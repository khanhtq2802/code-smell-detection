{"text": "<fim_prefix>        String group = qs.get(Constants.GROUP_KEY);\n        if (group != null && group.length() > 0) {\n            if ((COMMA_SPLIT_PATTERN.split(group)).length > 1 || \"*\".equals(group)) {\n                return doRefer(getMergeableCluster(), registry, type, url);\n            }\n        }\n        return doRefer(cluster, registry, type, url);\n    }\n    private Cluster getMergeableCluster() {\n        return ExtensionLoader.getExtensionLoader(Cluster.class).getExtension(\"mergeable\");\n    }\n    private <T> Invoker<T> doRefer(Cluster cluster, Registry registry, Class<T> type, URL url) {\n        RegistryDirectory<T> directory = new RegistryDirectory<T>(type, url);\n        directory.setRegistry(registry);\n        directory.setProtocol(protocol);\n        // all attributes of REFER_KEY\n        Map<String, String> parameters = new HashMap<String, String>(directory.getUrl().getParameters());\n        URL subscribeUrl = new URL(CONSUMER_PROTOCOL, parameters.remove(REGISTER_IP_KEY), 0, type.getName(), parameters);\n        if (!ANY_VALUE.equals(url.getServiceInterface()) && url.getParameter(REGISTER_KEY, true)) {\n            directory.setRegisteredConsumerUrl(getRegisteredConsumerUrl(subscribeUrl, url));\n            registry.register(directory.getRegisteredConsumerUrl());\n        }\n        directory.buildRouterChain(subscribeUrl);\n        directory.subscribe(subscribeUrl.addParameter(CATEGORY_KEY,\n                PROVIDERS_CATEGORY + \",\" + CONFIGURATORS_CATEGORY + \",\" + ROUTERS_CATEGORY));\n        Invoker invoker = cluster.join(directory);\n        ProviderConsumerRegTable.registerConsumer(invoker, url, subscribeUrl, directory);\n        return invoker;\n    }\n    public URL getRegisteredConsumerUrl(final URL consumerUrl, URL registryUrl) {\n        if (!registryUrl.getParameter(SIMPLIFIED_KEY, false)) {\n            return consumerUrl.addParameters(CATEGORY_KEY, CONSUMERS_CATEGORY,\n                    CHECK_KEY, String.valueOf(false));\n        } else {\n            return URL.valueOf(consumerUrl, DEFAULT_REGISTER_CONSUMER_KEYS, null).addParameters(\n                    CATEGORY_KEY, CONSUMERS_CATEGORY, CHECK_KEY, String.valueOf(false));\n        }\n    }\n    // available to test\n    public String[] getParamsToRegistry(String[] defaultKeys, String[] additionalParameterKeys) {\n        int additionalLen = additionalParameterKeys.length;\n        String[] registryParams = new String[defaultKeys.length + additionalLen];\n        System.arraycopy(defaultKeys, 0, registryParams, 0, defaultKeys.length);\n        System.arraycopy(additionalParameterKeys, 0, registryParams, defaultKeys.length, additionalLen);\n        return registryParams;\n    }\n    @Override\n    public void destroy() {\n        List<Exporter<?>> exporters = new ArrayList<Exporter<?>>(bounds.values());\n        for (Exporter<?> exporter : exporters) {\n            exporter.unexport();\n        }\n        bounds.clear();\n        DynamicConfiguration.getDynamicConfiguration()\n                .removeListener(ApplicationModel.getApplication() + CONFIGURATORS_SUFFIX, providerConfigurationListener);\n    }\n    //Merge the urls of configurators\n    private static URL getConfigedInvokerUrl(List<Configurator> configurators, URL url) {\n        if (configurators != null && configurators.size() > 0) {\n            for (Configurator configurator : configurators) {\n                url = configurator.configure(url);\n            }\n        }\n        return url;\n    }\n    public static class InvokerDelegate<T> extends InvokerWrapper<T> {\n        private final Invoker<T> invoker;\n        /**\n         * @param invoker\n         * @param url     invoker.getUrl return this value\n         */\n        public InvokerDelegate(Invoker<T> invoker, URL url) {\n            super(invoker, url);\n            this.invoker = invoker;\n        }\n        public Invoker<T> getInvoker() {\n            if (invoker instanceof InvokerDelegate) {\n                return ((InvokerDelegate<T>) invoker).getInvoker();\n            } else {\n                return invoker;\n            }\n        }\n    }\n    static private class DestroyableExporter<T> implements Exporter<T> {\n        private Exporter<T> exporter;\n        public DestroyableExporter(Exporter<T> exporter) {\n            this.exporter = exporter;\n        }\n        @Override\n        public Invoker<T> getInvoker() {\n            return exporter.getInvoker();\n        }\n        @Override\n        public void unexport() {\n            exporter.unexport();\n        }\n    }\n    /**\n     * Reexport: the exporter destroy problem in protocol\n     * 1.Ensure that the exporter returned by registryprotocol can be normal destroyed\n     * 2.No need to re-register to the registry after notify\n     * 3.The invoker passed by the export method , would better to be the invoker of exporter\n     */\n    private class OverrideListener implements NotifyListener {\n        private final URL subscribeUrl;\n        private final Invoker originInvoker;\n        private List<Configurator> configurators;\n        public OverrideListener(URL subscribeUrl, Invoker originalInvoker) {\n            this.subscribeUrl = subscribeUrl;\n            this.originInvoker = originalInvoker;\n        }\n        /**\n         * @param urls The list of registered information, is always not empty, The meaning is the same as the\n         *             return value of {@link org.apache.dubbo.registry.RegistryService#lookup(URL)}.\n         */\n        @Override\n        public synchronized void notify(List<URL> urls) {\n            logger.debug(\"original override urls: \" + urls);\n            List<URL> matchedUrls = getMatchedUrls(urls, subscribeUrl.addParameter(CATEGORY_KEY,\n                    CONFIGURATORS_CATEGORY));\n            logger.debug(\"subscribe url: \" + subscribeUrl + \", override urls: \" + matchedUrls);\n            // No matching results\n            if (matchedUrls.isEmpty()) {\n                return;\n            }\n            this.configurators = Configurator.toConfigurators(classifyUrls(matchedUrls, UrlUtils::isConfigurator))\n                    .orElse(configurators);\n            doOverrideIfNecessary();\n        }\n        public synchronized void doOverrideIfNecessary() {\n            final Invoker<?> invoker;\n            if (originInvoker instanceof InvokerDelegate) {\n                invoker = ((InvokerDelegate<?>) originInvoker).getInvoker();\n            } else {\n                invoker = originInvoker;\n            }\n            //The origin invoker\n            URL originUrl = RegistryProtocol.this.getProviderUrl(invoker);\n            String key = getCacheKey(originInvoker);\n            ExporterChangeableWrapper<?> exporter = bounds.get(key);\n            if (exporter == null) {\n                logger.warn(new IllegalStateException(\"error state, exporter should not be null\"));\n                return;\n            }\n            //The current, may have been merged many times\n            URL currentUrl = exporter.getInvoker().getUrl();\n            //Merged with this configuration\n            URL newUrl = getConfigedInvokerUrl(configurators, originUrl);\n            newUrl = getConfigedInvokerUrl(serviceConfigurationListeners.get(originUrl.getServiceKey())\n                    .getConfigurators(), newUrl);\n            newUrl = getConfigedInvokerUrl(providerConfigurationListener.getConfigurators(), newUrl);\n            if (!currentUrl.equals(newUrl)) {\n                RegistryProtocol.this.reExport(originInvoker, newUrl);\n                logger.info(\"exported provider url changed, origin url: \" + originUrl +\n                        \", old export url: \" + currentUrl + \", new export url: \" + newUrl);\n            }\n        }\n        private List<URL> getMatchedUrls(List<URL> configuratorUrls, URL currentSubscribe) {\n            List<URL> result = new ArrayList<URL>();\n            for (URL url : configuratorUrls) {\n                URL overrideUrl = url;\n                // Compatible with the old version\n                if (url.getParameter(CATEGORY_KEY) == null && OVERRIDE_PROTOCOL.equals(url.getProtocol())) {\n                    overrideUrl = url.addParameter(CATEGORY_KEY, CONFIGURATORS_CATEGORY);\n                }\n                // Check whether url is to be applied to the current service\n                if (UrlUtils.isMatch(currentSubscribe, overrideUrl)) {\n                    result.add(url);\n                }\n            }\n            return result;\n        }\n    }\n    private class ServiceConfigurationListener extends AbstractConfiguratorListener {\n        private URL providerUrl;\n        private OverrideListener notifyListener;\n        public ServiceConfigurationListener(URL providerUrl, OverrideListener notifyListener) {\n            this.providerUrl = providerUrl;\n            this.notifyListener = notifyListener;\n            this.initWith(providerUrl.getEncodedServiceKey() + CONFIGURATORS_SUFFIX);\n        }\n        private <T> URL overrideUrl(URL providerUrl) {\n            return RegistryProtocol.getConfigedInvokerUrl(configurators, providerUrl);\n        }\n<fim_suffix>        @Override\n        protected void notifyOverrides() {\n            notifyListener.doOverrideIfNecessary();\n        }<fim_middle>// function below has no smell\n"}