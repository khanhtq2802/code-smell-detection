{"text": "<fim_prefix>\n<fim_suffix>public class JpaEntityFactoryMetadata extends AbstractItdTypeDetailsProvidingMetadataItem {\n  private static final String INDEX_VAR = \"index\";\n  private static final JavaSymbolName INDEX_SYMBOL = new JavaSymbolName(INDEX_VAR);\n  private static final JavaSymbolName MAX_SYMBOL = new JavaSymbolName(\"max\");\n  private static final JavaSymbolName MIN_SYMBOL = new JavaSymbolName(\"min\");\n  private static final String OBJ_VAR = \"obj\";\n  private static final JavaSymbolName OBJ_SYMBOL = new JavaSymbolName(OBJ_VAR);\n  private static final JavaSymbolName VALUE = new JavaSymbolName(\"value\");\n  private static final JavaSymbolName CREATE_FACTORY_METHOD_NAME = new JavaSymbolName(\"create\");\n  public static final JavaSymbolName SPECIFIC_METHOD_PREFIX = new JavaSymbolName(\"getSpecific\");\n  private static final String PROVIDES_TYPE_STRING = JpaEntityFactoryMetadata.class.getName();\n  private static final String PROVIDES_TYPE = MetadataIdentificationUtils\n      .create(PROVIDES_TYPE_STRING);\n  public static String createIdentifier(final JavaType javaType, final LogicalPath path) {\n    return PhysicalTypeIdentifierNamingUtils.createIdentifier(PROVIDES_TYPE_STRING, javaType, path);\n  }\n  public static String createIdentifier(ClassOrInterfaceTypeDetails details) {\n    final LogicalPath logicalPath =\n        PhysicalTypeIdentifier.getPath(details.getDeclaredByMetadataId());\n    return createIdentifier(details.getType(), logicalPath);\n  }\n  public static JavaType getJavaType(final String metadataIdentificationString) {\n    return PhysicalTypeIdentifierNamingUtils.getJavaType(PROVIDES_TYPE_STRING,\n        metadataIdentificationString);\n  }\n  public static String getMetadataIdentiferType() {\n    return PROVIDES_TYPE;\n  }\n  public static LogicalPath getPath(final String metadataIdentificationString) {\n    return PhysicalTypeIdentifierNamingUtils.getPath(PROVIDES_TYPE_STRING,\n        metadataIdentificationString);\n  }\n  public static boolean isValid(final String metadataIdentificationString) {\n    return PhysicalTypeIdentifierNamingUtils.isValid(PROVIDES_TYPE_STRING,\n        metadataIdentificationString);\n  }\n  private JavaType entity;\n  private final List<JavaType> requiredDataOnDemandCollaborators = new ArrayList<JavaType>();\n  private MethodMetadata randomPersistentEntityMethod;\n  private final Map<FieldMetadata, Map<FieldMetadata, String>> embeddedFieldInitializers =\n      new LinkedHashMap<FieldMetadata, Map<FieldMetadata, String>>();\n  private final Map<FieldMetadata, String> fieldInitializers =\n      new LinkedHashMap<FieldMetadata, String>();\n  private EmbeddedIdHolder embeddedIdHolder;\n  private List<EmbeddedHolder> embeddedHolders;\n  private Map<FieldMetadata, JpaEntityFactoryMetadata> locatedFields;\n  private final MemberDetails entityMemberDetails;\n  /**\n   * Constructor\n   *\n   * @param identifier\n   * @param aspectName\n   * @param governorPhysicalTypeMetadata\n   * @param entity\n   * @param entityMemberDetails\n   * @param locatedFields\n   * @param embeddedHolder\n   * @param entityFactoryClasses\n   * @param embeddedIdHolder\n   */\n  public JpaEntityFactoryMetadata(final String identifier, final JavaType aspectName,\n      final PhysicalTypeMetadata governorPhysicalTypeMetadata, final JavaType entity,\n      MemberDetails entityMemberDetails,\n      final Map<FieldMetadata, JpaEntityFactoryMetadata> locatedFields,\n      final List<EmbeddedHolder> embeddedHolders,\n      Set<ClassOrInterfaceTypeDetails> entityFactoryClasses, final EmbeddedIdHolder embeddedIdHolder) {\n    super(identifier, aspectName, governorPhysicalTypeMetadata);\n    Validate.notNull(locatedFields, \"Located fields map required\");\n    Validate.notNull(embeddedHolders, \"Embedded holders list required\");\n    this.entity = entity;\n    this.entityMemberDetails = entityMemberDetails;\n    this.embeddedIdHolder = embeddedIdHolder;\n    this.embeddedHolders = embeddedHolders;\n    this.locatedFields = locatedFields;\n    builder.addMethod(getCreateMethod());\n    // Calculate and store field initializers\n    for (final Map.Entry<FieldMetadata, JpaEntityFactoryMetadata> entry : locatedFields.entrySet()) {\n      final FieldMetadata field = entry.getKey();\n      final String initializer = getFieldInitializer(field, entry.getValue(), entityFactoryClasses);\n      if (!StringUtils.isBlank(initializer)) {\n        this.fieldInitializers.put(field, initializer);\n      }\n    }\n    for (final EmbeddedHolder embeddedHolder : embeddedHolders) {\n      final Map<FieldMetadata, String> initializers = new LinkedHashMap<FieldMetadata, String>();\n      for (final FieldMetadata field : embeddedHolder.getFields()) {\n        initializers.put(field, getFieldInitializer(field, null, entityFactoryClasses));\n      }\n      this.embeddedFieldInitializers.put(embeddedHolder.getEmbeddedField(), initializers);\n    }\n    for (final EmbeddedHolder embeddedHolder : embeddedHolders) {\n      builder.addMethod(getEmbeddedClassMutatorMethod(embeddedHolder));\n      addEmbeddedClassFieldMutatorMethodsToBuilder(embeddedHolder, entityFactoryClasses);\n    }\n    for (final MethodMetadataBuilder fieldInitializerMethod : getFieldMutatorMethods()) {\n      builder.addMethod(fieldInitializerMethod);\n    }\n    addCollaboratingFieldsToBuilder(entityFactoryClasses);\n    builder.addMethod(getEmbeddedIdMutatorMethod(entityFactoryClasses));\n    itdTypeDetails = builder.build();\n  }\n  private void addCollaboratingFieldsToBuilder(\n      final Set<ClassOrInterfaceTypeDetails> entityFactoryClasses) {\n    final Set<JavaSymbolName> fields = new LinkedHashSet<JavaSymbolName>();\n    for (final JavaType entityNeedingCollaborator : this.requiredDataOnDemandCollaborators) {\n      final JavaType collaboratorType =\n          getCollaboratingType(entityNeedingCollaborator, entityFactoryClasses);\n      if (collaboratorType != null) {\n        final String collaboratingFieldName =\n            getCollaboratingFieldName(entityNeedingCollaborator, entityFactoryClasses)\n                .getSymbolName();\n        final JavaSymbolName fieldSymbolName = new JavaSymbolName(collaboratingFieldName);\n        final FieldMetadata candidate = governorTypeDetails.getField(fieldSymbolName);\n        if (candidate != null) {\n          // We really expect the field to be correct if we're going to\n          // rely on it\n          Validate\n              .isTrue(candidate.getFieldType().equals(collaboratorType),\n                  \"Field '%s' on '%s' must be of type '%s'\", collaboratingFieldName,\n                  destination.getFullyQualifiedTypeName(),\n                  collaboratorType.getFullyQualifiedTypeName());\n          Validate.isTrue(Modifier.isPrivate(candidate.getModifier()),\n              \"Field '%s' on '%s' must be private\", collaboratingFieldName,\n              destination.getFullyQualifiedTypeName());\n          Validate.notNull(\n              MemberFindingUtils.getAnnotationOfType(candidate.getAnnotations(), AUTOWIRED),\n              \"Field '%s' on '%s' must be @Autowired\", collaboratingFieldName,\n              destination.getFullyQualifiedTypeName());\n          // It's ok, so we can move onto the new field\n          continue;\n        }\n        // Create field and add it to the ITD, if it hasn't already been\n        if (!fields.contains(fieldSymbolName)) {\n          // Must make the field\n          final List<AnnotationMetadataBuilder> annotations =\n              new ArrayList<AnnotationMetadataBuilder>();\n          annotations.add(new AnnotationMetadataBuilder(AUTOWIRED));\n          builder.addField(new FieldMetadataBuilder(getId(), 0, annotations, fieldSymbolName,\n              collaboratorType));\n          fields.add(fieldSymbolName);\n        }\n      }\n    }\n  }\n  private void addEmbeddedClassFieldMutatorMethodsToBuilder(final EmbeddedHolder embeddedHolder,\n      final Set<ClassOrInterfaceTypeDetails> dataOnDemandClasses) {\n    final JavaType embeddedFieldType = embeddedHolder.getEmbeddedField().getFieldType();\n    final JavaType[] parameterTypes = {embeddedFieldType, JavaType.INT_PRIMITIVE};\n    final List<JavaSymbolName> parameterNames = Arrays.asList(OBJ_SYMBOL, INDEX_SYMBOL);\n    for (final FieldMetadata field : embeddedHolder.getFields()) {\n      final String initializer = getFieldInitializer(field, null, dataOnDemandClasses);\n      final JavaSymbolName fieldMutatorMethodName =\n          BeanInfoUtils.getMutatorMethodName(field.getFieldName());\n      final InvocableMemberBodyBuilder bodyBuilder = new InvocableMemberBodyBuilder();\n      bodyBuilder.append(getFieldValidationBody(field, initializer, fieldMutatorMethodName, false));\n      final JavaSymbolName embeddedClassMethodName =\n          getEmbeddedFieldMutatorMethodName(embeddedHolder.getEmbeddedField().getFieldName(),\n              field.getFieldName());\n      if (governorHasMethod(embeddedClassMethodName, parameterTypes)) {\n        // Method found in governor so do not create method in ITD\n        continue;\n      }\n      builder.addMethod(new MethodMetadataBuilder(getId(), Modifier.PUBLIC,\n          embeddedClassMethodName, JavaType.VOID_PRIMITIVE, AnnotatedJavaType\n              .convertFromJavaTypes(parameterTypes), parameterNames, bodyBuilder));\n    }\n  }<fim_middle>// class below is blob\n"}