{"text": "<fim_prefix>    private RomeNotificationReceiver mNotificationReceiver;\n    private ConnectedDevicesPlatform mPlatform;\n    private static ConnectedDevicesManager sConnectedDevicesManager;\n    // endregion\n    // region Constructors\n    /**\n     * This is a singleton object which holds onto the app's ConnectedDevicesPlatform and handles account management. \n     * @param context Application context\n     */\n    private ConnectedDevicesManager(Context context) {\n        // Initialize list of known accounts\n        mAccounts = new ArrayList<Account>();\n        // Create the NotificationReceiver\n        mNotificationReceiver = new RomeNotificationReceiver(context);\n        // Create Platform\n        mPlatform = new ConnectedDevicesPlatform(context);\n        // Create a final reference to the list of accounts\n        final List<Account> accounts = mAccounts;\n        // Subscribe to the AccessTokenRequested event\n        mPlatform.getAccountManager().accessTokenRequested().subscribe((accountManager, args) -> onAccessTokenRequested(accountManager, args, accounts));\n        // Subscribe to AccessTokenInvalidated event\n        mPlatform.getAccountManager().accessTokenInvalidated().subscribe((accountManager, args) -> onAccessTokenInvalidated(accountManager, args, accounts));\n        // Subscribe to NotificationRegistrationStateChanged event\n        mPlatform.getNotificationRegistrationManager().notificationRegistrationStateChanged().subscribe((notificationRegistrationManager, args) -> onNotificationRegistrationStateChanged(notificationRegistrationManager, args, accounts));\n        // Start the platform as we have subscribed to the events it can raise\n        mPlatform.start();\n        // Pull the accounts from our app's cache and synchronize the list with the apps cached by \n        // ConnectedDevicesPlatform.AccountManager.\n        List<Account> deserializedAccounts = deserializeAccounts(context);\n        // Finally initialize the accounts. This will refresh registrations when needed, add missing accounts,\n        // and remove stale accounts from the ConnectedDevicesPlatform AccountManager. The AsyncOperation associated\n        // with all of this asynchronous work need not be waited on as any sub component work will be accomplished\n        // in the synchronous portion of the call. If your app needs to sequence when other apps can see this app's registration\n        // (i.e. when RemoteSystemAppRegistration SaveAsync completes) then it would be useful to use the AsyncOperation returned by\n        // prepareAccountsAsync\n        prepareAccounts(deserializedAccounts, context);\n    }\n    // endregion\n    // region public static methods\n    public static synchronized ConnectedDevicesManager getConnectedDevicesManager(Context context) {\n        if (sConnectedDevicesManager == null) {\n            sConnectedDevicesManager = new ConnectedDevicesManager(context);\n        }\n        return sConnectedDevicesManager;\n    }\n    // endregion\n    // region public instance methods\n    /**\n     * Get the ConnectedDevicesPlatform owned by this ConnectedDevicesManager.\n     * @return Platform\n     */\n    public ConnectedDevicesPlatform getPlatform() {\n        return mPlatform;\n    }\n    /**\n     * Attempt to ensure there is a signed in MSA Account\n     * @param activity Application activity\n     * @return The async result for when this operation completes\n     */\n    public synchronized AsyncOperation<Boolean> signInMsaAsync(final Activity activity) {\n        // Create a SigninHelperAccount with a client id for msa, a map of requested scopes to override, and the context\n        final Map<String, String[]> msaScopeOverrides = new ArrayMap<>();\n        msaScopeOverrides.put(\"https://activity.windows.com/UserActivity.ReadWrite.CreatedByApp\",\n                new String[] { \"https://activity.windows.com/UserActivity.ReadWrite.CreatedByApp\",\n                        \"https://activity.windows.com/Notifications.ReadWrite.CreatedByApp\"});\n        SigninHelperAccount signInHelper = new MSASigninHelperAccount(Secrets.MSA_CLIENT_ID, msaScopeOverrides, (Context)activity);\n        if (signInHelper.isSignedIn()) {\n            Log.i(TAG, \"Already signed in with a MSA account\");\n            return AsyncOperation.completedFuture(true);\n        }\n        Log.i(TAG, \"Signing in with a MSA account\");\n        // Call signIn, which may prompt the user to enter credentials or just retreive a cached token if they exist and are valid\n        return signInHelper.signIn(activity).thenComposeAsync((ConnectedDevicesAccount account) -> {\n            // Prepare the account, adding it to the list of app's cached accounts is prepared successfully\n            return prepareAccountAsync(new Account(signInHelper, AccountRegistrationState.IN_APP_CACHE_ONLY, mPlatform), (Context)activity);\n        });\n    }\n    /**\n     * Attempt to ensure there is a signed in MSA Account\n     * @param activity Application activity\n     * @return The async result for when this operation completes\n     */\n    public synchronized AsyncOperation<Boolean> signInAadAsync(final Activity activity) {\n        // Create a SigninHelperAccount with a client id for msa, a map of requested scopes to override, and the context\n        SigninHelperAccount signInHelper = new AADSigninHelperAccount(Secrets.AAD_CLIENT_ID, Secrets.AAD_REDIRECT_URI, (Context)activity);\n        if (signInHelper.isSignedIn()) {\n            Log.i(TAG, \"Already signed in with a AAD account\");\n            return AsyncOperation.completedFuture(true);\n        }\n        Log.i(TAG, \"Signing in in with a AAD account\");\n        // Call signIn, which may prompt the user to enter credentials or just retreive a cached token if they exist and are valid\n        return signInHelper.signIn(activity).thenComposeAsync((ConnectedDevicesAccount account) -> {\n            // Prepare the account, adding it to the list of app's cached accounts is prepared successfully\n            return prepareAccountAsync(new Account(signInHelper, AccountRegistrationState.IN_APP_CACHE_ONLY, mPlatform), (Context)activity);\n        });\n    }\n    /**\n     * Sign out and remove the given Account from the ConnectedDevicesManager\n     * @param activity Application activity\n     * @return The async result for when this operation completes\n     */\n    public synchronized AsyncOperation<Boolean> logout(Activity activity) {\n        // First remove this account from the list of \"ready to go\" accounts so it cannot be used while logging out\n        Account accountToRemove = getSignedInAccount();\n        mAccounts.remove(accountToRemove);\n        // Now log out this account\n        return accountToRemove.logoutAsync(activity).thenComposeAsync((ConnectedDevicesAccount account) -> {\n            Log.i(TAG, \"Successfully signed out account: \" + account.getId());\n            return AsyncOperation.completedFuture(true);\n        });\n    }\n    /**\n     * Get a list of \"ready-to-go\" accounts owned by this ConnectedDevicesManager.\n     * @return accounts\n     */\n    public Account getSignedInAccount() {\n        // Compare the app cached account to find a match in the sdk cached accounts\n        if (mAccounts.size() > 0) {\n            return mAccounts.get(0);\n        }\n        Log.e(TAG, \"No signed in account found!\");\n        return null;\n    }\n    /**\n     * Create a NotificationRegistration using the notification token gained from GCM/FCM.\n     * @param token Notification token gained by the BroadcastReceiver\n     */\n<fim_suffix>    public synchronized void setNotificationRegistration(final String token) {\n        // Get the NotificationRegistrationManager from the platform\n        ConnectedDevicesNotificationRegistrationManager registrationManager = mPlatform.getNotificationRegistrationManager();\n        // Create a NotificationRegistration obect to store all notification information\n        ConnectedDevicesNotificationRegistration registration = new ConnectedDevicesNotificationRegistration();\n        registration.setType(ConnectedDevicesNotificationType.FCM);\n        registration.setToken(token);\n        registration.setAppId(Secrets.FCM_SENDER_ID);\n        registration.setAppDisplayName(\"GraphNotificationsSample\");\n        Log.i(TAG, \"Completing the RomeNotificationReceiver operation with token: \" + token);\n        // For each prepared account, register for notifications\n        for (final Account account : mAccounts) {\n            registrationManager.registerForAccountAsync(account.getAccount(), registration)\n                    .whenCompleteAsync((Boolean success, Throwable throwable) -> {\n                        if (throwable != null) {\n                            Log.e(TAG, \"Exception encountered in registerForAccountAsync\", throwable);\n                        } else if (!success) {\n                            Log.e(TAG, \"Failed to register account \" + account.getAccount().getId() + \" for cloud notifications!\");\n                        } else {\n                            Log.i(TAG, \"Successfully registered account \" + account.getAccount().getId() + \" for cloud notifications\");\n                        }\n                    });\n        }\n        // The two cases of receiving a new notification token are:\n        // 1. A notification registration is asked for and now it is available. In this case there is a pending promise that was made\n        //    at the time of requesting the information. It now needs to be completed.\n        // 2. The account is already registered but for whatever reason the registration changes (GCM/FCM gives the app a new token)\n        //\n        // In order to most cleanly handle both cases set the new notification information and then trigger a re registration of all accounts\n        // that are in good standing.\n        RomeNotificationReceiver.setNotificationRegistration(registration);\n        // For all the accounts which have been prepared successfully, perform SDK registration\n        for (Account account : mAccounts) {\n            if (account.getRegistrationState() == AccountRegistrationState.IN_APP_CACHE_AND_SDK_CACHE) {\n                account.registerAccountWithSdkAsync();\n            }\n        }\n    }<fim_middle>// function below is long method and feature envy\n"}