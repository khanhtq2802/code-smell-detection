{"text": "<fim_prefix>/*\n * Copyright 1999-2018 Alibaba Group Holding Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.alibaba.druid.sql.dialect.sqlserver.parser;\n\nimport com.alibaba.druid.sql.ast.SQLExpr;\nimport com.alibaba.druid.sql.ast.SQLObject;\nimport com.alibaba.druid.sql.ast.SQLSetQuantifier;\nimport com.alibaba.druid.sql.ast.statement.SQLExprHint;\nimport com.alibaba.druid.sql.ast.statement.SQLExprTableSource;\nimport com.alibaba.druid.sql.ast.statement.SQLSelect;\nimport com.alibaba.druid.sql.ast.statement.SQLSelectQuery;\nimport com.alibaba.druid.sql.ast.statement.SQLTableSource;\nimport com.alibaba.druid.sql.ast.statement.SQLWithSubqueryClause;\nimport com.alibaba.druid.sql.dialect.sqlserver.ast.SQLServerSelectQueryBlock;\nimport com.alibaba.druid.sql.dialect.sqlserver.ast.SQLServerTop;\nimport com.alibaba.druid.sql.parser.ParserException;\nimport com.alibaba.druid.sql.parser.SQLExprParser;\nimport com.alibaba.druid.sql.parser.SQLSelectListCache;\nimport com.alibaba.druid.sql.parser.SQLSelectParser;\nimport com.alibaba.druid.sql.parser.Token;\n\n<fim_suffix>public class SQLServerSelectParser extends SQLSelectParser {\n\n    public SQLServerSelectParser(String sql){\n        super(new SQLServerExprParser(sql));\n    }\n\n    public SQLServerSelectParser(SQLExprParser exprParser){\n        super(exprParser);\n    }\n\n    public SQLServerSelectParser(SQLExprParser exprParser, SQLSelectListCache selectListCache){\n        super(exprParser, selectListCache);\n    }\n\n    public SQLSelect select() {\n        SQLSelect select = new SQLSelect();\n\n        if (lexer.token() == Token.WITH) {\n            SQLWithSubqueryClause with = this.parseWith();\n            select.setWithSubQuery(with);\n        }\n\n        select.setQuery(query());\n        select.setOrderBy(parseOrderBy());\n\n        if (select.getOrderBy() == null) {\n            select.setOrderBy(parseOrderBy());\n        }\n\n        if (lexer.token() == Token.FOR) {\n            lexer.nextToken();\n\n            if (lexer.identifierEquals(\"BROWSE\")) {\n                lexer.nextToken();\n                select.setForBrowse(true);\n            } else if (lexer.identifierEquals(\"XML\")) {\n                lexer.nextToken();\n\n                for (;;) {\n                    if (lexer.identifierEquals(\"AUTO\") //\n                        || lexer.identifierEquals(\"TYPE\") //\n                        || lexer.identifierEquals(\"XMLSCHEMA\") //\n                    ) {\n                        select.getForXmlOptions().add(lexer.stringVal());\n                        lexer.nextToken();\n                    } else if (lexer.identifierEquals(\"ELEMENTS\")) {\n                        lexer.nextToken();\n                        if (lexer.identifierEquals(\"XSINIL\")) {\n                            lexer.nextToken();\n                            select.getForXmlOptions().add(\"ELEMENTS XSINIL\");\n                        } else {\n                            select.getForXmlOptions().add(\"ELEMENTS\");\n                        }\n                    } else if (lexer.identifierEquals(\"PATH\")) {\n                        SQLExpr xmlPath = this.exprParser.expr();\n                        select.setXmlPath(xmlPath);\n                    } else {\n                        break;\n                    }\n                    \n                    if (lexer.token() == Token.COMMA) {\n                        lexer.nextToken();\n                        continue;\n                    } else {\n                        break;\n                    }\n                }\n            } else {\n                throw new ParserException(\"syntax error, not support option : \" + lexer.token() + \", \" + lexer.info());\n            }\n        }\n        \n        if (lexer.identifierEquals(\"OFFSET\")) {\n            lexer.nextToken();\n            SQLExpr offset = this.expr();\n            \n            acceptIdentifier(\"ROWS\");\n            select.setOffset(offset);\n            \n            if (lexer.token() == Token.FETCH) {\n                lexer.nextToken();\n                acceptIdentifier(\"NEXT\");\n                \n                SQLExpr rowCount = expr();\n                acceptIdentifier(\"ROWS\");\n                acceptIdentifier(\"ONLY\");\n                select.setRowCount(rowCount);\n            }\n        }\n\n        return select;\n    }\n\n    public SQLSelectQuery query(SQLObject parent, boolean acceptUnion) {\n        if (lexer.token() == Token.LPAREN) {\n            lexer.nextToken();\n\n            SQLSelectQuery select = query();\n            accept(Token.RPAREN);\n\n            return queryRest(select, acceptUnion);\n        }\n\n        SQLServerSelectQueryBlock queryBlock = new SQLServerSelectQueryBlock();\n\n        if (lexer.token() == Token.SELECT) {\n            lexer.nextToken();\n\n            if (lexer.token() == Token.COMMENT) {\n                lexer.nextToken();\n            }\n\n            if (lexer.token() == Token.DISTINCT) {\n                queryBlock.setDistionOption(SQLSetQuantifier.DISTINCT);\n                lexer.nextToken();\n            } else if (lexer.token() == Token.ALL) {\n                queryBlock.setDistionOption(SQLSetQuantifier.ALL);\n                lexer.nextToken();\n            }\n\n            if (lexer.token() == Token.TOP) {\n                SQLServerTop top = this.createExprParser().parseTop();\n                queryBlock.setTop(top);\n            }\n\n            parseSelectList(queryBlock);\n        }\n\n        if (lexer.token() == Token.INTO) {\n            lexer.nextToken();\n\n            SQLTableSource into = this.parseTableSource();\n            queryBlock.setInto((SQLExprTableSource) into);\n        }\n\n        parseFrom(queryBlock);\n\n        parseWhere(queryBlock);\n\n        parseGroupBy(queryBlock);\n\n        queryBlock.setOrderBy(this.exprParser.parseOrderBy());\n\n        parseFetchClause(queryBlock);\n\n        return queryRest(queryBlock, acceptUnion);\n    }\n\n    protected SQLServerExprParser createExprParser() {\n        return new SQLServerExprParser(lexer);\n    }\n\n    protected SQLTableSource parseTableSourceRest(SQLTableSource tableSource) {\n        if (lexer.token() == Token.WITH) {\n            lexer.nextToken();\n            accept(Token.LPAREN);\n\n            for (;;) {\n                SQLExpr expr = this.expr();\n                SQLExprHint hint = new SQLExprHint(expr);\n                hint.setParent(tableSource);\n                tableSource.getHints().add(hint);\n                if (lexer.token() == Token.COMMA) {\n                    lexer.nextToken();\n                    continue;\n                } else {\n                    break;\n                }\n            }\n\n            accept(Token.RPAREN);\n        }\n\n        return super.parseTableSourceRest(tableSource);\n    }\n}<fim_middle>// class below has no smell\n"}