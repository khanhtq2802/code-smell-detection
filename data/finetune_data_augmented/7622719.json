{"text": "<fim_prefix>\t\tif (parameterTypes.length != arguments.size()) {\n\t\t\treturn null;\n\t\t}\n\t\tint index = arguments.indexOf(assignedExpression);\n\t\tif (index == -1) {\n\t\t\treturn null;\n\t\t}\n\t\tITypeBinding expressionBinding = assignedExpression.resolveTypeBinding();\n\t\tif (expressionBinding != null && !expressionBinding.isAssignmentCompatible(parameterTypes[index])) {\n\t\t\treturn null;\n\t\t}\n\t\ttry {\n\t\t\tIJavaElement javaElement = binding.getJavaElement();\n\t\t\tif (javaElement instanceof IMethod) {\n\t\t\t\tIMethod method = (IMethod) javaElement;\n\t\t\t\tif (method.getOpenable().getBuffer() != null) { // avoid dummy\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// names and\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// lookup from\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Javadoc\n\t\t\t\t\tString[] parameterNames = method.getParameterNames();\n\t\t\t\t\tif (index < parameterNames.length) {\n\t\t\t\t\t\treturn NamingConventions.getBaseName(NamingConventions.VK_PARAMETER, parameterNames[index],\n\t\t\t\t\t\t\t\tmethod.getJavaProject());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (JavaModelException e) {\n\t\t\t// ignore\n\t\t}\n\t\treturn null;\n\t}\n\tprivate static String getBaseNameFromLocationInParent(Expression assignedExpression) {\n\t\tStructuralPropertyDescriptor location = assignedExpression.getLocationInParent();\n\t\tif (location == MethodInvocation.ARGUMENTS_PROPERTY) {\n\t\t\tMethodInvocation parent = (MethodInvocation) assignedExpression.getParent();\n\t\t\treturn getBaseNameFromLocationInParent(assignedExpression, parent.arguments(),\n\t\t\t\t\tparent.resolveMethodBinding());\n\t\t}\n\t\telse if (location == ClassInstanceCreation.ARGUMENTS_PROPERTY) {\n\t\t\tClassInstanceCreation parent = (ClassInstanceCreation) assignedExpression.getParent();\n\t\t\treturn getBaseNameFromLocationInParent(assignedExpression, parent.arguments(),\n\t\t\t\t\tparent.resolveConstructorBinding());\n\t\t}\n\t\telse if (location == SuperMethodInvocation.ARGUMENTS_PROPERTY) {\n\t\t\tSuperMethodInvocation parent = (SuperMethodInvocation) assignedExpression.getParent();\n\t\t\treturn getBaseNameFromLocationInParent(assignedExpression, parent.arguments(),\n\t\t\t\t\tparent.resolveMethodBinding());\n\t\t}\n\t\telse if (location == ConstructorInvocation.ARGUMENTS_PROPERTY) {\n\t\t\tConstructorInvocation parent = (ConstructorInvocation) assignedExpression.getParent();\n\t\t\treturn getBaseNameFromLocationInParent(assignedExpression, parent.arguments(),\n\t\t\t\t\tparent.resolveConstructorBinding());\n\t\t}\n\t\telse if (location == SuperConstructorInvocation.ARGUMENTS_PROPERTY) {\n\t\t\tSuperConstructorInvocation parent = (SuperConstructorInvocation) assignedExpression.getParent();\n\t\t\treturn getBaseNameFromLocationInParent(assignedExpression, parent.arguments(),\n\t\t\t\t\tparent.resolveConstructorBinding());\n\t\t}\n\t\treturn null;\n\t}\n\tpublic static String[] getArgumentNameSuggestions(IType type, String[] excluded) {\n\t\treturn getVariableNameSuggestions(NamingConventions.VK_PARAMETER, type.getJavaProject(), type.getElementName(),\n\t\t\t\t0, new ExcludedCollection(excluded), true);\n\t}\n\tpublic static String[] getArgumentNameSuggestions(IJavaProject project, Type type, String[] excluded) {\n\t\treturn getVariableNameSuggestions(NamingConventions.VK_PARAMETER, project, type,\n\t\t\t\tnew ExcludedCollection(excluded), true);\n\t}\n\tpublic static String[] getArgumentNameSuggestions(IJavaProject project, ITypeBinding binding, String[] excluded) {\n\t\treturn getVariableNameSuggestions(NamingConventions.VK_PARAMETER, project, binding, null,\n\t\t\t\tnew ExcludedCollection(excluded));\n\t}\n\tpublic static String[] getArgumentNameSuggestions(IJavaProject project, String baseName, int dimensions,\n\t\t\tString[] excluded) {\n\t\treturn getVariableNameSuggestions(NamingConventions.VK_PARAMETER, project, baseName, dimensions,\n\t\t\t\tnew ExcludedCollection(excluded), true);\n\t}\n\tpublic static String[] getFieldNameSuggestions(IType type, int fieldModifiers, String[] excluded) {\n\t\treturn getFieldNameSuggestions(type.getJavaProject(), type.getElementName(), 0, fieldModifiers, excluded);\n\t}\n\tpublic static String[] getFieldNameSuggestions(IJavaProject project, String baseName, int dimensions, int modifiers,\n\t\t\tString[] excluded) {\n\t\tif (Flags.isFinal(modifiers) && Flags.isStatic(modifiers)) {\n\t\t\treturn getVariableNameSuggestions(NamingConventions.VK_STATIC_FINAL_FIELD, project, baseName, dimensions,\n\t\t\t\t\tnew ExcludedCollection(excluded), true);\n\t\t}\n\t\telse if (Flags.isStatic(modifiers)) {\n\t\t\treturn getVariableNameSuggestions(NamingConventions.VK_STATIC_FIELD, project, baseName, dimensions,\n\t\t\t\t\tnew ExcludedCollection(excluded), true);\n\t\t}\n\t\treturn getVariableNameSuggestions(NamingConventions.VK_INSTANCE_FIELD, project, baseName, dimensions,\n\t\t\t\tnew ExcludedCollection(excluded), true);\n\t}\n\tpublic static String[] getLocalNameSuggestions(IJavaProject project, String baseName, int dimensions,\n\t\t\tString[] excluded) {\n\t\treturn getVariableNameSuggestions(NamingConventions.VK_LOCAL, project, baseName, dimensions,\n\t\t\t\tnew ExcludedCollection(excluded), true);\n\t}\n\tpublic static String suggestArgumentName(IJavaProject project, String baseName, String[] excluded) {\n\t\treturn suggestVariableName(NamingConventions.VK_PARAMETER, project, baseName, 0, excluded);\n\t}\n\tprivate static String suggestVariableName(int varKind, IJavaProject project, String baseName, int dimension,\n\t\t\tString[] excluded) {\n\t\treturn getVariableNameSuggestions(varKind, project, baseName, dimension, new ExcludedCollection(excluded),\n\t\t\t\ttrue)[0];\n\t}\n\tpublic static String[][] suggestArgumentNamesWithProposals(IJavaProject project, String[] paramNames) {\n\t\tString[][] newNames = new String[paramNames.length][];\n\t\tArrayList<String> takenNames = new ArrayList<>();\n\t\t// Ensure that the code generation preferences are respected\n\t\tfor (int i = 0; i < paramNames.length; i++) {\n\t\t\tString curr = paramNames[i];\n\t\t\tString baseName = NamingConventions.getBaseName(NamingConventions.VK_PARAMETER, curr, project);\n\t\t\tString[] proposedNames = getVariableNameSuggestions(NamingConventions.VK_PARAMETER, project, curr, 0,\n\t\t\t\t\ttakenNames, true);\n\t\t\tif (!curr.equals(baseName)) {\n\t\t\t\t// make the existing name to favorite\n\t\t\t\tLinkedHashSet<String> updatedNames = new LinkedHashSet<>();\n\t\t\t\tupdatedNames.add(curr);\n\t\t\t\tfor (int k = 0; k < proposedNames.length; k++) {\n\t\t\t\t\tupdatedNames.add(proposedNames[k]);\n\t\t\t\t}\n\t\t\t\tproposedNames = updatedNames.toArray(new String[updatedNames.size()]);\n\t\t\t}\n\t\t\tnewNames[i] = proposedNames;\n\t\t\ttakenNames.add(proposedNames[0]);\n\t\t}\n\t\treturn newNames;\n\t}\n<fim_suffix>\tpublic static String[][] suggestArgumentNamesWithProposals(IJavaProject project, IMethodBinding binding) {\n\t\tint nParams = binding.getParameterTypes().length;\n\t\tif (nParams > 0) {\n\t\t\ttry {\n\t\t\t\tIMethod method = (IMethod) binding.getMethodDeclaration().getJavaElement();\n\t\t\t\tif (method != null) {\n\t\t\t\t\tString[] parameterNames = method.getParameterNames();\n\t\t\t\t\tif (parameterNames.length == nParams) {\n\t\t\t\t\t\treturn suggestArgumentNamesWithProposals(project, parameterNames);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (JavaModelException e) {\n\t\t\t\t// ignore\n\t\t\t}\n\t\t}\n\t\tString[][] names = new String[nParams][];\n\t\tfor (int i = 0; i < names.length; i++) {\n\t\t\tnames[i] = new String[] { \"arg\" + i }; //$NON-NLS-1$\n\t\t}\n\t\treturn names;\n\t}<fim_middle>// function below has no smell\n"}