{"text": "<fim_prefix>\n<fim_suffix>@ThreadConfined(ANY)\npublic final class ChangeSet {\n  private final List<Change> mChanges;\n  private Section mSection;\n  @Nullable private ChangeSetStats mChangeSetStats;\n  private int mFinalCount;\n  private ChangeSet() {\n    mChanges = new ArrayList<>();\n  }\n  /**\n   * @return the {@link Change} at index.\n   */\n  public Change getChangeAt(int index) {\n    return mChanges.get(index);\n  }\n  /**\n   * @return the number of {@link Change}s in this ChangeSet.\n   */\n  public int getChangeCount() {\n    return mChanges.size();\n  }\n  List<Change> getChanges() {\n    return mChanges;\n  }\n  /**\n   * Add a new Change to this ChangeSet. This is what a {@link DiffSectionSpec} would call in its\n   * {@link OnDiff} method to append a {@link Change}.\n   */\n  @VisibleForTesting(otherwise = VisibleForTesting.PACKAGE_PRIVATE)\n  public void addChange(Change change) {\n    mChanges.add(change);\n    final int changeDelta = getChangeDelta(change);\n    mFinalCount += changeDelta;\n    if (mChangeSetStats != null) {\n      mChangeSetStats = mChangeSetStats.merge(ChangeSetStats.fromChange(change, changeDelta));\n    }\n  }\n  private static int getChangeDelta(Change change) {\n    int changeDelta = 0;\n    switch (change.getType()) {\n      case INSERT:\n        changeDelta = 1;\n        break;\n      case INSERT_RANGE:\n        changeDelta = change.getCount();\n        break;\n      case DELETE:\n        changeDelta = -1;\n        break;\n      case DELETE_RANGE:\n        changeDelta = -change.getCount();\n        break;\n      case UPDATE:\n      case UPDATE_RANGE:\n      case MOVE:\n      default:\n        break;\n    }\n    return changeDelta;\n  }\n  public void insert(int index, RenderInfo renderInfo, @Nullable TreeProps treeProps) {\n    insert(index, renderInfo, treeProps, null);\n  }\n  public void insert(\n      int index, RenderInfo renderInfo, @Nullable TreeProps treeProps, @Nullable Object data) {\n    // Null check for tests only. This should never be the case otherwise.\n    if (mSection != null) {\n      renderInfo.addDebugInfo(SectionsDebugParams.SECTION_GLOBAL_KEY, mSection.getGlobalKey());\n    }\n    addChange(Change.insert(index, new TreePropsWrappedRenderInfo(renderInfo, treeProps), data));\n  }\n  public void insertRange(\n      int index, int count, List<RenderInfo> renderInfos, @Nullable TreeProps treeProps) {\n    insertRange(index, count, renderInfos, treeProps, null);\n  }\n  public void insertRange(\n      int index,\n      int count,\n      List<RenderInfo> renderInfos,\n      @Nullable TreeProps treeProps,\n      @Nullable List<?> data) {\n    // Null check for tests only. This should never be the case otherwise.\n    if (mSection != null) {\n      for (int i = 0, size = renderInfos.size(); i < size; i++) {\n        renderInfos\n            .get(i)\n            .addDebugInfo(SectionsDebugParams.SECTION_GLOBAL_KEY, mSection.getGlobalKey());\n      }\n    }\n    addChange(\n        Change.insertRange(index, count, wrapTreePropRenderInfos(renderInfos, treeProps), data));\n  }\n  public void update(int index, RenderInfo renderInfo, @Nullable TreeProps treeProps) {\n    update(index, renderInfo, treeProps, null, null);\n  }\n  public void update(\n      int index,\n      RenderInfo renderInfo,\n      @Nullable TreeProps treeProps,\n      @Nullable Object prevData,\n      @Nullable Object nextData) {\n    addChange(\n        Change.update(\n            index, new TreePropsWrappedRenderInfo(renderInfo, treeProps), prevData, nextData));\n  }\n  public void updateRange(\n      int index, int count, List<RenderInfo> renderInfos, @Nullable TreeProps treeProps) {\n    updateRange(index, count, renderInfos, treeProps, null, null);\n  }\n  public void updateRange(\n      int index,\n      int count,\n      List<RenderInfo> renderInfos,\n      @Nullable TreeProps treeProps,\n      @Nullable List<?> prevData,\n      @Nullable List<?> nextData) {\n    addChange(\n        Change.updateRange(\n            index, count, wrapTreePropRenderInfos(renderInfos, treeProps), prevData, nextData));\n  }\n  public void delete(int index) {\n    delete(index, null);\n  }\n  public void delete(int index, @Nullable Object data) {\n    addChange(Change.remove(index, data));\n  }\n  public void deleteRange(int index, int count) {\n    deleteRange(index, count, null);\n  }\n  public void deleteRange(int index, int count, @Nullable List<?> data) {\n    addChange(Change.removeRange(index, count, data));\n  }\n  public void move(int fromIndex, int toIndex) {\n    move(fromIndex, toIndex, null);\n  }\n  public void move(int fromIndex, int toIndex, @Nullable Object data) {\n    addChange(Change.move(fromIndex, toIndex, data));\n  }\n  /**\n   * @return the total number of items in the {@link Target}\n   * after this ChangeSet will be applied.\n   */\n  int getCount() {\n    return mFinalCount;\n  }\n  @Nullable\n  public ChangeSetStats getChangeSetStats() {\n    return mChangeSetStats;\n  }\n  /** @return an empty ChangeSet. */\n  @VisibleForTesting(otherwise = VisibleForTesting.PACKAGE_PRIVATE)\n  public static ChangeSet acquireChangeSet(Section section, boolean enableStats) {\n    return acquireChangeSet(0, section, enableStats);\n  }\n  /** @return an empty ChangeSet starting from count startCount. */\n  static ChangeSet acquireChangeSet(int startCount, Section section, boolean enableStats) {\n    final ChangeSet changeSet = acquire();\n    changeSet.mFinalCount = startCount;\n    changeSet.mSection = section;\n    changeSet.mChangeSetStats = enableStats ? new ChangeSetStats() : null;\n    return changeSet;\n  }\n  /** Wrap the given list of {@link RenderInfo} in a {@link TreePropsWrappedRenderInfo}. */\n  private static List<RenderInfo> wrapTreePropRenderInfos(\n      List<RenderInfo> renderInfos, @Nullable TreeProps treeProps) {\n    if (treeProps == null) {\n      return renderInfos;\n    }\n    final List<RenderInfo> wrappedRenderInfos = new ArrayList<>(renderInfos.size());\n    for (int i = 0; i < renderInfos.size(); i++) {\n      wrappedRenderInfos.add(new TreePropsWrappedRenderInfo(renderInfos.get(i), treeProps));\n    }\n    return wrappedRenderInfos;\n  }\n  /**\n   * Used internally by the framework to merge all the ChangeSet generated by all the leaf {@link\n   * Section}. The merged ChangeSet will be passed to the {@link Target}.\n   */\n  static ChangeSet merge(ChangeSet first, ChangeSet second) {\n    final ChangeSet mergedChangeSet = acquireChangeSet(null, false);\n    final int firstCount = first != null ? first.mFinalCount : 0;\n    final int secondCount = second != null ? second.mFinalCount : 0;\n    final List<Change> mergedChanged = mergedChangeSet.mChanges;\n    final ChangeSetStats firstStats = first != null ? first.getChangeSetStats() : null;\n    final ChangeSetStats secondStats = second != null ? second.getChangeSetStats() : null;\n    if (first != null) {\n      for (Change change : first.mChanges) {\n        mergedChanged.add(Change.copy(change));\n      }\n    }\n    if (second != null) {\n      for (Change change : second.mChanges) {\n        mergedChanged.add(Change.offset(change, firstCount));\n      }\n    }\n    mergedChangeSet.mFinalCount = firstCount + secondCount;\n    mergedChangeSet.mChangeSetStats = ChangeSetStats.merge(firstStats, secondStats);\n    return mergedChangeSet;\n  }\n  //TODO implement pools t11953296\n  private static ChangeSet acquire() {\n    return new ChangeSet();\n  }\n  //TODO implement pools t11953296\n  void release() {\n    for (Change change : mChanges) {\n      change.release();\n    }\n    mChanges.clear();\n    mChangeSetStats = null;\n    mFinalCount = 0;\n  }\n  /** Keep track of internal statistics useful for performance analyses. */\n  static class ChangeSetStats {\n    private final int mEffectiveChangesCount;\n    private final int mInsertSingleCount;\n    private final int mInsertRangeCount;\n    private final int mDeleteSingleCount;\n    private final int mDeleteRangeCount;\n    private final int mUpdateSingleCount;\n    private final int mUpdateRangeCount;<fim_middle>// class below has no smell\n"}