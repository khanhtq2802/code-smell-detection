{"text": "<fim_prefix>/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements. See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership. The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License. You may obtain a copy of the License at\n*\n* http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied. See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\npackage org.apache.taverna.prov;\n\n/**\n * Copied out from net.sf.taverna.t2.workbench.file.impl.SafeFileOutputStream\n * to avoid dependency on file-impl.  \n * \n * TODO: Move to taverna utils!\n * \n */\n\nimport java.io.FileNotFoundException;\nimport java.io.FilterOutputStream;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.StandardCopyOption;\n\n<fim_suffix>public class SafeFileOutputStream extends FilterOutputStream {\n\n    private final Path desiredFile;\n    private Path tempFile;\n    boolean desiredAlreadyExisted;\n\n    public SafeFileOutputStream(Path file) throws IOException {\n        this(file, tempFile(file));\n    }\n\n    public SafeFileOutputStream(Path desiredFile, Path tempFile)\n            throws IOException {\n\n        super(Files.newOutputStream(tempFile));\n        this.desiredFile = desiredFile;\n        this.tempFile = tempFile;\n        // Some useful things to check that we preferably don't want to fail on\n        // close()\n        desiredAlreadyExisted = Files.exists(desiredFile);\n        Path desiredFolder = this.desiredFile.getParent();\n        if (desiredAlreadyExisted) {\n            if (!Files.isWritable(desiredFile)) {\n                throw new FileNotFoundException(\"Can't write to \" + desiredFile);\n            }\n        } else {\n            if (!Files.exists(desiredFolder)) {\n                throw new FileNotFoundException(\"Folder does not exist: \"\n                        + desiredFolder);\n            }\n            if (!Files.isDirectory(desiredFolder)) {\n                throw new FileNotFoundException(\"Not a directory: \"\n                        + desiredFolder);\n            }\n        }\n        if (!Files.isWritable(desiredFolder)) {\n            throw new FileNotFoundException(\"Can't modify folder \"\n                    + desiredFolder);\n        }\n    }\n\n    private static Path tempFile(Path file) throws IOException {\n        return Files.createTempFile(file.getParent(), file.getFileName()\n                .toString(), \".tmp\");\n    }\n\n    @Override\n    public void close() throws IOException {\n        // If super.close fails - we leave the tempfiles behind\n        super.close();\n        if (!Files.exists(tempFile)) {\n            // Probably something went wrong before close called,\n            // like rollback()\n            return;\n        }\n        Path beforeDeletion = null;\n        try {\n            if (desiredAlreadyExisted) {\n                // In case renaming goes wrong, we don't want to have already\n                // deleted the\n                // desired file. So we'll rename it to another temporary file\n                // instead which\n                // we can delete on successful rename.\n                beforeDeletion = tempFile(desiredFile);\n                if (!Files.deleteIfExists(beforeDeletion)) {\n                    // Should not happen, we just made it!\n                    throw new IOException(\"Can't delete temporary file \"\n                            + beforeDeletion);\n                }\n                Files.move(desiredFile, beforeDeletion,\n                        StandardCopyOption.ATOMIC_MOVE);\n            }\n            try {\n                Files.move(tempFile, desiredFile,\n                        StandardCopyOption.ATOMIC_MOVE);\n            } catch (IOException e) {\n                // We'll leave our tempFiles for recovery.\n                tempFile = null;\n                beforeDeletion = null;\n\n                if (Files.exists(desiredFile)) {\n                    // Someone else added or replaced the file afterwards,\n                    // kind-a OK\n                    return;\n                }\n                throw e;\n            }\n        } finally {\n            if (beforeDeletion != null) {\n                Files.deleteIfExists(beforeDeletion);\n            }\n            if (tempFile != null) {\n                Files.deleteIfExists(tempFile);\n            }\n        }\n    }\n\n    public void rollback() throws IOException {\n        super.close();\n        Files.deleteIfExists(tempFile);\n    }\n\n}<fim_middle>// class below is blob\n"}