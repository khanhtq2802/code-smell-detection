{"text": "<fim_prefix>/*\n * Copyright 2014-present Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License. You may obtain\n * a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage com.facebook.buck.apple.clang;\nimport com.facebook.buck.io.file.MorePaths;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Ascii;\nimport com.google.common.base.Preconditions;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\nimport java.nio.channels.FileChannel;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Path;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Objects;\nimport javax.annotation.Nullable;\nimport javax.annotation.concurrent.NotThreadSafe;\n/**\n * Header maps are essentially hash maps from strings to paths (coded as two strings: a prefix and a\n * suffix).\n *\n * <p>This class provides support for reading and generating clang header maps. No spec is available\n * but we conform to the <a href=\"http://clang.llvm.org/doxygen/HeaderMap_8h_source.html\">reader\n * class defined in the Clang documentation</a>.\n *\n * <p>Note: currently we don't support offsets greater than MAX_SIGNED_INT.\n */\npublic class HeaderMap {\n  private static final double MAX_LOAD_FACTOR = 0.75;\n  /**\n   * Bucket in the hashtable that is a {@link HeaderMap}. Note: This notion of bucket is slightly\n   * more abstract than the one on disk (string offsets being already swapped/shifted).\n   */\n  private static class Bucket {\n    /** Offset of the key string into stringBytes. */\n    final int key;\n    /** Offset of the value prefix into stringBytes. */\n    final int prefix;\n    /** Offset of the value suffix into stringBytes. */\n    final int suffix;\n    Bucket(int key, int prefix, int suffix) {\n      this.key = key;\n      this.prefix = prefix;\n      this.suffix = suffix;\n    }\n  }\n  private static final Charset DEFAULT_CHARSET = StandardCharsets.UTF_8;\n  // NB: Despite this comment, which comes from clang, we are using this field to represent the\n  // number of entries, not the number of strings. Clang doesn't seem to care about this, and xcode\n  // seems to treat this as the number of entries as well.\n  /** Number of entries in the string table. */\n  private final int numEntries;\n  /** Length of longest result path (excluding {@code null}). */\n  private final int maxValueLength;\n  // data containers\n  private final Bucket[] buckets;\n  private final byte[] stringBytes; // actually chars to make debugging easier\n<fim_suffix>  private HeaderMap(Bucket[] buckets, byte[] stringTable, int numEntries, int maxValueLength) {\n    Preconditions.checkArgument(buckets.length > 0, \"The number of buckets must be greater than 0\");\n    Preconditions.checkArgument(\n        (buckets.length & (buckets.length - 1)) == 0, \"The number of buckets must be a power of 2\");\n    this.buckets = buckets;\n    this.stringBytes = stringTable;\n    this.numEntries = numEntries;\n    this.maxValueLength = maxValueLength;\n  }\n  public int getNumEntries() {\n    return numEntries;\n  }\n  public int getNumBuckets() {\n    return buckets.length;\n  }\n  public int getMaxValueLength() {\n    return maxValueLength;\n  }\n  /** Visitor function for {@link #visit(HeaderMapVisitor)}. */\n  @FunctionalInterface\n  public interface HeaderMapVisitor {\n    void apply(String str, String prefix, String suffix);\n  }\n  public void visit(HeaderMapVisitor visitor) {\n    for (Bucket bucket : buckets) {\n      if (bucket != null) {\n        visitor.apply(\n            Objects.requireNonNull(getString(bucket.key)),\n            Objects.requireNonNull(getString(bucket.prefix)),\n            Objects.requireNonNull(getString(bucket.suffix)));\n      }\n    }\n  }\n  @Override\n  public String toString() {\n    StringBuilder builder = new StringBuilder();\n    print(builder);\n    return builder.toString();\n  }\n  public void print(Appendable stream) {\n    visit(\n        (str, prefix, suffix) -> {\n          try {\n            stream.append(\"\\\"\");\n            stream.append(str);\n            stream.append(\"\\\" -> \\\"\");\n            stream.append(prefix);\n            stream.append(suffix);\n            stream.append(\"\\\"\\n\");\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          }\n        });\n  }\n  @Nullable\n  public String lookup(String str) {\n    int hash0 = hashKey(str) & (buckets.length - 1);\n    int hash = hash0;\n    while (true) {\n      Bucket bucket = buckets[hash];\n      if (bucket == null) {\n        return null;\n      }\n      if (str.equalsIgnoreCase(getString(bucket.key))) {\n        return getString(bucket.prefix) + getString(bucket.suffix);\n      }\n      hash = (hash + 1) & (buckets.length - 1);\n      if (hash == hash0) {\n        return null;\n      }\n    }\n  }\n  // --------- I/O methods ----------\n  private static final int HEADER_MAGIC = ('h' << 24) | ('m' << 16) | ('a' << 8) | 'p';\n  private static final short HEADER_VERSION = 1;\n  private static final short HEADER_RESERVED = 0;\n  private static final int EMPTY_BUCKET_KEY = 0;\n  private static final int HEADER_SIZE = 24;\n  private static final int BUCKET_SIZE = 12;\n  @Nullable\n  public static HeaderMap deserialize(byte[] bytes) {\n    ByteBuffer buffer = ByteBuffer.wrap(bytes);\n    return deserialize(buffer);\n  }\n  @Nullable\n  public static HeaderMap deserialize(ByteBuffer buffer) {\n    return processBuffer(buffer);\n  }\n  public static HeaderMap loadFromFile(File hmapFile) throws IOException {\n    HeaderMap map;\n    try (FileInputStream inputStream = new FileInputStream(hmapFile)) {\n      FileChannel fileChannel = inputStream.getChannel();\n      ByteBuffer buffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, hmapFile.length());\n      map = HeaderMap.deserialize(buffer);\n      if (map == null) {\n        throw new IOException(\"Error while parsing header map \" + hmapFile);\n      }\n    }\n    return map;\n  }\n  @Nullable\n  private static HeaderMap processBuffer(ByteBuffer buffer) {\n    buffer.order(ByteOrder.BIG_ENDIAN);\n    if (buffer.getInt(0) != HEADER_MAGIC) {\n      buffer.order(ByteOrder.LITTLE_ENDIAN);\n    }\n    int magic = buffer.getInt();\n    short version = buffer.getShort();\n    if (magic != HEADER_MAGIC || version != HEADER_VERSION) {\n      return null;\n    }\n    /* reserved */ buffer.getShort();\n    int stringOffset = buffer.getInt();\n    int numEntries = buffer.getInt();\n    int numBuckets = buffer.getInt();\n    int maxValueLength = buffer.getInt();\n    // strings can be anywhere after the end of the buckets\n    int stringBytesActualLength = buffer.capacity() - HEADER_SIZE - numBuckets * BUCKET_SIZE;\n    Bucket[] buckets = new Bucket[numBuckets];\n    int actualOffset = HEADER_SIZE + numBuckets * BUCKET_SIZE - stringOffset;\n    // actualOffset should always be positive since the index EMPTY_BUCKET_KEY=0 is reserved\n    for (int i = 0; i < numBuckets; i++) {\n      int keyRawOffset = buffer.getInt();\n      int prefixRawOffset = buffer.getInt();\n      int suffixRawOffset = buffer.getInt();\n      if (keyRawOffset == EMPTY_BUCKET_KEY) {\n        buckets[i] = null;\n      } else {\n        // we can subtract 1 value because index 0 is EMPTY_BUCKET_KEY\n        buckets[i] =\n            new Bucket(\n                keyRawOffset - actualOffset,\n                prefixRawOffset - actualOffset,\n                suffixRawOffset - actualOffset);\n      }\n    }\n    // anything else is string\n    byte[] stringBytes = new byte[stringBytesActualLength];\n    buffer.get(stringBytes);\n    return new HeaderMap(buckets, stringBytes, numEntries, maxValueLength);\n  }\n  public int getRequiredBufferCapacity() {\n    return HEADER_SIZE + buckets.length * BUCKET_SIZE + stringBytes.length;\n  }<fim_middle>// function below has no smell\n"}