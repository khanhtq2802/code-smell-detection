{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with this\n * work for additional information regarding copyright ownership. The ASF\n * licenses this file to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hadoop.hbase.io.encoding;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\n\nimport org.apache.hadoop.hbase.util.Bytes;\nimport org.apache.yetus.audience.InterfaceAudience;\n\n/**\n * Provide access to all data block encoding algorithms. All of the algorithms\n * are required to have unique id which should <b>NEVER</b> be changed. If you\n * want to add a new algorithm/version, assign it a new id. Announce the new id\n * in the HBase mailing list to prevent collisions.\n */\n@InterfaceAudience.Public\npublic enum DataBlockEncoding {\n\n  /** Disable data block encoding. */\n  NONE(0, null),\n  // id 1 is reserved for the BITSET algorithm to be added later\n  PREFIX(2, \"org.apache.hadoop.hbase.io.encoding.PrefixKeyDeltaEncoder\"),\n  DIFF(3, \"org.apache.hadoop.hbase.io.encoding.DiffKeyDeltaEncoder\"),\n  FAST_DIFF(4, \"org.apache.hadoop.hbase.io.encoding.FastDiffDeltaEncoder\"),\n  // id 5 is reserved for the COPY_KEY algorithm for benchmarking\n  // COPY_KEY(5, \"org.apache.hadoop.hbase.io.encoding.CopyKeyDataBlockEncoder\"),\n  // PREFIX_TREE(6, \"org.apache.hadoop.hbase.codec.prefixtree.PrefixTreeCodec\"),\n  ROW_INDEX_V1(7, \"org.apache.hadoop.hbase.io.encoding.RowIndexCodecV1\");\n\n  private final short id;\n  private final byte[] idInBytes;\n  private DataBlockEncoder encoder;\n  private final String encoderCls;\n\n  public static final int ID_SIZE = Bytes.SIZEOF_SHORT;\n\n  /** Maps data block encoding ids to enum instances. */\n  private static DataBlockEncoding[] idArray = new DataBlockEncoding[Byte.MAX_VALUE + 1];\n\n  static {\n    for (DataBlockEncoding algo : values()) {\n      if (idArray[algo.id] != null) {\n        throw new RuntimeException(String.format(\n          \"Two data block encoder algorithms '%s' and '%s' have \" + \"the same id %d\",\n          idArray[algo.id].toString(), algo.toString(), (int) algo.id));\n      }\n      idArray[algo.id] = algo;\n    }\n  }\n\n  private DataBlockEncoding(int id, String encoderClsName) {\n    if (id < 0 || id > Byte.MAX_VALUE) {\n      throw new AssertionError(\n          \"Data block encoding algorithm id is out of range: \" + id);\n    }\n    this.id = (short) id;\n    this.idInBytes = Bytes.toBytes(this.id);\n    if (idInBytes.length != ID_SIZE) {\n      // White this may seem redundant, if we accidentally serialize\n      // the id as e.g. an int instead of a short, all encoders will break.\n      throw new RuntimeException(\"Unexpected length of encoder ID byte \" +\n          \"representation: \" + Bytes.toStringBinary(idInBytes));\n    }\n    this.encoderCls = encoderClsName;\n  }\n\n  /**\n   * @return name converted to bytes.\n   */\n  public byte[] getNameInBytes() {\n    return Bytes.toBytes(toString());\n  }\n\n  /**\n   * @return The id of a data block encoder.\n   */\n  public short getId() {\n    return id;\n  }\n\n  /**\n   * Writes id in bytes.\n   * @param stream where the id should be written.\n   */\n  public void writeIdInBytes(OutputStream stream) throws IOException {\n    stream.write(idInBytes);\n  }\n\n\n  /**\n   * Writes id bytes to the given array starting from offset.\n   *\n   * @param dest output array\n   * @param offset starting offset of the output array\n   * @throws IOException\n   */\n  public void writeIdInBytes(byte[] dest, int offset) throws IOException {\n    System.arraycopy(idInBytes, 0, dest, offset, ID_SIZE);\n  }\n\n  /**\n   * Return new data block encoder for given algorithm type.\n   * @return data block encoder if algorithm is specified, null if none is\n   *         selected.\n   */\n<fim_suffix>  public DataBlockEncoder getEncoder() {\n    if (encoder == null && id != 0) {\n      // lazily create the encoder\n      encoder = createEncoder(encoderCls);\n    }\n    return encoder;\n  }\n\n  /**\n   * Find and create data block encoder for given id;\n   * @param encoderId id of data block encoder.\n   * @return Newly created data block encoder.\n   */\n  public static DataBlockEncoder getDataBlockEncoderById(short encoderId) {\n    return getEncodingById(encoderId).getEncoder();\n  }\n\n  /**\n   * Find and return the name of data block encoder for the given id.\n   * @param encoderId id of data block encoder\n   * @return name, same as used in options in column family\n   */\n  public static String getNameFromId(short encoderId) {\n    return getEncodingById(encoderId).toString();\n  }\n\n  /**\n   * Check if given encoder has this id.\n   * @param encoder encoder which id will be checked\n   * @param encoderId id which we except\n   * @return true if id is right for given encoder, false otherwise\n   * @exception IllegalArgumentException\n   *            thrown when there is no matching data block encoder\n   */\n  public static boolean isCorrectEncoder(DataBlockEncoder encoder,\n      short encoderId) {\n    DataBlockEncoding algorithm = getEncodingById(encoderId);\n    String encoderCls = encoder.getClass().getName();\n    return encoderCls.equals(algorithm.encoderCls);\n  }\n\n  public static DataBlockEncoding getEncodingById(short dataBlockEncodingId) {\n    DataBlockEncoding algorithm = null;\n    if (dataBlockEncodingId >= 0 && dataBlockEncodingId <= Byte.MAX_VALUE) {\n      algorithm = idArray[dataBlockEncodingId];\n    }\n    if (algorithm == null) {\n      throw new IllegalArgumentException(String.format(\n          \"There is no data block encoder for given id '%d'\",\n          (int) dataBlockEncodingId));\n    }\n    return algorithm;\n  }\n\n  protected static DataBlockEncoder createEncoder(String fullyQualifiedClassName) {\n    try {\n      return (DataBlockEncoder) Class.forName(fullyQualifiedClassName).getDeclaredConstructor()\n          .newInstance();\n    } catch (Exception e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n}<fim_middle>// function below has no smell\n"}