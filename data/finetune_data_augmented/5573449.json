{"text": "<fim_prefix>/* ====================================================================\n   Licensed to the Apache Software Foundation (ASF) under one or more\n   contributor license agreements.  See the NOTICE file distributed with\n   this work for additional information regarding copyright ownership.\n   The ASF licenses this file to You under the Apache License, Version 2.0\n   (the \"License\"); you may not use this file except in compliance with\n   the License.  You may obtain a copy of the License at\n       http://www.apache.org/licenses/LICENSE-2.0\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n==================================================================== */\npackage org.apache.poi.hslf.usermodel;\nimport java.awt.geom.AffineTransform;\nimport java.awt.geom.Path2D;\nimport java.awt.geom.PathIterator;\nimport java.awt.geom.Point2D;\nimport java.awt.geom.Rectangle2D;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.apache.poi.ddf.AbstractEscherOptRecord;\nimport org.apache.poi.ddf.EscherArrayProperty;\nimport org.apache.poi.ddf.EscherContainerRecord;\nimport org.apache.poi.ddf.EscherProperties;\nimport org.apache.poi.ddf.EscherSimpleProperty;\nimport org.apache.poi.sl.usermodel.FreeformShape;\nimport org.apache.poi.sl.usermodel.ShapeContainer;\nimport org.apache.poi.sl.usermodel.ShapeType;\nimport org.apache.poi.util.LittleEndian;\nimport org.apache.poi.util.POILogFactory;\nimport org.apache.poi.util.POILogger;\nimport org.apache.poi.util.Units;\n/**\n * A \"Freeform\" shape.\n *\n * <p>\n * Shapes drawn with the \"Freeform\" tool have cubic bezier curve segments in the smooth sections\n * and straight-line segments in the straight sections. This object closely corresponds to <code>java.awt.geom.GeneralPath</code>.\n * </p>\n */\npublic final class HSLFFreeformShape extends HSLFAutoShape implements FreeformShape<HSLFShape,HSLFTextParagraph> {\n    private static final POILogger LOG = POILogFactory.getLogger(HSLFFreeformShape.class);\n    enum ShapePath {\n        LINES(0),\n        LINES_CLOSED(1),\n        CURVES(2),\n        CURVES_CLOSED(3),\n        COMPLEX(4);\n        private final int flag;\n        ShapePath(int flag) {\n            this.flag = flag;\n        }\n        public int getFlag() {\n            return flag;\n        }\n        static ShapePath valueOf(int flag) {\n            for (ShapePath v : values()) {\n                if (v.flag == flag) {\n                    return v;\n                }\n            }\n            return null;\n        }\n    }\n    /**\n     * Create a Freeform object and initialize it from the supplied Record container.\n     *\n     * @param escherRecord       <code>EscherSpContainer</code> container which holds information about this shape\n     * @param parent    the parent of the shape\n     */\n   protected HSLFFreeformShape(EscherContainerRecord escherRecord, ShapeContainer<HSLFShape,HSLFTextParagraph> parent){\n        super(escherRecord, parent);\n    }\n    /**\n     * Create a new Freeform. This constructor is used when a new shape is created.\n     *\n     * @param parent    the parent of this Shape. For example, if this text box is a cell\n     * in a table then the parent is Table.\n     */\n    public HSLFFreeformShape(ShapeContainer<HSLFShape,HSLFTextParagraph> parent){\n        super((EscherContainerRecord)null, parent);\n        createSpContainer(ShapeType.NOT_PRIMITIVE, parent instanceof HSLFGroupShape);\n    }\n    /**\n     * Create a new Freeform. This constructor is used when a new shape is created.\n     *\n     */\n    public HSLFFreeformShape(){\n        this(null);\n    }\n<fim_suffix>    @Override\n    public int setPath(Path2D path) {\n        Rectangle2D bounds = path.getBounds2D();\n        PathIterator it = path.getPathIterator(null);\n        List<byte[]> segInfo = new ArrayList<>();\n        List<Point2D.Double> pntInfo = new ArrayList<>();\n        boolean isClosed = false;\n        int numPoints = 0;\n        while (!it.isDone()) {\n            double[] vals = new double[6];\n            int type = it.currentSegment(vals);\n            switch (type) {\n                case PathIterator.SEG_MOVETO:\n                    pntInfo.add(new Point2D.Double(vals[0], vals[1]));\n                    segInfo.add(SEGMENTINFO_MOVETO);\n                    numPoints++;\n                    break;\n                case PathIterator.SEG_LINETO:\n                    pntInfo.add(new Point2D.Double(vals[0], vals[1]));\n                    segInfo.add(SEGMENTINFO_LINETO);\n                    segInfo.add(SEGMENTINFO_ESCAPE);\n                    numPoints++;\n                    break;\n                case PathIterator.SEG_CUBICTO:\n                    pntInfo.add(new Point2D.Double(vals[0], vals[1]));\n                    pntInfo.add(new Point2D.Double(vals[2], vals[3]));\n                    pntInfo.add(new Point2D.Double(vals[4], vals[5]));\n                    segInfo.add(SEGMENTINFO_CUBICTO);\n                    segInfo.add(SEGMENTINFO_ESCAPE2);\n                    numPoints++;\n                    break;\n                case PathIterator.SEG_QUADTO:\n                    //TODO: figure out how to convert SEG_QUADTO into SEG_CUBICTO\n                    LOG.log(POILogger.WARN, \"SEG_QUADTO is not supported\");\n                    break;\n                case PathIterator.SEG_CLOSE:\n                    pntInfo.add(pntInfo.get(0));\n                    segInfo.add(SEGMENTINFO_LINETO);\n                    segInfo.add(SEGMENTINFO_ESCAPE);\n                    segInfo.add(SEGMENTINFO_LINETO);\n                    segInfo.add(SEGMENTINFO_CLOSE);\n                    isClosed = true;\n                    numPoints++;\n                    break;\n                default:\n                    LOG.log(POILogger.WARN, \"Ignoring invalid segment type \"+type);\n                    break;\n            }\n            it.next();\n        }\n        if(!isClosed) {\n            segInfo.add(SEGMENTINFO_LINETO);\n        }\n        segInfo.add(SEGMENTINFO_END);\n        AbstractEscherOptRecord opt = getEscherOptRecord();\n        opt.addEscherProperty(new EscherSimpleProperty(EscherProperties.GEOMETRY__SHAPEPATH, 0x4));\n        EscherArrayProperty verticesProp = new EscherArrayProperty((short)(EscherProperties.GEOMETRY__VERTICES + 0x4000), false, null);\n        verticesProp.setNumberOfElementsInArray(pntInfo.size());\n        verticesProp.setNumberOfElementsInMemory(pntInfo.size());\n        verticesProp.setSizeOfElements(8);\n        for (int i = 0; i < pntInfo.size(); i++) {\n            Point2D.Double pnt = pntInfo.get(i);\n            byte[] data = new byte[8];\n            LittleEndian.putInt(data, 0, Units.pointsToMaster(pnt.getX() - bounds.getX()));\n            LittleEndian.putInt(data, 4, Units.pointsToMaster(pnt.getY() - bounds.getY()));\n            verticesProp.setElement(i, data);\n        }\n        opt.addEscherProperty(verticesProp);\n        EscherArrayProperty segmentsProp = new EscherArrayProperty((short)(EscherProperties.GEOMETRY__SEGMENTINFO + 0x4000), false, null);\n        segmentsProp.setNumberOfElementsInArray(segInfo.size());\n        segmentsProp.setNumberOfElementsInMemory(segInfo.size());\n        segmentsProp.setSizeOfElements(0x2);\n        for (int i = 0; i < segInfo.size(); i++) {\n            byte[] seg = segInfo.get(i);\n            segmentsProp.setElement(i, seg);\n        }\n        opt.addEscherProperty(segmentsProp);\n        opt.addEscherProperty(new EscherSimpleProperty(EscherProperties.GEOMETRY__RIGHT, Units.pointsToMaster(bounds.getWidth())));\n        opt.addEscherProperty(new EscherSimpleProperty(EscherProperties.GEOMETRY__BOTTOM, Units.pointsToMaster(bounds.getHeight())));\n        opt.sortProperties();\n        setAnchor(bounds);\n        return numPoints;\n    }\n    @Override\n    public Path2D getPath(){\n        Path2D path2D = new Path2D.Double();\n        getGeometry(path2D);\n        Rectangle2D bounds = path2D.getBounds2D();<fim_middle>// function below is long method\n"}