{"text": "<fim_prefix>/*\n * Copyright 2002-2018 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.springframework.web.servlet.support;\nimport java.beans.PropertyEditor;\nimport java.util.Arrays;\nimport java.util.List;\nimport org.springframework.beans.BeanWrapper;\nimport org.springframework.beans.PropertyAccessorFactory;\nimport org.springframework.context.NoSuchMessageException;\nimport org.springframework.lang.Nullable;\nimport org.springframework.util.ObjectUtils;\nimport org.springframework.util.StringUtils;\nimport org.springframework.validation.BindingResult;\nimport org.springframework.validation.Errors;\nimport org.springframework.validation.ObjectError;\nimport org.springframework.web.util.HtmlUtils;\n/**\n * Simple adapter to expose the bind status of a field or object.\n * Set as a variable both by the JSP bind tag and FreeMarker macros.\n *\n * <p>Obviously, object status representations (i.e. errors at the object level\n * rather than the field level) do not have an expression and a value but only\n * error codes and messages. For simplicity's sake and to be able to use the same\n * tags and macros, the same status class is used for both scenarios.\n *\n * @author Rod Johnson\n * @author Juergen Hoeller\n * @author Darren Davison\n * @see RequestContext#getBindStatus\n * @see org.springframework.web.servlet.tags.BindTag\n * @see org.springframework.web.servlet.view.AbstractTemplateView#setExposeSpringMacroHelpers\n */\npublic class BindStatus {\n\tprivate final RequestContext requestContext;\n\tprivate final String path;\n\tprivate final boolean htmlEscape;\n\t@Nullable\n\tprivate final String expression;\n\t@Nullable\n\tprivate final Errors errors;\n\tprivate final String[] errorCodes;\n\t@Nullable\n\tprivate String[] errorMessages;\n\t@Nullable\n\tprivate List<? extends ObjectError> objectErrors;\n\t@Nullable\n\tprivate Object value;\n\t@Nullable\n\tprivate Class<?> valueType;\n\t@Nullable\n\tprivate Object actualValue;\n\t@Nullable\n\tprivate PropertyEditor editor;\n\t@Nullable\n\tprivate BindingResult bindingResult;\n\t/**\n\t * Create a new BindStatus instance, representing a field or object status.\n\t * @param requestContext the current RequestContext\n\t * @param path the bean and property path for which values and errors\n\t * will be resolved (e.g. \"customer.address.street\")\n\t * @param htmlEscape whether to HTML-escape error messages and string values\n\t * @throws IllegalStateException if no corresponding Errors object found\n\t */\n<fim_suffix>\tpublic BindStatus(RequestContext requestContext, String path, boolean htmlEscape) throws IllegalStateException {\n\t\tthis.requestContext = requestContext;\n\t\tthis.path = path;\n\t\tthis.htmlEscape = htmlEscape;\n\t\t// determine name of the object and property\n\t\tString beanName;\n\t\tint dotPos = path.indexOf('.');\n\t\tif (dotPos == -1) {\n\t\t\t// property not set, only the object itself\n\t\t\tbeanName = path;\n\t\t\tthis.expression = null;\n\t\t}\n\t\telse {\n\t\t\tbeanName = path.substring(0, dotPos);\n\t\t\tthis.expression = path.substring(dotPos + 1);\n\t\t}\n\t\tthis.errors = requestContext.getErrors(beanName, false);\n\t\tif (this.errors != null) {\n\t\t\t// Usual case: A BindingResult is available as request attribute.\n\t\t\t// Can determine error codes and messages for the given expression.\n\t\t\t// Can use a custom PropertyEditor, as registered by a form controller.\n\t\t\tif (this.expression != null) {\n\t\t\t\tif (\"*\".equals(this.expression)) {\n\t\t\t\t\tthis.objectErrors = this.errors.getAllErrors();\n\t\t\t\t}\n\t\t\t\telse if (this.expression.endsWith(\"*\")) {\n\t\t\t\t\tthis.objectErrors = this.errors.getFieldErrors(this.expression);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.objectErrors = this.errors.getFieldErrors(this.expression);\n\t\t\t\t\tthis.value = this.errors.getFieldValue(this.expression);\n\t\t\t\t\tthis.valueType = this.errors.getFieldType(this.expression);\n\t\t\t\t\tif (this.errors instanceof BindingResult) {\n\t\t\t\t\t\tthis.bindingResult = (BindingResult) this.errors;\n\t\t\t\t\t\tthis.actualValue = this.bindingResult.getRawFieldValue(this.expression);\n\t\t\t\t\t\tthis.editor = this.bindingResult.findEditor(this.expression, null);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.actualValue = this.value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.objectErrors = this.errors.getGlobalErrors();\n\t\t\t}\n\t\t\tthis.errorCodes = initErrorCodes(this.objectErrors);\n\t\t}\n\t\telse {\n\t\t\t// No BindingResult available as request attribute:\n\t\t\t// Probably forwarded directly to a form view.\n\t\t\t// Let's do the best we can: extract a plain target if appropriate.\n\t\t\tObject target = requestContext.getModelObject(beanName);\n\t\t\tif (target == null) {\n\t\t\t\tthrow new IllegalStateException(\"Neither BindingResult nor plain target object for bean name '\" +\n\t\t\t\t\t\tbeanName + \"' available as request attribute\");\n\t\t\t}\n\t\t\tif (this.expression != null && !\"*\".equals(this.expression) && !this.expression.endsWith(\"*\")) {\n\t\t\t\tBeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(target);\n\t\t\t\tthis.value = bw.getPropertyValue(this.expression);\n\t\t\t\tthis.valueType = bw.getPropertyType(this.expression);\n\t\t\t\tthis.actualValue = this.value;\n\t\t\t}\n\t\t\tthis.errorCodes = new String[0];\n\t\t\tthis.errorMessages = new String[0];\n\t\t}\n\t\tif (htmlEscape && this.value instanceof String) {\n\t\t\tthis.value = HtmlUtils.htmlEscape((String) this.value);\n\t\t}\n\t}\n\t/**\n\t * Extract the error codes from the ObjectError list.\n\t */\n\tprivate static String[] initErrorCodes(List<? extends ObjectError> objectErrors) {\n\t\tString[] errorCodes = new String[objectErrors.size()];\n\t\tfor (int i = 0; i < objectErrors.size(); i++) {\n\t\t\tObjectError error = objectErrors.get(i);\n\t\t\terrorCodes[i] = error.getCode();\n\t\t}\n\t\treturn errorCodes;\n\t}\n\t/**\n\t * Return the bean and property path for which values and errors\n\t * will be resolved (e.g. \"customer.address.street\").\n\t */\n\tpublic String getPath() {\n\t\treturn this.path;\n\t}\n\t/**\n\t * Return a bind expression that can be used in HTML forms as input name\n\t * for the respective field, or {@code null} if not field-specific.\n\t * <p>Returns a bind path appropriate for resubmission, e.g. \"address.street\".\n\t * Note that the complete bind path as required by the bind tag is\n\t * \"customer.address.street\", if bound to a \"customer\" bean.\n\t */\n\t@Nullable\n\tpublic String getExpression() {\n\t\treturn this.expression;\n\t}\n\t/**\n\t * Return the current value of the field, i.e. either the property value\n\t * or a rejected update, or {@code null} if not field-specific.\n\t * <p>This value will be an HTML-escaped String if the original value\n\t * already was a String.\n\t */\n\t@Nullable\n\tpublic Object getValue() {\n\t\treturn this.value;\n\t}\n\t/**\n\t * Get the '{@code Class}' type of the field. Favor this instead of\n\t * '{@code getValue().getClass()}' since '{@code getValue()}' may\n\t * return '{@code null}'.\n\t */\n\t@Nullable\n\tpublic Class<?> getValueType() {\n\t\treturn this.valueType;\n\t}\n\t/**\n\t * Return the actual value of the field, i.e. the raw property value,\n\t * or {@code null} if not available.\n\t */\n\t@Nullable\n\tpublic Object getActualValue() {\n\t\treturn this.actualValue;\n\t}\n\t/**\n\t * Return a suitable display value for the field, i.e. the stringified<fim_middle>// function below is long method\n"}