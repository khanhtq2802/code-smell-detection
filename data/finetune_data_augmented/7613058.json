{"text": "<fim_prefix>\t\treturn Mono.error(new UnsupportedOperationException(\"Cannot read multipart request body into single Part\"));\n\t}\n\t/**\n\t * Consume and feed input to the Synchronoss parser, then listen for parser\n\t * output events and adapt to {@code Flux<Sink<Part>>}.\n\t */\n\tprivate static class SynchronossPartGenerator implements Consumer<FluxSink<Part>> {\n\t\tprivate final ReactiveHttpInputMessage inputMessage;\n\t\tprivate final DataBufferFactory bufferFactory;\n\t\tprivate final PartBodyStreamStorageFactory streamStorageFactory;\n\t\tSynchronossPartGenerator(ReactiveHttpInputMessage inputMessage, DataBufferFactory bufferFactory,\n\t\t\t\tPartBodyStreamStorageFactory streamStorageFactory) {\n\t\t\tthis.inputMessage = inputMessage;\n\t\t\tthis.bufferFactory = bufferFactory;\n\t\t\tthis.streamStorageFactory = streamStorageFactory;\n\t\t}\n\t\t@Override\n\t\tpublic void accept(FluxSink<Part> emitter) {\n\t\t\tHttpHeaders headers = this.inputMessage.getHeaders();\n\t\t\tMediaType mediaType = headers.getContentType();\n\t\t\tAssert.state(mediaType != null, \"No content type set\");\n\t\t\tint length = getContentLength(headers);\n\t\t\tCharset charset = Optional.ofNullable(mediaType.getCharset()).orElse(StandardCharsets.UTF_8);\n\t\t\tMultipartContext context = new MultipartContext(mediaType.toString(), length, charset.name());\n\t\t\tNioMultipartParserListener listener = new FluxSinkAdapterListener(emitter, this.bufferFactory, context);\n\t\t\tNioMultipartParser parser = Multipart\n\t\t\t\t\t.multipart(context)\n\t\t\t\t\t.usePartBodyStreamStorageFactory(this.streamStorageFactory)\n\t\t\t\t\t.forNIO(listener);\n\t\t\tthis.inputMessage.getBody().subscribe(buffer -> {\n\t\t\t\tbyte[] resultBytes = new byte[buffer.readableByteCount()];\n\t\t\t\tbuffer.read(resultBytes);\n\t\t\t\ttry {\n\t\t\t\t\tparser.write(resultBytes);\n\t\t\t\t}\n\t\t\t\tcatch (IOException ex) {\n\t\t\t\t\tlistener.onError(\"Exception thrown providing input to the parser\", ex);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tDataBufferUtils.release(buffer);\n\t\t\t\t}\n\t\t\t}, ex -> {\n\t\t\t\ttry {\n\t\t\t\t\tlistener.onError(\"Request body input error\", ex);\n\t\t\t\t\tparser.close();\n\t\t\t\t}\n\t\t\t\tcatch (IOException ex2) {\n\t\t\t\t\tlistener.onError(\"Exception thrown while closing the parser\", ex2);\n\t\t\t\t}\n\t\t\t}, () -> {\n\t\t\t\ttry {\n\t\t\t\t\tparser.close();\n\t\t\t\t}\n\t\t\t\tcatch (IOException ex) {\n\t\t\t\t\tlistener.onError(\"Exception thrown while closing the parser\", ex);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tprivate int getContentLength(HttpHeaders headers) {\n\t\t\t// Until this is fixed https://github.com/synchronoss/nio-multipart/issues/10\n\t\t\tlong length = headers.getContentLength();\n\t\t\treturn (int) length == length ? (int) length : -1;\n\t\t}\n\t}\n\t/**\n\t * Listen for parser output and adapt to {@code Flux<Sink<Part>>}.\n\t */\n\tprivate static class FluxSinkAdapterListener implements NioMultipartParserListener {\n\t\tprivate final FluxSink<Part> sink;\n\t\tprivate final DataBufferFactory bufferFactory;\n\t\tprivate final MultipartContext context;\n\t\tprivate final AtomicInteger terminated = new AtomicInteger(0);\n\t\tFluxSinkAdapterListener(FluxSink<Part> sink, DataBufferFactory factory, MultipartContext context) {\n\t\t\tthis.sink = sink;\n\t\t\tthis.bufferFactory = factory;\n\t\t\tthis.context = context;\n\t\t}\n\t\t@Override\n\t\tpublic void onPartFinished(StreamStorage storage, Map<String, List<String>> headers) {\n\t\t\tHttpHeaders httpHeaders = new HttpHeaders();\n\t\t\thttpHeaders.putAll(headers);\n\t\t\tthis.sink.next(createPart(storage, httpHeaders));\n\t\t}\n\t\tprivate Part createPart(StreamStorage storage, HttpHeaders httpHeaders) {\n\t\t\tString filename = MultipartUtils.getFileName(httpHeaders);\n\t\t\tif (filename != null) {\n\t\t\t\treturn new SynchronossFilePart(httpHeaders, filename, storage, this.bufferFactory);\n\t\t\t}\n\t\t\telse if (MultipartUtils.isFormField(httpHeaders, this.context)) {\n\t\t\t\tString value = MultipartUtils.readFormParameterValue(storage, httpHeaders);\n\t\t\t\treturn new SynchronossFormFieldPart(httpHeaders, this.bufferFactory, value);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new SynchronossPart(httpHeaders, storage, this.bufferFactory);\n\t\t\t}\n\t\t}\n\t\t@Override\n\t\tpublic void onError(String message, Throwable cause) {\n\t\t\tif (this.terminated.getAndIncrement() == 0) {\n\t\t\t\tthis.sink.error(new RuntimeException(message, cause));\n\t\t\t}\n\t\t}\n\t\t@Override\n\t\tpublic void onAllPartsFinished() {\n\t\t\tif (this.terminated.getAndIncrement() == 0) {\n\t\t\t\tthis.sink.complete();\n\t\t\t}\n\t\t}\n\t\t@Override\n\t\tpublic void onNestedPartStarted(Map<String, List<String>> headersFromParentPart) {\n\t\t}\n\t\t@Override\n\t\tpublic void onNestedPartFinished() {\n\t\t}\n\t}\n\tprivate abstract static class AbstractSynchronossPart implements Part {\n\t\tprivate final String name;\n\t\tprivate final HttpHeaders headers;\n\t\tprivate final DataBufferFactory bufferFactory;\n\t\tAbstractSynchronossPart(HttpHeaders headers, DataBufferFactory bufferFactory) {\n\t\t\tAssert.notNull(headers, \"HttpHeaders is required\");\n\t\t\tAssert.notNull(bufferFactory, \"DataBufferFactory is required\");\n\t\t\tthis.name = MultipartUtils.getFieldName(headers);\n\t\t\tthis.headers = headers;\n\t\t\tthis.bufferFactory = bufferFactory;\n\t\t}\n\t\t@Override\n\t\tpublic String name() {\n\t\t\treturn this.name;\n\t\t}\n\t\t@Override\n\t\tpublic HttpHeaders headers() {\n\t\t\treturn this.headers;\n\t\t}\n\t\tDataBufferFactory getBufferFactory() {\n\t\t\treturn this.bufferFactory;\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Part '\" + this.name + \"', headers=\" + this.headers;\n\t\t}\n\t}\n\tprivate static class SynchronossPart extends AbstractSynchronossPart {\n\t\tprivate final StreamStorage storage;\n\t\tSynchronossPart(HttpHeaders headers, StreamStorage storage, DataBufferFactory factory) {\n\t\t\tsuper(headers, factory);\n\t\t\tAssert.notNull(storage, \"StreamStorage is required\");\n\t\t\tthis.storage = storage;\n\t\t}\n\t\t@Override\n\t\tpublic Flux<DataBuffer> content() {\n\t\t\treturn DataBufferUtils.readInputStream(getStorage()::getInputStream, getBufferFactory(), 4096);\n\t\t}\n\t\tprotected StreamStorage getStorage() {\n\t\t\treturn this.storage;\n\t\t}\n\t}\n<fim_suffix>\tprivate static class SynchronossFilePart extends SynchronossPart implements FilePart {\n\t\tprivate static final OpenOption[] FILE_CHANNEL_OPTIONS =\n\t\t\t\t{StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.WRITE};\n\t\tprivate final String filename;\n\t\tSynchronossFilePart(HttpHeaders headers, String filename, StreamStorage storage, DataBufferFactory factory) {\n\t\t\tsuper(headers, storage, factory);\n\t\t\tthis.filename = filename;\n\t\t}\n\t\t@Override\n\t\tpublic String filename() {\n\t\t\treturn this.filename;\n\t\t}\n\t\t@Override\n\t\tpublic Mono<Void> transferTo(Path dest) {\n\t\t\tReadableByteChannel input = null;\n\t\t\tFileChannel output = null;\n\t\t\ttry {\n\t\t\t\tinput = Channels.newChannel(getStorage().getInputStream());\n\t\t\t\toutput = FileChannel.open(dest, FILE_CHANNEL_OPTIONS);\n\t\t\t\tlong size = (input instanceof FileChannel ? ((FileChannel) input).size() : Long.MAX_VALUE);\n\t\t\t\tlong totalWritten = 0;\n\t\t\t\twhile (totalWritten < size) {\n\t\t\t\t\tlong written = output.transferFrom(input, totalWritten, size - totalWritten);\n\t\t\t\t\tif (written <= 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ttotalWritten += written;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\treturn Mono.error(ex);\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (input != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tinput.close();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException ignored) {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (output != null) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\toutput.close();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException ignored) {\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Mono.empty();\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Part '\" + name() + \"', filename='\" + this.filename + \"'\";\n\t\t}\n\t}<fim_middle>// class below has no smell\n"}