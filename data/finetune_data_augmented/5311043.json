{"text": "<fim_prefix>        // ISeries    DBProdName                 DB2 UDB for AS/400\n        //   (Toolbox)DBProdVersion              05.04.0000 V5R4m0\n        // ISeries                               DB2 UDB for AS/400\n        //   (Native)                            V5R4M0\n        // new jcc    DBProdVersion              QSQ05040 or QSQ06010\n        if (databaseProductName.indexOf(\"AS\") != -1) {\n            // default to V5R4\n            setMajorVersion(5);\n            setMinorVersion(4);\n            int index = databaseProductVersion.indexOf('V');\n            if (index != -1) {\n                String s = databaseProductVersion.substring(index);\n                s = s.toUpperCase(Locale.ENGLISH);\n                StringTokenizer stringtokenizer = new StringTokenizer(s, \"VRM\"\n                    , false);\n                if (stringtokenizer.countTokens() == 3) {\n                    String s1 = stringtokenizer.nextToken();\n                    setMajorVersion(Integer.parseInt(s1));\n                    String s2 =  stringtokenizer.nextToken();\n                    setMinorVersion(Integer.parseInt(s2));\n                }\n            } else {\n                index = databaseProductVersion.indexOf('0');\n                if (index != -1) {\n                    String s = databaseProductVersion.substring(index);\n                    s = s.toUpperCase(Locale.ENGLISH);\n                    StringTokenizer stringtokenizer = new StringTokenizer(s, \"0\"\n                        , false);\n                    if (stringtokenizer.countTokens() == 2) {\n                        String s1 = stringtokenizer.nextToken();\n                        setMajorVersion(Integer.parseInt(s1));\n                        String s2 =  stringtokenizer.nextToken();\n                        setMinorVersion(Integer.parseInt(s2));\n                    }\n                }\n            }\n        }\n    }\n    private void getProductVersionMajorMinor() {\n        // In case JDBC driver version is lower than 3\n        // use following info to determine Major and Minor\n        //                        CLI    vs      JCC\n        // ZDBV8 DBProdName       DB2            DB2\n        //       DBProdVersion    08.01.0005     DSN08015\n        // ZDBV9                  DB2            DB2\n        //                        09.01.0005     DSN09015\n        // WinV9                  DB2/NT         DB2/NT\n        //                        09.01.0000     SQL09010\n        // SolarisV9                             DB2/SUN64\n        //                                       SQL0901\n        // Linux                  DB2/LINUX      DB2/LINUX\n        //                        09.01.0000     SQL0901\n        if (databaseProductVersion.indexOf(\"09\") != -1) {\n            setMajorVersion(9);\n            if (databaseProductVersion.indexOf(\"01\") != -1) {\n                setMinorVersion(1);\n            }\n        } else if (databaseProductVersion.indexOf(\"08\") != -1) {\n        \tsetMajorVersion(8);\n        \tsetMinorVersion(2);\n            if (databaseProductVersion.indexOf(\"01\") != -1) {\n            \tsetMinorVersion(1);\n            }\n        }\n    }\n    protected String getOptimizeClause(Select sel) {\n        if (sel != null && sel.getExpectedResultCount() > 0) {\n            StringBuilder buf = new StringBuilder();\n            buf.append(\" \").append(optimizeClause).append(\" \")\n                .append(String.valueOf(sel.getExpectedResultCount()))\n                .append(\" \").append(rowClause);\n            return buf.toString();\n        }\n        return \"\";\n    }\n    @Override\n    public OpenJPAException newStoreException(String msg, SQLException[] causes, Object failed) {\n        if (appendExtendedExceptionText == true && causes != null && causes.length > 0) {\n            msg = appendExtendedExceptionMsg(msg, causes[0]);\n        }\n        return super.newStoreException(msg, causes, failed);\n    }\n    /**\n     *  Append exception information from SQLCA to the existing\n     *  exception message\n     */\n    private String appendExtendedExceptionMsg(String msg, SQLException sqle){\n       final String GETSQLCA =\"getSqlca\";\n       try {\n            Method sqlcaM2 = sqle.getNextException().getClass()\n                             .getMethod(GETSQLCA,null);\n            Object sqlca = sqlcaM2.invoke(sqle.getNextException(),\n                                          new Object[] {});\n            Method  getSqlErrpMethd = sqlca.getClass().\n            getMethod(\"getSqlErrp\", null);\n            Method  getSqlWarnMethd = sqlca.getClass().\n            getMethod(\"getSqlWarn\", null);\n            Method  getSqlErrdMethd = sqlca.getClass().\n            getMethod(\"getSqlErrd\", null);\n            StringBuilder errdStr = new StringBuilder();\n            int[] errds = (int[]) getSqlErrdMethd.invoke(sqlca, new Object[]{});\n            for (int i = 0; i < errds.length; i++)\n                errdStr.append(errdStr.length() > 0 ? \", \" : \"\").\n                    append(errds[i]);\n            StringBuilder exceptionMsg = new StringBuilder();\n            exceptionMsg.append(\"SQLCA OUTPUT\");\n            exceptionMsg.append(\"[Errp=\");\n            exceptionMsg.append(getSqlErrpMethd.invoke(sqlca, new Object[]{}));\n            exceptionMsg.append(\", Errd=\");\n            exceptionMsg.append(errdStr);\n            String Warn = new String((char[]) getSqlWarnMethd.\n                    invoke(sqlca, new Object[]{}));\n            if (Warn.trim().length() != 0) {\n                exceptionMsg.append(\", Warn=\");\n                exceptionMsg.append(Warn);\n                exceptionMsg.append(\"]\");\n            } else {\n                exceptionMsg.append(\"]\");\n            }\n            msg = msg.concat(exceptionMsg.toString());\n            // for batched execution failures, SQLExceptions are nested\n            SQLException sqle2 = sqle.getNextException();\n            while (sqle2 != null) {\n                msg = msg.concat(\"\\n\" + sqle2.getMessage());\n                sqle2 = sqle2.getNextException();\n            }\n            return msg;\n        } catch (Throwable t) {\n            return sqle.getMessage();\n        }\n    }\n    public int getDb2ServerType() {\n        return db2ServerType;\n    }\n    @Override\n    protected void appendLength(SQLBuffer buf, int type) {\n        if (type == Types.VARCHAR)\n            buf.append(\"(\").append(Integer.toString(characterColumnSize)).\n                append(\")\");\n    }\n    /**\n     * If this dictionary supports XML type,\n     * use this method to append xml predicate.\n     *\n     * @param buf the SQL buffer to write the comparison\n     * @param op the comparison operation to perform\n     * @param lhs the left hand side of the comparison\n     * @param rhs the right hand side of the comparison\n     * @param lhsxml indicates whether the left operand maps to xml\n     * @param rhsxml indicates whether the right operand maps to xml\n     */\n    @Override\n    public void appendXmlComparison(SQLBuffer buf, String op, FilterValue lhs,\n        FilterValue rhs, boolean lhsxml, boolean rhsxml) {\n        super.appendXmlComparison(buf, op, lhs, rhs, lhsxml, rhsxml);\n        if (lhsxml && rhsxml)\n            appendXmlComparison2(buf, op, lhs, rhs);\n        else if (lhsxml)\n            appendXmlComparison1(buf, op, lhs, rhs);\n        else\n            appendXmlComparison1(buf, op, rhs, lhs);\n    }\n    /**\n     * Append an xml comparison predicate.\n     *\n     * @param buf the SQL buffer to write the comparison\n     * @param op the comparison operation to perform\n     * @param lhs the left hand side of the comparison (maps to xml column)\n     * @param rhs the right hand side of the comparison\n     */\n<fim_suffix>    private void appendXmlComparison1(SQLBuffer buf, String op,\n            FilterValue lhs, FilterValue rhs) {\n        boolean castrhs = false;\n        Class<?> rc = Filters.wrap(rhs.getType());\n        int type = 0;\n        if (rhs.isConstant()) {\n            type = getJDBCType(JavaTypes.getTypeCode(rc), false);\n            castrhs = true;\n        }\n        appendXmlExists(buf, lhs);\n        buf.append(\" \").append(op).append(\" \");\n        buf.append(\"$\");\n        if (castrhs)\n            buf.append(\"Parm\");\n        else\n            rhs.appendTo(buf);\n        buf.append(\"]' PASSING \");\n        appendXmlVar(buf, lhs);\n        buf.append(\", \");\n        if (castrhs)\n            appendCast(buf, rhs, type);\n        else\n            rhs.appendTo(buf);\n        buf.append(\" AS \\\"\");\n        if (castrhs)\n            buf.append(\"Parm\");\n        else\n            rhs.appendTo(buf);\n        buf.append(\"\\\")\");\n    }<fim_middle>// function below has no smell\n"}