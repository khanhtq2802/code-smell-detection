{"text": "<fim_prefix>import java.util.Properties;\nimport java.util.Set;\nimport java.util.jar.Attributes;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarInputStream;\nimport java.util.jar.JarOutputStream;\nimport java.util.jar.Manifest;\nimport org.apache.aries.spifly.ConsumerHeaderProcessor;\nimport org.apache.aries.spifly.SpiFlyConstants;\nimport org.apache.aries.spifly.Streams;\nimport org.apache.aries.spifly.Util;\nimport org.apache.aries.spifly.WeavingData;\nimport org.apache.aries.spifly.weaver.TCCLSetterVisitor;\nimport org.objectweb.asm.ClassReader;\nimport org.objectweb.asm.ClassWriter;\nimport org.osgi.framework.Constants;\nimport org.osgi.framework.Version;\npublic class Main {\n    private static final String MODIFIED_BUNDLE_SUFFIX = \"_spifly.jar\";\n    private static final String IMPORT_PACKAGE = \"Import-Package\";\n    public static void usage() {\n        System.err.println(\"This tool processes OSGi Bundles that use java.util.ServiceLoader.load() to\");\n        System.err.println(\"obtain implementations via META-INF/services. The byte code in the bundles is\");\n        System.err.println(\"modified so that the ThreadContextClassLoader is set appropriately for the \");\n        System.err.println(\"duration of the java.util.ServiceLoader.load() call.\");\n        System.err.println(\"To opt-in to this process, bundles need to have the following MANIFEST.MF\");\n        System.err.println(\"header set:\");\n        System.err.println(\"    \" + SpiFlyConstants.SPI_CONSUMER_HEADER + \": *\");\n        System.err.println(\"Modified bundles are written out under the following name:\");\n        System.err.println(\"    <original-bundle-name>\" + MODIFIED_BUNDLE_SUFFIX);\n        System.err.println();\n        System.err.println(\"Usage: java \" + Main.class.getName() + \" bundle1.jar bundle2.jar ...\");\n        System.exit(-1);\n    }\n    public static void main(String ... args) throws Exception {\n        if (args.length < 1)\n            usage();\n        for (String arg : args) {\n            weaveJar(arg);\n        }\n    }\n    private static void weaveJar(String jarPath) throws Exception {\n        System.out.println(\"[SPI Fly Static Tool] Processing: \" + jarPath);\n        File jarFile = new File(jarPath);\n        File tempDir = new File(System.getProperty(\"java.io.tmpdir\") + File.separator + jarFile.getName() + \"_\" + System.currentTimeMillis());\n        Manifest manifest = unJar(jarFile, tempDir);\n        String consumerHeaderVal = manifest.getMainAttributes().getValue(SpiFlyConstants.SPI_CONSUMER_HEADER);\n        String consumerHeaderKey = null;\n        if (consumerHeaderVal != null) {\n            consumerHeaderKey = SpiFlyConstants.SPI_CONSUMER_HEADER;\n        } else {\n            consumerHeaderVal = manifest.getMainAttributes().getValue(SpiFlyConstants.REQUIRE_CAPABILITY);\n            if (consumerHeaderVal != null) {\n                consumerHeaderKey = SpiFlyConstants.REQUIRE_CAPABILITY;\n            }\n        }\n        if (consumerHeaderVal != null) {\n            String bcp = manifest.getMainAttributes().getValue(Constants.BUNDLE_CLASSPATH);\n            weaveDir(tempDir, consumerHeaderKey, consumerHeaderVal, bcp);\n            if (SpiFlyConstants.SPI_CONSUMER_HEADER.equals(consumerHeaderKey)) {\n                manifest.getMainAttributes().remove(new Attributes.Name(SpiFlyConstants.SPI_CONSUMER_HEADER));\n                manifest.getMainAttributes().putValue(SpiFlyConstants.PROCESSED_SPI_CONSUMER_HEADER, consumerHeaderVal);\n            } else {\n                // It's SpiFlyConstants.REQUIRE_CAPABILITY\n                // Take out the processor requirement, this probably needs to be improved a little bit\n                String newConsumerHeaderVal = consumerHeaderVal.replaceAll(\n                        \"osgi[.]extender;\\\\s*filter[:][=][\\\"]?[(]osgi[.]extender[=]osgi[.]serviceloader[.]processor[)][\\\"]?\", \"\").\n                        trim();\n                if (newConsumerHeaderVal.startsWith(\",\"))\n                    newConsumerHeaderVal = newConsumerHeaderVal.substring(1);\n                if (newConsumerHeaderVal.endsWith(\",\"))\n                    newConsumerHeaderVal = newConsumerHeaderVal.substring(0, newConsumerHeaderVal.length()-1);\n                manifest.getMainAttributes().putValue(SpiFlyConstants.REQUIRE_CAPABILITY, newConsumerHeaderVal);\n                manifest.getMainAttributes().putValue(\"X-SpiFly-Processed-Require-Capability\", consumerHeaderVal);\n            }\n            // TODO if new packages needed then...\n            extendImportPackage(manifest);\n            File newJar = getNewJarFile(jarFile);\n            jar(newJar, tempDir, manifest);\n        } else {\n            System.out.println(\"[SPI Fly Static Tool] This file is not marked as an SPI Consumer.\");\n        }\n        delTree(tempDir);\n    }\n    private static void extendImportPackage(Manifest manifest) throws IOException {\n        String utilPkgVersion = getPackageVersion(Util.class);\n        Version osgiVersion = Version.parseVersion(utilPkgVersion);\n        Version minVersion = new Version(osgiVersion.getMajor(), osgiVersion.getMinor(), osgiVersion.getMicro());\n        Version maxVersion = new Version(osgiVersion.getMajor(), osgiVersion.getMinor() + 1, 0);\n        String ip = manifest.getMainAttributes().getValue(IMPORT_PACKAGE);\n        if (ip == null)\n            ip = \"\";\n        StringBuilder sb = new StringBuilder(ip);\n        if (ip.length() > 0)\n            sb.append(\",\");\n        sb.append(Util.class.getPackage().getName());\n        sb.append(\";version=\\\"[\");\n        sb.append(minVersion);\n        sb.append(\",\");\n        sb.append(maxVersion);\n        sb.append(\")\\\"\");\n        manifest.getMainAttributes().putValue(IMPORT_PACKAGE, sb.toString());\n    }\n    private static String getPackageVersion(Class<?> clazz) throws IOException {\n        URL url = clazz.getResource(\"packageinfo\");\n        if (url == null) {\n            throw new RuntimeException(\"'packageinfo' file with version information not found for package: \"\n                    + clazz.getPackage().getName());\n        }\n        byte[] bytes = Streams.suck(url.openStream());\n        Properties p = new Properties();\n        p.load(new ByteArrayInputStream(bytes));\n        return p.getProperty(\"version\");\n    }\n    private static File getNewJarFile(File jarFile) {\n        String s = jarFile.getAbsolutePath();\n        int idx = s.lastIndexOf('.');\n        s = s.substring(0, idx);\n        s += MODIFIED_BUNDLE_SUFFIX;\n        return new File(s);\n    }\n<fim_suffix>    private static void weaveDir(File dir, String consumerHeaderKey, String consumerHeaderValue, String bundleClassPath) throws Exception {\n        Set<WeavingData> wd = ConsumerHeaderProcessor.processHeader(consumerHeaderKey, consumerHeaderValue);\n        URLClassLoader cl = new URLClassLoader(new URL [] {dir.toURI().toURL()}, Main.class.getClassLoader());\n        String dirName = dir.getAbsolutePath();\n        DirTree dt = new DirTree(dir);\n        for (File f : dt.getFiles()) {\n            if (!f.getName().endsWith(\".class\"))\n                continue;\n            String className = f.getAbsolutePath().substring(dirName.length());\n            if (className.startsWith(File.separator))\n                className = className.substring(1);\n            className = className.substring(0, className.length() - \".class\".length());\n            className = className.replace(File.separator, \".\");\n            InputStream is = new FileInputStream(f);\n            byte[] b;\n            try {\n                ClassReader cr = new ClassReader(is);\n                ClassWriter cw = new StaticToolClassWriter(ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES, cl);\n                TCCLSetterVisitor cv = new TCCLSetterVisitor(cw, className, wd);\n                cr.accept(cv, ClassReader.SKIP_FRAMES);\n                if (cv.isWoven()) {\n                    b = cw.toByteArray();\n                } else {\n                    // if not woven, store the original bytes\n                    b = Streams.suck(new FileInputStream(f));\n                }\n            } finally {\n                is.close();\n            }\n            OutputStream os = new FileOutputStream(f);\n            try {\n                os.write(b);\n            } finally {\n                os.close();\n            }\n        }\n        if (bundleClassPath != null) {\n            for (String entry : bundleClassPath.split(\",\")) {\n                File jarFile = new File(dir, entry.trim());\n                if (jarFile.isFile()) {\n                    weaveBCPJar(jarFile, consumerHeaderKey, consumerHeaderValue);\n                }\n            }\n        }\n    }<fim_middle>// function below is long method and feature envy\n"}