{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.flume.interceptor;\n\nimport static org.apache.flume.interceptor.RegexFilteringInterceptor.Constants.DEFAULT_EXCLUDE_EVENTS;\nimport static org.apache.flume.interceptor.RegexFilteringInterceptor.Constants.DEFAULT_REGEX;\nimport static org.apache.flume.interceptor.RegexFilteringInterceptor.Constants.EXCLUDE_EVENTS;\nimport static org.apache.flume.interceptor.RegexFilteringInterceptor.Constants.REGEX;\n\nimport java.util.List;\nimport java.util.regex.Pattern;\n\nimport org.apache.flume.Context;\nimport org.apache.flume.Event;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.google.common.collect.Lists;\n\n/**\n * Interceptor that filters events selectively based on a configured regular\n * expression matching against the event body.\n *\n * This supports either include- or exclude-based filtering. A given\n * interceptor can only perform one of these functions, but multiple\n * interceptor can be chained together to create more complex\n * inclusion/exclusion patterns. If include-based filtering is configured, then\n * all events matching the supplied regular expression will be passed through\n * and all events not matching will be ignored. If exclude-based filtering is\n * configured, than all events matching will be ignored, and all other events\n * will pass through.\n *\n * Note that all regular expression matching occurs through Java's built in\n * java.util.regex package.\n *\n * Properties:<p>\n *\n *   regex: Regular expression for matching excluded events.\n *          (default is \".*\")<p>\n *\n *   excludeEvents: If true, a regex match determines events to exclude,\n *                  otherwise a regex determines events to include\n *                  (default is false)<p>\n *\n * Sample config:<p>\n *\n * <code>\n *   agent.sources.r1.channels = c1<p>\n *   agent.sources.r1.type = SEQ<p>\n *   agent.sources.r1.interceptors = i1<p>\n *   agent.sources.r1.interceptors.i1.type = REGEX<p>\n *   agent.sources.r1.interceptors.i1.regex = (WARNING)|(ERROR)|(FATAL)<p>\n * </code>\n *\n */\npublic class RegexFilteringInterceptor implements Interceptor {\n\n  private static final Logger logger = LoggerFactory\n      .getLogger(RegexFilteringInterceptor.class);\n\n  private final Pattern regex;\n  private final boolean excludeEvents;\n\n  /**\n   * Only {@link RegexFilteringInterceptor.Builder} can build me\n   */\n  private RegexFilteringInterceptor(Pattern regex, boolean excludeEvents) {\n    this.regex = regex;\n    this.excludeEvents = excludeEvents;\n  }\n\n  @Override\n  public void initialize() {\n    // no-op\n  }\n\n\n  @Override\n  /**\n   * Returns the event if it passes the regular expression filter and null\n   * otherwise.\n   */\n  public Event intercept(Event event) {\n    // We've already ensured here that at most one of includeRegex and\n    // excludeRegex are defined.\n\n    if (!excludeEvents) {\n      if (regex.matcher(new String(event.getBody())).find()) {\n        return event;\n      } else {\n        return null;\n      }\n    } else {\n      if (regex.matcher(new String(event.getBody())).find()) {\n        return null;\n      } else {\n        return event;\n      }\n    }\n  }\n\n  /**\n   * Returns the set of events which pass filters, according to\n   * {@link #intercept(Event)}.\n   * @param events\n   * @return\n   */\n  @Override\n  public List<Event> intercept(List<Event> events) {\n    List<Event> out = Lists.newArrayList();\n    for (Event event : events) {\n      Event outEvent = intercept(event);\n      if (outEvent != null) {\n        out.add(outEvent);\n      }\n    }\n    return out;\n  }\n\n  @Override\n  public void close() {\n    // no-op\n  }\n\n  /**\n   * Builder which builds new instance of the RegexFilteringInterceptor.\n   */\n<fim_suffix>  public static class Builder implements Interceptor.Builder {\n\n    private Pattern regex;\n    private boolean excludeEvents;\n\n    @Override\n    public void configure(Context context) {\n      String regexString = context.getString(REGEX, DEFAULT_REGEX);\n      regex = Pattern.compile(regexString);\n      excludeEvents = context.getBoolean(EXCLUDE_EVENTS,\n          DEFAULT_EXCLUDE_EVENTS);\n    }\n\n    @Override\n    public Interceptor build() {\n      logger.info(String.format(\n          \"Creating RegexFilteringInterceptor: regex=%s,excludeEvents=%s\",\n          regex, excludeEvents));\n      return new RegexFilteringInterceptor(regex, excludeEvents);\n    }\n  }\n\n  public static class Constants {\n\n    public static final String REGEX = \"regex\";\n    public static final String DEFAULT_REGEX = \".*\";\n\n    public static final String EXCLUDE_EVENTS = \"excludeEvents\";\n    public static final boolean DEFAULT_EXCLUDE_EVENTS = false;\n  }\n\n}<fim_middle>// class below has no smell\n"}