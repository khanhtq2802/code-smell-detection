{"text": "<fim_prefix>        throw new IllegalStateException(\"trunc() requires at least 1 argument, got \" + call.getOperands().size());\n      }\n      if (call.getOperands().size() == 1) {\n        final String arg = DruidExpressions.toDruidExpression(call.getOperands().get(0), rowType, query);\n        if (arg == null) {\n          return null;\n        }\n        if (SqlTypeUtil.isDatetime(call.getOperands().get(0).getType())) {\n          final TimeZone tz = timezoneId(query, call.getOperands().get(0));\n          return applyTimestampFormat(\n              DruidExpressions.applyTimestampFloor(arg, Period.days(1).toString(), \"\", tz),\n              YYYY_MM_DD,\n              tz);\n        }\n        return null;\n      } else if (call.getOperands().size() == 2) {\n        final String arg = DruidExpressions.toDruidExpression(call.getOperands().get(0), rowType, query);\n        if (arg == null) {\n          return null;\n        }\n        String granularity = DruidExpressions.toDruidExpression(call.getOperands().get(1), rowType, query);\n        if (granularity == null) {\n          return null;\n        }\n        final String unit;\n        if (\"'MONTH'\".equals(granularity) || \"'MON'\".equals(granularity) || \"'MM'\".equals(granularity)) {\n          unit = Period.months(1).toString();\n        } else if (\"'YEAR'\".equals(granularity) || \"'YYYY'\".equals(granularity) || \"'YY'\".equals(granularity)) {\n          unit = Period.years(1).toString();\n        } else if (\"'QUARTER'\".equals(granularity) || \"'Q'\".equals(granularity)) {\n          unit = Period.months(3).toString();\n        } else {\n          unit = null;\n        }\n        if (unit == null) {\n          //bail out can not infer unit\n          return null;\n        }\n        final TimeZone tz = timezoneId(query, call.getOperands().get(0));\n        return applyTimestampFormat(\n            DruidExpressions.applyTimestampFloor(arg, unit, \"\", tz),\n            YYYY_MM_DD,\n            tz);\n      }\n      return null;\n    }\n  }\n  /**\n   * Expression operator conversion form Hive TO_DATE operator to Druid Date cast.\n   */\n  public static class DruidToDateOperatorConversion\n      implements org.apache.calcite.adapter.druid.DruidSqlOperatorConverter {\n    @Override public SqlOperator calciteOperator() {\n      return HiveToDateSqlOperator.INSTANCE;\n    }\n    @Nullable @Override public String toDruidExpression(RexNode rexNode, RelDataType rowType, DruidQuery query\n    ) {\n      final RexCall call = (RexCall) rexNode;\n      if (call.getOperands().size() != 1) {\n        throw new IllegalStateException(\"to_date() requires 1 argument, got \" + call.getOperands().size());\n      }\n      final String arg = DruidExpressions.toDruidExpression(call.getOperands().get(0), rowType, query);\n      if (arg == null) {\n        return null;\n      }\n      return DruidExpressions.applyTimestampFloor(\n          arg,\n          Period.days(1).toString(),\n          \"\",\n          timezoneId(query, call.getOperands().get(0)));\n    }\n  }\n  public static class DruidUnixTimestampOperatorConversion\n      implements org.apache.calcite.adapter.druid.DruidSqlOperatorConverter {\n    @Override public SqlOperator calciteOperator() {\n      return HiveUnixTimestampSqlOperator.INSTANCE;\n    }\n    @Nullable @Override public String toDruidExpression(RexNode rexNode, RelDataType rowType, DruidQuery query\n    ) {\n      final RexCall call = (RexCall) rexNode;\n      final String arg0 = DruidExpressions.toDruidExpression(call.getOperands().get(0), rowType, query);\n      if (arg0 == null) {\n        return null;\n      }\n      if (SqlTypeUtil.isDatetime((call.getOperands().get(0).getType()))) {\n        // Timestamp is represented as long internally no need to any thing here\n        return DruidExpressions.functionCall(\"div\", ImmutableList.of(arg0, DruidExpressions.numberLiteral(1000)));\n      }\n      // dealing with String type\n      final String format = call.getOperands().size() == 2 ? DruidExpressions\n          .toDruidExpression(call.getOperands().get(1), rowType, query) : DEFAULT_TS_FORMAT;\n      return DruidExpressions\n          .functionCall(\"unix_timestamp\", ImmutableList.of(arg0, DruidExpressions.stringLiteral(format)));\n    }\n  }\n  public static class DruidFormUnixTimeOperatorConversion\n      implements org.apache.calcite.adapter.druid.DruidSqlOperatorConverter {\n    @Override public SqlOperator calciteOperator() {\n      return HiveFromUnixTimeSqlOperator.INSTANCE;\n    }\n    @Nullable @Override public String toDruidExpression(RexNode rexNode, RelDataType rowType, DruidQuery query\n    ) {\n      final RexCall call = (RexCall) rexNode;\n      if (call.getOperands().size() < 1 || call.getOperands().size() > 2) {\n        throw new IllegalStateException(\"form_unixtime() requires 1 or 2 argument, got \" + call.getOperands().size());\n      }\n      final String arg = DruidExpressions.toDruidExpression(call.getOperands().get(0), rowType, query);\n      if (arg == null) {\n        return null;\n      }\n      final String numMillis = DruidQuery.format(\"(%s * '1000')\", arg);\n      final String format =\n          call.getOperands().size() == 1 ? DruidExpressions.stringLiteral(DEFAULT_TS_FORMAT) : DruidExpressions\n              .toDruidExpression(call.getOperands().get(1), rowType, query);\n      return DruidExpressions.functionCall(\"timestamp_format\",\n          ImmutableList.of(numMillis, format, DruidExpressions.stringLiteral(TimeZone.getTimeZone(\"UTC\").getID()))\n      );\n    }\n  }\n  /**\n   * Base class for Date Add/Sub operator conversion\n   */\n  public static class DruidDateArithmeticOperatorConversion\n      implements org.apache.calcite.adapter.druid.DruidSqlOperatorConverter {\n    private final int direction;\n    private final SqlOperator operator;\n    public DruidDateArithmeticOperatorConversion(int direction, SqlOperator operator) {\n      this.direction = direction;\n      this.operator = operator;\n      Preconditions.checkArgument(direction == 1 || direction == -1);\n    }\n    @Override public SqlOperator calciteOperator() {\n      return operator;\n    }\n    @Nullable @Override public String toDruidExpression(RexNode rexNode, RelDataType rowType, DruidQuery query\n    ) {\n      final RexCall call = (RexCall) rexNode;\n      if (call.getOperands().size() != 2) {\n        throw new IllegalStateException(\"date_add/date_sub() requires 2 arguments, got \" + call.getOperands().size());\n      }\n      final String arg0 = DruidExpressions.toDruidExpression(call.getOperands().get(0), rowType, query);\n      final String arg1 = DruidExpressions.toDruidExpression(call.getOperands().get(1), rowType, query);\n      if (arg0 == null || arg1 == null) {\n        return null;\n      }\n      final String steps = direction == -1 ? DruidQuery.format(\"-( %s )\", arg1) : arg1;\n      return DruidExpressions.functionCall(\n          \"timestamp_shift\",\n          ImmutableList.of(\n              arg0,\n              DruidExpressions.stringLiteral(\"P1D\"),\n              steps,\n              DruidExpressions.stringLiteral(timezoneId(query, call.getOperands().get(0)).getID())));\n    }\n  }\n  /**\n   * utility function to extract timezone id from Druid query\n   * @param query Druid Rel\n   * @return time zone\n   */\n  private static TimeZone timezoneId(final DruidQuery query, final RexNode arg) {\n    return arg.getType().getSqlTypeName() == SqlTypeName.TIMESTAMP_WITH_LOCAL_TIME_ZONE\n        ? TimeZone.getTimeZone(\n        query.getTopNode().getCluster().getPlanner().getContext().unwrap(CalciteConnectionConfig.class).timeZone()) :\n        TimeZone.getTimeZone(\"UTC\");\n  }\n<fim_suffix>  private static String applyTimestampFormat(String arg, String format, TimeZone timeZone) {\n    return DruidExpressions.functionCall(\"timestamp_format\",\n        ImmutableList.of(arg, DruidExpressions.stringLiteral(format), DruidExpressions.stringLiteral(timeZone.getID()))\n    );\n  }<fim_middle>// function below has no smell\n"}