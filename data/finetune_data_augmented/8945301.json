{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hive.ptest.execution.ssh;\n\nimport java.io.IOException;\nimport java.util.concurrent.Semaphore;\nimport java.util.concurrent.TimeUnit;\n\nimport org.apache.hive.ptest.execution.Constants;\nimport org.apache.hive.ptest.execution.LocalCommand;\nimport org.apache.hive.ptest.execution.LocalCommandFactory;\nimport org.apache.hive.ptest.execution.LocalCommand.CollectPolicy;\nimport org.slf4j.Logger;\n\n\n<fim_suffix>public class RSyncCommandExecutor {\n  private final Logger mLogger;\n  private final int mMaxRsyncThreads;\n  private final LocalCommandFactory mLocalCommandFactory;\n  private final Semaphore mSemaphore;\n  private volatile boolean mShutdown;\n\n  public RSyncCommandExecutor(Logger logger, int maxRsyncThreads, LocalCommandFactory localCommandFactory) {\n    mLogger = logger;\n    mMaxRsyncThreads = Math.min(Runtime.getRuntime().availableProcessors() * 5, maxRsyncThreads);\n    mLocalCommandFactory = localCommandFactory;\n    mSemaphore = new Semaphore(mMaxRsyncThreads);\n    mShutdown = false;\n    mLogger.info(\"RSyncCommandExecutor has \" + mMaxRsyncThreads + \" threads on \" + Runtime.getRuntime()\n      .availableProcessors() + \" cpus\");\n  }\n\n  /**\n   * Execute the given RSync. If the command exits with a non-zero\n   * exit status the command will be retried up to three times.\n   */\n  public void execute(RSyncCommand command) {\n    CollectPolicy collector = new CollectPolicy();\n    boolean release = false;\n    try {\n      mSemaphore.acquire();\n      release = true;\n      int attempts = 0;\n      boolean retry;\n      LocalCommand cmd;\n      do {\n        retry = false;\n        if(command.getType() == RSyncCommand.Type.TO_LOCAL) {\n          cmd = mLocalCommandFactory.create(collector,\n              String.format(\"timeout 1h rsync -vaPe \\\"ssh -i %s\\\" --timeout 600 %s@%s:%s %s\",\n                  command.getPrivateKey(), command.getUser(), command.getHost(),\n                  command.getRemoteFile(), command.getLocalFile()));\n        } else if (command.getType() == RSyncCommand.Type.TO_LOCAL_NON_RECURSIVE) {\n          cmd = mLocalCommandFactory.create(collector,\n              String.format(\"timeout 1h rsync --exclude \\\"*/\\\" -vaPe \\\"ssh -i %s\\\" --timeout 600 %s@%s:%s %s\",\n                  command.getPrivateKey(), command.getUser(), command.getHost(),\n                  command.getRemoteFile(), command.getLocalFile()));\n        } else if(command.getType() == RSyncCommand.Type.FROM_LOCAL) {\n          cmd = mLocalCommandFactory.create(collector,\n              String.format(\"timeout 1h rsync -vaPe \\\"ssh -i %s\\\" --timeout 600 --delete --delete-during --force %s %s@%s:%s\",\n                  command.getPrivateKey(), command.getLocalFile(), command.getUser(), command.getHost(),\n                  command.getRemoteFile()));\n        } else {\n          throw new UnsupportedOperationException(String.valueOf(command.getType()));\n        }\n        if(mShutdown) {\n          mLogger.warn(\"Shutting down command \" + command);\n          cmd.kill();\n          command.setExitCode(Constants.EXIT_CODE_UNKNOWN);\n          return;\n        }\n        // 12 is timeout and 255 is unspecified error\n        if(attempts++ <= 3 && cmd.getExitCode() != 0) {\n          mLogger.warn(\"Command exited with \" + cmd.getExitCode() + \", will retry: \" + command);\n          retry = true;\n          TimeUnit.SECONDS.sleep(20);\n        }\n      } while (!mShutdown && retry); // an error occurred, re-try\n      command.setExitCode(cmd.getExitCode());\n      command.setElapsedTimeInMs(cmd.getElapsedTimeInMs());\n    } catch (IOException e) {\n      command.setException(e);\n    } catch (InterruptedException e) {\n      command.setException(e);\n    } finally {\n      if(release) {\n        mSemaphore.release();\n      }\n      command.setOutput(collector.getOutput());\n    }\n  }\n  boolean isShutdown() {\n    return mShutdown;\n  }\n  public void shutdownNow() {\n    this.mShutdown = true;\n  }\n}<fim_middle>// class below has no smell\n"}