{"text": "<fim_prefix> *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.activemq.artemis.api.core;\nimport java.io.InputStream;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\nimport io.netty.buffer.ByteBuf;\nimport org.apache.activemq.artemis.core.message.impl.CoreMessageObjectPools;\nimport org.apache.activemq.artemis.core.persistence.Persister;\n/**\n * A Message is a routable instance that has a payload.\n * <p>\n * The payload (the \"body\") is opaque to the messaging system. A Message also has a fixed set of\n * headers (required by the messaging system) and properties (defined by the users) that can be used\n * by the messaging system to route the message (e.g. to ensure it matches a queue filter).\n * <h2>Message Properties</h2>\n * <p>\n * Message can contain properties specified by the users. It is possible to convert from some types\n * to other types as specified by the following table:\n * <pre>\n * |        | boolean byte short int long float double String byte[]\n * |----------------------------------------------------------------\n * |boolean |    X                                      X\n * |byte    |          X    X    X   X                  X\n * |short   |               X    X   X                  X\n * |int     |                    X   X                  X\n * |long    |                        X                  X\n * |float   |                              X     X      X\n * |double  |                                    X      X\n * |String  |    X     X    X    X   X     X     X      X\n * |byte[]  |                                                   X\n * |-----------------------------------------------------------------\n * </pre>\n * <p>\n * If conversion is not allowed (for example calling {@code getFloatProperty} on a property set a\n * {@code boolean}), a {@link ActiveMQPropertyConversionException} will be thrown.\n *\n *\n * User cases that will be covered by Message\n *\n * Receiving a buffer:\n *\n * Message encode = new CoreMessage(); // or any other implementation\n * encode.receiveBuffer(buffer);\n *\n *\n * Sending to a buffer:\n *\n * Message encode;\n * size = encode.getEncodeSize();\n * encode.encodeDirectly(bufferOutput);\n *\n */\npublic interface Message {\n   // This is an estimate of how much memory a Message takes up, excluding body and properties\n   // Note, it is only an estimate, it's not possible to be entirely sure with Java\n   // This figure is calculated using the test utilities in org.apache.activemq.tests.unit.util.sizeof\n   // The value is somewhat higher on 64 bit architectures, probably due to different alignment\n   int memoryOffset = 352;\n   SimpleString HDR_ROUTE_TO_IDS = new SimpleString(\"_AMQ_ROUTE_TO\");\n   SimpleString HDR_SCALEDOWN_TO_IDS = new SimpleString(\"_AMQ_SCALEDOWN_TO\");\n   SimpleString HDR_ROUTE_TO_ACK_IDS = new SimpleString(\"_AMQ_ACK_ROUTE_TO\");\n   // used by the bridges to set duplicates\n   SimpleString HDR_BRIDGE_DUPLICATE_ID = new SimpleString(\"_AMQ_BRIDGE_DUP\");\n   /**\n    * the actual time the message was expired.\n    * * *\n    */\n   SimpleString HDR_ACTUAL_EXPIRY_TIME = new SimpleString(\"_AMQ_ACTUAL_EXPIRY\");\n   /**\n    * The original address of a message when a message is diverted or transferred through DLQ or expiry\n    */\n   SimpleString HDR_ORIGINAL_ADDRESS = new SimpleString(\"_AMQ_ORIG_ADDRESS\");\n   /**\n    * The original address of a message when a message is transferred through DLQ or expiry\n    */\n   SimpleString HDR_ORIGINAL_QUEUE = new SimpleString(\"_AMQ_ORIG_QUEUE\");\n   /**\n    * The original message ID before the message was transferred.\n    */\n   SimpleString HDR_ORIG_MESSAGE_ID = new SimpleString(\"_AMQ_ORIG_MESSAGE_ID\");\n   /**\n    * For the Message Grouping feature.\n    */\n   SimpleString HDR_GROUP_ID = new SimpleString(\"_AMQ_GROUP_ID\");\n   SimpleString HDR_GROUP_SEQUENCE = new SimpleString(\"_AMQ_GROUP_SEQUENCE\");\n   /**\n    * to determine if the Large Message was compressed.\n    */\n   SimpleString HDR_LARGE_COMPRESSED = new SimpleString(\"_AMQ_LARGE_COMPRESSED\");\n   /**\n    * The body size of a large message before it was compressed.\n    */\n   SimpleString HDR_LARGE_BODY_SIZE = new SimpleString(\"_AMQ_LARGE_SIZE\");\n   /**\n    * To be used with Scheduled Delivery.\n    */\n   SimpleString HDR_SCHEDULED_DELIVERY_TIME = new SimpleString(\"_AMQ_SCHED_DELIVERY\");\n   /**\n    * To be used with duplicate detection.\n    */\n   SimpleString HDR_DUPLICATE_DETECTION_ID = new SimpleString(\"_AMQ_DUPL_ID\");\n   /**\n    * To be used with Last value queues.\n    */\n   SimpleString HDR_LAST_VALUE_NAME = new SimpleString(\"_AMQ_LVQ_NAME\");\n   /**\n    * To define the mime-type of body messages. Mainly for stomp but it could be informed on any message for user purposes.\n    */\n   SimpleString HDR_CONTENT_TYPE = new SimpleString(\"_AMQ_CONTENT_TYPE\");\n   /**\n    * The name of the validated user who sent the message. Useful for auditing.\n    */\n   SimpleString HDR_VALIDATED_USER = new SimpleString(\"_AMQ_VALIDATED_USER\");\n   /**\n    * The Routing Type for this message.  Ensures that this message is only routed to queues with matching routing type.\n    */\n   SimpleString HDR_ROUTING_TYPE = new SimpleString(\"_AMQ_ROUTING_TYPE\");\n   /**\n    * The prefix used (if any) when sending this message.  For protocols (e.g. STOMP) that need to track this and restore\n    * the prefix when the message is consumed.\n    */\n   SimpleString HDR_PREFIX = new SimpleString(\"_AMQ_PREFIX\");\n   byte DEFAULT_TYPE = 0;\n   byte OBJECT_TYPE = 2;\n   byte TEXT_TYPE = 3;\n   byte BYTES_TYPE = 4;\n   byte MAP_TYPE = 5;\n   byte STREAM_TYPE = 6;\n   /** The message will contain another message persisted through {@link org.apache.activemq.artemis.spi.core.protocol.EmbedMessageUtil}*/\n   byte EMBEDDED_TYPE = 7;\n   default void clearInternalProperties() {\n      // only on core\n   }\n   default RoutingType getRoutingType() {\n      return null;\n   }\n   default Message setRoutingType(RoutingType routingType) {\n      return this;\n   }\n   default SimpleString getLastValueProperty() {\n      return null;\n   }\n   default Message setLastValueProperty(SimpleString lastValueName) {\n      return this;\n   }\n   /**\n    * @deprecated do not use this, use through ICoreMessage or ClientMessage\n    */\n   @Deprecated\n   default InputStream getBodyInputStream() {\n      return null;\n   }\n   /**\n    * @deprecated do not use this, use through ICoreMessage or ClientMessage\n    */\n   @Deprecated\n   default ActiveMQBuffer getBodyBuffer() {\n      return null;\n   }\n      /**\n       * @deprecated do not use this, use through ICoreMessage or ClientMessage\n       */\n   @Deprecated\n   default byte getType() {\n      return (byte)0;\n   }\n   /**\n    * @deprecated do not use this, use through ICoreMessage or ClientMessage\n    */\n   @Deprecated\n   default Message setType(byte type) {\n      return this;\n   }\n   void messageChanged();\n   /** Used to calculate what is the delivery time.\n    *  Return null if not scheduled. */\n   Long getScheduledDeliveryTime();\n   default Message setScheduledDeliveryTime(Long time) {\n      return this;\n   }\n   /** Context can be used by the application server to inject extra control, like a protocol specific on the server.\n    * There is only one per Object, use it wisely!\n    *\n    * Note: the intent of this was to replace PageStore reference on Message, but it will be later increased by adidn a ServerPojo\n    * */\n   RefCountMessageListener getContext();\n   default SimpleString getGroupID() {\n      return null;\n   }\n   default Message setGroupID(SimpleString groupID) {\n      return this;\n   }\n   default Message setGroupID(String groupID) {\n      return this;\n   }\n<fim_suffix>   default int getGroupSequence() {\n      return 0;\n   }<fim_middle>// function below has no smell\n"}