{"text": "<fim_prefix>import com.linkedin.parseq.internal.ArgumentUtil;\nimport com.linkedin.parseq.promise.Promise;\nimport com.linkedin.parseq.promise.Promises;\nimport com.linkedin.parseq.promise.SettablePromise;\nimport com.linkedin.r2.message.RequestContext;\nimport com.linkedin.restli.client.config.ConfigValue;\nimport com.linkedin.restli.client.config.RequestConfig;\nimport com.linkedin.restli.client.config.RequestConfigBuilder;\nimport com.linkedin.restli.client.config.RequestConfigOverrides;\nimport com.linkedin.restli.client.config.RequestConfigProvider;\nimport com.linkedin.restli.client.metrics.BatchingMetrics;\nimport com.linkedin.restli.client.metrics.Metrics;\nimport com.linkedin.restli.common.OperationNameGenerator;\n/**\n * A ParSeq client that creates a ParSeq task from a rest.li {@link Request} by sending the request to underlying rest.li\n * {@link Client}. ParSeqRestClient delegates task execution to Rest.li Client {@link Client#sendRequest(Request, Callback)}\n * method that takes a {@link PromiseCallbackAdapter}. ParSeq task created from {@link ParSeqRestClient} may fail when\n * {@link PromiseCallbackAdapter} receives the following error conditions:\n * <p>\n * 1. @{link RestLiResponseExcepion}: Request has reached Rest.li server and rest.li server throws RestLiServiceException.\n * 2. @{link RemoteInvocationException}: Request failed before reaching rest.li server, for example, RestException thrown\n * from request filters, {@link javax.naming.ServiceUnavailableException} when client cannot find available server instance\n * that could serve the request, etc.\n * 3. @{link TimeoutException}: Request times out after configured timeoutMs.\n * </p>\n *\n * @author Jaroslaw Odzga (jodzga@linkedin.com)\n * @author Min Chen (mnchen@linkedin.com)\n *\n */\npublic class ParSeqRestClient extends BatchingStrategy<RequestGroup, RestRequestBatchKey, Response<Object>>\n    implements ParSeqRestliClient {\n  private static final Logger LOGGER = LoggerFactory.getLogger(ParSeqRestClient.class);\n  private final Client _client;\n  private final BatchingMetrics _batchingMetrics = new BatchingMetrics();\n  private final RequestConfigProvider _requestConfigProvider;\n  private final boolean _d2RequestTimeoutEnabled;\n  private final Function<Request<?>, RequestContext> _requestContextProvider;\n  ParSeqRestClient(final Client client, final RequestConfigProvider requestConfigProvider,\n      Function<Request<?>, RequestContext> requestContextProvider, final boolean d2RequestTimeoutEnabled) {\n    ArgumentUtil.requireNotNull(client, \"client\");\n    ArgumentUtil.requireNotNull(requestConfigProvider, \"requestConfigProvider\");\n    ArgumentUtil.requireNotNull(requestContextProvider, \"requestContextProvider\");\n    _client = client;\n    _requestConfigProvider = requestConfigProvider;\n    _requestContextProvider = requestContextProvider;\n    _d2RequestTimeoutEnabled = d2RequestTimeoutEnabled;\n  }\n  /**\n   * Creates new ParSeqRestClient with default configuration.\n   *\n   * @deprecated Please use {@link ParSeqRestliClientBuilder} to create instances.\n   */\n  @Deprecated\n  public ParSeqRestClient(final Client client) {\n    ArgumentUtil.requireNotNull(client, \"client\");\n    _client = client;\n    _requestConfigProvider = RequestConfigProvider.build(new ParSeqRestliClientConfigBuilder().build(), () -> Optional.empty());\n    _requestContextProvider = request -> new RequestContext();\n    _d2RequestTimeoutEnabled = false;\n  }\n  /**\n   * Creates new ParSeqRestClient with default configuration.\n   *\n   * @deprecated Please use {@link ParSeqRestliClientBuilder} to create instances.\n   */\n  @Deprecated\n  public ParSeqRestClient(final RestClient client) {\n    ArgumentUtil.requireNotNull(client, \"client\");\n    _client = client;\n    _requestConfigProvider = RequestConfigProvider.build(new ParSeqRestliClientConfigBuilder().build(), () -> Optional.empty());\n    _requestContextProvider = request -> new RequestContext();\n    _d2RequestTimeoutEnabled = false;\n  }\n  @Override\n  @Deprecated\n  public <T> Promise<Response<T>> sendRequest(final Request<T> request) {\n    return sendRequest(request, _requestContextProvider.apply(request));\n  }\n  @Override\n  @Deprecated\n  public <T> Promise<Response<T>> sendRequest(final Request<T> request, final RequestContext requestContext) {\n    final SettablePromise<Response<T>> promise = Promises.settable();\n    _client.sendRequest(request, requestContext, new PromiseCallbackAdapter<T>(promise));\n    return promise;\n  }\n  static class PromiseCallbackAdapter<T> implements Callback<Response<T>> {\n    private final SettablePromise<Response<T>> _promise;\n    public PromiseCallbackAdapter(final SettablePromise<Response<T>> promise) {\n      this._promise = promise;\n    }\n    @Override\n    public void onSuccess(final Response<T> result) {\n      try {\n        _promise.done(result);\n      } catch (Exception e) {\n        onError(e);\n      }\n    }\n    @Override\n    public void onError(final Throwable e) {\n      _promise.fail(e);\n    }\n  }\n  @Override\n  public <T> Task<Response<T>> createTask(final Request<T> request) {\n    return createTask(request, _requestContextProvider.apply(request));\n  }\n  @Override\n  public <T> Task<Response<T>> createTask(final Request<T> request, final RequestContext requestContext) {\n    return createTask(generateTaskName(request), request, requestContext, _requestConfigProvider.apply(request));\n  }\n  /**\n   * @deprecated ParSeqRestClient generates consistent names for tasks based on request parameters and it is\n   * recommended to us default names.\n   */\n  @Deprecated\n  public <T> Task<Response<T>> createTask(final String name, final Request<T> request, final RequestContext requestContext) {\n    return createTask(name, request, requestContext, _requestConfigProvider.apply(request));\n  }\n  @Override\n  public <T> Task<Response<T>> createTask(Request<T> request, RequestConfigOverrides configOverrides) {\n    return createTask(request,  _requestContextProvider.apply(request), configOverrides);\n  }\n  @Override\n  public <T> Task<Response<T>> createTask(Request<T> request, RequestContext requestContext,\n      RequestConfigOverrides configOverrides) {\n    RequestConfig config = _requestConfigProvider.apply(request);\n    RequestConfigBuilder configBuilder = new RequestConfigBuilder(config);\n    RequestConfig effectiveConfig = configBuilder.applyOverrides(configOverrides).build();\n    return createTask(generateTaskName(request), request, requestContext, effectiveConfig);\n  }\n  /**\n   * Generates a task name for the request.\n   * @param request\n   * @return a task name\n   */\n  static String generateTaskName(final Request<?> request) {\n    return request.getBaseUriTemplate() + \" \"\n        + OperationNameGenerator.generate(request.getMethod(), request.getMethodName());\n  }\n  private <T> Task<Response<T>> withTimeout(final Task<Response<T>> task, ConfigValue<Long> timeout) {\n    if (timeout.getSource().isPresent()) {\n      return task.withTimeout(\"src: \" + timeout.getSource().get(), timeout.getValue(), TimeUnit.MILLISECONDS);\n    } else {\n      return task.withTimeout(timeout.getValue(), TimeUnit.MILLISECONDS);\n    }\n  }\n  private <T> Task<Response<T>> withD2Timeout(final Task<Response<T>> task, ConfigValue<Long> timeout) {\n    String srcDesc = timeout.getSource().map(src -> \" src: \" + src).orElse(\"\");\n    String timeoutTaskName = \"withTimeout \" + timeout.getValue().intValue() + TimeUnitHelper.toString(TimeUnit.MILLISECONDS)\n        + srcDesc;\n    // make sure that we throw the same exception to maintain backward compatibility with current withTimeout implementation.\n    return task.transform(timeoutTaskName, (Try<Response<T>> tryGet) -> {\n      if (tryGet.isFailed() && tryGet.getError() instanceof TimeoutException) {\n        String timeoutExceptionMessage = \"task: '\" + task.getName() + \"' \" + timeoutTaskName;\n        return Failure.of(Exceptions.timeoutException(timeoutExceptionMessage));\n      } else {\n        return tryGet;\n      }\n    });\n  }\n<fim_suffix>  private <T> Task<Response<T>> createTask(final String name, final Request<T> request,\n      final RequestContext requestContext, RequestConfig config) {\n    LOGGER.debug(\"createTask, name: '{}', config: {}\", name, config);\n    if (_d2RequestTimeoutEnabled) {\n      return createTaskWithD2Timeout(name, request, requestContext, config);\n    } else {\n      return createTaskWithTimeout(name, request, requestContext, config);\n    }\n  }<fim_middle>// function below has no smell\n"}