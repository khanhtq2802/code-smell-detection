{"text": "<fim_prefix>/*[INCLUDE-IF Sidecar18-SE]*/\n/*******************************************************************************\n * Copyright (c) 2004, 2018 IBM Corp. and others\n *\n * This program and the accompanying materials are made available under\n * the terms of the Eclipse Public License 2.0 which accompanies this\n * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n * or the Apache License, Version 2.0 which accompanies this distribution and\n * is available at https://www.apache.org/licenses/LICENSE-2.0.\n *\n * This Source Code may also be made available under the following\n * Secondary Licenses when the conditions for such availability set\n * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n * General Public License, version 2 with the GNU Classpath\n * Exception [1] and GNU General Public License, version 2 with the\n * OpenJDK Assembly Exception [2].\n *\n * [1] https://www.gnu.org/software/classpath/license.html\n * [2] http://openjdk.java.net/legal/assembly-exception.html\n *\n * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n *******************************************************************************/\npackage com.ibm.dtfj.corereaders;\n\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.SortedMap;\nimport java.util.TreeMap;\n\n/**\n *  Class to maintain a list of addresses and coverage extents and a\n * symbolic name - then given an input address will convert this into \n * a string showing offset from the symbol. \n */ \npublic class Symbol {\n\t\n\tString symbolName;\n\tlong symbolStart;\n\tlong symbolEnd;  // -1 = unknown\n\tint symbolType;  // -1 = unknown\n\tint symbolBinding; // -1 = unknown\n\t\n\tprotected static HashMap knownSymbolsByName;  \n\tprotected static TreeMap symbolTree;\n\t\n\tfinal static int STB_UNKNOWN = -1;\n\tfinal static int STB_LOCAL = 0;\n\tfinal static int STB_GLOBAL = 1;\n\tfinal static int STB_WEAK = 2;\n\t\n\t   // values for st_info field\n    static final int STT_NOTYPE = 0;\n    static final int STT_OBJECT = 1;\n    static final int STT_FUNC = 2;\n    static final int STT_SECTION = 3;\n    static final int STT_FILE = 4;\n    static final int STT_COMMON = 5;\n    static final int STT_TLS = 6;\n    static final int STT_LOOS = 10;\n    static final int STT_HIOS = 12;\n    static final int STT_LOPROC = 13;\n    static final int STT_HIPROC = 15;\n\n\tpublic Symbol(String name, long address, int extent, int type, int bind) {\n\t\t\n\t\t// check don't already have this name \n\t\t\n\t\t \n\t\tif (null == knownSymbolsByName) {\n\t\t\tknownSymbolsByName = new HashMap();\n\t\t}\n\t\tObject o = knownSymbolsByName.get(name);\n\t\tif (o == null ) {\n\t\t\n\t\t\tsymbolName = name;\n\t\t\tsymbolStart = address;\n\t\t\tsymbolType = type;\n\t\t\tsymbolBinding = bind;\n\t\t\t// we use -1 for symbols whose extent is unknown \n\t\t\tif (extent != -1) {\n\t\t\t\tsymbolEnd = address+extent;\n\t\t\t} else {\n\t\t\t\tsymbolEnd = -1;\n\t\t\t}\n\t\t\n\t\t\t// Now update the Hash map of symbols\n\t\t\t \n\t\t\tknownSymbolsByName.put(name,this);\n\t\t\t// ... and into the range tree\n\t\t\tif (null == symbolTree) {\n\t\t\t\t\n\t\t\t\tComparator c = new Symbol.SymbolComparator();\n\t\t\t\tsymbolTree = new TreeMap(c);\n\t\t\t}\n\t\t\tsymbolTree.put(Long.valueOf(address),this);\n\t\t\t \n\t\t}\n\t\t\n\t}\n\t\n\tpublic static Symbol getSymbol(String name) {\n\t\tSymbol retSym = null;\n\t\t\n\t\tretSym = (Symbol)knownSymbolsByName.get(name);\n\t\t\n\t\treturn retSym;\n\t\t\n\t}\n\t\n\tpublic static String getSymbolForAddress(long address) {\n\t\tString retString = null;\n\t\t \n\t\tSortedMap head = (SortedMap) symbolTree.headMap(Long.valueOf(address));\n\t\t\n\t\t// So now we look at bottom of tail and hopefully we might have a \n\t\t// symbol covering this address.... \n\t\tif (head != null && !head.isEmpty()) {\n\t\t\t \n\t\t\tSymbol s = (Symbol) symbolTree.get(head.lastKey());\n\t\t\tif (s.symbolEnd == -1) {\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\tif (address <= s.symbolEnd && address > s.symbolStart) {\n\t\t\t\t\tlong diff = address - s.symbolStart;\n\t\t\t\t\tretString =  s.symbolName + \"+0x\" + Long.toHexString(diff); \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn retString;\n\t}\n\t\n<fim_suffix>\tstatic final class SymbolComparator implements Comparator {\n\n\t\t/* (non-Javadoc)\n\t\t * @see java.util.Comparator#compare(java.lang.Object, java.lang.Object)\n\t\t */\n\t\tpublic int compare(Object arg0, Object arg1) {\n\t\t\t \n\t\t\tlong addr0=0;\n\t\t\tlong addr1=0;\n\t\t\t// arg0 and arg1 will be Symbol objects \n\t\t\tif (arg0 instanceof Symbol) {\n\t\t\t\tSymbol S0 = (Symbol) arg0;\n\t\t\t\tSymbol S1 = (Symbol) arg1;\n\t\t\t\taddr0 = S0.symbolStart;\n\t\t\t\taddr1 = S1.symbolStart;\n\t\t\t} else {\n\t\t\t\taddr0 = ((Long)arg0).longValue();\n\t\t\t\taddr1 = ((Long)arg1).longValue();\n\t\t\t}\n\t\t\t\n\t\t\t// both +ve\n\t\t\tif (addr0 >= 0 && addr1 >=0) {\n\t\t\t\tif (addr0 == addr1) return 0;\n\t\t\t\tif (addr0 < addr1) return -1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\t\n\t\t\t// both -ve \n\t\t\tif (addr0 < 0 && addr1 < 0) {\n\t\t\t\tif (addr0 == addr1) return 0;\n\t\t\t\tif (addr0 < addr1) return 1;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t\n\t\t\tif (addr0 < 0 && addr1 >=0) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\t\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t}\n\n\t/**\n\t * @return Returns the symbolEnd.\n\t */\n\tpublic long getSymbolEnd() {\n\t\treturn symbolEnd;\n\t}\n\t/**\n\t * @return Returns the symbolName.\n\t */\n\tpublic String getSymbolName() {\n\t\treturn symbolName;\n\t}\n\t/**\n\t * @return Returns the symbolStart.\n\t */\n\tpublic long getSymbolStart() {\n\t\treturn symbolStart;\n\t}\n\t\n\tpublic static Iterator getSymbolsIterator() {\n\t\treturn symbolTree.keySet().iterator();\n\t\t//return knownSymbolsByName.keySet().iterator();\n\t\t \n\t}\n\t\n\tpublic static Symbol getSymbolUsingValue(Long l) {\n\t\tSymbol s = (Symbol) symbolTree.get(l);\n\t\treturn s;\n\t}\n\t \n}<fim_middle>// class below is blob\n"}