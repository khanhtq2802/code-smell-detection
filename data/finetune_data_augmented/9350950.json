{"text": "<fim_prefix>     * Other {@code ChronoUnit} values will throw an exception.\n     * <p>\n     * If the unit is not a {@code ChronoUnit}, then the result of this method\n     * is obtained by invoking {@code TemporalUnit.between(Temporal, Temporal)}\n     * passing {@code this} as the first argument and the converted input temporal\n     * as the second argument.\n     * <p>\n     * This instance is immutable and unaffected by this method call.\n     *\n     * @param endExclusive  the end date, exclusive, which is converted to an {@code OffsetDateTime}, not null\n     * @param unit  the unit to measure the amount in, not null\n     * @return the amount of time between this date-time and the end date-time\n     * @throws DateTimeException if the amount cannot be calculated, or the end\n     *  temporal cannot be converted to an {@code OffsetDateTime}\n     * @throws UnsupportedTemporalTypeException if the unit is not supported\n     * @throws ArithmeticException if numeric overflow occurs\n     */\n    @Override\n    public long until(Temporal endExclusive, TemporalUnit unit) {\n        OffsetDateTime end = OffsetDateTime.from(endExclusive);\n        if (unit instanceof ChronoUnit) {\n            end = end.withOffsetSameInstant(offset);\n            return dateTime.until(end.dateTime, unit);\n        }\n        return unit.between(this, end);\n    }\n    /**\n     * Formats this date-time using the specified formatter.\n     * <p>\n     * This date-time will be passed to the formatter to produce a string.\n     *\n     * @param formatter  the formatter to use, not null\n     * @return the formatted date-time string, not null\n     * @throws DateTimeException if an error occurs during printing\n     */\n    public String format(DateTimeFormatter formatter) {\n        Objects.requireNonNull(formatter, \"formatter\");\n        return formatter.format(this);\n    }\n    //-----------------------------------------------------------------------\n    /**\n     * Combines this date-time with a time-zone to create a {@code ZonedDateTime}\n     * ensuring that the result has the same instant.\n     * <p>\n     * This returns a {@code ZonedDateTime} formed from this date-time and the specified time-zone.\n     * This conversion will ignore the visible local date-time and use the underlying instant instead.\n     * This avoids any problems with local time-line gaps or overlaps.\n     * The result might have different values for fields such as hour, minute an even day.\n     * <p>\n     * To attempt to retain the values of the fields, use {@link #atZoneSimilarLocal(ZoneId)}.\n     * To use the offset as the zone ID, use {@link #toZonedDateTime()}.\n     *\n     * @param zone  the time-zone to use, not null\n     * @return the zoned date-time formed from this date-time, not null\n     */\n    public ZonedDateTime atZoneSameInstant(ZoneId zone) {\n        return ZonedDateTime.ofInstant(dateTime, offset, zone);\n    }\n    /**\n     * Combines this date-time with a time-zone to create a {@code ZonedDateTime}\n     * trying to keep the same local date and time.\n     * <p>\n     * This returns a {@code ZonedDateTime} formed from this date-time and the specified time-zone.\n     * Where possible, the result will have the same local date-time as this object.\n     * <p>\n     * Time-zone rules, such as daylight savings, mean that not every time on the\n     * local time-line exists. If the local date-time is in a gap or overlap according to\n     * the rules then a resolver is used to determine the resultant local time and offset.\n     * This method uses {@link ZonedDateTime#ofLocal(LocalDateTime, ZoneId, ZoneOffset)}\n     * to retain the offset from this instance if possible.\n     * <p>\n     * Finer control over gaps and overlaps is available in two ways.\n     * If you simply want to use the later offset at overlaps then call\n     * {@link ZonedDateTime#withLaterOffsetAtOverlap()} immediately after this method.\n     * <p>\n     * To create a zoned date-time at the same instant irrespective of the local time-line,\n     * use {@link #atZoneSameInstant(ZoneId)}.\n     * To use the offset as the zone ID, use {@link #toZonedDateTime()}.\n     *\n     * @param zone  the time-zone to use, not null\n     * @return the zoned date-time formed from this date and the earliest valid time for the zone, not null\n     */\n    public ZonedDateTime atZoneSimilarLocal(ZoneId zone) {\n        return ZonedDateTime.ofLocal(dateTime, zone, offset);\n    }\n    //-----------------------------------------------------------------------\n    /**\n     * Converts this date-time to an {@code OffsetTime}.\n     * <p>\n     * This returns an offset time with the same local time and offset.\n     *\n     * @return an OffsetTime representing the time and offset, not null\n     */\n    public OffsetTime toOffsetTime() {\n        return OffsetTime.of(dateTime.toLocalTime(), offset);\n    }\n    /**\n     * Converts this date-time to a {@code ZonedDateTime} using the offset as the zone ID.\n     * <p>\n     * This creates the simplest possible {@code ZonedDateTime} using the offset\n     * as the zone ID.\n     * <p>\n     * To control the time-zone used, see {@link #atZoneSameInstant(ZoneId)} and\n     * {@link #atZoneSimilarLocal(ZoneId)}.\n     *\n     * @return a zoned date-time representing the same local date-time and offset, not null\n     */\n    public ZonedDateTime toZonedDateTime() {\n        return ZonedDateTime.of(dateTime, offset);\n    }\n    /**\n     * Converts this date-time to an {@code Instant}.\n     * <p>\n     * This returns an {@code Instant} representing the same point on the\n     * time-line as this date-time.\n     *\n     * @return an {@code Instant} representing the same instant, not null\n     */\n    public Instant toInstant() {\n        return dateTime.toInstant(offset);\n    }\n    /**\n     * Converts this date-time to the number of seconds from the epoch of 1970-01-01T00:00:00Z.\n     * <p>\n     * This allows this date-time to be converted to a value of the\n     * {@link ChronoField#INSTANT_SECONDS epoch-seconds} field. This is primarily\n     * intended for low-level conversions rather than general application usage.\n     *\n     * @return the number of seconds from the epoch of 1970-01-01T00:00:00Z\n     */\n    public long toEpochSecond() {\n        return dateTime.toEpochSecond(offset);\n    }\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this date-time to another date-time.\n     * <p>\n     * The comparison is based on the instant then on the local date-time.\n     * It is \"consistent with equals\", as defined by {@link Comparable}.\n     * <p>\n     * For example, the following is the comparator order:\n     * <ol>\n     * <li>{@code 2008-12-03T10:30+01:00}</li>\n     * <li>{@code 2008-12-03T11:00+01:00}</li>\n     * <li>{@code 2008-12-03T12:00+02:00}</li>\n     * <li>{@code 2008-12-03T11:30+01:00}</li>\n     * <li>{@code 2008-12-03T12:00+01:00}</li>\n     * <li>{@code 2008-12-03T12:30+01:00}</li>\n     * </ol>\n     * Values #2 and #3 represent the same instant on the time-line.\n     * When two values represent the same instant, the local date-time is compared\n     * to distinguish them. This step is needed to make the ordering\n     * consistent with {@code equals()}.\n     *\n     * @param other  the other date-time to compare to, not null\n     * @return the comparator value, negative if less, positive if greater\n     */\n<fim_suffix>    @Override\n    public int compareTo(OffsetDateTime other) {\n        int cmp = compareInstant(this, other);\n        if (cmp == 0) {\n            cmp = toLocalDateTime().compareTo(other.toLocalDateTime());\n        }\n        return cmp;\n    }<fim_middle>// function below has no smell\n"}