{"text": "<fim_prefix>      final int maxPrecision =\n          builder.getTypeFactory().getTypeSystem().getMaxNumericPrecision();\n      assert scale >= 0 && scale <= maxPrecision;\n      if (scale == 0) {\n        return value;\n      }\n      if (scale == maxPrecision) {\n        long half = BigInteger.TEN.pow(scale - 1).longValue() * 5;\n        return makeCase(\n            builder.makeCall(\n                SqlStdOperatorTable.GREATER_THAN_OR_EQUAL,\n                value,\n                makeExactLiteral(half)),\n            makeExactLiteral(1),\n            builder.makeCall(\n                SqlStdOperatorTable.LESS_THAN_OR_EQUAL,\n                value,\n                makeExactLiteral(-half)),\n            makeExactLiteral(-1),\n            makeExactLiteral(0));\n      }\n      RexNode roundFactor = makeRoundFactor(scale);\n      RexNode roundValue =\n          makeCase(\n              builder.makeCall(\n                  SqlStdOperatorTable.GREATER_THAN,\n                  value,\n                  makeExactLiteral(0)),\n              makePlus(value, roundFactor),\n              makeMinus(value, roundFactor));\n      return makeDivide(\n          roundValue,\n          makeScaleFactor(scale));\n    }\n    /**\n     * Scales down a decimal value and returns the scaled value as a an\n     * double precision approximate value. Scaling is implemented with\n     * double precision arithmetic.\n     *\n     * @param value the integer representation of a decimal\n     * @param scale a value from zero to max precision\n     * @return value/10^scale as a double precision value\n     */\n    protected RexNode scaleDownDouble(RexNode value, int scale) {\n      assert scale >= 0;\n      assert scale\n          <= builder.getTypeFactory().getTypeSystem().getMaxNumericPrecision();\n      RexNode cast = ensureType(real8, value);\n      if (scale == 0) {\n        return cast;\n      }\n      return makeDivide(\n          cast,\n          makeApproxScaleFactor(scale));\n    }\n    /**\n     * Ensures a value is of a required scale. If it is not, then the value\n     * is multiplied by a scale factor. Scaling up an exact value is limited\n     * to max precision - 1, because we cannot represent the result of\n     * larger scales internally. Scaling up a floating point value is more\n     * flexible since the value may be very small despite having a scale of\n     * zero and the scaling may still produce a reasonable result\n     *\n     * @param value    integer representation of decimal, or a floating point\n     *                 number\n     * @param scale    current scale, 0 for floating point numbers\n     * @param required required scale, must be at least the current scale;\n     *                 the scale difference may not be greater than max\n     *                 precision - 1 for exact numerics\n     * @return value * 10^scale, returned as an exact or approximate value\n     * corresponding to the input value\n     */\n    protected RexNode ensureScale(RexNode value, int scale, int required) {\n      final RelDataTypeSystem typeSystem =\n          builder.getTypeFactory().getTypeSystem();\n      final int maxPrecision = typeSystem.getMaxNumericPrecision();\n      assert scale <= maxPrecision && required <= maxPrecision;\n      assert required >= scale;\n      if (scale == required) {\n        return value;\n      }\n      int scaleDiff = required - scale;\n      if (SqlTypeUtil.isApproximateNumeric(value.getType())) {\n        return makeMultiply(\n            value,\n            makeApproxScaleFactor(scaleDiff));\n      }\n      // TODO: make a validator exception for this\n      if (scaleDiff >= maxPrecision) {\n        throw Util.needToImplement(\"Source type with scale \" + scale\n            + \" cannot be converted to target type with scale \"\n            + required + \" because the smallest value of the \"\n            + \"source type is too large to be encoded by the \"\n            + \"target type\");\n      }\n      return scaleUp(value, scaleDiff);\n    }\n    /**\n     * Retrieves a decimal node's integer representation\n     *\n     * @param decimalNode the decimal value as an opaque type\n     * @return an integer representation of the decimal value\n     */\n    protected RexNode decodeValue(RexNode decimalNode) {\n      assert SqlTypeUtil.isDecimal(decimalNode.getType());\n      return builder.decodeIntervalOrDecimal(decimalNode);\n    }\n    /**\n     * Retrieves the primitive value of a numeric node. If the node is a\n     * decimal, then it must first be decoded. Otherwise the original node\n     * may be returned.\n     *\n     * @param node a numeric node, possibly a decimal\n     * @return the primitive value of the numeric node\n     */\n    protected RexNode accessValue(RexNode node) {\n      assert SqlTypeUtil.isNumeric(node.getType());\n      if (SqlTypeUtil.isDecimal(node.getType())) {\n        return decodeValue(node);\n      }\n      return node;\n    }\n    /**\n     * Casts a decimal's integer representation to a decimal node. If the\n     * expression is not the expected integer type, then it is casted first.\n     *\n     * <p>This method does not request an overflow check.\n     *\n     * @param value       integer representation of decimal\n     * @param decimalType type integer will be reinterpreted as\n     * @return the integer representation reinterpreted as a decimal type\n     */\n    protected RexNode encodeValue(RexNode value, RelDataType decimalType) {\n      return encodeValue(value, decimalType, false);\n    }\n    /**\n     * Casts a decimal's integer representation to a decimal node. If the\n     * expression is not the expected integer type, then it is casted first.\n     *\n     * <p>An overflow check may be requested to ensure the internal value\n     * does not exceed the maximum value of the decimal type.\n     *\n     * @param value         integer representation of decimal\n     * @param decimalType   type integer will be reinterpreted as\n     * @param checkOverflow indicates whether an overflow check is required\n     *                      when reinterpreting this particular value as the\n     *                      decimal type. A check usually not required for\n     *                      arithmetic, but is often required for rounding and\n     *                      explicit casts.\n     * @return the integer reinterpreted as an opaque decimal type\n     */\n    protected RexNode encodeValue(\n        RexNode value,\n        RelDataType decimalType,\n        boolean checkOverflow) {\n      return builder.encodeIntervalOrDecimal(\n          value, decimalType, checkOverflow);\n    }\n    /**\n     * Ensures expression is interpreted as a specified type. The returned\n     * expression may be wrapped with a cast.\n     *\n     * <p>This method corrects the nullability of the specified type to\n     * match the nullability of the expression.\n     *\n     * @param type desired type\n     * @param node expression\n     * @return a casted expression or the original expression\n     */\n    protected RexNode ensureType(RelDataType type, RexNode node) {\n      return ensureType(type, node, true);\n    }\n    /**\n     * Ensures expression is interpreted as a specified type. The returned\n     * expression may be wrapped with a cast.\n     *\n     * @param type             desired type\n     * @param node             expression\n     * @param matchNullability whether to correct nullability of specified\n     *                         type to match the expression; this usually should\n     *                         be true, except for explicit casts which can\n     *                         override default nullability\n     * @return a casted expression or the original expression\n     */\n    protected RexNode ensureType(\n        RelDataType type,\n        RexNode node,\n        boolean matchNullability) {\n      return builder.ensureType(type, node, matchNullability);\n    }\n    protected RexNode makeCase(\n        RexNode condition,\n        RexNode thenClause,\n        RexNode elseClause) {\n      return builder.makeCall(\n          SqlStdOperatorTable.CASE,\n          condition,\n          thenClause,\n          elseClause);\n    }\n    protected RexNode makeCase(\n        RexNode whenA,\n        RexNode thenA,\n        RexNode whenB,\n        RexNode thenB,\n        RexNode elseClause) {\n      return builder.makeCall(\n          SqlStdOperatorTable.CASE,\n          whenA,\n          thenA,\n          whenB,\n          thenB,\n          elseClause);\n    }\n    protected RexNode makePlus(\n        RexNode a,\n        RexNode b) {\n      return builder.makeCall(\n          SqlStdOperatorTable.PLUS,\n          a,\n          b);\n    }\n    protected RexNode makeMinus(\n        RexNode a,\n        RexNode b) {\n      return builder.makeCall(\n          SqlStdOperatorTable.MINUS,\n          a,\n          b);\n    }\n    protected RexNode makeDivide(\n        RexNode a,\n        RexNode b) {\n      return builder.makeCall(\n          SqlStdOperatorTable.DIVIDE_INTEGER,\n          a,\n          b);\n    }\n<fim_suffix>    protected RexNode makeMultiply(\n        RexNode a,\n        RexNode b) {\n      return builder.makeCall(\n          SqlStdOperatorTable.MULTIPLY,\n          a,\n          b);\n    }<fim_middle>// function below has no smell\n"}