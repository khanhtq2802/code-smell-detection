{"text": "<fim_prefix>     * specified {@code maxNumElements} value. Does not modify this combiner.\n     *\n     * <p>See {@link #create(int, Comparator, long, double)} for more information about the meaning\n     * of {@code maxNumElements}.\n     */\n    public ApproximateQuantilesCombineFn<T, ComparatorT> withMaxInputSize(long maxNumElements) {\n      return create(numQuantiles, compareFn, maxNumElements, maxNumElements);\n    }\n    /**\n     * Creates an approximate quantiles combiner with the given {@code compareFn} and desired number\n     * of quantiles. A total of {@code numQuantiles} elements will appear in the output list,\n     * including the minimum and maximum.\n     *\n     * <p>The {@code Comparator} must be {@code Serializable}.\n     *\n     * <p>The default error bound is {@code epsilon}, which holds as long as the number of elements\n     * is less than {@code maxNumElements}. Specifically, if one considers the input as a sorted\n     * list x_1, ..., x_N, then the distance between the each exact quantile x_c and its\n     * approximation x_c' is bounded by {@code |c - c'| < epsilon * N}. Note that these errors are\n     * worst-case scenarios; in practice the accuracy tends to be much better.\n     */\n    public static <T, ComparatorT extends Comparator<T> & Serializable>\n        ApproximateQuantilesCombineFn<T, ComparatorT> create(\n            int numQuantiles, ComparatorT compareFn, long maxNumElements, double epsilon) {\n      // Compute optimal b and k.\n      int b = 2;\n      while ((b - 2) * (1 << (b - 2)) < epsilon * maxNumElements) {\n        b++;\n      }\n      b--;\n      int k = Math.max(2, (int) Math.ceil(maxNumElements / (float) (1 << (b - 1))));\n      return new ApproximateQuantilesCombineFn<>(numQuantiles, compareFn, k, b, maxNumElements);\n    }\n    @Override\n    public QuantileState<T, ComparatorT> createAccumulator() {\n      return QuantileState.empty(compareFn, numQuantiles, numBuffers, bufferSize);\n    }\n    @Override\n    public Coder<QuantileState<T, ComparatorT>> getAccumulatorCoder(\n        CoderRegistry registry, Coder<T> elementCoder) {\n      return new QuantileStateCoder<>(compareFn, elementCoder);\n    }\n    @Override\n    public void populateDisplayData(DisplayData.Builder builder) {\n      super.populateDisplayData(builder);\n      builder\n          .add(DisplayData.item(\"numQuantiles\", numQuantiles).withLabel(\"Quantile Count\"))\n          .add(DisplayData.item(\"comparer\", compareFn.getClass()).withLabel(\"Record Comparer\"));\n    }\n    int getNumBuffers() {\n      return numBuffers;\n    }\n    int getBufferSize() {\n      return bufferSize;\n    }\n  }\n  /** Compact summarization of a collection on which quantiles can be estimated. */\n  static class QuantileState<T, ComparatorT extends Comparator<T> & Serializable>\n      implements Accumulator<T, QuantileState<T, ComparatorT>, List<T>> {\n    private ComparatorT compareFn;\n    private int numQuantiles;\n    private int numBuffers;\n    private int bufferSize;\n    @Nullable private T min;\n    @Nullable private T max;\n    /** The set of buffers, ordered by level from smallest to largest. */\n    private PriorityQueue<QuantileBuffer<T>> buffers;\n    /**\n     * The algorithm requires that the manipulated buffers always be filled to capacity to perform\n     * the collapse operation. This operation can be extended to buffers of varying sizes by\n     * introducing the notion of fractional weights, but it's easier to simply combine the\n     * remainders from all shards into new, full buffers and then take them into account when\n     * computing the final output.\n     */\n    private List<T> unbufferedElements = Lists.newArrayList();\n    private QuantileState(\n        ComparatorT compareFn,\n        int numQuantiles,\n        @Nullable T min,\n        @Nullable T max,\n        int numBuffers,\n        int bufferSize,\n        Collection<T> unbufferedElements,\n        Collection<QuantileBuffer<T>> buffers) {\n      this.compareFn = compareFn;\n      this.numQuantiles = numQuantiles;\n      this.numBuffers = numBuffers;\n      this.bufferSize = bufferSize;\n      this.buffers =\n          new PriorityQueue<>(numBuffers + 1, (q1, q2) -> Integer.compare(q1.level, q2.level));\n      this.min = min;\n      this.max = max;\n      this.unbufferedElements.addAll(unbufferedElements);\n      this.buffers.addAll(buffers);\n    }\n    public static <T, ComparatorT extends Comparator<T> & Serializable>\n        QuantileState<T, ComparatorT> empty(\n            ComparatorT compareFn, int numQuantiles, int numBuffers, int bufferSize) {\n      return new QuantileState<>(\n          compareFn,\n          numQuantiles,\n          null, /* min */\n          null, /* max */\n          numBuffers,\n          bufferSize,\n          Collections.emptyList(),\n          Collections.emptyList());\n    }\n    public static <T, ComparatorT extends Comparator<T> & Serializable>\n        QuantileState<T, ComparatorT> singleton(\n            ComparatorT compareFn, int numQuantiles, T elem, int numBuffers, int bufferSize) {\n      return new QuantileState<>(\n          compareFn,\n          numQuantiles,\n          elem, /* min */\n          elem, /* max */\n          numBuffers,\n          bufferSize,\n          Collections.singletonList(elem),\n          Collections.emptyList());\n    }\n    /** Add a new element to the collection being summarized by this state. */\n    @Override\n    public void addInput(T elem) {\n      if (isEmpty()) {\n        min = max = elem;\n      } else if (compareFn.compare(elem, min) < 0) {\n        min = elem;\n      } else if (compareFn.compare(elem, max) > 0) {\n        max = elem;\n      }\n      addUnbuffered(elem);\n    }\n    /** Add a new buffer to the unbuffered list, creating a new buffer and collapsing if needed. */\n    private void addUnbuffered(T elem) {\n      unbufferedElements.add(elem);\n      if (unbufferedElements.size() == bufferSize) {\n        unbufferedElements.sort(compareFn);\n        buffers.add(new QuantileBuffer<>(unbufferedElements));\n        unbufferedElements = Lists.newArrayListWithCapacity(bufferSize);\n        collapseIfNeeded();\n      }\n    }\n    /**\n     * Updates this as if adding all elements seen by other.\n     *\n     * <p>Note that this ignores the {@code Comparator} of the other {@link QuantileState}. In\n     * practice, they should generally be equal, but this method tolerates a mismatch.\n     */\n    @Override\n    public void mergeAccumulator(QuantileState<T, ComparatorT> other) {\n      if (other.isEmpty()) {\n        return;\n      }\n      if (min == null || compareFn.compare(other.min, min) < 0) {\n        min = other.min;\n      }\n      if (max == null || compareFn.compare(other.max, max) > 0) {\n        max = other.max;\n      }\n      for (T elem : other.unbufferedElements) {\n        addUnbuffered(elem);\n      }\n      buffers.addAll(other.buffers);\n      collapseIfNeeded();\n    }\n    public boolean isEmpty() {\n      return unbufferedElements.isEmpty() && buffers.isEmpty();\n    }\n    private void collapseIfNeeded() {\n      while (buffers.size() > numBuffers) {\n        List<QuantileBuffer<T>> toCollapse = Lists.newArrayList();\n        toCollapse.add(buffers.poll());\n        toCollapse.add(buffers.poll());\n        int minLevel = toCollapse.get(1).level;\n        while (!buffers.isEmpty() && buffers.peek().level == minLevel) {\n          toCollapse.add(buffers.poll());\n        }\n        buffers.add(collapse(toCollapse));\n      }\n    }\n<fim_suffix>    private QuantileBuffer<T> collapse(Iterable<QuantileBuffer<T>> buffers) {\n      int newLevel = 0;\n      long newWeight = 0;\n      for (QuantileBuffer<T> buffer : buffers) {\n        // As presented in the paper, there should always be at least two\n        // buffers of the same (minimal) level to collapse, but it is possible\n        // to violate this condition when combining buffers from independently\n        // computed shards.  If they differ we take the max.\n        newLevel = Math.max(newLevel, buffer.level + 1);\n        newWeight += buffer.weight;\n      }\n      List<T> newElements = interpolate(buffers, bufferSize, newWeight, offset(newWeight));\n      return new QuantileBuffer<>(newLevel, newWeight, newElements);\n    }<fim_middle>// function below has no smell\n"}