{"text": "<fim_prefix> *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.jackrabbit.jcr2spi.nodetype;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport javax.jcr.nodetype.ConstraintViolationException;\nimport javax.jcr.nodetype.NoSuchNodeTypeException;\nimport org.apache.jackrabbit.spi.Name;\nimport org.apache.jackrabbit.spi.QItemDefinition;\nimport org.apache.jackrabbit.spi.QNodeDefinition;\nimport org.apache.jackrabbit.spi.QNodeTypeDefinition;\nimport org.apache.jackrabbit.spi.QPropertyDefinition;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n/**\n * An <code>EffectiveNodeType</code> represents one or more\n * <code>NodeType</code>s as one 'effective' node type where inheritance\n * is resolved.\n * <p>\n * Instances of <code>EffectiveNodeType</code> are immutable.\n */\npublic class EffectiveNodeTypeImpl implements Cloneable, EffectiveNodeType {\n    private static Logger log = LoggerFactory.getLogger(EffectiveNodeTypeImpl.class);\n    // list of explicitly aggregated {i.e. merged) node types\n    private final TreeSet<Name> mergedNodeTypes = new TreeSet<Name>();\n    // list of implicitly aggregated {through inheritance) node types\n    private final TreeSet<Name> inheritedNodeTypes = new TreeSet<Name>();\n    // list of all either explicitly (through aggregation) or implicitly\n    // (through inheritance) included node types.\n    private final TreeSet<Name> allNodeTypes = new TreeSet<Name>();\n    // map of named item definitions (maps name to list of definitions)\n    private final Map<Name, List<QItemDefinition>> namedItemDefs = new HashMap<Name, List<QItemDefinition>>();\n    // list of unnamed item definitions (i.e. residual definitions)\n    private final List<QItemDefinition> unnamedItemDefs = new ArrayList<QItemDefinition>();\n    // (optional) set of additional mixins supported on node type\n    private Set<Name> supportedMixins;\n    /**\n     * constructor.\n     */\n    EffectiveNodeTypeImpl(TreeSet<Name> mergedNodeTypes, TreeSet<Name> inheritedNodeTypes,\n                          TreeSet<Name> allNodeTypes, Map<Name, List<QItemDefinition>> namedItemDefs,\n                          List<QItemDefinition> unnamedItemDefs, Set<Name> supportedMixins) {\n        this.mergedNodeTypes.addAll(mergedNodeTypes);\n        this.inheritedNodeTypes.addAll(inheritedNodeTypes);\n        this.allNodeTypes.addAll(allNodeTypes);\n        for (Map.Entry<Name, List<QItemDefinition>> entry : namedItemDefs.entrySet()) {\n            this.namedItemDefs.put(entry.getKey(), new ArrayList<QItemDefinition>(entry.getValue()));\n        }\n        this.unnamedItemDefs.addAll(unnamedItemDefs);\n        if (supportedMixins != null) {\n            this.supportedMixins = new HashSet<Name>();\n            this.supportedMixins.addAll(supportedMixins);\n        }\n    }\n    //--------------------------------------------------< EffectiveNodeType >---\n    /**\n     * @see EffectiveNodeType#getInheritedNodeTypes()\n     */\n    public Name[] getInheritedNodeTypes() {\n        return inheritedNodeTypes.toArray(new Name[inheritedNodeTypes.size()]);\n    }\n    /**\n     * @see EffectiveNodeType#getAllNodeTypes()\n     */\n    public Name[] getAllNodeTypes() {\n        return allNodeTypes.toArray(new Name[allNodeTypes.size()]);\n    }\n    /**\n     * @see EffectiveNodeType#getMergedNodeTypes()\n     */\n    public Name[] getMergedNodeTypes() {\n        return mergedNodeTypes.toArray(new Name[mergedNodeTypes.size()]);\n    }\n    /**\n     * @see EffectiveNodeType#getAllQNodeDefinitions()\n     */\n    public QNodeDefinition[] getAllQNodeDefinitions() {\n        if (namedItemDefs.size() == 0 && unnamedItemDefs.size() == 0) {\n            return QNodeDefinition.EMPTY_ARRAY;\n        }\n        ArrayList<QItemDefinition> defs = new ArrayList<QItemDefinition>(namedItemDefs.size() + unnamedItemDefs.size());\n        for (QItemDefinition qDef : unnamedItemDefs) {\n            if (qDef.definesNode()) {\n                defs.add(qDef);\n            }\n        }\n        for (List<QItemDefinition> list : namedItemDefs.values()) {\n            for (QItemDefinition qDef : list) {\n                if (qDef.definesNode()) {\n                    defs.add(qDef);\n                }\n            }\n        }\n        if (defs.size() == 0) {\n            return QNodeDefinition.EMPTY_ARRAY;\n        }\n        return defs.toArray(new QNodeDefinition[defs.size()]);\n    }\n    /**\n     * @see EffectiveNodeType#getAllQPropertyDefinitions()\n     */\n    public QPropertyDefinition[] getAllQPropertyDefinitions() {\n        if (namedItemDefs.size() == 0 && unnamedItemDefs.size() == 0) {\n            return QPropertyDefinition.EMPTY_ARRAY;\n        }\n        ArrayList<QItemDefinition> defs = new ArrayList<QItemDefinition>(namedItemDefs.size() + unnamedItemDefs.size());\n        for (QItemDefinition qDef : unnamedItemDefs) {\n            if (!qDef.definesNode()) {\n                defs.add(qDef);\n            }\n        }\n        for (List<QItemDefinition> list : namedItemDefs.values()) {\n            for (QItemDefinition qDef : list) {\n                if (!qDef.definesNode()) {\n                    defs.add(qDef);\n                }\n            }\n        }\n        if (defs.size() == 0) {\n            return QPropertyDefinition.EMPTY_ARRAY;\n        }\n        return defs.toArray(new QPropertyDefinition[defs.size()]);\n    }\n    /**\n     * @see EffectiveNodeType#getAutoCreateQNodeDefinitions()\n     */\n    public QNodeDefinition[] getAutoCreateQNodeDefinitions() {\n        // since auto-create items must have a name,\n        // we're only searching the named item definitions\n        if (namedItemDefs.size() == 0) {\n            return QNodeDefinition.EMPTY_ARRAY;\n        }\n        ArrayList<QItemDefinition> defs = new ArrayList<QItemDefinition>(namedItemDefs.size());\n        for (List<QItemDefinition> list : namedItemDefs.values()) {\n            for (QItemDefinition qDef : list) {\n                if (qDef.definesNode() && qDef.isAutoCreated()) {\n                    defs.add(qDef);\n                }\n            }\n        }\n        if (defs.size() == 0) {\n            return QNodeDefinition.EMPTY_ARRAY;\n        }\n        return defs.toArray(new QNodeDefinition[defs.size()]);\n    }\n    /**\n     * @see EffectiveNodeType#getAutoCreateQPropertyDefinitions()\n     */\n    public QPropertyDefinition[] getAutoCreateQPropertyDefinitions() {\n        // since auto-create items must have a name,\n        // we're only searching the named item definitions\n        if (namedItemDefs.size() == 0) {\n            return QPropertyDefinition.EMPTY_ARRAY;\n        }\n        ArrayList<QItemDefinition> defs = new ArrayList<QItemDefinition>(namedItemDefs.size());\n        for (List<QItemDefinition> list : namedItemDefs.values()) {\n            for (QItemDefinition qDef : list) {\n                if (!qDef.definesNode() && qDef.isAutoCreated()) {\n                    defs.add(qDef);\n                }\n            }\n        }\n        if (defs.size() == 0) {\n            return QPropertyDefinition.EMPTY_ARRAY;\n        }\n        return defs.toArray(new QPropertyDefinition[defs.size()]);\n    }\n    /**\n     * @see EffectiveNodeType#getMandatoryQPropertyDefinitions()\n     */\n<fim_suffix>    public QPropertyDefinition[] getMandatoryQPropertyDefinitions() {\n        // since mandatory items must have a name,\n        // we're only searching the named item definitions\n        if (namedItemDefs.size() == 0) {\n            return QPropertyDefinition.EMPTY_ARRAY;\n        }\n        ArrayList<QItemDefinition> defs = new ArrayList<QItemDefinition>(namedItemDefs.size());\n        for (List<QItemDefinition> list : namedItemDefs.values()) {\n            for (QItemDefinition qDef : list) {\n                if (!qDef.definesNode() && qDef.isMandatory()) {\n                    defs.add(qDef);\n                }\n            }\n        }\n        if (defs.size() == 0) {\n            return QPropertyDefinition.EMPTY_ARRAY;\n        }\n        return defs.toArray(new QPropertyDefinition[defs.size()]);\n    }<fim_middle>// function below has no smell\n"}