{"text": "<fim_prefix>package org.apache.archiva.common;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.util.function.Function;\n\n/**\n * This is a class that can be used for the Try monad\n *\n * The Try monad is able to collect exceptions during processing\n * of a stream.\n *\n *\n *\n */\npublic abstract class Try<V> {\n\n    private Try() {\n\n    }\n\n    public abstract Boolean isSuccess();\n\n    public abstract Boolean isFailure();\n\n    public abstract void throwException();\n\n    /**\n     * Returns the value if this is a success instance. Otherwise throws\n     * a runtime exception with the stored throwable as cause.\n     *\n     * @return The value\n     */\n    public abstract V get();\n\n    /**\n     * Returns the throwable that is stored in the failure.\n     *\n     * @return The Throwable or null.\n     */\n    public abstract Throwable getError();\n\n\n    /**\n     * A mapping method for mapping the current instance to a new type.\n     *\n     * @param fn\n     * @param <U>\n     * @return\n     */\n    public <U> Try<U> map(Function<? super V, U> fn) {\n        try {\n            return Try.success(fn.apply(get()));\n        } catch (Throwable e) {\n            return Try.failure(e);\n        }\n    }\n\n    /**\n     * This is the bind method.\n     * If this instance is success the function will be applied. If any error occurs\n     * a failure instance will be returned.\n     * If this instance is failure a new failure will be returned.\n     *\n     * @param fn\n     * @param <U>\n     * @return\n     */\n    public <U> Try<U> flatMap(Function<? super V, Try<U>> fn) {\n        try {\n            return fn.apply(get());\n        } catch (Throwable t) {\n            return Try.failure(t);\n        }\n    }\n\n    public static <V> Try<V> failure(String message) {\n\n        return new Failure<>(message);\n\n    }\n\n    public static <V> Try<V> failure(String message, Throwable e) {\n\n        return new Failure<>(message, e);\n\n    }\n\n    /**\n     * If you need type coercion, you should call this method as\n     *  Try.&lt;YOUR_TYPE&gt;failure(e)\n     *\n     *\n     *\n     * @param e The exception that is thrown\n     * @param <V> The generic type this monad keeps\n     * @return A new Try instance that represents a failure.\n     */\n    public static <V> Try<V> failure(Throwable e) {\n\n        return new Failure<>(e);\n\n    }\n\n\n    /**\n     * Returns a instance for the success case.\n     *\n     * @param value The value that should be stored.\n     * @param <V> The return type\n     * @return A new Try instance with the given value\n     */\n    public static <V> Try<V> success(V value) {\n\n        return new Success<>(value);\n\n    }\n\n    private static class Failure<V> extends Try<V> {\n\n        private Throwable exception;\n\n        public Failure(String message) {\n\n            super();\n\n            this.exception = new IllegalStateException(message);\n\n        }\n\n        public Failure(String message, Throwable e) {\n\n            super();\n\n            this.exception = new IllegalStateException(message, e);\n\n        }\n\n        public Failure(Throwable e) {\n\n            super();\n\n            this.exception = new IllegalStateException(e);\n\n        }\n\n        @Override\n\n        public Boolean isSuccess() {\n\n            return false;\n\n        }\n\n        @Override\n\n        public Boolean isFailure() {\n\n            return true;\n\n        }\n\n        @Override\n\n        public void throwException() {\n\n            throw new RuntimeException(this.exception);\n\n        }\n\n        @Override\n        public V get() {\n            throw new RuntimeException(this.exception);\n        }\n\n        @Override\n        public Throwable getError() {\n            return exception;\n        }\n    }\n\n<fim_suffix>    private static class Success<V> extends Try<V> {\n\n        private V value;\n\n        public Success(V value) {\n\n            super();\n\n            this.value = value;\n\n        }\n\n        @Override\n\n        public Boolean isSuccess() {\n\n            return true;\n\n        }\n\n        @Override\n\n        public Boolean isFailure() {\n\n            return false;\n\n        }\n\n        @Override\n\n        public void throwException() {\n\n            //log.error(\"Method throwException() called on a Success instance\");\n\n        }\n\n        @Override\n        public V get() {\n            return value;\n        }\n\n        @Override\n        public Throwable getError() {\n            return null;\n        }\n    }\n\n    // various method such as map an flatMap\n\n\n    @Override\n    public String toString() {\n        return isSuccess() ? \"true: \"+get() : \"false: \"+ getError().getMessage();\n    }\n}<fim_middle>// class below is data class\n"}