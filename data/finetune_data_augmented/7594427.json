{"text": "<fim_prefix>package org.springframework.roo.felix;\n\nimport static org.apache.commons.io.IOUtils.LINE_SEPARATOR;\n\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.util.Enumeration;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport org.apache.felix.scr.annotations.Component;\nimport org.apache.felix.scr.annotations.Reference;\nimport org.apache.felix.scr.annotations.ReferenceCardinality;\nimport org.apache.felix.scr.annotations.ReferencePolicy;\nimport org.apache.felix.scr.annotations.ReferenceStrategy;\nimport org.osgi.service.component.ComponentContext;\nimport org.osgi.service.log.LogEntry;\nimport org.osgi.service.log.LogListener;\nimport org.osgi.service.log.LogReaderService;\nimport org.osgi.service.log.LogService;\nimport org.springframework.roo.shell.Shell;\nimport org.springframework.roo.shell.osgi.AbstractFlashingObject;\nimport org.springframework.roo.support.logging.HandlerUtils;\n\n/**\n * Delegates OSGi log messages to the JDK logging infrastructure. This in turn\n * makes it compatible with Spring Roo's standard approach to log messages\n * appearing on the console.\n * <p>\n * For convenience all low-priority messages are output as flash messages. All\n * high priority messages are sent to the JDK logger.\n * \n * @author Ben Alex\n * @author Stefan Schmidt\n * @since 1.1\n */\n<fim_suffix>@Component\n@Reference(name = \"shell\", strategy = ReferenceStrategy.EVENT, policy = ReferencePolicy.DYNAMIC,\n    referenceInterface = Shell.class, cardinality = ReferenceCardinality.OPTIONAL_UNARY)\npublic class JdkDelegatingLogListener extends AbstractFlashingObject implements LogListener {\n\n  public static final String DO_NOT_LOG = \"#DO_NOT_LOG\";\n  private final static Logger LOGGER = HandlerUtils.getLogger(JdkDelegatingLogListener.class);\n\n  @Reference(policy = ReferencePolicy.DYNAMIC)\n  private volatile LogReaderService logReaderService;\n\n  public static String cleanThrowable(final Throwable throwable) {\n    final StringBuilder result = new StringBuilder();\n    result.append(LINE_SEPARATOR);\n    result.append(throwable.toString().replace(DO_NOT_LOG, \"\"));\n    result.append(LINE_SEPARATOR);\n    for (final StackTraceElement ste : throwable.getStackTrace()) {\n      result.append(ste);\n      result.append(LINE_SEPARATOR);\n    }\n    return result.toString();\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  protected void activate(final ComponentContext context) {\n    logReaderService.addLogListener(this);\n    final Enumeration<LogEntry> latestLogs = logReaderService.getLog();\n    if (latestLogs.hasMoreElements()) {\n      logNow(latestLogs.nextElement(), false);\n    }\n  }\n\n  private String buildMessage(final LogEntry entry) {\n    final StringBuilder sb = new StringBuilder();\n    sb.append(\"[\").append(entry.getBundle()).append(\"] \").append(entry.getMessage());\n    return sb.toString();\n  }\n\n  private boolean containsDoNotLogTag(final Throwable throwable) {\n    if (throwable == null) {\n      return false;\n    }\n    if (throwable.getMessage().contains(DO_NOT_LOG)) {\n      return true;\n    }\n    final StringWriter sw = new StringWriter();\n    throwable.printStackTrace(new PrintWriter(sw));\n    return sw.toString().contains(DO_NOT_LOG);\n  }\n\n  protected void deactivate(final ComponentContext context) {\n    logReaderService.removeLogListener(this);\n  }\n\n  public void logged(final LogEntry entry) {\n    if (containsDoNotLogTag(entry.getException())) {\n      // Only log Felix stack trace in development mode, discard log\n      // otherwise\n      if (isDevelopmentMode()) {\n        logNow(entry, true);\n      }\n    } else {\n      logNow(entry, false);\n    }\n  }\n\n  private void logNow(final LogEntry entry, final boolean removeDoNotLogTag) {\n    final int osgiLevel = entry.getLevel();\n    Level jdkLevel = Level.FINEST;\n\n    // Convert the OSGi level into a JDK logger level\n    if (osgiLevel == LogService.LOG_DEBUG) {\n      jdkLevel = Level.FINE;\n    } else if (osgiLevel == LogService.LOG_INFO) {\n      jdkLevel = Level.INFO;\n    } else if (osgiLevel == LogService.LOG_WARNING) {\n      jdkLevel = Level.WARNING;\n    } else if (osgiLevel == LogService.LOG_ERROR) {\n      jdkLevel = Level.SEVERE;\n    }\n\n    if (jdkLevel.intValue() <= Level.INFO.intValue()) {\n      // Not very important message, so just flash it if possible and\n      // we're in development mode\n      if (isDevelopmentMode()) {\n        flash(jdkLevel, buildMessage(entry), MY_SLOT);\n        // Immediately clear it once the timeout has been reached\n        flash(jdkLevel, \"\", MY_SLOT);\n      }\n    } else {\n      // Important log message, so log it via JDK\n      if (removeDoNotLogTag) {\n        LOGGER.log(jdkLevel, buildMessage(entry) + cleanThrowable(entry.getException()));\n      } else {\n        LOGGER.log(jdkLevel, buildMessage(entry), entry.getException());\n      }\n    }\n  }\n}<fim_middle>// class below has no smell\n"}