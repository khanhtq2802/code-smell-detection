{"text": "<fim_prefix>        .filter(instant -> HoodieActiveTimeline.GREATER.test(instant.getTimestamp(), instantTime))\n        .collect(Collectors.toList());\n    // reverse the commits to descending order of commit time\n    Collections.reverse(instantsToRollback);\n    // Start a rollback instant for all commits to be rolled back\n    String startRollbackInstant = startInstant();\n    // Start the timer\n    final Timer.Context context = startContext();\n    ImmutableMap.Builder<String, List<HoodieRollbackStat>> instantsToStats =\n        ImmutableMap.builder();\n    instantsToRollback.stream().forEach(instant -> {\n      try {\n        switch (instant.getAction()) {\n          case HoodieTimeline.COMMIT_ACTION:\n          case HoodieTimeline.DELTA_COMMIT_ACTION:\n            List<HoodieRollbackStat> statsForInstant = doRollbackAndGetStats(instant.getTimestamp());\n            instantsToStats.put(instant.getTimestamp(), statsForInstant);\n            break;\n          case HoodieTimeline.COMPACTION_ACTION:\n            if (instant.isRequested()) {\n              // TODO : Get file status and create a rollback stat and file\n              // TODO : Delete the .aux files along with the instant file, okay for now since the archival process will\n              // delete these files when it does not see a corresponding instant file under .hoodie\n              deleteRequestedCompaction(instant.getTimestamp());\n              logger.info(\"Deleted pending scheduled compaction \" + instant.getTimestamp());\n            } else {\n              List<HoodieRollbackStat> statsForCompaction = doRollbackAndGetStats(instant.getTimestamp());\n              instantsToStats.put(instant.getTimestamp(), statsForCompaction);\n            }\n            break;\n          default:\n            throw new IllegalArgumentException(\"invalid action name \" + instant.getAction());\n        }\n      } catch (IOException io) {\n        throw new HoodieRollbackException(\"unable to rollback instant \" + instant, io);\n      }\n    });\n    try {\n      finishRestore(context, instantsToStats.build(),\n          instantsToRollback.stream().map(HoodieInstant::getTimestamp).collect(Collectors.toList()),\n          startRollbackInstant, instantTime);\n    } catch (IOException io) {\n      throw new HoodieRollbackException(\"unable to rollback instants \" + instantsToRollback, io);\n    }\n  }\n  private String startInstant() {\n    return HoodieActiveTimeline.COMMIT_FORMATTER.format(new Date());\n  }\n  private Timer.Context startContext() {\n    return metrics.getRollbackCtx();\n  }\n  private List<HoodieRollbackStat> doRollbackAndGetStats(final String commitToRollback) throws\n      IOException {\n    HoodieTable<T> table = HoodieTable.getHoodieTable(\n        new HoodieTableMetaClient(jsc.hadoopConfiguration(), config.getBasePath(), true), config, jsc);\n    HoodieTimeline inflightCommitTimeline = table.getInflightCommitTimeline();\n    HoodieTimeline commitTimeline = table.getCompletedCommitsTimeline();\n    // Check if any of the commits is a savepoint - do not allow rollback on those commits\n    List<String> savepoints = table.getCompletedSavepointTimeline().getInstants()\n        .map(HoodieInstant::getTimestamp).collect(Collectors.toList());\n    savepoints.stream().forEach(s -> {\n      if (s.contains(commitToRollback)) {\n        throw new HoodieRollbackException(\n            \"Could not rollback a savepointed commit. Delete savepoint first before rolling back\"\n                + s);\n      }\n    });\n    if (commitTimeline.empty() && inflightCommitTimeline.empty()) {\n      // nothing to rollback\n      logger.info(\"No commits to rollback \" + commitToRollback);\n    }\n    // Make sure only the last n commits are being rolled back\n    // If there is a commit in-between or after that is not rolled back, then abort\n    String lastCommit = commitToRollback;\n    if ((lastCommit != null) && !commitTimeline.empty() && !commitTimeline\n        .findInstantsAfter(lastCommit, Integer.MAX_VALUE).empty()) {\n      throw new HoodieRollbackException(\n          \"Found commits after time :\" + lastCommit + \", please rollback greater commits first\");\n    }\n    List<String> inflights = inflightCommitTimeline.getInstants().map(HoodieInstant::getTimestamp)\n        .collect(Collectors.toList());\n    if ((lastCommit != null) && !inflights.isEmpty() && (inflights.indexOf(lastCommit) != inflights.size() - 1)) {\n      throw new HoodieRollbackException(\"Found in-flight commits after time :\" + lastCommit\n          + \", please rollback greater commits first\");\n    }\n    List<HoodieRollbackStat> stats = table.rollback(jsc, commitToRollback, true);\n    logger.info(\"Deleted inflight commits \" + commitToRollback);\n    // cleanup index entries\n    if (!index.rollbackCommit(commitToRollback)) {\n      throw new HoodieRollbackException(\"Rollback index changes failed, for time :\" + commitToRollback);\n    }\n    logger.info(\"Index rolled back for commits \" + commitToRollback);\n    return stats;\n  }\n  private void finishRollback(final Timer.Context context, List<HoodieRollbackStat> rollbackStats,\n      List<String> commitsToRollback, final String startRollbackTime) throws IOException {\n    HoodieTable<T> table = HoodieTable.getHoodieTable(\n        new HoodieTableMetaClient(jsc.hadoopConfiguration(), config.getBasePath(), true), config, jsc);\n    Optional<Long> durationInMs = Optional.empty();\n    Long numFilesDeleted = rollbackStats.stream().mapToLong(stat -> stat.getSuccessDeleteFiles().size()).sum();\n    if (context != null) {\n      durationInMs = Optional.of(metrics.getDurationInMs(context.stop()));\n      metrics.updateRollbackMetrics(durationInMs.get(), numFilesDeleted);\n    }\n    HoodieRollbackMetadata rollbackMetadata = AvroUtils\n        .convertRollbackMetadata(startRollbackTime, durationInMs, commitsToRollback, rollbackStats);\n    table.getActiveTimeline().saveAsComplete(\n        new HoodieInstant(true, HoodieTimeline.ROLLBACK_ACTION, startRollbackTime),\n        AvroUtils.serializeRollbackMetadata(rollbackMetadata));\n    logger.info(\"Commits \" + commitsToRollback + \" rollback is complete\");\n    if (!table.getActiveTimeline().getCleanerTimeline().empty()) {\n      logger.info(\"Cleaning up older rollback meta files\");\n      // Cleanup of older cleaner meta files\n      // TODO - make the commit archival generic and archive rollback metadata\n      FSUtils.deleteOlderRollbackMetaFiles(fs, table.getMetaClient().getMetaPath(),\n          table.getActiveTimeline().getRollbackTimeline().getInstants());\n    }\n  }\n<fim_suffix>  private void finishRestore(final Timer.Context context, Map<String, List<HoodieRollbackStat>> commitToStats,\n      List<String> commitsToRollback, final String startRestoreTime, final String restoreToInstant) throws IOException {\n    HoodieTable<T> table = HoodieTable.getHoodieTable(\n        new HoodieTableMetaClient(jsc.hadoopConfiguration(), config.getBasePath(), true), config, jsc);\n    Optional<Long> durationInMs = Optional.empty();\n    Long numFilesDeleted = 0L;\n    for (Map.Entry<String, List<HoodieRollbackStat>> commitToStat : commitToStats.entrySet()) {\n      List<HoodieRollbackStat> stats = commitToStat.getValue();\n      numFilesDeleted = stats.stream().mapToLong(stat -> stat.getSuccessDeleteFiles().size())\n          .sum();\n    }\n    if (context != null) {\n      durationInMs = Optional.of(metrics.getDurationInMs(context.stop()));\n      metrics.updateRollbackMetrics(durationInMs.get(), numFilesDeleted);\n    }\n    HoodieRestoreMetadata restoreMetadata = AvroUtils\n        .convertRestoreMetadata(startRestoreTime, durationInMs, commitsToRollback, commitToStats);\n    table.getActiveTimeline().saveAsComplete(\n        new HoodieInstant(true, HoodieTimeline.RESTORE_ACTION, startRestoreTime),\n        AvroUtils.serializeRestoreMetadata(restoreMetadata));\n    logger.info(\"Commits \" + commitsToRollback + \" rollback is complete. Restored dataset to \" + restoreToInstant);\n    if (!table.getActiveTimeline().getCleanerTimeline().empty()) {\n      logger.info(\"Cleaning up older restore meta files\");\n      // Cleanup of older cleaner meta files\n      // TODO - make the commit archival generic and archive rollback metadata\n      FSUtils.deleteOlderRollbackMetaFiles(fs, table.getMetaClient().getMetaPath(),\n          table.getActiveTimeline().getRestoreTimeline().getInstants());\n    }\n  }<fim_middle>// function below is feature envy and long method\n"}