{"text": "<fim_prefix>  private boolean mergeIsDirect;\n  // flag for no scan during analyze ... compute statistics\n  protected boolean noscan;\n  // whether this is a mv rebuild rewritten expression\n  protected MaterializationRebuildMode mvRebuildMode = MaterializationRebuildMode.NONE;\n  protected String mvRebuildDbName; // Db name for materialization to rebuild\n  protected String mvRebuildName; // Name for materialization to rebuild\n  protected volatile boolean disableJoinMerge = false;\n  protected final boolean defaultJoinMerge;\n  /*\n   * Capture the CTE definitions in a Query.\n   */\n  final Map<String, CTEClause> aliasToCTEs;\n  /*\n   * Used to check recursive CTE invocations. Similar to viewsExpanded\n   */\n  ArrayList<String> ctesExpanded;\n  /*\n   * Whether root tasks after materialized CTE linkage have been resolved\n   */\n  boolean rootTasksResolved;\n  protected TableMask tableMask;\n  CreateTableDesc tableDesc;\n  protected AnalyzeRewriteContext analyzeRewrite;\n  private WriteEntity acidAnalyzeTable;\n  // A mapping from a tableName to a table object in metastore.\n  Map<String, Table> tabNameToTabObject;\n  // The tokens we should ignore when we are trying to do table masking.\n  private final Set<Integer> ignoredTokens = Sets.newHashSet(HiveParser.TOK_GROUPBY,\n      HiveParser.TOK_ORDERBY, HiveParser.TOK_WINDOWSPEC, HiveParser.TOK_CLUSTERBY,\n      HiveParser.TOK_DISTRIBUTEBY, HiveParser.TOK_SORTBY);\n  private String invalidResultCacheReason;\n  private String invalidAutomaticRewritingMaterializationReason;\n  private static final CommonToken SELECTDI_TOKEN =\n      new ImmutableCommonToken(HiveParser.TOK_SELECTDI, \"TOK_SELECTDI\");\n  private static final CommonToken SELEXPR_TOKEN =\n      new ImmutableCommonToken(HiveParser.TOK_SELEXPR, \"TOK_SELEXPR\");\n  private static final CommonToken TABLEORCOL_TOKEN =\n      new ImmutableCommonToken(HiveParser.TOK_TABLE_OR_COL, \"TOK_TABLE_OR_COL\");\n  private static final CommonToken DOT_TOKEN =\n      new ImmutableCommonToken(HiveParser.DOT, \".\");\n  static class Phase1Ctx {\n    String dest;\n    int nextNum;\n  }\n  public SemanticAnalyzer(QueryState queryState) throws SemanticException {\n    super(queryState);\n    opToPartPruner = new HashMap<TableScanOperator, ExprNodeDesc>();\n    opToPartList = new HashMap<TableScanOperator, PrunedPartitionList>();\n    opToSamplePruner = new HashMap<TableScanOperator, SampleDesc>();\n    nameToSplitSample = new HashMap<String, SplitSample>();\n    // Must be deterministic order maps - see HIVE-8707\n    topOps = new LinkedHashMap<String, TableScanOperator>();\n    loadTableWork = new ArrayList<LoadTableDesc>();\n    loadFileWork = new ArrayList<LoadFileDesc>();\n    columnStatsAutoGatherContexts = new ArrayList<ColumnStatsAutoGatherContext>();\n    opParseCtx = new LinkedHashMap<Operator<? extends OperatorDesc>, OpParseContext>();\n    joinContext = new HashMap<JoinOperator, QBJoinTree>();\n    smbMapJoinContext = new HashMap<SMBMapJoinOperator, QBJoinTree>();\n    // Must be deterministic order map for consistent q-test output across Java versions\n    topToTable = new LinkedHashMap<TableScanOperator, Table>();\n    reduceSinkOperatorsAddedByEnforceBucketingSorting = new ArrayList<ReduceSinkOperator>();\n    topToTableProps = new HashMap<TableScanOperator, Map<String, String>>();\n    destTableId = 1;\n    uCtx = null;\n    listMapJoinOpsNoReducer = new ArrayList<AbstractMapJoinOperator<? extends MapJoinDesc>>();\n    groupOpToInputTables = new HashMap<GroupByOperator, Set<String>>();\n    prunedPartitions = new HashMap<String, PrunedPartitionList>();\n    unparseTranslator = new UnparseTranslator(conf);\n    autogenColAliasPrfxLbl = HiveConf.getVar(conf,\n        HiveConf.ConfVars.HIVE_AUTOGEN_COLUMNALIAS_PREFIX_LABEL);\n    autogenColAliasPrfxIncludeFuncName = HiveConf.getBoolVar(conf,\n        HiveConf.ConfVars.HIVE_AUTOGEN_COLUMNALIAS_PREFIX_INCLUDEFUNCNAME);\n    queryProperties = new QueryProperties();\n    opToPartToSkewedPruner = new HashMap<TableScanOperator, Map<String, ExprNodeDesc>>();\n    aliasToCTEs = new HashMap<String, CTEClause>();\n    globalLimitCtx = new GlobalLimitCtx();\n    viewAliasToInput = new HashMap<String, ReadEntity>();\n    mergeIsDirect = true;\n    noscan = false;\n    tabNameToTabObject = new HashMap<>();\n    defaultJoinMerge = false == HiveConf.getBoolVar(conf, HiveConf.ConfVars.HIVE_MERGE_NWAY_JOINS);\n    disableJoinMerge = defaultJoinMerge;\n  }\n  @Override\n  protected void reset(boolean clearCache) {\n    super.reset(true);\n    if(clearCache) {\n      prunedPartitions.clear();\n      if (ctx != null) {\n        ctx.getOpContext().getColStatsCache().clear();\n      }\n      //When init(true) combine with genResolvedParseTree, it will generate Resolved Parse tree from syntax tree\n      //ReadEntity created under these conditions should be all relevant to the syntax tree even the ones without parents\n      //set mergeIsDirect to true here.\n      mergeIsDirect = true;\n    } else {\n      mergeIsDirect = false;\n    }\n    tabNameToTabObject.clear();\n    loadTableWork.clear();\n    loadFileWork.clear();\n    columnStatsAutoGatherContexts.clear();\n    topOps.clear();\n    destTableId = 1;\n    idToTableNameMap.clear();\n    qb = null;\n    ast = null;\n    uCtx = null;\n    joinContext.clear();\n    smbMapJoinContext.clear();\n    opParseCtx.clear();\n    groupOpToInputTables.clear();\n    disableJoinMerge = defaultJoinMerge;\n    aliasToCTEs.clear();\n    topToTable.clear();\n    opToPartPruner.clear();\n    opToPartList.clear();\n    opToPartToSkewedPruner.clear();\n    opToSamplePruner.clear();\n    nameToSplitSample.clear();\n    resultSchema = null;\n    createVwDesc = null;\n    materializedViewUpdateDesc = null;\n    viewsExpanded = null;\n    viewSelect = null;\n    ctesExpanded = null;\n    globalLimitCtx.disableOpt();\n    viewAliasToInput.clear();\n    reduceSinkOperatorsAddedByEnforceBucketingSorting.clear();\n    topToTableProps.clear();\n    listMapJoinOpsNoReducer.clear();\n    unparseTranslator.clear();\n    queryProperties.clear();\n    outputs.clear();\n  }\n<fim_suffix>  public void initParseCtx(ParseContext pctx) {\n    opToPartPruner = pctx.getOpToPartPruner();\n    opToPartList = pctx.getOpToPartList();\n    opToSamplePruner = pctx.getOpToSamplePruner();\n    topOps = pctx.getTopOps();\n    loadTableWork = pctx.getLoadTableWork();\n    loadFileWork = pctx.getLoadFileWork();\n    ctx = pctx.getContext();\n    destTableId = pctx.getDestTableId();\n    idToTableNameMap = pctx.getIdToTableNameMap();\n    uCtx = pctx.getUCtx();\n    listMapJoinOpsNoReducer = pctx.getListMapJoinOpsNoReducer();\n    prunedPartitions = pctx.getPrunedPartitions();\n    tabNameToTabObject = pctx.getTabNameToTabObject();\n    fetchTask = pctx.getFetchTask();\n    setLineageInfo(pctx.getLineageInfo());\n  }<fim_middle>// function below has no smell\n"}