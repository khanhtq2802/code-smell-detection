{"text": "<fim_prefix>/**\n * Copyright 2016 LinkedIn Corp. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n */\npackage com.github.ambry.network;\n\nimport com.github.ambry.utils.Time;\nimport java.io.IOException;\nimport java.net.SocketAddress;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.SocketChannel;\n\n\n/**\n * Defines the interface for channel interactions. Once the connection is established, {@link Selector} assigns\n * a {@link Transmission} object as attachment for a key. All operations to the channel like read, write, close, etc\n * happens via this class. This class is also responsible for exposing the characteristics of the underlying channel\n * like ready, isConnected and so on.\n */\npublic abstract class Transmission {\n\n  private String connectionId;\n  protected NetworkSend networkSend = null;\n  protected NetworkReceive networkReceive = null;\n  protected SocketChannel socketChannel = null;\n  protected SelectionKey key = null;\n  protected final Time time;\n  protected final NetworkMetrics metrics;\n\n<fim_suffix>  public Transmission(String connectionId, SocketChannel socketChannel, SelectionKey key, Time time,\n      NetworkMetrics metrics) {\n    this.connectionId = connectionId;\n    this.socketChannel = socketChannel;\n    this.key = key;\n    this.time = time;\n    this.metrics = metrics;\n  }\n\n  /**\n   * Actions taken as part of finishing a connection initiation. This will be called by client when server accepting\n   * its connection request.\n   * @throws IOException\n   */\n  public void finishConnect() throws IOException {\n    socketChannel.finishConnect();\n    key.interestOps(key.interestOps() & ~SelectionKey.OP_CONNECT | SelectionKey.OP_READ);\n  }\n\n  /**\n   * Setting network send to be written to the underlying channel asynchronously\n   * @param networkSend\n   */\n  public void setNetworkSend(NetworkSend networkSend) {\n    if (hasSend()) {\n      throw new IllegalStateException(\n          \"Attempt to begin a networkSend operation with prior networkSend operation still in progress.\");\n    }\n    this.networkSend = networkSend;\n    metrics.sendInFlight.inc();\n    key.interestOps(key.interestOps() | SelectionKey.OP_WRITE);\n  }\n\n  /**\n   * Prepare the channel to accept read and write calls\n   * @throws IOException\n   */\n  public abstract void prepare() throws IOException;\n\n  /**\n   * To check if the channel is ready to accept read and write calls\n   */\n  public abstract boolean ready();\n\n  /**\n   * Reads a sequence of bytes from the channel into the {@link NetworkReceive}\n   *\n   * @return true if read is complete, false otherwise\n   * @throws IOException if some other I/O error occurs\n   */\n  public abstract boolean read() throws IOException;\n\n  /**\n   * Writes a sequence of bytes to the channel from the payload in {@link NetworkSend}\n   *\n   * @return true if {@link Send} in {@link NetworkSend} is complete (by writing all bytes to the channel),\n   * false otherwise\n   * @throws IOException If some other I/O error occurs\n   */\n  public abstract boolean write() throws IOException;\n\n  /**\n   * Actions to be taken on completion of {@link Send} in {@link NetworkSend}\n   */\n  public abstract void onSendComplete();\n\n  /**\n   * Actions to be taken on completion of {@link BoundedByteBufferReceive} in {@link NetworkReceive}\n   */\n  public abstract void onReceiveComplete();\n\n  /**\n   * Returns true if {@link NetworkReceive} is read completely\n   * @return true if {@link NetworkReceive} is read completely, false otherwise\n   */\n  public boolean isReadComplete() {\n    if (networkReceive != null) {\n      return networkReceive.getReceivedBytes().isReadComplete();\n    }\n    return false;\n  }\n\n  /**\n   * Returns the remote socket address of the underlying socket channel\n   */\n  public SocketAddress getRemoteSocketAddress() {\n    return socketChannel.socket().getRemoteSocketAddress();\n  }\n\n  /**\n   * Close the connection for the socket channel\n   */\n  public abstract void close() throws IOException;\n\n  public String getConnectionId() {\n    return connectionId;\n  }\n\n  public SocketChannel getSocketChannel() {\n    return this.socketChannel;\n  }\n\n  public boolean hasSend() {\n    return networkSend != null;\n  }\n\n  public void clearSend() {\n    networkSend = null;\n  }\n\n  public boolean hasReceive() {\n    return networkReceive != null;\n  }\n\n  public void clearReceive() {\n    networkReceive = null;\n  }\n\n  public NetworkReceive getNetworkReceive() {\n    return this.networkReceive;\n  }\n\n  public NetworkSend getNetworkSend() {\n    return this.networkSend;\n  }\n\n  public boolean isConnected() {\n    return socketChannel.isConnected();\n  }\n}<fim_middle>// function below has no smell\n"}