{"text": "<fim_prefix>/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n */\npackage org.apache.qpid.server.util;\nimport java.io.UnsupportedEncodingException;\nimport java.io.Writer;\nimport java.nio.ByteBuffer;\nimport java.util.Arrays;\nimport java.util.Base64;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.Stack;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n/**\n * Strings\n *\n */\npublic final class Strings\n{\n    private Strings()\n    {\n    }\n    private static final byte[] EMPTY = new byte[0];\n    private static final ThreadLocal<char[]> charbuf = new ThreadLocal<char[]>()\n    {\n        @Override\n        public char[] initialValue()\n        {\n            return new char[4096];\n        }\n    };\n    public static final byte[] toUTF8(String str)\n    {\n        if (str == null)\n        {\n            return EMPTY;\n        }\n        else\n        {\n            final int size = str.length();\n            char[] chars = charbuf.get();\n            if (size > chars.length)\n            {\n                chars = new char[Math.max(size, 2*chars.length)];\n                charbuf.set(chars);\n            }\n            str.getChars(0, size, chars, 0);\n            final byte[] bytes = new byte[size];\n            for (int i = 0; i < size; i++)\n            {\n                if (chars[i] > 127)\n                {\n                    try\n                    {\n                        return str.getBytes(\"UTF-8\");\n                    }\n                    catch (UnsupportedEncodingException e)\n                    {\n                        throw new RuntimeException(e);\n                    }\n                }\n                bytes[i] = (byte) chars[i];\n            }\n            return bytes;\n        }\n    }\n    public static final String fromUTF8(byte[] bytes)\n    {\n        try\n        {\n            return new String(bytes, \"UTF-8\");\n        }\n        catch (UnsupportedEncodingException e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n    private static final Pattern VAR = Pattern.compile(\"(?:\\\\$\\\\{([^\\\\}]*)\\\\})|(?:\\\\$(\\\\$))\");\n    public static Resolver chain(Resolver... resolvers)\n    {\n        Resolver resolver;\n        if(resolvers.length == 0)\n        {\n            resolver =  NULL_RESOLVER;\n        }\n        else\n        {\n            resolver = resolvers[resolvers.length - 1];\n            for (int i = resolvers.length - 2; i >= 0; i--)\n            {\n                resolver = new ChainedResolver(resolvers[i], resolver);\n            }\n        }\n        return resolver;\n    }\n    public static byte[] decodeBase64(String base64String)\n    {\n        base64String = base64String.replaceAll(\"\\\\s\",\"\");\n        if(!base64String.matches(\"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\"))\n        {\n            throw new IllegalArgumentException(\"Cannot convert string '\"+ base64String+ \"'to a byte[] - it does not appear to be base64 data\");\n        }\n        return Base64.getDecoder().decode(base64String);\n    }\n    public static interface Resolver\n    {\n        String resolve(String variable, final Resolver resolver);\n    }\n    private static final Resolver NULL_RESOLVER =\n            new Resolver()\n            {\n                @Override\n                public String resolve(final String variable, final Resolver resolver)\n                {\n                    return null;\n                }\n            };\n<fim_suffix>    public static class MapResolver implements Resolver\n    {\n        private final Map<String,String> map;\n        public MapResolver(Map<String,String> map)\n        {\n            this.map = map;\n        }\n        @Override\n        public String resolve(String variable, final Resolver resolver)\n        {\n            return map.get(variable);\n        }\n    }\n    public static class PropertiesResolver implements Resolver\n    {\n        private final Properties properties;\n        public PropertiesResolver(Properties properties)\n        {\n            this.properties = properties;\n        }\n        @Override\n        public String resolve(String variable, final Resolver resolver)\n        {\n            return properties.getProperty(variable);\n        }\n    }\n    public static class ChainedResolver implements Resolver\n    {\n        private final Resolver primary;\n        private final Resolver secondary;\n        public ChainedResolver(Resolver primary, Resolver secondary)\n        {\n            this.primary = primary;\n            this.secondary = secondary;\n        }\n        @Override\n        public String resolve(String variable, final Resolver resolver)\n        {\n            String result = primary.resolve(variable, resolver);\n            if (result == null)\n            {\n                result = secondary.resolve(variable, resolver);\n            }\n            return result;\n        }\n    }\n    public static final Resolver ENV_VARS_RESOLVER = new Resolver()\n        {\n            @Override\n            public String resolve(final String variable, final Resolver resolver)\n            {\n                return System.getenv(variable);\n            }\n        };\n    public static final Resolver JAVA_SYS_PROPS_RESOLVER = new Resolver()\n    {\n        @Override\n        public String resolve(final String variable, final Resolver resolver)\n        {\n            return System.getProperty(variable);\n        }\n    };\n    public static final Resolver SYSTEM_RESOLVER = chain(JAVA_SYS_PROPS_RESOLVER, ENV_VARS_RESOLVER);\n    public static final String expand(String input)\n    {\n        return expand(input, SYSTEM_RESOLVER);\n    }\n    public static final String expand(String input, Resolver resolver)\n    {\n        return expand(input, resolver, new Stack<String>(),true);\n    }\n    public static final String expand(String input, boolean failOnUnresolved, Resolver... resolvers)\n    {\n        return expand(input, chain(resolvers), new Stack<String>(), failOnUnresolved);\n    }\n    private static final String expand(String input, Resolver resolver, Stack<String> stack, boolean failOnUnresolved)\n    {\n        if (input == null)\n        {\n            return null;\n        }\n        Matcher m = VAR.matcher(input);\n        StringBuffer result = new StringBuffer();\n        while (m.find())\n        {\n            String var = m.group(1);\n            if (var == null)\n            {\n                String esc = m.group(2);\n                if (\"$\".equals(esc))\n                {\n                    m.appendReplacement(result, Matcher.quoteReplacement(\"$\"));\n                }\n                else\n                {\n                    throw new IllegalArgumentException(esc);\n                }\n            }\n            else\n            {\n                m.appendReplacement(result, Matcher.quoteReplacement(resolve(var, resolver, stack, failOnUnresolved)));\n            }\n        }\n        m.appendTail(result);\n        return result.toString();\n    }\n    private static final String resolve(String var,\n                                        Resolver resolver,\n                                        Stack<String> stack,\n                                        final boolean failOnUnresolved)\n    {\n        if (stack.contains(var))\n        {\n            throw new IllegalArgumentException\n                (String.format(\"recursively defined variable: %s stack=%s\", var,\n                               stack));\n        }\n        String result = resolver.resolve(var, resolver);\n        if (result == null)\n        {\n            if(failOnUnresolved)\n            {\n                throw new IllegalArgumentException(\"no such variable: \" + var);\n            }\n            else\n            {\n                return \"${\"+var+\"}\";\n            }\n        }\n        stack.push(var);\n        try\n        {\n            return expand(result, resolver, stack, failOnUnresolved);\n        }\n        finally\n        {\n            stack.pop();\n        }\n    }\n    public static final String join(String sep, Iterable items)\n    {\n        StringBuilder result = new StringBuilder();\n        for (Object o : items)\n        {\n            if (result.length() > 0)\n            {\n                result.append(sep);\n            }\n            result.append(o.toString());\n        }\n        return result.toString();\n    }\n    public static final String join(String sep, Object[] items)\n    {\n        return join(sep, Arrays.asList(items));\n    }\n    public static final List<String> split(String listAsString)\n    {\n        if(listAsString != null && !\"\".equals(listAsString))\n        {\n            return Arrays.asList(listAsString.split(\"\\\\s*,\\\\s*\"));\n        }\n        return Collections.emptyList();\n    }<fim_middle>// class below has no smell\n"}