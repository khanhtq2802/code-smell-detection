{"text": "<fim_prefix>          // this means we need to evict blocks in memory bucket to make room,\n          // so the single and multi buckets will be emptied\n          bytesFreed = bucketSingle.free(s);\n          bytesFreed += bucketMulti.free(m);\n          if (LOG.isTraceEnabled()) {\n            LOG.trace(\"freed \" + StringUtils.byteDesc(bytesFreed) +\n              \" from single and multi buckets\");\n          }\n          bytesFreed += bucketMemory.free(bytesToFree - bytesFreed);\n          if (LOG.isTraceEnabled()) {\n            LOG.trace(\"freed \" + StringUtils.byteDesc(bytesFreed) +\n              \" total from all three buckets \");\n          }\n        } else {\n          // this means no need to evict block in memory bucket,\n          // and we try best to make the ratio between single-bucket and\n          // multi-bucket is 1:2\n          long bytesRemain = s + m - bytesToFree;\n          if (3 * s <= bytesRemain) {\n            // single-bucket is small enough that no eviction happens for it\n            // hence all eviction goes from multi-bucket\n            bytesFreed = bucketMulti.free(bytesToFree);\n          } else if (3 * m <= 2 * bytesRemain) {\n            // multi-bucket is small enough that no eviction happens for it\n            // hence all eviction goes from single-bucket\n            bytesFreed = bucketSingle.free(bytesToFree);\n          } else {\n            // both buckets need to evict some blocks\n            bytesFreed = bucketSingle.free(s - bytesRemain / 3);\n            if (bytesFreed < bytesToFree) {\n              bytesFreed += bucketMulti.free(bytesToFree - bytesFreed);\n            }\n          }\n        }\n      } else {\n        PriorityQueue<BlockBucket> bucketQueue = new PriorityQueue<>(3);\n        bucketQueue.add(bucketSingle);\n        bucketQueue.add(bucketMulti);\n        bucketQueue.add(bucketMemory);\n        int remainingBuckets = 3;\n        BlockBucket bucket;\n        while ((bucket = bucketQueue.poll()) != null) {\n          long overflow = bucket.overflow();\n          if (overflow > 0) {\n            long bucketBytesToFree =\n                Math.min(overflow, (bytesToFree - bytesFreed) / remainingBuckets);\n            bytesFreed += bucket.free(bucketBytesToFree);\n          }\n          remainingBuckets--;\n        }\n      }\n      if (LOG.isTraceEnabled()) {\n        long single = bucketSingle.totalSize();\n        long multi = bucketMulti.totalSize();\n        long memory = bucketMemory.totalSize();\n        LOG.trace(\"Block cache LRU eviction completed; \" +\n          \"freed=\" + StringUtils.byteDesc(bytesFreed) + \", \" +\n          \"total=\" + StringUtils.byteDesc(this.size.get()) + \", \" +\n          \"single=\" + StringUtils.byteDesc(single) + \", \" +\n          \"multi=\" + StringUtils.byteDesc(multi) + \", \" +\n          \"memory=\" + StringUtils.byteDesc(memory));\n      }\n    } finally {\n      stats.evict();\n      evictionInProgress = false;\n      evictionLock.unlock();\n    }\n  }\n  @Override\n  public String toString() {\n    return MoreObjects.toStringHelper(this)\n      .add(\"blockCount\", getBlockCount())\n      .add(\"currentSize\", StringUtils.byteDesc(getCurrentSize()))\n      .add(\"freeSize\", StringUtils.byteDesc(getFreeSize()))\n      .add(\"maxSize\", StringUtils.byteDesc(getMaxSize()))\n      .add(\"heapSize\", StringUtils.byteDesc(heapSize()))\n      .add(\"minSize\", StringUtils.byteDesc(minSize()))\n      .add(\"minFactor\", minFactor)\n      .add(\"multiSize\", StringUtils.byteDesc(multiSize()))\n      .add(\"multiFactor\", multiFactor)\n      .add(\"singleSize\", StringUtils.byteDesc(singleSize()))\n      .add(\"singleFactor\", singleFactor)\n      .toString();\n  }\n  /**\n   * Used to group blocks into priority buckets.  There will be a BlockBucket\n   * for each priority (single, multi, memory).  Once bucketed, the eviction\n   * algorithm takes the appropriate number of elements out of each according\n   * to configuration parameters and their relatives sizes.\n   */\n  private class BlockBucket implements Comparable<BlockBucket> {\n    private final String name;\n    private LruCachedBlockQueue queue;\n    private long totalSize = 0;\n    private long bucketSize;\n    public BlockBucket(String name, long bytesToFree, long blockSize, long bucketSize) {\n      this.name = name;\n      this.bucketSize = bucketSize;\n      queue = new LruCachedBlockQueue(bytesToFree, blockSize);\n      totalSize = 0;\n    }\n    public void add(LruCachedBlock block) {\n      totalSize += block.heapSize();\n      queue.add(block);\n    }\n    public long free(long toFree) {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(\"freeing \" + StringUtils.byteDesc(toFree) + \" from \" + this);\n      }\n      LruCachedBlock cb;\n      long freedBytes = 0;\n      while ((cb = queue.pollLast()) != null) {\n        freedBytes += evictBlock(cb, true);\n        if (freedBytes >= toFree) {\n          return freedBytes;\n        }\n      }\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(\"freed \" + StringUtils.byteDesc(freedBytes) + \" from \" + this);\n      }\n      return freedBytes;\n    }\n    public long overflow() {\n      return totalSize - bucketSize;\n    }\n    public long totalSize() {\n      return totalSize;\n    }\n    @Override\n    public int compareTo(BlockBucket that) {\n      return Long.compare(this.overflow(), that.overflow());\n    }\n    @Override\n    public boolean equals(Object that) {\n      if (that == null || !(that instanceof BlockBucket)) {\n        return false;\n      }\n      return compareTo((BlockBucket)that) == 0;\n    }\n    @Override\n    public int hashCode() {\n      return Objects.hashCode(name, bucketSize, queue, totalSize);\n    }\n    @Override\n    public String toString() {\n      return MoreObjects.toStringHelper(this)\n        .add(\"name\", name)\n        .add(\"totalSize\", StringUtils.byteDesc(totalSize))\n        .add(\"bucketSize\", StringUtils.byteDesc(bucketSize))\n        .toString();\n    }\n  }\n  /**\n   * Get the maximum size of this cache.\n   *\n   * @return max size in bytes\n   */\n  @Override\n  public long getMaxSize() {\n    return this.maxSize;\n  }\n  @Override\n  public long getCurrentSize() {\n    return this.size.get();\n  }\n  @Override\n  public long getCurrentDataSize() {\n    return this.dataBlockSize.sum();\n  }\n  @Override\n  public long getFreeSize() {\n    return getMaxSize() - getCurrentSize();\n  }\n  @Override\n  public long size() {\n    return getMaxSize();\n  }\n  @Override\n  public long getBlockCount() {\n    return this.elements.get();\n  }\n  @Override\n  public long getDataBlockCount() {\n    return this.dataBlockElements.sum();\n  }\n  EvictionThread getEvictionThread() {\n    return this.evictionThread;\n  }\n  /*\n   * Eviction thread.  Sits in waiting state until an eviction is triggered\n   * when the cache size grows above the acceptable level.<p>\n   *\n   * Thread is triggered into action by {@link LruBlockCache#runEviction()}\n   */\n  static class EvictionThread extends HasThread {\n    private WeakReference<LruBlockCache> cache;\n    private volatile boolean go = true;\n    // flag set after enter the run method, used for test\n    private boolean enteringRun = false;\n    public EvictionThread(LruBlockCache cache) {\n      super(Thread.currentThread().getName() + \".LruBlockCache.EvictionThread\");\n      setDaemon(true);\n      this.cache = new WeakReference<>(cache);\n    }\n    @Override\n    public void run() {\n      enteringRun = true;\n      while (this.go) {\n        synchronized (this) {\n          try {\n            this.wait(1000 * 10/*Don't wait for ever*/);\n          } catch (InterruptedException e) {\n            LOG.warn(\"Interrupted eviction thread \", e);\n            Thread.currentThread().interrupt();\n          }\n        }\n        LruBlockCache cache = this.cache.get();\n        if (cache == null) break;\n        cache.evict();\n      }\n    }\n<fim_suffix>    @edu.umd.cs.findbugs.annotations.SuppressWarnings(value=\"NN_NAKED_NOTIFY\",\n        justification=\"This is what we want\")\n    public void evict() {\n      synchronized (this) {\n        this.notifyAll();\n      }\n    }<fim_middle>// function below has no smell\n"}