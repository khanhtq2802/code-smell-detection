{"text": "<fim_prefix>//\n//  ========================================================================\n//  Copyright (c) 1995-2019 Mort Bay Consulting Pty. Ltd.\n//  ------------------------------------------------------------------------\n//  All rights reserved. This program and the accompanying materials\n//  are made available under the terms of the Eclipse Public License v1.0\n//  and Apache License v2.0 which accompanies this distribution.\n//\n//      The Eclipse Public License is available at\n//      http://www.eclipse.org/legal/epl-v10.html\n//\n//      The Apache License v2.0 is available at\n//      http://www.opensource.org/licenses/apache2.0.php\n//\n//  You may elect to redistribute this code under either of these licenses.\n//  ========================================================================\n//\n\npackage org.eclipse.jetty.http2.parser;\n\nimport java.nio.ByteBuffer;\n\nimport org.eclipse.jetty.http2.ErrorCode;\nimport org.eclipse.jetty.http2.Flags;\nimport org.eclipse.jetty.http2.frames.FrameType;\nimport org.eclipse.jetty.io.ByteBufferPool;\nimport org.eclipse.jetty.util.BufferUtil;\nimport org.eclipse.jetty.util.log.Log;\nimport org.eclipse.jetty.util.log.Logger;\n\npublic class ServerParser extends Parser\n{\n    private static final Logger LOG = Log.getLogger(ServerParser.class);\n\n    private final Listener listener;\n    private final PrefaceParser prefaceParser;\n    private State state = State.PREFACE;\n    private boolean notifyPreface = true;\n\n    public ServerParser(ByteBufferPool byteBufferPool, Listener listener, int maxDynamicTableSize, int maxHeaderSize)\n    {\n        super(byteBufferPool, listener, maxDynamicTableSize, maxHeaderSize);\n        this.listener = listener;\n        this.prefaceParser = new PrefaceParser(listener);\n    }\n\n    /**\n     * <p>A direct upgrade is an unofficial upgrade from HTTP/1.1 to HTTP/2.0.</p>\n     * <p>A direct upgrade is initiated when {@code org.eclipse.jetty.server.HttpConnection}\n     * sees a request with these bytes:</p>\n     * <pre>\n     * PRI * HTTP/2.0\\r\\n\n     * \\r\\n\n     * </pre>\n     * <p>This request is part of the HTTP/2.0 preface, indicating that a\n     * HTTP/2.0 client is attempting a h2c direct connection.</p>\n     * <p>This is not a standard HTTP/1.1 Upgrade path.</p>\n     */\n<fim_suffix>    public void directUpgrade()\n    {\n        if (state != State.PREFACE)\n            throw new IllegalStateException();\n        prefaceParser.directUpgrade();\n    }\n\n    /**\n     * <p>The standard HTTP/1.1 upgrade path.</p>\n     */\n    public void standardUpgrade()\n    {\n        if (state != State.PREFACE)\n            throw new IllegalStateException();\n        notifyPreface = false;\n    }\n\n    @Override\n    public void parse(ByteBuffer buffer)\n    {\n        try\n        {\n            if (LOG.isDebugEnabled())\n                LOG.debug(\"Parsing {}\", buffer);\n\n            while (true)\n            {\n                switch (state)\n                {\n                    case PREFACE:\n                    {\n                        if (!prefaceParser.parse(buffer))\n                            return;\n                        if (notifyPreface)\n                            onPreface();\n                        state = State.SETTINGS;\n                        break;\n                    }\n                    case SETTINGS:\n                    {\n                        if (!parseHeader(buffer))\n                            return;\n                        if (getFrameType() != FrameType.SETTINGS.getType() || hasFlag(Flags.ACK))\n                        {\n                            BufferUtil.clear(buffer);\n                            notifyConnectionFailure(ErrorCode.PROTOCOL_ERROR.code, \"invalid_preface\");\n                            return;\n                        }\n                        if (!parseBody(buffer))\n                            return;\n                        state = State.FRAMES;\n                        break;\n                    }\n                    case FRAMES:\n                    {\n                        // Stay forever in the FRAMES state.\n                        super.parse(buffer);\n                        return;\n                    }\n                    default:\n                    {\n                        throw new IllegalStateException();\n                    }\n                }\n            }\n        }\n        catch (Throwable x)\n        {\n            LOG.debug(x);\n            BufferUtil.clear(buffer);\n            notifyConnectionFailure(ErrorCode.PROTOCOL_ERROR.code, \"parser_error\");\n        }\n    }\n\n    protected void onPreface()\n    {\n        notifyPreface();\n    }\n\n    private void notifyPreface()\n    {\n        try\n        {\n            listener.onPreface();\n        }\n        catch (Throwable x)\n        {\n            LOG.info(\"Failure while notifying listener \" + listener, x);\n        }\n    }\n\n    public interface Listener extends Parser.Listener\n    {\n        public void onPreface();\n\n        public static class Adapter extends Parser.Listener.Adapter implements Listener\n        {\n            @Override\n            public void onPreface()\n            {\n            }\n        }\n\n        public static class Wrapper extends Parser.Listener.Wrapper implements Listener\n        {\n            public Wrapper(ServerParser.Listener listener)\n            {\n                super(listener);\n            }\n\n            @Override\n            public ServerParser.Listener getParserListener()\n            {\n                return (Listener)super.getParserListener();\n            }\n\n            @Override\n            public void onPreface()\n            {\n                getParserListener().onPreface();\n            }\n        }\n    }\n\n    private enum State\n    {\n        PREFACE, SETTINGS, FRAMES\n    }\n}<fim_middle>// function below has no smell\n"}