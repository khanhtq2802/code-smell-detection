{"text": "<fim_prefix>     * LIR), cold (high inter-reference recency; HIR), or non-resident-cold. Hot\n     * entries are in the stack only. Cold entries are in the queue, and may be\n     * in the stack. Non-resident-cold entries have their value set to null and\n     * are in the stack and in the non-resident queue.\n     *\n     * @param <K> the key type\n     * @param <V> the value type\n     */\n    static class Entry<K, V> {\n        /**\n         * The key.\n         */\n        K key;\n        /**\n         * The value. Set to null for non-resident-cold entries.\n         */\n        V value;\n        /**\n         * The estimated memory used.\n         */\n        int memory;\n        /**\n         * When the item was last moved to the top of the stack.\n         */\n        int topMove;\n        /**\n         * The next entry in the stack.\n         */\n        Entry<K, V> stackNext;\n        /**\n         * The previous entry in the stack.\n         */\n        Entry<K, V> stackPrev;\n        /**\n         * The next entry in the queue (either the resident queue or the\n         * non-resident queue).\n         */\n        Entry<K, V> queueNext;\n        /**\n         * The previous entry in the queue.\n         */\n        Entry<K, V> queuePrev;\n        /**\n         * The next entry in the map\n         */\n        Entry<K, V> mapNext;\n        /**\n         * Whether this entry is hot. Cold entries are in one of the two queues.\n         *\n         * @return whether the entry is hot\n         */\n        boolean isHot() {\n            return queueNext == null;\n        }\n    }\n    /**\n     * A builder for the cache.\n     */\n    public static class Builder<K, V> {\n        private String module;\n        private Weigher<K, V> weigher;\n        private long maxWeight;\n        private int averageWeight = 100;\n        private int segmentCount = 16;\n        private int stackMoveDistance = 16;\n        private EvictionCallback<K, V> evicted;\n        public Builder<K, V> recordStats() {\n            return this;\n        }\n        public Builder<K, V> module(String module) {\n            this.module = module;\n            return this;\n        }\n        /**\n         * Set the weigher which is used if memory usage of an entry is not\n         * explicitly set (when adding entries).\n         * \n         * @param weigher the weigher\n         * @return this\n         */\n        public Builder<K, V> weigher(Weigher<K, V> weigher) {\n            this.weigher = weigher;\n            return this;\n        }\n        /**\n         * Set the total maximum weight. If the cache is heavier, then entries\n         * are evicted.\n         * \n         * @param maxWeight the maximum weight\n         * @return this\n         */\n        public Builder<K, V> maximumWeight(long maxWeight) {\n            this.maxWeight = maxWeight;\n            return this;\n        }\n        /**\n         * Set the average weight of an entry. This is used, together with the\n         * maximum weight, to calculate the length of the internal array of the\n         * cache.\n         * \n         * For higher performance, the weight should be set relatively low, at\n         * the cost of some space. To save space, the average weight should be\n         * set high, at the cost of some performance.\n         * \n         * @param averageWeight the average weight\n         * @return this\n         */\n        public Builder<K, V> averageWeight(int averageWeight) {\n            this.averageWeight = averageWeight;\n            return this;\n        }\n        /**\n         * Set the maximum size (in number of entries). This is the same as\n         * setting the average weight of an entry to 1, and the maximum weight\n         * to the maximum size.\n         * \n         * @param maxSize the maximum size\n         * @return this\n         */\n        public Builder<K, V> maximumSize(long maxSize) {\n            this.maxWeight = maxSize;\n            this.averageWeight = 1;\n            return this;\n        }\n        public Builder<K, V> segmentCount(int segmentCount) {\n            if (Integer.bitCount(segmentCount) != 1 || segmentCount < 0 || segmentCount > 65536) {\n                LOG.warn(\"Illegal segment count: \" + segmentCount + \", using 16\");\n                segmentCount = 16;\n            }\n            this.segmentCount = segmentCount;\n            return this;\n        }\n        /**\n         * How many other item are to be moved to the top of the stack before\n         * the current item is moved. The default is 16. Using higher values\n         * will avoid re-ordering in many cases, so less time is spent\n         * reordering. But this somewhat reduces cache hit rate, and eviction\n         * will become more random. Typically, cache hit rate can be improved by\n         * using smaller values, and access performance can be improved using\n         * larger values. Using values larger than 128 is not recommended.\n         */\n        public Builder<K, V> stackMoveDistance(int stackMoveDistance) {\n            if (stackMoveDistance < 0) {\n                LOG.warn(\"Illegal stack move distance: \" + stackMoveDistance + \", using 16\");\n                stackMoveDistance = 16;\n            }\n            this.stackMoveDistance = stackMoveDistance;\n            return this;\n        }\n        public Builder<K, V> evictionCallback(EvictionCallback<K, V> evicted) {\n            this.evicted = evicted;\n            return this;\n        }\n        public CacheLIRS<K, V> build() {\n            return build(null);\n        }\n        public CacheLIRS<K, V> build(CacheLoader<K, V> cacheLoader) {\n            return new CacheLIRS<K, V>(weigher, maxWeight, averageWeight,\n                    segmentCount, stackMoveDistance, cacheLoader, evicted, module);\n        }\n    }\n    /**\n     * Create a builder.\n     *\n     * @return the builder\n     */\n    public static <K, V> Builder<K, V> newBuilder() {\n        return new Builder<K, V>();\n    }\n    @Override\n    public ImmutableMap<K, V> getAllPresent(Iterable<?> keys) {\n        throw new UnsupportedOperationException();\n    }\n<fim_suffix>    @Override\n    public ConcurrentMap<K, V> asMap() {\n        return new ConcurrentMap<K, V>() {\n            @Override\n            public int size() {\n                long size = CacheLIRS.this.size();\n                return (int) Math.min(size, Integer.MAX_VALUE);\n            }\n            @Override\n            public boolean isEmpty() {\n                return CacheLIRS.this.size() == 0;\n            }\n            @Override\n            public boolean containsKey(Object key) {\n                return CacheLIRS.this.containsKey(key);\n            }\n            @Override\n            public boolean containsValue(Object value) {\n                return CacheLIRS.this.containsValue(value);\n            }\n            @SuppressWarnings(\"unchecked\")\n            @Override\n            public V get(Object key) {\n                return CacheLIRS.this.peek((K) key);\n            }\n            @Override\n            public V put(K key, V value) {\n                return CacheLIRS.this.put(key, value, sizeOf(key, value));\n            }\n            @Override\n            public V remove(Object key) {\n                @SuppressWarnings(\"unchecked\")\n                V old = CacheLIRS.this.getUnchecked((K) key);\n                CacheLIRS.this.invalidate(key);\n                return old;\n            }\n            @Override\n            public void putAll(Map<? extends K, ? extends V> m) {\n                for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {\n                    put(e.getKey(), e.getValue());\n                }                \n            }\n            @Override\n            public void clear() {\n                CacheLIRS.this.clear();\n            }\n            @Override\n            public Set<K> keySet() {\n                return CacheLIRS.this.keySet();\n            }\n            @Override\n            public Collection<V> values() {\n                return CacheLIRS.this.values();\n            }\n            @Override\n            public Set<java.util.Map.Entry<K, V>> entrySet() {\n                return CacheLIRS.this.entrySet();\n            }\n            @Override\n            public V putIfAbsent(K key, V value) {\n                return CacheLIRS.this.putIfAbsent(key, value);\n            }\n            @Override\n            public boolean remove(Object key, Object value) {\n                return CacheLIRS.this.remove(key, value);\n            }\n            @Override\n            public boolean replace(K key, V oldValue, V newValue) {\n                return CacheLIRS.this.replace(key, oldValue, newValue);\n            }\n            @Override\n            public V replace(K key, V value) {\n                return CacheLIRS.this.replace(key, value);\n            }\n        };\n    }<fim_middle>// function below has no smell\n"}