{"text": "<fim_prefix>    try {\n      return urlDevice.getExtraString(WIFIDIRECT_KEY);\n    } catch (JSONException e) {\n      throw new RuntimeException(\n          \"Tried to get address when no description set \" + urlDevice.getId(), e);\n    }\n  }\n  /**\n   * Gets the UrlDevice port.\n   * @param urlDevice The device that is getting checked.\n   * @return The port for the device.\n   * @throws RuntimeException if no port present.\n   */\n  public static int getWifiPort(UrlDevice urlDevice) {\n    try {\n      return urlDevice.getExtraInt(WIFIDIRECT_PORT_KEY);\n    } catch (JSONException e) {\n      throw new RuntimeException(\n          \"Tried to get port when no port set \" + urlDevice.getId(), e);\n    }\n  }\n  /**\n   * Gets the amount of time in milliseconds to get the result from the PWS if available.\n   * @param pwsResult The result that is being queried.\n   * @return The trip time for the result.\n   * @throws RuntimeException If the trip time is not recorded.\n   */\n  public static long getPwsTripTimeMillis(PwsResult pwsResult) {\n    try {\n      return pwsResult.getExtraLong(PWSTRIPTIME_KEY);\n    } catch (JSONException e) {\n      throw new RuntimeException(\"PWS trip time not recorded in PwsResult\");\n    }\n  }\n  /**\n   * Gets the groupId for the result.\n   * @param pwsResult The result that is being queried.\n   * @return The groupId for the result.\n   */\n  public static String getGroupId(PwsResult pwsResult) {\n    // The PWS does not always give us a group id yet.\n    if (pwsResult.getGroupId() == null || pwsResult.getGroupId().equals(\"\")) {\n      try {\n        return new URI(pwsResult.getSiteUrl()).getHost() + pwsResult.getTitle();\n      } catch (URISyntaxException e) {\n        return pwsResult.getSiteUrl();\n      }\n    }\n    return pwsResult.getGroupId();\n  }\n  /**\n   * Updates the region resolver with the device.\n   * @param urlDevice The device to update region with.\n   */\n  public static void updateRegion(UrlDevice urlDevice) {\n    REGION_RESOLVER.onUpdate(urlDevice.getId(), getRssi(urlDevice), getTxPower(urlDevice));\n  }\n  /**\n   * Gets the smoothed RSSI for device from the region resolver.\n   * @param urlDevice The device being queried.\n   * @return The smoothed RSSI for the device.\n   */\n  public static double getSmoothedRssi(UrlDevice urlDevice) {\n    return REGION_RESOLVER.getSmoothedRssi(urlDevice.getId());\n  }\n  /**\n   * Gets the distance for device from the region resolver.\n   * @param urlDevice The device being queried.\n   * @return The distance for the device.\n   */\n  public static double getDistance(UrlDevice urlDevice) {\n    return REGION_RESOLVER.getDistance(urlDevice.getId());\n  }\n  /**\n   * Gets the region string for device from the region resolver.\n   * @param urlDevice The device being queried.\n   * @return The region string for the device.\n   */\n  public static String getRegionString(UrlDevice urlDevice) {\n    return RangingUtils.toString(REGION_RESOLVER.getRegion(urlDevice.getId()));\n  }\n  static class UrlDeviceBuilder extends UrlDevice.Builder {\n    /**\n     * Constructor for the UrlDeviceBuilder.\n     * @param id The id of the UrlDevice.\n     * @param url The url of the UrlDevice.\n     */\n    public UrlDeviceBuilder(String id, String url) {\n      super(id, url);\n    }\n    /**\n    * Set the device type.\n    * @return The builder with type set.\n    */\n    public UrlDeviceBuilder setDeviceType(String type) {\n      addExtra(TYPE_KEY, type);\n      return this;\n    }\n    /**\n     * Setter for the ScanTimeMillis.\n     * @param timeMillis The scan time of the UrlDevice.\n     * @return The builder with ScanTimeMillis set.\n     */\n    public UrlDeviceBuilder setScanTimeMillis(long timeMillis) {\n      addExtra(SCANTIME_KEY, timeMillis);\n      return this;\n    }\n    /**\n     * Set the public key to false.\n     * @return The builder with public set to false.\n     */\n    public UrlDeviceBuilder setPrivate() {\n      addExtra(PUBLIC_KEY, false);\n      return this;\n    }\n    /**\n     * Set the public key to true.\n     * @return The builder with public set to true.\n     */\n    public UrlDeviceBuilder setPublic() {\n      addExtra(PUBLIC_KEY, true);\n      return this;\n    }\n    /**\n     * Set the title.\n     * @param title corresonding to UrlDevice.\n     * @return The builder with title\n     */\n    public UrlDeviceBuilder setTitle(String title) {\n      addExtra(TITLE_KEY, title);\n      return this;\n    }\n    /**\n     * Set the description.\n     * @param description corresonding to UrlDevice.\n     * @return The builder with description\n     */\n    public UrlDeviceBuilder setDescription(String description) {\n      addExtra(DESCRIPTION_KEY, description);\n      return this;\n    }\n    /**\n     * Set wifi-direct MAC address.\n     * @param MAC address corresonding to UrlDevice.\n     * @return The builder with address\n     */\n    public UrlDeviceBuilder setWifiAddress(String address) {\n      addExtra(WIFIDIRECT_KEY, address);\n      return this;\n    }\n        /**\n     * Set wifi-direct port.\n     * @param port corresonding to UrlDevice.\n     * @return The builder with port\n     */\n    public UrlDeviceBuilder setWifiPort(int port) {\n      addExtra(WIFIDIRECT_PORT_KEY, port);\n      return this;\n    }\n    /**\n     * Setter for the RSSI.\n     * @param rssi The RSSI of the UrlDevice.\n     * @return The builder with RSSI set.\n     */\n    public UrlDeviceBuilder setRssi(int rssi) {\n      addExtra(RSSI_KEY, rssi);\n      return this;\n    }\n    /**\n     * Setter for the TX power.\n     * @param txPower The TX power of the UrlDevice.\n     * @return The builder with TX power set.\n     */\n    public UrlDeviceBuilder setTxPower(int txPower) {\n      addExtra(TXPOWER_KEY, txPower);\n      return this;\n    }\n  }\n  static class PwsResultBuilder extends PwsResult.Builder {\n    /**\n     * Constructor for the PwsResultBuilder.\n     * @param pwsResult The base result of the PwsResultBuilder.\n     */\n    public PwsResultBuilder(PwsResult pwsResult) {\n      super(pwsResult);\n    }\n    /**\n     * Setter for the PWS Trip Time.\n     * @param pwsResult The pwsResult.\n     * @param timeMillis The PWS Trip Time for the result.\n     * @return The builder PWS Trip Time set.\n     */\n    public PwsResultBuilder setPwsTripTimeMillis(PwsResult pwsResult, long timeMillis) {\n      addExtra(PWSTRIPTIME_KEY, timeMillis);\n      return this;\n    }\n  }\n  /**\n   * Determines if a file is gzipped by examining the signature of\n   * the file, which is the first two bytes.\n   * @param file to be determined if is gzipped.\n   * @return true If the contents of the file are gzipped otherwise false.\n   */\n  public static boolean isGzippedFile(File file) {\n    InputStream input;\n    try {\n      input = new FileInputStream(file);\n    } catch(FileNotFoundException e) {\n      return false;\n    }\n    byte[] signature = new byte[GZIP_SIGNATURE_LENGTH];\n    try {\n      input.read(signature);\n    } catch(IOException e) {\n      return false;\n    }\n    return ((signature[0] == (byte) (GZIPInputStream.GZIP_MAGIC))\n            && (signature[1] == (byte) (GZIPInputStream.GZIP_MAGIC >> 8)));\n  }\n  /**\n   * Out-of-place Gunzips from src to dest.\n   * @param src file containing gzipped information.\n   * @param dest file to place decompressed information.\n   * @return File that has decompressed information.\n   */\n<fim_suffix>  public static File gunzip(File src, File dest) {\n    byte[] buffer = new byte[1024];\n    try{\n      GZIPInputStream gzis = new GZIPInputStream(new FileInputStream(src));\n      FileOutputStream out = new FileOutputStream(dest);\n      int len;\n      while ((len = gzis.read(buffer)) > 0) {\n        out.write(buffer, 0, len);\n      }\n      gzis.close();\n      out.close();\n    } catch(IOException ex){\n       ex.printStackTrace();\n    }\n    return dest;\n   }<fim_middle>// function below has no smell\n"}