{"text": "<fim_prefix>      this.currentBuffer.asSubByteBuffer(this.valueOffset, valAndTagsLength, this.tmpPair);\n      valAndTagsBuffer = this.tmpPair.getFirst();\n      vOffset = this.tmpPair.getSecond();// This is the offset to value part in the BB\n      if (valAndTagsBuffer.hasArray()) {\n        return toOnheapCell(valAndTagsBuffer, vOffset, tagsLenSerializationSize);\n      } else {\n        return toOffheapCell(valAndTagsBuffer, vOffset, tagsLenSerializationSize);\n      }\n    }\n    private Cell toOnheapCell(ByteBuffer valAndTagsBuffer, int vOffset,\n        int tagsLenSerializationSize) {\n      byte[] tagsArray = HConstants.EMPTY_BYTE_ARRAY;\n      int tOffset = 0;\n      if (this.includeTags) {\n        if (this.tagCompressionContext == null) {\n          tagsArray = valAndTagsBuffer.array();\n          tOffset = valAndTagsBuffer.arrayOffset() + vOffset + this.valueLength\n              + tagsLenSerializationSize;\n        } else {\n          tagsArray = Bytes.copy(tagsBuffer, 0, this.tagsLength);\n          tOffset = 0;\n        }\n      }\n      return new OnheapDecodedCell(Bytes.copy(keyBuffer, 0, this.keyLength),\n          currentKey.getRowLength(), currentKey.getFamilyOffset(), currentKey.getFamilyLength(),\n          currentKey.getQualifierOffset(), currentKey.getQualifierLength(),\n          currentKey.getTimestamp(), currentKey.getTypeByte(), valAndTagsBuffer.array(),\n          valAndTagsBuffer.arrayOffset() + vOffset, this.valueLength, memstoreTS, tagsArray,\n          tOffset, this.tagsLength);\n    }\n    private Cell toOffheapCell(ByteBuffer valAndTagsBuffer, int vOffset,\n        int tagsLenSerializationSize) {\n      ByteBuffer tagsBuf = HConstants.EMPTY_BYTE_BUFFER;\n      int tOffset = 0;\n      if (this.includeTags) {\n        if (this.tagCompressionContext == null) {\n          tagsBuf = valAndTagsBuffer;\n          tOffset = vOffset + this.valueLength + tagsLenSerializationSize;\n        } else {\n          tagsBuf = ByteBuffer.wrap(Bytes.copy(tagsBuffer, 0, this.tagsLength));\n          tOffset = 0;\n        }\n      }\n      return new OffheapDecodedExtendedCell(\n          ByteBuffer.wrap(Bytes.copy(keyBuffer, 0, this.keyLength)), currentKey.getRowLength(),\n          currentKey.getFamilyOffset(), currentKey.getFamilyLength(),\n          currentKey.getQualifierOffset(), currentKey.getQualifierLength(),\n          currentKey.getTimestamp(), currentKey.getTypeByte(), valAndTagsBuffer, vOffset,\n          this.valueLength, memstoreTS, tagsBuf, tOffset, this.tagsLength);\n    }\n  }\n  /**\n   * Copies only the key part of the keybuffer by doing a deep copy and passes the\n   * seeker state members for taking a clone.\n   * Note that the value byte[] part is still pointing to the currentBuffer and\n   * represented by the valueOffset and valueLength\n   */\n  // We return this as a Cell to the upper layers of read flow and might try setting a new SeqId\n  // there. So this has to be an instance of ExtendedCell.\n<fim_suffix>  protected static class OnheapDecodedCell implements ExtendedCell {\n    private static final long FIXED_OVERHEAD = ClassSize.align(ClassSize.OBJECT\n        + (3 * ClassSize.REFERENCE) + (2 * Bytes.SIZEOF_LONG) + (7 * Bytes.SIZEOF_INT)\n        + (Bytes.SIZEOF_SHORT) + (2 * Bytes.SIZEOF_BYTE) + (3 * ClassSize.ARRAY));\n    private byte[] keyOnlyBuffer;\n    private short rowLength;\n    private int familyOffset;\n    private byte familyLength;\n    private int qualifierOffset;\n    private int qualifierLength;\n    private long timestamp;\n    private byte typeByte;\n    private byte[] valueBuffer;\n    private int valueOffset;\n    private int valueLength;\n    private byte[] tagsBuffer;\n    private int tagsOffset;\n    private int tagsLength;\n    private long seqId;\n    protected OnheapDecodedCell(byte[] keyBuffer, short rowLength, int familyOffset,\n        byte familyLength, int qualOffset, int qualLength, long timeStamp, byte typeByte,\n        byte[] valueBuffer, int valueOffset, int valueLen, long seqId, byte[] tagsBuffer,\n        int tagsOffset, int tagsLength) {\n      this.keyOnlyBuffer = keyBuffer;\n      this.rowLength = rowLength;\n      this.familyOffset = familyOffset;\n      this.familyLength = familyLength;\n      this.qualifierOffset = qualOffset;\n      this.qualifierLength = qualLength;\n      this.timestamp = timeStamp;\n      this.typeByte = typeByte;\n      this.valueBuffer = valueBuffer;\n      this.valueOffset = valueOffset;\n      this.valueLength = valueLen;\n      this.tagsBuffer = tagsBuffer;\n      this.tagsOffset = tagsOffset;\n      this.tagsLength = tagsLength;\n      setSequenceId(seqId);\n    }\n    @Override\n    public byte[] getRowArray() {\n      return keyOnlyBuffer;\n    }\n    @Override\n    public byte[] getFamilyArray() {\n      return keyOnlyBuffer;\n    }\n    @Override\n    public byte[] getQualifierArray() {\n      return keyOnlyBuffer;\n    }\n    @Override\n    public int getRowOffset() {\n      return Bytes.SIZEOF_SHORT;\n    }\n    @Override\n    public short getRowLength() {\n      return rowLength;\n    }\n    @Override\n    public int getFamilyOffset() {\n      return familyOffset;\n    }\n    @Override\n    public byte getFamilyLength() {\n      return familyLength;\n    }\n    @Override\n    public int getQualifierOffset() {\n      return qualifierOffset;\n    }\n    @Override\n    public int getQualifierLength() {\n      return qualifierLength;\n    }\n    @Override\n    public long getTimestamp() {\n      return timestamp;\n    }\n    @Override\n    public byte getTypeByte() {\n      return typeByte;\n    }\n    @Override\n    public long getSequenceId() {\n      return seqId;\n    }\n    @Override\n    public byte[] getValueArray() {\n      return this.valueBuffer;\n    }\n    @Override\n    public int getValueOffset() {\n      return valueOffset;\n    }\n    @Override\n    public int getValueLength() {\n      return valueLength;\n    }\n    @Override\n    public byte[] getTagsArray() {\n      return this.tagsBuffer;\n    }\n    @Override\n    public int getTagsOffset() {\n      return this.tagsOffset;\n    }\n    @Override\n    public int getTagsLength() {\n      return tagsLength;\n    }\n    @Override\n    public String toString() {\n      return KeyValue.keyToString(this.keyOnlyBuffer, 0, KeyValueUtil.keyLength(this)) + \"/vlen=\"\n          + getValueLength() + \"/seqid=\" + seqId;\n    }\n    @Override\n    public void setSequenceId(long seqId) {\n      this.seqId = seqId;\n    }\n    @Override\n    public long heapSize() {\n      return FIXED_OVERHEAD + rowLength + familyLength + qualifierLength + valueLength + tagsLength;\n    }\n    @Override\n    public int write(OutputStream out, boolean withTags) throws IOException {\n      int lenToWrite = getSerializedSize(withTags);\n      ByteBufferUtils.putInt(out, keyOnlyBuffer.length);\n      ByteBufferUtils.putInt(out, valueLength);\n      // Write key\n      out.write(keyOnlyBuffer);\n      // Write value\n      out.write(this.valueBuffer, this.valueOffset, this.valueLength);\n      if (withTags && this.tagsLength > 0) {\n        // 2 bytes tags length followed by tags bytes\n        // tags length is serialized with 2 bytes only(short way) even if the type is int.\n        // As this is non -ve numbers, we save the sign bit. See HBASE-11437\n        out.write((byte) (0xff & (this.tagsLength >> 8)));\n        out.write((byte) (0xff & this.tagsLength));\n        out.write(this.tagsBuffer, this.tagsOffset, this.tagsLength);\n      }\n      return lenToWrite;\n    }\n    @Override\n    public int getSerializedSize(boolean withTags) {\n      return KeyValueUtil.length(rowLength, familyLength, qualifierLength, valueLength, tagsLength,\n          withTags);\n    }\n    @Override\n    public void write(ByteBuffer buf, int offset) {\n      // This is not used in actual flow. Throwing UnsupportedOperationException\n      throw new UnsupportedOperationException();\n    }\n    @Override\n    public void setTimestamp(long ts) throws IOException {\n      // This is not used in actual flow. Throwing UnsupportedOperationException\n      throw new UnsupportedOperationException();\n    }\n    @Override\n    public void setTimestamp(byte[] ts) throws IOException {\n      // This is not used in actual flow. Throwing UnsupportedOperationException\n      throw new UnsupportedOperationException();\n    }\n    @Override\n    public ExtendedCell deepClone() {\n      // This is not used in actual flow. Throwing UnsupportedOperationException\n      throw new UnsupportedOperationException();\n    }\n  }<fim_middle>// class below is data class\n"}