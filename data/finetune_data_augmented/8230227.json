{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.cocoon.transformation;\nimport org.apache.avalon.framework.parameters.Parameters;\nimport org.apache.cocoon.ProcessingException;\nimport org.apache.excalibur.source.Source;\nimport org.apache.excalibur.source.SourceException;\nimport org.apache.cocoon.components.source.util.SourceUtil;\nimport org.apache.cocoon.environment.SourceResolver;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.Locator;\nimport org.xml.sax.SAXException;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Date;\nimport java.util.Map;\n/**\n * The <code>LogTransformer</code> is a class that can be plugged into a pipeline\n * to print the SAX events which passes thru this transformer in a readable form\n * to a file.\n * <br>\n * The file will be specified in a parameter tag in the sitemap pipeline to the\n * transformer as follows:\n * <p>\n * <pre>\n * &lt;map:transform type=\"log\"&gt;\n * &nbsp;&nbsp;&lt;map:parameter name=\"logfile\" value=\"logfile.log\"/&gt;\n * &nbsp;&nbsp;&lt;map:parameter name=\"append\" value=\"no\"/&gt;\n * &lt;/map:transform&gt;\n * </pre>\n * </p>\n *\n * Because the log file will be hardcoded into the sitemap this LOGTransformer will\n * not be thread save!!\n * <br>\n * This transformations main purpose is debugging.\n *\n * @cocoon.sitemap.component.documentation\n * The <code>LogTransformer</code> is a class that can be plugged into a pipeline\n * to print the SAX events which passes thru this transformer in a readable form\n * to a file.\n * @cocoon.sitemap.component.name  log\n * @cocoon.sitemap.component.documentation.caching No\n * @cocoon.sitemap.component.pooling.max  16\n *\n * @version $Id$\n */\npublic class LogTransformer extends AbstractTransformer {\n    private static String lf = System.getProperty(\"line.separator\", \"\\n\");\n    /** log file */\n    private FileWriter logfile;\n    /**\n     * Setup\n     */\n    public void setup(SourceResolver resolver, Map objectModel,\n                      String src, Parameters parameters)\n    throws ProcessingException, SAXException, IOException {\n        final boolean append = parameters.getParameterAsBoolean(\"append\", false);\n        final String  logfilename = parameters.getParameter(\"logfile\", null);\n        // Check for null, use System.out if logfile is not specified.\n        this.logfile = null;\n        if ( null != logfilename ) {\n            Source source = null;\n            try {\n                source = resolver.resolveURI( logfilename );\n                final String systemId = source.getURI();\n                if ( systemId.startsWith(\"file:\") ) {\n                    this.logfile = new FileWriter(systemId.substring(5), append );\n                } else {\n                    throw new ProcessingException(\"The logfile parameter must point to a file: \" + logfilename);\n                }\n            } catch (SourceException se) {\n                throw SourceUtil.handle(se);\n            } finally {\n                resolver.release( source );\n            }\n        }\n        Date date = new Date();\n        StringBuffer logEntry = new StringBuffer();\n        logEntry.append ( \"---------------------------- [\" );\n        logEntry.append ( date.toString() );\n        logEntry.append ( \"] ----------------------------\" );\n        this.log(\"setup\", logEntry.toString());\n    }\n    /**\n     * Recycle\n     */\n    public void recycle() {\n        super.recycle();\n        try {\n            if (this.logfile != null) logfile.close();\n        } catch (Exception e) {\n            this.getLogger().warn(\"LogTransformer.recycle()\", e);\n        }\n        this.logfile = null;\n    }\n    /**\n     * Receive an object for locating the origin of SAX document events.\n     */\n    public void setDocumentLocator(Locator locator) {\n        this.log(\"setDocumentLocator\", locator != null ? \"systemid=\"+locator.getSystemId()+\",publicid=\"+locator.getPublicId() : \"(locator is null)\");\n        if (super.contentHandler!=null) {\n            super.contentHandler.setDocumentLocator(locator);\n        }\n    }\n    /**\n     * Receive notification of the beginning of a document.\n     */\n    public void startDocument()\n    throws SAXException {\n        this.log(\"startDocument\", \"\");\n        if (super.contentHandler!=null) {\n            super.contentHandler.startDocument();\n        }\n    }\n    /**\n     * Receive notification of the end of a document.\n     */\n    public void endDocument()\n    throws SAXException {\n        this.log (\"endDocument\", \"\");\n        if (super.contentHandler!=null) {\n            super.contentHandler.endDocument();\n        }\n    }\n    /**\n     * Begin the scope of a prefix-URI Namespace mapping.\n     */\n    public void startPrefixMapping(String prefix, String uri)\n    throws SAXException {\n        this.log (\"startPrefixMapping\", \"prefix=\"+prefix+\",uri=\"+uri);\n        if (super.contentHandler!=null) {\n            super.contentHandler.startPrefixMapping(prefix,uri);\n        }\n    }\n    /**\n     * End the scope of a prefix-URI mapping.\n     */\n    public void endPrefixMapping(String prefix)\n    throws SAXException {\n        this.log (\"endPrefixMapping\", \"prefix=\"+prefix);\n        if (super.contentHandler!=null) {\n            super.contentHandler.endPrefixMapping(prefix);\n        }\n    }\n    /**\n     * Receive notification of the beginning of an element.\n     */\n    public void startElement(String uri, String loc, String raw, Attributes a)\n    throws SAXException {\n        this.log (\"startElement\", \"uri=\"+uri+\",local=\"+loc+\",raw=\"+raw);\n        for (int i = 0; i < a.getLength(); i++) {\n            this.log (\"            \", new Integer(i+1).toString()\n                 +\". uri=\"+a.getURI(i)\n                 +\",local=\"+a.getLocalName(i)\n                 +\",qname=\"+a.getQName(i)\n                 +\",type=\"+a.getType(i)\n                 +\",value=\"+a.getValue(i));\n        }\n        if (super.contentHandler!=null) {\n            super.contentHandler.startElement(uri,loc,raw,a);\n        }\n    }\n    /**\n     * Receive notification of the end of an element.\n     */\n    public void endElement(String uri, String loc, String raw)\n    throws SAXException {\n        this.log (\"endElement\", \"uri=\"+uri+\",local=\"+loc+\",raw=\"+raw);\n        if (super.contentHandler!=null) {\n            super.contentHandler.endElement(uri,loc,raw);\n        }\n    }\n    /**\n     * Receive notification of character data.\n     */\n    public void characters(char ch[], int start, int len)\n    throws SAXException {\n        this.log (\"characters\", new String(ch,start,len));\n        if (super.contentHandler!=null) {\n            super.contentHandler.characters(ch,start,len);\n        }\n    }\n    /**\n     * Receive notification of ignorable whitespace in element content.\n     */\n<fim_suffix>    public void ignorableWhitespace(char ch[], int start, int len)\n    throws SAXException {\n        this.log (\"ignorableWhitespace\", new String(ch,start,len));\n        if (super.contentHandler!=null) {\n            super.contentHandler.ignorableWhitespace(ch,start,len);\n        }\n    }\n    /**\n     * Receive notification of a processing instruction.\n     */\n    public void processingInstruction(String target, String data)\n    throws SAXException {\n        log (\"processingInstruction\", \"target=\"+target+\",data=\"+data);\n        if (super.contentHandler!=null) {\n            super.contentHandler.processingInstruction(target,data);\n        }\n    }\n    /**\n     * Receive notification of a skipped entity.\n     */\n    public void skippedEntity(String name)\n    throws SAXException {\n        this.log (\"skippedEntity\", \"name=\"+name);\n        if (super.contentHandler!=null) {\n            super.contentHandler.skippedEntity(name);\n        }\n    }\n    /**\n     * Report the start of DTD declarations, if any.\n     */\n    public void startDTD(String name, String publicId, String systemId)\n    throws SAXException {<fim_middle>// function below has no smell\n"}