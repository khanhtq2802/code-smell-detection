{"text": "<fim_prefix>\n<fim_suffix>public class OperatorWrapper {\n  @SuppressWarnings(\"unused\")\n  private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(OperatorWrapper.class);\n  private static final DecimalFormat DECIMAL_FORMATTER = new DecimalFormat(\"#.##\");\n  private static final String UNKNOWN_OPERATOR = \"UNKNOWN_OPERATOR\";\n  //Negative valued constant used for denoting invalid index to indicate absence of metric\n  private static final int NO_SPILL_METRIC_INDEX = Integer.MIN_VALUE;\n  private final int major;\n  private final List<ImmutablePair<ImmutablePair<OperatorProfile, Integer>, String>> opsAndHosts; // [(operatorProfile --> minorFragment number,host), ...]\n  private final OperatorProfile firstProfile;\n  private final CoreOperatorType operatorType;\n  private final String operatorName;\n  private final int size;\n  private final int timeSkewMin;\n  private final double timeSkewRatio;\n  private final int scanWaitMin;\n  private final double waitSkewRatio;\n  public OperatorWrapper(int major, List<ImmutablePair<ImmutablePair<OperatorProfile, Integer>, String>> opsAndHostsList, Map<String, String> phyOperMap, DrillConfig config) {\n    //Threshold to track if the slowest operator ran relatively slow\n    timeSkewMin = config.getInt(ExecConstants.PROFILE_WARNING_TIME_SKEW_MIN);\n    timeSkewRatio = config.getDouble(ExecConstants.PROFILE_WARNING_TIME_SKEW_RATIO_PROCESS);\n    //Threshold to track if the slowest SCAN operator spent more time in wait than processing\n    scanWaitMin = config.getInt(ExecConstants.PROFILE_WARNING_SCAN_WAIT_MIN);\n    waitSkewRatio = config.getDouble(ExecConstants.PROFILE_WARNING_TIME_SKEW_RATIO_WAIT);\n    Preconditions.checkArgument(opsAndHostsList.size() > 0);\n    this.major = major;\n    firstProfile = opsAndHostsList.get(0).getLeft().getLeft();\n    operatorType = CoreOperatorType.valueOf(firstProfile.getOperatorType());\n    //Update Name from Physical Map\n    String path = new OperatorPathBuilder().setMajor(major).setOperator(firstProfile).build();\n    //Use Plan Extracted Operator Names if available\n    String extractedOpName = phyOperMap.get(path);\n    String inferredOpName = operatorType == null ? UNKNOWN_OPERATOR : operatorType.toString();\n    //Revert to inferred names for exceptional cases\n    // 1. Extracted 'FLATTEN' operator is NULL\n    // 2. Extracted 'SCAN' could be a PARQUET_ROW_GROUP_SCAN, or KAFKA_SUB_SCAN, or etc.\n    // 3. Extracted 'UNION_EXCHANGE' could be a SINGLE_SENDER or UNORDERED_RECEIVER\n    if (extractedOpName == null || inferredOpName.contains(extractedOpName) || extractedOpName.endsWith(\"_EXCHANGE\")) {\n      operatorName =  inferredOpName;\n    } else {\n      operatorName =  extractedOpName;\n    }\n    this.opsAndHosts = opsAndHostsList;\n    size = opsAndHostsList.size();\n  }\n  public String getDisplayName() {\n    final String path = new OperatorPathBuilder().setMajor(major).setOperator(firstProfile).build();\n    return String.format(\"%s - %s\", path, operatorName);\n  }\n  public String getId() {\n    return String.format(\"operator-%d-%d\", major, opsAndHosts.get(0).getLeft().getLeft().getOperatorId());\n  }\n  public static final String [] OPERATOR_COLUMNS = {\n      OperatorTblTxt.MINOR_FRAGMENT, OperatorTblTxt.HOSTNAME, OperatorTblTxt.SETUP_TIME, OperatorTblTxt.PROCESS_TIME, OperatorTblTxt.WAIT_TIME,\n      OperatorTblTxt.MAX_BATCHES, OperatorTblTxt.MAX_RECORDS, OperatorTblTxt.PEAK_MEMORY\n  };\n  public static final String [] OPERATOR_COLUMNS_TOOLTIP = {\n      OperatorTblTooltip.MINOR_FRAGMENT, OperatorTblTooltip.HOSTNAME, OperatorTblTooltip.SETUP_TIME, OperatorTblTooltip.PROCESS_TIME, OperatorTblTooltip.WAIT_TIME,\n      OperatorTblTooltip.MAX_BATCHES, OperatorTblTooltip.MAX_RECORDS, OperatorTblTooltip.PEAK_MEMORY\n  };\n  public String getContent() {\n    TableBuilder builder = new TableBuilder(OPERATOR_COLUMNS, OPERATOR_COLUMNS_TOOLTIP, true);\n    Map<String, String> attributeMap = new HashMap<>(); //Reusing for different fragments\n    for (ImmutablePair<ImmutablePair<OperatorProfile, Integer>, String> ip : opsAndHosts) {\n      int minor = ip.getLeft().getRight();\n      OperatorProfile op = ip.getLeft().getLeft();\n      attributeMap.put(HtmlAttribute.DATA_ORDER, String.valueOf(minor)); //Overwrite values from previous fragments\n      String path = new OperatorPathBuilder().setMajor(major).setMinor(minor).setOperator(op).build();\n      builder.appendCell(path, attributeMap);\n      builder.appendCell(ip.getRight());\n      builder.appendNanos(op.getSetupNanos());\n      builder.appendNanos(op.getProcessNanos());\n      builder.appendNanos(op.getWaitNanos());\n      long maxBatches = Long.MIN_VALUE;\n      long maxRecords = Long.MIN_VALUE;\n      for (StreamProfile sp : op.getInputProfileList()) {\n        maxBatches = Math.max(sp.getBatches(), maxBatches);\n        maxRecords = Math.max(sp.getRecords(), maxRecords);\n      }\n      builder.appendFormattedInteger(maxBatches);\n      builder.appendFormattedInteger(maxRecords);\n      builder.appendBytes(op.getPeakLocalMemoryAllocated());\n    }\n    return builder.build();\n  }\n  public static final String[] OPERATORS_OVERVIEW_COLUMNS = {\n      OverviewTblTxt.OPERATOR_ID, OverviewTblTxt.TYPE_OF_OPERATOR,\n      OverviewTblTxt.AVG_SETUP_TIME, OverviewTblTxt.MAX_SETUP_TIME,\n      OverviewTblTxt.AVG_PROCESS_TIME, OverviewTblTxt.MAX_PROCESS_TIME,\n      OverviewTblTxt.MIN_WAIT_TIME, OverviewTblTxt.AVG_WAIT_TIME, OverviewTblTxt.MAX_WAIT_TIME,\n      OverviewTblTxt.PERCENT_FRAGMENT_TIME, OverviewTblTxt.PERCENT_QUERY_TIME, OverviewTblTxt.ROWS,\n      OverviewTblTxt.AVG_PEAK_MEMORY, OverviewTblTxt.MAX_PEAK_MEMORY\n  };\n  public static final String[] OPERATORS_OVERVIEW_COLUMNS_TOOLTIP = {\n      OverviewTblTooltip.OPERATOR_ID, OverviewTblTooltip.TYPE_OF_OPERATOR,\n      OverviewTblTooltip.AVG_SETUP_TIME, OverviewTblTooltip.MAX_SETUP_TIME,\n      OverviewTblTooltip.AVG_PROCESS_TIME, OverviewTblTooltip.MAX_PROCESS_TIME,\n      OverviewTblTooltip.MIN_WAIT_TIME, OverviewTblTooltip.AVG_WAIT_TIME, OverviewTblTooltip.MAX_WAIT_TIME,\n      OverviewTblTooltip.PERCENT_FRAGMENT_TIME, OverviewTblTooltip.PERCENT_QUERY_TIME, OverviewTblTooltip.ROWS,\n      OverviewTblTooltip.AVG_PEAK_MEMORY, OverviewTblTooltip.MAX_PEAK_MEMORY\n  };\n  //Palette to help shade operators sharing a common major fragment\n  private static final String[] OPERATOR_OVERVIEW_BGCOLOR_PALETTE = {\"#ffffff\",\"#f2f2f2\"};\n  public void addSummary(TableBuilder tb, Map<String, Long> majorFragmentBusyTally, long majorFragmentBusyTallyTotal) {\n    //Select background color from palette\n    String opTblBgColor = OPERATOR_OVERVIEW_BGCOLOR_PALETTE[major%OPERATOR_OVERVIEW_BGCOLOR_PALETTE.length];\n    String path = new OperatorPathBuilder().setMajor(major).setOperator(firstProfile).build();\n    tb.appendCell(path, opTblBgColor, null);\n    tb.appendCell(operatorName);\n    //Check if spill information is available\n    int spillCycleMetricIndex = getSpillCycleMetricIndex(operatorType);\n    boolean isSpillableOp = (spillCycleMetricIndex != NO_SPILL_METRIC_INDEX);\n    boolean hasSpilledToDisk = false;\n    boolean isScanOp = operatorName.endsWith(\"SCAN\");\n    //Get MajorFragment Busy+Wait Time Tally\n    long majorBusyNanos = majorFragmentBusyTally.get(new OperatorPathBuilder().setMajor(major).build());\n    double setupSum = 0.0;\n    double processSum = 0.0;\n    double waitSum = 0.0;\n    double memSum = 0.0;\n    double spillCycleSum = 0.0;\n    long spillCycleMax = 0L;\n    long recordSum = 0L;\n    //Construct list for sorting purposes (using legacy Comparators)\n    final List<ImmutablePair<OperatorProfile, Integer>> opList = new ArrayList<>();<fim_middle>// class below is data class and blob\n"}