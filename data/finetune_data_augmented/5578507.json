{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.servicecomb.config;\nimport static org.apache.servicecomb.foundation.common.base.ServiceCombConstants.CONFIG_CSE_PREFIX;\nimport static org.apache.servicecomb.foundation.common.base.ServiceCombConstants.CONFIG_KEY_SPLITER;\nimport static org.apache.servicecomb.foundation.common.base.ServiceCombConstants.CONFIG_SERVICECOMB_PREFIX;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.commons.configuration.AbstractConfiguration;\nimport org.apache.commons.configuration.Configuration;\nimport org.apache.commons.configuration.EnvironmentConfiguration;\nimport org.apache.commons.configuration.SystemConfiguration;\nimport org.apache.servicecomb.config.archaius.scheduler.NeverStartPollingScheduler;\nimport org.apache.servicecomb.config.archaius.sources.ConfigModel;\nimport org.apache.servicecomb.config.archaius.sources.MicroserviceConfigLoader;\nimport org.apache.servicecomb.config.archaius.sources.MicroserviceConfigurationSource;\nimport org.apache.servicecomb.config.spi.ConfigCenterConfigurationSource;\nimport org.apache.servicecomb.foundation.common.utils.SPIServiceUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport com.netflix.config.ConcurrentCompositeConfiguration;\nimport com.netflix.config.ConcurrentMapConfiguration;\nimport com.netflix.config.ConfigurationManager;\nimport com.netflix.config.DynamicConfiguration;\nimport com.netflix.config.DynamicPropertyFactory;\nimport com.netflix.config.DynamicWatchedConfiguration;\nimport com.netflix.config.WatchedUpdateListener;\nimport com.netflix.config.WatchedUpdateResult;\npublic final class ConfigUtil {\n  private static final Logger LOGGER = LoggerFactory.getLogger(ConfigUtil.class);\n  private static final String MICROSERVICE_CONFIG_LOADER_KEY = \"cse-microservice-config-loader\";\n  private static Map<String, Object> localConfig = new HashMap<>();\n  /**\n   * <p>The configurations not read by ServiceComb.</p>\n   * <p>\n   * For example, this map can store the configurations read by SpringBoot from application.properties,\n   * If users write the configurations of ServiceComb into application.yml instead of microservice.yaml,\n   * this can help {@link ConfigUtil} load config correctly.\n   * </p>\n   */\n  private static final Map<String, Map<String, Object>> EXTRA_CONFIG_MAP = new LinkedHashMap<>();\n  private ConfigUtil() {\n  }\n  public static void setConfigs(Map<String, Object> config) {\n    localConfig = config;\n  }\n  public static void addConfig(String key, Object value) {\n    localConfig.put(key, value);\n  }\n  public static Object getProperty(String key) {\n    Object config = DynamicPropertyFactory.getBackingConfigurationSource();\n    return getProperty(config, key);\n  }\n  public static Object getProperty(Object config, String key) {\n    if (null != config && Configuration.class.isInstance(config)) {\n      Configuration configuration = (Configuration) config;\n      return configuration.getProperty(key);\n    }\n    return null;\n  }\n  private static void setMicroserviceConfigLoader(Configuration config, MicroserviceConfigLoader loader) {\n    config.setProperty(MICROSERVICE_CONFIG_LOADER_KEY, loader);\n  }\n  public static MicroserviceConfigLoader getMicroserviceConfigLoader() {\n    return (MicroserviceConfigLoader) getProperty(MICROSERVICE_CONFIG_LOADER_KEY);\n  }\n  public static MicroserviceConfigLoader getMicroserviceConfigLoader(Configuration config) {\n    return (MicroserviceConfigLoader) getProperty(config, MICROSERVICE_CONFIG_LOADER_KEY);\n  }\n<fim_suffix>  public static ConcurrentCompositeConfiguration createLocalConfig() {\n    MicroserviceConfigLoader loader = new MicroserviceConfigLoader();\n    loader.loadAndSort();\n    if (localConfig.size() > 0) {\n      ConfigModel model = new ConfigModel();\n      model.setConfig(localConfig);\n      loader.getConfigModels().add(model);\n    }\n    LOGGER.info(\"create local config:\");\n    for (ConfigModel configModel : loader.getConfigModels()) {\n      LOGGER.info(\" {}.\", configModel.getUrl());\n    }\n    ConcurrentCompositeConfiguration config = ConfigUtil.createLocalConfig(loader.getConfigModels());\n    ConfigUtil.setMicroserviceConfigLoader(config, loader);\n    return config;\n  }\n  public static ConcurrentCompositeConfiguration createLocalConfig(List<ConfigModel> configModelList) {\n    ConcurrentCompositeConfiguration config = new ConcurrentCompositeConfiguration();\n    duplicateCseConfigToServicecomb(config,\n        new ConcurrentMapConfiguration(new SystemConfiguration()),\n        \"configFromSystem\");\n    duplicateCseConfigToServicecomb(config,\n        convertEnvVariable(new ConcurrentMapConfiguration(new EnvironmentConfiguration())),\n        \"configFromEnvironment\");\n    // If there is extra configurations, add it into config.\n    EXTRA_CONFIG_MAP.entrySet()\n        .stream()\n        .filter(mapEntry -> !mapEntry.getValue().isEmpty())\n        .forEachOrdered(configMapEntry -> duplicateCseConfigToServicecomb(config,\n            new ConcurrentMapConfiguration(configMapEntry.getValue()),\n            configMapEntry.getKey()));\n    // we have already copy the cse config to the serviceComb config when we load the config from local yaml files\n    // hence, we do not need duplicate copy it.\n    config.addConfiguration(new DynamicConfiguration(\n            new MicroserviceConfigurationSource(configModelList), new NeverStartPollingScheduler()),\n        \"configFromYamlFile\");\n    duplicateCseConfigToServicecombAtFront(config,\n        new ConcurrentMapConfiguration(ConfigMapping.getConvertedMap(config)),\n        \"configFromMapping\");\n    return config;\n  }\n  public static AbstractConfiguration convertEnvVariable(AbstractConfiguration source) {\n    Iterator<String> keys = source.getKeys();\n    while (keys.hasNext()) {\n      String key = keys.next();\n      String[] separatedKey = key.split(CONFIG_KEY_SPLITER);\n      if (separatedKey.length == 1) {\n        continue;\n      }\n      String newKey = String.join(\".\", separatedKey);\n      source.addProperty(newKey, source.getProperty(key));\n    }\n    return source;\n  }\n  //inject a copy of servicecomb.xxx for cse.xxx\n  private static void duplicateCseConfigToServicecomb(AbstractConfiguration source) {\n    Iterator<String> keys = source.getKeys();\n    while (keys.hasNext()) {\n      String key = keys.next();\n      if (!key.startsWith(CONFIG_CSE_PREFIX)) {\n        continue;\n      }\n      String servicecombKey = CONFIG_SERVICECOMB_PREFIX + key.substring(key.indexOf(\".\") + 1);\n      if (!source.containsKey(servicecombKey)) {\n        source.addProperty(servicecombKey, source.getProperty(key));\n      } else {\n        LOGGER\n            .warn(\n                \"Key {} with an ambiguous item {} exists, it's recommended to use only one of them.\",\n                key, servicecombKey);\n      }\n    }\n  }\n  private static void duplicateCseConfigToServicecomb(ConcurrentCompositeConfiguration compositeConfiguration,\n      AbstractConfiguration source,\n      String sourceName) {\n    duplicateCseConfigToServicecomb(source);\n    compositeConfiguration.addConfiguration(source, sourceName);\n  }\n  private static void duplicateCseConfigToServicecombAtFront(ConcurrentCompositeConfiguration compositeConfiguration,\n      AbstractConfiguration source,\n      String sourceName) {\n    duplicateCseConfigToServicecomb(source);\n    compositeConfiguration.addConfigurationAtFront(source, sourceName);\n  }\n  private static ConfigCenterConfigurationSource createConfigCenterConfigurationSource(\n      Configuration localConfiguration) {\n    ConfigCenterConfigurationSource configCenterConfigurationSource =\n        SPIServiceUtils.getTargetService(ConfigCenterConfigurationSource.class);\n    if (null == configCenterConfigurationSource) {\n      LOGGER.info(\n          \"config center SPI service can not find, skip to load configuration from config center\");\n      return null;\n    }\n    if (!configCenterConfigurationSource.isValidSource(localConfiguration)) {\n      LOGGER.warn(\"Config Source serverUri is not correctly configured.\");\n      return null;\n    }\n    return configCenterConfigurationSource;\n  }\n  private static void createDynamicWatchedConfiguration(\n      ConcurrentCompositeConfiguration localConfiguration,\n      ConfigCenterConfigurationSource configCenterConfigurationSource) {<fim_middle>// function below has no smell\n"}