{"text": "<fim_prefix>         */\n        private void setText() {\n            int mappingIndex = -1;\n            int wordCharLength = 0;\n            for (int wordIndex = firstIndex; wordIndex <= lastIndex; wordIndex++) {\n                mapping = getGlyphMapping(wordIndex);\n                textArea.updateLevel(mapping.level);\n                if (mapping.isSpace) {\n                    addSpaces();\n                } else {\n                    // mapping stores information about a word fragment\n                    if (mappingIndex == -1) {\n                        // here starts a new word\n                        mappingIndex = wordIndex;\n                        wordCharLength = 0;\n                    }\n                    wordCharLength += mapping.getWordLength();\n                    if (isWordEnd(wordIndex)) {\n                        addWord(mappingIndex, wordIndex, wordCharLength);\n                        mappingIndex = -1;\n                    }\n                }\n            }\n        }\n        private boolean isWordEnd(int mappingIndex) {\n            return mappingIndex == lastIndex || getGlyphMapping(mappingIndex + 1).isSpace;\n        }\n        /**\n         * Add word with fragments from STARTINDEX to ENDINDEX, where\n         * total length of (possibly mapped) word is CHARLENGTH.\n         * A word is composed from one or more word fragments, where each\n         * fragment corresponds to distinct instance in a sequence of\n         * area info instances starting at STARTINDEX continuing through (and\n         * including)  ENDINDEX.\n         * @param startIndex index of first area info of word to add\n         * @param endIndex index of last area info of word to add\n         * @param wordLength number of (mapped) characters in word\n         */\n        private void addWord(int startIndex, int endIndex, int wordLength) {\n            int blockProgressionOffset = 0;\n            boolean gposAdjusted = false;\n            if (isHyphenated(endIndex)) {\n                // TODO may be problematic in some I18N contexts [GA]\n                wordLength++;\n            }\n            initWord(wordLength);\n            // iterate over word's fragments, adding word chars (with bidi\n            // levels), letter space adjustments, and glyph position adjustments\n            for (int i = startIndex; i <= endIndex; i++) {\n                GlyphMapping wordMapping = getGlyphMapping(i);\n                addWordChars(wordMapping);\n                addLetterAdjust(wordMapping);\n                if (addGlyphPositionAdjustments(wordMapping)) {\n                    gposAdjusted = true;\n                }\n            }\n            if (isHyphenated(endIndex)) {\n                // TODO may be problematic in some I18N contexts [GA]\n                addHyphenationChar();\n            }\n            if (!gposAdjusted) {\n                gposAdjustments = null;\n            }\n            textArea.addWord(wordChars.toString(), wordIPD, letterSpaceAdjust,\n                             getNonEmptyLevels(), gposAdjustments, blockProgressionOffset);\n        }\n        private int[] getNonEmptyLevels() {\n            if (wordLevels != null) {\n                assert wordLevelsIndex <= wordLevels.length;\n                boolean empty = true;\n                for (int i = 0, n = wordLevelsIndex; i < n; i++) {\n                    if (wordLevels [ i ] >= 0) {\n                        empty = false;\n                        break;\n                    }\n                }\n                return empty ? null : wordLevels;\n            } else {\n                return null;\n            }\n        }\n        /**\n         * Fully allocate word character buffer, letter space adjustments\n         * array, bidi levels array, and glyph position adjustments array.\n         * based on full word length, including all (possibly mapped) fragments.\n         * @param wordLength length of word including all (possibly mapped) fragments\n         */\n        private void initWord(int wordLength) {\n            wordChars = new StringBuffer(wordLength);\n            letterSpaceAdjust = new int[wordLength];\n            letterSpaceAdjustIndex = 0;\n            wordLevels = new int[wordLength];\n            wordLevelsIndex = 0;\n            Arrays.fill(wordLevels, -1);\n            gposAdjustments = new int[wordLength][4];\n            gposAdjustmentsIndex = 0;\n            wordIPD = 0;\n        }\n        private boolean isHyphenated(int endIndex) {\n            return isLastArea && endIndex == lastIndex && mapping.isHyphenated;\n        }\n        private void addHyphenationChar() {\n            wordChars.append(foText.getCommonHyphenation().getHyphChar(font));\n            // [TBD] expand bidi word levels, letter space adjusts, gpos adjusts\n            // [TBD] [GA] problematic in bidi context... what is level of hyphen?\n            textArea.setHyphenated();\n        }\n        /**\n         * Given a word area info associated with a word fragment,\n         * (1) concatenate (possibly mapped) word characters to word character buffer;\n         * (2) concatenante (possibly mapped) word bidi levels to levels buffer;\n         * (3) update word's IPD with optimal IPD of fragment.\n         * @param wordMapping fragment info\n         */\n        private void addWordChars(GlyphMapping wordMapping) {\n            int s = wordMapping.startIndex;\n            int e = wordMapping.endIndex;\n            if (wordMapping.mapping != null) {\n                wordChars.append(wordMapping.mapping);\n                addWordLevels(getMappingBidiLevels(wordMapping));\n            } else {\n                for (int i = s; i < e; i++) {\n                    wordChars.append(foText.charAt(i));\n                }\n                addWordLevels(foText.getBidiLevels(s, e));\n            }\n            wordIPD += wordMapping.areaIPD.getOpt();\n        }\n        /**\n         * Obtain bidirectional levels of mapping of characters over specific interval.\n         * @param start index in character buffer\n         * @param end index in character buffer\n         * @return a (possibly empty) array of bidi levels or null\n         * in case no bidi levels have been assigned\n         */\n        private int[] getMappingBidiLevels(GlyphMapping mapping) {\n            if (mapping.mapping != null) {\n                int nc = mapping.endIndex - mapping.startIndex;\n                int nm = mapping.mapping.length();\n                int[] la = foText.getBidiLevels(mapping.startIndex, mapping.endIndex);\n                if (la == null) {\n                    return null;\n                } else if (nm == nc) { // mapping is same length as mapped range\n                    return la;\n                } else if (nm > nc) { // mapping is longer than mapped range\n                    int[] ma = new int[nm];\n                    System.arraycopy(la, 0, ma, 0, la.length);\n                    for (int i = la.length, n = ma.length, l = (i > 0) ? la[i - 1] : 0; i < n; i++) {\n                        ma[i] = l;\n                    }\n                    return ma;\n                } else { // mapping is shorter than mapped range\n                    int[] ma = new int[nm];\n                    System.arraycopy(la, 0, ma, 0, ma.length);\n                    return ma;\n                }\n            } else {\n                return foText.getBidiLevels(mapping.startIndex, mapping.endIndex);\n            }\n        }\n        /**\n         * Given a (possibly null) bidi levels array associated with a word fragment,\n         * concatenante (possibly mapped) word bidi levels to levels buffer.\n         * @param levels bidi levels array or null\n         */\n        private void addWordLevels(int[] levels) {\n            int numLevels = (levels != null) ? levels.length : 0;\n            if (numLevels > 0) {\n                int need = wordLevelsIndex + numLevels;\n                if (need <= wordLevels.length) {\n                    System.arraycopy(levels, 0, wordLevels, wordLevelsIndex, numLevels);\n                } else {\n                    throw new IllegalStateException(\n                        \"word levels array too short: expect at least \"\n                          + need + \" entries, but has only \" + wordLevels.length + \" entries\");\n                }\n            }\n            wordLevelsIndex += numLevels;\n        }\n        /**\n         * Given a word area info associated with a word fragment,\n         * concatenate letter space adjustments for each (possibly mapped) character.\n         * @param wordMapping fragment info\n         */\n<fim_suffix>        private void addLetterAdjust(GlyphMapping wordMapping) {\n            int letterSpaceCount = wordMapping.letterSpaceCount;\n            int wordLength = wordMapping.getWordLength();\n            int taAdjust = textArea.getTextLetterSpaceAdjust();\n            for (int i = 0, n = wordLength; i < n; i++) {\n                int j = letterSpaceAdjustIndex + i;\n                if (j > 0) {\n                    int k = wordMapping.startIndex + i;\n                    MinOptMax adj = (k < letterSpaceAdjustArray.length)\n                        ? letterSpaceAdjustArray [ k ] : null;\n                    letterSpaceAdjust [ j ] = (adj == null) ? 0 : adj.getOpt();\n                }\n                if (letterSpaceCount > 0) {\n                    letterSpaceAdjust [ j ] += taAdjust;\n                    letterSpaceCount--;\n                }\n            }\n            letterSpaceAdjustIndex += wordLength;\n        }<fim_middle>// function below has no smell\n"}