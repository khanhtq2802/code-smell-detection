{"text": "<fim_prefix>   this work for additional information regarding copyright ownership.\n   The ASF licenses this file to you under the Apache License, Version 2.0\n   (the \"License\"); you may not use this file except in compliance with\n   the License.  You may obtain a copy of the License at\n      http://www.apache.org/licenses/LICENSE-2.0\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n */\npackage org.apache.derby.impl.sql.execute;\nimport org.apache.derby.iapi.sql.execute.ConstantAction;\nimport org.apache.derby.iapi.sql.dictionary.DataDescriptorGenerator;\nimport org.apache.derby.iapi.sql.dictionary.DataDictionary;\nimport org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;\nimport org.apache.derby.iapi.sql.dictionary.ColumnDescriptorList;\nimport org.apache.derby.iapi.sql.dictionary.SchemaDescriptor;\nimport org.apache.derby.iapi.sql.dictionary.TableDescriptor;\nimport org.apache.derby.iapi.sql.dictionary.ViewDescriptor;\nimport org.apache.derby.iapi.sql.depend.DependencyManager;\nimport org.apache.derby.iapi.store.access.TransactionController;\nimport org.apache.derby.iapi.sql.conn.LanguageConnectionContext;\nimport org.apache.derby.iapi.sql.depend.Provider;\nimport org.apache.derby.iapi.sql.depend.ProviderInfo;\nimport org.apache.derby.shared.common.reference.SQLState;\nimport org.apache.derby.iapi.sql.Activation;\nimport org.apache.derby.shared.common.error.StandardException;\nimport org.apache.derby.shared.common.sanity.SanityManager;\nimport org.apache.derby.catalog.UUID;\n/**\n *\tThis class  describes actions that are ALWAYS performed for a\n *\tCREATE VIEW Statement at Execution time.\n *  A view is represented as:\n *  <UL>\n *  <LI> TableDescriptor with the name of the view and type VIEW_TYPE\n *  <LI> Set of ColumnDescriptor's for the column names and types\n *  <LI> ViewDescriptor describing the SQL query that makes up the view.\n *  </UL>\n *  Dependencies are created as:\n *  <UL>\n *  <LI> ViewDescriptor depends on the Providers that its compiled\n *  query depends on.\n *  <LI> ViewDescriptor depends on the privileges required to execute the view.\n *  </UL>\n *  Note there are no dependencies created between the ViewDescriptor, TableDecriptor\n *  and the ColumnDescriptor's.\n *\n */\n<fim_suffix>class CreateViewConstantAction extends DDLConstantAction\n{\n\tprivate final String\t\t\t\t\ttableName;\n\tprivate final String\t\t\t\t\tschemaName;\n\tprivate final String\t\t\t\t\tviewText;\n\tprivate final int\t\t\t\t\t\ttableType;\n\tprivate final int\t\t\t\t\t\tcheckOption;\n\tprivate final ColumnInfo[]\t\t\tcolumnInfo;\n\tprivate final ProviderInfo[]\t\t\tproviderInfo;\n\tprivate final UUID\t\t\t\t\tcompSchemaId;\n\t// CONSTRUCTORS\n\t/**\n\t *\tMake the ConstantAction for a CREATE VIEW statement.\n\t *\n\t *  @param schemaName\t\t\tname for the schema that view lives in.\n\t *  @param tableName\tName of view.\n\t *  @param tableType\tType of table (ie. TableDescriptor.VIEW_TYPE).\n\t *\t@param viewText\t\tText of query expression for view definition\n\t *  @param checkOption\tCheck option type\n\t *  @param columnInfo\tInformation on all the columns in the table.\n\t *  @param providerInfo Information on all the Providers\n\t *  @param compSchemaId \tCompilation Schema Id\n\t */\n\tCreateViewConstantAction(\n\t\t\t\t\t\t\t\tString\t\t\tschemaName,\n\t\t\t\t\t\t\t\tString\t\t\ttableName,\n\t\t\t\t\t\t\t\tint\t\t\t\ttableType,\n\t\t\t\t\t\t\t\tString\t\t\tviewText,\n\t\t\t\t\t\t\t\tint\t\t\t\tcheckOption,\n\t\t\t\t\t\t\t\tColumnInfo[]\tcolumnInfo,\n\t\t\t\t\t\t\t\tProviderInfo[]  providerInfo,\n\t\t\t\t\t\t\t\tUUID\t\t\tcompSchemaId)\n\t{\n\t\tthis.schemaName = schemaName;\n\t\tthis.tableName = tableName;\n\t\tthis.tableType = tableType;\n\t\tthis.viewText = viewText;\n\t\tthis.checkOption = checkOption;\n\t\tthis.columnInfo = columnInfo;\n\t\tthis.providerInfo = providerInfo;\n\t\tthis.compSchemaId = compSchemaId;\n\t\tif (SanityManager.DEBUG)\n\t\t{\n\t\t\tSanityManager.ASSERT(schemaName != null, \"Schema name is null\");\n\t\t}\n\t}\n\t// OBJECT METHODS\n\tpublic\tString\ttoString()\n\t{\n\t\treturn constructToString(\"CREATE VIEW \", tableName);\n\t}\n\t// INTERFACE METHODS\n\t/**\n\t *\tThis is the guts of the Execution-time logic for CREATE VIEW.\n\t *\n\t *\t@see ConstantAction#executeConstantAction\n\t *\n\t * @exception StandardException\t\tThrown on failure\n\t */\n\tpublic void\texecuteConstantAction( Activation activation )\n\t\t\t\t\t\tthrows StandardException\n\t{\n\t\tTableDescriptor \t\t\ttd;\n\t\tUUID \t\t\t\t\t\ttoid;\n\t\tColumnDescriptor\t\t\tcolumnDescriptor;\n\t\tViewDescriptor\t\t\t\tvd;\n\t\tLanguageConnectionContext lcc = activation.getLanguageConnectionContext();\n\t\tDataDictionary dd = lcc.getDataDictionary();\n\t\tDependencyManager dm = dd.getDependencyManager();\n\t\tTransactionController tc = lcc.getTransactionExecute();\n\t\t/*\n\t\t** Inform the data dictionary that we are about to write to it.\n\t\t** There are several calls to data dictionary \"get\" methods here\n\t\t** that might be done in \"read\" mode in the data dictionary, but\n\t\t** it seemed safer to do this whole operation in \"write\" mode.\n\t\t**\n\t\t** We tell the data dictionary we're done writing at the end of\n\t\t** the transaction.\n\t\t*/\n\t\tdd.startWriting(lcc);\n\t\tSchemaDescriptor sd = DDLConstantAction.getSchemaDescriptorForCreate(dd, activation, schemaName);\n\t\t/* Create a new table descriptor.\n\t\t * (Pass in row locking, even though meaningless for views.)\n\t\t */\n\t\tDataDescriptorGenerator ddg = dd.getDataDescriptorGenerator();\n\t\ttd = ddg.newTableDescriptor(tableName,\n\t\t\t\t\t\t\t\t\tsd,\n\t\t\t\t\t\t\t\t\ttableType,\n\t\t\t\t\t\t\t\t\tTableDescriptor.ROW_LOCK_GRANULARITY);\n\t\tdd.addDescriptor(td, sd, DataDictionary.SYSTABLES_CATALOG_NUM, false, tc);\n\t\ttoid = td.getUUID();\n\t\t// for each column, stuff system.column\n\t\tColumnDescriptor[] cdlArray = new ColumnDescriptor[columnInfo.length];\n\t\tint index = 1;\n\t\tfor (int ix = 0; ix < columnInfo.length; ix++)\n\t\t{\n\t\t\tcolumnDescriptor = new ColumnDescriptor(\n\t\t\t\t                   columnInfo[ix].name,\n\t\t\t\t\t\t\t\t   index++,\n\t\t\t\t\t\t\t\t   columnInfo[ix].dataType,\n\t\t\t\t\t\t\t\t   columnInfo[ix].defaultValue,\n\t\t\t\t\t\t\t\t   columnInfo[ix].defaultInfo,\n\t\t\t\t\t\t\t\t   td,\n\t\t\t\t\t\t\t\t   (UUID) null,\n\t\t\t\t\t\t\t\t   columnInfo[ix].autoincStart,\n\t\t\t\t\t\t\t\t   columnInfo[ix].autoincInc,\n\t\t\t\t\t\t\t\t   columnInfo[ix].autoincCycle\n\t\t\t\t\t\t\t   );\n\t\t\tcdlArray[ix] = columnDescriptor;\n\t\t}\n\t\tdd.addDescriptorArray(cdlArray, td,\n\t\t\t\t\t\t\t  DataDictionary.SYSCOLUMNS_CATALOG_NUM, false, tc);\n\t\t// add columns to the column descriptor list.\n\t\tColumnDescriptorList cdl = td.getColumnDescriptorList();\n\t\tfor (int i = 0; i < cdlArray.length; i++)\n\t\t\tcdl.add(cdlArray[i]);\n\t\t/* Get and add a view descriptor */\n\t\tvd = ddg.newViewDescriptor(toid, tableName, viewText, \n\t\t\t\t\t\t\t\t\tcheckOption, \n\t\t\t\t\t\t\t\t\t(compSchemaId == null) ?\n\t\t\t\t\t\t\t\t\t\tlcc.getDefaultSchema().getUUID() :\n\t\t\t\t\t\t\t\t\t\tcompSchemaId);\n\t\tfor (int ix = 0; ix < providerInfo.length; ix++)\n\t\t{\n\t\t\t/* We should always be able to find the Provider */\n\t\t\t\tProvider provider = (Provider) providerInfo[ix].\n\t\t\t\t\t\t\t\t\t\tgetDependableFinder().\n\t\t\t\t\t\t\t\t\t\t\tgetDependable(dd,\n\t\t\t\t\t\t\t\t\t\t\t\tproviderInfo[ix].getObjectId());\n\t\t\t\tdm.addDependency(vd, provider, lcc.getContextManager());\n\t\t}\n\t\t//store view's dependency on various privileges in the dependeny system\n\t\tstoreViewTriggerDependenciesOnPrivileges(activation, vd);\n\t\tdd.addDescriptor(vd, sd, DataDictionary.SYSVIEWS_CATALOG_NUM, true, tc);\n\t}\n}<fim_middle>// class below has no smell\n"}