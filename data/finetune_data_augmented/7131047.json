{"text": "<fim_prefix>/*\n   Copyright (c) 2012 LinkedIn Corp.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npackage com.linkedin.restli.tools.idlgen;\n\n\nimport com.sun.javadoc.ClassDoc;\nimport com.sun.javadoc.MethodDoc;\nimport com.sun.javadoc.Parameter;\nimport com.sun.javadoc.RootDoc;\nimport com.sun.javadoc.Type;\nimport com.sun.tools.javadoc.Main;\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\n\nimport java.io.PrintWriter;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n\n/**\n * Custom Javadoc processor that merges documentation into the restspec.json. The embedded Javadoc\n * generator is basically a commandline tool wrapper and it runs in complete isolation from the rest\n * of the application. Due to the fact that the Javadoc tool instantiates RestLiDoclet, we cannot\n * cleanly integrate the output into the {@link RestLiResourceModelExporter} tool. Thus, we're just\n * dumping the docs into a static Map which can be accessed by {@link RestLiResourceModelExporter}.\n *\n * This class supports multiple runs of Javadoc Doclet API {@link Main#execute(String[])}.\n * Each run will be assigned an unique \"Doclet ID\", returned by\n * {@link #generateDoclet(String, java.io.PrintWriter, java.io.PrintWriter, java.io.PrintWriter, String[])}.\n * The Doclet ID should be subsequently used to initialize {@link DocletDocsProvider}.\n *\n * This class is thread-safe. However, #generateJavadoc() will be synchronized.\n *\n * @author dellamag\n * @see {@link Main#execute(String, java.io.PrintWriter, java.io.PrintWriter, java.io.PrintWriter, String, String[])}\n */\npublic class RestLiDoclet\n{\n  private static RestLiDoclet _currentDocLet = null;\n\n  private final DocInfo _docInfo;\n\n  /**\n   * Generate Javadoc and return associated Doclet ID.\n   * This method is synchronized.\n   *\n   * @param programName Name of the program (for error messages).\n   * @param errWriter PrintWriter to receive error messages.\n   * @param warnWriter PrintWriter to receive warning messages.\n   * @param noticeWriter PrintWriter to receive notice messages.\n   * @param args The command line parameters.\n   * @return an unique doclet ID which represent the subsequent Main#execute() run.\n   * @throws IllegalStateException if the generated doclet ID is already used. Try again.\n   * @throws IllegalArgumentException if Javadoc fails to generate docs.\n   */\n  public static synchronized RestLiDoclet generateDoclet(String programName,\n                                                         PrintWriter errWriter,\n                                                         PrintWriter warnWriter,\n                                                         PrintWriter noticeWriter,\n                                                         String[] args)\n  {\n    final int javadocRetCode = Main.execute(programName, errWriter, warnWriter, noticeWriter, RestLiDoclet.class.getName(), args);\n    if (javadocRetCode != 0)\n    {\n      throw new IllegalArgumentException(\"Javadoc failed with return code \" + javadocRetCode);\n    }\n\n    return _currentDocLet;\n  }\n\n  /**\n   * Entry point for Javadoc Doclet.\n   *\n   * @param root {@link RootDoc} passed in by Javadoc\n   * @return is successful or not\n   */\n  public static boolean start(RootDoc root)\n  {\n    final DocInfo docInfo = new DocInfo();\n\n    for (ClassDoc classDoc : root.classes())\n    {\n      docInfo.setClassDoc(classDoc.qualifiedName(), classDoc);\n\n      for (MethodDoc methodDoc : classDoc.methods())\n      {\n        docInfo.setMethodDoc(MethodIdentity.create(methodDoc), methodDoc);\n      }\n    }\n\n    _currentDocLet = new RestLiDoclet(docInfo);\n\n    return true;\n  }\n\n  private RestLiDoclet(DocInfo docInfo)\n  {\n    _docInfo = docInfo;\n  }\n\n  /**\n   * Query Javadoc {@link ClassDoc} for the specified resource class.\n   *\n   * @param resourceClass resource class to be queried\n   * @return corresponding {@link ClassDoc}\n   */\n  public ClassDoc getClassDoc(Class<?> resourceClass)\n  {\n    return _docInfo.getClassDoc(resourceClass.getCanonicalName());\n  }\n\n  /**\n   * Query Javadoc {@link MethodDoc} for the specified Java method.\n   *\n   * @param method Java method to be queried\n   * @return corresponding {@link MethodDoc}\n   */\n  public MethodDoc getMethodDoc(Method method)\n  {\n    final MethodIdentity methodId = MethodIdentity.create(method);\n    return _docInfo.getMethodDoc(methodId);\n  }\n\n  private static class DocInfo\n  {\n    public ClassDoc getClassDoc(String className)\n    {\n      return _classNameToClassDoc.get(className);\n    }\n\n    public MethodDoc getMethodDoc(MethodIdentity methodId)\n    {\n      return _methodIdToMethodDoc.get(methodId);\n    }\n\n    public void setClassDoc(String className, ClassDoc classDoc)\n    {\n      _classNameToClassDoc.put(className, classDoc);\n    }\n\n    public void setMethodDoc(MethodIdentity methodId, MethodDoc methodDoc)\n    {\n      _methodIdToMethodDoc.put(methodId, methodDoc);\n    }\n\n    private final Map<String, ClassDoc> _classNameToClassDoc = new HashMap<String, ClassDoc>();\n    private final Map<MethodIdentity, MethodDoc> _methodIdToMethodDoc = new HashMap<MethodIdentity, MethodDoc>();\n  }\n\n  private static class MethodIdentity\n  {\n    public static MethodIdentity create(Method method)\n    {\n      final List<String> parameterTypeNames = new ArrayList<String>();\n\n      // type parameters are not included in identity because of differences between reflection and Doclet:\n      // e.g. for Collection<Void>:\n      //   reflection Type.toString() -> Collection<Void>\n      //   Doclet Type.toString() -> Collection\n      for (Class<?> paramClass: method.getParameterTypes())\n      {\n        parameterTypeNames.add(paramClass.getCanonicalName());\n      }\n\n      return new MethodIdentity(method.getDeclaringClass().getName() + \".\" + method.getName(), parameterTypeNames);\n    }\n\n    public static MethodIdentity create(MethodDoc method)\n    {\n      final List<String> parameterTypeNames = new ArrayList<String>();\n      for (Parameter param: method.parameters())\n      {\n        Type type = param.type();\n        parameterTypeNames.add(type.qualifiedTypeName() + type.dimension());\n      }\n\n      return new MethodIdentity(method.qualifiedName(), parameterTypeNames);\n    }\n\n    private MethodIdentity(String methodQualifiedName, List<String> parameterTypeNames)\n    {\n      _methodQualifiedName = methodQualifiedName;\n      _parameterTypeNames = parameterTypeNames;\n    }\n\n    @Override\n    public int hashCode()\n    {\n      return new HashCodeBuilder(17, 29).\n          append(_methodQualifiedName).\n          append(_parameterTypeNames).\n          toHashCode();\n    }\n\n<fim_suffix>    @Override\n    public boolean equals(Object obj)\n    {\n      if (this == obj)\n      {\n        return true;\n      }\n\n      if (obj == null)\n      {\n        return false;\n      }\n\n      if (getClass() != obj.getClass())\n      {\n        return false;\n      }\n\n      final MethodIdentity other = (MethodIdentity) obj;\n      return new EqualsBuilder().\n          append(_methodQualifiedName, other._methodQualifiedName).\n          append(_parameterTypeNames, other._parameterTypeNames).\n          isEquals();\n    }\n\n    private final String _methodQualifiedName;\n    private final List<String> _parameterTypeNames;\n  }\n}<fim_middle>// function below has no smell\n"}