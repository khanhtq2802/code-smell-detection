{"text": "<fim_prefix>     *\n     * # task runs\n     *\n     * # task end callback run, if supplied\n     * # end time set\n     * # thread cleared, ThreadLocal getCurrentTask set\n     * # Task.notifyAll()\n     * # Task.get() (result.get()) available, Task.isDone is true\n     *\n     * Few _consumers_ should care, but internally we rely on this so that, for example, status is displayed correctly.\n     * Tests should catch most things, but be careful if you change any of the above semantics.\n     */\n    protected long queuedTimeUtc = -1;\n    protected long submitTimeUtc = -1;\n    protected long startTimeUtc = -1;\n    protected long endTimeUtc = -1;\n    protected Maybe<Task<?>> submittedByTask;\n    protected volatile Thread thread = null;\n    protected volatile boolean cancelled = false;\n    /** normally a {@link ListenableFuture}, except for scheduled tasks when it may be a {@link ScheduledFuture} */\n    protected volatile Future<T> internalFuture = null;\n    @Override\n    public synchronized void initInternalFuture(ListenableFuture<T> result) {\n        if (this.internalFuture != null) \n            throw new IllegalStateException(\"task \"+this+\" is being given a result twice\");\n        this.internalFuture = result;\n        notifyAll();\n    }\n    // metadata accessors ------------\n    @Override\n    public Set<Object> getTags() { return Collections.unmodifiableSet(new LinkedHashSet<Object>(tags)); }\n    /** if the job is queued for submission (e.g. by another task) it can indicate that fact (and time) here;\n     * note tasks can (and often are) submitted without any queueing, in which case this value may be -1 */\n    @Override\n    public long getQueuedTimeUtc() { return queuedTimeUtc; }\n    @Override\n    public long getSubmitTimeUtc() { return submitTimeUtc; }\n    @Override\n    public long getStartTimeUtc() { return startTimeUtc; }\n    @Override\n    public long getEndTimeUtc() { return endTimeUtc; }\n    @Override\n    public Future<T> getInternalFuture() { return internalFuture; }\n    @Override\n    public Task<?> getSubmittedByTask() { \n        if (submittedByTask==null) return null;\n        return submittedByTask.orNull(); \n    }\n    /** the thread where the task is running, if it is running */\n    @Override\n    public Thread getThread() { return thread; }\n    // basic fields --------------------\n    @Override\n    public boolean isQueued() {\n        return (queuedTimeUtc >= 0);\n    }\n    @Override\n    public boolean isQueuedOrSubmitted() {\n        return isQueued() || isSubmitted();\n    }\n    @Override\n    public boolean isQueuedAndNotSubmitted() {\n        return isQueued() && (!isSubmitted());\n    }\n    @Override\n    public boolean isSubmitted() {\n        return submitTimeUtc >= 0;\n    }\n    @Override\n    public boolean isBegun() {\n        return startTimeUtc >= 0;\n    }\n    /** marks the task as queued for execution */\n    @Override\n    public void markQueued() {\n        if (queuedTimeUtc<0)\n            queuedTimeUtc = System.currentTimeMillis();\n    }\n    @Override\n    public final synchronized boolean cancel() { return cancel(true); }\n    /** doesn't resume it, just means if something was cancelled but not submitted it could now be submitted;\n     * probably going to be removed and perhaps some mechanism for running again made available\n     * @since 0.7.0  */\n    @Beta\n    public synchronized boolean uncancel() {\n        boolean wasCancelled = cancelled;\n        cancelled = false; \n        return wasCancelled;\n    }\n    @Override\n    public final synchronized boolean cancel(boolean mayInterruptIfRunning) {\n        // semantics changed in 2016-01, previously \"true\" was INTERRUPT_TASK_BUT_NOT_SUBMITTED_TASKS\n        return cancel(mayInterruptIfRunning ? TaskCancellationMode.INTERRUPT_TASK_AND_DEPENDENT_SUBMITTED_TASKS\n            : TaskCancellationMode.DO_NOT_INTERRUPT);\n    }\n    @Override @Beta\n    public synchronized boolean cancel(TaskCancellationMode mode) {\n        if (isDone()) return false;\n        if (log.isTraceEnabled()) {\n            log.trace(\"BT cancelling \"+this+\" mode \"+mode+\", from thread \"+Thread.currentThread());\n        }\n        cancelled = true;\n        doCancel(mode);\n        notifyAll();\n        return true;\n    }\n    @SuppressWarnings(\"deprecation\")\n    protected boolean doCancel(TaskCancellationMode mode) {\n        if (internalFuture!=null) { \n            if (internalFuture instanceof ListenableForwardingFuture) {\n                return ((ListenableForwardingFuture<?>)internalFuture).cancel(mode);\n            } else {\n                return internalFuture.cancel(mode.isAllowedToInterruptTask());\n            }\n        }\n        return true;\n    }\n    @Override\n    public boolean isCancelled() {\n        return cancelled || (internalFuture!=null && internalFuture.isCancelled());\n    }\n    @Override\n    public boolean isDone() {\n        // if endTime is set, result might not be completed yet, but it will be set very soon \n        // (the two values are set close in time, result right after the endTime;\n        // but callback hooks might not see the result yet)\n        return cancelled || (internalFuture!=null && internalFuture.isDone()) || endTimeUtc>0;\n    }\n    /**\n     * Returns true if the task has had an error.\n     *\n     * Only true if calling {@link #get()} will throw an exception when it completes (including cancel).\n     * Implementations may set this true before completion if they have that insight, or\n     * (the default) they may compute it lazily after completion (returning false before completion).\n     */\n    @Override\n    public boolean isError() {\n        if (!isDone()) return false;\n        if (isCancelled()) return true;\n        try {\n            get();\n            return false;\n        } catch (Throwable t) {\n            return true;\n        }\n    }\n    // future value --------------------\n    @Override\n    public T get() throws InterruptedException, ExecutionException {\n        try {\n            if (!isDone())\n                Tasks.setBlockingTask(this);\n            blockUntilStarted();\n            return internalFuture.get();\n        } finally {\n            Tasks.resetBlockingTask();\n        }\n    }\n    @Override\n    public T getUnchecked() {\n        try {\n            return get();\n        } catch (Exception e) {\n            throw Exceptions.propagate(e);\n        }\n    }\n    @Override\n    public synchronized void blockUntilStarted() {\n        blockUntilStarted(null);\n    }\n    @Override\n    public synchronized boolean blockUntilStarted(Duration timeout) {\n        Long endTime = timeout==null ? null : System.currentTimeMillis() + timeout.toMillisecondsRoundingUp();\n        while (true) {\n            if (cancelled) throw new CancellationException();\n            if (internalFuture==null)\n                try {\n                    if (timeout==null) {\n                        wait();\n                    } else {\n                        long remaining = endTime - System.currentTimeMillis();\n                        if (remaining>0)\n                            wait(remaining);\n                        else\n                            return false;\n                    }\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                    Throwables.propagate(e);\n                }\n            if (internalFuture!=null) return true;\n        }\n    }\n    @Override\n    public void blockUntilEnded() {\n        blockUntilEnded(null);\n    }\n    @Override\n    public boolean blockUntilEnded(Duration timeout) {\n        Long endTime = timeout==null ? null : System.currentTimeMillis() + timeout.toMillisecondsRoundingUp();\n        try { \n            boolean started = blockUntilStarted(timeout);\n            if (!started) return false;\n            if (timeout==null) {\n                internalFuture.get();\n            } else {\n                long remaining = endTime - System.currentTimeMillis();\n                if (remaining>0)\n                    internalFuture.get(remaining, TimeUnit.MILLISECONDS);\n            }\n            return isDone();\n        } catch (Throwable t) {\n            Exceptions.propagateIfFatal(t);\n            if (!(t instanceof TimeoutException) && log.isDebugEnabled())\n                log.debug(\"call from \"+Thread.currentThread()+\", blocking until '\"+this+\"' finishes, ended with error: \"+t);\n            return isDone(); \n        }\n    }\n    @Override\n    public T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {\n        return get(new Duration(timeout, unit));\n    }\n<fim_suffix>    @Override\n    public T get(Duration duration) throws InterruptedException, ExecutionException, TimeoutException {\n        long start = System.currentTimeMillis();\n        Long end  = duration==null ? null : start + duration.toMillisecondsRoundingUp();\n        while (end==null || end > System.currentTimeMillis()) {\n            if (cancelled) throw new CancellationException();\n            if (internalFuture == null) {\n                synchronized (this) {\n                    long remaining = end - System.currentTimeMillis();\n                    if (internalFuture==null && remaining>0)\n                        wait(remaining);\n                }\n            }\n            if (internalFuture != null) break;\n        }\n        Long remaining = end==null ? null : end -  System.currentTimeMillis();\n        if (isDone()) {\n            return internalFuture.get(1, TimeUnit.MILLISECONDS);\n        } else if (remaining == null) {\n            return internalFuture.get();\n        } else if (remaining > 0) {\n            return internalFuture.get(remaining, TimeUnit.MILLISECONDS);\n        } else {\n            throw new TimeoutException();\n        }\n    }<fim_middle>// function below is long method\n"}