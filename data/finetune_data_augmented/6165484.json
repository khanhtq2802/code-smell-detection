{"text": "<fim_prefix>  }\n  /**\n   * Returns the item's index in it's parent including root level items.\n   *\n   * @param item\n   * @return\n   */\n  public int indexOf(Node item) {\n    Node parent = getParent(item);\n    if (parent == null) {\n      return getRootItems().indexOf(item);\n    } else {\n      return getChildren(parent).indexOf(item);\n    }\n  }\n  /**\n   * Inserts the given models at the given index in the list of root nodes\n   *\n   * @param index\n   * @param rootNodes\n   */\n  public void insert(int index, List<Node> rootNodes) {\n    insert(roots, index, rootNodes);\n  }\n  /**\n   * Inserts the given model at the given index in the list of root nodes\n   *\n   * @param index\n   * @param root\n   */\n  public void insert(int index, Node root) {\n    insert(roots, index, root);\n  }\n  public void insert(Node node, int index, List<Node> children) {\n    insert(getWrapper(node), index, children);\n  }\n  public void insert(Node parent, int index, Node child) {\n    insert(getWrapper(parent), index, child);\n  }\n  /**\n   * Inserts the child models at the given position in the parent's list of visible children.\n   *\n   * @param parent\n   * @param index\n   * @param children\n   */\n  public void insert(NodeDescriptor parent, int index, List<Node> children) {\n    int initialCount = parent.getChildren().size();\n    parent.addChildren(index, wrap(children));\n    if (initialCount != parent.getChildren().size()) {\n      List<Node> addedChildren = new ArrayList<>();\n      List<NodeDescriptor> currentChildren = parent.getChildren();\n      if (isSorted()) {\n        int currentChildrenSize = currentChildren.size();\n        for (int i = 0; i < currentChildrenSize; i++) {\n          int childrenSize = children.size();\n          for (int j = 0; j < childrenSize; j++) {\n            Node currentData = currentChildren.get(i).getNode();\n            Node child = children.get(j);\n            if (child == currentData) {\n              addedChildren.add(child);\n              break;\n            }\n          }\n        }\n      } else {\n        for (NodeDescriptor currentChild : currentChildren) {\n          if (children.contains(currentChild.getNode())) {\n            addedChildren.add(currentChild.getNode());\n          }\n        }\n      }\n      if (addedChildren.size() != 0) {\n        fireEvent(new StoreAddEvent(index, addedChildren));\n      }\n    }\n  }\n  /**\n   * Inserts the child model at the given position in the parent's list of visible children\n   *\n   * @param parent\n   * @param index\n   * @param child\n   */\n  public void insert(NodeDescriptor parent, int index, Node child) {\n    int initialCount = parent.getChildren().size();\n    parent.addChild(index, wrap(child));\n    if (parent.getChildren().size() != initialCount) {\n      int addedIndex = -1;\n      if (isSorted()) {\n        List<NodeDescriptor> childrenModels = parent.getChildren();\n        for (int i = 0; i < childrenModels.size(); i++) {\n          if (childrenModels.get(i).getNode().equals(child)) {\n            addedIndex = i;\n            break;\n          }\n        }\n      } else {\n        addedIndex = index;\n      }\n      // if the change actually occurred, fire an event\n      fireEvent(new StoreAddEvent(addedIndex, child));\n    }\n  }\n  public boolean remove(Node node) {\n    NodeDescriptor nodeDescriptor = idToNodeMap.get(getKeyProvider().getKey(node));\n    if (nodeDescriptor != null) {\n      Node parent = getParent(node);\n      List<Node> children = getAllChildren(node);\n      int visibleIndex = nodeDescriptor.getParent().getChildren().indexOf(nodeDescriptor);\n      nodeDescriptor.getParent().remove(nodeDescriptor);\n      if (visibleIndex != -1) {\n        fireEvent(new StoreRemoveEvent(visibleIndex, node, parent, children));\n      } else {\n        List<NodeDescriptor> descriptors = new LinkedList<>();\n        descriptors.add(nodeDescriptor);\n        for (int i = 0; i < descriptors.size(); i++) {\n          nodeDescriptor = descriptors.get(i);\n          descriptors.addAll(nodeDescriptor.getChildren());\n          idToNodeMap.remove(getKeyProvider().getKey(nodeDescriptor.getNode()));\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n  public void removeChildren(Node parent) {\n    removeChildren(getWrapper(parent));\n  }\n  private void removeChildren(NodeDescriptor parent) {\n    if (parent.getChildren().size() != 0) {\n      List<NodeDescriptor> models = new LinkedList<>();\n      models.addAll(parent.getChildren());\n      parent.clear();\n      for (int i = 0; i < models.size(); i++) {\n        NodeDescriptor wrapper = models.get(i);\n        models.addAll(wrapper.getChildren());\n        List<Node> children = getAllChildren(wrapper.getNode());\n        idToNodeMap.remove(getKeyProvider().getKey(wrapper.getNode()));\n        if (wrapper.getParent() == parent) {\n          fireEvent(new StoreRemoveEvent(0, wrapper.getNode(), parent.getNode(), children));\n        }\n      }\n    }\n  }\n  public void replaceChildren(Node parent, List<Node> children) {\n    if (parent == null) {\n      roots.clear();\n      idToNodeMap.clear();\n      roots.addChildren(0, wrap(children));\n    } else {\n      NodeDescriptor parentNodeDescriptor = getWrapper(parent);\n      List<NodeDescriptor> models = new LinkedList<>();\n      models.addAll(parentNodeDescriptor.getChildren());\n      for (int i = 0; i < models.size(); i++) {\n        NodeDescriptor wrapper = models.get(i);\n        models.addAll(wrapper.getChildren());\n        idToNodeMap.remove(getKeyProvider().getKey(wrapper.getNode()));\n        remove(wrapper.getNode());\n      }\n      parentNodeDescriptor.clear();\n      parentNodeDescriptor.addChildren(0, wrap(children));\n    }\n    fireEvent(new StoreDataChangeEvent(parent));\n  }\n  private List<NodeDescriptor> findRemovedNodes(\n      NodeDescriptor parent, final List<Node> loadedChildren) {\n    List<NodeDescriptor> existed = parent.getChildren();\n    if (existed == null || existed.isEmpty()) {\n      return Collections.emptyList();\n    }\n    Iterable<NodeDescriptor> removedItems =\n        Iterables.filter(\n            existed,\n            new Predicate<NodeDescriptor>() {\n              @Override\n              public boolean apply(NodeDescriptor existedChild) {\n                return !loadedChildren.contains(existedChild.getNode());\n              }\n            });\n    return Lists.newArrayList(removedItems);\n  }\n  private List<Node> findNewNodes(NodeDescriptor parent, final List<Node> loadedChildren) {\n    final List<NodeDescriptor> existed = parent.getChildren();\n    if (existed == null || existed.isEmpty()) {\n      return loadedChildren;\n    }\n    Iterable<Node> newItems =\n        Iterables.filter(\n            loadedChildren,\n            new Predicate<Node>() {\n              @Override\n              public boolean apply(Node loadedChild) {\n                for (NodeDescriptor nodeDescriptor : existed) {\n                  if (nodeDescriptor.getNode().equals(loadedChild)) {\n                    return false;\n                  }\n                }\n                return true;\n              }\n            });\n    return Lists.newArrayList(newItems);\n  }\n  private List<NodeDescriptor> convertTreeNodesHelper(List<Node> children) {\n    List<NodeDescriptor> nodeDescriptors = new ArrayList<>();\n    if (children != null) {\n      for (Node child : children) {\n        NodeDescriptor nodeDescriptor = new NodeDescriptor(this, child);\n        idToNodeMap.put(keyProvider.getKey(child), nodeDescriptor);\n        nodeDescriptors.add(nodeDescriptor);\n      }\n    }\n    return nodeDescriptors;\n  }\n  protected Map<String, NodeDescriptor> getNodeMap() {\n    return idToNodeMap;\n  }\n  public Collection<NodeDescriptor> getStoredNodes() {\n    return idToNodeMap.values();\n  }\n  public Node getParent(Node child) {\n    final NodeDescriptor wrapper = getWrapper(child);\n    if (wrapper == null) {\n      return null;\n    }\n    NodeDescriptor nodeDescriptor = wrapper.getParent();\n    return (nodeDescriptor != null && !nodeDescriptor.isRoot()) ? nodeDescriptor.getNode() : null;\n  }\n  public void fireEvent(GwtEvent<?> event) {\n    if (handlerManager != null) {\n      handlerManager.fireEvent(event);\n    }\n  }\n  protected HandlerManager ensureHandlers() {\n    if (handlerManager == null) {\n      handlerManager = new HandlerManager(this);\n    }\n    return handlerManager;\n  }\n  public UniqueKeyProvider<Node> getKeyProvider() {\n    return keyProvider;\n  }\n<fim_suffix>  public boolean hasMatchingKey(Node model1, Node model2) {\n    return keyProvider.getKey(model1).equals(keyProvider.getKey(model2));\n  }<fim_middle>// function below has no smell\n"}