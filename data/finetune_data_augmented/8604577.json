{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ignite.ml.clustering.gmm;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport org.apache.ignite.internal.util.typedef.internal.A;\nimport org.apache.ignite.ml.dataset.Dataset;\nimport org.apache.ignite.ml.dataset.primitive.context.EmptyContext;\nimport org.apache.ignite.ml.math.primitives.matrix.Matrix;\nimport org.apache.ignite.ml.math.primitives.vector.Vector;\n\n/**\n * This class encapsulates statistics aggregation logic for feature vector covariance matrix computation of one GMM\n * component (cluster).\n */\n<fim_suffix>public class CovarianceMatricesAggregator implements Serializable {\n    /** Serial version uid. */\n    private static final long serialVersionUID = 4163253784526780812L;\n\n    /** Mean vector. */\n    private final Vector mean;\n\n    /** Weighted by P(c|xi) sum of (xi - mean) * (xi - mean)^T values. */\n    private Matrix weightedSum;\n\n    /** Count of rows. */\n    private int rowCount;\n\n    /**\n     * Creates an instance of CovarianceMatricesAggregator.\n     *\n     * @param mean Mean vector.\n     */\n    CovarianceMatricesAggregator(Vector mean) {\n        this.mean = mean;\n    }\n\n    /**\n     * Creates an instance of CovarianceMatricesAggregator.\n     *\n     * @param mean Mean vector.\n     * @param weightedSum Weighted sums for covariace computation.\n     * @param rowCount Count of rows.\n     */\n    CovarianceMatricesAggregator(Vector mean, Matrix weightedSum, int rowCount) {\n        this.mean = mean;\n        this.weightedSum = weightedSum;\n        this.rowCount = rowCount;\n    }\n\n    /**\n     * Computes covatiation matrices for feature vector for each GMM component.\n     *\n     * @param dataset Dataset.\n     * @param clusterProbs Probabilities of each GMM component.\n     * @param means Means for each GMM component.\n     */\n    static List<Matrix> computeCovariances(Dataset<EmptyContext, GmmPartitionData> dataset,\n        Vector clusterProbs, Vector[] means) {\n\n        List<CovarianceMatricesAggregator> aggregators = dataset.compute(\n            data -> map(data, means),\n            CovarianceMatricesAggregator::reduce\n        );\n\n        if (aggregators == null)\n            return Collections.emptyList();\n\n        List<Matrix> res = new ArrayList<>();\n        for (int i = 0; i < aggregators.size(); i++)\n            res.add(aggregators.get(i).covariance(clusterProbs.get(i)));\n\n        return res;\n    }\n\n    /**\n     * @param x Feature vector (xi).\n     * @param pcxi P(c|xi) for GMM component \"c\" and vector xi.\n     */\n    void add(Vector x, double pcxi) {\n        Matrix deltaCol = x.minus(mean).toMatrix(false);\n        Matrix weightedCovComponent = deltaCol.times(deltaCol.transpose()).times(pcxi);\n        if (weightedSum == null)\n            weightedSum = weightedCovComponent;\n        else\n            weightedSum = weightedSum.plus(weightedCovComponent);\n        rowCount += 1;\n    }\n\n    /**\n     * @param other Other.\n     * @return sum of aggregators.\n     */\n    CovarianceMatricesAggregator plus(CovarianceMatricesAggregator other) {\n        A.ensure(this.mean.equals(other.mean), \"this.mean == other.mean\");\n\n        return new CovarianceMatricesAggregator(\n            mean,\n            this.weightedSum.plus(other.weightedSum),\n            this.rowCount + other.rowCount\n        );\n    }\n\n    /**\n     * Map stage for covariance computation over dataset.\n     *\n     * @param data Data partition.\n     * @param means Means vector.\n     * @return Covariance aggregators.\n     */\n    static List<CovarianceMatricesAggregator> map(GmmPartitionData data, Vector[] means) {\n        int countOfComponents = means.length;\n\n        List<CovarianceMatricesAggregator> aggregators = new ArrayList<>();\n        for (int i = 0; i < countOfComponents; i++)\n            aggregators.add(new CovarianceMatricesAggregator(means[i]));\n\n        for (int i = 0; i < data.size(); i++) {\n            for (int c = 0; c < countOfComponents; c++)\n                aggregators.get(c).add(data.getX(i), data.pcxi(c, i));\n        }\n\n        return aggregators;\n    }\n\n    /**\n     * @param clusterProb GMM component probability.\n     * @return computed covariance matrix.\n     */\n    private Matrix covariance(double clusterProb) {\n        return weightedSum.divide(rowCount * clusterProb);\n    }\n\n    /**\n     * Reduce stage for covariance computation over dataset.\n     *\n     * @param l first partition.\n     * @param r second partition.\n     */\n    static List<CovarianceMatricesAggregator> reduce(List<CovarianceMatricesAggregator> l,\n        List<CovarianceMatricesAggregator> r) {\n\n        A.ensure(l != null || r != null, \"Both partitions cannot equal to null\");\n\n        if (l == null || l.isEmpty())\n            return r;\n        if (r == null || r.isEmpty())\n            return l;\n\n        A.ensure(l.size() == r.size(), \"l.size() == r.size()\");\n        List<CovarianceMatricesAggregator> res = new ArrayList<>();\n        for (int i = 0; i < l.size(); i++)\n            res.add(l.get(i).plus(r.get(i)));\n\n        return res;\n    }\n\n    /**\n     * @return mean vector.\n     */\n    Vector mean() {\n        return mean.copy();\n    }\n\n    /**\n     * @return weighted sum.\n     */\n    Matrix weightedSum() {\n        return weightedSum.copy();\n    }\n\n    /**\n     * @return rows count.\n     */\n    public int rowCount() {\n        return rowCount;\n    }\n}<fim_middle>// class below has no smell\n"}