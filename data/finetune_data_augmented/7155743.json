{"text": "<fim_prefix>                    if (currentShapeIndex < shapeEndIndex) {\n                        appendToWKTBuffers(\"), \");\n                    } else {\n                        appendToWKTBuffers(\")\");\n                    }\n                    continue;\n                case COMPOUNDCURVE:\n                    if (currentFigureIndex == figures.length - 1) {\n                        pointIndexEnd = numberOfPoints;\n                    } else {\n                        pointIndexEnd = figures[currentFigureIndex + 1].getPointOffset();\n                    }\n                    int increment = calculateSegmentIncrement(currentSegmentIndex,\n                            pointIndexEnd - figures[currentFigureIndex].getPointOffset());\n                    segmentIndexIncrement = increment;\n                    segmentIndexEnd = currentSegmentIndex + increment;\n                    figureIndexIncrement++;\n                    currentShapeIndex++;\n                    break;\n                case FULLGLOBE:\n                    appendToWKTBuffers(\"FULLGLOBE\");\n                    break;\n                default:\n                    break;\n            }\n            constructWKT(this, isd, pointIndexEnd, figureIndexEnd, segmentIndexEnd, shapeIndexEnd);\n            currentFigureIndex = currentFigureIndex + figureIndexIncrement;\n            currentSegmentIndex = currentSegmentIndex + segmentIndexIncrement;\n            currentShapeIndex = currentShapeIndex + shapeIndexIncrement;\n            if (currentShapeIndex < shapeEndIndex) {\n                appendToWKTBuffers(\", \");\n            }\n        }\n    }\n    /**\n     * Calculates how many segments will be used by this shape. Needed to determine when the shape that uses segments\n     * (e.g. CompoundCurve) needs to stop reading in cases where the CompoundCurve is included as part of\n     * GeometryCollection.\n     * \n     * @param segmentStart\n     *        .\n     * @param pointDifference\n     *        number of points that were assigned to this segment to be used.\n     * @return the number of segments that will be used by this shape.\n     */\n    private int calculateSegmentIncrement(int segmentStart, int pointDifference) {\n        int segmentIncrement = 0;\n        while (pointDifference > 0) {\n            switch (segments[segmentStart].getSegmentType()) {\n                case 0:\n                    pointDifference = pointDifference - 1;\n                    if (segmentStart == segments.length - 1 || pointDifference < 1) { // last segment\n                        break;\n                    } else if (segments[segmentStart + 1].getSegmentType() != 0) { // one point will be reused\n                        pointDifference = pointDifference + 1;\n                    }\n                    break;\n                case 1:\n                    pointDifference = pointDifference - 2;\n                    if (segmentStart == segments.length - 1 || pointDifference < 1) { // last segment\n                        break;\n                    } else if (segments[segmentStart + 1].getSegmentType() != 1) { // one point will be reused\n                        pointDifference = pointDifference + 1;\n                    }\n                    break;\n                case 2:\n                    pointDifference = pointDifference - 2;\n                    if (segmentStart == segments.length - 1 || pointDifference < 1) { // last segment\n                        break;\n                    } else if (segments[segmentStart + 1].getSegmentType() != 0) { // one point will be reused\n                        pointDifference = pointDifference + 1;\n                    }\n                    break;\n                case 3:\n                    pointDifference = pointDifference - 3;\n                    if (segmentStart == segments.length - 1 || pointDifference < 1) { // last segment\n                        break;\n                    } else if (segments[segmentStart + 1].getSegmentType() != 1) { // one point will be reused\n                        pointDifference = pointDifference + 1;\n                    }\n                    break;\n                default:\n                    return segmentIncrement;\n            }\n            segmentStart++;\n            segmentIncrement++;\n        }\n        return segmentIncrement;\n    }\n    private void skipFirstPointWkt() {\n        int numOfCoordinates = 0;\n        while (numOfCoordinates < 4) {\n            if (wkt.charAt(currentWktPos) == '-') {\n                currentWktPos++;\n            }\n            if (wkt.charAt(currentWktPos) == ')') {\n                break;\n            }\n            while (currentWktPos < wkt.length()\n                    && (Character.isDigit(wkt.charAt(currentWktPos)) || wkt.charAt(currentWktPos) == '.'\n                            || wkt.charAt(currentWktPos) == 'E' || wkt.charAt(currentWktPos) == 'e')) {\n                currentWktPos++;\n            }\n            skipWhiteSpaces();\n            if (wkt.charAt(currentWktPos) == ',') {\n                currentWktPos++;\n                skipWhiteSpaces();\n                numOfCoordinates++;\n                break;\n            }\n            skipWhiteSpaces();\n            numOfCoordinates++;\n        }\n    }\n    private void readComma() throws SQLServerException {\n        skipWhiteSpaces();\n        if (wkt.charAt(currentWktPos) == ',') {\n            currentWktPos++;\n            skipWhiteSpaces();\n        } else {\n            throwIllegalWKTPosition();\n        }\n    }\n    private void skipWhiteSpaces() {\n        while (currentWktPos < wkt.length() && Character.isWhitespace(wkt.charAt(currentWktPos))) {\n            currentWktPos++;\n        }\n    }\n    private void checkNegSize(int num) throws SQLServerException {\n        if (num < 0) {\n            throwIllegalWKB();\n        }\n    }\n    private void readPoints(SQLServerSpatialDatatype type) throws SQLServerException {\n        xValues = new double[numberOfPoints];\n        yValues = new double[numberOfPoints];\n        if (type instanceof Geometry) {\n            for (int i = 0; i < numberOfPoints; i++) {\n                xValues[i] = readDouble();\n                yValues[i] = readDouble();\n            }\n        } else { // Geography\n            for (int i = 0; i < numberOfPoints; i++) {\n                yValues[i] = readDouble();\n                xValues[i] = readDouble();\n            }\n        }\n    }\n    private void checkBuffer(int i) throws SQLServerException {\n        if (buffer.remaining() < i) {\n            throwIllegalWKB();\n        }\n    }\n    private boolean checkSQLLength(int length) throws SQLServerException {\n        if (null == wkt || wkt.length() < length) {\n            throwIllegalWKTPosition();\n        }\n        return true;\n    }\n    private void throwIllegalWKTPosition() throws SQLServerException {\n        MessageFormat form = new MessageFormat(SQLServerException.getErrString(\"R_illegalWKTposition\"));\n        throw new SQLServerException(form.format(new Object[] {currentWktPos}), null, 0, null);\n    }\n    protected byte readByte() throws SQLServerException {\n        checkBuffer(1);\n        return buffer.get();\n    }\n    protected int readInt() throws SQLServerException {\n        checkBuffer(4);\n        return buffer.getInt();\n    }\n    protected double readDouble() throws SQLServerException {\n        checkBuffer(8);\n        return buffer.getDouble();\n    }\n}\n/**\n * Represents the internal makings of a Figure.\n *\n */\nclass Figure {\n    private byte figuresAttribute;\n    private int pointOffset;\n    Figure(byte figuresAttribute, int pointOffset) {\n        this.figuresAttribute = figuresAttribute;\n        this.pointOffset = pointOffset;\n    }\n    /**\n     * Returns the figuresAttribute value.\n     * \n     * @return byte figuresAttribute value.\n     */\n    public byte getFiguresAttribute() {\n        return figuresAttribute;\n    }\n    /**\n     * Returns the pointOffset value.\n     * \n     * @return int pointOffset value.\n     */\n    public int getPointOffset() {\n        return pointOffset;\n    }\n    /**\n     * Sets the figuresAttribute value.\n     * \n     * @param fa\n     *        figuresAttribute value.\n     */\n    public void setFiguresAttribute(byte fa) {\n        figuresAttribute = fa;\n    }\n}\n/**\n * Represents the internal makings of a Shape.\n *\n */\nclass Shape {\n    private int parentOffset;\n    private int figureOffset;\n    private byte openGISType;\n    Shape(int parentOffset, int figureOffset, byte openGISType) {\n        this.parentOffset = parentOffset;\n        this.figureOffset = figureOffset;\n        this.openGISType = openGISType;\n    }\n    /**\n     * Returns the parentOffset value.\n     * \n     * @return int parentOffset value.\n     */\n    public int getParentOffset() {\n        return parentOffset;\n    }\n    /**\n     * Returns the figureOffset value.\n     * \n     * @return int figureOffset value.\n     */\n    public int getFigureOffset() {\n        return figureOffset;\n    }\n    /**\n     * Returns the openGISType value.\n     * \n     * @return byte openGISType value.\n     */\n    public byte getOpenGISType() {\n        return openGISType;\n    }\n    /**\n     * Sets the figureOffset value.\n     * \n     * @param fo\n     *        figureOffset value.\n     */\n    public void setFigureOffset(int fo) {\n        figureOffset = fo;\n    }\n}\n/**\n * Represents the internal makings of a Segment.\n *\n */\n<fim_suffix>class Segment {\n    private byte segmentType;\n    Segment(byte segmentType) {\n        this.segmentType = segmentType;\n    }\n    /**\n     * Returns the segmentType value.\n     * \n     * @return byte segmentType value.\n     */\n    public byte getSegmentType() {\n        return segmentType;\n    }\n}<fim_middle>// class below is data class\n"}