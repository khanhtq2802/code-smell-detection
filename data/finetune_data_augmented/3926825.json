{"text": "<fim_prefix>    if ((n < 128) && (n >= -32)) {\n      out.writeByte((int) n);\n      return;\n    }\n    long un = (n < 0) ? ~n : n;\n    // how many bytes do we need to represent the number with sign bit?\n    int len = (Long.SIZE - Long.numberOfLeadingZeros(un)) / 8 + 1;\n    int firstByte = (int) (n >> ((len - 1) * 8));\n    switch (len) {\n      case 1:\n        // fall it through to firstByte==-1, len=2.\n        firstByte >>= 8;\n      case 2:\n        if ((firstByte < 20) && (firstByte >= -20)) {\n          out.writeByte(firstByte - 52);\n          out.writeByte((int) n);\n          return;\n        }\n        // fall it through to firstByte==0/-1, len=3.\n        firstByte >>= 8;\n      case 3:\n        if ((firstByte < 16) && (firstByte >= -16)) {\n          out.writeByte(firstByte - 88);\n          out.writeShort((int) n);\n          return;\n        }\n        // fall it through to firstByte==0/-1, len=4.\n        firstByte >>= 8;\n      case 4:\n        if ((firstByte < 8) && (firstByte >= -8)) {\n          out.writeByte(firstByte - 112);\n          out.writeShort(((int) n) >>> 8);\n          out.writeByte((int) n);\n          return;\n        }\n        out.writeByte(len - 129);\n        out.writeInt((int) n);\n        return;\n      case 5:\n        out.writeByte(len - 129);\n        out.writeInt((int) (n >>> 8));\n        out.writeByte((int) n);\n        return;\n      case 6:\n        out.writeByte(len - 129);\n        out.writeInt((int) (n >>> 16));\n        out.writeShort((int) n);\n        return;\n      case 7:\n        out.writeByte(len - 129);\n        out.writeInt((int) (n >>> 24));\n        out.writeShort((int) (n >>> 8));\n        out.writeByte((int) n);\n        return;\n      case 8:\n        out.writeByte(len - 129);\n        out.writeLong(n);\n        return;\n      default:\n        throw new RuntimeException(\"Internel error\");\n    }\n  }\n  /**\n   * Decoding the variable-length integer. Synonymous to <code>(int)Utils#readVLong(in)</code>.\n   *\n   * @param in\n   *          input stream\n   * @return the decoded integer\n   *\n   * @see Utils#readVLong(DataInput)\n   */\n  public static int readVInt(DataInput in) throws IOException {\n    long ret = readVLong(in);\n    if ((ret > Integer.MAX_VALUE) || (ret < Integer.MIN_VALUE)) {\n      throw new RuntimeException(\"Number too large to be represented as Integer\");\n    }\n    return (int) ret;\n  }\n  /**\n   * Decoding the variable-length integer. Suppose the value of the first byte is FB, and the\n   * following bytes are NB[*].\n   * <ul>\n   * <li>if (FB &gt;= -32), return (long)FB;\n   * <li>if (FB in [-72, -33]), return (FB+52)&lt;&lt;8 + NB[0]&amp;0xff;\n   * <li>if (FB in [-104, -73]), return (FB+88)&lt;&lt;16 + (NB[0]&amp;0xff)&lt;&lt;8 +\n   * NB[1]&amp;0xff;\n   * <li>if (FB in [-120, -105]), return (FB+112)&lt;&lt;24 + (NB[0]&amp;0xff)&lt;&lt;16 +\n   * (NB[1]&amp;0xff)&lt;&lt;8 + NB[2]&amp;0xff;\n   * <li>if (FB in [-128, -121]), return interpret NB[FB+129] as a signed big-endian integer.\n   * </ul>\n   *\n   * @param in\n   *          input stream\n   * @return the decoded long integer.\n   */\n  public static long readVLong(DataInput in) throws IOException {\n    int firstByte = in.readByte();\n    if (firstByte >= -32) {\n      return firstByte;\n    }\n    switch ((firstByte + 128) / 8) {\n      case 11:\n      case 10:\n      case 9:\n      case 8:\n      case 7:\n        return ((firstByte + 52) << 8) | in.readUnsignedByte();\n      case 6:\n      case 5:\n      case 4:\n      case 3:\n        return ((firstByte + 88) << 16) | in.readUnsignedShort();\n      case 2:\n      case 1:\n        return ((firstByte + 112) << 24) | (in.readUnsignedShort() << 8) | in.readUnsignedByte();\n      case 0:\n        int len = firstByte + 129;\n        switch (len) {\n          case 4:\n            return in.readInt();\n          case 5:\n            return ((long) in.readInt()) << 8 | in.readUnsignedByte();\n          case 6:\n            return ((long) in.readInt()) << 16 | in.readUnsignedShort();\n          case 7:\n            return ((long) in.readInt()) << 24 | (in.readUnsignedShort() << 8)\n                | in.readUnsignedByte();\n          case 8:\n            return in.readLong();\n          default:\n            throw new IOException(\"Corrupted VLong encoding\");\n        }\n      default:\n        throw new RuntimeException(\"Internal error\");\n    }\n  }\n  /**\n   * Write a String as a VInt n, followed by n Bytes as in Text format.\n   */\n  public static void writeString(DataOutput out, String s) throws IOException {\n    if (s != null) {\n      Text text = new Text(s);\n      byte[] buffer = text.getBytes();\n      int len = text.getLength();\n      writeVInt(out, len);\n      out.write(buffer, 0, len);\n    } else {\n      writeVInt(out, -1);\n    }\n  }\n  /**\n   * Read a String as a VInt n, followed by n Bytes in Text format.\n   *\n   * @param in\n   *          The input stream.\n   * @return The string\n   */\n  public static String readString(DataInput in) throws IOException {\n    int length = readVInt(in);\n    if (length == -1)\n      return null;\n    byte[] buffer = new byte[length];\n    in.readFully(buffer);\n    return Text.decode(buffer);\n  }\n  /**\n   * A generic Version class. We suggest applications built on top of TFile use this class to\n   * maintain version information in their meta blocks.\n   *\n   * A version number consists of a major version and a minor version. The suggested usage of major\n   * and minor version number is to increment major version number when the new storage format is\n   * not backward compatible, and increment the minor version otherwise.\n   */\n  public static final class Version implements Comparable<Version> {\n    private final short major;\n    private final short minor;\n    /**\n     * Construct the Version object by reading from the input stream.\n     *\n     * @param in\n     *          input stream\n     */\n    public Version(DataInput in) throws IOException {\n      major = in.readShort();\n      minor = in.readShort();\n    }\n    /**\n     * Constructor.\n     *\n     * @param major\n     *          major version.\n     * @param minor\n     *          minor version.\n     */\n    public Version(short major, short minor) {\n      this.major = major;\n      this.minor = minor;\n    }\n    /**\n     * Write the object to a DataOutput. The serialized format of the Version is major version\n     * followed by minor version, both as big-endian short integers.\n     *\n     * @param out\n     *          The DataOutput object.\n     */\n    public void write(DataOutput out) throws IOException {\n      out.writeShort(major);\n      out.writeShort(minor);\n    }\n    /**\n     * Get the size of the serialized Version object.\n     *\n     * @return serialized size of the version object.\n     */\n    public static int size() {\n      return (Short.SIZE + Short.SIZE) / Byte.SIZE;\n    }\n<fim_suffix>    @Override\n    public String toString() {\n      return new StringBuilder(\"v\").append(major).append(\".\").append(minor).toString();\n    }<fim_middle>// function below has no smell\n"}