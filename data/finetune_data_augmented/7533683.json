{"text": "<fim_prefix>/*\n * Copyright 2002-2012 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.springframework.integration.samples.tcpclientserver;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.springframework.core.serializer.Deserializer;\nimport org.springframework.core.serializer.Serializer;\n\n/**\n * This class is used to demonstrate how you can create a custom serializer/deserializer\n * to convert a TCP stream into custom objects which your domain-specific code can use.\n *\n * Since this is custom, it will have to have its own predefined assumptions for dealing\n * with the stream. In other words, there will have to be some indication within the\n * contents of the stream where the beginning/end is and how to extract the contents\n * into something meaningful (like an object). An example would be a fixed-file formatted\n * stream with the length encoded in some well known part of the stream (for example, the\n * first 8 bytes of the stream?).\n *\n * This custom serializer/deserializer assumes the first 3 bytes of the stream will be\n * considered an Order Number, the next 10 bytes will be the Sender's Name, the next 6 bytes\n * represents an left-zero-padded integer that specifies how long the rest of the message\n * content is. After that message content is parsed from the stream, the stream is assumed\n * to not have anything after it. In your code you could have delimiters to mark the end\n * of the stream, or could agree with the client that a valid stream is only n characters,\n * etc. Either way, since its custom, the client and server must have some predefined\n * assumptions in place for the communication to take place.\n *\n *\n * @author Christian Posta\n * @author Gunnar Hillert\n */\npublic class CustomSerializerDeserializer implements Serializer<CustomOrder>, Deserializer<CustomOrder>{\n\n\tprotected final Log logger = LogFactory.getLog(this.getClass());\n\n\tprivate static final int ORDER_NUMBER_LENGTH = 3;\n\tprivate static final int SENDER_NAME_LENGTH = 10;\n\tprivate static final int MESSAGE_LENGTH_LENGTH = 6;\n\n\t/**\n\t * Convert a CustomOrder object into a byte-stream\n\t *\n\t * @param object\n\t * @param outputStream\n\t * @throws IOException\n\t */\n\tpublic void serialize(CustomOrder object, OutputStream outputStream) throws IOException {\n\t\tbyte[] number = Integer.toString(object.getNumber()).getBytes();\n\t\toutputStream.write(number);\n\n\t\tbyte[] senderName = object.getSender().getBytes();\n\t\toutputStream.write(senderName);\n\n\t\tString lenghtPadded = pad(6, object.getMessage().length());\n\t\tbyte[] length = lenghtPadded.getBytes();\n\t\toutputStream.write(length);\n\n\t\toutputStream.write(object.getMessage().getBytes());\n\t\toutputStream.flush();\n\t}\n\n\tprivate String pad(int desiredLength, int length) {\n\t\treturn StringUtils.leftPad(Integer.toString(length), desiredLength, '0');\n\t}\n\n\t/**\n\t * Convert a raw byte stream into a CustomOrder\n\t *\n\t * @param inputStream\n\t * @return\n\t * @throws IOException\n\t */\n\tpublic CustomOrder deserialize(InputStream inputStream) throws IOException {\n\t\tint orderNumber = parseOrderNumber(inputStream);\n\t\tString senderName = parseSenderName(inputStream);\n\n\t\tCustomOrder order = new CustomOrder(orderNumber, senderName);\n\t\tString message = parseMessage(inputStream);\n\t\torder.setMessage(message);\n\t\treturn order;\n\t}\n\n\tprivate String parseMessage(InputStream inputStream) throws IOException {\n\t\tString lengthString = parseString(inputStream, MESSAGE_LENGTH_LENGTH);\n\t\tint lengthOfMessage = Integer.valueOf(lengthString);\n\n\t\tString message = parseString(inputStream, lengthOfMessage);\n\t\treturn message;\n\t}\n\n\tprivate String parseString(InputStream inputStream, int length) throws IOException {\n\t\tStringBuilder builder = new StringBuilder();\n\n\t\tint c;\n\t\tfor (int i = 0; i < length; ++i) {\n\t\t\tc = inputStream.read();\n\t\t\tcheckClosure(c);\n\t\t\tbuilder.append((char)c);\n\t\t}\n\n\t\treturn builder.toString();\n\t}\n\n\tprivate String parseSenderName(InputStream inputStream) throws IOException {\n\t\treturn parseString(inputStream, SENDER_NAME_LENGTH);\n\t}\n\n\tprivate int parseOrderNumber(InputStream inputStream) throws IOException {\n\t\tString value = parseString(inputStream, ORDER_NUMBER_LENGTH);\n\t\treturn Integer.valueOf(value.toString());\n\t}\n\n\t/**\n\t * Check whether the byte passed in is the \"closed socket\" byte\n\t * Note, I put this in here just as an example, but you could just extend the\n\t * {@link org.springframework.integration.ip.tcp.serializer.AbstractByteArraySerializer} class\n\t * which has this method\n\t *\n\t * @param bite\n\t * @throws IOException\n\t */\n<fim_suffix>\tprotected void checkClosure(int bite) throws IOException {\n\t\tif (bite < 0) {\n\t\t\tlogger.debug(\"Socket closed during message assembly\");\n\t\t\tthrow new IOException(\"Socket closed during message assembly\");\n\t\t}\n\t}\n}<fim_middle>// function below has no smell\n"}