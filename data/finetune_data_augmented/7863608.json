{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n * agreements. See the NOTICE file distributed with this work for additional information regarding\n * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n * copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\npackage org.apache.geode.internal.cache.persistence;\n\nimport static org.junit.Assert.fail;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.commons.io.FileUtils;\n\nimport org.apache.geode.cache.Cache;\nimport org.apache.geode.cache.DataPolicy;\nimport org.apache.geode.cache.DiskStore;\nimport org.apache.geode.cache.DiskStoreFactory;\nimport org.apache.geode.cache.Region;\nimport org.apache.geode.cache.RegionFactory;\nimport org.apache.geode.cache.Scope;\nimport org.apache.geode.internal.cache.GemFireCacheImpl;\nimport org.apache.geode.test.awaitility.GeodeAwaitility;\nimport org.apache.geode.test.dunit.AsyncInvocation;\nimport org.apache.geode.test.dunit.Invoke;\nimport org.apache.geode.test.dunit.SerializableRunnable;\nimport org.apache.geode.test.dunit.VM;\nimport org.apache.geode.test.dunit.WaitCriterion;\nimport org.apache.geode.test.dunit.cache.internal.JUnit4CacheTestCase;\n\n<fim_suffix>public abstract class PersistentReplicatedTestBase extends JUnit4CacheTestCase {\n\n  protected static final int MAX_WAIT = 60 * 1000;\n  protected static String REGION_NAME = \"region\";\n  protected File diskDir;\n  protected static String SAVED_ACK_WAIT_THRESHOLD;\n\n  @Override\n  public final void postSetUp() throws Exception {\n    Invoke.invokeInEveryVM(PersistentReplicatedTestBase.class, \"setRegionName\",\n        new Object[] {getUniqueName()});\n    setRegionName(getUniqueName());\n    diskDir = new File(\"diskDir-\" + getName()).getAbsoluteFile();\n    FileUtils.deleteDirectory(diskDir);\n    diskDir.mkdir();\n    diskDir.deleteOnExit();\n  }\n\n  public static void setRegionName(String testName) {\n    REGION_NAME = testName + \"Region\";\n  }\n\n  @Override\n  public final void postTearDownCacheTestCase() throws Exception {\n    FileUtils.deleteDirectory(diskDir);\n    postTearDownPersistentReplicatedTestBase();\n  }\n\n  protected void postTearDownPersistentReplicatedTestBase() throws Exception {}\n\n  protected void waitForBlockedInitialization(VM vm) {\n    vm.invoke(new SerializableRunnable() {\n\n      @Override\n      public void run() {\n        GeodeAwaitility.await().untilAsserted(new WaitCriterion() {\n\n          @Override\n          public String description() {\n            return \"Waiting for another persistent member to come online\";\n          }\n\n          @Override\n          public boolean done() {\n            GemFireCacheImpl cache = (GemFireCacheImpl) getCache();\n            PersistentMemberManager mm = cache.getPersistentMemberManager();\n            Map<String, Set<PersistentMemberID>> regions = mm.getWaitingRegions();\n            boolean done = !regions.isEmpty();\n            return done;\n          }\n\n        });\n\n      }\n\n    });\n  }\n\n  protected SerializableRunnable createPersistentRegionWithoutCompaction(final VM vm0) {\n    SerializableRunnable createRegion = new SerializableRunnable(\"Create persistent region\") {\n      @Override\n      public void run() {\n        Cache cache = getCache();\n        DiskStoreFactory dsf = cache.createDiskStoreFactory();\n        File dir = getDiskDirForVM(vm0);\n        dir.mkdirs();\n        dsf.setDiskDirs(new File[] {dir});\n        dsf.setMaxOplogSize(1);\n        dsf.setAutoCompact(false);\n        dsf.setAllowForceCompaction(true);\n        dsf.setCompactionThreshold(20);\n        DiskStore ds = dsf.create(REGION_NAME);\n        RegionFactory rf = new RegionFactory();\n        rf.setDiskStoreName(ds.getName());\n        rf.setDiskSynchronous(true);\n        rf.setDataPolicy(DataPolicy.PERSISTENT_REPLICATE);\n        rf.setScope(Scope.DISTRIBUTED_ACK);\n        rf.create(REGION_NAME);\n      }\n    };\n    vm0.invoke(createRegion);\n    return createRegion;\n  }\n\n  protected void closeRegion(final VM vm) {\n    SerializableRunnable closeRegion = new SerializableRunnable(\"Close persistent region\") {\n      @Override\n      public void run() {\n        Cache cache = getCache();\n        Region region = cache.getRegion(REGION_NAME);\n        region.close();\n      }\n    };\n    vm.invoke(closeRegion);\n  }\n\n  protected void closeCache(final VM vm) {\n    SerializableRunnable closeCache = new SerializableRunnable(\"close cache\") {\n      @Override\n      public void run() {\n        Cache cache = getCache();\n        cache.close();\n      }\n    };\n    vm.invoke(closeCache);\n  }\n\n  protected AsyncInvocation closeCacheAsync(VM vm0) {\n    SerializableRunnable close = new SerializableRunnable() {\n      @Override\n      public void run() {\n        Cache cache = getCache();\n        cache.close();\n      }\n    };\n\n    return vm0.invokeAsync(close);\n  }\n\n  protected void createNonPersistentRegion(VM vm) throws Exception {\n    SerializableRunnable createRegion = new SerializableRunnable(\"Create non persistent region\") {\n      @Override\n      public void run() {\n        Cache cache = getCache();\n        RegionFactory rf = new RegionFactory();\n        rf.setDataPolicy(DataPolicy.REPLICATE);\n        rf.setScope(Scope.DISTRIBUTED_ACK);\n        rf.create(REGION_NAME);\n      }\n    };\n    vm.invoke(createRegion);\n  }\n\n  protected AsyncInvocation createPersistentRegionWithWait(VM vm) throws Exception {\n    return _createPersistentRegion(vm, true);\n  }\n\n  protected void createPersistentRegion(VM vm) throws Exception {\n    _createPersistentRegion(vm, false);\n  }\n\n  private AsyncInvocation _createPersistentRegion(VM vm, boolean wait) throws Exception {\n    AsyncInvocation future = createPersistentRegionAsync(vm);\n    long waitTime = wait ? 500 : MAX_WAIT;\n    future.join(waitTime);\n    if (future.isAlive() && !wait) {\n      fail(\"Region not created within\" + MAX_WAIT);\n    }\n    if (!future.isAlive() && wait) {\n      fail(\"Did not expect region creation to complete\");\n    }\n    if (!wait && future.exceptionOccurred()) {\n      throw new RuntimeException(future.getException());\n    }\n    return future;\n  }\n\n  protected AsyncInvocation createPersistentRegionAsync(final VM vm) {\n    SerializableRunnable createRegion = new SerializableRunnable(\"Create persistent region\") {\n      @Override\n      public void run() {\n        Cache cache = getCache();\n        DiskStoreFactory dsf = cache.createDiskStoreFactory();\n        File dir = getDiskDirForVM(vm);\n        dir.mkdirs();\n        dsf.setDiskDirs(new File[] {dir});\n        dsf.setMaxOplogSize(1);\n        DiskStore ds = dsf.create(REGION_NAME);\n        RegionFactory rf = new RegionFactory();\n        rf.setDiskStoreName(ds.getName());\n        rf.setDiskSynchronous(true);\n        rf.setDataPolicy(DataPolicy.PERSISTENT_REPLICATE);\n        rf.setScope(Scope.DISTRIBUTED_ACK);\n        rf.create(REGION_NAME);\n      }\n    };\n    return vm.invokeAsync(createRegion);\n  }\n\n  protected File getDiskDirForVM(final VM vm) {\n    File dir = new File(diskDir, String.valueOf(vm.getId()));\n    return dir;\n  }\n\n  protected void backupDir(VM vm) throws IOException {\n    File dirForVM = getDiskDirForVM(vm);\n    File backFile = new File(dirForVM.getParent(), dirForVM.getName() + \".bk\");\n    FileUtils.copyDirectory(dirForVM, backFile);\n  }\n\n  protected void restoreBackup(VM vm) throws IOException {\n    File dirForVM = getDiskDirForVM(vm);\n    File backFile = new File(dirForVM.getParent(), dirForVM.getName() + \".bk\");\n    if (!backFile.renameTo(dirForVM)) {\n      FileUtils.deleteDirectory(dirForVM);\n      FileUtils.copyDirectory(backFile, dirForVM);\n      FileUtils.deleteDirectory(backFile);\n    }\n  }\n\n}<fim_middle>// class below is blob\n"}