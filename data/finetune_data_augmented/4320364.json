{"text": "<fim_prefix>/*\n   Derby - Class org.apache.derby.impl.sql.execute.GenericResultSetFactory\n   Licensed to the Apache Software Foundation (ASF) under one or more\n   contributor license agreements.  See the NOTICE file distributed with\n   this work for additional information regarding copyright ownership.\n   The ASF licenses this file to you under the Apache License, Version 2.0\n   (the \"License\"); you may not use this file except in compliance with\n   the License.  You may obtain a copy of the License at\n      http://www.apache.org/licenses/LICENSE-2.0\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n */\npackage org.apache.derby.impl.sql.execute;\nimport org.apache.derby.catalog.UUID;\nimport org.apache.derby.shared.common.error.StandardException;\nimport org.apache.derby.iapi.services.loader.GeneratedMethod;\nimport org.apache.derby.shared.common.sanity.SanityManager;\nimport org.apache.derby.iapi.sql.Activation;\nimport org.apache.derby.iapi.sql.ResultSet;\nimport org.apache.derby.iapi.sql.conn.Authorizer;\nimport org.apache.derby.iapi.sql.conn.LanguageConnectionContext;\nimport org.apache.derby.iapi.sql.execute.NoPutResultSet;\nimport org.apache.derby.iapi.sql.execute.ResultSetFactory;\nimport org.apache.derby.iapi.store.access.Qualifier;\nimport org.apache.derby.iapi.store.access.StaticCompiledOpenConglomInfo;\nimport org.apache.derby.iapi.types.DataValueDescriptor;\n/**\n * ResultSetFactory provides a wrapper around all of\n * the result sets used in this execution implementation.\n * This removes the need of generated classes to do a new\n * and of the generator to know about all of the result\n * sets.  Both simply know about this interface to getting\n * them.\n * <p>\n * In terms of modularizing, we can create just an interface\n * to this class and invoke the interface.  Different implementations\n * would get the same information provided but could potentially\n * massage/ignore it in different ways to satisfy their\n * implementations.  The practicality of this is to be seen.\n * <p>\n * The cost of this type of factory is that once you touch it,\n * you touch *all* of the possible result sets, not just\n * the ones you need.  So the first time you touch it could\n * be painful ... that might be a problem for execution.\n *\n */\npublic class GenericResultSetFactory implements ResultSetFactory \n{\n\t//\n\t// ResultSetFactory interface\n\t//\n\tpublic GenericResultSetFactory()\n\t{\n\t}\n\t/**\n\t\t@see ResultSetFactory#getInsertResultSet\n\t\t@exception StandardException thrown on error\n\t */\n    public ResultSet getInsertResultSet(NoPutResultSet source,\n                                        GeneratedMethod generationClauses,\n                                        GeneratedMethod checkGM,\n                                        int fullTemplate,\n                                        String schemaName,\n                                        String tableName)\n\t\tthrows StandardException\n\t{\n\t\tActivation activation = source.getActivation();\n\t\tgetAuthorizer(activation).authorize(activation, Authorizer.SQL_WRITE_OP);\n        return new InsertResultSet(source,\n                                   generationClauses,\n                                   checkGM,\n                                   fullTemplate,\n                                   schemaName,\n                                   tableName,\n                                   activation);\n\t}\n\t/**\n\t\t@see ResultSetFactory#getInsertVTIResultSet\n\t\t@exception StandardException thrown on error\n\t */\n\tpublic ResultSet getInsertVTIResultSet(NoPutResultSet source, \n\t\t\t\t\t\t\t\t\t\tNoPutResultSet vtiRS\n\t\t\t\t\t\t\t\t\t\t)\n\t\tthrows StandardException\n\t{\n\t\tActivation activation = source.getActivation();\n\t\tgetAuthorizer(activation).authorize(activation, Authorizer.SQL_WRITE_OP);\n\t\treturn new InsertVTIResultSet(source, vtiRS, activation );\n\t}\n\t/**\n\t\t@see ResultSetFactory#getDeleteVTIResultSet\n\t\t@exception StandardException thrown on error\n\t */\n\tpublic ResultSet getDeleteVTIResultSet(NoPutResultSet source)\n\t\tthrows StandardException\n\t{\n\t\tActivation activation = source.getActivation();\n\t\tgetAuthorizer(activation).authorize(activation, Authorizer.SQL_WRITE_OP);\n\t\treturn new DeleteVTIResultSet(source, activation);\n\t}\n\t/**\n\t\t@see ResultSetFactory#getDeleteResultSet\n\t\t@exception StandardException thrown on error\n\t */\n\tpublic ResultSet getDeleteResultSet(NoPutResultSet source)\n\t\t\tthrows StandardException\n\t{\n\t\tActivation activation = source.getActivation();\n\t\tgetAuthorizer(activation).authorize(activation, Authorizer.SQL_WRITE_OP);\n\t\treturn new DeleteResultSet(source, activation );\n\t}\n\t/**\n\t\t@see ResultSetFactory#getMergeResultSet\n\t\t@exception StandardException thrown on error\n\t */\n\tpublic ResultSet getMergeResultSet(NoPutResultSet drivingLeftJoin)\n        throws StandardException\n    {\n\t\tActivation activation = drivingLeftJoin.getActivation();\n\t\tgetAuthorizer( activation ).authorize( activation, Authorizer.SQL_WRITE_OP );\n\t\treturn new MergeResultSet( drivingLeftJoin, activation );\n    }\n\t/**\n\t\t@see ResultSetFactory#getDeleteCascadeResultSet\n\t\t@exception StandardException thrown on error\n\t */\n\tpublic ResultSet getDeleteCascadeResultSet(NoPutResultSet source, \n\t\t\t\t\t\t\t\t\t\t\t   int constantActionItem,\n\t\t\t\t\t\t\t\t\t\t\t   ResultSet[] dependentResultSets,\n\t\t\t\t\t\t\t\t\t\t\t   String resultSetId)\n\t\tthrows StandardException\n\t{\n\t\tActivation activation = source.getActivation();\n\t\tgetAuthorizer(activation).authorize(activation, Authorizer.SQL_WRITE_OP);\n\t\treturn new DeleteCascadeResultSet(source, activation, \n\t\t\t\t\t\t\t\t\t\t  constantActionItem,\n\t\t\t\t\t\t\t\t\t\t  dependentResultSets, \n\t\t\t\t\t\t\t\t\t\t  resultSetId);\n\t}\n\t/**\n\t\t@see ResultSetFactory#getUpdateResultSet\n\t\t@exception StandardException thrown on error\n\t */\n\tpublic ResultSet getUpdateResultSet(NoPutResultSet source, GeneratedMethod generationClauses,\n\t\t\t\t\t\t\t\t\t\tGeneratedMethod checkGM)\n\t\t\tthrows StandardException\n\t{\n\t\tActivation activation = source.getActivation();\n\t\t//The stress test failed with null pointer exception in here once and then\n\t\t//it didn't happen again. It can be a jit problem because after this null\n\t\t//pointer exception, the cleanup code in UpdateResultSet got a null\n\t\t//pointer exception too which can't happen since the cleanup code checks\n\t\t//for null value before doing anything.\n\t\t//In any case, if this ever happens again, hopefully the following\n\t\t//assertion code will catch it.\n\t\tif (SanityManager.DEBUG)\n\t\t{\n\t\t\tSanityManager.ASSERT(getAuthorizer(activation) != null, \"Authorizer is null\");\n\t\t}\n\t\tgetAuthorizer(activation).authorize(activation, Authorizer.SQL_WRITE_OP);\n\t\treturn new UpdateResultSet(source, generationClauses, checkGM, activation);\n\t}\n\t/**\n\t\t@see ResultSetFactory#getUpdateVTIResultSet\n\t\t@exception StandardException thrown on error\n\t */\n<fim_suffix>\tpublic ResultSet getUpdateVTIResultSet(NoPutResultSet source)\n\t\t\tthrows StandardException\n\t{\n\t\tActivation activation = source.getActivation();\n\t\tgetAuthorizer(activation).authorize(activation, Authorizer.SQL_WRITE_OP);\n\t\treturn new UpdateVTIResultSet(source, activation);\n\t}\n\t/**\n\t\t@see ResultSetFactory#getDeleteCascadeUpdateResultSet\n\t\t@exception StandardException thrown on error\n\t */\n\tpublic ResultSet getDeleteCascadeUpdateResultSet(NoPutResultSet source,\n                                                     GeneratedMethod generationClauses,\n\t\t\t\t\t\t\t\t\t\t\t\t\t GeneratedMethod checkGM,\n\t\t\t\t\t\t\t\t\t\t\t\t\t int constantActionItem,\n\t\t\t\t\t\t\t\t\t\t\t\t\t int rsdItem)\n\t\t\tthrows StandardException\n\t{\n\t\tActivation activation = source.getActivation();\n\t\tgetAuthorizer(activation).authorize(activation, Authorizer.SQL_WRITE_OP);\n\t\treturn new UpdateResultSet(source, generationClauses, checkGM, activation,\n\t\t\t\t\t\t\t\t   constantActionItem, rsdItem);\n\t}\n\t/**\n\t\t@see ResultSetFactory#getCallStatementResultSet\n\t\t@exception StandardException thrown on error\n\t */\n\tpublic ResultSet getCallStatementResultSet(GeneratedMethod methodCall,\n\t\t\t\tActivation activation)\n\t\t\tthrows StandardException\n\t{\n\t\tgetAuthorizer(activation).authorize(activation, Authorizer.SQL_CALL_OP);\n\t\treturn new CallStatementResultSet(methodCall, activation);\n\t}\n\t/**\n\t\t@see ResultSetFactory#getProjectRestrictResultSet\n\t\t@exception StandardException thrown on error\n\t */<fim_middle>// function below has no smell\n"}