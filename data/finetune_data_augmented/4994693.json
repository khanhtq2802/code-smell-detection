{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jclouds.compute.strategy;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Preconditions.checkState;\nimport static com.google.common.base.Throwables.getRootCause;\n\nimport java.util.Map;\nimport java.util.concurrent.Callable;\n\nimport javax.annotation.Resource;\nimport javax.inject.Named;\n\nimport org.jclouds.compute.callables.RunScriptOnNode;\nimport org.jclouds.compute.domain.ExecResponse;\nimport org.jclouds.compute.domain.NodeMetadata;\nimport org.jclouds.compute.reference.ComputeServiceConstants;\nimport org.jclouds.logging.Logger;\n\nimport com.google.common.base.MoreObjects;\nimport com.google.inject.assistedinject.AssistedInject;\n\n<fim_suffix>public class RunScriptOnNodeAndAddToGoodMapOrPutExceptionIntoBadMap implements Callable<ExecResponse> {\n\n   @Resource\n   @Named(ComputeServiceConstants.COMPUTE_LOGGER)\n   protected Logger logger = Logger.NULL;\n   private final RunScriptOnNode runScriptOnNode;\n   private final Map<NodeMetadata, Exception> badNodes;\n   private final Map<NodeMetadata, ExecResponse> goodNodes;\n\n   private transient boolean tainted;\n\n   @AssistedInject\n   public RunScriptOnNodeAndAddToGoodMapOrPutExceptionIntoBadMap(RunScriptOnNode runScriptOnNode,\n            Map<NodeMetadata, ExecResponse> goodNodes, Map<NodeMetadata, Exception> badNodes) {\n      this.runScriptOnNode = checkNotNull(runScriptOnNode, \"runScriptOnNode\");\n      this.badNodes = checkNotNull(badNodes, \"badNodes\");\n      this.goodNodes = checkNotNull(goodNodes, \"goodNodes\");\n   }\n\n   @Override\n   public ExecResponse call() {\n      checkState(runScriptOnNode != null, \"runScriptOnNode must be set\");\n      checkState(!tainted, \"this object is not designed to be reused: %s\", toString());\n      tainted = true;\n      try {\n         ExecResponse exec = runScriptOnNode.call();\n         logger.debug(\"<< options applied node(%s)\", runScriptOnNode.getNode().getId());\n         logger.trace(\"<< script output for node(%s): %s\", runScriptOnNode.getNode().getId(), exec);\n         goodNodes.put(runScriptOnNode.getNode(), exec);\n         return exec;\n      } catch (Exception e) {\n         logger.error(e, \"<< problem applying options to node(%s): \", runScriptOnNode.getNode().getId(),\n                  getRootCause(e).getMessage());\n         badNodes.put(runScriptOnNode.getNode(), e);\n      }\n      return null;\n   }\n\n   @Override\n   public String toString() {\n      return MoreObjects.toStringHelper(this).add(\"runScriptOnNode\", runScriptOnNode).add(\"goodNodes\", goodNodes).add(\n               \"badNodes\", badNodes).toString();\n   }\n\n}<fim_middle>// class below has no smell\n"}