{"text": "<fim_prefix>\n<fim_suffix>public class CellFormat {\n    private final Locale locale;\n    private final String format;\n    private final CellFormatPart posNumFmt;\n    private final CellFormatPart zeroNumFmt;\n    private final CellFormatPart negNumFmt;\n    private final CellFormatPart textFmt;\n    private final int formatPartCount;\n    private static final Pattern ONE_PART = Pattern.compile(\n            CellFormatPart.FORMAT_PAT.pattern() + \"(;|$)\",\n            Pattern.COMMENTS | Pattern.CASE_INSENSITIVE);\n    /*\n     * Cells that cannot be formatted, e.g. cells that have a date or time\n     * format and have an invalid date or time value, are displayed as 255\n     * pound signs (\"#\").\n     */\n    private static final String INVALID_VALUE_FOR_FORMAT =\n            \"###################################################\" +\n            \"###################################################\" +\n            \"###################################################\" +\n            \"###################################################\" +\n            \"###################################################\";\n    private static String QUOTE = \"\\\"\";\n    private static CellFormat createGeneralFormat(final Locale locale) {\n        return new CellFormat(locale, \"General\") {\n            @Override\n            public CellFormatResult apply(Object value) {\n                String text = (new CellGeneralFormatter(locale)).format(value);\n                return new CellFormatResult(true, text, null);\n            }\n        };\n    }\n    /** Maps a format string to its parsed version for efficiencies sake. */\n    private static final Map<Locale, Map<String, CellFormat>> formatCache =\n            new WeakHashMap<>();\n    /**\n     * Returns a {@link CellFormat} that applies the given format.  Two calls\n     * with the same format may or may not return the same object.\n     *\n     * @param format The format.\n     *\n     * @return A {@link CellFormat} that applies the given format.\n     */\n    public static CellFormat getInstance(String format) {\n        return getInstance(LocaleUtil.getUserLocale(), format);\n    }\n    /**\n     * Returns a {@link CellFormat} that applies the given format.  Two calls\n     * with the same format may or may not return the same object.\n     *\n     * @param locale The locale.\n     * @param format The format.\n     *\n     * @return A {@link CellFormat} that applies the given format.\n     */\n    public static synchronized CellFormat getInstance(Locale locale, String format) {\n        Map<String, CellFormat> formatMap = formatCache.get(locale);\n        if (formatMap == null) {\n            formatMap = new WeakHashMap<>();\n            formatCache.put(locale, formatMap);\n        }\n        CellFormat fmt = formatMap.get(format);\n        if (fmt == null) {\n            if (format.equals(\"General\") || format.equals(\"@\"))\n                fmt = createGeneralFormat(locale);\n            else\n                fmt = new CellFormat(locale, format);\n            formatMap.put(format, fmt);\n        }\n        return fmt;\n    }\n    /**\n     * Creates a new object.\n     *\n     * @param format The format.\n     */\n    private CellFormat(Locale locale, String format) {\n        this.locale = locale;\n        this.format = format;\n        CellFormatPart defaultTextFormat = new CellFormatPart(locale, \"@\");\n        Matcher m = ONE_PART.matcher(format);\n        List<CellFormatPart> parts = new ArrayList<>();\n        while (m.find()) {\n            try {\n                String valueDesc = m.group();\n                // Strip out the semicolon if it's there\n                if (valueDesc.endsWith(\";\"))\n                    valueDesc = valueDesc.substring(0, valueDesc.length() - 1);\n                parts.add(new CellFormatPart(locale, valueDesc));\n            } catch (RuntimeException e) {\n                CellFormatter.logger.log(Level.WARNING,\n                        \"Invalid format: \" + CellFormatter.quote(m.group()), e);\n                parts.add(null);\n            }\n        }\n        formatPartCount = parts.size();\n        switch (formatPartCount) {\n        case 1:\n            posNumFmt = parts.get(0);\n            negNumFmt = null;\n            zeroNumFmt = null;\n            textFmt = defaultTextFormat;\n            break;\n        case 2:\n            posNumFmt = parts.get(0);\n            negNumFmt = parts.get(1);\n            zeroNumFmt = null;\n            textFmt = defaultTextFormat;\n            break;\n        case 3:\n            posNumFmt = parts.get(0);\n            negNumFmt = parts.get(1);\n            zeroNumFmt = parts.get(2);\n            textFmt = defaultTextFormat;\n            break;\n        case 4:\n        default:\n            posNumFmt = parts.get(0);\n            negNumFmt = parts.get(1);\n            zeroNumFmt = parts.get(2);\n            textFmt = parts.get(3);\n            break;\n        }\n    }\n    /**\n     * Returns the result of applying the format to the given value.  If the\n     * value is a number (a type of {@link Number} object), the correct number\n     * format type is chosen; otherwise it is considered a text object.\n     *\n     * @param value The value\n     *\n     * @return The result, in a {@link CellFormatResult}.\n     */\n    public CellFormatResult apply(Object value) {\n        if (value instanceof Number) {\n            Number num = (Number) value;\n            double val = num.doubleValue();\n            if (val < 0 &&\n                    ((formatPartCount == 2\n                            && !posNumFmt.hasCondition() && !negNumFmt.hasCondition())\n                    || (formatPartCount == 3 && !negNumFmt.hasCondition())\n                    || (formatPartCount == 4 && !negNumFmt.hasCondition()))) {\n                // The negative number format has the negative formatting required,\n                // e.g. minus sign or brackets, so pass a positive value so that\n                // the default leading minus sign is not also output\n                return negNumFmt.apply(-val);\n            } else {\n                return getApplicableFormatPart(val).apply(val);\n            }\n        } else if (value instanceof java.util.Date) {\n            // Don't know (and can't get) the workbook date windowing (1900 or 1904)\n            // so assume 1900 date windowing\n            Double numericValue = DateUtil.getExcelDate((Date) value);\n            if (DateUtil.isValidExcelDate(numericValue)) {\n                return getApplicableFormatPart(numericValue).apply(value);\n            } else {\n                throw new IllegalArgumentException(\"value \" + numericValue + \" of date \" + value + \" is not a valid Excel date\");\n            }\n        } else {\n            return textFmt.apply(value);\n        }\n    }\n    /**\n     * Returns the result of applying the format to the given date.\n     *\n     * @param date         The date.\n     * @param numericValue The numeric value for the date.\n     *\n     * @return The result, in a {@link CellFormatResult}.\n     */\n    private CellFormatResult apply(Date date, double numericValue) {\n        return getApplicableFormatPart(numericValue).apply(date);\n    }\n    /**\n     * Fetches the appropriate value from the cell, and returns the result of\n     * applying it to the appropriate format.  For formula cells, the computed\n     * value is what is used.\n     *\n     * @param c The cell.\n     *\n     * @return The result, in a {@link CellFormatResult}.\n     */\n    public CellFormatResult apply(Cell c) {\n        switch (ultimateType(c)) {\n        case BLANK:\n            return apply(\"\");\n        case BOOLEAN:\n            return apply(c.getBooleanCellValue());\n        case NUMERIC:\n            Double value = c.getNumericCellValue();\n            if (getApplicableFormatPart(value).getCellFormatType() == CellFormatType.DATE) {\n                if (DateUtil.isValidExcelDate(value)) {\n                    return apply(c.getDateCellValue(), value);\n                } else {\n                    return apply(INVALID_VALUE_FOR_FORMAT);\n                }\n            } else {\n                return apply(value);\n            }\n        case STRING:\n            return apply(c.getStringCellValue());\n        default:\n            return apply(\"?\");\n        }\n    }\n    /**\n     * Uses the result of applying this format to the value, setting the text\n     * and color of a label before returning the result.\n     *\n     * @param label The label to apply to.\n     * @param value The value to process.\n     *\n     * @return The result, in a {@link CellFormatResult}.\n     */\n    public CellFormatResult apply(JLabel label, Object value) {\n        CellFormatResult result = apply(value);\n        label.setText(result.text);\n        if (result.textColor != null) {\n            label.setForeground(result.textColor);\n        }\n        return result;\n    }\n    /**\n     * Uses the result of applying this format to the given date, setting the text\n     * and color of a label before returning the result.\n     *\n     * @param label        The label to apply to.\n     * @param date         The date.\n     * @param numericValue The numeric value for the date.<fim_middle>// class below has no smell\n"}