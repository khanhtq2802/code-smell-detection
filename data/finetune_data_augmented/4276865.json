{"text": "<fim_prefix>                        case LARGEST_VARIANCE :\n                            newCenter = getPointFromLargestVarianceCluster(clusters);\n                            break;\n                        case LARGEST_POINTS_NUMBER :\n                            newCenter = getPointFromLargestNumberCluster(clusters);\n                            break;\n                        case FARTHEST_POINT :\n                            newCenter = getFarthestPoint(clusters);\n                            break;\n                        default :\n                            throw new ConvergenceException(LocalizedFormats.EMPTY_CLUSTER_IN_K_MEANS);\n                    }\n                    emptyCluster = true;\n                } else {\n                    newCenter = centroidOf(cluster.getPoints(), cluster.getCenter().getPoint().length);\n                }\n                newClusters.add(new CentroidCluster<T>(newCenter));\n            }\n            int changes = assignPointsToClusters(newClusters, points, assignments);\n            clusters = newClusters;\n            // if there were no more changes in the point-to-cluster assignment\n            // and there are no empty clusters left, return the current clusters\n            if (changes == 0 && !emptyCluster) {\n                return clusters;\n            }\n        }\n        return clusters;\n    }\n    /**\n     * Adds the given points to the closest {@link Cluster}.\n     *\n     * @param clusters the {@link Cluster}s to add the points to\n     * @param points the points to add to the given {@link Cluster}s\n     * @param assignments points assignments to clusters\n     * @return the number of points assigned to different clusters as the iteration before\n     */\n    private int assignPointsToClusters(final List<CentroidCluster<T>> clusters,\n                                       final Collection<T> points,\n                                       final int[] assignments) {\n        int assignedDifferently = 0;\n        int pointIndex = 0;\n        for (final T p : points) {\n            int clusterIndex = getNearestCluster(clusters, p);\n            if (clusterIndex != assignments[pointIndex]) {\n                assignedDifferently++;\n            }\n            CentroidCluster<T> cluster = clusters.get(clusterIndex);\n            cluster.addPoint(p);\n            assignments[pointIndex++] = clusterIndex;\n        }\n        return assignedDifferently;\n    }\n    /**\n     * Use K-means++ to choose the initial centers.\n     *\n     * @param points the points to choose the initial centers from\n     * @return the initial centers\n     */\n    private List<CentroidCluster<T>> chooseInitialCenters(final Collection<T> points) {\n        // Convert to list for indexed access. Make it unmodifiable, since removal of items\n        // would screw up the logic of this method.\n        final List<T> pointList = Collections.unmodifiableList(new ArrayList<> (points));\n        // The number of points in the list.\n        final int numPoints = pointList.size();\n        // Set the corresponding element in this array to indicate when\n        // elements of pointList are no longer available.\n        final boolean[] taken = new boolean[numPoints];\n        // The resulting list of initial centers.\n        final List<CentroidCluster<T>> resultSet = new ArrayList<>();\n        // Choose one center uniformly at random from among the data points.\n        final int firstPointIndex = random.nextInt(numPoints);\n        final T firstPoint = pointList.get(firstPointIndex);\n        resultSet.add(new CentroidCluster<T>(firstPoint));\n        // Must mark it as taken\n        taken[firstPointIndex] = true;\n        // To keep track of the minimum distance squared of elements of\n        // pointList to elements of resultSet.\n        final double[] minDistSquared = new double[numPoints];\n        // Initialize the elements.  Since the only point in resultSet is firstPoint,\n        // this is very easy.\n        for (int i = 0; i < numPoints; i++) {\n            if (i != firstPointIndex) { // That point isn't considered\n                double d = distance(firstPoint, pointList.get(i));\n                minDistSquared[i] = d*d;\n            }\n        }\n        while (resultSet.size() < k) {\n            // Sum up the squared distances for the points in pointList not\n            // already taken.\n            double distSqSum = 0.0;\n            for (int i = 0; i < numPoints; i++) {\n                if (!taken[i]) {\n                    distSqSum += minDistSquared[i];\n                }\n            }\n            // Add one new data point as a center. Each point x is chosen with\n            // probability proportional to D(x)2\n            final double r = random.nextDouble() * distSqSum;\n            // The index of the next point to be added to the resultSet.\n            int nextPointIndex = -1;\n            // Sum through the squared min distances again, stopping when\n            // sum >= r.\n            double sum = 0.0;\n            for (int i = 0; i < numPoints; i++) {\n                if (!taken[i]) {\n                    sum += minDistSquared[i];\n                    if (sum >= r) {\n                        nextPointIndex = i;\n                        break;\n                    }\n                }\n            }\n            // If it's not set to >= 0, the point wasn't found in the previous\n            // for loop, probably because distances are extremely small.  Just pick\n            // the last available point.\n            if (nextPointIndex == -1) {\n                for (int i = numPoints - 1; i >= 0; i--) {\n                    if (!taken[i]) {\n                        nextPointIndex = i;\n                        break;\n                    }\n                }\n            }\n            // We found one.\n            if (nextPointIndex >= 0) {\n                final T p = pointList.get(nextPointIndex);\n                resultSet.add(new CentroidCluster<T> (p));\n                // Mark it as taken.\n                taken[nextPointIndex] = true;\n                if (resultSet.size() < k) {\n                    // Now update elements of minDistSquared.  We only have to compute\n                    // the distance to the new center to do this.\n                    for (int j = 0; j < numPoints; j++) {\n                        // Only have to worry about the points still not taken.\n                        if (!taken[j]) {\n                            double d = distance(p, pointList.get(j));\n                            double d2 = d * d;\n                            if (d2 < minDistSquared[j]) {\n                                minDistSquared[j] = d2;\n                            }\n                        }\n                    }\n                }\n            } else {\n                // None found --\n                // Break from the while loop to prevent\n                // an infinite loop.\n                break;\n            }\n        }\n        return resultSet;\n    }\n    /**\n     * Get a random point from the {@link Cluster} with the largest distance variance.\n     *\n     * @param clusters the {@link Cluster}s to search\n     * @return a random point from the selected cluster\n     * @throws ConvergenceException if clusters are all empty\n     */\n    private T getPointFromLargestVarianceCluster(final Collection<CentroidCluster<T>> clusters)\n            throws ConvergenceException {\n        double maxVariance = Double.NEGATIVE_INFINITY;\n        Cluster<T> selected = null;\n        for (final CentroidCluster<T> cluster : clusters) {\n            if (!cluster.getPoints().isEmpty()) {\n                // compute the distance variance of the current cluster\n                final Clusterable center = cluster.getCenter();\n                final Variance stat = new Variance();\n                for (final T point : cluster.getPoints()) {\n                    stat.increment(distance(point, center));\n                }\n                final double variance = stat.getResult();\n                // select the cluster with the largest variance\n                if (variance > maxVariance) {\n                    maxVariance = variance;\n                    selected = cluster;\n                }\n            }\n        }\n        // did we find at least one non-empty cluster ?\n        if (selected == null) {\n            throw new ConvergenceException(LocalizedFormats.EMPTY_CLUSTER_IN_K_MEANS);\n        }\n        // extract a random point from the cluster\n        final List<T> selectedPoints = selected.getPoints();\n        return selectedPoints.remove(random.nextInt(selectedPoints.size()));\n    }\n    /**\n     * Get a random point from the {@link Cluster} with the largest number of points\n     *\n     * @param clusters the {@link Cluster}s to search\n     * @return a random point from the selected cluster\n     * @throws ConvergenceException if clusters are all empty\n     */\n<fim_suffix>    private T getPointFromLargestNumberCluster(final Collection<? extends Cluster<T>> clusters)\n            throws ConvergenceException {\n        int maxNumber = 0;\n        Cluster<T> selected = null;\n        for (final Cluster<T> cluster : clusters) {\n            // get the number of points of the current cluster\n            final int number = cluster.getPoints().size();\n            // select the cluster with the largest number of points\n            if (number > maxNumber) {\n                maxNumber = number;\n                selected = cluster;\n            }\n        }\n        // did we find at least one non-empty cluster ?\n        if (selected == null) {\n            throw new ConvergenceException(LocalizedFormats.EMPTY_CLUSTER_IN_K_MEANS);\n        }\n        // extract a random point from the cluster\n        final List<T> selectedPoints = selected.getPoints();\n        return selectedPoints.remove(random.nextInt(selectedPoints.size()));\n    }<fim_middle>// function below has no smell\n"}