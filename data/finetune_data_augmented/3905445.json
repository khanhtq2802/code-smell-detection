{"text": "<fim_prefix>          + \" for backwards compatibility\")\n  private Object deserialize(byte[] ser) {\n    try {\n      ByteArrayInputStream bais = new ByteArrayInputStream(ser);\n      ObjectInputStream ois = new ObjectInputStream(bais);\n      return ois.readObject();\n    } catch (Exception e) {\n      throw new RuntimeException(e);\n    }\n  }\n  private String getTXPath(long tid) {\n    return String.format(\"%s/tx_%016x\", path, tid);\n  }\n  private long parseTid(String txdir) {\n    return Long.parseLong(txdir.split(\"_\")[1], 16);\n  }\n  public ZooStore(String path, IZooReaderWriter zk) throws KeeperException, InterruptedException {\n    this.path = path;\n    this.zk = zk;\n    this.reserved = new HashSet<>();\n    this.defered = new HashMap<>();\n    this.idgenerator = new SecureRandom();\n    zk.putPersistentData(path, new byte[0], NodeExistsPolicy.SKIP);\n  }\n  @Override\n  public long create() {\n    while (true) {\n      try {\n        // looking at the code for SecureRandom, it appears to be thread safe\n        long tid = idgenerator.nextLong() & 0x7fffffffffffffffL;\n        zk.putPersistentData(getTXPath(tid), TStatus.NEW.name().getBytes(UTF_8),\n            NodeExistsPolicy.FAIL);\n        return tid;\n      } catch (NodeExistsException nee) {\n        // exist, so just try another random #\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n  @Override\n  public long reserve() {\n    try {\n      while (true) {\n        long events;\n        synchronized (this) {\n          events = statusChangeEvents;\n        }\n        List<String> txdirs = new ArrayList<>(zk.getChildren(path));\n        Collections.sort(txdirs);\n        synchronized (this) {\n          if (txdirs.size() > 0 && txdirs.get(txdirs.size() - 1).compareTo(lastReserved) <= 0)\n            lastReserved = \"\";\n        }\n        for (String txdir : txdirs) {\n          long tid = parseTid(txdir);\n          synchronized (this) {\n            // this check makes reserve pick up where it left off, so that it cycles through all as\n            // it is repeatedly called.... failing to do so can lead to\n            // starvation where fate ops that sort higher and hold a lock are never reserved.\n            if (txdir.compareTo(lastReserved) <= 0)\n              continue;\n            if (defered.containsKey(tid)) {\n              if (defered.get(tid) < System.currentTimeMillis())\n                defered.remove(tid);\n              else\n                continue;\n            }\n            if (!reserved.contains(tid)) {\n              reserved.add(tid);\n              lastReserved = txdir;\n            } else\n              continue;\n          }\n          // have reserved id, status should not change\n          try {\n            TStatus status = TStatus\n                .valueOf(new String(zk.getData(path + \"/\" + txdir, null), UTF_8));\n            if (status == TStatus.IN_PROGRESS || status == TStatus.FAILED_IN_PROGRESS) {\n              return tid;\n            } else {\n              unreserve(tid);\n            }\n          } catch (NoNodeException nne) {\n            // node deleted after we got the list of children, its ok\n            unreserve(tid);\n          } catch (Exception e) {\n            unreserve(tid);\n            throw e;\n          }\n        }\n        synchronized (this) {\n          // suppress lgtm alert - synchronized variable is not always true\n          if (events == statusChangeEvents) { // lgtm [java/constant-comparison]\n            if (defered.size() > 0) {\n              Long minTime = Collections.min(defered.values());\n              long waitTime = minTime - System.currentTimeMillis();\n              if (waitTime > 0)\n                this.wait(Math.min(waitTime, 5000));\n            } else\n              this.wait(5000);\n          }\n        }\n      }\n    } catch (Exception e) {\n      throw new RuntimeException(e);\n    }\n  }\n  @Override\n  public void reserve(long tid) {\n    synchronized (this) {\n      reservationsWaiting++;\n      try {\n        while (reserved.contains(tid))\n          try {\n            this.wait(1000);\n          } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n          }\n        reserved.add(tid);\n      } finally {\n        reservationsWaiting--;\n      }\n    }\n  }\n  private void unreserve(long tid) {\n    synchronized (this) {\n      if (!reserved.remove(tid))\n        throw new IllegalStateException(\n            \"Tried to unreserve id that was not reserved \" + String.format(\"%016x\", tid));\n      // do not want this unreserve to unesc wake up threads in reserve()... this leads to infinite\n      // loop when tx is stuck in NEW...\n      // only do this when something external has called reserve(tid)...\n      if (reservationsWaiting > 0)\n        this.notifyAll();\n    }\n  }\n  @Override\n  public void unreserve(long tid, long deferTime) {\n    if (deferTime < 0)\n      throw new IllegalArgumentException(\"deferTime < 0 : \" + deferTime);\n    synchronized (this) {\n      if (!reserved.remove(tid))\n        throw new IllegalStateException(\n            \"Tried to unreserve id that was not reserved \" + String.format(\"%016x\", tid));\n      if (deferTime > 0)\n        defered.put(tid, System.currentTimeMillis() + deferTime);\n      this.notifyAll();\n    }\n  }\n  private void verifyReserved(long tid) {\n    synchronized (this) {\n      if (!reserved.contains(tid))\n        throw new IllegalStateException(\n            \"Tried to operate on unreserved transaction \" + String.format(\"%016x\", tid));\n    }\n  }\n  private static final int RETRIES = 10;\n  @SuppressWarnings(\"unchecked\")\n  @Override\n  public Repo<T> top(long tid) {\n    verifyReserved(tid);\n    for (int i = 0; i < RETRIES; i++) {\n      String txpath = getTXPath(tid);\n      try {\n        String top;\n        try {\n          top = findTop(txpath);\n          if (top == null) {\n            return null;\n          }\n        } catch (KeeperException.NoNodeException ex) {\n          throw new RuntimeException(ex);\n        }\n        byte[] ser = zk.getData(txpath + \"/\" + top, null);\n        return (Repo<T>) deserialize(ser);\n      } catch (KeeperException.NoNodeException ex) {\n        log.debug(\"zookeeper error reading \" + txpath + \": \" + ex, ex);\n        sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n        continue;\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return null;\n  }\n  private String findTop(String txpath) throws KeeperException, InterruptedException {\n    List<String> ops = zk.getChildren(txpath);\n    ops = new ArrayList<>(ops);\n    String max = \"\";\n    for (String child : ops)\n      if (child.startsWith(\"repo_\") && child.compareTo(max) > 0)\n        max = child;\n    if (max.equals(\"\"))\n      return null;\n    return max;\n  }\n  @Override\n  public void push(long tid, Repo<T> repo) throws StackOverflowException {\n    verifyReserved(tid);\n    String txpath = getTXPath(tid);\n    try {\n      String top = findTop(txpath);\n      if (top != null && Long.parseLong(top.split(\"_\")[1]) > 100) {\n        throw new StackOverflowException(\"Repo stack size too large\");\n      }\n      zk.putPersistentSequential(txpath + \"/repo_\", serialize(repo));\n    } catch (StackOverflowException soe) {\n      throw soe;\n    } catch (Exception e) {\n      throw new RuntimeException(e);\n    }\n  }\n  @Override\n  public void pop(long tid) {\n    verifyReserved(tid);\n    try {\n      String txpath = getTXPath(tid);\n      String top = findTop(txpath);\n      if (top == null)\n        throw new IllegalStateException(\"Tried to pop when empty \" + tid);\n      zk.recursiveDelete(txpath + \"/\" + top, NodeMissingPolicy.SKIP);\n    } catch (Exception e) {\n      throw new RuntimeException(e);\n    }\n  }\n  private TStatus _getStatus(long tid) {\n    try {\n      return TStatus.valueOf(new String(zk.getData(getTXPath(tid), null), UTF_8));\n    } catch (NoNodeException nne) {\n      return TStatus.UNKNOWN;\n    } catch (Exception e) {\n      throw new RuntimeException(e);\n    }\n  }\n<fim_suffix>  @Override\n  public TStatus getStatus(long tid) {\n    verifyReserved(tid);\n    return _getStatus(tid);\n  }<fim_middle>// function below has no smell\n"}