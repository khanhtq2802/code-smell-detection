{"text": "<fim_prefix>\n<fim_suffix>public final class ParsableByteArray {\n  public byte[] data;\n  private int position;\n  private int limit;\n  /** Creates a new instance that initially has no backing data. */\n  public ParsableByteArray() {\n    data = Util.EMPTY_BYTE_ARRAY;\n  }\n  /**\n   * Creates a new instance with {@code limit} bytes and sets the limit.\n   *\n   * @param limit The limit to set.\n   */\n  public ParsableByteArray(int limit) {\n    this.data = new byte[limit];\n    this.limit = limit;\n  }\n  /**\n   * Creates a new instance wrapping {@code data}, and sets the limit to {@code data.length}.\n   *\n   * @param data The array to wrap.\n   */\n  public ParsableByteArray(byte[] data) {\n    this.data = data;\n    limit = data.length;\n  }\n  /**\n   * Creates a new instance that wraps an existing array.\n   *\n   * @param data The data to wrap.\n   * @param limit The limit to set.\n   */\n  public ParsableByteArray(byte[] data, int limit) {\n    this.data = data;\n    this.limit = limit;\n  }\n  /** Sets the position and limit to zero. */\n  public void reset() {\n    position = 0;\n    limit = 0;\n  }\n  /**\n   * Resets the position to zero and the limit to the specified value. If the limit exceeds the\n   * capacity, {@code data} is replaced with a new array of sufficient size.\n   *\n   * @param limit The limit to set.\n   */\n  public void reset(int limit) {\n    reset(capacity() < limit ? new byte[limit] : data, limit);\n  }\n  /**\n   * Updates the instance to wrap {@code data}, and resets the position to zero and the limit to\n   * {@code data.length}.\n   *\n   * @param data The array to wrap.\n   */\n  public void reset(byte[] data) {\n    reset(data, data.length);\n  }\n  /**\n   * Updates the instance to wrap {@code data}, and resets the position to zero.\n   *\n   * @param data The array to wrap.\n   * @param limit The limit to set.\n   */\n  public void reset(byte[] data, int limit) {\n    this.data = data;\n    this.limit = limit;\n    position = 0;\n  }\n  /**\n   * Returns the number of bytes yet to be read.\n   */\n  public int bytesLeft() {\n    return limit - position;\n  }\n  /**\n   * Returns the limit.\n   */\n  public int limit() {\n    return limit;\n  }\n  /**\n   * Sets the limit.\n   *\n   * @param limit The limit to set.\n   */\n  public void setLimit(int limit) {\n    Assertions.checkArgument(limit >= 0 && limit <= data.length);\n    this.limit = limit;\n  }\n  /**\n   * Returns the current offset in the array, in bytes.\n   */\n  public int getPosition() {\n    return position;\n  }\n  /**\n   * Returns the capacity of the array, which may be larger than the limit.\n   */\n  public int capacity() {\n    return data.length;\n  }\n  /**\n   * Sets the reading offset in the array.\n   *\n   * @param position Byte offset in the array from which to read.\n   * @throws IllegalArgumentException Thrown if the new position is neither in nor at the end of the\n   *     array.\n   */\n  public void setPosition(int position) {\n    // It is fine for position to be at the end of the array.\n    Assertions.checkArgument(position >= 0 && position <= limit);\n    this.position = position;\n  }\n  /**\n   * Moves the reading offset by {@code bytes}.\n   *\n   * @param bytes The number of bytes to skip.\n   * @throws IllegalArgumentException Thrown if the new position is neither in nor at the end of the\n   *     array.\n   */\n  public void skipBytes(int bytes) {\n    setPosition(position + bytes);\n  }\n  /**\n   * Reads the next {@code length} bytes into {@code bitArray}, and resets the position of\n   * {@code bitArray} to zero.\n   *\n   * @param bitArray The {@link ParsableBitArray} into which the bytes should be read.\n   * @param length The number of bytes to write.\n   */\n  public void readBytes(ParsableBitArray bitArray, int length) {\n    readBytes(bitArray.data, 0, length);\n    bitArray.setPosition(0);\n  }\n  /**\n   * Reads the next {@code length} bytes into {@code buffer} at {@code offset}.\n   *\n   * @see System#arraycopy(Object, int, Object, int, int)\n   * @param buffer The array into which the read data should be written.\n   * @param offset The offset in {@code buffer} at which the read data should be written.\n   * @param length The number of bytes to read.\n   */\n  public void readBytes(byte[] buffer, int offset, int length) {\n    System.arraycopy(data, position, buffer, offset, length);\n    position += length;\n  }\n  /**\n   * Reads the next {@code length} bytes into {@code buffer}.\n   *\n   * @see ByteBuffer#put(byte[], int, int)\n   * @param buffer The {@link ByteBuffer} into which the read data should be written.\n   * @param length The number of bytes to read.\n   */\n  public void readBytes(ByteBuffer buffer, int length) {\n    buffer.put(data, position, length);\n    position += length;\n  }\n  /**\n   * Peeks at the next byte as an unsigned value.\n   */\n  public int peekUnsignedByte() {\n    return (data[position] & 0xFF);\n  }\n  /**\n   * Peeks at the next char.\n   */\n  public char peekChar() {\n    return (char) ((data[position] & 0xFF) << 8\n        | (data[position + 1] & 0xFF));\n  }\n  /**\n   * Reads the next byte as an unsigned value.\n   */\n  public int readUnsignedByte() {\n    return (data[position++] & 0xFF);\n  }\n  /**\n   * Reads the next two bytes as an unsigned value.\n   */\n  public int readUnsignedShort() {\n    return (data[position++] & 0xFF) << 8\n        | (data[position++] & 0xFF);\n  }\n  /**\n   * Reads the next two bytes as an unsigned value.\n   */\n  public int readLittleEndianUnsignedShort() {\n    return (data[position++] & 0xFF) | (data[position++] & 0xFF) << 8;\n  }\n  /**\n   * Reads the next two bytes as a signed value.\n   */\n  public short readShort() {\n    return (short) ((data[position++] & 0xFF) << 8\n        | (data[position++] & 0xFF));\n  }\n  /**\n   * Reads the next two bytes as a signed value.\n   */\n  public short readLittleEndianShort() {\n    return (short) ((data[position++] & 0xFF) | (data[position++] & 0xFF) << 8);\n  }\n  /**\n   * Reads the next three bytes as an unsigned value.\n   */\n  public int readUnsignedInt24() {\n    return (data[position++] & 0xFF) << 16\n        | (data[position++] & 0xFF) << 8\n        | (data[position++] & 0xFF);\n  }\n  /**\n   * Reads the next three bytes as a signed value.\n   */\n  public int readInt24() {\n    return ((data[position++] & 0xFF) << 24) >> 8\n        | (data[position++] & 0xFF) << 8\n        | (data[position++] & 0xFF);\n  }\n  /**\n   * Reads the next three bytes as a signed value in little endian order.\n   */\n  public int readLittleEndianInt24() {\n    return (data[position++] & 0xFF)\n        | (data[position++] & 0xFF) << 8\n        | (data[position++] & 0xFF) << 16;\n  }\n  /**\n   * Reads the next three bytes as an unsigned value in little endian order.\n   */\n  public int readLittleEndianUnsignedInt24() {\n    return (data[position++] & 0xFF)\n        | (data[position++] & 0xFF) << 8\n        | (data[position++] & 0xFF) << 16;\n  }\n  /**\n   * Reads the next four bytes as an unsigned value.\n   */\n  public long readUnsignedInt() {\n    return (data[position++] & 0xFFL) << 24\n        | (data[position++] & 0xFFL) << 16\n        | (data[position++] & 0xFFL) << 8\n        | (data[position++] & 0xFFL);\n  }\n  /**\n   * Reads the next four bytes as an unsigned value in little endian order.\n   */\n  public long readLittleEndianUnsignedInt() {\n    return (data[position++] & 0xFFL)<fim_middle>// class below is blob\n"}