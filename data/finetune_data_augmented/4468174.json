{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Generated by http://code.google.com/p/protostuff/ ... DO NOT EDIT!\n// Generated from protobuf\n\npackage org.apache.drill.exec.proto.beans;\n\nimport java.io.Externalizable;\nimport java.io.IOException;\nimport java.io.ObjectInput;\nimport java.io.ObjectOutput;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport com.dyuproject.protostuff.GraphIOUtil;\nimport com.dyuproject.protostuff.Input;\nimport com.dyuproject.protostuff.Message;\nimport com.dyuproject.protostuff.Output;\nimport com.dyuproject.protostuff.Schema;\n\npublic final class Collector implements Externalizable, Message<Collector>, Schema<Collector>\n{\n\n    public static Schema<Collector> getSchema()\n    {\n        return DEFAULT_INSTANCE;\n    }\n\n    public static Collector getDefaultInstance()\n    {\n        return DEFAULT_INSTANCE;\n    }\n\n    static final Collector DEFAULT_INSTANCE = new Collector();\n\n    \n    private int oppositeMajorFragmentId;\n    private List<Integer> incomingMinorFragment;\n    private Boolean supportsOutOfOrder;\n    private Boolean isSpooling;\n\n    public Collector()\n    {\n        \n    }\n\n    // getters and setters\n\n    // oppositeMajorFragmentId\n\n    public int getOppositeMajorFragmentId()\n    {\n        return oppositeMajorFragmentId;\n    }\n\n    public Collector setOppositeMajorFragmentId(int oppositeMajorFragmentId)\n    {\n        this.oppositeMajorFragmentId = oppositeMajorFragmentId;\n        return this;\n    }\n\n    // incomingMinorFragment\n\n    public List<Integer> getIncomingMinorFragmentList()\n    {\n        return incomingMinorFragment;\n    }\n\n<fim_suffix>    public Collector setIncomingMinorFragmentList(List<Integer> incomingMinorFragment)\n    {\n        this.incomingMinorFragment = incomingMinorFragment;\n        return this;\n    }\n\n    // supportsOutOfOrder\n\n    public Boolean getSupportsOutOfOrder()\n    {\n        return supportsOutOfOrder;\n    }\n\n    public Collector setSupportsOutOfOrder(Boolean supportsOutOfOrder)\n    {\n        this.supportsOutOfOrder = supportsOutOfOrder;\n        return this;\n    }\n\n    // isSpooling\n\n    public Boolean getIsSpooling()\n    {\n        return isSpooling;\n    }\n\n    public Collector setIsSpooling(Boolean isSpooling)\n    {\n        this.isSpooling = isSpooling;\n        return this;\n    }\n\n    // java serialization\n\n    public void readExternal(ObjectInput in) throws IOException\n    {\n        GraphIOUtil.mergeDelimitedFrom(in, this, this);\n    }\n\n    public void writeExternal(ObjectOutput out) throws IOException\n    {\n        GraphIOUtil.writeDelimitedTo(out, this, this);\n    }\n\n    // message method\n\n    public Schema<Collector> cachedSchema()\n    {\n        return DEFAULT_INSTANCE;\n    }\n\n    // schema methods\n\n    public Collector newMessage()\n    {\n        return new Collector();\n    }\n\n    public Class<Collector> typeClass()\n    {\n        return Collector.class;\n    }\n\n    public String messageName()\n    {\n        return Collector.class.getSimpleName();\n    }\n\n    public String messageFullName()\n    {\n        return Collector.class.getName();\n    }\n\n    public boolean isInitialized(Collector message)\n    {\n        return true;\n    }\n\n    public void mergeFrom(Input input, Collector message) throws IOException\n    {\n        for(int number = input.readFieldNumber(this);; number = input.readFieldNumber(this))\n        {\n            switch(number)\n            {\n                case 0:\n                    return;\n                case 1:\n                    message.oppositeMajorFragmentId = input.readInt32();\n                    break;\n                case 2:\n                    if(message.incomingMinorFragment == null)\n                        message.incomingMinorFragment = new ArrayList<Integer>();\n                    message.incomingMinorFragment.add(input.readInt32());\n                    break;\n                case 3:\n                    message.supportsOutOfOrder = input.readBool();\n                    break;\n                case 4:\n                    message.isSpooling = input.readBool();\n                    break;\n                default:\n                    input.handleUnknownField(number, this);\n            }   \n        }\n    }\n\n\n    public void writeTo(Output output, Collector message) throws IOException\n    {\n        if(message.oppositeMajorFragmentId != 0)\n            output.writeInt32(1, message.oppositeMajorFragmentId, false);\n\n        if(message.incomingMinorFragment != null)\n        {\n            for(Integer incomingMinorFragment : message.incomingMinorFragment)\n            {\n                if(incomingMinorFragment != null)\n                    output.writeInt32(2, incomingMinorFragment, true);\n            }\n        }\n\n        if(message.supportsOutOfOrder != null)\n            output.writeBool(3, message.supportsOutOfOrder, false);\n\n        if(message.isSpooling != null)\n            output.writeBool(4, message.isSpooling, false);\n    }\n\n    public String getFieldName(int number)\n    {\n        switch(number)\n        {\n            case 1: return \"oppositeMajorFragmentId\";\n            case 2: return \"incomingMinorFragment\";\n            case 3: return \"supportsOutOfOrder\";\n            case 4: return \"isSpooling\";\n            default: return null;\n        }\n    }\n\n    public int getFieldNumber(String name)\n    {\n        final Integer number = __fieldMap.get(name);\n        return number == null ? 0 : number.intValue();\n    }\n\n    private static final java.util.HashMap<String,Integer> __fieldMap = new java.util.HashMap<String,Integer>();\n    static\n    {\n        __fieldMap.put(\"oppositeMajorFragmentId\", 1);\n        __fieldMap.put(\"incomingMinorFragment\", 2);\n        __fieldMap.put(\"supportsOutOfOrder\", 3);\n        __fieldMap.put(\"isSpooling\", 4);\n    }\n    \n}<fim_middle>// function below has no smell\n"}