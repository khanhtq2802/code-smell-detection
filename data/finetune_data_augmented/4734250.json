{"text": "<fim_prefix>/*\n * Copyright (c) 2016 Uber Technologies, Inc. (hoodie-dev-group@uber.com)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *          http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.uber.hoodie.common.model;\nimport com.fasterxml.jackson.annotation.JsonAutoDetect;\nimport com.fasterxml.jackson.annotation.JsonIgnoreProperties;\nimport com.fasterxml.jackson.annotation.PropertyAccessor;\nimport com.fasterxml.jackson.databind.DeserializationFeature;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.hadoop.fs.Path;\nimport org.apache.log4j.LogManager;\nimport org.apache.log4j.Logger;\n/**\n * All the metadata that gets stored along with a commit.\n */\n@JsonIgnoreProperties(ignoreUnknown = true)\npublic class HoodieCommitMetadata implements Serializable {\n  private static volatile Logger log = LogManager.getLogger(HoodieCommitMetadata.class);\n  protected Map<String, List<HoodieWriteStat>> partitionToWriteStats;\n  protected Boolean compacted;\n  private Map<String, String> extraMetadataMap;\n  // for ser/deser\n  public HoodieCommitMetadata() {\n    this(false);\n  }\n  public HoodieCommitMetadata(boolean compacted) {\n    extraMetadataMap = new HashMap<>();\n    partitionToWriteStats = new HashMap<>();\n    this.compacted = compacted;\n  }\n  public void addWriteStat(String partitionPath, HoodieWriteStat stat) {\n    if (!partitionToWriteStats.containsKey(partitionPath)) {\n      partitionToWriteStats.put(partitionPath, new ArrayList<>());\n    }\n    partitionToWriteStats.get(partitionPath).add(stat);\n  }\n  public void addMetadata(String metaKey, String value) {\n    extraMetadataMap.put(metaKey, value);\n  }\n  public List<HoodieWriteStat> getWriteStats(String partitionPath) {\n    return partitionToWriteStats.get(partitionPath);\n  }\n  public Map<String, String> getExtraMetadata() {\n    return extraMetadataMap;\n  }\n  public Map<String, List<HoodieWriteStat>> getPartitionToWriteStats() {\n    return partitionToWriteStats;\n  }\n  public String getMetadata(String metaKey) {\n    return extraMetadataMap.get(metaKey);\n  }\n  public Boolean getCompacted() {\n    return compacted;\n  }\n  public void setCompacted(Boolean compacted) {\n    this.compacted = compacted;\n  }\n  public HashMap<String, String> getFileIdAndRelativePaths() {\n    HashMap<String, String> filePaths = new HashMap<>();\n    // list all partitions paths\n    for (Map.Entry<String, List<HoodieWriteStat>> entry : getPartitionToWriteStats().entrySet()) {\n      for (HoodieWriteStat stat : entry.getValue()) {\n        filePaths.put(stat.getFileId(), stat.getPath());\n      }\n    }\n    return filePaths;\n  }\n  public HashMap<String, String> getFileIdAndFullPaths(String basePath) {\n    HashMap<String, String> fullPaths = new HashMap<>();\n    for (Map.Entry<String, String> entry : getFileIdAndRelativePaths().entrySet()) {\n      String fullPath =\n          (entry.getValue() != null) ? (new Path(basePath, entry.getValue())).toString() : null;\n      fullPaths.put(entry.getKey(), fullPath);\n    }\n    return fullPaths;\n  }\n  public String toJsonString() throws IOException {\n    if (partitionToWriteStats.containsKey(null)) {\n      log.info(\"partition path is null for \" + partitionToWriteStats.get(null));\n      partitionToWriteStats.remove(null);\n    }\n    return getObjectMapper().writerWithDefaultPrettyPrinter().writeValueAsString(this);\n  }\n  public static <T> T fromJsonString(String jsonStr, Class<T> clazz) throws Exception {\n    if (jsonStr == null || jsonStr.isEmpty()) {\n      // For empty commit file (no data or somethings bad happen).\n      return clazz.newInstance();\n    }\n    return getObjectMapper().readValue(jsonStr, clazz);\n  }\n  // Here the functions are named \"fetch\" instead of \"get\", to get avoid of the json conversion.\n  public long fetchTotalPartitionsWritten() {\n    return partitionToWriteStats.size();\n  }\n  public long fetchTotalFilesInsert() {\n    long totalFilesInsert = 0;\n    for (List<HoodieWriteStat> stats : partitionToWriteStats.values()) {\n      for (HoodieWriteStat stat : stats) {\n        if (stat.getPrevCommit() != null && stat.getPrevCommit().equals(\"null\")) {\n          totalFilesInsert++;\n        }\n      }\n    }\n    return totalFilesInsert;\n  }\n  public long fetchTotalFilesUpdated() {\n    long totalFilesUpdated = 0;\n    for (List<HoodieWriteStat> stats : partitionToWriteStats.values()) {\n      for (HoodieWriteStat stat : stats) {\n        if (stat.getPrevCommit() != null && !stat.getPrevCommit().equals(\"null\")) {\n          totalFilesUpdated++;\n        }\n      }\n    }\n    return totalFilesUpdated;\n  }\n  public long fetchTotalUpdateRecordsWritten() {\n    long totalUpdateRecordsWritten = 0;\n    for (List<HoodieWriteStat> stats : partitionToWriteStats.values()) {\n      for (HoodieWriteStat stat : stats) {\n        totalUpdateRecordsWritten += stat.getNumUpdateWrites();\n      }\n    }\n    return totalUpdateRecordsWritten;\n  }\n  public long fetchTotalInsertRecordsWritten() {\n    long totalInsertRecordsWritten = 0;\n    for (List<HoodieWriteStat> stats : partitionToWriteStats.values()) {\n      for (HoodieWriteStat stat : stats) {\n        if (stat.getPrevCommit() != null && stat.getPrevCommit().equals(\"null\")) {\n          totalInsertRecordsWritten += stat.getNumWrites();\n        }\n      }\n    }\n    return totalInsertRecordsWritten;\n  }\n  public long fetchTotalRecordsWritten() {\n    long totalRecordsWritten = 0;\n    for (List<HoodieWriteStat> stats : partitionToWriteStats.values()) {\n      for (HoodieWriteStat stat : stats) {\n        totalRecordsWritten += stat.getNumWrites();\n      }\n    }\n    return totalRecordsWritten;\n  }\n  public long fetchTotalBytesWritten() {\n    long totalBytesWritten = 0;\n    for (List<HoodieWriteStat> stats : partitionToWriteStats.values()) {\n      for (HoodieWriteStat stat : stats) {\n        totalBytesWritten += stat.getTotalWriteBytes();\n      }\n    }\n    return totalBytesWritten;\n  }\n  public long fetchTotalWriteErrors() {\n    long totalWriteErrors = 0;\n    for (List<HoodieWriteStat> stats : partitionToWriteStats.values()) {\n      for (HoodieWriteStat stat : stats) {\n        totalWriteErrors += stat.getTotalWriteErrors();\n      }\n    }\n    return totalWriteErrors;\n  }\n  public long getTotalRecordsDeleted() {\n    long totalDeletes = 0;\n    for (List<HoodieWriteStat> stats : partitionToWriteStats.values()) {\n      for (HoodieWriteStat stat : stats) {\n        totalDeletes += stat.getNumDeletes();\n      }\n    }\n    return totalDeletes;\n  }\n<fim_suffix>  public Long getTotalLogRecordsCompacted() {\n    Long totalLogRecords = 0L;\n    for (Map.Entry<String, List<HoodieWriteStat>> entry : partitionToWriteStats.entrySet()) {\n      for (HoodieWriteStat writeStat : entry.getValue()) {\n        totalLogRecords += writeStat.getTotalLogRecords();\n      }\n    }\n    return totalLogRecords;\n  }\n  public Long getTotalLogFilesCompacted() {\n    Long totalLogFiles = 0L;\n    for (Map.Entry<String, List<HoodieWriteStat>> entry : partitionToWriteStats.entrySet()) {\n      for (HoodieWriteStat writeStat : entry.getValue()) {\n        totalLogFiles += writeStat.getTotalLogFilesCompacted();\n      }\n    }\n    return totalLogFiles;\n  }\n  public Long getTotalCompactedRecordsUpdated() {\n    Long totalUpdateRecords = 0L;\n    for (Map.Entry<String, List<HoodieWriteStat>> entry : partitionToWriteStats.entrySet()) {<fim_middle>// function below has no smell\n"}