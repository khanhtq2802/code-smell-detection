{"text": "<fim_prefix>/*\n * Copyright (c) 2011, 2018, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage org.graalvm.compiler.graph;\nimport java.util.AbstractList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.RandomAccess;\nimport org.graalvm.compiler.graph.iterators.NodeIterable;\npublic abstract class NodeList<T extends Node> extends AbstractList<T> implements NodeIterable<T>, RandomAccess {\n    protected static final Node[] EMPTY_NODE_ARRAY = new Node[0];\n    protected final Node self;\n    protected Node[] nodes;\n    private int size;\n    protected final int initialSize;\n    protected NodeList(Node self) {\n        this.self = self;\n        this.nodes = EMPTY_NODE_ARRAY;\n        this.initialSize = 0;\n    }\n    protected NodeList(Node self, int initialSize) {\n        this.self = self;\n        this.size = initialSize;\n        this.initialSize = initialSize;\n        this.nodes = new Node[initialSize];\n    }\n    protected NodeList(Node self, T[] elements) {\n        this.self = self;\n        if (elements == null || elements.length == 0) {\n            this.size = 0;\n            this.nodes = EMPTY_NODE_ARRAY;\n            this.initialSize = 0;\n        } else {\n            this.size = elements.length;\n            this.initialSize = elements.length;\n            this.nodes = new Node[elements.length];\n            for (int i = 0; i < elements.length; i++) {\n                this.nodes[i] = elements[i];\n                assert this.nodes[i] == null || !this.nodes[i].isDeleted() : \"Initializing nodelist with deleted element : \" + nodes[i];\n            }\n        }\n    }\n    protected NodeList(Node self, List<? extends T> elements) {\n        this.self = self;\n        if (elements == null || elements.isEmpty()) {\n            this.size = 0;\n            this.nodes = EMPTY_NODE_ARRAY;\n            this.initialSize = 0;\n        } else {\n            this.size = elements.size();\n            this.initialSize = elements.size();\n            this.nodes = new Node[elements.size()];\n            for (int i = 0; i < elements.size(); i++) {\n                this.nodes[i] = elements.get(i);\n                assert this.nodes[i] == null || !this.nodes[i].isDeleted();\n            }\n        }\n    }\n    protected NodeList(Node self, Collection<? extends NodeInterface> elements) {\n        this.self = self;\n        if (elements == null || elements.isEmpty()) {\n            this.size = 0;\n            this.nodes = EMPTY_NODE_ARRAY;\n            this.initialSize = 0;\n        } else {\n            this.size = elements.size();\n            this.initialSize = elements.size();\n            this.nodes = new Node[elements.size()];\n            int i = 0;\n            for (NodeInterface n : elements) {\n                this.nodes[i] = n.asNode();\n                assert this.nodes[i] == null || !this.nodes[i].isDeleted();\n                i++;\n            }\n        }\n    }\n    public boolean isList() {\n        return true;\n    }\n    protected abstract void update(T oldNode, T newNode);\n    public abstract Edges.Type getEdgesType();\n    @Override\n    public final int size() {\n        return size;\n    }\n    @Override\n    public final boolean isEmpty() {\n        return size == 0;\n    }\n<fim_suffix>    @Override\n    public boolean isNotEmpty() {\n        return size > 0;\n    }\n    @Override\n    public int count() {\n        return size;\n    }\n    protected final void incModCount() {\n        modCount++;\n    }\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public boolean add(Node node) {\n        assert node == null || !node.isDeleted();\n        self.incModCount();\n        incModCount();\n        int length = nodes.length;\n        if (length == 0) {\n            nodes = new Node[2];\n        } else if (size == length) {\n            Node[] newNodes = new Node[nodes.length * 2 + 1];\n            System.arraycopy(nodes, 0, newNodes, 0, length);\n            nodes = newNodes;\n        }\n        nodes[size++] = node;\n        update(null, (T) node);\n        return true;\n    }\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public T get(int index) {\n        assert assertInRange(index);\n        return (T) nodes[index];\n    }\n    private boolean assertInRange(int index) {\n        assert index >= 0 && index < size() : index + \" < \" + size();\n        return true;\n    }\n    public T last() {\n        return get(size() - 1);\n    }\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public T set(int index, Node node) {\n        incModCount();\n        T oldValue = (T) nodes[index];\n        assert assertInRange(index);\n        update((T) nodes[index], (T) node);\n        nodes[index] = node;\n        return oldValue;\n    }\n    public void initialize(int index, Node node) {\n        incModCount();\n        assert index < size();\n        nodes[index] = node;\n    }\n    void copy(NodeList<? extends Node> other) {\n        self.incModCount();\n        incModCount();\n        Node[] newNodes = new Node[other.size];\n        System.arraycopy(other.nodes, 0, newNodes, 0, newNodes.length);\n        nodes = newNodes;\n        size = other.size;\n    }\n    public boolean equals(NodeList<T> other) {\n        if (size != other.size) {\n            return false;\n        }\n        for (int i = 0; i < size; i++) {\n            if (nodes[i] != other.nodes[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public void clear() {\n        self.incModCount();\n        incModCount();\n        for (int i = 0; i < size; i++) {\n            update((T) nodes[i], null);\n        }\n        clearWithoutUpdate();\n    }\n    void clearWithoutUpdate() {\n        nodes = EMPTY_NODE_ARRAY;\n        size = 0;\n    }\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public boolean remove(Object node) {\n        self.incModCount();\n        int i = 0;\n        incModCount();\n        while (i < size && nodes[i] != node) {\n            i++;\n        }\n        if (i < size) {\n            T oldValue = (T) nodes[i];\n            i++;\n            while (i < size) {\n                nodes[i - 1] = nodes[i];\n                i++;\n            }\n            nodes[--size] = null;\n            update(oldValue, null);\n            return true;\n        } else {\n            return false;\n        }\n    }\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public T remove(int index) {\n        self.incModCount();\n        T oldValue = (T) nodes[index];\n        int i = index + 1;\n        incModCount();\n        while (i < size) {\n            nodes[i - 1] = nodes[i];\n            i++;\n        }\n        nodes[--size] = null;\n        update(oldValue, null);\n        return oldValue;\n    }\n    boolean replaceFirst(Node node, Node other) {\n        for (int i = 0; i < size; i++) {\n            if (nodes[i] == node) {\n                nodes[i] = other;\n                return true;\n            }\n        }\n        return false;\n    }\n    @Override<fim_middle>// function below has no smell\n"}