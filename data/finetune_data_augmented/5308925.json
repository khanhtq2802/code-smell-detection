{"text": "<fim_prefix> * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.openjpa.kernel;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.Arrays;\nimport org.apache.openjpa.enhance.Reflection;\nimport org.apache.openjpa.lib.util.Localizer;\n/**\n * A strategy to fill data into a {@link ResultShape}.\n * <BR>\n * Available strategy implementations can fill by invoking constructor, setting array elements, direct assignment,\n * invoking put(key,value)-style method on Map or factory-constructed instance.\n *\n * @author Pinaki Poddar\n *\n * @since 2.0.0\n *\n */\n<fim_suffix>public interface FillStrategy<T> {\n    Localizer _loc = Localizer.forPackage(FillStrategy.class);\n    T fill(Object[] data, Class<?>[] types, String[] aliases);\n    /**\n     * Fills an array of given type.\n     *\n     * @param <T> must be an array type.\n     */\n    public static class Array<T> implements FillStrategy<T> {\n        private final Class<?> cls;\n        public Array(Class<T> arrayCls) {\n            if (arrayCls == null || !arrayCls.isArray())\n                throw new IllegalArgumentException(_loc.get(\"fill-bad-array\", arrayCls).getMessage());\n            this.cls = arrayCls.getComponentType();\n        }\n        @Override\n        public T fill(Object[] values, Class<?>[] types, String[] aliases) {\n            Object array = java.lang.reflect.Array.newInstance(cls, values.length);\n            System.arraycopy(values, 0, array, 0, values.length);\n            return (T)array;\n        }\n    }\n    /**\n     * Construct and populate an instance by invoking the put method\n     * with each alias as key and element of the given array of values.\n     *\n     * The instance is a created by the no-argument constructor of the declaring class of the given method.\n     */\n    public static class Map<T> implements FillStrategy<T> {\n        private final Method putMethod;\n        public Map(Method put) {\n            if (put == null || put.getParameterTypes().length != 2)\n                throw new IllegalArgumentException(_loc.get(\"fill-bad-put\", put).getMessage());\n            putMethod = put;\n        }\n        @Override\n        public T fill(Object[] values, Class<?>[] types, String[] aliases) {\n            int i = 0;\n            try {\n                Object map = putMethod.getDeclaringClass().newInstance();\n                for (i = 0; i < values.length; i++)\n                    putMethod.invoke(map, aliases[i], values[i]);\n                return (T)map;\n            } catch (InvocationTargetException t) {\n                throw new RuntimeException(_loc.get(\"fill-map-error\", putMethod, aliases[i], values[i]).getMessage(),\n                    t.getTargetException());\n            } catch (Exception e) {\n                throw new RuntimeException(_loc.get(\"fill-map-error\", putMethod, aliases[i], values[i]).getMessage(),\n                        e);\n            }\n        }\n    }\n    /**\n     * Construct and populate an instance by the given constructor and arguments.\n     */\n    public static class NewInstance<T> implements FillStrategy<T> {\n        private Constructor<? extends T> cons;\n        private Class<T> cls;\n        public NewInstance(Constructor<? extends T> cons) {\n            this.cons = cons;\n        }\n        public NewInstance(Class<T> cls) {\n            this.cls = cls;\n        }\n        /**\n         * Finds a constructor of the given class with given argument types.\n         */\n        <X> Constructor<X> findConstructor(Class<X> cls, Class<?>[] types) {\n            try {\n                return cls.getConstructor(types);\n            } catch (Exception e) {\n                Constructor<?>[] constructors = cls.getConstructors();\n                for (Constructor<?> cons : constructors) {\n                    Class<?>[] paramTypes = cons.getParameterTypes();\n                    boolean match = false;\n                    if (paramTypes.length == types.length) {\n                        for (int i = 0; i < paramTypes.length; i++) {\n                            match = paramTypes[i].isAssignableFrom(Filters.wrap(types[i]));\n                            if (!match)\n                                break;\n                            }\n                        }\n                        if (match) {\n                            return (Constructor<X>)cons;\n                        }\n                }\n            }\n            throw new RuntimeException(_loc.get(\"fill-ctor-none\", cls, Arrays.toString(types)).getMessage());\n        }\n        @Override\n        public T fill(Object[] values, Class<?>[] types, String[] aliases) {\n            if (cons == null) {\n                cons = findConstructor(cls, types);\n            }\n            try {\n                for (int i = 0; i < values.length; i++) {\n                    values[i] = Filters.convert(values[i], types[i]);\n                }\n                return cons.newInstance(values);\n            } catch (Exception e) {\n                throw new RuntimeException(_loc.get(\"fill-ctor-error\", cons, Arrays.toString(values),\n                        Arrays.toString(types)).getMessage(), e);\n            }\n        }\n    }\n    /**\n     * Create and populate a bean by invoking setter methods identified by alias name with each array\n     * element value as argument.\n     */\n    public static class Bean<T> implements FillStrategy<T> {\n        private final Class<T> cls;\n        private Method[] setters;\n        public Bean(Class<T> cls) {\n            this.cls = cls;\n        }\n        @Override\n        public T fill(Object[] values, Class<?>[] types, String[] aliases) {\n            int i = 0;\n            try {\n                if (setters == null) {\n                    setters = new Method[values.length];\n                }\n                T bean = cls.newInstance();\n                for (i = 0; i < values.length; i++) {\n                    if (setters[i] == null) {\n                        setters[i] = Reflection.findSetter(cls, aliases[i], false);\n                        if (setters[i] == null)\n                            throw new RuntimeException(_loc.get(\"fill-bean-setter\", cls, aliases[i]).getMessage());\n                    }\n                    setters[i].invoke(bean, Filters.convert(values[i], types[i]));\n                }\n                return bean;\n            } catch (InvocationTargetException t) {\n                throw new RuntimeException(_loc.get(\"fill-bean-error\", setters[i], values[i], types[i]).getMessage(),\n                        t.getTargetException());\n            } catch (Exception e) {\n                throw new RuntimeException(_loc.get(\"fill-bean-error\", setters[i], values[i], types[i]).getMessage(),\n                        e);\n            }\n        }\n    }\n    /**\n     * Populate an instance by simply assigning the 0-th element of the input values.\n     */\n    public static class Assign<T> implements FillStrategy<T> {\n        @Override\n        public T fill(Object[] values, Class<?>[] types, String[] aliases) {\n            try {\n                return (T)values[0];\n            } catch (Exception e) {\n                throw new RuntimeException(_loc.get(\"fill-assign-error\", Arrays.toString(values),\n                        Arrays.toString(types)).getMessage(), e);\n            }\n        }\n    }\n    /**\n     * Populate an instance created by given factory using a given put(key,value) method.\n     * If the first argument of the given put method is integer then fill the values\n     * by index else fill the values with alias key.\n     */\n    public static class Factory<T> implements FillStrategy<T> {\n        final ObjectFactory<T> factory;\n        final Method putMethod;\n        final boolean isArray;\n        public Factory(ObjectFactory<T> factory, Method put) {\n            this.factory = factory;\n            this.putMethod = put;\n            if (put == null || put.getParameterTypes().length != 2)\n                throw new IllegalArgumentException(_loc.get(\"fill-factory-bad-put\", put).getMessage());\n            Class<?> keyType = putMethod.getParameterTypes()[0];\n            this.isArray = keyType == int.class || keyType == Integer.class;\n        }\n        @Override\n        public T fill(Object[] values, Class<?>[] types, String[] aliases) {\n            int i = 0;\n            Object key = null;\n            T result = factory.newInstance();\n            try {\n                for (i = 0; i < values.length; i++) {\n                    key = isArray ? i : aliases[i];\n                    putMethod.invoke(result, key, Filters.convert(values[i], types[i]));\n                }\n                return result;\n            } catch (InvocationTargetException t) {\n                throw new RuntimeException(_loc.get(\"fill-factory-error\", new Object[]{putMethod, key, values[i],\n                        types[i]}).getMessage(), t.getTargetException());\n            } catch (Exception e) {\n                throw new RuntimeException(_loc.get(\"fill-factory-error\", new Object[]{putMethod, key, values[i],\n                        types[i]}).getMessage(), e);\n            }\n        }\n    }\n}<fim_middle>// class below has no smell\n"}