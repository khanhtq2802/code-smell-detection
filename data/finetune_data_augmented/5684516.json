{"text": "<fim_prefix>    // while (confidenceTriple.hasNext()) {\n    // loseConfidence.remove(confidenceTriple.next());\n    // }\n    // }\n    // return loseConfidence;\n    // }\n    /**\n     * Applies the disambiguation results to the suggestions of the {@link SavedEntity}.\n     * <p>\n     * This method modifies the state of the {@link SavedEntity#getSuggestions()}\n     * \n     * @param results\n     *            the results of the disambiguation request\n     * @param savedEntity\n     *            the saved entity to be disambiguated\n     **/\n    protected void disambiguateSuggestions(QueryResultList<Entity> results, SavedEntity savedEntity) {\n        // NOTE (rwesten) We should not score disambiguation results based on\n        // how well the labels match.\n        // Either use directly the scores of the disambiguation results OR\n        // do combine the confidence of the original suggestion with the\n        // scores of the disambiguation\n        /*\n         * Algorithm: Combine original confidence with Disambiguation results\n         * \n         * Parameter(s):\n         * \n         * * ratio configured as '{dr}:{cr}' where 'dr' stands for the ratio for the disambiguation score and\n         * 'cr' stand for the ratio for the original fise:confidence of a suggestion (default 1:1) *\n         * disambiguation weight (dw) := dr/(dr+cr) ... already calculated based on the configured ratio in\n         * #disambiguationWeight * confidence weight (cw) := cw/(dr+cr) ... already calculated based on the\n         * configured ratio in #confidenceWeight\n         * \n         * Input(s):\n         * \n         * * confidence (c): the original confidence of a suggestion (range [0..1]) * score (s): the score of\n         * the disambiguation * maximum score (ms): the maximum disambiguation score\n         * \n         * Output\n         * \n         * * disambiguated confidence (dc): the confidence after disambiguation\n         * \n         * Algorithm:\n         * \n         * * normalized score (ns) := s/ms ... ensures range [0..1] for disambiguation scores * disambiguated\n         * confidence = c*cw+ns*dw ... guaranteed to be [0..1]\n         */\n        List<Suggestion> matches = new ArrayList<Suggestion>(results.size());\n        Float maxScore = null;\n        Float maxSuggestedScore = null;\n        Iterator<Entity> guesses = results.iterator();\n        log.info(\"disambiguate {}: \", savedEntity.getName());\n        while (guesses.hasNext()) {\n            Entity guess = guesses.next();\n            Float score =\n                    guess.getRepresentation().getFirst(RdfResourceEnum.resultScore.getUri(), Float.class);\n            if (score == null) {\n                log.warn(\"Missing Score for Entityhub Query Result {}!\", guess.getId());\n                continue;\n            }\n            if (maxScore == null) {\n                maxScore = score;\n            }\n            IRI uri = new IRI(guess.getId());\n            Suggestion suggestion = savedEntity.getSuggestion(uri);\n            if (suggestion == null) {\n                log.info(\" - not found {}\", guess.getId());\n                continue;\n            }\n            if (maxSuggestedScore == null) {\n                maxSuggestedScore = score;\n            }\n            double c = suggestion.getOriginalConfidnece() == null ? 0 : suggestion.getOriginalConfidnece();\n            // TODO (rwesten) we need to find out if we should normalize based on the\n            // maximum score or the maximum score of an suggested one\n            double ns = score / maxSuggestedScore;\n            suggestion.setNormalizedDisambiguationScore(ns);\n            double dc = c * confidenceWeight + ns * disambiguationWeight;\n            suggestion.setDisambiguatedConfidence(dc);\n            log.info(\"  - found {}, origConf:{}, disScore:{}, disConf:{}\",\n                new Object[] {suggestion.getEntityUri(), c, ns, dc});\n        }\n        // if at least one suggestion was also in the disambiguation result\n        if (maxSuggestedScore != null) {\n            // adapt the confidence of suggestions that where not part of the\n            // disambiguation result\n            for (Suggestion suggestion : savedEntity.getSuggestions()) {\n                if (suggestion.getDisambiguatedConfidence() == null) {\n                    double c =\n                            suggestion.getOriginalConfidnece() == null ? 0 : suggestion\n                                    .getOriginalConfidnece();\n                    suggestion.setDisambiguatedConfidence(c * confidenceWeight);\n                }\n            }\n        } else { // else keep the original results\n            log.info(\"  - none found\");\n        }\n    }\n    /*\n     * Checks if there is any common elements amongst the ambiguations amongst latest dbpedia query and intial\n     * ambiguations\n     */\n    // NOTE (rwesten): now done as part of the disambiguateSuggestions(..)\n    // method.\n    // protected boolean intersectionCheck(List<Suggestion> matches,\n    // List<IRI> subsumed,\n    // Graph graph,\n    // String contentLangauge) {\n    // for (int i = 0; i < subsumed.size(); i++) {\n    // IRI uri = subsumed.get(i);\n    //\n    // IRI uri1 = EnhancementEngineHelper.getReference(graph, uri, new IRI(NamespaceEnum.fise\n    // + \"entity-reference\"));\n    //\n    // String selectedText = EnhancementEngineHelper.getString(graph, uri, ENHANCER_ENTITY_LABEL);\n    //\n    // if (selectedText == null) {\n    // continue;\n    // }\n    //\n    // for (int j = 0; j < matches.size(); j++) {\n    // Suggestion suggestion = matches.get(j);\n    // String suggestName = suggestion.getURI();\n    // if (suggestName.compareToIgnoreCase(uri1.getUnicodeString()) == 0) return true;\n    // }\n    // }\n    // return false;\n    // }\n    // NOTE (rwesten): one MUST NOT store information of processed ContentItems\n    // as member variables, as one EnhancementEngine instance is\n    // concurrently used to process multiple ContentItems. Because\n    // of that member variables will have data of different\n    // ContentItems!\n    // All those data need to be hold in information that are local\n    // to the processing of a single ContentItem (similar to\n    // SavedEntity).\n    // NOTE moved the DisambiguationData#directoryTextAnotation\n    // public Map<Integer,String> directoryTextAnotation = new HashMap<Integer,String>();\n    // TODO: make configureable\n    int radii = 23;\n    // Value to be configured\n    public boolean toInclude(int k, int s) {\n        if (Math.abs(k - s) < radii && Math.abs(k - s) > 0) {\n            return true;\n        }\n        return false;\n    }\n    /*\n     * TODO: rwesten I do not understand what is the intension of this Adding the fise:selection-context of\n     * all entities within a range of #radii characters seams not to be a great way to build a context (or do\n     * i miss something?\n     */\n    @Deprecated\n    // for now until someone can answer the anove question\n    public List<String> EntitiesInRange(NavigableMap<Integer,SavedEntity> map, int radius) {\n        List<String> temp = new ArrayList<String>();\n        // TODO: reimplement using subMap of the parsed NavigableMap map\n        for (Entry<Integer,SavedEntity> entry : map.entrySet()) {\n            Integer s = entry.getKey();\n            String subs = entry.getValue().getContext();\n            if (toInclude(s, radius)) {\n                temp.add(subs);\n            }\n        }\n        return temp; // if(Cal(f,k))\n    }\n    /**\n     * Returns a list of all fise:selected-text values occurring in the parsed context (excluding the parsed\n     * label if not null\n     * \n     * @param label\n     *            The label of the current Entity. parse <code>null</code> if the current label should not be\n     *            ignored (and included in the context)\n     * @param allEntities\n     *            The collections with all the fise:selection-text values of all fise:TextAnnotations\n     * @param context\n     * @return\n     */\n<fim_suffix>    protected List<String> getSelectionsInContext(String label, Collection<String> allEntities, String context) {\n        List<String> allEntityString = new ArrayList<String>();\n        for (String selectedText : allEntities) {\n            if (context.contains(selectedText) && selectedText.compareToIgnoreCase(label) != 0) {\n                allEntityString.add(selectedText);\n            }\n        }\n        return allEntityString;\n    }<fim_middle>// function below has no smell\n"}