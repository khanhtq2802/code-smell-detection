{"text": "<fim_prefix>\t\t\t\t\t/ LOG_10;\n\t\t\tdouble dValueLog = Math.log( dValue ) / LOG_10;\n\t\t\treturn da.getStart( )\n\t\t\t\t\t+ ( ( ( dValueLog - dMinimumLog ) / dStepLog ) * da.getStep( ) );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdouble dValue = iv.getValueAsDouble( sc );\n\t\t\tdouble dMinimum = asDouble( sc.getMinimum( ) ).doubleValue( );\n\t\t\tdouble dMaximum = asDouble( sc.getMaximum( ) ).doubleValue( );\n\t\t\tdouble[] ea = sc.getEndPoints( );\n\t\t\tif ( dMaximum == dMinimum )\n\t\t\t{\n\t\t\t\treturn ea[0];\n\t\t\t}\n\t\t\t{\n\t\t\t\treturn ea[0]\n\t\t\t\t\t\t- ( ( ( dValue - dMinimum ) / ( dMaximum - dMinimum ) ) * ( ea[0] - ea[1] ) );\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * @param sc\n\t * @param oValue\n\t * @return location coordinate\n\t * @throws ChartException\n\t * @throws IllegalArgumentException\n\t */\n\tpublic static final double getLocation( AutoScale sc, Object oValue )\n\t\t\tthrows ChartException, IllegalArgumentException\n\t{\n\t\tif ( oValue == null )\n\t\t{\n\t\t\tthrow new IllegalArgumentException( MessageFormat.format( Messages.getResourceBundle( sc.getRunTimeContext( )\n\t\t\t\t\t.getULocale( ) )\n\t\t\t\t\t.getString( \"exception.scale.null.location\" ), //$NON-NLS-1$\n\t\t\t\t\tnew Object[]{\n\t\t\t\t\t\tsc\n\t\t\t\t\t} )\n\t\t\t);\n\t\t}\n\t\tif ( oValue instanceof Number )\n\t\t{\n\t\t\treturn getLocation( sc, ( (Number) oValue ).doubleValue( ) );\n\t\t}\n\t\telse if ( oValue instanceof Calendar )\n\t\t{\n\t\t\treturn getDateLocation( sc, new CDateTime( (Calendar) oValue ) );\n\t\t}\n\t\telse if ( oValue instanceof NumberDataElement )\n\t\t{\n\t\t\treturn getLocation( sc, ( (NumberDataElement) oValue ).getValue( ) );\n\t\t}\n\t\telse if ( oValue instanceof DateTimeDataElement )\n\t\t{\n\t\t\treturn getDateLocation( sc,\n\t\t\t\t\t( (DateTimeDataElement) oValue ).getValueAsCDateTime( ) );\n\t\t}\n\t\telse if ( oValue instanceof BigNumberDataElement )\n\t\t{\n\t\t\treturn getLocation( sc, (Number)((BigNumberDataElement)oValue).getValue( ) );\n\t\t}\n\t\telse if ( oValue instanceof IntersectionValue )\n\t\t{\n\t\t\treturn getLocation( sc, (IntersectionValue) oValue );\n\t\t}\n\t\t/*\n\t\t * DefaultLoggerImpl.instance().log(ILogger.WARNING, \"Unexpected data\n\t\t * type {0}[value={1}] specified\" + oValue.getClass().getName() + oValue );\n\t\t */// i18n_CONCATENATIONS_REMOVED\n\t\treturn sc.getStart( ); // RETURNS THE START EDGE OF THE SCALE\n\t}\n\t/**\n\t * @param sc\n\t * @param dValue\n\t * @return location coordinate\n\t */\n\tpublic static final double getNormalizedLocation( AutoScale sc,\n\t\t\tdouble dValue )\n\t{\n\t\treturn getLocation( sc, dValue ) - sc.getStart( );\n\t}\n\t/**\n\t * @param sc\n\t * @param oValue\n\t * @return location coordinate\n\t * @throws ChartException\n\t * @throws IllegalArgumentException\n\t */\n\tpublic static final double getNormalizedLocation( AutoScale sc,\n\t\t\tObject oValue ) throws ChartException, IllegalArgumentException\n\t{\n\t\treturn getLocation( sc, oValue ) - sc.getStart( );\n\t}\n\t/**\n\t * Computes and returns the location based on specified value and scale info.\n\t * \n\t * @param sc scale info instance.\n\t * @param bdValue specified value.\n\t * @return\n\t */\n\tpublic static final double getLocation( AutoScale sc, Number bdValue )\n\t{\n\t\tif ( sc.isBigNumber( ) )\n\t\t{\n\t\t\treturn getLocation( sc, NumberUtil.asBigDecimal( bdValue ).divide(  sc.getBigNumberDivisor( ) ).doubleValue( ) );\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn getLocation( sc, bdValue.doubleValue( ) );\n\t\t}\n\t}\n\t/**\n\t * \n\t * @param sc\n\t * @param dValue\n\t * \n\t * @return location coordinate\n\t */\n\tpublic static final double getLocation( AutoScale sc, double dValue )\n\t\t\tthrows IllegalArgumentException\n\t{\n\t\tif ( ( sc.getType( ) & IConstants.TEXT ) == IConstants.TEXT\n\t\t\t\t|| sc.isCategoryScale( ) )\n\t\t{\n\t\t\tAxisTickCoordinates da = sc.getTickCordinates( );\n\t\t\treturn da.getStart( ) + da.getStep( ) * dValue;\n\t\t}\n\t\telse if ( ( sc.getType( ) & IConstants.LINEAR ) == IConstants.LINEAR )\n\t\t{\n\t\t\tdouble dMinimum = asDouble( sc.getMinimum( ) ).doubleValue( );\n\t\t\tdouble dMaximum = asDouble( sc.getMaximum( ) ).doubleValue( );\n\t\t\tdouble[] da = sc.getEndPoints( );\n\t\t\tif ( sc.isSetFactor( ) )\n\t\t\t{\n\t\t\t\tdouble delta = ( dValue - dMinimum ) / sc.getFactor( );\n\t\t\t\treturn da[0] < da[1] ? da[0] + delta : da[0]\n\t\t\t\t\t\t- delta;\n\t\t\t}\n\t\t\tif ( dMaximum == dMinimum )\n\t\t\t{\n\t\t\t\treturn da[0];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn da[0]\n\t\t\t\t\t\t- ( ( ( dValue - dMinimum ) / ( dMaximum - dMinimum ) ) * ( da[0] - da[1] ) );\n\t\t\t}\n\t\t}\n\t\telse if ( ( sc.getType( ) & IConstants.LOGARITHMIC ) == IConstants.LOGARITHMIC )\n\t\t{\n\t\t\tif ( dValue == 0 ) // CANNOT GO TO '0'\n\t\t\t{\n\t\t\t\treturn sc.getStart( );\n\t\t\t}\n\t\t\tif ( dValue < 0 )\n\t\t\t{\n\t\t\t\tthrow new IllegalArgumentException( MessageFormat.format( Messages.getResourceBundle( sc.getRunTimeContext( )\n\t\t\t\t\t\t.getULocale( ) )\n\t\t\t\t\t\t.getString( \"exception.zero.negative.logarithmic.scale\" ), //$NON-NLS-1$\n\t\t\t\t\t\tnew Object[]{\n\t\t\t\t\t\t\tsc\n\t\t\t\t\t\t} ) );\n\t\t\t}\n\t\t\tdouble dMinimumLog = Math.log( asDouble( sc.getMinimum( ) ).doubleValue( ) )\n\t\t\t\t\t/ LOG_10;\n\t\t\tdouble dStepLog = Math.log( asDouble( sc.getStep( ) ).doubleValue( ) )\n\t\t\t\t\t/ LOG_10;\n\t\t\tdouble dValueLog = Math.log( dValue ) / LOG_10;\n\t\t\tAxisTickCoordinates da = sc.getTickCordinates( );\n\t\t\treturn da.getStart( )\n\t\t\t\t\t+ ( ( ( dValueLog - dMinimumLog ) / dStepLog ) * da.getStep( ) );\n\t\t}\n\t\treturn 0;\n\t}\n\t/**\n\t * \n\t * @param sc\n\t * @param cdt\n\t * @return\n\t */\n\tstatic final double getDateLocation( AutoScale sc, CDateTime cdtValue )\n\t{\n\t\tAxisTickCoordinates da = sc.getTickCordinates( );\n\t\tCDateTime cdtMin = asDateTime( sc.getMinimum( ) );\n\t\tCDateTime cdtMax = asDateTime( sc.getMaximum( ) );\n\t\tlong max = cdtMax.getTimeInMillis( );\n\t\tlong min = cdtMin.getTimeInMillis( );\n\t\tlong curr = cdtValue.getTimeInMillis( );\n\t\tif ( max == min )\n\t\t{\n\t\t\treturn da.getStart( );\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn da.getStart( ) +\n\t\t\t\t\t( curr - min ) *\n\t\t\t\t\t( ( da.getEnd( ) - da.getStart( ) ) / ( max - min ) );\n\t\t}\n\t}\n\t/**\n\t * \n\t * @param g2d\n\t * @param fm\n\t * @param sText\n\t * @param dAngleInDegrees\n\t * @return width\n\t */\n<fim_suffix>\tpublic static final double computeWidth( IDisplayServer xs, Label la )\n\t{\n\t\tfinal ITextMetrics itm = xs.getTextMetrics( la );\n\t\ttry\n\t\t{\n\t\t\treturn computeWidth( itm, la );\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\titm.dispose( );\n\t\t}\n\t}<fim_middle>// function below has no smell\n"}