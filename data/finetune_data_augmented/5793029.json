{"text": "<fim_prefix>    /**\n     * Sorted ngram cache for faster distance calculation.\n     */\n    private Interleaved interleaved = new Interleaved();\n    public static boolean useInterleaved = true; // For testing purposes\n    /**\n     * The sum of all ngram counts in this profile.\n     * Used to calculate relative ngram frequency.\n     */\n    private long count = 0;\n    private static class Counter {\n        private long count = 0;\n        public String toString() {\n            return Long.toString(count);\n        }\n    }\n    public LanguageProfile(int length) {\n        this.length = length;\n    }\n    public LanguageProfile() {\n        this(DEFAULT_NGRAM_LENGTH);\n    }\n    public LanguageProfile(String content, int length) {\n        this(length);\n        ProfilingWriter writer = new ProfilingWriter(this);\n        char[] ch = content.toCharArray();\n        writer.write(ch, 0, ch.length);\n    }\n    public LanguageProfile(String content) {\n        this(content, DEFAULT_NGRAM_LENGTH);\n    }\n    public long getCount() {\n        return count;\n    }\n    public long getCount(String ngram) {\n        Counter counter = ngrams.get(ngram);\n        if (counter != null) {\n            return counter.count;\n        } else {\n            return 0;\n        }\n    }\n    /**\n     * Adds a single occurrence of the given ngram to this profile.\n     *\n     * @param ngram the ngram\n     */\n    public void add(String ngram) {\n        add(ngram, 1);\n    }\n    /**\n     * Adds multiple occurrences of the given ngram to this profile.\n     *\n     * @param ngram the ngram\n     * @param count number of occurrences to add\n     */\n    public void add(String ngram, long count) {\n        if (length != ngram.length()) {\n            throw new IllegalArgumentException(\n                    \"Unable to add an ngram of incorrect length: \"\n                    + ngram.length() + \" != \" + length);\n        }\n        Counter counter = ngrams.get(ngram);\n        if (counter == null) {\n            counter = new Counter();\n            ngrams.put(ngram, counter);\n        }\n        counter.count += count;\n        this.count += count;\n    }\n    /**\n     * Calculates the geometric distance between this and the given\n     * other language profile.\n     *\n     * @param that the other language profile\n     * @return distance between the profiles\n     */\n    public double distance(LanguageProfile that) {\n        return useInterleaved ? distanceInterleaved(that) : distanceStandard(that);\n    }\n    private double distanceStandard(LanguageProfile that) {\n        if (length != that.length) {\n            throw new IllegalArgumentException(\n                    \"Unable to calculage distance of language profiles\"\n                    + \" with different ngram lengths: \"\n                    + that.length + \" != \" + length);\n        }\n        double sumOfSquares = 0.0;\n        double thisCount = Math.max(this.count, 1.0);\n        double thatCount = Math.max(that.count, 1.0);\n        Set<String> ngrams = new HashSet<String>();\n        ngrams.addAll(this.ngrams.keySet());\n        ngrams.addAll(that.ngrams.keySet());\n        for (String ngram : ngrams) {\n            double thisFrequency = this.getCount(ngram) / thisCount;\n            double thatFrequency = that.getCount(ngram) / thatCount;\n            double difference = thisFrequency - thatFrequency;\n            sumOfSquares += difference * difference;\n        }\n        return Math.sqrt(sumOfSquares);\n    }\n    @Override\n    public String toString() {\n        return ngrams.toString();\n    }\n    /* Code for interleaved distance calculation below */\n    private double distanceInterleaved(LanguageProfile that) {\n        if (length != that.length) {\n            throw new IllegalArgumentException(\n                    \"Unable to calculage distance of language profiles\"\n                    + \" with different ngram lengths: \"\n                    + that.length + \" != \" + length);\n        }\n        double sumOfSquares = 0.0;\n        double thisCount = Math.max(this.count, 1.0);\n        double thatCount = Math.max(that.count, 1.0);\n        Interleaved.Entry thisEntry = updateInterleaved().firstEntry();\n        Interleaved.Entry thatEntry = that.updateInterleaved().firstEntry();\n        // Iterate the lists in parallel, until both lists has been depleted\n        while (thisEntry.hasNgram() || thatEntry.hasNgram()) {\n            if (!thisEntry.hasNgram()) { // Depleted this\n                sumOfSquares += square(thatEntry.count / thatCount);\n                thatEntry.next();\n                continue;\n            }\n            if (!thatEntry.hasNgram()) { // Depleted that\n                sumOfSquares += square(thisEntry.count / thisCount);\n                thisEntry.next();\n                continue;\n            }\n            final int compare = thisEntry.compareTo(thatEntry);\n            if (compare == 0) { // Term exists both in this and that\n                double difference = thisEntry.count/thisCount - thatEntry.count/thatCount;\n                sumOfSquares += square(difference);\n                thisEntry.next();\n                thatEntry.next();\n            } else if (compare < 0) { // Term exists only in this\n                sumOfSquares += square(thisEntry.count/thisCount);\n                thisEntry.next();\n            } else { // Term exists only in that\n                sumOfSquares += square(thatEntry.count/thatCount);\n                thatEntry.next();\n            }\n        }\n        return Math.sqrt(sumOfSquares);\n    }\n    private double square(double count) {\n        return count * count;\n    }\n<fim_suffix>    private class Interleaved {\n        private char[] entries = null; // <ngram(length chars)><count(2 chars)>*\n        private int size = 0; // Number of entries (one entry = length+2 chars)\n        private long entriesGeneratedAtCount = -1; // Keeps track of when the sequential structure was current\n        /**\n         * Ensure that the entries array is in sync with the ngrams.\n         */\n        public void update() {\n            if (count == entriesGeneratedAtCount) { // Already up to date\n                return;\n            }\n            size = ngrams.size();\n            final int numChars = (length+2)*size;\n            if (entries == null || entries.length < numChars) {\n                entries = new char[numChars];\n            }\n            int pos = 0;\n            for (Map.Entry<String, Counter> entry: getSortedNgrams()) {\n                for (int l = 0 ; l < length ; l++) {\n                    entries[pos + l] = entry.getKey().charAt(l);\n                }\n                entries[pos + length] = (char)(entry.getValue().count / 65536); // Upper 16 bit\n                entries[pos + length + 1] = (char)(entry.getValue().count % 65536); // lower 16 bit\n                pos += length + 2;\n            }\n            entriesGeneratedAtCount = count;\n        }\n        public Entry firstEntry() {\n            Entry entry = new Entry();\n            if (size > 0) {\n                entry.update(0);\n            }\n            return entry;\n        }\n        private List<Map.Entry<String, Counter>> getSortedNgrams() {\n            List<Map.Entry<String, Counter>> entries = new ArrayList<Map.Entry<String, Counter>>(ngrams.size());\n            entries.addAll(ngrams.entrySet());\n            Collections.sort(entries, new Comparator<Map.Entry<String, Counter>>() {\n                @Override\n                public int compare(Map.Entry<String, Counter> o1, Map.Entry<String, Counter> o2) {\n                    return o1.getKey().compareTo(o2.getKey());\n                }\n            });\n            return entries;\n        }\n        private class Entry implements Comparable<Entry> {\n            char[] ngram = new char[length];\n            int count = 0;\n            int pos = 0;\n            private void update(int pos) {\n                this.pos = pos;\n                if (pos >= size) { // Reached the end\n                    return;\n                }\n                final int origo = pos*(length+2);\n                System.arraycopy(entries, origo, ngram, 0, length);\n                count = entries[origo+length] * 65536 + entries[origo+length+1];\n            }\n            @Override\n            public int compareTo(Entry other) {\n                for (int i = 0 ; i < ngram.length ; i++) {\n                    if (ngram[i] != other.ngram[i]) {\n                        return ngram[i] - other.ngram[i];\n                    }\n                }\n                return 0;\n            }\n            public boolean hasNext() {\n                return pos < size-1;\n            }\n            public boolean hasNgram() {\n                return pos < size;\n            }\n            public void next() {\n                update(pos+1);\n            }\n            public String toString() {\n                return new String(ngram) + \"(\" + count + \")\";\n            }\n        }\n    }<fim_middle>// class below is blob\n"}