{"text": "<fim_prefix>/**\n * Copyright (c) 2014,2019 Contributors to the Eclipse Foundation\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.eclipse.smarthome.model.script.actions;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.stream.Collectors;\nimport org.eclipse.smarthome.core.events.EventPublisher;\nimport org.eclipse.smarthome.core.items.GroupItem;\nimport org.eclipse.smarthome.core.items.Item;\nimport org.eclipse.smarthome.core.items.ItemNotFoundException;\nimport org.eclipse.smarthome.core.items.ItemRegistry;\nimport org.eclipse.smarthome.core.items.events.ItemEventFactory;\nimport org.eclipse.smarthome.core.types.Command;\nimport org.eclipse.smarthome.core.types.State;\nimport org.eclipse.smarthome.core.types.TypeParser;\nimport org.eclipse.smarthome.model.script.ScriptServiceUtil;\nimport org.slf4j.LoggerFactory;\n/**\n * The static methods of this class are made available as functions in the scripts.\n * This gives direct write access to the Eclipse SmartHome event bus from within scripts.\n * Items should not be updated directly (setting the state property), but updates should\n * be sent to the bus, so that all interested bundles are notified.\n *\n * @author Kai Kreuzer - Initial contribution and API\n * @author Stefan Bu\u00dfweiler - Migration to new ESH event concept\n *\n */\npublic class BusEvent {\n    /**\n     * Sends a command for a specified item to the event bus.\n     *\n     * @param item the item to send the command to\n     * @param commandString the command to send\n     */\n    static public Object sendCommand(Item item, String commandString) {\n        if (item != null) {\n            return sendCommand(item.getName(), commandString);\n        } else {\n            return null;\n        }\n    }\n    /**\n     * Sends a number as a command for a specified item to the event bus.\n     *\n     * @param item the item to send the command to\n     * @param number the number to send as a command\n     */\n    static public Object sendCommand(Item item, Number number) {\n        if (item != null && number != null) {\n            return sendCommand(item.getName(), number.toString());\n        } else {\n            return null;\n        }\n    }\n    /**\n     * Sends a command for a specified item to the event bus.\n     *\n     * @param itemName the name of the item to send the command to\n     * @param commandString the command to send\n     */\n    static public Object sendCommand(String itemName, String commandString) {\n        ItemRegistry registry = ScriptServiceUtil.getItemRegistry();\n        EventPublisher publisher = ScriptServiceUtil.getEventPublisher();\n        if (publisher != null && registry != null) {\n            try {\n                Item item = registry.getItem(itemName);\n                Command command = TypeParser.parseCommand(item.getAcceptedCommandTypes(), commandString);\n                if (command != null) {\n                    publisher.post(ItemEventFactory.createCommandEvent(itemName, command));\n                } else {\n                    LoggerFactory.getLogger(BusEvent.class).warn(\n                            \"Cannot convert '{}' to a command type which item '{}' accepts: {}.\", commandString,\n                            itemName, getAcceptedCommandNames(item));\n                }\n            } catch (ItemNotFoundException e) {\n                LoggerFactory.getLogger(BusEvent.class).warn(\"Item '{}' does not exist.\", itemName);\n            }\n        }\n        return null;\n    }\n    private static <T extends State> List<String> getAcceptedCommandNames(Item item) {\n        return item.getAcceptedCommandTypes().stream().map(t -> t.getSimpleName()).collect(Collectors.toList());\n    }\n    /**\n     * Sends a command for a specified item to the event bus.\n     *\n     * @param item the item to send the command to\n     * @param command the command to send\n     */\n    static public Object sendCommand(Item item, Command command) {\n        EventPublisher publisher = ScriptServiceUtil.getEventPublisher();\n        if (publisher != null && item != null) {\n            publisher.post(ItemEventFactory.createCommandEvent(item.getName(), command));\n        }\n        return null;\n    }\n    /**\n     * Posts a status update for a specified item to the event bus.\n     *\n     * @param item the item to send the status update for\n     * @param state the new state of the item as a number\n     */\n    static public Object postUpdate(Item item, Number state) {\n        if (item != null && state != null) {\n            return postUpdate(item.getName(), state.toString());\n        } else {\n            return null;\n        }\n    }\n    /**\n     * Posts a status update for a specified item to the event bus.\n     *\n     * @param item the item to send the status update for\n     * @param stateAsString the new state of the item\n     */\n    static public Object postUpdate(Item item, String stateAsString) {\n        if (item != null) {\n            return postUpdate(item.getName(), stateAsString);\n        } else {\n            return null;\n        }\n    }\n    /**\n     * Posts a status update for a specified item to the event bus.\n     *\n     * @param itemName the name of the item to send the status update for\n     * @param stateAsString the new state of the item\n     */\n<fim_suffix>    static public Object postUpdate(String itemName, String stateString) {\n        ItemRegistry registry = ScriptServiceUtil.getItemRegistry();\n        EventPublisher publisher = ScriptServiceUtil.getEventPublisher();\n        if (publisher != null && registry != null) {\n            try {\n                Item item = registry.getItem(itemName);\n                State state = TypeParser.parseState(item.getAcceptedDataTypes(), stateString);\n                if (state != null) {\n                    publisher.post(ItemEventFactory.createStateEvent(itemName, state));\n                } else {\n                    LoggerFactory.getLogger(BusEvent.class).warn(\n                            \"Cannot convert '{}' to a state type which item '{}' accepts: {}.\", stateString, itemName,\n                            getAcceptedDataTypeNames(item));\n                }\n            } catch (ItemNotFoundException e) {\n                LoggerFactory.getLogger(BusEvent.class).warn(\"Item '{}' does not exist.\", itemName);\n            }\n        }\n        return null;\n    }\n    private static <T extends State> List<String> getAcceptedDataTypeNames(Item item) {\n        return item.getAcceptedDataTypes().stream().map(t -> t.getSimpleName()).collect(Collectors.toList());\n    }\n    /**\n     * Posts a status update for a specified item to the event bus.\n     * t\n     *\n     * @param item the item to send the status update for\n     * @param state the new state of the item\n     */\n    static public Object postUpdate(Item item, State state) {\n        EventPublisher publisher = ScriptServiceUtil.getEventPublisher();\n        if (publisher != null && item != null) {\n            publisher.post(ItemEventFactory.createStateEvent(item.getName(), state));\n        }\n        return null;\n    }\n    /**\n     * Stores the current states for a list of items in a map.\n     * A group item is not itself put into the map, but instead all its members.\n     *\n     * @param items the items for which the state should be stored\n     * @return the map of items with their states\n     */\n    static public Map<Item, State> storeStates(Item... items) {\n        Map<Item, State> statesMap = new HashMap<>();\n        if (items != null) {\n            for (Item item : items) {\n                if (item instanceof GroupItem) {\n                    GroupItem groupItem = (GroupItem) item;\n                    for (Item member : groupItem.getAllMembers()) {\n                        statesMap.put(member, member.getState());\n                    }\n                } else {\n                    statesMap.put(item, item.getState());\n                }\n            }\n        }\n        return statesMap;\n    }\n    /**\n     * Restores item states from a map.\n     * If the saved state can be interpreted as a command, a command is sent for the item\n     * (and the physical device can send a status update if occurred). If it is no valid\n     * command, the item state is directly updated to the saved value.\n     *\n     * @param statesMap a map with ({@link Item}, {@link State}) entries\n     * @return null\n     */\n    static public Object restoreStates(Map<Item, State> statesMap) {\n        if (statesMap != null) {\n            for (Entry<Item, State> entry : statesMap.entrySet()) {\n                if (entry.getValue() instanceof Command) {\n                    sendCommand(entry.getKey(), (Command) entry.getValue());\n                } else {\n                    postUpdate(entry.getKey(), entry.getValue());\n                }\n            }\n        }\n        return null;<fim_middle>// function below is long method\n"}