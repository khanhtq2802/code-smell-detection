{"text": "<fim_prefix>         *  should be.\n         */\n        @DefinedBy(Api.LANGUAGE_MODEL)\n        public String toString() {\n            StringBuilder sb = new StringBuilder();\n            appendAnnotationsString(sb);\n            sb.append('(');\n            sb.append(argtypes);\n            sb.append(')');\n            sb.append(restype);\n            return sb.toString();\n        }\n        @DefinedBy(Api.LANGUAGE_MODEL)\n        public List<Type>        getParameterTypes() { return argtypes; }\n        @DefinedBy(Api.LANGUAGE_MODEL)\n        public Type              getReturnType()     { return restype; }\n        @DefinedBy(Api.LANGUAGE_MODEL)\n        public Type              getReceiverType()   { return recvtype; }\n        @DefinedBy(Api.LANGUAGE_MODEL)\n        public List<Type>        getThrownTypes()    { return thrown; }\n        public boolean isErroneous() {\n            return\n                isErroneous(argtypes) ||\n                restype != null && restype.isErroneous();\n        }\n        public boolean contains(Type elem) {\n            return elem.equalsIgnoreMetadata(this) || contains(argtypes, elem) || restype.contains(elem) || contains(thrown, elem);\n        }\n        public MethodType asMethodType() { return this; }\n        public void complete() {\n            for (List<Type> l = argtypes; l.nonEmpty(); l = l.tail)\n                l.head.complete();\n            restype.complete();\n            recvtype.complete();\n            for (List<Type> l = thrown; l.nonEmpty(); l = l.tail)\n                l.head.complete();\n        }\n        @DefinedBy(Api.LANGUAGE_MODEL)\n        public List<TypeVar> getTypeVariables() {\n            return List.nil();\n        }\n        public TypeSymbol asElement() {\n            return null;\n        }\n        @DefinedBy(Api.LANGUAGE_MODEL)\n        public TypeKind getKind() {\n            return TypeKind.EXECUTABLE;\n        }\n        @DefinedBy(Api.LANGUAGE_MODEL)\n        public <R, P> R accept(TypeVisitor<R, P> v, P p) {\n            return v.visitExecutable(this, p);\n        }\n    }\n    public static class PackageType extends Type implements NoType {\n        PackageType(PackageSymbol tsym) {\n            // Package types cannot be annotated\n            super(tsym, TypeMetadata.EMPTY);\n        }\n        @Override\n        public PackageType cloneWithMetadata(TypeMetadata md) {\n            throw new AssertionError(\"Cannot add metadata to a package type\");\n        }\n        @Override\n        public TypeTag getTag() {\n            return PACKAGE;\n        }\n        @Override\n        public <R,S> R accept(Type.Visitor<R,S> v, S s) {\n            return v.visitPackageType(this, s);\n        }\n        @DefinedBy(Api.LANGUAGE_MODEL)\n        public String toString() {\n            return tsym.getQualifiedName().toString();\n        }\n        @DefinedBy(Api.LANGUAGE_MODEL)\n        public TypeKind getKind() {\n            return TypeKind.PACKAGE;\n        }\n        @DefinedBy(Api.LANGUAGE_MODEL)\n        public <R, P> R accept(TypeVisitor<R, P> v, P p) {\n            return v.visitNoType(this, p);\n        }\n    }\n    public static class ModuleType extends Type implements NoType {\n        ModuleType(ModuleSymbol tsym) {\n            // Module types cannot be annotated\n            super(tsym, TypeMetadata.EMPTY);\n        }\n        @Override\n        public ModuleType cloneWithMetadata(TypeMetadata md) {\n            throw new AssertionError(\"Cannot add metadata to a module type\");\n        }\n        @Override\n        public ModuleType annotatedType(List<Attribute.TypeCompound> annos) {\n            throw new AssertionError(\"Cannot annotate a module type\");\n        }\n        @Override\n        public TypeTag getTag() {\n            return TypeTag.MODULE;\n        }\n        @Override\n        public <R,S> R accept(Type.Visitor<R,S> v, S s) {\n            return v.visitModuleType(this, s);\n        }\n        @Override @DefinedBy(Api.LANGUAGE_MODEL)\n        public String toString() {\n            return tsym.getQualifiedName().toString();\n        }\n        @Override @DefinedBy(Api.LANGUAGE_MODEL)\n        public TypeKind getKind() {\n            return TypeKind.MODULE;\n        }\n        @Override @DefinedBy(Api.LANGUAGE_MODEL)\n        public <R, P> R accept(TypeVisitor<R, P> v, P p) {\n            return v.visitNoType(this, p);\n        }\n    }\n    public static class TypeVar extends Type implements TypeVariable {\n        /** The upper bound of this type variable; set from outside.\n         *  Must be nonempty once it is set.\n         *  For a bound, `bound' is the bound type itself.\n         *  Multiple bounds are expressed as a single class type which has the\n         *  individual bounds as superclass, respectively interfaces.\n         *  The class type then has as `tsym' a compiler generated class `c',\n         *  which has a flag COMPOUND and whose owner is the type variable\n         *  itself. Furthermore, the erasure_field of the class\n         *  points to the first class or interface bound.\n         */\n        public Type bound = null;\n        /** The lower bound of this type variable.\n         *  TypeVars don't normally have a lower bound, so it is normally set\n         *  to syms.botType.\n         *  Subtypes, such as CapturedType, may provide a different value.\n         */\n        public Type lower;\n        public TypeVar(Name name, Symbol owner, Type lower) {\n            super(null, TypeMetadata.EMPTY);\n            tsym = new TypeVariableSymbol(0, name, this, owner);\n            this.bound = null;\n            this.lower = lower;\n        }\n        public TypeVar(TypeSymbol tsym, Type bound, Type lower) {\n            this(tsym, bound, lower, TypeMetadata.EMPTY);\n        }\n        public TypeVar(TypeSymbol tsym, Type bound, Type lower,\n                       TypeMetadata metadata) {\n            super(tsym, metadata);\n            this.bound = bound;\n            this.lower = lower;\n        }\n        @Override\n        public TypeVar cloneWithMetadata(TypeMetadata md) {\n            return new TypeVar(tsym, bound, lower, md) {\n                @Override\n                public Type baseType() { return TypeVar.this.baseType(); }\n            };\n        }\n        @Override\n        public TypeTag getTag() {\n            return TYPEVAR;\n        }\n        @Override\n        public <R,S> R accept(Type.Visitor<R,S> v, S s) {\n            return v.visitTypeVar(this, s);\n        }\n        @Override @DefinedBy(Api.LANGUAGE_MODEL)\n        public Type getUpperBound() {\n            if ((bound == null || bound.hasTag(NONE)) && this != tsym.type) {\n                bound = tsym.type.getUpperBound();\n            }\n            return bound;\n        }\n        int rank_field = -1;\n        @Override @DefinedBy(Api.LANGUAGE_MODEL)\n        public Type getLowerBound() {\n            return lower;\n        }\n        @DefinedBy(Api.LANGUAGE_MODEL)\n        public TypeKind getKind() {\n            return TypeKind.TYPEVAR;\n        }\n        public boolean isCaptured() {\n            return false;\n        }\n        @Override\n        public boolean isReference() {\n            return true;\n        }\n        @Override\n        public boolean isNullOrReference() {\n            return true;\n        }\n        @Override @DefinedBy(Api.LANGUAGE_MODEL)\n        public <R, P> R accept(TypeVisitor<R, P> v, P p) {\n            return v.visitTypeVariable(this, p);\n        }\n    }\n    /** A captured type variable comes from wildcards which can have\n     *  both upper and lower bound.  CapturedType extends TypeVar with\n     *  a lower bound.\n     */\n    public static class CapturedType extends TypeVar {\n        public WildcardType wildcard;\n        public CapturedType(Name name,\n                            Symbol owner,\n                            Type upper,\n                            Type lower,\n                            WildcardType wildcard) {\n            super(name, owner, lower);\n            this.lower = Assert.checkNonNull(lower);\n            this.bound = upper;\n            this.wildcard = wildcard;\n        }\n        public CapturedType(TypeSymbol tsym,\n                            Type bound,\n                            Type upper,\n                            Type lower,\n                            WildcardType wildcard,\n                            TypeMetadata metadata) {\n            super(tsym, bound, lower, metadata);\n            this.wildcard = wildcard;\n        }\n<fim_suffix>        @Override\n        public CapturedType cloneWithMetadata(TypeMetadata md) {\n            return new CapturedType(tsym, bound, bound, lower, wildcard, md) {\n                @Override\n                public Type baseType() { return CapturedType.this.baseType(); }\n            };\n        }<fim_middle>// function below has no smell\n"}