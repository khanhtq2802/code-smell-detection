{"text": "<fim_prefix>      double min = ((double) cluster.numRegions) / cluster.numServers;\n      double value = 0;\n      for (int i = 0; i < cluster.numMaxRegionsPerTable.length; i++) {\n        value += cluster.numMaxRegionsPerTable[i];\n      }\n      return scale(min, max, value);\n    }\n  }\n  /**\n   * Compute a cost of a potential cluster configuration based upon where\n   * {@link org.apache.hadoop.hbase.regionserver.HStoreFile}s are located.\n   */\n  static abstract class LocalityBasedCostFunction extends CostFunction {\n    private final LocalityType type;\n    private double bestLocality; // best case locality across cluster weighted by local data size\n    private double locality; // current locality across cluster weighted by local data size\n    private MasterServices services;\n    LocalityBasedCostFunction(Configuration conf,\n                              MasterServices srv,\n                              LocalityType type,\n                              String localityCostKey,\n                              float defaultLocalityCost) {\n      super(conf);\n      this.type = type;\n      this.setMultiplier(conf.getFloat(localityCostKey, defaultLocalityCost));\n      this.services = srv;\n      this.locality = 0.0;\n      this.bestLocality = 0.0;\n    }\n    /**\n     * Maps region to the current entity (server or rack) on which it is stored\n     */\n    abstract int regionIndexToEntityIndex(int region);\n    public void setServices(MasterServices srvc) {\n      this.services = srvc;\n    }\n    @Override\n    void init(Cluster cluster) {\n      super.init(cluster);\n      locality = 0.0;\n      bestLocality = 0.0;\n      // If no master, no computation will work, so assume 0 cost\n      if (this.services == null) {\n        return;\n      }\n      for (int region = 0; region < cluster.numRegions; region++) {\n        locality += getWeightedLocality(region, regionIndexToEntityIndex(region));\n        bestLocality += getWeightedLocality(region, getMostLocalEntityForRegion(region));\n      }\n      // We normalize locality to be a score between 0 and 1.0 representing how good it\n      // is compared to how good it could be. If bestLocality is 0, assume locality is 100\n      // (and the cost is 0)\n      locality = bestLocality == 0 ? 1.0 : locality / bestLocality;\n    }\n    @Override\n    protected void regionMoved(int region, int oldServer, int newServer) {\n      int oldEntity = type == LocalityType.SERVER ? oldServer : cluster.serverIndexToRackIndex[oldServer];\n      int newEntity = type == LocalityType.SERVER ? newServer : cluster.serverIndexToRackIndex[newServer];\n      if (this.services == null) {\n        return;\n      }\n      double localityDelta = getWeightedLocality(region, newEntity) - getWeightedLocality(region, oldEntity);\n      double normalizedDelta = bestLocality == 0 ? 0.0 : localityDelta / bestLocality;\n      locality += normalizedDelta;\n    }\n    @Override\n    double cost() {\n      return 1 - locality;\n    }\n    private int getMostLocalEntityForRegion(int region) {\n      return cluster.getOrComputeRegionsToMostLocalEntities(type)[region];\n    }\n    private double getWeightedLocality(int region, int entity) {\n      return cluster.getOrComputeWeightedLocality(region, entity, type);\n    }\n  }\n  static class ServerLocalityCostFunction extends LocalityBasedCostFunction {\n    private static final String LOCALITY_COST_KEY = \"hbase.master.balancer.stochastic.localityCost\";\n    private static final float DEFAULT_LOCALITY_COST = 25;\n    ServerLocalityCostFunction(Configuration conf, MasterServices srv) {\n      super(\n          conf,\n          srv,\n          LocalityType.SERVER,\n          LOCALITY_COST_KEY,\n          DEFAULT_LOCALITY_COST\n      );\n    }\n    @Override\n    int regionIndexToEntityIndex(int region) {\n      return cluster.regionIndexToServerIndex[region];\n    }\n  }\n  static class RackLocalityCostFunction extends LocalityBasedCostFunction {\n    private static final String RACK_LOCALITY_COST_KEY = \"hbase.master.balancer.stochastic.rackLocalityCost\";\n    private static final float DEFAULT_RACK_LOCALITY_COST = 15;\n    public RackLocalityCostFunction(Configuration conf, MasterServices services) {\n      super(\n          conf,\n          services,\n          LocalityType.RACK,\n          RACK_LOCALITY_COST_KEY,\n          DEFAULT_RACK_LOCALITY_COST\n      );\n    }\n    @Override\n    int regionIndexToEntityIndex(int region) {\n      return cluster.getRackForRegion(region);\n    }\n  }\n  /**\n   * Base class the allows writing costs functions from rolling average of some\n   * number from RegionLoad.\n   */\n  abstract static class CostFromRegionLoadFunction extends CostFunction {\n    private ClusterMetrics clusterStatus = null;\n    private Map<String, Deque<BalancerRegionLoad>> loads = null;\n    private double[] stats = null;\n    CostFromRegionLoadFunction(Configuration conf) {\n      super(conf);\n    }\n    void setClusterMetrics(ClusterMetrics status) {\n      this.clusterStatus = status;\n    }\n    void setLoads(Map<String, Deque<BalancerRegionLoad>> l) {\n      this.loads = l;\n    }\n    @Override\n    double cost() {\n      if (clusterStatus == null || loads == null) {\n        return 0;\n      }\n      if (stats == null || stats.length != cluster.numServers) {\n        stats = new double[cluster.numServers];\n      }\n      for (int i =0; i < stats.length; i++) {\n        //Cost this server has from RegionLoad\n        long cost = 0;\n        // for every region on this server get the rl\n        for(int regionIndex:cluster.regionsPerServer[i]) {\n          Collection<BalancerRegionLoad> regionLoadList =  cluster.regionLoads[regionIndex];\n          // Now if we found a region load get the type of cost that was requested.\n          if (regionLoadList != null) {\n            cost = (long) (cost + getRegionLoadCost(regionLoadList));\n          }\n        }\n        // Add the total cost to the stats.\n        stats[i] = cost;\n      }\n      // Now return the scaled cost from data held in the stats object.\n      return costFromArray(stats);\n    }\n    protected double getRegionLoadCost(Collection<BalancerRegionLoad> regionLoadList) {\n      double cost = 0;\n      for (BalancerRegionLoad rl : regionLoadList) {\n        cost += getCostFromRl(rl);\n      }\n      return cost / regionLoadList.size();\n    }\n    protected abstract double getCostFromRl(BalancerRegionLoad rl);\n  }\n  /**\n   * Class to be used for the subset of RegionLoad costs that should be treated as rates.\n   * We do not compare about the actual rate in requests per second but rather the rate relative\n   * to the rest of the regions.\n   */\n  abstract static class CostFromRegionLoadAsRateFunction extends CostFromRegionLoadFunction {\n    CostFromRegionLoadAsRateFunction(Configuration conf) {\n      super(conf);\n    }\n    @Override\n    protected double getRegionLoadCost(Collection<BalancerRegionLoad> regionLoadList) {\n      double cost = 0;\n      double previous = 0;\n      boolean isFirst = true;\n      for (BalancerRegionLoad rl : regionLoadList) {\n        double current = getCostFromRl(rl);\n        if (isFirst) {\n          isFirst = false;\n        } else {\n          cost += current - previous;\n        }\n        previous = current;\n      }\n      return Math.max(0, cost / (regionLoadList.size() - 1));\n    }\n  }\n  /**\n   * Compute the cost of total number of read requests  The more unbalanced the higher the\n   * computed cost will be.  This uses a rolling average of regionload.\n   */\n<fim_suffix>  static class ReadRequestCostFunction extends CostFromRegionLoadAsRateFunction {\n    private static final String READ_REQUEST_COST_KEY =\n        \"hbase.master.balancer.stochastic.readRequestCost\";\n    private static final float DEFAULT_READ_REQUEST_COST = 5;\n    ReadRequestCostFunction(Configuration conf) {\n      super(conf);\n      this.setMultiplier(conf.getFloat(READ_REQUEST_COST_KEY, DEFAULT_READ_REQUEST_COST));\n    }\n    @Override\n    protected double getCostFromRl(BalancerRegionLoad rl) {\n      return rl.getReadRequestsCount();\n    }\n  }<fim_middle>// class below has no smell\n"}