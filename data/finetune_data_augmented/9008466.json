{"text": "<fim_prefix>            log.warn(\"Request to \"+getUrl+\" failed due to: \"+exc.getMessage()+\n                \", sleeping for 5 seconds before re-trying the request ...\");\n          try {\n            Thread.sleep(5000);\n          } catch (InterruptedException ie) { Thread.interrupted(); }\n          // retry using recursion with one-less attempt available\n          json = getJson(httpClient, getUrl, attempts, false);\n        } else {\n          // no more attempts or error is not retry-able\n          throw exc;\n        }\n      }\n    }\n    return json;\n  }\n  private static class SolrResponseHandler implements ResponseHandler<Map<String,Object>> {\n    public Map<String,Object> handleResponse(HttpResponse response) throws ClientProtocolException, IOException {\n      HttpEntity entity = response.getEntity();\n      if (entity != null) {\n        String respBody = EntityUtils.toString(entity);\n        Object resp = null;\n        try {\n          resp = ObjectBuilder.getVal(new JSONParser(respBody));\n        } catch (JSONParser.ParseException pe) {\n          throw new ClientProtocolException(\"Expected JSON response from server but received: \"+respBody+\n              \"\\nTypically, this indicates a problem with the Solr server; check the Solr server logs for more information.\");\n        }\n        if (resp != null && resp instanceof Map) {\n          return (Map<String,Object>)resp;\n        } else {\n          throw new ClientProtocolException(\"Expected JSON object in response but received \"+ resp);\n        }\n      } else {\n        StatusLine statusLine = response.getStatusLine();\n        throw new HttpResponseException(statusLine.getStatusCode(), statusLine.getReasonPhrase());\n      }\n    }\n  }\n  /**\n   * Utility function for sending HTTP GET request to Solr and then doing some\n   * validation of the response.\n   */\n  @SuppressWarnings({\"unchecked\"})\n  public static Map<String,Object> getJson(HttpClient httpClient, String getUrl) throws Exception {\n    try {\n      // ensure we're requesting JSON back from Solr\n      HttpGet httpGet = new HttpGet(new URIBuilder(getUrl).setParameter(CommonParams.WT, CommonParams.JSON).build());\n      // make the request and get back a parsed JSON object\n      Map<String, Object> json = httpClient.execute(httpGet, new SolrResponseHandler(), HttpClientUtil.createNewHttpClientRequestContext());\n      // check the response JSON from Solr to see if it is an error\n      Long statusCode = asLong(\"/responseHeader/status\", json);\n      if (statusCode == -1) {\n        throw new SolrServerException(\"Unable to determine outcome of GET request to: \"+\n            getUrl+\"! Response: \"+json);\n      } else if (statusCode != 0) {\n        String errMsg = asString(\"/error/msg\", json);\n        if (errMsg == null)\n          errMsg = String.valueOf(json);\n        throw new SolrServerException(errMsg);\n      } else {\n        // make sure no \"failure\" object in there either\n        Object failureObj = json.get(\"failure\");\n        if (failureObj != null) {\n          if (failureObj instanceof Map) {\n            Object err = ((Map)failureObj).get(\"\");\n            if (err != null)\n              throw new SolrServerException(err.toString());\n          }\n          throw new SolrServerException(failureObj.toString());\n        }\n      }\n      return json;\n    } catch (ClientProtocolException cpe) {\n      // Currently detecting authentication by string-matching the HTTP response\n      // Perhaps SolrClient should have thrown an exception itself??\n      if (cpe.getMessage().contains(\"HTTP ERROR 401\") || cpe.getMessage().contentEquals(\"HTTP ERROR 403\")) {\n        int code = cpe.getMessage().contains(\"HTTP ERROR 401\") ? 401 : 403; \n        throw new SolrException(SolrException.ErrorCode.getErrorCode(code), \n            \"Solr requires authentication for \" + getUrl + \". Please supply valid credentials. HTTP code=\" + code);\n      } else {\n        throw cpe;\n      }\n    }\n  }  \n  /**\n   * Helper function for reading a String value from a JSON Object tree. \n   */\n  public static String asString(String jsonPath, Map<String,Object> json) {\n    return pathAs(String.class, jsonPath, json);\n  }\n  /**\n   * Helper function for reading a Long value from a JSON Object tree. \n   */\n  public static Long asLong(String jsonPath, Map<String,Object> json) {\n    return pathAs(Long.class, jsonPath, json);\n  }\n  /**\n   * Helper function for reading a List of Strings from a JSON Object tree. \n   */\n  @SuppressWarnings(\"unchecked\")\n  public static List<String> asList(String jsonPath, Map<String,Object> json) {\n    return pathAs(List.class, jsonPath, json);\n  }\n  /**\n   * Helper function for reading a Map from a JSON Object tree. \n   */\n  @SuppressWarnings(\"unchecked\")\n  public static Map<String,Object> asMap(String jsonPath, Map<String,Object> json) {\n    return pathAs(Map.class, jsonPath, json);\n  }\n  @SuppressWarnings(\"unchecked\")\n  public static <T> T pathAs(Class<T> clazz, String jsonPath, Map<String,Object> json) {\n    T val = null;\n    Object obj = atPath(jsonPath, json);\n    if (obj != null) {\n      if (clazz.isAssignableFrom(obj.getClass())) {\n        val = (T) obj;\n      } else {\n        // no ok if it's not null and of a different type\n        throw new IllegalStateException(\"Expected a \" + clazz.getName() + \" at path \"+\n           jsonPath+\" but found \"+obj+\" instead! \"+json);\n      }\n    } // it's ok if it is null\n    return val;\n  }\n  /**\n   * Helper function for reading an Object of unknown type from a JSON Object tree.\n   * \n   * To find a path to a child that starts with a slash (e.g. queryHandler named /query)\n   * you must escape the slash. For instance /config/requestHandler/\\/query/defaults/echoParams\n   * would get the echoParams value for the \"/query\" request handler.\n   */\n  @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n  public static Object atPath(String jsonPath, Map<String,Object> json) {\n    if (\"/\".equals(jsonPath))\n      return json;\n    if (!jsonPath.startsWith(\"/\"))\n      throw new IllegalArgumentException(\"Invalid JSON path: \"+\n        jsonPath+\"! Must start with a /\");\n    Map<String,Object> parent = json;      \n    Object result = null;\n    String[] path = jsonPath.split(\"(?<![\\\\\\\\])/\"); // Break on all slashes _not_ preceeded by a backslash\n    for (int p=1; p < path.length; p++) {\n      String part = path[p];\n      if (part.startsWith(\"\\\\\")) {\n        part = part.substring(1);\n      }\n      Object child = parent.get(part);      \n      if (child == null)\n        break;\n      if (p == path.length-1) {\n        // success - found the node at the desired path\n        result = child;\n      } else {\n        if (child instanceof Map) {\n          // keep walking the path down to the desired node\n          parent = (Map)child;\n        } else {\n          // early termination - hit a leaf before the requested node\n          break;\n        }\n      }\n    }\n    return result;\n  }\n  public static class AutoscalingTool extends SolrCloudTool {\n    static final String NODE_REDACTION_PREFIX = \"N_\";\n    static final String COLL_REDACTION_PREFIX = \"COLL_\";\n    public AutoscalingTool() {\n      this(System.out);\n    }\n    public AutoscalingTool(PrintStream stdout) {\n      super(stdout);\n    }\n<fim_suffix>    @Override\n    public Option[] getOptions() {\n      return new Option[] {\n          OptionBuilder\n              .withArgName(\"HOST\")\n              .hasArg()\n              .isRequired(false)\n              .withDescription(\"Address of the Zookeeper ensemble; defaults to: \"+ZK_HOST)\n              .create(\"zkHost\"),\n          OptionBuilder\n              .withArgName(\"CONFIG\")\n              .hasArg()\n              .isRequired(false)\n              .withDescription(\"Autoscaling config file, defaults to the one deployed in the cluster.\")\n              .withLongOpt(\"config\")\n              .create(\"a\"),\n          OptionBuilder\n              .withDescription(\"Show calculated suggestions\")\n              .withLongOpt(\"suggestions\")\n              .create(\"s\"),\n          OptionBuilder\n              .withDescription(\"Show ClusterState (collections layout)\")\n              .withLongOpt(\"clusterState\")\n              .create(\"c\"),\n          OptionBuilder\n              .withDescription(\"Show calculated diagnostics\")\n              .withLongOpt(\"diagnostics\")\n              .create(\"d\"),\n          OptionBuilder\n              .withDescription(\"Show sorted nodes with diagnostics\")\n              .withLongOpt(\"sortedNodes\")\n              .create(\"n\"),\n          OptionBuilder\n              .withDescription(\"Redact node and collection names (original names will be consistently randomized)\")\n              .withLongOpt(\"redact\")\n              .create(\"r\"),\n          OptionBuilder\n              .withDescription(\"Show summarized collection & node statistics.\")\n              .create(\"stats\"),\n          OptionBuilder\n              .withDescription(\"Turn on all options to get all available information.\")\n              .create(\"all\")\n      };\n    }<fim_middle>// function below is long method\n"}