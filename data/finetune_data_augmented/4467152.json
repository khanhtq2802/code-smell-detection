{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.drill.exec.expr.fn.registry;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport org.apache.drill.shaded.guava.com.google.common.base.Preconditions;\nimport org.apache.drill.shaded.guava.com.google.common.collect.Sets;\nimport org.apache.drill.common.AutoCloseables;\nimport org.apache.drill.common.config.DrillConfig;\nimport org.apache.drill.common.exceptions.DrillRuntimeException;\nimport org.apache.drill.exec.ExecConstants;\nimport org.apache.drill.exec.coord.ClusterCoordinator;\nimport org.apache.drill.exec.coord.store.TransientStore;\nimport org.apache.drill.exec.coord.store.TransientStoreConfig;\nimport org.apache.drill.exec.coord.store.TransientStoreListener;\nimport org.apache.drill.exec.exception.StoreException;\nimport org.apache.drill.exec.exception.VersionMismatchException;\nimport org.apache.drill.exec.proto.SchemaUserBitShared;\nimport org.apache.drill.exec.proto.UserBitShared.Registry;\nimport org.apache.drill.exec.store.sys.PersistentStoreConfig;\nimport org.apache.drill.exec.store.sys.PersistentStoreProvider;\nimport org.apache.drill.exec.store.sys.VersionedPersistentStore;\nimport org.apache.drill.exec.store.sys.store.DataChangeVersion;\nimport org.apache.drill.exec.util.ImpersonationUtil;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.fs.FileStatus;\nimport org.apache.hadoop.fs.FileSystem;\nimport org.apache.hadoop.fs.Path;\nimport org.apache.hadoop.fs.permission.FsAction;\nimport org.apache.hadoop.fs.permission.FsPermission;\nimport java.io.File;\nimport java.io.IOException;\nimport static com.fasterxml.jackson.databind.SerializationFeature.INDENT_OUTPUT;\n/**\n * Is responsible for remote function registry management.\n * Creates all remote registry areas at startup and validates them,\n * during init establishes connections with three udf related stores.\n * Provides tools to work with three udf related stores, gives access to remote registry areas.\n * <p/>\n * There are three udf stores:\n *\n * <li><b>REGISTRY</b> - persistent store, stores remote function registry {@link Registry} under udf path\n * which contains information about all dynamically registered jars and their function signatures.\n * If connection is created for the first time, puts empty remote registry.</li>\n *\n * <li><b>UNREGISTRATION</b> - transient store, stores information under udf/unregister path.\n * udf/unregister path is persistent by itself but any child created will be transient.\n * Whenever user submits request to unregister jar, child path with jar name is created under this store.\n * This store also holds unregistration listener, which notifies all drill bits when child path is created,\n * so they can start local unregistration process.</li>\n *\n * <li><b>JARS</b> - transient store, stores information under udf/jars path.\n * udf/jars path is persistent by itself but any child created will be transient.\n * Servers as lock, not allowing to perform any action on the same time.\n * There two types of actions: {@link Action#REGISTRATION} and {@link Action#UNREGISTRATION}.\n * Before starting any action, users tries to create child path with jar name under this store\n * and if such path already exists, receives action being performed on that very jar.\n * When user finishes its action, he deletes child path with jar name.</li>\n * <p/>\n * There are three udf areas:\n *\n * <li><b>STAGING</b> - area where user copies binary and source jars before starting registration process.</li>\n * <li><b>REGISTRY</b> - area where registered jars are stored.</li>\n * <li><b>TMP</b> - area where source and binary jars are backed up in unique folder during registration process.</li>\n */\npublic class RemoteFunctionRegistry implements AutoCloseable {\n  private static final String REGISTRY_PATH = \"registry\";\n  private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(RemoteFunctionRegistry.class);\n  private static final ObjectMapper mapper = new ObjectMapper().enable(INDENT_OUTPUT);\n  private final TransientStoreListener unregistrationListener;\n  private int retryAttempts;\n  private FileSystem fs;\n  private Path registryArea;\n  private Path stagingArea;\n  private Path tmpArea;\n  private VersionedPersistentStore<Registry> registry;\n  private TransientStore<String> unregistration;\n  private TransientStore<String> jars;\n  public RemoteFunctionRegistry(TransientStoreListener unregistrationListener) {\n    this.unregistrationListener = unregistrationListener;\n  }\n  public void init(DrillConfig config, PersistentStoreProvider storeProvider, ClusterCoordinator coordinator) {\n    prepareStores(storeProvider, coordinator);\n    prepareAreas(config);\n    this.retryAttempts = config.getInt(ExecConstants.UDF_RETRY_ATTEMPTS);\n  }\n  /**\n   * Returns current remote function registry version.\n   * If remote function registry is not found or unreachable, logs error and returns -1.\n   *\n   * @return remote function registry version if any, -1 otherwise\n   */\n  public int getRegistryVersion() {\n    DataChangeVersion version = new DataChangeVersion();\n    boolean contains = false;\n    try {\n      contains = registry.contains(REGISTRY_PATH, version);\n    } catch (Exception e) {\n      logger.error(\"Problem during trying to access remote function registry [{}]\", REGISTRY_PATH, e);\n    }\n    if (contains) {\n      return version.getVersion();\n    } else {\n      logger.error(\"Remote function registry [{}] is unreachable\", REGISTRY_PATH);\n      return DataChangeVersion.NOT_AVAILABLE;\n    }\n  }\n  /**\n   * Report whether a remote registry exists. During some unit tests,\n   * no remote registry exists, so the other methods should not be called.\n   * @return true if a remote registry exists, false if this a local-only\n   * instance and no such registry exists\n   */\n  public boolean hasRegistry() { return registry != null; }\n  public Registry getRegistry(DataChangeVersion version) {\n    return registry.get(REGISTRY_PATH, version);\n  }\n  public void updateRegistry(Registry registryContent, DataChangeVersion version) throws VersionMismatchException {\n    registry.put(REGISTRY_PATH, registryContent, version);\n  }\n  public void submitForUnregistration(String jar) {\n    unregistration.putIfAbsent(jar, jar);\n  }\n  public void finishUnregistration(String jar) {\n    unregistration.remove(jar);\n  }\n  public String addToJars(String jar, Action action) {\n    return jars.putIfAbsent(jar, action.toString());\n  }\n  public void removeFromJars(String jar) {\n    jars.remove(jar);\n  }\n  public int getRetryAttempts() {\n    return retryAttempts;\n  }\n<fim_suffix>  public FileSystem getFs() {\n    return fs;\n  }\n  public Path getRegistryArea() {\n    return registryArea;\n  }\n  public Path getStagingArea() {\n    return stagingArea;\n  }\n  public Path getTmpArea() {\n    return tmpArea;\n  }\n  /**\n   * Connects to three stores: REGISTRY, UNREGISTRATION, JARS.\n   * Puts in REGISTRY store with default instance of remote function registry if store is initiated for the first time.\n   * Registers unregistration listener in UNREGISTRATION store.\n   */\n  private void prepareStores(PersistentStoreProvider storeProvider, ClusterCoordinator coordinator) {\n    try {\n      PersistentStoreConfig<Registry> registrationConfig = PersistentStoreConfig\n          .newProtoBuilder(SchemaUserBitShared.Registry.WRITE, SchemaUserBitShared.Registry.MERGE)\n          .name(\"udf\")\n          .persist()\n          .build();\n      registry = storeProvider.getOrCreateVersionedStore(registrationConfig);\n      logger.trace(\"Remote function registry type: {}.\", registry.getClass());<fim_middle>// function below has no smell\n"}