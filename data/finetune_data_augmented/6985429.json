{"text": "<fim_prefix>                    // the unboxing code. E.g. the code:\n                    //\n                    //  List<MyJsEnum> l\n                    //   MyJsEnum e = l.get(0);\n                    //\n                    // would be emitted as:\n                    //\n                    //   List<*> l;\n                    //   MyJsEnum e = /** @type {MyJsEnum} */ (Enums.unbox(l.get(0)))\n                    //\n                    .map(\n                        td ->\n                            AstUtils.isNonNativeJsEnum(td)\n                                ? TypeDescriptors.get().javaLangObject\n                                : td)\n                    .collect(toImmutableList()))),\n        typeDescriptor.isNullable());\n  }\n  /** Returns the Closure type for a primitive type descriptor */\n  private ClosureType getClosureTypeForPrimitive(PrimitiveTypeDescriptor typeDescriptor) {\n    if (TypeDescriptors.isPrimitiveLong(typeDescriptor)) {\n      return getClosureType(BootstrapType.NATIVE_LONG.getDescriptor()).toNonNullable();\n    }\n    if (TypeDescriptors.isPrimitiveBoolean(typeDescriptor)) {\n      return BOOLEAN;\n    }\n    if (TypeDescriptors.isPrimitiveVoid(typeDescriptor)) {\n      return VOID;\n    }\n    return NUMBER;\n  }\n  /** Returns the template variable name for a type variable for use in JsDoc annotations. */\n  private ClosureType getClosureTypeForTypeVariable(TypeVariable typeVariable) {\n    if (typeVariable.isWildcardOrCapture()) {\n      return UNKNOWN;\n    }\n    return new ClosureNamedType(environment.getUniqueNameForVariable(typeVariable));\n  }\n  /** Returns the Closure type for an array type descriptor. */\n  private ClosureType getClosureTypeForArray(ArrayTypeDescriptor typeDescriptor) {\n    return withNullability(\n        new ClosureNamedType(\"Array\", getClosureType(typeDescriptor.getComponentTypeDescriptor())),\n        typeDescriptor.isNullable());\n  }\n  /** Returns the Closure type for a union type descriptor. */\n  private ClosureType getClosureTypeForUnion(UnionTypeDescriptor typeDescriptor) {\n    return withNullability(\n        new ClosureUnionType(getClosureTypes(typeDescriptor.getUnionTypeDescriptors())),\n        typeDescriptor.isNullable());\n  }\n  /** Returns the Closure type for an intersection type descriptor. */\n  private ClosureType getClosureTypeForIntersection(IntersectionTypeDescriptor typeDescriptor) {\n    // Intersection types do not have an equivalent in the Closure type system. Following the\n    // approach that Java takes regarding erasure and intersection types, the Closure type for\n    // an intersection type will be the closure type for the first type in the intersection.\n    // Whenever there are accesses to members of other types in the intersection, the appropriate\n    // Closure casts will be emitted.\n    return getClosureType(typeDescriptor.getFirstType());\n  }\n  /** Returns the Closure type for a @JsFunction type descriptor. */\n  private ClosureType getClosureTypeForJsFunction(DeclaredTypeDescriptor typeDescriptor) {\n    checkArgument(\n        typeDescriptor.isJsFunctionInterface() || typeDescriptor.isJsFunctionImplementation());\n    MethodDescriptor functionalMethodDescriptor = typeDescriptor.getJsFunctionMethodDescriptor();\n    return withNullability(\n        new ClosureFunctionType(\n            toClosureTypeParameters(functionalMethodDescriptor),\n            getClosureType(functionalMethodDescriptor.getReturnTypeDescriptor())),\n        typeDescriptor.isNullable());\n  }\n  private ImmutableList<ClosureFunctionType.Parameter> toClosureTypeParameters(\n      MethodDescriptor methodDescriptor) {\n    return methodDescriptor\n        .getParameterDescriptors()\n        .stream()\n        .map(parameterDescriptor -> toClosureTypeParameter(methodDescriptor, parameterDescriptor))\n        .collect(toImmutableList());\n  }\n  private ClosureFunctionType.Parameter toClosureTypeParameter(\n      MethodDescriptor methodDescriptor, ParameterDescriptor parameterDescriptor) {\n    return toClosureTypeParameter(\n        methodDescriptor, parameterDescriptor, parameterDescriptor.getTypeDescriptor());\n  }\n  private ClosureFunctionType.Parameter toClosureTypeParameter(\n      MethodDescriptor methodDescriptor,\n      ParameterDescriptor parameterDescriptor,\n      TypeDescriptor parameterTypeDescriptor) {\n    boolean isJsVarargs = parameterDescriptor.isVarargs() && methodDescriptor.isJsMethodVarargs();\n    boolean isOptional = parameterDescriptor.isJsOptional();\n    parameterTypeDescriptor =\n        isJsVarargs\n            ? ((ArrayTypeDescriptor) parameterTypeDescriptor).getComponentTypeDescriptor()\n            : parameterTypeDescriptor;\n    return new ClosureFunctionType.Parameter(\n        isJsVarargs, isOptional, getClosureType(parameterTypeDescriptor));\n  }\n  /** Returns Closure types for collection of type descriptors. */\n  private ImmutableList<ClosureType> getClosureTypes(\n      Collection<? extends TypeDescriptor> typeDescriptors) {\n    return typeDescriptors.stream().map(this::getClosureType).collect(toImmutableList());\n  }\n  /** Returns the Closure type for a type declaration. */\n  private ClosureType getClosureTypeForDeclaration(\n      TypeDeclaration typeDeclaration, List<ClosureType> typeParameters) {\n    ClosureType closureType = maybeGetStandardClosureType(typeDeclaration);\n    if (closureType != null) {\n      return closureType;\n    }\n    TypeDescriptor typeDescriptor = typeDeclaration.toRawTypeDescriptor();\n    if (TypeDescriptors.isJavaLangComparable(typeDescriptor)) {\n      return new ClosureUnionType(\n          new ClosureNamedType(environment.aliasForType(typeDeclaration), typeParameters),\n          BOOLEAN,\n          NUMBER,\n          STRING);\n    }\n    if (TypeDescriptors.isJavaLangCharSequence(typeDescriptor)) {\n      return new ClosureUnionType(\n          new ClosureNamedType(environment.aliasForType(typeDeclaration), typeParameters), STRING);\n    }\n    if (TypeDescriptors.isJavaLangNumber(typeDescriptor)) {\n      return new ClosureUnionType(\n          new ClosureNamedType(environment.aliasForType(typeDeclaration), typeParameters), NUMBER);\n    }\n    if (TypeDescriptors.isJavaLangCloneable(typeDescriptor)\n        || TypeDescriptors.isJavaIoSerializable(typeDescriptor)) {\n      return new ClosureUnionType(\n          new ClosureNamedType(environment.aliasForType(typeDeclaration), typeParameters), ARRAY);\n    }\n    if (specialClosureTypesByName.containsKey(typeDeclaration.getQualifiedJsName())) {\n      // Java types are nullable by default as well as most Closure types with some exceptions.\n      // Here we represent those type specially so we can handle their nullability properly.\n      return specialClosureTypesByName.get(typeDeclaration.getQualifiedJsName());\n    }\n    if (typeDeclaration.getQualifiedJsName().equals(\"Object\") && typeParameters.size() == 1) {\n      // If the type is the native 'Object' class and is being given exactly one type parameter\n      // then it is being used as a map. Expand it to two type parameters where the first one\n      // (the implicit key type parameter) is a 'string'. This special case exists to replicate the\n      // same special case that already exists in the JSCompiler optimizing backend, and to\n      // generalize it to work everywhere (including when types are referenced via an alias).\n      return new ClosureNamedType(\n          environment.aliasForType(typeDeclaration),\n          ImmutableList.<ClosureType>builder().add(STRING).addAll(typeParameters).build());\n    }\n    if (typeDeclaration.isJsEnum()) {\n      // TODO(b/116748526):  add a way to represent unknown nullability.\n      // In Closure, the default nullability for enums is the default nullability of its value type,\n      // whereas in Java enums are implicitly nullable.\n      return new ClosureNamedType(\n              environment.aliasForType(typeDeclaration),\n              AstUtils.getJsEnumValueFieldType(typeDeclaration).isNullable())\n          .toNullable();\n    }\n    return new ClosureNamedType(environment.aliasForType(typeDeclaration), typeParameters);\n  }\n  public static ClosureType maybeGetStandardClosureType(TypeDeclaration typeDeclaration) {\n    return closureTypeByTypeDeclaration.get().get(typeDeclaration);\n  }\n  private static ClosureType withNullability(ClosureType type, boolean nullable) {\n    return nullable ? type.toNullable() : type.toNonNullable();\n  }\n  /**\n   * Abstraction of the Closure JavaScript type system.\n   *\n   * <p>{@see https://github.com/google/closure-compiler/wiki/Types-in-the-Closure-Type-System}\n   *\n   * <pre>\n   * // All types\n   *  < type >  := '?'\n   *            | < type-expression >\n   *\n   * // All types except ? which can not be decorated\n   *  < type-minus-? > := '*'\n   *                  | < primitive-type >                                      // primitive-type\n   *                  | < identifier > ( '<' < type > ( ',' < type > )* '>' )?  // named type\n   *                  | '!' < type-minus-? >                                    // ! decorated type\n   *                  | '?' < type-minus-? >                                    // ? decorated type\n   *                  | '(' < type > ('|' < type > ) + ')'                      // union type\n   *                  | 'function(' (< type > (',' < type > )*)* '):' < type >  // function type\n   *                  | '(' < type-minus-? >  ')'\n   * </pre>\n   */\n  private abstract static class ClosureType {\n    abstract boolean isNullable();\n    abstract String render();\n    ClosureType toNullable() {\n      return isNullable() ? this : new ClosureWildcardDecoratedType(this);\n    }\n<fim_suffix>    ClosureType toNonNullable() {\n      return isNullable() ? new ClosureBangDecoratedType(this) : this;\n    }<fim_middle>// function below has no smell\n"}