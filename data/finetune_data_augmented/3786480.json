{"text": "<fim_prefix>\n<fim_suffix>public class OkHttpDataSource extends BaseDataSource implements HttpDataSource {\n  static {\n    ExoPlayerLibraryInfo.registerModule(\"goog.exo.okhttp\");\n  }\n  private static final byte[] SKIP_BUFFER = new byte[4096];\n  private final Call.Factory callFactory;\n  private final RequestProperties requestProperties;\n  private final @Nullable String userAgent;\n  private final @Nullable Predicate<String> contentTypePredicate;\n  private final @Nullable CacheControl cacheControl;\n  private final @Nullable RequestProperties defaultRequestProperties;\n  private @Nullable DataSpec dataSpec;\n  private @Nullable Response response;\n  private @Nullable InputStream responseByteStream;\n  private boolean opened;\n  private long bytesToSkip;\n  private long bytesToRead;\n  private long bytesSkipped;\n  private long bytesRead;\n  /**\n   * @param callFactory A {@link Call.Factory} (typically an {@link okhttp3.OkHttpClient}) for use\n   *     by the source.\n   * @param userAgent An optional User-Agent string.\n   * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the\n   *     predicate then a {@link InvalidContentTypeException} is thrown from {@link\n   *     #open(DataSpec)}.\n   */\n  public OkHttpDataSource(\n      Call.Factory callFactory,\n      @Nullable String userAgent,\n      @Nullable Predicate<String> contentTypePredicate) {\n    this(\n        callFactory,\n        userAgent,\n        contentTypePredicate,\n        /* cacheControl= */ null,\n        /* defaultRequestProperties= */ null);\n  }\n  /**\n   * @param callFactory A {@link Call.Factory} (typically an {@link okhttp3.OkHttpClient}) for use\n   *     by the source.\n   * @param userAgent An optional User-Agent string.\n   * @param contentTypePredicate An optional {@link Predicate}. If a content type is rejected by the\n   *     predicate then a {@link InvalidContentTypeException} is thrown from {@link\n   *     #open(DataSpec)}.\n   * @param cacheControl An optional {@link CacheControl} for setting the Cache-Control header.\n   * @param defaultRequestProperties The optional default {@link RequestProperties} to be sent to\n   *     the server as HTTP headers on every request.\n   */\n  public OkHttpDataSource(\n      Call.Factory callFactory,\n      @Nullable String userAgent,\n      @Nullable Predicate<String> contentTypePredicate,\n      @Nullable CacheControl cacheControl,\n      @Nullable RequestProperties defaultRequestProperties) {\n    super(/* isNetwork= */ true);\n    this.callFactory = Assertions.checkNotNull(callFactory);\n    this.userAgent = userAgent;\n    this.contentTypePredicate = contentTypePredicate;\n    this.cacheControl = cacheControl;\n    this.defaultRequestProperties = defaultRequestProperties;\n    this.requestProperties = new RequestProperties();\n  }\n  @Override\n  public @Nullable Uri getUri() {\n    return response == null ? null : Uri.parse(response.request().url().toString());\n  }\n  @Override\n  public Map<String, List<String>> getResponseHeaders() {\n    return response == null ? Collections.emptyMap() : response.headers().toMultimap();\n  }\n  @Override\n  public void setRequestProperty(String name, String value) {\n    Assertions.checkNotNull(name);\n    Assertions.checkNotNull(value);\n    requestProperties.set(name, value);\n  }\n  @Override\n  public void clearRequestProperty(String name) {\n    Assertions.checkNotNull(name);\n    requestProperties.remove(name);\n  }\n  @Override\n  public void clearAllRequestProperties() {\n    requestProperties.clear();\n  }\n  @Override\n  public long open(DataSpec dataSpec) throws HttpDataSourceException {\n    this.dataSpec = dataSpec;\n    this.bytesRead = 0;\n    this.bytesSkipped = 0;\n    transferInitializing(dataSpec);\n    Request request = makeRequest(dataSpec);\n    Response response;\n    ResponseBody responseBody;\n    try {\n      this.response = callFactory.newCall(request).execute();\n      response = this.response;\n      responseBody = Assertions.checkNotNull(response.body());\n      responseByteStream = responseBody.byteStream();\n    } catch (IOException e) {\n      throw new HttpDataSourceException(\n          \"Unable to connect to \" + dataSpec.uri, e, dataSpec, HttpDataSourceException.TYPE_OPEN);\n    }\n    int responseCode = response.code();\n    // Check for a valid response code.\n    if (!response.isSuccessful()) {\n      Map<String, List<String>> headers = response.headers().toMultimap();\n      closeConnectionQuietly();\n      InvalidResponseCodeException exception =\n          new InvalidResponseCodeException(responseCode, response.message(), headers, dataSpec);\n      if (responseCode == 416) {\n        exception.initCause(new DataSourceException(DataSourceException.POSITION_OUT_OF_RANGE));\n      }\n      throw exception;\n    }\n    // Check for a valid content type.\n    MediaType mediaType = responseBody.contentType();\n    String contentType = mediaType != null ? mediaType.toString() : \"\";\n    if (contentTypePredicate != null && !contentTypePredicate.evaluate(contentType)) {\n      closeConnectionQuietly();\n      throw new InvalidContentTypeException(contentType, dataSpec);\n    }\n    // If we requested a range starting from a non-zero position and received a 200 rather than a\n    // 206, then the server does not support partial requests. We'll need to manually skip to the\n    // requested position.\n    bytesToSkip = responseCode == 200 && dataSpec.position != 0 ? dataSpec.position : 0;\n    // Determine the length of the data to be read, after skipping.\n    if (dataSpec.length != C.LENGTH_UNSET) {\n      bytesToRead = dataSpec.length;\n    } else {\n      long contentLength = responseBody.contentLength();\n      bytesToRead = contentLength != -1 ? (contentLength - bytesToSkip) : C.LENGTH_UNSET;\n    }\n    opened = true;\n    transferStarted(dataSpec);\n    return bytesToRead;\n  }\n  @Override\n  public int read(byte[] buffer, int offset, int readLength) throws HttpDataSourceException {\n    try {\n      skipInternal();\n      return readInternal(buffer, offset, readLength);\n    } catch (IOException e) {\n      throw new HttpDataSourceException(\n          e, Assertions.checkNotNull(dataSpec), HttpDataSourceException.TYPE_READ);\n    }\n  }\n  @Override\n  public void close() throws HttpDataSourceException {\n    if (opened) {\n      opened = false;\n      transferEnded();\n      closeConnectionQuietly();\n    }\n  }\n  /**\n   * Returns the number of bytes that have been skipped since the most recent call to\n   * {@link #open(DataSpec)}.\n   *\n   * @return The number of bytes skipped.\n   */\n  protected final long bytesSkipped() {\n    return bytesSkipped;\n  }\n  /**\n   * Returns the number of bytes that have been read since the most recent call to\n   * {@link #open(DataSpec)}.\n   *\n   * @return The number of bytes read.\n   */\n  protected final long bytesRead() {\n    return bytesRead;\n  }\n  /**\n   * Returns the number of bytes that are still to be read for the current {@link DataSpec}.\n   * <p>\n   * If the total length of the data being read is known, then this length minus {@code bytesRead()}\n   * is returned. If the total length is unknown, {@link C#LENGTH_UNSET} is returned.\n   *\n   * @return The remaining length, or {@link C#LENGTH_UNSET}.\n   */\n  protected final long bytesRemaining() {\n    return bytesToRead == C.LENGTH_UNSET ? bytesToRead : bytesToRead - bytesRead;\n  }\n  /** Establishes a connection. */\n  private Request makeRequest(DataSpec dataSpec) throws HttpDataSourceException {\n    long position = dataSpec.position;\n    long length = dataSpec.length;\n    boolean allowGzip = dataSpec.isFlagSet(DataSpec.FLAG_ALLOW_GZIP);\n    HttpUrl url = HttpUrl.parse(dataSpec.uri.toString());\n    if (url == null) {\n      throw new HttpDataSourceException(\n          \"Malformed URL\", dataSpec, HttpDataSourceException.TYPE_OPEN);\n    }\n    Request.Builder builder = new Request.Builder().url(url);\n    if (cacheControl != null) {\n      builder.cacheControl(cacheControl);\n    }\n    if (defaultRequestProperties != null) {\n      for (Map.Entry<String, String> property : defaultRequestProperties.getSnapshot().entrySet()) {\n        builder.header(property.getKey(), property.getValue());\n      }\n    }\n    for (Map.Entry<String, String> property : requestProperties.getSnapshot().entrySet()) {\n      builder.header(property.getKey(), property.getValue());\n    }\n    if (!(position == 0 && length == C.LENGTH_UNSET)) {\n      String rangeRequest = \"bytes=\" + position + \"-\";\n      if (length != C.LENGTH_UNSET) {\n        rangeRequest += (position + length - 1);\n      }\n      builder.addHeader(\"Range\", rangeRequest);\n    }\n    if (userAgent != null) {<fim_middle>// class below is blob\n"}