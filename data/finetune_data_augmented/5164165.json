{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.kylin.cache.memcached;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\n\n/**\n * A Class implement this interface indicates that the key information need to be calculated from a first lookup from cache itself to get\n * a hook.\n *\n */\npublic interface KeyHookLookup {\n    KeyHook lookupKeyHook(String key);\n\n<fim_suffix>    public static class KeyHook implements Serializable {\n        private static final long serialVersionUID = 2400159460862757991L;\n\n        private String[] chunkskey;\n        private byte[] values;\n\n        /**\n         * For de-serialization\n         */\n        public KeyHook() {\n        }\n\n        public KeyHook(String[] chunkskey, byte[] values) {\n            super();\n            this.chunkskey = chunkskey;\n            this.values = values;\n        }\n\n        public String[] getChunkskey() {\n            return chunkskey;\n        }\n\n        public void setChunkskey(String[] chunkskey) {\n            this.chunkskey = chunkskey;\n        }\n\n        public byte[] getValues() {\n            return values;\n        }\n\n        public void setValues(byte[] values) {\n            this.values = values;\n        }\n\n        @Override\n        public int hashCode() {\n            final int prime = 31;\n            int result = 1;\n            result = prime * result + Arrays.hashCode(chunkskey);\n            result = prime * result + Arrays.hashCode(values);\n            return result;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj)\n                return true;\n            if (obj == null)\n                return false;\n            if (getClass() != obj.getClass())\n                return false;\n            KeyHook other = (KeyHook) obj;\n            if (!Arrays.equals(chunkskey, other.chunkskey))\n                return false;\n            if (!Arrays.equals(values, other.values))\n                return false;\n            return true;\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            if (chunkskey != null) {\n                builder.append(\"chunkskey_length:\" + chunkskey.length);\n            } else {\n                builder.append(\"chunkskey_is_null\");\n            }\n            builder.append(\"|\");\n            if (values != null) {\n                builder.append(\"value_length:\" + values.length);\n            } else {\n                builder.append(\"value_is_null\");\n            }\n            return builder.toString();\n        }\n\n        //        @Override\n        //        public void writeExternal(ObjectOutput out) throws IOException {\n        //            if(chunkskey == null){\n        //                out.writeInt(0);\n        //            }else{\n        //                out.writeInt(chunkskey.length);\n        //                for (String chunkKey : chunkskey) {\n        //                    out.writeUTF(chunkKey);\n        //                }\n        //            }\n        //            if(values != null){\n        //                out.write(values);\n        //            }\n        //        }\n        //        \n        //        @Override\n        //        public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n        //            int keySize = in.readInt();\n        //            if(keySize > 0){\n        //                chunkskey = new String[keySize];\n        //                for (int i = 0; i < keySize; i++){\n        //                    chunkskey[i] = in.readUTF();\n        //                }\n        //            }\n        //            int available = in.available();\n        //            if(available > 0){\n        //                values = new byte[available];\n        //                in.read(values);\n        //            }\n        //        }\n    }\n}<fim_middle>// class below has no smell\n"}