{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.jena.riot;\nimport java.io.InputStream;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.nio.file.Path;\nimport java.util.*;\nimport org.apache.http.Header;\nimport org.apache.http.client.HttpClient;\nimport org.apache.http.message.BasicHeader;\nimport org.apache.jena.atlas.lib.IRILib;\nimport org.apache.jena.graph.BlankNodeId;\nimport org.apache.jena.graph.Graph;\nimport org.apache.jena.query.Dataset;\nimport org.apache.jena.rdf.model.Model;\nimport org.apache.jena.riot.RDFParser.LangTagForm;\nimport org.apache.jena.riot.lang.LabelToNode;\nimport org.apache.jena.riot.system.*;\nimport org.apache.jena.riot.system.stream.StreamManager;\nimport org.apache.jena.riot.web.HttpNames;\nimport org.apache.jena.riot.web.HttpOp ;\nimport org.apache.jena.sparql.core.DatasetGraph;\nimport org.apache.jena.sparql.util.Context;\n/**\n * An {@link RDFParser} is a process that will generate triples; \n * {@link RDFParserBuilder} provides the means to setup the parser.\n * <p>\n * An {@link RDFParser} has a predefined source; the target for output is given when the \"parse\" method is called. \n * It can be used multiple times in which case the same source is reread. The destination can vary.\n * The application is responsible for concurrency of the destination of the parse operation.\n * \n * The process is\n * <pre>\n *     StreamRDF destination = ...\n *     RDFParser parser = RDFParser.create()\n *          .source(\"filename.ttl\")\n *          .build();\n *     parser.parse(destination); \n * </pre>\n * or using a short cut: \n * <pre>\n *     RDFParser parser = RDFParser.create()\n *          .source(\"filename.ttl\")\n *          .parse(destination); \n * </pre> \n */\npublic class RDFParserBuilder {\n    // The various sources\n    // Reusable parser\n    private String uri = null;\n    private Path path = null;\n    private String content = null;\n    // The not reusable sources.\n    private InputStream inputStream;\n    private Reader javaReader = null;\n    private StreamManager streamManager = null;\n    // HTTP\n    private Map<String, String> httpHeaders = new HashMap<>(); \n    private HttpClient httpClient = null;\n    // Syntax\n    private Lang hintLang = null;\n    private Lang forceLang = null;\n    private String baseUri = null;\n    private boolean           canonicalValues = false;\n    private LangTagForm  langTagForm = LangTagForm.NONE;\n    private Optional<Boolean> checking = Optional.empty();\n    // ---- Unused but left in case required in the future.\n    private boolean strict = SysRIOT.isStrictMode();\n    private boolean resolveURIs = true;\n    private IRIResolver resolver = null;\n    // ----\n    // Construction for the StreamRDF \n    private FactoryRDF factory = null;\n    private LabelToNode labelToNode = null;\n    // Bad news.\n    private ErrorHandler errorHandler = null;\n    // Parsing process\n    private Context context = null;\n    public static RDFParserBuilder create() { return new RDFParserBuilder() ; }\n    private RDFParserBuilder() {}\n    /** \n     *  Set the source to {@link Path}. \n     *  This clears any other source setting.\n     *  <p>\n     *  The parser can be reused.\n     *  @param path\n     *  @return this\n     */\n    public RDFParserBuilder source(Path path) {\n        clearSource();\n        this.path = path;\n        return this;\n    }\n    /** \n     *  Set the source to a URI; this includes OS file names.\n     *  File URL should be of the form {@code file:///...}. \n     *  This clears any other source setting.\n     *  <p>\n     *  The parser can be reused.\n     *  @param uriOrFile\n     *  @return this\n     */\n    public RDFParserBuilder source(String uriOrFile) {\n        clearSource();\n        this.uri = uriOrFile;\n        return this;\n    }\n    /** \n     *  Use the given string as the content to parse. \n     *  This clears any other source setting.\n     *  <p>\n     *  The syntax must be set with {@code .lang(...)}.\n     *  <p>\n     *  The parser can be reused.  \n     *  @param string The characters to be parsed. \n     *  @return this\n     */\n<fim_suffix>    public RDFParserBuilder fromString(String string) {\n        clearSource();\n        this.content = string;\n        return this;\n    }\n    /** \n     *  Set the source to {@link InputStream}. \n     *  This clears any other source setting.\n     *  <p>\n     *  The syntax must be set with {@code .lang(...)}.\n     *  <p>\n     *  The {@link InputStream} will be closed when the \n     *  parser is called and the parser can not be reused.  \n     *  @param input\n     *  @return this\n     */\n    public RDFParserBuilder source(InputStream input) {\n        clearSource();\n        this.inputStream = input;\n        return this;\n    }\n    /**\n     *  Set the source to {@link StringReader}. \n     *  This clears any other source setting.\n     *  The {@link StringReader} will be closed when the \n     *  parser is called and the parser can not be reused.\n     *  <p>\n     *  The syntax must be set with {@code .lang(...)}.\n     *  <p>\n     *  Consider using {@link #fromString} instead.   \n     *  @param reader\n     *  @return this\n     */\n    public RDFParserBuilder source(StringReader reader) {\n        clearSource();\n        this.javaReader = reader;\n        return this;\n    }\n    /** \n     *  Set the source to {@link Reader}. \n     *  This clears any other source setting.\n     *  The {@link Reader} will be closed when the \n     *  parser is called and the parser can not be reused.\n     *  <p>\n     *  The syntax must be set with {@code .lang(...)}.\n     *  @param reader\n     *  @return this\n     *  @deprecated Use {@link #fromString}, or an InputStream or a StringReader. \n     */\n    @Deprecated\n    public RDFParserBuilder source(Reader reader) {\n        clearSource();\n        this.javaReader = reader;\n        return this;\n    }\n    /**\n     * Set the StreamManager to use when opening a URI (including files by name, but not by {@code Path}). \n     * @param streamManager\n     * @return this\n     */\n    public RDFParserBuilder streamManager(StreamManager streamManager) {\n        this.streamManager = streamManager;\n        return this;\n    }\n    private void clearSource() {\n        this.uri = null;\n        this.path = null;\n        this.content = null;\n        this.inputStream = null;\n        this.javaReader = null;\n    }\n    /**\n     * Set the hint {@link Lang}. This is the RDF syntax used when there is no way to\n     * deduce the syntax (e.g. read from a InputStream, no recognized file extension, no\n     * recognized HTTP Content-Type provided).\n     * \n     * @param lang\n     * @return this\n     */\n    public RDFParserBuilder lang(Lang lang) { this.hintLang = lang ; return this; }\n    /**\n     * Force the choice RDF syntax to be {@code lang}, and ignore any indications such as file extension\n     * or HTTP Content-Type.\n     * @see Lang\n     * @param lang\n     * @return this\n     */\n    public RDFParserBuilder forceLang(Lang lang) { this.forceLang = lang ; return this; }\n    /**\n     * Set the HTTP \"Accept\" header.\n     * The default if not set is {@link WebContent#defaultRDFAcceptHeader}.\n     * @param acceptHeader\n     * @return this\n     */\n    public RDFParserBuilder httpAccept(String acceptHeader) { \n        httpHeader(HttpNames.hAccept, acceptHeader);\n        return this; \n    }\n    /**\n     * Set an HTTP header. Any previous setting is lost.\n     * <p> \n     * Consider setting up an {@link HttpClient} if more complicated<fim_middle>// function below has no smell\n"}