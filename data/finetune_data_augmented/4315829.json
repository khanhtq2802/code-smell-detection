{"text": "<fim_prefix>/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n * \n *    http://www.apache.org/licenses/LICENSE-2.0\n * \n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n * \n */\npackage org.apache.directory.api.ldap.model.message;\nimport java.text.ParseException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport org.apache.directory.api.i18n.I18n;\nimport org.apache.directory.api.ldap.model.exception.LdapException;\nimport org.apache.directory.api.ldap.model.exception.LdapProtocolErrorException;\nimport org.apache.directory.api.ldap.model.filter.BranchNormalizedVisitor;\nimport org.apache.directory.api.ldap.model.filter.ExprNode;\nimport org.apache.directory.api.ldap.model.filter.FilterParser;\nimport org.apache.directory.api.ldap.model.name.Dn;\n/**\n * SearchRequest implementation.\n * \n * @author <a href=\"mailto:dev@directory.apache.org\"> Apache Directory Project</a>\n */\npublic class SearchRequestImpl extends AbstractAbandonableRequest implements SearchRequest\n{\n    static final long serialVersionUID = -5655881944020886218L;\n    /** Search base distinguished name */\n    private Dn baseDn;\n    /** Search filter expression tree's root node */\n    private ExprNode filterNode;\n    /** Search scope enumeration value */\n    private SearchScope scope;\n    /** Types only return flag */\n    private boolean typesOnly;\n    /** Max size in entries to return */\n    private long sizeLimit;\n    /** Max seconds to wait for search to complete */\n    private int timeLimit;\n    /** Alias dereferencing mode enumeration value (default to DEREF_ALWAYS) */\n    private AliasDerefMode aliasDerefMode = AliasDerefMode.DEREF_ALWAYS;\n    /** Attributes to return */\n    private List<String> attributes = new ArrayList<>();\n    /** The final result containing SearchResponseDone response */\n    private SearchResultDone response;\n    /** A flag set to tell the search what to do wth referrals */\n    private ReferralsPolicyEnum referralHandling = ReferralsPolicyEnum.THROW;\n    // -----------------------------------------------------------------------\n    // Constructors\n    // -----------------------------------------------------------------------\n    /**\n     * Creates a SearcRequest implementing object used to search the\n     * DIT.\n     */\n    public SearchRequestImpl()\n    {\n        super( -1, MessageTypeEnum.SEARCH_REQUEST );\n    }\n    // ------------------------------------------------------------------------\n    // SearchRequest Interface Method Implementations\n    // ------------------------------------------------------------------------\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public List<String> getAttributes()\n    {\n        return Collections.unmodifiableList( attributes );\n    }\n    /**\n     * Gets the search base as a distinguished name.\n     * \n     * @return the search base\n     */\n    @Override\n    public Dn getBase()\n    {\n        return baseDn;\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public SearchRequest setBase( Dn base )\n    {\n        baseDn = base;\n        return this;\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public AliasDerefMode getDerefAliases()\n    {\n        return aliasDerefMode;\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public SearchRequest setDerefAliases( AliasDerefMode aliasDerefAliases )\n    {\n        this.aliasDerefMode = aliasDerefAliases;\n        return this;\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public ExprNode getFilter()\n    {\n        return filterNode;\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public SearchRequest setFilter( ExprNode filter )\n    {\n        this.filterNode = filter;\n        return this;\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public SearchRequest setFilter( String filter ) throws LdapException\n    {\n        try\n        {\n            filterNode = FilterParser.parse( filter );\n        }\n        catch ( ParseException pe )\n        {\n            throw new LdapProtocolErrorException( I18n.err( I18n.ERR_13508_INVALID_FILTER, filter ), pe );\n        }\n        return this;\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public MessageTypeEnum[] getResponseTypes()\n    {\n        return RESPONSE_TYPES;\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public SearchScope getScope()\n    {\n        return scope;\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public SearchRequest setScope( SearchScope scope )\n    {\n        this.scope = scope;\n        return this;\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public long getSizeLimit()\n    {\n        return sizeLimit;\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public SearchRequest setSizeLimit( long entriesMax )\n    {\n        sizeLimit = entriesMax;\n        return this;\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int getTimeLimit()\n    {\n        return timeLimit;\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public SearchRequest setTimeLimit( int secondsMax )\n    {\n        timeLimit = secondsMax;\n        return this;\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean getTypesOnly()\n    {\n        return typesOnly;\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public SearchRequest setTypesOnly( boolean typesOnly )\n    {\n        this.typesOnly = typesOnly;\n        return this;\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public SearchRequest addAttributes( String... attributesToAdd )\n    {\n        this.attributes.addAll( Arrays.asList( attributesToAdd ) );\n        return this;\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public SearchRequest removeAttribute( String attribute )\n    {\n        attributes.remove( attribute );\n        return this;\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public SearchResultDone getResultResponse()\n    {\n        if ( response == null )\n        {\n            response = new SearchResultDoneImpl( getMessageId() );\n        }\n        return response;\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public SearchRequest setMessageId( int messageId )\n    {\n        super.setMessageId( messageId );\n        return this;\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public SearchRequest addControl( Control control )\n    {\n        return ( SearchRequest ) super.addControl( control );\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public SearchRequest addAllControls( Control[] controls )\n    {\n        return ( SearchRequest ) super.addAllControls( controls );\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public SearchRequest removeControl( Control control )\n    {\n        return ( SearchRequest ) super.removeControl( control );\n    }\n    /**\n     * {@inheritDoc}\n     */\n<fim_suffix>    @Override\n    public int hashCode()\n    {\n        int hash = 37;\n        if ( baseDn != null )\n        {\n            hash = hash * 17 + baseDn.hashCode();\n        }\n        hash = hash * 17 + aliasDerefMode.hashCode();\n        hash = hash * 17 + scope.hashCode();\n        hash = hash * 17 + Long.valueOf( sizeLimit ).hashCode();\n        hash = hash * 17 + timeLimit;\n        hash = hash * 17 + ( typesOnly ? 0 : 1 );\n        if ( attributes != null )\n        {\n            hash = hash * 17 + attributes.size();\n            // Order doesn't matter, thus just add hashCode\n            for ( String attr : attributes )\n            {\n                if ( attr != null )\n                {\n                    hash = hash + attr.hashCode();\n                }\n            }\n        }\n        BranchNormalizedVisitor visitor = new BranchNormalizedVisitor();\n        filterNode.accept( visitor );\n        hash = hash * 17 + filterNode.toString().hashCode();\n        hash = hash * 17 + super.hashCode();\n        return hash;\n    }\n    /**\n     * Checks to see if two search requests are equal. The Lockable properties\n     * and the get/set context specific parameters are not consulted to\n     * determine equality. The filter expression tree comparison will normalize\n     * the child order of filter branch nodes then generate a string\n     * representation which is comparable. For the time being this is a very\n     * costly operation.\n     * <fim_middle>// function below is long method\n"}