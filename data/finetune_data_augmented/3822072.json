{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.accumulo.tserver.tablet;\nimport java.io.IOException;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.atomic.AtomicLong;\nimport org.apache.accumulo.core.client.IteratorSetting;\nimport org.apache.accumulo.core.conf.AccumuloConfiguration;\nimport org.apache.accumulo.core.conf.IterConfigUtil;\nimport org.apache.accumulo.core.data.ByteSequence;\nimport org.apache.accumulo.core.data.Key;\nimport org.apache.accumulo.core.data.Value;\nimport org.apache.accumulo.core.dataImpl.KeyExtent;\nimport org.apache.accumulo.core.file.FileOperations;\nimport org.apache.accumulo.core.file.FileSKVIterator;\nimport org.apache.accumulo.core.file.FileSKVWriter;\nimport org.apache.accumulo.core.iterators.IteratorUtil.IteratorScope;\nimport org.apache.accumulo.core.iterators.SortedKeyValueIterator;\nimport org.apache.accumulo.core.iterators.system.ColumnFamilySkippingIterator;\nimport org.apache.accumulo.core.iterators.system.DeletingIterator;\nimport org.apache.accumulo.core.iterators.system.MultiIterator;\nimport org.apache.accumulo.core.iterators.system.TimeSettingIterator;\nimport org.apache.accumulo.core.metadata.schema.DataFileValue;\nimport org.apache.accumulo.core.util.LocalityGroupUtil;\nimport org.apache.accumulo.core.util.LocalityGroupUtil.LocalityGroupConfigurationError;\nimport org.apache.accumulo.core.util.ratelimit.RateLimiter;\nimport org.apache.accumulo.server.ServerContext;\nimport org.apache.accumulo.server.fs.FileRef;\nimport org.apache.accumulo.server.fs.VolumeManager;\nimport org.apache.accumulo.server.problems.ProblemReport;\nimport org.apache.accumulo.server.problems.ProblemReportingIterator;\nimport org.apache.accumulo.server.problems.ProblemReports;\nimport org.apache.accumulo.server.problems.ProblemType;\nimport org.apache.accumulo.tserver.InMemoryMap;\nimport org.apache.accumulo.tserver.MinorCompactionReason;\nimport org.apache.accumulo.tserver.TabletIteratorEnvironment;\nimport org.apache.accumulo.tserver.compaction.MajorCompactionReason;\nimport org.apache.hadoop.fs.FileSystem;\nimport org.apache.hadoop.fs.Path;\nimport org.apache.htrace.Trace;\nimport org.apache.htrace.TraceScope;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\npublic class Compactor implements Callable<CompactionStats> {\n  private static final Logger log = LoggerFactory.getLogger(Compactor.class);\n  private static final AtomicLong nextCompactorID = new AtomicLong(0);\n<fim_suffix>  public static class CompactionCanceledException extends Exception {\n    private static final long serialVersionUID = 1L;\n  }\n  public interface CompactionEnv {\n    boolean isCompactionEnabled();\n    IteratorScope getIteratorScope();\n    RateLimiter getReadLimiter();\n    RateLimiter getWriteLimiter();\n  }\n  private final Map<FileRef,DataFileValue> filesToCompact;\n  private final InMemoryMap imm;\n  private final FileRef outputFile;\n  private final boolean propogateDeletes;\n  private final AccumuloConfiguration acuTableConf;\n  private final CompactionEnv env;\n  private final VolumeManager fs;\n  protected final KeyExtent extent;\n  private final List<IteratorSetting> iterators;\n  // things to report\n  private String currentLocalityGroup = \"\";\n  private final long startTime;\n  private int reason;\n  private final AtomicLong entriesRead = new AtomicLong(0);\n  private final AtomicLong entriesWritten = new AtomicLong(0);\n  private final DateFormat dateFormatter = new SimpleDateFormat(\"yyyy/MM/dd HH:mm:ss.SSS\");\n  // a unique id to identify a compactor\n  private final long compactorID = nextCompactorID.getAndIncrement();\n  protected volatile Thread thread;\n  private final ServerContext context;\n  public long getCompactorID() {\n    return compactorID;\n  }\n  private synchronized void setLocalityGroup(String name) {\n    this.currentLocalityGroup = name;\n  }\n  public synchronized String getCurrentLocalityGroup() {\n    return currentLocalityGroup;\n  }\n  private void clearStats() {\n    entriesRead.set(0);\n    entriesWritten.set(0);\n  }\n  protected static final Set<Compactor> runningCompactions = Collections\n      .synchronizedSet(new HashSet<>());\n  public static List<CompactionInfo> getRunningCompactions() {\n    ArrayList<CompactionInfo> compactions = new ArrayList<>();\n    synchronized (runningCompactions) {\n      for (Compactor compactor : runningCompactions) {\n        compactions.add(new CompactionInfo(compactor));\n      }\n    }\n    return compactions;\n  }\n  public Compactor(ServerContext context, Tablet tablet, Map<FileRef,DataFileValue> files,\n      InMemoryMap imm, FileRef outputFile, boolean propogateDeletes, CompactionEnv env,\n      List<IteratorSetting> iterators, int reason, AccumuloConfiguration tableConfiguation) {\n    this.context = context;\n    this.extent = tablet.getExtent();\n    this.fs = tablet.getTabletServer().getFileSystem();\n    this.acuTableConf = tableConfiguation;\n    this.filesToCompact = files;\n    this.imm = imm;\n    this.outputFile = outputFile;\n    this.propogateDeletes = propogateDeletes;\n    this.env = env;\n    this.iterators = iterators;\n    this.reason = reason;\n    startTime = System.currentTimeMillis();\n  }\n  public VolumeManager getFileSystem() {\n    return fs;\n  }\n  KeyExtent getExtent() {\n    return extent;\n  }\n  String getOutputFile() {\n    return outputFile.toString();\n  }\n  MajorCompactionReason getMajorCompactionReason() {\n    return MajorCompactionReason.values()[reason];\n  }\n  protected Map<String,Set<ByteSequence>> getLocalityGroups(AccumuloConfiguration acuTableConf)\n      throws IOException {\n    try {\n      return LocalityGroupUtil.getLocalityGroups(acuTableConf);\n    } catch (LocalityGroupConfigurationError e) {\n      throw new IOException(e);\n    }\n  }\n  @Override\n  public CompactionStats call() throws IOException, CompactionCanceledException {\n    FileSKVWriter mfw = null;\n    CompactionStats majCStats = new CompactionStats();\n    boolean remove = runningCompactions.add(this);\n    clearStats();\n    final Path outputFilePath = outputFile.path();\n    final String outputFilePathName = outputFilePath.toString();\n    String oldThreadName = Thread.currentThread().getName();\n    String newThreadName = \"MajC compacting \" + extent + \" started \"\n        + dateFormatter.format(new Date()) + \" file: \" + outputFile;\n    Thread.currentThread().setName(newThreadName);\n    thread = Thread.currentThread();\n    try {\n      FileOperations fileFactory = FileOperations.getInstance();\n      FileSystem ns = this.fs.getVolumeByPath(outputFilePath).getFileSystem();\n      mfw = fileFactory.newWriterBuilder()\n          .forFile(outputFilePathName, ns, ns.getConf(), context.getCryptoService())\n          .withTableConfiguration(acuTableConf).withRateLimiter(env.getWriteLimiter()).build();\n      Map<String,Set<ByteSequence>> lGroups = getLocalityGroups(acuTableConf);\n      long t1 = System.currentTimeMillis();\n      HashSet<ByteSequence> allColumnFamilies = new HashSet<>();\n      if (mfw.supportsLocalityGroups()) {<fim_middle>// class below has no smell\n"}