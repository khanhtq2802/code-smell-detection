{"text": "<fim_prefix>      this.fromTable = checkNotNull(fromTable);\n      this.function = checkNotNull(function);\n    }\n    @Override\n    public boolean contains(Object rowKey, Object columnKey) {\n      return fromTable.contains(rowKey, columnKey);\n    }\n    @Override\n    public V2 get(Object rowKey, Object columnKey) {\n      // The function is passed a null input only when the table contains a null\n      // value.\n      return contains(rowKey, columnKey) ? function.apply(fromTable.get(rowKey, columnKey)) : null;\n    }\n    @Override\n    public int size() {\n      return fromTable.size();\n    }\n    @Override\n    public void clear() {\n      fromTable.clear();\n    }\n    @Override\n    public V2 put(R rowKey, C columnKey, V2 value) {\n      throw new UnsupportedOperationException();\n    }\n    @Override\n    public void putAll(Table<? extends R, ? extends C, ? extends V2> table) {\n      throw new UnsupportedOperationException();\n    }\n    @Override\n    public V2 remove(Object rowKey, Object columnKey) {\n      return contains(rowKey, columnKey)\n          ? function.apply(fromTable.remove(rowKey, columnKey))\n          : null;\n    }\n    @Override\n    public Map<C, V2> row(R rowKey) {\n      return Maps.transformValues(fromTable.row(rowKey), function);\n    }\n    @Override\n    public Map<R, V2> column(C columnKey) {\n      return Maps.transformValues(fromTable.column(columnKey), function);\n    }\n    Function<Cell<R, C, V1>, Cell<R, C, V2>> cellFunction() {\n      return new Function<Cell<R, C, V1>, Cell<R, C, V2>>() {\n        @Override\n        public Cell<R, C, V2> apply(Cell<R, C, V1> cell) {\n          return immutableCell(\n              cell.getRowKey(), cell.getColumnKey(), function.apply(cell.getValue()));\n        }\n      };\n    }\n    @Override\n    Iterator<Cell<R, C, V2>> cellIterator() {\n      return Iterators.transform(fromTable.cellSet().iterator(), cellFunction());\n    }\n    @Override\n    public Set<R> rowKeySet() {\n      return fromTable.rowKeySet();\n    }\n    @Override\n    public Set<C> columnKeySet() {\n      return fromTable.columnKeySet();\n    }\n    @Override\n    Collection<V2> createValues() {\n      return Collections2.transform(fromTable.values(), function);\n    }\n    @Override\n    public Map<R, Map<C, V2>> rowMap() {\n      Function<Map<C, V1>, Map<C, V2>> rowFunction =\n          new Function<Map<C, V1>, Map<C, V2>>() {\n            @Override\n            public Map<C, V2> apply(Map<C, V1> row) {\n              return Maps.transformValues(row, function);\n            }\n          };\n      return Maps.transformValues(fromTable.rowMap(), rowFunction);\n    }\n    @Override\n    public Map<C, Map<R, V2>> columnMap() {\n      Function<Map<R, V1>, Map<R, V2>> columnFunction =\n          new Function<Map<R, V1>, Map<R, V2>>() {\n            @Override\n            public Map<R, V2> apply(Map<R, V1> column) {\n              return Maps.transformValues(column, function);\n            }\n          };\n      return Maps.transformValues(fromTable.columnMap(), columnFunction);\n    }\n  }\n  /**\n   * Returns an unmodifiable view of the specified table. This method allows modules to provide\n   * users with \"read-only\" access to internal tables. Query operations on the returned table \"read\n   * through\" to the specified table, and attempts to modify the returned table, whether direct or\n   * via its collection views, result in an {@code UnsupportedOperationException}.\n   *\n   * <p>The returned table will be serializable if the specified table is serializable.\n   *\n   * <p>Consider using an {@link ImmutableTable}, which is guaranteed never to change.\n   *\n   * @since 11.0\n   */\n  public static <R, C, V> Table<R, C, V> unmodifiableTable(\n      Table<? extends R, ? extends C, ? extends V> table) {\n    return new UnmodifiableTable<>(table);\n  }\n  private static class UnmodifiableTable<R, C, V> extends ForwardingTable<R, C, V>\n      implements Serializable {\n    final Table<? extends R, ? extends C, ? extends V> delegate;\n    UnmodifiableTable(Table<? extends R, ? extends C, ? extends V> delegate) {\n      this.delegate = checkNotNull(delegate);\n    }\n    @SuppressWarnings(\"unchecked\") // safe, covariant cast\n    @Override\n    protected Table<R, C, V> delegate() {\n      return (Table<R, C, V>) delegate;\n    }\n    @Override\n    public Set<Cell<R, C, V>> cellSet() {\n      return Collections.unmodifiableSet(super.cellSet());\n    }\n    @Override\n    public void clear() {\n      throw new UnsupportedOperationException();\n    }\n    @Override\n    public Map<R, V> column(@NullableDecl C columnKey) {\n      return Collections.unmodifiableMap(super.column(columnKey));\n    }\n    @Override\n    public Set<C> columnKeySet() {\n      return Collections.unmodifiableSet(super.columnKeySet());\n    }\n    @Override\n    public Map<C, Map<R, V>> columnMap() {\n      Function<Map<R, V>, Map<R, V>> wrapper = unmodifiableWrapper();\n      return Collections.unmodifiableMap(Maps.transformValues(super.columnMap(), wrapper));\n    }\n    @Override\n    public V put(@NullableDecl R rowKey, @NullableDecl C columnKey, @NullableDecl V value) {\n      throw new UnsupportedOperationException();\n    }\n    @Override\n    public void putAll(Table<? extends R, ? extends C, ? extends V> table) {\n      throw new UnsupportedOperationException();\n    }\n    @Override\n    public V remove(@NullableDecl Object rowKey, @NullableDecl Object columnKey) {\n      throw new UnsupportedOperationException();\n    }\n    @Override\n    public Map<C, V> row(@NullableDecl R rowKey) {\n      return Collections.unmodifiableMap(super.row(rowKey));\n    }\n    @Override\n    public Set<R> rowKeySet() {\n      return Collections.unmodifiableSet(super.rowKeySet());\n    }\n    @Override\n    public Map<R, Map<C, V>> rowMap() {\n      Function<Map<C, V>, Map<C, V>> wrapper = unmodifiableWrapper();\n      return Collections.unmodifiableMap(Maps.transformValues(super.rowMap(), wrapper));\n    }\n    @Override\n    public Collection<V> values() {\n      return Collections.unmodifiableCollection(super.values());\n    }\n    private static final long serialVersionUID = 0;\n  }\n  /**\n   * Returns an unmodifiable view of the specified row-sorted table. This method allows modules to\n   * provide users with \"read-only\" access to internal tables. Query operations on the returned\n   * table \"read through\" to the specified table, and attempts to modify the returned table, whether\n   * direct or via its collection views, result in an {@code UnsupportedOperationException}.\n   *\n   * <p>The returned table will be serializable if the specified table is serializable.\n   *\n   * @param table the row-sorted table for which an unmodifiable view is to be returned\n   * @return an unmodifiable view of the specified table\n   * @since 11.0\n   */\n  @Beta\n  public static <R, C, V> RowSortedTable<R, C, V> unmodifiableRowSortedTable(\n      RowSortedTable<R, ? extends C, ? extends V> table) {\n    /*\n     * It's not ? extends R, because it's technically not covariant in R. Specifically,\n     * table.rowMap().comparator() could return a comparator that only works for the ? extends R.\n     * Collections.unmodifiableSortedMap makes the same distinction.\n     */\n    return new UnmodifiableRowSortedMap<>(table);\n  }\n  static final class UnmodifiableRowSortedMap<R, C, V> extends UnmodifiableTable<R, C, V>\n      implements RowSortedTable<R, C, V> {\n    public UnmodifiableRowSortedMap(RowSortedTable<R, ? extends C, ? extends V> delegate) {\n      super(delegate);\n    }\n    @Override\n    protected RowSortedTable<R, C, V> delegate() {\n      return (RowSortedTable<R, C, V>) super.delegate();\n    }\n<fim_suffix>    @Override\n    public SortedMap<R, Map<C, V>> rowMap() {\n      Function<Map<C, V>, Map<C, V>> wrapper = unmodifiableWrapper();\n      return Collections.unmodifiableSortedMap(Maps.transformValues(delegate().rowMap(), wrapper));\n    }<fim_middle>// function below has no smell\n"}