{"text": "<fim_prefix>                \"WriteCopy operation is only supported for S3 API. Request API [%s]\", api);\n            final String sourceUri;\n            if (containerSuffix != null && Integer.parseInt(containerSuffix) != -1) {\n              sourceUri = \"/\" + containerPrefix + containerSuffix + \"/\" + objectName;\n            } else {\n              sourceUri = \"/\" + containerPrefix + \"/\" + objectName;\n            }\n            input.put(Context.X_OG_SSE_SOURCE_URI, sourceUri);\n            return sourceUri;\n          }\n        };\n    if (encryptDestinationObject) {\n      checkArgument(api == Api.S3,\n          \"WriteCopy operation is only supported for S3 API. Request API [%s]\", api);\n      if (!headers.containsKey(\"x-amz-server-side-encryption-customer-algorithm\")) {\n        headers.put(\"x-amz-server-side-encryption-customer-algorithm\",\n            provideSSEEncryptionAlgorithm());\n      }\n      if (!headers.containsKey(\"x-amz-server-side-encryption-customer-key\")) {\n        headers.put(\"x-amz-server-side-encryption-customer-key\", provideSSEEncryptionKey());\n      }\n      if (!headers.containsKey(\"x-amz-server-side-encryption-customer-key-MD5\")) {\n        headers.put(\"x-amz-server-side-encryption-customer-key-MD5\", provideSSEKeyMD5());\n      }\n    }\n    if (encryptedSourceObject) {\n      if (!headers.containsKey(\"x-amz-copy-source-server-side-encryption-customer-algorithm\")) {\n        headers.put(\"x-amz-copy-source-server-side-encryption-customer-algorithm\",\n            provideSSEEncryptionAlgorithm());\n      }\n      if (!headers.containsKey(\"x-amz-copy-source-server-side-encryption-customer-key\")) {\n        headers.put(\"x-amz-copy-source-server-side-encryption-customer-key\",\n            provideSSEEncryptionKey());\n      }\n      if (!headers.containsKey(\"x-amz-copy-source-server-side-encryption-customer-key-MD5\")) {\n        headers.put(\"x-amz-copy-source-server-side-encryption-customer-key-MD5\",\n            provideSSEKeyMD5());\n      }\n    }\n    headers.put(\"x-amz-copy-source\", copySource);\n    return createRequestSupplier(Operation.WRITE_COPY, id, Method.PUT, scheme, host, port, uriRoot,\n        container, apiVersion, writeObject, queryParameters, headers, context, sseReadContext, null,\n        credentials, virtualHost, null, null, false, delimiter);\n  }\n  @Provides\n  @Singleton\n  @Named(\"overwrite\")\n  public Supplier<Request> provideOverwrite(\n      @Named(\"request.id\") final Function<Map<String, String>, String> id, final Api api,\n      final Scheme scheme, @OverwriteHost final Function<Map<String, String>, String> host,\n      @Nullable @Named(\"port\") final Integer port,\n      @Nullable @Named(\"uri.root\") final String uriRoot,\n      @Named(\"overwrite.container\") final Function<Map<String, String>, String> container,\n      @Nullable @Named(\"api.version\") final String apiVersion,\n      @Nullable @OverwriteObjectName final Function<Map<String, String>, String> object,\n      @OverwriteHeaders final Map<String, Function<Map<String, String>, String>> headers,\n      @Named(\"overwrite.context\") final List<Function<Map<String, String>, String>> context,\n      @OverwriteBody final Function<Map<String, String>, Body> body,\n      @Nullable @Named(\"credentials\") final Function<Map<String, String>, Credential> credentials,\n      @Named(\"virtualhost\") final boolean virtualHost,\n      @Named(\"overwrite.weight\") final double overwriteWeight,\n      @Named(\"overwrite.sseCDestination\") final boolean encryptDestinationObject,\n      @Nullable @Named(\"overwrite.retention\") final Function<Map<String, String>, Long> retention,\n      @Nullable @Named(\"overwrite.legalHold\") final Supplier<Function<Map<String, String>, String>> legalHold,\n      @Nullable @Named(\"overwrite.contentMd5\") final boolean contentMd5) throws Exception {\n    if (encryptDestinationObject) {\n      checkArgument(this.config.data == DataType.ZEROES,\n          \"If SSE-C is enabled, data must be ZEROES [%s]\", this.config.data);\n    }\n    // SOH needs to use a special response consumer to extract the returned object id\n    if (Api.SOH == api && overwriteWeight > 0.0) {\n      throw new Exception(\"Overwrites are not compatible with SOH\");\n    }\n    if (contentMd5) {\n      checkArgument(this.config.data == DataType.ZEROES,\n          \"If contentMD5 is set, data must be ZEROES [%s]\", this.config.data);\n    }\n    final Map<String, Function<Map<String, String>, String>> queryParameters =\n        Collections.emptyMap();\n    if (encryptDestinationObject) {\n      if (!headers.containsKey(\"x-amz-server-side-encryption-customer-algorithm\")) {\n        headers.put(\"x-amz-server-side-encryption-customer-algorithm\",\n            provideSSEEncryptionAlgorithm());\n      }\n      if (!headers.containsKey(\"x-amz-server-side-encryption-customer-key\")) {\n        headers.put(\"x-amz-server-side-encryption-customer-key\", provideSSEEncryptionKey());\n      }\n      if (!headers.containsKey(\"x-amz-server-side-encryption-customer-key-MD5\")) {\n        headers.put(\"x-amz-server-side-encryption-customer-key-MD5\", provideSSEKeyMD5());\n      }\n    }\n    return createRequestSupplier(Operation.OVERWRITE, id, Method.PUT, scheme, host, port, uriRoot,\n        container, apiVersion, object, queryParameters, headers, context, null, body, credentials,\n        virtualHost, retention, legalHold, contentMd5, null);\n  }\n<fim_suffix>  @Provides\n  @Singleton\n  @Named(\"read\")\n  public Supplier<Request> provideRead(\n      @Named(\"request.id\") final Function<Map<String, String>, String> id, final Scheme scheme,\n      @ReadHost final Function<Map<String, String>, String> host,\n      @Nullable @Named(\"port\") final Integer port,\n      @Nullable @Named(\"uri.root\") final String uriRoot,\n      @Named(\"read.container\") final Function<Map<String, String>, String> container,\n      @Nullable @Named(\"api.version\") final String apiVersion,\n      @Nullable @ReadObjectName final Function<Map<String, String>, String> object,\n      @ReadHeaders final Map<String, Function<Map<String, String>, String>> headers,\n      @Named(\"read.context\") final List<Function<Map<String, String>, String>> context,\n      @Nullable @Named(\"credentials\") final Function<Map<String, String>, Credential> credentials,\n      @Named(\"virtualhost\") final boolean virtualHost,\n      @Named(\"read.sseCSource\") final boolean encryptedSourceObject) {\n    final Map<String, Function<Map<String, String>, String>> queryParameters =\n        Collections.emptyMap();\n    if (encryptedSourceObject) {\n      if (!headers.containsKey(\"x-amz-server-side-encryption-customer-algorithm\")) {\n        headers.put(\"x-amz-server-side-encryption-customer-algorithm\",\n            provideSSEEncryptionAlgorithm());\n      }\n      if (!headers.containsKey(\"x-amz-server-side-encryption-customer-key\")) {\n        headers.put(\"x-amz-server-side-encryption-customer-key\", provideSSEEncryptionKey());\n      }\n      if (!headers.containsKey(\"x-amz-server-side-encryption-customer-key-MD5\")) {\n        headers.put(\"x-amz-server-side-encryption-customer-key-MD5\", provideSSEKeyMD5());\n      }\n    }\n    final Supplier<Body> bodySupplier = Suppliers.of(Bodies.none());\n    final Function<Map<String, String>, Body> body = MoreFunctions.forSupplier(bodySupplier);\n    return createRequestSupplier(Operation.READ, id, Method.GET, scheme, host, port, uriRoot,\n        container, apiVersion, object, queryParameters, headers, context, null, body, credentials,\n        virtualHost, null, null, false, null);\n  }<fim_middle>// function below has no smell\n"}