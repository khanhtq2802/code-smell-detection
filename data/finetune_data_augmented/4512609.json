{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.felix.framework;\nimport java.io.File;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Dictionary;\nimport org.osgi.framework.AdminPermission;\nimport org.osgi.framework.Bundle;\nimport org.osgi.framework.BundleContext;\nimport org.osgi.framework.BundleException;\nimport org.osgi.framework.BundleListener;\nimport org.osgi.framework.Constants;\nimport org.osgi.framework.Filter;\nimport org.osgi.framework.FrameworkListener;\nimport org.osgi.framework.InvalidSyntaxException;\nimport org.osgi.framework.ServiceFactory;\nimport org.osgi.framework.ServiceListener;\nimport org.osgi.framework.ServiceObjects;\nimport org.osgi.framework.ServicePermission;\nimport org.osgi.framework.ServiceReference;\nimport org.osgi.framework.ServiceRegistration;\nimport org.osgi.framework.SynchronousBundleListener;\nclass BundleContextImpl implements BundleContext\n{\n    private Logger m_logger = null;\n    private Felix m_felix = null;\n    private BundleImpl m_bundle = null;\n    private boolean m_valid = true;\n    protected BundleContextImpl(Logger logger, Felix felix, BundleImpl bundle)\n    {\n        m_logger = logger;\n        m_felix = felix;\n        m_bundle = bundle;\n    }\n    protected void invalidate()\n    {\n        m_valid = false;\n    }\n    public String getProperty(String name)\n    {\n        checkValidity();\n        // CONCURRENCY NOTE: This is a check-then-act situation,\n        // but we ignore it since the time window is small and\n        // the result is the same as if the calling thread had\n        // won the race condition.\n        Object sm = System.getSecurityManager();\n        if (sm != null)\n        {\n            if (!(Constants.FRAMEWORK_VERSION.equals(name) ||\n                Constants.FRAMEWORK_VENDOR.equals(name) ||\n                Constants.FRAMEWORK_LANGUAGE.equals(name)||\n                Constants.FRAMEWORK_OS_NAME.equals(name) ||\n                Constants.FRAMEWORK_OS_VERSION.equals(name) ||\n                Constants.FRAMEWORK_PROCESSOR.equals(name)))\n            {\n                ((SecurityManager) sm).checkPermission(\n                    new java.util.PropertyPermission(name, \"read\"));\n            }\n        }\n        return m_felix.getProperty(name);\n    }\n    public Bundle getBundle()\n    {\n        checkValidity();\n        // CONCURRENCY NOTE: This is a check-then-act situation,\n        // but we ignore it since the time window is small and\n        // the result is the same as if the calling thread had\n        // won the race condition.\n        return m_bundle;\n    }\n    public Filter createFilter(String expr)\n        throws InvalidSyntaxException\n    {\n        checkValidity();\n        // CONCURRENCY NOTE: This is a check-then-act situation,\n        // but we ignore it since the time window is small and\n        // the result is the same as if the calling thread had\n        // won the race condition.\n        return new FilterImpl(expr);\n    }\n    public Bundle installBundle(String location)\n        throws BundleException\n    {\n        return installBundle(location, null);\n    }\n    public Bundle installBundle(String location, InputStream is)\n        throws BundleException\n    {\n        checkValidity();\n        // CONCURRENCY NOTE: This is a check-then-act situation,\n        // but we ignore it since the time window is small and\n        // the result is the same as if the calling thread had\n        // won the race condition.\n        Bundle result = null;\n        Object sm = System.getSecurityManager();\n        if (sm != null)\n        {\n            result = m_felix.installBundle(m_bundle, location, is);\n            // Do check the bundle again in case that is was installed\n            // already.\n            ((SecurityManager) sm).checkPermission(\n                new AdminPermission(result, AdminPermission.LIFECYCLE));\n        }\n        else\n        {\n            result = m_felix.installBundle(m_bundle, location, is);\n        }\n        return result;\n    }\n    public Bundle getBundle(long id)\n    {\n        checkValidity();\n        // CONCURRENCY NOTE: This is a check-then-act situation,\n        // but we ignore it since the time window is small and\n        // the result is the same as if the calling thread had\n        // won the race condition.\n        return m_felix.getBundle(this, id);\n    }\n    public Bundle getBundle(String location)\n    {\n        checkValidity();\n        // CONCURRENCY NOTE: This is a check-then-act situation,\n        // but we ignore it since the time window is small and\n        // the result is the same as if the calling thread had\n        // won the race condition.\n        return m_felix.getBundle(location);\n    }\n    public Bundle[] getBundles()\n    {\n        checkValidity();\n        // CONCURRENCY NOTE: This is a check-then-act situation,\n        // but we ignore it since the time window is small and\n        // the result is the same as if the calling thread had\n        // won the race condition.\n        return m_felix.getBundles(this);\n    }\n<fim_suffix>    public void addBundleListener(BundleListener l)\n    {\n        checkValidity();\n        // CONCURRENCY NOTE: This is a check-then-act situation, but\n        // internally the event dispatcher double checks whether or not\n        // the bundle context is valid before adding the service listener\n        // while holding the event queue lock, so it will either succeed\n        // or fail.\n        Object sm = System.getSecurityManager();\n        if (sm != null)\n        {\n            if (l instanceof SynchronousBundleListener)\n            {\n                ((SecurityManager) sm).checkPermission(new AdminPermission(m_bundle,\n                    AdminPermission.LISTENER));\n            }\n        }\n        m_felix.addBundleListener(m_bundle, l);\n    }\n    public void removeBundleListener(BundleListener l)\n    {\n        checkValidity();\n        // CONCURRENCY NOTE: This is a check-then-act situation,\n        // but we ignore it since the time window is small and\n        // the result is the same as if the calling thread had\n        // won the race condition.\n        Object sm = System.getSecurityManager();\n        if (sm != null)\n        {\n            if (l instanceof SynchronousBundleListener)\n            {\n                ((SecurityManager) sm).checkPermission(new AdminPermission(m_bundle,\n                    AdminPermission.LISTENER));\n            }\n        }\n        m_felix.removeBundleListener(m_bundle, l);\n    }\n    public void addServiceListener(ServiceListener l)\n    {\n        try\n        {\n            addServiceListener(l, null);\n        }\n        catch (InvalidSyntaxException ex)\n        {\n            // This will not happen since the filter is null.\n        }\n    }\n    public void addServiceListener(ServiceListener l, String s)\n        throws InvalidSyntaxException\n    {\n        checkValidity();\n        // CONCURRENCY NOTE: This is a check-then-act situation, but\n        // internally the event dispatcher double checks whether or not\n        // the bundle context is valid before adding the service listener\n        // while holding the event queue lock, so it will either succeed\n        // or fail.\n        m_felix.addServiceListener(m_bundle, l, s);\n    }\n    public void removeServiceListener(ServiceListener l)\n    {\n        checkValidity();\n        // CONCURRENCY NOTE: This is a check-then-act situation,\n        // but we ignore it since the time window is small and\n        // the result is the same as if the calling thread had\n        // won the race condition.\n        m_felix.removeServiceListener(m_bundle, l);\n    }\n    public void addFrameworkListener(FrameworkListener l)\n    {\n        checkValidity();\n        // CONCURRENCY NOTE: This is a check-then-act situation, but\n        // internally the event dispatcher double checks whether or not\n        // the bundle context is valid before adding the service listener\n        // while holding the event queue lock, so it will either succeed\n        // or fail.\n        m_felix.addFrameworkListener(m_bundle, l);\n    }\n    public void removeFrameworkListener(FrameworkListener l)\n    {\n        checkValidity();\n        // CONCURRENCY NOTE: This is a check-then-act situation,<fim_middle>// function below has no smell\n"}