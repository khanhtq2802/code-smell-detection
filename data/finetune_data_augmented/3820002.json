{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.accumulo.core.clientImpl;\nimport static org.apache.accumulo.fate.util.UtilWaitThread.sleepUninterruptibly;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map.Entry;\nimport java.util.concurrent.TimeUnit;\nimport org.apache.accumulo.core.Constants;\nimport org.apache.accumulo.core.client.AccumuloException;\nimport org.apache.accumulo.core.client.SampleNotPresentException;\nimport org.apache.accumulo.core.client.TableNotFoundException;\nimport org.apache.accumulo.core.client.sample.SamplerConfiguration;\nimport org.apache.accumulo.core.conf.AccumuloConfiguration;\nimport org.apache.accumulo.core.conf.ConfigurationCopy;\nimport org.apache.accumulo.core.conf.IterConfigUtil;\nimport org.apache.accumulo.core.conf.IterLoad;\nimport org.apache.accumulo.core.conf.Property;\nimport org.apache.accumulo.core.crypto.CryptoServiceFactory;\nimport org.apache.accumulo.core.data.Key;\nimport org.apache.accumulo.core.data.KeyValue;\nimport org.apache.accumulo.core.data.PartialKey;\nimport org.apache.accumulo.core.data.Range;\nimport org.apache.accumulo.core.data.TableId;\nimport org.apache.accumulo.core.data.Value;\nimport org.apache.accumulo.core.dataImpl.KeyExtent;\nimport org.apache.accumulo.core.file.FileOperations;\nimport org.apache.accumulo.core.file.FileSKVIterator;\nimport org.apache.accumulo.core.iterators.IteratorEnvironment;\nimport org.apache.accumulo.core.iterators.IteratorUtil.IteratorScope;\nimport org.apache.accumulo.core.iterators.SortedKeyValueIterator;\nimport org.apache.accumulo.core.iterators.system.MultiIterator;\nimport org.apache.accumulo.core.master.state.tables.TableState;\nimport org.apache.accumulo.core.metadata.schema.MetadataSchema.TabletsSection;\nimport org.apache.accumulo.core.metadata.schema.TabletMetadata;\nimport org.apache.accumulo.core.metadata.schema.TabletsMetadata;\nimport org.apache.accumulo.core.sample.impl.SamplerConfigurationImpl;\nimport org.apache.accumulo.core.security.Authorizations;\nimport org.apache.accumulo.core.security.ColumnVisibility;\nimport org.apache.accumulo.core.util.LocalityGroupUtil;\nimport org.apache.accumulo.core.util.SystemIteratorUtil;\nimport org.apache.accumulo.core.volume.VolumeConfiguration;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.fs.FileSystem;\nimport org.apache.hadoop.io.Text;\nclass OfflineIterator implements Iterator<Entry<Key,Value>> {\n<fim_suffix>  static class OfflineIteratorEnvironment implements IteratorEnvironment {\n    private final Authorizations authorizations;\n    private AccumuloConfiguration conf;\n    private boolean useSample;\n    private SamplerConfiguration sampleConf;\n    public OfflineIteratorEnvironment(Authorizations auths, AccumuloConfiguration acuTableConf,\n        boolean useSample, SamplerConfiguration samplerConf) {\n      this.authorizations = auths;\n      this.conf = acuTableConf;\n      this.useSample = useSample;\n      this.sampleConf = samplerConf;\n    }\n    @Deprecated\n    @Override\n    public AccumuloConfiguration getConfig() {\n      return conf;\n    }\n    @Override\n    public IteratorScope getIteratorScope() {\n      return IteratorScope.scan;\n    }\n    @Override\n    public boolean isFullMajorCompaction() {\n      return false;\n    }\n    @Override\n    public boolean isUserCompaction() {\n      return false;\n    }\n    private ArrayList<SortedKeyValueIterator<Key,Value>> topLevelIterators = new ArrayList<>();\n    @Deprecated\n    @Override\n    public void registerSideChannel(SortedKeyValueIterator<Key,Value> iter) {\n      topLevelIterators.add(iter);\n    }\n    @Override\n    public Authorizations getAuthorizations() {\n      return authorizations;\n    }\n    SortedKeyValueIterator<Key,Value> getTopLevelIterator(SortedKeyValueIterator<Key,Value> iter) {\n      if (topLevelIterators.isEmpty())\n        return iter;\n      ArrayList<SortedKeyValueIterator<Key,Value>> allIters = new ArrayList<>(topLevelIterators);\n      allIters.add(iter);\n      return new MultiIterator(allIters, false);\n    }\n    @Override\n    public boolean isSamplingEnabled() {\n      return useSample;\n    }\n    @Override\n    public SamplerConfiguration getSamplerConfiguration() {\n      return sampleConf;\n    }\n    @Override\n    public IteratorEnvironment cloneWithSamplingEnabled() {\n      if (sampleConf == null)\n        throw new SampleNotPresentException();\n      return new OfflineIteratorEnvironment(authorizations, conf, true, sampleConf);\n    }\n  }\n  private SortedKeyValueIterator<Key,Value> iter;\n  private Range range;\n  private KeyExtent currentExtent;\n  private TableId tableId;\n  private Authorizations authorizations;\n  private ClientContext context;\n  private ScannerOptions options;\n  private ArrayList<SortedKeyValueIterator<Key,Value>> readers;\n  private AccumuloConfiguration config;\n  public OfflineIterator(ScannerOptions options, ClientContext context,\n      Authorizations authorizations, Text table, Range range) {\n    this.options = new ScannerOptions(options);\n    this.context = context;\n    this.range = range;\n    if (this.options.fetchedColumns.size() > 0) {\n      this.range = range.bound(this.options.fetchedColumns.first(),\n          this.options.fetchedColumns.last());\n    }\n    this.tableId = TableId.of(table.toString());\n    this.authorizations = authorizations;\n    this.readers = new ArrayList<>();\n    try {\n      config = new ConfigurationCopy(context.instanceOperations().getSiteConfiguration());\n      nextTablet();\n      while (iter != null && !iter.hasTop())\n        nextTablet();\n    } catch (Exception e) {\n      if (e instanceof RuntimeException)\n        throw (RuntimeException) e;\n      throw new RuntimeException(e);\n    }\n  }\n  @Override\n  public boolean hasNext() {\n    return iter != null && iter.hasTop();\n  }\n  @Override\n  public Entry<Key,Value> next() {\n    try {\n      byte[] v = iter.getTopValue().get();\n      // copy just like tablet server does, do this before calling next\n      KeyValue ret = new KeyValue(new Key(iter.getTopKey()), Arrays.copyOf(v, v.length));\n      iter.next();\n      while (iter != null && !iter.hasTop())\n        nextTablet();\n      return ret;\n    } catch (Exception e) {\n      throw new RuntimeException(e);\n    }\n  }\n  private void nextTablet() throws TableNotFoundException, AccumuloException, IOException {\n    Range nextRange = null;\n    if (currentExtent == null) {\n      Text startRow;\n      if (range.getStartKey() != null)\n        startRow = range.getStartKey().getRow();\n      else\n        startRow = new Text();\n      nextRange = new Range(TabletsSection.getRow(tableId, startRow), true, null, false);\n    } else {\n      if (currentExtent.getEndRow() == null) {\n        iter = null;\n        return;\n      }\n      if (range.afterEndKey(new Key(currentExtent.getEndRow()).followingKey(PartialKey.ROW))) {\n        iter = null;\n        return;\n      }\n      nextRange = new Range(currentExtent.getMetadataEntry(), false, null, false);\n    }\n    TabletMetadata tablet = getTabletFiles(nextRange);\n    while (tablet.getLocation() != null) {\n      if (Tables.getTableState(context, tableId) != TableState.OFFLINE) {\n        Tables.clearCache(context);\n        if (Tables.getTableState(context, tableId) != TableState.OFFLINE) {<fim_middle>// class below is data class\n"}