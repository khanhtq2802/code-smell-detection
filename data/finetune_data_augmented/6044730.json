{"text": "<fim_prefix>/*-\n *******************************************************************************\n * Copyright (c) 2011, 2014 Diamond Light Source Ltd.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *    Peter Chang - initial API and implementation and/or initial documentation\n *******************************************************************************/\npackage org.eclipse.dawnsci.analysis.dataset.roi;\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeSet;\nimport org.eclipse.dawnsci.analysis.dataset.coords.SectorCoords;\n/**\n * Class for sector region of interest\n */\npublic class SectorROI extends RingROI implements Serializable {\n\tprotected double ang[]; // angles in radians\n\tprotected boolean combineSymmetry; // combine symmetry option for profile (where appropriate)\n\tprotected int symmetry; // symmetry\n\t/**\n\t * No operation\n\t */\n\tpublic static final int NONE = 0;\n\t/**\n\t * Full circular sector\n\t */\n\tpublic static final int FULL = 1;\n\t/**\n\t * Reflect sector in y-axis (left/right)\n\t */\n\tpublic static final int XREFLECT = 2;\n\t/**\n\t * Reflect sector in x-axis (up/down)\n\t */\n\tpublic static final int YREFLECT = 3;\n\t/**\n\t * Rotate sector by +90 degrees\n\t */\n\tpublic static final int CNINETY = 4;\n\t/**\n\t * Rotate sector by -90 degrees\n\t */\n\tpublic static final int ACNINETY = 5;\n\t/**\n\t * Invert sector through centre\n\t */\n\tpublic static final int INVERT = 6;\n\tprivate static Map<Integer, String> symmetryText = new HashMap<Integer, String>();\n\tstatic {\n\t\tsymmetryText.put(SectorROI.NONE,     \"None\");\n\t\tsymmetryText.put(SectorROI.FULL,     \"Full\");\n\t\tsymmetryText.put(SectorROI.XREFLECT, \"L/R\");\n\t\tsymmetryText.put(SectorROI.YREFLECT, \"U/D\");\n\t\tsymmetryText.put(SectorROI.CNINETY,  \"+90\");\n\t\tsymmetryText.put(SectorROI.ACNINETY, \"-90\");\n\t\tsymmetryText.put(SectorROI.INVERT,   \"Invert\");\n\t}\n\tpublic static Map<Integer, String> getSymmetriesPossible() {\n\t\treturn symmetryText;\n\t}\n\t/**\n\t * @param symmetry The symmetry to set.\n\t */\n\tpublic void setSymmetry(int symmetry) {\n\t\tthis.symmetry = symmetry;\n\t\tsetDirty();\n\t}\n\t@Override\n\tprotected void setDirty() {\n\t\tsuper.setDirty();\n\t\tsymAng = null;\n\t}\n\t/**\n\t * @param symmetry The symmetry to set.\n\t */\n\tpublic static int getSymmetry(String symmetry) {\n\t\tif (symmetryText.containsValue(symmetry))\n\t\t\tfor (int key : symmetryText.keySet())\n\t\t\t\tif (symmetry.equals(symmetryText.get(key))) {\n\t\t\t\t\treturn key;\n\t\t\t\t}\n\t\treturn SectorROI.NONE;\n\t}\n\t/**\n\t * @return Returns the symmetry.\n\t */\n\tpublic int getSymmetry() {\n\t\treturn symmetry;\n\t}\n\t/**\n\t * \n\t */\n\tpublic SectorROI() {\n\t\tthis(30., 120., Math.PI*0.25, Math.PI*2./3.);\n\t}\n\tprivate final static double TWO_PI = 2.0 * Math.PI;\n\tprivate final static double HALF_PI = 0.5 * Math.PI;\n\t/**\n\t * Create an annulus\n\t * @param sr \n\t * @param er\n\t */\n\tpublic SectorROI(double sr, double er) {\n\t\tthis(0., 0., sr, er, 0, TWO_PI, 1.0, false, SectorROI.FULL);\n\t}\n\t/**\n\t * @param sr \n\t * @param er\n\t * @param sp\n\t * @param ep\n\t */\n\tpublic SectorROI(double sr, double er, double sp, double ep) {\n\t\tthis(0., 0., sr, er, sp, ep);\n\t}\n\t/**\n\t * @param ptx\n\t * @param pty\n\t * @param sr\n\t * @param er\n\t * @param sp\n\t * @param ep\n\t */\n\tpublic SectorROI(double ptx, double pty, double sr, double er, double sp, double ep) {\n\t\tthis(ptx, pty, sr, er, sp, ep, 1.0, true);\n\t}\n\t/**\n\t * @param ptx\n\t * @param pty\n\t * @param sr\n\t * @param er\n\t * @param sp\n\t * @param ep\n\t * @param dpp\n\t * @param clip \n\t */\n\tpublic SectorROI(double ptx, double pty, double sr, double er, double sp, double ep, double dpp, boolean clip) {\n\t\tthis(ptx, pty, sr, er, sp, ep, dpp, clip, SectorROI.NONE);\n\t}\n\t/**\n\t * @param ptx\n\t * @param pty\n\t * @param sr\n\t * @param er\n\t * @param sp\n\t * @param ep\n\t * @param dpp\n\t * @param clip \n\t * @param sym \n\t */\n\tpublic SectorROI(double ptx, double pty, double sr, double er, double sp, double ep, double dpp, boolean clip, int sym) {\n\t\tsuper(ptx, pty, sr, er, dpp, clip);\n\t\tang = new double[] {sp, ep};\n\t\tsymmetry = sym;\n\t\tcombineSymmetry = false;\n\t\tcheckAngles(ang);\n\t}\n\t/**\n\t * Set angles\n\t * @param startAngle\n\t * @param endAngle\n\t */\n\tpublic void setAngles(double startAngle, double endAngle) {\n\t\tang[0] = startAngle;\n\t\tang[1] = endAngle;\n\t\tcheckAngles(ang);\n\t\tsetDirty();\n\t}\n\t/**\n\t * @param angles The angles to set\n\t */\n\tpublic void setAngles(double angles[]) {\n\t\tsetAngles(angles[0], angles[1]);\n\t}\n\t/**\n\t * @return Returns the angles in degrees\n\t */\n<fim_suffix>\tpublic double[] getAnglesDegrees() {\n\t\tdouble[] angles = new double[] { Math.toDegrees(ang[0]), Math.toDegrees(ang[1]) };\n\t\treturn angles;\n\t}\n\t/**\n\t * @param index \n\t * @return Returns the angles in degrees\n\t */\n\tpublic double getAngleDegrees(int index) {\n\t\treturn Math.toDegrees(ang[index]);\n\t}\n\t/**\n\t * @param angles The angles in degrees to set\n\t */\n\tpublic void setAnglesDegrees(double angles[]) {\n\t\tsetAnglesDegrees(angles[0], angles[1]);\n\t}\n\t/**\n\t * For Jython\n\t * @param angles The angles in degrees to set\n\t */\n\tpublic void setAnglesdegrees(double[] angles) {\n\t\tsetAnglesDegrees(angles);\n\t}\n\t/**\n\t * @param startAngle in degrees\n\t * @param endAngle in degrees\n\t */\n\tpublic void setAnglesDegrees(double startAngle, double endAngle) {\n\t\tsetAngles(Math.toRadians(startAngle), Math.toRadians(endAngle));\n\t}\n\t/**\n\t * @return Returns reference to the angles\n\t */\n\tpublic double[] getAngles() {\n\t\treturn ang;\n\t}\n\t/**\n\t * @param index \n\t * @return Returns the angles\n\t */\n\tpublic double getAngle(int index) {\n\t\treturn ang[index];\n\t}\n\t/**\n\t * Add an offset to both angle\n\t * \n\t * @param angle\n\t */\n\tpublic void addAngles(double angle) {\n\t\tfor (int i = 0; i < 2; i++) {\n\t\t\tang[i] += angle;\n\t\t}\n\t\tif (ang[0] > TWO_PI) {\n\t\t\tang[0] -= TWO_PI;\n\t\t\tang[1] -= TWO_PI;\n\t\t}\n\t\tif (ang[0] < 0) {\n\t\t\tang[0] += TWO_PI;<fim_middle>// function below has no smell\n"}