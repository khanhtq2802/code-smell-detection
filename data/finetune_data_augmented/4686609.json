{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.hadoop.mapred;\n\nimport java.io.DataInputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.LongBuffer;\nimport java.util.zip.CheckedInputStream;\nimport java.util.zip.CheckedOutputStream;\nimport java.util.zip.Checksum;\n\nimport org.apache.hadoop.fs.ChecksumException;\nimport org.apache.hadoop.fs.FSDataOutputStream;\nimport org.apache.hadoop.fs.FileSystem;\nimport org.apache.hadoop.fs.Path;\nimport org.apache.hadoop.io.IOUtils;\nimport org.apache.hadoop.io.SecureIOUtils;\nimport org.apache.hadoop.security.UserGroupInformation;\nimport org.apache.hadoop.util.PureJavaCrc32;\n\nimport static org.apache.hadoop.mapred.MapTask.MAP_OUTPUT_INDEX_RECORD_LENGTH;\n\nclass SpillRecord {\n\n  /** Backing store */\n  private final ByteBuffer buf;\n  /** View of backing storage as longs */\n  private final LongBuffer entries;\n\n  public SpillRecord(int numPartitions) {\n    buf = ByteBuffer.allocate(\n        numPartitions * MapTask.MAP_OUTPUT_INDEX_RECORD_LENGTH);\n    entries = buf.asLongBuffer();\n  }\n\n  public SpillRecord(Path indexFileName, JobConf job) throws IOException {\n    this(indexFileName, job, null);\n  }\n\n  public SpillRecord(Path indexFileName, JobConf job, String expectedIndexOwner)\n    throws IOException {\n    this(indexFileName, job, new PureJavaCrc32(), expectedIndexOwner);\n  }\n\n  public SpillRecord(Path indexFileName, JobConf job, Checksum crc,\n                     String expectedIndexOwner)\n      throws IOException {\n\n    final FileSystem rfs = FileSystem.getLocal(job).getRaw();\n    final DataInputStream in = \n      new DataInputStream(SecureIOUtils.openForRead(\n          new File(indexFileName.toUri().getPath()), expectedIndexOwner, null));\n    try {\n      final long length = rfs.getFileStatus(indexFileName).getLen();\n      final int partitions = (int) length / MAP_OUTPUT_INDEX_RECORD_LENGTH;\n      final int size = partitions * MAP_OUTPUT_INDEX_RECORD_LENGTH;\n\n      buf = ByteBuffer.allocate(size);\n      if (crc != null) {\n        crc.reset();\n        CheckedInputStream chk = new CheckedInputStream(in, crc);\n        IOUtils.readFully(chk, buf.array(), 0, size);\n        if (chk.getChecksum().getValue() != in.readLong()) {\n          throw new ChecksumException(\"Checksum error reading spill index: \" +\n                                indexFileName, -1);\n        }\n      } else {\n        IOUtils.readFully(in, buf.array(), 0, size);\n      }\n      entries = buf.asLongBuffer();\n    } finally {\n      in.close();\n    }\n  }\n\n  /**\n   * Return number of IndexRecord entries in this spill.\n   */\n  public int size() {\n    return entries.capacity() / (MapTask.MAP_OUTPUT_INDEX_RECORD_LENGTH / 8);\n  }\n\n  /**\n   * Get spill offsets for given partition.\n   */\n  public IndexRecord getIndex(int partition) {\n    final int pos = partition * MapTask.MAP_OUTPUT_INDEX_RECORD_LENGTH / 8;\n    return new IndexRecord(entries.get(pos), entries.get(pos + 1),\n                           entries.get(pos + 2));\n  }\n\n  /**\n   * Set spill offsets for given partition.\n   */\n  public void putIndex(IndexRecord rec, int partition) {\n    final int pos = partition * MapTask.MAP_OUTPUT_INDEX_RECORD_LENGTH / 8;\n    entries.put(pos, rec.startOffset);\n    entries.put(pos + 1, rec.rawLength);\n    entries.put(pos + 2, rec.partLength);\n  }\n\n  /**\n   * Write this spill record to the location provided.\n   */\n  public void writeToFile(Path loc, JobConf job)\n      throws IOException {\n    writeToFile(loc, job, new PureJavaCrc32());\n  }\n\n  public void writeToFile(Path loc, JobConf job, Checksum crc)\n      throws IOException {\n    final FileSystem rfs = FileSystem.getLocal(job).getRaw();\n    CheckedOutputStream chk = null;\n    final FSDataOutputStream out = rfs.create(loc);\n    try {\n      if (crc != null) {\n        crc.reset();\n        chk = new CheckedOutputStream(out, crc);\n        chk.write(buf.array());\n        out.writeLong(chk.getChecksum().getValue());\n      } else {\n        out.write(buf.array());\n      }\n    } finally {\n      if (chk != null) {\n        chk.close();\n      } else {\n        out.close();\n      }\n    }\n  }\n\n}\n\n<fim_suffix>class IndexRecord {\n  long startOffset;\n  long rawLength;\n  long partLength;\n\n  public IndexRecord() { }\n\n  public IndexRecord(long startOffset, long rawLength, long partLength) {\n    this.startOffset = startOffset;\n    this.rawLength = rawLength;\n    this.partLength = partLength;\n  }\n}<fim_middle>// class below has no smell\n"}