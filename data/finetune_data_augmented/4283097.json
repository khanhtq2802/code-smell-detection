{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.crunch.types;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.nio.ByteBuffer;\nimport java.util.UUID;\nimport com.google.protobuf.ExtensionRegistry;\nimport org.apache.crunch.CrunchRuntimeException;\nimport org.apache.crunch.MapFn;\nimport org.apache.crunch.util.SerializableSupplier;\nimport org.apache.hadoop.util.ReflectionUtils;\nimport org.apache.thrift.TBase;\nimport org.apache.thrift.TDeserializer;\nimport org.apache.thrift.TException;\nimport org.apache.thrift.TSerializer;\nimport org.apache.thrift.protocol.TBinaryProtocol;\nimport org.codehaus.jackson.map.ObjectMapper;\nimport com.google.protobuf.InvalidProtocolBufferException;\nimport com.google.protobuf.Message;\n/**\n * Utility functions for creating common types of derived PTypes, e.g., for JSON\n * data, protocol buffers, and Thrift records.\n * \n */\npublic class PTypes {\n  /**\n   * A PType for Java's {@link BigInteger} type.\n   */\n  public static PType<BigInteger> bigInt(PTypeFamily typeFamily) {\n    return typeFamily.derivedImmutable(BigInteger.class, BYTE_TO_BIGINT, BIGINT_TO_BYTE, typeFamily.bytes());\n  }\n  /**\n   * A PType for Java's {@link BigDecimal} type.\n   */\n  public static PType<BigDecimal> bigDecimal(PTypeFamily typeFamily) {\n    return typeFamily.derivedImmutable(BigDecimal.class, BYTE_TO_BIGDECIMAL, BIGDECIMAL_TO_BYTE, typeFamily.bytes());\n  }\n  /**\n   * A PType for Java's {@link UUID} type.\n   */\n  public static PType<UUID> uuid(PTypeFamily ptf) {\n    return ptf.derivedImmutable(UUID.class, BYTE_TO_UUID, UUID_TO_BYTE, ptf.bytes());\n  }\n  /**\n   * Constructs a PType for reading a Java type from a JSON string using Jackson's {@link ObjectMapper}.\n   */\n  public static <T> PType<T> jsonString(Class<T> clazz, PTypeFamily typeFamily) {\n    return typeFamily\n        .derived(clazz, new JacksonInputMapFn<T>(clazz), new JacksonOutputMapFn<T>(), typeFamily.strings());\n  }\n  /**\n   * Constructs a PType for the given protocol buffer.\n   */\n  public static <T extends Message> PType<T> protos(Class<T> clazz, PTypeFamily typeFamily) {\n    return typeFamily.derivedImmutable(clazz, new ProtoInputMapFn<T>(clazz), new ProtoOutputMapFn<T>(), typeFamily.bytes());\n  }\n  /**\n   * Constructs a PType for a protocol buffer, using the given {@code SerializableSupplier} to provide\n   * an {@link ExtensionRegistry} to use in reading the given protobuf.\n   */\n  public static <T extends Message> PType<T> protos(\n      Class<T> clazz,\n      PTypeFamily typeFamily,\n      SerializableSupplier<ExtensionRegistry> supplier) {\n    return typeFamily.derivedImmutable(clazz,\n        new ProtoInputMapFn<T>(clazz, supplier),\n        new ProtoOutputMapFn<T>(),\n        typeFamily.bytes());\n  }\n  /**\n   * Constructs a PType for a Thrift record.\n   */\n  public static <T extends TBase> PType<T> thrifts(Class<T> clazz, PTypeFamily typeFamily) {\n    return typeFamily.derived(clazz, new ThriftInputMapFn<T>(clazz), new ThriftOutputMapFn<T>(), typeFamily.bytes());\n  }\n  /**\n   * Constructs a PType for a Java {@code Enum} type.\n   */\n  public static <T extends Enum> PType<T> enums(Class<T> type, PTypeFamily typeFamily) {\n    return typeFamily.derivedImmutable(type, new EnumInputMapper<T>(type), new EnumOutputMapper<T>(),\n        typeFamily.strings());\n  }\n  public static final MapFn<ByteBuffer, BigInteger> BYTE_TO_BIGINT = new MapFn<ByteBuffer, BigInteger>() {\n    @Override\n    public BigInteger map(ByteBuffer input) {\n      return input == null ? null : new BigInteger(input.array());\n    }\n  };\n  public static final MapFn<BigInteger, ByteBuffer> BIGINT_TO_BYTE = new MapFn<BigInteger, ByteBuffer>() {\n    @Override\n    public ByteBuffer map(BigInteger input) {\n      return input == null ? null : ByteBuffer.wrap(input.toByteArray());\n    }\n  };\n  public static final MapFn<ByteBuffer, BigDecimal> BYTE_TO_BIGDECIMAL = new MapFn<ByteBuffer, BigDecimal>() {\n    @Override\n    public BigDecimal map(ByteBuffer input) {\n      return input == null ? null : byteBufferToBigDecimal(input);\n    }\n  };\n  public static final MapFn<BigDecimal, ByteBuffer> BIGDECIMAL_TO_BYTE = new MapFn<BigDecimal, ByteBuffer>() {\n    @Override\n    public ByteBuffer map(BigDecimal input) {\n      return input == null ? null : bigDecimalToByteBuffer(input);\n    }\n  };\n<fim_suffix>  private static class JacksonInputMapFn<T> extends MapFn<String, T> {\n    private final Class<T> clazz;\n    private transient ObjectMapper mapper;\n    JacksonInputMapFn(Class<T> clazz) {\n      this.clazz = clazz;\n    }\n    @Override\n    public void initialize() {\n      this.mapper = new ObjectMapper();\n    }\n    @Override\n    public T map(String input) {\n      try {\n        return mapper.readValue(input, clazz);\n      } catch (Exception e) {\n        throw new CrunchRuntimeException(e);\n      }\n    }\n  }\n  private static class JacksonOutputMapFn<T> extends MapFn<T, String> {\n    private transient ObjectMapper mapper;\n    @Override\n    public void initialize() {\n      this.mapper = new ObjectMapper();\n    }\n    @Override\n    public String map(T input) {\n      try {\n        return mapper.writeValueAsString(input);\n      } catch (Exception e) {\n        throw new CrunchRuntimeException(e);\n      }\n    }\n  }\n  private static class ProtoInputMapFn<T extends Message> extends MapFn<ByteBuffer, T> {\n    private final Class<T> clazz;\n    private final SerializableSupplier<ExtensionRegistry> extensionSupplier;\n    private transient T instance;\n    private transient ExtensionRegistry registry;\n    ProtoInputMapFn(Class<T> clazz) {\n      this(clazz, null);\n    }\n    ProtoInputMapFn(Class<T> clazz, SerializableSupplier<ExtensionRegistry> extensionSupplier) {\n      this.clazz = clazz;\n      this.extensionSupplier = extensionSupplier;\n    }\n    @Override\n    public void initialize() {\n      this.instance = Protos.getDefaultInstance(clazz);\n      if (this.extensionSupplier != null) {\n        this.registry = extensionSupplier.get();\n      } else {\n        this.registry = ExtensionRegistry.getEmptyRegistry();\n      }\n    }\n    @Override\n    public T map(ByteBuffer bb) {\n      try {\n        return (T) instance.newBuilderForType().mergeFrom(bb.array(), bb.position(), bb.limit(), registry).build();\n      } catch (InvalidProtocolBufferException e) {\n        throw new CrunchRuntimeException(e);\n      }\n    }\n  }\n  private static class ProtoOutputMapFn<T extends Message> extends MapFn<T, ByteBuffer> {\n    ProtoOutputMapFn() {\n    }\n    @Override\n    public ByteBuffer map(T proto) {\n      return ByteBuffer.wrap(proto.toByteArray());\n    }\n  }\n  private static class ThriftInputMapFn<T extends TBase> extends MapFn<ByteBuffer, T> {\n    private final Class<T> clazz;\n    private transient T instance;\n    private transient TDeserializer deserializer;\n    private transient byte[] bytes;\n    ThriftInputMapFn(Class<T> clazz) {\n      this.clazz = clazz;\n    }\n    @Override\n    public void initialize() {\n      this.instance = ReflectionUtils.newInstance(clazz, null);\n      this.deserializer = new TDeserializer(new TBinaryProtocol.Factory());\n      this.bytes = new byte[0];\n    }\n    @Override\n    public T map(ByteBuffer bb) {\n      T next = (T) instance.deepCopy();\n      int len = bb.limit() - bb.position();\n      if (len != bytes.length) {\n        bytes = new byte[len];\n      }\n      System.arraycopy(bb.array(), bb.position(), bytes, 0, len);\n      try {<fim_middle>// class below has no smell\n"}