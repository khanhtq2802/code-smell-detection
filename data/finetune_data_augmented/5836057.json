{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.catalina.ha.context;\n\nimport java.util.Collections;\nimport java.util.Enumeration;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport javax.servlet.ServletContext;\n\nimport org.apache.catalina.Globals;\nimport org.apache.catalina.LifecycleException;\nimport org.apache.catalina.Loader;\nimport org.apache.catalina.core.ApplicationContext;\nimport org.apache.catalina.core.StandardContext;\nimport org.apache.catalina.ha.CatalinaCluster;\nimport org.apache.catalina.tribes.Channel;\nimport org.apache.catalina.tribes.tipis.AbstractReplicatedMap.MapOwner;\nimport org.apache.catalina.tribes.tipis.ReplicatedMap;\nimport org.apache.juli.logging.Log;\nimport org.apache.juli.logging.LogFactory;\nimport org.apache.tomcat.util.res.StringManager;\n\n/**\n * @version 1.0\n */\npublic class ReplicatedContext extends StandardContext implements MapOwner {\n    private int mapSendOptions = Channel.SEND_OPTIONS_DEFAULT;\n    private static final Log log = LogFactory.getLog(ReplicatedContext.class);\n    protected static final long DEFAULT_REPL_TIMEOUT = 15000;//15 seconds\n    private static final StringManager sm = StringManager.getManager(ReplicatedContext.class);\n\n    /**\n     * Start this component and implement the requirements\n     * of {@link org.apache.catalina.util.LifecycleBase#startInternal()}.\n     *\n     * @exception LifecycleException if this component detects a fatal error\n     *  that prevents this component from being used\n     */\n    @Override\n    protected synchronized void startInternal() throws LifecycleException {\n        super.startInternal();\n        try {\n            CatalinaCluster catclust = (CatalinaCluster)this.getCluster();\n            if ( catclust != null ) {\n                ReplicatedMap<String,Object> map = new ReplicatedMap<>(\n                        this, catclust.getChannel(),DEFAULT_REPL_TIMEOUT,\n                        getName(),getClassLoaders());\n                map.setChannelSendOptions(mapSendOptions);\n                ((ReplApplContext)this.context).setAttributeMap(map);\n            }\n        }  catch ( Exception x ) {\n            log.error(sm.getString(\"replicatedContext.startUnable\", getName()),x);\n            throw new LifecycleException(sm.getString(\"replicatedContext.startFailed\", getName()),x);\n        }\n    }\n\n    /**\n     * Stop this component and implement the requirements\n     * of {@link org.apache.catalina.util.LifecycleBase#stopInternal()}.\n     *\n     * @exception LifecycleException if this component detects a fatal error\n     *  that prevents this component from being used\n     */\n    @Override\n    protected synchronized void stopInternal() throws LifecycleException {\n\n        Map<String, Object> map = ((ReplApplContext) this.context)\n                .getAttributeMap();\n\n        super.stopInternal();\n\n        if (map instanceof ReplicatedMap) {\n            ((ReplicatedMap<?, ?>) map).breakdown();\n        }\n\n    }\n\n\n    public void setMapSendOptions(int mapSendOptions) {\n        this.mapSendOptions = mapSendOptions;\n    }\n\n    public int getMapSendOptions() {\n        return mapSendOptions;\n    }\n\n    public ClassLoader[] getClassLoaders() {\n        Loader loader = null;\n        ClassLoader classLoader = null;\n        loader = this.getLoader();\n        if (loader != null) classLoader = loader.getClassLoader();\n        if ( classLoader == null ) classLoader = Thread.currentThread().getContextClassLoader();\n        if ( classLoader == Thread.currentThread().getContextClassLoader() ) {\n            return new ClassLoader[] {classLoader};\n        } else {\n            return new ClassLoader[] {classLoader,Thread.currentThread().getContextClassLoader()};\n        }\n    }\n\n    @Override\n    public ServletContext getServletContext() {\n        if (context == null) {\n            context = new ReplApplContext(this);\n            if (getAltDDName() != null)\n                context.setAttribute(Globals.ALT_DD_ATTR,getAltDDName());\n        }\n\n        return ((ReplApplContext)context).getFacade();\n\n    }\n\n\n    protected static class ReplApplContext extends ApplicationContext {\n        protected final Map<String, Object> tomcatAttributes = new ConcurrentHashMap<>();\n\n        public ReplApplContext(ReplicatedContext context) {\n            super(context);\n        }\n\n        protected ReplicatedContext getParent() {\n            return (ReplicatedContext)getContext();\n        }\n\n        @Override\n        protected ServletContext getFacade() {\n             return super.getFacade();\n        }\n\n        public Map<String,Object> getAttributeMap() {\n            return this.attributes;\n        }\n        public void setAttributeMap(Map<String,Object> map) {\n            this.attributes = map;\n        }\n\n        @Override\n        public void removeAttribute(String name) {\n            tomcatAttributes.remove(name);\n            //do nothing\n            super.removeAttribute(name);\n        }\n\n        @Override\n        public void setAttribute(String name, Object value) {\n            if (name == null) {\n                throw new IllegalArgumentException(sm.getString(\"applicationContext.setAttribute.namenull\"));\n            }\n            if (value == null) {\n                removeAttribute(name);\n                return;\n            }\n            if ( (!getParent().getState().isAvailable()) || \"org.apache.jasper.runtime.JspApplicationContextImpl\".equals(name) ){\n                tomcatAttributes.put(name,value);\n            } else\n                super.setAttribute(name,value);\n        }\n\n        @Override\n        public Object getAttribute(String name) {\n            Object obj = tomcatAttributes.get(name);\n            if (obj == null) {\n                return super.getAttribute(name);\n            } else {\n                return obj;\n            }\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        @Override\n        public Enumeration<String> getAttributeNames() {\n            Set<String> names = new HashSet<>();\n            names.addAll(attributes.keySet());\n\n            return new MultiEnumeration<>(new Enumeration[] {\n                    super.getAttributeNames(),\n                    Collections.enumeration(names) });\n        }\n    }\n\n<fim_suffix>    protected static class MultiEnumeration<T> implements Enumeration<T> {\n        private final Enumeration<T>[] e;\n        public MultiEnumeration(Enumeration<T>[] lists) {\n            e = lists;\n        }\n        @Override\n        public boolean hasMoreElements() {\n            for ( int i=0; i<e.length; i++ ) {\n                if ( e[i].hasMoreElements() ) return true;\n            }\n            return false;\n        }\n        @Override\n        public T nextElement() {\n            for ( int i=0; i<e.length; i++ ) {\n                if ( e[i].hasMoreElements() ) return e[i].nextElement();\n            }\n            return null;\n\n        }\n    }\n\n    @Override\n    public void objectMadePrimary(Object key, Object value) {\n        //noop\n    }\n\n\n}<fim_middle>// class below has no smell\n"}