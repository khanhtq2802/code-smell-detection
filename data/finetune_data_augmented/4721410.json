{"text": "<fim_prefix>            final List<RetryReadListener> retryReadListeners\n                    = jobExecutionImpl.getListenerFactory().getListeners(RetryReadListener.class, step, injectionRef, jobExecutionImpl);\n            final List<RetryWriteListener> retryWriteListeners\n                    = jobExecutionImpl.getListenerFactory().getListeners(RetryWriteListener.class, step, injectionRef, jobExecutionImpl);\n            skipHandler = new SkipHandler(chunk);\n            skipHandler.addSkipProcessListener(skipProcessListeners);\n            skipHandler.addSkipReadListener(skipReadListeners);\n            skipHandler.addSkipWriteListener(skipWriteListeners);\n            retryHandler = new RetryHandler(chunk);\n            retryHandler.addRetryProcessListener(retryProcessListeners);\n            retryHandler.addRetryReadListener(retryReadListeners);\n            retryHandler.addRetryWriteListener(retryWriteListeners);\n        }\n    }\n    private void setNextChunkTransactionTimeout() {\n        int nextTimeout = 0;\n        if (customCheckpointPolicy) {\n            // Even on a retry-with-rollback, we'll continue to let\n            // the custom CheckpointAlgorithm set a tran timeout.\n            //\n            // We're guessing the application could need a smaller timeout than\n            // 180 seconds, (the default established by the batch chunk).\n            nextTimeout = this.checkpointManager.checkpointTimeout();\n        } else  {\n            nextTimeout = stepPropertyTranTimeoutSeconds;\n        }\n        transactionManager.setTransactionTimeout(nextTimeout);\n    }\n    /**\n     * Note we can rely on the StepContext properties already having been set at this point.\n     *\n     * @return global transaction timeout defined in step properties. default\n     */\n    private int initStepTransactionTimeout() {\n        Properties p = stepContext.getProperties();\n        int timeout = DEFAULT_TRAN_TIMEOUT_SECONDS; // default as per spec.\n        if (p != null && !p.isEmpty()) {\n            String propertyTimeOut = p.getProperty(\"javax.transaction.global.timeout\");\n            if (logger.isLoggable(Level.FINE)) {\n                logger.log(Level.FINE, \"javax.transaction.global.timeout = {0}\", propertyTimeOut==null ? \"<null>\" : propertyTimeOut);\n            }\n            if (propertyTimeOut != null && !propertyTimeOut.isEmpty()) {\n                timeout = Integer.parseInt(propertyTimeOut, 10);\n            }\n        }\n        return timeout;\n    }\n    private void openReaderAndWriter() {\n        readerChkptDK = new CheckpointDataKey(jobExecutionImpl.getJobInstance().getInstanceId(), step.getId(), CheckpointType.READER);\n        CheckpointData readerChkptData = persistenceManagerService.getCheckpointData(readerChkptDK);\n        try {\n            // check for data in backing store\n            if (readerChkptData != null) {\n                final byte[] readertoken = readerChkptData.getRestartToken();\n                try {\n                    readerProxy.open((Serializable) dataRepresentationService.toJavaRepresentation(readertoken));\n                } catch (final Exception ex) {\n                    // is this what I should be throwing here?\n                    throw new BatchContainerServiceException(\"Cannot read the checkpoint data for [\" + step.getId() + \"]\", ex);\n                }\n            } else {\n                // no chkpt data exists in the backing store\n                readerChkptData = null;\n                try {\n                    readerProxy.open(null);\n                } catch (final Exception ex) {\n                    // is this what I should be throwing here?\n                    throw new BatchContainerServiceException(\"Exception while opening step [\" + step.getId() + \"]\", ex);\n                }\n            }\n        } catch (final ClassCastException e) {\n            throw new IllegalStateException(\"Expected CheckpointData but found\" + readerChkptData);\n        }\n        writerChkptDK = new CheckpointDataKey(jobExecutionImpl.getJobInstance().getInstanceId(), step.getId(), CheckpointType.WRITER);\n        CheckpointData writerChkptData = persistenceManagerService.getCheckpointData(writerChkptDK);\n        try {\n            // check for data in backing store\n            if (writerChkptData != null) {\n                final byte[] writertoken = writerChkptData.getRestartToken();\n                try {\n                    writerProxy.open((Serializable) dataRepresentationService.toJavaRepresentation(writertoken));\n                } catch (final Exception ex) {\n                    throw new BatchContainerServiceException(\"Cannot persist the checkpoint data for [\" + step.getId() + \"]\", ex);\n                }\n            } else {\n                // no chkpt data exists in the backing store\n                writerChkptData = null;\n                try {\n                    writerProxy.open(null);\n                } catch (Exception e) {\n                    ExceptionConfig.wrapBatchException(e);\n                }\n            }\n        } catch (final ClassCastException e) {\n            throw new IllegalStateException(\"Expected Checkpoint but found\" + writerChkptData);\n        }\n    }\n    @Override\n    public void stop() {\n        stepContext.setBatchStatus(BatchStatus.STOPPING);\n        // we don't need to call stop on the chunk implementation here since a\n        // chunk always returns control to\n        // the batch container after every item.\n    }\n    private boolean skipReadException(final Exception e) {\n        try {\n            skipHandler.handleExceptionRead(e);\n        } catch (final BatchContainerRuntimeException bcre) {\n            return false;\n        }\n        return true;\n    }\n    private boolean retryReadException(final Exception e) {\n        try {\n            retryHandler.handleExceptionRead(e);\n        } catch (final BatchContainerRuntimeException bcre) {\n            return false;\n        }\n        return true;\n    }\n    private boolean skipProcessException(final Exception e, final Object record) {\n        try {\n            skipHandler.handleExceptionWithRecordProcess(e, record);\n        } catch (BatchContainerRuntimeException bcre) {\n            return false;\n        }\n        return true;\n    }\n    private boolean retryProcessException(final Exception e, final Object record) {\n        try {\n            retryHandler.handleExceptionProcess(e, record);\n        } catch (BatchContainerRuntimeException bcre) {\n            return false;\n        }\n        return true;\n    }\n    private boolean skipWriteException(final Exception e, final List<Object> chunkToWrite) {\n        try {\n            skipHandler.handleExceptionWithRecordListWrite(e, chunkToWrite);\n        } catch (BatchContainerRuntimeException bcre) {\n            return false;\n        }\n        return true;\n    }\n    private boolean retryWriteException(final Exception e, final List<Object> chunkToWrite) {\n        try {\n            retryHandler.handleExceptionWrite(e, chunkToWrite);\n        } catch (BatchContainerRuntimeException bcre) {\n            return false;\n        }\n        return true;\n    }\n    private void positionReaderAtCheckpoint() {\n        readerChkptDK = new CheckpointDataKey(jobExecutionImpl.getJobInstance().getInstanceId(), step.getId(), CheckpointType.READER);\n        CheckpointData readerData = persistenceManagerService.getCheckpointData(readerChkptDK);\n        try {\n            // check for data in backing store\n            if (readerData != null) {\n                byte[] readertoken = readerData.getRestartToken();\n                try {\n                    readerProxy.open((Serializable) dataRepresentationService.toJavaRepresentation(readertoken));\n                } catch (Exception ex) {\n                    // is this what I should be throwing here?\n                    throw new BatchContainerServiceException(\"Cannot persist the checkpoint data for [\" + step.getId() + \"]\", ex);\n                }\n            } else {\n                // no chkpt data exists in the backing store\n                readerData = null;\n                try {\n                    readerProxy.open(null);\n                } catch (final Exception ex) {\n                    // is this what I should be throwing here?\n                    throw new BatchContainerServiceException(\"Cannot persist the checkpoint data for [\" + step.getId() + \"]\", ex);\n                }\n            }\n        } catch (final ClassCastException e) {\n            throw new IllegalStateException(\"Expected CheckpointData but found\" + readerData);\n        }\n    }\n<fim_suffix>    private void positionWriterAtCheckpoint() {\n        writerChkptDK = new CheckpointDataKey(jobExecutionImpl.getJobInstance().getInstanceId(), step.getId(), CheckpointType.WRITER);\n        CheckpointData writerData = persistenceManagerService.getCheckpointData(writerChkptDK);\n        try {\n            // check for data in backing store\n            if (writerData != null) {\n                byte[] writertoken = writerData.getRestartToken();\n                TCCLObjectInputStream writerOIS;\n                try {\n                    writerProxy.open((Serializable) dataRepresentationService.toJavaRepresentation(writertoken));\n                } catch (Exception ex) {\n                    // is this what I should be throwing here?\n                    throw new BatchContainerServiceException(\"Cannot read the checkpoint data for [\" + step.getId() + \"]\", ex);\n                }\n            } else {\n                // no chkpt data exists in the backing store\n                writerData = null;\n                try {\n                    writerProxy.open(null);\n                } catch (Exception ex) {\n                    throw new BatchContainerServiceException(\"Cannot open the step [\" + step.getId() + \"]\", ex);\n                }\n            }\n        } catch (ClassCastException e) {\n            throw new IllegalStateException(\"Expected CheckpointData but found\" + writerData);\n        }\n    }<fim_middle>// function below is long method\n"}