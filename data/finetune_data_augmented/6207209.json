{"text": "<fim_prefix>/*\n * Copyright (c) 2012-2018 Red Hat, Inc.\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *   Red Hat, Inc. - initial API and implementation\n */\npackage org.eclipse.che.ide.command.editor;\nimport static org.eclipse.che.ide.api.notification.StatusNotification.DisplayMode.EMERGE_MODE;\nimport static org.eclipse.che.ide.api.notification.StatusNotification.Status.WARNING;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.gwt.user.client.rpc.AsyncCallback;\nimport com.google.gwt.user.client.ui.AcceptsOneWidget;\nimport com.google.gwt.user.client.ui.IsWidget;\nimport com.google.inject.Inject;\nimport com.google.web.bindery.event.shared.EventBus;\nimport com.google.web.bindery.event.shared.HandlerRegistration;\nimport java.util.LinkedList;\nimport java.util.List;\nimport org.eclipse.che.api.promises.client.Operation;\nimport org.eclipse.che.api.promises.client.OperationException;\nimport org.eclipse.che.api.promises.client.PromiseError;\nimport org.eclipse.che.commons.annotation.Nullable;\nimport org.eclipse.che.ide.CoreLocalizationConstant;\nimport org.eclipse.che.ide.api.command.CommandImpl;\nimport org.eclipse.che.ide.api.command.CommandManager;\nimport org.eclipse.che.ide.api.command.CommandRemovedEvent;\nimport org.eclipse.che.ide.api.command.CommandRemovedEvent.CommandRemovedHandler;\nimport org.eclipse.che.ide.api.editor.AbstractEditorPresenter;\nimport org.eclipse.che.ide.api.editor.EditorAgent;\nimport org.eclipse.che.ide.api.editor.EditorInput;\nimport org.eclipse.che.ide.api.icon.Icon;\nimport org.eclipse.che.ide.api.icon.IconRegistry;\nimport org.eclipse.che.ide.api.notification.NotificationManager;\nimport org.eclipse.che.ide.api.parts.WorkspaceAgent;\nimport org.eclipse.che.ide.api.resources.VirtualFile;\nimport org.eclipse.che.ide.command.editor.page.CommandEditorPage;\nimport org.eclipse.che.ide.command.editor.page.commandline.CommandLinePage;\nimport org.eclipse.che.ide.command.editor.page.goal.GoalPage;\nimport org.eclipse.che.ide.command.editor.page.name.NamePage;\nimport org.eclipse.che.ide.command.editor.page.previewurl.PreviewUrlPage;\nimport org.eclipse.che.ide.command.editor.page.project.ProjectsPage;\nimport org.eclipse.che.ide.command.node.CommandFileNode;\nimport org.eclipse.che.ide.command.node.NodeFactory;\nimport org.eclipse.che.ide.ui.dialogs.DialogFactory;\nimport org.vectomatic.dom.svg.ui.SVGImage;\nimport org.vectomatic.dom.svg.ui.SVGResource;\n/** Presenter for command editor. */\npublic class CommandEditor extends AbstractEditorPresenter\n    implements CommandEditorView.ActionDelegate, CommandRemovedHandler {\n  private final CommandEditorView view;\n  private final WorkspaceAgent workspaceAgent;\n  private final IconRegistry iconRegistry;\n  private final CommandManager commandManager;\n  private final NotificationManager notificationManager;\n  private final DialogFactory dialogFactory;\n  private final EditorAgent editorAgent;\n  private final CoreLocalizationConstant coreMessages;\n  private final EditorMessages messages;\n  private final NodeFactory nodeFactory;\n  private final EventBus eventBus;\n  private final List<CommandEditorPage> pages;\n  /** Edited command. */\n  @VisibleForTesting protected CommandImpl editedCommand;\n  private HandlerRegistration commandRemovedHandlerRegistration;\n  /** Initial (before any modification) name of the edited command. */\n  private String initialCommandName;\n  @Inject\n  public CommandEditor(\n      CommandEditorView view,\n      WorkspaceAgent workspaceAgent,\n      IconRegistry iconRegistry,\n      CommandManager commandManager,\n      NamePage namePage,\n      ProjectsPage projectsPage,\n      CommandLinePage commandLinePage,\n      GoalPage goalPage,\n      PreviewUrlPage previewUrlPage,\n      NotificationManager notificationManager,\n      DialogFactory dialogFactory,\n      EditorAgent editorAgent,\n      CoreLocalizationConstant coreMessages,\n      EditorMessages messages,\n      NodeFactory nodeFactory,\n      EventBus eventBus) {\n    this.view = view;\n    this.workspaceAgent = workspaceAgent;\n    this.iconRegistry = iconRegistry;\n    this.commandManager = commandManager;\n    this.notificationManager = notificationManager;\n    this.dialogFactory = dialogFactory;\n    this.editorAgent = editorAgent;\n    this.coreMessages = coreMessages;\n    this.messages = messages;\n    this.nodeFactory = nodeFactory;\n    this.eventBus = eventBus;\n    view.setDelegate(this);\n    pages = new LinkedList<>();\n    pages.add(previewUrlPage);\n    pages.add(projectsPage);\n    pages.add(goalPage);\n    pages.add(commandLinePage);\n    pages.add(namePage);\n  }\n  @Override\n  public void go(AcceptsOneWidget container) {\n    container.setWidget(getView());\n  }\n  @Override\n  protected void initializeEditor(EditorAgent.OpenEditorCallback callback) {\n    commandRemovedHandlerRegistration = eventBus.addHandler(CommandRemovedEvent.getType(), this);\n    final VirtualFile file = getEditorInput().getFile();\n    if (file instanceof CommandFileNode) {\n      // make a copy of the given command to avoid modifying of the provided command\n      editedCommand = new CommandImpl(((CommandFileNode) file).getData());\n      initializePages();\n      pages.forEach(page -> view.addPage(page.getView(), page.getTitle()));\n      callback.onEditorOpened(this);\n    } else {\n      callback.onInitializationFailed();\n    }\n  }\n  /** Initialize editor's pages with the edited command. */\n<fim_suffix>  private void initializePages() {\n    initialCommandName = editedCommand.getName();\n    pages.forEach(\n        page -> {\n          page.edit(editedCommand);\n          page.setDirtyStateListener(\n              () -> {\n                updateDirtyState(isDirtyPage());\n                view.setSaveEnabled(isDirtyPage());\n              });\n        });\n  }\n  /** Checks whether any page is dirty. */\n  private boolean isDirtyPage() {\n    for (CommandEditorPage page : pages) {\n      if (page.isDirty()) {\n        return true;\n      }\n    }\n    return false;\n  }\n  private boolean isInvalidData() {\n    for (CommandEditorPage page : pages) {\n      if (page.hasInvalidData()) {\n        return true;\n      }\n    }\n    return false;\n  }\n  public List<CommandEditorPage> getPages() {\n    return pages;\n  }\n  @Nullable\n  @Override\n  public SVGResource getTitleImage() {\n    final VirtualFile file = getEditorInput().getFile();\n    if (file instanceof CommandFileNode) {\n      final CommandImpl command = ((CommandFileNode) file).getData();\n      final Icon icon = iconRegistry.getIconIfExist(\"command.type.\" + command.getType());\n      if (icon != null) {\n        final SVGImage svgImage = icon.getSVGImage();\n        if (svgImage != null) {\n          return icon.getSVGResource();\n        }\n      }\n    }\n    return input.getSVGResource();\n  }\n  @Override\n  public String getTitle() {\n    return (isDirty() ? \"* \" : \"\") + input.getName();\n  }\n  @Override\n  public IsWidget getView() {\n    return view;\n  }\n  @Nullable\n  @Override\n  public String getTitleToolTip() {\n    return input.getName();\n  }\n  @Override\n  public void doSave() {\n    doSave(\n        new AsyncCallback<EditorInput>() {\n          @Override\n          public void onFailure(Throwable caught) {}\n          @Override\n          public void onSuccess(EditorInput result) {}\n        });\n  }\n  @Override\n  public void doSave(AsyncCallback<EditorInput> callback) {\n    if (isInvalidData()) {\n      dialogFactory\n          .createMessageDialog(\n              coreMessages.save(),\n              coreMessages.messagesInvalidCommand(),\n              () -> callback.onFailure(null))\n          .show();\n      return;\n    }\n    commandManager\n        .updateCommand(initialCommandName, editedCommand)\n        .then(\n            arg -> {\n              // according to the CommandManager#updateCommand contract\n              // command's name after updating may differ from the proposed name\n              // in order to prevent name duplication\n              editedCommand.setName(arg.getName());\n              if (!initialCommandName.equals(editedCommand.getName())) {\n                input.setFile(nodeFactory.newCommandFileNode(editedCommand));\n                initialCommandName = editedCommand.getName();\n                firePropertyChange(PROP_INPUT);\n              }<fim_middle>// function below has no smell\n"}