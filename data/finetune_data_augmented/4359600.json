{"text": "<fim_prefix>\n<fim_suffix>public class CopyRowsOperation extends PhysicalPageOperation {\n\tprotected int\tnum_rows;\n\tprotected int\tdestSlot;\t\t// copy into this page starting from destSlot\n\tprotected int[] recordIds;  // num_rows of recordIds (use these for undo)\n\tprotected int[] reservedSpace;\t// number of bytes to reserve for each row.\n\ttransient protected ByteArray preparedLog; \n    CopyRowsOperation(RawTransaction t, BasePage destPage, BasePage srcPage,\n\t\t\t\t\t\t\t int destSlot, int num_rows,\n\t\t\t\t\t\t\t int srcSlot, int[] recordIds)\n\t\tthrows StandardException\n\t{\n\t\tsuper(destPage);\n\t\tthis.num_rows = num_rows;\n\t\tthis.destSlot = destSlot;\n\t\tthis.recordIds = recordIds;\n\t\ttry {\n\t\t\treservedSpace = new int[num_rows];\n\t\t\tfor (int i = 0; i < num_rows; i++) {\n\t\t\t\treservedSpace[i] = srcPage.getReservedCount(i + srcSlot);\n\t\t\t}\n\t\t\twriteOptionalDataToBuffer(t, srcPage, srcSlot);\n\t\t} catch (IOException ioe) {\n\t\t\tthrow StandardException.newException(\n                    SQLState.DATA_UNEXPECTED_EXCEPTION, ioe);\n\t\t}\n\t}\n\t/*\n\t * Formatable methods\n\t */\n\t// no-arg constructor, required by Formatable \n\tpublic CopyRowsOperation() { super(); }\n/*\n\tpublic CopyRowsOperation(BasePage destPage) { super(destPage); }\n*/\n\tpublic void writeExternal(ObjectOutput out) throws IOException \n\t{\n\t\tsuper.writeExternal(out);\n\t\tCompressedNumber.writeInt(out, num_rows);\n\t\tCompressedNumber.writeInt(out, destSlot);\n\t\tfor (int i = 0; i < num_rows; i++) {\n\t\t\tCompressedNumber.writeInt(out, recordIds[i]);\n\t\t\tCompressedNumber.writeInt(out, reservedSpace[i]);\n\t\t}\n\t}\n\t/**\n\t\tRead this in\n\t\t@exception IOException error reading from log stream\n\t\t@exception ClassNotFoundException log stream corrupted\n\t*/\n\tpublic void readExternal(ObjectInput in) \n\t\t throws IOException, ClassNotFoundException\n\t{\n\t\tsuper.readExternal(in);\n\t\tnum_rows = CompressedNumber.readInt(in);\n\t\tdestSlot = CompressedNumber.readInt(in);\n\t\trecordIds = new int[num_rows];\n\t\treservedSpace = new int[num_rows];\n\t\tfor (int i = 0; i < num_rows; i++) {\n\t\t\trecordIds[i] = CompressedNumber.readInt(in);\n\t\t\treservedSpace[i] = CompressedNumber.readInt(in);\n\t\t}\n\t}\n\t/**\n\t\tReturn my format identifier.\n\t*/\n\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.LOGOP_COPY_ROWS;\n\t}\n\t/*\n\t * Loggable methods\n\t */\n\t/**\n\t\t@exception IOException Can be thrown by any of the methods of ObjectInput.\n\t\t@exception StandardException Standard Derby error policy.\t\t\n\t\t@see org.apache.derby.iapi.store.raw.Loggable#doMe\n\t*/\n\tpublic void doMe(Transaction xact, LogInstant instant, LimitObjectInput in)\n\t\t throws StandardException, IOException\n\t{\n\t\t/*\n\t\t * this operation's do me will bump the page version by more than 1\n\t\t */\n\t\tfor (int i = 0; i < num_rows; i++)\n\t\t{\n\t\t\tpage.storeRecord(instant, destSlot+i, true, in);\n\t\t\tif (reservedSpace[i] > 0)\n\t\t\t\tpage.reserveSpaceForSlot(instant, destSlot + i, reservedSpace[i]);\n\t\t}\n\t}\n\t/*\n\t * PhysicalPageOperation method\n\t */\n\t/**\n\t    to undo this operation, purge all records that were copied over.\n\t\t@exception IOException Can be thrown by any of the methods of ObjectInput.\n\t\t@exception StandardException\tStandard Derby error policy\n\t\t@see PhysicalPageOperation#undoMe\n\t */\n\tpublic void undoMe(Transaction xact, BasePage undoPage,\n\t\t\t\t\t   LogInstant CLRInstant, LimitObjectInput in)\n\t\t throws StandardException, IOException \n\t{\n\t\t// purge the records in the stored version\n\t\t// since we search for each recordId, it doesn't matter whether we\n\t\t// purge from high to low.  In most cases, it will be in order so do it\n\t\t// from high to low to save some work.\n\t\tint slot;\n\t\tfor (int i = num_rows-1; i >= 0; i--)\n\t\t{\n\t\t\tslot = undoPage.findRecordById(recordIds[i], i);\n\t\t\tundoPage.purgeRecord(CLRInstant, slot, recordIds[i]);\n\t\t}\n\t\tundoPage.setAuxObject(null);\n\t}\n\t/*\n\t * PageBasicOperation method to support BeforeImageLogging\n\t */\n\t/**\n\t * restore the before image of the page\n\t *\n\t * @exception IOException problem reading the complete log record from the input stream\n\t * @exception StandardException Standard Derby Error Policy\n\t */\n\tpublic void restoreMe(Transaction xact, BasePage undoPage,\n\t\t\t\t\t   LogInstant CLRInstant, LimitObjectInput in)\n\t\t throws StandardException, IOException \n\t{\n\t\tundoMe(xact, undoPage, CLRInstant, in);\n\t}\n\t/*\n\t\tmethods to support prepared log\n\t\tthe following two methods should not be called during recover\n\t*/\n\tpublic ByteArray getPreparedLog()\n\t{\n\t\treturn (this.preparedLog);\n\t}\n\t/**\n\t\tWrite the rows that are to be copied into this page\n\t\t@exception IOException Can be thrown by any of the methods of ObjectOutput.\n\t\t@exception StandardException Standard Derby policy.\t\t\n\t*/\n\tprivate void writeOptionalDataToBuffer(RawTransaction t, BasePage srcPage, int srcSlot)\n\t\tthrows StandardException, IOException\n\t{\n\t\tif (SanityManager.DEBUG) {\n\t\t\tSanityManager.ASSERT(this.page != null);\n\t\t\tSanityManager.ASSERT(srcPage != null);\n\t\t}\n\t\tDynamicByteArrayOutputStream logBuffer = t.getLogBuffer();\n\t\tint optionalDataStart = logBuffer.getPosition();\n\t\tif (SanityManager.DEBUG) {\n\t\t\tSanityManager.ASSERT(optionalDataStart == 0,\n\t\t\t\t\"Buffer for writing the optional data should start at position 0\");\n\t\t}\n\t\t// check to make sure the destination page have the necessary space to\n\t\t// take the rows\n\t\tint[] spaceNeeded = new int[num_rows];\n\t\tint startPosition = logBuffer.getPosition();\n\t\tfor (int i = 0; i < num_rows; i++)\n\t\t{\n\t\t\t// the recordId passed in is the record Id this row will have at\n\t\t\t// the destination page, not the record Id this row has on the\n\t\t\t// srcPage.\n\t\t\tsrcPage.logRecord(i + srcSlot, BasePage.LOG_RECORD_DEFAULT,\n\t\t\t\t\t\t\t  recordIds[i],  (FormatableBitSet) null, logBuffer,\n\t\t\t\t\t\t\t  (RecordHandle)null);\n\t\t\tspaceNeeded[i] = logBuffer.getPosition() - startPosition;\n\t\t\tstartPosition = logBuffer.getPosition();\n\t\t\t// now spaceNeeded[i] has the actual record size.  However, the src\n\t\t\t// page may actually leave more space for the record due to\n\t\t\t// reserved space.  Because we want to copy the reserve space as well,\n\t\t\t// we need to take into account that amount.\n\t\t\tspaceNeeded[i] += reservedSpace[i];\n \t\t}\n\t\t// page is the destination page.\n\t\tif (!page.spaceForCopy(num_rows, spaceNeeded))\n        {\n\t\t\tthrow StandardException.newException(\n                    SQLState.DATA_NO_SPACE_FOR_RECORD);\n        }\n\t\tint optionalDataLength = logBuffer.getPosition() - optionalDataStart;\n\t\tif (SanityManager.DEBUG) {\n\t\t\tif (optionalDataLength != logBuffer.getUsed())\n\t\t\t\tSanityManager.THROWASSERT(\"wrong optional data length, optionalDataLength = \"\n\t\t\t\t\t+ optionalDataLength + \", logBuffer.getUsed() = \" + logBuffer.getUsed());\n\t\t}\n\t\t// set the position to the beginning of the buffer\n\t\tlogBuffer.setPosition(optionalDataStart);\n\t\tthis.preparedLog = new ByteArray(logBuffer.getByteArray(), optionalDataStart,\n\t\t\toptionalDataLength);\n\t}\n\t/**\n\t  DEBUG: Print self.\n\t */\n\tpublic String toString()\n\t{\n\t\tif (SanityManager.DEBUG)\n\t\t{\n\t\t\tString str = super.toString() +\n\t\t\t\t\"CopyRows : \" + num_rows + \" to slots starting at \" + destSlot;\n\t\t\tfor (int i = 0; i < num_rows; i++)\n\t\t\t{\n\t\t\t\tstr += \" (recordId=\" + recordIds[i] + \")\";<fim_middle>// class below has no smell\n"}