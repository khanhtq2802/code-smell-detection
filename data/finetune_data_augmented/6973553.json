{"text": "<fim_prefix>      put(entry.getKey(), entry.getValue());\n    }\n  }\n  @Override\n  public void clear() {\n    entriesByLowerBound.clear();\n  }\n  @Override\n  public Range<K> span() {\n    Entry<Cut<K>, RangeMapEntry<K, V>> firstEntry = entriesByLowerBound.firstEntry();\n    Entry<Cut<K>, RangeMapEntry<K, V>> lastEntry = entriesByLowerBound.lastEntry();\n    if (firstEntry == null) {\n      throw new NoSuchElementException();\n    }\n    return Range.create(\n        firstEntry.getValue().getKey().lowerBound, lastEntry.getValue().getKey().upperBound);\n  }\n  private void putRangeMapEntry(Cut<K> lowerBound, Cut<K> upperBound, V value) {\n    entriesByLowerBound.put(lowerBound, new RangeMapEntry<K, V>(lowerBound, upperBound, value));\n  }\n  @Override\n  public void remove(Range<K> rangeToRemove) {\n    if (rangeToRemove.isEmpty()) {\n      return;\n    }\n    /*\n     * The comments for this method will use [ ] to indicate the bounds of rangeToRemove and ( ) to\n     * indicate the bounds of ranges in the range map.\n     */\n    Entry<Cut<K>, RangeMapEntry<K, V>> mapEntryBelowToTruncate =\n        entriesByLowerBound.lowerEntry(rangeToRemove.lowerBound);\n    if (mapEntryBelowToTruncate != null) {\n      // we know ( [\n      RangeMapEntry<K, V> rangeMapEntry = mapEntryBelowToTruncate.getValue();\n      if (rangeMapEntry.getUpperBound().compareTo(rangeToRemove.lowerBound) > 0) {\n        // we know ( [ )\n        if (rangeMapEntry.getUpperBound().compareTo(rangeToRemove.upperBound) > 0) {\n          // we know ( [ ] ), so insert the range ] ) back into the map --\n          // it's being split apart\n          putRangeMapEntry(\n              rangeToRemove.upperBound,\n              rangeMapEntry.getUpperBound(),\n              mapEntryBelowToTruncate.getValue().getValue());\n        }\n        // overwrite mapEntryToTruncateBelow with a truncated range\n        putRangeMapEntry(\n            rangeMapEntry.getLowerBound(),\n            rangeToRemove.lowerBound,\n            mapEntryBelowToTruncate.getValue().getValue());\n      }\n    }\n    Entry<Cut<K>, RangeMapEntry<K, V>> mapEntryAboveToTruncate =\n        entriesByLowerBound.lowerEntry(rangeToRemove.upperBound);\n    if (mapEntryAboveToTruncate != null) {\n      // we know ( ]\n      RangeMapEntry<K, V> rangeMapEntry = mapEntryAboveToTruncate.getValue();\n      if (rangeMapEntry.getUpperBound().compareTo(rangeToRemove.upperBound) > 0) {\n        // we know ( ] ), and since we dealt with truncating below already,\n        // we know [ ( ] )\n        putRangeMapEntry(\n            rangeToRemove.upperBound,\n            rangeMapEntry.getUpperBound(),\n            mapEntryAboveToTruncate.getValue().getValue());\n      }\n    }\n    entriesByLowerBound.subMap(rangeToRemove.lowerBound, rangeToRemove.upperBound).clear();\n  }\n  @Override\n  public Map<Range<K>, V> asMapOfRanges() {\n    return new AsMapOfRanges(entriesByLowerBound.values());\n  }\n  @Override\n  public Map<Range<K>, V> asDescendingMapOfRanges() {\n    return new AsMapOfRanges(entriesByLowerBound.descendingMap().values());\n  }\n  private final class AsMapOfRanges extends IteratorBasedAbstractMap<Range<K>, V> {\n    final Iterable<Entry<Range<K>, V>> entryIterable;\n    @SuppressWarnings(\"unchecked\") // it's safe to upcast iterables\n    AsMapOfRanges(Iterable<RangeMapEntry<K, V>> entryIterable) {\n      this.entryIterable = (Iterable) entryIterable;\n    }\n    @Override\n    public boolean containsKey(@Nullable Object key) {\n      return get(key) != null;\n    }\n    @Override\n    public V get(@Nullable Object key) {\n      if (key instanceof Range) {\n        Range<?> range = (Range<?>) key;\n        RangeMapEntry<K, V> rangeMapEntry = entriesByLowerBound.get(range.lowerBound);\n        if (rangeMapEntry != null && rangeMapEntry.getKey().equals(range)) {\n          return rangeMapEntry.getValue();\n        }\n      }\n      return null;\n    }\n    @Override\n    public int size() {\n      return entriesByLowerBound.size();\n    }\n    @Override\n    Iterator<Entry<Range<K>, V>> entryIterator() {\n      return entryIterable.iterator();\n    }\n  }\n  @Override\n  public RangeMap<K, V> subRangeMap(Range<K> subRange) {\n    if (subRange.equals(Range.all())) {\n      return this;\n    } else {\n      return new SubRangeMap(subRange);\n    }\n  }\n  @SuppressWarnings(\"unchecked\")\n  private RangeMap<K, V> emptySubRangeMap() {\n    return EMPTY_SUB_RANGE_MAP;\n  }\n  private static final RangeMap EMPTY_SUB_RANGE_MAP =\n      new RangeMap() {\n        @Override\n        public @Nullable Object get(Comparable key) {\n          return null;\n        }\n        @Override\n        public @Nullable Entry<Range, Object> getEntry(Comparable key) {\n          return null;\n        }\n        @Override\n        public Range span() {\n          throw new NoSuchElementException();\n        }\n        @Override\n        public void put(Range range, Object value) {\n          checkNotNull(range);\n          throw new IllegalArgumentException(\n              \"Cannot insert range \" + range + \" into an empty subRangeMap\");\n        }\n        @Override\n        public void putCoalescing(Range range, Object value) {\n          checkNotNull(range);\n          throw new IllegalArgumentException(\n              \"Cannot insert range \" + range + \" into an empty subRangeMap\");\n        }\n        @Override\n        public void putAll(RangeMap rangeMap) {\n          if (!rangeMap.asMapOfRanges().isEmpty()) {\n            throw new IllegalArgumentException(\n                \"Cannot putAll(nonEmptyRangeMap) into an empty subRangeMap\");\n          }\n        }\n        @Override\n        public void clear() {}\n        @Override\n        public void remove(Range range) {\n          checkNotNull(range);\n        }\n        @Override\n        public Map<Range, Object> asMapOfRanges() {\n          return Collections.emptyMap();\n        }\n        @Override\n        public Map<Range, Object> asDescendingMapOfRanges() {\n          return Collections.emptyMap();\n        }\n        @Override\n        public RangeMap subRangeMap(Range range) {\n          checkNotNull(range);\n          return this;\n        }\n      };\n  private class SubRangeMap implements RangeMap<K, V> {\n    private final Range<K> subRange;\n    SubRangeMap(Range<K> subRange) {\n      this.subRange = subRange;\n    }\n    @Override\n    public @Nullable V get(K key) {\n      return subRange.contains(key) ? TreeRangeMap.this.get(key) : null;\n    }\n    @Override\n    public @Nullable Entry<Range<K>, V> getEntry(K key) {\n      if (subRange.contains(key)) {\n        Entry<Range<K>, V> entry = TreeRangeMap.this.getEntry(key);\n        if (entry != null) {\n          return Maps.immutableEntry(entry.getKey().intersection(subRange), entry.getValue());\n        }\n      }\n      return null;\n    }\n    @Override\n    public Range<K> span() {\n      Cut<K> lowerBound;\n      Entry<Cut<K>, RangeMapEntry<K, V>> lowerEntry =\n          entriesByLowerBound.floorEntry(subRange.lowerBound);\n      if (lowerEntry != null\n          && lowerEntry.getValue().getUpperBound().compareTo(subRange.lowerBound) > 0) {\n        lowerBound = subRange.lowerBound;\n      } else {\n        lowerBound = entriesByLowerBound.ceilingKey(subRange.lowerBound);\n        if (lowerBound == null || lowerBound.compareTo(subRange.upperBound) >= 0) {\n          throw new NoSuchElementException();\n        }\n      }\n      Cut<K> upperBound;\n      Entry<Cut<K>, RangeMapEntry<K, V>> upperEntry =\n          entriesByLowerBound.lowerEntry(subRange.upperBound);\n      if (upperEntry == null) {\n        throw new NoSuchElementException();\n      } else if (upperEntry.getValue().getUpperBound().compareTo(subRange.upperBound) >= 0) {\n        upperBound = subRange.upperBound;\n      } else {\n        upperBound = upperEntry.getValue().getUpperBound();\n      }\n      return Range.create(lowerBound, upperBound);\n    }\n<fim_suffix>    @Override\n    public void put(Range<K> range, V value) {\n      checkArgument(\n          subRange.encloses(range), \"Cannot put range %s into a subRangeMap(%s)\", range, subRange);\n      TreeRangeMap.this.put(range, value);\n    }<fim_middle>// function below has no smell\n"}