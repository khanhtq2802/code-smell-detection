{"text": "<fim_prefix>/*\n * Copyright (c) 1995-2015, The R Core Team\n * Copyright (c) 2003, The R Foundation\n * Copyright (c) 2015, 2019, Oracle and/or its affiliates\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, a copy is available at\n * https://www.R-project.org/Licenses/\n */\npackage com.oracle.truffle.r.runtime;\nimport java.util.ArrayList;\nimport com.oracle.truffle.api.CompilerAsserts;\nimport com.oracle.truffle.api.CompilerDirectives;\nimport com.oracle.truffle.api.CompilerDirectives.TruffleBoundary;\nimport com.oracle.truffle.api.TruffleException;\nimport com.oracle.truffle.api.frame.Frame;\nimport com.oracle.truffle.api.frame.MaterializedFrame;\nimport com.oracle.truffle.api.nodes.Node;\nimport com.oracle.truffle.api.source.SourceSection;\nimport com.oracle.truffle.r.runtime.RError.Message;\nimport com.oracle.truffle.r.runtime.context.RContext;\nimport com.oracle.truffle.r.runtime.data.RDataFactory;\nimport com.oracle.truffle.r.runtime.data.RExpression;\nimport com.oracle.truffle.r.runtime.data.RFunction;\nimport com.oracle.truffle.r.runtime.data.RList;\nimport com.oracle.truffle.r.runtime.data.RMissing;\nimport com.oracle.truffle.r.runtime.data.RNull;\nimport com.oracle.truffle.r.runtime.data.RPairList;\nimport com.oracle.truffle.r.runtime.data.RString;\nimport com.oracle.truffle.r.runtime.data.RStringVector;\nimport com.oracle.truffle.r.runtime.data.model.RAbstractIntVector;\nimport com.oracle.truffle.r.runtime.data.model.RAbstractStringVector;\nimport com.oracle.truffle.r.runtime.env.REnvironment;\nimport com.oracle.truffle.r.runtime.env.REnvironment.PutException;\nimport com.oracle.truffle.r.runtime.interop.FastRInteropTryException;\nimport com.oracle.truffle.r.runtime.nodes.RBaseNode;\n/**\n * The details of error handling, including condition handling. Derived from GnUR src/main/errors.c.\n * The public methods in this class are primarily intended for use by the {@code .Internal}\n * functions in {@code ConditionFunctions}. Generally the {@link RError} class should be used for\n * error and warning reporting.\n *\n * FastR does not have access to the call that generated the error or warning as an AST (cf GnuR's\n * CLOSXP pairlist), only the {@link SourceSection} associated with the call. There is a need to\n * pass a value that denotes the call back out to R, e.g. as an argument to\n * {@code .handleSimpleError}. The R code mostly treats this as an opaque object, typically passing\n * it back into a {@code .Internal} that calls this class, but it sometimes calls {@code deparse} on\n * the value if it is not {@link RNull#instance}. Either way it must be a valid {@link RType} to be\n * passed as an argument. For better or worse, we use an {@link RPairList}. We handle the\n * {@code deparse} special case explicitly in our implementation of {@code deparse}.\n * <p>\n * TODO Consider using an {@link RPairList} object to denote the call (somehow).\n */\npublic class RErrorHandling {\n    private static final int IN_HANDLER = 3;\n    private static final RStringVector RESTART_CLASS = RDataFactory.createStringVectorFromScalar(\"restart\");\n    private static class Warnings {\n        private final ArrayList<Warning> list = new ArrayList<>();\n        int size() {\n            return list.size();\n        }\n        Warning get(int index) {\n            return list.get(index);\n        }\n        void add(Warning warning) {\n            list.add(warning);\n        }\n        void clear() {\n            list.clear();\n        }\n    }\n    /**\n     * Holds all the context-specific state that is relevant for error/warnings. Simple value class\n     * for which geterrs/setters are unnecessary.\n     */\n    public static class ContextStateImpl implements RContext.ContextState {\n        /**\n         * Values is either NULL or an RPairList, for {@code restarts}.\n         */\n        private Object restartStack = RNull.instance;\n        /**\n         * Values is either NULL or an RPairList, for {@code conditions}.\n         */\n        private Object handlerStack = RNull.instance;\n        /**\n         * Current list of (deferred) warnings.\n         */\n        private final Warnings warnings = new Warnings();\n        /**\n         * Max warnings accumulated.\n         */\n        private final int maxWarnings = 50;\n        /**\n         * Set/get by seterrmessage/geterrmessage builtins.\n         */\n        private String errMsg;\n        /**\n         * {@code true} if we are already processing an error.\n         */\n        private int inError;\n        /**\n         * {@code true} if we are already processing a warning.\n         */\n        private boolean inWarning;\n        /**\n         * {@code true} if the warning should be output immediately.\n         */\n        private boolean immediateWarning;\n        /**\n         * {@code true} if the warning should be output on one line.\n         */\n        @SuppressWarnings(\"unused\") private boolean noBreakWarning;\n        /**\n         * {@code true} if in {@link #printWarnings}.\n         */\n        private boolean inPrintWarning;\n        /**\n         * {@code .signalSimpleWarning} in \"conditions.R\".\n         */\n        private RFunction dotSignalSimpleWarning;\n        private RFunction dotHandleSimpleError;\n        /**\n         * Initialize and return the value of {@link #dotSignalSimpleWarning}. This is lazy because\n         * when this instance is created, the {@link REnvironment} context state has not been set\n         * up, so we can't look up anything in the base env.\n         */\n        private RFunction getDotSignalSimpleWarning() {\n            if (dotSignalSimpleWarning == null) {\n                CompilerDirectives.transferToInterpreter();\n                String name = \".signalSimpleWarning\";\n                Object f = REnvironment.baseEnv().findFunction(name);\n                dotSignalSimpleWarning = (RFunction) RContext.getRRuntimeASTAccess().forcePromise(name, f);\n            }\n            return dotSignalSimpleWarning;\n        }\n        private RFunction getDotHandleSimpleError() {\n            if (dotHandleSimpleError == null) {\n                CompilerDirectives.transferToInterpreter();\n                String name = \".handleSimpleError\";\n                Object f = REnvironment.baseEnv().findFunction(name);\n                dotHandleSimpleError = (RFunction) RContext.getRRuntimeASTAccess().forcePromise(name, f);\n            }\n            return dotHandleSimpleError;\n        }\n        public static ContextStateImpl newContextState() {\n            return new ContextStateImpl();\n        }\n    }\n    /**\n     * A temporary class used to accumulate warnings in deferred mode, Eventually these are\n     * converted to a list and stored in {@code last.warning} in {@code baseenv}.\n     */\n    private static class Warning {\n        final String message;\n        final Object call;\n<fim_suffix>        Warning(String message, Object call) {\n            this.message = message;\n            this.call = call;\n        }\n    }\n    public static final class HandlerStacks {\n        public final Object handlerStack;\n        public final Object restartStack;\n        private HandlerStacks(Object handlerStack, Object restartStack) {\n            this.handlerStack = handlerStack;\n            this.restartStack = restartStack;\n        }\n    }\n    private static final Object RESTART_TOKEN = new Object();\n    private static ContextStateImpl getRErrorHandlingState() {\n        return RContext.getInstance().stateRErrorHandling;\n    }\n    public static HandlerStacks resetAndGetHandlerStacks() {\n        HandlerStacks result = new HandlerStacks(getRErrorHandlingState().handlerStack, getRErrorHandlingState().restartStack);\n        resetStacks();\n        return result;\n    }\n    public static Object getHandlerStack() {\n        return getRErrorHandlingState().handlerStack;\n    }\n    public static Object getRestartStack() {\n        return getRErrorHandlingState().restartStack;\n    }\n    /**<fim_middle>// function below has no smell\n"}