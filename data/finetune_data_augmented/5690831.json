{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.opensymphony.xwork2.util;\n\nimport org.apache.commons.lang3.StringUtils;\n\n/**\n * OGNL implementation of {@link TextParser}\n */\n<fim_suffix>public class OgnlTextParser implements TextParser {\n\n    public Object evaluate(char[] openChars, String expression, TextParseUtil.ParsedValueEvaluator evaluator, int maxLoopCount) {\n        // deal with the \"pure\" expressions first!\n        //expression = expression.trim();\n        Object result = expression = (expression == null) ? \"\" : expression;\n        int pos = 0;\n\n        for (char open : openChars) {\n            int loopCount = 1;\n            //this creates an implicit StringBuffer and shouldn't be used in the inner loop\n            final String lookupChars = open + \"{\";\n\n            while (true) {\n                int start = expression.indexOf(lookupChars, pos);\n                if (start == -1) {\n                    loopCount++;\n                    start = expression.indexOf(lookupChars);\n                }\n                if (loopCount > maxLoopCount) {\n                    // translateVariables prevent infinite loop / expression recursive evaluation\n                    break;\n                }\n                int length = expression.length();\n                int x = start + 2;\n                int end;\n                char c;\n                int count = 1;\n                while (start != -1 && x < length && count != 0) {\n                    c = expression.charAt(x++);\n                    if (c == '{') {\n                        count++;\n                    } else if (c == '}') {\n                        count--;\n                    }\n                }\n                end = x - 1;\n\n                if ((start != -1) && (end != -1) && (count == 0)) {\n                    String var = expression.substring(start + 2, end);\n\n                    Object o = evaluator.evaluate(var);\n\n                    String left = expression.substring(0, start);\n                    String right = expression.substring(end + 1);\n                    String middle = null;\n                    if (o != null) {\n                        middle = o.toString();\n                        if (StringUtils.isEmpty(left)) {\n                            result = o;\n                        } else {\n                            result = left.concat(middle);\n                        }\n\n                        if (StringUtils.isNotEmpty(right)) {\n                            result = result.toString().concat(right);\n                        }\n\n                        expression = left.concat(middle).concat(right);\n                    } else {\n                        // the variable doesn't exist, so don't display anything\n                        expression = left.concat(right);\n                        result = expression;\n                    }\n                    pos = (left != null && left.length() > 0 ? left.length() - 1: 0) +\n                            (middle != null && middle.length() > 0 ? middle.length() - 1: 0) +\n                            1;\n                    pos = Math.max(pos, 1);\n                } else {\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n}<fim_middle>// class below has no smell\n"}