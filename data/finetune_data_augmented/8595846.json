{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with this\n * work for additional information regarding copyright ownership. The ASF\n * licenses this file to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage org.apache.hadoop.hbase.io.crypto;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.security.DigestException;\nimport java.security.Key;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.spec.InvalidKeySpecException;\nimport java.util.Arrays;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport javax.crypto.SecretKeyFactory;\nimport javax.crypto.spec.PBEKeySpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.hbase.HBaseConfiguration;\nimport org.apache.hadoop.hbase.HConstants;\nimport org.apache.hadoop.hbase.util.Bytes;\nimport org.apache.hadoop.hbase.util.Pair;\nimport org.apache.hadoop.util.ReflectionUtils;\nimport org.apache.yetus.audience.InterfaceAudience;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n/**\n * A facade for encryption algorithms and related support.\n */\n@InterfaceAudience.Public\npublic final class Encryption {\n  private static final Logger LOG = LoggerFactory.getLogger(Encryption.class);\n  /**\n   * Crypto context\n   */\n  @InterfaceAudience.Public\n  public static class Context extends org.apache.hadoop.hbase.io.crypto.Context {\n    /** The null crypto context */\n    public static final Context NONE = new Context();\n    private Context() {\n      super();\n    }\n    private Context(Configuration conf) {\n      super(conf);\n    }\n    @Override\n    public Context setCipher(Cipher cipher) {\n      super.setCipher(cipher);\n      return this;\n    }\n    @Override\n    public Context setKey(Key key) {\n      super.setKey(key);\n      return this;\n    }\n    public Context setKey(byte[] key) {\n      super.setKey(new SecretKeySpec(key, getCipher().getName()));\n      return this;\n    }\n  }\n  public static Context newContext() {\n    return new Context();\n  }\n  public static Context newContext(Configuration conf) {\n    return new Context(conf);\n  }\n  // Prevent instantiation\n  private Encryption() {\n    super();\n  }\n  /**\n   * Get an cipher given a name\n   * @param name the cipher name\n   * @return the cipher, or null if a suitable one could not be found\n   */\n  public static Cipher getCipher(Configuration conf, String name) {\n    return getCipherProvider(conf).getCipher(name);\n  }\n  /**\n   * Get names of supported encryption algorithms\n   *\n   * @return Array of strings, each represents a supported encryption algorithm\n   */\n  public static String[] getSupportedCiphers() {\n    return getSupportedCiphers(HBaseConfiguration.create());\n  }\n  /**\n   * Get names of supported encryption algorithms\n   *\n   * @return Array of strings, each represents a supported encryption algorithm\n   */\n  public static String[] getSupportedCiphers(Configuration conf) {\n    return getCipherProvider(conf).getSupportedCiphers();\n  }\n  /**\n   * Return the MD5 digest of the concatenation of the supplied arguments.\n   */\n  public static byte[] hash128(String... args) {\n    byte[] result = new byte[16];\n    try {\n      MessageDigest md = MessageDigest.getInstance(\"MD5\");\n      for (String arg: args) {\n        md.update(Bytes.toBytes(arg));\n      }\n      md.digest(result, 0, result.length);\n      return result;\n    } catch (NoSuchAlgorithmException e) {\n      throw new RuntimeException(e);\n    } catch (DigestException e) {\n      throw new RuntimeException(e);\n    }\n  }\n  /**\n   * Return the MD5 digest of the concatenation of the supplied arguments.\n   */\n  public static byte[] hash128(byte[]... args) {\n    byte[] result = new byte[16];\n    try {\n      MessageDigest md = MessageDigest.getInstance(\"MD5\");\n      for (byte[] arg: args) {\n        md.update(arg);\n      }\n      md.digest(result, 0, result.length);\n      return result;\n    } catch (NoSuchAlgorithmException e) {\n      throw new RuntimeException(e);\n    } catch (DigestException e) {\n      throw new RuntimeException(e);\n    }\n  }\n  /**\n   * Return the SHA-256 digest of the concatenation of the supplied arguments.\n   */\n  public static byte[] hash256(String... args) {\n    byte[] result = new byte[32];\n    try {\n      MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n      for (String arg: args) {\n        md.update(Bytes.toBytes(arg));\n      }\n      md.digest(result, 0, result.length);\n      return result;\n    } catch (NoSuchAlgorithmException e) {\n      throw new RuntimeException(e);\n    } catch (DigestException e) {\n      throw new RuntimeException(e);\n    }\n  }\n  /**\n   * Return the SHA-256 digest of the concatenation of the supplied arguments.\n   */\n  public static byte[] hash256(byte[]... args) {\n    byte[] result = new byte[32];\n    try {\n      MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n      for (byte[] arg: args) {\n        md.update(arg);\n      }\n      md.digest(result, 0, result.length);\n      return result;\n    } catch (NoSuchAlgorithmException e) {\n      throw new RuntimeException(e);\n    } catch (DigestException e) {\n      throw new RuntimeException(e);\n    }\n  }\n  /**\n   * Return a 128 bit key derived from the concatenation of the supplied\n   * arguments using PBKDF2WithHmacSHA1 at 10,000 iterations.\n   *\n   */\n  public static byte[] pbkdf128(String... args) {\n    byte[] salt = new byte[128];\n    Bytes.random(salt);\n    StringBuilder sb = new StringBuilder();\n    for (String s: args) {\n      sb.append(s);\n    }\n    PBEKeySpec spec = new PBEKeySpec(sb.toString().toCharArray(), salt, 10000, 128);\n    try {\n      return SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\")\n        .generateSecret(spec).getEncoded();\n    } catch (NoSuchAlgorithmException e) {\n      throw new RuntimeException(e);\n    } catch (InvalidKeySpecException e) {\n      throw new RuntimeException(e);\n    }\n  }\n  /**\n   * Return a 128 bit key derived from the concatenation of the supplied\n   * arguments using PBKDF2WithHmacSHA1 at 10,000 iterations.\n   *\n   */\n  public static byte[] pbkdf128(byte[]... args) {\n    byte[] salt = new byte[128];\n    Bytes.random(salt);\n    StringBuilder sb = new StringBuilder();\n    for (byte[] b: args) {\n      sb.append(Arrays.toString(b));\n    }\n    PBEKeySpec spec = new PBEKeySpec(sb.toString().toCharArray(), salt, 10000, 128);\n    try {\n      return SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\")\n        .generateSecret(spec).getEncoded();\n    } catch (NoSuchAlgorithmException e) {\n      throw new RuntimeException(e);\n    } catch (InvalidKeySpecException e) {\n      throw new RuntimeException(e);\n    }\n  }\n  /**\n   * Encrypt a block of plaintext\n   * <p>\n   * The encryptor's state will be finalized. It should be reinitialized or\n   * returned to the pool.\n   * @param out ciphertext\n   * @param src plaintext\n   * @param offset\n   * @param length\n   * @param e\n   * @throws IOException\n    */\n<fim_suffix>  public static void encrypt(OutputStream out, byte[] src, int offset,\n      int length, Encryptor e) throws IOException {\n    OutputStream cout = e.createEncryptionStream(out);\n    try {\n      cout.write(src, offset, length);\n    } finally {\n      cout.close();\n    }\n  }\n  /**\n   * Encrypt a block of plaintext\n   * @param out ciphertext\n   * @param src plaintext<fim_middle>// function below has no smell\n"}