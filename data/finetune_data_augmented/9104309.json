{"text": "<fim_prefix>/*\n * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 3 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 3 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 3 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage com.oracle.truffle.r.nodes.builtin.casts;\nimport java.util.function.Predicate;\nimport com.oracle.truffle.r.nodes.builtin.ArgumentFilter;\nimport com.oracle.truffle.r.nodes.builtin.casts.PipelineStep.FilterStep;\nimport com.oracle.truffle.r.nodes.builtin.casts.PipelineStep.MapStep;\nimport com.oracle.truffle.r.runtime.RType;\nimport com.oracle.truffle.r.runtime.data.RArgsValuesAndNames;\nimport com.oracle.truffle.r.runtime.data.RMissing;\nimport com.oracle.truffle.r.runtime.data.RNull;\nimport com.oracle.truffle.r.runtime.data.model.RAbstractVector;\n/**\n * Represents filters that can be used in {@link FilterStep} and as condition in {@link MapStep}.\n */\npublic abstract class Filter<T, R extends T> {\n    protected Filter() {\n    }\n    public ResultForArg resultForNull() {\n        return ResultForArg.UNDEFINED;\n    }\n    public ResultForArg resultForMissing() {\n        return ResultForArg.UNDEFINED;\n    }\n    public abstract <D> D accept(FilterVisitor<D> visitor, D previous);\n    public <S extends R> AndFilter<T, S> and(Filter<? super R, S> other) {\n        return new AndFilter<>(this, other);\n    }\n    public OrFilter<T> or(Filter<T, ? extends T> other) {\n        return new OrFilter<>(this, other);\n    }\n    public NotFilter<T> not() {\n        return new NotFilter<>(this);\n    }\n    public interface FilterVisitor<D> {\n        D visit(TypeFilter<?, ?> filter, D previous);\n        D visit(RTypeFilter<?> filter, D previous);\n        D visit(CompareFilter<?> filter, D previous);\n        D visit(AndFilter<?, ?> filter, D previous);\n        D visit(OrFilter<?> filter, D previous);\n        D visit(NotFilter<?> filter, D previous);\n        D visit(MatrixFilter<?> filter, D previous);\n        D visit(DoubleFilter filter, D previous);\n        D visit(NullFilter filter, D previous);\n        D visit(MissingFilter filter, D previous);\n        D visit(RVarArgsFilter filter, D previous);\n    }\n    /**\n     * Filters specific Java class.\n     */\n    public static final class TypeFilter<T, R extends T> extends Filter<T, R> {\n        private final Class<?> type1;\n        private final Class<?> type2;\n        private final Predicate<R> extraCondition;\n        public TypeFilter(Class<R> type) {\n            assert type != null;\n            this.type1 = type;\n            this.type2 = null;\n            this.extraCondition = null;\n        }\n        public TypeFilter(Class<R> type, Predicate<R> extraCondition) {\n            assert type != null;\n            this.type1 = type;\n            this.type2 = null;\n            this.extraCondition = extraCondition;\n        }\n        public TypeFilter(Class<?> type1, Class<?> type2) {\n            assert type1 != null && type2 != null;\n            assert type1 != Object.class && type2 != Object.class;\n            this.type1 = type1;\n            this.type2 = type2;\n            this.extraCondition = null;\n        }\n        public Class<?> getType1() {\n            return type1;\n        }\n        public Class<?> getType2() {\n            return type2;\n        }\n        public Predicate<R> getExtraCondition() {\n            return extraCondition;\n        }\n        @SuppressWarnings(\"unchecked\")\n        public ArgumentFilter<Object, Object> getInstanceOfLambda() {\n            final ArgumentFilter<Object, Object> instanceOfLambda;\n            if (type2 == null) {\n                if (extraCondition == null) {\n                    if (type1 == Object.class) {\n                        instanceOfLambda = x -> true;\n                    } else {\n                        instanceOfLambda = x -> type1.isInstance(x);\n                    }\n                } else {\n                    if (type1 == Object.class) {\n                        instanceOfLambda = x -> extraCondition.test((R) x);\n                    } else {\n                        instanceOfLambda = x -> type1.isInstance(x) && extraCondition.test((R) x);\n                    }\n                }\n            } else {\n                instanceOfLambda = x -> type1.isInstance(x) || type2.isInstance(x);\n            }\n            return instanceOfLambda;\n        }\n        @Override\n        public <D> D accept(FilterVisitor<D> visitor, D previous) {\n            return visitor.visit(this, previous);\n        }\n        @Override\n        public ResultForArg resultForNull() {\n            return ResultForArg.FALSE;\n        }\n        @Override\n        public ResultForArg resultForMissing() {\n            return ResultForArg.FALSE;\n        }\n    }\n    /**\n     * Filters specified set of type in R sense, supports only vector types minus list.\n     */\n    public static final class RTypeFilter<T extends RAbstractVector> extends Filter<Object, T> {\n        private final RType type;\n        public RTypeFilter(RType type) {\n            assert type.isVector() && type != RType.List : \"RTypeFilter supports only vector types minus list.\";\n            this.type = type;\n        }\n        public RType getType() {\n            return type;\n        }\n        @Override\n        public <D> D accept(FilterVisitor<D> visitor, D previous) {\n            return visitor.visit(this, previous);\n        }\n        @Override\n        public ResultForArg resultForNull() {\n            return ResultForArg.FALSE;\n        }\n        @Override\n        public ResultForArg resultForMissing() {\n            return ResultForArg.FALSE;\n        }\n    }\n    public static final class NullFilter extends Filter<Object, RNull> {\n        public static final NullFilter INSTANCE = new NullFilter();\n        private NullFilter() {\n        }\n        @Override\n        public <D> D accept(FilterVisitor<D> visitor, D previous) {\n            return visitor.visit(this, previous);\n        }\n        @Override\n        public ResultForArg resultForNull() {\n            return ResultForArg.TRUE;\n        }\n        @Override\n        public ResultForArg resultForMissing() {\n            return ResultForArg.FALSE;\n        }\n    }\n    public static final class MissingFilter extends Filter<Object, RMissing> {\n        public static final MissingFilter INSTANCE = new MissingFilter();\n        private MissingFilter() {\n        }\n        @Override\n        public <D> D accept(FilterVisitor<D> visitor, D previous) {\n            return visitor.visit(this, previous);\n        }\n        @Override\n        public ResultForArg resultForNull() {\n            return ResultForArg.FALSE;\n        }\n        @Override\n        public ResultForArg resultForMissing() {\n            return ResultForArg.TRUE;\n        }\n    }\n    /**\n     * Compares the real value against given value using given operation. Use the constants defined\n     * within this class for the operation.\n     */\n    public static final class CompareFilter<T> extends Filter<T, T> {\n        public interface Subject {\n            <D> D accept(SubjectVisitor<D> visitor, byte operation, D previous);\n        }\n<fim_suffix>        public interface SubjectVisitor<D> {\n            D visit(ScalarValue scalarValue, byte operation, D previous);\n            D visit(NATest naTest, byte operation, D previous);\n            D visit(StringLength stringLength, byte operation, D previous);\n            D visit(VectorSize vectorSize, byte operation, D previous);\n            D visit(ElementAt elementAt, byte operation, D previous);\n            D visit(Dim dim, byte operation, D previous);\n        }\n        public static final class ScalarValue implements Subject {\n            public final Object value;\n            public final RType type;\n            public ScalarValue(Object value, RType type) {\n                this.value = value;\n                this.type = type;\n            }\n            @Override<fim_middle>// class below has no smell\n"}