{"text": "<fim_prefix>package org.apache.commons.jcs.auxiliary.remote;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport org.apache.commons.jcs.auxiliary.AbstractAuxiliaryCacheMonitor;\n\n/**\n * Used to monitor and repair any failed connection for the remote cache service. By default the\n * monitor operates in a failure driven mode. That is, it goes into a wait state until there is an\n * error.\n *\n * TODO consider moving this into an active monitoring mode. Upon the notification of a\n * connection error, the monitor changes to operate in a time driven mode. That is, it attempts to\n * recover the connections on a periodic basis. When all failed connections are restored, it changes\n * back to the failure driven mode.\n */\npublic class RemoteCacheMonitor extends AbstractAuxiliaryCacheMonitor\n{\n    /**\n     * Map of managers to monitor\n     */\n    private ConcurrentHashMap<RemoteCacheManager, RemoteCacheManager> managers;\n\n    /** Constructor for the RemoteCacheMonitor object */\n    public RemoteCacheMonitor()\n    {\n        super(\"JCS-RemoteCacheMonitor\");\n        this.managers = new ConcurrentHashMap<RemoteCacheManager, RemoteCacheManager>();\n        setIdlePeriod(30000L);\n    }\n\n    /**\n     * Add a manager to be monitored\n     *\n     * @param manager the remote cache manager\n     */\n    public void addManager(RemoteCacheManager manager)\n    {\n        this.managers.put(manager, manager);\n\n        // if not yet started, go ahead\n        if (this.getState() == Thread.State.NEW)\n        {\n            this.start();\n        }\n    }\n\n    /**\n     * Clean up all resources before shutdown\n     */\n<fim_suffix>    @Override\n    public void dispose()\n    {\n        this.managers.clear();\n    }\n\n    // Avoid the use of any synchronization in the process of monitoring for\n    // performance reason.\n    // If exception is thrown owing to synchronization,\n    // just skip the monitoring until the next round.\n    /** Main processing method for the RemoteCacheMonitor object */\n    @Override\n    public void doWork()\n    {\n        // Monitor each RemoteCacheManager instance one after the other.\n        // Each RemoteCacheManager corresponds to one remote connection.\n        for (RemoteCacheManager mgr : managers.values())\n        {\n            // If we can't fix them, just skip and re-try in\n            // the next round.\n            if ( mgr.canFixCaches() )\n            {\n                mgr.fixCaches();\n            }\n            else\n            {\n                allright.set(false);\n            }\n        }\n    }\n}<fim_middle>// function below has no smell\n"}