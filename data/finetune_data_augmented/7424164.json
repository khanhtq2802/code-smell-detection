{"text": "<fim_prefix>import org.graalvm.compiler.lir.aarch64.AArch64AddressValue;\nimport org.graalvm.compiler.lir.aarch64.AArch64ArithmeticLIRGeneratorTool;\nimport org.graalvm.compiler.lir.aarch64.AArch64ArithmeticOp;\nimport org.graalvm.compiler.lir.aarch64.AArch64BitManipulationOp;\nimport org.graalvm.compiler.lir.aarch64.AArch64Move.LoadOp;\nimport org.graalvm.compiler.lir.aarch64.AArch64Move.StoreConstantOp;\nimport org.graalvm.compiler.lir.aarch64.AArch64Move.StoreOp;\nimport org.graalvm.compiler.lir.aarch64.AArch64ReinterpretOp;\nimport org.graalvm.compiler.lir.aarch64.AArch64SignExtendOp;\nimport org.graalvm.compiler.lir.aarch64.AArch64Unary;\nimport org.graalvm.compiler.lir.gen.ArithmeticLIRGenerator;\nimport jdk.vm.ci.aarch64.AArch64Kind;\nimport jdk.vm.ci.meta.AllocatableValue;\nimport jdk.vm.ci.meta.JavaConstant;\nimport jdk.vm.ci.meta.PlatformKind;\nimport jdk.vm.ci.meta.Value;\nimport jdk.vm.ci.meta.ValueKind;\npublic class AArch64ArithmeticLIRGenerator extends ArithmeticLIRGenerator implements AArch64ArithmeticLIRGeneratorTool {\n    @Override\n    public AArch64LIRGenerator getLIRGen() {\n        return (AArch64LIRGenerator) super.getLIRGen();\n    }\n    @Override\n    protected boolean isNumericInteger(PlatformKind kind) {\n        return ((AArch64Kind) kind).isInteger();\n    }\n    @Override\n    protected Variable emitAdd(LIRKind resultKind, Value a, Value b, boolean setFlags) {\n        if (isNumericInteger(a.getPlatformKind())) {\n            AArch64ArithmeticOp op = setFlags ? AArch64ArithmeticOp.ADDS : AArch64ArithmeticOp.ADD;\n            return emitBinary(resultKind, op, true, a, b);\n        } else {\n            assert !setFlags : \"Cannot set flags on floating point arithmetic\";\n            return emitBinary(resultKind, AArch64ArithmeticOp.FADD, true, a, b);\n        }\n    }\n    @Override\n    protected Variable emitSub(LIRKind resultKind, Value a, Value b, boolean setFlags) {\n        if (isNumericInteger(a.getPlatformKind())) {\n            AArch64ArithmeticOp op = setFlags ? AArch64ArithmeticOp.SUBS : AArch64ArithmeticOp.SUB;\n            return emitBinary(resultKind, op, false, a, b);\n        } else {\n            assert !setFlags : \"Cannot set flags on floating point arithmetic\";\n            return emitBinary(resultKind, AArch64ArithmeticOp.FSUB, false, a, b);\n        }\n    }\n    public Value emitExtendMemory(boolean isSigned, AArch64Kind memoryKind, int resultBits, AArch64AddressValue address, LIRFrameState state) {\n        // Issue a zero extending load of the proper bit size and set the result to\n        // the proper kind.\n        Variable result = getLIRGen().newVariable(LIRKind.value(resultBits == 32 ? AArch64Kind.DWORD : AArch64Kind.QWORD));\n        int targetSize = resultBits <= 32 ? 32 : 64;\n        switch (memoryKind) {\n            case BYTE:\n            case WORD:\n            case DWORD:\n            case QWORD:\n                getLIRGen().append(new AArch64Unary.MemoryOp(isSigned, targetSize,\n                                memoryKind.getSizeInBytes() * 8, result, address, state));\n                break;\n            default:\n                throw GraalError.shouldNotReachHere();\n        }\n        return result;\n    }\n    @Override\n    public Value emitMul(Value a, Value b, boolean setFlags) {\n        AArch64ArithmeticOp intOp = setFlags ? AArch64ArithmeticOp.MULVS : AArch64ArithmeticOp.MUL;\n        return emitBinary(LIRKind.combine(a, b), getOpCode(a, intOp, AArch64ArithmeticOp.FMUL), true, a, b);\n    }\n    @Override\n    public Value emitMulHigh(Value a, Value b) {\n        assert isNumericInteger(a.getPlatformKind());\n        return emitBinary(LIRKind.combine(a, b), AArch64ArithmeticOp.SMULH, true, a, b);\n    }\n    @Override\n    public Value emitUMulHigh(Value a, Value b) {\n        assert isNumericInteger(a.getPlatformKind());\n        return emitBinary(LIRKind.combine(a, b), AArch64ArithmeticOp.UMULH, true, a, b);\n    }\n    public Value emitMNeg(Value a, Value b) {\n        assert isNumericInteger(a.getPlatformKind()) && isNumericInteger(b.getPlatformKind());\n        return emitBinary(LIRKind.combine(a, b), AArch64ArithmeticOp.MNEG, true, a, b);\n    }\n    @Override\n    public Value emitDiv(Value a, Value b, LIRFrameState state) {\n        return emitBinary(LIRKind.combine(a, b), getOpCode(a, AArch64ArithmeticOp.DIV, AArch64ArithmeticOp.FDIV), false, asAllocatable(a), asAllocatable(b));\n    }\n    @Override\n    public Value emitRem(Value a, Value b, LIRFrameState state) {\n        return emitBinary(LIRKind.combine(a, b), getOpCode(a, AArch64ArithmeticOp.REM, AArch64ArithmeticOp.FREM), false, asAllocatable(a), asAllocatable(b));\n    }\n    @Override\n    public Value emitUDiv(Value a, Value b, LIRFrameState state) {\n        assert isNumericInteger(a.getPlatformKind());\n        return emitBinary(LIRKind.combine(a, b), AArch64ArithmeticOp.UDIV, false, asAllocatable(a), asAllocatable(b));\n    }\n    @Override\n    public Value emitURem(Value a, Value b, LIRFrameState state) {\n        assert isNumericInteger(a.getPlatformKind());\n        return emitBinary(LIRKind.combine(a, b), AArch64ArithmeticOp.UREM, false, asAllocatable(a), asAllocatable(b));\n    }\n    @Override\n    public Value emitAnd(Value a, Value b) {\n        assert isNumericInteger(a.getPlatformKind());\n        return emitBinary(LIRKind.combine(a, b), AArch64ArithmeticOp.AND, true, a, b);\n    }\n    @Override\n    public Value emitOr(Value a, Value b) {\n        assert isNumericInteger(a.getPlatformKind());\n        return emitBinary(LIRKind.combine(a, b), AArch64ArithmeticOp.OR, true, a, b);\n    }\n    @Override\n    public Value emitXor(Value a, Value b) {\n        assert isNumericInteger(a.getPlatformKind());\n        return emitBinary(LIRKind.combine(a, b), AArch64ArithmeticOp.XOR, true, a, b);\n    }\n    @Override\n    public Value emitShl(Value a, Value b) {\n        assert isNumericInteger(a.getPlatformKind());\n        return emitBinary(LIRKind.combine(a, b), AArch64ArithmeticOp.SHL, false, a, b);\n    }\n    @Override\n    public Value emitShr(Value a, Value b) {\n        assert isNumericInteger(a.getPlatformKind());\n        return emitBinary(LIRKind.combine(a, b), AArch64ArithmeticOp.ASHR, false, a, b);\n    }\n    @Override\n    public Value emitUShr(Value a, Value b) {\n        assert isNumericInteger(a.getPlatformKind());\n        return emitBinary(LIRKind.combine(a, b), AArch64ArithmeticOp.LSHR, false, a, b);\n    }\n<fim_suffix>    @Override\n    public Value emitFloatConvert(FloatConvert op, Value inputVal) {\n        PlatformKind resultPlatformKind = getFloatConvertResultKind(op);\n        LIRKind resultLirKind = LIRKind.combine(inputVal).changeType(resultPlatformKind);\n        Variable result = getLIRGen().newVariable(resultLirKind);\n        getLIRGen().append(new AArch64FloatConvertOp(op, result, asAllocatable(inputVal)));\n        return result;\n    }<fim_middle>// function below has no smell\n"}