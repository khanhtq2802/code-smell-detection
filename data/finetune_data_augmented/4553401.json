{"text": "<fim_prefix>        final LocalDate interestPostingUpToDate = interestPostingUpToDate(postingDate);\n        return super.calculateInterestUsing(mc, interestPostingUpToDate, isInterestTransfer, isSavingsInterestPostingAtCurrentPeriodEnd,\n                financialYearBeginningMonth, postAsInterestOn);\n    }\n    private LocalDate interestPostingUpToDate(final LocalDate interestPostingDate) {\n        LocalDate interestPostingUpToDate = interestPostingDate;\n        final LocalDate uptoMaturityDate = interestCalculatedUpto();\n        if (uptoMaturityDate != null && uptoMaturityDate.isBefore(interestPostingDate)) {\n            interestPostingUpToDate = uptoMaturityDate;\n        }\n        return interestPostingUpToDate;\n    }\n    public LocalDate maturityDate() {\n        return this.accountTermAndPreClosure.getMaturityLocalDate();\n    }\n    public BigDecimal maturityAmount() {\n        return this.accountTermAndPreClosure.maturityAmount();\n    }\n    private LocalDate interestCalculatedUpto() {\n        LocalDate uptoMaturityDate = calculateMaturityDate();\n        if (uptoMaturityDate != null) {\n            // interest should not be calculated for maturity day\n            uptoMaturityDate = uptoMaturityDate.minusDays(1);\n        }\n        return uptoMaturityDate;\n    }\n    private Money totalInterestPosted() {\n        Money interestPostedToDate = Money.zero(this.currency);\n        List<SavingsAccountTransaction> trans = getTransactions() ;\n        for (final SavingsAccountTransaction transaction : trans) {\n            if (transaction.isInterestPostingAndNotReversed()) {\n                interestPostedToDate = interestPostedToDate.plus(transaction.getAmount(currency));\n            }\n        }\n        return interestPostedToDate;\n    }\n    @Override\n    public Map<String, Object> activate(final AppUser currentUser, final JsonCommand command, final LocalDate tenantsTodayDate) {\n        final Map<String, Object> actualChanges = super.activate(currentUser, command, tenantsTodayDate);\n        if (accountTermAndPreClosure.isAfterExpectedFirstDepositDate(getActivationLocalDate())) {\n            final List<ApiParameterError> dataValidationErrors = new ArrayList<>();\n            final DataValidatorBuilder baseDataValidator = new DataValidatorBuilder(dataValidationErrors)\n                    .resource(RECURRING_DEPOSIT_ACCOUNT_RESOURCE_NAME);\n            final DateTimeFormatter formatter = DateTimeFormat.forPattern(command.dateFormat()).withLocale(command.extractLocale());\n            final String dateAsString = formatter.print(this.accountTermAndPreClosure.getExpectedFirstDepositOnDate());\n            baseDataValidator.reset().parameter(DepositsApiConstants.activatedOnDateParamName).value(dateAsString)\n                    .failWithCodeNoParameterAddedToErrorCode(\"cannot.be.before.expected.first.deposit.date\");\n            if (!dataValidationErrors.isEmpty()) { throw new PlatformApiDataValidationException(dataValidationErrors); }\n        }\n        return actualChanges;\n    }\n    protected List<SavingsAccountTransaction> sortTransactions(final List<SavingsAccountTransaction> transactions) {\n        final List<SavingsAccountTransaction> listOfTransactionsSorted = new ArrayList<>();\n        listOfTransactionsSorted.addAll(transactions);\n        final SavingsAccountTransactionComparator transactionComparator = new SavingsAccountTransactionComparator();\n        Collections.sort(listOfTransactionsSorted, transactionComparator);\n        return listOfTransactionsSorted;\n    }\n    @Override\n    public SavingsAccountTransaction deposit(final SavingsAccountTransactionDTO transactionDTO) {\n        if (isAccountMatured()) {\n            final String defaultUserMessage = \"Transaction is not allowed. Account is matured.\";\n            final ApiParameterError error = ApiParameterError.parameterError(\n                    \"error.msg.recurring.deposit.account.transaction.account.is.matured\", defaultUserMessage, \"transactionDate\",\n                    transactionDTO.getTransactionDate().toString(transactionDTO.getFormatter()));\n            final List<ApiParameterError> dataValidationErrors = new ArrayList<>();\n            dataValidationErrors.add(error);\n            throw new PlatformApiDataValidationException(dataValidationErrors);\n        }\n        if (!isBeforeMaturityDate(transactionDTO.getTransactionDate())) {\n            final String defaultUserMessage = \"Transaction is not allowed. Transaction date is on or after account maturity date.\";\n            final ApiParameterError error = ApiParameterError.parameterError(\n                    \"error.msg.recurring.deposit.account.transaction.date.is.after.account.maturity.date\", defaultUserMessage,\n                    \"transactionDate\", transactionDTO.getTransactionDate().toString(transactionDTO.getFormatter()));\n            final List<ApiParameterError> dataValidationErrors = new ArrayList<>();\n            dataValidationErrors.add(error);\n            throw new PlatformApiDataValidationException(dataValidationErrors);\n        }\n        if (isBeforeDepositStartDate(transactionDTO.getTransactionDate())) {\n            final String defaultUserMessage = \"Transaction is not allowed. Transaction date is on or after account activation and deposit start date.\";\n            final ApiParameterError error = ApiParameterError.parameterError(\n                    \"error.msg.recurring.deposit.account.transaction.date.is.before.account.activation.or.deposit.date\",\n                    defaultUserMessage, \"transactionDate\", transactionDTO.getTransactionDate().toString(transactionDTO.getFormatter()));\n            final List<ApiParameterError> dataValidationErrors = new ArrayList<>();\n            dataValidationErrors.add(error);\n            throw new PlatformApiDataValidationException(dataValidationErrors);\n        }\n        final SavingsAccountTransaction transaction = super.deposit(transactionDTO);\n        return transaction;\n    }\n    public void handleScheduleInstallments(final SavingsAccountTransaction transaction) {\n        final LocalDate transactionDate = transaction.transactionLocalDate();\n        Money transactionAmountUnprocessed = transaction.getAmount(getCurrency());\n        for (RecurringDepositScheduleInstallment currentInstallment : depositScheduleInstallments()) {\n            if (currentInstallment.isNotFullyPaidOff() && transactionAmountUnprocessed.isGreaterThanZero()) {\n                if (!this.adjustAdvanceTowardsFuturePayments() && currentInstallment.dueDate().isAfter(transactionDate)) {\n                    transactionAmountUnprocessed = Money.zero(getCurrency());\n                }\n                transactionAmountUnprocessed = handleInstallmentTransaction(currentInstallment, transactionAmountUnprocessed,\n                        transactionDate);\n            }\n        }\n    }\n    public void updateScheduleInstallments() {\n        // reset all installments to process from the beginning\n        for (RecurringDepositScheduleInstallment currentInstallment : depositScheduleInstallments()) {\n            currentInstallment.resetDerivedFields();\n        }\n        final List<SavingsAccountTransaction> orderedDepositTransactions = retreiveOrderedDepositTransactions();\n        for (SavingsAccountTransaction transaction : orderedDepositTransactions) {\n            handleScheduleInstallments(transaction);\n        }\n    }\n    public void updateScheduleInstallmentsWithNewRecommendedDepositAmount(BigDecimal newDepositAmount,\n            LocalDate depositAmountupdatedFromDate) {\n        // reset all installments to process from the beginning, also update\n        // deposit amount as necessary\n        for (RecurringDepositScheduleInstallment currentInstallment : depositScheduleInstallments()) {\n            if (currentInstallment.dueDate().isAfter(depositAmountupdatedFromDate)\n                    || currentInstallment.dueDate().isEqual(depositAmountupdatedFromDate)) {\n                currentInstallment.updateDepositAmountAndResetDerivedFields(newDepositAmount);\n            } else {\n                currentInstallment.resetDerivedFields();\n            }\n        }\n        final List<SavingsAccountTransaction> orderedDepositTransactions = retreiveOrderedDepositTransactions();\n        for (SavingsAccountTransaction transaction : orderedDepositTransactions) {\n            handleScheduleInstallments(transaction);\n        }\n    }\n    private List<SavingsAccountTransaction> retreiveOrderedDepositTransactions() {\n        final List<SavingsAccountTransaction> listOfTransactionsSorted = retreiveListOfTransactions();\n        final List<SavingsAccountTransaction> orderedDepositTransactions = new ArrayList<>();\n        for (final SavingsAccountTransaction transaction : listOfTransactionsSorted) {\n            if (transaction.isDepositAndNotReversed()) {\n                orderedDepositTransactions.add(transaction);\n            }\n        }\n        return orderedDepositTransactions;\n    }\n    /**\n     * This method is responsible for checking if the current transaction is 'an\n     * advance/early payment' based on the details passed through.\n     * \n     * Default implementation is check transaction date is before installment\n     * due date.\n     */\n    protected boolean isTransactionInAdvanceOfInstallment(final int currentInstallmentIndex,\n            final List<RecurringDepositScheduleInstallment> installments, final LocalDate transactionDate) {\n        final RecurringDepositScheduleInstallment currentInstallment = installments.get(currentInstallmentIndex);\n        return transactionDate.isBefore(currentInstallment.dueDate());\n    }\n<fim_suffix>    private Money handleInstallmentTransaction(final RecurringDepositScheduleInstallment currentInstallment,\n            final Money transactionAmountUnprocessed, final LocalDate transactionDate) {\n        Money transactionAmountRemaining = transactionAmountUnprocessed;\n        Money depositAmountPortion = Money.zero(transactionAmountRemaining.getCurrency());\n        depositAmountPortion = currentInstallment.payInstallment(transactionDate, transactionAmountRemaining);\n        transactionAmountRemaining = transactionAmountRemaining.minus(depositAmountPortion);\n        return transactionAmountRemaining;\n    }<fim_middle>// function below has no smell\n"}