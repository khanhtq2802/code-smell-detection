{"text": "<fim_prefix>/*\n * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.\n *\n * You are hereby granted a non-exclusive, worldwide, royalty-free license to use,\n * copy, modify, and distribute this software in source code or binary form for use\n * in connection with the web services and APIs provided by Facebook.\n *\n * As with any software that integrates with the Facebook platform, your use of\n * this software is subject to the Facebook Developer Principles and Policies\n * [http://developers.facebook.com/policy/]. This copyright notice shall be\n * included in all copies or substantial portions of the software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\npackage com.facebook;\nimport android.app.AlarmManager;\nimport android.app.PendingIntent;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.Looper;\nimport android.support.v4.content.LocalBroadcastManager;\nimport android.util.Log;\nimport com.facebook.internal.Utility;\nimport com.facebook.internal.Validate;\nimport org.json.JSONArray;\nimport org.json.JSONObject;\nimport java.util.Date;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicBoolean;\nfinal public class AccessTokenManager {\n    public static final String TAG = \"AccessTokenManager\";\n    public static final String ACTION_CURRENT_ACCESS_TOKEN_CHANGED =\n            \"com.facebook.sdk.ACTION_CURRENT_ACCESS_TOKEN_CHANGED\";\n    public static final String EXTRA_OLD_ACCESS_TOKEN =\n            \"com.facebook.sdk.EXTRA_OLD_ACCESS_TOKEN\";\n    public static final String EXTRA_NEW_ACCESS_TOKEN =\n            \"com.facebook.sdk.EXTRA_NEW_ACCESS_TOKEN\";\n    public static final String SHARED_PREFERENCES_NAME =\n            \"com.facebook.AccessTokenManager.SharedPreferences\";\n    // Token extension constants\n    private static final int TOKEN_EXTEND_THRESHOLD_SECONDS = 24 * 60 * 60; // 1 day\n    private static final int TOKEN_EXTEND_RETRY_SECONDS = 60 * 60; // 1 hour\n    private static final String TOKEN_EXTEND_GRAPH_PATH = \"oauth/access_token\";\n    private static final String ME_PERMISSIONS_GRAPH_PATH = \"me/permissions\";\n    private static volatile AccessTokenManager instance;\n    private final LocalBroadcastManager localBroadcastManager;\n    private final AccessTokenCache accessTokenCache;\n    private AccessToken currentAccessToken;\n    private AtomicBoolean tokenRefreshInProgress = new AtomicBoolean(false);\n    private Date lastAttemptedTokenExtendDate = new Date(0);\n    AccessTokenManager(LocalBroadcastManager localBroadcastManager,\n                       AccessTokenCache accessTokenCache) {\n        Validate.notNull(localBroadcastManager, \"localBroadcastManager\");\n        Validate.notNull(accessTokenCache, \"accessTokenCache\");\n        this.localBroadcastManager = localBroadcastManager;\n        this.accessTokenCache = accessTokenCache;\n    }\n    static AccessTokenManager getInstance() {\n        if (instance == null) {\n            synchronized (AccessTokenManager.class) {\n                if (instance == null) {\n                    Context applicationContext = FacebookSdk.getApplicationContext();\n                    LocalBroadcastManager localBroadcastManager = LocalBroadcastManager.getInstance(\n                            applicationContext);\n                    AccessTokenCache accessTokenCache = new AccessTokenCache();\n                    instance = new AccessTokenManager(localBroadcastManager, accessTokenCache);\n                }\n            }\n        }\n        return instance;\n    }\n    AccessToken getCurrentAccessToken() {\n        return currentAccessToken;\n    }\n    boolean loadCurrentAccessToken() {\n        AccessToken accessToken = accessTokenCache.load();\n        if (accessToken != null) {\n            setCurrentAccessToken(accessToken, false);\n            return true;\n        }\n        return false;\n    }\n    void setCurrentAccessToken(AccessToken currentAccessToken) {\n        setCurrentAccessToken(currentAccessToken, true);\n    }\n    private void setCurrentAccessToken(AccessToken currentAccessToken, boolean saveToCache) {\n        AccessToken oldAccessToken = this.currentAccessToken;\n        this.currentAccessToken = currentAccessToken;\n        tokenRefreshInProgress.set(false);\n        this.lastAttemptedTokenExtendDate = new Date(0);\n        if (saveToCache) {\n            if (currentAccessToken != null) {\n                accessTokenCache.save(currentAccessToken);\n            } else {\n                accessTokenCache.clear();\n                Utility.clearFacebookCookies(FacebookSdk.getApplicationContext());\n            }\n        }\n        if (!Utility.areObjectsEqual(oldAccessToken, currentAccessToken)) {\n            sendCurrentAccessTokenChangedBroadcastIntent(oldAccessToken, currentAccessToken);\n            setTokenExpirationBroadcastAlarm();\n        }\n    }\n    void currentAccessTokenChanged() {\n        sendCurrentAccessTokenChangedBroadcastIntent(\n                this.currentAccessToken,\n                this.currentAccessToken);\n    }\n    private void sendCurrentAccessTokenChangedBroadcastIntent(AccessToken oldAccessToken,\n                                                               AccessToken currentAccessToken) {\n        Intent intent = new Intent(\n                FacebookSdk.getApplicationContext(),\n                CurrentAccessTokenExpirationBroadcastReceiver.class);\n        intent.setAction(ACTION_CURRENT_ACCESS_TOKEN_CHANGED);\n        intent.putExtra(EXTRA_OLD_ACCESS_TOKEN, oldAccessToken);\n        intent.putExtra(EXTRA_NEW_ACCESS_TOKEN, currentAccessToken);\n        localBroadcastManager.sendBroadcast(intent);\n    }\n    private void setTokenExpirationBroadcastAlarm() {\n        Context context = FacebookSdk.getApplicationContext();\n        AccessToken accessToken = AccessToken.getCurrentAccessToken();\n        AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);\n        if (!AccessToken.isCurrentAccessTokenActive()\n                || accessToken.getExpires() == null\n                || alarmManager == null) {\n            return;\n        }\n        Intent intent = new Intent(context, CurrentAccessTokenExpirationBroadcastReceiver.class);\n        intent.setAction(ACTION_CURRENT_ACCESS_TOKEN_CHANGED);\n        PendingIntent alarmIntent = PendingIntent.getBroadcast(context, 0, intent, 0);\n        alarmManager.set(\n                AlarmManager.RTC,\n                accessToken.getExpires().getTime(),\n                alarmIntent);\n    }\n    void extendAccessTokenIfNeeded() {\n        if (!shouldExtendAccessToken()) {\n            return;\n        }\n        refreshCurrentAccessToken(null);\n    }\n    private boolean shouldExtendAccessToken() {\n        if (currentAccessToken == null) {\n            return false;\n        }\n        Long now = new Date().getTime();\n        return currentAccessToken.getSource().canExtendToken()\n                && now - lastAttemptedTokenExtendDate.getTime() > TOKEN_EXTEND_RETRY_SECONDS * 1000\n                && now - currentAccessToken.getLastRefresh().getTime() >\n                    TOKEN_EXTEND_THRESHOLD_SECONDS * 1000;\n    }\n<fim_suffix>    private static GraphRequest createGrantedPermissionsRequest(\n            AccessToken accessToken,\n            GraphRequest.Callback callback\n    ) {\n        Bundle parameters = new Bundle();\n        return new GraphRequest(\n                accessToken,\n                ME_PERMISSIONS_GRAPH_PATH,\n                parameters,\n                HttpMethod.GET,\n                callback);\n    }\n    private static GraphRequest createExtendAccessTokenRequest(\n            AccessToken accessToken,\n            GraphRequest.Callback callback\n    ) {\n        Bundle parameters = new Bundle();\n        parameters.putString(\"grant_type\", \"fb_extend_sso_token\");\n        return new GraphRequest(\n                accessToken,\n                TOKEN_EXTEND_GRAPH_PATH,\n                parameters,\n                HttpMethod.GET,\n                callback);\n    }\n    private static class RefreshResult {\n        public String accessToken;\n        public int expiresAt;\n        public Long dataAccessExpirationTime;\n    }\n    void refreshCurrentAccessToken(final AccessToken.AccessTokenRefreshCallback callback) {\n        if (Looper.getMainLooper().equals(Looper.myLooper())) {\n            refreshCurrentAccessTokenImpl(callback);\n        } else {\n            Handler mainHandler = new Handler(Looper.getMainLooper());\n            mainHandler.post(new Runnable() {\n                @Override\n                public void run() {\n                    refreshCurrentAccessTokenImpl(callback);\n                }\n            });\n        }\n    }\n    private void refreshCurrentAccessTokenImpl(\n            final AccessToken.AccessTokenRefreshCallback callback) {\n        final AccessToken accessToken = currentAccessToken;\n        if (accessToken == null) {\n            if (callback != null) {\n                callback.OnTokenRefreshFailed(\n                        new FacebookException(\"No current access token to refresh\"));\n            }\n            return;\n        }\n        if (!tokenRefreshInProgress.compareAndSet(false, true)) {\n            if (callback != null) {\n                callback.OnTokenRefreshFailed(\n                        new FacebookException(\"Refresh already in progress\"));\n            }\n            return;\n        }\n        lastAttemptedTokenExtendDate = new Date();\n        final Set<String> permissions = new HashSet<>();\n        final Set<String> declinedPermissions = new HashSet<>();\n        final AtomicBoolean permissionsCallSucceeded = new AtomicBoolean(false);\n        final RefreshResult refreshResult = new RefreshResult();\n        GraphRequestBatch batch = new GraphRequestBatch(\n                createGrantedPermissionsRequest(accessToken, new GraphRequest.Callback() {\n                    @Override<fim_middle>// function below has no smell\n"}