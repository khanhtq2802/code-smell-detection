{"text": "<fim_prefix>\n<fim_suffix>public class JodaDateValidator {\n  public enum PostgresDateTimeConstant {\n    // patterns for replacing\n    POSTGRES_FULL_NAME_OF_DAY(true, \"day\"),\n    POSTGRES_DAY_OF_YEAR(false, \"ddd\"),\n    POSTGRES_DAY_OF_MONTH(false, \"dd\"),\n    POSTGRES_DAY_OF_WEEK(false, \"d\"),\n    POSTGRES_NAME_OF_MONTH(true, \"month\"),\n    POSTGRES_ABR_NAME_OF_MONTH(true, \"mon\"),\n    POSTGRES_YEAR(false, \"y\"),\n    POSTGRES_ISO_4YEAR(false, \"iyyy\"),\n    POSTGRES_ISO_3YEAR(false, \"iyy\"),\n    POSTGRES_ISO_2YEAR(false, \"iy\"),\n    POSTGRES_ISO_1YEAR(false, \"i\"),\n    POSTGRES_FULL_ERA_NAME(false, \"ee\"),\n    POSTGRES_NAME_OF_DAY(true, \"dy\"),\n    POSTGRES_HOUR_12_NAME(false, \"hh\"),\n    POSTGRES_HOUR_12_OTHER_NAME(false, \"hh12\"),\n    POSTGRES_HOUR_24_NAME(false, \"hh24\"),\n    POSTGRES_MINUTE_OF_HOUR_NAME(false, \"mi\"),\n    POSTGRES_SECOND_OF_MINUTE_NAME(false, \"ss\"),\n    POSTGRES_MILLISECOND_OF_MINUTE_NAME(false, \"ms\"),\n    POSTGRES_WEEK_OF_YEAR(false, \"ww\"),\n    POSTGRES_ISO_WEEK_OF_YEAR(false, \"iw\"),\n    POSTGRES_MONTH(false, \"mm\"),\n    POSTGRES_HALFDAY_AM(false, \"am\"),\n    POSTGRES_HALFDAY_PM(false, \"pm\"),\n    // pattern modifiers for deleting\n    PREFIX_FM(false, \"fm\"),\n    PREFIX_FX(false, \"fx\"),\n    PREFIX_TM(false, \"tm\");\n    private final boolean hasCamelCasing;\n    private final String name;\n    PostgresDateTimeConstant(boolean hasCamelCasing, String name) {\n      this.hasCamelCasing = hasCamelCasing;\n      this.name = name;\n    }\n    public boolean hasCamelCasing() {\n      return hasCamelCasing;\n    }\n    public String getName() {\n      return name;\n    }\n  }\n  private static final Map<PostgresDateTimeConstant, String> postgresToJodaMap = Maps.newTreeMap(new LengthDescComparator());\n  public static final String POSTGRES_ESCAPE_CHARACTER = \"\\\"\";\n  // jodaTime patterns\n  public static final String JODA_FULL_NAME_OF_DAY = \"EEEE\";\n  public static final String JODA_DAY_OF_YEAR = \"D\";\n  public static final String JODA_DAY_OF_MONTH = \"d\";\n  public static final String JODA_DAY_OF_WEEK = \"e\";\n  public static final String JODA_NAME_OF_MONTH = \"MMMM\";\n  public static final String JODA_ABR_NAME_OF_MONTH = \"MMM\";\n  public static final String JODA_YEAR = \"y\";\n  public static final String JODA_ISO_4YEAR = \"xxxx\";\n  public static final String JODA_ISO_3YEAR = \"xxx\";\n  public static final String JODA_ISO_2YEAR = \"xx\";\n  public static final String JODA_ISO_1YEAR = \"x\";\n  public static final String JODA_FULL_ERA_NAME = \"G\";\n  public static final String JODA_NAME_OF_DAY = \"E\";\n  public static final String JODA_HOUR_12_NAME = \"h\";\n  public static final String JODA_HOUR_24_NAME = \"H\";\n  public static final String JODA_MINUTE_OF_HOUR_NAME = \"m\";\n  public static final String JODA_SECOND_OF_MINUTE_NAME = \"ss\";\n  public static final String JODA_MILLISECOND_OF_MINUTE_NAME = \"SSS\";\n  public static final String JODA_WEEK_OF_YEAR = \"w\";\n  public static final String JODA_MONTH = \"MM\";\n  public static final String JODA_HALFDAY = \"aa\";\n  public static final String JODA_ESCAPE_CHARACTER = \"'\";\n  public static final String EMPTY_STRING = \"\";\n  static {\n    postgresToJodaMap.put(POSTGRES_FULL_NAME_OF_DAY, JODA_FULL_NAME_OF_DAY);\n    postgresToJodaMap.put(POSTGRES_DAY_OF_YEAR, JODA_DAY_OF_YEAR);\n    postgresToJodaMap.put(POSTGRES_DAY_OF_MONTH, JODA_DAY_OF_MONTH);\n    postgresToJodaMap.put(POSTGRES_DAY_OF_WEEK, JODA_DAY_OF_WEEK);\n    postgresToJodaMap.put(POSTGRES_NAME_OF_MONTH, JODA_NAME_OF_MONTH);\n    postgresToJodaMap.put(POSTGRES_ABR_NAME_OF_MONTH, JODA_ABR_NAME_OF_MONTH);\n    postgresToJodaMap.put(POSTGRES_FULL_ERA_NAME, JODA_FULL_ERA_NAME);\n    postgresToJodaMap.put(POSTGRES_NAME_OF_DAY, JODA_NAME_OF_DAY);\n    postgresToJodaMap.put(POSTGRES_HOUR_12_NAME, JODA_HOUR_12_NAME);\n    postgresToJodaMap.put(POSTGRES_HOUR_12_OTHER_NAME, JODA_HOUR_12_NAME);\n    postgresToJodaMap.put(POSTGRES_HOUR_24_NAME, JODA_HOUR_24_NAME);\n    postgresToJodaMap.put(POSTGRES_MINUTE_OF_HOUR_NAME, JODA_MINUTE_OF_HOUR_NAME);\n    postgresToJodaMap.put(POSTGRES_SECOND_OF_MINUTE_NAME, JODA_SECOND_OF_MINUTE_NAME);\n    postgresToJodaMap.put(POSTGRES_MILLISECOND_OF_MINUTE_NAME, JODA_MILLISECOND_OF_MINUTE_NAME);\n    postgresToJodaMap.put(POSTGRES_WEEK_OF_YEAR, JODA_WEEK_OF_YEAR);\n    postgresToJodaMap.put(POSTGRES_MONTH, JODA_MONTH);\n    postgresToJodaMap.put(POSTGRES_HALFDAY_AM, JODA_HALFDAY);\n    postgresToJodaMap.put(POSTGRES_HALFDAY_PM, JODA_HALFDAY);\n    postgresToJodaMap.put(POSTGRES_ISO_WEEK_OF_YEAR, JODA_WEEK_OF_YEAR);\n    postgresToJodaMap.put(POSTGRES_YEAR, JODA_YEAR);\n    postgresToJodaMap.put(POSTGRES_ISO_1YEAR, JODA_ISO_1YEAR);\n    postgresToJodaMap.put(POSTGRES_ISO_2YEAR, JODA_ISO_2YEAR);\n    postgresToJodaMap.put(POSTGRES_ISO_3YEAR, JODA_ISO_3YEAR);\n    postgresToJodaMap.put(POSTGRES_ISO_4YEAR, JODA_ISO_4YEAR);\n    postgresToJodaMap.put(PREFIX_FM, EMPTY_STRING);\n    postgresToJodaMap.put(PREFIX_FX, EMPTY_STRING);\n    postgresToJodaMap.put(PREFIX_TM, EMPTY_STRING);\n  }\n  /**\n   * Replaces all postgres patterns from {@param pattern},\n   * available in postgresToJodaMap keys to jodaTime equivalents.\n   *\n   * @param pattern date pattern in postgres format\n   * @return date pattern with replaced patterns in joda format\n   */\n  public static String toJodaFormat(String pattern) {\n    // replaces escape character for text delimiter\n    StringBuilder builder = new StringBuilder(pattern.replaceAll(POSTGRES_ESCAPE_CHARACTER, JODA_ESCAPE_CHARACTER));\n    int start = 0;    // every time search of postgres token in pattern will start from this index.\n    int minPos;       // min position of the longest postgres token\n    do {\n      // finds first value with max length\n      minPos = builder.length();\n      PostgresDateTimeConstant firstMatch = null;\n      for (PostgresDateTimeConstant postgresPattern : postgresToJodaMap.keySet()) {\n        // keys sorted in length decreasing\n        // at first search longer tokens to consider situation where some tokens are the parts of large tokens\n        // example: if pattern contains a token \"DDD\", token \"DD\" would be skipped, as a part of \"DDD\".\n        int pos;\n        // some tokens can't be in upper camel casing, so we ignore them here.\n        // example: DD, DDD, MM, etc.<fim_middle>// class below has no smell\n"}