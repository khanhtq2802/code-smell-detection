{"text": "<fim_prefix>    public static final class GetTempNode extends RNode {\n        private final FrameSlot slot;\n        private final RSyntaxNode arg;\n        GetTempNode(FrameSlot slot, RSyntaxNode arg) {\n            this.slot = slot;\n            this.arg = arg;\n        }\n        @Override\n        protected RSyntaxNode getRSyntaxNode() {\n            return arg;\n        }\n        @Override\n        public SourceSection getSourceSection() {\n            return arg.getSourceSection();\n        }\n        @Override\n        public Object execute(VirtualFrame frame) {\n            try {\n                return FrameSlotChangeMonitor.getObject(slot, frame);\n            } catch (FrameSlotTypeException e) {\n                throw RInternalError.shouldNotReachHere();\n            }\n        }\n    }\n    /**\n     * Dispatches a call to a function for given arguments.\n     */\n    @ImportStatic(DSLConfig.class)\n    public abstract static class FunctionDispatch extends Node {\n        /**\n         * Note: s3DefaultArguments is intended to carry default arguments from\n         * {@link RCallNode#callGroupGeneric} if the R dispatch method has some. Currently this is\n         * only the case for 'summary' group so this argument is either null or set to\n         * {@link RArguments#SUMMARY_GROUP_DEFAULT_VALUE_NA_RM}\n         */\n        public abstract Object execute(VirtualFrame frame, RFunction function, Object varArgs, Object s3Args, Object s3DefaultArguments);\n        protected static final int CACHE_SIZE = 4;\n        private final RCallNode originalCall;\n        private final AlteredArguments alteredArguments;\n        private final boolean explicitArgs;\n        private final FrameSlot tempFrameSlot;\n        public FunctionDispatch(RCallNode originalCall, AlteredArguments alteredArguments, boolean explicitArgs, FrameSlot tempFrameSlot) {\n            this.originalCall = originalCall;\n            this.explicitArgs = explicitArgs;\n            this.tempFrameSlot = tempFrameSlot;\n            this.alteredArguments = alteredArguments;\n        }\n        public FunctionDispatch(RCallNode originalCall, boolean explicitArgs, FrameSlot tempFrameSlot) {\n            this(originalCall, null, explicitArgs, tempFrameSlot);\n        }\n        protected LeafCallFunctionNode createCacheNode(RootCallTarget cachedTarget) {\n            CompilerAsserts.neverPartOfCompilation();\n            RRootNode root = (RRootNode) cachedTarget.getRootNode();\n            FormalArguments formals = root.getFormalArguments();\n            if (root instanceof RBuiltinRootNode) {\n                RBuiltinRootNode builtinRoot = (RBuiltinRootNode) root;\n                return new BuiltinCallNode(RBuiltinNode.inline(builtinRoot.getBuiltin()), builtinRoot.getBuiltin(), formals, originalCall, explicitArgs);\n            } else {\n                return new DispatchedCallNode(cachedTarget, originalCall);\n            }\n        }\n        protected PrepareArguments createArguments(RootCallTarget cachedTarget, boolean noOpt) {\n            RRootNode root = (RRootNode) cachedTarget.getRootNode();\n            if (explicitArgs) {\n                return PrepareArguments.createExplicit(root);\n            } else {\n                CallArgumentsNode args = originalCall.createArguments(tempFrameSlot, root.getBuiltin() == null, true, alteredArguments);\n                return PrepareArguments.create(root, args, noOpt);\n            }\n        }\n        protected PrepareArguments createArguments(RootCallTarget cachedTarget) {\n            return createArguments(cachedTarget, false);\n        }\n        @Specialization(limit = \"getCacheSize(CACHE_SIZE)\", guards = \"function.getTarget() == cachedTarget\")\n        protected Object dispatch(VirtualFrame frame, RFunction function, Object varArgs, Object s3Args, Object s3DefaultArguments,\n                        @Cached(\"function.getTarget()\") @SuppressWarnings(\"unused\") RootCallTarget cachedTarget,\n                        @Cached(\"createCacheNode(cachedTarget)\") LeafCallFunctionNode leafCall,\n                        @Cached(\"createArguments(cachedTarget)\") PrepareArguments prepareArguments) {\n            RArgsValuesAndNames orderedArguments = prepareArguments.execute(frame, (RArgsValuesAndNames) varArgs, (S3DefaultArguments) s3DefaultArguments, originalCall);\n            return leafCall.execute(frame, function, orderedArguments, (S3Args) s3Args);\n        }\n        private static final class GenericCallEntry extends Node {\n            private final RootCallTarget cachedTarget;\n            @Child private LeafCallFunctionNode leafCall;\n            @Child private PrepareArguments prepareArguments;\n            GenericCallEntry(RootCallTarget cachedTarget, LeafCallFunctionNode leafCall, PrepareArguments prepareArguments) {\n                this.cachedTarget = cachedTarget;\n                this.leafCall = leafCall;\n                this.prepareArguments = prepareArguments;\n            }\n        }\n        /*\n         * Use a TruffleBoundaryNode to be able to switch child nodes without invalidating the whole\n         * method.\n         */\n        protected final class GenericCall extends TruffleBoundaryNode {\n            @Child private GenericCallEntry entry;\n            @TruffleBoundary\n            public Object execute(MaterializedFrame materializedFrame, RFunction function, Object varArgs, Object s3Args, Object s3DefaultArguments) {\n                GenericCallEntry e = entry;\n                RootCallTarget cachedTarget = function.getTarget();\n                if (e == null || e.cachedTarget != cachedTarget) {\n                    entry = e = insert(new GenericCallEntry(cachedTarget, createCacheNode(cachedTarget), createArguments(cachedTarget)));\n                }\n                RArgsValuesAndNames orderedArguments = e.prepareArguments.execute(materializedFrame, (RArgsValuesAndNames) varArgs, (S3DefaultArguments) s3DefaultArguments, originalCall);\n                return e.leafCall.execute(materializedFrame, function, orderedArguments, (S3Args) s3Args);\n            }\n        }\n        protected GenericCall createGenericCall() {\n            return new GenericCall();\n        }\n        @Specialization\n        protected Object dispatchFallback(VirtualFrame frame, RFunction function, Object varArgs, Object s3Args, Object s3DefaultArguments,\n                        @Cached(\"createGenericCall()\") GenericCall generic) {\n            return generic.execute(frame.materialize(), function, varArgs, s3Args, s3DefaultArguments);\n        }\n    }\n    public abstract static class LeafCallNode extends RBaseNode {\n        /**\n         * The original {@link RSyntaxNode} this derives from.\n         */\n        protected final RCallNode originalCall;\n        private LeafCallNode(RCallNode originalCall) {\n            this.originalCall = originalCall;\n        }\n        @Override\n        public RSyntaxNode getRSyntaxNode() {\n            return originalCall;\n        }\n    }\n    public abstract static class LeafCallFunctionNode extends LeafCallNode {\n        protected LeafCallFunctionNode(RCallNode originalCall) {\n            super(originalCall);\n        }\n        public abstract Object execute(VirtualFrame frame, RFunction currentFunction, RArgsValuesAndNames orderedArguments, S3Args s3Args);\n    }\n    /**\n     * It executes a builtin node using its call method (not the execute), which casts the\n     * arguments. Potential argument promises are evaluated before the execution.\n     *\n     * NB: The arguments are not cast here, but in the builtin.\n     */\n    @NodeInfo(cost = NodeCost.NONE)\n    public static final class BuiltinCallNode extends LeafCallFunctionNode {\n        @Child private RBuiltinNode builtin;\n        /**\n         * Evaluates potential promises in varArgs.\n         */\n        @Child private PromiseCheckHelperNode varArgsPromiseHelper;\n        /**\n         * Evaluates arg promises.\n         */\n        @Children private final PromiseHelperNode[] promiseHelpers;\n        @Child private SetVisibilityNode visibility = SetVisibilityNode.create();\n        // not using profiles to save overhead\n        @CompilationFinal(dimensions = 1) private final boolean[] argEmptySeen;\n        @CompilationFinal(dimensions = 1) private final boolean[] varArgSeen;\n        @CompilationFinal(dimensions = 1) private final boolean[] nonWrapSeen;\n        @CompilationFinal(dimensions = 1) private final boolean[] wrapSeen;\n        private final FormalArguments formals;\n        private final RBuiltinDescriptor builtinDescriptor;\n        private final boolean explicitArgs;\n        public BuiltinCallNode(RBuiltinNode builtin, RBuiltinDescriptor builtinDescriptor, FormalArguments formalArguments, RCallNode originalCall, boolean explicitArgs) {\n            super(originalCall);\n            this.builtin = builtin;\n            this.builtinDescriptor = builtinDescriptor;\n            this.explicitArgs = explicitArgs;\n            this.formals = formalArguments;\n            promiseHelpers = new PromiseHelperNode[formals.getLength()];\n            argEmptySeen = new boolean[formals.getLength()];\n            varArgSeen = new boolean[formals.getLength()];\n            nonWrapSeen = new boolean[formals.getLength()];\n            wrapSeen = new boolean[formals.getLength()];\n        }\n        @Override\n        public RBaseNode getErrorContext() {\n            return builtin.getErrorContext();\n        }\n<fim_suffix>        public RBuiltinNode getBuiltin() {\n            return builtin;\n        }<fim_middle>// function below has no smell\n"}