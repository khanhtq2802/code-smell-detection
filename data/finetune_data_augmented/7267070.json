{"text": "<fim_prefix>/*\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n *\n * Copyright 2012 Oracle and/or its affiliates. All rights reserved.\n *\n * Oracle and Java are registered trademarks of Oracle and/or its affiliates.\n * Other names may be trademarks of their respective owners.\n *\n * The contents of this file are subject to the terms of either the GNU\n * General Public License Version 2 only (\"GPL\") or the Common\n * Development and Distribution License(\"CDDL\") (collectively, the\n * \"License\"). You may not use this file except in compliance with the\n * License. You can obtain a copy of the License at\n * http://www.netbeans.org/cddl-gplv2.html\n * or nbbuild/licenses/CDDL-GPL-2-CP. See the License for the\n * specific language governing permissions and limitations under the\n * License.  When distributing the software, include this License Header\n * Notice in each file and include the License file at\n * nbbuild/licenses/CDDL-GPL-2-CP.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the GPL Version 2 section of the License file that\n * accompanied this code. If applicable, add the following below the\n * License Header, with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * If you wish your version of this file to be governed by only the CDDL\n * or only the GPL Version 2, indicate your decision by adding\n * \"[Contributor] elects to include this software in this distribution\n * under the [CDDL or GPL Version 2] license.\" If you do not indicate a\n * single choice of license, a recipient has the option to distribute\n * your version of this file under either the CDDL, the GPL Version 2 or\n * to extend the choice of license to its licensees as provided above.\n * However, if you add GPL Version 2 code and therefore, elected the GPL\n * Version 2 license, then the option applies only if the new code is\n * made subject to such option by the copyright holder.\n *\n * Contributor(s):\n *\n * Portions Copyrighted 2012 Sun Microsystems, Inc.\n */\npackage org.graalvm.visualvm.lib.profiler.api.java;\nimport java.io.IOException;\nimport java.lang.reflect.Modifier;\nimport java.util.*;\nimport org.graalvm.visualvm.lib.jfluid.classfile.ClassFileParser;\nimport org.graalvm.visualvm.lib.jfluid.classfile.ClassInfo;\nimport org.openide.filesystems.FileObject;\nimport org.openide.filesystems.FileUtil;\n/**\n *\n * @author Jaroslv Bachorik\n */\nfinal public class ExternalPackages {\n    private static final Comparator<FileObject> pathComparator = new Comparator<FileObject>() {\n        @Override\n        public int compare(FileObject o1, FileObject o2) {\n            return o1.getPath().compareTo(o2.getPath());\n        }\n    };\n    private static class FilePackageInfo extends SourcePackageInfo {\n        private FileObject root;\n        private FileObject pkg;\n        private Set<String> pkgsContent;\n        public FilePackageInfo(FileObject root, FileObject pkg, Set<String> pkgsContent) {\n            super(FileUtil.getRelativePath(root, pkg), FileUtil.getRelativePath(root, pkg).replace('/', '.'), SourcePackageInfo.Scope.SOURCE); // NOI18N\n            this.pkg = pkg;\n            this.root = root;\n            this.pkgsContent = pkgsContent;\n        }\n        @Override\n        public Collection<SourceClassInfo> getClasses() {\n            Set<FileObject> clzs = new TreeSet(pathComparator);\n            Enumeration<? extends FileObject> e = pkg.getData(false);\n            while (e.hasMoreElements()) {\n                FileObject clz = e.nextElement();\n                if (clz.getExt().equalsIgnoreCase(\"class\")) { // NOI18N\n                    clzs.add(clz);\n                }\n            }\n            ClassFileParser cfp = new ClassFileParser();\n            Collection<SourceClassInfo> rslt = new ArrayList<SourceClassInfo>();\n            for(final FileObject p : clzs) {\n                if (p.getName().contains(\"$\")) { // NOI18N\n                    continue; // skipping inner classes\n                }\n                ClassInfo ci = new ClassInfo(p.getName(), 0) {\n                    @Override\n                    protected byte[] getClassFileBytes() throws IOException, ClassNotFoundException {\n                        return p.asBytes();\n                    }\n                };\n                try {\n                    cfp.parseClassFile(p.asBytes(), ci);\n                    rslt.add(new FileClassInfo(ci, root, p));\n                } catch (IOException ex) {\n                } catch (ClassFileParser.ClassFileReadException ex) {\n                }\n            }\n            return rslt;\n        }\n<fim_suffix>        boolean hasClasses() {\n            Enumeration<? extends FileObject> e = pkg.getData(false);\n            while (e.hasMoreElements())\n                if (e.nextElement().getExt().equalsIgnoreCase(\"class\")) // NOI18N\n                    return true;\n            return false;\n        }\n        @Override\n        public Collection<SourcePackageInfo> getSubpackages() {\n            Set<FileObject> pkgs = new TreeSet(pathComparator);\n            Enumeration<? extends FileObject> e = pkg.getFolders(false);\n            while (e.hasMoreElements()) {\n                pkgs.add(e.nextElement());\n            }\n            Collection<SourcePackageInfo> rslt = new ArrayList<SourcePackageInfo>();\n            for(FileObject p : pkgs) {\n                if (pkgsContent.contains(p.getPath())) {\n                    rslt.add(new FilePackageInfo(root, p, pkgsContent));\n                }\n            }\n            return rslt;\n        }   \n    }\n    private static class FileClassInfo extends SourceClassInfo {\n        private FileObject root, clazz;\n        private ClassInfo ci;\n        public FileClassInfo(ClassInfo ci, FileObject root, FileObject clazz) {\n            super(clazz.getName(), FileUtil.getRelativePath(root, clazz).replace('/', '.').replace(\".class\", \"\"), FileUtil.getRelativePath(root, clazz).replace(\".class\", \"\")); // NOI18N\n            this.ci = ci;\n            this.clazz = clazz;\n            this.root = root;\n        }\n        @Override\n        public Set<SourceMethodInfo> getConstructors() {\n            String[] names = ci.getMethodNames();\n            Set<SourceMethodInfo> cts = new HashSet<SourceMethodInfo>();\n            if (names != null) {\n                for(int i=0;i<names.length;i++) {\n                    if (names[i].equals(\"<init>\")) { // NOI18N\n                        cts.add(new FileMethodInfo(ci, i));\n                    }\n                }\n            }\n            return cts;\n        }\n        @Override\n        public FileObject getFile() {\n            return clazz;\n        }\n        @Override\n        public Set<SourceClassInfo> getInnerClases() {\n            Set<SourceClassInfo> rslt = new HashSet<SourceClassInfo>();\n            ClassFileParser cfp = new ClassFileParser();\n            Enumeration<? extends FileObject> siblings = clazz.getParent().getData(false);\n            while (siblings.hasMoreElements()) {\n                final FileObject sibling = siblings.nextElement();\n                if (sibling.getName().contains(\"$\") && sibling.getName().startsWith(clazz.getName()) && !sibling.getName().equals(clazz.getName())) { // NOI18N\n                    ClassInfo ci = new ClassInfo(sibling.getName(), 0) {\n                        @Override\n                        protected byte[] getClassFileBytes() throws IOException, ClassNotFoundException {\n                            return sibling.asBytes();\n                        }\n                    };\n                    try {\n                        cfp.parseClassFile(sibling.asBytes(), ci);\n                        rslt.add(new FileClassInfo(ci, root, sibling));\n                    } catch (IOException ex) {\n                    } catch (ClassFileParser.ClassFileReadException ex) {\n                    }\n                }\n            }\n            return rslt;\n        }\n        @Override\n        public Set<SourceClassInfo> getInterfaces() {\n            Set<SourceClassInfo> ifcs = new HashSet<SourceClassInfo>();\n            String[] iNames = ci.getInterfaceNames();\n            if (iNames != null) {\n                for(String name : iNames) {\n                    ifcs.add(new PlainClassInfo(name));\n                }\n            }\n            return ifcs;\n        }\n        @Override\n        public Set<SourceMethodInfo> getMethods(boolean all) {\n            String[] names = ci.getMethodNames();\n            Set<SourceMethodInfo> cts = new HashSet<SourceMethodInfo>();\n            if (names != null) {\n                for(int i=0;i<names.length;i++) {\n                    if (!names[i].equals(\"<init>\")) { // NOI18N\n                        cts.add(new FileMethodInfo(ci, i));\n                    }\n                }\n            }\n            return cts;\n        }\n        @Override\n        public Set<SourceClassInfo> getSubclasses() {\n            return Collections.EMPTY_SET;\n        }\n        @Override\n        public SourceClassInfo getSuperType() {<fim_middle>// function below has no smell\n"}