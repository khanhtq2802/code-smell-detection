{"text": "<fim_prefix>/*\n * Copyright (c) 2018 Goldman Sachs.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * and Eclipse Distribution License v. 1.0 which accompany this distribution.\n * The Eclipse Public License is available at http://www.eclipse.org/legal/epl-v10.html\n * and the Eclipse Distribution License is available at\n * http://www.eclipse.org/org/documents/edl-v10.php.\n */\n\npackage org.eclipse.collections.impl.utility;\n\nimport org.eclipse.collections.api.LazyIterable;\nimport org.eclipse.collections.api.RichIterable;\nimport org.eclipse.collections.api.block.function.Function;\nimport org.eclipse.collections.api.block.function.Function2;\nimport org.eclipse.collections.api.block.predicate.Predicate;\nimport org.eclipse.collections.api.block.procedure.Procedure;\nimport org.eclipse.collections.api.tuple.Pair;\nimport org.eclipse.collections.impl.factory.Lists;\nimport org.eclipse.collections.impl.lazy.ChunkIterable;\nimport org.eclipse.collections.impl.lazy.CollectIterable;\nimport org.eclipse.collections.impl.lazy.CompositeIterable;\nimport org.eclipse.collections.impl.lazy.DistinctIterable;\nimport org.eclipse.collections.impl.lazy.DropIterable;\nimport org.eclipse.collections.impl.lazy.DropWhileIterable;\nimport org.eclipse.collections.impl.lazy.FlatCollectIterable;\nimport org.eclipse.collections.impl.lazy.LazyIterableAdapter;\nimport org.eclipse.collections.impl.lazy.RejectIterable;\nimport org.eclipse.collections.impl.lazy.SelectInstancesOfIterable;\nimport org.eclipse.collections.impl.lazy.SelectIterable;\nimport org.eclipse.collections.impl.lazy.TakeIterable;\nimport org.eclipse.collections.impl.lazy.TakeWhileIterable;\nimport org.eclipse.collections.impl.lazy.TapIterable;\nimport org.eclipse.collections.impl.lazy.ZipIterable;\nimport org.eclipse.collections.impl.lazy.ZipWithIndexIterable;\nimport org.eclipse.collections.impl.tuple.Tuples;\n\n/**\n * LazyIterate is a factory class which creates \"deferred\" iterables around the specified iterables. A \"deferred\"\n * iterable performs some operation, such as filtering or transforming, when the result iterable is iterated over. This\n * makes the operation very memory efficient, because you don't have to create intermediate collections during the\n * operation.\n *\n * @since 1.0\n */\n<fim_suffix>public final class LazyIterate\n{\n    private static final LazyIterable<?> EMPTY_ITERABLE = Lists.immutable.empty().asLazy();\n\n    private LazyIterate()\n    {\n        throw new AssertionError(\"Suppress default constructor for noninstantiability\");\n    }\n\n    /**\n     * Creates a deferred rich iterable for the specified iterable.\n     */\n    public static <T> LazyIterable<T> adapt(Iterable<T> iterable)\n    {\n        return new LazyIterableAdapter<>(iterable);\n    }\n\n    /**\n     * Creates a deferred filtering iterable for the specified iterable.\n     */\n    public static <T> LazyIterable<T> select(Iterable<T> iterable, Predicate<? super T> predicate)\n    {\n        return new SelectIterable<>(iterable, predicate);\n    }\n\n    /**\n     * Creates a deferred negative filtering iterable for the specified iterable.\n     */\n    public static <T> LazyIterable<T> reject(Iterable<T> iterable, Predicate<? super T> predicate)\n    {\n        return new RejectIterable<>(iterable, predicate);\n    }\n\n    public static <T> LazyIterable<T> selectInstancesOf(Iterable<?> iterable, Class<T> clazz)\n    {\n        return new SelectInstancesOfIterable<>(iterable, clazz);\n    }\n\n    /**\n     * Creates a deferred transforming iterable for the specified iterable.\n     */\n    public static <T, V> LazyIterable<V> collect(\n            Iterable<T> iterable,\n            Function<? super T, ? extends V> function)\n    {\n        return new CollectIterable<>(iterable, function);\n    }\n\n    /**\n     * Creates a deferred flattening iterable for the specified iterable.\n     */\n    public static <T, V> LazyIterable<V> flatCollect(\n            Iterable<T> iterable,\n            Function<? super T, ? extends Iterable<V>> function)\n    {\n        return new FlatCollectIterable<>(iterable, function);\n    }\n\n    /**\n     * Creates a deferred filtering and transforming iterable for the specified iterable.\n     */\n    public static <T, V> LazyIterable<V> collectIf(\n            Iterable<T> iterable,\n            Predicate<? super T> predicate,\n            Function<? super T, ? extends V> function)\n    {\n        return LazyIterate.select(iterable, predicate).collect(function);\n    }\n\n    /**\n     * Creates a deferred take iterable for the specified iterable using the specified count as the limit.\n     */\n    public static <T> LazyIterable<T> take(Iterable<T> iterable, int count)\n    {\n        return new TakeIterable<>(iterable, count);\n    }\n\n    /**\n     * Creates a deferred drop iterable for the specified iterable using the specified count as the size to drop.\n     */\n    public static <T> LazyIterable<T> drop(Iterable<T> iterable, int count)\n    {\n        return new DropIterable<>(iterable, count);\n    }\n\n    /**\n     * Creates a deferred takeWhile iterable for the specified iterable using the specified predicate.\n     * Short circuits at the first element which does not satisfy the Predicate.\n     *\n     * @since 8.0\n     */\n    public static <T> LazyIterable<T> takeWhile(Iterable<T> iterable, Predicate<? super T> predicate)\n    {\n        return new TakeWhileIterable<>(iterable, predicate);\n    }\n\n    /**\n     * Creates a deferred dropWhile iterable for the specified iterable using the specified count as the size to drop.\n     * Short circuits at the first element which satisfies the Predicate.\n     *\n     * @since 8.0\n     */\n    public static <T> LazyIterable<T> dropWhile(Iterable<T> iterable, Predicate<? super T> predicate)\n    {\n        return new DropWhileIterable<>(iterable, predicate);\n    }\n\n    /**\n     * Creates a deferred distinct iterable for the specified iterable.\n     *\n     * @since 5.0\n     */\n    public static <T> LazyIterable<T> distinct(Iterable<T> iterable)\n    {\n        return new DistinctIterable<>(iterable);\n    }\n\n    /**\n     * Combines iterables into a deferred composite iterable.\n     */\n    public static <T> LazyIterable<T> concatenate(Iterable<T>... iterables)\n    {\n        return CompositeIterable.with(iterables);\n    }\n\n    public static <T> LazyIterable<T> empty()\n    {\n        return (LazyIterable<T>) EMPTY_ITERABLE;\n    }\n\n    public static <A, B> LazyIterable<Pair<A, B>> zip(Iterable<A> as, Iterable<B> bs)\n    {\n        return new ZipIterable<>(as, bs);\n    }\n\n    public static <T> LazyIterable<Pair<T, Integer>> zipWithIndex(Iterable<T> iterable)\n    {\n        return new ZipWithIndexIterable<>(iterable);\n    }\n\n    public static <T> LazyIterable<RichIterable<T>> chunk(Iterable<T> iterable, int size)\n    {\n        return new ChunkIterable<>(iterable, size);\n    }\n\n    /**\n     * Creates a deferred tap iterable for the specified iterable.\n     *\n     * @since 6.0\n     */\n    public static <T> LazyIterable<T> tap(Iterable<T> iterable, Procedure<? super T> procedure)\n    {\n        return new TapIterable<>(iterable, procedure);\n    }\n\n    /**\n     * Create a deferred cartesian product of the two specified iterables.\n     *\n     * See {@link LazyIterate#cartesianProduct(Iterable, Iterable, Function2)} about performance and presence of duplicates.\n     *\n     * @since 10.0\n     */\n    public static <A, B> LazyIterable<Pair<A, B>> cartesianProduct(Iterable<A> iterable1, Iterable<B> iterable2)\n    {\n        return LazyIterate.cartesianProduct(iterable1, iterable2, Tuples::pair);\n    }\n\n    /**\n     * Create a deferred cartesian product of the two specified iterables.\n     *\n     * This operation has O(n^2) performance.\n     *\n     * The presence of duplicates in the resulting iterable is both dependent on the\n     * presence of duplicates in the two specified iterables, and on the behaviour\n     * of the terminating operation that is applied to the resulting lazy iterable.\n     *\n     * @since 10.0\n     */\n    public static <A, B, C> LazyIterable<C> cartesianProduct(Iterable<A> iterable1, Iterable<B> iterable2, Function2<? super A, ? super B, ? extends C> function)\n    {\n        return LazyIterate.flatCollect(iterable1, first -> LazyIterate.collect(iterable2, second -> function.value(first, second)));\n    }\n}<fim_middle>// class below has no smell\n"}