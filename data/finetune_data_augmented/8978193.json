{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.lucene.search;\n\n\nimport java.io.IOException;\n\n/**\n * This abstract class defines methods to iterate over a set of non-decreasing\n * doc ids. Note that this class assumes it iterates on doc Ids, and therefore\n * {@link #NO_MORE_DOCS} is set to {@value #NO_MORE_DOCS} in order to be used as\n * a sentinel object. Implementations of this class are expected to consider\n * {@link Integer#MAX_VALUE} as an invalid value.\n */\n<fim_suffix>public abstract class DocIdSetIterator {\n  \n  /** An empty {@code DocIdSetIterator} instance */\n  public static final DocIdSetIterator empty() {\n    return new DocIdSetIterator() {\n      boolean exhausted = false;\n      \n      @Override\n      public int advance(int target) {\n        assert !exhausted;\n        assert target >= 0;\n        exhausted = true;\n        return NO_MORE_DOCS;\n      }\n      \n      @Override\n      public int docID() {\n        return exhausted ? NO_MORE_DOCS : -1;\n      }\n      @Override\n      public int nextDoc() {\n        assert !exhausted;\n        exhausted = true;\n        return NO_MORE_DOCS;\n      }\n      \n      @Override\n      public long cost() {\n        return 0;\n      }\n    };\n  }\n\n  /** A {@link DocIdSetIterator} that matches all documents up to\n   *  {@code maxDoc - 1}. */\n  public static final DocIdSetIterator all(int maxDoc) {\n    return new DocIdSetIterator() {\n      int doc = -1;\n\n      @Override\n      public int docID() {\n        return doc;\n      }\n\n      @Override\n      public int nextDoc() throws IOException {\n        return advance(doc + 1);\n      }\n\n      @Override\n      public int advance(int target) throws IOException {\n        doc = target;\n        if (doc >= maxDoc) {\n          doc = NO_MORE_DOCS;\n        }\n        return doc;\n      }\n\n      @Override\n      public long cost() {\n        return maxDoc;\n      }\n    };\n  }\n\n  /** A {@link DocIdSetIterator} that matches a range documents from\n   *  minDocID (inclusive) to maxDocID (exclusive). */\n  public static final DocIdSetIterator range(int minDoc, int maxDoc) {\n    if (minDoc >= maxDoc) {\n        throw new IllegalArgumentException(\"minDoc must be < maxDoc but got minDoc=\" + minDoc + \" maxDoc=\" + maxDoc);\n    }\n    if (minDoc < 0) {\n      throw new IllegalArgumentException(\"minDoc must be >= 0 but got minDoc=\" + minDoc);\n    }\n    return new DocIdSetIterator() {\n      private int doc = -1;\n\n      @Override\n      public int docID() {\n        return doc;\n      }\n\n      @Override\n      public int nextDoc() throws IOException {\n        return advance(doc + 1);\n      }\n\n      @Override\n      public int advance(int target) throws IOException {\n        if (target < minDoc) {\n            doc = minDoc;\n        } else if (target >= maxDoc) {\n            doc = NO_MORE_DOCS;\n        } else {\n            doc = target;\n        }\n        return doc;\n      }\n\n      @Override\n      public long cost() {\n        return maxDoc - minDoc;\n      }\n    };\n  }\n\n  /**\n   * When returned by {@link #nextDoc()}, {@link #advance(int)} and\n   * {@link #docID()} it means there are no more docs in the iterator.\n   */\n  public static final int NO_MORE_DOCS = Integer.MAX_VALUE;\n\n  /**\n   * Returns the following:\n   * <ul>\n   * <li><code>-1</code> if {@link #nextDoc()} or\n   * {@link #advance(int)} were not called yet.\n   * <li>{@link #NO_MORE_DOCS} if the iterator has exhausted.\n   * <li>Otherwise it should return the doc ID it is currently on.\n   * </ul>\n   * <p>\n   * \n   * @since 2.9\n   */\n  public abstract int docID();\n\n  /**\n   * Advances to the next document in the set and returns the doc it is\n   * currently on, or {@link #NO_MORE_DOCS} if there are no more docs in the\n   * set.<br>\n   * \n   * <b>NOTE:</b> after the iterator has exhausted you should not call this\n   * method, as it may result in unpredicted behavior.\n   * \n   * @since 2.9\n   */\n  public abstract int nextDoc() throws IOException;\n\n /**\n   * Advances to the first beyond the current whose document number is greater \n   * than or equal to <i>target</i>, and returns the document number itself. \n   * Exhausts the iterator and returns {@link #NO_MORE_DOCS} if <i>target</i> \n   * is greater than the highest document number in the set.\n   * <p>\n   * The behavior of this method is <b>undefined</b> when called with\n   * <code> target &le; current</code>, or after the iterator has exhausted.\n   * Both cases may result in unpredicted behavior.\n   * <p>\n   * When <code> target &gt; current</code> it behaves as if written:\n   * \n   * <pre class=\"prettyprint\">\n   * int advance(int target) {\n   *   int doc;\n   *   while ((doc = nextDoc()) &lt; target) {\n   *   }\n   *   return doc;\n   * }\n   * </pre>\n   * \n   * Some implementations are considerably more efficient than that.\n   * <p>\n   * <b>NOTE:</b> this method may be called with {@link #NO_MORE_DOCS} for\n   * efficiency by some Scorers. If your implementation cannot efficiently\n   * determine that it should exhaust, it is recommended that you check for that\n   * value in each call to this method.\n   * <p>\n   *\n   * @since 2.9\n   */\n  public abstract int advance(int target) throws IOException;\n\n  /** Slow (linear) implementation of {@link #advance} relying on\n   *  {@link #nextDoc()} to advance beyond the target position. */\n  protected final int slowAdvance(int target) throws IOException {\n    assert docID() < target;\n    int doc;\n    do {\n      doc = nextDoc();\n    } while (doc < target);\n    return doc;\n  }\n\n  /**\n   * Returns the estimated cost of this {@link DocIdSetIterator}.\n   * <p>\n   * This is generally an upper bound of the number of documents this iterator\n   * might match, but may be a rough heuristic, hardcoded value, or otherwise\n   * completely inaccurate.\n   */\n  public abstract long cost();\n  \n}<fim_middle>// class below is blob\n"}