{"text": "<fim_prefix>/*\n * Copyright (c) 2015, 2017, Oracle and/or its affiliates. All rights reserved.\n */\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/*\n * $Id: DocumentCache.java,v 1.2.4.1 2005/09/06 06:15:22 pvedula Exp $\n */\npackage com.sun.org.apache.xalan.internal.xsltc.dom;\nimport com.sun.org.apache.xalan.internal.xsltc.DOM;\nimport com.sun.org.apache.xalan.internal.xsltc.DOMCache;\nimport com.sun.org.apache.xalan.internal.xsltc.DOMEnhancedForDTM;\nimport com.sun.org.apache.xalan.internal.xsltc.Translet;\nimport com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;\nimport com.sun.org.apache.xalan.internal.xsltc.runtime.BasisLibrary;\nimport com.sun.org.apache.xalan.internal.xsltc.runtime.Constants;\nimport com.sun.org.apache.xml.internal.utils.SystemIDResolver;\nimport java.io.File;\nimport java.io.PrintWriter;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.nio.file.Paths;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Map;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.sax.SAXSource;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.XMLReader;\n/**\n * @author Morten Jorgensen\n */\npublic final class DocumentCache implements DOMCache {\n    private int       _size;\n    private Map<String, CachedDocument> _references;\n    private String[]  _URIs;\n    private int       _count;\n    private int       _current;\n    private SAXParser _parser;\n    private XMLReader _reader;\n    private XSLTCDTMManager _dtmManager;\n    private static final int REFRESH_INTERVAL = 1000;\n    /*\n     * Inner class containing a DOMImpl object and DTD handler\n     */\n    public final class CachedDocument {\n        // Statistics data\n        private long _firstReferenced;\n        private long _lastReferenced;\n        private long _accessCount;\n        private long _lastModified;\n        private long _lastChecked;\n        private long _buildTime;\n        // DOM and DTD handler references\n        private DOMEnhancedForDTM _dom = null;\n        /**\n         * Constructor - load document and initialise statistics\n         */\n        public CachedDocument(String uri) {\n            // Initialise statistics variables\n            final long stamp = System.currentTimeMillis();\n            _firstReferenced = stamp;\n            _lastReferenced  = stamp;\n            _accessCount     = 0;\n            loadDocument(uri);\n            _buildTime = System.currentTimeMillis() - stamp;\n        }\n        /**\n         * Loads the document and updates build-time (latency) statistics\n         */\n        public void loadDocument(String uri) {\n            try {\n                final long stamp = System.currentTimeMillis();\n                _dom = (DOMEnhancedForDTM)_dtmManager.getDTM(\n                                 new SAXSource(_reader, new InputSource(uri)),\n                                 false, null, true, false);\n                _dom.setDocumentURI(uri);\n                // The build time can be used for statistics for a better\n                // priority algorithm (currently round robin).\n                final long thisTime = System.currentTimeMillis() - stamp;\n                if (_buildTime > 0)\n                    _buildTime = (_buildTime + thisTime) >>> 1;\n                else\n                    _buildTime = thisTime;\n            }\n            catch (Exception e) {\n                _dom = null;\n            }\n        }\n        public DOM getDocument()       { return(_dom); }\n        public long getFirstReferenced()   { return(_firstReferenced); }\n        public long getLastReferenced()    { return(_lastReferenced); }\n        public long getAccessCount()       { return(_accessCount); }\n        public void incAccessCount()       { _accessCount++; }\n        public long getLastModified()      { return(_lastModified); }\n        public void setLastModified(long t){ _lastModified = t; }\n        public long getLatency()           { return(_buildTime); }\n        public long getLastChecked()       { return(_lastChecked); }\n        public void setLastChecked(long t) { _lastChecked = t; }\n        public long getEstimatedSize() {\n            if (_dom != null)\n                return(_dom.getSize() << 5); // ???\n            else\n                return(0);\n        }\n    }\n    /**\n     * DocumentCache constructor\n     */\n<fim_suffix>    public DocumentCache(int size) throws SAXException {\n        this(size, null);\n        try {\n            _dtmManager = XSLTCDTMManager.createNewDTMManagerInstance();\n        } catch (Exception e) {\n            throw new SAXException(e);\n        }\n    }\n    /**\n     * DocumentCache constructor\n     */\n    public DocumentCache(int size, XSLTCDTMManager dtmManager) throws SAXException {\n        _dtmManager = dtmManager;\n        _count = 0;\n        _current = 0;\n        _size  = size;\n        _references = new HashMap<>(_size+2);\n        _URIs = new String[_size];\n        try {\n            // Create a SAX parser and get the XMLReader object it uses\n            final SAXParserFactory factory = SAXParserFactory.newInstance();\n            try {\n                factory.setFeature(Constants.NAMESPACE_FEATURE,true);\n            }\n            catch (Exception e) {\n                factory.setNamespaceAware(true);\n            }\n            _parser = factory.newSAXParser();\n            _reader = _parser.getXMLReader();\n        }\n        catch (ParserConfigurationException e) {\n            BasisLibrary.runTimeError(BasisLibrary.NAMESPACES_SUPPORT_ERR);\n        }\n    }\n    /**\n     * Returns the time-stamp for a document's last update\n     */\n    private final long getLastModified(String uri) {\n        try {\n            URL url = new URL(uri);\n            URLConnection connection = url.openConnection();\n            long timestamp = connection.getLastModified();\n            // Check for a \"file:\" URI (courtesy of Brian Ewins)\n            if (timestamp == 0){ // get 0 for local URI\n                if (\"file\".equals(url.getProtocol())){\n                    File localfile = Paths.get(url.toURI()).toFile();\n                    timestamp = localfile.lastModified();\n                }\n            }\n            return(timestamp);\n        }\n        // Brutal handling of all exceptions\n        catch (Exception e) {\n            return(System.currentTimeMillis());\n        }\n    }\n    /**\n     *\n     */\n    private CachedDocument lookupDocument(String uri) {\n        return(_references.get(uri));\n    }\n    /**\n     *\n     */\n    private synchronized void insertDocument(String uri, CachedDocument doc) {\n        if (_count < _size) {\n            // Insert out URI in circular buffer\n            _URIs[_count++] = uri;\n            _current = 0;\n        }\n        else {\n            // Remove oldest URI from reference map\n            _references.remove(_URIs[_current]);\n            // Insert our URI in circular buffer\n            _URIs[_current] = uri;\n            if (++_current >= _size) _current = 0;\n        }\n        _references.put(uri, doc);\n    }\n    /**\n     *\n     */\n    private synchronized void replaceDocument(String uri, CachedDocument doc) {\n        if (doc == null)\n            insertDocument(uri, doc);\n        else\n            _references.put(uri, doc);\n    }\n    /**\n     * Returns a document either by finding it in the cache or\n     * downloading it and putting it in the cache.\n     */\n    @Override\n    public DOM retrieveDocument(String baseURI, String href, Translet trs) {\n        CachedDocument doc;\n    String uri = href;\n    if (baseURI != null && !baseURI.equals(\"\")) {\n        try {\n            uri = SystemIDResolver.getAbsoluteURI(uri, baseURI);\n        } catch (TransformerException te) {\n            // ignore\n        }\n    }\n        // Try to get the document from the cache first<fim_middle>// function below has no smell\n"}