{"text": "<fim_prefix>/*\n * Copyright (c) 2012-2018 Institut National des Sciences Appliqu\u00e9es de Lyon (INSA Lyon) and others\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * SPDX-License-Identifier: EPL-2.0\n */\n\npackage gololang.concurrent.async;\n\n/**\n * A future is an abstraction over the eventual result of a possibly asynchronous computation.\n *\n * This interface is intended to be used in conjunction with {@code Promise}. A future is a read-only view over a\n * promise.\n *\n * {@code Future} objects are made composable in Golo through a set of augmentations: {@code filter}, {@code map}, etc.\n * You should consult the \"golodoc\" of the {@code gololang.Async} module.\n */\n<fim_suffix>public interface Future {\n\n  /**\n   * Non-blocking get.\n   *\n   * @return the future value, which may be {@code null} if it has not been resolved yet.\n   */\n  Object get();\n\n  /**\n   * Blocking get, waiting until the future has been resolved.\n   *\n   * @return the future value.\n   * @throws InterruptedException when the current thread is being interrupted.\n   */\n  Object blockingGet() throws InterruptedException;\n\n  /**\n   * Test whether the future has been resolved, that is, the future is either set or failed.\n   *\n   * @return {@code true} if the future is resolved, {@code false} otherwise.\n   */\n  boolean isResolved();\n\n  /**\n   * Test whether the future has failed.\n   *\n   * @return {@code true} if the future is resolved and failed, {@code false} otherwise.\n   */\n  boolean isFailed();\n\n  /**\n   * Registers a callback for when the future is set. If the future has already been set, then it is executed\n   * immediately from the caller thread.\n   *\n   * @param observer the callback.\n   * @return this future object.\n   */\n  Future onSet(Observer observer);\n\n  /**\n   * Registers a callback for when the future fails. If the future has already been failed, then it is executed\n   * immediately from the caller thread.\n   *\n   * @param observer the callback.\n   * @return this future object.\n   */\n  Future onFail(Observer observer);\n\n  /**\n   * Simple interface for a future observer / callback.\n   */\n  @FunctionalInterface\n  interface Observer {\n\n    /**\n     * Callback method.\n     *\n     * @param value the future value.\n     */\n    void apply(Object value);\n  }\n}<fim_middle>// class below has no smell\n"}