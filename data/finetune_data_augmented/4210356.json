{"text": "<fim_prefix>package org.apache.cassandra.stress.settings;\n/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n */\n\n\nimport java.util.*;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * For specifying multiple grouped sub-options in the form: group(arg1=,arg2,arg3) etc.\n */\nabstract class OptionMulti extends Option\n{\n\n    private static final Pattern ARGS = Pattern.compile(\"([^,]+)\", Pattern.CASE_INSENSITIVE);\n\n    private final class Delegate extends GroupedOptions\n    {\n        @Override\n        public List<? extends Option> options()\n        {\n            if (collectAsMap == null)\n                return OptionMulti.this.options();\n\n            List<Option> options = new ArrayList<>(OptionMulti.this.options());\n            options.add(collectAsMap);\n            return options;\n        }\n    }\n\n    protected abstract List<? extends Option> options();\n\n    public Map<String, String> extraOptions()\n    {\n        return collectAsMap == null ? new HashMap<String, String>() : collectAsMap.options;\n    }\n\n    private final String name;\n    private final Pattern pattern;\n    private final String description;\n    private final Delegate delegate = new Delegate();\n    private final CollectAsMap collectAsMap;\n\n    public OptionMulti(String name, String description, boolean collectExtraOptionsInMap)\n    {\n        this.name = name;\n        pattern = Pattern.compile(name + \"\\\\((.*)\\\\)\", Pattern.CASE_INSENSITIVE);\n        this.description = description;\n        this.collectAsMap = collectExtraOptionsInMap ? new CollectAsMap() : null;\n    }\n\n    @Override\n    public boolean accept(String param)\n    {\n        Matcher m = pattern.matcher(param);\n        if (!m.matches())\n            return false;\n        m = ARGS.matcher(m.group(1));\n        int last = -1;\n        while (m.find())\n        {\n            if (m.start() != last + 1)\n                throw new IllegalArgumentException(\"Invalid \" + name + \" specification: \" + param);\n            last = m.end();\n            if (!delegate.accept(m.group()))\n            {\n\n                throw new IllegalArgumentException(\"Invalid \" + name + \" specification: \" + m.group());\n            }\n        }\n        return true;\n    }\n\n    public String toString()\n    {\n        StringBuilder sb = new StringBuilder();\n        sb.append(name);\n        sb.append(\"(\");\n        for (Option option : delegate.options())\n        {\n            sb.append(option);\n            sb.append(\",\");\n        }\n        sb.append(\")\");\n        return sb.toString();\n    }\n\n<fim_suffix>    @Override\n    public String shortDisplay()\n    {\n        return (happy() ? \"[\" : \"\") + name + \"(?)\" + (happy() ? \"]\" : \"\");\n    }\n    public String getOptionAsString()\n    {\n        StringBuilder sb = new StringBuilder();\n        sb.append(name).append(\": \");\n        sb.append(delegate.getOptionAsString());\n        sb.append(\";\");\n        if (collectAsMap != null)\n        {\n            sb.append(\"[\");\n            sb.append(collectAsMap.getOptionAsString());\n            sb.append(\"];\");\n        }\n        return sb.toString();\n    }\n\n\n    @Override\n    public String longDisplay()\n    {\n        StringBuilder sb = new StringBuilder();\n        sb.append(name);\n        sb.append(\"(\");\n        for (Option opt : delegate.options())\n        {\n            sb.append(opt.shortDisplay());\n        }\n        sb.append(\"): \");\n        sb.append(description);\n        return sb.toString();\n    }\n\n    @Override\n    public List<String> multiLineDisplay()\n    {\n        final List<String> r = new ArrayList<>();\n        for (Option option : options())\n            r.add(option.longDisplay());\n        return r;\n    }\n\n    @Override\n    boolean happy()\n    {\n        return delegate.happy();\n    }\n\n    private static final class CollectAsMap extends Option\n    {\n\n        static final String description = \"Extra options\";\n        Map<String, String> options = new LinkedHashMap<>();\n\n        boolean accept(String param)\n        {\n            String[] args = param.split(\"=\");\n            if (args.length == 2 && args[1].length() > 0 && args[0].length() > 0)\n            {\n                if (options.put(args[0], args[1]) != null)\n                    throw new IllegalArgumentException(args[0] + \" set twice\");\n                return true;\n            }\n            return false;\n        }\n\n        boolean happy()\n        {\n            return true;\n        }\n\n        String shortDisplay()\n        {\n            return \"[<option 1..N>=?]\";\n        }\n\n        public String getOptionAsString()\n        {\n            StringBuilder sb = new StringBuilder();\n            for (Map.Entry<String, String> entry : options.entrySet())\n            {\n                sb.append(entry.getKey()).append(\"=\").append(entry.getValue()).append(\",\");\n            }\n            return sb.toString();\n        }\n\n\n        String longDisplay()\n        {\n            return GroupedOptions.formatLong(shortDisplay(), description);\n        }\n\n        List<String> multiLineDisplay()\n        {\n            return Collections.emptyList();\n        }\n\n        boolean setByUser()\n        {\n            return !options.isEmpty();\n        }\n\n        boolean present()\n        {\n            return !options.isEmpty();\n        }\n    }\n\n    List<Option> optionsSetByUser()\n    {\n        List<Option> r = new ArrayList<>();\n        for (Option option : delegate.options())\n            if (option.setByUser())\n                r.add(option);\n        return r;\n    }\n\n    List<Option> defaultOptions()\n    {\n        List<Option> r = new ArrayList<>();\n        for (Option option : delegate.options())\n            if (!option.setByUser() && option.present())\n                r.add(option);\n        return r;\n    }\n\n    boolean setByUser()\n    {\n        for (Option option : delegate.options())\n            if (option.setByUser())\n                return true;\n        return false;\n    }\n\n    boolean present()\n    {\n        for (Option option : delegate.options())\n            if (option.present())\n                return true;\n        return false;\n    }\n\n}<fim_middle>// function below has no smell\n"}