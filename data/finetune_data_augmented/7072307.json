{"text": "<fim_prefix>     * value will be discarded.  The level value {@link #OFF}\n     * can be used to turn off logging.\n     * <p>\n     * If the new level is null, it means that this node should\n     * inherit its level from its nearest ancestor with a specific\n     * (non-null) level value.\n     *\n     * @param newLevel the new value for the log level (may be null)\n     */\n    public void setLevel(Level newLevel) {\n        loggerProxy.setLevel(newLevel);\n    }\n    /**\n     * Logs a SEVERE message.\n     */\n    public void severe(String msg) {\n        loggerProxy.doLog(Level.SEVERE, msg);\n    }\n    public void severe(String msg, Throwable t) {\n        loggerProxy.doLog(Level.SEVERE, msg, t);\n    }\n    public void severe(String msg, Object... params) {\n        loggerProxy.doLog(Level.SEVERE, msg, params);\n    }\n    /**\n     * Logs a WARNING message.\n     */\n    public void warning(String msg) {\n        loggerProxy.doLog(Level.WARNING, msg);\n    }\n    public void warning(String msg, Throwable t) {\n        loggerProxy.doLog(Level.WARNING, msg, t);\n    }\n    public void warning(String msg, Object... params) {\n        loggerProxy.doLog(Level.WARNING, msg, params);\n    }\n    /**\n     * Logs an INFO message.\n     */\n    public void info(String msg) {\n        loggerProxy.doLog(Level.INFO, msg);\n    }\n    public void info(String msg, Throwable t) {\n        loggerProxy.doLog(Level.INFO, msg, t);\n    }\n    public void info(String msg, Object... params) {\n        loggerProxy.doLog(Level.INFO, msg, params);\n    }\n    /**\n     * Logs a CONFIG message.\n     */\n    public void config(String msg) {\n        loggerProxy.doLog(Level.CONFIG, msg);\n    }\n    public void config(String msg, Throwable t) {\n        loggerProxy.doLog(Level.CONFIG, msg, t);\n    }\n    public void config(String msg, Object... params) {\n        loggerProxy.doLog(Level.CONFIG, msg, params);\n    }\n    /**\n     * Logs a FINE message.\n     */\n    public void fine(String msg) {\n        loggerProxy.doLog(Level.FINE, msg);\n    }\n    public void fine(String msg, Throwable t) {\n        loggerProxy.doLog(Level.FINE, msg, t);\n    }\n    public void fine(String msg, Object... params) {\n        loggerProxy.doLog(Level.FINE, msg, params);\n    }\n    /**\n     * Logs a FINER message.\n     */\n    public void finer(String msg) {\n        loggerProxy.doLog(Level.FINER, msg);\n    }\n    public void finer(String msg, Throwable t) {\n        loggerProxy.doLog(Level.FINER, msg, t);\n    }\n    public void finer(String msg, Object... params) {\n        loggerProxy.doLog(Level.FINER, msg, params);\n    }\n    /**\n     * Logs a FINEST message.\n     */\n    public void finest(String msg) {\n        loggerProxy.doLog(Level.FINEST, msg);\n    }\n    public void finest(String msg, Throwable t) {\n        loggerProxy.doLog(Level.FINEST, msg, t);\n    }\n    public void finest(String msg, Object... params) {\n        loggerProxy.doLog(Level.FINEST, msg, params);\n    }\n    /**\n     * Abstract base class for logging support, defining the API and common field.\n     */\n    private static abstract class LoggerProxy {\n        final String name;\n        protected LoggerProxy(String name) {\n            this.name = name;\n        }\n        abstract boolean isEnabled();\n        abstract Level getLevel();\n        abstract void setLevel(Level newLevel);\n        abstract void doLog(Level level, String msg);\n        abstract void doLog(Level level, String msg, Throwable thrown);\n        abstract void doLog(Level level, String msg, Object... params);\n        abstract boolean isLoggable(Level level);\n    }\n<fim_suffix>    private static final class DefaultLoggerProxy extends LoggerProxy {\n        /**\n         * Default platform logging support - output messages to System.err -\n         * equivalent to ConsoleHandler with SimpleFormatter.\n         */\n        private static PrintStream outputStream() {\n            return System.err;\n        }\n        volatile Level effectiveLevel; // effective level (never null)\n        volatile Level level;          // current level set for this node (may be null)\n        DefaultLoggerProxy(String name) {\n            super(name);\n            this.effectiveLevel = deriveEffectiveLevel(null);\n            this.level = null;\n        }\n        boolean isEnabled() {\n            return effectiveLevel != Level.OFF;\n        }\n        Level getLevel() {\n            return level;\n        }\n        void setLevel(Level newLevel) {\n            Level oldLevel = level;\n            if (oldLevel != newLevel) {\n                level = newLevel;\n                effectiveLevel = deriveEffectiveLevel(newLevel);\n            }\n        }\n        void doLog(Level level, String msg) {\n            if (isLoggable(level)) {\n                outputStream().print(format(level, msg, null));\n            }\n        }\n        void doLog(Level level, String msg, Throwable thrown) {\n            if (isLoggable(level)) {\n                outputStream().print(format(level, msg, thrown));\n            }\n        }\n        void doLog(Level level, String msg, Object... params) {\n            if (isLoggable(level)) {\n                String newMsg = formatMessage(msg, params);\n                outputStream().print(format(level, newMsg, null));\n            }\n        }\n        boolean isLoggable(Level level) {\n            Level effectiveLevel = this.effectiveLevel;\n            return level.intValue() >= effectiveLevel.intValue() && effectiveLevel != Level.OFF;\n        }\n        // derive effective level (could do inheritance search like j.u.l.Logger)\n        private Level deriveEffectiveLevel(Level level) {\n            return level == null ? DEFAULT_LEVEL : level;\n        }\n        // Copied from java.util.logging.Formatter.formatMessage\n        private String formatMessage(String format, Object... parameters) {\n            // Do the formatting.\n            try {\n                if (parameters == null || parameters.length == 0) {\n                    // No parameters.  Just return format string.\n                    return format;\n                }\n                // Is it a java.text style format?\n                // Ideally we could match with\n                // Pattern.compile(\"\\\\{\\\\d\").matcher(format).find())\n                // However the cost is 14% higher, so we cheaply check for\n                // 1 of the first 4 parameters\n                if (format.indexOf(\"{0\") >= 0 || format.indexOf(\"{1\") >=0 ||\n                            format.indexOf(\"{2\") >=0|| format.indexOf(\"{3\") >=0) {\n                    return java.text.MessageFormat.format(format, parameters);\n                }\n                return format;\n            } catch (Exception ex) {\n                // Formatting failed: use format string.\n                return format;\n            }\n        }\n        private static final String formatString =\n            LoggingSupport.getSimpleFormat(false); // don't check logging.properties\n        // minimize memory allocation\n        private Date date = new Date();\n        private synchronized String format(Level level, String msg, Throwable thrown) {\n            date.setTime(System.currentTimeMillis());\n            String throwable = \"\";\n            if (thrown != null) {\n                StringWriter sw = new StringWriter();\n                PrintWriter pw = new PrintWriter(sw);\n                pw.println();\n                thrown.printStackTrace(pw);\n                pw.close();\n                throwable = sw.toString();\n            }\n            return String.format(formatString,\n                                 date,\n                                 getCallerInfo(),\n                                 name,\n                                 level.name(),\n                                 msg,\n                                 throwable);\n        }\n        // Returns the caller's class and method's name; best effort\n        // if cannot infer, return the logger's name.\n        private String getCallerInfo() {\n            String sourceClassName = null;\n            String sourceMethodName = null;\n            Throwable throwable = new Throwable();\n            String logClassName = \"sun.util.logging.PlatformLogger\";\n            boolean lookingForLogger = true;\n            for (StackTraceElement frame : throwable.getStackTrace()) {\n                String cname = frame.getClassName();\n                if (lookingForLogger) {\n                    // Skip all frames until we have found the first logger frame.\n                    if (cname.equals(logClassName)) {\n                        lookingForLogger = false;\n                    }\n                } else {\n                    if (!cname.equals(logClassName)) {\n                        // We've found the relevant frame.\n                        sourceClassName = cname;\n                        sourceMethodName = frame.getMethodName();\n                        break;\n                    }\n                }\n            }\n            if (sourceClassName != null) {\n                return sourceClassName + \" \" + sourceMethodName;\n            } else {\n                return name;\n            }\n        }\n    }<fim_middle>// class below has no smell\n"}