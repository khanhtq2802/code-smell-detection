{"text": "<fim_prefix>/*\n * Copyright 2002-2014 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.http.converter.json;\n\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.Reader;\nimport java.lang.reflect.Type;\nimport java.nio.charset.Charset;\n\nimport org.springframework.http.HttpHeaders;\nimport org.springframework.http.HttpInputMessage;\nimport org.springframework.http.HttpOutputMessage;\nimport org.springframework.http.MediaType;\nimport org.springframework.http.converter.AbstractHttpMessageConverter;\nimport org.springframework.http.converter.GenericHttpMessageConverter;\nimport org.springframework.http.converter.HttpMessageNotReadableException;\nimport org.springframework.http.converter.HttpMessageNotWritableException;\nimport org.springframework.util.Assert;\n\nimport com.google.gson.Gson;\nimport com.google.gson.JsonIOException;\nimport com.google.gson.JsonParseException;\nimport com.google.gson.reflect.TypeToken;\n\n/**\n * Implementation of {@link org.springframework.http.converter.HttpMessageConverter}\n * that can read and write JSON using the\n * <a href=\"https://code.google.com/p/google-gson/\">Google Gson</a> library's\n * {@link Gson} class.\n *\n * <p>This converter can be used to bind to typed beans or untyped {@code HashMap}s.\n * By default, it supports {@code application/json} and {@code application/*+json}.\n *\n * <p>Tested against Gson 2.3; compatible with Gson 2.0 and higher.\n *\n * @author Roy Clarkson\n * @since 1.0\n * @see #setGson\n * @see #setSupportedMediaTypes\n */\npublic class GsonHttpMessageConverter extends AbstractHttpMessageConverter<Object>\n\t\timplements GenericHttpMessageConverter<Object> {\n\n\tpublic static final Charset DEFAULT_CHARSET = Charset.forName(\"UTF-8\");\n\n\n\tprivate Gson gson = new Gson();\n\n\tprivate String jsonPrefix;\n\n\n\t/**\n\t * Construct a new {@code GsonHttpMessageConverter}.\n\t */\n\tpublic GsonHttpMessageConverter() {\n\t\tsuper(new MediaType(\"application\", \"json\", DEFAULT_CHARSET),\n\t\t\t\tnew MediaType(\"application\", \"*+json\", DEFAULT_CHARSET));\n\t}\n\n\n\t/**\n\t * Set the {@code Gson} instance to use.\n\t * If not set, a default {@link Gson#Gson() Gson} instance is used.\n\t * <p>Setting a custom-configured {@code Gson} is one way to take further\n\t * control of the JSON serialization process.\n\t */\n\tpublic void setGson(Gson gson) {\n\t\tAssert.notNull(gson, \"'gson' is required\");\n\t\tthis.gson = gson;\n\t}\n\n\t/**\n\t * Return the configured {@code Gson} instance for this converter.\n\t */\n\tpublic Gson getGson() {\n\t\treturn this.gson;\n\t}\n\n\t/**\n\t * Specify a custom prefix to use for JSON output. Default is none.\n\t * @see #setPrefixJson\n\t */\n\tpublic void setJsonPrefix(String jsonPrefix) {\n\t\tthis.jsonPrefix = jsonPrefix;\n\t}\n\n\t/**\n\t * Indicate whether the JSON output by this view should be prefixed with \"{} &&\".\n\t * Default is {@code false}.\n\t * <p>Prefixing the JSON string in this manner is used to help prevent JSON\n\t * Hijacking. The prefix renders the string syntactically invalid as a script\n\t * so that it cannot be hijacked. This prefix does not affect the evaluation\n\t * of JSON, but if JSON validation is performed on the string, the prefix\n\t * would need to be ignored.\n\t * @see #setJsonPrefix\n\t */\n\tpublic void setPrefixJson(boolean prefixJson) {\n\t\tthis.jsonPrefix = (prefixJson ? \"{} && \" : null);\n\t}\n\n\n\t@Override\n\tpublic boolean canRead(Class<?> clazz, MediaType mediaType) {\n\t\treturn canRead(mediaType);\n\t}\n\n\t@Override\n\tpublic boolean canRead(Type type, Class<?> contextClass, MediaType mediaType) {\n\t\treturn canRead(mediaType);\n\t}\n\n\t@Override\n\tpublic boolean canWrite(Class<?> clazz, MediaType mediaType) {\n\t\treturn canWrite(mediaType);\n\t}\n\n\t@Override\n\tprotected boolean supports(Class<?> clazz) {\n\t\t// should not be called, since we override canRead/Write instead\n\t\tthrow new UnsupportedOperationException();\n\t}\n\n\t@Override\n\tprotected Object readInternal(Class<?> clazz, HttpInputMessage inputMessage)\n\t\t\tthrows IOException, HttpMessageNotReadableException {\n\n\t\tTypeToken<?> token = getTypeToken(clazz);\n\t\treturn readTypeToken(token, inputMessage);\n\t}\n\n\t@Override\n\tpublic Object read(Type type, Class<?> contextClass, HttpInputMessage inputMessage)\n\t\t\tthrows IOException, HttpMessageNotReadableException {\n\n\t\tTypeToken<?> token = getTypeToken(type);\n\t\treturn readTypeToken(token, inputMessage);\n\t}\n\n\t/**\n\t * Return the Gson {@link TypeToken} for the specified type.\n\t * <p>The default implementation returns {@code TypeToken.get(type)}, but\n\t * this can be overridden in subclasses to allow for custom generic\n\t * collection handling. For instance:\n\t * <pre class=\"code\">\n\t * protected TypeToken<?> getTypeToken(Type type) {\n\t *   if (type instanceof Class && List.class.isAssignableFrom((Class<?>) type)) {\n\t *     return new TypeToken<ArrayList<MyBean>>() {};\n\t *   }\n\t *   else {\n\t *     return super.getTypeToken(type);\n\t *   }\n\t * }\n\t * </pre>\n\t * @param type the type for which to return the TypeToken\n\t * @return the type token\n\t */\n\tprotected TypeToken<?> getTypeToken(Type type) {\n\t\treturn TypeToken.get(type);\n\t}\n\n<fim_suffix>\tprivate Object readTypeToken(TypeToken<?> token, HttpInputMessage inputMessage) throws IOException {\n\t\tReader json = new InputStreamReader(inputMessage.getBody(), getCharset(inputMessage.getHeaders()));\n\t\ttry {\n\t\t\treturn this.gson.fromJson(json, token.getType());\n\t\t}\n\t\tcatch (JsonParseException ex) {\n\t\t\tthrow new HttpMessageNotReadableException(\"Could not read JSON: \" + ex.getMessage(), ex);\n\t\t}\n\t}\n\n\tprivate Charset getCharset(HttpHeaders headers) {\n\t\tif (headers == null || headers.getContentType() == null || headers.getContentType().getCharSet() == null) {\n\t\t\treturn DEFAULT_CHARSET;\n\t\t}\n\t\treturn headers.getContentType().getCharSet();\n\t}\n\n\t@Override\n\tprotected void writeInternal(Object o, HttpOutputMessage outputMessage)\n\t\t\tthrows IOException, HttpMessageNotWritableException {\n\n\t\tCharset charset = getCharset(outputMessage.getHeaders());\n\t\tOutputStreamWriter writer = new OutputStreamWriter(outputMessage.getBody(), charset);\n\t\ttry {\n\t\t\tif (this.jsonPrefix != null) {\n\t\t\t\twriter.append(this.jsonPrefix);\n\t\t\t}\n\t\t\tthis.gson.toJson(o, writer);\n\t\t\twriter.close();\n\t\t}\n\t\tcatch(JsonIOException  ex) {\n\t\t\tthrow new HttpMessageNotWritableException(\"Could not write JSON: \" + ex.getMessage(), ex);\n\t\t}\n\t}\n\n}<fim_middle>// function below has no smell\n"}