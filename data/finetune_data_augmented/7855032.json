{"text": "<fim_prefix>        stats.incBroadcastMessagesTime(endTime - startTime);\n      }\n    }\n    stats.incSentMessages(1L);\n    if (DistributionStats.enableClockStats) {\n      stats.incSentMessagesTime(endTime - startTime);\n      stats.incDistributeMessageTime(endTime - message.getTimestamp());\n    }\n    return result;\n  }\n  /**\n   * @return recipients who did not receive the message\n   * @throws NotSerializableException If <codE>message</code> cannot be serialized\n   */\n  private Set<InternalDistributedMember> sendMessage(DistributionMessage message)\n      throws NotSerializableException {\n    Set<InternalDistributedMember> result = null;\n    try {\n      // Verify we're not too far into the shutdown\n      stopper.checkCancelInProgress(null);\n      // avoid race condition during startup\n      waitUntilReadyToSendMsgs(message);\n      result = sendOutgoing(message);\n    } catch (NotSerializableException | ToDataException | ReenteredConnectException\n        | InvalidDeltaException | CancelException ex) {\n      throw ex;\n    } catch (Exception ex) {\n      ClusterDistributionManager.this.exceptionInThreads = true;\n      String receiver = \"NULL\";\n      if (message != null) {\n        receiver = message.getRecipientsDescription();\n      }\n      logger.fatal(String.format(\"While pushing message <%s> to %s\",\n          new Object[] {message, receiver}),\n          ex);\n      if (message == null || message.forAll())\n        return null;\n      result = new HashSet<>();\n      for (int i = 0; i < message.getRecipients().length; i++)\n        result.add(message.getRecipients()[i]);\n      return result;\n    }\n    return result;\n  }\n  /**\n   * @return list of recipients who did not receive the message because they left the view (null if\n   *         all received it or it was sent to {@link DistributionMessage#ALL_RECIPIENTS}).\n   * @throws NotSerializableException If content cannot be serialized\n   */\n  private Set<InternalDistributedMember> sendViaMembershipManager(\n      InternalDistributedMember[] destinations,\n      DistributionMessage content, ClusterDistributionManager dm, DistributionStats stats)\n      throws NotSerializableException {\n    if (membershipManager == null) {\n      logger.warn(\"Attempting a send to a disconnected DistributionManager\");\n      if (destinations.length == 1 && destinations[0] == DistributionMessage.ALL_RECIPIENTS)\n        return null;\n      HashSet<InternalDistributedMember> result = new HashSet<>();\n      Collections.addAll(result, destinations);\n      return result;\n    }\n    return membershipManager.send(destinations, content, stats);\n  }\n  /**\n   * Schedule a given message appropriately, depending upon its executor kind.\n   */\n  private void scheduleIncomingMessage(DistributionMessage message) {\n    /*\n     * Potential race condition between starting up and getting other distribution manager ids -- DM\n     * will only be initialized upto the point at which it called startThreads\n     */\n    waitUntilReadyForMessages();\n    message.schedule(ClusterDistributionManager.this);\n  }\n  private List<InternalDistributedMember> getElderCandidates() {\n    return clusterElderManager.getElderCandidates();\n  }\n  @Override\n  public InternalDistributedMember getElderId() throws DistributedSystemDisconnectedException {\n    return clusterElderManager.getElderId();\n  }\n  @Override\n  public boolean isElder() {\n    return clusterElderManager.isElder();\n  }\n  @Override\n  public boolean isLoner() {\n    return false;\n  }\n  @Override\n  public ElderState getElderState(boolean waitToBecomeElder) {\n    return clusterElderManager.getElderState(waitToBecomeElder);\n  }\n  /**\n   * Waits until elder if newElder or newElder is no longer a member\n   *\n   * @return true if newElder is the elder; false if it is no longer a member or we are the elder.\n   */\n  public boolean waitForElder(final InternalDistributedMember desiredElder) {\n    return clusterElderManager.waitForElder(desiredElder);\n  }\n  @Override\n  public ExecutorService getThreadPool() {\n    return this.threadPool;\n  }\n  @Override\n  public ExecutorService getHighPriorityThreadPool() {\n    return this.highPriorityPool;\n  }\n  @Override\n  public ExecutorService getWaitingThreadPool() {\n    return this.waitingPool;\n  }\n  @Override\n  public ExecutorService getPrMetaDataCleanupThreadPool() {\n    return this.prMetaDataCleanupThreadPool;\n  }\n  private Executor getPartitionedRegionExcecutor() {\n    if (this.partitionedRegionThread != null) {\n      return this.partitionedRegionThread;\n    } else {\n      return this.partitionedRegionPool;\n    }\n  }\n  @Override\n  public Executor getFunctionExecutor() {\n    if (this.functionExecutionThread != null) {\n      return this.functionExecutionThread;\n    } else {\n      return this.functionExecutionPool;\n    }\n  }\n  private Executor getSerialExecutor(InternalDistributedMember sender) {\n    if (MULTI_SERIAL_EXECUTORS) {\n      return this.serialQueuedExecutorPool.getThrottledSerialExecutor(sender);\n    } else {\n      return this.serialThread;\n    }\n  }\n  /** returns the serialThread's queue if throttling is being used, null if not */\n  public OverflowQueueWithDMStats<Runnable> getSerialQueue(InternalDistributedMember sender) {\n    if (MULTI_SERIAL_EXECUTORS) {\n      return this.serialQueuedExecutorPool.getSerialQueue(sender);\n    } else {\n      return this.serialQueue;\n    }\n  }\n  @Override\n  /** returns the Threads Monitoring instance */\n  public ThreadsMonitoring getThreadMonitoring() {\n    return this.threadMonitor;\n  }\n  /**\n   * Sets the administration agent associated with this distribution manager.\n   */\n  public void setAgent(RemoteGfManagerAgent agent) {\n    // Don't let the agent be set twice. There should be a one-to-one\n    // correspondence between admin agent and distribution manager.\n    if (agent != null) {\n      if (this.agent != null) {\n        throw new IllegalStateException(\n            \"There is already an Admin Agent associated with this distribution manager.\");\n      }\n    } else {\n      if (this.agent == null) {\n        throw new IllegalStateException(\n            \"There was never an Admin Agent associated with this distribution manager.\");\n      }\n    }\n    this.agent = agent;\n  }\n  /**\n   * Returns the agent that owns this distribution manager. (in ConsoleDistributionManager)\n   */\n  public RemoteGfManagerAgent getAgent() {\n    return this.agent;\n  }\n  /**\n   * Returns a description of the distribution configuration used for this distribution manager. (in\n   * ConsoleDistributionManager)\n   *\n   * @return <code>null</code> if no admin {@linkplain #getAgent agent} is associated with this\n   *         distribution manager\n   */\n  public String getDistributionConfigDescription() {\n    if (this.agent == null) {\n      return null;\n    } else {\n      return this.agent.getTransport().toString();\n    }\n  }\n  /* -----------------------------Health Monitor------------------------------ */\n  private final ConcurrentMap<InternalDistributedMember, HealthMonitor> hmMap =\n      new ConcurrentHashMap<>();\n  private volatile InternalCache cache;\n  /**\n   * Returns the health monitor for this distribution manager and owner.\n   *\n   * @param owner the agent that owns the returned monitor\n   * @return the health monitor created by the owner; <code>null</code> if the owner has now created\n   *         a monitor.\n   * @since GemFire 3.5\n   */\n  @Override\n  public HealthMonitor getHealthMonitor(InternalDistributedMember owner) {\n    return this.hmMap.get(owner);\n  }\n  /**\n   * Returns the health monitor for this distribution manager.\n   *\n   * @param owner the agent that owns the created monitor\n   * @param cfg the configuration to use when creating the monitor\n   * @since GemFire 3.5\n   */\n  @Override\n  public void createHealthMonitor(InternalDistributedMember owner, GemFireHealthConfig cfg) {\n    if (closeInProgress) {\n      return;\n    }\n    {\n      final HealthMonitor hm = getHealthMonitor(owner);\n      if (hm != null) {\n        hm.stop();\n        this.hmMap.remove(owner);\n      }\n    }\n    {\n      HealthMonitorImpl newHm = new HealthMonitorImpl(owner, cfg, this);\n      newHm.start();\n      this.hmMap.put(owner, newHm);\n    }\n  }\n  /**\n   * Remove a monitor that was previously created.\n   *\n   * @param owner the agent that owns the monitor to remove\n   */\n<fim_suffix>  @Override\n  public void removeHealthMonitor(InternalDistributedMember owner, int theId) {\n    final HealthMonitor hm = getHealthMonitor(owner);\n    if (hm != null && hm.getId() == theId) {\n      hm.stop();\n      this.hmMap.remove(owner);\n    }\n  }<fim_middle>// function below has no smell\n"}