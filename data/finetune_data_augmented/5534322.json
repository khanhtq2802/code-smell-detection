{"text": "<fim_prefix>      String entityPath = config.getStreamEntityPath(systemName, streamId);\n      EventHubClientManager eventHubClientManager = createOrGetEventHubClientManagerForSSP(streamId, ssp);\n      try {\n        PartitionReceiver receiver;\n        if (END_OF_STREAM.equals(offset)) {\n          // If the offset is greater than the newest offset, use the use current Instant as\n          // offset to fetch in Eventhub.\n          receiver = eventHubClientManager.getEventHubClient()\n              .createReceiver(consumerGroup, partitionId.toString(), EventPosition.fromEnqueuedTime(Instant.now())).get(DEFAULT_EVENTHUB_CREATE_RECEIVER_TIMEOUT.toMillis(), TimeUnit.MILLISECONDS);\n        } else {\n          // EventHub will return the first message AFTER the offset that was specified in the fetch request.\n          // If no such offset exists Eventhub will return an error.\n          receiver = eventHubClientManager.getEventHubClient()\n              .createReceiver(consumerGroup, partitionId.toString(),\n                  EventPosition.fromOffset(offset, /* inclusiveFlag */false)).get(DEFAULT_EVENTHUB_CREATE_RECEIVER_TIMEOUT.toMillis(), TimeUnit.MILLISECONDS);\n        }\n        receiver.setPrefetchCount(prefetchCount);\n        PartitionReceiveHandler handler =\n            new PartitionReceiverHandlerImpl(ssp, eventReadRates.get(streamId), eventByteReadRates.get(streamId),\n                consumptionLagMs.get(streamId), readErrors.get(streamId), interceptors.getOrDefault(streamId, null),\n                config.getMaxEventCountPerPoll(systemName));\n        // Timeout for EventHubClient receive\n        receiver.setReceiveTimeout(DEFAULT_EVENTHUB_RECEIVER_TIMEOUT);\n        // Start the receiver thread\n        receiver.setReceiveHandler(handler);\n        streamPartitionHandlers.put(ssp, handler);\n        streamPartitionReceivers.put(ssp, receiver);\n      } catch (Exception e) {\n        throw new SamzaException(\n            String.format(\"Failed to create receiver for EventHubs: namespace=%s, entity=%s, partitionId=%d\", namespace,\n                entityPath, partitionId), e);\n      }\n      LOG.info(String.format(\"Connection successfully started for namespace=%s, entity=%s \", namespace, entityPath));\n    }\n  }\n  @Override\n  public void start() {\n    if (isStarted) {\n      LOG.warn(\"Trying to start EventHubSystemConsumer while it's already started. Ignore the request.\");\n      return;\n    }\n    isStarted = true;\n    initializeEventHubsManagers();\n    LOG.info(\"EventHubSystemConsumer started\");\n  }\n  @Override\n  public Map<SystemStreamPartition, List<IncomingMessageEnvelope>> poll(\n      Set<SystemStreamPartition> systemStreamPartitions, long timeout) throws InterruptedException {\n    Throwable handlerError = eventHubNonTransientError.get();\n    /*\n     * We will retry for non transient error by instantiating a new EventHubs client if\n     * 1. Last retry happened more than CONFIG_MIN_RETRY_INTERVAL_MS ms ago. Otherwise we ignore\n     * 2. We haven't reached CONFIG_MAX_RETRY_COUNT allowed within the CONFIG_RETRY_WINDOW_MS window.\n     *    Otherwise we throw\n     */\n    if (handlerError != null && clock.currentTimeMillis() - lastRetryTs > config.getMinRetryIntervalMs(systemName)) {\n      int currentRetryCount = recentRetryAttempts.size();\n      long maxRetryCount = config.getMaxRetryCount(systemName);\n      if (currentRetryCount < maxRetryCount) {\n        LOG.warn(\"Received non transient error. Will retry.\", handlerError);\n        LOG.info(\"Current retry count within window: {}. max retry count allowed: {}. window size: {} ms\",\n            currentRetryCount, maxRetryCount, config.getRetryWindowMs(systemName));\n        long now = clock.currentTimeMillis();\n        recentRetryAttempts.update(now);\n        lastRetryTs = now;\n        reconnectTaskStatus = reconnectTaskRunner.submit(this::renewEventHubsClient);\n      } else {\n        LOG.error(\"Retries exhausted. Reached max allowed retries: ({}) within window {} ms\", currentRetryCount,\n            config.getRetryWindowMs(systemName));\n        String msg = \"Received a non transient error from event hub partition receiver\";\n        throw new SamzaException(msg, handlerError);\n      }\n    }\n    return super.poll(systemStreamPartitions, timeout);\n  }\n  private synchronized void renewEventHubsClient() {\n    try {\n      LOG.info(\"Start to renew eventhubs client\");\n      shutdownEventHubsManagers(); // The shutdown is in parallel and time bounded\n      initializeEventHubsManagers();\n    } catch (Exception e) {\n      LOG.error(\"Failed to renew eventhubs client\", e);\n      eventHubNonTransientError.set(e);\n    }\n  }\n  private void renewPartitionReceiver(SystemStreamPartition ssp) {\n    String streamId = config.getStreamId(ssp.getStream());\n    EventHubClientManager eventHubClientManager = perPartitionEventHubManagers.get(ssp);\n    String offset = streamPartitionOffsets.get(ssp);\n    Integer partitionId = ssp.getPartition().getPartitionId();\n    String consumerGroup = config.getStreamConsumerGroup(ssp.getSystem(), streamId);\n    try {\n      // Close current receiver\n      streamPartitionReceivers.get(ssp).close().get(DEFAULT_SHUTDOWN_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);\n      // Recreate receiver\n      PartitionReceiver receiver = eventHubClientManager.getEventHubClient()\n          .createReceiverSync(consumerGroup, partitionId.toString(),\n              EventPosition.fromOffset(offset, !offset.equals(EventHubSystemConsumer.START_OF_STREAM)));\n      receiver.setPrefetchCount(prefetchCount);\n      // Timeout for EventHubClient receive\n      receiver.setReceiveTimeout(DEFAULT_EVENTHUB_RECEIVER_TIMEOUT);\n      // Create and start receiver thread with handler\n      receiver.setReceiveHandler(streamPartitionHandlers.get(ssp));\n      streamPartitionReceivers.put(ssp, receiver);\n    } catch (Exception e) {\n      eventHubNonTransientError.set(new SamzaException(\n          String.format(\"Failed to recreate receiver for EventHubs after ReceiverHandlerError (ssp=%s)\", ssp), e));\n    }\n  }\n  private synchronized void shutdownEventHubsManagers() {\n    // There could be potentially many Receivers and EventHubManagers, so close the managers in parallel\n    LOG.info(\"Start shutting down eventhubs receivers\");\n    ShutdownUtil.boundedShutdown(streamPartitionReceivers.values().stream().map(receiver ->\n      (Runnable) () -> {\n        try {\n          receiver.close().get(DEFAULT_SHUTDOWN_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS);\n        } catch (Exception e) {\n          LOG.error(\"Failed to shutdown receiver.\", e);\n        }\n      }).collect(Collectors.toList()), \"EventHubSystemConsumer.Receiver#close\", DEFAULT_SHUTDOWN_TIMEOUT_MILLIS);\n    LOG.info(\"Start shutting down eventhubs managers\");\n    ShutdownUtil.boundedShutdown(perPartitionEventHubManagers.values().stream().map(manager ->\n      (Runnable) () -> {\n        try {\n          manager.close(DEFAULT_SHUTDOWN_TIMEOUT_MILLIS);\n        } catch (Exception e) {\n          LOG.error(\"Failed to shutdown eventhubs manager.\", e);\n        }\n      }).collect(Collectors.toList()), \"EventHubSystemConsumer.ClientManager#close\", DEFAULT_SHUTDOWN_TIMEOUT_MILLIS);\n    perPartitionEventHubManagers.clear();\n    perStreamEventHubManagers.clear();\n  }\n  @Override\n  public void stop() {\n    LOG.info(\"Stopping event hub system consumer...\");\n    try {\n      reconnectTaskRunner.shutdown();\n      shutdownEventHubsManagers();\n      isStarted = false;\n    } catch (Exception e) {\n      LOG.warn(\"Exception during stop.\", e);\n    }\n    LOG.info(\"Event hub system consumer stopped.\");\n  }\n  @Override\n  protected BlockingQueue<IncomingMessageEnvelope> newBlockingQueue() {\n    return new LinkedBlockingQueue<>(config.getConsumerBufferCapacity(systemName));\n  }\n  protected class PartitionReceiverHandlerImpl implements PartitionReceiveHandler {\n    private final Counter eventReadRate;\n    private final Counter eventByteReadRate;\n    private final SamzaHistogram readLatency;\n    private final Counter errorRate;\n    private final Interceptor interceptor;\n    private final Integer maxEventCount;\n    private final SystemStreamPartition ssp;\n<fim_suffix>    PartitionReceiverHandlerImpl(SystemStreamPartition ssp, Counter eventReadRate, Counter eventByteReadRate,\n        SamzaHistogram readLatency, Counter readErrors, Interceptor interceptor, int maxEventCount) {\n      this.ssp = ssp;\n      this.eventReadRate = eventReadRate;\n      this.eventByteReadRate = eventByteReadRate;\n      this.readLatency = readLatency;\n      this.errorRate = readErrors;\n      this.interceptor = interceptor;\n      this.maxEventCount = maxEventCount;\n    }<fim_middle>// function below has no smell\n"}