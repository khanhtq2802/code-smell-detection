{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.lucene.search;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport org.apache.lucene.index.IndexReader;\nimport org.apache.lucene.index.LeafReaderContext;\nimport org.apache.lucene.index.PostingsEnum;\nimport org.apache.lucene.index.Term;\nimport org.apache.lucene.index.TermState;\nimport org.apache.lucene.index.TermStates;\nimport org.apache.lucene.index.TermsEnum;\nimport org.apache.lucene.search.similarities.BM25Similarity;\nimport org.apache.lucene.search.similarities.Similarity;\nimport org.apache.lucene.search.similarities.SimilarityBase;\nimport org.apache.lucene.util.BytesRef;\n/**\n * A {@link Query} that treats multiple fields as a single stream and scores\n * terms as if you had indexed them as a single term in a single field.\n *\n * For scoring purposes this query implements the BM25F's simple formula\n * described in:\n *  http://www.staff.city.ac.uk/~sb317/papers/foundations_bm25_review.pdf\n *\n * The per-field similarity is ignored but to be compatible each field must use\n * a {@link Similarity} at index time that encodes norms the same way as\n * {@link SimilarityBase#computeNorm}.\n *\n * @lucene.experimental\n */\npublic final class BM25FQuery extends Query {\n  /**\n   * A builder for {@link BM25FQuery}.\n   */\n  public static class Builder {\n    private final BM25Similarity similarity;\n    private final Map<String, FieldAndWeight> fieldAndWeights = new HashMap<>();\n    private final Set<BytesRef> termsSet = new HashSet<>();\n    /**\n     * Default builder.\n     */\n    public Builder() {\n      this.similarity = new BM25Similarity();\n    }\n    /**\n     * Builder with the supplied parameter values.\n     * @param k1 Controls non-linear term frequency normalization (saturation).\n     * @param b Controls to what degree document length normalizes tf values.\n     */\n<fim_suffix>    public Builder(float k1, float b) {\n      this.similarity = new BM25Similarity(k1, b);\n    }\n    /**\n     * Adds a field to this builder.\n     * @param field The field name.\n     */\n    public Builder addField(String field) {\n      return addField(field, 1f);\n    }\n    /**\n     * Adds a field to this builder.\n     * @param field The field name.\n     * @param weight The weight associated to this field.\n     */\n    public Builder addField(String field, float weight) {\n      if (weight < 1) {\n        throw new IllegalArgumentException(\"weight must be greater or equal to 1\");\n      }\n      fieldAndWeights.put(field, new FieldAndWeight(field, weight));\n      return this;\n    }\n    /**\n     * Adds a term to this builder.\n     */\n    public Builder addTerm(BytesRef term) {\n      if (termsSet.size() > BooleanQuery.getMaxClauseCount()) {\n        throw new BooleanQuery.TooManyClauses();\n      }\n      termsSet.add(term);\n      return this;\n    }\n    /**\n     * Builds the {@link BM25FQuery}.\n     */\n    public BM25FQuery build() {\n      int size = fieldAndWeights.size() * termsSet.size();\n      if (size > BooleanQuery.getMaxClauseCount()) {\n        throw new BooleanQuery.TooManyClauses();\n      }\n      BytesRef[] terms = termsSet.toArray(new BytesRef[0]);\n      return new BM25FQuery(similarity, new TreeMap<>(fieldAndWeights), terms);\n    }\n  }\n  static class FieldAndWeight {\n    final String field;\n    final float weight;\n    FieldAndWeight(String field, float weight) {\n      this.field = field;\n      this.weight = weight;\n    }\n  }\n  // the similarity to use for scoring.\n  private final BM25Similarity similarity;\n  // sorted map for fields.\n  private final TreeMap<String, FieldAndWeight> fieldAndWeights;\n  // array of terms, sorted.\n  private final BytesRef terms[];\n  // array of terms per field, sorted\n  private final Term fieldTerms[];\n  private BM25FQuery(BM25Similarity similarity, TreeMap<String, FieldAndWeight> fieldAndWeights, BytesRef[] terms) {\n    this.similarity = similarity;\n    this.fieldAndWeights = fieldAndWeights;\n    this.terms = terms;\n    int numFieldTerms = fieldAndWeights.size() * terms.length;\n    if (numFieldTerms > BooleanQuery.getMaxClauseCount()) {\n      throw new BooleanQuery.TooManyClauses();\n    }\n    this.fieldTerms = new Term[numFieldTerms];\n    Arrays.sort(terms);\n    int pos = 0;\n    for (String field : fieldAndWeights.keySet()) {\n      for (BytesRef term : terms) {\n        fieldTerms[pos++] = new Term(field, term);\n      }\n    }\n  }\n  public List<Term> getTerms() {\n    return Collections.unmodifiableList(Arrays.asList(fieldTerms));\n  }\n  @Override\n  public String toString(String field) {\n    StringBuilder builder = new StringBuilder(\"BM25F((\");\n    int pos = 0;\n    for (FieldAndWeight fieldWeight : fieldAndWeights.values()) {\n      if (pos++ != 0) {\n        builder.append(\" \");\n      }\n      builder.append(fieldWeight.field);\n      if (fieldWeight.weight != 1f) {\n        builder.append(\"^\");\n        builder.append(fieldWeight.weight);\n      }\n    }\n    builder.append(\")(\");\n    pos = 0;\n    for (BytesRef term : terms) {\n      if (pos++ != 0) {\n        builder.append(\" \");\n      }\n      builder.append(term.utf8ToString());\n    }\n    builder.append(\"))\");\n    return builder.toString();\n  }\n  @Override\n  public int hashCode() {\n    return 31 * classHash() + Arrays.hashCode(terms);\n  }\n  @Override\n  public boolean equals(Object other) {\n    return sameClassAs(other) &&\n        Arrays.equals(terms, ((BM25FQuery) other).terms);\n  }\n  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    // optimize zero and single field cases\n    if (terms.length == 0) {\n      return new BooleanQuery.Builder().build();\n    }\n    // single field and one term\n    if (fieldTerms.length == 1) {\n      return new TermQuery(fieldTerms[0]);\n    }\n    // single field and multiple terms\n    if (fieldAndWeights.size() == 1) {\n      SynonymQuery.Builder builder = new SynonymQuery.Builder(fieldTerms[0].field());\n      for (Term term : fieldTerms) {\n        builder.addTerm(term);\n      }\n      return builder.build();\n    }\n    return this;\n  }\n  @Override\n  public void visit(QueryVisitor visitor) {\n    Term[] selectedTerms = Arrays.stream(fieldTerms).filter(t -> visitor.acceptField(t.field())).toArray(Term[]::new);\n    if (selectedTerms.length > 0) {\n      QueryVisitor v = visitor.getSubVisitor(BooleanClause.Occur.SHOULD, this);\n      v.consumeTerms(this, selectedTerms);\n    }\n  }\n  private BooleanQuery rewriteToBoolean() {\n    // rewrite to a simple disjunction if the score is not needed.\n    BooleanQuery.Builder bq = new BooleanQuery.Builder();\n    for (Term term : fieldTerms) {\n      bq.add(new TermQuery(term), BooleanClause.Occur.SHOULD);\n    }\n    return bq.build();\n  }\n  @Override\n  public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n    if (scoreMode.needsScores()) {\n      return new BM25FWeight(this, searcher, scoreMode, boost);\n    } else {<fim_middle>// function below has no smell\n"}