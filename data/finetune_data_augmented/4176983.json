{"text": "<fim_prefix>     *  - to track references that were cleared ReferenceQueue is used;\n     *  - this map is abstract, all that required for the concrete implementation is\n     *  to define newReference(Object) method;\n     *  - all accessors/modifiers should call checkReferenceQueue() to clear all stale data\n     */\n    private static final long serialVersionUID = -3365744592038165092L;\n    /**\n     * This is a main data storage used for most operations\n     */\n    protected transient HashMap<K, R> map;\n    protected transient ReferenceQueue<V> referenceQueue;\n    /**\n     * This is a lazily created set of entries that is essentially a view to actual data\n     */\n    protected transient Set<Entry<K, V>> entrySet;\n    public ReferenceMap() {\n        map = new HashMap<>();\n        referenceQueue = new ReferenceQueue<>();\n    }\n    public ReferenceMap(int initialCapacity) {\n        map = new HashMap<>(initialCapacity);\n        referenceQueue = new ReferenceQueue<>();\n    }\n    public ReferenceMap(Map<? extends K, ? extends V> m) {\n        this(m.size());\n        putAll(m);\n    }\n    @Override\n    public int size() {\n        checkReferenceQueue();\n        return map.size();\n    }\n    @Override\n    public boolean isEmpty() {\n        checkReferenceQueue();\n        return map.isEmpty();\n    }\n    @Override\n    public boolean containsKey(Object key) {\n        checkReferenceQueue();\n        return map.containsKey(key);\n    }\n    @Override\n    public boolean containsValue(Object value) {\n        checkReferenceQueue();\n        for(R ref : map.values()) {\n            if(ref == null) {\n                // should not happen, we can't have nulls in internal map\n                throw new IllegalStateException();\n            }\n            V v = ref.get();\n            if(v != null) {\n                if(v.equals(value)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    @Override\n    public V get(Object key) {\n        checkReferenceQueue();\n        R ref = map.get(key);\n        if(ref == null) {\n            return null;\n        }\n        return ref.get();\n    }\n    @Override\n    public V put(K key, V value) {\n        if(value == null) {\n            throw new NullPointerException(\"ReferenceMap can't contain null values\");\n        }\n        checkReferenceQueue();\n        R refValue = newReference(value);\n        R oldValue = map.put(key, refValue);\n        if(oldValue == null) {\n            return null;\n        }\n        return oldValue.get();\n    }\n    @Override\n    public V remove(Object key) {\n        checkReferenceQueue();\n        R oldValue = map.remove(key);\n        if(oldValue == null) {\n            return null;\n        }\n        return oldValue.get();\n    }\n    @Override\n    public void putAll(Map<? extends K, ? extends V> m) {\n        checkReferenceQueue();\n        for(Map.Entry<? extends K, ? extends V> entry : m.entrySet()) {\n            if(entry.getValue() == null) {\n                throw new NullPointerException(\"ReferenceMap can't contain null values\");\n            }\n            R value = newReference(entry.getValue());\n            map.put(entry.getKey(), value);\n        }\n    }\n    @Override\n    public void clear() {\n        map.clear();\n        resetReferenceQueue();\n    }\n    @Override\n    public Set<K> keySet() {\n        checkReferenceQueue();\n        // should this check for cleared references? it can be invalid later anyway...\n        return map.keySet();\n    }\n    @Override\n    public Collection<V> values() {\n        checkReferenceQueue();\n        // this can be optimized by creating view instead of new heavyweight collection\n        Collection<R> referenceValues = map.values();\n        Collection<V> values = new ArrayList<>(referenceValues.size());\n        for(R v : referenceValues) {\n            if(v != null) {\n                V value = v.get();\n                // check for null in case GC cleared some values after last queue check\n                if(value != null) {\n                    values.add(value);\n                }\n            }\n        }\n        return values;\n    }\n    @Override\n    public Set<Entry<K, V>> entrySet() {\n        checkReferenceQueue();\n        // lazily create entry set view\n        Set<Entry<K, V>> es = entrySet;\n        if(es == null) {\n            entrySet = es = new ReferenceEntrySet();\n        }\n        return es;\n    }\n    /**\n     * Cleanup all references collected by GC so far\n     */\n    protected void checkReferenceQueue() {\n        Collection<Reference<? extends V>> valuesToRemove = null;\n        Reference<? extends V> reference;\n        while((reference = referenceQueue.poll()) != null) {\n            if(valuesToRemove == null) {\n                valuesToRemove = new HashSet<>();\n            }\n            valuesToRemove.add(reference);\n        }\n        if(valuesToRemove == null) {\n            return;\n        }\n        Collection<K> keysToRemove = new ArrayList<>(valuesToRemove.size());\n        for(Map.Entry<K, R> entry : map.entrySet()) {\n            if(valuesToRemove.contains(entry.getValue())) {\n                keysToRemove.add(entry.getKey());\n            }\n        }\n        for(K keyToRemove : keysToRemove) {\n            map.remove(keyToRemove);\n        }\n    }\n    private void resetReferenceQueue() {\n        while(referenceQueue.poll() != null) {\n            // just purge this queue\n        }\n    }\n    /**\n     * This method should be implemented by concrete implementations of this abstract class.\n     *\n     * @param value to be wrapped into reference\n     * @return new reference to the value\n     */\n    abstract R newReference(V value);\n    private void writeObject(ObjectOutputStream out) throws IOException {\n        checkReferenceQueue();\n        Map<K, V> replacementMap = new HashMap<>(map.size());\n        for(Entry<K, R> entry : map.entrySet()) {\n            if(entry.getValue() != null) {\n                V value = entry.getValue().get();\n                if(value != null) {\n                    replacementMap.put(entry.getKey(), value);\n                }\n            }\n        }\n        out.writeObject(replacementMap);\n    }\n    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n        @SuppressWarnings(\"unchecked\")\n        Map<K, V> replacement = (Map<K, V>) in.readObject();\n        map = new HashMap<>(replacement.size());\n        referenceQueue = new ReferenceQueue<>();\n        putAll(replacement);\n    }\n    /**\n     * View over {@link #map} entry set\n     */\n    class ReferenceEntrySet extends AbstractSet<Entry<K, V>> {\n        @Override\n        public Iterator<Entry<K, V>> iterator() {\n            return new ReferenceEntryIterator();\n        }\n        @Override\n        public int size() {\n            return map.size();\n        }\n    }\n    /**\n     * Iterator used by entrySet. Wrapper around {@link #map} iterator.\n     * It fetch ahead to be sure we have valid value, or otherwise we can return cleared reference.\n     */\n    class ReferenceEntryIterator implements Iterator<Entry<K, V>> {\n        Iterator<Entry<K, R>> internalIterator;\n        Entry<K, V> next;\n        ReferenceEntryIterator() {\n            internalIterator = map.entrySet().iterator();\n            tryAdvance();\n        }\n        @Override\n        public boolean hasNext() {\n            return next != null;\n        }\n        @Override\n        public Entry<K, V> next() {\n            if(!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            Entry<K, V> result = next;\n            tryAdvance();\n            return result;\n        }\n        /**\n         * Moves ahead internalIterator and tries to find first and store nonnull reference\n         */\n        private void tryAdvance() {\n            next = null;\n            while(internalIterator.hasNext()) {\n                Entry<K, R> nextRefEntry = internalIterator.next();\n                if(nextRefEntry.getValue() == null) {\n                    // should not happen, we can't have nulls in internal map\n                    throw new IllegalStateException();\n                }\n                V value = nextRefEntry.getValue().get();\n                if(value != null) {\n                    next = new ReferenceEntry(nextRefEntry, value);\n                    break;\n                }\n            }\n        }\n    }\n    /**\n     * View over {@link Map.Entry} that transparently resolves Reference\n     */\n<fim_suffix>    class ReferenceEntry extends SimpleEntry<K, V> {\n        private static final long serialVersionUID = -1795136249842496011L;\n        Entry<K, R> refEntry;\n        public ReferenceEntry(Entry<K, R> refEntry, V value) {\n            super(refEntry.getKey(), value);\n            this.refEntry = refEntry;\n        }\n        @Override\n        public V setValue(V value) {\n            R newRef = newReference(value);\n            R oldRef = refEntry.setValue(newRef);\n            if(oldRef != null) {\n                return getValue();\n            }\n            return null;\n        }\n    }<fim_middle>// class below has no smell\n"}