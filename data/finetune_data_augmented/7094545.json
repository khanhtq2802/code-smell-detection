{"text": "<fim_prefix>/*\n * Copyright (C) 2014 The Android Open Source Project\n * Copyright (c) 2000, 2008, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage java.nio;\nimport libcore.io.Memory;\n/**\n * A read/write HeapByteBuffer.\n */\nfinal class HeapByteBuffer extends ByteBuffer {\n    // For speed these fields are actually declared in X-Buffer;\n    // these declarations are here as documentation\n    /*\n      protected final byte[] hb;\n      protected final int offset;\n    */\n    HeapByteBuffer(int cap, int lim) {            // packag-private\n        this(cap, lim, false);\n    }\n    private HeapByteBuffer(int cap, int lim, boolean isReadOnly) {\n        super(-1, 0, lim, cap, new byte[cap], 0);\n        this.isReadOnly = isReadOnly;\n    }\n    HeapByteBuffer(byte[] buf, int off, int len) { // package-private\n        this(buf, off, len, false);\n    }\n    private HeapByteBuffer(byte[] buf, int off, int len, boolean isReadOnly) {\n        super(-1, off, off + len, buf.length, buf, 0);\n        this.isReadOnly = isReadOnly;\n    }\n    private HeapByteBuffer(byte[] buf, int mark, int pos, int lim, int cap, int off,\n            boolean isReadOnly) {\n        super(mark, pos, lim, cap, buf, off);\n        this.isReadOnly = isReadOnly;\n    }\n    @Override\n    public ByteBuffer slice() {\n        return new HeapByteBuffer(hb,\n                -1,\n                0,\n                remaining(),\n                remaining(),\n                position() + offset,\n                isReadOnly);\n    }\n    @Override\n    public ByteBuffer duplicate() {\n        return new HeapByteBuffer(hb,\n                markValue(),\n                position(),\n                limit(),\n                capacity(),\n                offset,\n                isReadOnly);\n    }\n    @Override\n    public ByteBuffer asReadOnlyBuffer() {\n        return new HeapByteBuffer(hb,\n                this.markValue(),\n                this.position(),\n                this.limit(),\n                this.capacity(),\n                offset, true);\n    }\n    protected int ix(int i) {\n        return i + offset;\n    }\n    @Override\n    public byte get() {\n        return hb[ix(nextGetIndex())];\n    }\n    @Override\n    public byte get(int i) {\n        return hb[ix(checkIndex(i))];\n    }\n    @Override\n    public ByteBuffer get(byte[] dst, int offset, int length) {\n        checkBounds(offset, length, dst.length);\n        if (length > remaining())\n            throw new BufferUnderflowException();\n        System.arraycopy(hb, ix(position()), dst, offset, length);\n        position(position() + length);\n        return this;\n    }\n    @Override\n    public boolean isDirect() {\n        return false;\n    }\n    @Override\n    public boolean isReadOnly() {\n        return isReadOnly;\n    }\n<fim_suffix>    @Override\n    public ByteBuffer put(byte x) {\n        if (isReadOnly) {\n            throw new ReadOnlyBufferException();\n        }\n        hb[ix(nextPutIndex())] = x;\n        return this;\n    }\n    @Override\n    public ByteBuffer put(int i, byte x) {\n        if (isReadOnly) {\n            throw new ReadOnlyBufferException();\n        }\n        hb[ix(checkIndex(i))] = x;\n        return this;\n    }\n    @Override\n    public ByteBuffer put(byte[] src, int offset, int length) {\n        if (isReadOnly) {\n            throw new ReadOnlyBufferException();\n        }\n        checkBounds(offset, length, src.length);\n        if (length > remaining())\n            throw new BufferOverflowException();\n        System.arraycopy(src, offset, hb, ix(position()), length);\n        position(position() + length);\n        return this;\n    }\n    @Override\n    public ByteBuffer compact() {\n        if (isReadOnly) {\n            throw new ReadOnlyBufferException();\n        }\n        System.arraycopy(hb, ix(position()), hb, ix(0), remaining());\n        position(remaining());\n        limit(capacity());\n        discardMark();\n        return this;\n    }\n    @Override\n    byte _get(int i) {                          // package-private\n        return hb[i];\n    }\n    @Override\n    void _put(int i, byte b) {                  // package-private\n        if (isReadOnly) {\n            throw new ReadOnlyBufferException();\n        }\n        hb[i] = b;\n    }\n    @Override\n    public char getChar() {\n        return Bits.getChar(this, ix(nextGetIndex(2)), bigEndian);\n    }\n    @Override\n    public char getChar(int i) {\n        return Bits.getChar(this, ix(checkIndex(i, 2)), bigEndian);\n    }\n    @Override\n    char getCharUnchecked(int i) {\n        return Bits.getChar(this, ix(i), bigEndian);\n    }\n    @Override\n    void getUnchecked(int pos, char[] dst, int dstOffset, int length) {\n        Memory.unsafeBulkGet(dst, dstOffset, length * 2, hb, ix(pos), 2, !nativeByteOrder);\n    }\n    @Override\n    public ByteBuffer putChar(char x) {\n        if (isReadOnly) {\n            throw new ReadOnlyBufferException();\n        }\n        Bits.putChar(this, ix(nextPutIndex(2)), x, bigEndian);\n        return this;\n    }\n    @Override\n    public ByteBuffer putChar(int i, char x) {\n        if (isReadOnly) {\n            throw new ReadOnlyBufferException();\n        }\n        Bits.putChar(this, ix(checkIndex(i, 2)), x, bigEndian);\n        return this;\n    }\n    @Override\n    void putCharUnchecked(int i, char x) {\n        Bits.putChar(this, ix(i), x, bigEndian);\n    }\n    @Override\n    void putUnchecked(int pos, char[] src, int srcOffset, int length) {\n        Memory.unsafeBulkPut(hb, ix(pos), length * 2, src, srcOffset, 2, !nativeByteOrder);\n    }\n    @Override\n    public CharBuffer asCharBuffer() {\n        int size = this.remaining() >> 1;\n        int off = position();\n        return new ByteBufferAsCharBuffer(this,\n                -1,\n                0,\n                size,\n                size,\n                off,\n                order());\n    }\n    @Override\n    public short getShort() {\n        return Bits.getShort(this, ix(nextGetIndex(2)), bigEndian);\n    }\n    @Override\n    public short getShort(int i) {\n        return Bits.getShort(this, ix(checkIndex(i, 2)), bigEndian);\n    }\n    @Override\n    short getShortUnchecked(int i) {\n        return Bits.getShort(this, ix(i), bigEndian);\n    }\n    @Override\n    void getUnchecked(int pos, short[] dst, int dstOffset, int length) {\n        Memory.unsafeBulkGet(dst, dstOffset, length * 2, hb, ix(pos), 2, !nativeByteOrder);\n    }\n    @Override\n    public ByteBuffer putShort(short x) {\n        if (isReadOnly) {\n            throw new ReadOnlyBufferException();\n        }\n        Bits.putShort(this, ix(nextPutIndex(2)), x, bigEndian);\n        return this;\n    }\n    @Override\n    public ByteBuffer putShort(int i, short x) {\n        if (isReadOnly) {\n            throw new ReadOnlyBufferException();\n        }\n        Bits.putShort(this, ix(checkIndex(i, 2)), x, bigEndian);\n        return this;\n    }\n    @Override\n    void putShortUnchecked(int i, short x) {\n        Bits.putShort(this, ix(i), x, bigEndian);\n    }\n    @Override\n    void putUnchecked(int pos, short[] src, int srcOffset, int length) {\n        Memory.unsafeBulkPut(hb, ix(pos), length * 2, src, srcOffset, 2, !nativeByteOrder);\n    }\n    @Override<fim_middle>// function below has no smell\n"}