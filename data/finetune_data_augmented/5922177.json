{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.zeppelin.realm.jwt;\nimport java.util.Date;\nimport org.apache.commons.io.FileUtils;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.security.Groups;\nimport org.apache.shiro.authc.AuthenticationInfo;\nimport org.apache.shiro.authc.AuthenticationToken;\nimport org.apache.shiro.authc.SimpleAccount;\nimport org.apache.shiro.authz.AuthorizationInfo;\nimport org.apache.shiro.authz.SimpleAuthorizationInfo;\nimport org.apache.shiro.realm.AuthorizingRealm;\nimport org.apache.shiro.subject.PrincipalCollection;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.security.PublicKey;\nimport java.security.cert.CertificateException;\nimport java.security.cert.CertificateFactory;\nimport java.security.cert.X509Certificate;\nimport java.security.interfaces.RSAPublicKey;\nimport java.text.ParseException;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport javax.servlet.ServletException;\nimport com.nimbusds.jose.JWSObject;\nimport com.nimbusds.jose.JWSVerifier;\nimport com.nimbusds.jose.crypto.RSASSAVerifier;\nimport com.nimbusds.jwt.SignedJWT;\n/**\n * Created for org.apache.zeppelin.server.\n */\npublic class KnoxJwtRealm extends AuthorizingRealm {\n  private static final Logger LOGGER = LoggerFactory.getLogger(KnoxJwtRealm.class);\n  private String providerUrl;\n  private String redirectParam;\n  private String cookieName;\n  private String publicKeyPath;\n  private String login;\n  private String logout;\n  private Boolean logoutAPI;\n  private String principalMapping;\n  private String groupPrincipalMapping;\n  private SimplePrincipalMapper mapper = new SimplePrincipalMapper();\n  /**\n   * Configuration object needed by for Hadoop classes.\n   */\n  private Configuration hadoopConfig;\n  /**\n   * Hadoop Groups implementation.\n   */\n  private Groups hadoopGroups;\n  @Override\n  protected void onInit() {\n    super.onInit();\n    if (principalMapping != null && !principalMapping.isEmpty()\n        || groupPrincipalMapping != null && !groupPrincipalMapping.isEmpty()) {\n      try {\n        mapper.loadMappingTable(principalMapping, groupPrincipalMapping);\n      } catch (PrincipalMappingException e) {\n        LOGGER.error(\"PrincipalMappingException in onInit\", e);\n      }\n    }\n    try {\n      hadoopConfig = new Configuration();\n      hadoopGroups = new Groups(hadoopConfig);\n    } catch (final Exception e) {\n      LOGGER.error(\"Exception in onInit\", e);\n    }\n  }\n  @Override\n  public boolean supports(AuthenticationToken token) {\n    return token != null && token instanceof JWTAuthenticationToken;\n  }\n  @Override\n  protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) {\n    JWTAuthenticationToken upToken = (JWTAuthenticationToken) token;\n    if (validateToken(upToken.getToken())) {\n      try {\n        SimpleAccount account = new SimpleAccount(getName(upToken), upToken.getToken(), getName());\n        account.addRole(mapGroupPrincipals(getName(upToken)));\n        return account;\n      } catch (ParseException e) {\n        LOGGER.error(\"ParseException in doGetAuthenticationInfo\", e);\n      }\n    }\n    return null;\n  }\n  public String getName(JWTAuthenticationToken upToken) throws ParseException {\n    SignedJWT signed = SignedJWT.parse(upToken.getToken());\n    String userName = signed.getJWTClaimsSet().getSubject();\n    return userName;\n  }\n<fim_suffix>  protected boolean validateToken(String token) {\n    try {\n      SignedJWT signed = SignedJWT.parse(token);\n      boolean sigValid = validateSignature(signed);\n      if (!sigValid) {\n        LOGGER.warn(\"Signature of JWT token could not be verified. Please check the public key\");\n        return false;\n      }\n      boolean expValid = validateExpiration(signed);\n      if (!expValid) {\n        LOGGER.warn(\"Expiration time validation of JWT token failed.\");\n        return false;\n      }\n      String currentUser = (String) org.apache.shiro.SecurityUtils.getSubject().getPrincipal();\n      if (currentUser == null) {\n        return true;\n      }\n      String cookieUser = signed.getJWTClaimsSet().getSubject();\n      if (!cookieUser.equals(currentUser)) {\n        return false;\n      }\n      return true;\n    } catch (ParseException ex) {\n      LOGGER.info(\"ParseException in validateToken\", ex);\n      return false;\n    }\n  }\n  public static RSAPublicKey parseRSAPublicKey(String pem) throws IOException, ServletException {\n    final String pemHeader = \"-----BEGIN CERTIFICATE-----\\n\";\n    final String pemFooter = \"\\n-----END CERTIFICATE-----\";\n    String fullPem = pemHeader + pem + pemFooter;\n    PublicKey key = null;\n    try {\n      CertificateFactory fact = CertificateFactory.getInstance(\"X.509\");\n      ByteArrayInputStream is = new ByteArrayInputStream(\n          FileUtils.readFileToString(new File(pem)).getBytes(\"UTF8\"));\n      X509Certificate cer = (X509Certificate) fact.generateCertificate(is);\n      key = cer.getPublicKey();\n    } catch (CertificateException ce) {\n      String message = null;\n      if (pem.startsWith(pemHeader)) {\n        message = \"CertificateException - be sure not to include PEM header \"\n            + \"and footer in the PEM configuration element.\";\n      } else {\n        message = \"CertificateException - PEM may be corrupt\";\n      }\n      throw new ServletException(message, ce);\n    } catch (UnsupportedEncodingException uee) {\n      throw new ServletException(uee);\n    } catch (IOException e) {\n      throw new IOException(e);\n    }\n    return (RSAPublicKey) key;\n  }\n  protected boolean validateSignature(SignedJWT jwtToken) {\n    boolean valid = false;\n    if (JWSObject.State.SIGNED == jwtToken.getState()) {\n      if (jwtToken.getSignature() != null) {\n        try {\n          RSAPublicKey publicKey = parseRSAPublicKey(publicKeyPath);\n          JWSVerifier verifier = new RSASSAVerifier(publicKey);\n          if (verifier != null && jwtToken.verify(verifier)) {\n            valid = true;\n          }\n        } catch (Exception e) {\n          LOGGER.info(\"Exception in validateSignature\", e);\n        }\n      }\n    }\n    return valid;\n  }\n  /**\n   * Validate that the expiration time of the JWT token has not been violated.\n   * If it has then throw an AuthenticationException. Override this method in\n   * subclasses in order to customize the expiration validation behavior.\n   *\n   * @param jwtToken\n   *            the token that contains the expiration date to validate\n   * @return valid true if the token has not expired; false otherwise\n   */\n  protected boolean validateExpiration(SignedJWT jwtToken) {\n    boolean valid = false;\n    try {\n      Date expires = jwtToken.getJWTClaimsSet().getExpirationTime();\n      if (expires == null || new Date().before(expires)) {\n        if (LOGGER.isDebugEnabled()) {\n          LOGGER.debug(\"SSO token expiration date has been \" + \"successfully validated\");\n        }\n        valid = true;\n      } else {\n        LOGGER.warn(\"SSO expiration date validation failed.\");\n      }\n    } catch (ParseException pe) {\n      LOGGER.warn(\"SSO expiration date validation failed.\", pe);\n    }\n    return valid;\n  }\n  @Override\n  protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {\n    Set<String> roles = mapGroupPrincipals(principals.toString());\n    return new SimpleAuthorizationInfo(roles);\n  }\n  /**\n   * Query the Hadoop implementation of {@link Groups} to retrieve groups for provided user.\n   */\n  public Set<String> mapGroupPrincipals(final String mappedPrincipalName) {\n    /* return the groups as seen by Hadoop */\n    Set<String> groups = null;\n    try {\n      hadoopGroups.refresh();\n      final List<String> groupList = hadoopGroups\n          .getGroups(mappedPrincipalName);\n      if (LOGGER.isDebugEnabled()) {\n        LOGGER.debug(String.format(\"group found %s, %s\",\n            mappedPrincipalName, groupList.toString()));\n      }\n      groups = new HashSet<>(groupList);<fim_middle>// function below has no smell\n"}