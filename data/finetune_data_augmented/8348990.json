{"text": "<fim_prefix>\t\t// we remember if we found one @AJ annotation for minimal semantic error\n\t\t// reporting\n\t\t// the real reporting beeing done thru AJDT and the compiler mapping @AJ\n\t\t// to AjAtttribute\n\t\t// or thru APT\n\t\t//\n\t\t// Note: we could actually skip the whole thing if type is not itself an\n\t\t// @Aspect\n\t\t// but then we would not see any warning. We do bypass for pointcut but\n\t\t// not for advice since it would\n\t\t// be too silent.\n\t\tboolean hasAtAspectJAnnotation = false;\n\t\tboolean hasAtAspectJAnnotationMustReturnVoid = false;\n\t\tfor (int i = 0; i < attributes.length; i++) {\n\t\t\tAttribute attribute = attributes[i];\n\t\t\ttry {\n\t\t\t\tif (acceptAttribute(attribute)) {\n\t\t\t\t\tRuntimeAnnos rvs = (RuntimeAnnos) attribute;\n\t\t\t\t\thasAtAspectJAnnotationMustReturnVoid = hasAtAspectJAnnotationMustReturnVoid\n\t\t\t\t\t\t\t|| handleBeforeAnnotation(rvs, struct, preResolvedPointcut);\n\t\t\t\t\thasAtAspectJAnnotationMustReturnVoid = hasAtAspectJAnnotationMustReturnVoid\n\t\t\t\t\t\t\t|| handleAfterAnnotation(rvs, struct, preResolvedPointcut);\n\t\t\t\t\thasAtAspectJAnnotationMustReturnVoid = hasAtAspectJAnnotationMustReturnVoid\n\t\t\t\t\t\t\t|| handleAfterReturningAnnotation(rvs, struct, preResolvedPointcut, bMethod);\n\t\t\t\t\thasAtAspectJAnnotationMustReturnVoid = hasAtAspectJAnnotationMustReturnVoid\n\t\t\t\t\t\t\t|| handleAfterThrowingAnnotation(rvs, struct, preResolvedPointcut, bMethod);\n\t\t\t\t\thasAtAspectJAnnotation = hasAtAspectJAnnotation || handleAroundAnnotation(rvs, struct, preResolvedPointcut);\n\t\t\t\t\t// there can only be one RuntimeVisible bytecode attribute\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} catch (ReturningFormalNotDeclaredInAdviceSignatureException e) {\n\t\t\t\tmsgHandler.handleMessage(new Message(WeaverMessages.format(WeaverMessages.RETURNING_FORMAL_NOT_DECLARED_IN_ADVICE,\n\t\t\t\t\t\te.getFormalName()), IMessage.ERROR, null, bMethod.getSourceLocation()));\n\t\t\t} catch (ThrownFormalNotDeclaredInAdviceSignatureException e) {\n\t\t\t\tmsgHandler.handleMessage(new Message(WeaverMessages.format(WeaverMessages.THROWN_FORMAL_NOT_DECLARED_IN_ADVICE,\n\t\t\t\t\t\te.getFormalName()), IMessage.ERROR, null, bMethod.getSourceLocation()));\n\t\t\t}\n\t\t}\n\t\thasAtAspectJAnnotation = hasAtAspectJAnnotation || hasAtAspectJAnnotationMustReturnVoid;\n\t\t// semantic check - must be in an @Aspect [remove if previous block\n\t\t// bypassed in advance]\n\t\tif (hasAtAspectJAnnotation && !type.isAspect()) { // isAnnotationStyleAspect())\n\t\t\t// {\n\t\t\tmsgHandler.handleMessage(new Message(\"Found @AspectJ annotations in a non @Aspect type '\" + type.getName() + \"'\",\n\t\t\t\t\tIMessage.WARNING, null, type.getSourceLocation()));\n\t\t\t// go ahead\n\t\t}\n\t\t// semantic check - advice must be public\n\t\tif (hasAtAspectJAnnotation && !struct.method.isPublic()) {\n\t\t\tmsgHandler.handleMessage(new Message(\"Found @AspectJ annotation on a non public advice '\"\n\t\t\t\t\t+ methodToString(struct.method) + \"'\", IMessage.ERROR, null, type.getSourceLocation()));\n\t\t\t// go ahead\n\t\t}\n\t\t// semantic check - advice must not be static\n\t\tif (hasAtAspectJAnnotation && struct.method.isStatic()) {\n\t\t\tmsgHandler.handleMessage(MessageUtil.error(\"Advice cannot be declared static '\" + methodToString(struct.method) + \"'\",\n\t\t\t\t\ttype.getSourceLocation()));\n\t\t\t// new Message(\n\t\t\t// \"Advice cannot be declared static '\" +\n\t\t\t// methodToString(struct.method) + \"'\",\n\t\t\t// IMessage.ERROR,\n\t\t\t// null,\n\t\t\t// type.getSourceLocation()\n\t\t\t// )\n\t\t\t// );\n\t\t\t// go ahead\n\t\t}\n\t\t// semantic check for non around advice must return void\n\t\tif (hasAtAspectJAnnotationMustReturnVoid && !Type.VOID.equals(struct.method.getReturnType())) {\n\t\t\tmsgHandler.handleMessage(new Message(\"Found @AspectJ annotation on a non around advice not returning void '\"\n\t\t\t\t\t+ methodToString(struct.method) + \"'\", IMessage.ERROR, null, type.getSourceLocation()));\n\t\t\t// go ahead\n\t\t}\n\t\treturn struct.ajAttributes;\n\t}\n\t/**\n\t * Extract field level annotations and turn them into AjAttributes.\n\t * \n\t * @param field\n\t * @param type\n\t * @param context\n\t * @param msgHandler\n\t * @return list of AjAttributes, always empty for now\n\t */\n\tpublic static List<AjAttribute> readAj5FieldAttributes(Field field, BcelField bField, ResolvedType type,\n\t\t\tISourceContext context, IMessageHandler msgHandler) {\n\t\t// Note: field annotation are for ITD and DEOW - processed at class\n\t\t// level directly\n\t\treturn Collections.emptyList();\n\t}\n\t/**\n\t * Read @Aspect\n\t * \n\t * @param runtimeAnnotations\n\t * @param struct\n\t * @return true if found\n\t */\n<fim_suffix>\tprivate static boolean handleAspectAnnotation(RuntimeAnnos runtimeAnnotations, AjAttributeStruct struct) {\n\t\tAnnotationGen aspect = getAnnotation(runtimeAnnotations, AjcMemberMaker.ASPECT_ANNOTATION);\n\t\tif (aspect != null) {\n\t\t\t// semantic check for inheritance (only one level up)\n\t\t\tboolean extendsAspect = false;\n\t\t\tif (!\"java.lang.Object\".equals(struct.enclosingType.getSuperclass().getName())) {\n\t\t\t\tif (!struct.enclosingType.getSuperclass().isAbstract() && struct.enclosingType.getSuperclass().isAspect()) {\n\t\t\t\t\treportError(\"cannot extend a concrete aspect\", struct);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\textendsAspect = struct.enclosingType.getSuperclass().isAspect();\n\t\t\t}\n\t\t\tNameValuePair aspectPerClause = getAnnotationElement(aspect, VALUE);\n\t\t\tfinal PerClause perClause;\n\t\t\tif (aspectPerClause == null) {\n\t\t\t\t// empty value means singleton unless inherited\n\t\t\t\tif (!extendsAspect) {\n\t\t\t\t\tperClause = new PerSingleton();\n\t\t\t\t} else {\n\t\t\t\t\tperClause = new PerFromSuper(struct.enclosingType.getSuperclass().getPerClause().getKind());\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tString perX = aspectPerClause.getValue().stringifyValue();\n\t\t\t\tif (perX == null || perX.length() <= 0) {\n\t\t\t\t\tperClause = new PerSingleton();\n\t\t\t\t} else {\n\t\t\t\t\tperClause = parsePerClausePointcut(perX, struct);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (perClause == null) {\n\t\t\t\t// could not parse it, ignore the aspect\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tperClause.setLocation(struct.context, -1, -1);// struct.context.getOffset(),\n\t\t\t\t// struct.context.getOffset()+1);//FIXME\n\t\t\t\t// AVASM\n\t\t\t\t// Not setting version here\n\t\t\t\t// struct.ajAttributes.add(new AjAttribute.WeaverVersionInfo());\n\t\t\t\tAjAttribute.Aspect aspectAttribute = new AjAttribute.Aspect(perClause);\n\t\t\t\tstruct.ajAttributes.add(aspectAttribute);\n\t\t\t\tFormalBinding[] bindings = new org.aspectj.weaver.patterns.FormalBinding[0];\n\t\t\t\tfinal IScope binding;\n\t\t\t\tbinding = new BindingScope(struct.enclosingType, struct.context, bindings);\n\t\t\t\t// // we can't resolve here since the perclause typically refers\n\t\t\t\t// to pointcuts\n\t\t\t\t// // defined in the aspect that we haven't told the\n\t\t\t\t// BcelObjectType about yet.\n\t\t\t\t//\n\t\t\t\t// perClause.resolve(binding);\n\t\t\t\t// so we prepare to do it later...\n\t\t\t\taspectAttribute.setResolutionScope(binding);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}<fim_middle>// function below is long method\n"}