{"text": "<fim_prefix>      private final long meanPartitionSize;\n      private final BigInteger rangeStart;\n      private final BigInteger rangeEnd;\n      TokenRange(\n          long partitionCount, long meanPartitionSize, BigInteger rangeStart, BigInteger rangeEnd) {\n        this.partitionCount = partitionCount;\n        this.meanPartitionSize = meanPartitionSize;\n        this.rangeStart = rangeStart;\n        this.rangeEnd = rangeEnd;\n      }\n    }\n    private class CassandraReader extends BoundedSource.BoundedReader<T> {\n      private final CassandraIO.CassandraSource<T> source;\n      private Cluster cluster;\n      private Session session;\n      private Iterator<T> iterator;\n      private T current;\n      CassandraReader(CassandraSource<T> source) {\n        this.source = source;\n      }\n      @Override\n      public boolean start() {\n        LOG.debug(\"Starting Cassandra reader\");\n        cluster =\n            getCluster(\n                source.spec.hosts(),\n                source.spec.port(),\n                source.spec.username(),\n                source.spec.password(),\n                source.spec.localDc(),\n                source.spec.consistencyLevel());\n        session = cluster.connect(source.spec.keyspace().get());\n        LOG.debug(\"Queries: \" + source.splitQueries);\n        List<ResultSetFuture> futures = new ArrayList<>();\n        for (String query : source.splitQueries) {\n          futures.add(session.executeAsync(query));\n        }\n        final MappingManager mappingManager = new MappingManager(session);\n        Mapper mapper = mappingManager.mapper(source.spec.entity());\n        for (ResultSetFuture result : futures) {\n          if (iterator == null) {\n            iterator = mapper.map(result.getUninterruptibly()).iterator();\n          } else {\n            iterator =\n                Iterators.concat(iterator, mapper.map(result.getUninterruptibly()).iterator());\n          }\n        }\n        return advance();\n      }\n      @Override\n      public boolean advance() {\n        if (iterator.hasNext()) {\n          current = iterator.next();\n          return true;\n        }\n        current = null;\n        return false;\n      }\n      @Override\n      public void close() {\n        LOG.debug(\"Closing Cassandra reader\");\n        if (session != null) {\n          session.close();\n        }\n        if (cluster != null) {\n          cluster.close();\n        }\n      }\n      @Override\n      public T getCurrent() throws NoSuchElementException {\n        if (current == null) {\n          throw new NoSuchElementException();\n        }\n        return current;\n      }\n      @Override\n      public CassandraIO.CassandraSource<T> getCurrentSource() {\n        return source;\n      }\n    }\n  }\n  /** Specify the mutation type: either write or delete. */\n  public enum MutationType {\n    WRITE,\n    DELETE\n  }\n  /**\n   * A {@link PTransform} to mutate into Apache Cassandra. See {@link CassandraIO} for details on\n   * usage and configuration.\n   */\n  @AutoValue\n  public abstract static class Write<T> extends PTransform<PCollection<T>, PDone> {\n    @Nullable\n    abstract List<String> hosts();\n    @Nullable\n    abstract Integer port();\n    @Nullable\n    abstract String keyspace();\n    @Nullable\n    abstract Class<T> entity();\n    @Nullable\n    abstract String username();\n    @Nullable\n    abstract String password();\n    @Nullable\n    abstract String localDc();\n    @Nullable\n    abstract String consistencyLevel();\n    abstract MutationType mutationType();\n    abstract Builder<T> builder();\n    static <T> Builder<T> builder(MutationType mutationType) {\n      return new AutoValue_CassandraIO_Write.Builder<T>().setMutationType(mutationType);\n    }\n    /** Specify the Cassandra instance hosts where to write data. */\n    public Write<T> withHosts(List<String> hosts) {\n      checkArgument(\n          hosts != null,\n          \"CassandraIO.\" + getMutationTypeName() + \"().withHosts(hosts) called with null hosts\");\n      checkArgument(\n          !hosts.isEmpty(),\n          \"CassandraIO.\"\n              + getMutationTypeName()\n              + \"().withHosts(hosts) called with empty \"\n              + \"hosts list\");\n      return builder().setHosts(hosts).build();\n    }\n    /** Specify the Cassandra instance port number where to write data. */\n    public Write<T> withPort(int port) {\n      checkArgument(\n          port > 0,\n          \"CassandraIO.\"\n              + getMutationTypeName()\n              + \"().withPort(port) called with invalid port \"\n              + \"number (%s)\",\n          port);\n      return builder().setPort(port).build();\n    }\n    /** Specify the Cassandra keyspace where to write data. */\n    public Write<T> withKeyspace(String keyspace) {\n      checkArgument(\n          keyspace != null,\n          \"CassandraIO.\"\n              + getMutationTypeName()\n              + \"().withKeyspace(keyspace) called with \"\n              + \"null keyspace\");\n      return builder().setKeyspace(keyspace).build();\n    }\n    /**\n     * Specify the entity class in the input {@link PCollection}. The {@link CassandraIO} will map\n     * this entity to the Cassandra table thanks to the annotations.\n     */\n    public Write<T> withEntity(Class<T> entity) {\n      checkArgument(\n          entity != null,\n          \"CassandraIO.\"\n              + getMutationTypeName()\n              + \"().withEntity(entity) called with null \"\n              + \"entity\");\n      return builder().setEntity(entity).build();\n    }\n    /** Specify the username used for authentication. */\n    public Write<T> withUsername(String username) {\n      checkArgument(\n          username != null,\n          \"CassandraIO.\"\n              + getMutationTypeName()\n              + \"().withUsername(username) called with \"\n              + \"null username\");\n      return builder().setUsername(username).build();\n    }\n    /** Specify the password used for authentication. */\n    public Write<T> withPassword(String password) {\n      checkArgument(\n          password != null,\n          \"CassandraIO.\"\n              + getMutationTypeName()\n              + \"().withPassword(password) called with \"\n              + \"null password\");\n      return builder().setPassword(password).build();\n    }\n    /** Specify the local DC used by the load balancing policy. */\n    public Write<T> withLocalDc(String localDc) {\n      checkArgument(\n          localDc != null,\n          \"CassandraIO.\"\n              + getMutationTypeName()\n              + \"().withLocalDc(localDc) called with null\"\n              + \" localDc\");\n      return builder().setLocalDc(localDc).build();\n    }\n    public Write<T> withConsistencyLevel(String consistencyLevel) {\n      checkArgument(\n          consistencyLevel != null,\n          \"CassandraIO.\"\n              + getMutationTypeName()\n              + \"().withConsistencyLevel\"\n              + \"(consistencyLevel) called with null consistencyLevel\");\n      return builder().setConsistencyLevel(consistencyLevel).build();\n    }\n    @Override\n    public void validate(PipelineOptions pipelineOptions) {\n      checkState(\n          hosts() != null,\n          \"CassandraIO.\"\n              + getMutationTypeName()\n              + \"() requires a list of hosts to be set via withHosts(hosts)\");\n      checkState(\n          port() != null,\n          \"CassandraIO.\"\n              + getMutationTypeName()\n              + \"() requires a \"\n              + \"valid port number to be set via withPort(port)\");\n      checkState(\n          keyspace() != null,\n          \"CassandraIO.\"\n              + getMutationTypeName()\n              + \"() requires a keyspace to be set via \"\n              + \"withKeyspace(keyspace)\");\n      checkState(\n          entity() != null,\n          \"CassandraIO.\"\n              + getMutationTypeName()\n              + \"() requires an entity to be set via \"\n              + \"withEntity(entity)\");\n    }\n    @Override\n    public PDone expand(PCollection<T> input) {\n      if (mutationType() == MutationType.DELETE) {\n        input.apply(ParDo.of(new DeleteFn<>(this)));\n      } else {\n        input.apply(ParDo.of(new WriteFn<>(this)));\n      }\n      return PDone.in(input.getPipeline());\n    }\n    private String getMutationTypeName() {\n      return mutationType() == null\n          ? MutationType.WRITE.name().toLowerCase()\n          : mutationType().name().toLowerCase();\n    }\n<fim_suffix>    @AutoValue.Builder\n    abstract static class Builder<T> {\n      abstract Builder<T> setHosts(List<String> hosts);\n      abstract Builder<T> setPort(Integer port);\n      abstract Builder<T> setKeyspace(String keyspace);\n      abstract Builder<T> setEntity(Class<T> entity);\n      abstract Builder<T> setUsername(String username);\n      abstract Builder<T> setPassword(String password);\n      abstract Builder<T> setLocalDc(String localDc);\n      abstract Builder<T> setConsistencyLevel(String consistencyLevel);\n      abstract Builder<T> setMutationType(MutationType mutationType);\n      abstract Write<T> build();\n    }<fim_middle>// class below is data class\n"}