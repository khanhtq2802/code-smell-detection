{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.sjms.producer;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.Exchanger;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport javax.jms.Connection;\nimport javax.jms.Destination;\nimport javax.jms.Message;\nimport javax.jms.MessageConsumer;\nimport javax.jms.MessageListener;\nimport javax.jms.Session;\nimport org.apache.camel.AsyncCallback;\nimport org.apache.camel.CamelException;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.component.sjms.MessageConsumerResources;\nimport org.apache.camel.component.sjms.MessageProducerResources;\nimport org.apache.camel.component.sjms.SjmsEndpoint;\nimport org.apache.camel.component.sjms.SjmsMessage;\nimport org.apache.camel.component.sjms.SjmsProducer;\nimport org.apache.camel.component.sjms.jms.ConnectionResource;\nimport org.apache.camel.component.sjms.jms.DestinationNameParser;\nimport org.apache.camel.component.sjms.jms.JmsConstants;\nimport org.apache.camel.component.sjms.jms.JmsMessageHelper;\nimport org.apache.camel.spi.UuidGenerator;\nimport org.apache.camel.util.ObjectHelper;\nimport org.apache.commons.pool.BasePoolableObjectFactory;\nimport org.apache.commons.pool.impl.GenericObjectPool;\n/**\n * A Camel Producer that provides the InOut Exchange pattern.\n */\npublic class InOutProducer extends SjmsProducer {\n    private static final Map<String, Exchanger<Object>> EXCHANGERS = new ConcurrentHashMap<>();\n    private static final String GENERATED_CORRELATION_ID_PREFIX = \"Camel-\";\n    private UuidGenerator uuidGenerator;\n    private GenericObjectPool<MessageConsumerResources> consumers;\n    public InOutProducer(final SjmsEndpoint endpoint) {\n        super(endpoint);\n    }\n    public UuidGenerator getUuidGenerator() {\n        return uuidGenerator;\n    }\n    public void setUuidGenerator(UuidGenerator uuidGenerator) {\n        this.uuidGenerator = uuidGenerator;\n    }\n    /**\n     * A pool of {@link MessageConsumerResources} objects that are the reply consumers.\n     */\n<fim_suffix>    protected class MessageConsumerResourcesFactory extends BasePoolableObjectFactory<MessageConsumerResources> {\n        @Override\n        public MessageConsumerResources makeObject() throws Exception {\n            MessageConsumerResources answer;\n            ConnectionResource connectionResource = getOrCreateConnectionResource();\n            Connection conn = connectionResource.borrowConnection();\n            try {\n                Session session;\n                if (isEndpointTransacted()) {\n                    session = conn.createSession(true, Session.SESSION_TRANSACTED);\n                } else {\n                    session = conn.createSession(false, Session.AUTO_ACKNOWLEDGE);\n                }\n                Destination replyToDestination;\n                boolean isReplyToTopic = false;\n                if (ObjectHelper.isEmpty(getNamedReplyTo())) {\n                    isReplyToTopic = isTopic();\n                    replyToDestination = getEndpoint().getDestinationCreationStrategy().createTemporaryDestination(session, isReplyToTopic);\n                } else {\n                    DestinationNameParser parser = new DestinationNameParser();\n                    isReplyToTopic = parser.isNamedReplyToTopic(getNamedReplyTo(), isTopic());\n                    replyToDestination = getEndpoint().getDestinationCreationStrategy().createDestination(session, getNamedReplyTo(), isReplyToTopic);\n                }\n                MessageConsumer messageConsumer = getEndpoint().getJmsObjectFactory().createMessageConsumer(session, replyToDestination, null, isReplyToTopic, null, true, false, false);\n                messageConsumer.setMessageListener(new MessageListener() {\n                    @Override\n                    public void onMessage(final Message message) {\n                        log.debug(\"Message Received in the Consumer Pool\");\n                        log.debug(\"  Message : {}\", message);\n                        try {\n                            Exchanger<Object> exchanger = EXCHANGERS.get(message.getJMSCorrelationID());\n                            exchanger.exchange(message, getResponseTimeOut(), TimeUnit.MILLISECONDS);\n                        } catch (Exception e) {\n                            log.warn(\"Unable to exchange message: {}. This exception is ignored.\", message, e);\n                        }\n                    }\n                });\n                answer = new MessageConsumerResources(session, messageConsumer, replyToDestination);\n            } catch (Exception e) {\n                log.error(\"Unable to create the MessageConsumerResource: {}\", e.getLocalizedMessage());\n                throw new CamelException(e);\n            } finally {\n                connectionResource.returnConnection(conn);\n            }\n            return answer;\n        }\n        @Override\n        public void destroyObject(MessageConsumerResources model) throws Exception {\n            if (model.getMessageConsumer() != null) {\n                model.getMessageConsumer().close();\n            }\n            if (model.getSession() != null) {\n                if (model.getSession().getTransacted()) {\n                    try {\n                        model.getSession().rollback();\n                    } catch (Exception e) {\n                        // Do nothing. Just make sure we are cleaned up\n                    }\n                }\n                model.getSession().close();\n            }\n        }\n    }\n    @Override\n    protected void doStart() throws Exception {\n        if (isEndpointTransacted()) {\n            throw new IllegalArgumentException(\"InOut exchange pattern is incompatible with transacted=true as it cause a deadlock. Please use transacted=false or InOnly exchange pattern.\");\n        }\n        if (ObjectHelper.isEmpty(getNamedReplyTo())) {\n            log.debug(\"No reply to destination is defined. Using temporary destinations.\");\n        } else {\n            log.debug(\"Using {} as the reply to destination.\", getNamedReplyTo());\n        }\n        if (uuidGenerator == null) {\n            // use the generator configured on the camel context\n            uuidGenerator = getEndpoint().getCamelContext().getUuidGenerator();\n        }\n        if (consumers == null) {\n            consumers = new GenericObjectPool<>(new MessageConsumerResourcesFactory());\n            consumers.setMaxActive(getConsumerCount());\n            consumers.setMaxIdle(getConsumerCount());\n            while (consumers.getNumIdle() < consumers.getMaxIdle()) {\n                consumers.addObject();\n            }\n        }\n        super.doStart();\n    }\n    @Override\n    protected void doStop() throws Exception {\n        super.doStop();\n        if (consumers != null) {\n            consumers.close();\n            consumers = null;\n        }\n    }\n    /**\n     * TODO time out is actually double as it waits for the producer and then\n     * waits for the response. Use an atomic long to manage the countdown\n     */\n    @Override\n    public void sendMessage(final Exchange exchange, final AsyncCallback callback, final MessageProducerResources producer, final ReleaseProducerCallback releaseProducerCallback) throws Exception {\n        Message request = getEndpoint().getBinding().makeJmsMessage(exchange, producer.getSession());\n        String correlationId = exchange.getIn().getHeader(JmsConstants.JMS_CORRELATION_ID, String.class);\n        if (correlationId == null) {\n            // we append the 'Camel-' prefix to know it was generated by us\n            correlationId = GENERATED_CORRELATION_ID_PREFIX + getUuidGenerator().generateUuid();\n        }\n        Object responseObject = null;\n        Exchanger<Object> messageExchanger = new Exchanger<>();\n        JmsMessageHelper.setCorrelationId(request, correlationId);\n        EXCHANGERS.put(correlationId, messageExchanger);\n        MessageConsumerResources consumer = consumers.borrowObject();\n        JmsMessageHelper.setJMSReplyTo(request, consumer.getReplyToDestination());\n        consumers.returnObject(consumer);\n        producer.getMessageProducer().send(request);\n        // Return the producer to the pool so another waiting producer\n        // can move forward\n        // without waiting on us to complete the exchange\n        try {\n            releaseProducerCallback.release(producer);\n        } catch (Exception exception) {\n            // thrown if the pool is full. safe to ignore.\n        }\n        try {\n            responseObject = messageExchanger.exchange(null, getResponseTimeOut(), TimeUnit.MILLISECONDS);\n            EXCHANGERS.remove(correlationId);\n        } catch (InterruptedException e) {\n            log.debug(\"Exchanger was interrupted while waiting on response\", e);\n            exchange.setException(e);\n        } catch (TimeoutException e) {\n            log.debug(\"Exchanger timed out while waiting on response\", e);\n            exchange.setException(e);\n        }\n        if (exchange.getException() == null) {<fim_middle>// class below has no smell\n"}