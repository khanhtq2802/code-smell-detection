{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.jena.sparql.expr;\n\nimport java.util.* ;\n\nimport org.apache.jena.sparql.algebra.walker.Walker ;\nimport org.apache.jena.sparql.core.Var ;\nimport org.apache.jena.sparql.engine.ExecutionContext ;\nimport org.apache.jena.sparql.engine.binding.Binding ;\nimport org.apache.jena.sparql.graph.NodeTransform;\nimport org.apache.jena.sparql.util.Context ;\n\n<fim_suffix>public class ExprList implements Iterable<Expr>\n{\n    private final List<Expr> expressions ;\n    /** Create a copy which does not share the list of expressions with the original */ \n    public static ExprList copy(ExprList other) { return new ExprList(other) ; }\n    \n    /** Create an ExprList that contains the expressions */\n    public static ExprList create(Collection<Expr> exprs) {\n        ExprList exprList = new ExprList() ;\n        exprs.forEach(exprList::add) ;\n        return exprList ; \n    } \n    \n    /** Empty, immutable ExprList */\n    public static final ExprList emptyList = new ExprList(Collections.emptyList()) ;\n    \n    public ExprList() { expressions = new ArrayList<>() ; }\n    \n    private ExprList(ExprList other) {\n        this() ;\n        expressions.addAll(other.expressions) ;\n    }\n\n    public ExprList(Expr expr) {\n        this() ;\n        expressions.add(expr) ;\n    }\n\n    public ExprList(List<Expr> x)   { expressions = x ; }\n\n    public boolean isSatisfied(Binding binding, ExecutionContext execCxt) {\n        for (Expr expr : expressions) {\n            if ( !expr.isSatisfied(binding, execCxt) )\n                return false ;\n        }\n        return true ;\n    }\n    \n    public Expr get(int idx)                            { return expressions.get(idx) ; }\n    public int size()                                   { return expressions.size() ; }\n    public boolean isEmpty()                            { return expressions.isEmpty() ; }\n    public ExprList subList(int fromIdx, int toIdx)     { return new ExprList(expressions.subList(fromIdx, toIdx)) ; }\n    public ExprList tail(int fromIdx)                   { return subList(fromIdx, expressions.size()) ; }\n    \n    public Set<Var> getVarsMentioned() {\n        Set<Var> x = new HashSet<>() ;\n        varsMentioned(x) ;\n        return x ;\n    }\n\n    /** @deprecated Use {@link ExprVars#varsMentioned(Collection, ExprList)} */\n    @Deprecated\n    public void varsMentioned(Collection<Var> acc) {\n        for (Expr expr : expressions)\n            ExprVars.varsMentioned(acc, expr);\n    }\n    \n    /**\n     * Rewrite, applying a node{@literal ->}node transformation\n     */\n    public ExprList applyNodeTransform(NodeTransform transform) {\n        ExprList x = new ExprList() ;\n        for ( Expr e : expressions)\n            x.add(e.applyNodeTransform(transform));\n        return x ; \n    }\n\n    public ExprList copySubstitute(Binding binding) {\n        ExprList x = new ExprList() ;\n        for (Expr expr : expressions ) {\n            expr = expr.copySubstitute(binding) ;\n            x.add(expr) ;\n        }\n        return x ;\n    }\n\n    public void addAll(ExprList exprs)      { expressions.addAll(exprs.getList()) ; }\n    public void add(Expr expr)              { expressions.add(expr) ; }\n    public List<Expr> getList()             { return Collections.unmodifiableList(expressions) ; }\n    /** Use only while building ExprList */\n    public List<Expr> getListRaw()          { return expressions ; }\n    @Override\n    public Iterator<Expr> iterator()        { return expressions.iterator() ; }\n    \n    public void prepareExprs(Context context) {\n        ExprBuild build = new ExprBuild(context) ;\n        // Give each expression the chance to set up (bind functions)\n        for (Expr expr : expressions)\n            Walker.walk(expr, build) ;\n    }\n    \n    @Override\n    public String toString()\n    { return expressions.toString() ; }\n    \n    @Override\n    public int hashCode() { return expressions.hashCode() ; }\n\n    public boolean equals(ExprList other, boolean bySyntax) {\n        if ( this == other ) return true ;\n        if (expressions.size() != other.expressions.size()) return false;\n        \n        for ( int i = 0 ; i < expressions.size() ; i++ ) {\n            Expr e1 = expressions.get(i) ;\n            Expr e2 = other.expressions.get(i) ;\n            if ( ! e1.equals(e2, bySyntax) ) \n                return false ;\n        }\n        return true ;\n    }\n    \n    @Override\n    public boolean equals(Object other) {\n        if ( this == other ) return true ;\n        if ( ! ( other instanceof ExprList ) ) return false ;\n        ExprList exprs = (ExprList)other ;\n        //return expressions.equals(exprs.expressions) ;\n        return equals((ExprList)other, false) ;\n    }\n\n    public static ExprList splitConjunction(ExprList exprList1) {\n        ExprList exprList2 = new ExprList() ;\n        for (Expr expr : exprList1)\n            split(exprList2, expr) ;\n        return exprList2 ;\n    }\n\n    private static ExprList splitConjunction(Expr expr) {\n        ExprList exprList = new ExprList() ;\n        split(exprList, expr) ;\n        return exprList ;\n    }\n\n    private static void split(ExprList exprList, Expr expr) {\n        // Explode &&-chain to exprlist.\n        while (expr instanceof E_LogicalAnd) {\n            E_LogicalAnd x = (E_LogicalAnd)expr ;\n            Expr left = x.getArg1() ;\n            Expr right = x.getArg2() ;\n            split(exprList, left) ;\n            expr = right ;\n        }\n        // Drop through and add remaining\n        exprList.add(expr) ;\n    }\n}<fim_middle>// class below is blob\n"}