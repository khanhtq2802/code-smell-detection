{"text": "<fim_prefix>\n<fim_suffix>public class DebugInfoDecoder {\n    /** encoded debug info */\n    private final byte[] encoded;\n    /** positions decoded */\n    private final ArrayList<PositionEntry> positions;\n    /** locals decoded */\n    private final ArrayList<LocalEntry> locals;\n    /** size of code block in code units */\n    private final int codesize;\n    /** indexed by register, the last local variable live in a reg */\n    private final LocalEntry[] lastEntryForReg;\n    /** method descriptor of method this debug info is for */\n    private final Prototype desc;\n    /** true if method is static */\n    private final boolean isStatic;\n    /** dex file this debug info will be stored in */\n    private final DexFile file;\n    /**\n     * register size, in register units, of the register space\n     * used by this method\n     */\n    private final int regSize;\n    /** current decoding state: line number */\n    private int line = 1;\n    /** current decoding state: bytecode address */\n    private int address = 0;\n    /** string index of the string \"this\" */\n    private final int thisStringIdx;\n    /**\n     * Constructs an instance.\n     *\n     * @param encoded encoded debug info\n     * @param codesize size of code block in code units\n     * @param regSize register size, in register units, of the register space\n     * used by this method\n     * @param isStatic true if method is static\n     * @param ref method descriptor of method this debug info is for\n     * @param file dex file this debug info will be stored in\n     */\n    DebugInfoDecoder(byte[] encoded, int codesize, int regSize,\n            boolean isStatic, CstMethodRef ref, DexFile file) {\n        if (encoded == null) {\n            throw new NullPointerException(\"encoded == null\");\n        }\n        this.encoded = encoded;\n        this.isStatic = isStatic;\n        this.desc = ref.getPrototype();\n        this.file = file;\n        this.regSize = regSize;\n        positions = new ArrayList<PositionEntry>();\n        locals = new ArrayList<LocalEntry>();\n        this.codesize = codesize;\n        lastEntryForReg = new LocalEntry[regSize];\n        int idx = -1;\n        try {\n            idx = file.getStringIds().indexOf(new CstString(\"this\"));\n        } catch (IllegalArgumentException ex) {\n            /*\n             * Silently tolerate not finding \"this\". It just means that\n             * no method has local variable info that looks like\n             * a standard instance method.\n             */\n        }\n        thisStringIdx = idx;\n    }\n    /**\n     * An entry in the resulting postions table\n     */\n    static private class PositionEntry {\n        /** bytecode address */\n        public int address;\n        /** line number */\n        public int line;\n        public PositionEntry(int address, int line) {\n            this.address = address;\n            this.line = line;\n        }\n    }\n    /**\n     * An entry in the resulting locals table\n     */\n    static private class LocalEntry {\n        /** address of event */\n        public int address;\n        /** {@code true} iff it's a local start */\n        public boolean isStart;\n        /** register number */\n        public int reg;\n        /** index of name in strings table */\n        public int nameIndex;\n        /** index of type in types table */\n        public int typeIndex;\n        /** index of type signature in strings table */\n        public int signatureIndex;\n        public LocalEntry(int address, boolean isStart, int reg, int nameIndex,\n                int typeIndex, int signatureIndex) {\n            this.address        = address;\n            this.isStart        = isStart;\n            this.reg            = reg;\n            this.nameIndex      = nameIndex;\n            this.typeIndex      = typeIndex;\n            this.signatureIndex = signatureIndex;\n        }\n        public String toString() {\n            return String.format(\"[%x %s v%d %04x %04x %04x]\",\n                    address, isStart ? \"start\" : \"end\", reg,\n                    nameIndex, typeIndex, signatureIndex);\n        }\n    }\n    /**\n     * Gets the decoded positions list.\n     * Valid after calling {@code decode}.\n     *\n     * @return positions list in ascending address order.\n     */\n    public List<PositionEntry> getPositionList() {\n        return positions;\n    }\n    /**\n     * Gets the decoded locals list, in ascending start-address order.\n     * Valid after calling {@code decode}.\n     *\n     * @return locals list in ascending address order.\n     */\n    public List<LocalEntry> getLocals() {\n        return locals;\n    }\n    /**\n     * Decodes the debug info sequence.\n     */\n    public void decode() {\n        try {\n            decode0();\n        } catch (Exception ex) {\n            throw ExceptionWithContext.withContext(ex,\n                    \"...while decoding debug info\");\n        }\n    }\n    /**\n     * Reads a string index. String indicies are offset by 1, and a 0 value\n     * in the stream (-1 as returned by this method) means \"null\"\n     *\n     * @return index into file's string ids table, -1 means null\n     * @throws IOException\n     */\n    private int readStringIndex(ByteInput bs) throws IOException {\n        int offsetIndex = Leb128.readUnsignedLeb128(bs);\n        return offsetIndex - 1;\n    }\n    /**\n     * Gets the register that begins the method's parameter range (including\n     * the 'this' parameter for non-static methods). The range continues until\n     * {@code regSize}\n     *\n     * @return register as noted above.\n     */\n    private int getParamBase() {\n        return regSize\n                - desc.getParameterTypes().getWordCount() - (isStatic? 0 : 1);\n    }\n    private void decode0() throws IOException {\n        ByteInput bs = new ByteArrayByteInput(encoded);\n        line = Leb128.readUnsignedLeb128(bs);\n        int szParams = Leb128.readUnsignedLeb128(bs);\n        StdTypeList params = desc.getParameterTypes();\n        int curReg = getParamBase();\n        if (szParams != params.size()) {\n            throw new RuntimeException(\n                    \"Mismatch between parameters_size and prototype\");\n        }\n        if (!isStatic) {\n            // Start off with implicit 'this' entry\n            LocalEntry thisEntry =\n                new LocalEntry(0, true, curReg, thisStringIdx, 0, 0);\n            locals.add(thisEntry);\n            lastEntryForReg[curReg] = thisEntry;\n            curReg++;\n        }\n        for (int i = 0; i < szParams; i++) {\n            Type paramType = params.getType(i);\n            LocalEntry le;\n            int nameIdx = readStringIndex(bs);\n            if (nameIdx == -1) {\n                /*\n                 * Unnamed parameter; often but not always filled in by an\n                 * extended start op after the prologue\n                 */\n                le = new LocalEntry(0, true, curReg, -1, 0, 0);\n            } else {\n                // TODO: Final 0 should be idx of paramType.getDescriptor().\n                le = new LocalEntry(0, true, curReg, nameIdx, 0, 0);\n            }\n            locals.add(le);\n            lastEntryForReg[curReg] = le;\n            curReg += paramType.getCategory();\n        }\n        for (;;) {\n            int opcode = bs.readByte() & 0xff;\n            switch (opcode) {\n                case DBG_START_LOCAL: {\n                    int reg = Leb128.readUnsignedLeb128(bs);\n                    int nameIdx = readStringIndex(bs);\n                    int typeIdx = readStringIndex(bs);\n                    LocalEntry le = new LocalEntry(\n                            address, true, reg, nameIdx, typeIdx, 0);\n                    locals.add(le);\n                    lastEntryForReg[reg] = le;\n                }\n                break;\n                case DBG_START_LOCAL_EXTENDED: {\n                    int reg = Leb128.readUnsignedLeb128(bs);\n                    int nameIdx = readStringIndex(bs);\n                    int typeIdx = readStringIndex(bs);\n                    int sigIdx = readStringIndex(bs);\n                    LocalEntry le = new LocalEntry(\n                            address, true, reg, nameIdx, typeIdx, sigIdx);\n                    locals.add(le);\n                    lastEntryForReg[reg] = le;\n                }\n                break;\n                case DBG_RESTART_LOCAL: {\n                    int reg = Leb128.readUnsignedLeb128(bs);\n                    LocalEntry prevle;\n                    LocalEntry le;\n                    try {\n                        prevle = lastEntryForReg[reg];\n                        if (prevle.isStart) {\n                            throw new RuntimeException(\"nonsensical \"\n                                    + \"RESTART_LOCAL on live register v\"\n                                    + reg);\n                        }\n                        le = new LocalEntry(address, true, reg,\n                                prevle.nameIndex, prevle.typeIndex, 0);\n                    } catch (NullPointerException ex) {\n                        throw new RuntimeException(\n                                \"Encountered RESTART_LOCAL on new v\" + reg);\n                    }<fim_middle>// class below is data class and blob\n"}