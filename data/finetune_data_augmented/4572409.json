{"text": "<fim_prefix>        private GlyphClassTable lcdt;                   // lookahead class def table\n        private int ngc;                                // class set count\n        private RuleSet[] rsa;                          // rule set array, ordered by class number [0...ngc - 1]\n        ChainedContextualSubtableFormat2(String id, int sequence, int flags, int format, GlyphCoverageTable coverage, List entries) {\n            super(id, sequence, flags, format, coverage, entries);\n            populate(entries);\n        }\n        /** {@inheritDoc} */\n        public List getEntries() {\n            if (rsa != null) {\n                List entries = new ArrayList(5);\n                entries.add(icdt);\n                entries.add(bcdt);\n                entries.add(lcdt);\n                entries.add(ngc);\n                entries.add(rsa);\n                return entries;\n            } else {\n                return null;\n            }\n        }\n        /** {@inheritDoc} */\n        public RuleLookup[] getLookups(int ci, int gi, GlyphSubstitutionState ss, int[] rv) {\n            assert ss != null;\n            assert (rv != null) && (rv.length > 0);\n            assert rsa != null;\n            if (rsa.length > 0) {\n                RuleSet rs = rsa [ 0 ];\n                if (rs != null) {\n                    Rule[] ra = rs.getRules();\n                    for (Rule r : ra) {\n                        if ((r != null) && (r instanceof ChainedClassSequenceRule)) {\n                            ChainedClassSequenceRule cr = (ChainedClassSequenceRule) r;\n                            int[] ica = cr.getClasses(icdt.getClassIndex(gi, ss.getClassMatchSet(gi)));\n                            if (matches(ss, icdt, ica, 0, rv)) {\n                                int[] bca = cr.getBacktrackClasses();\n                                if (matches(ss, bcdt, bca, -1, null)) {\n                                    int[] lca = cr.getLookaheadClasses();\n                                    if (matches(ss, lcdt, lca, rv[0], null)) {\n                                        return r.getLookups();\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            return null;\n        }\n        private boolean matches(GlyphSubstitutionState ss, GlyphClassTable cdt, int[] classes, int offset, int[] rv) {\n            return ContextualSubtableFormat2.matches(ss, cdt, classes, offset, rv);\n        }\n        /** {@inheritDoc} */\n        public void resolveLookupReferences(Map<String, LookupTable> lookupTables) {\n            GlyphTable.resolveLookupReferences(rsa, lookupTables);\n        }\n        private void populate(List entries) {\n            if (entries == null) {\n                throw new AdvancedTypographicTableFormatException(\"illegal entries, must be non-null\");\n            } else if (entries.size() != 5) {\n                throw new AdvancedTypographicTableFormatException(\"illegal entries, \" + entries.size() + \" entries present, but requires 5 entries\");\n            } else {\n                Object o;\n                if (((o = entries.get(0)) == null) || !(o instanceof GlyphClassTable)) {\n                    throw new AdvancedTypographicTableFormatException(\"illegal entries, first entry must be an GlyphClassTable, but is: \" + ((o != null) ? o.getClass() : null));\n                } else {\n                    icdt = (GlyphClassTable) o;\n                }\n                if (((o = entries.get(1)) != null) && !(o instanceof GlyphClassTable)) {\n                    throw new AdvancedTypographicTableFormatException(\"illegal entries, second entry must be an GlyphClassTable, but is: \" + o.getClass());\n                } else {\n                    bcdt = (GlyphClassTable) o;\n                }\n                if (((o = entries.get(2)) != null) && !(o instanceof GlyphClassTable)) {\n                    throw new AdvancedTypographicTableFormatException(\"illegal entries, third entry must be an GlyphClassTable, but is: \" + o.getClass());\n                } else {\n                    lcdt = (GlyphClassTable) o;\n                }\n                if (((o = entries.get(3)) == null) || !(o instanceof Integer)) {\n                    throw new AdvancedTypographicTableFormatException(\"illegal entries, fourth entry must be an Integer, but is: \" + ((o != null) ? o.getClass() : null));\n                } else {\n                    ngc = (Integer) (o);\n                }\n                if (((o = entries.get(4)) == null) || !(o instanceof RuleSet[])) {\n                    throw new AdvancedTypographicTableFormatException(\"illegal entries, fifth entry must be an RuleSet[], but is: \" + ((o != null) ? o.getClass() : null));\n                } else {\n                    rsa = (RuleSet[]) o;\n                    if (rsa.length != ngc) {\n                        throw new AdvancedTypographicTableFormatException(\"illegal entries, RuleSet[] length is \" + rsa.length + \", but expected \" + ngc + \" glyph classes\");\n                    }\n                }\n            }\n        }\n    }\n    private static class ChainedContextualSubtableFormat3 extends ChainedContextualSubtable {\n        private RuleSet[] rsa;                          // rule set array, containing a single rule set\n        ChainedContextualSubtableFormat3(String id, int sequence, int flags, int format, GlyphCoverageTable coverage, List entries) {\n            super(id, sequence, flags, format, coverage, entries);\n            populate(entries);\n        }\n        /** {@inheritDoc} */\n        public List getEntries() {\n            if (rsa != null) {\n                List entries = new ArrayList(1);\n                entries.add(rsa);\n                return entries;\n            } else {\n                return null;\n            }\n        }\n        /** {@inheritDoc} */\n        public void resolveLookupReferences(Map<String, LookupTable> lookupTables) {\n            GlyphTable.resolveLookupReferences(rsa, lookupTables);\n        }\n        /** {@inheritDoc} */\n        public RuleLookup[] getLookups(int ci, int gi, GlyphSubstitutionState ss, int[] rv) {\n            assert ss != null;\n            assert (rv != null) && (rv.length > 0);\n            assert rsa != null;\n            if (rsa.length > 0) {\n                RuleSet rs = rsa [ 0 ];\n                if (rs != null) {\n                    Rule[] ra = rs.getRules();\n                    for (Rule r : ra) {\n                        if ((r != null) && (r instanceof ChainedCoverageSequenceRule)) {\n                            ChainedCoverageSequenceRule cr = (ChainedCoverageSequenceRule) r;\n                            GlyphCoverageTable[] igca = cr.getCoverages();\n                            if (matches(ss, igca, 0, rv)) {\n                                GlyphCoverageTable[] bgca = cr.getBacktrackCoverages();\n                                if (matches(ss, bgca, -1, null)) {\n                                    GlyphCoverageTable[] lgca = cr.getLookaheadCoverages();\n                                    if (matches(ss, lgca, rv[0], null)) {\n                                        return r.getLookups();\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            return null;\n        }\n        private boolean matches(GlyphSubstitutionState ss, GlyphCoverageTable[] gca, int offset, int[] rv) {\n            return ContextualSubtableFormat3.matches(ss, gca, offset, rv);\n        }\n        private void populate(List entries) {\n            if (entries == null) {\n                throw new AdvancedTypographicTableFormatException(\"illegal entries, must be non-null\");\n            } else if (entries.size() != 1) {\n                throw new AdvancedTypographicTableFormatException(\"illegal entries, \" + entries.size() + \" entries present, but requires 1 entry\");\n            } else {\n                Object o;\n                if (((o = entries.get(0)) == null) || !(o instanceof RuleSet[])) {\n                    throw new AdvancedTypographicTableFormatException(\"illegal entries, first entry must be an RuleSet[], but is: \" + ((o != null) ? o.getClass() : null));\n                } else {\n                    rsa = (RuleSet[]) o;\n                }\n            }\n        }\n    }\n    private abstract static class ReverseChainedSingleSubtable extends GlyphSubstitutionSubtable {\n        public ReverseChainedSingleSubtable(String id, int sequence, int flags, int format, GlyphCoverageTable coverage, List entries) {\n            super(id, sequence, flags, format, coverage);\n        }\n        /** {@inheritDoc} */\n        public int getType() {\n            return GSUB_LOOKUP_TYPE_REVERSE_CHAINED_SINGLE;\n        }\n        /** {@inheritDoc} */\n        public boolean isCompatible(GlyphSubtable subtable) {\n            return subtable instanceof ReverseChainedSingleSubtable;\n        }\n        /** {@inheritDoc} */\n        public boolean usesReverseScan() {\n            return true;\n        }\n<fim_suffix>        static GlyphSubstitutionSubtable create(String id, int sequence, int flags, int format, GlyphCoverageTable coverage, List entries) {\n            if (format == 1) {\n                return new ReverseChainedSingleSubtableFormat1(id, sequence, flags, format, coverage, entries);\n            } else {\n                throw new UnsupportedOperationException();\n            }\n        }<fim_middle>// function below has no smell\n"}