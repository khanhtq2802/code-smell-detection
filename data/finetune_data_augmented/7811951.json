{"text": "<fim_prefix>      this.args = ae.args;\n    }\n    if (ae.rc != null) {\n      this.rc = ae.rc;\n    }\n    if (ae.memberMappedArg != null) {\n      this.memberMappedArg = ae.memberMappedArg;\n    }\n    this.isMemberMappedArgument = ae.isMemberMappedArgument;\n    this.isClientServerMode = ae.isClientServerMode;\n    if (ae.proxyCache != null) {\n      this.proxyCache = ae.proxyCache;\n    }\n    this.isFnSerializationReqd = ae.isFnSerializationReqd;\n  }\n  protected AbstractExecution(AbstractExecution ae, boolean isReExecute) {\n    this(ae);\n    this.isReExecute = isReExecute;\n  }\n  public boolean isMemberMappedArgument() {\n    return this.isMemberMappedArgument;\n  }\n  public Object getArgumentsForMember(String memberId) {\n    if (!isMemberMappedArgument) {\n      return this.args;\n    } else {\n      return this.memberMappedArg.getArgumentsForMember(memberId);\n    }\n  }\n  public MemberMappedArgument getMemberMappedArgument() {\n    return this.memberMappedArg;\n  }\n  public Object getArguments() {\n    return this.args;\n  }\n  public ResultCollector getResultCollector() {\n    return this.rc;\n  }\n  public Set getFilter() {\n    return this.filter;\n  }\n  public AbstractExecution setIsReExecute() {\n    this.isReExecute = true;\n    if (this.executionNodesListener != null) {\n      this.executionNodesListener.reset();\n    }\n    return this;\n  }\n  public boolean isReExecute() {\n    return isReExecute;\n  }\n  public Set<String> getFailedNodes() {\n    return this.failedNodes;\n  }\n  public void addFailedNode(String failedNode) {\n    this.failedNodes.add(failedNode);\n  }\n  public void clearFailedNodes() {\n    this.failedNodes.clear();\n  }\n  public boolean isClientServerMode() {\n    return isClientServerMode;\n  }\n  public boolean isFnSerializationReqd() {\n    return isFnSerializationReqd;\n  }\n  public Collection<InternalDistributedMember> getExecutionNodes() {\n    return this.executionNodes;\n  }\n  public void setRequireExecutionNodes(ExecutionNodesListener listener) {\n    this.executionNodes = Collections.emptySet();\n    this.executionNodesListener = listener;\n  }\n  public void setExecutionNodes(Set<InternalDistributedMember> nodes) {\n    if (this.executionNodes != null) {\n      this.executionNodes = nodes;\n      if (this.executionNodesListener != null) {\n        this.executionNodesListener.afterExecutionNodesSet(this);\n      }\n    }\n  }\n  public void executeFunctionOnLocalPRNode(final Function fn, final FunctionContext cx,\n      final PartitionedRegionFunctionResultSender sender, DistributionManager dm, boolean isTx) {\n    if (dm instanceof ClusterDistributionManager && !isTx) {\n      if (ServerConnection.isExecuteFunctionOnLocalNodeOnly().byteValue() == 1) {\n        ServerConnection.executeFunctionOnLocalNodeOnly((byte) 3);// executed locally\n        executeFunctionLocally(fn, cx, sender, dm);\n        if (!sender.isLastResultReceived() && fn.hasResult()) {\n          ((InternalResultSender) sender).setException(new FunctionException(\n              String.format(\"The function, %s, did not send last result\",\n                  fn.getId())));\n        }\n      } else {\n        final ClusterDistributionManager newDM = (ClusterDistributionManager) dm;\n        newDM.getFunctionExecutor().execute(new Runnable() {\n          @Override\n          public void run() {\n            executeFunctionLocally(fn, cx, sender, newDM);\n            if (!sender.isLastResultReceived() && fn.hasResult()) {\n              ((InternalResultSender) sender).setException(new FunctionException(\n                  String.format(\"The function, %s, did not send last result\",\n                      fn.getId())));\n            }\n          }\n        });\n      }\n    } else {\n      executeFunctionLocally(fn, cx, sender, dm);\n      if (!sender.isLastResultReceived() && fn.hasResult()) {\n        ((InternalResultSender) sender).setException(new FunctionException(\n            String.format(\"The function, %s, did not send last result\",\n                fn.getId())));\n      }\n    }\n  }\n  // Bug41118 : in case of lonerDistribuedSystem do local execution through\n  // main thread otherwise give execution to FunctionExecutor from\n  // DistributionManager\n  public void executeFunctionOnLocalNode(final Function<?> fn, final FunctionContext cx,\n      final ResultSender sender, DistributionManager dm, final boolean isTx) {\n    if (dm instanceof ClusterDistributionManager && !isTx) {\n      final ClusterDistributionManager newDM = (ClusterDistributionManager) dm;\n      newDM.getFunctionExecutor().execute(new Runnable() {\n        @Override\n        public void run() {\n          executeFunctionLocally(fn, cx, sender, newDM);\n          if (!((InternalResultSender) sender).isLastResultReceived() && fn.hasResult()) {\n            ((InternalResultSender) sender).setException(new FunctionException(\n                String.format(\"The function, %s, did not send last result\",\n                    fn.getId())));\n          }\n        }\n      });\n    } else {\n      executeFunctionLocally(fn, cx, sender, dm);\n      if (!((InternalResultSender) sender).isLastResultReceived() && fn.hasResult()) {\n        ((InternalResultSender) sender).setException(new FunctionException(\n            String.format(\"The function, %s, did not send last result\",\n                fn.getId())));\n      }\n    }\n  }\n  public void executeFunctionLocally(final Function<?> fn, final FunctionContext cx,\n      final ResultSender sender, DistributionManager dm) {\n    FunctionStats stats = FunctionStats.getFunctionStats(fn.getId(), dm.getSystem());\n    try {\n      long start = stats.startTime();\n      stats.startFunctionExecution(fn.hasResult());\n      if (logger.isDebugEnabled()) {\n        logger.debug(\"Executing Function: {} on local node with context: {}\", fn.getId(),\n            cx.toString());\n      }\n      fn.execute(cx);\n      stats.endFunctionExecution(start, fn.hasResult());\n    } catch (FunctionInvocationTargetException fite) {\n      FunctionException functionException = null;\n      if (fn.isHA()) {\n        functionException =\n            new FunctionException(new InternalFunctionInvocationTargetException(fite.getMessage()));\n      } else {\n        functionException = new FunctionException(fite);\n      }\n      handleException(functionException, fn, cx, sender, dm);\n    } catch (BucketMovedException bme) {\n      FunctionException functionException = null;\n      if (fn.isHA()) {\n        functionException =\n            new FunctionException(new InternalFunctionInvocationTargetException(bme));\n      } else {\n        functionException = new FunctionException(bme);\n      }\n      handleException(functionException, fn, cx, sender, dm);\n    } catch (VirtualMachineError e) {\n      SystemFailure.initiateFailure(e);\n      throw e;\n    } catch (Throwable t) {\n      SystemFailure.checkFailure();\n      handleException(t, fn, cx, sender, dm);\n    }\n  }\n  @Override\n  public ResultCollector execute(final String functionName) {\n    if (functionName == null) {\n      throw new FunctionException(\n          \"The input function for the execute function request is null\");\n    }\n    this.isFnSerializationReqd = false;\n    Function functionObject = FunctionService.getFunction(functionName);\n    if (functionObject == null) {\n      throw new FunctionException(\n          String.format(\"Function named %s is not registered to FunctionService\",\n              functionName));\n    }\n    return executeFunction(functionObject);\n  }\n  @Override\n  public ResultCollector execute(Function function) throws FunctionException {\n    if (function == null) {\n      throw new FunctionException(\n          \"The input function for the execute function request is null\");\n    }\n    if (function.isHA() && !function.hasResult()) {\n      throw new FunctionException(\n          \"For Functions with isHA true, hasResult must also be true.\");\n    }\n    String id = function.getId();\n    if (id == null) {\n      throw new IllegalArgumentException(\n          \"The Function#getID() returned null\");\n    }\n    this.isFnSerializationReqd = true;\n    return executeFunction(function);\n  }\n  @Override\n  public void setWaitOnExceptionFlag(boolean waitOnException) {\n    this.setForwardExceptions(waitOnException);\n    this.waitOnException = waitOnException;\n  }\n  public boolean getWaitOnExceptionFlag() {\n    return this.waitOnException;\n  }\n  @Override\n  public void setForwardExceptions(boolean forward) {\n    this.forwardExceptions = forward;\n  }\n  public boolean isForwardExceptions() {\n    return forwardExceptions;\n  }\n<fim_suffix>  @Override\n  public void setIgnoreDepartedMembers(boolean ignore) {\n    this.ignoreDepartedMembers = ignore;\n    if (ignore) {\n      setWaitOnExceptionFlag(true);\n    }\n  }<fim_middle>// function below has no smell\n"}