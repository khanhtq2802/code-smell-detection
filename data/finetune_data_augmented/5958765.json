{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.openejb.util;\nimport org.apache.openejb.core.ParentClassLoaderFinder;\nimport org.apache.openejb.monitoring.Managed;\nimport java.lang.ref.SoftReference;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.RejectedExecutionHandler;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.Semaphore;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport static java.util.concurrent.TimeUnit.MILLISECONDS;\nimport static java.util.concurrent.TimeUnit.SECONDS;\n/**\n * Any successful pop() call requires a corresponding push() or discard() call.\n * <p/>\n * A pop() call that returns null is considered successful.  A null indicates\n * that the calling code has a permit to create a poolable object and call\n * {@link Pool#push(Object)}.  This is the only situation in which that method\n * may be called.\n * <p/>\n * To simply fill the pool without a corresponding pop(), the add() method\n * must be used.  This method will attempt to aquire a permit to add to the pool.\n *\n * @version $Rev$ $Date$\n */\n@SuppressWarnings(\"StatementWithEmptyBody\")\npublic class Pool<T> {\n    private final LinkedList<Entry> pool = new LinkedList<>();\n    private final Semaphore instances;\n    private final Semaphore available;\n    private final Semaphore minimum;\n    private final Executor executor;\n    @Managed\n    private final long maxAge;\n    @Managed\n    private final AtomicInteger poolVersion = new AtomicInteger();\n    private final Supplier<T> supplier;\n    private final AtomicReference<ScheduledExecutorService> scheduler = new AtomicReference<>();\n    private final AtomicReference<ScheduledFuture<?>> future = new AtomicReference<>();\n    private final Sweeper sweeper;\n    private final CountingLatch out = new CountingLatch();\n    @Managed\n    private final long sweepInterval;\n    @Managed\n    private final boolean replaceAged;\n    @Managed\n    private final boolean replaceFlushed;\n    @Managed\n    private final double maxAgeOffset;\n    @Managed\n    private final Stats stats;\n    @Managed\n    private final boolean garbageCollection;\n    public Pool(final int max, final int min, final boolean strict) {\n        this(max, min, strict, 0, 0, 0, null, null, false, -1, false, false);\n    }\n    @SuppressWarnings(\"unchecked\")\n    public Pool(final int max, final int min, final boolean strict, final long maxAge, final long idleTimeout, long sweepInterval, final Executor executor, final Supplier<T> supplier, final boolean replaceAged, final double maxAgeOffset, final boolean garbageCollection, final boolean replaceFlushed) {\n        if (min > max) {\n            greater(\"max\", max, \"min\", min);\n        }\n        if (maxAge != 0 && idleTimeout > maxAge) {\n            greater(\"MaxAge\", maxAge, \"IdleTimeout\", idleTimeout);\n        }\n        this.executor = executor != null ? executor : createExecutor();\n        this.supplier = supplier != null ? supplier : new NoSupplier();\n        this.available = strict ? new Semaphore(max) : new Overdraft(max);\n        this.minimum = new Semaphore(min);\n        this.instances = new Semaphore(max);\n        this.maxAge = maxAge;\n        this.maxAgeOffset = maxAgeOffset;\n        this.replaceAged = replaceAged;\n        this.replaceFlushed = replaceFlushed;\n        if (sweepInterval == 0) {\n            sweepInterval = 5 * 60 * 1000; // five minutes\n        }\n        this.sweepInterval = sweepInterval;\n        this.sweeper = new Sweeper(idleTimeout, max);\n        this.stats = new Stats(min, max, idleTimeout);\n        this.garbageCollection = garbageCollection;\n    }\n    public Pool start() {\n        ScheduledExecutorService scheduledExecutorService = this.scheduler.get();\n        boolean createdSES = scheduledExecutorService == null;\n        if (scheduledExecutorService == null) {\n            scheduledExecutorService = Executors.newScheduledThreadPool(1, new SchedulerThreadFactory());\n            if (!this.scheduler.compareAndSet(null, scheduledExecutorService)) {\n                scheduledExecutorService.shutdownNow();\n                scheduledExecutorService = this.scheduler.get();\n                createdSES = false;\n            }\n        }\n        final ScheduledFuture<?> scheduledFuture = scheduledExecutorService.scheduleAtFixedRate(sweeper, 0, this.sweepInterval, MILLISECONDS);\n        if (!this.future.compareAndSet(null, scheduledFuture)) {\n            scheduledFuture.cancel(true);\n        }\n        if (!createdSES) {\n            // we don't want to shutdown it, we'll just stop the task\n            this.scheduler.set(null);\n        }\n        return this;\n    }\n    public void stop() {\n        final ScheduledFuture<?> future = this.future.getAndSet(null);\n        if (future != null\n                && !future.isDone() && !future.isCancelled()\n                && !future.cancel(false)) {\n            Logger.getLogger(Pool.class.getName()).log(Level.WARNING, \"Pool scheduler task termination timeout expired\");\n        }\n        final ScheduledExecutorService scheduler = this.scheduler.getAndSet(null);\n        if (scheduler != null) {\n            scheduler.shutdown();\n            try {\n                if (!scheduler.awaitTermination(10, SECONDS)) { // should last something like 0s max since we killed the task\n                    Logger.getLogger(Pool.class.getName()).log(Level.WARNING, \"Pool scheduler termination timeout expired\");\n                }\n            } catch (final InterruptedException e) {\n                //Ignore\n            }\n        }\n    }\n    public boolean running() {\n        return this.future.get() != null;\n    }\n    private Executor createExecutor() {\n        final ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(3, 10,\n                60L, SECONDS,\n                new LinkedBlockingQueue<>(2), new DaemonThreadFactory(\"org.apache.openejb.util.Pool\", hashCode()));\n        threadPoolExecutor.setRejectedExecutionHandler(new RejectedExecutionHandler() {\n            @Override\n            public void rejectedExecution(final Runnable r, final ThreadPoolExecutor tpe) {\n                if (null == r || null == tpe || tpe.isShutdown() || tpe.isTerminated() || tpe.isTerminating()) {\n                    return;\n                }\n                try {\n                    if (!tpe.getQueue().offer(r, 20, SECONDS)) {\n                        org.apache.openejb.util.Logger.getInstance(LogCategory.OPENEJB, \"org.apache.openejb.util.resources\")\n                                .warning(\"Default pool executor failed to run asynchronous process: \" + r);\n                    }\n                } catch (final InterruptedException e) {\n                    //Ignore\n                }\n            }\n        });\n        return threadPoolExecutor;\n    }\n    private void greater(final String maxName, final long max, final String minName, final long min) {\n        throw new IllegalArgumentException(minName + \" cannot be greater than \" + maxName + \": \" + minName + \"=\" + min + \", \" + maxName + \"=\" + max);\n    }\n<fim_suffix>    @Managed\n    public void flush() {\n        stats.flushes.record();\n        poolVersion.incrementAndGet();\n    }\n    /**\n     * Any successful pop() call requires a corresponding push() or discard() call\n     * <p/>\n     * A pop() call that returns null is considered successful.\n     *\n     * @param timeout time to block while waiting for an instance\n     * @param unit    unit of time dicated by the timeout\n     * @return an entry from the pool or null indicating permission to create and push() an instance into the pool\n     * @throws InterruptedException  vm level thread interruption<fim_middle>// function below has no smell\n"}