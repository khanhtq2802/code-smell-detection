{"text": "<fim_prefix>/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.devtools.j2objc.types;\nimport com.google.common.base.Preconditions;\nimport com.google.devtools.j2objc.util.ElementUtil;\nimport com.google.devtools.j2objc.util.NameTable;\nimport com.google.devtools.j2objc.util.TypeUtil;\nimport java.lang.annotation.Annotation;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport javax.lang.model.element.AnnotationMirror;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.ElementKind;\nimport javax.lang.model.element.ElementVisitor;\nimport javax.lang.model.element.Modifier;\nimport javax.lang.model.element.Name;\nimport javax.lang.model.element.NestingKind;\nimport javax.lang.model.element.PackageElement;\nimport javax.lang.model.element.TypeElement;\nimport javax.lang.model.element.TypeParameterElement;\nimport javax.lang.model.type.DeclaredType;\nimport javax.lang.model.type.TypeKind;\nimport javax.lang.model.type.TypeMirror;\nimport javax.lang.model.type.TypeVisitor;\n/**\n * Element class for types created during translation.\n *\n * @author Keith Stanger\n */\npublic class GeneratedTypeElement extends GeneratedElement implements TypeElement {\n  private final TypeMirror superclass;\n  private List<TypeMirror> interfaces = new ArrayList<>();\n  private final NestingKind nestingKind;\n  private final Name qualifiedName;\n  private final String header;\n  private final boolean isIosType;\n  protected GeneratedTypeElement(\n      String name, ElementKind kind, Element enclosingElement, TypeMirror superclass,\n      NestingKind nestingKind, String header, boolean isIosType, boolean synthetic) {\n    super(Preconditions.checkNotNull(name), checkElementKind(kind), enclosingElement, synthetic);\n    this.superclass = superclass;\n    this.nestingKind = nestingKind;\n    qualifiedName = new NameImpl(getQualifiedPrefix(enclosingElement) + name);\n    this.header = header;\n    this.isIosType = isIosType;\n  }\n  public static GeneratedTypeElement mutableCopy(TypeElement element) {\n    GeneratedTypeElement generatedTypeElement =\n        new GeneratedTypeElement(\n            element.getSimpleName().toString(),\n            element.getKind(),\n            element.getEnclosingElement(),\n            element.getSuperclass(),\n            element.getNestingKind(),\n            ElementUtil.getHeader(element),\n            ElementUtil.isIosType(element),\n            ElementUtil.isSynthetic(element));\n    generatedTypeElement.addModifiers(element.getModifiers());\n    generatedTypeElement.addAnnotationMirrors(element.getAnnotationMirrors());\n    return generatedTypeElement;\n  }\n  private static GeneratedTypeElement newEmulatedType(\n      String qualifiedName, ElementKind kind, TypeMirror superclass) {\n    int idx = qualifiedName.lastIndexOf('.');\n    String packageName = idx < 0 ? \"\" : qualifiedName.substring(0, idx);\n    PackageElement packageElement = new GeneratedPackageElement(packageName);\n    return new GeneratedTypeElement(\n        qualifiedName.substring(idx + 1), kind, packageElement, superclass, NestingKind.TOP_LEVEL,\n        null, false, false);\n  }\n  public static GeneratedTypeElement newEmulatedClass(String qualifiedName, TypeMirror superclass) {\n    return newEmulatedType(qualifiedName, ElementKind.CLASS, superclass);\n  }\n  public static GeneratedTypeElement newEmulatedInterface(String qualifiedName) {\n    return newEmulatedType(qualifiedName, ElementKind.INTERFACE, null);\n  }\n  public static GeneratedTypeElement newIosType(\n      String name, ElementKind kind, TypeElement superclass, String header) {\n    return new GeneratedTypeElement(\n        name, kind, null, superclass != null ? superclass.asType() : null, NestingKind.TOP_LEVEL,\n        header, true, false);\n  }\n  public static GeneratedTypeElement newIosClass(\n      String name, TypeElement superclass, String header) {\n    return newIosType(name, ElementKind.CLASS, superclass, header);\n  }\n  public static GeneratedTypeElement newIosInterface(String name, String header) {\n    return newIosType(name, ElementKind.INTERFACE, null, header);\n  }\n  public static GeneratedTypeElement newPackageInfoClass(\n      PackageElement pkgElem, TypeUtil typeUtil) {\n    return (GeneratedTypeElement) new GeneratedTypeElement(\n        NameTable.PACKAGE_INFO_CLASS_NAME, ElementKind.CLASS, pkgElem,\n        typeUtil.getJavaObject().asType(), NestingKind.TOP_LEVEL, null, false, false)\n        .addModifiers(Modifier.PRIVATE);\n  }\n  private static ElementKind checkElementKind(ElementKind kind) {\n    Preconditions.checkArgument(kind.isClass() || kind.isInterface());\n    return kind;\n  }\n  private static String getQualifiedPrefix(Element enclosing) {\n    if (enclosing == null) {\n      return \"\";\n    } else if (ElementUtil.isTypeElement(enclosing)) {\n      return ((TypeElement) enclosing).getQualifiedName().toString() + '.';\n    } else if (ElementUtil.isPackage(enclosing)) {\n      PackageElement pkg = (PackageElement) enclosing;\n      return pkg.isUnnamed() ? \"\" : pkg.getQualifiedName().toString() + '.';\n    } else {\n      return getQualifiedPrefix(enclosing.getEnclosingElement());\n    }\n  }\n  @Override\n  public TypeMirror asType() {\n    return new Mirror();\n  }\n  @Override\n  public Name getQualifiedName() {\n    return qualifiedName;\n  }\n  public String getHeader() {\n    return header;\n  }\n  public boolean isIosType() {\n    return isIosType;\n  }\n  @Override\n  public TypeMirror getSuperclass() {\n    return superclass;\n  }\n  @Override\n  public NestingKind getNestingKind() {\n    return nestingKind;\n  }\n  @Override\n  public List<? extends TypeMirror> getInterfaces() {\n    return interfaces;\n  }\n  public List<? extends TypeMirror> getDirectSupertypes() {\n    List<TypeMirror> result = new ArrayList<>(interfaces);\n    if (superclass != null) {\n      result.add(0, superclass);  // Superclass must be first.\n    }\n    return result;\n  }\n  public void addInterface(TypeMirror t) {\n    interfaces.add(t);\n  }\n  public void addInterfaces(Collection<? extends TypeMirror> types) {\n    interfaces.addAll(types);\n  }\n  @Override\n  public List<? extends TypeParameterElement> getTypeParameters() {\n    return Collections.emptyList();\n  }\n  @Override\n  public <R, P> R accept(ElementVisitor<R, P> v, P p) {\n    return v.visitType(this, p);\n  }\n  /**\n   * The associated TypeMirror.\n   * TODO(kstanger): Make private when javac conversion is complete.\n   */\n  public class Mirror extends AbstractTypeMirror implements DeclaredType {\n<fim_suffix>    @Override\n    public TypeKind getKind() {\n      return TypeKind.DECLARED;\n    }\n    @Override\n    public Element asElement() {\n      return GeneratedTypeElement.this;\n    }\n    @Override\n    public TypeMirror getEnclosingType() {\n      TypeElement declaringClass = ElementUtil.getDeclaringClass(GeneratedTypeElement.this);\n      return declaringClass == null ? null : declaringClass.asType();\n    }\n    @Override\n    public List<? extends TypeMirror> getTypeArguments() {\n      return Collections.emptyList();\n    }\n    @Override\n    public <A extends Annotation> A getAnnotation(Class<A> annotationType) {\n      return GeneratedTypeElement.this.getAnnotation(annotationType);\n    }\n    @Override\n    public List<? extends AnnotationMirror> getAnnotationMirrors() {\n      return GeneratedTypeElement.this.getAnnotationMirrors();\n    }\n    @Override\n    public <A extends Annotation> A[] getAnnotationsByType(Class<A> annotationType) {\n      return GeneratedTypeElement.this.getAnnotationsByType(annotationType);\n    }\n    @Override\n    public <R, P> R accept(TypeVisitor<R, P> v, P p) {\n      return v.visitDeclared(this, p);\n    }\n    @Override\n    public boolean equals(Object obj) {\n      return obj instanceof Mirror && ((Mirror) obj).asElement().equals(GeneratedTypeElement.this);\n    }\n    @Override\n    public int hashCode() {\n      return 31 * GeneratedTypeElement.this.hashCode();\n    }<fim_middle>// function below has no smell\n"}