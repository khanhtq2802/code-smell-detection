{"text": "<fim_prefix>import org.eclipse.ceylon.javax.tools.JavaFileManager;\nimport org.eclipse.ceylon.javax.tools.StandardLocation;\nimport org.eclipse.ceylon.javax.tools.JavaFileObject.Kind;\nimport org.eclipse.ceylon.langtools.source.util.TaskEvent;\nimport org.eclipse.ceylon.langtools.source.util.TaskListener;\nimport org.eclipse.ceylon.langtools.tools.javac.code.Kinds;\nimport org.eclipse.ceylon.langtools.tools.javac.code.Symbol;\nimport org.eclipse.ceylon.langtools.tools.javac.code.Symtab;\nimport org.eclipse.ceylon.langtools.tools.javac.code.TypeTag;\nimport org.eclipse.ceylon.langtools.tools.javac.code.Types;\nimport org.eclipse.ceylon.langtools.tools.javac.code.Symbol.ClassSymbol;\nimport org.eclipse.ceylon.langtools.tools.javac.code.Type.ClassType;\nimport org.eclipse.ceylon.langtools.tools.javac.comp.Annotate;\nimport org.eclipse.ceylon.langtools.tools.javac.comp.AttrContext;\nimport org.eclipse.ceylon.langtools.tools.javac.comp.Check;\nimport org.eclipse.ceylon.langtools.tools.javac.comp.Enter;\nimport org.eclipse.ceylon.langtools.tools.javac.comp.Env;\nimport org.eclipse.ceylon.langtools.tools.javac.comp.Todo;\nimport org.eclipse.ceylon.langtools.tools.javac.main.Option;\nimport org.eclipse.ceylon.langtools.tools.javac.tree.EndPosTable;\nimport org.eclipse.ceylon.langtools.tools.javac.tree.JCTree;\nimport org.eclipse.ceylon.langtools.tools.javac.tree.JCTree.JCCompilationUnit;\nimport org.eclipse.ceylon.langtools.tools.javac.util.Abort;\nimport org.eclipse.ceylon.langtools.tools.javac.util.Context;\nimport org.eclipse.ceylon.langtools.tools.javac.util.List;\nimport org.eclipse.ceylon.langtools.tools.javac.util.Log;\nimport org.eclipse.ceylon.langtools.tools.javac.util.Options;\nimport org.eclipse.ceylon.langtools.tools.javac.util.Position;\nimport org.eclipse.ceylon.langtools.tools.javac.util.SourceLanguage;\nimport org.eclipse.ceylon.langtools.tools.javac.util.JCDiagnostic.DiagnosticPosition;\nimport org.eclipse.ceylon.langtools.tools.javac.util.JCDiagnostic.SimpleDiagnosticPosition;\nimport org.eclipse.ceylon.langtools.tools.javac.util.Log.WriterKind;\nimport org.eclipse.ceylon.langtools.tools.javac.util.SourceLanguage.Language;\nimport org.eclipse.ceylon.model.cmr.ArtifactResult;\nimport org.eclipse.ceylon.model.loader.AbstractModelLoader;\nimport org.eclipse.ceylon.model.loader.Timer;\nimport org.eclipse.ceylon.model.loader.model.LazyModule;\nimport org.eclipse.ceylon.model.typechecker.model.Declaration;\nimport org.eclipse.ceylon.model.typechecker.model.ModelUtil;\nimport org.eclipse.ceylon.model.typechecker.model.Module;\nimport org.eclipse.ceylon.model.typechecker.model.Package;\nimport org.eclipse.ceylon.model.typechecker.model.Setter;\nimport org.eclipse.ceylon.model.typechecker.model.Type;\nimport org.eclipse.ceylon.model.typechecker.model.TypedDeclaration;\nimport org.eclipse.ceylon.model.typechecker.model.Unit;\npublic class CeylonEnter extends Enter {\n    public static CeylonEnter instance(Context context) {\n        CeylonEnter instance = (CeylonEnter)context.get(enterKey);\n        if (instance == null){\n            instance = new CeylonEnter(context);\n            context.put(enterKey, instance);\n        }\n        return instance;\n    }\n    private CeylonTransformer gen;\n    private boolean hasRun = false;\n    private PhasedUnits phasedUnits;\n    private CompilerDelegate compilerDelegate;\n    private Log log;\n    private AbstractModelLoader modelLoader;\n    private Options options;\n    private Timer timer;\n    private CeyloncFileManager fileManager;\n    private boolean verbose;\n    private Check chk;\n    private Types types;\n    private Symtab symtab;\n    private Todo todo;\n    private boolean isBootstrap;\n    private Annotate annotate;\n    private Set<Module> modulesAddedToClassPath = new HashSet<Module>();\n    private Set<ModuleSpec> modulesAddedToAptClassPath = new HashSet<ModuleSpec>();\n    private TaskListener taskListener;\n    private SourceLanguage sourceLanguage;\n    private StatusPrinter sp;\n    private boolean hasJavaAndCeylonSources;\n    private LanguageCompiler compiler;\n    protected CeylonEnter(Context context) {\n        super(context);\n        // make sure it's loaded first\n        CeylonClassReader.instance(context);\n        try {\n            gen = CeylonTransformer.getInstance(context);\n        } catch (Exception e) {\n            // FIXME\n            e.printStackTrace();\n        }\n        phasedUnits = LanguageCompiler.getPhasedUnitsInstance(context);\n        compilerDelegate = LanguageCompiler.getCompilerDelegate(context);\n        log = CeylonLog.instance(context);\n        modelLoader = CeylonModelLoader.instance(context);\n        options = Options.instance(context);\n        timer = org.eclipse.ceylon.compiler.java.util.Timer.instance(context);\n        fileManager = (CeyloncFileManager) context.get(JavaFileManager.class);\n        verbose = options.get(Option.VERBOSE) != null;\n        isBootstrap = options.get(Option.BOOTSTRAPCEYLON) != null;\n        chk = Check.instance(context);\n        types = Types.instance(context);\n        symtab = Symtab.instance(context);\n        todo = Todo.instance(context);\n        annotate = Annotate.instance(context);\n        taskListener = context.get(TaskListener.class);\n        sourceLanguage = SourceLanguage.instance(context);\n        compiler = (LanguageCompiler) LanguageCompiler.instance(context);\n        // now superclass init\n        init(context);\n        boolean isProgressPrinted = options.get(Option.CEYLONPROGRESS) != null && StatusPrinter.canPrint();\n        if(isProgressPrinted && taskListener == null){\n            sp = LanguageCompiler.getStatusPrinterInstance(context);\n        }else{\n            sp = null;\n        }\n    }\n<fim_suffix>    @Override\n    public void main(List<JCCompilationUnit> trees) {\n        // complete the javac AST with a completed ceylon model\n        timer.startTask(\"prepareForTypeChecking\");\n        prepareForTypeChecking(trees);\n        timer.endTask();\n        List<JCCompilationUnit> javaTrees = List.nil();\n        List<JCCompilationUnit> ceylonTrees = List.nil();\n        // split them in two sets: java and ceylon\n        for(JCCompilationUnit tree : trees){\n            if(tree instanceof CeylonCompilationUnit)\n                ceylonTrees = ceylonTrees.prepend(tree);\n            else\n                javaTrees = javaTrees.prepend(tree);\n        }\n        timer.startTask(\"Enter on Java trees\");\n        boolean needsModelReset = isBootstrap;\n        // enter java trees first to set up their ClassSymbol objects for ceylon trees to use during type-checking\n        if(!javaTrees.isEmpty()){\n            setupImportedPackagesForJavaTrees(javaTrees);\n            hasJavaAndCeylonSources = true;\n            needsModelReset = true;\n        }\n        // this is false if we're in an APT round where we did not generate the trees\n        if(!compiler.isAddModuleTrees()){\n            setupImportedPackagesForJavaTrees(ceylonTrees);\n        }\n        if(isBootstrap || hasJavaAndCeylonSources){\n            super.main(trees);\n        }\n        // now we can type-check the Ceylon code\n        List<JCCompilationUnit> packageInfo = completeCeylonTrees(trees);\n        trees = trees.prependList(packageInfo);\n        ceylonTrees = ceylonTrees.prependList(packageInfo);\n        if(compiler.isHadRunTwiceException()){\n            needsModelReset = true;\n        }\n        if(needsModelReset){\n            // bootstrapping the language module is a bit more complex\n            resetAndRunEnterAgain(trees);\n        }else{\n            timer.startTask(\"Enter on Ceylon trees\");\n            // and complete their new trees\n            try {\n                sourceLanguage.push(Language.CEYLON);\n                super.main(ceylonTrees);\n            } finally {\n                sourceLanguage.pop();\n            }\n            timer.endTask();\n        }\n    }<fim_middle>// function below is long method\n"}