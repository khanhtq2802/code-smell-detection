{"text": "<fim_prefix>/* *******************************************************************\n * Copyright (c) 2002, 2010 Palo Alto Research Center, Incorporated (PARC) and others.\n * All rights reserved. \n * This program and the accompanying materials are made available \n * under the terms of the Eclipse Public License v1.0 \n * which accompanies this distribution and is available at \n * http://www.eclipse.org/legal/epl-v10.html \n *  \n * Contributors: \n *     PARC     initial implementation \n * ******************************************************************/\npackage org.aspectj.weaver.patterns;\n\nimport java.io.IOException;\nimport java.lang.reflect.Modifier;\nimport java.util.Map;\n\nimport org.aspectj.bridge.MessageUtil;\nimport org.aspectj.util.FuzzyBoolean;\nimport org.aspectj.weaver.CompressingDataOutputStream;\nimport org.aspectj.weaver.ISourceContext;\nimport org.aspectj.weaver.ResolvedType;\nimport org.aspectj.weaver.UnresolvedType;\nimport org.aspectj.weaver.VersionedDataInputStream;\nimport org.aspectj.weaver.WeaverMessages;\nimport org.aspectj.weaver.World;\n\n\n/**\n * This type represents a type pattern of '*' but with an annotation specified, e.g. '@Color *'\n */\npublic class AnyWithAnnotationTypePattern extends TypePattern {\n\n\tpublic AnyWithAnnotationTypePattern(AnnotationTypePattern atp) {\n\t\tsuper(false, false);\n\t\tannotationPattern = atp;\n\t}\n\n\t@Override\n\tpublic Object accept(PatternNodeVisitor visitor, Object data) {\n\t\treturn visitor.visit(this, data);\n\t}\n\n\t@Override\n\tprotected boolean couldEverMatchSameTypesAs(TypePattern other) {\n\t\treturn true;\n\t}\n\n\t@Override\n\tprotected boolean matchesExactly(ResolvedType type) {\n\t\tannotationPattern.resolve(type.getWorld());\n\t\tboolean b = false;\n\t\tif (type.temporaryAnnotationTypes != null) {\n\t\t\tb = annotationPattern.matches(type, type.temporaryAnnotationTypes).alwaysTrue();\n\t\t} else {\n\t\t\tb = annotationPattern.matches(type).alwaysTrue();\n\t\t}\n\t\treturn b;\n\t}\n\n\t@Override\n\tpublic TypePattern resolveBindings(IScope scope, Bindings bindings, boolean allowBinding, boolean requireExactType) {\n\t\tif (requireExactType) {\n\t\t\tscope.getWorld().getMessageHandler().handleMessage(\n\t\t\t\t\tMessageUtil.error(WeaverMessages.format(WeaverMessages.WILDCARD_NOT_ALLOWED), getSourceLocation()));\n\t\t\treturn NO;\n\t\t}\n\t\treturn super.resolveBindings(scope, bindings, allowBinding, requireExactType);\n\t}\n\n\t@Override\n\tprotected boolean matchesExactly(ResolvedType type, ResolvedType annotatedType) {\n\t\tannotationPattern.resolve(type.getWorld());\n\t\treturn annotationPattern.matches(annotatedType).alwaysTrue();\n\t}\n\n\t@Override\n\tpublic FuzzyBoolean matchesInstanceof(ResolvedType type) {\n\t\tif (Modifier.isFinal(type.getModifiers())) {\n\t\t\treturn FuzzyBoolean.fromBoolean(matchesExactly(type));\n\t\t}\n\t\treturn FuzzyBoolean.MAYBE;\n\t}\n\n\t@Override\n\tpublic TypePattern parameterizeWith(Map<String,UnresolvedType> typeVariableMap, World w) {\n\t\tAnyWithAnnotationTypePattern ret = new AnyWithAnnotationTypePattern(this.annotationPattern.parameterizeWith(\n\t\t\t\ttypeVariableMap, w));\n\t\tret.copyLocationFrom(this);\n\t\treturn ret;\n\t}\n\n\t@Override\n\tpublic void write(CompressingDataOutputStream s) throws IOException {\n\t\ts.writeByte(TypePattern.ANY_WITH_ANNO);\n\t\tannotationPattern.write(s);\n\t\twriteLocation(s);\n\t}\n\n<fim_suffix>\tpublic static TypePattern read(VersionedDataInputStream s, ISourceContext c) throws IOException {\n\t\tAnnotationTypePattern annPatt = AnnotationTypePattern.read(s, c);\n\t\tAnyWithAnnotationTypePattern ret = new AnyWithAnnotationTypePattern(annPatt);\n\t\tret.readLocation(c, s);\n\t\treturn ret;\n\t}\n\n\t// public FuzzyBoolean matches(IType type, MatchKind kind) {\n\t// return FuzzyBoolean.YES;\n\t// }\n\n\t@Override\n\tprotected boolean matchesSubtypes(ResolvedType type) {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean isStar() {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"(\" + annotationPattern + \" *)\";\n\t}\n\t\n\tpublic AnnotationTypePattern getAnnotationTypePattern() {\n\t\treturn annotationPattern;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (!(obj instanceof AnyWithAnnotationTypePattern)) {\n\t\t\treturn false;\n\t\t}\n\t\tAnyWithAnnotationTypePattern awatp = (AnyWithAnnotationTypePattern) obj;\n\t\treturn (annotationPattern.equals(awatp.annotationPattern));\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn annotationPattern.hashCode();\n\t}\n}<fim_middle>// function below has no smell\n"}