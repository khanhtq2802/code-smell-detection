{"text": "<fim_prefix>/*\n * Copyright 2002-2019 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.type.classreading;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.springframework.asm.Type;\nimport org.springframework.core.annotation.AnnotationAttributes;\nimport org.springframework.core.annotation.AnnotationUtils;\nimport org.springframework.lang.Nullable;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.CollectionUtils;\nimport org.springframework.util.LinkedMultiValueMap;\nimport org.springframework.util.ObjectUtils;\n\n/**\n * Internal utility class used when reading annotations via ASM.\n *\n * @author Juergen Hoeller\n * @author Mark Fisher\n * @author Costin Leau\n * @author Phillip Webb\n * @author Sam Brannen\n * @since 4.0\n */\n<fim_suffix>abstract class AnnotationReadingVisitorUtils {\n\n\tpublic static AnnotationAttributes convertClassValues(Object annotatedElement,\n\t\t\t@Nullable ClassLoader classLoader, AnnotationAttributes original, boolean classValuesAsString) {\n\n\t\tAnnotationAttributes result = new AnnotationAttributes(original);\n\t\tAnnotationUtils.postProcessAnnotationAttributes(annotatedElement, result, classValuesAsString);\n\n\t\tfor (Map.Entry<String, Object> entry : result.entrySet()) {\n\t\t\ttry {\n\t\t\t\tObject value = entry.getValue();\n\t\t\t\tif (value instanceof AnnotationAttributes) {\n\t\t\t\t\tvalue = convertClassValues(\n\t\t\t\t\t\t\tannotatedElement, classLoader, (AnnotationAttributes) value, classValuesAsString);\n\t\t\t\t}\n\t\t\t\telse if (value instanceof AnnotationAttributes[]) {\n\t\t\t\t\tAnnotationAttributes[] values = (AnnotationAttributes[]) value;\n\t\t\t\t\tfor (int i = 0; i < values.length; i++) {\n\t\t\t\t\t\tvalues[i] = convertClassValues(annotatedElement, classLoader, values[i], classValuesAsString);\n\t\t\t\t\t}\n\t\t\t\t\tvalue = values;\n\t\t\t\t}\n\t\t\t\telse if (value instanceof Type) {\n\t\t\t\t\tvalue = (classValuesAsString ? ((Type) value).getClassName() :\n\t\t\t\t\t\t\tClassUtils.forName(((Type) value).getClassName(), classLoader));\n\t\t\t\t}\n\t\t\t\telse if (value instanceof Type[]) {\n\t\t\t\t\tType[] array = (Type[]) value;\n\t\t\t\t\tObject[] convArray =\n\t\t\t\t\t\t\t(classValuesAsString ? new String[array.length] : new Class<?>[array.length]);\n\t\t\t\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\t\t\t\tconvArray[i] = (classValuesAsString ? array[i].getClassName() :\n\t\t\t\t\t\t\t\tClassUtils.forName(array[i].getClassName(), classLoader));\n\t\t\t\t\t}\n\t\t\t\t\tvalue = convArray;\n\t\t\t\t}\n\t\t\t\telse if (classValuesAsString) {\n\t\t\t\t\tif (value instanceof Class) {\n\t\t\t\t\t\tvalue = ((Class<?>) value).getName();\n\t\t\t\t\t}\n\t\t\t\t\telse if (value instanceof Class[]) {\n\t\t\t\t\t\tClass<?>[] clazzArray = (Class<?>[]) value;\n\t\t\t\t\t\tString[] newValue = new String[clazzArray.length];\n\t\t\t\t\t\tfor (int i = 0; i < clazzArray.length; i++) {\n\t\t\t\t\t\t\tnewValue[i] = clazzArray[i].getName();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalue = newValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tentry.setValue(value);\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// Class not found - can't resolve class reference in annotation attribute.\n\t\t\t\tresult.put(entry.getKey(), ex);\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Retrieve the merged attributes of the annotation of the given type,\n\t * if any, from the supplied {@code attributesMap}.\n\t * <p>Annotation attribute values appearing <em>lower</em> in the annotation\n\t * hierarchy (i.e., closer to the declaring class) will override those\n\t * defined <em>higher</em> in the annotation hierarchy.\n\t * @param attributesMap the map of annotation attribute lists, keyed by\n\t * annotation type name\n\t * @param metaAnnotationMap the map of meta annotation relationships,\n\t * keyed by annotation type name\n\t * @param annotationName the fully qualified class name of the annotation\n\t * type to look for\n\t * @return the merged annotation attributes, or {@code null} if no\n\t * matching annotation is present in the {@code attributesMap}\n\t * @since 4.0.3\n\t */\n\t@Nullable\n\tpublic static AnnotationAttributes getMergedAnnotationAttributes(\n\t\t\tLinkedMultiValueMap<String, AnnotationAttributes> attributesMap,\n\t\t\tMap<String, Set<String>> metaAnnotationMap, String annotationName) {\n\n\t\t// Get the unmerged list of attributes for the target annotation.\n\t\tList<AnnotationAttributes> attributesList = attributesMap.get(annotationName);\n\t\tif (CollectionUtils.isEmpty(attributesList)) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// To start with, we populate the result with a copy of all attribute values\n\t\t// from the target annotation. A copy is necessary so that we do not\n\t\t// inadvertently mutate the state of the metadata passed to this method.\n\t\tAnnotationAttributes result = new AnnotationAttributes(attributesList.get(0));\n\n\t\tSet<String> overridableAttributeNames = new HashSet<>(result.keySet());\n\t\toverridableAttributeNames.remove(AnnotationUtils.VALUE);\n\n\t\t// Since the map is a LinkedMultiValueMap, we depend on the ordering of\n\t\t// elements in the map and reverse the order of the keys in order to traverse\n\t\t// \"down\" the annotation hierarchy.\n\t\tList<String> annotationTypes = new ArrayList<>(attributesMap.keySet());\n\t\tCollections.reverse(annotationTypes);\n\n\t\t// No need to revisit the target annotation type:\n\t\tannotationTypes.remove(annotationName);\n\n\t\tfor (String currentAnnotationType : annotationTypes) {\n\t\t\tList<AnnotationAttributes> currentAttributesList = attributesMap.get(currentAnnotationType);\n\t\t\tif (!ObjectUtils.isEmpty(currentAttributesList)) {\n\t\t\t\tSet<String> metaAnns = metaAnnotationMap.get(currentAnnotationType);\n\t\t\t\tif (metaAnns != null && metaAnns.contains(annotationName)) {\n\t\t\t\t\tAnnotationAttributes currentAttributes = currentAttributesList.get(0);\n\t\t\t\t\tfor (String overridableAttributeName : overridableAttributeNames) {\n\t\t\t\t\t\tObject value = currentAttributes.get(overridableAttributeName);\n\t\t\t\t\t\tif (value != null) {\n\t\t\t\t\t\t\t// Store the value, potentially overriding a value from an attribute\n\t\t\t\t\t\t\t// of the same name found higher in the annotation hierarchy.\n\t\t\t\t\t\t\tresult.put(overridableAttributeName, value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n}<fim_middle>// class below has no smell\n"}