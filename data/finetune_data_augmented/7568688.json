{"text": "<fim_prefix>\t}\n\t/**\n\t * InvocationHandler for extended EntityManagers as defined in the JPA spec.\n\t */\n\t@SuppressWarnings(\"serial\")\n\tprivate static final class ExtendedEntityManagerInvocationHandler implements InvocationHandler, Serializable {\n\t\tprivate static final Log logger = LogFactory.getLog(ExtendedEntityManagerInvocationHandler.class);\n\t\tprivate final EntityManager target;\n\t\t@Nullable\n\t\tprivate final PersistenceExceptionTranslator exceptionTranslator;\n\t\tprivate final boolean jta;\n\t\tprivate final boolean containerManaged;\n\t\tprivate final boolean synchronizedWithTransaction;\n\t\tprivate ExtendedEntityManagerInvocationHandler(EntityManager target,\n\t\t\t\t@Nullable PersistenceExceptionTranslator exceptionTranslator, @Nullable Boolean jta,\n\t\t\t\tboolean containerManaged, boolean synchronizedWithTransaction) {\n\t\t\tthis.target = target;\n\t\t\tthis.exceptionTranslator = exceptionTranslator;\n\t\t\tthis.jta = (jta != null ? jta : isJtaEntityManager());\n\t\t\tthis.containerManaged = containerManaged;\n\t\t\tthis.synchronizedWithTransaction = synchronizedWithTransaction;\n\t\t}\n\t\tprivate boolean isJtaEntityManager() {\n\t\t\ttry {\n\t\t\t\tthis.target.getTransaction();\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tcatch (IllegalStateException ex) {\n\t\t\t\tlogger.debug(\"Cannot access EntityTransaction handle - assuming we're in a JTA environment\");\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t@Override\n\t\t@Nullable\n\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\t// Invocation on EntityManager interface coming in...\n\t\t\tif (method.getName().equals(\"equals\")) {\n\t\t\t\t// Only consider equal when proxies are identical.\n\t\t\t\treturn (proxy == args[0]);\n\t\t\t}\n\t\t\telse if (method.getName().equals(\"hashCode\")) {\n\t\t\t\t// Use hashCode of EntityManager proxy.\n\t\t\t\treturn hashCode();\n\t\t\t}\n\t\t\telse if (method.getName().equals(\"getTargetEntityManager\")) {\n\t\t\t\t// Handle EntityManagerProxy interface.\n\t\t\t\treturn this.target;\n\t\t\t}\n\t\t\telse if (method.getName().equals(\"unwrap\")) {\n\t\t\t\t// Handle JPA 2.0 unwrap method - could be a proxy match.\n\t\t\t\tClass<?> targetClass = (Class<?>) args[0];\n\t\t\t\tif (targetClass == null) {\n\t\t\t\t\treturn this.target;\n\t\t\t\t}\n\t\t\t\telse if (targetClass.isInstance(proxy)) {\n\t\t\t\t\treturn proxy;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (method.getName().equals(\"isOpen\")) {\n\t\t\t\tif (this.containerManaged) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (method.getName().equals(\"close\")) {\n\t\t\t\tif (this.containerManaged) {\n\t\t\t\t\tthrow new IllegalStateException(\"Invalid usage: Cannot close a container-managed EntityManager\");\n\t\t\t\t}\n\t\t\t\tExtendedEntityManagerSynchronization synch = (ExtendedEntityManagerSynchronization)\n\t\t\t\t\t\tTransactionSynchronizationManager.getResource(this.target);\n\t\t\t\tif (synch != null) {\n\t\t\t\t\t// Local transaction joined - don't actually call close() before transaction completion\n\t\t\t\t\tsynch.closeOnCompletion = true;\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (method.getName().equals(\"getTransaction\")) {\n\t\t\t\tif (this.synchronizedWithTransaction) {\n\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\t\"Cannot obtain local EntityTransaction from a transaction-synchronized EntityManager\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (method.getName().equals(\"joinTransaction\")) {\n\t\t\t\tdoJoinTransaction(true);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\telse if (method.getName().equals(\"isJoinedToTransaction\")) {\n\t\t\t\t// Handle JPA 2.1 isJoinedToTransaction method for the non-JTA case.\n\t\t\t\tif (!this.jta) {\n\t\t\t\t\treturn TransactionSynchronizationManager.hasResource(this.target);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Do automatic joining if required. Excludes toString, equals, hashCode calls.\n\t\t\tif (this.synchronizedWithTransaction && method.getDeclaringClass().isInterface()) {\n\t\t\t\tdoJoinTransaction(false);\n\t\t\t}\n\t\t\t// Invoke method on current EntityManager.\n\t\t\ttry {\n\t\t\t\treturn method.invoke(this.target, args);\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tthrow ex.getTargetException();\n\t\t\t}\n\t\t}\n\t\t/**\n\t\t * Join an existing transaction, if not already joined.\n\t\t * @param enforce whether to enforce the transaction\n\t\t * (i.e. whether failure to join is considered fatal)\n\t\t */\n\t\tprivate void doJoinTransaction(boolean enforce) {\n\t\t\tif (this.jta) {\n\t\t\t\t// Let's try whether we're in a JTA transaction.\n\t\t\t\ttry {\n\t\t\t\t\tthis.target.joinTransaction();\n\t\t\t\t\tlogger.debug(\"Joined JTA transaction\");\n\t\t\t\t}\n\t\t\t\tcatch (TransactionRequiredException ex) {\n\t\t\t\t\tif (!enforce) {\n\t\t\t\t\t\tlogger.debug(\"No JTA transaction to join: \" + ex);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (TransactionSynchronizationManager.isSynchronizationActive()) {\n\t\t\t\t\tif (!TransactionSynchronizationManager.hasResource(this.target) &&\n\t\t\t\t\t\t\t!this.target.getTransaction().isActive()) {\n\t\t\t\t\t\tenlistInCurrentTransaction();\n\t\t\t\t\t}\n\t\t\t\t\tlogger.debug(\"Joined local transaction\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (!enforce) {\n\t\t\t\t\t\tlogger.debug(\"No local transaction to join\");\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow new TransactionRequiredException(\"No local transaction to join\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/**\n\t\t * Enlist this application-managed EntityManager in the current transaction.\n\t\t */\n\t\tprivate void enlistInCurrentTransaction() {\n\t\t\t// Resource local transaction, need to acquire the EntityTransaction,\n\t\t\t// start a transaction now and enlist a synchronization for commit or rollback later.\n\t\t\tEntityTransaction et = this.target.getTransaction();\n\t\t\tet.begin();\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Starting resource-local transaction on application-managed \" +\n\t\t\t\t\t\t\"EntityManager [\" + this.target + \"]\");\n\t\t\t}\n\t\t\tExtendedEntityManagerSynchronization extendedEntityManagerSynchronization =\n\t\t\t\t\tnew ExtendedEntityManagerSynchronization(this.target, this.exceptionTranslator);\n\t\t\tTransactionSynchronizationManager.bindResource(this.target, extendedEntityManagerSynchronization);\n\t\t\tTransactionSynchronizationManager.registerSynchronization(extendedEntityManagerSynchronization);\n\t\t}\n\t}\n\t/**\n\t * TransactionSynchronization enlisting an extended EntityManager\n\t * with a current Spring transaction.\n\t */\n<fim_suffix>\tprivate static class ExtendedEntityManagerSynchronization\n\t\t\textends ResourceHolderSynchronization<EntityManagerHolder, EntityManager>\n\t\t\timplements Ordered {\n\t\tprivate final EntityManager entityManager;\n\t\t@Nullable\n\t\tprivate final PersistenceExceptionTranslator exceptionTranslator;\n\t\tpublic volatile boolean closeOnCompletion = false;\n\t\tpublic ExtendedEntityManagerSynchronization(\n\t\t\t\tEntityManager em, @Nullable PersistenceExceptionTranslator exceptionTranslator) {\n\t\t\tsuper(new EntityManagerHolder(em), em);\n\t\t\tthis.entityManager = em;\n\t\t\tthis.exceptionTranslator = exceptionTranslator;\n\t\t}\n\t\t@Override\n\t\tpublic int getOrder() {\n\t\t\treturn EntityManagerFactoryUtils.ENTITY_MANAGER_SYNCHRONIZATION_ORDER - 1;\n\t\t}\n\t\t@Override\n\t\tprotected void flushResource(EntityManagerHolder resourceHolder) {\n\t\t\ttry {\n\t\t\t\tthis.entityManager.flush();\n\t\t\t}\n\t\t\tcatch (RuntimeException ex) {\n\t\t\t\tthrow convertException(ex);\n\t\t\t}\n\t\t}\n\t\t@Override\n\t\tprotected boolean shouldReleaseBeforeCompletion() {\n\t\t\treturn false;\n\t\t}\n\t\t@Override\n\t\tpublic void afterCommit() {\n\t\t\tsuper.afterCommit();\n\t\t\t// Trigger commit here to let exceptions propagate to the caller.\n\t\t\ttry {\n\t\t\t\tthis.entityManager.getTransaction().commit();\n\t\t\t}\n\t\t\tcatch (RuntimeException ex) {\n\t\t\t\tthrow convertException(ex);\n\t\t\t}\n\t\t}\n\t\t@Override\n\t\tpublic void afterCompletion(int status) {\n\t\t\ttry {\n\t\t\t\tsuper.afterCompletion(status);\n\t\t\t\tif (status != STATUS_COMMITTED) {\n\t\t\t\t\t// Haven't had an afterCommit call: trigger a rollback.\n\t\t\t\t\ttry {\n\t\t\t\t\t\tthis.entityManager.getTransaction().rollback();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (RuntimeException ex) {\n\t\t\t\t\t\tthrow convertException(ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (this.closeOnCompletion) {\n\t\t\t\t\tEntityManagerFactoryUtils.closeEntityManager(this.entityManager);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprivate RuntimeException convertException(RuntimeException ex) {\n\t\t\tDataAccessException dae = (this.exceptionTranslator != null) ?\n\t\t\t\t\tthis.exceptionTranslator.translateExceptionIfPossible(ex) :\n\t\t\t\t\tEntityManagerFactoryUtils.convertJpaAccessExceptionIfPossible(ex);\n\t\t\treturn (dae != null ? dae : ex);\n\t\t}\n\t}<fim_middle>// class below has no smell\n"}