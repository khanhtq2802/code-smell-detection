{"text": "<fim_prefix>\n<fim_suffix>public class PipelineOptionsFactory {\n  /**\n   * Creates and returns an object that implements {@link PipelineOptions}. This sets the {@link\n   * ApplicationNameOptions#getAppName() \"appName\"} to the calling {@link Class#getSimpleName()\n   * classes simple name}.\n   *\n   * @return An object that implements {@link PipelineOptions}.\n   */\n  public static PipelineOptions create() {\n    return new Builder().as(PipelineOptions.class);\n  }\n  /**\n   * Creates and returns an object that implements {@code <T>}. This sets the {@link\n   * ApplicationNameOptions#getAppName() \"appName\"} to the calling {@link Class#getSimpleName()\n   * classes simple name}.\n   *\n   * <p>Note that {@code <T>} must be composable with every registered interface with this factory.\n   * See {@link PipelineOptionsFactory.Cache#validateWellFormed(Class, Set)} for more details.\n   *\n   * @return An object that implements {@code <T>}.\n   */\n  public static <T extends PipelineOptions> T as(Class<T> klass) {\n    return new Builder().as(klass);\n  }\n  /**\n   * Sets the command line arguments to parse when constructing the {@link PipelineOptions}.\n   *\n   * <p>Example GNU style command line arguments:\n   *\n   * <pre>\n   *   --project=MyProject (simple property, will set the \"project\" property to \"MyProject\")\n   *   --readOnly=true (for boolean properties, will set the \"readOnly\" property to \"true\")\n   *   --readOnly (shorthand for boolean properties, will set the \"readOnly\" property to \"true\")\n   *   --x=1 --x=2 --x=3 (list style simple property, will set the \"x\" property to [1, 2, 3])\n   *   --x=1,2,3 (shorthand list style simple property, will set the \"x\" property to [1, 2, 3])\n   *   --complexObject='{\"key1\":\"value1\",...} (JSON format for all other complex types)\n   * </pre>\n   *\n   * <p>Simple properties are able to bound to {@link String}, {@link Class}, enums and Java\n   * primitives {@code boolean}, {@code byte}, {@code short}, {@code int}, {@code long}, {@code\n   * float}, {@code double} and their primitive wrapper classes.\n   *\n   * <p>Simple list style properties are able to be bound to {@code boolean[]}, {@code char[]},\n   * {@code short[]}, {@code int[]}, {@code long[]}, {@code float[]}, {@code double[]}, {@code\n   * Class[]}, enum arrays, {@code String[]}, and {@code List<String>}.\n   *\n   * <p>JSON format is required for all other types.\n   *\n   * <p>By default, strict parsing is enabled and arguments must conform to be either {@code\n   * --booleanArgName} or {@code --argName=argValue}. Strict parsing can be disabled with {@link\n   * Builder#withoutStrictParsing()}. Empty or null arguments will be ignored whether or not strict\n   * parsing is enabled.\n   *\n   * <p>Help information can be output to {@link System#out} by specifying {@code --help} as an\n   * argument. After help is printed, the application will exit. Specifying only {@code --help} will\n   * print out the list of {@link PipelineOptionsFactory#getRegisteredOptions() registered options}\n   * by invoking {@link PipelineOptionsFactory#printHelp(PrintStream)}. Specifying {@code\n   * --help=PipelineOptionsClassName} will print out detailed usage information about the\n   * specifically requested PipelineOptions by invoking {@link\n   * PipelineOptionsFactory#printHelp(PrintStream, Class)}.\n   */\n  public static Builder fromArgs(String... args) {\n    return new Builder().fromArgs(args);\n  }\n  /**\n   * After creation we will validate that {@code <T>} conforms to all the validation criteria. See\n   * {@link PipelineOptionsValidator#validate(Class, PipelineOptions)} for more details about\n   * validation.\n   */\n  public Builder withValidation() {\n    return new Builder().withValidation();\n  }\n  /** A fluent {@link PipelineOptions} builder. */\n  public static class Builder {\n    private final String defaultAppName;\n    private final String[] args;\n    private final boolean validation;\n    private final boolean strictParsing;\n    private final boolean isCli;\n    // Do not allow direct instantiation\n    private Builder() {\n      this(null, false, true, false);\n    }\n    private Builder(String[] args, boolean validation, boolean strictParsing, boolean isCli) {\n      this.defaultAppName = findCallersClassName();\n      this.args = args;\n      this.validation = validation;\n      this.strictParsing = strictParsing;\n      this.isCli = isCli;\n    }\n    /**\n     * Sets the command line arguments to parse when constructing the {@link PipelineOptions}.\n     *\n     * <p>Example GNU style command line arguments:\n     *\n     * <pre>\n     *   --project=MyProject (simple property, will set the \"project\" property to \"MyProject\")\n     *   --readOnly=true (for boolean properties, will set the \"readOnly\" property to \"true\")\n     *   --readOnly (shorthand for boolean properties, will set the \"readOnly\" property to \"true\")\n     *   --x=1 --x=2 --x=3 (list style simple property, will set the \"x\" property to [1, 2, 3])\n     *   --x=1,2,3 (shorthand list style simple property, will set the \"x\" property to [1, 2, 3])\n     *   --complexObject='{\"key1\":\"value1\",...} (JSON format for all other complex types)\n     * </pre>\n     *\n     * <p>Simple properties are able to bound to {@link String}, {@link Class}, enums and Java\n     * primitives {@code boolean}, {@code byte}, {@code short}, {@code int}, {@code long}, {@code\n     * float}, {@code double} and their primitive wrapper classes.\n     *\n     * <p>Simple list style properties are able to be bound to {@code boolean[]}, {@code char[]},\n     * {@code short[]}, {@code int[]}, {@code long[]}, {@code float[]}, {@code double[]}, {@code\n     * Class[]}, enum arrays, {@code String[]}, and {@code List<String>}.\n     *\n     * <p>JSON format is required for all other types.\n     *\n     * <p>By default, strict parsing is enabled and arguments must conform to be either {@code\n     * --booleanArgName} or {@code --argName=argValue}. Strict parsing can be disabled with {@link\n     * Builder#withoutStrictParsing()}. Empty or null arguments will be ignored whether or not\n     * strict parsing is enabled.\n     *\n     * <p>Help information can be output to {@link System#out} by specifying {@code --help} as an\n     * argument. After help is printed, the application will exit. Specifying only {@code --help}\n     * will print out the list of {@link PipelineOptionsFactory#getRegisteredOptions() registered\n     * options} by invoking {@link PipelineOptionsFactory#printHelp(PrintStream)}. Specifying {@code\n     * --help=PipelineOptionsClassName} will print out detailed usage information about the\n     * specifically requested PipelineOptions by invoking {@link\n     * PipelineOptionsFactory#printHelp(PrintStream, Class)}.\n     */\n    public Builder fromArgs(String... args) {\n      checkNotNull(args, \"Arguments should not be null.\");\n      return new Builder(args, validation, strictParsing, true);\n    }\n    /**\n     * After creation we will validate that {@link PipelineOptions} conforms to all the validation\n     * criteria from {@code <T>}. See {@link PipelineOptionsValidator#validate(Class,\n     * PipelineOptions)} for more details about validation.\n     */\n    public Builder withValidation() {\n      return new Builder(args, true, strictParsing, isCli);\n    }\n    /**\n     * During parsing of the arguments, we will skip over improperly formatted and unknown\n     * arguments.\n     */\n    public Builder withoutStrictParsing() {\n      return new Builder(args, validation, false, isCli);\n    }\n    /**\n     * Creates and returns an object that implements {@link PipelineOptions} using the values\n     * configured on this builder during construction.\n     *\n     * @return An object that implements {@link PipelineOptions}.\n     */\n    public PipelineOptions create() {\n      return as(PipelineOptions.class);\n    }\n    /**\n     * Creates and returns an object that implements {@code <T>} using the values configured on this\n     * builder during construction.\n     *\n     * <p>Note that {@code <T>} must be composable with every registered interface with this<fim_middle>// class below is blob\n"}