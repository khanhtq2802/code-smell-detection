{"text": "<fim_prefix>/* Generated By:JJTree&JavaCC: Do not edit this line. ELParser.java */\npackage org.apache.el.parser;\nimport java.io.StringReader;\nimport javax.el.ELException;\n@SuppressWarnings(\"all\") // Ignore warnings in generated code\npublic class ELParser/*@bgen(jjtree)*/implements ELParserTreeConstants, ELParserConstants {/*@bgen(jjtree)*/\n  protected JJTELParserState jjtree = new JJTELParserState();\n    public static Node parse(String ref) throws ELException {\n        try {\n            return new ELParser(new StringReader(ref)).CompositeExpression();\n        } catch (ParseException pe) {\n            throw new ELException(pe.getMessage());\n        }\n    }\n/*\n * CompositeExpression\n * Allow most flexible parsing, restrict by examining\n * type of returned node\n */\n  final public AstCompositeExpression CompositeExpression() throws ParseException {\n                                                                     /*@bgen(jjtree) CompositeExpression */\n  AstCompositeExpression jjtn000 = new AstCompositeExpression(JJTCOMPOSITEEXPRESSION);\n  boolean jjtc000 = true;\n  jjtree.openNodeScope(jjtn000);\n    try {\n      label_1:\n      while (true) {\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n        case LITERAL_EXPRESSION:\n        case START_DYNAMIC_EXPRESSION:\n        case START_DEFERRED_EXPRESSION:\n          ;\n          break;\n        default:\n          jj_la1[0] = jj_gen;\n          break label_1;\n        }\n        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n        case START_DEFERRED_EXPRESSION:\n          DeferredExpression();\n          break;\n        case START_DYNAMIC_EXPRESSION:\n          DynamicExpression();\n          break;\n        case LITERAL_EXPRESSION:\n          LiteralExpression();\n          break;\n        default:\n          jj_la1[1] = jj_gen;\n          jj_consume_token(-1);\n          throw new ParseException();\n        }\n      }\n      jj_consume_token(0);\n                                   jjtree.closeNodeScope(jjtn000, true);\n                                   jjtc000 = false;\n                                   {if (true) return jjtn000;}\n    } catch (Throwable jjte000) {\n      if (jjtc000) {\n        jjtree.clearNodeScope(jjtn000);\n        jjtc000 = false;\n      } else {\n        jjtree.popNode();\n      }\n      if (jjte000 instanceof RuntimeException) {\n        {if (true) throw (RuntimeException)jjte000;}\n      }\n      if (jjte000 instanceof ParseException) {\n        {if (true) throw (ParseException)jjte000;}\n      }\n      {if (true) throw (Error)jjte000;}\n    } finally {\n      if (jjtc000) {\n        jjtree.closeNodeScope(jjtn000, true);\n      }\n    }\n    throw new Error(\"Missing return statement in function\");\n  }\n/*\n * LiteralExpression\n * Non-EL Expression blocks\n */\n  final public void LiteralExpression() throws ParseException {\n                                               /*@bgen(jjtree) LiteralExpression */\n                                                AstLiteralExpression jjtn000 = new AstLiteralExpression(JJTLITERALEXPRESSION);\n                                                boolean jjtc000 = true;\n                                                jjtree.openNodeScope(jjtn000);Token t = null;\n    try {\n      t = jj_consume_token(LITERAL_EXPRESSION);\n                             jjtree.closeNodeScope(jjtn000, true);\n                             jjtc000 = false;\n                             jjtn000.setImage(t.image);\n    } finally {\n      if (jjtc000) {\n        jjtree.closeNodeScope(jjtn000, true);\n      }\n    }\n  }\n/*\n * DeferredExpression\n * #{...} Expressions\n */\n  final public void DeferredExpression() throws ParseException {\n                                                 /*@bgen(jjtree) DeferredExpression */\n  AstDeferredExpression jjtn000 = new AstDeferredExpression(JJTDEFERREDEXPRESSION);\n  boolean jjtc000 = true;\n  jjtree.openNodeScope(jjtn000);\n    try {\n      jj_consume_token(START_DEFERRED_EXPRESSION);\n      Expression();\n      jj_consume_token(RBRACE);\n    } catch (Throwable jjte000) {\n      if (jjtc000) {\n        jjtree.clearNodeScope(jjtn000);\n        jjtc000 = false;\n      } else {\n        jjtree.popNode();\n      }\n      if (jjte000 instanceof RuntimeException) {\n        {if (true) throw (RuntimeException)jjte000;}\n      }\n      if (jjte000 instanceof ParseException) {\n        {if (true) throw (ParseException)jjte000;}\n      }\n      {if (true) throw (Error)jjte000;}\n    } finally {\n      if (jjtc000) {\n        jjtree.closeNodeScope(jjtn000, true);\n      }\n    }\n  }\n/*\n * DynamicExpression\n * ${...} Expressions\n */\n<fim_suffix>  final public void DynamicExpression() throws ParseException {\n                                               /*@bgen(jjtree) DynamicExpression */\n  AstDynamicExpression jjtn000 = new AstDynamicExpression(JJTDYNAMICEXPRESSION);\n  boolean jjtc000 = true;\n  jjtree.openNodeScope(jjtn000);\n    try {\n      jj_consume_token(START_DYNAMIC_EXPRESSION);\n      Expression();\n      jj_consume_token(RBRACE);\n    } catch (Throwable jjte000) {\n      if (jjtc000) {\n        jjtree.clearNodeScope(jjtn000);\n        jjtc000 = false;\n      } else {\n        jjtree.popNode();\n      }\n      if (jjte000 instanceof RuntimeException) {\n        {if (true) throw (RuntimeException)jjte000;}\n      }\n      if (jjte000 instanceof ParseException) {\n        {if (true) throw (ParseException)jjte000;}\n      }\n      {if (true) throw (Error)jjte000;}\n    } finally {\n      if (jjtc000) {\n        jjtree.closeNodeScope(jjtn000, true);\n      }\n    }\n  }\n/*\n * Expression\n * EL Expression Language Root\n */\n  final public void Expression() throws ParseException {\n    Semicolon();\n  }\n/*\n * Semicolon\n */\n  final public void Semicolon() throws ParseException {\n    Assignment();\n    label_2:\n    while (true) {\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n      case SEMICOLON:\n        ;\n        break;\n      default:\n        jj_la1[2] = jj_gen;\n        break label_2;\n      }\n      jj_consume_token(SEMICOLON);\n                                 AstSemicolon jjtn001 = new AstSemicolon(JJTSEMICOLON);\n                                 boolean jjtc001 = true;\n                                 jjtree.openNodeScope(jjtn001);\n      try {\n        Assignment();\n      } catch (Throwable jjte001) {\n                                 if (jjtc001) {\n                                   jjtree.clearNodeScope(jjtn001);\n                                   jjtc001 = false;\n                                 } else {\n                                   jjtree.popNode();\n                                 }\n                                 if (jjte001 instanceof RuntimeException) {\n                                   {if (true) throw (RuntimeException)jjte001;}\n                                 }\n                                 if (jjte001 instanceof ParseException) {\n                                   {if (true) throw (ParseException)jjte001;}\n                                 }\n                                 {if (true) throw (Error)jjte001;}\n      } finally {\n                                 if (jjtc001) {\n                                   jjtree.closeNodeScope(jjtn001,  2);\n                                 }\n      }\n    }\n  }\n/*\n * Assignment\n */\n  final public void Assignment() throws ParseException {\n    if (jj_2_2(4)) {\n      LambdaExpression();\n    } else {\n      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {\n      case START_SET_OR_MAP:\n      case INTEGER_LITERAL:\n      case FLOATING_POINT_LITERAL:\n      case STRING_LITERAL:\n      case TRUE:\n      case FALSE:\n      case NULL:<fim_middle>// function below is long method\n"}