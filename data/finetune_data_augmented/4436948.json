{"text": "<fim_prefix>        if (consumer.getInputs() != null && consumer.getInputs().getInputs() != null) {\n            for (Input input : consumer.getInputs().getInputs()) {\n                if (StringUtils.equals(input.getFeed(), feed.getName())) {\n                    inputFeeds.add(input);\n                }\n            }\n        }\n        // for each input corresponding to given feed, find corresponding consumer instances\n        for (Input in : inputFeeds) {\n            /* Algorithm for finding a consumer instance for an input feed instance\n            Step 1. Find one instance which will consume the given feed instance.\n                    a. take process start date and find last input feed instance time. In this step take care of\n                        frequencies being out of sync.\n                    b. using the above find the time difference between the process instance and feed instance.\n                    c. Adding the above time difference to given feed instance for which we want to find the consumer\n                        instances we will get one consumer process instance.\n            Step 2. Keep checking for next instances of process till they consume the given feed Instance.\n            Step 3. Similarly check for all previous instances of process till they consume the given feed instance.\n            */\n            // Step 1.a & 1.b\n            ExpressionHelper.setReferenceDate(processStartDate);\n            ExpressionHelper evaluator = ExpressionHelper.get();\n            Date startRelative = evaluator.evaluate(in.getStart(), Date.class);\n            Date startTimeActual = EntityUtil.getPreviousInstanceTime(feedStartDate,\n                    feed.getFrequency(), feed.getTimezone(), startRelative);\n            Long offset = processStartDate.getTime() - startTimeActual.getTime();\n            // Step 1.c\n            Date processInstanceStartRelative = new Date(feedInstancetime.getTime() + offset);\n            Date processInstanceStartActual = EntityUtil.getPreviousInstanceTime(processStartDate,\n                    consumer.getFrequency(), consumer.getTimezone(), processInstanceStartRelative);\n            // Step 2.\n            Date currentInstance = processInstanceStartActual;\n            while (true) {\n                Date nextConsumerInstance = EntityUtil.getNextStartTime(processStartDate,\n                        consumer.getFrequency(), consumer.getTimezone(), currentInstance);\n                ExpressionHelper.setReferenceDate(nextConsumerInstance);\n                evaluator = ExpressionHelper.get();\n                Date inputStart = evaluator.evaluate(in.getStart(), Date.class);\n                Long rangeStart = EntityUtil.getPreviousInstanceTime(feedStartDate, feed.getFrequency(),\n                        feed.getTimezone(), inputStart).getTime();\n                Long rangeEnd = evaluator.evaluate(in.getEnd(), Date.class).getTime();\n                if (rangeStart <= feedInstancetime.getTime() && feedInstancetime.getTime() <= rangeEnd) {\n                    if (!nextConsumerInstance.before(processCluster.getValidity().getStart())\n                            && nextConsumerInstance.before(processCluster.getValidity().getEnd())) {\n                        result.add(nextConsumerInstance);\n                    }\n                } else {\n                    break;\n                }\n                currentInstance = new Date(nextConsumerInstance.getTime() + ONE_MS);\n            }\n            // Step 3.\n            currentInstance = processInstanceStartActual;\n            while (true) {\n                Date nextConsumerInstance = EntityUtil.getPreviousInstanceTime(processStartDate,\n                        consumer.getFrequency(), consumer.getTimezone(), currentInstance);\n                ExpressionHelper.setReferenceDate(nextConsumerInstance);\n                evaluator = ExpressionHelper.get();\n                Date inputStart = evaluator.evaluate(in.getStart(), Date.class);\n                Long rangeStart = EntityUtil.getPreviousInstanceTime(feedStartDate, feed.getFrequency(),\n                        feed.getTimezone(), inputStart).getTime();\n                Long rangeEnd = evaluator.evaluate(in.getEnd(), Date.class).getTime();\n                if (rangeStart <= feedInstancetime.getTime() && feedInstancetime.getTime() <= rangeEnd) {\n                    if (!nextConsumerInstance.before(processCluster.getValidity().getStart())\n                            && nextConsumerInstance.before(processCluster.getValidity().getEnd())) {\n                        result.add(nextConsumerInstance);\n                    }\n                } else {\n                    break;\n                }\n                currentInstance = new Date(nextConsumerInstance.getTime() - ONE_MS);\n            }\n        }\n        return result;\n    }\n    public static FeedInstanceResult getFeedInstanceListing(Entity entityObject,\n                                                            Date start, Date end) throws FalconException {\n        Set<String> clusters = EntityUtil.getClustersDefinedInColos(entityObject);\n        FeedInstanceResult result = new FeedInstanceResult(APIResult.Status.SUCCEEDED, \"Success\");\n        List<FeedInstanceResult.Instance> allInstances = new ArrayList<FeedInstanceResult.Instance>();\n        for (String cluster : clusters) {\n            Feed feed = (Feed) entityObject;\n            Storage storage = createStorage(cluster, feed);\n            List<FeedInstanceStatus> feedListing = storage.getListing(feed, cluster, LocationType.DATA, start, end);\n            for (FeedInstanceStatus feedStatus : feedListing) {\n                FeedInstanceResult.Instance instance = new\n                        FeedInstanceResult.Instance(cluster, feedStatus.getInstance(),\n                        feedStatus.getStatus().name());\n                instance.creationTime = feedStatus.getCreationTime();\n                instance.uri = feedStatus.getUri();\n                instance.size = feedStatus.getSize();\n                instance.sizeH = feedStatus.getSizeH();\n                allInstances.add(instance);\n            }\n        }\n        FeedInstanceResult.Instance[] resultInstances = allInstances.toArray(\n                new FeedInstanceResult.Instance[allInstances.size()]);\n        result.setInstances(resultInstances);\n        return result;\n    }\n    /**\n     * Returns the data source type associated with the Feed's import policy.\n     *\n     * @param clusterEntity\n     * @param feed\n     * @return {@link org.apache.falcon.entity.v0.datasource.DatasourceType}\n     * @throws FalconException\n     */\n    public static DatasourceType getImportDatasourceType(\n            org.apache.falcon.entity.v0.cluster.Cluster clusterEntity,\n            Feed feed) throws FalconException {\n        Cluster feedCluster = getCluster(feed, clusterEntity.getName());\n        if (isImportEnabled(feedCluster)) {\n            return DatasourceHelper.getDatasourceType(getImportDatasourceName(feedCluster));\n        } else {\n            return null;\n        }\n    }\n    /**\n     * Return if Import policy is enabled in the Feed definition.\n     *\n     * @param feedCluster\n     * @return true if import policy is enabled else false\n     */\n    public static boolean isImportEnabled(org.apache.falcon.entity.v0.feed.Cluster feedCluster) {\n        if (feedCluster.getType() == ClusterType.SOURCE) {\n            return (feedCluster.getImport() != null);\n        }\n        return false;\n    }\n    /**\n     * Returns the data source name associated with the Feed's import policy.\n     *\n     * @param feedCluster\n     * @return DataSource name defined in the Datasource Entity\n     */\n    public static String getImportDatasourceName(org.apache.falcon.entity.v0.feed.Cluster feedCluster) {\n        if (isImportEnabled(feedCluster)) {\n            return feedCluster.getImport().getSource().getName();\n        } else {\n            return null;\n        }\n    }\n    /**\n     * Returns Datasource table name.\n     *\n     * @param feedCluster\n     * @return Table or Topic name of the Datasource\n     */\n    public static String getImportDataSourceTableName(org.apache.falcon.entity.v0.feed.Cluster feedCluster) {\n        if (isImportEnabled(feedCluster)) {\n            return feedCluster.getImport().getSource().getTableName();\n        } else {\n            return null;\n        }\n    }\n    /**\n     * Returns the extract method type.\n     *\n     * @param feedCluster\n     * @return {@link org.apache.falcon.entity.v0.feed.ExtractMethod}\n     */\n    public static ExtractMethod getImportExtractMethod(org.apache.falcon.entity.v0.feed.Cluster feedCluster) {\n        if (isImportEnabled(feedCluster)) {\n            return feedCluster.getImport().getSource().getExtract().getType();\n        } else {\n            return null;\n        }\n    }\n    /**\n     * Returns the merge type of the Feed import policy.\n     *\n     * @param feedCluster\n     * @return {@link org.apache.falcon.entity.v0.feed.MergeType}\n     */\n    public static MergeType getImportMergeType(org.apache.falcon.entity.v0.feed.Cluster feedCluster) {\n        if (isImportEnabled(feedCluster)) {\n            return feedCluster.getImport().getSource().getExtract().getMergepolicy();\n        } else {\n            return null;\n        }\n    }\n    /**\n     * Returns the initial instance date for the import data set for coorinator.\n     *\n     * @param feedCluster\n     * @return Feed cluster validity start date or recent time\n     */\n<fim_suffix>    public static Date getImportInitalInstance(org.apache.falcon.entity.v0.feed.Cluster feedCluster) {\n        return feedCluster.getValidity().getStart();\n    }<fim_middle>// function below is feature envy\n"}