{"text": "<fim_prefix> * The DeltaIteration itself represents the result after the iteration has terminated.\n * Delta iterations terminate when the feed back data set (the workset) is empty.\n * In addition, a maximum number of steps is given as a fall back termination guard.\n * <p>\n * Elements in the solution set are uniquely identified by a key. When merging the solution set delta, contained elements\n * with the same key are replaced.\n * <p>\n * This class is a subclass of {@code DualInputOperator}. The solution set is considered the first input, the\n * workset is considered the second input.\n */\n@Internal\npublic class DeltaIterationBase<ST, WT> extends DualInputOperator<ST, WT, ST, AbstractRichFunction> implements IterationOperator {\n\tprivate final Operator<ST> solutionSetPlaceholder;\n\tprivate final Operator<WT> worksetPlaceholder;\n\tprivate Operator<ST> solutionSetDelta;\n\tprivate Operator<WT> nextWorkset;\n\t/**\n\t * The positions of the keys in the solution tuple.\n\t */\n\tprivate final int[] solutionSetKeyFields;\n\t/**\n\t * The maximum number of iterations. Possibly used only as a safeguard.\n\t */\n\tprivate int maxNumberOfIterations = -1;\n\tprivate final AggregatorRegistry aggregators = new AggregatorRegistry();\n\tprivate boolean solutionSetUnManaged;\n\t// --------------------------------------------------------------------------------------------\n\tpublic DeltaIterationBase(BinaryOperatorInformation<ST, WT, ST> operatorInfo, int keyPosition) {\n\t\tthis(operatorInfo, new int[] {keyPosition});\n\t}\n\tpublic DeltaIterationBase(BinaryOperatorInformation<ST, WT, ST> operatorInfo, int[] keyPositions) {\n\t\tthis(operatorInfo, keyPositions, \"<Unnamed Delta Iteration>\");\n\t}\n\tpublic DeltaIterationBase(BinaryOperatorInformation<ST, WT, ST> operatorInfo, int keyPosition, String name) {\n\t\tthis(operatorInfo, new int[] {keyPosition}, name);\n\t}\n\tpublic DeltaIterationBase(BinaryOperatorInformation<ST, WT, ST> operatorInfo, int[] keyPositions, String name) {\n\t\tsuper(new UserCodeClassWrapper<AbstractRichFunction>(AbstractRichFunction.class), operatorInfo, name);\n\t\tthis.solutionSetKeyFields = keyPositions;\n\t\tsolutionSetPlaceholder = new SolutionSetPlaceHolder<ST>(this, new OperatorInformation<ST>(operatorInfo.getFirstInputType()));\n\t\tworksetPlaceholder = new WorksetPlaceHolder<WT>(this, new OperatorInformation<WT>(operatorInfo.getSecondInputType()));\n\t}\n\t// --------------------------------------------------------------------------------------------\n\tpublic int[] getSolutionSetKeyFields() {\n\t\treturn this.solutionSetKeyFields;\n\t}\n\tpublic void setMaximumNumberOfIterations(int maxIterations) {\n\t\tthis.maxNumberOfIterations = maxIterations;\n\t}\n\tpublic int getMaximumNumberOfIterations() {\n\t\treturn this.maxNumberOfIterations;\n\t}\n\t@Override\n\tpublic AggregatorRegistry getAggregators() {\n\t\treturn this.aggregators;\n\t}\n\t// --------------------------------------------------------------------------------------------\n\t// Getting / Setting of the step function input place-holders\n\t// --------------------------------------------------------------------------------------------\n\t/**\n\t * Gets the contract that represents the solution set for the step function.\n\t * \n\t * @return The solution set for the step function.\n\t */\n\tpublic Operator<ST> getSolutionSet() {\n\t\treturn this.solutionSetPlaceholder;\n\t}\n\t/**\n\t * Gets the contract that represents the workset for the step function.\n\t * \n\t * @return The workset for the step function.\n\t */\n\tpublic Operator<WT> getWorkset() {\n\t\treturn this.worksetPlaceholder;\n\t}\n\t/**\n\t * Sets the contract of the step function that represents the next workset. This contract is considered \n\t * one of the two sinks of the step function (the other one being the solution set delta).\n\t * \n\t * @param result The contract representing the next workset.\n\t */\n\tpublic void setNextWorkset(Operator<WT> result) {\n\t\tthis.nextWorkset = result;\n\t}\n\t/**\n\t * Gets the contract that has been set as the next workset.\n\t * \n\t * @return The contract that has been set as the next workset.\n\t */\n\tpublic Operator<WT> getNextWorkset() {\n\t\treturn this.nextWorkset;\n\t}\n\t/**\n\t * Sets the contract of the step function that represents the solution set delta. This contract is considered\n\t * one of the two sinks of the step function (the other one being the next workset).\n\t * \n\t * @param delta The contract representing the solution set delta.\n\t */\n\tpublic void setSolutionSetDelta(Operator<ST> delta) {\n\t\tthis.solutionSetDelta = delta;\n\t}\n\t/**\n\t * Gets the contract that has been set as the solution set delta.\n\t * \n\t * @return The contract that has been set as the solution set delta.\n\t */\n\tpublic Operator<ST> getSolutionSetDelta() {\n\t\treturn this.solutionSetDelta;\n\t}\n\t// --------------------------------------------------------------------------------------------\n\t// Getting / Setting the Inputs\n\t// --------------------------------------------------------------------------------------------\n\t/**\n\t * Returns the initial solution set input, or null, if none is set.\n\t * \n\t * @return The iteration's initial solution set input.\n\t */\n\tpublic Operator<ST> getInitialSolutionSet() {\n\t\treturn getFirstInput();\n\t}\n\t/**\n\t * Returns the initial workset input, or null, if none is set.\n\t * \n\t * @return The iteration's workset input.\n\t */\n\tpublic Operator<WT> getInitialWorkset() {\n\t\treturn getSecondInput();\n\t}\n\t/**\n\t * Sets the given input as the initial solution set.\n\t * \n\t * @param input The contract to set the initial solution set.\n\t */\n\tpublic void setInitialSolutionSet(Operator<ST> input) {\n\t\tsetFirstInput(input);\n\t}\n\t/**\n\t * Sets the given input as the initial workset.\n\t * \n\t * @param input The contract to set as the initial workset.\n\t */\n\tpublic void setInitialWorkset(Operator<WT> input) {\n\t\tsetSecondInput(input);\n\t}\n\t/**\n\t * DeltaIteration meta operator cannot have broadcast inputs.\n\t * \n\t * @return An empty map.\n\t */\n\tpublic Map<String, Operator<?>> getBroadcastInputs() {\n\t\treturn Collections.emptyMap();\n\t}\n\t/**\n\t * The DeltaIteration meta operator cannot have broadcast inputs.\n\t * This method always throws an exception.\n\t * \n\t * @param name Ignored.\n\t * @param root Ignored.\n\t */\n\tpublic void setBroadcastVariable(String name, Operator<?> root) {\n\t\tthrow new UnsupportedOperationException(\"The DeltaIteration meta operator cannot have broadcast inputs.\");\n\t}\n\t/**\n\t * The DeltaIteration meta operator cannot have broadcast inputs.\n\t * This method always throws an exception.\n\t * \n\t * @param inputs Ignored\n\t */\n\tpublic <X> void setBroadcastVariables(Map<String, Operator<X>> inputs) {\n\t\tthrow new UnsupportedOperationException(\"The DeltaIteration meta operator cannot have broadcast inputs.\");\n\t}\n\t/**\n\t * Sets whether to keep the solution set in managed memory (safe against heap exhaustion) or unmanaged memory\n\t * (objects on heap).\n\t * \n\t * @param solutionSetUnManaged True to keep the solution set in unmanaged memory, false to keep it in managed memory.\n\t * \n\t * @see #isSolutionSetUnManaged()\n\t */\n\tpublic void setSolutionSetUnManaged(boolean solutionSetUnManaged) {\n\t\tthis.solutionSetUnManaged = solutionSetUnManaged;\n\t}\n\t/**\n\t * gets whether the solution set is in managed or unmanaged memory.\n\t * \n\t * @return True, if the solution set is in unmanaged memory (object heap), false if in managed memory.\n\t * \n\t * @see #setSolutionSetUnManaged(boolean)\n\t */\n\tpublic boolean isSolutionSetUnManaged() {\n\t\treturn solutionSetUnManaged;\n\t}\n\t// --------------------------------------------------------------------------------------------\n\t// Place-holder Operators\n\t// --------------------------------------------------------------------------------------------\n\t/**\n\t * Specialized operator to use as a recognizable place-holder for the working set input to the\n\t * step function.\n\t */\n<fim_suffix>\tpublic static class WorksetPlaceHolder<WT> extends Operator<WT> {\n\t\tprivate final DeltaIterationBase<?, WT> containingIteration;\n\t\tpublic WorksetPlaceHolder(DeltaIterationBase<?, WT> container, OperatorInformation<WT> operatorInfo) {\n\t\t\tsuper(operatorInfo, \"Workset\");\n\t\t\tthis.containingIteration = container;\n\t\t}\n\t\tpublic DeltaIterationBase<?, WT> getContainingWorksetIteration() {\n\t\t\treturn this.containingIteration;\n\t\t}\n\t\t@Override\n\t\tpublic void accept(Visitor<Operator<?>> visitor) {\n\t\t\tvisitor.preVisit(this);\n\t\t\tvisitor.postVisit(this);\n\t\t}\n\t\t@Override\n\t\tpublic UserCodeWrapper<?> getUserCodeWrapper() {\n\t\t\treturn null;\n\t\t}\n\t}<fim_middle>// class below has no smell\n"}