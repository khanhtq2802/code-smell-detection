{"text": "<fim_prefix>        finish = resolution.round( finish );\n        long expected_time = start;\n        Keyspace ko = cass.getApplicationKeyspace( applicationId );\n        SliceCounterQuery<String, Long> q = createCounterSliceQuery( ko, se, le );\n        q.setColumnFamily( APPLICATION_AGGREGATE_COUNTERS.toString() );\n        q.setRange( start, finish, false, ALL_COUNT );\n        //Adding graphite metrics\n        Timer.Context timeGetAggregateCounters = aggCounterTimer.time();\n        QueryResult<CounterSlice<Long>> r = q.setKey(\n                counterUtils.getAggregateCounterRow( counterName, userId, groupId, queueId, category, resolution ) )\n                                             .execute();\n        timeGetAggregateCounters.stop();\n        List<AggregateCounter> counters = new ArrayList<AggregateCounter>();\n        for ( HCounterColumn<Long> column : r.get().getColumns() ) {\n            AggregateCounter count = new AggregateCounter( column.getName(), column.getValue() );\n            if ( pad && !( resolution == CounterResolution.ALL ) ) {\n                while ( count.getTimestamp() != expected_time ) {\n                    counters.add( new AggregateCounter( expected_time, 0 ) );\n                    expected_time = resolution.next( expected_time );\n                }\n                expected_time = resolution.next( expected_time );\n            }\n            counters.add( count );\n        }\n        if ( pad && !( resolution == CounterResolution.ALL ) ) {\n            while ( expected_time <= finish ) {\n                counters.add( new AggregateCounter( expected_time, 0 ) );\n                expected_time = resolution.next( expected_time );\n            }\n        }\n        return Results.fromCounters( new AggregateCounterSet( counterName, userId, groupId, category, counters ) );\n    }\n    @Override\n    public Results getAggregateCounters( Query query ) throws Exception {\n        CounterResolution resolution = query.getResolution();\n        if ( resolution == null ) {\n            resolution = CounterResolution.ALL;\n        }\n        long start = query.getStartTime() != null ? query.getStartTime() : 0;\n        long finish = query.getFinishTime() != null ? query.getFinishTime() : 0;\n        boolean pad = query.isPad();\n        if ( start <= 0 ) {\n            start = 0;\n        }\n        if ( ( finish <= 0 ) || ( finish < start ) ) {\n            finish = System.currentTimeMillis();\n        }\n        start = resolution.round( start );\n        finish = resolution.round( finish );\n        long expected_time = start;\n        if ( pad && ( resolution != CounterResolution.ALL ) ) {\n            long max_counters = ( finish - start ) / resolution.interval();\n            if ( max_counters > 1000 ) {\n                finish = resolution.round( start + ( resolution.interval() * 1000 ) );\n            }\n        }\n        List<Query.CounterFilterPredicate> filters = query.getCounterFilters();\n        if ( filters == null ) {\n            return null;\n        }\n        Map<String, CounterUtils.AggregateCounterSelection> selections =\n                new HashMap<String, CounterUtils.AggregateCounterSelection>();\n        Keyspace ko = cass.getApplicationKeyspace( applicationId );\n        for ( Query.CounterFilterPredicate filter : filters ) {\n            CounterUtils.AggregateCounterSelection selection =\n                new CounterUtils.AggregateCounterSelection( filter.getName(),\n                    getUuid( getUserByIdentifier( filter.getUser() ) ),\n                    getUuid( getGroupByIdentifier( filter.getGroup() ) ),\n                    org.apache.usergrid.mq.Queue.getQueueId( filter.getQueue() ), filter.getCategory() );\n            selections.put( selection.getRow( resolution ), selection );\n        }\n        MultigetSliceCounterQuery<String, Long> q = HFactory.createMultigetSliceCounterQuery( ko, se, le );\n        q.setColumnFamily( APPLICATION_AGGREGATE_COUNTERS.toString() );\n        q.setRange( start, finish, false, ALL_COUNT );\n        //Adding graphite metrics\n        Timer.Context timeGetAggregateCounters = entGetAggregateCountersQueryTimer.time();\n        QueryResult<CounterRows<String, Long>> rows = q.setKeys( selections.keySet() ).execute();\n        timeGetAggregateCounters.stop();\n        List<AggregateCounterSet> countSets = new ArrayList<AggregateCounterSet>();\n        for ( CounterRow<String, Long> r : rows.get() ) {\n            expected_time = start;\n            List<AggregateCounter> counters = new ArrayList<AggregateCounter>();\n            for ( HCounterColumn<Long> column : r.getColumnSlice().getColumns() ) {\n                AggregateCounter count = new AggregateCounter( column.getName(), column.getValue() );\n                if ( pad && ( resolution != CounterResolution.ALL ) ) {\n                    while ( count.getTimestamp() != expected_time ) {\n                        counters.add( new AggregateCounter( expected_time, 0 ) );\n                        expected_time = resolution.next( expected_time );\n                    }\n                    expected_time = resolution.next( expected_time );\n                }\n                counters.add( count );\n            }\n            if ( pad && ( resolution != CounterResolution.ALL ) ) {\n                while ( expected_time <= finish ) {\n                    counters.add( new AggregateCounter( expected_time, 0 ) );\n                    expected_time = resolution.next( expected_time );\n                }\n            }\n            CounterUtils.AggregateCounterSelection selection = selections.get( r.getKey() );\n            countSets.add( new AggregateCounterSet( selection.getName(), selection.getUserId(),\n                    selection.getGroupId(), selection.getCategory(), counters ) );\n        }\n        Collections.sort( countSets, new Comparator<AggregateCounterSet>() {\n            @Override\n            public int compare( AggregateCounterSet o1, AggregateCounterSet o2 ) {\n                String s1 = o1.getName();\n                String s2 = o2.getName();\n                return s1.compareTo( s2 );\n            }\n        } );\n        return Results.fromCounters( countSets );\n    }\n    @Override\n    public EntityRef getUserByIdentifier( Identifier identifier ) throws Exception {\n        if ( identifier == null ) {\n            if(logger.isDebugEnabled()){\n                logger.debug( \"getUserByIdentifier: returning null for null identifier\" );\n            }\n            return null;\n        }\n        if(logger.isTraceEnabled()){\n            logger.trace( \"getUserByIdentifier {}:{}\", identifier.getType(), identifier.toString() );\n        }\n        if ( identifier.isUUID() ) {\n            return new SimpleEntityRef( \"user\", identifier.getUUID() );\n        }\n        if ( identifier.isName() ) {\n            return this.getAlias( new SimpleEntityRef(\n                    Application.ENTITY_TYPE, applicationId ), \"user\", identifier.getName() );\n        }\n        if ( identifier.isEmail() ) {\n            final Iterable<EntityRef> emailProperty =\n                    getEntityRefsForUniqueProperty( Schema.defaultCollectionName( \"user\" ), \"email\",\n                            identifier.getEmail() );\n            for ( EntityRef firstRef : emailProperty ) {\n                return firstRef;\n            }\n            //            Query query = new Query();\n            //            query.setEntityType( \"user\" );\n            //            query.addEqualityFilter( \"email\", identifier.getEmail() );\n            //            query.setLimit( 1 );\n            //            query.setResultsLevel( REFS );\n            //\n            //            Results r = getRelationManager(\n            //                ref( Application.ENTITY_TYPE, applicationId ) ).searchCollection( \"users\", query );\n            //\n            //            if ( r != null && r.getRef() != null ) {\n            //                logger.debug(\"Got entity ref!\");\n            //                return r.getRef();\n            //            }\n            //            else {\n            // look-aside as it might be an email in the name field\n            return this.getAlias( new SimpleEntityRef( Application.ENTITY_TYPE, applicationId ), \"user\",\n                    identifier.getEmail() );\n            //            }\n        }\n        return null;\n    }\n    @Override\n    public EntityRef getGroupByIdentifier( Identifier identifier ) throws Exception {\n        if ( identifier == null ) {\n            return null;\n        }\n        if ( identifier.isUUID() ) {\n            return new SimpleEntityRef( \"group\", identifier.getUUID() );\n        }\n        if ( identifier.isName() ) {\n            return this.getAlias( new SimpleEntityRef( Application.ENTITY_TYPE, applicationId ), \"group\",\n                    identifier.getName() );\n        }\n        return null;\n    }\n<fim_suffix>    @Override\n    public Set<String> getCounterNames() throws Exception {\n        Set<String> names = new TreeSet<String>( CASE_INSENSITIVE_ORDER );\n        Set<String> nameSet = cast( getDictionaryAsSet( getApplicationRef(), Schema.DICTIONARY_COUNTERS ) );\n        names.addAll( nameSet );\n        return names;\n    }<fim_middle>// function below has no smell\n"}