{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.  The ASF licenses this file to you under the Apache License, Version\n * 2.0 (the \"License\"); you may not use this file except in compliance with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\n\npackage org.apache.storm.executor;\n\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.concurrent.atomic.AtomicReferenceArray;\nimport org.apache.storm.Config;\nimport org.apache.storm.daemon.worker.WorkerState;\nimport org.apache.storm.serialization.KryoTupleSerializer;\nimport org.apache.storm.tuple.AddressedTuple;\nimport org.apache.storm.utils.JCQueue;\nimport org.apache.storm.utils.ObjectReader;\nimport org.apache.storm.utils.Utils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n// Every executor has an instance of this class\n<fim_suffix>public class ExecutorTransfer {\n    private static final Logger LOG = LoggerFactory.getLogger(ExecutorTransfer.class);\n\n    private final WorkerState workerData;\n    private final KryoTupleSerializer serializer;\n    private final boolean isDebug;\n    private int indexingBase = 0;\n    private ArrayList<JCQueue> localReceiveQueues; // [taskId-indexingBase] => queue : List of all recvQs local to this worker\n    private AtomicReferenceArray<JCQueue> queuesToFlush;\n        // [taskId-indexingBase] => queue, some entries can be null. : outbound Qs for this executor instance\n\n\n    public ExecutorTransfer(WorkerState workerData, Map<String, Object> topoConf) {\n        this.workerData = workerData;\n        this.serializer = new KryoTupleSerializer(topoConf, workerData.getWorkerTopologyContext());\n        this.isDebug = ObjectReader.getBoolean(topoConf.get(Config.TOPOLOGY_DEBUG), false);\n    }\n\n    // to be called after all Executor objects in the worker are created and before this object is used\n    public void initLocalRecvQueues() {\n        Integer minTaskId = workerData.getLocalReceiveQueues().keySet().stream().min(Integer::compareTo).get();\n        this.localReceiveQueues = Utils.convertToArray(workerData.getLocalReceiveQueues(), minTaskId);\n        this.indexingBase = minTaskId;\n        this.queuesToFlush = new AtomicReferenceArray<JCQueue>(localReceiveQueues.size());\n    }\n\n    // adds addressedTuple to destination Q if it is not full. else adds to pendingEmits (if its not null)\n    public boolean tryTransfer(AddressedTuple addressedTuple, Queue<AddressedTuple> pendingEmits) {\n        if (isDebug) {\n            LOG.info(\"TRANSFERRING tuple {}\", addressedTuple);\n        }\n\n        JCQueue localQueue = getLocalQueue(addressedTuple);\n        if (localQueue != null) {\n            return tryTransferLocal(addressedTuple, localQueue, pendingEmits);\n        }\n        return workerData.tryTransferRemote(addressedTuple, pendingEmits, serializer);\n    }\n\n\n    // flushes local and remote messages\n    public void flush() throws InterruptedException {\n        flushLocal();\n        workerData.flushRemotes();\n    }\n\n    private void flushLocal() throws InterruptedException {\n        for (int i = 0; i < queuesToFlush.length(); i++) {\n            JCQueue q = queuesToFlush.get(i);\n            if (q != null) {\n                q.flush();\n                queuesToFlush.set(i, null);\n            }\n        }\n    }\n\n\n    public JCQueue getLocalQueue(AddressedTuple tuple) {\n        if ((tuple.dest - indexingBase) >= localReceiveQueues.size()) {\n            return null;\n        }\n        return localReceiveQueues.get(tuple.dest - indexingBase);\n    }\n\n    /**\n     * Adds tuple to localQueue (if overflow is empty). If localQueue is full adds to pendingEmits instead. pendingEmits can be null.\n     * Returns false if unable to add to localQueue.\n     */\n    public boolean tryTransferLocal(AddressedTuple tuple, JCQueue localQueue, Queue<AddressedTuple> pendingEmits) {\n        workerData.checkSerialize(serializer, tuple);\n        if (pendingEmits != null) {\n            if (pendingEmits.isEmpty() && localQueue.tryPublish(tuple)) {\n                queuesToFlush.set(tuple.dest - indexingBase, localQueue);\n                return true;\n            } else {\n                pendingEmits.add(tuple);\n                return false;\n            }\n        } else {\n            return localQueue.tryPublish(tuple);\n        }\n    }\n\n}<fim_middle>// class below is blob\n"}