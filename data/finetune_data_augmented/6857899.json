{"text": "<fim_prefix>    // Truncate potential overflows\n    instructions.add(ReilHelpers.createAnd(offset + 1, nextSize, addResult, archSize, mask,\n        archSize, \"esp\"));\n    // Store the value on the stack\n    instructions.add(ReilHelpers.createStm(offset + 2, size, value, archSize, \"esp\"));\n  }\n  /**\n   * Pushes all registers onto the stack (in correct order for pusha/pushaw)\n   *\n   * @param environment A valid translation environment\n   * @param baseOffset The next unused REIL offset\n   * @param size The size of the registers to push (either WORD or DWORD)\n   * @param instructions A list of REIL instructions where the new REIL code is added\n   *\n   * @throws IllegalArgumentException Thrown if any of the arguments are invalid\n   */\n  public static void generatePushAllRegisters(final ITranslationEnvironment environment,\n      final long baseOffset, final OperandSize size, final List<ReilInstruction> instructions)\n      throws IllegalArgumentException {\n    Preconditions.checkNotNull(environment, \"Error: Argument environment can't be null\");\n    Preconditions.checkNotNull(size, \"Error: Argument size can't be null\");\n    Preconditions.checkNotNull(instructions, \"Error: Argument instructions can't be null\");\n    Preconditions.checkArgument((size == OperandSize.WORD) || (size == OperandSize.DWORD),\n        \"Error: Invalid size argument\");\n    long offset = baseOffset;\n    final OperandSize archSize = environment.getArchitectureSize();\n    final String tempEsp = environment.getNextVariableString();\n    instructions.add(ReilHelpers.createStr(offset, archSize, \"esp\", archSize, tempEsp));\n    generateRegisterPush(environment, offset + 1, \"eax\", size, instructions);\n    offset = baseOffset + instructions.size();\n    generateRegisterPush(environment, offset, \"ebx\", size, instructions);\n    offset = baseOffset + instructions.size();\n    generateRegisterPush(environment, offset, \"ecx\", size, instructions);\n    offset = baseOffset + instructions.size();\n    generateRegisterPush(environment, offset, \"edx\", size, instructions);\n    offset = baseOffset + instructions.size();\n    generateRegisterPush(environment, offset, tempEsp, size, instructions);\n    offset = baseOffset + instructions.size();\n    generateRegisterPush(environment, offset, \"ebp\", size, instructions);\n    offset = baseOffset + instructions.size();\n    generateRegisterPush(environment, offset, \"esi\", size, instructions);\n    offset = baseOffset + instructions.size();\n    generateRegisterPush(environment, offset, \"edi\", size, instructions);\n    offset = baseOffset + instructions.size();\n  }\n  /**\n   * Generates code to set the Sign Flag\n   *\n   * @param environment A valid translation environment\n   * @param offset The next unused REIL offset\n   * @param value The value used to set the SF\n   * @param valueSize The size of the value\n   * @param instructions A list of REIL instructions where the new REIL code is added\n   *\n   * @throws IllegalArgumentException Thrown if any of the arguments are invalid\n   */\n  public static void generateSignFlagCode(final ITranslationEnvironment environment,\n      final long offset, final String value, final OperandSize valueSize,\n      final List<ReilInstruction> instructions) throws IllegalArgumentException {\n    Preconditions.checkNotNull(environment, \"Error: Argument environment can't be null\");\n    Preconditions.checkNotNull(value, \"Error: Argument value can't be null\");\n    Preconditions.checkNotNull(valueSize, \"Error: Argument valueSize can't be null\");\n    Preconditions.checkNotNull(instructions, \"Error: Argument instructions can't be null\");\n    final String maskValue = environment.getNextVariableString();\n    final String mask = String.valueOf(TranslationHelpers.getMsbMask(valueSize));\n    final String shiftValue = String.valueOf(TranslationHelpers.getShiftMsbLsbMask(valueSize));\n    // Isolate the MSB of the result and put it into the Sign Flag\n    instructions.add(ReilHelpers.createAnd(offset, valueSize, value, valueSize, mask, valueSize,\n        maskValue));\n    instructions.add(ReilHelpers.createBsh(offset + 1, valueSize, maskValue, valueSize, shiftValue,\n        OperandSize.BYTE, Helpers.SIGN_FLAG));\n  }\n  /**\n   * Generates code that subtracts two values and sets the flags according to the result.\n   *\n   * @param environment A valid translation environment\n   * @param offset The next unused REIL offset\n   * @param size The size of the two operands\n   * @param operand1 The first operand\n   * @param operand2 The second operand\n   * @param instructions A list of REIL instructions where the new REIL code is added\n   *\n   * @return The register that holds the result of the subtraction\n   *\n   * @throws IllegalArgumentException Thrown if any of the arguments are invalid\n   */\n<fim_suffix>  public static String generateSub(final ITranslationEnvironment environment, final long offset,\n      final OperandSize size, final String operand1, final String operand2,\n      final List<ReilInstruction> instructions) throws IllegalArgumentException {\n    Preconditions.checkNotNull(environment, \"Error: Argument environment can't be null\");\n    Preconditions.checkNotNull(size, \"Error: Argument size can't be null\");\n    Preconditions.checkNotNull(operand1, \"Error: Argument operand1 can't be null\");\n    Preconditions.checkNotNull(operand2, \"Error: Argument operand2 can't be null\");\n    final OperandSize resultSize = TranslationHelpers.getNextSize(size);\n    final String msbMask = String.valueOf(TranslationHelpers.getMsbMask(size));\n    final String shiftMsbLsb = String.valueOf(TranslationHelpers.getShiftMsbLsbMask(size));\n    final String carryMask = String.valueOf(getCarryMask(size));\n    final String shiftCarryLsb = String.valueOf(-size.getBitSize());\n    final String truncateMask = String.valueOf(TranslationHelpers.getAllBitsMask(size));\n    final String maskedOp1 = environment.getNextVariableString();\n    final String maskedOp2 = environment.getNextVariableString();\n    final String subResult = environment.getNextVariableString();\n    final String msbResult = environment.getNextVariableString();\n    final String msbSameBefore = environment.getNextVariableString();\n    final String msbHasChanged = environment.getNextVariableString();\n    final String tempOf = environment.getNextVariableString();\n    final String tempCf = environment.getNextVariableString();\n    final String truncatedResult = environment.getNextVariableString();\n    // Isolate the MSBs of the two operands\n    instructions.add(ReilHelpers.createAnd(offset, size, operand1, size, msbMask, size, maskedOp1));\n    instructions.add(ReilHelpers.createAnd(offset + 1, size, operand2, size, msbMask, size,\n        maskedOp2));\n    // Perform the subtraction\n    instructions.add(ReilHelpers.createSub(offset + 2, size, operand1, size, operand2, resultSize,\n        subResult));\n    // Isolate the MSB of the result and put it into the Sign Flag\n    instructions.add(ReilHelpers.createAnd(offset + 3, resultSize, subResult, resultSize, msbMask,\n        size, msbResult));\n    instructions.add(ReilHelpers.createBsh(offset + 4, size, msbResult, size, shiftMsbLsb,\n        OperandSize.BYTE, SIGN_FLAG));\n    // Find out if the MSB of the two operands were different and whether the MSB of the first\n    // operand changed\n    instructions.add(ReilHelpers.createXor(offset + 5, size, maskedOp1, size, maskedOp2, size,\n        msbSameBefore));\n    instructions.add(ReilHelpers.createXor(offset + 6, size, maskedOp1, size, msbResult, size,\n        msbHasChanged));\n    instructions.add(ReilHelpers.createAnd(offset + 7, size, msbSameBefore, size, msbHasChanged,\n        size, tempOf));\n    // Write the result into the Overflow Flag\n    instructions.add(ReilHelpers.createBsh(offset + 8, size, tempOf, size, shiftMsbLsb,\n        OperandSize.BYTE, OVERFLOW_FLAG));\n    // Update the Carry Flag\n    instructions.add(ReilHelpers.createAnd(offset + 9, resultSize, subResult, resultSize,\n        carryMask, resultSize, tempCf));\n    instructions.add(ReilHelpers.createBsh(offset + 10, resultSize, tempCf, resultSize,\n        shiftCarryLsb, OperandSize.BYTE, CARRY_FLAG));\n    // Truncate the result to fit into the target\n    instructions.add(ReilHelpers.createAnd(offset + 11, resultSize, subResult, resultSize,\n        truncateMask, size, truncatedResult));\n    // Update the Zero Flag\n    instructions.add(ReilHelpers.createBisz(offset + 12, size, truncatedResult, OperandSize.BYTE,\n        ZERO_FLAG));\n    return truncatedResult;\n  }<fim_middle>// function below has no smell\n"}