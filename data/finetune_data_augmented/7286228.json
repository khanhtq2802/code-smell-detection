{"text": "<fim_prefix>/*******************************************************************************\n * Copyright (c) 2012 Pivotal Software, Inc.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     Pivotal Software, Inc. - initial API and implementation\n *******************************************************************************/\npackage org.springsource.ide.eclipse.commons.tests;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport org.springsource.ide.eclipse.commons.frameworks.core.downloadmanager.DownloadManager;\nimport org.springsource.ide.eclipse.commons.frameworks.core.downloadmanager.DownloadManager.DownloadService;\nimport org.springsource.ide.eclipse.commons.frameworks.core.downloadmanager.DownloadableItem;\nimport org.springsource.ide.eclipse.commons.frameworks.core.util.IOUtil;\nimport junit.framework.TestCase;\npublic class DownloadManagerTests extends TestCase {\n<fim_suffix>\tpublic class TestContent {\n\t\tpublic final boolean isError;\n\t\tpublic final String data;\n\t\tpublic TestContent(boolean isError, String data) {\n\t\t\tthis.isError = isError;\n\t\t\tthis.data = data;\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tif (isError) {\n\t\t\t\treturn \"Error(\"+data+\")\";\n\t\t\t} else {\n\t\t\t\treturn data;\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * A test DownloadRequesto it 'accepts' downloaded data when it is equal to\n\t * the expected test data and throws an Error otherwise.\n\t */\n\tpublic class DownloadAcceptor implements DownloadManager.DownloadRequestor {\n\t\tprivate final String expected;\n\t\tpublic String data = null; // Set when data read successfully.\n\t\tpublic DownloadAcceptor(String expect) {\n\t\t\tthis.expected = expect;\n\t\t}\n\t\tpublic void exec(File downloadedFile) throws Exception {\n\t\t\tString data = getContents(downloadedFile);\n\t\t\tif (data.equals(expected)) {\n\t\t\t\tthis.data = data;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new Error(\"Bad data: \" + data);\n\t\t\t}\n\t\t}\n\t\tprivate String getContents(File downloadedFile) throws IOException {\n\t\t\tFileInputStream input = new FileInputStream(downloadedFile);\n\t\t\tByteArrayOutputStream data = new ByteArrayOutputStream();\n\t\t\tIOUtil.pipe(input, data);\n\t\t\treturn data.toString(\"utf8\");\n\t\t}\n\t}\n\t/**\n\t * A DownloadService who's behavior for specific urls can be 'programmed'.\n\t */\n\tpublic class TestDownloadService implements DownloadService {\n\t\tprivate final Map<String, LinkedList<TestContent>> responses = new HashMap<String, LinkedList<TestContent>>();\n\t\tpublic int fetchCount = 0;\n\t\tpublic void fetch(URL url, OutputStream writeTo) throws IOException {\n\t\t\tfetchCount++;\n\t\t\tLinkedList<TestContent> rs = responses.get(url.toString());\n\t\t\tif (rs == null || rs.isEmpty()) {\n\t\t\t\tthrow new IOException(\"Not found: \" + url);\n\t\t\t}\n\t\t\tTestContent r = rs.removeFirst();\n\t\t\trs.addLast(r);\n\t\t\tif (r.isError) {\n\t\t\t\tthrow new IOException(r.data);\n\t\t\t} else {\n\t\t\t\twriteTo.write(r.data.getBytes(\"utf8\"));\n\t\t\t}\n\t\t}\n\t\t/**\n\t\t * Make this downloadservice return given TestContent for a given url. \n\t\t * If more then one 'TestContent' element is provided the service will\n\t\t * cycle through them on each download attempt. For example if test content\n\t\t * is 'a', 'b', 'c' then the first download attempt will return 'a', the second\n\t\t * 'b', the third 'c' the fourth 'a' again and so on.\n\t\t */\n\t\tpublic void at(String url, TestContent... content) {\n\t\t\tassertTrue(content.length>0);\n\t\t\tresponses.put(url, new LinkedList<TestContent>(Arrays.asList(content)));\n\t\t}\n\t}\n\tprivate DownloadManager downloader;\n\tpublic void testSimple() throws Exception {\n\t\tTestDownloadService service = new TestDownloadService();\n\t\tservice.at(\"https://foo\", content(\"Content for https://foo\"));\n\t\tdownloader = new DownloadManager(service, null);\n\t\tdownloader.allowUIThread(true);\n\t\tFile cacheDir = downloader.getCacheDir();\n\t\ttry {\n\t\t\tDownloadAcceptor acceptor = new DownloadAcceptor(\"Content for https://foo\");\n\t\t\tdownloader.doWithDownload(item(\"foo\"), acceptor);\n\t\t\tassertEquals(\"Content for https://foo\", acceptor.data);\n\t\t}\n\t\tfinally {\n\t\t\tdownloader.dispose();\n\t\t\t// when cachedir was generated by DownloadManager it should be\n\t\t\t// deleted on dispose.\n\t\t\tassertFalse(cacheDir.exists());\n\t\t\tassertEquals(1, service.fetchCount);\n\t\t}\n\t}\n\tpublic void testSecondFetchFromCache() throws Exception {\n\t\tTestDownloadService service = new TestDownloadService();\n\t\tservice.at(\"https://foo\", content(\"Content for https://foo\"));\n\t\tdownloader = new DownloadManager(service, null);\n\t\tdownloader.allowUIThread(true);\n\t\tFile cacheDir = downloader.getCacheDir();\n\t\ttry {\n\t\t\tDownloadAcceptor acceptor = new DownloadAcceptor(\"Content for https://foo\");\n\t\t\tdownloader.doWithDownload(item(\"foo\"), acceptor);\n\t\t\tassertEquals(\"Content for https://foo\", acceptor.data);\n\t\t\tdownloader.doWithDownload(item(\"foo\"), acceptor);\n\t\t}\n\t\tfinally {\n\t\t\tdownloader.dispose();\n\t\t\t// when cachedir was generated by DownloadManager it should be\n\t\t\t// deleted on dispose.\n\t\t\tassertFalse(cacheDir.exists());\n\t\t\t//Twice using same data, but only one fetch!\n\t\t\tassertEquals(1, service.fetchCount);\n\t\t}\n\t}\n\t/**\n\t * Check that downloads are retried when download fails with an error.\n\t */\n\tpublic void testRetryOnError() throws Exception {\n\t\tTestDownloadService service = new TestDownloadService();\n\t\tservice.at(\"https://foo\", error(\"Foo\"), error(\"Foo\"), content(\"Foo\"));\n\t\tdownloader = new DownloadManager(service, null);\n\t\tdownloader.allowUIThread(true);\n\t\tFile cacheDir = downloader.getCacheDir();\n\t\ttry {\n\t\t\tDownloadAcceptor acceptor = new DownloadAcceptor(\"Foo\");\n\t\t\tdownloader.doWithDownload(item(\"foo\"), acceptor);\n\t\t\tassertEquals(\"Foo\", acceptor.data);\n\t\t}\n\t\tfinally {\n\t\t\tdownloader.dispose();\n\t\t\t// when cachedir was generated by DownloadManager it should be\n\t\t\t// deleted on dispose.\n\t\t\tassertFalse(cacheDir.exists());\n\t\t\t//Check fetch count. 2 failed attempts + 1 succesful = 3\n\t\t\tassertEquals(3, service.fetchCount);\n\t\t}\n\t}\n\t/**\n\t * Check that downloads are retried when download succeeds but data is\n\t * 'corrupted'.\n\t */\n\tpublic void testRetryOnCorruptedData() throws Exception {\n\t\tTestDownloadService service = new TestDownloadService();\n\t\tservice.at(\"https://foo\", content(\"CORRUPTED\"), content(\"GARBAGE\"), content(\"Foo\"));\n\t\tdownloader = new DownloadManager(service, null);\n\t\tdownloader.allowUIThread(true);\n\t\tFile cacheDir = downloader.getCacheDir();\n\t\ttry {\n\t\t\tDownloadAcceptor acceptor = new DownloadAcceptor(\"Foo\");\n\t\t\tdownloader.doWithDownload(item(\"foo\"), acceptor);\n\t\t\tassertEquals(\"Foo\", acceptor.data);\n\t\t} finally {\n\t\t\tdownloader.dispose();\n\t\t\t// when cachedir was generated by DownloadManager it should be\n\t\t\t// deleted on dispose.\n\t\t\tassertFalse(cacheDir.exists());\n\t\t\t//Check fetch count. 2 failed attempts + 1 succesfull = 3\n\t\t\tassertEquals(3, service.fetchCount);\n\t\t}\n\t}\n\t/**\n\t * Check that setting tries limits the number of tries as expected.\n\t */\n\tpublic void testRetryCountWithError() throws Exception {\n\t\tTestDownloadService service = new TestDownloadService();\n\t\tdownloader = new DownloadManager(service, null);\n\t\tdownloader.allowUIThread(true);\n\t\tdownloader.setTries(3);\n\t\tFile cacheDir = downloader.getCacheDir();\n\t\ttry {\n\t\t\tDownloadAcceptor acceptor = new DownloadAcceptor(\"Foo\");\n\t\t\tdownloader.doWithDownload(item(\"foo\"), acceptor);\n\t\t\tfail(\"Download should have failed\");\n\t\t} catch (IOException e) {\n\t\t\tassertEquals(\"Not found: https://foo\", e.getMessage());\n\t\t} finally {\n\t\t\tdownloader.dispose();<fim_middle>// class below has no smell\n"}