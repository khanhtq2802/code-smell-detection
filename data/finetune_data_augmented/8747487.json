{"text": "<fim_prefix>   * @return the protocol proxy\n   * @throws IOException if the far end through a RemoteException\n   */\n  public static <T> ProtocolProxy<T> getProtocolProxy(Class<T> protocol,\n                                long clientVersion,\n                                InetSocketAddress addr,\n                                UserGroupInformation ticket,\n                                Configuration conf,\n                                SocketFactory factory) throws IOException {\n    return getProtocolProxy(\n        protocol, clientVersion, addr, ticket, conf, factory, 0, null);\n  }\n  /**\n   * Construct a client-side proxy that implements the named protocol,\n   * talking to a server at the named address.\n   * @param <T>\n   * \n   * @param protocol protocol\n   * @param clientVersion client's version\n   * @param addr server address\n   * @param ticket security ticket\n   * @param conf configuration\n   * @param factory socket factory\n   * @param rpcTimeout max time for each rpc; 0 means no timeout\n   * @return the proxy\n   * @throws IOException if any error occurs\n   */\n  public static <T> T getProxy(Class<T> protocol,\n                                long clientVersion,\n                                InetSocketAddress addr,\n                                UserGroupInformation ticket,\n                                Configuration conf,\n                                SocketFactory factory,\n                                int rpcTimeout) throws IOException {\n    return getProtocolProxy(protocol, clientVersion, addr, ticket,\n             conf, factory, rpcTimeout, null).getProxy();\n  }\n  /**\n   * Get a protocol proxy that contains a proxy connection to a remote server\n   * and a set of methods that are supported by the server\n   * \n   * @param protocol protocol\n   * @param clientVersion client's version\n   * @param addr server address\n   * @param ticket security ticket\n   * @param conf configuration\n   * @param factory socket factory\n   * @param rpcTimeout max time for each rpc; 0 means no timeout\n   * @return the proxy\n   * @throws IOException if any error occurs\n   */\n   public static <T> ProtocolProxy<T> getProtocolProxy(Class<T> protocol,\n                                long clientVersion,\n                                InetSocketAddress addr,\n                                UserGroupInformation ticket,\n                                Configuration conf,\n                                SocketFactory factory,\n                                int rpcTimeout,\n                                RetryPolicy connectionRetryPolicy) throws IOException {    \n    if (UserGroupInformation.isSecurityEnabled()) {\n      SaslRpcServer.init(conf);\n    }\n    return getProtocolEngine(protocol,conf).getProxy(protocol, clientVersion,\n        addr, ticket, conf, factory, rpcTimeout, connectionRetryPolicy);\n  }\n   /**\n    * Construct a client-side proxy object with the default SocketFactory\n    * @param <T>\n    * \n    * @param protocol\n    * @param clientVersion\n    * @param addr\n    * @param conf\n    * @return a proxy instance\n    * @throws IOException\n    */\n   public static <T> T getProxy(Class<T> protocol,\n                                 long clientVersion,\n                                 InetSocketAddress addr, Configuration conf)\n     throws IOException {\n     return getProtocolProxy(protocol, clientVersion, addr, conf).getProxy();\n   }\n  /**\n   * Returns the server address for a given proxy.\n   */\n  public static InetSocketAddress getServerAddress(Object proxy) {\n    return getConnectionIdForProxy(proxy).getAddress();\n  }\n  /**\n   * Return the connection ID of the given object. If the provided object is in\n   * fact a protocol translator, we'll get the connection ID of the underlying\n   * proxy object.\n   * \n   * @param proxy the proxy object to get the connection ID of.\n   * @return the connection ID for the provided proxy object.\n   */\n  public static ConnectionId getConnectionIdForProxy(Object proxy) {\n    if (proxy instanceof ProtocolTranslator) {\n      proxy = ((ProtocolTranslator)proxy).getUnderlyingProxyObject();\n    }\n    RpcInvocationHandler inv = (RpcInvocationHandler) Proxy\n        .getInvocationHandler(proxy);\n    return inv.getConnectionId();\n  }\n  /**\n   * Get a protocol proxy that contains a proxy connection to a remote server\n   * and a set of methods that are supported by the server\n   * \n   * @param protocol\n   * @param clientVersion\n   * @param addr\n   * @param conf\n   * @return a protocol proxy\n   * @throws IOException\n   */\n  public static <T> ProtocolProxy<T> getProtocolProxy(Class<T> protocol,\n                                long clientVersion,\n                                InetSocketAddress addr, Configuration conf)\n    throws IOException {\n    return getProtocolProxy(protocol, clientVersion, addr, conf, NetUtils\n        .getDefaultSocketFactory(conf));\n  }\n  /**\n   * Stop the proxy. Proxy must either implement {@link Closeable} or must have\n   * associated {@link RpcInvocationHandler}.\n   * \n   * @param proxy\n   *          the RPC proxy object to be stopped\n   * @throws HadoopIllegalArgumentException\n   *           if the proxy does not implement {@link Closeable} interface or\n   *           does not have closeable {@link InvocationHandler}\n   */\n  public static void stopProxy(Object proxy) {\n    if (proxy == null) {\n      throw new HadoopIllegalArgumentException(\n          \"Cannot close proxy since it is null\");\n    }\n    try {\n      if (proxy instanceof Closeable) {\n        ((Closeable) proxy).close();\n        return;\n      } else {\n        InvocationHandler handler = Proxy.getInvocationHandler(proxy);\n        if (handler instanceof Closeable) {\n          ((Closeable) handler).close();\n          return;\n        }\n      }\n    } catch (IOException e) {\n      LOG.error(\"Closing proxy or invocation handler caused exception\", e);\n    } catch (IllegalArgumentException e) {\n      LOG.error(\"RPC.stopProxy called on non proxy: class=\" + proxy.getClass().getName(), e);\n    }\n    // If you see this error on a mock object in a unit test you're\n    // developing, make sure to use MockitoUtil.mockProtocol() to\n    // create your mock.\n    throw new HadoopIllegalArgumentException(\n        \"Cannot close proxy - is not Closeable or \"\n            + \"does not provide closeable invocation handler \"\n            + proxy.getClass());\n  }\n  /**\n   * Class to construct instances of RPC server with specific options.\n   */\n  public static class Builder {\n    private Class<?> protocol = null;\n    private Object instance = null;\n    private String bindAddress = \"0.0.0.0\";\n    private int port = 0;\n    private int numHandlers = 1;\n    private int numReaders = -1;\n    private int queueSizePerHandler = -1;\n    private boolean verbose = false;\n    private final Configuration conf;    \n    private SecretManager<? extends TokenIdentifier> secretManager = null;\n    private String portRangeConfig = null;\n    public Builder(Configuration conf) {\n      this.conf = conf;\n    }\n    /** Mandatory field */\n    public Builder setProtocol(Class<?> protocol) {\n      this.protocol = protocol;\n      return this;\n    }\n    /** Mandatory field */\n    public Builder setInstance(Object instance) {\n      this.instance = instance;\n      return this;\n    }\n    /** Default: 0.0.0.0 */\n    public Builder setBindAddress(String bindAddress) {\n      this.bindAddress = bindAddress;\n      return this;\n    }\n    /** Default: 0 */\n    public Builder setPort(int port) {\n      this.port = port;\n      return this;\n    }\n    /** Default: 1 */\n    public Builder setNumHandlers(int numHandlers) {\n      this.numHandlers = numHandlers;\n      return this;\n    }\n    /** Default: -1 */\n    public Builder setnumReaders(int numReaders) {\n      this.numReaders = numReaders;\n      return this;\n    }\n    /** Default: -1 */\n    public Builder setQueueSizePerHandler(int queueSizePerHandler) {\n      this.queueSizePerHandler = queueSizePerHandler;\n      return this;\n    }\n    /** Default: false */\n    public Builder setVerbose(boolean verbose) {\n      this.verbose = verbose;\n      return this;\n    }\n    /** Default: null */\n    public Builder setSecretManager(\n        SecretManager<? extends TokenIdentifier> secretManager) {\n      this.secretManager = secretManager;\n      return this;\n    }\n    /** Default: null */\n    public Builder setPortRangeConfig(String portRangeConfig) {\n      this.portRangeConfig = portRangeConfig;\n      return this;\n    }\n    /**\n     * Build the RPC Server. \n     * @throws IOException on error\n     * @throws HadoopIllegalArgumentException when mandatory fields are not set\n     */\n    public Server build() throws IOException, HadoopIllegalArgumentException {\n      if (this.conf == null) {\n        throw new HadoopIllegalArgumentException(\"conf is not set\");\n      }\n      if (this.protocol == null) {\n        throw new HadoopIllegalArgumentException(\"protocol is not set\");\n      }\n      if (this.instance == null) {\n        throw new HadoopIllegalArgumentException(\"instance is not set\");\n      }\n      return getProtocolEngine(this.protocol, this.conf).getServer(\n          this.protocol, this.instance, this.bindAddress, this.port,\n          this.numHandlers, this.numReaders, this.queueSizePerHandler,\n          this.verbose, this.conf, this.secretManager, this.portRangeConfig);\n    }\n  }\n  /** An RPC Server. */\n  public abstract static class Server extends org.apache.hadoop.ipc.Server {\n   boolean verbose;\n<fim_suffix>   static String classNameBase(String className) {\n      String[] names = className.split(\"\\\\.\", -1);\n      if (names == null || names.length == 0) {\n        return className;\n      }\n      return names[names.length-1];\n    }<fim_middle>// function below has no smell\n"}