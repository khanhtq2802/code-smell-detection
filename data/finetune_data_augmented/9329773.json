{"text": "<fim_prefix>/*\n * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage jdk.internal.net.http;\nimport java.io.IOException;\nimport java.net.ConnectException;\nimport java.net.InetSocketAddress;\nimport java.net.StandardSocketOptions;\nimport java.nio.channels.SelectableChannel;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.SocketChannel;\nimport java.security.AccessController;\nimport java.security.PrivilegedActionException;\nimport java.security.PrivilegedExceptionAction;\nimport java.time.Duration;\nimport java.util.concurrent.CompletableFuture;\nimport jdk.internal.net.http.common.FlowTube;\nimport jdk.internal.net.http.common.Log;\nimport jdk.internal.net.http.common.MinimalFuture;\nimport jdk.internal.net.http.common.Utils;\n/**\n * Plain raw TCP connection direct to destination.\n * The connection operates in asynchronous non-blocking mode.\n * All reads and writes are done non-blocking.\n */\nclass PlainHttpConnection extends HttpConnection {\n    private final Object reading = new Object();\n    protected final SocketChannel chan;\n    private final SocketTube tube; // need SocketTube to call signalClosed().\n    private final PlainHttpPublisher writePublisher = new PlainHttpPublisher(reading);\n    private volatile boolean connected;\n    private boolean closed;\n    private volatile ConnectTimerEvent connectTimerEvent;  // may be null\n    // should be volatile to provide proper synchronization(visibility) action\n    /**\n     * Returns a ConnectTimerEvent iff there is a connect timeout duration,\n     * otherwise null.\n     */\n    private ConnectTimerEvent newConnectTimer(Exchange<?> exchange,\n                                              CompletableFuture<Void> cf) {\n        Duration duration = exchange.remainingConnectTimeout().orElse(null);\n        if (duration != null) {\n            ConnectTimerEvent cte = new ConnectTimerEvent(duration, exchange, cf);\n            return cte;\n        }\n        return null;\n    }\n    final class ConnectTimerEvent extends TimeoutEvent {\n        private final CompletableFuture<Void> cf;\n        private final Exchange<?> exchange;\n        ConnectTimerEvent(Duration duration,\n                          Exchange<?> exchange,\n                          CompletableFuture<Void> cf) {\n            super(duration);\n            this.exchange = exchange;\n            this.cf = cf;\n        }\n        @Override\n        public void handle() {\n            if (debug.on()) {\n                debug.log(\"HTTP connect timed out\");\n            }\n            ConnectException ce = new ConnectException(\"HTTP connect timed out\");\n            exchange.multi.cancel(ce);\n            client().theExecutor().execute(() -> cf.completeExceptionally(ce));\n        }\n        @Override\n        public String toString() {\n            return \"ConnectTimerEvent, \" + super.toString();\n        }\n    }\n    final class ConnectEvent extends AsyncEvent {\n        private final CompletableFuture<Void> cf;\n        ConnectEvent(CompletableFuture<Void> cf) {\n            this.cf = cf;\n        }\n        @Override\n        public SelectableChannel channel() {\n            return chan;\n        }\n        @Override\n        public int interestOps() {\n            return SelectionKey.OP_CONNECT;\n        }\n        @Override\n        public void handle() {\n            try {\n                assert !connected : \"Already connected\";\n                assert !chan.isBlocking() : \"Unexpected blocking channel\";\n                if (debug.on())\n                    debug.log(\"ConnectEvent: finishing connect\");\n                boolean finished = chan.finishConnect();\n                assert finished : \"Expected channel to be connected\";\n                if (debug.on())\n                    debug.log(\"ConnectEvent: connect finished: %s Local addr: %s\",\n                              finished, chan.getLocalAddress());\n                // complete async since the event runs on the SelectorManager thread\n                cf.completeAsync(() -> null, client().theExecutor());\n            } catch (Throwable e) {\n                Throwable t = Utils.toConnectException(e);\n                client().theExecutor().execute( () -> cf.completeExceptionally(t));\n                close();\n            }\n        }\n        @Override\n        public void abort(IOException ioe) {\n            client().theExecutor().execute( () -> cf.completeExceptionally(ioe));\n            close();\n        }\n    }\n    @Override\n    public CompletableFuture<Void> connectAsync(Exchange<?> exchange) {\n        CompletableFuture<Void> cf = new MinimalFuture<>();\n        try {\n            assert !connected : \"Already connected\";\n            assert !chan.isBlocking() : \"Unexpected blocking channel\";\n            boolean finished;\n            connectTimerEvent = newConnectTimer(exchange, cf);\n            if (connectTimerEvent != null) {\n                if (debug.on())\n                    debug.log(\"registering connect timer: \" + connectTimerEvent);\n                client().registerTimer(connectTimerEvent);\n            }\n            PrivilegedExceptionAction<Boolean> pa =\n                    () -> chan.connect(Utils.resolveAddress(address));\n            try {\n                 finished = AccessController.doPrivileged(pa);\n            } catch (PrivilegedActionException e) {\n               throw e.getCause();\n            }\n            if (finished) {\n                if (debug.on()) debug.log(\"connect finished without blocking\");\n                cf.complete(null);\n            } else {\n                if (debug.on()) debug.log(\"registering connect event\");\n                client().registerEvent(new ConnectEvent(cf));\n            }\n        } catch (Throwable throwable) {\n            cf.completeExceptionally(Utils.toConnectException(throwable));\n            try {\n                close();\n            } catch (Exception x) {\n                if (debug.on())\n                    debug.log(\"Failed to close channel after unsuccessful connect\");\n            }\n        }\n        return cf;\n    }\n    @Override\n    public CompletableFuture<Void> finishConnect() {\n        assert connected == false;\n        if (debug.on()) debug.log(\"finishConnect, setting connected=true\");\n        connected = true;\n        if (connectTimerEvent != null)\n            client().cancelTimer(connectTimerEvent);\n        return MinimalFuture.completedFuture(null);\n    }\n    @Override\n    SocketChannel channel() {\n        return chan;\n    }\n    @Override\n    final FlowTube getConnectionFlow() {\n        return tube;\n    }\n<fim_suffix>    PlainHttpConnection(InetSocketAddress addr, HttpClientImpl client) {\n        super(addr, client);\n        try {\n            this.chan = SocketChannel.open();\n            chan.configureBlocking(false);\n            trySetReceiveBufferSize(client.getReceiveBufferSize());\n            if (debug.on()) {\n                int bufsize = getInitialBufferSize();\n                debug.log(\"Initial receive buffer size is: %d\", bufsize);\n            }\n            chan.setOption(StandardSocketOptions.TCP_NODELAY, true);\n            // wrap the channel in a Tube for async reading and writing\n            tube = new SocketTube(client(), chan, Utils::getBuffer);\n        } catch (IOException e) {\n            throw new InternalError(e);\n        }\n    }\n    private int getInitialBufferSize() {\n        try {\n            return chan.getOption(StandardSocketOptions.SO_RCVBUF);\n        } catch(IOException x) {\n            if (debug.on())\n                debug.log(\"Failed to get initial receive buffer size on %s\", chan);\n        }\n        return 0;\n    }\n    private void trySetReceiveBufferSize(int bufsize) {\n        try {\n            if (bufsize > 0) {\n                chan.setOption(StandardSocketOptions.SO_RCVBUF, bufsize);\n            }\n        } catch(IOException x) {\n            if (debug.on())\n                debug.log(\"Failed to set receive buffer size to %d on %s\",\n                          bufsize, chan);\n        }\n    }\n    @Override\n    HttpPublisher publisher() { return writePublisher; }\n    @Override\n    public String toString() {\n        return \"PlainHttpConnection: \" + super.toString();\n    }\n    /**\n     * Closes this connection\n     */\n    @Override\n    public void close() {\n        synchronized (this) {\n            if (closed) {\n                return;\n            }\n            closed = true;\n        }\n        try {\n            Log.logTrace(\"Closing: \" + toString());<fim_middle>// function below has no smell\n"}