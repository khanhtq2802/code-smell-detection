{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.disruptor;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.apache.camel.Endpoint;\nimport org.apache.camel.spi.Metadata;\nimport org.apache.camel.spi.annotations.Component;\nimport org.apache.camel.support.DefaultComponent;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n/**\n * An implementation of the <a href=\"https://github.com/sirchia/camel-disruptor\">Disruptor component</a>\n * for asynchronous SEDA exchanges on an\n * <a href=\"https://github.com/LMAX-Exchange/disruptor\">LMAX Disruptor</a> within a CamelContext\n */\n@Component(\"disruptor\")\npublic class DisruptorComponent extends DefaultComponent {\n    public static final int DEFAULT_BUFFER_SIZE = 1024;\n    public static final int MAX_CONCURRENT_CONSUMERS = 500;\n    private static final Logger LOGGER = LoggerFactory.getLogger(DisruptorComponent.class);\n    @Metadata(defaultValue = \"\" + DEFAULT_BUFFER_SIZE)\n    private int bufferSize = -1;\n    //for SEDA compatibility only\n    private int queueSize = -1;\n    @Metadata(label = \"consumer\", defaultValue = \"1\")\n    private int defaultConcurrentConsumers = 1;\n    @Metadata(label = \"consumer\")\n    private boolean defaultMultipleConsumers;\n    @Metadata(label = \"producer\", defaultValue = \"Multi\")\n    private DisruptorProducerType defaultProducerType = DisruptorProducerType.Multi;\n    @Metadata(label = \"consumer\", defaultValue = \"Blocking\")\n    private DisruptorWaitStrategy defaultWaitStrategy = DisruptorWaitStrategy.Blocking;\n    @Metadata(label = \"producer\", defaultValue = \"true\")\n    private boolean defaultBlockWhenFull = true;\n    //synchronized access guarded by this\n    private final Map<String, DisruptorReference> disruptors = new HashMap<>();\n    public DisruptorComponent() {\n    }\n<fim_suffix>    @Override\n    protected Endpoint createEndpoint(final String uri, final String remaining,\n                                      final Map<String, Object> parameters) throws Exception {\n        final int concurrentConsumers = getAndRemoveParameter(parameters, \"concurrentConsumers\", Integer.class, defaultConcurrentConsumers);\n        final boolean limitConcurrentConsumers = getAndRemoveParameter(parameters, \"limitConcurrentConsumers\", Boolean.class, true);\n        if (limitConcurrentConsumers && concurrentConsumers > MAX_CONCURRENT_CONSUMERS) {\n            throw new IllegalArgumentException(\n                    \"The limitConcurrentConsumers flag in set to true. ConcurrentConsumers cannot be set at a value greater than \"\n                            + MAX_CONCURRENT_CONSUMERS + \" was \" + concurrentConsumers);\n        }\n        if (concurrentConsumers < 0) {\n            throw new IllegalArgumentException(\"concurrentConsumers found to be \" + concurrentConsumers \n                                               + \", must be greater than 0\");\n        }\n        int size = 0;\n        if (parameters.containsKey(\"size\")) {\n            size = getAndRemoveParameter(parameters, \"size\", int.class);\n            if (size <= 0) {\n                throw new IllegalArgumentException(\"size found to be \" + size + \", must be greater than 0\");\n            }\n        }\n        // Check if the pollTimeout argument is set (may be the case if Disruptor component is used as drop-in\n        // replacement for the SEDA component.\n        if (parameters.containsKey(\"pollTimeout\")) {\n            throw new IllegalArgumentException(\"The 'pollTimeout' argument is not supported by the Disruptor component\");\n        }\n        final DisruptorWaitStrategy waitStrategy = getAndRemoveParameter(parameters, \"waitStrategy\", DisruptorWaitStrategy.class, defaultWaitStrategy);\n        final DisruptorProducerType producerType = getAndRemoveParameter(parameters, \"producerType\", DisruptorProducerType.class, defaultProducerType);\n        final boolean multipleConsumers = getAndRemoveParameter(parameters, \"multipleConsumers\", boolean.class, defaultMultipleConsumers);\n        final boolean blockWhenFull = getAndRemoveParameter(parameters, \"blockWhenFull\", boolean.class, defaultBlockWhenFull);\n        final DisruptorReference disruptorReference = getOrCreateDisruptor(uri, remaining, size, producerType, waitStrategy);\n        final DisruptorEndpoint disruptorEndpoint = new DisruptorEndpoint(uri, this, disruptorReference, concurrentConsumers, multipleConsumers, blockWhenFull);\n        disruptorEndpoint.setWaitStrategy(waitStrategy);\n        disruptorEndpoint.setProducerType(producerType);\n        disruptorEndpoint.configureProperties(parameters);\n        return disruptorEndpoint;\n    }\n    private DisruptorReference getOrCreateDisruptor(final String uri, final String name, final int size,\n                                                    final DisruptorProducerType producerType,\n                                                    final DisruptorWaitStrategy waitStrategy) throws Exception {\n        final String key = getDisruptorKey(uri);\n        int sizeToUse;\n        if (size > 0) {\n            sizeToUse = size;\n        } else if (bufferSize > 0) {\n            sizeToUse = bufferSize;\n        } else if (queueSize > 0) {\n            sizeToUse = queueSize;\n        } else {\n            sizeToUse = DEFAULT_BUFFER_SIZE;\n        }\n        sizeToUse = powerOfTwo(sizeToUse);\n        synchronized (this) {\n            DisruptorReference ref = getDisruptors().get(key);\n            if (ref == null) {\n                LOGGER.debug(\"Creating new disruptor for key {}\", key);\n                ref = new DisruptorReference(this, uri, name, sizeToUse, producerType, waitStrategy);\n                getDisruptors().put(key, ref);\n            } else {\n                //if size was explicitly requested, the size to use should match the retrieved DisruptorReference\n                if (size != 0 && ref.getBufferSize() != sizeToUse) {\n                    // there is already a queue, so make sure the size matches\n                    throw new IllegalArgumentException(\n                            \"Cannot use existing queue \" + key + \" as the existing queue size \"\n                                    + ref.getBufferSize() + \" does not match given queue size \" + sizeToUse);\n                }\n                LOGGER.debug(\"Reusing disruptor {} for key {}\", ref, key);\n            }\n            return ref;\n        }\n    }\n    private static int powerOfTwo(int size) {\n        size--;\n        size |= size >> 1;\n        size |= size >> 2;\n        size |= size >> 4;\n        size |= size >> 8;\n        size |= size >> 16;\n        size++;\n        return size;\n    }\n    public static String getDisruptorKey(String uri) {\n        if (uri.contains(\"?\")) {\n            // strip parameters\n            uri = uri.substring(0, uri.indexOf('?'));\n        }\n        return uri;\n    }\n    @Override\n    protected void doStop() throws Exception {\n        synchronized (this) {\n            getDisruptors().clear();\n        }\n        super.doStop();\n    }\n    public Map<String, DisruptorReference> getDisruptors() {\n        return disruptors;\n    }\n    public int getDefaultConcurrentConsumers() {\n        return defaultConcurrentConsumers;\n    }\n    /**\n     * To configure the default number of concurrent consumers\n     */\n    public void setDefaultConcurrentConsumers(final int defaultConcurrentConsumers) {\n        this.defaultConcurrentConsumers = defaultConcurrentConsumers;\n    }\n    public boolean isDefaultMultipleConsumers() {\n        return defaultMultipleConsumers;\n    }\n    /**\n     * To configure the default value for multiple consumers\n     */\n    public void setDefaultMultipleConsumers(final boolean defaultMultipleConsumers) {\n        this.defaultMultipleConsumers = defaultMultipleConsumers;\n    }\n    public DisruptorProducerType getDefaultProducerType() {\n        return defaultProducerType;\n    }\n    /**\n     * To configure the default value for DisruptorProducerType\n     * <p/>\n     * The default value is Multi.\n     */\n    public void setDefaultProducerType(final DisruptorProducerType defaultProducerType) {\n        this.defaultProducerType = defaultProducerType;\n    }\n    public DisruptorWaitStrategy getDefaultWaitStrategy() {\n        return defaultWaitStrategy;\n    }\n    /**\n     * To configure the default value for DisruptorWaitStrategy\n     * <p/>\n     * The default value is Blocking.\n     */\n    public void setDefaultWaitStrategy(final DisruptorWaitStrategy defaultWaitStrategy) {\n        this.defaultWaitStrategy = defaultWaitStrategy;<fim_middle>// function below is long method and feature envy\n"}