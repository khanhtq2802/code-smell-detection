{"text": "<fim_prefix>                    }\n                    throw new IgniteCheckedException(e);\n                }\n                finally {\n                    sessionEnd0(tx, threwEx);\n                }\n                if (log.isDebugEnabled())\n                    log.debug(\"Stored value in cache store [entries=\" + entries + ']');\n                return true;\n            }\n            return false;\n        }\n    }\n    /** {@inheritDoc} */\n    @Override public final boolean remove(@Nullable IgniteInternalTx tx, KeyCacheObject key) throws IgniteCheckedException {\n        if (store != null) {\n            // Never remove internal key from store as it is never persisted.\n            if (key instanceof GridCacheInternal)\n                return false;\n            Object key0 = cctx.unwrapBinaryIfNeeded(key, !convertBinary());\n            if (log.isDebugEnabled())\n                log.debug(S.toString(\"Removing value from cache store\", \"key\", key0, true));\n            sessionInit0(tx, StoreOperation.WRITE, false);\n            boolean threwEx = true;\n            try {\n                store.delete(key0);\n                threwEx = false;\n            }\n            catch (ClassCastException e) {\n                handleClassCastException(e);\n            }\n            catch (CacheWriterException e) {\n                throw new IgniteCheckedException(e);\n            }\n            catch (Exception e) {\n                throw new IgniteCheckedException(new CacheWriterException(e));\n            }\n            finally {\n                sessionEnd0(tx, threwEx);\n            }\n            if (log.isDebugEnabled())\n                log.debug(S.toString(\"Removed value from cache store\", \"key\", key0, true));\n            return true;\n        }\n        return false;\n    }\n    /** {@inheritDoc} */\n    @Override public final boolean removeAll(\n        @Nullable IgniteInternalTx tx,\n        Collection<? extends KeyCacheObject> keys\n    ) throws IgniteCheckedException {\n        if (F.isEmpty(keys))\n            return true;\n        if (keys.size() == 1) {\n            KeyCacheObject key = keys.iterator().next();\n            return remove(tx, key);\n        }\n        if (store != null) {\n            Collection<Object> keys0 = cctx.unwrapBinariesIfNeeded(keys, !convertBinary());\n            if (log.isDebugEnabled())\n                log.debug(S.toString(\"Removing values from cache store\",\n                    \"keys\", keys0, true));\n            sessionInit0(tx, StoreOperation.WRITE, false);\n            boolean threwEx = true;\n            try {\n                store.deleteAll(keys0);\n                threwEx = false;\n            }\n            catch (ClassCastException e) {\n                handleClassCastException(e);\n            }\n            catch (Exception e) {\n                if (!(e instanceof CacheWriterException))\n                    e = new CacheWriterException(e);\n                if (!keys0.isEmpty())\n                    throw new CacheStorePartialUpdateException(keys0, e);\n                throw new IgniteCheckedException(e);\n            }\n            finally {\n                sessionEnd0(tx, threwEx);\n            }\n            if (log.isDebugEnabled())\n                log.debug(S.toString(\"Removed values from cache store\",\n                    \"keys\", keys0, true));\n            return true;\n        }\n        return false;\n    }\n    /** {@inheritDoc} */\n    @Override public CacheStore<Object, Object> store() {\n        return store;\n    }\n    /** {@inheritDoc} */\n    @Override public void forceFlush() throws IgniteCheckedException {\n        if (store instanceof GridCacheWriteBehindStore)\n            ((GridCacheWriteBehindStore)store).forceFlush();\n    }\n    /** {@inheritDoc} */\n    @Override public final void sessionEnd(IgniteInternalTx tx, boolean commit, boolean last,\n        boolean storeSessionEnded) throws IgniteCheckedException {\n        assert store != null;\n        sessionInit0(tx, commit? StoreOperation.COMMIT: StoreOperation.ROLLBACK, false);\n        try {\n            if (sesLsnrs != null && sesHolder.get().contains(store)) {\n                for (CacheStoreSessionListener lsnr : sesLsnrs)\n                    lsnr.onSessionEnd(locSes, commit);\n            }\n            if (!sesHolder.get().ended(store) && !storeSessionEnded)\n                store.sessionEnd(commit);\n        }\n        catch (Throwable e) {\n            last = true;\n            throw e;\n        }\n        finally {\n            if (last && sesHolder != null) {\n                sesHolder.set(null);\n                tx.removeMeta(SES_ATTR);\n            }\n        }\n    }\n    /**\n     * @param e Class cast exception.\n     * @throws IgniteCheckedException Thrown exception.\n     */\n    private void handleClassCastException(ClassCastException e) throws IgniteCheckedException {\n        assert e != null;\n        if (e.getMessage() != null) {\n            throw new IgniteCheckedException(\"Cache store must work with binary objects if binary are \" +\n                \"enabled for cache [cacheName=\" + cctx.name() + ']', e);\n        }\n        else\n            throw e;\n    }\n    /** {@inheritDoc} */\n    @Override public void writeBehindSessionInit() throws IgniteCheckedException {\n        sessionInit0(null, null, true);\n    }\n    /** {@inheritDoc} */\n    @Override public void writeBehindCacheStoreSessionListenerStart()  throws IgniteCheckedException {\n        assert sesHolder.get() != null;\n        notifyCacheStoreSessionListeners(sesHolder.get(), null, true);\n    }\n    /** {@inheritDoc} */\n    @Override public void writeBehindSessionEnd(boolean threwEx) throws IgniteCheckedException {\n        sessionEnd0(null, threwEx);\n    }\n    /**\n     * @param tx Current transaction.\n     * @param op Store operation.\n     * @param writeBehindStoreInitiator {@code true} if method call is initiated by {@link GridCacheWriteBehindStore}.\n     * @throws IgniteCheckedException If failed.\n     */\n    private void sessionInit0(@Nullable IgniteInternalTx tx, @Nullable StoreOperation op,\n        boolean writeBehindStoreInitiator) throws IgniteCheckedException {\n        assert sesHolder != null;\n        SessionData ses;\n        if (tx != null) {\n            ses = tx.meta(SES_ATTR);\n            if (ses == null) {\n                ses = new SessionData(tx, cctx.name());\n                tx.addMeta(SES_ATTR, ses);\n            }\n            else\n                // Session cache name may change in cross-cache transaction.\n                ses.cacheName(cctx.name());\n        }\n        else\n            ses = new SessionData(null, cctx.name());\n        sesHolder.set(ses);\n        notifyCacheStoreSessionListeners(ses, op, writeBehindStoreInitiator);\n    }\n    /**\n     * @param ses Current session.\n     * @param op Store operation.\n     * @param writeBehindStoreInitiator {@code True} if method call is initiated by {@link GridCacheWriteBehindStore}.\n     * @throws IgniteCheckedException If failed.\n     */\n    private void notifyCacheStoreSessionListeners(SessionData ses, @Nullable StoreOperation op,\n        boolean writeBehindStoreInitiator) throws IgniteCheckedException {\n        try {\n            boolean notifyLsnrs = false;\n            if (writeBehindStoreInitiator)\n                notifyLsnrs = !ses.started(store) && sesLsnrs != null;\n            else {\n                assert op != null;\n                switch (op) {\n                    case READ:\n                        notifyLsnrs = readThrough && !ses.started(store) && sesLsnrs != null;\n                        break;\n                    case WRITE:\n                        notifyLsnrs = !cacheConfiguration().isWriteBehindEnabled() && writeThrough\n                            && !ses.started(store) && sesLsnrs != null;\n                        break;\n                    case COMMIT:\n                    case ROLLBACK:\n                        // No needs to start the session (if not started yet) and notify listeners.\n                        break;\n                    default:\n                        assert false : \"Unexpected operation: \" + op.toString();\n                }\n            }\n            if (notifyLsnrs) {\n                for (CacheStoreSessionListener lsnr : sesLsnrs)\n                    lsnr.onSessionStart(locSes);\n            }\n        }\n        catch (Exception e) {\n            throw new IgniteCheckedException(\"Failed to start store session: \" + e, e);\n        }\n    }\n    /**\n     * Clears session holder.\n     */\n<fim_suffix>    private void sessionEnd0(@Nullable IgniteInternalTx tx, boolean threwEx) throws IgniteCheckedException {\n        try {\n            if (tx == null) {\n                if (sesLsnrs != null && sesHolder.get().contains(store)) {\n                    for (CacheStoreSessionListener lsnr : sesLsnrs)\n                        lsnr.onSessionEnd(locSes, !threwEx);\n                }\n                if (!sesHolder.get().ended(store))\n                    store.sessionEnd(!threwEx);\n            }\n        }\n        catch (Exception e) {\n            if (!threwEx)\n                throw U.cast(e);\n        }\n        finally {\n            if (sesHolder != null)\n                sesHolder.set(null);\n        }\n    }<fim_middle>// function below is long method\n"}