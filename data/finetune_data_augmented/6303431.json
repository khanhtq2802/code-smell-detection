{"text": "<fim_prefix>//\n//  ========================================================================\n//  Copyright (c) 1995-2019 Mort Bay Consulting Pty. Ltd.\n//  ------------------------------------------------------------------------\n//  All rights reserved. This program and the accompanying materials\n//  are made available under the terms of the Eclipse Public License v1.0\n//  and Apache License v2.0 which accompanies this distribution.\n//\n//      The Eclipse Public License is available at\n//      http://www.eclipse.org/legal/epl-v10.html\n//\n//      The Apache License v2.0 is available at\n//      http://www.opensource.org/licenses/apache2.0.php\n//\n//  You may elect to redistribute this code under either of these licenses.\n//  ========================================================================\n//\n\npackage org.eclipse.jetty.websocket.common.extensions.compress;\n\nimport java.nio.ByteBuffer;\nimport java.util.zip.DataFormatException;\n\nimport org.eclipse.jetty.util.log.Log;\nimport org.eclipse.jetty.util.log.Logger;\nimport org.eclipse.jetty.websocket.api.BadPayloadException;\nimport org.eclipse.jetty.websocket.api.BatchMode;\nimport org.eclipse.jetty.websocket.api.ProtocolException;\nimport org.eclipse.jetty.websocket.api.WriteCallback;\nimport org.eclipse.jetty.websocket.api.extensions.ExtensionConfig;\nimport org.eclipse.jetty.websocket.api.extensions.Frame;\nimport org.eclipse.jetty.websocket.common.OpCode;\n\n/**\n * Per Message Deflate Compression extension for WebSocket.\n * <p>\n * Attempts to follow <a href=\"https://tools.ietf.org/html/rfc7692\">Compression Extensions for WebSocket</a>\n */\npublic class PerMessageDeflateExtension extends CompressExtension\n{\n    private static final Logger LOG = Log.getLogger(PerMessageDeflateExtension.class);\n\n    private ExtensionConfig configRequested;\n    private ExtensionConfig configNegotiated;\n    private boolean incomingContextTakeover = true;\n    private boolean outgoingContextTakeover = true;\n    private boolean incomingCompressed;\n\n    @Override\n    public String getName()\n    {\n        return \"permessage-deflate\";\n    }\n\n    @Override\n    public void incomingFrame(Frame frame)\n    {\n        // Incoming frames are always non concurrent because\n        // they are read and parsed with a single thread, and\n        // therefore there is no need for synchronization.\n\n        // This extension requires the RSV1 bit set only in the first frame.\n        // Subsequent continuation frames don't have RSV1 set, but are compressed.\n        if (frame.getType().isData())\n        {\n            incomingCompressed = frame.isRsv1();\n        }\n\n        if (OpCode.isControlFrame(frame.getOpCode()) || !incomingCompressed)\n        {\n            nextIncomingFrame(frame);\n            return;\n        }\n\n        if (frame.getOpCode() == OpCode.CONTINUATION && frame.isRsv1())\n        {\n            // Per RFC7692 we MUST Fail the websocket connection\n            throw new ProtocolException(\"Invalid RSV1 set on permessage-deflate CONTINUATION frame\");\n        }\n        \n        ByteAccumulator accumulator = newByteAccumulator();\n        \n        try \n        {\n            ByteBuffer payload = frame.getPayload();\n            decompress(accumulator, payload);\n            if (frame.isFin())\n            {\n                decompress(accumulator, TAIL_BYTES_BUF.slice());\n            }\n            \n            forwardIncoming(frame, accumulator);\n        }\n        catch (DataFormatException e)\n        {\n            throw new BadPayloadException(e);\n        }\n\n        if (frame.isFin())\n            incomingCompressed = false;\n    }\n\n    @Override\n    protected void nextIncomingFrame(Frame frame)\n    {\n        if (frame.isFin() && !incomingContextTakeover)\n        {\n            LOG.debug(\"Incoming Context Reset\");\n            decompressCount.set(0);\n            getInflater().reset();\n        }\n        super.nextIncomingFrame(frame);\n    }\n\n    @Override\n    protected void nextOutgoingFrame(Frame frame, WriteCallback callback, BatchMode batchMode)\n    {\n        if (frame.isFin() && !outgoingContextTakeover)\n        {\n            LOG.debug(\"Outgoing Context Reset\");\n            getDeflater().reset();\n        }\n        super.nextOutgoingFrame(frame, callback, batchMode);\n    }\n    \n    @Override\n    int getRsvUseMode()\n    {\n        return RSV_USE_ONLY_FIRST;\n    }\n    \n    @Override\n    int getTailDropMode()\n    {\n        return TAIL_DROP_FIN_ONLY;\n    }\n\n    @Override\n    public void setConfig(final ExtensionConfig config)\n    {\n        configRequested = new ExtensionConfig(config);\n        configNegotiated = new ExtensionConfig(config.getName());\n        \n        for (String key : config.getParameterKeys())\n        {\n            key = key.trim();\n            switch (key)\n            {\n                case \"client_max_window_bits\":\n                case \"server_max_window_bits\":\n                {\n                    // Not supported by Jetty\n                    // Don't negotiate these parameters\n                    break;\n                }\n                case \"client_no_context_takeover\":\n                {\n                    configNegotiated.setParameter(\"client_no_context_takeover\");\n                    switch (getPolicy().getBehavior())\n                    {\n                        case CLIENT:\n                            incomingContextTakeover = false;\n                            break;\n                        case SERVER:\n                            outgoingContextTakeover = false;\n                            break;\n                    }\n                    break;\n                }\n                case \"server_no_context_takeover\":\n                {\n                    configNegotiated.setParameter(\"server_no_context_takeover\");\n                    switch (getPolicy().getBehavior())\n                    {\n                        case CLIENT:\n                            outgoingContextTakeover = false;\n                            break;\n                        case SERVER:\n                            incomingContextTakeover = false;\n                            break;\n                    }\n                    break;\n                }\n                default:\n                {\n                    throw new IllegalArgumentException();\n                }\n            }\n        }\n        \n        LOG.debug(\"config: outgoingContextTakeover={}, incomingContextTakeover={} : {}\", outgoingContextTakeover, incomingContextTakeover, this);\n\n        super.setConfig(configNegotiated);\n    }\n\n<fim_suffix>    @Override\n    public String toString()\n    {\n        return String.format(\"%s[requested=\\\"%s\\\", negotiated=\\\"%s\\\"]\",\n                getClass().getSimpleName(),\n                configRequested.getParameterizedName(),\n                configNegotiated.getParameterizedName());\n    }\n}<fim_middle>// function below has no smell\n"}