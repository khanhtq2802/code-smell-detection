{"text": "<fim_prefix>                redCondition = \"after-now\";\n            } else if (\"thruDate\".equals(this.name)\n                    || (this.entryAcsr != null && \"thruDate\".equals(this.entryAcsr.getOriginalName()))) {\n                redCondition = \"before-now\";\n            } else {\n                return false;\n            }\n        }\n        boolean isBeforeNow = false;\n        if (\"before-now\".equals(redCondition)) {\n            isBeforeNow = true;\n        } else if (\"after-now\".equals(redCondition)) {\n            isBeforeNow = false;\n        } else {\n            return false;\n        }\n        java.sql.Date dateVal = null;\n        java.sql.Time timeVal = null;\n        java.sql.Timestamp timestampVal = null;\n        //now before going on, check to see if the current entry is a valid date and/or time and get the value\n        String value = this.getEntry(context, null);\n        try {\n            timestampVal = java.sql.Timestamp.valueOf(value);\n        } catch (IllegalArgumentException e) {\n            // okay, not a timestamp...\n        }\n        if (timestampVal == null) {\n            try {\n                dateVal = java.sql.Date.valueOf(value);\n            } catch (IllegalArgumentException e) {\n                // okay, not a date...\n            }\n        }\n        if (timestampVal == null && dateVal == null) {\n            try {\n                timeVal = java.sql.Time.valueOf(value);\n            } catch (IllegalArgumentException e) {\n                // okay, not a time...\n            }\n        }\n        if (timestampVal == null && dateVal == null && timeVal == null) {\n            return false;\n        }\n        long nowMillis = System.currentTimeMillis();\n        if (timestampVal != null) {\n            java.sql.Timestamp nowStamp = new java.sql.Timestamp(nowMillis);\n            if (!timestampVal.equals(nowStamp)) {\n                if (isBeforeNow) {\n                    if (timestampVal.before(nowStamp)) {\n                        return true;\n                    }\n                } else {\n                    if (timestampVal.after(nowStamp)) {\n                        return true;\n                    }\n                }\n            }\n        } else if (dateVal != null) {\n            java.sql.Date nowDate = new java.sql.Date(nowMillis);\n            if (!dateVal.equals(nowDate)) {\n                if (isBeforeNow) {\n                    if (dateVal.before(nowDate)) {\n                        return true;\n                    }\n                } else {\n                    if (dateVal.after(nowDate)) {\n                        return true;\n                    }\n                }\n            }\n        } else if (timeVal != null) {\n            java.sql.Time nowTime = new java.sql.Time(nowMillis);\n            if (!timeVal.equals(nowTime)) {\n                if (isBeforeNow) {\n                    if (timeVal.before(nowTime)) {\n                        return true;\n                    }\n                } else {\n                    if (timeVal.after(nowTime)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    public boolean shouldUse(Map<String, Object> context) {\n        String useWhenStr = this.getUseWhen(context);\n        if (UtilValidate.isEmpty(useWhenStr))\n            return true;\n        try {\n            Object retVal = GroovyUtil.eval(StringUtil.convertOperatorSubstitutions(useWhenStr),context);\n            boolean condTrue = false;\n            // retVal should be a Boolean, if not something weird is up...\n            if (retVal instanceof Boolean) {\n                Boolean boolVal = (Boolean) retVal;\n                condTrue = boolVal.booleanValue();\n            } else {\n                throw new IllegalArgumentException(\"Return value from use-when condition eval was not a Boolean: \"\n                        + (retVal != null ? retVal.getClass().getName() : \"null\") + \" [\" + retVal + \"] on the field \" + this.name\n                        + \" of form \" + this.modelForm.getName());\n            }\n            return condTrue;\n        } catch (CompilationFailedException e) {\n            String errMsg = \"Error evaluating groovy use-when condition [\" + useWhenStr + \"] on the field \" + this.name\n                    + \" of form \" + this.modelForm.getName() + \": \" + e.toString();\n            Debug.logError(e, errMsg, module);\n            throw new IllegalArgumentException(errMsg);\n        }\n    }\n    /**\n     * Models the &lt;auto-complete&gt; element.\n     * \n     * @see <code>widget-form.xsd</code>\n     */\n    public static class AutoComplete {\n        private final String autoSelect;\n        private final String choices;\n        private final String frequency;\n        private final String fullSearch;\n        private final String ignoreCase;\n        private final String minChars;\n        private final String partialChars;\n        private final String partialSearch;\n        public AutoComplete(Element element) {\n            this.autoSelect = element.getAttribute(\"auto-select\");\n            this.frequency = element.getAttribute(\"frequency\");\n            this.minChars = element.getAttribute(\"min-chars\");\n            this.choices = element.getAttribute(\"choices\");\n            this.partialSearch = element.getAttribute(\"partial-search\");\n            this.partialChars = element.getAttribute(\"partial-chars\");\n            this.ignoreCase = element.getAttribute(\"ignore-case\");\n            this.fullSearch = element.getAttribute(\"full-search\");\n        }\n        public String getAutoSelect() {\n            return this.autoSelect;\n        }\n        public String getChoices() {\n            return this.choices;\n        }\n        public String getFrequency() {\n            return this.frequency;\n        }\n        public String getFullSearch() {\n            return this.fullSearch;\n        }\n        public String getIgnoreCase() {\n            return this.ignoreCase;\n        }\n        public String getMinChars() {\n            return this.minChars;\n        }\n        public String getPartialChars() {\n            return this.partialChars;\n        }\n        public String getPartialSearch() {\n            return this.partialSearch;\n        }\n    }\n    /**\n     * Models the &lt;check&gt; element.\n     * \n     * @see <code>widget-form.xsd</code>\n     */\n    public static class CheckField extends FieldInfoWithOptions {\n        public final static String ROW_SUBMIT_FIELD_NAME = \"_rowSubmit\";\n        private final FlexibleStringExpander allChecked;\n        private CheckField(CheckField original, ModelFormField modelFormField) {\n            super(original, modelFormField);\n            this.allChecked = original.allChecked;\n        }\n        public CheckField(Element element, ModelFormField modelFormField) {\n            super(element, modelFormField);\n            allChecked = FlexibleStringExpander.getInstance(element.getAttribute(\"all-checked\"));\n        }\n        public CheckField(int fieldSource, ModelFormField modelFormField) {\n            super(fieldSource, FieldInfo.CHECK, modelFormField);\n            this.allChecked = FlexibleStringExpander.getInstance(\"\");\n        }\n        public CheckField(ModelFormField modelFormField) {\n            super(FieldInfo.SOURCE_EXPLICIT, FieldInfo.CHECK, modelFormField);\n            this.allChecked = FlexibleStringExpander.getInstance(\"\");\n        }\n        @Override\n        public void accept(ModelFieldVisitor visitor) throws Exception {\n            visitor.visit(this);\n        }\n        @Override\n        public FieldInfo copy(ModelFormField modelFormField) {\n            return new CheckField(this, modelFormField);\n        }\n        public FlexibleStringExpander getAllChecked() {\n            return allChecked;\n        }\n        public Boolean isAllChecked(Map<String, Object> context) {\n            String allCheckedStr = this.allChecked.expandString(context);\n            if (!allCheckedStr.isEmpty())\n                return Boolean.valueOf(\"true\".equals(allCheckedStr));\n            else\n                return null;\n        }\n        @Override\n        public void renderFieldString(Appendable writer, Map<String, Object> context, FormStringRenderer formStringRenderer)\n                throws IOException {\n            formStringRenderer.renderCheckField(writer, context, this);\n        }\n    }\n    /**\n     * Models the &lt;container&gt; element.\n     * \n     * @see <code>widget-form.xsd</code>\n     */\n<fim_suffix>    public static class ContainerField extends FieldInfo {\n        private ContainerField(ContainerField original, ModelFormField modelFormField) {\n            super(original.getFieldSource(), original.getFieldType(), modelFormField);\n        }\n        public ContainerField(Element element, ModelFormField modelFormField) {\n            super(element, modelFormField);\n        }\n        public ContainerField(int fieldSource, int fieldType, ModelFormField modelFormField) {\n            super(fieldSource, fieldType, modelFormField);\n        }\n        @Override\n        public void accept(ModelFieldVisitor visitor) throws Exception {\n            visitor.visit(this);\n        }\n        @Override\n        public FieldInfo copy(ModelFormField modelFormField) {\n            return new ContainerField(this, modelFormField);\n        }\n        @Override\n        public void renderFieldString(Appendable writer, Map<String, Object> context, FormStringRenderer formStringRenderer)\n                throws IOException {\n            formStringRenderer.renderContainerFindField(writer, context, this);\n        }\n    }<fim_middle>// class below has no smell\n"}