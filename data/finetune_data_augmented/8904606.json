{"text": "<fim_prefix>\n<fim_suffix>public class LazyBinaryMap extends\n    LazyBinaryNonPrimitive<LazyBinaryMapObjectInspector> {\n  private static final Logger LOG = LoggerFactory.getLogger(LazyBinaryMap.class.getName());\n  /**\n   * Whether the data is already parsed or not.\n   */\n  boolean parsed;\n  /**\n   * The size of the map. Only valid when the data is parsed. -1 when the map is\n   * NULL.\n   */\n  int mapSize = 0;\n  /**\n   * The beginning position and length of key[i] and value[i]. Only valid when\n   * the data is parsed.\n   */\n  int[] keyStart;\n  int[] keyLength;\n  int[] valueStart;\n  int[] valueLength;\n  /**\n   * Whether valueObjects[i]/keyObjects[i] is initialized or not.\n   */\n  boolean[] keyInited;\n  boolean[] valueInited;\n  /**\n   * Whether valueObjects[i]/keyObjects[i] is null or not This could not be\n   * inferred from the length of the object. In particular, a 0-length string is\n   * not null.\n   */\n  boolean[] keyIsNull;\n  boolean[] valueIsNull;\n  /**\n   * The keys are stored in an array of LazyPrimitives.\n   */\n  LazyBinaryPrimitive<?, ?>[] keyObjects;\n  /**\n   * The values are stored in an array of LazyObjects. value[index] will start\n   * from KeyEnd[index] + 1, and ends before KeyStart[index+1] - 1.\n   */\n  LazyBinaryObject[] valueObjects;\n  protected LazyBinaryMap(LazyBinaryMapObjectInspector oi) {\n    super(oi);\n  }\n  /**\n   * Set the row data for this LazyBinaryMap.\n   * \n   * @see LazyBinaryObject#init(ByteArrayRef, int, int)\n   */\n  @Override\n  public void init(ByteArrayRef bytes, int start, int length) {\n    super.init(bytes, start, length);\n    parsed = false;\n  }\n  /**\n   * Adjust the size of arrays: keyStart, keyLength valueStart, valueLength\n   * keyInited, keyIsNull valueInited, valueIsNull.\n   */\n  protected void adjustArraySize(int newSize) {\n    if (keyStart == null || keyStart.length < newSize) {\n      keyStart = new int[newSize];\n      keyLength = new int[newSize];\n      valueStart = new int[newSize];\n      valueLength = new int[newSize];\n      keyInited = new boolean[newSize];\n      keyIsNull = new boolean[newSize];\n      valueInited = new boolean[newSize];\n      valueIsNull = new boolean[newSize];\n      keyObjects = new LazyBinaryPrimitive<?, ?>[newSize];\n      valueObjects = new LazyBinaryObject[newSize];\n    }\n  }\n  boolean nullMapKey = false;\n  VInt vInt = new LazyBinaryUtils.VInt();\n  RecordInfo recordInfo = new LazyBinaryUtils.RecordInfo();\n  /**\n   * Parse the byte[] and fill keyStart, keyLength, keyIsNull valueStart,\n   * valueLength and valueIsNull.\n   */\n  private void parse() {\n    byte[] bytes = this.bytes.getData();\n    // get the VInt that represents the map size\n    LazyBinaryUtils.readVInt(bytes, start, vInt);\n    mapSize = vInt.value;\n    if (0 == mapSize) {\n      parsed = true;\n      return;\n    }\n    // adjust arrays\n    adjustArraySize(mapSize);\n    // find out the null-bytes\n    int mapByteStart = start + vInt.length;\n    int nullByteCur = mapByteStart;\n    int nullByteEnd = mapByteStart + (mapSize * 2 + 7) / 8;\n    int lastElementByteEnd = nullByteEnd;\n    // parsing the keys and values one by one\n    for (int i = 0; i < mapSize; i++) {\n      // parse a key\n      keyIsNull[i] = true;\n      if ((bytes[nullByteCur] & (1 << ((i * 2) % 8))) != 0) {\n        keyIsNull[i] = false;\n        LazyBinaryUtils.checkObjectByteInfo(((MapObjectInspector) oi)\n            .getMapKeyObjectInspector(), bytes, lastElementByteEnd, recordInfo, vInt);\n        keyStart[i] = lastElementByteEnd + recordInfo.elementOffset;\n        keyLength[i] = recordInfo.elementSize;\n        lastElementByteEnd = keyStart[i] + keyLength[i];\n      } else if (!nullMapKey) {\n        nullMapKey = true;\n        LOG.warn(\"Null map key encountered! Ignoring similar problems.\");\n      }\n      // parse a value\n      valueIsNull[i] = true;\n      if ((bytes[nullByteCur] & (1 << ((i * 2 + 1) % 8))) != 0) {\n        valueIsNull[i] = false;\n        LazyBinaryUtils.checkObjectByteInfo(((MapObjectInspector) oi)\n            .getMapValueObjectInspector(), bytes, lastElementByteEnd,\n            recordInfo, vInt);\n        valueStart[i] = lastElementByteEnd + recordInfo.elementOffset;\n        valueLength[i] = recordInfo.elementSize;\n        lastElementByteEnd = valueStart[i] + valueLength[i];\n      }\n      // move onto the next null byte\n      if (3 == (i % 4)) {\n        nullByteCur++;\n      }\n    }\n    Arrays.fill(keyInited, 0, mapSize, false);\n    Arrays.fill(valueInited, 0, mapSize, false);\n    parsed = true;\n  }\n  /**\n   * Get the value object with the index without checking parsed.\n   * \n   * @param index\n   *          The index into the array starting from 0\n   */\n  private LazyBinaryObject uncheckedGetValue(int index) {\n    if (valueIsNull[index]) {\n      return null;\n    }\n    if (!valueInited[index]) {\n      valueInited[index] = true;\n      if (valueObjects[index] == null) {\n        valueObjects[index] = LazyBinaryFactory\n            .createLazyBinaryObject(((MapObjectInspector) oi)\n            .getMapValueObjectInspector());\n      }\n      valueObjects[index].init(bytes, valueStart[index], valueLength[index]);\n    }\n    return valueObjects[index];\n  }\n  /**\n   * Get the value in the map for the key.\n   * \n   * If there are multiple matches (which is possible in the serialized format),\n   * only the first one is returned.\n   * \n   * The most efficient way to get the value for the key is to serialize the key\n   * and then try to find it in the array. We do linear search because in most\n   * cases, user only wants to get one or two values out of the map, and the\n   * cost of building up a HashMap is substantially higher.\n   * \n   * @param key\n   *          The key object that we are looking for.\n   * @return The corresponding value object, or NULL if not found\n   */\n  public Object getMapValueElement(Object key) {\n    if (!parsed) {\n      parse();\n    }\n    // search for the key\n    for (int i = 0; i < mapSize; i++) {\n      LazyBinaryPrimitive<?, ?> lazyKeyI = uncheckedGetKey(i);\n      if (lazyKeyI == null) {\n        continue;\n      }\n      // getWritableObject() will convert LazyPrimitive to actual primitive\n      // writable objects.\n      Object keyI = lazyKeyI.getWritableObject();\n      if (keyI == null) {\n        continue;\n      }\n      if (keyI.equals(key)) {\n        // Got a match, return the value\n        LazyBinaryObject v = uncheckedGetValue(i);\n        return v == null ? v : v.getObject();\n      }\n    }\n    return null;\n  }\n  /**\n   * Get the key object with the index without checking parsed.\n   * \n   * @param index\n   *          The index into the array starting from 0\n   */\n  private LazyBinaryPrimitive<?, ?> uncheckedGetKey(int index) {\n    if (keyIsNull[index]) {\n      return null;\n    }\n    if (!keyInited[index]) {\n      keyInited[index] = true;\n      if (keyObjects[index] == null) {\n        // Keys are always primitive\n        keyObjects[index] = LazyBinaryFactory\n            .createLazyBinaryPrimitiveClass((PrimitiveObjectInspector) ((MapObjectInspector) oi)\n            .getMapKeyObjectInspector());\n      }\n      keyObjects[index].init(bytes, keyStart[index], keyLength[index]);\n    }\n    return keyObjects[index];\n  }\n  /**\n   * cachedMap is reused for different calls to getMap(). But each LazyBinaryMap\n   * has a separate cachedMap so we won't overwrite the data by accident.\n   */\n  LinkedHashMap<Object, Object> cachedMap;\n  /**\n   * Return the map object representing this LazyBinaryMap. Note that the\n   * keyObjects will be Writable primitive objects.\n   * \n   * @return the map object\n   */\n  public Map<Object, Object> getMap() {\n    if (!parsed) {\n      parse();\n    }\n    if (cachedMap == null) {<fim_middle>// class below has no smell\n"}