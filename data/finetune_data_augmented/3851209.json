{"text": "<fim_prefix>      try {\n        ServiceInfo serviceInfo = metaInfo.getService(stackName, stackVersion, serviceName);\n        if (serviceInfo.getAdvisorFile() != null) {\n          serviceVersion.put(\"advisor_name\", serviceInfo.getAdvisorName());\n          serviceVersion.put(\"advisor_path\", serviceInfo.getAdvisorFile().getAbsolutePath());\n        }\n      } catch (Exception e) {\n        LOG.error(\"Error adding service advisor information to services.json\", e);\n      }\n    }\n  }\n  public synchronized T invoke(StackAdvisorRequest request, ServiceInfo.ServiceAdvisorType serviceAdvisorType) throws StackAdvisorException {\n    validate(request);\n    String hostsJSON = getHostsInformation(request);\n    String servicesJSON = getServicesInformation(request);\n    StackAdvisorData adjusted = adjust(new StackAdvisorData(hostsJSON, servicesJSON), request);\n    try {\n      createRequestDirectory();\n      FileUtils.writeStringToFile(new File(requestDirectory, \"hosts.json\"), adjusted.hostsJSON);\n      FileUtils.writeStringToFile(new File(requestDirectory, \"services.json\"), adjusted.servicesJSON);\n      saRunner.runScript(serviceAdvisorType, getCommandType(), requestDirectory);\n      String result = FileUtils.readFileToString(new File(requestDirectory, getResultFileName()));\n      T response = this.mapper.readValue(result, this.type);\n      return updateResponse(request, setRequestId(response));\n    } catch (StackAdvisorException ex) {\n      throw ex;\n    } catch (Exception e) {\n      String message = \"Error occured during stack advisor command invocation: \";\n      LOG.warn(message, e);\n      throw new StackAdvisorException(message + e.getMessage());\n    }\n  }\n  protected abstract T updateResponse(StackAdvisorRequest request, T response);\n  private T setRequestId(T response) {\n    response.setId(requestId);\n    return response;\n  }\n  /**\n   * Create request id directory for each call\n   */\n  private void createRequestDirectory() throws IOException {\n    if (!recommendationsDir.exists()) {\n      if (!recommendationsDir.mkdirs()) {\n        throw new IOException(\"Cannot create \" + recommendationsDir);\n      }\n    }\n    cleanupRequestDirectory();\n    requestDirectory = new File(recommendationsDir, Integer.toString(requestId));\n    if (requestDirectory.exists()) {\n      FileUtils.deleteDirectory(requestDirectory);\n    }\n    if (!requestDirectory.mkdirs()) {\n      throw new IOException(\"Cannot create \" + requestDirectory);\n    }\n  }\n  /**\n   * Deletes folders older than (now - recommendationsArtifactsLifetime)\n   */\n  private void cleanupRequestDirectory() throws IOException {\n    final Date cutoffDate = DateUtils.getDateSpecifiedTimeAgo(recommendationsArtifactsLifetime); // subdirectories older than this date will be deleted\n    String[] oldDirectories = recommendationsDir.list(new FilenameFilter() {\n      @Override\n      public boolean accept(File current, String name) {\n        File file = new File(current, name);\n        return file.isDirectory() && !FileUtils.isFileNewer(file, cutoffDate);\n      }\n    });\n    if (oldDirectories.length > 0) {\n      LOG.info(String.format(\"Deleting old directories %s from %s\", StringUtils.join(oldDirectories, \", \"), recommendationsDir));\n    }\n    for (String oldDirectory : oldDirectories) {\n      FileUtils.deleteQuietly(new File(recommendationsDir, oldDirectory));\n    }\n  }\n  String getHostsInformation(StackAdvisorRequest request) throws StackAdvisorException {\n    List<String> hostNames = new ArrayList<>(request.getHosts());\n    // retrieve cached info\n    List<JsonNode> resultInfos = new ArrayList<>();\n    if (hostInfoCache != null && !hostInfoCache.isEmpty()) {\n      Iterator<String> hostNamesIterator = hostNames.iterator();\n      while(hostNamesIterator.hasNext()) {\n        String hostName = hostNamesIterator.next();\n        JsonNode node = hostInfoCache.get(hostName);\n        if (node != null) {\n          resultInfos.add(node);\n          hostNamesIterator.remove();\n        }\n      }\n    }\n    String hostsJSON = null;\n    // get hosts info for not cached hosts only\n    if (!hostNames.isEmpty()) {\n      LOG.info(String.format(\"Fire host info request for hosts: \" + hostNames.toString()));\n      String hostsURI = String.format(GET_HOSTS_INFO_URI, String.join(\",\", hostNames));\n      Response response = handleRequest(null, null, new LocalUriInfo(hostsURI), Request.Type.GET,\n          createHostResource());\n      if (response.getStatus() != Status.OK.getStatusCode()) {\n        String message = String.format(\n            \"Error occured during hosts information retrieving, status=%s, response=%s\",\n            response.getStatus(), (String) response.getEntity());\n        LOG.warn(message);\n        throw new StackAdvisorException(message);\n      }\n      hostsJSON = (String) response.getEntity();\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Hosts information: {}\", hostsJSON);\n      }\n    }\n    // when cache is used we should merge cached info with just got\n    if (hostInfoCache != null) {\n      if (hostsJSON != null && !hostsJSON.isEmpty()) {\n        try {\n          JsonNode root = mapper.readTree(hostsJSON);\n          Iterator<JsonNode> iterator = root.get(\"items\").getElements();\n          while (iterator.hasNext()) {\n            JsonNode next = iterator.next();\n            String hostName = next.get(\"Hosts\").get(\"host_name\").getTextValue();\n            hostInfoCache.put(hostName, next);\n            resultInfos.add(next);\n          }\n        } catch (IOException e) {\n          throw new StackAdvisorException(\"Error occured during parsing result host infos\", e);\n        }\n      }\n      String fullHostsURI = String.format(GET_HOSTS_INFO_URI, request.getHostsCommaSeparated());\n      JsonNodeFactory f = JsonNodeFactory.instance;\n      ObjectNode resultRoot = f.objectNode();\n      resultRoot.put(\"href\", fullHostsURI);\n      ArrayNode resultArray = resultRoot.putArray(\"items\");\n      resultArray.addAll(resultInfos);\n      hostsJSON = resultRoot.toString();\n    }\n    Collection<String> unregistered = getUnregisteredHosts(hostsJSON, request.getHosts());\n    if (unregistered.size() > 0) {\n      String message = String.format(\"There are unregistered hosts in the request, %s\",\n          Arrays.toString(unregistered.toArray()));\n      LOG.warn(message);\n      throw new StackAdvisorException(message);\n    }\n    return hostsJSON;\n  }\n  @SuppressWarnings(\"unchecked\")\n  private Collection<String> getUnregisteredHosts(String hostsJSON, List<String> hosts)\n      throws StackAdvisorException {\n    List<String> registeredHosts = new ArrayList<>();\n    try {\n      JsonNode root = mapper.readTree(hostsJSON);\n      Iterator<JsonNode> iterator = root.get(\"items\").getElements();\n      while (iterator.hasNext()) {\n        JsonNode next = iterator.next();\n        String hostName = next.get(\"Hosts\").get(\"host_name\").getTextValue();\n        registeredHosts.add(hostName);\n      }\n      return CollectionUtils.subtract(hosts, registeredHosts);\n    } catch (Exception e) {\n      throw new StackAdvisorException(\"Error occured during calculating unregistered hosts\", e);\n    }\n  }\n  String getServicesInformation(StackAdvisorRequest request) throws StackAdvisorException {\n    String stackName = request.getStackName();\n    String stackVersion = request.getStackVersion();\n    String servicesURI = String.format(GET_SERVICES_INFO_URI, stackName, stackVersion,\n        request.getServicesCommaSeparated());\n    Response response = handleRequest(null, null, new LocalUriInfo(servicesURI),\n        Request.Type.GET, createStackVersionResource(stackName, stackVersion));\n    if (response.getStatus() != Status.OK.getStatusCode()) {\n      String message = String.format(\n          \"Error occured during services information retrieving, status=%s, response=%s\",\n          response.getStatus(), (String) response.getEntity());\n      LOG.warn(message);\n      throw new StackAdvisorException(message);\n    }\n    String servicesJSON = (String) response.getEntity();\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Services information: {}\", servicesJSON);\n    }\n    return servicesJSON;\n  }\n  private ResourceInstance createHostResource() {\n    Map<Resource.Type, String> mapIds = new HashMap<>();\n    return createResource(Resource.Type.Host, mapIds);\n  }\n<fim_suffix>  private ResourceInstance createConfigResource() {\n    Map<Resource.Type, String> mapIds = new HashMap<>();\n    mapIds.put(Resource.Type.RootService, RootService.AMBARI.name());\n    mapIds.put(Resource.Type.RootServiceComponent, RootComponent.AMBARI_SERVER.name());\n    return createResource(Resource.Type.RootServiceComponentConfiguration, mapIds);\n  }<fim_middle>// function below has no smell\n"}