{"text": "<fim_prefix>            }\n        }\n        return true;\n    }\n    private boolean mergeLifecycleCallback(\n            Map<String, String> fragmentMap, Map<String, String> tempMap,\n            WebXml fragment, String mapName) {\n        for (Entry<String, String> entry : fragmentMap.entrySet()) {\n            final String key = entry.getKey();\n            final String value = entry.getValue();\n            if (tempMap.containsKey(key)) {\n                if (value != null && !value.equals(tempMap.get(key))) {\n                    log.error(sm.getString(\"webXml.mergeConflictString\",\n                            mapName, key, fragment.getName(), fragment.getURL()));\n                    return false;\n                }\n            } else {\n                tempMap.put(key, value);\n            }\n        }\n        return true;\n    }\n    /**\n     * Generates the sub-set of the web-fragment.xml files to be processed in\n     * the order that the fragments must be processed as per the rules in the\n     * Servlet spec.\n     *\n     * @param application    The application web.xml file\n     * @param fragments      The map of fragment names to web fragments\n     * @param servletContext The servlet context the fragments are associated\n     *                       with\n     * @return Ordered list of web-fragment.xml files to process\n     */\n    public static Set<WebXml> orderWebFragments(WebXml application,\n            Map<String,WebXml> fragments, ServletContext servletContext) {\n        return application.orderWebFragments(fragments, servletContext);\n    }\n    private Set<WebXml> orderWebFragments(Map<String,WebXml> fragments,\n            ServletContext servletContext) {\n        Set<WebXml> orderedFragments = new LinkedHashSet<>();\n        boolean absoluteOrdering = getAbsoluteOrdering() != null;\n        boolean orderingPresent = false;\n        if (absoluteOrdering) {\n            orderingPresent = true;\n            // Only those fragments listed should be processed\n            Set<String> requestedOrder = getAbsoluteOrdering();\n            for (String requestedName : requestedOrder) {\n                if (WebXml.ORDER_OTHERS.equals(requestedName)) {\n                    // Add all fragments not named explicitly at this point\n                    for (Entry<String, WebXml> entry : fragments.entrySet()) {\n                        if (!requestedOrder.contains(entry.getKey())) {\n                            WebXml fragment = entry.getValue();\n                            if (fragment != null) {\n                                orderedFragments.add(fragment);\n                            }\n                        }\n                    }\n                } else {\n                    WebXml fragment = fragments.get(requestedName);\n                    if (fragment != null) {\n                        orderedFragments.add(fragment);\n                    } else {\n                        log.warn(sm.getString(\"webXml.wrongFragmentName\",requestedName));\n                    }\n                }\n            }\n        } else {\n            // Stage 0. Check there were no fragments with duplicate names\n            for (WebXml fragment : fragments.values()) {\n                if (fragment.isDuplicated()) {\n                    throw new IllegalArgumentException(\n                            sm.getString(\"webXml.duplicateFragment\", fragment.getName()));\n                }\n            }\n            // Stage 1. Make all dependencies bi-directional - this makes the\n            //          next stage simpler.\n            for (WebXml fragment : fragments.values()) {\n                Iterator<String> before =\n                        fragment.getBeforeOrdering().iterator();\n                while (before.hasNext()) {\n                    orderingPresent = true;\n                    String beforeEntry = before.next();\n                    if (!beforeEntry.equals(ORDER_OTHERS)) {\n                        WebXml beforeFragment = fragments.get(beforeEntry);\n                        if (beforeFragment == null) {\n                            before.remove();\n                        } else {\n                            beforeFragment.addAfterOrdering(fragment.getName());\n                        }\n                    }\n                }\n                Iterator<String> after = fragment.getAfterOrdering().iterator();\n                while (after.hasNext()) {\n                    orderingPresent = true;\n                    String afterEntry = after.next();\n                    if (!afterEntry.equals(ORDER_OTHERS)) {\n                        WebXml afterFragment = fragments.get(afterEntry);\n                        if (afterFragment == null) {\n                            after.remove();\n                        } else {\n                            afterFragment.addBeforeOrdering(fragment.getName());\n                        }\n                    }\n                }\n            }\n            // Stage 2. Make all fragments that are implicitly before/after\n            //          others explicitly so. This is iterative so the next\n            //          stage doesn't have to be.\n            for (WebXml fragment : fragments.values()) {\n                if (fragment.getBeforeOrdering().contains(ORDER_OTHERS)) {\n                    makeBeforeOthersExplicit(fragment.getAfterOrdering(), fragments);\n                }\n                if (fragment.getAfterOrdering().contains(ORDER_OTHERS)) {\n                    makeAfterOthersExplicit(fragment.getBeforeOrdering(), fragments);\n                }\n            }\n            // Stage 3. Separate into three groups\n            Set<WebXml> beforeSet = new HashSet<>();\n            Set<WebXml> othersSet = new HashSet<>();\n            Set<WebXml> afterSet = new HashSet<>();\n            for (WebXml fragment : fragments.values()) {\n                if (fragment.getBeforeOrdering().contains(ORDER_OTHERS)) {\n                    beforeSet.add(fragment);\n                    fragment.getBeforeOrdering().remove(ORDER_OTHERS);\n                } else if (fragment.getAfterOrdering().contains(ORDER_OTHERS)) {\n                    afterSet.add(fragment);\n                    fragment.getAfterOrdering().remove(ORDER_OTHERS);\n                } else {\n                    othersSet.add(fragment);\n                }\n            }\n            // Stage 4. Decouple the groups so the ordering requirements for\n            //          each fragment in the group only refer to other fragments\n            //          in the group. Ordering requirements outside the group\n            //          will be handled by processing the groups in order.\n            //          Note: Only after ordering requirements are considered.\n            //                This is OK because of the processing in stage 1.\n            decoupleOtherGroups(beforeSet);\n            decoupleOtherGroups(othersSet);\n            decoupleOtherGroups(afterSet);\n            // Stage 5. Order each group\n            //          Note: Only after ordering requirements are considered.\n            //                This is OK because of the processing in stage 1.\n            orderFragments(orderedFragments, beforeSet);\n            orderFragments(orderedFragments, othersSet);\n            orderFragments(orderedFragments, afterSet);\n        }\n        // Container fragments are always included\n        Set<WebXml> containerFragments = new LinkedHashSet<>();\n        // Find all the container fragments and remove any present from the\n        // ordered list\n        for (WebXml fragment : fragments.values()) {\n            if (!fragment.getWebappJar()) {\n                containerFragments.add(fragment);\n                orderedFragments.remove(fragment);\n            }\n        }\n        // Avoid NPE when unit testing\n        if (servletContext != null) {\n            // Publish the ordered fragments. The app does not need to know\n            // about container fragments\n            List<String> orderedJarFileNames = null;\n            if (orderingPresent) {\n                orderedJarFileNames = new ArrayList<>();\n                for (WebXml fragment: orderedFragments) {\n                    orderedJarFileNames.add(fragment.getJarName());\n                }\n            }\n            servletContext.setAttribute(ServletContext.ORDERED_LIBS,\n                    orderedJarFileNames);\n        }\n        // The remainder of the processing needs to know about container\n        // fragments\n        if (containerFragments.size() > 0) {\n            Set<WebXml> result = new LinkedHashSet<>();\n            if (containerFragments.iterator().next().getDelegate()) {\n                result.addAll(containerFragments);\n                result.addAll(orderedFragments);\n            } else {\n                result.addAll(orderedFragments);\n                result.addAll(containerFragments);\n            }\n            return result;\n        } else {\n            return orderedFragments;\n        }\n    }\n    private static void decoupleOtherGroups(Set<WebXml> group) {\n        Set<String> names = new HashSet<>();\n        for (WebXml fragment : group) {\n            names.add(fragment.getName());\n        }\n        for (WebXml fragment : group) {\n            Iterator<String> after = fragment.getAfterOrdering().iterator();\n            while (after.hasNext()) {\n                String entry = after.next();\n                if (!names.contains(entry)) {\n                    after.remove();\n                }\n            }\n        }\n    }\n<fim_suffix>    private static void orderFragments(Set<WebXml> orderedFragments,\n            Set<WebXml> unordered) {\n        Set<WebXml> addedThisRound = new HashSet<>();\n        Set<WebXml> addedLastRound = new HashSet<>();\n        while (unordered.size() > 0) {\n            Iterator<WebXml> source = unordered.iterator();\n            while (source.hasNext()) {\n                WebXml fragment = source.next();\n                for (WebXml toRemove : addedLastRound) {\n                    fragment.getAfterOrdering().remove(toRemove.getName());\n                }\n                if (fragment.getAfterOrdering().isEmpty()) {\n                    addedThisRound.add(fragment);\n                    orderedFragments.add(fragment);\n                    source.remove();\n                }\n            }\n            if (addedThisRound.size() == 0) {\n                // Circular\n                throw new IllegalArgumentException(\n                        sm.getString(\"webXml.mergeConflictOrder\"));\n            }\n            addedLastRound.clear();\n            addedLastRound.addAll(addedThisRound);\n            addedThisRound.clear();\n        }\n    }<fim_middle>// function below has no smell\n"}