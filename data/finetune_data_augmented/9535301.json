{"text": "<fim_prefix>\n<fim_suffix>@Private\nfinal class NflyFSystem extends FileSystem {\n  private static final Log LOG = LogFactory.getLog(NflyFSystem.class);\n  private static final String NFLY_TMP_PREFIX = \"_nfly_tmp_\";\n  enum NflyKey {\n    // minimum replication, if local filesystem is included +1 is recommended\n    minReplication,\n    // forces to check all the replicas and fetch the one with the most recent\n    // time stamp\n    //\n    readMostRecent,\n    // create missing replica from far to near, including local?\n    repairOnRead\n  }\n  private static final int DEFAULT_MIN_REPLICATION = 2;\n  private static URI nflyURI = URI.create(\"nfly:///\");\n  private final NflyNode[] nodes;\n  private final int minReplication;\n  private final EnumSet<NflyKey> nflyFlags;\n  private final Node myNode;\n  private final NetworkTopology topology;\n  /**\n   * URI's authority is used as an approximation of the distance from the\n   * client. It's sufficient for DC but not accurate because worker nodes can be\n   * closer.\n   */\n  private static class NflyNode extends NodeBase {\n    private final ChRootedFileSystem fs;\n    NflyNode(String hostName, String rackName, URI uri,\n        Configuration conf) throws IOException {\n      this(hostName, rackName, new ChRootedFileSystem(uri, conf));\n    }\n    NflyNode(String hostName, String rackName, ChRootedFileSystem fs) {\n      super(hostName, rackName);\n      this.fs = fs;\n    }\n    ChRootedFileSystem getFs() {\n      return fs;\n    }\n    @Override\n    public boolean equals(Object o) {\n      // satisfy findbugs\n      return super.equals(o);\n    }\n    @Override\n    public int hashCode() {\n      // satisfy findbugs\n      return super.hashCode();\n    }\n  }\n  private static final class MRNflyNode\n      extends NflyNode implements Comparable<MRNflyNode> {\n    private FileStatus status;\n    private MRNflyNode(NflyNode n) {\n      super(n.getName(), n.getNetworkLocation(), n.fs);\n    }\n    private void updateFileStatus(Path f) throws IOException {\n      final FileStatus tmpStatus = getFs().getFileStatus(f);\n      status = tmpStatus == null\n          ? notFoundStatus(f)\n          : tmpStatus;\n    }\n    // TODO allow configurable error margin for FileSystems with different\n    // timestamp precisions\n    @Override\n    public int compareTo(MRNflyNode other) {\n      if (status == null) {\n        return other.status == null ? 0 : 1; // move non-null towards head\n      } else if (other.status == null) {\n        return -1; // move this towards head\n      } else {\n        final long mtime = status.getModificationTime();\n        final long their = other.status.getModificationTime();\n        return Long.compare(their, mtime); // move more recent towards head\n      }\n    }\n    @Override\n    public boolean equals(Object o) {\n      if (!(o instanceof MRNflyNode)) {\n        return false;\n      }\n      MRNflyNode other = (MRNflyNode) o;\n      return 0 == compareTo(other);\n    }\n    @Override\n    public int hashCode() {\n      // satisfy findbugs\n      return super.hashCode();\n    }\n    private FileStatus nflyStatus() throws IOException {\n      return new NflyStatus(getFs(), status);\n    }\n    private FileStatus cloneStatus() throws IOException {\n      return new FileStatus(status.getLen(),\n          status.isDirectory(),\n          status.getReplication(),\n          status.getBlockSize(),\n          status.getModificationTime(),\n          status.getAccessTime(),\n          null, null, null,\n          status.isSymlink() ? status.getSymlink() : null,\n          status.getPath());\n    }\n  }\n  private MRNflyNode[] workSet() {\n    final MRNflyNode[] res = new MRNflyNode[nodes.length];\n    for (int i = 0; i < res.length; i++) {\n      res[i] = new MRNflyNode(nodes[i]);\n    }\n    return res;\n  }\n  /**\n   * Utility to replace null with DEFAULT_RACK.\n   *\n   * @param rackString rack value, can be null\n   * @return non-null rack string\n   */\n  private static String getRack(String rackString) {\n    return rackString == null ? NetworkTopology.DEFAULT_RACK : rackString;\n  }\n  /**\n   * Creates a new Nfly instance.\n   *\n   * @param uris the list of uris in the mount point\n   * @param conf configuration object\n   * @param minReplication minimum copies to commit a write op\n   * @param nflyFlags modes such readMostRecent\n   * @throws IOException\n   */\n  private NflyFSystem(URI[] uris, Configuration conf, int minReplication,\n      EnumSet<NflyKey> nflyFlags) throws IOException {\n    if (uris.length < minReplication) {\n      throw new IOException(minReplication + \" < \" + uris.length\n          + \": Minimum replication < #destinations\");\n    }\n    setConf(conf);\n    final String localHostName = InetAddress.getLocalHost().getHostName();\n    // build a list for topology resolution\n    final List<String> hostStrings = new ArrayList<String>(uris.length + 1);\n    for (URI uri : uris) {\n      final String uriHost = uri.getHost();\n      // assume local file system or another closest filesystem if no authority\n      hostStrings.add(uriHost == null ? localHostName : uriHost);\n    }\n    // resolve the client node\n    hostStrings.add(localHostName);\n    final DNSToSwitchMapping tmpDns = ReflectionUtils.newInstance(conf.getClass(\n        CommonConfigurationKeys.NET_TOPOLOGY_NODE_SWITCH_MAPPING_IMPL_KEY,\n        ScriptBasedMapping.class, DNSToSwitchMapping.class), conf);\n    // this is an ArrayList\n    final List<String> rackStrings = tmpDns.resolve(hostStrings);\n    nodes = new NflyNode[uris.length];\n    final Iterator<String> rackIter = rackStrings.iterator();\n    for (int i = 0; i < nodes.length; i++) {\n      nodes[i] = new NflyNode(hostStrings.get(i), rackIter.next(), uris[i],\n          conf);\n    }\n    // sort all the uri's by distance from myNode, the local file system will\n    // automatically be the the first one.\n    //\n    myNode = new NodeBase(localHostName, getRack(rackIter.next()));\n    topology = NetworkTopology.getInstance(conf);\n    topology.sortByDistance(myNode, nodes, nodes.length);\n    this.minReplication = minReplication;\n    this.nflyFlags = nflyFlags;\n    statistics = getStatistics(nflyURI.getScheme(), getClass());\n  }\n  /**\n   * Transactional output stream. When creating path /dir/file\n   * 1) create invisible /real/dir_i/_nfly_tmp_file\n   * 2) when more than min replication was written, write is committed by\n   *   renaming all successfully written files to /real/dir_i/file\n   */\n  private final class NflyOutputStream extends OutputStream {\n    // actual path\n    private final Path nflyPath;\n    // tmp path before commit\n    private final Path tmpPath;\n    // broadcast set\n    private final FSDataOutputStream[] outputStreams;\n    // status set: 1 working, 0 problem\n    private final BitSet opSet;\n    private final boolean useOverwrite;\n    private NflyOutputStream(Path f, FsPermission permission, boolean overwrite,\n        int bufferSize, short replication, long blockSize,\n        Progressable progress) throws IOException {\n      nflyPath = f;\n      tmpPath = getNflyTmpPath(f);\n      outputStreams = new FSDataOutputStream[nodes.length];\n      for (int i = 0; i < outputStreams.length; i++) {\n        outputStreams[i] = nodes[i].fs.create(tmpPath, permission, true,\n            bufferSize, replication, blockSize, progress);\n      }\n      opSet = new BitSet(outputStreams.length);\n      opSet.set(0, outputStreams.length);\n      useOverwrite = false;\n    }\n    //\n    // TODO consider how to clean up and throw an exception early when the clear\n    // bits under min replication\n    //\n    private void mayThrow(List<IOException> ioExceptions) throws IOException {\n      final IOException ioe = MultipleIOException\n          .createIOException(ioExceptions);\n      if (opSet.cardinality() < minReplication) {\n        throw ioe;\n      } else {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Exceptions occurred: \" + ioe);\n        }\n      }\n    }\n    @Override\n    public void write(int d) throws IOException {\n      final List<IOException> ioExceptions = new ArrayList<IOException>();\n      for (int i = opSet.nextSetBit(0);\n           i >=0;\n           i = opSet.nextSetBit(i + 1)) {<fim_middle>// class below is blob\n"}