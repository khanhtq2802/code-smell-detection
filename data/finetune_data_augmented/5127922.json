{"text": "<fim_prefix>    private Date timestamp;\n    private List<? extends IndexCreator> indexCreators;\n    /**\n     * Currently nexus-indexer knows only M2 reposes\n     * <p>\n     * XXX move this into a concrete Scanner implementation\n     */\n    private GavCalculator gavCalculator;\n    private DefaultIndexingContext( String id,\n                                    String repositoryId,\n                                    File repository, //\n                                    String repositoryUrl, String indexUpdateUrl,\n                                    List<? extends IndexCreator> indexCreators, Directory indexDirectory,\n                                    TrackingLockFactory lockFactory,\n                                    boolean reclaimIndex )\n        throws ExistingLuceneIndexMismatchException, IOException\n    {\n        this.id = id;\n        this.searchable = true;\n        this.repositoryId = repositoryId;\n        this.repository = repository;\n        this.repositoryUrl = repositoryUrl;\n        this.indexUpdateUrl = indexUpdateUrl;\n        this.indexWriter = null;\n        this.searcherManager = null;\n        this.indexCreators = indexCreators;\n        this.indexDirectory = indexDirectory;\n        this.lockFactory = lockFactory;\n        // eh?\n        // Guice does NOT initialize these, and we have to do manually?\n        // While in Plexus, all is well, but when in guice-shim,\n        // these objects are still LazyHintedBeans or what not and IndexerFields are NOT registered!\n        for ( IndexCreator indexCreator : indexCreators )\n        {\n            indexCreator.getIndexerFields();\n        }\n        this.gavCalculator = new M2GavCalculator();\n        prepareIndex( reclaimIndex );\n        setIndexDirectoryFile( null );\n    }\n    private DefaultIndexingContext( String id, String repositoryId, File repository, File indexDirectoryFile,\n                                   TrackingLockFactory lockFactory, String repositoryUrl, String indexUpdateUrl,\n                                   List<? extends IndexCreator> indexCreators, boolean reclaimIndex )\n        throws IOException, ExistingLuceneIndexMismatchException\n    {\n        this( id, repositoryId, repository, repositoryUrl, indexUpdateUrl, indexCreators,\n            FSDirectory.open( indexDirectoryFile.toPath(), lockFactory ), lockFactory, reclaimIndex );\n        setIndexDirectoryFile( indexDirectoryFile );\n    }\n    public DefaultIndexingContext( String id, String repositoryId, File repository, File indexDirectoryFile,\n                                   String repositoryUrl, String indexUpdateUrl,\n                                   List<? extends IndexCreator> indexCreators, boolean reclaimIndex )\n        throws IOException, ExistingLuceneIndexMismatchException\n    {\n        this( id, repositoryId, repository, indexDirectoryFile, new TrackingLockFactory( FSLockFactory.getDefault() ),\n              repositoryUrl, indexUpdateUrl, indexCreators, reclaimIndex );\n    }\n    @Deprecated\n    public DefaultIndexingContext( String id, String repositoryId, File repository, Directory indexDirectory,\n                                   String repositoryUrl, String indexUpdateUrl,\n                                   List<? extends IndexCreator> indexCreators, boolean reclaimIndex )\n        throws IOException, ExistingLuceneIndexMismatchException\n    {\n        this( id, repositoryId, repository, repositoryUrl, indexUpdateUrl, indexCreators, indexDirectory, null,\n              reclaimIndex ); // Lock factory already installed - pass null\n        if ( indexDirectory instanceof FSDirectory )\n        {\n            setIndexDirectoryFile( ( (FSDirectory) indexDirectory ).getDirectory().toFile() );\n        }\n    }\n    public Directory getIndexDirectory()\n    {\n        return indexDirectory;\n    }\n    /**\n     * Sets index location. As usually index is persistent (is on disk), this will point to that value, but in\n     * some circumstances (ie, using RAMDisk for index), this will point to an existing tmp directory.\n     */\n    protected void setIndexDirectoryFile( File dir )\n        throws IOException\n    {\n        if ( dir == null )\n        {\n            // best effort, to have a directory thru the life of a ctx\n            File tmpFile = File.createTempFile( \"mindexer-ctx\" + id, \"tmp\" );\n            tmpFile.deleteOnExit();\n            tmpFile.delete();\n            tmpFile.mkdirs();\n            this.indexDirectoryFile = tmpFile;\n        }\n        else\n        {\n            this.indexDirectoryFile = dir;\n        }\n    }\n    public File getIndexDirectoryFile()\n    {\n        return indexDirectoryFile;\n    }\n    private void prepareIndex( boolean reclaimIndex )\n        throws IOException, ExistingLuceneIndexMismatchException\n    {\n        if ( DirectoryReader.indexExists( indexDirectory ) )\n        {\n            try\n            {\n                // unlock the dir forcibly\n                if ( IndexWriter.isLocked( indexDirectory ) )\n                {\n                    unlockForcibly( lockFactory, indexDirectory );\n                }\n                openAndWarmup();\n                checkAndUpdateIndexDescriptor( reclaimIndex );\n            }\n            catch ( IOException e )\n            {\n                if ( reclaimIndex )\n                {\n                    prepareCleanIndex( true );\n                }\n                else\n                {\n                    throw e;\n                }\n            }\n        }\n        else\n        {\n            prepareCleanIndex( false );\n        }\n        timestamp = IndexUtils.getTimestamp( indexDirectory );\n    }\n    private void prepareCleanIndex( boolean deleteExisting )\n        throws IOException\n    {\n        if ( deleteExisting )\n        {\n            closeReaders();\n            // unlock the dir forcibly\n            if ( IndexWriter.isLocked( indexDirectory ) )\n            {\n                unlockForcibly( lockFactory, indexDirectory );\n            }\n            deleteIndexFiles( true );\n        }\n        openAndWarmup();\n        if ( StringUtils.isEmpty( getRepositoryId() ) )\n        {\n            throw new IllegalArgumentException( \"The repositoryId cannot be null when creating new repository!\" );\n        }\n        storeDescriptor();\n    }\n    private void checkAndUpdateIndexDescriptor( boolean reclaimIndex )\n        throws IOException, ExistingLuceneIndexMismatchException\n    {\n        if ( reclaimIndex )\n        {\n            // forcefully \"reclaiming\" the ownership of the index as ours\n            storeDescriptor();\n            return;\n        }\n        // check for descriptor if this is not a \"virgin\" index\n        if ( getSize() > 0 )\n        {\n            final TopScoreDocCollector collector = TopScoreDocCollector.create( 1 );\n            final IndexSearcher indexSearcher = acquireIndexSearcher();\n            try\n            {\n                indexSearcher.search( new TermQuery( DESCRIPTOR_TERM ), collector );\n                if ( collector.getTotalHits() == 0 )\n                {\n                    throw new ExistingLuceneIndexMismatchException(\n                        \"The existing index has no NexusIndexer descriptor\" );\n                }\n                if ( collector.getTotalHits() > 1 )\n                {\n                    // eh? this is buggy index it seems, just iron it out then\n                    storeDescriptor();\n                    return;\n                }\n                else\n                {\n                    // good, we have one descriptor as should\n                    Document descriptor = indexSearcher.doc( collector.topDocs().scoreDocs[0].doc );\n                    String[] h = StringUtils.split( descriptor.get( FLD_IDXINFO ), ArtifactInfo.FS );\n                    // String version = h[0];\n                    String repoId = h[1];\n                    // // compare version\n                    // if ( !VERSION.equals( version ) )\n                    // {\n                    // throw new UnsupportedExistingLuceneIndexException(\n                    // \"The existing index has version [\" + version + \"] and not [\" + VERSION + \"] version!\" );\n                    // }\n                    if ( getRepositoryId() == null )\n                    {\n                        repositoryId = repoId;\n                    }\n                    else if ( !getRepositoryId().equals( repoId ) )\n                    {\n                        throw new ExistingLuceneIndexMismatchException( \"The existing index is for repository \" //\n                            + \"[\" + repoId + \"] and not for repository [\" + getRepositoryId() + \"]\" );\n                    }\n                }\n            }\n            finally\n            {\n                releaseIndexSearcher( indexSearcher );\n            }\n        }\n    }\n    private void storeDescriptor()\n        throws IOException\n    {\n        Document hdr = new Document();\n        hdr.add( new Field( FLD_DESCRIPTOR, FLD_DESCRIPTOR_CONTENTS, Field.Store.YES, Field.Index.NOT_ANALYZED ) );\n        hdr.add( new Field( FLD_IDXINFO, VERSION + ArtifactInfo.FS + getRepositoryId(), Field.Store.YES,\n                            Field.Index.NO ) );\n        IndexWriter w = getIndexWriter();\n        w.updateDocument( DESCRIPTOR_TERM, hdr );\n        w.commit();\n    }\n<fim_suffix>    private void deleteIndexFiles( boolean full )\n        throws IOException\n    {\n        if ( indexDirectory != null )\n        {\n            String[] names = indexDirectory.listAll();\n            if ( names != null )\n            {\n                for ( String name : names )\n                {\n                    if ( !( name.equals( INDEX_PACKER_PROPERTIES_FILE )\n                        || name.equals( INDEX_UPDATER_PROPERTIES_FILE ) ) )\n                    {\n                        indexDirectory.deleteFile( name );\n                    }\n                }\n            }\n            if ( full )\n            {\n                try\n                {\n                    indexDirectory.deleteFile( INDEX_PACKER_PROPERTIES_FILE );\n                }\n                catch ( IOException ioe )\n                {\n                    //Does not exist\n                }\n                try\n                {\n                    indexDirectory.deleteFile( INDEX_UPDATER_PROPERTIES_FILE );\n                }\n                catch ( IOException ioe )\n                {\n                    //Does not exist\n                }\n            }\n            IndexUtils.deleteTimestamp( indexDirectory );\n        }\n    }<fim_middle>// function below has no smell\n"}