{"text": "<fim_prefix>            (Hashtable)SwingUtilities.appContextGet(kitRegistryKey);\n        if (ht == null) {\n            ht = new Hashtable<>(3);\n            SwingUtilities.appContextPut(kitRegistryKey, ht);\n        }\n        return ht;\n    }\n    /**\n     * This is invoked every time the registries are accessed. Loading\n     * is done this way instead of via a static as the static is only\n     * called once when running in plugin resulting in the entries only\n     * appearing in the first applet.\n     */\n    private static void loadDefaultKitsIfNecessary() {\n        if (SwingUtilities.appContextGet(kitTypeRegistryKey) == null) {\n            synchronized(defaultEditorKitMap) {\n                if (defaultEditorKitMap.size() == 0) {\n                    defaultEditorKitMap.put(\"text/plain\",\n                                            \"javax.swing.JEditorPane$PlainEditorKit\");\n                    defaultEditorKitMap.put(\"text/html\",\n                                            \"javax.swing.text.html.HTMLEditorKit\");\n                    defaultEditorKitMap.put(\"text/rtf\",\n                                            \"javax.swing.text.rtf.RTFEditorKit\");\n                    defaultEditorKitMap.put(\"application/rtf\",\n                                            \"javax.swing.text.rtf.RTFEditorKit\");\n                }\n            }\n            Hashtable<Object, Object> ht = new Hashtable<>();\n            SwingUtilities.appContextPut(kitTypeRegistryKey, ht);\n            ht = new Hashtable<>();\n            SwingUtilities.appContextPut(kitLoaderRegistryKey, ht);\n            for (String key : defaultEditorKitMap.keySet()) {\n                registerEditorKitForContentType(key,defaultEditorKitMap.get(key));\n            }\n        }\n    }\n    // --- java.awt.Component methods --------------------------\n    /**\n     * Returns the preferred size for the <code>JEditorPane</code>.\n     * The preferred size for <code>JEditorPane</code> is slightly altered\n     * from the preferred size of the superclass.  If the size\n     * of the viewport has become smaller than the minimum size\n     * of the component, the scrollable definition for tracking\n     * width or height will turn to false.  The default viewport\n     * layout will give the preferred size, and that is not desired\n     * in the case where the scrollable is tracking.  In that case\n     * the <em>normal</em> preferred size is adjusted to the\n     * minimum size.  This allows things like HTML tables to\n     * shrink down to their minimum size and then be laid out at\n     * their minimum size, refusing to shrink any further.\n     *\n     * @return a <code>Dimension</code> containing the preferred size\n     */\n    public Dimension getPreferredSize() {\n        Dimension d = super.getPreferredSize();\n        Container parent = SwingUtilities.getUnwrappedParent(this);\n        if (parent instanceof JViewport) {\n            JViewport port = (JViewport) parent;\n            TextUI ui = getUI();\n            int prefWidth = d.width;\n            int prefHeight = d.height;\n            if (! getScrollableTracksViewportWidth()) {\n                int w = port.getWidth();\n                Dimension min = ui.getMinimumSize(this);\n                if (w != 0 && w < min.width) {\n                    // Only adjust to min if we have a valid size\n                    prefWidth = min.width;\n                }\n            }\n            if (! getScrollableTracksViewportHeight()) {\n                int h = port.getHeight();\n                Dimension min = ui.getMinimumSize(this);\n                if (h != 0 && h < min.height) {\n                    // Only adjust to min if we have a valid size\n                    prefHeight = min.height;\n                }\n            }\n            if (prefWidth != d.width || prefHeight != d.height) {\n                d = new Dimension(prefWidth, prefHeight);\n            }\n        }\n        return d;\n    }\n    // --- JTextComponent methods -----------------------------\n    /**\n     * Sets the text of this <code>TextComponent</code> to the specified\n     * content,\n     * which is expected to be in the format of the content type of\n     * this editor.  For example, if the type is set to <code>text/html</code>\n     * the string should be specified in terms of HTML.\n     * <p>\n     * This is implemented to remove the contents of the current document,\n     * and replace them by parsing the given string using the current\n     * <code>EditorKit</code>.  This gives the semantics of the\n     * superclass by not changing\n     * out the model, while supporting the content type currently set on\n     * this component.  The assumption is that the previous content is\n     * relatively\n     * small, and that the previous content doesn't have side effects.\n     * Both of those assumptions can be violated and cause undesirable results.\n     * To avoid this, create a new document,\n     * <code>getEditorKit().createDefaultDocument()</code>, and replace the\n     * existing <code>Document</code> with the new one. You are then assured the\n     * previous <code>Document</code> won't have any lingering state.\n     * <ol>\n     * <li>\n     * Leaving the existing model in place means that the old view will be\n     * torn down, and a new view created, where replacing the document would\n     * avoid the tear down of the old view.\n     * <li>\n     * Some formats (such as HTML) can install things into the document that\n     * can influence future contents.  HTML can have style information embedded\n     * that would influence the next content installed unexpectedly.\n     * </ol>\n     * <p>\n     * An alternative way to load this component with a string would be to\n     * create a StringReader and call the read method.  In this case the model\n     * would be replaced after it was initialized with the contents of the\n     * string.\n     *\n     * @param t the new text to be set; if <code>null</code> the old\n     *    text will be deleted\n     * @see #getText\n     */\n    @BeanProperty(bound = false, description\n            = \"the text of this component\")\n    public void setText(String t) {\n        try {\n            Document doc = getDocument();\n            doc.remove(0, doc.getLength());\n            if (t == null || t.equals(\"\")) {\n                return;\n            }\n            Reader r = new StringReader(t);\n            EditorKit kit = getEditorKit();\n            kit.read(r, doc, 0);\n        } catch (IOException ioe) {\n            UIManager.getLookAndFeel().provideErrorFeedback(JEditorPane.this);\n        } catch (BadLocationException ble) {\n            UIManager.getLookAndFeel().provideErrorFeedback(JEditorPane.this);\n        }\n    }\n    /**\n     * Returns the text contained in this <code>TextComponent</code>\n     * in terms of the\n     * content type of this editor.  If an exception is thrown while\n     * attempting to retrieve the text, <code>null</code> will be returned.\n     * This is implemented to call <code>JTextComponent.write</code> with\n     * a <code>StringWriter</code>.\n     *\n     * @return the text\n     * @see #setText\n     */\n    public String getText() {\n        String txt;\n        try {\n            StringWriter buf = new StringWriter();\n            write(buf);\n            txt = buf.toString();\n        } catch (IOException ioe) {\n            txt = null;\n        }\n        return txt;\n    }\n    // --- Scrollable  ----------------------------------------\n    /**\n     * Returns true if a viewport should always force the width of this\n     * <code>Scrollable</code> to match the width of the viewport.\n     *\n     * @return true if a viewport should force the Scrollables width to\n     * match its own, false otherwise\n     */\n<fim_suffix>    @BeanProperty(bound = false)\n    public boolean getScrollableTracksViewportWidth() {\n        Container parent = SwingUtilities.getUnwrappedParent(this);\n        if (parent instanceof JViewport) {\n            JViewport port = (JViewport) parent;\n            TextUI ui = getUI();\n            int w = port.getWidth();\n            Dimension min = ui.getMinimumSize(this);\n            Dimension max = ui.getMaximumSize(this);\n            if ((w >= min.width) && (w <= max.width)) {\n                return true;\n            }\n        }\n        return false;\n    }<fim_middle>// function below has no smell\n"}