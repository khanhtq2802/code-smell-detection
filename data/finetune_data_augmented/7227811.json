{"text": "<fim_prefix>                    Operators.error(o, Operators.onOperatorError(s, e, null, o.currentContext()));\n                    return;\n                }\n                result.subscribe(o);\n                return;\n            }\n            if (f == null) {\n                drain();\n            }\n        }\n        abstract void drain();\n    }\n    static final class SwitchOnFirstInner<T, R> extends AbstractSwitchOnFirstInner<T, R> {\n        SwitchOnFirstInner(\n                CoreSubscriber<? super R> outer,\n                BiFunction<Signal<? extends T>, Flux<T>, Publisher<? extends R>> transformer) {\n            super(outer, transformer);\n        }\n        @Override\n        public void subscribe(CoreSubscriber<? super T> actual) {\n            if (state == STATE_INIT && STATE.compareAndSet(this, STATE_INIT, STATE_SUBSCRIBED_ONCE)) {\n                if (first == null && done) {\n                    if (throwable != null) {\n                        Operators.error(actual, throwable);\n                    }\n                    else {\n                        Operators.complete(actual);\n                    }\n                    return;\n                }\n                INNER.lazySet(this, actual);\n                actual.onSubscribe(this);\n            }\n            else {\n                Operators.error(actual, new IllegalStateException(\"FluxSwitchOnFirst allows only one Subscriber\"));\n            }\n        }\n        @Override\n        public void request(long n) {\n            if (Operators.validate(n)) {\n                if (state == STATE_SUBSCRIBED_ONCE && STATE.compareAndSet(this, STATE_SUBSCRIBED_ONCE, STATE_REQUESTED_ONCE)) {\n                    if (first != null) {\n                        drain();\n                    }\n                    if (n != Long.MAX_VALUE) {\n                        if (--n > 0) {\n                            s.request(n);\n                            return;\n                        }\n                        return;\n                    }\n                }\n                s.request(n);\n            }\n        }\n        @Override\n        void drain() {\n            if (WIP.getAndIncrement(this) != 0) {\n                return;\n            }\n            T f = first;\n            int m = 1;\n            CoreSubscriber<? super T> a = inner;\n            for (;;) {\n                if (f != null) {\n                    first = null;\n                    if (cancelled) {\n                        Operators.onDiscard(f, a.currentContext());\n                        return;\n                    }\n                    a.onNext(f);\n                    f = null;\n                }\n                if (cancelled) {\n                    return;\n                }\n                if (done) {\n                    Throwable t = throwable;\n                    if (t != null) {\n                        a.onError(t);\n                    } else {\n                        a.onComplete();\n                    }\n                    return;\n                }\n                m = WIP.addAndGet(this, -m);\n                if (m == 0) {\n                    return;\n                }\n            }\n        }\n    }\n    static final class SwitchOnFirstConditionalInner<T, R> extends AbstractSwitchOnFirstInner<T, R>\n            implements Fuseable.ConditionalSubscriber<T> {\n        SwitchOnFirstConditionalInner(\n                Fuseable.ConditionalSubscriber<? super R> outer,\n                BiFunction<Signal<? extends T>, Flux<T>, Publisher<? extends R>> transformer) {\n            super(outer, transformer);\n        }\n        @Override\n        public void subscribe(CoreSubscriber<? super T> actual) {\n            if (state == STATE_INIT && STATE.compareAndSet(this, STATE_INIT, STATE_SUBSCRIBED_ONCE)) {\n                if (first == null && done) {\n                    if (throwable != null) {\n                        Operators.error(actual, throwable);\n                    }\n                    else {\n                        Operators.complete(actual);\n                    }\n                    return;\n                }\n                INNER.lazySet(this, Operators.toConditionalSubscriber(actual));\n                actual.onSubscribe(this);\n            }\n            else {\n                Operators.error(actual, new IllegalStateException(\"FluxSwitchOnFirst allows only one Subscriber\"));\n            }\n        }\n        @Override\n        public boolean tryOnNext(T t) {\n            if (done) {\n                Operators.onNextDropped(t, currentContext());\n                return false;\n            }\n            @SuppressWarnings(\"unchecked\")\n            Fuseable.ConditionalSubscriber<? super T> i =\n                    (Fuseable.ConditionalSubscriber<? super T>) inner;\n            if (i == null) {\n                Publisher<? extends R> result;\n                CoreSubscriber<? super R> o = outer;\n                try {\n                    result = Objects.requireNonNull(\n                        transformer.apply(Signal.next(t, o.currentContext()), this),\n                        \"The transformer returned a null value\"\n                    );\n                }\n                catch (Throwable e) {\n                    done = true;\n                    Operators.error(o, Operators.onOperatorError(s, e, t, o.currentContext()));\n                    return false;\n                }\n                first = t;\n                result.subscribe(o);\n                return true;\n            }\n            return i.tryOnNext(t);\n        }\n        @Override\n        public void request(long n) {\n            if (Operators.validate(n)) {\n                if (state == STATE_SUBSCRIBED_ONCE && STATE.compareAndSet(this, STATE_SUBSCRIBED_ONCE, STATE_REQUESTED_ONCE)) {\n                    boolean sent = false;\n                    if (first != null) {\n                        sent = drainRegular();\n                    }\n                    if (sent && n != Long.MAX_VALUE) {\n                        if (--n > 0) {\n                            s.request(n);\n                            return;\n                        }\n                        return;\n                    }\n                }\n                s.request(n);\n            }\n        }\n        @Override\n        void drain() {\n            drainRegular();\n        }\n        boolean drainRegular() {\n            if (WIP.getAndIncrement(this) != 0) {\n                return false;\n            }\n            T f = first;\n            int m = 1;\n            boolean sent = false;\n            @SuppressWarnings(\"unchecked\")\n            Fuseable.ConditionalSubscriber<? super T> a =\n                    (Fuseable.ConditionalSubscriber<? super T>) inner;\n            for (;;) {\n                if (f != null) {\n                    first = null;\n                    if (cancelled) {\n                        Operators.onDiscard(f, a.currentContext());\n                        return false;\n                    }\n                    sent = a.tryOnNext(f);\n                    f = null;\n                }\n                if (cancelled) {\n                    return false;\n                }\n                if (done) {\n                    Throwable t = throwable;\n                    if (t != null) {\n                        a.onError(t);\n                    } else {\n                        a.onComplete();\n                    }\n                    return sent;\n                }\n                m = WIP.addAndGet(this, -m);\n                if (m == 0) {\n                    return sent;\n                }\n            }\n        }\n    }\n    static final class SwitchOnFirstInnerSubscriber<T> implements InnerConsumer<T> {\n        final AbstractSwitchOnFirstInner<?, T> parent;\n        final CoreSubscriber<? super T> inner;\n        SwitchOnFirstInnerSubscriber(\n                AbstractSwitchOnFirstInner<?, T> parent,\n                CoreSubscriber<? super T> inner) {\n            this.parent = parent;\n            this.inner = inner;\n        }\n        @Override\n        public Context currentContext() {\n            return inner.currentContext();\n        }\n        @Override\n        public void onSubscribe(Subscription s) {\n            inner.onSubscribe(s);\n        }\n        @Override\n        public void onNext(T t) {\n            inner.onNext(t);\n        }\n        @Override\n        public void onError(Throwable throwable) {\n            if (!parent.done) {\n                parent.cancel();\n            }\n            inner.onError(throwable);\n        }\n        @Override\n        public void onComplete() {\n            if (!parent.done) {\n                parent.cancel();\n            }\n            inner.onComplete();\n        }\n        @Override\n        public Object scanUnsafe(Attr key) {\n            if (key == Attr.PARENT) return parent;\n            if (key == Attr.ACTUAL) return inner;\n            return null;\n        }\n    }\n<fim_suffix>    static final class SwitchOnFirstConditionalInnerSubscriber<T> implements InnerConsumer<T>,\n                                                                             Fuseable.ConditionalSubscriber<T> {\n        final AbstractSwitchOnFirstInner<?, ? super T>  parent;\n        final Fuseable.ConditionalSubscriber<? super T> inner;\n        SwitchOnFirstConditionalInnerSubscriber(\n                AbstractSwitchOnFirstInner<?, ? super T> parent,\n                Fuseable.ConditionalSubscriber<? super T> inner) {\n            this.parent = parent;\n            this.inner = inner;\n        }\n        @Override\n        public Context currentContext() {\n            return inner.currentContext();\n        }\n        @Override\n        public void onSubscribe(Subscription s) {\n            inner.onSubscribe(s);\n        }\n        @Override\n        public void onNext(T t) {\n            inner.onNext(t);\n        }\n        @Override\n        public boolean tryOnNext(T t) {\n            return inner.tryOnNext(t);\n        }\n        @Override\n        public void onError(Throwable throwable) {\n            if (!parent.done) {\n                parent.cancel();\n            }\n            inner.onError(throwable);\n        }\n        @Override\n        public void onComplete() {\n            if (!parent.done) {\n                parent.cancel();\n            }\n            inner.onComplete();\n        }\n        @Override\n        public Object scanUnsafe(Attr key) {\n            if (key == Attr.PARENT) return parent;\n            if (key == Attr.ACTUAL) return inner;\n            return null;\n        }\n    }<fim_middle>// class below has no smell\n"}