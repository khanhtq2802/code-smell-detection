{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.oodt.cas.crawl;\nimport com.google.common.annotations.VisibleForTesting;\nimport org.apache.oodt.cas.crawl.action.CrawlerAction;\nimport org.apache.oodt.cas.crawl.action.CrawlerActionRepo;\nimport org.apache.oodt.cas.crawl.config.ProductCrawlerBean;\nimport org.apache.oodt.cas.crawl.status.IngestStatus;\nimport org.apache.oodt.cas.filemgr.ingest.Ingester;\nimport org.apache.oodt.cas.filemgr.ingest.StdIngester;\nimport org.apache.oodt.cas.metadata.Metadata;\nimport java.io.File;\nimport java.io.FileFilter;\nimport java.io.IOException;\nimport java.net.URL;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Stack;\nimport java.util.Vector;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n//OODT imports\n/**\n * An abstract base class for Product Crawling. This class provides methods to\n * communicate with the file manager and parse met files that show how to ingest\n * a particular Product into the File Manager.\n * \n * @author mattmann (Chris Mattmann)\n * @author bfoster (Brian Foster)\n */\npublic abstract class ProductCrawler extends ProductCrawlerBean {\n   /* our log stream */\n   protected static Logger LOG = Logger.getLogger(ProductCrawler.class\n         .getName());\n   // filter to only find directories when doing a listFiles\n   protected static FileFilter DIR_FILTER = new FileFilter() {\n      public boolean accept(File file) {\n         return file.isDirectory();\n      }\n   };\n   // filter to only find product files, not met files\n   protected static FileFilter FILE_FILTER = new FileFilter() {\n      public boolean accept(File file) {\n         return file.isFile();\n      }\n   };\n   protected List<IngestStatus> ingestStatus = new Vector<IngestStatus>();\n   protected CrawlerActionRepo actionRepo;\n   protected Ingester ingester;\n   public void crawl() {\n      LOG.info(\"Crawl operation invoked\");\n      crawl(new File(getProductPath()));\n   }\n<fim_suffix>   public void crawl(File dirRoot) {\n      LOG.info(String.format(\"Start crawling dir: %s\", dirRoot));\n      // Reset ingest status.a\n      ingestStatus.clear();\n      // Load actions.\n      loadAndValidateActions();\n      // Create Ingester.\n      setupIngester();\n      // Verify valid crawl directory.\n      if (dirRoot == null || !dirRoot.exists()) {\n         throw new IllegalArgumentException(\"dir root is null or non existant!\");\n      }\n      // Start crawling.\n      Stack<File> stack = new Stack<File>();\n      stack.push(dirRoot.isDirectory() ? dirRoot : dirRoot.getParentFile());\n      while (!stack.isEmpty()) {\n         File dir = (File) stack.pop();\n         LOG.log(Level.INFO, \"Crawling \" + dir);\n         File[] productFiles;\n         productFiles = isCrawlForDirs() ? dir.listFiles(DIR_FILTER) : dir.listFiles(FILE_FILTER);\n         if(productFiles!=null) {\n            for (File productFile : productFiles) {\n               ingestStatus.add(handleFile(productFile));\n            }\n         }\n         if (!isNoRecur()) {\n            File[] subdirs = dir.listFiles(DIR_FILTER);\n            if (subdirs != null) {\n               for (File subdir : subdirs) {\n                  stack.push(subdir);\n               }\n            }\n         }\n      }\n      LOG.info(String.format(\"Finished crawling dir: %s\", dirRoot));\n   }\n   public IngestStatus handleFile(File product) {\n      LOG.log(Level.INFO, \"Handling file \" + product);\n      // Check preconditions.\n      if (!passesPreconditions(product)) {\n         LOG.log(Level.WARNING,\n               \"Failed to pass preconditions for ingest of product: [\"\n                     + product.getAbsolutePath() + \"]\");\n         return createIngestStatus(product,\n               IngestStatus.Result.PRECONDS_FAILED,\n               \"Failed to pass preconditions\");\n      }\n      // Generate Metadata for product.\n      Metadata productMetadata = new Metadata();\n      productMetadata.addMetadata(getGlobalMetadata());\n      try {\n         productMetadata.replaceMetadata(getMetadataForProduct(product));\n      } catch (Exception e) {\n         LOG.log(Level.SEVERE,\n               \"Failed to get metadata for product : \" + e.getMessage(), e);\n         performPostIngestOnFailActions(product, productMetadata);\n         return createIngestStatus(product,\n               IngestStatus.Result.FAILURE,\n               \"Failed to get metadata for product : \" + e.getMessage());\n      }\n      // Rename the product.\n      try {\n         product = renameProduct(product, productMetadata);\n      } catch (Exception e) {\n         LOG.log(Level.SEVERE,\n               \"Failed to rename product : \" + e.getMessage(), e);\n         performPostIngestOnFailActions(product, productMetadata);\n         return createIngestStatus(product, IngestStatus.Result.FAILURE,\n               \"Failed to rename product : \" + e.getMessage());\n      }\n      // Set known metadata if not already specified.\n      addKnownMetadata(product, productMetadata);\n      // Check that metadata contains required metadata.\n      if (!containsRequiredMetadata(productMetadata)) {\n         LOG.log(Level.SEVERE, \"Missing required metadata for product '\"\n               + product + \"'\");\n         performPostIngestOnFailActions(product, productMetadata);\n         return createIngestStatus(product, IngestStatus.Result.FAILURE,\n               \"Missing required metadata\");\n      }\n      // Run preIngest actions.\n      if (!performPreIngestActions(product, productMetadata)) {\n         performPostIngestOnFailActions(product, productMetadata);\n         return createIngestStatus(product, IngestStatus.Result.FAILURE,\n            \"PreIngest actions failed to complete\");            \n      }\n      // Check if ingest has been turned off.\n      if (isSkipIngest()) {\n         LOG.log(Level.INFO, \"Skipping ingest of product: [\"\n               + product.getAbsolutePath() + \"]\");\n         return createIngestStatus(product, IngestStatus.Result.SKIPPED,\n               \"Crawler ingest turned OFF\");\n      }\n      // Ingest product.\n      boolean ingestSuccess = ingest(product, productMetadata);\n      // On Successful Ingest.\n      if (ingestSuccess) {\n         LOG.log(Level.INFO, \"Successful ingest of product: [\"\n               + product.getAbsolutePath() + \"]\");\n         performPostIngestOnSuccessActions(product, productMetadata);\n         return createIngestStatus(product,\n               IngestStatus.Result.SUCCESS, \"Ingest was successful\");\n      // On Failed Ingest.\n      } else {\n         LOG.log(Level.WARNING, \"Failed to ingest product: [\"\n               + product.getAbsolutePath()\n               + \"]: performing postIngestFail actions\");         \n         performPostIngestOnFailActions(product, productMetadata);\n         return createIngestStatus(product, IngestStatus.Result.FAILURE,\n               \"Failed to ingest product\");\n      }\n   }\n   public List<IngestStatus> getIngestStatus() {\n      return Collections.unmodifiableList(ingestStatus);\n   }\n   protected abstract boolean passesPreconditions(File product);\n   protected abstract Metadata getMetadataForProduct(File product)\n         throws Exception;\n   protected abstract File renameProduct(File product, Metadata productMetadata)\n         throws Exception;\n   @VisibleForTesting void setupIngester() {\n      ingester = new StdIngester(getClientTransferer());\n   }\n   @VisibleForTesting void loadAndValidateActions() {\n      if (actionRepo == null && getApplicationContext() != null) {\n         actionRepo = new CrawlerActionRepo();\n         actionRepo.loadActionsFromBeanFactory(\n               getApplicationContext(), getActionIds());\n         validateActions();\n      }\n   }\n   @VisibleForTesting void validateActions() {\n      StringBuilder actionErrors = new StringBuilder(\"\");\n      for (CrawlerAction action : actionRepo.getActions()) {\n         try {\n            action.validate();\n         } catch (Exception e) {\n            actionErrors.append(\" \").append(action.getId()).append(\": \").append(e.getMessage()).append(\"\\n\");\n         }\n      }\n      if (actionErrors.length() > 0) {\n         throw new RuntimeException(\"Actions failed validation:\\n\"\n               + actionErrors);\n      }\n   }\n   @VisibleForTesting synchronized boolean containsRequiredMetadata(\n         Metadata productMetadata) {<fim_middle>// function below is long method\n"}