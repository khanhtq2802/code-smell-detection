{"text": "<fim_prefix>/*\n *  Licensed to the Apache Software Foundation (ASF) under one or more\n *  contributor license agreements.  See the NOTICE file distributed with\n *  this work for additional information regarding copyright ownership.\n *  The ASF licenses this file to You under the Apache License, Version 2.0\n *  (the \"License\"); you may not use this file except in compliance with\n *  the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage websocket.drawboard;\n\nimport java.io.IOException;\nimport java.util.LinkedList;\n\nimport javax.websocket.CloseReason;\nimport javax.websocket.CloseReason.CloseCodes;\nimport javax.websocket.RemoteEndpoint.Async;\nimport javax.websocket.SendHandler;\nimport javax.websocket.SendResult;\nimport javax.websocket.Session;\n\nimport websocket.drawboard.wsmessages.AbstractWebsocketMessage;\nimport websocket.drawboard.wsmessages.BinaryWebsocketMessage;\nimport websocket.drawboard.wsmessages.CloseWebsocketMessage;\nimport websocket.drawboard.wsmessages.StringWebsocketMessage;\n\n/**\n * Represents a client with methods to send messages asynchronously.\n */\n<fim_suffix>public class Client {\n\n    private final Session session;\n    private final Async async;\n\n    /**\n     * Contains the messages which are buffered until the previous\n     * send operation has finished.\n     */\n    private final LinkedList<AbstractWebsocketMessage> messagesToSend =\n            new LinkedList<>();\n    /**\n     * If this client is currently sending a messages asynchronously.\n     */\n    private volatile boolean isSendingMessage = false;\n    /**\n     * If this client is closing. If <code>true</code>, new messages to\n     * send will be ignored.\n     */\n    private volatile boolean isClosing = false;\n    /**\n     * The length of all current buffered messages, to avoid iterating\n     * over a linked list.\n     */\n    private volatile long messagesToSendLength = 0;\n\n    public Client(Session session) {\n        this.session = session;\n        this.async = session.getAsyncRemote();\n    }\n\n    /**\n     * Asynchronously closes the Websocket session. This will wait until all\n     * remaining messages have been sent to the Client and then close\n     * the Websocket session.\n     */\n    public void close() {\n        sendMessage(new CloseWebsocketMessage());\n    }\n\n    /**\n     * Sends the given message asynchronously to the client.\n     * If there is already a async sending in progress, then the message\n     * will be buffered and sent when possible.<br><br>\n     *\n     * This method can be called from multiple threads.\n     *\n     * @param msg The message to send\n     */\n    public void sendMessage(AbstractWebsocketMessage msg) {\n        synchronized (messagesToSend) {\n            if (!isClosing) {\n                // Check if we have a Close message\n                if (msg instanceof CloseWebsocketMessage) {\n                    isClosing = true;\n                }\n\n                if (isSendingMessage) {\n                    // Check if the buffered messages exceed\n                    // a specific amount - in that case, disconnect the client\n                    // to prevent DoS.\n                    // In this case we check if there are >= 1000 messages\n                    // or length(of all messages) >= 1000000 bytes.\n                    if (messagesToSend.size() >= 1000\n                            || messagesToSendLength >= 1000000) {\n                        isClosing = true;\n\n                        // Discard the new message and close the session immediately.\n                        CloseReason cr = new CloseReason(\n                                CloseCodes.VIOLATED_POLICY,\n                                \"Send Buffer exceeded\");\n                        try {\n                            // TODO: close() may block if the remote endpoint doesn't read the data\n                            // (eventually there will be a TimeoutException). However, this method\n                            // (sendMessage) is intended to run asynchronous code and shouldn't\n                            // block. Otherwise it would temporarily stop processing of messages\n                            // from other clients.\n                            // Maybe call this method on another thread.\n                            // Note that when this method is called, the RemoteEndpoint.Async\n                            // is still in the process of sending data, so there probably should\n                            // be another way to abort the Websocket connection.\n                            // Ideally, there should be some abort() method that cancels the\n                            // connection immediately...\n                            session.close(cr);\n                        } catch (IOException e) {\n                            // Ignore\n                        }\n\n                    } else {\n\n                        // Check if the last message and the new message are\n                        // String messages - in that case we concatenate them\n                        // to reduce TCP overhead (using \";\" as separator).\n                        if (msg instanceof StringWebsocketMessage\n                                && !messagesToSend.isEmpty()\n                                && messagesToSend.getLast()\n                                instanceof StringWebsocketMessage) {\n\n                            StringWebsocketMessage ms =\n                                    (StringWebsocketMessage) messagesToSend.removeLast();\n                            messagesToSendLength -= calculateMessageLength(ms);\n\n                            String concatenated = ms.getString() + \";\" +\n                                    ((StringWebsocketMessage) msg).getString();\n                            msg = new StringWebsocketMessage(concatenated);\n                        }\n\n                        messagesToSend.add(msg);\n                        messagesToSendLength += calculateMessageLength(msg);\n                    }\n                } else {\n                    isSendingMessage = true;\n                    internalSendMessageAsync(msg);\n                }\n            }\n\n        }\n    }\n\n    private long calculateMessageLength(AbstractWebsocketMessage msg) {\n        if (msg instanceof BinaryWebsocketMessage) {\n            return ((BinaryWebsocketMessage) msg).getBytes().capacity();\n        } else if (msg instanceof StringWebsocketMessage) {\n            return ((StringWebsocketMessage) msg).getString().length() * 2;\n        }\n\n        return 0;\n    }\n\n    /**\n     * Internally sends the messages asynchronously.\n     * @param msg\n     */\n    private void internalSendMessageAsync(AbstractWebsocketMessage msg) {\n        try {\n            if (msg instanceof StringWebsocketMessage) {\n                StringWebsocketMessage sMsg = (StringWebsocketMessage) msg;\n                async.sendText(sMsg.getString(), sendHandler);\n\n            } else if (msg instanceof BinaryWebsocketMessage) {\n                BinaryWebsocketMessage bMsg = (BinaryWebsocketMessage) msg;\n                async.sendBinary(bMsg.getBytes(), sendHandler);\n\n            } else if (msg instanceof CloseWebsocketMessage) {\n                // Close the session.\n                session.close();\n            }\n        } catch (IllegalStateException|IOException ex) {\n            // Trying to write to the client when the session has\n            // already been closed.\n            // Ignore\n        }\n    }\n\n\n\n    /**\n     * SendHandler that will continue to send buffered messages.\n     */\n    private final SendHandler sendHandler = new SendHandler() {\n        @Override\n        public void onResult(SendResult result) {\n            if (!result.isOK()) {\n                // Message could not be sent. In this case, we don't\n                // set isSendingMessage to false because we must assume the connection\n                // broke (and onClose will be called), so we don't try to send\n                // other messages.\n                // As a precaution, we close the session (e.g. if a send timeout occurred).\n                // TODO: session.close() blocks, while this handler shouldn't block.\n                // Ideally, there should be some abort() method that cancels the\n                // connection immediately...\n                try {\n                    session.close();\n                } catch (IOException ex) {\n                    // Ignore\n                }\n            }\n            synchronized (messagesToSend) {\n\n                if (!messagesToSend.isEmpty()) {\n                    AbstractWebsocketMessage msg = messagesToSend.remove();\n                    messagesToSendLength -= calculateMessageLength(msg);\n\n                    internalSendMessageAsync(msg);\n\n                } else {\n                    isSendingMessage = false;\n                }\n\n            }\n        }\n    };\n\n}<fim_middle>// class below has no smell\n"}