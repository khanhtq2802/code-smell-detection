{"text": "<fim_prefix>/*\n * Copyright 2010-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\").\n * You may not use this file except in compliance with the License.\n * A copy of the License is located at\n *\n *  http://aws.amazon.com/apache2.0\n *\n * or in the \"license\" file accompanying this file. This file is distributed\n * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n * express or implied. See the License for the specific language governing\n * permissions and limitations under the License.\n */\npackage software.amazon.awssdk.codegen.poet.paginators;\nimport com.squareup.javapoet.ClassName;\nimport com.squareup.javapoet.CodeBlock;\nimport com.squareup.javapoet.FieldSpec;\nimport com.squareup.javapoet.MethodSpec;\nimport com.squareup.javapoet.TypeName;\nimport java.security.InvalidParameterException;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.stream.Collectors;\nimport javax.lang.model.element.Modifier;\nimport software.amazon.awssdk.codegen.docs.PaginationDocs;\nimport software.amazon.awssdk.codegen.model.intermediate.IntermediateModel;\nimport software.amazon.awssdk.codegen.model.intermediate.MemberModel;\nimport software.amazon.awssdk.codegen.model.intermediate.OperationModel;\nimport software.amazon.awssdk.codegen.model.intermediate.ShapeModel;\nimport software.amazon.awssdk.codegen.model.service.PaginatorDefinition;\nimport software.amazon.awssdk.codegen.poet.ClassSpec;\nimport software.amazon.awssdk.codegen.poet.PoetExtensions;\nimport software.amazon.awssdk.codegen.poet.model.TypeProvider;\nimport software.amazon.awssdk.core.util.PaginatorUtils;\npublic abstract class PaginatorsClassSpec implements ClassSpec {\n    protected static final String CLIENT_MEMBER = \"client\";\n    protected static final String REQUEST_MEMBER = \"firstRequest\";\n    protected static final String NEXT_PAGE_FETCHER_MEMBER = \"nextPageFetcher\";\n    protected static final String HAS_NEXT_PAGE_METHOD = \"hasNextPage\";\n    protected static final String NEXT_PAGE_METHOD = \"nextPage\";\n    protected static final String RESUME_METHOD = \"resume\";\n    protected static final String PREVIOUS_PAGE_METHOD_ARGUMENT = \"previousPage\";\n    protected static final String RESPONSE_LITERAL = \"response\";\n    protected static final String LAST_SUCCESSFUL_PAGE_LITERAL = \"lastSuccessfulPage\";\n    protected final IntermediateModel model;\n    protected final String c2jOperationName;\n    protected final PaginatorDefinition paginatorDefinition;\n    protected final PoetExtensions poetExtensions;\n    protected final TypeProvider typeProvider;\n    protected final OperationModel operationModel;\n    protected final PaginationDocs paginationDocs;\n    public PaginatorsClassSpec(IntermediateModel model, String c2jOperationName, PaginatorDefinition paginatorDefinition) {\n        this.model = model;\n        this.c2jOperationName = c2jOperationName;\n        this.paginatorDefinition = paginatorDefinition;\n        this.poetExtensions = new PoetExtensions(model);\n        this.typeProvider = new TypeProvider(model);\n        this.operationModel = model.getOperation(c2jOperationName);\n        this.paginationDocs = new PaginationDocs(model, operationModel);\n    }\n    /**\n     * @return A Poet {@link ClassName} for the operation request type.\n     *\n     * Example: For ListTables operation, it will be \"ListTablesRequest\" class.\n     */\n    protected ClassName requestType() {\n        return poetExtensions.getModelClass(operationModel.getInput().getVariableType());\n    }\n    /**\n     * @return A Poet {@link ClassName} for the sync operation response type.\n     *\n     * Example: For ListTables operation, it will be \"ListTablesResponse\" class.\n     */\n    protected ClassName responseType() {\n        return poetExtensions.getModelClass(operationModel.getReturnType().getReturnType());\n    }\n    // Generates\n    // private final ListTablesRequest firstRequest;\n    protected FieldSpec requestClassField() {\n        return FieldSpec.builder(requestType(), REQUEST_MEMBER, Modifier.PRIVATE, Modifier.FINAL).build();\n    }\n    protected String nextPageFetcherClassName() {\n        return operationModel.getReturnType().getReturnType() + \"Fetcher\";\n    }\n<fim_suffix>    protected MethodSpec.Builder resumeMethodBuilder() {\n        return MethodSpec.methodBuilder(RESUME_METHOD)\n                         .addModifiers(Modifier.PRIVATE, Modifier.FINAL)\n                         .addParameter(responseType(), LAST_SUCCESSFUL_PAGE_LITERAL)\n                         .returns(className())\n                         .addCode(CodeBlock.builder()\n                                           .beginControlFlow(\"if ($L.$L($L))\", NEXT_PAGE_FETCHER_MEMBER,\n                                                             HAS_NEXT_PAGE_METHOD, LAST_SUCCESSFUL_PAGE_LITERAL)\n                                           .addStatement(\"return new $T($L, $L)\", className(), CLIENT_MEMBER,\n                                                         constructRequestFromLastPage(LAST_SUCCESSFUL_PAGE_LITERAL))\n                                           .endControlFlow()\n                                           .build())\n                         .addJavadoc(CodeBlock.builder()\n                                              .add(\"<p>A helper method to resume the pages in case of unexpected failures. \"\n                                                   + \"The method takes the last successful response page as input and returns an \"\n                                                   + \"instance of {@link $T} that can be used to retrieve the consecutive pages \"\n                                                   + \"that follows the input page.</p>\", className())\n                                              .build());\n    }\n    /*\n     * Returns the {@link TypeName} for a value in the {@link PaginatorDefinition#getResultKey()} list.\n     *\n     * Examples:\n     * If paginated item is represented as List<String>, then member type is String.\n     * If paginated item is represented as List<Foo>, then member type is Foo.\n     * If paginated item is represented as Map<String, List<Foo>>,\n     *              then member type is Map.Entry<String, List<Foo>>.\n     */\n    protected TypeName getTypeForResultKey(String singleResultKey) {\n        MemberModel resultKeyModel = memberModelForResponseMember(singleResultKey);\n        if (resultKeyModel == null) {\n            throw new InvalidParameterException(\"MemberModel is not found for result key: \" + singleResultKey);\n        }\n        if (resultKeyModel.isList()) {\n            return typeProvider.fieldType(resultKeyModel.getListModel().getListMemberModel());\n        } else if (resultKeyModel.isMap()) {\n            return typeProvider.mapEntryWithConcreteTypes(resultKeyModel.getMapModel());\n        } else {\n            throw new IllegalArgumentException(String.format(\"Key %s in paginated operation %s should be either a list or a map\",\n                                                             singleResultKey, c2jOperationName));\n        }\n    }\n    /**\n     * @param input A top level or nested member in response of {@link #c2jOperationName}.\n     *\n     * @return The {@link MemberModel} of the {@link PaginatorDefinition#getResultKey()}. If input value is nested,\n     * then member model of the last child shape is returned.\n     *\n     * For example, if input is StreamDescription.Shards, then the return value is \"Shard\" which is the member model for\n     * the Shards.\n     */\n    protected MemberModel memberModelForResponseMember(String input) {\n        String[] hierarchy = input.split(\"\\\\.\");\n        if (hierarchy.length < 1) {\n            throw new IllegalArgumentException(String.format(\"Error when splitting value %s for operation %s\",\n                                                             input, c2jOperationName));\n        }\n        ShapeModel shape = operationModel.getOutputShape();\n        for (int i = 0; i < hierarchy.length - 1; i++) {\n            shape = shape.findMemberModelByC2jName(hierarchy[i]).getShape();\n        }\n        return shape.getMemberByC2jName(hierarchy[hierarchy.length - 1]);\n    }\n    protected CodeBlock hasNextPageMethodBody() {\n        if (paginatorDefinition.getMoreResults() != null) {\n            return CodeBlock.builder()\n                    .add(\"return $N.$L.booleanValue()\",\n                                 PREVIOUS_PAGE_METHOD_ARGUMENT,\n                                 fluentGetterMethodForResponseMember(paginatorDefinition.getMoreResults()))\n                    .build();\n        }\n        // If there is no more_results token, then output_token will be a single value\n        return CodeBlock.builder()\n                        .add(\"return $3T.isOutputTokenAvailable($1N.$2L)\",\n                             PREVIOUS_PAGE_METHOD_ARGUMENT,\n                             fluentGetterMethodsForOutputToken().get(0),\n                             PaginatorUtils.class)\n                        .build();\n    }\n    /*\n     * Returns {@link CodeBlock} for the NEXT_PAGE_METHOD.\n     *\n     * A sample from dynamoDB listTables paginator:\n     *\n     *  if (oldPage == null) {\n     *      return client.listTables(firstRequest);\n     *  } else {<fim_middle>// function below has no smell\n"}