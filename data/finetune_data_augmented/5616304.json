{"text": "<fim_prefix> * or an {@code ehcache.xml} path location can be specified instead and one will be constructed. If neither are\n * specified, Shiro's failsafe <code><a href=\"./ehcache.xml\">ehcache.xml</a></code> file will be used by default.\n * <p/>\n * This implementation requires EhCache 1.2 and above. Make sure EhCache 1.1 or earlier\n * is not in the classpath or it will not work.\n * <p/>\n * Please see the <a href=\"http://ehcache.sf.net\" target=\"_top\">Ehcache website</a> for their documentation.\n *\n * @see <a href=\"http://ehcache.sf.net\" target=\"_top\">The Ehcache website</a>\n * @since 0.2\n */\npublic class EhCacheManager implements CacheManager, Initializable, Destroyable {\n    /**\n     * This class's private log instance.\n     */\n    private static final Logger log = LoggerFactory.getLogger(EhCacheManager.class);\n    /**\n     * The EhCache cache manager used by this implementation to create caches.\n     */\n    protected net.sf.ehcache.CacheManager manager;\n    /**\n     * Indicates if the CacheManager instance was implicitly/automatically created by this instance, indicating that\n     * it should be automatically cleaned up as well on shutdown.\n     */\n    private boolean cacheManagerImplicitlyCreated = false;\n    /**\n     * Classpath file location of the ehcache CacheManager config file.\n     */\n    private String cacheManagerConfigFile = \"classpath:org/apache/shiro/cache/ehcache/ehcache.xml\";\n    /**\n     * Default no argument constructor\n     */\n    public EhCacheManager() {\n    }\n    /**\n     * Returns the wrapped Ehcache {@link net.sf.ehcache.CacheManager CacheManager} instance.\n     *\n     * @return the wrapped Ehcache {@link net.sf.ehcache.CacheManager CacheManager} instance.\n     */\n    public net.sf.ehcache.CacheManager getCacheManager() {\n        return manager;\n    }\n    /**\n     * Sets the wrapped Ehcache {@link net.sf.ehcache.CacheManager CacheManager} instance.\n     *\n     * @param manager the wrapped Ehcache {@link net.sf.ehcache.CacheManager CacheManager} instance.\n     */\n    public void setCacheManager(net.sf.ehcache.CacheManager manager) {\n        this.manager = manager;\n    }\n    /**\n     * Returns the resource location of the config file used to initialize a new\n     * EhCache CacheManager instance.  The string can be any resource path supported by the\n     * {@link org.apache.shiro.io.ResourceUtils#getInputStreamForPath(String)} call.\n     * <p/>\n     * This property is ignored if the CacheManager instance is injected directly - that is, it is only used to\n     * lazily create a CacheManager if one is not already provided.\n     *\n     * @return the resource location of the config file used to initialize the wrapped\n     *         EhCache CacheManager instance.\n     */\n    public String getCacheManagerConfigFile() {\n        return this.cacheManagerConfigFile;\n    }\n    /**\n     * Sets the resource location of the config file used to initialize the wrapped\n     * EhCache CacheManager instance.  The string can be any resource path supported by the\n     * {@link org.apache.shiro.io.ResourceUtils#getInputStreamForPath(String)} call.\n     * <p/>\n     * This property is ignored if the CacheManager instance is injected directly - that is, it is only used to\n     * lazily create a CacheManager if one is not already provided.\n     *\n     * @param classpathLocation resource location of the config file used to create the wrapped\n     *                          EhCache CacheManager instance.\n     */\n    public void setCacheManagerConfigFile(String classpathLocation) {\n        this.cacheManagerConfigFile = classpathLocation;\n    }\n    /**\n     * Acquires the InputStream for the ehcache configuration file using\n     * {@link ResourceUtils#getInputStreamForPath(String) ResourceUtils.getInputStreamForPath} with the\n     * path returned from {@link #getCacheManagerConfigFile() getCacheManagerConfigFile()}.\n     *\n     * @return the InputStream for the ehcache configuration file.\n     */\n    protected InputStream getCacheManagerConfigFileInputStream() {\n        String configFile = getCacheManagerConfigFile();\n        try {\n            return ResourceUtils.getInputStreamForPath(configFile);\n        } catch (IOException e) {\n            throw new IllegalStateException(\"Unable to obtain input stream for cacheManagerConfigFile [\" +\n                    configFile + \"]\", e);\n        }\n    }\n    /**\n     * Loads an existing EhCache from the cache manager, or starts a new cache if one is not found.\n     *\n     * @param name the name of the cache to load/create.\n     */\n    public final <K, V> Cache<K, V> getCache(String name) throws CacheException {\n        if (log.isTraceEnabled()) {\n            log.trace(\"Acquiring EhCache instance named [\" + name + \"]\");\n        }\n        try {\n            net.sf.ehcache.Ehcache cache = ensureCacheManager().getEhcache(name);\n            if (cache == null) {\n                if (log.isInfoEnabled()) {\n                    log.info(\"Cache with name '{}' does not yet exist.  Creating now.\", name);\n                }\n                this.manager.addCache(name);\n                cache = manager.getCache(name);\n                if (log.isInfoEnabled()) {\n                    log.info(\"Added EhCache named [\" + name + \"]\");\n                }\n            } else {\n                if (log.isInfoEnabled()) {\n                    log.info(\"Using existing EHCache named [\" + cache.getName() + \"]\");\n                }\n            }\n            return new EhCache<K, V>(cache);\n        } catch (net.sf.ehcache.CacheException e) {\n            throw new CacheException(e);\n        }\n    }\n    /**\n     * Initializes this instance.\n     * <p/>\n     * If a {@link #setCacheManager CacheManager} has been\n     * explicitly set (e.g. via Dependency Injection or programmatically) prior to calling this\n     * method, this method does nothing.\n     * <p/>\n     * However, if no {@code CacheManager} has been set, the default Ehcache singleton will be initialized, where\n     * Ehcache will look for an {@code ehcache.xml} file at the root of the classpath.  If one is not found,\n     * Ehcache will use its own failsafe configuration file.\n     * <p/>\n     * Because Shiro cannot use the failsafe defaults (fail-safe expunges cached objects after 2 minutes,\n     * something not desirable for Shiro sessions), this class manages an internal default configuration for\n     * this case.\n     *\n     * @throws org.apache.shiro.cache.CacheException\n     *          if there are any CacheExceptions thrown by EhCache.\n     * @see net.sf.ehcache.CacheManager#create\n     */\n    public final void init() throws CacheException {\n        ensureCacheManager();\n    }\n    private net.sf.ehcache.CacheManager ensureCacheManager() {\n        try {\n            if (this.manager == null) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"cacheManager property not set.  Constructing CacheManager instance... \");\n                }\n                //using the CacheManager constructor, the resulting instance is _not_ a VM singleton\n                //(as would be the case by calling CacheManager.getInstance().  We do not use the getInstance here\n                //because we need to know if we need to destroy the CacheManager instance - using the static call,\n                //we don't know which component is responsible for shutting it down.  By using a single EhCacheManager,\n                //it will always know to shut down the instance if it was responsible for creating it.\n                this.manager = new net.sf.ehcache.CacheManager(getCacheManagerConfigFileInputStream());\n                if (log.isTraceEnabled()) {\n                    log.trace(\"instantiated Ehcache CacheManager instance.\");\n                }\n                cacheManagerImplicitlyCreated = true;\n                if (log.isDebugEnabled()) {\n                    log.debug(\"implicit cacheManager created successfully.\");\n                }\n            }\n            return this.manager;\n        } catch (Exception e) {\n            throw new CacheException(e);\n        }\n    }\n    /**\n     * Shuts-down the wrapped Ehcache CacheManager <b>only if implicitly created</b>.\n     * <p/>\n     * If another component injected\n     * a non-null CacheManager into this instance before calling {@link #init() init}, this instance expects that same\n     * component to also destroy the CacheManager instance, and it will not attempt to do so.\n     */\n<fim_suffix>    public void destroy() {\n        if (cacheManagerImplicitlyCreated) {\n            try {\n                net.sf.ehcache.CacheManager cacheMgr = getCacheManager();\n                cacheMgr.shutdown();\n            } catch (Throwable t) {\n                if (log.isWarnEnabled()) {\n                    log.warn(\"Unable to cleanly shutdown implicitly created CacheManager instance.  \" +\n                            \"Ignoring (shutting down)...\", t);\n                }\n            } finally {\n                this.manager = null;\n                this.cacheManagerImplicitlyCreated = false;\n            }\n        }\n    }<fim_middle>// function below has no smell\n"}