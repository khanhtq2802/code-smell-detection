{"text": "<fim_prefix>    public static final int DEFAULT_CAPACITY = 10;\n    /**\n     * Construct a new unsorted ArrayList with the default capacity.\n     */\n    public ArrayList() {\n        items = new Object[DEFAULT_CAPACITY];\n    }\n    /**\n     * Construct a new ArrayList sorted by the given comparator, with the\n     * default capacity.\n     *\n     * @param comparator A comparator to sort the entries in the list.\n     */\n    public ArrayList(final Comparator<T> comparator) {\n        this();\n        this.comparator = comparator;\n    }\n    /**\n     * Construct a new unsorted ArrayList with the given initial capacity.\n     *\n     * @param capacity The initial capacity for this list.\n     * @throws IllegalArgumentException if the given capacity is negative.\n     */\n    public ArrayList(final int capacity) {\n        Utils.checkNonNegative(capacity, \"capacity\");\n        items = new Object[capacity];\n    }\n    /**\n     * Construct a new ArrayList with the given list of items.\n     *\n     * @param items The initial list of values for the list.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public ArrayList(final T... items) {\n        this(items, 0, items.length);\n    }\n    /**\n     * Construct a new ArrayList with a subset of the given list of items.\n     *\n     * @param items The full array of items to choose from.\n     * @param index The starting location of the items to choose.\n     * @param count The count of items to pick from the full array, starting at the index.\n     * @throws IndexOutOfBoundsException if the given index is negative or greater than the count.\n     */\n    public ArrayList(final T[] items, final int index, final int count) {\n        Utils.checkNull(items, \"items\");\n        Utils.checkIndexBounds(index, count, 0, items.length);\n        this.items = new Object[count];\n        System.arraycopy(items, index, this.items, 0, count);\n        length = count;\n    }\n    /**\n     * Construct a new ArrayList with the given sequence of items.\n     *\n     * @param items The initial list of values for the list.\n     */\n    public ArrayList(final Sequence<T> items) {\n        this(items, 0, items.getLength());\n    }\n    /**\n     * Construct a new ArrayList with a subset of the given sequence of items.\n     *\n     * @param items The full sequence of items to choose from.\n     * @param index The starting location of the items to choose.\n     * @param count The count of items to pick from the full sequence, starting at the index.\n     * @throws IndexOutOfBoundsException if the given index is negative or greater than the count.\n     */\n    public ArrayList(final Sequence<T> items, final int index, final int count) {\n        Utils.checkNull(items, \"items\");\n        Utils.checkIndexBounds(index, count, 0, items.getLength());\n        this.items = new Object[count];\n        for (int i = 0; i < count; i++) {\n            this.items[i] = items.get(index + i);\n        }\n        length = count;\n    }\n    /**\n     * Copy the given ArrayList into a new one.\n     *\n     * @param arrayList The existing list to copy into this one.\n     */\n    public ArrayList(final ArrayList<T> arrayList) {\n        this(arrayList, 0, arrayList.length);\n    }\n    /**\n     * Construct a new ArrayList with a subset of the given ArrayList.\n     *\n     * @param arrayList The full list of items to choose from.\n     * @param index The starting location of the items to choose.\n     * @param count The count of items to pick from the full list, starting at the index.\n     * @throws IndexOutOfBoundsException if the given index is negative or greater than the count.\n     */\n    public ArrayList(final ArrayList<T> arrayList, final int index, final int count) {\n        Utils.checkNull(arrayList, \"arrayList\");\n        Utils.checkIndexBounds(index, count, 0, arrayList.length);\n        items = new Object[count];\n        length = count;\n        System.arraycopy(arrayList.items, index, items, 0, count);\n        comparator = arrayList.comparator;\n    }\n    /**\n     * Copy the given collection into a new ArrayList.\n     *\n     * @param c The existing collection to copy into this list.\n     */\n    public ArrayList(final java.util.Collection<T> c) {\n        Utils.checkNull(c, \"c\");\n        items = c.toArray();\n        length = c.size();\n    }\n    @Override\n    public int add(final T item) {\n        int index = -1;\n        if (comparator == null) {\n            index = length;\n            insert(item, index);\n        } else {\n            // Perform a binary search to find the insertion point\n            index = binarySearch(this, item, comparator);\n            if (index < 0) {\n                index = -(index + 1);\n            }\n            insert(item, index, false);\n        }\n        return index;\n    }\n    @Override\n    public void insert(final T item, final int index) {\n        insert(item, index, true);\n    }\n    /**\n     * Private method to insert an item into the list, with an option to validate\n     * its position with any comparator.\n     *\n     * @param item The item to insert.\n     * @param index The position at which to insert the item.\n     * @param validate Whether or not to ensure the item is being inserted into\n     * the correct sorted position if the list has a comparator.\n     * @throws IllegalArgumentException if the \"validate\" parameter is true, and\n     * there is a comparator set, and the given insertion point is incorrect for\n     * the value of the item.\n     */\n    private void insert(final T item, final int index, final boolean validate) {\n        Utils.checkIndexBounds(index, 0, length);\n        if (comparator != null && validate) {\n            int i = binarySearch(this, item, comparator);\n            if (i < 0) {\n                i = -(i + 1);\n            }\n            if (index != i) {\n                throw new IllegalArgumentException(\n                    \"Given insertion point \" + index + \" does not match the sorted insertion location \" + i + \".\");\n            }\n        }\n        // Insert item\n        ensureCapacity(length + 1);\n        System.arraycopy(items, index, items, index + 1, length - index);\n        items[index] = item;\n        length++;\n        modificationCount++;\n        if (listListeners != null) {\n            listListeners.itemInserted(this, index);\n        }\n    }\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public T update(final int index, final T item) {\n        Utils.checkIndexBounds(index, 0, length - 1);\n        T previousItem = (T) items[index];\n        if (previousItem != item) {\n            if (comparator != null) {\n                // Ensure that the new item is greater or equal to its\n                // predecessor and less than or equal to its successor\n                T predecessorItem = (index > 0 ? (T) items[index - 1] : null);\n                T successorItem = (index < length - 1 ? (T) items[index + 1] : null);\n                if ((predecessorItem != null && comparator.compare(item, predecessorItem) < 0)\n                    || (successorItem != null && comparator.compare(item, successorItem) > 0)) {\n                    throw new IllegalArgumentException(\n                        \"Updated item at index \" + index + \" is not in correct sorted order.\");\n                }\n            }\n            items[index] = item;\n            modificationCount++;\n        }\n        if (listListeners != null) {\n            listListeners.itemUpdated(this, index, previousItem);\n        }\n        return previousItem;\n    }\n    @Override\n    public int remove(final T item) {\n        int index = indexOf(item);\n        if (index >= 0) {\n            remove(index, 1);\n        }\n        return index;\n    }\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public Sequence<T> remove(final int index, final int count) {\n        Utils.checkIndexBounds(index, count, 0, length);\n        ArrayList<T> removed = new ArrayList<>((T[]) items, index, count);\n        // Remove items\n        if (count > 0) {\n            int end = index + count;\n            System.arraycopy(items, index + count, items, index, length - end);\n            length -= count;\n            modificationCount++;\n            // Clear any orphaned references\n            for (int i = length, n = length + count; i < n; i++) {\n                items[i] = null;\n            }\n            if (listListeners != null) {\n                listListeners.itemsRemoved(this, index, removed);\n            }\n        }\n        return removed;\n    }\n<fim_suffix>    @Override\n    public void clear() {\n        if (length > 0) {\n            items = new Object[items.length];\n            length = 0;\n            modificationCount++;\n            if (listListeners != null) {\n                listListeners.listCleared(this);\n            }\n        }\n    }<fim_middle>// function below has no smell\n"}