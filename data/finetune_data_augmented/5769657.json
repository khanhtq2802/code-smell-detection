{"text": "<fim_prefix>        return preparedAttr == null\n                ? null\n                : MappingUtils.evaluateNAME(any, provision, preparedAttr.getKey()).getNameValue();\n    }\n    @Transactional(readOnly = true)\n    @Override\n    public Optional<String> getConnObjectKeyValue(final Any<?> any, final Provision provision) {\n        MappingItem mapItem = provision.getMapping().getConnObjectKeyItem().get();\n        Pair<AttrSchemaType, List<PlainAttrValue>> intValues;\n        try {\n            intValues = getIntValues(\n                    provision,\n                    mapItem,\n                    intAttrNameParser.parse(mapItem.getIntAttrName(), provision.getAnyType().getKind()),\n                    AttrSchemaType.String,\n                    any);\n        } catch (ParseException e) {\n            LOG.error(\"Invalid intAttrName '{}' specified, ignoring\", mapItem.getIntAttrName(), e);\n            intValues = Pair.of(AttrSchemaType.String, Collections.<PlainAttrValue>emptyList());\n        }\n        return Optional.ofNullable(intValues.getRight().isEmpty()\n                ? null\n                : intValues.getRight().get(0).getValueAsString());\n    }\n    @Transactional(readOnly = true)\n    @Override\n    public Optional<String> getConnObjectKeyValue(final Realm realm, final OrgUnit orgUnit) {\n        OrgUnitItem orgUnitItem = orgUnit.getConnObjectKeyItem().get();\n        return Optional.ofNullable(orgUnitItem == null ? null : getIntValue(realm, orgUnitItem));\n    }\n    @Transactional(readOnly = true)\n    @Override\n    public void setIntValues(final Item mapItem, final Attribute attr, final AnyTO anyTO) {\n        List<Object> values = null;\n        if (attr != null) {\n            values = attr.getValue();\n            for (ItemTransformer transformer : MappingUtils.getItemTransformers(mapItem)) {\n                values = transformer.beforePull(mapItem, anyTO, values);\n            }\n        }\n        values = values == null ? Collections.emptyList() : values;\n        IntAttrName intAttrName;\n        try {\n            intAttrName = intAttrNameParser.parse(mapItem.getIntAttrName(), AnyTypeKind.fromTOClass(anyTO.getClass()));\n        } catch (ParseException e) {\n            LOG.error(\"Invalid intAttrName '{}' specified, ignoring\", mapItem.getIntAttrName(), e);\n            return;\n        }\n        if (intAttrName.getField() != null) {\n            switch (intAttrName.getField()) {\n                case \"password\":\n                    if (anyTO instanceof UserTO && !values.isEmpty()) {\n                        ((UserTO) anyTO).setPassword(ConnObjectUtils.getPassword(values.get(0)));\n                    }\n                    break;\n                case \"username\":\n                    if (anyTO instanceof UserTO) {\n                        ((UserTO) anyTO).setUsername(values.isEmpty() || values.get(0) == null\n                                ? null\n                                : values.get(0).toString());\n                    }\n                    break;\n                case \"name\":\n                    if (anyTO instanceof GroupTO) {\n                        ((GroupTO) anyTO).setName(values.isEmpty() || values.get(0) == null\n                                ? null\n                                : values.get(0).toString());\n                    } else if (anyTO instanceof AnyObjectTO) {\n                        ((AnyObjectTO) anyTO).setName(values.isEmpty() || values.get(0) == null\n                                ? null\n                                : values.get(0).toString());\n                    }\n                    break;\n                case \"mustChangePassword\":\n                    if (anyTO instanceof UserTO && !values.isEmpty() && values.get(0) != null) {\n                        ((UserTO) anyTO).setMustChangePassword(BooleanUtils.toBoolean(values.get(0).toString()));\n                    }\n                    break;\n                case \"userOwner\":\n                case \"groupOwner\":\n                    if (anyTO instanceof GroupTO && attr != null) {\n                        // using a special attribute (with schema \"\", that will be ignored) for carrying the\n                        // GroupOwnerSchema value\n                        Attr attrTO = new Attr();\n                        attrTO.setSchema(StringUtils.EMPTY);\n                        if (values.isEmpty() || values.get(0) == null) {\n                            attrTO.getValues().add(StringUtils.EMPTY);\n                        } else {\n                            attrTO.getValues().add(values.get(0).toString());\n                        }\n                        ((GroupTO) anyTO).getPlainAttrs().add(attrTO);\n                    }\n                    break;\n                default:\n            }\n        } else if (intAttrName.getSchemaType() != null && attr != null) {\n            GroupableRelatableTO groupableTO;\n            Group group;\n            if (anyTO instanceof GroupableRelatableTO && intAttrName.getMembershipOfGroup() != null) {\n                groupableTO = (GroupableRelatableTO) anyTO;\n                group = groupDAO.findByName(intAttrName.getMembershipOfGroup());\n            } else {\n                groupableTO = null;\n                group = null;\n            }\n            switch (intAttrName.getSchemaType()) {\n                case PLAIN:\n                    Attr attrTO = new Attr();\n                    attrTO.setSchema(intAttrName.getSchema().getKey());\n                    PlainSchema schema = (PlainSchema) intAttrName.getSchema();\n                    for (Object value : values) {\n                        AttrSchemaType schemaType = schema == null ? AttrSchemaType.String : schema.getType();\n                        if (value != null) {\n                            if (schemaType == AttrSchemaType.Binary) {\n                                attrTO.getValues().add(Base64.getEncoder().encodeToString((byte[]) value));\n                            } else {\n                                attrTO.getValues().add(value.toString());\n                            }\n                        }\n                    }\n                    if (groupableTO == null || group == null) {\n                        anyTO.getPlainAttrs().add(attrTO);\n                    } else {\n                        MembershipTO membership = groupableTO.getMembership(group.getKey()).orElseGet(() -> {\n                            MembershipTO newMemb = new MembershipTO.Builder(group.getKey()).build();\n                            groupableTO.getMemberships().add(newMemb);\n                            return newMemb;\n                        });\n                        membership.getPlainAttrs().add(attrTO);\n                    }\n                    break;\n                case DERIVED:\n                    attrTO = new Attr();\n                    attrTO.setSchema(intAttrName.getSchema().getKey());\n                    if (groupableTO == null || group == null) {\n                        anyTO.getDerAttrs().add(attrTO);\n                    } else {\n                        MembershipTO membership = groupableTO.getMembership(group.getKey()).orElseGet(() -> {\n                            MembershipTO newMemb = new MembershipTO.Builder(group.getKey()).build();\n                            groupableTO.getMemberships().add(newMemb);\n                            return newMemb;\n                        });\n                        membership.getDerAttrs().add(attrTO);\n                    }\n                    break;\n                case VIRTUAL:\n                    attrTO = new Attr();\n                    attrTO.setSchema(intAttrName.getSchema().getKey());\n                    // virtual attributes don't get transformed, iterate over original attr.getValue()\n                    if (attr.getValue() != null && !attr.getValue().isEmpty()) {\n                        attr.getValue().stream().\n                                filter(value -> value != null).\n                                forEachOrdered(value -> attrTO.getValues().add(value.toString()));\n                    }\n                    if (groupableTO == null || group == null) {\n                        anyTO.getVirAttrs().add(attrTO);\n                    } else {\n                        MembershipTO membership = groupableTO.getMembership(group.getKey()).orElseGet(() -> {\n                            MembershipTO newMemb = new MembershipTO.Builder(group.getKey()).build();\n                            groupableTO.getMemberships().add(newMemb);\n                            return newMemb;\n                        });\n                        membership.getVirAttrs().add(attrTO);\n                    }\n                    break;\n                default:\n            }\n        }\n    }\n<fim_suffix>    @Override\n    public void setIntValues(final Item orgUnitItem, final Attribute attr, final RealmTO realmTO) {\n        List<Object> values = null;\n        if (attr != null) {\n            values = attr.getValue();\n            for (ItemTransformer transformer : MappingUtils.getItemTransformers(orgUnitItem)) {\n                values = transformer.beforePull(orgUnitItem, realmTO, values);\n            }\n        }\n        if (values != null && !values.isEmpty() && values.get(0) != null) {\n            switch (orgUnitItem.getIntAttrName()) {\n                case \"name\":\n                    realmTO.setName(values.get(0).toString());\n                    break;\n                case \"fullpath\":\n                    String parentFullPath = StringUtils.substringBeforeLast(values.get(0).toString(), \"/\");\n                    Realm parent = realmDAO.findByFullPath(parentFullPath);\n                    if (parent == null) {\n                        LOG.warn(\"Could not find Realm with path {}, ignoring\", parentFullPath);\n                    } else {\n                        realmTO.setParent(parent.getFullPath());\n                    }\n                    break;\n                default:\n            }\n        }\n    }<fim_middle>// function below has no smell\n"}