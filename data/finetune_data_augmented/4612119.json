{"text": "<fim_prefix>\t\t\treturn FutureUtils.completedExceptionally(new CheckpointException(message));\n\t\t}\n\t}\n\t@Override\n\tpublic CompletableFuture<Acknowledge> confirmCheckpoint(\n\t\t\tExecutionAttemptID executionAttemptID,\n\t\t\tlong checkpointId,\n\t\t\tlong checkpointTimestamp) {\n\t\tlog.debug(\"Confirm checkpoint {}@{} for {}.\", checkpointId, checkpointTimestamp, executionAttemptID);\n\t\tfinal Task task = taskSlotTable.getTask(executionAttemptID);\n\t\tif (task != null) {\n\t\t\ttask.notifyCheckpointComplete(checkpointId);\n\t\t\treturn CompletableFuture.completedFuture(Acknowledge.get());\n\t\t} else {\n\t\t\tfinal String message = \"TaskManager received a checkpoint confirmation for unknown task \" + executionAttemptID + '.';\n\t\t\tlog.debug(message);\n\t\t\treturn FutureUtils.completedExceptionally(new CheckpointException(message));\n\t\t}\n\t}\n\t// ----------------------------------------------------------------------\n\t// Slot allocation RPCs\n\t// ----------------------------------------------------------------------\n\t@Override\n\tpublic CompletableFuture<Acknowledge> requestSlot(\n\t\tfinal SlotID slotId,\n\t\tfinal JobID jobId,\n\t\tfinal AllocationID allocationId,\n\t\tfinal String targetAddress,\n\t\tfinal ResourceManagerId resourceManagerId,\n\t\tfinal Time timeout) {\n\t\t// TODO: Filter invalid requests from the resource manager by using the instance/registration Id\n\t\tlog.info(\"Receive slot request {} for job {} from resource manager with leader id {}.\",\n\t\t\tallocationId, jobId, resourceManagerId);\n\t\ttry {\n\t\t\tif (!isConnectedToResourceManager(resourceManagerId)) {\n\t\t\t\tfinal String message = String.format(\"TaskManager is not connected to the resource manager %s.\", resourceManagerId);\n\t\t\t\tlog.debug(message);\n\t\t\t\tthrow new TaskManagerException(message);\n\t\t\t}\n\t\t\tif (taskSlotTable.isSlotFree(slotId.getSlotNumber())) {\n\t\t\t\tif (taskSlotTable.allocateSlot(slotId.getSlotNumber(), jobId, allocationId, taskManagerConfiguration.getTimeout())) {\n\t\t\t\t\tlog.info(\"Allocated slot for {}.\", allocationId);\n\t\t\t\t} else {\n\t\t\t\t\tlog.info(\"Could not allocate slot for {}.\", allocationId);\n\t\t\t\t\tthrow new SlotAllocationException(\"Could not allocate slot.\");\n\t\t\t\t}\n\t\t\t} else if (!taskSlotTable.isAllocated(slotId.getSlotNumber(), jobId, allocationId)) {\n\t\t\t\tfinal String message = \"The slot \" + slotId + \" has already been allocated for a different job.\";\n\t\t\t\tlog.info(message);\n\t\t\t\tfinal AllocationID allocationID = taskSlotTable.getCurrentAllocation(slotId.getSlotNumber());\n\t\t\t\tthrow new SlotOccupiedException(message, allocationID, taskSlotTable.getOwningJob(allocationID));\n\t\t\t}\n\t\t\tif (jobManagerTable.contains(jobId)) {\n\t\t\t\tofferSlotsToJobManager(jobId);\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tjobLeaderService.addJob(jobId, targetAddress);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t// free the allocated slot\n\t\t\t\t\ttry {\n\t\t\t\t\t\ttaskSlotTable.freeSlot(allocationId);\n\t\t\t\t\t} catch (SlotNotFoundException slotNotFoundException) {\n\t\t\t\t\t\t// slot no longer existent, this should actually never happen, because we've\n\t\t\t\t\t\t// just allocated the slot. So let's fail hard in this case!\n\t\t\t\t\t\tonFatalError(slotNotFoundException);\n\t\t\t\t\t}\n\t\t\t\t\t// release local state under the allocation id.\n\t\t\t\t\tlocalStateStoresManager.releaseLocalStateForAllocationId(allocationId);\n\t\t\t\t\t// sanity check\n\t\t\t\t\tif (!taskSlotTable.isSlotFree(slotId.getSlotNumber())) {\n\t\t\t\t\t\tonFatalError(new Exception(\"Could not free slot \" + slotId));\n\t\t\t\t\t}\n\t\t\t\t\tthrow new SlotAllocationException(\"Could not add job to job leader service.\", e);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (TaskManagerException taskManagerException) {\n\t\t\treturn FutureUtils.completedExceptionally(taskManagerException);\n\t\t}\n\t\treturn CompletableFuture.completedFuture(Acknowledge.get());\n\t}\n\t@Override\n\tpublic CompletableFuture<Acknowledge> freeSlot(AllocationID allocationId, Throwable cause, Time timeout) {\n\t\tfreeSlotInternal(allocationId, cause);\n\t\treturn CompletableFuture.completedFuture(Acknowledge.get());\n\t}\n\t@Override\n\tpublic CompletableFuture<TransientBlobKey> requestFileUpload(FileType fileType, Time timeout) {\n\t\tlog.debug(\"Request file {} upload.\", fileType);\n\t\tfinal String filePath;\n\t\tswitch (fileType) {\n\t\t\tcase LOG:\n\t\t\t\tfilePath = taskManagerConfiguration.getTaskManagerLogPath();\n\t\t\t\tbreak;\n\t\t\tcase STDOUT:\n\t\t\t\tfilePath = taskManagerConfiguration.getTaskManagerStdoutPath();\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tfilePath = null;\n\t\t}\n\t\tif (filePath != null && !filePath.isEmpty()) {\n\t\t\tfinal File file = new File(filePath);\n\t\t\tif (file.exists()) {\n\t\t\t\tfinal TransientBlobCache transientBlobService = blobCacheService.getTransientBlobService();\n\t\t\t\tfinal TransientBlobKey transientBlobKey;\n\t\t\t\ttry (FileInputStream fileInputStream = new FileInputStream(file)) {\n\t\t\t\t\ttransientBlobKey = transientBlobService.putTransient(fileInputStream);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tlog.debug(\"Could not upload file {}.\", fileType, e);\n\t\t\t\t\treturn FutureUtils.completedExceptionally(new FlinkException(\"Could not upload file \" + fileType + '.', e));\n\t\t\t\t}\n\t\t\t\treturn CompletableFuture.completedFuture(transientBlobKey);\n\t\t\t} else {\n\t\t\t\tlog.debug(\"The file {} does not exist on the TaskExecutor {}.\", fileType, getResourceID());\n\t\t\t\treturn FutureUtils.completedExceptionally(new FlinkException(\"The file \" + fileType + \" does not exist on the TaskExecutor.\"));\n\t\t\t}\n\t\t} else {\n\t\t\tlog.debug(\"The file {} is unavailable on the TaskExecutor {}.\", fileType, getResourceID());\n\t\t\treturn FutureUtils.completedExceptionally(new FlinkException(\"The file \" + fileType + \" is not available on the TaskExecutor.\"));\n\t\t}\n\t}\n\t@Override\n\tpublic CompletableFuture<SerializableOptional<String>> requestMetricQueryServiceAddress(Time timeout) {\n\t\treturn CompletableFuture.completedFuture(SerializableOptional.ofNullable(metricQueryServicePath));\n\t}\n\t// ----------------------------------------------------------------------\n\t// Disconnection RPCs\n\t// ----------------------------------------------------------------------\n\t@Override\n\tpublic void disconnectJobManager(JobID jobId, Exception cause) {\n\t\tcloseJobManagerConnection(jobId, cause);\n\t\tjobLeaderService.reconnect(jobId);\n\t}\n\t@Override\n\tpublic void disconnectResourceManager(Exception cause) {\n\t\treconnectToResourceManager(cause);\n\t}\n\t// ======================================================================\n\t//  Internal methods\n\t// ======================================================================\n\t// ------------------------------------------------------------------------\n\t//  Internal resource manager connection methods\n\t// ------------------------------------------------------------------------\n\tprivate void notifyOfNewResourceManagerLeader(String newLeaderAddress, ResourceManagerId newResourceManagerId) {\n\t\tresourceManagerAddress = createResourceManagerAddress(newLeaderAddress, newResourceManagerId);\n\t\treconnectToResourceManager(new FlinkException(String.format(\"ResourceManager leader changed to new address %s\", resourceManagerAddress)));\n\t}\n\t@Nullable\n\tprivate ResourceManagerAddress createResourceManagerAddress(@Nullable String newLeaderAddress, @Nullable ResourceManagerId newResourceManagerId) {\n\t\tif (newLeaderAddress == null) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\tassert(newResourceManagerId != null);\n\t\t\treturn new ResourceManagerAddress(newLeaderAddress, newResourceManagerId);\n\t\t}\n\t}\n\tprivate void reconnectToResourceManager(Exception cause) {\n\t\tcloseResourceManagerConnection(cause);\n\t\ttryConnectToResourceManager();\n\t}\n<fim_suffix>\tprivate void tryConnectToResourceManager() {\n\t\tif (resourceManagerAddress != null) {\n\t\t\tconnectToResourceManager();\n\t\t}\n\t}<fim_middle>// function below has no smell\n"}