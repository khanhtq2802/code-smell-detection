{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.jackrabbit.core.version;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport javax.jcr.ReferentialIntegrityException;\n\nimport org.apache.jackrabbit.core.id.NodeId;\nimport org.apache.jackrabbit.core.id.NodeIdFactory;\nimport org.apache.jackrabbit.core.id.PropertyId;\nimport org.apache.jackrabbit.core.nodetype.NodeTypeRegistry;\nimport org.apache.jackrabbit.core.persistence.PersistenceManager;\nimport org.apache.jackrabbit.core.state.ChangeLog;\nimport org.apache.jackrabbit.core.state.ISMLocking;\nimport org.apache.jackrabbit.core.state.ItemStateCacheFactory;\nimport org.apache.jackrabbit.core.state.ItemStateException;\nimport org.apache.jackrabbit.core.state.NoSuchItemStateException;\nimport org.apache.jackrabbit.core.state.NodeReferences;\nimport org.apache.jackrabbit.core.state.SharedItemStateManager;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Specialized SharedItemStateManager that filters out NodeReferences to\n * non-versioning states.\n */\npublic class VersionItemStateManager extends SharedItemStateManager {\n\n    /**\n     * Logger instance for this class.\n     */\n    private static final Logger log = LoggerFactory.getLogger(VersionItemStateManager.class);\n\n    /**\n     * The persistence manager.\n     */\n    private final PersistenceManager pMgr;\n\n    public VersionItemStateManager(PersistenceManager persistMgr,\n                                   NodeId rootNodeId,\n                                   NodeTypeRegistry ntReg,\n                                   ItemStateCacheFactory cacheFactory,\n                                   ISMLocking locking,\n                                   NodeIdFactory nodeIdFactory)\n            throws ItemStateException {\n        super(persistMgr, rootNodeId, ntReg, false, cacheFactory, locking, nodeIdFactory);\n        this.pMgr = persistMgr;\n    }\n\n    @Override\n    public NodeReferences getNodeReferences(NodeId id)\n            throws NoSuchItemStateException, ItemStateException {\n        // check persistence manager\n        try {\n            return pMgr.loadReferencesTo(id);\n        } catch (NoSuchItemStateException e) {\n            // ignore\n        }\n        // throw\n        throw new NoSuchItemStateException(id.toString());\n    }\n\n    @Override\n    public boolean hasNodeReferences(NodeId id) {\n        // check persistence manager\n        try {\n            if (pMgr.existsReferencesTo(id)) {\n                return true;\n            }\n        } catch (ItemStateException e) {\n            // ignore\n        }\n        return false;\n    }\n\n    /**\n     * Sets the\n     * @param references\n     * @return\n     */\n<fim_suffix>    public boolean setNodeReferences(ChangeLog references) {\n        try {\n            ChangeLog log = new ChangeLog();\n\n            for (NodeReferences source : references.modifiedRefs()) {\n                // filter out version storage intern ones\n                NodeReferences target = new NodeReferences(source.getTargetId());\n                for (PropertyId id : source.getReferences()) {\n                    if (!hasNonVirtualItemState(id.getParentId())) {\n                        target.addReference(id);\n                    }\n                }\n                log.modified(target);\n            }\n\n            if (log.hasUpdates()) {\n                pMgr.store(log);\n            }\n            return true;\n        } catch (ItemStateException e) {\n            log.error(\"Error while setting references: \" + e.toString());\n            return false;\n        }\n    }\n\n    protected void checkReferentialIntegrity(ChangeLog changes)\n            throws ReferentialIntegrityException, ItemStateException {\n        // only store VV-type references and NV-type references\n\n        // check whether targets of modified node references exist\n        Set<NodeId> remove = new HashSet<NodeId>();\n        for (NodeReferences refs : changes.modifiedRefs()) {\n            // no need to check existence of target if there are no references\n            if (refs.hasReferences()) {\n                NodeId id = refs.getTargetId();\n                if (!changes.has(id) && !hasNonVirtualItemState(id)) {\n                    remove.add(refs.getTargetId());\n                }\n            }\n        }\n        // remove references\n        for (NodeId id : remove) {\n            changes.removeReferencesEntry(id);\n        }\n    }\n}<fim_middle>// function below has no smell\n"}