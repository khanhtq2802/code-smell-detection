{"text": "<fim_prefix>                    jobGenParams.readFromFuncArgs(f.getArguments());\n                    datasetName = jobGenParams.getDatasetName();\n                    dataverseName = jobGenParams.getDataverseName();\n                    break;\n                case EXTERNAL_SCAN:\n                    UnnestMapOperator externalScan = (UnnestMapOperator) sourceOpRefs.get(i).getValue();\n                    datasetInfo = AnalysisUtil.getExternalDatasetInfo(externalScan);\n                    dataverseName = datasetInfo.first;\n                    datasetName = datasetInfo.second;\n                    break;\n                case COLLECTION_SCAN:\n                    if (i != 0) {\n                        getIxJoinOuterAdditionalDatasets().add(null);\n                        getIxJoinOuterAdditionalRecordTypes().add(null);\n                    }\n                    continue;\n                case NO_DATASOURCE:\n                default:\n                    return false;\n            }\n            if (dataverseName == null || datasetName == null) {\n                return false;\n            }\n            // Find the dataset corresponding to the datasource in the metadata.\n            ds = metadataProvider.findDataset(dataverseName, datasetName);\n            if (ds == null) {\n                throw new CompilationException(ErrorCode.NO_METADATA_FOR_DATASET, root.getSourceLocation(),\n                        datasetName);\n            }\n            // Get the record type for that dataset.\n            IAType itemType = metadataProvider.findType(ds.getItemTypeDataverseName(), ds.getItemTypeName());\n            if (itemType.getTypeTag() != ATypeTag.OBJECT) {\n                if (i == 0) {\n                    return false;\n                } else {\n                    getIxJoinOuterAdditionalDatasets().add(null);\n                    getIxJoinOuterAdditionalRecordTypes().add(null);\n                }\n            }\n            rType = (ARecordType) itemType;\n            // Get the meta record type for that dataset.\n            IAType metaItemType =\n                    metadataProvider.findType(ds.getMetaItemTypeDataverseName(), ds.getMetaItemTypeName());\n            // First index is always the primary datasource in this subtree.\n            if (i == 0) {\n                setDataset(ds);\n                setRecordType(rType);\n                setMetaRecordType((ARecordType) metaItemType);\n            } else {\n                getIxJoinOuterAdditionalDatasets().add(ds);\n                getIxJoinOuterAdditionalRecordTypes().add(rType);\n            }\n            dataverseName = null;\n            datasetName = null;\n            ds = null;\n            rType = null;\n        }\n        return true;\n    }\n    public boolean hasDataSource() {\n        return getDataSourceType() != DataSourceType.NO_DATASOURCE;\n    }\n    public boolean hasIxJoinOuterAdditionalDataSource() {\n        boolean dataSourceFound = false;\n        if (getIxJoinOuterAdditionalDataSourceTypes() != null) {\n            for (int i = 0; i < getIxJoinOuterAdditionalDataSourceTypes().size(); i++) {\n                if (getIxJoinOuterAdditionalDataSourceTypes().get(i) != DataSourceType.NO_DATASOURCE) {\n                    dataSourceFound = true;\n                    break;\n                }\n            }\n        }\n        return dataSourceFound;\n    }\n    public boolean hasDataSourceScan() {\n        return getDataSourceType() == DataSourceType.DATASOURCE_SCAN;\n    }\n    public boolean hasIxJoinOuterAdditionalDataSourceScan() {\n        if (getIxJoinOuterAdditionalDataSourceTypes() != null) {\n            for (int i = 0; i < getIxJoinOuterAdditionalDataSourceTypes().size(); i++) {\n                if (getIxJoinOuterAdditionalDataSourceTypes().get(i) == DataSourceType.DATASOURCE_SCAN) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    public void reset() {\n        setRoot(null);\n        setRootRef(null);\n        getAssignsAndUnnestsRefs().clear();\n        getAssignsAndUnnests().clear();\n        setDataSourceRef(null);\n        setDataSourceType(DataSourceType.NO_DATASOURCE);\n        setIxJoinOuterAdditionalDataSourceRefs(null);\n        setIxJoinOuterAdditionalDataSourceTypes(null);\n        setDataset(null);\n        setIxJoinOuterAdditionalDatasets(null);\n        setRecordType(null);\n        setIxJoinOuterAdditionalRecordTypes(null);\n    }\n    /**\n     * Gets the primary key variables from the given data-source.\n     */\n    public void getPrimaryKeyVars(Mutable<ILogicalOperator> dataSourceRefToFetch, List<LogicalVariable> target)\n            throws AlgebricksException {\n        Mutable<ILogicalOperator> dataSourceRefToFetchKey =\n                (dataSourceRefToFetch == null) ? dataSourceRef : dataSourceRefToFetch;\n        switch (dataSourceType) {\n            case DATASOURCE_SCAN:\n                DataSourceScanOperator dataSourceScan = (DataSourceScanOperator) getDataSourceRef().getValue();\n                int numPrimaryKeys = dataset.getPrimaryKeys().size();\n                for (int i = 0; i < numPrimaryKeys; i++) {\n                    target.add(dataSourceScan.getVariables().get(i));\n                }\n                break;\n            case PRIMARY_INDEX_LOOKUP:\n                AbstractUnnestMapOperator unnestMapOp = (AbstractUnnestMapOperator) dataSourceRefToFetchKey.getValue();\n                List<LogicalVariable> primaryKeys = null;\n                primaryKeys = AccessMethodUtils.getPrimaryKeyVarsFromPrimaryUnnestMap(dataset, unnestMapOp);\n                target.addAll(primaryKeys);\n                break;\n            case INDEXONLY_PLAN_SECONDARY_INDEX_LOOKUP:\n                AbstractUnnestMapOperator idxOnlyPlanUnnestMapOp =\n                        (AbstractUnnestMapOperator) dataSourceRefToFetchKey.getValue();\n                List<LogicalVariable> idxOnlyPlanKeyVars = idxOnlyPlanUnnestMapOp.getVariables();\n                int indexOnlyPlanNumPrimaryKeys = dataset.getPrimaryKeys().size();\n                // The order of variables: SK, PK, the result of instantTryLock on PK.\n                // The last variable keeps the result of instantTryLock on PK.\n                // Thus, we deduct 1 to only count key variables.\n                int start = idxOnlyPlanKeyVars.size() - 1 - indexOnlyPlanNumPrimaryKeys;\n                int end = start + indexOnlyPlanNumPrimaryKeys;\n                for (int i = start; i < end; i++) {\n                    target.add(idxOnlyPlanKeyVars.get(i));\n                }\n                break;\n            case EXTERNAL_SCAN:\n                break;\n            case NO_DATASOURCE:\n            default:\n                throw new CompilationException(ErrorCode.SUBTREE_HAS_NO_DATA_SOURCE, root.getSourceLocation());\n        }\n    }\n    public List<LogicalVariable> getDataSourceVariables() throws AlgebricksException {\n        switch (getDataSourceType()) {\n            case DATASOURCE_SCAN:\n            case EXTERNAL_SCAN:\n            case PRIMARY_INDEX_LOOKUP:\n                AbstractScanOperator scanOp = (AbstractScanOperator) getDataSourceRef().getValue();\n                return scanOp.getVariables();\n            case INDEXONLY_PLAN_SECONDARY_INDEX_LOOKUP:\n                // This data-source doesn't have record variables.\n                List<LogicalVariable> pkVars = new ArrayList<>();\n                getPrimaryKeyVars(dataSourceRef, pkVars);\n                return pkVars;\n            case COLLECTION_SCAN:\n                return new ArrayList<>();\n            case NO_DATASOURCE:\n            default:\n                throw new CompilationException(ErrorCode.SUBTREE_HAS_NO_DATA_SOURCE, root.getSourceLocation());\n        }\n    }\n    public List<LogicalVariable> getIxJoinOuterAdditionalDataSourceVariables(int idx) throws AlgebricksException {\n        if (getIxJoinOuterAdditionalDataSourceRefs() != null && getIxJoinOuterAdditionalDataSourceRefs().size() > idx) {\n            switch (getIxJoinOuterAdditionalDataSourceTypes().get(idx)) {\n                case DATASOURCE_SCAN:\n                case EXTERNAL_SCAN:\n                case PRIMARY_INDEX_LOOKUP:\n                    AbstractScanOperator scanOp =\n                            (AbstractScanOperator) getIxJoinOuterAdditionalDataSourceRefs().get(idx).getValue();\n                    return scanOp.getVariables();\n                case INDEXONLY_PLAN_SECONDARY_INDEX_LOOKUP:\n                    List<LogicalVariable> PKVars = new ArrayList<>();\n                    getPrimaryKeyVars(ixJoinOuterAdditionalDataSourceRefs.get(idx), PKVars);\n                    return PKVars;\n                case COLLECTION_SCAN:\n                    return new ArrayList<>();\n                case NO_DATASOURCE:\n                default:\n                    throw new CompilationException(ErrorCode.SUBTREE_HAS_NO_ADDTIONAL_DATA_SOURCE,\n                            root.getSourceLocation());\n            }\n        } else {\n            return null;\n        }\n    }\n    public void initializeIxJoinOuterAddtionalDataSourcesIfEmpty() {\n        if (getIxJoinOuterAdditionalDataSourceRefs() == null) {\n            setIxJoinOuterAdditionalDataSourceRefs(new ArrayList<Mutable<ILogicalOperator>>());\n            setIxJoinOuterAdditionalDataSourceTypes(new ArrayList<DataSourceType>());\n            setIxJoinOuterAdditionalDatasets(new ArrayList<Dataset>());\n            setIxJoinOuterAdditionalRecordTypes(new ArrayList<ARecordType>());\n        }\n    }\n    public ILogicalOperator getRoot() {\n        return root;\n    }\n    public void setRoot(ILogicalOperator root) {\n        this.root = root;\n    }\n<fim_suffix>    public Mutable<ILogicalOperator> getRootRef() {\n        return rootRef;\n    }<fim_middle>// function below has no smell\n"}