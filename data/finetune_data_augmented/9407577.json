{"text": "<fim_prefix>     * @return The node removed from the map if a node with such a name exists.\n     * @throws              NOT_FOUND_ERR: Raised if there is no node named\n     *                      name in the map.\n     */\n    /***/\n    public Node removeNamedItem(String name)\n        throws DOMException {\n        return internalRemoveNamedItem(name, true);\n    }\n    /**\n     * Same as removeNamedItem except that it simply returns null if the\n     * specified name is not found.\n     */\n    Node safeRemoveNamedItem(String name) {\n        return internalRemoveNamedItem(name, false);\n    }\n    /**\n     * NON-DOM: Remove the node object\n     *\n     * NOTE: Specifically removes THIS NODE -- not the node with this\n     * name, nor the node with these contents. If node does not belong to\n     * this named node map, we throw a DOMException.\n     *\n     * @param item       The node to remove\n     * @param addDefault true -- magically add default attribute\n     * @return Removed node\n     * @exception DOMException\n     */\n    protected Node removeItem(Node item, boolean addDefault)\n        throws DOMException {\n        int index = -1;\n        if (nodes != null) {\n            final int size = nodes.size();\n            for (int i = 0; i < size; ++i) {\n                if (nodes.get(i) == item) {\n                    index = i;\n                    break;\n                }\n            }\n        }\n        if (index < 0) {\n            String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, \"NOT_FOUND_ERR\", null);\n            throw new DOMException(DOMException.NOT_FOUND_ERR, msg);\n        }\n        return remove((AttrImpl)item, index, addDefault);\n    }\n    /**\n     * Internal removeNamedItem method allowing to specify whether an exception\n     * must be thrown if the specified name is not found.\n     */\n    final protected Node internalRemoveNamedItem(String name, boolean raiseEx){\n        if (isReadOnly()) {\n                String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, \"NO_MODIFICATION_ALLOWED_ERR\", null);\n                throw new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR, msg);\n        }\n        int i = findNamePoint(name,0);\n        if (i < 0) {\n            if (raiseEx) {\n                String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, \"NOT_FOUND_ERR\", null);\n                throw new DOMException(DOMException.NOT_FOUND_ERR, msg);\n            } else {\n                return null;\n            }\n        }\n        return remove((AttrImpl)nodes.get(i), i, true);\n    } // internalRemoveNamedItem(String,boolean):Node\n    private final Node remove(AttrImpl attr, int index,\n                              boolean addDefault) {\n        CoreDocumentImpl ownerDocument = ownerNode.ownerDocument();\n        String name = attr.getNodeName();\n        if (attr.isIdAttribute()) {\n            ownerDocument.removeIdentifier(attr.getValue());\n        }\n        if (hasDefaults() && addDefault) {\n            // If there's a default, add it instead\n            NamedNodeMapImpl defaults =\n                ((ElementImpl) ownerNode).getDefaultAttributes();\n            Node d;\n            if (defaults != null &&\n                (d = defaults.getNamedItem(name)) != null &&\n                findNamePoint(name, index+1) < 0) {\n                    NodeImpl clone = (NodeImpl)d.cloneNode(true);\n                    if (d.getLocalName() !=null){\n                            // we must rely on the name to find a default attribute\n                            // (\"test:attr\"), but while copying it from the DOCTYPE\n                            // we should not loose namespace URI that was assigned\n                            // to the attribute in the instance document.\n                            ((AttrNSImpl)clone).namespaceURI = attr.getNamespaceURI();\n                    }\n                    clone.ownerNode = ownerNode;\n                    clone.isOwned(true);\n                    clone.isSpecified(false);\n                    nodes.set(index, clone);\n                    if (attr.isIdAttribute()) {\n                        ownerDocument.putIdentifier(clone.getNodeValue(),\n                                                (ElementImpl)ownerNode);\n                    }\n            } else {\n                nodes.remove(index);\n            }\n        } else {\n            nodes.remove(index);\n        }\n        //        changed(true);\n        // remove reference to owner\n        attr.ownerNode = ownerDocument;\n        attr.isOwned(false);\n        // make sure it won't be mistaken with defaults in case it's\n        // reused\n        attr.isSpecified(true);\n        attr.isIdAttribute(false);\n        // notify document\n        ownerDocument.removedAttrNode(attr, ownerNode, name);\n        return attr;\n    }\n    /**\n     * Introduced in DOM Level 2. <p>\n     * Removes an attribute specified by local name and namespace URI.\n     * @param namespaceURI\n     *                      The namespace URI of the node to remove.\n     *                      When it is null or an empty string, this\n     *                      method behaves like removeNamedItem.\n     * @param name          The local name of the node to remove. If the\n     *                      removed attribute is known to have a default\n     *                      value, an attribute immediately appears\n     *                      containing the default value.\n     * @return Node         The node removed from the map if a node with such\n     *                      a local name and namespace URI exists.\n     * @throws              NOT_FOUND_ERR: Raised if there is no node named\n     *                      name in the map.\n     */\n    public Node removeNamedItemNS(String namespaceURI, String name)\n        throws DOMException {\n        return internalRemoveNamedItemNS(namespaceURI, name, true);\n    }\n    /**\n     * Same as removeNamedItem except that it simply returns null if the\n     * specified local name and namespace URI is not found.\n     */\n    Node safeRemoveNamedItemNS(String namespaceURI, String name) {\n        return internalRemoveNamedItemNS(namespaceURI, name, false);\n    }\n    /**\n     * Internal removeNamedItemNS method allowing to specify whether an\n     * exception must be thrown if the specified local name and namespace URI\n     * is not found.\n     */\n<fim_suffix>    final protected Node internalRemoveNamedItemNS(String namespaceURI,\n            String name,\n            boolean raiseEx) {\n        CoreDocumentImpl ownerDocument = ownerNode.ownerDocument();\n        if (ownerDocument.errorChecking && isReadOnly()) {\n            String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, \"NO_MODIFICATION_ALLOWED_ERR\", null);\n            throw new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR, msg);\n        }\n        int i = findNamePoint(namespaceURI, name);\n        if (i < 0) {\n            if (raiseEx) {\n                String msg = DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN, \"NOT_FOUND_ERR\", null);\n                throw new DOMException(DOMException.NOT_FOUND_ERR, msg);\n            } else {\n                return null;\n            }\n        }\n        AttrImpl n = (AttrImpl)nodes.get(i);\n        if (n.isIdAttribute()) {\n            ownerDocument.removeIdentifier(n.getValue());\n        }\n        // If there's a default, add it instead\n        String nodeName = n.getNodeName();\n        if (hasDefaults()) {\n            NamedNodeMapImpl defaults = ((ElementImpl) ownerNode).getDefaultAttributes();\n            Node d;\n            if (defaults != null\n                    && (d = defaults.getNamedItem(nodeName)) != null)\n            {\n                int j = findNamePoint(nodeName,0);\n                if (j>=0 && findNamePoint(nodeName, j+1) < 0) {\n                    NodeImpl clone = (NodeImpl)d.cloneNode(true);\n                    clone.ownerNode = ownerNode;\n                    if (d.getLocalName() != null) {\n                        // we must rely on the name to find a default attribute\n                        // (\"test:attr\"), but while copying it from the DOCTYPE\n                        // we should not loose namespace URI that was assigned\n                        // to the attribute in the instance document.\n                        ((AttrNSImpl)clone).namespaceURI = namespaceURI;\n                    }\n                    clone.isOwned(true);\n                    clone.isSpecified(false);\n                    nodes.set(i, clone);\n                    if (clone.isIdAttribute()) {\n                        ownerDocument.putIdentifier(clone.getNodeValue(),\n                                (ElementImpl)ownerNode);\n                    }\n                } else {\n                    nodes.remove(i);\n                }\n            } else {\n                nodes.remove(i);\n            }\n        } else {\n            nodes.remove(i);\n        }\n        //        changed(true);\n        // remove reference to owner\n        n.ownerNode = ownerDocument;\n        n.isOwned(false);\n        // make sure it won't be mistaken with defaults in case it's\n        // reused\n        n.isSpecified(true);\n        // update id table if needed\n        n.isIdAttribute(false);\n        // notify document\n        ownerDocument.removedAttrNode(n, ownerNode, name);\n        return n;\n    } // internalRemoveNamedItemNS(String,String,boolean):Node<fim_middle>// function below is long method\n"}