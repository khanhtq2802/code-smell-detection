{"text": "<fim_prefix>\tpublic ServletServerHttpRequest(HttpServletRequest request, AsyncContext asyncContext,\n\t\t\tString servletPath, DataBufferFactory bufferFactory, int bufferSize)\n\t\t\tthrows IOException, URISyntaxException {\n\t\tthis(createDefaultHttpHeaders(request), request, asyncContext, servletPath, bufferFactory, bufferSize);\n\t}\n\tpublic ServletServerHttpRequest(HttpHeaders headers, HttpServletRequest request, AsyncContext asyncContext,\n\t\t\tString servletPath, DataBufferFactory bufferFactory, int bufferSize)\n\t\t\tthrows IOException, URISyntaxException {\n\t\tsuper(initUri(request), request.getContextPath() + servletPath, initHeaders(headers, request));\n\t\tAssert.notNull(bufferFactory, \"'bufferFactory' must not be null\");\n\t\tAssert.isTrue(bufferSize > 0, \"'bufferSize' must be higher than 0\");\n\t\tthis.request = request;\n\t\tthis.bufferFactory = bufferFactory;\n\t\tthis.buffer = new byte[bufferSize];\n\t\tasyncContext.addListener(new RequestAsyncListener());\n\t\t// Tomcat expects ReadListener registration on initial thread\n\t\tServletInputStream inputStream = request.getInputStream();\n\t\tthis.bodyPublisher = new RequestBodyPublisher(inputStream);\n\t\tthis.bodyPublisher.registerReadListener();\n\t}\n\tprivate static HttpHeaders createDefaultHttpHeaders(HttpServletRequest request) {\n\t\tHttpHeaders headers = new HttpHeaders();\n\t\tfor (Enumeration<?> names = request.getHeaderNames(); names.hasMoreElements(); ) {\n\t\t\tString name = (String) names.nextElement();\n\t\t\tfor (Enumeration<?> values = request.getHeaders(name); values.hasMoreElements(); ) {\n\t\t\t\theaders.add(name, (String) values.nextElement());\n\t\t\t}\n\t\t}\n\t\treturn headers;\n\t}\n\tprivate static URI initUri(HttpServletRequest request) throws URISyntaxException {\n\t\tAssert.notNull(request, \"'request' must not be null\");\n\t\tStringBuffer url = request.getRequestURL();\n\t\tString query = request.getQueryString();\n\t\tif (StringUtils.hasText(query)) {\n\t\t\turl.append('?').append(query);\n\t\t}\n\t\treturn new URI(url.toString());\n\t}\n\tprivate static HttpHeaders initHeaders(HttpHeaders headers, HttpServletRequest request) {\n\t\tMediaType contentType = headers.getContentType();\n\t\tif (contentType == null) {\n\t\t\tString requestContentType = request.getContentType();\n\t\t\tif (StringUtils.hasLength(requestContentType)) {\n\t\t\t\tcontentType = MediaType.parseMediaType(requestContentType);\n\t\t\t\theaders.setContentType(contentType);\n\t\t\t}\n\t\t}\n\t\tif (contentType != null && contentType.getCharset() == null) {\n\t\t\tString encoding = request.getCharacterEncoding();\n\t\t\tif (StringUtils.hasLength(encoding)) {\n\t\t\t\tCharset charset = Charset.forName(encoding);\n\t\t\t\tMap<String, String> params = new LinkedCaseInsensitiveMap<>();\n\t\t\t\tparams.putAll(contentType.getParameters());\n\t\t\t\tparams.put(\"charset\", charset.toString());\n\t\t\t\theaders.setContentType(\n\t\t\t\t\t\tnew MediaType(contentType.getType(), contentType.getSubtype(),\n\t\t\t\t\t\t\t\tparams));\n\t\t\t}\n\t\t}\n\t\tif (headers.getContentLength() == -1) {\n\t\t\tint contentLength = request.getContentLength();\n\t\t\tif (contentLength != -1) {\n\t\t\t\theaders.setContentLength(contentLength);\n\t\t\t}\n\t\t}\n\t\treturn headers;\n\t}\n\t@Override\n\tpublic String getMethodValue() {\n\t\treturn this.request.getMethod();\n\t}\n\t@Override\n\tprotected MultiValueMap<String, HttpCookie> initCookies() {\n\t\tMultiValueMap<String, HttpCookie> httpCookies = new LinkedMultiValueMap<>();\n\t\tCookie[] cookies;\n\t\tsynchronized (this.cookieLock) {\n\t\t\tcookies = this.request.getCookies();\n\t\t}\n\t\tif (cookies != null) {\n\t\t\tfor (Cookie cookie : cookies) {\n\t\t\t\tString name = cookie.getName();\n\t\t\t\tHttpCookie httpCookie = new HttpCookie(name, cookie.getValue());\n\t\t\t\thttpCookies.add(name, httpCookie);\n\t\t\t}\n\t\t}\n\t\treturn httpCookies;\n\t}\n\t@Override\n\tpublic InetSocketAddress getRemoteAddress() {\n\t\treturn new InetSocketAddress(this.request.getRemoteHost(), this.request.getRemotePort());\n\t}\n\t@Nullable\n\tprotected SslInfo initSslInfo() {\n\t\tX509Certificate[] certificates = getX509Certificates();\n\t\treturn certificates != null ? new DefaultSslInfo(getSslSessionId(), certificates) : null;\n\t}\n\t@Nullable\n\tprivate String getSslSessionId() {\n\t\treturn (String) this.request.getAttribute(\"javax.servlet.request.ssl_session_id\");\n\t}\n\t@Nullable\n\tprivate X509Certificate[] getX509Certificates() {\n\t\tString name = \"javax.servlet.request.X509Certificate\";\n\t\treturn (X509Certificate[]) this.request.getAttribute(name);\n\t}\n\t@Override\n\tpublic Flux<DataBuffer> getBody() {\n\t\treturn Flux.from(this.bodyPublisher);\n\t}\n\t/**\n\t * Read from the request body InputStream and return a DataBuffer.\n\t * Invoked only when {@link ServletInputStream#isReady()} returns \"true\".\n\t * @return a DataBuffer with data read, or {@link #EOF_BUFFER} if the input\n\t * stream returned -1, or null if 0 bytes were read.\n\t */\n\t@Nullable\n\tDataBuffer readFromInputStream() throws IOException {\n\t\tint read = this.request.getInputStream().read(this.buffer);\n\t\tlogBytesRead(read);\n\t\tif (read > 0) {\n\t\t\tDataBuffer dataBuffer = this.bufferFactory.allocateBuffer(read);\n\t\t\tdataBuffer.write(this.buffer, 0, read);\n\t\t\treturn dataBuffer;\n\t\t}\n\t\tif (read == -1) {\n\t\t\treturn EOF_BUFFER;\n\t\t}\n\t\treturn null;\n\t}\n\tprotected final void logBytesRead(int read) {\n\t\tLog rsReadLogger = AbstractListenerReadPublisher.rsReadLogger;\n\t\tif (rsReadLogger.isTraceEnabled()) {\n\t\t\trsReadLogger.trace(getLogPrefix() + \"Read \" + read + (read != -1 ? \" bytes\" : \"\"));\n\t\t}\n\t}\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic <T> T getNativeRequest() {\n\t\treturn (T) this.request;\n\t}\n\tprivate final class RequestAsyncListener implements AsyncListener {\n\t\t@Override\n\t\tpublic void onStartAsync(AsyncEvent event) {\n\t\t}\n\t\t@Override\n\t\tpublic void onTimeout(AsyncEvent event) {\n\t\t\tThrowable ex = event.getThrowable();\n\t\t\tex = ex != null ? ex : new IllegalStateException(\"Async operation timeout.\");\n\t\t\tbodyPublisher.onError(ex);\n\t\t}\n\t\t@Override\n\t\tpublic void onError(AsyncEvent event) {\n\t\t\tbodyPublisher.onError(event.getThrowable());\n\t\t}\n\t\t@Override\n\t\tpublic void onComplete(AsyncEvent event) {\n\t\t\tbodyPublisher.onAllDataRead();\n\t\t}\n\t}\n\tprivate class RequestBodyPublisher extends AbstractListenerReadPublisher<DataBuffer> {\n\t\tprivate final ServletInputStream inputStream;\n\t\tpublic RequestBodyPublisher(ServletInputStream inputStream) {\n\t\t\tsuper(ServletServerHttpRequest.this.getLogPrefix());\n\t\t\tthis.inputStream = inputStream;\n\t\t}\n\t\tpublic void registerReadListener() throws IOException {\n\t\t\tthis.inputStream.setReadListener(new RequestBodyPublisherReadListener());\n\t\t}\n\t\t@Override\n\t\tprotected void checkOnDataAvailable() {\n\t\t\tif (this.inputStream.isReady() && !this.inputStream.isFinished()) {\n\t\t\t\tonDataAvailable();\n\t\t\t}\n\t\t}\n\t\t@Override\n\t\t@Nullable\n\t\tprotected DataBuffer read() throws IOException {\n\t\t\tif (this.inputStream.isReady()) {\n\t\t\t\tDataBuffer dataBuffer = readFromInputStream();\n\t\t\t\tif (dataBuffer == EOF_BUFFER) {\n\t\t\t\t\t// No need to wait for container callback...\n\t\t\t\t\tonAllDataRead();\n\t\t\t\t\tdataBuffer = null;\n\t\t\t\t}\n\t\t\t\treturn dataBuffer;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\t@Override\n\t\tprotected void readingPaused() {\n\t\t\t// no-op\n\t\t}\n\t\t@Override\n\t\tprotected void discardData() {\n\t\t\t// Nothing to discard since we pass data buffers on immediately..\n\t\t}\n<fim_suffix>\t\tprivate class RequestBodyPublisherReadListener implements ReadListener {\n\t\t\t@Override\n\t\t\tpublic void onDataAvailable() throws IOException {\n\t\t\t\tRequestBodyPublisher.this.onDataAvailable();\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void onAllDataRead() throws IOException {\n\t\t\t\tRequestBodyPublisher.this.onAllDataRead();\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void onError(Throwable throwable) {\n\t\t\t\tRequestBodyPublisher.this.onError(throwable);\n\t\t\t}\n\t\t}<fim_middle>// class below has no smell\n"}