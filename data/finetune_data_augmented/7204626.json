{"text": "<fim_prefix>\n<fim_suffix>@javax.annotation.Generated(value = \"OracleSDKGenerator\", comments = \"API Version: 20160918\")\npublic interface VirtualNetworkAsync extends AutoCloseable {\n    /**\n     * Sets the endpoint to call (ex, https://www.example.com).\n     * @param endpoint The endpoint of the serice.\n     */\n    void setEndpoint(String endpoint);\n    /**\n     * Sets the region to call (ex, Region.US_PHOENIX_1).\n     * <p>\n     * Note, this will call {@link #setEndpoint(String) setEndpoint} after resolving the endpoint.  If the service is not available in this region, however, an IllegalArgumentException will be raised.\n     * @param region The region of the service.\n     */\n    void setRegion(com.oracle.bmc.Region region);\n    /**\n     * Sets the region to call (ex, 'us-phoenix-1').\n     * <p>\n     * Note, this will first try to map the region ID to a known Region and call\n     * {@link #setRegion(Region) setRegion}.\n     * <p>\n     * If no known Region could be determined, it will create an endpoint based on the\n     * default endpoint format ({@link com.oracle.bmc.Region#formatDefaultRegionEndpoint(Service, String)}\n     * and then call {@link #setEndpoint(String) setEndpoint}.\n     * @param regionId The public region ID.\n     */\n    void setRegion(String regionId);\n    /**\n     * Enables the specified service on the specified gateway. In other words, enables the service\n     * gateway to send traffic to the specified service. You must also set up a route rule with the\n     * service's `cidrBlock` as the rule's destination CIDR and the gateway as the rule's target.\n     * See {@link RouteTable}.\n     * <p>\n     **Note:** The `AttachServiceId` operation is an easy way to enable an individual service on\n     * the service gateway. Compare it with\n     * {@link #updateServiceGateway(UpdateServiceGatewayRequest, Consumer, Consumer) updateServiceGateway}, which also\n     * lets you enable an individual service. However, with `UpdateServiceGateway`, you must specify\n     * the *entire* list of services you want enabled on the service gateway.\n     *\n     *\n     * @param request The request object containing the details to send\n     * @param handler The request handler to invoke upon completion, may be null.\n     * @return A Future that can be used to get the response if no AsyncHandler was\n     *         provided. Note, if you provide an AsyncHandler and use the Future, some\n     *         types of responses (like java.io.InputStream) may not be able to be read in\n     *         both places as the underlying stream may only be consumed once.\n     */\n    java.util.concurrent.Future<AttachServiceIdResponse> attachServiceId(\n            AttachServiceIdRequest request,\n            com.oracle.bmc.responses.AsyncHandler<AttachServiceIdRequest, AttachServiceIdResponse>\n                    handler);\n    /**\n     * Adds one or more customer public IP prefixes to the specified public virtual circuit.\n     * Use this operation (and not {@link #updateVirtualCircuit(UpdateVirtualCircuitRequest, Consumer, Consumer) updateVirtualCircuit})\n     * to add prefixes to the virtual circuit. Oracle must verify the customer's ownership\n     * of each prefix before traffic for that prefix will flow across the virtual circuit.\n     *\n     *\n     * @param request The request object containing the details to send\n     * @param handler The request handler to invoke upon completion, may be null.\n     * @return A Future that can be used to get the response if no AsyncHandler was\n     *         provided. Note, if you provide an AsyncHandler and use the Future, some\n     *         types of responses (like java.io.InputStream) may not be able to be read in\n     *         both places as the underlying stream may only be consumed once.\n     */\n    java.util.concurrent.Future<BulkAddVirtualCircuitPublicPrefixesResponse>\n            bulkAddVirtualCircuitPublicPrefixes(\n                    BulkAddVirtualCircuitPublicPrefixesRequest request,\n                    com.oracle.bmc.responses.AsyncHandler<\n                                    BulkAddVirtualCircuitPublicPrefixesRequest,\n                                    BulkAddVirtualCircuitPublicPrefixesResponse>\n                            handler);\n    /**\n     * Removes one or more customer public IP prefixes from the specified public virtual circuit.\n     * Use this operation (and not {@link #updateVirtualCircuit(UpdateVirtualCircuitRequest, Consumer, Consumer) updateVirtualCircuit})\n     * to remove prefixes from the virtual circuit. When the virtual circuit's state switches\n     * back to PROVISIONED, Oracle stops advertising the specified prefixes across the connection.\n     *\n     *\n     * @param request The request object containing the details to send\n     * @param handler The request handler to invoke upon completion, may be null.\n     * @return A Future that can be used to get the response if no AsyncHandler was\n     *         provided. Note, if you provide an AsyncHandler and use the Future, some\n     *         types of responses (like java.io.InputStream) may not be able to be read in\n     *         both places as the underlying stream may only be consumed once.\n     */\n    java.util.concurrent.Future<BulkDeleteVirtualCircuitPublicPrefixesResponse>\n            bulkDeleteVirtualCircuitPublicPrefixes(\n                    BulkDeleteVirtualCircuitPublicPrefixesRequest request,\n                    com.oracle.bmc.responses.AsyncHandler<\n                                    BulkDeleteVirtualCircuitPublicPrefixesRequest,\n                                    BulkDeleteVirtualCircuitPublicPrefixesResponse>\n                            handler);\n    /**\n     * Connects this local peering gateway (LPG) to another one in the same region.\n     * <p>\n     * This operation must be called by the VCN administrator who is designated as\n     * the *requestor* in the peering relationship. The *acceptor* must implement\n     * an Identity and Access Management (IAM) policy that gives the requestor permission\n     * to connect to LPGs in the acceptor's compartment. Without that permission, this\n     * operation will fail. For more information, see\n     * [VCN Peering](https://docs.cloud.oracle.com/Content/Network/Tasks/VCNpeering.htm).\n     *\n     *\n     * @param request The request object containing the details to send\n     * @param handler The request handler to invoke upon completion, may be null.\n     * @return A Future that can be used to get the response if no AsyncHandler was\n     *         provided. Note, if you provide an AsyncHandler and use the Future, some\n     *         types of responses (like java.io.InputStream) may not be able to be read in\n     *         both places as the underlying stream may only be consumed once.\n     */\n    java.util.concurrent.Future<ConnectLocalPeeringGatewaysResponse> connectLocalPeeringGateways(\n            ConnectLocalPeeringGatewaysRequest request,\n            com.oracle.bmc.responses.AsyncHandler<\n                            ConnectLocalPeeringGatewaysRequest, ConnectLocalPeeringGatewaysResponse>\n                    handler);\n    /**\n     * Connects this RPC to another one in a different region.\n     * <p>\n     * This operation must be called by the VCN administrator who is designated as\n     * the *requestor* in the peering relationship. The *acceptor* must implement\n     * an Identity and Access Management (IAM) policy that gives the requestor permission\n     * to connect to RPCs in the acceptor's compartment. Without that permission, this\n     * operation will fail. For more information, see\n     * [VCN Peering](https://docs.cloud.oracle.com/Content/Network/Tasks/VCNpeering.htm).\n     *\n     *\n     * @param request The request object containing the details to send\n     * @param handler The request handler to invoke upon completion, may be null.\n     * @return A Future that can be used to get the response if no AsyncHandler was\n     *         provided. Note, if you provide an AsyncHandler and use the Future, some\n     *         types of responses (like java.io.InputStream) may not be able to be read in\n     *         both places as the underlying stream may only be consumed once.\n     */\n    java.util.concurrent.Future<ConnectRemotePeeringConnectionsResponse>\n            connectRemotePeeringConnections(\n                    ConnectRemotePeeringConnectionsRequest request,\n                    com.oracle.bmc.responses.AsyncHandler<\n                                    ConnectRemotePeeringConnectionsRequest,\n                                    ConnectRemotePeeringConnectionsResponse>\n                            handler);\n    /**\n     * Creates a new virtual customer-premises equipment (CPE) object in the specified compartment. For\n     * more information, see [IPSec VPNs](https://docs.cloud.oracle.com/Content/Network/Tasks/managingIPsec.htm).\n     * <p>\n     * For the purposes of access control, you must provide the OCID of the compartment where you want\n     * the CPE to reside. Notice that the CPE doesn't have to be in the same compartment as the IPSec\n     * connection or other Networking Service components. If you're not sure which compartment to\n     * use, put the CPE in the same compartment as the DRG. For more information about\n     * compartments and access control, see [Overview of the IAM Service](https://docs.cloud.oracle.com/Content/Identity/Concepts/overview.htm).<fim_middle>// class below has no smell\n"}