{"text": "<fim_prefix>/*\n * Copyright (C) 2006 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * A TimeLimiter implementation which actually does not attempt to limit time at all. This may be\n * desirable to use in some unit tests. More importantly, attempting to debug a call which is\n * time-limited would be extremely annoying, so this gives you a time-limiter you can easily swap in\n * for your real time-limiter while you're debugging.\n *\n * @author Kevin Bourrillion\n * @author Jens Nyman\n * @since 1.0\n */\n@Beta\n@CanIgnoreReturnValue\n@GwtIncompatible\npublic final class FakeTimeLimiter implements TimeLimiter {\n  @Override\n  public <T> T newProxy(\n      T target, Class<T> interfaceType, long timeoutDuration, TimeUnit timeoutUnit) {\n    checkNotNull(target);\n    checkNotNull(interfaceType);\n    checkNotNull(timeoutUnit);\n    return target; // ha ha\n  }\n\n<fim_suffix>  @Override\n  public <T> T callWithTimeout(Callable<T> callable, long timeoutDuration, TimeUnit timeoutUnit)\n      throws ExecutionException {\n    checkNotNull(callable);\n    checkNotNull(timeoutUnit);\n    try {\n      return callable.call();\n    } catch (RuntimeException e) {\n      throw new UncheckedExecutionException(e);\n    } catch (Exception e) {\n      throw new ExecutionException(e);\n    } catch (Error e) {\n      throw new ExecutionError(e);\n    } catch (Throwable e) {\n      // It's a non-Error, non-Exception Throwable. Such classes are usually intended to extend\n      // Exception, so we'll treat it like an Exception.\n      throw new ExecutionException(e);\n    }\n  }\n\n  @Override\n  public <T> T callUninterruptiblyWithTimeout(\n      Callable<T> callable, long timeoutDuration, TimeUnit timeoutUnit) throws ExecutionException {\n    return callWithTimeout(callable, timeoutDuration, timeoutUnit);\n  }\n\n  @Override\n  public void runWithTimeout(Runnable runnable, long timeoutDuration, TimeUnit timeoutUnit) {\n    checkNotNull(runnable);\n    checkNotNull(timeoutUnit);\n    try {\n      runnable.run();\n    } catch (RuntimeException e) {\n      throw new UncheckedExecutionException(e);\n    } catch (Error e) {\n      throw new ExecutionError(e);\n    } catch (Throwable e) {\n      // It's a non-Error, non-Exception Throwable. Such classes are usually intended to extend\n      // Exception, so we'll treat it like a RuntimeException.\n      throw new UncheckedExecutionException(e);\n    }\n  }\n\n  @Override\n  public void runUninterruptiblyWithTimeout(\n      Runnable runnable, long timeoutDuration, TimeUnit timeoutUnit) {\n    runWithTimeout(runnable, timeoutDuration, timeoutUnit);\n  }\n}<fim_middle>// function below has no smell\n"}