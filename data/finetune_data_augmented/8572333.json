{"text": "<fim_prefix>        storeFlushedSequenceIdsByRegion.get(encodedRegionName);\n    if (storeFlushedSequenceId != null) {\n      for (Map.Entry<byte[], Long> entry : storeFlushedSequenceId.entrySet()) {\n        builder.addStoreSequenceId(StoreSequenceId.newBuilder()\n            .setFamilyName(UnsafeByteOperations.unsafeWrap(entry.getKey()))\n            .setSequenceId(entry.getValue().longValue()).build());\n      }\n    }\n    return builder.build();\n  }\n  /**\n   * @param serverName\n   * @return ServerMetrics if serverName is known else null\n   */\n  public ServerMetrics getLoad(final ServerName serverName) {\n    return this.onlineServers.get(serverName);\n  }\n  /**\n   * Compute the average load across all region servers.\n   * Currently, this uses a very naive computation - just uses the number of\n   * regions being served, ignoring stats about number of requests.\n   * @return the average load\n   */\n  public double getAverageLoad() {\n    int totalLoad = 0;\n    int numServers = 0;\n    for (ServerMetrics sl : this.onlineServers.values()) {\n      numServers++;\n      totalLoad += sl.getRegionMetrics().size();\n    }\n    return numServers == 0 ? 0 :\n      (double)totalLoad / (double)numServers;\n  }\n  /** @return the count of active regionservers */\n  public int countOfRegionServers() {\n    // Presumes onlineServers is a concurrent map\n    return this.onlineServers.size();\n  }\n  /**\n   * @return Read-only map of servers to serverinfo\n   */\n  public Map<ServerName, ServerMetrics> getOnlineServers() {\n    // Presumption is that iterating the returned Map is OK.\n    synchronized (this.onlineServers) {\n      return Collections.unmodifiableMap(this.onlineServers);\n    }\n  }\n  public DeadServer getDeadServers() {\n    return this.deadservers;\n  }\n  /**\n   * Checks if any dead servers are currently in progress.\n   * @return true if any RS are being processed as dead, false if not\n   */\n  public boolean areDeadServersInProgress() {\n    return this.deadservers.areDeadServersInProgress();\n  }\n  void letRegionServersShutdown() {\n    long previousLogTime = 0;\n    ServerName sn = master.getServerName();\n    ZKWatcher zkw = master.getZooKeeper();\n    int onlineServersCt;\n    while ((onlineServersCt = onlineServers.size()) > 0){\n      if (System.currentTimeMillis() > (previousLogTime + 1000)) {\n        Set<ServerName> remainingServers = onlineServers.keySet();\n        synchronized (onlineServers) {\n          if (remainingServers.size() == 1 && remainingServers.contains(sn)) {\n            // Master will delete itself later.\n            return;\n          }\n        }\n        StringBuilder sb = new StringBuilder();\n        // It's ok here to not sync on onlineServers - merely logging\n        for (ServerName key : remainingServers) {\n          if (sb.length() > 0) {\n            sb.append(\", \");\n          }\n          sb.append(key);\n        }\n        LOG.info(\"Waiting on regionserver(s) \" + sb.toString());\n        previousLogTime = System.currentTimeMillis();\n      }\n      try {\n        List<String> servers = getRegionServersInZK(zkw);\n        if (servers == null || servers.isEmpty() || (servers.size() == 1\n            && servers.contains(sn.toString()))) {\n          LOG.info(\"ZK shows there is only the master self online, exiting now\");\n          // Master could have lost some ZK events, no need to wait more.\n          break;\n        }\n      } catch (KeeperException ke) {\n        LOG.warn(\"Failed to list regionservers\", ke);\n        // ZK is malfunctioning, don't hang here\n        break;\n      }\n      synchronized (onlineServers) {\n        try {\n          if (onlineServersCt == onlineServers.size()) onlineServers.wait(100);\n        } catch (InterruptedException ignored) {\n          // continue\n        }\n      }\n    }\n  }\n  private List<String> getRegionServersInZK(final ZKWatcher zkw)\n  throws KeeperException {\n    return ZKUtil.listChildrenNoWatch(zkw, zkw.getZNodePaths().rsZNode);\n  }\n  /**\n   * Expire the passed server. Add it to list of dead servers and queue a shutdown processing.\n   * @return True if we queued a ServerCrashProcedure else false if we did not (could happen for\n   *         many reasons including the fact that its this server that is going down or we already\n   *         have queued an SCP for this server or SCP processing is currently disabled because we\n   *         are in startup phase).\n   */\n  public synchronized boolean expireServer(final ServerName serverName) {\n    // THIS server is going down... can't handle our own expiration.\n    if (serverName.equals(master.getServerName())) {\n      if (!(master.isAborted() || master.isStopped())) {\n        master.stop(\"We lost our znode?\");\n      }\n      return false;\n    }\n    if (this.deadservers.isDeadServer(serverName)) {\n      LOG.warn(\"Expiration called on {} but crash processing already in progress\", serverName);\n      return false;\n    }\n    moveFromOnlineToDeadServers(serverName);\n    // If cluster is going down, yes, servers are going to be expiring; don't\n    // process as a dead server\n    if (isClusterShutdown()) {\n      LOG.info(\"Cluster shutdown set; \" + serverName +\n        \" expired; onlineServers=\" + this.onlineServers.size());\n      if (this.onlineServers.isEmpty()) {\n        master.stop(\"Cluster shutdown set; onlineServer=0\");\n      }\n      return false;\n    }\n    LOG.info(\"Processing expiration of \" + serverName + \" on \" + this.master.getServerName());\n    long pid = master.getAssignmentManager().submitServerCrash(serverName, true);\n    if(pid <= 0) {\n      return false;\n    } else {\n      // Tell our listeners that a server was removed\n      if (!this.listeners.isEmpty()) {\n        for (ServerListener listener : this.listeners) {\n          listener.serverRemoved(serverName);\n        }\n      }\n      // trigger a persist of flushedSeqId\n      if (flushedSeqIdFlusher != null) {\n        flushedSeqIdFlusher.triggerNow();\n      }\n      return true;\n    }\n  }\n  @VisibleForTesting\n  public void moveFromOnlineToDeadServers(final ServerName sn) {\n    synchronized (onlineServers) {\n      if (!this.onlineServers.containsKey(sn)) {\n        LOG.trace(\"Expiration of {} but server not online\", sn);\n      }\n      // Remove the server from the known servers lists and update load info BUT\n      // add to deadservers first; do this so it'll show in dead servers list if\n      // not in online servers list.\n      this.deadservers.add(sn);\n      this.onlineServers.remove(sn);\n      onlineServers.notifyAll();\n    }\n    this.rsAdmins.remove(sn);\n  }\n  /*\n   * Remove the server from the drain list.\n   */\n  public synchronized boolean removeServerFromDrainList(final ServerName sn) {\n    // Warn if the server (sn) is not online.  ServerName is of the form:\n    // <hostname> , <port> , <startcode>\n    if (!this.isServerOnline(sn)) {\n      LOG.warn(\"Server \" + sn + \" is not currently online. \" +\n               \"Removing from draining list anyway, as requested.\");\n    }\n    // Remove the server from the draining servers lists.\n    return this.drainingServers.remove(sn);\n  }\n  /**\n   * Add the server to the drain list.\n   * @param sn\n   * @return True if the server is added or the server is already on the drain list.\n   */\n<fim_suffix>  public synchronized boolean addServerToDrainList(final ServerName sn) {\n    // Warn if the server (sn) is not online.  ServerName is of the form:\n    // <hostname> , <port> , <startcode>\n    if (!this.isServerOnline(sn)) {\n      LOG.warn(\"Server \" + sn + \" is not currently online. \" +\n               \"Ignoring request to add it to draining list.\");\n      return false;\n    }\n    // Add the server to the draining servers lists, if it's not already in\n    // it.\n    if (this.drainingServers.contains(sn)) {\n      LOG.warn(\"Server \" + sn + \" is already in the draining server list.\" +\n               \"Ignoring request to add it again.\");\n      return true;\n    }\n    LOG.info(\"Server \" + sn + \" added to draining server list.\");\n    return this.drainingServers.add(sn);\n  }<fim_middle>// function below has no smell\n"}