{"text": "<fim_prefix>              {\n                if (watcher != null) watcher.disable();\n                cb.processResult(KeeperException.Code.NONODE.intValue(), path, ctx, null, null);\n                LOG.warn(\"Exception when resolving symlink: \" + path, e);\n              }\n              break;\n            default:\n              if (watcher != null) watcher.disable();\n              cb.processResult(rc, path, ctx, data, stat);\n              break;\n          }\n        }\n      };\n      _zk.getData(symlink, watcher, resolveCallback, ctx);\n    }\n  }\n  private void exists0(final String path, final SymlinkWatcher watcher, final AsyncCallback.StatCallback cb, final Object ctx)\n  {\n    int index = SymlinkUtil.firstSymlinkIndex(path);\n    if (index < 0)\n    {\n      _zk.exists(path, watcher, cb, ctx);\n    }\n    else\n    {\n      String symlink = path.substring(0, index);\n      final String remainPath = path.substring(index);\n      AsyncCallback.DataCallback resolveCallback = new AsyncCallback.DataCallback()\n      {\n        @Override\n        public void processResult(int rc, String p, Object c, byte data[], Stat s)\n        {\n          KeeperException.Code result = KeeperException.Code.get(rc);\n          switch (result)\n          {\n            case OK:\n              try\n              {\n                String realPath = _serializer.fromBytes(data);\n                exists0(realPath + remainPath, watcher, cb, ctx);\n              }\n              catch (Exception e)\n              {\n                // we don't want to disable watch here because NONODE is not an exception\n                // in exists() call, so the watch is still valid.\n                cb.processResult(KeeperException.Code.NONODE.intValue(), path, ctx, null);\n                LOG.warn(\"Exception when resolving symlink: \" + path, e);\n              }\n              break;\n            case NONODE:\n              // the intermediate symlink znode doesn't exist. we should attach an existsWatcher to this znode,\n              // otherwise we won't get notified once it is back later.\n              //\n              // Note that we don't have to do this for getData0() and getChildren0() because NONODE is considered\n              // as exception for these two operations and by definition no watcher should be attached if an exception\n              // is thrown.\n              AsyncCallback.StatCallback existsCallback = new AsyncCallback.StatCallback()\n              {\n                @Override\n                public void processResult(int rc, String p, Object c, Stat s)\n                {\n                  KeeperException.Code code = KeeperException.Code.get(rc);\n                  switch (code)\n                  {\n                    case OK:\n                      // the symlink znode is back, resume the original call.\n                      exists0(path, watcher, cb, ctx);\n                      break;\n                    case NONODE:\n                      // the existsWatcher has been attached. we just need to invoke the user callback in this case.\n                      cb.processResult(rc, path, ctx, s);\n                      break;\n                    default:\n                      // the call failed with some other reasons. disable the watcher and invoke the user callback.\n                      if (watcher != null) watcher.disable();\n                      cb.processResult(rc, path, ctx, s);\n                      break;\n                  }\n                }\n              };\n              _zk.exists(p, watcher, existsCallback, ctx);\n              break;\n            default:\n              if (watcher != null) watcher.disable();\n              cb.processResult(rc, path, ctx, s);\n              break;\n          }\n        }\n      };\n      _zk.getData(symlink, watcher, resolveCallback, ctx);\n    }\n  }\n  private void getChildren0(final String path, final SymlinkWatcher watcher, final AsyncCallback.ChildrenCallback cb, final Object ctx)\n  {\n    int index = SymlinkUtil.firstSymlinkIndex(path);\n    if (index < 0)\n    {\n      _zk.getChildren(path, watcher, cb, ctx);\n    }\n    else\n    {\n      String symlink = path.substring(0, index);\n      final String remainPath = path.substring(index);\n      AsyncCallback.DataCallback resolveCallback = new AsyncCallback.DataCallback()\n      {\n        @Override\n        public void processResult(int rc, String path, Object ctx, byte data[], Stat stat)\n        {\n          KeeperException.Code result = KeeperException.Code.get(rc);\n          switch (result)\n          {\n            case OK:\n              try\n              {\n                String realPath = _serializer.fromBytes(data);\n                getChildren0(realPath + remainPath, watcher, cb, ctx);\n              }\n              catch (Exception e)\n              {\n                if (watcher != null) watcher.disable();\n                cb.processResult(KeeperException.Code.NONODE.intValue(), path, ctx, Collections.<String>emptyList());\n                LOG.warn(\"Exception when resolving symlink: \" + path, e);\n              }\n              break;\n            default:\n              if (watcher != null) watcher.disable();\n              cb.processResult(rc, path, ctx, Collections.<String>emptyList());\n              break;\n          }\n        }\n      };\n      _zk.getData(symlink, watcher, resolveCallback, ctx);\n    }\n  }\n  private void getChildren2(final String path, final SymlinkWatcher watcher, final AsyncCallback.Children2Callback cb, final Object ctx)\n  {\n    int index = SymlinkUtil.firstSymlinkIndex(path);\n    if (index < 0)\n    {\n      _zk.getChildren(path, watcher, cb, ctx);\n    }\n    else\n    {\n      String symlink = path.substring(0, index);\n      final String remainPath = path.substring(index);\n      AsyncCallback.DataCallback resolveCallback = new AsyncCallback.DataCallback()\n      {\n        @Override\n        public void processResult(int rc, String path, Object ctx, byte data[], Stat stat)\n        {\n          KeeperException.Code result = KeeperException.Code.get(rc);\n          switch (result)\n          {\n            case OK:\n              try\n              {\n                String realPath = _serializer.fromBytes(data);\n                getChildren2(realPath + remainPath, watcher, cb, ctx);\n              }\n              catch (Exception e)\n              {\n                if (watcher != null) watcher.disable();\n                cb.processResult(KeeperException.Code.NONODE.intValue(), path, ctx, Collections.<String>emptyList(), null);\n                LOG.warn(\"Exception when resolving symlink: \" + path, e);\n              }\n              break;\n            default:\n              if (watcher != null) watcher.disable();\n              cb.processResult(rc, path, ctx, Collections.<String>emptyList(), null);\n              break;\n          }\n        }\n      };\n      _zk.getData(symlink, watcher, resolveCallback, ctx);\n    }\n  }\n  private abstract class SymlinkWatcher implements Watcher\n  {\n    protected final Watcher _watch;\n    protected final String _rawPath;\n    protected AtomicBoolean _disabled = new AtomicBoolean();\n    protected volatile WatchedEvent _pendingEvent;\n    protected volatile boolean _callbackInvoked = false;\n    public SymlinkWatcher(Watcher watch, String rawPath)\n    {\n      _watch = watch;\n      _rawPath = rawPath;\n      _pendingEvent = null;\n    }\n    @Override\n    public void process(WatchedEvent event)\n    {\n      // We disable the watch once we receive the first watched event. Otherwise\n      // the user watcher may receive more than 1 event, which breaks the definition\n      // of \"one-time trigger\".\n      // See: http://zookeeper.apache.org/doc/trunk/zookeeperProgrammers.html#ch_zkWatches.\n      if (_disabled.getAndSet(true)) return;\n      WatchedEvent newEvent = newWatchedEvent(event);\n      // In vanilla ZooKeeper, we can only receive a watch event after the\n      // callback associated with the request has been successfully invoked.\n      // While it is entirely possible in our implementation that a watch event\n      // triggered by an intermediate symlink arrives in advance. In such case,\n      // we should defer the watch event until the request callback is invoked.\n      if (_callbackInvoked)\n      {\n        _watch.process(newEvent);\n      }\n      else\n      {\n        _pendingEvent = newEvent;\n      }\n    }\n    public void disable()\n    {\n      _disabled.set(true);\n      _pendingEvent = null;\n    }\n    protected WatchedEvent newWatchedEvent(WatchedEvent event)\n    {\n      return new WatchedEvent(event.getType(), event.getState(), _rawPath);\n    }\n  }\n<fim_suffix>  private class SymlinkDataCallback extends SymlinkWatcher implements AsyncCallback.DataCallback\n  {\n    private final AsyncCallback.DataCallback _callback;\n    public SymlinkDataCallback (String rawPath, Watcher watch, AsyncCallback.DataCallback cb)\n    {\n      super(watch, rawPath);\n      _callback = cb;\n    }\n    @Override\n    public void processResult(int rc, String path, Object ctx, byte[] bytes, Stat stat)\n    {\n      _callback.processResult(rc, _rawPath, ctx, bytes, stat);\n      _callbackInvoked = true;\n      // flush out the pending watch event if necessary.\n      if (_pendingEvent != null)\n      {\n        _watch.process(_pendingEvent);\n      }\n    }\n  }<fim_middle>// class below has no smell\n"}