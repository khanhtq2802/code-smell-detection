{"text": "<fim_prefix>\n<fim_suffix>class GlyphPainter2 extends GlyphView.GlyphPainter {\n    public GlyphPainter2(TextLayout layout) {\n        this.layout = layout;\n    }\n    /**\n     * Create a painter to use for the given GlyphView.\n     */\n    public GlyphView.GlyphPainter getPainter(GlyphView v, int p0, int p1) {\n        return null;\n    }\n    /**\n     * Determine the span the glyphs given a start location\n     * (for tab expansion).  This implementation assumes it\n     * has no tabs (i.e. TextLayout doesn't deal with tab\n     * expansion).\n     */\n    public float getSpan(GlyphView v, int p0, int p1,\n                         TabExpander e, float x) {\n        if ((p0 == v.getStartOffset()) && (p1 == v.getEndOffset())) {\n            return layout.getAdvance();\n        }\n        int p = v.getStartOffset();\n        int index0 = p0 - p;\n        int index1 = p1 - p;\n        TextHitInfo hit0 = TextHitInfo.afterOffset(index0);\n        TextHitInfo hit1 = TextHitInfo.beforeOffset(index1);\n        float[] locs = layout.getCaretInfo(hit0);\n        float x0 = locs[0];\n        locs = layout.getCaretInfo(hit1);\n        float x1 = locs[0];\n        return (x1 > x0) ? x1 - x0 : x0 - x1;\n    }\n    public float getHeight(GlyphView v) {\n        return layout.getAscent() + layout.getDescent() + layout.getLeading();\n    }\n    /**\n     * Fetch the ascent above the baseline for the glyphs\n     * corresponding to the given range in the model.\n     */\n    public float getAscent(GlyphView v) {\n        return layout.getAscent();\n    }\n    /**\n     * Fetch the descent below the baseline for the glyphs\n     * corresponding to the given range in the model.\n     */\n    public float getDescent(GlyphView v) {\n        return layout.getDescent();\n    }\n    /**\n     * Paint the glyphs for the given view.  This is implemented\n     * to only render if the Graphics is of type Graphics2D which\n     * is required by TextLayout (and this should be the case if\n     * running on the JDK).\n     */\n    public void paint(GlyphView v, Graphics g, Shape a, int p0, int p1) {\n        if (g instanceof Graphics2D) {\n            Rectangle2D alloc = a.getBounds2D();\n            Graphics2D g2d = (Graphics2D)g;\n            float y = (float) alloc.getY() + layout.getAscent() + layout.getLeading();\n            float x = (float) alloc.getX();\n            if( p0 > v.getStartOffset() || p1 < v.getEndOffset() ) {\n                try {\n                    //TextLayout can't render only part of it's range, so if a\n                    //partial range is required, add a clip region.\n                    Shape s = v.modelToView(p0, Position.Bias.Forward,\n                                            p1, Position.Bias.Backward, a);\n                    Shape savedClip = g.getClip();\n                    g2d.clip(s);\n                    layout.draw(g2d, x, y);\n                    g.setClip(savedClip);\n                } catch (BadLocationException e) {}\n            } else {\n                layout.draw(g2d, x, y);\n            }\n        }\n    }\n    public Shape modelToView(GlyphView v, int pos, Position.Bias bias,\n                             Shape a) throws BadLocationException {\n        int offs = pos - v.getStartOffset();\n        Rectangle2D alloc = a.getBounds2D();\n        TextHitInfo hit = (bias == Position.Bias.Forward) ?\n            TextHitInfo.afterOffset(offs) : TextHitInfo.beforeOffset(offs);\n        float[] locs = layout.getCaretInfo(hit);\n        // vertical at the baseline, should use slope and check if glyphs\n        // are being rendered vertically.\n        Rectangle2D rect = new Rectangle2D.Float();\n        rect.setRect(alloc.getX() + locs[0], alloc.getY(), 1, alloc.getHeight());\n        return rect;\n    }\n    /**\n     * Provides a mapping from the view coordinate space to the logical\n     * coordinate space of the model.\n     *\n     * @param v the view containing the view coordinates\n     * @param x the X coordinate\n     * @param y the Y coordinate\n     * @param a the allocated region to render into\n     * @param biasReturn either <code>Position.Bias.Forward</code>\n     *  or <code>Position.Bias.Backward</code> is returned as the\n     *  zero-th element of this array\n     * @return the location within the model that best represents the\n     *  given point of view\n     * @see View#viewToModel\n     */\n    public int viewToModel(GlyphView v, float x, float y, Shape a,\n                           Position.Bias[] biasReturn) {\n        Rectangle2D alloc = (a instanceof Rectangle2D) ? (Rectangle2D)a : a.getBounds2D();\n        //Move the y co-ord of the hit onto the baseline.  This is because TextLayout supports\n        //italic carets and we do not.\n        TextHitInfo hit = layout.hitTestChar(x - (float)alloc.getX(), 0);\n        int pos = hit.getInsertionIndex();\n        if (pos == v.getEndOffset()) {\n            pos--;\n        }\n        biasReturn[0] = hit.isLeadingEdge() ? Position.Bias.Forward : Position.Bias.Backward;\n        return pos + v.getStartOffset();\n    }\n    /**\n     * Determines the model location that represents the\n     * maximum advance that fits within the given span.\n     * This could be used to break the given view.  The result\n     * should be a location just shy of the given advance.  This\n     * differs from viewToModel which returns the closest\n     * position which might be proud of the maximum advance.\n     *\n     * @param v the view to find the model location to break at.\n     * @param p0 the location in the model where the\n     *  fragment should start it's representation >= 0.\n     * @param x the graphic location along the axis that the\n     *  broken view would occupy >= 0.  This may be useful for\n     *  things like tab calculations.\n     * @param len specifies the distance into the view\n     *  where a potential break is desired >= 0.\n     * @return the maximum model location possible for a break.\n     * @see View#breakView\n     */\n    public int getBoundedPosition(GlyphView v, int p0, float x, float len) {\n        if( len < 0 )\n            throw new IllegalArgumentException(\"Length must be >= 0.\");\n        // note: this only works because swing uses TextLayouts that are\n        // only pure rtl or pure ltr\n        TextHitInfo hit;\n        if (layout.isLeftToRight()) {\n            hit = layout.hitTestChar(len, 0);\n        } else {\n            hit = layout.hitTestChar(layout.getAdvance() - len, 0);\n        }\n        return v.getStartOffset() + hit.getCharIndex();\n    }\n    /**\n         * Provides a way to determine the next visually represented model\n         * location that one might place a caret.  Some views may not be\n         * visible, they might not be in the same order found in the model, or\n         * they just might not allow access to some of the locations in the\n         * model.\n         *\n         * @param v the view to use\n         * @param pos the position to convert >= 0\n         * @param a the allocated region to render into\n         * @param direction the direction from the current position that can\n         *  be thought of as the arrow keys typically found on a keyboard.\n         *  This may be SwingConstants.WEST, SwingConstants.EAST,\n         *  SwingConstants.NORTH, or SwingConstants.SOUTH.\n         * @return the location within the model that best represents the next\n         *  location visual position.\n         * @exception BadLocationException\n         * @exception IllegalArgumentException for an invalid direction\n         */\n        public int getNextVisualPositionFrom(GlyphView v, int pos,\n                                             Position.Bias b, Shape a,\n                                             int direction,\n                                             Position.Bias[] biasRet)\n            throws BadLocationException {\n            Document doc = v.getDocument();\n            int startOffset = v.getStartOffset();\n            int endOffset = v.getEndOffset();\n            Segment text;\n            boolean viewIsLeftToRight;\n            TextHitInfo currentHit, nextHit;\n            switch (direction) {\n            case View.NORTH:\n                break;\n            case View.SOUTH:\n                break;\n            case View.EAST:\n                viewIsLeftToRight = AbstractDocument.isLeftToRight(doc, startOffset, endOffset);\n                if(startOffset == doc.getLength()) {\n                    if(pos == -1) {\n                        biasRet[0] = Position.Bias.Forward;<fim_middle>// class below is blob\n"}