{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.wicket.feedback;\n\nimport java.util.List;\n\nimport org.apache.wicket.Component;\nimport org.apache.wicket.MetaDataKey;\nimport org.apache.wicket.Session;\nimport org.apache.wicket.markup.html.panel.FeedbackPanel;\n\n/**\n * A specialized feedback panel that only displays messages from inside a fence defined by a\n * container component. Instances will not show messages coming from inside a nested fence, allowing\n * the nesting of these panels to work correctly without displaying the same feedback message twice.\n * A constructor that does not takes a fencing component creates a catch-all panel that shows\n * messages that do not come from inside any fence or from the {@link Session}.\n * <p/>\n * <h2>IN DEPTH EXPLANATION</h2>\n * <p>\n * It is often very useful to have feedback panels that show feedback that comes from inside a\n * certain container only. For example given a page with the following structure:\n * </p>\n * <p/>\n * <pre>\n * Page\n *   Form1\n *     Feedback1\n *     Input1\n *     Form2\n *       Feedback2\n *       Input2\n * </pre>\n * <p>\n * we want Feedback2 to show messages originating only from inside Form2 and Feedback1 to show\n * messages only originating from Form1 but not Form2 (because messages originating from Form2 are\n * already shown by Feedback2).\n * </p>\n * <p>\n * It is fairly simple to configure Feedback2 - a {@link ContainerFeedbackMessageFilter} added to\n * the regular {@link FeedbackPanel} will do the trick. The hard part is configuring Feedback1. We\n * can add a {@link ContainerFeedbackMessageFilter} to it, but since Form2 is inside Form1 the\n * container filter will allow messages from both Form1 and Form2 to be added to FeedbackPanel1.\n * </p>\n * <p>\n * This is where the {@link FencedFeedbackPanel} comes in. All we have to do is to make\n * FeedbackPanel2 a {@link FencedFeedbackPanel} with the fencing component defined as Form2 and\n * Feedback1 a {@link FencedFeedbackPanel} with the fencing component defined as Form1.\n * {@link FencedFeedbackPanel} will only show messages that original from inside its fencing\n * component and not from inside any descendant component that acts as a fence for another\n * {@link FencedFeedbackPanel}.\n * </p>\n * <p>\n * When created with a {@code null} fencing component or using a constructor that does not take one\n * the panel will only display messages that do not come from inside a fence. It will also display\n * messages that come from {@link Session}. This acts as a catch-all panels showing messages that\n * would not be shown using any other instance of the {@link FencedFeedbackPanel} created with a\n * fencing component. There is usually one instance of such a panel at the top of the page to\n * display notifications of success.\n * </p>\n *\n * @author igor\n */\npublic class FencedFeedbackPanel extends FeedbackPanel\n{\n\t\n\tprivate static final long serialVersionUID = 1L;\n\n\tprivate static final MetaDataKey<Integer> FENCE_KEY = new MetaDataKey<>()\n\t{\n\t\tprivate static final long serialVersionUID = 1L;\n\t};\n\n\tprivate final Component fence;\n\n\t/**\n\t * Creates a catch-all feedback panel that will show messages not coming from any fence,\n\t * including messages coming from {@link Session}\n\t *\n\t * @param id\n\t */\n\tpublic FencedFeedbackPanel(String id)\n\t{\n\t\tthis(id, (Component)null);\n\t}\n\n\t/**\n\t * Creates a feedback panel that will only show messages if they original from, or inside of,\n\t * the {@code fence} component and not from any inner fence.\n\t *\n\t * @param id\n\t * @param fence\n\t */\n\tpublic FencedFeedbackPanel(String id, Component fence)\n\t{\n\t\tthis(id, fence, null);\n\t}\n\n\t/**\n\t * Creates a catch-all instance with a filter.\n\t *\n\t * @param id\n\t * @param filter\n\t * @see #FencedFeedbackPanel(String)\n\t */\n\tpublic FencedFeedbackPanel(String id, IFeedbackMessageFilter filter)\n\t{\n\t\tthis(id, null, filter);\n\t}\n\n\t/**\n\t * Creates a fenced feedback panel with a filter.\n\t *\n\t * @param id\n\t * @param fence\n\t * @param filter\n\t * @see #FencedFeedbackPanel(String, Component)\n\t */\n\tpublic FencedFeedbackPanel(String id, Component fence, IFeedbackMessageFilter filter)\n\t{\n\t\tsuper(id, filter);\n\t\tthis.fence = fence;\n\t\tif (fence != null)\n\t\t{\n\t\t\tincrementFenceCount();\n\t\t}\n\t}\n\n\tprivate void incrementFenceCount()\n\t{\n\t\tInteger count = fence.getMetaData(FENCE_KEY);\n\t\tcount = count == null ? 1 : count + 1;\n\t\tfence.setMetaData(FENCE_KEY, count);\n\t}\n\n\t@Override\n\tprotected void onRemove()\n\t{\n\t\tsuper.onRemove();\n\t\tif (fence != null)\n\t\t{\n\t\t\t// decrement the fence count\n\n\t\t\tdecrementFenceCount();\n\t\t}\n\t}\n\n\tprivate void decrementFenceCount()\n\t{\n\t\tInteger count = fence.getMetaData(FENCE_KEY);\n\t\tcount = (count == null || count == 1) ? null : count - 1;\n\t\tfence.setMetaData(FENCE_KEY, count);\n\t}\n\n\t@Override\n\tprotected FeedbackMessagesModel newFeedbackMessagesModel()\n\t{\n\t\treturn new FeedbackMessagesModel(this)\n\t\t{\n\t\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t\t@Override\n\t\t\tprotected List<FeedbackMessage> collectMessages(Component panel,\n\t\t\t\t\tIFeedbackMessageFilter filter)\n\t\t\t{\n\t\t\t\tif (fence == null)\n\t\t\t\t{\n\t\t\t\t\t// this is the catch-all panel\n\t\t\t\t\treturn new FencedFeedbackCollector(panel.getPage(), true).collect(filter);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// this is a fenced panel\n\t\t\t\t\treturn new FencedFeedbackCollector(fence, false).collect(filter);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n<fim_suffix>\t@Override\n\tprotected void onReAdd()\n\t{\n\t\tif (this.fence != null)\n\t\t{\n\t\t\t// The fence mark is removed when the feedback panel is removed from the hierarchy.\n\t\t\t// see onRemove().\n\t\t\t// when the panel is re-added, we recreate the fence mark.\n\t\t\tincrementFenceCount();\n\t\t}\n\t\tsuper.onReAdd();\n\t}\n\t\n\tprivate final class FencedFeedbackCollector extends FeedbackCollector\n\t{\n\t\tprivate FencedFeedbackCollector(Component component, boolean includeSession)\n\t\t{\n\t\t\tsuper(component, includeSession);\n\t\t}\n\n\t\t@Override\n\t\tprotected boolean shouldRecurseInto(Component component)\n\t\t{\n\t\t\treturn !componentIsMarkedAsFence(component);\n\t\t}\n\t\t\n\t\tprivate boolean componentIsMarkedAsFence(Component component)\n\t\t{\n\t\t\treturn component.getMetaData(FENCE_KEY) != null;\n\t\t}\n\t}\n}<fim_middle>// function below has no smell\n"}