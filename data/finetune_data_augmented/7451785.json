{"text": "<fim_prefix>/*\n * Copyright (c) 2017, 2017, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage com.oracle.truffle.regex;\nimport com.oracle.truffle.api.CompilerDirectives;\nimport com.oracle.truffle.regex.tregex.parser.flavors.PythonFlavor;\nimport com.oracle.truffle.regex.tregex.parser.flavors.RegexFlavor;\nimport java.util.Arrays;\npublic final class RegexOptions {\n    private static final int U180E_WHITESPACE = 1;\n    public static final String U180E_WHITESPACE_NAME = \"U180EWhitespace\";\n    private static final int REGRESSION_TEST_MODE = 1 << 1;\n    public static final String REGRESSION_TEST_MODE_NAME = \"RegressionTestMode\";\n    private static final int DUMP_AUTOMATA = 1 << 2;\n    public static final String DUMP_AUTOMATA_NAME = \"DumpAutomata\";\n    private static final int STEP_EXECUTION = 1 << 3;\n    public static final String STEP_EXECUTION_NAME = \"StepExecution\";\n    private static final int ALWAYS_EAGER = 1 << 4;\n    public static final String ALWAYS_EAGER_NAME = \"AlwaysEager\";\n    public static final RegexOptions DEFAULT = new RegexOptions(0, null);\n    private final int options;\n    private final RegexFlavor flavor;\n    private RegexOptions(int options, RegexFlavor flavor) {\n        this.options = options;\n        this.flavor = flavor;\n    }\n    public static Builder newBuilder() {\n        return new Builder();\n    }\n    @CompilerDirectives.TruffleBoundary\n    public static RegexOptions parse(String optionsString) throws RegexSyntaxException {\n        int options = 0;\n        RegexFlavor flavor = null;\n        for (String propValue : optionsString.split(\",\")) {\n            if (propValue.isEmpty()) {\n                continue;\n            }\n            int eqlPos = propValue.indexOf('=');\n            if (eqlPos < 0) {\n                throw optionsSyntaxError(optionsString, propValue + \" is not in form 'key=value'\");\n            }\n            String key = propValue.substring(0, eqlPos);\n            String value = propValue.substring(eqlPos + 1);\n            switch (key) {\n                case U180E_WHITESPACE_NAME:\n                    options = parseBooleanOption(optionsString, options, key, value, U180E_WHITESPACE);\n                    break;\n                case REGRESSION_TEST_MODE_NAME:\n                    options = parseBooleanOption(optionsString, options, key, value, REGRESSION_TEST_MODE);\n                    break;\n                case DUMP_AUTOMATA_NAME:\n                    options = parseBooleanOption(optionsString, options, key, value, DUMP_AUTOMATA);\n                    break;\n                case STEP_EXECUTION_NAME:\n                    options = parseBooleanOption(optionsString, options, key, value, STEP_EXECUTION);\n                    break;\n                case ALWAYS_EAGER_NAME:\n                    options = parseBooleanOption(optionsString, options, key, value, ALWAYS_EAGER);\n                    break;\n                case \"Flavor\":\n                    flavor = parseFlavor(optionsString, value);\n                    break;\n                default:\n                    throw optionsSyntaxError(optionsString, \"unexpected option \" + key);\n            }\n        }\n        return new RegexOptions(options, flavor);\n    }\n    private static int parseBooleanOption(String optionsString, int options, String key, String value, int flag) throws RegexSyntaxException {\n        if (value.equals(\"true\")) {\n            return options | flag;\n        } else if (!value.equals(\"false\")) {\n            throw optionsSyntaxErrorUnexpectedValue(optionsString, key, value, \"true\", \"false\");\n        }\n        return options;\n    }\n    private static RegexFlavor parseFlavor(String optionsString, String value) throws RegexSyntaxException {\n        switch (value) {\n            case \"PythonStr\":\n                return PythonFlavor.STR_INSTANCE;\n            case \"PythonBytes\":\n                return PythonFlavor.BYTES_INSTANCE;\n            case \"ECMAScript\":\n                return null;\n            default:\n                throw optionsSyntaxErrorUnexpectedValue(optionsString, \"Flavor\", value, \"Python\", \"ECMAScript\");\n        }\n    }\n    private static RegexSyntaxException optionsSyntaxErrorUnexpectedValue(String optionsString, String key, String value, String... expectedValues) {\n        return optionsSyntaxError(optionsString, String.format(\"unexpected value '%s' for option '%s', expected one of %s\", value, key, Arrays.toString(expectedValues)));\n    }\n    private static RegexSyntaxException optionsSyntaxError(String optionsString, String msg) {\n        return new RegexSyntaxException(String.format(\"Invalid options syntax in '%s': %s\", optionsString, msg));\n    }\n    private boolean isBitSet(int bit) {\n        return (options & bit) != 0;\n    }\n    public boolean isU180EWhitespace() {\n        return isBitSet(U180E_WHITESPACE);\n    }\n    public boolean isRegressionTestMode() {\n        return isBitSet(REGRESSION_TEST_MODE);\n    }\n    /**\n     * Produce ASTs and automata in JSON, DOT (GraphViz) and LaTeX formats.\n     */\n    public boolean isDumpAutomata() {\n        return isBitSet(DUMP_AUTOMATA);\n    }\n    /**\n     * Trace the execution of automata in JSON files.\n     */\n    public boolean isStepExecution() {\n        return isBitSet(STEP_EXECUTION);\n    }\n    /**\n     * Always match capture groups eagerly.\n     */\n    public boolean isAlwaysEager() {\n        return isBitSet(ALWAYS_EAGER);\n    }\n    public RegexFlavor getFlavor() {\n        return flavor;\n    }\n    @Override\n    public int hashCode() {\n        int flavorHash = flavor == null ? 0 : flavor.hashCode();\n        return options + 13 * flavorHash;\n    }\n    @Override\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof RegexOptions)) {\n            return false;\n        }\n        RegexOptions other = (RegexOptions) obj;\n        return this.options == other.options && this.flavor == other.flavor;\n    }\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        if (isU180EWhitespace()) {\n            sb.append(U180E_WHITESPACE_NAME + \"=true,\");\n        }\n        if (isRegressionTestMode()) {\n            sb.append(REGRESSION_TEST_MODE_NAME + \"=true,\");\n        }\n        if (isDumpAutomata()) {\n            sb.append(DUMP_AUTOMATA_NAME + \"=true,\");\n        }\n        if (isStepExecution()) {\n            sb.append(STEP_EXECUTION_NAME + \"=true,\");\n        }\n        if (isAlwaysEager()) {\n            sb.append(ALWAYS_EAGER_NAME + \"=true,\");\n        }\n        if (flavor == PythonFlavor.STR_INSTANCE) {\n            sb.append(\"Flavor=PythonStr,\");\n        } else if (flavor == PythonFlavor.BYTES_INSTANCE) {\n            sb.append(\"Flavor=PythonBytes,\");\n        }\n        return sb.toString();\n    }\n    public static final class Builder {\n        private int options;\n        private RegexFlavor flavor;\n<fim_suffix>        private Builder() {\n            this.options = 0;\n            this.flavor = null;\n        }\n        public Builder u180eWhitespace(boolean enabled) {\n            updateOption(enabled, U180E_WHITESPACE);\n            return this;\n        }\n        public Builder regressionTestMode(boolean enabled) {\n            updateOption(enabled, REGRESSION_TEST_MODE);\n            return this;\n        }\n        public Builder dumpAutomata(boolean enabled) {\n            updateOption(enabled, DUMP_AUTOMATA);\n            return this;\n        }\n        public Builder stepExecution(boolean enabled) {<fim_middle>// function below has no smell\n"}