{"text": "<fim_prefix>/**\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.kerby.kerberos.kerb.gss.impl;\nimport org.apache.kerby.kerberos.kerb.KrbException;\nimport org.apache.kerby.kerberos.kerb.crypto.CheckSumHandler;\nimport org.apache.kerby.kerberos.kerb.crypto.CheckSumTypeHandler;\nimport org.apache.kerby.kerberos.kerb.crypto.EncTypeHandler;\nimport org.apache.kerby.kerberos.kerb.crypto.EncryptionHandler;\nimport org.apache.kerby.kerberos.kerb.crypto.cksum.provider.Md5Provider;\nimport org.apache.kerby.kerberos.kerb.crypto.enc.provider.DesProvider;\nimport org.apache.kerby.kerberos.kerb.crypto.enc.provider.Rc4Provider;\nimport org.apache.kerby.kerberos.kerb.type.base.CheckSumType;\nimport org.apache.kerby.kerberos.kerb.type.base.EncryptionKey;\nimport org.apache.kerby.kerberos.kerb.type.base.EncryptionType;\nimport org.ietf.jgss.GSSException;\nimport javax.crypto.Mac;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\n/**\n * This class implements encryption related function used in GSS tokens\n */\npublic class GssEncryptor {\n    private final EncryptionKey encKey;\n    private final EncryptionType encKeyType; // The following two variables used for convenience\n    private final byte[] encKeyBytes;\n    private CheckSumType checkSumTypeDef;\n    private int checkSumSize;\n    private boolean isV2 = false;\n    private int sgnAlg = 0xFFFF;\n    private int sealAlg = 0xFFFF;\n    private boolean isArcFourHmac = false;\n    private static final byte[] IV_ZEROR_8B = new byte[8];\n    public GssEncryptor(EncryptionKey key) throws GSSException {\n        encKey = key;\n        encKeyBytes = encKey.getKeyData();\n        encKeyType = key.getKeyType();\n        if (encKeyType == EncryptionType.AES128_CTS_HMAC_SHA1_96) {\n            checkSumSize = 12;\n            checkSumTypeDef = CheckSumType.HMAC_SHA1_96_AES128;\n            isV2 = true;\n        } else if (encKeyType == EncryptionType.AES256_CTS_HMAC_SHA1_96) {\n            checkSumSize = 12;\n            checkSumTypeDef = CheckSumType.HMAC_SHA1_96_AES256;\n            isV2 = true;\n        } else if (encKeyType == EncryptionType.DES_CBC_CRC || encKeyType == EncryptionType.DES_CBC_MD5) {\n            sgnAlg = GssTokenV1.SGN_ALG_DES_MAC_MD5;\n            sealAlg = GssTokenV1.SEAL_ALG_DES;\n            checkSumSize = 8;\n        } else if (encKeyType == EncryptionType.DES3_CBC_SHA1) {\n            sgnAlg = GssTokenV1.SGN_ALG_HMAC_SHA1_DES3_KD;\n            sealAlg = GssTokenV1.SEAL_ALG_DES3_KD;\n            checkSumSize = 20;\n        } else if (encKeyType == EncryptionType.ARCFOUR_HMAC) {\n            sgnAlg = GssTokenV1.SGN_ALG_RC4_HMAC;\n            sealAlg = GssTokenV1.SEAL_ALG_RC4_HMAC;\n            checkSumSize = 16;\n            isArcFourHmac = true;\n        } else {\n            throw new GSSException(GSSException.FAILURE, -1,\n                    \"Invalid encryption type: \" + encKeyType.getDisplayName());\n        }\n    }\n    /**\n     * Return true if it is encryption type defined in RFC 4121\n     * @return\n     */\n    public boolean isV2() {\n        return isV2;\n    }\n    public int getSgnAlg() {\n        return sgnAlg;\n    }\n    public int getSealAlg() {\n        return sealAlg;\n    }\n    public boolean isArcFourHmac() {\n        return isArcFourHmac;\n    }\n    public byte[] encryptData(byte[] tokenHeader, byte[] data,\n                              int offset, int len, int keyUsage) throws GSSException {\n        byte[] ret;\n        byte[] toProcess = new byte[tokenHeader.length + len];\n        System.arraycopy(data, offset, toProcess, 0, len);\n        System.arraycopy(tokenHeader, 0, toProcess, len, tokenHeader.length);\n        ret = encryptData(toProcess, keyUsage);\n        return ret;\n    }\n    public byte[] encryptData(byte[] toProcess, int keyUsage) throws GSSException {\n        byte[] ret;\n        try {\n            EncTypeHandler encHandler = EncryptionHandler.getEncHandler(encKey.getKeyType());\n            ret = encHandler.encrypt(toProcess, encKey.getKeyData(), keyUsage);\n        } catch (KrbException e) {\n            throw new GSSException(GSSException.FAILURE, -1, e.getMessage());\n        }\n        return ret;\n    }\n<fim_suffix>    public byte[] decryptData(byte[] dataEncrypted, int keyUsage) throws GSSException {\n        byte[] ret;\n        try {\n            EncTypeHandler encHandler = EncryptionHandler.getEncHandler(encKey.getKeyType());\n            ret = encHandler.decrypt(dataEncrypted, encKey.getKeyData(), keyUsage);\n        } catch (KrbException e) {\n            throw new GSSException(GSSException.FAILURE, -1, e.getMessage());\n        }\n        return ret;\n    }\n    public byte[] calculateCheckSum(byte[] header, byte[] data, int offset, int len, int keyUsage)\n            throws GSSException {\n        int totalLen = len + (header == null ? 0 : header.length);\n        byte[] buffer = new byte[totalLen];\n        System.arraycopy(data, offset, buffer, 0, len);\n        if (header != null) {\n            System.arraycopy(header, 0, buffer, len, header.length);\n        }\n        try {\n            return CheckSumHandler.getCheckSumHandler(checkSumTypeDef)\n                    .checksumWithKey(buffer, encKey.getKeyData(), keyUsage);\n        } catch (KrbException e) {\n            throw new GSSException(GSSException.FAILURE, -1,\n                    \"Exception in checksum calculation:\" + e.getMessage());\n        }\n    }\n    /**\n     * Get the size of the corresponding checksum algorithm\n     * @return\n     * @throws GSSException\n     */\n    public int getCheckSumSize() throws GSSException {\n        return checkSumSize;\n    }\n    private void addPadding(int paddingLen, byte[] outBuf, int offset) {\n        for (int i = 0; i < paddingLen; i++) {\n            outBuf[offset + i] = (byte) paddingLen;\n        }\n    }\n    private byte[] getFirstBytes(byte[] src, int len) {\n        if (len < src.length) {\n            byte[] ret = new byte[len];\n            System.arraycopy(src, 0, ret, 0, len);\n            return ret;\n        }\n        return src;\n    }\n    private byte[] getKeyBytesWithLength(int len) {\n        return getFirstBytes(encKeyBytes, len);\n    }\n    public byte[] calculateCheckSum(byte[] confounder, byte[] header,\n                                    byte[] data, int offset, int len, int paddingLen, boolean isMic)\n            throws GSSException {\n        byte[] ret;\n        int keyUsage = GssTokenV1.KG_USAGE_SIGN;\n        CheckSumTypeHandler handler;\n        int keySize;\n        byte[] key;\n        byte[] toProc;\n        int toOffset;\n        int toLen = (confounder == null ? 0 : confounder.length)\n                + (header == null ? 0 : header.length) + len + paddingLen;\n        if (toLen == len) {\n            toProc = data;<fim_middle>// function below has no smell\n"}