{"text": "<fim_prefix>/*\n * Copyright 2018-present Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License. You may obtain\n * a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage com.facebook.buck.rules.modern;\nimport com.facebook.buck.core.model.BuildTarget;\nimport com.facebook.buck.core.model.EmptyTargetConfiguration;\nimport com.facebook.buck.core.model.TargetConfiguration;\nimport com.facebook.buck.core.rulekey.AddsToRuleKey;\nimport com.facebook.buck.core.rules.modern.annotations.CustomClassBehaviorTag;\nimport com.facebook.buck.core.rules.modern.annotations.CustomFieldBehavior;\nimport com.facebook.buck.core.rules.modern.annotations.DefaultFieldSerialization;\nimport com.facebook.buck.core.sourcepath.ExplicitBuildTargetSourcePath;\nimport com.facebook.buck.core.sourcepath.PathSourcePath;\nimport com.facebook.buck.core.sourcepath.SourcePath;\nimport com.facebook.buck.core.sourcepath.resolver.SourcePathResolver;\nimport com.facebook.buck.core.toolchain.ToolchainProvider;\nimport com.facebook.buck.io.filesystem.ProjectFilesystem;\nimport com.facebook.buck.rules.modern.impl.DefaultClassInfoFactory;\nimport com.facebook.buck.rules.modern.impl.ValueTypeInfoFactory;\nimport com.facebook.buck.util.exceptions.BuckUncheckedExecutionException;\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Throwables;\nimport com.google.common.collect.ImmutableCollection;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.ImmutableSortedMap;\nimport com.google.common.collect.ImmutableSortedSet;\nimport com.google.common.hash.HashCode;\nimport com.google.common.io.ByteStreams;\nimport com.google.common.reflect.TypeToken;\nimport java.io.ByteArrayInputStream;\nimport java.io.DataInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.lang.reflect.Field;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\nimport javax.annotation.Nullable;\nimport org.objenesis.ObjenesisStd;\nimport org.objenesis.instantiator.ObjectInstantiator;\n/**\n * Implements deserialization of Buildables.\n *\n * <p>This works by walking all referenced fields and creating them with a ValueCreator. It uses\n * Objenesis to create objects and then injects the field values via reflection.\n */\npublic class Deserializer {\n  private ObjenesisStd objenesis = new ObjenesisStd();\n  private Map<Class<?>, ObjectInstantiator> instantiators = new ConcurrentHashMap<>();\n  private Map<HashCode, AddsToRuleKey> childCache = new ConcurrentHashMap<>();\n  /**\n   * DataProviders are used for deserializing \"dynamic\" objects. These are serialized as hashcodes\n   * and the DataProvider is expected to map those back to the corresponding serialized\n   * representation.\n   */\n  public interface DataProvider {\n    InputStream getData();\n    DataProvider getChild(HashCode hash);\n  }\n  /**\n   * Used for looking up classes. It's not necessarily the case that every serialized class is\n   * loadable from Deserializer's ClassLoader.\n   */\n  public interface ClassFinder {\n    Class<?> find(String name) throws ClassNotFoundException;\n  }\n  private final Function<Optional<String>, ProjectFilesystem> cellMap;\n  private final ClassFinder classFinder;\n  private final Supplier<SourcePathResolver> pathResolver;\n  private final ToolchainProvider toolchainProvider;\n  public Deserializer(\n      Function<Optional<String>, ProjectFilesystem> cellMap,\n      ClassFinder classFinder,\n      Supplier<SourcePathResolver> pathResolver,\n      ToolchainProvider toolchainProvider) {\n    this.cellMap = cellMap;\n    this.classFinder = classFinder;\n    this.pathResolver = pathResolver;\n    this.toolchainProvider = toolchainProvider;\n  }\n  public <T extends AddsToRuleKey> T deserialize(DataProvider provider, Class<T> clazz)\n      throws IOException {\n    try (DataInputStream stream = new DataInputStream(provider.getData())) {\n      return new Creator(provider, stream).create(clazz);\n    }\n  }\n  private class Creator implements ValueCreator<IOException> {\n    private final DataInputStream stream;\n    private final DataProvider provider;\n    private Creator(DataProvider provider, DataInputStream stream) {\n      this.stream = stream;\n      this.provider = provider;\n    }\n    @Override\n    public <T> T createSpecial(Class<T> valueClass, Object... args) {\n      if (valueClass.equals(SourcePathResolver.class)) {\n        Preconditions.checkState(args.length == 0);\n        @SuppressWarnings(\"unchecked\")\n        T value = (T) pathResolver.get();\n        return value;\n      } else if (valueClass.equals(ToolchainProvider.class)) {\n        @SuppressWarnings(\"unchecked\")\n        T value = (T) toolchainProvider;\n        return value;\n      }\n      throw new IllegalArgumentException();\n    }\n    @Override\n    public AddsToRuleKey createDynamic() throws IOException {\n      DataProvider childProvider;\n      if (stream.readBoolean()) {\n        HashCode hash = HashCode.fromBytes(readBytes());\n        if (childCache.containsKey(hash)) {\n          return childCache.get(hash);\n        }\n        childProvider = provider.getChild(hash);\n        AddsToRuleKey child = deserialize(childProvider, AddsToRuleKey.class);\n        return childCache.computeIfAbsent(hash, ignored -> child);\n      } else {\n        byte[] data = readBytes();\n        return deserialize(\n            new DataProvider() {\n              @Override\n              public InputStream getData() {\n                return new ByteArrayInputStream(data);\n              }\n              @Override\n              public DataProvider getChild(HashCode hash) {\n                throw new IllegalStateException();\n              }\n            },\n            AddsToRuleKey.class);\n      }\n    }\n    @Override\n    public <T> ImmutableList<T> createList(ValueTypeInfo<T> innerType) throws IOException {\n      int size = stream.readInt();\n      ImmutableList.Builder<T> builder = ImmutableList.builderWithExpectedSize(size);\n      for (int i = 0; i < size; i++) {\n        builder.add(innerType.createNotNull(this));\n      }\n      return builder.build();\n    }\n    @Override\n    public <T> ImmutableSet<T> createSet(ValueTypeInfo<T> innerType) throws IOException {\n      int size = stream.readInt();\n      ImmutableSet.Builder<T> builder = ImmutableSet.builderWithExpectedSize(size);\n      for (int i = 0; i < size; i++) {\n        builder.add(innerType.createNotNull(this));\n      }\n      return builder.build();\n    }\n    @Override\n    public <T> ImmutableSortedSet<T> createSortedSet(ValueTypeInfo<T> innerType)\n        throws IOException {\n      int size = stream.readInt();\n      @SuppressWarnings(\"unchecked\")\n      ImmutableSortedSet.Builder<T> builder =\n          (ImmutableSortedSet.Builder<T>) ImmutableSortedSet.naturalOrder();\n      for (int i = 0; i < size; i++) {\n        builder.add(innerType.createNotNull(this));\n      }\n      return builder.build();\n    }\n<fim_suffix>    @Override\n    public <T> Optional<T> createOptional(ValueTypeInfo<T> innerType) throws IOException {\n      if (stream.readBoolean()) {\n        return Optional.of(innerType.createNotNull(this));\n      }\n      return Optional.empty();\n    }\n    @Override\n    @Nullable\n    public <T> T createNullable(ValueTypeInfo<T> innerType) throws IOException {\n      if (stream.readBoolean()) {\n        return innerType.create(this);\n      }\n      return null;\n    }\n    @Override\n    public OutputPath createOutputPath() throws IOException {\n      boolean isPublic = stream.readBoolean();\n      String path = stream.readUTF();\n      return isPublic ? new PublicOutputPath(Paths.get(path)) : new OutputPath(path);\n    }\n    @Override\n    public SourcePath createSourcePath() throws IOException {\n      if (stream.readBoolean()) {\n        BuildTarget target = readValue(new TypeToken<BuildTarget>() {});\n        Path path = Paths.get(stream.readUTF());<fim_middle>// function below has no smell\n"}