{"text": "<fim_prefix>import org.apache.cassandra.utils.FBUtilities;\nimport org.apache.cassandra.utils.Pair;\n/**\n * Encapsulate handling of paths to the data files.\n *\n * <pre> {@code\n *   /<path_to_data_dir>/ks/<cf dir>/ks-cf1-jb-1-Data.db\n *                         /<cf dir>/la-2-Data.db\n *                         /<cf dir>/.<index name>/ks-cf1.idx-jb-1-Data.db\n *                         /<cf dir>/.<index name>/la-1-Data.db\n *                         ...\n * } </pre>\n *\n * Until v2.0, {@code <cf dir>} is just column family name.\n * Since v2.1, {@code <cf dir>} has column family ID(tableId) added to its end.\n *\n * SSTables from secondary indexes were put in the same directory as their parent.\n * Since v2.2, they have their own directory under the parent directory whose name is index name.\n * Upon startup, those secondary index files are moved to new directory when upgrading.\n *\n * For backward compatibility, Directories can use directory without tableId if exists.\n *\n * In addition, more that one 'root' data directory can be specified so that\n * {@code <path_to_data_dir>} potentially represents multiple locations.\n * Note that in the case of multiple locations, the manifest for the leveled\n * compaction is only in one of the location.\n *\n * Snapshots (resp. backups) are always created along the sstables there are\n * snapshotted (resp. backuped) but inside a subdirectory named 'snapshots'\n * (resp. backups) (and snapshots are further inside a subdirectory of the name\n * of the snapshot). For secondary indexes, snapshots (backups) are not created in\n * their own directory, but are in their parent's snapshot (backup) directory.\n *\n * This class abstracts all those details from the rest of the code.\n */\npublic class Directories\n{\n    private static final Logger logger = LoggerFactory.getLogger(Directories.class);\n    public static final String BACKUPS_SUBDIR = \"backups\";\n    public static final String SNAPSHOT_SUBDIR = \"snapshots\";\n    public static final String TMP_SUBDIR = \"tmp\";\n    public static final String SECONDARY_INDEX_NAME_SEPARATOR = \".\";\n    public static final DataDirectory[] dataDirectories;\n    static\n    {\n        String[] locations = DatabaseDescriptor.getAllDataFileLocations();\n        dataDirectories = new DataDirectory[locations.length];\n        for (int i = 0; i < locations.length; ++i)\n            dataDirectories[i] = new DataDirectory(new File(locations[i]));\n    }\n    /**\n     * Checks whether Cassandra has RWX permissions to the specified directory.  Logs an error with\n     * the details if it does not.\n     *\n     * @param dir File object of the directory.\n     * @param dataDir String representation of the directory's location\n     * @return status representing Cassandra's RWX permissions to the supplied folder location.\n     */\n    public static boolean verifyFullPermissions(File dir, String dataDir)\n    {\n        if (!dir.isDirectory())\n        {\n            logger.error(\"Not a directory {}\", dataDir);\n            return false;\n        }\n        else if (!FileAction.hasPrivilege(dir, FileAction.X))\n        {\n            logger.error(\"Doesn't have execute permissions for {} directory\", dataDir);\n            return false;\n        }\n        else if (!FileAction.hasPrivilege(dir, FileAction.R))\n        {\n            logger.error(\"Doesn't have read permissions for {} directory\", dataDir);\n            return false;\n        }\n        else if (dir.exists() && !FileAction.hasPrivilege(dir, FileAction.W))\n        {\n            logger.error(\"Doesn't have write permissions for {} directory\", dataDir);\n            return false;\n        }\n        return true;\n    }\n    public enum FileAction\n    {\n        X, W, XW, R, XR, RW, XRW;\n        FileAction()\n        {\n        }\n        public static boolean hasPrivilege(File file, FileAction action)\n        {\n            boolean privilege = false;\n            switch (action)\n            {\n                case X:\n                    privilege = file.canExecute();\n                    break;\n                case W:\n                    privilege = file.canWrite();\n                    break;\n                case XW:\n                    privilege = file.canExecute() && file.canWrite();\n                    break;\n                case R:\n                    privilege = file.canRead();\n                    break;\n                case XR:\n                    privilege = file.canExecute() && file.canRead();\n                    break;\n                case RW:\n                    privilege = file.canRead() && file.canWrite();\n                    break;\n                case XRW:\n                    privilege = file.canExecute() && file.canRead() && file.canWrite();\n                    break;\n            }\n            return privilege;\n        }\n    }\n    private final TableMetadata metadata;\n    private final DataDirectory[] paths;\n    private final File[] dataPaths;\n    public Directories(final TableMetadata metadata)\n    {\n        this(metadata, dataDirectories);\n    }\n    public Directories(final TableMetadata metadata, Collection<DataDirectory> paths)\n    {\n        this(metadata, paths.toArray(new DataDirectory[paths.size()]));\n    }\n    /**\n     * Create Directories of given ColumnFamily.\n     * SSTable directories are created under data_directories defined in cassandra.yaml if not exist at this time.\n     *\n     * @param metadata metadata of ColumnFamily\n     */\n    public Directories(final TableMetadata metadata, DataDirectory[] paths)\n    {\n        this.metadata = metadata;\n        this.paths = paths;\n        String tableId = metadata.id.toHexString();\n        int idx = metadata.name.indexOf(SECONDARY_INDEX_NAME_SEPARATOR);\n        String cfName = idx >= 0 ? metadata.name.substring(0, idx) : metadata.name;\n        String indexNameWithDot = idx >= 0 ? metadata.name.substring(idx) : null;\n        this.dataPaths = new File[paths.length];\n        // If upgraded from version less than 2.1, use existing directories\n        String oldSSTableRelativePath = join(metadata.keyspace, cfName);\n        for (int i = 0; i < paths.length; ++i)\n        {\n            // check if old SSTable directory exists\n            dataPaths[i] = new File(paths[i].location, oldSSTableRelativePath);\n        }\n        boolean olderDirectoryExists = Iterables.any(Arrays.asList(dataPaths), File::exists);\n        if (!olderDirectoryExists)\n        {\n            // use 2.1+ style\n            String newSSTableRelativePath = join(metadata.keyspace, cfName + '-' + tableId);\n            for (int i = 0; i < paths.length; ++i)\n                dataPaths[i] = new File(paths[i].location, newSSTableRelativePath);\n        }\n        // if index, then move to its own directory\n        if (indexNameWithDot != null)\n        {\n            for (int i = 0; i < paths.length; ++i)\n                dataPaths[i] = new File(dataPaths[i], indexNameWithDot);\n        }\n        for (File dir : dataPaths)\n        {\n            try\n            {\n                FileUtils.createDirectory(dir);\n            }\n            catch (FSError e)\n            {\n                // don't just let the default exception handler do this, we need the create loop to continue\n                logger.error(\"Failed to create {} directory\", dir);\n                FileUtils.handleFSError(e);\n            }\n        }\n        // if index, move existing older versioned SSTable files to new directory\n        if (indexNameWithDot != null)\n        {\n            for (File dataPath : dataPaths)\n            {\n                File[] indexFiles = dataPath.getParentFile().listFiles(new FileFilter()\n                {\n                    @Override\n                    public boolean accept(File file)\n                    {\n                        if (file.isDirectory())\n                            return false;\n                        Descriptor desc = SSTable.tryDescriptorFromFilename(file);\n                        return desc != null && desc.ksname.equals(metadata.keyspace) && desc.cfname.equals(metadata.name);\n                    }\n                });\n                for (File indexFile : indexFiles)\n                {\n                    File destFile = new File(dataPath, indexFile.getName());\n                    logger.trace(\"Moving index file {} to {}\", indexFile, destFile);\n                    FileUtils.renameWithConfirm(indexFile, destFile);\n                }\n            }\n        }\n    }\n    /**\n     * Returns SSTable location which is inside given data directory.\n     *\n     * @param dataDirectory\n     * @return SSTable location\n     */\n<fim_suffix>    public File getLocationForDisk(DataDirectory dataDirectory)\n    {\n        if (dataDirectory != null)\n            for (File dir : dataPaths)\n                if (dir.getAbsolutePath().startsWith(dataDirectory.location.getAbsolutePath()))\n                    return dir;\n        return null;\n    }<fim_middle>// function below has no smell\n"}