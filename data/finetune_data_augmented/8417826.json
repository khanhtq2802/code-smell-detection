{"text": "<fim_prefix>\n<fim_suffix>@UriEndpoint(firstVersion = \"1.0\", scheme = \"xmpp\", title = \"XMPP\", syntax = \"xmpp:host:port/participant\", alternativeSyntax = \"xmpp:user:password@host:port/participant\",\n        label = \"chat,messaging\")\npublic class XmppEndpoint extends DefaultEndpoint implements HeaderFilterStrategyAware {\n    private volatile XMPPTCPConnection connection;\n    private XmppBinding binding;\n    @UriPath @Metadata(required = true)\n    private String host;\n    @UriPath @Metadata(required = true)\n    private int port;\n    @UriPath(label = \"common\")\n    private String participant;\n    @UriParam(label = \"security\", secret = true)\n    private String user;\n    @UriParam(label = \"security\", secret = true)\n    private String password;\n    @UriParam(label = \"common,advanced\", defaultValue = \"Camel\")\n    private String resource = \"Camel\";\n    @UriParam(label = \"common\", defaultValue = \"true\")\n    private boolean login = true;\n    @UriParam(label = \"common,advanced\")\n    private boolean createAccount;\n    @UriParam(label = \"common\")\n    private String room;\n    @UriParam(label = \"common\")\n    private String nickname;\n    @UriParam(label = \"common\")\n    private String serviceName;\n    @UriParam(label = \"common\")\n    private boolean pubsub;\n    @UriParam(label = \"consumer\")\n    private boolean doc;\n    @UriParam(label = \"common\", defaultValue = \"true\")\n    private boolean testConnectionOnStartup = true;\n    @UriParam(label = \"consumer\", defaultValue = \"10\")\n    private int connectionPollDelay = 10;\n    @UriParam(label = \"filter\")\n    private HeaderFilterStrategy headerFilterStrategy = new DefaultHeaderFilterStrategy();\n    @UriParam(label = \"advanced\")\n    private ConnectionConfiguration connectionConfig;\n    public XmppEndpoint() {\n    }\n    public XmppEndpoint(String uri, XmppComponent component) {\n        super(uri, component);\n    }\n    public Producer createProducer() throws Exception {\n        if (room != null) {\n            return createGroupChatProducer();\n        } else {\n            if (isPubsub()) {\n                return createPubSubProducer();\n            }\n            if (isDoc()) {\n                return createDirectProducer();\n            }\n            if (getParticipant() == null) {\n                throw new IllegalArgumentException(\"No room or participant configured on this endpoint: \" + this);\n            }\n            return createPrivateChatProducer(getParticipant());\n        }\n    }\n    public Producer createGroupChatProducer() throws Exception {\n        return new XmppGroupChatProducer(this);\n    }\n    public Producer createPrivateChatProducer(String participant) throws Exception {\n        return new XmppPrivateChatProducer(this, participant);\n    }\n    public Producer createDirectProducer() throws Exception {\n        return new XmppDirectProducer(this);\n    }\n    public Producer createPubSubProducer() throws Exception {\n        return new XmppPubSubProducer(this);\n    }\n    public Consumer createConsumer(Processor processor) throws Exception {\n        XmppConsumer answer = new XmppConsumer(this, processor);\n        configureConsumer(answer);\n        return answer;\n    }\n    public Exchange createExchange(Stanza packet) {\n        Exchange exchange = super.createExchange();\n        exchange.setProperty(Exchange.BINDING, getBinding());\n        exchange.setIn(new XmppMessage(exchange, packet));\n        return exchange;\n    }\n    @Override\n    protected String createEndpointUri() {\n        return \"xmpp://\" + host + \":\" + port + \"/\" + getParticipant() + \"?serviceName=\" + serviceName;\n    }\n    public boolean isSingleton() {\n        return true;\n    }\n    public synchronized XMPPTCPConnection createConnection() throws InterruptedException, IOException, SmackException, XMPPException {\n        if (connection != null && connection.isConnected()) {\n            // use existing working connection\n            return connection;\n        }\n        // prepare for creating new connection\n        connection = null;\n        log.trace(\"Creating new connection ...\");\n        XMPPTCPConnection newConnection = createConnectionInternal();\n        newConnection.connect();\n        newConnection.addSyncStanzaListener(new XmppLogger(\"INBOUND\"), stanza -> true);\n        newConnection.addSyncStanzaListener(new XmppLogger(\"OUTBOUND\"), stanza -> true);\n        if (!newConnection.isAuthenticated()) {\n            if (user != null) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Logging in to XMPP as user: {} on connection: {}\", user, getConnectionMessage(newConnection));\n                }\n                if (password == null) {\n                    log.warn(\"No password configured for user: {} on connection: {}\", user, getConnectionMessage(newConnection));\n                }\n                if (createAccount) {\n                    AccountManager accountManager = AccountManager.getInstance(newConnection);\n                    accountManager.createAccount(Localpart.from(user), password);\n                }\n                if (login) {\n                    if (resource != null) {\n                        newConnection.login(user, password, Resourcepart.from(resource));\n                    } else {\n                        newConnection.login(user, password);\n                    }\n                }\n            } else {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Logging in anonymously to XMPP on connection: {}\", getConnectionMessage(newConnection));\n                }\n                newConnection.login();\n            }\n            // presence is not needed to be sent after login\n        }\n        // okay new connection was created successfully so assign it as the connection\n        log.debug(\"Created new connection successfully: {}\", newConnection);\n        connection = newConnection;\n        return connection;\n    }\n    private XMPPTCPConnection createConnectionInternal() throws UnknownHostException, XmppStringprepException {\n        if (connectionConfig != null) {\n            return new XMPPTCPConnection(ObjectHelper.cast(XMPPTCPConnectionConfiguration.class, connectionConfig));\n        }\n        if (port == 0) {\n            port = 5222;\n        }\n        String sName = getServiceName() == null ? host : getServiceName();\n        XMPPTCPConnectionConfiguration conf = XMPPTCPConnectionConfiguration.builder()\n                .setHostAddress(InetAddress.getByName(host))\n                .setPort(port)\n                .setXmppDomain(sName)\n                .build();\n        return new XMPPTCPConnection(conf);\n    }\n    /*\n     * If there is no \"@\" symbol in the room, find the chat service JID and\n     * return fully qualified JID for the room as room@conference.server.domain\n     */\n    public String resolveRoom(XMPPConnection connection) throws InterruptedException, SmackException, XMPPException  {\n        StringHelper.notEmpty(room, \"room\");\n        if (room.indexOf('@', 0) != -1) {\n            return room;\n        }\n        MultiUserChatManager multiUserChatManager = MultiUserChatManager.getInstanceFor(connection);\n        List<DomainBareJid> xmppServiceDomains = multiUserChatManager.getXMPPServiceDomains();\n        if (xmppServiceDomains.isEmpty()) {\n            throw new XMPPErrorException(null,\n                    StanzaError.from(Condition.item_not_found, \"Cannot find any XMPPServiceDomain by MultiUserChatManager on connection: \" + getConnectionMessage(connection)).build());\n        }\n        return room + \"@\" + xmppServiceDomains.iterator().next();\n    }\n    public String getConnectionDescription() {\n        return host + \":\" + port + \"/\" + serviceName;\n    }\n    public static String getConnectionMessage(XMPPConnection connection) {\n        return connection.getHost() + \":\" + connection.getPort() + \"/\" + connection.getXMPPServiceDomain();\n    }\n    public String getChatId() {\n        return \"Chat:\" + getParticipant() + \":\" + getUser();\n    }\n    // Properties\n    // -------------------------------------------------------------------------\n    public XmppBinding getBinding() {\n        if (binding == null) {\n            binding = new XmppBinding(headerFilterStrategy);\n        }\n        return binding;\n    }\n    /**\n     * Sets the binding used to convert from a Camel message to and from an XMPP\n     * message\n     */\n    public void setBinding(XmppBinding binding) {\n        this.binding = binding;\n    }\n    public String getHost() {\n        return host;\n    }\n    /**\n     * Hostname for the chat server\n     */\n    public void setHost(String host) {\n        this.host = host;\n    }\n    public int getPort() {\n        return port;\n    }\n    /**\n     * Port number for the chat server\n     */\n    public void setPort(int port) {\n        this.port = port;\n    }\n    public String getUser() {\n        return user;\n    }\n    /**\n     * User name (without server name). If not specified, anonymous login will be attempted.\n     */\n    public void setUser(String user) {\n        this.user = user;\n    }\n    public String getPassword() {\n        return password;\n    }\n    /**\n     * Password for login\n     */\n    public void setPassword(String password) {\n        this.password = password;\n    }\n    public String getResource() {\n        return resource;\n    }\n    /**<fim_middle>// class below has no smell\n"}