{"text": "<fim_prefix>     * of previous Derby releases with the master repository at Apache.\n     *\n     * @see ReleaseRepository\n     */\n    public static synchronized ReleaseRepository getReleaseRepository() {\n        if (releaseRepository == null) {\n            try {\n                releaseRepository = ReleaseRepository.getInstance();\n            } catch (IOException ioe) {\n                BaseTestCase.printStackTrace(ioe);\n                Assert.fail(\"failed to initialize the release repository: \" +\n                        ioe.getMessage());\n            }\n        }\n        return releaseRepository;\n    }\n    /**\n     * WORK IN PROGRESS\n     * Set this Thread's current configuration for running tests.\n     * @param config Configuration to set it to.\n     */\n    static void setCurrent(TestConfiguration config)\n    {\n        CURRENT_CONFIG.set(config);\n    }\n    /**\n     * Return a Test suite that contains all the test fixtures\n     * for the passed in class running in embedded and the\n     * default client server configuration.\n     * <BR>\n     * Each set of embedded and set of client server tests\n     * is decorated with a CleanDatabaseTestSetup.\n     * <BR>\n     * The client server configuration is setup using clientServerSuite\n     */\n    public static Test defaultSuite(Class testClass)\n    {\n        return defaultSuite(testClass, true);\n    }\n    /**\n     * Does the work of \"defaultSuite\" as defined above.  Takes\n     * a boolean argument to determine whether or not to \"clean\"\n     * the test database before each suite.  If the resultant\n     * suite is going to be wrapped inside a TestSetup that creates\n     * database objects to be used throughout the tests, then the\n     * cleanDB parameter should be \"false\" to prevent cleanup of the\n     * database objects that TestSetup created.  For example, see\n     * XMLBindingTest.suite().\n     */\n    public static Test defaultSuite(Class testClass, boolean cleanDB)\n    {\n         final BaseTestSuite suite = new BaseTestSuite(suiteName(testClass));\n        if (cleanDB)\n        {\n            suite.addTest(new CleanDatabaseTestSetup(embeddedSuite(testClass)));\n            suite.addTest(new CleanDatabaseTestSetup(clientServerSuite(testClass)));\n        }\n        else\n        {\n            suite.addTest(embeddedSuite(testClass));\n            suite.addTest(clientServerSuite(testClass));\n        }\n        return (suite);\n    }\n    /**\n     * Equivalent to \"defaultSuite\" as defined above, but assumes a server\n     * has already been started. \n     * <BR>\n     * Does NOT decorate for running in embedded mode, only for running on\n     * the already started server.\n     * <BR>\n     * Return a Test suite that contains all the test fixtures\n     * for the passed in class running in client server configuration\n     * on an already started server.\n     * <BR>\n     * The set of client server tests\n     * is decorated with a CleanDatabaseTestSetup.\n     * <BR>\n     * The client server configuration is setup using clientExistingServerSuite\n     */\n    public static Test defaultExistingServerSuite(Class testClass)\n    {\n        return defaultExistingServerSuite(testClass, true);\n    }\n    /**\n     * Does the work of \"defaultExistingServerSuite\" as defined above.  Takes\n     * a boolean argument to determine whether or not to \"clean\"\n     * the test database before each suite.  If the resultant\n     * suite is going to be wrapped inside a TestSetup that creates\n     * database objects to be used throughout the tests, then the\n     * cleanDB parameter should be \"false\" to prevent cleanup of the\n     * database objects that TestSetup created.\n     * <BR>\n     * Does NOT decorate for running in embedded mode, only for running on\n     * an already started server.\n     */\n    public static Test defaultExistingServerSuite(Class testClass, boolean cleanDB)\n    {\n         final BaseTestSuite suite = new BaseTestSuite(suiteName(testClass));\n        if (cleanDB)\n        {\n            suite.addTest(new CleanDatabaseTestSetup(clientExistingServerSuite(testClass)));\n        }\n        else\n        {\n            suite.addTest(clientExistingServerSuite(testClass));\n        }\n        return (suite);\n    }\n    /**\n     * Return a Test suite that contains all the test fixtures\n     * for the passed in class running in client server configuration\n     * on an already started server on a given host and port number.\n     * <BR>\n     * Takes a boolean argument to determine whether or not to \"clean\"\n     * the test database before each suite.  If the resultant\n     * suite is going to be wrapped inside a TestSetup that creates\n     * database objects to be used throughout the tests, then the\n     * cleanDB parameter should be \"false\" to prevent cleanup of the\n     * database objects that TestSetup created.\n     * <BR>\n     * Takes a String argument to specify which host the server runs on, and\n     * takes an int argument to specify the port number to use.\n     * <BR>\n     * Does NOT decorate for running in embedded mode, only for running on\n     * an already started server.\n     * <BR>\n     * The set of client server tests\n     * is decorated with a CleanDatabaseTestSetup.\n     * <BR>\n     * The client server configuration is setup using clientExistingServerSuite\n     */\n    public static Test existingServerSuite(Class testClass, \n            boolean cleanDB,\n            String hostName,\n            int portNumber)\n    {\n         final BaseTestSuite suite = new BaseTestSuite(suiteName(testClass));\n        if (cleanDB)\n        {\n            suite.addTest(new CleanDatabaseTestSetup(\n                    clientExistingServerSuite(testClass, hostName, portNumber)));\n        }\n        else\n        {\n            suite.addTest(clientExistingServerSuite(testClass, hostName, portNumber));\n        }\n        return (suite);\n    }\n    public static Test existingServerSuite(Class testClass, \n            boolean cleanDB,\n            String hostName,\n            int portNumber,\n            String dbPath)\n    {\n         final BaseTestSuite suite = new BaseTestSuite(suiteName(testClass));\n        if (cleanDB)\n        {\n            suite.addTest(new CleanDatabaseTestSetup(\n                    clientExistingServerSuite(testClass, hostName, portNumber, dbPath)));\n        }\n        else\n        {\n            suite.addTest(clientExistingServerSuite(testClass, hostName, portNumber, dbPath));\n        }\n        return (suite);\n    }\n    /**\n     * Return a Test suite that contains all the test fixtures\n     * for the passed in class running in embedded and client-\n     * server *JDBC3* configurations.\n     * <BR>\n     * Each set of embedded and set of client server tests is\n     * decorated with a CleanDatabaseTestSetup.\n     * <BR>\n     */\n    public static Test forceJDBC3Suite(Class testClass)\n    {\n        final BaseTestSuite suite = new BaseTestSuite(suiteName(testClass));\n        suite.addTest(\n            new CleanDatabaseTestSetup(\n                forceJDBC3Embedded(embeddedSuite(testClass))));\n        suite.addTest(\n            new CleanDatabaseTestSetup(\n                forceJDBC3NetClient(clientServerSuite(testClass))));\n        return (suite);\n    }\n    /**\n     * Generate a suite name from a class name, taking\n     * only the last element of the fully qualified class name.\n     */\n    static String suiteName(Class testClass)\n    {\n        int lastDot = testClass.getName().lastIndexOf('.');\n        String suiteName = testClass.getName();\n        if (lastDot != -1)\n            suiteName = suiteName.substring(lastDot + 1, suiteName.length());\n        return suiteName;\n    }\n    /**\n     * Create a suite for the passed test class that includes\n     * all the default fixtures from the class.\n      */\n    public static Test embeddedSuite(Class testClass)\n    {\n        return new BaseTestSuite(testClass,\n                suiteName(testClass)+\":embedded\");\n    }\n    /**\n     * Create a suite for the passed test class that includes\n     * all the default fixtures from the class, wrapped in\n     * a derbyClientServerDecorator.\n     * \n     */\n    public static Test clientServerSuite(Class testClass)\n    {\n        return clientServerDecorator(bareClientServerSuite(testClass));\n    }\n    /**\n     * Create a suite for the passed test class that includes\n     * all the default fixtures from the class, wrapped in\n     * a derbyClientServerDecorator with alternative port.\n     * \n     */\n    public static Test clientServerSuiteWithAlternativePort(Class testClass) {\n        return clientServerDecoratorWithAlternativePort(\n                bareClientServerSuite(testClass));\n    }\n    /**\n     * Equivalent to 'clientServerSuite' above, but assumes server is\n     * already running.\n     *\n     */\n    public static Test clientExistingServerSuite(Class testClass)\n    {\n        // Will not start server and does not stop it when done.\n        return defaultExistingServerDecorator(bareClientServerSuite(testClass));\n    }\n    /**\n     * Create a suite for the passed test class that includes\n     * all the default fixtures from the class, wrapped in\n     * a existingServerDecorator.\n     * <BR>\n     * Equivalent to 'clientServerSuite' above, but assumes server is\n     * already running. Will also NOT shut down the server.\n     *\n     */\n<fim_suffix>    public static Test clientExistingServerSuite(Class testClass, String hostName, int portNumber)\n    {\n               // Will not start server and does not stop it when done!.\n        return existingServerDecorator(bareClientServerSuite(testClass),\n                hostName, portNumber);\n    }<fim_middle>// function below has no smell\n"}