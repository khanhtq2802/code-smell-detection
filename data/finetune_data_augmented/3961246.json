{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n * <p>\n * http://www.apache.org/licenses/LICENSE-2.0\n * <p>\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.atlas.repository.graphdb.janus.migration;\n\nimport org.apache.tinkerpop.shaded.jackson.databind.JsonNode;\nimport org.apache.atlas.repository.graphdb.janus.migration.pc.WorkItemBuilder;\nimport org.apache.atlas.repository.graphdb.janus.migration.pc.WorkItemConsumer;\nimport org.apache.atlas.repository.graphdb.janus.migration.JsonNodeParsers.ParseElement;\nimport org.apache.tinkerpop.gremlin.structure.Graph;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.concurrent.BlockingQueue;\n\npublic class JsonNodeProcessManager {\n    private static class Consumer extends WorkItemConsumer<JsonNode> {\n        private static final Logger LOG = LoggerFactory.getLogger(Consumer.class);\n\n        private static final int WAIT_DURATION_AFTER_COMMIT_EXCEPTION = 1000;\n\n        private   final Graph              graph;\n        protected final Graph              bulkLoadGraph;\n        protected final ParseElement       parseElement;\n        private   final long               batchSize;\n        private         long               counter;\n        private   final MappedElementCache cache;\n        private   final List<JsonNode>     nodes = new ArrayList<>();\n\n        public Consumer(BlockingQueue<JsonNode> workQueue, Graph graph, Graph bulkLoadGraph, ParseElement parseElement, long batchSize) {\n            super(workQueue);\n\n            this.graph         = graph;\n            this.bulkLoadGraph = bulkLoadGraph;\n            this.parseElement  = parseElement;\n            this.batchSize     = batchSize;\n            this.counter       = 0;\n            this.cache         = new MappedElementCache();\n        }\n\n        @Override\n        public void processItem(JsonNode node) {\n            try {\n                Map<String, Object> result = parseElement.parse(bulkLoadGraph, cache, node);\n\n                if (result == null) {\n                    nodes.add(node);\n                    commitConditionally(counter++);\n                } else {\n                    commitBulk();\n                    cache.clearAll();\n                    updateSchema(result, node);\n                }\n            } catch (Exception ex) {\n                bulkLoadGraph.tx().rollback();\n                error(\"Failed! Retrying...\", ex);\n                retryBatchCommit();\n            }\n        }\n\n        @Override\n        protected void commitDirty() {\n            super.commitDirty();\n            cache.clearAll();\n        }\n\n        @Override\n        protected void doCommit() {\n            commitBulk();\n        }\n\n        private void commitConditionally(long index) {\n            if (index % batchSize == 0 && nodes.size() > 0) {\n                commitBulk();\n            }\n        }\n\n        private void commitBulk() {\n            commit(bulkLoadGraph, nodes.size());\n            nodes.clear();\n        }\n\n        private void commitRegular() {\n            commit(graph, nodes.size());\n            cache.clearAll();\n        }\n\n        private void commit(Graph g, int size) {\n            parseElement.commit(g);\n            display(\"commit-size: {}: Done!\", size);\n        }\n\n        private void updateSchema(Map<String, Object> schema, JsonNode node) {\n            synchronized (graph) {\n                String typeName = parseElement.getType(node);\n\n                try {\n                    display(\"updateSchema: type: {}: ...\", typeName);\n\n                    if (schema.containsKey(\"oid\")) {\n                        parseElement.parse(graph, cache, node);\n                    } else {\n                        Object id = schema.get(\"id\");\n                        schema.remove(\"id\");\n                        parseElement.update(graph, id, schema);\n                    }\n\n                    commitRegular();\n\n                    display(\"updateSchema: type: {}: Done!\", typeName);\n                } catch (NoSuchElementException ex) {\n                    parseElement.parse(graph, cache, node);\n                    commitRegular();\n                    display(\"updateSchema: NoSuchElementException processed!: type: {}: Done!\", typeName);\n                } catch (Exception ex) {\n                    graph.tx().rollback();\n                    error(\"updateSchema: failed!: type: \" + typeName, ex);\n                }\n            }\n        }\n\n        private void retryBatchCommit() {\n            display(\"Waiting with [{} nodes] for 1 secs.\", nodes.size());\n\n            try {\n                Thread.sleep(WAIT_DURATION_AFTER_COMMIT_EXCEPTION);\n                for (JsonNode n : nodes) {\n                    parseElement.parse(bulkLoadGraph, cache, n);\n                }\n                commitBulk();\n                display(\"Done!: After re-adding {}.\", nodes.size());\n            } catch (Exception ex) {\n                error(\"retryBatchCommit: Failed! Potential data loss.\", ex);\n            }\n        }\n\n        private void display(String message, Object s1, Object s2) {\n            LOG.info(\"{}: [{}]: \" + message, parseElement.getMessage(), counter, s1, s2);\n        }\n\n        private void display(String message, Object s1) {\n            display(message, s1, \"\");\n        }\n\n        private void error(String message, Exception ex) {\n            LOG.error(\"{}: [{}]: \" + message, parseElement.getMessage(), counter, ex);\n        }\n    }\n\n    private static class ResumingConsumer extends Consumer {\n        public ResumingConsumer(BlockingQueue<JsonNode> workQueue, Graph graph, Graph bulkLoadGraph, ParseElement parseElement, long batchSize) {\n            super(workQueue, graph, bulkLoadGraph, parseElement, batchSize);\n        }\n\n        @Override\n        public void processItem(JsonNode node) {\n            if (!contains(node)) {\n                super.processItem(node);\n            }\n        }\n\n        private boolean contains(JsonNode node) {\n            return (parseElement.getByOriginalId(bulkLoadGraph, node) != null);\n        }\n    }\n\n    private static class ConsumerBuilder implements WorkItemBuilder<Consumer, JsonNode> {\n        private final Graph        graph;\n        private final Graph        bulkLoadGraph;\n        private final ParseElement parseElement;\n        private final int          batchSize;\n        private final boolean      isResuming;\n\n        public ConsumerBuilder(Graph graph, Graph bulkLoadGraph, ParseElement parseElement, int batchSize, boolean isResuming) {\n            this.graph         = graph;\n            this.bulkLoadGraph = bulkLoadGraph;\n            this.batchSize     = batchSize;\n            this.parseElement  = parseElement;\n            this.isResuming    = isResuming;\n        }\n\n<fim_suffix>        @Override\n        public Consumer build(BlockingQueue<JsonNode> queue) {\n            return (isResuming)\n                    ? new ResumingConsumer(queue, graph, bulkLoadGraph, parseElement, batchSize)\n                    : new Consumer(queue, graph, bulkLoadGraph, parseElement, batchSize);\n        }\n    }\n\n    static class WorkItemManager extends org.apache.atlas.repository.graphdb.janus.migration.pc.WorkItemManager {\n        public WorkItemManager(WorkItemBuilder builder, int batchSize, int numWorkers) {\n            super(builder, batchSize, numWorkers);\n        }\n    }\n\n    public static WorkItemManager create(Graph rGraph, Graph bGraph,\n                                         ParseElement parseElement, int numWorkers, int batchSize, boolean isResuming) {\n        ConsumerBuilder cb = new ConsumerBuilder(rGraph, bGraph, parseElement, batchSize, isResuming);\n\n        return new WorkItemManager(cb, batchSize, numWorkers);\n    }\n}<fim_middle>// function below has no smell\n"}