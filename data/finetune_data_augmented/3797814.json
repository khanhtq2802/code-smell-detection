{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n * <p/>\n * http://www.apache.org/licenses/LICENSE-2.0\n * <p/>\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.alibaba.jstorm.hdfs.spout;\n\nimport org.apache.hadoop.fs.FileSystem;\nimport org.apache.hadoop.fs.Path;\nimport org.apache.hadoop.io.SequenceFile;\nimport org.apache.hadoop.io.Writable;\nimport org.apache.hadoop.util.ReflectionUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\n\npublic class SequenceFileReader<Key extends Writable,Value extends Writable>\n        extends AbstractFileReader {\n  private static final Logger LOG = LoggerFactory\n          .getLogger(SequenceFileReader.class);\n  public static final String[] defaultFields = {\"key\", \"value\"};\n  private static final int DEFAULT_BUFF_SIZE = 4096;\n  public static final String BUFFER_SIZE = \"hdfsspout.reader.buffer.bytes\";\n\n  private final SequenceFile.Reader reader;\n\n  private final SequenceFileReader.Offset offset;\n\n\n  private final Key key;\n  private final Value value;\n\n\n  public SequenceFileReader(FileSystem fs, Path file, Map conf)\n          throws IOException {\n    super(fs, file);\n    int bufferSize = !conf.containsKey(BUFFER_SIZE) ? DEFAULT_BUFF_SIZE : Integer.parseInt( conf.get(BUFFER_SIZE).toString() );\n    this.reader = new SequenceFile.Reader(fs.getConf(),  SequenceFile.Reader.file(file), SequenceFile.Reader.bufferSize(bufferSize) );\n    this.key = (Key) ReflectionUtils.newInstance(reader.getKeyClass(), fs.getConf() );\n    this.value = (Value) ReflectionUtils.newInstance(reader.getValueClass(), fs.getConf() );\n    this.offset = new SequenceFileReader.Offset(0,0,0);\n  }\n\n  public SequenceFileReader(FileSystem fs, Path file, Map conf, String offset)\n          throws IOException {\n    super(fs, file);\n    int bufferSize = !conf.containsKey(BUFFER_SIZE) ? DEFAULT_BUFF_SIZE : Integer.parseInt( conf.get(BUFFER_SIZE).toString() );\n    this.offset = new SequenceFileReader.Offset(offset);\n    this.reader = new SequenceFile.Reader(fs.getConf(),  SequenceFile.Reader.file(file), SequenceFile.Reader.bufferSize(bufferSize) );\n    this.key = (Key) ReflectionUtils.newInstance(reader.getKeyClass(), fs.getConf() );\n    this.value = (Value) ReflectionUtils.newInstance(reader.getValueClass(), fs.getConf() );\n    skipToOffset(this.reader, this.offset, this.key);\n  }\n\n  private static <K> void skipToOffset(SequenceFile.Reader reader, Offset offset, K key) throws IOException {\n    reader.sync(offset.lastSyncPoint);\n    for(int i=0; i<offset.recordsSinceLastSync; ++i) {\n      reader.next(key);\n    }\n  }\n\n  public List<Object> next() throws IOException, ParseException {\n    if( reader.next(key, value) ) {\n      ArrayList<Object> result = new ArrayList<Object>(2);\n      Collections.addAll(result, key, value);\n      offset.increment(reader.syncSeen(), reader.getPosition() );\n      return result;\n    }\n    return null;\n  }\n\n  @Override\n  public void close() {\n    try {\n      reader.close();\n    } catch (IOException e) {\n      LOG.warn(\"Ignoring error when closing file \" + getFilePath(), e);\n    }\n  }\n\n  public Offset getFileOffset() {\n      return offset;\n  }\n\n\n<fim_suffix>  public static class Offset implements  FileOffset {\n    public long lastSyncPoint;\n    public long recordsSinceLastSync;\n    public long currentRecord;\n    private long currRecordEndOffset;\n    private long prevRecordEndOffset;\n\n    public Offset(long lastSyncPoint, long recordsSinceLastSync, long currentRecord) {\n      this(lastSyncPoint, recordsSinceLastSync, currentRecord, 0, 0 );\n    }\n\n    public Offset(long lastSyncPoint, long recordsSinceLastSync, long currentRecord\n                  , long currRecordEndOffset, long prevRecordEndOffset) {\n      this.lastSyncPoint = lastSyncPoint;\n      this.recordsSinceLastSync = recordsSinceLastSync;\n      this.currentRecord = currentRecord;\n      this.prevRecordEndOffset = prevRecordEndOffset;\n      this.currRecordEndOffset = currRecordEndOffset;\n    }\n\n    public Offset(String offset) {\n      try {\n        if(offset==null) {\n          throw new IllegalArgumentException(\"offset cannot be null\");\n        }\n        if(offset.equalsIgnoreCase(\"0\")) {\n          this.lastSyncPoint = 0;\n          this.recordsSinceLastSync = 0;\n          this.currentRecord = 0;\n          this.prevRecordEndOffset = 0;\n          this.currRecordEndOffset = 0;\n        } else {\n          String[] parts = offset.split(\":\");\n          this.lastSyncPoint = Long.parseLong(parts[0].split(\"=\")[1]);\n          this.recordsSinceLastSync = Long.parseLong(parts[1].split(\"=\")[1]);\n          this.currentRecord = Long.parseLong(parts[2].split(\"=\")[1]);\n          this.prevRecordEndOffset = 0;\n          this.currRecordEndOffset = 0;\n        }\n      } catch (Exception e) {\n        throw new IllegalArgumentException(\"'\" + offset +\n                \"' cannot be interpreted. It is not in expected format for SequenceFileReader.\" +\n                \" Format e.g. {sync=123:afterSync=345:record=67}\");\n      }\n    }\n\n    @Override\n    public String toString() {\n      return '{' +\n              \"sync=\" + lastSyncPoint +\n              \":afterSync=\" + recordsSinceLastSync +\n              \":record=\" + currentRecord +\n              \":}\";\n    }\n\n    @Override\n    public boolean isNextOffset(FileOffset rhs) {\n      if(rhs instanceof Offset) {\n        Offset other = ((Offset) rhs);\n        return  other.currentRecord > currentRecord+1;\n      }\n      return false;\n    }\n\n    @Override\n    public int compareTo(FileOffset o) {\n      Offset rhs = ((Offset) o);\n      if(currentRecord<rhs.currentRecord) {\n        return -1;\n      }\n      if(currentRecord==rhs.currentRecord) {\n        return 0;\n      }\n      return 1;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) { return true; }\n      if (!(o instanceof Offset)) { return false; }\n\n      Offset offset = (Offset) o;\n\n      return currentRecord == offset.currentRecord;\n    }\n\n    @Override\n    public int hashCode() {\n      return (int) (currentRecord ^ (currentRecord >>> 32));\n    }\n    \n    void increment(boolean syncSeen, long newBytePosition) {\n      if(!syncSeen) {\n        ++recordsSinceLastSync;\n      }  else {\n        recordsSinceLastSync = 1;\n        lastSyncPoint = prevRecordEndOffset;\n      }\n      ++currentRecord;\n      prevRecordEndOffset = currRecordEndOffset;\n      currentRecord = newBytePosition;\n    }\n\n    @Override\n    public Offset clone() {\n      return new Offset(lastSyncPoint, recordsSinceLastSync, currentRecord, currRecordEndOffset, prevRecordEndOffset);\n    }\n\n  } //class Offset\n} //class<fim_middle>// class below is data class\n"}