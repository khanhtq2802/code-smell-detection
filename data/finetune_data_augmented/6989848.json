{"text": "<fim_prefix>/*\n * Copyright (C) 2009 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.common.collect;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.base.MoreObjects;\nimport com.google.common.base.Preconditions;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport com.google.errorprone.annotations.concurrent.LazyInit;\nimport com.google.j2objc.annotations.RetainedWith;\nimport com.google.j2objc.annotations.Weak;\nimport java.io.IOException;\nimport java.io.InvalidObjectException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.function.Function;\nimport java.util.stream.Collector;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport org.checkerframework.checker.nullness.qual.MonotonicNonNull;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n/**\n * A {@link SetMultimap} whose contents will never change, with many other important properties\n * detailed at {@link ImmutableCollection}.\n *\n * <p>See the Guava User Guide article on <a href=\n * \"https://github.com/google/guava/wiki/ImmutableCollectionsExplained\"> immutable collections</a>.\n *\n * @author Mike Ward\n * @since 2.0\n */\n@GwtCompatible(serializable = true, emulated = true)\npublic class ImmutableSetMultimap<K, V> extends ImmutableMultimap<K, V>\n    implements SetMultimap<K, V> {\n  /**\n   * Returns a {@link Collector} that accumulates elements into an {@code ImmutableSetMultimap}\n   * whose keys and values are the result of applying the provided mapping functions to the input\n   * elements.\n   *\n   * <p>For streams with {@linkplain java.util.stream#Ordering defined encounter order}, that order\n   * is preserved, but entries are <a href=\"ImmutableMultimap.html#iteration\">grouped by key</a>.\n   *\n   * <p>Example:\n   *\n   * <pre>{@code\n   * static final Multimap<Character, String> FIRST_LETTER_MULTIMAP =\n   *     Stream.of(\"banana\", \"apple\", \"carrot\", \"asparagus\", \"cherry\")\n   *         .collect(toImmutableSetMultimap(str -> str.charAt(0), str -> str.substring(1)));\n   *\n   * // is equivalent to\n   *\n   * static final Multimap<Character, String> FIRST_LETTER_MULTIMAP =\n   *     new ImmutableSetMultimap.Builder<Character, String>()\n   *         .put('b', \"anana\")\n   *         .putAll('a', \"pple\", \"sparagus\")\n   *         .putAll('c', \"arrot\", \"herry\")\n   *         .build();\n   * }</pre>\n   *\n   * @since 21.0\n   */\n<fim_suffix>  public static <T, K, V> Collector<T, ?, ImmutableSetMultimap<K, V>> toImmutableSetMultimap(\n      Function<? super T, ? extends K> keyFunction,\n      Function<? super T, ? extends V> valueFunction) {\n    checkNotNull(keyFunction, \"keyFunction\");\n    checkNotNull(valueFunction, \"valueFunction\");\n    return Collector.of(\n        ImmutableSetMultimap::<K, V>builder,\n        (builder, t) -> builder.put(keyFunction.apply(t), valueFunction.apply(t)),\n        ImmutableSetMultimap.Builder::combine,\n        ImmutableSetMultimap.Builder::build);\n  }\n  /**\n   * Returns a {@code Collector} accumulating entries into an {@code ImmutableSetMultimap}. Each\n   * input element is mapped to a key and a stream of values, each of which are put into the\n   * resulting {@code Multimap}, in the encounter order of the stream and the encounter order of the\n   * streams of values.\n   *\n   * <p>Example:\n   *\n   * <pre>{@code\n   * static final ImmutableSetMultimap<Character, Character> FIRST_LETTER_MULTIMAP =\n   *     Stream.of(\"banana\", \"apple\", \"carrot\", \"asparagus\", \"cherry\")\n   *         .collect(\n   *             flatteningToImmutableSetMultimap(\n   *                  str -> str.charAt(0),\n   *                  str -> str.substring(1).chars().mapToObj(c -> (char) c));\n   *\n   * // is equivalent to\n   *\n   * static final ImmutableSetMultimap<Character, Character> FIRST_LETTER_MULTIMAP =\n   *     ImmutableSetMultimap.<Character, Character>builder()\n   *         .putAll('b', Arrays.asList('a', 'n', 'a', 'n', 'a'))\n   *         .putAll('a', Arrays.asList('p', 'p', 'l', 'e'))\n   *         .putAll('c', Arrays.asList('a', 'r', 'r', 'o', 't'))\n   *         .putAll('a', Arrays.asList('s', 'p', 'a', 'r', 'a', 'g', 'u', 's'))\n   *         .putAll('c', Arrays.asList('h', 'e', 'r', 'r', 'y'))\n   *         .build();\n   *\n   * // after deduplication, the resulting multimap is equivalent to\n   *\n   * static final ImmutableSetMultimap<Character, Character> FIRST_LETTER_MULTIMAP =\n   *     ImmutableSetMultimap.<Character, Character>builder()\n   *         .putAll('b', Arrays.asList('a', 'n'))\n   *         .putAll('a', Arrays.asList('p', 'l', 'e', 's', 'a', 'r', 'g', 'u'))\n   *         .putAll('c', Arrays.asList('a', 'r', 'o', 't', 'h', 'e', 'y'))\n   *         .build();\n   * }\n   * }</pre>\n   *\n   * @since 21.0\n   */\n  public static <T, K, V>\n      Collector<T, ?, ImmutableSetMultimap<K, V>> flatteningToImmutableSetMultimap(\n          Function<? super T, ? extends K> keyFunction,\n          Function<? super T, ? extends Stream<? extends V>> valuesFunction) {\n    checkNotNull(keyFunction);\n    checkNotNull(valuesFunction);\n    return Collectors.collectingAndThen(\n        Multimaps.flatteningToMultimap(\n            input -> checkNotNull(keyFunction.apply(input)),\n            input -> valuesFunction.apply(input).peek(Preconditions::checkNotNull),\n            MultimapBuilder.linkedHashKeys().linkedHashSetValues()::<K, V>build),\n        ImmutableSetMultimap::copyOf);\n  }\n  /** Returns the empty multimap. */\n  // Casting is safe because the multimap will never hold any elements.\n  @SuppressWarnings(\"unchecked\")\n  public static <K, V> ImmutableSetMultimap<K, V> of() {\n    return (ImmutableSetMultimap<K, V>) EmptyImmutableSetMultimap.INSTANCE;\n  }\n  /** Returns an immutable multimap containing a single entry. */\n  public static <K, V> ImmutableSetMultimap<K, V> of(K k1, V v1) {\n    ImmutableSetMultimap.Builder<K, V> builder = ImmutableSetMultimap.builder();\n    builder.put(k1, v1);\n    return builder.build();\n  }\n  /**\n   * Returns an immutable multimap containing the given entries, in order. Repeated occurrences of\n   * an entry (according to {@link Object#equals}) after the first are ignored.\n   */\n  public static <K, V> ImmutableSetMultimap<K, V> of(K k1, V v1, K k2, V v2) {\n    ImmutableSetMultimap.Builder<K, V> builder = ImmutableSetMultimap.builder();\n    builder.put(k1, v1);\n    builder.put(k2, v2);\n    return builder.build();\n  }\n  /**\n   * Returns an immutable multimap containing the given entries, in order. Repeated occurrences of<fim_middle>// function below has no smell\n"}