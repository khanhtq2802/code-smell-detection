{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ignite.internal.binary.builder;\n\nimport java.util.AbstractList;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport org.apache.ignite.internal.binary.BinaryWriterExImpl;\nimport org.apache.ignite.internal.binary.GridBinaryMarshaller;\nimport org.apache.ignite.internal.binary.BinaryUtils;\n\n/**\n *\n */\nclass BinaryLazyArrayList extends AbstractList<Object> implements BinaryBuilderSerializationAware {\n    /** */\n    private final BinaryBuilderReader reader;\n\n    /** */\n    private final int off;\n\n    /** */\n    private List<Object> delegate;\n\n    /**\n     * @param reader Reader.\n     * @param size Size,\n     */\n    BinaryLazyArrayList(BinaryBuilderReader reader, int size) {\n        this.reader = reader;\n        off = reader.position() - 1/* flag */ - 4/* size */ - 1/* col type */;\n\n        assert size >= 0;\n\n        for (int i = 0; i < size; i++)\n            reader.skipValue();\n    }\n\n    /**\n     *\n     */\n    private void ensureDelegateInit() {\n        if (delegate == null) {\n            int size = reader.readIntPositioned(off + 1);\n\n            reader.position(off + 1/* flag */ + 4/* size */ + 1/* col type */);\n\n            delegate = new ArrayList<>(size);\n\n            for (int i = 0; i < size; i++)\n                delegate.add(reader.parseValue());\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override public Object get(int idx) {\n        ensureDelegateInit();\n\n        return BinaryUtils.unwrapLazy(delegate.get(idx));\n    }\n\n    /** {@inheritDoc} */\n    @Override public boolean add(Object o) {\n        ensureDelegateInit();\n\n        return delegate.add(o);\n    }\n\n    /** {@inheritDoc} */\n    @Override public void add(int idx, Object element) {\n        ensureDelegateInit();\n\n        delegate.add(idx, element);\n    }\n\n    /** {@inheritDoc} */\n    @Override public Object set(int idx, Object element) {\n        ensureDelegateInit();\n\n        return BinaryUtils.unwrapLazy(delegate.set(idx, element));\n    }\n\n    /** {@inheritDoc} */\n    @Override public Object remove(int idx) {\n        ensureDelegateInit();\n\n        return BinaryUtils.unwrapLazy(delegate.remove(idx));\n    }\n\n    /** {@inheritDoc} */\n<fim_suffix>    @Override public void clear() {\n        if (delegate == null)\n            delegate = new ArrayList<>();\n        else\n            delegate.clear();\n    }\n\n    /** {@inheritDoc} */\n    @Override public boolean addAll(int idx, Collection<?> c) {\n        return delegate.addAll(idx, c);\n    }\n\n    /** {@inheritDoc} */\n    @Override protected void removeRange(int fromIdx, int toIdx) {\n        ensureDelegateInit();\n\n        delegate.subList(fromIdx, toIdx).clear();\n    }\n\n    /** {@inheritDoc} */\n    @Override public int size() {\n        if (delegate == null)\n            return reader.readIntPositioned(off + 1);\n\n        return delegate.size();\n    }\n\n    /** {@inheritDoc} */\n    @Override public void writeTo(BinaryWriterExImpl writer, BinaryBuilderSerializer ctx) {\n        if (delegate == null) {\n            int size = reader.readIntPositioned(off + 1);\n\n            int hdrSize = 1 /* flag */ + 4 /* size */ + 1 /* col type */;\n\n            writer.write(reader.array(), off, hdrSize);\n\n            reader.position(off + hdrSize);\n\n            for (int i = 0; i < size; i++) {\n                Object o = reader.parseValue();\n\n                ctx.writeValue(writer, o);\n            }\n        }\n        else {\n            writer.writeByte(GridBinaryMarshaller.COL);\n            writer.writeInt(delegate.size());\n\n            byte colType = reader.array()[off + 1 /* flag */ + 4 /* size */];\n            writer.writeByte(colType);\n\n            int oldPos = reader.position();\n\n            for (Object o : delegate)\n                ctx.writeValue(writer, o);\n\n            // BinaryBuilderImpl might have been written. It could override reader's position.\n            reader.position(oldPos);\n        }\n    }\n}<fim_middle>// function below has no smell\n"}