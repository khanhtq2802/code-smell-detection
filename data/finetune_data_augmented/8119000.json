{"text": "<fim_prefix>\n<fim_suffix>public class Strings {\n\tpublic static final String[] EMPTY_ARRAY = new String[0];\n\tpublic static boolean equalsIgnoreWhitespace(String left, String right) {\n\t\tString l = left == null ? \"\" : left.replaceAll(\"\\\\s\", \"\");\n\t\tString r = right == null ? \"\" : right.replaceAll(\"\\\\s\", \"\");\n\t\treturn l.equals(r);\n\t}\n\tpublic static boolean equal(String literal, String name) {\n\t\treturn isEmpty(literal) ? isEmpty(name) : literal.equals(name);\n\t}\n\tpublic static String notNull(Object o) {\n\t\treturn String.valueOf(o);\n\t}\n\tpublic static String emptyIfNull(String s) {\n\t\treturn (s == null) ? \"\" : s;\n\t}\n\tpublic static String concat(String separator, List<String> list) {\n\t\treturn concat(separator, list, 0);\n\t}\n\tpublic static <T> String toString(Collection<T> list, Function<T, String> toString, String delim) {\n\t\tStringBuffer buffer = new StringBuffer();\n\t\tfor (Iterator<T> iterator = list.iterator(); iterator.hasNext();) {\n\t\t\tT t = iterator.next();\n\t\t\tbuffer.append(toString.apply(t));\n\t\t\tif (iterator.hasNext())\n\t\t\t\tbuffer.append(delim);\n\t\t}\n\t\treturn buffer.toString();\n\t}\n\tpublic static String concat(String separator, List<String> list, int skip) {\n\t\tStringBuffer buff = new StringBuffer();\n\t\tint lastIndex = list.size() - skip;\n\t\tfor (int i = 0; i < lastIndex; i++) {\n\t\t\tbuff.append(list.get(i));\n\t\t\tif (i + 1 < lastIndex)\n\t\t\t\tbuff.append(separator);\n\t\t}\n\t\tString string = buff.toString();\n\t\treturn string.trim().length() == 0 ? null : string;\n\t}\n\tpublic static String skipLastToken(String value, String separator) {\n\t\tint endIndex = value.lastIndexOf(separator);\n\t\tif (endIndex > 0)\n\t\t\treturn value.substring(0, endIndex);\n\t\treturn value;\n\t}\n\tpublic static String lastToken(String value, String separator) {\n\t\tint index = value.lastIndexOf(separator) + separator.length();\n\t\tif (index < value.length())\n\t\t\treturn value.substring(index, value.length());\n\t\treturn \"\";\n\t}\n\tpublic static String toFirstUpper(String s) {\n\t\tif (s == null || s.length() == 0 || Character.isUpperCase(s.charAt(0)))\n\t\t\treturn s;\n\t\tif (s.length() == 1)\n\t\t\treturn s.toUpperCase();\n\t\treturn s.substring(0, 1).toUpperCase() + s.substring(1);\n\t}\n\tpublic static boolean isEmpty(String s) {\n\t\treturn s == null || s.equals(\"\");\n\t}\n\tpublic static String newLine() {\n\t\treturn System.getProperty(\"line.separator\");\n\t}\n\t/**\n\t * @since 2.13\n\t */\n\tpublic static String toPlatformLineSeparator(CharSequence cs) {\n\t\treturn cs.toString().replaceAll(\"\\r?\\n\", Strings.newLine());\n\t}\n\t/**\n\t * @since 2.14\n\t */\n\tpublic static String toUnixLineSeparator(CharSequence cs) {\n\t\treturn cs.toString().replaceAll(\"\\r?\\n\", \"\\n\");\n\t}\n\tpublic static String toFirstLower(String s) {\n\t\tif (s == null || s.length() == 0 || Character.isLowerCase(s.charAt(0)))\n\t\t\treturn s;\n\t\tif (s.length() == 1)\n\t\t\treturn s.toLowerCase();\n\t\treturn s.substring(0, 1).toLowerCase() + s.substring(1);\n\t}\n\tprivate static final JavaStringConverter CONVERTER = new JavaStringConverter();\n\t/**\n\t * Resolve Java control character sequences with to the actual character value.\n\t * Optionally handle unicode escape sequences, too. \n\t */\n\tpublic static String convertFromJavaString(String string, boolean useUnicode) {\n\t\treturn CONVERTER.convertFromJavaString(string, useUnicode);\n\t}\n\t/**\n\t * Escapes control characters with a preceding backslash.\n\t * Encodes special chars as unicode escape sequence. \n\t * The resulting string is safe to be put into a Java string literal between\n\t * the quotes.\n\t */\n\tpublic static String convertToJavaString(String theString) {\n\t\treturn CONVERTER.convertToJavaString(theString, true);\n\t}\n\t/**\n\t * Escapes control characters with a preceding backslash.\n\t * Optionally encodes special chars as unicode escape sequence. \n\t * The resulting string is safe to be put into a Java string literal between\n\t * the quotes.\n\t */\n\tpublic static String convertToJavaString(String input, boolean useUnicode) {\n\t\treturn CONVERTER.convertToJavaString(input, useUnicode);\n\t}\n\tpublic static char toHex(int i) {\n\t\treturn CONVERTER.toHex(i);\n\t}\n\t/**\n\t * Splits a string around matches of the given delimiter string.\n\t * <p>\n\t * This method works similar to {@link String#split(String)} but does not treat the delimiter\n\t * as a regular expression. This makes it perform better in most cases where this feature is not\n\t * necessary. Furthermore this implies that trailing empty segments will not be part of the\n\t * result.\n\t * <p>\n\t * For delimiters of length 1 it is preferred to use {@link #split(String, char)} instead.\n\t * \n\t * @param value\n\t *            the string to split\n\t * @param delimiter\n\t *            the delimiting string (e.g. \"::\")\n\t * \n\t * @return the list of strings computed by splitting the string around matches of the given delimiter\n\t * without trailing empty segments. Never <code>null</code> and the list does not contain any <code>null</code> values.\n\t * \n\t * @throws NullPointerException\n\t *             If the {@code value} or {@code delimiter} is {@code null}\n\t */\n\tpublic static List<String> split(String value, String delimiter) {\n\t\tList<String> result = new ArrayList<String>();\n\t\tint lastIndex = 0;\n\t\tint index = value.indexOf(delimiter, lastIndex);\n\t\tint pendingEmptyStrings = 0;\n\t\twhile (index != -1) {\n\t\t\tString addMe = value.substring(lastIndex, index);\n\t\t\tif (addMe.length() == 0)\n\t\t\t\tpendingEmptyStrings++;\n\t\t\telse {\n\t\t\t\twhile(pendingEmptyStrings > 0) {\n\t\t\t\t\tresult.add(\"\");\n\t\t\t\t\tpendingEmptyStrings--;\n\t\t\t\t}\n\t\t\t\tresult.add(addMe);\n\t\t\t}\n\t\t\tlastIndex = index + delimiter.length();\n\t\t\tindex = value.indexOf(delimiter, lastIndex);\n\t\t}\n\t\tif (lastIndex != value.length()) {\n\t\t\twhile(pendingEmptyStrings > 0) {\n\t\t\t\tresult.add(\"\");\n\t\t\t\tpendingEmptyStrings--;\n\t\t\t}\n\t\t\tresult.add(value.substring(lastIndex));\n\t\t}\n\t\treturn result;\n\t}\n\t/**\n\t * Splits a string around matches of the given delimiter character.\n\t * <p>\n\t * This method works similar to {@link String#split(String)} but does not treat the delimiter\n\t * as a regular expression. This makes it perform better in most cases where this feature is not\n\t * necessary. Furthermore this implies that trailing empty segments will not be part of the\n\t * result.\n\t * \n\t * @param value\n\t *            the string to split\n\t * @param delimiter\n\t *            the delimiting character (e.g. '.' or ':')\n\t * \n\t * @return the list of strings computed by splitting the string around matches of the given delimiter\n\t * without trailing empty segments. Never <code>null</code> and the list does not contain any <code>null</code> values.\n\t * \n\t * @throws NullPointerException\n\t *             If the {@code value} is {@code null}\n\t * @see String#split(String)\n\t * @since 2.3\n\t */\n\tpublic static List<String> split(String value, char delimiter) {\n\t\tList<String> result = new ArrayList<String>();\n\t\tint lastIndex = 0;\n\t\tint index = value.indexOf(delimiter, lastIndex);\n\t\tint pendingEmptyStrings = 0;\n\t\twhile (index != -1) {\n\t\t\tString addMe = value.substring(lastIndex, index);\n\t\t\tif (addMe.length() == 0)\n\t\t\t\tpendingEmptyStrings++;\n\t\t\telse {\n\t\t\t\twhile(pendingEmptyStrings > 0) {\n\t\t\t\t\tresult.add(\"\");\n\t\t\t\t\tpendingEmptyStrings--;\n\t\t\t\t}\n\t\t\t\tresult.add(addMe);\n\t\t\t}\n\t\t\tlastIndex = index + 1;<fim_middle>// class below is blob\n"}