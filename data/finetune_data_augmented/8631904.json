{"text": "<fim_prefix>        cols = colsInfo.cols();\n        inlineIdxs = colsInfo.inlineIdx();\n        IndexColumn.mapColumns(cols, table);\n        initBaseIndex(table, 0, idxName, cols,\n            pk ? IndexType.createPrimaryKey(false, false) : IndexType.createNonUnique(false, false, false));\n        // Initialize distributed joins.\n        msgTopic = new IgniteBiTuple<>(GridTopic.TOPIC_QUERY, table.identifierString() + '.' + getName());\n        msgLsnr = new GridMessageListener() {\n            @Override public void onMessage(UUID nodeId, Object msg, byte plc) {\n                GridSpinBusyLock l = table.rowDescriptor().indexing().busyLock();\n                if (!l.enterBusy())\n                    return;\n                try {\n                    onMessage0(nodeId, msg);\n                }\n                finally {\n                    l.leaveBusy();\n                }\n            }\n        };\n        ctx.io().addMessageListener(msgTopic, msgLsnr);\n    }\n    /** {@inheritDoc} */\n    @Override public int inlineSize() {\n        return segments[0].inlineSize();\n    }\n    /**\n     * Check if index exists in store.\n     *\n     * @return {@code True} if exists.\n     */\n    public boolean rebuildRequired() {\n        assert segments != null;\n        for (int i = 0; i < segments.length; i++) {\n            try {\n                H2Tree segment = segments[i];\n                if (segment.created())\n                    return true;\n            }\n            catch (Exception e) {\n                throw new IgniteException(\"Failed to check index tree root page existence [cacheName=\" + cctx.name() +\n                    \", tblName=\" + tblName + \", idxName=\" + idxName + \", segment=\" + i + ']');\n            }\n        }\n        return false;\n    }\n    /** {@inheritDoc} */\n    @Override protected void warnCantBeInlined(IndexColumn col) {\n        String idxType = pk ? \"PRIMARY KEY\" : affinityKey ? \"AFFINITY KEY (implicit)\" : \"SECONDARY\";\n        U.warn(log, \"Column cannot be inlined into the index because it's type doesn't support inlining, \" +\n            \"index access may be slow due to additional page reads (change column type if possible) \" +\n            \"[cacheName=\" + cctx.name() +\n            \", tableName=\" + tblName +\n            \", idxName=\" + idxName +\n            \", idxType=\" + idxType +\n            \", colName=\" + col.columnName +\n            \", columnType=\" + InlineIndexHelper.nameTypeBycode(col.column.getType()) + ']'\n        );\n    }\n    /** {@inheritDoc} */\n    @Override public int segmentsCount() {\n        return segments.length;\n    }\n    /** {@inheritDoc} */\n    @Override public Cursor find(Session ses, SearchRow lower, SearchRow upper) {\n        assert lower == null || lower instanceof H2Row : lower;\n        assert upper == null || upper instanceof H2Row : upper;\n        try {\n            int seg = threadLocalSegment();\n            H2Tree tree = treeForRead(seg);\n            if (!cctx.mvccEnabled() && indexType.isPrimaryKey() && lower != null && upper != null &&\n                tree.compareRows((H2Row)lower, (H2Row)upper) == 0) {\n                H2Row row = tree.findOne((H2Row)lower, filter(qryCtxRegistry.getThreadLocal()), null);\n                if (row == null || isExpired(row))\n                    return GridH2Cursor.EMPTY;\n                return new SingleRowCursor(row);\n            }\n            else {\n                return new H2Cursor(tree.find((H2Row)lower,\n                    (H2Row)upper, filter(qryCtxRegistry.getThreadLocal()), null));\n            }\n        }\n        catch (IgniteCheckedException e) {\n            throw DbException.convert(e);\n        }\n    }\n    /** {@inheritDoc} */\n    @Override public H2CacheRow put(H2CacheRow row) {\n        try {\n            InlineIndexHelper.setCurrentInlineIndexes(inlineIdxs);\n            int seg = segmentForRow(cctx, row);\n            H2Tree tree = treeForRead(seg);\n            assert cctx.shared().database().checkpointLockIsHeldByThread();\n            return (H2CacheRow)tree.put(row);\n        }\n        catch (IgniteCheckedException e) {\n            throw DbException.convert(e);\n        }\n        finally {\n            InlineIndexHelper.clearCurrentInlineIndexes();\n        }\n    }\n    /** {@inheritDoc} */\n    @Override public boolean putx(H2CacheRow row) {\n        try {\n            InlineIndexHelper.setCurrentInlineIndexes(inlineIdxs);\n            int seg = segmentForRow(cctx, row);\n            H2Tree tree = treeForRead(seg);\n            assert cctx.shared().database().checkpointLockIsHeldByThread();\n            return tree.putx(row);\n        }\n        catch (IgniteCheckedException e) {\n            throw DbException.convert(e);\n        }\n        finally {\n            InlineIndexHelper.clearCurrentInlineIndexes();\n        }\n    }\n    /** {@inheritDoc} */\n    @Override public boolean removex(SearchRow row) {\n        assert row instanceof H2Row : row;\n        try {\n            InlineIndexHelper.setCurrentInlineIndexes(inlineIdxs);\n            int seg = segmentForRow(cctx, row);\n            H2Tree tree = treeForRead(seg);\n            assert cctx.shared().database().checkpointLockIsHeldByThread();\n            return tree.removex((H2Row)row);\n        }\n        catch (IgniteCheckedException e) {\n            throw DbException.convert(e);\n        }\n        finally {\n            InlineIndexHelper.clearCurrentInlineIndexes();\n        }\n    }\n    /** {@inheritDoc} */\n    @Override public long getRowCount(Session ses) {\n        try {\n            int seg = threadLocalSegment();\n            H2Tree tree = treeForRead(seg);\n            QueryContext qctx = qryCtxRegistry.getThreadLocal();\n            return tree.size(filter(qctx));\n        }\n        catch (IgniteCheckedException e) {\n            throw DbException.convert(e);\n        }\n    }\n    /** {@inheritDoc} */\n    @Override public Cursor findFirstOrLast(Session session, boolean b) {\n        try {\n            H2Tree tree = treeForRead(threadLocalSegment());\n            QueryContext qctx = qryCtxRegistry.getThreadLocal();\n            H2Row found = b ? tree.findFirst(filter(qctx)) : tree.findLast(filter(qctx));\n            if (found == null || isExpired(found))\n                return GridH2Cursor.EMPTY;\n            return new SingleRowCursor(found);\n        }\n        catch (IgniteCheckedException e) {\n            throw DbException.convert(e);\n        }\n    }\n    /**\n     * Determines if provided row can be treated as expired at the current moment.\n     *\n     * @param row row to check.\n     * @throws NullPointerException if provided row is {@code null}.\n     */\n    private static boolean isExpired(@NotNull H2Row row) {\n        return row.expireTime() > 0 && row.expireTime() <= U.currentTimeMillis();\n    }\n    /** {@inheritDoc} */\n    @Override public void destroy(boolean rmvIdx) {\n        try {\n            if (cctx.affinityNode() && rmvIdx) {\n                assert cctx.shared().database().checkpointLockIsHeldByThread();\n                for (int i = 0; i < segments.length; i++) {\n                    H2Tree tree = segments[i];\n                    tree.destroy();\n                    dropMetaPage(i);\n                }\n            }\n        }\n        catch (IgniteCheckedException e) {\n            throw new IgniteException(e);\n        }\n        finally {\n            if (msgLsnr != null)\n                ctx.io().removeMessageListener(msgTopic, msgLsnr);\n        }\n    }\n    /**\n     * @param segment Segment Id.\n     * @return Snapshot for requested segment if there is one.\n     */\n    private H2Tree treeForRead(int segment) {\n        return segments[segment];\n    }\n    /**\n     * @param qctx Query context.\n     * @return Row filter.\n     */\n<fim_suffix>    private BPlusTree.TreeRowClosure<H2Row, H2Row> filter(QueryContext qctx) {\n        if (qctx == null) {\n            assert !cctx.mvccEnabled();\n            return null;\n        }\n        IndexingQueryFilter f = qctx.filter();\n        IndexingQueryCacheFilter p = f == null ? null : f.forCache(getTable().cacheName());\n        MvccSnapshot v = qctx.mvccSnapshot();\n        assert !cctx.mvccEnabled() || v != null;\n        if(p == null && v == null)\n            return null;\n        return new H2TreeFilterClosure(p, v, cctx, log);\n    }<fim_middle>// function below has no smell\n"}