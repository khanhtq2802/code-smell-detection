{"text": "<fim_prefix>\n<fim_suffix>public class RemoteInterpreterEventServer implements RemoteInterpreterEventService.Iface {\n  private static final Logger LOGGER = LoggerFactory.getLogger(RemoteInterpreterEventServer.class);\n  private String portRange;\n  private int port;\n  private String host;\n  private TThreadPoolServer thriftServer;\n  private InterpreterSettingManager interpreterSettingManager;\n  private final ScheduledExecutorService appendService =\n      Executors.newSingleThreadScheduledExecutor();\n  private ScheduledFuture<?> appendFuture;\n  private AppendOutputRunner runner;\n  private final RemoteInterpreterProcessListener listener;\n  private final ApplicationEventListener appListener;\n  private final Gson gson = new Gson();\n  public RemoteInterpreterEventServer(ZeppelinConfiguration zConf,\n                                      InterpreterSettingManager interpreterSettingManager) {\n    this.portRange = zConf.getZeppelinServerRPCPortRange();\n    this.interpreterSettingManager = interpreterSettingManager;\n    this.listener = interpreterSettingManager.getRemoteInterpreterProcessListener();\n    this.appListener = interpreterSettingManager.getAppEventListener();\n  }\n  public void start() throws IOException {\n    Thread startingThread = new Thread() {\n      @Override\n      public void run() {\n        TServerSocket tSocket = null;\n        try {\n          tSocket = RemoteInterpreterUtils.createTServerSocket(portRange);\n          port = tSocket.getServerSocket().getLocalPort();\n          host = RemoteInterpreterUtils.findAvailableHostAddress();\n        } catch (IOException e1) {\n          throw new RuntimeException(e1);\n        }\n        LOGGER.info(\"InterpreterEventServer is starting at {}:{}\", host, port);\n        RemoteInterpreterEventService.Processor processor =\n            new RemoteInterpreterEventService.Processor(RemoteInterpreterEventServer.this);\n        thriftServer = new TThreadPoolServer(\n            new TThreadPoolServer.Args(tSocket).processor(processor));\n        thriftServer.serve();\n      }\n    };\n    startingThread.start();\n    long start = System.currentTimeMillis();\n    while ((System.currentTimeMillis() - start) < 30 * 1000) {\n      if (thriftServer != null && thriftServer.isServing()) {\n        break;\n      }\n      try {\n        Thread.sleep(500);\n      } catch (InterruptedException e) {\n        throw new IOException(e);\n      }\n    }\n    if (thriftServer != null && !thriftServer.isServing()) {\n      throw new IOException(\"Fail to start InterpreterEventServer in 30 seconds.\");\n    }\n    LOGGER.info(\"RemoteInterpreterEventServer is started\");\n    runner = new AppendOutputRunner(listener);\n    appendFuture = appendService.scheduleWithFixedDelay(\n        runner, 0, AppendOutputRunner.BUFFER_TIME_MS, TimeUnit.MILLISECONDS);\n  }\n  public void stop() {\n    if (thriftServer != null) {\n      thriftServer.stop();\n    }\n    if (appendFuture != null) {\n      appendFuture.cancel(true);\n    }\n    LOGGER.info(\"RemoteInterpreterEventServer is stopped\");\n  }\n  public int getPort() {\n    return port;\n  }\n  public String getHost() {\n    return host;\n  }\n  @Override\n  public void registerInterpreterProcess(RegisterInfo registerInfo) throws TException {\n    InterpreterGroup interpreterGroup =\n        interpreterSettingManager.getInterpreterGroupById(registerInfo.getInterpreterGroupId());\n    if (interpreterGroup == null) {\n      LOGGER.warn(\"No such interpreterGroup: \" + registerInfo.getInterpreterGroupId());\n      return;\n    }\n    RemoteInterpreterProcess interpreterProcess =\n        ((ManagedInterpreterGroup) interpreterGroup).getInterpreterProcess();\n    if (interpreterProcess == null) {\n      LOGGER.warn(\"Interpreter process does not existed yet for InterpreterGroup: \" +\n          registerInfo.getInterpreterGroupId());\n    }\n    interpreterProcess.processStarted(registerInfo.port, registerInfo.host);\n  }\n  @Override\n  public void appendOutput(OutputAppendEvent event) throws TException {\n    if (event.getAppId() == null) {\n      runner.appendBuffer(\n          event.getNoteId(), event.getParagraphId(), event.getIndex(), event.getData());\n    } else {\n      appListener.onOutputAppend(event.getNoteId(), event.getParagraphId(), event.getIndex(),\n          event.getAppId(), event.getData());\n    }\n  }\n  @Override\n  public void updateOutput(OutputUpdateEvent event) throws TException {\n    if (event.getAppId() == null) {\n      listener.onOutputUpdated(event.getNoteId(), event.getParagraphId(), event.getIndex(),\n          InterpreterResult.Type.valueOf(event.getType()), event.getData());\n    } else {\n      appListener.onOutputUpdated(event.getNoteId(), event.getParagraphId(), event.getIndex(),\n          event.getAppId(), InterpreterResult.Type.valueOf(event.getType()), event.getData());\n    }\n  }\n  @Override\n  public void updateAllOutput(OutputUpdateAllEvent event) throws TException {\n    listener.onOutputClear(event.getNoteId(), event.getParagraphId());\n    for (int i = 0; i < event.getMsg().size(); i++) {\n      RemoteInterpreterResultMessage msg = event.getMsg().get(i);\n      listener.onOutputUpdated(event.getNoteId(), event.getParagraphId(), i,\n          InterpreterResult.Type.valueOf(msg.getType()), msg.getData());\n    }\n  }\n  @Override\n  public void appendAppOutput(AppOutputAppendEvent event) throws TException {\n    appListener.onOutputAppend(event.noteId, event.paragraphId, event.index, event.appId,\n        event.data);\n  }\n  @Override\n  public void updateAppOutput(AppOutputUpdateEvent event) throws TException {\n    appListener.onOutputUpdated(event.noteId, event.paragraphId, event.index, event.appId,\n        InterpreterResult.Type.valueOf(event.type), event.data);\n  }\n  @Override\n  public void updateAppStatus(AppStatusUpdateEvent event) throws TException {\n    appListener.onStatusChange(event.noteId, event.paragraphId, event.appId, event.status);\n  }\n  @Override\n  public void runParagraphs(RunParagraphsEvent event) throws TException {\n    try {\n      listener.runParagraphs(event.getNoteId(), event.getParagraphIndices(),\n          event.getParagraphIds(), event.getCurParagraphId());\n      if (InterpreterContext.get() != null) {\n        LOGGER.info(\"complete runParagraphs.\" + InterpreterContext.get().getParagraphId() + \" \"\n          + event);\n      } else {\n        LOGGER.info(\"complete runParagraphs.\" + event);\n      }\n    } catch (IOException e) {\n      throw new TException(e);\n    }\n  }\n  @Override\n  public void addAngularObject(String intpGroupId, String json) throws TException {\n    LOGGER.debug(\"Add AngularObject, interpreterGroupId: \" + intpGroupId + \", json: \" + json);\n    AngularObject angularObject = AngularObject.fromJson(json);\n    InterpreterGroup interpreterGroup =\n        interpreterSettingManager.getInterpreterGroupById(intpGroupId);\n    if (interpreterGroup == null) {\n      throw new TException(\"Invalid InterpreterGroupId: \" + intpGroupId);\n    }\n    interpreterGroup.getAngularObjectRegistry().add(angularObject.getName(),\n        angularObject.get(), angularObject.getNoteId(), angularObject.getParagraphId());\n  }\n  @Override\n  public void updateAngularObject(String intpGroupId, String json) throws TException {\n    AngularObject angularObject = AngularObject.fromJson(json);\n    InterpreterGroup interpreterGroup =\n        interpreterSettingManager.getInterpreterGroupById(intpGroupId);\n    if (interpreterGroup == null) {\n      throw new TException(\"Invalid InterpreterGroupId: \" + intpGroupId);\n    }\n    AngularObject localAngularObject = interpreterGroup.getAngularObjectRegistry().get(\n        angularObject.getName(), angularObject.getNoteId(), angularObject.getParagraphId());\n    if (localAngularObject instanceof RemoteAngularObject) {\n      // to avoid ping-pong loop\n      ((RemoteAngularObject) localAngularObject).set(\n          angularObject.get(), true, false);\n    } else {\n      localAngularObject.set(angularObject.get());\n    }\n  }\n  @Override\n  public void removeAngularObject(String intpGroupId,\n                                  String noteId,\n                                  String paragraphId,\n                                  String name) throws TException {\n    InterpreterGroup interpreterGroup =\n        interpreterSettingManager.getInterpreterGroupById(intpGroupId);\n    if (interpreterGroup == null) {\n      throw new TException(\"Invalid InterpreterGroupId: \" + intpGroupId);\n    }\n    interpreterGroup.getAngularObjectRegistry().remove(name, noteId, paragraphId);\n  }\n  @Override\n  public void sendParagraphInfo(String intpGroupId, String json) throws TException {\n    InterpreterGroup interpreterGroup =\n        interpreterSettingManager.getInterpreterGroupById(intpGroupId);\n    if (interpreterGroup == null) {\n      throw new TException(\"Invalid InterpreterGroupId: \" + intpGroupId);\n    }\n    Map<String, String> paraInfos = gson.fromJson(json,\n        new TypeToken<Map<String, String>>() {\n        }.getType());\n    String noteId = paraInfos.get(\"noteId\");<fim_middle>// class below is blob\n"}