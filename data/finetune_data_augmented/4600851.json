{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.giraph.examples;\nimport org.apache.commons.cli.CommandLine;\nimport org.apache.commons.cli.CommandLineParser;\nimport org.apache.commons.cli.HelpFormatter;\nimport org.apache.commons.cli.Options;\nimport org.apache.commons.cli.PosixParser;\nimport org.apache.giraph.aggregators.LongSumAggregator;\nimport org.apache.giraph.graph.BasicComputation;\nimport org.apache.giraph.edge.Edge;\nimport org.apache.giraph.edge.EdgeFactory;\nimport org.apache.giraph.io.formats.FileOutputFormatUtil;\nimport org.apache.giraph.io.formats.GeneratedVertexInputFormat;\nimport org.apache.giraph.io.formats.IdWithValueTextOutputFormat;\nimport org.apache.giraph.job.GiraphJob;\nimport org.apache.giraph.master.DefaultMasterCompute;\nimport org.apache.giraph.graph.Vertex;\nimport org.apache.giraph.worker.WorkerContext;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.fs.Path;\nimport org.apache.hadoop.io.FloatWritable;\nimport org.apache.hadoop.io.IntWritable;\nimport org.apache.hadoop.io.LongWritable;\nimport org.apache.hadoop.util.Tool;\nimport org.apache.hadoop.util.ToolRunner;\nimport org.apache.log4j.Logger;\nimport java.io.IOException;\n/**\n * An example that simply uses its id, value, and edges to compute new data\n * every iteration to verify that checkpoint restarting works.  Fault injection\n * can also test automated checkpoint restarts.\n */\npublic class SimpleCheckpoint implements Tool {\n  /** Which superstep to cause the worker to fail */\n  public static final int FAULTING_SUPERSTEP = 4;\n  /** Vertex id to fault on */\n  public static final long FAULTING_VERTEX_ID = 1;\n  /** Dynamically set number of supersteps */\n  public static final String SUPERSTEP_COUNT =\n      \"simpleCheckpointVertex.superstepCount\";\n  /** Should fault? */\n  public static final String ENABLE_FAULT =\n      \"simpleCheckpointVertex.enableFault\";\n  /** Class logger */\n  private static final Logger LOG =\n      Logger.getLogger(SimpleCheckpoint.class);\n  /** Configuration */\n  private Configuration conf;\n  /**\n   * Actual computation.\n   */\n  public static class SimpleCheckpointComputation extends\n      BasicComputation<LongWritable, IntWritable, FloatWritable,\n          FloatWritable> {\n    @Override\n    public void compute(\n        Vertex<LongWritable, IntWritable, FloatWritable> vertex,\n        Iterable<FloatWritable> messages) throws IOException {\n      SimpleCheckpointVertexWorkerContext workerContext = getWorkerContext();\n      boolean enableFault = workerContext.getEnableFault();\n      int supersteps = workerContext.getSupersteps();\n      if (enableFault && (getSuperstep() == FAULTING_SUPERSTEP) &&\n          (getContext().getTaskAttemptID().getId() == 0) &&\n          (vertex.getId().get() == FAULTING_VERTEX_ID)) {\n        LOG.info(\"compute: Forced a fault on the first \" +\n            \"attempt of superstep \" +\n            FAULTING_SUPERSTEP + \" and vertex id \" +\n            FAULTING_VERTEX_ID);\n        System.exit(-1);\n      }\n      if (getSuperstep() > supersteps) {\n        vertex.voteToHalt();\n        return;\n      }\n      long sumAgg = this.<LongWritable>getAggregatedValue(\n          LongSumAggregator.class.getName()).get();\n      LOG.info(\"compute: \" + sumAgg);\n      aggregate(LongSumAggregator.class.getName(),\n          new LongWritable(vertex.getId().get()));\n      LOG.info(\"compute: sum = \" + sumAgg +\n          \" for vertex \" + vertex.getId());\n      float msgValue = 0.0f;\n      for (FloatWritable message : messages) {\n        float curMsgValue = message.get();\n        msgValue += curMsgValue;\n        LOG.info(\"compute: got msgValue = \" + curMsgValue +\n            \" for vertex \" + vertex.getId() +\n            \" on superstep \" + getSuperstep());\n      }\n      int vertexValue = vertex.getValue().get();\n      vertex.setValue(new IntWritable(vertexValue + (int) msgValue));\n      LOG.info(\"compute: vertex \" + vertex.getId() +\n          \" has value \" + vertex.getValue() +\n          \" on superstep \" + getSuperstep());\n      for (Edge<LongWritable, FloatWritable> edge : vertex.getEdges()) {\n        FloatWritable newEdgeValue = new FloatWritable(edge.getValue().get() +\n            (float) vertexValue);\n        Edge<LongWritable, FloatWritable> newEdge =\n            EdgeFactory.create(edge.getTargetVertexId(), newEdgeValue);\n        LOG.info(\"compute: vertex \" + vertex.getId() +\n            \" sending edgeValue \" + edge.getValue() +\n            \" vertexValue \" + vertexValue +\n            \" total \" + newEdgeValue +\n            \" to vertex \" + edge.getTargetVertexId() +\n            \" on superstep \" + getSuperstep());\n        vertex.addEdge(newEdge);\n        sendMessage(edge.getTargetVertexId(), newEdgeValue);\n      }\n    }\n  }\n  /**\n   * Worker context associated with {@link SimpleCheckpoint}.\n   */\n  public static class SimpleCheckpointVertexWorkerContext\n      extends WorkerContext {\n    /** Filename to indicate whether a fault was found */\n    public static final String FAULT_FILE = \"/tmp/faultFile\";\n    /** User can access this after the application finishes if local */\n    private static long FINAL_SUM;\n    /** Number of supersteps to run (6 by default) */\n    private int supersteps = 6;\n    /** Enable the fault at the particular vertex id and superstep? */\n    private boolean enableFault = false;\n    public static long getFinalSum() {\n      return FINAL_SUM;\n    }\n    @Override\n    public void preApplication()\n      throws InstantiationException, IllegalAccessException {\n      supersteps = getContext().getConfiguration()\n          .getInt(SUPERSTEP_COUNT, supersteps);\n      enableFault = getContext().getConfiguration()\n          .getBoolean(ENABLE_FAULT, false);\n    }\n    @Override\n    public void postApplication() {\n      setFinalSum(this.<LongWritable>getAggregatedValue(\n          LongSumAggregator.class.getName()).get());\n      LOG.info(\"FINAL_SUM=\" + FINAL_SUM);\n    }\n    /**\n     * Set the final sum\n     *\n     * @param value sum\n     */\n    private static void setFinalSum(long value) {\n      FINAL_SUM = value;\n    }\n    @Override\n    public void preSuperstep() {\n    }\n<fim_suffix>    @Override\n    public void postSuperstep() { }\n    public int getSupersteps() {\n      return this.supersteps;\n    }\n    public boolean getEnableFault() {\n      return this.enableFault;\n    }\n  }\n  @Override\n  public int run(String[] args) throws Exception {\n    Options options = new Options();\n    options.addOption(\"h\", \"help\", false, \"Help\");\n    options.addOption(\"v\", \"verbose\", false, \"Verbose\");\n    options.addOption(\"w\",\n        \"workers\",\n        true,\n        \"Number of workers\");\n    options.addOption(\"s\",\n        \"supersteps\",\n        true,\n        \"Supersteps to execute before finishing\");\n    options.addOption(\"w\",\n        \"workers\",\n        true,\n        \"Minimum number of workers\");\n    options.addOption(\"o\",\n        \"outputDirectory\",\n        true,\n        \"Output directory\");\n    HelpFormatter formatter = new HelpFormatter();\n    if (args.length == 0) {\n      formatter.printHelp(getClass().getName(), options, true);\n      return 0;\n    }\n    CommandLineParser parser = new PosixParser();\n    CommandLine cmd = parser.parse(options, args);\n    if (cmd.hasOption('h')) {\n      formatter.printHelp(getClass().getName(), options, true);\n      return 0;\n    }\n    if (!cmd.hasOption('w')) {\n      LOG.info(\"Need to choose the number of workers (-w)\");\n      return -1;\n    }\n    if (!cmd.hasOption('o')) {\n      LOG.info(\"Need to set the output directory (-o)\");\n      return -1;\n    }<fim_middle>// function below has no smell\n"}