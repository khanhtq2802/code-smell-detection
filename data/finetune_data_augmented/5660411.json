{"text": "<fim_prefix>     * {@code GeodeticObjectFactory} will fallback on the map given to this constructor for any property\n     * not present in the map provided to a {@code createFoo(Map<String,?>, \u2026)} method.\n     *\n     * @param  properties  the default properties, or {@code null} if none.\n     */\n    public GeodeticObjectFactory(Map<String,?> properties) {\n        if (properties == null || properties.isEmpty()) {\n            properties = Collections.emptyMap();\n        } else {\n            properties = CollectionsExt.compact(new HashMap<>(properties));\n        }\n        defaultProperties = properties;\n        pool = new WeakHashSet<>(AbstractIdentifiedObject.class);\n        parser = new AtomicReference<>();\n    }\n    /**\n     * Returns the union of the given {@code properties} map with the default properties given at\n     * {@linkplain #GeodeticObjectFactory(Map) construction time}. Entries in the given properties\n     * map have precedence, even if their {@linkplain java.util.Map.Entry#getValue() value} is {@code null}\n     * (i.e. a null value \"erase\" the default property value).\n     * Entries with null value after the union will be omitted.\n     *\n     * <p>This method is invoked by all {@code createFoo(Map<String,?>, \u2026)} methods.</p>\n     *\n     * @param  properties  the user-supplied properties.\n     * @return the union of the given properties with the default properties.\n     */\n    protected Map<String,?> complete(final Map<String,?> properties) {\n        ArgumentChecks.ensureNonNull(\"properties\", properties);\n        return new MergedProperties(properties, defaultProperties) {\n            /**\n             * Handles the {@code \"mtFactory\"} key in a special way since this is normally not needed for\n             * {@link GeodeticObjectFactory}, except when creating the SIS implementation of derived or\n             * projected CRS (because of the way we implemented derived CRS, but this is specific to SIS).\n             */\n            @Override\n            protected Object invisibleEntry(final Object key) {\n                if (ReferencingServices.MT_FACTORY.equals(key)) {\n                    return getMathTransformFactory();\n                } else {\n                    return super.invisibleEntry(key);\n                }\n            }\n        };\n    }\n    /**\n     * Returns the math transform factory for internal usage only.\n     * The {@code MathTransformFactory} is normally not needed by {@code GeodeticObjectFactory},\n     * except when constructing the Apache SIS implementation of derived and projected CRS.\n     * For this reason, we will fetch this dependency only if really requested.\n     */\n    final MathTransformFactory getMathTransformFactory() {\n        MathTransformFactory factory = mtFactory;\n        if (factory == null) {\n            mtFactory = factory = DefaultFactories.forBuildin(MathTransformFactory.class);\n        }\n        return factory;\n    }\n    /**\n     * Returns a unique instance of the given object. If this method recycles an existing object,\n     * then the existing instance is returned silently. Otherwise this method logs a message at\n     * {@link Level#FINE} telling that a new object has been created.\n     */\n    private <T extends AbstractIdentifiedObject> T unique(final String caller, final T object) {\n        final T c = pool.unique(object);\n        if (c == object && LOGGER.isLoggable(Level.FINE)) {\n            final String id = IdentifiedObjects.toString(IdentifiedObjects.getIdentifier(c, null));\n            final LogRecord record = Messages.getResources(null).getLogRecord(Level.FINE,\n                    (id != null) ? Messages.Keys.CreatedIdentifiedObject_3\n                                 : Messages.Keys.CreatedNamedObject_2,\n                    c.getInterface(), c.getName().getCode(), id);\n            record.setSourceClassName(GeodeticObjectFactory.class.getCanonicalName());\n            record.setSourceMethodName(caller);\n            record.setLoggerName(LOGGER.getName());\n            LOGGER.log(record);\n        }\n        return c;\n    }\n    /**\n     * Creates a geocentric coordinate reference system from a {@linkplain CartesianCS Cartesian coordinate system}.\n     * Geocentric CRS have their origin at the approximate centre of mass of the earth.\n     * An {@linkplain #createGeocentricCRS(Map, GeodeticDatum, SphericalCS) alternate method} allows creation of the\n     * same kind of CRS with spherical coordinate system instead than a Cartesian one.\n     *\n     * <div class=\"note\"><b>Dependencies:</b>\n     * the components needed by this method can be created by the following methods:\n     * <ol>\n     *   <li>{@link #createCoordinateSystemAxis(Map, String, AxisDirection, Unit)}</li>\n     *   <li>{@link #createCartesianCS(Map, CoordinateSystemAxis, CoordinateSystemAxis, CoordinateSystemAxis)}</li>\n     *   <li>One of:<ul>\n     *     <li>{@link #createEllipsoid(Map, double, double, Unit)}</li>\n     *     <li>{@link #createFlattenedSphere(Map, double, double, Unit)}</li>\n     *   </ul></li>\n     *   <li>{@link #createPrimeMeridian(Map, double, Unit)}</li>\n     *   <li>{@link #createGeodeticDatum(Map, Ellipsoid, PrimeMeridian)}</li>\n     * </ol></div>\n     *\n     * The default implementation creates a {@link DefaultGeocentricCRS} instance.\n     *\n     * @param  properties  name and other properties to give to the new object.\n     * @param  datum       the geodetic datum to use in created CRS.\n     * @param  cs          the three-dimensional Cartesian coordinate system for the created CRS.\n     * @throws FactoryException if the object creation failed.\n     *\n     * @see GeodeticAuthorityFactory#createGeocentricCRS(String)\n     * @see DefaultGeocentricCRS#DefaultGeocentricCRS(Map, GeodeticDatum, CartesianCS)\n     */\n    @Override\n    public GeocentricCRS createGeocentricCRS(final Map<String,?> properties,\n            final GeodeticDatum datum, final CartesianCS cs) throws FactoryException\n    {\n        final DefaultGeocentricCRS crs;\n        try {\n            crs = new DefaultGeocentricCRS(complete(properties), datum, cs);\n        } catch (IllegalArgumentException exception) {\n            throw new InvalidGeodeticParameterException(exception);\n        }\n        return unique(\"createGeocentricCRS\", crs);\n    }\n    /**\n     * Creates a three-dimensional Cartesian coordinate system from the given set of axis.\n     * This coordinate system can be used with geocentric, engineering and derived CRS.\n     *\n     * <div class=\"note\"><b>Dependencies:</b>\n     * the components needed by this method can be created by the following methods:\n     * <ol>\n     *   <li>{@link #createCoordinateSystemAxis(Map, String, AxisDirection, Unit)}</li>\n     * </ol></div>\n     *\n     * The default implementation creates a {@link DefaultCartesianCS} instance.\n     *\n     * @param  properties  name and other properties to give to the new object.\n     * @param  axis0       the first  axis (e.g. \u201cGeocentric X\u201d).\n     * @param  axis1       the second axis (e.g. \u201cGeocentric Y\u201d).\n     * @param  axis2       the third  axis (e.g. \u201cGeocentric Z\u201d).\n     * @throws FactoryException if the object creation failed.\n     *\n     * @see DefaultCartesianCS#DefaultCartesianCS(Map, CoordinateSystemAxis, CoordinateSystemAxis, CoordinateSystemAxis)\n     * @see GeodeticAuthorityFactory#createCartesianCS(String)\n     */\n<fim_suffix>    @Override\n    public CartesianCS createCartesianCS(final Map<String,?> properties,\n            final CoordinateSystemAxis axis0,\n            final CoordinateSystemAxis axis1,\n            final CoordinateSystemAxis axis2) throws FactoryException\n    {\n        final DefaultCartesianCS cs;\n        try {\n            cs = new DefaultCartesianCS(complete(properties), axis0, axis1, axis2);\n        } catch (IllegalArgumentException exception) {\n            throw new InvalidGeodeticParameterException(exception);\n        }\n        return unique(\"createCartesianCS\", cs);\n    }<fim_middle>// function below has no smell\n"}