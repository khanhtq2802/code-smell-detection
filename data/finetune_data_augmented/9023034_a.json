{"text": "<fim_prefix>import org.apache.solr.common.SolrDocumentList;\nimport org.apache.solr.common.SolrException;\nimport org.apache.solr.common.params.CommonParams;\nimport org.apache.solr.common.params.ModifiableSolrParams;\nimport org.apache.solr.common.params.ShardParams;\nimport org.apache.solr.common.util.NamedList;\nimport org.apache.solr.common.util.SimpleOrderedMap;\nimport org.apache.solr.core.CloseHook;\nimport org.apache.solr.core.CoreContainer;\nimport org.apache.solr.core.PluginInfo;\nimport org.apache.solr.core.SolrCore;\nimport org.apache.solr.handler.RequestHandlerBase;\nimport org.apache.solr.request.SolrQueryRequest;\nimport org.apache.solr.response.SolrQueryResponse;\nimport org.apache.solr.search.SolrQueryTimeoutImpl;\nimport org.apache.solr.search.facet.FacetModule;\nimport org.apache.solr.security.AuthorizationContext;\nimport org.apache.solr.security.PermissionNameProvider;\nimport org.apache.solr.util.RTimerTree;\nimport org.apache.solr.util.SolrPluginUtils;\nimport org.apache.solr.util.plugin.PluginInfoInitialized;\nimport org.apache.solr.util.plugin.SolrCoreAware;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n/**\n *\n * Refer SOLR-281\n *\n */\npublic class SearchHandler extends RequestHandlerBase implements SolrCoreAware , PluginInfoInitialized, PermissionNameProvider {\n  static final String INIT_COMPONENTS = \"components\";\n  static final String INIT_FIRST_COMPONENTS = \"first-components\";\n  static final String INIT_LAST_COMPONENTS = \"last-components\";\n  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n  protected volatile List<SearchComponent> components;\n  private ShardHandlerFactory shardHandlerFactory ;\n  private PluginInfo shfInfo;\n  private SolrCore core;\n  protected List<String> getDefaultComponents()\n  {\n    ArrayList<String> names = new ArrayList<>(8);\n    names.add( QueryComponent.COMPONENT_NAME );\n    names.add( FacetComponent.COMPONENT_NAME );\n    names.add( FacetModule.COMPONENT_NAME );\n    names.add( MoreLikeThisComponent.COMPONENT_NAME );\n    names.add( HighlightComponent.COMPONENT_NAME );\n    names.add( StatsComponent.COMPONENT_NAME );\n    names.add( DebugComponent.COMPONENT_NAME );\n    names.add( ExpandComponent.COMPONENT_NAME);\n    names.add( TermsComponent.COMPONENT_NAME);\n    return names;\n  }\n  @Override\n  public void init(PluginInfo info) {\n    init(info.initArgs);\n    for (PluginInfo child : info.children) {\n      if(\"shardHandlerFactory\".equals(child.type)){\n        this.shfInfo = child;\n        break;\n      }\n    }\n  }\n  @Override\n  public PermissionNameProvider.Name getPermissionName(AuthorizationContext ctx) {\n    return PermissionNameProvider.Name.READ_PERM;\n  }\n  /**\n   * Initialize the components based on name.  Note, if using <code>INIT_FIRST_COMPONENTS</code> or <code>INIT_LAST_COMPONENTS</code>,\n   * then the {@link DebugComponent} will always occur last.  If this is not desired, then one must explicitly declare all components using\n   * the <code>INIT_COMPONENTS</code> syntax.\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void inform(SolrCore core)\n  {\n    this.core = core;\n    Set<String> missing = new HashSet<>();\n    List<String> c = (List<String>) initArgs.get(INIT_COMPONENTS);\n    missing.addAll(core.getSearchComponents().checkContains(c));\n    List<String> first = (List<String>) initArgs.get(INIT_FIRST_COMPONENTS);\n    missing.addAll(core.getSearchComponents().checkContains(first));\n    List<String> last = (List<String>) initArgs.get(INIT_LAST_COMPONENTS);\n    missing.addAll(core.getSearchComponents().checkContains(last));\n    if (!missing.isEmpty()) throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n        \"Missing SearchComponents named : \" + missing);\n    if (c != null && (first != null || last != null)) throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n        \"First/Last components only valid if you do not declare 'components'\");\n    if (shfInfo == null) {\n      shardHandlerFactory = core.getCoreContainer().getShardHandlerFactory();\n    } else {\n      shardHandlerFactory = core.createInitInstance(shfInfo, ShardHandlerFactory.class, null, null);\n      core.addCloseHook(new CloseHook() {\n        @Override\n        public void preClose(SolrCore core) {\n          shardHandlerFactory.close();\n        }\n        @Override\n        public void postClose(SolrCore core) {\n        }\n      });\n    }\n  }\n  private void initComponents() {\n    Object declaredComponents = initArgs.get(INIT_COMPONENTS);\n    List<String> first = (List<String>) initArgs.get(INIT_FIRST_COMPONENTS);\n    List<String> last  = (List<String>) initArgs.get(INIT_LAST_COMPONENTS);\n    List<String> list = null;\n    boolean makeDebugLast = true;\n    if( declaredComponents == null ) {\n      // Use the default component list\n      list = getDefaultComponents();\n      if( first != null ) {\n        List<String> clist = first;\n        clist.addAll( list );\n        list = clist;\n      }\n      if( last != null ) {\n        list.addAll( last );\n      }\n    }\n    else {\n      list = (List<String>)declaredComponents;\n      if( first != null || last != null ) {\n        throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n            \"First/Last components only valid if you do not declare 'components'\");\n      }\n      makeDebugLast = false;\n    }\n    // Build the component list\n    List<SearchComponent> components = new ArrayList<>(list.size());\n    DebugComponent dbgCmp = null;\n    for(String c : list){\n      SearchComponent comp = core.getSearchComponent( c );\n      if (comp instanceof DebugComponent && makeDebugLast == true){\n        dbgCmp = (DebugComponent) comp;\n      } else {\n        components.add(comp);\n        log.debug(\"Adding  component:{}\", comp);\n      }\n    }\n    if (makeDebugLast == true && dbgCmp != null){\n      components.add(dbgCmp);\n      log.debug(\"Adding  debug component:{}\", dbgCmp);\n    }\n    this.components = components;\n  }\n  public List<SearchComponent> getComponents() {\n    List<SearchComponent> result = components;  // volatile read\n    if (result == null) {\n      synchronized (this) {\n        if (components == null) {\n          initComponents();\n        }\n        result = components;\n      }\n    }\n    return result;\n  }\n<fim_suffix>  private ShardHandler getAndPrepShardHandler(SolrQueryRequest req, ResponseBuilder rb) {\n    ShardHandler shardHandler = null;\n    CoreContainer cc = req.getCore().getCoreContainer();\n    boolean isZkAware = cc.isZooKeeperAware();\n    rb.isDistrib = req.getParams().getBool(DISTRIB, isZkAware);\n    if (!rb.isDistrib) {\n      // for back compat, a shards param with URLs like localhost:8983/solr will mean that this\n      // search is distributed.\n      final String shards = req.getParams().get(ShardParams.SHARDS);\n      rb.isDistrib = ((shards != null) && (shards.indexOf('/') > 0));\n    }\n    if (rb.isDistrib) {\n      shardHandler = shardHandlerFactory.getShardHandler();\n      shardHandler.prepDistributed(rb);\n      if (!rb.isDistrib) {\n        shardHandler = null; // request is not distributed after all and so the shard handler is not needed\n      }\n    }\n    if (isZkAware) {\n      String shardsTolerant = req.getParams().get(ShardParams.SHARDS_TOLERANT);\n      boolean requireZkConnected = shardsTolerant != null && shardsTolerant.equals(ShardParams.REQUIRE_ZK_CONNECTED);\n      ZkController zkController = cc.getZkController();\n      boolean zkConnected = zkController != null && ! zkController.getZkClient().getConnectionManager().isLikelyExpired();\n      if (requireZkConnected && false == zkConnected) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ZooKeeper is not connected\");\n      } else {\n        NamedList<Object> headers = rb.rsp.getResponseHeader();\n        if (headers != null) {\n          headers.add(\"zkConnected\", zkConnected);\n        }\n      }\n    }\n    return shardHandler;\n  }<fim_middle>// function below is feature envy and long method\n"}