{"text": "<fim_prefix>                            if (cenlen64 != end.cenlen && end.cenlen != ZIP64_MAGICVAL ||\n                                cenoff64 != end.cenoff && end.cenoff != ZIP64_MAGICVAL ||\n                                centot64 != end.centot && end.centot != ZIP64_MAGICCOUNT) {\n                                return end;\n                            }\n                            // to use the end64 values\n                            end.cenlen = cenlen64;\n                            end.cenoff = cenoff64;\n                            end.centot = (int)centot64; // assume total < 2g\n                            end.endpos = end64pos;\n                        } catch (IOException x) {}    // no zip64 loc/end\n                        return end;\n                    }\n                }\n            }\n            zerror(\"zip END header not found\");\n            return null; //make compiler happy\n        }\n        // Reads zip file central directory.\n        private void initCEN(int knownTotal) throws IOException {\n            if (knownTotal == -1) {\n                End end = findEND();\n                if (end.endpos == 0) {\n                    locpos = 0;\n                    total = 0;\n                    entries  = new int[0];\n                    cen = null;\n                    return;         // only END header present\n                }\n                if (end.cenlen > end.endpos)\n                    zerror(\"invalid END header (bad central directory size)\");\n                long cenpos = end.endpos - end.cenlen;     // position of CEN table\n                // Get position of first local file (LOC) header, taking into\n                // account that there may be a stub prefixed to the zip file.\n                locpos = cenpos - end.cenoff;\n                if (locpos < 0) {\n                    zerror(\"invalid END header (bad central directory offset)\");\n                }\n                // read in the CEN and END\n                cen = new byte[(int)(end.cenlen + ENDHDR)];\n                if (readFullyAt(cen, 0, cen.length, cenpos) != end.cenlen + ENDHDR) {\n                    zerror(\"read CEN tables failed\");\n                }\n                total = end.centot;\n            } else {\n                total = knownTotal;\n            }\n            // hash table for entries\n            entries  = new int[total * 3];\n            tablelen = ((total/2) | 1); // Odd -> fewer collisions\n            table    =  new int[tablelen];\n            Arrays.fill(table, ZIP_ENDCHAIN);\n            int idx = 0;\n            int hash = 0;\n            int next = -1;\n            // list for all meta entries\n            ArrayList<Integer> metanamesList = null;\n            // Iterate through the entries in the central directory\n            int i = 0;\n            int hsh = 0;\n            int pos = 0;\n            int limit = cen.length - ENDHDR;\n            while (pos + CENHDR <= limit) {\n                if (i >= total) {\n                    // This will only happen if the zip file has an incorrect\n                    // ENDTOT field, which usually means it contains more than\n                    // 65535 entries.\n                    initCEN(countCENHeaders(cen, limit));\n                    return;\n                }\n                if (CENSIG(cen, pos) != CENSIG)\n                    zerror(\"invalid CEN header (bad signature)\");\n                int method = CENHOW(cen, pos);\n                int nlen   = CENNAM(cen, pos);\n                int elen   = CENEXT(cen, pos);\n                int clen   = CENCOM(cen, pos);\n                if ((CENFLG(cen, pos) & 1) != 0)\n                    zerror(\"invalid CEN header (encrypted entry)\");\n                if (method != STORED && method != DEFLATED)\n                    zerror(\"invalid CEN header (bad compression method: \" + method + \")\");\n                if (pos + CENHDR + nlen > limit)\n                    zerror(\"invalid CEN header (bad header size)\");\n                // Record the CEN offset and the name hash in our hash cell.\n                hash = hashN(cen, pos + CENHDR, nlen);\n                hsh = (hash & 0x7fffffff) % tablelen;\n                next = table[hsh];\n                table[hsh] = idx;\n                idx = addEntry(idx, hash, next, pos);\n                // Adds name to metanames.\n                if (isMetaName(cen, pos + CENHDR, nlen)) {\n                    if (metanamesList == null)\n                        metanamesList = new ArrayList<>(4);\n                    metanamesList.add(pos);\n                }\n                // skip ext and comment\n                pos += (CENHDR + nlen + elen + clen);\n                i++;\n            }\n            total = i;\n            if (metanamesList != null) {\n                metanames = new int[metanamesList.size()];\n                for (int j = 0, len = metanames.length; j < len; j++) {\n                    metanames[j] = metanamesList.get(j);\n                }\n            }\n            if (pos + ENDHDR != cen.length) {\n                zerror(\"invalid CEN header (bad header size)\");\n            }\n        }\n        private static void zerror(String msg) throws ZipException {\n            throw new ZipException(msg);\n        }\n        /*\n         * Returns the {@code pos} of the zip cen entry corresponding to the\n         * specified entry name, or -1 if not found.\n         */\n        private int getEntryPos(byte[] name, boolean addSlash) {\n            if (total == 0) {\n                return -1;\n            }\n            int hsh = hashN(name, 0, name.length);\n            int idx = table[(hsh & 0x7fffffff) % tablelen];\n            /*\n             * This while loop is an optimization where a double lookup\n             * for name and name+/ is being performed. The name char\n             * array has enough room at the end to try again with a\n             * slash appended if the first table lookup does not succeed.\n             */\n            while (true) {\n                /*\n                 * Search down the target hash chain for a entry whose\n                 * 32 bit hash matches the hashed name.\n                 */\n                while (idx != ZIP_ENDCHAIN) {\n                    if (getEntryHash(idx) == hsh) {\n                        // The CEN name must match the specfied one\n                        int pos = getEntryPos(idx);\n                        if (name.length == CENNAM(cen, pos)) {\n                            boolean matched = true;\n                            int nameoff = pos + CENHDR;\n                            for (int i = 0; i < name.length; i++) {\n                                if (name[i] != cen[nameoff++]) {\n                                    matched = false;\n                                    break;\n                                }\n                            }\n                            if (matched) {\n                                return pos;\n                            }\n                         }\n                    }\n                    idx = getEntryNext(idx);\n                }\n                /* If not addSlash, or slash is already there, we are done */\n                if (!addSlash  || name.length == 0 || name[name.length - 1] == '/') {\n                     return -1;\n                }\n                /* Add slash and try once more */\n                name = Arrays.copyOf(name, name.length + 1);\n                name[name.length - 1] = '/';\n                hsh = hash_append(hsh, (byte)'/');\n                //idx = table[hsh % tablelen];\n                idx = table[(hsh & 0x7fffffff) % tablelen];\n                addSlash = false;\n            }\n        }\n        /**\n         * Returns true if the bytes represent a non-directory name\n         * beginning with \"META-INF/\", disregarding ASCII case.\n         */\n<fim_suffix>        private static boolean isMetaName(byte[] name, int off, int len) {\n            // Use the \"oldest ASCII trick in the book\"\n            return len > 9                     // \"META-INF/\".length()\n                && name[off + len - 1] != '/'  // non-directory\n                && (name[off++] | 0x20) == 'm'\n                && (name[off++] | 0x20) == 'e'\n                && (name[off++] | 0x20) == 't'\n                && (name[off++] | 0x20) == 'a'\n                && (name[off++]       ) == '-'\n                && (name[off++] | 0x20) == 'i'\n                && (name[off++] | 0x20) == 'n'\n                && (name[off++] | 0x20) == 'f'\n                && (name[off]         ) == '/';\n        }<fim_middle>// function below has no smell\n"}