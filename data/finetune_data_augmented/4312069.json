{"text": "<fim_prefix>                }\n            }\n            converted[nbNeededBytes - 1] &= 0x7F;\n            // Copy the converted bytes in the buffer\n            System.arraycopy( converted, 0, buffer, posBuffer, nbNeededBytes );\n            return nbNeededBytes;\n        }\n    }\n    /**\n     * Returns an OID object representing <code>oidString</code>.  \n     *  \n     * @param oidString The string representation of the OID\n     * @return A new Oid\n     * @throws DecoderException  When the OID is not valid\n     */\n    public static Oid fromString( String oidString ) throws DecoderException\n    {\n        if ( ( oidString == null ) || oidString.isEmpty() )\n        {\n            throw new DecoderException( I18n.err( I18n.ERR_00003_INVALID_OID, \"empty\" ) );\n        }\n        // Create a buffer that is wide enough to contain all the values\n        byte[] buffer = new byte[oidString.length()];\n        OidFSAState state = OidFSAState.START;\n        // A counter of chars used for an arc. In 1.2.45345, this counter will be 5 for the '45345' arc.\n        int arcNbChars = 0;\n        // The position in the buffer where we accumulate the result. \n        int bufPos = 0;\n        // The position in the OID string where we started to read an arc\n        int startArc = 0;\n        // The number of bytes in the resulting OID byte[]\n        int nbBytes;\n        for ( int i = 0; i < oidString.length(); i++ )\n        {\n            switch ( state )\n            {\n                case START :\n                    // (Start) --['0'..'1']--> (A)\n                    // (start) --['2']--> (F)\n                    state = processStateStart( oidString, buffer, i );\n                    break;\n                case STATE_A :\n                    // (A) --['.']--> (B)\n                    state = processStateA( oidString, i );\n                    break;\n                case STATE_B :\n                    // (B) --['0']--> (D)\n                    // (B) --['1'..'3']--> (C)\n                    // (B) --['4'..'9']--> (E)\n                    state = processStateB( oidString, buffer, i );\n                    break;\n                case STATE_C :\n                    // (C) --['.']--> (K)\n                    // (C) --['0'..'9']--> (E)\n                    state = processStateC( oidString, buffer, i );\n                    // the next arc will be store at position 1 in the buffer\n                    bufPos = 1;\n                    break;\n                case STATE_D :\n                    // (D) --['.']--> (K)\n                    // Fallthrough\n                case STATE_E :\n                    // (E) --['.']--> (K)\n                    state = processStateDE( oidString, buffer, i );\n                    // the next arc will be store at position 1 in teh buffer\n                    bufPos = 1;\n                    break;\n                case STATE_F :\n                    // (F) --['.']--> (G)\n                    state = processStateF( oidString, i );\n                    break;\n                case STATE_G :\n                    // (G) --['0']--> (I)\n                    // (G) --['1'..'9']--> (H)\n                    state = processStateG( oidString, buffer, i );\n                    arcNbChars = 1;\n                    startArc = i;\n                    break;\n                case STATE_H :\n                    // (H) --['.']--> (K)\n                    // (H) --['0'..'9']--> (J)\n                    state = processStateH( oidString, buffer, i );\n                    if ( state == OidFSAState.STATE_J )\n                    {\n                        // We have already two digits\n                        arcNbChars = 2;\n                        bufPos = 0;\n                    }\n                    break;\n                case STATE_I :\n                    // (I) --['.']--> (K)\n                    state = processStateI( oidString, buffer, i );\n                    // Set the arc position to buffer[1], we haven't yet accumulated digits.\n                    bufPos = 1;\n                    break;\n                case STATE_J :\n                    // (J) --['.']--> (K)\n                    // (J) --['0'..'9']--> (J)\n                    state = processStateJ( oidString, buffer, arcNbChars + bufPos, i );\n                    if ( state == OidFSAState.STATE_J )\n                    {\n                        // We can increment the number of digit for this arc\n                        arcNbChars++;\n                    }\n                    else\n                    {\n                        // We are done with the first arc : convert it\n                        bufPos += convert( oidString, buffer, bufPos, arcNbChars, 0, true );\n                    }\n                    break;\n                case STATE_K :\n                    startArc = i;\n                    state = processStateK( oidString, buffer, bufPos, i );\n                    if ( state == OidFSAState.STATE_M )\n                    { \n                        bufPos++;\n                    }\n                    else\n                    {\n                        arcNbChars = 1;\n                    }\n                    break;\n                case STATE_L :\n                    state = processStateL( oidString, buffer, arcNbChars + bufPos, i );\n                    if ( state == OidFSAState.STATE_L )\n                    {\n                        arcNbChars++;\n                        break;\n                    }\n                    else\n                    {\n                        // We are done with the arc : convert it\n                        bufPos += convert( oidString, buffer, startArc, arcNbChars, bufPos, false );\n                    }\n                    break;\n                case STATE_M :\n                    state = processStateM( oidString, i );\n                    break;\n                default :\n                    // Exist to please checkstyle...\n                    break;\n            }\n        }\n        // End of the string : check that we are in a correct state for a completion\n        // The only valid exit states are :\n        // (C) --[]--> (End)\n        // (D) --[]--> (End)\n        // (E) --[]--> (End)\n        // (H) --[]--> (End)\n        // (I) --[]--> (End)\n        // (J) --[]--> (End)\n        // (L) --[]--> (End)\n        // (M) --[]--> (End)\n        switch ( state )\n        {\n            case STATE_C :\n                // (C) --[]--> (End)\n                // fallthrough\n            case STATE_D :\n                // (D) --[]--> (End)\n                // fallthrough\n            case STATE_E :\n                // (E) --[]--> (End)\n                // fallthrough\n            case STATE_H :\n                // (H) --[]--> (End)\n                // fallthrough\n            case STATE_I :\n                // (I) --[]--> (End)\n                byte[] bytes = new byte[1];\n                bytes[0] = ( byte ) ( buffer[0] | buffer[1] );\n                return new Oid( oidString, bytes );\n            case STATE_J :\n                // (J) --[]--> (End)\n                nbBytes = convert( oidString, buffer, 2, arcNbChars, 0, true );\n                bytes = new byte[nbBytes];\n                System.arraycopy( buffer, 0, bytes, 0, nbBytes );\n                return new Oid( oidString, bytes );\n            case STATE_L :\n                bufPos += convert( oidString, buffer, startArc, arcNbChars, bufPos, false );\n                bytes = new byte[bufPos];\n                System.arraycopy( buffer, 0, bytes, 0, bufPos );\n                return new Oid( oidString, bytes );\n            case STATE_M :\n                bytes = new byte[bufPos];\n                System.arraycopy( buffer, 0, bytes, 0, bufPos );\n                return new Oid( oidString, bytes );\n            default :\n                // This should never happen...\n                throw new DecoderException( I18n.err( I18n.ERR_00003_INVALID_OID, \"Wrong OID\" ) );\n        }\n    }\n    /**\n     * Returns the length of the encoded <code>byte[]</code> representation.\n     * \n     * @return The length of the byte[]\n     */\n    public int getEncodedLength()\n    {\n        return oidBytes.length;\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int hashCode()\n    {\n        return oidString.hashCode();\n    }\n    /**\n     * Returns true if <code>oidString</code> is a valid string representation\n     * of an OID.  This method simply calls {@link #fromString(String)} and \n     * returns true if no exception was thrown.  As such, it should not be used \n     * in an attempt to check if a string is a valid OID before calling \n     * {@link #fromString(String)}.\n     * \n     * @param oidString The string to test\n     * @return True, if <code>oidString</code> is valid\n     */\n<fim_suffix>    public static boolean isOid( String oidString )\n    {\n        try\n        {\n            Oid.fromString( oidString );\n            return true;\n        }\n        catch ( DecoderException e )\n        {\n            return false;\n        }\n    }<fim_middle>// function below has no smell\n"}