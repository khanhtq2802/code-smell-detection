{"text": "<fim_prefix>/*\n * Copyright 2012-2013 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.springframework.batch.core.job.builder;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport org.springframework.batch.core.ExitStatus;\nimport org.springframework.batch.core.Step;\nimport org.springframework.batch.core.job.flow.Flow;\nimport org.springframework.batch.core.job.flow.FlowExecutionStatus;\nimport org.springframework.batch.core.job.flow.JobExecutionDecider;\nimport org.springframework.batch.core.job.flow.State;\nimport org.springframework.batch.core.job.flow.support.SimpleFlow;\nimport org.springframework.batch.core.job.flow.support.StateTransition;\nimport org.springframework.batch.core.job.flow.support.state.DecisionState;\nimport org.springframework.batch.core.job.flow.support.state.EndState;\nimport org.springframework.batch.core.job.flow.support.state.FlowState;\nimport org.springframework.batch.core.job.flow.support.state.SplitState;\nimport org.springframework.batch.core.job.flow.support.state.StepState;\nimport org.springframework.core.task.TaskExecutor;\n/**\n * A builder for a flow of steps that can be executed as a job or as part of a job. Steps can be linked together with\n * conditional transitions that depend on the exit status of the previous step.\n *\n * @author Dave Syer\n *\n * @since 2.2\n *\n * @param <Q> the type of object returned by the builder (by default a Flow)\n *\n */\npublic class FlowBuilder<Q> {\n\tprivate String name;\n\tprivate String prefix;\n\tprivate List<StateTransition> transitions = new ArrayList<>();\n\tprivate Map<String, State> tos = new HashMap<>();\n\tprivate State currentState;\n\tprivate EndState failedState;\n\tprivate EndState completedState;\n\tprivate EndState stoppedState;\n\tprivate int decisionCounter = 0;\n\tprivate int splitCounter = 0;\n\tprivate int endCounter = 0;\n\tprivate Map<Object, State> states = new HashMap<>();\n\tprivate SimpleFlow flow;\n\tprivate boolean dirty = true;\n\tpublic FlowBuilder(String name) {\n\t\tthis.name = name;\n\t\tthis.prefix = name + \".\";\n\t\tthis.failedState = new EndState(FlowExecutionStatus.FAILED, prefix + \"FAILED\");\n\t\tthis.completedState = new EndState(FlowExecutionStatus.COMPLETED, prefix + \"COMPLETED\");\n\t\tthis.stoppedState = new EndState(FlowExecutionStatus.STOPPED, prefix + \"STOPPED\");\n\t}\n\t/**\n\t * Validate the current state of the builder and build a flow. Subclasses may override this to build an object of a\n\t * different type that itself depends on the flow.\n\t *\n\t * @return a flow\n\t */\n<fim_suffix>\tpublic Q build() {\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tQ result = (Q) flow();\n\t\treturn result;\n\t}\n\t/**\n\t * Transition to the next step on successful completion of the current step. All other outcomes are treated as\n\t * failures.\n\t *\n\t * @param step the next step\n\t * @return this to enable chaining\n\t */\n\tpublic FlowBuilder<Q> next(Step step) {\n\t\tdoNext(step);\n\t\treturn this;\n\t}\n\t/**\n\t * Start a flow. If some steps are already registered, just a synonym for {@link #from(Step)}.\n\t *\n\t * @param step the step to start with\n\t * @return this to enable chaining\n\t */\n\tpublic FlowBuilder<Q> start(Step step) {\n\t\tdoStart(step);\n\t\treturn this;\n\t}\n\t/**\n\t * Go back to a previously registered step and start a new path. If no steps are registered yet just a synonym for\n\t * {@link #start(Step)}.\n\t *\n\t * @param step the step to start from (already registered)\n\t * @return this to enable chaining\n\t */\n\tpublic FlowBuilder<Q> from(Step step) {\n\t\tdoFrom(step);\n\t\treturn this;\n\t}\n\t/**\n\t * Transition to the decider on successful completion of the current step. All other outcomes are treated as\n\t * failures.\n\t *\n\t * @param decider the JobExecutionDecider to determine the next step to execute\n\t * @return this to enable chaining\n\t */\n\tpublic UnterminatedFlowBuilder<Q> next(JobExecutionDecider decider) {\n\t\tdoNext(decider);\n\t\treturn new UnterminatedFlowBuilder<>(this);\n\t}\n\t/**\n\t * If a flow should start with a decision use this as the first state.\n\t *\n\t * @param decider the to start from\n\t * @return a builder to enable chaining\n\t */\n\tpublic UnterminatedFlowBuilder<Q> start(JobExecutionDecider decider) {\n\t\tdoStart(decider);\n\t\treturn new UnterminatedFlowBuilder<>(this);\n\t}\n\t/**\n\t * Start again from a decision that was already registered.\n\t *\n\t * @param decider the decider to start from (already registered)\n\t * @return a builder to enable chaining\n\t */\n\tpublic UnterminatedFlowBuilder<Q> from(JobExecutionDecider decider) {\n\t\tdoFrom(decider);\n\t\treturn new UnterminatedFlowBuilder<>(this);\n\t}\n\t/**\n\t * Go next on successful completion to a subflow.\n\t *\n\t * @param flow the flow to go to\n\t * @return a builder to enable chaining\n\t */\n\tpublic FlowBuilder<Q> next(Flow flow) {\n\t\tdoNext(flow);\n\t\treturn this;\n\t}\n\t/**\n\t * Start again from a subflow that was already registered.\n\t *\n\t * @param flow the flow to start from (already registered)\n\t * @return a builder to enable chaining\n\t */\n\tpublic FlowBuilder<Q> from(Flow flow) {\n\t\tdoFrom(flow);\n\t\treturn this;\n\t}\n\t/**\n\t * If a flow should start with a subflow use this as the first state.\n\t *\n\t * @param flow the flow to start from\n\t * @return a builder to enable chaining\n\t */\n\tpublic FlowBuilder<Q> start(Flow flow) {\n\t\tdoStart(flow);\n\t\treturn this;\n\t}\n\t/**\n\t * @param executor a task executor to execute the split flows\n\t * @return a builder to enable fluent chaining\n\t */\n\tpublic SplitBuilder<Q> split(TaskExecutor executor) {\n\t\treturn new SplitBuilder<>(this, executor);\n\t}\n\t/**\n\t * Start a transition to a new state if the exit status from the previous state matches the pattern given.\n\t * Successful completion normally results in an exit status equal to (or starting with by convention) \"COMPLETED\".\n\t * See {@link ExitStatus} for commonly used values.\n\t *\n\t * @param pattern the pattern of exit status on which to take this transition\n\t * @return a builder to enable fluent chaining\n\t */\n\tpublic TransitionBuilder<Q> on(String pattern) {\n\t\treturn new TransitionBuilder<>(this, pattern);\n\t}\n\t/**\n\t * A synonym for {@link #build()} which callers might find useful. Subclasses can override build to create an object\n\t * of the desired type (e.g. a parent builder or an actual flow).\n\t *\n\t * @return the result of the builder\n\t */\n\tpublic final Q end() {\n\t\treturn build();\n\t}\n\tprotected Flow flow() {\n\t\tif (!dirty) {\n\t\t\t// optimization in case this method is called consecutively\n\t\t\treturn flow;\n\t\t}\n\t\tflow = new SimpleFlow(name);\n\t\t// optimization for flows that only have one state that itself is a flow:\n\t\tif (currentState instanceof FlowState && states.size() == 1) {\n\t\t\treturn ((FlowState) currentState).getFlows().iterator().next();\n\t\t}\n\t\taddDanglingEndStates();<fim_middle>// function below has no smell\n"}