{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.apache.hadoop.ozone.client.io;\nimport com.google.common.annotations.VisibleForTesting;\nimport org.apache.hadoop.fs.FSExceptionMessages;\nimport org.apache.hadoop.fs.Seekable;\nimport org.apache.hadoop.hdds.protocol.datanode.proto.ContainerProtos;\nimport org.apache.hadoop.hdds.client.BlockID;\nimport org.apache.hadoop.hdds.protocol.proto.HddsProtos;\nimport org.apache.hadoop.hdds.scm.pipeline.Pipeline;\nimport org.apache.hadoop.hdds.scm.protocol.StorageContainerLocationProtocol;\nimport org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\nimport org.apache.hadoop.ozone.om.helpers.OmKeyLocationInfo;\nimport org.apache.hadoop.hdds.scm.XceiverClientManager;\nimport org.apache.hadoop.hdds.scm.XceiverClientSpi;\nimport org.apache.hadoop.hdds.scm.storage.BlockInputStream;\nimport org.apache.hadoop.hdds.scm.storage.ContainerProtocolCalls;\nimport org.apache.hadoop.security.UserGroupInformation;\nimport org.apache.ratis.util.Preconditions;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n/**\n * Maintaining a list of BlockInputStream. Read based on offset.\n */\npublic class KeyInputStream extends InputStream implements Seekable {\n  private static final Logger LOG =\n      LoggerFactory.getLogger(KeyInputStream.class);\n  private static final int EOF = -1;\n  private final ArrayList<ChunkInputStreamEntry> streamEntries;\n  // streamOffset[i] stores the offset at which blockInputStream i stores\n  // data in the key\n  private long[] streamOffset = null;\n  private int currentStreamIndex;\n  private long length = 0;\n  private boolean closed = false;\n  private String key;\n  public KeyInputStream() {\n    streamEntries = new ArrayList<>();\n    currentStreamIndex = 0;\n  }\n  @VisibleForTesting\n  public synchronized int getCurrentStreamIndex() {\n    return currentStreamIndex;\n  }\n  @VisibleForTesting\n  public long getRemainingOfIndex(int index) throws IOException {\n    return streamEntries.get(index).getRemaining();\n  }\n  /**\n   * Append another stream to the end of the list.\n   *\n   * @param stream       the stream instance.\n   * @param streamLength the max number of bytes that should be written to this\n   *                     stream.\n   */\n  public synchronized void addStream(BlockInputStream stream,\n      long streamLength) {\n    streamEntries.add(new ChunkInputStreamEntry(stream, streamLength));\n  }\n  @Override\n  public synchronized int read() throws IOException {\n    byte[] buf = new byte[1];\n    if (read(buf, 0, 1) == EOF) {\n      return EOF;\n    }\n    return Byte.toUnsignedInt(buf[0]);\n  }\n  @Override\n  public synchronized int read(byte[] b, int off, int len) throws IOException {\n    checkNotClosed();\n    if (b == null) {\n      throw new NullPointerException();\n    }\n    if (off < 0 || len < 0 || len > b.length - off) {\n      throw new IndexOutOfBoundsException();\n    }\n    if (len == 0) {\n      return 0;\n    }\n    int totalReadLen = 0;\n    while (len > 0) {\n      // if we are at the last block and have read the entire block, return\n      if (streamEntries.size() == 0 ||\n              (streamEntries.size() - 1 <= currentStreamIndex &&\n                      streamEntries.get(currentStreamIndex)\n                              .getRemaining() == 0)) {\n        return totalReadLen == 0 ? EOF : totalReadLen;\n      }\n      ChunkInputStreamEntry current = streamEntries.get(currentStreamIndex);\n      int numBytesToRead = Math.min(len, (int)current.getRemaining());\n      int numBytesRead = current.read(b, off, numBytesToRead);\n      if (numBytesRead != numBytesToRead) {\n        // This implies that there is either data loss or corruption in the\n        // chunk entries. Even EOF in the current stream would be covered in\n        // this case.\n        throw new IOException(String.format(\n            \"Inconsistent read for blockID=%s length=%d numBytesRead=%d\",\n            current.blockInputStream.getBlockID(), current.length,\n            numBytesRead));\n      }\n      totalReadLen += numBytesRead;\n      off += numBytesRead;\n      len -= numBytesRead;\n      if (current.getRemaining() <= 0 &&\n          ((currentStreamIndex + 1) < streamEntries.size())) {\n        currentStreamIndex += 1;\n      }\n    }\n    return totalReadLen;\n  }\n  @Override\n  public void seek(long pos) throws IOException {\n    checkNotClosed();\n    if (pos < 0 || pos >= length) {\n      if (pos == 0) {\n        // It is possible for length and pos to be zero in which case\n        // seek should return instead of throwing exception\n        return;\n      }\n      throw new EOFException(\n          \"EOF encountered at pos: \" + pos + \" for key: \" + key);\n    }\n    Preconditions.assertTrue(currentStreamIndex >= 0);\n    if (currentStreamIndex >= streamEntries.size()) {\n      currentStreamIndex = Arrays.binarySearch(streamOffset, pos);\n    } else if (pos < streamOffset[currentStreamIndex]) {\n      currentStreamIndex =\n          Arrays.binarySearch(streamOffset, 0, currentStreamIndex, pos);\n    } else if (pos >= streamOffset[currentStreamIndex] + streamEntries\n        .get(currentStreamIndex).length) {\n      currentStreamIndex = Arrays\n          .binarySearch(streamOffset, currentStreamIndex + 1,\n              streamEntries.size(), pos);\n    }\n    if (currentStreamIndex < 0) {\n      // Binary search returns -insertionPoint - 1  if element is not present\n      // in the array. insertionPoint is the point at which element would be\n      // inserted in the sorted array. We need to adjust the currentStreamIndex\n      // accordingly so that currentStreamIndex = insertionPoint - 1\n      currentStreamIndex = -currentStreamIndex - 2;\n    }\n    // seek to the proper offset in the BlockInputStream\n    streamEntries.get(currentStreamIndex)\n        .seek(pos - streamOffset[currentStreamIndex]);\n  }\n  @Override\n  public long getPos() throws IOException {\n    return length == 0 ? 0 :\n        streamOffset[currentStreamIndex] + streamEntries.get(currentStreamIndex)\n            .getPos();\n  }\n  @Override\n  public boolean seekToNewSource(long targetPos) throws IOException {\n    return false;\n  }\n  @Override\n  public int available() throws IOException {\n    checkNotClosed();\n    long remaining = length - getPos();\n    return remaining <= Integer.MAX_VALUE ? (int) remaining : Integer.MAX_VALUE;\n  }\n  @Override\n  public void close() throws IOException {\n    closed = true;\n    for (int i = 0; i < streamEntries.size(); i++) {\n      streamEntries.get(i).close();\n    }\n  }\n  /**\n   * Encapsulates BlockInputStream.\n   */\n  public static class ChunkInputStreamEntry extends InputStream\n      implements Seekable {\n    private final BlockInputStream blockInputStream;\n    private final long length;\n    public ChunkInputStreamEntry(BlockInputStream blockInputStream,\n        long length) {\n      this.blockInputStream = blockInputStream;\n      this.length = length;\n    }\n    synchronized long getRemaining() throws IOException {\n      return length - getPos();\n    }\n    @Override\n    public synchronized int read(byte[] b, int off, int len)\n        throws IOException {\n      int readLen = blockInputStream.read(b, off, len);\n      return readLen;\n    }\n<fim_suffix>    @Override\n    public synchronized int read() throws IOException {\n      int data = blockInputStream.read();\n      return data;\n    }\n    @Override\n    public synchronized void close() throws IOException {\n      blockInputStream.close();\n    }\n    @Override\n    public void seek(long pos) throws IOException {<fim_middle>// function below has no smell\n"}