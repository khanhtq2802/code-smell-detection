{"text": "<fim_prefix>import jdk.nashorn.internal.runtime.Undefined;\n/**\n * Literal nodes represent JavaScript values.\n *\n * @param <T> the literal type\n */\n@Immutable\npublic abstract class LiteralNode<T> extends Expression implements PropertyKey {\n    private static final long serialVersionUID = 1L;\n    /** Literal value */\n    protected final T value;\n    /** Marker for values that must be computed at runtime */\n    public static final Object POSTSET_MARKER = new Object();\n    /**\n     * Constructor\n     *\n     * @param token   token\n     * @param finish  finish\n     * @param value   the value of the literal\n     */\n    protected LiteralNode(final long token, final int finish, final T value) {\n        super(token, finish);\n        this.value = value;\n    }\n    /**\n     * Copy constructor\n     *\n     * @param literalNode source node\n     */\n    protected LiteralNode(final LiteralNode<T> literalNode) {\n        this(literalNode, literalNode.value);\n    }\n    /**\n     * A copy constructor with value change.\n     * @param literalNode the original literal node\n     * @param newValue new value for this node\n     */\n    protected LiteralNode(final LiteralNode<T> literalNode, final T newValue) {\n        super(literalNode);\n        this.value = newValue;\n    }\n    /**\n     * Initialization setter, if required for immutable state. This is used for\n     * things like ArrayLiteralNodes that need to carry state for the splitter.\n     * Default implementation is just a nop.\n     * @param lc lexical context\n     * @return new literal node with initialized state, or same if nothing changed\n     */\n    public LiteralNode<?> initialize(final LexicalContext lc) {\n        return this;\n    }\n    /**\n     * Check if the literal value is null\n     * @return true if literal value is null\n     */\n    public boolean isNull() {\n        return value == null;\n    }\n    @Override\n    public Type getType() {\n        return Type.typeFor(value.getClass());\n    }\n    @Override\n    public String getPropertyName() {\n        return JSType.toString(getObject());\n    }\n    /**\n     * Fetch boolean value of node.\n     *\n     * @return boolean value of node.\n     */\n    public boolean getBoolean() {\n        return JSType.toBoolean(value);\n    }\n    /**\n     * Fetch int32 value of node.\n     *\n     * @return Int32 value of node.\n     */\n    public int getInt32() {\n        return JSType.toInt32(value);\n    }\n    /**\n     * Fetch uint32 value of node.\n     *\n     * @return uint32 value of node.\n     */\n    public long getUint32() {\n        return JSType.toUint32(value);\n    }\n    /**\n     * Fetch long value of node\n     *\n     * @return long value of node\n     */\n    public long getLong() {\n        return JSType.toLong(value);\n    }\n    /**\n     * Fetch double value of node.\n     *\n     * @return double value of node.\n     */\n    public double getNumber() {\n        return JSType.toNumber(value);\n    }\n    /**\n     * Fetch String value of node.\n     *\n     * @return String value of node.\n     */\n    public String getString() {\n        return JSType.toString(value);\n    }\n    /**\n     * Fetch Object value of node.\n     *\n     * @return Object value of node.\n     */\n    public Object getObject() {\n        return value;\n    }\n    /**\n     * Test if the value is an array\n     *\n     * @return True if value is an array\n     */\n    public boolean isArray() {\n        return false;\n    }\n    public List<Expression> getElementExpressions() {\n        return null;\n    }\n    /**\n     * Test if the value is a boolean.\n     *\n     * @return True if value is a boolean.\n     */\n    public boolean isBoolean() {\n        return value instanceof Boolean;\n    }\n    /**\n     * Test if the value is a string.\n     *\n     * @return True if value is a string.\n     */\n    public boolean isString() {\n        return value instanceof String;\n    }\n    /**\n     * Test if tha value is a number\n     *\n     * @return True if value is a number\n     */\n    public boolean isNumeric() {\n        return value instanceof Number;\n    }\n    /**\n     * Assist in IR navigation.\n     *\n     * @param visitor IR navigating visitor.\n     */\n    @Override\n    public Node accept(final NodeVisitor<? extends LexicalContext> visitor) {\n        if (visitor.enterLiteralNode(this)) {\n            return visitor.leaveLiteralNode(this);\n        }\n        return this;\n    }\n    @Override\n    public void toString(final StringBuilder sb, final boolean printType) {\n        if (value == null) {\n            sb.append(\"null\");\n        } else {\n            sb.append(value.toString());\n        }\n    }\n    /**\n     * Get the literal node value\n     * @return the value\n     */\n    public final T getValue() {\n        return value;\n    }\n    private static Expression[] valueToArray(final List<Expression> value) {\n        return value.toArray(new Expression[0]);\n    }\n    /**\n     * Create a new null literal\n     *\n     * @param token   token\n     * @param finish  finish\n     *\n     * @return the new literal node\n     */\n    public static LiteralNode<Object> newInstance(final long token, final int finish) {\n        return new NullLiteralNode(token, finish);\n    }\n    /**\n     * Create a new null literal based on a parent node (source, token, finish)\n     *\n     * @param parent parent node\n     *\n     * @return the new literal node\n     */\n    public static LiteralNode<Object> newInstance(final Node parent) {\n        return new NullLiteralNode(parent.getToken(), parent.getFinish());\n    }\n    /**\n     * Super class for primitive (side-effect free) literals.\n     *\n     * @param <T> the literal type\n     */\n    public static class PrimitiveLiteralNode<T> extends LiteralNode<T> {\n        private static final long serialVersionUID = 1L;\n        private PrimitiveLiteralNode(final long token, final int finish, final T value) {\n            super(token, finish, value);\n        }\n        private PrimitiveLiteralNode(final PrimitiveLiteralNode<T> literalNode) {\n            super(literalNode);\n        }\n        /**\n         * Check if the literal value is boolean true\n         * @return true if literal value is boolean true\n         */\n        public boolean isTrue() {\n            return JSType.toBoolean(value);\n        }\n        @Override\n        public boolean isLocal() {\n            return true;\n        }\n        @Override\n        public boolean isAlwaysFalse() {\n            return !isTrue();\n        }\n        @Override\n        public boolean isAlwaysTrue() {\n            return isTrue();\n        }\n    }\n    @Immutable\n    private static final class BooleanLiteralNode extends PrimitiveLiteralNode<Boolean> {\n        private static final long serialVersionUID = 1L;\n        private BooleanLiteralNode(final long token, final int finish, final boolean value) {\n            super(Token.recast(token, value ? TokenType.TRUE : TokenType.FALSE), finish, value);\n        }\n        private BooleanLiteralNode(final BooleanLiteralNode literalNode) {\n            super(literalNode);\n        }\n        @Override\n        public boolean isTrue() {\n            return value;\n        }\n        @Override\n        public Type getType() {\n            return Type.BOOLEAN;\n        }\n        @Override\n        public Type getWidestOperationType() {\n            return Type.BOOLEAN;\n        }\n    }\n    /**\n     * Create a new boolean literal\n     *\n     * @param token   token\n     * @param finish  finish\n     * @param value   true or false\n     *\n     * @return the new literal node\n     */\n    public static LiteralNode<Boolean> newInstance(final long token, final int finish, final boolean value) {\n        return new BooleanLiteralNode(token, finish, value);\n    }\n    /**\n     * Create a new boolean literal based on a parent node (source, token, finish)\n     *\n     * @param parent parent node\n     * @param value  true or false\n     *\n     * @return the new literal node\n     */\n    public static LiteralNode<?> newInstance(final Node parent, final boolean value) {\n        return new BooleanLiteralNode(parent.getToken(), parent.getFinish(), value);\n    }\n<fim_suffix>    @Immutable\n    private static final class NumberLiteralNode extends PrimitiveLiteralNode<Number> {\n        private static final long serialVersionUID = 1L;\n        private final Type type = numberGetType(value);\n        private NumberLiteralNode(final long token, final int finish, final Number value) {\n            super(Token.recast(token, TokenType.DECIMAL), finish, value);\n        }\n        private NumberLiteralNode(final NumberLiteralNode literalNode) {\n            super(literalNode);\n        }\n        private static Type numberGetType(final Number number) {\n            if (number instanceof Integer) {\n                return Type.INT;\n            } else if (number instanceof Double) {\n                return Type.NUMBER;\n            } else {\n                assert false;\n            }\n            return null;\n        }\n        @Override\n        public Type getType() {\n            return type;\n        }\n        @Override\n        public Type getWidestOperationType() {\n            return getType();\n        }\n    }<fim_middle>// class below is data class\n"}