{"text": "<fim_prefix>        }\n        // First, read the packet header.\n        for (int headerBytesRead = 0; headerBytesRead < TDS.PACKET_HEADER_SIZE;) {\n            int bytesRead = tdsChannel.read(newPacket.header, headerBytesRead,\n                    TDS.PACKET_HEADER_SIZE - headerBytesRead);\n            if (bytesRead < 0) {\n                if (logger.isLoggable(Level.FINER))\n                    logger.finer(toString() + \" Premature EOS in response. packetNum:\" + packetNum + \" headerBytesRead:\"\n                            + headerBytesRead);\n                con.terminate(SQLServerException.DRIVER_ERROR_IO_FAILED,\n                        ((0 == packetNum && 0 == headerBytesRead) ? SQLServerException.getErrString(\n                                \"R_noServerResponse\") : SQLServerException.getErrString(\"R_truncatedServerResponse\")));\n            }\n            headerBytesRead += bytesRead;\n        }\n        // if execution was subject to timeout then stop timing\n        if (this.timeout != null) {\n            this.timeout.cancel(false);\n            this.timeout = null;\n        }\n        // Header size is a 2 byte unsigned short integer in big-endian order.\n        int packetLength = Util.readUnsignedShortBigEndian(newPacket.header, TDS.PACKET_HEADER_MESSAGE_LENGTH);\n        // Make header size is properly bounded and compute length of the packet payload.\n        if (packetLength < TDS.PACKET_HEADER_SIZE || packetLength > con.getTDSPacketSize()) {\n            if (logger.isLoggable(Level.WARNING)) {\n                logger.warning(toString() + \" TDS header contained invalid packet length:\" + packetLength\n                        + \"; packet size:\" + con.getTDSPacketSize());\n            }\n            throwInvalidTDS();\n        }\n        newPacket.payloadLength = packetLength - TDS.PACKET_HEADER_SIZE;\n        // Just grab the SPID for logging (another big-endian unsigned short).\n        tdsChannel.setSPID(Util.readUnsignedShortBigEndian(newPacket.header, TDS.PACKET_HEADER_SPID));\n        // Packet header looks good enough.\n        // When logging, copy the packet header to the log buffer.\n        byte[] logBuffer = null;\n        if (tdsChannel.isLoggingPackets()) {\n            logBuffer = new byte[packetLength];\n            System.arraycopy(newPacket.header, 0, logBuffer, 0, TDS.PACKET_HEADER_SIZE);\n        }\n        // Now for the payload...\n        for (int payloadBytesRead = 0; payloadBytesRead < newPacket.payloadLength;) {\n            int bytesRead = tdsChannel.read(newPacket.payload, payloadBytesRead,\n                    newPacket.payloadLength - payloadBytesRead);\n            if (bytesRead < 0)\n                con.terminate(SQLServerException.DRIVER_ERROR_IO_FAILED,\n                        SQLServerException.getErrString(\"R_truncatedServerResponse\"));\n            payloadBytesRead += bytesRead;\n        }\n        ++packetNum;\n        lastPacket.next = newPacket;\n        lastPacket = newPacket;\n        // When logging, append the payload to the log buffer and write out the whole thing.\n        if (tdsChannel.isLoggingPackets()) {\n            System.arraycopy(newPacket.payload, 0, logBuffer, TDS.PACKET_HEADER_SIZE, newPacket.payloadLength);\n            tdsChannel.logPacket(logBuffer, 0, packetLength,\n                    this.toString() + \" received Packet:\" + packetNum + \" (\" + newPacket.payloadLength + \" bytes)\");\n        }\n        // If end of message, then bump the count of messages received and disable\n        // interrupts. If an interrupt happened prior to disabling, then expect\n        // to read the attention ack packet as well.\n        if (newPacket.isEOM()) {\n            ++tdsChannel.numMsgsRcvd;\n            // Notify the command (if any) that we've reached the end of the response.\n            if (null != command)\n                command.onResponseEOM();\n        }\n        return true;\n    }\n    final TDSReaderMark mark() {\n        TDSReaderMark mark = new TDSReaderMark(currentPacket, payloadOffset);\n        isStreaming = false;\n        if (logger.isLoggable(Level.FINEST))\n            logger.finest(this.toString() + \": Buffering from: \" + mark.toString());\n        return mark;\n    }\n    final void reset(TDSReaderMark mark) {\n        if (logger.isLoggable(Level.FINEST))\n            logger.finest(this.toString() + \": Resetting to: \" + mark.toString());\n        currentPacket = mark.packet;\n        payloadOffset = mark.payloadOffset;\n    }\n    final void stream() {\n        isStreaming = true;\n    }\n    /**\n     * Returns the number of bytes that can be read (or skipped over) from this TDSReader without blocking by the next\n     * caller of a method for this TDSReader.\n     *\n     * @return the actual number of bytes available.\n     */\n    final int available() {\n        // The number of bytes that can be read without blocking is just the number\n        // of bytes that are currently buffered. That is the number of bytes left\n        // in the current packet plus the number of bytes in the remaining packets.\n        int available = currentPacket.payloadLength - payloadOffset;\n        for (TDSPacket packet = currentPacket.next; null != packet; packet = packet.next)\n            available += packet.payloadLength;\n        return available;\n    }\n    /**\n     * \n     * @return number of bytes available in the current packet\n     */\n    final int availableCurrentPacket() {\n        /*\n         * The number of bytes that can be read from the current chunk, without including the next chunk that is\n         * buffered. This is so the driver can confirm if the next chunk sent is new packet or just continuation\n         */\n        int available = currentPacket.payloadLength - payloadOffset;\n        return available;\n    }\n    final int peekTokenType() throws SQLServerException {\n        // Check whether we're at EOF\n        if (!ensurePayload())\n            return -1;\n        // Peek at the current byte (don't increment payloadOffset!)\n        return currentPacket.payload[payloadOffset] & 0xFF;\n    }\n    final short peekStatusFlag() throws SQLServerException {\n        // skip the current packet(i.e, TDS packet type) and peek into the status flag (USHORT)\n        if (payloadOffset + 3 <= currentPacket.payloadLength) {\n            short value = Util.readShort(currentPacket.payload, payloadOffset + 1);\n            return value;\n        }\n        return 0;\n    }\n    final int readUnsignedByte() throws SQLServerException {\n        // Ensure that we have a packet to read from.\n        if (!ensurePayload())\n            throwInvalidTDS();\n        return currentPacket.payload[payloadOffset++] & 0xFF;\n    }\n    final short readShort() throws SQLServerException {\n        if (payloadOffset + 2 <= currentPacket.payloadLength) {\n            short value = Util.readShort(currentPacket.payload, payloadOffset);\n            payloadOffset += 2;\n            return value;\n        }\n        return Util.readShort(readWrappedBytes(2), 0);\n    }\n    final int readUnsignedShort() throws SQLServerException {\n        if (payloadOffset + 2 <= currentPacket.payloadLength) {\n            int value = Util.readUnsignedShort(currentPacket.payload, payloadOffset);\n            payloadOffset += 2;\n            return value;\n        }\n        return Util.readUnsignedShort(readWrappedBytes(2), 0);\n    }\n    final String readUnicodeString(int length) throws SQLServerException {\n        int byteLength = 2 * length;\n        byte bytes[] = new byte[byteLength];\n        readBytes(bytes, 0, byteLength);\n        return Util.readUnicodeString(bytes, 0, byteLength, con);\n    }\n    final char readChar() throws SQLServerException {\n        return (char) readShort();\n    }\n    final int readInt() throws SQLServerException {\n        if (payloadOffset + 4 <= currentPacket.payloadLength) {\n            int value = Util.readInt(currentPacket.payload, payloadOffset);\n            payloadOffset += 4;\n            return value;\n        }\n        return Util.readInt(readWrappedBytes(4), 0);\n    }\n<fim_suffix>    final int readIntBigEndian() throws SQLServerException {\n        if (payloadOffset + 4 <= currentPacket.payloadLength) {\n            int value = Util.readIntBigEndian(currentPacket.payload, payloadOffset);\n            payloadOffset += 4;\n            return value;\n        }\n        return Util.readIntBigEndian(readWrappedBytes(4), 0);\n    }<fim_middle>// function below has no smell\n"}