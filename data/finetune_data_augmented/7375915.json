{"text": "<fim_prefix>/*\n * Copyright 2012-2018 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.actuate.trace.http;\n\nimport java.net.URI;\nimport java.security.Principal;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\nimport java.util.stream.Collectors;\n\nimport org.springframework.http.HttpHeaders;\n\n/**\n * Traces an HTTP request-response exchange.\n *\n * @author Andy Wilkinson\n * @since 2.0.0\n */\n<fim_suffix>public class HttpExchangeTracer {\n\n\tprivate final Set<Include> includes;\n\n\t/**\n\t * Creates a new {@code HttpExchangeTracer} that will use the given {@code includes}\n\t * to determine the contents of its traces.\n\t * @param includes the includes\n\t */\n\tpublic HttpExchangeTracer(Set<Include> includes) {\n\t\tthis.includes = includes;\n\t}\n\n\t/**\n\t * Begins the tracing of the exchange that was initiated by the given {@code request}\n\t * being received.\n\t * @param request the received request\n\t * @return the HTTP trace for the\n\t */\n\tpublic final HttpTrace receivedRequest(TraceableRequest request) {\n\t\treturn new HttpTrace(new FilteredTraceableRequest(request));\n\t}\n\n\t/**\n\t * Ends the tracing of the exchange that is being concluded by sending the given\n\t * {@code response}.\n\t * @param trace the trace for the exchange\n\t * @param response the response that concludes the exchange\n\t * @param principal a supplier for the exchange's principal\n\t * @param sessionId a supplier for the id of the exchange's session\n\t */\n\tpublic final void sendingResponse(HttpTrace trace, TraceableResponse response,\n\t\t\tSupplier<Principal> principal, Supplier<String> sessionId) {\n\t\tsetIfIncluded(Include.TIME_TAKEN,\n\t\t\t\t() -> System.currentTimeMillis() - trace.getTimestamp().toEpochMilli(),\n\t\t\t\ttrace::setTimeTaken);\n\t\tsetIfIncluded(Include.SESSION_ID, sessionId, trace::setSessionId);\n\t\tsetIfIncluded(Include.PRINCIPAL, principal, trace::setPrincipal);\n\t\ttrace.setResponse(\n\t\t\t\tnew HttpTrace.Response(new FilteredTraceableResponse(response)));\n\t}\n\n\t/**\n\t * Post-process the given mutable map of request {@code headers}.\n\t * @param headers the headers to post-process\n\t */\n\tprotected void postProcessRequestHeaders(Map<String, List<String>> headers) {\n\n\t}\n\n\tprivate <T> T getIfIncluded(Include include, Supplier<T> valueSupplier) {\n\t\treturn this.includes.contains(include) ? valueSupplier.get() : null;\n\t}\n\n\tprivate <T> void setIfIncluded(Include include, Supplier<T> supplier,\n\t\t\tConsumer<T> consumer) {\n\t\tif (this.includes.contains(include)) {\n\t\t\tconsumer.accept(supplier.get());\n\t\t}\n\t}\n\n\tprivate Map<String, List<String>> getHeadersIfIncluded(Include include,\n\t\t\tSupplier<Map<String, List<String>>> headersSupplier,\n\t\t\tPredicate<String> headerPredicate) {\n\t\tif (!this.includes.contains(include)) {\n\t\t\treturn new LinkedHashMap<>();\n\t\t}\n\t\treturn headersSupplier.get().entrySet().stream()\n\t\t\t\t.filter((entry) -> headerPredicate.test(entry.getKey()))\n\t\t\t\t.collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n\t}\n\n\tprivate final class FilteredTraceableRequest implements TraceableRequest {\n\n\t\tprivate final TraceableRequest delegate;\n\n\t\tprivate FilteredTraceableRequest(TraceableRequest delegate) {\n\t\t\tthis.delegate = delegate;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getMethod() {\n\t\t\treturn this.delegate.getMethod();\n\t\t}\n\n\t\t@Override\n\t\tpublic URI getUri() {\n\t\t\treturn this.delegate.getUri();\n\t\t}\n\n\t\t@Override\n\t\tpublic Map<String, List<String>> getHeaders() {\n\t\t\tMap<String, List<String>> headers = getHeadersIfIncluded(\n\t\t\t\t\tInclude.REQUEST_HEADERS, this.delegate::getHeaders,\n\t\t\t\t\tthis::includedHeader);\n\t\t\tpostProcessRequestHeaders(headers);\n\t\t\treturn headers;\n\t\t}\n\n\t\tprivate boolean includedHeader(String name) {\n\t\t\tif (name.equalsIgnoreCase(HttpHeaders.COOKIE)) {\n\t\t\t\treturn HttpExchangeTracer.this.includes.contains(Include.COOKIE_HEADERS);\n\t\t\t}\n\t\t\tif (name.equalsIgnoreCase(HttpHeaders.AUTHORIZATION)) {\n\t\t\t\treturn HttpExchangeTracer.this.includes\n\t\t\t\t\t\t.contains(Include.AUTHORIZATION_HEADER);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getRemoteAddress() {\n\t\t\treturn getIfIncluded(Include.REMOTE_ADDRESS, this.delegate::getRemoteAddress);\n\t\t}\n\n\t}\n\n\tprivate final class FilteredTraceableResponse implements TraceableResponse {\n\n\t\tprivate final TraceableResponse delegate;\n\n\t\tprivate FilteredTraceableResponse(TraceableResponse delegate) {\n\t\t\tthis.delegate = delegate;\n\t\t}\n\n\t\t@Override\n\t\tpublic int getStatus() {\n\t\t\treturn this.delegate.getStatus();\n\t\t}\n\n\t\t@Override\n\t\tpublic Map<String, List<String>> getHeaders() {\n\t\t\treturn getHeadersIfIncluded(Include.RESPONSE_HEADERS,\n\t\t\t\t\tthis.delegate::getHeaders, this::includedHeader);\n\t\t}\n\n\t\tprivate boolean includedHeader(String name) {\n\t\t\tif (name.equalsIgnoreCase(HttpHeaders.SET_COOKIE)) {\n\t\t\t\treturn HttpExchangeTracer.this.includes.contains(Include.COOKIE_HEADERS);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t}\n\n}<fim_middle>// class below is blob\n"}