{"text": "<fim_prefix>/*\n * Copyright (c) 2011-2018 Pivotal Software Inc, All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage reactor.core.publisher;\nimport java.util.ArrayDeque;\nimport java.util.Collection;\nimport java.util.Objects;\nimport java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\nimport java.util.concurrent.atomic.AtomicLongFieldUpdater;\nimport java.util.function.BooleanSupplier;\nimport java.util.function.Supplier;\nimport org.reactivestreams.Subscription;\nimport reactor.core.CoreSubscriber;\nimport reactor.util.annotation.Nullable;\nimport reactor.util.context.Context;\n/**\n * Buffers a certain number of subsequent elements and emits the buffers.\n *\n * @param <T> the source value type\n * @param <C> the buffer collection type\n *\n * @see <a href=\"https://github.com/reactor/reactive-streams-commons\">Reactive-Streams-Commons</a>\n */\nfinal class FluxBuffer<T, C extends Collection<? super T>> extends FluxOperator<T, C> {\n\tfinal int size;\n\tfinal int skip;\n\tfinal Supplier<C> bufferSupplier;\n\tFluxBuffer(Flux<? extends T> source, int size, Supplier<C> bufferSupplier) {\n\t\tthis(source, size, size, bufferSupplier);\n\t}\n\tFluxBuffer(Flux<? extends T> source,\n\t\t\tint size,\n\t\t\tint skip,\n\t\t\tSupplier<C> bufferSupplier) {\n\t\tsuper(source);\n\t\tif (size <= 0) {\n\t\t\tthrow new IllegalArgumentException(\"size > 0 required but it was \" + size);\n\t\t}\n\t\tif (skip <= 0) {\n\t\t\tthrow new IllegalArgumentException(\"skip > 0 required but it was \" + size);\n\t\t}\n\t\tthis.size = size;\n\t\tthis.skip = skip;\n\t\tthis.bufferSupplier = Objects.requireNonNull(bufferSupplier, \"bufferSupplier\");\n\t}\n\t@Override\n\tpublic void subscribe(CoreSubscriber<? super C> actual) {\n\t\tif (size == skip) {\n\t\t\tsource.subscribe(new BufferExactSubscriber<>(actual, size, bufferSupplier));\n\t\t}\n\t\telse if (skip > size) {\n\t\t\tsource.subscribe(new BufferSkipSubscriber<>(actual, size, skip, bufferSupplier));\n\t\t}\n\t\telse {\n\t\t\tsource.subscribe(new BufferOverlappingSubscriber<>(actual,\n\t\t\t\t\tsize,\n\t\t\t\t\tskip,\n\t\t\t\t\tbufferSupplier));\n\t\t}\n\t}\n\tstatic final class BufferExactSubscriber<T, C extends Collection<? super T>>\n\t\t\timplements InnerOperator<T, C> {\n\t\tfinal CoreSubscriber<? super C> actual;\n\t\tfinal Context ctx;\n\t\tfinal Supplier<C> bufferSupplier;\n\t\tfinal int size;\n\t\tC buffer;\n\t\tSubscription s;\n\t\tboolean done;\n\t\tBufferExactSubscriber(CoreSubscriber<? super C> actual,\n\t\t\t\tint size,\n\t\t\t\tSupplier<C> bufferSupplier) {\n\t\t\tthis.actual = actual;\n\t\t\tthis.ctx = actual.currentContext();\n\t\t\tthis.size = size;\n\t\t\tthis.bufferSupplier = bufferSupplier;\n\t\t}\n\t\t@Override\n\t\tpublic void request(long n) {\n\t\t\tif (Operators.validate(n)) {\n\t\t\t\ts.request(Operators.multiplyCap(n, size));\n\t\t\t}\n\t\t}\n\t\t@Override\n\t\tpublic void cancel() {\n\t\t\ts.cancel();\n\t\t\tOperators.onDiscardMultiple(buffer, this.ctx);\n\t\t}\n\t\t@Override\n\t\tpublic void onSubscribe(Subscription s) {\n\t\t\tif (Operators.validate(this.s, s)) {\n\t\t\t\tthis.s = s;\n\t\t\t\tactual.onSubscribe(this);\n\t\t\t}\n\t\t}\n\t\t@Override\n\t\tpublic void onNext(T t) {\n\t\t\tif (done) {\n\t\t\t\tOperators.onNextDropped(t, this.ctx);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tC b = buffer;\n\t\t\tif (b == null) {\n\t\t\t\ttry {\n\t\t\t\t\tb = Objects.requireNonNull(bufferSupplier.get(),\n\t\t\t\t\t\t\t\"The bufferSupplier returned a null buffer\");\n\t\t\t\t}\n\t\t\t\tcatch (Throwable e) {\n\t\t\t\t\tonError(Operators.onOperatorError(s, e, t, this.ctx));\n\t\t\t\t\tOperators.onDiscard(t, this.ctx); //this is in no buffer\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbuffer = b;\n\t\t\t}\n\t\t\tb.add(t);\n\t\t\tif (b.size() == size) {\n\t\t\t\tbuffer = null;\n\t\t\t\tactual.onNext(b);\n\t\t\t}\n\t\t}\n\t\t@Override\n\t\tpublic void onError(Throwable t) {\n\t\t\tif (done) {\n\t\t\t\tOperators.onErrorDropped(t, this.ctx);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdone = true;\n\t\t\tactual.onError(t);\n\t\t\tOperators.onDiscardMultiple(buffer, this.ctx);\n\t\t}\n<fim_suffix>\t\t@Override\n\t\tpublic void onComplete() {\n\t\t\tif (done) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdone = true;\n\t\t\tC b = buffer;\n\t\t\tif (b != null && !b.isEmpty()) {\n\t\t\t\tactual.onNext(b);\n\t\t\t}\n\t\t\tactual.onComplete();\n\t\t}\n\t\t@Override\n\t\tpublic CoreSubscriber<? super C> actual() {\n\t\t\treturn actual;\n\t\t}\n\t\t@Override\n\t\t@Nullable\n\t\tpublic Object scanUnsafe(Attr key) {\n\t\t\tif (key == Attr.PARENT) return s;\n\t\t\tif (key == Attr.TERMINATED) return done;\n\t\t\tif (key == Attr.BUFFERED) {\n\t\t\t\tC b = buffer;\n\t\t\t\treturn b != null ? b.size() : 0;\n\t\t\t}\n\t\t\tif (key == Attr.CAPACITY) return size;\n\t\t\tif (key == Attr.PREFETCH) return size;\n\t\t\treturn InnerOperator.super.scanUnsafe(key);\n\t\t}\n\t}\n\tstatic final class BufferSkipSubscriber<T, C extends Collection<? super T>>\n\t\t\timplements InnerOperator<T, C> {\n\t\tfinal CoreSubscriber<? super C> actual;\n\t\tfinal Context ctx;\n\t\tfinal Supplier<C> bufferSupplier;\n\t\tfinal int size;\n\t\tfinal int skip;\n\t\tC buffer;\n\t\tSubscription s;\n\t\tboolean done;\n\t\tlong index;\n\t\tvolatile int wip;\n\t\t@SuppressWarnings(\"rawtypes\")\n\t\tstatic final AtomicIntegerFieldUpdater<BufferSkipSubscriber> WIP =\n\t\t\t\tAtomicIntegerFieldUpdater.newUpdater(BufferSkipSubscriber.class, \"wip\");\n\t\tBufferSkipSubscriber(CoreSubscriber<? super C> actual,\n\t\t\t\tint size,\n\t\t\t\tint skip,\n\t\t\t\tSupplier<C> bufferSupplier) {\n\t\t\tthis.actual = actual;\n\t\t\tthis.ctx = actual.currentContext();\n\t\t\tthis.size = size;\n\t\t\tthis.skip = skip;\n\t\t\tthis.bufferSupplier = bufferSupplier;\n\t\t}\n\t\t@Override\n\t\tpublic void request(long n) {\n\t\t\tif (!Operators.validate(n)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (wip == 0 && WIP.compareAndSet(this, 0, 1)) {\n\t\t\t\t// n full buffers\n\t\t\t\tlong u = Operators.multiplyCap(n, size);\n\t\t\t\t// + (n - 1) gaps\n\t\t\t\tlong v = Operators.multiplyCap(skip - size, n - 1);\n\t\t\t\ts.request(Operators.addCap(u, v));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// n full buffer + gap\n\t\t\t\ts.request(Operators.multiplyCap(skip, n));\n\t\t\t}\n\t\t}\n\t\t@Override\n\t\tpublic void cancel() {\n\t\t\ts.cancel();\n\t\t\tOperators.onDiscardMultiple(buffer, this.ctx);\n\t\t}\n\t\t@Override\n\t\tpublic void onSubscribe(Subscription s) {\n\t\t\tif (Operators.validate(this.s, s)) {\n\t\t\t\tthis.s = s;\n\t\t\t\tactual.onSubscribe(this);\n\t\t\t}\n\t\t}\n\t\t@Override\n\t\tpublic void onNext(T t) {\n\t\t\tif (done) {\n\t\t\t\tOperators.onNextDropped(t, this.ctx);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tC b = buffer;\n\t\t\tlong i = index;\n\t\t\tif (i % skip == 0L) {\n\t\t\t\ttry {\n\t\t\t\t\tb = Objects.requireNonNull(bufferSupplier.get(),<fim_middle>// function below has no smell\n"}