{"text": "<fim_prefix>\t\tSystem.arraycopy(mplsObj.playlistItems[maxStreamIndex].subtitleStreams, 0, streams,\n\t\t\tmplsObj.playlistItems[maxStreamIndex].primaryVideoStreams.length + mplsObj.playlistItems[maxStreamIndex].primaryAudioStreams.length,\n\t\t\tmplsObj.playlistItems[maxStreamIndex].subtitleStreams.length);\n\t\tcf.setStreamFormats(streams);\n\t\tcf.setPacketSize(192);\n\t\t// Check to see if there's any 6 channel audio sources, and if so we need to run our own MPEG format detector to distinguish between 7.1 and 5.1 audio.\n\t\tboolean needAudioRedetect = false;\n\t\tfor (int i = 0; i < streams.length; i++)\n\t\t{\n\t\t\tif (streams[i] instanceof sage.media.format.AudioFormat &&\n\t\t\t\t((sage.media.format.AudioFormat)streams[i]).getChannels() == 6)\n\t\t\t\tneedAudioRedetect = true;\n\t\t}\n\t\tif (needAudioRedetect)\n\t\t{\n\t\t\tif (sage.Sage.DBG) System.out.println(\"Redetecting format on BluRay audio to distinguish between 5.1 and 7.1 channels\");\n\t\t\t// We need to use FFMPEG here because our internal detector doesn't deal with the stv:// protocol\n\t\t\tsage.media.format.ContainerFormat ourCf;\n\t\t\t// NOTE: THIS WILL NOT WORK PROPERLY IN FAT CLIENT EMBEDDED MODE; BUT WE CAN FIX THAT LATER!\n      ourCf = sage.media.format.FormatParser.getFFMPEGFileFormat((remoteHostname == null ? \"\" : (\"stv://\" + remoteHostname + \"/\")) +\n        new java.io.File(streamDir, mplsObj.playlistItems[0].itemClips[0].clipName + (doesUseShortFilenames() ? \".MTS\" : \".m2ts\")).getAbsolutePath());\n\t\t\tif (ourCf != null)\n\t\t\t{\n\t\t\t\tsage.media.format.AudioFormat[] ffAudios = ourCf.getAudioFormats();\n\t\t\t\t// Now go through and find all the audio streams that we need to locate a match for, and then match them\n\t\t\t\tfor (int i = 0; i < streams.length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (streams[i] instanceof sage.media.format.AudioFormat)\n\t\t\t\t\t{\n\t\t\t\t\t\tsage.media.format.AudioFormat origAudioFormat = (sage.media.format.AudioFormat)streams[i];\n\t\t\t\t\t\tif (origAudioFormat.getChannels() == 6 && origAudioFormat.getId() != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (int j = 0; j < ffAudios.length; j++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (origAudioFormat.getId().equals(ffAudios[j].getId()))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (sage.Sage.DBG && origAudioFormat.getChannels() != ffAudios[j].getChannels()) System.out.println(\"Fixing BD Audio channels for \" + origAudioFormat + \" to be \" + ffAudios[j]);\n\t\t\t\t\t\t\t\t\torigAudioFormat.setChannels(ffAudios[j].getChannels());\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (sage.Sage.getBoolean(\"enable_bluray_metadata_extraction\", true))\n\t\t\textractBDMetadata(cf);\n\t\tif (sage.Sage.DBG) System.out.println(\"Built BluRay format of:\" + cf);\n\t\treturn cf;\n\t}\n\t// This will try to find Title & Thumbnail information from the META folder in the BDMV\n\tprivate void extractBDMetadata(sage.media.format.ContainerFormat cf)\n\t{\n\t\tjava.io.File metaXml = new java.io.File(bdmvDir, \"META\" + java.io.File.separator + \"DL\" + java.io.File.separator + \"bdmt_eng.xml\");\n\t\tif (metaXml.isFile())\n\t\t{\n\t\t\tif (factory == null)\n\t\t\t\tfactory = SAXParserFactory.newInstance();\n\t\t\t// We should use XML parsing even though its simple in case there's special chars in the title or other funky stuff\n\t\t\tjava.io.InputStream inStream = null;\n\t\t\ttry\n\t\t\t{\n\t\t\t\tinStream = new java.io.BufferedInputStream(new java.io.FileInputStream(metaXml));\n\t\t\t\tfactory.setValidating(false);\n\t\t\t\tfactory.newSAXParser().parse(inStream, new BDMVSAXHandler());\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t}\n\t\t\tif (inStream != null)\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tinStream.close();\n\t\t\t\t}\n\t\t\t\tcatch (Exception e){}\n\t\t\t}\n\t\t\tif (metaTitle != null)\n\t\t\t\tcf.addMetadata(sage.media.format.MediaFormat.META_TITLE, metaTitle);\n\t\t\tif (metaThumbnail != null)\n\t\t\t\tcf.addMetadata(sage.media.format.MediaFormat.META_THUMBNAIL_FILE, metaThumbnail);\n\t\t}\n\t}\n\tpublic boolean doesUseShortFilenames()\n\t{\n\t\treturn usesShortFilenames;\n\t}\n\tprivate java.io.File bdmvDir;\n\tprivate java.io.File indexFile;\n\tprivate java.io.File movieObjectFile;\n\tprivate java.io.File streamDir;\n\tprivate java.io.File playlistDir;\n\tprivate String remoteHostname; // for retrieving from a SageTV Server\n\tprivate String metaTitle;\n\tprivate String metaThumbnail;\n\tprivate sage.media.format.ContainerFormat[] playlistFormats;\n\tprivate int mainPlaylistIndex;\n\tprivate MPLSObject[] playlists;\n\tprivate String[] playlistIDs;\n\tprivate boolean usesShortFilenames;\n\tprivate static SAXParserFactory factory = null;\n<fim_suffix>\tprivate class BDMVSAXHandler extends DefaultHandler\n\t{\n\t\tprivate String current_tag;\n\t\tprivate StringBuffer buff = new StringBuffer();\n\t\tprivate boolean insideTitle;\n\t\tprivate boolean insideDescription;\n\t\tprivate int maxThumbSize = -1;\n\t\tpublic void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException\n\t\t{\n\t\t\tif (\"di:title\".equalsIgnoreCase(qName))\n\t\t\t{\n\t\t\t\tinsideTitle = true;\n\t\t\t}\n\t\t\telse if (\"di:description\".equalsIgnoreCase(qName))\n\t\t\t{\n\t\t\t\tinsideDescription = true;\n\t\t\t}\n\t\t\telse if (insideDescription && \"di:thumbnail\".equals(qName))\n\t\t\t{\n\t\t\t\tString thumbStr = attributes.getValue(\"href\");\n\t\t\t\tString sizeStr = attributes.getValue(\"size\");\n\t\t\t\tif (thumbStr != null && sizeStr != null)\n\t\t\t\t{\n\t\t\t\t\tint xidx = sizeStr.indexOf('x');\n\t\t\t\t\tif (xidx != -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tint currSize = 0;\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcurrSize = Integer.parseInt(sizeStr.substring(0, xidx)) * Integer.parseInt(sizeStr.substring(xidx + 1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (NumberFormatException nfe)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (sage.Sage.DBG) System.out.println(\"ERROR could not extract BDMV thumbnail size of :\" + nfe + \" from \" + sizeStr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (currSize > maxThumbSize)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmetaThumbnail = new java.io.File(new java.io.File(bdmvDir, \"META\" + java.io.File.separator + \"DL\"), thumbStr).getAbsolutePath();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrent_tag = qName;\n\t\t}\n\t\tpublic void characters(char[] ch, int start, int length)\n\t\t{\n\t\t\tString data = new String(ch,start,length);\n\t\t\t//Jump blank chunk\n\t\t\tif (data.trim().length() == 0)\n\t\t\t\treturn;\n\t\t\tbuff.append(data);\n\t\t}\n\t\tpublic void endElement(String uri, String localName, String qName)\n\t\t{\n\t\t\tString data = buff.toString().trim();\n\t\t\tif (qName.equals(current_tag))\n\t\t\t\tbuff = new StringBuffer();\n\t\t\tif (\"di:title\".equals(qName))\n\t\t\t\tinsideTitle = false;\n\t\t\telse if (\"di:description\".equals(qName))\n\t\t\t\tinsideDescription = false;\n\t\t\telse if (insideTitle && \"di:name\".equals(qName))\n\t\t\t{\n\t\t\t\tmetaTitle = data;\n\t\t\t}\n\t\t}\n\t}<fim_middle>// class below is blob\n"}