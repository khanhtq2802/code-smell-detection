{"text": "<fim_prefix>    public void start() throws RepositoryException {\n        // nop\n    }\n    @Override\n    public void startNode(NodeInfo nodeInfo, List<PropInfo> propInfos)\n            throws RepositoryException {\n        Tree parent = parents.peek();\n        Tree tree = null;\n        String id = nodeInfo.getUUID();\n        String nodeName = nodeInfo.getName();\n        String ntName = nodeInfo.getPrimaryTypeName();\n        if (parent == null) {\n            log.debug(\"Skipping node: {}\", nodeName);\n            // parent node was skipped, skip this child node too\n            parents.push(null); // push null onto stack for skipped node\n            // notify the p-i-importer\n            if (pnImporter != null) {\n                pnImporter.startChildInfo(nodeInfo, propInfos);\n            }\n            return;\n        }\n        NodeDefinition parentDef = getDefinition(parent);\n        if (parentDef.isProtected()) {\n            // skip protected node\n            parents.push(null);\n            log.debug(\"Skipping protected node: {}\", nodeName);\n            if (pnImporter != null) {\n                // pnImporter was already started (current nodeInfo is a sibling)\n                // notify it about this child node.\n                pnImporter.startChildInfo(nodeInfo, propInfos);\n            } else {\n                // no importer defined yet:\n                // test if there is a ProtectedNodeImporter among the configured\n                // importers that can handle this.\n                // if there is one, notify the ProtectedNodeImporter about the\n                // start of a item tree that is protected by this parent. If it\n                // potentially is able to deal with it, notify it about the child node.\n                for (ProtectedNodeImporter pni : getNodeImporters()) {\n                    if (pni.start(parent)) {\n                        log.debug(\"Protected node -> delegated to ProtectedNodeImporter\");\n                        pnImporter = pni;\n                        pnImporter.startChildInfo(nodeInfo, propInfos);\n                        break;\n                    } /* else: p-i-Importer isn't able to deal with the protected tree.\n                     try next. and if none can handle the passed parent the\n                     tree below will be skipped */\n                }\n            }\n            return;\n        }\n        if (parent.hasChild(nodeName)) {\n            // a node with that name already exists...\n            Tree existing = parent.getChild(nodeName);\n            NodeDefinition def = getDefinition(existing);\n            if (!def.allowsSameNameSiblings()) {\n                // existing doesn't allow same-name siblings,\n                // check for potential conflicts\n                if (def.isProtected() && isNodeType(existing, ntName)) {\n                    /*\n                     use the existing node as parent for the possible subsequent\n                     import of a protected tree, that the protected node importer\n                     may or may not be able to deal with.\n                     -> upon the next 'startNode' the check for the parent being\n                        protected will notify the protected node importer.\n                     -> if the importer is able to deal with that node it needs\n                        to care of the complete subtree until it is notified\n                        during the 'endNode' call.\n                     -> if the import can't deal with that node or if that node\n                        is the a leaf in the tree to be imported 'end' will\n                        not have an effect on the importer, that was never started.\n                    */\n                    log.debug(\"Skipping protected node: {}\", existing);\n                    parents.push(existing);\n                    /**\n                     * let ProtectedPropertyImporters handle the properties\n                     * associated with the imported node. this may include overwriting,\n                     * merging or just adding missing properties.\n                     */\n                    importProperties(existing, propInfos, true);\n                    return;\n                }\n                if (def.isAutoCreated() && isNodeType(existing, ntName)) {\n                    // this node has already been auto-created, no need to create it\n                    tree = existing;\n                } else {\n                    // edge case: colliding node does have same uuid\n                    // (see http://issues.apache.org/jira/browse/JCR-1128)\n                    String existingIdentifier = IdentifierManager.getIdentifier(existing);\n                    if (!(existingIdentifier.equals(id)\n                            && (uuidBehavior == ImportUUIDBehavior.IMPORT_UUID_COLLISION_REMOVE_EXISTING\n                            || uuidBehavior == ImportUUIDBehavior.IMPORT_UUID_COLLISION_REPLACE_EXISTING))) {\n                        throw new ItemExistsException(\n                                \"Node with the same UUID exists:\" + existing);\n                    }\n                    // fall through\n                }\n            }\n        }\n        if (tree == null) {\n            // create node\n            if (id == null) {\n                // no potential uuid conflict, always add new node\n                tree = createTree(parent, nodeInfo, null);\n            } else if (uuidBehavior == ImportUUIDBehavior.IMPORT_UUID_CREATE_NEW) {\n                // always create a new UUID even if no\n                // conflicting node exists. see OAK-1244\n                tree = createTree(parent, nodeInfo, UUID.randomUUID().toString());\n                // remember uuid mapping\n                if (isNodeType(tree, JcrConstants.MIX_REFERENCEABLE)) {\n                    refTracker.put(nodeInfo.getUUID(), TreeUtil.getString(tree, JcrConstants.JCR_UUID));\n                }\n            } else {\n                Tree conflicting = idLookup.getConflictingTree(id);\n                if (conflicting != null && conflicting.exists()) {\n                    // resolve uuid conflict\n                    tree = resolveUUIDConflict(parent, conflicting, id, nodeInfo);\n                    if (tree == null) {\n                        // no new node has been created, so skip this node\n                        parents.push(null); // push null onto stack for skipped node\n                        log.debug(\"Skipping existing node {}\", nodeInfo.getName());\n                        return;\n                    }\n                } else {\n                    // create new with given uuid\n                    tree = createTree(parent, nodeInfo, id);\n                }\n            }\n        }\n        // process properties\n        importProperties(tree, propInfos, false);\n        if (tree.exists()) {\n            parents.push(tree);\n        }\n    }\n    @Override\n    public void endNode(NodeInfo nodeInfo) throws RepositoryException {\n        Tree parent = parents.pop();\n        if (parent == null) {\n            if (pnImporter != null) {\n                pnImporter.endChildInfo();\n            }\n        } else if (getDefinition(parent).isProtected()) {\n            if (pnImporter != null) {\n                pnImporter.end(parent);\n                // and reset the pnImporter field waiting for the next protected\n                // parent -> selecting again from available importers\n                pnImporter = null;\n            }\n        }\n        idLookup.rememberImportedUUIDs(parent);\n    }\n    @Override\n    public void end() throws RepositoryException {\n        /**\n         * adjust references that refer to uuids which have been mapped to\n         * newly generated uuids on import\n         */\n        // 1. let protected property/node importers handle protected ref-properties\n        //    and (protected) properties underneath a protected parent node.\n        for (ProtectedItemImporter ppi : pItemImporters) {\n            ppi.processReferences();\n        }\n        // 2. regular non-protected properties.\n        Iterator<Object> iter = refTracker.getProcessedReferences();\n        while (iter.hasNext()) {\n            Object ref = iter.next();\n            if (!(ref instanceof Reference)) {\n                continue;\n            }\n            Reference reference = (Reference) ref;\n            if (reference.isMultiple()) {\n                Iterable<String> values = reference.property.getValue(Type.STRINGS);\n                List<String> newValues = Lists.newArrayList();\n                for (String original : values) {\n                    String adjusted = refTracker.get(original);\n                    if (adjusted != null) {\n                        newValues.add(adjusted);\n                    } else {\n                        // reference doesn't need adjusting, just copy old value\n                        newValues.add(original);\n                    }\n                }\n                reference.setProperty(newValues);\n            } else {\n                String original = reference.property.getValue(Type.STRING);\n                String adjusted = refTracker.get(original);\n                if (adjusted != null) {\n                    reference.setProperty(adjusted);\n                }\n            }\n        }\n        refTracker.clear();\n    }\n    private boolean isNodeType(Tree tree, String ntName) throws RepositoryException {\n        return effectiveNodeTypeProvider.isNodeType(tree, ntName);\n    }\n    private NodeDefinition getDefinition(Tree tree) throws RepositoryException {\n        if (tree.isRoot()) {\n            return definitionProvider.getRootDefinition();\n        } else {\n            return definitionProvider.getDefinition(tree.getParent(), tree);\n        }\n    }\n<fim_suffix>    private static final class Reference {\n        private final Tree tree;\n        private final PropertyState property;\n        private Reference(Tree tree, String propertyName) {\n            this.tree = tree;\n            this.property = tree.getProperty(propertyName);\n        }\n        private boolean isMultiple() {\n            return property.isArray();\n        }\n        private void setProperty(String newValue) {\n            PropertyState prop = PropertyStates.createProperty(property.getName(), newValue, property.getType().tag());\n            tree.setProperty(prop);\n        }\n        private void setProperty(Iterable<String> newValues) {\n            PropertyState prop = PropertyStates.createProperty(property.getName(), newValues, property.getType());\n            tree.setProperty(prop);\n        }\n    }<fim_middle>// class below has no smell\n"}