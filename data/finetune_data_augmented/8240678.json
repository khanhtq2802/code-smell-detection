{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.cocoon.components.elementprocessor.impl.poi.hssf.elements;\n\nimport java.io.IOException;\nimport java.util.Locale;\n\nimport org.apache.cocoon.components.elementprocessor.ElementProcessor;\nimport org.apache.cocoon.components.elementprocessor.LocaleAware;\nimport org.apache.cocoon.components.elementprocessor.types.Attribute;\nimport org.apache.cocoon.components.elementprocessor.types.NumericConverter;\nimport org.apache.cocoon.components.elementprocessor.types.NumericResult;\nimport org.apache.cocoon.components.elementprocessor.types.Validator;\nimport org.apache.poi.hssf.util.CellRangeAddress;\n/**\n * Implementation of ElementProcessor to handle the \"Cell\" tag.\n * This element has several attributes and may contain other elements.\n *\n * @version $Id$\n */\npublic class EPCell extends BaseElementProcessor implements LocaleAware {\n\n    private Cell _cell;\n    private NumericResult _col;\n    private NumericResult _row;\n    private NumericResult _expr_id;\n    private NumericResult _cols;\n    private NumericResult _rows;\n    private NumericResult _value_type;\n    private String _value_format;\n    private boolean _expr_id_fetched;\n    private boolean _cols_fetched;\n    private boolean _rows_fetched;\n    private boolean _value_type_fetched;\n    private boolean _value_format_fetched;\n    private static final String _col_attribute = \"Col\";\n    private static final String _row_attribute = \"Row\";\n    private static final String _expr_id_attribute = \"ExprID\";\n    private static final String _cols_attribute = \"Cols\";\n    private static final String _rows_attribute = \"Rows\";\n    private static final String _value_type_attribute = \"ValueType\";\n    private static final String _value_format_attribute = \"ValueFormat\";\n    private String locale; // the locale for this EPCell\n    private static final Validator _cell_type_validator = new Validator() {\n        public IOException validate(final Number number) {\n            return CellType.isValid(number.intValue()) ? null : new IOException(\"\\\"\" + number + \"\\\" is not a legal value\");\n        }\n    };\n\n    /**\n     * constructor\n     */\n    public EPCell() {\n        super(null);\n        _cell = null;\n        _col = null;\n        _row = null;\n        _expr_id = null;\n        _cols = null;\n        _rows = null;\n        _value_type = null;\n        _value_format = null;\n        _expr_id_fetched = false;\n        _cols_fetched = false;\n        _rows_fetched = false;\n        _value_type_fetched = false;\n        _value_format_fetched = false;\n    }\n\n    /**\n     * @return column\n     *\n     * @exception IOException\n     */\n    public int getColumn() throws IOException {\n        if (_col == null) {\n            _col = NumericConverter.extractNonNegativeInteger(getValue(_col_attribute));\n        }\n        return _col.intValue();\n    }\n\n    /**\n     * @return row\n     *\n     * @exception IOException\n     */\n    public int getRow() throws IOException {\n        if (_row == null) {\n            _row = NumericConverter.extractNonNegativeInteger(getValue(_row_attribute));\n        }\n        return _row.intValue();\n    }\n\n    /**\n     * @return expression id\n     *\n     * @exception IOException\n     * @exception NullPointerException\n     */\n    public int getExpressionId() throws IOException, NullPointerException {\n        if (!_expr_id_fetched) {\n            String valueString = getValue(_expr_id_attribute);\n            if (valueString != null) {\n                _expr_id = NumericConverter.extractPositiveInteger(valueString);\n            }\n            _expr_id_fetched = true;\n        }\n        return _expr_id.intValue();\n    }\n\n    /**\n     * @return columns\n     *\n     * @exception IOException\n     * @exception NullPointerException\n     */\n     public int getColumns() throws IOException, NullPointerException {\n       if (!_cols_fetched) {\n           String valueString = getValue(_cols_attribute);\n           if (valueString != null) {\n               _cols = NumericConverter.extractPositiveInteger(valueString);\n\t\t\t\t_cols_fetched = true;\n            }\n            \n        }\n        return _cols_fetched ?_cols.intValue() : -1;\n    }\n\n    /**\n     * @return rows\n     *\n     * @exception IOException\n     * @exception NullPointerException\n     */\n     public int getRows() throws IOException, NullPointerException {\n      if (!_rows_fetched) {\n           String valueString = getValue(_rows_attribute);\n           if (valueString != null) {\n               _rows = NumericConverter.extractPositiveInteger(valueString);\n\t\t\t   _rows_fetched = true;\n           }\n           \n        }\n        return _rows_fetched ? _rows.intValue() : -1 ;\n    }\n\n    /**\n     * @return cell type as a public member of CellType\n     *\n     * @exception IOException\n     * @exception NullPointerException\n     */\n    public int getCellType() throws IOException, NullPointerException {\n        if (!_value_type_fetched) {\n            String valueString = getValue(_value_type_attribute);\n            if (valueString != null) {\n                _value_type = NumericConverter.extractInteger(valueString, _cell_type_validator);\n            }\n            _value_type_fetched = true;\n        }\n        return _value_type.intValue();\n    }\n\n    /**\n     * @return format string; null if no such attribute\n     *\n     * @exception IOException\n     */\n    public String getFormat() throws IOException {\n        if (!_value_format_fetched) {\n            _value_format = getValue(_value_format_attribute);\n            _value_format_fetched = true;\n        }\n        return _value_format;\n    }\n\n    /**\n     * Override of initialize() implementation\n     *\n     * @param attributes the array of Attribute instances; may be\n     *                   empty, will never be null\n     * @param parent the parent ElementProcessor; may be null\n     *\n     * @exception IOException if anything is wrong\n     */\n<fim_suffix>    public void initialize(final Attribute[] attributes, final ElementProcessor parent) throws IOException {\n        super.initialize(attributes, parent);\n        // default value (when <gmr:Cell> has no ValueType attribute)\n        int cellType = CellType.CELL_TYPE_FORMULA;\n        try {\n            cellType = getCellType();\n        } catch (NullPointerException ignored) {\n        }\n        _cell = getSheet().getRow(getRow()).createCell(getColumn(), cellType);\n    }\n\n    public String getContent() {\n        String content = getData();\n        return content;\n    }\n\n    /**\n     * end processing -- apply content to the cell.\n     *\n     * @exception IOException\n     */\n    public void endProcessing() throws IOException {\n        String content = getContent();\n        if (content != null && locale != null) {\n            // if there is a locale then set it (otherwise the default locale\n            // will be used)\n            getCell().setLocale(new Locale(locale, locale.toUpperCase()));\n        }\n        if (content != null && !content.trim().equals(\"\")) {\n            getCell().setContent(getContent());\n        }\n        \n        if(getColumns() != -1 && getRows() != -1) {\n            getSheet().addMergedRegion(new CellRangeAddress(getRow(), getRow() + getRows() - 1,\n                    getColumn(), (getColumn() + getColumns() - 1)));\n        }\n\n    }\n\n    /**\n     * override of getCell()\n     *\n     * @return the cell\n     */\n    protected Cell getCell() {\n        return _cell;\n    }\n\n    // from LocaleAware - set the locale for a cell\n    public void setLocale(String locale) {\n        this.locale = locale;\n    }\n\n}   // end public class EPCell<fim_middle>// function below has no smell\n"}