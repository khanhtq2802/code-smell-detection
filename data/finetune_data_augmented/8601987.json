{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.hadoop.hbase.client;\n\nimport static org.apache.hadoop.hbase.client.ConnectionUtils.createClosestRowAfter;\nimport static org.apache.hadoop.hbase.client.ConnectionUtils.isEmptyStartRow;\nimport static org.apache.hadoop.hbase.client.ConnectionUtils.noMoreResultsForScan;\n\nimport java.io.IOException;\nimport java.util.concurrent.ExecutorService;\n\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.hbase.TableName;\nimport org.apache.yetus.audience.InterfaceAudience;\nimport org.apache.hadoop.hbase.ipc.RpcControllerFactory;\n\n/**\n * ClientSimpleScanner implements a sync scanner behaviour.\n * The cache is a simple list.\n * The prefetch is invoked only when the application finished processing the entire cache.\n */\n<fim_suffix>@InterfaceAudience.Private\npublic class ClientSimpleScanner extends ClientScanner {\n  public ClientSimpleScanner(Configuration configuration, Scan scan, TableName name,\n      ClusterConnection connection, RpcRetryingCallerFactory rpcCallerFactory,\n      RpcControllerFactory rpcControllerFactory, ExecutorService pool,\n      int replicaCallTimeoutMicroSecondScan) throws IOException {\n    super(configuration, scan, name, connection, rpcCallerFactory, rpcControllerFactory, pool,\n        replicaCallTimeoutMicroSecondScan);\n  }\n\n  @Override\n  protected boolean setNewStartKey() {\n    if (noMoreResultsForScan(scan, currentRegion)) {\n      return false;\n    }\n    scan.withStartRow(currentRegion.getEndKey(), true);\n    return true;\n  }\n\n  @Override\n  protected ScannerCallable createScannerCallable() {\n    if (!scan.includeStartRow() && !isEmptyStartRow(scan.getStartRow())) {\n      // we have not implemented locate to next row for sync client yet, so here we change the\n      // inclusive of start row to true.\n      scan.withStartRow(createClosestRowAfter(scan.getStartRow()), true);\n    }\n    return new ScannerCallable(getConnection(), getTable(), scan, this.scanMetrics,\n        this.rpcControllerFactory);\n  }\n}<fim_middle>// class below has no smell\n"}