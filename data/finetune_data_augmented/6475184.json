{"text": "<fim_prefix>\tString getDescription() {\n\t\treturn \"A comma separated list of thread ids to include in the formatted trace output.\";\n\t}\n\tString getName() {\n\t\treturn \"threads\";\n\t}\n\tString getUsage() {\n\t\treturn \"-threads=id[,id]\";\n\t}\n\tObject getValue() {\n\t\treturn threads;\n\t}\n\tvoid setValue(String value) throws IllegalArgumentException {\n\t\t/* This could be just the one file or could be a comma separated list */\n\t\tStringTokenizer st = new StringTokenizer(value, \",\");\n\t\tString token = \"\";\n\t\ttry {\n\t\t\twhile (st.hasMoreTokens()) {\n\t\t\t\ttoken = st.nextToken();\n\t\t\t\tLong id;\n\t\t\t\t/* construct Long's from the id's */\n\t\t\t\tif (token.startsWith(\"0x\")) {\n\t\t\t\t\tid = Long.valueOf(token.substring(2), 16);\n\t\t\t\t} else {\n\t\t\t\t\tid = Long.valueOf(token);\n\t\t\t\t}\n\t\t\t\tthreads.add(id);\n\t\t\t}\n\t\t} catch (NumberFormatException e) {\n\t\t\tthrow new IllegalArgumentException(\"The specified thread id, \\\"\"+token+\"\\\" is not valid. Id's must be a number\");\n\t\t}\n\t}\n\tvoid setDefault() {\n\t}\n}\nclass Timezone extends ProgramOption {\n\tInteger timezone;\n\tString getDescription() {\n\t\treturn \"Specifies the offset from UTC/GMT to apply when formatting timestamps, as +|-HH:MM\";\n\t}\n\tString getName() {\n\t\treturn \"timezone\";\n\t}\n\tString getUsage() {\n\t\treturn \"-timezone=+|-HH:MM\";\n\t}\n\tObject getValue() {\n\t\treturn timezone;\n\t}\n\tvoid setValue(String value) throws IllegalArgumentException {\n\t\t// Validate and convert input time zone string from +|-HH:MM format to +/- integer minutes\n\t\ttry {\n\t\t\tif (value.length() != 6) { // initial validation, string length must be 6\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n \t\t\tint hours = Integer.parseInt(value.substring(1,3));\n\t\t\tint minutes = Integer.parseInt(value.substring(4,6));\n \t\t\tif ((hours > 12) || (minutes > 60))  {\n \t\t\t\tthrow new NumberFormatException();\n \t\t\t}\n\t\t\ttimezone = (hours * 60) + minutes;\n\t\t\tif (value.substring(0,1).equals(\"-\")) {\n\t\t\t\ttimezone = -timezone;\t\n\t\t\t}\n\t\t} catch (NumberFormatException e) {\n\t\t\tthrow new IllegalArgumentException(\"The specified timezone offset \\\"\"+value+\"\\\" is not valid. Format is +|-HH:MM\");\n\t\t}\n\t}\n\tvoid setAutomatic() {\n\t\t/* if specified with no value, default to the current timezone. Convert from millis to minutes */\n\t\ttimezone = Integer.valueOf((TimeZone.getDefault().getRawOffset() + TimeZone.getDefault().getDSTSavings())/(1000 * 60));\n\t}\n\tvoid setDefault() {\n\t\t/* default value is false */\n\t\ttimezone = Integer.valueOf(0);\n\t}\n}\nclass Indent extends ProgramOption {\n\tboolean indent;\n\tString getDescription() {\n\t\treturn \"Specifies whether to indent the trace point text to illustrate the call flow for the thread.\";\n\t}\n\tString getName() {\n\t\treturn \"indent\";\n\t}\n\tString getUsage() {\n\t\treturn \"-indent\";\n\t}\n\tObject getValue() {\n\t\treturn Boolean.valueOf(indent);\n\t}\n\tvoid setValue(String value) throws IllegalArgumentException {\n\t\tif (value.equalsIgnoreCase(\"true\") || value.equalsIgnoreCase(\"yes\")) {\n\t\t\tindent = true;\n\t\t} else if (value.equalsIgnoreCase(\"false\") || value.equalsIgnoreCase(\"no\")) {\n\t\t\tindent = false;\n\t\t} else {\n\t\t\tthrow new IllegalArgumentException(\"The value \\\"\"+value+\"\\\" specified for indent is not valid, must be true or false\");\n\t\t}\n\t}\n\tvoid setAutomatic() {\n\t\t/* if specified with no value, default to true */\n\t\tindent = true;\n\t}\n\tvoid setDefault() {\n\t\t/* default value is false */\n\t\tindent = false;\n\t}\n}\nclass Summary extends ProgramOption {\n\tboolean summary;\n\tString getDescription() {\n\t\treturn \"Instructs the formatter to produce only summary information about the data\";\n\t}\n\tString getName() {\n\t\treturn \"summary\";\n\t}\n\tString getUsage() {\n\t\treturn \"-summary\";\n\t}\n\tObject getValue() {\n\t\treturn Boolean.valueOf(summary);\n\t}\n\tvoid setValue(String value) throws IllegalArgumentException {\n\t\tif (value.equalsIgnoreCase(\"true\") || value.equalsIgnoreCase(\"yes\")) {\n\t\t\tsummary = true;\n\t\t} else if (value.equalsIgnoreCase(\"false\") || value.equalsIgnoreCase(\"no\")) {\n\t\t\tsummary = false;\n\t\t} else {\n\t\t\tthrow new IllegalArgumentException(\"The value \\\"\"+value+\"\\\" specified for summary is not valid, must be true or false\");\n\t\t}\n\t}\n\tvoid setAutomatic() {\n\t\t/* if specified with no value, default to true */\n\t\tsummary = true;\n\t}\n\tvoid setDefault() {\n\t\t/* default value is false */\n\t\tsummary = false;\n\t}\n}\nclass InputFile extends ProgramOption {\n\tList inputFiles = new LinkedList();\n\tString getDescription() {\n\t\treturn \"The binary trace file generated by IBM JVMs. For multi-generational trace files specify the file pattern instead. This option is required\";\n\t}\n\tString getName() {\n\t\treturn \"input_file\";\n\t}\n\tObject getValue() {\n\t\treturn inputFiles;\n\t}\n\tboolean required() {\n\t\treturn true;\n\t}\n\tvoid setDefault() {\n\t\t/* pulls the first Anonymous argument out of the list and uses that */\n\t\tif (ProgramOption.AnonymousArgs.isEmpty()) {\n\t\t\tthrow new IllegalArgumentException(\"An input file must be specified\");\n\t\t}\n\t\tsetValue((String)ProgramOption.AnonymousArgs.get(0));\n\t}\n\tvoid setValue(String value) throws IllegalArgumentException {\n\t\ttry {\n\t\t\tinputFiles.add(new RandomAccessFile(value, \"r\"));\n\t\t} catch (FileNotFoundException e) {\n\t\t\tint i = 0;\n\t\t\tString generation = value;\n\t\t\t/* if this was a generational file pattern then replace the token and try again */\n\t\t\tif (value.indexOf('#') != -1) {\n\t\t\t\t/* TODO: we've had to remove record level sorting due to the problems with NTP updates.\n\t\t\t\t * Until we've got sorting for the generational files this needs to be disabled\n\t\t\t\t */\n\t\t\t\tthrow new IllegalArgumentException(\"Support for generational files has been removed until file level sorting is implemented\");\n//\t\t\t\ttry {\n//\t\t\t\t\twhile (true) {\n//\t\t\t\t\t\tgeneration = value.replace('#', Character.forDigit(i, 10));\n//\t\t\t\t\t\tsetValue(generation);\n//\t\t\t\t\t\ti++;\n//\t\t\t\t\t}\n//\t\t\t\t} catch (IllegalArgumentException r) {\n//\t\t\t\t\tif (i == 0) {\n//\t\t\t\t\t\t/* we failed to find any generational files */\n//\t\t\t\t\t\tthrow new IllegalArgumentException(\"A generational input file pattern was specified (contained '#'), but the file \\\"\"+generation+\"\\\" was not be found\");\n//\t\t\t\t\t}\n//\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new IllegalArgumentException(\"The file \\\"\"+value+\"\\\" specified as the input file could not be found\");\n\t\t\t}\n\t\t}\n\t}\n}\nclass FormatTimestamp extends ProgramOption {\n\tboolean formatTimestamp;\n\tString getDescription() {\n\t\treturn \"Specifies whether to format the tracepoint time stamps. Default is yes.\";\n\t}\n\tString getName() {\n\t\treturn \"format_time\";\n\t}\n\tString getUsage() {\n\t\treturn \"-format_time=yes|no\";\n\t}\n\tObject getValue() {\n\t\treturn Boolean.valueOf(formatTimestamp);\n\t}\n<fim_suffix>\tvoid setValue(String value) throws IllegalArgumentException {\n\t\tif (value.equalsIgnoreCase(\"true\") || value.equalsIgnoreCase(\"yes\")) {\n\t\t\tformatTimestamp = true;\n\t\t} else if (value.equalsIgnoreCase(\"false\") || value.equalsIgnoreCase(\"no\")) {\n\t\t\tformatTimestamp = false;\n\t\t} else {\n\t\t\tthrow new IllegalArgumentException(\"The value \\\"\"+value+\"\\\" specified for format timestamp is not valid, must be true or false\");\n\t\t}\n\t}<fim_middle>// function below has no smell\n"}