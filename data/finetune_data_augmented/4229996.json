{"text": "<fim_prefix> * the following range\n *\n * <ul>\n * <li>0x6601 - DES</li>\n * <li>0x6602 - RC2 (version needed to extract &lt; 5.2)</li>\n * <li>0x6603 - 3DES 168</li>\n * <li>0x6609 - 3DES 112</li>\n * <li>0x660E - AES 128</li>\n * <li>0x660F - AES 192</li>\n * <li>0x6610 - AES 256</li>\n * <li>0x6702 - RC2 (version needed to extract &gt;= 5.2)</li>\n * <li>0x6720 - Blowfish</li>\n * <li>0x6721 - Twofish</li>\n * <li>0x6801 - RC4</li>\n * <li>0xFFFF - Unknown algorithm</li>\n * </ul>\n *\n * <b>Hash Algorithms</b> - integer identifier of the hash algorithm from the\n * following range\n *\n * <ul>\n * <li>0x0000 - none</li>\n * <li>0x0001 - CRC32</li>\n * <li>0x8003 - MD5</li>\n * <li>0x8004 - SHA1</li>\n * <li>0x8007 - RIPEMD160</li>\n * <li>0x800C - SHA256</li>\n * <li>0x800D - SHA384</li>\n * <li>0x800E - SHA512</li>\n * </ul>\n *\n * @since 1.11\n */\n<fim_suffix>public abstract class PKWareExtraHeader implements ZipExtraField {\n    private final ZipShort headerId;\n    /**\n     * Extra field data in local file data - without Header-ID or length\n     * specifier.\n     */\n    private byte[] localData;\n    /**\n     * Extra field data in central directory - without Header-ID or length\n     * specifier.\n     */\n    private byte[] centralData;\n    protected PKWareExtraHeader(final ZipShort headerId) {\n        this.headerId = headerId;\n    }\n    /**\n     * Get the header id.\n     *\n     * @return the header id\n     */\n    @Override\n    public ZipShort getHeaderId() {\n        return headerId;\n    }\n    /**\n     * Set the extra field data in the local file data - without Header-ID or\n     * length specifier.\n     *\n     * @param data\n     *            the field data to use\n     */\n    public void setLocalFileDataData(final byte[] data) {\n        localData = ZipUtil.copy(data);\n    }\n    /**\n     * Get the length of the local data.\n     *\n     * @return the length of the local data\n     */\n    @Override\n    public ZipShort getLocalFileDataLength() {\n        return new ZipShort(localData != null ? localData.length : 0);\n    }\n    /**\n     * Get the local data.\n     *\n     * @return the local data\n     */\n    @Override\n    public byte[] getLocalFileDataData() {\n        return ZipUtil.copy(localData);\n    }\n    /**\n     * Set the extra field data in central directory.\n     *\n     * @param data\n     *            the data to use\n     */\n    public void setCentralDirectoryData(final byte[] data) {\n        centralData = ZipUtil.copy(data);\n    }\n    /**\n     * Get the central data length. If there is no central data, get the local\n     * file data length.\n     *\n     * @return the central data length\n     */\n    @Override\n    public ZipShort getCentralDirectoryLength() {\n        if (centralData != null) {\n            return new ZipShort(centralData.length);\n        }\n        return getLocalFileDataLength();\n    }\n    /**\n     * Get the central data.\n     *\n     * @return the central data if present, else return the local file data\n     */\n    @Override\n    public byte[] getCentralDirectoryData() {\n        if (centralData != null) {\n            return ZipUtil.copy(centralData);\n        }\n        return getLocalFileDataData();\n    }\n    /**\n     * @param data\n     *            the array of bytes.\n     * @param offset\n     *            the source location in the data array.\n     * @param length\n     *            the number of bytes to use in the data array.\n     * @see ZipExtraField#parseFromLocalFileData(byte[], int, int)\n     */\n    @Override\n    public void parseFromLocalFileData(final byte[] data, final int offset, final int length) {\n        final byte[] tmp = new byte[length];\n        System.arraycopy(data, offset, tmp, 0, length);\n        setLocalFileDataData(tmp);\n    }\n    /**\n     * @param data\n     *            the array of bytes.\n     * @param offset\n     *            the source location in the data array.\n     * @param length\n     *            the number of bytes to use in the data array.\n     * @see ZipExtraField#parseFromCentralDirectoryData(byte[], int, int)\n     */\n    @Override\n    public void parseFromCentralDirectoryData(final byte[] data, final int offset, final int length) {\n        final byte[] tmp = new byte[length];\n        System.arraycopy(data, offset, tmp, 0, length);\n        setCentralDirectoryData(tmp);\n        if (localData == null) {\n            setLocalFileDataData(tmp);\n        }\n    }\n    /**\n     * Encryption algorithm.\n     *\n     * @since 1.11\n     */\n    public enum EncryptionAlgorithm {\n        DES(0x6601),\n        RC2pre52(0x6602),\n        TripleDES168(0x6603),\n        TripleDES192(0x6609),\n        AES128(0x660E),\n        AES192(0x660F),\n        AES256(0x6610),\n        RC2(0x6702),\n        RC4(0x6801),\n        UNKNOWN(0xFFFF);\n        private final int code;\n        private static final Map<Integer, EncryptionAlgorithm> codeToEnum;\n        static {\n            final Map<Integer, EncryptionAlgorithm> cte = new HashMap<>();\n            for (final EncryptionAlgorithm method : values()) {\n                cte.put(method.getCode(), method);\n            }\n            codeToEnum = Collections.unmodifiableMap(cte);\n        }\n        /**\n         * private constructor for enum style class.\n         */\n        EncryptionAlgorithm(final int code) {\n            this.code = code;\n        }\n        /**\n         * the algorithm id.\n         *\n         * @return the PKWare AlgorithmId\n         */\n        public int getCode() {\n            return code;\n        }\n        /**\n         * Returns the EncryptionAlgorithm for the given code or null if the\n         * method is not known.\n         * @param code the code of the algorithm\n         * @return the EncryptionAlgorithm for the given code or null\n         * if the method is not known\n         */\n        public static EncryptionAlgorithm getAlgorithmByCode(final int code) {\n            return codeToEnum.get(code);\n        }\n    }\n    /**\n     * Hash Algorithm\n     *\n     * @since 1.11\n     */\n    public enum HashAlgorithm {\n        NONE(0),\n        CRC32(1),\n        MD5(0x8003),\n        SHA1(0x8004),\n        RIPEND160(0x8007),\n        SHA256(0x800C),\n        SHA384(0x800D),\n        SHA512(0x800E);\n        private final int code;\n        private static final Map<Integer, HashAlgorithm> codeToEnum;\n        static {\n            final Map<Integer, HashAlgorithm> cte = new HashMap<>();\n            for (final HashAlgorithm method : values()) {\n                cte.put(method.getCode(), method);\n            }\n            codeToEnum = Collections.unmodifiableMap(cte);\n        }\n        /**\n         * private constructor for enum style class.\n         */\n        HashAlgorithm(final int code) {\n            this.code = code;\n        }\n        /**\n         * the hash algorithm ID.\n         *\n         * @return the PKWare hashAlg\n         */\n        public int getCode() {\n            return code;\n        }\n        /**\n         * Returns the HashAlgorithm for the given code or null if the method is\n         * not known.\n         * @param code the code of the algorithm\n         * @return the HashAlgorithm for the given code or null\n         * if the method is not known\n         */\n        public static HashAlgorithm getAlgorithmByCode(final int code) {\n            return codeToEnum.get(code);\n        }\n    }\n}<fim_middle>// class below is data class\n"}