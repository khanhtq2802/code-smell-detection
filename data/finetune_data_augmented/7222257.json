{"text": "<fim_prefix>/*\n * Copyright (c) 2011-2017 Pivotal Software Inc, All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage reactor.core.publisher;\n\nimport java.util.Objects;\nimport java.util.function.BiConsumer;\nimport java.util.function.Function;\nimport java.util.stream.Collector;\n\nimport org.reactivestreams.Subscription;\nimport reactor.core.CoreSubscriber;\nimport reactor.core.Fuseable;\nimport reactor.util.annotation.Nullable;\n\n/**\n * Collects the values from the source sequence into a {@link java.util.stream.Collector}\n * instance.\n *\n * @param <T> the source value type\n * @param <A> an intermediate value type\n * @param <R> the output value type\n *\n * @see <a href=\"https://github.com/reactor/reactive-streams-commons\">Reactive-Streams-Commons</a>\n */\nfinal class MonoStreamCollector<T, A, R> extends MonoFromFluxOperator<T, R>\n\t\timplements Fuseable {\n\n\tfinal Collector<? super T, A, ? extends R> collector;\n\n\tMonoStreamCollector(Flux<? extends T> source,\n\t\t\tCollector<? super T, A, ? extends R> collector) {\n\t\tsuper(source);\n\t\tthis.collector = Objects.requireNonNull(collector, \"collector\");\n\t}\n\n\t@Override\n\tpublic void subscribe(CoreSubscriber<? super R> actual) {\n\t\tA container;\n\t\tBiConsumer<? super A, ? super T> accumulator;\n\t\tFunction<? super A, ? extends R> finisher;\n\n\t\ttry {\n\t\t\tcontainer = collector.supplier()\n\t\t\t                     .get();\n\n\t\t\taccumulator = collector.accumulator();\n\n\t\t\tfinisher = collector.finisher();\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tOperators.error(actual, Operators.onOperatorError(ex, actual.currentContext()));\n\t\t\treturn;\n\t\t}\n\n\t\tsource.subscribe(new StreamCollectorSubscriber<>(actual,\n\t\t\t\tcontainer,\n\t\t\t\taccumulator,\n\t\t\t\tfinisher));\n\t}\n\n\tstatic final class StreamCollectorSubscriber<T, A, R>\n\t\t\textends Operators.MonoSubscriber<T, R> {\n\n\t\tfinal BiConsumer<? super A, ? super T> accumulator;\n\n\t\tfinal Function<? super A, ? extends R> finisher;\n\n\t\tA container;\n\n\t\tSubscription s;\n\n\t\tboolean done;\n\n\t\tStreamCollectorSubscriber(CoreSubscriber<? super R> actual,\n\t\t\t\tA container,\n\t\t\t\tBiConsumer<? super A, ? super T> accumulator,\n\t\t\t\tFunction<? super A, ? extends R> finisher) {\n\t\t\tsuper(actual);\n\t\t\tthis.container = container;\n\t\t\tthis.accumulator = accumulator;\n\t\t\tthis.finisher = finisher;\n\t\t}\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic Object scanUnsafe(Attr key) {\n\t\t\tif (key == Attr.TERMINATED) return done;\n\t\t\tif (key == Attr.PARENT) return s;\n\n\t\t\treturn super.scanUnsafe(key);\n\t\t}\n\n<fim_suffix>\t\t@Override\n\t\tpublic void onSubscribe(Subscription s) {\n\t\t\tif (Operators.validate(this.s, s)) {\n\t\t\t\tthis.s = s;\n\n\t\t\t\tactual.onSubscribe(this);\n\n\t\t\t\ts.request(Long.MAX_VALUE);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void onNext(T t) {\n\t\t\tif (done) {\n\t\t\t\tOperators.onNextDropped(t, actual.currentContext());\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\taccumulator.accept(container, t);\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tonError(Operators.onOperatorError(s, ex, t, actual.currentContext()));\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void onError(Throwable t) {\n\t\t\tif (done) {\n\t\t\t\tOperators.onErrorDropped(t, actual.currentContext());\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdone = true;\n\t\t\tcontainer = null;\n\t\t\tactual.onError(t);\n\t\t}\n\n\t\t@Override\n\t\tpublic void onComplete() {\n\t\t\tif (done) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdone = true;\n\n\t\t\tA a = container;\n\t\t\tcontainer = null;\n\n\t\t\tR r;\n\n\t\t\ttry {\n\t\t\t\tr = finisher.apply(a);\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\tactual.onError(Operators.onOperatorError(ex, actual.currentContext()));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcomplete(r);\n\t\t}\n\n\t\t@Override\n\t\tpublic void cancel() {\n\t\t\tsuper.cancel();\n\t\t\ts.cancel();\n\t\t}\n\t}\n}<fim_middle>// function below has no smell\n"}