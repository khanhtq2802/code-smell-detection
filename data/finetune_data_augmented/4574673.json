{"text": "<fim_prefix> * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/* $Id$ */\npackage org.apache.fop.layoutmgr;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Map;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.apache.xmlgraphics.util.QName;\nimport org.apache.fop.area.Area;\nimport org.apache.fop.area.AreaTreeObject;\nimport org.apache.fop.area.PageViewport;\nimport org.apache.fop.fo.Constants;\nimport org.apache.fop.fo.FONode;\nimport org.apache.fop.fo.FObj;\nimport org.apache.fop.fo.flow.Marker;\nimport org.apache.fop.fo.flow.RetrieveMarker;\n/**\n * The base class for most LayoutManagers.\n */\npublic abstract class AbstractLayoutManager extends AbstractBaseLayoutManager implements Constants {\n    /** logging instance */\n    private static Log log = LogFactory.getLog(AbstractLayoutManager.class);\n    /** Parent LayoutManager for this LayoutManager */\n    protected LayoutManager parentLayoutManager;\n    /** List of child LayoutManagers */\n    protected List<LayoutManager> childLMs;\n    /** Iterator for child LayoutManagers */\n    protected ListIterator fobjIter;\n    /** Marker map for markers related to this LayoutManager */\n    private Map<String, Marker> markers;\n    /** True if this LayoutManager has handled all of its content. */\n    private boolean isFinished;\n    /** child LM during getNextKnuthElement phase */\n    protected LayoutManager curChildLM;\n    /** child LM iterator during getNextKnuthElement phase */\n    protected ListIterator<LayoutManager> childLMiter;\n    private int lastGeneratedPosition = -1;\n    private int smallestPosNumberChecked = Integer.MAX_VALUE;\n    private boolean preserveChildrenAtEndOfLayout;\n    /**\n     * Abstract layout manager.\n     */\n    public AbstractLayoutManager() {\n    }\n    /**\n     * Abstract layout manager.\n     *\n     * @param fo the formatting object for this layout manager\n     */\n    public AbstractLayoutManager(FObj fo) {\n        super(fo);\n        markers = fo.getMarkers();\n        fobjIter = fo.getChildNodes();\n        childLMiter = new LMiter(this);\n    }\n    /** {@inheritDoc} */\n    public void setParent(LayoutManager lm) {\n        this.parentLayoutManager = lm;\n    }\n    /** {@inheritDoc} */\n    public LayoutManager getParent() {\n        return this.parentLayoutManager;\n    }\n    /** {@inheritDoc} */\n    public void initialize() {\n        // Empty\n    }\n    /**\n     * Return currently active child LayoutManager or null if\n     * all children have finished layout.\n     * Note: child must implement LayoutManager! If it doesn't, skip it\n     * and print a warning.\n     * @return the current child LayoutManager\n     */\n    protected LayoutManager getChildLM() {\n        if (curChildLM != null && !curChildLM.isFinished()) {\n            return curChildLM;\n        }\n        if (childLMiter.hasNext()) {\n            curChildLM = childLMiter.next();\n            curChildLM.initialize();\n            return curChildLM;\n        }\n        return null;\n    }\n    /**\n     * Set currently active child layout manager.\n     * @param childLM the child layout manager\n     */\n    protected void setCurrentChildLM(LayoutManager childLM) {\n        curChildLM = childLM;\n        childLMiter = new LMiter(this);\n        do {\n            curChildLM = childLMiter.next();\n        } while (curChildLM != childLM);\n    }\n    /**\n     * Return indication if getChildLM will return another LM.\n     * @return true if another child LM is still available\n     */\n    protected boolean hasNextChildLM() {\n        return childLMiter.hasNext();\n    }\n    /**\n     * Tell whether this LayoutManager has handled all of its content.\n     * @return True if there are no more break possibilities,\n     * ie. the last one returned represents the end of the content.\n     */\n    public boolean isFinished() {\n        return isFinished;\n    }\n    /**\n     * Set the flag indicating the LayoutManager has handled all of its content.\n     * @param fin the flag value to be set\n     */\n    public void setFinished(boolean fin) {\n        isFinished = fin;\n    }\n    /** {@inheritDoc} */\n    public void addAreas(PositionIterator posIter, LayoutContext context) {\n    }\n    /** {@inheritDoc} */\n    public List getNextKnuthElements(LayoutContext context, int alignment) {\n        log.warn(\"null implementation of getNextKnuthElements() called!\");\n        setFinished(true);\n        return null;\n    }\n    /** {@inheritDoc} */\n    public List getChangedKnuthElements(List oldList, int alignment) {\n        log.warn(\"null implementation of getChangeKnuthElement() called!\");\n        return null;\n    }\n    /**\n     * Return an Area which can contain the passed childArea. The childArea\n     * may not yet have any content, but it has essential traits set.\n     * In general, if the LayoutManager already has an Area it simply returns\n     * it. Otherwise, it makes a new Area of the appropriate class.\n     * It gets a parent area for its area by calling its parent LM.\n     * Finally, based on the dimensions of the parent area, it initializes\n     * its own area. This includes setting the content IPD and the maximum\n     * BPD.\n     * @param childArea the child area for which the parent area is wanted\n     * @return the parent area for the given child\n     */\n    public Area getParentArea(Area childArea) {\n        return null;\n    }\n    /**\n     * Add a child area to the current area. If this causes the maximum\n     * dimension of the current area to be exceeded, the parent LM is called\n     * to add it.\n     * @param childArea the child area to be added\n     */\n    public void addChildArea(Area childArea) {\n    }\n    /**\n     * Create the LM instances for the children of the\n     * formatting object being handled by this LM.\n     * @param size the requested number of child LMs\n     * @return the list with the preloaded child LMs\n     */\n    protected List<LayoutManager> createChildLMs(int size) {\n        if (fobjIter == null) {\n            return null;\n        }\n        List<LayoutManager> newLMs = new ArrayList<LayoutManager>(size);\n        while (fobjIter.hasNext() && newLMs.size() < size) {\n            Object theobj = fobjIter.next();\n            if (theobj instanceof FONode) {\n                FONode foNode = (FONode) theobj;\n                if (foNode instanceof RetrieveMarker) {\n                    foNode = getPSLM().resolveRetrieveMarker(\n                        (RetrieveMarker) foNode);\n                }\n                if (foNode != null) {\n                    getPSLM().getLayoutManagerMaker()\n                        .makeLayoutManagers(foNode, newLMs);\n                }\n            }\n        }\n        return newLMs;\n    }\n    /** {@inheritDoc} */\n    public PageSequenceLayoutManager getPSLM() {\n        return parentLayoutManager.getPSLM();\n    }\n    /**\n     * @see PageSequenceLayoutManager#getCurrentPage()\n     * @return the {@link Page} instance corresponding to the current page\n     */\n    public Page getCurrentPage() {\n        return getPSLM().getCurrentPage();\n    }\n    /** @return the current page viewport */\n    public PageViewport getCurrentPV() {\n        return getPSLM().getCurrentPage().getPageViewport();\n    }\n    /** {@inheritDoc} */\n    public boolean createNextChildLMs(int pos) {\n        List<LayoutManager> newLMs = createChildLMs(pos + 1 - childLMs.size());\n        addChildLMs(newLMs);\n        return pos < childLMs.size();\n    }\n    /** {@inheritDoc} */\n    public List<LayoutManager> getChildLMs() {\n        if (childLMs == null) {\n            childLMs = new java.util.ArrayList<LayoutManager>(10);\n        }\n        return childLMs;\n    }\n    /** {@inheritDoc} */\n    public void addChildLM(LayoutManager lm) {\n        if (lm == null) {\n            return;\n        }\n        lm.setParent(this);\n        if (childLMs == null) {\n            childLMs = new java.util.ArrayList<LayoutManager>(10);\n        }\n        childLMs.add(lm);\n        if (log.isTraceEnabled()) {\n            log.trace(this.getClass().getName()\n                    + \": Adding child LM \" + lm.getClass().getName());\n        }\n    }\n    /** {@inheritDoc} */\n<fim_suffix>    public void addChildLMs(List newLMs) {\n        if (newLMs == null || newLMs.size() == 0) {\n            return;\n        }\n        for (LayoutManager newLM : (Iterable<LayoutManager>) newLMs) {\n            addChildLM(newLM);\n        }\n    }<fim_middle>// function below has no smell\n"}