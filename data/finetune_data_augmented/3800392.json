{"text": "<fim_prefix>/*\n * Copyright (C) 2016 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.android.exoplayer2.extractor.wav;\n\nimport com.google.android.exoplayer2.C;\nimport com.google.android.exoplayer2.Format;\nimport com.google.android.exoplayer2.ParserException;\nimport com.google.android.exoplayer2.extractor.Extractor;\nimport com.google.android.exoplayer2.extractor.ExtractorInput;\nimport com.google.android.exoplayer2.extractor.ExtractorOutput;\nimport com.google.android.exoplayer2.extractor.ExtractorsFactory;\nimport com.google.android.exoplayer2.extractor.PositionHolder;\nimport com.google.android.exoplayer2.extractor.TrackOutput;\nimport com.google.android.exoplayer2.util.Assertions;\nimport com.google.android.exoplayer2.util.MimeTypes;\nimport java.io.IOException;\n\n/**\n * Extracts data from WAV byte streams.\n */\npublic final class WavExtractor implements Extractor {\n\n  /** Factory for {@link WavExtractor} instances. */\n  public static final ExtractorsFactory FACTORY = () -> new Extractor[] {new WavExtractor()};\n\n  /** Arbitrary maximum input size of 32KB, which is ~170ms of 16-bit stereo PCM audio at 48KHz. */\n  private static final int MAX_INPUT_SIZE = 32 * 1024;\n\n  private ExtractorOutput extractorOutput;\n  private TrackOutput trackOutput;\n  private WavHeader wavHeader;\n  private int bytesPerFrame;\n  private int pendingBytes;\n\n  @Override\n  public boolean sniff(ExtractorInput input) throws IOException, InterruptedException {\n    return WavHeaderReader.peek(input) != null;\n  }\n\n<fim_suffix>  @Override\n  public void init(ExtractorOutput output) {\n    extractorOutput = output;\n    trackOutput = output.track(0, C.TRACK_TYPE_AUDIO);\n    wavHeader = null;\n    output.endTracks();\n  }\n\n  @Override\n  public void seek(long position, long timeUs) {\n    pendingBytes = 0;\n  }\n\n  @Override\n  public void release() {\n    // Do nothing\n  }\n\n  @Override\n  public int read(ExtractorInput input, PositionHolder seekPosition)\n      throws IOException, InterruptedException {\n    if (wavHeader == null) {\n      wavHeader = WavHeaderReader.peek(input);\n      if (wavHeader == null) {\n        // Should only happen if the media wasn't sniffed.\n        throw new ParserException(\"Unsupported or unrecognized wav header.\");\n      }\n      Format format = Format.createAudioSampleFormat(null, MimeTypes.AUDIO_RAW, null,\n          wavHeader.getBitrate(), MAX_INPUT_SIZE, wavHeader.getNumChannels(),\n          wavHeader.getSampleRateHz(), wavHeader.getEncoding(), null, null, 0, null);\n      trackOutput.format(format);\n      bytesPerFrame = wavHeader.getBytesPerFrame();\n    }\n\n    if (!wavHeader.hasDataBounds()) {\n      WavHeaderReader.skipToData(input, wavHeader);\n      extractorOutput.seekMap(wavHeader);\n    }\n\n    long dataLimit = wavHeader.getDataLimit();\n    Assertions.checkState(dataLimit != C.POSITION_UNSET);\n\n    long bytesLeft = dataLimit - input.getPosition();\n    if (bytesLeft <= 0) {\n      return Extractor.RESULT_END_OF_INPUT;\n    }\n\n    int maxBytesToRead = (int) Math.min(MAX_INPUT_SIZE - pendingBytes, bytesLeft);\n    int bytesAppended = trackOutput.sampleData(input, maxBytesToRead, true);\n    if (bytesAppended != RESULT_END_OF_INPUT) {\n      pendingBytes += bytesAppended;\n    }\n\n    // Samples must consist of a whole number of frames.\n    int pendingFrames = pendingBytes / bytesPerFrame;\n    if (pendingFrames > 0) {\n      long timeUs = wavHeader.getTimeUs(input.getPosition() - pendingBytes);\n      int size = pendingFrames * bytesPerFrame;\n      pendingBytes -= size;\n      trackOutput.sampleMetadata(timeUs, C.BUFFER_FLAG_KEY_FRAME, size, pendingBytes, null);\n    }\n\n    return bytesAppended == RESULT_END_OF_INPUT ? RESULT_END_OF_INPUT : RESULT_CONTINUE;\n  }\n\n}<fim_middle>// function below has no smell\n"}