{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.jena.dboe.transaction.txn;\n\nimport java.nio.ByteBuffer;\n\nimport org.apache.jena.atlas.lib.Closeable;\nimport org.apache.jena.atlas.lib.Sync;\nimport org.apache.jena.dboe.base.file.BufferChannel;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/** Helper class for the manage the persistent state of a transactional.\n * The persistent state is assumed to be a fixed size, or at least\n * of known maximum size.\n * May not be suitable for all transactional component implementations.\n */\n\npublic abstract class StateMgrBase implements Sync, Closeable {\n    /* Compare to TransBlob which is a similar idea but where it is a\n     * component in the transaction component group. That can lead to\n     * the wrong control, or at least unclear, of the writing during\n     * the transaction commit cycle.\n     */\n\n    private static Logger log = LoggerFactory.getLogger(StateMgrBase.class);\n\n    private final BufferChannel storage;\n    // One ByteBuffer that is reused where possible.\n    // This is short-term usage\n    // *  get disk state-> deserialize\n    // *  serialize->set disk state\n    // on a single thread (the transaction writer).\n    private ByteBuffer bb;\n    // Is the internal state out of sync with the disk state?\n    private boolean dirty = false;\n\n    protected StateMgrBase(BufferChannel storage, int sizeBytes) {\n        bb = ByteBuffer.allocate(sizeBytes);\n        this.storage = storage;\n    }\n\n    /**\n     * After the default initial state is known, call this, for example, at the\n     * end of the constructor.  If no on-disk state is found, a clean copy is written.\n     */\n    protected void init() {\n        if ( ! storage.isEmpty() )\n            readState();\n        else\n            writeState();\n    }\n\n    /* Serialize the necessary state into a ByteBuffer.\n     * The argument ByteBuffer can be used or a new one returned\n     * if it is the wrong size (e.g. too small).  The returned one will become the\n     * recycled ByteBuffer. The returned ByteBuffer should have posn/limit\n     * delimiting the necessary space to write.\n     */\n    protected abstract ByteBuffer serialize(ByteBuffer bytes);\n\n    /*\n     * Deserialize the persistent state from the ByteBuffer (delimited by posn/limit).\n     * The byte buffer will be the recycled one from last time.\n     * Most\n     */\n    protected abstract void deserialize(ByteBuffer bytes);\n\n    /** Note that the in-memory state is not known to be the same\n     * as the on-disk state.\n     */\n    protected void setDirtyFlag() {\n        dirty = true;\n    }\n\n    /**\n     * Event call for state writing. Called after successful\n     * writing of the state.\n     */\n    protected abstract void writeStateEvent();\n\n    /**\n     * Event call for state reading. Called after successful\n     * deserializing of the state.\n     */\n    protected abstract void readStateEvent();\n\n    /** Note that the in-memory state is the same\n     * as the on-disk state, or at least the on-disk state is\n     * acceptable for restart at any time.\n     */\n    protected void clearDirtyFlag() {\n        dirty = false;\n    }\n\n    /** Low level control - for example, used for cloning setup.\n     * Use with care.\n     */\n    public BufferChannel getBufferChannel() {\n        return storage;\n    }\n\n    /** Return the serialized state using the internal ByteBuffer\n     * Typically called by \"prepare\" for the bytes to write to the journal.\n     * Calls {@link #serialize}.\n     * This method does not perform an external I/O.\n     */\n    public ByteBuffer getState() {\n        bb.rewind();\n        serialize(bb);\n        return bb;\n    }\n\n    /** Set the in-memory state from a ByteBuffer, for example, from journal recovery.\n     * This method does not perform an external I/O.\n     * Call \"writeState\" to put the n-memory state as the disk state.\n     */\n    public void setState(ByteBuffer buff) {\n        buff.rewind();\n        deserialize(buff);\n        dirty = true;\n    }\n\n    //public BufferChannel getChannel() { return storage; }\n\n    /** The write process : serialize, write, sync,\n     * After this, the bytes definitely are on disk, not in some OS cache\n     */\n    public void writeState() {\n        bb.rewind();\n        ByteBuffer bb1 = serialize(bb);\n        if ( bb1 != null )\n            bb = bb1;\n        bb.rewind();\n        int len = storage.write(bb, 0);\n        storage.sync();\n        dirty = false;\n        writeStateEvent();\n    }\n\n    /** The read process : get all bytes on disk, deserialize */\n    public void readState() {\n        bb.rewind();\n        int len = storage.read(bb, 0);\n        bb.rewind();\n        deserialize(bb);\n        readStateEvent();\n    }\n\n<fim_suffix>    @Override\n    public void sync() {\n        if ( dirty )\n            writeState();\n    }\n\n    @Override\n    public void close() {\n        storage.close();\n    }\n}<fim_middle>// function below has no smell\n"}