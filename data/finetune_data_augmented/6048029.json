{"text": "<fim_prefix>\n<fim_suffix>public class GridROI extends RectangularROI implements Serializable {\n\tdouble xSpacing = 50;\n\tdouble ySpacing = 50;\n\tboolean midPointOn = true;\n\tboolean gridLinesOn = false;\n\tprivate GridPreferences gridPref = new GridPreferences();\n\t@SuppressWarnings(\"unused\")\n\tprivate GridROI() {\n\t\tsuper();\n\t}\n\t@SuppressWarnings(\"unused\")\n\tprivate GridROI(double width, double angle) {\n\t\tsuper(width, angle);\n\t}\n\t@SuppressWarnings(\"unused\")\n\tprivate GridROI(double width, double height, double angle) {\n\t\tsuper(width, height, angle);\n\t}\n\t/**\n\t * If using this constructor, you should set x and y spacing and GridPreferences\n\t * at some point.\n\t * \n\t * @param ptx\n\t * @param pty\n\t * @param width\n\t * @param height\n\t * @param angle\n\t */\n\tpublic GridROI(double ptx, double pty, double width, double height, double angle) {\n\t\tsuper(ptx, pty, width, height, angle);\n\t}\n\t@SuppressWarnings(\"unused\")\n\tprivate GridROI(double ptx, double pty, double width, double height, double angle, boolean clip) {\n\t\tsuper(ptx, pty, width, height, angle, clip);\n\t}\n\tprivate GridROI(double ptx, double pty, double width, double height, double angle, double xSpacing, double ySpacing) {\n\t\tsuper(ptx, pty, width, height, angle, false);\n\t\tthis.xSpacing = xSpacing;\n\t\tthis.ySpacing = ySpacing;\n\t}\n\tpublic GridROI(double ptx, double pty, double width, double height, double angle, double xSpacing, double ySpacing,\n\t\t\tboolean gridLinesOn, boolean midPointOn) {\n\t\tthis(ptx, pty, width, height, angle, xSpacing, ySpacing);\n\t\tthis.gridLinesOn = gridLinesOn;\n\t\tthis.midPointOn = midPointOn;\n\t}\n\tpublic GridROI(double ptx, double pty, double width, double height, double angle, double xSpacing, double ySpacing,\n\t\t\tboolean gridLinesOn, boolean midPointOn, GridPreferences gridPref) {\n\t\tthis(ptx, pty, width, height, angle, xSpacing, ySpacing);\n\t\tthis.gridLinesOn = gridLinesOn;\n\t\tthis.midPointOn = midPointOn;\n\t\tthis.gridPref = gridPref;\n\t}\n\tpublic GridROI(GridPreferences gridPrefs) {\n\t\tthis.gridPref = gridPrefs;\n\t}\n\t@Override\n\tpublic GridROI copy() {\n\t\tGridROI c = new GridROI(spt[0], spt[1], len[0], len[1], getAngle(), xSpacing,\n\t\t\t\tySpacing, gridLinesOn, midPointOn, gridPref);\n\t\tc.name = name;\n\t\tc.plot = plot;\n\t\treturn c;\n\t}\n\t/**\n\t * @return Returns the spacing of X and Y grid\n\t */\n\tpublic double[] getSpacing() {\n\t\treturn new double[] { xSpacing, ySpacing };\n\t}\n\t/**\n\t * @return integer lengths\n\t */\n\tpublic int[] getIntSpacing() {\n\t\treturn new int[] { (int) xSpacing, (int) ySpacing };\n\t}\n\t/**\n\t * Work out where all the grid points (middle of grid box) are\n\t * \n\t * @return grid points\n\t */\n\tpublic double[][] getGridPoints() {\n\t\tfinal double[] len = getLengths();\n\t\tfinal double[] spt = getPointRef();\n\t\tint xGrids = (int) ((len[0] / xSpacing) + 0.5);\n\t\tint yGrids = (int) ((len[1] / ySpacing) + 0.5);\n\t\tdouble[] xLocs = new double[xGrids];\n\t\tdouble[] yLocs = new double[yGrids];\n\t\tif (xGrids != 0 && yGrids != 0) {\n\t\t\txLocs[0] = spt[0] + xSpacing / 2.0;\n\t\t\tyLocs[0] = spt[1] + ySpacing / 2.0;\n\t\t\tfor (int i = 1; i < xGrids; i++) {\n\t\t\t\txLocs[i] = xLocs[0] + xSpacing * i;\n\t\t\t}\n\t\t\tfor (int i = 1; i < yGrids; i++) {\n\t\t\t\tyLocs[i] = yLocs[0] + ySpacing * i;\n\t\t\t}\n\t\t}\n\t\tdouble[][] gp = new double[2][];\n\t\tgp[0] = xLocs;\n\t\tgp[1] = yLocs;\n\t\treturn gp;\n\t}\n\tpublic double[][] getGridLines() {\n\t\tdouble[][] gp = getGridPoints();\n\t\tint xGrids = gp[0].length;\n\t\tint yGrids = gp[1].length;\n\t\tdouble[][] gl = new double[2][];\n\t\tif (getSpacing()[0] * xGrids >= getLengths()[0]) {\n\t\t\txGrids--;\n\t\t\tif (xGrids < 0) {\n\t\t\t\txGrids = 0;\n\t\t\t}\n\t\t\tgl[0] = new double[xGrids];\n\t\t} else {\n\t\t\tgl[0] = gp[0];\n\t\t}\n\t\tif (getSpacing()[1] * yGrids >= getLengths()[1]) {\n\t\t\tyGrids--;\n\t\t\tif (yGrids < 0) {\n\t\t\t\tyGrids = 0;\n\t\t\t}\n\t\t\tgl[1] = new double[yGrids];\n\t\t} else {\n\t\t\tgl[1] = gp[1];\n\t\t}\n\t\tfor (int i = 0; i < xGrids; i++) {\n\t\t\tgl[0][i] = gp[0][i] + xSpacing / 2.0;\n\t\t}\n\t\tfor (int i = 0; i < yGrids; i++) {\n\t\t\tgl[1][i] = gp[1][i] + ySpacing / 2.0;\n\t\t}\n\t\treturn gl;\n\t}\n\t/**\n\t * @return Returns the value for x-axis resolution\n\t */\n\tpublic double getxSpacing() {\n\t\treturn xSpacing;\n\t}\n\t/**\n\t * @return Returns the value for y-axis resolution\n\t */\n\tpublic double getySpacing() {\n\t\treturn ySpacing;\n\t}\n\t/**\n\t * @param xSpacing\n\t *            Sets grid resolution for x-axis\n\t * @param ySpacing\n\t *            Sets grid resolution for y-axis\n\t */\n\tpublic void setxySpacing(double xSpacing, double ySpacing) {\n\t\tthis.xSpacing = xSpacing;\n\t\tthis.ySpacing = ySpacing;\n\t}\n\tpublic void setxSpacing(double xSpacing) {\n\t\tthis.xSpacing = xSpacing;\n\t}\n\tpublic void setySpacing(double ySpacing) {\n\t\tthis.ySpacing = ySpacing;\n\t}\n\t/**\n\t * @return Returns true if midpoints are enabled, false otherwise\n\t */\n\tpublic boolean isMidPointOn() {\n\t\treturn midPointOn;\n\t}\n\t/**\n\t * @param midPointOn\n\t *            Turns on display of midpoints\n\t */\n\tpublic void setMidPointOn(boolean midPointOn) {\n\t\tthis.midPointOn = midPointOn;\n\t}\n\t/**\n\t * @return Returns true if gridpoints are enabled, false otherwise\n\t */\n\tpublic boolean isGridLineOn() {\n\t\treturn gridLinesOn;\n\t}\n\t/**\n\t * @param gridLinesOn\n\t *            Turns on display of gridpoints\n\t */\n\tpublic void setGridLineOn(boolean gridLinesOn) {\n\t\tthis.gridLinesOn = gridLinesOn;\n\t}\n\tpublic int getNumberOfPoints() {\n\t\tint[] dimensions = getDimensions();\n\t\treturn dimensions[0] * dimensions[1];\n\t}\n\tpublic int[] getDimensions() {\n\t\tdouble[][] gp = getGridPoints();\n\t\treturn new int[] { gp[0].length, gp[1].length };\n\t}\n\t/**\n\t * returns an array of (x, y) tuples that represent the physical amount the motors \n\t * have to be driven relative to the current position (when taking the image) to drive \n\t * every point on the grid into the beam.\n\t * \n\t * @return the tuples\n\t */\n\tpublic double[][] getPhysicalGridPoints() {\n\t\tdouble[][] gp = getGridPoints();\n\t\tdouble[][] xyTuples = new double[getNumberOfPoints()][2];\n\t\tdouble cang = Math.cos(getAngle());<fim_middle>// class below has no smell\n"}