{"text": "<fim_prefix>\t\t\tfinal String name = fileURI.lastSegment();\n\t\t\tout.printf(\"%-50s   %3d   (%3d = %3d + %3d + %3d) in %5d ms\",\n\t\t\t\t\tname,\n\t\t\t\t\tcountTotal,\n\t\t\t\t\tcountLoadedFromAST + countLoadedFromIndex + countBuiltIn,\n\t\t\t\t\tcountLoadedFromAST,\n\t\t\t\t\tcountLoadedFromIndex,\n\t\t\t\t\tcountBuiltIn,\n\t\t\t\t\ttimeInMs);\n\t\t\tout.println();\n\t\t}\n\t\tstatic void printReport(IN4JSProject project, List<FileLoadInfo> results, PrintStream out, String elapsedTime) {\n\t\t\tout.println(\"------------------------------------------------------------------------------------\");\n\t\t\tout.println(\"Resource loading per file for project: \" + project.getLocation().lastSegment() + \" took \"\n\t\t\t\t\t+ elapsedTime);\n\t\t\tout.println();\n\t\t\tfinal List<FileLoadInfo> othersFromAST = results.stream().filter(result -> result.countLoadedFromAST > 0)\n\t\t\t\t\t.collect(Collectors.toList());\n\t\t\tfinal List<FileLoadInfo> noOthersFromAST = results.stream().filter(result -> result.countLoadedFromAST == 0)\n\t\t\t\t\t.collect(Collectors.toList());\n\t\t\tout.println(\"Files that triggered other files being loaded from AST:\");\n\t\t\tif (!othersFromAST.isEmpty()) {\n\t\t\t\tothersFromAST.forEach(result -> result.println(out));\n\t\t\t} else {\n\t\t\t\tout.println(\"None.\");\n\t\t\t}\n\t\t\tout.println();\n\t\t\tout.println(\"Files that did *not* trigger other files being loaded from AST:\");\n\t\t\tif (!noOthersFromAST.isEmpty()) {\n\t\t\t\tnoOthersFromAST.forEach(result -> result.println(out));\n\t\t\t} else {\n\t\t\t\tout.println(\"None.\");\n\t\t\t}\n\t\t\tout.println();\n\t\t\tout.println(\"Legend: countTotal (sum = countLoadedFromAST + countLoadedFromIndex + countBuiltIn)\");\n\t\t\tout.println();\n\t\t\tout.println(\n\t\t\t\t\t\"Files that triggered other files being loaded from AST        : \" + othersFromAST.size());\n\t\t\tout.println(\n\t\t\t\t\t\"Files that did *not* trigger other files being loaded from AST: \" + noOthersFromAST.size());\n\t\t\tout.println(\"------------------------------------------------------------------------------------\");\n\t\t}\n\t}\n\t/**\n\t * Computes and prints resource loading statistics for all N4JS[X] projects in the workspace.\n\t * <p>\n\t * For each N4JS[X] file in the workspace, this method will\n\t * <ol>\n\t * <li>create a new, empty resource set,\n\t * <li>load the file into this resource set and fully process it (parser, types builder, post-processing),\n\t * <li>count how many other files/resources were automatically loaded into the resource set and if they were loaded\n\t * from AST or from Xtext index,\n\t * <li>print statistics to the given stream.\n\t * </ol>\n\t */\n\tpublic void computeAndShowStatsForWorkspace(PrintStream out, IProgressMonitor monitor) {\n\t\tfinal CancelIndicator cancelIndicator = new MonitorBasedCancelIndicator(monitor);\n\t\t// for proper progress reporting, first collect all URIs in all N4JS projects\n\t\tint uriCount = 0;\n\t\tfinal Map<IN4JSProject, List<URI>> urisPerProject = new LinkedHashMap<>();\n\t\tfinal Iterable<IN4JSProject> projects = n4jsCore.findAllProjects();\n\t\tfor (IN4JSProject project : projects) {\n\t\t\toperationCanceledManager.checkCanceled(cancelIndicator);\n\t\t\tif (!isManagedByLibraryManager(project)) {\n\t\t\t\tfinal List<URI> uris = collectURIsToInvestigate(project);\n\t\t\t\turiCount += uris.size();\n\t\t\t\turisPerProject.put(project, uris);\n\t\t\t}\n\t\t}\n\t\t// now do the actual work: compute and show statistics for each project\n\t\tmonitor.beginTask(\"Investigate projects in workspace ... \", uriCount);\n\t\tfor (Entry<IN4JSProject, List<URI>> entry : urisPerProject.entrySet()) {\n\t\t\toperationCanceledManager.checkCanceled(cancelIndicator);\n\t\t\tStopwatch stopwatch = Stopwatch.createStarted();\n\t\t\tfinal IN4JSProject project = entry.getKey();\n\t\t\tfinal List<URI> uris = entry.getValue();\n\t\t\tfinal List<FileLoadInfo> results = investigate(project, uris, out, monitor, false);\n\t\t\tout.println();\n\t\t\tout.println(\"SUMMARY:\");\n\t\t\tout.println();\n\t\t\tFileLoadInfo.printReport(project, results, out, stopwatch.toString());\n\t\t}\n\t}\n\t/**\n\t * This method assumes the given resource set has at least 1 resource and that the first resource is the main\n\t * resource, i.e. the only resource for which loading and proxy resolution was triggered explicitly (and thus all\n\t * other resources can be assumed to have been loaded incidentally while processing the first).\n\t */\n\tpublic void computeAndShowStatsForResourceSet(ResourceSet resSet, PrintStream out) {\n\t\tfinal FileLoadInfo info = investigate(resSet);\n\t\tinfo.println(out);\n\t}\n\tprivate List<FileLoadInfo> investigate(IN4JSProject project, List<URI> urisToInvestigate,\n\t\t\tPrintStream out, IProgressMonitor monitor, boolean printProgressToOut) {\n\t\tfinal int urisCount = urisToInvestigate.size();\n\t\tfinal List<FileLoadInfo> results = new ArrayList<>(urisCount);\n\t\tfor (int i = 0; i < urisCount; i++) {\n\t\t\tfinal URI uri = urisToInvestigate.get(i);\n\t\t\tmonitor.subTask(\"Investigating file \" + uri.lastSegment() + \" ...\");\n\t\t\tStopwatch perResource = Stopwatch.createStarted();\n\t\t\tif (printProgressToOut) {\n\t\t\t\tfinal int progress = (int) Math.floor(((float) i) / ((float) urisCount) * 100.0f);\n\t\t\t\tout.println(\"Investigating file \" + uri.lastSegment()\n\t\t\t\t\t\t+ \" (\" + (i + 1) + \"/\" + urisCount + \", \" + progress + \"%) ...\");\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tfinal FileLoadInfo currResult = investigate(project, uri, monitor);\n\t\t\t\tresults.add(currResult);\n\t\t\t\tcurrResult.timeInMs = perResource.elapsed(TimeUnit.MILLISECONDS);\n\t\t\t\tcurrResult.println(out); // note: print currResult always (even if !printProgressToOut)\n\t\t\t} catch (Throwable th) {\n\t\t\t\tif (operationCanceledManager.isOperationCanceledException(th)) {\n\t\t\t\t\t// don't propagate the cancel exception; instead, return the results collected thus far\n\t\t\t\t\treturn results;\n\t\t\t\t}\n\t\t\t\tth.printStackTrace();\n\t\t\t\t// do not abort if investigation of one file fails\n\t\t\t} finally {\n\t\t\t\tmonitor.worked(1);\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}\n\tprivate FileLoadInfo investigate(IN4JSProject project, URI fileURI, IProgressMonitor monitor) {\n\t\tfinal CancelIndicator cancelIndicator = new MonitorBasedCancelIndicator(monitor);\n\t\toperationCanceledManager.checkCanceled(cancelIndicator);\n\t\tfinal ResourceSet resSet = n4jsCore.createResourceSet(Optional.of(project));\n\t\tfinal N4JSResource res = (N4JSResource) resSet.createResource(fileURI);\n\t\ttry {\n\t\t\tres.load(Collections.emptyMap());\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tres.getContents(); // trigger loading of AST\n\t\tres.resolveLazyCrossReferences(cancelIndicator);\n\t\t// now start counting what was loaded incidentally ...\n\t\treturn investigate(resSet);\n\t}\n\t/** This method makes the same assumptions as {@link #computeAndShowStatsFor(ResourceSet)}. */\n\tprivate FileLoadInfo investigate(ResourceSet resSet) {\n\t\tfinal Resource resMain = resSet.getResources().get(0);\n\t\tfinal FileLoadInfo result = new FileLoadInfo(resMain.getURI());\n\t\tresult.countTotal = resSet.getResources().size();\n\t\tresult.countBuiltIn = countN4JSResourcesBuiltIn(resSet);\n\t\tresult.countLoadedFromAST = countN4JSResourcesLoadedFromAST(resSet) - 1; // do not count 'res' itself\n\t\tresult.countLoadedFromIndex = countN4JSResourcesLoadedFromIndex(resSet);\n\t\treturn result;\n\t}\n<fim_suffix>\tprivate int countN4JSResourcesBuiltIn(ResourceSet resSet) {\n\t\tint n = 0;\n\t\tfor (Resource res : resSet.getResources()) {\n\t\t\tif (isBuiltInResource(res)) {\n\t\t\t\tn++;\n\t\t\t}\n\t\t}\n\t\treturn n;\n\t}<fim_middle>// function below has no smell\n"}