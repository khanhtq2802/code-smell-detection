{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.falcon.hadoop;\n\nimport org.apache.commons.codec.digest.DigestUtils;\nimport org.apache.commons.io.FileUtils;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.fs.FSDataInputStream;\nimport org.apache.hadoop.fs.FSDataOutputStream;\nimport org.apache.hadoop.fs.FileChecksum;\nimport org.apache.hadoop.fs.FileStatus;\nimport org.apache.hadoop.fs.FileSystem;\nimport org.apache.hadoop.fs.LocalFileSystem;\nimport org.apache.hadoop.fs.Path;\nimport org.apache.hadoop.fs.permission.FsPermission;\nimport org.apache.hadoop.util.Progressable;\n\nimport java.io.DataInput;\nimport java.io.DataOutput;\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URI;\n\n/**\n * chroot local file system for tests.\n */\npublic class JailedFileSystem extends FileSystem {\n    private URI uri;\n    private String basePath;\n    private LocalFileSystem localFS;\n    private Path workingDir;\n\n    public JailedFileSystem() {\n        localFS = new LocalFileSystem();\n        this.workingDir = new Path(\"/user\", System.getProperty(\"user.name\"));\n    }\n\n    @Override\n    public void initialize(URI name, Configuration conf) throws IOException {\n        super.initialize(name, conf);\n        setConf(conf);\n        localFS.initialize(LocalFileSystem.getDefaultUri(conf), conf);\n        String base = name.getHost();\n        if (base == null) {\n            throw new IOException(\"Incomplete Jail URI, no jail base: \"+ name);\n        }\n        basePath = new Path(conf.get(\"jail.base\", System.getProperty(\"hadoop.tmp.dir\",\n                        System.getProperty(\"user.dir\") + \"/target/falcon/tmp-hadoop-\"\n                                + System.getProperty(\"user.name\"))) + \"/jail-fs/\" + base).toUri().getPath();\n        this.uri = URI.create(name.getScheme()+\"://\"+name.getAuthority());\n    }\n\n    @Override\n    public URI getUri() {\n        return uri;\n    }\n\n    private Path toLocalPath(Path f) {\n        if (!f.isAbsolute()) {\n            f = new Path(getWorkingDirectory(), f);\n        }\n        return new Path(basePath + f.toUri().getPath());\n    }\n\n<fim_suffix>    @Override\n    public FSDataInputStream open(Path f, int bufferSize) throws IOException {\n        return localFS.open(toLocalPath(f), bufferSize);\n    }\n\n    @Override\n    public FSDataOutputStream create(Path f, FsPermission permission, boolean overwrite, int bufferSize,\n                                     short replication, long blockSize, Progressable progress) throws IOException {\n        return localFS.create(toLocalPath(f), permission, overwrite, bufferSize,\n                replication, blockSize, progress);\n    }\n\n    @Override\n    public FSDataOutputStream create(Path f) throws IOException {\n        return localFS.create(toLocalPath(f));\n    }\n\n    @Override\n    public FSDataOutputStream append(Path f, int bufferSize, Progressable progress) throws IOException {\n        return localFS.append(toLocalPath(f), bufferSize, progress);\n    }\n\n    @Override\n    public boolean rename(Path src, Path dst) throws IOException {\n        return localFS.rename(toLocalPath(src), toLocalPath(dst));\n    }\n\n    @Override\n    public boolean delete(Path f, boolean recursive) throws IOException {\n        Path localPath = toLocalPath(f);\n        if (localPath.toUri().getPath().trim().equals(\"/\")) {\n            throw new AssertionError(\"Attempting to delete root \" + localPath);\n        }\n\n        return localFS.delete(localPath, recursive);\n    }\n\n    @Override\n    public FileStatus[] listStatus(Path f) throws IOException {\n        FileStatus[] fileStatuses = localFS.listStatus(toLocalPath(f));\n        if (fileStatuses == null || fileStatuses.length == 0) {\n            return fileStatuses;\n        } else {\n            FileStatus[] jailFileStatuses = new FileStatus[fileStatuses.length];\n            for (int index = 0; index < fileStatuses.length; index++) {\n                FileStatus status = fileStatuses[index];\n                jailFileStatuses[index] = new FileStatus(status.getLen(), status.isDirectory(),\n                        status.getReplication(), status.getBlockSize(), status.getModificationTime(),\n                        status.getAccessTime(), status.getPermission(), status.getOwner(), status.getGroup(),\n                        fromLocalPath(status.getPath())\n                                .makeQualified(this.getUri(), this.getWorkingDirectory()));\n            }\n            return jailFileStatuses;\n        }\n    }\n\n    @Override\n    public void setWorkingDirectory(Path newDir) {\n        if (newDir != null) {\n            workingDir = makeAbsolute(newDir);\n        }\n    }\n\n    private Path makeAbsolute(Path path) {\n        if (path.isAbsolute()) {\n            return path;\n        }\n        return new Path(workingDir, path);\n    }\n\n    @Override\n    public Path getWorkingDirectory() {\n        return workingDir;\n    }\n\n    @Override\n    public boolean mkdirs(Path f, FsPermission permission) throws IOException {\n        return localFS.mkdirs(toLocalPath(f), permission);\n    }\n\n    @Override\n    public void setPermission(Path p, FsPermission permission) throws IOException {\n        localFS.setPermission(toLocalPath(p), permission);\n    }\n\n    @Override\n    public FileChecksum getFileChecksum(Path f) throws IOException {\n        final byte[] md5 = DigestUtils.md5(FileUtils.readFileToByteArray(new File(toLocalPath(f).toString())));\n        return new FileChecksum() {\n\n            @Override\n            public String getAlgorithmName() {\n                return \"MD5\";\n            }\n\n            @Override\n            public int getLength() {\n                return md5.length;\n            }\n\n            @Override\n            public byte[] getBytes() {\n                return md5;\n            }\n\n            @Override\n            public void write(DataOutput out) throws IOException {\n            }\n\n            @Override\n            public void readFields(DataInput in) throws IOException {\n            }\n        };\n    }\n\n    @Override\n    public FileStatus getFileStatus(Path f) throws IOException {\n        FileStatus status = localFS.getFileStatus(toLocalPath(f));\n        if (status == null) {\n            return null;\n        }\n        return new FileStatus(status.getLen(), status.isDirectory(),\n                status.getReplication(), status.getBlockSize(), status.getModificationTime(),\n                status.getAccessTime(), status.getPermission(), status.getOwner(), status.getGroup(),\n                fromLocalPath(status.getPath()).makeQualified(this.getUri(), this.getWorkingDirectory()));\n    }\n\n    private Path fromLocalPath(Path path) {\n        String pathString = path.toUri().getPath().replaceFirst(basePath, \"\");\n        return new Path(pathString.isEmpty() ? \"/\" : pathString);\n    }\n\n    @Override\n    public void setTimes(Path p, long mtime, long atime) throws IOException {\n        super.setTimes(p, mtime, atime);\n    }\n\n    @Override\n    public void close() throws IOException {\n        localFS.close();\n    }\n}<fim_middle>// function below has no smell\n"}