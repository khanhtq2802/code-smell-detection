{"text": "<fim_prefix>                    SAXDocumentFactory df = new SAXDocumentFactory(document\n                            .getImplementation(), XMLResourceDescriptor\n                            .getXMLParserClassName());\n                    DocumentFragment documentFragment = (DocumentFragment) DOMUtilities\n                            .parseXML(toParse, document, uri, prefixes,\n                                    SVGConstants.SVG_SVG_TAG, df);\n                    nodeToAdd = documentFragment.getFirstChild();\n                    break;\n                case Node.TEXT_NODE:\n                    nodeToAdd = document.createTextNode(toParse);\n                    break;\n                case Node.COMMENT_NODE:\n                    nodeToAdd = document.createComment(toParse);\n                    break;\n                case Node.CDATA_SECTION_NODE:\n                    nodeToAdd = document.createCDATASection(toParse);\n                }\n                // Append the new node to the parentNode\n                TreePath[] treePaths = tree.getSelectionPaths();\n                if (treePaths != null) {\n                    TreePath treePath = treePaths[treePaths.length - 1];\n                    DefaultMutableTreeNode node = (DefaultMutableTreeNode) treePath\n                            .getLastPathComponent();\n                    NodeInfo nodeInfo = (NodeInfo) node.getUserObject();\n                    addChangesToHistory();\n                    historyBrowserInterface.appendChild(nodeInfo.getNode(),\n                            nodeToAdd);\n                }\n            }\n        }\n        /**\n         * Creates JMenu menu using {@link NodeTemplates}.\n         *\n         * @param name\n         *            The name of the submenu\n         * @return The JMenu submenu\n         */\n        protected JMenu createTemplatesMenu(String name) {\n            NodeTemplates templates = new NodeTemplates();\n            JMenu submenu = new JMenu(name);\n            // Create submenus\n            HashMap menuMap = new HashMap();\n            ArrayList categoriesList = templates.getCategories();\n            int n = categoriesList.size();\n            for (Object aCategoriesList : categoriesList) {\n                String category = aCategoriesList.toString();\n                JMenu currentMenu = new JMenu(category);\n                submenu.add(currentMenu);\n                // Add submenus to the map\n                menuMap.put(category, currentMenu);\n            }\n            // Sort the value list and then iterate through node templates\n            ArrayList values =\n                new ArrayList(templates.getNodeTemplatesMap().values());\n            Collections.sort(values, new Comparator() {\n                public int compare(Object o1, Object o2) {\n                    NodeTemplateDescriptor n1 = (NodeTemplateDescriptor) o1;\n                    NodeTemplateDescriptor n2 = (NodeTemplateDescriptor) o2;\n                    return n1.getName().compareTo(n2.getName());\n                }\n            });\n            for (Object value : values) {\n                NodeTemplateDescriptor desc =\n                        (NodeTemplateDescriptor) value;\n                String toParse = desc.getXmlValue();\n                short nodeType = desc.getType();\n                String nodeCategory = desc.getCategory();\n                JMenuItem currentItem = new JMenuItem(desc.getName());\n                currentItem.addActionListener\n                        (new NodeTemplateParser(toParse, nodeType));\n                JMenu currentSubmenu = (JMenu) menuMap.get(nodeCategory);\n                currentSubmenu.add(currentItem);\n            }\n            return submenu;\n        }\n        /**\n         * Handles tree pop-up menu action for removing nodes.\n         */\n        protected class TreeNodeRemover implements ActionListener {\n            public void actionPerformed(ActionEvent e) {\n                addChangesToHistory();\n                AbstractCompoundCommand cmd = historyBrowserInterface\n                        .createRemoveSelectedTreeNodesCommand(null);\n                TreePath[] treePaths = tree.getSelectionPaths();\n                for (int i = 0; treePaths != null && i < treePaths.length; i++) {\n                    TreePath treePath = treePaths[i];\n                    DefaultMutableTreeNode node = (DefaultMutableTreeNode) treePath\n                            .getLastPathComponent();\n                    NodeInfo nodeInfo = (NodeInfo) node.getUserObject();\n                    if (DOMUtilities.isParentOf(nodeInfo.getNode(),\n                            nodeInfo.getNode().getParentNode())) {\n                        cmd.addCommand(historyBrowserInterface\n                                .createRemoveChildCommand(nodeInfo.getNode()\n                                        .getParentNode(), nodeInfo.getNode()));\n                    }\n                }\n                historyBrowserInterface.performCompoundUpdateCommand(cmd);\n            }\n        }\n        /**\n         * To listen to the tree selection.\n         */\n        protected class DOMTreeSelectionListener\n                implements TreeSelectionListener {\n            /**\n             * Called when the selection changes.\n             */\n            public void valueChanged(TreeSelectionEvent ev) {\n                // Manages the selection overlay\n                if (elementOverlayManager != null) {\n                    handleElementSelection(ev);\n                }\n                DefaultMutableTreeNode mtn;\n                mtn = (DefaultMutableTreeNode)\n                    tree.getLastSelectedPathComponent();\n                if (mtn == null) {\n                    return;\n                }\n                if (rightPanel.getComponentCount() != 0) {\n                    rightPanel.remove(0);\n                }\n                Object nodeInfo = mtn.getUserObject();\n                if (nodeInfo instanceof NodeInfo) {\n                    Node node = ((NodeInfo) nodeInfo).getNode();\n                    switch (node.getNodeType()) {\n                    case Node.DOCUMENT_NODE:\n                        documentInfo.setText\n                            (createDocumentText((Document) node));\n                        rightPanel.add(documentInfoPanel);\n                        break;\n                    case Node.ELEMENT_NODE:\n                        propertiesTable.setModel(new NodeCSSValuesModel(node));\n                        attributePanel.promptForChanges();\n                        attributePanel.setPreviewElement((Element) node);\n                        rightPanel.add(elementPanel);\n                        break;\n                    case Node.COMMENT_NODE:\n                    case Node.TEXT_NODE:\n                    case Node.CDATA_SECTION_NODE:\n                        characterDataPanel.setNode(node);\n                        characterDataPanel.getTextArea().setText\n                            (node.getNodeValue());\n                        rightPanel.add(characterDataPanel);\n                    }\n                }\n                splitPane.revalidate();\n                splitPane.repaint();\n            }\n            protected String createDocumentText(Document doc) {\n                StringBuffer sb = new StringBuffer();\n                sb.append(\"Nodes: \");\n                sb.append(nodeCount(doc));\n                return sb.toString();\n            }\n            protected int nodeCount(Node node) {\n                int result = 1;\n                for (Node n = node.getFirstChild();\n                     n != null;\n                     n = n.getNextSibling()) {\n                    result += nodeCount(n);\n                }\n                return result;\n            }\n            /**\n             * Processes element selection overlay.\n             *\n             * @param ev\n             *            Tree selection event\n             */\n            protected void handleElementSelection(TreeSelectionEvent ev) {\n                TreePath[] paths = ev.getPaths();\n                for (TreePath path : paths) {\n                    DefaultMutableTreeNode mtn =\n                            (DefaultMutableTreeNode) path.getLastPathComponent();\n                    Object nodeInfo = mtn.getUserObject();\n                    if (nodeInfo instanceof NodeInfo) {\n                        Node node = ((NodeInfo) nodeInfo).getNode();\n                        if (node.getNodeType() == Node.ELEMENT_NODE) {\n                            if (ev.isAddedPath(path)) {\n                                elementOverlayManager.addElement\n                                        ((Element) node);\n                            } else {\n                                elementOverlayManager.removeElement\n                                        ((Element) node);\n                            }\n                        }\n                    }\n                }\n                elementOverlayManager.repaint();\n            }\n        }\n        /**\n         * To render the tree nodes.\n         */\n        protected class NodeRenderer extends DefaultTreeCellRenderer {\n            /**\n             * The icon used to represent elements.\n             */\n            protected ImageIcon elementIcon;\n            /**\n             * The icon used to represent comments.\n             */\n            protected ImageIcon commentIcon;\n            /**\n             * The icon used to represent processing instructions.\n             */\n            protected ImageIcon piIcon;\n            /**\n             * The icon used to represent text.\n             */\n            protected ImageIcon textIcon;\n            /**\n             * Creates a new NodeRenderer object.\n             */\n            public NodeRenderer() {\n                String s;\n                s = resources.getString(\"Element.icon\");\n                elementIcon = new ImageIcon(getClass().getResource(s));\n                s = resources.getString(\"Comment.icon\");\n                commentIcon = new ImageIcon(getClass().getResource(s));\n                s = resources.getString(\"PI.icon\");\n                piIcon = new ImageIcon(getClass().getResource(s));\n                s = resources.getString(\"Text.icon\");\n                textIcon = new ImageIcon(getClass().getResource(s));\n            }\n            /**\n             * Sets the value of the current tree cell.\n             */\n<fim_suffix>            public Component getTreeCellRendererComponent(JTree tree,\n                                                          Object value,\n                                                          boolean sel,\n                                                          boolean expanded,\n                                                          boolean leaf,\n                                                          int row,\n                                                          boolean hasFocus) {\n                super.getTreeCellRendererComponent(tree, value, sel, expanded,\n                                                   leaf, row, hasFocus);\n                switch (getNodeType(value)) {\n                case Node.ELEMENT_NODE:\n                    setIcon(elementIcon);\n                    break;\n                case Node.COMMENT_NODE:\n                    setIcon(commentIcon);\n                    break;\n                case Node.PROCESSING_INSTRUCTION_NODE:\n                    setIcon(piIcon);\n                    break;\n                case Node.TEXT_NODE:\n                case Node.CDATA_SECTION_NODE:\n                    setIcon(textIcon);\n                    break;\n                }\n                return this;\n            }<fim_middle>// function below has no smell\n"}