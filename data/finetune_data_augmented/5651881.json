{"text": "<fim_prefix>import org.apache.sqoop.mapreduce.HBaseBulkImportJob;\nimport org.apache.sqoop.mapreduce.JdbcCallExportJob;\nimport org.apache.sqoop.util.LoggingUtils;\nimport org.apache.sqoop.util.SqlTypeMap;\nimport org.apache.sqoop.SqoopOptions;\nimport org.apache.sqoop.hbase.HBaseUtil;\nimport org.apache.sqoop.mapreduce.DataDrivenImportJob;\nimport org.apache.sqoop.mapreduce.HBaseImportJob;\nimport org.apache.sqoop.mapreduce.ImportJobBase;\nimport org.apache.sqoop.mapreduce.JdbcExportJob;\nimport org.apache.sqoop.mapreduce.JdbcUpdateExportJob;\nimport org.apache.sqoop.mapreduce.db.DataDrivenDBInputFormat;\nimport org.apache.sqoop.util.ExportException;\nimport org.apache.sqoop.util.ImportException;\nimport org.apache.sqoop.util.ResultSetPrinter;\n/**\n * ConnManager implementation for generic SQL-compliant database.\n * This is an abstract class; it requires a database-specific\n * ConnManager implementation to actually create the connection.\n */\npublic abstract class SqlManager\n    extends org.apache.sqoop.manager.ConnManager {\n  public static final Log LOG = LogFactory.getLog(SqlManager.class.getName());\n  /** Substring that must appear in free-form queries submitted by users.\n   * This is the string '$CONDITIONS'.\n   */\n  public static final String SUBSTITUTE_TOKEN =\n      DataDrivenDBInputFormat.SUBSTITUTE_TOKEN;\n  protected static final int DEFAULT_FETCH_SIZE = 1000;\n  private Statement lastStatement;\n  /**\n   * Constructs the SqlManager.\n   * @param opts the SqoopOptions describing the user's requested action.\n   */\n  public SqlManager(final SqoopOptions opts) {\n    this.options = opts;\n    initOptionDefaults();\n  }\n  /**\n   * Sets default values for values that were not provided by the user.\n   * Only options with database-specific defaults should be configured here.\n   */\n  protected void initOptionDefaults() {\n    if (options.getFetchSize() == null) {\n      LOG.info(\"Using default fetchSize of \" + DEFAULT_FETCH_SIZE);\n      options.setFetchSize(DEFAULT_FETCH_SIZE);\n    }\n  }\n  /**\n   * @return the SQL query to use in getColumnNames() in case this logic must\n   * be tuned per-database, but the main extraction loop is still inheritable.\n   */\n  protected String getColNamesQuery(String tableName) {\n    // adding where clause to prevent loading a big table\n    return \"SELECT t.* FROM \" + escapeTableName(tableName) + \" AS t WHERE 1=0\";\n  }\n  @Override\n  /** {@inheritDoc} */\n  public String[] getColumnNames(String tableName) {\n    String stmt = getColNamesQuery(tableName);\n    return filterSpecifiedColumnNames(getColumnNamesForRawQuery(stmt));\n  }\n  /**\n  * Utilize the --columns option, if specified.\n  * @param columns\n  * @return the subset of columns which were specified by --columns option.\n  */\n  protected String[] filterSpecifiedColumnNames(String[] columns) {\n    if (options.getColumns() == null) {\n      return columns;\n    }\n    List<String> colNames = new ArrayList<String>();\n    for (String col : columns) {\n      String userColName = options.getColumnNameCaseInsensitive(col);\n      if (userColName != null) {\n        colNames.add(userColName);\n      }\n    }\n    return colNames.toArray(new String[colNames.size()]);\n  }\n  @Override\n  /** {@inheritDoc} */\n  public String [] getColumnNamesForQuery(String query) {\n    String rawQuery = query.replace(SUBSTITUTE_TOKEN, \" (1 = 0) \");\n    return getColumnNamesForRawQuery(rawQuery);\n  }\n  /**\n   * Get column names for a query statement that we do not modify further.\n   */\n  public String[] getColumnNamesForRawQuery(String stmt) {\n    ResultSet results;\n    try {\n      results = execute(stmt);\n    } catch (SQLException sqlE) {\n      LoggingUtils.logAll(LOG, \"Error executing statement: \" + sqlE.toString(),\n        sqlE);\n      release();\n      return null;\n    }\n    try {\n      int cols = results.getMetaData().getColumnCount();\n      ArrayList<String> columns = new ArrayList<String>();\n      ResultSetMetaData metadata = results.getMetaData();\n      for (int i = 1; i < cols + 1; i++) {\n        String colName = metadata.getColumnLabel(i);\n        if (colName == null || colName.equals(\"\")) {\n          colName = metadata.getColumnName(i);\n          if (null == colName) {\n            colName = \"_RESULT_\" + i;\n          }\n        }\n        columns.add(colName);\n        LOG.debug(\"Found column \" + colName);\n      }\n      return columns.toArray(new String[0]);\n    } catch (SQLException sqlException) {\n      LoggingUtils.logAll(LOG, \"Error reading from database: \"\n          + sqlException.toString(), sqlException);\n      return null;\n    } finally {\n      try {\n        results.close();\n        getConnection().commit();\n      } catch (SQLException sqlE) {\n        LoggingUtils.logAll(LOG, \"SQLException closing ResultSet: \"\n          + sqlE.toString(), sqlE);\n      }\n      release();\n    }\n  }\n  @Override\n  public String[] getColumnNamesForProcedure(String procedureName) {\n    List<String> ret = new ArrayList<String>();\n    try {\n      DatabaseMetaData metaData = this.getConnection().getMetaData();\n      ResultSet results = metaData.getProcedureColumns(null, null,\n          procedureName, null);\n      if (null == results) {\n        return null;\n      }\n      try {\n        while (results.next()) {\n          if (results.getInt(\"COLUMN_TYPE\")\n              != DatabaseMetaData.procedureColumnReturn) {\n            int index = results.getInt(\"ORDINAL_POSITION\") - 1;\n            if (index < 0) {\n              continue; // actually the return type\n            }\n            for(int i = ret.size(); i < index; ++i) {\n              ret.add(null);\n            }\n            String name = results.getString(\"COLUMN_NAME\");\n            if (index == ret.size()) {\n              ret.add(name);\n            } else {\n              ret.set(index, name);\n            }\n          }\n        }\n        LOG.debug(\"getColumnsNamesForProcedure returns \"\n          + StringUtils.join(ret, \",\"));\n        return ret.toArray(new String[ret.size()]);\n      } finally {\n        results.close();\n        getConnection().commit();\n      }\n    } catch (SQLException e) {\n      LoggingUtils.logAll(LOG, \"Error reading procedure metadata: \", e);\n      throw new RuntimeException(\"Can't fetch column names for procedure.\", e);\n    }\n  }\n  /**\n   * @return the SQL query to use in getColumnTypes() in case this logic must\n   * be tuned per-database, but the main extraction loop is still inheritable.\n   */\n  protected String getColTypesQuery(String tableName) {\n    return getColNamesQuery(tableName);\n  }\n  @Override\n  public Map<String, Integer> getColumnTypes(String tableName) {\n    String stmt = getColTypesQuery(tableName);\n    return getColumnTypesForRawQuery(stmt);\n  }\n  @Override\n  public Map<String, Integer> getColumnTypesForQuery(String query) {\n    // Manipulate the query to return immediately, with zero rows.\n    String rawQuery = query.replace(SUBSTITUTE_TOKEN, \" (1 = 0) \");\n    return getColumnTypesForRawQuery(rawQuery);\n  }\n  /**\n   * Get column types for a query statement that we do not modify further.\n   */\n  protected Map<String, Integer> getColumnTypesForRawQuery(String stmt) {\n    Map<String, List<Integer>> colInfo = getColumnInfoForRawQuery(stmt);\n    if (colInfo == null) {\n      return null;\n    }\n    Map<String, Integer> colTypes = new SqlTypeMap<String, Integer>();\n    for (String s : colInfo.keySet()) {\n      List<Integer> info = colInfo.get(s);\n      colTypes.put(s, info.get(0));\n    }\n    return colTypes;\n  }\n  @Override\n  public Map<String, List<Integer>> getColumnInfo(String tableName) {\n    String stmt = getColNamesQuery(tableName);\n    return getColumnInfoForRawQuery(stmt);\n  }\n<fim_suffix>  @Override\n  public Map<String, List<Integer>> getColumnInfoForQuery(String query) {\n    // Manipulate the query to return immediately, with zero rows.\n    String rawQuery = query.replace(SUBSTITUTE_TOKEN, \" (1 = 0) \");\n    return getColumnInfoForRawQuery(rawQuery);\n  }<fim_middle>// function below has no smell\n"}