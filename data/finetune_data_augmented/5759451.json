{"text": "<fim_prefix>    registerTableSpace(DEFAULT_TABLESPACE_NAME, warehouseDir.toUri(), null, true, false);\n  }\n  private void addLocalFsTablespace() {\n    if (TABLE_SPACES.headMap(LOCAL_FS_URI, true).firstEntry() == null && TABLE_SPACE_HANDLERS.containsKey(\"file\")) {\n      String tmpName = UUID.randomUUID().toString();\n      registerTableSpace(tmpName, LOCAL_FS_URI, null, false, false);\n    }\n  }\n  public static TablespaceManager getInstance() {\n    return instance;\n  }\n  private void initForDefaultConfig() {\n    JSONObject json = loadFromConfig(DEFAULT_CONFIG_FILE);\n    if (json == null) {\n      throw new IllegalStateException(\"There is no \" + SITE_CONFIG_FILE);\n    }\n    applyConfig(json, false);\n  }\n  private void initSiteConfig() {\n    JSONObject json = loadFromConfig(SITE_CONFIG_FILE);\n    // if there is no storage-site.json file, nothing happen.\n    if (json != null) {\n      applyConfig(json, true);\n    }\n  }\n  private JSONObject loadFromConfig(String fileName) {\n    String json;\n    try {\n      json = JavaResourceUtil.readTextFromResource(fileName);\n    } catch (FileNotFoundException fnfe) {\n      return null;      \n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n    return parseJson(json);\n  }\n  private static JSONObject parseJson(String json) {\n    try {\n      return (JSONObject) parser.parse(json);\n    } catch (ParseException e) {\n      throw new RuntimeException(e);\n    }\n  }\n  private void applyConfig(JSONObject json, boolean override) {\n    loadStorages(json);\n    loadTableSpaces(json, override);\n  }\n  private void loadStorages(JSONObject json) {\n    JSONObject spaces = (JSONObject) json.get(KEY_STORAGES);\n    if (spaces != null) {\n      Pair<String, Class<? extends Tablespace>> pair = null;\n      for (Map.Entry<String, Object> entry : spaces.entrySet()) {\n        try {\n          pair = extractStorage(entry);\n        } catch (ClassNotFoundException e) {\n          LOG.warn(e);\n          continue;\n        }\n        TABLE_SPACE_HANDLERS.put(pair.getFirst(), pair.getSecond());\n      }\n    }\n  }\n  private Pair<String, Class<? extends Tablespace>> extractStorage(Map.Entry<String, Object> entry)\n      throws ClassNotFoundException {\n    String storageType = entry.getKey();\n    JSONObject storageDesc = (JSONObject) entry.getValue();\n    String handlerClass = (String) storageDesc.get(KEY_STORAGE_HANDLER);\n    return new Pair<>(\n            storageType, (Class<? extends Tablespace>) Class.forName(handlerClass));\n  }\n  private void loadTableSpaces(JSONObject json, boolean override) {\n    JSONObject spaces = (JSONObject) json.get(KEY_SPACES);\n    if (spaces != null) {\n      for (Map.Entry<String, Object> entry : spaces.entrySet()) {\n        JSONObject spaceDetail = (JSONObject) entry.getValue();\n        AddTableSpace(\n            entry.getKey(),\n            URI.create(spaceDetail.getAsString(\"uri\")),\n            Boolean.parseBoolean(spaceDetail.getAsString(\"default\")),\n            (JSONObject) spaceDetail.get(TABLESPACE_SPEC_CONFIGS_KEY),\n            override);\n      }\n    }\n  }\n  public static void AddTableSpace(String spaceName, URI uri, boolean isDefault, JSONObject configs, boolean override) {\n    if (isDefault) {\n      registerTableSpace(DEFAULT_TABLESPACE_NAME, uri, configs, true, override);\n    }\n    registerTableSpace(spaceName, uri, configs, true, override);\n  }\n  private static Tablespace registerTableSpace(String spaceName, URI uri, JSONObject spaceDesc,\n                                         boolean visible, boolean override) {\n    Tablespace tableSpace = initializeTableSpace(spaceName, uri, spaceDesc);\n    tableSpace.setVisible(visible);\n    try {\n      tableSpace.init(systemConf);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n    putTablespace(tableSpace, override);\n    // If the arbitrary path is allowed, root uri is also added as a tablespace\n    if (tableSpace.getProperty().isArbitraryPathAllowed()) {\n      URI rootUri = tableSpace.getRootUri();\n      // if there already exists or the rootUri is 'file:/', it won't overwrite the tablespace.\n      if (!TABLE_SPACES.containsKey(rootUri) && !rootUri.toString().startsWith(LOCAL_FS_URI.toString())) {\n        String tmpName = UUID.randomUUID().toString();\n        registerTableSpace(tmpName, rootUri, spaceDesc, false, override);\n      }\n    }\n    return tableSpace;\n  }\n  private static void putTablespace(Tablespace space, boolean override) {\n    // It is a device to keep the relationship among name, URI, and tablespace 1:1:1.\n    boolean nameExist = SPACES_URIS_MAP.containsKey(space.getName());\n    boolean uriExist = TABLE_SPACES.containsKey(space.uri);\n    boolean mismatch = nameExist && !SPACES_URIS_MAP.get(space.getName()).equals(space.getUri());\n    mismatch = mismatch || uriExist && TABLE_SPACES.get(space.uri).equals(space);\n    if (!override && mismatch) {\n      throw new RuntimeException(\"Name or URI of Tablespace must be unique.\");\n    }\n    SPACES_URIS_MAP.put(space.getName(), space.getUri());\n    // We must guarantee that the same uri results in the same tablespace instance.\n    TABLE_SPACES.put(space.getUri(), space);\n  }\n  /**\n   * Return length of the fragment.\n   * In the UNKNOWN_LENGTH case get FRAGMENT_ALTERNATIVE_UNKNOWN_LENGTH from the configuration.\n   *\n   * @param conf Tajo system property\n   * @param fragment Fragment\n   * @return\n   */\n  public static long guessFragmentVolume(TajoConf conf, Fragment fragment) {\n    if (fragment.getLength() == TajoConstants.UNKNOWN_LENGTH) {\n      return conf.getLongVar(TajoConf.ConfVars.FRAGMENT_ALTERNATIVE_UNKNOWN_LENGTH);\n    } else {\n      return fragment.getLength();\n    }\n  }\n  public static final String KEY_STORAGES = \"storages\"; // storages\n  public static final String KEY_STORAGE_HANDLER = \"handler\"; // storages/?/handler\n  public static final String KEY_STORAGE_DEFAULT_FORMAT = \"default-format\"; // storages/?/default-format\n  public static final String KEY_SPACES = \"spaces\";\n  private static Tablespace initializeTableSpace(String spaceName, URI uri, JSONObject spaceDesc) {\n    final String scheme = UriUtil.getScheme(uri);\n    Class<? extends Tablespace> clazz = TABLE_SPACE_HANDLERS.get(scheme);\n    if (clazz == null) {\n      throw new TajoRuntimeException(new UndefinedTablespaceHandlerException(scheme));\n    }\n    try {\n      Constructor<? extends Tablespace> constructor =\n          (Constructor<? extends Tablespace>) CONSTRUCTORS.get(clazz);\n      if (constructor == null) {\n        constructor = clazz.getDeclaredConstructor(TABLESPACE_PARAM);\n        constructor.setAccessible(true);\n        CONSTRUCTORS.put(clazz, constructor);\n      }\n      return constructor.newInstance(new Object[]{spaceName, uri, spaceDesc});\n    } catch (Exception e) {\n      throw new RuntimeException(e);\n    }\n  }\n  @VisibleForTesting\n  public static Optional<Tablespace> addTableSpaceForTest(Tablespace space) {\n    Tablespace existing;\n    synchronized (SPACES_URIS_MAP) {\n      String scheme = UriUtil.getScheme(space.getUri());\n      if (!TABLE_SPACE_HANDLERS.containsKey(scheme)) {\n        TABLE_SPACE_HANDLERS.put(scheme, space.getClass());\n      }\n      // Remove existing one\n      SPACES_URIS_MAP.remove(space.getName());\n      existing = TABLE_SPACES.remove(space.getUri());\n      // Add anotherone for test\n      Tablespace tablespace = registerTableSpace(space.name, space.uri, space.getConfig(), true, true);\n      try {\n        //override conf for test\n        if (space.conf != null)\n          tablespace.init(space.conf);\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n    // if there is an existing one, return it.\n    return Optional.ofNullable(existing);\n  }\n<fim_suffix>  @VisibleForTesting\n  public static Optional<Tablespace> removeTablespaceForTest(String name) {\n    Tablespace existing = null;\n    synchronized (SPACES_URIS_MAP) {\n      URI uri = SPACES_URIS_MAP.remove(name);\n      if (uri != null) {\n        existing = TABLE_SPACES.remove(uri);\n      }\n    }\n    return Optional.ofNullable(existing);\n  }<fim_middle>// function below has no smell\n"}