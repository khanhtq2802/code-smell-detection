{"text": "<fim_prefix>\n<fim_suffix>class WindmillStateReader {\n  /**\n   * Ideal maximum bytes in a TagBag response. However, Windmill will always return at least one\n   * value if possible irrespective of this limit.\n   */\n  public static final long MAX_BAG_BYTES = 8L << 20; // 8MB\n  /**\n   * Ideal maximum bytes in a KeyedGetDataResponse. However, Windmill will always return at least\n   * one value if possible irrespective of this limit.\n   */\n  public static final long MAX_KEY_BYTES = 16L << 20; // 16MB\n  /**\n   * When combined with a key and computationId, represents the unique address for state managed by\n   * Windmill.\n   */\n  private static class StateTag {\n    private enum Kind {\n      VALUE,\n      BAG,\n      WATERMARK;\n    }\n    private final Kind kind;\n    private final ByteString tag;\n    private final String stateFamily;\n    /**\n     * For {@link Kind#BAG} kinds: A previous 'continuation_position' returned by Windmill to signal\n     * the resulting bag was incomplete. Sending that position will request the next page of values.\n     * Null for first request.\n     *\n     * <p>Null for other kinds.\n     */\n    @Nullable private final Long requestPosition;\n    private StateTag(\n        Kind kind, ByteString tag, String stateFamily, @Nullable Long requestPosition) {\n      this.kind = kind;\n      this.tag = tag;\n      this.stateFamily = Preconditions.checkNotNull(stateFamily);\n      this.requestPosition = requestPosition;\n    }\n    private StateTag(Kind kind, ByteString tag, String stateFamily) {\n      this(kind, tag, stateFamily, null);\n    }\n    @Override\n    public boolean equals(Object obj) {\n      if (this == obj) {\n        return true;\n      }\n      if (!(obj instanceof StateTag)) {\n        return false;\n      }\n      StateTag that = (StateTag) obj;\n      return Objects.equal(this.kind, that.kind)\n          && Objects.equal(this.tag, that.tag)\n          && Objects.equal(this.stateFamily, that.stateFamily)\n          && Objects.equal(this.requestPosition, that.requestPosition);\n    }\n    @Override\n    public int hashCode() {\n      return Objects.hashCode(kind, tag, stateFamily, requestPosition);\n    }\n    @Override\n    public String toString() {\n      return \"Tag(\"\n          + kind\n          + \",\"\n          + tag.toStringUtf8()\n          + \",\"\n          + stateFamily\n          + (requestPosition == null ? \"\" : (\",\" + requestPosition.toString()))\n          + \")\";\n    }\n  }\n  /**\n   * An in-memory collection of deserialized values and an optional continuation position to pass to\n   * Windmill when fetching the next page of values.\n   */\n  private static class ValuesAndContPosition<T> {\n    private final List<T> values;\n    /** Position to pass to next request for next page of values. Null if done. */\n    @Nullable private final Long continuationPosition;\n    public ValuesAndContPosition(List<T> values, @Nullable Long continuationPosition) {\n      this.values = values;\n      this.continuationPosition = continuationPosition;\n    }\n  }\n  private final String computation;\n  private final ByteString key;\n  private final long shardingKey;\n  private final long workToken;\n  private final MetricTrackingWindmillServerStub server;\n  private long bytesRead = 0L;\n  public WindmillStateReader(\n      MetricTrackingWindmillServerStub server,\n      String computation,\n      ByteString key,\n      long shardingKey,\n      long workToken) {\n    this.server = server;\n    this.computation = computation;\n    this.key = key;\n    this.shardingKey = shardingKey;\n    this.workToken = workToken;\n  }\n  private static final class CoderAndFuture<ElemT, FutureT> {\n    private Coder<ElemT> coder;\n    private final SettableFuture<FutureT> future;\n    private CoderAndFuture(Coder<ElemT> coder, SettableFuture<FutureT> future) {\n      this.coder = coder;\n      this.future = future;\n    }\n    private SettableFuture<FutureT> getFuture() {\n      return future;\n    }\n    private SettableFuture<FutureT> getNonDoneFuture(StateTag stateTag) {\n      if (future.isDone()) {\n        throw new IllegalStateException(\"Future for \" + stateTag + \" is already done\");\n      }\n      return future;\n    }\n    private Coder<ElemT> getAndClearCoder() {\n      if (coder == null) {\n        throw new IllegalStateException(\"Coder has already been cleared from cache\");\n      }\n      Coder<ElemT> result = coder;\n      coder = null;\n      return result;\n    }\n    private void checkNoCoder() {\n      if (coder != null) {\n        throw new IllegalStateException(\"Unexpected coder\");\n      }\n    }\n  }\n  @VisibleForTesting ConcurrentLinkedQueue<StateTag> pendingLookups = new ConcurrentLinkedQueue<>();\n  private ConcurrentHashMap<StateTag, CoderAndFuture<?, ?>> waiting = new ConcurrentHashMap<>();\n  private <ElemT, FutureT> Future<FutureT> stateFuture(\n      StateTag stateTag, @Nullable Coder<ElemT> coder) {\n    CoderAndFuture<ElemT, FutureT> coderAndFuture =\n        new CoderAndFuture<>(coder, SettableFuture.<FutureT>create());\n    CoderAndFuture<?, ?> existingCoderAndFutureWildcard =\n        waiting.putIfAbsent(stateTag, coderAndFuture);\n    if (existingCoderAndFutureWildcard == null) {\n      // Schedule a new request. It's response is guaranteed to find the future and coder.\n      pendingLookups.add(stateTag);\n    } else {\n      // Piggy-back on the pending or already answered request.\n      @SuppressWarnings(\"unchecked\")\n      CoderAndFuture<ElemT, FutureT> existingCoderAndFuture =\n          (CoderAndFuture<ElemT, FutureT>) existingCoderAndFutureWildcard;\n      coderAndFuture = existingCoderAndFuture;\n    }\n    return wrappedFuture(coderAndFuture.getFuture());\n  }\n  private <ElemT, FutureT> CoderAndFuture<ElemT, FutureT> getWaiting(\n      StateTag stateTag, boolean shouldRemove) {\n    CoderAndFuture<?, ?> coderAndFutureWildcard;\n    if (shouldRemove) {\n      coderAndFutureWildcard = waiting.remove(stateTag);\n    } else {\n      coderAndFutureWildcard = waiting.get(stateTag);\n    }\n    if (coderAndFutureWildcard == null) {\n      throw new IllegalStateException(\"Missing future for \" + stateTag);\n    }\n    @SuppressWarnings(\"unchecked\")\n    CoderAndFuture<ElemT, FutureT> coderAndFuture =\n        (CoderAndFuture<ElemT, FutureT>) coderAndFutureWildcard;\n    return coderAndFuture;\n  }\n  public Future<Instant> watermarkFuture(ByteString encodedTag, String stateFamily) {\n    return stateFuture(new StateTag(StateTag.Kind.WATERMARK, encodedTag, stateFamily), null);\n  }\n  public <T> Future<T> valueFuture(ByteString encodedTag, String stateFamily, Coder<T> coder) {\n    return stateFuture(new StateTag(StateTag.Kind.VALUE, encodedTag, stateFamily), coder);\n  }\n  public <T> Future<Iterable<T>> bagFuture(\n      ByteString encodedTag, String stateFamily, Coder<T> elemCoder) {\n    // First request has no continuation position.\n    StateTag stateTag = new StateTag(StateTag.Kind.BAG, encodedTag, stateFamily);\n    // Convert the ValuesAndContPosition<T> to Iterable<T>.\n    return valuesToPagingIterableFuture(\n        stateTag, elemCoder, this.<T, ValuesAndContPosition<T>>stateFuture(stateTag, elemCoder));\n  }\n  /**\n   * Internal request to fetch the next 'page' of values in a TagBag. Return null if no continuation\n   * position is in {@code contStateTag}, which signals there are no more pages.\n   */\n  @Nullable\n  private <T> Future<ValuesAndContPosition<T>> continuationBagFuture(\n      StateTag contStateTag, Coder<T> elemCoder) {\n    if (contStateTag.requestPosition == null) {\n      // We're done.\n      return null;\n    }\n    return stateFuture(contStateTag, elemCoder);\n  }\n  /**\n   * A future which will trigger a GetData request to Windmill for all outstanding futures on the\n   * first {@link #get}.\n   */\n  private static class WrappedFuture<T> extends ForwardingFuture.SimpleForwardingFuture<T> {\n    /**\n     * The reader we'll use to service the eventual read. Null if read has been fulfilled.\n     *\n     * <p>NOTE: We must clear this after the read is fulfilled to prevent space leaks.\n     */\n    @Nullable private WindmillStateReader reader;<fim_middle>// class below is blob\n"}