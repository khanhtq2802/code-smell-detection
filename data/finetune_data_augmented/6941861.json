{"text": "<fim_prefix>/*\n * Copyright (C) 2008 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.inject.spi;\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.inject.internal.InternalFlags.getIncludeStackTraceOption;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Sets;\nimport com.google.inject.AbstractModule;\nimport com.google.inject.Binder;\nimport com.google.inject.Binding;\nimport com.google.inject.Key;\nimport com.google.inject.MembersInjector;\nimport com.google.inject.Module;\nimport com.google.inject.PrivateBinder;\nimport com.google.inject.PrivateModule;\nimport com.google.inject.Provider;\nimport com.google.inject.Scope;\nimport com.google.inject.Stage;\nimport com.google.inject.TypeLiteral;\nimport com.google.inject.binder.AnnotatedBindingBuilder;\nimport com.google.inject.binder.AnnotatedConstantBindingBuilder;\nimport com.google.inject.binder.AnnotatedElementBuilder;\nimport com.google.inject.internal.AbstractBindingBuilder;\nimport com.google.inject.internal.BindingBuilder;\nimport com.google.inject.internal.ConstantBindingBuilderImpl;\nimport com.google.inject.internal.Errors;\nimport com.google.inject.internal.ExposureBuilder;\nimport com.google.inject.internal.InternalFlags.IncludeStackTraceOption;\nimport com.google.inject.internal.MoreTypes;\nimport com.google.inject.internal.PrivateElementsImpl;\nimport com.google.inject.internal.ProviderMethodsModule;\nimport com.google.inject.internal.util.SourceProvider;\nimport com.google.inject.internal.util.StackTraceElements;\nimport com.google.inject.matcher.Matcher;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n/**\n * Exposes elements of a module so they can be inspected, validated or {@link\n * Element#applyTo(Binder) rewritten}.\n *\n * @author jessewilson@google.com (Jesse Wilson)\n * @since 2.0\n */\npublic final class Elements {\n  private static final BindingTargetVisitor<Object, Object> GET_INSTANCE_VISITOR =\n      new DefaultBindingTargetVisitor<Object, Object>() {\n        @Override\n        public Object visit(InstanceBinding<?> binding) {\n          return binding.getInstance();\n        }\n        @Override\n        protected Object visitOther(Binding<?> binding) {\n          throw new IllegalArgumentException();\n        }\n      };\n  /** Records the elements executed by {@code modules}. */\n  public static List<Element> getElements(Module... modules) {\n    return getElements(Stage.DEVELOPMENT, Arrays.asList(modules));\n  }\n  /** Records the elements executed by {@code modules}. */\n  public static List<Element> getElements(Stage stage, Module... modules) {\n    return getElements(stage, Arrays.asList(modules));\n  }\n  /** Records the elements executed by {@code modules}. */\n  public static List<Element> getElements(Iterable<? extends Module> modules) {\n    return getElements(Stage.DEVELOPMENT, modules);\n  }\n  /** Records the elements executed by {@code modules}. */\n  public static List<Element> getElements(Stage stage, Iterable<? extends Module> modules) {\n    RecordingBinder binder = new RecordingBinder(stage);\n    for (Module module : modules) {\n      binder.install(module);\n    }\n    binder.scanForAnnotatedMethods();\n    for (RecordingBinder child : binder.privateBinders) {\n      child.scanForAnnotatedMethods();\n    }\n    // Free the memory consumed by the stack trace elements cache\n    StackTraceElements.clearCache();\n    return Collections.unmodifiableList(binder.elements);\n  }\n  private static class ElementsAsModule implements Module {\n    private final Iterable<? extends Element> elements;\n    ElementsAsModule(Iterable<? extends Element> elements) {\n      this.elements = elements;\n    }\n    @Override\n    public void configure(Binder binder) {\n      for (Element element : elements) {\n        element.applyTo(binder);\n      }\n    }\n  }\n  /** Returns the module composed of {@code elements}. */\n  public static Module getModule(final Iterable<? extends Element> elements) {\n    return new ElementsAsModule(elements);\n  }\n  @SuppressWarnings(\"unchecked\")\n  static <T> BindingTargetVisitor<T, T> getInstanceVisitor() {\n    return (BindingTargetVisitor<T, T>) GET_INSTANCE_VISITOR;\n  }\n  private static class ModuleInfo {\n    private final Binder binder;\n    private final ModuleSource moduleSource;\n    private final boolean skipScanning;\n    private ModuleInfo(Binder binder, ModuleSource moduleSource, boolean skipScanning) {\n      this.binder = binder;\n      this.moduleSource = moduleSource;\n      this.skipScanning = skipScanning;\n    }\n  }\n  private static class RecordingBinder implements Binder, PrivateBinder {\n    private final Stage stage;\n    private final Map<Module, ModuleInfo> modules;\n    private final List<Element> elements;\n    private final Object source;\n    /** The current modules stack */\n    private ModuleSource moduleSource = null;\n    private final SourceProvider sourceProvider;\n    private final Set<ModuleAnnotatedMethodScanner> scanners;\n    /** The binder where exposed bindings will be created */\n    private final RecordingBinder parent;\n    private final PrivateElementsImpl privateElements;\n    /** All children private binders, so we can scan through them. */\n    private final List<RecordingBinder> privateBinders;\n    private RecordingBinder(Stage stage) {\n      this.stage = stage;\n      this.modules = Maps.newLinkedHashMap();\n      this.scanners = Sets.newLinkedHashSet();\n      this.elements = Lists.newArrayList();\n      this.source = null;\n      this.sourceProvider =\n          SourceProvider.DEFAULT_INSTANCE.plusSkippedClasses(\n              Elements.class,\n              RecordingBinder.class,\n              AbstractModule.class,\n              ConstantBindingBuilderImpl.class,\n              AbstractBindingBuilder.class,\n              BindingBuilder.class);\n      this.parent = null;\n      this.privateElements = null;\n      this.privateBinders = Lists.newArrayList();\n    }\n    /** Creates a recording binder that's backed by {@code prototype}. */\n    private RecordingBinder(\n        RecordingBinder prototype, Object source, SourceProvider sourceProvider) {\n      checkArgument(source == null ^ sourceProvider == null);\n      this.stage = prototype.stage;\n      this.modules = prototype.modules;\n      this.elements = prototype.elements;\n      this.scanners = prototype.scanners;\n      this.source = source;\n      this.moduleSource = prototype.moduleSource;\n      this.sourceProvider = sourceProvider;\n      this.parent = prototype.parent;\n      this.privateElements = prototype.privateElements;\n      this.privateBinders = prototype.privateBinders;\n    }\n    /** Creates a private recording binder. */\n    private RecordingBinder(RecordingBinder parent, PrivateElementsImpl privateElements) {\n      this.stage = parent.stage;\n      this.modules = Maps.newLinkedHashMap();\n      this.scanners = Sets.newLinkedHashSet(parent.scanners);\n      this.elements = privateElements.getElementsMutable();\n      this.source = parent.source;\n      this.moduleSource = parent.moduleSource;\n      this.sourceProvider = parent.sourceProvider;\n      this.parent = parent;\n      this.privateElements = privateElements;\n      this.privateBinders = parent.privateBinders;\n    }\n    /*if[AOP]*/\n<fim_suffix>    @Override\n    public void bindInterceptor(\n        Matcher<? super Class<?>> classMatcher,\n        Matcher<? super Method> methodMatcher,\n        org.aopalliance.intercept.MethodInterceptor... interceptors) {\n      elements.add(\n          new InterceptorBinding(getElementSource(), classMatcher, methodMatcher, interceptors));\n    }\n    /*end[AOP]*/\n    @Override\n    public void bindScope(Class<? extends Annotation> annotationType, Scope scope) {\n      elements.add(new ScopeBinding(getElementSource(), annotationType, scope));\n    }\n    @Override\n    @SuppressWarnings(\"unchecked\") // it is safe to use the type literal for the raw type<fim_middle>// function below has no smell\n"}