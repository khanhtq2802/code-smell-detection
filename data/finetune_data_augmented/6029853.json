{"text": "<fim_prefix>/*******************************************************************************\n * Copyright (c) 2015 Institute for Pervasive Computing, ETH Zurich and others.\n * \n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * and Eclipse Distribution License v1.0 which accompany this distribution.\n * \n * The Eclipse Public License is available at\n *    http://www.eclipse.org/legal/epl-v10.html\n * and the Eclipse Distribution License is available at\n *    http://www.eclipse.org/org/documents/edl-v10.html.\n * \n * Contributors:\n *    Matthias Kovatsch - creator and main architect\n *    Stefan Jucker - DTLS implementation\n *    Kai Hudalla (Bosch Software Innovations GmbH) - add access to client identity\n *    Kai Hudalla (Bosch Software Innovations GmbH) - fix bug 469593 (validation of peer certificate chain)\n *    Kai Hudalla (Bosch Software Innovations GmbH) - add accessor for peer address\n *    Kai Hudalla (Bosch Software Innovations GmbH) - improve handling of empty messages\n *    Kai Hudalla (Bosch Software Innovations GmbH) - fix 477074 (erroneous encoding of RPK)\n *    Ludwig Seitz (RISE SICS) - Moved certificate validation to Handhaker\n ******************************************************************************/\npackage org.eclipse.californium.scandium.dtls;\nimport java.io.ByteArrayInputStream;\nimport java.net.InetSocketAddress;\nimport java.security.GeneralSecurityException;\nimport java.security.KeyFactory;\nimport java.security.PublicKey;\nimport java.security.cert.CertPath;\nimport java.security.cert.Certificate;\nimport java.security.cert.CertificateEncodingException;\nimport java.security.cert.CertificateException;\nimport java.security.cert.CertificateFactory;\nimport java.security.cert.X509Certificate;\nimport java.security.spec.EncodedKeySpec;\nimport java.security.spec.X509EncodedKeySpec;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.security.auth.x500.X500Principal;\nimport org.eclipse.californium.elements.util.DatagramReader;\nimport org.eclipse.californium.elements.util.DatagramWriter;\nimport org.eclipse.californium.scandium.dtls.AlertMessage.AlertDescription;\nimport org.eclipse.californium.scandium.dtls.AlertMessage.AlertLevel;\n/**\n * The server MUST send a Certificate message whenever the agreed-upon key\n * exchange method uses certificates for authentication. This message will\n * always immediately follow the {@link ServerHello} message. For details see <a\n * href=\"http://tools.ietf.org/html/rfc5246#section-7.4.2\">RFC 5246</a>.\n */\npublic final class CertificateMessage extends HandshakeMessage {\n\t// Logging ///////////////////////////////////////////////////////////\n\tprivate static final String CERTIFICATE_TYPE_X509 = \"X.509\";\n\tprivate static final Logger LOGGER = Logger.getLogger(CertificateMessage.class.getCanonicalName());\n\t// DTLS-specific constants ///////////////////////////////////////////\n\t/**\n\t * <a href=\"http://tools.ietf.org/html/rfc5246#section-7.4.2\">RFC 5246</a>:\n\t * <code>opaque ASN.1Cert<1..2^24-1>;</code>\n\t */\n\tprivate static final int CERTIFICATE_LENGTH_BITS = 24;\n\t/**\n\t * <a href=\"http://tools.ietf.org/html/rfc5246#section-7.4.2\">RFC 5246</a>:\n\t * <code>ASN.1Cert certificate_list<0..2^24-1>;</code>\n\t */\n\tprivate static final int CERTIFICATE_LIST_LENGTH = 24;\n\t// Members ///////////////////////////////////////////////////////////\n\t/**\n\t * A chain of certificates asserting the sender's identity.\n\t * The sender's identity is reflected by the certificate at index 0.\n\t */\n\tprivate CertPath certPath;\n\t/** The encoded chain of certificates */\n\tprivate List<byte[]> encodedChain;\n\t/**\n\t * The SubjectPublicKeyInfo part of the X.509 certificate. Used in\n\t * constrained environments for smaller message size.\n\t */\n\tprivate byte[] rawPublicKeyBytes;\n\t// length is at least 3 bytes containing the message's overall number of bytes\n\tprivate int length = 3;\n\t// Constructor ////////////////////////////////////////////////////\n\t/**\n\t * Creates a <em>CERTIFICATE</em> message containing a certificate chain.\n\t * \n\t * @param certificateChain\n\t *            the certificate chain with the (first certificate must be the\n\t *            server's)\n\t * @param peerAddress the IP address and port of the peer this\n\t *            message has been received from or should be sent to\n\t * @throws NullPointerException if the certificate chain is <code>null</code>\n\t *            (use an array of length zero to create an <em>empty</em> message)\n\t * @throws IllegalArgumentException if the certificate chain contains any\n\t *            non-X.509 certificates or does not form a valid chain of\n\t *            certification.\n\t * \n\t */\n<fim_suffix>\tpublic CertificateMessage(X509Certificate[] certificateChain, InetSocketAddress peerAddress) {\n\t\tsuper(peerAddress);\n\t\tif (certificateChain == null) {\n\t\t\tthrow new NullPointerException(\"Certificate chain must not be null\");\n\t\t} else {\n\t\t\tsetCertificateChain(certificateChain);\n\t\t\tcalculateLength();\n\t\t}\n\t}\n\tprivate CertificateMessage(final CertPath peerCertChain, final InetSocketAddress peerAddress) {\n\t\tsuper(peerAddress);\n\t\tthis.certPath = peerCertChain;\n\t\tcalculateLength();\n\t}\n\t/**\n\t * Creates a <em>CERTIFICATE</em> message containing a raw public key.\n\t * \n\t * @param rawPublicKeyBytes\n\t *           the raw public key (SubjectPublicKeyInfo)\n\t * @param peerAddress the IP address and port of the peer this\n\t *           message has been received from or should be sent to\n\t * @throws NullPointerException if the raw public key byte array is <code>null</code>\n\t *           (use an array of length zero to create an <em>empty</em> message)\n\t */\n\tpublic CertificateMessage(byte[] rawPublicKeyBytes, InetSocketAddress peerAddress) {\n\t\tsuper(peerAddress);\n\t\tif (rawPublicKeyBytes == null) {\n\t\t\tthrow new NullPointerException(\"Raw public key byte array must not be null\");\n\t\t} else {\n\t\t\tthis.rawPublicKeyBytes = Arrays.copyOf(rawPublicKeyBytes, rawPublicKeyBytes.length);\n\t\t\tlength += this.rawPublicKeyBytes.length;\n\t\t}\n\t}\n\t/**\n\t * Sets the chain of certificates to be sent to a peer as\n\t * part of this message for authentication purposes.\n\t * <p>\n\t * Only the non-root certificates from the given chain are sent to the\n\t * peer because the peer is assumed to have been provisioned with a\n\t * set of trusted root certificates already.\n\t * <p>\n\t * See <a href=\"http://tools.ietf.org/html/rfc5246#section-7.4.2\">\n\t * TLS 1.2, Section 7.4.2</a> for details.\n\t *  \n\t * @param chain the certificate chain\n\t * @throws IllegalArgumentException if the given array contains non X.509 certificates or\n\t *                                  the certificates do not form a chain.\n\t */\n\tprivate void setCertificateChain(final X509Certificate[] chain) {\n\t\tList<X509Certificate> certificates = new ArrayList<>();\n\t\tX500Principal issuer = null;\n\t\ttry {\n\t\t\tCertificateFactory factory = CertificateFactory.getInstance(CERTIFICATE_TYPE_X509);\n\t\t\tfor (X509Certificate cert : chain) {\n\t\t\t\tLOGGER.log(Level.FINER, \"Current Subject DN: {0}\", cert.getSubjectX500Principal().getName());\n\t\t\t\tif (issuer != null && !issuer.equals(cert.getSubjectX500Principal())) {\n\t\t\t\t\tLOGGER.log(Level.FINER, \"Actual Issuer DN: {0}\",\n\t\t\t\t\t\t\tcert.getSubjectX500Principal().getName());\n\t\t\t\t\tthrow new IllegalArgumentException(\"Given certificates do not form a chain\");\n\t\t\t\t}\n\t\t\t\tif (!cert.getIssuerX500Principal().equals(cert.getSubjectX500Principal())) {\n\t\t\t\t\t// not a self-signed certificate<fim_middle>// function below has no smell\n"}