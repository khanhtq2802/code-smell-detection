{"text": "<fim_prefix>     * Note that each time this property is accessed, the list is copied and\n     * returned.\n     *\n     * @return Array of AccessMappings.\n     */\n    public AccessMapping[] getAccessMappings() {\n        try {\n            ensureDiskCacheLoaded();\n            accessLock.readLock().lock();\n            return accessMappingMapToArray(mapAccessMappings);\n        } finally {\n            accessLock.readLock().unlock();\n        }\n    }\n    /**\n     * Removes the access mapping with the provided access mapping moniker and\n     * all of the location mapping entries that have this access zone.\n     *\n     * @param moniker\n     *        The moniker of the access mapping to remove.\n     */\n    public void removeAccessMapping(final String moniker) {\n        try {\n            ensureDiskCacheLoaded();\n            accessLock.writeLock().lock();\n            if (mapAccessMappings.containsKey(moniker)) {\n                // Remove it from the access mappings\n                mapAccessMappings.remove(moniker);\n                // Remove each instance from the service definitions\n                for (final Map<GUID, ServiceDefinition> m : mapServices.values()) {\n                    for (final ServiceDefinition definition : m.values()) {\n                        // We know that it is illegal to delete an access\n                        // mapping that is the default access mapping of\n                        // a service definition so we don't have to update any\n                        // of those values.\n                        final LocationMapping[] locationMappings = definition.getLocationMappings();\n                        // Remove the mapping that has the removed access\n                        // mapping.\n                        for (int i = 0; i < locationMappings.length; i++) {\n                            final String accessMappingMoniker = locationMappings[i].getAccessMappingMoniker();\n                            if (moniker.equalsIgnoreCase(accessMappingMoniker)) {\n                                definition.internalRemoveLocationMappingAt(i);\n                            }\n                        }\n                    }\n                }\n            }\n            writeCacheToDisk();\n        } finally {\n            if (accessLock.isWriteLockedByCurrentThread()) {\n                accessLock.writeLock().unlock();\n            }\n        }\n    }\n    /**\n     * Removes services from both the in-memory cache and the disk cache.\n     *\n     * @param serviceDefinitions\n     *        The service definitions to remove.\n     *\n     * @param lastChangeId\n     *        The lastChangeId the server returned when it performed this\n     *        operation.\n     */\n    public void removeServices(final ServiceDefinition[] serviceDefinitions, final int lastChangeId) {\n        try {\n            ensureDiskCacheLoaded();\n            accessLock.writeLock().lock();\n            // Iterate the service definitions that should be removed.\n            for (int i = 0; i < serviceDefinitions.length; i++) {\n                // Move to the next definition if there are no service\n                // definitions of this type.\n                final ServiceDefinition serviceDefinition = serviceDefinitions[i];\n                if (!mapServices.containsKey(serviceDefinition.getServiceType())) {\n                    continue;\n                }\n                // Remove the service definition from the map of all services of\n                // this type.\n                final Map<GUID, ServiceDefinition> serviceDefinitionInstances =\n                    mapServices.get(serviceDefinition.getServiceType());\n                if (serviceDefinitionInstances.containsKey(serviceDefinition.getIdentifier())) {\n                    serviceDefinitionInstances.remove(serviceDefinition.getIdentifier());\n                }\n                // If the entry is removed and there are no more definitions of\n                // this type, remove that entry from the services structure\n                if (serviceDefinitionInstances.size() == 0) {\n                    mapServices.remove(serviceDefinition.getServiceType());\n                }\n            }\n            // Update the change id on the cache and persist it to disk.\n            setLastChangeID(lastChangeId, false);\n            writeCacheToDisk();\n        } finally {\n            if (accessLock.isWriteLockedByCurrentThread()) {\n                accessLock.writeLock().unlock();\n            }\n        }\n    }\n    /**\n     * Returns the access mapping for the provided moniker.\n     *\n     * @param moniker\n     *        The moniker of the access mapping to return.\n     *\n     * @return The access mapping for the provided moniker or null /// if an\n     *         access mapping for the moniker doesn't exist\n     */\n    public AccessMapping getAccessMapping(final String moniker) {\n        Check.notNullOrEmpty(moniker, \"moniker\"); //$NON-NLS-1$\n        try {\n            ensureDiskCacheLoaded();\n            accessLock.readLock().lock();\n            if (mapAccessMappings.containsKey(moniker)) {\n                return mapAccessMappings.get(moniker);\n            } else {\n                return null;\n            }\n        } finally {\n            accessLock.readLock().unlock();\n        }\n    }\n    /**\n     * Returns the service definition for the service with the provided service\n     * type and identifier. Null will be returned if there is no entry in the\n     * cache for this service.\n     *\n     * @param serviceType\n     *        The service type we are looking for.\n     *\n     * @param serviceIdentifier\n     *        The identifier for the specific service instance we are looking\n     *        for.\n     *\n     * @return The service definition for the service with the provided service\n     *         type and identifier. Null will be returned if there is no entry\n     *         in the cache for this service.\n     */\n    public ServiceDefinition findService(final String serviceType, final GUID serviceIdentifier) {\n        try {\n            ensureDiskCacheLoaded();\n            accessLock.readLock().lock();\n            ServiceDefinition serviceDefinition = null;\n            if (mapServices.containsKey(serviceType)) {\n                final Map<GUID, ServiceDefinition> services = mapServices.get(serviceType);\n                if (services.containsKey(serviceIdentifier)) {\n                    serviceDefinition = services.get(serviceIdentifier);\n                }\n            }\n            return (ServiceDefinition) (serviceDefinition == null ? null : serviceDefinition.clone());\n        } finally {\n            accessLock.readLock().unlock();\n        }\n    }\n    /**\n     * Finds all services with the provided service type.\n     *\n     * @param serviceType\n     *        The service type we are looking for.\n     *\n     * @return All of the service definitions with the serviceType that are in\n     *         the cache or null if none are in the cache\n     */\n    public ServiceDefinition[] findServices(final String serviceType) {\n        try {\n            ensureDiskCacheLoaded();\n            accessLock.readLock().lock();\n            Check.isTrue(lastChangeID == -1 || mapServices.size() > 0, \"lastChangeID == -1 || mapServices.size() > 0\"); //$NON-NLS-1$\n            // Bail immediately if there are no known services.\n            if (mapServices.size() == 0) {\n                return null;\n            }\n            // Build an array of ServiceDefinitions of the requested service\n            // type or all services if a service type was not specified.\n            final List<ServiceDefinition> list = new ArrayList<ServiceDefinition>();\n            if (serviceType == null || serviceType.length() == 0) {\n                // Return all services.\n                for (final Map<GUID, ServiceDefinition> mapServiceInstances : mapServices.values()) {\n                    addClonedServiceInstancesToList(mapServiceInstances, list);\n                }\n            } else {\n                // The caller has requested services of a specific type.\n                if (!mapServices.containsKey(serviceType)) {\n                    return null;\n                }\n                final Map<GUID, ServiceDefinition> mapServiceInstances = mapServices.get(serviceType);\n                addClonedServiceInstancesToList(mapServiceInstances, list);\n            }\n            return list.toArray(new ServiceDefinition[list.size()]);\n        } finally {\n            accessLock.readLock().unlock();\n        }\n    }\n    /**\n     * Finds the service definitions for all of the available services for the\n     * specified tool id. If no services exist for this tool id, null will be\n     * returned.\n     *\n     * @param toolId\n     *        The case-insensitive tool id whose services we are looking for. If\n     *        this is null or empty, all services will be returned.\n     *\n     * @return Service definitions for all of the existing services that are of\n     *         the supplied tool id. If no services of this type exist, null\n     *         will be returned\n     */\n<fim_suffix>    public ServiceDefinition[] findServicesByToolID(final String toolId) {\n        try {\n            ensureDiskCacheLoaded();\n            accessLock.readLock().lock();\n            final boolean returnAll = toolId == null || toolId.length() == 0;\n            final List<ServiceDefinition> requestedDefinitions = new ArrayList<ServiceDefinition>();\n            // Iterate the map of service types. Values are a map of service\n            // instances.\n            for (final Map<GUID, ServiceDefinition> mapServiceInstances : mapServices.values()) {\n                for (final ServiceDefinition definition : mapServiceInstances.values()) {\n                    /*\n                     * NB! some service definitions in Dev12 QU1 may have null\n                     * ToolID\n                     */\n                    if (returnAll || toolId.equalsIgnoreCase(definition.getToolID())) {\n                        requestedDefinitions.add((ServiceDefinition) definition.clone());\n                    }\n                }\n            }\n            // Return null if no matching definitions were found.\n            if (requestedDefinitions.size() == 0) {\n                return null;\n            }\n            // Return an array of the matching service definitions.\n            return requestedDefinitions.toArray(new ServiceDefinition[requestedDefinitions.size()]);\n        } finally {\n            accessLock.readLock().unlock();\n        }\n    }<fim_middle>// function below is long method\n"}