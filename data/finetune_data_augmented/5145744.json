{"text": "<fim_prefix>package org.apache.maven.scm.provider.bazaar.command;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.scm.ScmFileStatus;\nimport org.apache.maven.scm.log.ScmLogger;\nimport org.apache.maven.scm.util.AbstractConsumer;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Base consumer to do common parsing for all bazaar commands.\n * <p/>\n * More specific: log line each line if debug is enabled, get file status\n * and detect warnings from bazaar\n *\n * @author <a href=\"mailto:torbjorn@smorgrav.org\">Torbj\u00f6rn Eikli Sm\u00f6rgrav</a>\n *\n */\npublic class BazaarConsumer\n    extends AbstractConsumer\n{\n\n    /**\n     * A list of known keywords from bazaar\n     */\n    private static final Map<String, ScmFileStatus> IDENTIFIERS = new HashMap<String, ScmFileStatus>();\n\n    /**\n     * A list of known message prefixes from bazaar\n     */\n    private static final Map<String, String> MESSAGES = new HashMap<String, String>();\n\n    /**\n     * Number of lines to keep from Std.Err\n     * This size is set to ensure that we capture enough info\n     * but still keeps a low memory footprint.\n     */\n    private static final int MAX_STDERR_SIZE = 10;\n\n    /**\n     * A list of the MAX_STDERR_SIZE last errors or warnings.\n     */\n    private final List<String> stderr = new ArrayList<String>();\n\n    static\n    {\n        IDENTIFIERS.put( \"added\", ScmFileStatus.ADDED );\n        IDENTIFIERS.put( \"adding\", ScmFileStatus.ADDED );\n        IDENTIFIERS.put( \"unknown\", ScmFileStatus.UNKNOWN );\n        IDENTIFIERS.put( \"modified\", ScmFileStatus.MODIFIED );\n        IDENTIFIERS.put( \"removed\", ScmFileStatus.DELETED );\n        IDENTIFIERS.put( \"renamed\", ScmFileStatus.RENAMED );\n        MESSAGES.put( \"bzr: WARNING:\", \"WARNING\" );\n        MESSAGES.put( \"bzr: ERROR:\", \"ERROR\" );\n        MESSAGES.put( \"'bzr' \", \"ERROR\" ); // bzr isn't found in windows path\n    }\n\n    public BazaarConsumer( ScmLogger logger )\n    {\n        super( logger );\n    }\n\n    public void doConsume( ScmFileStatus status, String trimmedLine )\n    {\n        //override this\n    }\n\n    /** {@inheritDoc} */\n    public void consumeLine( String line )\n    {\n        if ( getLogger().isDebugEnabled() )\n        {\n            getLogger().debug( line );\n        }\n        String trimmedLine = line.trim();\n\n        String statusStr = processInputForKnownIdentifiers( trimmedLine );\n\n        //If its not a status report - then maybe its a message?\n        if ( statusStr == null )\n        {\n            boolean isMessage = processInputForKnownMessages( trimmedLine );\n            //If it is then its already processed and we can ignore futher processing\n            if ( isMessage )\n            {\n                return;\n            }\n        }\n        else\n        {\n            //Strip away identifier\n            trimmedLine = trimmedLine.substring( statusStr.length() );\n            trimmedLine = trimmedLine.trim(); //one or more spaces\n        }\n\n        ScmFileStatus status = statusStr != null ? ( (ScmFileStatus) IDENTIFIERS.get( statusStr.intern() ) ) : null;\n        doConsume( status, trimmedLine );\n    }\n\n    /**\n     * Warnings and errors is usually printed out in Std.Err, thus for derived consumers\n     * operating on Std.Out this would typically return an empty string.\n     *\n     * @return Return the last lines interpreted as an warning or an error\n     */\n<fim_suffix>    public String getStdErr()\n    {\n        StringBuilder str = new StringBuilder();\n        for ( String line : stderr )\n        {\n            str.append( line );\n        }\n        return str.toString();\n    }\n\n    private static String processInputForKnownIdentifiers( String line )\n    {\n        for ( String id : IDENTIFIERS.keySet() )\n        {\n            if ( line.startsWith( id ) )\n            {\n                return id;\n            }\n        }\n        return null;\n    }\n\n    private boolean processInputForKnownMessages( String line )\n    {\n        for ( String prefix : MESSAGES.keySet() )\n        {\n            if ( line.startsWith( prefix ) )\n            {\n                stderr.add( line ); //Add line\n                if ( stderr.size() > MAX_STDERR_SIZE )\n                {\n                    stderr.remove( 0 ); //Rotate list\n                }\n                String message = line.substring( prefix.length() );\n                if ( MESSAGES.get( prefix ).equals( \"WARNING\" ) )\n                {\n                    if ( getLogger().isWarnEnabled() )\n                    {\n                        getLogger().warn( message );\n                    }\n                }\n                else\n                {\n                    if ( getLogger().isErrorEnabled() )\n                    {\n                        getLogger().error( message );\n                    }\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n}<fim_middle>// function below has no smell\n"}