{"text": "<fim_prefix>/**\n * Copyright (c) 2016 NumberFour AG.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *   NumberFour AG - Initial API and implementation\n */\npackage org.eclipse.n4js.transpiler;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.eclipse.emf.ecore.EObject;\nimport org.eclipse.n4js.n4JS.ExpressionStatement;\nimport org.eclipse.n4js.n4JS.FunctionDeclaration;\nimport org.eclipse.n4js.n4JS.ImportDeclaration;\nimport org.eclipse.n4js.n4JS.N4ClassDeclaration;\nimport org.eclipse.n4js.n4JS.N4ClassifierDeclaration;\nimport org.eclipse.n4js.n4JS.N4EnumDeclaration;\nimport org.eclipse.n4js.n4JS.N4InterfaceDeclaration;\nimport org.eclipse.n4js.n4JS.N4MemberDeclaration;\nimport org.eclipse.n4js.n4JS.N4TypeDeclaration;\nimport org.eclipse.n4js.n4JS.ParameterizedCallExpression;\nimport org.eclipse.n4js.n4JS.TypeDefiningElement;\nimport org.eclipse.n4js.n4JS.VariableDeclaration;\nimport org.eclipse.n4js.transpiler.assistants.TypeAssistant;\nimport org.eclipse.n4js.transpiler.utils.ConcreteMembersOrderedForTranspiler;\nimport org.eclipse.n4js.transpiler.utils.TranspilerUtils;\nimport org.eclipse.n4js.ts.types.TClass;\nimport org.eclipse.n4js.ts.types.TClassifier;\nimport org.eclipse.n4js.ts.types.TEnum;\nimport org.eclipse.n4js.ts.types.TInterface;\nimport org.eclipse.n4js.ts.types.TMember;\nimport org.eclipse.n4js.ts.types.TModule;\nimport org.eclipse.n4js.ts.types.Type;\nimport com.google.common.collect.HashMultimap;\n/**\n * Data storage for meta-information that will be passed from one transformation to another and should not be stored in\n * the intermediate model. This means some transformations will add information to this registry and others will read\n * from it.\n */\npublic class InformationRegistry {\n\tprivate final HashMultimap<Tag, EObject> hmTagged = HashMultimap.create();\n\tprivate final Map<ImportDeclaration, TModule> importedModules = new HashMap<>();\n\tprivate final Map<N4TypeDeclaration, Type> originalDefinedTypes = new HashMap<>();\n\tprivate final Map<N4MemberDeclaration, TMember> originalDefinedMembers = new HashMap<>();\n\tprivate final Map<TClassifier, ConcreteMembersOrderedForTranspiler> cachedCMOFTs = new HashMap<>();\n\t/**\n\t */\n\tprivate enum Tag {\n\t\t/** Tag for elements which should be hoisted. */\n\t\ttoHoist,\n\t\t/** Tag for expression statements that were originally an initializer expression of a to-be-hoisted variable. */\n\t\tinitializerOfHoistedVariable,\n\t\t/** Tag for IM nodes that were, originally, an explicit super call. */\n\t\texplicitSuperCall,\n\t\t/** Tag for members which were consumed from an interface. */\n\t\tconsumedFromInterface,\n\t\t/** Tag for members which were filled in by way of static polyfills. */\n\t\tstaticlyPolyfilled,\n\t}\n\t/** Tells if the given variable requires hoisting, i.e. the module wrapping transformation should hoist it. */\n\tpublic boolean isToHoist(VariableDeclaration element) {\n\t\treturn isTaggedAs(Tag.toHoist, element);\n\t}\n\t/** Tells if the given function requires hoisting, i.e. the module wrapping transformation should hoist it. */\n\tpublic boolean isToHoist(FunctionDeclaration element) {\n\t\treturn isTaggedAs(Tag.toHoist, element);\n\t}\n\t/** Marks given variable as requiring hoisting, i.e. module wrapping transformation will hoist it. */\n\tpublic void markAsToHoist(VariableDeclaration element) {\n\t\ttag(Tag.toHoist, element);\n\t}\n\t/** Marks given function as requiring hoisting, i.e. module wrapping transformation will hoist it. */\n<fim_suffix>\tpublic void markAsToHoist(FunctionDeclaration element) {\n\t\ttag(Tag.toHoist, element);\n\t}\n\t/** Tells if the given expression statement was derived from initializer expression of a to-be-hoisted variable. */\n\tpublic boolean isInitializerOfHoistedVariable(ExpressionStatement element) {\n\t\treturn isTaggedAs(Tag.initializerOfHoistedVariable, element);\n\t}\n\t/** Marks given expression statement was being derived from initializer expression of a to-be-hoisted variable. */\n\tpublic void markAsInitializerOfHoistedVariable(ExpressionStatement element) {\n\t\ttag(Tag.initializerOfHoistedVariable, element);\n\t}\n\t/** Tells if the given call expression has been derived from an explicit super call within a constructor. */\n\tpublic boolean isExplicitSuperCall(ParameterizedCallExpression callExpr) {\n\t\treturn isTaggedAs(Tag.explicitSuperCall, callExpr);\n\t}\n\t/** Marks given call expression as being derived from an explicit super call within a constructor. */\n\tpublic void markAsExplicitSuperCall(ParameterizedCallExpression callExpr) {\n\t\ttag(Tag.explicitSuperCall, callExpr);\n\t}\n\t/** Tells if the given member was consumed from an interface. */\n\tpublic boolean isConsumedFromInterface(N4MemberDeclaration element) {\n\t\treturn isTaggedAs(Tag.consumedFromInterface, element);\n\t}\n\t/** Marks given member as being consumed from an interface. */\n\tpublic void markAsConsumedFromInterface(N4MemberDeclaration element) {\n\t\ttag(Tag.consumedFromInterface, element);\n\t}\n\t/** Tells if the given member was statically polyfilled. */\n\tpublic boolean isStaticlyPolyfilled(N4MemberDeclaration element) {\n\t\treturn isTaggedAs(Tag.staticlyPolyfilled, element);\n\t}\n\t/** Marks given member as statically polyfilled. */\n\tpublic void markAsStaticlyPolyfilled(N4MemberDeclaration element) {\n\t\ttag(Tag.staticlyPolyfilled, element);\n\t}\n\tprivate boolean isTaggedAs(Tag tag, EObject element) {\n\t\treturn hmTagged.containsEntry(tag, element);\n\t}\n\tprivate void tag(Tag tag, EObject element) {\n\t\thmTagged.put(tag, element);\n\t}\n\t/** Return true if the element is an IM element. */\n\tpublic boolean isIntermediateModelElement(EObject eobj) {\n\t\treturn TranspilerUtils.isIntermediateModelElement(eobj);\n\t}\n\t/**\n\t * For {@link ImportDeclaration}s that do not have an original AST node (i.e. that were created by some\n\t * transformation on-the-fly), this returns the imported module.\n\t */\n\tpublic TModule getImportedModule(ImportDeclaration importDeclInIM) {\n\t\treturn getImportedModule(importDeclInIM, true);\n\t}\n\t/**\n\t * For {@link ImportDeclaration}s that do not have an original AST node (i.e. that were created by some\n\t * transformation on-the-fly), this returns the imported module.\n\t */\n\tpublic TModule getImportedModule(ImportDeclaration importDeclInIM, boolean assertIntermediateModel) {\n\t\tif (assertIntermediateModel) {\n\t\t\tTranspilerUtils.assertIntermediateModelElement(importDeclInIM);\n\t\t}\n\t\treturn importedModules.get(importDeclInIM);\n\t}\n\t/**\n\t * Sets the imported module for the given {@link ImportDeclaration} in the intermediate model. For import\n\t * declarations that were created from the original AST, we expect the {@link PreparationStep} to set this value,\n\t * for import declarations that were created by some transformation on-the-fly, we expect the transformation that\n\t * creates such an import declaration to define the imported module via this method.\n\t */\n\tpublic void setImportedModule(ImportDeclaration importDeclInIM, TModule module) {\n\t\tTranspilerUtils.assertIntermediateModelElement(importDeclInIM);\n\t\tsetImportedModule_internal(importDeclInIM, module);\n\t}\n\t/**\n\t * As {@link #setImportedModule(ImportDeclaration,TModule)}, but does not assert that <code>elementInIM</code> is<fim_middle>// function below has no smell\n"}