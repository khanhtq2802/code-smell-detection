{"text": "<fim_prefix>        {\n            try\n            {\n                return new CompactionInfo(sstable.metadata(),\n                                          OperationType.SCRUB,\n                                          dataFile.getFilePointer(),\n                                          dataFile.length(),\n                                          scrubCompactionId,\n                                          ImmutableSet.of(sstable));\n            }\n            catch (Exception e)\n            {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n    @VisibleForTesting\n    public ScrubResult scrubWithResult()\n    {\n        scrub();\n        return new ScrubResult(this);\n    }\n    public static final class ScrubResult\n    {\n        public final int goodRows;\n        public final int badRows;\n        public final int emptyRows;\n        public ScrubResult(Scrubber scrubber)\n        {\n            this.goodRows = scrubber.goodRows;\n            this.badRows = scrubber.badRows;\n            this.emptyRows = scrubber.emptyRows;\n        }\n    }\n    public class NegativeLocalDeletionInfoMetrics\n    {\n        public volatile int fixedRows = 0;\n    }\n    /**\n     * During 2.x migration, under some circumstances rows might have gotten duplicated.\n     * Merging iterator merges rows with same clustering.\n     *\n     * For more details, refer to CASSANDRA-12144.\n     */\n    private static class RowMergingSSTableIterator extends WrappingUnfilteredRowIterator\n    {\n        Unfiltered nextToOffer = null;\n        RowMergingSSTableIterator(UnfilteredRowIterator source)\n        {\n            super(source);\n        }\n        @Override\n        public boolean hasNext()\n        {\n            return nextToOffer != null || wrapped.hasNext();\n        }\n        @Override\n        public Unfiltered next()\n        {\n            Unfiltered next = nextToOffer != null ? nextToOffer : wrapped.next();\n            if (next.isRow())\n            {\n                while (wrapped.hasNext())\n                {\n                    Unfiltered peek = wrapped.next();\n                    if (!peek.isRow() || !next.clustering().equals(peek.clustering()))\n                    {\n                        nextToOffer = peek; // Offer peek in next call\n                        return next;\n                    }\n                    // Duplicate row, merge it.\n                    next = Rows.merge((Row) next, (Row) peek);\n                }\n            }\n            nextToOffer = null;\n            return next;\n        }\n    }\n    /**\n     * In some case like CASSANDRA-12127 the cells might have been stored in the wrong order. This decorator check the\n     * cells order and collect the out of order cells to correct the problem.\n     */\n    private static final class OrderCheckerIterator extends AbstractIterator<Unfiltered> implements UnfilteredRowIterator\n    {\n        /**\n         * The decorated iterator.\n         */\n        private final UnfilteredRowIterator iterator;\n        private final ClusteringComparator comparator;\n        private Unfiltered previous;\n        /**\n         * The partition containing the rows which are out of order.\n         */\n        private Partition rowsOutOfOrder;\n        public OrderCheckerIterator(UnfilteredRowIterator iterator, ClusteringComparator comparator)\n        {\n            this.iterator = iterator;\n            this.comparator = comparator;\n        }\n        public TableMetadata metadata()\n        {\n            return iterator.metadata();\n        }\n        public boolean isReverseOrder()\n        {\n            return iterator.isReverseOrder();\n        }\n        public RegularAndStaticColumns columns()\n        {\n            return iterator.columns();\n        }\n        public DecoratedKey partitionKey()\n        {\n            return iterator.partitionKey();\n        }\n        public Row staticRow()\n        {\n            return iterator.staticRow();\n        }\n        @Override\n        public boolean isEmpty()\n        {\n            return iterator.isEmpty();\n        }\n        public void close()\n        {\n            iterator.close();\n        }\n        public DeletionTime partitionLevelDeletion()\n        {\n            return iterator.partitionLevelDeletion();\n        }\n        public EncodingStats stats()\n        {\n            return iterator.stats();\n        }\n        public boolean hasRowsOutOfOrder()\n        {\n            return rowsOutOfOrder != null;\n        }\n        public Partition getRowsOutOfOrder()\n        {\n            return rowsOutOfOrder;\n        }\n        protected Unfiltered computeNext()\n        {\n            if (!iterator.hasNext())\n                return endOfData();\n            Unfiltered next = iterator.next();\n            // If we detect that some rows are out of order we will store and sort the remaining ones to insert them\n            // in a separate SSTable.\n            if (previous != null && comparator.compare(next, previous) < 0)\n            {\n                rowsOutOfOrder = ImmutableBTreePartition.create(UnfilteredRowIterators.concat(next, iterator), false);\n                return endOfData();\n            }\n            previous = next;\n            return next;\n        }\n    }\n    /**\n     * This iterator converts negative {@link AbstractCell#localDeletionTime()} into {@link AbstractCell#MAX_DELETION_TIME}\n     *\n     * This is to recover entries with overflowed localExpirationTime due to CASSANDRA-14092\n     */\n<fim_suffix>    private static final class FixNegativeLocalDeletionTimeIterator extends AbstractIterator<Unfiltered> implements UnfilteredRowIterator\n    {\n        /**\n         * The decorated iterator.\n         */\n        private final UnfilteredRowIterator iterator;\n        private final OutputHandler outputHandler;\n        private final NegativeLocalDeletionInfoMetrics negativeLocalExpirationTimeMetrics;\n        public FixNegativeLocalDeletionTimeIterator(UnfilteredRowIterator iterator, OutputHandler outputHandler,\n                                                    NegativeLocalDeletionInfoMetrics negativeLocalDeletionInfoMetrics)\n        {\n            this.iterator = iterator;\n            this.outputHandler = outputHandler;\n            this.negativeLocalExpirationTimeMetrics = negativeLocalDeletionInfoMetrics;\n        }\n        public TableMetadata metadata()\n        {\n            return iterator.metadata();\n        }\n        public boolean isReverseOrder()\n        {\n            return iterator.isReverseOrder();\n        }\n        public RegularAndStaticColumns columns()\n        {\n            return iterator.columns();\n        }\n        public DecoratedKey partitionKey()\n        {\n            return iterator.partitionKey();\n        }\n        public Row staticRow()\n        {\n            return iterator.staticRow();\n        }\n        @Override\n        public boolean isEmpty()\n        {\n            return iterator.isEmpty();\n        }\n        public void close()\n        {\n            iterator.close();\n        }\n        public DeletionTime partitionLevelDeletion()\n        {\n            return iterator.partitionLevelDeletion();\n        }\n        public EncodingStats stats()\n        {\n            return iterator.stats();\n        }\n        protected Unfiltered computeNext()\n        {\n            if (!iterator.hasNext())\n                return endOfData();\n            Unfiltered next = iterator.next();\n            if (!next.isRow())\n                return next;\n            if (hasNegativeLocalExpirationTime((Row) next))\n            {\n                outputHandler.debug(String.format(\"Found row with negative local expiration time: %s\", next.toString(metadata(), false)));\n                negativeLocalExpirationTimeMetrics.fixedRows++;\n                return fixNegativeLocalExpirationTime((Row) next);\n            }\n            return next;\n        }\n        private boolean hasNegativeLocalExpirationTime(Row next)\n        {\n            Row row = next;\n            if (row.primaryKeyLivenessInfo().isExpiring() && row.primaryKeyLivenessInfo().localExpirationTime() < 0)\n            {\n                return true;\n            }\n            for (ColumnData cd : row)\n            {\n                if (cd.column().isSimple())\n                {\n                    Cell cell = (Cell)cd;\n                    if (cell.isExpiring() && cell.localDeletionTime() < 0)\n                        return true;\n                }\n                else\n                {\n                    ComplexColumnData complexData = (ComplexColumnData)cd;\n                    for (Cell cell : complexData)\n                    {\n                        if (cell.isExpiring() && cell.localDeletionTime() < 0)\n                            return true;\n                    }\n                }\n            }\n            return false;\n        }\n        private Unfiltered fixNegativeLocalExpirationTime(Row row)\n        {\n            Row.Builder builder = HeapAllocator.instance.cloningBTreeRowBuilder();\n            builder.newRow(row.clustering());\n            builder.addPrimaryKeyLivenessInfo(row.primaryKeyLivenessInfo().isExpiring() && row.primaryKeyLivenessInfo().localExpirationTime() < 0 ?\n                                              row.primaryKeyLivenessInfo().withUpdatedTimestampAndLocalDeletionTime(row.primaryKeyLivenessInfo().timestamp() + 1, AbstractCell.MAX_DELETION_TIME)\n                                              :row.primaryKeyLivenessInfo());\n            builder.addRowDeletion(row.deletion());\n            for (ColumnData cd : row)\n            {\n                if (cd.column().isSimple())\n                {\n                    Cell cell = (Cell)cd;\n                    builder.addCell(cell.isExpiring() && cell.localDeletionTime() < 0 ? cell.withUpdatedTimestampAndLocalDeletionTime(cell.timestamp() + 1, AbstractCell.MAX_DELETION_TIME) : cell);\n                }\n                else\n                {\n                    ComplexColumnData complexData = (ComplexColumnData)cd;\n                    builder.addComplexDeletion(complexData.column(), complexData.complexDeletion());\n                    for (Cell cell : complexData)\n                    {\n                        builder.addCell(cell.isExpiring() && cell.localDeletionTime() < 0 ? cell.withUpdatedTimestampAndLocalDeletionTime(cell.timestamp() + 1, AbstractCell.MAX_DELETION_TIME) : cell);\n                    }\n                }\n            }\n            return builder.build();\n        }\n    }<fim_middle>// class below has no smell\n"}