{"text": "<fim_prefix>\n<fim_suffix>public class RFC3339Utils {\n  private static final RFC3339Utils INSTANCE = new RFC3339Utils();\n  public static RFC3339Utils getInstance() {\n    return INSTANCE;\n  }\n  private static final String BASE = \"^[0-9]{4}\\\\-[0-9]{2}\\\\-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}\";\n  private static final String TZ = \"[+-][0-9]{2}:?[0-9]{2}$\";\n  private static final String SUB_SECOND = \"\\\\.([0-9]*)\";\n  private static final String UTC = \"Z$\";\n  private static final Pattern MILLIS = Pattern.compile(\"^[0-9]*$\");\n  private static final Pattern UTC_STANDARD = Pattern.compile(BASE + UTC);\n  private static final Pattern UTC_SUB_SECOND = Pattern.compile(BASE + SUB_SECOND + UTC);\n  private static final Pattern LOCAL_STANDARD = Pattern.compile(BASE + TZ);\n  private static final Pattern LOCAL_SUB_SECOND = Pattern.compile(BASE + SUB_SECOND + TZ);\n  private static final String BASE_FMT = \"yyyy-MM-dd'T'HH:mm:ss\";\n  public static final DateTimeFormatter UTC_STANDARD_FMT = DateTimeFormat.forPattern(BASE_FMT + \"'Z'\").withZoneUTC();\n  public static final DateTimeFormatter UTC_SUB_SECOND_FMT = DateTimeFormat.forPattern(BASE_FMT + \".SSS'Z'\").withZoneUTC();\n  public static final DateTimeFormatter LOCAL_STANDARD_FMT = DateTimeFormat.forPattern(BASE_FMT + \"Z\").withZoneUTC();\n  public static final DateTimeFormatter LOCAL_SUB_SECOND_FMT = DateTimeFormat.forPattern(BASE_FMT + \".SSSZ\").withZoneUTC();\n  /**\n   * Contains various formats.  All formats should be of international standards when comes to the ordering of the\n   * days and month.\n   */\n  private static final  DateTimeFormatter DEFAULT_FORMATTER;\n  /**\n   * Contains alternative formats that will succeed after failures from the DEFAULT_FORMATTER.\n   * i.e. 4/24/2014 will throw an exception on the default formatter because it will assume international date standards\n   * However, the date will parse in the ALT_FORMATTER because it contains the US format of MM/dd/yyyy.\n   */\n  private static final DateTimeFormatter ALT_FORMATTER;\n  static {\n    DateTimeParser[] parsers = new DateTimeParser[]{\n        DateTimeFormat.forPattern(\"EEE MMM dd HH:mm:ss Z yyyy\").withZoneUTC().getParser(),\n        DateTimeFormat.forPattern(\"EEE, dd MMM yyyy HH:mm:ss Z\").getParser(),\n        DateTimeFormat.forPattern(\"dd MMMM yyyy HH:mm:ss\").withZoneUTC().getParser(),\n        DateTimeFormat.forPattern(\"yyyyMMdd\").withZoneUTC().getParser(),\n        DateTimeFormat.forPattern(\"dd-MM-yyyy\").withZoneUTC().getParser(),\n        DateTimeFormat.forPattern(\"yyyy-MM-dd\").withZoneUTC().getParser(),\n        DateTimeFormat.forPattern(\"yyyy/MM/dd\").withZoneUTC().getParser(),\n        DateTimeFormat.forPattern(\"dd MMM yyyy\").withZoneUTC().getParser(),\n        DateTimeFormat.forPattern(\"dd MMMM yyyy\").withZoneUTC().getParser(),\n        DateTimeFormat.forPattern(\"yyyyMMddHHmm\").withZoneUTC().getParser(),\n        DateTimeFormat.forPattern(\"yyyyMMdd HHmm\").withZoneUTC().getParser(),\n        DateTimeFormat.forPattern(\"dd-MM-yyyy HH:mm\").withZoneUTC().getParser(),\n        DateTimeFormat.forPattern(\"yyyy-MM-dd HH:mm\").withZoneUTC().getParser(),\n        DateTimeFormat.forPattern(\"yyyy/MM/dd HH:mm\").withZoneUTC().getParser(),\n        DateTimeFormat.forPattern(\"dd MMM yyyy HH:mm\").withZoneUTC().getParser(),\n        DateTimeFormat.forPattern(\"dd MMMM yyyy HH:mm\").withZoneUTC().getParser(),\n        DateTimeFormat.forPattern(\"yyyyMMddHHmmss\").withZoneUTC().getParser(),\n        DateTimeFormat.forPattern(\"yyyyMMdd HHmmss\").withZoneUTC().getParser(),\n        DateTimeFormat.forPattern(\"dd-MM-yyyy HH:mm:ss\").withZoneUTC().getParser(),\n        DateTimeFormat.forPattern(\"yyyy-MM-dd HH:mm:ss\").withZoneUTC().getParser(),\n        DateTimeFormat.forPattern(\"yyyy/MM/dd HH:mm:ss\").withZoneUTC().getParser(),\n        DateTimeFormat.forPattern(\"dd MMM yyyy HH:mm:ss\").withZoneUTC().getParser(),\n        DateTimeFormat.forPattern(\"HH:mm:ss yyyy/MM/dd\").withZoneUTC().getParser(),\n        DateTimeFormat.forPattern(\"HH:mm:ss MM/dd/yyyy\").withZoneUTC().getParser(),\n        DateTimeFormat.forPattern(\"HH:mm:ss yyyy-MM-dd\").withZoneUTC().getParser(),\n        DateTimeFormat.forPattern(\"HH:mm:ss MM-dd-yyyy\").withZoneUTC().getParser(),\n        DateTimeFormat.forPattern(\"dd/MM/yyyy HH:mm:ss\").withZoneUTC().getParser(),\n        DateTimeFormat.forPattern(\"dd/MM/yyyy HH:mm\").withZoneUTC().getParser(),\n        DateTimeFormat.forPattern(\"dd/MM/yyyy\").withZoneUTC().getParser(),\n        UTC_STANDARD_FMT.getParser(),\n        UTC_SUB_SECOND_FMT.getParser(),\n        LOCAL_STANDARD_FMT.getParser(),\n        LOCAL_SUB_SECOND_FMT.getParser()\n    };\n    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\n    builder.append(null, parsers);\n    DEFAULT_FORMATTER = builder.toFormatter().withZoneUTC();\n    DateTimeParser[] altParsers = new DateTimeParser[] {\n        DateTimeFormat.forPattern(\"MM-dd-yyyy HH:mm:ss\").withZoneUTC().getParser(),\n        DateTimeFormat.forPattern(\"MM/dd/yyyy HH:mm:ss\").withZoneUTC().getParser(),\n        DateTimeFormat.forPattern(\"MM/dd/yyyy HH:mm\").withZoneUTC().getParser(),\n        DateTimeFormat.forPattern(\"MM/dd/yyyy\").withZoneUTC().getParser(),\n    };\n    builder = new DateTimeFormatterBuilder();\n    builder.append(null, altParsers);\n    ALT_FORMATTER = builder.toFormatter().withZoneUTC();\n  }\n  private RFC3339Utils() {}\n  /**\n   * parse String to DateTime\n   * @param toParse DateTime as UTC String\n   * @return DateTime\n   */\n  public static DateTime parseUTC(String toParse) {\n    if (MILLIS.matcher(toParse).matches()) {\n      return new DateTime(Long.valueOf(toParse), DateTimeZone.UTC);\n    }\n    if (UTC_STANDARD.matcher(toParse).matches()) {\n      return parseUTC(UTC_STANDARD_FMT, toParse);\n    }\n    Matcher utc = UTC_SUB_SECOND.matcher(toParse);\n    if (utc.matches()) {\n      return parseUTC(getSubSecondFormat(utc.group(1), \"'Z'\"), toParse);\n    }\n    if (LOCAL_STANDARD.matcher(toParse).matches()) {\n      return parseUTC(LOCAL_STANDARD_FMT, toParse);\n    }\n    Matcher local = LOCAL_SUB_SECOND.matcher(toParse);\n    if (local.matches()) {\n      return parseUTC(getSubSecondFormat(local.group(1), \"Z\"), toParse);\n    }\n    throw new IllegalArgumentException(String.format(\"Failed to parse date %s. Ensure format is RFC3339 Compliant\", toParse));\n  }\n  private static DateTime parseUTC(DateTimeFormatter formatter, String toParse) {\n    return formatter.parseDateTime(toParse);\n  }\n  /**\n   * Parses arbitrarily formatted Strings representing dates or dates and times to a {@link org.joda.time.DateTime}\n   * objects.  It first attempts parse with international standards, assuming the dates are either dd MM yyyy or\n   * yyyy MM dd.  If that fails it will try American formats where the month precedes the days of the month.\n   * @param dateString abitrarily formatted date or date and time string\n   * @return {@link org.joda.time.DateTime} representation of the dateString\n   */\n  public static DateTime parseToUTC(String dateString) {\n    if (MILLIS.matcher(dateString).find()) {\n      return new DateTime(Long.parseLong(dateString));\n    }\n    try {\n      return DEFAULT_FORMATTER.parseDateTime(dateString);\n    } catch (Exception ex) {\n      return ALT_FORMATTER.parseDateTime(dateString);\n    }\n  }\n  /**\n   * Formats an arbitrarily formatted into RFC3339 Specifications.\n   * @param dateString date string to be formatted\n   * @return RFC3339 compliant date string\n   */\n  public static String format(String dateString) {\n    return format(parseToUTC(dateString));\n  }<fim_middle>// class below has no smell\n"}