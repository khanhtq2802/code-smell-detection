{"text": "<fim_prefix>\n<fim_suffix>public class MemberMatrix {\n\t// columns (index 0)\n\tfinal static String[] COLS = { \"owned\", \"inherited\", \"implemented\" };\n\tfinal static int OWNED = 0;\n\tfinal static int INHERITED = 1;\n\tfinal static int IMPLEMENTED = 2;\n\tfinal static int CONSUMED = 3;\n\t/** Number of source kinds, *not* including {@link #CONSUMED}. */\n\tfinal static int SOURCE_COUNT_WITHOUT_CONSUMED = 3; // number of columns (not considering CONSUMED)\n\tfinal static int MEMBER_TYPE_COUNT = MemberType.values().length; // number of rows\n\t/**\n\t * Set of actually consumed members, added in via {@link #markConsumed(MemberList)}.\n\t */\n\tprivate final Set<TMember> consumed;\n\t// rows (index 1) according to MemberType values\n\tprivate final MemberList<TMember>[][] memberMatrix;\n\t/**\n\t * List of members from interfaces that are not implemented, because they are static.\n\t */\n\tprivate final MemberList<TMember> nonImplemented;\n\t/**\n\t * Iterator which holds information about the source (owned, consumed, inherited, implemented) of the last returned\n\t * element.\n\t */\n\tpublic class SourceAwareIterator implements Iterator<TMember> {\n\t\tprivate int lastRetrievedSource = -1;\n\t\tprivate TMember lastRetrievedElement;\n\t\t/** The source used to find the next element */\n\t\tprotected int source;\n\t\t/** The current iterator */\n\t\tprotected Iterator<TMember> currentIter;\n\t\tprivate TMember next;\n\t\tfinal private boolean returnConsumed;\n\t\tSourceAwareIterator(boolean returnConsumed) {\n\t\t\tthis.returnConsumed = returnConsumed;\n\t\t\tinitIter();\n\t\t\tnext = findNext();\n\t\t}\n\t\t/**\n\t\t * Initialized iterator with which we start, the owned members by default.\n\t\t */\n\t\tprotected void initIter() {\n\t\t\tsource = OWNED;\n\t\t\tcurrentIter = members(source).iterator();\n\t\t}\n\t\t/**\n\t\t * Returns true if the last returned member is actually contained in the type, that is it is either owned,\n\t\t * inherited, or mixed in. If it is inherited, it is not overridden.\n\t\t */\n\t\tpublic boolean isActualMember() {\n\t\t\treturn lastRetrievedSource == OWNED || lastRetrievedSource == CONSUMED\n\t\t\t\t\t|| (lastRetrievedSource == INHERITED && isActuallyInherited(lastRetrievedElement));\n\t\t}\n\t\t/**\n\t\t * Returns true if the source of the last returned element is an interface (either consumed in classifier or to\n\t\t * be implemented).\n\t\t */\n\t\tpublic boolean isInterfaceMember() {\n\t\t\treturn lastRetrievedSource == IMPLEMENTED;\n\t\t}\n\t\t/**\n\t\t * Returns true if the source of the last returned element is the super class.\n\t\t */\n\t\tpublic boolean isInheritedMember() {\n\t\t\treturn lastRetrievedSource == INHERITED;\n\t\t}\n\t\t/**\n\t\t * Returns true if the source of the last returned element is the class itself.\n\t\t */\n\t\tpublic boolean isOwnedMember() {\n\t\t\treturn lastRetrievedSource == OWNED;\n\t\t}\n\t\t/**\n\t\t * Finds next member.\n\t\t */\n\t\tprotected TMember findNext() {\n\t\t\tdo {\n\t\t\t\twhile (currentIter.hasNext()) {\n\t\t\t\t\tTMember m = currentIter.next();\n\t\t\t\t\tif (!returnConsumed || source != IMPLEMENTED || !consumed.contains(m)) {\n\t\t\t\t\t\treturn m;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcurrentIter = nextIter();\n\t\t\t} while (source >= 0);\n\t\t\treturn null;\n\t\t}\n\t\t/**\n\t\t * Selects the next iterator.\n\t\t */\n\t\tprotected Iterator<TMember> nextIter() {\n\t\t\tswitch (source) {\n\t\t\tcase OWNED:\n\t\t\t\tif (returnConsumed) {\n\t\t\t\t\tsource = CONSUMED;\n\t\t\t\t\treturn consumed.iterator();\n\t\t\t\t} // else\n\t\t\t\t\t// $FALL-THROUGH$\n\t\t\tcase CONSUMED: {\n\t\t\t\tsource = INHERITED;\n\t\t\t\treturn members(source).iterator();\n\t\t\t}\n\t\t\tcase INHERITED: {\n\t\t\t\tsource = IMPLEMENTED;\n\t\t\t\treturn members(source).iterator();\n\t\t\t}\n\t\t\tcase IMPLEMENTED:\n\t\t\t\t// $FALL-THROUGH$\n\t\t\tdefault:\n\t\t\t\tsource = -1;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\treturn source >= 0;\n\t\t}\n\t\t@Override\n\t\tpublic TMember next() {\n\t\t\tif (!hasNext()) {\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\t}\n\t\t\tlastRetrievedElement = next;\n\t\t\tlastRetrievedSource = source;\n\t\t\tnext = findNext();\n\t\t\treturn lastRetrievedElement;\n\t\t}\n\t}\n\t/**\n\t * Iterator that iterates only over consumed and actually inherited members.\n\t */\n\tpublic class ActuallyInheritedAndConsumedMembersIterator extends SourceAwareIterator {\n\t\t/** Delegates to super constructor */\n\t\tActuallyInheritedAndConsumedMembersIterator() {\n\t\t\tsuper(true);\n\t\t}\n\t\t@Override\n\t\tprotected void initIter() {\n\t\t\tsource = CONSUMED;\n\t\t\tcurrentIter = consumed.iterator();\n\t\t}\n\t\t@Override\n\t\tprotected TMember findNext() {\n\t\t\tdo {\n\t\t\t\twhile (currentIter.hasNext()) {\n\t\t\t\t\tTMember m = currentIter.next();\n\t\t\t\t\tif (source == CONSUMED || isActuallyInherited(m)) {\n\t\t\t\t\t\treturn m;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcurrentIter = nextIter();\n\t\t\t} while (source >= 0);\n\t\t\treturn null;\n\t\t}\n\t\t@Override\n\t\tprotected Iterator<TMember> nextIter() {\n\t\t\tswitch (source) {\n\t\t\tcase CONSUMED: {\n\t\t\t\tsource = INHERITED;\n\t\t\t\treturn members(source).iterator();\n\t\t\t}\n\t\t\tdefault:\n\t\t\t\tsource = -1;\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * Creates an empty matrix.\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic MemberMatrix() {\n\t\tmemberMatrix = new MemberList[SOURCE_COUNT_WITHOUT_CONSUMED][MEMBER_TYPE_COUNT];\n\t\tconsumed = new HashSet<>(2);\n\t\tnonImplemented = new MemberList<>(2);\n\t}\n\t/**\n\t * @see N4JSMemberRedefinitionValidator#constraints_61_Consumption(MemberMatrix)\n\t */\n\t@SuppressWarnings(\"javadoc\")\n\tpublic void markConsumed(MemberList<TMember> consumedMembers) {\n\t\tconsumed.addAll(consumedMembers);\n\t}\n\t/**\n\t * Tells if the given member is one of the \"consumed members\" added via method {@link #markConsumed(MemberList)}.\n\t */\n\tpublic boolean isConsumed(TMember member) {\n\t\treturn consumed.contains(member);\n\t}\n\t/**\n\t * Returns true if the matrix contains an owned getter and an owned setter.\n\t */\n\tpublic boolean hasOwnedAccessorPair() {\n\t\treturn !members(OWNED, GETTER).isEmpty() && !members(OWNED, SETTER).isEmpty();\n\t}\n\t/**\n\t * Returns true if the matrix contains a mixed accessor pair. That is that getter and setter have different origins\n\t * (inherited, owned). This method doesn't consider consumed members.\n\t */\n\tpublic boolean hasMixedAccessorPair() {\n\t\tboolean hasOwnedGetter = !members(OWNED, GETTER).isEmpty();\n\t\tboolean hasOwnedSetter = !members(OWNED, SETTER).isEmpty();\n\t\tboolean hasInheritedGetter = !members(INHERITED, GETTER).isEmpty();\n\t\tboolean hasInheritedSetter = !members(INHERITED, SETTER).isEmpty();\n\t\treturn (!hasOwnedGetter && hasInheritedGetter && hasOwnedSetter) ||\n\t\t\t\t(hasOwnedGetter && hasInheritedSetter && !hasOwnedSetter);\n\t}\n\t/**\n\t * Returns {@code true} if the matrix contains a getter as well as a setter.\n\t */\n\tpublic boolean hasAccessorPair() {\n\t\treturn (!members(OWNED, GETTER).isEmpty() || !members(INHERITED, GETTER).isEmpty()\n\t\t\t\t|| !members(IMPLEMENTED, GETTER).isEmpty()) &&\n\t\t\t\t(!members(OWNED, SETTER).isEmpty() || !members(INHERITED, SETTER).isEmpty()\n\t\t\t\t\t\t|| !members(IMPLEMENTED, SETTER).isEmpty());\n\t}\n\t/**\n\t * Returns all owned, inherited and implemented members (but not consumed members, since they are already contained\n\t * in \"implemented\").\n\t */<fim_middle>// class below is blob\n"}