{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.hadoop.fs;\nimport java.util.Optional;\nimport java.util.function.Function;\nimport java.util.function.BiFunction;\nimport org.apache.hadoop.classification.InterfaceAudience;\nimport org.apache.hadoop.classification.InterfaceStability;\nimport org.apache.hadoop.fs.permission.FsPermission;\nimport org.apache.hadoop.util.DataChecksum;\nimport org.apache.hadoop.util.Progressable;\n/**\n * This class contains options related to file system operations.\n */\n@InterfaceAudience.Public\n@InterfaceStability.Evolving\npublic final class Options {\n  /**\n   * Class to support the varargs for create() options.\n   *\n   */\n  public static class CreateOpts {\n    private CreateOpts() { };\n    public static BlockSize blockSize(long bs) { \n      return new BlockSize(bs);\n    }\n    public static BufferSize bufferSize(int bs) { \n      return new BufferSize(bs);\n    }\n    public static ReplicationFactor repFac(short rf) { \n      return new ReplicationFactor(rf);\n    }\n    public static BytesPerChecksum bytesPerChecksum(short crc) {\n      return new BytesPerChecksum(crc);\n    }\n    public static ChecksumParam checksumParam(\n        ChecksumOpt csumOpt) {\n      return new ChecksumParam(csumOpt);\n    }\n    public static Progress progress(Progressable prog) {\n      return new Progress(prog);\n    }\n    public static Perms perms(FsPermission perm) {\n      return new Perms(perm);\n    }\n    public static CreateParent createParent() {\n      return new CreateParent(true);\n    }\n    public static CreateParent donotCreateParent() {\n      return new CreateParent(false);\n    }\n    public static class BlockSize extends CreateOpts {\n      private final long blockSize;\n      protected BlockSize(long bs) {\n        if (bs <= 0) {\n          throw new IllegalArgumentException(\n                        \"Block size must be greater than 0\");\n        }\n        blockSize = bs; \n      }\n      public long getValue() { return blockSize; }\n    }\n    public static class ReplicationFactor extends CreateOpts {\n      private final short replication;\n      protected ReplicationFactor(short rf) { \n        if (rf <= 0) {\n          throw new IllegalArgumentException(\n                      \"Replication must be greater than 0\");\n        }\n        replication = rf;\n      }\n      public short getValue() { return replication; }\n    }\n    public static class BufferSize extends CreateOpts {\n      private final int bufferSize;\n      protected BufferSize(int bs) {\n        if (bs <= 0) {\n          throw new IllegalArgumentException(\n                        \"Buffer size must be greater than 0\");\n        }\n        bufferSize = bs; \n      }\n      public int getValue() { return bufferSize; }\n    }\n    /** This is not needed if ChecksumParam is specified. **/\n    public static class BytesPerChecksum extends CreateOpts {\n      private final int bytesPerChecksum;\n      protected BytesPerChecksum(short bpc) { \n        if (bpc <= 0) {\n          throw new IllegalArgumentException(\n                        \"Bytes per checksum must be greater than 0\");\n        }\n        bytesPerChecksum = bpc; \n      }\n      public int getValue() { return bytesPerChecksum; }\n    }\n    public static class ChecksumParam extends CreateOpts {\n      private final ChecksumOpt checksumOpt;\n      protected ChecksumParam(ChecksumOpt csumOpt) {\n        checksumOpt = csumOpt;\n      }\n      public ChecksumOpt getValue() { return checksumOpt; }\n    }\n<fim_suffix>    public static class Perms extends CreateOpts {\n      private final FsPermission permissions;\n      protected Perms(FsPermission perm) { \n        if(perm == null) {\n          throw new IllegalArgumentException(\"Permissions must not be null\");\n        }\n        permissions = perm; \n      }\n      public FsPermission getValue() { return permissions; }\n    }\n    public static class Progress extends CreateOpts {\n      private final Progressable progress;\n      protected Progress(Progressable prog) { \n        if(prog == null) {\n          throw new IllegalArgumentException(\"Progress must not be null\");\n        }\n        progress = prog;\n      }\n      public Progressable getValue() { return progress; }\n    }\n    public static class CreateParent extends CreateOpts {\n      private final boolean createParent;\n      protected CreateParent(boolean createPar) {\n        createParent = createPar;}\n      public boolean getValue() { return createParent; }\n    }\n    /**\n     * Get an option of desired type\n     * @param clazz is the desired class of the opt\n     * @param opts - not null - at least one opt must be passed\n     * @return an opt from one of the opts of type theClass.\n     *   returns null if there isn't any\n     */\n    static <T extends CreateOpts> T getOpt(Class<T> clazz, CreateOpts... opts) {\n      if (opts == null) {\n        throw new IllegalArgumentException(\"Null opt\");\n      }\n      T result = null;\n      for (int i = 0; i < opts.length; ++i) {\n        if (opts[i].getClass() == clazz) {\n          if (result != null) {\n            throw new IllegalArgumentException(\"multiple opts varargs: \" + clazz);\n          }\n          @SuppressWarnings(\"unchecked\")\n          T t = (T)opts[i];\n          result = t;\n        }\n      }\n      return result;\n    }\n    /**\n     * set an option\n     * @param newValue  the option to be set\n     * @param opts  - the option is set into this array of opts\n     * @return updated CreateOpts[] == opts + newValue\n     */\n    static <T extends CreateOpts> CreateOpts[] setOpt(final T newValue,\n        final CreateOpts... opts) {\n      final Class<?> clazz = newValue.getClass();\n      boolean alreadyInOpts = false;\n      if (opts != null) {\n        for (int i = 0; i < opts.length; ++i) {\n          if (opts[i].getClass() == clazz) {\n            if (alreadyInOpts) {\n              throw new IllegalArgumentException(\"multiple opts varargs: \" + clazz);\n            }\n            alreadyInOpts = true;\n            opts[i] = newValue;\n          }\n        }\n      }\n      CreateOpts[] resultOpt = opts;\n      if (!alreadyInOpts) { // no newValue in opt\n        final int oldLength = opts == null? 0: opts.length;\n        CreateOpts[] newOpts = new CreateOpts[oldLength + 1];\n        if (oldLength > 0) {\n          System.arraycopy(opts, 0, newOpts, 0, oldLength);\n        }\n        newOpts[oldLength] = newValue;\n        resultOpt = newOpts;\n      }\n      return resultOpt;\n    }\n  }\n  /**\n   * Enum to support the varargs for rename() options\n   */\n  public enum Rename {\n    NONE((byte) 0), // No options\n    OVERWRITE((byte) 1), // Overwrite the rename destination\n    TO_TRASH ((byte) 2); // Rename to trash\n    private final byte code;\n    private Rename(byte code) {\n      this.code = code;\n    }\n    public static Rename valueOf(byte code) {\n      return code < 0 || code >= values().length ? null : values()[code];\n    }\n    public byte value() {\n      return code;\n    }\n  }\n  /**\n   * This is used in FileSystem and FileContext to specify checksum options.\n   */\n  public static class ChecksumOpt {\n    private final DataChecksum.Type checksumType;\n    private final int bytesPerChecksum;\n    /**\n     * Create a uninitialized one\n     */\n    public ChecksumOpt() {\n      this(DataChecksum.Type.DEFAULT, -1);\n    }\n    /**\n     * Normal ctor\n     * @param type checksum type\n     * @param size bytes per checksum\n     */\n    public ChecksumOpt(DataChecksum.Type type, int size) {\n      checksumType = type;\n      bytesPerChecksum = size;\n    }\n    public int getBytesPerChecksum() {\n      return bytesPerChecksum;\n    }\n    public DataChecksum.Type getChecksumType() {\n      return checksumType;\n    }\n    @Override\n    public String toString() {\n      return checksumType + \":\" + bytesPerChecksum;\n    }\n    /**\n     * Create a ChecksumOpts that disables checksum\n     */\n    public static ChecksumOpt createDisabled() {\n      return new ChecksumOpt(DataChecksum.Type.NULL, -1);\n    }\n    /**\n     * A helper method for processing user input and default value to \n     * create a combined checksum option. This is a bit complicated because\n     * bytesPerChecksum is kept for backward compatibility.\n     *\n     * @param defaultOpt Default checksum option<fim_middle>// class below has no smell\n"}