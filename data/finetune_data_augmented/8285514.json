{"text": "<fim_prefix>\n<fim_suffix>public abstract class AbstractRecipientRewriteTable implements RecipientRewriteTable, Configurable {\n    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractRecipientRewriteTable.class);\n    // The maximum mappings which will process before throwing exception\n    private int mappingLimit = 10;\n    private boolean recursive = true;\n    private DomainList domainList;\n    @Inject\n    public void setDomainList(DomainList domainList) {\n        this.domainList = domainList;\n    }\n    @Override\n    public void configure(HierarchicalConfiguration config) throws ConfigurationException {\n        setRecursiveMapping(config.getBoolean(\"recursiveMapping\", true));\n        try {\n            setMappingLimit(config.getInt(\"mappingLimit\", 10));\n        } catch (IllegalArgumentException e) {\n            throw new ConfigurationException(e.getMessage());\n        }\n        doConfigure(config);\n    }\n    /**\n     * Override to handle config\n     */\n    protected void doConfigure(HierarchicalConfiguration conf) throws ConfigurationException {\n    }\n    public void setRecursiveMapping(boolean recursive) {\n        this.recursive = recursive;\n    }\n    /**\n     * Set the mappingLimit\n     * \n     * @param mappingLimit\n     *            the mappingLimit\n     * @throws IllegalArgumentException\n     *             get thrown if mappingLimit smaller then 1 is used\n     */\n    public void setMappingLimit(int mappingLimit) throws IllegalArgumentException {\n        if (mappingLimit < 1) {\n            throw new IllegalArgumentException(\"The minimum mappingLimit is 1\");\n        }\n        this.mappingLimit = mappingLimit;\n    }\n    @Override\n    public Mappings getResolvedMappings(String user, Domain domain) throws ErrorMappingException, RecipientRewriteTableException {\n        return getMappings(User.fromLocalPartWithDomain(user, domain), mappingLimit);\n    }\n    private Mappings getMappings(User user, int mappingLimit) throws ErrorMappingException, RecipientRewriteTableException {\n        // We have to much mappings throw ErrorMappingException to avoid\n        // infinity loop\n        if (mappingLimit == 0) {\n            throw new TooManyMappingException(\"554 Too many mappings to process\");\n        }\n        Mappings targetMappings = mapAddress(user.getLocalPart(), user.getDomainPart().get());\n        try {\n            return MappingsImpl.fromMappings(\n                targetMappings.asStream()\n                    .flatMap(Throwing.function((Mapping target) -> convertAndRecurseMapping(user, target, mappingLimit)).sneakyThrow()));\n        } catch (SkipMappingProcessingException e) {\n            return MappingsImpl.empty();\n        }\n    }\n    private Stream<Mapping> convertAndRecurseMapping(User originalUser, Mapping associatedMapping, int remainingLoops) throws ErrorMappingException, RecipientRewriteTableException, SkipMappingProcessingException, AddressException {\n        Function<User, Stream<Mapping>> convertAndRecurseMapping =\n            Throwing\n                .function((User rewrittenUser) -> convertAndRecurseMapping(associatedMapping, originalUser, rewrittenUser, remainingLoops))\n                .sneakyThrow();\n        return associatedMapping.rewriteUser(originalUser)\n            .map(rewrittenUser -> rewrittenUser.withDefaultDomainFromUser(originalUser))\n            .map(convertAndRecurseMapping)\n            .orElse(Stream.empty());\n    }\n    private Stream<Mapping> convertAndRecurseMapping(Mapping mapping, User originalUser, User rewrittenUser, int remainingLoops) throws ErrorMappingException, RecipientRewriteTableException {\n        LOGGER.debug(\"Valid virtual user mapping {} to {}\", originalUser.asString(), rewrittenUser.asString());\n        Stream<Mapping> nonRecursiveResult = Stream.of(toMapping(rewrittenUser, mapping.getType()));\n        if (!recursive) {\n            return nonRecursiveResult;\n        }\n        // Check if the returned mapping is the same as the input. If so we need to handle identity to avoid loops.\n        if (originalUser.equals(rewrittenUser)) {\n            return mapping.handleIdentity(nonRecursiveResult);\n        } else {\n            return recurseMapping(nonRecursiveResult, rewrittenUser, remainingLoops);\n        }\n    }\n    private Stream<Mapping> recurseMapping(Stream<Mapping> nonRecursiveResult, User targetUser, int remainingLoops) throws ErrorMappingException, RecipientRewriteTableException {\n        Mappings childMappings = getMappings(targetUser, remainingLoops - 1);\n        if (childMappings.isEmpty()) {\n            return nonRecursiveResult;\n        } else {\n            return childMappings.asStream();\n        }\n    }\n    private Mapping toMapping(User rewrittenUser, Type type) {\n        switch (type) {\n            case Forward:\n            case Group:\n            case Alias:\n                return Mapping.of(type, rewrittenUser.asString());\n            case Regex:\n            case Domain:\n            case Error:\n            case Address:\n                return Mapping.address(rewrittenUser.asString());\n        }\n        throw new IllegalArgumentException(\"unhandled enum type\");\n    }\n    @Override\n    public void addRegexMapping(MappingSource source, String regex) throws RecipientRewriteTableException {\n        try {\n            Pattern.compile(regex);\n        } catch (PatternSyntaxException e) {\n            throw new RecipientRewriteTableException(\"Invalid regex: \" + regex, e);\n        }\n        Mapping mapping = Mapping.regex(regex);\n        checkDuplicateMapping(source, mapping);\n        LOGGER.info(\"Add regex mapping => {} for source {}\", regex, source.asString());\n        addMapping(source, mapping);\n    }\n    @Override\n    public void removeRegexMapping(MappingSource source, String regex) throws RecipientRewriteTableException {\n        LOGGER.info(\"Remove regex mapping => {} for source: {}\", regex, source.asString());\n        removeMapping(source, Mapping.regex(regex));\n    }\n    @Override\n    public void addAddressMapping(MappingSource source, String address) throws RecipientRewriteTableException {\n        Mapping mapping = Mapping.address(address)\n            .appendDomainFromThrowingSupplierIfNone(this::defaultDomain);\n        checkHasValidAddress(mapping);\n        checkDuplicateMapping(source, mapping);\n        LOGGER.info(\"Add address mapping => {} for source: {}\", mapping.asString(), source.asString());\n        addMapping(source, mapping);\n    }\n    private Domain defaultDomain() throws RecipientRewriteTableException {\n        try {\n            return domainList.getDefaultDomain();\n        } catch (DomainListException e) {\n            throw new RecipientRewriteTableException(\"Unable to retrieve default domain\", e);\n        }\n    }\n    private void checkHasValidAddress(Mapping mapping) throws RecipientRewriteTableException {\n        if (!mapping.asMailAddress().isPresent()) {\n            throw new RecipientRewriteTableException(\"Invalid emailAddress: \" + mapping.asString());\n        }\n    }\n    @Override\n    public void removeAddressMapping(MappingSource source, String address) throws RecipientRewriteTableException {\n        Mapping mapping = Mapping.address(address)\n            .appendDomainFromThrowingSupplierIfNone(this::defaultDomain);\n        LOGGER.info(\"Remove address mapping => {} for source: {}\", mapping.asString(), source.asString());\n        removeMapping(source, mapping);\n    }\n    @Override\n    public void addErrorMapping(MappingSource source, String error) throws RecipientRewriteTableException {\n        Mapping mapping = Mapping.error(error);\n        checkDuplicateMapping(source, mapping);\n        LOGGER.info(\"Add error mapping => {} for source: {}\", error, source.asString());\n        addMapping(source, mapping);\n    }\n    @Override\n    public void removeErrorMapping(MappingSource source, String error) throws RecipientRewriteTableException {\n        LOGGER.info(\"Remove error mapping => {} for source: {}\", error, source.asString());\n        removeMapping(source, Mapping.error(error));\n    }\n    @Override\n    public void addAliasDomainMapping(MappingSource source, Domain realDomain) throws RecipientRewriteTableException {\n        LOGGER.info(\"Add domain mapping: {} => {}\", source.asDomain().map(Domain::asString).orElse(\"null\"), realDomain);\n        addMapping(source, Mapping.domain(realDomain));\n    }\n    @Override\n    public void removeAliasDomainMapping(MappingSource source, Domain realDomain) throws RecipientRewriteTableException {\n        LOGGER.info(\"Remove domain mapping: {} => {}\", source.asDomain().map(Domain::asString).orElse(\"null\"), realDomain);\n        removeMapping(source, Mapping.domain(realDomain));\n    }\n    @Override\n    public void addForwardMapping(MappingSource source, String address) throws RecipientRewriteTableException {\n        Mapping mapping = Mapping.forward(address)\n            .appendDomainFromThrowingSupplierIfNone(this::defaultDomain);\n        checkHasValidAddress(mapping);\n        checkDuplicateMapping(source, mapping);\n        LOGGER.info(\"Add forward mapping => {} for source: {}\", mapping.asString(), source.asString());\n        addMapping(source, mapping);\n    }\n    @Override\n    public void removeForwardMapping(MappingSource source, String address) throws RecipientRewriteTableException {\n        Mapping mapping = Mapping.forward(address)\n            .appendDomainFromThrowingSupplierIfNone(this::defaultDomain);\n        LOGGER.info(\"Remove forward mapping => {} for source: {}\", mapping.asString(), source.asString());\n        removeMapping(source, mapping);\n    }\n    @Override\n    public void addGroupMapping(MappingSource source, String address) throws RecipientRewriteTableException {\n        Mapping mapping = Mapping.group(address)\n            .appendDomainFromThrowingSupplierIfNone(this::defaultDomain);<fim_middle>// class below is blob\n"}