{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.druid.segment;\nimport com.fasterxml.jackson.core.JsonParseException;\nimport com.fasterxml.jackson.databind.JsonMappingException;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Strings;\nimport com.google.common.base.Suppliers;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Sets;\nimport com.google.common.io.Closeables;\nimport com.google.common.io.Files;\nimport com.google.common.primitives.Ints;\nimport com.google.inject.Inject;\nimport org.apache.druid.collections.bitmap.ConciseBitmapFactory;\nimport org.apache.druid.collections.bitmap.ImmutableBitmap;\nimport org.apache.druid.collections.spatial.ImmutableRTree;\nimport org.apache.druid.common.utils.SerializerUtils;\nimport org.apache.druid.java.util.common.IAE;\nimport org.apache.druid.java.util.common.IOE;\nimport org.apache.druid.java.util.common.ISE;\nimport org.apache.druid.java.util.common.Intervals;\nimport org.apache.druid.java.util.common.StringUtils;\nimport org.apache.druid.java.util.common.io.smoosh.Smoosh;\nimport org.apache.druid.java.util.common.io.smoosh.SmooshedFileMapper;\nimport org.apache.druid.java.util.common.logger.Logger;\nimport org.apache.druid.java.util.emitter.EmittingLogger;\nimport org.apache.druid.segment.column.ColumnBuilder;\nimport org.apache.druid.segment.column.ColumnCapabilities;\nimport org.apache.druid.segment.column.ColumnConfig;\nimport org.apache.druid.segment.column.ColumnDescriptor;\nimport org.apache.druid.segment.column.ColumnHolder;\nimport org.apache.druid.segment.column.ValueType;\nimport org.apache.druid.segment.data.BitmapSerde;\nimport org.apache.druid.segment.data.BitmapSerdeFactory;\nimport org.apache.druid.segment.data.CompressedColumnarLongsSupplier;\nimport org.apache.druid.segment.data.GenericIndexed;\nimport org.apache.druid.segment.data.ImmutableRTreeObjectStrategy;\nimport org.apache.druid.segment.data.IndexedIterable;\nimport org.apache.druid.segment.data.VSizeColumnarMultiInts;\nimport org.apache.druid.segment.serde.BitmapIndexColumnPartSupplier;\nimport org.apache.druid.segment.serde.ComplexColumnPartSupplier;\nimport org.apache.druid.segment.serde.DictionaryEncodedColumnSupplier;\nimport org.apache.druid.segment.serde.FloatNumericColumnSupplier;\nimport org.apache.druid.segment.serde.LongNumericColumnSupplier;\nimport org.apache.druid.segment.serde.SpatialIndexColumnPartSupplier;\nimport org.joda.time.Interval;\nimport javax.annotation.Nullable;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\npublic class IndexIO\n{\n  public static final byte V8_VERSION = 0x8;\n  public static final byte V9_VERSION = 0x9;\n  public static final int CURRENT_VERSION_ID = V9_VERSION;\n  public static BitmapSerdeFactory LEGACY_FACTORY = new BitmapSerde.LegacyBitmapSerdeFactory();\n  public static final ByteOrder BYTE_ORDER = ByteOrder.nativeOrder();\n  private final Map<Integer, IndexLoader> indexLoaders;\n  private static final EmittingLogger log = new EmittingLogger(IndexIO.class);\n  private static final SerializerUtils serializerUtils = new SerializerUtils();\n  private final ObjectMapper mapper;\n  @Inject\n  public IndexIO(ObjectMapper mapper, ColumnConfig columnConfig)\n  {\n    this.mapper = Preconditions.checkNotNull(mapper, \"null ObjectMapper\");\n    Preconditions.checkNotNull(columnConfig, \"null ColumnConfig\");\n    ImmutableMap.Builder<Integer, IndexLoader> indexLoadersBuilder = ImmutableMap.builder();\n    LegacyIndexLoader legacyIndexLoader = new LegacyIndexLoader(new DefaultIndexIOHandler(), columnConfig);\n    for (int i = 0; i <= V8_VERSION; i++) {\n      indexLoadersBuilder.put(i, legacyIndexLoader);\n    }\n    indexLoadersBuilder.put((int) V9_VERSION, new V9IndexLoader(columnConfig));\n    indexLoaders = indexLoadersBuilder.build();\n  }\n  public void validateTwoSegments(File dir1, File dir2) throws IOException\n  {\n    try (QueryableIndex queryableIndex1 = loadIndex(dir1)) {\n      try (QueryableIndex queryableIndex2 = loadIndex(dir2)) {\n        validateTwoSegments(\n            new QueryableIndexIndexableAdapter(queryableIndex1),\n            new QueryableIndexIndexableAdapter(queryableIndex2)\n        );\n      }\n    }\n  }\n<fim_suffix>  public void validateTwoSegments(final IndexableAdapter adapter1, final IndexableAdapter adapter2)\n  {\n    if (adapter1.getNumRows() != adapter2.getNumRows()) {\n      throw new SegmentValidationException(\n          \"Row count mismatch. Expected [%d] found [%d]\",\n          adapter1.getNumRows(),\n          adapter2.getNumRows()\n      );\n    }\n    {\n      final Set<String> dimNames1 = Sets.newHashSet(adapter1.getDimensionNames());\n      final Set<String> dimNames2 = Sets.newHashSet(adapter2.getDimensionNames());\n      if (!dimNames1.equals(dimNames2)) {\n        throw new SegmentValidationException(\n            \"Dimension names differ. Expected [%s] found [%s]\",\n            dimNames1,\n            dimNames2\n        );\n      }\n      final Set<String> metNames1 = Sets.newHashSet(adapter1.getMetricNames());\n      final Set<String> metNames2 = Sets.newHashSet(adapter2.getMetricNames());\n      if (!metNames1.equals(metNames2)) {\n        throw new SegmentValidationException(\"Metric names differ. Expected [%s] found [%s]\", metNames1, metNames2);\n      }\n    }\n    final RowIterator it1 = adapter1.getRows();\n    final RowIterator it2 = adapter2.getRows();\n    long row = 0L;\n    while (it1.moveToNext()) {\n      if (!it2.moveToNext()) {\n        throw new SegmentValidationException(\"Unexpected end of second adapter\");\n      }\n      final RowPointer rp1 = it1.getPointer();\n      final RowPointer rp2 = it2.getPointer();\n      ++row;\n      if (rp1.getRowNum() != rp2.getRowNum()) {\n        throw new SegmentValidationException(\"Row number mismatch: [%d] vs [%d]\", rp1.getRowNum(), rp2.getRowNum());\n      }\n      try {\n        validateRowValues(rp1, adapter1, rp2, adapter2);\n      }\n      catch (SegmentValidationException ex) {\n        throw new SegmentValidationException(ex, \"Validation failure on row %d: [%s] vs [%s]\", row, rp1, rp2);\n      }\n    }\n    if (it2.moveToNext()) {\n      throw new SegmentValidationException(\"Unexpected end of first adapter\");\n    }\n    if (row != adapter1.getNumRows()) {\n      throw new SegmentValidationException(\n          \"Actual Row count mismatch. Expected [%d] found [%d]\",\n          row,\n          adapter1.getNumRows()\n      );\n    }\n  }\n  public QueryableIndex loadIndex(File inDir) throws IOException\n  {\n    final int version = SegmentUtils.getVersionFromDir(inDir);\n    final IndexLoader loader = indexLoaders.get(version);\n    if (loader != null) {\n      return loader.load(inDir, mapper);\n    } else {<fim_middle>// function below is feature envy and long method\n"}