{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.kafka.clients.admin;\n\nimport org.apache.kafka.common.KafkaException;\nimport org.apache.kafka.common.KafkaFuture;\nimport org.apache.kafka.common.acl.AclBinding;\nimport org.apache.kafka.common.acl.AclBindingFilter;\nimport org.apache.kafka.common.annotation.InterfaceStability;\nimport org.apache.kafka.common.errors.ApiException;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * The result of the {@link AdminClient#deleteAcls(Collection)} call.\n *\n * The API of this class is evolving, see {@link AdminClient} for details.\n */\n<fim_suffix>@InterfaceStability.Evolving\npublic class DeleteAclsResult {\n\n    /**\n     * A class containing either the deleted ACL binding or an exception if the delete failed.\n     */\n    public static class FilterResult {\n        private final AclBinding binding;\n        private final ApiException exception;\n\n        FilterResult(AclBinding binding, ApiException exception) {\n            this.binding = binding;\n            this.exception = exception;\n        }\n\n        /**\n         * Return the deleted ACL binding or null if there was an error.\n         */\n        public AclBinding binding() {\n            return binding;\n        }\n\n        /**\n         * Return an exception if the ACL delete was not successful or null if it was.\n         */\n        public ApiException exception() {\n            return exception;\n        }\n    }\n\n    /**\n     * A class containing the results of the delete ACLs operation.\n     */\n    public static class FilterResults {\n        private final List<FilterResult> values;\n\n        FilterResults(List<FilterResult> values) {\n            this.values = values;\n        }\n\n        /**\n         * Return a list of delete ACLs results for a given filter.\n         */\n        public List<FilterResult> values() {\n            return values;\n        }\n    }\n\n    private final Map<AclBindingFilter, KafkaFuture<FilterResults>> futures;\n\n    DeleteAclsResult(Map<AclBindingFilter, KafkaFuture<FilterResults>> futures) {\n        this.futures = futures;\n    }\n\n    /**\n     * Return a map from acl filters to futures which can be used to check the status of the deletions by each\n     * filter.\n     */\n    public Map<AclBindingFilter, KafkaFuture<FilterResults>> values() {\n        return futures;\n    }\n\n    /**\n     * Return a future which succeeds only if all the ACLs deletions succeed, and which contains all the deleted ACLs.\n     * Note that it if the filters don't match any ACLs, this is not considered an error.\n     */\n    public KafkaFuture<Collection<AclBinding>> all() {\n        return KafkaFuture.allOf(futures.values().toArray(new KafkaFuture[0])).thenApply(v -> getAclBindings(futures));\n    }\n\n    private List<AclBinding> getAclBindings(Map<AclBindingFilter, KafkaFuture<FilterResults>> futures) {\n        List<AclBinding> acls = new ArrayList<>();\n        for (KafkaFuture<FilterResults> value: futures.values()) {\n            FilterResults results;\n            try {\n                results = value.get();\n            } catch (Throwable e) {\n                // This should be unreachable, since the future returned by KafkaFuture#allOf should\n                // have failed if any Future failed.\n                throw new KafkaException(\"DeleteAclsResult#all: internal error\", e);\n            }\n            for (FilterResult result : results.values()) {\n                if (result.exception() != null)\n                    throw result.exception();\n                acls.add(result.binding());\n            }\n        }\n        return acls;\n    }\n}<fim_middle>// class below has no smell\n"}