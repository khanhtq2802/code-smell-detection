{"text": "<fim_prefix>\t\tif (rule instanceof TerminalRule || rule instanceof ParserRule && DatatypeRuleUtil.isDatatypeRule((ParserRule) rule)) {\n\t\t\treturn GrammarUtil.findEString(grammar);\n\t\t}\n\t\treturn null;\n\t}\n\tTypeRef getTypeRef(EClassifier classifier) {\n\t\tTypeRef result = XtextFactory.eINSTANCE.createTypeRef();\n\t\tresult.setClassifier(classifier);\n\t\tEPackage pack = classifier.getEPackage();\n\t\tfor(AbstractMetamodelDeclaration decl: GrammarUtil.allMetamodelDeclarations(grammar)) {\n\t\t\tif (pack.equals(decl.getEPackage())) {\n\t\t\t\tresult.setMetamodel(decl);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tTypeRef getTypeRef(String qualifiedName) {\n\t\tTypeRef result = XtextFactory.eINSTANCE.createTypeRef();\n\t\tString[] split = qualifiedName.split(\"::\");\n\t\tString name = qualifiedName;\n\t\tif (split.length > 1) {\n\t\t\tresult.setMetamodel(findMetamodel(grammar, split[0], split[1]));\n\t\t\tname = split[1];\n\t\t} else {\n\t\t\tresult.setMetamodel(findDefaultMetamodel(grammar, qualifiedName));\n\t\t}\n\t\tif (result.getMetamodel() instanceof ReferencedMetamodel && result.getMetamodel().getEPackage() != null) {\n\t\t\tresult.setClassifier(result.getMetamodel().getEPackage().getEClassifier(name));\n\t\t}\n\t\treturn result;\n\t}\n\tpublic AbstractMetamodelDeclaration findDefaultMetamodel(Grammar grammar, String containedClassifier) {\n\t\treturn findMetamodel(grammar, \"\", containedClassifier);\n\t}\n\tpublic AbstractMetamodelDeclaration findMetamodel(Grammar grammar, String alias, String containedClassifier) {\n\t\tfinal List<AbstractMetamodelDeclaration> declarations = grammar.getMetamodelDeclarations();\n\t\tAbstractMetamodelDeclaration result = null;\n\t\tfor (AbstractMetamodelDeclaration decl : declarations) {\n\t\t\tif (isSameAlias(decl.getAlias(), alias)) {\n\t\t\t\tEPackage pack = decl.getEPackage();\n\t\t\t\tif (pack != null && pack.getEClassifier(containedClassifier) != null) {\n\t\t\t\t\tif (result != null)\n\t\t\t\t\t\treturn null;\n\t\t\t\t\tresult = decl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tpublic boolean isSameAlias(String alias, String alias2) {\n\t\treturn Strings.isEmpty(alias) ? Strings.isEmpty(alias2) : alias.equals(alias2);\n\t}\n\tprivate void normalizeAndValidateGeneratedPackages() {\n\t\tfinal TypeHierarchyHelper helper = new TypeHierarchyHelper(grammar, this.eClassifierInfos, this.errorAcceptor);\n\t\thelper.liftUpFeaturesRecursively();\n\t\thelper.removeDuplicateDerivedFeatures();\n\t}\n\tprivate void deriveTypesAndHierarchy(final ParserRule rule, final EClassifierInfo ruleReturnType,\n\t\t\tAbstractElement element) throws TransformationException {\n\t\tTransformationException ex = new XtextSwitch<TransformationException>() {\n\t\t\tSet<AbstractRule> visiting = Sets.newHashSet();\n\t\t\t@Override\n\t\t\tpublic TransformationException caseAction(Action action) {\n\t\t\t\tfinal TypeRef actionTypeRef = action.getType();\n\t\t\t\ttry {\n\t\t\t\t\taddSuperType(rule, actionTypeRef, ruleReturnType);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tcatch (TransformationException ex) {\n\t\t\t\t\treturn ex;\n\t\t\t\t}\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic TransformationException caseCompoundElement(CompoundElement object) {\n\t\t\t\tfor (AbstractElement ele : object.getElements()) {\n\t\t\t\t\tTransformationException ex = doSwitch(ele);\n\t\t\t\t\tif (ex != null) {\n\t\t\t\t\t\treturn ex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic TransformationException caseRuleCall(RuleCall ruleCall) {\n\t\t\t\tfinal AbstractRule calledRule = ruleCall.getRule();\n\t\t\t\tif (calledRule == null) {\n\t\t\t\t\tICompositeNode node = NodeModelUtils.getNode(ruleCall);\n\t\t\t\t\tif (node != null)\n\t\t\t\t\t\treturn new TransformationException(TransformationErrorCode.NoSuchRuleAvailable,\n\t\t\t\t\t\t\t\t\"Cannot find rule \" + node.getText().trim(), ruleCall);\n\t\t\t\t\treturn new TransformationException(TransformationErrorCode.NoSuchRuleAvailable,\n\t\t\t\t\t\t\t\"Cannot find called rule.\", ruleCall);\n\t\t\t\t}\n\t\t\t\tif (calledRule instanceof TerminalRule ||\n\t\t\t\t\t\tcalledRule instanceof ParserRule && (GrammarUtil.isDatatypeRule((ParserRule) calledRule))\n\t\t\t\t\t\t|| isWildcardFragment(calledRule))\n\t\t\t\t\treturn null;\n\t\t\t\tif (calledRule instanceof EnumRule) {\n\t\t\t\t\treturn new TransformationException(TransformationErrorCode.NoSuchRuleAvailable,\n\t\t\t\t\t\t\t\"Cannot call enum rule without assignment.\", ruleCall);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tif (isParserRuleFragment(calledRule)) {\n\t\t\t\t\t\tTypeRef subTypeRef = getOrComputeReturnType(rule);\n\t\t\t\t\t\taddSuperType(rule, subTypeRef, findOrCreateEClassifierInfo(calledRule));\n\t\t\t\t\t\tif (visiting.add(calledRule)) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tAbstractElement fragment = calledRule.getAlternatives();\n\t\t\t\t\t\t\t\tif (fragment != null) {\n\t\t\t\t\t\t\t\t\tdoSwitch(fragment);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\tvisiting.remove(calledRule);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfinal TypeRef calledRuleReturnTypeRef = getOrComputeReturnType(calledRule);\n\t\t\t\t\t\taddSuperType(rule, calledRuleReturnTypeRef, ruleReturnType);\n\t\t\t\t\t}\n\t\t\t\t} catch (TransformationException ex) {\n\t\t\t\t\treturn ex;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic TransformationException defaultCase(EObject object) {\n\t\t\t\t// ignore\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}.doSwitch(element);\n\t\tif (ex != null)\n\t\t\tthrow ex;\n\t\tfor (Grammar usedGrammar: grammar.getUsedGrammars()) {\n\t\t\tif (deriveTypeHierarchyFromOverridden(rule, usedGrammar))\n\t\t\t\treturn;\n\t\t}\n\t}\n<fim_suffix>\tprivate boolean deriveTypeHierarchyFromOverridden(ParserRule rule, Grammar grammar) throws TransformationException {\n\t\tAbstractRule parentRule = GrammarUtil.findRuleForName(grammar, rule.getName());\n\t\tif (parentRule != null) {\n\t\t\tif (parentRule != rule && parentRule instanceof ParserRule) {\n\t\t\t\tParserRule casted = (ParserRule) parentRule;\n\t\t\t\tif (casted.isFragment() != rule.isFragment()) {\n\t\t\t\t\tif (rule.isFragment()) {\n\t\t\t\t\t\tthrow new TransformationException(TransformationErrorCode.InvalidFragmentOverride,\n\t\t\t\t\t\t\t\t\"A fragment rule cannot override a production rule.\", rule);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new TransformationException(TransformationErrorCode.InvalidFragmentOverride,\n\t\t\t\t\t\t\t\t\"Only fragment rule can override other fragment rules.\", rule);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (casted.isWildcard() != rule.isWildcard()) {\n\t\t\t\t\tif (rule.isWildcard()) {\n\t\t\t\t\t\tthrow new TransformationException(TransformationErrorCode.InvalidFragmentOverride,\n\t\t\t\t\t\t\t\t\"A wildcard fragment rule cannot override a typed fragment rule.\", rule);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new TransformationException(TransformationErrorCode.InvalidFragmentOverride,\n\t\t\t\t\t\t\t\t\"Only wildcard fragment rules can override other wildcard fragments.\", rule);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (rule.isFragment() && !rule.isWildcard() && parentRule.getType() != null) {\n\t\t\t\t\tif (rule.getType().getClassifier() != parentRule.getType().getClassifier()) {\n\t\t\t\t\t\tthrow new TransformationException(TransformationErrorCode.InvalidFragmentOverride,\n\t\t\t\t\t\t\t\t\"Overriding fragment rules cannot redeclare their type.\", rule.getType());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcheckParameterLists(rule, casted);\n\t\t\t}\n\t\t\tif (parentRule.getType() != null && parentRule != rule) {\t\t\t\n\t\t\t\tif (parentRule.getType().getClassifier() instanceof EDataType)\n\t\t\t\t\tthrow new TransformationException(TransformationErrorCode.InvalidSupertype,\n\t\t\t\t\t\t\t\"Cannot inherit from datatype rule and return another type.\", rule.getType());\n\t\t\t\tEClassifierInfo parentTypeInfo = eClassifierInfos.getInfoOrNull(parentRule.getType());\n\t\t\t\tif (parentTypeInfo == null)\n\t\t\t\t\tthrow new TransformationException(TransformationErrorCode.InvalidSupertype,\n\t\t\t\t\t\t\t\"Cannot determine return type of overridden rule.\", rule.getType());\n\t\t\t\taddSuperType(rule, rule.getType(), parentTypeInfo);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}<fim_middle>// function below is long method\n"}