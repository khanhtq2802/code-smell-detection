{"text": "<fim_prefix>/****************************************************************\n * Licensed to the Apache Software Foundation (ASF) under one   *\n * or more contributor license agreements.  See the NOTICE file *\n * distributed with this work for additional information        *\n * regarding copyright ownership.  The ASF licenses this file   *\n * to you under the Apache License, Version 2.0 (the            *\n * \"License\"); you may not use this file except in compliance   *\n * with the License.  You may obtain a copy of the License at   *\n *                                                              *\n *   http://www.apache.org/licenses/LICENSE-2.0                 *\n *                                                              *\n * Unless required by applicable law or agreed to in writing,   *\n * software distributed under the License is distributed on an  *\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *\n * KIND, either express or implied.  See the License for the    *\n * specific language governing permissions and limitations      *\n * under the License.                                           *\n ****************************************************************/\npackage org.apache.james.mailbox.elasticsearch.query;\nimport static org.apache.james.backends.es.NodeMappingFactory.RAW;\nimport static org.apache.james.backends.es.NodeMappingFactory.SPLIT_EMAIL;\nimport static org.elasticsearch.index.query.QueryBuilders.boolQuery;\nimport static org.elasticsearch.index.query.QueryBuilders.existsQuery;\nimport static org.elasticsearch.index.query.QueryBuilders.matchAllQuery;\nimport static org.elasticsearch.index.query.QueryBuilders.matchQuery;\nimport static org.elasticsearch.index.query.QueryBuilders.nestedQuery;\nimport static org.elasticsearch.index.query.QueryBuilders.rangeQuery;\nimport static org.elasticsearch.index.query.QueryBuilders.termQuery;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.stream.Collector;\nimport java.util.stream.Stream;\nimport javax.mail.Flags;\nimport org.apache.james.mailbox.elasticsearch.json.HeaderCollection;\nimport org.apache.james.mailbox.elasticsearch.json.JsonMessageConstants;\nimport org.apache.james.mailbox.model.SearchQuery;\nimport org.apache.james.mailbox.model.SearchQuery.Criterion;\nimport org.apache.james.mailbox.model.SearchQuery.HeaderOperator;\nimport org.elasticsearch.index.query.BoolQueryBuilder;\nimport org.elasticsearch.index.query.QueryBuilder;\nimport org.elasticsearch.index.query.QueryBuilders;\npublic class CriterionConverter {\n    private final Map<Class<?>, Function<SearchQuery.Criterion, QueryBuilder>> criterionConverterMap;\n    private final Map<Class<?>, BiFunction<String, SearchQuery.HeaderOperator, QueryBuilder>> headerOperatorConverterMap;\n    public CriterionConverter() {\n        criterionConverterMap = new HashMap<>();\n        headerOperatorConverterMap = new HashMap<>();\n        registerCriterionConverters();\n        registerHeaderOperatorConverters();\n    }\n    private void registerCriterionConverters() {\n        registerCriterionConverter(SearchQuery.FlagCriterion.class, this::convertFlag);\n        registerCriterionConverter(SearchQuery.UidCriterion.class, this::convertUid);\n        registerCriterionConverter(SearchQuery.ConjunctionCriterion.class, this::convertConjunction);\n        registerCriterionConverter(SearchQuery.HeaderCriterion.class, this::convertHeader);\n        registerCriterionConverter(SearchQuery.TextCriterion.class, this::convertTextCriterion);\n        registerCriterionConverter(SearchQuery.CustomFlagCriterion.class, this::convertCustomFlagCriterion);\n        registerCriterionConverter(SearchQuery.AllCriterion.class,\n            criterion -> matchAllQuery());\n        registerCriterionConverter(SearchQuery.ModSeqCriterion.class,\n            criterion -> createNumericFilter(JsonMessageConstants.MODSEQ, criterion.getOperator()));\n        registerCriterionConverter(SearchQuery.SizeCriterion.class,\n            criterion -> createNumericFilter(JsonMessageConstants.SIZE, criterion.getOperator()));\n        registerCriterionConverter(SearchQuery.InternalDateCriterion.class,\n            criterion -> dateRangeFilter(JsonMessageConstants.DATE, criterion.getOperator()));\n        registerCriterionConverter(SearchQuery.AttachmentCriterion.class, this::convertAttachmentCriterion);\n        registerCriterionConverter(SearchQuery.MimeMessageIDCriterion.class, this::convertMimeMessageIDCriterion);\n    }\n    @SuppressWarnings(\"unchecked\")\n    private <T extends Criterion> void registerCriterionConverter(Class<T> type, Function<T, QueryBuilder> f) {\n        criterionConverterMap.put(type, (Function<Criterion, QueryBuilder>) f);\n    }\n    private void registerHeaderOperatorConverters() {\n        registerHeaderOperatorConverter(\n            SearchQuery.ExistsOperator.class,\n            (headerName, operator) ->\n                existsQuery(JsonMessageConstants.HEADERS + \".\" + headerName));\n        registerHeaderOperatorConverter(\n            SearchQuery.AddressOperator.class,\n            (headerName, operator) -> manageAddressFields(headerName, operator.getAddress()));\n        registerHeaderOperatorConverter(\n            SearchQuery.DateOperator.class,\n            (headerName, operator) -> dateRangeFilter(JsonMessageConstants.SENT_DATE, operator));\n        registerHeaderOperatorConverter(\n            SearchQuery.ContainsOperator.class,\n            (headerName, operator) -> matchQuery(JsonMessageConstants.HEADERS + \".\" + headerName,\n                    operator.getValue()));\n    }\n    @SuppressWarnings(\"unchecked\")\n    private <T extends HeaderOperator> void registerHeaderOperatorConverter(Class<T> type, BiFunction<String, T, QueryBuilder> f) {\n        headerOperatorConverterMap.put(type, (BiFunction<String, HeaderOperator, QueryBuilder>) f);\n    }\n    public QueryBuilder convertCriterion(SearchQuery.Criterion criterion) {\n        return criterionConverterMap.get(criterion.getClass()).apply(criterion);\n    }\n    private QueryBuilder convertAttachmentCriterion(SearchQuery.AttachmentCriterion criterion) {\n        return termQuery(JsonMessageConstants.HAS_ATTACHMENT, criterion.getOperator().isSet());\n    }\n    private QueryBuilder convertMimeMessageIDCriterion(SearchQuery.MimeMessageIDCriterion criterion) {\n        return termQuery(JsonMessageConstants.MIME_MESSAGE_ID, criterion.getMessageID());\n    }\n<fim_suffix>    private QueryBuilder convertCustomFlagCriterion(SearchQuery.CustomFlagCriterion criterion) {\n        QueryBuilder termQueryBuilder = termQuery(JsonMessageConstants.USER_FLAGS, criterion.getFlag());\n        if (criterion.getOperator().isSet()) {\n            return termQueryBuilder;\n        } else {\n            return boolQuery().mustNot(termQueryBuilder);\n        }\n    }\n    private QueryBuilder convertTextCriterion(SearchQuery.TextCriterion textCriterion) {\n        switch (textCriterion.getType()) {\n        case BODY:\n            return boolQuery()\n                    .should(matchQuery(JsonMessageConstants.TEXT_BODY, textCriterion.getOperator().getValue()))\n                    .should(matchQuery(JsonMessageConstants.TEXT_BODY + \".\" + SPLIT_EMAIL,\n                        textCriterion.getOperator().getValue()))\n                    .should(matchQuery(JsonMessageConstants.HTML_BODY + \".\" + SPLIT_EMAIL,\n                        textCriterion.getOperator().getValue()))\n                    .should(matchQuery(JsonMessageConstants.HTML_BODY, textCriterion.getOperator().getValue()));\n        case TEXT:\n            return boolQuery()\n                    .should(matchQuery(JsonMessageConstants.TEXT, textCriterion.getOperator().getValue()))\n                    .should(matchQuery(JsonMessageConstants.TEXT + \".\" + SPLIT_EMAIL,\n                        textCriterion.getOperator().getValue()));\n        case FULL:\n            return boolQuery()\n                    .should(matchQuery(JsonMessageConstants.TEXT_BODY, textCriterion.getOperator().getValue()))\n                    .should(matchQuery(JsonMessageConstants.TEXT_BODY + \".\" + SPLIT_EMAIL,\n                        textCriterion.getOperator().getValue()))\n                    .should(matchQuery(JsonMessageConstants.HTML_BODY + \".\" + SPLIT_EMAIL,\n                        textCriterion.getOperator().getValue()))\n                    .should(matchQuery(JsonMessageConstants.HTML_BODY, textCriterion.getOperator().getValue()))\n                    .should(matchQuery(JsonMessageConstants.HTML_BODY, textCriterion.getOperator().getValue()))\n                    .should(matchQuery(JsonMessageConstants.ATTACHMENTS + \".\" + JsonMessageConstants.Attachment.TEXT_CONTENT,\n                        textCriterion.getOperator().getValue()));\n        case ATTACHMENTS:\n            return boolQuery()\n                    .should(matchQuery(JsonMessageConstants.ATTACHMENTS + \".\" + JsonMessageConstants.Attachment.TEXT_CONTENT,\n                        textCriterion.getOperator().getValue()));\n        case ATTACHMENT_FILE_NAME:\n            return boolQuery()\n                .should(termQuery(JsonMessageConstants.ATTACHMENTS + \".\" + JsonMessageConstants.Attachment.FILENAME,\n                    textCriterion.getOperator().getValue()));\n        }\n        throw new RuntimeException(\"Unknown SCOPE for text criterion\");\n    }\n    private QueryBuilder dateRangeFilter(String field, SearchQuery.DateOperator dateOperator) {\n        return boolQuery().filter(\n            convertDateOperator(field,\n                dateOperator.getType(),\n                DateResolutionFormater.DATE_TIME_FOMATTER.format(\n                    DateResolutionFormater.computeLowerDate(\n                        DateResolutionFormater.convertDateToZonedDateTime(dateOperator.getDate()),\n                        dateOperator.getDateResultion())),<fim_middle>// function below is feature envy\n"}