{"text": "<fim_prefix>\t\t\t\tnextChar();\n\t\t\t\tif (current != ':')\n\t\t\t\t\treturn ':';\n\t\t\t\telse {\n\t\t\t\t\tnextChar();\n\t\t\t\t\treturn TK_DBCOLON;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase '\"':\n\t\t\tcase '\\'': {\n\t\t\t\tread_string(current, seminfo);\n\t\t\t\treturn TK_STRING;\n\t\t\t}\n\t\t\tcase '.': {\n\t\t\t\tsave_and_next();\n\t\t\t\tif (check_next(\".\")) {\n\t\t\t\t\tif (check_next(\".\"))\n\t\t\t\t\t\treturn TK_DOTS; /* ... */\n\t\t\t\t\telse\n\t\t\t\t\t\treturn TK_CONCAT; /* .. */\n\t\t\t\t} else if (!isdigit(current))\n\t\t\t\t\treturn '.';\n\t\t\t\telse {\n\t\t\t\t\tread_numeral(seminfo);\n\t\t\t\t\treturn TK_NUMBER;\n\t\t\t\t}\n\t\t\t}\n\t\t    case '0': case '1': case '2': case '3': case '4':\n\t\t    case '5': case '6': case '7': case '8': case '9': {\n\t\t        read_numeral(seminfo);\n\t\t        return TK_NUMBER;\n\t\t    }\n\t\t \tcase EOZ: {\n\t\t\t\treturn TK_EOS;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tif (isspace(current)) {\n\t\t\t\t\t_assert (!currIsNewline());\n\t\t\t\t\tnextChar();\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (isdigit(current)) {\n\t\t\t\t\tread_numeral(seminfo);\n\t\t\t\t\treturn TK_NUMBER;\n\t\t\t\t} else if (isalpha(current) || current == '_') {\n\t\t\t\t\t/* identifier or reserved word */\n\t\t\t\t\tLuaString ts;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tsave_and_next();\n\t\t\t\t\t} while (isalnum(current) || current == '_');\n\t\t\t\t\tts = newstring(buff, 0, nbuff);\n\t\t\t\t\tif ( RESERVED.containsKey(ts) )\n\t\t\t\t\t\treturn ((Integer)RESERVED.get(ts)).intValue();\n\t\t\t\t\telse {\n\t\t\t\t\t\tseminfo.ts = ts;\n\t\t\t\t\t\treturn TK_NAME;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tint c = current;\n\t\t\t\t\tnextChar();\n\t\t\t\t\treturn c; /* single-char tokens (+ - / ...) */\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvoid next() {\n\t\tlastline = linenumber;\n\t\tif (lookahead.token != TK_EOS) { /* is there a look-ahead token? */\n\t\t\tt.set( lookahead ); /* use this one */\n\t\t\tlookahead.token = TK_EOS; /* and discharge it */\n\t\t} else\n\t\t\tt.token = llex(t.seminfo); /* read next token */\n\t}\n\tvoid lookahead() {\n\t\t_assert (lookahead.token == TK_EOS);\n\t\tlookahead.token = llex(lookahead.seminfo);\n\t}\n\t// =============================================================\n\t// from lcode.h\n\t// =============================================================\n\t// =============================================================\n\t// from lparser.c\n\t// =============================================================\n\tstatic final boolean vkisvar(final int k) {\n\t\treturn (VLOCAL <= (k) && (k) <= VINDEXED);\n\t}\n\tstatic final boolean vkisinreg(final int k) {\n\t\treturn ((k) == VNONRELOC || (k) == VLOCAL);\n\t}\n\tstatic class expdesc {\n\t\tint k; // expkind, from enumerated list, above\n\t\tstatic class U { // originally a union\n\t\t\tshort ind_idx; // index (R/K)\n\t\t\tshort ind_t; // table(register or upvalue)\n\t\t\tshort ind_vt; // whether 't' is register (VLOCAL) or (UPVALUE)\n\t\t\tprivate LuaValue _nval;\n\t\t\tint info;\n\t\t\tpublic void setNval(LuaValue r) {\n\t\t\t\t_nval = r;\n\t\t\t}\n\t\t\tpublic LuaValue nval() {\n\t\t\t\treturn (_nval == null? LuaInteger.valueOf(info): _nval);\n\t\t\t}\n\t\t};\n\t\tfinal U u = new U();\n\t\tfinal IntPtr t = new IntPtr(); /* patch list of `exit when true' */\n\t\tfinal IntPtr f = new IntPtr(); /* patch list of `exit when false' */\n\t\tvoid init( int k, int i ) {\n\t\t\tthis.f.i = NO_JUMP;\n\t\t\tthis.t.i = NO_JUMP;\n\t\t\tthis.k = k;\n\t\t\tthis.u.info = i;\n\t\t}\n\t\tboolean hasjumps() {\n\t\t\treturn (t.i != f.i);\n\t\t}\n\t\tboolean isnumeral() {\n\t\t\treturn (k == VKNUM && t.i == NO_JUMP && f.i == NO_JUMP);\n\t\t}\n\t\tpublic void setvalue(expdesc other) {\n\t\t\tthis.f.i = other.f.i;\n\t\t\tthis.k = other.k;\n\t\t\tthis.t.i = other.t.i;\n\t\t\tthis.u._nval = other.u._nval;\n\t\t\tthis.u.ind_idx = other.u.ind_idx;\n\t\t\tthis.u.ind_t = other.u.ind_t;\n\t\t\tthis.u.ind_vt = other.u.ind_vt;\n\t\t\tthis.u.info = other.u.info;\n\t\t}\n\t}\n\t/* description of active local variable */\n\tstatic class Vardesc {\n\t\tfinal short idx;  /* variable index in stack */\n\t\tVardesc(int idx) {\n\t\t\tthis.idx = (short) idx;\n\t\t}\n\t};\n\t/* description of pending goto statements and label statements */\n\tstatic class Labeldesc {\n\t\tLuaString name;  /* label identifier */\n\t\tint pc;  /* position in code */\n\t\tint line;  /* line where it appeared */\n\t\tshort nactvar;  /* local level where it appears in current block */\n\t\tpublic Labeldesc(LuaString name, int pc, int line, short nactvar) {\n\t\t\tthis.name = name;\n\t\t\tthis.pc = pc;\n\t\t\tthis.line = line;\n\t\t\tthis.nactvar = nactvar;\n\t\t}\n\t};\n\t/* dynamic structures used by the parser */\n\tstatic class Dyndata {\n\t\tVardesc[] actvar;  /* list of active local variables */ \n\t\tint n_actvar = 0;\n\t\tLabeldesc[] gt;  /* list of pending gotos */\n\t\tint n_gt = 0;\n\t\tLabeldesc[] label;   /* list of active labels */\n\t\tint n_label = 0;\n\t};\n\tboolean hasmultret(int k) {\n\t\treturn ((k) == VCALL || (k) == VVARARG);\n\t}\n\t/*----------------------------------------------------------------------\n\tname\t\targs\tdescription\n\t------------------------------------------------------------------------*/\n\tvoid anchor_token () {\n\t\t/* last token from outer function must be EOS */\n\t\t_assert(fs != null || t.token == TK_EOS);\n\t\tif (t.token == TK_NAME || t.token == TK_STRING) {\n\t\t\tLuaString ts = t.seminfo.ts;\n\t\t\t// TODO: is this necessary?\n\t\t\tL.cachedLuaString(t.seminfo.ts);\n\t\t}\n\t}\n\t/* semantic error */\n\tvoid semerror (String msg) {\n\t\tt.token = 0;  /* remove 'near to' from final message */\n\t\tsyntaxerror(msg);\n\t}\n\tvoid error_expected(int token) {\n\t\tsyntaxerror(L.pushfstring(LUA_QS(token2str(token)) + \" expected\"));\n\t}\n<fim_suffix>\tboolean testnext(int c) {\n\t\tif (t.token == c) {\n\t\t\tnext();\n\t\t\treturn true;\n\t\t} else\n\t\t\treturn false;\n\t}<fim_middle>// function below has no smell\n"}