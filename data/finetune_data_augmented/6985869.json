{"text": "<fim_prefix>/*\n * Copyright 2015 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage com.google.j2cl.ast;\n\nimport static com.google.common.base.Preconditions.checkState;\n\nimport com.google.auto.value.AutoValue;\nimport com.google.auto.value.extension.memoized.Memoized;\nimport com.google.j2cl.ast.annotations.Visitable;\nimport com.google.j2cl.common.ThreadLocalInterner;\nimport java.util.Optional;\nimport javax.annotation.Nullable;\n\n/** A (by signature) reference to a field. */\n@AutoValue\n@Visitable\npublic abstract class FieldDescriptor extends MemberDescriptor {\n\n  public abstract TypeDescriptor getTypeDescriptor();\n\n  public abstract boolean isCompileTimeConstant();\n\n  public abstract boolean isEnumConstant();\n\n  public abstract boolean isVariableCapture();\n\n  public abstract boolean isEnclosingInstanceCapture();\n\n  public abstract boolean isDeprecated();\n\n  @Override\n  public abstract FieldOrigin getOrigin();\n\n  /** Whether this field originates in the source code or is synthetic. */\n  public enum FieldOrigin implements MemberDescriptor.Origin {\n    SOURCE,\n    SYNTHETIC_BACKING_FIELD(\"$\"),\n    SYNTHETIC_ORDINAL_FIELD(\"$ordinal$\");\n\n    private final String prefix;\n\n    FieldOrigin() {\n      this(\"\");\n    }\n\n    FieldOrigin(String prefix) {\n      this.prefix = prefix;\n    }\n\n    @Override\n    public String getPrefix() {\n      return prefix;\n    }\n  }\n\n  /**\n   * Returns the descriptor of the field declaration. A field descriptor might describe a\n   * specialized version of a field, e.g.\n   *\n   * <p>\n   *\n   * <pre>\n   *   class A<T> {\n   *     T f;  // Field declaration described as a field \"A.f\" with type \"T\".\n   *   }\n   *\n   *   // Field access with field descriptor for field \"A.f\" with type \"String\" that has a\n   *   // declaration descriptor for field \"A.f\" but with type \"T\". Note that both descriptors refer\n   *   // to the same field \"A.f\".\n   *   new A<String>().f;\n   * <p>\n   * </pre>\n   */\n  @Override\n  public FieldDescriptor getDeclarationDescriptor() {\n    return getDeclarationFieldDescriptorOrNullIfSelf() == null\n        ? this\n        : getDeclarationFieldDescriptorOrNullIfSelf();\n  }\n\n  @Nullable\n  // A field declaration can be itself but AutoValue does not allow for a property to be a\n  // reference to the value object being created, so we use a backing nullable property where null\n  // encodes a self reference for AutoValue purposes and provide the accessor above to hide\n  // the details.\n  abstract FieldDescriptor getDeclarationFieldDescriptorOrNullIfSelf();\n\n  @Override\n  @Memoized\n  public FieldDescriptor toRawMemberDescriptor() {\n    return toBuilder()\n        .setEnclosingTypeDescriptor(getEnclosingTypeDescriptor().toRawTypeDescriptor())\n        .setTypeDescriptor(getTypeDescriptor().toRawTypeDescriptor())\n        .build();\n  }\n\n  @Override\n  public boolean isNative() {\n    return getEnclosingTypeDescriptor().isNative() && !isJsOverlay();\n  }\n\n  public boolean isCapture() {\n    return isVariableCapture() || isEnclosingInstanceCapture();\n  }\n\n  public boolean isJsProperty() {\n    return getJsInfo().getJsMemberType() == JsMemberType.PROPERTY;\n  }\n\n  @Override\n  public boolean isPolymorphic() {\n    return !isStatic();\n  }\n\n  @Override\n  public boolean isJsFunction() {\n    return false;\n  }\n\n  @Override\n  public boolean isField() {\n    return true;\n  }\n\n  @Override\n  public boolean isSameMember(MemberDescriptor thatMember) {\n    // TODO(b/69130180): Ideally isSameMember should be not be overridden here and use the\n    // implementation in MemberDescriptor, which relies in comparing the declarations directly.\n    // The current codebase does not enforce the invariant and sometimes references to the same\n    // member end up with different declarations.\n    if (!(thatMember instanceof FieldDescriptor)) {\n      return false;\n    }\n\n    if (!inSameTypeAs(thatMember)) {\n      return false;\n    }\n\n    FieldDescriptor thisField = this.getDeclarationDescriptor();\n    FieldDescriptor thatField = (FieldDescriptor) thatMember.getDeclarationDescriptor();\n    return thisField.getName().equals(thatField.getName());\n  }\n\n  @Override\n  public Node accept(Processor processor) {\n    return Visitor_FieldDescriptor.visit(processor, this);\n  }\n\n  abstract Builder toBuilder();\n\n  @Override\n  @Memoized\n  public String getBinaryName() {\n    return getName();\n  }\n\n  public static Builder newBuilder() {\n    return new AutoValue_FieldDescriptor.Builder()\n        // Default values.\n        .setVisibility(Visibility.PUBLIC)\n        .setJsInfo(JsInfo.NONE)\n        .setCompileTimeConstant(false)\n        .setStatic(false)\n        .setFinal(false)\n        .setVariableCapture(false)\n        .setEnclosingInstanceCapture(false)\n        .setSynthetic(false)\n        .setUnusableByJsSuppressed(false)\n        .setDeprecated(false)\n        .setEnumConstant(false)\n        .setOrigin(FieldOrigin.SOURCE);\n  }\n\n  /** Returns a description that is useful for error messages. */\n  @Override\n  public String getReadableDescription() {\n    return String.format(\"%s.%s\", getEnclosingTypeDescriptor().getReadableDescription(), getName());\n  }\n\n  /** A Builder for FieldDescriptors. */\n<fim_suffix>  @AutoValue.Builder\n  public abstract static class Builder {\n    public abstract Builder setCompileTimeConstant(boolean compileTimeConstant);\n\n    public abstract Builder setStatic(boolean isStatic);\n\n    public abstract Builder setFinal(boolean isFinal);\n\n    public abstract Builder setVariableCapture(boolean isVariableCapture);\n\n    public abstract Builder setEnclosingInstanceCapture(boolean isEnclosingInstanceCapture);\n\n    public abstract Builder setEnclosingTypeDescriptor(\n        DeclaredTypeDescriptor enclosingTypeDescriptor);\n\n    public abstract Builder setName(String name);\n\n    public abstract Builder setEnumConstant(boolean isEnumConstant);\n\n    public abstract Builder setSynthetic(boolean isSynthetic);\n\n    public abstract Builder setTypeDescriptor(TypeDescriptor typeDescriptor);\n\n    public abstract Builder setVisibility(Visibility visibility);\n\n    public abstract Builder setJsInfo(JsInfo jsInfo);\n\n    public abstract Builder setUnusableByJsSuppressed(boolean isUnusableByJsSuppressed);\n\n    public abstract Builder setDeprecated(boolean isDeprecated);\n\n    public abstract Builder setOrigin(FieldOrigin fieldOrigin);\n\n    public Builder setDeclarationFieldDescriptor(FieldDescriptor declarationFieldDescriptor) {\n      return setDeclarationFieldDescriptorOrNullIfSelf(declarationFieldDescriptor);\n    }\n\n    // Accessors to support validation, default construction and custom setters.\n    abstract Builder setDeclarationFieldDescriptorOrNullIfSelf(\n        FieldDescriptor declarationFieldDescriptor);\n\n    abstract Optional<String> getName();\n\n    abstract FieldDescriptor autoBuild();\n\n    public FieldDescriptor build() {\n      checkState(getName().isPresent());\n      FieldDescriptor fieldDescriptor = autoBuild();\n\n      checkState(\n          !fieldDescriptor.isVariableCapture() || !fieldDescriptor.isEnclosingInstanceCapture());\n\n      return interner.intern(fieldDescriptor);\n    }\n\n    public static Builder from(FieldDescriptor fieldDescriptor) {\n      return fieldDescriptor.toBuilder();\n    }\n\n    private static final ThreadLocalInterner<FieldDescriptor> interner =\n        new ThreadLocalInterner<>();\n  }\n}<fim_middle>// class below has no smell\n"}