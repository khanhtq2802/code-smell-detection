{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.openejb.loader;\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.Flushable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.Proxy;\nimport java.net.ProxySelector;\nimport java.net.URI;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Properties;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.zip.ZipInputStream;\nimport java.util.zip.ZipOutputStream;\n/**\n * @version $Revision$ $Date$\n *          <p/>\n *          NOTE: CHECK ExecMojo before adding dependency or inner class to it please\n */\npublic class IO {\n    private static final int MAX_TIMEOUT;\n    static {\n        int timeout = 5000;\n        try {\n            timeout = SystemInstance.isInitialized() ?\n                    SystemInstance.get().getOptions().get(\"openejb.io.util.timeout\", timeout) :\n                    Integer.getInteger(\"openejb.io.util.timeout\", timeout);\n        } catch (final Throwable th) {\n            // no-op: see ExecMojo\n        }\n        MAX_TIMEOUT = timeout;\n    }\n    public static String readFileAsString(final URI uri) throws IOException {\n        final StringBuilder builder = new StringBuilder(\"\");\n        for (final Proxy proxy : ProxySelector.getDefault().select(uri)) {\n            final InputStream is;\n            try {\n                final URLConnection urlConnection = uri.toURL().openConnection(proxy);\n                urlConnection.setConnectTimeout(MAX_TIMEOUT);\n                is = urlConnection.getInputStream();\n            } catch (final IOException e) {\n                continue;\n            }\n            String line;\n            try {\n                final BufferedReader reader = new BufferedReader(new InputStreamReader(is));\n                while ((line = reader.readLine()) != null) {\n                    builder.append(line);\n                }\n            } finally {\n                close(is);\n            }\n        }\n        return builder.toString();\n    }\n    public static Properties readProperties(final URL resource) throws IOException {\n        return readProperties(resource, new Properties());\n    }\n    public static Properties readProperties(final URL resource, final Properties properties) throws IOException {\n        return readProperties(read(resource), properties);\n    }\n    public static Properties readProperties(final File resource) throws IOException {\n        return readProperties(resource, new Properties());\n    }\n    public static Properties readProperties(final File resource, final Properties properties) throws IOException {\n        return readProperties(read(resource), properties);\n    }\n    public static Properties readProperties(final InputStream in, final Properties properties) throws IOException {\n        if (in == null) {\n            throw new NullPointerException(\"InputStream is null\");\n        }\n        if (properties == null) {\n            throw new NullPointerException(\"Properties is null\");\n        }\n        try {\n            properties.load(in);\n        } finally {\n            close(in);\n        }\n        return properties;\n    }\n    public static String readString(final URL url) throws IOException {\n        final InputStream in = url.openStream();\n        try {\n            final BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n            return reader.readLine();\n        } finally {\n            close(in);\n        }\n    }\n    public static String readString(final File file) throws IOException {\n        final FileReader in = new FileReader(file);\n        try {\n            final BufferedReader reader = new BufferedReader(in);\n            return reader.readLine();\n        } finally {\n            close(in);\n        }\n    }\n    public static String slurp(final File file) throws IOException {\n        try (final InputStream is = read(file)) {\n            return slurp(is);\n        }\n    }\n    public static String slurp(final URL url) throws IOException {\n        return slurp(url.openStream());\n    }\n    public static String slurp(final InputStream in) throws IOException {\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        copy(in, out);\n        return new String(out.toByteArray());\n    }\n    public static void writeString(final File file, final String string) throws IOException {\n        final FileWriter out = new FileWriter(file);\n        try {\n            final BufferedWriter bufferedWriter = new BufferedWriter(out);\n            try {\n                bufferedWriter.write(string);\n                bufferedWriter.newLine();\n            } finally {\n                close(bufferedWriter);\n            }\n        } finally {\n            close(out);\n        }\n    }\n    public static void copy(final File from, final File to) throws IOException {\n        if (!from.isDirectory()) {\n            final FileOutputStream fos = new FileOutputStream(to);\n            try {\n                copy(from, fos);\n            } finally {\n                close(fos);\n            }\n        } else {\n            copyDirectory(from, to);\n        }\n    }\n<fim_suffix>    public static void copyDirectory(final File srcDir, final File destDir) throws IOException {\n        if (srcDir == null) {\n            throw new NullPointerException(\"Source must not be null\");\n        }\n        if (destDir == null) {\n            throw new NullPointerException(\"Destination must not be null\");\n        }\n        if (!srcDir.exists()) {\n            throw new FileNotFoundException(\"Source '\" + srcDir + \"' does not exist\");\n        }\n        if (!srcDir.isDirectory()) {\n            throw new IOException(\"Source '\" + srcDir + \"' exists but is not a directory\");\n        }\n        if (srcDir.getCanonicalPath().equals(destDir.getCanonicalPath())) {\n            throw new IOException(\"Source '\" + srcDir + \"' and destination '\" + destDir + \"' are the same\");\n        }\n        // Cater for destination being directory within the source directory (see IO-141)\n        List<String> exclusionList = null;\n        if (destDir.getCanonicalPath().startsWith(srcDir.getCanonicalPath())) {\n            final File[] srcFiles = srcDir.listFiles();\n            if (srcFiles != null && srcFiles.length > 0) {\n                exclusionList = new ArrayList<>(srcFiles.length);\n                for (final File srcFile : srcFiles) {\n                    final File copiedFile = new File(destDir, srcFile.getName());\n                    exclusionList.add(copiedFile.getCanonicalPath());\n                }\n            }\n        }\n        doCopyDirectory(srcDir, destDir, exclusionList);\n    }\n    private static void doCopyDirectory(final File srcDir, final File destDir, final List<String> exclusionList) throws IOException {\n        final File[] files = srcDir.listFiles();\n        if (files == null) {  // null if security restricted\n            throw new IOException(\"Failed to list contents of \" + srcDir);\n        }\n        if (destDir.exists()) {\n            if (!destDir.isDirectory()) {\n                throw new IOException(\"Destination '\" + destDir + \"' exists but is not a directory\");\n            }\n        } else {\n            if (!destDir.mkdirs()) {\n                throw new IOException(\"Destination '\" + destDir + \"' directory cannot be created\");\n            }\n        }\n        if (!destDir.canWrite()) {\n            throw new IOException(\"Destination '\" + destDir + \"' cannot be written to\");\n        }\n        for (final File file : files) {\n            final File copiedFile = new File(destDir, file.getName());\n            if (exclusionList == null || !exclusionList.contains(file.getCanonicalPath())) {\n                if (file.isDirectory()) {\n                    doCopyDirectory(file, copiedFile, exclusionList);\n                } else {\n                    copy(file, copiedFile);\n                }\n            }\n        }\n    }\n    public static void copy(final File from, final OutputStream to) throws IOException {\n        final InputStream read = read(from);\n        try {\n            copy(read, to);\n        } finally {\n            close(read);\n        }\n    }\n    public static void copy(final URL from, final OutputStream to) throws IOException {\n        final InputStream read = read(from);\n        try {\n            copy(read, to);\n        } finally {\n            close(read);\n        }\n    }<fim_middle>// function below is long method\n"}