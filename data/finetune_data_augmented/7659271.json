{"text": "<fim_prefix>/*\n * Copyright 2016 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.springframework.statemachine.support;\n\nimport java.util.Date;\nimport java.util.concurrent.TimeUnit;\n\nimport org.springframework.scheduling.Trigger;\nimport org.springframework.scheduling.TriggerContext;\nimport org.springframework.scheduling.support.PeriodicTrigger;\nimport org.springframework.util.Assert;\n\n/**\n * Enhanced implementation following same logic from {@link PeriodicTrigger}\n * except also adding a counter how many times a trigger can fire. If given\n * count is either zero on a negative value, counter functionality is disabled.\n *\n * @author Janne Valkealahti\n * @see PeriodicTrigger\n */\n<fim_suffix>public class CountTrigger implements Trigger {\n\n\tprivate final int count;\n\tprivate final long period;\n\tprivate final TimeUnit timeUnit;\n\tprivate volatile long initialDelay = 0;\n\tprivate volatile boolean fixedRate = false;\n\tprivate volatile int counter = 0;\n\n\t/**\n\t * Create a trigger with the given period in milliseconds and firing\n\t * exactly one time.\n\t *\n\t * @param period the period\n\t */\n\tpublic CountTrigger(long period) {\n\t\tthis(1, period, null);\n\t}\n\n\t/**\n\t * Create a trigger with the given count, period and time unit. The time unit will\n\t * apply not only to the period but also to any 'initialDelay' value, if\n\t * configured on this Trigger later via {@link #setInitialDelay(long)}.\n\t *\n\t * @param count the count\n\t * @param period the period\n\t * @param timeUnit the time unit\n\t */\n\tpublic CountTrigger(int count, long period, TimeUnit timeUnit) {\n\t\tthis(count, period, 0, timeUnit);\n\t}\n\n\t/**\n\t * Create a trigger with the given count, period and time unit. The time unit will\n\t * apply not only to the period but also to any 'initialDelay' value, if\n\t * configured on this Trigger later via {@link #setInitialDelay(long)}.\n\t *\n\t * @param count the count\n\t * @param period the period\n\t * @param timeUnit the time unit\n\t * @param initialDelay the initial delay\n\t */\n\tpublic CountTrigger(int count, long period, long initialDelay, TimeUnit timeUnit) {\n\t\tAssert.isTrue(period >= 0, \"period must not be negative\");\n\t\tAssert.isTrue(count >= 0, \"count must not be negative\");\n\t\tthis.timeUnit = (timeUnit != null ? timeUnit : TimeUnit.MILLISECONDS);\n\t\tthis.period = this.timeUnit.toMillis(period);\n\t\tthis.count = count;\n\t\tsetInitialDelay(initialDelay);\n\t}\n\n\t/**\n\t * Specify the delay for the initial execution. It will be evaluated in\n\t * terms of this trigger's {@link TimeUnit}. If no time unit was explicitly\n\t * provided upon instantiation, the default is milliseconds.\n\t *\n\t * @param initialDelay the new initial delay\n\t */\n\tpublic void setInitialDelay(long initialDelay) {\n\t\tthis.initialDelay = this.timeUnit.toMillis(initialDelay);\n\t}\n\n\t/**\n\t * Specify whether the periodic interval should be measured between the\n\t * scheduled start times rather than between actual completion times.\n\t * The latter, \"fixed delay\" behavior, is the default.\n\t *\n\t * @param fixedRate the new fixed rate\n\t */\n\tpublic void setFixedRate(boolean fixedRate) {\n\t\tthis.fixedRate = fixedRate;\n\t}\n\n\t@Override\n\tpublic Date nextExecutionTime(TriggerContext triggerContext) {\n\t\tif (count > 0) {\n\t\t\tif (++counter > count) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tif (triggerContext.lastScheduledExecutionTime() == null) {\n\t\t\treturn new Date(System.currentTimeMillis() + this.initialDelay);\n\t\t}\n\t\telse if (this.fixedRate) {\n\t\t\treturn new Date(triggerContext.lastScheduledExecutionTime().getTime() + this.period);\n\t\t}\n\t\treturn new Date(triggerContext.lastCompletionTime().getTime() + this.period);\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tresult = prime * result + count;\n\t\tresult = prime * result + (fixedRate ? 1231 : 1237);\n\t\tresult = prime * result + (int) (initialDelay ^ (initialDelay >>> 32));\n\t\tresult = prime * result + (int) (period ^ (period >>> 32));\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tCountTrigger other = (CountTrigger) obj;\n\t\tif (count != other.count)\n\t\t\treturn false;\n\t\tif (fixedRate != other.fixedRate)\n\t\t\treturn false;\n\t\tif (initialDelay != other.initialDelay)\n\t\t\treturn false;\n\t\tif (period != other.period)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n}<fim_middle>// class below has no smell\n"}