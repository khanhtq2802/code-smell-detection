{"text": "<fim_prefix>/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.collect;\n\nimport com.google.common.annotations.Beta;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.errorprone.annotations.CanIgnoreReturnValue;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\n/**\n * A list which forwards all its method calls to another list. Subclasses should override one or\n * more methods to modify the behavior of the backing list as desired per the <a\n * href=\"http://en.wikipedia.org/wiki/Decorator_pattern\">decorator pattern</a>.\n *\n * <p>This class does not implement {@link java.util.RandomAccess}. If the delegate supports random\n * access, the {@code ForwardingList} subclass should implement the {@code RandomAccess} interface.\n *\n * <p><b>Warning:</b> The methods of {@code ForwardingList} forward <b>indiscriminately</b> to the\n * methods of the delegate. For example, overriding {@link #add} alone <b>will not</b> change the\n * behavior of {@link #addAll}, which can lead to unexpected behavior. In this case, you should\n * override {@code addAll} as well, either providing your own implementation, or delegating to the\n * provided {@code standardAddAll} method.\n *\n * <p><b>{@code default} method warning:</b> This class does <i>not</i> forward calls to {@code\n * default} methods. Instead, it inherits their default implementations. When those implementations\n * invoke methods, they invoke methods on the {@code ForwardingList}.\n *\n * <p>The {@code standard} methods and any collection views they return are not guaranteed to be\n * thread-safe, even when all of the methods that they depend on are thread-safe.\n *\n * @author Mike Bostock\n * @author Louis Wasserman\n * @since 2.0\n */\n@GwtCompatible\npublic abstract class ForwardingList<E> extends ForwardingCollection<E> implements List<E> {\n  // TODO(lowasser): identify places where thread safety is actually lost\n\n  /** Constructor for use by subclasses. */\n  protected ForwardingList() {}\n\n  @Override\n  protected abstract List<E> delegate();\n\n  @Override\n  public void add(int index, E element) {\n    delegate().add(index, element);\n  }\n\n  @CanIgnoreReturnValue\n  @Override\n  public boolean addAll(int index, Collection<? extends E> elements) {\n    return delegate().addAll(index, elements);\n  }\n\n  @Override\n  public E get(int index) {\n    return delegate().get(index);\n  }\n\n  @Override\n  public int indexOf(Object element) {\n    return delegate().indexOf(element);\n  }\n\n  @Override\n  public int lastIndexOf(Object element) {\n    return delegate().lastIndexOf(element);\n  }\n\n  @Override\n  public ListIterator<E> listIterator() {\n    return delegate().listIterator();\n  }\n\n  @Override\n  public ListIterator<E> listIterator(int index) {\n    return delegate().listIterator(index);\n  }\n\n<fim_suffix>  @CanIgnoreReturnValue\n  @Override\n  public E remove(int index) {\n    return delegate().remove(index);\n  }\n\n  @CanIgnoreReturnValue\n  @Override\n  public E set(int index, E element) {\n    return delegate().set(index, element);\n  }\n\n  @Override\n  public List<E> subList(int fromIndex, int toIndex) {\n    return delegate().subList(fromIndex, toIndex);\n  }\n\n  @Override\n  public boolean equals(@Nullable Object object) {\n    return object == this || delegate().equals(object);\n  }\n\n  @Override\n  public int hashCode() {\n    return delegate().hashCode();\n  }\n\n  /**\n   * A sensible default implementation of {@link #add(Object)}, in terms of {@link #add(int,\n   * Object)}. If you override {@link #add(int, Object)}, you may wish to override {@link\n   * #add(Object)} to forward to this implementation.\n   *\n   * @since 7.0\n   */\n  protected boolean standardAdd(E element) {\n    add(size(), element);\n    return true;\n  }\n\n  /**\n   * A sensible default implementation of {@link #addAll(int, Collection)}, in terms of the {@code\n   * add} method of {@link #listIterator(int)}. If you override {@link #listIterator(int)}, you may\n   * wish to override {@link #addAll(int, Collection)} to forward to this implementation.\n   *\n   * @since 7.0\n   */\n  protected boolean standardAddAll(int index, Iterable<? extends E> elements) {\n    return Lists.addAllImpl(this, index, elements);\n  }\n\n  /**\n   * A sensible default implementation of {@link #indexOf}, in terms of {@link #listIterator()}. If\n   * you override {@link #listIterator()}, you may wish to override {@link #indexOf} to forward to\n   * this implementation.\n   *\n   * @since 7.0\n   */\n  protected int standardIndexOf(@Nullable Object element) {\n    return Lists.indexOfImpl(this, element);\n  }\n\n  /**\n   * A sensible default implementation of {@link #lastIndexOf}, in terms of {@link\n   * #listIterator(int)}. If you override {@link #listIterator(int)}, you may wish to override\n   * {@link #lastIndexOf} to forward to this implementation.\n   *\n   * @since 7.0\n   */\n  protected int standardLastIndexOf(@Nullable Object element) {\n    return Lists.lastIndexOfImpl(this, element);\n  }\n\n  /**\n   * A sensible default implementation of {@link #iterator}, in terms of {@link #listIterator()}. If\n   * you override {@link #listIterator()}, you may wish to override {@link #iterator} to forward to\n   * this implementation.\n   *\n   * @since 7.0\n   */\n  protected Iterator<E> standardIterator() {\n    return listIterator();\n  }\n\n  /**\n   * A sensible default implementation of {@link #listIterator()}, in terms of {@link\n   * #listIterator(int)}. If you override {@link #listIterator(int)}, you may wish to override\n   * {@link #listIterator()} to forward to this implementation.\n   *\n   * @since 7.0\n   */\n  protected ListIterator<E> standardListIterator() {\n    return listIterator(0);\n  }\n\n  /**\n   * A sensible default implementation of {@link #listIterator(int)}, in terms of {@link #size},\n   * {@link #get(int)}, {@link #set(int, Object)}, {@link #add(int, Object)}, and {@link\n   * #remove(int)}. If you override any of these methods, you may wish to override {@link\n   * #listIterator(int)} to forward to this implementation.\n   *\n   * @since 7.0\n   */\n  @Beta\n  protected ListIterator<E> standardListIterator(int start) {\n    return Lists.listIteratorImpl(this, start);\n  }\n\n  /**\n   * A sensible default implementation of {@link #subList(int, int)}. If you override any other\n   * methods, you may wish to override {@link #subList(int, int)} to forward to this implementation.\n   *\n   * @since 7.0\n   */\n  @Beta\n  protected List<E> standardSubList(int fromIndex, int toIndex) {\n    return Lists.subListImpl(this, fromIndex, toIndex);\n  }\n\n  /**\n   * A sensible definition of {@link #equals(Object)} in terms of {@link #size} and {@link\n   * #iterator}. If you override either of those methods, you may wish to override {@link\n   * #equals(Object)} to forward to this implementation.\n   *\n   * @since 7.0\n   */\n  @Beta\n  protected boolean standardEquals(@Nullable Object object) {\n    return Lists.equalsImpl(this, object);\n  }\n\n  /**\n   * A sensible definition of {@link #hashCode} in terms of {@link #iterator}. If you override\n   * {@link #iterator}, you may wish to override {@link #hashCode} to forward to this\n   * implementation.\n   *\n   * @since 7.0\n   */\n  @Beta\n  protected int standardHashCode() {\n    return Lists.hashCodeImpl(this);\n  }\n}<fim_middle>// function below has no smell\n"}