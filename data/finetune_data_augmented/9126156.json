{"text": "<fim_prefix>/*******************************************************************************\n * Copyright (c) 2004 Actuate Corporation.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *  Actuate Corporation  - initial API and implementation\n *******************************************************************************/\n\npackage org.eclipse.birt.chart.ui.swt;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.Stack;\n\nimport org.eclipse.jface.resource.JFaceResources;\nimport org.eclipse.swt.graphics.Color;\nimport org.eclipse.swt.graphics.RGB;\n\n/**\n * Manages and register color resource.\n */\n\npublic final class ColorPalette\n{\n\n\tprivate static ColorPalette instance = null;\n\tprivate List<RGB> colorLib = new ArrayList<RGB>( );\n\tprivate Stack<RGB> colorAvailable = new Stack<RGB>( );\n\tprivate HashMap<String, Color> hmColorUsed = new HashMap<String, Color>( );\n\n\tprivate ColorPalette( )\n\t{\n\t\tinitColorLibrary( );\n\t\trestore( );\n\t}\n\n<fim_suffix>\tpublic synchronized static ColorPalette getInstance( )\n\t{\n\t\tif ( instance == null )\n\t\t{\n\t\t\tinstance = new ColorPalette( );\n\t\t}\n\t\treturn instance;\n\t}\n\n\tprivate void initColorLibrary( )\n\t{\n\t\tcolorLib.add( new RGB( 170, 200, 255 ) );\n\t\tcolorLib.add( new RGB( 255, 255, 128 ) );\n\t\tcolorLib.add( new RGB( 128, 255, 128 ) );\n\t\tcolorLib.add( new RGB( 128, 255, 255 ) );\n\t\tcolorLib.add( new RGB( 255, 128, 255 ) );\n\t\tcolorLib.add( new RGB( 255, 128, 64 ) );\n\t\tcolorLib.add( new RGB( 0, 255, 128 ) );\n\t\tcolorLib.add( new RGB( 200, 156, 156 ) );\n\t\tcolorLib.add( new RGB( 128, 128, 255 ) );\n\t\tcolorLib.add( new RGB( 210, 210, 210 ) );\n\t\tcolorLib.add( new RGB( 184, 184, 114 ) );\n\t\tcolorLib.add( new RGB( 128, 128, 128 ) );\n\t\tCollections.reverse( colorLib );\n\t}\n\n\t/**\n\t * This map stores color name - Color pairs, used to quickly lookup a Color\n\t * of a predefined color.\n\t * \n\t * @param rgb\n\t *            RGB value of color\n\t */\n\tprivate Color getColor( RGB rgb )\n\t{\n\t\tif ( rgb == null )\n\t\t{\n\t\t\treturn null;\n\t\t}\n\n\t\tString key = rgb.toString( );\n\t\tColor color = JFaceResources.getColorRegistry( ).get( key );\n\t\tif ( color == null )\n\t\t{\n\t\t\tJFaceResources.getColorRegistry( ).put( key, rgb );\n\t\t\tcolor = JFaceResources.getColorRegistry( ).get( key );\n\t\t}\n\t\treturn color;\n\t}\n\n\tprivate Color getAvailableColor( )\n\t{\n\t\tRGB rgb = colorAvailable.isEmpty( ) ? null\n\t\t\t\t: (RGB) colorAvailable.pop( );\n\t\tif ( rgb == null )\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\treturn getColor( rgb );\n\t}\n\n\t/**\n\t * Registers the expression with a color. Duplicate expression will be\n\t * ignored.\n\t * \n\t * @param expression\n\t *            registered expression\n\t */\n\tpublic void putColor( String expression )\n\t{\n\t\tif ( expression != null && expression.length( ) > 0 )\n\t\t{\n\t\t\texpression = expression.toUpperCase( );\n\t\t\tif ( !hmColorUsed.containsKey( expression ) )\n\t\t\t{\n\t\t\t\thmColorUsed.put( expression, getAvailableColor( ) );\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void retrieveColor( String expression )\n\t{\n\t\tif ( expression != null && expression.length( ) > 0 )\n\t\t{\n\t\t\texpression = expression.toUpperCase( );\n\t\t\tif ( hmColorUsed.containsKey( expression ) )\n\t\t\t{\n\t\t\t\tColor oldColor = hmColorUsed.remove( expression );\n\t\t\t\tcolorAvailable.push( oldColor.getRGB( ) );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Fetches the color by registered expression\n\t * \n\t * @param expression\n\t *            registered expression\n\t * @return the registered color or null if not found\n\t */\n\tpublic Color getColor( String expression )\n\t{\n\t\tif ( expression != null && expression.length( ) > 0 )\n\t\t{\n\t\t\treturn hmColorUsed.get( expression.toUpperCase( ) );\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Restores the current to the initial state.\n\t * \n\t */\n\tpublic void restore( )\n\t{\n\t\tcolorAvailable.clear( );\n\t\tcolorAvailable.addAll( colorLib );\n\t\thmColorUsed.clear( );\n\t}\n\n\tpublic void updateKeys(Collection<String> keys)\n\t{\n\t\tSet<String> newKeys = new HashSet<String>( );\n\t\tfor (String key:keys)\n\t\t{\n\t\t\tnewKeys.add( key.toUpperCase( ) );\n\t\t}\n\t\t\n\t\tSet<String> oldKeys = hmColorUsed.keySet( );\n\n\t\tSet<String> keysToRemove = new HashSet<String>( oldKeys );\n\t\tkeysToRemove.removeAll( newKeys );\n\n\t\tfor ( String key : keysToRemove )\n\t\t{\n\t\t\tretrieveColor( key );\n\t\t}\n\t\t\n\t\tSet<String> keysToAdd = newKeys;\n\t\tkeysToAdd.removeAll( oldKeys );\n\n\t\tfor ( String key : keysToAdd )\n\t\t{\n\t\t\tputColor( key );\n\t\t}\n\t}\n\n}<fim_middle>// function below has no smell\n"}