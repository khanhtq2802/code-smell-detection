{"text": "<fim_prefix>import org.apache.activemq.artemis.core.client.impl.TopologyMemberImpl;\nimport org.apache.activemq.artemis.core.server.ActiveMQComponent;\nimport org.apache.activemq.artemis.core.server.ActiveMQServerLogger;\nimport org.apache.activemq.artemis.core.server.cluster.ClusterControl;\nimport org.apache.activemq.artemis.core.server.cluster.ClusterController;\n/**\n * A QourumManager can be used to register a {@link org.apache.activemq.artemis.core.server.cluster.qourum.Quorum} to receive notifications\n * about changes to the cluster. A {@link org.apache.activemq.artemis.core.server.cluster.qourum.Quorum} can then issue a vote to the\n * remaining nodes in a cluster for a specific outcome\n */\npublic final class QuorumManager implements ClusterTopologyListener, ActiveMQComponent {\n   private final ExecutorService executor;\n   private final ClusterController clusterController;\n   /**\n    * all the current registered {@link org.apache.activemq.artemis.core.server.cluster.qourum.Quorum}'s\n    */\n   private final Map<String, Quorum> quorums = new HashMap<>();\n   /**\n    * any currently running runnables.\n    */\n   private final Map<QuorumVote, VoteRunnableHolder> voteRunnables = new HashMap<>();\n   private final Map<SimpleString, QuorumVoteHandler> handlers = new HashMap<>();\n   private boolean started = false;\n   /**\n    * this is the max size that the cluster has been.\n    */\n   private int maxClusterSize = 0;\n   public QuorumManager(ExecutorService threadPool, ClusterController clusterController) {\n      this.clusterController = clusterController;\n      this.executor = threadPool;\n   }\n   /**\n    * we start by simply creating the server locator and connecting in a separate thread\n    *\n    * @throws Exception\n    */\n   @Override\n   public void start() throws Exception {\n      if (started)\n         return;\n      started = true;\n   }\n   /**\n    * stops the server locator\n    *\n    * @throws Exception\n    */\n   @Override\n   public void stop() throws Exception {\n      if (!started)\n         return;\n      synchronized (voteRunnables) {\n         started = false;\n         for (VoteRunnableHolder voteRunnableHolder : voteRunnables.values()) {\n            for (VoteRunnable runnable : voteRunnableHolder.runnables) {\n               runnable.close();\n            }\n         }\n      }\n      for (Quorum quorum : quorums.values()) {\n         quorum.close();\n      }\n      quorums.clear();\n   }\n   /**\n    * are we started\n    *\n    * @return\n    */\n   @Override\n   public boolean isStarted() {\n      return started;\n   }\n   /**\n    * registers a {@link org.apache.activemq.artemis.core.server.cluster.qourum.Quorum} so that it can be notified of changes in the cluster.\n    *\n    * @param quorum\n    */\n   public void registerQuorum(Quorum quorum) {\n      quorums.put(quorum.getName(), quorum);\n      quorum.setQuorumManager(this);\n   }\n   /**\n    * unregisters a {@link org.apache.activemq.artemis.core.server.cluster.qourum.Quorum}.\n    *\n    * @param quorum\n    */\n   public void unRegisterQuorum(Quorum quorum) {\n      quorums.remove(quorum.getName());\n   }\n   /**\n    * called by the {@link org.apache.activemq.artemis.core.client.impl.ServerLocatorInternal} when the topology changes. we update the\n    * {@code maxClusterSize} if needed and inform the {@link org.apache.activemq.artemis.core.server.cluster.qourum.Quorum}'s.\n    *\n    * @param topologyMember the topolgy changed\n    * @param last           if the whole cluster topology is being transmitted (after adding the listener to\n    *                       the cluster connection) this parameter will be {@code true} for the last topology\n    */\n   @Override\n   public void nodeUP(TopologyMember topologyMember, boolean last) {\n      final int newClusterSize = clusterController.getDefaultClusterSize();\n      maxClusterSize = newClusterSize > maxClusterSize ? newClusterSize : maxClusterSize;\n      for (Quorum quorum : quorums.values()) {\n         quorum.nodeUp(clusterController.getDefaultClusterTopology());\n      }\n   }\n   /**\n    * notify the {@link org.apache.activemq.artemis.core.server.cluster.qourum.Quorum} of a topology change.\n    *\n    * @param eventUID\n    * @param nodeID   the id of the node leaving the cluster\n    */\n   @Override\n   public void nodeDown(long eventUID, String nodeID) {\n      for (Quorum quorum : quorums.values()) {\n         quorum.nodeDown(clusterController.getDefaultClusterTopology(), eventUID, nodeID);\n      }\n   }\n   /**\n    * returns the maximum size this cluster has been.\n    *\n    * @return max size\n    */\n   public int getMaxClusterSize() {\n      return maxClusterSize;\n   }\n   /**\n    * ask the quorum to vote within a specific quorum.\n    *\n    * @param quorumVote the vote to acquire\n    */\n   public void vote(final QuorumVote quorumVote) {\n      List<VoteRunnable> runnables = new ArrayList<>();\n      synchronized (voteRunnables) {\n         if (!started)\n            return;\n         //send a vote to each node\n         ActiveMQServerLogger.LOGGER.initiatingQuorumVote(quorumVote.getName());\n         for (TopologyMemberImpl tm : clusterController.getDefaultClusterTopology().getMembers()) {\n            //but not ourselves\n            if (!tm.getNodeId().equals(clusterController.getNodeID().toString())) {\n               Pair<TransportConfiguration, TransportConfiguration> pair = tm.getConnector();\n               final TransportConfiguration serverTC = pair.getA();\n               VoteRunnable voteRunnable = new VoteRunnable(serverTC, quorumVote);\n               runnables.add(voteRunnable);\n            }\n         }\n         if (runnables.size() > 0) {\n            voteRunnables.put(quorumVote, new VoteRunnableHolder(quorumVote, runnables, runnables.size()));\n            for (VoteRunnable runnable : runnables) {\n               executor.submit(runnable);\n            }\n         } else {\n            quorumVote.allVotesCast(clusterController.getDefaultClusterTopology());\n         }\n      }\n   }\n   /**\n    * handle a vote received on the quorum\n    *\n    * @param handler the name of the handler to use for the vote\n    * @param vote    the vote\n    * @return the updated vote\n    */\n   public Vote vote(SimpleString handler, Vote vote) {\n      QuorumVoteHandler quorumVoteHandler = handlers.get(handler);\n      return quorumVoteHandler.vote(vote);\n   }\n   /**\n    * must be called by the quorum when it is happy on an outcome. only one vote can take place at anyone time for a\n    * specific quorum\n    *\n    * @param quorumVote the vote\n    */\n   public void voteComplete(QuorumVoteServerConnect quorumVote) {\n      VoteRunnableHolder holder = voteRunnables.remove(quorumVote);\n      if (holder != null) {\n         for (VoteRunnable runnable : holder.runnables) {\n            runnable.close();\n         }\n      }\n   }\n   /**\n    * called to register vote handlers on the quorum\n    *\n    * @param quorumVoteHandler the vote handler\n    */\n   public void registerQuorumHandler(QuorumVoteHandler quorumVoteHandler) {\n      handlers.put(quorumVoteHandler.getQuorumName(), quorumVoteHandler);\n   }\n   @Override\n   public String toString() {\n      return QuorumManager.class.getSimpleName() + \"(server=\" + clusterController.getIdentity() + \")\";\n   }\n   public QuorumVoteHandler getVoteHandler(SimpleString handler) {\n      return handlers.get(handler);\n   }\n   public TransportConfiguration getLiveTransportConfiguration(String targetServerID) {\n      TopologyMemberImpl member = clusterController.getDefaultClusterTopology().getMember(targetServerID);\n      return member != null ? member.getLive() : null;\n   }\n   public boolean checkLive(TransportConfiguration liveTransportConfiguration) {\n      try {\n         ClusterControl control = clusterController.connectToNode(liveTransportConfiguration);\n         control.close();\n         return true;\n      } catch (Throwable t) {\n         return false;\n      }\n   }\n   private final class VoteRunnableHolder {\n      private final QuorumVote quorumVote;\n      private final List<VoteRunnable> runnables;\n      private int size;\n<fim_suffix>      private VoteRunnableHolder(QuorumVote quorumVote, List<VoteRunnable> runnables, int size) {\n         this.quorumVote = quorumVote;\n         this.runnables = runnables;\n         this.size = size;\n      }<fim_middle>// function below has no smell\n"}