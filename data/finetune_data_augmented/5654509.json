{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.sis.feature;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Set;\nimport java.util.EnumSet;\nimport java.util.Iterator;\nimport java.util.Collection;\nimport java.util.Locale;\nimport java.util.TimeZone;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.text.Format;\nimport java.text.FieldPosition;\nimport java.text.ParsePosition;\nimport java.text.ParseException;\nimport java.util.concurrent.atomic.AtomicReference;\nimport org.opengis.referencing.IdentifiedObject;\nimport org.opengis.util.InternationalString;\nimport org.opengis.util.GenericName;\nimport org.apache.sis.io.TableAppender;\nimport org.apache.sis.io.TabularFormat;\nimport org.apache.sis.util.Deprecable;\nimport org.apache.sis.util.Characters;\nimport org.apache.sis.util.CharSequences;\nimport org.apache.sis.util.ArgumentChecks;\nimport org.apache.sis.util.logging.Logging;\nimport org.apache.sis.util.resources.Errors;\nimport org.apache.sis.util.resources.Vocabulary;\nimport org.apache.sis.internal.util.CollectionsExt;\nimport org.apache.sis.internal.feature.Geometries;\nimport org.apache.sis.internal.system.Modules;\nimport org.apache.sis.referencing.IdentifiedObjects;\nimport org.apache.sis.math.MathFunctions;\n/**\n * Formats {@linkplain AbstractFeature features} or {@linkplain DefaultFeatureType feature types} in a tabular format.\n * This format assumes a monospaced font and an encoding supporting drawing box characters (e.g. UTF-8).\n *\n * <div class=\"note\"><b>Example:</b> a feature named \u201cCity\u201d and containing 3 properties (\u201cname\u201d, \u201cpopulation\u201d and\n * \u201ctwin town\u201d) may be formatted like below. The two first properties are {@linkplain AbstractAttribute attributes}\n * while the last property is an {@linkplain AbstractAssociation association} to an other feature.\n *\n * {@preformat text\n *   City\n *   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n *   \u2502 Name       \u2502 Type    \u2502 Multiplicity \u2502 Value     \u2502\n *   \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n *   \u2502 name       \u2502 String  \u2502 [1 \u2026 1]      \u2502 Paderborn \u2502\n *   \u2502 population \u2502 Integer \u2502 [1 \u2026 1]      \u2502 143,174   \u2502\n *   \u2502 twin town  \u2502 City    \u2502 [0 \u2026 \u221e]      \u2502 Le Mans   \u2502\n *   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n * }</div>\n *\n * <p><b>Limitations:</b></p>\n * <ul>\n *   <li>The current implementation can only format features \u2014 parsing is not yet implemented.</li>\n *   <li>{@code FeatureFormat}, like most {@code java.text.Format} subclasses, is not thread-safe.</li>\n * </ul>\n *\n * @author  Martin Desruisseaux (Geomatys)\n * @version 1.0\n * @since   0.5\n * @module\n */\npublic class FeatureFormat extends TabularFormat<Object> {\n    /**\n     * For cross-version compatibility.\n     */\n    private static final long serialVersionUID = -5792086817264884947L;\n    /**\n     * The separator to use in comma-separated lists.\n     */\n    private static final String SEPARATOR = \", \";\n    /**\n     * An instance created when first needed and potentially shared.\n     */\n    private static final AtomicReference<FeatureFormat> INSTANCE = new AtomicReference<>();\n    /**\n     * The locale for international strings.\n     */\n    private final Locale displayLocale;\n    /**\n     * The columns to include in the table formatted by this {@code FeatureFormat}.\n     * By default, all columns having at least one value are included.\n     */\n    private final EnumSet<Column> columns = EnumSet.allOf(Column.class);\n    /**\n     * Maximal length of attribute values, in number of characters.\n     * If a value is longer than this length, it will be truncated.\n     *\n     * <p>This is defined as a static final variable for now because its value is approximate:\n     * it is a number of characters instead than a number of code points, and that length may be\n     * exceeded by a few characters if the overflow happen while appending the list separator.</p>\n     */\n    private static final int MAXIMAL_VALUE_LENGTH = 40;\n    /**\n     * The bit patterns of the last {@link Float#NaN}\u00a0value for which {@link MathFunctions#toNanOrdinal(float)} could\n     * not get the ordinal value. We use this information for avoiding flooding the logger with the same message.\n     */\n    private transient int illegalNaN;\n    /**\n     * Creates a new formatter for the default locale and timezone.\n     */\n    public FeatureFormat() {\n        super(Locale.getDefault(Locale.Category.FORMAT), TimeZone.getDefault());\n        displayLocale = Locale.getDefault(Locale.Category.DISPLAY);\n        columnSeparator = \" \u2502 \";\n    }\n    /**\n     * Creates a new formatter for the given locale and timezone.\n     *\n     * @param  locale    the locale, or {@code null} for {@code Locale.ROOT}.\n     * @param  timezone  the timezone, or {@code null} for UTC.\n     */\n    public FeatureFormat(final Locale locale, final TimeZone timezone) {\n        super(locale, timezone);\n        displayLocale = (locale != null) ? locale : Locale.ROOT;\n        columnSeparator = \" \u2502 \";\n    }\n    /**\n     * Returns the type of objects formatted by this class. This method has to return {@code Object.class}\n     * since it is the only common parent to {@code Feature} and {@link FeatureType}.\n     *\n     * @return {@code Object.class}\n     */\n    @Override\n    public final Class<Object> getValueType() {\n        return Object.class;\n    }\n    /**\n     * Returns the locale for the given category.\n     *\n     * <ul>\n     *   <li>{@link java.util.Locale.Category#FORMAT} specifies the locale to use for values.</li>\n     *   <li>{@link java.util.Locale.Category#DISPLAY} specifies the locale to use for labels.</li>\n     * </ul>\n     *\n     * @param  category  the category for which a locale is desired.\n     * @return the locale for the given category (never {@code null}).\n     */\n    @Override\n    public Locale getLocale(final Locale.Category category) {\n        return (category == Locale.Category.DISPLAY) ? displayLocale : super.getLocale(category);\n    }\n    /**\n     * Returns all columns that may be shown in the tables to format.\n     * The columns included in the set may be shown, but not necessarily;\n     * some columns will still be omitted if they are completely empty.\n     * However columns <em>not</em> included in the set are guaranteed to be omitted.\n     *\n     * @return all columns that may be shown in the tables to format.\n     *\n     * @since 0.8\n     */\n    public Set<Column> getAllowedColumns() {\n        return columns.clone();\n    }\n    /**\n     * Sets all columns that may be shown in the tables to format.\n     * Note that the columns specified to this method are not guaranteed to be shown;\n     * some columns will still be omitted if they are completely empty.\n     *\n     * @param inclusion  all columns that may be shown in the tables to format.\n     *\n     * @since 0.8\n     */\n<fim_suffix>    public void setAllowedColumns(final Set<Column> inclusion) {\n        ArgumentChecks.ensureNonNull(\"inclusion\", inclusion);\n        columns.clear();\n        columns.addAll(inclusion);\n    }\n    /**\n     * Identifies the columns to include in the table formatted by {@code FeatureFormat}.\n     * By default, all columns having at least one non-null value are shown. But a smaller<fim_middle>// function below has no smell\n"}