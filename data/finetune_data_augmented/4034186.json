{"text": "<fim_prefix>          options.as(DataflowPipelineDebugOptions.class), \"beam_fn_api\")) {\n        LOG.info(\"FnAPI: Unable to deserialize windowing strategy, assuming default\", e);\n        windowingStrategy = WindowingStrategy.globalDefault();\n      } else {\n        throw e;\n      }\n    }\n    byte[] serializedCombineFn = getBytes(cloudUserFn, WorkerPropertyNames.COMBINE_FN, null);\n    AppliedCombineFn<?, ?, ?, ?> combineFn = null;\n    if (serializedCombineFn != null) {\n      Object combineFnObj =\n          SerializableUtils.deserializeFromByteArray(serializedCombineFn, \"serialized combine fn\");\n      checkArgument(\n          combineFnObj instanceof AppliedCombineFn,\n          \"unexpected kind of AppliedCombineFn: \" + combineFnObj.getClass().getName());\n      combineFn = (AppliedCombineFn<?, ?, ?, ?>) combineFnObj;\n    }\n    Map<String, Object> inputCoderObject = getObject(cloudUserFn, WorkerPropertyNames.INPUT_CODER);\n    Coder<?> inputCoder = CloudObjects.coderFromCloudObject(CloudObject.fromSpec(inputCoderObject));\n    checkArgument(\n        inputCoder instanceof WindowedValueCoder,\n        \"Expected WindowedValueCoder for inputCoder, got: \" + inputCoder.getClass().getName());\n    @SuppressWarnings(\"unchecked\")\n    WindowedValueCoder<?> windowedValueCoder = (WindowedValueCoder<?>) inputCoder;\n    Coder<?> elemCoder = windowedValueCoder.getValueCoder();\n    checkArgument(\n        elemCoder instanceof KvCoder,\n        \"Expected KvCoder for inputCoder, got: \" + elemCoder.getClass().getName());\n    @SuppressWarnings(\"unchecked\")\n    KvCoder<?, ?> kvCoder = (KvCoder<?, ?>) elemCoder;\n    boolean isStreamingPipeline = options.as(StreamingOptions.class).isStreaming();\n    SideInputReader sideInputReader = NullSideInputReader.empty();\n    @Nullable AppliedCombineFn<?, ?, ?, ?> maybeMergingCombineFn = null;\n    if (combineFn != null) {\n      sideInputReader =\n          executionContext.getSideInputReader(\n              sideInputInfos, combineFn.getSideInputViews(), operationContext);\n      String phase = getString(cloudUserFn, WorkerPropertyNames.PHASE, CombinePhase.ALL);\n      checkArgument(\n          phase.equals(CombinePhase.ALL) || phase.equals(CombinePhase.MERGE),\n          \"Unexpected phase: %s\",\n          phase);\n      if (phase.equals(CombinePhase.MERGE)) {\n        maybeMergingCombineFn = makeAppliedMergingFunction(combineFn);\n      } else {\n        maybeMergingCombineFn = combineFn;\n      }\n    }\n    StateInternalsFactory<?> stateInternalsFactory =\n        key -> executionContext.getStepContext(operationContext).stateInternals();\n    // This will be a GABW Fn for either batch or streaming, with combiner in it or not\n    GroupAlsoByWindowFn<?, ?> fn;\n    // This will be a FakeKeyedWorkItemCoder for streaming or null for batch\n    Coder<?> gabwInputCoder;\n    // TODO: do not do this with mess of \"if\"\n    if (isStreamingPipeline) {\n      if (maybeMergingCombineFn == null) {\n        fn =\n            StreamingGroupAlsoByWindowsDoFns.createForIterable(\n                windowingStrategy, stateInternalsFactory, ((KvCoder) kvCoder).getValueCoder());\n        gabwInputCoder = WindmillKeyedWorkItem.FakeKeyedWorkItemCoder.of(kvCoder);\n      } else {\n        fn =\n            StreamingGroupAlsoByWindowsDoFns.create(\n                windowingStrategy,\n                stateInternalsFactory,\n                (AppliedCombineFn) maybeMergingCombineFn,\n                ((KvCoder) kvCoder).getKeyCoder());\n        gabwInputCoder =\n            WindmillKeyedWorkItem.FakeKeyedWorkItemCoder.of(\n                ((AppliedCombineFn) maybeMergingCombineFn).getKvCoder());\n      }\n    } else {\n      if (maybeMergingCombineFn == null) {\n        fn =\n            BatchGroupAlsoByWindowsDoFns.createForIterable(\n                windowingStrategy, stateInternalsFactory, ((KvCoder) kvCoder).getValueCoder());\n        gabwInputCoder = null;\n      } else {\n        fn =\n            BatchGroupAlsoByWindowsDoFns.create(\n                windowingStrategy, (AppliedCombineFn) maybeMergingCombineFn);\n        gabwInputCoder = null;\n      }\n    }\n    // TODO: or anyhow related to it, do not do this with mess of \"if\"\n    if (maybeMergingCombineFn != null) {\n      return new GroupAlsoByWindowsParDoFn(\n          options,\n          fn,\n          windowingStrategy,\n          ((AppliedCombineFn) maybeMergingCombineFn).getSideInputViews(),\n          gabwInputCoder,\n          sideInputReader,\n          mainOutputTag,\n          executionContext.getStepContext(operationContext));\n    } else {\n      return new GroupAlsoByWindowsParDoFn(\n          options,\n          fn,\n          windowingStrategy,\n          null,\n          gabwInputCoder,\n          sideInputReader,\n          mainOutputTag,\n          executionContext.getStepContext(operationContext));\n    }\n  }\n  static WindowingStrategy deserializeWindowingStrategy(byte[] encodedWindowingStrategy)\n      throws InvalidProtocolBufferException {\n    RunnerApi.MessageWithComponents strategyProto =\n        RunnerApi.MessageWithComponents.parseFrom(encodedWindowingStrategy);\n    checkArgument(\n        strategyProto.getRootCase() == RootCase.WINDOWING_STRATEGY,\n        \"Invalid windowing strategy: %s\",\n        strategyProto);\n    return WindowingStrategyTranslation.fromProto(\n        strategyProto.getWindowingStrategy(),\n        RehydratedComponents.forComponents(strategyProto.getComponents()));\n  }\n  private static <K, AccumT>\n      AppliedCombineFn<K, AccumT, List<AccumT>, AccumT> makeAppliedMergingFunction(\n          AppliedCombineFn<K, ?, AccumT, ?> appliedFn) {\n    GlobalCombineFn<AccumT, List<AccumT>, AccumT> mergingCombineFn;\n    if (appliedFn.getFn() instanceof CombineFnWithContext) {\n      mergingCombineFn =\n          new MergingKeyedCombineFnWithContext<>(\n              (CombineFnWithContext<?, AccumT, ?>) appliedFn.getFn(),\n              appliedFn.getAccumulatorCoder());\n    } else {\n      mergingCombineFn =\n          new MergingCombineFn<>(\n              (CombineFn<?, AccumT, ?>) appliedFn.getFn(), appliedFn.getAccumulatorCoder());\n    }\n    return AppliedCombineFn.<K, AccumT, List<AccumT>, AccumT>withAccumulatorCoder(\n        mergingCombineFn,\n        ListCoder.of(appliedFn.getAccumulatorCoder()),\n        appliedFn.getSideInputViews(),\n        KvCoder.of(appliedFn.getKvCoder().getKeyCoder(), appliedFn.getAccumulatorCoder()),\n        appliedFn.getWindowingStrategy());\n  }\n  private static int MAX_ACCUMULATOR_BUFFER_SIZE = 10;\n<fim_suffix>  static class MergingCombineFn<K, AccumT> extends CombineFn<AccumT, List<AccumT>, AccumT> {\n    private final CombineFn<?, AccumT, ?> combineFn;\n    private final Coder<AccumT> accumCoder;\n    MergingCombineFn(CombineFn<?, AccumT, ?> combineFn, Coder<AccumT> accumCoder) {\n      this.combineFn = combineFn;\n      this.accumCoder = accumCoder;\n    }\n    @Override\n    public List<AccumT> createAccumulator() {\n      ArrayList<AccumT> result = new ArrayList<>();\n      result.add(this.combineFn.createAccumulator());\n      return result;\n    }\n    @Override\n    public List<AccumT> addInput(List<AccumT> accumulator, AccumT input) {\n      accumulator.add(input);\n      if (accumulator.size() < MAX_ACCUMULATOR_BUFFER_SIZE) {\n        return accumulator;\n      } else {\n        return mergeToSingleton(accumulator);\n      }\n    }\n    @Override\n    public List<AccumT> mergeAccumulators(Iterable<List<AccumT>> accumulators) {\n      return mergeToSingleton(Iterables.concat(accumulators));\n    }\n    @Override\n    public List<AccumT> compact(List<AccumT> accumulator) {\n      return mergeToSingleton(accumulator);\n    }\n    @Override\n    public AccumT extractOutput(List<AccumT> accumulator) {\n      if (accumulator.isEmpty()) {\n        return combineFn.createAccumulator();\n      } else {\n        return combineFn.mergeAccumulators(accumulator);\n      }\n    }\n    private List<AccumT> mergeToSingleton(Iterable<AccumT> accumulators) {\n      List<AccumT> singleton = new ArrayList<>();\n      singleton.add(combineFn.mergeAccumulators(accumulators));\n      return singleton;\n    }\n    @Override\n    public Coder<List<AccumT>> getAccumulatorCoder(CoderRegistry registry, Coder<AccumT> inputCoder)\n        throws CannotProvideCoderException {\n      return ListCoder.of(accumCoder);\n    }\n  }<fim_middle>// class below has no smell\n"}