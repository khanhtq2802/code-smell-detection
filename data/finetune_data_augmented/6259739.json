{"text": "<fim_prefix>\t\t\t\t|| name.contains(\"^\") || name.contains(\"'\")) {\n\t\t\tnewName.insert(0, '(');\n\t\t\tnewName.append(')');\n\t\t}\n\t\treturn newName;\n\t}\n\t/**\n\t * Create a string for a binary operator and its operands\n\t * \n\t * @param operator\n\t * @param a\n\t *            1st operand name\n\t * @param b\n\t *            2nd operand name\n\t * @return name of operation\n\t */\n\tpublic static String createBinaryOperationName(final String operator, final String a, final String b) {\n\t\tStringBuilder newName = bracketIfNecessary(a).append(operator).append(bracketIfNecessary(b));\n\t\treturn newName.toString();\n\t}\n\t/**\n\t * Create a string for a function and its arguments\n\t * \n\t * @param function\n\t * @param arguments\n\t * @return name of function\n\t */\n\tpublic static String createFunctionName(final String function, String... arguments) {\n\t\tStringBuilder name = new StringBuilder(function);\n\t\tname.append('(');\n\t\tint length = arguments.length - 1;\n\t\tfor (int i = 0; i < length; i++) {\n\t\t\tname.append(arguments[i]);\n\t\t\tname.append(\", \");\n\t\t}\n\t\tname.append(arguments[length]);\n\t\tname.append(')');\n\t\treturn name.toString();\n\t}\n\t/**\n\t * Negation with boolean not\n\t */\n\tpublic static class Negation implements UnaryOperation {\n\t\t@Override\n\t\tpublic boolean booleanOperate(long a) {\n\t\t\treturn a == 0;\n\t\t}\n\t\t@Override\n\t\tpublic long longOperate(long a) {\n\t\t\treturn -a;\n\t\t}\n\t\t@Override\n\t\tpublic double doubleOperate(double a) {\n\t\t\treturn -a;\n\t\t}\n\t\t@Override\n\t\tpublic void complexOperate(double[] out, double ra, double ia) {\n\t\t\tout[0] = -ra;\n\t\t\tout[1] = -ia;\n\t\t}\n\t\t@Override\n\t\tpublic String toString(String a) {\n\t\t\treturn createFunctionName(toString(), a);\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"-\";\n\t\t}\n\t}\n\t/**\n\t * Addition with boolean or\n\t */\n\tpublic static class Addition implements BinaryOperation {\n\t\t@Override\n\t\tpublic boolean booleanOperate(long a, long b) {\n\t\t\treturn a != 0 || b != 0;\n\t\t}\n\t\t@Override\n\t\tpublic long longOperate(long a, long b) {\n\t\t\treturn a + b;\n\t\t}\n\t\t@Override\n\t\tpublic double doubleOperate(double a, double b) {\n\t\t\treturn a + b;\n\t\t}\n\t\t@Override\n\t\tpublic void complexOperate(double[] out, double ra, double ia, double rb, double ib) {\n\t\t\tout[0] = ra + rb;\n\t\t\tout[1] = ia + ib;\n\t\t}\n\t\t@Override\n\t\tpublic String toString(String a, String b) {\n\t\t\treturn createBinaryOperationName(toString(), a, b);\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"+\";\n\t\t}\n\t}\n\t/**\n\t * Subtraction with boolean or of negated second operand\n\t */\n\tpublic static class Subtraction implements BinaryOperation {\n\t\t@Override\n\t\tpublic boolean booleanOperate(long a, long b) {\n\t\t\treturn a != 0 || b == 0;\n\t\t}\n\t\t@Override\n\t\tpublic long longOperate(long a, long b) {\n\t\t\treturn a - b;\n\t\t}\n\t\t@Override\n\t\tpublic double doubleOperate(double a, double b) {\n\t\t\treturn a - b;\n\t\t}\n\t\t@Override\n\t\tpublic void complexOperate(double[] out, double ra, double ia, double rb, double ib) {\n\t\t\tout[0] = ra - rb;\n\t\t\tout[1] = ia - ib;\n\t\t}\n\t\t@Override\n\t\tpublic String toString(String a, String b) {\n\t\t\treturn createBinaryOperationName(toString(), a, b);\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"-\";\n\t\t}\n\t}\n\t/**\n\t * Multiplication with boolean and\n\t */\n\tpublic static class Multiplication implements BinaryOperation {\n\t\t@Override\n\t\tpublic boolean booleanOperate(long a, long b) {\n\t\t\treturn a != 0 && b != 0;\n\t\t}\n\t\t@Override\n\t\tpublic long longOperate(long a, long b) {\n\t\t\treturn a * b;\n\t\t}\n\t\t@Override\n\t\tpublic double doubleOperate(double a, double b) {\n\t\t\treturn a * b;\n\t\t}\n\t\t@Override\n\t\tpublic void complexOperate(double[] out, double ra, double ia, double rb, double ib) {\n\t\t\tout[0] = ra * rb - ia * ib;\n\t\t\tout[1] = ra * ib + ia * rb;\n\t\t}\n\t\t@Override\n\t\tpublic String toString(String a, String b) {\n\t\t\treturn createBinaryOperationName(toString(), a, b);\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"*\";\n\t\t}\n\t}\n\t/**\n\t * Division with boolean and of negated second operand\n\t */\n\tpublic static class Division implements BinaryOperation {\n\t\t@Override\n\t\tpublic boolean booleanOperate(long a, long b) {\n\t\t\treturn a != 0 && b == 0;\n\t\t}\n\t\t@Override\n\t\tpublic long longOperate(long a, long b) {\n\t\t\treturn b == 0 ? 0 : a / b;\n\t\t}\n\t\t@Override\n\t\tpublic double doubleOperate(double a, double b) {\n\t\t\treturn a / b;\n\t\t}\n\t\t@Override\n\t\tpublic void complexOperate(double[] out, double ra, double ia, double rb, double ib) {\n\t\t\tdouble q;\n\t\t\tdouble den;\n\t\t\tif (ib == 0) {\n\t\t\t\tout[0] = ra / rb;\n\t\t\t\tout[1] = ia / rb;\n\t\t\t} else if (rb == 0) {\n\t\t\t\tout[0] = ia / ib;\n\t\t\t\tout[1] = -ra / ib;\n\t\t\t} else if (Math.abs(rb) < Math.abs(ib)) {\n\t\t\t\tq = rb / ib;\n\t\t\t\tden = rb * q + ib;\n\t\t\t\tout[0] = (ra * q + ia) / den;\n\t\t\t\tout[1] = (ia * q - rb) / den;\n\t\t\t} else {\n\t\t\t\tq = ib / rb;\n\t\t\t\tden = ib * q + rb;\n\t\t\t\tout[0] = (ia * q + ra) / den;\n\t\t\t\tout[1] = (ia - ra * q) / den;\n\t\t\t}\n\t\t}\n\t\t@Override\n\t\tpublic String toString(String a, String b) {\n\t\t\treturn createBinaryOperationName(toString(), a, b);\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"/\";\n\t\t}\n\t}\n\t/**\n\t * Division with boolean and of negated second operand and returns zero if\n\t * denominator is zero\n\t */\n<fim_suffix>\tpublic static class DivisionWithZero extends Division {\n\t\t@Override\n\t\tpublic double doubleOperate(double a, double b) {\n\t\t\treturn b == 0 ? 0 : a / b;\n\t\t}\n\t\t@Override\n\t\tpublic void complexOperate(double[] out, double ra, double ia, double rb, double ib) {\n\t\t\tdouble q;\n\t\t\tdouble den;\n\t\t\tif (ib == 0) {\n\t\t\t\tif (rb == 0) {\n\t\t\t\t\tout[0] = 0;\n\t\t\t\t\tout[1] = 0;\n\t\t\t\t} else {\n\t\t\t\t\tout[0] = ra / rb;\n\t\t\t\t\tout[1] = ia / rb;\n\t\t\t\t}\n\t\t\t} else if (rb == 0) {\n\t\t\t\tout[0] = ia / ib;\n\t\t\t\tout[1] = -ra / ib;\n\t\t\t} else if (Math.abs(rb) < Math.abs(ib)) {\n\t\t\t\tq = rb / ib;\n\t\t\t\tden = rb * q + ib;\n\t\t\t\tout[0] = (ra * q + ia) / den;\n\t\t\t\tout[1] = (ia * q - rb) / den;\n\t\t\t} else {\n\t\t\t\tq = ib / rb;\n\t\t\t\tden = ib * q + rb;\n\t\t\t\tout[0] = (ia * q + ra) / den;\n\t\t\t\tout[1] = (ia - ra * q) / den;\n\t\t\t}\n\t\t}\n\t}<fim_middle>// class below has no smell\n"}