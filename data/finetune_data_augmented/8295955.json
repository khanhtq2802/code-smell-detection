{"text": "<fim_prefix>/****************************************************************\n * Licensed to the Apache Software Foundation (ASF) under one   *\n * or more contributor license agreements.  See the NOTICE file *\n * distributed with this work for additional information        *\n * regarding copyright ownership.  The ASF licenses this file   *\n * to you under the Apache License, Version 2.0 (the            *\n * \"License\"); you may not use this file except in compliance   *\n * with the License.  You may obtain a copy of the License at   *\n *                                                              *\n *   http://www.apache.org/licenses/LICENSE-2.0                 *\n *                                                              *\n * Unless required by applicable law or agreed to in writing,   *\n * software distributed under the License is distributed on an  *\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *\n * KIND, either express or implied.  See the License for the    *\n * specific language governing permissions and limitations      *\n * under the License.                                           *\n ****************************************************************/\n\npackage org.apache.james.managesieveserver.netty;\n\nimport static org.jboss.netty.channel.Channels.pipeline;\n\nimport javax.net.ssl.SSLEngine;\n\nimport org.apache.james.managesieve.transcode.ManageSieveProcessor;\nimport org.apache.james.protocols.api.Encryption;\nimport org.apache.james.protocols.lib.netty.AbstractConfigurableAsyncServer;\nimport org.apache.james.protocols.netty.ChannelGroupHandler;\nimport org.apache.james.protocols.netty.ChannelHandlerFactory;\nimport org.apache.james.protocols.netty.ConnectionLimitUpstreamHandler;\nimport org.apache.james.protocols.netty.ConnectionPerIpLimitUpstreamHandler;\nimport org.apache.james.protocols.netty.LineDelimiterBasedChannelHandlerFactory;\nimport org.jboss.netty.channel.ChannelPipeline;\nimport org.jboss.netty.channel.ChannelPipelineFactory;\nimport org.jboss.netty.channel.ChannelUpstreamHandler;\nimport org.jboss.netty.channel.group.ChannelGroup;\nimport org.jboss.netty.handler.codec.string.StringDecoder;\nimport org.jboss.netty.handler.codec.string.StringEncoder;\nimport org.jboss.netty.handler.execution.ExecutionHandler;\nimport org.jboss.netty.handler.ssl.SslHandler;\nimport org.jboss.netty.handler.stream.ChunkedWriteHandler;\nimport org.jboss.netty.util.CharsetUtil;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n<fim_suffix>public class ManageSieveServer extends AbstractConfigurableAsyncServer implements ManageSieveServerMBean {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(ManageSieveServer.class);\n\n    static final String SSL_HANDLER = \"sslHandler\";\n    static final String FRAMER = \"framer\";\n    static final String CORE_HANDLER = \"coreHandler\";\n    static final String GROUP_HANDLER = \"groupHandler\";\n    static final String CONNECTION_LIMIT_HANDLER = \"connectionLimitHandler\";\n    static final String CONNECTION_LIMIT_PER_IP_HANDLER = \"connectionPerIpLimitHandler\";\n    static final String CONNECTION_COUNT_HANDLER = \"connectionCountHandler\";\n    static final String CHUNK_WRITE_HANDLER = \"chunkWriteHandler\";\n    static final String EXECUTION_HANDLER = \"executionHandler\";\n\n    private final int maxLineLength;\n    private final ManageSieveProcessor manageSieveProcessor;\n\n    public ManageSieveServer(int maxLineLength, ManageSieveProcessor manageSieveProcessor) {\n        this.maxLineLength = maxLineLength;\n        this.manageSieveProcessor = manageSieveProcessor;\n    }\n\n    @Override\n    protected int getDefaultPort() {\n        return 4190;\n    }\n\n    @Override\n    protected String getDefaultJMXName() {\n        return \"managesieveserver\";\n    }\n\n    @Override\n    protected ChannelUpstreamHandler createCoreHandler() {\n        return new ManageSieveChannelUpstreamHandler(manageSieveProcessor,\n            getEncryption() == null ? null : getEncryption().getContext(),\n            getEnabledCipherSuites(),\n            isSSL(),\n            LOGGER);\n    }\n\n    private boolean isSSL() {\n        return getEncryption() != null\n            && !getEncryption().isStartTLS();\n    }\n\n    @Override\n    protected ChannelPipelineFactory createPipelineFactory(final ChannelGroup group) {\n\n        return new ChannelPipelineFactory() {\n\n            private final ChannelGroupHandler groupHandler = new ChannelGroupHandler(group);\n\n            @Override\n            public ChannelPipeline getPipeline() throws Exception {\n                ChannelPipeline pipeline = pipeline();\n                Encryption secure = getEncryption();\n                if (secure != null && !secure.isStartTLS()) {\n                    // We need to set clientMode to false.\n                    // See https://issues.apache.org/jira/browse/JAMES-1025\n                    SSLEngine engine = secure.getContext().createSSLEngine();\n                    engine.setUseClientMode(false);\n                    pipeline.addFirst(SSL_HANDLER, new SslHandler(engine));\n\n                }\n                pipeline.addLast(GROUP_HANDLER, groupHandler);\n                pipeline.addLast(CONNECTION_LIMIT_HANDLER, new ConnectionLimitUpstreamHandler(ManageSieveServer.this.connectionLimit));\n                pipeline.addLast(CONNECTION_LIMIT_PER_IP_HANDLER, new ConnectionPerIpLimitUpstreamHandler(ManageSieveServer.this.connPerIP));\n                // Add the text line decoder which limit the max line length,\n                // don't strip the delimiter and use CRLF as delimiter\n                // Use a SwitchableDelimiterBasedFrameDecoder, see JAMES-1436\n                pipeline.addLast(FRAMER, getFrameHandlerFactory().create(pipeline));\n                pipeline.addLast(CONNECTION_COUNT_HANDLER, getConnectionCountHandler());\n                pipeline.addLast(CHUNK_WRITE_HANDLER, new ChunkedWriteHandler());\n\n                ExecutionHandler ehandler = getExecutionHandler();\n                if (ehandler  != null) {\n                    pipeline.addLast(EXECUTION_HANDLER, ehandler);\n\n                }\n                pipeline.addLast(\"stringDecoder\", new StringDecoder(CharsetUtil.UTF_8));\n                pipeline.addLast(CORE_HANDLER, createCoreHandler());\n                pipeline.addLast(\"stringEncoder\", new StringEncoder(CharsetUtil.UTF_8));\n                return pipeline;\n            }\n\n        };\n    }\n\n    @Override\n    public String getServiceType() {\n        return \"Manage Sieve Service\";\n    }\n\n    @Override\n    protected ChannelHandlerFactory createFrameHandlerFactory() {\n        return new LineDelimiterBasedChannelHandlerFactory(maxLineLength);\n    }\n}<fim_middle>// class below has no smell\n"}