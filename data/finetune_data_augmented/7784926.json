{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.wicket.pageStore;\nimport java.io.IOException;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.function.Supplier;\nimport javax.servlet.http.HttpSession;\nimport org.apache.wicket.DefaultPageManagerProvider;\nimport org.apache.wicket.MetaDataKey;\nimport org.apache.wicket.Session;\nimport org.apache.wicket.WicketRuntimeException;\nimport org.apache.wicket.page.IManageablePage;\nimport org.apache.wicket.serialize.ISerializer;\nimport org.apache.wicket.util.lang.Args;\nimport org.apache.wicket.util.lang.Bytes;\nimport org.apache.wicket.util.lang.Classes;\n/**\n * A store keeping a configurable maximum of pages in the session.\n * <p>\n * This store is used by {@link DefaultPageManagerProvider} as a cache in front \n * of a persistent store.\n */\npublic class InSessionPageStore extends DelegatingPageStore\n{\n\tprivate static final MetaDataKey<SessionData> KEY = new MetaDataKey<SessionData>()\n\t{\n\t\tprivate static final long serialVersionUID = 1L;\n\t};\n\tprivate final ISerializer serializer;\n\tprivate final Supplier<SessionData> dataCreator;\n\t/**\n\t * Keep {@code maxPages} in each session.\n\t * <p>\n\t * If the container serializes sessions to disk, any non-{@code SerializedPage} added to this store\n\t * will be dropped.   \n\t * \n\t * @param delegate\n\t *            store to delegate to\n\t * @param maxPages\n\t *            maximum pages to keep in session\n\t */\n\tpublic InSessionPageStore(IPageStore delegate, int maxPages)\n\t{\n\t\tthis(delegate, maxPages, null);\n\t}\n\t/**\n\t * Keep {@code maxPages} in each session.\n\t * <p>\n\t * If the container serializes sessions to disk, any non-{@code SerializedPage} added to this store\n\t * will be automatically serialized.   \n\t * \n\t * @param delegate\n\t *            store to delegate to\n\t * @param maxPages\n\t *            maximum pages to keep in session\n\t * @param serializer\n\t *            optional serializer of pages in the session\n\t */\n\tpublic InSessionPageStore(IPageStore delegate, int maxPages, ISerializer serializer)\n\t{\n\t\tthis(delegate, serializer, () -> new CountLimitedData(maxPages));\n\t}\n\t/**\n\t * Keep page up to {@code maxBytes} in each session.\n\t * <p>\n\t * All pages added to this store <em>must</em> be {@code SerializedPage}s. You can achieve this by letting\n\t * a {@link SerializingPageStore} delegate to this store.\n\t * \n\t * @param delegate\n\t *            store to delegate to\n\t * @param maxBytes\n\t *            maximum bytes to keep in session\n\t */\n\tpublic InSessionPageStore(IPageStore delegate, Bytes maxBytes)\n\t{\n\t\tthis(delegate, null, () -> new SizeLimitedData(maxBytes));\n\t}\n\tprivate InSessionPageStore(IPageStore delegate, ISerializer serializer, Supplier<SessionData> dataCreator)\n\t{\n\t\tsuper(delegate);\n\t\tthis.serializer = serializer;\n\t\tthis.dataCreator = dataCreator;\n\t}\n\t@Override\n\tpublic IManageablePage getPage(IPageContext context, int id)\n\t{\n\t\tSessionData data = getSessionData(context, false);\n\t\tif (data != null)\n\t\t{\n\t\t\tIManageablePage page = data.get(id);\n\t\t\tif (page != null)\n\t\t\t{\n\t\t\t\treturn page;\n\t\t\t}\n\t\t}\n\t\treturn getDelegate().getPage(context, id);\n\t}\n\t@Override\n\tpublic void addPage(IPageContext context, IManageablePage page)\n\t{\n\t\tSessionData data = getSessionData(context, true);\n\t\tdata.add(page);\n\t\tgetDelegate().addPage(context, page);\n\t}\n\t@Override\n\tpublic void removePage(IPageContext context, IManageablePage page)\n\t{\n\t\tSessionData data = getSessionData(context, false);\n\t\tif (data != null)\n\t\t{\n\t\t\tdata.remove(page.getPageId());\n\t\t}\n\t\tgetDelegate().removePage(context, page);\n\t}\n\t@Override\n\tpublic void removeAllPages(IPageContext context)\n\t{\n\t\tSessionData data = getSessionData(context, false);\n\t\tif (data != null)\n\t\t{\n\t\t\tdata.removeAll();\n\t\t}\n\t\tgetDelegate().removeAllPages(context);\n\t}\n\tprivate SessionData getSessionData(IPageContext context, boolean create)\n\t{\n\t\tSessionData data = context.getSessionData(KEY, () -> {\n\t\t\tif (create)\n\t\t\t{\n\t\t\t\treturn dataCreator.get();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn null;\n\t\t\t}\n\t\t});\n\t\tif (data != null && serializer != null)\n\t\t{\n\t\t\t// data might be deserialized so initialize again\n\t\t\tdata.supportSessionSerialization(serializer);\n\t\t}\n\t\treturn data;\n\t}\n\t/**\n\t * Data kept in the {@link Session}, might get serialized along with its containing\n\t * {@link HttpSession}.\n\t */\n\tstatic abstract class SessionData implements Serializable\n\t{\n\t\ttransient ISerializer serializer;\n\t\t/**\n\t\t * Pages, may partly be serialized.\n\t\t * <p>\n\t\t * Kept in list instead of map, since non-serialized pages might change their id during a request.\n\t\t */\n\t\tList<IManageablePage> pages = new LinkedList<>();\n\t\t/**\n\t\t * Call this method if session serialization should be supported, i.e. all pages get serialized along with the session.\n\t\t */\n<fim_suffix>\t\tpublic void supportSessionSerialization(ISerializer serializer)\n\t\t{\n\t\t\tthis.serializer = Args.notNull(serializer, \"serializer\");\n\t\t}\n\t\tpublic synchronized void add(IManageablePage page)\n\t\t{\n\t\t\t// move to end\n\t\t\tremove(page.getPageId());\n\t\t\tpages.add(page);\n\t\t}\n\t\tprotected synchronized void removeOldest()\n\t\t{\n\t\t\tIManageablePage page = pages.get(0);\n\t\t\tremove(page.getPageId());\n\t\t}\n\t\tpublic synchronized IManageablePage remove(int pageId)\n\t\t{\n\t\t\tIterator<IManageablePage> iterator = pages.iterator();\n\t\t\twhile (iterator.hasNext())\n\t\t\t{\n\t\t\t\tIManageablePage page = iterator.next();\n\t\t\t\tif (page.getPageId() == pageId)\n\t\t\t\t{\n\t\t\t\t\titerator.remove();\n\t\t\t\t\treturn page;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tpublic synchronized void removeAll()\n\t\t{\n\t\t\tpages.clear();\n\t\t}\n\t\tpublic synchronized IManageablePage get(int id)\n\t\t{\n\t\t\tfor (int p = 0; p < pages.size(); p++)\n\t\t\t{\n\t\t\t\tIManageablePage candidate = pages.get(p);\n\t\t\t\tif (candidate.getPageId() == id)\n\t\t\t\t{\n\t\t\t\t\tif (candidate instanceof SerializedPage && serializer != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tcandidate = (IManageablePage)serializer.deserialize(((SerializedPage)candidate).getData());\n\t\t\t\t\t\tpages.set(p, candidate);\n\t\t\t\t\t}\n\t\t\t\t\treturn candidate;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\t/**\n\t\t * Serialize pages before writing to output.\n\t\t */\n\t\tprivate void writeObject(final ObjectOutputStream output) throws IOException\n\t\t{\n\t\t\t// handle non-serialized pages\n\t\t\tfor (int p = 0; p < pages.size(); p++)\n\t\t\t{\n\t\t\t\tIManageablePage page = pages.get(p);\n\t\t\t\tif ((page instanceof SerializedPage) == false)\n\t\t\t\t{\n\t\t\t\t\tif (serializer == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tpages.remove(p);\n\t\t\t\t\t\tp--;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tpages.set(p, new SerializedPage(page.getPageId(), Classes.name(page.getClass()), serializer.serialize(page)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}<fim_middle>// function below has no smell\n"}