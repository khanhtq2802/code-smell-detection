{"text": "<fim_prefix>/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n */\npackage org.apache.bookkeeper.util.collections;\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.locks.StampedLock;\nimport java.util.function.LongPredicate;\n/**\n * Concurrent hash map from primitive long to long.\n *\n * <p>Provides similar methods as a {@code ConcurrentMap<K,V>} but since it's an open hash map with linear probing,\n * no node allocations are required to store the values.\n *\n * <p>Keys <strong>MUST</strong> be >= 0.\n */\npublic class ConcurrentLongLongHashMap {\n    private static final long EmptyKey = -1L;\n    private static final long DeletedKey = -2L;\n    private static final long ValueNotFound = -1L;\n    private static final float MapFillFactor = 0.66f;\n    private static final int DefaultExpectedItems = 256;\n    private static final int DefaultConcurrencyLevel = 16;\n    private final Section[] sections;\n    /**\n     * A Long-Long BiConsumer.\n     */\n    public interface BiConsumerLong {\n        void accept(long key, long value);\n    }\n    /**\n     * A Long-Long function.\n     */\n    public interface LongLongFunction {\n        long apply(long key);\n    }\n    /**\n     * A Long-Long predicate.\n     */\n    public interface LongLongPredicate {\n        boolean test(long key, long value);\n    }\n    public ConcurrentLongLongHashMap() {\n        this(DefaultExpectedItems);\n    }\n    public ConcurrentLongLongHashMap(int expectedItems) {\n        this(expectedItems, DefaultConcurrencyLevel);\n    }\n    public ConcurrentLongLongHashMap(int expectedItems, int concurrencyLevel) {\n        checkArgument(expectedItems > 0);\n        checkArgument(concurrencyLevel > 0);\n        checkArgument(expectedItems >= concurrencyLevel);\n        int numSections = concurrencyLevel;\n        int perSectionExpectedItems = expectedItems / numSections;\n        int perSectionCapacity = (int) (perSectionExpectedItems / MapFillFactor);\n        this.sections = new Section[numSections];\n        for (int i = 0; i < numSections; i++) {\n            sections[i] = new Section(perSectionCapacity);\n        }\n    }\n    public long size() {\n        long size = 0;\n        for (Section s : sections) {\n            size += s.size;\n        }\n        return size;\n    }\n    public long capacity() {\n        long capacity = 0;\n        for (Section s : sections) {\n            capacity += s.capacity;\n        }\n        return capacity;\n    }\n    public boolean isEmpty() {\n        for (Section s : sections) {\n            if (s.size != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    long getUsedBucketCount() {\n        long usedBucketCount = 0;\n        for (Section s : sections) {\n            usedBucketCount += s.usedBuckets;\n        }\n        return usedBucketCount;\n    }\n    /**\n     *\n     * @param key\n     * @return the value or -1 if the key was not present\n     */\n    public long get(long key) {\n        checkBiggerEqualZero(key);\n        long h = hash(key);\n        return getSection(h).get(key, (int) h);\n    }\n    public boolean containsKey(long key) {\n        return get(key) != ValueNotFound;\n    }\n    public long put(long key, long value) {\n        checkBiggerEqualZero(key);\n        checkBiggerEqualZero(value);\n        long h = hash(key);\n        return getSection(h).put(key, value, (int) h, false, null);\n    }\n    public long putIfAbsent(long key, long value) {\n        checkBiggerEqualZero(key);\n        checkBiggerEqualZero(value);\n        long h = hash(key);\n        return getSection(h).put(key, value, (int) h, true, null);\n    }\n<fim_suffix>    public long computeIfAbsent(long key, LongLongFunction provider) {\n        checkBiggerEqualZero(key);\n        checkNotNull(provider);\n        long h = hash(key);\n        return getSection(h).put(key, ValueNotFound, (int) h, true, provider);\n    }\n    /**\n     * Atomically add the specified delta to a current value identified by the key. If the entry was not in the map, a\n     * new entry with default value 0 is added and then the delta is added.\n     *\n     * @param key\n     *            the entry key\n     * @param delta\n     *            the delta to add\n     * @return the new value of the entry\n     * @throws IllegalArgumentException\n     *             if the delta was invalid, such as it would have caused the value to be < 0\n     */\n    public long addAndGet(long key, long delta) {\n        checkBiggerEqualZero(key);\n        long h = hash(key);\n        return getSection(h).addAndGet(key, delta, (int) h);\n    }\n    /**\n     * Change the value for a specific key only if it matches the current value.\n     *\n     * @param key\n     * @param currentValue\n     * @param newValue\n     * @return\n     */\n    public boolean compareAndSet(long key, long currentValue, long newValue) {\n        checkBiggerEqualZero(key);\n        checkBiggerEqualZero(newValue);\n        long h = hash(key);\n        return getSection(h).compareAndSet(key, currentValue, newValue, (int) h);\n    }\n    /**\n     * Remove an existing entry if found.\n     *\n     * @param key\n     * @return the value associated with the key or -1 if key was not present\n     */\n    public long remove(long key) {\n        checkBiggerEqualZero(key);\n        long h = hash(key);\n        return getSection(h).remove(key, ValueNotFound, (int) h);\n    }\n    public boolean remove(long key, long value) {\n        checkBiggerEqualZero(key);\n        checkBiggerEqualZero(value);\n        long h = hash(key);\n        return getSection(h).remove(key, value, (int) h) != ValueNotFound;\n    }\n    public int removeIf(LongPredicate filter) {\n        checkNotNull(filter);\n        int removedCount = 0;\n        for (Section s : sections) {\n            removedCount += s.removeIf(filter);\n        }\n        return removedCount;\n    }\n    public int removeIf(LongLongPredicate filter) {\n        checkNotNull(filter);\n        int removedCount = 0;\n        for (Section s : sections) {\n            removedCount += s.removeIf(filter);\n        }\n        return removedCount;\n    }\n    private Section getSection(long hash) {\n        // Use 32 msb out of long to get the section\n        final int sectionIdx = (int) (hash >>> 32) & (sections.length - 1);\n        return sections[sectionIdx];\n    }\n    public void clear() {\n        for (Section s : sections) {\n            s.clear();\n        }\n    }\n    public void forEach(BiConsumerLong processor) {\n        for (Section s : sections) {\n            s.forEach(processor);\n        }\n    }\n    /**\n     * @return a new list of all keys (makes a copy)\n     */\n    public List<Long> keys() {\n        List<Long> keys = Lists.newArrayList();\n        forEach((key, value) -> keys.add(key));\n        return keys;\n    }\n    public List<Long> values() {\n        List<Long> values = Lists.newArrayList();\n        forEach((key, value) -> values.add(value));\n        return values;\n    }\n    public Map<Long, Long> asMap() {\n        Map<Long, Long> map = Maps.newHashMap();\n        forEach((key, value) -> map.put(key, value));\n        return map;\n    }\n    // A section is a portion of the hash map that is covered by a single\n    @SuppressWarnings(\"serial\")\n    private static final class Section extends StampedLock {\n        // Keys and values are stored interleaved in the table array\n        private volatile long[] table;<fim_middle>// function below has no smell\n"}