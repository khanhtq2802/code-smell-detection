{"text": "<fim_prefix>\n<fim_suffix>public class TupleImpl extends IndifferentAccessMap implements Seqable, Indexed, IMeta, Tuple {\n    private List<Object> values;\n    private int taskId;\n    private String streamId;\n    private GeneralTopologyContext context;\n    private MessageId id;\n    private IPersistentMap _meta = null;\n    Long _processSampleStartTime = null;\n    Long _executeSampleStartTime = null;\n    long _outAckVal = 0;\n    public TupleImpl() {\n    }\n    public TupleImpl(GeneralTopologyContext context, List<Object> values, int taskId, String streamId, MessageId id) {\n        this.values = values;\n        this.taskId = taskId;\n        this.streamId = streamId;\n        this.id = id;\n        this.context = context;\n        /*\n        String componentId = context.getComponentId(taskId);\n        Fields schema = context.getComponentOutputFields(componentId, streamId);\n        if (values.size() != schema.size()) {\n            throw new IllegalArgumentException(\"Tuple created with wrong number of fields. \" + \"Expected \" + schema.size() + \" fields but got \" + values.size()\n                    + \" fields\");\n        }*/\n    }\n    public TupleImpl(GeneralTopologyContext context, List<Object> values, int taskId, String streamId) {\n        this(context, values, taskId, streamId, MessageId.makeUnanchored());\n    }\n    public void setProcessSampleStartTime(long ms) {\n        _processSampleStartTime = ms;\n    }\n    public Long getProcessSampleStartTime() {\n        return _processSampleStartTime;\n    }\n    public void setExecuteSampleStartTime(long ms) {\n        _executeSampleStartTime = ms;\n    }\n    public Long getExecuteSampleStartTime() {\n        return _executeSampleStartTime;\n    }\n    public void updateAckVal(long val) {\n        _outAckVal = _outAckVal ^ val;\n    }\n    public long getAckVal() {\n        return _outAckVal;\n    }\n    public int size() {\n        return values.size();\n    }\n    public int fieldIndex(String field) {\n        return getFields().fieldIndex(field);\n    }\n    public boolean contains(String field) {\n        return getFields().contains(field);\n    }\n    public Object getValue(int i) {\n        return values.get(i);\n    }\n    public String getString(int i) {\n        return (String) values.get(i);\n    }\n    public Integer getInteger(int i) {\n        return (Integer) values.get(i);\n    }\n    public Long getLong(int i) {\n        return (Long) values.get(i);\n    }\n    public Boolean getBoolean(int i) {\n        return (Boolean) values.get(i);\n    }\n    public Short getShort(int i) {\n        return (Short) values.get(i);\n    }\n    public Byte getByte(int i) {\n        return (Byte) values.get(i);\n    }\n    public Double getDouble(int i) {\n        return (Double) values.get(i);\n    }\n    public Float getFloat(int i) {\n        return (Float) values.get(i);\n    }\n    public byte[] getBinary(int i) {\n        return (byte[]) values.get(i);\n    }\n    public Object getValueByField(String field) {\n        return values.get(fieldIndex(field));\n    }\n    public String getStringByField(String field) {\n        return (String) values.get(fieldIndex(field));\n    }\n    public Integer getIntegerByField(String field) {\n        return (Integer) values.get(fieldIndex(field));\n    }\n    public Long getLongByField(String field) {\n        return (Long) values.get(fieldIndex(field));\n    }\n    public Boolean getBooleanByField(String field) {\n        return (Boolean) values.get(fieldIndex(field));\n    }\n    public Short getShortByField(String field) {\n        return (Short) values.get(fieldIndex(field));\n    }\n    public Byte getByteByField(String field) {\n        return (Byte) values.get(fieldIndex(field));\n    }\n    public Double getDoubleByField(String field) {\n        return (Double) values.get(fieldIndex(field));\n    }\n    public Float getFloatByField(String field) {\n        return (Float) values.get(fieldIndex(field));\n    }\n    public byte[] getBinaryByField(String field) {\n        return (byte[]) values.get(fieldIndex(field));\n    }\n    public List<Object> getValues() {\n        return values;\n    }\n    public Fields getFields() {\n        return context.getComponentOutputFields(getSourceComponent(), getSourceStreamId());\n    }\n    public List<Object> select(Fields selector) {\n        return getFields().select(selector, values);\n    }\n    public GlobalStreamId getSourceGlobalStreamid() {\n        return new GlobalStreamId(getSourceComponent(), streamId);\n    }\n    public String getSourceComponent() {\n        return context.getComponentId(taskId);\n    }\n    public int getSourceTask() {\n        return taskId;\n    }\n    public String getSourceStreamId() {\n        return streamId;\n    }\n    public MessageId getMessageId() {\n        return id;\n    }\n    @Override\n    public String toString() {\n        return \"source: \" + getSourceComponent() + \":\" + taskId + \", stream: \" + streamId + \", id: \" + id.toString() + \", \" + values.toString();\n    }\n    @Override\n    public boolean equals(Object other) {\n        return this == other;\n    }\n    @Override\n    public int hashCode() {\n        return System.identityHashCode(this);\n    }\n    private Keyword makeKeyword(String name) {\n        return Keyword.intern(Symbol.create(name));\n    }\n    /* ILookup */\n    @Override\n    public Object valAt(Object o) {\n        try {\n            if (o instanceof Keyword) {\n                return getValueByField(((Keyword) o).getName());\n            } else if (o instanceof String) {\n                return getValueByField((String) o);\n            }\n        } catch (IllegalArgumentException ignored) {\n        }\n        return null;\n    }\n    /* Seqable */\n    public ISeq seq() {\n        if (values.size() > 0) {\n            return new Seq(getFields().toList(), values, 0);\n        }\n        return null;\n    }\n    static class Seq extends ASeq implements Counted {\n        final List<String> fields;\n        final List<Object> values;\n        final int i;\n        Seq(List<String> fields, List<Object> values, int i) {\n            this.fields = fields;\n            this.values = values;\n            assert i >= 0;\n            this.i = i;\n        }\n        public Seq(IPersistentMap meta, List<String> fields, List<Object> values, int i) {\n            super(meta);\n            this.fields = fields;\n            this.values = values;\n            assert i >= 0;\n            this.i = i;\n        }\n        public Object first() {\n            return new MapEntry(fields.get(i), values.get(i));\n        }\n        public ISeq next() {\n            if (i + 1 < fields.size()) {\n                return new Seq(fields, values, i + 1);\n            }\n            return null;\n        }\n        public int count() {\n            assert fields.size() - i >= 0 : \"index out of bounds\";\n            // i being the position in the fields of this seq, the remainder of the seq is the size\n            return fields.size() - i;\n        }\n        public Obj withMeta(IPersistentMap meta) {\n            return new Seq(meta, fields, values, i);\n        }\n    }\n    /* Indexed */\n    public Object nth(int i) {\n        if (i < values.size()) {\n            return values.get(i);\n        } else {\n            return null;\n        }\n    }\n    public Object nth(int i, Object notfound) {\n        Object ret = nth(i);\n        if (ret == null)\n            ret = notfound;\n        return ret;\n    }\n    /* Counted */\n    public int count() {\n        return values.size();\n    }\n    /* IMeta */\n    public IPersistentMap meta() {\n        if (_meta == null) {\n            _meta = new PersistentArrayMap(new Object[]{makeKeyword(\"stream\"), getSourceStreamId(),\n                    makeKeyword(\"component\"), getSourceComponent(), makeKeyword(\"task\"), getSourceTask()});\n        }\n        return _meta;\n    }\n    private PersistentArrayMap toMap() {\n        Object array[] = new Object[values.size() * 2];\n        List<String> fields = getFields().toList();\n        for (int i = 0; i < values.size(); i++) {\n            array[i * 2] = fields.get(i);\n            array[(i * 2) + 1] = values.get(i);\n        }\n        return new PersistentArrayMap(array);\n    }\n    public IPersistentMap getMap() {\n        if (_map == null) {\n            setMap(toMap());\n        }\n        return _map;\n    }\n    public void setTopologyContext(GeneralTopologyContext context) {\n        this.context = context;\n    }<fim_middle>// class below is data class\n"}