{"text": "<fim_prefix>/****************************************************************\n * Licensed to the Apache Software Foundation (ASF) under one   *\n * or more contributor license agreements.  See the NOTICE file *\n * distributed with this work for additional information        *\n * regarding copyright ownership.  The ASF licenses this file   *\n * to you under the Apache License, Version 2.0 (the            *\n * \"License\"); you may not use this file except in compliance   *\n * with the License.  You may obtain a copy of the License at   *\n *                                                              *\n *   http://www.apache.org/licenses/LICENSE-2.0                 *\n *                                                              *\n * Unless required by applicable law or agreed to in writing,   *\n * software distributed under the License is distributed on an  *\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *\n * KIND, either express or implied.  See the License for the    *\n * specific language governing permissions and limitations      *\n * under the License.                                           *\n ****************************************************************/\npackage org.apache.james.mailbox.cassandra.mail;\nimport static com.datastax.driver.core.querybuilder.QueryBuilder.bindMarker;\nimport static com.datastax.driver.core.querybuilder.QueryBuilder.eq;\nimport static com.datastax.driver.core.querybuilder.QueryBuilder.insertInto;\nimport static com.datastax.driver.core.querybuilder.QueryBuilder.select;\nimport static com.datastax.driver.core.querybuilder.QueryBuilder.set;\nimport static com.datastax.driver.core.querybuilder.QueryBuilder.update;\nimport static org.apache.james.mailbox.cassandra.table.CassandraMessageModseqTable.MAILBOX_ID;\nimport static org.apache.james.mailbox.cassandra.table.CassandraMessageModseqTable.NEXT_MODSEQ;\nimport static org.apache.james.mailbox.cassandra.table.CassandraMessageModseqTable.TABLE_NAME;\nimport java.time.Duration;\nimport java.util.Optional;\nimport java.util.concurrent.CompletionException;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\nimport javax.inject.Inject;\nimport org.apache.james.backends.cassandra.init.configuration.CassandraConfiguration;\nimport org.apache.james.backends.cassandra.utils.CassandraAsyncExecutor;\nimport org.apache.james.mailbox.MailboxSession;\nimport org.apache.james.mailbox.cassandra.ids.CassandraId;\nimport org.apache.james.mailbox.exception.MailboxException;\nimport org.apache.james.mailbox.model.MailboxId;\nimport org.apache.james.mailbox.store.mail.ModSeqProvider;\nimport org.apache.james.mailbox.store.mail.model.Mailbox;\nimport org.apache.james.util.FunctionalUtils;\nimport com.datastax.driver.core.PreparedStatement;\nimport com.datastax.driver.core.Session;\nimport com.google.common.base.MoreObjects;\nimport reactor.core.publisher.Mono;\npublic class CassandraModSeqProvider implements ModSeqProvider {\n    public static final String MOD_SEQ_CONDITION = \"modSeqCondition\";\n    private final long maxModSeqRetries;\n    public static class ExceptionRelay extends RuntimeException {\n        private final MailboxException underlying;\n        public ExceptionRelay(MailboxException underlying) {\n            super(underlying);\n            this.underlying = underlying;\n        }\n        public MailboxException getUnderlying() {\n            return underlying;\n        }\n    }\n    private static <T> T unbox(Supplier<T> supplier) throws MailboxException {\n        try {\n            return supplier.get();\n        } catch (CompletionException e) {\n            if (e.getCause() instanceof ExceptionRelay) {\n                throw ((ExceptionRelay) e.getCause()).getUnderlying();\n            }\n            throw e;\n        }\n    }\n    private static final ModSeq FIRST_MODSEQ = new ModSeq(0);\n    private final CassandraAsyncExecutor cassandraAsyncExecutor;\n    private final PreparedStatement select;\n    private final PreparedStatement update;\n    private final PreparedStatement insert;\n    @Inject\n    public CassandraModSeqProvider(Session session, CassandraConfiguration cassandraConfiguration) {\n        this.cassandraAsyncExecutor = new CassandraAsyncExecutor(session);\n        this.maxModSeqRetries = cassandraConfiguration.getModSeqMaxRetry();\n        this.insert = prepareInsert(session);\n        this.update = prepareUpdate(session);\n        this.select = prepareSelect(session);\n    }\n    private PreparedStatement prepareInsert(Session session) {\n        return session.prepare(insertInto(TABLE_NAME)\n            .value(NEXT_MODSEQ, bindMarker(NEXT_MODSEQ))\n            .value(MAILBOX_ID, bindMarker(MAILBOX_ID))\n            .ifNotExists());\n    }\n    private PreparedStatement prepareUpdate(Session session) {\n        return session.prepare(update(TABLE_NAME)\n            .onlyIf(eq(NEXT_MODSEQ, bindMarker(MOD_SEQ_CONDITION)))\n            .with(set(NEXT_MODSEQ, bindMarker(NEXT_MODSEQ)))\n            .where(eq(MAILBOX_ID, bindMarker(MAILBOX_ID))));\n    }\n    private PreparedStatement prepareSelect(Session session) {\n        return session.prepare(select(NEXT_MODSEQ)\n            .from(TABLE_NAME)\n            .where(eq(MAILBOX_ID, bindMarker(MAILBOX_ID))));\n    }\n    @Override\n    public long nextModSeq(MailboxSession mailboxSession, Mailbox mailbox) throws MailboxException {\n        CassandraId mailboxId = (CassandraId) mailbox.getMailboxId();\n        return nextModSeq(mailboxId)\n            .blockOptional()\n            .orElseThrow(() -> new MailboxException(\"Can not retrieve modseq for \" + mailboxId));\n    }\n    @Override\n    public long nextModSeq(MailboxSession session, MailboxId mailboxId) throws MailboxException {\n        return nextModSeq((CassandraId) mailboxId)\n            .blockOptional()\n            .orElseThrow(() -> new MailboxException(\"Can not retrieve modseq for \" + mailboxId));\n    }\n    @Override\n    public long highestModSeq(MailboxSession mailboxSession, Mailbox mailbox) throws MailboxException {\n        return highestModSeq(mailboxSession, mailbox.getMailboxId());\n    }\n    @Override\n    public long highestModSeq(MailboxSession mailboxSession, MailboxId mailboxId) throws MailboxException {\n        return unbox(() -> findHighestModSeq((CassandraId) mailboxId).block().orElse(FIRST_MODSEQ).getValue());\n    }\n    private Mono<Optional<ModSeq>> findHighestModSeq(CassandraId mailboxId) {\n        return cassandraAsyncExecutor.executeSingleRowOptional(\n            select.bind()\n                .setUUID(MAILBOX_ID, mailboxId.asUuid()))\n            .map(maybeRow -> maybeRow.map(row -> new ModSeq(row.getLong(NEXT_MODSEQ))));\n    }\n    private Mono<ModSeq> tryInsertModSeq(CassandraId mailboxId, ModSeq modSeq) {\n        ModSeq nextModSeq = modSeq.next();\n        return cassandraAsyncExecutor.executeReturnApplied(\n            insert.bind()\n                .setUUID(MAILBOX_ID, mailboxId.asUuid())\n                .setLong(NEXT_MODSEQ, nextModSeq.getValue()))\n            .flatMap(success -> successToModSeq(nextModSeq, success));\n    }\n<fim_suffix>    private Mono<ModSeq> tryUpdateModSeq(CassandraId mailboxId, ModSeq modSeq) {\n        ModSeq nextModSeq = modSeq.next();\n        return cassandraAsyncExecutor.executeReturnApplied(\n            update.bind()\n                .setUUID(MAILBOX_ID, mailboxId.asUuid())\n                .setLong(NEXT_MODSEQ, nextModSeq.getValue())\n                .setLong(MOD_SEQ_CONDITION, modSeq.getValue()))\n            .flatMap(success -> successToModSeq(nextModSeq, success));\n    }\n    private Mono<ModSeq> successToModSeq(ModSeq modSeq, Boolean success) {\n        return Mono.just(success)\n            .filter(FunctionalUtils.toPredicate(Function.identity()))\n            .map(any -> modSeq);\n    }\n    public Mono<Long> nextModSeq(CassandraId mailboxId) {\n        return findHighestModSeq(mailboxId)\n            .flatMap(maybeHighestModSeq -> maybeHighestModSeq\n                        .map(highestModSeq -> tryUpdateModSeq(mailboxId, highestModSeq))\n                        .orElseGet(() -> tryInsertModSeq(mailboxId, FIRST_MODSEQ)))\n            .switchIfEmpty(handleRetries(mailboxId))\n            .map(ModSeq::getValue);\n    }\n    private Mono<ModSeq> handleRetries(CassandraId mailboxId) {\n        return tryFindThenUpdateOnce(mailboxId)\n            .single()\n            .retryBackoff(maxModSeqRetries, Duration.ofMillis(2));\n    }\n    private Mono<ModSeq> tryFindThenUpdateOnce(CassandraId mailboxId) {\n        return Mono.defer(() -> findHighestModSeq(mailboxId)\n            .flatMap(Mono::justOrEmpty)\n            .flatMap(highestModSeq -> tryUpdateModSeq(mailboxId, highestModSeq)));\n    }<fim_middle>// function below has no smell\n"}