{"text": "<fim_prefix>            }\n            performMaintenanceStage(post, stage, deadline);\n        } catch (Exception e) {\n            log(Level.SEVERE, \"Uncaught exception: %s\", Utils.toString(e));\n            post.fail(e);\n        }\n    }\n    private void performNodeSelectorChangeMaintenance(Operation post, long now,\n            MaintenanceStage nextStage, boolean isCheckRequired, long deadline) {\n        this.serviceSynchTracker.performNodeSelectorChangeMaintenance(post, now, nextStage,\n                isCheckRequired, deadline);\n    }\n    private void performIOMaintenance(Operation post, long now, MaintenanceStage nextStage,\n            long deadline) {\n        try {\n            this.operationTracker.performMaintenance(now);\n            performMaintenanceStage(post, nextStage, deadline);\n        } catch (Exception e) {\n            log(Level.WARNING, \"Exception: %s\", Utils.toString(e));\n            performMaintenanceStage(post, nextStage, deadline);\n        }\n    }\n    public ServiceHost setOperationTimeOutMicros(long timeoutMicros) {\n        this.state.operationTimeoutMicros = timeoutMicros;\n        return this;\n    }\n    public ServiceHost setServiceCacheClearDelayMicros(long delayMicros) {\n        this.state.serviceCacheClearDelayMicros = delayMicros;\n        return this;\n    }\n    public long getServiceCacheClearDelayMicros() {\n        return this.state.serviceCacheClearDelayMicros;\n    }\n    public ServiceHost setProcessOwner(boolean isOwner) {\n        this.state.isProcessOwner = isOwner;\n        return this;\n    }\n    public boolean isProcessOwner() {\n        return this.state.isProcessOwner;\n    }\n    public void setListener(ServiceRequestListener listener) {\n        if (isStarted() || this.httpListener != null) {\n            throw new IllegalStateException(\"Already started\");\n        }\n        this.httpListener = listener;\n    }\n    public ServiceRequestListener getSecureListener() {\n        return this.httpsListener;\n    }\n    public void setSecureListener(ServiceRequestListener listener) {\n        if (isStarted() || this.httpsListener != null) {\n            throw new IllegalStateException(\"Already started\");\n        }\n        this.httpsListener = listener;\n    }\n    public ServiceRequestListener getListener() {\n        return this.httpListener;\n    }\n    public ServiceClient getClient() {\n        return this.client;\n    }\n    public void setClient(ServiceClient client) {\n        this.client = client;\n    }\n    protected void saveServiceState(Service s, Operation op, ServiceDocument state) {\n        // If this request doesn't originate from replication (which might happen asynchronously, i.e. through\n        // (re-)synchronization after a node group change), don't update the documentAuthPrincipalLink because\n        // it will be set to the system user. The specified state is expected to have the documentAuthPrincipalLink\n        // set from when it was first saved.\n        if (!op.isFromReplication()) {\n            state.documentAuthPrincipalLink = op.getAuthorizationContext() != null\n                    ? op.getAuthorizationContext().getClaims().getSubject() : null;\n        }\n        if (this.transactionService != null) {\n            state.documentTransactionId = op.getTransactionId();\n        }\n        if (!op.isSynchronizePeer()) {\n            // a synch-peer request already has the correct documentUpdateAction\n            // in its body\n            state.documentUpdateAction = op.getAction().name();\n        }\n        if (!isServiceIndexed(s)) {\n            cacheServiceState(s, state, op);\n            op.complete();\n            return;\n        }\n        Service indexService = getIndexServiceForService(s);\n        // serialize state and compute signature. The index service will take\n        // the serialized state and store as is, and it will index all fields\n        // from the document instance, using the description for instructions\n        UpdateIndexRequest body = new UpdateIndexRequest();\n        body.document = state;\n        // retrieve the description through the cached template so its the thread safe,\n        // immutable version\n        body.description = buildDocumentDescription(s);\n        body.serializedDocument = op.getLinkedSerializedState();\n        op.linkSerializedState(null);\n        ServiceDocument previousState = this.serviceResourceTracker.getCachedServiceState(s, op);\n        cacheServiceState(s, state, op);\n        Operation post = Operation.createPost(indexService.getUri())\n                .setBodyNoCloning(body)\n                .setCompletion((o, e) -> {\n                    if (op.getAction() == Action.DELETE) {\n                        unmarkAsPendingDelete(s);\n                    }\n                    if (e != null) {\n                        if (previousState != null) {\n                            this.serviceResourceTracker.resetCachedServiceState(s, previousState, op);\n                        } else {\n                            this.serviceResourceTracker.clearCachedServiceState(s, op);\n                        }\n                        op.fail(e);\n                        return;\n                    }\n                    op.complete();\n                });\n        if (op.getAction() == Action.POST\n                && op.hasPragmaDirective(Operation.PRAGMA_DIRECTIVE_FORCE_INDEX_UPDATE)) {\n            post.addPragmaDirective(Operation.PRAGMA_DIRECTIVE_FORCE_INDEX_UPDATE);\n        }\n        // Just like we do in loadServiceState, special case co-located indexing service and bypass\n        // normal processing path, to reduce latency. The call is still assumed to be asynchronous\n        // and the request can be processed in arbitrary thread context.\n        indexService.handleRequest(post);\n    }\n    /**\n     * Infrastructure use only\n     * @see ServiceSynchronizationTracker#selectServiceOwnerAndSynchState(Service, Operation)\n     */\n    void selectServiceOwnerAndSynchState(Service s, Operation op) {\n        this.serviceSynchTracker.selectServiceOwnerAndSynchState(s, op);\n    }\n    /**\n     * Find {@link NodeSelectorService} from given or default path.\n     *\n     * @param path    path to the NodeSelectorService. default path is used when it is null. Nullable.\n     * @param request passed operation is failed if no service is found on the path. Nullable.\n     * @return a node selector service\n     */\n    NodeSelectorService findNodeSelectorService(String path, Operation request) {\n        if (path == null) {\n            path = ServiceUriPaths.DEFAULT_NODE_SELECTOR;\n        }\n        Service s = this.findService(path);\n        if (s == null) {\n            if (request != null) {\n                request.fail(new ServiceNotFoundException());\n            }\n            return null;\n        }\n        return (NodeSelectorService) s;\n    }\n    public void broadcastRequest(String selectorPath, boolean excludeThisHost, Operation request) {\n        broadcastRequest(selectorPath, null, excludeThisHost, request);\n    }\n    public void broadcastRequest(String selectorPath, String key, boolean excludeThisHost,\n            Operation request) {\n        if (isStopping()) {\n            request.fail(new CancellationException(\"Host is stopping\"));\n            return;\n        }\n        if (selectorPath == null) {\n            throw new IllegalArgumentException(\"selectorPath is required\");\n        }\n        if (request == null) {\n            throw new IllegalArgumentException(\"request is required\");\n        }\n        prepareRequest(request);\n        NodeSelectorService nss = findNodeSelectorService(selectorPath, request);\n        if (nss == null) {\n            return;\n        }\n        SelectAndForwardRequest req = new SelectAndForwardRequest();\n        req.options = SelectAndForwardRequest.BROADCAST_OPTIONS;\n        if (excludeThisHost) {\n            req.options = SelectAndForwardRequest.BROADCAST_OPTIONS_EXCLUDE_ENTRY_NODE;\n            req.options.add(ForwardingOption.EXCLUDE_ENTRY_NODE);\n        }\n        req.key = key;\n        req.targetPath = request.getUri().getPath();\n        req.targetQuery = request.getUri().getQuery();\n        nss.selectAndForward(request, req);\n    }\n    private ThreadLocal<SelectAndForwardRequest> selectOwnerRequests = ThreadLocal\n            .withInitial(SelectAndForwardRequest::new);\n    /**\n     * Convenience method that issues a {@code SelectOwnerRequest} to the node selector service. If\n     * the supplied path is null the default selector will be used\n     */\n<fim_suffix>    public void selectOwner(String selectorPath, String key, Operation op) {\n        if (isStopping()) {\n            op.fail(new CancellationException(\"Host is stopping\"));\n            return;\n        }\n        SelectAndForwardRequest body = this.selectOwnerRequests.get();\n        body.key = key;\n        NodeSelectorService nss = findNodeSelectorService(selectorPath, op);\n        if (nss == null) {\n            return;\n        }\n        nss.selectAndForward(op, body);\n    }<fim_middle>// function below has no smell\n"}