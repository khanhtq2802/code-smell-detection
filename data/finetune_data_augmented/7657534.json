{"text": "<fim_prefix>\t\treturn requireResponse(vaultOperations.doWithVault(restOperations -> {\n\t\t\tResponseEntity<VaultUnsealStatusImpl> response = restOperations.exchange(\n\t\t\t\t\t\"sys/unseal\", HttpMethod.PUT,\n\t\t\t\t\tnew HttpEntity<Object>(Collections.singletonMap(\"key\", keyShare)),\n\t\t\t\t\tVaultUnsealStatusImpl.class);\n\t\t\tAssert.state(response.getBody() != null, \"Unseal response must not be null\");\n\t\t\treturn response.getBody();\n\t\t}));\n\t}\n\t@Override\n\tpublic VaultUnsealStatus getUnsealStatus() {\n\t\treturn requireResponse(vaultOperations.doWithVault(GET_UNSEAL_STATUS));\n\t}\n\t@Override\n\tpublic void mount(String path, VaultMount vaultMount) {\n\t\tAssert.hasText(path, \"Path must not be empty\");\n\t\tAssert.notNull(vaultMount, \"VaultMount must not be null\");\n\t\tvaultOperations.write(String.format(\"sys/mounts/%s\", path), vaultMount);\n\t}\n\t@Override\n\tpublic Map<String, VaultMount> getMounts() {\n\t\treturn requireResponse(vaultOperations.doWithSession(GET_MOUNTS));\n\t}\n\t@Override\n\tpublic void unmount(String path) {\n\t\tAssert.hasText(path, \"Path must not be empty\");\n\t\tvaultOperations.delete(String.format(\"sys/mounts/%s\", path));\n\t}\n\t@Override\n\tpublic void authMount(String path, VaultMount vaultMount)\n\t\t\tthrows VaultException {\n\t\tAssert.hasText(path, \"Path must not be empty\");\n\t\tAssert.notNull(vaultMount, \"VaultMount must not be null\");\n\t\tvaultOperations.write(String.format(\"sys/auth/%s\", path), vaultMount);\n\t}\n\t@Override\n\tpublic Map<String, VaultMount> getAuthMounts() throws VaultException {\n\t\treturn requireResponse(vaultOperations.doWithSession(GET_AUTH_MOUNTS));\n\t}\n\t@Override\n\tpublic void authUnmount(String path) throws VaultException {\n\t\tAssert.hasText(path, \"Path must not be empty\");\n\t\tvaultOperations.delete(String.format(\"sys/auth/%s\", path));\n\t}\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic List<String> getPolicyNames() throws VaultException {\n\t\treturn requireResponse((List<String>) vaultOperations.read(\"sys/policy\")\n\t\t\t\t.getRequiredData().get(\"policies\"));\n\t}\n\t@Nullable\n\t@Override\n\tpublic Policy getPolicy(String name) throws VaultException {\n\t\tAssert.hasText(name, \"Name must not be null or empty\");\n\t\treturn vaultOperations.doWithSession(restOperations -> {\n\t\t\tResponseEntity<VaultResponse> response;\n\t\t\ttry {\n\t\t\t\tresponse = restOperations.getForEntity(\"sys/policy/{name}\",\n\t\t\t\t\t\tVaultResponse.class, name);\n\t\t\t}\n\t\t\tcatch (HttpStatusCodeException e) {\n\t\t\t\tif (e.getStatusCode() == HttpStatus.NOT_FOUND) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t\tString rules = (String) response.getBody().getRequiredData().get(\"rules\");\n\t\t\tif (StringUtils.isEmpty(rules)) {\n\t\t\t\treturn Policy.empty();\n\t\t\t}\n\t\t\tif (rules.trim().startsWith(\"{\")) {\n\t\t\t\treturn VaultResponses.unwrap(rules, Policy.class);\n\t\t\t}\n\t\t\tthrow new UnsupportedOperationException(\"Cannot parse policy in HCL format\");\n\t\t});\n\t}\n\t@Override\n\tpublic void createOrUpdatePolicy(String name, Policy policy) throws VaultException {\n\t\tAssert.hasText(name, \"Name must not be null or empty\");\n\t\tAssert.notNull(policy, \"Policy must not be null\");\n\t\tString rules;\n\t\ttry {\n\t\t\trules = OBJECT_MAPPER.writeValueAsString(policy);\n\t\t}\n\t\tcatch (IOException e) {\n\t\t\tthrow new VaultException(\"Cannot serialize policy to JSON\", e);\n\t\t}\n\t\tvaultOperations.doWithSession(restOperations -> {\n\t\t\trestOperations.exchange(\"sys/policy/{name}\", HttpMethod.PUT,\n\t\t\t\t\tnew HttpEntity<>(Collections.singletonMap(\"rules\", rules)),\n\t\t\t\t\tVaultResponse.class, name);\n\t\t\treturn null;\n\t\t});\n\t}\n\t@Override\n\tpublic void deletePolicy(String name) throws VaultException {\n\t\tAssert.hasText(name, \"Name must not be null or empty\");\n\t\tvaultOperations.delete(String.format(\"sys/policy/%s\", name));\n\t}\n\t@Override\n\tpublic VaultHealth health() {\n\t\treturn requireResponse(vaultOperations.doWithVault(HEALTH));\n\t}\n\tprivate static <T> T requireResponse(@Nullable T response) {\n\t\tAssert.state(response != null, \"Response must not be null\");\n\t\treturn response;\n\t}\n\tprivate static class GetUnsealStatus implements\n\t\t\tRestOperationsCallback<VaultUnsealStatus> {\n\t\t@Override\n\t\tpublic VaultUnsealStatus doWithRestOperations(RestOperations restOperations) {\n\t\t\treturn restOperations.getForObject(\"sys/seal-status\",\n\t\t\t\t\tVaultUnsealStatusImpl.class);\n\t\t}\n\t}\n\tprivate static class Seal implements RestOperationsCallback<Void> {\n\t\t@Override\n\t\tpublic Void doWithRestOperations(RestOperations restOperations) {\n\t\t\trestOperations.put(\"sys/seal\", null);\n\t\t\treturn null;\n\t\t}\n\t}\n\tprivate static class GetMounts implements\n\t\t\tRestOperationsCallback<Map<String, VaultMount>> {\n\t\tprivate static final ParameterizedTypeReference<VaultMountsResponse> MOUNT_TYPE_REF = new ParameterizedTypeReference<VaultMountsResponse>() {\n\t\t};\n\t\tprivate final String path;\n\t\tGetMounts(String path) {\n\t\t\tthis.path = path;\n\t\t}\n\t\t@Override\n\t\tpublic Map<String, VaultMount> doWithRestOperations(RestOperations restOperations) {\n\t\t\tResponseEntity<VaultMountsResponse> exchange = restOperations.exchange(path,\n\t\t\t\t\tHttpMethod.GET, null, MOUNT_TYPE_REF, Collections.emptyMap());\n\t\t\tVaultMountsResponse body = exchange.getBody();\n\t\t\tAssert.state(body != null, \"Get mounts response must not be null\");\n\t\t\tif (body.getData() != null) {\n\t\t\t\treturn body.getData();\n\t\t\t}\n\t\t\treturn body.getTopLevelMounts();\n\t\t}\n\t\tprivate static class VaultMountsResponse extends\n\t\t\t\tVaultResponseSupport<Map<String, VaultMount>> {\n\t\t\tprivate Map<String, VaultMount> topLevelMounts = new HashMap<>();\n\t\t\t@JsonIgnore\n\t\t\tpublic Map<String, VaultMount> getTopLevelMounts() {\n\t\t\t\treturn topLevelMounts;\n\t\t\t}\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t@JsonAnySetter\n\t\t\tpublic void set(String name, Object value) {\n\t\t\t\tif (!(value instanceof Map)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tMap<String, Object> map = (Map) value;\n\t\t\t\tif (map.containsKey(\"type\")) {\n\t\t\t\t\tVaultMountBuilder builder = VaultMount.builder() //\n\t\t\t\t\t\t\t.type((String) map.get(\"type\")) //\n\t\t\t\t\t\t\t.description((String) map.get(\"description\"));// ;\n\t\t\t\t\tif (map.containsKey(\"config\")) {\n\t\t\t\t\t\tbuilder.config((Map) map.get(\"config\"));\n\t\t\t\t\t}\n\t\t\t\t\tVaultMount vaultMount = builder.build();\n\t\t\t\t\ttopLevelMounts.put(name, vaultMount);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprivate static class Health implements RestOperationsCallback<VaultHealth> {\n\t\t@Override\n\t\tpublic VaultHealth doWithRestOperations(RestOperations restOperations) {\n\t\t\ttry {\n\t\t\t\tResponseEntity<VaultHealthImpl> healthResponse = restOperations.exchange(\n\t\t\t\t\t\t\"sys/health\", HttpMethod.GET, null, VaultHealthImpl.class);\n\t\t\t\treturn healthResponse.getBody();\n\t\t\t}\n\t\t\tcatch (HttpStatusCodeException responseError) {\n\t\t\t\ttry {\n\t\t\t\t\tObjectMapper mapper = new ObjectMapper();\n\t\t\t\t\treturn mapper.readValue(responseError.getResponseBodyAsString(),\n\t\t\t\t\t\t\tVaultHealthImpl.class);\n\t\t\t\t}\n\t\t\t\tcatch (Exception jsonError) {\n\t\t\t\t\tthrow responseError;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n<fim_suffix>\t@Data\n\tstatic class VaultInitializationResponseImpl implements VaultInitializationResponse {\n\t\tprivate List<String> keys = new ArrayList<>();\n\t\t@JsonProperty(\"root_token\")\n\t\tprivate String rootToken = \"\";\n\t\tpublic VaultToken getRootToken() {\n\t\t\treturn VaultToken.of(rootToken);\n\t\t}\n\t}<fim_middle>// class below has no smell\n"}