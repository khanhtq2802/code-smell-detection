{"text": "<fim_prefix>\n<fim_suffix>public class ImmutableBitSet\n    implements Iterable<Integer>, Serializable, Comparable<ImmutableBitSet> {\n  /** Compares bit sets topologically, so that enclosing bit sets come first,\n   * using natural ordering to break ties. */\n  public static final Comparator<ImmutableBitSet> COMPARATOR = (o1, o2) -> {\n    if (o1.equals(o2)) {\n      return 0;\n    }\n    if (o1.contains(o2)) {\n      return -1;\n    }\n    if (o2.contains(o1)) {\n      return 1;\n    }\n    return o1.compareTo(o2);\n  };\n  public static final Ordering<ImmutableBitSet> ORDERING =\n      Ordering.from(COMPARATOR);\n  // BitSets are packed into arrays of \"words.\"  Currently a word is\n  // a long, which consists of 64 bits, requiring 6 address bits.\n  // The choice of word size is determined purely by performance concerns.\n  private static final int ADDRESS_BITS_PER_WORD = 6;\n  private static final int BITS_PER_WORD = 1 << ADDRESS_BITS_PER_WORD;\n  /* Used to shift left or right for a partial word mask */\n  private static final long WORD_MASK = 0xffffffffffffffffL;\n  private static final long[] EMPTY_LONGS = new long[0];\n  private static final ImmutableBitSet EMPTY =\n      new ImmutableBitSet(EMPTY_LONGS);\n  @SuppressWarnings(\"Guava\")\n  @Deprecated // to be removed before 2.0\n  public static final\n      com.google.common.base.Function<? super BitSet, ImmutableBitSet>\n      FROM_BIT_SET = ImmutableBitSet::fromBitSet;\n  private final long[] words;\n  /** Private constructor. Does not copy the array. */\n  private ImmutableBitSet(long[] words) {\n    this.words = words;\n    assert words.length == 0\n        ? words == EMPTY_LONGS\n        : words[words.length - 1] != 0L;\n  }\n  /** Creates an ImmutableBitSet with no bits. */\n  public static ImmutableBitSet of() {\n    return EMPTY;\n  }\n  public static ImmutableBitSet of(int... bits) {\n    int max = -1;\n    for (int bit : bits) {\n      max = Math.max(bit, max);\n    }\n    if (max == -1) {\n      return EMPTY;\n    }\n    long[] words = new long[wordIndex(max) + 1];\n    for (int bit : bits) {\n      int wordIndex = wordIndex(bit);\n      words[wordIndex] |= 1L << bit;\n    }\n    return new ImmutableBitSet(words);\n  }\n  public static ImmutableBitSet of(Iterable<Integer>  bits) {\n    if (bits instanceof ImmutableBitSet) {\n      return (ImmutableBitSet) bits;\n    }\n    int max = -1;\n    for (int bit : bits) {\n      max = Math.max(bit, max);\n    }\n    if (max == -1) {\n      return EMPTY;\n    }\n    long[] words = new long[wordIndex(max) + 1];\n    for (int bit : bits) {\n      int wordIndex = wordIndex(bit);\n      words[wordIndex] |= 1L << bit;\n    }\n    return new ImmutableBitSet(words);\n  }\n  /**\n   * Creates an ImmutableBitSet with given bits set.\n   *\n   * <p>For example, <code>of(ImmutableIntList.of(0, 3))</code> returns a bit\n   * set with bits {0, 3} set.\n   *\n   * @param bits Collection of bits to set\n   * @return Bit set\n   */\n  public static ImmutableBitSet of(ImmutableIntList bits) {\n    return builder().addAll(bits).build();\n  }\n  /**\n   * Returns a new immutable bit set containing all the bits in the given long\n   * array.\n   *\n   * <p>More precisely,\n   *\n   * <blockquote>{@code ImmutableBitSet.valueOf(longs).get(n)\n   *   == ((longs[n/64] & (1L<<(n%64))) != 0)}</blockquote>\n   *\n   * <p>for all {@code n < 64 * longs.length}.\n   *\n   * <p>This method is equivalent to\n   * {@code ImmutableBitSet.valueOf(LongBuffer.wrap(longs))}.\n   *\n   * @param longs a long array containing a little-endian representation\n   *        of a sequence of bits to be used as the initial bits of the\n   *        new bit set\n   * @return a {@code ImmutableBitSet} containing all the bits in the long\n   *         array\n   */\n  public static ImmutableBitSet valueOf(long... longs) {\n    int n = longs.length;\n    while (n > 0 && longs[n - 1] == 0) {\n      --n;\n    }\n    if (n == 0) {\n      return EMPTY;\n    }\n    return new ImmutableBitSet(Arrays.copyOf(longs, n));\n  }\n  /**\n   * Returns a new immutable bit set containing all the bits in the given long\n   * buffer.\n   */\n  public static ImmutableBitSet valueOf(LongBuffer longs) {\n    longs = longs.slice();\n    int n = longs.remaining();\n    while (n > 0 && longs.get(n - 1) == 0) {\n      --n;\n    }\n    if (n == 0) {\n      return EMPTY;\n    }\n    long[] words = new long[n];\n    longs.get(words);\n    return new ImmutableBitSet(words);\n  }\n  /**\n   * Returns a new immutable bit set containing all the bits in the given\n   * {@link BitSet}.\n   */\n  public static ImmutableBitSet fromBitSet(BitSet input) {\n    return ImmutableBitSet.of(BitSets.toIter(input));\n  }\n  /**\n   * Creates an ImmutableBitSet with bits from {@code fromIndex} (inclusive) to\n   * specified {@code toIndex} (exclusive) set to {@code true}.\n   *\n   * <p>For example, {@code range(0, 3)} returns a bit set with bits\n   * {0, 1, 2} set.\n   *\n   * @param fromIndex Index of the first bit to be set.\n   * @param toIndex   Index after the last bit to be set.\n   * @return Bit set\n   */\n  public static ImmutableBitSet range(int fromIndex, int toIndex) {\n    if (fromIndex > toIndex) {\n      throw new IllegalArgumentException();\n    }\n    if (toIndex < 0) {\n      throw new IllegalArgumentException();\n    }\n    if (fromIndex == toIndex) {\n      return EMPTY;\n    }\n    int startWordIndex = wordIndex(fromIndex);\n    int endWordIndex   = wordIndex(toIndex - 1);\n    long[] words = new long[endWordIndex + 1];\n    long firstWordMask = WORD_MASK << fromIndex;\n    long lastWordMask  = WORD_MASK >>> -toIndex;\n    if (startWordIndex == endWordIndex) {\n      // One word\n      words[startWordIndex] |= firstWordMask & lastWordMask;\n    } else {\n      // First word, middle words, last word\n      words[startWordIndex] |= firstWordMask;\n      for (int i = startWordIndex + 1; i < endWordIndex; i++) {\n        words[i] = WORD_MASK;\n      }\n      words[endWordIndex] |= lastWordMask;\n    }\n    return new ImmutableBitSet(words);\n  }\n  /** Creates an ImmutableBitSet with bits between 0 and {@code toIndex} set. */\n  public static ImmutableBitSet range(int toIndex) {\n    return range(0, toIndex);\n  }\n  /**\n   * Given a bit index, return word index containing it.\n   */\n  private static int wordIndex(int bitIndex) {\n    return bitIndex >> ADDRESS_BITS_PER_WORD;\n  }\n  /** Computes the power set (set of all sets) of this bit set. */\n  public Iterable<ImmutableBitSet> powerSet() {\n    List<List<ImmutableBitSet>> singletons = new ArrayList<>();\n    for (int bit : this) {\n      singletons.add(\n          ImmutableList.of(ImmutableBitSet.of(), ImmutableBitSet.of(bit)));\n    }\n    return Iterables.transform(Linq4j.product(singletons),\n        ImmutableBitSet::union);\n  }\n  /**\n   * Returns the value of the bit with the specified index. The value\n   * is {@code true} if the bit with the index {@code bitIndex}\n   * is currently set in this {@code ImmutableBitSet}; otherwise, the result\n   * is {@code false}.\n   *\n   * @param  bitIndex   the bit index\n   * @return the value of the bit with the specified index\n   * @throws IndexOutOfBoundsException if the specified index is negative\n   */\n  public boolean get(int bitIndex) {<fim_middle>// class below is blob\n"}