{"text": "<fim_prefix>/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.aurora.scheduler.storage.durability;\n\nimport java.io.File;\nimport java.net.InetSocketAddress;\nimport java.util.Map;\n\nimport com.beust.jcommander.IStringConverter;\nimport com.beust.jcommander.IStringConverterFactory;\nimport com.beust.jcommander.JCommander;\nimport com.beust.jcommander.Parameter;\nimport com.beust.jcommander.Parameters;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.inject.AbstractModule;\nimport com.google.inject.Guice;\nimport com.google.inject.Injector;\n\nimport org.apache.aurora.common.util.BuildInfo;\nimport org.apache.aurora.common.util.Clock;\nimport org.apache.aurora.scheduler.app.LifecycleModule;\nimport org.apache.aurora.scheduler.config.converters.DataAmountConverter;\nimport org.apache.aurora.scheduler.config.converters.InetSocketAddressConverter;\nimport org.apache.aurora.scheduler.config.converters.TimeAmountConverter;\nimport org.apache.aurora.scheduler.config.types.DataAmount;\nimport org.apache.aurora.scheduler.config.types.TimeAmount;\nimport org.apache.aurora.scheduler.discovery.FlaggedZooKeeperConfig;\nimport org.apache.aurora.scheduler.discovery.ServiceDiscoveryBindings;\nimport org.apache.aurora.scheduler.log.mesos.MesosLogStreamModule;\nimport org.apache.aurora.scheduler.storage.Snapshotter;\nimport org.apache.aurora.scheduler.storage.backup.BackupReader;\nimport org.apache.aurora.scheduler.storage.log.LogPersistenceModule;\nimport org.apache.aurora.scheduler.storage.log.SnapshotterImpl;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * A utility to recover the contents of one persistence into another.\n */\npublic final class RecoveryTool {\n\n  private static final Logger LOG = LoggerFactory.getLogger(RecoveryTool.class);\n\n  private RecoveryTool() {\n    // Main-only class.\n  }\n\n<fim_suffix>  interface RecoveryEndpoint {\n    Iterable<Object> getOptions();\n\n    Persistence create();\n  }\n\n  private static class Log implements RecoveryEndpoint {\n    private final FlaggedZooKeeperConfig.Options zkOptions = new FlaggedZooKeeperConfig.Options();\n    private final MesosLogStreamModule.Options logOptions = new MesosLogStreamModule.Options();\n    private final LogPersistenceModule.Options options = new LogPersistenceModule.Options();\n\n    @Override\n    public Iterable<Object> getOptions() {\n      return ImmutableList.of(logOptions, options, zkOptions);\n    }\n\n    @Override\n    public Persistence create() {\n      Injector injector = Guice.createInjector(\n          new MesosLogStreamModule(logOptions, FlaggedZooKeeperConfig.create(zkOptions)),\n          new LogPersistenceModule(options),\n          new LifecycleModule(),\n          new AbstractModule() {\n            @Override\n            protected void configure() {\n              bind(ServiceDiscoveryBindings.ZOO_KEEPER_CLUSTER_KEY)\n                  .toInstance(zkOptions.zkEndpoints);\n              bind(Snapshotter.class).to(SnapshotterImpl.class);\n              bind(Clock.class).toInstance(Clock.SYSTEM_CLOCK);\n              bind(BuildInfo.class).toInstance(new BuildInfo());\n            }\n          });\n      return injector.getInstance(Persistence.class);\n    }\n  }\n\n  private static class Backup implements RecoveryEndpoint {\n    @Parameters(separators = \"=\")\n    private static class Options {\n      @Parameter(names = \"-backup\", description = \"Backup file to load\")\n      File backup;\n    }\n\n    private final Options options = new Options();\n\n    @Override\n    public Iterable<Object> getOptions() {\n      return ImmutableList.of(options);\n    }\n\n    @Override\n    public Persistence create() {\n      return new BackupReader(\n          options.backup,\n          new SnapshotterImpl(new BuildInfo(), Clock.SYSTEM_CLOCK));\n    }\n  }\n\n  enum Endpoint {\n    LOG(new Log()),\n    BACKUP(new Backup());\n\n    private final RecoveryEndpoint impl;\n\n    Endpoint(RecoveryEndpoint impl) {\n      this.impl = impl;\n    }\n  }\n\n  @Parameters(separators = \"=\")\n  private static class Options {\n    @Parameter(names = \"-from\",\n        required = true,\n        description = \"Persistence to read state from\")\n    Endpoint from;\n\n    @Parameter(names = \"-to\",\n        required = true,\n        description = \"Persistence to write recovered state into\")\n    Endpoint to;\n\n    @Parameter(names = \"-batch-size\",\n        description = \"Write in batches of this may ops.\")\n    int batchSize = 50;\n\n    @Parameter(names = \"--help\", description = \"Print usage\", help = true)\n    boolean help;\n  }\n\n  private static JCommander configure(Options options, String... args) {\n    JCommander.Builder builder = JCommander.newBuilder().programName(RecoveryTool.class.getName());\n    builder.addConverterFactory(new IStringConverterFactory() {\n      private Map<Class<?>, Class<? extends IStringConverter<?>>> classConverters =\n          ImmutableMap.<Class<?>, Class<? extends IStringConverter<?>>>builder()\n              .put(DataAmount.class, DataAmountConverter.class)\n              .put(InetSocketAddress.class, InetSocketAddressConverter.class)\n              .put(TimeAmount.class, TimeAmountConverter.class)\n              .build();\n\n      @SuppressWarnings(\"unchecked\")\n      @Override\n      public <T> Class<? extends IStringConverter<T>> getConverter(Class<T> forType) {\n        return (Class<IStringConverter<T>>) classConverters.get(forType);\n      }\n    });\n\n    builder.addObject(options);\n    for (Endpoint endpoint : Endpoint.values()) {\n      endpoint.impl.getOptions().forEach(builder::addObject);\n    }\n\n    JCommander parser = builder.build();\n    parser.parse(args);\n    return parser;\n  }\n\n  public static void main(String[] args) {\n    Options options = new Options();\n    JCommander parser = configure(options, args);\n    if (options.help) {\n      parser.usage();\n      System.exit(1);\n    }\n\n    LOG.info(\"Recovering from \" + options.from + \" to \" + options.to);\n    Persistence from = options.from.impl.create();\n    Persistence to = options.to.impl.create();\n\n    from.prepare();\n    to.prepare();\n\n    Recovery.copy(from, to, options.batchSize);\n  }\n}<fim_middle>// class below has no smell\n"}