{"text": "<fim_prefix>/*******************************************************************************\n * Copyright (c) 2003, 2010 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     IBM Corporation - initial API and implementation\n *******************************************************************************/\npackage org.eclipse.draw2d.graph;\n\nimport org.eclipse.draw2d.geometry.Insets;\n\n/**\n * Converts a compound directed graph into a simple directed graph.\n * \n * @author Randy Hudson\n * @since 2.1.2\n */\nclass ConvertCompoundGraph extends GraphVisitor {\n\n\tprivate void addContainmentEdges(CompoundDirectedGraph graph) {\n\t\t// For all nested nodes, connect to head and/or tail of containing\n\t\t// subgraph if present\n\t\tfor (int i = 0; i < graph.nodes.size(); i++) {\n\t\t\tNode node = graph.nodes.getNode(i);\n\t\t\tSubgraph parent = node.getParent();\n\t\t\tif (parent == null)\n\t\t\t\tcontinue;\n\t\t\tif (node instanceof Subgraph) {\n\t\t\t\tSubgraph sub = (Subgraph) node;\n\t\t\t\tconnectHead(graph, sub.head, parent);\n\t\t\t\tconnectTail(graph, sub.tail, parent);\n\t\t\t} else {\n\t\t\t\tconnectHead(graph, node, parent);\n\t\t\t\tconnectTail(graph, node, parent);\n\t\t\t}\n\t\t}\n\t}\n\n\tint buildNestingTreeIndices(NodeList nodes, int base) {\n\t\tfor (int i = 0; i < nodes.size(); i++) {\n\t\t\tNode node = (Node) nodes.get(i);\n\t\t\tif (node instanceof Subgraph) {\n\t\t\t\tSubgraph s = (Subgraph) node;\n\t\t\t\ts.nestingTreeMin = base;\n\t\t\t\tbase = buildNestingTreeIndices(s.members, base);\n\t\t\t}\n\t\t\tnode.nestingIndex = base++;\n\t\t}\n\t\treturn base++;\n\t}\n\n\tprivate void connectHead(CompoundDirectedGraph graph, Node node,\n\t\t\tSubgraph parent) {\n\t\tboolean connectHead = true;\n\t\tfor (int j = 0; connectHead && j < node.incoming.size(); j++) {\n\t\t\tNode ancestor = node.incoming.getEdge(j).source;\n\t\t\tif (parent.isNested(ancestor))\n\t\t\t\tconnectHead = false;\n\t\t}\n\t\tif (connectHead) {\n\t\t\tEdge e = new Edge(parent.head, node);\n\t\t\te.weight = 0;\n\t\t\tgraph.edges.add(e);\n\t\t\tgraph.containment.add(e);\n\t\t}\n\t}\n\n\tprivate void connectTail(CompoundDirectedGraph graph, Node node,\n\t\t\tSubgraph parent) {\n\t\tboolean connectTail = true;\n\t\tfor (int j = 0; connectTail && j < node.outgoing.size(); j++) {\n\t\t\tNode ancestor = node.outgoing.getEdge(j).target;\n\t\t\tif (parent.isNested(ancestor))\n\t\t\t\tconnectTail = false;\n\t\t}\n\t\tif (connectTail) {\n\t\t\tEdge e = new Edge(node, parent.tail);\n\t\t\te.weight = 0;\n\t\t\tgraph.edges.add(e);\n\t\t\tgraph.containment.add(e);\n\t\t}\n\t}\n\n\tprivate void convertSubgraphEndpoints(CompoundDirectedGraph graph) {\n\t\tfor (int i = 0; i < graph.edges.size(); i++) {\n\t\t\tEdge edge = (Edge) graph.edges.get(i);\n\t\t\tif (edge.source instanceof Subgraph) {\n\t\t\t\tSubgraph s = (Subgraph) edge.source;\n\t\t\t\tNode newSource;\n\t\t\t\tif (s.isNested(edge.target))\n\t\t\t\t\tnewSource = s.head;\n\t\t\t\telse\n\t\t\t\t\tnewSource = s.tail;\n\t\t\t\t// s.outgoing.remove(edge);\n\t\t\t\tedge.source = newSource;\n\t\t\t\tnewSource.outgoing.add(edge);\n\t\t\t}\n\t\t\tif (edge.target instanceof Subgraph) {\n\t\t\t\tSubgraph s = (Subgraph) edge.target;\n\t\t\t\tNode newTarget;\n\t\t\t\tif (s.isNested(edge.source))\n\t\t\t\t\tnewTarget = s.tail;\n\t\t\t\telse\n\t\t\t\t\tnewTarget = s.head;\n\n\t\t\t\t// s.incoming.remove(edge);\n\t\t\t\tedge.target = newTarget;\n\t\t\t\tnewTarget.incoming.add(edge);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void replaceSubgraphsWithBoundaries(CompoundDirectedGraph graph) {\n\t\tfor (int i = 0; i < graph.subgraphs.size(); i++) {\n\t\t\tSubgraph s = (Subgraph) graph.subgraphs.get(i);\n\t\t\tgraph.nodes.add(s.head);\n\t\t\tgraph.nodes.add(s.tail);\n\t\t\tgraph.nodes.remove(s);\n\t\t}\n\t}\n\n\tvoid revisit(DirectedGraph g) {\n\t\tfor (int i = 0; i < g.edges.size(); i++) {\n\t\t\tEdge e = g.edges.getEdge(i);\n\t\t\tif (e.source instanceof SubgraphBoundary) {\n\t\t\t\te.source.outgoing.remove(e);\n\t\t\t\te.source = e.source.getParent();\n\t\t\t}\n\t\t\tif (e.target instanceof SubgraphBoundary) {\n\t\t\t\te.target.incoming.remove(e);\n\t\t\t\te.target = e.target.getParent();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @see GraphVisitor#visit(org.eclipse.draw2d.graph.DirectedGraph)\n\t */\n<fim_suffix>\tpublic void visit(DirectedGraph dg) {\n\t\tCompoundDirectedGraph graph = (CompoundDirectedGraph) dg;\n\n\t\tNodeList roots = new NodeList();\n\t\t// Find all subgraphs and root subgraphs\n\t\tfor (int i = 0; i < graph.nodes.size(); i++) {\n\t\t\tObject node = graph.nodes.get(i);\n\t\t\tif (node instanceof Subgraph) {\n\t\t\t\tSubgraph s = (Subgraph) node;\n\t\t\t\tInsets padding = dg.getPadding(s);\n\t\t\t\ts.head = new SubgraphBoundary(s, padding, 0);\n\t\t\t\ts.tail = new SubgraphBoundary(s, padding, 2);\n\t\t\t\tEdge headToTail = new Edge(s.head, s.tail);\n\t\t\t\theadToTail.weight = 10;\n\t\t\t\tgraph.edges.add(headToTail);\n\t\t\t\tgraph.containment.add(headToTail);\n\n\t\t\t\tgraph.subgraphs.add(s);\n\t\t\t\tif (s.getParent() == null)\n\t\t\t\t\troots.add(s);\n\t\t\t\tif (s.members.size() == 2) // The 2 being the head and tail only\n\t\t\t\t\tgraph.edges.add(new Edge(s.head, s.tail));\n\t\t\t}\n\t\t}\n\n\t\tbuildNestingTreeIndices(roots, 0);\n\t\tconvertSubgraphEndpoints(graph);\n\t\taddContainmentEdges(graph);\n\t\treplaceSubgraphsWithBoundaries(graph);\n\t}\n\n}<fim_middle>// function below is long method\n"}