{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.cassandra.db.filter;\n\nimport java.io.IOException;\nimport java.util.List;\nimport java.nio.ByteBuffer;\n\nimport org.apache.cassandra.schema.TableMetadata;\nimport org.apache.cassandra.db.*;\nimport org.apache.cassandra.db.rows.*;\nimport org.apache.cassandra.db.partitions.CachedPartition;\nimport org.apache.cassandra.db.partitions.Partition;\nimport org.apache.cassandra.db.transform.Transformation;\nimport org.apache.cassandra.io.sstable.format.SSTableReader;\nimport org.apache.cassandra.io.util.DataInputPlus;\nimport org.apache.cassandra.io.util.DataOutputPlus;\n\n/**\n * A filter over a single partition.\n */\npublic class ClusteringIndexSliceFilter extends AbstractClusteringIndexFilter\n{\n    static final InternalDeserializer deserializer = new SliceDeserializer();\n\n    private final Slices slices;\n\n    public ClusteringIndexSliceFilter(Slices slices, boolean reversed)\n    {\n        super(reversed);\n        this.slices = slices;\n    }\n\n    public Slices requestedSlices()\n    {\n        return slices;\n    }\n\n    public boolean selectsAllPartition()\n    {\n        return slices.size() == 1 && !slices.hasLowerBound() && !slices.hasUpperBound();\n    }\n\n    public boolean selects(Clustering clustering)\n    {\n        return slices.selects(clustering);\n    }\n\n    public ClusteringIndexSliceFilter forPaging(ClusteringComparator comparator, Clustering lastReturned, boolean inclusive)\n    {\n        Slices newSlices = slices.forPaging(comparator, lastReturned, inclusive, reversed);\n        return slices == newSlices\n             ? this\n             : new ClusteringIndexSliceFilter(newSlices, reversed);\n    }\n\n    public boolean isFullyCoveredBy(CachedPartition partition)\n    {\n        // Partition is guaranteed to cover the whole filter if it includes the filter start and finish bounds.\n\n        // (note that since partition is the head of a partition, to have no lower bound is ok)\n        if (!slices.hasUpperBound() || partition.isEmpty())\n            return false;\n\n        return partition.metadata().comparator.compare(slices.get(slices.size() - 1).end(), partition.lastRow().clustering()) <= 0;\n    }\n\n    public boolean isHeadFilter()\n    {\n        return !reversed && slices.size() == 1 && !slices.hasLowerBound();\n    }\n\n    // Given another iterator, only return the rows that match this filter\n    public UnfilteredRowIterator filterNotIndexed(final ColumnFilter columnFilter, UnfilteredRowIterator iterator)\n    {\n        final Slices.InOrderTester tester = slices.inOrderTester(reversed);\n\n        // Note that we don't filter markers because that's a bit trickier (we don't know in advance until when\n        // the range extend) and it's harmless to leave them.\n        class FilterNotIndexed extends Transformation\n        {\n            @Override\n            public Row applyToRow(Row row)\n            {\n                return tester.includes(row.clustering()) ? row.filter(columnFilter, iterator.metadata()) : null;\n            }\n\n            @Override\n            public Row applyToStatic(Row row)\n            {\n                return columnFilter.fetchedColumns().statics.isEmpty() ? Rows.EMPTY_STATIC_ROW : row.filter(columnFilter, iterator.metadata());\n            }\n        }\n        return Transformation.apply(iterator, new FilterNotIndexed());\n    }\n\n    public Slices getSlices(TableMetadata metadata)\n    {\n        return slices;\n    }\n\n    public UnfilteredRowIterator getUnfilteredRowIterator(ColumnFilter columnFilter, Partition partition)\n    {\n        return partition.unfilteredIterator(columnFilter, slices, reversed);\n    }\n\n    public boolean shouldInclude(SSTableReader sstable)\n    {\n        List<ByteBuffer> minClusteringValues = sstable.getSSTableMetadata().minClusteringValues;\n        List<ByteBuffer> maxClusteringValues = sstable.getSSTableMetadata().maxClusteringValues;\n\n        if (minClusteringValues.isEmpty() || maxClusteringValues.isEmpty())\n            return true;\n\n        return slices.intersects(minClusteringValues, maxClusteringValues);\n    }\n\n<fim_suffix>    public String toString(TableMetadata metadata)\n    {\n        return String.format(\"slice(slices=%s, reversed=%b)\", slices, reversed);\n    }\n\n    public String toCQLString(TableMetadata metadata)\n    {\n        StringBuilder sb = new StringBuilder();\n\n        if (!selectsAllPartition())\n            sb.append(slices.toCQLString(metadata));\n\n        appendOrderByToCQLString(metadata, sb);\n\n        return sb.toString();\n    }\n\n    public Kind kind()\n    {\n        return Kind.SLICE;\n    }\n\n    protected void serializeInternal(DataOutputPlus out, int version) throws IOException\n    {\n        Slices.serializer.serialize(slices, out, version);\n    }\n\n    protected long serializedSizeInternal(int version)\n    {\n        return Slices.serializer.serializedSize(slices, version);\n    }\n\n    private static class SliceDeserializer implements InternalDeserializer\n    {\n        public ClusteringIndexFilter deserialize(DataInputPlus in, int version, TableMetadata metadata, boolean reversed) throws IOException\n        {\n            Slices slices = Slices.serializer.deserialize(in, version, metadata);\n            return new ClusteringIndexSliceFilter(slices, reversed);\n        }\n    }\n}<fim_middle>// function below has no smell\n"}