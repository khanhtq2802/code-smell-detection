{"text": "<fim_prefix>/*\n *\n *  Licensed to the Apache Software Foundation (ASF) under one or more\n *  contributor license agreements.  See the NOTICE file distributed with\n *  this work for additional information regarding copyright ownership.\n *  The ASF licenses this file to You under the Apache License, Version 2.0\n *  (the \"License\"); you may not use this file except in compliance with\n *  the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n */\npackage org.apache.royale.compiler.internal.codegen.js.jx;\nimport org.apache.royale.compiler.codegen.ISubEmitter;\nimport org.apache.royale.compiler.codegen.js.IJSEmitter;\nimport org.apache.royale.compiler.constants.IASLanguageConstants;\nimport org.apache.royale.compiler.definitions.IClassDefinition;\nimport org.apache.royale.compiler.internal.codegen.as.ASEmitterTokens;\nimport org.apache.royale.compiler.internal.codegen.js.JSEmitterTokens;\nimport org.apache.royale.compiler.internal.codegen.js.JSSessionModel.ImplicitBindableImplementation;\nimport org.apache.royale.compiler.internal.codegen.js.JSSessionModel.BindableVarInfo;\nimport org.apache.royale.compiler.internal.codegen.js.JSSubEmitter;\nimport org.apache.royale.compiler.internal.codegen.js.royale.JSRoyaleEmitter;\nimport org.apache.royale.compiler.internal.codegen.js.goog.JSGoogEmitterTokens;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.Map.Entry;\nimport java.util.Collections;\nimport java.util.Set;\npublic class BindableEmitter extends JSSubEmitter implements\n        ISubEmitter<IClassDefinition>\n{\n    public static String BINDABLE_DISPATCHER_NAME = \"_bindingEventDispatcher\";\n    public static String STATIC_DISPATCHER_GETTER = \"staticEventDispatcher\";\n    public static String EVENTS_PACKAGE =\"org.apache.royale.events\";\n    public static String EVENTDISPATCHER = \"EventDispatcher\";\n    public static String EVENTDISPATCHER_INTERFACE = \"IEventDispatcher\";\n    public static String EVENT = \"Event\";\n    public static String VALUECHANGE_EVENT = \"ValueChangeEvent\";\n    public static String EVENT_QNAME = EVENTS_PACKAGE +\".\" +EVENT;\n    public static String VALUECHANGE_EVENT_QNAME = EVENTS_PACKAGE +\".\" +VALUECHANGE_EVENT;\n    public static String DISPATCHER_CLASS_QNAME = EVENTS_PACKAGE +\".\" + EVENTDISPATCHER;\n    public static String DISPATCHER_INTERFACE_QNAME = EVENTS_PACKAGE +\".\" +EVENTDISPATCHER_INTERFACE;\n    public BindableEmitter(IJSEmitter emitter)\n    {\n        super(emitter);\n    }\n    @Override\n    public void emit(IClassDefinition definition)\n    {\n        if (getModel().hasBindableVars())\n        {\n            int statics = 0;\n            if (getModel().hasStaticBindableVars()) {\n                statics = emitStaticBindableVars(definition);\n            }\n            if (statics < getModel().getBindableVars().size())\n                emitInstanceBindableVars(definition);\n        }\n    }\n    public void emitBindableImplementsConstructorCode() {\n        emitBindableImplementsConstructorCode(false);\n    }\n<fim_suffix>    public void emitBindableImplementsConstructorCode(boolean popIndent) {\n        writeNewline(\"// Compiler generated Binding support implementation:\");\n        String dispatcherClass = getEmitter().formatQualifiedName(DISPATCHER_CLASS_QNAME);\n        write(ASEmitterTokens.THIS);\n        write(ASEmitterTokens.MEMBER_ACCESS);\n        write(BINDABLE_DISPATCHER_NAME);\n        write(ASEmitterTokens.SPACE);\n        write(ASEmitterTokens.EQUAL);\n        write(ASEmitterTokens.SPACE);\n        write(ASEmitterTokens.NEW);\n        write(ASEmitterTokens.SPACE);\n        write(dispatcherClass);\n        write(ASEmitterTokens.PAREN_OPEN);\n        write(ASEmitterTokens.THIS);\n        write(ASEmitterTokens.PAREN_CLOSE);\n        writeNewline(ASEmitterTokens.SEMICOLON);\n        if (popIndent) writeNewline(\"\",false);\n        else writeNewline();\n    }\n    public void emitBindableExtendsConstructorCode(String qname,boolean popIndent) {\n        writeNewline(\"// Compiler generated Binding support implementation:\");\n        write(getEmitter().formatQualifiedName(qname));\n        write(ASEmitterTokens.MEMBER_ACCESS);\n        write(JSGoogEmitterTokens.GOOG_BASE);\n        write(ASEmitterTokens.PAREN_OPEN);\n        write(ASEmitterTokens.THIS);\n        writeToken(ASEmitterTokens.COMMA);\n        write(ASEmitterTokens.SINGLE_QUOTE);\n        write(JSGoogEmitterTokens.GOOG_CONSTRUCTOR);\n        write(ASEmitterTokens.SINGLE_QUOTE);\n        write(ASEmitterTokens.PAREN_CLOSE);\n        writeNewline(ASEmitterTokens.SEMICOLON);\n        if (popIndent) writeNewline(\"\",false);\n        else writeNewline();\n    }\n    private void emitBindableInterfaceMethods(IClassDefinition definition)  {\n        writeNewline();\n        writeNewline(\"/**\");\n        writeNewline(\" * Compiler generated\");\n        writeNewline(\" * Binding support implementation of \"+DISPATCHER_INTERFACE_QNAME);\n        writeNewline(\"*/\");\n        String qname = getEmitter().formatQualifiedName(definition.getQualifiedName());\n        String dispatcherClass = getEmitter().formatQualifiedName(DISPATCHER_CLASS_QNAME);\n        writeNewline(\"/**\");\n        writeNewline(\"* @private\");\n        writeNewline(\"* @type {\"+dispatcherClass+\"}\");\n        writeNewline(\"*/\");\n        write(qname);\n        write(ASEmitterTokens.MEMBER_ACCESS);\n        write(JSEmitterTokens.PROTOTYPE);\n        write(ASEmitterTokens.MEMBER_ACCESS);\n        writeNewline(BINDABLE_DISPATCHER_NAME);\n        writeNewline();\n        emitBindableInterfaceMethod(qname,\n                new String[]{ \"/**\",\n                        \" * @export\",\n                        \" * @param {string} type\",\n                        \" * @param {function(?):?}\",\n                        \" * @param {boolean=} opt_capture\",\n                        \" * @param {Object=} opt_handlerScope\",\n                        \" */\"},\n                \"addEventListener\",\n                \"type , handler , opt_capture , opt_handlerScope\",\n                \"this.\"+BINDABLE_DISPATCHER_NAME+\".addEventListener(type , handler , opt_capture , opt_handlerScope);\");\n        emitBindableInterfaceMethod(qname,\n                new String[]{ \"/**\",\n                        \" * @export\",\n                        \" * @param {string} type\",\n                        \" * @param {function(?):?}\",\n                        \" * @param {boolean=} opt_capture\",\n                        \" * @param {Object=} opt_handlerScope\",\n                        \" */\"},\n                \"removeEventListener\",\n                \"type , handler , opt_capture , opt_handlerScope\",\n                \"this.\"+BINDABLE_DISPATCHER_NAME+\".removeEventListener(type , handler , opt_capture , opt_handlerScope);\");\n        emitBindableInterfaceMethod(qname,\n                new String[]{ \"/**\",\n                        \" * @export\",\n                        \" * @param {\"+EVENT_QNAME+\"} e\",\n                        \" * @return {boolean}\",\n                        \" */\"},\n                \"dispatchEvent\",\n                \"e\",\n                \"return this.\"+BINDABLE_DISPATCHER_NAME+\".dispatchEvent(e);\");\n        emitBindableInterfaceMethod(qname,\n                new String[]{ \"/**\",\n                        \" * @export\",\n                        \" * @param {string} type\",\n                        \" * @return {boolean}\",\n                        \" */\"},\n                \"hasEventListener\",\n                \"type\",\n                \"return this.\"+BINDABLE_DISPATCHER_NAME+\".hasEventListener(type);\");\n        writeNewline(\"/**\");\n        writeNewline(\" * End of Binding support implementation of \"+DISPATCHER_INTERFACE_QNAME);\n        writeNewline(\"*/\");\n        writeNewline();\n    }\n    private void emitBindableInterfaceMethod(String qualifiedClassName, String[] docLines, String methodName, String methodArgs, String methodBody) {\n        for (String line : docLines)\n        {\n            writeNewline(line);\n        }\n        write(qualifiedClassName);\n        write(ASEmitterTokens.MEMBER_ACCESS);\n        write(JSEmitterTokens.PROTOTYPE);\n        write(ASEmitterTokens.MEMBER_ACCESS);\n        write(methodName);\n        write(ASEmitterTokens.SPACE);\n        write(ASEmitterTokens.EQUAL);\n        write(ASEmitterTokens.SPACE);\n        write(ASEmitterTokens.FUNCTION);\n        write(ASEmitterTokens.PAREN_OPEN);\n        write(methodArgs);\n        write(ASEmitterTokens.PAREN_CLOSE);<fim_middle>// function below has no smell\n"}