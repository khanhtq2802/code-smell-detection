{"text": "<fim_prefix>/*\n * Copyright 2016-2019 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.springframework.data.redis.connection;\nimport reactor.core.publisher.Flux;\nimport reactor.core.publisher.Mono;\nimport java.nio.ByteBuffer;\nimport java.time.Duration;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport org.reactivestreams.Publisher;\nimport org.springframework.data.redis.connection.ReactiveRedisConnection.BooleanResponse;\nimport org.springframework.data.redis.connection.ReactiveRedisConnection.ByteBufferResponse;\nimport org.springframework.data.redis.connection.ReactiveRedisConnection.Command;\nimport org.springframework.data.redis.connection.ReactiveRedisConnection.CommandResponse;\nimport org.springframework.data.redis.connection.ReactiveRedisConnection.KeyCommand;\nimport org.springframework.data.redis.connection.ReactiveRedisConnection.NumericResponse;\nimport org.springframework.data.redis.connection.ReactiveRedisConnection.RangeCommand;\nimport org.springframework.data.redis.connection.RedisListCommands.Position;\nimport org.springframework.lang.Nullable;\nimport org.springframework.util.Assert;\nimport org.springframework.util.ObjectUtils;\n/**\n * Redis List commands executed using reactive infrastructure.\n *\n * @author Christoph Strobl\n * @author Mark Paluch\n * @since 2.0\n */\npublic interface ReactiveListCommands {\n\t/**\n\t * @author Christoph Strobl\n\t */\n\tenum Direction {\n\t\tLEFT, RIGHT\n\t}\n\t/**\n\t * {@code LPUSH}/{@literal RPUSH} command parameters.\n\t *\n\t * @author Christoph Strobl\n\t * @see <a href=\"https://redis.io/commands/lpush\">Redis Documentation: LPUSH</a>\n\t * @see <a href=\"https://redis.io/commands/rpush\">Redis Documentation: RPUSH</a>\n\t */\n<fim_suffix>\tclass PushCommand extends KeyCommand {\n\t\tprivate List<ByteBuffer> values;\n\t\tprivate boolean upsert;\n\t\tprivate Direction direction;\n\t\tprivate PushCommand(@Nullable ByteBuffer key, List<ByteBuffer> values, Direction direction, boolean upsert) {\n\t\t\tsuper(key);\n\t\t\tthis.values = values;\n\t\t\tthis.upsert = upsert;\n\t\t\tthis.direction = direction;\n\t\t}\n\t\t/**\n\t\t * Creates a new {@link PushCommand} for right push ({@literal RPUSH}).\n\t\t *\n\t\t * @return a new {@link PushCommand} for right push ({@literal RPUSH}).\n\t\t */\n\t\tpublic static PushCommand right() {\n\t\t\treturn new PushCommand(null, Collections.emptyList(), Direction.RIGHT, true);\n\t\t}\n\t\t/**\n\t\t * Creates a new {@link PushCommand} for left push ({@literal LPUSH}).\n\t\t *\n\t\t * @return a new {@link PushCommand} for left push ({@literal LPUSH}).\n\t\t */\n\t\tpublic static PushCommand left() {\n\t\t\treturn new PushCommand(null, Collections.emptyList(), Direction.LEFT, true);\n\t\t}\n\t\t/**\n\t\t * Applies the {@literal value}. Constructs a new command instance with all previously configured properties.\n\t\t *\n\t\t * @param value must not be {@literal null}.\n\t\t * @return a new {@link PushCommand} with {@literal value} applied.\n\t\t */\n\t\tpublic PushCommand value(ByteBuffer value) {\n\t\t\tAssert.notNull(value, \"Value must not be null!\");\n\t\t\treturn new PushCommand(null, Collections.singletonList(value), direction, upsert);\n\t\t}\n\t\t/**\n\t\t * Applies a {@link List} of {@literal values}.\n\t\t *\n\t\t * @param values must not be {@literal null}.\n\t\t * @return a new {@link PushCommand} with {@literal values} applied.\n\t\t */\n\t\tpublic PushCommand values(List<ByteBuffer> values) {\n\t\t\tAssert.notNull(values, \"Values must not be null!\");\n\t\t\treturn new PushCommand(null, new ArrayList<>(values), direction, upsert);\n\t\t}\n\t\t/**\n\t\t * Applies the {@literal key}. Constructs a new command instance with all previously configured properties.\n\t\t *\n\t\t * @param key must not be {@literal null}.\n\t\t * @return a new {@link PushCommand} with {@literal key} applied.\n\t\t */\n\t\tpublic PushCommand to(ByteBuffer key) {\n\t\t\tAssert.notNull(key, \"Key must not be null!\");\n\t\t\treturn new PushCommand(key, values, direction, upsert);\n\t\t}\n\t\t/**\n\t\t * Disable upsert. Constructs a new command instance with all previously configured properties.\n\t\t *\n\t\t * @return a new {@link PushCommand} with upsert disabled.\n\t\t */\n\t\tpublic PushCommand ifExists() {\n\t\t\treturn new PushCommand(getKey(), values, direction, false);\n\t\t}\n\t\t/**\n\t\t * @return never {@literal null}.\n\t\t */\n\t\tpublic List<ByteBuffer> getValues() {\n\t\t\treturn values;\n\t\t}\n\t\t/**\n\t\t * @return\n\t\t */\n\t\tpublic boolean getUpsert() {\n\t\t\treturn upsert;\n\t\t}\n\t\t/**\n\t\t * @return never {@literal null}.\n\t\t */\n\t\tpublic Direction getDirection() {\n\t\t\treturn direction;\n\t\t}\n\t}\n\t/**\n\t * Append {@literal values} to {@literal key}.\n\t *\n\t * @param key must not be {@literal null}.\n\t * @param values must not be {@literal null}.\n\t * @return\n\t * @see <a href=\"https://redis.io/commands/rpush\">Redis Documentation: RPUSH</a>\n\t */\n\tdefault Mono<Long> rPush(ByteBuffer key, List<ByteBuffer> values) {\n\t\tAssert.notNull(key, \"Key must not be null!\");\n\t\tAssert.notNull(values, \"Values must not be null!\");\n\t\treturn push(Mono.just(PushCommand.right().values(values).to(key))).next().map(NumericResponse::getOutput);\n\t}\n\t/**\n\t * Append {@literal values} to {@literal key} only if {@literal key} already exists.\n\t *\n\t * @param key must not be {@literal null}.\n\t * @param value must not be {@literal null}.\n\t * @return\n\t * @see <a href=\"https://redis.io/commands/rpushx\">Redis Documentation: RPUSHX</a>\n\t */\n\tdefault Mono<Long> rPushX(ByteBuffer key, ByteBuffer value) {\n\t\tAssert.notNull(key, \"Key must not be null!\");\n\t\tAssert.notNull(value, \"Value must not be null!\");\n\t\treturn push(Mono.just(PushCommand.right().value(value).to(key).ifExists())).next().map(NumericResponse::getOutput);\n\t}\n\t/**\n\t * Prepend {@literal values} to {@literal key}.\n\t *\n\t * @param key must not be {@literal null}.\n\t * @param values must not be {@literal null}.\n\t * @return\n\t * @see <a href=\"https://redis.io/commands/lpush\">Redis Documentation: LPUSH</a>\n\t */\n\tdefault Mono<Long> lPush(ByteBuffer key, List<ByteBuffer> values) {\n\t\tAssert.notNull(key, \"Key must not be null!\");\n\t\tAssert.notNull(values, \"Values must not be null!\");\n\t\treturn push(Mono.just(PushCommand.left().values(values).to(key))).next().map(NumericResponse::getOutput);\n\t}\n\t/**\n\t * Prepend {@literal value} to {@literal key} if {@literal key} already exists.\n\t *\n\t * @param key must not be {@literal null}.\n\t * @param value must not be {@literal null}.\n\t * @return\n\t * @see <a href=\"https://redis.io/commands/lpushx\">Redis Documentation: LPUSHX</a>\n\t */\n\tdefault Mono<Long> lPushX(ByteBuffer key, ByteBuffer value) {\n\t\tAssert.notNull(key, \"Key must not be null!\");\n\t\tAssert.notNull(value, \"Value must not be null!\");\n\t\treturn push(Mono.just(PushCommand.left().value(value).to(key).ifExists())).next().map(NumericResponse::getOutput);<fim_middle>// class below has no smell\n"}