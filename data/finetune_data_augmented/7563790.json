{"text": "<fim_prefix>\n<fim_suffix>public class ReflectivePropertyAccessor implements PropertyAccessor {\n\tprivate static final Set<Class<?>> ANY_TYPES = Collections.emptySet();\n\tprivate static final Set<Class<?>> BOOLEAN_TYPES;\n\tstatic {\n\t\tSet<Class<?>> booleanTypes = new HashSet<>(4);\n\t\tbooleanTypes.add(Boolean.class);\n\t\tbooleanTypes.add(Boolean.TYPE);\n\t\tBOOLEAN_TYPES = Collections.unmodifiableSet(booleanTypes);\n\t}\n\tprivate final boolean allowWrite;\n\tprivate final Map<PropertyCacheKey, InvokerPair> readerCache = new ConcurrentHashMap<>(64);\n\tprivate final Map<PropertyCacheKey, Member> writerCache = new ConcurrentHashMap<>(64);\n\tprivate final Map<PropertyCacheKey, TypeDescriptor> typeDescriptorCache = new ConcurrentHashMap<>(64);\n\tprivate final Map<Class<?>, Method[]> sortedMethodsCache = new ConcurrentHashMap<>(64);\n\t@Nullable\n\tprivate volatile InvokerPair lastReadInvokerPair;\n\t/**\n\t * Create a new property accessor for reading as well writing.\n\t * @see #ReflectivePropertyAccessor(boolean)\n\t */\n\tpublic ReflectivePropertyAccessor() {\n\t\tthis.allowWrite = true;\n\t}\n\t/**\n\t * Create a new property accessor for reading and possibly writing.\n\t * @param allowWrite whether to also allow for write operations\n\t * @since 4.3.15\n\t * @see #canWrite\n\t */\n\tpublic ReflectivePropertyAccessor(boolean allowWrite) {\n\t\tthis.allowWrite = allowWrite;\n\t}\n\t/**\n\t * Returns {@code null} which means this is a general purpose accessor.\n\t */\n\t@Override\n\t@Nullable\n\tpublic Class<?>[] getSpecificTargetClasses() {\n\t\treturn null;\n\t}\n\t@Override\n\tpublic boolean canRead(EvaluationContext context, @Nullable Object target, String name) throws AccessException {\n\t\tif (target == null) {\n\t\t\treturn false;\n\t\t}\n\t\tClass<?> type = (target instanceof Class ? (Class<?>) target : target.getClass());\n\t\tif (type.isArray() && name.equals(\"length\")) {\n\t\t\treturn true;\n\t\t}\n\t\tPropertyCacheKey cacheKey = new PropertyCacheKey(type, name, target instanceof Class);\n\t\tif (this.readerCache.containsKey(cacheKey)) {\n\t\t\treturn true;\n\t\t}\n\t\tMethod method = findGetterForProperty(name, type, target);\n\t\tif (method != null) {\n\t\t\t// Treat it like a property...\n\t\t\t// The readerCache will only contain gettable properties (let's not worry about setters for now).\n\t\t\tProperty property = new Property(type, method, null);\n\t\t\tTypeDescriptor typeDescriptor = new TypeDescriptor(property);\n\t\t\tthis.readerCache.put(cacheKey, new InvokerPair(method, typeDescriptor));\n\t\t\tthis.typeDescriptorCache.put(cacheKey, typeDescriptor);\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\tField field = findField(name, type, target);\n\t\t\tif (field != null) {\n\t\t\t\tTypeDescriptor typeDescriptor = new TypeDescriptor(field);\n\t\t\t\tthis.readerCache.put(cacheKey, new InvokerPair(field, typeDescriptor));\n\t\t\t\tthis.typeDescriptorCache.put(cacheKey, typeDescriptor);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t@Override\n\tpublic TypedValue read(EvaluationContext context, @Nullable Object target, String name) throws AccessException {\n\t\tAssert.state(target != null, \"Target must not be null\");\n\t\tClass<?> type = (target instanceof Class ? (Class<?>) target : target.getClass());\n\t\tif (type.isArray() && name.equals(\"length\")) {\n\t\t\tif (target instanceof Class) {\n\t\t\t\tthrow new AccessException(\"Cannot access length on array class itself\");\n\t\t\t}\n\t\t\treturn new TypedValue(Array.getLength(target));\n\t\t}\n\t\tPropertyCacheKey cacheKey = new PropertyCacheKey(type, name, target instanceof Class);\n\t\tInvokerPair invoker = this.readerCache.get(cacheKey);\n\t\tthis.lastReadInvokerPair = invoker;\n\t\tif (invoker == null || invoker.member instanceof Method) {\n\t\t\tMethod method = (Method) (invoker != null ? invoker.member : null);\n\t\t\tif (method == null) {\n\t\t\t\tmethod = findGetterForProperty(name, type, target);\n\t\t\t\tif (method != null) {\n\t\t\t\t\t// Treat it like a property...\n\t\t\t\t\t// The readerCache will only contain gettable properties (let's not worry about setters for now).\n\t\t\t\t\tProperty property = new Property(type, method, null);\n\t\t\t\t\tTypeDescriptor typeDescriptor = new TypeDescriptor(property);\n\t\t\t\t\tinvoker = new InvokerPair(method, typeDescriptor);\n\t\t\t\t\tthis.lastReadInvokerPair = invoker;\n\t\t\t\t\tthis.readerCache.put(cacheKey, invoker);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (method != null) {\n\t\t\t\ttry {\n\t\t\t\t\tReflectionUtils.makeAccessible(method);\n\t\t\t\t\tObject value = method.invoke(target);\n\t\t\t\t\treturn new TypedValue(value, invoker.typeDescriptor.narrow(value));\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tthrow new AccessException(\"Unable to access property '\" + name + \"' through getter method\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (invoker == null || invoker.member instanceof Field) {\n\t\t\tField field = (Field) (invoker == null ? null : invoker.member);\n\t\t\tif (field == null) {\n\t\t\t\tfield = findField(name, type, target);\n\t\t\t\tif (field != null) {\n\t\t\t\t\tinvoker = new InvokerPair(field, new TypeDescriptor(field));\n\t\t\t\t\tthis.lastReadInvokerPair = invoker;\n\t\t\t\t\tthis.readerCache.put(cacheKey, invoker);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (field != null) {\n\t\t\t\ttry {\n\t\t\t\t\tReflectionUtils.makeAccessible(field);\n\t\t\t\t\tObject value = field.get(target);\n\t\t\t\t\treturn new TypedValue(value, invoker.typeDescriptor.narrow(value));\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tthrow new AccessException(\"Unable to access field '\" + name + \"'\", ex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthrow new AccessException(\"Neither getter method nor field found for property '\" + name + \"'\");\n\t}\n\t@Override\n\tpublic boolean canWrite(EvaluationContext context, @Nullable Object target, String name) throws AccessException {\n\t\tif (!this.allowWrite || target == null) {\n\t\t\treturn false;\n\t\t}\n\t\tClass<?> type = (target instanceof Class ? (Class<?>) target : target.getClass());\n\t\tPropertyCacheKey cacheKey = new PropertyCacheKey(type, name, target instanceof Class);\n\t\tif (this.writerCache.containsKey(cacheKey)) {\n\t\t\treturn true;\n\t\t}\n\t\tMethod method = findSetterForProperty(name, type, target);\n\t\tif (method != null) {\n\t\t\t// Treat it like a property\n\t\t\tProperty property = new Property(type, null, method);\n\t\t\tTypeDescriptor typeDescriptor = new TypeDescriptor(property);\n\t\t\tthis.writerCache.put(cacheKey, method);\n\t\t\tthis.typeDescriptorCache.put(cacheKey, typeDescriptor);\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\tField field = findField(name, type, target);\n\t\t\tif (field != null) {\n\t\t\t\tthis.writerCache.put(cacheKey, field);\n\t\t\t\tthis.typeDescriptorCache.put(cacheKey, new TypeDescriptor(field));\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t@Override\n\tpublic void write(EvaluationContext context, @Nullable Object target, String name, @Nullable Object newValue)\n\t\t\tthrows AccessException {\n\t\tif (!this.allowWrite) {\n\t\t\tthrow new AccessException(\"PropertyAccessor for property '\" + name +\n\t\t\t\t\t\"' on target [\" + target + \"] does not allow write operations\");\n\t\t}\n\t\tAssert.state(target != null, \"Target must not be null\");\n\t\tClass<?> type = (target instanceof Class ? (Class<?>) target : target.getClass());\n\t\tObject possiblyConvertedNewValue = newValue;\n\t\tTypeDescriptor typeDescriptor = getTypeDescriptor(context, target, name);\n\t\tif (typeDescriptor != null) {\n\t\t\ttry {\n\t\t\t\tpossiblyConvertedNewValue = context.getTypeConverter().convertValue(\n\t\t\t\t\t\tnewValue, TypeDescriptor.forObject(newValue), typeDescriptor);\n\t\t\t}\n\t\t\tcatch (EvaluationException evaluationException) {\n\t\t\t\tthrow new AccessException(\"Type conversion failure\", evaluationException);\n\t\t\t}\n\t\t}<fim_middle>// class below has no smell\n"}