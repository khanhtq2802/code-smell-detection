{"text": "<fim_prefix>/*\n * Copyright (c) 2012-2018 Red Hat, Inc.\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *   Red Hat, Inc. - initial API and implementation\n */\npackage org.eclipse.che.inject.lifecycle;\n\nimport com.google.common.cache.CacheBuilder;\nimport com.google.common.cache.CacheLoader;\nimport com.google.common.cache.LoadingCache;\nimport com.google.inject.AbstractModule;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\n\n/** @author andrew00x */\nabstract class LifecycleModule extends AbstractModule {\n  private static class Key {\n    final Class<?> type;\n    final Class<? extends Annotation> annotationType;\n    final int hashCode;\n\n    static Key of(Class<?> type, Class<? extends Annotation> annotationType) {\n      return new Key(type, annotationType);\n    }\n\n<fim_suffix>    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (!(o instanceof Key)) {\n        return false;\n      }\n      Key key = (Key) o;\n      return annotationType.equals(key.annotationType) && type.equals(key.type);\n    }\n\n    @Override\n    public int hashCode() {\n      return hashCode;\n    }\n\n    private Key(Class<?> type, Class<? extends Annotation> annotationType) {\n      this.type = type;\n      this.annotationType = annotationType;\n      int hash = annotationType.hashCode();\n      hash = 31 * hash + type.hashCode();\n      this.hashCode = hash;\n    }\n  }\n\n  private final LoadingCache<Key, Method[]> cache;\n\n  @SuppressWarnings(\"unchecked\")\n  LifecycleModule() {\n    cache =\n        CacheBuilder.newBuilder()\n            .maximumSize(1_000)\n            .expireAfterWrite(1, TimeUnit.HOURS)\n            .build(\n                new CacheLoader<Key, Method[]>() {\n                  @Override\n                  public Method[] load(Key key) throws Exception {\n                    return doGet(key.type, key.annotationType);\n                  }\n                });\n  }\n\n  Method[] get(Class<?> type, Class<? extends Annotation> annotationType) {\n    final Key key = Key.of(type, annotationType);\n    try {\n      return cache.get(key);\n    } catch (ExecutionException e) {\n      // should never happen\n      throw new RuntimeException(e.getLocalizedMessage(), e);\n    }\n  }\n\n  private Method[] doGet(Class<?> type, Class<? extends Annotation> annotationType) {\n    final List<Method> allMethods = getAllMethods(type);\n    final LinkedList<Method> methods = new LinkedList<>();\n    final Set<String> methodNames = new HashSet<>();\n    for (Method method : allMethods) {\n      if (method.isAnnotationPresent(annotationType)\n          && method.getParameterTypes().length == 0\n          && method.getReturnType() == void.class\n          && methodNames.add(method.getName())) {\n        method.setAccessible(true);\n        methods.addFirst(method);\n      }\n    }\n    return methods.toArray(new Method[methods.size()]);\n  }\n\n  private List<Method> getAllMethods(Class<?> c) {\n    final List<Method> list = new ArrayList<>();\n    while (c != null && c != Object.class) {\n      Collections.addAll(list, c.getDeclaredMethods());\n      c = c.getSuperclass();\n    }\n    return list;\n  }\n}<fim_middle>// function below has no smell\n"}