{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.openejb.testing;\n\nimport org.apache.openejb.core.ThreadContext;\nimport org.apache.openejb.util.JavaSecurityManagers;\nimport org.apache.webbeans.config.WebBeansContext;\nimport org.apache.webbeans.inject.OWBInjector;\nimport org.apache.xbean.finder.AnnotationFinder;\nimport org.apache.xbean.finder.archive.FileArchive;\nimport org.junit.rules.MethodRule;\nimport org.junit.rules.TestRule;\nimport org.junit.runner.Description;\nimport org.junit.runner.notification.RunListener;\nimport org.junit.runners.BlockJUnit4ClassRunner;\nimport org.junit.runners.model.FrameworkMethod;\nimport org.junit.runners.model.InitializationError;\nimport org.junit.runners.model.Statement;\n\nimport java.lang.reflect.Field;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport static org.apache.openejb.loader.JarLocation.jarLocation;\n\n// goal is to share the same container for all embedded tests and hold the config there\n// only works if all tests use the same config\npublic class SingleApplicationComposerRunner extends BlockJUnit4ClassRunner {\n    private static volatile boolean started = false;\n    private static final AtomicReference<Object> APP = new AtomicReference<>();\n    private static final AtomicReference<Thread> HOOK = new AtomicReference<>();\n\n    // use when you use another runner like Parameterized of JUnit\n<fim_suffix>    public static class Rule implements TestRule {\n        private final Object test;\n\n        public Rule(final Object test) {\n            this.test = test;\n        }\n\n        @Override\n        public Statement apply(final Statement base, final Description description) {\n            return new Statement() {\n                @Override\n                public void evaluate() throws Throwable {\n                    start(test.getClass());\n                    composerInject(test);\n                    base.evaluate();\n                }\n            };\n        }\n    }\n\n    public static class Start extends RunListener {\n        @Override\n        public void testStarted(final Description description) throws Exception {\n            start(null);\n        }\n    }\n\n    public static void setApp(final Object o) {\n        APP.set(o);\n    }\n\n    public static void close() {\n        final Thread hook = HOOK.get();\n        if (hook != null) {\n            hook.run();\n            Runtime.getRuntime().removeShutdownHook(hook);\n            HOOK.compareAndSet(hook, null);\n            APP.set(null);\n        }\n    }\n\n    public SingleApplicationComposerRunner(final Class<?> klass) throws InitializationError {\n        super(klass);\n    }\n\n    @Override\n    protected List<MethodRule> rules(final Object test) {\n        final List<MethodRule> rules = super.rules(test);\n        rules.add(new MethodRule() {\n            @Override\n            public Statement apply(final Statement base, final FrameworkMethod method, final Object target) {\n                return new Statement() {\n                    @Override\n                    public void evaluate() throws Throwable {\n                        start(getTestClass().getJavaClass());\n                        composerInject(target);\n                        base.evaluate();\n                    }\n                };\n            }\n        });\n        return rules;\n    }\n\n    private static void start(final Class<?> marker) throws Exception {\n        if (APP.get() == null) {\n            final Class<?> type;\n            final String typeStr = JavaSecurityManagers.getSystemProperty(\"tomee.application-composer.application\");\n            if (typeStr != null) {\n                try {\n                    type = Thread.currentThread().getContextClassLoader().loadClass(typeStr);\n                } catch (final ClassNotFoundException e) {\n                    throw new IllegalArgumentException(e);\n                }\n            } else if (marker == null) {\n                throw new IllegalArgumentException(\"set tomee.application-composer.application system property or add a marker to the rule or runner\");\n            } else {\n                final Iterator<Class<?>> descriptors =\n                    new AnnotationFinder(new FileArchive(Thread.currentThread().getContextClassLoader(), jarLocation(marker)), false)\n                        .findAnnotatedClasses(Application.class).iterator();\n                if (!descriptors.hasNext()) {\n                    throw new IllegalArgumentException(\"No descriptor class using @Application\");\n                }\n                type = descriptors.next();\n                if (descriptors.hasNext()) {\n                    throw new IllegalArgumentException(\"Ambiguous @Application: \" + type + \", \" + descriptors.next());\n                }\n            }\n            try {\n                APP.compareAndSet(null, type.newInstance());\n            } catch (final InstantiationException | IllegalAccessException e) {\n                throw new IllegalStateException(e);\n            }\n        }\n        if (!started) {\n            final Object app = APP.get();\n            final ApplicationComposers composers = new ApplicationComposers(app.getClass()) {\n                @Override\n                public void deployApp(final Object inputTestInstance) throws Exception {\n                    super.deployApp(inputTestInstance);\n                    if (!started) {\n                        final ThreadContext previous = ThreadContext.getThreadContext(); // done here for logging\n                        final ApplicationComposers comp = this;\n                        final Thread hook = new Thread() {\n                            @Override\n                            public void run() {\n                                try {\n                                    comp.after();\n                                } catch (final Exception e) {\n                                    ThreadContext.exit(previous);\n                                    throw new IllegalStateException(e);\n                                }\n                            }\n                        };\n                        HOOK.set(hook);\n                        Runtime.getRuntime().addShutdownHook(hook);\n                        started = true;\n                    }\n                }\n            };\n            composers.before(app);\n            composers.handleLifecycle(app.getClass(), app);\n        }\n    }\n\n    private static void composerInject(final Object target) throws IllegalAccessException {\n        WebBeansContext wbc = null;\n        try {\n            wbc = WebBeansContext.currentInstance();\n        } catch (final IllegalStateException ise) {\n            // no-op\n        }\n        if (wbc != null) {\n            OWBInjector.inject(wbc.getBeanManagerImpl(), target, null);\n        }\n\n        final Object app = APP.get();\n        final Class<?> aClass = target.getClass();\n        for (final Field f : aClass.getDeclaredFields()) {\n            if (f.isAnnotationPresent(RandomPort.class)) {\n                for (final Field field : app.getClass().getDeclaredFields()) {\n                    if (field.getType() ==  f.getType()) {\n                        if (!field.isAccessible()) {\n                            field.setAccessible(true);\n                        }\n                        if (!f.isAccessible()) {\n                            f.setAccessible(true);\n                        }\n\n                        final Object value = field.get(app);\n                        f.set(target, value);\n                        break;\n                    }\n                }\n            } else if (f.isAnnotationPresent(Application.class)) {\n                if (!f.isAccessible()) {\n                    f.setAccessible(true);\n                }\n                f.set(target, app);\n            }\n        }\n        final Class<?> superclass = aClass.getSuperclass();\n        if (superclass != Object.class) {\n            composerInject(superclass);\n        }\n    }\n}<fim_middle>// class below has no smell\n"}