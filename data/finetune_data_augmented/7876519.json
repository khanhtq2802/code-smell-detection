{"text": "<fim_prefix>/*\n * Copyright 2016-present Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License. You may obtain\n * a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\n\npackage com.facebook.buck.doctor;\n\nimport static com.facebook.buck.log.MachineReadableLogConfig.PREFIX_BUILD_FINISHED;\nimport static com.facebook.buck.log.MachineReadableLogConfig.PREFIX_EXIT_CODE;\nimport static com.facebook.buck.log.MachineReadableLogConfig.PREFIX_INVOCATION_INFO;\n\nimport com.facebook.buck.core.model.BuildId;\nimport com.facebook.buck.doctor.config.BuildLogEntry;\nimport com.facebook.buck.io.filesystem.ProjectFilesystem;\nimport com.facebook.buck.log.InvocationInfo;\nimport com.facebook.buck.util.BuckConstant;\nimport com.facebook.buck.util.json.ObjectMappers;\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.google.common.collect.ImmutableList;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.FileVisitResult;\nimport java.nio.file.FileVisitor;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.attribute.BasicFileAttributes;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.OptionalInt;\n\n/** Methods for finding and inspecting buck log files. */\npublic class BuildLogHelper {\n\n  private final ProjectFilesystem projectFilesystem;\n\n  public BuildLogHelper(ProjectFilesystem projectFilesystem) {\n    this.projectFilesystem = projectFilesystem;\n  }\n\n<fim_suffix>  public ImmutableList<BuildLogEntry> getBuildLogs() throws IOException {\n    // Remove commands with unknown args or invocations of buck rage.\n    // Sort the remaining logs based on time, reverse order.\n    ImmutableList.Builder<BuildLogEntry> logEntries = ImmutableList.builder();\n    for (Path logFile : getAllBuckLogFiles()) {\n      BuildLogEntry entry = newBuildLogEntry(logFile);\n      if (entry.getCommandArgs().isPresent()\n          && entry.getCommandArgs().get().size() > 0\n          && !entry.getCommandArgs().get().get(0).matches(\"^(rage|doctor|server|launch)$\")) {\n        logEntries.add(newBuildLogEntry(logFile));\n      }\n    }\n    return logEntries\n        .build()\n        .stream()\n        .sorted(Comparator.comparing(BuildLogEntry::getLastModifiedTime).reversed())\n        .collect(ImmutableList.toImmutableList());\n  }\n\n  private BuildLogEntry newBuildLogEntry(Path logFile) throws IOException {\n    BuildLogEntry.Builder builder = BuildLogEntry.builder();\n\n    Path machineReadableLogFile =\n        logFile.getParent().resolve(BuckConstant.BUCK_MACHINE_LOG_FILE_NAME);\n\n    if (projectFilesystem.isFile(machineReadableLogFile)) {\n\n      Optional<InvocationInfo> invocationInfo =\n          readObjectFromLog(\n              machineReadableLogFile,\n              PREFIX_INVOCATION_INFO,\n              new TypeReference<InvocationInfo>() {});\n      Optional<Long> startTimestampMs = Optional.empty();\n\n      if (invocationInfo.isPresent()) {\n        builder.setCommandArgs(\n            Optional.ofNullable(invocationInfo.get().getUnexpandedCommandArgs()));\n        startTimestampMs = Optional.of(invocationInfo.get().getTimestampMillis());\n      }\n\n      builder.setBuildId(\n          Optional.of(\n              invocationInfo.isPresent()\n                  ? invocationInfo.get().getBuildId()\n                  : new BuildId(\"unknown\")));\n      builder.setMachineReadableLogFile(machineReadableLogFile);\n      Optional<Integer> exitCode =\n          readObjectFieldFromLog(machineReadableLogFile, PREFIX_EXIT_CODE, \"exitCode\");\n      Optional<Long> finishTimestampMs =\n          readObjectFieldFromLog(machineReadableLogFile, PREFIX_BUILD_FINISHED, \"timestamp\");\n\n      builder.setExitCode(exitCode.map(OptionalInt::of).orElseGet(OptionalInt::empty));\n      if (finishTimestampMs.isPresent() && startTimestampMs.isPresent()) {\n        builder.setBuildTimeMs(\n            OptionalInt.of((int) (finishTimestampMs.get() - startTimestampMs.get())));\n      }\n    }\n\n    Path ruleKeyLoggerFile = logFile.getParent().resolve(BuckConstant.RULE_KEY_LOGGER_FILE_NAME);\n    if (projectFilesystem.isFile(ruleKeyLoggerFile)) {\n      builder.setRuleKeyLoggerLogFile(ruleKeyLoggerFile);\n    }\n\n    Path ruleKeyDiagKeysFile =\n        logFile.getParent().resolve(BuckConstant.RULE_KEY_DIAG_KEYS_FILE_NAME);\n    if (projectFilesystem.isFile(ruleKeyDiagKeysFile)) {\n      builder.setRuleKeyDiagKeysFile(ruleKeyDiagKeysFile);\n    }\n\n    Path ruleKeyDiagGraphFile =\n        logFile.getParent().resolve(BuckConstant.RULE_KEY_DIAG_GRAPH_FILE_NAME);\n    if (projectFilesystem.isFile(ruleKeyDiagGraphFile)) {\n      builder.setRuleKeyDiagGraphFile(ruleKeyDiagGraphFile);\n    }\n\n    Optional<Path> traceFile =\n        projectFilesystem\n            .getFilesUnderPath(logFile.getParent())\n            .stream()\n            .filter(input -> input.toString().endsWith(\".trace\"))\n            .findFirst();\n\n    return builder\n        .setRelativePath(logFile)\n        .setSize(projectFilesystem.getFileSize(logFile))\n        .setLastModifiedTime(Date.from(projectFilesystem.getLastModifiedTime(logFile).toInstant()))\n        .setTraceFile(traceFile)\n        .build();\n  }\n\n  private <T> Optional<T> readObjectFromLog(\n      Path machineReadableLogFile, String linePrefix, TypeReference<T> typeReference) {\n    try (BufferedReader reader =\n        Files.newBufferedReader(projectFilesystem.resolve(machineReadableLogFile))) {\n      Optional<String> line =\n          reader\n              .lines()\n              .filter(s -> s.startsWith(linePrefix))\n              .map(s -> s.substring(linePrefix.length()))\n              .findFirst();\n      if (line.isPresent()) {\n        return Optional.of(\n            ObjectMappers.READER.readValue(\n                ObjectMappers.createParser(line.get().getBytes(StandardCharsets.UTF_8)),\n                typeReference));\n      }\n    } catch (IOException e) {\n      return Optional.empty();\n    }\n    return Optional.empty();\n  }\n\n  private <T> Optional<T> readObjectFieldFromLog(\n      Path machineReadableLogFile, String linePrefix, String fieldName) {\n    Optional<Map<String, T>> logObject =\n        readObjectFromLog(\n            machineReadableLogFile, linePrefix, new TypeReference<Map<String, T>>() {});\n    if (logObject.isPresent() && logObject.get().containsKey(fieldName)) {\n      return Optional.of(logObject.get().get(fieldName));\n    }\n    return Optional.empty();\n  }\n\n  private Collection<Path> getAllBuckLogFiles() throws IOException {\n    List<Path> logfiles = new ArrayList<>();\n    projectFilesystem.walkRelativeFileTree(\n        projectFilesystem.getBuckPaths().getLogDir(),\n        new FileVisitor<Path>() {\n          @Override\n          public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {\n            return Files.isSymbolicLink(dir)\n                ? FileVisitResult.SKIP_SUBTREE\n                : FileVisitResult.CONTINUE;\n          }\n\n          @Override\n          public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {\n            if (file.getFileName().toString().equals(BuckConstant.BUCK_LOG_FILE_NAME)) {\n              logfiles.add(file);\n            }\n\n            return FileVisitResult.CONTINUE;\n          }\n\n          @Override\n          public FileVisitResult visitFileFailed(Path file, IOException exc) {\n            return FileVisitResult.CONTINUE;\n          }\n\n          @Override\n          public FileVisitResult postVisitDirectory(Path dir, IOException exc) {\n            return FileVisitResult.CONTINUE;\n          }\n        });\n\n    return logfiles;\n  }\n}<fim_middle>// function below has no smell\n"}