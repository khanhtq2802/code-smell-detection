{"text": "<fim_prefix>\n<fim_suffix>public class JavadocFormatter {\n    private static final String CODE_RESET = \"\\033[0m\";\n    private static final String CODE_HIGHLIGHT = \"\\033[1m\";\n    private static final String CODE_UNDERLINE = \"\\033[4m\";\n    private final int lineLimit;\n    private final boolean escapeSequencesSupported;\n    /** Construct the formatter.\n     *\n     * @param lineLimit maximum line length\n     * @param escapeSequencesSupported whether escape sequences are supported\n     */\n    public JavadocFormatter(int lineLimit, boolean escapeSequencesSupported) {\n        this.lineLimit = lineLimit;\n        this.escapeSequencesSupported = escapeSequencesSupported;\n    }\n    private static final int MAX_LINE_LENGTH = 95;\n    private static final int SHORTEST_LINE = 30;\n    private static final int INDENT = 4;\n    /**Format javadoc to plain text.\n     *\n     * @param header element caption that should be used\n     * @param javadoc to format\n     * @return javadoc formatted to plain text\n     */\n    public String formatJavadoc(String header, String javadoc) {\n        try {\n            StringBuilder result = new StringBuilder();\n            result.append(escape(CODE_HIGHLIGHT)).append(header).append(escape(CODE_RESET)).append(\"\\n\");\n            if (javadoc == null) {\n                return result.toString();\n            }\n            JavacTask task = (JavacTask) ToolProvider.getSystemJavaCompiler().getTask(null, null, null, null, null, null);\n            DocTrees trees = DocTrees.instance(task);\n            DocCommentTree docComment = trees.getDocCommentTree(new SimpleJavaFileObject(new URI(\"mem://doc.html\"), Kind.HTML) {\n                @Override @DefinedBy(Api.COMPILER)\n                public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n                    return \"<body>\" + javadoc + \"</body>\";\n                }\n            });\n            new FormatJavadocScanner(result, task).scan(docComment, null);\n            addNewLineIfNeeded(result);\n            return result.toString();\n        } catch (URISyntaxException ex) {\n            throw new InternalError(\"Unexpected exception\", ex);\n        }\n    }\n    private class FormatJavadocScanner extends DocTreeScanner<Object, Object> {\n        private final StringBuilder result;\n        private final JavacTask task;\n        private int reflownTo;\n        private int indent;\n        private int limit = Math.min(lineLimit, MAX_LINE_LENGTH);\n        private boolean pre;\n        private Map<StartElementTree, Integer> tableColumns;\n        public FormatJavadocScanner(StringBuilder result, JavacTask task) {\n            this.result = result;\n            this.task = task;\n        }\n        @Override @DefinedBy(Api.COMPILER_TREE)\n        public Object visitDocComment(DocCommentTree node, Object p) {\n            tableColumns = countTableColumns(node);\n            reflownTo = result.length();\n            scan(node.getFirstSentence(), p);\n            scan(node.getBody(), p);\n            reflow(result, reflownTo, indent, limit);\n            for (Sections current : docSections.keySet()) {\n                boolean seenAny = false;\n                for (DocTree t : node.getBlockTags()) {\n                    if (current.matches(t)) {\n                        if (!seenAny) {\n                            seenAny = true;\n                            if (result.charAt(result.length() - 1) != '\\n')\n                                result.append(\"\\n\");\n                            result.append(\"\\n\");\n                            result.append(escape(CODE_UNDERLINE))\n                                  .append(docSections.get(current))\n                                  .append(escape(CODE_RESET))\n                                  .append(\"\\n\");\n                        }\n                        scan(t, null);\n                    }\n                }\n            }\n            return null;\n        }\n        @Override @DefinedBy(Api.COMPILER_TREE)\n        public Object visitText(TextTree node, Object p) {\n            String text = node.getBody();\n            if (!pre) {\n                text = text.replaceAll(\"[ \\t\\r\\n]+\", \" \").trim();\n                if (text.isEmpty()) {\n                    text = \" \";\n                }\n            } else {\n                text = text.replaceAll(\"\\n\", \"\\n\" + indentString(indent));\n            }\n            result.append(text);\n            return null;\n        }\n        @Override @DefinedBy(Api.COMPILER_TREE)\n        public Object visitLink(LinkTree node, Object p) {\n            if (!node.getLabel().isEmpty()) {\n                scan(node.getLabel(), p);\n            } else {\n                result.append(node.getReference().getSignature());\n            }\n            return null;\n        }\n        @Override @DefinedBy(Api.COMPILER_TREE)\n        public Object visitParam(ParamTree node, Object p) {\n            return formatDef(node.getName().getName(), node.getDescription());\n        }\n        @Override @DefinedBy(Api.COMPILER_TREE)\n        public Object visitThrows(ThrowsTree node, Object p) {\n            return formatDef(node.getExceptionName().getSignature(), node.getDescription());\n        }\n        public Object formatDef(CharSequence name, List<? extends DocTree> description) {\n            result.append(name);\n            result.append(\" - \");\n            reflownTo = result.length();\n            indent = name.length() + 3;\n            if (limit - indent < SHORTEST_LINE) {\n                result.append(\"\\n\");\n                result.append(indentString(INDENT));\n                indent = INDENT;\n                reflownTo += INDENT;\n            }\n            try {\n                return scan(description, null);\n            } finally {\n                reflow(result, reflownTo, indent, limit);\n                result.append(\"\\n\");\n            }\n        }\n        @Override @DefinedBy(Api.COMPILER_TREE)\n        public Object visitLiteral(LiteralTree node, Object p) {\n            return scan(node.getBody(), p);\n        }\n        @Override @DefinedBy(Api.COMPILER_TREE)\n        public Object visitReturn(ReturnTree node, Object p) {\n            reflownTo = result.length();\n            try {\n                return super.visitReturn(node, p);\n            } finally {\n                reflow(result, reflownTo, 0, limit);\n            }\n        }\n        Stack<Integer> listStack = new Stack<>();\n        Stack<Integer> defStack = new Stack<>();\n        Stack<Integer> tableStack = new Stack<>();\n        Stack<List<Integer>> cellsStack = new Stack<>();\n        Stack<List<Boolean>> headerStack = new Stack<>();\n        @Override @DefinedBy(Api.COMPILER_TREE)\n        public Object visitStartElement(StartElementTree node, Object p) {\n            switch (getHtmlTag(node.getName())) {\n                case P:\n                    if (lastNode!= null && lastNode.getKind() == DocTree.Kind.START_ELEMENT &&\n                        HtmlTag.get(((StartElementTree) lastNode).getName()) == HtmlTag.LI) {\n                        //ignore\n                        break;\n                    }\n                    reflowTillNow();\n                    addNewLineIfNeeded(result);\n                    result.append(indentString(indent));\n                    reflownTo = result.length();\n                    break;\n                case BLOCKQUOTE:\n                    reflowTillNow();\n                    indent += INDENT;\n                    break;\n                case PRE:\n                    reflowTillNow();\n                    pre = true;\n                    break;\n                case UL:\n                    reflowTillNow();\n                    listStack.push(-1);\n                    indent += INDENT;\n                    break;\n                case OL:\n                    reflowTillNow();\n                    listStack.push(1);\n                    indent += INDENT;\n                    break;\n                case DL:\n                    reflowTillNow();\n                    defStack.push(indent);\n                    break;\n                case LI:\n                    reflowTillNow();\n                    if (!listStack.empty()) {\n                        addNewLineIfNeeded(result);\n                        int top = listStack.pop();\n                        if (top == (-1)) {\n                            result.append(indentString(indent - 2));\n                            result.append(\"* \");\n                        } else {\n                            result.append(indentString(indent - 3));\n                            result.append(\"\" + top++ + \". \");\n                        }\n                        listStack.push(top);\n                        reflownTo = result.length();\n                    }\n                    break;\n                case DT:\n                    reflowTillNow();\n                    if (!defStack.isEmpty()) {\n                        addNewLineIfNeeded(result);\n                        indent = defStack.peek();\n                        result.append(escape(CODE_HIGHLIGHT));\n                    }\n                    break;\n                case DD:\n                    reflowTillNow();\n                    if (!defStack.isEmpty()) {\n                        if (indent == defStack.peek()) {\n                            result.append(escape(CODE_RESET));\n                        }\n                        addNewLineIfNeeded(result);\n                        indent = defStack.peek() + INDENT;\n                        result.append(indentString(indent));\n                    }\n                    break;\n                case H1: case H2: case H3:\n                case H4: case H5: case H6:\n                    reflowTillNow();\n                    addNewLineIfNeeded(result);\n                    result.append(\"\\n\")\n                          .append(escape(CODE_UNDERLINE));<fim_middle>// class below is blob\n"}