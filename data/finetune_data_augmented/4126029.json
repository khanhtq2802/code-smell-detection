{"text": "<fim_prefix>              LinkedHashMap::putAll);\n    }\n    @Override public boolean equals(final Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || getClass() != o.getClass()) {\n        return false;\n      }\n      final RowKey rowKey = (RowKey) o;\n      return hashCode == rowKey.hashCode\n          && Objects.equals(keys, rowKey.keys);\n    }\n    @Override public int hashCode() {\n      return this.hashCode;\n    }\n  }\n  private static void visitValueNodes(Aggregation aggregation, List<Bucket> parents,\n      BiConsumer<RowKey, MultiValue> consumer) {\n    if (aggregation instanceof MultiValue) {\n      // this is a leaf. publish value of the row.\n      RowKey key = new RowKey(parents);\n      consumer.accept(key, (MultiValue) aggregation);\n      return;\n    }\n    if (aggregation instanceof Bucket) {\n      Bucket bucket = (Bucket) aggregation;\n      if (bucket.hasNoAggregations()) {\n        // bucket with no aggregations is also considered a leaf node\n        visitValueNodes(GroupValue.of(bucket.getName(), bucket.key()), parents, consumer);\n        return;\n      }\n      parents.add(bucket);\n      bucket.getAggregations().forEach(a -> visitValueNodes(a, parents, consumer));\n      parents.remove(parents.size() - 1);\n    } else if (aggregation instanceof HasAggregations) {\n      HasAggregations children = (HasAggregations) aggregation;\n      children.getAggregations().forEach(a -> visitValueNodes(a, parents, consumer));\n    } else if (aggregation instanceof MultiBucketsAggregation) {\n      MultiBucketsAggregation multi = (MultiBucketsAggregation) aggregation;\n      multi.buckets().forEach(b -> visitValueNodes(b, parents, consumer));\n    }\n  }\n  /**\n   * Response from Elastic\n   */\n  @JsonIgnoreProperties(ignoreUnknown = true)\n  static class Result {\n    private final SearchHits hits;\n    private final Aggregations aggregations;\n    private final String scrollId;\n    private final long took;\n    /**\n     * Constructor for this instance.\n     * @param hits list of matched documents\n     * @param took time taken (in took) for this query to execute\n     */\n    @JsonCreator\n    Result(@JsonProperty(\"hits\") SearchHits hits,\n        @JsonProperty(\"aggregations\") Aggregations aggregations,\n        @JsonProperty(\"_scroll_id\") String scrollId,\n        @JsonProperty(\"took\") long took) {\n      this.hits = Objects.requireNonNull(hits, \"hits\");\n      this.aggregations = aggregations;\n      this.scrollId = scrollId;\n      this.took = took;\n    }\n    SearchHits searchHits() {\n      return hits;\n    }\n    Aggregations aggregations() {\n      return aggregations;\n    }\n    Duration took() {\n      return Duration.ofMillis(took);\n    }\n    Optional<String> scrollId() {\n      return Optional.ofNullable(scrollId);\n    }\n  }\n  /**\n   * Similar to {@code SearchHits} in ES. Container for {@link SearchHit}\n   */\n  @JsonIgnoreProperties(ignoreUnknown = true)\n  static class SearchHits {\n    private final long total;\n    private final List<SearchHit> hits;\n    @JsonCreator\n    SearchHits(@JsonProperty(\"total\")final long total,\n               @JsonProperty(\"hits\") final List<SearchHit> hits) {\n      this.total = total;\n      this.hits = Objects.requireNonNull(hits, \"hits\");\n    }\n    public List<SearchHit> hits() {\n      return this.hits;\n    }\n    public long total() {\n      return total;\n    }\n  }\n  /**\n   * Concrete result record which matched the query. Similar to {@code SearchHit} in ES.\n   */\n  @JsonIgnoreProperties(ignoreUnknown = true)\n  static class SearchHit {\n    /**\n     * ID of the document (not available in aggregations)\n     */\n    private final String id;\n    private final Map<String, Object> source;\n    private final Map<String, Object> fields;\n    @JsonCreator\n    SearchHit(@JsonProperty(ElasticsearchConstants.ID) final String id,\n                      @JsonProperty(\"_source\") final Map<String, Object> source,\n                      @JsonProperty(\"fields\") final Map<String, Object> fields) {\n      this.id = Objects.requireNonNull(id, \"id\");\n      // both can't be null\n      if (source == null && fields == null) {\n        final String message = String.format(Locale.ROOT,\n            \"Both '_source' and 'fields' are missing for %s\", id);\n        throw new IllegalArgumentException(message);\n      }\n      // both can't be non-null\n      if (source != null && fields != null) {\n        final String message = String.format(Locale.ROOT,\n            \"Both '_source' and 'fields' are populated (non-null) for %s\", id);\n        throw new IllegalArgumentException(message);\n      }\n      this.source = source;\n      this.fields = fields;\n    }\n    /**\n     * Returns id of this hit (usually document id)\n     * @return unique id\n     */\n    public String id() {\n      return id;\n    }\n    Object valueOrNull(String name) {\n      Objects.requireNonNull(name, \"name\");\n      // for \"select *\" return whole document\n      if (ElasticsearchConstants.isSelectAll(name)) {\n        return sourceOrFields();\n      }\n      if (fields != null && fields.containsKey(name)) {\n        Object field = fields.get(name);\n        if (field instanceof Iterable) {\n          // return first element (or null)\n          Iterator<?> iter = ((Iterable<?>) field).iterator();\n          return iter.hasNext() ? iter.next() : null;\n        }\n        return field;\n      }\n      return valueFromPath(source, name);\n    }\n    /**\n     * Returns property from nested maps given a path like {@code a.b.c}.\n     * @param map current map\n     * @param path field path(s), optionally with dots ({@code a.b.c}).\n     * @return value located at path {@code path} or {@code null} if not found.\n     */\n    private static Object valueFromPath(Map<String, Object> map, String path) {\n      if (map == null) {\n        return null;\n      }\n      if (map.containsKey(path)) {\n        return map.get(path);\n      }\n      // maybe pattern of type a.b.c\n      final int index = path.indexOf('.');\n      if (index == -1) {\n        return null;\n      }\n      final String prefix = path.substring(0, index);\n      final String suffix = path.substring(index + 1);\n      Object maybeMap = map.get(prefix);\n      if (maybeMap instanceof Map) {\n        return valueFromPath((Map<String, Object>) maybeMap, suffix);\n      }\n      return null;\n    }\n    Map<String, Object> source() {\n      return source;\n    }\n    Map<String, Object> fields() {\n      return fields;\n    }\n    Map<String, Object> sourceOrFields() {\n      return source != null ? source : fields;\n    }\n  }\n  /**\n   * {@link Aggregation} container.\n   */\n<fim_suffix>  @JsonDeserialize(using = AggregationsDeserializer.class)\n  static class Aggregations implements Iterable<Aggregation> {\n    private final List<? extends Aggregation> aggregations;\n    private Map<String, Aggregation> aggregationsAsMap;\n    Aggregations(List<? extends Aggregation> aggregations) {\n      this.aggregations = Objects.requireNonNull(aggregations, \"aggregations\");\n    }\n    /**\n     * Iterates over the {@link Aggregation}s.\n     */\n    @Override public final Iterator<Aggregation> iterator() {\n      return asList().iterator();\n    }\n    /**\n     * The list of {@link Aggregation}s.\n     */\n    final List<Aggregation> asList() {\n      return Collections.unmodifiableList(aggregations);\n    }\n    /**\n     * Returns the {@link Aggregation}s keyed by aggregation name. Lazy init.\n     */\n    final Map<String, Aggregation> asMap() {\n      if (aggregationsAsMap == null) {\n        Map<String, Aggregation> map = new LinkedHashMap<>(aggregations.size());\n        for (Aggregation aggregation : aggregations) {\n          map.put(aggregation.getName(), aggregation);\n        }\n        this.aggregationsAsMap = unmodifiableMap(map);\n      }\n      return aggregationsAsMap;\n    }\n    /**\n     * Returns the aggregation that is associated with the specified name.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public final <A extends Aggregation> A get(String name) {\n      return (A) asMap().get(name);\n    }\n    @Override public final boolean equals(Object obj) {\n      if (obj == null || getClass() != obj.getClass()) {\n        return false;\n      }\n      return aggregations.equals(((Aggregations) obj).aggregations);\n    }\n    @Override public final int hashCode() {\n      return Objects.hash(getClass(), aggregations);\n    }\n  }<fim_middle>// class below is data class\n"}