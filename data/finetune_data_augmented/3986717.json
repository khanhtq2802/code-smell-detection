{"text": "<fim_prefix>        PRIMITIVE_CLASSES.put( float.class, Float.class );\n        PRIMITIVE_CLASSES.put( double.class, Double.class );\n    }\n    /**\n     * Convert from primitive class (int, short, double, etc.) to wrapper class (Integer, Short, Double, etc.).\n     * Return the same class if it's not a primitive class. This can therefore safely be used on all types\n     * to ensure that they are not primitives.\n     */\n    private static final Function<Type, Type> WRAPPER_CLASS = clazz -> {\n        Type wrapperClass = WRAPPER_CLASSES.get( clazz );\n        return wrapperClass == null ? clazz : wrapperClass;\n    };\n    /**\n     * Convert from wrapper class (Integer, Short, Double, etc.) to primitive class (int, short, double, etc.).\n     * Return the same class if it's not a wrapper class. This can therefore safely be used on all types\n     * to ensure that they are primitives if possible.\n     */\n    @SuppressWarnings( \"UnusedDeclaration\" )\n    private static final Function<Type, Type> PRIMITIVE_CLASS = aClass -> {\n        Type primitiveClass = PRIMITIVE_CLASSES.get( aClass );\n        return primitiveClass == null ? aClass : primitiveClass;\n    };\n    /**\n     * Function that extract the raw class of a type.\n     */\n    public static final Function<Type, Class<?>> RAW_CLASS = genericType -> {\n        // Calculate raw type\n        if( genericType instanceof Class )\n        {\n            return (Class<?>) genericType;\n        }\n        else if( genericType instanceof ParameterizedType )\n        {\n            return (Class<?>) ( (ParameterizedType) genericType ).getRawType();\n        }\n        else if( genericType instanceof TypeVariable )\n        {\n            return (Class<?>) ( (TypeVariable) genericType ).getGenericDeclaration();\n        }\n        else if( genericType instanceof WildcardType )\n        {\n            return (Class<?>) ( (WildcardType) genericType ).getUpperBounds()[ 0 ];\n        }\n        else if( genericType instanceof GenericArrayType )\n        {\n            Object temp = Array.newInstance( (Class<?>) ( (GenericArrayType) genericType ).getGenericComponentType(), 0 );\n            return temp.getClass();\n        }\n        throw new IllegalArgumentException( \"Could not extract the raw class of \" + genericType );\n    };\n    private static final Function<AccessibleObject, Type> TYPE_OF = accessor -> {\n        if( accessor instanceof Method )\n        {\n            return ( (Method) accessor ).getGenericReturnType();\n        }\n        return ( (Field) accessor ).getGenericType();\n    };\n    private static final Function<Type, Stream<Class<?>>> CLASS_HIERARCHY = new Function<Type, Stream<Class<?>>>()\n    {\n        @Override\n        public Stream<Class<?>> apply( Type type )\n        {\n            if( type == null )\n            {\n                return Stream.empty();\n            }\n            if( type.equals( Object.class ) )\n            {\n                return Stream.of( (Class<?>) type );\n            }\n            else\n            {\n                type = RAW_CLASS.apply( type );\n                Class superclass = ( (Class) type ).getSuperclass();\n                return concat( Stream.of( (Class<?>) type ), apply( superclass ) );\n            }\n        }\n    };\n    @SuppressWarnings( \"raw\" )\n    private static final Function<Type, Stream<? extends Type>> INTERFACES_OF = new Function<Type, Stream<? extends Type>>()\n    {\n        @Override\n        public Stream<? extends Type> apply( Type type )\n        {\n            Class clazz = RAW_CLASS.apply( type );\n            if( clazz.isInterface() )\n            {\n                Stream<? extends Type> genericInterfaces = Arrays.stream( clazz.getGenericInterfaces() );\n                Stream<? extends Type> intfaces = genericInterfaces.flatMap( INTERFACES_OF );\n                return concat( Stream.of( type ), intfaces );\n            }\n            else\n            {\n                if( type.equals( Object.class ) )\n                {\n                    return Arrays.stream( clazz.getGenericInterfaces() );\n                }\n                else\n                {\n                    return concat( Stream.of( clazz.getGenericInterfaces() ).flatMap( INTERFACES_OF ),\n                                   Stream.of( clazz.getSuperclass() ).flatMap( INTERFACES_OF ) );\n                }\n            }\n        }\n    };\n    private static final Function<Type, Stream<? extends Type>> TYPES_OF = type -> {\n        Class clazz = RAW_CLASS.apply( type );\n        if( clazz.isInterface() )\n        {\n            Stream<Type> intfaces = Arrays.stream( clazz.getGenericInterfaces() ).flatMap( INTERFACES_OF );\n            return concat( Stream.of( clazz ), intfaces );\n        }\n        else\n        {\n            return concat( Stream.of( clazz ),\n                           Stream.of( type ).flatMap( CLASS_HIERARCHY ).flatMap( INTERFACES_OF ) );\n        }\n    };\n    public static Type typeOf( AccessibleObject from )\n    {\n        return TYPE_OF.apply( from );\n    }\n    public static Stream<Type> typesOf( Stream<? extends Type> types )\n    {\n        return types.flatMap( TYPES_OF );\n    }\n    public static Stream<? extends Type> typesOf( Type type )\n    {\n        return TYPES_OF.apply( type );\n    }\n    public static Stream<? extends Type> interfacesOf( Stream<? extends Type> types )\n    {\n        return types.flatMap( INTERFACES_OF );\n    }\n    public static Stream<? extends Type> interfacesOf( Type type )\n    {\n        return Stream.of( type ).flatMap( INTERFACES_OF );\n    }\n    public static Stream<Class<?>> classHierarchy( Class<?> type )\n    {\n        return Stream.of( type ).flatMap( CLASS_HIERARCHY );\n    }\n    public static Type wrapperClass( Type type )\n    {\n        return WRAPPER_CLASS.apply( type );\n    }\n    public static Predicate<Class<?>> isAssignableFrom( final Class<?> clazz )\n    {\n        return clazz::isAssignableFrom;\n    }\n    public static Predicate<Object> instanceOf( final Class<?> clazz )\n    {\n        return clazz::isInstance;\n    }\n    public static Predicate<Class<?>> hasModifier( final int classModifier )\n    {\n        return item -> ( item.getModifiers() & classModifier ) != 0;\n    }\n    public static <T> Function<Type, Stream<T>> forClassHierarchy( final Function<Class<?>, Stream<T>> function )\n    {\n        return type -> Stream.of( type ).flatMap( CLASS_HIERARCHY ).flatMap( function );\n    }\n    public static <T> Function<Type, Stream<T>> forTypes( final Function<Type, Stream<T>> function )\n    {\n        return type -> Stream.of( type ).flatMap( TYPES_OF ).flatMap( function );\n    }\n    @SuppressWarnings( \"raw\" )\n    public static Set<Class<?>> interfacesWithMethods( Set<Class<?>> interfaces )\n    {\n        Set<Class<?>> newSet = new LinkedHashSet<>();\n        for( Class type : interfaces )\n        {\n            if( type.isInterface() && type.getDeclaredMethods().length > 0 )\n            {\n                newSet.add( type );\n            }\n        }\n        return newSet;\n    }\n    public static String simpleGenericNameOf( Type type )\n    {\n        StringBuilder sb = new StringBuilder();\n        simpleGenericNameOf( sb, type );\n        return sb.toString();\n    }\n<fim_suffix>    @SuppressWarnings( \"raw\" )\n    private static void simpleGenericNameOf( StringBuilder sb, Type type )\n    {\n        if( type instanceof Class )\n        {\n            sb.append( ( (Class) type ).getSimpleName() );\n        }\n        else if( type instanceof ParameterizedType )\n        {\n            ParameterizedType pt = (ParameterizedType) type;\n            simpleGenericNameOf( sb, pt.getRawType() );\n            sb.append( \"<\" );\n            boolean atLeastOne = false;\n            for( Type typeArgument : pt.getActualTypeArguments() )\n            {\n                if( atLeastOne )\n                {\n                    sb.append( \", \" );\n                }\n                simpleGenericNameOf( sb, typeArgument );\n                atLeastOne = true;\n            }\n            sb.append( \">\" );\n        }\n        else if( type instanceof GenericArrayType )\n        {\n            GenericArrayType gat = (GenericArrayType) type;\n            simpleGenericNameOf( sb, gat.getGenericComponentType() );\n            sb.append( \"[]\" );\n        }\n        else if( type instanceof TypeVariable )\n        {\n            TypeVariable tv = (TypeVariable) type;\n            sb.append( tv.getName() );\n        }\n        else if( type instanceof WildcardType )\n        {\n            WildcardType wt = (WildcardType) type;\n            sb.append( \"? extends \" );\n            boolean atLeastOne = false;\n            for( Type typeArgument : wt.getUpperBounds() )\n            {\n                if( atLeastOne )\n                {\n                    sb.append( \", \" );\n                }\n                simpleGenericNameOf( sb, typeArgument );\n                atLeastOne = true;\n            }\n        }\n        else\n        {\n            throw new IllegalArgumentException( \"Don't know how to deal with type:\" + type );\n        }\n    }<fim_middle>// function below is long method\n"}