{"text": "<fim_prefix>/*\n * Copyright 1999-2018 Alibaba Group Holding Ltd.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.alibaba.druid.pool.ha.selector;\n\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Random;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\nimport javax.sql.DataSource;\n\nimport com.alibaba.druid.pool.DruidDataSource;\nimport com.alibaba.druid.pool.ha.HighAvailableDataSource;\nimport com.alibaba.druid.support.logging.Log;\nimport com.alibaba.druid.support.logging.LogFactory;\n\n/**\n * A selector which uses java.util.Random to choose DataSource.\n *\n * @author DigitalSonic\n */\n<fim_suffix>public class RandomDataSourceSelector implements DataSourceSelector {\n    private final static Log LOG = LogFactory.getLog(RandomDataSourceSelector.class);\n\n    private Random random = new Random();\n    private List<DataSource> blacklist = new CopyOnWriteArrayList<DataSource>();\n    private HighAvailableDataSource highAvailableDataSource;\n    private RandomDataSourceValidateThread validateThread;\n    private RandomDataSourceRecoverThread recoverThread;\n\n    public RandomDataSourceSelector(HighAvailableDataSource highAvailableDataSource) {\n        this.highAvailableDataSource = highAvailableDataSource;\n        if (!highAvailableDataSource.isTestOnBorrow() && !highAvailableDataSource.isTestOnReturn()) {\n            validateThread = new RandomDataSourceValidateThread(this);\n            recoverThread = new RandomDataSourceRecoverThread(this);\n            new Thread(validateThread, \"RandomDataSourceSelector-validate-thread\").start();\n            new Thread(recoverThread, \"RandomDataSourceSelector-recover-thread\").start();\n        } else {\n            LOG.info(\"testOnBorrow or testOnReturn has been set to true, ignore validateThread\");\n        }\n    }\n\n    @Override\n    public boolean isSame(String name) {\n        return getName().equalsIgnoreCase(name);\n    }\n\n    @Override\n    public String getName() {\n        return \"random\";\n    }\n\n    @Override\n    public DataSource get() {\n        Map<String, DataSource> dataSourceMap = getDataSourceMap();\n        if (dataSourceMap == null || dataSourceMap.isEmpty()) {\n            return null;\n        }\n\n        Collection<DataSource> targetDataSourceSet;\n        if (blacklist == null || blacklist.isEmpty() || blacklist.size() >= dataSourceMap.size()) {\n            targetDataSourceSet = dataSourceMap.values();\n        } else {\n            targetDataSourceSet = new HashSet<DataSource>(dataSourceMap.values());\n            for (DataSource b : blacklist) {\n                targetDataSourceSet.remove(b);\n            }\n        }\n\n        DataSource[] dataSources = targetDataSourceSet.toArray(new DataSource[] {});\n        if (dataSources != null && dataSources.length > 0) {\n            return dataSources[random.nextInt(targetDataSourceSet.size())];\n        }\n        return null;\n    }\n\n    @Override\n    public void setTarget(String name) {\n        // do nothing\n    }\n\n    public Map<String, DataSource> getDataSourceMap() {\n        if (highAvailableDataSource != null) {\n            return highAvailableDataSource.getDataSourceMap();\n        }\n        return new HashMap<String, DataSource>();\n    }\n\n    public List<DataSource> getBlacklist() {\n        return blacklist;\n    }\n\n    public void addBlacklist(DataSource dataSource) {\n        if (dataSource != null && !blacklist.contains(dataSource)) {\n            blacklist.add(dataSource);\n            if (dataSource instanceof DruidDataSource) {\n                ((DruidDataSource) dataSource).setTestOnReturn(true);\n            }\n        }\n    }\n\n    public void removeBlacklist(DataSource dataSource) {\n        if (dataSource != null && blacklist.contains(dataSource)) {\n            blacklist.remove(dataSource);\n            if (dataSource instanceof DruidDataSource) {\n                ((DruidDataSource) dataSource).setTestOnReturn(highAvailableDataSource.isTestOnReturn());\n            }\n        }\n    }\n\n    public RandomDataSourceValidateThread getValidateThread() {\n        return validateThread;\n    }\n\n    public RandomDataSourceRecoverThread getRecoverThread() {\n        return recoverThread;\n    }\n}<fim_middle>// class below has no smell\n"}