{"text": "<fim_prefix>/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *  \n *    http://www.apache.org/licenses/LICENSE-2.0\n *  \n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License. \n *  \n */\npackage org.apache.directory.server.core.api.sp;\n\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.apache.directory.api.ldap.model.constants.SchemaConstants;\nimport org.apache.directory.api.ldap.model.cursor.Cursor;\nimport org.apache.directory.api.ldap.model.entry.Attribute;\nimport org.apache.directory.api.ldap.model.entry.Entry;\nimport org.apache.directory.api.ldap.model.entry.Value;\nimport org.apache.directory.api.ldap.model.exception.LdapException;\nimport org.apache.directory.api.ldap.model.exception.LdapInvalidAttributeValueException;\nimport org.apache.directory.api.ldap.model.filter.AndNode;\nimport org.apache.directory.api.ldap.model.filter.BranchNode;\nimport org.apache.directory.api.ldap.model.filter.EqualityNode;\nimport org.apache.directory.api.ldap.model.message.AliasDerefMode;\nimport org.apache.directory.api.ldap.model.message.SearchScope;\nimport org.apache.directory.api.ldap.model.name.Dn;\nimport org.apache.directory.api.ldap.model.schema.AttributeType;\nimport org.apache.directory.server.constants.ApacheSchemaConstants;\nimport org.apache.directory.server.core.api.DirectoryService;\nimport org.apache.directory.server.i18n.I18n;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n\n/**\n * A class loader that loads classes from an LDAP DIT.\n * \n * <p>\n * This loader looks for an configuration entry whose Dn is\n * determined by defaultSearchContextsConfig variable. If there is such\n * an entry it gets the search contexts from the entry and searches the \n * class to be loaded in those contexts.\n * If there is no default search context configuration entry it searches\n * the class in the whole DIT. \n * \n * @author <a href=\"mailto:dev@directory.apache.org\">Apache Directory Project</a>\n */\npublic class LdapClassLoader extends ClassLoader\n{\n    private static final Logger LOG = LoggerFactory.getLogger( LdapClassLoader.class );\n    public static final String DEFAULT_SEARCH_CONTEXTS_CONFIG = \"cn=classLoaderDefaultSearchContext,ou=configuration,ou=system\";\n\n    private Dn defaultSearchDn;\n    private DirectoryService directoryService;\n\n    /** A storage for the ObjectClass attributeType */\n    private AttributeType objectClassAT;\n\n\n<fim_suffix>    public LdapClassLoader( DirectoryService directoryService ) throws LdapException\n    {\n        super( LdapClassLoader.class.getClassLoader() );\n        this.directoryService = directoryService;\n        defaultSearchDn = directoryService.getDnFactory().create( DEFAULT_SEARCH_CONTEXTS_CONFIG );\n\n        objectClassAT = directoryService.getSchemaManager().getAttributeType( SchemaConstants.OBJECT_CLASS_AT );\n    }\n\n\n    private byte[] findClassInDIT( List<Dn> searchContexts, String name ) throws ClassNotFoundException, LdapInvalidAttributeValueException\n    {\n        // Set up the search filter\n        BranchNode filter = new AndNode();\n        AttributeType fqjcnAt = directoryService.getSchemaManager().getAttributeType( \"fullyQualifiedJavaClassName\" );\n        filter.addNode( new EqualityNode<String>( fqjcnAt, new Value( fqjcnAt, name ) ) );\n        filter.addNode( new EqualityNode<String>( objectClassAT,\n            new Value( objectClassAT, ApacheSchemaConstants.JAVA_CLASS_OC ) ) );\n\n        try\n        {\n            for ( Dn base : searchContexts )\n            {\n                Cursor<Entry> cursor = null;\n                try\n                {\n                    cursor = directoryService.getAdminSession()\n                        .search( base, SearchScope.SUBTREE, filter, AliasDerefMode.DEREF_ALWAYS );\n\n                    cursor.beforeFirst();\n                    if ( cursor.next() ) // there should be only one!\n                    {\n                        LOG.debug( \"Class {} found under {} search context.\", name, base );\n                        Entry classEntry = cursor.get();\n\n                        if ( cursor.next() )\n                        {\n                            Entry other = cursor.get();\n                            LOG.warn( \"More than one class found on classpath at locations: {} \\n\\tand {}\",\n                                classEntry, other );\n                        }\n\n                        return classEntry.get( \"javaClassByteCode\" ).getBytes();\n                    }\n                }\n                finally\n                {\n                    if ( cursor != null )\n                    {\n                        cursor.close();\n                    }\n                }\n            }\n        }\n        catch ( Exception e )\n        {\n            LOG.error( I18n.err( I18n.ERR_69, name ), e );\n        }\n\n        throw new ClassNotFoundException();\n    }\n\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Class<?> findClass( String name ) throws ClassNotFoundException\n    {\n        byte[] classBytes = null;\n\n        try\n        {\n            // TODO we should cache this information and register with the event\n            // service to get notified if this changes so we can update the cached\n            // copy - there's absolutely no reason why we should be performing this\n            // lookup every time!!!\n\n            Entry configEntry = null;\n\n            try\n            {\n                configEntry = directoryService.getAdminSession().lookup( defaultSearchDn );\n            }\n            catch ( LdapException e )\n            {\n                LOG.debug( \"No configuration data found for class loader default search contexts.\" );\n            }\n\n            if ( configEntry != null )\n            {\n                List<Dn> searchContexts = new ArrayList<>();\n                Attribute attr = configEntry.get( \"classLoaderDefaultSearchContext\" );\n\n                for ( Value val : attr )\n                {\n                    Dn dn = directoryService.getDnFactory().create( val.getString() );\n                    searchContexts.add( dn );\n                }\n\n                try\n                {\n                    classBytes = findClassInDIT( searchContexts, name );\n\n                    if ( LOG.isDebugEnabled() )\n                    { \n                        LOG.debug( \"Class {} found under default search contexts.\", name );\n                    }\n                }\n                catch ( ClassNotFoundException e )\n                {\n                    if ( LOG.isDebugEnabled() )\n                    { \n                        LOG.debug( \"Class {} could not be found under default search contexts.\", name );\n                    }\n                }\n            }\n\n            if ( classBytes == null )\n            {\n                List<Dn> namingContexts = new ArrayList<>();\n\n                Set<String> suffixes = directoryService.getPartitionNexus().listSuffixes();\n\n                for ( String suffix : suffixes )\n                {\n                    Dn suffixDn = directoryService.getDnFactory().create( suffix );\n                    namingContexts.add( suffixDn );\n                }\n\n                classBytes = findClassInDIT( namingContexts, name );\n            }\n        }\n        catch ( ClassNotFoundException e )\n        {\n            String msg = I18n.err( I18n.ERR_293, name );\n            LOG.debug( msg );\n            throw new ClassNotFoundException( msg );\n        }\n        catch ( Exception e )\n        {\n            String msg = I18n.err( I18n.ERR_70, name );\n            LOG.error( msg, e );\n            throw new ClassNotFoundException( msg );\n        }\n\n        return defineClass( name, classBytes, 0, classBytes.length );\n    }\n}<fim_middle>// function below has no smell\n"}