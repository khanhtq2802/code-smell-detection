{"text": "<fim_prefix>\n<fim_suffix>public class StreamRecords {\n\t/**\n\t * Create a new {@link ByteRecord} for the given raw field/value pairs.\n\t *\n\t * @param raw must not be {@literal null}.\n\t * @return new instance of {@link ByteRecord}.\n\t */\n\tpublic static ByteRecord rawBytes(Map<byte[], byte[]> raw) {\n\t\treturn new ByteMapBackedRecord(null, RecordId.autoGenerate(), raw);\n\t}\n\t/**\n\t * Create a new {@link ByteBufferRecord} for the given raw field/value pairs.\n\t *\n\t * @param raw must not be {@literal null}.\n\t * @return new instance of {@link ByteBufferRecord}.\n\t */\n\tpublic static ByteBufferRecord rawBuffer(Map<ByteBuffer, ByteBuffer> raw) {\n\t\treturn new ByteBufferMapBackedRecord(null, RecordId.autoGenerate(), raw);\n\t}\n\t/**\n\t * Create a new {@link ByteBufferRecord} for the given raw field/value pairs.\n\t *\n\t * @param raw must not be {@literal null}.\n\t * @return new instance of {@link ByteBufferRecord}.\n\t */\n\tpublic static StringRecord string(Map<String, String> raw) {\n\t\treturn new StringMapBackedRecord(null, RecordId.autoGenerate(), raw);\n\t}\n\t/**\n\t * Create a new {@link MapRecord} backed by the field/value pairs of the given {@link Map}.\n\t *\n\t * @param map must not be {@literal null}.\n\t * @param <S> type of the stream key.\n\t * @param <K> type of the map key.\n\t * @param <V> type of the map value.\n\t * @return new instance of {@link MapRecord}.\n\t */\n\tpublic static <S, K, V> MapRecord<S, K, V> mapBacked(Map<K, V> map) {\n\t\treturn new MapBackedRecord<>(null, RecordId.autoGenerate(), map);\n\t}\n\t/**\n\t * Create new {@link ObjectRecord} backed by the given value.\n\t *\n\t * @param value must not be {@literal null}.\n\t * @param <S> the stream key type\n\t * @param <V> the value type.\n\t * @return new instance of {@link ObjectRecord}.\n\t */\n\tpublic static <S, V> ObjectRecord<S, V> objectBacked(V value) {\n\t\treturn new ObjectBackedRecord<>(null, RecordId.autoGenerate(), value);\n\t}\n\t/**\n\t * Obtain new instance of {@link RecordBuilder} to fluently create {@link Record records}.\n\t *\n\t * @return new instance of {@link RecordBuilder}.\n\t */\n\tpublic static RecordBuilder<?> newRecord() {\n\t\treturn new RecordBuilder<>(null, RecordId.autoGenerate());\n\t}\n\t// Utility constructor\n\tprivate StreamRecords() {}\n\t/**\n\t * Builder for {@link Record}.\n\t * \n\t * @param <S> stream keyy type.\n\t */\n\tpublic static class RecordBuilder<S> {\n\t\tprivate RecordId id;\n\t\tprivate S stream;\n\t\tRecordBuilder(@Nullable S stream, RecordId recordId) {\n\t\t\tthis.stream = stream;\n\t\t\tthis.id = recordId;\n\t\t}\n\t\t/**\n\t\t * Configure a stream key.\n\t\t * \n\t\t * @param stream the stream key, must not be null.\n\t\t * @param <STREAM_KEY>\n\t\t * @return {@literal this} {@link RecordBuilder}.\n\t\t */\n\t\tpublic <STREAM_KEY> RecordBuilder<STREAM_KEY> in(STREAM_KEY stream) {\n\t\t\tAssert.notNull(stream, \"Stream key must not be null\");\n\t\t\treturn new RecordBuilder<>(stream, id);\n\t\t}\n\t\t/**\n\t\t * Configure a record Id given a {@link String}. Associates a user-supplied record id instead of using\n\t\t * server-generated record Id's.\n\t\t * \n\t\t * @param id the record id.\n\t\t * @return {@literal this} {@link RecordBuilder}.\n\t\t * @see RecordId\n\t\t */\n\t\tpublic RecordBuilder<S> withId(String id) {\n\t\t\treturn withId(RecordId.of(id));\n\t\t}\n\t\t/**\n\t\t * Configure a {@link RecordId}. Associates a user-supplied record id instead of using server-generated record Id's.\n\t\t * \n\t\t * @param id the record id.\n\t\t * @return {@literal this} {@link RecordBuilder}.\n\t\t */\n\t\tpublic RecordBuilder<S> withId(RecordId id) {\n\t\t\tAssert.notNull(id, \"RecordId must not be null\");\n\t\t\tthis.id = id;\n\t\t\treturn this;\n\t\t}\n\t\t/**\n\t\t * Create a {@link MapRecord}.\n\t\t * \n\t\t * @param map\n\t\t * @param <K>\n\t\t * @param <V>\n\t\t * @return new instance of {@link MapRecord}.\n\t\t */\n\t\tpublic <K, V> MapRecord<S, K, V> ofMap(Map<K, V> map) {\n\t\t\treturn new MapBackedRecord<>(stream, id, map);\n\t\t}\n\t\t/**\n\t\t * Create a {@link StringRecord}.\n\t\t * \n\t\t * @param map\n\t\t * @return new instance of {@link StringRecord}.\n\t\t * @see MapRecord\n\t\t */\n\t\tpublic StringRecord ofStrings(Map<String, String> map) {\n\t\t\treturn new StringMapBackedRecord(ObjectUtils.nullSafeToString(stream), id, map);\n\t\t}\n\t\t/**\n\t\t * Create an {@link ObjectRecord}.\n\t\t * \n\t\t * @param value\n\t\t * @param <V>\n\t\t * @return new instance of {@link ObjectRecord}.\n\t\t */\n\t\tpublic <V> ObjectRecord<S, V> ofObject(V value) {\n\t\t\treturn new ObjectBackedRecord<>(stream, id, value);\n\t\t}\n\t\t/**\n\t\t * @param value\n\t\t * @return new instance of {@link ByteRecord}.\n\t\t */\n\t\tpublic ByteRecord ofBytes(Map<byte[], byte[]> value) {\n\t\t\t// todo auto conversion of known values\n\t\t\treturn new ByteMapBackedRecord((byte[]) stream, id, value);\n\t\t}\n\t\t/**\n\t\t * @param value\n\t\t * @return new instance of {@link ByteBufferRecord}.\n\t\t */\n\t\tpublic ByteBufferRecord ofBuffer(Map<ByteBuffer, ByteBuffer> value) {\n\t\t\tByteBuffer streamKey;\n\t\t\tif (stream instanceof ByteBuffer) {\n\t\t\t\tstreamKey = (ByteBuffer) stream;\n\t\t\t} else if (stream instanceof String) {\n\t\t\t\tstreamKey = ByteUtils.getByteBuffer((String) stream);\n\t\t\t} else if (stream instanceof byte[]) {\n\t\t\t\tstreamKey = ByteBuffer.wrap((byte[]) stream);\n\t\t\t} else {\n\t\t\t\tthrow new IllegalArgumentException(String.format(\"Stream key %s cannot be converted to byte buffer.\", stream));\n\t\t\t}\n\t\t\treturn new ByteBufferMapBackedRecord(streamKey, id, value);\n\t\t}\n\t}\n\t/**\n\t * Default implementation of {@link MapRecord}.\n\t *\n\t * @param <S>\n\t * @param <K>\n\t * @param <V>\n\t */\n\tstatic class MapBackedRecord<S, K, V> implements MapRecord<S, K, V> {\n\t\tprivate @Nullable S stream;\n\t\tprivate RecordId recordId;\n\t\tprivate final Map<K, V> kvMap;\n\t\tMapBackedRecord(@Nullable S stream, RecordId recordId, Map<K, V> kvMap) {\n\t\t\tthis.stream = stream;\n\t\t\tthis.recordId = recordId;\n\t\t\tthis.kvMap = kvMap;\n\t\t}\n\t\t@Nullable\n\t\t@Override\n\t\tpublic S getStream() {\n\t\t\treturn stream;\n\t\t}\n\t\t@Nullable\n\t\t@Override\n\t\tpublic RecordId getId() {\n\t\t\treturn recordId;\n\t\t}\n\t\t@Override\n\t\tpublic Iterator<Entry<K, V>> iterator() {\n\t\t\treturn kvMap.entrySet().iterator();\n\t\t}\n\t\t@Override\n\t\tpublic Map<K, V> getValue() {\n\t\t\treturn kvMap;\n\t\t}\n\t\t@Override\n\t\tpublic MapRecord<S, K, V> withId(RecordId id) {\n\t\t\treturn new MapBackedRecord<>(stream, id, this.kvMap);\n\t\t}\n\t\t@Override\n\t\tpublic <S1> MapRecord<S1, K, V> withStreamKey(S1 key) {\n\t\t\treturn new MapBackedRecord<>(key, recordId, this.kvMap);\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"MapBackedRecord{\" + \"recordId=\" + recordId + \", kvMap=\" + kvMap + '}';\n\t\t}\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\tif (o == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (this == o) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (!ClassUtils.isAssignable(MapBackedRecord.class, o.getClass())) {\n\t\t\t\treturn false;\n\t\t\t}<fim_middle>// class below is blob\n"}