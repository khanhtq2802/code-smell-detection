{"text": "<fim_prefix>\n<fim_suffix>  public static class PutAllEntryData {\n    final Object key;\n    private Object value;\n    private final Object oldValue;\n    private final Operation op;\n    private EventID eventID;\n    transient EntryEventImpl event;\n    private Integer bucketId = Integer.valueOf(-1);\n    protected transient boolean callbacksInvoked = false;\n    public FilterRoutingInfo filterRouting;\n    // One flags byte for all booleans\n    protected byte flags = 0x00;\n    // TODO: Yogesh, this should be intialized and sent on wire only when\n    // parallel wan is enabled\n    private Long tailKey = 0L;\n    public VersionTag versionTag;\n    transient boolean inhibitDistribution;\n    /**\n     * Constructor to use when preparing to send putall data out\n     */\n    public PutAllEntryData(EntryEventImpl event) {\n      this.key = event.getKey();\n      this.value = event.getRawNewValueAsHeapObject();\n      Object oldValue = event.getRawOldValueAsHeapObject();\n      if (oldValue == Token.NOT_AVAILABLE || Token.isRemoved(oldValue)) {\n        this.oldValue = null;\n      } else {\n        this.oldValue = oldValue;\n      }\n      this.op = event.getOperation();\n      this.eventID = event.getEventId();\n      this.tailKey = event.getTailKey();\n      this.versionTag = event.getVersionTag();\n      setNotifyOnly(!event.getInvokePRCallbacks());\n      setCallbacksInvoked(event.callbacksInvoked());\n      setPossibleDuplicate(event.isPossibleDuplicate());\n      setInhibitDistribution(event.getInhibitDistribution());\n    }\n    /**\n     * Constructor to use when receiving a putall from someone else\n     */\n    public PutAllEntryData(DataInput in, EventID baseEventID, int idx, Version version,\n        ByteArrayDataInput bytesIn) throws IOException, ClassNotFoundException {\n      this.key = DataSerializer.readObject(in);\n      byte flgs = in.readByte();\n      if ((flgs & IS_OBJECT) != 0) {\n        this.value = DataSerializer.readObject(in);\n      } else {\n        byte[] bb = DataSerializer.readByteArray(in);\n        if ((flgs & IS_CACHED_DESER) != 0) {\n          this.value = new FutureCachedDeserializable(bb);\n        } else {\n          this.value = bb;\n        }\n      }\n      this.oldValue = null;\n      this.op = Operation.fromOrdinal(in.readByte());\n      this.flags = in.readByte();\n      if ((this.flags & FILTER_ROUTING) != 0) {\n        this.filterRouting = (FilterRoutingInfo) DataSerializer.readObject(in);\n      }\n      if ((this.flags & VERSION_TAG) != 0) {\n        boolean persistentTag = (this.flags & PERSISTENT_TAG) != 0;\n        this.versionTag = VersionTag.create(persistentTag, in);\n      }\n      if (isUsedFakeEventId()) {\n        this.eventID = new EventID();\n        InternalDataSerializer.invokeFromData(this.eventID, in);\n      } else {\n        this.eventID = new EventID(baseEventID, idx);\n      }\n      if ((this.flags & HAS_TAILKEY) != 0) {\n        this.tailKey = DataSerializer.readLong(in);\n      }\n    }\n    @Override\n    public String toString() {\n      StringBuilder sb = new StringBuilder(50);\n      sb.append(\"(\").append(getKey()).append(\",\").append(this.value).append(\",\")\n          .append(getOldValue());\n      if (this.bucketId > 0) {\n        sb.append(\", b\").append(this.bucketId);\n      }\n      if (versionTag != null) {\n        sb.append(versionTag);\n        // sb.append(\",v\").append(versionTag.getEntryVersion()).append(\",rv\"+versionTag.getRegionVersion());\n      }\n      if (filterRouting != null) {\n        sb.append(\", \").append(filterRouting);\n      }\n      sb.append(\")\");\n      return sb.toString();\n    }\n    void setSender(InternalDistributedMember sender) {\n      if (this.versionTag != null) {\n        this.versionTag.replaceNullIDs(sender);\n      }\n    }\n    /**\n     * Used to serialize this instances data to <code>out</code>. If changes are made to this method\n     * make sure that it is backwards compatible by creating toDataPreXX methods. Also make sure\n     * that the callers to this method are backwards compatible by creating toDataPreXX methods for\n     * them even if they are not changed. <br>\n     * Callers for this method are: <br>\n     * {@link PutAllMessage#toData(DataOutput)} <br>\n     * {@link PutAllPRMessage#toData(DataOutput)} <br>\n     * {@link RemotePutAllMessage#toData(DataOutput)} <br>\n     */\n    public void toData(final DataOutput out) throws IOException {\n      Object key = this.key;\n      final Object v = this.value;\n      DataSerializer.writeObject(key, out);\n      if (v instanceof byte[] || v == null) {\n        out.writeByte(0);\n        DataSerializer.writeByteArray((byte[]) v, out);\n      } else if (v instanceof CachedDeserializable) {\n        CachedDeserializable cd = (CachedDeserializable) v;\n        out.writeByte(IS_CACHED_DESER);\n        DataSerializer.writeByteArray(cd.getSerializedValue(), out);\n      } else {\n        out.writeByte(IS_CACHED_DESER);\n        DataSerializer.writeObjectAsByteArray(v, out);\n      }\n      out.writeByte(this.op.ordinal);\n      byte bits = this.flags;\n      if (this.filterRouting != null)\n        bits |= FILTER_ROUTING;\n      if (this.versionTag != null) {\n        bits |= VERSION_TAG;\n        if (this.versionTag instanceof DiskVersionTag) {\n          bits |= PERSISTENT_TAG;\n        }\n      }\n      // TODO: Yogesh, this should be conditional,\n      // make sure that we sent it on wire only\n      // when parallel wan is enabled\n      bits |= HAS_TAILKEY;\n      out.writeByte(bits);\n      if (this.filterRouting != null) {\n        DataSerializer.writeObject(this.filterRouting, out);\n      }\n      if (this.versionTag != null) {\n        InternalDataSerializer.invokeToData(this.versionTag, out);\n      }\n      if (isUsedFakeEventId()) {\n        // fake event id should be serialized\n        InternalDataSerializer.invokeToData(this.eventID, out);\n      }\n      // TODO: Yogesh, this should be conditional,\n      // make sure that we sent it on wire only\n      // when parallel wan is enabled\n      DataSerializer.writeLong(this.tailKey, out);\n    }\n    /**\n     * Returns the key\n     */\n    public Object getKey() {\n      return this.key;\n    }\n    /**\n     * Returns the value\n     */\n    public Object getValue(InternalCache cache) {\n      Object result = this.value;\n      if (result instanceof FutureCachedDeserializable) {\n        FutureCachedDeserializable future = (FutureCachedDeserializable) result;\n        result = future.create(cache);\n        this.value = result;\n      }\n      return result;\n    }\n    /**\n     * Returns the old value\n     */\n    public Object getOldValue() {\n      return this.oldValue;\n    }\n    public Long getTailKey() {\n      return this.tailKey;\n    }\n    public void setTailKey(Long key) {\n      this.tailKey = key;\n    }\n    /**\n     * Returns the operation\n     */\n    public Operation getOp() {\n      return this.op;\n    }\n    public EventID getEventID() {\n      return this.eventID;\n    }\n    /**\n     * change event id for the entry\n     *\n     * @param eventId new event id\n     */\n    public void setEventId(EventID eventId) {\n      this.eventID = eventId;\n    }\n    /**\n     * change bucket id for the entry\n     *\n     * @param bucketId new bucket id\n     */\n    public void setBucketId(Integer bucketId) {\n      this.bucketId = bucketId;\n    }\n    /**\n     * get bucket id for the entry\n     *\n     * @return bucket id\n     */\n    public Integer getBucketId() {\n      return this.bucketId;\n    }\n    /**\n     * change event id into fake event id The algorithm is to change the threadid into\n     * bucketid*MAX_THREAD_PER_CLIENT+oldthreadid. So from the log, we can derive the original\n     * thread id.\n     *\n     * @return wether current event id is fake or not new bucket id\n     */\n    public boolean setFakeEventID() {\n      if (bucketId.intValue() < 0) {\n        return false;\n      }\n      if (!isUsedFakeEventId()) {\n        // assign a fake big thread id. bucket id starts from 0. In order to distinguish<fim_middle>// class below is blob\n"}