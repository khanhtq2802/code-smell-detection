{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.wicket.util.file;\n\nimport java.io.IOException;\nimport java.net.URI;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.apache.wicket.util.lang.Bytes;\n\n/**\n * This folder subclass provides some type safety and extensibility for \"files\" that hold other\n * files.\n * \n * @author Jonathan Locke\n */\npublic class Folder extends File\n{\n\t/**\n\t * Filter for files\n\t * \n\t * @author Jonathan Locke\n\t */\n<fim_suffix>\tpublic static interface FileFilter\n\t{\n\t\t/**\n\t\t * File filter that matches all files\n\t\t */\n\t\tpublic static FileFilter ALL_FILES = new FileFilter()\n\t\t{\n\t\t\t@Override\n\t\t\tpublic boolean accept(final File file)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * @param file\n\t\t *            The file to test\n\t\t * @return True if the file should be accepted\n\t\t */\n\t\tpublic boolean accept(File file);\n\t}\n\n\t/**\n\t * Filter for folders\n\t * \n\t * @author Jonathan Locke\n\t */\n\tpublic static interface FolderFilter\n\t{\n\t\t/**\n\t\t * @param folder\n\t\t *            The folder to test\n\t\t * @return True if the file should be accepted\n\t\t */\n\t\tpublic boolean accept(Folder folder);\n\t}\n\n\tprivate static final long serialVersionUID = 1L;\n\n\t/**\n\t * Constructor.\n\t * \n\t * @param parent\n\t *            parent\n\t * @param child\n\t *            child\n\t */\n\tpublic Folder(final Folder parent, final String child)\n\t{\n\t\tsuper(parent, child);\n\t}\n\n\t/**\n\t * Construct.\n\t * \n\t * @param file\n\t *            File\n\t */\n\tpublic Folder(final java.io.File file)\n\t{\n\t\tthis(file.getPath());\n\t}\n\n\t/**\n\t * Constructor.\n\t * \n\t * @param pathname\n\t *            path name\n\t */\n\tpublic Folder(final String pathname)\n\t{\n\t\tsuper(pathname);\n\t}\n\n\t/**\n\t * Constructor.\n\t * \n\t * @param parent\n\t *            parent\n\t * @param child\n\t *            child\n\t */\n\tpublic Folder(final String parent, final String child)\n\t{\n\t\tsuper(parent, child);\n\t}\n\n\t/**\n\t * Constructor.\n\t * \n\t * @param uri\n\t *            folder uri\n\t */\n\tpublic Folder(final URI uri)\n\t{\n\t\tsuper(uri);\n\t}\n\n\t/**\n\t * Does a mkdirs() on this folder if it does not exist. If the folder cannot be created, an\n\t * IOException is thrown.\n\t * \n\t * @throws IOException\n\t *             Thrown if folder cannot be created\n\t */\n\tpublic void ensureExists() throws IOException\n\t{\n\t\tif (!exists() && !mkdirs())\n\t\t{\n\t\t\tthrow new IOException(\"Unable to create folder \" + this);\n\t\t}\n\t}\n\n\t/**\n\t * @param name\n\t *            Name of child folder\n\t * @return Child file object\n\t */\n\tpublic Folder folder(final String name)\n\t{\n\t\treturn new Folder(this, name);\n\t}\n\n\t/**\n\t * @return Disk space free on the partition where this folder lives\n\t */\n\tpublic Bytes freeDiskSpace()\n\t{\n\t\treturn Bytes.bytes(super.getFreeSpace());\n\t}\n\n\t/**\n\t * @return Files in this folder\n\t */\n\tpublic File[] getFiles()\n\t{\n\t\treturn getFiles(FileFilter.ALL_FILES);\n\t}\n\n\t/**\n\t * @return All files nested within this folder\n\t */\n\tpublic File[] getNestedFiles()\n\t{\n\t\treturn getNestedFiles(FileFilter.ALL_FILES);\n\t}\n\n\t/**\n\t * Gets files in this folder matching a given filter recursively.\n\t * \n\t * @param filter\n\t *            The filter\n\t * @return The list of files\n\t */\n\tpublic File[] getNestedFiles(final FileFilter filter)\n\t{\n\t\tfinal List<File> files = new ArrayList<>();\n\t\tfiles.addAll(Arrays.asList(getFiles(filter)));\n\t\tfinal Folder[] folders = getFolders();\n\t\tfor (Folder folder : folders)\n\t\t{\n\t\t\tfiles.addAll(Arrays.asList(folder.getNestedFiles(filter)));\n\t\t}\n\t\treturn files.toArray(new File[files.size()]);\n\t}\n\n\t/**\n\t * @param filter\n\t *            File filter\n\t * @return Files\n\t */\n\tpublic File[] getFiles(final FileFilter filter)\n\t{\n\t\t// Get list of java.io files\n\t\tfinal java.io.File[] files = listFiles(new java.io.FileFilter()\n\t\t{\n\t\t\t/**\n\t\t\t * @see java.io.FileFilter#accept(java.io.File)\n\t\t\t */\n\t\t\t@Override\n\t\t\tpublic boolean accept(final java.io.File file)\n\t\t\t{\n\t\t\t\treturn file.isFile() && filter.accept(new File(file));\n\t\t\t}\n\t\t});\n\n\t\t// Convert java.io files to org.apache.wicket files\n\t\tif (files != null)\n\t\t{\n\t\t\tfinal File[] wicketFiles = new File[files.length];\n\t\t\tfor (int i = 0; i < files.length; i++)\n\t\t\t{\n\t\t\t\twicketFiles[i] = new File(files[i]);\n\t\t\t}\n\t\t\treturn wicketFiles;\n\t\t}\n\t\treturn new File[0];\n\t}\n\n\t/**\n\t * Gets all folders in this folder, except \".\" and \"..\"\n\t * \n\t * @return Folders\n\t */\n\tpublic Folder[] getFolders()\n\t{\n\t\treturn getFolders(new FolderFilter()\n\t\t{\n\t\t\t@Override\n\t\t\tpublic boolean accept(final Folder folder)\n\t\t\t{\n\t\t\t\tfinal String name = folder.getName();\n\t\t\t\treturn !name.equals(\".\") && !name.equals(\"..\");\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * @param filter\n\t *            Folder filter\n\t * @return Folders\n\t */\n\tpublic Folder[] getFolders(final FolderFilter filter)\n\t{\n\t\t// Get java io files that are directories matching the filter\n\t\tfinal java.io.File[] files = listFiles(new java.io.FileFilter()\n\t\t{\n\t\t\t/**\n\t\t\t * @see java.io.FileFilter#accept(java.io.File)\n\t\t\t */\n\t\t\t@Override\n\t\t\tpublic boolean accept(final java.io.File file)\n\t\t\t{\n\t\t\t\treturn file.isDirectory() && filter.accept(new Folder(file.getPath()));\n\t\t\t}\n\t\t});\n\n\t\t// Convert\n\t\tif (files != null)\n\t\t{\n\t\t\tfinal Folder[] wicketFolders = new Folder[files.length];\n\t\t\tfor (int i = 0; i < files.length; i++)\n\t\t\t{\n\t\t\t\twicketFolders[i] = new Folder(files[i]);\n\t\t\t}\n\t\t\treturn wicketFolders;\n\t\t}\n\t\treturn new Folder[0];\n\t}\n\n\t/**\n\t * Removes this folder and everything in it, recursively. A best effort is made to remove nested\n\t * folders and files in depth-first order.\n\t * \n\t * @return True if the folder was successfully removed\n\t */\n\t@Override\n\tpublic boolean remove()\n\t{\n\t\treturn remove(this);\n\t}\n\n\t/**\n\t * Removes all the files in this folder.\n\t * \n\t * @return True if any files were successfully removed\n\t */\n\tpublic boolean removeFiles()\n\t{\n\t\tfinal File[] files = getFiles();\n\t\tboolean success = true;\n\t\tfor (File file : files)\n\t\t{\n\t\t\tsuccess = file.remove() && success;\n\t\t}\n\t\treturn success;\n\t}\n\n\t/**\n\t * Removes everything in the given folder and then the folder itself.\n\t * \n\t * @param folder\n\t *            The folder\n\t * @return True if the folder was successfully removed\n\t */\n\tprivate boolean remove(final Folder folder)\n\t{\n\t\tfinal Folder[] folders = getFolders();\n\t\tboolean success = true;\n\t\tfor (Folder subfolder : folders)\n\t\t{\n\t\t\tsuccess = subfolder.remove() && success;\n\t\t}\n\t\tsuccess = removeFiles() && success;\n\t\treturn folder.delete() && success;\n\t}\n}<fim_middle>// class below has no smell\n"}