{"text": "<fim_prefix>\n<fim_suffix>public class ImportFolderCollection extends ImportItemCollectionBase {\n    private static final String NEWLINE = System.getProperty(\"line.separator\"); //$NON-NLS-1$\n    private static final String ROOT_ELEMENT_NAME = \"TFSImportSelectionSet\"; //$NON-NLS-1$\n    private static final String FOLDER_PATHS_ELEMENT_NAME = \"ServerFolderPaths\"; //$NON-NLS-1$\n    private static final String PATH_ELEMENT_NAME = \"Path\"; //$NON-NLS-1$\n    /*\n     * The import options associated with this selection set\n     */\n    private final ImportOptions importOptions;\n    /**\n     * Creates a SelectionSet using the given ImportOptions.\n     *\n     * @param importOptions\n     *        the ImportOptions to use.\n     */\n    public ImportFolderCollection(final ImportOptions importOptions) {\n        super();\n        this.importOptions = importOptions;\n    }\n    public ImportFolderCollection(final ImportOptions importOptions, final List<TypedServerItem> items) {\n        this(importOptions);\n        setItems(items);\n    }\n    @Override\n    protected ImportFolderValidation validate(final ImportItemBase selectedPath) {\n        final ImportFolderValidation validation = super.validate(selectedPath);\n        if (validation.getStatus() != ImportFolderValidationStatus.OK) {\n            return validation;\n        } else {\n            return importOptions.getFolderValidator().validate(selectedPath.getFullPath());\n        }\n    }\n    @Override\n    protected ImportItemBase getImportItem(final String folderPath) {\n        // Determine if the specified server folder path has a mapping and how\n        // it is mapped. Possibilities are:\n        //\n        // 1) mapped by a ancestor with RecursiveType.FULL\n        // 2) mapped by a parent with RecursiveType.ONE\n        // 3) mapped by itself at RecursiveType.FULL or RecursiveType.ONE\n        // 4) not mapped\n        //\n        // We want to create a new default mapping for this folder in cases 2\n        // and 4 above. For case number 2, translateServerPathToLocalPath will\n        // return RecursiveType.NONE to indicate the path is mapped by a\n        // RecursiveType.ONE parent.\n        final PathTranslation translation = importOptions.getTFSWorkspace().translateServerPathToLocalPath(folderPath);\n        ImportFolder selectedPath;\n        // Test for cases 2 and 4 above.\n        if (translation == null || translation.getRecursionType() == RecursionType.NONE) {\n            // A new mapping will be created for this folder path.\n            selectedPath = new ImportFolder(folderPath);\n        } else {\n            // A new mapping will not be created for this folder path.\n            selectedPath = new ImportFolder(folderPath, translation.getTranslatedPath());\n        }\n        return selectedPath;\n    }\n    @Override\n    protected ImportItemBase getImportItem(final TypedServerItem item) {\n        return getImportItem(item.getServerPath());\n    }\n    /**\n     *\n     * WARNING: the return value is non-localized and should be used for logging\n     * or debugging purposes only, never displayed directly in the UI.\n     *\n     * @return some text describing the import plan for this SelectionSet\n     *         (non-localized)\n     */\n    public String getImportPlan() {\n        final ImportTask[] tasks = makeImportTasks();\n        final StringBuffer sb = new StringBuffer();\n        sb.append(\"Import Plan for \" + tasks.length + \" import task\"); //$NON-NLS-1$ //$NON-NLS-2$\n        if (tasks.length != 1) {\n            sb.append(\"s\"); //$NON-NLS-1$\n        }\n        sb.append(NEWLINE).append(NEWLINE);\n        for (int i = 0; i < tasks.length; i++) {\n            sb.append(tasks[i].getImportPlan());\n            sb.append(NEWLINE);\n        }\n        return sb.toString();\n    }\n    /**\n     * Creates an array of ImportTasks that contains a task for each\n     * SelectedPath in this SelectionSet.\n     *\n     * @return an array of ImportTasks\n     */\n    public ImportTask[] makeImportTasks() {\n        final ImportTask[] importTasks = new ImportTask[size()];\n        int ix = 0;\n        /*\n         * TODO do we want some kind of sorting here so that the tasks get\n         * executed in a specific order?\n         */\n        for (final ImportItemBase item : getItems()) {\n            final ImportFolder selectedPath = (ImportFolder) item;\n            importTasks[ix++] = ImportTaskFactory.createImportTask(selectedPath, importOptions);\n        }\n        return importTasks;\n    }\n    /**\n     * Performs a single server query for .project files corresponding to the\n     * SelectedPaths in this SelectionSet. The data from the query is pushed\n     * into the SelectedPaths by calling the serProjectMetadataFileServerItem()\n     * method on SelectedPath.\n     */\n    public void queryForProjectMetadataFiles() {\n        /*\n         * clear out any old project metadata file references\n         */\n        for (final ImportItemBase item : getItems()) {\n            final ImportFolder selectedPath = (ImportFolder) item;\n            selectedPath.setProjectMetadataFileServerItem(null);\n            selectedPath.setProjectMetadataFileServerExtendedItem(null);\n        }\n        /* Do a query items (for DURL) */\n        final ItemSpec[] itemSpecs = new ItemSpec[size()];\n        int ix = 0;\n        for (final String folder : getFolders()) {\n            final String queryPath = folder + \"/\" + IProjectDescription.DESCRIPTION_FILE_NAME; //$NON-NLS-1$\n            itemSpecs[ix++] = new ItemSpec(queryPath, RecursionType.NONE);\n        }\n        final ItemSet[] itemResultSet = importOptions.getTFSWorkspace().getClient().getItems(\n            itemSpecs,\n            LatestVersionSpec.INSTANCE,\n            DeletedState.NON_DELETED,\n            ItemType.FILE,\n            true);\n        for (int i = 0; i < itemResultSet.length; i++) {\n            final Item[] queryResults = itemResultSet[i].getItems();\n            for (int j = 0; j < queryResults.length; j++) {\n                final String dotProjectFilePath = queryResults[j].getServerItem();\n                final ImportFolder selectedPath = (ImportFolder) get(ServerPath.getParent(dotProjectFilePath));\n                selectedPath.setProjectMetadataFileServerItem(queryResults[j]);\n            }\n        }\n        /* Do a query items extended (for local workspace information) */\n        final ExtendedItem[][] extendedItemResults =\n            importOptions.getTFSWorkspace().getExtendedItems(itemSpecs, DeletedState.NON_DELETED, ItemType.FILE);\n        for (int i = 0; i < extendedItemResults.length; i++) {\n            for (int j = 0; j < extendedItemResults[i].length; j++) {\n                final String dotProjectFilePath = extendedItemResults[i][j].getSourceServerItem() != null\n                    ? extendedItemResults[i][j].getSourceServerItem() : extendedItemResults[i][j].getTargetServerItem();\n                if (dotProjectFilePath == null) {\n                    continue;\n                }\n                final ImportFolder selectedPath = (ImportFolder) get(ServerPath.getParent(dotProjectFilePath));\n                if (selectedPath != null) {\n                    selectedPath.setProjectMetadataFileServerExtendedItem(extendedItemResults[i][j]);\n                }\n            }\n        }\n    }\n    private List<String> makeItemPathList() {\n        return Arrays.asList(getFolders());\n    }\n    /**\n     * Serializes this SelectionSet out to a file.\n     *\n     * @param file\n     *        the output file\n     */\n    public void toFile(final File file) {\n        final List<String> sortedPaths = makeItemPathList();\n        Collections.sort(sortedPaths, ServerPath.TOP_DOWN_COMPARATOR);\n        final Document document = DOMCreateUtils.newDocument(ROOT_ELEMENT_NAME);\n        final Element root = document.getDocumentElement();\n        final Element element = DOMUtils.appendChild(root, FOLDER_PATHS_ELEMENT_NAME);\n        for (final Iterator<String> it = sortedPaths.iterator(); it.hasNext();) {\n            final String path = it.next();\n            DOMUtils.appendChildWithText(element, PATH_ELEMENT_NAME, path);\n        }\n        DOMSerializeUtils.serializeToFile(document, file, DOMSerializeUtils.ENCODING_UTF8, DOMSerializeUtils.INDENT);\n    }\n    /**\n     * Deserializes a file, populating this SelectionSet. Any SelectedPaths\n     * already held in the set are first removed.\n     *\n     * @param file\n     *        input file\n     */\n    public void fromFile(final File file) {\n        final Document document = DOMCreateUtils.parseFile(file, DOMCreateUtils.ENCODING_UTF8);\n        clear();\n        final Node root = document.getFirstChild();\n        if (root.getNodeType() == Node.ELEMENT_NODE && ROOT_ELEMENT_NAME.equals(root.getNodeName())) {\n            NodeList list = ((Element) root).getElementsByTagName(FOLDER_PATHS_ELEMENT_NAME);\n            if (list.getLength() > 0) {\n                list = ((Element) list.item(0)).getElementsByTagName(PATH_ELEMENT_NAME);\n                final int count = list.getLength();<fim_middle>// class below has no smell\n"}