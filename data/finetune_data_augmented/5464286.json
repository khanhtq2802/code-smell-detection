{"text": "<fim_prefix>\n<fim_suffix>public class JmsConnectionConsumer implements ConnectionConsumer, JmsMessageDispatcher {\n    private static final Logger LOG = LoggerFactory.getLogger(JmsConnectionConsumer.class);\n    private static final long DEFAULT_DISPATCH_RETRY_DELAY = 1000;\n    private final JmsConnection connection;\n    private final JmsConsumerInfo consumerInfo;\n    private final ServerSessionPool sessionPool;\n    private final MessageQueue messageQueue;\n    private final Lock stateLock = new ReentrantLock();\n    private final Lock dispatchLock = new ReentrantLock();\n    private final ReadWriteLock deliveringLock = new ReentrantReadWriteLock(true);\n    private final AtomicBoolean closed = new AtomicBoolean(false);\n    private final AtomicReference<Throwable> failureCause = new AtomicReference<>();\n    private final ScheduledThreadPoolExecutor dispatcher;\n    public JmsConnectionConsumer(JmsConnection connection, JmsConsumerInfo consumerInfo, MessageQueue messageQueue, ServerSessionPool sessionPool) throws JMSException {\n        this.connection = connection;\n        this.consumerInfo = consumerInfo;\n        this.sessionPool = sessionPool;\n        this.messageQueue = messageQueue;\n        this.dispatcher = new ScheduledThreadPoolExecutor(1, new ThreadFactory() {\n            @Override\n            public Thread newThread(Runnable runner) {\n                Thread serial = new Thread(runner);\n                serial.setDaemon(true);\n                serial.setName(this.getClass().getSimpleName() + \":(\" + consumerInfo.getId() + \")\");\n                return serial;\n            }\n        });\n        // Ensure a timely shutdown for consumer close.\n        dispatcher.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);\n        dispatcher.setContinueExistingPeriodicTasksAfterShutdownPolicy(false);\n        connection.createResource(consumerInfo, new ProviderSynchronization() {\n            @Override\n            public void onPendingSuccess() {\n                connection.addConnectionConsumer(consumerInfo, JmsConnectionConsumer.this);\n            }\n            @Override\n            public void onPendingFailure(Throwable cause) {\n            }\n        });\n    }\n    public JmsConnectionConsumer init() throws JMSException {\n        getConnection().startResource(consumerInfo);\n        return this;\n    }\n    @Override\n    public void onInboundMessage(JmsInboundMessageDispatch envelope) {\n        envelope.setConsumerInfo(consumerInfo);\n        stateLock.lock();\n        try {\n            if (envelope.isEnqueueFirst()) {\n                this.messageQueue.enqueueFirst(envelope);\n            } else {\n                this.messageQueue.enqueue(envelope);\n            }\n            if (messageQueue.isRunning()) {\n                try {\n                    dispatcher.execute(() -> deliverNextPending());\n                } catch (RejectedExecutionException rje) {\n                    LOG.debug(\"Rejected on attempt to queue message dispatch\", rje);\n                }\n            }\n        } finally {\n            stateLock.unlock();\n        }\n    }\n    @Override\n    public void close() throws JMSException {\n        if (!closed.get()) {\n            doClose();\n        }\n    }\n    /**\n     * Called to initiate shutdown of consumer resources and request that the remote\n     * peer remove the registered producer.\n     *\n     * @throws JMSException if an error occurs during the consumer close operation.\n     */\n    protected void doClose() throws JMSException {\n        deliveringLock.writeLock().lock();\n        try {\n            shutdown();\n            this.connection.destroyResource(consumerInfo);\n        } finally {\n            deliveringLock.writeLock().unlock();\n        }\n    }\n    protected void shutdown() throws JMSException {\n        shutdown(null);\n    }\n    protected void shutdown(Throwable cause) throws JMSException {\n        if (closed.compareAndSet(false, true)) {\n            dispatchLock.lock();\n            try {\n                failureCause.set(cause);\n                consumerInfo.setState(ResourceState.CLOSED);\n                connection.removeConnectionConsumer(consumerInfo);\n                stop(true);\n                dispatcher.shutdown();\n                try {\n                    dispatcher.awaitTermination(connection.getCloseTimeout(), TimeUnit.MILLISECONDS);\n                } catch (InterruptedException e) {\n                    LOG.trace(\"ConnectionConsumer shutdown of dispatcher was interupted\");\n                }\n            } finally {\n                dispatchLock.unlock();\n            }\n        }\n    }\n    public void start() {\n        stateLock.lock();\n        try {\n            if (!messageQueue.isRunning()) {\n                this.messageQueue.start();\n                this.dispatcher.execute(new BoundedMessageDeliverTask(messageQueue.size()));\n            }\n        } finally {\n            stateLock.unlock();\n        }\n    }\n    public void stop() {\n        stop(false);\n    }\n    private void stop(boolean closeMessageQueue) {\n        dispatchLock.lock();\n        stateLock.lock();\n        try {\n            if (closeMessageQueue) {\n                this.messageQueue.close();\n            } else {\n                this.messageQueue.stop();\n            }\n        } finally {\n            stateLock.unlock();\n            dispatchLock.unlock();\n        }\n    }\n    @Override\n    public ServerSessionPool getServerSessionPool() throws JMSException {\n        checkClosed();\n        return sessionPool;\n    }\n    JmsConnection getConnection() {\n        return connection;\n    }\n    JmsConsumerInfo getConsumerInfo() {\n        return consumerInfo;\n    }\n    void setFailureCause(Throwable failureCause) {\n        this.failureCause.set(failureCause);\n    }\n    Throwable getFailureCause() {\n        return failureCause.get();\n    }\n    @Override\n    public String toString() {\n        return \"JmsConnectionConsumer { id=\" + consumerInfo.getId() + \" }\";\n    }\n    protected void checkClosed() throws IllegalStateException {\n        if (closed.get()) {\n            IllegalStateException jmsEx = null;\n            if (getFailureCause() == null) {\n                jmsEx = new IllegalStateException(\"The ConnectionConsumer is closed\");\n            } else {\n                jmsEx = new IllegalStateException(\"The ConnectionConsumer was closed due to an unrecoverable error.\");\n                jmsEx.initCause(getFailureCause());\n            }\n            throw jmsEx;\n        }\n    }\n    private boolean deliverNextPending() {\n        if (messageQueue.isRunning() && !messageQueue.isEmpty()) {\n            dispatchLock.lock();\n            try {\n                ServerSession serverSession = getServerSessionPool().getServerSession();\n                if (serverSession == null) {\n                    // There might not be an available session so queue a task to try again\n                    // and hope that by then one is available in the pool.\n                    dispatcher.schedule(new BoundedMessageDeliverTask(messageQueue.size()), DEFAULT_DISPATCH_RETRY_DELAY, TimeUnit.MILLISECONDS);\n                    return false;\n                }\n                Session session = serverSession.getSession();\n                JmsInboundMessageDispatch envelope = messageQueue.dequeueNoWait();\n                if (session instanceof JmsSession) {\n                    ((JmsSession) session).enqueueInSession(new DeliveryTask(envelope));\n                } else {\n                    LOG.warn(\"ServerSession provided an unknown JMS Session type to this ConnectionConsumer: {}\", session);\n                }\n                serverSession.start();\n            } catch (JMSException e) {\n                connection.onAsyncException(e);\n                stop(true);\n            } finally {\n                dispatchLock.unlock();\n            }\n        }\n        return !messageQueue.isEmpty();\n    }\n    private final class BoundedMessageDeliverTask implements Runnable {\n        private final int deliveryCount;\n        public BoundedMessageDeliverTask(int deliveryCount) {\n            this.deliveryCount = deliveryCount;\n        }\n        @Override\n        public void run() {\n            int current = 0;\n            while (messageQueue.isRunning() && current++ < deliveryCount) {\n                if (!deliverNextPending()) {\n                    return;  // Another task already drained the queue.\n                }\n            }\n        }\n    }\n    private final class DeliveryTask implements Consumer<JmsSession> {\n        private final JmsInboundMessageDispatch envelope;\n        public DeliveryTask(JmsInboundMessageDispatch envelope) {\n            this.envelope = envelope;\n        }\n        @Override\n        public void accept(JmsSession session) {\n            deliveringLock.readLock().lock();\n            try {\n                if (closed.get()) {\n                    return;  // Message has been released.\n                }\n                JmsMessage copy = null;\n                if (envelope.getMessage().isExpired()) {\n                    LOG.trace(\"{} filtered expired message: {}\", envelope.getConsumerId(), envelope);\n                    session.acknowledge(envelope, ACK_TYPE.MODIFIED_FAILED_UNDELIVERABLE);\n                } else if (session.redeliveryExceeded(envelope)) {\n                    LOG.trace(\"{} filtered message with excessive redelivery count: {}\", envelope.getConsumerId(), envelope);\n                    JmsRedeliveryPolicy redeliveryPolicy = envelope.getConsumerInfo().getRedeliveryPolicy();\n                    session.acknowledge(envelope, lookupAckTypeForDisposition(redeliveryPolicy.getOutcome(envelope.getConsumerInfo().getDestination())));\n                } else {\n                    boolean deliveryFailed = false;\n                    copy = session.acknowledge(envelope, ACK_TYPE.DELIVERED).getMessage().copy();\n                    session.clearSessionRecovered();\n                    try {\n                        session.getMessageListener().onMessage(copy);\n                    } catch (RuntimeException rte) {\n                        deliveryFailed = true;\n                    }\n                    if (!session.isSessionRecovered()) {\n                        if (!deliveryFailed) {\n                            session.acknowledge(envelope, ACK_TYPE.ACCEPTED);\n                        } else {\n                            session.acknowledge(envelope, ACK_TYPE.RELEASED);\n                        }\n                    }\n                }<fim_middle>// class below has no smell\n"}