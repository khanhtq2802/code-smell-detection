{"text": "<fim_prefix> * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.ignite.internal.processors.cache.distributed.dht.atomic;\nimport java.io.Externalizable;\nimport java.nio.ByteBuffer;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.UUID;\nimport javax.cache.processor.EntryProcessor;\nimport org.apache.ignite.IgniteCheckedException;\nimport org.apache.ignite.cache.CacheWriteSynchronizationMode;\nimport org.apache.ignite.internal.processors.affinity.AffinityTopologyVersion;\nimport org.apache.ignite.internal.processors.cache.CacheObject;\nimport org.apache.ignite.internal.processors.cache.GridCacheContext;\nimport org.apache.ignite.internal.processors.cache.GridCacheOperation;\nimport org.apache.ignite.internal.processors.cache.GridCacheSharedContext;\nimport org.apache.ignite.internal.processors.cache.KeyCacheObject;\nimport org.apache.ignite.internal.processors.cache.version.GridCacheVersion;\nimport org.apache.ignite.internal.util.tostring.GridToStringInclude;\nimport org.apache.ignite.internal.util.typedef.internal.CU;\nimport org.apache.ignite.internal.util.typedef.internal.S;\nimport org.apache.ignite.plugin.extensions.communication.MessageReader;\nimport org.apache.ignite.plugin.extensions.communication.MessageWriter;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\nimport static org.apache.ignite.internal.processors.cache.GridCacheOperation.DELETE;\nimport static org.apache.ignite.internal.processors.cache.GridCacheOperation.TRANSFORM;\n/**\n *\n */\n<fim_suffix>public class GridNearAtomicSingleUpdateRequest extends GridNearAtomicAbstractSingleUpdateRequest {\n    /** */\n    private static final long serialVersionUID = 0L;\n    /** Key to update. */\n    @GridToStringInclude\n    protected KeyCacheObject key;\n    /** Value to update. */\n    protected CacheObject val;\n    /**\n     * Empty constructor required by {@link Externalizable}.\n     */\n    public GridNearAtomicSingleUpdateRequest() {\n        // No-op.\n    }\n    /**\n     * Constructor.\n     *\n     * @param cacheId Cache ID.\n     * @param nodeId Node ID.\n     * @param futId Future ID.\n     * @param topVer Topology version.\n     * @param syncMode Synchronization mode.\n     * @param op Cache update operation.\n     * @param subjId Subject ID.\n     * @param taskNameHash Task name hash code.\n     * @param flags Flags.\n     * @param addDepInfo Deployment info flag.\n     */\n    GridNearAtomicSingleUpdateRequest(\n        int cacheId,\n        UUID nodeId,\n        long futId,\n        @NotNull AffinityTopologyVersion topVer,\n        CacheWriteSynchronizationMode syncMode,\n        GridCacheOperation op,\n        @Nullable UUID subjId,\n        int taskNameHash,\n        byte flags,\n        boolean addDepInfo\n    ) {\n        super(cacheId,\n            nodeId,\n            futId,\n            topVer,\n            syncMode,\n            op,\n            subjId,\n            taskNameHash,\n            flags,\n            addDepInfo\n        );\n    }\n    /** {@inheritDoc} */\n    @Override public int partition() {\n        assert key != null;\n        return key.partition();\n    }\n    /**\n     * @param key Key to add.\n     * @param val Optional update value.\n     * @param conflictTtl Conflict TTL (optional).\n     * @param conflictExpireTime Conflict expire time (optional).\n     * @param conflictVer Conflict version (optional).\n     */\n    @Override public void addUpdateEntry(KeyCacheObject key,\n        @Nullable Object val,\n        long conflictTtl,\n        long conflictExpireTime,\n        @Nullable GridCacheVersion conflictVer) {\n        assert op != TRANSFORM;\n        assert val != null || op == DELETE;\n        assert conflictTtl < 0 : conflictTtl;\n        assert conflictExpireTime < 0 : conflictExpireTime;\n        assert conflictVer == null : conflictVer;\n        this.key = key;\n        if (val != null) {\n            assert val instanceof CacheObject : val;\n            this.val = (CacheObject)val;\n        }\n    }\n    /** {@inheritDoc} */\n    @Override public int size() {\n        assert key != null;\n        return key == null ? 0 : 1;\n    }\n    /** {@inheritDoc} */\n    @Override public List<KeyCacheObject> keys() {\n        return Collections.singletonList(key);\n    }\n    /** {@inheritDoc} */\n    @Override public KeyCacheObject key(int idx) {\n        assert idx == 0 : idx;\n        return key;\n    }\n    /** {@inheritDoc} */\n    @Override public List<?> values() {\n        return Collections.singletonList(val);\n    }\n    /** {@inheritDoc} */\n    @Override public CacheObject value(int idx) {\n        assert idx == 0 : idx;\n        return val;\n    }\n    /** {@inheritDoc} */\n    @Override public EntryProcessor<Object, Object, Object> entryProcessor(int idx) {\n        assert idx == 0 : idx;\n        return null;\n    }\n    /** {@inheritDoc} */\n    @Override public CacheObject writeValue(int idx) {\n        assert idx == 0 : idx;\n        return val;\n    }\n    /** {@inheritDoc} */\n    @Nullable @Override public List<GridCacheVersion> conflictVersions() {\n        return null;\n    }\n    /** {@inheritDoc} */\n    @Nullable @Override public GridCacheVersion conflictVersion(int idx) {\n        assert idx == 0 : idx;\n        return null;\n    }\n    /** {@inheritDoc} */\n    @Override public long conflictTtl(int idx) {\n        assert idx == 0 : idx;\n        return CU.TTL_NOT_CHANGED;\n    }\n    /** {@inheritDoc} */\n    @Override public long conflictExpireTime(int idx) {\n        assert idx == 0 : idx;\n        return CU.EXPIRE_TIME_CALCULATE;\n    }\n    /** {@inheritDoc} */\n    @Override public void prepareMarshal(GridCacheSharedContext ctx) throws IgniteCheckedException {\n        super.prepareMarshal(ctx);\n        GridCacheContext cctx = ctx.cacheContext(cacheId);\n        prepareMarshalCacheObject(key, cctx);\n        if (val != null)\n            prepareMarshalCacheObject(val, cctx);\n    }\n    /** {@inheritDoc} */\n    @Override public void finishUnmarshal(GridCacheSharedContext ctx, ClassLoader ldr) throws IgniteCheckedException {\n        super.finishUnmarshal(ctx, ldr);\n        GridCacheContext cctx = ctx.cacheContext(cacheId);\n        key.finishUnmarshal(cctx.cacheObjectContext(), ldr);\n        if (val != null)\n            val.finishUnmarshal(cctx.cacheObjectContext(), ldr);\n    }\n    /** {@inheritDoc} */\n    @Override public boolean writeTo(ByteBuffer buf, MessageWriter writer) {\n        writer.setBuffer(buf);\n        if (!super.writeTo(buf, writer))\n            return false;\n        if (!writer.isHeaderWritten()) {\n            if (!writer.writeHeader(directType(), fieldsCount()))\n                return false;\n            writer.onHeaderWritten();\n        }\n        switch (writer.state()) {\n            case 11:\n                if (!writer.writeMessage(\"key\", key))\n                    return false;\n                writer.incrementState();\n            case 12:\n                if (!writer.writeMessage(\"val\", val))\n                    return false;\n                writer.incrementState();\n        }\n        return true;\n    }\n    /** {@inheritDoc} */\n    @Override public boolean readFrom(ByteBuffer buf, MessageReader reader) {\n        reader.setBuffer(buf);\n        if (!reader.beforeMessageRead())\n            return false;\n        if (!super.readFrom(buf, reader))\n            return false;\n        switch (reader.state()) {\n            case 11:\n                key = reader.readMessage(\"key\");\n                if (!reader.isLastRead())\n                    return false;\n                reader.incrementState();\n            case 12:\n                val = reader.readMessage(\"val\");\n                if (!reader.isLastRead())\n                    return false;\n                reader.incrementState();\n        }\n        return reader.afterMessageRead(GridNearAtomicSingleUpdateRequest.class);\n    }\n    /** {@inheritDoc} */\n    @Override public void cleanup(boolean clearKey) {\n        val = null;\n        if (clearKey)\n            key = null;\n    }\n    /** {@inheritDoc} */\n    @Override public short directType() {\n        return 125;\n    }\n    /** {@inheritDoc} */\n    @Override public byte fieldsCount() {\n        return 13;\n    }\n    /** {@inheritDoc} */\n    @Override public String toString() {\n        return S.toString(GridNearAtomicSingleUpdateRequest.class, this, \"parent\", super.toString());\n    }\n}<fim_middle>// class below is blob\n"}