{"text": "<fim_prefix>/*\n * Copyright (C) 2015-2017 Uber Technologies, Inc. (streaming-data@uber.com)\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.uber.stream.kafka.mirrormaker.manager.core;\n\nimport com.codahale.metrics.Counter;\nimport com.uber.stream.kafka.mirrormaker.common.utils.HelixUtils;\nimport com.uber.stream.kafka.mirrormaker.manager.reporter.HelixKafkaMirrorMakerMetricsReporter;\nimport java.util.List;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\nimport org.apache.helix.HelixManager;\nimport org.apache.helix.LiveInstanceChangeListener;\nimport org.apache.helix.NotificationContext;\nimport org.apache.helix.model.LiveInstance;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * We only considering add or remove box(es), not considering the replacing.\n * For replacing, we just need to bring up a new box and give the old instanceId no auto-balancing needed.\n */\n<fim_suffix>public class ControllerLiveInstanceChangeListener implements LiveInstanceChangeListener {\n\n  private static final Logger LOGGER = LoggerFactory.getLogger(ControllerLiveInstanceChangeListener.class);\n\n  private final ControllerHelixManager _controllerHelixManager;\n  private final HelixManager _helixManager;\n\n  private final int minIntervalInSeconds = 60;\n  private long _lastRebalanceTimeMillis = 0;\n\n  private final ScheduledExecutorService _delayedScheduler = Executors.newSingleThreadScheduledExecutor();\n\n  private final Counter _isLeaderCounter = new Counter();\n\n  public ControllerLiveInstanceChangeListener(ControllerHelixManager controllerHelixManager,\n      HelixManager helixManager, int _workloadRefreshPeriodInSeconds) {\n    _controllerHelixManager = controllerHelixManager;\n    _helixManager = helixManager;\n    registerMetrics();\n\n    LOGGER.info(\"Trying to schedule auto rebalancing\");\n    _delayedScheduler.scheduleWithFixedDelay(\n        new Runnable() {\n          @Override\n          public void run() {\n            try {\n              rebalanceCurrentCluster(false);\n            } catch (Exception e) {\n              LOGGER.error(\"Got exception during periodically rebalancing the whole cluster! \", e);\n            }\n          }\n        }, 60, _workloadRefreshPeriodInSeconds, TimeUnit.SECONDS);\n  }\n\n  @Override\n  public void onLiveInstanceChange(final List<LiveInstance> liveInstances, NotificationContext changeContext) {\n    LOGGER.info(\"ControllerLiveInstanceChangeListener.onLiveInstanceChange() wakes up!\");\n    _delayedScheduler.schedule(new Runnable() {\n      @Override\n      public void run() {\n        try {\n          rebalanceCurrentCluster(true);\n        } catch (Exception e) {\n          LOGGER.error(\"Got exception during rebalance the whole cluster! \", e);\n        }\n      }\n    }, 5, TimeUnit.SECONDS);\n  }\n\n  public synchronized void rebalanceCurrentCluster(boolean onlyCheckOffline) {\n    if (_helixManager.isLeader()) {\n      _isLeaderCounter.inc(1 - _isLeaderCounter.getCount());\n    } else {\n      LOGGER.info(\"Not leader, do nothing!\");\n      return;\n    }\n\n    if (HelixUtils.liveInstances(_helixManager).isEmpty() ||\n        HelixUtils.liveInstances(_controllerHelixManager.getWorkerHelixManager().getHelixManager()).isEmpty()) {\n      LOGGER.info(\"No live instances, do nothing!\");\n      return;\n    }\n\n    LOGGER.info(\"onlyCheckOffline={}\", onlyCheckOffline);\n    try {\n      _controllerHelixManager.handleLiveInstanceChange(onlyCheckOffline, false);\n    } catch (Exception e) {\n      LOGGER.error(\"Failed to handle live instance change!\", e);\n    }\n\n  }\n\n  private void registerMetrics() {\n    try {\n      HelixKafkaMirrorMakerMetricsReporter.get().registerMetric(\"leader.counter\",\n          _isLeaderCounter);\n    } catch (Exception e) {\n      LOGGER.error(\"Error registering metrics!\", e);\n    }\n  }\n\n}<fim_middle>// class below has no smell\n"}