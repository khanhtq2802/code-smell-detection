{"text": "<fim_prefix>package com.epam.wilma.stubconfig.json.parser;\n/*==========================================================================\nCopyright since 2013, EPAM Systems\n\nThis file is part of Wilma.\n\nWilma is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nWilma is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Wilma.  If not, see <http://www.gnu.org/licenses/>.\n===========================================================================*/\n\nimport com.epam.wilma.domain.stubconfig.dialog.response.ResponseFormatter;\nimport com.epam.wilma.domain.stubconfig.dialog.response.ResponseFormatterDescriptor;\nimport com.epam.wilma.domain.stubconfig.exception.DescriptorCannotBeParsedException;\nimport com.epam.wilma.domain.stubconfig.exception.DescriptorValidationFailedException;\nimport com.epam.wilma.domain.stubconfig.parameter.ParameterList;\nimport com.epam.wilma.stubconfig.configuration.StubConfigurationAccess;\nimport com.epam.wilma.stubconfig.configuration.domain.PropertyDto;\nimport com.epam.wilma.stubconfig.initializer.template.ResponseFormatterInitializer;\nimport com.epam.wilma.stubconfig.json.parser.helper.ObjectParser;\nimport com.epam.wilma.stubconfig.json.parser.helper.ParameterListParser;\nimport org.json.JSONArray;\nimport org.json.JSONObject;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\nimport java.util.LinkedHashSet;\nimport java.util.Set;\n\n/**\n * Builds a set of {@link ResponseFormatter}s from a JSON object.\n *\n * @author Tamas_Kohegyi\n */\n<fim_suffix>@Component\npublic class ResponseFormatterDescriptorJsonParser implements ObjectParser<Set<ResponseFormatterDescriptor>> {\n\n    private static final String RESPONSE_FORMATTER_SET_INVOKER_TAG = \"responseFormatterSetInvoker\";\n    private static final String RESPONSE_FORMATTER_TAG = \"responseFormatter\";\n    private Integer maxDepthOfJsonTree;\n\n    @Autowired\n    private ResponseFormatterInitializer formatterInitializer;\n    @Autowired\n    private StubConfigurationAccess configurationAccess;\n    @Autowired\n    private ParameterListParser parameterListParser;\n\n    @Override\n    public Set<ResponseFormatterDescriptor> parseObject(final JSONObject responseDescriptorObject, final JSONObject root) {\n        //This number represents the depth of the subtree\n        int depth = 0;\n        return parse(responseDescriptorObject, root, depth);\n    }\n\n    private Set<ResponseFormatterDescriptor> parse(final JSONObject responseDescriptorObject, final JSONObject root, final int depth) {\n        Set<ResponseFormatterDescriptor> responseFormatterDescriptorSet = new LinkedHashSet<>();\n        if (responseDescriptorObject.has(\"responseFormatterSet\")) {\n            JSONArray responseFormatterSet = responseDescriptorObject.getJSONArray(\"responseFormatterSet\");\n            for (int i = 0; i < responseFormatterSet.length(); i++) {\n                JSONObject formatter = responseFormatterSet.getJSONObject(i);\n                if (formatter.has(RESPONSE_FORMATTER_TAG)) {\n                    //response formatter\n                    responseFormatterDescriptorSet.add(parseResponseFormatter(formatter.getJSONObject(RESPONSE_FORMATTER_TAG), root));\n                } else {\n                    if (formatter.has(RESPONSE_FORMATTER_SET_INVOKER_TAG)) {\n                        //response formatter set invoker\n                        String name = formatter.getString(RESPONSE_FORMATTER_SET_INVOKER_TAG);\n                        int newDepth = validateDepth(depth, name);\n                        responseFormatterDescriptorSet.addAll(parseResponseFormatterSetInvoker(name, root, newDepth));\n                    }\n                }\n            }\n        }\n        return responseFormatterDescriptorSet;\n    }\n\n    private Set<ResponseFormatterDescriptor> parseResponseFormatterSetInvoker(final String responseFormatterSetName, final JSONObject root, final int depth) {\n        //String expression = \"/wilma:wilma-stub/wilma:template-descriptor/wilma:template-formatter-set[@name='\" + templateFormatterSetName + \"']\";\n        //Element templateFormatterSet = xPathEvaluator.getElementByXPath(expression, document);\n        //return parse(templateFormatterSet, document, depth);\n        JSONObject formatterSet = null;\n        boolean found = false;\n        if (root.has(\"responseFormatterSets\")) {\n            JSONArray responseFormatterSetArray = root.getJSONArray(\"responseFormatterSets\");\n            for (int i = 0; responseFormatterSetArray.length() > i; i++) {\n                JSONObject responseFormatterSet = responseFormatterSetArray.getJSONObject(i);\n                String name = responseFormatterSet.getString(\"name\");\n                if (name.contentEquals(responseFormatterSetName)) {\n                    formatterSet = responseFormatterSet;\n                    found = true;\n                    break;\n                }\n            }\n        } else {\n            throw new DescriptorCannotBeParsedException(\"There is no Response Formatter Set defined.\");\n        }\n        if (!found) {\n            throw new DescriptorCannotBeParsedException(\"Cannot find Response Formatter Set with name: '\" + responseFormatterSetName + \"'.\");\n        }\n        return parse(formatterSet, root, depth);\n    }\n\n    private ResponseFormatterDescriptor parseResponseFormatter(final JSONObject responseFormatterObject, final JSONObject root) {\n        String clazz = responseFormatterObject.getString(\"class\");\n        ParameterList params = parameterListParser.parseObject(responseFormatterObject, root);\n        ResponseFormatter responseFormatter = formatterInitializer.getExternalClassObject(clazz);\n        return new ResponseFormatterDescriptor(responseFormatter, params);\n    }\n\n    private int validateDepth(final int depth, final String invokerName) {\n        int newDepth = depth + 1;\n        getMaxDepth();\n        if (newDepth >= maxDepthOfJsonTree) {\n            throw new DescriptorValidationFailedException(\n                    \"Validation of stub descriptor failed: Response-descriptor subtree is too deep or contains circles, error occurs at: responseFormatterSetInvoker = '\"\n                            + invokerName + \"'\");\n        }\n        return newDepth;\n    }\n\n    private void getMaxDepth() {\n        if (maxDepthOfJsonTree == null) {\n            PropertyDto properties = configurationAccess.getProperties();\n            maxDepthOfJsonTree = properties.getMaxDepthOfTree();\n        }\n    }\n}<fim_middle>// class below has no smell\n"}