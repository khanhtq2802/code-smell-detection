{"text": "<fim_prefix>                                ImageSingletonsSupportImpl.HostedManagement.installInThread(vmConfig);\n                                assert loader.getClassLoader().equals(getContextClassLoader());\n                            }\n                            @Override\n                            protected void onTermination(Throwable exception) {\n                                ImageSingletonsSupportImpl.HostedManagement.clearInThread();\n                                super.onTermination(exception);\n                            }\n                        },\n                        Thread.getDefaultUncaughtExceptionHandler(),\n                        false);\n    }\n<fim_suffix>    @SuppressWarnings(\"try\")\n    private void doRun(Map<Method, CEntryPointData> entryPoints, Method mainEntryPoint,\n                    JavaMainSupport javaMainSupport, String imageName, AbstractBootImage.NativeImageKind k,\n                    SubstitutionProcessor harnessSubstitutions,\n                    ForkJoinPool compilationExecutor, ForkJoinPool analysisExecutor) {\n        List<HostedMethod> hostedEntryPoints = new ArrayList<>();\n        OptionValues options = HostedOptionValues.singleton();\n        SnippetReflectionProvider originalSnippetReflection = GraalAccess.getOriginalSnippetReflection();\n        try (DebugContext debug = DebugContext.create(options, new GraalDebugHandlersFactory(originalSnippetReflection))) {\n            setupNativeImage(imageName, options, entryPoints, javaMainSupport, harnessSubstitutions, analysisExecutor, originalSnippetReflection, debug);\n            boolean returnAfterAnalysis = runPointsToAnalysis(imageName, options, debug);\n            if (returnAfterAnalysis) {\n                return;\n            }\n            NativeImageHeap heap;\n            HostedMethod mainEntryPointHostedStub;\n            HostedMetaAccess hMetaAccess;\n            SharedRuntimeConfigurationBuilder runtime;\n            try (StopTimer t = new Timer(imageName, \"universe\").start()) {\n                hUniverse = new HostedUniverse(bigbang);\n                hMetaAccess = new HostedMetaAccess(hUniverse, bigbang.getMetaAccess());\n                new UniverseBuilder(aUniverse, bigbang.getMetaAccess(), hUniverse, hMetaAccess, HostedConfiguration.instance().createStaticAnalysisResultsBuilder(bigbang, hUniverse),\n                                bigbang.getUnsupportedFeatures()).build(debug);\n                runtime = new HostedRuntimeConfigurationBuilder(options, bigbang.getHostVM(), hUniverse, hMetaAccess, bigbang.getProviders()).build();\n                registerGraphBuilderPlugins(featureHandler, runtime.getRuntimeConfig(), (HostedProviders) runtime.getRuntimeConfig().getProviders(), bigbang.getMetaAccess(), aUniverse,\n                                hMetaAccess, hUniverse,\n                                nativeLibraries, loader, false, true, bigbang.getAnnotationSubstitutionProcessor(), new SubstrateClassInitializationPlugin((SVMHost) aUniverse.hostVM()),\n                                bigbang.getHostVM().getClassInitializationSupport());\n                if (NativeImageOptions.PrintUniverse.getValue()) {\n                    printTypes();\n                }\n                /* Find the entry point methods in the hosted world. */\n                for (AnalysisMethod m : aUniverse.getMethods()) {\n                    if (m.isEntryPoint()) {\n                        HostedMethod found = hUniverse.lookup(m);\n                        assert found != null;\n                        hostedEntryPoints.add(found);\n                    }\n                }\n                /* Find main entry point */\n                if (mainEntryPoint != null) {\n                    AnalysisMethod analysisStub = CEntryPointCallStubSupport.singleton().getStubForMethod(mainEntryPoint);\n                    mainEntryPointHostedStub = (HostedMethod) hMetaAccess.getUniverse().lookup(analysisStub);\n                    assert hostedEntryPoints.contains(mainEntryPointHostedStub);\n                } else {\n                    mainEntryPointHostedStub = null;\n                }\n                if (hostedEntryPoints.size() == 0) {\n                    throw UserError.abort(\"Warning: no entry points found, i.e., no method annotated with @\" + CEntryPoint.class.getSimpleName());\n                }\n                heap = new NativeImageHeap(aUniverse, hUniverse, hMetaAccess);\n                BeforeCompilationAccessImpl config = new BeforeCompilationAccessImpl(featureHandler, loader, aUniverse, hUniverse, hMetaAccess, heap, debug);\n                featureHandler.forEachFeature(feature -> feature.beforeCompilation(config));\n                bigbang.getUnsupportedFeatures().report(bigbang);\n            } catch (UnsupportedFeatureException ufe) {\n                throw UserError.abort(ufe.getMessage());\n            }\n            recordMethodsWithStackValues();\n            recordRestrictHeapAccessCallees(aUniverse.getMethods());\n            /*\n             * After this point, all TypeFlow (and therefore also TypeState) objects are unreachable\n             * and can be garbage collected. This is important to keep the overall memory footprint\n             * low. However, this also means we no longer have complete call chain information. Only\n             * the summarized information stored in the StaticAnalysisResult objects is available\n             * after this point.\n             */\n            bigbang.cleanupAfterAnalysis();\n            NativeImageCodeCache codeCache;\n            CompileQueue compileQueue;\n            try (StopTimer t = new Timer(imageName, \"compile\").start()) {\n                compileQueue = HostedConfiguration.instance().createCompileQueue(debug, featureHandler, hUniverse, runtime, DeoptTester.enabled(), bigbang.getProviders().getSnippetReflection(),\n                                compilationExecutor);\n                compileQueue.finish(debug);\n                /* release memory taken by graphs for the image writing */\n                hUniverse.getMethods().forEach(HostedMethod::clear);\n                codeCache = NativeImageCodeCacheFactory.get().newCodeCache(compileQueue, heap);\n                codeCache.layoutConstants();\n                codeCache.layoutMethods(debug, imageName);\n                AfterCompilationAccessImpl config = new AfterCompilationAccessImpl(featureHandler, loader, aUniverse, hUniverse, hMetaAccess, heap, debug);\n                featureHandler.forEachFeature(feature -> feature.afterCompilation(config));\n            }\n            try (Indent indent = debug.logAndIndent(\"create native image\")) {\n                try (DebugContext.Scope buildScope = debug.scope(\"CreateBootImage\")) {\n                    try (StopTimer t = new Timer(imageName, \"image\").start()) {\n                        // Start building the model of the native image heap.\n                        heap.addInitialObjects();\n                        // Then build the model of the code cache, which can\n                        // add objects to the native image heap.\n                        codeCache.addConstantsToHeap();\n                        // Finish building the model of the native image heap.\n                        heap.addTrailingObjects();\n                        AfterHeapLayoutAccessImpl config = new AfterHeapLayoutAccessImpl(featureHandler, loader, hMetaAccess, debug);\n                        featureHandler.forEachFeature(feature -> feature.afterHeapLayout(config));\n                        this.image = AbstractBootImage.create(k, hUniverse, hMetaAccess, nativeLibraries, heap, codeCache, hostedEntryPoints, mainEntryPointHostedStub, loader.getClassLoader());\n                        image.build(debug);\n                        if (NativeImageOptions.PrintUniverse.getValue()) {\n                            /*\n                             * This debug output must be printed _after_ and not _during_ image\n                             * building, because it adds some PrintStream objects to static fields,\n                             * which disrupts the heap.\n                             */\n                            codeCache.printCompilationResults();\n                        }\n                    }\n                }\n            }\n            BeforeImageWriteAccessImpl beforeConfig = new BeforeImageWriteAccessImpl(featureHandler, loader, imageName, image,\n                            runtime.getRuntimeConfig(), aUniverse, hUniverse, optionProvider, hMetaAccess, debug);\n            featureHandler.forEachFeature(feature -> feature.beforeImageWrite(beforeConfig));\n            try (StopTimer t = new Timer(imageName, \"write\").start()) {\n                /*\n                 * This will write the debug info too -- i.e. we may be writing more than one file,\n                 * if the debug info is in a separate file. We need to push writing the file to the\n                 * image implementation, because whether the debug info and image share a file or\n                 * not is an implementation detail of the image.\n                 */\n                Path tmpDir = tempDirectory();\n                Path imagePath = image.write(debug, generatedFiles(HostedOptionValues.singleton()), tmpDir, imageName, beforeConfig).getOutputFile();\n                AfterImageWriteAccessImpl afterConfig = new AfterImageWriteAccessImpl(featureHandler, loader, hUniverse, imagePath, tmpDir, image.getBootImageKind(), debug);\n                featureHandler.forEachFeature(feature -> feature.afterImageWrite(afterConfig));\n            }\n        }\n    }<fim_middle>// function below is long method and feature envy\n"}