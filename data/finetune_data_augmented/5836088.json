{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.jasper.compiler;\n/**\n * Converts a JSP attribute value into the unquoted equivalent. The attribute\n * may contain EL expressions, in which case care needs to be taken to avoid any\n * ambiguities. For example, consider the attribute values \"${1+1}\" and\n * \"\\${1+1}\". After unquoting, both appear as \"${1+1}\" but the first should\n * evaluate to \"2\" and the second to \"${1+1}\". Literal \\, $ and # need special\n * treatment to ensure there is no ambiguity. The JSP attribute unquoting\n * covers \\\\, \\\", \\', \\$, \\#, %\\&gt;, &lt;\\%, &amp;apos; and &amp;quot;\n */\npublic class AttributeParser {\n    /**\n     * Parses the provided input String as a JSP attribute and returns an\n     * unquoted value.\n     *\n     * @param input         The input.\n     * @param quote         The quote character for the attribute or 0 for\n     *                      scripting expressions.\n     * @param isELIgnored   Is expression language being ignored on the page\n     *                      where the JSP attribute is defined.\n     * @param isDeferredSyntaxAllowedAsLiteral\n     *                      Are deferred expressions treated as literals?\n     * @param strict        Should the rules of JSP.1.6 for escaping of quotes\n     *                      be strictly applied?\n     * @param quoteAttributeEL Should the rules of JSP.1.6 for escaping in\n     *                      attributes be applied to EL in attribute values?\n     * @return              An unquoted JSP attribute that, if it contains\n     *                      expression language can be safely passed to the EL\n     *                      processor without fear of ambiguity.\n     */\n    public static String getUnquoted(String input, char quote,\n            boolean isELIgnored, boolean isDeferredSyntaxAllowedAsLiteral,\n            boolean strict, boolean quoteAttributeEL) {\n        return new AttributeParser(input, quote, isELIgnored,\n                isDeferredSyntaxAllowedAsLiteral, strict, quoteAttributeEL).getUnquoted();\n    }\n    /* The quoted input string. */\n    private final String input;\n    /* The quote used for the attribute - null for scripting expressions. */\n    private final char quote;\n    /* Is expression language being ignored - affects unquoting. \\$ and \\# are\n     * treated as literals rather than quoted values. */\n    private final boolean isELIgnored;\n    /* Are deferred expression treated as literals */\n    private final boolean isDeferredSyntaxAllowedAsLiteral;\n    /* If a quote appears that matches quote, must it always be escaped? See\n     * JSP.1.6.\n     */\n    private final boolean strict;\n    private final boolean quoteAttributeEL;\n    /* The type ($ or #) of expression. Literals have a type of null. */\n    private final char type;\n    /* The length of the quoted input string. */\n    private final int size;\n    /* Tracks the current position of the parser in the input String. */\n    private int i = 0;\n    /* Indicates if the last character returned by nextChar() was escaped. */\n    private boolean lastChEscaped = false;\n    /* The unquoted result. */\n    private final StringBuilder result;\n    /**\n     * For test purposes.\n     * @param input\n     * @param quote\n     * @param strict\n     */\n    private AttributeParser(String input, char quote,\n            boolean isELIgnored, boolean isDeferredSyntaxAllowedAsLiteral,\n            boolean strict, boolean quoteAttributeEL) {\n        this.input = input;\n        this.quote = quote;\n        this.isELIgnored = isELIgnored;\n        this.isDeferredSyntaxAllowedAsLiteral =\n            isDeferredSyntaxAllowedAsLiteral;\n        this.strict = strict;\n        this.quoteAttributeEL = quoteAttributeEL;\n        this.type = getType(input);\n        this.size = input.length();\n        result = new StringBuilder(size);\n    }\n    /*\n     * Work through input looking for literals and expressions until the input\n     * has all been read.\n     */\n<fim_suffix>    private String getUnquoted() {\n        while (i < size) {\n            parseLiteral();\n            parseEL();\n        }\n        return result.toString();\n    }\n    /*\n     * This method gets the next unquoted character and looks for\n     * - literals that need to be converted for EL processing\n     *   \\ -> type{'\\\\'}\n     *   $ -> type{'$'}\n     *   # -> type{'#'}\n     * - start of EL\n     *   ${\n     *   #{\n     * Note all the examples above *do not* include the escaping required to use\n     * the values in Java code.\n     */\n    private void parseLiteral() {\n        boolean foundEL = false;\n        while (i < size && !foundEL) {\n            char ch = nextChar();\n            if (!isELIgnored && ch == '\\\\') {\n                if (type == 0) {\n                    result.append(\"\\\\\");\n                } else {\n                    result.append(type);\n                    result.append(\"{'\\\\\\\\'}\");\n                }\n            } else if (!isELIgnored && ch == '$' && lastChEscaped){\n                if (type == 0) {\n                    result.append(\"\\\\$\");\n                } else {\n                    result.append(type);\n                    result.append(\"{'$'}\");\n                }\n            } else if (!isELIgnored && ch == '#' && lastChEscaped){\n                // Note if isDeferredSyntaxAllowedAsLiteral==true, \\# will\n                // not be treated as an escape\n                if (type == 0) {\n                    result.append(\"\\\\#\");\n                } else {\n                    result.append(type);\n                    result.append(\"{'#'}\");\n                }\n            } else if (ch == type){\n                if (i < size) {\n                    char next = input.charAt(i);\n                    if (next == '{') {\n                        foundEL = true;\n                        // Move back to start of EL\n                        i--;\n                    } else {\n                        result.append(ch);\n                    }\n                } else {\n                    result.append(ch);\n                }\n            } else {\n                result.append(ch);\n            }\n        }\n    }\n    /*\n     * Once inside EL, no need to unquote or convert anything. The EL is\n     * terminated by '}'. The only other valid location for '}' is inside a\n     * StringLiteral. The literals are delimited by '\\'' or '\\\"'. The only other\n     * valid location for '\\'' or '\\\"' is also inside a StringLiteral. A quote\n     * character inside a StringLiteral must be escaped if the same quote\n     * character is used to delimit the StringLiteral.\n     */\n    private void parseEL() {\n        boolean endEL = false;\n        boolean insideLiteral = false;\n        char literalQuote = 0;\n        while (i < size && !endEL) {\n            char ch;\n            if (quoteAttributeEL) {\n                ch = nextChar();\n            } else {\n                ch = input.charAt(i++);\n            }\n            if (ch == '\\'' || ch == '\\\"') {\n                if (insideLiteral) {\n                    if (literalQuote == ch) {\n                        insideLiteral = false;\n                    }\n                } else {\n                    insideLiteral = true;\n                    literalQuote = ch;\n                }\n                result.append(ch);\n            } else if (ch == '\\\\') {\n                result.append(ch);\n                if (insideLiteral && size < i) {\n                    if (quoteAttributeEL) {\n                        ch = nextChar();\n                    } else {\n                        ch = input.charAt(i++);\n                    }\n                    result.append(ch);\n                }\n            } else if (ch == '}') {\n                if (!insideLiteral) {\n                    endEL = true;\n                }\n                result.append(ch);\n            } else {\n                result.append(ch);\n            }\n        }\n    }\n    /*\n     * Returns the next unquoted character and sets the lastChEscaped flag to\n     * indicate if it was quoted/escaped or not.\n     * &apos; is always unquoted to '\n     * &quot; is always unquoted to \"\n     * \\\" is always unquoted to \"\n     * \\' is always unquoted to '\n     * \\\\ is always unquoted to \\\n     * \\$ is unquoted to $ if EL is not being ignored\n     * \\# is unquoted to # if EL is not being ignored\n     * <\\% is always unquoted to <%\n     * %\\> is always unquoted to %>\n     */\n    private char nextChar() {\n        lastChEscaped = false;\n        char ch = input.charAt(i);\n        if (ch == '&') {<fim_middle>// function below has no smell\n"}