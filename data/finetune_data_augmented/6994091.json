{"text": "<fim_prefix>/*\n * Copyright (C) 2006 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.common.util.concurrent;\n\nimport static com.google.common.util.concurrent.MoreExecutors.directExecutor;\n\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.base.Preconditions;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport org.checkerframework.checker.nullness.compatqual.NullableDecl;\n\n/**\n * Implementation of {@code Futures#withTimeout}.\n *\n * <p>Future that delegates to another but will finish early (via a {@link TimeoutException} wrapped\n * in an {@link ExecutionException}) if the specified duration expires. The delegate future is\n * interrupted and cancelled if it times out.\n */\n@GwtIncompatible\nfinal class TimeoutFuture<V> extends FluentFuture.TrustedFuture<V> {\n  static <V> ListenableFuture<V> create(\n      ListenableFuture<V> delegate,\n      long time,\n      TimeUnit unit,\n      ScheduledExecutorService scheduledExecutor) {\n    TimeoutFuture<V> result = new TimeoutFuture<>(delegate);\n    Fire<V> fire = new Fire<>(result);\n    result.timer = scheduledExecutor.schedule(fire, time, unit);\n    delegate.addListener(fire, directExecutor());\n    return result;\n  }\n\n  /*\n   * Memory visibility of these fields. There are two cases to consider.\n   *\n   * 1. visibility of the writes to these fields to Fire.run:\n   *\n   * The initial write to delegateRef is made definitely visible via the semantics of\n   * addListener/SES.schedule. The later racy write in cancel() is not guaranteed to be observed,\n   * however that is fine since the correctness is based on the atomic state in our base class. The\n   * initial write to timer is never definitely visible to Fire.run since it is assigned after\n   * SES.schedule is called. Therefore Fire.run has to check for null. However, it should be visible\n   * if Fire.run is called by delegate.addListener since addListener is called after the assignment\n   * to timer, and importantly this is the main situation in which we need to be able to see the\n   * write.\n   *\n   * 2. visibility of the writes to an afterDone() call triggered by cancel():\n   *\n   * Since these fields are non-final that means that TimeoutFuture is not being 'safely published',\n   * thus a motivated caller may be able to expose the reference to another thread that would then\n   * call cancel() and be unable to cancel the delegate.\n   * There are a number of ways to solve this, none of which are very pretty, and it is currently\n   * believed to be a purely theoretical problem (since the other actions should supply sufficient\n   * write-barriers).\n   */\n\n  @NullableDecl private ListenableFuture<V> delegateRef;\n  @NullableDecl private ScheduledFuture<?> timer;\n\n  private TimeoutFuture(ListenableFuture<V> delegate) {\n    this.delegateRef = Preconditions.checkNotNull(delegate);\n  }\n\n  /** A runnable that is called when the delegate or the timer completes. */\n  private static final class Fire<V> implements Runnable {\n    @NullableDecl TimeoutFuture<V> timeoutFutureRef;\n\n    Fire(TimeoutFuture<V> timeoutFuture) {\n      this.timeoutFutureRef = timeoutFuture;\n    }\n\n    @Override\n    public void run() {\n      // If either of these reads return null then we must be after a successful cancel or another\n      // call to this method.\n      TimeoutFuture<V> timeoutFuture = timeoutFutureRef;\n      if (timeoutFuture == null) {\n        return;\n      }\n      ListenableFuture<V> delegate = timeoutFuture.delegateRef;\n      if (delegate == null) {\n        return;\n      }\n\n      /*\n       * If we're about to complete the TimeoutFuture, we want to release our reference to it.\n       * Otherwise, we'll pin it (and its result) in memory until the timeout task is GCed. (The\n       * need to clear our reference to the TimeoutFuture is the reason we use a *static* nested\n       * class with a manual reference back to the \"containing\" class.)\n       *\n       * This has the nice-ish side effect of limiting reentrancy: run() calls\n       * timeoutFuture.setException() calls run(). That reentrancy would already be harmless, since\n       * timeoutFuture can be set (and delegate cancelled) only once. (And \"set only once\" is\n       * important for other reasons: run() can still be invoked concurrently in different threads,\n       * even with the above null checks.)\n       */\n      timeoutFutureRef = null;\n      if (delegate.isDone()) {\n        timeoutFuture.setFuture(delegate);\n      } else {\n        try {\n          ScheduledFuture<?> timer = timeoutFuture.timer;\n          String message = \"Timed out\";\n          if (timer != null) {\n            long overDelayMs = Math.abs(timer.getDelay(TimeUnit.MILLISECONDS));\n            if (overDelayMs > 10) { // Not all timing drift is worth reporting\n              message += \" (timeout delayed by \" + overDelayMs + \" ms after scheduled time)\";\n            }\n          }\n          timeoutFuture.timer = null; // Don't include already elapsed delay in delegate.toString()\n          timeoutFuture.setException(new TimeoutFutureException(message + \": \" + delegate));\n        } finally {\n          delegate.cancel(true);\n        }\n      }\n    }\n  }\n\n  private static final class TimeoutFutureException extends TimeoutException {\n    private TimeoutFutureException(String message) {\n      super(message);\n    }\n\n    @Override\n    public synchronized Throwable fillInStackTrace() {\n      setStackTrace(new StackTraceElement[0]);\n      return this; // no stack trace, wouldn't be useful anyway\n    }\n  }\n\n<fim_suffix>  @Override\n  protected String pendingToString() {\n    ListenableFuture<? extends V> localInputFuture = delegateRef;\n    ScheduledFuture<?> localTimer = timer;\n    if (localInputFuture != null) {\n      String message = \"inputFuture=[\" + localInputFuture + \"]\";\n      if (localTimer != null) {\n        final long delay = localTimer.getDelay(TimeUnit.MILLISECONDS);\n        // Negative delays look confusing in an error message\n        if (delay > 0) {\n          message += \", remaining delay=[\" + delay + \" ms]\";\n        }\n      }\n      return message;\n    }\n    return null;\n  }\n\n  @Override\n  protected void afterDone() {\n    maybePropagateCancellationTo(delegateRef);\n\n    Future<?> localTimer = timer;\n    // Try to cancel the timer as an optimization.\n    // timer may be null if this call to run was by the timer task since there is no happens-before\n    // edge between the assignment to timer and an execution of the timer task.\n    if (localTimer != null) {\n      localTimer.cancel(false);\n    }\n\n    delegateRef = null;\n    timer = null;\n  }\n}<fim_middle>// function below has no smell\n"}