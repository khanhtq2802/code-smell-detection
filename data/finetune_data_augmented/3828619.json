{"text": "<fim_prefix> *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.activemq.artemis.core.postoffice.impl;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.EnumSet;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport org.apache.activemq.artemis.api.core.SimpleString;\nimport org.apache.activemq.artemis.core.config.WildcardConfiguration;\nimport org.apache.activemq.artemis.core.persistence.StorageManager;\nimport org.apache.activemq.artemis.core.postoffice.Address;\nimport org.apache.activemq.artemis.core.postoffice.AddressManager;\nimport org.apache.activemq.artemis.core.postoffice.Binding;\nimport org.apache.activemq.artemis.core.postoffice.Bindings;\nimport org.apache.activemq.artemis.core.postoffice.BindingsFactory;\nimport org.apache.activemq.artemis.core.postoffice.QueueBinding;\nimport org.apache.activemq.artemis.core.server.ActiveMQMessageBundle;\nimport org.apache.activemq.artemis.api.core.RoutingType;\nimport org.apache.activemq.artemis.core.server.cluster.impl.MessageLoadBalancingType;\nimport org.apache.activemq.artemis.core.server.impl.AddressInfo;\nimport org.apache.activemq.artemis.core.transaction.Transaction;\nimport org.apache.activemq.artemis.utils.CompositeAddress;\nimport org.jboss.logging.Logger;\n/**\n * A simple address manager that maintains the addresses and bindings.\n */\npublic class SimpleAddressManager implements AddressManager {\n   private static final Logger logger = Logger.getLogger(SimpleAddressManager.class);\n   private final ConcurrentMap<SimpleString, AddressInfo> addressInfoMap = new ConcurrentHashMap<>();\n   private final StorageManager storageManager;\n   /**\n    * HashMap<Address, Binding>\n    */\n   protected final ConcurrentMap<SimpleString, Bindings> mappings = new ConcurrentHashMap<>();\n   /**\n    * HashMap<QueueName, Binding>\n    */\n   private final ConcurrentMap<SimpleString, Binding> nameMap = new ConcurrentHashMap<>();\n   private final BindingsFactory bindingsFactory;\n   protected final WildcardConfiguration wildcardConfiguration;\n   public SimpleAddressManager(final BindingsFactory bindingsFactory, final StorageManager storageManager) {\n      this(bindingsFactory, new WildcardConfiguration(), storageManager);\n   }\n   public SimpleAddressManager(final BindingsFactory bindingsFactory,\n                               final WildcardConfiguration wildcardConfiguration,\n                               final StorageManager storageManager) {\n      this.wildcardConfiguration = wildcardConfiguration;\n      this.bindingsFactory = bindingsFactory;\n      this.storageManager = storageManager;\n   }\n   @Override\n   public boolean addBinding(final Binding binding) throws Exception {\n      if (nameMap.putIfAbsent(binding.getUniqueName(), binding) != null) {\n         throw ActiveMQMessageBundle.BUNDLE.bindingAlreadyExists(binding);\n      }\n      if (logger.isTraceEnabled()) {\n         logger.trace(\"Adding binding \" + binding + \" with address = \" + binding.getUniqueName(), new Exception(\"trace\"));\n      }\n      return addMappingInternal(binding.getAddress(), binding);\n   }\n   @Override\n   public Binding removeBinding(final SimpleString uniqueName, Transaction tx) throws Exception {\n      final Binding binding = nameMap.remove(uniqueName);\n      if (binding == null) {\n         return null;\n      }\n      removeBindingInternal(binding.getAddress(), uniqueName);\n      return binding;\n   }\n   @Override\n   public Bindings getBindingsForRoutingAddress(final SimpleString address) throws Exception {\n      return mappings.get(CompositeAddress.extractAddressName(address));\n   }\n   @Override\n   public Binding getBinding(final SimpleString bindableName) {\n      return nameMap.get(CompositeAddress.extractQueueName(bindableName));\n   }\n   @Override\n   public Map<SimpleString, Binding> getBindings() {\n      return nameMap;\n   }\n   @Override\n   public Bindings getMatchingBindings(final SimpleString address) throws Exception {\n      SimpleString realAddress = CompositeAddress.extractAddressName(address);\n      Address add = new AddressImpl(realAddress, wildcardConfiguration);\n      Bindings bindings = bindingsFactory.createBindings(realAddress);\n      for (Binding binding : nameMap.values()) {\n         Address addCheck = new AddressImpl(binding.getAddress(), wildcardConfiguration);\n         if (addCheck.matches(add)) {\n            bindings.addBinding(binding);\n         }\n      }\n      return bindings;\n   }\n   @Override\n   public Bindings getDirectBindings(final SimpleString address) throws Exception {\n      SimpleString realAddress = CompositeAddress.extractAddressName(address);\n      Bindings bindings = bindingsFactory.createBindings(realAddress);\n      for (Binding binding : nameMap.values()) {\n         if (binding.getAddress().equals(realAddress)) {\n            bindings.addBinding(binding);\n         }\n      }\n      return bindings;\n   }\n   @Override\n   public SimpleString getMatchingQueue(final SimpleString address, RoutingType routingType) throws Exception {\n      SimpleString realAddress = CompositeAddress.extractAddressName(address);\n      Binding binding = getBinding(realAddress);\n      if (binding == null || !(binding instanceof LocalQueueBinding) || !binding.getAddress().equals(realAddress)) {\n         Bindings bindings = mappings.get(realAddress);\n         if (bindings != null) {\n            for (Binding theBinding : bindings.getBindings()) {\n               if (theBinding instanceof LocalQueueBinding) {\n                  binding = theBinding;\n                  break;\n               }\n            }\n         }\n      }\n      return binding != null ? binding.getUniqueName() : null;\n   }\n   @Override\n   public SimpleString getMatchingQueue(final SimpleString address,\n                                        final SimpleString queueName,\n                                        RoutingType routingType) throws Exception {\n      SimpleString realAddress = CompositeAddress.extractAddressName(address);\n      Binding binding = getBinding(queueName);\n      if (binding != null && !binding.getAddress().equals(realAddress) && !realAddress.toString().isEmpty()) {\n         throw new IllegalStateException(\"queue belongs to address\" + binding.getAddress());\n      }\n      return binding != null ? binding.getUniqueName() : null;\n   }\n   @Override\n   public void clear() {\n      nameMap.clear();\n      mappings.clear();\n   }\n   @Override\n   public Set<SimpleString> getAddresses() {\n      Set<SimpleString> addresses = new HashSet<>();\n      addresses.addAll(addressInfoMap.keySet());\n      return addresses;\n   }\n   protected void removeBindingInternal(final SimpleString address, final SimpleString bindableName) {\n      SimpleString realAddress = CompositeAddress.extractAddressName(address);\n      Bindings bindings = mappings.get(realAddress);\n      if (bindings != null) {\n         removeMapping(bindableName, bindings);\n         if (bindings.getBindings().isEmpty()) {\n            mappings.remove(realAddress);\n         }\n      }\n   }\n   protected Binding removeMapping(final SimpleString bindableName, final Bindings bindings) {\n      Binding theBinding = null;\n      for (Binding binding : bindings.getBindings()) {\n         if (binding.getUniqueName().equals(CompositeAddress.extractQueueName(bindableName))) {\n            theBinding = binding;\n            break;\n         }\n      }\n      if (theBinding == null) {\n         throw new IllegalStateException(\"Cannot find binding \" + bindableName);\n      }\n      bindings.removeBinding(theBinding);\n      return theBinding;\n   }\n   protected boolean addMappingInternal(final SimpleString address, final Binding binding) throws Exception {\n      SimpleString realAddress = CompositeAddress.extractAddressName(address);\n      Bindings bindings = mappings.get(realAddress);\n      Bindings prevBindings = null;\n      if (bindings == null) {\n         bindings = bindingsFactory.createBindings(realAddress);\n         prevBindings = mappings.putIfAbsent(realAddress, bindings);\n         if (prevBindings != null) {\n            bindings = prevBindings;\n         }\n      }\n      bindings.addBinding(binding);\n      return prevBindings != null;\n   }\n   @Override\n   public boolean reloadAddressInfo(AddressInfo addressInfo) throws Exception {\n      return addressInfoMap.putIfAbsent(addressInfo.getName(), addressInfo) == null;\n   }\n<fim_suffix>   @Override\n   public boolean addAddressInfo(AddressInfo addressInfo) throws Exception {\n      boolean added = reloadAddressInfo(addressInfo);\n      if (added && storageManager != null) {\n         long txID = storageManager.generateID();\n         try {\n            storageManager.addAddressBinding(txID, addressInfo);\n            storageManager.commitBindings(txID);\n         } catch (Exception e) {\n            try {\n               storageManager.rollbackBindings(txID);\n            } catch (Exception ignored) {\n            }\n            throw e;\n         }\n      }\n      return added;\n   }<fim_middle>// function below has no smell\n"}