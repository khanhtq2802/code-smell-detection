{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n * \n * http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.felix.inventory.impl.webconsole;\n\nimport java.io.IOException;\nimport java.net.URL;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.PropertyResourceBundle;\nimport java.util.ResourceBundle;\n\nimport org.osgi.framework.Bundle;\nimport org.osgi.framework.BundleContext;\nimport org.osgi.framework.BundleEvent;\nimport org.osgi.framework.BundleListener;\nimport org.osgi.framework.Constants;\n\n/**\n * The ResourceBundleManager manages resource bundle instance per OSGi Bundle.\n * It contains a local cache, for bundles, but when a bundle is being\n * unistalled,\n * its resources stored in the cache are cleaned up.\n */\npublic class ResourceBundleManager implements BundleListener\n{\n\n    private final BundleContext bundleContext;\n\n    private final Map resourceBundleCaches;\n\n    /**\n     * Creates a new object and adds self as a bundle listener\n     * \n     * @param bundleContext the bundle context of the Web Console.\n     */\n    public ResourceBundleManager(final BundleContext bundleContext)\n    {\n        this.bundleContext = bundleContext;\n        this.resourceBundleCaches = new HashMap();\n\n        bundleContext.addBundleListener(this);\n    }\n\n    /**\n     * Removes the bundle lister.\n     */\n    public void dispose()\n    {\n        bundleContext.removeBundleListener(this);\n    }\n\n    /**\n     * This method is used to retrieve a /cached/ instance of the i18n resource\n     * associated\n     * with a given bundle.\n     * \n     * @param provider the bundle, provider of the resources\n     * @param locale the requested locale.\n     */\n    public ResourceBundle getResourceBundle(final Bundle provider)\n    {\n        ResourceBundle cache;\n        final Long key = new Long(provider.getBundleId());\n        synchronized (resourceBundleCaches)\n        {\n            cache = (ResourceBundle) resourceBundleCaches.get(key);\n            if (cache == null && !resourceBundleCaches.containsKey(key))\n            {\n                cache = this.loadResourceBundle(provider);\n                resourceBundleCaches.put(key, cache);\n            }\n        }\n\n        return cache;\n    }\n\n    // ---------- BundleListener\n\n    /**\n     * @see org.osgi.framework.BundleListener#bundleChanged(org.osgi.framework.BundleEvent)\n     */\n    public final void bundleChanged(BundleEvent event)\n    {\n        if (event.getType() == BundleEvent.STOPPED)\n        {\n            final Long key = new Long(event.getBundle().getBundleId());\n            synchronized (resourceBundleCaches)\n            {\n                resourceBundleCaches.remove(key);\n            }\n        }\n    }\n\n    private static final Locale DEFAULT_LOCALE = Locale.ENGLISH;\n\n    private ResourceBundle loadResourceBundle(final Bundle bundle)\n    {\n        final String path = \"_\" + DEFAULT_LOCALE.toString(); //$NON-NLS-1$\n        final URL source = (URL) getResourceBundleEntries(bundle).get(path);\n        if (source != null)\n        {\n            try\n            {\n                return new PropertyResourceBundle(source.openStream());\n            }\n            catch (final IOException ignore)\n            {\n                // ignore\n            }\n        }\n        return null;\n    }\n\n    // TODO : Instead of getting all property files, we could just get the one\n    // for the default locale\n<fim_suffix>    private synchronized Map getResourceBundleEntries(final Bundle bundle)\n    {\n        String file = (String) bundle.getHeaders().get(Constants.BUNDLE_LOCALIZATION);\n        if (file == null)\n        {\n            file = Constants.BUNDLE_LOCALIZATION_DEFAULT_BASENAME;\n        }\n\n        // remove leading slash\n        if (file.startsWith(\"/\")) //$NON-NLS-1$\n        {\n            file = file.substring(1);\n        }\n\n        // split path and base name\n        int slash = file.lastIndexOf('/');\n        String fileName = file.substring(slash + 1);\n        String path = (slash <= 0) ? \"/\" : file.substring(0, slash); //$NON-NLS-1$\n\n        HashMap resourceBundleEntries = new HashMap();\n\n        Enumeration locales = bundle.findEntries(path, fileName + \"*.properties\", false); //$NON-NLS-1$\n        if (locales != null)\n        {\n            while (locales.hasMoreElements())\n            {\n                URL entry = (URL) locales.nextElement();\n\n                // calculate the key\n                String entryPath = entry.getPath();\n                final int start = entryPath.lastIndexOf('/') + 1 + fileName.length(); // path,\n                                                                                      // slash\n                                                                                      // and\n                                                                                      // base\n                                                                                      // name\n                final int end = entryPath.length() - 11; // .properties suffix\n                entryPath = entryPath.substring(start, end);\n\n                // the default language is \"name.properties\" thus the entry\n                // path is empty and must default to \"_\"+DEFAULT_LOCALE\n                if (entryPath.length() == 0)\n                {\n                    entryPath = \"_\" + DEFAULT_LOCALE; //$NON-NLS-1$\n                }\n\n                // only add this entry, if the \"language\" is not provided\n                // by the main bundle or an earlier bound fragment\n                if (!resourceBundleEntries.containsKey(entryPath))\n                {\n                    resourceBundleEntries.put(entryPath, entry);\n                }\n            }\n        }\n\n        return resourceBundleEntries;\n    }\n}<fim_middle>// function below is long method\n"}