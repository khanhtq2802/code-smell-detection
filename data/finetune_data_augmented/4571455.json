{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/* $Id$ */\npackage org.apache.fop.layoutmgr.table;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.apache.fop.datatypes.Length;\nimport org.apache.fop.datatypes.PercentBaseContext;\nimport org.apache.fop.fo.FONode;\nimport org.apache.fop.fo.expr.RelativeNumericProperty;\nimport org.apache.fop.fo.flow.table.Table;\nimport org.apache.fop.fo.flow.table.TableColumn;\nimport org.apache.fop.fo.properties.TableColLength;\nimport org.apache.fop.traits.Direction;\nimport org.apache.fop.traits.WritingModeTraits;\nimport org.apache.fop.traits.WritingModeTraitsGetter;\n/**\n * Class holding a number of columns making up the column setup of a row.\n */\npublic class ColumnSetup {\n    /** Logger **/\n    private static Log log = LogFactory.getLog(ColumnSetup.class);\n    private Table table;\n    private WritingModeTraitsGetter wmTraits;\n    private List columns = new java.util.ArrayList();\n    private List colWidths = new java.util.ArrayList();\n    private int maxColIndexReferenced;\n    /**\n     * Main Constructor.\n     * @param table the table to construct this column setup for\n     */\n    public ColumnSetup(Table table) {\n        assert table != null;\n        this.table = table;\n        this.wmTraits = WritingModeTraits.getWritingModeTraitsGetter(table);\n        prepareColumns();\n        initializeColumnWidths();\n    }\n    private void prepareColumns() {\n        List rawCols = table.getColumns();\n        if (rawCols != null) {\n            int colnum = 1;\n            for (Object rawCol : rawCols) {\n                TableColumn col = (TableColumn) rawCol;\n                if (col == null) {\n                    continue;\n                }\n                colnum = col.getColumnNumber();\n                for (int i = 0; i < col.getNumberColumnsRepeated(); i++) {\n                    while (colnum > columns.size()) {\n                        columns.add(null);\n                    }\n                    columns.set(colnum - 1, col);\n                    colnum++;\n                }\n            }\n            //Post-processing the list (looking for gaps)\n            //TODO The following block could possibly be removed\n            int pos = 1;\n            for (Object column : columns) {\n                TableColumn col = (TableColumn) column;\n                if (col == null) {\n                    assert false; //Gaps are filled earlier by fo.flow.table.Table.finalizeColumns()\n                    //log.error(\"Found a gap in the table-columns at position \" + pos);\n                }\n                pos++;\n            }\n        }\n    }\n    /**\n     * Returns a column. If the index of the column is bigger than the number of explicitly\n     * defined columns the last column is returned.\n     * @param index index of the column (1 is the first column)\n     * @return the requested column\n     */\n    public TableColumn getColumn(int index) {\n        int size = columns.size();\n        if (index > size) {\n            if (index > maxColIndexReferenced) {\n                maxColIndexReferenced = index;\n                TableColumn col = getColumn(1);\n                if (!(size == 1 && col.isImplicitColumn())) {\n                    assert false; //TODO Seems to be removable as this is now done in the FO tree\n                    log.warn(FONode.decorateWithContextInfo(\n                            \"There are fewer table-columns than are needed. \"\n                            + \"Column \" + index + \" was accessed, but only \"\n                            + size + \" columns have been defined. \"\n                            + \"The last defined column will be reused.\"\n                        , table));\n                    if (!table.isAutoLayout()) {\n                        log.warn(\"Please note that according XSL-FO 1.0 (7.26.9) says that \"\n                                + \"the 'column-width' property must be specified for every \"\n                                + \"column, unless the automatic table layout is used.\");\n                    }\n                }\n            }\n            return (TableColumn) columns.get(size - 1);\n        } else {\n            return (TableColumn) columns.get(index - 1);\n        }\n    }\n    /** {@inheritDoc} */\n    public String toString() {\n        return columns.toString();\n    }\n    /** @return the number of columns in the setup. */\n    public int getColumnCount() {\n        if (maxColIndexReferenced > columns.size()) {\n            return maxColIndexReferenced;\n        } else {\n            return columns.size();\n        }\n   }\n    /** @return an Iterator over all columns */\n    public Iterator iterator() {\n        return this.columns.iterator();\n    }\n    /*\n    private void createColumnsFromFirstRow() {\n        //TODO Create oldColumns from first row here\n        //--> rule 2 in \"fixed table layout\", see CSS2, 17.5.2\n        //Alternative: extend oldColumns on-the-fly, but in this case we need the\n        //new property evaluation context so proportional-column-width() works\n        //correctly.\n        if (columns.size() == 0) {\n            this.columns.add(table.getDefaultColumn());\n        }\n    }\n    */\n    /**\n     * Initializes the column's widths\n     *\n     */\n    private void initializeColumnWidths() {\n        TableColumn col;\n        Length colWidth;\n        for (int i = columns.size(); --i >= 0;) {\n            if (columns.get(i) != null) {\n                col = (TableColumn) columns.get(i);\n                colWidth = col.getColumnWidth();\n                colWidths.add(0, colWidth);\n            }\n        }\n        colWidths.add(0, null);\n    }\n    /**\n     * Works out the base unit for resolving proportional-column-width()\n     * [p-c-w(x) = x * base_unit_ipd]\n     *\n     * @param tlm   the TableLayoutManager\n     * @return the computed base unit (in millipoint)\n     */\n    protected double computeTableUnit(TableLayoutManager tlm) {\n        return computeTableUnit(tlm, tlm.getContentAreaIPD());\n    }\n    /**\n     * Works out the base unit for resolving proportional-column-width()\n     * [p-c-w(x) = x * base_unit_ipd]\n     *\n     * @param percentBaseContext the percent base context for relative values\n     * @param contentAreaIPD the IPD of the available content area\n     * @return the computed base unit (in millipoints)\n     */\n<fim_suffix>    public float computeTableUnit(PercentBaseContext percentBaseContext, int contentAreaIPD) {\n        int sumCols = 0;\n        float factors = 0;\n        float unit = 0;\n        /* calculate the total width (specified absolute/percentages),\n         * and work out the total number of factors to use to distribute\n         * the remaining space (if any)\n         */\n        for (Object colWidth1 : colWidths) {\n            Length colWidth = (Length) colWidth1;\n            if (colWidth != null) {\n                sumCols += colWidth.getValue(percentBaseContext);\n                if (colWidth instanceof RelativeNumericProperty) {\n                    factors += ((RelativeNumericProperty) colWidth).getTableUnits();\n                } else if (colWidth instanceof TableColLength) {\n                    factors += ((TableColLength) colWidth).getTableUnits();\n                }\n            }\n        }\n        /* distribute the remaining space over the accumulated\n         * factors (if any)\n         */\n        if (factors > 0) {\n            if (sumCols < contentAreaIPD) {\n                unit = (contentAreaIPD - sumCols) / factors;\n            } else {\n                log.warn(\"No space remaining to distribute over columns.\");\n            }\n        }\n        return unit;\n    }\n    /**\n     * Determine the X offset of the indicated column, where this\n     * offset denotes the left edge of the column irrespective of writing\n     * mode. If writing mode's column progression direction is right-to-left,\n     * then the first column is the right-most column and the last column is\n     * the left-most column; otherwise, the first column is the left-most\n     * column.\n     * @param col column index (1 is first column)<fim_middle>// function below is long method\n"}