{"text": "<fim_prefix>/*\n * Copyright (c) 1999, 2014, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage javax.swing;\nimport java.awt.*;\nimport sun.awt.ModalExclude;\nimport sun.awt.SunToolkit;\n/**\n * Popups are used to display a <code>Component</code> to the user, typically\n * on top of all the other <code>Component</code>s in a particular containment\n * hierarchy. <code>Popup</code>s have a very small life cycle. Once you\n * have obtained a <code>Popup</code>, and hidden it (invoked the\n * <code>hide</code> method), you should no longer\n * invoke any methods on it. This allows the <code>PopupFactory</code> to cache\n * <code>Popup</code>s for later use.\n * <p>\n * The general contract is that if you need to change the size of the\n * <code>Component</code>, or location of the <code>Popup</code>, you should\n * obtain a new <code>Popup</code>.\n * <p>\n * <code>Popup</code> does not descend from <code>Component</code>, rather\n * implementations of <code>Popup</code> are responsible for creating\n * and maintaining their own <code>Component</code>s to render the\n * requested <code>Component</code> to the user.\n * <p>\n * You typically do not explicitly create an instance of <code>Popup</code>,\n * instead obtain one from a <code>PopupFactory</code>.\n *\n * @see PopupFactory\n *\n * @since 1.4\n */\npublic class Popup {\n    /**\n     * The Component representing the Popup.\n     */\n    private Component component;\n    /**\n     * Creates a <code>Popup</code> for the Component <code>owner</code>\n     * containing the Component <code>contents</code>. <code>owner</code>\n     * is used to determine which <code>Window</code> the new\n     * <code>Popup</code> will parent the <code>Component</code> the\n     * <code>Popup</code> creates to.\n     * A null <code>owner</code> implies there is no valid parent.\n     * <code>x</code> and\n     * <code>y</code> specify the preferred initial location to place\n     * the <code>Popup</code> at. Based on screen size, or other paramaters,\n     * the <code>Popup</code> may not display at <code>x</code> and\n     * <code>y</code>.\n     *\n     * @param owner    Component mouse coordinates are relative to, may be null\n     * @param contents Contents of the Popup\n     * @param x        Initial x screen coordinate\n     * @param y        Initial y screen coordinate\n     * @exception IllegalArgumentException if contents is null\n     */\n    protected Popup(Component owner, Component contents, int x, int y) {\n        this();\n        if (contents == null) {\n            throw new IllegalArgumentException(\"Contents must be non-null\");\n        }\n        reset(owner, contents, x, y);\n    }\n    /**\n     * Creates a <code>Popup</code>. This is provided for subclasses.\n     */\n    protected Popup() {\n    }\n    /**\n     * Makes the <code>Popup</code> visible. If the <code>Popup</code> is\n     * currently visible, this has no effect.\n     */\n<fim_suffix>    @SuppressWarnings(\"deprecation\")\n    public void show() {\n        Component component = getComponent();\n        if (component != null) {\n            component.show();\n        }\n    }\n    /**\n     * Hides and disposes of the <code>Popup</code>. Once a <code>Popup</code>\n     * has been disposed you should no longer invoke methods on it. A\n     * <code>dispose</code>d <code>Popup</code> may be reclaimed and later used\n     * based on the <code>PopupFactory</code>. As such, if you invoke methods\n     * on a <code>disposed</code> <code>Popup</code>, indeterminate\n     * behavior will result.\n     */\n    @SuppressWarnings(\"deprecation\")\n    public void hide() {\n        Component component = getComponent();\n        if (component instanceof JWindow) {\n            component.hide();\n            ((JWindow)component).getContentPane().removeAll();\n        }\n        dispose();\n    }\n    /**\n     * Frees any resources the <code>Popup</code> may be holding onto.\n     */\n    void dispose() {\n        Component component = getComponent();\n        Window window = SwingUtilities.getWindowAncestor(component);\n        if (component instanceof JWindow) {\n            ((Window)component).dispose();\n            component = null;\n        }\n        // If our parent is a DefaultFrame, we need to dispose it, too.\n        if (window instanceof DefaultFrame) {\n            window.dispose();\n        }\n    }\n    /**\n     * Resets the <code>Popup</code> to an initial state.\n     */\n    void reset(Component owner, Component contents, int ownerX, int ownerY) {\n        if (getComponent() == null) {\n            component = createComponent(owner);\n        }\n        Component c = getComponent();\n        if (c instanceof JWindow) {\n            JWindow component = (JWindow)getComponent();\n            component.setLocation(ownerX, ownerY);\n            component.getContentPane().add(contents, BorderLayout.CENTER);\n            component.invalidate();\n            component.validate();\n            if(component.isVisible()) {\n                // Do not call pack() if window is not visible to\n                // avoid early native peer creation\n                pack();\n            }\n        }\n    }\n    /**\n     * Causes the <code>Popup</code> to be sized to fit the preferred size\n     * of the <code>Component</code> it contains.\n     */\n    void pack() {\n        Component component = getComponent();\n        if (component instanceof Window) {\n            ((Window)component).pack();\n        }\n    }\n    /**\n     * Returns the <code>Window</code> to use as the parent of the\n     * <code>Window</code> created for the <code>Popup</code>. This creates\n     * a new <code>DefaultFrame</code>, if necessary.\n     */\n    private Window getParentWindow(Component owner) {\n        Window window = null;\n        if (owner instanceof Window) {\n            window = (Window)owner;\n        }\n        else if (owner != null) {\n            window = SwingUtilities.getWindowAncestor(owner);\n        }\n        if (window == null) {\n            window = new DefaultFrame();\n        }\n        return window;\n    }\n    /**\n     * Creates the Component to use as the parent of the <code>Popup</code>.\n     * The default implementation creates a <code>Window</code>, subclasses\n     * should override.\n     */\n    Component createComponent(Component owner) {\n        if (GraphicsEnvironment.isHeadless()) {\n            // Generally not useful, bail.\n            return null;\n        }\n        return new HeavyWeightWindow(getParentWindow(owner));\n    }\n    /**\n     * Returns the <code>Component</code> returned from\n     * <code>createComponent</code> that will hold the <code>Popup</code>.\n     */\n    Component getComponent() {\n        return component;\n    }\n    /**\n     * Component used to house window.\n     */\n    @SuppressWarnings(\"serial\") // Superclass is not serializable across versions\n    static class HeavyWeightWindow extends JWindow implements ModalExclude {\n        HeavyWeightWindow(Window parent) {\n            super(parent);\n            setFocusableWindowState(false);\n            setType(Window.Type.POPUP);\n            // Popups are typically transient and most likely won't benefit\n            // from true double buffering.  Turn it off here.\n            getRootPane().setUseTrueDoubleBuffering(false);\n            // Try to set \"always-on-top\" for the popup window.\n            // Applets usually don't have sufficient permissions to do it.\n            // In this case simply ignore the exception.<fim_middle>// function below has no smell\n"}