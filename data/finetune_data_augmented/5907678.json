{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the  \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/*\n * $Id$\n */\npackage org.apache.xpath.compiler;\nimport org.apache.xalan.res.XSLMessages;\nimport org.apache.xml.utils.ObjectVector;\nimport org.apache.xpath.patterns.NodeTest;\nimport org.apache.xpath.res.XPATHErrorResources;\n/**\n * This class represents the data structure basics of the XPath\n * object.\n */\npublic class OpMap\n{\n  /**\n   * The current pattern string, for diagnostics purposes\n   */\n  protected String m_currentPattern;\n  /**\n   * Return the expression as a string for diagnostics.\n   *\n   * @return The expression string.\n   */\n  public String toString()\n  {\n    return m_currentPattern;\n  }\n  /**\n   * Return the expression as a string for diagnostics.\n   *\n   * @return The expression string.\n   */\n  public String getPatternString()\n  {\n    return m_currentPattern;\n  }\n  /**\n   * The starting size of the token queue.\n   */\n  static final int MAXTOKENQUEUESIZE = 500;\n  /*\n   * Amount to grow token queue when it becomes full\n   */\n  static final int BLOCKTOKENQUEUESIZE = 500;\n  /**\n   *  TokenStack is the queue of used tokens. The current token is the token at the\n   * end of the m_tokenQueue. The idea is that the queue can be marked and a sequence\n   * of tokens can be reused.\n   */\n  ObjectVector m_tokenQueue = new ObjectVector(MAXTOKENQUEUESIZE, BLOCKTOKENQUEUESIZE);\n  /**\n   * Get the XPath as a list of tokens.\n   *\n   * @return ObjectVector of tokens.\n   */\n  public ObjectVector getTokenQueue()\n  {\n    return m_tokenQueue;\n  }\n  /**\n   * Get the XPath as a list of tokens.\n   *\n   * @param pos index into token queue.\n   *\n   * @return The token, normally a string.\n   */\n  public Object getToken(int pos)\n  {\n    return m_tokenQueue.elementAt(pos);\n  }\n  /**\n   * The current size of the token queue.\n   */\n//  public int m_tokenQueueSize = 0;\n  /**\n    * Get size of the token queue.\n   *\n   * @return The size of the token queue.\n   */\n  public int getTokenQueueSize()\n  {\n    return m_tokenQueue.size();\n  }\n  /**\n   * An operations map is used instead of a proper parse tree.  It contains\n   * operations codes and indexes into the m_tokenQueue.\n   * I use an array instead of a full parse tree in order to cut down\n   * on the number of objects created.\n   */\n  OpMapVector m_opMap = null;\n  /**\n    * Get the opcode list that describes the XPath operations.  It contains\n   * operations codes and indexes into the m_tokenQueue.\n   * I use an array instead of a full parse tree in order to cut down\n   * on the number of objects created.\n   *\n   * @return An IntVector that is the opcode list that describes the XPath operations.\n   */\n  public OpMapVector getOpMap()\n  {\n    return m_opMap;\n  }\n  // Position indexes\n  /**\n   * The length is always the opcode position + 1.\n   * Length is always expressed as the opcode+length bytes,\n   * so it is always 2 or greater.\n   */\n  public static final int MAPINDEX_LENGTH = 1;\n  /**\n   * Replace the large arrays\n   * with a small array.\n   */\n  void shrink()\n  {\n    int n = m_opMap.elementAt(MAPINDEX_LENGTH);\n    m_opMap.setToSize(n + 4);\n    m_opMap.setElementAt(0,n);\n    m_opMap.setElementAt(0,n+1);\n    m_opMap.setElementAt(0,n+2);\n    n = m_tokenQueue.size();\n    m_tokenQueue.setToSize(n + 4);\n    m_tokenQueue.setElementAt(null,n);\n    m_tokenQueue.setElementAt(null,n + 1);\n    m_tokenQueue.setElementAt(null,n + 2);\n  }\n  /**\n  * Given an operation position, return the current op.\n   *\n   * @param opPos index into op map.\n   * @return the op that corresponds to the opPos argument.\n   */\n  public int getOp(int opPos)\n  {\n    return m_opMap.elementAt(opPos);\n  }\n  /**\n  * Set the op at index to the given int.\n   *\n   * @param opPos index into op map.\n   * @param value Value to set\n   */\n<fim_suffix>  public void setOp(int opPos, int value)\n  {\n     m_opMap.setElementAt(value,opPos);\n  }\n  /**\n   * Given an operation position, return the end position, i.e. the\n   * beginning of the next operation.\n   *\n   * @param opPos An op position of an operation for which there is a size \n   *              entry following.\n   * @return position of next operation in m_opMap.\n   */\n  public int getNextOpPos(int opPos)\n  {\n    return opPos + m_opMap.elementAt(opPos + 1);\n  }\n  /**\n   * Given a location step position, return the end position, i.e. the\n   * beginning of the next step.\n   *\n   * @param opPos the position of a location step.\n   * @return the position of the next location step.\n   */\n  public int getNextStepPos(int opPos)\n  {\n    int stepType = getOp(opPos);\n    if ((stepType >= OpCodes.AXES_START_TYPES)\n            && (stepType <= OpCodes.AXES_END_TYPES))\n    {\n      return getNextOpPos(opPos);\n    }\n    else if ((stepType >= OpCodes.FIRST_NODESET_OP)\n             && (stepType <= OpCodes.LAST_NODESET_OP))\n    {\n      int newOpPos = getNextOpPos(opPos);\n      while (OpCodes.OP_PREDICATE == getOp(newOpPos))\n      {\n        newOpPos = getNextOpPos(newOpPos);\n      }\n      stepType = getOp(newOpPos);\n      if (!((stepType >= OpCodes.AXES_START_TYPES)\n            && (stepType <= OpCodes.AXES_END_TYPES)))\n      {\n        return OpCodes.ENDOP;\n      }\n      return newOpPos;\n    }\n    else\n    {\n      throw new RuntimeException(\n        XSLMessages.createXPATHMessage(XPATHErrorResources.ER_UNKNOWN_STEP, new Object[]{String.valueOf(stepType)})); \n      //\"Programmer's assertion in getNextStepPos: unknown stepType: \" + stepType);\n    }\n  }\n  /**\n   * Given an operation position, return the end position, i.e. the\n   * beginning of the next operation.\n   *\n   * @param opMap The operations map.\n   * @param opPos index to operation, for which there is a size entry following.\n   * @return position of next operation in m_opMap.\n   */\n  public static int getNextOpPos(int[] opMap, int opPos)\n  {\n    return opPos + opMap[opPos + 1];\n  }\n  /**\n   * Given an FROM_stepType position, return the position of the\n   * first predicate, if there is one, or else this will point\n   * to the end of the FROM_stepType.\n   * Example:\n   *  int posOfPredicate = xpath.getNextOpPos(stepPos);\n   *  boolean hasPredicates =\n   *            OpCodes.OP_PREDICATE == xpath.getOp(posOfPredicate);\n   *\n   * @param opPos position of FROM_stepType op. \n   * @return position of predicate in FROM_stepType structure.\n   */\n  public int getFirstPredicateOpPos(int opPos)\n     throws javax.xml.transform.TransformerException\n  {\n    int stepType = m_opMap.elementAt(opPos);\n    if ((stepType >= OpCodes.AXES_START_TYPES)\n            && (stepType <= OpCodes.AXES_END_TYPES))\n    {\n      return opPos + m_opMap.elementAt(opPos + 2);\n    }\n    else if ((stepType >= OpCodes.FIRST_NODESET_OP)<fim_middle>// function below is feature envy\n"}