{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.heron.network;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport com.google.protobuf.ByteString;\nimport com.google.protobuf.InvalidProtocolBufferException;\nimport com.google.protobuf.Message;\nimport org.apache.heron.common.basics.Communicator;\nimport org.apache.heron.common.basics.NIOLooper;\nimport org.apache.heron.common.basics.SingletonRegistry;\nimport org.apache.heron.common.config.SystemConfig;\nimport org.apache.heron.common.network.HeronClient;\nimport org.apache.heron.common.network.HeronSocketOptions;\nimport org.apache.heron.common.network.StatusCode;\nimport org.apache.heron.common.utils.misc.PhysicalPlanHelper;\nimport org.apache.heron.instance.InstanceControlMsg;\nimport org.apache.heron.metrics.GatewayMetrics;\nimport org.apache.heron.proto.ckptmgr.CheckpointManager;\nimport org.apache.heron.proto.stmgr.StreamManager;\nimport org.apache.heron.proto.system.Common;\nimport org.apache.heron.proto.system.HeronTuples;\nimport org.apache.heron.proto.system.PhysicalPlans;\n/**\n * StreamClient implements SocketClient and communicate with Stream Manager, it will:\n * 1. Register the message of NewInstanceAssignmentMessage and HeronTupleSet2.\n * 2. Send Register Request when it is onConnect()\n * 3. Handle relative response for requests\n * 4. if onIncomingMessage(message) is called, it will see whether it is NewAssignment or NewTuples.\n * 5. If it is a new assignment, it will pass the PhysicalPlan to Slave,\n * which will new a corresponding instance.\n */\npublic class StreamManagerClient extends HeronClient {\n  private static final Logger LOG = Logger.getLogger(StreamManagerClient.class.getName());\n  private final String topologyName;\n  private final String topologyId;\n  private final PhysicalPlans.Instance instance;\n  // For spout, it will buffer Control tuple, while for bolt, it will buffer data tuple.\n  private final Communicator<Message> inStreamQueue;\n  private final Communicator<Message> outStreamQueue;\n  private final Communicator<InstanceControlMsg> inControlQueue;\n  private final GatewayMetrics gatewayMetrics;\n  private final SystemConfig systemConfig;\n  private PhysicalPlanHelper helper;\n  private long lastNotConnectedLogTime = 0;\n<fim_suffix>  public StreamManagerClient(NIOLooper s, String streamManagerHost, int streamManagerPort,\n                             String topologyName, String topologyId,\n                             PhysicalPlans.Instance instance,\n                             Communicator<Message> inStreamQueue,\n                             Communicator<Message> outStreamQueue,\n                             Communicator<InstanceControlMsg> inControlQueue,\n                             HeronSocketOptions options,\n                             GatewayMetrics gatewayMetrics) {\n    super(s, streamManagerHost, streamManagerPort, options);\n    this.topologyName = topologyName;\n    this.topologyId = topologyId;\n    this.instance = instance;\n    this.inStreamQueue = inStreamQueue;\n    this.outStreamQueue = outStreamQueue;\n    this.inControlQueue = inControlQueue;\n    this.systemConfig =\n        (SystemConfig) SingletonRegistry.INSTANCE.getSingleton(SystemConfig.HERON_SYSTEM_CONFIG);\n    this.gatewayMetrics = gatewayMetrics;\n    addStreamManagerClientTasksOnWakeUp();\n  }\n  private void addStreamManagerClientTasksOnWakeUp() {\n    Runnable task = new Runnable() {\n      @Override\n      public void run() {\n        sendStreamMessageIfNeeded();\n        readStreamMessageIfNeeded();\n      }\n    };\n    getNIOLooper().addTasksOnWakeup(task);\n  }\n  private void registerMessagesToHandle() {\n    registerOnMessage(StreamManager.NewInstanceAssignmentMessage.newBuilder());\n    registerOnMessage(HeronTuples.HeronTupleSet2.newBuilder());\n    // Register stateful processing related messages\n    registerOnMessage(CheckpointManager.InitiateStatefulCheckpoint.newBuilder());\n    registerOnMessage(CheckpointManager.RestoreInstanceStateRequest.newBuilder());\n    registerOnMessage(CheckpointManager.StartInstanceStatefulProcessing.newBuilder());\n  }\n  @Override\n  public void onError() {\n    LOG.severe(\"Disconnected from Stream Manager.\");\n    // We would set PhysicalPlanHelper to null onError(),\n    // since we would re-connect to stream manager and wait for new PhysicalPlan\n    // the stream manager publishes\n    LOG.info(\"Clean the old PhysicalPlanHelper in StreamManagerClient.\");\n    helper = null;\n    // Dispatch to onConnect(...)\n    onConnect(StatusCode.CONNECT_ERROR);\n  }\n  @Override\n  public void onConnect(StatusCode status) {\n    if (status != StatusCode.OK) {\n      LOG.log(Level.WARNING,\n          \"Error connecting to Stream Manager with status: {0}, Retrying...\", status);\n      Runnable r = new Runnable() {\n        public void run() {\n          start();\n        }\n      };\n      getNIOLooper().registerTimerEvent(\n          systemConfig.getInstanceReconnectStreammgrInterval(), r);\n      return;\n    }\n    // Initialize the register: determine what messages we would like to handle\n    registerMessagesToHandle();\n    // Build the request and send it.\n    LOG.info(\"Connected to Stream Manager. Ready to send register request\");\n    sendRegisterRequest();\n  }\n  // Build register request and send to stream mgr\n  private void sendRegisterRequest() {\n    StreamManager.RegisterInstanceRequest request =\n        StreamManager.RegisterInstanceRequest.newBuilder().\n            setInstance(instance).setTopologyName(topologyName).setTopologyId(topologyId).\n            build();\n    // The timeout would be the reconnect-interval-seconds\n    sendRequest(request, null,\n        StreamManager.RegisterInstanceResponse.newBuilder(),\n        systemConfig.getInstanceReconnectStreammgrInterval());\n  }\n  @Override\n  public void onResponse(StatusCode status, Object ctx, Message response) {\n    if (status != StatusCode.OK) {\n      //TODO:- is this a good thing?\n      throw new RuntimeException(\"Response from Stream Manager not ok\");\n    }\n    if (response instanceof StreamManager.RegisterInstanceResponse) {\n      handleRegisterResponse((StreamManager.RegisterInstanceResponse) response);\n    } else {\n      throw new RuntimeException(\"Unknown kind of response received from Stream Manager\");\n    }\n  }\n  @Override\n  public void onIncomingMessage(Message message) {\n    gatewayMetrics.updateReceivedPacketsCount(1);\n    gatewayMetrics.updateReceivedPacketsSize(message.getSerializedSize());\n    if (message instanceof StreamManager.NewInstanceAssignmentMessage) {\n      StreamManager.NewInstanceAssignmentMessage m =\n          (StreamManager.NewInstanceAssignmentMessage) message;\n      LOG.info(\"Handling assignment message from direct NewInstanceAssignmentMessage\");\n      handleAssignmentMessage(m.getPplan());\n    } else if (message instanceof HeronTuples.HeronTupleSet2) {\n      handleNewTuples2((HeronTuples.HeronTupleSet2) message);\n    } else if (message instanceof CheckpointManager.InitiateStatefulCheckpoint)  {\n      handleCheckpointRequest((CheckpointManager.InitiateStatefulCheckpoint) message);\n    } else if (message instanceof CheckpointManager.RestoreInstanceStateRequest) {\n      handleRestoreInstanceStateRequest((CheckpointManager.RestoreInstanceStateRequest) message);\n    } else if (message instanceof CheckpointManager.StartInstanceStatefulProcessing) {\n      handleStartStatefulRequest((CheckpointManager.StartInstanceStatefulProcessing) message);\n    } else {\n      throw new RuntimeException(\"Unknown kind of message received from Stream Manager\");\n    }\n  }\n  @Override\n  public void onClose() {\n    LOG.info(\"StreamManagerClient exits.\");\n  }\n  // Send out all the data\n  public void sendAllMessage() {\n    if (!isConnected()) {\n      return;\n    }\n    LOG.info(\"Flushing all pending data in StreamManagerClient\");\n    // Collect all tuples in queue\n    int size = outStreamQueue.size();\n    for (int i = 0; i < size; i++) {\n      Message streamMessage = outStreamQueue.poll();\n      sendMessage(streamMessage);\n    }\n  }\n  private void sendStreamMessageIfNeeded() {\n    if (isStreamMgrReadyReceiveTuples()) {\n      if (getOutstandingPackets() <= 0) {\n        // In order to avoid packets back up in Client side,\n        // We would poll message from queue and send them only when there are no outstanding packets\n        while (!outStreamQueue.isEmpty()) {<fim_middle>// function below has no smell\n"}