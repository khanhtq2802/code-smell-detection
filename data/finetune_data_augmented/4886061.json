{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.jackrabbit.jcr2spi.hierarchy;\nimport java.lang.ref.Reference;\nimport java.lang.ref.SoftReference;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.ConcurrentModificationException;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport javax.jcr.ItemNotFoundException;\nimport javax.jcr.RepositoryException;\nimport org.apache.commons.collections.list.AbstractLinkedList;\nimport org.apache.jackrabbit.jcr2spi.state.Status;\nimport org.apache.jackrabbit.spi.ChildInfo;\nimport org.apache.jackrabbit.spi.Name;\nimport org.apache.jackrabbit.spi.NodeId;\nimport org.apache.jackrabbit.spi.Path;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n/**\n * <code>ChildNodeEntriesImpl</code> implements a memory sensitive implementation\n * of the <code>ChildNodeEntries</code> interface.\n */\nfinal class ChildNodeEntriesImpl implements ChildNodeEntries {\n    private static Logger log = LoggerFactory.getLogger(ChildNodeEntriesImpl.class);\n    private boolean complete = false;\n    /**\n     * Linked list of {@link NodeEntry} instances.\n     */\n    private final LinkedEntries entries = new LinkedEntries();\n    /**\n     * Map used for lookup by name.\n     */\n    private final NameMap entriesByName = new NameMap();\n    private final NodeEntry parent;\n    private final EntryFactory factory;\n     /**\n      * Create a new <code>ChildNodeEntries</code> collection from the given\n      * <code>childNodeInfos</code> instead of retrieving them from the\n      * persistent layer.\n      *\n      * @param parent\n      * @param factory\n      * @param childNodeInfos The complete list of child infos or\n      * <code>null</code> if an 'empty' ChildNodeEntriesImpl should be created.\n      * In the latter case, individual child entries will be added on demand\n      * and the complete list will be retrieved only to answer {@link #iterator()}\n      * if the passed boolean is <code>true</code>.\n      */\n     ChildNodeEntriesImpl(NodeEntry parent, EntryFactory factory, Iterator<ChildInfo> childNodeInfos) {\n         this.parent = parent;\n         this.factory = factory;\n         if (childNodeInfos != null) {\n             while (childNodeInfos.hasNext()) {\n                 ChildInfo ci = childNodeInfos.next();\n                 NodeEntry entry = factory.createNodeEntry(parent, ci.getName(), ci.getUniqueID());\n                 add(entry, ci.getIndex());\n             }\n             complete = true;\n         } else {\n             complete = false;\n         }\n     }\n    /**\n     * @param childEntry\n     * @return The node entry that directly follows the given <code>childEntry</code>\n     * or <code>null</code> if the given <code>childEntry</code> has no successor\n     * or was not found in this <code>ChildNodeEntries</code>.\n     */\n    NodeEntry getNext(NodeEntry childEntry) {\n        LinkedEntries.LinkNode ln = entries.getLinkNode(childEntry);\n        LinkedEntries.LinkNode nextLn = (ln == null) ? null : ln.getNextLinkNode();\n        return (nextLn == null) ? null : nextLn.getNodeEntry();\n    }\n    /**\n     * @param childEntry\n     * @return The node entry that directly precedes the given <code>childEntry</code>\n     * or <code>null</code> if the given <code>childEntry</code> is the first\n     * or was not found in this <code>ChildNodeEntries</code>.\n     */\n    NodeEntry getPrevious(NodeEntry childEntry) {\n        LinkedEntries.LinkNode ln = entries.getLinkNode(childEntry);\n        LinkedEntries.LinkNode prevLn = (ln == null) ? null : ln.getPreviousLinkNode();\n        return (prevLn == null) ? null : prevLn.getNodeEntry();\n    }\n    /**\n     * @see ChildNodeEntries#isComplete()\n     */\n    public boolean isComplete() {\n        return (parent.getStatus() != Status.INVALIDATED && complete) ||\n                parent.getStatus() == Status.NEW ||\n                Status.isTerminal(parent.getStatus());\n    }\n    /**\n     * @see ChildNodeEntries#reload()\n     */\n<fim_suffix>    public synchronized void reload() throws ItemNotFoundException, RepositoryException {\n        if (isComplete()) {\n            // nothing to do\n            return;\n        }\n        NodeId id = parent.getWorkspaceId();\n        Iterator<ChildInfo> childNodeInfos = factory.getItemStateFactory().getChildNodeInfos(id);\n        update(childNodeInfos);\n    }\n    /**\n     * Update the child node entries according to the child-infos obtained\n     * from the persistence layer.\n     * NOTE: the status of the entries already present is not respected. Thus\n     * new or removed entries are not touched in order not to modify the\n     * transient status of the parent. Operations that affect the set or order\n     * of child entries (AddNode, Move, Reorder) currently assert the\n     * completeness of the ChildNodeEntries, therefore avoiding an update\n     * resulting in inconsistent entries.\n     *\n     * @param childNodeInfos\n     * @see HierarchyEntry#reload(boolean) that ignores items with\n     * pending changes.\n     * @see org.apache.jackrabbit.jcr2spi.operation.AddNode\n     * @see org.apache.jackrabbit.jcr2spi.operation.Move\n     * @see org.apache.jackrabbit.jcr2spi.operation.ReorderNodes\n     */\n    synchronized void update(Iterator<ChildInfo> childNodeInfos) {\n        // insert missing entries and reorder all if necessary.\n        LinkedEntries.LinkNode prevLN = null;\n        while (childNodeInfos.hasNext()) {\n            ChildInfo ci = childNodeInfos.next();\n            LinkedEntries.LinkNode ln = entriesByName.getLinkNode(ci.getName(), ci.getIndex(), ci.getUniqueID());\n            if (ln == null) {\n                // add missing at the correct position.\n                NodeEntry entry = factory.createNodeEntry(parent, ci.getName(), ci.getUniqueID());\n                ln = internalAddAfter(entry, ci.getIndex(), prevLN);\n            } else if (prevLN != null) {\n                // assert correct order of existing\n                if (prevLN != ln) {\n                    reorderAfter(ln, prevLN);\n                } else {\n                    // there was an existing entry but it's the same as the one\n                    // created/retrieved before. getting here indicates that\n                    // the SPI implementation provided invalid childNodeInfos.\n                    log.error(\"ChildInfo iterator contains multiple entries with the same name|index or uniqueID -> ignore ChildNodeInfo.\");\n                }\n            }\n            prevLN = ln;\n        }\n        // finally reset the status\n        complete = true;\n    }\n    /**\n     * @see ChildNodeEntries#iterator()\n     */\n    public Iterator<NodeEntry> iterator() {\n        List<NodeEntry> l = new ArrayList<NodeEntry>(entries.size());\n        for (Iterator<LinkedEntries.LinkNode> it = entries.linkNodeIterator(); it.hasNext();) {\n            l.add(it.next().getNodeEntry());\n        }\n        return Collections.unmodifiableList(l).iterator();\n    }\n    /**\n     * @see ChildNodeEntries#get(Name)\n     */\n    public List<NodeEntry> get(Name nodeName) {\n        return entriesByName.getList(nodeName);\n    }\n    /**\n     * @see ChildNodeEntries#get(Name, int)\n     */\n    public NodeEntry get(Name nodeName, int index) {\n        if (index < Path.INDEX_DEFAULT) {\n            throw new IllegalArgumentException(\"index is 1-based\");\n        }\n        return entriesByName.getNodeEntry(nodeName, index);\n    }\n    /**\n     * @see ChildNodeEntries#get(Name, String)\n     */\n    public NodeEntry get(Name nodeName, String uniqueID) {\n        if (uniqueID == null || nodeName == null) {\n            throw new IllegalArgumentException();\n        }\n        for (NodeEntry cne : get(nodeName)) {\n            if (uniqueID.equals(cne.getUniqueID())) {\n                return cne;\n            }\n        }\n        return null;\n    }\n    /**<fim_middle>// function below has no smell\n"}