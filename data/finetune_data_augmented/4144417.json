{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.calcite.rel.rules;\nimport org.apache.calcite.plan.Contexts;\nimport org.apache.calcite.plan.RelOptRule;\nimport org.apache.calcite.plan.RelOptRuleCall;\nimport org.apache.calcite.plan.RelOptUtil;\nimport org.apache.calcite.rel.RelNode;\nimport org.apache.calcite.rel.core.Join;\nimport org.apache.calcite.rel.core.JoinRelType;\nimport org.apache.calcite.rel.core.RelFactories;\nimport org.apache.calcite.rel.core.RelFactories.ProjectFactory;\nimport org.apache.calcite.rel.logical.LogicalJoin;\nimport org.apache.calcite.rel.type.RelDataType;\nimport org.apache.calcite.rel.type.RelDataTypeField;\nimport org.apache.calcite.rex.RexBuilder;\nimport org.apache.calcite.rex.RexCall;\nimport org.apache.calcite.rex.RexInputRef;\nimport org.apache.calcite.rex.RexNode;\nimport org.apache.calcite.tools.RelBuilder;\nimport org.apache.calcite.tools.RelBuilderFactory;\nimport com.google.common.collect.ImmutableList;\nimport java.util.List;\n/**\n * Planner rule that permutes the inputs to a\n * {@link org.apache.calcite.rel.core.Join}.\n *\n * <p>Permutation of outer joins can be turned on/off by specifying the\n * swapOuter flag in the constructor.\n *\n * <p>To preserve the order of columns in the output row, the rule adds a\n * {@link org.apache.calcite.rel.core.Project}.\n */\npublic class JoinCommuteRule extends RelOptRule {\n  //~ Static fields/initializers ---------------------------------------------\n  /** Instance of the rule that only swaps inner joins. */\n  public static final JoinCommuteRule INSTANCE = new JoinCommuteRule(false);\n  /** Instance of the rule that swaps outer joins as well as inner joins. */\n  public static final JoinCommuteRule SWAP_OUTER = new JoinCommuteRule(true);\n  private final boolean swapOuter;\n  //~ Constructors -----------------------------------------------------------\n  /**\n   * Creates a JoinCommuteRule.\n   */\n  public JoinCommuteRule(Class<? extends Join> clazz,\n      RelBuilderFactory relBuilderFactory, boolean swapOuter) {\n    super(operand(clazz, any()), relBuilderFactory, null);\n    this.swapOuter = swapOuter;\n  }\n  private JoinCommuteRule(boolean swapOuter) {\n    this(LogicalJoin.class, RelFactories.LOGICAL_BUILDER, swapOuter);\n  }\n  @Deprecated // to be removed before 2.0\n  public JoinCommuteRule(Class<? extends Join> clazz,\n      ProjectFactory projectFactory) {\n    this(clazz, RelBuilder.proto(Contexts.of(projectFactory)), false);\n  }\n  @Deprecated // to be removed before 2.0\n  public JoinCommuteRule(Class<? extends Join> clazz,\n      ProjectFactory projectFactory, boolean swapOuter) {\n    this(clazz, RelBuilder.proto(Contexts.of(projectFactory)), swapOuter);\n  }\n  //~ Methods ----------------------------------------------------------------\n<fim_suffix>  @Deprecated // to be removed before 2.0\n  public static RelNode swap(Join join) {\n    return swap(join, false,\n        RelFactories.LOGICAL_BUILDER.create(join.getCluster(), null));\n  }\n  @Deprecated // to be removed before 2.0\n  public static RelNode swap(Join join, boolean swapOuterJoins) {\n    return swap(join, swapOuterJoins,\n        RelFactories.LOGICAL_BUILDER.create(join.getCluster(), null));\n  }\n  /**\n   * Returns a relational expression with the inputs switched round. Does not\n   * modify <code>join</code>. Returns null if the join cannot be swapped (for\n   * example, because it is an outer join).\n   *\n   * @param join              join to be swapped\n   * @param swapOuterJoins    whether outer joins should be swapped\n   * @param relBuilder        Builder for relational expressions\n   * @return swapped join if swapping possible; else null\n   */\n  public static RelNode swap(Join join, boolean swapOuterJoins,\n      RelBuilder relBuilder) {\n    final JoinRelType joinType = join.getJoinType();\n    if (!swapOuterJoins && joinType != JoinRelType.INNER) {\n      return null;\n    }\n    final RexBuilder rexBuilder = join.getCluster().getRexBuilder();\n    final RelDataType leftRowType = join.getLeft().getRowType();\n    final RelDataType rightRowType = join.getRight().getRowType();\n    final VariableReplacer variableReplacer =\n        new VariableReplacer(rexBuilder, leftRowType, rightRowType);\n    final RexNode oldCondition = join.getCondition();\n    RexNode condition = variableReplacer.go(oldCondition);\n    // NOTE jvs 14-Mar-2006: We preserve attribute semiJoinDone after the\n    // swap.  This way, we will generate one semijoin for the original\n    // join, and one for the swapped join, and no more.  This\n    // doesn't prevent us from seeing any new combinations assuming\n    // that the planner tries the desired order (semijoins after swaps).\n    Join newJoin =\n        join.copy(join.getTraitSet(), condition, join.getRight(),\n            join.getLeft(), joinType.swap(), join.isSemiJoinDone());\n    final List<RexNode> exps =\n        RelOptUtil.createSwappedJoinExprs(newJoin, join, true);\n    return relBuilder.push(newJoin)\n        .project(exps, join.getRowType().getFieldNames())\n        .build();\n  }\n  public void onMatch(final RelOptRuleCall call) {\n    Join join = call.rel(0);\n    if (!join.getSystemFieldList().isEmpty()) {\n      // FIXME Enable this rule for joins with system fields\n      return;\n    }\n    final RelNode swapped = swap(join, this.swapOuter, call.builder());\n    if (swapped == null) {\n      return;\n    }\n    // The result is either a Project or, if the project is trivial, a\n    // raw Join.\n    final Join newJoin =\n        swapped instanceof Join\n            ? (Join) swapped\n            : (Join) swapped.getInput(0);\n    call.transformTo(swapped);\n    // We have converted join='a join b' into swapped='select\n    // a0,a1,a2,b0,b1 from b join a'. Now register that project='select\n    // b0,b1,a0,a1,a2 from (select a0,a1,a2,b0,b1 from b join a)' is the\n    // same as 'b join a'. If we didn't do this, the swap join rule\n    // would fire on the new join, ad infinitum.\n    final RelBuilder relBuilder = call.builder();\n    final List<RexNode> exps =\n        RelOptUtil.createSwappedJoinExprs(newJoin, join, false);\n    relBuilder.push(swapped)\n        .project(exps, newJoin.getRowType().getFieldNames());\n    call.getPlanner().ensureRegistered(relBuilder.build(), newJoin);\n  }\n  //~ Inner Classes ----------------------------------------------------------\n  /**\n   * Walks over an expression, replacing references to fields of the left and\n   * right inputs.\n   *\n   * <p>If the field index is less than leftFieldCount, it must be from the\n   * left, and so has rightFieldCount added to it; if the field index is\n   * greater than leftFieldCount, it must be from the right, so we subtract\n   * leftFieldCount from it.</p>\n   */\n  private static class VariableReplacer {\n    private final RexBuilder rexBuilder;\n    private final List<RelDataTypeField> leftFields;\n    private final List<RelDataTypeField> rightFields;\n    VariableReplacer(\n        RexBuilder rexBuilder,\n        RelDataType leftType,\n        RelDataType rightType) {\n      this.rexBuilder = rexBuilder;\n      this.leftFields = leftType.getFieldList();<fim_middle>// function below has no smell\n"}