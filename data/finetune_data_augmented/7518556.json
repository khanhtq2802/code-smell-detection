{"text": "<fim_prefix>            case INT:\n                return \"int\";\n            case LONG:\n                return \"long\";\n            case DECLARED:\n                return getDeclaredName((DeclaredType) mirror, true);\n            case ARRAY:\n                return getSimpleName(((ArrayType) mirror).getComponentType()) + \"[]\";\n            case VOID:\n                return \"void\";\n            case NULL:\n                return \"null\";\n            case WILDCARD:\n                return getWildcardName((WildcardType) mirror);\n            case TYPEVAR:\n                return ((TypeVariable) mirror).asElement().getSimpleName().toString();\n            case ERROR:\n                throw new CompileErrorException(\"Type error \" + mirror);\n            case NONE:\n                return \"None\";\n            default:\n                throw new RuntimeException(\"Unknown type specified \" + mirror.getKind() + \" mirror: \" + mirror);\n        }\n    }\n    private static String getWildcardName(WildcardType type) {\n        StringBuilder b = new StringBuilder();\n        if (type.getExtendsBound() != null) {\n            b.append(\"? extends \").append(getSimpleName(type.getExtendsBound()));\n        } else if (type.getSuperBound() != null) {\n            b.append(\"? super \").append(getSimpleName(type.getExtendsBound()));\n        }\n        return b.toString();\n    }\n    public static String getDeclaredName(DeclaredType element, boolean includeTypeVariables) {\n        String simpleName = fixECJBinaryNameIssue(element.asElement().getSimpleName().toString());\n        if (!includeTypeVariables || element.getTypeArguments().size() == 0) {\n            return simpleName;\n        }\n        StringBuilder b = new StringBuilder(simpleName);\n        b.append(\"<\");\n        if (element.getTypeArguments().size() > 0) {\n            for (int i = 0; i < element.getTypeArguments().size(); i++) {\n                b.append(getSimpleName(element.getTypeArguments().get(i)));\n                if (i < element.getTypeArguments().size() - 1) {\n                    b.append(\", \");\n                }\n            }\n        }\n        b.append(\">\");\n        return b.toString();\n    }\n    public static String fixECJBinaryNameIssue(String name) {\n        if (name.contains(\"$\")) {\n            int lastIndex = name.lastIndexOf('$');\n            return name.substring(lastIndex + 1, name.length());\n        }\n        return name;\n    }\n    public static String getClassQualifiedName(TypeElement e) {\n        StringBuilder b = new StringBuilder();\n        buildClassQualifiedNameImpl(e, b);\n        return b.toString();\n    }\n    private static void buildClassQualifiedNameImpl(Element e, StringBuilder classNames) {\n        if (e == null) {\n            return;\n        } else if (e.getKind() == ElementKind.PACKAGE) {\n            String packageName = getPackageName(e);\n            if (packageName != null) {\n                classNames.append(packageName);\n            }\n        } else {\n            Element enclosingElement = e.getEnclosingElement();\n            buildClassQualifiedNameImpl(enclosingElement, classNames);\n            if (enclosingElement.getKind().isClass()) {\n                classNames.append(\"$\");\n            } else {\n                classNames.append(\".\");\n            }\n            classNames.append(e.getSimpleName().toString());\n        }\n    }\n    public static String getQualifiedName(TypeElement element) {\n        String qualifiedName = element.getQualifiedName().toString();\n        if (qualifiedName.contains(\"$\")) {\n            /*\n             * If a class gets loaded in its binary form by the ECJ compiler it fails to produce the\n             * proper canonical class name. It leaves the $ in the qualified name of the class. So\n             * one instance of a TypeElement may be loaded in binary and one in source form. The\n             * current type comparison in #typeEquals compares by the qualified name so the\n             * qualified name must match. This is basically a hack to fix the returned qualified\n             * name of eclipse.\n             */\n            qualifiedName = qualifiedName.replace('$', '.');\n        }\n        return qualifiedName;\n    }\n    public static String getQualifiedName(TypeMirror mirror) {\n        switch (mirror.getKind()) {\n            case BOOLEAN:\n                return \"boolean\";\n            case BYTE:\n                return \"byte\";\n            case CHAR:\n                return \"char\";\n            case DOUBLE:\n                return \"double\";\n            case SHORT:\n                return \"short\";\n            case FLOAT:\n                return \"float\";\n            case INT:\n                return \"int\";\n            case LONG:\n                return \"long\";\n            case DECLARED:\n                return getQualifiedName(fromTypeMirror(mirror));\n            case ARRAY:\n                return getQualifiedName(((ArrayType) mirror).getComponentType());\n            case VOID:\n                return \"void\";\n            case NULL:\n                return \"null\";\n            case TYPEVAR:\n                return getSimpleName(mirror);\n            case ERROR:\n                throw new CompileErrorException(\"Type error \" + mirror);\n            case EXECUTABLE:\n                return ((ExecutableType) mirror).toString();\n            case NONE:\n                return \"$none\";\n            default:\n                throw new RuntimeException(\"Unknown type specified \" + mirror + \" mirror: \" + mirror);\n        }\n    }\n    public static boolean isNone(TypeMirror mirror) {\n        return mirror != null && isInvalidType(mirror);\n    }\n    public static boolean isVoid(TypeMirror mirror) {\n        return mirror != null && mirror.getKind() == TypeKind.VOID;\n    }\n    public static boolean isPrimitive(TypeMirror mirror) {\n        return mirror != null && mirror.getKind().isPrimitive();\n    }\n    public static List<String> getQualifiedSuperTypeNames(TypeElement element) {\n        List<TypeElement> types = getSuperTypes(element);\n        List<String> qualifiedNames = new ArrayList<>();\n        for (TypeElement type : types) {\n            qualifiedNames.add(getQualifiedName(type));\n        }\n        return qualifiedNames;\n    }\n    public static List<TypeElement> getDeclaredTypes(TypeElement element) {\n        return ElementFilter.typesIn(element.getEnclosedElements());\n    }\n    public static boolean isEnclosedIn(Element enclosedIn, Element element) {\n        if (element == null) {\n            return false;\n        } else if (typeEquals(enclosedIn.asType(), element.asType())) {\n            return true;\n        } else {\n            return isEnclosedIn(enclosedIn, element.getEnclosingElement());\n        }\n    }\n    public static List<Element> getElementHierarchy(Element e) {\n        List<Element> elements = new ArrayList<>();\n        Element enclosing = null;\n        if (e != null) {\n            elements.add(e);\n            enclosing = e.getEnclosingElement();\n        }\n        while (enclosing != null && enclosing.getKind() != ElementKind.PACKAGE) {\n            elements.add(enclosing);\n            enclosing = enclosing.getEnclosingElement();\n        }\n        if (enclosing != null) {\n            elements.add(enclosing);\n        }\n        return elements;\n    }\n    public static Optional<TypeElement> findRootEnclosingType(Element element) {\n        TypeElement parentType = findParentEnclosingType(element).orElse(null);\n        if (parentType == null) {\n            return findNearestEnclosingType(element);\n        } else {\n            return findRootEnclosingType(parentType);\n        }\n    }\n    public static Optional<TypeElement> findParentEnclosingType(Element element) {\n        if (element == null) {\n            return Optional.empty();\n        }\n        return findNearestEnclosingType(element.getEnclosingElement());\n    }\n    public static Optional<TypeElement> findNearestEnclosingType(Element e) {\n        if (e != null) {\n            if (e.getKind().isInterface() || e.getKind().isClass()) {\n                return Optional.of((TypeElement) e);\n            }\n            Element enclosing = e.getEnclosingElement();\n            if (enclosing != null && enclosing.getKind() != ElementKind.PACKAGE) {\n                return findNearestEnclosingType(enclosing);\n            }\n        }\n        return Optional.empty();\n    }\n    public static List<TypeElement> getDirectSuperTypes(TypeElement element) {\n        List<TypeElement> types = new ArrayList<>();\n        TypeElement superElement = getSuperType(element);\n        if (superElement != null) {\n            types.add(superElement);\n            types.addAll(getDirectSuperTypes(superElement));\n        }\n        return types;\n    }\n    /**\n     * Gets the element representing the {@linkplain TypeElement#getSuperclass() super class} of a\n     * given type element.\n     */\n    public static TypeElement getSuperType(TypeElement element) {\n        if (element == null) {\n            return null;\n        } else if (element.getSuperclass() != null) {\n            return fromTypeMirror(element.getSuperclass());\n        }\n        return null;\n    }\n<fim_suffix>    public static boolean isDeprecated(TypeMirror baseType) {\n        if (baseType instanceof DeclaredType) {\n            return isDeprecated((TypeElement) ((DeclaredType) baseType).asElement());\n        }\n        return false;\n    }<fim_middle>// function below has no smell\n"}