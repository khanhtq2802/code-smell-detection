{"text": "<fim_prefix>/*******************************************************************************\n * Copyright (c) 2003, 2010 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     IBM Corporation - initial API and implementation\n *******************************************************************************/\npackage org.eclipse.draw2d.graph;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\n/**\n * Calculates the X-coordinates for nodes in a compound directed graph.\n * \n * @author Randy Hudson\n * @since 2.1.2\n */\n<fim_suffix>class CompoundHorizontalPlacement extends HorizontalPlacement {\n\n\tclass LeftRight {\n\t\t// $TODO Delete and use NodePair class, equivalent\n\t\tObject left, right;\n\n\t\tLeftRight(Object l, Object r) {\n\t\t\tleft = l;\n\t\t\tright = r;\n\t\t}\n\n\t\tpublic boolean equals(Object obj) {\n\t\t\tLeftRight entry = (LeftRight) obj;\n\t\t\treturn entry.left.equals(left) && entry.right.equals(right);\n\t\t}\n\n\t\tpublic int hashCode() {\n\t\t\treturn left.hashCode() ^ right.hashCode();\n\t\t}\n\t}\n\n\tSet entries = new HashSet();\n\n\t/**\n\t * @see org.eclipse.graph.HorizontalPlacement#applyGPrime()\n\t */\n\tvoid applyGPrime() {\n\t\tsuper.applyGPrime();\n\t\tNodeList subgraphs = ((CompoundDirectedGraph) graph).subgraphs;\n\t\tfor (int i = 0; i < subgraphs.size(); i++) {\n\t\t\tSubgraph s = (Subgraph) subgraphs.get(i);\n\t\t\ts.x = s.left.x;\n\t\t\ts.width = s.right.x + s.right.width - s.x;\n\t\t}\n\t}\n\n\t/**\n\t * @see HorizontalPlacement#buildRankSeparators(RankList)\n\t */\n\tvoid buildRankSeparators(RankList ranks) {\n\t\tCompoundDirectedGraph g = (CompoundDirectedGraph) graph;\n\n\t\tRank rank;\n\t\tfor (int row = 0; row < g.ranks.size(); row++) {\n\t\t\trank = g.ranks.getRank(row);\n\t\t\tNode n = null, prev = null;\n\t\t\tfor (int j = 0; j < rank.size(); j++) {\n\t\t\t\tn = rank.getNode(j);\n\t\t\t\tif (prev == null) {\n\t\t\t\t\tNode left = addSeparatorsLeft(n, null);\n\t\t\t\t\tif (left != null) {\n\t\t\t\t\t\tEdge e = new Edge(graphLeft, getPrime(left), 0, 0);\n\t\t\t\t\t\tprime.edges.add(e);\n\t\t\t\t\t\te.delta = graph.getPadding(n).left\n\t\t\t\t\t\t\t\t+ graph.getMargin().left;\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\tSubgraph s = GraphUtilities.getCommonAncestor(prev, n);\n\t\t\t\t\tNode left = addSeparatorsRight(prev, s);\n\t\t\t\t\tNode right = addSeparatorsLeft(n, s);\n\t\t\t\t\tcreateEdge(left, right);\n\t\t\t\t}\n\t\t\t\tprev = n;\n\t\t\t}\n\t\t\tif (n != null)\n\t\t\t\taddSeparatorsRight(n, null);\n\t\t}\n\t}\n\n\tvoid createEdge(Node left, Node right) {\n\t\tLeftRight entry = new LeftRight(left, right);\n\t\tif (entries.contains(entry))\n\t\t\treturn;\n\t\tentries.add(entry);\n\t\tint separation = left.width + graph.getPadding(left).right\n\t\t\t\t+ graph.getPadding(right).left;\n\t\tprime.edges\n\t\t\t\t.add(new Edge(getPrime(left), getPrime(right), separation, 0));\n\t}\n\n\tNode addSeparatorsLeft(Node n, Subgraph graph) {\n\t\tSubgraph parent = n.getParent();\n\t\twhile (parent != graph && parent != null) {\n\t\t\tcreateEdge(getLeft(parent), n);\n\t\t\tn = parent.left;\n\t\t\tparent = parent.getParent();\n\t\t}\n\t\treturn n;\n\t}\n\n\tNode addSeparatorsRight(Node n, Subgraph graph) {\n\t\tSubgraph parent = n.getParent();\n\t\twhile (parent != graph && parent != null) {\n\t\t\tcreateEdge(n, getRight(parent));\n\t\t\tn = parent.right;\n\t\t\tparent = parent.getParent();\n\t\t}\n\t\treturn n;\n\t}\n\n\tNode getLeft(Subgraph s) {\n\t\tif (s.left == null) {\n\t\t\ts.left = new SubgraphBoundary(s, graph.getPadding(s), 1);\n\t\t\ts.left.rank = (s.head.rank + s.tail.rank) / 2;\n\n\t\t\tNode head = getPrime(s.head);\n\t\t\tNode tail = getPrime(s.tail);\n\t\t\tNode left = getPrime(s.left);\n\t\t\tNode right = getPrime(getRight(s));\n\t\t\tprime.edges.add(new Edge(left, right, s.width, 0));\n\t\t\tprime.edges.add(new Edge(left, head, 0, 1));\n\t\t\tprime.edges.add(new Edge(head, right, 0, 1));\n\t\t\tprime.edges.add(new Edge(left, tail, 0, 1));\n\t\t\tprime.edges.add(new Edge(tail, right, 0, 1));\n\t\t}\n\t\treturn s.left;\n\t}\n\n\tNode getRight(Subgraph s) {\n\t\tif (s.right == null) {\n\t\t\ts.right = new SubgraphBoundary(s, graph.getPadding(s), 3);\n\t\t\ts.right.rank = (s.head.rank + s.tail.rank) / 2;\n\t\t}\n\t\treturn s.right;\n\t}\n\n\tNode getPrime(Node n) {\n\t\tNode nPrime = get(n);\n\t\tif (nPrime == null) {\n\t\t\tnPrime = new Node(n);\n\t\t\tprime.nodes.add(nPrime);\n\t\t\tmap(n, nPrime);\n\t\t}\n\t\treturn nPrime;\n\t}\n\n\tpublic void visit(DirectedGraph g) {\n\t\tsuper.visit(g);\n\t}\n\n}<fim_middle>// class below has no smell\n"}