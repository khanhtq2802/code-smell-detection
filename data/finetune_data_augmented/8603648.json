{"text": "<fim_prefix> * limitations under the License.\n */\npackage org.apache.ignite.internal.processors.cache.distributed.dht.atomic;\nimport java.nio.ByteBuffer;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.apache.ignite.internal.GridDirectCollection;\nimport org.apache.ignite.internal.processors.cache.CacheObject;\nimport org.apache.ignite.internal.processors.cache.version.GridCacheVersion;\nimport org.apache.ignite.internal.util.GridLongList;\nimport org.apache.ignite.internal.util.tostring.GridToStringInclude;\nimport org.apache.ignite.internal.util.typedef.internal.S;\nimport org.apache.ignite.plugin.extensions.communication.Message;\nimport org.apache.ignite.plugin.extensions.communication.MessageCollectionItemType;\nimport org.apache.ignite.plugin.extensions.communication.MessageReader;\nimport org.apache.ignite.plugin.extensions.communication.MessageWriter;\nimport org.jetbrains.annotations.Nullable;\n/**\n *\n */\n<fim_suffix>public class NearCacheUpdates implements Message {\n    /** */\n    private static final long serialVersionUID = 0L;\n    /** Indexes of keys for which values were generated on primary node (used if originating node has near cache). */\n    @GridDirectCollection(int.class)\n    private List<Integer> nearValsIdxs;\n    /** Indexes of keys for which update was skipped (used if originating node has near cache). */\n    @GridDirectCollection(int.class)\n    private List<Integer> nearSkipIdxs;\n    /** Values generated on primary node which should be put to originating node's near cache. */\n    @GridToStringInclude\n    @GridDirectCollection(CacheObject.class)\n    private List<CacheObject> nearVals;\n    /** Version generated on primary node to be used for originating node's near cache update. */\n    private GridCacheVersion nearVer;\n    /** Near TTLs. */\n    private GridLongList nearTtls;\n    /** Near expire times. */\n    private GridLongList nearExpireTimes;\n    /**\n     * @return Values.\n     */\n    List<CacheObject> nearValues() {\n        return nearVals;\n    }\n    /**\n     * Adds value to be put in near cache on originating node.\n     *\n     * @param keyIdx Key index.\n     * @param val Value.\n     * @param ttl TTL for near cache update.\n     * @param expireTime Expire time for near cache update.\n     */\n    void addNearValue(int keyIdx,\n        @Nullable CacheObject val,\n        long ttl,\n        long expireTime) {\n        if (nearValsIdxs == null) {\n            nearValsIdxs = new ArrayList<>();\n            nearVals = new ArrayList<>();\n        }\n        addNearTtl(keyIdx, ttl, expireTime);\n        nearValsIdxs.add(keyIdx);\n        nearVals.add(val);\n    }\n    /**\n     * @param keyIdx Key index.\n     * @param ttl TTL for near cache update.\n     * @param expireTime Expire time for near cache update.\n     */\n    void addNearTtl(int keyIdx, long ttl, long expireTime) {\n        if (ttl >= 0) {\n            if (nearTtls == null) {\n                nearTtls = new GridLongList(16);\n                for (int i = 0; i < keyIdx; i++)\n                    nearTtls.add(-1L);\n            }\n        }\n        if (nearTtls != null)\n            nearTtls.add(ttl);\n        if (expireTime >= 0) {\n            if (nearExpireTimes == null) {\n                nearExpireTimes = new GridLongList(16);\n                for (int i = 0; i < keyIdx; i++)\n                    nearExpireTimes.add(-1);\n            }\n        }\n        if (nearExpireTimes != null)\n            nearExpireTimes.add(expireTime);\n    }\n    /**\n     * @param idx Index.\n     * @return Expire time for near cache update.\n     */\n    long nearExpireTime(int idx) {\n        if (nearExpireTimes != null) {\n            assert idx >= 0 && idx < nearExpireTimes.size();\n            return nearExpireTimes.get(idx);\n        }\n        return -1L;\n    }\n    /**\n     * @param idx Index.\n     * @return TTL for near cache update.\n     */\n    long nearTtl(int idx) {\n        if (nearTtls != null) {\n            assert idx >= 0 && idx < nearTtls.size();\n            return nearTtls.get(idx);\n        }\n        return -1L;\n    }\n    /**\n     * @param nearVer Version generated on primary node to be used for originating node's near cache update.\n     */\n    void nearVersion(GridCacheVersion nearVer) {\n        this.nearVer = nearVer;\n    }\n    /**\n     * @return Version generated on primary node to be used for originating node's near cache update.\n     */\n    GridCacheVersion nearVersion() {\n        return nearVer;\n    }\n    /**\n     * @param keyIdx Index of key for which update was skipped\n     */\n    void addSkippedIndex(int keyIdx) {\n        if (nearSkipIdxs == null)\n            nearSkipIdxs = new ArrayList<>();\n        nearSkipIdxs.add(keyIdx);\n        addNearTtl(keyIdx, -1L, -1L);\n    }\n    /**\n     * @return Indexes of keys for which update was skipped\n     */\n    @Nullable List<Integer> skippedIndexes() {\n        return nearSkipIdxs;\n    }\n    /**\n     * @return Indexes of keys for which values were generated on primary node.\n     */\n    @Nullable List<Integer> nearValuesIndexes() {\n        return nearValsIdxs;\n    }\n    /**\n     * @param idx Index.\n     * @return Value generated on primary node which should be put to originating node's near cache.\n     */\n    @Nullable CacheObject nearValue(int idx) {\n        return nearVals.get(idx);\n    }\n    /** {@inheritDoc} */\n    @Override public boolean writeTo(ByteBuffer buf, MessageWriter writer) {\n        writer.setBuffer(buf);\n        if (!writer.isHeaderWritten()) {\n            if (!writer.writeHeader(directType(), fieldsCount()))\n                return false;\n            writer.onHeaderWritten();\n        }\n        switch (writer.state()) {\n            case 0:\n                if (!writer.writeMessage(\"nearExpireTimes\", nearExpireTimes))\n                    return false;\n                writer.incrementState();\n            case 1:\n                if (!writer.writeCollection(\"nearSkipIdxs\", nearSkipIdxs, MessageCollectionItemType.INT))\n                    return false;\n                writer.incrementState();\n            case 2:\n                if (!writer.writeMessage(\"nearTtls\", nearTtls))\n                    return false;\n                writer.incrementState();\n            case 3:\n                if (!writer.writeCollection(\"nearVals\", nearVals, MessageCollectionItemType.MSG))\n                    return false;\n                writer.incrementState();\n            case 4:\n                if (!writer.writeCollection(\"nearValsIdxs\", nearValsIdxs, MessageCollectionItemType.INT))\n                    return false;\n                writer.incrementState();\n            case 5:\n                if (!writer.writeMessage(\"nearVer\", nearVer))\n                    return false;\n                writer.incrementState();\n        }\n        return true;\n    }\n    /** {@inheritDoc} */\n    @Override public boolean readFrom(ByteBuffer buf, MessageReader reader) {\n        reader.setBuffer(buf);\n        if (!reader.beforeMessageRead())\n            return false;\n        switch (reader.state()) {\n            case 0:\n                nearExpireTimes = reader.readMessage(\"nearExpireTimes\");\n                if (!reader.isLastRead())\n                    return false;\n                reader.incrementState();\n            case 1:\n                nearSkipIdxs = reader.readCollection(\"nearSkipIdxs\", MessageCollectionItemType.INT);\n                if (!reader.isLastRead())\n                    return false;\n                reader.incrementState();\n            case 2:\n                nearTtls = reader.readMessage(\"nearTtls\");\n                if (!reader.isLastRead())\n                    return false;\n                reader.incrementState();\n            case 3:\n                nearVals = reader.readCollection(\"nearVals\", MessageCollectionItemType.MSG);\n                if (!reader.isLastRead())\n                    return false;\n                reader.incrementState();\n            case 4:\n                nearValsIdxs = reader.readCollection(\"nearValsIdxs\", MessageCollectionItemType.INT);\n                if (!reader.isLastRead())\n                    return false;\n                reader.incrementState();\n            case 5:\n                nearVer = reader.readMessage(\"nearVer\");\n                if (!reader.isLastRead())\n                    return false;\n                reader.incrementState();\n        }\n        return reader.afterMessageRead(NearCacheUpdates.class);\n    }\n    /** {@inheritDoc} */\n    @Override public short directType() {\n        return -51;\n    }\n    /** {@inheritDoc} */\n    @Override public byte fieldsCount() {\n        return 6;\n    }\n    /** {@inheritDoc} */\n    @Override public void onAckReceived() {\n        // No-op.\n    }\n    /** {@inheritDoc} */\n    @Override public String toString() {\n        return S.toString(NearCacheUpdates.class, this);\n    }\n}<fim_middle>// class below has no smell\n"}