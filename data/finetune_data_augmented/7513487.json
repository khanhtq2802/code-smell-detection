{"text": "<fim_prefix>            case EQ:\n                return LLVMAddressEqualsNodeGen.create(l, r);\n            case NEQ:\n                return LLVMNegateNodeGen.create(LLVMAddressEqualsNodeGen.create(null, null), l, r);\n            default:\n                throw new AssertionError();\n        }\n    }\n    public enum Kind {\n        ULT,\n        ULE,\n        SLT,\n        SLE,\n        EQ,\n        NEQ,\n    }\n    protected abstract static class NativePointerCompare {\n        abstract boolean compare(long a, long b);\n    }\n    /**\n     * Whenever we used {@link ManagedToComparableValue} in this class, we only convert the managed\n     * object to a long value and ignore the pointer offset (including the offset would increase the\n     * probability of collisions). However, we can only ignore the offset safely when we know that\n     * both pointers do not point to the same object.\n     */\n    abstract static class LLVMManagedCompareNode extends LLVMNode {\n        private static final long TYPICAL_POINTER = 0x00007f0000000000L;\n        abstract boolean execute(Object a, LLVMNativeLibrary libA, Object b, LLVMNativeLibrary libB, NativePointerCompare op);\n        @Specialization(guards = {\"pointToSameObject.execute(a, b)\"})\n        protected boolean doForeign(LLVMManagedPointer a, @SuppressWarnings(\"unused\") LLVMNativeLibrary libA,\n                        LLVMManagedPointer b, @SuppressWarnings(\"unused\") LLVMNativeLibrary libB, NativePointerCompare op,\n                        @Cached(\"create()\") @SuppressWarnings(\"unused\") LLVMPointToSameObjectNode pointToSameObject) {\n            // when comparing pointers to the same object, it is not sufficient to simply compare\n            // the offsets if we have an unsigned comparison and one of the offsets is negative. So,\n            // we add a \"typical\" pointer value to both offsets and compare the resulting values.\n            return op.compare(TYPICAL_POINTER + a.getOffset(), TYPICAL_POINTER + b.getOffset());\n        }\n        @Specialization(guards = \"!pointToSameObject.execute(a, b)\")\n        protected boolean doForeign(LLVMManagedPointer a, @SuppressWarnings(\"unused\") LLVMNativeLibrary libA,\n                        LLVMManagedPointer b, @SuppressWarnings(\"unused\") LLVMNativeLibrary libB, NativePointerCompare op,\n                        @Cached(\"create()\") @SuppressWarnings(\"unused\") LLVMPointToSameObjectNode pointToSameObject,\n                        @Cached(\"createIgnoreOffset()\") ManagedToComparableValue convertA,\n                        @Cached(\"createIgnoreOffset()\") ManagedToComparableValue convertB) {\n            return op.compare(convertA.executeWithTarget(a), convertB.executeWithTarget(b));\n        }\n        @Specialization(guards = \"pointToSameObject.execute(a, b)\")\n        protected boolean doVirtual(LLVMVirtualAllocationAddress a, @SuppressWarnings(\"unused\") LLVMNativeLibrary libA,\n                        LLVMVirtualAllocationAddress b, @SuppressWarnings(\"unused\") LLVMNativeLibrary libB, NativePointerCompare op,\n                        @Cached(\"create()\") @SuppressWarnings(\"unused\") LLVMPointToSameObjectNode pointToSameObject) {\n            return op.compare(TYPICAL_POINTER + a.getOffset(), TYPICAL_POINTER + b.getOffset());\n        }\n        @Specialization(guards = \"!pointToSameObject.execute(a, b)\")\n        protected boolean doVirtual(LLVMVirtualAllocationAddress a, @SuppressWarnings(\"unused\") LLVMNativeLibrary libA,\n                        LLVMVirtualAllocationAddress b, @SuppressWarnings(\"unused\") LLVMNativeLibrary libB, NativePointerCompare op,\n                        @Cached(\"create()\") @SuppressWarnings(\"unused\") LLVMPointToSameObjectNode pointToSameObject,\n                        @Cached(\"createIgnoreOffset()\") ManagedToComparableValue convertA,\n                        @Cached(\"createIgnoreOffset()\") ManagedToComparableValue convertB) {\n            return op.compare(convertA.executeWithTarget(a), convertB.executeWithTarget(b));\n        }\n        @Specialization(guards = \"libA.isPointer(a)\", rewriteOn = UnsupportedMessageException.class)\n        @SuppressWarnings(\"unused\")\n        protected boolean doNativeManaged(Object a, LLVMNativeLibrary libA, Object b, LLVMNativeLibrary libB, NativePointerCompare op,\n                        @Cached(\"createIgnoreOffset()\") ManagedToComparableValue convert) throws UnsupportedMessageException {\n            return op.compare(libA.asPointer(a), convert.executeWithTarget(b));\n        }\n        @Specialization(guards = \"libB.isPointer(b)\", rewriteOn = UnsupportedMessageException.class)\n        @SuppressWarnings(\"unused\")\n        protected boolean doManagedNative(Object a, LLVMNativeLibrary libA, Object b, LLVMNativeLibrary libB, NativePointerCompare op,\n                        @Cached(\"createIgnoreOffset()\") ManagedToComparableValue convert) throws UnsupportedMessageException {\n            return op.compare(convert.executeWithTarget(a), libB.asPointer(b));\n        }\n        @Specialization(guards = \"libA.isPointer(a) || libB.isPointer(b)\")\n        protected boolean doManagedNativeException(Object a, LLVMNativeLibrary libA, Object b, LLVMNativeLibrary libB, NativePointerCompare op,\n                        @Cached(\"createIgnoreOffset()\") ManagedToComparableValue convert) {\n            try {\n                return op.compare(libA.asPointer(a), convert.executeWithTarget(b));\n            } catch (UnsupportedMessageException e) {\n                try {\n                    return op.compare(convert.executeWithTarget(a), libB.asPointer(b));\n                } catch (UnsupportedMessageException ex) {\n                    return op.compare(convert.executeWithTarget(a), convert.executeWithTarget(b));\n                }\n            }\n        }\n    }\n    public abstract static class LLVMPointToSameObjectNode extends LLVMNode {\n        public abstract boolean execute(Object a, Object b);\n        @Specialization\n        protected boolean pointToSameObjectCached(LLVMManagedPointer a, LLVMManagedPointer b,\n                        @Cached(\"create()\") LLVMObjectEqualsNode equalsNode) {\n            return equalsNode.execute(a.getObject(), b.getObject());\n        }\n        @Specialization\n        protected boolean pointToSameObject(LLVMVirtualAllocationAddress a, LLVMVirtualAllocationAddress b) {\n            return a.getObject() == b.getObject();\n        }\n        @TruffleBoundary\n        public static LLVMPointToSameObjectNode create() {\n            return LLVMPointToSameObjectNodeGen.create();\n        }\n    }\n    /**\n     * Uses an inline cache to devirtualize the virtual call to equals.\n     */\n    public abstract static class LLVMObjectEqualsNode extends LLVMNode {\n        public abstract boolean execute(Object a, Object b);\n        @Specialization(guards = \"cachedClassA == getObjectClass(a)\")\n        protected boolean pointToSameForeignObjectCached(LLVMTypedForeignObject a, LLVMTypedForeignObject b,\n                        @Cached(\"getObjectClass(a)\") Class<?> cachedClassA) {\n            return CompilerDirectives.castExact(a.getForeign(), cachedClassA).equals(b.getForeign());\n        }\n        @Specialization(replaces = \"pointToSameForeignObjectCached\")\n        protected boolean pointToSameForeignObject(LLVMTypedForeignObject a, LLVMTypedForeignObject b) {\n            return a.equals(b);\n        }\n        @Specialization(guards = \"!isTypedForeignObject(a)\")\n        protected boolean pointToDifferentObjects(@SuppressWarnings(\"unused\") Object a, @SuppressWarnings(\"unused\") LLVMTypedForeignObject b) {\n            return false;\n        }\n        @Specialization(guards = \"!isTypedForeignObject(b)\")\n        protected boolean pointToDifferentObjects(@SuppressWarnings(\"unused\") LLVMTypedForeignObject a, @SuppressWarnings(\"unused\") Object b) {\n            return false;\n        }\n        @Specialization\n        protected boolean pointToSameDynamicObject(DynamicObject a, DynamicObject b) {\n            // workaround for Graal issue GR-12757 - this removes the redundant checks from the\n            // compiler graph\n            return a.equals(b);\n        }\n        @Specialization(guards = {\"!isTypedForeignObject(a)\", \"!isTypedForeignObject(b)\", \"cachedClass == a.getClass()\"}, replaces = \"pointToSameDynamicObject\")\n        protected boolean pointToSameObjectCached(Object a, Object b,\n                        @Cached(\"a.getClass()\") Class<?> cachedClass) {\n            return CompilerDirectives.castExact(a, cachedClass).equals(b);\n        }\n        protected static Class<?> getObjectClass(LLVMTypedForeignObject foreignObject) {\n            return foreignObject.getForeign().getClass();\n        }\n        protected static boolean isTypedForeignObject(Object object) {\n            return object instanceof LLVMTypedForeignObject;\n        }\n    }\n    @NodeChild(type = LLVMExpressionNode.class)\n    @NodeChild(type = LLVMExpressionNode.class)\n    public abstract static class LLVMNegateNode extends LLVMAbstractCompareNode {\n        @Child private LLVMAbstractCompareNode booleanExpression;\n<fim_suffix>        LLVMNegateNode(LLVMAbstractCompareNode booleanExpression) {\n            this.booleanExpression = booleanExpression;\n        }<fim_middle>// function below has no smell\n"}