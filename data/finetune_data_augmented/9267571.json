{"text": "<fim_prefix>            }\n            return xis;\n        }\n        else if (val instanceof InputSource) {\n            return saxToXMLInputSource((InputSource) val);\n        }\n        else if (val instanceof InputStream) {\n            return new XMLInputSource(null, null, null,\n                    (InputStream) val, null);\n        }\n        else if (val instanceof File) {\n            File file = (File) val;\n            InputStream is = null;\n            try {\n                is = new BufferedInputStream(new FileInputStream(file));\n            } catch (FileNotFoundException ex) {\n                fErrorReporter.reportError(XSMessageFormatter.SCHEMA_DOMAIN,\n                        \"schema_reference.4\", new Object[] { file.toString() },\n                        XMLErrorReporter.SEVERITY_ERROR);\n            }\n            return new XMLInputSource(null, file.toURI().toString(), null, is, null);\n        }\n        MessageFormatter mf = fErrorReporter.getMessageFormatter(XSMessageFormatter.SCHEMA_DOMAIN);\n        throw new XMLConfigurationException(\n                Status.NOT_SUPPORTED,\n                mf.formatMessage(fErrorReporter.getLocale(), \"jaxp12-schema-source-type.1\",\n                new Object [] {val != null ? val.getClass().getName() : \"null\"}));\n    }\n    //Convert a SAX InputSource to an equivalent XNI XMLInputSource\n    private static XMLInputSource saxToXMLInputSource(InputSource sis) {\n        String publicId = sis.getPublicId();\n        String systemId = sis.getSystemId();\n        Reader charStream = sis.getCharacterStream();\n        if (charStream != null) {\n            return new XMLInputSource(publicId, systemId, null, charStream,\n                    null);\n        }\n        InputStream byteStream = sis.getByteStream();\n        if (byteStream != null) {\n            return new XMLInputSource(publicId, systemId, null, byteStream,\n                    sis.getEncoding());\n        }\n        return new XMLInputSource(publicId, systemId, null, false);\n    }\n    public static class LocationArray{\n        int length ;\n        String [] locations = new String[2];\n        public void resize(int oldLength , int newLength){\n            String [] temp = new String[newLength] ;\n            System.arraycopy(locations, 0, temp, 0, Math.min(oldLength, newLength));\n            locations = temp ;\n            length = Math.min(oldLength, newLength);\n        }\n        public void addLocation(String location){\n            if(length >= locations.length ){\n                resize(length, Math.max(1, length*2));\n            }\n            locations[length++] = location;\n        }//setLocation()\n        public String [] getLocationArray(){\n            if(length < locations.length ){\n                resize(locations.length, length);\n            }\n            return locations;\n        }//getLocationArray()\n        public String getFirstLocation(){\n            return length > 0 ? locations[0] : null;\n        }\n        public int getLength(){\n            return length ;\n        }\n    } //locationArray\n    /* (non-Javadoc)\n     * @see com.sun.org.apache.xerces.internal.xni.parser.XMLComponent#getFeatureDefault(java.lang.String)\n     */\n    public Boolean getFeatureDefault(String featureId) {\n        if (featureId.equals(AUGMENT_PSVI)){\n            return Boolean.TRUE;\n        }\n        return null;\n    }\n    /* (non-Javadoc)\n     * @see com.sun.org.apache.xerces.internal.xni.parser.XMLComponent#getPropertyDefault(java.lang.String)\n     */\n    public Object getPropertyDefault(String propertyId) {\n        // TODO Auto-generated method stub\n        return null;\n    }\n    /* (non-Javadoc)\n     * @see com.sun.org.apache.xerces.internal.xni.parser.XMLComponent#reset(com.sun.org.apache.xerces.internal.xni.parser.XMLComponentManager)\n     */\n<fim_suffix>    public void reset(XMLComponentManager componentManager) throws XMLConfigurationException {\n        XMLSecurityPropertyManager spm = (XMLSecurityPropertyManager)componentManager.getProperty(XML_SECURITY_PROPERTY_MANAGER);\n        if (spm == null) {\n            spm = new XMLSecurityPropertyManager();\n            setProperty(XML_SECURITY_PROPERTY_MANAGER, spm);\n        }\n        XMLSecurityManager sm = (XMLSecurityManager)componentManager.getProperty(SECURITY_MANAGER);\n        if (sm == null)\n            setProperty(SECURITY_MANAGER,new XMLSecurityManager(true));\n        faccessExternalSchema = spm.getValue(XMLSecurityPropertyManager.Property.ACCESS_EXTERNAL_SCHEMA);\n        fGrammarBucket.reset();\n        fSubGroupHandler.reset();\n        boolean parser_settings = true;\n        // If the component manager is the loader config don't bother querying it since it doesn't\n        // recognize the PARSER_SETTINGS feature. Prevents an XMLConfigurationException from being\n        // thrown.\n        if (componentManager != fLoaderConfig) {\n            parser_settings = componentManager.getFeature(PARSER_SETTINGS, true);\n        }\n        if (!parser_settings || !fSettingsChanged){\n            // need to reprocess JAXP schema sources\n            fJAXPProcessed = false;\n            // reinitialize grammar bucket\n            initGrammarBucket();\n            if (fDeclPool != null) {\n                fDeclPool.reset();\n            }\n            return;\n        }\n        //pass the component manager to the factory..\n        fNodeFactory.reset(componentManager);\n        // get registered entity manager to be able to resolve JAXP schema-source property:\n        // Note: in case XMLSchemaValidator has created the loader,\n        // the entity manager property is null\n        fEntityManager = (XMLEntityManager)componentManager.getProperty(ENTITY_MANAGER);\n        // get the error reporter\n        fErrorReporter = (XMLErrorReporter)componentManager.getProperty(ERROR_REPORTER);\n        // Determine schema dv factory to use\n        SchemaDVFactory dvFactory = null;\n        dvFactory = fSchemaHandler.getDVFactory();\n        if (dvFactory == null) {\n            dvFactory = SchemaDVFactory.getInstance();\n            fSchemaHandler.setDVFactory(dvFactory);\n        }\n        // get schema location properties\n        try {\n            fExternalSchemas = (String) componentManager.getProperty(SCHEMA_LOCATION);\n            fExternalNoNSSchema = (String) componentManager.getProperty(SCHEMA_NONS_LOCATION);\n        } catch (XMLConfigurationException e) {\n            fExternalSchemas = null;\n            fExternalNoNSSchema = null;\n        }\n        // get JAXP sources if available\n        fJAXPSource = componentManager.getProperty(JAXP_SCHEMA_SOURCE, null);\n        fJAXPProcessed = false;\n        // clear grammars, and put the one for schema namespace there\n        fGrammarPool = (XMLGrammarPool) componentManager.getProperty(XMLGRAMMAR_POOL, null);\n        initGrammarBucket();\n        boolean psvi = componentManager.getFeature(AUGMENT_PSVI, false);\n        // Only use the decl pool when there is no chance that the schema\n        // components will be exposed or cached.\n        // TODO: when someone calls loadGrammar(XMLInputSource), the schema is\n        // always exposed even without the use of a grammar pool.\n        // Disabling the \"decl pool\" feature for now until we understand when\n        // it can be safely used.\n        if (!psvi && fGrammarPool == null && false) {\n            if (fDeclPool != null) {\n                fDeclPool.reset();\n            }\n            else {\n                fDeclPool = new XSDeclarationPool();\n            }\n            fCMBuilder.setDeclPool(fDeclPool);\n            fSchemaHandler.setDeclPool(fDeclPool);\n            if (dvFactory instanceof SchemaDVFactoryImpl) {\n                fDeclPool.setDVFactory((SchemaDVFactoryImpl)dvFactory);\n                ((SchemaDVFactoryImpl)dvFactory).setDeclPool(fDeclPool);\n            }\n        } else {\n            fCMBuilder.setDeclPool(null);\n            fSchemaHandler.setDeclPool(null);\n            if (dvFactory instanceof SchemaDVFactoryImpl) {\n                ((SchemaDVFactoryImpl)dvFactory).setDeclPool(null);\n            }\n        }\n        // get continue-after-fatal-error feature\n        try {\n            boolean fatalError = componentManager.getFeature(CONTINUE_AFTER_FATAL_ERROR, false);\n            if (!fatalError) {\n                fErrorReporter.setFeature(CONTINUE_AFTER_FATAL_ERROR, fatalError);\n            }\n        } catch (XMLConfigurationException e) {\n        }\n        // set full validation to false\n        fIsCheckedFully = componentManager.getFeature(SCHEMA_FULL_CHECKING, false);\n        // get generate-synthetic-annotations feature\n        fSchemaHandler.setGenerateSyntheticAnnotations(componentManager.getFeature(GENERATE_SYNTHETIC_ANNOTATIONS, false));\n        fSchemaHandler.reset(componentManager);\n    }<fim_middle>// function below is long method\n"}