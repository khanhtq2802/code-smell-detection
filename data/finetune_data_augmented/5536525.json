{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.samza.operators.impl;\n\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport org.apache.samza.system.EndOfStreamMessage;\nimport org.apache.samza.system.SystemStream;\nimport org.apache.samza.system.SystemStreamPartition;\n\n\n/**\n * This class manages the end-of-stream state of the streams in a task. Internally it keeps track of end-of-stream\n * messages received from upstream tasks for each system stream partition (ssp). If messages have been received from\n * all tasks, it will mark the ssp as end-of-stream. For a stream to be end-of-stream, all its partitions assigned to\n * the task need to be end-of-stream.\n *\n * This class is thread-safe.\n */\nclass EndOfStreamStates {\n\n<fim_suffix>  private static final class EndOfStreamState {\n    // set of upstream tasks\n    private final Set<String> tasks = new HashSet<>();\n    private final int expectedTotal;\n    private volatile boolean isEndOfStream = false;\n\n    EndOfStreamState(int expectedTotal) {\n      this.expectedTotal = expectedTotal;\n    }\n\n    synchronized void update(String taskName) {\n      if (taskName != null) {\n        // aggregate the eos messages\n        tasks.add(taskName);\n        isEndOfStream = tasks.size() == expectedTotal;\n      } else {\n        // eos is coming from either source or aggregator task\n        isEndOfStream = true;\n      }\n    }\n\n    boolean isEndOfStream() {\n      return isEndOfStream;\n    }\n  }\n\n  private final Map<SystemStreamPartition, EndOfStreamState> eosStates;\n\n  /**\n   * Constructing the end-of-stream states for a task\n   * @param ssps all the ssps assigned to this task\n   * @param producerTaskCounts mapping from a stream to the number of upstream tasks that produce to it\n   */\n  EndOfStreamStates(Set<SystemStreamPartition> ssps, Map<SystemStream, Integer> producerTaskCounts) {\n    Map<SystemStreamPartition, EndOfStreamState> states = new HashMap<>();\n    ssps.forEach(ssp -> {\n        states.put(ssp, new EndOfStreamState(producerTaskCounts.getOrDefault(ssp.getSystemStream(), 0)));\n      });\n    this.eosStates = Collections.unmodifiableMap(states);\n  }\n\n  /**\n   * Update the state upon receiving an end-of-stream message.\n   * @param eos message of {@link EndOfStreamMessage}\n   * @param ssp system stream partition\n   */\n  void update(EndOfStreamMessage eos, SystemStreamPartition ssp) {\n    EndOfStreamState state = eosStates.get(ssp);\n    state.update(eos.getTaskName());\n  }\n\n  boolean isEndOfStream(SystemStream systemStream) {\n    return eosStates.entrySet().stream()\n        .filter(entry -> entry.getKey().getSystemStream().equals(systemStream))\n        .allMatch(entry -> entry.getValue().isEndOfStream());\n  }\n\n  boolean allEndOfStream() {\n    return eosStates.values().stream().allMatch(EndOfStreamState::isEndOfStream);\n  }\n}<fim_middle>// class below has no smell\n"}