{"text": "<fim_prefix>      switch (node.getKind()) {\n      case AND:\n      case OR:\n        operands = ((RexCall) node).getOperands();\n        for (RexNode operand : operands) {\n          if (!canJoinOnCondition(operand)) {\n            return false;\n          }\n        }\n        return true;\n      case EQUALS:\n      case IS_NOT_DISTINCT_FROM:\n      case NOT_EQUALS:\n      case GREATER_THAN:\n      case GREATER_THAN_OR_EQUAL:\n      case LESS_THAN:\n      case LESS_THAN_OR_EQUAL:\n        operands = ((RexCall) node).getOperands();\n        if ((operands.get(0) instanceof RexInputRef)\n            && (operands.get(1) instanceof RexInputRef)) {\n          return true;\n        }\n        // fall through\n      default:\n        return false;\n      }\n    }\n  }\n  /** Join operator implemented in JDBC convention. */\n  public static class JdbcJoin extends Join implements JdbcRel {\n    /** Creates a JdbcJoin. */\n    public JdbcJoin(RelOptCluster cluster, RelTraitSet traitSet,\n        RelNode left, RelNode right, RexNode condition,\n        Set<CorrelationId> variablesSet, JoinRelType joinType)\n        throws InvalidRelException {\n      super(cluster, traitSet, left, right, condition, variablesSet, joinType);\n    }\n    @Deprecated // to be removed before 2.0\n    protected JdbcJoin(\n        RelOptCluster cluster,\n        RelTraitSet traitSet,\n        RelNode left,\n        RelNode right,\n        RexNode condition,\n        JoinRelType joinType,\n        Set<String> variablesStopped)\n        throws InvalidRelException {\n      this(cluster, traitSet, left, right, condition,\n          CorrelationId.setOf(variablesStopped), joinType);\n    }\n    @Override public JdbcJoin copy(RelTraitSet traitSet, RexNode condition,\n        RelNode left, RelNode right, JoinRelType joinType,\n        boolean semiJoinDone) {\n      try {\n        return new JdbcJoin(getCluster(), traitSet, left, right,\n            condition, variablesSet, joinType);\n      } catch (InvalidRelException e) {\n        // Semantic error not possible. Must be a bug. Convert to\n        // internal error.\n        throw new AssertionError(e);\n      }\n    }\n    @Override public RelOptCost computeSelfCost(RelOptPlanner planner,\n        RelMetadataQuery mq) {\n      // We always \"build\" the\n      double rowCount = mq.getRowCount(this);\n      return planner.getCostFactory().makeCost(rowCount, 0, 0);\n    }\n    @Override public double estimateRowCount(RelMetadataQuery mq) {\n      final double leftRowCount = left.estimateRowCount(mq);\n      final double rightRowCount = right.estimateRowCount(mq);\n      return Math.max(leftRowCount, rightRowCount);\n    }\n    public JdbcImplementor.Result implement(JdbcImplementor implementor) {\n      return implementor.implement(this);\n    }\n  }\n  /**\n   * Rule to convert a {@link org.apache.calcite.rel.core.Calc} to an\n   * {@link org.apache.calcite.adapter.jdbc.JdbcRules.JdbcCalc}.\n   */\n  private static class JdbcCalcRule extends JdbcConverterRule {\n    /** Creates a JdbcCalcRule. */\n    private JdbcCalcRule(JdbcConvention out,\n        RelBuilderFactory relBuilderFactory) {\n      super(Calc.class, (Predicate<RelNode>) r -> true, Convention.NONE,\n          out, relBuilderFactory, \"JdbcCalcRule\");\n    }\n    public RelNode convert(RelNode rel) {\n      final Calc calc = (Calc) rel;\n      // If there's a multiset, let FarragoMultisetSplitter work on it\n      // first.\n      if (RexMultisetUtil.containsMultiset(calc.getProgram())) {\n        return null;\n      }\n      return new JdbcCalc(rel.getCluster(), rel.getTraitSet().replace(out),\n          convert(calc.getInput(), calc.getTraitSet().replace(out)),\n          calc.getProgram());\n    }\n  }\n  /** Calc operator implemented in JDBC convention.\n   *\n   * @see org.apache.calcite.rel.core.Calc */\n  public static class JdbcCalc extends SingleRel implements JdbcRel {\n    private final RexProgram program;\n    public JdbcCalc(RelOptCluster cluster,\n        RelTraitSet traitSet,\n        RelNode input,\n        RexProgram program) {\n      super(cluster, traitSet, input);\n      assert getConvention() instanceof JdbcConvention;\n      this.program = program;\n      this.rowType = program.getOutputRowType();\n    }\n    @Deprecated // to be removed before 2.0\n    public JdbcCalc(RelOptCluster cluster, RelTraitSet traitSet, RelNode input,\n        RexProgram program, int flags) {\n      this(cluster, traitSet, input, program);\n      Util.discard(flags);\n    }\n    public RelWriter explainTerms(RelWriter pw) {\n      return program.explainCalc(super.explainTerms(pw));\n    }\n    @Override public double estimateRowCount(RelMetadataQuery mq) {\n      return RelMdUtil.estimateFilteredRows(getInput(), program, mq);\n    }\n    public RelOptCost computeSelfCost(RelOptPlanner planner,\n        RelMetadataQuery mq) {\n      double dRows = mq.getRowCount(this);\n      double dCpu = mq.getRowCount(getInput())\n          * program.getExprCount();\n      double dIo = 0;\n      return planner.getCostFactory().makeCost(dRows, dCpu, dIo);\n    }\n    public RelNode copy(RelTraitSet traitSet, List<RelNode> inputs) {\n      return new JdbcCalc(getCluster(), traitSet, sole(inputs), program);\n    }\n    public JdbcImplementor.Result implement(JdbcImplementor implementor) {\n      return implementor.implement(this);\n    }\n  }\n  /**\n   * Rule to convert a {@link org.apache.calcite.rel.core.Project} to\n   * an {@link org.apache.calcite.adapter.jdbc.JdbcRules.JdbcProject}.\n   */\n  public static class JdbcProjectRule extends JdbcConverterRule {\n    @Deprecated // to be removed before 2.0\n    public JdbcProjectRule(final JdbcConvention out) {\n      this(out, RelFactories.LOGICAL_BUILDER);\n    }\n    /** Creates a JdbcProjectRule. */\n    public JdbcProjectRule(final JdbcConvention out,\n        RelBuilderFactory relBuilderFactory) {\n      super(Project.class, (Predicate<Project>) project ->\n              (out.dialect.supportsWindowFunctions()\n                  || !RexOver.containsOver(project.getProjects(), null))\n                  && !userDefinedFunctionInProject(project),\n          Convention.NONE, out, relBuilderFactory, \"JdbcProjectRule\");\n    }\n    private static boolean userDefinedFunctionInProject(Project project) {\n      CheckingUserDefinedFunctionVisitor visitor = new CheckingUserDefinedFunctionVisitor();\n      for (RexNode node : project.getChildExps()) {\n        node.accept(visitor);\n        if (visitor.containsUserDefinedFunction()) {\n          return true;\n        }\n      }\n      return false;\n    }\n    public RelNode convert(RelNode rel) {\n      final Project project = (Project) rel;\n      return new JdbcProject(\n          rel.getCluster(),\n          rel.getTraitSet().replace(out),\n          convert(\n              project.getInput(),\n              project.getInput().getTraitSet().replace(out)),\n          project.getProjects(),\n          project.getRowType());\n    }\n  }\n  /** Implementation of {@link org.apache.calcite.rel.core.Project} in\n   * {@link JdbcConvention jdbc calling convention}. */\n  public static class JdbcProject\n      extends Project\n      implements JdbcRel {\n    public JdbcProject(\n        RelOptCluster cluster,\n        RelTraitSet traitSet,\n        RelNode input,\n        List<? extends RexNode> projects,\n        RelDataType rowType) {\n      super(cluster, traitSet, input, projects, rowType);\n      assert getConvention() instanceof JdbcConvention;\n    }\n    @Deprecated // to be removed before 2.0\n    public JdbcProject(RelOptCluster cluster, RelTraitSet traitSet,\n        RelNode input, List<RexNode> projects, RelDataType rowType, int flags) {\n      this(cluster, traitSet, input, projects, rowType);\n      Util.discard(flags);\n    }\n    @Override public JdbcProject copy(RelTraitSet traitSet, RelNode input,\n        List<RexNode> projects, RelDataType rowType) {\n      return new JdbcProject(getCluster(), traitSet, input, projects, rowType);\n    }\n<fim_suffix>    @Override public RelOptCost computeSelfCost(RelOptPlanner planner,\n        RelMetadataQuery mq) {\n      return super.computeSelfCost(planner, mq)\n          .multiplyBy(JdbcConvention.COST_MULTIPLIER);\n    }<fim_middle>// function below has no smell\n"}