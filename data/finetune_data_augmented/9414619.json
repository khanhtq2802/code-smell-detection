{"text": "<fim_prefix>        }\n        if(widenRetDelta > 0) {\n            return false;\n        }\n        // Prefer function that returns a less narrow return type\n        final int narrowRetDelta = Math.max(-thisRetWeightDelta, 0) - Math.max(-otherRetWeightDelta, 0);\n        if(narrowRetDelta < 0) {\n            return true;\n        }\n        if(narrowRetDelta > 0) {\n            return false;\n        }\n        //if they are equal, pick the specialized one first\n        if (cf.isSpecialization() != other.isSpecialization()) {\n            return cf.isSpecialization(); //always pick the specialized version if we can\n        }\n        if (cf.isSpecialization() && other.isSpecialization()) {\n            return cf.getLinkLogicClass() != null; //pick link logic specialization above generic specializations\n        }\n        // Signatures are identical\n        throw new AssertionError(thisMethodType + \" identically applicable to \" + otherMethodType + \" for \" + callSiteMethodType);\n    }\n    private static Type[] toTypeWithoutCallee(final MethodType type, final int thisIndex) {\n        final int paramCount = type.parameterCount();\n        final Type[] t = new Type[paramCount - thisIndex];\n        for(int i = thisIndex; i < paramCount; ++i) {\n            t[i - thisIndex] = Type.typeFor(type.parameterType(i));\n        }\n        return t;\n    }\n    private static Type getParamType(final int i, final Type[] paramTypes, final boolean isVarArg) {\n        final int fixParamCount = paramTypes.length - (isVarArg ? 1 : 0);\n        if(i < fixParamCount) {\n            return paramTypes[i];\n        }\n        assert isVarArg;\n        return ((ArrayType)paramTypes[paramTypes.length - 1]).getElementType();\n    }\n    boolean matchesCallSite(final MethodType other, final boolean pickVarArg) {\n        if (other.equals(this.callSiteType)) {\n            return true;\n        }\n        final MethodType type  = type();\n        final int fnParamCount = getParamCount(type);\n        final boolean isVarArg = fnParamCount == Integer.MAX_VALUE;\n        if (isVarArg) {\n            return pickVarArg;\n        }\n        final int csParamCount = getParamCount(other);\n        final boolean csIsVarArg = csParamCount == Integer.MAX_VALUE;\n        if (csIsVarArg && isApplyToCall()) {\n            return false; // apply2call function must be called with exact number of parameters\n        }\n        final int thisThisIndex = needsCallee() ? 1 : 0; // Index of \"this\" parameter in this function's type\n        final int fnParamCountNoCallee = fnParamCount - thisThisIndex;\n        final int minParams = Math.min(csParamCount - 1, fnParamCountNoCallee); // callSiteType always has callee, so subtract 1\n        // We must match all incoming parameters, including \"this\". \"this\" will usually be Object, but there\n        // are exceptions, e.g. when calling functions with primitive \"this\" in strict mode or through call/apply.\n        for(int i = 0; i < minParams; ++i) {\n            final Type fnType = Type.typeFor(type.parameterType(i + thisThisIndex));\n            final Type csType = csIsVarArg ? Type.OBJECT : Type.typeFor(other.parameterType(i + 1));\n            if(!fnType.isEquivalentTo(csType)) {\n                return false;\n            }\n        }\n        // Must match any undefined parameters to Object type.\n        for(int i = minParams; i < fnParamCountNoCallee; ++i) {\n            if(!Type.typeFor(type.parameterType(i + thisThisIndex)).isEquivalentTo(Type.OBJECT)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private static int getParamCount(final MethodType type) {\n        final int paramCount = type.parameterCount();\n        return type.parameterType(paramCount - 1).isArray() ? Integer.MAX_VALUE : paramCount;\n    }\n    private boolean canBeDeoptimized() {\n        return optimismInfo != null;\n    }\n    private MethodHandle createComposableInvoker(final boolean isConstructor) {\n        final MethodHandle handle = getInvokerOrConstructor(isConstructor);\n        // If compiled function is not optimistic, it can't ever change its invoker/constructor, so just return them\n        // directly.\n        if(!canBeDeoptimized()) {\n            return handle;\n        }\n        // Otherwise, we need a new level of indirection; need to introduce a mutable call site that can relink itself\n        // to the compiled function's changed target whenever the optimistic assumptions are invalidated.\n        final CallSite cs = new MutableCallSite(handle.type());\n        relinkComposableInvoker(cs, this, isConstructor);\n        return cs.dynamicInvoker();\n    }\n    private static class HandleAndAssumptions {\n        final MethodHandle handle;\n        final SwitchPoint assumptions;\n        HandleAndAssumptions(final MethodHandle handle, final SwitchPoint assumptions) {\n            this.handle = handle;\n            this.assumptions = assumptions;\n        }\n        GuardedInvocation createInvocation() {\n            return new GuardedInvocation(handle, assumptions);\n        }\n    }\n    /**\n     * Returns a pair of an invocation created with a passed-in supplier and a non-invalidated switch point for\n     * optimistic assumptions (or null for the switch point if the function can not be deoptimized). While the method\n     * makes a best effort to return a non-invalidated switch point (compensating for possible deoptimizing\n     * recompilation happening on another thread) it is still possible that by the time this method returns the\n     * switchpoint has been invalidated by a {@code RewriteException} triggered on another thread for this function.\n     * This is not a problem, though, as these switch points are always used to produce call sites that fall back to\n     * relinking when they are invalidated, and in this case the execution will end up here again. What this method\n     * basically does is minimize such busy-loop relinking while the function is being recompiled on a different thread.\n     * @param invocationSupplier the supplier that constructs the actual invocation method handle; should use the\n     * {@code CompiledFunction} method itself in some capacity.\n     * @return a tuple object containing the method handle as created by the supplier and an optimistic assumptions\n     * switch point that is guaranteed to not have been invalidated before the call to this method (or null if the\n     * function can't be further deoptimized).\n     */\n    private synchronized HandleAndAssumptions getValidOptimisticInvocation(final Supplier<MethodHandle> invocationSupplier) {\n        for(;;) {\n            final MethodHandle handle = invocationSupplier.get();\n            final SwitchPoint assumptions = canBeDeoptimized() ? optimismInfo.optimisticAssumptions : null;\n            if(assumptions != null && assumptions.hasBeenInvalidated()) {\n                // We can be in a situation where one thread is in the middle of a deoptimizing compilation when we hit\n                // this and thus, it has invalidated the old switch point, but hasn't created the new one yet. Note that\n                // the behavior of invalidating the old switch point before recompilation, and only creating the new one\n                // after recompilation is by design. If we didn't wait here for the recompilation to complete, we would\n                // be busy looping through the fallback path of the invalidated switch point, relinking the call site\n                // again with the same invalidated switch point, invoking the fallback, etc. stealing CPU cycles from\n                // the recompilation task we're dependent on. This can still happen if the switch point gets invalidated\n                // after we grabbed it here, in which case we'll indeed do one busy relink immediately.\n                try {\n                    wait();\n                } catch (final InterruptedException e) {\n                    // Intentionally ignored. There's nothing meaningful we can do if we're interrupted\n                }\n            } else {\n                return new HandleAndAssumptions(handle, assumptions);\n            }\n        }\n    }\n<fim_suffix>    private static void relinkComposableInvoker(final CallSite cs, final CompiledFunction inv, final boolean constructor) {\n        final HandleAndAssumptions handleAndAssumptions = inv.getValidOptimisticInvocation(new Supplier<MethodHandle>() {\n            @Override\n            public MethodHandle get() {\n                return inv.getInvokerOrConstructor(constructor);\n            }\n        });\n        final MethodHandle handle = handleAndAssumptions.handle;\n        final SwitchPoint assumptions = handleAndAssumptions.assumptions;\n        final MethodHandle target;\n        if(assumptions == null) {\n            target = handle;\n        } else {\n            final MethodHandle relink = MethodHandles.insertArguments(RELINK_COMPOSABLE_INVOKER, 0, cs, inv, constructor);\n            target = assumptions.guardWithTest(handle, MethodHandles.foldArguments(cs.dynamicInvoker(), relink));\n        }\n        cs.setTarget(target.asType(cs.type()));\n    }<fim_middle>// function below has no smell\n"}