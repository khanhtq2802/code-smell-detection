{"text": "<fim_prefix>    private final List<Mutation> mutations = new ArrayList<>();\n    private int mutationsSize = 0; // Accumulated size of protos in mutations.\n    private WriteBatcher writeBatcher;\n    private transient AdaptiveThrottler throttler;\n    private final Counter throttledSeconds =\n        Metrics.counter(DatastoreWriterFn.class, \"cumulativeThrottlingSeconds\");\n    private final Counter rpcErrors =\n        Metrics.counter(DatastoreWriterFn.class, \"datastoreRpcErrors\");\n    private final Counter rpcSuccesses =\n        Metrics.counter(DatastoreWriterFn.class, \"datastoreRpcSuccesses\");\n    private static final int MAX_RETRIES = 5;\n    private static final FluentBackoff BUNDLE_WRITE_BACKOFF =\n        FluentBackoff.DEFAULT\n            .withMaxRetries(MAX_RETRIES)\n            .withInitialBackoff(Duration.standardSeconds(5));\n    DatastoreWriterFn(String projectId, @Nullable String localhost) {\n      this(\n          StaticValueProvider.of(projectId),\n          localhost,\n          new V1DatastoreFactory(),\n          new WriteBatcherImpl());\n    }\n    DatastoreWriterFn(ValueProvider<String> projectId, @Nullable String localhost) {\n      this(projectId, localhost, new V1DatastoreFactory(), new WriteBatcherImpl());\n    }\n    @VisibleForTesting\n    DatastoreWriterFn(\n        ValueProvider<String> projectId,\n        @Nullable String localhost,\n        V1DatastoreFactory datastoreFactory,\n        WriteBatcher writeBatcher) {\n      this.projectId = checkNotNull(projectId, \"projectId\");\n      this.localhost = localhost;\n      this.datastoreFactory = datastoreFactory;\n      this.writeBatcher = writeBatcher;\n    }\n    @StartBundle\n    public void startBundle(StartBundleContext c) {\n      datastore = datastoreFactory.getDatastore(c.getPipelineOptions(), projectId.get(), localhost);\n      writeBatcher.start();\n      if (throttler == null) {\n        // Initialize throttler at first use, because it is not serializable.\n        throttler = new AdaptiveThrottler(120000, 10000, 1.25);\n      }\n    }\n    @ProcessElement\n    public void processElement(ProcessContext c) throws Exception {\n      Mutation write = c.element();\n      int size = write.getSerializedSize();\n      if (mutations.size() > 0\n          && mutationsSize + size >= DatastoreV1.DATASTORE_BATCH_UPDATE_BYTES_LIMIT) {\n        flushBatch();\n      }\n      mutations.add(c.element());\n      mutationsSize += size;\n      if (mutations.size() >= writeBatcher.nextBatchSize(System.currentTimeMillis())) {\n        flushBatch();\n      }\n    }\n    @FinishBundle\n    public void finishBundle() throws Exception {\n      if (!mutations.isEmpty()) {\n        flushBatch();\n      }\n    }\n    /**\n     * Writes a batch of mutations to Cloud Datastore.\n     *\n     * <p>If a commit fails, it will be retried up to {@link #MAX_RETRIES} times. All mutations in\n     * the batch will be committed again, even if the commit was partially successful. If the retry\n     * limit is exceeded, the last exception from Cloud Datastore will be thrown.\n     *\n     * @throws DatastoreException if the commit fails or IOException or InterruptedException if\n     *     backing off between retries fails.\n     */\n    private void flushBatch() throws DatastoreException, IOException, InterruptedException {\n      LOG.debug(\"Writing batch of {} mutations\", mutations.size());\n      Sleeper sleeper = Sleeper.DEFAULT;\n      BackOff backoff = BUNDLE_WRITE_BACKOFF.backoff();\n      while (true) {\n        // Batch upsert entities.\n        CommitRequest.Builder commitRequest = CommitRequest.newBuilder();\n        commitRequest.addAllMutations(mutations);\n        commitRequest.setMode(CommitRequest.Mode.NON_TRANSACTIONAL);\n        long startTime = System.currentTimeMillis(), endTime;\n        if (throttler.throttleRequest(startTime)) {\n          LOG.info(\"Delaying request due to previous failures\");\n          throttledSeconds.inc(WriteBatcherImpl.DATASTORE_BATCH_TARGET_LATENCY_MS / 1000);\n          sleeper.sleep(WriteBatcherImpl.DATASTORE_BATCH_TARGET_LATENCY_MS);\n          continue;\n        }\n        try {\n          datastore.commit(commitRequest.build());\n          endTime = System.currentTimeMillis();\n          writeBatcher.addRequestLatency(endTime, endTime - startTime, mutations.size());\n          throttler.successfulRequest(startTime);\n          rpcSuccesses.inc();\n          // Break if the commit threw no exception.\n          break;\n        } catch (DatastoreException exception) {\n          if (exception.getCode() == Code.DEADLINE_EXCEEDED) {\n            /* Most errors are not related to request size, and should not change our expectation of\n             * the latency of successful requests. DEADLINE_EXCEEDED can be taken into\n             * consideration, though. */\n            endTime = System.currentTimeMillis();\n            writeBatcher.addRequestLatency(endTime, endTime - startTime, mutations.size());\n          }\n          // Only log the code and message for potentially-transient errors. The entire exception\n          // will be propagated upon the last retry.\n          LOG.error(\n              \"Error writing batch of {} mutations to Datastore ({}): {}\",\n              mutations.size(),\n              exception.getCode(),\n              exception.getMessage());\n          rpcErrors.inc();\n          if (NON_RETRYABLE_ERRORS.contains(exception.getCode())) {\n            throw exception;\n          }\n          if (!BackOffUtils.next(sleeper, backoff)) {\n            LOG.error(\"Aborting after {} retries.\", MAX_RETRIES);\n            throw exception;\n          }\n        }\n      }\n      LOG.debug(\"Successfully wrote {} mutations\", mutations.size());\n      mutations.clear();\n      mutationsSize = 0;\n    }\n    @Override\n    public void populateDisplayData(Builder builder) {\n      super.populateDisplayData(builder);\n      builder.addIfNotNull(DisplayData.item(\"projectId\", projectId).withLabel(\"Output Project\"));\n    }\n  }\n  /**\n   * Returns true if a Cloud Datastore key is complete. A key is complete if its last element has\n   * either an id or a name.\n   */\n  static boolean isValidKey(Key key) {\n    List<PathElement> elementList = key.getPathList();\n    if (elementList.isEmpty()) {\n      return false;\n    }\n    PathElement lastElement = elementList.get(elementList.size() - 1);\n    return (lastElement.getId() != 0 || !lastElement.getName().isEmpty());\n  }\n  /** A function that constructs an upsert {@link Mutation} from an {@link Entity}. */\n  @VisibleForTesting\n  static class UpsertFn extends SimpleFunction<Entity, Mutation> {\n    @Override\n    public Mutation apply(Entity entity) {\n      // Verify that the entity to write has a complete key.\n      checkArgument(\n          isValidKey(entity.getKey()),\n          \"Entities to be written to the Cloud Datastore must have complete keys:\\n%s\",\n          entity);\n      return makeUpsert(entity).build();\n    }\n    @Override\n    public void populateDisplayData(Builder builder) {\n      builder.add(\n          DisplayData.item(\"upsertFn\", this.getClass()).withLabel(\"Create Upsert Mutation\"));\n    }\n  }\n  /** A function that constructs a delete {@link Mutation} from an {@link Entity}. */\n  @VisibleForTesting\n  static class DeleteEntityFn extends SimpleFunction<Entity, Mutation> {\n    @Override\n    public Mutation apply(Entity entity) {\n      // Verify that the entity to delete has a complete key.\n      checkArgument(\n          isValidKey(entity.getKey()),\n          \"Entities to be deleted from the Cloud Datastore must have complete keys:\\n%s\",\n          entity);\n      return makeDelete(entity.getKey()).build();\n    }\n    @Override\n    public void populateDisplayData(Builder builder) {\n      builder.add(\n          DisplayData.item(\"deleteEntityFn\", this.getClass()).withLabel(\"Create Delete Mutation\"));\n    }\n  }\n  /** A function that constructs a delete {@link Mutation} from a {@link Key}. */\n  @VisibleForTesting\n  static class DeleteKeyFn extends SimpleFunction<Key, Mutation> {\n<fim_suffix>    @Override\n    public Mutation apply(Key key) {\n      // Verify that the entity to delete has a complete key.\n      checkArgument(\n          isValidKey(key),\n          \"Keys to be deleted from the Cloud Datastore must be complete:\\n%s\",\n          key);\n      return makeDelete(key).build();\n    }<fim_middle>// function below has no smell\n"}