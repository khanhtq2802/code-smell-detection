{"text": "<fim_prefix>\t\tthis.registeredSerializer = stateSerializer;\n\t\tthis.previousSerializerSnapshot = null;\n\t}\n\tprivate StateSerializerProvider(@Nonnull TypeSerializerSnapshot<T> previousSerializerSnapshot) {\n\t\tthis.previousSerializerSnapshot = previousSerializerSnapshot;\n\t\tthis.registeredSerializer = null;\n\t}\n\t/**\n\t * Gets the serializer that recognizes the current serialization schema of the state.\n\t * This is the serializer that should be used for regular state serialization and\n\t * deserialization after state has been restored.\n\t *\n\t * <p>If this provider was created from a restored state's serializer snapshot, while a\n\t * new serializer (with a new schema) was not registered for the state (i.e., because\n\t * the state was never accessed after it was restored), then the schema of state remains\n\t * identical. Therefore, in this case, it is guaranteed that the serializer returned by\n\t * this method is the same as the one returned by {@link #previousSchemaSerializer()}.\n\t *\n\t * <p>If this provider was created from a serializer instance, then this always returns the\n\t * that same serializer instance. If later on a snapshot of the previous serializer is supplied\n\t * via {@link #setPreviousSerializerSnapshotForRestoredState(TypeSerializerSnapshot)}, then\n\t * the initially supplied serializer instance will be checked for compatibility.\n\t *\n\t * @return a serializer that reads and writes in the current schema of the state.\n\t */\n\t@Nonnull\n\tpublic final TypeSerializer<T> currentSchemaSerializer() {\n\t\tif (registeredSerializer != null) {\n\t\t\tcheckState(\n\t\t\t\t!isRegisteredWithIncompatibleSerializer,\n\t\t\t\t\"Unable to provide a serializer with the current schema, because the restored state was \" +\n\t\t\t\t\t\"registered with a new serializer that has incompatible schema.\");\n\t\t\treturn registeredSerializer;\n\t\t}\n\t\t// if we are not yet registered with a new serializer,\n\t\t// we can just use the restore serializer to read / write the state.\n\t\treturn previousSchemaSerializer();\n\t}\n\t/**\n\t * Gets the serializer that recognizes the previous serialization schema of the state.\n\t * This is the serializer that should be used for restoring the state, i.e. when the state\n\t * is still in the previous serialization schema.\n\t *\n\t * <p>This method only returns a serializer if this provider has the previous serializer's\n\t * snapshot. Otherwise, trying to access the previous schema serializer will fail\n\t * with an exception.\n\t *\n\t * @return a serializer that reads and writes in the previous schema of the state.\n\t */\n\t@Nonnull\n\tpublic final TypeSerializer<T> previousSchemaSerializer() {\n\t\tif (cachedRestoredSerializer != null) {\n\t\t\treturn cachedRestoredSerializer;\n\t\t}\n\t\tif (previousSerializerSnapshot == null) {\n\t\t\tthrow new UnsupportedOperationException(\n\t\t\t\t\"This provider does not contain the state's previous serializer's snapshot. Cannot provider a serializer for previous schema.\");\n\t\t}\n\t\tthis.cachedRestoredSerializer = previousSerializerSnapshot.restoreSerializer();\n\t\treturn cachedRestoredSerializer;\n\t};\n\t/**\n\t * For restored state, register a new serializer that potentially has a new serialization schema.\n\t *\n\t * <p>Users are allowed to register serializers for state only once. Therefore, this method\n\t * is irrelevant if this provider was created with a serializer instance, since a state serializer had\n\t * been registered already.\n\t *\n\t * <p>For the case where this provider was created from a serializer snapshot, then this method should\n\t * be called at most once. The new serializer will be checked for its schema compatibility with the\n\t * previous serializer's schema, and returned to the caller. The caller is responsible for\n\t * checking the result and react appropriately to it, as follows:\n\t * <ul>\n\t *     <li>{@link TypeSerializerSchemaCompatibility#isCompatibleAsIs()}: nothing needs to be done.\n\t *     {@link #currentSchemaSerializer()} now returns the newly registered serializer.</li>\n\t *     <li>{@link TypeSerializerSchemaCompatibility#isCompatibleAfterMigration()} ()}: state needs to be\n\t *     migrated before the serializer returned by {@link #currentSchemaSerializer()} can be used.\n\t *     The migration should be performed by reading the state with {@link #previousSchemaSerializer()},\n\t *     and then writing it again with {@link #currentSchemaSerializer()}.</li>\n\t *     <li>{@link TypeSerializerSchemaCompatibility#isIncompatible()}: the registered serializer is\n\t *     incompatible. {@link #currentSchemaSerializer()} can no longer return a serializer for\n\t *     the state, and therefore this provider shouldn't be used anymore.</li>\n\t * </ul>\n\t *\n\t * @return the schema compatibility of the new registered serializer, with respect to the previous serializer.\n\t */\n\t@Nonnull\n\tpublic abstract TypeSerializerSchemaCompatibility<T> registerNewSerializerForRestoredState(TypeSerializer<T> newSerializer);\n\t/**\n\t * For restored state, set the state's previous serializer's snapshot.\n\t *\n\t * <p>Users are allowed to set the previous serializer's snapshot once. Therefore, this method\n\t * is irrelevant if this provider was created with a serializer snapshot, since the serializer\n\t * snapshot had been set already.\n\t *\n\t * <p>For the case where this provider was created from a serializer instance, then this method should\n\t * be called at most once. The initially registered state serializer will be checked for its\n\t * schema compatibility with the previous serializer's schema, and returned to the caller.\n\t * The caller is responsible for checking the result and react appropriately to it, as follows:\n\t * <ul>\n\t *     <li>{@link TypeSerializerSchemaCompatibility#isCompatibleAsIs()}: nothing needs to be done.\n\t *     {@link #currentSchemaSerializer()} remains to return the initially registered serializer.</li>\n\t *     <li>{@link TypeSerializerSchemaCompatibility#isCompatibleAfterMigration()} ()}: state needs to be\n\t *     migrated before the serializer returned by {@link #currentSchemaSerializer()} can be used.\n\t *     The migration should be performed by reading the state with {@link #previousSchemaSerializer()},\n\t *     and then writing it again with {@link #currentSchemaSerializer()}.</li>\n\t *     <li>{@link TypeSerializerSchemaCompatibility#isIncompatible()}: the registered serializer is\n\t *     incompatible. {@link #currentSchemaSerializer()} can no longer return a serializer for\n\t *     the state, and therefore this provider shouldn't be used anymore.</li>\n\t * </ul>\n\t *\n\t * @param previousSerializerSnapshot the state's previous serializer's snapshot\n\t *\n\t * @return the schema compatibility of the initially registered serializer, with respect to the previous serializer.\n\t */\n\t@Nonnull\n\tpublic abstract TypeSerializerSchemaCompatibility<T> setPreviousSerializerSnapshotForRestoredState(TypeSerializerSnapshot<T> previousSerializerSnapshot);\n\t/**\n\t * Invalidates access to the current schema serializer. This lets {@link #currentSchemaSerializer()}\n\t * fail when invoked.\n\t *\n\t * <p>Access to the current schema serializer should be invalidated by the methods\n\t * {@link #registerNewSerializerForRestoredState(TypeSerializer)} or\n\t * {@link #setPreviousSerializerSnapshotForRestoredState(TypeSerializerSnapshot)}\n\t * once the registered serializer is determined to be incompatible.\n\t */\n\tprotected final void invalidateCurrentSchemaSerializerAccess() {\n\t\tthis.isRegisteredWithIncompatibleSerializer = true;\n\t}\n\t/**\n\t * Implementation of the {@link StateSerializerProvider} for the case where a snapshot of the\n\t * previous serializer is obtained before a new state serializer is registered (hence, the naming \"lazily\" registered).\n\t */\n\tprivate static class LazilyRegisteredStateSerializerProvider<T> extends StateSerializerProvider<T> {\n\t\tLazilyRegisteredStateSerializerProvider(TypeSerializerSnapshot<T> previousSerializerSnapshot) {\n\t\t\tsuper(Preconditions.checkNotNull(previousSerializerSnapshot));\n\t\t}\n\t\t@Nonnull\n\t\t@Override\n\t\t@SuppressWarnings(\"ConstantConditions\")\n\t\tpublic TypeSerializerSchemaCompatibility<T> registerNewSerializerForRestoredState(TypeSerializer<T> newSerializer) {\n\t\t\tcheckNotNull(newSerializer);\n\t\t\tif (registeredSerializer != null) {\n\t\t\t\tthrow new UnsupportedOperationException(\"A serializer has already been registered for the state; re-registration is not allowed.\");\n\t\t\t}\n\t\t\tTypeSerializerSchemaCompatibility<T> result = previousSerializerSnapshot.resolveSchemaCompatibility(newSerializer);\n\t\t\tif (result.isIncompatible()) {\n\t\t\t\tinvalidateCurrentSchemaSerializerAccess();\n\t\t\t}\n\t\t\tif (result.isCompatibleWithReconfiguredSerializer()) {\n\t\t\t\tthis.registeredSerializer = result.getReconfiguredSerializer();\n\t\t\t} else {\n\t\t\t\tthis.registeredSerializer = newSerializer;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n<fim_suffix>\t\t@Nonnull\n\t\t@Override\n\t\tpublic TypeSerializerSchemaCompatibility<T> setPreviousSerializerSnapshotForRestoredState(\n\t\t\t\tTypeSerializerSnapshot<T> previousSerializerSnapshot) {\n\t\t\tthrow new UnsupportedOperationException(\"The snapshot of the state's previous serializer has already been set; cannot reset.\");\n\t\t}<fim_middle>// function below has no smell\n"}