{"text": "<fim_prefix>/**\n * @author Jacek Ambroziak\n * @author Santiago Pericas-Geertsen\n */\npublic final class IntType extends NumberType {\n    protected IntType() {}\n    public String toString() {\n\treturn \"int\";\n    }\n    public boolean identicalTo(Type other) {\n\treturn this == other;\n    }\n    public String toSignature() {\n\treturn \"I\";\n    }\n    public org.apache.bcel.generic.Type toJCType() {\n\treturn org.apache.bcel.generic.Type.INT;\n    }\n    /**\n     * @see\torg.apache.xalan.xsltc.compiler.util.Type#distanceTo\n     */\n    public int distanceTo(Type type) {\n\tif (type == this) {\n\t    return 0;\n\t}\n\telse if (type == Type.Real) {\n\t    return 1;\n\t}\n\telse\n\t    return Integer.MAX_VALUE;\n    }\n    /**\n     * Translates an integer into an object of internal type <code>type</code>.\n     *\n     * @see\torg.apache.xalan.xsltc.compiler.util.Type#translateTo\n     */\n    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, \n\t\t\t    final Type type) {\n\tif (type == Type.Real) {\n\t    translateTo(classGen, methodGen, (RealType) type);\n\t}\n\telse if (type == Type.String) {\n\t    translateTo(classGen, methodGen, (StringType) type);\n\t}\n\telse if (type == Type.Boolean) {\n\t    translateTo(classGen, methodGen, (BooleanType) type);\n\t}\n\telse if (type == Type.Reference) {\n\t    translateTo(classGen, methodGen, (ReferenceType) type);\n\t}\n\telse {\n\t    ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,\n\t\t\t\t\ttoString(), type.toString());\n\t    classGen.getParser().reportError(Constants.FATAL, err);\n\t}\n    }\n    /**\n     * Expects an integer on the stack and pushes a real.\n     *\n     * @see\torg.apache.xalan.xsltc.compiler.util.Type#translateTo\n     */\n    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, \n\t\t\t    RealType type) {\n\tmethodGen.getInstructionList().append(I2D);\n    }\n    /**\n     * Expects an integer on the stack and pushes its string value by calling\n     * <code>Integer.toString(int i)</code>.\n     *\n     * @see\torg.apache.xalan.xsltc.compiler.util.Type#translateTo\n     */\n    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, \n\t\t\t    StringType type) {\n\tfinal ConstantPoolGen cpg = classGen.getConstantPool();\n\tfinal InstructionList il = methodGen.getInstructionList();\n\til.append(new INVOKESTATIC(cpg.addMethodref(INTEGER_CLASS,\n\t\t\t\t\t\t    \"toString\",\n\t\t\t\t\t\t    \"(I)\" + STRING_SIG)));\n    }\n    /**\n     * Expects an integer on the stack and pushes a 0 if its value is 0 and\n     * a 1 otherwise.\n     *\n     * @see\torg.apache.xalan.xsltc.compiler.util.Type#translateTo\n     */\n    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, \n\t\t\t    BooleanType type) {\n\tfinal InstructionList il = methodGen.getInstructionList();\n\tfinal BranchHandle falsec = il.append(new IFEQ(null));\n\til.append(ICONST_1);\n\tfinal BranchHandle truec = il.append(new GOTO(null));\n\tfalsec.setTarget(il.append(ICONST_0));\n\ttruec.setTarget(il.append(NOP));\n    }\n    /**\n     * Expects an integer on the stack and translates it to a non-synthesized\n     * boolean. It does not push a 0 or a 1 but instead returns branchhandle \n     * list to be appended to the false list.\n     *\n     * @see\torg.apache.xalan.xsltc.compiler.util.Type#translateToDesynthesized\n     */\n    public FlowList translateToDesynthesized(ClassGenerator classGen, \n\t\t\t\t\t     MethodGenerator methodGen, \n\t\t\t\t\t     BooleanType type) {\n\tfinal InstructionList il = methodGen.getInstructionList();\n\treturn new FlowList(il.append(new IFEQ(null)));\n    }\n    /**\n     * Expects an integer on the stack and pushes a boxed integer.\n     * Boxed integers are represented by an instance of\n     * <code>java.lang.Integer</code>.\n     *\n     * @see\torg.apache.xalan.xsltc.compiler.util.Type#translateTo\n     */\n    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, \n\t\t\t    ReferenceType type) {\n\tfinal ConstantPoolGen cpg = classGen.getConstantPool();\n\tfinal InstructionList il = methodGen.getInstructionList();\n\til.append(new NEW(cpg.addClass(INTEGER_CLASS)));\n\til.append(DUP_X1);\n\til.append(SWAP);\n\til.append(new INVOKESPECIAL(cpg.addMethodref(INTEGER_CLASS,\n\t\t\t\t\t\t     \"<init>\", \"(I)V\")));\n    }\n    /**\n     * Translates an integer into the Java type denoted by <code>clazz</code>. \n     * Expects an integer on the stack and pushes a number of the appropriate\n     * type after coercion.\n     */\n    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, \n\t\t\t    Class clazz) {\n\tfinal InstructionList il = methodGen.getInstructionList();\n\tif (clazz == Character.TYPE) {\n\t    il.append(I2C);\n\t}\n\telse if (clazz == Byte.TYPE) {\n\t    il.append(I2B);\n\t}\n\telse if (clazz == Short.TYPE) {\n\t    il.append(I2S);\n\t}\n\telse if (clazz == Integer.TYPE) {\n\t    il.append(NOP);\n\t}\n\telse if (clazz == Long.TYPE) {\n\t    il.append(I2L);\n\t}\n\telse if (clazz == Float.TYPE) {\n\t    il.append(I2F);\n\t}\n\telse if (clazz == Double.TYPE) {\n\t    il.append(I2D);\n\t}\n         // Is Double <: clazz? I.e. clazz in { Double, Number, Object }\n       else if (clazz.isAssignableFrom(java.lang.Double.class)) {\n           il.append(I2D);\n           Type.Real.translateTo(classGen, methodGen, Type.Reference);\n        }\n\telse {\n\t    ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,\n\t\t\t\t\ttoString(), clazz.getName());\n\t    classGen.getParser().reportError(Constants.FATAL, err);\n\t}\n    }\n    /**\n     * Translates an object of this type to its boxed representation.\n     */ \n    public void translateBox(ClassGenerator classGen,\n\t\t\t     MethodGenerator methodGen) {\n\ttranslateTo(classGen, methodGen, Type.Reference);\n    }\n    /**\n     * Translates an object of this type to its unboxed representation.\n     */ \n    public void translateUnBox(ClassGenerator classGen,\n\t\t\t       MethodGenerator methodGen) {\n\tfinal ConstantPoolGen cpg = classGen.getConstantPool();\n\tfinal InstructionList il = methodGen.getInstructionList();\n\til.append(new CHECKCAST(cpg.addClass(INTEGER_CLASS)));\n\tfinal int index = cpg.addMethodref(INTEGER_CLASS,\n\t\t\t\t\t   INT_VALUE, \n\t\t\t\t\t   INT_VALUE_SIG);\n\til.append(new INVOKEVIRTUAL(index));\n    }\n    public Instruction ADD() {\n\treturn InstructionConstants.IADD;\n    }\n    public Instruction SUB() {\n\treturn InstructionConstants.ISUB;\n    }\n    public Instruction MUL() {\n\treturn InstructionConstants.IMUL;\n    }\n    public Instruction DIV() {\n\treturn InstructionConstants.IDIV;\n    }\n    public Instruction REM() {\n\treturn InstructionConstants.IREM;\n    }\n    public Instruction NEG() {\n\treturn InstructionConstants.INEG;\n    }\n    public Instruction LOAD(int slot) {\n\treturn new ILOAD(slot);\n    }\n    public Instruction STORE(int slot) {\n\treturn new ISTORE(slot);\n    }\n    public BranchInstruction GT(boolean tozero) {\n\treturn tozero ? (BranchInstruction) new IFGT(null) : \n\t    (BranchInstruction) new IF_ICMPGT(null);\n    }\n<fim_suffix>    public BranchInstruction GE(boolean tozero) {\n\treturn tozero ? (BranchInstruction) new IFGE(null) : \n\t    (BranchInstruction) new IF_ICMPGE(null);\n    }<fim_middle>// function below has no smell\n"}