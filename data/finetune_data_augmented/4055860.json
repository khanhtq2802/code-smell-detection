{"text": "<fim_prefix>      // string in RFC 3339 format here.\n      // Expected IllegalArgumentException if parsing fails; we use that to fall back\n      // to RFC 3339.\n      return Long.parseLong(timestamp);\n    } catch (IllegalArgumentException e1) {\n      // Try parsing as RFC3339 string. DateTime.parseRfc3339 will throw an\n      // IllegalArgumentException if parsing fails, and the caller should handle.\n      return DateTime.parseRfc3339(timestamp).getValue();\n    }\n  }\n  /**\n   * Return the timestamp (in ms since unix epoch) to use for a Pubsub message with {@code\n   * attributes} and {@code pubsubTimestamp}.\n   *\n   * <p>If {@code timestampAttribute} is non-{@literal null} then the message attributes must\n   * contain that attribute, and the value of that attribute will be taken as the timestamp.\n   * Otherwise the timestamp will be taken from the Pubsub publish timestamp {@code\n   * pubsubTimestamp}.\n   *\n   * @throws IllegalArgumentException if the timestamp cannot be recognized as a ms-since-unix-epoch\n   *     or RFC3339 time.\n   */\n  protected static long extractTimestamp(\n      @Nullable String timestampAttribute,\n      @Nullable String pubsubTimestamp,\n      @Nullable Map<String, String> attributes) {\n    Long timestampMsSinceEpoch;\n    if (Strings.isNullOrEmpty(timestampAttribute)) {\n      timestampMsSinceEpoch = asMsSinceEpoch(pubsubTimestamp);\n      checkArgument(\n          timestampMsSinceEpoch != null,\n          \"Cannot interpret PubSub publish timestamp: %s\",\n          pubsubTimestamp);\n    } else {\n      String value = attributes == null ? null : attributes.get(timestampAttribute);\n      checkArgument(\n          value != null,\n          \"PubSub message is missing a value for timestamp attribute %s\",\n          timestampAttribute);\n      timestampMsSinceEpoch = asMsSinceEpoch(value);\n      checkArgument(\n          timestampMsSinceEpoch != null,\n          \"Cannot interpret value of attribute %s as timestamp: %s\",\n          timestampAttribute,\n          value);\n    }\n    return timestampMsSinceEpoch;\n  }\n  /** Path representing a cloud project id. */\n  public static class ProjectPath implements Serializable {\n    private final String projectId;\n    /**\n     * Creates a {@link ProjectPath} from a {@link String} representation, which must be of the form\n     * {@code \"projects/\" + projectId}.\n     */\n    ProjectPath(String path) {\n      List<String> splits = Splitter.on('/').splitToList(path);\n      checkArgument(\n          splits.size() == 2 && \"projects\".equals(splits.get(0)),\n          \"Malformed project path \\\"%s\\\": must be of the form \\\"projects/\\\" + <project id>\",\n          path);\n      this.projectId = splits.get(1);\n    }\n    public String getPath() {\n      return String.format(\"projects/%s\", projectId);\n    }\n    public String getId() {\n      return projectId;\n    }\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || getClass() != o.getClass()) {\n        return false;\n      }\n      ProjectPath that = (ProjectPath) o;\n      return projectId.equals(that.projectId);\n    }\n    @Override\n    public int hashCode() {\n      return projectId.hashCode();\n    }\n    @Override\n    public String toString() {\n      return getPath();\n    }\n  }\n  public static ProjectPath projectPathFromPath(String path) {\n    return new ProjectPath(path);\n  }\n  public static ProjectPath projectPathFromId(String projectId) {\n    return new ProjectPath(String.format(\"projects/%s\", projectId));\n  }\n  /** Path representing a Pubsub subscription. */\n  public static class SubscriptionPath implements Serializable {\n    private final String projectId;\n    private final String subscriptionName;\n    SubscriptionPath(String path) {\n      List<String> splits = Splitter.on('/').splitToList(path);\n      checkState(\n          splits.size() == 4\n              && \"projects\".equals(splits.get(0))\n              && \"subscriptions\".equals(splits.get(2)),\n          \"Malformed subscription path %s: \"\n              + \"must be of the form \\\"projects/\\\" + <project id> + \\\"subscriptions\\\"\",\n          path);\n      this.projectId = splits.get(1);\n      this.subscriptionName = splits.get(3);\n    }\n    public String getPath() {\n      return String.format(\"projects/%s/subscriptions/%s\", projectId, subscriptionName);\n    }\n    public String getName() {\n      return subscriptionName;\n    }\n    public String getV1Beta1Path() {\n      return String.format(\"/subscriptions/%s/%s\", projectId, subscriptionName);\n    }\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || getClass() != o.getClass()) {\n        return false;\n      }\n      SubscriptionPath that = (SubscriptionPath) o;\n      return this.subscriptionName.equals(that.subscriptionName)\n          && this.projectId.equals(that.projectId);\n    }\n    @Override\n    public int hashCode() {\n      return Objects.hashCode(projectId, subscriptionName);\n    }\n    @Override\n    public String toString() {\n      return getPath();\n    }\n  }\n  public static SubscriptionPath subscriptionPathFromPath(String path) {\n    return new SubscriptionPath(path);\n  }\n  public static SubscriptionPath subscriptionPathFromName(\n      String projectId, String subscriptionName) {\n    return new SubscriptionPath(\n        String.format(\"projects/%s/subscriptions/%s\", projectId, subscriptionName));\n  }\n  /** Path representing a Pubsub topic. */\n  public static class TopicPath implements Serializable {\n    private final String path;\n    TopicPath(String path) {\n      this.path = path;\n    }\n    public String getPath() {\n      return path;\n    }\n    public String getName() {\n      List<String> splits = Splitter.on('/').splitToList(path);\n      checkState(splits.size() == 4, \"Malformed topic path %s\", path);\n      return splits.get(3);\n    }\n    public String getV1Beta1Path() {\n      List<String> splits = Splitter.on('/').splitToList(path);\n      checkState(splits.size() == 4, \"Malformed topic path %s\", path);\n      return String.format(\"/topics/%s/%s\", splits.get(1), splits.get(3));\n    }\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || getClass() != o.getClass()) {\n        return false;\n      }\n      TopicPath topicPath = (TopicPath) o;\n      return path.equals(topicPath.path);\n    }\n    @Override\n    public int hashCode() {\n      return path.hashCode();\n    }\n    @Override\n    public String toString() {\n      return path;\n    }\n  }\n  public static TopicPath topicPathFromPath(String path) {\n    return new TopicPath(path);\n  }\n  public static TopicPath topicPathFromName(String projectId, String topicName) {\n    return new TopicPath(String.format(\"projects/%s/topics/%s\", projectId, topicName));\n  }\n  /**\n   * A message to be sent to Pubsub.\n   *\n   * <p>NOTE: This class is {@link Serializable} only to support the {@link PubsubTestClient}. Java\n   * serialization is never used for non-test clients.\n   */\n<fim_suffix>  public static class OutgoingMessage implements Serializable {\n    /** Underlying (encoded) element. */\n    public final byte[] elementBytes;\n    public final Map<String, String> attributes;\n    /** Timestamp for element (ms since epoch). */\n    public final long timestampMsSinceEpoch;\n    /**\n     * If using an id attribute, the record id to associate with this record's metadata so the\n     * receiver can reject duplicates. Otherwise {@literal null}.\n     */\n    @Nullable public final String recordId;\n    public OutgoingMessage(\n        byte[] elementBytes,\n        Map<String, String> attributes,\n        long timestampMsSinceEpoch,\n        @Nullable String recordId) {\n      this.elementBytes = elementBytes;\n      this.attributes = attributes;\n      this.timestampMsSinceEpoch = timestampMsSinceEpoch;\n      this.recordId = recordId;\n    }\n    @Override\n    public String toString() {\n      return String.format(\n          \"OutgoingMessage(%db, %dms)\", elementBytes.length, timestampMsSinceEpoch);\n    }\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || getClass() != o.getClass()) {\n        return false;\n      }\n      OutgoingMessage that = (OutgoingMessage) o;\n      return timestampMsSinceEpoch == that.timestampMsSinceEpoch\n          && Arrays.equals(elementBytes, that.elementBytes)\n          && Objects.equal(attributes, that.attributes)\n          && Objects.equal(recordId, that.recordId);\n    }\n    @Override\n    public int hashCode() {\n      return Objects.hashCode(\n          Arrays.hashCode(elementBytes), attributes, timestampMsSinceEpoch, recordId);\n    }\n  }<fim_middle>// class below has no smell\n"}