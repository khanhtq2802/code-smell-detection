{"text": "<fim_prefix> * and {@code //$<type>.<name>} with a generated snippet documenting options. Those start and end fences are copied as-is,\n * so that a subsequent run regenerates uptodate doco.\n * </p>\n *\n * @author Eric Bottard\n */\n<fim_suffix>public class ModuleOptionsReferenceDoc {\n\t/**\n\t * Matches \"//^<type>.<name>\" exactly.\n\t */\n\tprivate static final Pattern FENCE_START_REGEX = Pattern.compile(\"^//\\\\^([^.]+)\\\\.([^.]+)$\");\n\tprivate ModuleRegistry moduleRegistry = new ResourceModuleRegistry(\"file:./modules\");\n\tprivate ModuleOptionsMetadataResolver moduleOptionsMetadataResolver = new DefaultModuleOptionsMetadataResolver();\n\tprivate ResourcePatternResolver resourcePatternResolver = new PathMatchingResourcePatternResolver();\n\tpublic static void main(String... paths) throws IOException {\n\t\tModuleOptionsReferenceDoc runner = new ModuleOptionsReferenceDoc();\n\t\tfor (String path : paths) {\n\t\t\trunner.updateSingleFile(path);\n\t\t}\n\t}\n\tprivate void updateSingleFile(String path) throws IOException {\n\t\tFile originalFile = new File(path);\n\t\tAssert.isTrue(originalFile.exists() && !originalFile.isDirectory(),\n\t\t\t\tString.format(\"'%s' does not exist or points to a directory\", originalFile.getAbsolutePath()));\n\t\tFile backup = new File(originalFile.getAbsolutePath() + \".backup\");\n\t\toriginalFile.renameTo(backup);\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(backup), \"UTF-8\"));\n\t\tPrintStream out = new PrintStream(new FileOutputStream(originalFile), false, \"UTF-8\");\n\t\tModuleType type = null;\n\t\tString name = null;\n\t\tint openingLineNumber = 0;\n\t\tint ln = 1;\n\t\tfor (String line = reader.readLine(); line != null; line = reader.readLine(), ln++) {\n\t\t\tMatcher startMatcher = FENCE_START_REGEX.matcher(line);\n\t\t\tif (startMatcher.matches()) {\n\t\t\t\tcheckPreviousTagHasBeenClosed(originalFile, backup, out, type, name, openingLineNumber);\n\t\t\t\ttype = ModuleType.valueOf(startMatcher.group(1));\n\t\t\t\tname = startMatcher.group(2);\n\t\t\t\topeningLineNumber = ln;\n\t\t\t\tout.println(line);\n\t\t\t}\n\t\t\telse if (type != null && line.equals(String.format(\"//$%s.%s\", type, name))) {\n\t\t\t\tgenerateWarning(out, name, type);\n\t\t\t\tgenerateAsciidoc(out, name, type);\n\t\t\t\ttype = null;\n\t\t\t\tname = null;\n\t\t\t\tout.println(line);\n\t\t\t}\n\t\t\telse if (type == null) {\n\t\t\t\tout.println(line);\n\t\t\t}\n\t\t}\n\t\tcheckPreviousTagHasBeenClosed(originalFile, backup, out, type, name, openingLineNumber);\n\t\tout.close();\n\t\treader.close();\n\t\tbackup.delete();\n\t}\n\tprivate void checkPreviousTagHasBeenClosed(File originalFile, File backup, PrintStream out, ModuleType type,\n\t\t\tString name, int openingLineNumber) {\n\t\tif (type != null) {\n\t\t\tout.close();\n\t\t\toriginalFile.delete();\n\t\t\tbackup.renameTo(originalFile);\n\t\t\tthrow new IllegalStateException(String.format(\n\t\t\t\t\t\"In %s, found '//^%s.%s' @line %d with no matching '//$%2$s.%3$s'\",\n\t\t\t\t\toriginalFile.getAbsolutePath(), type, name, openingLineNumber));\n\t\t}\n\t}\n\tprivate void generateWarning(PrintStream out, String name, ModuleType type) {\n\t\tout.format(\"// DO NOT MODIFY THE LINES BELOW UNTIL THE CLOSING '//$%s.%s' TAG%n\", type, name);\n\t\tout.format(\"// THIS SNIPPET HAS BEEN GENERATED BY %s AND MANUAL EDITS WILL BE LOST%n\",\n\t\t\t\tModuleOptionsReferenceDoc.class.getSimpleName());\n\t}\n\tprivate void generateAsciidoc(PrintStream out, String name, ModuleType type)\n\t\t\tthrows IOException {\n\t\tModuleDefinition def = moduleRegistry.findDefinition(name, type);\n\t\tModuleOptionsMetadata moduleOptionsMetadata = moduleOptionsMetadataResolver.resolve(def);\n\t\tResource moduleLoc = resourcePatternResolver.getResource(((SimpleModuleDefinition) def).getLocation());\n\t\tClassLoader moduleClassLoader = ModuleUtils.createModuleDiscoveryClassLoader(moduleLoc, ModuleOptionsReferenceDoc.class.getClassLoader());\n\t\tif (!moduleOptionsMetadata.iterator().hasNext()) {\n\t\t\tout.format(\"The **%s** %s has no particular option (in addition to options shared by all modules)%n%n\",\n\t\t\t\t\tpt(def.getName()), pt(def.getType()));\n\t\t\treturn;\n\t\t}\n\t\tout.format(\"The **%s** %s has the following options:%n%n\", pt(def.getName()), pt(def.getType()));\n\t\tList<ModuleOption> options = new ArrayList<ModuleOption>();\n\t\tfor (ModuleOption mo : moduleOptionsMetadata) {\n\t\t\toptions.add(mo);\n\t\t}\n\t\tCollections.sort(options, new Comparator<ModuleOption>() {\n\t\t\t@Override\n\t\t\tpublic int compare(ModuleOption o1, ModuleOption o2) {\n\t\t\t\treturn o1.getName().compareTo(o2.getName());\n\t\t\t}\n\t\t});\n\t\tfor (ModuleOption mo : options) {\n\t\t\tString prettyDefault = prettifyDefaultValue(mo);\n\t\t\tString maybeEnumHint = generateEnumValues(mo, moduleClassLoader);\n\t\t\tout.format(\"%s:: %s *(%s, %s%s)*%n\", pt(mo.getName()), pt(mo.getDescription()),\n\t\t\t\t\tpt(shortClassName(mo.getType())),\n\t\t\t\t\tprettyDefault, maybeEnumHint);\n\t\t}\n\t}\n\tprivate String shortClassName(String fqName) {\n\t\tint lastDot = fqName.lastIndexOf('.');\n\t\treturn lastDot >= 0 ? fqName.substring(lastDot + 1) : fqName;\n\t}\n\t/**\n\t * When the type of an option is an enum, document all possible values\n\t */\n\tprivate String generateEnumValues(ModuleOption mo, ClassLoader moduleClassLoader) {\n\t\t// Attempt to convert back to com.acme.Foo$Bar form\n\t\tString canonical = mo.getType();\n\t\tString system = canonical.replaceAll(\"(.*\\\\p{Upper}[^\\\\.]*)\\\\.(\\\\p{Upper}.*)\", \"$1\\\\$$2\");\n\t\tClass<?> clazz = null;\n\t\ttry {\n\t\t\tclazz = Class.forName(system, false, moduleClassLoader);\n\t\t}\n\t\tcatch (ClassNotFoundException e) {\n\t\t\treturn \"\";\n\t\t}\n\t\tif (Enum.class.isAssignableFrom(clazz)) {\n\t\t\tString values = StringUtils.arrayToCommaDelimitedString(clazz.getEnumConstants());\n\t\t\treturn String.format(\", possible values: `%s`\", values);\n\t\t}\n\t\telse\n\t\t\treturn \"\";\n\t}\n\tprivate String prettifyDefaultValue(ModuleOption mo) {\n\t\tif (mo.getDefaultValue() == null) {\n\t\t\treturn \"no default\";\n\t\t}\n\t\tString result = stringify(mo.getDefaultValue());\n\t\tresult = result.replace(ModulePlaceholders.XD_STREAM_NAME, \"<stream name>\");\n\t\tresult = result.replace(ModulePlaceholders.XD_JOB_NAME, \"<job name>\");\n\t\treturn \"default: `\" + result + \"`\";\n\t}\n\tprivate String stringify(Object element) {\n\t\tClass<?> clazz = element.getClass();\n\t\tif (clazz == byte[].class) {\n\t\t\treturn Arrays.toString((byte[]) element);\n\t\t}\n\t\telse if (clazz == short[].class) {\n\t\t\treturn Arrays.toString((short[]) element);\n\t\t}\n\t\telse if (clazz == int[].class) {\n\t\t\treturn Arrays.toString((int[]) element);\n\t\t}\n\t\telse if (clazz == long[].class) {\n\t\t\treturn Arrays.toString((long[]) element);\n\t\t}\n\t\telse if (clazz == char[].class) {\n\t\t\treturn Arrays.toString((char[]) element);\n\t\t}\n\t\telse if (clazz == float[].class) {\n\t\t\treturn Arrays.toString((float[]) element);\n\t\t}\n\t\telse if (clazz == double[].class) {\n\t\t\treturn Arrays.toString((double[]) element);\n\t\t}\n\t\telse if (clazz == boolean[].class) {\n\t\t\treturn Arrays.toString((boolean[]) element);\n\t\t}\n\t\telse if (element instanceof Object[]) {\n\t\t\treturn Arrays.deepToString((Object[]) element);\n\t\t}\n\t\telse {\n\t\t\treturn element.toString();\n\t\t}\n\t}\n\t/**\n\t * Return an asciidoc passthrough version of some text, in case the original text contains characters\n\t * that would be (mis)interpreted by asciidoc.\n\t */\n\tprivate String pt(Object original) {\n\t\treturn \"$$\" + original + \"$$\";\n\t}\n}<fim_middle>// class below is blob\n"}