{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.pinot.thirdeye.dashboard.resources;\nimport com.wordnik.swagger.annotations.ApiOperation;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport javax.validation.constraints.NotNull;\nimport javax.ws.rs.DefaultValue;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.POST;\nimport javax.ws.rs.PUT;\nimport javax.ws.rs.Path;\nimport javax.ws.rs.PathParam;\nimport javax.ws.rs.Produces;\nimport javax.ws.rs.QueryParam;\nimport javax.ws.rs.core.MediaType;\nimport javax.ws.rs.core.Response;\nimport org.apache.commons.lang.StringUtils;\nimport org.codehaus.jackson.node.ObjectNode;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport org.apache.pinot.thirdeye.common.metric.MetricType;\nimport org.apache.pinot.thirdeye.dashboard.Utils;\nimport org.apache.pinot.thirdeye.datalayer.bao.MetricConfigManager;\nimport org.apache.pinot.thirdeye.datalayer.dto.MetricConfigDTO;\nimport org.apache.pinot.thirdeye.datasource.DAORegistry;\nimport org.apache.pinot.thirdeye.util.JsonResponseUtil;\nimport org.apache.pinot.thirdeye.util.ThirdEyeUtils;\n@Path(value = \"/thirdeye-admin/metric-config\")\n@Produces(MediaType.APPLICATION_JSON)\npublic class MetricConfigResource {\n  private static final Logger LOG = LoggerFactory.getLogger(MetricConfigResource.class);\n  private static final DAORegistry DAO_REGISTRY = DAORegistry.getInstance();\n  private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();\n  private MetricConfigManager metricConfigDao;\n  public MetricConfigResource() {\n    this.metricConfigDao = DAO_REGISTRY.getMetricConfigDAO();\n  }\n<fim_suffix>  @GET\n  @Path(\"/create\")\n  public String createMetricConfig(@QueryParam(\"dataset\") String dataset, @QueryParam(\"name\") String name, @QueryParam(\"datatype\") String metricType,\n      @QueryParam(\"active\") boolean active, @QueryParam(\"derived\") boolean derived, @QueryParam(\"derivedFunctionType\") String derivedFunctionType,\n      @QueryParam(\"numerator\") String numerator, @QueryParam(\"denominator\") String denominator,\n      @QueryParam(\"derivedMetricExpression\") String derivedMetricExpression, @QueryParam(\"inverseMetric\") boolean inverseMetric,\n      @QueryParam(\"cellSizeExpression\") String cellSizeExpression, @QueryParam(\"rollupThreshold\") Double rollupThreshold) {\n    try {\n      MetricConfigDTO metricConfigDTO = new MetricConfigDTO();\n      populateMetricConfig(metricConfigDTO, dataset, name, metricType, active, derived, derivedFunctionType, numerator, denominator, derivedMetricExpression,\n          inverseMetric, cellSizeExpression, rollupThreshold);\n      Long id = metricConfigDao.save(metricConfigDTO);\n      metricConfigDTO.setId(id);\n      return JsonResponseUtil.buildResponseJSON(metricConfigDTO).toString();\n    } catch (Exception e) {\n      LOG.warn(\"Failed to create metric:{}\", name, e);\n      return JsonResponseUtil.buildErrorResponseJSON(\"Failed to create metric:\" + name + \" Message:\" + e.getMessage()).toString();\n    }\n  }\n  private void populateMetricConfig(MetricConfigDTO metricConfigDTO, String dataset, String name, String metricType, boolean active, boolean derived,\n      String derivedFunctionType, String numerator, String denominator, String derivedMetricExpression, boolean inverseMetric, String cellSizeExpression,\n      Double rollupThreshold) {\n    metricConfigDTO.setDataset(dataset);\n    metricConfigDTO.setName(name);\n    metricConfigDTO.setAlias(ThirdEyeUtils.constructMetricAlias(dataset, name));\n    metricConfigDTO.setDatatype(MetricType.valueOf(metricType));\n    metricConfigDTO.setActive(active);\n    // optional ones\n    metricConfigDTO.setCellSizeExpression(cellSizeExpression);\n    metricConfigDTO.setInverseMetric(inverseMetric);\n    if (rollupThreshold != null) {\n      metricConfigDTO.setRollupThreshold(rollupThreshold);\n    }\n    // handle derived\n    if (derived) {\n      if (StringUtils.isEmpty(derivedMetricExpression) && numerator != null && denominator != null) {\n        MetricConfigDTO numMetricConfigDTO = metricConfigDao.findByAliasAndDataset(numerator, dataset);\n        MetricConfigDTO denMetricConfigDTO = metricConfigDao.findByAliasAndDataset(denominator, dataset);\n        if (\"RATIO\".equals(derivedFunctionType)) {\n          derivedMetricExpression = String.format(\"id%s/id%s\", numMetricConfigDTO.getId(), denMetricConfigDTO.getId());\n        } else if (\"PERCENT\".equals(derivedFunctionType)) {\n          derivedMetricExpression = String.format(\"id%s*100/id%s\", numMetricConfigDTO.getId(), denMetricConfigDTO.getId());\n        }\n      }\n      metricConfigDTO.setDerived(derived);\n      metricConfigDTO.setDerivedMetricExpression(derivedMetricExpression);\n    }\n  }\n  @GET\n  @Path(\"/metrics\")\n  public String getMetricsForDataset(@NotNull @QueryParam(\"dataset\") String dataset) {\n    Map<String, Object> filters = new HashMap<>();\n    filters.put(\"dataset\", dataset);\n    List<MetricConfigDTO> metricConfigDTOs = metricConfigDao.findByParams(filters);\n    List<String> metrics = new ArrayList<>();\n    for (MetricConfigDTO metricConfigDTO : metricConfigDTOs) {\n      metrics.add(metricConfigDTO.getAlias());\n    }\n    return JsonResponseUtil.buildResponseJSON(metrics).toString();\n  }\n  @GET\n  @Path(\"/update\")\n  public String updateMetricConfig(@NotNull @QueryParam(\"id\") long metricConfigId, @QueryParam(\"dataset\") String dataset, @QueryParam(\"name\") String name,\n      @QueryParam(\"datatype\") String metricType, @QueryParam(\"active\") boolean active, @QueryParam(\"derived\") boolean derived,\n      @QueryParam(\"derivedFunctionType\") String derivedFunctionType, @QueryParam(\"numerator\") String numerator, @QueryParam(\"denominator\") String denominator,\n      @QueryParam(\"derivedMetricExpression\") String derivedMetricExpression, @QueryParam(\"inverseMetric\") boolean inverseMetric,\n      @QueryParam(\"cellSizeExpression\") String cellSizeExpression, @QueryParam(\"rollupThreshold\") Double rollupThreshold) {\n    try {\n      MetricConfigDTO metricConfigDTO = metricConfigDao.findById(metricConfigId);\n      populateMetricConfig(metricConfigDTO, dataset, name, metricType, active, derived, derivedFunctionType, numerator, denominator, derivedMetricExpression,\n          inverseMetric, cellSizeExpression, rollupThreshold);\n      int numRowsUpdated = metricConfigDao.update(metricConfigDTO);\n      if (numRowsUpdated == 1) {\n        return JsonResponseUtil.buildResponseJSON(metricConfigDTO).toString();\n      } else {\n        return JsonResponseUtil.buildErrorResponseJSON(\"Failed to update metric id:\" + metricConfigId).toString();\n      }\n    } catch (Exception e) {\n      return JsonResponseUtil.buildErrorResponseJSON(\"Failed to update metric id:\" + metricConfigId + \". Exception:\" + e.getMessage()).toString();\n    }\n  }\n  @GET\n  @Path(\"/delete\")\n  public String deleteMetricConfig(@NotNull @QueryParam(\"dataset\") String dataset, @NotNull @QueryParam(\"id\") Long metricConfigId) {\n    metricConfigDao.deleteById(metricConfigId);\n    return JsonResponseUtil.buildSuccessResponseJSON(\"Successully deleted \" + metricConfigId).toString();\n  }\n  @GET\n  @Path(\"/list\")\n  @Produces(MediaType.APPLICATION_JSON)\n  public String viewMetricConfig(@NotNull @QueryParam(\"dataset\") String dataset, @DefaultValue(\"0\") @QueryParam(\"jtStartIndex\") int jtStartIndex,\n      @DefaultValue(\"100\") @QueryParam(\"jtPageSize\") int jtPageSize) {\n    Map<String, Object> filters = new HashMap<>();\n    filters.put(\"dataset\", dataset);<fim_middle>// function below has no smell\n"}