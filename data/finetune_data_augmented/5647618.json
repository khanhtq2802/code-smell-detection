{"text": "<fim_prefix>              analyzer.getUniqueString(reflect, dir.table),\n              analyzer.getUniqueString(reflect, Reflection.FK_NAME));\n        final Map<String,String> m = new LinkedHashMap<>();\n        do {\n            final String column = analyzer.getUniqueString(reflect, dir.column);\n            if (m.put(column, analyzer.getUniqueString(reflect, dir.containerColumn)) != null) {\n                throw new DataStoreContentException(Resources.forLocale(analyzer.locale)\n                        .getString(Resources.Keys.DuplicatedColumn_1, column));\n            }\n            if (!reflect.next()) {\n                reflect.close();\n                break;\n            }\n        } while (table.equals(reflect.getString(dir.table)) &&                  // Table name is mandatory.\n                 Objects.equals(schema,  reflect.getString(dir.schema)) &&      // Schema and catalog may be null.\n                 Objects.equals(catalog, reflect.getString(dir.catalog)));\n        columns = CollectionsExt.compact(m);\n    }\n    /**\n     * Invoked after construction for setting the name of the feature property of the enclosing table where to\n     * store association to the feature instances read from the {@linkplain #getSearchTable() search table}.\n     * If the foreigner key use exactly one column, we can use the name of that column. Otherwise we don't know\n     * which column has the most appropriate name (often there is none), so we fallback on the foreigner key name.\n     *\n     * @param  column  a foreigner key column.\n     * @param  count   number of names previously created from that column.\n     */\n    final void setPropertyName(final String column, final int count) {\n        if (columns.size() > 1) {\n            propertyName = freeText;        // Foreigner key name (may be null).\n        }\n        if (propertyName == null) {\n            propertyName = (count == 0) ? column : column + '-' + count;\n        }\n    }\n    /**\n     * Invoked after construction for setting the table identified by {@link #catalog}, {@link #schema}\n     * and {@link #table} names. Shall be invoked exactly once.\n     *\n     * @param  search       the other table containing the primary key ({@link Direction#IMPORT})\n     *                      or the foreigner key ({@link Direction#EXPORT}) of this relation.\n     * @param  primaryKeys  the primary key columns of the relation. May be the primary key columns of this table\n     *                      or the primary key columns of the other table, depending on {@link Direction}.\n     * @param  direction    {@code this.direction} (see comment in field declarations).\n     */\n    final void setSearchTable(final Analyzer analyzer, final Table search, final String[] primaryKeys,\n                              final Direction direction) throws DataStoreException\n    {\n        /*\n         * Sanity check (could be assertion): name of the given table must match\n         * the name expected by this relation. This check below should never fail.\n         */\n        final boolean isDefined = (searchTable != null);\n        if (isDefined || !equals(search.name)) {\n            throw new InternalDataStoreException(isDefined ? analyzer.internalError() : super.toString());\n        }\n        /*\n         * Store the specified table and verify if this relation\n         * contains all columns required by the primary key.\n         */\n        searchTable = search;\n        final Collection<String> referenced;        // Primary key components referenced by this relation.\n        switch (direction) {\n            case IMPORT: referenced = columns.keySet(); break;\n            case EXPORT: referenced = columns.values(); break;\n            default: throw new AssertionError(direction);\n        }\n        useFullKey = referenced.containsAll(Arrays.asList(primaryKeys));\n        if (useFullKey && columns.size() >= 2) {\n            /*\n             * Sort the columns in the order expected by the primary key.  This is required because we need\n             * a consistent order in the cache provided by Table.instanceForPrimaryKeys() even if different\n             * relations declare different column order in their foreigner key. Note that the 'columns' map\n             * is unmodifiable if its size is less than 2, and modifiable otherwise.\n             */\n            final Map<String,String> copy = new HashMap<>(columns);\n            columns.clear();\n            for (String key : primaryKeys) {\n                String value = key;\n                switch (direction) {\n                    case IMPORT: {                                      // Primary keys are 'columns' keys.\n                        value = copy.remove(key);\n                        break;\n                    }\n                    case EXPORT: {                                      // Primary keys are 'columns' values.\n                        key = null;\n                        for (final Iterator<Map.Entry<String,String>> it = copy.entrySet().iterator(); it.hasNext();) {\n                            final Map.Entry<String,String> e = it.next();\n                            if (value.equals(e.getValue())) {\n                                key = e.getKey();\n                                it.remove();\n                                break;\n                            }\n                        }\n                        break;\n                    }\n                }\n                if (key == null || value == null || columns.put(key, value) != null) {\n                    throw new InternalDataStoreException(analyzer.internalError());\n                }\n            }\n            if (!copy.isEmpty()) {\n                throw new DataStoreContentException(Resources.forLocale(analyzer.locale)\n                            .getString(Resources.Keys.MalformedForeignerKey_2, freeText,\n                                       CollectionsExt.first(copy.keySet())));\n            }\n        }\n    }\n    /**\n     * Returns the other table identified by {@link #catalog}, {@link #schema} and {@link #table} names.\n     * This is the table where the search operations will be performed. In other words, this is part of\n     * the following pseudo-query:\n     *\n     * <pre>{@code SELECT * FROM <search table> WHERE <search columns> = ...}</pre>\n     */\n    final Table getSearchTable() throws InternalDataStoreException {\n        if (searchTable != null) {\n            return searchTable;\n        }\n        throw new InternalDataStoreException(super.toString());                 // Should not happen.\n    }\n    /**\n     * Returns whether {@link #setSearchTable setSearchTable(\u2026)} has been invoked.\n     */\n    final boolean isSearchTableDefined() {\n        return searchTable != null;\n    }\n    /**\n     * Returns the columns of the {@linkplain #getSearchTable() search table}\n     * which will need to appear in the {@code WHERE} clause.\n     * For {@link Direction#IMPORT}, they are primary key columns.\n     * For {@link Direction#EXPORT}, they are foreigner key columns.\n     */\n    final Collection<String> getSearchColumns() {\n        return columns.keySet();\n    }\n    /**\n     * Returns the foreigner key columns of the table that contains this relation.\n     * This method should be invoked only for {@link Direction#IMPORT} (otherwise the method name is wrong).\n     * This method returns only the foreigner key columns known to this relation; this is not necessarily\n     * all the enclosing table foreigner keys. Some columns may be used in more than one relation.\n     */\n    final Collection<String> getForeignerKeys() {\n        return columns.values();\n    }\n    /**\n     * Returns {@code true} if this relation includes all required primary key columns. Returns {@code false}\n     * if the foreigner key uses only a subset of the primary key columns, in which case the referenced rows\n     * may not be unique.\n     */\n    final boolean useFullKey() {\n        return useFullKey;\n    }\n    /**\n     * Returns {@code true} if this relation is the inverse of the given relation.\n     * If two relations are inverse, then following those relations recursively would result in an infinite loop.\n     *\n     * <p>This method tests only the column names; the table names shall be verified by the caller.\n     * Table names can be verified as below (see comment in field declarations for meaning of \"owner\"):</p>\n     * <ul>\n     *   <li>{@code this.equals(other.owner.name)}: the target of this relation is the source of other relation.</li>\n     *   <li>{@code this.owner.name.equals(other)}: the source of this relation is the target of other relation.</li>\n     * </ul>\n     *\n     * @param  other  the other relation to check for inverse relationship.\n     */\n    final boolean isInverseOf(final Relation other) {\n        return columns.size() == other.columns.size() &&\n               columns.keySet().containsAll(other.columns.values()) &&\n               other.columns.keySet().containsAll(columns.values());\n    }\n    /**\n     * Adds this relation to the given list, making sure that the relation has not already been added.\n     * The check for previous existence of {@code this}\u00a0relation is for preventing infinite recursivity.\n     */\n<fim_suffix>    final void startFollowing(final List<Relation> following) throws InternalDataStoreException {\n        for (int i = following.size(); --i >= 0;) {\n            if (following.get(i) == this) {\n                throw new InternalDataStoreException(Errors.format(Errors.Keys.CircularReference));\n            }\n        }\n        following.add(this);\n    }<fim_middle>// function below has no smell\n"}