{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\npackage org.apache.hadoop.fs.swift.util;\n\nimport org.slf4j.Logger;\nimport org.apache.hadoop.fs.FileStatus;\nimport org.apache.hadoop.fs.FileSystem;\nimport org.apache.hadoop.fs.Path;\n\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\n\n/**\n * Various utility classes for SwiftFS support\n */\n<fim_suffix>public final class SwiftUtils {\n\n  public static final String READ = \"read(buffer, offset, length)\";\n\n  /**\n   * Join two (non null) paths, inserting a forward slash between them\n   * if needed\n   *\n   * @param path1 first path\n   * @param path2 second path\n   * @return the combined path\n   */\n  public static String joinPaths(String path1, String path2) {\n    StringBuilder result =\n            new StringBuilder(path1.length() + path2.length() + 1);\n    result.append(path1);\n    boolean insertSlash = true;\n    if (path1.endsWith(\"/\")) {\n      insertSlash = false;\n    } else if (path2.startsWith(\"/\")) {\n      insertSlash = false;\n    }\n    if (insertSlash) {\n      result.append(\"/\");\n    }\n    result.append(path2);\n    return result.toString();\n  }\n\n  /**\n   * This test contains the is-directory logic for Swift, so if\n   * changed there is only one place for it.\n   *\n   * @param fileStatus status to examine\n   * @return true if we consider this status to be representative of a\n   *         directory.\n   */\n  public static boolean isDirectory(FileStatus fileStatus) {\n    return fileStatus.isDirectory() || isFilePretendingToBeDirectory(fileStatus);\n  }\n\n  /**\n   * Test for the entry being a file that is treated as if it is a\n   * directory\n   *\n   * @param fileStatus status\n   * @return true if it meets the rules for being a directory\n   */\n  public static boolean isFilePretendingToBeDirectory(FileStatus fileStatus) {\n    return fileStatus.getLen() == 0;\n  }\n\n  /**\n   * Predicate: Is a swift object referring to the root directory?\n   * @param swiftObject object to probe\n   * @return true iff the object refers to the root\n   */\n  public static boolean isRootDir(SwiftObjectPath swiftObject) {\n    return swiftObject.objectMatches(\"\") || swiftObject.objectMatches(\"/\");\n  }\n\n  /**\n   * Sprintf() to the log iff the log is at debug level. If the log\n   * is not at debug level, the printf operation is skipped, so\n   * no time is spent generating the string.\n   * @param log log to use\n   * @param text text message\n   * @param args args arguments to the print statement\n   */\n  public static void debug(Logger log, String text, Object... args) {\n    if (log.isDebugEnabled()) {\n      log.debug(String.format(text, args));\n    }\n  }\n\n  /**\n   * Log an exception (in text and trace) iff the log is at debug\n   * @param log Log to use\n   * @param text text message\n   * @param ex exception\n   */\n  public static void debugEx(Logger log, String text, Exception ex) {\n    if (log.isDebugEnabled()) {\n      log.debug(text + ex, ex);\n    }\n  }\n\n  /**\n   * Sprintf() to the log iff the log is at trace level. If the log\n   * is not at trace level, the printf operation is skipped, so\n   * no time is spent generating the string.\n   * @param log log to use\n   * @param text text message\n   * @param args args arguments to the print statement\n   */\n  public static void trace(Logger log, String text, Object... args) {\n    if (log.isTraceEnabled()) {\n      log.trace(String.format(text, args));\n    }\n  }\n\n  /**\n   * Given a partition number, calculate the partition value.\n   * This is used in the SwiftNativeOutputStream, and is placed\n   * here for tests to be able to calculate the filename of\n   * a partition.\n   * @param partNumber part number\n   * @return a string to use as the filename\n   */\n  public static String partitionFilenameFromNumber(int partNumber) {\n    return String.format(\"%06d\", partNumber);\n  }\n\n  /**\n   * List a a path to string\n   * @param fileSystem filesystem\n   * @param path directory\n   * @return a listing of the filestatuses of elements in the directory, one\n   * to a line, preceded by the full path of the directory\n   * @throws IOException connectivity problems\n   */\n  public static String ls(FileSystem fileSystem, Path path) throws\n                                                            IOException {\n    if (path == null) {\n      //surfaces when someone calls getParent() on something at the top of the path\n      return \"/\";\n    }\n    FileStatus[] stats;\n    String pathtext = \"ls \" + path;\n    try {\n      stats = fileSystem.listStatus(path);\n    } catch (FileNotFoundException e) {\n      return pathtext + \" -file not found\";\n    } catch (IOException e) {\n      return pathtext + \" -failed: \" + e;\n    }\n    return pathtext + fileStatsToString(stats, \"\\n\");\n  }\n\n  /**\n   * Take an array of filestatus and convert to a string (prefixed w/ a [01] counter\n   * @param stats array of stats\n   * @param separator separator after every entry\n   * @return a stringified set\n   */\n  public static String fileStatsToString(FileStatus[] stats, String separator) {\n    StringBuilder buf = new StringBuilder(stats.length * 128);\n    for (int i = 0; i < stats.length; i++) {\n      buf.append(String.format(\"[%02d] %s\", i, stats[i])).append(separator);\n    }\n    return buf.toString();\n  }\n\n  /**\n   * Verify that the basic args to a read operation are valid;\n   * throws an exception if not -with meaningful text including\n   * @param buffer destination buffer\n   * @param off offset\n   * @param len number of bytes to read\n   * @throws NullPointerException null buffer\n   * @throws IndexOutOfBoundsException on any invalid range.\n   */\n  public static void validateReadArgs(byte[] buffer, int off, int len) {\n    if (buffer == null) {\n      throw new NullPointerException(\"Null byte array in\"+ READ);\n    }\n    if (off < 0 ) {\n      throw new IndexOutOfBoundsException(\"Negative buffer offset \"\n                                          + off\n                                          + \" in \" + READ);\n    }\n    if (len < 0 ) {\n      throw new IndexOutOfBoundsException(\"Negative read length \"\n                                          + len\n                                          + \" in \" + READ);\n    }\n    if (off > buffer.length) {\n      throw new IndexOutOfBoundsException(\"Buffer offset of \"\n                                          + off\n                                          + \"beyond buffer size of \"\n                                          + buffer.length\n                                          + \" in \" + READ);\n    }\n  } \n}<fim_middle>// class below is blob\n"}