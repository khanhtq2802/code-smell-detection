{"text": "<fim_prefix>import org.apache.commons.math3.distribution.ZipfDistribution;\n/**\n * This {@link SyntheticOptions} class provides common parameterizable synthetic options that are\n * used by {@link SyntheticBoundedSource} and {@link SyntheticUnboundedSource}.\n */\npublic class SyntheticOptions implements Serializable {\n  private static final long serialVersionUID = 0;\n  /**\n   * The type of Delay that will be produced.\n   *\n   * <p>CPU delay produces a CPU-busy delay. SLEEP delay makes the process sleep.\n   */\n  public enum DelayType {\n    SLEEP,\n    CPU,\n    MIXED,\n  }\n  /**\n   * Wrapper over a distribution. Unfortunately commons-math does not provide a common interface\n   * over both RealDistribution and IntegerDistribution, and we sometimes need one and sometimes the\n   * other.\n   */\n  public interface Sampler extends Serializable {\n    double sample(long seed);\n    // Make this class a bean, so Jackson can serialize it during SyntheticOptions.toString().\n    Object getDistribution();\n  }\n  public static Sampler fromRealDistribution(final RealDistribution dist) {\n    return new Sampler() {\n      private static final long serialVersionUID = 0L;\n      @Override\n      public double sample(long seed) {\n        dist.reseedRandomGenerator(seed);\n        return dist.sample();\n      }\n      @Override\n      public Object getDistribution() {\n        return dist;\n      }\n    };\n  }\n  public static Sampler fromIntegerDistribution(final IntegerDistribution dist) {\n    return new Sampler() {\n      private static final long serialVersionUID = 0L;\n      @Override\n      public double sample(long seed) {\n        dist.reseedRandomGenerator(seed);\n        return dist.sample();\n      }\n      @Override\n      public Object getDistribution() {\n        return dist;\n      }\n    };\n  }\n  private static Sampler scaledSampler(final Sampler sampler, final double multiplier) {\n    return new Sampler() {\n      private static final long serialVersionUID = 0L;\n      @Override\n      public double sample(long seed) {\n        return multiplier * sampler.sample(seed);\n      }\n      @Override\n      public Object getDistribution() {\n        return sampler.getDistribution();\n      }\n    };\n  }\n  /** The key size in bytes. */\n  @JsonProperty public long keySizeBytes = 1;\n  /** The value size in bytes. */\n  @JsonProperty public long valueSizeBytes = 1;\n  /**\n   * The size of a single record used for size estimation in bytes. If less than zero, keySizeBytes\n   * + valueSizeBytes is used.\n   */\n  @JsonProperty public final long bytesPerRecord;\n  /** The number of distinct \"hot\" keys. */\n  @JsonProperty public long numHotKeys;\n  /**\n   * The fraction of records associated with \"hot\" keys, which are uniformly distributed over a\n   * fixed number of hot keys.\n   */\n  @JsonProperty public double hotKeyFraction;\n  /** The fraction of keys that should be larger than others. */\n  @JsonProperty public double largeKeyFraction = 0.0;\n  /** The size of large keys. */\n  @JsonProperty public double largeKeySizeBytes = 1000;\n  /** The seed is used for generating a hash function implementing the 128-bit murmur3 algorithm. */\n  @JsonIgnore public int seed = 1;\n  /**\n   * The hash function is used to generate seeds that are fed into the random number generators and\n   * the sleep time distributions.\n   */\n  @JsonIgnore private transient HashFunction hashFunction;\n  /**\n   * SyntheticOptions supports several delay distributions including uniform, normal, exponential,\n   * and constant delay per record. The delay is either sleep or CPU spinning for the duration.\n   *\n   * <ul>\n   *   <li>The uniform delay distribution is specified through\n   *       \"delayDistribution\":{\"type\":\"uniform\",\"lower\":lower_bound,\"upper\":upper_bound}, where\n   *       lower_bound and upper_bound are non-negative numbers representing the delay range in\n   *       milliseconds.\n   *   <li>The normal delay distribution is specified through\n   *       \"delayDistribution\":{\"type\":\"normal\",\"mean\":mean,\"stddev\":stddev}, where mean is a\n   *       non-negative number representing the mean of this normal distributed delay in\n   *       milliseconds and stddev is a positive number representing its standard deviation.\n   *   <li>The exponential delay distribution is specified through\n   *       \"delayDistribution\":{\"type\":\"exp\",\"mean\":mean}, where mean is a positive number\n   *       representing the mean of this exponentially distributed delay in milliseconds.\n   *   <li>The zipf distribution is specified through\n   *       \"delayDistribution\":{\"type\":\"zipf\",\"param\":param,\"multiplier\":multiplier}, where param is\n   *       a number &gt; 1 and multiplier just scales the output of the distribution. By default,\n   *       the multiplier is 1. Parameters closer to 1 produce dramatically more skewed results.\n   *       E.g. given 100 samples, the min will almost always be 1, while max with param 3 will\n   *       usually be below 10; with param 2 max will usually be between several dozen and several\n   *       hundred; with param 1.5, thousands to millions.\n   *   <li>The constant sleep time per record is specified through\n   *       \"delayDistribution\":{\"type\":\"const\",\"const\":const} where const is a non-negative number\n   *       representing the constant sleep time in milliseconds.\n   * </ul>\n   *\n   * <p>The field delayDistribution is not used in the synthetic unbounded source. The synthetic\n   * unbounded source uses RateLimiter to control QPS.\n   */\n  @JsonDeserialize(using = SamplerDeserializer.class)\n  Sampler delayDistribution = fromRealDistribution(new ConstantRealDistribution(0));\n  /**\n   * When 'delayDistribution' is configured, this indicates how the delay enforced (\"SLEEP\", \"CPU\",\n   * or \"MIXED\").\n   */\n  @JsonProperty public final DelayType delayType = DelayType.SLEEP;\n  /**\n   * CPU utilization when delayType is 'MIXED'. This determines the fraction of processing time\n   * spent spinning. The remaining time is spent sleeping. For each millisecond of processing time\n   * we choose to spin with probability equal to this fraction.\n   */\n  @JsonProperty public final double cpuUtilizationInMixedDelay;\n  SyntheticOptions() {\n    cpuUtilizationInMixedDelay = 0.1;\n    bytesPerRecord = -1;\n  }\n  @JsonDeserialize\n  public void setSeed(int seed) {\n    this.seed = seed;\n  }\n  public HashFunction hashFunction() {\n    // due to field's transiency initialize when null.\n    if (hashFunction == null) {\n      this.hashFunction = Hashing.murmur3_128(seed);\n    }\n    return hashFunction;\n  }\n  static class SamplerDeserializer extends JsonDeserializer<Sampler> {\n<fim_suffix>    @Override\n    public Sampler deserialize(JsonParser jp, DeserializationContext ctxt) throws IOException {\n      JsonNode node = jp.getCodec().readTree(jp);\n      String type = node.get(\"type\").asText();\n      switch (type) {\n        case \"uniform\":\n          {\n            double lowerBound = node.get(\"lower\").asDouble();\n            double upperBound = node.get(\"upper\").asDouble();\n            checkArgument(\n                lowerBound >= 0,\n                \"The lower bound of uniform distribution should be a non-negative number, \"\n                    + \"but found %s.\",\n                lowerBound);\n            return fromRealDistribution(new UniformRealDistribution(lowerBound, upperBound));\n          }\n        case \"exp\":\n          {\n            double mean = node.get(\"mean\").asDouble();\n            return fromRealDistribution(new ExponentialDistribution(mean));\n          }\n        case \"normal\":\n          {\n            double mean = node.get(\"mean\").asDouble();\n            double stddev = node.get(\"stddev\").asDouble();\n            checkArgument(\n                mean >= 0,\n                \"The mean of normal distribution should be a non-negative number, but found %s.\",\n                mean);\n            return fromRealDistribution(new NormalDistribution(mean, stddev));\n          }\n        case \"const\":\n          {\n            double constant = node.get(\"const\").asDouble();\n            checkArgument(\n                constant >= 0,\n                \"The value of constant distribution should be a non-negative number, but found %s.\",\n                constant);\n            return fromRealDistribution(new ConstantRealDistribution(constant));\n          }\n        case \"zipf\":\n          {\n            double param = node.get(\"param\").asDouble();\n            final double multiplier =\n                node.has(\"multiplier\") ? node.get(\"multiplier\").asDouble() : 1.0;\n            checkArgument(\n                param > 1,\n                \"The parameter of the Zipf distribution should be > 1, but found %s.\",\n                param);\n            checkArgument(\n                multiplier >= 0,\n                \"The multiplier of the Zipf distribution should be >= 0, but found %s.\",\n                multiplier);\n            final ZipfDistribution dist = new ZipfDistribution(100, param);\n            return scaledSampler(fromIntegerDistribution(dist), multiplier);\n          }\n        default:\n          {\n            throw new IllegalArgumentException(\"Unknown distribution type: \" + type);\n          }\n      }\n    }<fim_middle>// function below is long method\n"}