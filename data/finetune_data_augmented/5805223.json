{"text": "<fim_prefix>//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\npackage org.apache.tapestry5.ioc.internal;\nimport org.apache.tapestry5.ioc.*;\nimport org.apache.tapestry5.ioc.annotations.EagerLoad;\nimport org.apache.tapestry5.ioc.annotations.Marker;\nimport org.apache.tapestry5.ioc.annotations.PreventServiceDecoration;\nimport org.apache.tapestry5.ioc.annotations.Scope;\nimport org.apache.tapestry5.ioc.def.ServiceDef;\nimport org.apache.tapestry5.ioc.internal.util.CollectionFactory;\nimport org.apache.tapestry5.ioc.internal.util.InternalUtils;\nimport org.apache.tapestry5.ioc.internal.util.OneShotLock;\nimport org.apache.tapestry5.ioc.services.PlasticProxyFactory;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.util.Arrays;\nimport java.util.Set;\n<fim_suffix>@SuppressWarnings(\"all\")\npublic class ServiceBinderImpl implements ServiceBinder, ServiceBindingOptions\n{\n    private final OneShotLock lock = new OneShotLock();\n    private final Method bindMethod;\n    private final ServiceDefAccumulator accumulator;\n    private PlasticProxyFactory proxyFactory;\n    private final Set<Class> defaultMarkers;\n    private final boolean moduleDefaultPreventDecoration;\n    public ServiceBinderImpl(ServiceDefAccumulator accumulator, Method bindMethod, PlasticProxyFactory proxyFactory,\n                             Set<Class> defaultMarkers, boolean moduleDefaultPreventDecoration)\n    {\n        this.accumulator = accumulator;\n        this.bindMethod = bindMethod;\n        this.proxyFactory = proxyFactory;\n        this.defaultMarkers = defaultMarkers;\n        this.moduleDefaultPreventDecoration = moduleDefaultPreventDecoration;\n        clear();\n    }\n    private String serviceId;\n    private Class serviceInterface;\n    private Class serviceImplementation;\n    private final Set<Class> markers = CollectionFactory.newSet();\n    private ObjectCreatorSource source;\n    private boolean eagerLoad;\n    private String scope;\n    private boolean preventDecoration;\n    private boolean preventReloading;\n    public void finish()\n    {\n        lock.lock();\n        flush();\n    }\n    protected void flush()\n    {\n        if (serviceInterface == null)\n            return;\n        // source will be null when the implementation class is provided; non-null when using\n        // a ServiceBuilder callback\n        if (source == null)\n            source = createObjectCreatorSourceFromImplementationClass();\n        // Combine service-specific markers with those inherited form the module.\n        Set<Class> markers = CollectionFactory.newSet(defaultMarkers);\n        markers.addAll(this.markers);\n        ServiceDef serviceDef = new ServiceDefImpl(serviceInterface, serviceImplementation, serviceId, markers, scope,\n                eagerLoad, preventDecoration, source);\n        accumulator.addServiceDef(serviceDef);\n        clear();\n    }\n    private void clear()\n    {\n        serviceId = null;\n        serviceInterface = null;\n        serviceImplementation = null;\n        source = null;\n        this.markers.clear();\n        eagerLoad = false;\n        scope = null;\n        preventDecoration = moduleDefaultPreventDecoration;\n        preventReloading = false;\n    }\n    private ObjectCreatorSource createObjectCreatorSourceFromImplementationClass()\n    {\n        if (InternalUtils.SERVICE_CLASS_RELOADING_ENABLED && !preventReloading && isProxiable() && reloadableScope()\n                && InternalUtils.isLocalFile(serviceImplementation))\n            return createReloadableConstructorBasedObjectCreatorSource();\n        return createStandardConstructorBasedObjectCreatorSource();\n    }\n    private boolean isProxiable()\n    {\n        return serviceInterface.isInterface();\n    }\n    private boolean reloadableScope()\n    {\n        return scope.equalsIgnoreCase(ScopeConstants.DEFAULT);\n    }\n    private ObjectCreatorSource createStandardConstructorBasedObjectCreatorSource()\n    {\n        if (Modifier.isAbstract(serviceImplementation.getModifiers()))\n            throw new RuntimeException(IOCMessages.abstractServiceImplementation(serviceImplementation, serviceId));\n        final Constructor constructor = InternalUtils.findAutobuildConstructor(serviceImplementation);\n        if (constructor == null)\n            throw new RuntimeException(IOCMessages.noConstructor(serviceImplementation, serviceId));\n        return new ObjectCreatorSource()\n        {\n            @Override\n            public ObjectCreator constructCreator(ServiceBuilderResources resources)\n            {\n                return new ConstructorServiceCreator(resources, getDescription(), constructor);\n            }\n            @Override\n            public String getDescription()\n            {\n                return String.format(\"%s via %s\", proxyFactory.getConstructorLocation(constructor),\n                        proxyFactory.getMethodLocation(bindMethod));\n            }\n        };\n    }\n    private ObjectCreatorSource createReloadableConstructorBasedObjectCreatorSource()\n    {\n        return new ReloadableObjectCreatorSource(proxyFactory, bindMethod, serviceInterface, serviceImplementation,\n                eagerLoad);\n    }\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public <T> ServiceBindingOptions bind(Class<T> serviceClass)\n    {\n        if (serviceClass.isInterface())\n        {\n            try\n            {\n                String expectedImplName = serviceClass.getName() + \"Impl\";\n                ClassLoader classLoader = proxyFactory.getClassLoader();\n                Class<T> implementationClass = (Class<T>) classLoader.loadClass(expectedImplName);\n                if (!implementationClass.isInterface() && serviceClass.isAssignableFrom(implementationClass))\n                {\n                    return bind(\n                            serviceClass, implementationClass);\n                }\n                throw new RuntimeException(IOCMessages.noServiceMatchesType(serviceClass));\n            } catch (ClassNotFoundException ex)\n            {\n                throw new RuntimeException(String.format(\"Could not find default implementation class %sImpl. Please provide this class, or bind the service interface to a specific implementation class.\",\n                        serviceClass.getName()));\n            }\n        }\n        return bind(serviceClass, serviceClass);\n    }\n    @Override\n    public <T> ServiceBindingOptions bind(Class<T> serviceInterface, final ServiceBuilder<T> builder)\n    {\n        assert serviceInterface != null;\n        assert builder != null;\n        lock.check();\n        flush();\n        this.serviceInterface = serviceInterface;\n        this.scope = ScopeConstants.DEFAULT;\n        serviceId = serviceInterface.getSimpleName();\n        this.source = new ObjectCreatorSource()\n        {\n            @Override\n            public ObjectCreator constructCreator(final ServiceBuilderResources resources)\n            {\n                return new ObjectCreator()\n                {\n                    @Override\n                    public Object createObject()\n                    {\n                        return builder.buildService(resources);\n                    }\n                };\n            }\n            @Override\n            public String getDescription()\n            {\n                return proxyFactory.getMethodLocation(bindMethod).toString();\n            }\n        };\n        return this;\n    }\n    @Override\n    public <T> ServiceBindingOptions bind(Class<T> serviceInterface, Class<? extends T> serviceImplementation)\n    {\n        assert serviceInterface != null;\n        assert serviceImplementation != null;\n        lock.check();\n        flush();\n        this.serviceInterface = serviceInterface;\n        this.serviceImplementation = serviceImplementation;\n        // Set defaults for the other properties.\n        eagerLoad = serviceImplementation.getAnnotation(EagerLoad.class) != null;\n        serviceId = InternalUtils.getServiceId(serviceImplementation);\n        if (serviceId == null)\n        {\n            serviceId = serviceInterface.getSimpleName();\n        }\n        Scope scope = serviceImplementation.getAnnotation(Scope.class);\n        this.scope = scope != null ? scope.value() : ScopeConstants.DEFAULT;\n        Marker marker = serviceImplementation.getAnnotation(Marker.class);\n        if (marker != null)\n        {\n            InternalUtils.validateMarkerAnnotations(marker.value());\n            markers.addAll(Arrays.asList(marker.value()));\n        }\n        preventDecoration |= serviceImplementation.getAnnotation(PreventServiceDecoration.class) != null;\n        return this;\n    }\n    @Override\n    public ServiceBindingOptions eagerLoad()\n    {\n        lock.check();\n        eagerLoad = true;\n        return this;\n    }\n    @Override\n    public ServiceBindingOptions preventDecoration()\n    {\n        lock.check();\n        preventDecoration = true;\n        return this;\n    }\n    @Override\n    public ServiceBindingOptions preventReloading()\n    {\n        lock.check();\n        preventReloading = true;\n        return this;\n    }\n    @Override\n    public ServiceBindingOptions withId(String id)\n    {\n        assert InternalUtils.isNonBlank(id);\n        lock.check();\n        serviceId = id;\n        return this;\n    }\n    @Override\n    public ServiceBindingOptions withSimpleId()\n    {\n        if (serviceImplementation == null)\n        {\n            throw new IllegalArgumentException(\"No defined implementation class to generate simple id from.\");\n        }\n        return withId(serviceImplementation.getSimpleName());\n    }\n    @Override\n    public ServiceBindingOptions scope(String scope)\n    {\n        assert InternalUtils.isNonBlank(scope);\n        lock.check();\n        this.scope = scope;\n        return this;\n    }\n    @Override\n    public ServiceBindingOptions withMarker(Class<? extends Annotation>... marker)\n    {\n        lock.check();\n        InternalUtils.validateMarkerAnnotations(marker);\n        markers.addAll(Arrays.asList(marker));\n        return this;\n    }\n}<fim_middle>// class below has no smell\n"}