{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.pinot.core.segment.index.column;\n\nimport java.io.IOException;\nimport org.apache.pinot.common.data.FieldSpec;\nimport org.apache.pinot.core.io.reader.DataFileReader;\nimport org.apache.pinot.core.io.reader.SingleColumnSingleValueReader;\nimport org.apache.pinot.core.io.reader.impl.v1.FixedBitMultiValueReader;\nimport org.apache.pinot.core.io.reader.impl.v1.FixedBitSingleValueReader;\nimport org.apache.pinot.core.io.reader.impl.v1.FixedByteChunkSingleValueReader;\nimport org.apache.pinot.core.io.reader.impl.v1.SortedIndexReader;\nimport org.apache.pinot.core.io.reader.impl.v1.SortedIndexReaderImpl;\nimport org.apache.pinot.core.io.reader.impl.v1.VarByteChunkSingleValueReader;\nimport org.apache.pinot.core.segment.index.ColumnMetadata;\nimport org.apache.pinot.core.segment.index.loader.IndexLoadingConfig;\nimport org.apache.pinot.core.segment.index.readers.BitmapInvertedIndexReader;\nimport org.apache.pinot.core.segment.index.readers.BloomFilterReader;\nimport org.apache.pinot.core.segment.index.readers.BytesDictionary;\nimport org.apache.pinot.core.segment.index.readers.DoubleDictionary;\nimport org.apache.pinot.core.segment.index.readers.FloatDictionary;\nimport org.apache.pinot.core.segment.index.readers.ImmutableDictionaryReader;\nimport org.apache.pinot.core.segment.index.readers.IntDictionary;\nimport org.apache.pinot.core.segment.index.readers.InvertedIndexReader;\nimport org.apache.pinot.core.segment.index.readers.LongDictionary;\nimport org.apache.pinot.core.segment.index.readers.OnHeapDoubleDictionary;\nimport org.apache.pinot.core.segment.index.readers.OnHeapFloatDictionary;\nimport org.apache.pinot.core.segment.index.readers.OnHeapIntDictionary;\nimport org.apache.pinot.core.segment.index.readers.OnHeapLongDictionary;\nimport org.apache.pinot.core.segment.index.readers.OnHeapStringDictionary;\nimport org.apache.pinot.core.segment.index.readers.StringDictionary;\nimport org.apache.pinot.core.segment.memory.PinotDataBuffer;\nimport org.apache.pinot.core.segment.store.ColumnIndexType;\nimport org.apache.pinot.core.segment.store.SegmentDirectory;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n\npublic final class PhysicalColumnIndexContainer implements ColumnIndexContainer {\n  private static final Logger LOGGER = LoggerFactory.getLogger(PhysicalColumnIndexContainer.class);\n\n  private final DataFileReader _forwardIndex;\n  private final InvertedIndexReader _invertedIndex;\n  private final ImmutableDictionaryReader _dictionary;\n  private final BloomFilterReader _bloomFilterReader;\n\n  public PhysicalColumnIndexContainer(SegmentDirectory.Reader segmentReader, ColumnMetadata metadata,\n      IndexLoadingConfig indexLoadingConfig)\n      throws IOException {\n    String columnName = metadata.getColumnName();\n    boolean loadInvertedIndex = false;\n    boolean loadOnHeapDictionary = false;\n    boolean loadBloomFilter = false;\n    if (indexLoadingConfig != null) {\n      loadInvertedIndex = indexLoadingConfig.getInvertedIndexColumns().contains(columnName);\n      loadOnHeapDictionary = indexLoadingConfig.getOnHeapDictionaryColumns().contains(columnName);\n      loadBloomFilter = indexLoadingConfig.getBloomFilterColumns().contains(columnName);\n    }\n    PinotDataBuffer fwdIndexBuffer = segmentReader.getIndexFor(columnName, ColumnIndexType.FORWARD_INDEX);\n\n    if (metadata.hasDictionary()) {\n      //bloom filter\n      if (loadBloomFilter) {\n        PinotDataBuffer bloomFilterBuffer = segmentReader.getIndexFor(columnName, ColumnIndexType.BLOOM_FILTER);\n        _bloomFilterReader = new BloomFilterReader(bloomFilterBuffer);\n      } else {\n        _bloomFilterReader = null;\n      }\n      // Dictionary-based index\n      _dictionary = loadDictionary(segmentReader.getIndexFor(columnName, ColumnIndexType.DICTIONARY), metadata,\n          loadOnHeapDictionary);\n      if (metadata.isSingleValue()) {\n        // Single-value\n        if (metadata.isSorted()) {\n          // Sorted\n          SortedIndexReader sortedIndexReader = new SortedIndexReaderImpl(fwdIndexBuffer, metadata.getCardinality());\n          _forwardIndex = sortedIndexReader;\n          _invertedIndex = sortedIndexReader;\n          return;\n        } else {\n          // Unsorted\n          _forwardIndex =\n              new FixedBitSingleValueReader(fwdIndexBuffer, metadata.getTotalDocs(), metadata.getBitsPerElement());\n        }\n      } else {\n        // Multi-value\n        _forwardIndex =\n            new FixedBitMultiValueReader(fwdIndexBuffer, metadata.getTotalDocs(), metadata.getTotalNumberOfEntries(),\n                metadata.getBitsPerElement());\n      }\n      if (loadInvertedIndex) {\n        _invertedIndex =\n            new BitmapInvertedIndexReader(segmentReader.getIndexFor(columnName, ColumnIndexType.INVERTED_INDEX),\n                metadata.getCardinality());\n      } else {\n        _invertedIndex = null;\n      }\n    } else {\n      // Raw index\n      _forwardIndex = loadRawForwardIndex(fwdIndexBuffer, metadata.getDataType());\n      _invertedIndex = null;\n      _dictionary = null;\n      _bloomFilterReader = null;\n    }\n  }\n\n  @Override\n  public DataFileReader getForwardIndex() {\n    return _forwardIndex;\n  }\n\n  @Override\n  public InvertedIndexReader getInvertedIndex() {\n    return _invertedIndex;\n  }\n\n  @Override\n  public ImmutableDictionaryReader getDictionary() {\n    return _dictionary;\n  }\n\n  @Override\n  public BloomFilterReader getBloomFilter() {\n    return _bloomFilterReader;\n  }\n\n<fim_suffix>  private static ImmutableDictionaryReader loadDictionary(PinotDataBuffer dictionaryBuffer, ColumnMetadata metadata,\n      boolean loadOnHeap) {\n    FieldSpec.DataType dataType = metadata.getDataType();\n    if (loadOnHeap) {\n      String columnName = metadata.getColumnName();\n      LOGGER.info(\"Loading on-heap dictionary for column: {}\", columnName);\n    }\n\n    int length = metadata.getCardinality();\n    switch (dataType) {\n      case INT:\n        return (loadOnHeap) ? new OnHeapIntDictionary(dictionaryBuffer, length)\n            : new IntDictionary(dictionaryBuffer, length);\n\n      case LONG:\n        return (loadOnHeap) ? new OnHeapLongDictionary(dictionaryBuffer, length)\n            : new LongDictionary(dictionaryBuffer, length);\n\n      case FLOAT:\n        return (loadOnHeap) ? new OnHeapFloatDictionary(dictionaryBuffer, length)\n            : new FloatDictionary(dictionaryBuffer, length);\n\n      case DOUBLE:\n        return (loadOnHeap) ? new OnHeapDoubleDictionary(dictionaryBuffer, length)\n            : new DoubleDictionary(dictionaryBuffer, length);\n\n      case STRING:\n        int numBytesPerValue = metadata.getColumnMaxLength();\n        byte paddingByte = (byte) metadata.getPaddingCharacter();\n        return loadOnHeap ? new OnHeapStringDictionary(dictionaryBuffer, length, numBytesPerValue, paddingByte)\n            : new StringDictionary(dictionaryBuffer, length, numBytesPerValue, paddingByte);\n\n      case BYTES:\n        numBytesPerValue = metadata.getColumnMaxLength();\n        return new BytesDictionary(dictionaryBuffer, length, numBytesPerValue);\n\n      default:\n        throw new IllegalStateException(\"Illegal data type for dictionary: \" + dataType);\n    }\n  }\n\n  private static SingleColumnSingleValueReader loadRawForwardIndex(PinotDataBuffer forwardIndexBuffer,\n      FieldSpec.DataType dataType) {\n\n    switch (dataType) {\n      case INT:\n      case LONG:\n      case FLOAT:\n      case DOUBLE:\n        return new FixedByteChunkSingleValueReader(forwardIndexBuffer);\n      case STRING:\n      case BYTES:\n        return new VarByteChunkSingleValueReader(forwardIndexBuffer);\n      default:\n        throw new IllegalStateException(\"Illegal data type for raw forward index: \" + dataType);\n    }\n  }\n}<fim_middle>// function below is long method\n"}