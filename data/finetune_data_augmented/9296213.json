{"text": "<fim_prefix>/*\n * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\npackage jdk.nashorn.internal.runtime.arrays;\n\nimport static jdk.nashorn.internal.runtime.ScriptRuntime.UNDEFINED;\nimport java.lang.reflect.Array;\nimport jdk.nashorn.internal.runtime.BitVector;\nimport jdk.nashorn.internal.runtime.UnwarrantedOptimismException;\n\n/**\n * This filter handles the presence of undefined array elements.\n */\nfinal class UndefinedArrayFilter extends ArrayFilter {\n    /** Bit vector tracking undefined slots. */\n    private final BitVector undefined;\n\n    UndefinedArrayFilter(final ArrayData underlying) {\n        super(underlying);\n        this.undefined = new BitVector(underlying.length());\n    }\n\n<fim_suffix>    @Override\n    public ArrayData copy() {\n        final UndefinedArrayFilter copy = new UndefinedArrayFilter(underlying.copy());\n        copy.getUndefined().copy(undefined);\n        return copy;\n    }\n\n    @Override\n    public Object[] asObjectArray() {\n        final Object[] value = super.asObjectArray();\n\n        for (int i = 0; i < value.length; i++) {\n            if (undefined.isSet(i)) {\n                value[i] = UNDEFINED;\n            }\n        }\n\n        return value;\n    }\n\n    @Override\n    public Object asArrayOfType(final Class<?> componentType) {\n        final Object value = super.asArrayOfType(componentType);\n        final Object undefValue = convertUndefinedValue(componentType);\n        final int l = Array.getLength(value);\n        for (int i = 0; i < l; i++) {\n            if (undefined.isSet(i)) {\n                Array.set(value, i,undefValue);\n            }\n        }\n\n        return value;\n    }\n\n    @Override\n    public ArrayData shiftLeft(final int by) {\n        super.shiftLeft(by);\n        undefined.shiftLeft(by, length());\n        return this;\n    }\n\n    @Override\n    public ArrayData shiftRight(final int by) {\n        super.shiftRight(by);\n        undefined.shiftRight(by, length());\n        return this;\n    }\n\n    @Override\n    public ArrayData ensure(final long safeIndex) {\n        if (safeIndex >= SparseArrayData.MAX_DENSE_LENGTH && safeIndex >= length()) {\n            return new SparseArrayData(this, safeIndex + 1);\n        }\n\n        super.ensure(safeIndex);\n        undefined.resize(length());\n\n        return this;\n    }\n\n    @Override\n    public ArrayData shrink(final long newLength) {\n        super.shrink(newLength);\n        undefined.resize(length());\n        return this;\n    }\n\n    @Override\n    public ArrayData set(final int index, final Object value, final boolean strict) {\n        undefined.clear(index);\n\n        if (value == UNDEFINED) {\n            undefined.set(index);\n            return this;\n        }\n\n        return super.set(index, value, strict);\n    }\n\n    @Override\n    public ArrayData set(final int index, final int value, final boolean strict) {\n        undefined.clear(index);\n\n        return super.set(index, value, strict);\n    }\n\n    @Override\n    public ArrayData set(final int index, final double value, final boolean strict) {\n        undefined.clear(index);\n\n        return super.set(index, value, strict);\n    }\n\n    @Override\n    public int getInt(final int index) {\n        if (undefined.isSet(index)) {\n            return 0;\n        }\n\n        return super.getInt(index);\n    }\n\n    @Override\n    public int getIntOptimistic(final int index, final int programPoint) {\n        if (undefined.isSet(index)) {\n            throw new UnwarrantedOptimismException(UNDEFINED, programPoint);\n        }\n\n        return super.getIntOptimistic(index, programPoint);\n    }\n\n    @Override\n    public double getDouble(final int index) {\n        if (undefined.isSet(index)) {\n            return Double.NaN;\n        }\n\n        return super.getDouble(index);\n    }\n\n    @Override\n    public double getDoubleOptimistic(final int index, final int programPoint) {\n        if (undefined.isSet(index)) {\n            throw new UnwarrantedOptimismException(UNDEFINED, programPoint);\n        }\n\n        return super.getDoubleOptimistic(index, programPoint);\n    }\n\n    @Override\n    public Object getObject(final int index) {\n        if (undefined.isSet(index)) {\n            return UNDEFINED;\n        }\n\n        return super.getObject(index);\n    }\n\n    @Override\n    public ArrayData delete(final int index) {\n        undefined.clear(index);\n\n        return super.delete(index);\n    }\n\n    @Override\n    public Object pop() {\n        final long index = length() - 1;\n\n        if (super.has((int)index)) {\n            final boolean isUndefined = undefined.isSet(index);\n            final Object value = super.pop();\n\n            return isUndefined ? UNDEFINED : value;\n        }\n\n        return super.pop();\n    }\n\n    @Override\n    public ArrayData slice(final long from, final long to) {\n        final ArrayData newArray = underlying.slice(from, to);\n        final UndefinedArrayFilter newFilter = new UndefinedArrayFilter(newArray);\n        newFilter.getUndefined().copy(undefined);\n        newFilter.getUndefined().shiftLeft(from, newFilter.length());\n\n        return newFilter;\n    }\n\n    private BitVector getUndefined() {\n        return undefined;\n    }\n}<fim_middle>// function below has no smell\n"}