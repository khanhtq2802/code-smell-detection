{"text": "<fim_prefix>                        entry.sealedKey = (SealedObject) ois.readObject();\n                    } catch (ClassNotFoundException cnfe) {\n                        throw new IOException(cnfe.getMessage());\n                    }\n                    //Add the entry to the list\n                    keyEntries.put(alias, entry);\n                } finally {\n                    if (ois != null) {\n                        ois.close();\n                    } else {\n                        dis.close();\n                    }\n                }\n            }\n        }\n    }\n    private List<XXRangerKeyStore> dbOperationLoad() throws IOException {\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"==> RangerKeyStore.dbOperationLoad()\");\n        }\n        try {\n            if (daoManager != null) {\n                RangerKMSDao rangerKMSDao = new RangerKMSDao(daoManager);\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"<== RangerKeyStore.dbOperationLoad()\");\n                }\n                return rangerKMSDao.getAllKeys();\n            }\n        } catch (Exception e) {\n            logger.error(\"==> RangerKeyStore.dbOperationLoad() error:\", e);\n        }\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"<== RangerKeyStore.dbOperationLoad()\");\n        }\n        return null;\n    }\n    /**\n     * To guard against tampering with the keystore, we append a keyed\n     * hash with a bit of whitener.\n     */\n    private final String SECRET_KEY_HASH_WORD = \"Apache Ranger\";\n    private MessageDigest getKeyedMessageDigest(char[] aKeyPassword)\n            throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        int i, j;\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        byte[] keyPasswordBytes = new byte[aKeyPassword.length * 2];\n        for (i = 0, j = 0; i < aKeyPassword.length; i++) {\n            keyPasswordBytes[j++] = (byte) (aKeyPassword[i] >> 8);\n            keyPasswordBytes[j++] = (byte) aKeyPassword[i];\n        }\n        md.update(keyPasswordBytes);\n        for (i = 0; i < keyPasswordBytes.length; i++)\n            keyPasswordBytes[i] = 0;\n        md.update(SECRET_KEY_HASH_WORD.getBytes(\"UTF8\"));\n        return md;\n    }\n    @Override\n    public void engineSetKeyEntry(String arg0, byte[] arg1, Certificate[] arg2)\n            throws KeyStoreException {\n    }\n    @Override\n    public Certificate engineGetCertificate(String alias) {\n        return null;\n    }\n    @Override\n    public String engineGetCertificateAlias(Certificate cert) {\n        return null;\n    }\n    @Override\n    public Certificate[] engineGetCertificateChain(String alias) {\n        return null;\n    }\n    @Override\n    public boolean engineIsCertificateEntry(String alias) {\n        return false;\n    }\n    @Override\n    public boolean engineIsKeyEntry(String alias) {\n        return false;\n    }\n    @Override\n    public void engineSetCertificateEntry(String alias, Certificate cert)\n            throws KeyStoreException {\n    }\n    @Override\n    public void engineSetKeyEntry(String alias, Key key, char[] password,\n                                  Certificate[] chain) throws KeyStoreException {\n    }\n    //\n    // The method is created to support JKS migration (from hadoop-common KMS keystore to RangerKMS keystore)\n    //\n    private static final String METADATA_FIELDNAME = \"metadata\";\n    private static final int NUMBER_OF_BITS_PER_BYTE = 8;\n    public void engineLoadKeyStoreFile(InputStream stream, char[] storePass,\n                                       char[] keyPass, char[] masterKey, String fileFormat)\n            throws IOException, NoSuchAlgorithmException, CertificateException {\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"==> RangerKeyStoreProvider.engineLoadKeyStoreFile()\");\n        }\n        synchronized (deltaEntries) {\n            KeyStore ks;\n            try {\n                ks = KeyStore.getInstance(fileFormat);\n                ks.load(stream, storePass);\n                deltaEntries.clear();\n                for (Enumeration<String> name = ks.aliases(); name\n                        .hasMoreElements(); ) {\n                    SecretKeyEntry entry = new SecretKeyEntry();\n                    String alias = (String) name.nextElement();\n                    Key k = ks.getKey(alias, keyPass);\n                    if (k instanceof JavaKeyStoreProvider.KeyMetadata) {\n                        JavaKeyStoreProvider.KeyMetadata keyMetadata = (JavaKeyStoreProvider.KeyMetadata) k;\n                        Field f = JavaKeyStoreProvider.KeyMetadata.class\n                                .getDeclaredField(METADATA_FIELDNAME);\n                        f.setAccessible(true);\n                        Metadata metadata = (Metadata) f.get(keyMetadata);\n                        entry.bit_length = metadata.getBitLength();\n                        entry.cipher_field = metadata.getAlgorithm();\n                        Constructor<RangerKeyStoreProvider.KeyMetadata> constructor = RangerKeyStoreProvider.KeyMetadata.class\n                                .getDeclaredConstructor(Metadata.class);\n                        constructor.setAccessible(true);\n                        RangerKeyStoreProvider.KeyMetadata nk = constructor\n                                .newInstance(metadata);\n                        k = nk;\n                    } else {\n                        entry.bit_length = (k.getEncoded().length * NUMBER_OF_BITS_PER_BYTE);\n                        entry.cipher_field = k.getAlgorithm();\n                    }\n                    String keyName = alias.split(\"@\")[0];\n                    validateKeyName(keyName);\n                    entry.attributes = \"{\\\"key.acl.name\\\":\\\"\" + keyName + \"\\\"}\";\n                    Class<?> c = null;\n                    Object o = null;\n                    try {\n                        c = Class\n                                .forName(\"com.sun.crypto.provider.KeyProtector\");\n                        Constructor<?> constructor = c\n                                .getDeclaredConstructor(char[].class);\n                        constructor.setAccessible(true);\n                        o = constructor.newInstance(masterKey);\n                        // seal and store the key\n                        Method m = c.getDeclaredMethod(\"seal\", Key.class);\n                        m.setAccessible(true);\n                        entry.sealedKey = (SealedObject) m.invoke(o, k);\n                    } catch (ClassNotFoundException | NoSuchMethodException\n                            | SecurityException | InstantiationException\n                            | IllegalAccessException | IllegalArgumentException\n                            | InvocationTargetException e) {\n                        logger.error(e.getMessage());\n                        throw new IOException(e.getMessage());\n                    }\n                    entry.date = ks.getCreationDate(alias);\n                    entry.version = (alias.split(\"@\").length == 2) ? (Integer\n                            .parseInt(alias.split(\"@\")[1])) : 0;\n                    entry.description = k.getFormat() + \" - \" + ks.getType();\n                    deltaEntries.put(alias, entry);\n                }\n            } catch (Throwable t) {\n                logger.error(\"Unable to load keystore file \", t);\n                throw new IOException(t);\n            }\n        }\n    }\n    public void engineLoadToKeyStoreFile(OutputStream stream, char[] storePass,\n                                         char[] keyPass, char[] masterKey, String fileFormat)\n            throws IOException, NoSuchAlgorithmException, CertificateException {\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"==> RangerKeyStoreProvider.engineLoadToKeyStoreFile()\");\n        }\n        synchronized (keyEntries) {\n            KeyStore ks;\n            try {\n                ks = KeyStore.getInstance(fileFormat);\n                if (ks != null) {\n                    ks.load(null, storePass);\n                    String alias = null;\n                    engineLoad(null, masterKey);\n                    Enumeration<String> e = engineAliases();\n                    Key key;\n                    while (e.hasMoreElements()) {\n                        alias = e.nextElement();\n                        key = engineGetKey(alias, masterKey);\n                        ks.setKeyEntry(alias, key, keyPass, null);\n                    }\n                    ks.store(stream, storePass);\n                }\n            } catch (Throwable t) {\n                logger.error(\"Unable to load keystore file \", t);\n                throw new IOException(t);\n            }\n        }\n    }\n    private void validateKeyName(String name) {\n        Matcher matcher = pattern.matcher(name);\n        if (!matcher.matches()) {\n            throw new IllegalArgumentException(\n                    \"Key Name : \"\n                            + name\n                            + \", should start with alpha/numeric letters and can have special characters - (hypen) or _ (underscore)\");\n        }\n    }\n    public void clearDeltaEntires() {\n        deltaEntries.clear();\n    }\n    /**\n     * Encapsulate the encrypted key, so that we can retrieve the AlgorithmParameters object on the decryption side\n     */\n<fim_suffix>    private static class RangerSealedObject extends SealedObject {\n        /**\n         *\n         */\n        private static final long serialVersionUID = -7551578543434362070L;\n        protected RangerSealedObject(SealedObject so) {\n            super(so);\n        }\n        protected RangerSealedObject(Serializable object, Cipher cipher) throws IllegalBlockSizeException, IOException {\n            super(object, cipher);\n        }\n        public AlgorithmParameters getParameters() throws NoSuchAlgorithmException, IOException {\n            AlgorithmParameters algorithmParameters = AlgorithmParameters.getInstance(\"PBEWithMD5AndTripleDES\");\n            algorithmParameters.init(super.encodedParams);\n            return algorithmParameters;\n        }\n    }<fim_middle>// class below has no smell\n"}