{"text": "<fim_prefix>                        final Category logger,\n                        final long timeStamp,\n                        final Level level,\n                        final Object message,\n                        final String threadName,\n                        final ThrowableInformation throwable,\n                        final String ndc,\n                        final LocationInfo info,\n                        final java.util.Map properties) {\n      super();\n      this.fqnOfCategoryClass = fqnOfCategoryClass;\n      this.logger = logger;\n      if (logger != null) {\n          categoryName = logger.getName();\n      } else {\n          categoryName = null;\n      }\n      this.level = level;\n      this.message = message;\n      if(throwable != null) {\n        this.throwableInfo = throwable;\n      }\n      this.timeStamp = timeStamp;\n      this.threadName = threadName;\n      ndcLookupRequired = false;\n      this.ndc = ndc;\n      this.locationInfo = info;\n      mdcCopyLookupRequired = false;\n      if (properties != null) {\n        mdcCopy = new java.util.Hashtable(properties);\n      }\n    }\n  /**\n     Set the location information for this logging event. The collected\n     information is cached for future use.\n   */\n  public LocationInfo getLocationInformation() {\n    if(locationInfo == null) {\n      locationInfo = new LocationInfo(new Throwable(), fqnOfCategoryClass);\n    }\n    return locationInfo;\n  }\n  /**\n   * Return the level of this event. Use this form instead of directly\n   * accessing the <code>level</code> field.  */\n  public Level getLevel() {\n    return (Level) level;\n  }\n  /**\n   * Return the name of the logger. Use this form instead of directly\n   * accessing the <code>categoryName</code> field.  \n   */\n  public String getLoggerName() {\n    return categoryName;\n  }\n    /**\n     * Gets the logger of the event.\n     * Use should be restricted to cloning events.\n     * @since 1.2.15\n     */\n    public Category getLogger() {\n      return logger;\n    }\n  /**\n     Return the message for this logging event.\n     <p>Before serialization, the returned object is the message\n     passed by the user to generate the logging event. After\n     serialization, the returned value equals the String form of the\n     message possibly after object rendering.\n     @since 1.1 */\n  public\n  Object getMessage() {\n    if(message != null) {\n      return message;\n    } else {\n      return getRenderedMessage();\n    }\n  }\n  /**\n   * This method returns the NDC for this event. It will return the\n   * correct content even if the event was generated in a different\n   * thread or even on a different machine. The {@link NDC#get} method\n   * should <em>never</em> be called directly.  */\n  public\n  String getNDC() {\n    if(ndcLookupRequired) {\n      ndcLookupRequired = false;\n      ndc = NDC.get();\n    }\n    return ndc;\n  }\n  /**\n      Returns the the context corresponding to the <code>key</code>\n      parameter. If there is a local MDC copy, possibly because we are\n      in a logging server or running inside AsyncAppender, then we\n      search for the key in MDC copy, if a value is found it is\n      returned. Otherwise, if the search in MDC copy returns a null\n      result, then the current thread's <code>MDC</code> is used.\n      <p>Note that <em>both</em> the local MDC copy and the current\n      thread's MDC are searched.\n  */\n  public\n  Object getMDC(String key) {\n    Object r;\n    // Note the mdcCopy is used if it exists. Otherwise we use the MDC\n    // that is associated with the thread.\n    if(mdcCopy != null) {\n      r = mdcCopy.get(key);\n      if(r != null) {\n        return r;\n      }\n    }\n    return MDC.get(key);\n  }\n  /**\n     Obtain a copy of this thread's MDC prior to serialization or\n     asynchronous logging.  \n  */\n  public\n  void getMDCCopy() {\n    if(mdcCopyLookupRequired) {\n      mdcCopyLookupRequired = false;\n      // the clone call is required for asynchronous logging.\n      // See also bug #5932.\n      Hashtable t = MDC.getContext();\n      if(t != null) {\n\tmdcCopy = (Hashtable) t.clone();\n      }\n    }\n  }\n  public\n  String getRenderedMessage() {\n     if(renderedMessage == null && message != null) {\n       if(message instanceof String) {\n        renderedMessage = (String) message;\n    } else {\n\t LoggerRepository repository = logger.getLoggerRepository();\n\t if(repository instanceof RendererSupport) {\n\t   RendererSupport rs = (RendererSupport) repository;\n\t   renderedMessage= rs.getRendererMap().findAndRender(message);\n\t } else {\n\t   renderedMessage = message.toString();\n\t }\n       }\n     }\n     return renderedMessage;\n  }\n  /**\n     Returns the time when the application started, in milliseconds\n     elapsed since 01.01.1970.  */\n  public static long getStartTime() {\n    return startTime;\n  }\n  public\n  String getThreadName() {\n    if(threadName == null) {\n        threadName = (Thread.currentThread()).getName();\n    }\n    return threadName;\n  }\n  /**\n     Returns the throwable information contained within this\n     event. May be <code>null</code> if there is no such information.\n     <p>Note that the {@link Throwable} object contained within a\n     {@link ThrowableInformation} does not survive serialization.\n     @since 1.1 */\n  public\n  ThrowableInformation getThrowableInformation() {\n    return throwableInfo;\n  }\n  /**\n     Return this event's throwable's string[] representaion.\n  */\n  public\n  String[] getThrowableStrRep() {\n    if(throwableInfo ==  null) {\n        return null;\n    } else {\n        return throwableInfo.getThrowableStrRep();\n    }\n  }\n  private\n  void readLevel(ObjectInputStream ois)\n                      throws java.io.IOException, ClassNotFoundException {\n    int p = ois.readInt();\n    try {\n      String className = (String) ois.readObject();\n      if(className == null) {\n\tlevel = Level.toLevel(p);\n      } else {\n\tMethod m = (Method) methodCache.get(className);\n\tif(m == null) {\n\t  Class clazz = Loader.loadClass(className);\n\t  // Note that we use Class.getDeclaredMethod instead of\n\t  // Class.getMethod. This assumes that the Level subclass\n\t  // implements the toLevel(int) method which is a\n\t  // requirement. Actually, it does not make sense for Level\n\t  // subclasses NOT to implement this method. Also note that\n\t  // only Level can be subclassed and not Priority.\n\t  m = clazz.getDeclaredMethod(TO_LEVEL, TO_LEVEL_PARAMS);\n\t  methodCache.put(className, m);\n\t}\n\tlevel = (Level) m.invoke(null,  new Integer[] { new Integer(p) } );\n      }\n    } catch(InvocationTargetException e) {\n        if (e.getTargetException() instanceof InterruptedException\n                || e.getTargetException() instanceof InterruptedIOException) {\n            Thread.currentThread().interrupt();\n        }\n    LogLog.warn(\"Level deserialization failed, reverting to default.\", e);\n\tlevel = Level.toLevel(p);\n    } catch(NoSuchMethodException e) {\n\tLogLog.warn(\"Level deserialization failed, reverting to default.\", e);\n\tlevel = Level.toLevel(p);\n    } catch(IllegalAccessException e) {\n\tLogLog.warn(\"Level deserialization failed, reverting to default.\", e);\n\tlevel = Level.toLevel(p);\n    } catch(RuntimeException e) {\n\tLogLog.warn(\"Level deserialization failed, reverting to default.\", e);\n\tlevel = Level.toLevel(p);\n    }\n  }\n  private void readObject(ObjectInputStream ois)\n                        throws java.io.IOException, ClassNotFoundException {\n    ois.defaultReadObject();\n    readLevel(ois);\n    // Make sure that no location info is available to Layouts\n    if(locationInfo == null) {\n        locationInfo = new LocationInfo(null, null);\n    }\n  }\n<fim_suffix>  private\n  void writeObject(ObjectOutputStream oos) throws java.io.IOException {\n    // Aside from returning the current thread name the wgetThreadName\n    // method sets the threadName variable.\n    this.getThreadName();\n    // This sets the renders the message in case it wasn't up to now.\n    this.getRenderedMessage();\n    // This call has a side effect of setting this.ndc and\n    // setting ndcLookupRequired to false if not already false.\n    this.getNDC();\n    // This call has a side effect of setting this.mdcCopy and\n    // setting mdcLookupRequired to false if not already false.\n    this.getMDCCopy();\n    // This sets the throwable sting representation of the event throwable.\n    this.getThrowableStrRep();\n    oos.defaultWriteObject();\n    // serialize this event's level\n    writeLevel(oos);\n  }<fim_middle>// function below has no smell\n"}