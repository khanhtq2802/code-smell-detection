{"text": "<fim_prefix>import java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.zip.GZIPInputStream;\n/**\n * @version $Rev$ $Date$\n */\npublic class KeepAliveServer implements ServerService {\n    private static final Logger logger = Logger.getInstance(LogCategory.OPENEJB_SERVER.createChild(\"keepalive\"), KeepAliveServer.class);\n    private final ServerService service;\n    private final long timeout = (1000 * 10);\n    private final AtomicBoolean running = new AtomicBoolean(false);\n    private final ConcurrentHashMap<Thread, Session> sessions = new ConcurrentHashMap<>();\n    private BlockingQueue<Runnable> threadQueue;\n    private Timer timer;\n    private final boolean gzip;\n    @SuppressWarnings(\"deprecation\")\n    public KeepAliveServer() {\n        this(new EjbServer());\n    }\n    @Deprecated\n    public KeepAliveServer(final ServerService service) {\n        this(service, false);\n    }\n    public KeepAliveServer(final ServerService service, final boolean gzip) {\n        this.service = service;\n        this.gzip = gzip;\n    }\n    private void closeInactiveSessions() {\n        if (!this.running.get()) {\n            return;\n        }\n        final BlockingQueue<Runnable> queue = this.getQueue();\n        if (queue == null) {\n            return;\n        }\n        int backlog = queue.size();\n        if (backlog <= 0) {\n            return;\n        }\n        final long now = System.currentTimeMillis();\n        final List<Session> current = new ArrayList<Session>();\n        current.addAll(this.sessions.values());\n        for (final Session session : current) {\n            final Lock l = session.lock;\n            if (l.tryLock()) {\n                try {\n                    if (now - session.lastRequest.get() > this.timeout) {\n                        backlog--;\n                        try {\n                            session.close();\n                        } catch (Throwable e) {\n                            //Ignore\n                        } finally {\n                            this.removeSession(session);\n                        }\n                    }\n                } finally {\n                    l.unlock();\n                }\n            }\n            if (backlog <= 0) {\n                return;\n            }\n        }\n    }\n    public void closeSessions() {\n        // Close the ones we can\n        final List<Session> current = new ArrayList<>();\n        current.addAll(this.sessions.values());\n        for (final Session session : current) {\n            final Lock l = session.lock;\n            if (l.tryLock()) {\n                try {\n                    session.close();\n                } catch (Throwable e) {\n                    //Ignore\n                } finally {\n                    this.removeSession(session);\n                    l.unlock();\n                }\n            } else if (logger.isDebugEnabled()) {\n                try {\n                    logger.debug(\"Allowing graceful shutdown of \" + session.socket.getInetAddress());\n                } catch (Throwable e) {\n                    //Ignore\n                }\n            }\n        }\n        this.sessions.clear();\n    }\n    private BlockingQueue<Runnable> getQueue() {\n        if (this.threadQueue == null) {\n            // this can be null if timer fires before service is fully initialized\n            final ServicePool incoming = Unwrappable.class.isInstance(service) ? Unwrappable.class.cast(service).unwrap(ServicePool.class) : null;\n            if (incoming == null) {\n                return null;\n            }\n            this.threadQueue = incoming.getThreadPool().getQueue();\n        }\n        return this.threadQueue;\n    }\n    /**\n     *\n     * @param session\n     * @return\n     */\n    public Session addSession(final Session session) {\n        return this.sessions.put(session.thread, session);\n    }\n    /**\n     *\n     * @param session\n     * @return\n     */\n    public Session removeSession(final Session session) {\n        return this.sessions.remove(session.thread);\n    }\n    public class KeepAliveTimer extends TimerTask {\n        private final KeepAliveServer kas;\n        public KeepAliveTimer(final org.apache.openejb.server.ejbd.KeepAliveServer kas) {\n            this.kas = kas;\n        }\n        @Override\n        public void run() {\n            this.kas.closeInactiveSessions();\n        }\n    }\n    private class Session {\n        private final Thread thread;\n        private final KeepAliveServer kas;\n        private final Lock lock = new ReentrantLock();\n        // only used inside the Lock\n        private final AtomicLong lastRequest;\n        private final Socket socket;\n        private InputStream in = null;\n        private OutputStream out = null;\n        private Session(final KeepAliveServer kas, final Socket socket) {\n            this.kas = kas;\n            this.socket = socket;\n            this.lastRequest = new AtomicLong(System.currentTimeMillis());\n            this.thread = Thread.currentThread();\n        }\n        @Override\n        protected void finalize() throws Throwable {\n            try {\n                this.close();\n            } finally {\n                super.finalize();\n            }\n        }\n        private void service() throws ServiceException, IOException {\n            this.kas.addSession(this);\n            int i = -1;\n            try {\n                final Lock l1 = this.lock;\n                l1.lock();\n                try {\n                    if (!KeepAliveServer.this.gzip) {\n                        in = new BufferedInputStream(socket.getInputStream());\n                        out = new BufferedOutputStream(socket.getOutputStream());\n                    } else {\n                        in = new GZIPInputStream(new BufferedInputStream(socket.getInputStream()));\n                        out = new BufferedOutputStream(new FlushableGZIPOutputStream(socket.getOutputStream()));\n                    }\n                } finally {\n                    l1.unlock();\n                }\n                while (KeepAliveServer.this.running.get()) {\n                    try {\n                        i = in.read();\n                    } catch (SocketException e) {\n                        // Socket closed.\n                        break;\n                    }\n                    if (i == -1) {\n                        // client hung up\n                        break;\n                    }\n                    final KeepAliveStyle style = KeepAliveStyle.values()[i];\n                    final Lock l2 = this.lock;\n                    l2.lock();\n                    try {\n                        switch (style) {\n                            case PING_PING: {\n                                i = in.read();\n                                break;\n                            }\n                            case PING_PONG: {\n                                out.write(style.ordinal());\n                                out.flush();\n                                break;\n                            }\n                        }\n                        try {\n                            KeepAliveServer.this.service.service(new Input(in), new Output(out));\n                            out.flush();\n                        } catch (SocketException e) {\n                            // Socket closed.\n                            break;\n                        }\n                    } finally {\n                        this.lastRequest.set(System.currentTimeMillis());\n                        l2.unlock();\n                    }\n                }\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new IOException(\"Unexpected byte \" + i);\n            } catch (InterruptedIOException e) {\n                Thread.interrupted();\n            } finally {\n                close();\n                this.kas.removeSession(this);\n            }\n        }\n        private void close() {\n            if (null != in) {\n                try {\n                    in.close();\n                } catch (Throwable e) {\n                    //ignore\n                }\n            }\n            if (null != out) {\n                try {\n                    out.close();\n                } catch (Throwable e) {\n                    //ignore\n                }\n            }\n            if (null != socket) {\n                try {\n                    socket.close();\n                } catch (Throwable e) {\n                    //ignore\n                }\n            }\n        }\n    }\n    @Override\n    public void service(final Socket socket) throws ServiceException, IOException {\n        RequestInfos.initRequestInfo(socket);\n        try {\n            new Session(this, socket).service();\n        } finally {\n            RequestInfos.clearRequestInfo();\n        }\n    }\n    @Override\n    public void service(final InputStream in, final OutputStream out) throws ServiceException, IOException {\n    }\n    @Override\n    public String getIP() {\n        return this.service.getIP();\n    }\n    @Override\n    public String getName() {\n        return this.service.getName();\n    }\n    @Override\n    public int getPort() {\n        return this.service.getPort();\n    }\n    @Override\n    public void start() throws ServiceException {\n        if (!this.running.getAndSet(true)) {\n            this.timer = new Timer(\"KeepAliveTimer\", true);\n            this.timer.scheduleAtFixedRate(new KeepAliveTimer(this), this.timeout, (this.timeout / 2));\n        }\n    }\n    @Override\n    public void stop() throws ServiceException {\n        if (this.running.getAndSet(false)) {\n            try {\n                this.closeSessions();\n            } catch (Throwable e) {\n                //Ignore\n            }\n            try {\n                this.timer.cancel();\n            } catch (Throwable e) {\n                //Ignore\n            }\n        }\n    }\n    @Override\n    public void init(final Properties props) throws Exception {\n        this.service.init(props);\n    }\n<fim_suffix>    public class Input extends java.io.FilterInputStream {\n        public Input(final InputStream in) {\n            super(in);\n        }\n        @Override\n        public void close() throws IOException {\n        }\n    }<fim_middle>// class below has no smell\n"}