{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\nimport org.apache.camel.AggregationStrategy;\nimport org.apache.camel.AsyncCallback;\nimport org.apache.camel.AsyncProcessor;\nimport org.apache.camel.AsyncProducer;\nimport org.apache.camel.CamelContext;\nimport org.apache.camel.CamelContextAware;\nimport org.apache.camel.CamelExchangeException;\nimport org.apache.camel.Endpoint;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.ExchangePattern;\nimport org.apache.camel.Expression;\nimport org.apache.camel.impl.DefaultProducerCache;\nimport org.apache.camel.spi.EndpointUtilizationStatistics;\nimport org.apache.camel.spi.IdAware;\nimport org.apache.camel.spi.ProducerCache;\nimport org.apache.camel.support.AsyncProcessorConverterHelper;\nimport org.apache.camel.support.AsyncProcessorSupport;\nimport org.apache.camel.support.DefaultExchange;\nimport org.apache.camel.support.EventHelper;\nimport org.apache.camel.support.ExchangeHelper;\nimport org.apache.camel.support.service.ServiceHelper;\nimport org.apache.camel.util.StopWatch;\nimport static org.apache.camel.support.ExchangeHelper.copyResultsPreservePattern;\n/**\n * A content enricher that enriches input data by first obtaining additional\n * data from a <i>resource</i> represented by an endpoint <code>producer</code>\n * and second by aggregating input data and additional data. Aggregation of\n * input data and additional data is delegated to an {@link AggregationStrategy}\n * object.\n * <p/>\n * Uses a {@link org.apache.camel.Producer} to obtain the additional data as opposed to {@link PollEnricher}\n * that uses a {@link org.apache.camel.PollingConsumer}.\n *\n * @see PollEnricher\n */\npublic class Enricher extends AsyncProcessorSupport implements IdAware, CamelContextAware {\n    private CamelContext camelContext;\n    private String id;\n    private ProducerCache producerCache;\n    private final Expression expression;\n    private AggregationStrategy aggregationStrategy;\n    private boolean aggregateOnException;\n    private boolean shareUnitOfWork;\n    private int cacheSize;\n    private boolean ignoreInvalidEndpoint;\n    public Enricher(Expression expression) {\n        this.expression = expression;\n    }\n    public CamelContext getCamelContext() {\n        return camelContext;\n    }\n    public void setCamelContext(CamelContext camelContext) {\n        this.camelContext = camelContext;\n    }\n    public String getId() {\n        return id;\n    }\n    public void setId(String id) {\n        this.id = id;\n    }\n    public Expression getExpression() {\n        return expression;\n    }\n    public EndpointUtilizationStatistics getEndpointUtilizationStatistics() {\n        return producerCache.getEndpointUtilizationStatistics();\n    }\n    public void setAggregationStrategy(AggregationStrategy aggregationStrategy) {\n        this.aggregationStrategy = aggregationStrategy;\n    }\n<fim_suffix>    public AggregationStrategy getAggregationStrategy() {\n        return aggregationStrategy;\n    }\n    public boolean isAggregateOnException() {\n        return aggregateOnException;\n    }\n    public void setAggregateOnException(boolean aggregateOnException) {\n        this.aggregateOnException = aggregateOnException;\n    }\n    public boolean isShareUnitOfWork() {\n        return shareUnitOfWork;\n    }\n    public void setShareUnitOfWork(boolean shareUnitOfWork) {\n        this.shareUnitOfWork = shareUnitOfWork;\n    }\n    public int getCacheSize() {\n        return cacheSize;\n    }\n    public void setCacheSize(int cacheSize) {\n        this.cacheSize = cacheSize;\n    }\n    public boolean isIgnoreInvalidEndpoint() {\n        return ignoreInvalidEndpoint;\n    }\n    public void setIgnoreInvalidEndpoint(boolean ignoreInvalidEndpoint) {\n        this.ignoreInvalidEndpoint = ignoreInvalidEndpoint;\n    }\n    /**\n     * Enriches the input data (<code>exchange</code>) by first obtaining\n     * additional data from an endpoint represented by an endpoint\n     * <code>producer</code> and second by aggregating input data and additional\n     * data. Aggregation of input data and additional data is delegated to an\n     * {@link AggregationStrategy} object set at construction time. If the\n     * message exchange with the resource endpoint fails then no aggregation\n     * will be done and the failed exchange content is copied over to the\n     * original message exchange.\n     *\n     * @param exchange input data.\n     */\n    public boolean process(final Exchange exchange, final AsyncCallback callback) {\n        // which producer to use\n        final AsyncProducer producer;\n        final Endpoint endpoint;\n        // use dynamic endpoint so calculate the endpoint to use\n        Object recipient = null;\n        try {\n            recipient = expression.evaluate(exchange, Object.class);\n            endpoint = resolveEndpoint(exchange, recipient);\n            // acquire the consumer from the cache\n            producer = producerCache.acquireProducer(endpoint);\n        } catch (Throwable e) {\n            if (isIgnoreInvalidEndpoint()) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Endpoint uri is invalid: \" + recipient + \". This exception will be ignored.\", e);\n                }\n            } else {\n                exchange.setException(e);\n            }\n            callback.done(true);\n            return true;\n        }\n        final Exchange resourceExchange = createResourceExchange(exchange, ExchangePattern.InOut);\n        final Endpoint destination = producer.getEndpoint();\n        StopWatch sw = null;\n        boolean sending = EventHelper.notifyExchangeSending(exchange.getContext(), resourceExchange, destination);\n        if (sending) {\n            sw = new StopWatch();\n        }\n        // record timing for sending the exchange using the producer\n        final StopWatch watch = sw;\n        AsyncProcessor ap = AsyncProcessorConverterHelper.convert(producer);\n        boolean sync = ap.process(resourceExchange, new AsyncCallback() {\n            public void done(boolean doneSync) {\n                // we only have to handle async completion of the routing slip\n                if (doneSync) {\n                    return;\n                }\n                // emit event that the exchange was sent to the endpoint\n                if (watch != null) {\n                    long timeTaken = watch.taken();\n                    EventHelper.notifyExchangeSent(resourceExchange.getContext(), resourceExchange, destination, timeTaken);\n                }\n                if (!isAggregateOnException() && resourceExchange.isFailed()) {\n                    // copy resource exchange onto original exchange (preserving pattern)\n                    copyResultsPreservePattern(exchange, resourceExchange);\n                } else {\n                    prepareResult(exchange);\n                    try {\n                        // prepare the exchanges for aggregation\n                        ExchangeHelper.prepareAggregation(exchange, resourceExchange);\n                        Exchange aggregatedExchange = aggregationStrategy.aggregate(exchange, resourceExchange);\n                        if (aggregatedExchange != null) {\n                            // copy aggregation result onto original exchange (preserving pattern)\n                            copyResultsPreservePattern(exchange, aggregatedExchange);\n                        }\n                    } catch (Throwable e) {\n                        // if the aggregationStrategy threw an exception, set it on the original exchange\n                        exchange.setException(new CamelExchangeException(\"Error occurred during aggregation\", exchange, e));\n                        callback.done(false);\n                        // we failed so break out now\n                        return;\n                    }\n                }\n                // set property with the uri of the endpoint enriched so we can use that for tracing etc\n                exchange.setProperty(Exchange.TO_ENDPOINT, producer.getEndpoint().getEndpointUri());\n                // return the producer back to the cache\n                try {\n                    producerCache.releaseProducer(endpoint, producer);\n                } catch (Exception e) {\n                    // ignore\n                }\n                callback.done(false);\n            }\n        });\n        if (!sync) {\n            log.trace(\"Processing exchangeId: {} is continued being processed asynchronously\", exchange.getExchangeId());\n            // the remainder of the routing slip will be completed async\n            // so we break out now, then the callback will be invoked which then continue routing from where we left here\n            return false;\n        }\n        log.trace(\"Processing exchangeId: {} is continued being processed synchronously\", exchange.getExchangeId());\n        if (watch != null) {\n            // emit event that the exchange was sent to the endpoint\n            long timeTaken = watch.taken();\n            EventHelper.notifyExchangeSent(resourceExchange.getContext(), resourceExchange, destination, timeTaken);\n        }\n        if (!isAggregateOnException() && resourceExchange.isFailed()) {\n            // copy resource exchange onto original exchange (preserving pattern)\n            copyResultsPreservePattern(exchange, resourceExchange);\n        } else {\n            prepareResult(exchange);\n            try {\n                // prepare the exchanges for aggregation<fim_middle>// function below has no smell\n"}