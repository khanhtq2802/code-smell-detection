{"text": "<fim_prefix>      {\n        int nodeID = makeNodeIdentity(node);\n        m_size = 0;\n        if (nodeID == DTM.NULL) {\n          _currentNode = DTM.NULL;\n          m_ancestorsPos = 0;\n          return this;\n        }\n        final int nodeType = _nodeType;\n        if (!_includeSelf) {\n          nodeID = _parent2(nodeID);\n          node = makeNodeHandle(nodeID);\n        }\n        _startNode = node;\n        if (nodeType >= DTM.NTYPES) {\n          while (nodeID != END) {\n            int eType = _exptype2(nodeID);\n            if (eType == nodeType) {\n              if (m_size >= m_ancestors.length)\n              {\n              \tint[] newAncestors = new int[m_size * 2];\n              \tSystem.arraycopy(m_ancestors, 0, newAncestors, 0, m_ancestors.length);\n              \tm_ancestors = newAncestors;\n              }\n              m_ancestors[m_size++] = makeNodeHandle(nodeID);\n            }\n            nodeID = _parent2(nodeID);\n          }\n        }\n        else {\n          while (nodeID != END) {\n            int eType = _exptype2(nodeID);\n            if ((eType < DTM.NTYPES && eType == nodeType)\n                || (eType >= DTM.NTYPES\n                    && m_extendedTypes[eType].getNodeType() == nodeType)) {\n              if (m_size >= m_ancestors.length)\n              {\n              \tint[] newAncestors = new int[m_size * 2];\n              \tSystem.arraycopy(m_ancestors, 0, newAncestors, 0, m_ancestors.length);\n              \tm_ancestors = newAncestors;\n              }\n              m_ancestors[m_size++] = makeNodeHandle(nodeID);\n            }\n            nodeID = _parent2(nodeID);\n          }\n        }\n        m_ancestorsPos = m_size - 1;\n        _currentNode = (m_ancestorsPos>=0)\n                               ? m_ancestors[m_ancestorsPos]\n                               : DTM.NULL;\n        return resetPosition();\n      }\n      return this;\n    }\n    /**\n     * Return the node at the given position.\n     */\n    public int getNodeByPosition(int position)\n    {\n      if (position > 0 && position <= m_size) {\n        return m_ancestors[position-1];\n      }\n      else\n        return DTM.NULL;\n    }\n    /**\n     * Returns the position of the last node within the iteration, as\n     * defined by XPath.\n     */\n    public int getLast() {\n      return m_size;\n    }\n  }  // end of TypedAncestorIterator\n  /**\n   * Iterator that returns the descendants of a given node.\n   */\n  public class DescendantIterator extends InternalAxisIteratorBase\n  {\n    /**\n     * Set start to END should 'close' the iterator,\n     * i.e. subsequent call to next() should return END.\n     *\n     * @param node Sets the root of the iteration.\n     *\n     * @return A DTMAxisIterator set to the start of the iteration.\n     */\n    public DTMAxisIterator setStartNode(int node)\n    {\n//%HZ%: Added reference to DTMDefaultBase.ROOTNODE back in, temporarily\n      if (node == DTMDefaultBase.ROOTNODE)\n        node = getDocument();\n      if (_isRestartable)\n      {\n        node = makeNodeIdentity(node);\n        _startNode = node;\n        if (_includeSelf)\n          node--;\n        _currentNode = node;\n        return resetPosition();\n      }\n      return this;\n    }\n    /**\n     * Tell if this node identity is a descendant.  Assumes that\n     * the node info for the element has already been obtained.\n     *\n     * This one-sided test works only if the parent has been\n     * previously tested and is known to be a descendent. It fails if\n     * the parent is the _startNode's next sibling, or indeed any node\n     * that follows _startNode in document order.  That may suffice\n     * for this iterator, but it's not really an isDescendent() test.\n     * %REVIEW% rename?\n     *\n     * @param identity The index number of the node in question.\n     * @return true if the index is a descendant of _startNode.\n     */\n    protected final boolean isDescendant(int identity)\n    {\n      return (_parent2(identity) >= _startNode) || (_startNode == identity);\n    }\n    /**\n     * Get the next node in the iteration.\n     *\n     * @return The next node handle in the iteration, or END.\n     */\n    public int next()\n    {\n      final int startNode = _startNode;\n      if (startNode == NULL) {\n        return NULL;\n      }\n      if (_includeSelf && (_currentNode + 1) == startNode)\n          return returnNode(makeNodeHandle(++_currentNode)); // | m_dtmIdent);\n      int node = _currentNode;\n      int type;\n      // %OPT% If the startNode is the root node, do not need\n      // to do the isDescendant() check.\n      if (startNode == ROOTNODE) {\n        int eType;\n        do {\n          node++;\n          eType = _exptype2(node);\n          if (NULL == eType) {\n            _currentNode = NULL;\n            return END;\n          }\n        } while (eType == TEXT_NODE\n                 || (type = m_extendedTypes[eType].getNodeType()) == ATTRIBUTE_NODE\n                 || type == NAMESPACE_NODE);\n      }\n      else {\n        do {\n          node++;\n          type = _type2(node);\n          if (NULL == type ||!isDescendant(node)) {\n            _currentNode = NULL;\n            return END;\n          }\n        } while(ATTRIBUTE_NODE == type || TEXT_NODE == type\n                 || NAMESPACE_NODE == type);\n      }\n      _currentNode = node;\n      return returnNode(makeNodeHandle(node));  // make handle.\n    }\n    /**\n     * Reset.\n     *\n     */\n  public DTMAxisIterator reset()\n  {\n    final boolean temp = _isRestartable;\n    _isRestartable = true;\n    setStartNode(makeNodeHandle(_startNode));\n    _isRestartable = temp;\n    return this;\n  }\n  }  // end of DescendantIterator\n  /**\n   * Typed iterator that returns the descendants of a given node.\n   */\n  public final class TypedDescendantIterator extends DescendantIterator\n  {\n    /** The extended type ID that was requested. */\n    private final int _nodeType;\n    /**\n     * Constructor TypedDescendantIterator\n     *\n     *\n     * @param nodeType Extended type ID being requested.\n     */\n    public TypedDescendantIterator(int nodeType)\n    {\n      _nodeType = nodeType;\n    }\n    /**\n     * Get the next node in the iteration.\n     *\n     * @return The next node handle in the iteration, or END.\n     */\n<fim_suffix>    public int next()\n    {\n      final int startNode = _startNode;\n      if (_startNode == NULL) {\n        return NULL;\n      }\n      int node = _currentNode;\n      int expType;\n      final int nodeType = _nodeType;\n      if (nodeType != DTM.ELEMENT_NODE)\n      {\n        do\n        {\n          node++;\n\t  expType = _exptype2(node);\n          if (NULL == expType || _parent2(node) < startNode && startNode != node) {\n            _currentNode = NULL;\n            return END;\n          }\n        }\n        while (expType != nodeType);\n      }\n      // %OPT% If the start node is root (e.g. in the case of //node),\n      // we can save the isDescendant() check, because all nodes are\n      // descendants of root.\n      else if (startNode == DTMDefaultBase.ROOTNODE)\n      {\n\tdo\n\t{\n\t  node++;\n\t  expType = _exptype2(node);\n\t  if (NULL == expType) {\n\t    _currentNode = NULL;\n\t    return END;\n\t  }\n\t} while (expType < DTM.NTYPES\n\t        || m_extendedTypes[expType].getNodeType() != DTM.ELEMENT_NODE);\n      }\n      else\n      {\n        do\n        {\n          node++;\n\t  expType = _exptype2(node);\n          if (NULL == expType || _parent2(node) < startNode && startNode != node) {\n            _currentNode = NULL;\n            return END;\n          }\n        }\n        while (expType < DTM.NTYPES\n\t       || m_extendedTypes[expType].getNodeType() != DTM.ELEMENT_NODE);\n      }\n      _currentNode = node;\n      return returnNode(makeNodeHandle(node));\n    }<fim_middle>// function below is long method\n"}