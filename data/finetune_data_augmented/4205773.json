{"text": "<fim_prefix>    {\n        return new SimpleBuilders.PartitionUpdateBuilder(metadata, partitionKeyValues);\n    }\n    public void validateIndexedColumns()\n    {\n        IndexRegistry.obtain(metadata()).validate(this);\n    }\n    /**\n     * Interface for building partition updates geared towards human.\n     * <p>\n     * This should generally not be used when performance matters too much, but provides a more convenient interface to\n     * build an update than using the class constructor when performance is not of the utmost importance.\n     */\n    public interface SimpleBuilder\n    {\n        /**\n         * The metadata of the table this is a builder on.\n         */\n        public TableMetadata metadata();\n        /**\n         * Sets the timestamp to use for the following additions to this builder or any derived (row) builder.\n         *\n         * @param timestamp the timestamp to use for following additions. If that timestamp hasn't been set, the current\n         * time in microseconds will be used.\n         * @return this builder.\n         */\n        public SimpleBuilder timestamp(long timestamp);\n        /**\n         * Sets the ttl to use for the following additions to this builder or any derived (row) builder.\n         *\n         * @param ttl the ttl to use for following additions. If that ttl hasn't been set, no ttl will be used.\n         * @return this builder.\n         */\n        public SimpleBuilder ttl(int ttl);\n        /**\n         * Sets the current time to use for the following additions to this builder or any derived (row) builder.\n         *\n         * @param nowInSec the current time to use for following additions. If the current time hasn't been set, the current\n         * time in seconds will be used.\n         * @return this builder.\n         */\n        public SimpleBuilder nowInSec(int nowInSec);\n        /**\n         * Adds the row identifier by the provided clustering and return a builder for that row.\n         *\n         * @param clusteringValues the value for the clustering columns of the row to add to this build. There may be no\n         * values if either the table has no clustering column, or if you want to edit the static row. Note that as a\n         * shortcut it is also allowed to pass a {@code Clustering} object directly, in which case that should be the\n         * only argument.\n         * @return a builder for the row identified by {@code clusteringValues}.\n         */\n        public Row.SimpleBuilder row(Object... clusteringValues);\n        /**\n         * Deletes the partition identified by this builder (using a partition level deletion).\n         *\n         * @return this builder.\n         */\n        public SimpleBuilder delete();\n        /**\n         * Adds a new range tombstone to this update, returning a builder for that range.\n         *\n         * @return the range tombstone builder for the newly added range.\n         */\n        public RangeTombstoneBuilder addRangeTombstone();\n        /**\n         * Adds a new range tombstone to this update\n         *\n         * @return this builder\n         */\n        public SimpleBuilder addRangeTombstone(RangeTombstone rt);\n        /**\n         * Build the update represented by this builder.\n         *\n         * @return the built update.\n         */\n        public PartitionUpdate build();\n        /**\n         * As shortcut for {@code new Mutation(build())}.\n         *\n         * @return the built update, wrapped in a {@code Mutation}.\n         */\n        public Mutation buildAsMutation();\n        /**\n         * Interface to build range tombstone.\n         *\n         * By default, if no other methods are called, the represented range is inclusive of both start and end and\n         * includes everything (its start is {@code BOTTOM} and it's end is {@code TOP}).\n         */\n        public interface RangeTombstoneBuilder\n        {\n            /**\n             * Sets the start for the built range using the provided values.\n             *\n             * @param values the value for the start of the range. They act like the {@code clusteringValues} argument\n             * of the {@link SimpleBuilder#row(Object...)} method, except that it doesn't have to be a full\n             * clustering, it can only be a prefix.\n             * @return this builder.\n             */\n            public RangeTombstoneBuilder start(Object... values);\n            /**\n             * Sets the end for the built range using the provided values.\n             *\n             * @param values the value for the end of the range. They act like the {@code clusteringValues} argument\n             * of the {@link SimpleBuilder#row(Object...)} method, except that it doesn't have to be a full\n             * clustering, it can only be a prefix.\n             * @return this builder.\n             */\n            public RangeTombstoneBuilder end(Object... values);\n            /**\n             * Sets the start of this range as inclusive.\n             * <p>\n             * This is the default and don't need to be called, but can for explicitness.\n             *\n             * @return this builder.\n             */\n            public RangeTombstoneBuilder inclStart();\n            /**\n             * Sets the start of this range as exclusive.\n             *\n             * @return this builder.\n             */\n            public RangeTombstoneBuilder exclStart();\n            /**\n             * Sets the end of this range as inclusive.\n             * <p>\n             * This is the default and don't need to be called, but can for explicitness.\n             *\n             * @return this builder.\n             */\n            public RangeTombstoneBuilder inclEnd();\n            /**\n             * Sets the end of this range as exclusive.\n             *\n             * @return this builder.\n             */\n            public RangeTombstoneBuilder exclEnd();\n        }\n    }\n    public static class PartitionUpdateSerializer\n    {\n        public void serialize(PartitionUpdate update, DataOutputPlus out, int version) throws IOException\n        {\n            try (UnfilteredRowIterator iter = update.unfilteredIterator())\n            {\n                assert !iter.isReverseOrder();\n                update.metadata.id.serialize(out);\n                UnfilteredRowIteratorSerializer.serializer.serialize(iter, null, out, version, update.rowCount());\n            }\n        }\n        public PartitionUpdate deserialize(DataInputPlus in, int version, SerializationHelper.Flag flag) throws IOException\n        {\n            TableMetadata metadata = Schema.instance.getExistingTableMetadata(TableId.deserialize(in));\n            UnfilteredRowIteratorSerializer.Header header = UnfilteredRowIteratorSerializer.serializer.deserializeHeader(metadata, null, in, version, flag);\n            if (header.isEmpty)\n                return emptyUpdate(metadata, header.key);\n            assert !header.isReversed;\n            assert header.rowEstimate >= 0;\n            MutableDeletionInfo.Builder deletionBuilder = MutableDeletionInfo.builder(header.partitionDeletion, metadata.comparator, false);\n            BTree.Builder<Row> rows = BTree.builder(metadata.comparator, header.rowEstimate);\n            rows.auto(false);\n            try (UnfilteredRowIterator partition = UnfilteredRowIteratorSerializer.serializer.deserialize(in, version, metadata, flag, header))\n            {\n                while (partition.hasNext())\n                {\n                    Unfiltered unfiltered = partition.next();\n                    if (unfiltered.kind() == Unfiltered.Kind.ROW)\n                        rows.add((Row)unfiltered);\n                    else\n                        deletionBuilder.add((RangeTombstoneMarker)unfiltered);\n                }\n            }\n            MutableDeletionInfo deletionInfo = deletionBuilder.build();\n            return new PartitionUpdate(metadata,\n                                       header.key,\n                                       new Holder(header.sHeader.columns(), rows.build(), deletionInfo, header.staticRow, header.sHeader.stats()),\n                                       deletionInfo,\n                                       false);\n        }\n        public long serializedSize(PartitionUpdate update, int version)\n        {\n            try (UnfilteredRowIterator iter = update.unfilteredIterator())\n            {\n                return update.metadata.id.serializedSize()\n                     + UnfilteredRowIteratorSerializer.serializer.serializedSize(iter, null, version, update.rowCount());\n            }\n        }\n    }\n    /**\n     * A counter mark is basically a pointer to a counter update inside this partition update. That pointer allows\n     * us to update the counter value based on the pre-existing value read during the read-before-write that counters\n     * do. See {@link CounterMutation} to understand how this is used.\n     */\n<fim_suffix>    public static class CounterMark\n    {\n        private final Row row;\n        private final ColumnMetadata column;\n        private final CellPath path;\n        private CounterMark(Row row, ColumnMetadata column, CellPath path)\n        {\n            this.row = row;\n            this.column = column;\n            this.path = path;\n        }\n        public Clustering clustering()\n        {\n            return row.clustering();\n        }\n        public ColumnMetadata column()\n        {\n            return column;\n        }\n        public CellPath path()\n        {\n            return path;\n        }\n        public ByteBuffer value()\n        {\n            return path == null\n                 ? row.getCell(column).value()\n                 : row.getCell(column, path).value();\n        }\n        public void setValue(ByteBuffer value)\n        {\n            // This is a bit of a giant hack as this is the only place where we mutate a Row object. This makes it more efficient\n            // for counters however and this won't be needed post-#6506 so that's probably fine.\n            assert row instanceof BTreeRow;\n            ((BTreeRow)row).setValue(column, path, value);\n        }\n    }<fim_middle>// class below is data class\n"}