{"text": "<fim_prefix>            .anyMatch(numericRange -> numericRange.isIn(uid));\n    }\n    private boolean matches(SearchQuery.HeaderCriterion criterion, MailboxMessage message)\n            throws MailboxException, IOException {\n        SearchQuery.HeaderOperator operator = criterion.getOperator();\n        String headerName = criterion.getHeaderName();\n        if (operator instanceof SearchQuery.DateOperator) {\n            return matches((SearchQuery.DateOperator) operator, headerName, message);\n        } else if (operator instanceof SearchQuery.ContainsOperator) {\n            return matches((SearchQuery.ContainsOperator) operator, headerName, message);\n        } else if (operator instanceof SearchQuery.ExistsOperator) {\n            return exists(headerName, message);\n        } else if (operator instanceof SearchQuery.AddressOperator) {\n            return matchesAddress((SearchQuery.AddressOperator) operator, headerName, message);\n        } else {\n            throw new UnsupportedSearchException();\n        }\n    }\n    /**\n     * Match against a {@link AddressType} header\n     * \n     * @param operator\n     * @param headerName\n     * @param message\n     * @return containsAddress\n     * @throws MailboxException\n     * @throws IOException\n     */\n    private boolean matchesAddress(SearchQuery.AddressOperator operator, String headerName,\n                                   MailboxMessage message) throws MailboxException, IOException {\n        String text = operator.getAddress().toUpperCase(Locale.US);\n        List<Header> headers = ResultUtils.createHeaders(message);\n        for (Header header : headers) {\n            String name = header.getName();\n            if (headerName.equalsIgnoreCase(name)) {\n                String value = header.getValue();\n                AddressList aList = LenientAddressParser.DEFAULT.parseAddressList(value);\n                for (Address address : aList) {\n                    if (address instanceof Mailbox) {\n                        if (AddressFormatter.DEFAULT.encode((Mailbox) address).toUpperCase(Locale.US)\n                            .contains(text)) {\n                            return true;\n                        }\n                    } else if (address instanceof Group) {\n                        MailboxList mList = ((Group) address).getMailboxes();\n                        for (Mailbox mailbox : mList) {\n                            if (AddressFormatter.DEFAULT.encode(mailbox).toUpperCase(Locale.US)\n                                .contains(text)) {\n                                return true;\n                            }\n                        }\n                    }\n                }\n                // Also try to match against raw header now\n                return value.toUpperCase(Locale.US).contains(text);\n            }\n        }\n        return false;\n    }\n    private boolean exists(String headerName, MailboxMessage message) throws MailboxException, IOException {\n        List<Header> headers = ResultUtils.createHeaders(message);\n        return headers.stream()\n            .map(Header::getName)\n            .anyMatch(headerName::equalsIgnoreCase);\n    }\n    private boolean matches(SearchQuery.ContainsOperator operator, String headerName,\n            MailboxMessage message) throws MailboxException, IOException {\n        String text = operator.getValue().toUpperCase(Locale.US);\n        List<Header> headers = ResultUtils.createHeaders(message);\n        for (Header header : headers) {\n            String name = header.getName();\n            if (headerName.equalsIgnoreCase(name)) {\n                String value = MimeUtil.unscrambleHeaderValue(header.getValue());\n                if (value != null) {\n                    if (value.toUpperCase(Locale.US).contains(text)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    private boolean matches(SearchQuery.DateOperator operator, String headerName, MailboxMessage message)\n            throws MailboxException {\n        Date date = operator.getDate();\n        DateResolution res = operator.getDateResultion();\n        try {\n            final String value = headerValue(headerName, message);\n            if (value == null) {\n                return false;\n            } else {\n                try {\n                    Date isoFieldValue = toISODate(value);\n                    SearchQuery.DateComparator type = operator.getType();\n                    switch (type) {\n                    case AFTER:\n                        return after(isoFieldValue, date, res);\n                    case BEFORE:\n                        return before(isoFieldValue, date, res);\n                    case ON:\n                        return on(isoFieldValue, date, res);\n                    default:\n                        throw new UnsupportedSearchException();\n                    }\n                } catch (ParseException e) {\n                    return false;\n                }\n            }\n        } catch (IOException e) {\n            return false;\n        }\n    }\n    private String headerValue(String headerName, MailboxMessage message) throws MailboxException, IOException {\n        List<Header> headers = ResultUtils.createHeaders(message);\n        for (Header header : headers) {\n            String name = header.getName();\n            if (headerName.equalsIgnoreCase(name)) {\n                return MimeUtil.unscrambleHeaderValue(header.getValue());\n            }\n        }\n        return null;\n    }\n    private Date toISODate(String value) throws ParseException {\n        StringReader reader = new StringReader(value);\n        DateTime dateTime = new DateTimeParser(reader).parseAll();\n        Calendar cal = getGMT();\n        cal.set(dateTime.getYear(), dateTime.getMonth() - 1, dateTime.getDay(), dateTime.getHour(),\n                dateTime.getMinute(), dateTime.getSecond());\n        return cal.getTime();\n    }\n    private boolean matches(SearchQuery.AttachmentCriterion criterion, MailboxMessage message) throws UnsupportedSearchException {\n        boolean mailHasAttachments = message.getProperties()\n            .stream()\n            .anyMatch(PropertyBuilder.isHasAttachmentProperty());\n        return mailHasAttachments == criterion.getOperator().isSet();\n    }\n    private boolean matches(SearchQuery.SizeCriterion criterion, MailboxMessage message) throws UnsupportedSearchException {\n        SearchQuery.NumericOperator operator = criterion.getOperator();\n        long size = message.getFullContentOctets();\n        long value = operator.getValue();\n        switch (operator.getType()) {\n        case LESS_THAN:\n            return size < value;\n        case GREATER_THAN:\n            return size > value;\n        case EQUALS:\n            return size == value;\n        default:\n            throw new UnsupportedSearchException();\n        }\n    }\n    private boolean matches(SearchQuery.ModSeqCriterion criterion, MailboxMessage message)\n            throws UnsupportedSearchException {\n        SearchQuery.NumericOperator operator = criterion.getOperator();\n        long modSeq = message.getModSeq();\n        long value = operator.getValue();\n        switch (operator.getType()) {\n        case LESS_THAN:\n            return modSeq < value;\n        case GREATER_THAN:\n            return modSeq > value;\n        case EQUALS:\n            return modSeq == value;\n        default:\n            throw new UnsupportedSearchException();\n        }\n    }\n    private boolean matches(SearchQuery.InternalDateCriterion criterion, MailboxMessage message)\n            throws UnsupportedSearchException {\n        SearchQuery.DateOperator operator = criterion.getOperator();\n        return matchesInternalDate(operator, message);\n    }\n    private boolean matchesInternalDate(SearchQuery.DateOperator operator, MailboxMessage message)\n            throws UnsupportedSearchException {\n        Date date = operator.getDate();\n        DateResolution dateResultion = operator.getDateResultion();\n        Date internalDate = message.getInternalDate();\n        SearchQuery.DateComparator type = operator.getType();\n        switch (type) {\n        case ON:\n            return on(internalDate, date, dateResultion);\n        case BEFORE:\n            return before(internalDate, date, dateResultion);\n        case AFTER:\n            return after(internalDate, date, dateResultion);\n        default:\n            throw new UnsupportedSearchException();\n        }\n    }\n    private boolean on(Date date1, Date date2, DateResolution dateResolution) {\n        String d1 = createDateString(date1, dateResolution);\n        String d2 = createDateString(date2, dateResolution);\n        return d1.compareTo(d2) == 0;\n    }\n    private boolean before(Date date1, Date date2, DateResolution dateResolution) {\n        String d1 = createDateString(date1, dateResolution);\n        String d2 = createDateString(date2, dateResolution);\n        return d1.compareTo(d2) < 0;\n    }\n    private boolean after(Date date1, Date date2, DateResolution dateResolution) {\n        String d1 = createDateString(date1, dateResolution);\n        String d2 = createDateString(date2, dateResolution);\n        return d1.compareTo(d2) > 0;\n    }\n    private String createDateString(Date date, DateResolution dateResolution) {\n        SimpleDateFormat format = createFormat(dateResolution);\n        format.setCalendar(getGMT());\n        return format.format(date);\n    }\n<fim_suffix>    private SimpleDateFormat createFormat(DateResolution dateResolution) {\n        switch (dateResolution) {\n        case Year:\n            return new SimpleDateFormat(\"yyyy\");\n        case Month:\n            return new SimpleDateFormat(\"yyyyMM\");\n        case Day:\n            return new SimpleDateFormat(\"yyyyMMdd\");\n        case Hour:\n            return new SimpleDateFormat(\"yyyyMMddhh\");\n        case Minute:\n            return new SimpleDateFormat(\"yyyyMMddhhmm\");\n        case Second:\n            return new SimpleDateFormat(\"yyyyMMddhhmmss\");\n        default:\n            return new SimpleDateFormat(\"yyyyMMddhhmmssSSS\");\n        }\n    }<fim_middle>// function below has no smell\n"}