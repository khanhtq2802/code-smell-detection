{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache license, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the license for the specific language governing permissions and\n * limitations under the license.\n */\npackage org.apache.logging.log4j.core.appender.rolling;\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.SortedMap;\nimport java.util.concurrent.TimeUnit;\nimport java.util.zip.Deflater;\nimport org.apache.logging.log4j.core.Core;\nimport org.apache.logging.log4j.core.appender.rolling.action.Action;\nimport org.apache.logging.log4j.core.appender.rolling.action.CompositeAction;\nimport org.apache.logging.log4j.core.appender.rolling.action.FileRenameAction;\nimport org.apache.logging.log4j.core.appender.rolling.action.PathCondition;\nimport org.apache.logging.log4j.core.appender.rolling.action.PosixViewAttributeAction;\nimport org.apache.logging.log4j.core.config.Configuration;\nimport org.apache.logging.log4j.core.config.plugins.Plugin;\nimport org.apache.logging.log4j.core.config.plugins.PluginBuilderAttribute;\nimport org.apache.logging.log4j.core.config.plugins.PluginBuilderFactory;\nimport org.apache.logging.log4j.core.config.plugins.PluginConfiguration;\nimport org.apache.logging.log4j.core.config.plugins.PluginElement;\nimport org.apache.logging.log4j.core.lookup.StrSubstitutor;\nimport org.apache.logging.log4j.core.util.Integers;\n/**\n * When rolling over, <code>DirectWriteRolloverStrategy</code> writes directly to the file as resolved by the file\n * pattern. Files will be renamed files according to an algorithm as described below.\n *\n * <p>\n * The DirectWriteRolloverStrategy uses similar logic as DefaultRolloverStrategy to determine the file name based\n * on the file pattern, however the DirectWriteRolloverStrategy writes directly to a file and does not rename it\n * during rollover, except if it is compressed, in which case it will add the appropriate file extension.\n * </p>\n *\n * @since 2.8\n */\n@Plugin(name = \"DirectWriteRolloverStrategy\", category = Core.CATEGORY_NAME, printObject = true)\npublic class DirectWriteRolloverStrategy extends AbstractRolloverStrategy implements DirectFileRolloverStrategy {\n    private static final int DEFAULT_MAX_FILES = 7;\n    /**\n     * Builds DirectWriteRolloverStrategy instances.\n     */\n    public static class Builder implements org.apache.logging.log4j.core.util.Builder<DirectWriteRolloverStrategy> {\n        @PluginBuilderAttribute(\"maxFiles\")\n        private String maxFiles;\n        @PluginBuilderAttribute(\"compressionLevel\")\n        private String compressionLevelStr;\n        @PluginElement(\"Actions\")\n        private Action[] customActions;\n        @PluginBuilderAttribute(value = \"stopCustomActionsOnError\")\n        private boolean stopCustomActionsOnError = true;\n        @PluginBuilderAttribute(value = \"tempCompressedFilePattern\")\n        private String tempCompressedFilePattern;\n        @PluginConfiguration\n        private Configuration config;\n<fim_suffix>        @Override\n        public DirectWriteRolloverStrategy build() {\n            int maxIndex = Integer.MAX_VALUE;\n            if (maxFiles != null) {\n                maxIndex = Integer.parseInt(maxFiles);\n                if (maxIndex < 0) {\n                    maxIndex = Integer.MAX_VALUE;\n                } else if (maxIndex < 2) {\n                    LOGGER.error(\"Maximum files too small. Limited to \" + DEFAULT_MAX_FILES);\n                    maxIndex = DEFAULT_MAX_FILES;\n                }\n            }\n            final int compressionLevel = Integers.parseInt(compressionLevelStr, Deflater.DEFAULT_COMPRESSION);\n            return new DirectWriteRolloverStrategy(maxIndex, compressionLevel, config.getStrSubstitutor(),\n                    customActions, stopCustomActionsOnError, tempCompressedFilePattern);\n        }\n        public String getMaxFiles() {\n            return maxFiles;\n        }\n        /**\n         * Defines the maximum number of files to keep.\n         *\n         * @param maxFiles The maximum number of files that match the date portion of the pattern to keep.\n         * @return This builder for chaining convenience\n         */\n        public Builder setMaxFiles(final String maxFiles) {\n            this.maxFiles = maxFiles;\n            return this;\n        }\n        public String getCompressionLevelStr() {\n            return compressionLevelStr;\n        }\n        /**\n         * Defines compression level.\n         *\n         * @param compressionLevelStr The compression level, 0 (less) through 9 (more); applies only to ZIP files.\n         * @return This builder for chaining convenience\n         */\n        public Builder setCompressionLevelStr(final String compressionLevelStr) {\n            this.compressionLevelStr = compressionLevelStr;\n            return this;\n        }\n        public Action[] getCustomActions() {\n            return customActions;\n        }\n        /**\n         * Defines custom actions.\n         *\n         * @param customActions custom actions to perform asynchronously after rollover\n         * @return This builder for chaining convenience\n         */\n        public Builder setCustomActions(final Action... customActions) {\n            this.customActions = customActions;\n            return this;\n        }\n        public boolean isStopCustomActionsOnError() {\n            return stopCustomActionsOnError;\n        }\n        /**\n         * Defines whether to stop executing asynchronous actions if an error occurs.\n         *\n         * @param stopCustomActionsOnError whether to stop executing asynchronous actions if an error occurs\n         * @return This builder for chaining convenience\n         */\n        public Builder setStopCustomActionsOnError(final boolean stopCustomActionsOnError) {\n            this.stopCustomActionsOnError = stopCustomActionsOnError;\n            return this;\n        }\n        public String getTempCompressedFilePattern() {\n            return tempCompressedFilePattern;\n        }\n        /**\n         * Defines temporary compression file pattern.\n         *\n         * @param tempCompressedFilePattern File pattern of the working file pattern used during compression, if null no temporary file are used\n         * @return This builder for chaining convenience\n         */\n        public Builder setTempCompressedFilePattern(final String tempCompressedFilePattern) {\n            this.tempCompressedFilePattern = tempCompressedFilePattern;\n            return this;\n        }\n        public Configuration getConfig() {\n            return config;\n        }\n        /**\n         * Defines configuration.\n         * \n         * @param config The Configuration.\n         * @return This builder for chaining convenience\n         */\n        public Builder setConfig(final Configuration config) {\n            this.config = config;\n            return this;\n        }\n    }\n    @PluginBuilderFactory\n    public static Builder newBuilder() {\n        return new Builder();\n    }\n    /**\n     * Index for most recent log file.\n     */\n    private final int maxFiles;\n    private final int compressionLevel;\n    private final List<Action> customActions;\n    private final boolean stopCustomActionsOnError;\n    private volatile String currentFileName;\n    private int nextIndex = -1;\n    private final PatternProcessor tempCompressedFilePattern;\n    private volatile boolean usePrevTime = false;\n    /**\n     * Constructs a new instance.\n     *\n     * @param maxFiles The maximum number of files that match the date portion of the pattern to keep.\n     * @param customActions custom actions to perform asynchronously after rollover\n     * @param stopCustomActionsOnError whether to stop executing asynchronous actions if an error occurs\n     * @param tempCompressedFilePatternString File pattern of the working file\n     *                                     used during compression, if null no temporary file are used\n     */\n    protected DirectWriteRolloverStrategy(final int maxFiles, final int compressionLevel,\n                                          final StrSubstitutor strSubstitutor, final Action[] customActions,\n                                          final boolean stopCustomActionsOnError, final String tempCompressedFilePatternString) {\n        super(strSubstitutor);\n        this.maxFiles = maxFiles;\n        this.compressionLevel = compressionLevel;\n        this.stopCustomActionsOnError = stopCustomActionsOnError;\n        this.customActions = customActions == null ? Collections.<Action> emptyList() : Arrays.asList(customActions);\n        this.tempCompressedFilePattern =\n                tempCompressedFilePatternString != null ? new PatternProcessor(tempCompressedFilePatternString) : null;\n    }\n    public int getCompressionLevel() {\n        return this.compressionLevel;\n    }\n    public List<Action> getCustomActions() {\n        return customActions;\n    }<fim_middle>// function below has no smell\n"}