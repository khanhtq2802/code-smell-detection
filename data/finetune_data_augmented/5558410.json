{"text": "<fim_prefix>\n<fim_suffix>public final class TestDec2Bin extends TestCase {\n    private static ValueEval invokeValue(String number1) {\n\t\tValueEval[] args = new ValueEval[] { new StringEval(number1) };\n\t\treturn new Dec2Bin().evaluate(args, -1, -1);\n\t}\n    private static ValueEval invokeBack(String number1) {\n        ValueEval[] args = new ValueEval[] { new StringEval(number1) };\n        return new Bin2Dec().evaluate(args, -1, -1);\n    }\n    private static void confirmValue(String msg, String number1, String expected) {\n\t\tValueEval result = invokeValue(number1);\n\t\tassertEquals(\"Had: \" + result, StringEval.class, result.getClass());\n\t\tassertEquals(msg, expected, ((StringEval) result).getStringValue());\n\t}\n    private static void confirmValueError(String msg, String number1, ErrorEval numError) {\n        ValueEval result = invokeValue(number1);\n        assertEquals(ErrorEval.class, result.getClass());\n        assertEquals(msg, numError, result);\n    }\n\tpublic void testBasic() {\n\t\tconfirmValue(\"Converts binary '00101' from binary (5)\", \"5\", \"101\");\n\t\tconfirmValue(\"Converts binary '1111111111' from binary (-1)\", \"-1\",    \"1111111111\");\n\t\tconfirmValue(\"Converts binary '1111111110' from binary (-2)\", \"-2\",    \"1111111110\");\n        confirmValue(\"Converts binary '0111111111' from binary (511)\", \"511\",   \"111111111\");\n        confirmValue(\"Converts binary '1000000000' from binary (511)\", \"-512\", \"1000000000\");\n\t}\n    public void testErrors() {\n        confirmValueError(\"fails for >= 512 or < -512\",\"512\", ErrorEval.NUM_ERROR);\n        confirmValueError(\"fails for >= 512 or < -512\",\"-513\", ErrorEval.NUM_ERROR);\n        confirmValueError(\"not a valid decimal number\",\"GGGGGGG\", ErrorEval.VALUE_INVALID);\n        confirmValueError(\"not a valid decimal number\",\"3.14159a\", ErrorEval.VALUE_INVALID);\n    }\n    public void testEvalOperationEvaluationContext() {\n        OperationEvaluationContext ctx = createContext();\n        ValueEval[] args = new ValueEval[] { ctx.getRefEval(0, 0) };\n        ValueEval result = new Dec2Bin().evaluate(args, ctx);\n        assertEquals(StringEval.class, result.getClass());\n        assertEquals(\"1101\", ((StringEval) result).getStringValue());\n    }\n    public void testEvalOperationEvaluationContextFails() {\n        OperationEvaluationContext ctx = createContext();\n        ValueEval[] args = new ValueEval[] { ErrorEval.VALUE_INVALID };\n        ValueEval result = new Dec2Bin().evaluate(args, ctx);\n        assertEquals(ErrorEval.class, result.getClass());\n        assertEquals(ErrorEval.VALUE_INVALID, result);\n    }\n    private OperationEvaluationContext createContext() {\n        HSSFWorkbook wb = new HSSFWorkbook();\n        Sheet sheet = wb.createSheet();\n        Row row = sheet.createRow(0);\n        Cell cell = row.createCell(0);\n        cell.setCellValue(\"13.43\");\n        cell = row.createCell(1);\n        cell.setCellValue(\"8\");\n        cell = row.createCell(2);\n        cell.setCellValue(\"-8\");\n        cell = row.createCell(3);\n        cell.setCellValue(\"1\");\n        HSSFEvaluationWorkbook workbook = HSSFEvaluationWorkbook.create(wb);\n        WorkbookEvaluator workbookEvaluator = new WorkbookEvaluator(workbook, new IStabilityClassifier() {\n            @Override\n            public boolean isCellFinal(int sheetIndex, int rowIndex, int columnIndex) {\n                return true;\n            }\n        }, null);\n        return new OperationEvaluationContext(workbookEvaluator,\n                workbook, 0, 0, 0, null);\n    }\n    public void testRefs() {\n        OperationEvaluationContext ctx = createContext();\n        ValueEval[] args = new ValueEval[] { ctx.getRefEval(0, 0) };\n        ValueEval result = new Dec2Bin().evaluate(args, -1, -1);\n        assertEquals(\"Had: \" + result, StringEval.class, result.getClass());\n        assertEquals(\"1101\", ((StringEval) result).getStringValue());\n    }\n    public void testWithPlacesIntInt() {\n        OperationEvaluationContext ctx = createContext();\n        ValueEval[] args = new ValueEval[] { ctx.getRefEval(0, 0), ctx.getRefEval(0, 1) };\n        ValueEval result = new Dec2Bin().evaluate(args, -1, -1);\n        assertEquals(\"Had: \" + result, StringEval.class, result.getClass());\n        // TODO: documentation and behavior do not match here!\n        assertEquals(\"1101\", ((StringEval) result).getStringValue());\n    }\n    public void testWithPlaces() {\n        OperationEvaluationContext ctx = createContext();\n        ValueEval[] args = new ValueEval[] { ctx.getRefEval(0, 0), ctx.getRefEval(0, 1) };\n        ValueEval result = new Dec2Bin().evaluate(args, ctx);\n        assertEquals(\"Had: \" + result, StringEval.class, result.getClass());\n        // TODO: documentation and behavior do not match here!\n        assertEquals(\"1101\", ((StringEval) result).getStringValue());\n    }\n    public void testWithToShortPlaces() {\n        OperationEvaluationContext ctx = createContext();\n        ValueEval[] args = new ValueEval[] { ctx.getRefEval(0, 0), ctx.getRefEval(0, 3) };\n        ValueEval result = new Dec2Bin().evaluate(args, -1, -1);\n        assertEquals(ErrorEval.class, result.getClass());\n        assertEquals(ErrorEval.NUM_ERROR, result);\n    }\n    public void testWithTooManyParamsIntInt() {\n        OperationEvaluationContext ctx = createContext();\n        ValueEval[] args = new ValueEval[] { ctx.getRefEval(0, 0), ctx.getRefEval(0, 1), ctx.getRefEval(0, 1) };\n        ValueEval result = new Dec2Bin().evaluate(args, -1, -1);\n        assertEquals(ErrorEval.class, result.getClass());\n        assertEquals(ErrorEval.VALUE_INVALID, result);\n    }\n    public void testWithTooManyParams() {\n        OperationEvaluationContext ctx = createContext();\n        ValueEval[] args = new ValueEval[] { ctx.getRefEval(0, 0), ctx.getRefEval(0, 1), ctx.getRefEval(0, 1) };\n        ValueEval result = new Dec2Bin().evaluate(args, ctx);\n        assertEquals(ErrorEval.class, result.getClass());\n        assertEquals(ErrorEval.VALUE_INVALID, result);\n    }\n    public void testWithErrorPlaces() {\n        OperationEvaluationContext ctx = createContext();\n        ValueEval[] args = new ValueEval[] { ctx.getRefEval(0, 0), ErrorEval.NULL_INTERSECTION };\n        ValueEval result = new Dec2Bin().evaluate(args, -1, -1);\n        assertEquals(ErrorEval.class, result.getClass());\n        assertEquals(ErrorEval.NULL_INTERSECTION, result);\n    }\n    public void testWithNegativePlaces() {\n        OperationEvaluationContext ctx = createContext();\n        ValueEval[] args = new ValueEval[] { ctx.getRefEval(0, 0), ctx.getRefEval(0, 2) };\n        ValueEval result = new Dec2Bin().evaluate(args, -1, -1);\n        assertEquals(ErrorEval.class, result.getClass());\n        assertEquals(ErrorEval.NUM_ERROR, result);\n    }\n    public void testWithZeroPlaces() {\n        OperationEvaluationContext ctx = createContext();\n        ValueEval[] args = new ValueEval[] { ctx.getRefEval(0, 0), new NumberEval(0.0) };\n        ValueEval result = new Dec2Bin().evaluate(args, -1, -1);\n        assertEquals(ErrorEval.class, result.getClass());\n        assertEquals(ErrorEval.NUM_ERROR, result);\n    }\n    public void testWithEmptyPlaces() {\n        OperationEvaluationContext ctx = createContext();\n        ValueEval[] args = new ValueEval[] { ctx.getRefEval(0, 0), ctx.getRefEval(1, 0) };\n        ValueEval result = new Dec2Bin().evaluate(args, -1, -1);\n        assertEquals(ErrorEval.class, result.getClass());\n        assertEquals(ErrorEval.VALUE_INVALID, result);\n    }\n    public void testBackAndForth() {\n        for (int i = -512; i < 512; i++) {<fim_middle>// class below has no smell\n"}