{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.tez.dag.library.vertexmanager;\n\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.apache.hadoop.yarn.api.records.Container;\nimport org.apache.tez.dag.api.EdgeProperty;\nimport org.apache.tez.dag.api.EdgeProperty.DataMovementType;\nimport org.apache.tez.dag.api.InputDescriptor;\nimport org.apache.tez.dag.api.TezUncheckedException;\nimport org.apache.tez.dag.api.VertexLocationHint.TaskLocationHint;\nimport org.apache.tez.dag.api.VertexManagerPlugin;\nimport org.apache.tez.dag.api.VertexManagerPluginContext;\nimport org.apache.tez.dag.api.VertexManagerPluginContext.TaskWithLocationHint;\nimport org.apache.tez.runtime.api.Event;\nimport org.apache.tez.runtime.api.events.VertexManagerEvent;\n\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\n\n<fim_suffix>public class InputReadyVertexManager extends VertexManagerPlugin {\n  private static final Log LOG = \n      LogFactory.getLog(InputReadyVertexManager.class);\n\n  VertexManagerPluginContext context;\n  Map<String, SourceVertexInfo> srcVertexInfo = Maps.newHashMap();\n  boolean taskIsStarted[];\n  int oneToOneSrcTasksDoneCount[];\n  Container oneToOneLocationHints[];\n  int numOneToOneEdges;\n  \n  class SourceVertexInfo {\n    EdgeProperty edgeProperty;\n    int numTasks;\n    int numFinishedTasks;\n    Boolean taskIsFinished[];\n    \n    SourceVertexInfo(int numTasks, EdgeProperty edgeProperty) {\n      this.numTasks = numTasks;\n      this.numFinishedTasks = 0;\n      this.edgeProperty = edgeProperty;\n      this.taskIsFinished = new Boolean[numTasks];\n    }\n  }\n  \n  @Override\n  public void initialize(VertexManagerPluginContext context) {\n    this.context = context;\n  }\n\n  @Override\n  public void onVertexStarted(Map<String, List<Integer>> completions) {\n    int numManagedTasks = context.getVertexNumTasks(context.getVertexName());\n    LOG.info(\"Managing \" + numManagedTasks + \" tasks for vertex: \" + context.getVertexName());\n    taskIsStarted = new boolean[numManagedTasks];\n\n    // find out about all input edge types. If there is a custom edge then \n    // TODO Until TEZ-1013 we cannot handle custom input formats\n    Map<String, EdgeProperty> edges = context.getInputVertexEdgeProperties();\n    int oneToOneSrcTaskCount = 0;\n    numOneToOneEdges = 0;\n    for (Map.Entry<String, EdgeProperty> entry : edges.entrySet()) {\n      EdgeProperty edgeProp = entry.getValue();\n      String srcVertex = entry.getKey();\n      int numSrcTasks = context.getVertexNumTasks(srcVertex);\n      switch (edgeProp.getDataMovementType()) {\n      case CUSTOM:\n        throw new TezUncheckedException(\"Cannot handle custom edge\");\n      case ONE_TO_ONE:\n        numOneToOneEdges++;\n        if (oneToOneSrcTaskCount == 0) {\n          oneToOneSrcTaskCount = numSrcTasks;\n        } else if (oneToOneSrcTaskCount != numSrcTasks) {\n          throw new TezUncheckedException(\n              \"All 1-1 source vertices must have identical concurrency\");\n        }\n        break;\n      case SCATTER_GATHER:\n      case BROADCAST:\n        break;\n      default:\n        throw new TezUncheckedException(\n            \"Unknown edge type: \" + edgeProp.getDataMovementType());\n      }\n      srcVertexInfo.put(srcVertex, new SourceVertexInfo(numSrcTasks, edgeProp));\n    }\n    \n    if (numOneToOneEdges > 0) {\n      if (oneToOneSrcTaskCount != numManagedTasks) {\n        throw new TezUncheckedException(\n            \"Managed task number must equal 1-1 source task number\");\n      }\n      oneToOneSrcTasksDoneCount = new int[oneToOneSrcTaskCount];\n      oneToOneLocationHints = new Container[oneToOneSrcTaskCount];\n    }\n\n    for (Map.Entry<String, List<Integer>> entry : completions.entrySet()) {\n      for (Integer task : entry.getValue()) {\n        handleSourceTaskFinished(entry.getKey(), task);\n      }\n    }\n  }\n\n  @Override\n  public void onSourceTaskCompleted(String srcVertexName, Integer taskId) {\n    handleSourceTaskFinished(srcVertexName, taskId);\n  }\n\n  @Override\n  public void onVertexManagerEventReceived(VertexManagerEvent vmEvent) {\n  }\n\n  @Override\n  public void onRootVertexInitialized(String inputName,\n      InputDescriptor inputDescriptor, List<Event> events) {\n  }\n  \n  void handleSourceTaskFinished(String vertex, Integer taskId) {\n    SourceVertexInfo srcInfo = srcVertexInfo.get(vertex);\n    if (srcInfo.taskIsFinished[taskId.intValue()] == null) {\n      // not a duplicate completion\n      srcInfo.taskIsFinished[taskId.intValue()] = new Boolean(true);\n      srcInfo.numFinishedTasks++;\n      if (srcInfo.edgeProperty.getDataMovementType() == DataMovementType.ONE_TO_ONE) {\n        oneToOneSrcTasksDoneCount[taskId.intValue()]++;\n        // keep the latest container that completed as the location hint\n        // After there is standard data size info available then use it\n        oneToOneLocationHints[taskId.intValue()] = context.getTaskContainer(vertex, taskId);\n      }\n    }\n    \n    // custom edge needs to tell us which of our tasks its connected to\n    // for now only-built in edges supported\n    // Check if current source task's vertex is completed.\n    if (srcInfo.edgeProperty.getDataMovementType() != DataMovementType.ONE_TO_ONE\n        && srcInfo.numTasks != srcInfo.numFinishedTasks) {\n      // we depend on all tasks to finish. So nothing to do now.\n      return;\n    }\n    \n    // currently finished vertex task may trigger us to schedule\n    for (SourceVertexInfo vInfo : srcVertexInfo.values()) {\n      if (vInfo.edgeProperty.getDataMovementType() != DataMovementType.ONE_TO_ONE) {\n        // we depend on all tasks to finish.\n        if (vInfo.numTasks != vInfo.numFinishedTasks) {\n          // we depend on all tasks to finish. So nothing to do now.\n          return;\n        }\n      }\n    }\n    \n    // all source vertices will full dependencies are done\n    List<TaskWithLocationHint> tasksToStart = null;\n    if (numOneToOneEdges == 0) {\n      // no 1-1 dependency. Start all tasks\n      int numTasks = taskIsStarted.length;\n      LOG.info(\"Starting all \" + numTasks + \"tasks for vertex: \" + context.getVertexName());\n      tasksToStart = Lists.newArrayListWithCapacity(numTasks);\n      for (int i=0; i<numTasks; ++i) {\n        taskIsStarted[i] = true;\n        tasksToStart.add(new TaskWithLocationHint(new Integer(i), null));\n      }\n    } else {\n      // start only the ready 1-1 tasks\n      tasksToStart = Lists.newLinkedList();\n      for (int i=0; i<taskIsStarted.length; ++i) {\n        if (!taskIsStarted[i] && oneToOneSrcTasksDoneCount[i] == numOneToOneEdges) {\n          taskIsStarted[i] = true;\n          TaskLocationHint locationHint = null;\n          if (oneToOneLocationHints[i] != null) {\n            locationHint = new TaskLocationHint(oneToOneLocationHints[i].getId());\n          }\n          LOG.info(\"Starting task \" + i + \" for vertex: \"\n              + context.getVertexName() + \" with location: \"\n              + ((locationHint != null) ? locationHint.getAffinitizedContainer() : \"null\"));\n          tasksToStart.add(new TaskWithLocationHint(new Integer(i), locationHint));\n        }\n      }\n    }\n    \n    if (tasksToStart != null && !tasksToStart.isEmpty()) {\n      context.scheduleVertexTasks(tasksToStart);\n    }\n    \n  }\n\n}<fim_middle>// class below has no smell\n"}