{"text": "<fim_prefix>// Copyright 2017 The Nomulus Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage google.registry.request;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.net.MediaType.PLAIN_TEXT_UTF_8;\nimport static javax.servlet.http.HttpServletResponse.SC_FORBIDDEN;\nimport static javax.servlet.http.HttpServletResponse.SC_METHOD_NOT_ALLOWED;\nimport static javax.servlet.http.HttpServletResponse.SC_NOT_FOUND;\n\nimport com.google.common.flogger.FluentLogger;\nimport google.registry.request.auth.AuthResult;\nimport google.registry.request.auth.RequestAuthenticator;\nimport google.registry.util.NonFinalForTesting;\nimport google.registry.util.SystemClock;\nimport google.registry.util.TypeUtils.TypeInstantiator;\nimport java.io.IOException;\nimport java.util.Optional;\nimport javax.annotation.Nullable;\nimport javax.inject.Provider;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport org.joda.time.DateTime;\nimport org.joda.time.Duration;\n\n/**\n * Dagger-based request processor.\n *\n * <p>This class creates an HTTP request processor from a Dagger component. It routes requests from\n * your servlet to an {@link Action @Action} annotated handler class.\n *\n * <h3>Component Definition</h3>\n *\n * <p>Action instances are supplied on a per-request basis by invoking the methods on {@code C}.\n * For example:\n * <pre>\n * {@literal @Component}\n * interface ServerComponent {\n *   HelloAction helloAction();\n * }</pre>\n *\n * <p>The rules for component methods are as follows:\n * <ol>\n * <li>Methods whose raw return type does not implement {@code Runnable} will be ignored\n * <li>Methods whose raw return type does not have an {@code @Action} annotation are ignored\n * </ol>\n *\n * <h3>Security Features</h3>\n *\n * @param <C> request component type\n */\npublic class RequestHandler<C> {\n\n  private static final FluentLogger logger = FluentLogger.forEnclosingClass();\n\n  private final Router router;\n  private final Provider<? extends RequestComponentBuilder<C>> requestComponentBuilderProvider;\n  private final RequestAuthenticator requestAuthenticator;\n  private final SystemClock clock = new SystemClock();\n\n  @NonFinalForTesting\n  RequestMetrics requestMetrics = new RequestMetrics();\n\n  /**\n   * Constructor for subclasses to create a new request handler for a specific request component.\n   *\n   * <p>This operation will generate a routing map for the component's {@code @Action}-returning\n   * methods using reflection, which is moderately expensive, so a given servlet should construct a\n   * single {@code RequestHandler} and re-use it across requests.\n   *\n   * @param requestComponentBuilderProvider a Dagger {@code Provider} of builder instances that can\n   *     be used to construct new instances of the request component (with the required\n   *     request-derived modules provided by this class)\n   * @param requestAuthenticator an instance of the {@link RequestAuthenticator} class\n   */\n  protected RequestHandler(\n      Provider<? extends RequestComponentBuilder<C>> requestComponentBuilderProvider,\n      RequestAuthenticator requestAuthenticator) {\n    this(null, requestComponentBuilderProvider, requestAuthenticator);\n  }\n\n  /** Creates a new RequestHandler with an explicit component class for test purposes. */\n  public static <C> RequestHandler<C> createForTest(\n      Class<C> component,\n      Provider<? extends RequestComponentBuilder<C>> requestComponentBuilderProvider,\n      RequestAuthenticator requestAuthenticator) {\n    return new RequestHandler<>(\n        checkNotNull(component),\n        requestComponentBuilderProvider,\n        requestAuthenticator);\n  }\n\n<fim_suffix>  private RequestHandler(\n      @Nullable Class<C> component,\n      Provider<? extends RequestComponentBuilder<C>> requestComponentBuilderProvider,\n      RequestAuthenticator requestAuthenticator) {\n    // If the component class isn't explicitly provided, infer it from the class's own typing.\n    // This is safe only for use by subclasses of RequestHandler where the generic parameter is\n    // preserved at runtime, so only expose that option via the protected constructor.\n    this.router = Router.create(\n        component != null ? component : new TypeInstantiator<C>(getClass()){}.getExactType());\n    this.requestComponentBuilderProvider = checkNotNull(requestComponentBuilderProvider);\n    this.requestAuthenticator = checkNotNull(requestAuthenticator);\n  }\n\n  /** Runs the appropriate action for a servlet request. */\n  public void handleRequest(HttpServletRequest req, HttpServletResponse rsp) throws IOException {\n    checkNotNull(req);\n    checkNotNull(rsp);\n    Action.Method method;\n    try {\n      method = Action.Method.valueOf(req.getMethod());\n    } catch (IllegalArgumentException e) {\n      logger.atInfo().log(\"Unsupported method: %s\", req.getMethod());\n      rsp.sendError(SC_METHOD_NOT_ALLOWED);\n      return;\n    }\n    String path = req.getRequestURI();\n    Optional<Route> route = router.route(path);\n    if (!route.isPresent()) {\n      logger.atInfo().log(\"No action found for: %s\", path);\n      rsp.sendError(SC_NOT_FOUND);\n      return;\n    }\n    if (!route.get().isMethodAllowed(method)) {\n      logger.atInfo().log(\"Method %s not allowed for: %s\", method, path);\n      rsp.sendError(SC_METHOD_NOT_ALLOWED);\n      return;\n    }\n    Optional<AuthResult> authResult =\n        requestAuthenticator.authorize(route.get().action().auth().authSettings(), req);\n    if (!authResult.isPresent()) {\n      rsp.sendError(SC_FORBIDDEN, \"Not authorized\");\n      return;\n    }\n\n    // Build a new request component using any modules we've constructed by this point.\n    C component = requestComponentBuilderProvider.get()\n        .requestModule(new RequestModule(req, rsp, authResult.get()))\n        .build();\n    // Apply the selected Route to the component to produce an Action instance, and run it.\n    boolean success = true;\n    DateTime startTime = clock.nowUtc();\n    try {\n      route.get().instantiator().apply(component).run();\n      if (route.get().action().automaticallyPrintOk()) {\n        rsp.setContentType(PLAIN_TEXT_UTF_8.toString());\n        rsp.getWriter().write(\"OK\\n\");\n      }\n    } catch (HttpException e) {\n      e.send(rsp);\n      success = false;\n    } finally {\n      requestMetrics.record(\n          new Duration(startTime, clock.nowUtc()),\n          path,\n          method,\n          authResult.get().authLevel(),\n          success);\n    }\n  }\n}<fim_middle>// function below has no smell\n"}