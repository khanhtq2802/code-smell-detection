{"text": "<fim_prefix>import static org.apache.brooklyn.util.time.Time.makeTimeStringRounded;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicReference;\nimport org.apache.brooklyn.api.entity.EntityLocal;\nimport org.apache.brooklyn.api.mgmt.Task;\nimport org.apache.brooklyn.api.sensor.Sensor;\nimport org.apache.brooklyn.config.ConfigKey;\nimport org.apache.brooklyn.core.config.ConfigKeys;\nimport org.apache.brooklyn.core.mgmt.BrooklynTaskTags;\nimport org.apache.brooklyn.core.policy.AbstractPolicy;\nimport org.apache.brooklyn.policy.ha.HASensors.FailureDescriptor;\nimport org.apache.brooklyn.util.core.flags.SetFromFlag;\nimport org.apache.brooklyn.util.core.task.BasicTask;\nimport org.apache.brooklyn.util.core.task.ScheduledTask;\nimport org.apache.brooklyn.util.core.task.Tasks;\nimport org.apache.brooklyn.util.exceptions.Exceptions;\nimport org.apache.brooklyn.util.time.Duration;\nimport org.apache.brooklyn.util.time.Time;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport com.google.common.reflect.TypeToken;\npublic abstract class AbstractFailureDetector extends AbstractPolicy {\n    // TODO Remove duplication from ServiceFailureDetector, particularly for the stabilisation delays.\n    private static final Logger LOG = LoggerFactory.getLogger(AbstractFailureDetector.class);\n    private static final long MIN_PERIOD_BETWEEN_EXECS_MILLIS = 100;\n    public static final ConfigKey<Duration> POLL_PERIOD = ConfigKeys.newDurationConfigKey(\n            \"failureDetector.pollPeriod\", \"\", Duration.ONE_SECOND);\n    @SetFromFlag(\"failedStabilizationDelay\")\n    public static final ConfigKey<Duration> FAILED_STABILIZATION_DELAY = ConfigKeys.newDurationConfigKey(\n            \"failureDetector.serviceFailedStabilizationDelay\",\n            \"Time period for which the health check consistently fails \"\n                    + \"(e.g. doesn't report failed-ok-faled) before concluding failure.\",\n            Duration.ZERO);\n    @SetFromFlag(\"recoveredStabilizationDelay\")\n    public static final ConfigKey<Duration> RECOVERED_STABILIZATION_DELAY = ConfigKeys.newDurationConfigKey(\n            \"failureDetector.serviceRecoveredStabilizationDelay\",\n            \"Time period for which the health check succeeds continiually \" +\n                    \"(e.g. doesn't report ok-failed-ok) before concluding recovered\",\n            Duration.ZERO);\n    @SuppressWarnings(\"serial\")\n    public static final ConfigKey<Sensor<FailureDescriptor>> SENSOR_FAILED = ConfigKeys.newConfigKey(new TypeToken<Sensor<FailureDescriptor>>() {},\n            \"failureDetector.sensor.fail\", \"A sensor which will indicate failure when set\", HASensors.ENTITY_FAILED);\n    @SuppressWarnings(\"serial\")\n    public static final ConfigKey<Sensor<FailureDescriptor>> SENSOR_RECOVERED = ConfigKeys.newConfigKey(new TypeToken<Sensor<FailureDescriptor>>() {},\n            \"failureDetector.sensor.recover\", \"A sensor which will indicate recovery from failure when set\", HASensors.ENTITY_RECOVERED);\n    public interface CalculatedStatus {\n        boolean isHealthy();\n        String getDescription();\n    }\n    private final class PublishJob implements Runnable {\n        @Override public void run() {\n            try {\n                executorTime = System.currentTimeMillis();\n                executorQueued.set(false);\n                publishNow();\n            } catch (Exception e) {\n                if (isRunning()) {\n                    LOG.error(\"Problem resizing: \"+e, e);\n                } else {\n                    if (LOG.isDebugEnabled()) LOG.debug(\"Problem resizing, but no longer running: \"+e, e);\n                }\n            } catch (Throwable t) {\n                LOG.error(\"Problem in service-failure-detector: \"+t, t);\n                throw Exceptions.propagate(t);\n            }\n        }\n    }\n    private final class HealthPoller implements Runnable {\n        @Override\n        public void run() {\n            checkHealth();\n        }\n    }\n    private final class HealthPollingTaskFactory implements Callable<Task<?>> {\n        @Override\n        public Task<?> call() {\n            BasicTask<Void> task = new BasicTask<Void>(new HealthPoller());\n            BrooklynTaskTags.setTransient(task);\n            return task;\n        }\n    }\n    protected static class BasicCalculatedStatus implements CalculatedStatus {\n        private boolean healthy;\n        private String description;\n        public BasicCalculatedStatus(boolean healthy, String description) {\n            this.healthy = healthy;\n            this.description = description;\n        }\n        @Override\n        public boolean isHealthy() {\n            return healthy;\n        }\n        @Override\n        public String getDescription() {\n            return description;\n        }\n    }\n    public enum LastPublished {\n        NONE,\n        FAILED,\n        RECOVERED;\n    }\n    protected final AtomicReference<Long> stateLastGood = new AtomicReference<Long>();\n    protected final AtomicReference<Long> stateLastFail = new AtomicReference<Long>();\n    protected Long currentFailureStartTime = null;\n    protected Long currentRecoveryStartTime = null;\n    protected LastPublished lastPublished = LastPublished.NONE;\n    private final AtomicBoolean executorQueued = new AtomicBoolean(false);\n    private volatile long executorTime = 0;\n    private Callable<Task<?>> pollingTaskFactory = new HealthPollingTaskFactory();\n    private Task<?> scheduledTask;\n    protected abstract CalculatedStatus calculateStatus();\n    @Override\n    public void setEntity(EntityLocal entity) {\n        super.setEntity(entity);\n        if (isRunning()) {\n            doStartPolling();\n        }\n    }\n    @Override\n    public void suspend() {\n        scheduledTask.cancel(true);\n        super.suspend();\n    }\n    @Override\n    public void resume() {\n        currentFailureStartTime = null;\n        currentRecoveryStartTime = null;\n        lastPublished = LastPublished.NONE;\n        executorQueued.set(false);\n        executorTime = 0;\n        super.resume();\n        doStartPolling();\n    }\n    protected void doStartPolling() {\n        if (scheduledTask == null || scheduledTask.isDone()) {\n            ScheduledTask task = ScheduledTask.builder(pollingTaskFactory).displayName( getTaskName() ).period(getPollPeriod()).build();\n            scheduledTask = getExecutionContext().submit(task);\n        }\n    }\n    private String getTaskName() {\n        return getDisplayName();\n    }\n    protected Duration getPollPeriod() {\n        return getConfig(POLL_PERIOD);\n    }\n    protected Duration getFailedStabilizationDelay() {\n        return getConfig(FAILED_STABILIZATION_DELAY);\n    }\n    protected Duration getRecoveredStabilizationDelay() {\n        return getConfig(RECOVERED_STABILIZATION_DELAY);\n    }\n    protected Sensor<FailureDescriptor> getSensorFailed() {\n        return getConfig(SENSOR_FAILED);\n    }\n    protected Sensor<FailureDescriptor> getSensorRecovered() {\n        return getConfig(SENSOR_RECOVERED);\n    }\n<fim_suffix>    private synchronized void checkHealth() {\n        CalculatedStatus status = calculateStatus();\n        boolean healthy = status.isHealthy();\n        long now = System.currentTimeMillis();\n        if (healthy) {\n            stateLastGood.set(now);\n            if (lastPublished == LastPublished.FAILED) {\n                if (currentRecoveryStartTime == null) {\n                    LOG.info(\"{} check for {}, now recovering: {}\", new Object[] {this, entity, getDescription(status)});\n                    currentRecoveryStartTime = now;\n                    schedulePublish();\n                } else {\n                    if (LOG.isTraceEnabled()) LOG.trace(\"{} check for {}, continuing recovering: {}\", new Object[] {this, entity, getDescription(status)});\n                }\n            } else {\n                if (currentFailureStartTime != null) {\n                    LOG.info(\"{} check for {}, now healthy: {}\", new Object[] {this, entity, getDescription(status)});\n                    currentFailureStartTime = null;\n                } else {\n                    if (LOG.isTraceEnabled()) LOG.trace(\"{} check for {}, still healthy: {}\", new Object[] {this, entity, getDescription(status)});\n                }\n            }\n        } else {\n            stateLastFail.set(now);\n            if (lastPublished != LastPublished.FAILED) {\n                if (currentFailureStartTime == null) {\n                    LOG.info(\"{} check for {}, now failing: {}\", new Object[] {this, entity, getDescription(status)});\n                    currentFailureStartTime = now;\n                    schedulePublish();\n                } else {\n                    if (LOG.isTraceEnabled()) LOG.trace(\"{} check for {}, continuing failing: {}\", new Object[] {this, entity, getDescription(status)});\n                }\n            } else {\n                if (currentRecoveryStartTime != null) {\n                    LOG.info(\"{} check for {}, now failing: {}\", new Object[] {this, entity, getDescription(status)});\n                    currentRecoveryStartTime = null;\n                } else {\n                    if (LOG.isTraceEnabled()) LOG.trace(\"{} check for {}, still failed: {}\", new Object[] {this, entity, getDescription(status)});\n                }\n            }\n        }\n    }<fim_middle>// function below is long method\n"}