{"text": "<fim_prefix>            JobEvent event = JobEvent.yieldJobEventBeforeRemoval(job);\n            eventManager.notifyListeners(event);\n            JobOperator op = getJobOperator(job);\n            op.delete(job);\n            event = JobEvent.yieldJobEventAfterRemoval(job);\n            eventManager.notifyListeners(event);\n        }\n    }\n    @Override\n    public List<JobInstanceBean> findInstancesOfJob(\n        Long jobId,\n        int page,\n        int size) {\n        AbstractJob job = jobRepo.findByIdAndDeleted(jobId, false);\n        if (job == null) {\n            LOGGER.warn(\"Job id {} does not exist.\", jobId);\n            throw new GriffinException\n                .NotFoundException(JOB_ID_DOES_NOT_EXIST);\n        }\n        size = size > MAX_PAGE_SIZE ? MAX_PAGE_SIZE : size;\n        size = size <= 0 ? DEFAULT_PAGE_SIZE : size;\n        Pageable pageable = new PageRequest(page, size,\n            Sort.Direction.DESC, \"tms\");\n        List<JobInstanceBean> instances = instanceRepo.findByJobId(jobId,\n            pageable);\n        return updateState(instances);\n    }\n    @Override\n    public JobInstanceBean findInstance(Long id) {\n        JobInstanceBean bean = instanceRepo.findByInstanceId(id);\n        if (bean == null) {\n            LOGGER.warn(\"Instance id {} does not exist.\", id);\n            throw new GriffinException\n                .NotFoundException(INSTANCE_ID_DOES_NOT_EXIST);\n        }\n        return bean;\n    }\n    private List<JobInstanceBean> updateState(List<JobInstanceBean> instances) {\n        for (JobInstanceBean instance : instances) {\n            State state = instance.getState();\n            if (state.equals(UNKNOWN) || isActive(state)) {\n                syncInstancesOfJob(instance);\n            }\n        }\n        return instances;\n    }\n    /**\n     * a job is regard as healthy job when its latest instance is in healthy\n     * state.\n     *\n     * @return job healthy statistics\n     */\n    @Override\n    public JobHealth getHealthInfo() {\n        JobHealth jobHealth = new JobHealth();\n        List<AbstractJob> jobs = jobRepo.findByDeleted(false);\n        for (AbstractJob job : jobs) {\n            JobOperator op = getJobOperator(job);\n            try {\n                jobHealth = op.getHealth(jobHealth, job);\n            } catch (SchedulerException e) {\n                LOGGER.error(\"Job schedule exception. {}\", e);\n                throw new GriffinException\n                    .ServiceException(\"Fail to Get HealthInfo\", e);\n            }\n        }\n        return jobHealth;\n    }\n    @Scheduled(fixedDelayString = \"${jobInstance.expired.milliseconds}\")\n    public void deleteExpiredJobInstance() {\n        Long timeMills = System.currentTimeMillis();\n        List<JobInstanceBean> instances = instanceRepo\n            .findByExpireTmsLessThanEqual\n                (timeMills);\n        if (!batchJobOp.pauseJobInstances(instances)) {\n            LOGGER.error(\"Pause job failure.\");\n            return;\n        }\n        int count = instanceRepo.deleteByExpireTimestamp(timeMills);\n        LOGGER.info(\"Delete {} expired job instances.\", count);\n    }\n    private void validateJobExist(AbstractJob job) {\n        if (job == null) {\n            LOGGER.warn(\"Griffin job does not exist.\");\n            throw new GriffinException.NotFoundException(JOB_ID_DOES_NOT_EXIST);\n        }\n    }\n    private JobOperator getJobOperator(AbstractJob job) {\n        if (job instanceof BatchJob) {\n            return batchJobOp;\n        } else if (job instanceof StreamingJob) {\n            return streamingJobOp;\n        }\n        throw new GriffinException.BadRequestException\n            (JOB_TYPE_DOES_NOT_SUPPORT);\n    }\n    private JobOperator getJobOperator(ProcessType type) {\n        if (type == BATCH) {\n            return batchJobOp;\n        } else if (type == STREAMING) {\n            return streamingJobOp;\n        }\n        throw new GriffinException.BadRequestException\n            (MEASURE_TYPE_DOES_NOT_SUPPORT);\n    }\n    TriggerKey getTriggerKeyIfValid(String qName, String qGroup) throws\n        SchedulerException {\n        TriggerKey triggerKey = triggerKey(qName, qGroup);\n        if (factory.getScheduler().checkExists(triggerKey)) {\n            throw new GriffinException.ConflictException\n                (QUARTZ_JOB_ALREADY_EXIST);\n        }\n        return triggerKey;\n    }\n    List<? extends Trigger> getTriggers(String name, String group) throws\n        SchedulerException {\n        if (name == null || group == null) {\n            return null;\n        }\n        JobKey jobKey = new JobKey(name, group);\n        Scheduler scheduler = factory.getScheduler();\n        return scheduler.getTriggersOfJob(jobKey);\n    }\n    private JobState genJobState(AbstractJob job, String action) throws\n        SchedulerException {\n        JobOperator op = getJobOperator(job);\n        JobState state = op.getState(job, action);\n        job.setJobState(state);\n        return state;\n    }\n    private JobState genJobState(AbstractJob job) throws SchedulerException {\n        return genJobState(job, null);\n    }\n    void addJob(TriggerKey tk, AbstractJob job, ProcessType type) throws\n        Exception {\n        JobDetail jobDetail = addJobDetail(tk, job);\n        Trigger trigger = genTriggerInstance(tk, jobDetail, job, type);\n        factory.getScheduler().scheduleJob(trigger);\n    }\n    String getQuartzName(AbstractJob job) {\n        return job.getJobName() + \"_\" + System.currentTimeMillis();\n    }\n    String getQuartzGroup() {\n        return \"BA\";\n    }\n    boolean isValidJobName(String jobName) {\n        if (StringUtils.isEmpty(jobName)) {\n            LOGGER.warn(\"Job name cannot be empty.\");\n            return false;\n        }\n        int size = jobRepo.countByJobNameAndDeleted(jobName, false);\n        if (size > 0) {\n            LOGGER.warn(\"Job name already exits.\");\n            return false;\n        }\n        return true;\n    }\n    private GriffinMeasure getMeasureIfValid(Long measureId) {\n        GriffinMeasure measure = measureRepo.findByIdAndDeleted(measureId,\n            false);\n        if (measure == null) {\n            LOGGER.warn(\"The measure id {} isn't valid. Maybe it doesn't \" +\n                    \"exist or is external measure type.\",\n                measureId);\n            throw new GriffinException.BadRequestException(INVALID_MEASURE_ID);\n        }\n        return measure;\n    }\n    private Trigger genTriggerInstance(TriggerKey tk, JobDetail jd, AbstractJob\n        job, ProcessType type) {\n        TriggerBuilder builder = newTrigger().withIdentity(tk).forJob(jd);\n        if (type == BATCH) {\n            TimeZone timeZone = getTimeZone(job.getTimeZone());\n            return builder.withSchedule(cronSchedule(job.getCronExpression())\n                .inTimeZone(timeZone)).build();\n        } else if (type == STREAMING) {\n            return builder.startNow().withSchedule(simpleSchedule()\n                .withRepeatCount(0)).build();\n        }\n        throw new GriffinException.BadRequestException\n            (JOB_TYPE_DOES_NOT_SUPPORT);\n    }\n    private JobDetail addJobDetail(TriggerKey triggerKey, AbstractJob job)\n        throws SchedulerException {\n        Scheduler scheduler = factory.getScheduler();\n        JobKey jobKey = jobKey(triggerKey.getName(), triggerKey.getGroup());\n        JobDetail jobDetail;\n        Boolean isJobKeyExist = scheduler.checkExists(jobKey);\n        if (isJobKeyExist) {\n            jobDetail = scheduler.getJobDetail(jobKey);\n        } else {\n            jobDetail = newJob(JobInstance.class).storeDurably().withIdentity\n                (jobKey).build();\n        }\n        setJobDataMap(jobDetail, job);\n        scheduler.addJob(jobDetail, isJobKeyExist);\n        return jobDetail;\n    }\n    private void setJobDataMap(JobDetail jd, AbstractJob job) {\n        JobDataMap jobDataMap = jd.getJobDataMap();\n        jobDataMap.put(GRIFFIN_JOB_ID, job.getId().toString());\n    }\n    /**\n     * deleteJobsRelateToMeasure\n     * 1. search jobs related to measure\n     * 2. deleteJob\n     *\n     * @param measureId measure id\n     */\n<fim_suffix>    public void deleteJobsRelateToMeasure(Long measureId) throws\n        SchedulerException {\n        List<AbstractJob> jobs = jobRepo.findByMeasureIdAndDeleted(measureId,\n            false);\n        if (CollectionUtils.isEmpty(jobs)) {\n            LOGGER.info(\"Measure id {} has no related jobs.\", measureId);\n            return;\n        }\n        for (AbstractJob job : jobs) {\n            JobOperator op = getJobOperator(job);\n            op.delete(job);\n        }\n    }<fim_middle>// function below has no smell\n"}