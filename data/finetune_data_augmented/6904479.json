{"text": "<fim_prefix>            appClassLoader = fileManager.getClassLoader(DocumentationTool.Location.DOCLET_PATH);\n        } else {\n            // construct class loader\n            String cpString = null;   // make sure env.class.path defaults to dot\n            // do prepends to get correct ordering\n            cpString = appendPath(System.getProperty(\"env.class.path\"), cpString);\n            cpString = appendPath(System.getProperty(\"java.class.path\"), cpString);\n            cpString = appendPath(docletPath, cpString);\n            URL[] urls = pathToURLs(cpString);\n            if (docletParentClassLoader == null)\n                appClassLoader = new URLClassLoader(urls, getDelegationClassLoader(docletClassName));\n            else\n                appClassLoader = new URLClassLoader(urls, docletParentClassLoader);\n        }\n        if (exportInternalAPI) {\n            exportInternalAPI(appClassLoader);\n        }\n        // attempt to find doclet\n        Class<?> dc = null;\n        try {\n            dc = appClassLoader.loadClass(docletClassName);\n        } catch (ClassNotFoundException exc) {\n            messager.error(Messager.NOPOS, \"main.doclet_class_not_found\", docletClassName);\n            messager.exit();\n        }\n        docletClass = dc;\n    }\n    /*\n     * Returns the delegation class loader to use when creating\n     * appClassLoader (used to load the doclet).  The context class\n     * loader is the best choice, but legacy behavior was to use the\n     * default delegation class loader (aka system class loader).\n     *\n     * Here we favor using the context class loader.  To ensure\n     * compatibility with existing apps, we revert to legacy\n     * behavior if either or both of the following conditions hold:\n     *\n     * 1) the doclet is loadable from the system class loader but not\n     *    from the context class loader,\n     *\n     * 2) this.getClass() is loadable from the system class loader but not\n     *    from the context class loader.\n     */\n    private ClassLoader getDelegationClassLoader(String docletClassName) {\n        ClassLoader ctxCL = Thread.currentThread().getContextClassLoader();\n        ClassLoader sysCL = ClassLoader.getSystemClassLoader();\n        if (sysCL == null)\n            return ctxCL;\n        if (ctxCL == null)\n            return sysCL;\n        // Condition 1.\n        try {\n            sysCL.loadClass(docletClassName);\n            try {\n                ctxCL.loadClass(docletClassName);\n            } catch (ClassNotFoundException e) {\n                return sysCL;\n            }\n        } catch (ClassNotFoundException e) {\n        }\n        // Condition 2.\n        try {\n            if (getClass() == sysCL.loadClass(getClass().getName())) {\n                try {\n                    if (getClass() != ctxCL.loadClass(getClass().getName()))\n                        return sysCL;\n                } catch (ClassNotFoundException e) {\n                    return sysCL;\n                }\n            }\n        } catch (ClassNotFoundException e) {\n        }\n        return ctxCL;\n    }\n    /**\n     * Generate documentation here.  Return true on success.\n     */\n    public boolean start(RootDoc root) {\n        Object retVal;\n        String methodName = \"start\";\n        Class<?>[] paramTypes = { RootDoc.class };\n        Object[] params = { root };\n        try {\n            retVal = invoke(methodName, null, paramTypes, params);\n        } catch (DocletInvokeException exc) {\n            return false;\n        }\n        if (retVal instanceof Boolean) {\n            return ((Boolean)retVal);\n        } else {\n            messager.error(Messager.NOPOS, \"main.must_return_boolean\",\n                           docletClassName, methodName);\n            return false;\n        }\n    }\n    /**\n     * Check for doclet added options here. Zero return means\n     * option not known.  Positive value indicates number of\n     * arguments to option.  Negative value means error occurred.\n     */\n    public int optionLength(String option) {\n        Object retVal;\n        String methodName = \"optionLength\";\n        Class<?>[] paramTypes = { String.class };\n        Object[] params = { option };\n        try {\n            retVal = invoke(methodName, 0, paramTypes, params);\n        } catch (DocletInvokeException exc) {\n            return -1;\n        }\n        if (retVal instanceof Integer) {\n            return ((Integer)retVal);\n        } else {\n            messager.error(Messager.NOPOS, \"main.must_return_int\",\n                           docletClassName, methodName);\n            return -1;\n        }\n    }\n    /**\n     * Let doclet check that all options are OK. Returning true means\n     * options are OK.  If method does not exist, assume true.\n     */\n    public boolean validOptions(List<String[]> optlist) {\n        Object retVal;\n        String options[][] = optlist.toArray(new String[optlist.length()][]);\n        String methodName = \"validOptions\";\n        DocErrorReporter reporter = messager;\n        Class<?>[] paramTypes = { String[][].class, DocErrorReporter.class };\n        Object[] params = { options, reporter };\n        try {\n            retVal = invoke(methodName, Boolean.TRUE, paramTypes, params);\n        } catch (DocletInvokeException exc) {\n            return false;\n        }\n        if (retVal instanceof Boolean) {\n            return ((Boolean)retVal);\n        } else {\n            messager.error(Messager.NOPOS, \"main.must_return_boolean\",\n                           docletClassName, methodName);\n            return false;\n        }\n    }\n    /**\n     * Return the language version supported by this doclet.\n     * If the method does not exist in the doclet, assume version 1.1.\n     */\n    public LanguageVersion languageVersion() {\n        try {\n            Object retVal;\n            String methodName = \"languageVersion\";\n            Class<?>[] paramTypes = new Class<?>[0];\n            Object[] params = new Object[0];\n            try {\n                retVal = invoke(methodName, LanguageVersion.JAVA_1_1, paramTypes, params);\n            } catch (DocletInvokeException exc) {\n                return LanguageVersion.JAVA_1_1;\n            }\n            if (retVal instanceof LanguageVersion) {\n                return (LanguageVersion)retVal;\n            } else {\n                messager.error(Messager.NOPOS, \"main.must_return_languageversion\",\n                               docletClassName, methodName);\n                return LanguageVersion.JAVA_1_1;\n            }\n        } catch (NoClassDefFoundError ex) { // for boostrapping, no Enum class.\n            return null;\n        }\n    }\n    /**\n     * Utility method for calling doclet functionality\n     */\n<fim_suffix>    private Object invoke(String methodName, Object returnValueIfNonExistent,\n                          Class<?>[] paramTypes, Object[] params)\n        throws DocletInvokeException {\n            Method meth;\n            try {\n                meth = docletClass.getMethod(methodName, paramTypes);\n            } catch (NoSuchMethodException exc) {\n                if (returnValueIfNonExistent == null) {\n                    messager.error(Messager.NOPOS, \"main.doclet_method_not_found\",\n                                   docletClassName, methodName);\n                    throw new DocletInvokeException();\n                } else {\n                    return returnValueIfNonExistent;\n                }\n            } catch (SecurityException exc) {\n                messager.error(Messager.NOPOS, \"main.doclet_method_not_accessible\",\n                               docletClassName, methodName);\n                throw new DocletInvokeException();\n            }\n            if (!Modifier.isStatic(meth.getModifiers())) {\n                messager.error(Messager.NOPOS, \"main.doclet_method_must_be_static\",\n                               docletClassName, methodName);\n                throw new DocletInvokeException();\n            }\n            ClassLoader savedCCL =\n                Thread.currentThread().getContextClassLoader();\n            try {\n                if (appClassLoader != null) // will be null if doclet class provided via API\n                    Thread.currentThread().setContextClassLoader(appClassLoader);\n                return meth.invoke(null , params);\n            } catch (IllegalArgumentException | NullPointerException exc) {\n                messager.error(Messager.NOPOS, \"main.internal_error_exception_thrown\",\n                               docletClassName, methodName, exc.toString());\n                throw new DocletInvokeException();\n            } catch (IllegalAccessException exc) {\n                messager.error(Messager.NOPOS, \"main.doclet_method_not_accessible\",\n                               docletClassName, methodName);\n                throw new DocletInvokeException();\n            }\n            catch (InvocationTargetException exc) {\n                Throwable err = exc.getTargetException();\n                if (apiMode)\n                    throw new ClientCodeException(err);\n                if (err instanceof java.lang.OutOfMemoryError) {\n                    messager.error(Messager.NOPOS, \"main.out.of.memory\");\n                } else {\n                    messager.error(Messager.NOPOS, \"main.exception_thrown\",\n                               docletClassName, methodName, exc.toString());\n                    exc.getTargetException().printStackTrace(System.err);\n                }\n                throw new DocletInvokeException();\n            } finally {\n                Thread.currentThread().setContextClassLoader(savedCCL);\n            }\n    }<fim_middle>// function below is long method\n"}