{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.brooklyn.core.effector;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.brooklyn.api.effector.Effector;\nimport org.apache.brooklyn.api.effector.ParameterType;\nimport org.apache.brooklyn.api.entity.Entity;\nimport org.apache.brooklyn.core.annotation.EffectorParam;\nimport org.apache.brooklyn.core.entity.AbstractEntity;\nimport org.apache.brooklyn.core.mgmt.internal.EffectorUtils;\nimport org.apache.brooklyn.util.JavaGroovyEquivalents;\nimport org.apache.brooklyn.util.core.flags.TypeCoercions;\nimport org.apache.brooklyn.util.exceptions.Exceptions;\nimport org.codehaus.groovy.runtime.MethodClosure;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.google.common.collect.Lists;\n\n/** concrete class for providing an Effector implementation that gets its information from annotations on a method;\n * see Effector*Test for usage example.\n * <p>\n * note that the method must be on an interface in order for it to be remoted, with the current implementation.\n * see comments in {@link #call(Entity, Map)} for more details.\n */\n<fim_suffix>public class MethodEffector<T> extends AbstractEffector<T> {\n\n    private static final long serialVersionUID = 6989688364011965968L;\n    private static final Logger log = LoggerFactory.getLogger(MethodEffector.class);\n    \n    @SuppressWarnings(\"rawtypes\")\n    public static Effector<?> create(Method m) {\n        return new MethodEffector(m);\n    }\n    \n    protected static class AnnotationsOnMethod {\n        final Class<?> clazz;\n        final String name;\n        final String description;\n        final Class<?> returnType;\n        final List<ParameterType<?>> parameters;\n\n        public AnnotationsOnMethod(Class<?> clazz, String methodName) {\n            this(clazz, inferBestMethod(clazz, methodName));\n        }\n\n        public AnnotationsOnMethod(Class<?> clazz, Method method) {\n            this.clazz = clazz;\n            this.name = method.getName();\n            this.returnType = method.getReturnType();\n\n            // Get the description\n            org.apache.brooklyn.core.annotation.Effector effectorAnnotation = method.getAnnotation(org.apache.brooklyn.core.annotation.Effector.class);\n            description = (effectorAnnotation != null) ? effectorAnnotation.description() : null;\n\n            // Get the parameters\n            parameters = Lists.newArrayList();\n            int numParameters = method.getParameterTypes().length;\n            for (int i = 0; i < numParameters; i++) {\n                parameters.add(toParameterType(method, i));\n            }\n        }\n\n        @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n        protected static ParameterType<?> toParameterType(Method method, int paramIndex) {\n            Annotation[] anns = method.getParameterAnnotations()[paramIndex];\n            Class<?> type = method.getParameterTypes()[paramIndex];\n            EffectorParam paramAnnotation = findAnnotation(anns, EffectorParam.class);\n\n            // TODO if blank, could do \"param\"+(i+1); would that be better?\n            // TODO this will now give \"\" if name is blank, rather than previously null. Is that ok?!\n            String name = (paramAnnotation != null) ? paramAnnotation.name() : null;\n\n            String paramDescription = (paramAnnotation == null || EffectorParam.MAGIC_STRING_MEANING_NULL.equals(paramAnnotation.description())) ? null : paramAnnotation.description();\n            String description = (paramDescription != null) ? paramDescription : null;\n\n            String paramDefaultValue = (paramAnnotation == null || EffectorParam.MAGIC_STRING_MEANING_NULL.equals(paramAnnotation.defaultValue())) ? null : paramAnnotation.defaultValue();\n            Object defaultValue = (paramDefaultValue != null) ? TypeCoercions.coerce(paramDefaultValue, type) : null;\n\n            return new BasicParameterType(name, type, description, defaultValue);\n        }\n        \n        @SuppressWarnings(\"unchecked\")\n        protected static <T extends Annotation> T findAnnotation(Annotation[] anns, Class<T> type) {\n            for (Annotation ann : anns) {\n                if (type.isInstance(ann)) return (T) ann;\n            }\n            return null;\n        }\n        \n        protected static Method inferBestMethod(Class<?> clazz, String methodName) {\n            Method best = null;\n            for (Method it : clazz.getMethods()) { \n                if (it.getName().equals(methodName)) {\n                    if (best==null || best.getParameterTypes().length < it.getParameterTypes().length) best=it;\n                }\n            }\n            if (best==null) {\n                throw new IllegalStateException(\"Cannot find method \"+methodName+\" on \"+clazz.getCanonicalName());\n            }\n            return best;\n        }\n    }\n\n    /** Defines a new effector whose details are supplied as annotations on the given type and method name */\n    public MethodEffector(Class<?> whereEffectorDefined, String methodName) {\n        this(new AnnotationsOnMethod(whereEffectorDefined, methodName), null);\n    }\n\n    public MethodEffector(Method method) {\n        this(new AnnotationsOnMethod(method.getDeclaringClass(), method), null);\n    }\n\n    /**\n     * @deprecated since 0.11.0; explicit groovy utilities/support will be deleted.\n     */\n    @Deprecated\n    public MethodEffector(MethodClosure mc) {\n        this(new AnnotationsOnMethod((Class<?>)mc.getDelegate(), mc.getMethod()), null);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected MethodEffector(AnnotationsOnMethod anns, String description) {\n        super(anns.name, (Class<T>)anns.returnType, anns.parameters, JavaGroovyEquivalents.elvis(description, anns.description));\n    }\n\n    @Override\n    @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n    public T call(Entity entity, Map parameters) {\n        if (entity instanceof AbstractEntity) {\n            return EffectorUtils.invokeMethodEffector(entity, this, (Map<String,?>)parameters);\n        } else {\n            // we are dealing with a proxy here\n            // this implementation invokes the method on the proxy\n            // (requiring it to be on the interface)\n            // and letting the proxy deal with the remoting / runAtEntity;\n            // alternatively we could create the task here and pass it to runAtEntity;\n            // the latter may allow us to simplify/remove a lot of the stuff from \n            // EffectorUtils and possibly Effectors and Entities\n            \n            // TODO Should really find method with right signature, rather than just the right args.\n            // TODO prepareArgs can miss things out that have \"default values\"! Code below will probably fail if that happens.\n            Object[] parametersArray = EffectorUtils.prepareArgsForEffector(this, parameters);\n            Method[] methods = entity.getClass().getMethods();\n            for (Method method : methods) {\n                if (method.getName().equals(getName())) {\n                    if (parametersArray.length == method.getParameterTypes().length) {\n                        try {\n                            return (T) method.invoke(entity, parametersArray);\n                        } catch (Exception e) {\n                            // exception handled by the proxy invocation (which leads to EffectorUtils.invokeEffectorMethod...)\n                            throw Exceptions.propagate(e);\n                        }\n                    }\n                }\n            }\n            String msg = \"Could not find method for effector \"+getName()+\" with \"+parametersArray.length+\" parameters on \"+entity;\n            log.warn(msg+\" (throwing); available methods are: \"+Arrays.toString(methods));\n            throw new IllegalStateException(msg);\n        }\n    }\n    \n}<fim_middle>// class below has no smell\n"}