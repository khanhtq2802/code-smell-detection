{"text": "<fim_prefix>            boolean retainInput, boolean retainMissing, IMissingWriterFactory missingWriterFactory,\n            ISearchOperationCallbackFactory searchCallbackFactory, boolean appendIndexFilter)\n            throws HyracksDataException {\n        this(ctx, inputRecDesc, partition, minFilterFieldIndexes, maxFilterFieldIndexes, indexHelperFactory,\n                retainInput, retainMissing, missingWriterFactory, searchCallbackFactory, appendIndexFilter, null, -1,\n                false, null, null);\n    }\n    public IndexSearchOperatorNodePushable(IHyracksTaskContext ctx, RecordDescriptor inputRecDesc, int partition,\n            int[] minFilterFieldIndexes, int[] maxFilterFieldIndexes, IIndexDataflowHelperFactory indexHelperFactory,\n            boolean retainInput, boolean retainMissing, IMissingWriterFactory missingWriterFactory,\n            ISearchOperationCallbackFactory searchCallbackFactory, boolean appendIndexFilter,\n            ITupleFilterFactory tupleFilterFactory, long outputLimit) throws HyracksDataException {\n        this(ctx, inputRecDesc, partition, minFilterFieldIndexes, maxFilterFieldIndexes, indexHelperFactory,\n                retainInput, retainMissing, missingWriterFactory, searchCallbackFactory, appendIndexFilter,\n                tupleFilterFactory, outputLimit, false, null, null);\n    }\n    public IndexSearchOperatorNodePushable(IHyracksTaskContext ctx, RecordDescriptor inputRecDesc, int partition,\n            int[] minFilterFieldIndexes, int[] maxFilterFieldIndexes, IIndexDataflowHelperFactory indexHelperFactory,\n            boolean retainInput, boolean retainMissing, IMissingWriterFactory missingWriterFactory,\n            ISearchOperationCallbackFactory searchCallbackFactory, boolean appendIndexFilter,\n            ITupleFilterFactory tupleFactoryFactory, long outputLimit, boolean appendSearchCallbackProceedResult,\n            byte[] searchCallbackProceedResultFalseValue, byte[] searchCallbackProceedResultTrueValue)\n            throws HyracksDataException {\n        this.ctx = ctx;\n        this.indexHelper = indexHelperFactory.create(ctx.getJobletContext().getServiceContext(), partition);\n        this.retainInput = retainInput;\n        this.retainMissing = retainMissing;\n        this.appendIndexFilter = appendIndexFilter;\n        if (this.retainMissing || this.appendIndexFilter) {\n            this.nonMatchWriter = missingWriterFactory.createMissingWriter();\n        }\n        this.inputRecDesc = inputRecDesc;\n        this.searchCallbackFactory = searchCallbackFactory;\n        this.minFilterFieldIndexes = minFilterFieldIndexes;\n        this.maxFilterFieldIndexes = maxFilterFieldIndexes;\n        if (minFilterFieldIndexes != null && minFilterFieldIndexes.length > 0) {\n            minFilterKey = new PermutingFrameTupleReference();\n            minFilterKey.setFieldPermutation(minFilterFieldIndexes);\n        }\n        if (maxFilterFieldIndexes != null && maxFilterFieldIndexes.length > 0) {\n            maxFilterKey = new PermutingFrameTupleReference();\n            maxFilterKey.setFieldPermutation(maxFilterFieldIndexes);\n        }\n        this.appendSearchCallbackProceedResult = appendSearchCallbackProceedResult;\n        this.searchCallbackProceedResultFalseValue = searchCallbackProceedResultFalseValue;\n        this.searchCallbackProceedResultTrueValue = searchCallbackProceedResultTrueValue;\n        stats = new OperatorStats(getDisplayName());\n        if (ctx.getStatsCollector() != null) {\n            ctx.getStatsCollector().add(stats);\n        }\n        this.tupleFilterFactory = tupleFactoryFactory;\n        this.outputLimit = outputLimit;\n        if (this.tupleFilterFactory != null && this.retainMissing) {\n            throw new IllegalStateException(\"RetainMissing with tuple filter is not supported\");\n        }\n    }\n    protected abstract ISearchPredicate createSearchPredicate();\n    protected abstract void resetSearchPredicate(int tupleIndex);\n    // Assigns any index-type specific related accessor parameters\n    protected abstract void addAdditionalIndexAccessorParams(IIndexAccessParameters iap) throws HyracksDataException;\n    protected IIndexCursor createCursor() throws HyracksDataException {\n        return indexAccessor.createSearchCursor(false);\n    }\n    protected abstract int getFieldCount();\n    @Override\n    public void open() throws HyracksDataException {\n        writer.open();\n        indexHelper.open();\n        index = indexHelper.getIndexInstance();\n        accessor = new FrameTupleAccessor(inputRecDesc);\n        if (retainMissing) {\n            int fieldCount = getFieldCount();\n            // Field count in case searchCallback.proceed() result is needed.\n            int finalFieldCount = appendSearchCallbackProceedResult ? fieldCount + 1 : fieldCount;\n            nonMatchTupleBuild = new ArrayTupleBuilder(finalFieldCount);\n            buildMissingTuple(fieldCount, nonMatchTupleBuild, nonMatchWriter);\n            if (appendSearchCallbackProceedResult) {\n                // Writes the success result in the last field in case we need to write down\n                // the result of searchOperationCallback.proceed(). This value can't be missing even for this case.\n                writeSearchCallbackProceedResult(nonMatchTupleBuild, true);\n            }\n        } else {\n            nonMatchTupleBuild = null;\n        }\n        if (appendIndexFilter) {\n            int numIndexFilterFields = index.getNumOfFilterFields();\n            nonFilterTupleBuild = new ArrayTupleBuilder(numIndexFilterFields);\n            buildMissingTuple(numIndexFilterFields, nonFilterTupleBuild, nonMatchWriter);\n        }\n        if (tupleFilterFactory != null) {\n            tupleFilter = tupleFilterFactory.createTupleFilter(ctx);\n            referenceFilterTuple = new ReferenceFrameTupleReference();\n        }\n        finished = false;\n        outputCount = 0;\n        try {\n            searchPred = createSearchPredicate();\n            tb = new ArrayTupleBuilder(recordDesc.getFieldCount());\n            dos = tb.getDataOutput();\n            appender = new FrameTupleAppender(new VSizeFrame(ctx), true);\n            ISearchOperationCallback searchCallback =\n                    searchCallbackFactory.createSearchOperationCallback(indexHelper.getResource().getId(), ctx, null);\n            IIndexAccessParameters iap = new IndexAccessParameters(NoOpOperationCallback.INSTANCE, searchCallback);\n            addAdditionalIndexAccessorParams(iap);\n            indexAccessor = index.createAccessor(iap);\n            cursor = createCursor();\n            if (retainInput) {\n                frameTuple = new FrameTupleReference();\n            }\n        } catch (Exception e) {\n            throw HyracksDataException.create(e);\n        }\n    }\n    protected void writeSearchResults(int tupleIndex) throws Exception {\n        long matchingTupleCount = 0;\n        while (cursor.hasNext()) {\n            cursor.next();\n            matchingTupleCount++;\n            ITupleReference tuple = cursor.getTuple();\n            if (tupleFilter != null && !tupleFilter.accept(referenceFilterTuple.reset(tuple))) {\n                continue;\n            }\n            tb.reset();\n            if (retainInput) {\n                frameTuple.reset(accessor, tupleIndex);\n                for (int i = 0; i < frameTuple.getFieldCount(); i++) {\n                    dos.write(frameTuple.getFieldData(i), frameTuple.getFieldStart(i), frameTuple.getFieldLength(i));\n                    tb.addFieldEndOffset();\n                }\n            }\n            writeTupleToOutput(tuple);\n            if (appendSearchCallbackProceedResult) {\n                writeSearchCallbackProceedResult(tb,\n                        ((ILSMIndexCursor) cursor).getSearchOperationCallbackProceedResult());\n            }\n            if (appendIndexFilter) {\n                writeFilterTupleToOutput(((ILSMIndexCursor) cursor).getFilterMinTuple());\n                writeFilterTupleToOutput(((ILSMIndexCursor) cursor).getFilterMaxTuple());\n            }\n            FrameUtils.appendToWriter(writer, appender, tb.getFieldEndOffsets(), tb.getByteArray(), 0, tb.getSize());\n            if (outputLimit >= 0 && ++outputCount >= outputLimit) {\n                finished = true;\n                break;\n            }\n        }\n        stats.getTupleCounter().update(matchingTupleCount);\n        if (matchingTupleCount == 0 && retainInput && retainMissing) {\n            FrameUtils.appendConcatToWriter(writer, appender, accessor, tupleIndex,\n                    nonMatchTupleBuild.getFieldEndOffsets(), nonMatchTupleBuild.getByteArray(), 0,\n                    nonMatchTupleBuild.getSize());\n        }\n    }\n    @Override\n    public void nextFrame(ByteBuffer buffer) throws HyracksDataException {\n        accessor.reset(buffer);\n        int tupleCount = accessor.getTupleCount();\n        try {\n            for (int i = 0; i < tupleCount && !finished; i++) {\n                resetSearchPredicate(i);\n                cursor.close();\n                indexAccessor.search(cursor, searchPred);\n                writeSearchResults(i);\n            }\n        } catch (Exception e) {\n            throw HyracksDataException.create(e);\n        }\n    }\n    @Override\n    public void flush() throws HyracksDataException {\n        appender.flush(writer);\n    }\n<fim_suffix>    @Override\n    public void close() throws HyracksDataException {\n        Throwable failure = releaseResources();\n        failure = CleanupUtils.close(writer, failure);\n        if (failure != null) {\n            throw HyracksDataException.create(failure);\n        }\n    }<fim_middle>// function below has no smell\n"}