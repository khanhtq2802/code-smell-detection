{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/* Generated By:JavaCC: Do not edit this line. TokenMgrError.java Version 5.0 */\n/* JavaCCOptions: */\npackage org.apache.camel.component.sql.stored.template.generated;\n\n/** Token Manager Error. */\n<fim_suffix>public class TokenMgrError extends Error\n{\n\n  /**\n   * The version identifier for this Serializable class.\n   * Increment only if the <i>serialized</i> form of the\n   * class changes.\n   */\n  private static final long serialVersionUID = 1L;\n\n  /*\n   * Ordinals for various reasons why an Error of this type can be thrown.\n   */\n\n  /**\n   * Lexical error occurred.\n   */\n  static final int LEXICAL_ERROR = 0;\n\n  /**\n   * An attempt was made to create a second instance of a static token manager.\n   */\n  static final int STATIC_LEXER_ERROR = 1;\n\n  /**\n   * Tried to change to an invalid lexical state.\n   */\n  static final int INVALID_LEXICAL_STATE = 2;\n\n  /**\n   * Detected (and bailed out of) an infinite loop in the token manager.\n   */\n  static final int LOOP_DETECTED = 3;\n\n  /**\n   * Indicates the reason why the exception is thrown. It will have\n   * one of the above 4 values.\n   */\n  int errorCode;\n\n  /**\n   * Replaces unprintable characters by their escaped (or unicode escaped)\n   * equivalents in the given string\n   */\n  protected static final String addEscapes(String str) {\n    StringBuffer retval = new StringBuffer();\n    char ch;\n    for (int i = 0; i < str.length(); i++) {\n      switch (str.charAt(i))\n      {\n        case 0 :\n          continue;\n        case '\\b':\n          retval.append(\"\\\\b\");\n          continue;\n        case '\\t':\n          retval.append(\"\\\\t\");\n          continue;\n        case '\\n':\n          retval.append(\"\\\\n\");\n          continue;\n        case '\\f':\n          retval.append(\"\\\\f\");\n          continue;\n        case '\\r':\n          retval.append(\"\\\\r\");\n          continue;\n        case '\\\"':\n          retval.append(\"\\\\\\\"\");\n          continue;\n        case '\\'':\n          retval.append(\"\\\\\\'\");\n          continue;\n        case '\\\\':\n          retval.append(\"\\\\\\\\\");\n          continue;\n        default:\n          if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {\n            String s = \"0000\" + Integer.toString(ch, 16);\n            retval.append(\"\\\\u\" + s.substring(s.length() - 4, s.length()));\n          } else {\n            retval.append(ch);\n          }\n          continue;\n      }\n    }\n    return retval.toString();\n  }\n\n  /**\n   * Returns a detailed message for the Error when it is thrown by the\n   * token manager to indicate a lexical error.\n   * Parameters :\n   *    EOFSeen     : indicates if EOF caused the lexical error\n   *    curLexState : lexical state in which this error occurred\n   *    errorLine   : line number when the error occurred\n   *    errorColumn : column number when the error occurred\n   *    errorAfter  : prefix that was seen before this error occurred\n   *    curchar     : the offending character\n   * Note: You can customize the lexical error message by modifying this method.\n   */\n  protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {\n    return(\"Lexical error at line \" +\n          errorLine + \", column \" +\n          errorColumn + \".  Encountered: \" +\n          (EOFSeen ? \"<EOF> \" : (\"\\\"\" + addEscapes(String.valueOf(curChar)) + \"\\\"\") + \" (\" + (int)curChar + \"), \") +\n          \"after : \\\"\" + addEscapes(errorAfter) + \"\\\"\");\n  }\n\n  /**\n   * You can also modify the body of this method to customize your error messages.\n   * For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not\n   * of end-users concern, so you can return something like :\n   *\n   *     \"Internal Error : Please file a bug report .... \"\n   *\n   * from this method for such cases in the release version of your parser.\n   */\n  public String getMessage() {\n    return super.getMessage();\n  }\n\n  /*\n   * Constructors of various flavors follow.\n   */\n\n  /** No arg constructor. */\n  public TokenMgrError() {\n  }\n\n  /** Constructor with message and reason. */\n  public TokenMgrError(String message, int reason) {\n    super(message);\n    errorCode = reason;\n  }\n\n  /** Full Constructor. */\n  public TokenMgrError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar, int reason) {\n    this(LexicalError(EOFSeen, lexState, errorLine, errorColumn, errorAfter, curChar), reason);\n  }\n}\n/* JavaCC - OriginalChecksum=076ac52ededde06a2bcb85f2834da49c (do not edit this line) */<fim_middle>// class below is blob\n"}