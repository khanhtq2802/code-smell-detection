{"text": "<fim_prefix>/*\n * Copyright (c) 2018 MapleLabs. All Rights Reserved.\n * SPDX-License-Identifier: Apache-2.0\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.hillview.storage;\nimport org.apache.commons.io.FilenameUtils;\nimport org.hillview.table.ColumnDescription;\nimport org.hillview.table.Schema;\nimport org.hillview.table.Table;\nimport org.hillview.table.api.ContentsKind;\nimport org.hillview.table.api.IAppendableColumn;\nimport org.hillview.table.api.IColumn;\nimport org.hillview.table.api.ITable;\nimport org.hillview.table.columns.ConstantStringColumn;\nimport org.hillview.table.columns.IntListColumn;\nimport org.hillview.table.columns.StringListColumn;\nimport org.hillview.utils.DateParsing;\nimport org.hillview.utils.GrokExtra;\nimport org.hillview.utils.HillviewLogger;\nimport org.hillview.utils.Utilities;\nimport java.time.Instant;\nimport java.util.List;\nimport java.util.Map;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport io.krakens.grok.api.*;\nimport javax.annotation.Nullable;\n/**\n * Reads Generic logs into ITable objects.\n */\npublic class GenericLogs {\n    private final String logFormat;\n    /**\n     * This column name must appear in all log formats.\n     */\n    public static final String timestampColumnName = \"Timestamp\";\n    /**\n     * Column name where the lines that are not parsed correctly are stored.\n     */\n    public static final String parseErrorColumn = \"ParsingErrors\";\n    public static final String hostColumn = \"Host\";\n    public static final String directoryColumn = \"Directory\";\n    public static final String filenameColumn = \"Filename\";\n    public static final String lineNumberColumn = \"Line\";\n    public GenericLogs(String logFormat) {\n        this.logFormat = logFormat;\n    }\n    public class LogFileLoader extends TextFileLoader {\n        private final Grok grok;\n        private final GrokCompiler grokCompiler;\n        @Nullable\n        private final Instant start;\n        @Nullable\n        private final Instant end;\n        @Nullable\n        DateParsing dateTimeParser = null;\n        /**\n         * Pattern used for parsing timestamps.  Obtained from a column named 'Timestamp'.\n         */\n        @Nullable\n        private final Grok dateTime;\n        @Nullable\n        private List<String> columnNames = null;\n        private final StringListColumn parsingErrors;\n        private final IntListColumn lineNumber;\n<fim_suffix>        LogFileLoader(final String path, @Nullable Instant start, @Nullable Instant end) {\n            super(path);\n            this.grokCompiler = GrokCompiler.newInstance();\n            this.grokCompiler.registerDefaultPatterns();\n            this.grokCompiler.registerPatternFromClasspath(\"/patterns/log-patterns\");\n            this.grok = grokCompiler.compile(logFormat, true);\n            this.start = start;\n            this.end = end;\n            this.parsingErrors = new StringListColumn(\n                new ColumnDescription(parseErrorColumn, ContentsKind.String));\n            this.lineNumber = new IntListColumn(\n                    new ColumnDescription(lineNumberColumn, ContentsKind.Integer));\n            String originalPattern = this.grok.getOriginalGrokPattern();\n            String timestampPattern = GrokExtra.extractGroupPattern(\n                    this.grokCompiler.getPatternDefinitions(),\n                    originalPattern, GenericLogs.timestampColumnName);\n            if (timestampPattern == null) {\n                HillviewLogger.instance.warn(\"Pattern does not contain column named 'Timestamp'\",\n                        \"{0}\", originalPattern);\n                this.dateTime = null;\n            } else {\n                this.dateTime = this.grokCompiler.compile(\n                        \"%{\" + timestampPattern + \":\" + GenericLogs.timestampColumnName + \"}\", true);\n            }\n        }\n        boolean parse(String line, String[] output) {\n            assert this.columnNames != null;\n            Match gm = this.grok.match(line);\n            final Map<String, Object> capture = gm.capture();\n            if (capture.size() > 0) {\n                int index = 0;\n                for (String col : this.columnNames) {\n                    output[index] = capture.get(col).toString().replace(\"\\\\n\", \"\\n\").trim();\n                    index += 1;\n                }\n                return true;\n            }\n            return false;\n        }\n        @Override\n        public ITable load() {\n            // Create the schema and allocate the columns based on the pattern.\n            Schema schema = new Schema();\n            this.columnNames = GrokExtra.getColumnsFromPattern(this.grok);\n            for (String colName: this.columnNames) {\n                ContentsKind kind = ContentsKind.String;\n                if (colName.equals(GenericLogs.timestampColumnName))\n                    kind = ContentsKind.Date;\n                schema.append(new ColumnDescription(colName, kind));\n            }\n            this.columns = schema.createAppendableColumns();\n            String[] fields = new String[this.columns.length];\n            boolean first = true;\n            // True if the first non-empty line does not have a timestamp\n            boolean firstTimestampIsMissing = this.dateTime == null;\n            int currentLineNumber = 0;\n            int previousLineNumber = 0;\n            try (BufferedReader reader = new BufferedReader(\n                    this.getFileReader())) {\n                // Used to build up a log line that spans multiple file lines\n                StringBuilder logLine = new StringBuilder();\n                String fileLine; // Current line in the file\n                while (true) {\n                    currentLineNumber++;\n                    fileLine = reader.readLine();\n                    if (fileLine != null) {\n                        if (fileLine.trim().isEmpty())\n                            continue;\n                        @Nullable\n                        String currentTimestamp = null;\n                        if (this.dateTime != null) {\n                            Match gm = this.dateTime.match(fileLine);\n                            if (!gm.isNull())\n                                currentTimestamp = gm.capture()\n                                        .get(GenericLogs.timestampColumnName)\n                                        .toString();\n                            else if (first)\n                                // If the first line does not have a timestamp\n                                // it may be that the pattern supplied by the user\n                                // is actually wrong.   We do not want to end up\n                                // concatenating all log lines into one big line.\n                                firstTimestampIsMissing = true;\n                        }\n                        first = false;\n                        // If there is no timestamp in a fileLine we consider heuristically that it\n                        // is a continuation of the previous logLine.\n                        if (currentTimestamp == null && !firstTimestampIsMissing) {\n                            if (logLine.length() != 0)\n                                logLine.append(\"\\\\n\");\n                            logLine.append(fileLine);\n                            continue;\n                        } else {\n                            if (currentTimestamp != null &&\n                                    (this.start != null || this.end != null)) {\n                                if (this.dateTimeParser == null)\n                                    this.dateTimeParser = new DateParsing(currentTimestamp);\n                                Instant parsed = this.dateTimeParser.parse(currentTimestamp);\n                                if (this.start != null && this.start.isAfter(parsed))\n                                    continue;\n                                if (this.end != null && this.end.isBefore(parsed))\n                                    // We assume timestamps are monotone, and thus\n                                    // we won't see another one smaller.  So we end\n                                    // parsing here.\n                                    fileLine = null;\n                            }\n                        }\n                    }\n                    // If we reach this point fileLine has a date or is null.\n                    // We parse the logLine and save the fileLine for next time.\n                    String logString = logLine.toString();\n                    if (!logString.isEmpty()) {\n                        logLine.setLength(0);\n                        this.lineNumber.append(previousLineNumber);\n                        if (this.parse(logString, fields)) {\n                            this.append(fields);\n                            this.parsingErrors.appendMissing();\n                        } else {\n                            for (IAppendableColumn c: this.columns)\n                                c.appendMissing();\n                            this.parsingErrors.append(logString);\n                        }\n                    }\n                    previousLineNumber = currentLineNumber;\n                    if (fileLine == null)\n                        break;\n                    logLine.append(fileLine);\n                }\n            } catch (IOException e) {\n                this.error(e.getMessage());\n            }\n            this.close(null);\n            int size;\n            int columnCount;\n            if (this.columns == null)\n                columnCount = 0;\n            else\n                columnCount = this.columns.length;\n            if (columnCount == 0)\n                size = 0;\n            else\n                size = this.columns[0].sizeInRows();\n            // Create a new column for the host<fim_middle>// function below is long method\n"}