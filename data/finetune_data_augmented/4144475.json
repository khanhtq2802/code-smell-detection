{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.calcite.rex;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.Iterables;\nimport java.util.ArrayList;\nimport java.util.List;\n/**\n * Passes over a row-expression, calling a handler method for each node,\n * appropriate to the type of the node.\n *\n * <p>Like {@link RexVisitor}, this is an instance of the\n * {@link org.apache.calcite.util.Glossary#VISITOR_PATTERN Visitor Pattern}. Use\n * <code> RexShuttle</code> if you would like your methods to return a\n * value.</p>\n */\npublic class RexShuttle implements RexVisitor<RexNode> {\n  //~ Methods ----------------------------------------------------------------\n  public RexNode visitOver(RexOver over) {\n    boolean[] update = {false};\n    List<RexNode> clonedOperands = visitList(over.operands, update);\n    RexWindow window = visitWindow(over.getWindow());\n    if (update[0] || (window != over.getWindow())) {\n      // REVIEW jvs 8-Mar-2005:  This doesn't take into account\n      // the fact that a rewrite may have changed the result type.\n      // To do that, we would need to take a RexBuilder and\n      // watch out for special operators like CAST and NEW where\n      // the type is embedded in the original call.\n      return new RexOver(\n          over.getType(),\n          over.getAggOperator(),\n          clonedOperands,\n          window,\n          over.isDistinct());\n    } else {\n      return over;\n    }\n  }\n  public RexWindow visitWindow(RexWindow window) {\n    boolean[] update = {false};\n    List<RexFieldCollation> clonedOrderKeys =\n        visitFieldCollations(window.orderKeys, update);\n    List<RexNode> clonedPartitionKeys =\n        visitList(window.partitionKeys, update);\n    RexWindowBound lowerBound = window.getLowerBound().accept(this);\n    RexWindowBound upperBound = window.getUpperBound().accept(this);\n    if (update[0]\n        || (lowerBound != window.getLowerBound() && lowerBound != null)\n        || (upperBound != window.getUpperBound() && upperBound != null)) {\n      return new RexWindow(\n          clonedPartitionKeys,\n          clonedOrderKeys,\n          lowerBound,\n          upperBound,\n          window.isRows());\n    } else {\n      return window;\n    }\n  }\n  public RexNode visitSubQuery(RexSubQuery subQuery) {\n    boolean[] update = {false};\n    List<RexNode> clonedOperands = visitList(subQuery.operands, update);\n    if (update[0]) {\n      return subQuery.clone(subQuery.getType(), clonedOperands);\n    } else {\n      return subQuery;\n    }\n  }\n  @Override public RexNode visitTableInputRef(RexTableInputRef ref) {\n    return ref;\n  }\n  @Override public RexNode visitPatternFieldRef(RexPatternFieldRef fieldRef) {\n    return fieldRef;\n  }\n  public RexNode visitCall(final RexCall call) {\n    boolean[] update = {false};\n    List<RexNode> clonedOperands = visitList(call.operands, update);\n    if (update[0]) {\n      // REVIEW jvs 8-Mar-2005:  This doesn't take into account\n      // the fact that a rewrite may have changed the result type.\n      // To do that, we would need to take a RexBuilder and\n      // watch out for special operators like CAST and NEW where\n      // the type is embedded in the original call.\n      return call.clone(call.getType(), clonedOperands);\n    } else {\n      return call;\n    }\n  }\n  /**\n   * Visits each of an array of expressions and returns an array of the\n   * results.\n   *\n   * @param exprs  Array of expressions\n   * @param update If not null, sets this to true if any of the expressions\n   *               was modified\n   * @return Array of visited expressions\n   */\n  protected RexNode[] visitArray(RexNode[] exprs, boolean[] update) {\n    RexNode[] clonedOperands = new RexNode[exprs.length];\n    for (int i = 0; i < exprs.length; i++) {\n      RexNode operand = exprs[i];\n      RexNode clonedOperand = operand.accept(this);\n      if ((clonedOperand != operand) && (update != null)) {\n        update[0] = true;\n      }\n      clonedOperands[i] = clonedOperand;\n    }\n    return clonedOperands;\n  }\n  /**\n   * Visits each of a list of expressions and returns a list of the\n   * results.\n   *\n   * @param exprs  List of expressions\n   * @param update If not null, sets this to true if any of the expressions\n   *               was modified\n   * @return Array of visited expressions\n   */\n  protected List<RexNode> visitList(\n      List<? extends RexNode> exprs, boolean[] update) {\n    ImmutableList.Builder<RexNode> clonedOperands = ImmutableList.builder();\n    for (RexNode operand : exprs) {\n      RexNode clonedOperand = operand.accept(this);\n      if ((clonedOperand != operand) && (update != null)) {\n        update[0] = true;\n      }\n      clonedOperands.add(clonedOperand);\n    }\n    return clonedOperands.build();\n  }\n  /**\n   * Visits a list and writes the results to another list.\n   */\n  public void visitList(\n      List<? extends RexNode> exprs, List<RexNode> outExprs) {\n    for (RexNode expr : exprs) {\n      outExprs.add(expr.accept(this));\n    }\n  }\n  /**\n   * Visits each of a list of field collations and returns a list of the\n   * results.\n   *\n   * @param collations List of field collations\n   * @param update     If not null, sets this to true if any of the expressions\n   *                   was modified\n   * @return Array of visited field collations\n   */\n<fim_suffix>  protected List<RexFieldCollation> visitFieldCollations(\n      List<RexFieldCollation> collations, boolean[] update) {\n    ImmutableList.Builder<RexFieldCollation> clonedOperands =\n        ImmutableList.builder();\n    for (RexFieldCollation collation : collations) {\n      RexNode clonedOperand = collation.left.accept(this);\n      if ((clonedOperand != collation.left) && (update != null)) {\n        update[0] = true;\n        collation =\n            new RexFieldCollation(clonedOperand, collation.right);\n      }\n      clonedOperands.add(collation);\n    }\n    return clonedOperands.build();\n  }\n  public RexNode visitCorrelVariable(RexCorrelVariable variable) {\n    return variable;\n  }\n  public RexNode visitFieldAccess(RexFieldAccess fieldAccess) {\n    RexNode before = fieldAccess.getReferenceExpr();\n    RexNode after = before.accept(this);\n    if (before == after) {\n      return fieldAccess;\n    } else {\n      return new RexFieldAccess(\n          after,\n          fieldAccess.getField());\n    }\n  }\n  public RexNode visitInputRef(RexInputRef inputRef) {\n    return inputRef;\n  }\n  public RexNode visitLocalRef(RexLocalRef localRef) {\n    return localRef;\n  }\n  public RexNode visitLiteral(RexLiteral literal) {\n    return literal;\n  }\n  public RexNode visitDynamicParam(RexDynamicParam dynamicParam) {\n    return dynamicParam;\n  }\n  public RexNode visitRangeRef(RexRangeRef rangeRef) {\n    return rangeRef;\n  }\n  /**\n   * Applies this shuttle to each expression in a list.\n   *\n   * @return whether any of the expressions changed\n   */\n  public final <T extends RexNode> boolean mutate(List<T> exprList) {\n    int changeCount = 0;\n    for (int i = 0; i < exprList.size(); i++) {\n      T expr = exprList.get(i);<fim_middle>// function below has no smell\n"}