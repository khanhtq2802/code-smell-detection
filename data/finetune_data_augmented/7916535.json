{"text": "<fim_prefix>     *                           of the properties file.  If none specified,\n     *                           ${java.home}/lib/xalan.properties will be used.\n     * @param fallbackClassName     Implementation class name, if nothing else\n     *                              is found.  Use null to mean no fallback.\n     *\n     * @exception ObjectFactory.ConfigurationError\n     */\n    static String lookUpFactoryClassName(String factoryId,\n                                                String propertiesFilename,\n                                                String fallbackClassName)\n    {\n        // Use the system property first\n        try {\n            String systemProp = SecuritySupport.getSystemProperty(factoryId);\n            if (systemProp != null) {\n                debugPrintln(\"found system property, value=\" + systemProp);\n                return systemProp;\n            }\n        } catch (SecurityException se) {\n            // Ignore and continue w/ next location\n        }\n        // Try to read from propertiesFilename, or\n        // $java.home/lib/xalan.properties\n        String factoryClassName = null;\n        // no properties file name specified; use\n        // $JAVA_HOME/lib/xalan.properties:\n        if (propertiesFilename == null) {\n            File propertiesFile = null;\n            boolean propertiesFileExists = false;\n            try {\n                String javah = SecuritySupport.getSystemProperty(\"java.home\");\n                propertiesFilename = javah + File.separator +\n                    \"lib\" + File.separator + DEFAULT_PROPERTIES_FILENAME;\n                propertiesFile = new File(propertiesFilename);\n                propertiesFileExists = SecuritySupport.getFileExists(propertiesFile);\n            } catch (SecurityException e) {\n                // try again...\n                fLastModified = -1;\n                fXalanProperties = null;\n            }\n            synchronized (ObjectFactory.class) {\n                boolean loadProperties = false;\n                FileInputStream fis = null;\n                try {\n                    // file existed last time\n                    if(fLastModified >= 0) {\n                        if(propertiesFileExists &&\n                                (fLastModified < (fLastModified = SecuritySupport.getLastModified(propertiesFile)))) {\n                            loadProperties = true;\n                        } else {\n                            // file has stopped existing...\n                            if(!propertiesFileExists) {\n                                fLastModified = -1;\n                                fXalanProperties = null;\n                            } // else, file wasn't modified!\n                        }\n                    } else {\n                        // file has started to exist:\n                        if(propertiesFileExists) {\n                            loadProperties = true;\n                            fLastModified = SecuritySupport.getLastModified(propertiesFile);\n                        } // else, nothing's changed\n                    }\n                    if(loadProperties) {\n                        // must never have attempted to read xalan.properties\n                        // before (or it's outdeated)\n                        fXalanProperties = new Properties();\n                        fis = SecuritySupport.getFileInputStream(propertiesFile);\n                        fXalanProperties.load(fis);\n                    }\n\t        } catch (Exception x) {\n\t            fXalanProperties = null;\n\t            fLastModified = -1;\n                    // assert(x instanceof FileNotFoundException\n\t            //        || x instanceof SecurityException)\n\t            // In both cases, ignore and continue w/ next location\n\t        }\n                finally {\n                    // try to close the input stream if one was opened.\n                    if (fis != null) {\n                        try {\n                            fis.close();\n                        }\n                        // Ignore the exception.\n                        catch (IOException exc) {}\n                    }\n                }\t            \n            }\n            if(fXalanProperties != null) {\n                factoryClassName = fXalanProperties.getProperty(factoryId);\n            }\n        } else {\n            FileInputStream fis = null;\n            try {\n                fis = SecuritySupport.getFileInputStream(new File(propertiesFilename));\n                Properties props = new Properties();\n                props.load(fis);\n                factoryClassName = props.getProperty(factoryId);\n            } catch (Exception x) {\n                // assert(x instanceof FileNotFoundException\n                //        || x instanceof SecurityException)\n                // In both cases, ignore and continue w/ next location\n            }\n            finally {\n                // try to close the input stream if one was opened.\n                if (fis != null) {\n                    try {\n                        fis.close();\n                    }\n                    // Ignore the exception.\n                    catch (IOException exc) {}\n                }\n            }               \n        }\n        if (factoryClassName != null) {\n            debugPrintln(\"found in \" + propertiesFilename + \", value=\"\n                          + factoryClassName);\n            return factoryClassName;\n        }\n        // Try Jar Service Provider Mechanism\n        return findJarServiceProviderName(factoryId);\n    } // lookUpFactoryClass(String,String):String\n    //\n    // Private static methods\n    //\n    /** Prints a message to standard error if debugging is enabled. */\n    private static void debugPrintln(String msg) {\n        if (DEBUG) {\n            System.err.println(\"JAXP: \" + msg);\n        }\n    } // debugPrintln(String)\n    /**\n     * Figure out which ClassLoader to use.  For JDK 1.2 and later use\n     * the context ClassLoader.\n     */\n    static ClassLoader findClassLoader()\n        throws ConfigurationError\n    { \n        // Now we just return the ClassLoader which loads this class\n        // to work in OSGI platform\n        return ObjectFactory.class.getClassLoader();\n        /*\n        // Figure out which ClassLoader to use for loading the provider\n        // class.  If there is a Context ClassLoader then use it.\n        ClassLoader context = SecuritySupport.getContextClassLoader();\n        ClassLoader system = SecuritySupport.getSystemClassLoader();\n        ClassLoader chain = system;\n        while (true) {\n            if (context == chain) {\n                // Assert: we are on JDK 1.1 or we have no Context ClassLoader\n                // or any Context ClassLoader in chain of system classloader\n                // (including extension ClassLoader) so extend to widest\n                // ClassLoader (always look in system ClassLoader if Xalan\n                // is in boot/extension/system classpath and in current\n                // ClassLoader otherwise); normal classloaders delegate\n                // back to system ClassLoader first so this widening doesn't\n                // change the fact that context ClassLoader will be consulted\n                ClassLoader current = ObjectFactory.class.getClassLoader();\n                chain = system;\n                while (true) {\n                    if (current == chain) {\n                        // Assert: Current ClassLoader in chain of\n                        // boot/extension/system ClassLoaders\n                        return system;\n                    }\n                    if (chain == null) {\n                        break;\n                    }\n                    chain = SecuritySupport.getParentClassLoader(chain);\n                }\n                // Assert: Current ClassLoader not in chain of\n                // boot/extension/system ClassLoaders\n                return current;\n            }\n            if (chain == null) {\n                // boot ClassLoader reached\n                break;\n            }\n            // Check for any extension ClassLoaders in chain up to\n            // boot ClassLoader\n            chain = SecuritySupport.getParentClassLoader(chain);\n        };\n        // Assert: Context ClassLoader not in chain of\n        // boot/extension/system ClassLoaders\n        return context;\n        */\n    } // findClassLoader():ClassLoader\n    /**\n     * Create an instance of a class using the specified ClassLoader\n     */ \n    static Object newInstance(String className, ClassLoader cl,\n                                      boolean doFallback)\n        throws ConfigurationError\n    {\n        // assert(className != null);\n        try{\n            Class providerClass = findProviderClass(className, cl, doFallback);\n            Object instance = providerClass.newInstance();\n            debugPrintln(\"created new instance of \" + providerClass +\n                   \" using ClassLoader: \" + cl);\n            return instance;\n        } catch (ClassNotFoundException x) {\n            throw new ConfigurationError(\n                \"Provider \" + className + \" not found\", x);\n        } catch (Exception x) {\n            throw new ConfigurationError(\n                \"Provider \" + className + \" could not be instantiated: \" + x,\n                x);\n        }\n    }\n    /**\n     * Find a Class using the specified ClassLoader\n     */ \n<fim_suffix>    static Class findProviderClass(String className, ClassLoader cl,\n                                           boolean doFallback)\n        throws ClassNotFoundException, ConfigurationError\n    {   \n        //throw security exception if the calling thread is not allowed to access the\n        //class. Restrict the access to the package classes as specified in java.security policy.\n        SecurityManager security = System.getSecurityManager();\n        try{\n                if (security != null){\n                    final int lastDot = className.lastIndexOf('.');\n                    String packageName = className;\n                    if (lastDot != -1) packageName = className.substring(0, lastDot);\n                    security.checkPackageAccess(packageName);\n                 }   \n        }catch(SecurityException e){\n            throw e;\n        }\n        Class providerClass;\n        if (cl == null) {\n            // XXX Use the bootstrap ClassLoader.  There is no way to\n            // load a class using the bootstrap ClassLoader that works\n            // in both JDK 1.1 and Java 2.  However, this should still\n            // work b/c the following should be true:\n            //\n            // (cl == null) iff current ClassLoader == null\n            //\n            // Thus Class.forName(String) will use the current\n            // ClassLoader which will be the bootstrap ClassLoader.\n            providerClass = Class.forName(className);\n        } else {\n            try {\n                providerClass = cl.loadClass(className);\n            } catch (ClassNotFoundException x) {\n                if (doFallback) {\n                    // Fall back to current classloader\n                    ClassLoader current = ObjectFactory.class.getClassLoader();\n                    if (current == null) {\n                        providerClass = Class.forName(className);\n                    } else if (cl != current) {\n                        cl = current;\n                        providerClass = cl.loadClass(className);\n                    } else {\n                        throw x;\n                    }\n                } else {\n                    throw x;\n                }\n            }\n        }\n        return providerClass;\n    }<fim_middle>// function below is long method\n"}