{"text": "<fim_prefix>/*\n * Copyright 2006-2014 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.batch.sample.common;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport javax.sql.DataSource;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n\nimport org.springframework.batch.core.ExitStatus;\nimport org.springframework.batch.core.StepExecution;\nimport org.springframework.batch.core.StepExecutionListener;\nimport org.springframework.batch.item.ItemReader;\nimport org.springframework.batch.item.ReaderNotOpenException;\nimport org.springframework.beans.factory.DisposableBean;\nimport org.springframework.beans.factory.InitializingBean;\nimport org.springframework.jdbc.core.JdbcOperations;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.jdbc.core.RowMapper;\nimport org.springframework.util.Assert;\nimport org.springframework.util.SerializationUtils;\n\n/**\n * Thread-safe database {@link ItemReader} implementing the process indicator\n * pattern.\n *\n * To achieve restartability use together with {@link StagingItemProcessor}.\n */\n<fim_suffix>public class StagingItemReader<T> implements ItemReader<ProcessIndicatorItemWrapper<T>>, StepExecutionListener,\nInitializingBean, DisposableBean {\n\n\tprivate static Log logger = LogFactory.getLog(StagingItemReader.class);\n\n\tprivate StepExecution stepExecution;\n\n\tprivate final Object lock = new Object();\n\n\tprivate volatile boolean initialized = false;\n\n\tprivate volatile Iterator<Long> keys;\n\n\tprivate JdbcOperations jdbcTemplate;\n\n\tpublic void setDataSource(DataSource dataSource) {\n\t\tjdbcTemplate = new JdbcTemplate(dataSource);\n\t}\n\n\t@Override\n\tpublic void destroy() throws Exception {\n\t\tinitialized = false;\n\t\tkeys = null;\n\t}\n\n\t@Override\n\tpublic final void afterPropertiesSet() throws Exception {\n\t\tAssert.notNull(jdbcTemplate, \"You must provide a DataSource.\");\n\t}\n\n\tprivate List<Long> retrieveKeys() {\n\n\t\tsynchronized (lock) {\n\n\t\t\treturn jdbcTemplate.query(\n\n\t\t\t\t\t\"SELECT ID FROM BATCH_STAGING WHERE JOB_ID=? AND PROCESSED=? ORDER BY ID\",\n\n\t\t\t\t\tnew RowMapper<Long>() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic Long mapRow(ResultSet rs, int rowNum) throws SQLException {\n\t\t\t\t\t\t\treturn rs.getLong(1);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\n\t\t\t\t\tstepExecution.getJobExecution().getJobId(), StagingItemWriter.NEW);\n\n\t\t}\n\n\t}\n\n\t@Override\n\tpublic ProcessIndicatorItemWrapper<T> read() {\n\t\tif (!initialized) {\n\t\t\tthrow new ReaderNotOpenException(\"Reader must be open before it can be used.\");\n\t\t}\n\n\t\tLong id = null;\n\t\tsynchronized (lock) {\n\t\t\tif (keys.hasNext()) {\n\t\t\t\tid = keys.next();\n\t\t\t}\n\t\t}\n\t\tlogger.debug(\"Retrieved key from list: \" + id);\n\n\t\tif (id == null) {\n\t\t\treturn null;\n\t\t}\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tT result = (T) jdbcTemplate.queryForObject(\"SELECT VALUE FROM BATCH_STAGING WHERE ID=?\",\n\t\t\t\tnew RowMapper<Object>() {\n\t\t\t@Override\n\t\t\tpublic Object mapRow(ResultSet rs, int rowNum) throws SQLException {\n\t\t\t\tbyte[] blob = rs.getBytes(1);\n\t\t\t\treturn SerializationUtils.deserialize(blob);\n\t\t\t}\n\t\t}, id);\n\n\t\treturn new ProcessIndicatorItemWrapper<>(id, result);\n\t}\n\n\t@Override\n\tpublic ExitStatus afterStep(StepExecution stepExecution) {\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic void beforeStep(StepExecution stepExecution) {\n\t\tthis.stepExecution = stepExecution;\n\t\tsynchronized (lock) {\n\t\t\tif (keys == null) {\n\t\t\t\tkeys = retrieveKeys().iterator();\n\t\t\t\tlogger.info(\"Keys obtained for staging.\");\n\t\t\t\tinitialized = true;\n\t\t\t}\n\t\t}\n\t}\n\n}<fim_middle>// class below has no smell\n"}