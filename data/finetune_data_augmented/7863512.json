{"text": "<fim_prefix>            processor.doNetWrite(event, netWriteRecipients, localWriter,\n                SearchLoadAndWriteProcessor.BEFOREREGIONDESTROY);\n            result = true;\n          } finally {\n            processor.release();\n          }\n        } finally {\n          getCachePerfStats().endCacheWriterCall(start);\n        }\n      }\n      serverRegionDestroy(event);\n    }\n    return result;\n  }\n  protected void distributedRegionCleanup(RegionEventImpl event) {\n    if (event == null || event.getOperation() != Operation.REGION_REINITIALIZE) {\n      // only perform this if reinitialize is not due to resumption\n      // (REGION_REINITIALIZE)\n      // or if event is null then this was a failed initialize (create)\n      // wake up any threads in waitForRequiredRoles... they will checkReadiness\n      synchronized (this.missingRequiredRoles) {\n        this.missingRequiredRoles.notifyAll();\n      }\n    }\n    if (this.persistenceAdvisor != null) {\n      this.persistenceAdvisor.close(); // fix for bug 41094\n    }\n    this.distAdvisor.close();\n    // Fix for bug 46338. Wait for in progress clears before destroying the\n    // lock service, because destroying the service immediately releases the dlock\n    waitForInProgressClear();\n    DLockService dls = null;\n    synchronized (this.dlockMonitor) {\n      if (this.dlockService != null) {\n        dls = (DLockService) this.dlockService;\n      }\n    }\n    if (dls != null) {\n      try {\n        dls.destroyAndRemove();\n      } catch (CancelException e) {\n        // bug 37118\n        if (logger.isDebugEnabled()) {\n          logger.debug(\"DLS destroy abridged due to shutdown\", e);\n        }\n      } catch (Exception ex) {\n        logger.warn(\"DLS destroy may have failed for \" +\n            this.getFullPath(),\n            ex);\n      }\n    }\n    waitForCurrentOperations();\n  }\n  protected void waitForCurrentOperations() {\n    // Fix for #48066 - make sure that region operations are completely\n    // distributed to peers before destroying the region.\n    boolean flushOnClose =\n        !Boolean.getBoolean(DistributionConfig.GEMFIRE_PREFIX + \"no-flush-on-close\"); // test hook\n    if (!this.cache.forcedDisconnect() && flushOnClose\n        && this.getDistributionManager().getMembershipManager() != null\n        && this.getDistributionManager().getMembershipManager().isConnected()) {\n      getDistributionAdvisor().forceNewMembershipVersion();\n      try {\n        getDistributionAdvisor().waitForCurrentOperations();\n      } catch (Exception e) {\n        // log this but try to close the region so that listeners are invoked\n        logger.warn(String.format(\"%s: error closing region %s\",\n            new Object[] {this, getFullPath()}), e);\n      }\n    }\n  }\n  /**\n   * In addition to inherited code this method also invokes RegionMembershipListeners\n   */\n  @Override\n  public void postCreateRegion() {\n    super.postCreateRegion();\n    // should we sync on this.distAdvisor first to prevent bug 44369?\n    synchronized (this.advisorListener) {\n      Set others = this.advisorListener.getInitialMembers();\n      CacheListener[] listeners = fetchCacheListenersField();\n      if (listeners != null) {\n        for (CacheListener listener : listeners) {\n          if (listener instanceof RegionMembershipListener) {\n            RegionMembershipListener regionMembershipListener = (RegionMembershipListener) listener;\n            try {\n              DistributedMember[] otherDms = new DistributedMember[others.size()];\n              others.toArray(otherDms);\n              regionMembershipListener.initialMembers(this, otherDms);\n            } catch (VirtualMachineError err) {\n              SystemFailure.initiateFailure(err);\n              // If this ever returns, rethrow the error. We're poisoned\n              // now, so don't let this thread continue.\n              throw err;\n            } catch (Throwable t) {\n              // Whenever you catch Error or Throwable, you must also\n              // catch VirtualMachineError (see above). However, there is\n              // _still_ a possibility that you are dealing with a cascading\n              // error condition, so you also need to check to see if the JVM\n              // is still usable:\n              SystemFailure.checkFailure();\n              logger.error(\"Exception occurred in RegionMembershipListener\",\n                  t);\n            }\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Free resources held by this region. This method is invoked after isDestroyed has been set to\n   * true.\n   */\n  @Override\n  protected void postDestroyRegion(boolean destroyDiskRegion, RegionEventImpl event) {\n    distributedRegionCleanup(event);\n    try {\n      super.postDestroyRegion(destroyDiskRegion, event);\n    } catch (CancelException e) {\n      // I don't think this should ever happens: bulletproofing for bug 39454\n      logger.warn(\"postDestroyRegion: encountered cancellation\", e);\n    }\n  }\n  @Override\n  public void cleanupFailedInitialization() {\n    super.cleanupFailedInitialization();\n    try {\n      RegionEventImpl ev = new RegionEventImpl(this, Operation.REGION_CLOSE, null, false, getMyId(),\n          generateEventID());\n      distributeDestroyRegion(ev, true);\n      distributedRegionCleanup(null);\n    } catch (RegionDestroyedException ignore) {\n      // someone else must have concurrently destroyed the region (maybe a distributed destroy)\n    } catch (CancelException ignore) {\n      // cache or DS is closed, ignore\n    } catch (VirtualMachineError e) {\n      SystemFailure.initiateFailure(e);\n      throw e;\n    } catch (Throwable t) {\n      logger.warn(\"Error cleaning up after failed region initialization of region \" + this,\n          t);\n    }\n  }\n  @Override\n  public void handleCacheClose(Operation operation) {\n    try {\n      super.handleCacheClose(operation);\n    } finally {\n      distributedRegionCleanup(null);\n    }\n  }\n  /**\n   * invoke a cache writer before a put is performed elsewhere\n   */\n  @Override\n  public void cacheWriteBeforePut(EntryEventImpl event, Set netWriteRecipients,\n      CacheWriter localWriter, boolean requireOldValue, Object expectedOldValue)\n      throws CacheWriterException, TimeoutException {\n    if ((localWriter != null || (netWriteRecipients != null && !netWriteRecipients.isEmpty()))\n        && !event.inhibitAllNotifications()) {\n      final boolean isNewKey = event.getOperation().isCreate();\n      final long start = getCachePerfStats().startCacheWriterCall();\n      try {\n        SearchLoadAndWriteProcessor processor = SearchLoadAndWriteProcessor.getProcessor();\n        processor.initialize(this, \"preUpdate\", null);\n        try {\n          if (!isNewKey) {\n            processor.doNetWrite(event, netWriteRecipients, localWriter,\n                SearchLoadAndWriteProcessor.BEFOREUPDATE);\n          } else {\n            processor.doNetWrite(event, netWriteRecipients, localWriter,\n                SearchLoadAndWriteProcessor.BEFORECREATE);\n          }\n        } finally {\n          processor.release();\n        }\n      } finally {\n        getCachePerfStats().endCacheWriterCall(start);\n      }\n    }\n    serverPut(event, requireOldValue, expectedOldValue);\n  }\n  @Override\n  protected void cacheListenersChanged(boolean nowHasListener) {\n    if (nowHasListener) {\n      this.advisorListener.initRMLWrappers();\n    }\n    new UpdateAttributesProcessor(this).distribute();\n  }\n  @Override\n  protected void cacheWriterChanged(CacheWriter oldWriter) {\n    super.cacheWriterChanged(oldWriter);\n    if (oldWriter == null ^ basicGetWriter() == null) {\n      new UpdateAttributesProcessor(this).distribute();\n    }\n  }\n  @Override\n  protected void cacheLoaderChanged(CacheLoader oldLoader) {\n    super.cacheLoaderChanged(oldLoader);\n    if (oldLoader == null ^ basicGetLoader() == null) {\n      new UpdateAttributesProcessor(this).distribute();\n    }\n  }\n  @Override\n  public void addGatewaySenderId(String gatewaySenderId) {\n    super.addGatewaySenderId(gatewaySenderId);\n    new UpdateAttributesProcessor(this).distribute();\n  }\n  @Override\n  public void removeGatewaySenderId(String gatewaySenderId) {\n    super.removeGatewaySenderId(gatewaySenderId);\n    new UpdateAttributesProcessor(this).distribute();\n  }\n  @Override\n  public void addAsyncEventQueueId(String asyncEventQueueId) {\n    super.addAsyncEventQueueId(asyncEventQueueId);\n    new UpdateAttributesProcessor(this).distribute();\n  }\n<fim_suffix>  @Override\n  public void removeAsyncEventQueueId(String asyncEventQueueId) {\n    super.removeAsyncEventQueueId(asyncEventQueueId);\n    new UpdateAttributesProcessor(this).distribute();\n  }<fim_middle>// function below has no smell\n"}