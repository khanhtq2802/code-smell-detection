{"text": "<fim_prefix>    op.encode(arr, off, blocks, blockIndex, nblocks);\n    final int diff = nblocks * valuesPerBlock;\n    index += diff; len -= diff;\n    if (index > originalIndex) {\n      // stay at the block boundary\n      return index - originalIndex;\n    } else {\n      // no progress so far => already at a block boundary but no full block to\n      // set\n      assert index == originalIndex;\n      return super.set(index, arr, off, len);\n    }\n  }\n  @Override\n  public void fill(int fromIndex, int toIndex, long val) {\n    assert fromIndex >= 0;\n    assert fromIndex <= toIndex;\n    assert PackedInts.unsignedBitsRequired(val) <= bitsPerValue;\n    final int valuesPerBlock = 64 / bitsPerValue;\n    if (toIndex - fromIndex <= valuesPerBlock << 1) {\n      // there needs to be at least one full block to set for the block\n      // approach to be worth trying\n      super.fill(fromIndex, toIndex, val);\n      return;\n    }\n    // set values naively until the next block start\n    int fromOffsetInBlock = fromIndex % valuesPerBlock;\n    if (fromOffsetInBlock != 0) {\n      for (int i = fromOffsetInBlock; i < valuesPerBlock; ++i) {\n        set(fromIndex++, val);\n      }\n      assert fromIndex % valuesPerBlock == 0;\n    }\n    // bulk set of the inner blocks\n    final int fromBlock = fromIndex / valuesPerBlock;\n    final int toBlock = toIndex / valuesPerBlock;\n    assert fromBlock * valuesPerBlock == fromIndex;\n    long blockValue = 0L;\n    for (int i = 0; i < valuesPerBlock; ++i) {\n      blockValue = blockValue | (val << (i * bitsPerValue));\n    }\n    Arrays.fill(blocks, fromBlock, toBlock, blockValue);\n    // fill the gap\n    for (int i = valuesPerBlock * toBlock; i < toIndex; ++i) {\n      set(i, val);\n    }\n  }\n  @Override\n  protected PackedInts.Format getFormat() {\n    return PackedInts.Format.PACKED_SINGLE_BLOCK;\n  }\n  @Override\n  public String toString() {\n    return getClass().getSimpleName() + \"(bitsPerValue=\" + bitsPerValue\n        + \",size=\" + size() + \",blocks=\" + blocks.length + \")\";\n  }\n  public static Packed64SingleBlock create(DataInput in,\n      int valueCount, int bitsPerValue) throws IOException {\n    Packed64SingleBlock reader = create(valueCount, bitsPerValue);\n    for (int i = 0; i < reader.blocks.length; ++i) {\n      reader.blocks[i] = in.readLong();\n    }\n    return reader;\n  }\n  public static Packed64SingleBlock create(int valueCount, int bitsPerValue) {\n    switch (bitsPerValue) {\n      case 1:\n        return new Packed64SingleBlock1(valueCount);\n      case 2:\n        return new Packed64SingleBlock2(valueCount);\n      case 3:\n        return new Packed64SingleBlock3(valueCount);\n      case 4:\n        return new Packed64SingleBlock4(valueCount);\n      case 5:\n        return new Packed64SingleBlock5(valueCount);\n      case 6:\n        return new Packed64SingleBlock6(valueCount);\n      case 7:\n        return new Packed64SingleBlock7(valueCount);\n      case 8:\n        return new Packed64SingleBlock8(valueCount);\n      case 9:\n        return new Packed64SingleBlock9(valueCount);\n      case 10:\n        return new Packed64SingleBlock10(valueCount);\n      case 12:\n        return new Packed64SingleBlock12(valueCount);\n      case 16:\n        return new Packed64SingleBlock16(valueCount);\n      case 21:\n        return new Packed64SingleBlock21(valueCount);\n      case 32:\n        return new Packed64SingleBlock32(valueCount);\n      default:\n        throw new IllegalArgumentException(\"Unsupported number of bits per value: \" + 32);\n    }\n  }\n  static class Packed64SingleBlock1 extends Packed64SingleBlock {\n    Packed64SingleBlock1(int valueCount) {\n      super(valueCount, 1);\n    }\n    @Override\n    public long get(int index) {\n      final int o = index >>> 6;\n      final int b = index & 63;\n      final int shift = b << 0;\n      return (blocks[o] >>> shift) & 1L;\n    }\n    @Override\n    public void set(int index, long value) {\n      final int o = index >>> 6;\n      final int b = index & 63;\n      final int shift = b << 0;\n      blocks[o] = (blocks[o] & ~(1L << shift)) | (value << shift);\n    }\n  }\n  static class Packed64SingleBlock2 extends Packed64SingleBlock {\n    Packed64SingleBlock2(int valueCount) {\n      super(valueCount, 2);\n    }\n    @Override\n    public long get(int index) {\n      final int o = index >>> 5;\n      final int b = index & 31;\n      final int shift = b << 1;\n      return (blocks[o] >>> shift) & 3L;\n    }\n    @Override\n    public void set(int index, long value) {\n      final int o = index >>> 5;\n      final int b = index & 31;\n      final int shift = b << 1;\n      blocks[o] = (blocks[o] & ~(3L << shift)) | (value << shift);\n    }\n  }\n  static class Packed64SingleBlock3 extends Packed64SingleBlock {\n    Packed64SingleBlock3(int valueCount) {\n      super(valueCount, 3);\n    }\n    @Override\n    public long get(int index) {\n      final int o = index / 21;\n      final int b = index % 21;\n      final int shift = b * 3;\n      return (blocks[o] >>> shift) & 7L;\n    }\n    @Override\n    public void set(int index, long value) {\n      final int o = index / 21;\n      final int b = index % 21;\n      final int shift = b * 3;\n      blocks[o] = (blocks[o] & ~(7L << shift)) | (value << shift);\n    }\n  }\n  static class Packed64SingleBlock4 extends Packed64SingleBlock {\n    Packed64SingleBlock4(int valueCount) {\n      super(valueCount, 4);\n    }\n    @Override\n    public long get(int index) {\n      final int o = index >>> 4;\n      final int b = index & 15;\n      final int shift = b << 2;\n      return (blocks[o] >>> shift) & 15L;\n    }\n    @Override\n    public void set(int index, long value) {\n      final int o = index >>> 4;\n      final int b = index & 15;\n      final int shift = b << 2;\n      blocks[o] = (blocks[o] & ~(15L << shift)) | (value << shift);\n    }\n  }\n  static class Packed64SingleBlock5 extends Packed64SingleBlock {\n    Packed64SingleBlock5(int valueCount) {\n      super(valueCount, 5);\n    }\n    @Override\n    public long get(int index) {\n      final int o = index / 12;\n      final int b = index % 12;\n      final int shift = b * 5;\n      return (blocks[o] >>> shift) & 31L;\n    }\n    @Override\n    public void set(int index, long value) {\n      final int o = index / 12;\n      final int b = index % 12;\n      final int shift = b * 5;\n      blocks[o] = (blocks[o] & ~(31L << shift)) | (value << shift);\n    }\n  }\n<fim_suffix>  static class Packed64SingleBlock6 extends Packed64SingleBlock {\n    Packed64SingleBlock6(int valueCount) {\n      super(valueCount, 6);\n    }\n    @Override\n    public long get(int index) {\n      final int o = index / 10;\n      final int b = index % 10;\n      final int shift = b * 6;\n      return (blocks[o] >>> shift) & 63L;\n    }\n    @Override\n    public void set(int index, long value) {\n      final int o = index / 10;\n      final int b = index % 10;\n      final int shift = b * 6;\n      blocks[o] = (blocks[o] & ~(63L << shift)) | (value << shift);\n    }\n  }<fim_middle>// class below has no smell\n"}