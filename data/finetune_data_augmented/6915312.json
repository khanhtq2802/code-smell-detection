{"text": "<fim_prefix>   * or if not available the sample with the smallest overall offset to avoid subsequent source\n   * reloads.\n   *\n   * <p>To deal with poor sample interleaving, we also check whether the required memory to catch up\n   * with the next logical sample (based on sample time) exceeds {@link\n   * #MAXIMUM_READ_AHEAD_BYTES_STREAM}. If this is the case, we continue with this sample even\n   * though it may require a source reload.\n   */\n  private int getTrackIndexOfNextReadSample(long inputPosition) {\n    long preferredSkipAmount = Long.MAX_VALUE;\n    boolean preferredRequiresReload = true;\n    int preferredTrackIndex = C.INDEX_UNSET;\n    long preferredAccumulatedBytes = Long.MAX_VALUE;\n    long minAccumulatedBytes = Long.MAX_VALUE;\n    boolean minAccumulatedBytesRequiresReload = true;\n    int minAccumulatedBytesTrackIndex = C.INDEX_UNSET;\n    for (int trackIndex = 0; trackIndex < tracks.length; trackIndex++) {\n      Mp4Track track = tracks[trackIndex];\n      int sampleIndex = track.sampleIndex;\n      if (sampleIndex == track.sampleTable.sampleCount) {\n        continue;\n      }\n      long sampleOffset = track.sampleTable.offsets[sampleIndex];\n      long sampleAccumulatedBytes = accumulatedSampleSizes[trackIndex][sampleIndex];\n      long skipAmount = sampleOffset - inputPosition;\n      boolean requiresReload = skipAmount < 0 || skipAmount >= RELOAD_MINIMUM_SEEK_DISTANCE;\n      if ((!requiresReload && preferredRequiresReload)\n          || (requiresReload == preferredRequiresReload && skipAmount < preferredSkipAmount)) {\n        preferredRequiresReload = requiresReload;\n        preferredSkipAmount = skipAmount;\n        preferredTrackIndex = trackIndex;\n        preferredAccumulatedBytes = sampleAccumulatedBytes;\n      }\n      if (sampleAccumulatedBytes < minAccumulatedBytes) {\n        minAccumulatedBytes = sampleAccumulatedBytes;\n        minAccumulatedBytesRequiresReload = requiresReload;\n        minAccumulatedBytesTrackIndex = trackIndex;\n      }\n    }\n    return minAccumulatedBytes == Long.MAX_VALUE\n            || !minAccumulatedBytesRequiresReload\n            || preferredAccumulatedBytes < minAccumulatedBytes + MAXIMUM_READ_AHEAD_BYTES_STREAM\n        ? preferredTrackIndex\n        : minAccumulatedBytesTrackIndex;\n  }\n  /**\n   * Updates every track's sample index to point its latest sync sample before/at {@code timeUs}.\n   */\n  private void updateSampleIndices(long timeUs) {\n    for (Mp4Track track : tracks) {\n      TrackSampleTable sampleTable = track.sampleTable;\n      int sampleIndex = sampleTable.getIndexOfEarlierOrEqualSynchronizationSample(timeUs);\n      if (sampleIndex == C.INDEX_UNSET) {\n        // Handle the case where the requested time is before the first synchronization sample.\n        sampleIndex = sampleTable.getIndexOfLaterOrEqualSynchronizationSample(timeUs);\n      }\n      track.sampleIndex = sampleIndex;\n    }\n  }\n  /**\n   * For each sample of each track, calculates accumulated size of all samples which need to be read\n   * before this sample can be used.\n   */\n  private static long[][] calculateAccumulatedSampleSizes(Mp4Track[] tracks) {\n    long[][] accumulatedSampleSizes = new long[tracks.length][];\n    int[] nextSampleIndex = new int[tracks.length];\n    long[] nextSampleTimesUs = new long[tracks.length];\n    boolean[] tracksFinished = new boolean[tracks.length];\n    for (int i = 0; i < tracks.length; i++) {\n      accumulatedSampleSizes[i] = new long[tracks[i].sampleTable.sampleCount];\n      nextSampleTimesUs[i] = tracks[i].sampleTable.timestampsUs[0];\n    }\n    long accumulatedSampleSize = 0;\n    int finishedTracks = 0;\n    while (finishedTracks < tracks.length) {\n      long minTimeUs = Long.MAX_VALUE;\n      int minTimeTrackIndex = -1;\n      for (int i = 0; i < tracks.length; i++) {\n        if (!tracksFinished[i] && nextSampleTimesUs[i] <= minTimeUs) {\n          minTimeTrackIndex = i;\n          minTimeUs = nextSampleTimesUs[i];\n        }\n      }\n      int trackSampleIndex = nextSampleIndex[minTimeTrackIndex];\n      accumulatedSampleSizes[minTimeTrackIndex][trackSampleIndex] = accumulatedSampleSize;\n      accumulatedSampleSize += tracks[minTimeTrackIndex].sampleTable.sizes[trackSampleIndex];\n      nextSampleIndex[minTimeTrackIndex] = ++trackSampleIndex;\n      if (trackSampleIndex < accumulatedSampleSizes[minTimeTrackIndex].length) {\n        nextSampleTimesUs[minTimeTrackIndex] =\n            tracks[minTimeTrackIndex].sampleTable.timestampsUs[trackSampleIndex];\n      } else {\n        tracksFinished[minTimeTrackIndex] = true;\n        finishedTracks++;\n      }\n    }\n    return accumulatedSampleSizes;\n  }\n  /**\n   * Adjusts a seek point offset to take into account the track with the given {@code sampleTable},\n   * for a given {@code seekTimeUs}.\n   *\n   * @param sampleTable The sample table to use.\n   * @param seekTimeUs The seek time in microseconds.\n   * @param offset The current offset.\n   * @return The adjusted offset.\n   */\n  private static long maybeAdjustSeekOffset(\n      TrackSampleTable sampleTable, long seekTimeUs, long offset) {\n    int sampleIndex = getSynchronizationSampleIndex(sampleTable, seekTimeUs);\n    if (sampleIndex == C.INDEX_UNSET) {\n      return offset;\n    }\n    long sampleOffset = sampleTable.offsets[sampleIndex];\n    return Math.min(sampleOffset, offset);\n  }\n  /**\n   * Returns the index of the synchronization sample before or at {@code timeUs}, or the index of\n   * the first synchronization sample if located after {@code timeUs}, or {@link C#INDEX_UNSET} if\n   * there are no synchronization samples in the table.\n   *\n   * @param sampleTable The sample table in which to locate a synchronization sample.\n   * @param timeUs A time in microseconds.\n   * @return The index of the synchronization sample before or at {@code timeUs}, or the index of\n   *     the first synchronization sample if located after {@code timeUs}, or {@link C#INDEX_UNSET}\n   *     if there are no synchronization samples in the table.\n   */\n  private static int getSynchronizationSampleIndex(TrackSampleTable sampleTable, long timeUs) {\n    int sampleIndex = sampleTable.getIndexOfEarlierOrEqualSynchronizationSample(timeUs);\n    if (sampleIndex == C.INDEX_UNSET) {\n      // Handle the case where the requested time is before the first synchronization sample.\n      sampleIndex = sampleTable.getIndexOfLaterOrEqualSynchronizationSample(timeUs);\n    }\n    return sampleIndex;\n  }\n  /**\n   * Process an ftyp atom to determine whether the media is QuickTime.\n   *\n   * @param atomData The ftyp atom data.\n   * @return Whether the media is QuickTime.\n   */\n  private static boolean processFtypAtom(ParsableByteArray atomData) {\n    atomData.setPosition(Atom.HEADER_SIZE);\n    int majorBrand = atomData.readInt();\n    if (majorBrand == BRAND_QUICKTIME) {\n      return true;\n    }\n    atomData.skipBytes(4); // minor_version\n    while (atomData.bytesLeft() > 0) {\n      if (atomData.readInt() == BRAND_QUICKTIME) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /** Returns whether the extractor should decode a leaf atom with type {@code atom}. */\n  private static boolean shouldParseLeafAtom(int atom) {\n    return atom == Atom.TYPE_mdhd\n        || atom == Atom.TYPE_mvhd\n        || atom == Atom.TYPE_hdlr\n        || atom == Atom.TYPE_stsd\n        || atom == Atom.TYPE_stts\n        || atom == Atom.TYPE_stss\n        || atom == Atom.TYPE_ctts\n        || atom == Atom.TYPE_elst\n        || atom == Atom.TYPE_stsc\n        || atom == Atom.TYPE_stsz\n        || atom == Atom.TYPE_stz2\n        || atom == Atom.TYPE_stco\n        || atom == Atom.TYPE_co64\n        || atom == Atom.TYPE_tkhd\n        || atom == Atom.TYPE_ftyp\n        || atom == Atom.TYPE_udta\n        || atom == Atom.TYPE_keys\n        || atom == Atom.TYPE_ilst;\n  }\n  /** Returns whether the extractor should decode a container atom with type {@code atom}. */\n<fim_suffix>  private static boolean shouldParseContainerAtom(int atom) {\n    return atom == Atom.TYPE_moov\n        || atom == Atom.TYPE_trak\n        || atom == Atom.TYPE_mdia\n        || atom == Atom.TYPE_minf\n        || atom == Atom.TYPE_stbl\n        || atom == Atom.TYPE_edts\n        || atom == Atom.TYPE_meta;\n  }<fim_middle>// function below has no smell\n"}