{"text": "<fim_prefix>/**\n * Copyright (c) 2014,2019 Contributors to the Eclipse Foundation\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.eclipse.smarthome.binding.lifx.internal;\nimport static org.eclipse.smarthome.binding.lifx.LifxBindingConstants.PACKET_INTERVAL;\nimport static org.eclipse.smarthome.binding.lifx.internal.protocol.Product.Feature.MULTIZONE;\nimport static org.eclipse.smarthome.binding.lifx.internal.util.LifxMessageUtil.*;\nimport java.time.Duration;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.ReentrantLock;\nimport org.eclipse.jdt.annotation.NonNullByDefault;\nimport org.eclipse.jdt.annotation.Nullable;\nimport org.eclipse.smarthome.binding.lifx.internal.fields.HSBK;\nimport org.eclipse.smarthome.binding.lifx.internal.listener.LifxLightStateListener;\nimport org.eclipse.smarthome.binding.lifx.internal.protocol.AcknowledgementResponse;\nimport org.eclipse.smarthome.binding.lifx.internal.protocol.ApplicationRequest;\nimport org.eclipse.smarthome.binding.lifx.internal.protocol.GetColorZonesRequest;\nimport org.eclipse.smarthome.binding.lifx.internal.protocol.GetLightInfraredRequest;\nimport org.eclipse.smarthome.binding.lifx.internal.protocol.GetLightPowerRequest;\nimport org.eclipse.smarthome.binding.lifx.internal.protocol.GetRequest;\nimport org.eclipse.smarthome.binding.lifx.internal.protocol.Packet;\nimport org.eclipse.smarthome.binding.lifx.internal.protocol.PowerState;\nimport org.eclipse.smarthome.binding.lifx.internal.protocol.Product;\nimport org.eclipse.smarthome.binding.lifx.internal.protocol.SetColorRequest;\nimport org.eclipse.smarthome.binding.lifx.internal.protocol.SetColorZonesRequest;\nimport org.eclipse.smarthome.binding.lifx.internal.protocol.SetLightInfraredRequest;\nimport org.eclipse.smarthome.binding.lifx.internal.protocol.SetLightPowerRequest;\nimport org.eclipse.smarthome.binding.lifx.internal.protocol.SetPowerRequest;\nimport org.eclipse.smarthome.binding.lifx.internal.protocol.SignalStrength;\nimport org.eclipse.smarthome.core.library.types.PercentType;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n/**\n * The {@link LifxLightStateChanger} listens to state changes of the {@code pendingLightState}. It sends packets to a\n * light so the change the actual light state to that of the {@code pendingLightState}. When the light does not\n * acknowledge a packet, it resends it (max 3 times).\n *\n * @author Wouter Born - Extracted class from LifxLightHandler, added logic for handling packet loss\n */\n@NonNullByDefault\npublic class LifxLightStateChanger implements LifxLightStateListener {\n    /**\n     * Milliseconds before a packet is considered to be lost (unacknowledged).\n     */\n    private static final int PACKET_ACKNOWLEDGE_INTERVAL = 250;\n    /**\n     * The number of times a lost packet will be resent.\n     */\n    private static final int MAX_RETRIES = 3;\n    private final Logger logger = LoggerFactory.getLogger(LifxLightStateChanger.class);\n    private final String logId;\n    private final Product product;\n    private final Duration fadeTime;\n    private final LifxLightState pendingLightState;\n    private final ScheduledExecutorService scheduler;\n    private final LifxLightCommunicationHandler communicationHandler;\n    private final ReentrantLock lock = new ReentrantLock();\n    private @Nullable ScheduledFuture<?> sendJob;\n    private Map<Integer, @Nullable List<PendingPacket>> pendingPacketsMap = new ConcurrentHashMap<>();\n    private class PendingPacket {\n        long lastSend;\n        int sendCount;\n        final Packet packet;\n        private PendingPacket(Packet packet) {\n            this.packet = packet;\n        }\n        private boolean hasAcknowledgeIntervalElapsed() {\n            long millisSinceLastSend = System.currentTimeMillis() - lastSend;\n            return millisSinceLastSend > PACKET_ACKNOWLEDGE_INTERVAL;\n        }\n    }\n<fim_suffix>    public LifxLightStateChanger(LifxLightContext context, LifxLightCommunicationHandler communicationHandler) {\n        this.logId = context.getLogId();\n        this.product = context.getProduct();\n        this.fadeTime = context.getConfiguration().getFadeTime();\n        this.pendingLightState = context.getPendingLightState();\n        this.scheduler = context.getScheduler();\n        this.communicationHandler = communicationHandler;\n    }\n    private void sendPendingPackets() {\n        try {\n            lock.lock();\n            removeFailedPackets();\n            PendingPacket pendingPacket = findPacketToSend();\n            if (pendingPacket != null) {\n                Packet packet = pendingPacket.packet;\n                if (pendingPacket.sendCount == 0) {\n                    // sendPacket will set the sequence number\n                    logger.debug(\"{} : Sending {} packet\", logId, packet.getClass().getSimpleName());\n                    communicationHandler.sendPacket(packet);\n                } else {\n                    // resendPacket will reuse the sequence number\n                    logger.debug(\"{} : Resending {} packet\", logId, packet.getClass().getSimpleName());\n                    communicationHandler.resendPacket(packet);\n                }\n                pendingPacket.lastSend = System.currentTimeMillis();\n                pendingPacket.sendCount++;\n            }\n        } catch (Exception e) {\n            logger.error(\"Error occurred while sending packet\", e);\n        } finally {\n            lock.unlock();\n        }\n    };\n    public void start() {\n        try {\n            lock.lock();\n            communicationHandler.addResponsePacketListener(this::handleResponsePacket);\n            pendingLightState.addListener(this);\n            ScheduledFuture<?> localSendJob = sendJob;\n            if (localSendJob == null || localSendJob.isCancelled()) {\n                sendJob = scheduler.scheduleWithFixedDelay(this::sendPendingPackets, 0, PACKET_INTERVAL,\n                        TimeUnit.MILLISECONDS);\n            }\n        } catch (Exception e) {\n            logger.error(\"Error occurred while starting send packets job\", e);\n        } finally {\n            lock.unlock();\n        }\n    }\n    public void stop() {\n        try {\n            lock.lock();\n            communicationHandler.removeResponsePacketListener(this::handleResponsePacket);\n            pendingLightState.removeListener(this);\n            ScheduledFuture<?> localSendJob = sendJob;\n            if (localSendJob != null && !localSendJob.isCancelled()) {\n                localSendJob.cancel(true);\n                sendJob = null;\n            }\n            pendingPacketsMap.clear();\n        } catch (Exception e) {\n            logger.error(\"Error occurred while stopping send packets job\", e);\n        } finally {\n            lock.unlock();\n        }\n    }\n    private List<PendingPacket> createPendingPackets(Packet... packets) {\n        Integer packetType = null;\n        List<PendingPacket> pendingPackets = new ArrayList<>();\n        for (Packet packet : packets) {\n            // the acknowledgement is used to resend the packet in case of packet loss\n            packet.setAckRequired(true);\n            // the LIFX LAN protocol spec indicates that the response returned for a request would be the\n            // previous value\n            packet.setResponseRequired(false);\n            pendingPackets.add(new PendingPacket(packet));\n            if (packetType == null) {\n                packetType = packet.getPacketType();\n            } else if (packetType != packet.getPacketType()) {\n                throw new IllegalArgumentException(\"Packets should have same packet type\");\n            }\n        }\n        return pendingPackets;\n    }\n    private void addPacketsToMap(Packet... packets) {\n        List<PendingPacket> newPendingPackets = createPendingPackets(packets);\n        int packetType = packets[0].getPacketType();\n        try {\n            lock.lock();\n            List<PendingPacket> pendingPackets = pendingPacketsMap.get(packetType);\n            if (pendingPackets == null) {\n                pendingPacketsMap.put(packetType, newPendingPackets);\n            } else {\n                pendingPackets.addAll(newPendingPackets);\n            }\n        } finally {\n            lock.unlock();\n        }\n    }\n    private void replacePacketsInMap(Packet... packets) {<fim_middle>// function below has no smell\n"}