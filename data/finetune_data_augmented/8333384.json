{"text": "<fim_prefix>\t * streams (in child threads) through to the corresponding streams (e.g., the process System.err to this System.err). This can\n\t * complete normally, by exception, or on demand by a client. Clients can implement <code>doCompleting(..)</code> to get notice\n\t * when the process completes.\n\t * <p>\n\t * The following sample code creates a process with a completion callback starts it, and some time later retries the process.\n\t * \n\t * <pre>\n\t * LangUtil.ProcessController controller = new LangUtil.ProcessController() {\n\t * \tprotected void doCompleting(LangUtil.ProcessController.Thrown thrown, int result) {\n\t * \t\t// signal result \n\t * \t}\n\t * };\n\t * controller.init(new String[] { &quot;java&quot;, &quot;-version&quot; }, &quot;java version&quot;);\n\t * controller.start();\n\t * // some time later...\n\t * // retry...\n\t * if (!controller.completed()) {\n\t * \tcontroller.stop();\n\t * \tcontroller.reinit();\n\t * \tcontroller.start();\n\t * }\n\t * </pre>\n\t * \n\t * <u>warning</u>: Currently this does not close the input or output streams, since doing so prevents their use later.\n\t */\n\tpublic static class ProcessController {\n\t\t/*\n\t\t * XXX not verified thread-safe, but should be. Known problems: - user stops (completed = true) then exception thrown from\n\t\t * destroying process (stop() expects !completed) ...\n\t\t */\n\t\tprivate String[] command;\n\t\tprivate String[] envp;\n\t\tprivate String label;\n\t\tprivate boolean init;\n\t\tprivate boolean started;\n\t\tprivate boolean completed;\n\t\t/** if true, stopped by user when not completed */\n\t\tprivate boolean userStopped;\n\t\tprivate Process process;\n\t\tprivate FileUtil.Pipe errStream;\n\t\tprivate FileUtil.Pipe outStream;\n\t\tprivate FileUtil.Pipe inStream;\n\t\tprivate ByteArrayOutputStream errSnoop;\n\t\tprivate ByteArrayOutputStream outSnoop;\n\t\tprivate int result;\n\t\tprivate Thrown thrown;\n\t\tpublic ProcessController() {\n\t\t}\n\t\t/**\n\t\t * Permit re-running using the same command if this is not started or if completed. Can also call this when done with\n\t\t * results to release references associated with results (e.g., stack traces).\n\t\t */\n\t\tpublic final void reinit() {\n\t\t\tif (!init) {\n\t\t\t\tthrow new IllegalStateException(\"must init(..) before reinit()\");\n\t\t\t}\n\t\t\tif (started && !completed) {\n\t\t\t\tthrow new IllegalStateException(\"not completed - do stop()\");\n\t\t\t}\n\t\t\t// init everything but command and label\n\t\t\tstarted = false;\n\t\t\tcompleted = false;\n\t\t\tresult = Integer.MIN_VALUE;\n\t\t\tthrown = null;\n\t\t\tprocess = null;\n\t\t\terrStream = null;\n\t\t\toutStream = null;\n\t\t\tinStream = null;\n\t\t}\n\t\tpublic final void init(String classpath, String mainClass, String[] args) {\n\t\t\tinit(LangUtil.getJavaExecutable(), classpath, mainClass, args);\n\t\t}\n\t\tpublic final void init(File java, String classpath, String mainClass, String[] args) {\n\t\t\tLangUtil.throwIaxIfNull(java, \"java\");\n\t\t\tLangUtil.throwIaxIfNull(mainClass, \"mainClass\");\n\t\t\tLangUtil.throwIaxIfNull(args, \"args\");\n\t\t\tArrayList<String> cmd = new ArrayList<String>();\n\t\t\tcmd.add(java.getAbsolutePath());\n\t\t\tcmd.add(\"-classpath\");\n\t\t\tcmd.add(classpath);\n\t\t\tcmd.add(mainClass);\n\t\t\tif (!LangUtil.isEmpty(args)) {\n\t\t\t\tcmd.addAll(Arrays.asList(args));\n\t\t\t}\n\t\t\tinit(cmd.toArray(new String[0]), mainClass);\n\t\t}\n\t\tpublic final void init(String[] command, String label) {\n\t\t\tthis.command = (String[]) LangUtil.safeCopy(command, new String[0]);\n\t\t\tif (1 > this.command.length) {\n\t\t\t\tthrow new IllegalArgumentException(\"empty command\");\n\t\t\t}\n\t\t\tthis.label = LangUtil.isEmpty(label) ? command[0] : label;\n\t\t\tinit = true;\n\t\t\treinit();\n\t\t}\n\t\tpublic final void setEnvp(String[] envp) {\n\t\t\tthis.envp = (String[]) LangUtil.safeCopy(envp, new String[0]);\n\t\t\tif (1 > this.envp.length) {\n\t\t\t\tthrow new IllegalArgumentException(\"empty envp\");\n\t\t\t}\n\t\t}\n\t\tpublic final void setErrSnoop(ByteArrayOutputStream snoop) {\n\t\t\terrSnoop = snoop;\n\t\t\tif (null != errStream) {\n\t\t\t\terrStream.setSnoop(errSnoop);\n\t\t\t}\n\t\t}\n\t\tpublic final void setOutSnoop(ByteArrayOutputStream snoop) {\n\t\t\toutSnoop = snoop;\n\t\t\tif (null != outStream) {\n\t\t\t\toutStream.setSnoop(outSnoop);\n\t\t\t}\n\t\t}\n\t\t/**\n\t\t * Start running the process and pipes asynchronously.\n\t\t * \n\t\t * @return Thread started or null if unable to start thread (results available via <code>getThrown()</code>, etc.)\n\t\t */\n<fim_suffix>\t\tpublic final Thread start() {\n\t\t\tif (!init) {\n\t\t\t\tthrow new IllegalStateException(\"not initialized\");\n\t\t\t}\n\t\t\tsynchronized (this) {\n\t\t\t\tif (started) {\n\t\t\t\t\tthrow new IllegalStateException(\"already started\");\n\t\t\t\t}\n\t\t\t\tstarted = true;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tprocess = Runtime.getRuntime().exec(command);\n\t\t\t} catch (IOException e) {\n\t\t\t\tstop(e, Integer.MIN_VALUE);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\terrStream = new FileUtil.Pipe(process.getErrorStream(), System.err);\n\t\t\tif (null != errSnoop) {\n\t\t\t\terrStream.setSnoop(errSnoop);\n\t\t\t}\n\t\t\toutStream = new FileUtil.Pipe(process.getInputStream(), System.out);\n\t\t\tif (null != outSnoop) {\n\t\t\t\toutStream.setSnoop(outSnoop);\n\t\t\t}\n\t\t\tinStream = new FileUtil.Pipe(System.in, process.getOutputStream());\n\t\t\t// start 4 threads, process & pipes for in, err, out\n\t\t\tRunnable processRunner = new Runnable() {\n\t\t\t\t@Override\n\t\t\t\tpublic void run() {\n\t\t\t\t\tThrowable thrown = null;\n\t\t\t\t\tint result = Integer.MIN_VALUE;\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// pipe threads are children\n\t\t\t\t\t\tnew Thread(errStream).start();\n\t\t\t\t\t\tnew Thread(outStream).start();\n\t\t\t\t\t\tnew Thread(inStream).start();\n\t\t\t\t\t\tprocess.waitFor();\n\t\t\t\t\t\tresult = process.exitValue();\n\t\t\t\t\t} catch (Throwable e) {\n\t\t\t\t\t\tthrown = e;\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tstop(thrown, result);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tThread result = new Thread(processRunner, label);\n\t\t\tresult.start();\n\t\t\treturn result;\n\t\t}<fim_middle>// function below has no smell\n"}