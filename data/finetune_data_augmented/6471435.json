{"text": "<fim_prefix> * only the GPL Version 2, indicate your decision by adding \"[Contributor]\n * elects to include this software in this distribution under the [CDDL or GPL\n * Version 2] license.\"  If you don't indicate a single choice of license, a\n * recipient has the option to distribute your version of this file under\n * either the CDDL, the GPL Version 2 or to extend the choice of license to\n * its licensees as provided above.  However, if you add GPL Version 2 code\n * and therefore, elected the GPL Version 2 license, then the option applies\n * only if the new code is made subject to such option by the copyright\n * holder.\n *\n *\n * This file incorporates work covered by the following copyright and\n * permission notice:\n *\n * Copyright 2004 The Apache Software Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.jasper.compiler;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.apache.jasper.JasperException;\nimport org.apache.jasper.JspCompilationContext;\n/**\n * Contains static utilities for generating SMAP data based on the\n * current version of Jasper.\n * \n * @author Jayson Falkner\n * @author Shawn Bayern\n * @author Robert Field (inner SDEInstaller class)\n * @author Mark Roth\n * @author Kin-man Chung\n */\npublic class SmapUtil {\n    private JspCompilationContext ctxt;\n    private List<ClassInfo> classInfos;\n    //*********************************************************************\n    // Constants\n    public static final String SMAP_ENCODING = \"UTF-8\";\n    //*********************************************************************\n    // Public entry points\n    SmapUtil(JspCompilationContext ctxt) {\n        this.ctxt = ctxt;\n    }\n    /**\n     * Generates an appropriate SMAP representing the current compilation\n     * context.  (JSR-045.)\n     *\n     * @param ctxt Current compilation context\n     * @param pageNodes The current JSP page\n     * @return a SMAP for the page\n     */\n    public void generateSmap(Node.Nodes pageNodes)\n        throws IOException {\n        classInfos = new ArrayList<ClassInfo>();\n        String className = ctxt.getFullClassName();\n        // Instantiate a SmapStratum for the main JSP page.\n        SmapStratum s = new SmapStratum(\"JSP\");\n        classInfos.add(new ClassInfo(className, s));\n        // Map out Node.Nodes and putting LineInfo into SmapStratum\n        evaluateNodes(pageNodes, s, ctxt.getOptions().getMappedFile());\n        String classFileName = ctxt.getClassFileName();\n        for (ClassInfo entry: classInfos) {\n            // Get SmapStratum\n            s = entry.getSmapStratum();\n            s.optimizeLineSection();\n            // Set up our SMAP generator\n            SmapGenerator g = new SmapGenerator();\n            g.setOutputFileName(unqualify(ctxt.getServletJavaFileName()));\n            g.addStratum(s, true);\n            String name = entry.getClassName();  // class name\n            // Compute the class name and output file name for inner classes\n            if (!className.equals(name)) {\n                classFileName = ctxt.getOutputDir() + \n                    name.substring(name.lastIndexOf('.')+1) + \".class\";\n            }\n            entry.setClassFileName(classFileName);\n            entry.setSmap(g.getString());\n            if (ctxt.getOptions().isSmapDumped()) {\n                File outSmap = new File(classFileName + \".smap\");\n                PrintWriter so =\n                    new PrintWriter(\n                        new OutputStreamWriter(\n                            new FileOutputStream(outSmap),\n                            SMAP_ENCODING));\n                so.print(g.getString());\n                so.close();\n            }\n        }\n    }\n    public void installSmap() throws IOException {\n        for (ClassInfo ci: classInfos) {\n            String className = ci.getClassName();\n            byte[] classfile = ctxt.getRuntimeContext().getBytecode(className);\n            if (classfile == null) {\n                SDEInstaller.install(new File(ci.getClassFileName()),\n                             ci.getSmap().getBytes(Charset.defaultCharset()));\n            }\n            else {\n                classfile = SDEInstaller.install(classfile,\n                             ci.getSmap().getBytes(Charset.defaultCharset()));\n                ctxt.getRuntimeContext().setBytecode(className, classfile);\n            }\n        }\n    }\n    //*********************************************************************\n    // Private utilities\n    /**\n     * Returns an unqualified version of the given file path.\n     */\n    private static String unqualify(String path) {\n        path = path.replace('\\\\', '/');\n        return path.substring(path.lastIndexOf('/') + 1);\n    }\n    //*********************************************************************\n    // Installation logic (from Robert Field, JSR-045 spec lead)\n    private static class SDEInstaller {\n        static final String nameSDE = \"SourceDebugExtension\";\n        byte[] orig;\n        byte[] sdeAttr;\n        byte[] gen;\n        int origPos = 0;\n        int genPos = 0;\n        int sdeIndex;\n        public static void main(String[] args) throws IOException {\n            if (args.length == 2) {\n                install(new File(args[0]), new File(args[1]));\n            } else if (args.length == 3) {\n                install(\n                    new File(args[0]),\n                    new File(args[1]),\n                    new File(args[2]));\n            } else {\n                System.err.println(\n                    \"Usage: <command> <input class file> \"\n                        + \"<attribute file> <output class file name>\\n\"\n                        + \"<command> <input/output class file> <attribute file>\");\n            }\n        }\n        static void install(File inClassFile, File attrFile, File outClassFile)\n            throws IOException {\n            new SDEInstaller(inClassFile, attrFile, outClassFile);\n        }\n        static void install(File inOutClassFile, File attrFile)\n            throws IOException {\n            File tmpFile = new File(inOutClassFile.getPath() + \"tmp\");\n            new SDEInstaller(inOutClassFile, attrFile, tmpFile);\n            if (!inOutClassFile.delete()) {\n                throw new IOException(\"inOutClassFile.delete() failed\");\n            }\n            if (!tmpFile.renameTo(inOutClassFile)) {\n                throw new IOException(\"tmpFile.renameTo(inOutClassFile) failed\");\n            }\n        }\n        static void install(File classFile, byte[] smap) throws IOException {\n            File tmpFile = new File(classFile.getPath() + \"tmp\");\n            new SDEInstaller(classFile, smap, tmpFile);\n            if (!classFile.delete()) {\n                throw new IOException(\"classFile.delete() failed\");\n            }\n            if (!tmpFile.renameTo(classFile)) {\n                throw new IOException(\"tmpFile.renameTo(classFile) failed\");\n            }\n        }\n        static byte[] install(byte[] classfile, byte[] smap)\n                throws IOException {\n            SDEInstaller installer = new SDEInstaller(classfile, smap);\n            byte[] tmp = new byte[installer.genPos];\n            System.arraycopy(installer.gen, 0, tmp, 0, installer.genPos);\n            return tmp;\n        }\n        SDEInstaller(byte[] classfile, byte[] sdeAttr) \n\t\tthrows IOException {\n            orig = classfile;\n            this.sdeAttr = sdeAttr;\n            gen = new byte[orig.length + sdeAttr.length + 100];\n            addSDE();\n        }\n<fim_suffix>        SDEInstaller(File inClassFile, byte[] sdeAttr, File outClassFile)\n            throws IOException {\n            if (!inClassFile.exists()) {\n                throw new FileNotFoundException(\"no such file: \" + inClassFile);\n            }\n            this.sdeAttr = sdeAttr;\n            // get the bytes\n            orig = readWhole(inClassFile);\n            gen = new byte[orig.length + sdeAttr.length + 100];\n            // do it\n            addSDE();\n            // write result\n            FileOutputStream outStream = new FileOutputStream(outClassFile);\n            outStream.write(gen, 0, genPos);\n            outStream.close();\n        }<fim_middle>// function below has no smell\n"}