{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ignite.examples.computegrid;\n\nimport java.math.BigInteger;\nimport java.util.UUID;\nimport java.util.concurrent.ConcurrentMap;\nimport org.apache.ignite.Ignite;\nimport org.apache.ignite.IgniteCompute;\nimport org.apache.ignite.IgniteException;\nimport org.apache.ignite.Ignition;\nimport org.apache.ignite.cluster.ClusterGroup;\nimport org.apache.ignite.cluster.ClusterNode;\nimport org.apache.ignite.compute.ComputeJobContext;\nimport org.apache.ignite.examples.ExampleNodeStartup;\nimport org.apache.ignite.lang.IgniteClosure;\nimport org.apache.ignite.lang.IgniteFuture;\nimport org.apache.ignite.lang.IgniteInClosure;\nimport org.apache.ignite.lang.IgnitePredicate;\nimport org.apache.ignite.resources.IgniteInstanceResource;\nimport org.apache.ignite.resources.JobContextResource;\nimport org.jetbrains.annotations.Nullable;\n\n/**\n * This example demonstrates how to use continuation feature of Ignite by\n * performing the distributed recursive calculation of {@code 'Fibonacci'}\n * numbers on the cluster. Continuations\n * functionality is exposed via {@link ComputeJobContext#holdcc()} and\n * {@link ComputeJobContext#callcc()} method calls in\n * {@link org.apache.ignite.examples.computegrid.ComputeFibonacciContinuationExample.ContinuationFibonacciClosure}\n * class.\n * <p>\n * Remote nodes should always be started with special configuration file which\n * enables P2P class loading: {@code 'ignite.{sh|bat} examples/config/example-ignite.xml'}.\n * <p>\n * Alternatively you can run {@link ExampleNodeStartup} in another JVM which will start node\n * with {@code examples/config/example-ignite.xml} configuration.\n */\n<fim_suffix>public final class ComputeFibonacciContinuationExample {\n    /**\n     * Executes example.\n     *\n     * @param args Command line arguments, none required.\n     * @throws IgniteException If example execution failed.\n     */\n    public static void main(String[] args) throws IgniteException {\n        try (Ignite ignite = Ignition.start(\"examples/config/example-ignite.xml\")) {\n            System.out.println();\n            System.out.println(\"Compute Fibonacci continuation example started.\");\n\n            long N = 100;\n\n            final UUID exampleNodeId = ignite.cluster().localNode().id();\n\n            // Filter to exclude this node from execution.\n            final IgnitePredicate<ClusterNode> nodeFilter = new IgnitePredicate<ClusterNode>() {\n                @Override public boolean apply(ClusterNode n) {\n                    // Give preference to remote nodes.\n                    return ignite.cluster().forRemotes().nodes().isEmpty() || !n.id().equals(exampleNodeId);\n                }\n            };\n\n            long start = System.currentTimeMillis();\n\n            BigInteger fib = ignite.compute(ignite.cluster().forPredicate(nodeFilter)).apply(\n                new ContinuationFibonacciClosure(nodeFilter), N);\n\n            long duration = System.currentTimeMillis() - start;\n\n            System.out.println();\n            System.out.println(\">>> Finished executing Fibonacci for '\" + N + \"' in \" + duration + \" ms.\");\n            System.out.println(\">>> Fibonacci sequence for input number '\" + N + \"' is '\" + fib + \"'.\");\n            System.out.println(\">>> If you re-run this example w/o stopping remote nodes - the performance will\");\n            System.out.println(\">>> increase since intermediate results are pre-cache on remote nodes.\");\n            System.out.println(\">>> You should see prints out every recursive Fibonacci execution on cluster nodes.\");\n            System.out.println(\">>> Check remote nodes for output.\");\n        }\n    }\n\n    /**\n     * Closure to execute.\n     */\n    private static class ContinuationFibonacciClosure implements IgniteClosure<Long, BigInteger> {\n        /** Future for spawned task. */\n        private IgniteFuture<BigInteger> fut1;\n\n        /** Future for spawned task. */\n        private IgniteFuture<BigInteger> fut2;\n\n        /** Auto-inject job context. */\n        @JobContextResource\n        private ComputeJobContext jobCtx;\n\n        /** Auto-inject ignite instance. */\n        @IgniteInstanceResource\n        private Ignite ignite;\n\n        /** Predicate. */\n        private final IgnitePredicate<ClusterNode> nodeFilter;\n\n        /**\n         * @param nodeFilter Predicate to filter nodes.\n         */\n        ContinuationFibonacciClosure(IgnitePredicate<ClusterNode> nodeFilter) {\n            this.nodeFilter = nodeFilter;\n        }\n\n        /** {@inheritDoc} */\n        @Nullable @Override public BigInteger apply(Long n) {\n            if (fut1 == null || fut2 == null) {\n                System.out.println();\n                System.out.println(\">>> Starting fibonacci execution for number: \" + n);\n\n                // Make sure n is not negative.\n                n = Math.abs(n);\n\n                if (n <= 2)\n                    return n == 0 ? BigInteger.ZERO : BigInteger.ONE;\n\n                // Node-local storage.\n                ConcurrentMap<Long, IgniteFuture<BigInteger>> locMap = ignite.cluster().nodeLocalMap();\n\n                // Check if value is cached in node-local-map first.\n                fut1 = locMap.get(n - 1);\n                fut2 = locMap.get(n - 2);\n\n                ClusterGroup p = ignite.cluster().forPredicate(nodeFilter);\n\n                IgniteCompute compute = ignite.compute(p);\n\n                // If future is not cached in node-local-map, cache it.\n                if (fut1 == null) {\n                    IgniteFuture<BigInteger> futVal = compute.applyAsync(\n                        new ContinuationFibonacciClosure(nodeFilter), n - 1);\n\n                    fut1 = locMap.putIfAbsent(n - 1, futVal);\n\n                    if (fut1 == null)\n                        fut1 = futVal;\n                }\n\n                // If future is not cached in node-local-map, cache it.\n                if (fut2 == null) {\n                    IgniteFuture<BigInteger> futVal = compute.applyAsync(\n                        new ContinuationFibonacciClosure(nodeFilter), n - 2);\n\n                    fut2 = locMap.putIfAbsent(n - 2, futVal);\n\n                    if (fut2 == null)\n                        fut2 = futVal;\n                }\n\n                // If futures are not done, then wait asynchronously for the result\n                if (!fut1.isDone() || !fut2.isDone()) {\n                    IgniteInClosure<IgniteFuture<BigInteger>> lsnr = new IgniteInClosure<IgniteFuture<BigInteger>>() {\n                        @Override public void apply(IgniteFuture<BigInteger> f) {\n                            // If both futures are done, resume the continuation.\n                            if (fut1.isDone() && fut2.isDone())\n                                // CONTINUATION:\n                                // =============\n                                // Resume suspended job execution.\n                                jobCtx.callcc();\n                        }\n                    };\n\n                    // CONTINUATION:\n                    // =============\n                    // Hold (suspend) job execution.\n                    // It will be resumed in listener above via 'callcc()' call\n                    // once both futures are done.\n                    jobCtx.holdcc();\n\n                    // Attach the same listener to both futures.\n                    fut1.listen(lsnr);\n                    fut2.listen(lsnr);\n\n                    return null;\n                }\n            }\n\n            assert fut1.isDone() && fut2.isDone();\n\n            // Return cached results.\n            return fut1.get().add(fut2.get());\n        }\n    }\n}<fim_middle>// class below has no smell\n"}