{"text": "<fim_prefix>            org.apache.nifi.registry.security.authorization.file.tenants.generated.Group.User jaxbGroupUser =\n                    new org.apache.nifi.registry.security.authorization.file.tenants.generated.Group.User();\n            jaxbGroupUser.setIdentifier(groupUser);\n            jaxbGroup.getUser().add(jaxbGroupUser);\n        }\n        tenants.getGroups().getGroup().add(jaxbGroup);\n        saveAndRefreshHolder(tenants);\n        return userGroupHolder.get().getGroupsById().get(group.getIdentifier());\n    }\n    @Override\n    public Group getGroup(String identifier) throws AuthorizationAccessException {\n        if (identifier == null) {\n            return null;\n        }\n        return userGroupHolder.get().getGroupsById().get(identifier);\n    }\n    @Override\n    public UserAndGroups getUserAndGroups(final String identity) throws AuthorizationAccessException {\n        final UserGroupHolder holder = userGroupHolder.get();\n        final User user = holder.getUser(identity);\n        final Set<Group> groups = holder.getGroups(identity);\n        return new UserAndGroups() {\n            @Override\n            public User getUser() {\n                return user;\n            }\n            @Override\n            public Set<Group> getGroups() {\n                return groups;\n            }\n        };\n    }\n    @Override\n    public synchronized Group updateGroup(Group group) throws AuthorizationAccessException {\n        if (group == null) {\n            throw new IllegalArgumentException(\"Group cannot be null\");\n        }\n        final UserGroupHolder holder = userGroupHolder.get();\n        final Tenants tenants = holder.getTenants();\n        // find the group that needs to be update\n        org.apache.nifi.registry.security.authorization.file.tenants.generated.Group updateGroup = null;\n        for (org.apache.nifi.registry.security.authorization.file.tenants.generated.Group jaxbGroup : tenants.getGroups().getGroup()) {\n            if (jaxbGroup.getIdentifier().equals(group.getIdentifier())) {\n                updateGroup = jaxbGroup;\n                break;\n            }\n        }\n        // if the group wasn't found return null, otherwise update the group and save changes\n        if (updateGroup == null) {\n            return null;\n        }\n        // reset the list of users and add each user to the group\n        updateGroup.getUser().clear();\n        for (String groupUser : group.getUsers()) {\n            org.apache.nifi.registry.security.authorization.file.tenants.generated.Group.User jaxbGroupUser =\n                    new org.apache.nifi.registry.security.authorization.file.tenants.generated.Group.User();\n            jaxbGroupUser.setIdentifier(groupUser);\n            updateGroup.getUser().add(jaxbGroupUser);\n        }\n        updateGroup.setName(group.getName());\n        saveAndRefreshHolder(tenants);\n        return userGroupHolder.get().getGroupsById().get(group.getIdentifier());\n    }\n    @Override\n    public synchronized Group deleteGroup(Group group) throws AuthorizationAccessException {\n        if (group == null) {\n            throw new IllegalArgumentException(\"Group cannot be null\");\n        }\n        return deleteGroup(group.getIdentifier());\n    }\n    @Override\n    public synchronized Group deleteGroup(String groupIdentifier) throws AuthorizationAccessException {\n        if (groupIdentifier == null) {\n            throw new IllegalArgumentException(\"Group identifier cannot be null\");\n        }\n        final UserGroupHolder holder = userGroupHolder.get();\n        final Group deletedGroup = holder.getGroupsById().get(groupIdentifier);\n        if (deletedGroup == null) {\n            return null;\n        }\n        // now remove the actual group from the top-level list of groups\n        final Tenants tenants = holder.getTenants();\n        Iterator<org.apache.nifi.registry.security.authorization.file.tenants.generated.Group> iter = tenants.getGroups().getGroup().iterator();\n        while (iter.hasNext()) {\n            org.apache.nifi.registry.security.authorization.file.tenants.generated.Group jaxbGroup = iter.next();\n            if (groupIdentifier.equals(jaxbGroup.getIdentifier())) {\n                iter.remove();\n                break;\n            }\n        }\n        saveAndRefreshHolder(tenants);\n        return deletedGroup;\n    }\n    UserGroupHolder getUserGroupHolder() {\n        return userGroupHolder.get();\n    }\n    @AuthorizerContext\n    public void setNiFiProperties(NiFiRegistryProperties properties) {\n        this.properties = properties;\n    }\n    @Override\n    public synchronized void inheritFingerprint(String fingerprint) throws AuthorizationAccessException {\n        final UsersAndGroups usersAndGroups = parseUsersAndGroups(fingerprint);\n        usersAndGroups.getUsers().forEach(user -> addUser(user));\n        usersAndGroups.getGroups().forEach(group -> addGroup(group));\n    }\n    @Override\n    public void checkInheritability(String proposedFingerprint) throws AuthorizationAccessException {\n        try {\n            // ensure we understand the proposed fingerprint\n            parseUsersAndGroups(proposedFingerprint);\n        } catch (final AuthorizationAccessException e) {\n            throw new UninheritableAuthorizationsException(\"Unable to parse the proposed fingerprint: \" + e);\n        }\n        final UserGroupHolder usersAndGroups = userGroupHolder.get();\n        // ensure we are in a proper state to inherit the fingerprint\n        if (!usersAndGroups.getAllUsers().isEmpty() || !usersAndGroups.getAllGroups().isEmpty()) {\n            throw new UninheritableAuthorizationsException(\"Proposed fingerprint is not inheritable because the current users and groups is not empty.\");\n        }\n    }\n    @Override\n    public String getFingerprint() throws AuthorizationAccessException {\n        final UserGroupHolder usersAndGroups = userGroupHolder.get();\n        final List<User> users = new ArrayList<>(usersAndGroups.getAllUsers());\n        Collections.sort(users, Comparator.comparing(User::getIdentifier));\n        final List<Group> groups = new ArrayList<>(usersAndGroups.getAllGroups());\n        Collections.sort(groups, Comparator.comparing(Group::getIdentifier));\n        XMLStreamWriter writer = null;\n        final StringWriter out = new StringWriter();\n        try {\n            writer = XML_OUTPUT_FACTORY.createXMLStreamWriter(out);\n            writer.writeStartDocument();\n            writer.writeStartElement(\"tenants\");\n            for (User user : users) {\n                writeUser(writer, user);\n            }\n            for (Group group : groups) {\n                writeGroup(writer, group);\n            }\n            writer.writeEndElement();\n            writer.writeEndDocument();\n            writer.flush();\n        } catch (XMLStreamException e) {\n            throw new AuthorizationAccessException(\"Unable to generate fingerprint\", e);\n        } finally {\n            if (writer != null) {\n                try {\n                    writer.close();\n                } catch (XMLStreamException e) {\n                    // nothing to do here\n                }\n            }\n        }\n        return out.toString();\n    }\n    private UsersAndGroups parseUsersAndGroups(final String fingerprint) {\n        final List<User> users = new ArrayList<>();\n        final List<Group> groups = new ArrayList<>();\n        final byte[] fingerprintBytes = fingerprint.getBytes(StandardCharsets.UTF_8);\n        try (final ByteArrayInputStream in = new ByteArrayInputStream(fingerprintBytes)) {\n            final DocumentBuilder docBuilder = DOCUMENT_BUILDER_FACTORY.newDocumentBuilder();\n            final Document document = docBuilder.parse(in);\n            final Element rootElement = document.getDocumentElement();\n            // parse all the users and add them to the current user group provider\n            NodeList userNodes = rootElement.getElementsByTagName(USER_ELEMENT);\n            for (int i=0; i < userNodes.getLength(); i++) {\n                Node userNode = userNodes.item(i);\n                users.add(parseUser((Element) userNode));\n            }\n            // parse all the groups and add them to the current user group provider\n            NodeList groupNodes = rootElement.getElementsByTagName(GROUP_ELEMENT);\n            for (int i=0; i < groupNodes.getLength(); i++) {\n                Node groupNode = groupNodes.item(i);\n                groups.add(parseGroup((Element) groupNode));\n            }\n        } catch (SAXException | ParserConfigurationException | IOException e) {\n            throw new AuthorizationAccessException(\"Unable to parse fingerprint\", e);\n        }\n        return new UsersAndGroups(users, groups);\n    }\n    private User parseUser(final Element element) {\n        final User.Builder builder = new User.Builder()\n                .identifier(element.getAttribute(IDENTIFIER_ATTR))\n                .identity(element.getAttribute(IDENTITY_ATTR));\n        return builder.build();\n    }\n<fim_suffix>    private Group parseGroup(final Element element) {\n        final Group.Builder builder = new Group.Builder()\n                .identifier(element.getAttribute(IDENTIFIER_ATTR))\n                .name(element.getAttribute(NAME_ATTR));\n        NodeList groupUsers = element.getElementsByTagName(GROUP_USER_ELEMENT);\n        for (int i=0; i < groupUsers.getLength(); i++) {\n            Element groupUserNode = (Element) groupUsers.item(i);\n            builder.addUser(groupUserNode.getAttribute(IDENTIFIER_ATTR));\n        }\n        return builder.build();\n    }<fim_middle>// function below has no smell\n"}