{"text": "<fim_prefix>            if (doPadding) {\n                len = 4 * ((srclen + 2) / 3);\n            } else {\n                int n = srclen % 3;\n                len = 4 * (srclen / 3) + (n == 0 ? 0 : n + 1);\n            }\n            if (linemax > 0)                                  // line separators\n                len += (len - 1) / linemax * newline.length;\n            return len;\n        }\n        /**\n         * Encodes all bytes from the specified byte array into a newly-allocated\n         * byte array using the {@link Base64} encoding scheme. The returned byte\n         * array is of the length of the resulting bytes.\n         *\n         * @param   src\n         *          the byte array to encode\n         * @return  A newly-allocated byte array containing the resulting\n         *          encoded bytes.\n         */\n        public byte[] encode(byte[] src) {\n            int len = outLength(src.length);          // dst array size\n            byte[] dst = new byte[len];\n            int ret = encode0(src, 0, src.length, dst);\n            if (ret != dst.length)\n                 return Arrays.copyOf(dst, ret);\n            return dst;\n        }\n        /**\n         * Encodes all bytes from the specified byte array using the\n         * {@link Base64} encoding scheme, writing the resulting bytes to the\n         * given output byte array, starting at offset 0.\n         *\n         * <p> It is the responsibility of the invoker of this method to make\n         * sure the output byte array {@code dst} has enough space for encoding\n         * all bytes from the input byte array. No bytes will be written to the\n         * output byte array if the output byte array is not big enough.\n         *\n         * @param   src\n         *          the byte array to encode\n         * @param   dst\n         *          the output byte array\n         * @return  The number of bytes written to the output byte array\n         *\n         * @throws  IllegalArgumentException if {@code dst} does not have enough\n         *          space for encoding all input bytes.\n         */\n        public int encode(byte[] src, byte[] dst) {\n            int len = outLength(src.length);         // dst array size\n            if (dst.length < len)\n                throw new IllegalArgumentException(\n                    \"Output byte array is too small for encoding all input bytes\");\n            return encode0(src, 0, src.length, dst);\n        }\n        /**\n         * Encodes the specified byte array into a String using the {@link Base64}\n         * encoding scheme.\n         *\n         * <p> This method first encodes all input bytes into a base64 encoded\n         * byte array and then constructs a new String by using the encoded byte\n         * array and the {@link java.nio.charset.StandardCharsets#ISO_8859_1\n         * ISO-8859-1} charset.\n         *\n         * <p> In other words, an invocation of this method has exactly the same\n         * effect as invoking\n         * {@code new String(encode(src), StandardCharsets.ISO_8859_1)}.\n         *\n         * @param   src\n         *          the byte array to encode\n         * @return  A String containing the resulting Base64 encoded characters\n         */\n        @SuppressWarnings(\"deprecation\")\n        public String encodeToString(byte[] src) {\n            byte[] encoded = encode(src);\n            return new String(encoded, 0, 0, encoded.length);\n        }\n        /**\n         * Encodes all remaining bytes from the specified byte buffer into\n         * a newly-allocated ByteBuffer using the {@link Base64} encoding\n         * scheme.\n         *\n         * Upon return, the source buffer's position will be updated to\n         * its limit; its limit will not have been changed. The returned\n         * output buffer's position will be zero and its limit will be the\n         * number of resulting encoded bytes.\n         *\n         * @param   buffer\n         *          the source ByteBuffer to encode\n         * @return  A newly-allocated byte buffer containing the encoded bytes.\n         */\n        public ByteBuffer encode(ByteBuffer buffer) {\n            int len = outLength(buffer.remaining());\n            byte[] dst = new byte[len];\n            int ret = 0;\n            if (buffer.hasArray()) {\n                ret = encode0(buffer.array(),\n                              buffer.arrayOffset() + buffer.position(),\n                              buffer.arrayOffset() + buffer.limit(),\n                              dst);\n                buffer.position(buffer.limit());\n            } else {\n                byte[] src = new byte[buffer.remaining()];\n                buffer.get(src);\n                ret = encode0(src, 0, src.length, dst);\n            }\n            if (ret != dst.length)\n                 dst = Arrays.copyOf(dst, ret);\n            return ByteBuffer.wrap(dst);\n        }\n        /**\n         * Wraps an output stream for encoding byte data using the {@link Base64}\n         * encoding scheme.\n         *\n         * <p> It is recommended to promptly close the returned output stream after\n         * use, during which it will flush all possible leftover bytes to the underlying\n         * output stream. Closing the returned output stream will close the underlying\n         * output stream.\n         *\n         * @param   os\n         *          the output stream.\n         * @return  the output stream for encoding the byte data into the\n         *          specified Base64 encoded format\n         */\n        public OutputStream wrap(OutputStream os) {\n            Objects.requireNonNull(os);\n            return new EncOutputStream(os, isURL ? toBase64URL : toBase64,\n                                       newline, linemax, doPadding);\n        }\n        /**\n         * Returns an encoder instance that encodes equivalently to this one,\n         * but without adding any padding character at the end of the encoded\n         * byte data.\n         *\n         * <p> The encoding scheme of this encoder instance is unaffected by\n         * this invocation. The returned encoder instance should be used for\n         * non-padding encoding operation.\n         *\n         * @return an equivalent encoder that encodes without adding any\n         *         padding character at the end\n         */\n        public Encoder withoutPadding() {\n            if (!doPadding)\n                return this;\n            return new Encoder(isURL, newline, linemax, false);\n        }\n<fim_suffix>        private int encode0(byte[] src, int off, int end, byte[] dst) {\n            char[] base64 = isURL ? toBase64URL : toBase64;\n            int sp = off;\n            int slen = (end - off) / 3 * 3;\n            int sl = off + slen;\n            if (linemax > 0 && slen  > linemax / 4 * 3)\n                slen = linemax / 4 * 3;\n            int dp = 0;\n            while (sp < sl) {\n                int sl0 = Math.min(sp + slen, sl);\n                for (int sp0 = sp, dp0 = dp ; sp0 < sl0; ) {\n                    int bits = (src[sp0++] & 0xff) << 16 |\n                               (src[sp0++] & 0xff) <<  8 |\n                               (src[sp0++] & 0xff);\n                    dst[dp0++] = (byte)base64[(bits >>> 18) & 0x3f];\n                    dst[dp0++] = (byte)base64[(bits >>> 12) & 0x3f];\n                    dst[dp0++] = (byte)base64[(bits >>> 6)  & 0x3f];\n                    dst[dp0++] = (byte)base64[bits & 0x3f];\n                }\n                int dlen = (sl0 - sp) / 3 * 4;\n                dp += dlen;\n                sp = sl0;\n                if (dlen == linemax && sp < end) {\n                    for (byte b : newline){\n                        dst[dp++] = b;\n                    }\n                }\n            }\n            if (sp < end) {               // 1 or 2 leftover bytes\n                int b0 = src[sp++] & 0xff;\n                dst[dp++] = (byte)base64[b0 >> 2];\n                if (sp == end) {\n                    dst[dp++] = (byte)base64[(b0 << 4) & 0x3f];\n                    if (doPadding) {\n                        dst[dp++] = '=';\n                        dst[dp++] = '=';\n                    }\n                } else {\n                    int b1 = src[sp++] & 0xff;\n                    dst[dp++] = (byte)base64[(b0 << 4) & 0x3f | (b1 >> 4)];\n                    dst[dp++] = (byte)base64[(b1 << 2) & 0x3f];\n                    if (doPadding) {\n                        dst[dp++] = '=';\n                    }\n                }\n            }\n            return dp;\n        }<fim_middle>// function below is long method\n"}