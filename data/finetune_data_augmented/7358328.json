{"text": "<fim_prefix>        expectedResults.add(\"BASE\"); //$NON-NLS-1$\n        expectedResults.add(\"BASESUB1SUB2SUB3\"); //$NON-NLS-1$\n        expectedResults.add(\"BASESUB1SUB2SUB4\"); //$NON-NLS-1$\n        expectedResults.add(\"BASESUB1SUB5SUB7SUB9\"); //$NON-NLS-1$\n        expectedResults.add(\"OTHR\"); //$NON-NLS-1$\n        Assert.assertTrue(areStringListsEqual(expectedResults, results, String.CASE_INSENSITIVE_ORDER));\n        // Remove the BASESUB1SUB2 node (which is sparse) and its children.\n        Assert.assertTrue(st.remove(\"BASESUB1SUB2\", true)); //$NON-NLS-1$\n        results = new ArrayList<String>();\n        st.EnumSubTree(\n            null,\n            new AccumulatorCallback(),\n            EnumSubTreeOptions.ENUMERATE_SUB_TREE_ROOT,\n            Integer.MAX_VALUE,\n            additionalData,\n            results);\n        expectedResults = new ArrayList<String>();\n        expectedResults.add(\"BASE\"); //$NON-NLS-1$\n        expectedResults.add(\"BASESUB1SUB5SUB7SUB9\"); //$NON-NLS-1$\n        expectedResults.add(\"OTHR\"); //$NON-NLS-1$\n        Assert.assertTrue(areStringListsEqual(expectedResults, results, String.CASE_INSENSITIVE_ORDER));\n    }\n    // Test 18. Test Remove with variable-length tokens.\n    public void test18() {\n        final SparseTreeAdditionalData additionalData = new SparseTreeAdditionalData();\n        final SparseTree<String> st = new SparseTree<String>('/', String.CASE_INSENSITIVE_ORDER);\n        st.add(\"/$/BASE/SUB1/SUB2/SUB3\", \"Child node 3\"); //$NON-NLS-1$ //$NON-NLS-2$\n        st.add(\"/$/BASE/SUB1/SUB2/SUB4\", \"Child node 4\"); //$NON-NLS-1$ //$NON-NLS-2$\n        st.add(\"/$/BASE/SUB1/SUB5/SUB7/SUB9\", \"Child node 5\"); //$NON-NLS-1$ //$NON-NLS-2$\n        st.add(\"/$/BASE\", \"Base node\"); //$NON-NLS-1$ //$NON-NLS-2$\n        st.add(\"/$/BASE/SUB1\", \"Child node 1\"); //$NON-NLS-1$ //$NON-NLS-2$\n        st.add(\"/$/OTHR\", \"Other node\"); //$NON-NLS-1$ //$NON-NLS-2$\n        st.add(\"$/FUN\", \"Other root node\"); //$NON-NLS-1$ //$NON-NLS-2$\n        st.add(\"$/AAA\", \"Other root node\"); //$NON-NLS-1$ //$NON-NLS-2$\n        st.add(\"\", \"empty string root node\"); //$NON-NLS-1$ //$NON-NLS-2$\n        List<String> results = new ArrayList<String>();\n        EnumSubTreeOptions options =\n            EnumSubTreeOptions.ENUMERATE_SUB_TREE_ROOT.combine(EnumSubTreeOptions.ENUMERATE_SPARSE_NODES);\n        st.EnumSubTree(null, new AccumulatorCallback(), options, Integer.MAX_VALUE, additionalData, results);\n        List<String> expectedResults = new ArrayList<String>();\n        expectedResults.add(\"\"); //$NON-NLS-1$\n        expectedResults.add(\"/$\"); //$NON-NLS-1$\n        expectedResults.add(\"/$/BASE\"); //$NON-NLS-1$\n        expectedResults.add(\"/$/BASE/SUB1\"); //$NON-NLS-1$\n        expectedResults.add(\"/$/BASE/SUB1/SUB2\"); //$NON-NLS-1$\n        expectedResults.add(\"/$/BASE/SUB1/SUB2/SUB3\"); //$NON-NLS-1$\n        expectedResults.add(\"/$/BASE/SUB1/SUB2/SUB4\"); //$NON-NLS-1$\n        expectedResults.add(\"/$/BASE/SUB1/SUB5\"); //$NON-NLS-1$\n        expectedResults.add(\"/$/BASE/SUB1/SUB5/SUB7\"); //$NON-NLS-1$\n        expectedResults.add(\"/$/BASE/SUB1/SUB5/SUB7/SUB9\"); //$NON-NLS-1$\n        expectedResults.add(\"/$/OTHR\"); //$NON-NLS-1$\n        expectedResults.add(\"$\"); //$NON-NLS-1$\n        expectedResults.add(\"$/AAA\"); //$NON-NLS-1$\n        expectedResults.add(\"$/FUN\"); //$NON-NLS-1$\n        Assert.assertTrue(areStringListsEqual(expectedResults, results, String.CASE_INSENSITIVE_ORDER));\n        // Remove the empty string token from the tree\n        Assert.assertTrue(st.remove(\"/\", false)); //$NON-NLS-1$\n        results = new ArrayList<String>();\n        options = EnumSubTreeOptions.ENUMERATE_SUB_TREE_ROOT.combine(EnumSubTreeOptions.ENUMERATE_SPARSE_NODES);\n        st.EnumSubTree(null, new AccumulatorCallback(), options, Integer.MAX_VALUE, additionalData, results);\n        // No change to expected results\n        Assert.assertTrue(areStringListsEqual(expectedResults, results, String.CASE_INSENSITIVE_ORDER));\n        // Remove the empty string token's children from the tree\n        Assert.assertTrue(st.remove(\"/\", true)); //$NON-NLS-1$\n        results = new ArrayList<String>();\n        options = EnumSubTreeOptions.ENUMERATE_SUB_TREE_ROOT.combine(EnumSubTreeOptions.ENUMERATE_SPARSE_NODES);\n        st.EnumSubTree(null, new AccumulatorCallback(), options, Integer.MAX_VALUE, additionalData, results);\n        expectedResults = new ArrayList<String>();\n        expectedResults.add(\"$\"); //$NON-NLS-1$\n        expectedResults.add(\"$/AAA\"); //$NON-NLS-1$\n        expectedResults.add(\"$/FUN\"); //$NON-NLS-1$\n        Assert.assertTrue(areStringListsEqual(expectedResults, results, String.CASE_INSENSITIVE_ORDER));\n    }\n    // Test 19. Test common failure conditions and miscellaneous methods\n    public void test19() {\n        final SparseTreeAdditionalData additionalData = new SparseTreeAdditionalData();\n        final SparseTree<String> st = new SparseTree<String>('/', String.CASE_INSENSITIVE_ORDER);\n        st.add(\"$/BASE/SUB1/SUB2/SUB3\", \"Child node 3\"); //$NON-NLS-1$ //$NON-NLS-2$\n        boolean caughtArgumentException = false;\n        try {\n            // Collision\n            st.add(\"$/BASE/SUB1/SUB2/SUB3\", \"Replacement\"); //$NON-NLS-1$ //$NON-NLS-2$\n        } catch (final IllegalArgumentException e) {\n            caughtArgumentException = true;\n        }\n        Assert.assertTrue(caughtArgumentException);\n        // Removing an object that isn't there\n        Assert.assertFalse(st.remove(\"$/SILLY\", false)); //$NON-NLS-1$\n        Assert.assertFalse(st.remove(\"$/SILLY\", true)); //$NON-NLS-1$\n        // Does not exist in the tree\n        Assert.assertNull(st.get(\"$/Wiggles\")); //$NON-NLS-1$\n        // Does not exist in the tree\n        Assert.assertNull(st.get(\"/\")); //$NON-NLS-1$\n        // Clear\n        st.clear();\n        final List<String> results = new ArrayList<String>();\n        final EnumSubTreeOptions options =\n            EnumSubTreeOptions.ENUMERATE_SUB_TREE_ROOT.combine(EnumSubTreeOptions.ENUMERATE_SPARSE_NODES);\n        st.EnumSubTree(null, new AccumulatorCallback(), options, Integer.MAX_VALUE, additionalData, results);\n        final List<String> expectedResults = new ArrayList<String>();\n        Assert.assertTrue(areStringListsEqual(expectedResults, results, String.CASE_INSENSITIVE_ORDER));\n    }\n    // Test 20. EnumParents test with SparseTreeAdditionalData (1)\n<fim_suffix>    public void test20() {\n        final SparseTreeAdditionalData additionalData = new SparseTreeAdditionalData();\n        final SparseTree<String> st = new SparseTree<String>('/', String.CASE_INSENSITIVE_ORDER);\n        st.add(\"$\", \"Root\"); //$NON-NLS-1$ //$NON-NLS-2$\n        st.add(\"$/A\", \"A\"); //$NON-NLS-1$ //$NON-NLS-2$\n        st.add(\"$/A/Z\", \"AZ\"); //$NON-NLS-1$ //$NON-NLS-2$\n        final List<String> results = new ArrayList<String>();\n        st.EnumParents(\"$/A/B/C/D/E\", new NoChildrenBelowCallback(), EnumParentsOptions.NONE, additionalData, results); //$NON-NLS-1$\n        final List<String> expectedResults = new ArrayList<String>();\n        expectedResults.add(\"$/A/B\"); //$NON-NLS-1$\n        expectedResults.add(null);\n        Assert.assertTrue(areStringListsEqual(expectedResults, results, String.CASE_INSENSITIVE_ORDER));\n    }<fim_middle>// function below has no smell\n"}