{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.gobblin.rest;\n\nimport com.linkedin.restli.server.ResourceContext;\nimport java.util.Map;\nimport java.util.Set;\nimport javax.inject.Inject;\nimport javax.inject.Named;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.google.common.collect.Maps;\n\nimport com.linkedin.restli.common.ComplexResourceKey;\nimport com.linkedin.restli.common.EmptyRecord;\nimport com.linkedin.restli.server.annotations.RestLiCollection;\nimport com.linkedin.restli.server.resources.ComplexKeyResourceTemplate;\n\nimport org.apache.gobblin.metastore.JobHistoryStore;\n\n\n/**\n * A Rest.li resource for serving queries of Gobblin job executions.\n *\n * @author Yinan Li\n */\n<fim_suffix>@RestLiCollection(name = \"jobExecutions\", namespace = \"org.apache.gobblin.rest\")\npublic class JobExecutionInfoResource extends ComplexKeyResourceTemplate<JobExecutionQuery, EmptyRecord, JobExecutionQueryResult> {\n\n  private static final Logger LOGGER = LoggerFactory.getLogger(JobExecutionInfoResource.class);\n\n  @Inject\n  @Named(\"jobHistoryStore\")\n  private JobHistoryStore jobHistoryStore;\n\n  @Override\n  public JobExecutionQueryResult get(ComplexResourceKey<JobExecutionQuery, EmptyRecord> key) {\n    JobExecutionQuery query = key.getKey();\n\n    JobExecutionInfoArray jobExecutionInfos = new JobExecutionInfoArray();\n    try {\n      for (JobExecutionInfo jobExecutionInfo : this.jobHistoryStore.get(query)) {\n        jobExecutionInfos.add(jobExecutionInfo);\n      }\n    } catch (Throwable t) {\n      LOGGER\n          .error(String.format(\"Failed to execute query [id = %s, type = %s]\", query.getId(), query.getIdType().name()),\n              t);\n      return null;\n    }\n\n    JobExecutionQueryResult result = new JobExecutionQueryResult();\n    result.setJobExecutions(jobExecutionInfos);\n    ResourceContext rc = this.getContext();\n    rc.setResponseHeader(\"Access-Control-Allow-Origin\", \"*\");\n    this.setContext(rc);\n\n    return result;\n  }\n\n  @Override\n  public Map<ComplexResourceKey<JobExecutionQuery, EmptyRecord>, JobExecutionQueryResult> batchGet(\n      Set<ComplexResourceKey<JobExecutionQuery, EmptyRecord>> keys) {\n\n    Map<ComplexResourceKey<JobExecutionQuery, EmptyRecord>, JobExecutionQueryResult> results = Maps.newHashMap();\n    for (ComplexResourceKey<JobExecutionQuery, EmptyRecord> key : keys) {\n      JobExecutionQueryResult result = get(key);\n      if (result != null) {\n        results.put(key, get(key));\n      }\n    }\n    ResourceContext rc = this.getContext();\n    rc.setResponseHeader(\"Access-Control-Allow-Origin\", \"*\");\n    this.setContext(rc);\n\n    return results;\n  }\n}<fim_middle>// class below has no smell\n"}