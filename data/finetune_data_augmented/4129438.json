{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.calcite.adapter.elasticsearch;\nimport org.apache.calcite.adapter.enumerable.RexImpTable;\nimport org.apache.calcite.adapter.enumerable.RexToLixTranslator;\nimport org.apache.calcite.adapter.java.JavaTypeFactory;\nimport org.apache.calcite.plan.Convention;\nimport org.apache.calcite.plan.RelOptRule;\nimport org.apache.calcite.plan.RelTrait;\nimport org.apache.calcite.plan.RelTraitSet;\nimport org.apache.calcite.rel.InvalidRelException;\nimport org.apache.calcite.rel.RelCollations;\nimport org.apache.calcite.rel.RelNode;\nimport org.apache.calcite.rel.convert.ConverterRule;\nimport org.apache.calcite.rel.core.Sort;\nimport org.apache.calcite.rel.logical.LogicalAggregate;\nimport org.apache.calcite.rel.logical.LogicalFilter;\nimport org.apache.calcite.rel.logical.LogicalProject;\nimport org.apache.calcite.rel.type.RelDataType;\nimport org.apache.calcite.rex.RexCall;\nimport org.apache.calcite.rex.RexInputRef;\nimport org.apache.calcite.rex.RexLiteral;\nimport org.apache.calcite.rex.RexNode;\nimport org.apache.calcite.rex.RexVisitorImpl;\nimport org.apache.calcite.sql.SqlKind;\nimport org.apache.calcite.sql.fun.SqlStdOperatorTable;\nimport org.apache.calcite.sql.type.SqlTypeName;\nimport org.apache.calcite.sql.validate.SqlValidatorUtil;\nimport java.util.AbstractList;\nimport java.util.ArrayList;\nimport java.util.List;\n/**\n * Rules and relational operators for\n * {@link ElasticsearchRel#CONVENTION ELASTICSEARCH}\n * calling convention.\n */\nclass ElasticsearchRules {\n  static final RelOptRule[] RULES = {\n      ElasticsearchSortRule.INSTANCE,\n      ElasticsearchFilterRule.INSTANCE,\n      ElasticsearchProjectRule.INSTANCE,\n      ElasticsearchAggregateRule.INSTANCE\n  };\n  private ElasticsearchRules() {}\n  /**\n   * Returns 'string' if it is a call to item['string'], null otherwise.\n   * @param call current relational expression\n   * @return literal value\n   */\n  static String isItem(RexCall call) {\n    if (call.getOperator() != SqlStdOperatorTable.ITEM) {\n      return null;\n    }\n    final RexNode op0 = call.getOperands().get(0);\n    final RexNode op1 = call.getOperands().get(1);\n    if (op0 instanceof RexInputRef\n        && ((RexInputRef) op0).getIndex() == 0\n        && op1 instanceof RexLiteral\n        && ((RexLiteral) op1).getValue2() instanceof String) {\n      return (String) ((RexLiteral) op1).getValue2();\n    }\n    return null;\n  }\n  static boolean isItem(RexNode node) {\n    final Boolean result = node.accept(new RexVisitorImpl<Boolean>(false) {\n      @Override public Boolean visitCall(final RexCall call) {\n        return isItem(call) != null;\n      }\n    });\n    return Boolean.TRUE.equals(result);\n  }\n  static List<String> elasticsearchFieldNames(final RelDataType rowType) {\n    return SqlValidatorUtil.uniquify(\n        new AbstractList<String>() {\n          @Override public String get(int index) {\n            final String name = rowType.getFieldList().get(index).getName();\n            return name.startsWith(\"$\") ? \"_\" + name.substring(2) : name;\n          }\n          @Override public int size() {\n            return rowType.getFieldCount();\n          }\n        },\n        SqlValidatorUtil.EXPR_SUGGESTER, true);\n  }\n  static String quote(String s) {\n    return \"\\\"\" + s + \"\\\"\";\n  }\n  static String stripQuotes(String s) {\n    return s.length() > 1 && s.startsWith(\"\\\"\") && s.endsWith(\"\\\"\")\n        ? s.substring(1, s.length() - 1) : s;\n  }\n  /**\n   * Translator from {@link RexNode} to strings in Elasticsearch's expression\n   * language.\n   */\n  static class RexToElasticsearchTranslator extends RexVisitorImpl<String> {\n    private final JavaTypeFactory typeFactory;\n    private final List<String> inFields;\n    RexToElasticsearchTranslator(JavaTypeFactory typeFactory, List<String> inFields) {\n      super(true);\n      this.typeFactory = typeFactory;\n      this.inFields = inFields;\n    }\n    @Override public String visitLiteral(RexLiteral literal) {\n      if (literal.getValue() == null) {\n        return \"null\";\n      }\n      return \"\\\"literal\\\":\\\"\"\n        + RexToLixTranslator.translateLiteral(literal, literal.getType(),\n          typeFactory, RexImpTable.NullAs.NOT_POSSIBLE)\n        + \"\\\"\";\n    }\n    @Override public String visitInputRef(RexInputRef inputRef) {\n      return quote(inFields.get(inputRef.getIndex()));\n    }\n    @Override public String visitCall(RexCall call) {\n      final String name = isItem(call);\n      if (name != null) {\n        return name;\n      }\n      final List<String> strings = visitList(call.operands);\n      if (call.getKind() == SqlKind.CAST) {\n        return strings.get(0).startsWith(\"$\") ? strings.get(0).substring(1) : strings.get(0);\n      }\n      if (call.getOperator() == SqlStdOperatorTable.ITEM) {\n        final RexNode op1 = call.getOperands().get(1);\n        if (op1 instanceof RexLiteral && op1.getType().getSqlTypeName() == SqlTypeName.INTEGER) {\n          return stripQuotes(strings.get(0)) + \"[\" + ((RexLiteral) op1).getValue2() + \"]\";\n        }\n      }\n      throw new IllegalArgumentException(\"Translation of \" + call\n          + \" is not supported by ElasticsearchProject\");\n    }\n    List<String> visitList(List<RexNode> list) {\n      final List<String> strings = new ArrayList<>();\n      for (RexNode node: list) {\n        strings.add(node.accept(this));\n      }\n      return strings;\n    }\n  }\n  /**\n   * Base class for planner rules that convert a relational expression to\n   * Elasticsearch calling convention.\n   */\n<fim_suffix>  abstract static class ElasticsearchConverterRule extends ConverterRule {\n    final Convention out;\n    ElasticsearchConverterRule(Class<? extends RelNode> clazz, RelTrait in, Convention out,\n        String description) {\n      super(clazz, in, out, description);\n      this.out = out;\n    }\n  }\n  /**\n   * Rule to convert a {@link org.apache.calcite.rel.core.Sort} to an\n   * {@link ElasticsearchSort}.\n   */\n  private static class ElasticsearchSortRule extends ElasticsearchConverterRule {\n    private static final ElasticsearchSortRule INSTANCE =\n        new ElasticsearchSortRule();\n    private ElasticsearchSortRule() {\n      super(Sort.class, Convention.NONE, ElasticsearchRel.CONVENTION,\n          \"ElasticsearchSortRule\");\n    }\n    @Override public RelNode convert(RelNode relNode) {\n      final Sort sort = (Sort) relNode;\n      final RelTraitSet traitSet = sort.getTraitSet().replace(out).replace(sort.getCollation());\n      return new ElasticsearchSort(relNode.getCluster(), traitSet,\n        convert(sort.getInput(), traitSet.replace(RelCollations.EMPTY)), sort.getCollation(),\n        sort.offset, sort.fetch);\n    }\n  }\n  /**\n   * Rule to convert a {@link org.apache.calcite.rel.logical.LogicalFilter} to an\n   * {@link ElasticsearchFilter}.\n   */\n  private static class ElasticsearchFilterRule extends ElasticsearchConverterRule {\n    private static final ElasticsearchFilterRule INSTANCE = new ElasticsearchFilterRule();\n    private ElasticsearchFilterRule() {\n      super(LogicalFilter.class, Convention.NONE, ElasticsearchRel.CONVENTION,\n        \"ElasticsearchFilterRule\");\n    }<fim_middle>// class below has no smell\n"}