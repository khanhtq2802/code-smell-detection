{"text": "<fim_prefix>                            if (opcode == DebugInfoItem.DBG_START_LOCAL_EXTENDED) {\n                                int sigIndex = readUleb128p1();\n                                Leb128.writeUnsignedLeb128p1(outAdapter, sigIndex);\n                            }\n                            break;\n                        }\n                        case DebugInfoItem.DBG_END_LOCAL:\n                        case DebugInfoItem.DBG_RESTART_LOCAL: {\n                            int registerNum = readUleb128();\n                            Leb128.writeUnsignedLeb128(outAdapter, registerNum);\n                            break;\n                        }\n                        case DebugInfoItem.DBG_SET_FILE: {\n                            int nameIndex = readUleb128p1();\n                            Leb128.writeUnsignedLeb128p1(outAdapter, nameIndex);\n                            break;\n                        }\n                        case DebugInfoItem.DBG_SET_PROLOGUE_END:\n                        case DebugInfoItem.DBG_SET_EPILOGUE_BEGIN:\n                        default: {\n                            break;\n                        }\n                    }\n                }\n            byte[] infoSTM = baos.toByteArray();\n            return new DebugInfoItem(off, lineStart, parameterNames, infoSTM);\n        } finally {\n            if (baos != null) {\n                try {\n                    baos.close();\n                } catch (Exception e) {\n                    // Do nothing.\n                }\n            }\n        }\n    }\n    public ClassData readClassData() {\n        int off = data.position();\n        int staticFieldsSize = readUleb128();\n        int instanceFieldsSize = readUleb128();\n        int directMethodsSize = readUleb128();\n        int virtualMethodsSize = readUleb128();\n        ClassData.Field[] staticFields = readFields(staticFieldsSize);\n        ClassData.Field[] instanceFields = readFields(instanceFieldsSize);\n        ClassData.Method[] directMethods = readMethods(directMethodsSize);\n        ClassData.Method[] virtualMethods = readMethods(virtualMethodsSize);\n        return new ClassData(off, staticFields, instanceFields, directMethods, virtualMethods);\n    }\n    private ClassData.Field[] readFields(int count) {\n        ClassData.Field[] result = new ClassData.Field[count];\n        int fieldIndex = 0;\n        for (int i = 0; i < count; i++) {\n            fieldIndex += readUleb128(); // field index diff\n            int accessFlags = readUleb128();\n            result[i] = new ClassData.Field(fieldIndex, accessFlags);\n        }\n        return result;\n    }\n    private ClassData.Method[] readMethods(int count) {\n        ClassData.Method[] result = new ClassData.Method[count];\n        int methodIndex = 0;\n        for (int i = 0; i < count; i++) {\n            methodIndex += readUleb128(); // method index diff\n            int accessFlags = readUleb128();\n            int codeOff = readUleb128();\n            result[i] = new ClassData.Method(methodIndex, accessFlags, codeOff);\n        }\n        return result;\n    }\n    /**\n     * Returns a byte array containing the bytes from {@code start} to this\n     * section's current position.\n     */\n    private byte[] getBytesFrom(int start) {\n        int end = data.position();\n        byte[] result = new byte[end - start];\n        data.position(start);\n        data.get(result);\n        return result;\n    }\n    public Annotation readAnnotation() {\n        int off = data.position();\n        byte visibility = readByte();\n        int start = data.position();\n        new EncodedValueReader(this, EncodedValueReader.ENCODED_ANNOTATION).skipValue();\n        return new Annotation(off, visibility, new EncodedValue(start, getBytesFrom(start)));\n    }\n    public AnnotationSet readAnnotationSet() {\n        int off = data.position();\n        int size = readInt();\n        int[] annotationOffsets = new int[size];\n        for (int i = 0; i < size; ++i) {\n            annotationOffsets[i] = readInt();\n        }\n        return new AnnotationSet(off, annotationOffsets);\n    }\n    public AnnotationSetRefList readAnnotationSetRefList() {\n        int off = data.position();\n        int size = readInt();\n        int[] annotationSetRefItems = new int[size];\n        for (int i = 0; i < size; ++i) {\n            annotationSetRefItems[i] = readInt();\n        }\n        return new AnnotationSetRefList(off, annotationSetRefItems);\n    }\n    public AnnotationsDirectory readAnnotationsDirectory() {\n        int off = data.position();\n        int classAnnotationsOffset = readInt();\n        int fieldsSize = readInt();\n        int methodsSize = readInt();\n        int parameterListSize = readInt();\n        int[][] fieldAnnotations = new int[fieldsSize][2];\n        for (int i = 0; i < fieldsSize; ++i) {\n            // field index\n            fieldAnnotations[i][0] = readInt();\n            // annotations offset\n            fieldAnnotations[i][1] = readInt();\n        }\n        int[][] methodAnnotations = new int[methodsSize][2];\n        for (int i = 0; i < methodsSize; ++i) {\n            // method index\n            methodAnnotations[i][0] = readInt();\n            // annotation set offset\n            methodAnnotations[i][1] = readInt();\n        }\n        int[][] parameterAnnotations = new int[parameterListSize][2];\n        for (int i = 0; i < parameterListSize; ++i) {\n            // method index\n            parameterAnnotations[i][0] = readInt();\n            // annotations offset\n            parameterAnnotations[i][1] = readInt();\n        }\n        return new AnnotationsDirectory(off, classAnnotationsOffset, fieldAnnotations, methodAnnotations, parameterAnnotations);\n    }\n    public EncodedValue readEncodedArray() {\n        int start = data.position();\n        new EncodedValueReader(this, EncodedValueReader.ENCODED_ARRAY).skipValue();\n        return new EncodedValue(start, getBytesFrom(start));\n    }\n    public void skip(int count) {\n        if (count < 0) {\n            throw new IllegalArgumentException();\n        }\n        data.position(data.position() + count);\n    }\n    public void skipWithAutoExpand(int count) {\n        ensureBufferSize(SizeOf.UBYTE * count);\n        skip(count);\n    }\n    /**\n     * Skips bytes until the position is aligned to a multiple of 4.\n     */\n    public void alignToFourBytes() {\n        data.position((data.position() + 3) & ~3);\n    }\n    /**\n     * Writes 0x00 until the position is aligned to a multiple of 4.\n     */\n    public void alignToFourBytesWithZeroFill() {\n        int alignedPos = SizeOf.roundToTimesOfFour(data.position());\n        ensureBufferSize((alignedPos - data.position()) * SizeOf.UBYTE);\n        while ((data.position() & 3) != 0) {\n            data.put((byte) 0);\n        }\n        if (this.data.position() > this.dataBound) {\n            this.dataBound = this.data.position();\n        }\n    }\n    @Override\n    public void writeByte(int b) {\n        ensureBufferSize(SizeOf.UBYTE);\n        data.put((byte) b);\n        if (this.data.position() > this.dataBound) {\n            this.dataBound = this.data.position();\n        }\n    }\n    public void writeShort(short i) {\n        ensureBufferSize(SizeOf.USHORT);\n        data.putShort(i);\n        if (this.data.position() > this.dataBound) {\n            this.dataBound = this.data.position();\n        }\n    }\n    public void writeUnsignedShort(int i) {\n        short s = (short) i;\n        if (i != (s & 0xffff)) {\n            throw new IllegalArgumentException(\"Expected an unsigned short: \" + i);\n        }\n        writeShort(s);\n    }\n    public void writeInt(int i) {\n        ensureBufferSize(SizeOf.UINT);\n        this.data.putInt(i);\n        if (this.data.position() > this.dataBound) {\n            this.dataBound = this.data.position();\n        }\n    }\n    public void write(byte[] bytes) {\n        ensureBufferSize(bytes.length * SizeOf.UBYTE);\n        this.data.put(bytes);\n        if (this.data.position() > this.dataBound) {\n            this.dataBound = this.data.position();\n        }\n    }\n<fim_suffix>    public void write(short[] shorts) {\n        ensureBufferSize(shorts.length * SizeOf.USHORT);\n        for (short s : shorts) {\n            writeShort(s);\n        }\n        if (this.data.position() > this.dataBound) {\n            this.dataBound = this.data.position();\n        }\n    }<fim_middle>// function below has no smell\n"}