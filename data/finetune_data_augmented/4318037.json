{"text": "<fim_prefix>                    intermediateOrderByNullsLow[intermediateOrderByIdx] = false;\n                    intermediateOrderByColumns[intermediateOrderByIdx] = i;\n                    intermediateOrderByIdx++;\n                }\n            }\n            qec.setOrderByList(0, null); // It will be pushed down.\n        }\n        else // The output of the intersect/except does not have to be ordered\n        {\n            // Pick an intermediate ordering that minimizes the cost.\n            // RESOLVE: how do you do that?\n            for( int i = 0; i < intermediateOrderByColumns.length; i++)\n            {\n                intermediateOrderByDirection[i] = 1;\n                intermediateOrderByNullsLow[i] = false;\n                intermediateOrderByColumns[i] = i;\n            }\n        }\n        pushOrderingDown( leftResultSet);\n        pushOrderingDown( rightResultSet);\n        return super.preprocess( numTables, gbl, fromList);\n    } // end of preprocess\n    private void pushOrderingDown( ResultSetNode rsn)\n        throws StandardException\n    {\n        ContextManager cm = getContextManager();\n        OrderByList orderByList = new OrderByList(null, cm);\n        for( int i = 0; i < intermediateOrderByColumns.length; i++)\n        {\n            OrderByColumn orderByColumn =\n                new OrderByColumn(\n                    new NumericConstantNode(\n                        TypeId.getBuiltInTypeId(Types.INTEGER),\n                        intermediateOrderByColumns[i] + 1,\n                        cm),\n                    cm);\n            if( intermediateOrderByDirection[i] < 0) {\n                orderByColumn.setDescending();\n            }\n            if( intermediateOrderByNullsLow[i]) {\n                orderByColumn.setNullsOrderedLow();\n            }\n            orderByList.addOrderByColumn( orderByColumn);\n        }\n        orderByList.bindOrderByColumns( rsn);\n        rsn.pushQueryExpressionSuffix();\n        rsn.pushOrderByList( orderByList);\n    } // end of pushOrderingDown\n    /**\n     * @see org.apache.derby.iapi.sql.compile.Optimizable#estimateCost\n     */\n    @Override\n    public CostEstimate estimateCost( OptimizablePredicateList predList,\n                                      ConglomerateDescriptor cd,\n                                      CostEstimate outerCost,\n                                      Optimizer optimizer,\n                                      RowOrdering rowOrdering)\n                          throws StandardException\n    {\n\t\tleftResultSet = optimizeSource(\n\t\t\t\t\t\t\toptimizer,\n\t\t\t\t\t\t\tleftResultSet,\n\t\t\t\t\t\t\t(PredicateList) null,\n\t\t\t\t\t\t\touterCost);\n\t\trightResultSet = optimizeSource(\n\t\t\t\t\t\t\toptimizer,\n\t\t\t\t\t\t\trightResultSet,\n\t\t\t\t\t\t\t(PredicateList) null,\n\t\t\t\t\t\t\touterCost);\n        CostEstimate costEst = getCostEstimate(optimizer);\n        CostEstimate leftCostEstimate = leftResultSet.getCostEstimate();\n        CostEstimate rightCostEstimate = rightResultSet.getCostEstimate();\n        // The cost is the sum of the two child costs plus the cost of\n        // sorting the union.\n        costEst.setCost(\n            leftCostEstimate.getEstimatedCost() +\n                rightCostEstimate.getEstimatedCost(),\n            getRowCountEstimate(\n                leftCostEstimate.rowCount(),\n                rightCostEstimate.rowCount()),\n            getSingleScanRowCountEstimate(\n                leftCostEstimate.singleScanRowCount(),\n                rightCostEstimate.singleScanRowCount()));\n        return costEst;\n    } // End of estimateCost\n\t/**\n\t * @see Optimizable#modifyAccessPath\n\t *\n\t * @exception StandardException\t\tThrown on error\n\t */\n    @Override\n\tpublic Optimizable modifyAccessPath(JBitSet outerTables) throws StandardException\n\t{\n\t\tOptimizable retOptimizable;\n\t\tretOptimizable = super.modifyAccessPath(outerTables);\n\t\t/* We only want call addNewNodes() once */\n\t\tif (addNewNodesCalled)\n\t\t{\n\t\t\treturn retOptimizable;\n\t\t}\n\t\treturn (Optimizable) addNewNodes();\n\t}\n\t/**\n\t * @see ResultSetNode#modifyAccessPaths\n\t *\n\t * @exception StandardException\t\tThrown on error\n\t */\n    @Override\n    ResultSetNode modifyAccessPaths() throws StandardException\n\t{\n\t\tResultSetNode retRSN;\n\t\tretRSN = super.modifyAccessPaths();\n\t\t/* We only want call addNewNodes() once */\n\t\tif (addNewNodesCalled)\n\t\t{\n\t\t\treturn retRSN;\n\t\t}\n\t\treturn addNewNodes();\n\t}\n\t/**\n\t * Add any new ResultSetNodes that are necessary to the tree.\n\t * We wait until after optimization to do this in order to\n\t * make it easier on the optimizer.\n\t *\n\t * @return (Potentially new) head of the ResultSetNode tree.\n\t *\n\t * @exception StandardException\t\tThrown on error\n\t */\n\tprivate ResultSetNode addNewNodes()\n\t\tthrows StandardException\n\t{\n\t\t/* Only call addNewNodes() once */\n\t\tif (addNewNodesCalled)\n\t\t{\n\t\t\treturn this;\n\t\t}\n\t\taddNewNodesCalled = true;\n        ResultSetNode treeTop = this;\n        for (int i = 0; i < qec.size(); i++) {\n            final OrderByList obl = qec.getOrderByList(i);\n            if(obl != null) {\n                // Generate an order by node on top of the intersect/except\n                treeTop = new OrderByNode(\n                        treeTop,\n                        obl,\n                        tableProperties,\n                        getContextManager());\n            }\n            final ValueNode offset = qec.getOffset(i);\n            final ValueNode fetchFirst = qec.getFetchFirst(i);\n            if (offset != null || fetchFirst != null) {\n                ResultColumnList newRcl =\n                    treeTop.getResultColumns().copyListAndObjects();\n                newRcl.genVirtualColumnNodes(\n                    treeTop, treeTop.getResultColumns());\n                treeTop = new RowCountNode(\n                        treeTop,\n                        newRcl,\n                        offset,\n                        fetchFirst,\n                        qec.getHasJDBCLimitClause()[i].booleanValue(),\n                        getContextManager());\n            }\n        }\n        return treeTop;\n    } // end of addNewNodes\n    /**\n\t * Generate the code.\n\t *\n\t * @exception StandardException\t\tThrown on error\n     */\n    @Override\n    void generate( ActivationClassBuilder acb, MethodBuilder mb)\n        throws StandardException\n\t{\n\t\t/* Get the next ResultSet #, so that we can number this ResultSetNode, its\n\t\t * ResultColumnList and ResultSet.\n\t\t */\n\t\tassignResultSetNumber();\n\t\t// Get our final cost estimate based on the child estimates.\n\t\tsetCostEstimate( getFinalCostEstimate() );\n\t\t// build up the tree.\n        /* Generate the SetOpResultSet. Arguments:\n         *  1) expression for left child ResultSet\n         *  2) expression for right child ResultSet\n         *  3) activation\n         *  4) resultSetNumber\n         *  5) estimated row count\n         *  6) estimated cost\n         *  7) opType\n         *  8) all\n         *  9) intermediateOrderByColumns saved object index\n         *  10) intermediateOrderByDirection saved object index\n         *  11) intermediateOrderByNullsLow saved object index\n         */\n\t\tacb.pushGetResultSetFactoryExpression(mb); // instance for getSetOpResultSet\n\t\tgetLeftResultSet().generate( acb, mb);\n\t\tgetRightResultSet().generate( acb, mb);\n\t\tacb.pushThisAsActivation(mb);\n\t\tmb.push(getResultSetNumber());\n        mb.push( getCostEstimate().getEstimatedRowCount());\n        mb.push( getCostEstimate().getEstimatedCost());\n        mb.push( getOpType());\n        mb.push( all);\n        mb.push( getCompilerContext().addSavedObject( intermediateOrderByColumns));\n        mb.push( getCompilerContext().addSavedObject( intermediateOrderByDirection));\n        mb.push( getCompilerContext().addSavedObject( intermediateOrderByNullsLow));\n\t\tmb.callMethod(VMOpcode.INVOKEINTERFACE,\n                      (String) null,\n                      \"getSetOpResultSet\",\n                      ClassName.NoPutResultSet, 11);\n\t} // end of generate\n\t/**\n\t * @see ResultSetNode#getFinalCostEstimate\n\t *\n\t * Get the final CostEstimate for this IntersectOrExceptNode.\n\t *\n\t * @return\tThe final CostEstimate for this IntersectOrExceptNode,\n\t *  which is the sum of the two child costs.  The final number of\n\t *  rows depends on whether this is an INTERSECT or EXCEPT (see\n\t *  getRowCountEstimate() in this class for more).\n\t */\n<fim_suffix>    @Override\n    CostEstimate getFinalCostEstimate()\n\t\tthrows StandardException\n\t{\n\t\tif (getCandidateFinalCostEstimate() != null)\n        {\n\t\t\treturn getCandidateFinalCostEstimate();\n        }\n\t\tCostEstimate leftCE = leftResultSet.getFinalCostEstimate();\n\t\tCostEstimate rightCE = rightResultSet.getFinalCostEstimate();\n\t\tsetCandidateFinalCostEstimate( getNewCostEstimate() );\n\t\tgetCandidateFinalCostEstimate().setCost(\n\t\t\tleftCE.getEstimatedCost() + rightCE.getEstimatedCost(),\n\t\t\tgetRowCountEstimate(leftCE.rowCount(), rightCE.rowCount()),\n\t\t\tgetSingleScanRowCountEstimate(leftCE.singleScanRowCount(),\n\t\t\t\trightCE.singleScanRowCount()));\n\t\treturn getCandidateFinalCostEstimate();\n\t}<fim_middle>// function below has no smell\n"}