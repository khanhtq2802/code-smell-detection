{"text": "<fim_prefix>        return CLASS_FOR_NAME;\n    }\n    private static final class FirstNotNullFunction<T, V> implements Function<T, V>\n    {\n        private static final long serialVersionUID = 1L;\n        private final Function<T, V>[] functions;\n        private FirstNotNullFunction(Function<T, V>... functions)\n        {\n            this.functions = functions;\n        }\n        @Override\n        public V valueOf(T object)\n        {\n            for (Function<T, V> function : this.functions)\n            {\n                V result = function.valueOf(object);\n                if (result != null)\n                {\n                    return result;\n                }\n            }\n            return null;\n        }\n    }\n    private static final class FirstNotEmptyStringFunction<T> implements Function<T, String>\n    {\n        private static final long serialVersionUID = 1L;\n        private final Function<T, String>[] functions;\n        private FirstNotEmptyStringFunction(Function<T, String>... functions)\n        {\n            this.functions = functions;\n        }\n        @Override\n        public String valueOf(T object)\n        {\n            for (Function<T, String> function : this.functions)\n            {\n                String result = function.valueOf(object);\n                if (StringIterate.notEmpty(result))\n                {\n                    return result;\n                }\n            }\n            return null;\n        }\n    }\n    private static final class FirstNotEmptyCollectionFunction<T1, T2, I extends Iterable<T2>> implements Function<T1, I>\n    {\n        private static final long serialVersionUID = 1L;\n        private final Function<T1, I>[] functions;\n        private FirstNotEmptyCollectionFunction(Function<T1, I>[] functions)\n        {\n            this.functions = functions;\n        }\n        @Override\n        public I valueOf(T1 object)\n        {\n            for (Function<T1, I> function : this.functions)\n            {\n                I result = function.valueOf(object);\n                if (Iterate.notEmpty(result))\n                {\n                    return result;\n                }\n            }\n            return null;\n        }\n    }\n    private static final class SynchronizedFunction<T, V> implements Function<T, V>\n    {\n        private static final long serialVersionUID = 1L;\n        private final Function<T, V> function;\n        private SynchronizedFunction(Function<T, V> function)\n        {\n            this.function = function;\n        }\n        @Override\n        public V valueOf(T each)\n        {\n            synchronized (each)\n            {\n                return this.function.valueOf(each);\n            }\n        }\n    }\n    public static <T1, T2, T3> FunctionChain<T1, T2, T3> chain(Function<T1, T2> function1, Function<? super T2, T3> function2)\n    {\n        return new FunctionChain<>(function1, function2);\n    }\n    public static <T1, T2> BooleanFunctionChain<T1, T2> chainBoolean(Function<T1, T2> function1, BooleanFunction<? super T2> function2)\n    {\n        return new BooleanFunctionChain<>(function1, function2);\n    }\n    public static <T1, T2> ByteFunctionChain<T1, T2> chainByte(Function<T1, T2> function1, ByteFunction<? super T2> function2)\n    {\n        return new ByteFunctionChain<>(function1, function2);\n    }\n    public static <T1, T2> CharFunctionChain<T1, T2> chainChar(Function<T1, T2> function1, CharFunction<? super T2> function2)\n    {\n        return new CharFunctionChain<>(function1, function2);\n    }\n    public static <T1, T2> DoubleFunctionChain<T1, T2> chainDouble(Function<T1, T2> function1, DoubleFunction<? super T2> function2)\n    {\n        return new DoubleFunctionChain<>(function1, function2);\n    }\n    public static <T1, T2> FloatFunctionChain<T1, T2> chainFloat(Function<T1, T2> function1, FloatFunction<? super T2> function2)\n    {\n        return new FloatFunctionChain<>(function1, function2);\n    }\n    public static <T1, T2> IntFunctionChain<T1, T2> chainInt(Function<T1, T2> function1, IntFunction<? super T2> function2)\n    {\n        return new IntFunctionChain<>(function1, function2);\n    }\n    public static <T1, T2> LongFunctionChain<T1, T2> chainLong(Function<T1, T2> function1, LongFunction<? super T2> function2)\n    {\n        return new LongFunctionChain<>(function1, function2);\n    }\n    public static <T1, T2> ShortFunctionChain<T1, T2> chainShort(Function<T1, T2> function1, ShortFunction<? super T2> function2)\n    {\n        return new ShortFunctionChain<>(function1, function2);\n    }\n    private static class DoublePassThruFunction implements Function<Double, Double>, DoubleFunction<Double>\n    {\n        private static final long serialVersionUID = 1L;\n        @Override\n        public double doubleValueOf(Double each)\n        {\n            return each.doubleValue();\n        }\n        @Override\n        public Double valueOf(Double each)\n        {\n            return each;\n        }\n        @Override\n        public String toString()\n        {\n            return DoublePassThruFunction.class.getSimpleName();\n        }\n    }\n    private static class IntegerPassThruFunction implements Function<Integer, Integer>, IntFunction<Integer>\n    {\n        private static final long serialVersionUID = 1L;\n        @Override\n        public int intValueOf(Integer each)\n        {\n            return each.intValue();\n        }\n        @Override\n        public Integer valueOf(Integer each)\n        {\n            return each;\n        }\n        @Override\n        public String toString()\n        {\n            return IntegerPassThruFunction.class.getSimpleName();\n        }\n    }\n    private static class LongPassThruFunction implements Function<Long, Long>, LongFunction<Long>\n    {\n        private static final long serialVersionUID = 1L;\n        @Override\n        public long longValueOf(Long each)\n        {\n            return each.longValue();\n        }\n        @Override\n        public Long valueOf(Long each)\n        {\n            return each;\n        }\n        @Override\n        public String toString()\n        {\n            return LongPassThruFunction.class.getSimpleName();\n        }\n    }\n    private static final class DefaultFunction<T, V> implements Function<T, V>\n    {\n        private static final long serialVersionUID = 1L;\n        private final Function<? super T, ? extends V> function;\n        private final V defaultValue;\n        private DefaultFunction(Function<? super T, ? extends V> newFunction, V newDefaultValue)\n        {\n            this.function = newFunction;\n            this.defaultValue = newDefaultValue;\n        }\n        @Override\n        public V valueOf(T anObject)\n        {\n            V returnValue = this.function.valueOf(anObject);\n            if (returnValue == null)\n            {\n                return this.defaultValue;\n            }\n            return returnValue;\n        }\n    }\n    private static final class NullSafeFunction<T, V> implements Function<T, V>\n    {\n        private static final long serialVersionUID = 1L;\n        private final Function<? super T, ? extends V> function;\n        private final V nullValue;\n        private NullSafeFunction(Function<? super T, ? extends V> function, V nullValue)\n        {\n            this.function = function;\n            this.nullValue = nullValue;\n        }\n        @Override\n        public V valueOf(T object)\n        {\n            return object == null ? this.nullValue : this.function.valueOf(object);\n        }\n    }\n    public static <T, V1, V2> Function<T, Pair<V1, V2>> pair(\n            Function<? super T, V1> function1,\n            Function<? super T, V2> function2)\n    {\n        return t -> Tuples.pair(function1.valueOf(t), function2.valueOf(t));\n    }\n    /**\n     * @return A function that gets the key out of a {@link java.util.Map.Entry}\n     */\n    @SuppressWarnings(\"UnnecessaryFullyQualifiedName\")\n    public static <K> Function<Map.Entry<K, ?>, K> getKeyFunction()\n    {\n        return (Function<Map.Entry<K, ?>, K>) MAP_KEY_FUNCTION;\n    }\n    /**\n     * @return A function that gets the value out of a {@link java.util.Map.Entry}\n     */\n    @SuppressWarnings(\"UnnecessaryFullyQualifiedName\")\n    public static <V> Function<Map.Entry<?, V>, V> getValueFunction()\n    {\n        return (Function<Map.Entry<?, V>, V>) MAP_VALUE_FUNCTION;\n    }\n<fim_suffix>    private static class MapKeyFunction<K> implements Function<Map.Entry<K, ?>, K>\n    {\n        private static final long serialVersionUID = 1L;\n        @Override\n        public K valueOf(Map.Entry<K, ?> entry)\n        {\n            return entry.getKey();\n        }\n    }<fim_middle>// class below has no smell\n"}