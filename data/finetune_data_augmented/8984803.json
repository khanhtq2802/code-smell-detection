{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.lucene.index;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.regex.Matcher;\nimport org.apache.lucene.codecs.Codec;\nimport org.apache.lucene.search.Sort;\nimport org.apache.lucene.store.Directory;\nimport org.apache.lucene.store.TrackingDirectoryWrapper;\nimport org.apache.lucene.util.StringHelper;\nimport org.apache.lucene.util.Version;\n/**\n * Information about a segment such as its name, directory, and files related\n * to the segment.\n *\n * @lucene.experimental\n */\npublic final class SegmentInfo {\n  // TODO: remove these from this class, for now this is the representation\n  /** Used by some member fields to mean not present (e.g.,\n   *  norms, deletions). */\n  public static final int NO = -1;          // e.g. no norms; no deletes;\n  /** Used by some member fields to mean present (e.g.,\n   *  norms, deletions). */\n  public static final int YES = 1;          // e.g. have norms; have deletes;\n  /** Unique segment name in the directory. */\n  public final String name;\n  private int maxDoc;         // number of docs in seg\n  /** Where this segment resides. */\n  public final Directory dir;\n  private boolean isCompoundFile;\n  /** Id that uniquely identifies this segment. */\n  private final byte[] id;\n  private Codec codec;\n  private Map<String,String> diagnostics;\n  private final Map<String,String> attributes;\n  private final Sort indexSort;\n  // Tracks the Lucene version this segment was created with, since 3.1. Null\n  // indicates an older than 3.0 index, and it's used to detect a too old index.\n  // The format expected is \"x.y\" - \"2.x\" for pre-3.0 indexes (or null), and\n  // specific versions afterwards (\"3.0.0\", \"3.1.0\" etc.).\n  // see o.a.l.util.Version.\n  private final Version version;\n  // Tracks the minimum version that contributed documents to a segment. For\n  // flush segments, that is the version that wrote it. For merged segments,\n  // this is the minimum minVersion of all the segments that have been merged\n  // into this segment\n  Version minVersion;\n  void setDiagnostics(Map<String, String> diagnostics) {\n    this.diagnostics = Objects.requireNonNull(diagnostics);\n  }\n  /** Returns diagnostics saved into the segment when it was\n   *  written. The map is immutable. */\n  public Map<String, String> getDiagnostics() {\n    return diagnostics;\n  }\n  /**\n   * Construct a new complete SegmentInfo instance from input.\n   * <p>Note: this is public only to allow access from\n   * the codecs package.</p>\n   */\n  public SegmentInfo(Directory dir, Version version, Version minVersion, String name, int maxDoc,\n                     boolean isCompoundFile, Codec codec, Map<String,String> diagnostics,\n                     byte[] id, Map<String,String> attributes, Sort indexSort) {\n    assert !(dir instanceof TrackingDirectoryWrapper);\n    this.dir = Objects.requireNonNull(dir);\n    this.version = Objects.requireNonNull(version);\n    this.minVersion = minVersion;\n    this.name = Objects.requireNonNull(name);\n    this.maxDoc = maxDoc;\n    this.isCompoundFile = isCompoundFile;\n    this.codec = codec;\n    this.diagnostics = Objects.requireNonNull(diagnostics);\n    this.id = id;\n    if (id.length != StringHelper.ID_LENGTH) {\n      throw new IllegalArgumentException(\"invalid id: \" + Arrays.toString(id));\n    }\n    this.attributes = Objects.requireNonNull(attributes);\n    this.indexSort = indexSort;\n  }\n  /**\n   * Mark whether this segment is stored as a compound file.\n   *\n   * @param isCompoundFile true if this is a compound file;\n   * else, false\n   */\n  void setUseCompoundFile(boolean isCompoundFile) {\n    this.isCompoundFile = isCompoundFile;\n  }\n  /**\n   * Returns true if this segment is stored as a compound\n   * file; else, false.\n   */\n  public boolean getUseCompoundFile() {\n    return isCompoundFile;\n  }\n  /** Can only be called once. */\n  public void setCodec(Codec codec) {\n    assert this.codec == null;\n    if (codec == null) {\n      throw new IllegalArgumentException(\"codec must be non-null\");\n    }\n    this.codec = codec;\n  }\n  /** Return {@link Codec} that wrote this segment. */\n  public Codec getCodec() {\n    return codec;\n  }\n  /** Returns number of documents in this segment (deletions\n   *  are not taken into account). */\n<fim_suffix>  public int maxDoc() {\n    if (this.maxDoc == -1) {\n      throw new IllegalStateException(\"maxDoc isn't set yet\");\n    }\n    return maxDoc;\n  }\n  // NOTE: leave package private\n  void setMaxDoc(int maxDoc) {\n    if (this.maxDoc != -1) {\n      throw new IllegalStateException(\"maxDoc was already set: this.maxDoc=\" + this.maxDoc + \" vs maxDoc=\" + maxDoc);\n    }\n    this.maxDoc = maxDoc;\n  }\n  /** Return all files referenced by this SegmentInfo. */\n  public Set<String> files() {\n    if (setFiles == null) {\n      throw new IllegalStateException(\"files were not computed yet; segment=\" + name + \" maxDoc=\" + maxDoc);\n    }\n    return Collections.unmodifiableSet(setFiles);\n  }\n  @Override\n  public String toString() {\n    return toString(0);\n  }\n  /** Used for debugging.  Format may suddenly change.\n   *\n   *  <p>Current format looks like\n   *  <code>_a(3.1):c45/4:[sorter=&lt;long: \"timestamp\"&gt;!]</code>, which means\n   *  the segment's name is <code>_a</code>; it was created with Lucene 3.1 (or\n   *  '?' if it's unknown); it's using compound file\n   *  format (would be <code>C</code> if not compound); it\n   *  has 45 documents; it has 4 deletions (this part is\n   *  left off when there are no deletions); it is sorted by the timestamp field\n   *  in descending order (this part is omitted for unsorted segments).</p>\n   */\n  public String toString(int delCount) {\n    StringBuilder s = new StringBuilder();\n    s.append(name).append('(').append(version == null ? \"?\" : version).append(')').append(':');\n    char cfs = getUseCompoundFile() ? 'c' : 'C';\n    s.append(cfs);\n    s.append(maxDoc);\n    if (delCount != 0) {\n      s.append('/').append(delCount);\n    }\n    if (indexSort != null) {\n      s.append(\":[indexSort=\");\n      s.append(indexSort);\n      s.append(']');\n    }\n    if (!diagnostics.isEmpty()) {\n      s.append(\":[diagnostics=\");\n      s.append(diagnostics.toString());\n      s.append(']');\n    }\n    if (!attributes.isEmpty()) {\n      s.append(\":[attributes=\");\n      s.append(attributes.toString());\n      s.append(']');\n    }\n    return s.toString();\n  }\n  /** We consider another SegmentInfo instance equal if it\n   *  has the same dir and same name. */\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj) return true;\n    if (obj instanceof SegmentInfo) {\n      final SegmentInfo other = (SegmentInfo) obj;\n      return other.dir == dir && other.name.equals(name);\n    } else {\n      return false;\n    }\n  }\n  @Override\n  public int hashCode() {\n    return dir.hashCode() + name.hashCode();\n  }\n  /** Returns the version of the code which wrote the segment.\n   */\n  public Version getVersion() {\n    return version;\n  }\n  /**<fim_middle>// function below has no smell\n"}