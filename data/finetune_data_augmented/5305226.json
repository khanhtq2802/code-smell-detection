{"text": "<fim_prefix>                    _loc.get(\"closed\"), _closedException).setFatal(true);\n                e.setCause(_closedException);\n                throw e;\n            }\n        }\n    }\n    @Override\n    public void assertActiveTransaction() {\n        if ((_flags & FLAG_ACTIVE) == 0)\n            throw new NoTransactionException(_loc.get(\"not-active\"));\n    }\n    /**\n     * Throw exception if a transaction-related operation is attempted and\n     * no transaction is active.\n     */\n    private void assertTransactionOperation() {\n        if ((_flags & FLAG_ACTIVE) == 0)\n            throw new InvalidStateException(_loc.get(\"not-active\"));\n    }\n    @Override\n    public void assertNontransactionalRead() {\n        if ((_flags & FLAG_ACTIVE) == 0 && !_nontransRead)\n            throw new InvalidStateException(_loc.get(\"non-trans-read\"));\n    }\n    @Override\n    public void assertWriteOperation() {\n        if ((_flags & FLAG_ACTIVE) == 0 && (!_nontransWrite\n            || (_autoDetach & DETACH_NONTXREAD) != 0))\n            throw new NoTransactionException(_loc.get(\"write-operation\"));\n    }\n    /**\n     * Return an object not found exception containing nested exceptions\n     * for all of the given failed objects.\n     */\n    private static ObjectNotFoundException newObjectNotFoundException\n        (Collection failed) {\n        Throwable[] t = new Throwable[failed.size()];\n        int idx = 0;\n        for (Iterator<?> itr = failed.iterator(); itr.hasNext(); idx++)\n            t[idx] = new ObjectNotFoundException(itr.next());\n        return new ObjectNotFoundException(failed, t);\n    }\n    ////////////////////////////////\n    // FindCallbacks implementation\n    ////////////////////////////////\n    @Override\n    public Object processArgument(Object oid) {\n        return oid;\n    }\n    @Override\n    public Object processReturn(Object oid, OpenJPAStateManager sm) {\n        return (sm == null) ? null : sm.getManagedInstance();\n    }\n    private void writeObject(ObjectOutputStream out) throws IOException {\n        assertOpen();\n        lock();\n        try {\n            if (isActive()) {\n                if (!getOptimistic())\n                    throw new InvalidStateException(\n                        _loc.get(\"cant-serialize-pessimistic-broker\"));\n                if (hasFlushed())\n                    throw new InvalidStateException(\n                        _loc.get(\"cant-serialize-flushed-broker\"));\n                if (hasConnection())\n                    throw new InvalidStateException(\n                        _loc.get(\"cant-serialize-connected-broker\"));\n            }\n            try {\n                _isSerializing = true;\n                out.writeObject(_factory.getPoolKey());\n                out.defaultWriteObject();\n            } finally {\n                _isSerializing = false;\n            }\n        } finally {\n            unlock();\n        }\n    }\n    private void readObject(ObjectInputStream in)\n        throws ClassNotFoundException, IOException {\n        Object factoryKey = in.readObject();\n        AbstractBrokerFactory factory =\n            AbstractBrokerFactory.getPooledFactoryForKey(factoryKey);\n        // this needs to happen before defaultReadObject so that it's\n        // available for calls to broker.getConfiguration() during\n        // StateManager deserialization\n        _conf = factory.getConfiguration();\n        _repo = _conf.getMetaDataRepositoryInstance();\n        in.defaultReadObject();\n        factory.initializeBroker(_managed, _connRetainMode, this, true);\n        // re-initialize the lock if needed.\n        setMultithreaded(_multithreaded);\n        // force recreation of set\n        _operatingDirty = true;\n        initializeOperatingSet();\n        if (isActive() && _runtime instanceof LocalManagedRuntime)\n            ((LocalManagedRuntime) _runtime).begin();\n    }\n    /**\n     * Whether or not this broker is in the midst of being serialized.\n     *\n     * @since 1.1.0\n     */\n    boolean isSerializing() {\n        return _isSerializing;\n    }\n    /**\n     * @return The value of openjpa.ConnectionFactoryProperties.PrintParameters. Default is false.\n     */\n    public boolean getPrintParameters() {\n        return _printParameters;\n    }\n    /**\n     * Transactional cache that holds soft refs to clean instances.\n     */\n<fim_suffix>    static class TransactionalCache\n        implements Set, Serializable {\n        private static final long serialVersionUID = 1L;\n        private final boolean _orderDirty;\n        private Set<StateManagerImpl> _dirty = null;\n        private Set<StateManagerImpl> _clean = null;\n        public TransactionalCache(boolean orderDirty) {\n            _orderDirty = orderDirty;\n        }\n        /**\n         * Return a copy of all transactional state managers.\n         */\n        public Collection copy() {\n            if (isEmpty()) {\n                // Transaction Listeners may add entities to the transaction.\n                return new LinkedHashSet();\n            }\n            // size may not be entirely accurate due to refs expiring, so\n            // manually copy each object; doesn't matter this way if size too\n            // big by some\n            Set copy = new LinkedHashSet(size());\n            if (_dirty != null)\n                for (Iterator<StateManagerImpl> itr = _dirty.iterator(); itr.hasNext();)\n                    copy.add(itr.next());\n            if (_clean != null)\n                for (Iterator<StateManagerImpl> itr = _clean.iterator(); itr.hasNext();)\n                    copy.add(itr.next());\n            return copy;\n        }\n        /**\n         * Return a copy of all dirty state managers.\n         */\n        public Collection copyDirty() {\n            if (_dirty == null || _dirty.isEmpty())\n                return Collections.EMPTY_SET;\n            return new LinkedHashSet<>(_dirty);\n        }\n        /**\n         * Transfer the given instance from the dirty cache to the clean cache.\n         */\n        public void flushed(StateManagerImpl sm) {\n            if (sm.isDirty() && _dirty != null && _dirty.remove(sm))\n                addCleanInternal(sm);\n        }\n        /**\n         * Add the given instance to the clean cache.\n         */\n        public void addClean(StateManagerImpl sm) {\n            if (addCleanInternal(sm) && _dirty != null)\n                _dirty.remove(sm);\n        }\n        private boolean addCleanInternal(StateManagerImpl sm) {\n            if (_clean == null)\n                _clean = new ReferenceHashSet(ReferenceStrength.SOFT);\n            return _clean.add(sm);\n        }\n        /**\n         * Add the given instance to the dirty cache.\n         */\n        public void addDirty(StateManagerImpl sm) {\n            if (_dirty == null) {\n                if (_orderDirty)\n                    _dirty = MapBackedSet.mapBackedSet(new LinkedMap());\n                else\n                    _dirty = new HashSet<>();\n            }\n            if (_dirty.add(sm))\n                removeCleanInternal(sm);\n        }\n        /**\n         * Remove the given instance from the cache.\n         */\n        public boolean remove(StateManagerImpl sm) {\n            return removeCleanInternal(sm)\n                || (_dirty != null && _dirty.remove(sm));\n        }\n        private boolean removeCleanInternal(StateManagerImpl sm) {\n            return _clean != null && _clean.remove(sm);\n        }\n        @Override\n        public Iterator iterator() {\n            IteratorChain chain = new IteratorChain();\n            if (_dirty != null && !_dirty.isEmpty())\n                chain.addIterator(_dirty.iterator());\n            if (_clean != null && !_clean.isEmpty())\n                chain.addIterator(_clean.iterator());\n            return chain;\n        }\n        @Override\n        public boolean contains(Object obj) {\n            return (_dirty != null && _dirty.contains(obj))\n                || (_clean != null && _clean.contains(obj));\n        }\n        @Override\n        public boolean containsAll(Collection coll) {\n            for (Iterator<?> itr = coll.iterator(); itr.hasNext();)\n                if (!contains(itr.next()))\n                    return false;\n            return true;\n        }\n        @Override\n        public void clear() {\n            if (_dirty != null)\n                _dirty = null;\n            if (_clean != null)\n                _clean = null;\n        }\n        @Override\n        public boolean isEmpty() {\n            return (_dirty == null || _dirty.isEmpty())\n                && (_clean == null || _clean.isEmpty());\n        }\n        @Override\n        public int size() {\n            int size = 0;\n            if (_dirty != null)\n                size += _dirty.size();\n            if (_clean != null)\n                size += _clean.size();\n            return size;\n        }\n        @Override\n        public boolean add(Object obj) {\n            throw new UnsupportedOperationException();\n        }\n        @Override\n        public boolean addAll(Collection coll) {\n            throw new UnsupportedOperationException();\n        }\n        @Override\n        public boolean remove(Object obj) {\n            throw new UnsupportedOperationException();\n        }\n        @Override\n        public boolean removeAll(Collection coll) {\n            throw new UnsupportedOperationException();\n        }\n        @Override\n        public boolean retainAll(Collection c) {\n            throw new UnsupportedOperationException();\n        }\n        @Override\n        public Object[] toArray() {\n            throw new UnsupportedOperationException();\n        }\n        @Override\n        public Object[] toArray(Object[] arr) {\n            throw new UnsupportedOperationException();\n        }\n    }<fim_middle>// class below has no smell\n"}