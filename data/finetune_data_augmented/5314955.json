{"text": "<fim_prefix>                getGraphicsState().getSoftMask());\n    }\n    // returns the non-stroking AWT Paint\n    private Paint getNonStrokingPaint() throws IOException\n    {\n        return applySoftMaskToPaint(\n                getPaint(getGraphicsState().getNonStrokingColor()),\n                getGraphicsState().getSoftMask());\n    }\n    // create a new stroke based on the current CTM and the current stroke\n    private BasicStroke getStroke()\n    {\n        PDGraphicsState state = getGraphicsState();\n        // apply the CTM\n        float lineWidth = transformWidth(state.getLineWidth());\n        // minimum line width as used by Adobe Reader\n        if (lineWidth < 0.25)\n        {\n            lineWidth = 0.25f;\n        }\n        PDLineDashPattern dashPattern = state.getLineDashPattern();\n        int phaseStart = dashPattern.getPhase();\n        float[] dashArray = dashPattern.getDashArray();\n        float scalingFactorX = new Matrix(xform).getScalingFactorX();\n        for (int i = 0; i < dashArray.length; ++i)\n        {\n            // apply the CTM\n            float w = transformWidth(dashArray[i]);\n            // minimum line dash width avoids JVM crash,\n            // see PDFBOX-2373, PDFBOX-2929, PDFBOX-3204, PDFBOX-3813\n            // also avoid 0 in array like \"[ 0 1000 ] 0 d\", see PDFBOX-3724\n            if (scalingFactorX < 0.5f)\n            {\n                // PDFBOX-4492\n                dashArray[i] = Math.max(w, 0.2f);\n            }\n            else\n            {\n                dashArray[i] = Math.max(w, 0.062f);\n            }\n        }\n        phaseStart = (int) transformWidth(phaseStart);\n        // empty dash array is illegal\n        // avoid also infinite and NaN values (PDFBOX-3360)\n        if (dashArray.length == 0 || Float.isInfinite(phaseStart) || Float.isNaN(phaseStart))\n        {\n            dashArray = null;\n        }\n        else\n        {\n            for (int i = 0; i < dashArray.length; ++i)\n            {\n                if (Float.isInfinite(dashArray[i]) || Float.isNaN(dashArray[i]))\n                {\n                    dashArray = null;\n                    break;\n                }\n            }\n        }\n        return new BasicStroke(lineWidth, state.getLineCap(), state.getLineJoin(),\n                               state.getMiterLimit(), dashArray, phaseStart);\n    }\n    @Override\n    public void strokePath() throws IOException\n    {\n        graphics.setComposite(getGraphicsState().getStrokingJavaComposite());\n        graphics.setPaint(getStrokingPaint());\n        graphics.setStroke(getStroke());\n        setClip();\n        //TODO bbox of shading pattern should be used here? (see fillPath)\n        if (isContentRendered())\n        {\n            graphics.draw(linePath);\n        }\n        linePath.reset();\n    }\n    @Override\n    public void fillPath(int windingRule) throws IOException\n    {\n        graphics.setComposite(getGraphicsState().getNonStrokingJavaComposite());\n        graphics.setPaint(getNonStrokingPaint());\n        setClip();\n        linePath.setWindingRule(windingRule);\n        // disable anti-aliasing for rectangular paths, this is a workaround to avoid small stripes\n        // which occur when solid fills are used to simulate piecewise gradients, see PDFBOX-2302\n        // note that we ignore paths with a width/height under 1 as these are fills used as strokes,\n        // see PDFBOX-1658 for an example\n        Rectangle2D bounds = linePath.getBounds2D();\n        boolean noAntiAlias = isRectangular(linePath) && bounds.getWidth() > 1 &&\n                                                         bounds.getHeight() > 1;\n        if (noAntiAlias)\n        {\n            graphics.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                                      RenderingHints.VALUE_ANTIALIAS_OFF);\n        }\n        Shape shape;\n        if (!(graphics.getPaint() instanceof Color))\n        {\n            // apply clip to path to avoid oversized device bounds in shading contexts (PDFBOX-2901)\n            Area area = new Area(linePath);\n            area.intersect(new Area(graphics.getClip()));\n            intersectShadingBBox(getGraphicsState().getNonStrokingColor(), area);\n            shape = area;\n        }\n        else\n        {\n            shape = linePath;\n        }\n        if (isContentRendered())\n        {\n            graphics.fill(shape);\n        }\n        linePath.reset();\n        if (noAntiAlias)\n        {\n            // JDK 1.7 has a bug where rendering hints are reset by the above call to\n            // the setRenderingHint method, so we re-set all hints, see PDFBOX-2302\n            setRenderingHints();\n        }\n    }\n    // checks whether this is a shading pattern and if yes,\n    // get the transformed BBox and intersect with current paint area\n    // need to do it here and not in shading getRaster() because it may have been rotated\n    private void intersectShadingBBox(PDColor color, Area area) throws IOException\n    {\n        if (color.getColorSpace() instanceof PDPattern)\n        {\n            PDColorSpace colorSpace = color.getColorSpace();\n            PDAbstractPattern pat = ((PDPattern) colorSpace).getPattern(color);\n            if (pat instanceof PDShadingPattern)\n            {\n                PDShading shading = ((PDShadingPattern) pat).getShading();\n                PDRectangle bbox = shading.getBBox();\n                if (bbox != null)\n                {\n                    Matrix m = Matrix.concatenate(getInitialMatrix(), pat.getMatrix());\n                    Area bboxArea = new Area(bbox.transform(m));\n                    area.intersect(bboxArea);\n                }\n            }\n        }\n    }\n    /**\n     * Returns true if the given path is rectangular.\n     */\n    private boolean isRectangular(GeneralPath path)\n    {\n        PathIterator iter = path.getPathIterator(null);\n        double[] coords = new double[6];\n        int count = 0;\n        int[] xs = new int[4];\n        int[] ys = new int[4];\n        while (!iter.isDone())\n        {\n            switch(iter.currentSegment(coords))\n            {\n                case PathIterator.SEG_MOVETO:\n                    if (count == 0)\n                    {\n                        xs[count] = (int)Math.floor(coords[0]);\n                        ys[count] = (int)Math.floor(coords[1]);\n                    }\n                    else\n                    {\n                        return false;\n                    }\n                    count++;\n                    break;\n                case PathIterator.SEG_LINETO:\n                    if (count < 4)\n                    {\n                        xs[count] = (int)Math.floor(coords[0]);\n                        ys[count] = (int)Math.floor(coords[1]);\n                    }\n                    else\n                    {\n                        return false;\n                    }\n                    count++;\n                    break;\n                case PathIterator.SEG_CUBICTO:\n                    return false;\n                case PathIterator.SEG_CLOSE:\n                    break;\n            }\n            iter.next();\n        }\n        if (count == 4)\n        {\n            return xs[0] == xs[1] || xs[0] == xs[2] ||\n                   ys[0] == ys[1] || ys[0] == ys[3];\n        }\n        return false;\n    }\n    /**\n     * Fills and then strokes the path.\n     *\n     * @param windingRule The winding rule this path will use.\n     * @throws IOException If there is an IO error while filling the path.\n     */\n    @Override\n    public void fillAndStrokePath(int windingRule) throws IOException\n    {\n        // TODO can we avoid cloning the path?\n        GeneralPath path = (GeneralPath)linePath.clone();\n        fillPath(windingRule);\n        linePath = path;\n        strokePath();\n    }\n    @Override\n    public void clip(int windingRule)\n    {\n        // the clipping path will not be updated until the succeeding painting operator is called\n        clipWindingRule = windingRule;\n    }\n    @Override\n    public void moveTo(float x, float y)\n    {\n        linePath.moveTo(x, y);\n    }\n    @Override\n    public void lineTo(float x, float y)\n    {\n        linePath.lineTo(x, y);\n    }\n    @Override\n    public void curveTo(float x1, float y1, float x2, float y2, float x3, float y3)\n    {\n        linePath.curveTo(x1, y1, x2, y2, x3, y3);\n    }\n    @Override\n    public Point2D getCurrentPoint()\n    {\n        return linePath.getCurrentPoint();\n    }\n<fim_suffix>    @Override\n    public void closePath()\n    {\n        linePath.closePath();\n    }<fim_middle>// function below has no smell\n"}