{"text": "<fim_prefix>//\n//  ========================================================================\n//  Copyright (c) 1995-2019 Mort Bay Consulting Pty. Ltd.\n//  ------------------------------------------------------------------------\n//  All rights reserved. This program and the accompanying materials\n//  are made available under the terms of the Eclipse Public License v1.0\n//  and Apache License v2.0 which accompanies this distribution.\n//\n//      The Eclipse Public License is available at\n//      http://www.eclipse.org/legal/epl-v10.html\n//\n//      The Apache License v2.0 is available at\n//      http://www.opensource.org/licenses/apache2.0.php\n//\n//  You may elect to redistribute this code under either of these licenses.\n//  ========================================================================\n//\npackage org.eclipse.jetty.start;\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.FileVisitOption;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.PathMatcher;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.EnumSet;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Objects;\nimport org.eclipse.jetty.start.config.CommandLineConfigSource;\nimport org.eclipse.jetty.start.config.ConfigSource;\nimport org.eclipse.jetty.start.config.ConfigSources;\nimport org.eclipse.jetty.start.config.DirConfigSource;\nimport org.eclipse.jetty.start.config.JettyBaseConfigSource;\nimport org.eclipse.jetty.start.config.JettyHomeConfigSource;\n/**\n * File access for <code>${jetty.home}</code>, <code>${jetty.base}</code>, directories.\n * <p>\n * By default, both <code>${jetty.home}</code> and <code>${jetty.base}</code> are the same directory, but they can point at different directories.\n * <p>\n * The <code>${jetty.home}</code> directory is where the main Jetty binaries and default configuration is housed.\n * <p>\n * The <code>${jetty.base}</code> directory is where the execution specific configuration and webapps are obtained from.\n */\npublic class BaseHome\n{\n    public static class SearchDir\n    {\n        private Path dir;\n        private String name;\n        public SearchDir(String name)\n        {\n            this.name = name;\n        }\n        public Path getDir()\n        {\n            return dir;\n        }\n        public Path resolve(Path subpath)\n        {\n            return dir.resolve(subpath);\n        }\n        public Path resolve(String subpath)\n        {\n            return dir.resolve(FS.separators(subpath));\n        }\n        public SearchDir setDir(File path)\n        {\n            if (path != null)\n            {\n                return setDir(path.toPath());\n            }\n            return this;\n        }\n        public SearchDir setDir(Path path)\n        {\n            if (path != null)\n            {\n                this.dir = path.toAbsolutePath();\n            }\n            return this;\n        }\n        public SearchDir setDir(String path)\n        {\n            if (path != null)\n            {\n                return setDir(FS.toPath(path));\n            }\n            return this;\n        }\n        public String toShortForm(Path path)\n        {\n            Path relative = dir.relativize(path);\n            return String.format(\"${%s}%c%s\",name,File.separatorChar,relative.toString());\n        }\n    }\n    public static final String JETTY_BASE = \"jetty.base\";\n    public static final String JETTY_HOME = \"jetty.home\";\n    private final static EnumSet<FileVisitOption> SEARCH_VISIT_OPTIONS = EnumSet.of(FileVisitOption.FOLLOW_LINKS);\n    private final static int MAX_SEARCH_DEPTH = Integer.getInteger(\"org.eclipse.jetty.start.searchDepth\",10);\n    private final ConfigSources sources;\n    private final Path homeDir;\n    private final Path baseDir;\n<fim_suffix>    public BaseHome() throws IOException\n    {\n        this(new String[0]);\n    }\n    public BaseHome(String cmdLine[]) throws IOException\n    {\n        this(new CommandLineConfigSource(cmdLine));\n    }\n    public BaseHome(CommandLineConfigSource cmdLineSource) throws IOException\n    {\n        sources = new ConfigSources();\n        sources.add(cmdLineSource);\n        this.homeDir = cmdLineSource.getHomePath();\n        this.baseDir = cmdLineSource.getBasePath();\n        // TODO this is cyclic construction as start log uses BaseHome, but BaseHome constructor\n        // calls other constructors that log.   This appears to be a workable sequence.\n        StartLog.getInstance().initialize(this,cmdLineSource);\n        sources.add(new JettyBaseConfigSource(cmdLineSource.getBasePath()));\n        sources.add(new JettyHomeConfigSource(cmdLineSource.getHomePath()));\n        System.setProperty(JETTY_HOME,homeDir.toAbsolutePath().toString());\n        System.setProperty(JETTY_BASE,baseDir.toAbsolutePath().toString());\n    }\n    public BaseHome(ConfigSources sources)\n    {\n        this.sources = sources;\n        Path home = null;\n        Path base = null;\n        for (ConfigSource source : sources)\n        {\n            if (source instanceof CommandLineConfigSource)\n            {\n                CommandLineConfigSource cmdline = (CommandLineConfigSource)source;\n                home = cmdline.getHomePath();\n                base = cmdline.getBasePath();\n            }\n            else if (source instanceof JettyBaseConfigSource)\n            {\n                base = ((JettyBaseConfigSource)source).getDir();\n            }\n            else if (source instanceof JettyHomeConfigSource)\n            {\n                home = ((JettyHomeConfigSource)source).getDir();\n            }\n        }\n        Objects.requireNonNull(home,\"jetty.home cannot be null\");\n        this.homeDir = home;\n        this.baseDir = (base != null)?base:home;\n        System.setProperty(JETTY_HOME,homeDir.toAbsolutePath().toString());\n        System.setProperty(JETTY_BASE,baseDir.toAbsolutePath().toString());\n    }\n    public String getBase()\n    {\n        if (baseDir == null)\n        {\n            return null;\n        }\n        return baseDir.toString();\n    }\n    public Path getBasePath()\n    {\n        return baseDir;\n    }\n    /**\n     * Create a {@link Path} reference to some content in <code>\"${jetty.base}\"</code>\n     * \n     * @param path\n     *            the path to reference\n     * @return the file reference\n     */\n    public Path getBasePath(String path)\n    {\n        return baseDir.resolve(path).normalize().toAbsolutePath();\n    }\n    public ConfigSources getConfigSources()\n    {\n        return this.sources;\n    }\n    public String getHome()\n    {\n        return homeDir.toString();\n    }\n    public Path getHomePath()\n    {\n        return homeDir;\n    }\n    /**\n     * Get a specific path reference.\n     * <p>\n     * Path references are searched based on the config source search order.\n     * <ol>\n     * <li>If provided path is an absolute reference., and exists, return that reference</li>\n     * <li>If exists relative to <code>${jetty.base}</code>, return that reference</li>\n     * <li>If exists relative to and <code>include-jetty-dir</code> locations, return that reference</li>\n     * <li>If exists relative to <code>${jetty.home}</code>, return that reference</li>\n     * <li>Return standard {@link Path} reference obtained from {@link java.nio.file.FileSystem#getPath(String, String...)} (no exists check performed)</li>\n     * </ol>\n     * \n     * @param path\n     *            the path to get.\n     * @return the path reference.\n     */\n    public Path getPath(final String path)\n    {\n        Path apath = FS.toPath(path);\n        if (apath.isAbsolute())\n        {\n            if (FS.exists(apath))\n            {\n                return apath;\n            }\n        }\n        for (ConfigSource source : sources)\n        {\n            if (source instanceof DirConfigSource)\n            {\n                DirConfigSource dirsource = (DirConfigSource)source;\n                Path file = dirsource.getDir().resolve(apath);\n                if (FS.exists(file))\n                {\n                    return file;\n                }\n            }\n        }\n        // Finally, as an anonymous path\n        return FS.toPath(path);\n    }\n    /**\n     * Search specified Path with pattern and return hits\n     * \n     * @param dir\n     *            the path to a directory to start search from\n     * @param searchDepth\n     *            the number of directories deep to perform the search\n     * @param pattern\n     *            the raw pattern to use for the search (must be relative)\n     * @return the list of Paths found\n     * @throws IOException\n     *             if unable to search the path\n     */\n    public List<Path> getPaths(Path dir, int searchDepth, String pattern) throws IOException\n    {\n        if (PathMatchers.isAbsolute(pattern))\n        {<fim_middle>// function below has no smell\n"}