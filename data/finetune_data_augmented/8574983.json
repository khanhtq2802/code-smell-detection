{"text": "<fim_prefix>    // way to make it\n    // work for all implementations.\n    int length = kv.getLength();\n    out.writeInt(length);\n    out.write(kv.getBuffer(), kv.getOffset(), length);\n    return (long) length + Bytes.SIZEOF_INT;\n  }\n  static String bytesToHex(byte[] buf, int offset, int length) {\n    String bufferContents = buf != null ? Bytes.toStringBinary(buf, offset, length) : \"<null>\";\n    return \", KeyValueBytesHex=\" + bufferContents + \", offset=\" + offset\n        + \", length=\" + length;\n  }\n  static void checkKeyValueBytes(byte[] buf, int offset, int length, boolean withTags) {\n    if (buf == null) {\n      throw new IllegalArgumentException(\"Invalid to have null \" +\n          \"byte array in KeyValue.\");\n    }\n    int pos = offset, endOffset = offset + length;\n    // check the key\n    if (pos + Bytes.SIZEOF_INT > endOffset) {\n      throw new IllegalArgumentException(\n          \"Overflow when reading key length at position=\" + pos + bytesToHex(buf, offset, length));\n    }\n    int keyLen = Bytes.toInt(buf, pos, Bytes.SIZEOF_INT);\n    pos += Bytes.SIZEOF_INT;\n    if (keyLen <= 0 || pos + keyLen > endOffset) {\n      throw new IllegalArgumentException(\n          \"Invalid key length in KeyValue. keyLength=\" + keyLen + bytesToHex(buf, offset, length));\n    }\n    // check the value\n    if (pos + Bytes.SIZEOF_INT > endOffset) {\n      throw new IllegalArgumentException(\"Overflow when reading value length at position=\" + pos\n          + bytesToHex(buf, offset, length));\n    }\n    int valLen = Bytes.toInt(buf, pos, Bytes.SIZEOF_INT);\n    pos += Bytes.SIZEOF_INT;\n    if (valLen < 0 || pos + valLen > endOffset) {\n      throw new IllegalArgumentException(\"Invalid value length in KeyValue, valueLength=\" + valLen\n          + bytesToHex(buf, offset, length));\n    }\n    // check the row\n    if (pos + Bytes.SIZEOF_SHORT > endOffset) {\n      throw new IllegalArgumentException(\n          \"Overflow when reading row length at position=\" + pos + bytesToHex(buf, offset, length));\n    }\n    short rowLen = Bytes.toShort(buf, pos, Bytes.SIZEOF_SHORT);\n    pos += Bytes.SIZEOF_SHORT;\n    if (rowLen < 0 || pos + rowLen > endOffset) {\n      throw new IllegalArgumentException(\n          \"Invalid row length in KeyValue, rowLength=\" + rowLen + bytesToHex(buf, offset, length));\n    }\n    pos += rowLen;\n    // check the family\n    if (pos + Bytes.SIZEOF_BYTE > endOffset) {\n      throw new IllegalArgumentException(\"Overflow when reading family length at position=\" + pos\n          + bytesToHex(buf, offset, length));\n    }\n    int familyLen = buf[pos];\n    pos += Bytes.SIZEOF_BYTE;\n    if (familyLen < 0 || pos + familyLen > endOffset) {\n      throw new IllegalArgumentException(\"Invalid family length in KeyValue, familyLength=\"\n          + familyLen + bytesToHex(buf, offset, length));\n    }\n    pos += familyLen;\n    // check the qualifier\n    int qualifierLen = keyLen - Bytes.SIZEOF_SHORT - rowLen - Bytes.SIZEOF_BYTE - familyLen\n        - Bytes.SIZEOF_LONG - Bytes.SIZEOF_BYTE;\n    if (qualifierLen < 0 || pos + qualifierLen > endOffset) {\n      throw new IllegalArgumentException(\"Invalid qualifier length in KeyValue, qualifierLen=\"\n          + qualifierLen + bytesToHex(buf, offset, length));\n    }\n    pos += qualifierLen;\n    // check the timestamp\n    if (pos + Bytes.SIZEOF_LONG > endOffset) {\n      throw new IllegalArgumentException(\n          \"Overflow when reading timestamp at position=\" + pos + bytesToHex(buf, offset, length));\n    }\n    long timestamp = Bytes.toLong(buf, pos, Bytes.SIZEOF_LONG);\n    if (timestamp < 0) {\n      throw new IllegalArgumentException(\n          \"Timestamp cannot be negative, ts=\" + timestamp + bytesToHex(buf, offset, length));\n    }\n    pos += Bytes.SIZEOF_LONG;\n    // check the type\n    if (pos + Bytes.SIZEOF_BYTE > endOffset) {\n      throw new IllegalArgumentException(\n          \"Overflow when reading type at position=\" + pos + bytesToHex(buf, offset, length));\n    }\n    byte type = buf[pos];\n    if (!Type.isValidType(type)) {\n      throw new IllegalArgumentException(\n          \"Invalid type in KeyValue, type=\" + type + bytesToHex(buf, offset, length));\n    }\n    pos += Bytes.SIZEOF_BYTE;\n    // check the value\n    if (pos + valLen > endOffset) {\n      throw new IllegalArgumentException(\n          \"Overflow when reading value part at position=\" + pos + bytesToHex(buf, offset, length));\n    }\n    pos += valLen;\n    // check the tags\n    if (withTags) {\n      if (pos == endOffset) {\n        // withTags is true but no tag in the cell.\n        return;\n      }\n      if (pos + Bytes.SIZEOF_SHORT > endOffset) {\n        throw new IllegalArgumentException(\"Overflow when reading tags length at position=\" + pos\n            + bytesToHex(buf, offset, length));\n      }\n      short tagsLen = Bytes.toShort(buf, pos);\n      pos += Bytes.SIZEOF_SHORT;\n      if (tagsLen < 0 || pos + tagsLen > endOffset) {\n        throw new IllegalArgumentException(\"Invalid tags length in KeyValue at position=\"\n            + (pos - Bytes.SIZEOF_SHORT) + bytesToHex(buf, offset, length));\n      }\n      int tagsEndOffset = pos + tagsLen;\n      for (; pos < tagsEndOffset;) {\n        if (pos + Tag.TAG_LENGTH_SIZE > endOffset) {\n          throw new IllegalArgumentException(\"Overflow when reading tag length at position=\" + pos\n              + bytesToHex(buf, offset, length));\n        }\n        short tagLen = Bytes.toShort(buf, pos);\n        pos += Tag.TAG_LENGTH_SIZE;\n        // tagLen contains one byte tag type, so must be not less than 1.\n        if (tagLen < 1 || pos + tagLen > endOffset) {\n          throw new IllegalArgumentException(\n              \"Invalid tag length at position=\" + (pos - Tag.TAG_LENGTH_SIZE) + \", tagLength=\"\n                  + tagLen + bytesToHex(buf, offset, length));\n        }\n        pos += tagLen;\n      }\n    }\n    if (pos != endOffset) {\n      throw new IllegalArgumentException(\"Some redundant bytes in KeyValue's buffer, startOffset=\"\n          + pos + \", endOffset=\" + endOffset + bytesToHex(buf, offset, length));\n    }\n  }\n  /**\n   * Create a KeyValue reading from the raw InputStream. Named\n   * <code>createKeyValueFromInputStream</code> so doesn't clash with {@link #create(DataInput)}\n   * @param in inputStream to read.\n   * @param withTags whether the keyvalue should include tags are not\n   * @return Created KeyValue OR if we find a length of zero, we will return null which can be\n   *         useful marking a stream as done.\n   * @throws IOException\n   */\n  public static KeyValue createKeyValueFromInputStream(InputStream in, boolean withTags)\n      throws IOException {\n    byte[] intBytes = new byte[Bytes.SIZEOF_INT];\n    int bytesRead = 0;\n    while (bytesRead < intBytes.length) {\n      int n = in.read(intBytes, bytesRead, intBytes.length - bytesRead);\n      if (n < 0) {\n        if (bytesRead == 0) {\n          throw new EOFException();\n        }\n        throw new IOException(\"Failed read of int, read \" + bytesRead + \" bytes\");\n      }\n      bytesRead += n;\n    }\n    byte[] bytes = new byte[Bytes.toInt(intBytes)];\n    IOUtils.readFully(in, bytes, 0, bytes.length);\n    return withTags ? new KeyValue(bytes, 0, bytes.length)\n        : new NoTagsKeyValue(bytes, 0, bytes.length);\n  }\n  /**\n   * @param b\n   * @return A KeyValue made of a byte array that holds the key-only part.\n   *         Needed to convert hfile index members to KeyValues.\n   */\n  public static KeyValue createKeyValueFromKey(final byte[] b) {\n    return createKeyValueFromKey(b, 0, b.length);\n  }\n  /**\n   * @param bb\n   * @return A KeyValue made of a byte buffer that holds the key-only part.\n   *         Needed to convert hfile index members to KeyValues.\n   */\n<fim_suffix>  public static KeyValue createKeyValueFromKey(final ByteBuffer bb) {\n    return createKeyValueFromKey(bb.array(), bb.arrayOffset(), bb.limit());\n  }<fim_middle>// function below has no smell\n"}