{"text": "<fim_prefix>      monitorService.shutdown();\n      try {\n        monitorService.awaitTermination(10, TimeUnit.SECONDS);\n      } catch (InterruptedException e) {\n        logger.error(\"Interrupted while waiting for monitor service to stop\");\n      }\n      if (!monitorService.isTerminated()) {\n        monitorService.shutdownNow();\n        try {\n          while (!monitorService.isTerminated()) {\n            monitorService.awaitTermination(10, TimeUnit.SECONDS);\n          }\n        } catch (InterruptedException e) {\n          logger.error(\"Interrupted while waiting for monitor service to stop\");\n        }\n      }\n    }\n    for (final Entry<LifecycleAware, Supervisoree> entry : supervisedProcesses.entrySet()) {\n      if (entry.getKey().getLifecycleState().equals(LifecycleState.START)) {\n        entry.getValue().status.desiredState = LifecycleState.STOP;\n        entry.getKey().stop();\n      }\n    }\n    /* If we've failed, preserve the error state. */\n    if (lifecycleState.equals(LifecycleState.START)) {\n      lifecycleState = LifecycleState.STOP;\n    }\n    supervisedProcesses.clear();\n    monitorFutures.clear();\n    logger.debug(\"Lifecycle supervisor stopped\");\n  }\n  public synchronized void fail() {\n    lifecycleState = LifecycleState.ERROR;\n  }\n  public synchronized void supervise(LifecycleAware lifecycleAware,\n      SupervisorPolicy policy, LifecycleState desiredState) {\n    if (this.monitorService.isShutdown()\n        || this.monitorService.isTerminated()\n        || this.monitorService.isTerminating()) {\n      throw new FlumeException(\"Supervise called on \" + lifecycleAware + \" \" +\n          \"after shutdown has been initiated. \" + lifecycleAware + \" will not\" +\n          \" be started\");\n    }\n    Preconditions.checkState(!supervisedProcesses.containsKey(lifecycleAware),\n        \"Refusing to supervise \" + lifecycleAware + \" more than once\");\n    if (logger.isDebugEnabled()) {\n      logger.debug(\"Supervising service:{} policy:{} desiredState:{}\",\n          new Object[] { lifecycleAware, policy, desiredState });\n    }\n    Supervisoree process = new Supervisoree();\n    process.status = new Status();\n    process.policy = policy;\n    process.status.desiredState = desiredState;\n    process.status.error = false;\n    MonitorRunnable monitorRunnable = new MonitorRunnable();\n    monitorRunnable.lifecycleAware = lifecycleAware;\n    monitorRunnable.supervisoree = process;\n    monitorRunnable.monitorService = monitorService;\n    supervisedProcesses.put(lifecycleAware, process);\n    ScheduledFuture<?> future = monitorService.scheduleWithFixedDelay(\n        monitorRunnable, 0, 3, TimeUnit.SECONDS);\n    monitorFutures.put(lifecycleAware, future);\n  }\n  public synchronized void unsupervise(LifecycleAware lifecycleAware) {\n    Preconditions.checkState(supervisedProcesses.containsKey(lifecycleAware),\n        \"Unaware of \" + lifecycleAware + \" - can not unsupervise\");\n    logger.debug(\"Unsupervising service:{}\", lifecycleAware);\n    synchronized (lifecycleAware) {\n      Supervisoree supervisoree = supervisedProcesses.get(lifecycleAware);\n      supervisoree.status.discard = true;\n      this.setDesiredState(lifecycleAware, LifecycleState.STOP);\n      logger.info(\"Stopping component: {}\", lifecycleAware);\n      lifecycleAware.stop();\n    }\n    supervisedProcesses.remove(lifecycleAware);\n    //We need to do this because a reconfiguration simply unsupervises old\n    //components and supervises new ones.\n    monitorFutures.get(lifecycleAware).cancel(false);\n    //purges are expensive, so it is done only once every 2 hours.\n    needToPurge = true;\n    monitorFutures.remove(lifecycleAware);\n  }\n  public synchronized void setDesiredState(LifecycleAware lifecycleAware,\n      LifecycleState desiredState) {\n    Preconditions.checkState(supervisedProcesses.containsKey(lifecycleAware),\n        \"Unaware of \" + lifecycleAware + \" - can not set desired state to \"\n            + desiredState);\n    logger.debug(\"Setting desiredState:{} on service:{}\", desiredState,\n        lifecycleAware);\n    Supervisoree supervisoree = supervisedProcesses.get(lifecycleAware);\n    supervisoree.status.desiredState = desiredState;\n  }\n  @Override\n  public synchronized LifecycleState getLifecycleState() {\n    return lifecycleState;\n  }\n  public synchronized boolean isComponentInErrorState(LifecycleAware component) {\n    return supervisedProcesses.get(component).status.error;\n  }\n  public static class MonitorRunnable implements Runnable {\n    public ScheduledExecutorService monitorService;\n    public LifecycleAware lifecycleAware;\n    public Supervisoree supervisoree;\n    @Override\n    public void run() {\n      logger.debug(\"checking process:{} supervisoree:{}\", lifecycleAware,\n          supervisoree);\n      long now = System.currentTimeMillis();\n      try {\n        if (supervisoree.status.firstSeen == null) {\n          logger.debug(\"first time seeing {}\", lifecycleAware);\n          supervisoree.status.firstSeen = now;\n        }\n        supervisoree.status.lastSeen = now;\n        synchronized (lifecycleAware) {\n          if (supervisoree.status.discard) {\n            // Unsupervise has already been called on this.\n            logger.info(\"Component has already been stopped {}\", lifecycleAware);\n            return;\n          } else if (supervisoree.status.error) {\n            logger.info(\"Component {} is in error state, and Flume will not\"\n                + \"attempt to change its state\", lifecycleAware);\n            return;\n          }\n          supervisoree.status.lastSeenState = lifecycleAware.getLifecycleState();\n          if (!lifecycleAware.getLifecycleState().equals(\n              supervisoree.status.desiredState)) {\n            logger.debug(\"Want to transition {} from {} to {} (failures:{})\",\n                new Object[] { lifecycleAware, supervisoree.status.lastSeenState,\n                    supervisoree.status.desiredState,\n                    supervisoree.status.failures });\n            switch (supervisoree.status.desiredState) {\n              case START:\n                try {\n                  lifecycleAware.start();\n                } catch (Throwable e) {\n                  logger.error(\"Unable to start \" + lifecycleAware\n                      + \" - Exception follows.\", e);\n                  if (e instanceof Error) {\n                    // This component can never recover, shut it down.\n                    supervisoree.status.desiredState = LifecycleState.STOP;\n                    try {\n                      lifecycleAware.stop();\n                      logger.warn(\"Component {} stopped, since it could not be\"\n                          + \"successfully started due to missing dependencies\",\n                          lifecycleAware);\n                    } catch (Throwable e1) {\n                      logger.error(\"Unsuccessful attempt to \"\n                          + \"shutdown component: {} due to missing dependencies.\"\n                          + \" Please shutdown the agent\"\n                          + \"or disable this component, or the agent will be\"\n                          + \"in an undefined state.\", e1);\n                      supervisoree.status.error = true;\n                      if (e1 instanceof Error) {\n                        throw (Error) e1;\n                      }\n                      // Set the state to stop, so that the conf poller can\n                      // proceed.\n                    }\n                  }\n                  supervisoree.status.failures++;\n                }\n                break;\n              case STOP:\n                try {\n                  lifecycleAware.stop();\n                } catch (Throwable e) {\n                  logger.error(\"Unable to stop \" + lifecycleAware\n                      + \" - Exception follows.\", e);\n                  if (e instanceof Error) {\n                    throw (Error) e;\n                  }\n                  supervisoree.status.failures++;\n                }\n                break;\n              default:\n                logger.warn(\"I refuse to acknowledge {} as a desired state\",\n                    supervisoree.status.desiredState);\n            }\n            if (!supervisoree.policy.isValid(lifecycleAware, supervisoree.status)) {\n              logger.error(\n                  \"Policy {} of {} has been violated - supervisor should exit!\",\n                  supervisoree.policy, lifecycleAware);\n            }\n          }\n        }\n      } catch (Throwable t) {\n        logger.error(\"Unexpected error\", t);\n      }\n      logger.debug(\"Status check complete\");\n    }\n  }\n  private class Purger implements Runnable {\n    @Override\n    public void run() {\n      if (needToPurge) {\n        monitorService.purge();\n        needToPurge = false;\n      }\n    }\n  }\n  public static class Status {\n    public Long firstSeen;\n    public Long lastSeen;\n    public LifecycleState lastSeenState;\n    public LifecycleState desiredState;\n    public int failures;\n    public boolean discard;\n    public volatile boolean error;\n    @Override\n    public String toString() {\n      return \"{ lastSeen:\" + lastSeen + \" lastSeenState:\" + lastSeenState\n          + \" desiredState:\" + desiredState + \" firstSeen:\" + firstSeen\n          + \" failures:\" + failures + \" discard:\" + discard + \" error:\" +\n          error + \" }\";\n    }\n  }\n  public abstract static class SupervisorPolicy {\n    abstract boolean isValid(LifecycleAware object, Status status);\n    public static class AlwaysRestartPolicy extends SupervisorPolicy {\n<fim_suffix>      @Override\n      boolean isValid(LifecycleAware object, Status status) {\n        return true;\n      }<fim_middle>// function below has no smell\n"}