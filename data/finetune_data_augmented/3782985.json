{"text": "<fim_prefix>      } else {\n        throw new ParserException(\"Unexpected MIME type.\");\n      }\n      this.output = output.track(number, type);\n      this.output.format(format);\n    }\n    /** Forces any pending sample metadata to be flushed to the output. */\n    public void outputPendingSampleMetadata() {\n      if (trueHdSampleRechunker != null) {\n        trueHdSampleRechunker.outputPendingSampleMetadata(this);\n      }\n    }\n    /** Resets any state stored in the track in response to a seek. */\n    public void reset() {\n      if (trueHdSampleRechunker != null) {\n        trueHdSampleRechunker.reset();\n      }\n    }\n    /** Returns the HDR Static Info as defined in CTA-861.3. */\n    private byte[] getHdrStaticInfo() {\n      // Are all fields present.\n      if (primaryRChromaticityX == Format.NO_VALUE || primaryRChromaticityY == Format.NO_VALUE\n          || primaryGChromaticityX == Format.NO_VALUE || primaryGChromaticityY == Format.NO_VALUE\n          || primaryBChromaticityX == Format.NO_VALUE || primaryBChromaticityY == Format.NO_VALUE\n          || whitePointChromaticityX == Format.NO_VALUE\n          || whitePointChromaticityY == Format.NO_VALUE || maxMasteringLuminance == Format.NO_VALUE\n          || minMasteringLuminance == Format.NO_VALUE) {\n        return null;\n      }\n      byte[] hdrStaticInfoData = new byte[25];\n      ByteBuffer hdrStaticInfo = ByteBuffer.wrap(hdrStaticInfoData);\n      hdrStaticInfo.put((byte) 0);  // Type.\n      hdrStaticInfo.putShort((short) ((primaryRChromaticityX * MAX_CHROMATICITY) + 0.5f));\n      hdrStaticInfo.putShort((short) ((primaryRChromaticityY * MAX_CHROMATICITY) + 0.5f));\n      hdrStaticInfo.putShort((short) ((primaryGChromaticityX * MAX_CHROMATICITY)  + 0.5f));\n      hdrStaticInfo.putShort((short) ((primaryGChromaticityY * MAX_CHROMATICITY) + 0.5f));\n      hdrStaticInfo.putShort((short) ((primaryBChromaticityX * MAX_CHROMATICITY) + 0.5f));\n      hdrStaticInfo.putShort((short) ((primaryBChromaticityY * MAX_CHROMATICITY) + 0.5f));\n      hdrStaticInfo.putShort((short) ((whitePointChromaticityX * MAX_CHROMATICITY) + 0.5f));\n      hdrStaticInfo.putShort((short) ((whitePointChromaticityY * MAX_CHROMATICITY) + 0.5f));\n      hdrStaticInfo.putShort((short) (maxMasteringLuminance + 0.5f));\n      hdrStaticInfo.putShort((short) (minMasteringLuminance + 0.5f));\n      hdrStaticInfo.putShort((short) maxContentLuminance);\n      hdrStaticInfo.putShort((short) maxFrameAverageLuminance);\n      return hdrStaticInfoData;\n    }\n    /**\n     * Builds initialization data for a {@link Format} from FourCC codec private data.\n     *\n     * <p>VC1 and H263 are the only supported compression types.\n     *\n     * @return The codec mime type and initialization data. If the compression type is not supported\n     *     then the mime type is set to {@link MimeTypes#VIDEO_UNKNOWN} and the initialization data\n     *     is {@code null}.\n     * @throws ParserException If the initialization data could not be built.\n     */\n    private static Pair<String, List<byte[]>> parseFourCcPrivate(ParsableByteArray buffer)\n        throws ParserException {\n      try {\n        buffer.skipBytes(16); // size(4), width(4), height(4), planes(2), bitcount(2).\n        long compression = buffer.readLittleEndianUnsignedInt();\n        if (compression == FOURCC_COMPRESSION_DIVX) {\n          return new Pair<>(MimeTypes.VIDEO_H263, null);\n        } else if (compression == FOURCC_COMPRESSION_VC1) {\n          // Search for the initialization data from the end of the BITMAPINFOHEADER. The last 20\n          // bytes of which are: sizeImage(4), xPel/m (4), yPel/m (4), clrUsed(4), clrImportant(4).\n          int startOffset = buffer.getPosition() + 20;\n          byte[] bufferData = buffer.data;\n          for (int offset = startOffset; offset < bufferData.length - 4; offset++) {\n            if (bufferData[offset] == 0x00\n                && bufferData[offset + 1] == 0x00\n                && bufferData[offset + 2] == 0x01\n                && bufferData[offset + 3] == 0x0F) {\n              // We've found the initialization data.\n              byte[] initializationData = Arrays.copyOfRange(bufferData, offset, bufferData.length);\n              return new Pair<>(MimeTypes.VIDEO_VC1, Collections.singletonList(initializationData));\n            }\n          }\n          throw new ParserException(\"Failed to find FourCC VC1 initialization data\");\n        }\n      } catch (ArrayIndexOutOfBoundsException e) {\n        throw new ParserException(\"Error parsing FourCC private data\");\n      }\n      Log.w(TAG, \"Unknown FourCC. Setting mimeType to \" + MimeTypes.VIDEO_UNKNOWN);\n      return new Pair<>(MimeTypes.VIDEO_UNKNOWN, null);\n    }\n    /**\n     * Builds initialization data for a {@link Format} from Vorbis codec private data.\n     *\n     * @return The initialization data for the {@link Format}.\n     * @throws ParserException If the initialization data could not be built.\n     */\n    private static List<byte[]> parseVorbisCodecPrivate(byte[] codecPrivate)\n        throws ParserException {\n      try {\n        if (codecPrivate[0] != 0x02) {\n          throw new ParserException(\"Error parsing vorbis codec private\");\n        }\n        int offset = 1;\n        int vorbisInfoLength = 0;\n        while (codecPrivate[offset] == (byte) 0xFF) {\n          vorbisInfoLength += 0xFF;\n          offset++;\n        }\n        vorbisInfoLength += codecPrivate[offset++];\n        int vorbisSkipLength = 0;\n        while (codecPrivate[offset] == (byte) 0xFF) {\n          vorbisSkipLength += 0xFF;\n          offset++;\n        }\n        vorbisSkipLength += codecPrivate[offset++];\n        if (codecPrivate[offset] != 0x01) {\n          throw new ParserException(\"Error parsing vorbis codec private\");\n        }\n        byte[] vorbisInfo = new byte[vorbisInfoLength];\n        System.arraycopy(codecPrivate, offset, vorbisInfo, 0, vorbisInfoLength);\n        offset += vorbisInfoLength;\n        if (codecPrivate[offset] != 0x03) {\n          throw new ParserException(\"Error parsing vorbis codec private\");\n        }\n        offset += vorbisSkipLength;\n        if (codecPrivate[offset] != 0x05) {\n          throw new ParserException(\"Error parsing vorbis codec private\");\n        }\n        byte[] vorbisBooks = new byte[codecPrivate.length - offset];\n        System.arraycopy(codecPrivate, offset, vorbisBooks, 0, codecPrivate.length - offset);\n        List<byte[]> initializationData = new ArrayList<>(2);\n        initializationData.add(vorbisInfo);\n        initializationData.add(vorbisBooks);\n        return initializationData;\n      } catch (ArrayIndexOutOfBoundsException e) {\n        throw new ParserException(\"Error parsing vorbis codec private\");\n      }\n    }\n    /**\n     * Parses an MS/ACM codec private, returning whether it indicates PCM audio.\n     *\n     * @return Whether the codec private indicates PCM audio.\n     * @throws ParserException If a parsing error occurs.\n     */\n<fim_suffix>    private static boolean parseMsAcmCodecPrivate(ParsableByteArray buffer) throws ParserException {\n      try {\n        int formatTag = buffer.readLittleEndianUnsignedShort();\n        if (formatTag == WAVE_FORMAT_PCM) {\n          return true;\n        } else if (formatTag == WAVE_FORMAT_EXTENSIBLE) {\n          buffer.setPosition(WAVE_FORMAT_SIZE + 6); // unionSamples(2), channelMask(4)\n          return buffer.readLong() == WAVE_SUBFORMAT_PCM.getMostSignificantBits()\n              && buffer.readLong() == WAVE_SUBFORMAT_PCM.getLeastSignificantBits();\n        } else {\n          return false;\n        }\n      } catch (ArrayIndexOutOfBoundsException e) {\n        throw new ParserException(\"Error parsing MS/ACM codec private\");\n      }\n    }<fim_middle>// function below has no smell\n"}