{"text": "<fim_prefix>/*\n\n   Derby - Class org.apache.derby.impl.services.uuid.BasicUUID\n\n   Licensed to the Apache Software Foundation (ASF) under one or more\n   contributor license agreements.  See the NOTICE file distributed with\n   this work for additional information regarding copyright ownership.\n   The ASF licenses this file to you under the Apache License, Version 2.0\n   (the \"License\"); you may not use this file except in compliance with\n   the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n */\n\npackage org.apache.derby.impl.services.uuid;\n\nimport org.apache.derby.iapi.services.io.StoredFormatIds;\nimport org.apache.derby.iapi.services.io.Formatable;\n\nimport org.apache.derby.catalog.UUID;\n\nimport java.io.ObjectOutput;\nimport java.io.ObjectInput;\nimport java.io.IOException;\n\nimport java.io.StringReader;\n\n\n<fim_suffix>public class BasicUUID implements UUID, Formatable\n{\n\t/*\n\t** Fields of BasicUUID\n\t*/\n\t\n\tprivate long majorId; // only using 48 bits\n\tprivate long timemillis;\n\tprivate int sequence;\n\n\t/*\n\t** Methods of BasicUUID\n\t*/\n\n\t/**\n\t\tConstructor only called by BasicUUIDFactory.\n\t**/\n\tpublic BasicUUID(long majorId, long timemillis, int sequence)\n\t{\n\t\tthis.majorId = majorId;\n\t\tthis.timemillis = timemillis;\n\t\tthis.sequence = sequence;\n\t}\n\n\t/**\n\t\tConstructor only called by BasicUUIDFactory.\n\t\tConstructs a UUID from the string representation\n\t\tproduced by toString.\n\t\t@see BasicUUID#toString\n\t**/\n\tpublic BasicUUID(String uuidstring)\n\t{\n\t\tStringReader sr = new StringReader(uuidstring);\n\t\tsequence = (int) readMSB(sr);\n\n\t\tlong ltimemillis = readMSB(sr) << 32;\n\t\tltimemillis += readMSB(sr) << 16;\n\t\tltimemillis += readMSB(sr);\n\t\ttimemillis = ltimemillis;\n\t\tmajorId = readMSB(sr);\n\t}\n\n\t/*\n\t * Formatable methods\n\t */\n\n\t// no-arg constructor, required by Formatable \n\tpublic BasicUUID() { super(); }\n\n\t/**\n\t\tWrite this out.\n\t\t@exception IOException error writing to log stream\n\t*/\n\tpublic void writeExternal(ObjectOutput out) throws IOException \n\t{\n\t\tout.writeLong(majorId);\n\t\tout.writeLong(timemillis);\n\t\tout.writeInt(sequence);\n\t}\n\n\t/**\n\t\tRead this in\n\t\t@exception IOException error reading from log stream\n\t*/\n\tpublic void readExternal(ObjectInput in) throws IOException\n\t{\n\t\tmajorId = in.readLong();\n\t\ttimemillis = in.readLong();\n\t\tsequence = in.readInt();\n\t}\n\n\t/**\n\t\tReturn my format identifier.\n\t*/\n\tpublic int getTypeFormatId() {\n\t\treturn StoredFormatIds.BASIC_UUID;\n\t}\n\n\tprivate static void writeMSB(char[] data, int offset, long value, int nbytes)\n    {\n    \tfor (int i = nbytes - 1; i >= 0; i--)\n\t\t{\n\t\t   long b = (value & (255L << (8 * i))) >>> (8 * i);\n\n\t\t   int c = (int) ((b & 0xf0) >> 4);\n\t\t   data[offset++] = (char) (c < 10 ? c + '0' : (c - 10) + 'a');\n\t\t   c = (int) (b & 0x0f);\n\t\t   data[offset++] = (char) (c < 10 ? c + '0' : (c - 10) + 'a');\n\t\t} \n    }\n\n    /**\n\t\tRead a long value, msb first, from its character \n\t\trepresentation in the string reader, using '-' or\n\t\tend of string to delimit.\n\t**/\n\tprivate static long readMSB(StringReader sr)\n    {\n\t\tlong value = 0;\n\n\t\ttry\n\t\t{\n\t\t\tint c;\n\t\t\twhile ((c = sr.read()) != -1)\n\t\t\t{\n\t\t\t\tif (c == '-')\n\t\t\t\t\tbreak;\n\t\t\t\tvalue <<= 4;\n\n\t\t\t\tint nibble;\n\t\t\t\tif (c <= '9')\n\t\t\t\t\tnibble = c - '0';\n\t\t\t\telse if (c <= 'F')\n\t\t\t\t\tnibble = c - 'A' + 10;\n\t\t\t\telse\n\t\t\t\t\tnibble = c - 'a' + 10;\n\t\t\t\tvalue += nibble;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t}\n\n\t\treturn value;\n    }\n\n\t/*\n\t** Methods of UUID\n\t*/\n\n\t/**\n\t\tImplement value equality.\n\n\t**/\n\tpublic boolean equals(Object otherObject)\n\t{\n\t\tif (!(otherObject instanceof BasicUUID))\n\t\t\treturn false;\n\n\t\tBasicUUID other = (BasicUUID) otherObject;\n\n\t\treturn (this.sequence == other.sequence)\n\t\t\t&& (this.timemillis == other.timemillis)\n\t\t\t&& (this.majorId == other.majorId);\n\t}\n\n\t/**\n\t\tProvide a hashCode which is compatible with\n\t\tthe equals() method.\n\t**/\n\tpublic int hashCode()\n\t{\n\t\tlong hc = majorId ^ timemillis;\n\n\t\treturn sequence ^ ((int) (hc >> 4));\n\t}\n\n\t/**\n\t\tProduce a string representation of this UUID which\n\t\tcan be passed to UUIDFactory.recreateUUID later on\n\t\tto reconstruct it.  The funny representation is \n\t\tdesigned to (sort of) match the format of Microsoft's\n\t\tUUIDGEN utility.\n\t */\n\tpublic String toString() {return stringWorkhorse( '-' );}\n\n\t/**\n\t\tProduce a string representation of this UUID which\n\t\tis suitable for use as a unique ANSI identifier.\n\t */\n\tpublic String toANSIidentifier() {return \"U\" + stringWorkhorse( 'X' );}\n\n\t/**\n\t  *\tPrivate workhorse of the string making routines.\n\t  *\n\t  *\t@param\tseparator\tCharacter to separate number blocks.\n\t  *                     Null means do not include a separator.\n\t  *\n\t  *\t@return\tstring representation of UUID.\n\t  */\n\tpublic\tString\tstringWorkhorse( char separator )\n\t{\n\t\tchar[] data = new char[36];\n\n\t\twriteMSB(data, 0, (long) sequence, 4);\n\n\t\tint offset = 8;\n\t\tif (separator != 0) data[offset++] = separator;\n\n\t\tlong ltimemillis = timemillis;\n\t\twriteMSB(data, offset, (ltimemillis & 0x0000ffff00000000L) >>> 32, 2);\n\t\toffset += 4;\n\t\tif (separator != 0) data[offset++] = separator;\n\t\twriteMSB(data, offset, (ltimemillis & 0x00000000ffff0000L) >>> 16, 2);\n\t\toffset += 4;\n\t\tif (separator != 0) data[offset++] = separator;\n\t\twriteMSB(data, offset, (ltimemillis & 0x000000000000ffffL), 2);\n\t\toffset += 4;\n\t\tif (separator != 0) data[offset++] = separator;\n\t\twriteMSB(data, offset, majorId, 6);\n\t\toffset += 12;\n\n\t\treturn new String(data, 0, offset);\n\t}\n\n\t/**\n\t  Clone this UUID.\n\n\t  @return\ta copy of this UUID\n\t  */\n\tpublic UUID cloneMe()\n\t{\n\t\treturn\tnew\tBasicUUID(majorId, timemillis, sequence);\n\t}\n}\n<fim_middle>// class below has no smell\n"}