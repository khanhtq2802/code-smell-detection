{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n * agreements. See the NOTICE file distributed with this work for additional information regarding\n * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n * copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\npackage org.apache.geode.rest.internal.web.controllers;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Vector;\n\nimport org.apache.geode.cache.CacheClosedException;\nimport org.apache.geode.cache.CacheFactory;\nimport org.apache.geode.cache.Region;\nimport org.apache.geode.cache.execute.Function;\nimport org.apache.geode.cache.execute.FunctionContext;\nimport org.apache.geode.cache.query.FunctionDomainException;\nimport org.apache.geode.cache.query.NameResolutionException;\nimport org.apache.geode.cache.query.Query;\nimport org.apache.geode.cache.query.QueryInvocationTargetException;\nimport org.apache.geode.cache.query.SelectResults;\nimport org.apache.geode.cache.query.TypeMismatchException;\nimport org.apache.geode.internal.cache.InternalCache;\nimport org.apache.geode.pdx.PdxInstance;\n\n/**\n * Gemfire function to add free items in the existing order if the total price for that order is\n * greater then the argument\n */\npublic class AddFreeItemToOrders implements Function {\n\n  @Override\n  public void execute(FunctionContext context) {\n    Region region = null;\n    List<Object> vals = new ArrayList<Object>();\n    List<Object> keys = new ArrayList<Object>();\n    List<Object> argsList = new ArrayList<Object>();\n    Object[] argsArray = null;\n\n    if (context.getArguments() instanceof Boolean) {\n\n    } else if (context.getArguments() instanceof String) {\n      String arg = (String) context.getArguments();\n    } else if (context.getArguments() instanceof Vector) {\n\n    } else if (context.getArguments() instanceof Object[]) {\n      argsArray = (Object[]) context.getArguments();\n      argsList = Arrays.asList(argsArray);\n    } else {\n      System.out.println(\"AddFreeItemToOrders : Invalid Arguments\");\n    }\n\n    InternalCache cache = null;\n    try {\n      cache = (InternalCache) CacheFactory.getAnyInstance();\n      cache.getCacheConfig().setPdxReadSerialized(true);\n      region = cache.getRegion(\"orders\");\n    } catch (CacheClosedException ex) {\n      vals.add(\"NoCacheFoundResult\");\n      context.getResultSender().lastResult(vals);\n      throw ex;\n    }\n\n    String oql =\n        \"SELECT DISTINCT entry.key FROM /orders.entries entry WHERE entry.value.totalPrice > $1\";\n    Object queryArgs[] = new Object[1];\n    queryArgs[0] = argsList.get(0);\n\n    final Query query = cache.getQueryService().newQuery(oql);\n\n    SelectResults result = null;\n    try {\n      result = (SelectResults) query.execute(queryArgs);\n\n      if (result instanceof Collection<?>)\n        for (Object item : result) {\n          keys.add(item);\n        }\n    } catch (FunctionDomainException e) {\n      cache.getLogger()\n          .info(\"Caught FunctionDomainException while executing function AddFreeItemToOrders: \"\n              + e.getMessage());\n    } catch (TypeMismatchException e) {\n      cache.getLogger()\n          .info(\"Caught TypeMismatchException while executing function AddFreeItemToOrders: \"\n              + e.getMessage());\n    } catch (NameResolutionException e) {\n      cache.getLogger()\n          .info(\"Caught NameResolutionException while executing function AddFreeItemToOrders: \"\n              + e.getMessage());\n    } catch (QueryInvocationTargetException e) {\n      cache.getLogger().info(\n          \"Caught QueryInvocationTargetException while executing function AddFreeItemToOrders\"\n              + e.getMessage());\n    }\n\n    // class has to be in classpath.\n    try {\n      Item it = (Item) (argsList.get(1));\n      for (Object key : keys) {\n        Object obj = region.get(key);\n        if (obj instanceof PdxInstance) {\n          PdxInstance pi = (PdxInstance) obj;\n          Order receivedOrder = (Order) pi.getObject();\n          receivedOrder.addItem(it);\n\n          region.put(key, receivedOrder);\n        }\n      }\n\n      context.getResultSender().lastResult(\"success\");\n    } catch (ClassCastException e) {\n      context.getResultSender().lastResult(\"failure\");\n    } catch (Exception e) {\n      context.getResultSender().lastResult(\"failure\");\n    }\n  }\n\n<fim_suffix>  @Override\n  public String getId() {\n    return \"AddFreeItemToOrders\";\n  }\n\n  @Override\n  public boolean hasResult() {\n    return true;\n  }\n\n  @Override\n  public boolean optimizeForWrite() {\n    return false;\n  }\n\n  @Override\n  public boolean isHA() {\n    return false;\n  }\n}<fim_middle>// function below has no smell\n"}