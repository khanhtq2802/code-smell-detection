{"text": "<fim_prefix>  private final ExecutorService rawExecutor;\n  private final ListeningExecutorService executor;\n  @SuppressWarnings(\"rawtypes\")\n  private final EventHandler eventHandler;\n  private volatile boolean isStopped = false;\n  private final UserGroupInformation dagUgi;\n  private final StateChangeNotifier entityStateTracker;\n  private final Vertex vertex;\n  private final AppContext appContext;\n  @VisibleForTesting\n  final Map<String, InitializerWrapper> initializerMap = new HashMap<String, InitializerWrapper>();\n  public RootInputInitializerManager(Vertex vertex, AppContext appContext,\n                                     UserGroupInformation dagUgi, StateChangeNotifier stateTracker) {\n    this.appContext = appContext;\n    this.vertex = vertex;\n    this.eventHandler = appContext.getEventHandler();\n    this.rawExecutor = Executors.newCachedThreadPool(new ThreadFactoryBuilder()\n        .setDaemon(true).setNameFormat(\"InputInitializer {\" + this.vertex.getName() + \"} #%d\").build());\n    this.executor = MoreExecutors.listeningDecorator(rawExecutor);\n    this.dagUgi = dagUgi;\n    this.entityStateTracker = stateTracker;\n  }\n  public void runInputInitializers(List<RootInputLeafOutput<InputDescriptor, InputInitializerDescriptor>>\n      inputs) throws TezException {\n    for (RootInputLeafOutput<InputDescriptor, InputInitializerDescriptor> input : inputs) {\n      InputInitializerContext context =\n          new TezRootInputInitializerContextImpl(input, vertex, appContext, this);\n      InputInitializer initializer;\n      try {\n        TezUtilsInternal.setHadoopCallerContext(appContext.getHadoopShim(), vertex.getVertexId());\n        initializer = createInitializer(input, context);\n      } finally {\n        appContext.getHadoopShim().clearHadoopCallerContext();\n      }\n      InitializerWrapper initializerWrapper =\n          new InitializerWrapper(input, initializer, context, vertex, entityStateTracker, appContext);\n      // Register pending vertex update registrations\n      List<VertexUpdateRegistrationHolder> vertexUpdateRegistrations = pendingVertexRegistrations.removeAll(input.getName());\n      if (vertexUpdateRegistrations != null) {\n        for (VertexUpdateRegistrationHolder h : vertexUpdateRegistrations) {\n          initializerWrapper.registerForVertexStateUpdates(h.vertexName, h.stateSet);\n        }\n      }\n      initializerMap.put(input.getName(), initializerWrapper);\n      ListenableFuture<List<Event>> future = executor\n          .submit(new InputInitializerCallable(initializerWrapper, dagUgi, appContext));\n      Futures.addCallback(future, createInputInitializerCallback(initializerWrapper));\n    }\n  }\n  @VisibleForTesting\n  protected InputInitializer createInitializer(final RootInputLeafOutput<InputDescriptor, InputInitializerDescriptor>\n      input, final InputInitializerContext context) throws TezException {\n    try {\n      return dagUgi.doAs(new PrivilegedExceptionAction<InputInitializer>() {\n        @Override\n        public InputInitializer run() throws Exception {\n          InputInitializer initializer = ReflectionUtils\n              .createClazzInstance(input.getControllerDescriptor().getClassName(),\n                  new Class[]{InputInitializerContext.class}, new Object[]{context});\n          return initializer;\n        }\n      });\n    } catch (IOException e) {\n      throw new TezException(e);\n    } catch (InterruptedException e) {\n      throw new TezException(e);\n    } catch (UndeclaredThrowableException e) {\n      if (e.getCause() instanceof TezException) {\n        throw (TezException) e.getCause();\n      } else {\n        throw e;\n      }\n    }\n  }\n  public void handleInitializerEvents(List<TezEvent> events) {\n    ListMultimap<InitializerWrapper, TezEvent> eventMap = LinkedListMultimap.create();\n    for (TezEvent tezEvent : events) {\n      Preconditions.checkState(tezEvent.getEvent() instanceof InputInitializerEvent);\n      InputInitializerEvent event = (InputInitializerEvent)tezEvent.getEvent();\n      Preconditions.checkState(vertex.getName().equals(event.getTargetVertexName()),\n          \"Received event for incorrect vertex\");\n      Preconditions.checkNotNull(event.getTargetInputName(), \"target input name must be set\");\n      InitializerWrapper initializer = initializerMap.get(event.getTargetInputName());\n      Preconditions.checkState(initializer != null,\n          \"Received event for unknown input : \" + event.getTargetInputName());\n      eventMap.put(initializer, tezEvent);\n    }\n    // This is a restriction based on current flow - i.e. events generated only by initialize().\n    // TODO Rework the flow as per the first comment on TEZ-1076\n    if (isStopped) {\n      LOG.warn(\"InitializerManager already stopped for \" + vertex.getLogIdentifier() +\n          \" Dropping \" + events.size() + \" events\");\n    }\n    for (Map.Entry<InitializerWrapper, Collection<TezEvent>> entry : eventMap.asMap().entrySet()) {\n      InitializerWrapper initializerWrapper = entry.getKey();\n      if (initializerWrapper.isComplete()) {\n        LOG.warn(entry.getValue().size() +\n            \" events targeted at vertex \" + vertex.getLogIdentifier() +\n            \", initializerWrapper for Input: \" +\n            initializerWrapper.getInput().getName() +\n            \" will be dropped, since Input has already been initialized.\");\n      } else {\n        initializerWrapper.handleInputInitializerEvents(entry.getValue());\n      }\n    }\n  }\n  private static class VertexUpdateRegistrationHolder {\n    private VertexUpdateRegistrationHolder(String vertexName, Set<org.apache.tez.dag.api.event.VertexState> stateSet) {\n      this.vertexName = vertexName;\n      this.stateSet = stateSet;\n    }\n    private final String vertexName;\n    private final Set<org.apache.tez.dag.api.event.VertexState> stateSet;\n  }\n  // This doesn't need to be thread safe, since initializers are not created in separate threads,\n  // they're only executed in separate threads.\n  private final ListMultimap<String, VertexUpdateRegistrationHolder> pendingVertexRegistrations =\n      LinkedListMultimap.create();\n  public void registerForVertexUpdates(String vertexName, String inputName,\n                                       @Nullable Set<org.apache.tez.dag.api.event.VertexState> stateSet) {\n    Preconditions.checkNotNull(vertexName, \"VertexName cannot be null: \" + vertexName);\n    Preconditions.checkNotNull(inputName, \"InputName cannot be null\");\n    InitializerWrapper initializer = initializerMap.get(inputName);\n    if (initializer == null) {\n      pendingVertexRegistrations.put(inputName, new VertexUpdateRegistrationHolder(vertexName, stateSet));\n    } else {\n      initializer.registerForVertexStateUpdates(vertexName, stateSet);\n    }\n  }\n  @VisibleForTesting\n  protected InputInitializerCallback createInputInitializerCallback(InitializerWrapper initializer) {\n    return new InputInitializerCallback(initializer, eventHandler, vertex.getVertexId());\n  }\n  @VisibleForTesting\n  @InterfaceAudience.Private\n  public InitializerWrapper getInitializerWrapper(String inputName) {\n    return initializerMap.get(inputName);\n  }\n  public void shutdown() {\n    if (executor != null && !isStopped) {\n      // Don't really care about what is running if an error occurs. If no error\n      // occurs, all execution is complete.\n      executor.shutdownNow();\n      isStopped = true;\n    }\n  }\n  private static class InputInitializerCallable implements\n      Callable<List<Event>> {\n    private final InitializerWrapper initializerWrapper;\n    private final UserGroupInformation ugi;\n    private final AppContext appContext;\n    public InputInitializerCallable(InitializerWrapper initializer, UserGroupInformation ugi,\n                                    AppContext appContext) {\n      this.initializerWrapper = initializer;\n      this.ugi = ugi;\n      this.appContext = appContext;\n    }\n    @Override\n    public List<Event> call() throws Exception {\n      List<Event> events = ugi.doAs(new PrivilegedExceptionAction<List<Event>>() {\n        @Override\n        public List<Event> run() throws Exception {\n          LOG.info(\n              \"Starting InputInitializer for Input: \" + initializerWrapper.getInput().getName() +\n                  \" on vertex \" + initializerWrapper.getVertexLogIdentifier());\n          try {\n            TezUtilsInternal.setHadoopCallerContext(appContext.getHadoopShim(),\n                initializerWrapper.vertexId);\n            return initializerWrapper.getInitializer().initialize();\n          } finally {\n            appContext.getHadoopShim().clearHadoopCallerContext();\n          }\n        }\n      });\n      return events;\n    }\n  }\n  @SuppressWarnings(\"rawtypes\")\n  @VisibleForTesting\n  private static class InputInitializerCallback implements\n      FutureCallback<List<Event>> {\n    private final InitializerWrapper initializer;\n    private final EventHandler eventHandler;\n    private final TezVertexID vertexID;\n<fim_suffix>    public InputInitializerCallback(InitializerWrapper initializer,\n        EventHandler eventHandler, TezVertexID vertexID) {\n      this.initializer = initializer;\n      this.eventHandler = eventHandler;\n      this.vertexID = vertexID;\n    }<fim_middle>// function below has no smell\n"}