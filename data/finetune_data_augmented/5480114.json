{"text": "<fim_prefix>    @ManagedAttributeField\n    private long _storeTransactionIdleTimeoutClose;\n    @ManagedAttributeField\n    private long _storeTransactionIdleTimeoutWarn;\n    @ManagedAttributeField\n    private long _storeTransactionOpenTimeoutClose;\n    @ManagedAttributeField\n    private long _storeTransactionOpenTimeoutWarn;\n    @ManagedAttributeField\n    private int _housekeepingThreadCount;\n    @ManagedAttributeField\n    private int _connectionThreadPoolSize;\n    @ManagedAttributeField\n    private int _numberOfSelectors;\n    @ManagedAttributeField\n    private List<String> _enabledConnectionValidators;\n    @ManagedAttributeField\n    private List<String> _disabledConnectionValidators;\n    @ManagedAttributeField\n    private List<String> _globalAddressDomains;\n    @ManagedAttributeField\n    private List<NodeAutoCreationPolicy> _nodeAutoCreationPolicies;\n    @ManagedAttributeField\n    private volatile int _statisticsReportingPeriod;\n    private boolean _useAsyncRecoverer;\n    private MessageDestination _defaultDestination;\n    private MessageStore _messageStore;\n    private MessageStoreRecoverer _messageStoreRecoverer;\n    private final FileSystemSpaceChecker _fileSystemSpaceChecker;\n    private int _fileSystemMaxUsagePercent;\n    private Collection<VirtualHostLogger> _virtualHostLoggersToClose;\n    private PreferenceStore _preferenceStore;\n    private long _flowToDiskCheckPeriod;\n    private volatile boolean _isDiscardGlobalSharedSubscriptionLinksOnDetach;\n    public AbstractVirtualHost(final Map<String, Object> attributes, VirtualHostNode<?> virtualHostNode)\n    {\n        super(virtualHostNode, attributes);\n        _broker = (Broker<?>) virtualHostNode.getParent();\n        _virtualHostNode = virtualHostNode;\n        _dtxRegistry = new DtxRegistry(this);\n        final SystemConfig systemConfig = (SystemConfig) _broker.getParent();\n        _eventLogger = systemConfig.getEventLogger();\n        _eventLogger.message(VirtualHostMessages.CREATED(getName()));\n        _principal = new VirtualHostPrincipal(this);\n        if (systemConfig.isManagementMode())\n        {\n            _accessControl = AccessControl.ALWAYS_ALLOWED;\n        }\n        else\n        {\n            _accessControl =  new CompoundAccessControl(\n                    Collections.<AccessControl<?>>emptyList(), Result.DEFER\n            );\n        }\n        _defaultDestination = new DefaultDestination(this, _accessControl);\n        _housekeepingJobContext = getSystemTaskControllerContext(\"Housekeeping[\"+getName()+\"]\", _principal);\n        _fileSystemSpaceCheckerJobContext = getSystemTaskControllerContext(\"FileSystemSpaceChecker[\"+getName()+\"]\", _principal);\n        _fileSystemSpaceChecker = new FileSystemSpaceChecker();\n    }\n    private void updateAccessControl()\n    {\n        if(!((SystemConfig)_broker.getParent()).isManagementMode())\n        {\n            List<VirtualHostAccessControlProvider> children = new ArrayList<>(getChildren(VirtualHostAccessControlProvider.class));\n            LOGGER.debug(\"Updating access control list with {} provider children\", children.size());\n            Collections.sort(children, VirtualHostAccessControlProvider.ACCESS_CONTROL_PROVIDER_COMPARATOR);\n            List<AccessControl<?>> accessControls = new ArrayList<>(children.size()+2);\n            accessControls.add(_systemUserAllowed);\n            for(VirtualHostAccessControlProvider prov : children)\n            {\n                if(prov.getState() == State.ERRORED)\n                {\n                    accessControls.clear();\n                    accessControls.add(AccessControl.ALWAYS_DENIED);\n                    break;\n                }\n                else if(prov.getState() == State.ACTIVE)\n                {\n                    accessControls.add(prov.getController());\n                }\n            }\n            accessControls.add(getParentAccessControl());\n            ((CompoundAccessControl)_accessControl).setAccessControls(accessControls);\n        }\n    }\n    @Override\n    protected void onCreate()\n    {\n        super.onCreate();\n        _createDefaultExchanges = true;\n    }\n    @Override\n    public void setFirstOpening(boolean firstOpening)\n    {\n        _createDefaultExchanges = firstOpening;\n    }\n    @Override\n    public void onValidate()\n    {\n        super.onValidate();\n        String name = getName();\n        if (name == null || \"\".equals(name.trim()))\n        {\n            throw new IllegalConfigurationException(\"Virtual host name must be specified\");\n        }\n        String type = getType();\n        if (type == null || \"\".equals(type.trim()))\n        {\n            throw new IllegalConfigurationException(\"Virtual host type must be specified\");\n        }\n        if(!isDurable())\n        {\n            throw new IllegalArgumentException(getClass().getSimpleName() + \" must be durable\");\n        }\n        if(getGlobalAddressDomains() != null)\n        {\n            for(String domain : getGlobalAddressDomains())\n            {\n                validateGlobalAddressDomain(domain);\n            }\n        }\n        if(getNodeAutoCreationPolicies() != null)\n        {\n            for(NodeAutoCreationPolicy policy : getNodeAutoCreationPolicies())\n            {\n                validateNodeAutoCreationPolicy(policy);\n            }\n        }\n        validateConnectionThreadPoolSettings(this);\n        validateMessageStoreCreation();\n    }\n    @Override\n    protected void validateChange(final ConfiguredObject<?> proxyForValidation, final Set<String> changedAttributes)\n    {\n        super.validateChange(proxyForValidation, changedAttributes);\n        QueueManagingVirtualHost<?> virtualHost = (QueueManagingVirtualHost<?>) proxyForValidation;\n        if(changedAttributes.contains(GLOBAL_ADDRESS_DOMAINS))\n        {\n            if(virtualHost.getGlobalAddressDomains() != null)\n            {\n                for(String name : virtualHost.getGlobalAddressDomains())\n                {\n                    validateGlobalAddressDomain(name);\n                }\n            }\n        }\n        if(changedAttributes.contains(NODE_AUTO_CREATION_POLICIES))\n        {\n            if(getNodeAutoCreationPolicies() != null)\n            {\n                for(NodeAutoCreationPolicy policy : virtualHost.getNodeAutoCreationPolicies())\n                {\n                    validateNodeAutoCreationPolicy(policy);\n                }\n            }\n        }\n        if (changedAttributes.contains(CONNECTION_THREAD_POOL_SIZE) || changedAttributes.contains(NUMBER_OF_SELECTORS))\n        {\n            validateConnectionThreadPoolSettings(virtualHost);\n        }\n    }\n    @Override\n    protected void changeAttributes(final Map<String, Object> attributes)\n    {\n        super.changeAttributes(attributes);\n        if (attributes.containsKey(STATISTICS_REPORTING_PERIOD))\n        {\n            initialiseStatisticsReporting();\n        }\n    }\n    @Override\n    protected AccessControl getAccessControl()\n    {\n        return _accessControl;\n    }\n    private AccessControl getParentAccessControl()\n    {\n        return super.getAccessControl();\n    }\n    @Override\n    protected void postResolveChildren()\n    {\n        super.postResolveChildren();\n        addChangeListener(_accessControlProviderListener);\n        Collection<VirtualHostAccessControlProvider> accessControlProviders = getChildren(VirtualHostAccessControlProvider.class);\n        if (!accessControlProviders.isEmpty())\n        {\n            accessControlProviders.forEach(child -> child.addChangeListener(_accessControlProviderListener));\n        }\n    }\n<fim_suffix>    private void validateNodeAutoCreationPolicy(final NodeAutoCreationPolicy policy)\n    {\n        String pattern = policy.getPattern();\n        if(pattern == null)\n        {\n            throw new IllegalArgumentException(\"The 'pattern' attribute of a NodeAutoCreationPolicy MUST be supplied: \" + policy);\n        }\n        try\n        {\n            Pattern.compile(pattern);\n        }\n        catch (PatternSyntaxException e)\n        {\n            throw new IllegalArgumentException(\"The 'pattern' attribute of a NodeAutoCreationPolicy MUST be a valid \"\n                                               + \"Java Regular Expression Pattern, the value '\" + pattern + \"' is not: \" + policy);\n        }\n        String nodeType = policy.getNodeType();\n        Class<? extends ConfiguredObject> sourceClass = null;\n        for (Class<? extends ConfiguredObject> childClass : getModel().getChildTypes(getCategoryClass()))\n        {\n            if (childClass.getSimpleName().equalsIgnoreCase(nodeType.trim()))\n            {\n                sourceClass = childClass;\n                break;\n            }\n        }\n        if(sourceClass == null)\n        {\n            throw new IllegalArgumentException(\"The node type of a NodeAutoCreationPolicy must be a valid child type \"\n                                               + \"of a VirtualHost, '\" + nodeType + \"' is not.\");\n        }\n        if(policy.isCreatedOnConsume() && !MessageSource.class.isAssignableFrom(sourceClass))\n        {\n            throw new IllegalArgumentException(\"A NodeAutoCreationPolicy which creates nodes on consume must have a \"\n                                               + \"nodeType which implements MessageSource, '\" + nodeType + \"' does not.\");\n        }\n        if(policy.isCreatedOnPublish() && !MessageDestination.class.isAssignableFrom(sourceClass))\n        {\n            throw new IllegalArgumentException(\"A NodeAutoCreationPolicy which creates nodes on publish must have a \"\n                                               + \"nodeType which implements MessageDestination, '\" + nodeType + \"' does not.\");\n        }\n        if(!(policy.isCreatedOnConsume() || policy.isCreatedOnPublish()))\n        {\n            throw new IllegalArgumentException(\"A NodeAutoCreationPolicy must create on consume, create on publish or both.\");\n        }\n    }<fim_middle>// function below has no smell\n"}