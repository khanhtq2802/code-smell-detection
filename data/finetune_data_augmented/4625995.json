{"text": "<fim_prefix>\n<fim_suffix>public abstract class AsynchronousFileIOChannel<T, R extends IORequest> extends AbstractFileIOChannel {\n\tprivate final Object listenerLock = new Object();\n\t/**\n\t * The lock that is used during closing to synchronize the thread that waits for all\n\t * requests to be handled with the asynchronous I/O thread.\n\t */\n\tprotected final Object closeLock = new Object();\n\t/** A request queue for submitting asynchronous requests to the corresponding IO worker thread. */\n\tprotected final RequestQueue<R> requestQueue;\n\t/** An atomic integer that counts the number of requests that we still wait for to return. */\n\tprotected final AtomicInteger requestsNotReturned = new AtomicInteger(0);\n\t/** Handler for completed requests */\n\tprotected final RequestDoneCallback<T> resultHandler;\n\t/** An exception that was encountered by the asynchronous request handling thread. */\n\tprotected volatile IOException exception;\n\t/** Flag marking this channel as closed */\n\tprotected volatile boolean closed;\n\tprivate NotificationListener allRequestsProcessedListener;\n\t// --------------------------------------------------------------------------------------------\n\t/**\n\t * Creates a new channel access to the path indicated by the given ID. The channel accepts buffers to be\n\t * read/written and hands them to the asynchronous I/O thread. After being processed, the buffers\n\t * are returned by adding the to the given queue.\n\t *\n\t * @param channelID    The id describing the path of the file that the channel accessed.\n\t * @param requestQueue The queue that this channel hands its IO requests to.\n\t * @param callback     The callback to be invoked when a request is done.\n\t * @param writeEnabled Flag describing whether the channel should be opened in read/write mode, rather\n\t *                     than in read-only mode.\n\t * @throws IOException Thrown, if the channel could no be opened.\n\t */\n\tprotected AsynchronousFileIOChannel(FileIOChannel.ID channelID, RequestQueue<R> requestQueue, \n\t\t\tRequestDoneCallback<T> callback, boolean writeEnabled) throws IOException\n\t{\n\t\tsuper(channelID, writeEnabled);\n\t\tthis.requestQueue = checkNotNull(requestQueue);\n\t\tthis.resultHandler = checkNotNull(callback);\n\t}\n\t// --------------------------------------------------------------------------------------------\n\t@Override\n\tpublic boolean isClosed() {\n\t\treturn this.closed;\n\t}\n\t/**\n\t * Closes the channel and waits until all pending asynchronous requests are processed. The\n\t * underlying <code>FileChannel</code> is closed even if an exception interrupts the closing.\n\t *\n\t * <p> <strong>Important:</strong> the {@link #isClosed()} method returns <code>true</code>\n\t * immediately after this method has been called even when there are outstanding requests.\n\t *\n\t * @throws IOException Thrown, if an I/O exception occurred while waiting for the buffers, or if\n\t *                     the closing was interrupted.\n\t */\n\t@Override\n\tpublic void close() throws IOException {\n\t\t// atomically set the close flag\n\t\tsynchronized (this.closeLock) {\n\t\t\tif (this.closed) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.closed = true;\n\t\t\ttry {\n\t\t\t\t// wait until as many buffers have been returned as were written\n\t\t\t\t// only then is everything guaranteed to be consistent.\n\t\t\t\twhile (this.requestsNotReturned.get() > 0) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// we add a timeout here, because it is not guaranteed that the\n\t\t\t\t\t\t// decrementing during buffer return and the check here are deadlock free.\n\t\t\t\t\t\t// the deadlock situation is however unlikely and caught by the timeout\n\t\t\t\t\t\tthis.closeLock.wait(1000);\n\t\t\t\t\t\tcheckErroneous();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (InterruptedException iex) {\n\t\t\t\t\t\tthrow new IOException(\"Closing of asynchronous file channel was interrupted.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Additional check because we might have skipped the while loop\n\t\t\t\tcheckErroneous();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\t// close the file\n\t\t\t\tif (this.fileChannel.isOpen()) {\n\t\t\t\t\tthis.fileChannel.close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * This method waits for all pending asynchronous requests to return. When the\n\t * last request has returned, the channel is closed and deleted.\n\t * <p>\n\t * Even if an exception interrupts the closing, such that not all request are handled,\n\t * the underlying <tt>FileChannel</tt> is closed and deleted.\n\t *\n\t * @throws IOException Thrown, if an I/O exception occurred while waiting for the buffers, or if the closing was interrupted.\n\t */\n\t@Override\n\tpublic void closeAndDelete() throws IOException {\n\t\ttry {\n\t\t\tclose();\n\t\t}\n\t\tfinally {\n\t\t\tdeleteChannel();\n\t\t}\n\t}\n\t/**\n\t * Checks the exception state of this channel. The channel is erroneous, if one of its requests could not\n\t * be processed correctly.\n\t *\n\t * @throws IOException Thrown, if the channel is erroneous. The thrown exception contains the original exception\n\t *                     that defined the erroneous state as its cause.\n\t */\n\tpublic final void checkErroneous() throws IOException {\n\t\tif (this.exception != null) {\n\t\t\tthrow this.exception;\n\t\t}\n\t}\n\t/**\n\t * Handles a processed <tt>Buffer</tt>. This method is invoked by the\n\t * asynchronous IO worker threads upon completion of the IO request with the\n\t * provided buffer and/or an exception that occurred while processing the request\n\t * for that buffer.\n\t *\n\t * @param buffer The buffer to be processed.\n\t * @param ex     The exception that occurred in the I/O threads when processing the buffer's request.\n\t */\n\tfinal protected void handleProcessedBuffer(T buffer, IOException ex) {\n\t\tif (buffer == null) {\n\t\t\treturn;\n\t\t}\n\t\t// even if the callbacks throw an error, we need to maintain our bookkeeping\n\t\ttry {\n\t\t\tif (ex != null && this.exception == null) {\n\t\t\t\tthis.exception = ex;\n\t\t\t\tthis.resultHandler.requestFailed(buffer, ex);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.resultHandler.requestSuccessful(buffer);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tNotificationListener listener = null;\n\t\t\t// Decrement the number of outstanding requests. If we are currently closing, notify the\n\t\t\t// waiters. If there is a listener, notify her as well.\n\t\t\tsynchronized (this.closeLock) {\n\t\t\t\tif (this.requestsNotReturned.decrementAndGet() == 0) {\n\t\t\t\t\tif (this.closed) {\n\t\t\t\t\t\tthis.closeLock.notifyAll();\n\t\t\t\t\t}\n\t\t\t\t\tsynchronized (listenerLock) {\n\t\t\t\t\t\tlistener = allRequestsProcessedListener;\n\t\t\t\t\t\tallRequestsProcessedListener = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (listener != null) {\n\t\t\t\tlistener.onNotification();\n\t\t\t}\n\t\t}\n\t}\n\tfinal protected void addRequest(R request) throws IOException {\n\t\t// check the error state of this channel\n\t\tcheckErroneous();\n\t\t// write the current buffer and get the next one\n\t\tthis.requestsNotReturned.incrementAndGet();\n\t\tif (this.closed || this.requestQueue.isClosed()) {\n\t\t\t// if we found ourselves closed after the counter increment,\n\t\t\t// decrement the counter again and do not forward the request\n\t\t\tthis.requestsNotReturned.decrementAndGet();\n\t\t\tfinal NotificationListener listener;\n\t\t\tsynchronized (listenerLock) {\n\t\t\t\tlistener = allRequestsProcessedListener;\n\t\t\t\tallRequestsProcessedListener = null;\n\t\t\t}\n\t\t\tif (listener != null) {\n\t\t\t\tlistener.onNotification();\n\t\t\t}\n\t\t\tthrow new IOException(\"I/O channel already closed. Could not fulfill: \" + request);\n\t\t}\n\t\tthis.requestQueue.add(request);\n\t}\n\t/**\n\t * Registers a listener to be notified when all outstanding requests have been processed.\n\t *\n\t * <p> New requests can arrive right after the listener got notified. Therefore, it is not safe\n\t * to assume that the number of outstanding requests is still zero after a notification unless\n\t * there was a close right before the listener got called.\n\t *\n\t * <p> Returns <code>true</code>, if the registration was successful. A registration can fail,\n\t * if there are no outstanding requests when trying to register a listener.\n\t */\n\tprotected boolean registerAllRequestsProcessedListener(NotificationListener listener) throws IOException {\n\t\tcheckNotNull(listener);\n\t\tsynchronized (listenerLock) {\n\t\t\tif (allRequestsProcessedListener == null) {\n\t\t\t\t// There was a race with the processing of the last outstanding request<fim_middle>// class below has no smell\n"}