{"text": "<fim_prefix>\n<fim_suffix>public class CtagsReader {\n    /**\n     * Matches the Unicode word that occurs last in a string, ignoring any\n     * trailing whitespace or non-word characters, and makes it accessible as\n     * the first capture, {@code mtch.groups(1)}:\n     * <pre>\n     * {@code\n     * (?U)(\\w+)[\\W\\s]*$\n     * }\n     * </pre>\n     * (Edit above and paste below [in NetBeans] for easy String escaping.)\n     */\n    private static final Pattern LAST_UWORD = Pattern.compile(\n        \"(?U)(\\\\w+)[\\\\W\\\\s]*$\");\n    /**\n     * Matches a Unicode word character:\n     * <pre>\n     * {@code\n     * (?U)\\w\n     * }\n     * </pre>\n     * (Edit above and paste below [in NetBeans] for easy String escaping.)\n     */\n    private static final Pattern WORD_CHAR = Pattern.compile(\"(?U)\\\\w\");\n    private static final Logger LOGGER = LoggerFactory.getLogger(\n        CtagsReader.class);\n    /** A value indicating empty method body in tags, so skip it */\n    private static final int MIN_METHOD_LINE_LENGTH = 6;\n    /**\n     * 96 is used by universal ctags for some lines, but it's too low,\n     * OpenGrok can theoretically handle 50000 with 8G heap. Also this might\n     * break scopes functionality, if set too low.\n     */\n    private static final int MAX_METHOD_LINE_LENGTH = 1030;\n    private static final int MAX_CUT_LENGTH = 2000;\n    /**\n     * E.g. krb5 src/kdc/kdc_authdata.c has a signature for handle_authdata()\n     * split across twelve lines, so use double that number.\n     */\n    private static final int MAX_CUT_LINES = 24;\n    private final EnumMap<tagFields, String> fields = new EnumMap<>(\n        tagFields.class);\n    private final Definitions defs = new Definitions();\n    private Supplier<SourceSplitter> splitterSupplier;\n    private boolean triedSplitterSupplier;\n    private SourceSplitter splitter;\n    private long cutCacheKey;\n    private String cutCacheValue;\n    private int tabSize;\n    /**\n     * This should mimic\n     * https://github.com/universal-ctags/ctags/blob/master/docs/format.rst or\n     * http://ctags.sourceforge.net/FORMAT (for backwards compatibility).\n     * Uncomment only those that are used ... (to avoid populating the hashmap\n     * for every record).\n     */\n    public enum tagFields {\n//        ARITY(\"arity\"),\n        CLASS(\"class\"),\n        //        INHERIT(\"inherit\"), //this is not defined in above format docs, but both universal and exuberant ctags use it\n        //        INTERFACE(\"interface\"), //this is not defined in above format docs, but both universal and exuberant ctags use it\n        //        ENUM(\"enum\"),\n        //        FILE(\"file\"),\n        //        FUNCTION(\"function\"),\n        //        KIND(\"kind\"),\n        LINE(\"line\"),\n        //        NAMESPACE(\"namespace\"), //this is not defined in above format docs, but both universal and exuberant ctags use it\n        //        PROGRAM(\"program\"), //this is not defined in above format docs, but both universal and exuberant ctags use it\n        SIGNATURE(\"signature\");\n//        STRUCT(\"struct\"),\n//        TYPEREF(\"typeref\"),\n//        UNION(\"union\");\n        //NOTE: if you edit above, always consult below charCmpEndOffset\n        private final String name;\n        /**\n         * Sets {@code this.name} to {@code name}.\n         * @param name the assignment value\n         */\n        tagFields(String name) {\n            this.name = name;\n        }\n        /**\n         * N.b. make this MAX. 8 chars! (backwards compat to DOS/Win).\n         * 1 - means only 2 first chars are compared.\n         * <p>This is very important, we only compare that amount of chars from\n         * field types with input to save time. This number has to be long\n         * enough to get rid of disambiguation.\n         * <p>TODO:\n         * <p>NOTE this is a big tradeoff in terms of input data, e.g. field\n         * \"find\" will be considered \"file\" and overwrite the value, so if\n         * ctags will send us buggy input. We will output buggy data TOO! NO\n         * VALIDATION happens of input - but then we gain LOTS of speed, due to\n         * not comparing the same field names again and again fully.\n         */\n        public static int charCmpEndOffset = 0;\n        /**\n         * Quickly get if the field name matches allowed/consumed ones\n         * @param fullName the name to look up\n         * @return a defined value, or null if unmatched\n         */\n        public static CtagsReader.tagFields quickValueOf(String fullName) {\n            int i;\n            boolean match;\n            for (tagFields x : tagFields.values()) {\n                match = true;\n                for (i = 0; i <= charCmpEndOffset; i++) {\n                    if (x.name.charAt(i) != fullName.charAt(i)) {\n                        match = false;\n                        break;\n                    }\n                }\n                if (match) {\n                    return x;\n                }\n            }\n            return null;\n        }\n    }\n    public int getTabSize() {\n        return tabSize;\n    }\n    public void setTabSize(int tabSize) {\n        this.tabSize = tabSize;\n    }\n    /**\n     * Gets the instance's definitions.\n     * @return a defined instance\n     */\n    public Definitions getDefinitions() {\n        return defs;\n    }\n    /**\n     * Sets the supplier of a {@link SourceSplitter} to use when ctags pattern\n     * is insufficient, and the reader could use the source data.\n     * <p>\n     * N.b. because an I/O exception can occur, the supplier may return\n     * {@code null}, which the {@link CtagsReader} handles.\n     * @param obj defined instance or {@code null}\n     */\n    public void setSplitterSupplier(Supplier<SourceSplitter> obj) {\n        splitter = null;\n        triedSplitterSupplier = false;\n        splitterSupplier = obj;\n    }\n    /**\n     * Reads a line into the instance's definitions.\n     * @param tagLine a defined line or null to no-op\n     */\n    public void readLine(String tagLine) {\n        if (tagLine == null) {\n            return;\n        }\n        int p = tagLine.indexOf('\\t');\n        if (p <= 0) {\n            //log.fine(\"SKIPPING LINE - NO TAB\");\n            return;\n        }\n        String def = tagLine.substring(0, p);\n        int mstart = tagLine.indexOf('\\t', p + 1);\n        String kind = null;\n        int lp = tagLine.length();\n        while ((p = tagLine.lastIndexOf('\\t', lp - 1)) > 0) {\n            //log.fine(\" p = \" + p + \" lp = \" + lp);\n            String fld = tagLine.substring(p + 1, lp);\n            //log.fine(\"FIELD===\" + fld);\n            lp = p;\n            int sep = fld.indexOf(':');\n            if (sep != -1) {\n                tagFields pos = tagFields.quickValueOf(fld);\n                if (pos != null) {\n                    String val = fld.substring(sep + 1);\n                    fields.put(pos, val);\n                } else {\n                    //unknown field name\n                    //don't log on purpose, since we don't consume all possible\n                    // fields, so just ignore this error for now\n//                    LOGGER.log(Level.WARNING, \"Unknown field name found: {0}\",\n//                        fld.substring(0, sep - 1));\n                }\n            } else {\n                //TODO no separator, assume this is the kind\n                kind = fld;\n                break;\n            }\n        }\n        String lnum = fields.get(tagFields.LINE);\n        String signature = fields.get(tagFields.SIGNATURE);\n        String classInher = fields.get(tagFields.CLASS);\n        final String whole;\n        final String match;\n        int mlength = p - mstart;\n        if ((p > 0) && (mlength > MIN_METHOD_LINE_LENGTH)) {\n            whole = cutPattern(tagLine, mstart, p);\n            if (mlength < MAX_METHOD_LINE_LENGTH) {\n                match = whole.replaceAll(\"[ \\t]+\", \" \");\n                //TODO per format we should also recognize \\r and \\n\n            } else {\n                LOGGER.log(Level.FINEST, \"Ctags: stripping method\" +\n                    \" body for def {0} line {1}(scopes/highlight\" +\n                    \" might break)\", new Object[]{def, lnum});\n                match = whole.substring(0, MAX_METHOD_LINE_LENGTH).replaceAll(\n                    \"[ \\t]+\", \" \");\n            }<fim_middle>// class below is blob\n"}