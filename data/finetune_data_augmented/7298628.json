{"text": "<fim_prefix>\n<fim_suffix>public class DefaultMessagePropertiesConverter implements MessagePropertiesConverter {\n\tprivate static final int DEFAULT_LONG_STRING_LIMIT = 1024;\n\tprivate final int longStringLimit;\n\tprivate final boolean convertLongLongStrings;\n\t/**\n\t * Construct an instance where {@link LongString}s will be returned\n\t * unconverted when longer than 1024 bytes.\n\t */\n\tpublic DefaultMessagePropertiesConverter() {\n\t\tthis(DEFAULT_LONG_STRING_LIMIT, false);\n\t}\n\t/**\n\t * Construct an instance where {@link LongString}s will be returned\n\t * unconverted when longer than this limit.\n\t * @param longStringLimit the limit.\n\t * @since 1.4.4\n\t */\n\tpublic DefaultMessagePropertiesConverter(int longStringLimit) {\n\t\tthis(longStringLimit, false);\n\t}\n\t/**\n\t * Construct an instance where {@link LongString}s will be returned\n\t * unconverted or as a {@link java.io.DataInputStream} when longer than this limit.\n\t * Use this constructor with 'true' to restore pre-1.6 behavior.\n\t * @param longStringLimit the limit.\n\t * @param convertLongLongStrings {@link LongString} when false,\n\t * {@link java.io.DataInputStream} when true.\n\t * @since 1.6\n\t */\n\tpublic DefaultMessagePropertiesConverter(int longStringLimit, boolean convertLongLongStrings) {\n\t\tthis.longStringLimit = longStringLimit;\n\t\tthis.convertLongLongStrings = convertLongLongStrings;\n\t}\n\t@Override\n\tpublic MessageProperties toMessageProperties(final BasicProperties source, final Envelope envelope,\n\t\t\tfinal String charset) {\n\t\tMessageProperties target = new MessageProperties();\n\t\tMap<String, Object> headers = source.getHeaders();\n\t\tif (!CollectionUtils.isEmpty(headers)) {\n\t\t\tfor (Map.Entry<String, Object> entry : headers.entrySet()) {\n\t\t\t\tString key = entry.getKey();\n\t\t\t\tif (MessageProperties.X_DELAY.equals(key)) {\n\t\t\t\t\tObject value = entry.getValue();\n\t\t\t\t\tif (value instanceof Integer) {\n\t\t\t\t\t\ttarget.setReceivedDelay((Integer) value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttarget.setHeader(key, convertLongStringIfNecessary(entry.getValue(), charset));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttarget.setTimestamp(source.getTimestamp());\n\t\ttarget.setMessageId(source.getMessageId());\n\t\ttarget.setReceivedUserId(source.getUserId());\n\t\ttarget.setAppId(source.getAppId());\n\t\ttarget.setClusterId(source.getClusterId());\n\t\ttarget.setType(source.getType());\n\t\tInteger deliveryMode = source.getDeliveryMode();\n\t\tif (deliveryMode != null) {\n\t\t\ttarget.setReceivedDeliveryMode(MessageDeliveryMode.fromInt(deliveryMode));\n\t\t}\n\t\ttarget.setDeliveryMode(null);\n\t\ttarget.setExpiration(source.getExpiration());\n\t\ttarget.setPriority(source.getPriority());\n\t\ttarget.setContentType(source.getContentType());\n\t\ttarget.setContentEncoding(source.getContentEncoding());\n\t\tString correlationId = source.getCorrelationId();\n\t\tif (StringUtils.hasText(correlationId)) {\n\t\t\ttarget.setCorrelationId(source.getCorrelationId());\n\t\t}\n\t\tString replyTo = source.getReplyTo();\n\t\tif (replyTo != null) {\n\t\t\ttarget.setReplyTo(replyTo);\n\t\t}\n\t\tif (envelope != null) {\n\t\t\ttarget.setReceivedExchange(envelope.getExchange());\n\t\t\ttarget.setReceivedRoutingKey(envelope.getRoutingKey());\n\t\t\ttarget.setRedelivered(envelope.isRedeliver());\n\t\t\ttarget.setDeliveryTag(envelope.getDeliveryTag());\n\t\t}\n\t\treturn target;\n\t}\n\t@Override\n\tpublic BasicProperties fromMessageProperties(final MessageProperties source, final String charset) {\n\t\tBasicProperties.Builder target = new BasicProperties.Builder();\n\t\ttarget.headers(this.convertHeadersIfNecessary(source.getHeaders()))\n\t\t\t.timestamp(source.getTimestamp())\n\t\t\t.messageId(source.getMessageId())\n\t\t\t.userId(source.getUserId())\n\t\t\t.appId(source.getAppId())\n\t\t\t.clusterId(source.getClusterId())\n\t\t\t.type(source.getType());\n\t\tMessageDeliveryMode deliveryMode = source.getDeliveryMode();\n\t\tif (deliveryMode != null) {\n\t\t\ttarget.deliveryMode(MessageDeliveryMode.toInt(deliveryMode));\n\t\t}\n\t\ttarget.expiration(source.getExpiration())\n\t\t\t.priority(source.getPriority())\n\t\t\t.contentType(source.getContentType())\n\t\t\t.contentEncoding(source.getContentEncoding());\n\t\tString correlationId = source.getCorrelationId();\n\t\tif (StringUtils.hasText(correlationId)) {\n\t\t\ttarget.correlationId(correlationId);\n\t\t}\n\t\tString replyTo = source.getReplyTo();\n\t\tif (replyTo != null) {\n\t\t\ttarget.replyTo(replyTo);\n\t\t}\n\t\treturn target.build();\n\t}\n\tprivate Map<String, Object> convertHeadersIfNecessary(Map<String, Object> headers) {\n\t\tif (CollectionUtils.isEmpty(headers)) {\n\t\t\treturn Collections.<String, Object>emptyMap();\n\t\t}\n\t\tMap<String, Object> writableHeaders = new HashMap<String, Object>();\n\t\tfor (Map.Entry<String, Object> entry : headers.entrySet()) {\n\t\t\twritableHeaders.put(entry.getKey(), this.convertHeaderValueIfNecessary(entry.getValue()));\n\t\t}\n\t\treturn writableHeaders;\n\t}\n\t/**\n\t * Converts a header value to a String if the value type is unsupported by AMQP, also handling values\n\t * nested inside Lists or Maps.\n\t * <p> {@code null} values are passed through, although Rabbit client will throw an IllegalArgumentException.\n\t * @param valueArg the value.\n\t * @return the converted value.\n\t */\n\t@Nullable // NOSONAR complexity\n\tprivate Object convertHeaderValueIfNecessary(@Nullable Object valueArg) {\n\t\tObject value = valueArg;\n\t\tboolean valid = (value instanceof String) || (value instanceof byte[]) // NOSONAR boolean complexity\n\t\t\t\t|| (value instanceof Boolean)\n\t\t\t\t|| (value instanceof LongString) || (value instanceof Integer) || (value instanceof Long)\n\t\t\t\t|| (value instanceof Float) || (value instanceof Double) || (value instanceof BigDecimal)\n\t\t\t\t|| (value instanceof Short) || (value instanceof Byte) || (value instanceof Date)\n\t\t\t\t|| (value instanceof List) || (value instanceof Map) || (value instanceof Object[]);\n\t\tif (!valid && value != null) {\n\t\t\tvalue = value.toString();\n\t\t}\n\t\telse if (value instanceof Object[]) {\n\t\t\tObject[] array = (Object[]) value;\n\t\t\tObject[] writableArray = new Object[array.length];\n\t\t\tfor (int i = 0; i < writableArray.length; i++) {\n\t\t\t\twritableArray[i] = convertHeaderValueIfNecessary(array[i]);\n\t\t\t}\n\t\t\tvalue = writableArray;\n\t\t}\n\t\telse if (value instanceof List<?>) {\n\t\t\tList<Object> writableList = new ArrayList<Object>(((List<?>) value).size());\n\t\t\tfor (Object listValue : (List<?>) value) {\n\t\t\t\twritableList.add(convertHeaderValueIfNecessary(listValue));\n\t\t\t}\n\t\t\tvalue = writableList;\n\t\t}\n\t\telse if (value instanceof Map<?, ?>) {\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tMap<String, Object> originalMap = (Map<String, Object>) value;\n\t\t\tMap<String, Object> writableMap = new HashMap<String, Object>(originalMap.size());\n\t\t\tfor (Map.Entry<String, Object> entry : originalMap.entrySet()) {\n\t\t\t\twritableMap.put(entry.getKey(), this.convertHeaderValueIfNecessary(entry.getValue()));\n\t\t\t}\n\t\t\tvalue = writableMap;\n\t\t}\n\t\treturn value;\n\t}\n\t/**\n\t * Converts a LongString value to either a String or DataInputStream based on a\n\t * length-driven threshold. If the length is {@link #longStringLimit} bytes or less, a\n\t * String will be returned, otherwise a DataInputStream is returned or the {@link LongString}\n\t * is returned unconverted if {@link #convertLongLongStrings} is true.\n\t * @param longString the long string.\n\t * @param charset the charset.\n\t * @return the converted string.\n\t */\n\tprivate Object convertLongString(LongString longString, String charset) {\n\t\ttry {\n\t\t\tif (longString.length() <= this.longStringLimit) {\n\t\t\t\treturn new String(longString.getBytes(), charset);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn this.convertLongLongStrings ? longString.getStream() : longString;\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {<fim_middle>// class below has no smell\n"}