{"text": "<fim_prefix>import com.google.common.base.Objects;\nimport com.google.common.base.Optional;\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Supplier;\nimport com.google.common.collect.AbstractIterator;\nimport com.google.common.collect.ImmutableSet;\n/** Like Guava Optional but permitting null and permitting errors to be thrown. */\npublic abstract class Maybe<T> implements Serializable, Supplier<T> {\n    private static final long serialVersionUID = -6372099069863179019L;\n    /** Returns an absent indicator. No message is available and access does not include any reference to this creation.\n     * Therefore it is fast and simple, but hard to work with if someone might {@link #get()} it and want a useful exception.\n     * See also {@link #absentNoTrace(String)} to include a message with very low overhead,\n     * or {@link #absentWithTrace(String)} or {@link #absent(Throwable)} for more control over the exception thrown. \n     */\n    public static <T> Maybe<T> absent() {\n        return new Maybe.Absent<T>();\n    }\n    /** Convenience for {@link #absentWithTrace(String)}. */\n    public static <T> Maybe<T> absent(final String message) {\n        return absent(new IllegalStateException(message));\n    }\n    /** Creates an absent whose {@link #get()} throws an {@link IllegalStateException} with the indicated message.\n     * Both stack traces (the cause and the callers) are provided, which can be quite handy,\n     * but comparatively expensive as the cause stack trace has to generated when this method is invoked,\n     * even if it is never accessed. See also {@link #absentNoTrace(String)} and {@link #absent(Throwable)}. */\n    public static <T> Maybe<T> absentWithTrace(final String message) {\n        return absent(new IllegalStateException(message));\n    }\n    /** Creates an absent whose get throws an {@link IllegalStateException} with the indicated message,\n     * but not a stack trace for the calling location. As stack traces can be comparatively expensive\n     * this is useful for efficiency, but it can make debugging harder as the origin of the absence is not kept,\n     * in contrast to {@link #absentWithTrace(String)} and {@link #absent(Throwable)}. */\n    public static <T> Maybe<T> absentNoTrace(final String message) {\n        return absent(new IllegalStateExceptionSupplier(message));\n    }\n    /** As {@link #absentWithTrace(String)} but using the provided exception instead of this location\n     * as the cause, and a string based on this cause as the message on the {@link IllegalStateException}\n     * thrown if a user does a {@link #get()}. \n     * Useful if an {@link Exception} has already been generated (and no overhead)\n     * or if you want to supply a specific cause as in <code>absent(new MyException(...))</code>\n     * (but there is the Exception creation overhead there). */\n    public static <T> Maybe<T> absent(final Throwable cause) {\n        return absent(new IllegalStateExceptionSupplier(cause));\n    }\n    /** As {@link #absent(Throwable)} but using the given message as the message on the {@link IllegalStateException}\n     * thrown if a user does a {@link #get()}. */\n    public static <T> Maybe<T> absent(final String message, final Throwable cause) {\n        return absent(new IllegalStateExceptionSupplier(message, cause));\n    }\n    /** Creates an absent whose {@link #get()} throws a {@link RuntimeException} \n     * generated on demand from the given supplier */\n    public static <T> Maybe<T> absent(final Supplier<? extends RuntimeException> exceptionSupplier) {\n        return new Absent<T>(Preconditions.checkNotNull(exceptionSupplier));\n    }\n    /** as {@link #absentNull(String)} but with a generic message */\n    public static <T> Maybe<T> absentNull() {\n        return absentNull(\"disallowed null value\");\n    }\n    /** like {@link #absent(String)} but {@link #isNull()} will return true on the result. */\n    public static <T> Maybe<T> absentNull(String message) {\n        return new AbsentNull<T>(message);\n    }\n    /** Creates a new Maybe object which is present. \n     * The argument may be null and the object still present, \n     * which may be confusing in some contexts\n     * (traditional {@link Optional} usages) but\n     * may be natural in others (where null is a valid value, distinguished from no value set). \n     * See also {@link #ofDisallowingNull(Object)}. */\n    public static <T> Maybe<T> ofAllowingNull(@Nullable T value) {\n        return new Present<T>(value);\n    }\n    /** Creates a new Maybe object which is present if and only if the argument is not null.\n     * If the argument is null, then an {@link #absentNull()} is returned,\n     * on which {@link #isNull()} will be true. */\n    public static <T> Maybe<T> ofDisallowingNull(@Nullable T value) {\n        if (value==null) return absentNull();\n        return new Present<T>(value);\n    }\n    /** Creates a new Maybe object.\n     * Currently this uses {@link #ofAllowingNull(Object)} semantics,\n     * but it is recommended to use that method for clarity \n     * if the argument might be null. */\n    // note: Optional throws if null is supplied; we might want to do the same here\n    public static <T> Maybe<T> of(@Nullable T value) {\n        return ofAllowingNull(value);\n    }\n    /**\n     * Casts the given value to the desired type. This is valid because {@link Maybe} is immutable,\n     * so things like {@code Maybe<Object>} is a super-type of {@code Maybe<String>}.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <T> Maybe<T> cast(Maybe<? extends T> value) {\n        return (Maybe<T>) value;\n    }\n    /** Converts the given {@link Maybe} to {@link Optional}, failing if this {@link Maybe} contains null. */\n    public Optional<T> toOptional() {\n        if (isPresent()) return Optional.of(get());\n        return Optional.absent();\n    }\n    /** Creates a new Maybe object using {@link #ofDisallowingNull(Object)} semantics. \n     * It is recommended to use that method for clarity. \n     * This method is provided for consistency with {@link Optional#fromNullable(Object)}. */\n    public static <T> Maybe<T> fromNullable(@Nullable T value) {\n        return ofDisallowingNull(value);\n    }\n    /** Creates a new Maybe object out of the {@link Optional} argument */\n    public static <T> Maybe<T> fromOptional(Optional<T> value) {\n        return Maybe.fromNullable(value.orNull());\n    }\n    /** creates an instance wrapping a {@link SoftReference}, so it might go absent later on.\n     * if null is supplied the result is a present null. */\n    public static <T> Maybe<T> soft(@Nonnull T value) {\n        return softThen(value, null);\n    }\n    /** creates an instance wrapping a {@link SoftReference}, using the second item given \n     * if the first argument is dereferenced.\n     * however if the first argument is null, this is a permanent present null,\n     * as {@link #of(Object)} with null. */\n    public static <T> Maybe<T> softThen(T value, Maybe<T> ifEmpty) {\n        if (value==null) return of((T)null);\n        return new SoftlyPresent<T>(value).usingAfterExpiry(ifEmpty);\n    }\n    public static <T> Maybe<T> of(final Optional<T> value) {\n        if (value.isPresent()) return new AbstractPresent<T>() {\n            private static final long serialVersionUID = -5735268814211401356L;\n            @Override\n            public T get() {\n                return value.get();\n            }\n        };\n        return absent();\n    }\n    @SuppressWarnings(\"unused\")\n    private static <T> Maybe<T> ofOldKeptForDeserializationOfAnonymousInnerClass(final Supplier<T> value) {\n        return new AbstractPresent<T>() {\n            private static final long serialVersionUID = -5735268814211401356L;\n            @Override\n            public T get() {\n                return value.get();\n            }\n        };\n    }\n    public static <T> Maybe<T> of(final Supplier<T> value) {\n        return new MaybeSupplier<T>(value);\n    }\n<fim_suffix>    public static class MaybeSupplier<T> extends AbstractPresent<T> {\n        private static final long serialVersionUID = -823731500051341455L;\n        private final Supplier<T> supplier;\n        public MaybeSupplier(Supplier<T> value) {\n            this.supplier = value;\n        }\n        @Override\n        public T get() {\n            return supplier.get();\n        }\n        public Supplier<T> getSupplier() {\n            return supplier;\n        }\n    }<fim_middle>// class below has no smell\n"}