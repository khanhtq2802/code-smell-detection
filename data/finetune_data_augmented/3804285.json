{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.storm.starter.tools;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.Lists;\n\nimport java.io.Serializable;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Rankings implements Serializable {\n    \n    private static final long serialVersionUID = -1549827195410578903L;\n    private static final int  DEFAULT_COUNT    = 10;\n    \n    private final int            maxSize;\n    private final List<Rankable> rankedItems = Lists.newArrayList();\n    \n    public Rankings() {\n        this(DEFAULT_COUNT);\n    }\n    \n    public Rankings(int topN) {\n        if (topN < 1) {\n            throw new IllegalArgumentException(\"topN must be >= 1\");\n        }\n        maxSize = topN;\n    }\n    \n    /**\n     * Copy constructor.\n     * \n     * @param other\n     */\n    public Rankings(Rankings other) {\n        this(other.maxSize());\n        updateWith(other);\n    }\n    \n    /**\n     * @return the maximum possible number (size) of ranked objects this\n     *         instance can hold\n     */\n    public int maxSize() {\n        return maxSize;\n    }\n    \n    /**\n     * @return the number (size) of ranked objects this instance is currently\n     *         holding\n     */\n    public int size() {\n        return rankedItems.size();\n    }\n    \n    /**\n     * The returned defensive copy is only \"somewhat\" defensive. We do, for\n     * instance, return a defensive copy of the enclosing List instance, and we\n     * do try to defensively copy any contained Rankable objects, too. However,\n     * the contract of {@link org.apache.storm.starter.tools.Rankable#copy()}\n     * does not guarantee that any Object's embedded within a Rankable will be\n     * defensively copied, too.\n     *\n     * @return a somewhat defensive copy of ranked items\n     */\n    public List<Rankable> getRankings() {\n        List<Rankable> copy = Lists.newLinkedList();\n        for (Rankable r : rankedItems) {\n            copy.add(r.copy());\n        }\n        return ImmutableList.copyOf(copy);\n    }\n    \n    public void updateWith(Rankings other) {\n        for (Rankable r : other.getRankings()) {\n            updateWith(r);\n        }\n    }\n    \n    public void updateWith(Rankable r) {\n        synchronized (rankedItems) {\n            addOrReplace(r);\n            rerank();\n            shrinkRankingsIfNeeded();\n        }\n    }\n    \n    private void addOrReplace(Rankable r) {\n        Integer rank = findRankOf(r);\n        if (rank != null) {\n            rankedItems.set(rank, r);\n        } else {\n            rankedItems.add(r);\n        }\n    }\n    \n<fim_suffix>    private Integer findRankOf(Rankable r) {\n        Object tag = r.getObject();\n        for (int rank = 0; rank < rankedItems.size(); rank++) {\n            Object cur = rankedItems.get(rank).getObject();\n            if (cur.equals(tag)) {\n                return rank;\n            }\n        }\n        return null;\n    }\n    \n    private void rerank() {\n        Collections.sort(rankedItems);\n        Collections.reverse(rankedItems);\n    }\n    \n    private void shrinkRankingsIfNeeded() {\n        if (rankedItems.size() > maxSize) {\n            rankedItems.remove(maxSize);\n        }\n    }\n    \n    /**\n     * Removes ranking entries that have a count of zero.\n     */\n    public void pruneZeroCounts() {\n        int i = 0;\n        while (i < rankedItems.size()) {\n            if (rankedItems.get(i).getCount() == 0) {\n                rankedItems.remove(i);\n            } else {\n                i++;\n            }\n        }\n    }\n    \n    public String toString() {\n        return rankedItems.toString();\n    }\n    \n    /**\n     * Creates a (defensive) copy of itself.\n     */\n    public Rankings copy() {\n        return new Rankings(this);\n    }\n}<fim_middle>// function below has no smell\n"}