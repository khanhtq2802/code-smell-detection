{"text": "<fim_prefix>     * @param paramType                the (unresolved) type of the method parameter\n     * @return a new parameter with the same name and type as the original one, but with resolved generic types\n     */\n    private static Parameter buildParameter(final Map<GenericsTypeName, GenericsType> genericFromReceiver, final Map<GenericsTypeName, GenericsType> placeholdersFromContext, final Parameter methodParameter, final ClassNode paramType) {\n        if (genericFromReceiver.isEmpty() && (placeholdersFromContext == null || placeholdersFromContext.isEmpty())) {\n            return methodParameter;\n        }\n        if (paramType.isArray()) {\n            ClassNode componentType = paramType.getComponentType();\n            Parameter subMethodParameter = new Parameter(componentType, methodParameter.getName());\n            Parameter component = buildParameter(genericFromReceiver, placeholdersFromContext, subMethodParameter, componentType);\n            return new Parameter(component.getType().makeArray(), component.getName());\n        }\n        ClassNode resolved = resolveClassNodeGenerics(genericFromReceiver, placeholdersFromContext, paramType);\n        return new Parameter(resolved, methodParameter.getName());\n    }\n    /**\n     * Returns true if a class node makes use of generic types. If the class node represents an\n     * array type, then checks if the component type is using generics.\n     *\n     * @param cn a class node for which to check if it is using generics\n     * @return true if the type (or component type) is using generics\n     */\n    public static boolean isUsingGenericsOrIsArrayUsingGenerics(ClassNode cn) {\n        if (cn.isArray()) {\n            return isUsingGenericsOrIsArrayUsingGenerics(cn.getComponentType());\n        }\n        return (cn.isUsingGenerics() && cn.getGenericsTypes() != null);\n    }\n    /**\n     * Given a generics type representing SomeClass&lt;T,V&gt; and a resolved placeholder map, returns a new generics type\n     * for which placeholders are resolved recursively.\n     */\n    protected static GenericsType fullyResolve(GenericsType gt, Map<GenericsTypeName, GenericsType> placeholders) {\n        GenericsType fromMap = placeholders.get(new GenericsTypeName(gt.getName()));\n        if (gt.isPlaceholder() && fromMap != null) {\n            gt = fromMap;\n        }\n        ClassNode type = fullyResolveType(gt.getType(), placeholders);\n        ClassNode lowerBound = gt.getLowerBound();\n        if (lowerBound != null) lowerBound = fullyResolveType(lowerBound, placeholders);\n        ClassNode[] upperBounds = gt.getUpperBounds();\n        if (upperBounds != null) {\n            ClassNode[] copy = new ClassNode[upperBounds.length];\n            for (int i = 0, upperBoundsLength = upperBounds.length; i < upperBoundsLength; i++) {\n                final ClassNode upperBound = upperBounds[i];\n                copy[i] = fullyResolveType(upperBound, placeholders);\n            }\n            upperBounds = copy;\n        }\n        GenericsType genericsType = new GenericsType(type, upperBounds, lowerBound);\n        genericsType.setWildcard(gt.isWildcard());\n        return genericsType;\n    }\n    protected static ClassNode fullyResolveType(final ClassNode type, final Map<GenericsTypeName, GenericsType> placeholders) {\n        if (type.isUsingGenerics() && !type.isGenericsPlaceHolder()) {\n            GenericsType[] gts = type.getGenericsTypes();\n            if (gts != null) {\n                GenericsType[] copy = new GenericsType[gts.length];\n                for (int i = 0; i < gts.length; i++) {\n                    GenericsType genericsType = gts[i];\n                    if (genericsType.isPlaceholder() && placeholders.containsKey(new GenericsTypeName(genericsType.getName()))) {\n                        copy[i] = placeholders.get(new GenericsTypeName(genericsType.getName()));\n                    } else {\n                        copy[i] = fullyResolve(genericsType, placeholders);\n                    }\n                }\n                gts = copy;\n            }\n            ClassNode result = type.getPlainNodeReference();\n            result.setGenericsTypes(gts);\n            return result;\n        } else if (type.isUsingGenerics() && OBJECT_TYPE.equals(type) && type.getGenericsTypes() != null) {\n            // Object<T>\n            GenericsType genericsType = placeholders.get(new GenericsTypeName(type.getGenericsTypes()[0].getName()));\n            if (genericsType != null) {\n                return genericsType.getType();\n            }\n        } else if (type.isArray()) {\n            return fullyResolveType(type.getComponentType(), placeholders).makeArray();\n        }\n        return type;\n    }\n    /**\n     * Checks that the parameterized generics of an argument are compatible with the generics of the parameter.\n     *\n     * @param parameterType the parameter type of a method\n     * @param argumentType  the type of the argument passed to the method\n     */\n    protected static boolean typeCheckMethodArgumentWithGenerics(ClassNode parameterType, ClassNode argumentType, boolean lastArg) {\n        if (UNKNOWN_PARAMETER_TYPE == argumentType) {\n            // called with null\n            return !isPrimitiveType(parameterType);\n        }\n        if (!isAssignableTo(argumentType, parameterType) && !lastArg) {\n            // incompatible assignment\n            return false;\n        }\n        if (!isAssignableTo(argumentType, parameterType) && lastArg) {\n            if (parameterType.isArray()) {\n                if (!isAssignableTo(argumentType, parameterType.getComponentType())) {\n                    return false;\n                }\n            } else {\n                return false;\n            }\n        }\n        if (parameterType.isUsingGenerics() && argumentType.isUsingGenerics()) {\n            GenericsType gt = GenericsUtils.buildWildcardType(parameterType);\n            if (!gt.isCompatibleWith(argumentType)) {\n                boolean samCoercion = isSAMType(parameterType) && argumentType.equals(CLOSURE_TYPE);\n                if (!samCoercion) return false;\n            }\n        } else if (parameterType.isArray() && argumentType.isArray()) {\n            // verify component type\n            return typeCheckMethodArgumentWithGenerics(parameterType.getComponentType(), argumentType.getComponentType(), lastArg);\n        } else if (lastArg && parameterType.isArray()) {\n            // verify component type, but if we reach that point, the only possibility is that the argument is\n            // the last one of the call, so we're in the cast of a vargs call\n            // (otherwise, we face a type checker bug)\n            return typeCheckMethodArgumentWithGenerics(parameterType.getComponentType(), argumentType, lastArg);\n        }\n        return true;\n    }\n    static void addMethodLevelDeclaredGenerics(MethodNode method, Map<GenericsTypeName, GenericsType> resolvedPlaceholders) {\n        ClassNode dummy = OBJECT_TYPE.getPlainNodeReference();\n        dummy.setGenericsTypes(method.getGenericsTypes());\n        GenericsUtils.extractPlaceholders(dummy, resolvedPlaceholders);\n    }\n<fim_suffix>    protected static boolean typeCheckMethodsWithGenerics(ClassNode receiver, ClassNode[] arguments, MethodNode candidateMethod) {\n        if (isUsingUncheckedGenerics(receiver)) {\n            return true;\n        }\n        if (CLASS_Type.equals(receiver)\n                && receiver.isUsingGenerics()\n                && !candidateMethod.getDeclaringClass().equals(receiver)\n                && !(candidateMethod instanceof ExtensionMethodNode)) {\n            return typeCheckMethodsWithGenerics(receiver.getGenericsTypes()[0].getType(), arguments, candidateMethod);\n        }\n        // both candidate method and receiver have generic information so a check is possible\n        GenericsType[] genericsTypes = candidateMethod.getGenericsTypes();\n        boolean methodUsesGenerics = (genericsTypes != null && genericsTypes.length > 0);\n        boolean isExtensionMethod = candidateMethod instanceof ExtensionMethodNode;\n        if (isExtensionMethod && methodUsesGenerics) {\n            ClassNode[] dgmArgs = new ClassNode[arguments.length + 1];\n            dgmArgs[0] = receiver;\n            System.arraycopy(arguments, 0, dgmArgs, 1, arguments.length);\n            MethodNode extensionMethodNode = ((ExtensionMethodNode) candidateMethod).getExtensionMethodNode();\n            return typeCheckMethodsWithGenerics(extensionMethodNode.getDeclaringClass(), dgmArgs, extensionMethodNode, true);\n        } else {\n            return typeCheckMethodsWithGenerics(receiver, arguments, candidateMethod, false);\n        }\n    }<fim_middle>// function below is long method\n"}