{"text": "<fim_prefix>\n<fim_suffix>    abstract static class Sync extends AbstractQueuedSynchronizer {\n        private static final long serialVersionUID = 6317671515068378041L;\n        /*\n         * Read vs write count extraction constants and functions.\n         * Lock state is logically divided into two unsigned shorts:\n         * The lower one representing the exclusive (writer) lock hold count,\n         * and the upper the shared (reader) hold count.\n         */\n        static final int SHARED_SHIFT   = 16;\n        static final int SHARED_UNIT    = (1 << SHARED_SHIFT);\n        static final int MAX_COUNT      = (1 << SHARED_SHIFT) - 1;\n        static final int EXCLUSIVE_MASK = (1 << SHARED_SHIFT) - 1;\n        /** Returns the number of shared holds represented in count. */\n        static int sharedCount(int c)    { return c >>> SHARED_SHIFT; }\n        /** Returns the number of exclusive holds represented in count. */\n        static int exclusiveCount(int c) { return c & EXCLUSIVE_MASK; }\n        /**\n         * A counter for per-thread read hold counts.\n         * Maintained as a ThreadLocal; cached in cachedHoldCounter.\n         */\n        static final class HoldCounter {\n            int count;          // initially 0\n            // Use id, not reference, to avoid garbage retention\n            final long tid = getThreadId(Thread.currentThread());\n        }\n        /**\n         * ThreadLocal subclass. Easiest to explicitly define for sake\n         * of deserialization mechanics.\n         */\n        static final class ThreadLocalHoldCounter\n            extends ThreadLocal<HoldCounter> {\n            public HoldCounter initialValue() {\n                return new HoldCounter();\n            }\n        }\n        /**\n         * The number of reentrant read locks held by current thread.\n         * Initialized only in constructor and readObject.\n         * Removed whenever a thread's read hold count drops to 0.\n         */\n        private transient ThreadLocalHoldCounter readHolds;\n        /**\n         * The hold count of the last thread to successfully acquire\n         * readLock. This saves ThreadLocal lookup in the common case\n         * where the next thread to release is the last one to\n         * acquire. This is non-volatile since it is just used\n         * as a heuristic, and would be great for threads to cache.\n         *\n         * <p>Can outlive the Thread for which it is caching the read\n         * hold count, but avoids garbage retention by not retaining a\n         * reference to the Thread.\n         *\n         * <p>Accessed via a benign data race; relies on the memory\n         * model's final field and out-of-thin-air guarantees.\n         *\n         * J2ObjC modification: Added @Weak to avoid ref counting races. We rely\n         * on the ThreadLocal readHolds to hold strong references to the\n         * counters, and a modification is made below int tryReleaseShared to\n         * assign this field to null when it is removed from it's ThreadLocal.\n         */\n        @Weak private transient HoldCounter cachedHoldCounter;\n        /**\n         * firstReader is the first thread to have acquired the read lock.\n         * firstReaderHoldCount is firstReader's hold count.\n         *\n         * <p>More precisely, firstReader is the unique thread that last\n         * changed the shared count from 0 to 1, and has not released the\n         * read lock since then; null if there is no such thread.\n         *\n         * <p>Cannot cause garbage retention unless the thread terminated\n         * without relinquishing its read locks, since tryReleaseShared\n         * sets it to null.\n         *\n         * <p>Accessed via a benign data race; relies on the memory\n         * model's out-of-thin-air guarantees for references.\n         *\n         * <p>This allows tracking of read holds for uncontended read\n         * locks to be very cheap.\n         *\n         * J2ObjC modification: Added @Weak to avoid ref counting races. This is\n         * safe because firstReader is only ever used for object comparison with\n         * the current thread, and is never dereferenced.\n         */\n        @Weak private transient Thread firstReader;\n        private transient int firstReaderHoldCount;\n        Sync() {\n            readHolds = new ThreadLocalHoldCounter();\n            setState(getState()); // ensures visibility of readHolds\n        }\n        /*\n         * Acquires and releases use the same code for fair and\n         * nonfair locks, but differ in whether/how they allow barging\n         * when queues are non-empty.\n         */\n        /**\n         * Returns true if the current thread, when trying to acquire\n         * the read lock, and otherwise eligible to do so, should block\n         * because of policy for overtaking other waiting threads.\n         */\n        abstract boolean readerShouldBlock();\n        /**\n         * Returns true if the current thread, when trying to acquire\n         * the write lock, and otherwise eligible to do so, should block\n         * because of policy for overtaking other waiting threads.\n         */\n        abstract boolean writerShouldBlock();\n        /*\n         * Note that tryRelease and tryAcquire can be called by\n         * Conditions. So it is possible that their arguments contain\n         * both read and write holds that are all released during a\n         * condition wait and re-established in tryAcquire.\n         */\n        protected final boolean tryRelease(int releases) {\n            if (!isHeldExclusively())\n                throw new IllegalMonitorStateException();\n            int nextc = getState() - releases;\n            boolean free = exclusiveCount(nextc) == 0;\n            if (free)\n                setExclusiveOwnerThread(null);\n            setState(nextc);\n            return free;\n        }\n        protected final boolean tryAcquire(int acquires) {\n            /*\n             * Walkthrough:\n             * 1. If read count nonzero or write count nonzero\n             *    and owner is a different thread, fail.\n             * 2. If count would saturate, fail. (This can only\n             *    happen if count is already nonzero.)\n             * 3. Otherwise, this thread is eligible for lock if\n             *    it is either a reentrant acquire or\n             *    queue policy allows it. If so, update state\n             *    and set owner.\n             */\n            Thread current = Thread.currentThread();\n            int c = getState();\n            int w = exclusiveCount(c);\n            if (c != 0) {\n                // (Note: if c != 0 and w == 0 then shared count != 0)\n                if (w == 0 || current != getExclusiveOwnerThread())\n                    return false;\n                if (w + exclusiveCount(acquires) > MAX_COUNT)\n                    throw new Error(\"Maximum lock count exceeded\");\n                // Reentrant acquire\n                setState(c + acquires);\n                return true;\n            }\n            if (writerShouldBlock() ||\n                !compareAndSetState(c, c + acquires))\n                return false;\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n        protected final boolean tryReleaseShared(int unused) {\n            Thread current = Thread.currentThread();\n            if (firstReader == current) {\n                // assert firstReaderHoldCount > 0;\n                if (firstReaderHoldCount == 1)\n                    firstReader = null;\n                else\n                    firstReaderHoldCount--;\n            } else {\n                HoldCounter rh = cachedHoldCounter;\n                boolean cachedCounterIsLocal = true;\n                if (rh == null || rh.tid != getThreadId(current)) {\n                    rh = readHolds.get();\n                    cachedCounterIsLocal = false;\n                }\n                int count = rh.count;\n                if (count <= 1) {\n                    // J2ObjC modification: cachedHoldCounter is @Weak, so it\n                    // must be cleared when removing from readHolds.\n                    if (cachedCounterIsLocal) {\n                      cachedHoldCounter = null;\n                    }\n                    readHolds.remove();\n                    if (count <= 0)\n                        throw unmatchedUnlockException();\n                }\n                --rh.count;\n            }\n            for (;;) {\n                int c = getState();\n                int nextc = c - SHARED_UNIT;\n                if (compareAndSetState(c, nextc))\n                    // Releasing the read lock has no effect on readers,\n                    // but it may allow waiting writers to proceed if\n                    // both read and write locks are now free.\n                    return nextc == 0;\n            }\n        }\n        private IllegalMonitorStateException unmatchedUnlockException() {\n            return new IllegalMonitorStateException(<fim_middle>// class below is blob\n"}