{"text": "<fim_prefix>\n<fim_suffix>public class JobSchedulerService extends AbstractScheduledService {\n    protected static final long DEFAULT_DELAY = 1000;\n    private static final Logger logger = LoggerFactory.getLogger( JobSchedulerService.class );\n    private long interval = DEFAULT_DELAY;\n    private int workerSize = 1;\n    private int maxFailCount = 10;\n    private JobAccessor jobAccessor;\n    private JobFactory jobFactory;\n    private Semaphore capacitySemaphore;\n    private ListeningScheduledExecutorService service;\n    private JobListener jobListener;\n    private Timer jobTimer;\n    private Counter runCounter;\n    private Counter successCounter;\n    private Counter failCounter;\n    private Injector injector;\n    //TODO Add meters for throughput of start and stop\n    public JobSchedulerService() { }\n    @Override\n    protected void runOneIteration() throws Exception {\n        MetricsFactory metricsFactory = injector.getInstance( MetricsFactory.class );\n        jobTimer = metricsFactory.getTimer( JobSchedulerService.class, \"scheduler.job_execution_timer\" );\n        runCounter = metricsFactory.getCounter( JobSchedulerService.class, \"scheduler.running_workers\" );\n        successCounter = metricsFactory.getCounter( JobSchedulerService.class, \"scheduler.successful_jobs\" );\n        failCounter = metricsFactory.getCounter( JobSchedulerService.class, \"scheduler.failed_jobs\" );\n        try {\n            if ( logger.isDebugEnabled() ) {\n                logger.debug( \"Running one check iteration ...\" );\n            }\n            List<JobDescriptor> activeJobs;\n            // run until there are no more active jobs\n            while ( true ) {\n                // get the semaphore if we can. This means we have space for at least 1\n                // job\n                if ( logger.isDebugEnabled() ) {\n                    logger.debug( \"About to acquire semaphore.  Capacity is {}\", capacitySemaphore.availablePermits() );\n                }\n                capacitySemaphore.acquire();\n                // release the sempaphore we only need to acquire as a way to stop the\n                // loop if there's no capacity\n                capacitySemaphore.release();\n                int capacity = capacitySemaphore.availablePermits();\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Capacity is {}\", capacity);\n                }\n                activeJobs = jobAccessor.getJobs( capacity );\n                // nothing to do, we don't have any jobs to run\n                if ( activeJobs.size() == 0 ) {\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"No jobs returned. Exiting run loop\");\n                    }\n                    return;\n                }\n                for ( JobDescriptor jd : activeJobs ) {\n                    logger.debug( \"Submitting work for {}\", jd );\n                    submitWork( jd );\n                    logger.debug( \"Work submitted for {}\", jd );\n                }\n            }\n        }\n        catch ( Throwable t ) {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Scheduler run failed, error is\", t);\n            }\n        }\n    }\n    /*\n     * (non-Javadoc)\n     *\n     * @see com.google.common.util.concurrent.AbstractScheduledService#scheduler()\n     */\n    @Override\n    protected Scheduler scheduler() {\n        return Scheduler.newFixedDelaySchedule( 0, interval, TimeUnit.MILLISECONDS );\n    }\n    /**\n     * Use the provided BulkJobFactory to build and submit BulkJob items as ListenableFuture objects\n     */\n    private void submitWork( final JobDescriptor jobDescriptor ) {\n        final Job job;\n        try {\n            job = jobFactory.jobsFrom( jobDescriptor );\n        }\n        catch ( JobNotFoundException e ) {\n            logger.error( \"Could not create jobs\", e );\n            return;\n        }\n        // job execution needs to be external to both the callback and the task.\n        // This way regardless of any error we can\n        // mark a job as failed if required\n        final JobExecution execution = new JobExecutionImpl( jobDescriptor );\n        // We don't care if this is atomic (not worth using a lock object)\n        // we just need to prevent NPEs from ever occurring\n        final JobListener currentListener = this.jobListener;\n        /**\n         * Acquire the semaphore before we schedule.  This way we wont' take things from the Q that end up\n         * stuck in the queue for the scheduler and then time out their distributed heartbeat\n         */\n        try {\n            capacitySemaphore.acquire();\n        }\n        catch ( InterruptedException e ) {\n            logger.error( \"Unable to acquire semaphore capacity before submitting job\", e );\n            //just return, they'll get picked up again later\n            return;\n        }\n        final Timer.Context timer = jobTimer.time();\n        ListenableFuture<Void> future = service.submit( new Callable<Void>() {\n            @Override\n            public Void call() throws Exception {\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Starting the job with job id {}\", execution.getJobId());\n                }\n                runCounter.inc();\n                execution.start( maxFailCount );\n                //this job is dead, treat it as such\n                if ( execution.getStatus() == Status.DEAD ) {\n                    try {\n                        job.dead( execution );\n                        jobAccessor.save( execution );\n                    }\n                    catch ( Exception t ) {\n                        //we purposefully swallow all exceptions here, we don't want it to effect the outcome\n                        //of finally popping this job from the queue\n                        logger.error( \"Unable to invoke dead event on job\", t );\n                    }\n                    return null;\n                }\n                jobAccessor.save( execution );\n                // TODO wrap and throw specifically typed exception for onFailure,\n                // needs jobId\n                logger.debug( \"Starting job {} with execution data {}\", job, execution );\n                job.execute( execution );\n                if ( currentListener != null ) {\n                    currentListener.onSubmit( execution );\n                }\n                return null;\n            }\n        } );\n        Futures.addCallback( future, new FutureCallback<Void>() {\n            @Override\n            public void onSuccess( Void param ) {\n                /**\n                 * Release semaphore first in case there are other problems with communicating with Cassandra\n                 */\n                if (logger.isDebugEnabled()) {\n                    logger.debug(\"Job succeeded with the job id {}\", execution.getJobId());\n                }\n                capacitySemaphore.release();\n                timer.stop();\n                runCounter.dec();\n                successCounter.inc();\n                //TODO, refactor into the execution itself for checking if done\n                if ( execution.getStatus() == Status.IN_PROGRESS ) {\n                    logger.debug( \"Successful completion of bulkJob {}\", execution );\n                    execution.completed();\n                }\n                jobAccessor.save( execution );\n                if ( currentListener != null ) {\n                    currentListener.onSuccess( execution );\n                }\n            }\n            @Override\n            public void onFailure( Throwable throwable ) {\n                /**\n                 * Release semaphore first in case there are other problems with communicating with Cassandra\n                 */\n                logger.error( \"Job failed with the job id {}\", execution.getJobId() );\n                capacitySemaphore.release();\n                timer.stop();\n                runCounter.dec();\n                failCounter.inc();\n                logger.error( \"Failed execution for bulkJob\", throwable );\n                // mark it as failed\n                if ( execution.getStatus() == Status.IN_PROGRESS ) {\n                    execution.failed();\n                }\n                jobAccessor.save( execution );\n                if ( currentListener != null ) {\n                    currentListener.onFailure( execution );\n                }\n            }\n        } );\n    }\n    /**\n     * @param milliseconds the milliseconds to set to wait if we didn't receive a job to run\n     */\n    public void setInterval( long milliseconds ) {\n        this.interval = milliseconds;\n    }\n    public long getInterval() {\n        return interval;\n    }\n    /**\n     * @param listeners the listeners to set\n     */\n    public void setWorkerSize( int listeners ) {\n        this.workerSize = listeners;\n    }\n    public int getWorkerSize() {\n        return workerSize;\n    }\n    /**\n     * @param jobAccessor the jobAccessor to set\n     */\n    public void setJobAccessor( JobAccessor jobAccessor ) {\n        this.jobAccessor = jobAccessor;\n    }\n    /**\n     * @param jobFactory the jobFactory to set\n     */\n    public void setJobFactory( JobFactory jobFactory ) {\n        this.jobFactory = jobFactory;\n    }\n    /**\n     * @param maxFailCount the maxFailCount to set\n     */\n    public void setMaxFailCount( int maxFailCount ) {\n        this.maxFailCount = maxFailCount;\n    }\n    /**\n     * Set the metrics factory\n     */\n//    public void setMetricsFactory( MetricsFactory metricsFactory ) {\n//\n//        jobTimer = metricsFactory.getTimer( JobSchedulerService.class, \"job_execution_timer\" );\n//        runCounter = metricsFactory.getCounter( JobSchedulerService.class, \"running_workers\" );\n//        successCounter = metricsFactory.getCounter( JobSchedulerService.class, \"successful_jobs\" );\n//        failCounter = metricsFactory.getCounter( JobSchedulerService.class, \"failed_jobs\" );\n//    }\n    /*\n     * (non-Javadoc)\n     *\n     * @see com.google.common.util.concurrent.AbstractScheduledService#startUp()\n     */\n    @Override\n    protected void startUp() throws Exception {\n        service = MoreExecutors\n                .listeningDecorator( Executors.newScheduledThreadPool( workerSize, JobThreadFactory.INSTANCE ) );\n        capacitySemaphore = new Semaphore( workerSize );<fim_middle>// class below is blob\n"}