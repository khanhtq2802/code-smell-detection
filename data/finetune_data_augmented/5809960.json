{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.tinkerpop.gremlin.process.traversal.dsl.graph;\nimport org.apache.commons.configuration.Configuration;\nimport org.apache.tinkerpop.gremlin.process.computer.Computer;\nimport org.apache.tinkerpop.gremlin.process.computer.GraphComputer;\nimport org.apache.tinkerpop.gremlin.process.remote.RemoteConnection;\nimport org.apache.tinkerpop.gremlin.process.remote.traversal.strategy.decoration.RemoteStrategy;\nimport org.apache.tinkerpop.gremlin.process.traversal.AnonymousTraversalSource;\nimport org.apache.tinkerpop.gremlin.process.traversal.Bytecode;\nimport org.apache.tinkerpop.gremlin.process.traversal.Traversal;\nimport org.apache.tinkerpop.gremlin.process.traversal.TraversalSource;\nimport org.apache.tinkerpop.gremlin.process.traversal.TraversalStrategies;\nimport org.apache.tinkerpop.gremlin.process.traversal.TraversalStrategy;\nimport org.apache.tinkerpop.gremlin.process.traversal.step.map.AddEdgeStartStep;\nimport org.apache.tinkerpop.gremlin.process.traversal.step.map.AddVertexStartStep;\nimport org.apache.tinkerpop.gremlin.process.traversal.step.map.GraphStep;\nimport org.apache.tinkerpop.gremlin.process.traversal.step.sideEffect.IoStep;\nimport org.apache.tinkerpop.gremlin.process.traversal.step.sideEffect.InjectStep;\nimport org.apache.tinkerpop.gremlin.process.traversal.strategy.decoration.RequirementsStrategy;\nimport org.apache.tinkerpop.gremlin.process.traversal.traverser.TraverserRequirement;\nimport org.apache.tinkerpop.gremlin.structure.Edge;\nimport org.apache.tinkerpop.gremlin.structure.Graph;\nimport org.apache.tinkerpop.gremlin.structure.Transaction;\nimport org.apache.tinkerpop.gremlin.structure.Vertex;\nimport org.apache.tinkerpop.gremlin.structure.util.StringFactory;\nimport org.apache.tinkerpop.gremlin.structure.util.empty.EmptyGraph;\nimport java.util.Optional;\nimport java.util.function.BinaryOperator;\nimport java.util.function.Supplier;\nimport java.util.function.UnaryOperator;\n/**\n * A {@code GraphTraversalSource} is the primary DSL of the Gremlin traversal machine.\n * It provides access to all the configurations and steps for Turing complete graph computing.\n * Any DSL can be constructed based on the methods of both {@code GraphTraversalSource} and {@link GraphTraversal}.\n *\n * @author Marko A. Rodriguez (http://markorodriguez.com)\n * @author Stephen Mallette (http://stephen.genoprime.com)\n */\npublic class GraphTraversalSource implements TraversalSource {\n    protected transient RemoteConnection connection;\n    protected final Graph graph;\n    protected TraversalStrategies strategies;\n    protected Bytecode bytecode = new Bytecode();\n    ////////////////\n    public static final class Symbols {\n        private Symbols() {\n            // static fields only\n        }\n        public static final String withBulk = \"withBulk\";\n        public static final String withPath = \"withPath\";\n    }\n    ////////////////\n    @Override\n    public Optional<Class> getAnonymousTraversalClass() {\n        return Optional.of(__.class);\n    }\n    public GraphTraversalSource(final Graph graph, final TraversalStrategies traversalStrategies) {\n        this.graph = graph;\n        this.strategies = traversalStrategies;\n    }\n    public GraphTraversalSource(final Graph graph) {\n        this(graph, TraversalStrategies.GlobalCache.getStrategies(graph.getClass()));\n    }\n    public GraphTraversalSource(final RemoteConnection connection) {\n        this(EmptyGraph.instance(), TraversalStrategies.GlobalCache.getStrategies(EmptyGraph.class).clone());\n        this.connection = connection;\n        this.strategies.addStrategies(new RemoteStrategy(connection));\n    }\n    @Override\n    public TraversalStrategies getStrategies() {\n        return this.strategies;\n    }\n    @Override\n    public Graph getGraph() {\n        return this.graph;\n    }\n    @Override\n    public Bytecode getBytecode() {\n        return this.bytecode;\n    }\n    @SuppressWarnings(\"CloneDoesntDeclareCloneNotSupportedException\")\n    public GraphTraversalSource clone() {\n        try {\n            final GraphTraversalSource clone = (GraphTraversalSource) super.clone();\n            clone.strategies = this.strategies.clone();\n            clone.bytecode = this.bytecode.clone();\n            return clone;\n        } catch (final CloneNotSupportedException e) {\n            throw new IllegalStateException(e.getMessage(), e);\n        }\n    }\n    //// CONFIGURATIONS\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public GraphTraversalSource with(final String key) {\n        return (GraphTraversalSource) TraversalSource.super.with(key);\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public GraphTraversalSource with(final String key, final Object value) {\n        return (GraphTraversalSource) TraversalSource.super.with(key, value);\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public GraphTraversalSource withStrategies(final TraversalStrategy... traversalStrategies) {\n        return (GraphTraversalSource) TraversalSource.super.withStrategies(traversalStrategies);\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    @SuppressWarnings({\"unchecked\"})\n    public GraphTraversalSource withoutStrategies(final Class<? extends TraversalStrategy>... traversalStrategyClasses) {\n        return (GraphTraversalSource) TraversalSource.super.withoutStrategies(traversalStrategyClasses);\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public GraphTraversalSource withComputer(final Computer computer) {\n        return (GraphTraversalSource) TraversalSource.super.withComputer(computer);\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public GraphTraversalSource withComputer(final Class<? extends GraphComputer> graphComputerClass) {\n        return (GraphTraversalSource) TraversalSource.super.withComputer(graphComputerClass);\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public GraphTraversalSource withComputer() {\n        return (GraphTraversalSource) TraversalSource.super.withComputer();\n    }\n    /**\n     * {@inheritDoc}\n     */\n<fim_suffix>    @Override\n    public <A> GraphTraversalSource withSideEffect(final String key, final Supplier<A> initialValue, final BinaryOperator<A> reducer) {\n        return (GraphTraversalSource) TraversalSource.super.withSideEffect(key, initialValue, reducer);\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public <A> GraphTraversalSource withSideEffect(final String key, final A initialValue, final BinaryOperator<A> reducer) {\n        return (GraphTraversalSource) TraversalSource.super.withSideEffect(key, initialValue, reducer);\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public <A> GraphTraversalSource withSideEffect(final String key, final A initialValue) {\n        return (GraphTraversalSource) TraversalSource.super.withSideEffect(key, initialValue);\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public <A> GraphTraversalSource withSideEffect(final String key, final Supplier<A> initialValue) {\n        return (GraphTraversalSource) TraversalSource.super.withSideEffect(key, initialValue);\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public <A> GraphTraversalSource withSack(final Supplier<A> initialValue, final UnaryOperator<A> splitOperator, final BinaryOperator<A> mergeOperator) {\n        return (GraphTraversalSource) TraversalSource.super.withSack(initialValue, splitOperator, mergeOperator);\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public <A> GraphTraversalSource withSack(final A initialValue, final UnaryOperator<A> splitOperator, final BinaryOperator<A> mergeOperator) {<fim_middle>// function below has no smell\n"}