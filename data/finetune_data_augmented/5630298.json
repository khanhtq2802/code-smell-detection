{"text": "<fim_prefix>/*\n *\n *  Licensed to the Apache Software Foundation (ASF) under one or more\n *  contributor license agreements.  See the NOTICE file distributed with\n *  this work for additional information regarding copyright ownership.\n *  The ASF licenses this file to You under the Apache License, Version 2.0\n *  (the \"License\"); you may not use this file except in compliance with\n *  the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n */\n\npackage org.apache.royale.compiler.internal.codegen.js.jx;\n\nimport org.apache.royale.compiler.codegen.ISubEmitter;\nimport org.apache.royale.compiler.codegen.js.IJSEmitter;\nimport org.apache.royale.compiler.internal.codegen.as.ASEmitterTokens;\nimport org.apache.royale.compiler.internal.codegen.js.JSSubEmitter;\nimport org.apache.royale.compiler.internal.codegen.js.utils.EmitterUtils;\nimport org.apache.royale.compiler.tree.as.IASNode;\nimport org.apache.royale.compiler.tree.as.IConditionalNode;\nimport org.apache.royale.compiler.tree.as.IContainerNode;\nimport org.apache.royale.compiler.tree.as.IExpressionNode;\nimport org.apache.royale.compiler.tree.as.ISwitchNode;\nimport org.apache.royale.compiler.tree.as.ITerminalNode;\nimport org.apache.royale.compiler.utils.ASNodeUtils;\n\n<fim_suffix>public class SwitchEmitter extends JSSubEmitter implements\n        ISubEmitter<ISwitchNode>\n{\n    public SwitchEmitter(IJSEmitter emitter)\n    {\n        super(emitter);\n    }\n\n    @Override\n    public void emit(ISwitchNode node)\n    {\n        startMapping(node);\n        writeToken(ASEmitterTokens.SWITCH);\n        write(ASEmitterTokens.PAREN_OPEN);\n        endMapping(node);\n        IASNode expressionNode = node.getChild(0);\n        getWalker().walk(expressionNode);\n        startMapping(node, expressionNode);\n        writeToken(ASEmitterTokens.PAREN_CLOSE);\n        endMapping(node);\n        IASNode statementContentsNode = node.getStatementContentsNode();\n        startMapping(statementContentsNode);\n        write(ASEmitterTokens.BLOCK_OPEN);\n        endMapping(statementContentsNode);\n        indentPush();\n        writeNewline();\n\n        IConditionalNode[] cnodes = ASNodeUtils.getCaseNodes(node);\n        ITerminalNode dnode = ASNodeUtils.getDefaultNode(node);\n        \n        for (int i = 0; i < cnodes.length; i++)\n        {\n            IConditionalNode casen = cnodes[i];\n            IContainerNode cnode = (IContainerNode) casen.getChild(1);\n            startMapping(casen);\n            writeToken(ASEmitterTokens.CASE);\n            endMapping(casen);\n            IExpressionNode conditionalExpressionNode = casen.getConditionalExpressionNode();\n            getWalker().walk(conditionalExpressionNode);\n            startMapping(casen, conditionalExpressionNode);\n            write(ASEmitterTokens.COLON);\n            if (!EmitterUtils.isImplicit(cnode))\n                write(ASEmitterTokens.SPACE);\n            endMapping(casen);\n            getWalker().walk(casen.getStatementContentsNode());\n            if (i == cnodes.length - 1 && dnode == null)\n            {\n                indentPop();\n                writeNewline();\n            }\n            else\n                writeNewline();\n        }\n        if (dnode != null)\n        {\n            IContainerNode cnode = (IContainerNode) dnode.getChild(0);\n            startMapping(dnode);\n            write(ASEmitterTokens.DEFAULT);\n            write(ASEmitterTokens.COLON);\n            if (!EmitterUtils.isImplicit(cnode))\n                write(ASEmitterTokens.SPACE);\n            endMapping(dnode);\n            getWalker().walk(dnode);\n            indentPop();\n            writeNewline();\n        }\n        startMapping(node, node.getEndLine(), node.getEndColumn() - 1);\n        write(ASEmitterTokens.BLOCK_CLOSE);\n        endMapping(node);\n    }\n}<fim_middle>// class below has no smell\n"}