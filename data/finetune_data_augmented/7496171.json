{"text": "<fim_prefix>/*\n * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage org.graalvm.compiler.truffle.runtime;\nimport static org.graalvm.compiler.truffle.runtime.SharedTruffleRuntimeOptions.TraceTruffleAssumptions;\nimport java.lang.ref.WeakReference;\nimport java.util.function.Consumer;\nimport org.graalvm.compiler.truffle.common.OptimizedAssumptionDependency;\nimport com.oracle.truffle.api.CompilerDirectives;\nimport com.oracle.truffle.api.CompilerDirectives.TruffleBoundary;\nimport com.oracle.truffle.api.impl.AbstractAssumption;\nimport com.oracle.truffle.api.nodes.InvalidAssumptionException;\nimport jdk.vm.ci.meta.JavaKind.FormatWithToString;\n/**\n * An assumption that when {@linkplain #invalidate() invalidated} will cause all\n * {@linkplain #registerDependency() registered} dependencies to be invalidated.\n */\npublic final class OptimizedAssumption extends AbstractAssumption implements FormatWithToString {\n    /**\n     * Reference to machine code that is dependent on an assumption.\n     */\n    static class Entry implements Consumer<OptimizedAssumptionDependency> {\n        /**\n         * A machine code reference that must be kept reachable as long as the machine code itself\n         * is valid.\n         */\n        OptimizedAssumptionDependency dependency;\n        /**\n         * Machine code that is guaranteed to be invalid once the\n         * {@link OptimizedAssumptionDependency} object becomes unreachable.\n         */\n        WeakReference<OptimizedAssumptionDependency> weakDependency;\n        Entry next;\n        @Override\n        public synchronized void accept(OptimizedAssumptionDependency dep) {\n            if (dep == null || dep.soleExecutionEntryPoint()) {\n                this.weakDependency = new WeakReference<>(dep);\n            } else {\n                this.dependency = dep;\n            }\n            this.notifyAll();\n        }\n        synchronized OptimizedAssumptionDependency awaitDependency() {\n            while (dependency == null && weakDependency == null) {\n                try {\n                    this.wait();\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                }\n            }\n            if (dependency != null) {\n                return dependency;\n            }\n            return weakDependency.get();\n        }\n        synchronized boolean isValid() {\n            if (dependency != null) {\n                return dependency.isValid();\n            }\n            if (weakDependency != null) {\n                OptimizedAssumptionDependency dep = weakDependency.get();\n                return dep != null && dep.isValid();\n            }\n            // A pending dependency is treated as valid\n            return true;\n        }\n        @Override\n        public synchronized String toString() {\n            if (dependency != null) {\n                return String.format(\"%x[%s]\", hashCode(), dependency);\n            }\n            if (weakDependency != null) {\n                OptimizedAssumptionDependency dep = weakDependency.get();\n                return String.format(\"%x[%s]\", hashCode(), dep);\n            }\n            return String.format(\"%x\", hashCode());\n        }\n    }\n    /**\n     * Linked list of registered dependencies.\n     */\n    private Entry dependencies;\n    /**\n     * Number of entries in {@link #dependencies}.\n     */\n    private int size;\n    /**\n     * Number of entries in {@link #dependencies} after most recent call to\n     * {@link #removeInvalidEntries()}.\n     */\n    private int sizeAfterLastRemove;\n    public OptimizedAssumption(String name) {\n        super(name);\n    }\n    @Override\n    public void check() throws InvalidAssumptionException {\n        if (!this.isValid()) {\n            CompilerDirectives.transferToInterpreterAndInvalidate();\n            throw new InvalidAssumptionException();\n        }\n    }\n    @Override\n    public void invalidate() {\n        if (isValid) {\n            invalidateImpl(\"\");\n        }\n    }\n    @Override\n    public void invalidate(String message) {\n        if (isValid) {\n            invalidateImpl(message);\n        }\n    }\n    @TruffleBoundary\n    private synchronized void invalidateImpl(String message) {\n        /*\n         * Check again, now that we are holding the lock. Since isValid is defined volatile,\n         * double-checked locking is allowed.\n         */\n        if (!isValid) {\n            return;\n        }\n        boolean invalidatedADependency = false;\n        Entry e = dependencies;\n        while (e != null) {\n            OptimizedAssumptionDependency dependency = e.awaitDependency();\n            if (dependency != null) {\n                OptimizedCallTarget callTarget = invalidateWithReason(dependency, \"assumption invalidated\");\n                invalidatedADependency = true;\n                if (TruffleRuntimeOptions.getValue(TraceTruffleAssumptions)) {\n                    logInvalidatedDependency(dependency, message);\n                }\n                if (callTarget != null) {\n                    callTarget.getCompilationProfile().reportInvalidated();\n                }\n            }\n            e = e.next;\n        }\n        dependencies = null;\n        size = 0;\n        sizeAfterLastRemove = 0;\n        isValid = false;\n        if (TruffleRuntimeOptions.getValue(TraceTruffleAssumptions)) {\n            if (invalidatedADependency) {\n                logStackTrace();\n            }\n        }\n    }\n    private void removeInvalidEntries() {\n        Entry last = null;\n        Entry e = dependencies;\n        dependencies = null;\n        while (e != null) {\n            if (e.isValid()) {\n                if (last == null) {\n                    dependencies = e;\n                } else {\n                    last.next = e;\n                }\n                last = e;\n            } else {\n                size--;\n            }\n            e = e.next;\n        }\n        if (last != null) {\n            last.next = null;\n        }\n        sizeAfterLastRemove = size;\n    }\n    /**\n     * Removes all {@linkplain OptimizedAssumptionDependency#isValid() invalid} dependencies.\n     */\n    public synchronized void removeInvalidDependencies() {\n        removeInvalidEntries();\n    }\n    /**\n     * Gets the number of dependencies registered with this assumption.\n     */\n<fim_suffix>    public synchronized int countDependencies() {\n        return size;\n    }\n    /**\n     * Registers some dependent code with this assumption.\n     *\n     * As the dependent code may not yet be available, a {@link Consumer} is returned that must be\n     * {@linkplain Consumer#accept(Object) notified} when the code becomes available. If there is an\n     * error while compiling or installing the code, the returned consumer must be called with a\n     * {@code null} argument.\n     *\n     * If this assumption is already invalid, then {@code null} is returned in which case the caller\n     * (e.g., the compiler) must ensure the dependent code is never executed.\n     */\n    public synchronized Consumer<OptimizedAssumptionDependency> registerDependency() {\n        if (isValid) {\n            if (size >= 2 * sizeAfterLastRemove) {\n                removeInvalidEntries();\n            }\n            Entry e = new Entry();\n            e.next = dependencies;\n            dependencies = e;\n            size++;\n            return e;\n        } else {\n            return null;\n        }\n    }\n    private OptimizedCallTarget invalidateWithReason(OptimizedAssumptionDependency dependency, String reason) {\n        if (dependency.getCompilable() != null) {\n            OptimizedCallTarget callTarget = (OptimizedCallTarget) dependency.getCompilable();\n            callTarget.invalidate(this, reason);\n            return callTarget;\n        } else {\n            dependency.invalidate();\n            return null;\n        }\n    }\n    @Override\n    public boolean isValid() {\n        return isValid;\n    }\n    private void logInvalidatedDependency(OptimizedAssumptionDependency dependency, String message) {\n        final StringBuilder sb = new StringBuilder(\"assumption '\").append(name).append(\"' invalidated installed code '\").append(dependency);\n        if (message != null && !message.isEmpty()) {\n            sb.append(\"' with message '\").append(message);\n        }\n        GraalTruffleRuntime.getRuntime().log(sb.toString());\n    }\n    private static void logStackTrace() {\n        final int skip = 1;\n        final int limit = TruffleRuntimeOptions.getValue(SharedTruffleRuntimeOptions.TraceTruffleStackTraceLimit);<fim_middle>// function below has no smell\n"}