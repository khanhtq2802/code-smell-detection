{"text": "<fim_prefix>import java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.apache.openjpa.jdbc.meta.ClassMapping;\nimport org.apache.openjpa.jdbc.meta.FieldMapping;\nimport org.apache.openjpa.jdbc.meta.Strategy;\nimport org.apache.openjpa.jdbc.meta.strats.ContainerFieldStrategy;\nimport org.apache.openjpa.jdbc.schema.ForeignKey;\nimport org.apache.openjpa.jdbc.sql.DBDictionary;\nimport org.apache.openjpa.jdbc.sql.SQLBuffer;\nimport org.apache.openjpa.jdbc.sql.SQLFactory;\nimport org.apache.openjpa.jdbc.sql.Select;\nimport org.apache.openjpa.kernel.LockLevels;\nimport org.apache.openjpa.kernel.LockScopes;\nimport org.apache.openjpa.kernel.MixedLockLevels;\nimport org.apache.openjpa.kernel.OpenJPAStateManager;\nimport org.apache.openjpa.kernel.StoreContext;\nimport org.apache.openjpa.kernel.VersionLockManager;\nimport org.apache.openjpa.lib.util.Localizer;\nimport org.apache.openjpa.util.LockException;\nimport org.apache.openjpa.util.StoreException;\n/**\n * Lock manager that uses exclusive database locks.\n *\n * @author Marc Prud'hommeaux\n */\npublic class PessimisticLockManager\n    extends VersionLockManager\n    implements JDBCLockManager {\n    public static final int LOCK_DATASTORE_ONLY = 1;\n    private static final Localizer _loc = Localizer.forPackage\n        (PessimisticLockManager.class);\n    protected JDBCStore _store;\n    public PessimisticLockManager() {\n        setVersionCheckOnReadLock(false);\n        setVersionUpdateOnWriteLock(false);\n    }\n    @Override\n    public void setContext(StoreContext ctx) {\n        super.setContext(ctx);\n        _store = (JDBCStore) ctx.getStoreManager().getInnermostDelegate();\n    }\n    @Override\n    public boolean selectForUpdate(Select sel, int lockLevel) {\n        if (lockLevel == LOCK_NONE)\n            return false;\n        DBDictionary dict = _store.getDBDictionary();\n        if (dict.simulateLocking)\n            return false;\n        dict.assertSupport(dict.supportsSelectForUpdate,\n            \"SupportsSelectForUpdate\");\n        if (!sel.supportsLocking()) {\n            if (log.isInfoEnabled())\n                log.info(_loc.get(\"cant-lock-on-load\",\n                    sel.toSelect(false, null).getSQL()));\n            return false;\n        }\n        ensureStoreManagerTransaction();\n        return true;\n    }\n    @Override\n    public void loadedForUpdate(OpenJPAStateManager sm) {\n        // we set a low lock level to indicate that we don't need datastore\n        // locking, but we don't necessarily have a read or write lock\n        // according to our superclass\n        if (getLockLevel(sm) == LOCK_NONE)\n            setLockLevel(sm, LOCK_DATASTORE_ONLY);\n    }\n    @Override\n    protected void lockInternal(OpenJPAStateManager sm, int level, int timeout,\n        Object sdata, boolean postVersionCheck) {\n        // we can skip any already-locked instance regardless of level because\n        // we treat all locks the same (though super doesn't).\n        // only need to lock if not loaded from locking result\n        ConnectionInfo info = (ConnectionInfo) sdata;\n        if (info == null || info.result == null || !info.result.isLocking())\n            lockRow(sm, timeout, level);\n        optimisticLockInternal(sm, level, timeout, sdata, postVersionCheck);\n    }\n    /**\n     * Lock the specified instance row by issuing a \"SELECT ... FOR UPDATE\"\n     * statement.\n     */\n    private void lockRow(OpenJPAStateManager sm, int timeout, int level) {\n        // assert that the dictionary supports the \"SELECT ... FOR UPDATE\"\n        // construct; if not, and we the assertion does not throw an\n        // exception, then just return without locking\n        DBDictionary dict = _store.getDBDictionary();\n        JDBCFetchConfiguration fetch = _store.getFetchConfiguration();\n        if (dict.simulateLocking)\n            return;\n        dict.assertSupport(dict.supportsSelectForUpdate, \"SupportsSelectForUpdate\");\n        Object id = sm.getObjectId();\n        ClassMapping mapping = (ClassMapping) sm.getMetaData();\n        //Code changed for OPENJPA-2449, code updated for OPENJPA-2547.  OPENJPA-2547 added\n        //one check to determine if the lock is a value of LockLevels.LOCK_NONE.  The first\n        //time a thread attempts to get a lock the lock will be null.  If the thread can't\n        //get the lock because another thread holds it, the lock will be non-null and have\n        //a value of LockLevels.LOCK_NONE.\n        List<SQLBuffer> sqls = (sm.getLock() == null || sm.getLock().equals(LockLevels.LOCK_NONE))\n            ?  getLockRows(dict, id, mapping, fetch, _store.getSQLFactory())\n            : new ArrayList<>();\n        if (ctx.getFetchConfiguration().getLockScope() == LockScopes.LOCKSCOPE_EXTENDED)\n            lockJoinTables(sqls, dict, id, mapping, fetch, _store.getSQLFactory());\n        ensureStoreManagerTransaction();\n        Connection conn = _store.getConnection();\n        PreparedStatement stmnt = null;\n        ResultSet rs = null;\n        try {\n            for (SQLBuffer sql : sqls) {\n                stmnt = prepareStatement(conn, sql);\n                dict.setTimeouts(stmnt, fetch, true);\n                rs = executeQuery(conn, stmnt, sql);\n                checkLock(rs, sm, timeout);\n            }\n        } catch (SQLException se) {\n            LockException e = new LockException(sm.getPersistenceCapable(), timeout, level);\n            e.setCause(se);\n            e.setFatal(dict.isFatalException(StoreException.LOCK, se)\n                    || level >= MixedLockLevels.LOCK_PESSIMISTIC_READ);\n            throw e;\n        } finally {\n            if (stmnt != null)\n                try { stmnt.close(); } catch (SQLException se) {}\n            if (rs != null)\n                try { rs.close(); } catch (SQLException se) {}\n            try { conn.close(); } catch (SQLException se) {}\n        }\n    }\n    protected List<SQLBuffer> getLockRows(DBDictionary dict, Object id, ClassMapping mapping,\n            JDBCFetchConfiguration fetch, SQLFactory factory) {\n        while (mapping.getJoinablePCSuperclassMapping() != null)\n            mapping = mapping.getJoinablePCSuperclassMapping();\n        // select only the PK columns, since we just want to lock\n        Select select = factory.newSelect();\n        select.select(mapping.getPrimaryKeyColumns());\n        select.wherePrimaryKey(id, mapping, _store);\n        List<SQLBuffer> sqls = new ArrayList<>();\n        sqls.add(select.toSelect(true, fetch));\n        return sqls;\n    }\n    protected void lockJoinTables(List<SQLBuffer> sqls, DBDictionary dict, Object id, ClassMapping mapping,\n            JDBCFetchConfiguration fetch, SQLFactory factory) {\n        FieldMapping[] fms = mapping.getFieldMappings();\n        for (int i = 0; i < fms.length; i++) {\n            Strategy strat = fms[i].getStrategy();\n            if (strat instanceof ContainerFieldStrategy) {\n                ForeignKey fk = ((ContainerFieldStrategy)strat).getJoinForeignKey();\n                Select select = factory.newSelect();\n                select.select(fk.getColumns());\n                select.whereForeignKey(fk, id, fms[i].getDefiningMapping(), _store);\n                sqls.add(select.toSelect(true, fetch));\n            }\n        }\n    }\n    /**\n     * Enforce that we have an actual transaction in progress so that we can\n     * start locking. The transaction should already be begun when using a\n     * datastore transaction; this will just be used if we are locking in\n     * optimistic mode.\n     */\n    private void ensureStoreManagerTransaction() {\n        if (!_store.getContext().isStoreActive()) {\n            _store.getContext().beginStore();\n            if (log.isTraceEnabled())\n                log.trace(_loc.get(\"start-trans-for-lock\"));\n        }\n    }\n    public JDBCStore getStore() {\n        return _store;\n    }\n    /**\n     * This method is to provide override for non-JDBC or JDBC-like\n     * implementation of preparing statement.\n     */\n    protected PreparedStatement prepareStatement(Connection conn, SQLBuffer sql)\n        throws SQLException {\n        return sql.prepareStatement(conn);\n    }\n    /**\n     * This method is to provide override for non-JDBC or JDBC-like\n     * implementation of executing query.\n     */\n<fim_suffix>    protected ResultSet executeQuery(Connection conn, PreparedStatement stmnt,\n        SQLBuffer sql) throws SQLException {\n        return stmnt.executeQuery();\n    }<fim_middle>// function below has no smell\n"}