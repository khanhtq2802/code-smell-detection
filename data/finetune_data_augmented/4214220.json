{"text": "<fim_prefix>\n<fim_suffix>public class EventAdapterGenerator\n{\n  public static AdapterClassLoader ldr = new AdapterClassLoader();\n  static Class  EVENTLISTENER          = null;\n  static String CLASSPACKAGE           = \"org/apache/bsf/util/event/adapters/\";\n  static String WRITEDIRECTORY         = null;\n  // starting 8 bytes of all Java Class files\n  static byte   CLASSHEADER[];\n  // constant pool items found in all event adapters\n  static short  BASECPCOUNT; // number of cp items + 1 ( cp item # 0 reserved for JVM )\n  static byte   BASECP[];    //\n  // some bytes in the middle of the class file (see below)\n  static byte   FIXEDCLASSBYTES[];\n  // the initialization method, noargs constructor\n  static byte   INITMETHOD[];\n  private static BSF_Log logger=null;\n  /* The static initializer */\n  static\n  {\n    // logger = LogFactory.getLog((org.apache.bsf.util.event.generator.EventAdapterGenerator.class).getName());\n        logger = BSF_LogFactory.getLog((org.apache.bsf.util.event.generator.EventAdapterGenerator.class).getName());\n    String USERCLASSPACKAGE = System.getProperty(\"DynamicEventClassPackage\",\n                                                 \"\");\n    if (!USERCLASSPACKAGE.equals(\"\"))\n    {\n      CLASSPACKAGE = USERCLASSPACKAGE;\n    }\n    if(CLASSPACKAGE.length() > 0 )\n    {\n      CLASSPACKAGE = CLASSPACKAGE.replace('\\\\','/');\n      if(!CLASSPACKAGE.endsWith(\"/\"))\n      { CLASSPACKAGE = CLASSPACKAGE+\"/\"; }\n    }\n    WRITEDIRECTORY = System.getProperty(\"DynamicEventClassWriteDirectory\",CLASSPACKAGE);\n    if(WRITEDIRECTORY.length() > 0 )\n    {\n      WRITEDIRECTORY = WRITEDIRECTORY.replace('\\\\','/');\n      if(!WRITEDIRECTORY.endsWith(\"/\"))\n      { WRITEDIRECTORY = WRITEDIRECTORY+\"/\"; }\n    }\n    try\n    // { EVENTLISTENER = Class.forName(\"java.util.EventListener\"); }\n    {\n            // EVENTLISTENER = Thread.currentThread().getContextClassLoader().loadClass (\"java.util.EventListener\"); // rgf, 2006-01-05\n            // rgf, 20070917: first try context class loader, then BSFManager's defining class loader\n            EVENTLISTENER=null;\n            ClassLoader tccl=Thread.currentThread().getContextClassLoader();\n            if (tccl!=null)\n            {\n                try {\n                     EVENTLISTENER = tccl.loadClass (\"java.util.EventListener\");\n                }\n                catch(ClassNotFoundException ex01)\n                {}\n            }\n            if (EVENTLISTENER==null)    // did not work, try to load it via the definedClassLoader\n            {\n                EVENTLISTENER = BSFManager.getDefinedClassLoader().loadClass (\"java.util.EventListener\");\n            }\n        }\n    catch(ClassNotFoundException ex)\n    {\n            System.err.println(ex.getMessage());\n            ex.printStackTrace();\n        }\n    // start of the Java Class File\n    CLASSHEADER = ByteUtility.addBytes(CLASSHEADER,(byte)0xCA);  // magic\n    CLASSHEADER = ByteUtility.addBytes(CLASSHEADER,(byte)0xFE);  // magic\n    CLASSHEADER = ByteUtility.addBytes(CLASSHEADER,(byte)0xBA);  // magic\n    CLASSHEADER = ByteUtility.addBytes(CLASSHEADER,(byte)0xBE);  // magic\n    CLASSHEADER = ByteUtility.addBytes(CLASSHEADER,(short)3);    // minor version\n    CLASSHEADER = ByteUtility.addBytes(CLASSHEADER,(short)45);   // major version\n    // Start the constant pool for base items in all event adapter classes\n    BASECPCOUNT = 17; // number of cp items + 1 ( cp item # 0 reserved for JVM )\n    // cp item 01\n    BASECP = Bytecode.addUtf8(BASECP,\"()V\");\n    // cp item 02\n    BASECP = Bytecode.addUtf8(BASECP,\"<init>\");\n    // cp item 03\n    BASECP = Bytecode.addUtf8(BASECP,\"Code\");\n    // cp item 04\n    BASECP = Bytecode.addUtf8(BASECP,\"eventProcessor\");\n    // cp item 05\n    BASECP = Bytecode.addUtf8(BASECP,\"java/lang/Object\");\n    // cp item 06\n    BASECP = Bytecode.addUtf8(BASECP,\"org/apache/bsf/util/event/EventAdapterImpl\");\n    // cp item 07\n    BASECP = Bytecode.addUtf8(BASECP,\"org/apache/bsf/util/event/EventProcessor\");\n    // cp item 08\n    BASECP = Bytecode.addUtf8(BASECP,\"(Ljava/lang/String;[Ljava/lang/Object;)V\");\n    // cp item 09\n    BASECP = Bytecode.addUtf8(BASECP,\"Lorg/apache/bsf/util/event/EventProcessor;\");\n    // cp item 10\n    BASECP = Bytecode.addClass(BASECP,(short)5); // Class \"java/lang/Object\"\n    // cp item 11\n    BASECP = Bytecode.addClass(BASECP,(short)6); // Class \"org/apache/bsf/util/event/EventAdapterImpl\"\n    // cp item 12\n    BASECP = Bytecode.addClass(BASECP,(short)7); // Class \"org/apache/bsf/util/event/EventProcessor\"\n    // cp item 13\n    BASECP = Bytecode.addNameAndType(BASECP,(short)2,(short)1); // \"<init>\" \"()V\"\n    // cp item 14\n    BASECP = Bytecode.addNameAndType(BASECP,(short)4,(short)9); // \"eventProcessor\" \"Lorg/apache/bsf/util/event/EventProcessor;\"\n    // cp item 15\n    BASECP = Bytecode.addFieldRef(BASECP,(short)11,(short)14);\n    // cp item 16\n    BASECP = Bytecode.addMethodRef(BASECP,(short)11,(short)13);\n    // fixed bytes in middle of class file\n    FIXEDCLASSBYTES = ByteUtility.addBytes(FIXEDCLASSBYTES,(short)0x21); // access_flags        (fixed)\n    FIXEDCLASSBYTES = ByteUtility.addBytes(FIXEDCLASSBYTES,(short)20);   // this_class          (fixed)\n    FIXEDCLASSBYTES = ByteUtility.addBytes(FIXEDCLASSBYTES,(short)11);   // super_class         (fixed)\n    FIXEDCLASSBYTES = ByteUtility.addBytes(FIXEDCLASSBYTES,(short)1);    // interface_count     (fixed)\n    FIXEDCLASSBYTES = ByteUtility.addBytes(FIXEDCLASSBYTES,(short)19);   // interfaces          (fixed)\n    FIXEDCLASSBYTES = ByteUtility.addBytes(FIXEDCLASSBYTES,(short)0);    // field_count         (fixed)\n    // initialization method, constructor\n    INITMETHOD = ByteUtility.addBytes(INITMETHOD,(short)1);              // access_flags\n    INITMETHOD = ByteUtility.addBytes(INITMETHOD,(short)2);              // name_index \"<init>\"\n    INITMETHOD = ByteUtility.addBytes(INITMETHOD,(short)1);              // descriptor_index \"()V\"\n    INITMETHOD = ByteUtility.addBytes(INITMETHOD,(short)1);              // attribute_count\n    INITMETHOD = ByteUtility.addBytes(INITMETHOD,(short)3);              // attribute_name_index \"Code\"\n    INITMETHOD = ByteUtility.addBytes(INITMETHOD,(long)17);              // attribute_length\n    INITMETHOD = ByteUtility.addBytes(INITMETHOD,(short)1);              // max_stack\n    INITMETHOD = ByteUtility.addBytes(INITMETHOD,(short)1);              // max_locals\n    INITMETHOD = ByteUtility.addBytes(INITMETHOD,(long)5);               // code_length\n    //code\n    INITMETHOD = ByteUtility.addBytes(INITMETHOD,(byte)0x2A);            // aload_0\n    INITMETHOD = ByteUtility.addBytes(INITMETHOD,(byte)0xB7);            // invokespecial\n    INITMETHOD = ByteUtility.addBytes(INITMETHOD,(short)16);             // method_ref index\n    INITMETHOD = ByteUtility.addBytes(INITMETHOD,(byte)0xB1);            // return\n    // exception table\n    INITMETHOD = ByteUtility.addBytes(INITMETHOD,(short)0);              // exception_table_length\n    INITMETHOD = ByteUtility.addBytes(INITMETHOD,(short)0);              // attributes_count\n  }\n  /* methods that take an EventListener Class Type to create an EventAdapterClass */\n  public static Class makeEventAdapterClass(Class listenerType,boolean writeClassFile)\n  {\n      logger.debug(\"EventAdapterGenerator\");\n        if( EVENTLISTENER.isAssignableFrom(listenerType) )\n    {<fim_middle>// class below is blob\n"}