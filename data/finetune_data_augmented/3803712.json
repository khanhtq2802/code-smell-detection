{"text": "<fim_prefix> * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage backtype.storm.topology;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport backtype.storm.Config;\nimport backtype.storm.generated.GlobalStreamId;\nimport backtype.storm.state.KeyValueState;\nimport backtype.storm.state.State;\nimport backtype.storm.state.StateFactory;\nimport backtype.storm.task.OutputCollector;\nimport backtype.storm.task.TopologyContext;\nimport backtype.storm.tuple.Tuple;\nimport backtype.storm.windowing.WindowLifecycleListener;\n/**\n * Wraps a {@link IStatefulWindowedBolt} and handles the execution. Saves the last expired\n * and evaluated states of the window during checkpoint and restores the state during recovery.\n */\npublic class StatefulWindowedBoltExecutor<T extends State> extends WindowedBoltExecutor implements IStatefulBolt<T> {\n    private static final Logger LOG = LoggerFactory.getLogger(StatefulWindowedBoltExecutor.class);\n    private final IStatefulWindowedBolt<T> statefulWindowedBolt;\n    private transient String msgIdFieldName;\n    private transient TopologyContext topologyContext;\n    private transient OutputCollector outputCollector;\n    // last evaluated and last expired message ids per task stream (source taskid + stream-id)\n    private transient KeyValueState<TaskStream, WindowState> streamState;\n    private transient List<Tuple> pendingTuples;\n    // the states to be recovered\n    private transient Map<TaskStream, WindowState> recoveryStates;\n    private transient boolean stateInitialized;\n    private transient boolean prePrepared;\n    public StatefulWindowedBoltExecutor(IStatefulWindowedBolt<T> bolt) {\n        super(bolt);\n        this.statefulWindowedBolt = bolt;\n    }\n    @Override\n    public void prepare(Map stormConf, TopologyContext context, OutputCollector collector) {\n        prepare(stormConf, context, collector, getWindowState(stormConf, context));\n    }\n    // package access for unit tests\n    void prepare(Map stormConf, TopologyContext context, OutputCollector collector,\n                 KeyValueState<TaskStream, WindowState> windowState) {\n        init(stormConf, context, collector, windowState);\n        super.prepare(stormConf, context, collector);\n    }\n    private void init(Map stormConf, TopologyContext context, OutputCollector collector,\n                      KeyValueState<TaskStream, WindowState> windowState) {\n        if (stormConf.containsKey(Config.TOPOLOGY_BOLTS_MESSAGE_ID_FIELD_NAME)) {\n            msgIdFieldName = (String) stormConf.get(Config.TOPOLOGY_BOLTS_MESSAGE_ID_FIELD_NAME);\n        } else {\n            throw new IllegalArgumentException(Config.TOPOLOGY_BOLTS_MESSAGE_ID_FIELD_NAME + \" is not set\");\n        }\n        topologyContext = context;\n        outputCollector = collector;\n        streamState = windowState;\n        pendingTuples = new ArrayList<>();\n        recoveryStates = new HashMap<>();\n        stateInitialized = false;\n        prePrepared = false;\n    }\n    @Override\n    public void execute(Tuple input) {\n        if (!isStateInitialized()) {\n            throw new IllegalStateException(\"execute invoked before initState with input tuple \" + input);\n        } else if (isRecovering()) {\n            handleRecovery(input);\n        } else {\n            super.execute(input);\n        }\n    }\n    @Override\n    protected void start() {\n        if (!isStateInitialized() || isRecovering()) {\n            LOG.debug(\"Will invoke start after recovery is complete.\");\n        } else {\n            super.start();\n        }\n    }\n    private void handleRecovery(Tuple input) {\n        long msgId = getMsgId(input);\n        TaskStream taskStream = TaskStream.fromTuple(input);\n        WindowState state = recoveryStates.get(taskStream);\n        LOG.debug(\"handleRecovery, recoveryStates {}\", recoveryStates);\n        if (state != null) {\n            LOG.debug(\"Tuple msgid {}, saved state {}\", msgId, state);\n            if (msgId <= state.lastExpired) {\n                LOG.debug(\"Ignoring tuple since msg id {} <= lastExpired id {}\", msgId, state.lastExpired);\n                outputCollector.ack(input);\n            } else if (msgId <= state.lastEvaluated) {\n                super.execute(input);\n            } else {\n                LOG.debug(\"Tuple msg id {} > lastEvaluated id {}, adding to pendingTuples and clearing recovery state \" +\n                        \"for taskStream {}\", msgId, state.lastEvaluated, taskStream);\n                pendingTuples.add(input);\n                clearRecoveryState(taskStream);\n            }\n        } else {\n            pendingTuples.add(input);\n        }\n    }\n    private void clearRecoveryState(TaskStream stream) {\n        recoveryStates.remove(stream);\n        if (!isRecovering()) {\n            super.start();\n            LOG.debug(\"Recovery complete, processing {} pending tuples\", pendingTuples.size());\n            for (Tuple tuple : pendingTuples) {\n                super.execute(tuple);\n            }\n        }\n    }\n    private boolean isRecovering() {\n        return !recoveryStates.isEmpty();\n    }\n    private boolean isStateInitialized() {\n        return stateInitialized;\n    }\n    @Override\n    public void initState(T state) {\n        if (stateInitialized) {\n            LOG.warn(\"State is already initialized. Ignoring initState\");\n            return;\n        }\n        statefulWindowedBolt.initState((T) state);\n        // query the streamState for each input task stream and compute recoveryStates\n        for (GlobalStreamId streamId : topologyContext.getThisSources().keySet()) {\n            for (int taskId : topologyContext.getComponentTasks(streamId.get_componentId())) {\n                WindowState windowState = streamState.get(new TaskStream(taskId, streamId));\n                if (windowState != null) {\n                    recoveryStates.put(new TaskStream(taskId, streamId), windowState);\n                }\n            }\n        }\n        LOG.debug(\"recoveryStates {}\", recoveryStates);\n        stateInitialized = true;\n        start();\n    }\n    @Override\n    public void preCommit(long txid) {\n        if (!isStateInitialized() || (!isRecovering() && prePrepared)) {\n            LOG.debug(\"Commit streamState, txid {}\", txid);\n            streamState.commit(txid);\n        } else {\n            LOG.debug(\"Still recovering, ignoring preCommit and not committing streamState.\");\n        }\n    }\n    @Override\n    public void prePrepare(long txid) {\n        if (!isStateInitialized()) {\n            LOG.warn(\"Cannot prepare before initState\");\n        } else if (!isRecovering()) {\n            LOG.debug(\"Prepare streamState, txid {}\", txid);\n            streamState.prepareCommit(txid);\n            prePrepared = true;\n        } else {\n            LOG.debug(\"Still recovering, ignoring prePrepare and not preparing streamState.\");\n        }\n    }\n    @Override\n    public void preRollback() {\n        LOG.debug(\"Rollback streamState, stateInitialized {}\", stateInitialized);\n        streamState.rollback();\n    }\n    @Override\n    protected WindowLifecycleListener<Tuple> newWindowLifecycleListener() {\n        final WindowLifecycleListener<Tuple> parentListener = super.newWindowLifecycleListener();\n        return new WindowLifecycleListener<Tuple>() {\n            @Override\n            public void onExpiry(List<Tuple> events) {\n                parentListener.onExpiry(events);\n            }\n            @Override\n            public void onActivation(List<Tuple> events, List<Tuple> newEvents, List<Tuple> expired) {\n                if (isRecovering()) {\n                    String msg = String.format(\"Unexpected activation with events %s, newEvents %s, expired %s in recovering state. \" +\n                            \"recoveryStates %s \", events, newEvents, expired, recoveryStates);\n                    LOG.error(msg);\n                    throw new IllegalStateException(msg);\n                } else {\n                    parentListener.onActivation(events, newEvents, expired);\n                    updateWindowState(expired, newEvents);\n                }\n            }\n        };\n    }\n<fim_suffix>    private void updateWindowState(List<Tuple> expired, List<Tuple> newEvents) {\n        LOG.debug(\"Update window state, {} expired, {} new events\", expired.size(), newEvents.size());\n        Map<TaskStream, WindowState> state = new HashMap<>();\n        updateState(state, expired, false);\n        updateState(state, newEvents, true);\n        updateStreamState(state);\n    }<fim_middle>// function below has no smell\n"}