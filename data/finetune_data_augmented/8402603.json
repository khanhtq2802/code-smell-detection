{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.file.remote;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.net.InetAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.security.KeyPair;\nimport java.security.interfaces.DSAPrivateKey;\nimport java.security.interfaces.DSAPublicKey;\nimport java.security.interfaces.RSAPrivateKey;\nimport java.security.interfaces.RSAPublicKey;\nimport java.util.ArrayList;\nimport java.util.Hashtable;\nimport java.util.List;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\nimport com.jcraft.jsch.ChannelSftp;\nimport com.jcraft.jsch.JSch;\nimport com.jcraft.jsch.JSchException;\nimport com.jcraft.jsch.Proxy;\nimport com.jcraft.jsch.Session;\nimport com.jcraft.jsch.SftpException;\nimport com.jcraft.jsch.SocketFactory;\nimport com.jcraft.jsch.UIKeyboardInteractive;\nimport com.jcraft.jsch.UserInfo;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.InvalidPayloadException;\nimport org.apache.camel.LoggingLevel;\nimport org.apache.camel.RuntimeCamelException;\nimport org.apache.camel.component.file.FileComponent;\nimport org.apache.camel.component.file.GenericFile;\nimport org.apache.camel.component.file.GenericFileEndpoint;\nimport org.apache.camel.component.file.GenericFileExist;\nimport org.apache.camel.component.file.GenericFileOperationFailedException;\nimport org.apache.camel.support.ResourceHelper;\nimport org.apache.camel.util.FileUtil;\nimport org.apache.camel.util.IOHelper;\nimport org.apache.camel.util.ObjectHelper;\nimport org.apache.camel.util.StopWatch;\nimport org.apache.camel.util.TimeUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport static org.apache.camel.util.ObjectHelper.isNotEmpty;\n/**\n * SFTP remote file operations\n * <p/>\n * The JSCH session and channel are not thread-safe so we need to synchronize\n * access to using this operation.\n */\npublic class SftpOperations implements RemoteFileOperations<SftpRemoteFile> {\n    private static final Logger LOG = LoggerFactory.getLogger(SftpOperations.class);\n    private static final Pattern UP_DIR_PATTERN = Pattern.compile(\"/[^/]+\");\n    private Proxy proxy;\n    private SftpEndpoint endpoint;\n    private ChannelSftp channel;\n    private Session session;\n    public SftpOperations() {\n    }\n    public SftpOperations(Proxy proxy) {\n        this.proxy = proxy;\n    }\n    /**\n     * Extended user info which supports interactive keyboard mode, by entering\n     * the password.\n     */\n    public interface ExtendedUserInfo extends UserInfo, UIKeyboardInteractive {\n    }\n    public void setEndpoint(GenericFileEndpoint<SftpRemoteFile> endpoint) {\n        this.endpoint = (SftpEndpoint)endpoint;\n    }\n    public synchronized boolean connect(RemoteFileConfiguration configuration) throws GenericFileOperationFailedException {\n        if (isConnected()) {\n            // already connected\n            return true;\n        }\n        boolean connected = false;\n        int attempt = 0;\n        while (!connected) {\n            try {\n                if (LOG.isTraceEnabled() && attempt > 0) {\n                    LOG.trace(\"Reconnect attempt #{} connecting to + {}\", attempt, configuration.remoteServerInformation());\n                }\n                if (channel == null || !channel.isConnected()) {\n                    if (session == null || !session.isConnected()) {\n                        LOG.trace(\"Session isn't connected, trying to recreate and connect.\");\n                        session = createSession(configuration);\n                        if (endpoint.getConfiguration().getConnectTimeout() > 0) {\n                            LOG.trace(\"Connecting use connectTimeout: {} ...\", endpoint.getConfiguration().getConnectTimeout());\n                            session.connect(endpoint.getConfiguration().getConnectTimeout());\n                        } else {\n                            LOG.trace(\"Connecting ...\");\n                            session.connect();\n                        }\n                    }\n                    LOG.trace(\"Channel isn't connected, trying to recreate and connect.\");\n                    channel = (ChannelSftp)session.openChannel(\"sftp\");\n                    if (endpoint.getConfiguration().getConnectTimeout() > 0) {\n                        LOG.trace(\"Connecting use connectTimeout: {} ...\", endpoint.getConfiguration().getConnectTimeout());\n                        channel.connect(endpoint.getConfiguration().getConnectTimeout());\n                    } else {\n                        LOG.trace(\"Connecting ...\");\n                        channel.connect();\n                    }\n                    LOG.debug(\"Connected to {}\", configuration.remoteServerInformation());\n                }\n                // yes we could connect\n                connected = true;\n            } catch (Exception e) {\n                // check if we are interrupted so we can break out\n                if (Thread.currentThread().isInterrupted()) {\n                    throw new GenericFileOperationFailedException(\"Interrupted during connecting\", new InterruptedException(\"Interrupted during connecting\"));\n                }\n                GenericFileOperationFailedException failed = new GenericFileOperationFailedException(\"Cannot connect to \" + configuration.remoteServerInformation(), e);\n                LOG.trace(\"Cannot connect due: {}\", failed.getMessage());\n                attempt++;\n                if (attempt > endpoint.getMaximumReconnectAttempts()) {\n                    throw failed;\n                }\n                if (endpoint.getReconnectDelay() > 0) {\n                    try {\n                        Thread.sleep(endpoint.getReconnectDelay());\n                    } catch (InterruptedException ie) {\n                        // we could potentially also be interrupted during sleep\n                        Thread.currentThread().interrupt();\n                        throw new GenericFileOperationFailedException(\"Interrupted during sleeping\", ie);\n                    }\n                }\n            }\n        }\n        configureBulkRequests();\n        return true;\n    }\n    private void configureBulkRequests() {\n        try {\n            tryConfigureBulkRequests();\n        } catch (JSchException e) {\n            throw new GenericFileOperationFailedException(\"Failed to configure number of bulk requests\", e);\n        }\n    }\n<fim_suffix>    private void tryConfigureBulkRequests() throws JSchException {\n        Integer bulkRequests = endpoint.getConfiguration().getBulkRequests();\n        if (bulkRequests != null) {\n            LOG.trace(\"configuring channel to use up to {} bulk request(s)\", bulkRequests);\n            channel.setBulkRequests(bulkRequests);\n        }\n    }\n    protected Session createSession(final RemoteFileConfiguration configuration) throws JSchException {\n        final JSch jsch = new JSch();\n        JSch.setLogger(new JSchLogger(endpoint.getConfiguration().getJschLoggingLevel()));\n        SftpConfiguration sftpConfig = (SftpConfiguration)configuration;\n        if (isNotEmpty(sftpConfig.getCiphers())) {\n            LOG.debug(\"Using ciphers: {}\", sftpConfig.getCiphers());\n            Hashtable<String, String> ciphers = new Hashtable<>();\n            ciphers.put(\"cipher.s2c\", sftpConfig.getCiphers());\n            ciphers.put(\"cipher.c2s\", sftpConfig.getCiphers());\n            JSch.setConfig(ciphers);\n        }\n        if (isNotEmpty(sftpConfig.getPrivateKeyFile())) {\n            LOG.debug(\"Using private keyfile: {}\", sftpConfig.getPrivateKeyFile());\n            if (isNotEmpty(sftpConfig.getPrivateKeyPassphrase())) {\n                jsch.addIdentity(sftpConfig.getPrivateKeyFile(), sftpConfig.getPrivateKeyPassphrase());\n            } else {\n                jsch.addIdentity(sftpConfig.getPrivateKeyFile());\n            }\n        }\n        if (sftpConfig.getPrivateKey() != null) {\n            LOG.debug(\"Using private key information from byte array\");\n            byte[] passphrase = null;\n            if (isNotEmpty(sftpConfig.getPrivateKeyPassphrase())) {\n                try {\n                    passphrase = sftpConfig.getPrivateKeyPassphrase().getBytes(\"UTF-8\");\n                } catch (UnsupportedEncodingException e) {\n                    throw new JSchException(\"Cannot transform passphrase to byte[]\", e);\n                }\n            }\n            jsch.addIdentity(\"ID\", sftpConfig.getPrivateKey(), null, passphrase);\n        }\n        if (sftpConfig.getPrivateKeyUri() != null) {<fim_middle>// function below has no smell\n"}