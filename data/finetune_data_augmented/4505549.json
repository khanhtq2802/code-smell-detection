{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n * agreements. See the NOTICE file distributed with this work for additional information regarding\n * copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n * copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage org.apache.fluo.core.impl;\n\nimport java.io.IOException;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.SortedSet;\nimport java.util.Timer;\nimport java.util.TimerTask;\nimport java.util.TreeSet;\n\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Preconditions;\nimport org.apache.curator.framework.recipes.nodes.PersistentNode;\nimport org.apache.fluo.accumulo.util.LongUtil;\nimport org.apache.fluo.accumulo.util.ZookeeperPath;\nimport org.apache.fluo.core.oracle.Stamp;\nimport org.apache.fluo.core.util.CuratorUtil;\nimport org.apache.zookeeper.CreateMode;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Allocates timestamps from Oracle for transactions and tracks the oldest active timestamp in\n * Zookeeper for garbage collection\n */\n<fim_suffix>public class TimestampTracker implements AutoCloseable {\n\n  private static final Logger log = LoggerFactory.getLogger(TimestampTracker.class);\n  private volatile long zkTimestamp = -1;\n  private final Environment env;\n  private final SortedSet<Long> timestamps = new TreeSet<>();\n  private volatile PersistentNode node = null;\n  private final TransactorID tid;\n  private final Timer timer;\n\n  private boolean closed = false;\n  private int allocationsInProgress = 0;\n  private boolean updatingZk = false;\n\n  public TimestampTracker(Environment env, TransactorID tid, long updatePeriodMs) {\n    Objects.requireNonNull(env, \"environment cannot be null\");\n    Objects.requireNonNull(tid, \"tid cannot be null\");\n    Preconditions.checkArgument(updatePeriodMs > 0, \"update period must be positive\");\n    this.env = env;\n    this.tid = tid;\n\n    TimerTask tt = new TimerTask() {\n\n      private int sawZeroCount = 0;\n\n      @Override\n      public void run() {\n        try {\n          long ts = 0;\n\n          synchronized (TimestampTracker.this) {\n            if (closed) {\n              return;\n            }\n\n            if (allocationsInProgress > 0) {\n              sawZeroCount = 0;\n              if (!timestamps.isEmpty()) {\n                if (updatingZk) {\n                  throw new IllegalStateException(\"expected updatingZk to be false\");\n                }\n                ts = timestamps.first();\n                updatingZk = true;\n              }\n            } else if (allocationsInProgress == 0) {\n              sawZeroCount++;\n              if (sawZeroCount >= 2) {\n                sawZeroCount = 0;\n                closeZkNode();\n              }\n            } else {\n              throw new IllegalStateException(\"allocationsInProgress = \" + allocationsInProgress);\n            }\n\n          }\n\n          // update can be done outside of sync block as timer has one thread and future\n          // executions of run method will block until this method returns\n          if (updatingZk) {\n            try {\n              updateZkNode(ts);\n            } finally {\n              synchronized (TimestampTracker.this) {\n                updatingZk = false;\n              }\n            }\n          }\n        } catch (Exception e) {\n          log.error(\"Exception occurred in Zookeeper update thread\", e);\n        }\n      }\n    };\n    timer = new Timer(\"TimestampTracker timer\", true);\n    timer.schedule(tt, updatePeriodMs, updatePeriodMs);\n  }\n\n  public TimestampTracker(Environment env, TransactorID tid) {\n    this(env, tid, env.getConfiguration().getLong(FluoConfigurationImpl.ZK_UPDATE_PERIOD_PROP,\n        FluoConfigurationImpl.ZK_UPDATE_PERIOD_MS_DEFAULT));\n  }\n\n  /**\n   * Allocate a timestamp\n   */\n  public Stamp allocateTimestamp() {\n\n    synchronized (this) {\n      Preconditions.checkState(!closed, \"tracker closed \");\n\n      if (node == null) {\n        Preconditions.checkState(allocationsInProgress == 0,\n            \"expected allocationsInProgress == 0 when node == null\");\n        Preconditions.checkState(!updatingZk, \"unexpected concurrent ZK update\");\n\n        createZkNode(getTimestamp().getTxTimestamp());\n      }\n\n      allocationsInProgress++;\n    }\n\n    try {\n      Stamp ts = getTimestamp();\n\n      synchronized (this) {\n        timestamps.add(ts.getTxTimestamp());\n      }\n\n      return ts;\n    } catch (RuntimeException re) {\n      synchronized (this) {\n        allocationsInProgress--;\n      }\n      throw re;\n    }\n  }\n\n  /**\n   * Remove a timestamp (of completed transaction)\n   */\n  public synchronized void removeTimestamp(long ts) throws NoSuchElementException {\n    Preconditions.checkState(!closed, \"tracker closed \");\n    Preconditions.checkState(allocationsInProgress > 0,\n        \"allocationsInProgress should be > 0 \" + allocationsInProgress);\n    Objects.requireNonNull(node);\n    if (timestamps.remove(ts) == false) {\n      throw new NoSuchElementException(\n          \"Timestamp \" + ts + \" was previously removed or does not exist\");\n    }\n\n    allocationsInProgress--;\n  }\n\n  private Stamp getTimestamp() {\n    return env.getSharedResources().getOracleClient().getStamp();\n  }\n\n  private void createZkNode(long ts) {\n    Preconditions.checkState(node == null, \"expected node to be null\");\n    node = new PersistentNode(env.getSharedResources().getCurator(), CreateMode.EPHEMERAL, false,\n        getNodePath(), LongUtil.toByteArray(ts));\n    CuratorUtil.startAndWait(node, 10);\n    zkTimestamp = ts;\n  }\n\n  private void closeZkNode() {\n    try {\n      if (node != null) {\n        node.close();\n        node = null;\n      }\n    } catch (IOException e) {\n      log.error(\"Failed to close timestamp tracker ephemeral node\");\n      throw new IllegalStateException(e);\n    }\n  }\n\n  private void updateZkNode(long ts) {\n    if (ts != zkTimestamp) {\n      try {\n        node.setData(LongUtil.toByteArray(ts));\n      } catch (Exception e) {\n        throw new IllegalStateException(e);\n      }\n    }\n    zkTimestamp = ts;\n  }\n\n  @VisibleForTesting\n  public synchronized void updateZkNode() {\n    Preconditions.checkState(!updatingZk, \"unexpected concurrent ZK update\");\n\n    if (allocationsInProgress > 0) {\n      if (!timestamps.isEmpty()) {\n        updateZkNode(timestamps.first());\n      }\n    } else if (allocationsInProgress == 0) {\n      closeZkNode();\n    } else {\n      throw new IllegalStateException(\"allocationsInProgress = \" + allocationsInProgress);\n    }\n  }\n\n  @VisibleForTesting\n  public long getOldestActiveTimestamp() {\n    return timestamps.first();\n  }\n\n  @VisibleForTesting\n  public long getZookeeperTimestamp() {\n    return zkTimestamp;\n  }\n\n  @VisibleForTesting\n  public boolean isEmpty() {\n    return timestamps.isEmpty();\n  }\n\n  @VisibleForTesting\n  public String getNodePath() {\n    return ZookeeperPath.TRANSACTOR_TIMESTAMPS + \"/\" + tid;\n  }\n\n  @Override\n  public synchronized void close() {\n    Preconditions.checkState(!closed, \"tracker already closed\");\n    closed = true;\n    timer.cancel();\n    closeZkNode();\n  }\n}<fim_middle>// class below is blob\n"}