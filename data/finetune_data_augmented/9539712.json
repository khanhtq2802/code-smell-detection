{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.yarn.server.sharedcachemanager;\n\nimport java.io.IOException;\nimport java.lang.management.ManagementFactory;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\nimport org.apache.hadoop.HadoopIllegalArgumentException;\nimport org.apache.hadoop.classification.InterfaceAudience.Private;\nimport org.apache.hadoop.classification.InterfaceStability.Evolving;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.fs.FSDataOutputStream;\nimport org.apache.hadoop.fs.FileSystem;\nimport org.apache.hadoop.fs.Path;\nimport org.apache.hadoop.service.CompositeService;\nimport org.apache.hadoop.util.concurrent.HadoopExecutors;\nimport org.apache.hadoop.yarn.conf.YarnConfiguration;\nimport org.apache.hadoop.yarn.exceptions.YarnException;\nimport org.apache.hadoop.yarn.server.sharedcachemanager.metrics.CleanerMetrics;\nimport org.apache.hadoop.yarn.server.sharedcachemanager.store.SCMStore;\n\nimport com.google.common.util.concurrent.ThreadFactoryBuilder;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * The cleaner service that maintains the shared cache area, and cleans up stale\n * entries on a regular basis.\n */\n@Private\n@Evolving\npublic class CleanerService extends CompositeService {\n  /**\n   * The name of the global cleaner lock that the cleaner creates to indicate\n   * that a cleaning process is in progress.\n   */\n  public static final String GLOBAL_CLEANER_PID = \".cleaner_pid\";\n\n  private static final Logger LOG =\n      LoggerFactory.getLogger(CleanerService.class);\n\n  private Configuration conf;\n  private CleanerMetrics metrics;\n  private ScheduledExecutorService scheduledExecutor;\n  private final SCMStore store;\n  private final Lock cleanerTaskLock;\n\n  public CleanerService(SCMStore store) {\n    super(\"CleanerService\");\n    this.store = store;\n    this.cleanerTaskLock = new ReentrantLock();\n  }\n\n<fim_suffix>  @Override\n  protected void serviceInit(Configuration conf) throws Exception {\n    this.conf = conf;\n\n    // create scheduler executor service that services the cleaner tasks\n    // use 2 threads to accommodate the on-demand tasks and reduce the chance of\n    // back-to-back runs\n    ThreadFactory tf =\n        new ThreadFactoryBuilder().setNameFormat(\"Shared cache cleaner\").build();\n    scheduledExecutor = HadoopExecutors.newScheduledThreadPool(2, tf);\n    super.serviceInit(conf);\n  }\n\n  @Override\n  protected void serviceStart() throws Exception {\n    if (!writeGlobalCleanerPidFile()) {\n      throw new YarnException(\"The global cleaner pid file already exists! \" +\n          \"It appears there is another CleanerService running in the cluster\");\n    }\n\n    this.metrics = CleanerMetrics.getInstance();\n\n    // Start dependent services (i.e. AppChecker)\n    super.serviceStart();\n\n    Runnable task =\n        CleanerTask.create(conf, store, metrics, cleanerTaskLock);\n    long periodInMinutes = getPeriod(conf);\n    scheduledExecutor.scheduleAtFixedRate(task, getInitialDelay(conf),\n        periodInMinutes, TimeUnit.MINUTES);\n    LOG.info(\"Scheduled the shared cache cleaner task to run every \"\n        + periodInMinutes + \" minutes.\");\n  }\n\n  @Override\n  protected void serviceStop() throws Exception {\n    LOG.info(\"Shutting down the background thread.\");\n    scheduledExecutor.shutdownNow();\n    try {\n      if (scheduledExecutor.awaitTermination(10, TimeUnit.SECONDS)) {\n        LOG.info(\"The background thread stopped.\");\n      } else {\n        LOG.warn(\"Gave up waiting for the cleaner task to shutdown.\");\n      }\n    } catch (InterruptedException e) {\n      LOG.warn(\"The cleaner service was interrupted while shutting down the task.\",\n          e);\n    }\n\n    removeGlobalCleanerPidFile();\n\n    super.serviceStop();\n  }\n\n  /**\n   * Execute an on-demand cleaner task.\n   */\n  protected void runCleanerTask() {\n    Runnable task =\n        CleanerTask.create(conf, store, metrics, cleanerTaskLock);\n    // this is a non-blocking call (it simply submits the task to the executor\n    // queue and returns)\n    this.scheduledExecutor.execute(task);\n  }\n\n  /**\n   * To ensure there are not multiple instances of the SCM running on a given\n   * cluster, a global pid file is used. This file contains the hostname of the\n   * machine that owns the pid file.\n   *\n   * @return true if the pid file was written, false otherwise\n   * @throws YarnException\n   */\n  private boolean writeGlobalCleanerPidFile() throws YarnException {\n    String root =\n        conf.get(YarnConfiguration.SHARED_CACHE_ROOT,\n            YarnConfiguration.DEFAULT_SHARED_CACHE_ROOT);\n    Path pidPath = new Path(root, GLOBAL_CLEANER_PID);\n    try {\n      FileSystem fs = FileSystem.get(this.conf);\n\n      if (fs.exists(pidPath)) {\n        return false;\n      }\n\n      FSDataOutputStream os = fs.create(pidPath, false);\n      // write the hostname and the process id in the global cleaner pid file\n      final String ID = ManagementFactory.getRuntimeMXBean().getName();\n      os.writeUTF(ID);\n      os.close();\n      // add it to the delete-on-exit to ensure it gets deleted when the JVM\n      // exits\n      fs.deleteOnExit(pidPath);\n    } catch (IOException e) {\n      throw new YarnException(e);\n    }\n    LOG.info(\"Created the global cleaner pid file at \" + pidPath.toString());\n    return true;\n  }\n\n  private void removeGlobalCleanerPidFile() {\n    try {\n      FileSystem fs = FileSystem.get(this.conf);\n      String root =\n          conf.get(YarnConfiguration.SHARED_CACHE_ROOT,\n              YarnConfiguration.DEFAULT_SHARED_CACHE_ROOT);\n\n      Path pidPath = new Path(root, GLOBAL_CLEANER_PID);\n\n\n      fs.delete(pidPath, false);\n      LOG.info(\"Removed the global cleaner pid file at \" + pidPath.toString());\n    } catch (IOException e) {\n      LOG.error(\n          \"Unable to remove the global cleaner pid file! The file may need \"\n              + \"to be removed manually.\", e);\n    }\n  }\n\n  private static int getInitialDelay(Configuration conf) {\n    int initialDelayInMinutes =\n        conf.getInt(YarnConfiguration.SCM_CLEANER_INITIAL_DELAY_MINS,\n            YarnConfiguration.DEFAULT_SCM_CLEANER_INITIAL_DELAY_MINS);\n    // negative value is invalid; use the default\n    if (initialDelayInMinutes < 0) {\n      throw new HadoopIllegalArgumentException(\"Negative initial delay value: \"\n          + initialDelayInMinutes\n          + \". The initial delay must be greater than zero.\");\n    }\n    return initialDelayInMinutes;\n  }\n\n  private static int getPeriod(Configuration conf) {\n    int periodInMinutes =\n        conf.getInt(YarnConfiguration.SCM_CLEANER_PERIOD_MINS,\n            YarnConfiguration.DEFAULT_SCM_CLEANER_PERIOD_MINS);\n    // non-positive value is invalid; use the default\n    if (periodInMinutes <= 0) {\n      throw new HadoopIllegalArgumentException(\"Non-positive period value: \"\n          + periodInMinutes\n          + \". The cleaner period must be greater than or equal to zero.\");\n    }\n    return periodInMinutes;\n  }\n}<fim_middle>// function below has no smell\n"}