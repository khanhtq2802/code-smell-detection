{"text": "<fim_prefix>\n<fim_suffix>@InterfaceAudience.Private\npublic class SplitTableRegionProcedure\n    extends AbstractStateMachineRegionProcedure<SplitTableRegionState> {\n  private static final Logger LOG = LoggerFactory.getLogger(SplitTableRegionProcedure.class);\n  private Boolean traceEnabled = null;\n  private RegionInfo daughter_1_RI;\n  private RegionInfo daughter_2_RI;\n  private byte[] bestSplitRow;\n  private RegionSplitPolicy splitPolicy;\n  public SplitTableRegionProcedure() {\n    // Required by the Procedure framework to create the procedure on replay\n  }\n  public SplitTableRegionProcedure(final MasterProcedureEnv env,\n      final RegionInfo regionToSplit, final byte[] splitRow) throws IOException {\n    super(env, regionToSplit);\n    preflightChecks(env, true);\n    // When procedure goes to run in its prepare step, it also does these checkOnline checks. Here\n    // we fail-fast on construction. There it skips the split with just a warning.\n    checkOnline(env, regionToSplit);\n    this.bestSplitRow = splitRow;\n    checkSplittable(env, regionToSplit, bestSplitRow);\n    final TableName table = regionToSplit.getTable();\n    final long rid = getDaughterRegionIdTimestamp(regionToSplit);\n    this.daughter_1_RI = RegionInfoBuilder.newBuilder(table)\n        .setStartKey(regionToSplit.getStartKey())\n        .setEndKey(bestSplitRow)\n        .setSplit(false)\n        .setRegionId(rid)\n        .build();\n    this.daughter_2_RI = RegionInfoBuilder.newBuilder(table)\n        .setStartKey(bestSplitRow)\n        .setEndKey(regionToSplit.getEndKey())\n        .setSplit(false)\n        .setRegionId(rid)\n        .build();\n    TableDescriptor htd = env.getMasterServices().getTableDescriptors().get(getTableName());\n    if(htd.getRegionSplitPolicyClassName() != null) {\n      // Since we don't have region reference here, creating the split policy instance without it.\n      // This can be used to invoke methods which don't require Region reference. This instantiation\n      // of a class on Master-side though it only makes sense on the RegionServer-side is\n      // for Phoenix Local Indexing. Refer HBASE-12583 for more information.\n      Class<? extends RegionSplitPolicy> clazz =\n          RegionSplitPolicy.getSplitPolicyClass(htd, env.getMasterConfiguration());\n      this.splitPolicy = ReflectionUtils.newInstance(clazz, env.getMasterConfiguration());\n    }\n  }\n  @Override\n  protected LockState acquireLock(final MasterProcedureEnv env) {\n    if (env.getProcedureScheduler().waitRegions(this, getTableName(), getParentRegion(),\n      daughter_1_RI, daughter_2_RI)) {\n      try {\n        LOG.debug(LockState.LOCK_EVENT_WAIT + \" \" + env.getProcedureScheduler().dumpLocks());\n      } catch (IOException e) {\n        // Ignore, just for logging\n      }\n      return LockState.LOCK_EVENT_WAIT;\n    }\n    return LockState.LOCK_ACQUIRED;\n  }\n  @Override\n  protected void releaseLock(final MasterProcedureEnv env) {\n    env.getProcedureScheduler().wakeRegions(this, getTableName(), getParentRegion(), daughter_1_RI,\n      daughter_2_RI);\n  }\n  /**\n   * Check whether the region is splittable\n   * @param env MasterProcedureEnv\n   * @param regionToSplit parent Region to be split\n   * @param splitRow if splitRow is not specified, will first try to get bestSplitRow from RS\n   * @throws IOException\n   */\n  private void checkSplittable(final MasterProcedureEnv env,\n      final RegionInfo regionToSplit, final byte[] splitRow) throws IOException {\n    // Ask the remote RS if this region is splittable.\n    // If we get an IOE, report it along w/ the failure so can see why we are not splittable at this time.\n    if(regionToSplit.getReplicaId() != RegionInfo.DEFAULT_REPLICA_ID) {\n      throw new IllegalArgumentException (\"Can't invoke split on non-default regions directly\");\n    }\n    RegionStateNode node =\n        env.getAssignmentManager().getRegionStates().getRegionStateNode(getParentRegion());\n    IOException splittableCheckIOE = null;\n    boolean splittable = false;\n    if (node != null) {\n      try {\n        if (bestSplitRow == null || bestSplitRow.length == 0) {\n          LOG\n            .info(\"splitKey isn't explicitly specified, will try to find a best split key from RS\");\n        }\n        // Always set bestSplitRow request as true here,\n        // need to call Region#checkSplit to check it splittable or not\n        GetRegionInfoResponse response = AssignmentManagerUtil.getRegionInfoResponse(env,\n          node.getRegionLocation(), node.getRegionInfo(), true);\n        if(bestSplitRow == null || bestSplitRow.length == 0) {\n          bestSplitRow = response.hasBestSplitRow() ? response.getBestSplitRow().toByteArray() : null;\n        }\n        splittable = response.hasSplittable() && response.getSplittable();\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Splittable=\" + splittable + \" \" + node.toShortString());\n        }\n      } catch (IOException e) {\n        splittableCheckIOE = e;\n      }\n    }\n    if (!splittable) {\n      IOException e =\n        new DoNotRetryIOException(regionToSplit.getShortNameToLog() + \" NOT splittable\");\n      if (splittableCheckIOE != null) {\n        e.initCause(splittableCheckIOE);\n      }\n      throw e;\n    }\n    if (bestSplitRow == null || bestSplitRow.length == 0) {\n      throw new DoNotRetryIOException(\"Region not splittable because bestSplitPoint = null, \" +\n        \"maybe table is too small for auto split. For force split, try specifying split row\");\n    }\n    if (Bytes.equals(regionToSplit.getStartKey(), bestSplitRow)) {\n      throw new DoNotRetryIOException(\n        \"Split row is equal to startkey: \" + Bytes.toStringBinary(splitRow));\n    }\n    if (!regionToSplit.containsRow(bestSplitRow)) {\n      throw new DoNotRetryIOException(\"Split row is not inside region key range splitKey:\" +\n        Bytes.toStringBinary(splitRow) + \" region: \" + regionToSplit);\n    }\n  }\n  /**\n   * Calculate daughter regionid to use.\n   * @param hri Parent {@link RegionInfo}\n   * @return Daughter region id (timestamp) to use.\n   */\n  private static long getDaughterRegionIdTimestamp(final RegionInfo hri) {\n    long rid = EnvironmentEdgeManager.currentTime();\n    // Regionid is timestamp.  Can't be less than that of parent else will insert\n    // at wrong location in hbase:meta (See HBASE-710).\n    if (rid < hri.getRegionId()) {\n      LOG.warn(\"Clock skew; parent regions id is \" + hri.getRegionId() +\n        \" but current time here is \" + rid);\n      rid = hri.getRegionId() + 1;\n    }\n    return rid;\n  }\n  private void removeNonDefaultReplicas(MasterProcedureEnv env) throws IOException {\n    AssignmentManagerUtil.removeNonDefaultReplicas(env, Stream.of(getParentRegion()),\n      getRegionReplication(env));\n  }\n  private void checkClosedRegions(MasterProcedureEnv env) throws IOException {\n    // theoretically this should not happen any more after we use TRSP, but anyway let's add a check\n    // here\n    AssignmentManagerUtil.checkClosedRegion(env, getParentRegion());\n  }\n  @Override\n  protected Flow executeFromState(MasterProcedureEnv env, SplitTableRegionState state)\n      throws InterruptedException {\n    LOG.trace(\"{} execute state={}\", this, state);\n    try {\n      switch (state) {\n        case SPLIT_TABLE_REGION_PREPARE:\n          if (prepareSplitRegion(env)) {\n            setNextState(SplitTableRegionState.SPLIT_TABLE_REGION_PRE_OPERATION);\n            break;\n          } else {\n            return Flow.NO_MORE_STATE;\n          }\n        case SPLIT_TABLE_REGION_PRE_OPERATION:\n          preSplitRegion(env);\n          setNextState(SplitTableRegionState.SPLIT_TABLE_REGION_CLOSE_PARENT_REGION);\n          break;\n        case SPLIT_TABLE_REGION_CLOSE_PARENT_REGION:\n          addChildProcedure(createUnassignProcedures(env));\n          setNextState(SplitTableRegionState.SPLIT_TABLE_REGIONS_CHECK_CLOSED_REGIONS);\n          break;\n        case SPLIT_TABLE_REGIONS_CHECK_CLOSED_REGIONS:\n          checkClosedRegions(env);\n          setNextState(SplitTableRegionState.SPLIT_TABLE_REGION_CREATE_DAUGHTER_REGIONS);\n          break;<fim_middle>// class below is blob\n"}