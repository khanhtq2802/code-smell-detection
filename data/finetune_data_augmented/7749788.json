{"text": "<fim_prefix>import org.apache.brooklyn.util.text.Strings;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport com.google.common.base.Joiner;\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Throwables;\nimport com.google.common.io.ByteSource;\nimport com.google.common.io.ByteStreams;\nimport com.google.common.io.Files;\n/** Implementation of {@link ShellTool} which runs locally. */\npublic class ProcessTool extends ShellAbstractTool implements ShellTool {\n    private static final Logger LOG = LoggerFactory.getLogger(ProcessTool.class);\n    // applies to calls\n    public static final ConfigKey<Boolean> PROP_LOGIN_SHELL = newConfigKey(\"loginShell\", \"Causes the commands to be invoked with bash arguments to forcea  login shell\", Boolean.FALSE);\n    public static final ConfigKey<String> PROP_DIRECTORY = newStringConfigKey(\"directory\", \"the working directory, for executing commands\", null);\n    public ProcessTool() {\n        this(null);\n    }\n    public ProcessTool(Map<String,?> flags) {\n        super(getOptionalVal(flags, PROP_LOCAL_TEMP_DIR));\n        if (flags!=null) {\n            MutableMap<String, Object> flags2 = MutableMap.copyOf(flags);\n            // TODO should remember other flags here?  (e.g. NO_EXTRA_OUTPUT, RUN_AS_ROOT, etc)\n            flags2.remove(PROP_LOCAL_TEMP_DIR.getName());\n            if (!flags2.isEmpty())\n                LOG.warn(\"\"+this+\" ignoring unsupported constructor flags: \"+flags);\n        }\n    }\n    @Override\n    public int execScript(final Map<String,?> props, final List<String> commands, final Map<String,?> env) {\n        return new ToolAbstractExecScript(props) {\n            public int run() {\n                try {\n                    String directory = getOptionalVal(props, PROP_DIRECTORY);\n                    File directoryDir = (directory != null) ? new File(Os.tidyPath(directory)) : null;\n                    String scriptContents = toScript(props, commands, env);\n                    if (LOG.isTraceEnabled()) LOG.trace(\"Running shell process (process) as script:\\n{}\", scriptContents);\n                    File to = new File(scriptPath);\n                    Files.createParentDirs(to);\n                    ByteSource.wrap(scriptContents.getBytes()).copyTo(Files.asByteSink(to));\n                    List<String> cmds = buildRunScriptCommand();\n                    cmds.add(0, \"chmod +x \"+scriptPath);\n                    return asInt(execProcesses(cmds, null, directoryDir, out, err, separator, getOptionalVal(props, PROP_LOGIN_SHELL), this), -1);\n                } catch (IOException e) {\n                    throw Throwables.propagate(e);\n                }\n            }\n        }.run();\n    }\n    @Override\n    public int execCommands(Map<String,?> props, List<String> commands, Map<String,?> env) {\n        if (Boolean.FALSE.equals(props.get(\"blocks\"))) {\n            throw new IllegalArgumentException(\"Cannot exec non-blocking: command=\"+commands);\n        }\n        OutputStream out = getOptionalVal(props, PROP_OUT_STREAM);\n        OutputStream err = getOptionalVal(props, PROP_ERR_STREAM);\n        String separator = getOptionalVal(props, PROP_SEPARATOR);\n        String directory = getOptionalVal(props, PROP_DIRECTORY);\n        File directoryDir = (directory != null) ? new File(Os.tidyPath(directory)) : null;\n        List<String> allcmds = toCommandSequence(commands, null);\n        String singlecmd = Joiner.on(separator).join(allcmds);\n        if (Boolean.TRUE.equals(getOptionalVal(props, PROP_RUN_AS_ROOT))) {\n            LOG.warn(\"Cannot run as root when executing as command; run as a script instead (will run as normal user): \"+singlecmd);\n        }\n        if (LOG.isTraceEnabled()) LOG.trace(\"Running shell command (process): {}\", singlecmd);\n        return asInt(execProcesses(allcmds, env, directoryDir, out, err, separator, getOptionalVal(props, PROP_LOGIN_SHELL), this), -1);\n    }\n    /**\n     * as {@link #execProcesses(List, Map, OutputStream, OutputStream, String, boolean, Object)} but not using a login shell\n     * @deprecated since 0.7; use {@link #execProcesses(List, Map, File, OutputStream, OutputStream, String, boolean, Object)}\n     */\n    @Deprecated\n    public static int execProcesses(List<String> cmds, Map<String,?> env, OutputStream out, OutputStream err, String separator, Object contextForLogging) {\n        return execProcesses(cmds, env, (File)null, out, err, separator, false, contextForLogging);\n    }\n    /**\n     * @deprecated since 0.7; use {@link #execProcesses(List, Map, File, OutputStream, OutputStream, String, boolean, Object)}\n     */\n    @Deprecated\n    public static int execProcesses(List<String> cmds, Map<String,?> env, OutputStream out, OutputStream err, String separator, boolean asLoginShell, Object contextForLogging) {\n        return execProcesses(cmds, env, (File)null, out, err, separator, asLoginShell, contextForLogging);\n    }\n    /** executes a set of commands by sending them as a single process to `bash -c` \n     * (single command argument of all the commands, joined with separator)\n     * <p>\n     * consequence of this is that you should not normally need to escape things oddly in your commands, \n     * type them just as you would into a bash shell (if you find exceptions please note them here!)\n     */\n    public static int execProcesses(List<String> cmds, Map<String,?> env, File directory, OutputStream out, OutputStream err, String separator, boolean asLoginShell, Object contextForLogging) {\n        MutableList<String> commands = new MutableList<String>().append(\"bash\");\n        if (asLoginShell) commands.append(\"-l\");\n        commands.append(\"-c\", Strings.join(cmds, Preconditions.checkNotNull(separator, \"separator\")));\n        return execSingleProcess(commands, env, directory, out, err, contextForLogging);\n    }\n    /**\n     * @deprecated since 0.7; use {@link #execSingleProcess(List, Map, File, OutputStream, OutputStream, Object)}\n     */\n    @Deprecated\n    public static int execSingleProcess(List<String> cmdWords, Map<String,?> env, OutputStream out, OutputStream err, Object contextForLogging) {\n        return execSingleProcess(cmdWords, env, (File)null, out, err, contextForLogging);\n    }\n    /** executes a single process made up of the given command words (*not* bash escaped);\n     * should be portable across OS's */\n<fim_suffix>    public static int execSingleProcess(List<String> cmdWords, Map<String,?> env, File directory, OutputStream out, OutputStream err, Object contextForLogging) {\n        StreamGobbler errgobbler = null;\n        StreamGobbler outgobbler = null;\n        ProcessBuilder pb = new ProcessBuilder(cmdWords);\n        if (env!=null) {\n            for (Map.Entry<String,?> kv: env.entrySet()) pb.environment().put(kv.getKey(), String.valueOf(kv.getValue())); \n        }\n        if (directory != null) {\n            pb.directory(directory);\n        }\n        try {\n            Process p = pb.start();\n            if (out != null) {\n                InputStream outstream = p.getInputStream();\n                outgobbler = new StreamGobbler(outstream, out, (Logger) null);\n                outgobbler.start();\n            }\n            if (err != null) {\n                InputStream errstream = p.getErrorStream();\n                errgobbler = new StreamGobbler(errstream, err, (Logger) null);\n                errgobbler.start();\n            }\n            int result = p.waitFor();\n            if (outgobbler != null) outgobbler.blockUntilFinished();\n            if (errgobbler != null) errgobbler.blockUntilFinished();\n            if (result==255)\n                // this is not definitive, but tests (and code?) expects throw exception if can't connect;\n                // only return exit code when it is exit code from underlying process;\n                // we have no way to distinguish 255 from ssh failure from 255 from the command run through ssh ...\n                // but probably 255 is from CLI ssh\n                throw new SshException(\"exit code 255 from CLI ssh; probably failed to connect\");\n            return result;\n        } catch (InterruptedException e) {\n            throw Exceptions.propagate(e);\n        } catch (IOException e) {\n            throw Exceptions.propagate(e);\n        } finally {\n            closeWhispering(outgobbler, contextForLogging, \"execProcess\");\n            closeWhispering(errgobbler, contextForLogging, \"execProcess\");\n        }\n    }<fim_middle>// function below has no smell\n"}