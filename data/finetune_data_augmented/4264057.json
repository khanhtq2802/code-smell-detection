{"text": "<fim_prefix> *     <li>n<sub>d</sub> = Number of discordant pairs</li>\n *     <li>n<sub>1</sub> = sum of t<sub>i</sub> * (t<sub>i</sub> - 1) / 2 for all i</li>\n *     <li>n<sub>2</sub> = sum of u<sub>j</sub> * (u<sub>j</sub> - 1) / 2 for all j</li>\n *     <li>t<sub>i</sub> = Number of tied values in the i<sup>th</sup> group of ties in x</li>\n *     <li>u<sub>j</sub> = Number of tied values in the j<sup>th</sup> group of ties in y</li>\n * </ul>\n * <p>\n * This implementation uses the O(n log n) algorithm described in\n * William R. Knight's 1966 paper \"A Computer Method for Calculating\n * Kendall's Tau with Ungrouped Data\" in the Journal of the American\n * Statistical Association.\n *\n * @see <a href=\"http://en.wikipedia.org/wiki/Kendall_tau_rank_correlation_coefficient\">\n * Kendall tau rank correlation coefficient (Wikipedia)</a>\n * @see <a href=\"http://www.jstor.org/stable/2282833\">A Computer\n * Method for Calculating Kendall's Tau with Ungrouped Data</a>\n *\n * @since 3.3\n */\npublic class KendallsCorrelation {\n    /** correlation matrix */\n    private final RealMatrix correlationMatrix;\n    /**\n     * Create a KendallsCorrelation instance without data.\n     */\n    public KendallsCorrelation() {\n        correlationMatrix = null;\n    }\n    /**\n     * Create a KendallsCorrelation from a rectangular array\n     * whose columns represent values of variables to be correlated.\n     *\n     * @param data rectangular array with columns representing variables\n     * @throws IllegalArgumentException if the input data array is not\n     * rectangular with at least two rows and two columns.\n     */\n    public KendallsCorrelation(double[][] data) {\n        this(MatrixUtils.createRealMatrix(data));\n    }\n    /**\n     * Create a KendallsCorrelation from a RealMatrix whose columns\n     * represent variables to be correlated.\n     *\n     * @param matrix matrix with columns representing variables to correlate\n     */\n    public KendallsCorrelation(RealMatrix matrix) {\n        correlationMatrix = computeCorrelationMatrix(matrix);\n    }\n    /**\n     * Returns the correlation matrix.\n     *\n     * @return correlation matrix\n     */\n    public RealMatrix getCorrelationMatrix() {\n        return correlationMatrix;\n    }\n    /**\n     * Computes the Kendall's Tau rank correlation matrix for the columns of\n     * the input matrix.\n     *\n     * @param matrix matrix with columns representing variables to correlate\n     * @return correlation matrix\n     */\n    public RealMatrix computeCorrelationMatrix(final RealMatrix matrix) {\n        int nVars = matrix.getColumnDimension();\n        RealMatrix outMatrix = new BlockRealMatrix(nVars, nVars);\n        for (int i = 0; i < nVars; i++) {\n            for (int j = 0; j < i; j++) {\n                double corr = correlation(matrix.getColumn(i), matrix.getColumn(j));\n                outMatrix.setEntry(i, j, corr);\n                outMatrix.setEntry(j, i, corr);\n            }\n            outMatrix.setEntry(i, i, 1d);\n        }\n        return outMatrix;\n    }\n    /**\n     * Computes the Kendall's Tau rank correlation matrix for the columns of\n     * the input rectangular array.  The columns of the array represent values\n     * of variables to be correlated.\n     *\n     * @param matrix matrix with columns representing variables to correlate\n     * @return correlation matrix\n     */\n    public RealMatrix computeCorrelationMatrix(final double[][] matrix) {\n       return computeCorrelationMatrix(new BlockRealMatrix(matrix));\n    }\n    /**\n     * Computes the Kendall's Tau rank correlation coefficient between the two arrays.\n     *\n     * @param xArray first data array\n     * @param yArray second data array\n     * @return Returns Kendall's Tau rank correlation coefficient for the two arrays\n     * @throws DimensionMismatchException if the arrays lengths do not match\n     */\n<fim_suffix>    public double correlation(final double[] xArray, final double[] yArray)\n            throws DimensionMismatchException {\n        if (xArray.length != yArray.length) {\n            throw new DimensionMismatchException(xArray.length, yArray.length);\n        }\n        final int n = xArray.length;\n        final long numPairs = sum(n - 1);\n        @SuppressWarnings(\"unchecked\")\n        Pair<Double, Double>[] pairs = new Pair[n];\n        for (int i = 0; i < n; i++) {\n            pairs[i] = new Pair<>(xArray[i], yArray[i]);\n        }\n        Arrays.sort(pairs, new Comparator<Pair<Double, Double>>() {\n            /** {@inheritDoc} */\n            @Override\n            public int compare(Pair<Double, Double> pair1, Pair<Double, Double> pair2) {\n                int compareFirst = pair1.getFirst().compareTo(pair2.getFirst());\n                return compareFirst != 0 ? compareFirst : pair1.getSecond().compareTo(pair2.getSecond());\n            }\n        });\n        long tiedXPairs = 0;\n        long tiedXYPairs = 0;\n        long consecutiveXTies = 1;\n        long consecutiveXYTies = 1;\n        Pair<Double, Double> prev = pairs[0];\n        for (int i = 1; i < n; i++) {\n            final Pair<Double, Double> curr = pairs[i];\n            if (curr.getFirst().equals(prev.getFirst())) {\n                consecutiveXTies++;\n                if (curr.getSecond().equals(prev.getSecond())) {\n                    consecutiveXYTies++;\n                } else {\n                    tiedXYPairs += sum(consecutiveXYTies - 1);\n                    consecutiveXYTies = 1;\n                }\n            } else {\n                tiedXPairs += sum(consecutiveXTies - 1);\n                consecutiveXTies = 1;\n                tiedXYPairs += sum(consecutiveXYTies - 1);\n                consecutiveXYTies = 1;\n            }\n            prev = curr;\n        }\n        tiedXPairs += sum(consecutiveXTies - 1);\n        tiedXYPairs += sum(consecutiveXYTies - 1);\n        long swaps = 0;\n        @SuppressWarnings(\"unchecked\")\n        Pair<Double, Double>[] pairsDestination = new Pair[n];\n        for (int segmentSize = 1; segmentSize < n; segmentSize <<= 1) {\n            for (int offset = 0; offset < n; offset += 2 * segmentSize) {\n                int i = offset;\n                final int iEnd = FastMath.min(i + segmentSize, n);\n                int j = iEnd;\n                final int jEnd = FastMath.min(j + segmentSize, n);\n                int copyLocation = offset;\n                while (i < iEnd || j < jEnd) {\n                    if (i < iEnd) {\n                        if (j < jEnd) {\n                            if (pairs[i].getSecond().compareTo(pairs[j].getSecond()) <= 0) {\n                                pairsDestination[copyLocation] = pairs[i];\n                                i++;\n                            } else {\n                                pairsDestination[copyLocation] = pairs[j];\n                                j++;\n                                swaps += iEnd - i;\n                            }\n                        } else {\n                            pairsDestination[copyLocation] = pairs[i];\n                            i++;\n                        }\n                    } else {\n                        pairsDestination[copyLocation] = pairs[j];\n                        j++;\n                    }\n                    copyLocation++;\n                }\n            }\n            final Pair<Double, Double>[] pairsTemp = pairs;\n            pairs = pairsDestination;\n            pairsDestination = pairsTemp;\n        }\n        long tiedYPairs = 0;\n        long consecutiveYTies = 1;\n        prev = pairs[0];\n        for (int i = 1; i < n; i++) {\n            final Pair<Double, Double> curr = pairs[i];\n            if (curr.getSecond().equals(prev.getSecond())) {\n                consecutiveYTies++;\n            } else {\n                tiedYPairs += sum(consecutiveYTies - 1);\n                consecutiveYTies = 1;\n            }\n            prev = curr;\n        }\n        tiedYPairs += sum(consecutiveYTies - 1);\n        final long concordantMinusDiscordant = numPairs - tiedXPairs - tiedYPairs + tiedXYPairs - 2 * swaps;\n        final double nonTiedPairsMultiplied = (numPairs - tiedXPairs) * (double) (numPairs - tiedYPairs);\n        return concordantMinusDiscordant / FastMath.sqrt(nonTiedPairsMultiplied);\n    }<fim_middle>// function below is long method\n"}