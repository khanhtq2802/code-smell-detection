{"text": "<fim_prefix>      return null;\n    }\n    Task result = maps[target].getTaskToRun(tts.getTrackerName());\n    if (result != null) {\n      addRunningTaskToTIP(maps[target], result.getTaskID(), tts, true);\n    }\n    return result;\n  } \n  /**\n   * Return a MapTask, if appropriate, to run on the given tasktracker\n   */\n  public synchronized Task obtainNewMapTask(TaskTrackerStatus tts, \n                                            int clusterSize, \n                                            int numUniqueHosts\n                                           ) throws IOException {\n    return obtainNewMapTask(tts, clusterSize, numUniqueHosts, anyCacheLevel);\n  }    \n  /*\n   * Return task cleanup attempt if any, to run on a given tracker\n   */\n  public Task obtainTaskCleanupTask(TaskTrackerStatus tts, \n                                                 boolean isMapSlot)\n  throws IOException {\n    if (!tasksInited.get()) {\n      return null;\n    }\n    synchronized (this) {\n      if (this.status.getRunState() != JobStatus.RUNNING || \n          jobFailed || jobKilled) {\n        return null;\n      }\n      String taskTracker = tts.getTrackerName();\n      if (!shouldRunOnTaskTracker(taskTracker)) {\n        return null;\n      }\n      TaskAttemptID taskid = null;\n      TaskInProgress tip = null;\n      if (isMapSlot) {\n        if (!mapCleanupTasks.isEmpty()) {\n          taskid = mapCleanupTasks.remove(0);\n          tip = maps[taskid.getTaskID().getId()];\n        }\n      } else {\n        if (!reduceCleanupTasks.isEmpty()) {\n          taskid = reduceCleanupTasks.remove(0);\n          tip = reduces[taskid.getTaskID().getId()];\n        }\n      }\n      if (tip != null) {\n        return tip.addRunningTask(taskid, taskTracker, true);\n      }\n      return null;\n    }\n  }\n  public synchronized Task obtainNewLocalMapTask(TaskTrackerStatus tts,\n                                                     int clusterSize, \n                                                     int numUniqueHosts)\n  throws IOException {\n    if (!tasksInited.get()) {\n      LOG.info(\"Cannot create task split for \" + profile.getJobID());\n      return null;\n    }\n    return obtainNewMapTask(tts, clusterSize, numUniqueHosts, maxLevel);\n  }\n  public synchronized Task obtainNewNonLocalMapTask(TaskTrackerStatus tts,\n                                                    int clusterSize, \n                                                    int numUniqueHosts)\n  throws IOException {\n    if (!tasksInited.get()) {\n      LOG.info(\"Cannot create task split for \" + profile.getJobID());\n      return null;\n    }\n    return obtainNewMapTask(tts, clusterSize, numUniqueHosts,\n        NON_LOCAL_CACHE_LEVEL);\n  }\n  /**\n   * Return a CleanupTask, if appropriate, to run on the given tasktracker\n   * \n   */\n  public Task obtainJobCleanupTask(TaskTrackerStatus tts, \n                                             int clusterSize, \n                                             int numUniqueHosts,\n                                             boolean isMapSlot\n                                            ) throws IOException {\n    if(!tasksInited.get() || !jobSetupCleanupNeeded) {\n      return null;\n    }\n    synchronized(this) {\n      if (!canLaunchJobCleanupTask()) {\n        return null;\n      }\n      String taskTracker = tts.getTrackerName();\n      // Update the last-known clusterSize\n      this.clusterSize = clusterSize;\n      if (!shouldRunOnTaskTracker(taskTracker)) {\n        return null;\n      }\n      List<TaskInProgress> cleanupTaskList = new ArrayList<TaskInProgress>();\n      if (isMapSlot) {\n        cleanupTaskList.add(cleanup[0]);\n      } else {\n        cleanupTaskList.add(cleanup[1]);\n      }\n      TaskInProgress tip = findTaskFromList(cleanupTaskList,\n                             tts, numUniqueHosts, false);\n      if (tip == null) {\n        return null;\n      }\n      // Now launch the cleanupTask\n      Task result = tip.getTaskToRun(tts.getTrackerName());\n      if (result != null) {\n        addRunningTaskToTIP(tip, result.getTaskID(), tts, true);\n        if (jobFailed) {\n          result.setJobCleanupTaskState(org.apache.hadoop.mapreduce.JobStatus\n                .State.FAILED);\n        } else if (jobKilled) {\n          result.setJobCleanupTaskState(org.apache.hadoop.mapreduce.JobStatus\n                .State.KILLED);\n        } else {\n          result.setJobCleanupTaskState(org.apache.hadoop.mapreduce\n                .JobStatus.State.SUCCEEDED);\n        }\n      }\n      return result;\n    }\n  }\n  /**\n   * Check whether cleanup task can be launched for the job.\n   * \n   * Cleanup task can be launched if it is not already launched\n   * or job is Killed\n   * or all maps and reduces are complete\n   * @return true/false\n   */\n  private synchronized boolean canLaunchJobCleanupTask() {\n    // check if the job is running\n    if (status.getRunState() != JobStatus.RUNNING &&\n        status.getRunState() != JobStatus.PREP) {\n      return false;\n    }\n    // check if cleanup task has been launched already or if setup isn't\n    // launched already. The later check is useful when number of maps is\n    // zero.\n    if (launchedCleanup || !isSetupFinished()) {\n      return false;\n    }\n    // check if job has failed or killed\n    if (jobKilled || jobFailed) {\n      return true;\n    }\n    // Check if all maps and reducers have finished.\n    boolean launchCleanupTask = \n        ((finishedMapTasks + failedMapTIPs) == (numMapTasks));\n    if (launchCleanupTask) {\n      launchCleanupTask = \n        ((finishedReduceTasks + failedReduceTIPs) == numReduceTasks);\n    }\n    return launchCleanupTask;\n  }\n  /**\n   * Return a SetupTask, if appropriate, to run on the given tasktracker\n   * \n   */\n  public Task obtainJobSetupTask(TaskTrackerStatus tts, \n                                             int clusterSize, \n                                             int numUniqueHosts,\n                                             boolean isMapSlot\n                                            ) throws IOException {\n    if(!tasksInited.get() || !jobSetupCleanupNeeded) {\n      return null;\n    }\n    synchronized(this) {\n      if (!canLaunchSetupTask()) {\n        return null;\n      }\n      String taskTracker = tts.getTrackerName();\n      // Update the last-known clusterSize\n      this.clusterSize = clusterSize;\n      if (!shouldRunOnTaskTracker(taskTracker)) {\n        return null;\n      }\n      List<TaskInProgress> setupTaskList = new ArrayList<TaskInProgress>();\n      if (isMapSlot) {\n        setupTaskList.add(setup[0]);\n      } else {\n        setupTaskList.add(setup[1]);\n      }\n      TaskInProgress tip = findTaskFromList(setupTaskList,\n                             tts, numUniqueHosts, false);\n      if (tip == null) {\n        return null;\n      }\n      // Now launch the setupTask\n      Task result = tip.getTaskToRun(tts.getTrackerName());\n      if (result != null) {\n        addRunningTaskToTIP(tip, result.getTaskID(), tts, true);\n      }\n      return result;\n    }\n  }\n  public synchronized boolean scheduleReduces() {\n    return finishedMapTasks >= completedMapsForReduceSlowstart;\n  }\n  /**\n   * Check whether setup task can be launched for the job.\n   * \n   * Setup task can be launched after the tasks are inited\n   * and Job is in PREP state\n   * and if it is not already launched\n   * or job is not Killed/Failed\n   * @return true/false\n   */\n  private synchronized boolean canLaunchSetupTask() {\n    return (tasksInited.get() && status.getRunState() == JobStatus.PREP && \n           !launchedSetup && !jobKilled && !jobFailed);\n  }\n  /**\n   * Return a ReduceTask, if appropriate, to run on the given tasktracker.\n   * We don't have cache-sensitivity for reduce tasks, as they\n   *  work on temporary MapRed files.  \n   */\n  public synchronized Task obtainNewReduceTask(TaskTrackerStatus tts,\n                                               int clusterSize,\n                                               int numUniqueHosts\n                                              ) throws IOException {\n    if (status.getRunState() != JobStatus.RUNNING) {\n      LOG.info(\"Cannot create task split for \" + profile.getJobID());\n      return null;\n    }\n    // Ensure we have sufficient map outputs ready to shuffle before \n    // scheduling reduces\n    if (!scheduleReduces()) {\n      return null;\n    }\n    int  target = findNewReduceTask(tts, clusterSize, numUniqueHosts);\n    if (target == -1) {\n      return null;\n    }\n    Task result = reduces[target].getTaskToRun(tts.getTrackerName());\n    if (result != null) {\n      addRunningTaskToTIP(reduces[target], result.getTaskID(), tts, true);\n    }\n    return result;\n  }\n  // returns the (cache)level at which the nodes matches\n<fim_suffix>  private int getMatchingLevelForNodes(Node n1, Node n2) {\n    int count = 0;\n    do {\n      if (n1.equals(n2)) {\n        return count;\n      }\n      ++count;\n      n1 = n1.getParent();\n      n2 = n2.getParent();\n    } while (n1 != null);\n    return this.maxLevel;\n  }<fim_middle>// function below has no smell\n"}