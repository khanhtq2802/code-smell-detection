{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.beam.runners.fnexecution.wire;\n\nimport java.util.Map.Entry;\nimport java.util.function.Predicate;\nimport org.apache.beam.model.pipeline.v1.RunnerApi;\nimport org.apache.beam.model.pipeline.v1.RunnerApi.Coder;\nimport org.apache.beam.model.pipeline.v1.RunnerApi.Components;\nimport org.apache.beam.runners.core.construction.ModelCoders;\nimport org.apache.beam.sdk.coders.ByteArrayCoder;\nimport org.apache.beam.sdk.coders.LengthPrefixCoder;\n\n/** Utilities for replacing or wrapping unknown coders with {@link LengthPrefixCoder}. */\npublic class LengthPrefixUnknownCoders {\n  /**\n   * Recursively traverses the coder tree and wraps the first unknown coder in every branch with a\n   * {@link LengthPrefixCoder} unless an ancestor coder is itself a {@link LengthPrefixCoder}. If\n   * {@code replaceWithByteArrayCoder} is set, then replaces that unknown coder with a {@link\n   * ByteArrayCoder}. Registers the new coders in the given {@link Components.Builder}. Note that no\n   * ids that are generated will collide with the ids supplied within the {@link\n   * Components#getCodersMap() coder map} key space.\n   *\n   * @param coderId The root coder contained within {@code coders} to start the recursive descent\n   *     from.\n   * @param components Components builder that initially contains the root coder and all component\n   *     coders, and will be modified to contain all the necessary additional coders (including the\n   *     resulting coder).\n   * @param replaceWithByteArrayCoder whether to replace an unknown coder with a {@link\n   *     ByteArrayCoder}.\n   * @return Id of the original coder (if unchanged) or the newly generated length-prefixed coder.\n   */\n<fim_suffix>  public static String addLengthPrefixedCoder(\n      String coderId, RunnerApi.Components.Builder components, boolean replaceWithByteArrayCoder) {\n    String lengthPrefixedByteArrayCoderId = addLengthPrefixByteArrayCoder(components);\n    String urn = components.getCodersOrThrow(coderId).getSpec().getSpec().getUrn();\n\n    // We handle three cases:\n    //  1) the requested coder is already a length prefix coder. In this case we just honor the\n    //     request to replace the coder with a byte array coder.\n    //  2) the requested coder is a known coder but not a length prefix coder. In this case we\n    //     rebuild the coder by recursively length prefixing any unknown component coders.\n    //  3) the requested coder is an unknown coder. In this case we either wrap the requested coder\n    //     with a length prefix coder or replace it with a length prefix byte array coder.\n    if (ModelCoders.LENGTH_PREFIX_CODER_URN.equals(urn)) {\n      return replaceWithByteArrayCoder ? lengthPrefixedByteArrayCoderId : coderId;\n    } else if (ModelCoders.urns().contains(urn)) {\n      return addForModelCoder(coderId, components, replaceWithByteArrayCoder);\n    } else {\n      return replaceWithByteArrayCoder\n          ? lengthPrefixedByteArrayCoderId\n          : addWrappedWithLengthPrefixCoder(coderId, components);\n    }\n  }\n\n  private static String addForModelCoder(\n      String coderId, RunnerApi.Components.Builder components, boolean replaceWithByteArrayCoder) {\n    Coder coder = components.getCodersOrThrow(coderId);\n    RunnerApi.Coder.Builder builder = coder.toBuilder().clearComponentCoderIds();\n    for (String componentCoderId : coder.getComponentCoderIdsList()) {\n      builder.addComponentCoderIds(\n          addLengthPrefixedCoder(componentCoderId, components, replaceWithByteArrayCoder));\n    }\n    return addCoder(builder.build(), components, coderId + \"-length_prefix\");\n  }\n\n  // If we are handling an unknown URN then we need to wrap it with a length prefix coder.\n  // If requested we also replace the unknown coder with a byte array coder.\n  private static String addWrappedWithLengthPrefixCoder(\n      String coderId, RunnerApi.Components.Builder components) {\n    Coder.Builder lengthPrefixed = Coder.newBuilder().addComponentCoderIds(coderId);\n    lengthPrefixed\n        .getSpecBuilder()\n        .getSpecBuilder()\n        .setUrn(ModelCoders.LENGTH_PREFIX_CODER_URN)\n        .build();\n    return addCoder(lengthPrefixed.build(), components, coderId + \"-length_prefix\");\n  }\n\n  /** Adds the (singleton) length-prefixed byte array coder. */\n  private static String addLengthPrefixByteArrayCoder(RunnerApi.Components.Builder components) {\n    // Add byte array coder\n    Coder.Builder byteArrayCoder = Coder.newBuilder();\n    byteArrayCoder.getSpecBuilder().getSpecBuilder().setUrn(ModelCoders.BYTES_CODER_URN);\n    String byteArrayCoderId = addCoder(byteArrayCoder.build(), components, \"byte_array\");\n\n    // Wrap it into length-prefixed coder\n    Coder.Builder lengthPrefixByteArrayCoder = Coder.newBuilder();\n    lengthPrefixByteArrayCoder\n        .addComponentCoderIds(byteArrayCoderId)\n        .getSpecBuilder()\n        .getSpecBuilder()\n        .setUrn(ModelCoders.LENGTH_PREFIX_CODER_URN);\n\n    return addCoder(lengthPrefixByteArrayCoder.build(), components, \"length_prefix_byte_array\");\n  }\n\n  private static String addCoder(\n      RunnerApi.Coder coder, RunnerApi.Components.Builder components, String uniqueIdPrefix) {\n    for (Entry<String, Coder> entry : components.getCodersMap().entrySet()) {\n      if (entry.getValue().equals(coder)) {\n        return entry.getKey();\n      }\n    }\n    String id = generateUniqueId(uniqueIdPrefix, components::containsCoders);\n    components.putCoders(id, coder);\n    return id;\n  }\n\n  /** Generates a unique id given a prefix and the set of existing ids. */\n  static String generateUniqueId(String prefix, Predicate<String> isExistingId) {\n    int i = 0;\n    while (isExistingId.test(prefix + i)) {\n      i += 1;\n    }\n    return prefix + i;\n  }\n}<fim_middle>// function below has no smell\n"}