{"text": "<fim_prefix>import org.graalvm.compiler.lir.LIRFrameState;\nimport org.graalvm.compiler.lir.Variable;\nimport org.graalvm.compiler.lir.amd64.AMD64BreakpointOp;\nimport org.graalvm.compiler.lir.gen.LIRGeneratorTool;\nimport org.graalvm.compiler.nodes.BreakpointNode;\nimport org.graalvm.compiler.nodes.CallTargetNode.InvokeKind;\nimport org.graalvm.compiler.nodes.DirectCallTargetNode;\nimport org.graalvm.compiler.nodes.FullInfopointNode;\nimport org.graalvm.compiler.nodes.IndirectCallTargetNode;\nimport org.graalvm.compiler.nodes.NodeView;\nimport org.graalvm.compiler.nodes.ParameterNode;\nimport org.graalvm.compiler.nodes.SafepointNode;\nimport org.graalvm.compiler.nodes.StructuredGraph;\nimport org.graalvm.compiler.nodes.ValueNode;\nimport org.graalvm.compiler.nodes.spi.NodeValueMap;\nimport org.graalvm.compiler.replacements.nodes.ArrayCompareToNode;\nimport org.graalvm.compiler.replacements.nodes.ArrayEqualsNode;\nimport jdk.vm.ci.amd64.AMD64;\nimport jdk.vm.ci.amd64.AMD64Kind;\nimport jdk.vm.ci.code.BytecodeFrame;\nimport jdk.vm.ci.code.CallingConvention;\nimport jdk.vm.ci.code.Register;\nimport jdk.vm.ci.code.RegisterValue;\nimport jdk.vm.ci.code.StackSlot;\nimport jdk.vm.ci.code.ValueUtil;\nimport jdk.vm.ci.hotspot.HotSpotCallingConventionType;\nimport jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;\nimport jdk.vm.ci.meta.AllocatableValue;\nimport jdk.vm.ci.meta.JavaKind;\nimport jdk.vm.ci.meta.JavaType;\nimport jdk.vm.ci.meta.ResolvedJavaMethod;\nimport jdk.vm.ci.meta.Value;\nimport org.graalvm.compiler.replacements.nodes.ArrayRegionEqualsNode;\n/**\n * LIR generator specialized for AMD64 HotSpot.\n */\npublic class AMD64HotSpotNodeLIRBuilder extends AMD64NodeLIRBuilder implements HotSpotNodeLIRBuilder {\n    public AMD64HotSpotNodeLIRBuilder(StructuredGraph graph, LIRGeneratorTool gen, AMD64NodeMatchRules nodeMatchRules) {\n        super(graph, gen, nodeMatchRules);\n        assert gen instanceof AMD64HotSpotLIRGenerator;\n        assert getDebugInfoBuilder() instanceof HotSpotDebugInfoBuilder;\n        ((AMD64HotSpotLIRGenerator) gen).setDebugInfoBuilder(((HotSpotDebugInfoBuilder) getDebugInfoBuilder()));\n    }\n    private AMD64HotSpotLIRGenerator getGen() {\n        return (AMD64HotSpotLIRGenerator) gen;\n    }\n    @Override\n    protected DebugInfoBuilder createDebugInfoBuilder(StructuredGraph graph, NodeValueMap nodeValueMap) {\n        HotSpotLockStack lockStack = new HotSpotLockStack(gen.getResult().getFrameMapBuilder(), LIRKind.value(AMD64Kind.QWORD));\n        return new HotSpotDebugInfoBuilder(nodeValueMap, lockStack, (HotSpotLIRGenerator) gen);\n    }\n    @Override\n    protected void emitPrologue(StructuredGraph graph) {\n        CallingConvention incomingArguments = gen.getResult().getCallingConvention();\n        Value[] params = new Value[incomingArguments.getArgumentCount() + 1];\n        for (int i = 0; i < params.length - 1; i++) {\n            params[i] = incomingArguments.getArgument(i);\n            if (isStackSlot(params[i])) {\n                StackSlot slot = ValueUtil.asStackSlot(params[i]);\n                if (slot.isInCallerFrame() && !gen.getResult().getLIR().hasArgInCallerFrame()) {\n                    gen.getResult().getLIR().setHasArgInCallerFrame();\n                }\n            }\n        }\n        params[params.length - 1] = rbp.asValue(LIRKind.value(AMD64Kind.QWORD));\n        gen.emitIncomingValues(params);\n        getGen().emitSaveRbp();\n        getGen().append(((HotSpotDebugInfoBuilder) getDebugInfoBuilder()).lockStack());\n        for (ParameterNode param : graph.getNodes(ParameterNode.TYPE)) {\n            Value paramValue = params[param.index()];\n            assert paramValue.getValueKind().equals(getLIRGeneratorTool().getLIRKind(param.stamp(NodeView.DEFAULT))) : paramValue.getValueKind() + \" != \" + param.stamp(NodeView.DEFAULT);\n            setResult(param, gen.emitMove(paramValue));\n        }\n    }\n    @Override\n    public void visitSafepointNode(SafepointNode i) {\n        LIRFrameState info = state(i);\n        Register thread = getGen().getProviders().getRegisters().getThreadRegister();\n        append(new AMD64HotSpotSafepointOp(info, getGen().config, this, thread));\n    }\n    @Override\n    protected void emitDirectCall(DirectCallTargetNode callTarget, Value result, Value[] parameters, Value[] temps, LIRFrameState callState) {\n        InvokeKind invokeKind = ((HotSpotDirectCallTargetNode) callTarget).invokeKind();\n        if (invokeKind.isIndirect()) {\n            append(new AMD64HotspotDirectVirtualCallOp(callTarget.targetMethod(), result, parameters, temps, callState, invokeKind, getGen().config));\n        } else {\n            assert invokeKind.isDirect();\n            HotSpotResolvedJavaMethod resolvedMethod = (HotSpotResolvedJavaMethod) callTarget.targetMethod();\n            assert resolvedMethod.isConcrete() : \"Cannot make direct call to abstract method.\";\n            append(new AMD64HotSpotDirectStaticCallOp(callTarget.targetMethod(), result, parameters, temps, callState, invokeKind, getGen().config));\n        }\n    }\n    @Override\n    protected void emitIndirectCall(IndirectCallTargetNode callTarget, Value result, Value[] parameters, Value[] temps, LIRFrameState callState) {\n        if (callTarget instanceof HotSpotIndirectCallTargetNode) {\n            Value metaspaceMethodSrc = operand(((HotSpotIndirectCallTargetNode) callTarget).metaspaceMethod());\n            Value targetAddressSrc = operand(callTarget.computedAddress());\n            AllocatableValue metaspaceMethodDst = AMD64.rbx.asValue(metaspaceMethodSrc.getValueKind());\n            AllocatableValue targetAddressDst = AMD64.rax.asValue(targetAddressSrc.getValueKind());\n            gen.emitMove(metaspaceMethodDst, metaspaceMethodSrc);\n            gen.emitMove(targetAddressDst, targetAddressSrc);\n            append(new AMD64IndirectCallOp(callTarget.targetMethod(), result, parameters, temps, metaspaceMethodDst, targetAddressDst, callState, getGen().config));\n        } else {\n            super.emitIndirectCall(callTarget, result, parameters, temps, callState);\n        }\n    }\n    @Override\n    public void emitPatchReturnAddress(ValueNode address) {\n        append(new AMD64HotSpotPatchReturnAddressOp(gen.load(operand(address))));\n    }\n    @Override\n    public void emitJumpToExceptionHandlerInCaller(ValueNode handlerInCallerPc, ValueNode exception, ValueNode exceptionPc) {\n        Variable handler = gen.load(operand(handlerInCallerPc));\n        ForeignCallLinkage linkage = gen.getForeignCalls().lookupForeignCall(EXCEPTION_HANDLER_IN_CALLER);\n        CallingConvention outgoingCc = linkage.getOutgoingCallingConvention();\n        assert outgoingCc.getArgumentCount() == 2;\n        RegisterValue exceptionFixed = (RegisterValue) outgoingCc.getArgument(0);\n        RegisterValue exceptionPcFixed = (RegisterValue) outgoingCc.getArgument(1);\n        gen.emitMove(exceptionFixed, operand(exception));\n        gen.emitMove(exceptionPcFixed, operand(exceptionPc));\n        Register thread = getGen().getProviders().getRegisters().getThreadRegister();\n        AMD64HotSpotJumpToExceptionHandlerInCallerOp op = new AMD64HotSpotJumpToExceptionHandlerInCallerOp(handler, exceptionFixed, exceptionPcFixed, getGen().config.threadIsMethodHandleReturnOffset,\n                        thread);\n        append(op);\n    }\n<fim_suffix>    @Override\n    public void visitFullInfopointNode(FullInfopointNode i) {\n        if (i.getState() != null && i.getState().bci == BytecodeFrame.AFTER_BCI) {\n            i.getDebug().log(\"Ignoring InfopointNode for AFTER_BCI\");\n        } else {\n            super.visitFullInfopointNode(i);\n        }\n    }<fim_middle>// function below has no smell\n"}