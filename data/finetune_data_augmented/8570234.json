{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.hadoop.hbase.io.hfile.bucket;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Queue;\nimport java.util.Set;\nimport java.util.concurrent.atomic.LongAdder;\nimport org.apache.hadoop.hbase.io.hfile.BlockCacheFactory;\nimport org.apache.hadoop.hbase.io.hfile.BlockCacheKey;\nimport org.apache.hadoop.hbase.io.hfile.bucket.BucketCache.BucketEntry;\nimport org.apache.yetus.audience.InterfaceAudience;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.apache.hbase.thirdparty.com.google.common.base.MoreObjects;\nimport org.apache.hbase.thirdparty.com.google.common.base.Preconditions;\nimport org.apache.hbase.thirdparty.com.google.common.collect.MinMaxPriorityQueue;\nimport org.apache.hbase.thirdparty.com.google.common.primitives.Ints;\nimport org.apache.hbase.thirdparty.org.apache.commons.collections4.map.LinkedMap;\n/**\n * This class is used to allocate a block with specified size and free the block when evicting. It\n * manages an array of buckets, each bucket is associated with a size and caches elements up to this\n * size. For a completely empty bucket, this size could be re-specified dynamically.\n * <p/>\n * This class is not thread safe.\n */\n@InterfaceAudience.Private\npublic final class BucketAllocator {\n  private static final Logger LOG = LoggerFactory.getLogger(BucketAllocator.class);\n<fim_suffix>  public final static class Bucket {\n    private long baseOffset;\n    private int itemAllocationSize, sizeIndex;\n    private int itemCount;\n    private int freeList[];\n    private int freeCount, usedCount;\n    public Bucket(long offset) {\n      baseOffset = offset;\n      sizeIndex = -1;\n    }\n    void reconfigure(int sizeIndex, int[] bucketSizes, long bucketCapacity) {\n      Preconditions.checkElementIndex(sizeIndex, bucketSizes.length);\n      this.sizeIndex = sizeIndex;\n      itemAllocationSize = bucketSizes[sizeIndex];\n      itemCount = (int) (bucketCapacity / (long) itemAllocationSize);\n      freeCount = itemCount;\n      usedCount = 0;\n      freeList = new int[itemCount];\n      for (int i = 0; i < freeCount; ++i)\n        freeList[i] = i;\n    }\n    public boolean isUninstantiated() {\n      return sizeIndex == -1;\n    }\n    public int sizeIndex() {\n      return sizeIndex;\n    }\n    public int getItemAllocationSize() {\n      return itemAllocationSize;\n    }\n    public boolean hasFreeSpace() {\n      return freeCount > 0;\n    }\n    public boolean isCompletelyFree() {\n      return usedCount == 0;\n    }\n    public int freeCount() {\n      return freeCount;\n    }\n    public int usedCount() {\n      return usedCount;\n    }\n    public int getFreeBytes() {\n      return freeCount * itemAllocationSize;\n    }\n    public int getUsedBytes() {\n      return usedCount * itemAllocationSize;\n    }\n    public long getBaseOffset() {\n      return baseOffset;\n    }\n    /**\n     * Allocate a block in this bucket, return the offset representing the\n     * position in physical space\n     * @return the offset in the IOEngine\n     */\n    public long allocate() {\n      assert freeCount > 0; // Else should not have been called\n      assert sizeIndex != -1;\n      ++usedCount;\n      long offset = baseOffset + (freeList[--freeCount] * itemAllocationSize);\n      assert offset >= 0;\n      return offset;\n    }\n    public void addAllocation(long offset) throws BucketAllocatorException {\n      offset -= baseOffset;\n      if (offset < 0 || offset % itemAllocationSize != 0)\n        throw new BucketAllocatorException(\n            \"Attempt to add allocation for bad offset: \" + offset + \" base=\"\n                + baseOffset + \", bucket size=\" + itemAllocationSize);\n      int idx = (int) (offset / itemAllocationSize);\n      boolean matchFound = false;\n      for (int i = 0; i < freeCount; ++i) {\n        if (matchFound) freeList[i - 1] = freeList[i];\n        else if (freeList[i] == idx) matchFound = true;\n      }\n      if (!matchFound)\n        throw new BucketAllocatorException(\"Couldn't find match for index \"\n            + idx + \" in free list\");\n      ++usedCount;\n      --freeCount;\n    }\n    private void free(long offset) {\n      offset -= baseOffset;\n      assert offset >= 0;\n      assert offset < itemCount * itemAllocationSize;\n      assert offset % itemAllocationSize == 0;\n      assert usedCount > 0;\n      assert freeCount < itemCount; // Else duplicate free\n      int item = (int) (offset / (long) itemAllocationSize);\n      assert !freeListContains(item);\n      --usedCount;\n      freeList[freeCount++] = item;\n    }\n    private boolean freeListContains(int blockNo) {\n      for (int i = 0; i < freeCount; ++i) {\n        if (freeList[i] == blockNo) return true;\n      }\n      return false;\n    }\n  }\n  final class BucketSizeInfo {\n    // Free bucket means it has space to allocate a block;\n    // Completely free bucket means it has no block.\n    private LinkedMap bucketList, freeBuckets, completelyFreeBuckets;\n    private int sizeIndex;\n    BucketSizeInfo(int sizeIndex) {\n      bucketList = new LinkedMap();\n      freeBuckets = new LinkedMap();\n      completelyFreeBuckets = new LinkedMap();\n      this.sizeIndex = sizeIndex;\n    }\n    public synchronized void instantiateBucket(Bucket b) {\n      assert b.isUninstantiated() || b.isCompletelyFree();\n      b.reconfigure(sizeIndex, bucketSizes, bucketCapacity);\n      bucketList.put(b, b);\n      freeBuckets.put(b, b);\n      completelyFreeBuckets.put(b, b);\n    }\n    public int sizeIndex() {\n      return sizeIndex;\n    }\n    /**\n     * Find a bucket to allocate a block\n     * @return the offset in the IOEngine\n     */\n    public long allocateBlock() {\n      Bucket b = null;\n      if (freeBuckets.size() > 0) {\n        // Use up an existing one first...\n        b = (Bucket) freeBuckets.lastKey();\n      }\n      if (b == null) {\n        b = grabGlobalCompletelyFreeBucket();\n        if (b != null) instantiateBucket(b);\n      }\n      if (b == null) return -1;\n      long result = b.allocate();\n      blockAllocated(b);\n      return result;\n    }\n    void blockAllocated(Bucket b) {\n      if (!b.isCompletelyFree()) completelyFreeBuckets.remove(b);\n      if (!b.hasFreeSpace()) freeBuckets.remove(b);\n    }\n    public Bucket findAndRemoveCompletelyFreeBucket() {\n      Bucket b = null;\n      assert bucketList.size() > 0;\n      if (bucketList.size() == 1) {\n        // So we never get complete starvation of a bucket for a size\n        return null;\n      }\n      if (completelyFreeBuckets.size() > 0) {\n        b = (Bucket) completelyFreeBuckets.firstKey();\n        removeBucket(b);\n      }\n      return b;\n    }\n    private synchronized void removeBucket(Bucket b) {\n      assert b.isCompletelyFree();\n      bucketList.remove(b);\n      freeBuckets.remove(b);\n      completelyFreeBuckets.remove(b);\n    }\n    public void freeBlock(Bucket b, long offset) {\n      assert bucketList.containsKey(b);\n      // else we shouldn't have anything to free...\n      assert (!completelyFreeBuckets.containsKey(b));\n      b.free(offset);\n      if (!freeBuckets.containsKey(b)) freeBuckets.put(b, b);\n      if (b.isCompletelyFree()) completelyFreeBuckets.put(b, b);\n    }<fim_middle>// class below has no smell\n"}