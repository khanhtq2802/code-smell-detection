{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n * agreements. See the NOTICE file distributed with this work for additional information regarding\n * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n * copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n/*\n * Written by Doug Lea with assistance from members of JCP JSR-166 Expert Group and released to the\n * public domain, as explained at http://creativecommons.org/licenses/publicdomain\n */\n/**\n * Misc utilities in JSR166 performance tests\n */\n\npackage org.apache.geode.internal.util.concurrent.cm;\n\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicLong;\n\nclass LoopHelpers {\n\n  static final SimpleRandom staticRNG = new SimpleRandom();\n\n  // Some mindless computation to do between synchronizations...\n\n  /**\n   * generates 32 bit pseudo-random numbers. Adapted from http://www.snippets.org\n   */\n  public static int compute1(int x) {\n    int lo = 16807 * (x & 0xFFFF);\n    int hi = 16807 * (x >>> 16);\n    lo += (hi & 0x7FFF) << 16;\n    if ((lo & 0x80000000) != 0) {\n      lo &= 0x7fffffff;\n      ++lo;\n    }\n    lo += hi >>> 15;\n    if (lo == 0 || (lo & 0x80000000) != 0) {\n      lo &= 0x7fffffff;\n      ++lo;\n    }\n    return lo;\n  }\n\n  /**\n   * Computes a linear congruential random number a random number of times.\n   */\n  public static int compute2(int x) {\n    int loops = (x >>> 4) & 7;\n    while (loops-- > 0) {\n      x = (x * 2147483647) % 16807;\n    }\n    return x;\n  }\n\n  /**\n   * Yet another random number generator\n   */\n  public static int compute3(int x) {\n    int t = (x % 127773) * 16807 - (x / 127773) * 2836;\n    return (t > 0) ? t : t + 0x7fffffff;\n  }\n\n  /**\n   * Yet another random number generator\n   */\n  public static int compute4(int x) {\n    return x * 134775813 + 1;\n  }\n\n\n  /**\n   * Yet another random number generator\n   */\n  public static int compute5(int x) {\n    return 36969 * (x & 65535) + (x >> 16);\n  }\n\n  /**\n   * Marsaglia xorshift (1, 3, 10)\n   */\n  public static int compute6(int seed) {\n    seed ^= seed << 1;\n    seed ^= seed >>> 3;\n    seed ^= (seed << 10);\n    return seed;\n  }\n\n  /**\n   * Marsaglia xorshift (6, 21, 7)\n   */\n  public static int compute7(int y) {\n    y ^= y << 6;\n    y ^= y >>> 21;\n    y ^= (y << 7);\n    return y;\n  }\n\n\n  /**\n   * Marsaglia xorshift for longs\n   */\n<fim_suffix>  public static long compute8(long x) {\n    x ^= x << 13;\n    x ^= x >>> 7;\n    x ^= (x << 17);\n    return x;\n  }\n\n  public static class XorShift32Random {\n    static final AtomicInteger seq = new AtomicInteger(8862213);\n    int x = -1831433054;\n\n    public XorShift32Random(int seed) {\n      x = seed;\n    }\n\n    public XorShift32Random() {\n      this((int) System.nanoTime() + seq.getAndAdd(129));\n    }\n\n    public int next() {\n      x ^= x << 6;\n      x ^= x >>> 21;\n      x ^= (x << 7);\n      return x;\n    }\n  }\n\n\n  /** Multiplication-free RNG from Marsaglia \"Xorshift RNGs\" paper */\n  public static class MarsagliaRandom {\n    static final AtomicInteger seq = new AtomicInteger(3122688);\n    int x;\n    int y = 842502087;\n    int z = -715159705;\n    int w = 273326509;\n\n    public MarsagliaRandom(int seed) {\n      x = seed;\n    }\n\n    public MarsagliaRandom() {\n      this((int) System.nanoTime() + seq.getAndAdd(129));\n    }\n\n    public int next() {\n      int t = x ^ (x << 11);\n      x = y;\n      y = z;\n      z = w;\n      return w = (w ^ (w >>> 19) ^ (t ^ (t >>> 8)));\n    }\n  }\n\n  /**\n   * Unsynchronized version of java.util.Random algorithm.\n   */\n  public static class SimpleRandom {\n    private static final long multiplier = 0x5DEECE66DL;\n    private static final long addend = 0xBL;\n    private static final long mask = (1L << 48) - 1;\n    static final AtomicLong seq = new AtomicLong(-715159705);\n    private long seed;\n\n    SimpleRandom(long s) {\n      seed = s;\n    }\n\n    SimpleRandom() {\n      seed = System.nanoTime() + seq.getAndAdd(129);\n    }\n\n    public void setSeed(long s) {\n      seed = s;\n    }\n\n    public int next() {\n      long nextseed = (seed * multiplier + addend) & mask;\n      seed = nextseed;\n      return ((int) (nextseed >>> 17)) & 0x7FFFFFFF;\n    }\n  }\n\n  public static class BarrierTimer implements Runnable {\n    volatile boolean started;\n    volatile long startTime;\n    volatile long endTime;\n\n    @Override\n    public void run() {\n      long t = System.nanoTime();\n      if (!started) {\n        started = true;\n        startTime = t;\n      } else\n        endTime = t;\n    }\n\n    public void clear() {\n      started = false;\n    }\n\n    public long getTime() {\n      return endTime - startTime;\n    }\n  }\n\n  public static String rightJustify(long n) {\n    // There's probably a better way to do this...\n    String field = \"         \";\n    String num = Long.toString(n);\n    if (num.length() >= field.length())\n      return num;\n    StringBuffer b = new StringBuffer(field);\n    b.replace(b.length() - num.length(), b.length(), num);\n    return b.toString();\n  }\n\n}<fim_middle>// function below has no smell\n"}