{"text": "<fim_prefix>/*\n * Copyright 2014-present Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.facebook.litho;\n\nimport android.graphics.Rect;\nimport androidx.annotation.Nullable;\n\n/**\n * Holds information about a VisibilityOutput (that is, about a component for which a visibility\n * event handler has been set). This class is justified by the fact that VisibilityOutput should be\n * immutable.\n */\nclass VisibilityItem {\n\n  private static final int FLAG_LEFT_EDGE_VISIBLE = 1 << 1;\n  private static final int FLAG_TOP_EDGE_VISIBLE = 1 << 2;\n  private static final int FLAG_RIGHT_EDGE_VISIBLE = 1 << 3;\n  private static final int FLAG_BOTTOM_EDGE_VISIBLE = 1 << 4;\n  private static final int FLAG_FOCUSED_RANGE = 1 << 5;\n\n  private final String mGlobalKey;\n  private int mFlags;\n  // The invisible event and unfocused event handlers are required to make it possible to dispatch\n  // the corresponding event when unbind is called or when the MountState is reset.\n  @Nullable private EventHandler<InvisibleEvent> mInvisibleHandler;\n  @Nullable private EventHandler<UnfocusedVisibleEvent> mUnfocusedHandler;\n  private @Nullable final EventHandler<VisibilityChangedEvent> mVisibilityChangedHandler;\n  private boolean mDoNotClearInThisPass;\n\n  public VisibilityItem(\n      String globalKey,\n      EventHandler<InvisibleEvent> invisibleHandler,\n      EventHandler<UnfocusedVisibleEvent> unfocusedHandler,\n      @Nullable EventHandler<VisibilityChangedEvent> visibilityChangedHandler) {\n    mGlobalKey = globalKey;\n    mInvisibleHandler = invisibleHandler;\n    mUnfocusedHandler = unfocusedHandler;\n    mVisibilityChangedHandler = visibilityChangedHandler;\n  }\n\n  String getGlobalKey() {\n    return mGlobalKey;\n  }\n\n  /**\n   * Sets the invisible event handler.\n   */\n  void setInvisibleHandler(EventHandler<InvisibleEvent> invisibleHandler) {\n    mInvisibleHandler = invisibleHandler;\n  }\n\n  /** Returns the invisible event handler. */\n  @Nullable\n  EventHandler<InvisibleEvent> getInvisibleHandler() {\n    return mInvisibleHandler;\n  }\n\n  /**\n   * Sets the unfocused event handler.\n   */\n  void setUnfocusedHandler(EventHandler<UnfocusedVisibleEvent> unfocusedHandler) {\n    mUnfocusedHandler = unfocusedHandler;\n  }\n\n  /** Returns the unfocused event handler. */\n  @Nullable\n  EventHandler<UnfocusedVisibleEvent> getUnfocusedHandler() {\n    return mUnfocusedHandler;\n  }\n\n  @Nullable\n  EventHandler<VisibilityChangedEvent> getVisibilityChangedHandler() {\n    return mVisibilityChangedHandler;\n  }\n\n  boolean isInFocusedRange() {\n    return (mFlags & FLAG_FOCUSED_RANGE) != 0;\n  }\n\n  void setFocusedRange(boolean isFocused) {\n    if (isFocused) {\n      mFlags |= FLAG_FOCUSED_RANGE;\n    } else {\n      mFlags &= ~FLAG_FOCUSED_RANGE;\n    }\n  }\n\n  /**\n   * Returns true if the component associated with this VisibilityItem is in the full impression\n   * range.\n   */\n<fim_suffix>  boolean isInFullImpressionRange() {\n    final int allEdgesVisible = FLAG_LEFT_EDGE_VISIBLE\n        | FLAG_TOP_EDGE_VISIBLE\n        | FLAG_RIGHT_EDGE_VISIBLE\n        | FLAG_BOTTOM_EDGE_VISIBLE;\n\n    return (mFlags & allEdgesVisible) == allEdgesVisible;\n  }\n\n  /**\n   * Sets the flags corresponding to the edges of the component that are visible. Afterwards, it\n   * checks if the component has entered the full impression visible range and, if so, it sets the\n   * appropriate flag.\n   */\n  void setVisibleEdges(Rect componentBounds, Rect componentVisibleBounds) {\n    if (componentBounds.top == componentVisibleBounds.top) {\n      mFlags |= FLAG_TOP_EDGE_VISIBLE;\n    }\n    if (componentBounds.bottom == componentVisibleBounds.bottom) {\n      mFlags |= FLAG_BOTTOM_EDGE_VISIBLE;\n    }\n    if (componentBounds.left == componentVisibleBounds.left) {\n      mFlags |= FLAG_LEFT_EDGE_VISIBLE;\n    }\n    if (componentBounds.right == componentVisibleBounds.right) {\n      mFlags |= FLAG_RIGHT_EDGE_VISIBLE;\n    }\n  }\n\n  boolean doNotClearInThisPass() {\n    return mDoNotClearInThisPass;\n  }\n\n  void setDoNotClearInThisPass(boolean doNotClearInThisPass) {\n    mDoNotClearInThisPass = doNotClearInThisPass;\n  }\n}<fim_middle>// function below has no smell\n"}