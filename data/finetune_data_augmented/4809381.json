{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage org.apache.skywalking.oap.server.core.storage;\n\nimport java.util.*;\nimport java.util.concurrent.*;\nimport org.apache.skywalking.apm.util.RunnableWithExceptionProtection;\nimport org.apache.skywalking.oap.server.core.analysis.worker.*;\nimport org.apache.skywalking.oap.server.library.module.ModuleManager;\nimport org.apache.skywalking.oap.server.telemetry.TelemetryModule;\nimport org.apache.skywalking.oap.server.telemetry.api.*;\nimport org.slf4j.*;\n\n/**\n * @author peng-yongsheng\n */\npublic enum PersistenceTimer {\n    INSTANCE;\n\n    private static final Logger logger = LoggerFactory.getLogger(PersistenceTimer.class);\n\n    private Boolean isStarted = false;\n    private final Boolean debug;\n    private CounterMetric errorCounter;\n    private HistogramMetric prepareLatency;\n    private HistogramMetric executeLatency;\n\n    PersistenceTimer() {\n        this.debug = System.getProperty(\"debug\") != null;\n    }\n\n    public void start(ModuleManager moduleManager) {\n        logger.info(\"persistence timer start\");\n        //TODO timer value config\n//        final long timeInterval = EsConfig.Es.Persistence.Timer.VALUE * 1000;\n        final long timeInterval = 3;\n        IBatchDAO batchDAO = moduleManager.find(StorageModule.NAME).provider().getService(IBatchDAO.class);\n\n        MetricCreator metricCreator = moduleManager.find(TelemetryModule.NAME).provider().getService(MetricCreator.class);\n        errorCounter = metricCreator.createCounter(\"persistence_timer_bulk_error_count\", \"Error execution of the prepare stage in persistence timer\",\n            MetricTag.EMPTY_KEY, MetricTag.EMPTY_VALUE);\n        prepareLatency = metricCreator.createHistogramMetric(\"persistence_timer_bulk_prepare_latency\", \"Latency of the prepare stage in persistence timer\",\n            MetricTag.EMPTY_KEY, MetricTag.EMPTY_VALUE);\n        executeLatency = metricCreator.createHistogramMetric(\"persistence_timer_bulk_execute_latency\", \"Latency of the execute stage in persistence timer\",\n            MetricTag.EMPTY_KEY, MetricTag.EMPTY_VALUE);\n\n        if (!isStarted) {\n            Executors.newSingleThreadScheduledExecutor().scheduleAtFixedRate(\n                new RunnableWithExceptionProtection(() -> extractDataAndSave(batchDAO),\n                    t -> logger.error(\"Extract data and save failure.\", t)), 1, timeInterval, TimeUnit.SECONDS);\n\n            this.isStarted = true;\n        }\n    }\n\n<fim_suffix>    @SuppressWarnings(\"unchecked\")\n    private void extractDataAndSave(IBatchDAO batchDAO) {\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Extract data and save\");\n        }\n\n        long startTime = System.currentTimeMillis();\n        try {\n            HistogramMetric.Timer timer = prepareLatency.createTimer();\n\n            List batchAllCollection = new LinkedList();\n            try {\n                List<PersistenceWorker> persistenceWorkers = new ArrayList<>();\n                persistenceWorkers.addAll(IndicatorProcess.INSTANCE.getPersistentWorkers());\n                persistenceWorkers.addAll(RecordProcess.INSTANCE.getPersistentWorkers());\n                persistenceWorkers.addAll(TopNProcess.INSTANCE.getPersistentWorkers());\n\n                persistenceWorkers.forEach(worker -> {\n                    if (logger.isDebugEnabled()) {\n                        logger.debug(\"extract {} worker data and save\", worker.getClass().getName());\n                    }\n\n                    if (worker.flushAndSwitch()) {\n                        List<?> batchCollection = worker.buildBatchCollection();\n\n                        if (logger.isDebugEnabled()) {\n                            logger.debug(\"extract {} worker data size: {}\", worker.getClass().getName(), batchCollection.size());\n                        }\n                        batchAllCollection.addAll(batchCollection);\n                    }\n                });\n\n                if (debug) {\n                    logger.info(\"build batch persistence duration: {} ms\", System.currentTimeMillis() - startTime);\n                }\n            } finally {\n                timer.finish();\n            }\n\n            HistogramMetric.Timer executeLatencyTimer = executeLatency.createTimer();\n            try {\n                batchDAO.batchPersistence(batchAllCollection);\n            } finally {\n                executeLatencyTimer.finish();\n            }\n        } catch (Throwable e) {\n            errorCounter.inc();\n            logger.error(e.getMessage(), e);\n        } finally {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"persistence data save finish\");\n            }\n        }\n\n        if (debug) {\n            logger.info(\"batch persistence duration: {} ms\", System.currentTimeMillis() - startTime);\n        }\n    }\n}<fim_middle>// function below is long method\n"}