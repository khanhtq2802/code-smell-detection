{"text": "<fim_prefix>/*\n *\n *  * Licensed to the Apache Software Foundation (ASF) under one or more\n *  * contributor license agreements.  See the NOTICE file distributed with\n *  * this work for additional information regarding copyright ownership.\n *  * The ASF licenses this file to You under the Apache License, Version 2.0\n *  * (the \"License\"); you may not use this file except in compliance with\n *  * the License.  You may obtain a copy of the License at\n *  *\n *  *    http://www.apache.org/licenses/LICENSE-2.0\n *  *\n *  * Unless required by applicable law or agreed to in writing, software\n *  * distributed under the License is distributed on an \"AS IS\" BASIS,\n *  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  * See the License for the specific language governing permissions and\n *  * limitations under the License.\n *\n */\npackage org.apache.eagle.jpm.spark.history.status;\nimport org.apache.eagle.jpm.spark.history.SparkHistoryJobAppConfig;\nimport org.apache.eagle.jpm.spark.history.crawl.SparkApplicationInfo;\nimport org.apache.curator.framework.CuratorFramework;\nimport org.apache.curator.framework.CuratorFrameworkFactory;\nimport org.apache.curator.framework.api.transaction.CuratorTransactionBridge;\nimport org.apache.curator.framework.recipes.locks.InterProcessLock;\nimport org.apache.curator.framework.recipes.locks.InterProcessReadWriteLock;\nimport org.apache.curator.retry.RetryNTimes;\nimport org.apache.zookeeper.CreateMode;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\npublic class JobHistoryZKStateManager {\n    private static final Logger LOG = LoggerFactory.getLogger(JobHistoryZKStateManager.class);\n    private static final String START_TIMESTAMP = \"lastAppTime\";\n    private String zkRoot;\n    private CuratorFramework curator;\n    private CuratorFramework newCurator(SparkHistoryJobAppConfig config) throws Exception {\n        return CuratorFrameworkFactory.newClient(\n                config.zkStateConfig.zkQuorum,\n                config.zkStateConfig.zkSessionTimeoutMs,\n                15000,\n                new RetryNTimes(config.zkStateConfig.zkRetryTimes, config.zkStateConfig.zkRetryInterval)\n        );\n    }\n    public JobHistoryZKStateManager(SparkHistoryJobAppConfig config) {\n        this.zkRoot = config.zkStateConfig.zkRoot + \"/\" + config.stormConfig.siteId;\n        try {\n            curator = newCurator(config);\n            curator.start();\n        } catch (Exception e) {\n            LOG.error(\"Fail to connect to zookeeper\", e);\n            throw new RuntimeException(e);\n        }\n    }\n    public void close() {\n        curator.close();\n        curator = null;\n    }\n    public List<String> loadApplications(int limit) {\n        String jobPath = zkRoot + \"/jobs\";\n        List<String> apps = new ArrayList<>();\n        //InterProcessLock lock = new InterProcessReadWriteLock(curator,jobPath).writeLock();\n        try {\n            //lock.acquire();\n            Iterator<String> iter = curator.getChildren().forPath(jobPath).iterator();\n            while (iter.hasNext()) {\n                String appId = iter.next();\n                String path = jobPath + \"/\" + appId;\n                if (curator.checkExists().forPath(path) != null) {\n                    if (new String(curator.getData().forPath(path)).equals(ZKStateConstant.AppStatus.INIT.toString())) {\n                        apps.add(appId);\n                    }\n                }\n                if (apps.size() == limit) {\n                    break;\n                }\n            }\n            return apps;\n        } catch (Exception e) {\n            LOG.error(\"fail to read unprocessed jobs\", e);\n            throw new RuntimeException(e);\n        } finally {\n           /* try {\n                lock.release();\n            } catch (Exception e) {\n                LOG.error(\"fail to release lock\", e);\n            }*/\n        }\n    }\n<fim_suffix>    public void resetApplications() {\n        String jobPath = zkRoot + \"/jobs\";\n        InterProcessLock lock = new InterProcessReadWriteLock(curator,jobPath).writeLock();\n        try {\n            lock.acquire();\n            (curator.getChildren().forPath(jobPath)).forEach(appId -> {\n                String path = jobPath + \"/\" + appId;\n                try {\n                    if (curator.checkExists().forPath(path) != null) {\n                        String status = new String(curator.getData().forPath(path));\n                        if (!ZKStateConstant.AppStatus.INIT.toString().equals(status)) {\n                            curator.setData().forPath(path, ZKStateConstant.AppStatus.INIT.toString().getBytes(\"UTF-8\"));\n                        }\n                    }\n                } catch (Exception e) {\n                    LOG.error(\"fail to read unprocessed job\", e);\n                    throw new RuntimeException(e);\n                }\n            });\n        } catch (Exception e) {\n            LOG.error(\"fail to read unprocessed jobs\", e);\n            throw new RuntimeException(e);\n        } finally {\n            try {\n                lock.release();\n            } catch (Exception e) {\n                LOG.error(\"fail to release lock\", e);\n            }\n        }\n    }\n    public SparkApplicationInfo getApplicationInfo(String appId) {\n        String appPath = zkRoot + \"/jobs/\" + appId + \"/info\";\n        try {\n            SparkApplicationInfo info = new SparkApplicationInfo();\n            if (curator.checkExists().forPath(appPath) != null) {\n                String[] appStatus = new String(curator.getData().forPath(appPath)).split(\"/\");\n                info.setQueue(appStatus[0]);\n                info.setState(appStatus[1]);\n                info.setFinalStatus(appStatus[2]);\n                if (appStatus.length > 3) {\n                    info.setUser(appStatus[3]);\n                    info.setName(appStatus[4]);\n                }\n            }\n            return info;\n        } catch (Exception e) {\n            LOG.error(\"fail to read application attempt info\", e);\n            throw new RuntimeException(e);\n        }\n    }\n    public long readLastFinishedTimestamp() {\n        String lastTimeStampPath = zkRoot + \"/\" + START_TIMESTAMP;\n        try {\n            if (curator.checkExists().forPath(lastTimeStampPath) == null) {\n                return 0L;\n            } else {\n                return Long.valueOf(new String(curator.getData().forPath(lastTimeStampPath)));\n            }\n        } catch (Exception e) {\n            LOG.error(\"fail to read last finished spark job timestamp\", e);\n            throw new RuntimeException(e);\n        }\n    }\n    public boolean hasApplication(String appId) {\n        String path = zkRoot + \"/jobs/\" + appId;\n        try {\n            return curator.checkExists().forPath(path) != null;\n        } catch (Exception e) {\n            LOG.error(\"fail to check whether application exists\", e);\n            throw new RuntimeException(e);\n        }\n    }\n    public void addFinishedApplication(String appId, String queue, String yarnState, String yarnStatus, String user, String name) {\n        String path = zkRoot + \"/jobs/\" + appId;\n        try {\n            if (curator.checkExists().forPath(path) != null) {\n                curator.delete().deletingChildrenIfNeeded().forPath(path);\n            }\n            name = name.replace(\"/\", \"_\");\n            if (name.length() > 50) {\n                name = name.substring(0, 50);\n            }\n            CuratorTransactionBridge result =  curator.inTransaction().create().withMode(CreateMode.PERSISTENT).forPath(path, ZKStateConstant.AppStatus.INIT.toString().getBytes(\"UTF-8\"));\n            result = result.and().create().withMode(CreateMode.PERSISTENT).forPath(path + \"/info\", String.format(\"%s/%s/%s/%s/%s\", queue, yarnState, yarnStatus, user, name).getBytes(\"UTF-8\"));\n            result.and().commit();\n        } catch (Exception e) {\n            LOG.error(\"fail adding finished application\", e);\n            throw new RuntimeException(e);\n        }\n    }\n    public void updateLastUpdateTime(Long updateTime) {\n        String lastTimeStampPath = zkRoot + \"/\" + START_TIMESTAMP;\n        try {\n            if (curator.checkExists().forPath(lastTimeStampPath) == null) {\n                curator.create().creatingParentsIfNeeded().withMode(CreateMode.PERSISTENT).forPath(lastTimeStampPath, updateTime.toString().getBytes(\"UTF-8\"));\n            } else {\n                long originalEndTime = this.readLastFinishedTimestamp();\n                if (originalEndTime < updateTime) {\n                    curator.setData().forPath(lastTimeStampPath, updateTime.toString().getBytes(\"UTF-8\"));\n                }\n            }\n        } catch (Exception e) {\n            LOG.error(\"fail to update last finished time\", e);\n            throw new RuntimeException(e);\n        }<fim_middle>// function below is feature envy and long method\n"}