{"text": "<fim_prefix> * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.springframework.data.mongodb.repository.query;\nimport reactor.core.publisher.Flux;\nimport reactor.core.publisher.Mono;\nimport org.bson.Document;\nimport org.reactivestreams.Publisher;\nimport org.springframework.core.convert.converter.Converter;\nimport org.springframework.data.convert.EntityInstantiators;\nimport org.springframework.data.mongodb.core.MongoOperations;\nimport org.springframework.data.mongodb.core.ReactiveFindOperation.FindWithProjection;\nimport org.springframework.data.mongodb.core.ReactiveFindOperation.FindWithQuery;\nimport org.springframework.data.mongodb.core.ReactiveFindOperation.TerminatingFind;\nimport org.springframework.data.mongodb.core.ReactiveMongoOperations;\nimport org.springframework.data.mongodb.core.query.Query;\nimport org.springframework.data.mongodb.repository.query.ReactiveMongoQueryExecution.DeleteExecution;\nimport org.springframework.data.mongodb.repository.query.ReactiveMongoQueryExecution.GeoNearExecution;\nimport org.springframework.data.mongodb.repository.query.ReactiveMongoQueryExecution.ResultProcessingConverter;\nimport org.springframework.data.mongodb.repository.query.ReactiveMongoQueryExecution.ResultProcessingExecution;\nimport org.springframework.data.repository.query.ParameterAccessor;\nimport org.springframework.data.repository.query.RepositoryQuery;\nimport org.springframework.data.repository.query.ResultProcessor;\nimport org.springframework.util.Assert;\n/**\n * Base class for reactive {@link RepositoryQuery} implementations for MongoDB.\n *\n * @author Mark Paluch\n * @author Christoph Strobl\n * @since 2.0\n */\n<fim_suffix>public abstract class AbstractReactiveMongoQuery implements RepositoryQuery {\n\tprivate final ReactiveMongoQueryMethod method;\n\tprivate final ReactiveMongoOperations operations;\n\tprivate final EntityInstantiators instantiators;\n\tprivate final FindWithProjection<?> findOperationWithProjection;\n\t/**\n\t * Creates a new {@link AbstractReactiveMongoQuery} from the given {@link MongoQueryMethod} and\n\t * {@link MongoOperations}.\n\t *\n\t * @param method must not be {@literal null}.\n\t * @param operations must not be {@literal null}.\n\t */\n\tpublic AbstractReactiveMongoQuery(ReactiveMongoQueryMethod method, ReactiveMongoOperations operations) {\n\t\tAssert.notNull(method, \"MongoQueryMethod must not be null!\");\n\t\tAssert.notNull(operations, \"ReactiveMongoOperations must not be null!\");\n\t\tthis.method = method;\n\t\tthis.operations = operations;\n\t\tthis.instantiators = new EntityInstantiators();\n\t\tMongoEntityMetadata<?> metadata = method.getEntityInformation();\n\t\tClass<?> type = metadata.getCollectionEntity().getType();\n\t\tthis.findOperationWithProjection = operations.query(type);\n\t}\n\t/*\n\t * (non-Javadoc)\n\t * @see org.springframework.data.repository.query.RepositoryQuery#getQueryMethod()\n\t */\n\tpublic MongoQueryMethod getQueryMethod() {\n\t\treturn method;\n\t}\n\t/*\n\t * (non-Javadoc)\n\t * @see org.springframework.data.repository.query.RepositoryQuery#execute(java.lang.Object[])\n\t */\n\tpublic Object execute(Object[] parameters) {\n\t\treturn method.hasReactiveWrapperParameter() ? executeDeferred(parameters)\n\t\t\t\t: execute(new MongoParametersParameterAccessor(method, parameters));\n\t}\n\t@SuppressWarnings(\"unchecked\")\n\tprivate Object executeDeferred(Object[] parameters) {\n\t\tReactiveMongoParameterAccessor parameterAccessor = new ReactiveMongoParameterAccessor(method, parameters);\n\t\tif (getQueryMethod().isCollectionQuery()) {\n\t\t\treturn Flux.defer(() -> (Publisher<Object>) execute(parameterAccessor));\n\t\t}\n\t\treturn Mono.defer(() -> (Mono<Object>) execute(parameterAccessor));\n\t}\n\tprivate Object execute(MongoParameterAccessor parameterAccessor) {\n\t\tQuery query = createQuery(new ConvertingParameterAccessor(operations.getConverter(), parameterAccessor));\n\t\tapplyQueryMetaAttributesWhenPresent(query);\n\t\tquery = applyAnnotatedDefaultSortIfPresent(query);\n\t\tResultProcessor processor = method.getResultProcessor().withDynamicProjection(parameterAccessor);\n\t\tClass<?> typeToRead = processor.getReturnedType().getTypeToRead();\n\t\tFindWithQuery<?> find = typeToRead == null //\n\t\t\t\t? findOperationWithProjection //\n\t\t\t\t: findOperationWithProjection.as(typeToRead);\n\t\tString collection = method.getEntityInformation().getCollectionName();\n\t\tReactiveMongoQueryExecution execution = getExecution(parameterAccessor,\n\t\t\t\tnew ResultProcessingConverter(processor, operations, instantiators), find);\n\t\treturn execution.execute(query, processor.getReturnedType().getDomainType(), collection);\n\t}\n\t/**\n\t * Returns the execution instance to use.\n\t *\n\t * @param accessor must not be {@literal null}.\n\t * @param resultProcessing must not be {@literal null}.\n\t * @return\n\t */\n\tprivate ReactiveMongoQueryExecution getExecution(MongoParameterAccessor accessor,\n\t\t\tConverter<Object, Object> resultProcessing, FindWithQuery<?> operation) {\n\t\treturn new ResultProcessingExecution(getExecutionToWrap(accessor, operation), resultProcessing);\n\t}\n\tprivate ReactiveMongoQueryExecution getExecutionToWrap(MongoParameterAccessor accessor, FindWithQuery<?> operation) {\n\t\tif (isDeleteQuery()) {\n\t\t\treturn new DeleteExecution(operations, method);\n\t\t} else if (method.isGeoNearQuery()) {\n\t\t\treturn new GeoNearExecution(operations, accessor, method.getReturnType());\n\t\t} else if (isTailable(method)) {\n\t\t\treturn (q, t, c) -> operation.matching(q.with(accessor.getPageable())).tail();\n\t\t} else if (method.isCollectionQuery()) {\n\t\t\treturn (q, t, c) -> operation.matching(q.with(accessor.getPageable())).all();\n\t\t} else if (isCountQuery()) {\n\t\t\treturn (q, t, c) -> operation.matching(q).count();\n\t\t} else if (isExistsQuery()) {\n\t\t\treturn (q, t, c) -> operation.matching(q).exists();\n\t\t} else {\n\t\t\treturn (q, t, c) -> {\n\t\t\t\tTerminatingFind<?> find = operation.matching(q);\n\t\t\t\tif (isCountQuery()) {\n\t\t\t\t\treturn find.count();\n\t\t\t\t}\n\t\t\t\treturn isLimiting() ? find.first() : find.one();\n\t\t\t};\n\t\t}\n\t}\n\tprivate boolean isTailable(MongoQueryMethod method) {\n\t\treturn method.getTailableAnnotation() != null;\n\t}\n\tQuery applyQueryMetaAttributesWhenPresent(Query query) {\n\t\tif (method.hasQueryMetaAttributes()) {\n\t\t\tquery.setMeta(method.getQueryMetaAttributes());\n\t\t}\n\t\treturn query;\n\t}\n\t/**\n\t * Add a default sort derived from {@link org.springframework.data.mongodb.repository.Query#sort()} to the given\n\t * {@link Query} if present.\n\t *\n\t * @param query the {@link Query} to potentially apply the sort to.\n\t * @return the query with potential default sort applied.\n\t * @since 2.1\n\t */\n\tQuery applyAnnotatedDefaultSortIfPresent(Query query) {\n\t\tif (!method.hasAnnotatedSort()) {\n\t\t\treturn query;\n\t\t}\n\t\treturn QueryUtils.decorateSort(query, Document.parse(method.getAnnotatedSort()));\n\t}\n\t/**\n\t * Creates a {@link Query} instance using the given {@link ConvertingParameterAccessor}. Will delegate to\n\t * {@link #createQuery(ConvertingParameterAccessor)} by default but allows customization of the count query to be\n\t * triggered.\n\t *\n\t * @param accessor must not be {@literal null}.\n\t * @return\n\t */\n\tprotected Query createCountQuery(ConvertingParameterAccessor accessor) {\n\t\treturn applyQueryMetaAttributesWhenPresent(createQuery(accessor));\n\t}\n\t/**\n\t * Creates a {@link Query} instance using the given {@link ParameterAccessor}\n\t *\n\t * @param accessor must not be {@literal null}.\n\t * @return\n\t */\n\tprotected abstract Query createQuery(ConvertingParameterAccessor accessor);\n\t/**\n\t * Returns whether the query should get a count projection applied.\n\t *\n\t * @return\n\t */\n\tprotected abstract boolean isCountQuery();\n\t/**\n\t * Returns whether the query should get an exists projection applied.\n\t *\n\t * @return\n\t * @since 2.0.9\n\t */\n\tprotected abstract boolean isExistsQuery();\n\t/**\n\t * Return weather the query should delete matching documents.\n\t *\n\t * @return\n\t * @since 1.5\n\t */\n\tprotected abstract boolean isDeleteQuery();\n\t/**\n\t * Return whether the query has an explicit limit set.\n\t *\n\t * @return\n\t * @since 2.0.4\n\t */\n\tprotected abstract boolean isLimiting();\n}<fim_middle>// class below has no smell\n"}