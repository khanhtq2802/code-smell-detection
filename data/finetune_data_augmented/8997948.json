{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.lucene.analysis.ja.util;\n\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.util.Arrays;\n\nimport org.apache.lucene.analysis.ja.dict.CharacterDefinition;\n\nimport org.apache.lucene.codecs.CodecUtil;\nimport org.apache.lucene.store.DataOutput;\nimport org.apache.lucene.store.OutputStreamDataOutput;\n\npublic final class CharacterDefinitionWriter {\n\n  private final byte[] characterCategoryMap = new byte[0x10000];\n  \n  private final boolean[] invokeMap = new boolean[CharacterDefinition.CLASS_COUNT];\n  private final boolean[] groupMap = new boolean[CharacterDefinition.CLASS_COUNT];\n    \n  /**\n   * Constructor for building. TODO: remove write access\n   */\n  public CharacterDefinitionWriter() {\n    Arrays.fill(characterCategoryMap, CharacterDefinition.DEFAULT);\n  }\n  \n  /**\n   * Put mapping from unicode code point to character class.\n   * \n   * @param codePoint\n   *            code point\n   * @param characterClassName character class name\n   */\n  public void putCharacterCategory(int codePoint, String characterClassName) {\n    characterClassName = characterClassName.split(\" \")[0]; // use first\n    // category\n    // class\n    \n    // Override Nakaguro\n    if (codePoint == 0x30FB) {\n      characterClassName = \"SYMBOL\";\n    }\n    characterCategoryMap[codePoint] = CharacterDefinition.lookupCharacterClass(characterClassName);\n  }\n  \n  public void putInvokeDefinition(String characterClassName, int invoke, int group, int length) {\n    final byte characterClass = CharacterDefinition.lookupCharacterClass(characterClassName);\n    invokeMap[characterClass] = invoke == 1;\n    groupMap[characterClass] = group == 1;\n    // TODO: length def ignored\n  }\n  \n<fim_suffix>  public void write(String baseDir) throws IOException {\n    String filename = baseDir + File.separator +\n      CharacterDefinition.class.getName().replace('.', File.separatorChar) + CharacterDefinition.FILENAME_SUFFIX;\n    new File(filename).getParentFile().mkdirs();\n    OutputStream os = new FileOutputStream(filename);\n    try {\n      os = new BufferedOutputStream(os);\n      final DataOutput out = new OutputStreamDataOutput(os);\n      CodecUtil.writeHeader(out, CharacterDefinition.HEADER, CharacterDefinition.VERSION);\n      out.writeBytes(characterCategoryMap, 0, characterCategoryMap.length);\n      for (int i = 0; i < CharacterDefinition.CLASS_COUNT; i++) {\n        final byte b = (byte) (\n          (invokeMap[i] ? 0x01 : 0x00) | \n          (groupMap[i] ? 0x02 : 0x00)\n        );\n        out.writeByte(b);\n      }\n    } finally {\n      os.close();\n    }\n  }\n  \n}<fim_middle>// function below has no smell\n"}