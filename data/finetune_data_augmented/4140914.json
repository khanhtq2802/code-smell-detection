{"text": "<fim_prefix>        builder.put(entry.getKey(), table);\n      }\n    }\n    // add tables derived from implicit functions\n    addImplicitTablesBasedOnNullaryFunctionsToBuilder(builder);\n    return builder.build();\n  }\n  /** Returns a tables derived from explicit and implicit functions\n   * that take zero parameters. */\n  public final TableEntry getTableBasedOnNullaryFunction(String tableName,\n      boolean caseSensitive) {\n    for (Map.Entry<String, FunctionEntry> entry\n        : nullaryFunctionMap.range(tableName, caseSensitive).entrySet()) {\n      final Function function = entry.getValue().getFunction();\n      if (function instanceof TableMacro) {\n        assert function.getParameters().isEmpty();\n        final Table table = ((TableMacro) function).apply(ImmutableList.of());\n        return tableEntry(tableName, table);\n      }\n    }\n    return getImplicitTableBasedOnNullaryFunction(tableName, caseSensitive);\n  }\n  /** Creates a snapshot of this CalciteSchema as of the specified time. All\n   * explicit objects in this CalciteSchema will be copied into the snapshot\n   * CalciteSchema, while the contents of the snapshot of the underlying schema\n   * should not change as specified in {@link Schema#snapshot(SchemaVersion)}.\n   * Snapshots of explicit sub schemas will be created and copied recursively.\n   *\n   * <p>Currently, to accommodate the requirement of creating tables on the fly\n   * for materializations, the snapshot will still use the same table map and\n   * lattice map as in the original CalciteSchema instead of making copies.</p>\n   *\n   * @param version The current schema version\n   *\n   * @return the schema snapshot.\n   */\n  public CalciteSchema createSnapshot(SchemaVersion version) {\n    Preconditions.checkArgument(this.isRoot(), \"must be root schema\");\n    return snapshot(null, version);\n  }\n  /** Returns a subset of a map whose keys match the given string\n   * case-insensitively.\n   * @deprecated use NameMap\n   */\n  @Deprecated // to be removed before 2.0\n  protected static <V> NavigableMap<String, V> find(NavigableMap<String, V> map,\n      String s) {\n    return NameMap.immutableCopyOf(map).range(s, false);\n  }\n  /** Returns a subset of a set whose values match the given string\n   * case-insensitively.\n   * @deprecated use NameSet\n   */\n  @Deprecated // to be removed before 2.0\n  protected static Iterable<String> find(NavigableSet<String> set, String name) {\n    return NameSet.immutableCopyOf(set).range(name, false);\n  }\n  /** Creates a root schema.\n   *\n   * <p>When <code>addMetadataSchema</code> argument is true adds a \"metadata\"\n   * schema containing definitions of tables, columns etc. to root schema.\n   * By default, creates a {@link CachingCalciteSchema}.\n   */\n  public static CalciteSchema createRootSchema(boolean addMetadataSchema) {\n    return createRootSchema(addMetadataSchema, true);\n  }\n  /** Creates a root schema.\n   *\n   * @param addMetadataSchema Whether to add a \"metadata\" schema containing\n   *              definitions of tables, columns etc.\n   * @param cache If true create {@link CachingCalciteSchema};\n   *                if false create {@link SimpleCalciteSchema}\n   */\n  public static CalciteSchema createRootSchema(boolean addMetadataSchema,\n      boolean cache) {\n    return createRootSchema(addMetadataSchema, cache, \"\");\n  }\n  /** Creates a root schema.\n   *\n   * @param addMetadataSchema Whether to add a \"metadata\" schema containing\n   *              definitions of tables, columns etc.\n   * @param cache If true create {@link CachingCalciteSchema};\n   *                if false create {@link SimpleCalciteSchema}\n   * @param name Schema name\n   */\n  public static CalciteSchema createRootSchema(boolean addMetadataSchema,\n      boolean cache, String name) {\n    CalciteSchema rootSchema;\n    final Schema schema = new CalciteConnectionImpl.RootSchema();\n    if (cache) {\n      rootSchema = new CachingCalciteSchema(null, schema, name);\n    } else {\n      rootSchema = new SimpleCalciteSchema(null, schema, name);\n    }\n    if (addMetadataSchema) {\n      rootSchema.add(\"metadata\", MetadataSchema.INSTANCE);\n    }\n    return rootSchema;\n  }\n  @Experimental\n  public boolean removeSubSchema(String name) {\n    return subSchemaMap.remove(name) != null;\n  }\n  @Experimental\n  public boolean removeTable(String name) {\n    return tableMap.remove(name) != null;\n  }\n  @Experimental\n  public boolean removeFunction(String name) {\n    final FunctionEntry remove = nullaryFunctionMap.remove(name);\n    if (remove == null) {\n      return false;\n    }\n    functionMap.remove(name, remove);\n    return true;\n  }\n  @Experimental\n  public boolean removeType(String name) {\n    return typeMap.remove(name) != null;\n  }\n  /**\n   * Entry in a schema, such as a table or sub-schema.\n   *\n   * <p>Each object's name is a property of its membership in a schema;\n   * therefore in principle it could belong to several schemas, or\n   * even the same schema several times, with different names. In this\n   * respect, it is like an inode in a Unix file system.</p>\n   *\n   * <p>The members of a schema must have unique names.\n   */\n  public abstract static class Entry {\n    public final CalciteSchema schema;\n    public final String name;\n    public Entry(CalciteSchema schema, String name) {\n      this.schema = Objects.requireNonNull(schema);\n      this.name = Objects.requireNonNull(name);\n    }\n    /** Returns this object's path. For example [\"hr\", \"emps\"]. */\n    public final List<String> path() {\n      return schema.path(name);\n    }\n  }\n  /** Membership of a table in a schema. */\n  public abstract static class TableEntry extends Entry {\n    public final ImmutableList<String> sqls;\n    public TableEntry(CalciteSchema schema, String name,\n        ImmutableList<String> sqls) {\n      super(schema, name);\n      this.sqls = Objects.requireNonNull(sqls);\n    }\n    public abstract Table getTable();\n  }\n  /** Membership of a type in a schema. */\n  public abstract static class TypeEntry extends Entry {\n    public TypeEntry(CalciteSchema schema, String name) {\n      super(schema, name);\n    }\n    public abstract RelProtoDataType getType();\n  }\n  /** Membership of a function in a schema. */\n  public abstract static class FunctionEntry extends Entry {\n    public FunctionEntry(CalciteSchema schema, String name) {\n      super(schema, name);\n    }\n    public abstract Function getFunction();\n    /** Whether this represents a materialized view. (At a given point in time,\n     * it may or may not be materialized as a table.) */\n    public abstract boolean isMaterialization();\n  }\n  /** Membership of a lattice in a schema. */\n  public abstract static class LatticeEntry extends Entry {\n    public LatticeEntry(CalciteSchema schema, String name) {\n      super(schema, name);\n    }\n    public abstract Lattice getLattice();\n    public abstract TableEntry getStarTable();\n  }\n  /** Implementation of {@link SchemaPlus} based on a\n   * {@link org.apache.calcite.jdbc.CalciteSchema}. */\n  private class SchemaPlusImpl implements SchemaPlus {\n    CalciteSchema calciteSchema() {\n      return CalciteSchema.this;\n    }\n    public SchemaPlus getParentSchema() {\n      return parent == null ? null : parent.plus();\n    }\n    public String getName() {\n      return CalciteSchema.this.getName();\n    }\n    public boolean isMutable() {\n      return schema.isMutable();\n    }\n    public void setCacheEnabled(boolean cache) {\n      CalciteSchema.this.setCache(cache);\n    }\n    public boolean isCacheEnabled() {\n      return CalciteSchema.this.isCacheEnabled();\n    }\n    public Schema snapshot(SchemaVersion version) {\n      throw new UnsupportedOperationException();\n    }\n    public Expression getExpression(SchemaPlus parentSchema, String name) {\n      return schema.getExpression(parentSchema, name);\n    }\n    public Table getTable(String name) {\n      final TableEntry entry = CalciteSchema.this.getTable(name, true);\n      return entry == null ? null : entry.getTable();\n    }\n    public NavigableSet<String> getTableNames() {\n      return CalciteSchema.this.getTableNames();\n    }\n    @Override public RelProtoDataType getType(String name) {\n      final TypeEntry entry = CalciteSchema.this.getType(name, true);\n      return entry == null ? null : entry.getType();\n    }\n    @Override public Set<String> getTypeNames() {\n      return CalciteSchema.this.getTypeNames();\n    }\n<fim_suffix>    public Collection<Function> getFunctions(String name) {\n      return CalciteSchema.this.getFunctions(name, true);\n    }<fim_middle>// function below has no smell\n"}