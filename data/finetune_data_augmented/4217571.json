{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.chain2.web.servlet;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Enumeration;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.apache.commons.chain2.web.MapEntry;\n\n/**\n * <p>Private implementation of <code>Map</code> for servlet request\n * name-values[].</p>\n *\n * @version $Id$\n */\nfinal class ServletHeaderValuesMap implements Map<String, String[]> {\n\n    public ServletHeaderValuesMap(HttpServletRequest request) {\n        this.request = request;\n    }\n\n    private final HttpServletRequest request;\n\n    public void clear() {\n        throw new UnsupportedOperationException();\n    }\n\n    public boolean containsKey(Object key) {\n        return (request.getHeader(key(key)) != null);\n    }\n\n    public boolean containsValue(Object value) {\n        if (!(value instanceof String[])) {\n            return (false);\n        }\n        String[] test = (String[]) value;\n\n        for (String[] actual : values()) {\n            if (test.length == actual.length) {\n                boolean matched = true;\n                for (int i = 0; i < test.length; i++) {\n                    if (!test[i].equals(actual[i])) {\n                        matched = false;\n                        break;\n                    }\n                }\n                if (matched) {\n                    return (true);\n                }\n            }\n        }\n\n        return (false);\n    }\n\n    public Set<Entry<String, String[]>> entrySet() {\n        Set<Entry<String, String[]>> set = new HashSet<Entry<String, String[]>>();\n        @SuppressWarnings( \"unchecked\" ) // it is known that header names are String\n        Enumeration<String> keys = request.getHeaderNames();\n        String key;\n        while (keys.hasMoreElements()) {\n            key = keys.nextElement();\n            @SuppressWarnings( \"unchecked\" ) // it is known that header values are String\n            Enumeration<String> values = request.getHeaders(key);\n            String[] valuesArray = enumerationToArray(values);\n            /* Previously the API was returning an Set<Entry<String, Enumeration<String>>\n             * I'm assuming that this was a bug because it violates the contract of how the\n             * mapping class behaves. So, I fixed it right here.\n             */\n            set.add(new MapEntry<String, String[]>(key, valuesArray, false));\n        }\n        return (set);\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        return (request.equals(o));\n    }\n\n    public String[] get(Object key) {\n        @SuppressWarnings( \"unchecked\" ) // it is known that header names are String\n        Enumeration<String> values = request.getHeaders(key(key));\n        String[] valuesArray = enumerationToArray(values);\n\n        return valuesArray;\n    }\n\n    @Override\n    public int hashCode() {\n        return (request.hashCode());\n    }\n\n    public boolean isEmpty() {\n        return (size() < 1);\n    }\n\n    public Set<String> keySet() {\n        Set<String> set = new HashSet<String>();\n        @SuppressWarnings( \"unchecked\" ) // it is known that header names are String\n        Enumeration<String> keys = request.getHeaderNames();\n        while (keys.hasMoreElements()) {\n            set.add(keys.nextElement());\n        }\n        return (set);\n    }\n\n    public String[] put(String key, String[] value) {\n        throw new UnsupportedOperationException();\n    }\n\n    public void putAll(Map<? extends String, ? extends String[]> map) {\n        throw new UnsupportedOperationException();\n    }\n\n    public String[] remove(Object key) {\n        throw new UnsupportedOperationException();\n    }\n\n    public int size() {\n        int n = 0;\n        @SuppressWarnings( \"unchecked\" ) // it is known that header names are String\n        Enumeration<String> keys = request.getHeaderNames();\n        while (keys.hasMoreElements()) {\n            keys.nextElement();\n            n++;\n        }\n        return (n);\n    }\n\n    public Collection<String[]> values() {\n        List<String[]> list = new ArrayList<String[]>();\n        @SuppressWarnings( \"unchecked\" ) // it is known that header names are String\n        Enumeration<String> keys = request.getHeaderNames();\n        while (keys.hasMoreElements()) {\n            String key = keys.nextElement();\n            @SuppressWarnings( \"unchecked\" ) // it is known that header values are String\n            Enumeration<String> values = request.getHeaders(key);\n            String[] valuesArray = enumerationToArray(values);\n            list.add(valuesArray);\n        }\n        return (list);\n    }\n\n    /**\n     * Simple utility method that converts a string enumeration into a string array.\n     * @param values enumeration of strings\n     * @return enumeration represented as a string array\n     */\n<fim_suffix>    private static String[] enumerationToArray(Enumeration<String> values) {\n        ArrayList<String> list = new ArrayList<String>();\n\n        while (values.hasMoreElements()) {\n            list.add(values.nextElement());\n        }\n\n        return list.toArray(new String[list.size()]);\n    }\n\n    private String key(Object key) {\n        if (key == null) {\n            throw new IllegalArgumentException();\n        } else if (key instanceof String) {\n            return ((String) key);\n        } else {\n            return (key.toString());\n        }\n    }\n\n}<fim_middle>// function below has no smell\n"}