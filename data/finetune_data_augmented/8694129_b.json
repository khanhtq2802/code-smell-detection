{"text": "<fim_prefix> */\n<fim_suffix>@ThreadSafe\npublic final class MetricsFactory {\n    private static final UtilCache<String, Metrics> METRICS_CACHE = UtilCache.createUtilCache(\"base.metrics\", 0, 0);\n    /**\n     * A \"do-nothing\" <code>Metrics</code> instance.\n     */\n    public static final Metrics NULL_METRICS = new NullMetrics();\n    /**\n     * Creates a <code>Metrics</code> instance based on <code>element</code> attributes.\n     * If an instance with the same name already exists, it will be returned.\n     * <table border=\"1\">\n     *   <caption><strong>Element Attributes</strong></caption>\n     *   <tr><th>Attribute Name</th><th>Requirements</th><th>Description</th><th>Notes</th></tr>\n     *   <tr>\n     *     <td>name</td>\n     *     <td>Required</td>\n     *     <td>The metric name.</td>\n     *     <td>&nbsp;</td>\n     *   <tr>\n     *     <td>estimation-size</td>\n     *     <td>Optional</td>\n     *     <td>Positive integer number of events to include in the metrics calculation.</td>\n     *     <td>Defaults to \"100\".</td>\n     *   </tr>\n     *   <tr>\n     *     <td>estimation-time</td>\n     *     <td>Optional</td>\n     *     <td>Positive integer number of milliseconds to include in the metrics calculation.</td>\n     *     <td>Defaults to \"1000\".</td>\n     *   </tr>\n     *   <tr>\n     *     <td>smoothing</td>\n     *     <td>Optional</td>\n     *     <td>Smoothing factor - used to smooth the differences between calculations.</td>\n     *     <td>A value of \"1\" disables smoothing. Defaults to \"0.7\".</td>\n     *   </tr>\n     *   <tr>\n     *     <td>threshold</td>\n     *     <td>Optional</td>\n     *     <td>The metric threshold. The meaning of the threshold is determined by client code.</td>\n     *     <td>Defaults to \"0.0\".</td></tr>\n     * </table>\n     * \n     * @param element The element whose attributes will be used to create the <code>Metrics</code> instance\n     * @return A <code>Metrics</code> instance based on <code>element</code> attributes\n     * @throws IllegalArgumentException if <code>element</code> is null or if the name attribute is empty\n     * @throws NumberFormatException if any of the numeric attribute values are unparsable\n     */\n    public static Metrics getInstance(Element element) {\n        Assert.notNull(\"element\", element);\n        String name = element.getAttribute(\"name\");\n        Assert.notEmpty(\"name attribute\", name);\n        Metrics result = METRICS_CACHE.get(name);\n        if (result == null) {\n            int estimationSize = UtilProperties.getPropertyAsInteger(\"serverstats\", \"metrics.estimation.size\", 100); \n            String attributeValue = element.getAttribute(\"estimation-size\");\n            if (!attributeValue.isEmpty()) {\n                estimationSize = Integer.parseInt(attributeValue);\n            }\n            long estimationTime = UtilProperties.getPropertyAsLong(\"serverstats\", \"metrics.estimation.time\", 1000);\n            attributeValue = element.getAttribute(\"estimation-time\");\n            if (!attributeValue.isEmpty()) {\n                estimationTime = Long.parseLong(attributeValue);\n            }\n            double smoothing = UtilProperties.getPropertyNumber(\"serverstats\", \"metrics.smoothing.factor\", 0.7);\n            attributeValue = element.getAttribute(\"smoothing\");\n            if (!attributeValue.isEmpty()) {\n                smoothing = Double.parseDouble(attributeValue);\n            }\n            double threshold = 0.0;\n            attributeValue = element.getAttribute(\"threshold\");\n            if (!attributeValue.isEmpty()) {\n                threshold = Double.parseDouble(attributeValue);\n            }\n            result = new MetricsImpl(name, estimationSize, estimationTime, smoothing, threshold);\n            METRICS_CACHE.putIfAbsent(name, result);\n            result = METRICS_CACHE.get(name);\n        }\n        return result;\n    }\n    /**\n     * Creates a <code>Metrics</code> instance.\n     * If an instance with the same name already exists, it will be returned.\n     * @param name The metric name.\n     * @param estimationSize Positive integer number of events to include in the metrics calculation.\n     * @param estimationTime Positive integer number of milliseconds to include in the metrics calculation.\n     * @param smoothing Smoothing factor - used to smooth the differences between calculations.\n     * @return A <code>Metrics</code> instance\n     */\n    public static Metrics getInstance(String name, int estimationSize, long estimationTime, double smoothing, double threshold) {\n        Assert.notNull(\"name\", name);\n        Metrics result = METRICS_CACHE.get(name);\n        if (result == null) {\n            result = new MetricsImpl(name, estimationSize, estimationTime, smoothing, threshold);\n            METRICS_CACHE.putIfAbsent(name, result);\n            result = METRICS_CACHE.get(name);\n        }\n        return result;\n    }\n    /**\n     * Returns an existing <code>Metric</code> instance with the specified name.\n     * Returns <code>null</code> if the metric does not exist.\n     * @param name The metric name\n     */\n    public static Metrics getMetric(String name) {\n        Assert.notNull(\"name\", name);\n        return METRICS_CACHE.get(name);\n    }\n    /**\n     * Returns all <code>Metric</code> instances, sorted by name.\n     */\n    public static Collection<Metrics> getMetrics() {\n        return new TreeSet<Metrics>(METRICS_CACHE.values());\n    }\n    private static final class MetricsImpl implements Metrics, Comparable<Metrics> {\n        private int count = 0;\n        private long lastTime = System.currentTimeMillis();\n        private double serviceRate = 0.0;\n        private long totalServiceTime = 0;\n        private long totalEvents = 0;\n        private long cumulativeEvents = 0;\n        private final String name;\n        private final int estimationSize;\n        private final long estimationTime;\n        private final double smoothing;\n        private final double threshold;\n        private MetricsImpl(String name, int estimationSize, long estimationTime, double smoothing, double threshold) {\n            this.name = name;\n            this.estimationSize = estimationSize;\n            this.estimationTime = estimationTime;\n            this.smoothing = smoothing;\n            this.threshold = threshold;\n        }\n        @Override\n        public int compareTo(Metrics other) {\n            return this.name.compareTo(other.getName());\n        }\n        @Override\n        public boolean equals(Object obj) {\n            if (obj == this) {\n                return true;\n            }\n            try {\n                MetricsImpl that = (MetricsImpl) obj;\n                return this.name.equals(that.name);\n            } catch (Exception e) {}\n            return false;\n        }\n        @Override\n        public String getName() {\n            return name;\n        }\n        @Override\n        public synchronized double getServiceRate() {\n            return serviceRate;\n        }\n        @Override\n        public double getThreshold() {\n            return threshold;\n        }\n        @Override\n        public synchronized long getTotalEvents() {\n            return cumulativeEvents;\n        }\n        @Override\n        public int hashCode() {\n            return name.hashCode();\n        }\n        @Override\n        public synchronized void recordServiceRate(int numEvents, long time) {\n            totalEvents += numEvents;\n            cumulativeEvents += numEvents;\n            totalServiceTime += time;\n            count++;\n            long curTime = System.currentTimeMillis();\n            if ((count == estimationSize) || (curTime - lastTime >= estimationTime)) {\n                if (totalEvents == 0) {\n                    totalEvents = 1;\n                }\n                double rate = totalServiceTime / totalEvents;\n                serviceRate = (rate * smoothing) + (serviceRate * (1.0 - smoothing));\n                count = 0;\n                lastTime = curTime;\n                totalEvents = totalServiceTime = 0;\n            }\n        }\n        @Override\n        public synchronized void reset() {\n            serviceRate = 0.0;\n            count = 0;\n            lastTime = System.currentTimeMillis();\n            totalEvents = totalServiceTime = cumulativeEvents = 0;\n        }\n        @Override\n        public String toString() {\n            return name;\n        }\n    }\n    private static final class NullMetrics implements Metrics {\n        @Override\n        public String getName() {\n            return \"NULL\";\n        }\n        @Override\n        public double getServiceRate() {\n            return 0;\n        }\n        @Override\n        public double getThreshold() {\n            return 0.0;\n        }\n        @Override\n        public long getTotalEvents() {\n            return 0;\n        }\n        @Override\n        public void recordServiceRate(int numEvents, long time) {\n        }\n        @Override\n        public void reset() {\n        }\n    }\n    private MetricsFactory() {}\n}<fim_middle>// class below is data class and blob\n"}