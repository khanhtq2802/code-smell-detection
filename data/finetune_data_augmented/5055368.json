{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.jena.sparql.util ;\nimport static org.apache.jena.atlas.lib.tuple.TupleFactory.tuple ;\nimport java.util.ArrayList ;\nimport java.util.Collection ;\nimport java.util.Iterator ;\nimport java.util.List ;\nimport org.apache.jena.atlas.lib.tuple.Tuple ;\nimport org.apache.jena.graph.Graph ;\nimport org.apache.jena.graph.Node ;\nimport org.apache.jena.graph.Triple ;\nimport org.apache.jena.sparql.core.DatasetGraph ;\nimport org.apache.jena.sparql.core.Quad ;\nimport org.apache.jena.sparql.util.NodeUtils.EqualityTest ;\n// Needs to be back tracking?\n/** Simple isomorphism testing\n * This code is simple and slow.\n * For graphs, the Graph isomorphism code in Jena is much better (better tested, better performance)\n * This code can work on any tuples of nodes. \n */\npublic class IsoMatcher\n{\n    // Possible speed ups \n    //  A/ Phase 1 - do all non-bNode tuples. / Phase 2 : all tuples with a bNode \n    //  B/ turn tuples2 into a map, keyed by (1) constants or (2) first term. \n    static boolean DEBUG = false ;\n    private final List<Tuple<Node>>        tuples1 ;\n    private final List<Tuple<Node>>        tuples2 ;\n//    private final Map<Node, Node>           mapping = new HashMap<>();\n//    private final Queue<Pair<Node, Node>>   causes  = new LinkedList<>() ;  \n    private final EqualityTest nodeTest ;\n    static class Mapping {\n        final Node     node1 ;\n        final Node     node2 ;\n        final Mapping  parent ;\n        static Mapping rootMapping = new Mapping(null, null, null) ;\n        public Mapping(Mapping parent, Node node1, Node node2) {\n            super() ;\n            this.parent = parent ;\n            this.node1 = node1 ;\n            this.node2 = node2 ;\n        }\n        public boolean mapped(Node node) {\n            return map(node) != null ;\n        }\n        public boolean revmapped(Node node) {\n            return revmap(node) != null ;\n        }\n        public Node map(Node node) {\n            Mapping mapping = this ;\n            while (mapping != rootMapping) {\n                if ( mapping.node1.equals(node) )\n                    return mapping.node2 ;\n                mapping = mapping.parent ;\n            }\n            return null ;\n        }\n        // Reverse mapping.\n        public Node revmap(Node node) {\n            Mapping mapping = this ;\n            while (mapping != rootMapping) {\n                if ( mapping.node2.equals(node) )\n                    return mapping.node1 ;\n                mapping = mapping.parent ;\n            }\n            return null ;\n        }\n        @Override\n        public String toString() {\n            StringBuilder sbuff = new StringBuilder() ;\n            Mapping mapping = this ;\n            while (mapping != rootMapping) {\n                sbuff.append(\"{\" + mapping.node1 + \" => \" + mapping.node2 + \"}\") ;\n                mapping = mapping.parent ;\n            }\n            sbuff.append(\"{}\") ;\n            return sbuff.toString() ;\n        }\n    }\n<fim_suffix>    static class Cause {\n        final Tuple<Node> tuple ;\n        final Mapping     mapping ;\n        public Cause(Tuple<Node> tuple, Mapping mapping) {\n            super() ;\n            this.tuple = tuple ;\n            this.mapping = mapping ;\n        }\n    }\n    public static boolean isomorphic(Graph g1, Graph g2) {\n        List<Tuple<Node>> x1 = tuplesTriples(g1.find(null, null, null)) ;\n        List<Tuple<Node>> x2 = tuplesTriples(g2.find(null, null, null)) ;\n        IsoMatcher matcher = new IsoMatcher(x1, x2, NodeUtils.sameTerm) ;\n        return matcher.match() ;\n    }\n    public static boolean isomorphic(DatasetGraph dsg1, DatasetGraph dsg2) {\n        List<Tuple<Node>> x1 = tuplesQuads(dsg1.find()) ;\n        List<Tuple<Node>> x2 = tuplesQuads(dsg2.find()) ;\n        IsoMatcher matcher = new IsoMatcher(x1, x2, NodeUtils.sameTerm) ;\n        return matcher.match() ;\n    }\n    public static boolean isomorphic(List<Tuple<Node>> x1, List<Tuple<Node>> x2) {\n        x1 = new ArrayList<>(x1) ;\n        x2 = new ArrayList<>(x2) ;\n        IsoMatcher matcher = new IsoMatcher(x1, x2, NodeUtils.sameTerm) ;\n        return matcher.match() ;\n    }\n    private static List<Tuple<Node>> tuplesTriples(Iterator<Triple> iter) {\n        List<Tuple<Node>> tuples = new ArrayList<>() ;\n        for ( ; iter.hasNext() ; ) {\n            Triple t = iter.next() ;\n            Tuple<Node> tuple = tuple(t.getSubject(), t.getPredicate(), t.getObject()) ;\n            tuples.add(tuple) ;\n        }\n        return tuples ;\n    }\n    private static List<Tuple<Node>> tuplesQuads(Iterator<Quad> iter) {\n        List<Tuple<Node>> tuples = new ArrayList<>() ;\n        for ( ; iter.hasNext() ; ) {\n            Quad q = iter.next() ;\n            Tuple<Node> tuple = tuple(q.getGraph(), q.getSubject(), q.getPredicate(), q.getObject()) ;\n            tuples.add(tuple) ;\n        }\n        return tuples ;\n    }\n    public IsoMatcher(List<Tuple<Node>> g1, List<Tuple<Node>> g2, EqualityTest nodeTest) {\n        this.tuples1 = g1 ;\n        this.tuples2 = g2 ;\n        this.nodeTest = nodeTest ;\n    }\n    // May MUTATE tuples1 or tuples2\n    public boolean match() {\n        return match(tuples1, tuples2, Mapping.rootMapping) ;\n    }\n    private boolean match(List<Tuple<Node>> tuples1, List<Tuple<Node>> tuples2, Mapping mapping) {\n        if ( DEBUG ) {\n            System.out.println(\"match: \") ;\n            System.out.println(\"  \"+tuples1) ;\n            System.out.println(\"  \"+tuples2) ;\n            System.out.println(\"  \"+mapping) ; \n        }\n        if ( tuples1.size() != tuples2.size() )\n            return false;\n        List<Tuple<Node>> tuples = new ArrayList<>(tuples1) ;  // Copy, mutate\n        for ( Tuple<Node> t1 : tuples1 ) {\n            if ( DEBUG )\n                System.out.println(\"  t1 = \"+t1) ;\n            tuples.remove(t1) ;\n            List<Cause> causes = match(t1, tuples2, mapping) ;\n            for ( Cause c : causes ) {\n                if ( DEBUG ) \n                    System.out.println(\"  Try: \"+c.mapping) ;\n                // Try t1 -> t2\n                Tuple<Node> t2 = c.tuple ;\n                tuples2.remove(t2) ;\n                if ( tuples2.isEmpty() )\n                    return true ;\n                if ( match(tuples, tuples2, c.mapping) ) {\n                    if ( DEBUG ) \n                        System.out.println(\"Yes\") ;\n                    return true ;\n                }\n                if ( DEBUG ) \n                    System.out.println(\"No\") ;\n                tuples2.add(t2) ;\n            }\n            return false ;\n        }\n        // The empty-empty case\n        return true ;\n    }\n    private List<Cause> match(Tuple<Node> t1, Collection<Tuple<Node>> g2, Mapping mapping) {\n        List<Cause> matches = new ArrayList<>() ;\n        for ( Tuple<Node> t2 : g2 ) {\n            // No - multiple bNodes.\n            Mapping step = gen(t1, t2, mapping) ;\n            if (step != null) { \n                Cause c = new Cause(t2, step) ;\n                matches.add(c) ;\n            }\n        }\n        return matches ;\n    }\n    // Maybe several mappings!\n    private Mapping gen(Tuple<Node> t1, Tuple<Node> t2, Mapping _mapping) {\n        if ( t1.len() != t2.len() )\n            return null ;\n        Mapping mapping = _mapping ;<fim_middle>// class below is data class\n"}