{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.cassandra.hints;\nimport java.io.DataInput;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Path;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.UUID;\nimport java.util.regex.Pattern;\nimport java.util.zip.CRC32;\nimport javax.crypto.Cipher;\nimport com.google.common.base.MoreObjects;\nimport com.google.common.base.Objects;\nimport com.google.common.collect.ImmutableMap;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.apache.cassandra.config.DatabaseDescriptor;\nimport org.apache.cassandra.config.ParameterizedClass;\nimport org.apache.cassandra.db.TypeSizes;\nimport org.apache.cassandra.io.FSReadError;\nimport org.apache.cassandra.io.compress.ICompressor;\nimport org.apache.cassandra.io.util.DataOutputPlus;\nimport org.apache.cassandra.net.MessagingService;\nimport org.apache.cassandra.schema.CompressionParams;\nimport org.apache.cassandra.security.EncryptionContext;\nimport org.apache.cassandra.utils.Hex;\nimport org.json.simple.JSONValue;\nimport static org.apache.cassandra.utils.FBUtilities.updateChecksumInt;\n/**\n * Describes the host id, the version, the timestamp of creation, and an arbitrary map of JSON-encoded parameters of a\n * hints file.\n *\n * Written in the beginning of each hints file.\n */\nfinal class HintsDescriptor\n{\n    private static final Logger logger = LoggerFactory.getLogger(HintsDescriptor.class);\n    static final int VERSION_30 = 1;\n    static final int VERSION_40 = 2;\n    static final int CURRENT_VERSION = VERSION_40;\n    static final String COMPRESSION = \"compression\";\n    static final String ENCRYPTION = \"encryption\";\n    static final Pattern pattern =\n        Pattern.compile(\"^[a-fA-F0-9]{8}\\\\-[a-fA-F0-9]{4}\\\\-[a-fA-F0-9]{4}\\\\-[a-fA-F0-9]{4}\\\\-[a-fA-F0-9]{12}\\\\-(\\\\d+)\\\\-(\\\\d+)\\\\.hints$\");\n    final UUID hostId;\n    final int version;\n    final long timestamp;\n    final ImmutableMap<String, Object> parameters;\n    final ParameterizedClass compressionConfig;\n    private final Cipher cipher;\n    private final ICompressor compressor;\n    HintsDescriptor(UUID hostId, int version, long timestamp, ImmutableMap<String, Object> parameters)\n    {\n        this.hostId = hostId;\n        this.version = version;\n        this.timestamp = timestamp;\n        compressionConfig = createCompressionConfig(parameters);\n        EncryptionData encryption = createEncryption(parameters);\n        if (encryption == null)\n        {\n            cipher = null;\n            compressor = null;\n        }\n        else\n        {\n            if (compressionConfig != null)\n                throw new IllegalStateException(\"a hints file cannot be configured for both compression and encryption\");\n            cipher = encryption.cipher;\n            compressor = encryption.compressor;\n            parameters = encryption.params;\n        }\n        this.parameters = parameters;\n    }\n    HintsDescriptor(UUID hostId, long timestamp, ImmutableMap<String, Object> parameters)\n    {\n        this(hostId, CURRENT_VERSION, timestamp, parameters);\n    }\n    HintsDescriptor(UUID hostId, long timestamp)\n    {\n        this(hostId, CURRENT_VERSION, timestamp, ImmutableMap.<String, Object>of());\n    }\n    @SuppressWarnings(\"unchecked\")\n    static ParameterizedClass createCompressionConfig(Map<String, Object> params)\n    {\n        if (params.containsKey(COMPRESSION))\n        {\n            Map<String, Object> compressorConfig = (Map<String, Object>) params.get(COMPRESSION);\n            return new ParameterizedClass((String) compressorConfig.get(ParameterizedClass.CLASS_NAME),\n                                          (Map<String, String>) compressorConfig.get(ParameterizedClass.PARAMETERS));\n        }\n        else\n        {\n            return null;\n        }\n    }\n    /**\n     * Create, if necessary, the required encryption components (for either decrpyt or encrypt operations).\n     * Note that in the case of encyption (this is, when writing out a new hints file), we need to write\n     * the cipher's IV out to the header so it can be used when decrypting. Thus, we need to add an additional\n     * entry to the {@code params} map.\n     *\n     * @param params the base parameters into the descriptor.\n     * @return null if not using encryption; else, the initialized {@link Cipher} and a possibly updated version\n     * of the {@code params} map.\n     */\n    @SuppressWarnings(\"unchecked\")\n    static EncryptionData createEncryption(ImmutableMap<String, Object> params)\n    {\n        if (params.containsKey(ENCRYPTION))\n        {\n            Map<?, ?> encryptionConfig = (Map<?, ?>) params.get(ENCRYPTION);\n            EncryptionContext encryptionContext = EncryptionContext.createFromMap(encryptionConfig, DatabaseDescriptor.getEncryptionContext());\n            try\n            {\n                Cipher cipher;\n                if (encryptionConfig.containsKey(EncryptionContext.ENCRYPTION_IV))\n                {\n                    cipher = encryptionContext.getDecryptor();\n                }\n                else\n                {\n                    cipher = encryptionContext.getEncryptor();\n                    ImmutableMap<String, Object> encParams = ImmutableMap.<String, Object>builder()\n                                                                 .putAll(encryptionContext.toHeaderParameters())\n                                                                 .put(EncryptionContext.ENCRYPTION_IV, Hex.bytesToHex(cipher.getIV()))\n                                                                 .build();\n                    Map<String, Object> map = new HashMap<>(params);\n                    map.put(ENCRYPTION, encParams);\n                    params = ImmutableMap.<String, Object>builder().putAll(map).build();\n                }\n                return new EncryptionData(cipher, encryptionContext.getCompressor(), params);\n            }\n            catch (IOException ioe)\n            {\n                logger.warn(\"failed to create encyption context for hints file. ignoring encryption for hints.\", ioe);\n                return null;\n            }\n        }\n        else\n        {\n            return null;\n        }\n    }\n<fim_suffix>    private static final class EncryptionData\n    {\n        final Cipher cipher;\n        final ICompressor compressor;\n        final ImmutableMap<String, Object> params;\n        private EncryptionData(Cipher cipher, ICompressor compressor, ImmutableMap<String, Object> params)\n        {\n            this.cipher = cipher;\n            this.compressor = compressor;\n            this.params = params;\n        }\n    }\n    String fileName()\n    {\n        return String.format(\"%s-%s-%s.hints\", hostId, timestamp, version);\n    }\n    String checksumFileName()\n    {\n        return String.format(\"%s-%s-%s.crc32\", hostId, timestamp, version);\n    }\n    int messagingVersion()\n    {\n        return messagingVersion(version);\n    }\n    static int messagingVersion(int hintsVersion)\n    {\n        switch (hintsVersion)\n        {\n            case VERSION_30:\n                return MessagingService.VERSION_30;\n            case VERSION_40:\n                return MessagingService.VERSION_40;\n            default:\n                throw new AssertionError();\n        }\n    }\n    static boolean isHintFileName(Path path)\n    {\n        return pattern.matcher(path.getFileName().toString()).matches();\n    }\n    static Optional<HintsDescriptor> readFromFileQuietly(Path path)\n    {\n        try (RandomAccessFile raf = new RandomAccessFile(path.toFile(), \"r\"))\n        {\n            return Optional.of(deserialize(raf));\n        }\n        catch (ChecksumMismatchException e)\n        {\n            throw new FSReadError(e, path.toFile());\n        }\n        catch (IOException e)\n        {\n            logger.error(\"Failed to deserialize hints descriptor {}\", path.toString(), e);\n            return Optional.empty();\n        }\n    }\n    static HintsDescriptor readFromFile(Path path)\n    {\n        try (RandomAccessFile raf = new RandomAccessFile(path.toFile(), \"r\"))\n        {\n            return deserialize(raf);\n        }\n        catch (IOException e)\n        {\n            throw new FSReadError(e, path.toFile());\n        }\n    }\n    public boolean isCompressed()\n    {\n        return compressionConfig != null;\n    }<fim_middle>// class below has no smell\n"}