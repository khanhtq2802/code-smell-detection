{"text": "<fim_prefix>        {\n            T item = list.get(i);\n            result.updateValue(groupBy.valueOf(item), Functions0.zeroBigInteger(), original -> original.add(function.valueOf(item)));\n        }\n        return result;\n    }\n    public static <T> boolean shortCircuit(\n            List<T> list,\n            Predicate<? super T> predicate,\n            boolean expected,\n            boolean onShortCircuit,\n            boolean atEnd)\n    {\n        int size = list.size();\n        for (int i = 0; i < size; i++)\n        {\n            if (predicate.accept(list.get(i)) == expected)\n            {\n                return onShortCircuit;\n            }\n        }\n        return atEnd;\n    }\n    public static <T, P> boolean shortCircuitWith(\n            List<T> list,\n            Predicate2<? super T, ? super P> predicate2,\n            P parameter,\n            boolean expected,\n            boolean onShortCircuit,\n            boolean atEnd)\n    {\n        int size = list.size();\n        for (int i = 0; i < size; i++)\n        {\n            if (predicate2.accept(list.get(i), parameter) == expected)\n            {\n                return onShortCircuit;\n            }\n        }\n        return atEnd;\n    }\n    public static <T, P> boolean corresponds(List<T> list, OrderedIterable<P> other, Predicate2<? super T, ? super P> predicate)\n    {\n        if (!(list instanceof RandomAccess))\n        {\n            throw new IllegalArgumentException();\n        }\n        int size = list.size();\n        if (size != other.size())\n        {\n            return false;\n        }\n        if (other instanceof RandomAccess)\n        {\n            List<P> otherList = (List<P>) other;\n            for (int index = 0; index < size; index++)\n            {\n                if (!predicate.accept(list.get(index), otherList.get(index)))\n                {\n                    return false;\n                }\n            }\n            return true;\n        }\n        Iterator<P> iterator = other.iterator();\n        for (int index = 0; index < size; index++)\n        {\n            if (!predicate.accept(list.get(index), iterator.next()))\n            {\n                return false;\n            }\n        }\n        return true;\n    }\n    public static <T> boolean anySatisfy(List<T> list, Predicate<? super T> predicate)\n    {\n        return RandomAccessListIterate.shortCircuit(list, predicate, true, true, false);\n    }\n    public static <T, P> boolean anySatisfyWith(List<T> list, Predicate2<? super T, ? super P> predicate, P parameter)\n    {\n        return RandomAccessListIterate.shortCircuitWith(list, predicate, parameter, true, true, false);\n    }\n    public static <T> boolean allSatisfy(List<T> list, Predicate<? super T> predicate)\n    {\n        return RandomAccessListIterate.shortCircuit(list, predicate, false, false, true);\n    }\n    public static <T, P> boolean allSatisfyWith(List<T> list, Predicate2<? super T, ? super P> predicate, P parameter)\n    {\n        return RandomAccessListIterate.shortCircuitWith(list, predicate, parameter, false, false, true);\n    }\n    public static <T> boolean noneSatisfy(List<T> list, Predicate<? super T> predicate)\n    {\n        return RandomAccessListIterate.shortCircuit(list, predicate, true, false, true);\n    }\n    public static <T, P> boolean noneSatisfyWith(List<T> list, Predicate2<? super T, ? super P> predicate, P parameter)\n    {\n        return RandomAccessListIterate.shortCircuitWith(list, predicate, parameter, true, false, true);\n    }\n    public static <T> T detect(List<T> list, Predicate<? super T> predicate)\n    {\n        int size = list.size();\n        for (int i = 0; i < size; i++)\n        {\n            T each = list.get(i);\n            if (predicate.accept(each))\n            {\n                return each;\n            }\n        }\n        return null;\n    }\n    public static <T, P> T detectWith(List<T> list, Predicate2<? super T, ? super P> predicate, P parameter)\n    {\n        int size = list.size();\n        for (int i = 0; i < size; i++)\n        {\n            T each = list.get(i);\n            if (predicate.accept(each, parameter))\n            {\n                return each;\n            }\n        }\n        return null;\n    }\n    public static <T> Optional<T> detectOptional(List<T> list, Predicate<? super T> predicate)\n    {\n        int size = list.size();\n        for (int i = 0; i < size; i++)\n        {\n            T each = list.get(i);\n            if (predicate.accept(each))\n            {\n                return Optional.of(each);\n            }\n        }\n        return Optional.empty();\n    }\n    public static <T, P> Optional<T> detectWithOptional(List<T> list, Predicate2<? super T, ? super P> predicate, P parameter)\n    {\n        int size = list.size();\n        for (int i = 0; i < size; i++)\n        {\n            T each = list.get(i);\n            if (predicate.accept(each, parameter))\n            {\n                return Optional.of(each);\n            }\n        }\n        return Optional.empty();\n    }\n    public static <T, IV> Twin<MutableList<T>> selectAndRejectWith(\n            List<T> list,\n            Predicate2<? super T, ? super IV> predicate,\n            IV injectedValue)\n    {\n        MutableList<T> positiveResult = Lists.mutable.empty();\n        MutableList<T> negativeResult = Lists.mutable.empty();\n        int size = list.size();\n        for (int i = 0; i < size; i++)\n        {\n            T item = list.get(i);\n            (predicate.accept(item, injectedValue) ? positiveResult : negativeResult).add(item);\n        }\n        return Tuples.twin(positiveResult, negativeResult);\n    }\n    public static <T> PartitionMutableList<T> partition(List<T> list, Predicate<? super T> predicate)\n    {\n        PartitionFastList<T> partitionFastList = new PartitionFastList<>();\n        int size = list.size();\n        for (int i = 0; i < size; i++)\n        {\n            T each = list.get(i);\n            MutableList<T> bucket = predicate.accept(each)\n                    ? partitionFastList.getSelected()\n                    : partitionFastList.getRejected();\n            bucket.add(each);\n        }\n        return partitionFastList;\n    }\n    public static <T, P> PartitionMutableList<T> partitionWith(List<T> list, Predicate2<? super T, ? super P> predicate, P parameter)\n    {\n        PartitionFastList<T> partitionFastList = new PartitionFastList<>();\n        int size = list.size();\n        for (int i = 0; i < size; i++)\n        {\n            T each = list.get(i);\n            MutableList<T> bucket = predicate.accept(each, parameter)\n                    ? partitionFastList.getSelected()\n                    : partitionFastList.getRejected();\n            bucket.add(each);\n        }\n        return partitionFastList;\n    }\n    public static <T> boolean removeIf(List<T> list, Predicate<? super T> predicate)\n    {\n        boolean changed = false;\n        for (int i = 0; i < list.size(); i++)\n        {\n            T each = list.get(i);\n            if (predicate.accept(each))\n            {\n                list.remove(i--);\n                changed = true;\n            }\n        }\n        return changed;\n    }\n    public static <T, P> boolean removeIfWith(List<T> list, Predicate2<? super T, ? super P> predicate, P parameter)\n    {\n        boolean changed = false;\n        for (int i = 0; i < list.size(); i++)\n        {\n            T each = list.get(i);\n            if (predicate.accept(each, parameter))\n            {\n                list.remove(i--);\n                changed = true;\n            }\n        }\n        return changed;\n    }\n<fim_suffix>    public static <T> boolean removeIf(List<T> list, Predicate<? super T> predicate, Procedure<? super T> procedure)\n    {\n        boolean changed = false;\n        for (int i = 0; i < list.size(); i++)\n        {\n            T each = list.get(i);\n            if (predicate.accept(each))\n            {\n                procedure.value(each);\n                list.remove(i--);\n                changed = true;\n            }\n        }\n        return changed;\n    }<fim_middle>// function below has no smell\n"}