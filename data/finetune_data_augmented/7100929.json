{"text": "<fim_prefix>\n<fim_suffix>@Deprecated\npublic final class CompactCharArray implements Cloneable {\n    /**\n     * The total number of Unicode characters.\n     * @deprecated This API is ICU internal only.\n     * @hide draft / provisional / internal are hidden on Android\n     */\n    @Deprecated\n    public static  final int UNICODECOUNT = 65536;\n    /**\n     * Default constructor for CompactCharArray, the default value of the\n     * compact array is 0.\n     * @deprecated This API is ICU internal only.\n     * @hide draft / provisional / internal are hidden on Android\n     */\n    @Deprecated\n    public CompactCharArray()\n    {\n        this((char)0);\n    }\n    /**\n     * Constructor for CompactCharArray.\n     * @param defaultValue the default value of the compact array.\n     * @deprecated This API is ICU internal only.\n     * @hide draft / provisional / internal are hidden on Android\n     */\n    @Deprecated\n    public CompactCharArray(char defaultValue)\n    {\n        int i;\n        values = new char[UNICODECOUNT];\n        indices = new char[INDEXCOUNT];\n        hashes = new int[INDEXCOUNT];\n        for (i = 0; i < UNICODECOUNT; ++i) {\n            values[i] = defaultValue;\n        }\n        for (i = 0; i < INDEXCOUNT; ++i) {\n            indices[i] = (char)(i<<BLOCKSHIFT);\n            hashes[i] = 0;\n        }\n        isCompact = false;\n        this.defaultValue = defaultValue;\n    }\n    /**\n     * Constructor for CompactCharArray.\n     * @param indexArray the indicies of the compact array.\n     * @param newValues the values of the compact array.\n     * @exception IllegalArgumentException If the index is out of range.\n     * @deprecated This API is ICU internal only.\n     * @hide draft / provisional / internal are hidden on Android\n     */\n    @Deprecated\n    public CompactCharArray(char indexArray[],\n                             char newValues[])\n    {\n        int i;\n        if (indexArray.length != INDEXCOUNT)\n            throw new IllegalArgumentException(\"Index out of bounds.\");\n        for (i = 0; i < INDEXCOUNT; ++i) {\n            char index = indexArray[i];\n            if (index >= newValues.length+BLOCKCOUNT)\n                throw new IllegalArgumentException(\"Index out of bounds.\");\n        }\n        indices = indexArray;\n        values = newValues;\n        isCompact = true;\n    }\n    /**\n     * Constructor for CompactCharArray.\n     *\n     * @param indexArray the RLE-encoded indicies of the compact array.\n     * @param valueArray the RLE-encoded values of the compact array.\n     *\n     * @throws IllegalArgumentException if the index or value array is\n     *          the wrong size.\n     * @deprecated This API is ICU internal only.\n     * @hide draft / provisional / internal are hidden on Android\n     */\n    @Deprecated\n    public CompactCharArray(String indexArray,\n                String valueArray)\n    {\n        this( Utility.RLEStringToCharArray(indexArray),\n              Utility.RLEStringToCharArray(valueArray));\n    }\n    /**\n     * Get the mapped value of a Unicode character.\n     * @param index the character to get the mapped value with\n     * @return the mapped value of the given character\n     * @deprecated This API is ICU internal only.\n     * @hide draft / provisional / internal are hidden on Android\n     */\n    @Deprecated\n    public char elementAt(char index)\n    {\n    int ix = (indices[index >> BLOCKSHIFT] & 0xFFFF)\n        + (index & BLOCKMASK);\n    return ix >= values.length ? defaultValue : values[ix];\n    }\n    /**\n     * Set a new value for a Unicode character.\n     * Set automatically expands the array if it is compacted.\n     * @param index the character to set the mapped value with\n     * @param value the new mapped value\n     * @deprecated This API is ICU internal only.\n     * @hide draft / provisional / internal are hidden on Android\n     */\n    @Deprecated\n    public void setElementAt(char index, char value)\n    {\n        if (isCompact)\n            expand();\n         values[index] = value;\n        touchBlock(index >> BLOCKSHIFT, value);\n    }\n    /**\n     * Set new values for a range of Unicode character.\n     *\n     * @param start the starting offset of the range\n     * @param end the ending offset of the range\n     * @param value the new mapped value\n     * @deprecated This API is ICU internal only.\n     * @hide draft / provisional / internal are hidden on Android\n     */\n    @Deprecated\n    public void setElementAt(char start, char end, char value)\n    {\n        int i;\n        if (isCompact) {\n            expand();\n        }\n        for (i = start; i <= end; ++i) {\n            values[i] = value;\n            touchBlock(i >> BLOCKSHIFT, value);\n        }\n    }\n    /**\n     * Compact the array\n     * @deprecated This API is ICU internal only.\n     * @hide draft / provisional / internal are hidden on Android\n     */\n    @Deprecated\n    public void compact() {\n        compact(true);\n    }\n    /**\n     * Compact the array.\n     * @deprecated This API is ICU internal only.\n     * @hide draft / provisional / internal are hidden on Android\n     */\n    @Deprecated\n    public void compact(boolean exhaustive)\n    {\n        if (!isCompact) {\n            int iBlockStart = 0;\n            char iUntouched = 0xFFFF;\n            int newSize = 0;\n            char[] target = exhaustive ? new char[UNICODECOUNT] : values;\n            for (int i = 0; i < indices.length; ++i, iBlockStart += BLOCKCOUNT) {\n                indices[i] = 0xFFFF;\n                boolean touched = blockTouched(i);\n                if (!touched && iUntouched != 0xFFFF) {\n                    // If no values in this block were set, we can just set its\n                    // index to be the same as some other block with no values\n                    // set, assuming we've seen one yet.\n                    indices[i] = iUntouched;\n                } else {\n                    int jBlockStart = 0;\n                    // See if we can find a previously compacted block that's identical\n                    for (int j = 0; j < i; ++j, jBlockStart += BLOCKCOUNT) {\n                        if (hashes[i] == hashes[j] &&\n                                arrayRegionMatches(values, iBlockStart,\n                                                   values, jBlockStart, BLOCKCOUNT)) {\n                            indices[i] = indices[j];\n                        }\n                    }\n                    if (indices[i] == 0xFFFF) {\n                        int dest;   // Where to copy\n                        if (exhaustive) {\n                            // See if we can find some overlap with another block\n                            dest = FindOverlappingPosition(iBlockStart, target,\n                                                            newSize);\n                        } else {\n                            // Just copy to the end; it's quicker\n                            dest = newSize;\n                        }\n                        int limit = dest + BLOCKCOUNT;\n                        if (limit > newSize) {\n                            for (int j = newSize; j < limit; ++j) {\n                                target[j] = values[iBlockStart + j - dest];\n                            }\n                            newSize = limit;\n                        }\n                        indices[i] = (char)dest;\n                        if (!touched) {\n                            // If this is the first untouched block we've seen,\n                            // remember its index.\n                            iUntouched = (char)jBlockStart;\n                        }\n                    }\n                }\n            }\n            // we are done compacting, so now make the array shorter\n            char[] result = new char[newSize];\n            System.arraycopy(target, 0, result, 0, newSize);\n            values = result;\n            isCompact = true;\n            hashes = null;\n        }\n    }\n    private int FindOverlappingPosition(int start, char[] tempValues, int tempCount)\n    {\n        for (int i = 0; i < tempCount; i += 1) {\n            int currentCount = BLOCKCOUNT;\n            if (i + BLOCKCOUNT > tempCount) {\n                currentCount = tempCount - i;\n            }\n            if (arrayRegionMatches(values, start, tempValues, i, currentCount))\n                return i;\n        }\n        return tempCount;\n    }\n    /**\n     * Convenience utility to compare two arrays of doubles.\n     * @param len the length to compare.\n     * The start indices and start+len must be valid.\n     */\n    final static boolean arrayRegionMatches(char[] source, int sourceStart,\n                                            char[] target, int targetStart,\n                                            int len)\n    {\n        int sourceEnd = sourceStart + len;\n        int delta = targetStart - sourceStart;\n        for (int i = sourceStart; i < sourceEnd; i++) {\n            if (source[i] != target[i + delta])\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Remember that a specified block was \"touched\", i.e. had a value set.\n     * Untouched blocks can be skipped when compacting the array\n     */\n    private final void touchBlock(int i, int value) {\n        hashes[i] = (hashes[i] + (value<<1)) | 1;\n    }\n    /**<fim_middle>// class below is blob\n"}