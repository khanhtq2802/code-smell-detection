{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.lucene.spatial.spatial4j;\n\nimport org.apache.lucene.spatial3d.geom.GeoBBox;\nimport org.apache.lucene.spatial3d.geom.GeoBBoxFactory;\nimport org.apache.lucene.spatial3d.geom.GeoPoint;\nimport org.apache.lucene.spatial3d.geom.GeoPointShapeFactory;\nimport org.apache.lucene.spatial3d.geom.LatLonBounds;\nimport org.locationtech.spatial4j.context.SpatialContext;\nimport org.locationtech.spatial4j.distance.DistanceUtils;\nimport org.locationtech.spatial4j.shape.Point;\nimport org.locationtech.spatial4j.shape.Rectangle;\nimport org.locationtech.spatial4j.shape.Shape;\nimport org.locationtech.spatial4j.shape.SpatialRelation;\n\n/**\n * Specialization of a {@link Geo3dShape} which represents a {@link Rectangle}.\n *\n * @lucene.experimental\n */\npublic class Geo3dRectangleShape extends Geo3dShape<GeoBBox> implements Rectangle {\n\n  private double minX;\n  private double maxX;\n  private double minY;\n  private double maxY;\n\n<fim_suffix>  public Geo3dRectangleShape(final GeoBBox shape,\n                             final SpatialContext spatialcontext,\n                             double minX,\n                             double maxX,\n                             double minY,\n                             double maxY) {\n    super(shape, spatialcontext);\n    this.minX = minX;\n    this.maxX = maxX;\n    this.minY = minY;\n    this.maxY = maxY;\n  }\n\n  public Geo3dRectangleShape(final GeoBBox shape, final SpatialContext spatialcontext) {\n    super(shape, spatialcontext);\n    setBoundsFromshape();\n  }\n\n\n  /**\n   * Set the bounds from the wrapped GeoBBox.\n   */\n  private void setBoundsFromshape() {\n    LatLonBounds bounds = new LatLonBounds();\n    shape.getBounds(bounds);\n    minX = bounds.checkNoLongitudeBound() ? -180.0 : bounds.getLeftLongitude() * DistanceUtils.RADIANS_TO_DEGREES;\n    minY = bounds.checkNoBottomLatitudeBound() ? -90.0 : bounds.getMinLatitude() * DistanceUtils.RADIANS_TO_DEGREES;\n    maxX = bounds.checkNoLongitudeBound() ? 180.0 : bounds.getRightLongitude() * DistanceUtils.RADIANS_TO_DEGREES;\n    maxY = bounds.checkNoTopLatitudeBound() ? 90.0 : bounds.getMaxLatitude() * DistanceUtils.RADIANS_TO_DEGREES;\n  }\n\n  @Override\n  public Point getCenter() {\n    Point center = this.center;//volatile read once\n    if (center == null) {\n      GeoPoint point = shape.getCenter();\n      center = new Geo3dPointShape(\n          GeoPointShapeFactory.makeGeoPointShape(shape.getPlanetModel(),\n              point.getLatitude(),\n              point.getLongitude()),\n          spatialcontext);\n      this.center = center;\n    }\n    return center;\n  }\n\n  @Override\n  public void reset(double minX, double maxX, double minY, double maxY) {\n    shape = GeoBBoxFactory.makeGeoBBox(shape.getPlanetModel(),\n        maxY * DistanceUtils.DEGREES_TO_RADIANS,\n        minY * DistanceUtils.DEGREES_TO_RADIANS,\n        minX * DistanceUtils.DEGREES_TO_RADIANS,\n        maxX * DistanceUtils.DEGREES_TO_RADIANS);\n    center = null;\n    boundingBox = null;\n  }\n\n  @Override\n  public Rectangle getBoundingBox() {\n    return this;\n  }\n\n  @Override\n  public double getWidth() {\n    double result = getMaxX() - getMinX();\n    if (result < 0) {\n      result += 360;\n    }\n    return result;\n  }\n\n  @Override\n  public double getHeight() {\n    return getMaxY() - getMinY();\n  }\n\n  @Override\n  public double getMinX() {\n    return minX;\n  }\n\n  @Override\n  public double getMinY() {\n    return minY;\n  }\n\n  @Override\n  public double getMaxX() {\n    return maxX;\n  }\n\n  @Override\n  public double getMaxY() {\n    return maxY;\n  }\n\n  @Override\n  public boolean getCrossesDateLine() {\n    return (getMaxX() > 0 && getMinX() < 0);\n\n  }\n\n  @Override\n  public SpatialRelation relateYRange(double minY, double maxY) {\n    Rectangle r = spatialcontext.getShapeFactory().rect(-180, 180, minY, maxY);\n    return relate(r);\n  }\n\n  @Override\n  public SpatialRelation relateXRange(double minX, double maxX) {\n    Rectangle r = spatialcontext.getShapeFactory().rect(minX, maxX, -90, 90);\n    return relate(r);\n  }\n\n  @Override\n  public Shape getBuffered(double distance, SpatialContext spatialContext) {\n    GeoBBox bBox = shape.expand(distance * DistanceUtils.DEGREES_TO_RADIANS);\n    return new Geo3dRectangleShape(bBox, spatialContext);\n  }\n}<fim_middle>// function below has no smell\n"}