{"text": "<fim_prefix>/*\n * Copyright 2002-2018 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.web.socket.messaging;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.core.annotation.AnnotationAwareOrderComparator;\nimport org.springframework.lang.Nullable;\nimport org.springframework.messaging.MessageChannel;\nimport org.springframework.messaging.SubscribableChannel;\nimport org.springframework.messaging.handler.MessagingAdviceBean;\nimport org.springframework.messaging.handler.annotation.support.AnnotationExceptionHandlerMethodResolver;\nimport org.springframework.messaging.simp.SimpMessageSendingOperations;\nimport org.springframework.messaging.simp.annotation.support.SimpAnnotationMethodMessageHandler;\nimport org.springframework.web.method.ControllerAdviceBean;\n\n/**\n * A sub-class of {@link SimpAnnotationMethodMessageHandler} to provide support\n * for {@link org.springframework.web.bind.annotation.ControllerAdvice\n * ControllerAdvice} with global {@code @MessageExceptionHandler} methods.\n *\n * @author Rossen Stoyanchev\n * @since 4.2\n */\npublic class WebSocketAnnotationMethodMessageHandler extends SimpAnnotationMethodMessageHandler {\n\n\tpublic WebSocketAnnotationMethodMessageHandler(SubscribableChannel clientInChannel,\n\t\t\tMessageChannel clientOutChannel, SimpMessageSendingOperations brokerTemplate) {\n\n\t\tsuper(clientInChannel, clientOutChannel, brokerTemplate);\n\t}\n\n\n\t@Override\n\tpublic void afterPropertiesSet() {\n\t\tinitControllerAdviceCache();\n\t\tsuper.afterPropertiesSet();\n\t}\n\n\tprivate void initControllerAdviceCache() {\n\t\tApplicationContext context = getApplicationContext();\n\t\tif (context == null) {\n\t\t\treturn;\n\t\t}\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Looking for @MessageExceptionHandler mappings: \" + context);\n\t\t}\n\t\tList<ControllerAdviceBean> beans = ControllerAdviceBean.findAnnotatedBeans(context);\n\t\tAnnotationAwareOrderComparator.sort(beans);\n\t\tinitMessagingAdviceCache(MessagingControllerAdviceBean.createFromList(beans));\n\t}\n\n\tprivate void initMessagingAdviceCache(@Nullable List<MessagingAdviceBean> beans) {\n\t\tif (beans == null) {\n\t\t\treturn;\n\t\t}\n\t\tfor (MessagingAdviceBean bean : beans) {\n\t\t\tClass<?> type = bean.getBeanType();\n\t\t\tif (type != null) {\n\t\t\t\tAnnotationExceptionHandlerMethodResolver resolver = new AnnotationExceptionHandlerMethodResolver(type);\n\t\t\t\tif (resolver.hasExceptionMappings()) {\n\t\t\t\t\tregisterExceptionHandlerAdvice(bean, resolver);\n\t\t\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\t\t\tlogger.trace(\"Detected @MessageExceptionHandler methods in \" + bean);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**\n\t * Adapt ControllerAdviceBean to MessagingAdviceBean.\n\t */\n\tprivate static final class MessagingControllerAdviceBean implements MessagingAdviceBean {\n\n\t\tprivate final ControllerAdviceBean adviceBean;\n\n\t\tprivate MessagingControllerAdviceBean(ControllerAdviceBean adviceBean) {\n\t\t\tthis.adviceBean = adviceBean;\n\t\t}\n\n\t\tpublic static List<MessagingAdviceBean> createFromList(List<ControllerAdviceBean> beans) {\n\t\t\tList<MessagingAdviceBean> result = new ArrayList<>(beans.size());\n\t\t\tfor (ControllerAdviceBean bean : beans) {\n\t\t\t\tresult.add(new MessagingControllerAdviceBean(bean));\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n<fim_suffix>\t\t@Override\n\t\t@Nullable\n\t\tpublic Class<?> getBeanType() {\n\t\t\treturn this.adviceBean.getBeanType();\n\t\t}\n\n\t\t@Override\n\t\tpublic Object resolveBean() {\n\t\t\treturn this.adviceBean.resolveBean();\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isApplicableToBeanType(Class<?> beanType) {\n\t\t\treturn this.adviceBean.isApplicableToBeanType(beanType);\n\t\t}\n\n\t\t@Override\n\t\tpublic int getOrder() {\n\t\t\treturn this.adviceBean.getOrder();\n\t\t}\n\t}\n\n}<fim_middle>// function below has no smell\n"}