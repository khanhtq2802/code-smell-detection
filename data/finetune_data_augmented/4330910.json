{"text": "<fim_prefix>    private static final boolean IS_DEBUG = LOG_CURSOR.isDebugEnabled();\n    private static final String UNSUPPORTED_MSG = I18n.err( I18n.ERR_716 );\n    /** An less eq evaluator for candidates */\n    private final LessEqEvaluator<V> lessEqEvaluator;\n    /** Cursor over attribute entry matching filter: set when index present */\n    private final Cursor<IndexEntry<V, String>> userIdxCursor;\n    /** NDN Cursor on all entries in  (set when no index on user attribute) */\n    private final Cursor<IndexEntry<String, String>> uuidIdxCursor;\n    /**\n     * Used to store indexEntry from uudCandidate so it can be saved after\n     * call to evaluate() which changes the value so it's not referring to\n     * the String but to the value of the attribute instead.\n     */\n    private IndexEntry<String, String> uuidCandidate;\n    /**\n     * Creates a new instance of an LessEqCursor\n     * \n     * @param partitionTxn The transaction to use\n     * @param store The store\n     * @param lessEqEvaluator The LessEqEvaluator\n     * @throws LdapException If the creation failed\n     * @throws IndexNotFoundException If the index was not found\n     */\n    @SuppressWarnings(\"unchecked\")\n    public LessEqCursor( PartitionTxn partitionTxn, Store store, LessEqEvaluator<V> lessEqEvaluator ) \n        throws LdapException, IndexNotFoundException\n    {\n        if ( IS_DEBUG )\n        {\n            LOG_CURSOR.debug( \"Creating LessEqCursor {}\", this );\n        }\n        this.lessEqEvaluator = lessEqEvaluator;\n        this.partitionTxn = partitionTxn;\n        AttributeType attributeType = lessEqEvaluator.getExpression().getAttributeType();\n        if ( store.hasIndexOn( attributeType ) )\n        {\n            userIdxCursor = ( ( Index<V, String> ) store.getIndex( attributeType ) ).forwardCursor( partitionTxn );\n            uuidIdxCursor = null;\n        }\n        else\n        {\n            uuidIdxCursor = new AllEntriesCursor( partitionTxn, store );\n            userIdxCursor = null;\n        }\n    }\n    /**\n     * {@inheritDoc}\n     */\n    protected String getUnsupportedMessage()\n    {\n        return UNSUPPORTED_MSG;\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void before( IndexEntry<V, String> element ) throws LdapException, CursorException\n    {\n        checkNotClosed();\n        if ( userIdxCursor != null )\n        {\n            /*\n             * First we need to check and make sure this element is within\n             * bounds as mandated by the assertion node.  To do so we compare\n             * it's value with the value of the expression node.  If the\n             * element's value is greater than this upper bound then we\n             * position the userIdxCursor after the last node.\n             *\n             * If the element's value is equal to this upper bound then we\n             * position the userIdxCursor right before the last node.\n             *\n             * If the element's value is smaller, then we delegate to the\n             * before() method of the userIdxCursor.\n             */\n            int compareValue = lessEqEvaluator.getComparator().compare( element.getKey(),\n                lessEqEvaluator.getExpression().getValue().getString() );\n            if ( compareValue > 0 )\n            {\n                afterLast();\n                return;\n            }\n            else if ( compareValue == 0 )\n            {\n                last();\n                previous();\n                setAvailable( false );\n                return;\n            }\n            userIdxCursor.before( element );\n            setAvailable( false );\n        }\n        else\n        {\n            super.before( element );\n        }\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void after( IndexEntry<V, String> element ) throws LdapException, CursorException\n    {\n        checkNotClosed();\n        if ( userIdxCursor != null )\n        {\n            int comparedValue = lessEqEvaluator.getComparator().compare( element.getKey(),\n                lessEqEvaluator.getExpression().getValue().getString() );\n            /*\n             * First we need to check and make sure this element is within\n             * bounds as mandated by the assertion node.  To do so we compare\n             * it's value with the value of the expression node.\n             *\n             * If the element's value is equal to or greater than this upper\n             * bound then we position the userIdxCursor after the last node.\n             *\n             * If the element's value is smaller, then we delegate to the\n             * after() method of the userIdxCursor.\n             */\n            if ( comparedValue >= 0 )\n            {\n                afterLast();\n                return;\n            }\n            // Element is in the valid range as specified by assertion\n            userIdxCursor.after( element );\n            setAvailable( false );\n        }\n        else\n        {\n            super.after( element );\n        }\n    }\n    /**\n     * {@inheritDoc}\n     */\n    public void beforeFirst() throws LdapException, CursorException\n    {\n        checkNotClosed();\n        if ( userIdxCursor != null )\n        {\n            userIdxCursor.beforeFirst();\n        }\n        else\n        {\n            uuidIdxCursor.beforeFirst();\n            uuidCandidate = null;\n        }\n        setAvailable( false );\n    }\n    /**\n     * {@inheritDoc}\n     */\n    public void afterLast() throws LdapException, CursorException\n    {\n        checkNotClosed();\n        if ( userIdxCursor != null )\n        {\n            IndexEntry<V, String> advanceTo = new IndexEntry<>();\n            //noinspection unchecked\n            String normalizedKey = lessEqEvaluator.getAttributeType().getEquality().getNormalizer().normalize( \n                lessEqEvaluator.getExpression().getValue().getString() );\n            advanceTo.setKey( ( V ) normalizedKey );\n            userIdxCursor.after( advanceTo );\n        }\n        else\n        {\n            uuidIdxCursor.afterLast();\n            uuidCandidate = null;\n        }\n        setAvailable( false );\n    }\n    /**\n     * {@inheritDoc}\n     */\n    public boolean first() throws LdapException, CursorException\n    {\n        beforeFirst();\n        return next();\n    }\n    /**\n     * {@inheritDoc}\n     */\n    public boolean last() throws LdapException, CursorException\n    {\n        afterLast();\n        return previous();\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean previous() throws LdapException, CursorException\n    {\n        checkNotClosed();\n        if ( userIdxCursor != null )\n        {\n            /*\n             * No need to do the same check that is done in next() since\n             * values are decreasing with calls to previous().  We will\n             * always have lesser values.\n             */\n            return setAvailable( userIdxCursor.previous() );\n        }\n        while ( uuidIdxCursor.previous() )\n        {\n            checkNotClosed();\n            uuidCandidate = uuidIdxCursor.get();\n            if ( lessEqEvaluator.evaluate( partitionTxn, uuidCandidate ) )\n            {\n                return setAvailable( true );\n            }\n            else\n            {\n                uuidCandidate = null;\n            }\n        }\n        return setAvailable( false );\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean next() throws LdapException, CursorException\n    {\n        checkNotClosed();\n        if ( userIdxCursor != null )\n        {\n            /*\n             * We have to check and make sure the next value complies by\n             * being less than or eq to the expression node's value.  We need\n             * to do this since values are increasing and we must limit to our\n             * upper bound.\n             */\n            while ( userIdxCursor.next() )\n            {\n                checkNotClosed();\n                IndexEntry<?, String> candidate = userIdxCursor.get();\n                if ( lessEqEvaluator.getComparator().compare( candidate.getKey(),\n                    lessEqEvaluator.getExpression().getValue().getString() ) <= 0 )\n                {\n                    return setAvailable( true );\n                }\n            }\n            return setAvailable( false );\n        }\n        while ( uuidIdxCursor.next() )\n        {\n            checkNotClosed();\n            uuidCandidate = uuidIdxCursor.get();\n            if ( lessEqEvaluator.evaluate( partitionTxn, uuidCandidate ) )\n            {\n                return setAvailable( true );\n            }\n            else\n            {\n                uuidCandidate = null;\n            }\n        }\n        return setAvailable( false );\n    }\n    /**\n     * {@inheritDoc}\n     */\n    public IndexEntry<V, String> get() throws CursorException\n    {\n        checkNotClosed();\n        if ( userIdxCursor != null )\n        {\n            if ( available() )\n            {\n                return userIdxCursor.get();\n            }\n            throw new InvalidCursorPositionException( I18n.err( I18n.ERR_708 ) );\n        }\n        if ( available() )\n        {\n            return ( IndexEntry<V, String> ) uuidCandidate;\n        }\n        throw new InvalidCursorPositionException( I18n.err( I18n.ERR_708 ) );\n    }\n    /**\n     * {@inheritDoc}\n     */\n<fim_suffix>    @Override\n    public void close() throws IOException\n    {\n        if ( IS_DEBUG )\n        {\n            LOG_CURSOR.debug( \"Closing LessEqCursor {}\", this );\n        }\n        super.close();\n        if ( userIdxCursor != null )\n        {\n            userIdxCursor.close();\n        }\n        else\n        {\n            uuidIdxCursor.close();\n            uuidCandidate = null;\n        }\n    }<fim_middle>// function below has no smell\n"}