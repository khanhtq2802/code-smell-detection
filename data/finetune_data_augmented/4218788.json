{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.cassandra.audit;\nimport java.nio.ByteBuffer;\nimport java.util.ArrayList;\nimport java.util.List;\nimport javax.annotation.Nullable;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Preconditions;\nimport com.google.common.primitives.Ints;\nimport io.netty.buffer.ByteBuf;\nimport net.openhft.chronicle.bytes.BytesStore;\nimport net.openhft.chronicle.wire.ValueOut;\nimport net.openhft.chronicle.wire.WireOut;\nimport org.apache.cassandra.cql3.QueryOptions;\nimport org.apache.cassandra.cql3.statements.BatchStatement;\nimport org.apache.cassandra.service.QueryState;\nimport org.apache.cassandra.transport.CBUtil;\nimport org.apache.cassandra.utils.ObjectSizes;\nimport org.apache.cassandra.utils.binlog.BinLog;\nimport org.apache.cassandra.utils.concurrent.WeightedQueue;\nimport org.github.jamm.MemoryLayoutSpecification;\n/**\n * A logger that logs entire query contents after the query finishes (or times out).\n */\npublic class FullQueryLogger extends BinLogAuditLogger implements IAuditLogger\n{\n    public static final long CURRENT_VERSION = 0; // encode a dummy version, to prevent pain in decoding in the future\n    public static final String VERSION = \"version\";\n    public static final String TYPE = \"type\";\n    public static final String PROTOCOL_VERSION = \"protocol-version\";\n    public static final String QUERY_OPTIONS = \"query-options\";\n    public static final String QUERY_START_TIME = \"query-start-time\";\n    public static final String GENERATED_TIMESTAMP = \"generated-timestamp\";\n    public static final String GENERATED_NOW_IN_SECONDS = \"generated-now-in-seconds\";\n    public static final String KEYSPACE = \"keyspace\";\n    public static final String BATCH = \"batch\";\n    public static final String SINGLE_QUERY = \"single-query\";\n    public static final String QUERY = \"query\";\n    public static final String BATCH_TYPE = \"batch-type\";\n    public static final String QUERIES = \"queries\";\n    public static final String VALUES = \"values\";\n    private static final int EMPTY_BYTEBUFFER_SIZE = Ints.checkedCast(ObjectSizes.sizeOnHeapExcludingData(ByteBuffer.allocate(0)));\n    private static final int EMPTY_LIST_SIZE = Ints.checkedCast(ObjectSizes.measureDeep(new ArrayList(0)));\n    private static final int EMPTY_BYTEBUF_SIZE;\n    private static final int OBJECT_HEADER_SIZE = MemoryLayoutSpecification.SPEC.getObjectHeaderSize();\n    private static final int OBJECT_REFERENCE_SIZE = MemoryLayoutSpecification.SPEC.getReferenceSize();\n    static\n    {\n        ByteBuf buf = CBUtil.allocator.buffer(0, 0);\n        try\n        {\n            EMPTY_BYTEBUF_SIZE = Ints.checkedCast(ObjectSizes.measure(buf));\n        }\n        finally\n        {\n            buf.release();\n        }\n    }\n    @Override\n    public void log(AuditLogEntry entry)\n    {\n        logQuery(entry.getOperation(), entry.getOptions(), entry.getState(), entry.getTimestamp());\n    }\n    /**\n     * Log an invocation of a batch of queries\n     * @param type The type of the batch\n     * @param queries CQL text of the queries\n     * @param values Values to bind to as parameters for the queries\n     * @param queryOptions Options associated with the query invocation\n     * @param queryState Timestamp state associated with the query invocation\n     * @param batchTimeMillis Approximate time in milliseconds since the epoch since the batch was invoked\n     */\n    void logBatch(BatchStatement.Type type,\n                  List<String> queries,\n                  List<List<ByteBuffer>> values,\n                  QueryOptions queryOptions,\n                  QueryState queryState,\n                  long batchTimeMillis)\n    {\n        Preconditions.checkNotNull(type, \"type was null\");\n        Preconditions.checkNotNull(queries, \"queries was null\");\n        Preconditions.checkNotNull(values, \"value was null\");\n        Preconditions.checkNotNull(queryOptions, \"queryOptions was null\");\n        Preconditions.checkNotNull(queryState, \"queryState was null\");\n        Preconditions.checkArgument(batchTimeMillis > 0, \"batchTimeMillis must be > 0\");\n        //Don't construct the wrapper if the log is disabled\n        BinLog binLog = this.binLog;\n        if (binLog == null)\n        {\n            return;\n        }\n        Batch wrappedBatch = new Batch(type, queries, values, queryOptions, queryState, batchTimeMillis);\n        logRecord(wrappedBatch, binLog);\n    }\n    /**\n     * Log a single CQL query\n     * @param query CQL query text\n     * @param queryOptions Options associated with the query invocation\n     * @param queryState Timestamp state associated with the query invocation\n     * @param queryTimeMillis Approximate time in milliseconds since the epoch since the batch was invoked\n     */\n    void logQuery(String query, QueryOptions queryOptions, QueryState queryState, long queryTimeMillis)\n    {\n        Preconditions.checkNotNull(query, \"query was null\");\n        Preconditions.checkNotNull(queryOptions, \"queryOptions was null\");\n        Preconditions.checkNotNull(queryState, \"queryState was null\");\n        Preconditions.checkArgument(queryTimeMillis > 0, \"queryTimeMillis must be > 0\");\n        //Don't construct the wrapper if the log is disabled\n        BinLog binLog = this.binLog;\n        if (binLog == null)\n        {\n            return;\n        }\n        Query wrappedQuery = new Query(query, queryOptions, queryState, queryTimeMillis);\n        logRecord(wrappedQuery, binLog);\n    }\n<fim_suffix>    public static class Query extends AbstractLogEntry\n    {\n        private final String query;\n        public Query(String query, QueryOptions queryOptions, QueryState queryState, long queryStartTime)\n        {\n            super(queryOptions, queryState, queryStartTime);\n            this.query = query;\n        }\n        @Override\n        protected String type()\n        {\n            return SINGLE_QUERY;\n        }\n        @Override\n        public void writeMarshallable(WireOut wire)\n        {\n            super.writeMarshallable(wire);\n            wire.write(QUERY).text(query);\n        }\n        @Override\n        public int weight()\n        {\n            return Ints.checkedCast(ObjectSizes.sizeOf(query)) + super.weight();\n        }\n    }\n    public static class Batch extends AbstractLogEntry\n    {\n        private final int weight;\n        private final BatchStatement.Type batchType;\n        private final List<String> queries;\n        private final List<List<ByteBuffer>> values;\n        public Batch(BatchStatement.Type batchType,\n                     List<String> queries,\n                     List<List<ByteBuffer>> values,\n                     QueryOptions queryOptions,\n                     QueryState queryState,\n                     long batchTimeMillis)\n        {\n            super(queryOptions, queryState, batchTimeMillis);\n            this.queries = queries;\n            this.values = values;\n            this.batchType = batchType;\n            int weight = super.weight();\n            // weight, queries, values, batch type\n            weight += 4 +                    // cached weight\n                      2 * EMPTY_LIST_SIZE +  // queries + values lists\n                      OBJECT_REFERENCE_SIZE; // batchType reference, worst case\n            for (String query : queries)\n                weight += ObjectSizes.sizeOf(query);\n            for (List<ByteBuffer> subValues : values)\n            {\n                weight += EMPTY_LIST_SIZE;\n                for (ByteBuffer value : subValues)\n                    weight += EMPTY_BYTEBUFFER_SIZE + value.capacity();\n            }\n            this.weight = weight;\n        }\n        @Override\n        protected String type()\n        {\n            return BATCH;\n        }\n        @Override\n        public void writeMarshallable(WireOut wire)\n        {\n            super.writeMarshallable(wire);\n            wire.write(BATCH_TYPE).text(batchType.name());\n            ValueOut valueOut = wire.write(QUERIES);\n            valueOut.int32(queries.size());\n            for (String query : queries)\n            {\n                valueOut.text(query);\n            }\n            valueOut = wire.write(VALUES);\n            valueOut.int32(values.size());\n            for (List<ByteBuffer> subValues : values)\n            {\n                valueOut.int32(subValues.size());\n                for (ByteBuffer value : subValues)\n                {\n                    valueOut.bytes(BytesStore.wrap(value));\n                }\n            }\n        }\n        @Override<fim_middle>// class below has no smell\n"}