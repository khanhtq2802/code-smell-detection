{"text": "<fim_prefix>/*\n * Copyright 2013-2019 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.integration.support.json;\n\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.lang.reflect.Type;\nimport java.util.Collection;\nimport java.util.Map;\n\nimport org.springframework.core.ResolvableType;\nimport org.springframework.core.convert.TypeDescriptor;\nimport org.springframework.integration.mapping.support.JsonHeaders;\nimport org.springframework.lang.Nullable;\n\n/**\n * Strategy interface to convert an Object to/from the JSON representation.\n *\n * @param <N> - The expected type of JSON Node.\n * @param <P> - The expected type of JSON Parser.\n *\n * @author Artem Bilan\n *\n * @since 3.0\n *\n */\n<fim_suffix>public interface JsonObjectMapper<N, P> {\n\n\tdefault String toJson(Object value) throws IOException {\n\t\treturn null;\n\t}\n\n\tdefault void toJson(Object value, Writer writer) throws IOException {\n\n\t}\n\n\tdefault N toJsonNode(Object value) throws IOException {\n\t\treturn null;\n\t}\n\n\tdefault <T> T fromJson(Object json, Class<T> valueType) throws IOException {\n\t\treturn null;\n\t}\n\n\t/**\n\t * Deserialize a JSON to an expected {@link ResolvableType}.\n\t * @param json the JSON to deserialize\n\t * @param valueType the {@link ResolvableType} for the target object.\n\t * @param <T> the expected object type\n\t * @return deserialization result object\n\t * @throws IOException a JSON parsing exception\n\t * @since 5.2\n\t */\n\tdefault <T> T fromJson(Object json, ResolvableType valueType) throws IOException {\n\t\treturn null;\n\t}\n\n\tdefault <T> T fromJson(Object json, Map<String, Object> javaTypes) throws IOException {\n\t\treturn null;\n\t}\n\n\tdefault <T> T fromJson(P parser, Type valueType) throws IOException {\n\t\treturn null;\n\t}\n\n\tdefault void populateJavaTypes(Map<String, Object> map, Object object) {\n\t\tClass<?> targetClass = object.getClass();\n\t\tClass<?> contentClass = null;\n\t\tClass<?> keyClass = null;\n\t\tmap.put(JsonHeaders.TYPE_ID, targetClass);\n\t\tif (object instanceof Collection && !((Collection<?>) object).isEmpty()) {\n\t\t\tObject firstElement = ((Collection<?>) object).iterator().next();\n\t\t\tif (firstElement != null) {\n\t\t\t\tcontentClass = firstElement.getClass();\n\t\t\t\tmap.put(JsonHeaders.CONTENT_TYPE_ID, contentClass);\n\t\t\t}\n\t\t}\n\t\tif (object instanceof Map && !((Map<?, ?>) object).isEmpty()) {\n\t\t\tObject firstValue = ((Map<?, ?>) object).values().iterator().next();\n\t\t\tif (firstValue != null) {\n\t\t\t\tcontentClass = firstValue.getClass();\n\t\t\t\tmap.put(JsonHeaders.CONTENT_TYPE_ID, contentClass);\n\t\t\t}\n\t\t\tObject firstKey = ((Map<?, ?>) object).keySet().iterator().next();\n\t\t\tif (firstKey != null) {\n\t\t\t\tkeyClass = firstKey.getClass();\n\t\t\t\tmap.put(JsonHeaders.KEY_TYPE_ID, keyClass);\n\t\t\t}\n\t\t}\n\n\n\t\tmap.put(JsonHeaders.RESOLVABLE_TYPE, buildResolvableType(targetClass, contentClass, keyClass));\n\t}\n\n\tstatic ResolvableType buildResolvableType(Class<?> targetClass, @Nullable Class<?> contentClass,\n\t\t\t@Nullable Class<?> keyClass) {\n\n\t\tif (keyClass != null) {\n\t\t\treturn TypeDescriptor\n\t\t\t\t\t.map(targetClass,\n\t\t\t\t\t\t\tTypeDescriptor.valueOf(keyClass),\n\t\t\t\t\t\t\tTypeDescriptor.valueOf(contentClass))\n\t\t\t\t\t.getResolvableType();\n\t\t}\n\t\telse if (contentClass != null) {\n\t\t\treturn TypeDescriptor\n\t\t\t\t\t.collection(targetClass,\n\t\t\t\t\t\t\tTypeDescriptor.valueOf(contentClass))\n\t\t\t\t\t.getResolvableType();\n\t\t}\n\t\telse {\n\t\t\treturn ResolvableType.forClass(targetClass);\n\t\t}\n\t}\n\n}<fim_middle>// class below is blob\n"}