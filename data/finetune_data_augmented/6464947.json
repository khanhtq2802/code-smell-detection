{"text": "<fim_prefix>            buf1 = new StringBuffer(100);\n            buf2 = new StringBuffer(100);\n            for (j=0;j<4;j++) {\n                for (k=0;k<4;k++) {\n                    if ((k+j*4+i*16) >= length) break;\n                    byte2hex(buffer[k+j*4+i*16],buf1);\n                    if ( (buffer[k+j*4+i*16]) > 40 && (buffer[k+j*4+i*16]) < 128) {\n                        buf2.append((char)buffer[k+j*4+i*16]);\n                    }\n                    else\n                    {\n                        buf2.append(\".\");\n                    }\n                }\n                buf1.append(\" \");\n            }\n            Util.Debug.println(Util.formatAsHexString(i * 16) + \": \" + buf1 + \" \" + buf2);\n        }\n    }\n    /**\n     * Formats a number as a hex string, prefixing the \"0x\"\n     * radix specifier so that it can be unambiguously\n     * interpreted as a hex string.\n     * @param number the number to format\n     */\n    final static public String formatAsHexString(long number)\n    {\n        return \"0x\" + Long.toHexString(number);\n    }\n    /**\n     * Converts a byte to hex digit and writes to the supplied buffer\n     */\n    private static void byte2hex(byte b, StringBuffer buf) {\n        char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8',\n                        '9', 'A', 'B', 'C', 'D', 'E', 'F' };\n        int high = ((b & 0xf0) >> 4);\n        int low = (b & 0x0f);\n        buf.append(hexChars[high]);\n        buf.append(hexChars[low]);\n    }\n    final static String getFormattedTime(BigInteger time)\n    {\n        //Util.Debug.println(\"formatting time    \" + time);\n        //Util.Debug.println(\"Util: timerType    \" + timerType);\n        switch (timerType) {\n        case 2:\n        case 4:\n        case 5:\n        case 7:\n        {\n            /*\n             *  X86 with RDTSC, MFTB, MSPR, J9\n             */\n            if (TraceFormat.verMod >= 1.1) {\n                BigInteger splitTime[];\n                BigInteger nanos;\n                BigInteger secondsMillis[];\n                BigInteger minutesSeconds[];\n                BigInteger hoursMinutes[];\n                BigInteger daysHours[];\n                time = time.subtract(TraceFormat.overallStartPlatform);\n                splitTime = time.divideAndRemainder(TraceFormat.timeConversion);\n                secondsMillis = splitTime[0].add(TraceFormat.overallStartSystem).divideAndRemainder(MILLIS2SECONDS);\n                nanos = secondsMillis[1].multiply(MILLION).add(splitTime[1].multiply(MILLION).divide(TraceFormat.timeConversion));\n                minutesSeconds = secondsMillis[0].divideAndRemainder(SECONDS2MINUTES);\n                hoursMinutes = minutesSeconds[0].divideAndRemainder(MINUTES2HOURS);\n                daysHours = hoursMinutes[0].divideAndRemainder(HOURS2DAYS);\n                daysHours[1] = daysHours[1].add(TraceArgs.timeZoneOffset); /* allow user to modify timezone */\n                try{\n                    return \"00\".substring(daysHours[1].toString().length()) + daysHours[1].toString() + \":\" +\n                           \"00\".substring(hoursMinutes[1].toString().length()) + hoursMinutes[1].toString() + \":\" +\n                           \"00\".substring(minutesSeconds[1].toString().length()) + minutesSeconds[1].toString() + \".\" +\n                           \"000000000\".substring(nanos.toString().length()) + nanos.toString();\n                } catch(Exception e) {\n                    Debug.println(daysHours[1].toString() + \":\" +\n                                  hoursMinutes[1].toString() + \":\" +\n                                  minutesSeconds[1].toString() + \".\" +\n                                  nanos.toString());\n                    return \"Bad Time: \" + time.toString(16);\n                }\n            } else {\n                return \"0000000000000000\".substring(time.toString(16).length()) + time.toString(16);\n            }\n        }\n        case 3:\n        {\n            /*\n             *  Power/Power PC\n             */\n            long   seconds;\n            long   nanos;\n            long   ss;\n            long   mm;\n            long   hh;\n            seconds = time.shiftRight(32).longValue() & 0xffffffffL;\n            nanos = time.longValue() &  0xffffffffL;\n            ss = seconds % 60;\n            mm = (seconds / 60) % 60;\n            hh = (seconds / 3600) % 24;\n            try{\n                return \"00\".substring(Long.toString(hh).length()) + Long.toString(hh) + \":\" +\n                       \"00\".substring(Long.toString(mm).length()) + Long.toString(mm) + \":\" +\n                       \"00\".substring(Long.toString(ss).length()) + Long.toString(ss) + \".\" +\n                       \"000000000\".substring(Long.toString(nanos).length()) + Long.toString(nanos);\n            } catch(Exception e) {\n                Debug.println(\"hh: \" + Long.toString(hh) + \" mm: \" +\n                              Long.toString(mm) + \" ss: \" +\n                              Long.toString(ss) + \" Nanos: \" +\n                              Long.toString(nanos));\n                return \"Bad Time: \" + time.toString(16);\n            }\n        }\n        case 6:\n        {\n            /*\n             *  System/390\n             */\n            long picos;\n            long micros;\n            long ss;\n            long mm;\n            long hh;\n            micros = time.shiftRight(12).longValue() & 0xfffffffffffffL;\n            ss = (micros / 1000000) % 60;\n            mm = (micros / 60000000) % 60;\n            hh = (micros / 3600000000L) % 24;\n            micros = micros % 1000000;\n            picos = (((time.longValue() &  0xfffL) | (micros << 12)) * 244140625) / 1000000;\n            try{\n                return \"00\".substring(Long.toString(hh).length()) + Long.toString(hh) + \":\" +\n                       \"00\".substring(Long.toString(mm).length()) + Long.toString(mm) + \":\" +\n                       \"00\".substring(Long.toString(ss).length()) + Long.toString(ss) + \".\" +\n                       \"000000000000\".substring(Long.toString(picos).length()) + Long.toString(picos);\n            } catch(Exception e) {\n                Debug.println(\"hh: \" + Long.toString(hh) + \" mm: \" +\n                              Long.toString(mm) + \" ss: \" +\n                              Long.toString(ss) + \" Picos: \" +\n                              Long.toString(picos));\n                return \"Bad Time: \" + time.toString(16);\n            }\n        }\n        default:\n        {\n            return \"0000000000000000\".substring(time.toString(16).length()) + time.toString(16);\n        }\n        }\n    }\n    static class Debug {\n        static java.io.PrintStream out = TraceFormat.outStream;\n        static void println(Object o)\n        {\n            if ( TraceArgs.debug ) {\n                out.println(o);\n            }\n        }\n        static void print(Object o)\n        {\n            if ( TraceArgs.debug ) {\n                out.print(o);\n            }\n        }\n    }\n    /** keeps track of the types to format for a given component\n     *\n     * @author Jonathon Lee\n     * @version 1.0, Date: 7/7/1999\n     */\n<fim_suffix>    final static class TypeList {\n        Hashtable types;\n        TypeList()\n        {\n        }\n        TypeList(Vector typeNames)\n        {\n            types = new Hashtable();\n            for ( int i = 0; i < typeNames.size(); i++ ) {\n                String t = ((String) typeNames.elementAt(i)).toLowerCase();\n                types.put(t, t);\n            }\n        }\n        final boolean contains(String type)\n        {\n            if ( types == null ) {\n                return true; //defaults to all\n            }\n            return types.containsKey(type);\n        }\n    }<fim_middle>// class below has no smell\n"}