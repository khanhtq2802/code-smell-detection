{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.jena.graph;\n\nimport org.apache.jena.graph.impl.GraphBase ;\nimport org.apache.jena.shared.AddDeniedException ;\nimport org.apache.jena.shared.DeleteDeniedException ;\nimport org.apache.jena.shared.PrefixMapping ;\nimport org.apache.jena.util.iterator.ExtendedIterator ;\nimport org.apache.jena.util.iterator.NullIterator ;\n\n/**\n    The interface to be satisfied by implementations maintaining collections\n    of RDF triples. The core interface is small (add, delete, find, contains) and\n    is augmented by additional classes to handle more complicated matters\n    such as event management.\n    @see GraphBase for an implementation framework.\n*/\n<fim_suffix>public interface Graph\n    {\n    /**\n        An immutable empty graph. \n    */\n    public static final Graph emptyGraph = new GraphBase()\n        { @Override\n        public ExtendedIterator<Triple> graphBaseFind( Triple tm ) { return NullIterator.instance(); } };\n    \t\n    /** \n        true if this graph's content depends on the other graph. May be\n        pessimistic (ie return true if it's not sure). Typically true when a\n        graph is a composition of other graphs, eg union.\n        \n         @param other the graph this graph may depend on\n         @return false if this does not depend on other \n    */\n    boolean dependsOn( Graph other );\n    \n    /** returns this Graph's transaction handler */\n    TransactionHandler getTransactionHandler();\n    \n    /** returns this Graph's capabilities */\n    Capabilities getCapabilities();\n    \n    /**\n        Answer this Graph's event manager.\n    */\n    GraphEventManager getEventManager(); \n   \n    /**\n        Answer this Graph's statistics handler, or null if there isn't one. Every\n        call to this method on a particular graph delivers the same (==) answer.\n    */\n    GraphStatisticsHandler getStatisticsHandler();\n    \n    /**\n        returns this Graph's prefix mapping. Each call on a given Graph gets the\n        same PrefixMapping object, which is the one used by the Graph.\n    */\n    PrefixMapping getPrefixMapping();\n\n    /** \n        Add the triple t (if possible) to the set belonging to this graph \n        @param t the triple to add to the graph\n        @throws AddDeniedException if the triple cannot be added \n     */\n    void add( Triple t ) throws AddDeniedException;\n\n    /** \n        Delete the triple t (if possible) from the set belonging to this graph \n    \n        @param  t the triple to delete to the graph\n        @throws DeleteDeniedException if the triple cannot be removed  \n    */   \n\tvoid delete(Triple t) throws DeleteDeniedException;\n      \n\t/** \n        Returns an iterator over all the Triples that match the triple pattern.\n   \n        @param m a Triple encoding the pattern to look for\n        @return an iterator of all triples in this graph that match m\n\t */\n\tExtendedIterator<Triple> find(Triple m);\n\n\t/** Returns an iterator over Triples matching a pattern.\n     * \n     * @return an iterator of all triples in this graph\n\t */\n\tExtendedIterator<Triple> find(Node s, Node p, Node o);\n    \n    /** Returns an iterator over all Triples in the graph.\n     * Equivalent to {@code find(Node.ANY, Node.ANY, Node.ANY)}\n     * \n     * @return an iterator of all triples in this graph\n     */\n    default ExtendedIterator<Triple> find() { return find(Node.ANY, Node.ANY, Node.ANY); }\n\n    /**\n\t * Compare this graph with another using the method\n\t * described in \n\t * <a href=\"http://www.w3.org/TR/rdf-concepts#section-Graph-syntax\">\n     * http://www.w3.org/TR/rdf-concepts#section-Graph-syntax\n     * </a>\n\t * @param g Compare against this.\n\t * @return boolean True if the two graphs are isomorphic.\n\t */\n\tboolean isIsomorphicWith(Graph g);\n    \n    /** \n        Answer true iff the graph contains a triple matching (s, p, o).\n        s/p/o may be concrete or fluid. Equivalent to find(s,p,o).hasNext,\n        but an implementation is expected to optimise this in easy cases.\n    */\n    boolean contains( Node s, Node p, Node o );\n    \n    /** \n        Answer true iff the graph contains a triple that t matches; t may be\n        fluid.\n    */\n    boolean contains( Triple t );\n    \n    /**\n        Remove all the statements from this graph.\n    */\n    void clear();\n    \n    /**\n       Remove all triples that match by find(s, p, o)\n    */\n    void remove( Node s, Node p, Node o );\n    \n\t/** Free all resources, any further use of this Graph is an error.\n\t */\n\tvoid close();\n    \n    /**\n        Answer true iff this graph is empty. \"Empty\" means \"has as few triples as it\n        can manage\", because an inference graph may have irremovable axioms\n        and their consequences.\n    */\n    boolean isEmpty();\n    \n    /**\n     * For a concrete graph this returns the number of triples in the graph. For graphs which\n     * might infer additional triples it results an estimated lower bound of the number of triples.\n     * For example, an inference graph might return the number of triples in the raw data graph. \n     */\n\t int size();\n\n    /**\n        Answer true iff .close() has been called on this Graph.\n    */\n    boolean isClosed();\n    }<fim_middle>// class below has no smell\n"}