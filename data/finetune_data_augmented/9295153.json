{"text": "<fim_prefix>        return resolve(tag,\n                binaryOperators,\n                binop -> binop.test(op1, op2),\n                binop -> binop.resolve(op1, op2),\n                () -> reportErrorIfNeeded(pos, tag, op1, op2));\n    }\n    /**\n     * Main operator lookup routine; lookup an operator (either unary or binary) in its corresponding\n     * map. If there's a matching operator, its resolve routine is called and the result is returned;\n     * otherwise the result of a fallback function is returned.\n     */\n    private <O> OperatorSymbol resolve(Tag tag, Map<Name, List<O>> opMap, Predicate<O> opTestFunc,\n                       Function<O, OperatorSymbol> resolveFunc, Supplier<OperatorSymbol> noResultFunc) {\n        return opMap.get(operatorName(tag)).stream()\n                .filter(opTestFunc)\n                .map(resolveFunc)\n                .findFirst()\n                .orElseGet(noResultFunc);\n    }\n    /**\n     * Creates an operator symbol.\n     */\n    private OperatorSymbol makeOperator(Name name, List<OperatorType> formals, OperatorType res, int... opcodes) {\n        MethodType opType = new MethodType(\n                formals.stream()\n                        .map(o -> o.asType(syms))\n                        .collect(List.collector()),\n                res.asType(syms), List.nil(), syms.methodClass);\n        return new OperatorSymbol(name, opType, mergeOpcodes(opcodes), syms.noSymbol);\n    }\n    /**\n     * Fold two opcodes in a single int value (if required).\n     */\n    private int mergeOpcodes(int... opcodes) {\n        int opcodesLen = opcodes.length;\n        Assert.check(opcodesLen == 1 || opcodesLen == 2);\n        return (opcodesLen == 1) ?\n                opcodes[0] :\n                ((opcodes[0] << ByteCodes.preShift) | opcodes[1]);\n    }\n    /** A symbol that stands for a missing operator.\n     */\n    public final OperatorSymbol noOpSymbol;\n    /**\n     * Report an operator lookup error.\n     */\n    private OperatorSymbol reportErrorIfNeeded(DiagnosticPosition pos, Tag tag, Type... args) {\n        if (Stream.of(args).noneMatch(t -> t.isErroneous() || t.hasTag(TypeTag.NONE))) {\n            Name opName = operatorName(tag);\n            JCDiagnostic.Error opError = (args.length) == 1 ?\n                    Errors.OperatorCantBeApplied(opName, args[0]) :\n                    Errors.OperatorCantBeApplied1(opName, args[0], args[1]);\n            log.error(pos, opError);\n        }\n        return noOpSymbol;\n    }\n    /**\n     * Return name of operator with given tree tag.\n     */\n    public Name operatorName(JCTree.Tag tag) {\n        return opname[tag.operatorIndex()];\n    }\n    /**\n     * The constants in this enum represent the types upon which all the operator helpers\n     * operate upon. This allows lazy and consise mapping between a type name and a type instance.\n     */\n    enum OperatorType {\n        BYTE(syms -> syms.byteType),\n        SHORT(syms -> syms.shortType),\n        INT(syms -> syms.intType),\n        LONG(syms -> syms.longType),\n        FLOAT(syms -> syms.floatType),\n        DOUBLE(syms -> syms.doubleType),\n        CHAR(syms -> syms.charType),\n        BOOLEAN(syms -> syms.booleanType),\n        OBJECT(syms -> syms.objectType),\n        STRING(syms -> syms.stringType),\n        BOT(syms -> syms.botType);\n        final Function<Symtab, Type> asTypeFunc;\n        OperatorType(Function<Symtab, Type> asTypeFunc) {\n            this.asTypeFunc = asTypeFunc;\n        }\n        Type asType(Symtab syms) {\n            return asTypeFunc.apply(syms);\n        }\n    }\n    /**\n     * Common root for all operator helpers. An operator helper instance is associated with a\n     * given operator (i.e. '+'); it contains routines to perform operator lookup, i.e. find\n     * which version of the '+' operator is the best given an argument type list. Supported\n     * operator symbols are initialized lazily upon first lookup request - this is in order to avoid\n     * initialization circularities between this class and {@code Symtab}.\n     */\n    abstract class OperatorHelper {\n        /** The operator name. */\n        final Name name;\n        /** The list of symbols associated with this operator (lazily populated). */\n        Optional<OperatorSymbol[]> alternatives = Optional.empty();\n        /** An array of operator symbol suppliers (used to lazily populate the symbol list). */\n        List<Supplier<OperatorSymbol>> operatorSuppliers = List.nil();\n        @SuppressWarnings(\"varargs\")\n        OperatorHelper(Tag tag) {\n            this.name = operatorName(tag);\n        }\n        /**\n         * This routine implements the main operator lookup process. Each operator is tested\n         * using an applicability predicate; if the test suceeds that same operator is returned,\n         * otherwise a dummy symbol is returned.\n         */\n        final OperatorSymbol doLookup(Predicate<OperatorSymbol> applicabilityTest) {\n            return Stream.of(alternatives.orElseGet(this::initOperators))\n                    .filter(applicabilityTest)\n                    .findFirst()\n                    .orElse(noOpSymbol);\n        }\n        /**\n         * This routine performs lazy instantiation of the operator symbols supported by this helper.\n         * After initialization is done, the suppliers are cleared, to free up memory.\n         */\n        private OperatorSymbol[] initOperators() {\n            OperatorSymbol[] operators = operatorSuppliers.stream()\n                    .map(Supplier::get)\n                    .toArray(OperatorSymbol[]::new);\n            alternatives = Optional.of(operators);\n            operatorSuppliers = null; //let GC do its work\n            return operators;\n        }\n    }\n    /**\n     * Common superclass for all unary operator helpers.\n     */\n    abstract class UnaryOperatorHelper extends OperatorHelper implements Predicate<Type> {\n        UnaryOperatorHelper(Tag tag) {\n            super(tag);\n        }\n        /**\n         * This routine implements the unary operator lookup process. It customizes the behavior\n         * of the shared lookup routine in {@link OperatorHelper}, by using an unary applicability test\n         * (see {@link UnaryOperatorHelper#isUnaryOperatorApplicable(OperatorOperatorSymbol, Type)}\n         */\n        final OperatorSymbol doLookup(Type t) {\n            return doLookup(op -> isUnaryOperatorApplicable(op, t));\n        }\n        /**\n         * Unary operator applicability test - is the input type the same as the expected operand type?\n         */\n        boolean isUnaryOperatorApplicable(OperatorSymbol op, Type t) {\n            return types.isSameType(op.type.getParameterTypes().head, t);\n        }\n        /**\n         * Adds a unary operator symbol.\n         */\n        final UnaryOperatorHelper addUnaryOperator(OperatorType arg, OperatorType res, int... opcode) {\n            operatorSuppliers = operatorSuppliers.prepend(() -> makeOperator(name, List.of(arg), res, opcode));\n            return this;\n        }\n        /**\n         * This method will be overridden by unary operator helpers to provide custom resolution\n         * logic.\n         */\n        abstract OperatorSymbol resolve(Type t);\n    }\n<fim_suffix>    abstract class BinaryOperatorHelper extends OperatorHelper implements BiPredicate<Type, Type> {\n        BinaryOperatorHelper(Tag tag) {\n            super(tag);\n        }\n        /**\n         * This routine implements the binary operator lookup process. It customizes the behavior\n         * of the shared lookup routine in {@link OperatorHelper}, by using an unary applicability test\n         * (see {@link BinaryOperatorHelper#isBinaryOperatorApplicable(OperatorSymbol, Type, Type)}\n         */\n        final OperatorSymbol doLookup(Type t1, Type t2) {\n            return doLookup(op -> isBinaryOperatorApplicable(op, t1, t2));\n        }\n        /**\n         * Binary operator applicability test - are the input types the same as the expected operand types?\n         */\n        boolean isBinaryOperatorApplicable(OperatorSymbol op, Type t1, Type t2) {\n            List<Type> formals = op.type.getParameterTypes();\n            return types.isSameType(formals.head, t1) &&\n                    types.isSameType(formals.tail.head, t2);\n        }\n        /**\n         * Adds a binary operator symbol.\n         */\n        final BinaryOperatorHelper addBinaryOperator(OperatorType arg1, OperatorType arg2, OperatorType res, int... opcode) {\n            operatorSuppliers = operatorSuppliers.prepend(() -> makeOperator(name, List.of(arg1, arg2), res, opcode));\n            return this;\n        }\n        /**\n         * This method will be overridden by binary operator helpers to provide custom resolution\n         * logic.\n         */\n        abstract OperatorSymbol resolve(Type t1, Type t2);\n    }<fim_middle>// class below has no smell\n"}