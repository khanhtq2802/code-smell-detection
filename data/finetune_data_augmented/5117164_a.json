{"text": "<fim_prefix>/* $Id$ */\n/**\n* Licensed to the Apache Software Foundation (ASF) under one or more\n* contributor license agreements. See the NOTICE file distributed with\n* this work for additional information regarding copyright ownership.\n* The ASF licenses this file to You under the Apache License, Version 2.0\n* (the \"License\"); you may not use this file except in compliance with\n* the License. You may obtain a copy of the License at\n*\n* http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\npackage org.apache.manifoldcf.agents.system;\nimport org.apache.manifoldcf.core.interfaces.*;\nimport org.apache.manifoldcf.agents.interfaces.*;\nimport java.io.*;\nimport java.util.*;\npublic class AgentsDaemon\n{\n  public static final String _rcsid = \"@(#)$Id$\";\n  /** Agent shutdown signal name */\n  public static final String agentShutdownSignal = \"_AGENTRUN_\";\n  /** Agent service name prefix (followed by agent class name) */\n  public static final String agentServicePrefix = \"AGENT_\";\n  /** The agents thread, which starts and stops agents daemons to keep them consistent with the database, and\n  * also takes on process cleanup where necessary. */\n  protected AgentsThread agentsThread = null;\n  /** The idle cleanup thread. */\n  protected IdleCleanupThread idleCleanupThread = null;\n  /** Process ID for this agents daemon. */\n  protected final String processID;\n  /** This is the place we keep track of the agents we've started. */\n  protected final Map<String,IAgent> runningHash = new HashMap<String,IAgent>();\n  // There are a number of different ways of running the agents framework.\n  // (1) Repeatedly call checkAgents(), and when all done make sure to call stopAgents().\n  // (2) Call registerAgentsShutdownHook(), then repeatedly run checkAgents(),  Agent shutdown happens on JVM exit.\n  // (3) Call runAgents(), which will wait for someone else to call assertAgentsShutdownSignal().  Before exit, stopAgents() must be called.\n  // (4) Call registerAgentsShutdownHook(), then call runAgents(), which will wait for someone else to call assertAgentsShutdownSignal().  Shutdown happens on JVM exit.\n  /** Create an agents daemon object.\n  *@param processID is the process ID of this agents daemon.  Process ID's must be unique\n  * for all agents daemons.\n  */\n  public AgentsDaemon(String processID)\n  {\n    this.processID = processID;\n  }\n  /** Assert shutdown signal for the current agents daemon.\n  */\n  public static void assertAgentsShutdownSignal(IThreadContext threadContext)\n    throws ManifoldCFException\n  {\n    ILockManager lockManager = LockManagerFactory.make(threadContext);\n    lockManager.setGlobalFlag(agentShutdownSignal);\n  }\n  /** Clear shutdown signal for the current agents daemon.\n  */\n  public static void clearAgentsShutdownSignal(IThreadContext threadContext)\n    throws ManifoldCFException\n  {\n    ILockManager lockManager = LockManagerFactory.make(threadContext);\n    lockManager.clearGlobalFlag(agentShutdownSignal);\n  }\n  /** Register agents shutdown hook.\n  * Call this ONCE before calling startAgents or checkAgents the first time, if you want automatic cleanup of agents on JVM stop.\n  */\n  public void registerAgentsShutdownHook(IThreadContext threadContext)\n    throws ManifoldCFException\n  {\n    // Create the shutdown hook for agents.  All activity will be keyed off of runningHash, so it is safe to do this under all conditions.\n    org.apache.manifoldcf.core.system.ManifoldCF.addShutdownHook(new AgentsShutdownHook());\n  }\n  /** Run agents process.\n  * This method will not return until a shutdown signal is sent.\n  */\n  public void runAgents(IThreadContext threadContext)\n    throws ManifoldCFException\n  {\n    ILockManager lockManager = LockManagerFactory.make(threadContext);\n    // Don't come up at all if shutdown signal in force\n    if (lockManager.checkGlobalFlag(agentShutdownSignal))\n      return;\n    // Create and start agents thread.\n    startAgents(threadContext);\n    while (true)\n    {\n      // Any shutdown signal yet?\n      if (lockManager.checkGlobalFlag(agentShutdownSignal))\n        break;\n      try\n      {\n        ManifoldCF.sleep(5000L);\n      }\n      catch (InterruptedException e)\n      {\n        break;\n      }\n    }\n  }\n  /** Start agents thread for this agents daemon object.\n  */\n  public void startAgents(IThreadContext threadContext)\n    throws ManifoldCFException\n  {\n    // Create idle cleanup thread.\n    idleCleanupThread = new IdleCleanupThread(processID);\n    agentsThread = new AgentsThread();\n    // Create and start agents thread.\n    idleCleanupThread.start();\n    agentsThread.start();\n  }\n  /** Stop all started agents running under this agents daemon.\n  */\n  public void stopAgents(IThreadContext threadContext)\n    throws ManifoldCFException\n  {\n    // Shut down agents background thread.\n    while (agentsThread != null || idleCleanupThread != null)\n    {\n      if (agentsThread != null)\n        agentsThread.interrupt();\n      if (idleCleanupThread != null)\n        idleCleanupThread.interrupt();\n      if (agentsThread != null && !agentsThread.isAlive())\n        agentsThread = null;\n      if (idleCleanupThread != null && !idleCleanupThread.isAlive())\n        idleCleanupThread = null;\n    }\n    // Shut down running agents services directly.\n    ILockManager lockManager = LockManagerFactory.make(threadContext);\n    synchronized (runningHash)\n    {\n      // This is supposedly safe; iterator remove is used\n      Iterator<String> iter = runningHash.keySet().iterator();\n      while (iter.hasNext())\n      {\n        String className = iter.next();\n        IAgent agent = runningHash.get(className);\n        // Stop it\n        agent.stopAgent(threadContext);\n        lockManager.endServiceActivity(getAgentsClassServiceType(className), processID);\n        iter.remove();\n        agent.cleanUp(threadContext);\n      }\n    }\n    // Done.\n    OutputConnectorPoolFactory.make(threadContext).flushUnusedConnectors();\n    TransformationConnectorPoolFactory.make(threadContext).flushUnusedConnectors();\n  }\n  protected static String getAgentsClassServiceType(String agentClassName)\n  {\n    return agentServicePrefix + agentClassName;\n  }\n  /** Agents thread.  This runs in background until interrupted, at which point\n  * it shuts down.  Its responsibilities include cleaning up after dead processes,\n  * as well as starting newly-registered agent processes, and terminating ones that disappear.\n  */\n  protected class AgentsThread extends Thread\n  {\n    public AgentsThread()\n    {\n      super();\n      setName(\"Agents thread\");\n      setDaemon(true);\n    }\n<fim_suffix>    public void run()\n    {\n      try\n      {\n        IThreadContext threadContext = ThreadContextFactory.make();\n        while (true)\n        {\n          try\n          {\n            if (Thread.currentThread().isInterrupted())\n              throw new ManifoldCFException(\"Interrupted\",ManifoldCFException.INTERRUPTED);\n            checkAgents(threadContext);\n            ManifoldCF.sleep(5000L);\n          }\n          catch (InterruptedException e)\n          {\n            break;\n          }\n          catch (ManifoldCFException e)\n          {\n            if (e.getErrorCode() == ManifoldCFException.INTERRUPTED)\n              break;\n            if (e.getErrorCode() == ManifoldCFException.SETUP_ERROR)\n            {\n              System.err.println(\"Misconfigured ManifoldCF agents - shutting down\");\n              Logging.agents.fatal(\"AgentThread configuration exception tossed: \"+e.getMessage(),e);\n              System.exit(-200);\n            }\n            Logging.agents.error(\"Exception tossed: \"+e.getMessage(),e);\n          }\n          catch (OutOfMemoryError e)\n          {\n            System.err.println(\"Agents process ran out of memory - shutting down\");\n            e.printStackTrace(System.err);\n            System.exit(-200);\n          }\n          catch (Throwable e)\n          {\n            Logging.agents.fatal(\"Error tossed: \"+e.getMessage(),e);\n          }\n        }\n      }\n      catch (Throwable e)\n      {\n        // Severe error on initialization\n        System.err.println(\"Agents process could not start - shutting down\");\n        Logging.agents.fatal(\"AgentThread initialization error tossed: \"+e.getMessage(),e);\n        System.exit(-300);\n      }\n    }\n  }\n  /** Start all not-running agents.\n  *@param threadContext is the thread context.\n  */\n  protected void checkAgents(IThreadContext threadContext)\n    throws ManifoldCFException\n  {\n    ILockManager lockManager = LockManagerFactory.make(threadContext);\n    // Get agent manager\n    IAgentManager manager = AgentManagerFactory.make(threadContext);\n    synchronized (runningHash)\n    {\n      String[] classes = manager.getAllAgents();<fim_middle>// function below is feature envy and long method\n"}