{"text": "<fim_prefix>        Iterator it = swarmSet.iterator();\n        while (it.hasNext()) {\n          WeakReference ref = (WeakReference) it.next();\n          SystemTimer t2 = (SystemTimer) ref.get();\n          if (t2 == null) {\n            // Since we've discovered an empty reference, we should remove it.\n            it.remove();\n            continue;\n          }\n          if (t2 == t) {\n            it.remove();\n            // Don't keep sweeping once we've found it; just quit.\n            break;\n          }\n          if (t2.cancelled) {\n            // But if we happen to run across a cancelled timer,\n            // remove it.\n            it.remove();\n            continue;\n          }\n        } // while\n        // While we're here, if the swarm has gone to zero size,\n        // we should remove it.\n        if (swarmSet.size() == 0) {\n          allSwarms.remove(t.swarm); // last reference\n          if (isDebugEnabled) {\n            logger.trace(\"SystemTimer#removeFromSwarm: removed last reference to {}\", t.swarm);\n          }\n        }\n      } // synchronized swarmSet\n    } // synchronized allSwarms\n    sweepAllSwarms(); // Occasionally check global list, use any available logger :-)\n  }\n  /**\n   * Cancel all outstanding timers\n   *\n   * @param swarm the swarm to cancel\n   */\n  public static void cancelSwarm(Object /* T */ swarm) {\n    Assert.assertTrue(swarm instanceof InternalDistributedSystem); // TODO\n    // Find the swarmSet and remove it\n    ArrayList swarmSet;\n    synchronized (allSwarms) {\n      swarmSet = (ArrayList) allSwarms.get(swarm);\n      if (swarmSet == null) {\n        return; // already cancelled\n      }\n      // Remove before releasing synchronization, so any fresh timer ends up\n      // in a new set with same key\n      allSwarms.remove(swarmSet);\n    } // synchronized\n    // Empty the swarmSet\n    synchronized (swarmSet) {\n      Iterator it = swarmSet.iterator();\n      while (it.hasNext()) {\n        WeakReference wr = (WeakReference) it.next();\n        SystemTimer st = (SystemTimer) wr.get();\n        // it.remove(); Not necessary, we're emptying the list...\n        if (st != null) {\n          st.cancelled = true; // for safety :-)\n          st.timer.cancel(); // st.cancel() would just search for it again\n        }\n      } // while\n    } // synchronized\n  }\n  public int timerPurge() {\n    if (logger.isTraceEnabled()) {\n      logger.trace(\"SystemTimer#timerPurge of {}\", this);\n    }\n    // Fix 39585, IBM's java.util.timer's purge() has stack overflow issue\n    if (isIBM) {\n      return 0;\n    }\n    return this.timer.purge();\n  }\n  // This creates a non-daemon timer thread. We don't EVER do this...\n  // /**\n  // * @see Timer#Timer()\n  // *\n  // * @param swarm the swarm this timer belongs to\n  // */\n  // public SystemTimer(DistributedSystem swarm) {\n  // this.timer = new Timer();\n  // this.swarm = swarm;\n  // addToSwarm(swarm, this);\n  // }\n  /**\n   * @see Timer#Timer(boolean)\n   * @param swarm the swarm this timer belongs to, currently must be a DistributedSystem\n   * @param isDaemon whether the timer is a daemon. Must be true for GemFire use.\n   */\n  public SystemTimer(Object /* T */ swarm, boolean isDaemon) {\n    Assert.assertTrue(isDaemon); // we don't currently allow non-daemon timers\n    Assert.assertTrue(swarm instanceof InternalDistributedSystem,\n        \"Attempt to create swarm on \" + swarm); // TODO allow template class?\n    this.timer = new Timer(isDaemon);\n    this.swarm = swarm;\n    addToSwarm(swarm, this);\n  }\n  /**\n   * @param name the name to give the timer thread\n   * @param swarm the swarm this timer belongs to, currently must be a DistributedMember\n   * @param isDaemon whether the timer is a daemon. Must be true for GemFire use.\n   */\n  public SystemTimer(String name, Object /* T */ swarm, boolean isDaemon) {\n    Assert.assertTrue(isDaemon); // we don't currently allow non-daemon timers\n    Assert.assertTrue(swarm instanceof InternalDistributedSystem,\n        \"Attempt to create swarm on \" + swarm); // TODO allow template class?\n    this.timer = new Timer(name, isDaemon);\n    this.swarm = swarm;\n    addToSwarm(swarm, this);\n  }\n  private void checkCancelled() throws IllegalStateException {\n    if (this.cancelled) {\n      throw new IllegalStateException(\"This timer has been cancelled.\");\n    }\n  }\n  /**\n   * @see Timer#schedule(TimerTask, long)\n   */\n  public void schedule(SystemTimerTask task, long delay) {\n    checkCancelled();\n    if (logger.isTraceEnabled()) {\n      Date tilt = new Date(System.currentTimeMillis() + delay);\n      SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\");\n      logger.trace(\"SystemTimer#schedule (long): {}: expect task {} to fire around {}\", this, task,\n          sdf.format(tilt));\n    }\n    timer.schedule(task, delay);\n  }\n  /**\n   * @see Timer#schedule(TimerTask, Date)\n   */\n  public void schedule(SystemTimerTask task, Date time) {\n    checkCancelled();\n    if (logger.isTraceEnabled()) {\n      SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\");\n      logger.trace(\"SystemTimer#schedule (Date): {}: expect task {} to fire around {}\", this, task,\n          sdf.format(time));\n    }\n    timer.schedule(task, time);\n  }\n  // Not currently used, so don't complicate things\n  // /**\n  // * @see Timer#schedule(TimerTask, long, long)\n  // */\n  // public void schedule(SystemTimerTask task, long delay, long period) {\n  // // TODO add debug statement\n  // checkCancelled();\n  // timer.schedule(task, delay, period);\n  // }\n  // Not currently used, so don't complicate things\n  // /**\n  // * @see Timer#schedule(TimerTask, Date, long)\n  // */\n  // public void schedule(SystemTimerTask task, Date firstTime, long period) {\n  // // TODO add debug statement\n  // checkCancelled();\n  // timer.schedule(task, firstTime, period);\n  // }\n  /**\n   * @see Timer#scheduleAtFixedRate(TimerTask, long, long)\n   */\n  public void scheduleAtFixedRate(SystemTimerTask task, long delay, long period) {\n    // TODO add debug statement\n    checkCancelled();\n    timer.scheduleAtFixedRate(task, delay, period);\n  }\n  /**\n   * @see Timer#schedule(TimerTask, long, long)\n   */\n  public void schedule(SystemTimerTask task, long delay, long period) {\n    // TODO add debug statement\n    checkCancelled();\n    timer.schedule(task, delay, period);\n  }\n  // Not currently used, so don't complicate things\n  // /**\n  // * @see Timer#scheduleAtFixedRate(TimerTask, Date, long)\n  // */\n  // public void scheduleAtFixedRate(SystemTimerTask task, Date firstTime,\n  // long period) {\n  // // TODO add debug statement\n  // checkCancelled();\n  // timer.scheduleAtFixedRate(task, firstTime, period);\n  // }\n  /**\n   * @see Timer#cancel()\n   */\n  public void cancel() {\n    this.cancelled = true;\n    timer.cancel();\n    removeFromSwarm(this);\n  }\n  /**\n   * Cover class to track behavior of scheduled tasks\n   *\n   * @see TimerTask\n   */\n<fim_suffix>  public abstract static class SystemTimerTask extends TimerTask {\n    protected static final Logger logger = LogService.getLogger();\n    /**\n     * This is your executed action\n     */\n    public abstract void run2();\n    /**\n     * Does debug logging, catches critical errors, then delegates to {@link #run2()}\n     */\n    @Override\n    public void run() {\n      final boolean isDebugEnabled = logger.isTraceEnabled();\n      if (isDebugEnabled) {\n        logger.trace(\"SystemTimer.MyTask: starting {}\", this);\n      }\n      try {\n        this.run2();\n      } catch (CancelException ignore) {\n        // ignore: TimerThreads can fire during or near cache closure\n      } catch (VirtualMachineError e) {\n        SystemFailure.initiateFailure(e);\n        throw e;\n      } catch (Throwable t) {\n        SystemFailure.checkFailure();\n        logger.warn(String.format(\"Timer task <%s> encountered exception\", this), t);\n        // Don't rethrow, it will just get eaten and kill the timer\n      }\n      if (isDebugEnabled) {\n        logger.trace(\"SystemTimer.MyTask: finished {}\", this);\n      }\n    }\n  }<fim_middle>// class below has no smell\n"}