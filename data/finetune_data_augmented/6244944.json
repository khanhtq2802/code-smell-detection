{"text": "<fim_prefix>import io.vertx.core.json.JsonArray;\nimport io.vertx.core.json.JsonObject;\n/**\n * A credentials service that keeps all data in memory but is backed by a file.\n * <p>\n * On startup this adapter tries to load credentials from a file (if configured).\n * On shutdown all credentials kept in memory are written to the file (if configured).\n */\n@Repository\n@ConditionalOnProperty(name = \"hono.app.type\", havingValue = \"file\", matchIfMissing = true)\npublic final class FileBasedCredentialsService extends CompleteBaseCredentialsService<FileBasedCredentialsConfigProperties> {\n    /**\n     * The name of the JSON array within a tenant that contains the credentials.\n     */\n    public static final String ARRAY_CREDENTIALS = \"credentials\";\n    /**\n     * The name of the JSON property containing the tenant's ID.\n     */\n    public static final String FIELD_TENANT = \"tenant\";\n    // <tenantId, <authId, credentialsData[]>>\n    private final Map<String, Map<String, JsonArray>> credentials = new HashMap<>();\n    private boolean running = false;\n    private boolean dirty = false;\n    /**\n     * Creates a new service instance for a password encoder.\n     * \n     * @param pwdEncoder The encoder to use for hashing clear text passwords.\n     * @throws NullPointerException if encoder is {@code null}.\n     */\n    @Autowired\n    public FileBasedCredentialsService(final HonoPasswordEncoder pwdEncoder) {\n        super(pwdEncoder);\n    }\n    @Autowired\n    @Override\n    public void setConfig(final FileBasedCredentialsConfigProperties configuration) {\n        setSpecificConfig(configuration);\n    }\n    private Future<Void> checkFileExists(final boolean createIfMissing) {\n        final Future<Void> result = Future.future();\n        if (getConfig().getFilename() == null) {\n            result.fail(\"no filename set\");\n        } else if (vertx.fileSystem().existsBlocking(getConfig().getFilename())) {\n            result.complete();\n        } else if (createIfMissing) {\n            vertx.fileSystem().createFile(getConfig().getFilename(), result.completer());\n        } else {\n            log.debug(\"no such file [{}]\", getConfig().getFilename());\n            result.complete();\n        }\n        return result;\n    }\n    @Override\n    protected void doStart(final Future<Void> startFuture) {\n        if (running) {\n            startFuture.complete();\n        } else {\n            if (!getConfig().isModificationEnabled()) {\n                log.info(\"modification of credentials has been disabled\");\n            }\n            if (getConfig().getFilename() == null) {\n                log.debug(\"credentials filename is not set, no credentials will be loaded\");\n                running = true;\n                startFuture.complete();\n            } else {\n                checkFileExists(getConfig().isSaveToFile()).compose(ok -> {\n                    return loadCredentials();\n                }).compose(s -> {\n                    if (getConfig().isSaveToFile()) {\n                        log.info(\"saving credentials to file every 3 seconds\");\n                        vertx.setPeriodic(3000, saveIdentities -> {\n                            saveToFile();\n                        });\n                    } else {\n                        log.info(\"persistence is disabled, will not save credentials to file\");\n                    }\n                    running = true;\n                    startFuture.complete();\n                }, startFuture);\n            }\n        }\n    }\n    Future<Void> loadCredentials() {\n        if (getConfig().getFilename() == null || getConfig().isStartEmpty()) {\n            // no need to load anything\n            log.info(\"Either filename is null or empty start is set, won't load any credentials\");\n            return Future.succeededFuture();\n        } else {\n            final Future<Buffer> readResult = Future.future();\n            log.debug(\"trying to load credentials from file {}\", getConfig().getFilename());\n            vertx.fileSystem().readFile(getConfig().getFilename(), readResult.completer());\n            return readResult.compose(buffer -> {\n                return addAll(buffer);\n            }).recover(t -> {\n                log.debug(\"cannot load credentials from file [{}]: {}\", getConfig().getFilename(), t.getMessage());\n                return Future.succeededFuture();\n            });\n        }\n    }\n    private Future<Void> addAll(final Buffer credentials) {\n        final Future<Void> result = Future.future();\n        try {\n            int credentialsCount = 0;\n            final JsonArray allObjects = credentials.toJsonArray();\n            log.debug(\"trying to load credentials for {} tenants\", allObjects.size());\n            for (final Object obj : allObjects) {\n                if (JsonObject.class.isInstance(obj)) {\n                    credentialsCount += addCredentialsForTenant((JsonObject) obj);\n                }\n            }\n            log.info(\"successfully loaded {} credentials from file [{}]\", credentialsCount, getConfig().getFilename());\n            result.complete();\n        } catch (final DecodeException e) {\n            log.warn(\"cannot read malformed JSON from credentials file [{}]\", getConfig().getFilename());\n            result.fail(e);\n        }\n        return result;\n    };\n    int addCredentialsForTenant(final JsonObject tenant) {\n        int count = 0;\n        final String tenantId = tenant.getString(FIELD_TENANT);\n        final Map<String, JsonArray> credentialsMap = new HashMap<>();\n        for (final Object credentialsObj : tenant.getJsonArray(ARRAY_CREDENTIALS)) {\n            final JsonObject credentials = (JsonObject) credentialsObj;\n            final JsonArray authIdCredentials;\n            if (credentialsMap.containsKey(credentials.getString(CredentialsConstants.FIELD_AUTH_ID))) {\n                authIdCredentials = credentialsMap.get(credentials.getString(CredentialsConstants.FIELD_AUTH_ID));\n            } else {\n                authIdCredentials = new JsonArray();\n            }\n            authIdCredentials.add(credentials);\n            credentialsMap.put(credentials.getString(CredentialsConstants.FIELD_AUTH_ID), authIdCredentials);\n            count++;\n        }\n        credentials.put(tenantId, credentialsMap);\n        return count;\n    }\n    @Override\n    protected void doStop(final Future<Void> stopFuture) {\n        if (running) {\n            saveToFile().compose(s -> {\n                running = false;\n                stopFuture.complete();\n            }, stopFuture);\n        } else {\n            stopFuture.complete();\n        }\n    }\n    Future<Void> saveToFile() {\n        if (!getConfig().isSaveToFile()) {\n            return Future.succeededFuture();\n        } else if (dirty) {\n            return checkFileExists(true).compose(s -> {\n                final AtomicInteger idCount = new AtomicInteger();\n                final JsonArray tenants = new JsonArray();\n                for (final Entry<String, Map<String, JsonArray>> entry : credentials.entrySet()) {\n                    final JsonArray credentialsArray = new JsonArray();\n                    for (final JsonArray singleAuthIdCredentials : entry.getValue().values()) {\n                        credentialsArray.addAll(singleAuthIdCredentials.copy());\n                        idCount.incrementAndGet();\n                    }\n                    tenants.add(\n                            new JsonObject()\n                                    .put(FIELD_TENANT, entry.getKey())\n                                    .put(ARRAY_CREDENTIALS, credentialsArray));\n                }\n                final Future<Void> writeHandler = Future.future();\n                vertx.fileSystem().writeFile(\n                        getConfig().getFilename(),\n                        Buffer.buffer(tenants.encodePrettily(), StandardCharsets.UTF_8.name()),\n                        writeHandler.completer());\n                return writeHandler.map(ok -> {\n                    dirty = false;\n                    log.trace(\"successfully wrote {} credentials to file {}\", idCount.get(), getConfig().getFilename());\n                    return (Void) null;\n                }).otherwise(t -> {\n                    log.warn(\"could not write credentials to file {}\", getConfig().getFilename(), t);\n                    return (Void) null;\n                });\n            });\n        } else {\n            log.trace(\"credentials registry does not need to be persisted\");\n            return Future.succeededFuture();\n        }\n    }\n    /**\n     * {@inheritDoc}\n     * <p>\n     * The result object will include a <em>no-cache</em> directive.\n     */\n    @Override\n    public void get(final String tenantId, final String type, final String authId, final Span span,\n            final Handler<AsyncResult<CredentialsResult<JsonObject>>> resultHandler) {\n        get(tenantId, type, authId, null, span, resultHandler);\n    }\n    /**\n     * {@inheritDoc}\n     * <p>\n     * The result object will include a <em>no-cache</em> directive.\n     */\n<fim_suffix>    @Override\n    public void get(\n            final String tenantId,\n            final String type,\n            final String authId,\n            final JsonObject clientContext,\n            final Span span,\n            final Handler<AsyncResult<CredentialsResult<JsonObject>>> resultHandler) {\n        Objects.requireNonNull(tenantId);\n        Objects.requireNonNull(type);\n        Objects.requireNonNull(authId);\n        Objects.requireNonNull(resultHandler);\n        final JsonObject data = getSingleCredentials(tenantId, authId, type, clientContext, span);\n        if (data == null) {\n            resultHandler.handle(Future.succeededFuture(CredentialsResult.from(HttpURLConnection.HTTP_NOT_FOUND)));\n        } else {\n            resultHandler.handle(Future.succeededFuture(\n                    CredentialsResult.from(HttpURLConnection.HTTP_OK, data.copy(), CacheDirective.noCacheDirective())));\n        }\n    }<fim_middle>// function below has no smell\n"}