{"text": "<fim_prefix>/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.mina.coap.codec;\n\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\n\nimport org.apache.mina.coap.CoapMessage;\nimport org.apache.mina.coap.CoapOption;\nimport org.apache.mina.codec.StatelessProtocolEncoder;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Encode a CoAP message following the RFC.\n * \n * Encode {@link CoapMessage} into {@link ByteBuffer}\n * \n * @author <a href=\"http://mina.apache.org\">Apache MINA Project</a>\n */\n<fim_suffix>public class CoapEncoder implements StatelessProtocolEncoder<CoapMessage, ByteBuffer> {\n\n    private static final Logger LOG = LoggerFactory.getLogger(CoapEncoder.class);\n\n    private static final int HEADER_SIZE = 4;\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Void createEncoderState() {\n        return null;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public ByteBuffer encode(CoapMessage message, Void context) {\n\n        LOG.debug(\"encoding {}\", message);\n\n        // compute size of the needed buffer\n        int size = HEADER_SIZE + message.getToken().length;\n\n        int delta = 0;\n        for (CoapOption opt : message.getOptions()) {\n            // compute delta encoding size\n            int code = opt.getType().getCode();\n            delta = code - delta;\n            if (delta < 13) {\n                size += 1;\n            } else if (delta < 256 + 13) {\n                size += 2;\n            } else if (delta < 65536 + 269) {\n                size += 3;\n            }\n\n            // compute option length encoding size\n            int optLength = opt.getData().length;\n            if (optLength < 13) {\n                size += 0;\n            } else if (optLength < 256 + 13) {\n                size += 1;\n            } else if (optLength < 65536 + 269) {\n                size += 2;\n            }\n\n            // compute option data encoding size\n            size += optLength;\n        }\n\n        // if we have a payload, we place the marker and the payload\n        if (message.getPayload() != null && message.getPayload().length > 0) {\n            // payload marker\n            size += 1;\n            size += message.getPayload().length;\n        }\n\n        ByteBuffer buffer = ByteBuffer.allocate(size);\n\n        buffer.order(ByteOrder.BIG_ENDIAN);\n\n        // encode header\n        buffer.put((byte) (((message.getVersion() & 0x03) << 6) | (message.getType().getCode() & 0x03) << 4 | (message\n                .getToken().length & 0x0F)));\n        buffer.put((byte) message.getCode());\n        buffer.putShort((short) message.getId());\n        buffer.put(message.getToken());\n\n        // encode options\n        int lastOptCode = 0;\n\n        for (CoapOption opt : message.getOptions()) {\n            int optionDelta = opt.getType().getCode() - lastOptCode;\n            int deltaQuartet = getQuartet(optionDelta);\n            int optionLength = opt.getData().length;\n\n            int optionQuartet = getQuartet(optionLength);\n\n            buffer.put((byte) ((deltaQuartet << 4) | optionQuartet));\n\n            // write extended option delta field (0 - 2 bytes)\n            if (deltaQuartet == 13) {\n                buffer.put((byte) (optionDelta - 13));\n            } else if (deltaQuartet == 14) {\n                buffer.putShort((short) (optionDelta - 269));\n            }\n\n            if (optionQuartet == 13) {\n                buffer.put((byte) (optionLength - 13));\n            } else if (optionQuartet == 14) {\n                buffer.putShort((short) (optionLength - 269));\n            }\n            buffer.put(opt.getData());\n\n            lastOptCode = opt.getType().getCode();\n        }\n\n        if (message.getPayload() != null && message.getPayload().length > 0) {\n            buffer.put((byte) 0xFF);\n            buffer.put(message.getPayload());\n        }\n\n        buffer.flip();\n        return buffer;\n    }\n\n    private int getQuartet(int value) {\n        if (value <= 12) {\n            return value;\n        } else if (value <= 255 + 13) {\n            return 13;\n        } else {\n            return 14;\n        }\n    }\n}<fim_middle>// class below is blob\n"}