{"text": "<fim_prefix> * persistence applies to both local scope and distributed scope.\n * </ol>\n *\n *\n *\n * @see AttributesFactory#setDataPolicy\n * @see RegionAttributes#getDataPolicy\n *\n * @since GemFire 5.0\n */\n@Immutable\npublic class DataPolicy implements java.io.Serializable {\n  private static final long serialVersionUID = 2095573273889467233L;\n  @Immutable\n  private static final DataPolicy[] VALUES = new DataPolicy[11];\n  /**\n   * Data is never stored in local memory. The region will always be empty locally. It can be used\n   * to for zero footprint producers that only want to distribute their data to others and for zero\n   * footprint consumers that only want to see events.\n   */\n  @Immutable\n  public static final DataPolicy EMPTY = new DataPolicy(0, \"EMPTY\");\n  /**\n   * Allows the contents in this cache to differ from other caches.\n   * <p>\n   * Data that this region is interested in is stored in local memory.\n   */\n  @Immutable\n  public static final DataPolicy NORMAL = new DataPolicy(1, \"NORMAL\");\n  /**\n   * The region will be initialized with the data from other caches and accepts any new entries\n   * created in other caches.\n   * <p>\n   * Operations that would cause the contents to differ with other caches are not allowed.\n   * <p>\n   * Data that this region is interested in is stored in local memory.\n   */\n  @Immutable\n  public static final DataPolicy REPLICATE = new DataPolicy(2, \"REPLICATE\");\n  /**\n   * In addition to <code>REPLICATE</code> also causes data to be stored to disk. The region\n   * initialization may use the data stored on disk.\n   */\n  @Immutable\n  public static final DataPolicy PERSISTENT_REPLICATE = new DataPolicy(3, \"PERSISTENT_REPLICATE\");\n  /**\n   * Data in this region may be spread across a number of processes. This is further configured with\n   * {@link PartitionAttributes partitioning attributes}\n   */\n  @Immutable\n  public static final DataPolicy PARTITION = new DataPolicy(4, \"PARTITION\");\n  /**\n   * In addition to <code>NORMAL</code>, contents inside of this cache are (partially) initialized\n   * with data from other caches, if available.\n   */\n  @Immutable\n  public static final DataPolicy PRELOADED = new DataPolicy(5, \"PRELOADED\");\n  /**\n   * In addition to <code>PARTITION</code> also causes data to be stored to disk. The region\n   * initialization may use the data stored on disk.\n   *\n   * @since GemFire 6.5\n   */\n  @Immutable\n  public static final DataPolicy PERSISTENT_PARTITION = new DataPolicy(6, \"PERSISTENT_PARTITION\");\n  /**\n   * The data policy used by default; it is {@link #NORMAL}.\n   */\n  @Immutable\n  public static final DataPolicy DEFAULT = NORMAL;\n  /** The name of this mirror type. */\n  private final transient String name;\n  /** used as ordinal to represent this DataPolicy */\n  public final byte ordinal;\n  private Object readResolve() throws ObjectStreamException {\n    return VALUES[ordinal]; // Canonicalize\n  }\n  /** Creates a new instance of DataPolicy. */\n  private DataPolicy(int ordinal, String name) {\n    if (ordinal >= VALUES.length) {\n      throw new IllegalArgumentException(\n          String.format(\"Only %s DataPolicies may be defined\",\n              Integer.valueOf(VALUES.length + 1)));\n    }\n    if (VALUES[ordinal] != null) {\n      throw new IllegalArgumentException(\n          String.format(\"Ordinal %s is already defined by %s\",\n              new Object[] {Integer.valueOf(ordinal), VALUES[ordinal]}));\n    }\n    this.name = name;\n    this.ordinal = (byte) (ordinal & 0xff);\n    VALUES[this.ordinal] = this;\n  }\n  /** Return the DataPolicy represented by specified ordinal */\n  public static DataPolicy fromOrdinal(byte ordinal) {\n    return VALUES[ordinal];\n  }\n  /**\n   * Return true if regions with this policy store data locally.\n   * <p>\n   * Although DataPolicy {@link #PARTITION} will return true to this query, it is possible to turn\n   * off local storage with {@link PartitionAttributesFactory#setLocalMaxMemory(int)} by setting\n   * localMaxMemory to zero.\n   *\n   * @return true if regions with this policy store data locally.\n   * @see #NORMAL\n   * @see #PRELOADED\n   * @see #REPLICATE\n   * @see #PERSISTENT_REPLICATE\n   * @see #PARTITION\n   * @see #PERSISTENT_PARTITION\n   */\n  public boolean withStorage() {\n    return this != EMPTY;\n  }\n  /**\n   * Return whether this policy does replication.\n   *\n   * @return true if this policy does replication.\n   * @see #REPLICATE\n   * @see #PERSISTENT_REPLICATE\n   */\n  public boolean withReplication() {\n    return this == REPLICATE || this == PERSISTENT_REPLICATE;\n  }\n  /**\n   * Return whether this policy does persistence.\n   *\n   * @return true if this policy does persistence.\n   * @see #PERSISTENT_PARTITION\n   * @see #PERSISTENT_REPLICATE\n   * @since GemFire 6.5\n   */\n  public boolean withPersistence() {\n    return this == PERSISTENT_PARTITION || this == PERSISTENT_REPLICATE;\n  }\n  /**\n   * Return whether this policy does partitioning.\n   *\n   * @return true if this policy does partitioning\n   * @see #PARTITION\n   * @see #PERSISTENT_PARTITION\n   * @since GemFire 6.5\n   */\n  public boolean withPartitioning() {\n    return this == PARTITION || this == PERSISTENT_PARTITION;\n  }\n  /**\n   * Return whether this policy does preloaded.\n   *\n   * @return true if this policy does preloaded.\n   * @see #PRELOADED\n   * @since GemFire 6.5\n   */\n  public boolean withPreloaded() {\n    return this == PRELOADED;\n  }\n  /**\n   * Return true if this policy is {@link #EMPTY}.\n   *\n   * @return true if this policy is {@link #EMPTY}.\n   * @deprecated from version 6.5 forward please use withStorage()\n   */\n  public boolean isEmpty() {\n    return this == EMPTY;\n  }\n  /**\n   * Return true if this policy is {@link #NORMAL}.\n   *\n   * @return true if this policy is {@link #NORMAL}.\n   * @deprecated from version 6.5 forward please use an identity comparison instead of this method\n   */\n  public boolean isNormal() {\n    return this == NORMAL;\n  }\n  /**\n   * Return true if this policy is {@link #PRELOADED}.\n   *\n   * @return true if this policy is {@link #PRELOADED}\n   * @deprecated from version 6.5 forward please use withPreloaded()\n   */\n  public boolean isPreloaded() {\n    return this == PRELOADED;\n  }\n  /**\n   * Return true if this policy is the default.\n   *\n   * @return true if this policy is the default.\n   * @deprecated from version 6.5 forward please use an identity comparison instead of this method\n   */\n  public boolean isDefault() {\n    return this == DEFAULT;\n  }\n  /**\n   * Return true if this policy is {@link #REPLICATE}.\n   *\n   * @return true if this policy is {@link #REPLICATE}.\n   * @deprecated from version 6.5 forward please use withReplication()\n   */\n  public boolean isReplicate() {\n    return this == REPLICATE;\n  }\n  /**\n   * Return true if this policy is {@link #PERSISTENT_REPLICATE}.\n   *\n   * @return true if this policy is {@link #PERSISTENT_REPLICATE}.\n   * @deprecated from version 6.5 forward please use withPersistence() and withReplication()\n   */\n  public boolean isPersistentReplicate() {\n    return this == PERSISTENT_REPLICATE;\n  }\n  /**\n   * Return true if this policy is {@link #PARTITION}.\n   *\n   * @return true if this policy is {@link #PARTITION}\n   * @deprecated from version 6.5 forward please use withPartitioning()\n   */\n  public boolean isPartition() {\n    return this == PARTITION;\n  }\n  /**\n   * Returns a string representation for this data policy.\n   *\n   * @return the name of this data policy.\n   */\n  @Override\n  public String toString() {\n    return this.name;\n  }\n<fim_suffix>  public static DataPolicy fromString(String s) {\n    String[] allowedValues =\n        new String[] {\"EMPTY\", \"NORMAL\", \"REPLICATE\", \"PERSISTENT_REPLICATE\", \"PARTITION\",\n            \"PRELOADED\", \"PERSISTENT_PARTITION\"};\n    int valueIndex = -1;\n    for (int i = 0; i < allowedValues.length; i++) {\n      if (allowedValues[i].equals(s)) {\n        valueIndex = i;\n        break;\n      }\n    }\n    if (valueIndex != -1)\n      return VALUES[valueIndex];\n    return null;\n  }<fim_middle>// function below has no smell\n"}