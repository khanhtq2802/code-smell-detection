{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hbase.security.token;\n\nimport javax.crypto.SecretKey;\n\nimport java.io.DataInput;\nimport java.io.DataOutput;\nimport java.io.IOException;\nimport java.util.Arrays;\n\nimport org.apache.yetus.audience.InterfaceAudience;\nimport org.apache.hadoop.hbase.util.Bytes;\nimport org.apache.hadoop.io.Writable;\nimport org.apache.hadoop.io.WritableUtils;\n\n/**\n * Represents a secret key used for signing and verifying authentication tokens\n * by {@link AuthenticationTokenSecretManager}.\n */\n@InterfaceAudience.Private\npublic class AuthenticationKey implements Writable {\n  private int id;\n  private long expirationDate;\n  private SecretKey secret;\n\n  public AuthenticationKey() {\n    // for Writable\n  }\n\n<fim_suffix>  public AuthenticationKey(int keyId, long expirationDate, SecretKey key) {\n    this.id = keyId;\n    this.expirationDate = expirationDate;\n    this.secret = key;\n  }\n\n  public int getKeyId() {\n    return id;\n  }\n\n  public long getExpiration() {\n    return expirationDate;\n  }\n\n  public void setExpiration(long timestamp) {\n    expirationDate = timestamp;\n  }\n\n  SecretKey getKey() {\n    return secret;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = id;\n    result = 31 * result + (int) (expirationDate ^ (expirationDate >>> 32));\n    result = 31 * result + ((secret == null) ? 0 : Arrays.hashCode(secret.getEncoded()));\n    return result;\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (obj == null || !(obj instanceof AuthenticationKey)) {\n      return false;\n    }\n    AuthenticationKey other = (AuthenticationKey)obj;\n    return id == other.getKeyId() &&\n        expirationDate == other.getExpiration() &&\n        (secret == null ? other.getKey() == null :\n            other.getKey() != null &&\n                Bytes.equals(secret.getEncoded(), other.getKey().getEncoded()));       \n  }\n\n  @Override\n  public String toString() {\n    StringBuilder buf = new StringBuilder();\n    buf.append(\"AuthenticationKey[ \")\n       .append(\"id=\").append(id)\n       .append(\", expiration=\").append(expirationDate)\n       .append(\" ]\");\n    return buf.toString();\n  }\n\n  @Override\n  public void write(DataOutput out) throws IOException {\n    WritableUtils.writeVInt(out, id);\n    WritableUtils.writeVLong(out, expirationDate);\n    if (secret == null) {\n      WritableUtils.writeVInt(out, -1);\n    } else {\n      byte[] keyBytes = secret.getEncoded();\n      WritableUtils.writeVInt(out, keyBytes.length);\n      out.write(keyBytes);\n    }\n  }\n\n  @Override\n  public void readFields(DataInput in) throws IOException {\n    id = WritableUtils.readVInt(in);\n    expirationDate = WritableUtils.readVLong(in);\n    int keyLength = WritableUtils.readVInt(in);\n    if (keyLength < 0) {\n      secret = null;\n    } else {\n      byte[] keyBytes = new byte[keyLength];\n      in.readFully(keyBytes);\n      secret = AuthenticationTokenSecretManager.createSecretKey(keyBytes);\n    }\n  }\n}<fim_middle>// function below has no smell\n"}