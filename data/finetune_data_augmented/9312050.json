{"text": "<fim_prefix>/*\n * Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage java.nio.channels.spi;\nimport java.io.IOException;\nimport java.net.ProtocolFamily;\nimport java.nio.channels.*;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.util.Iterator;\nimport java.util.ServiceLoader;\nimport java.util.ServiceConfigurationError;\nimport sun.security.action.GetPropertyAction;\n/**\n * Service-provider class for selectors and selectable channels.\n *\n * <p> A selector provider is a concrete subclass of this class that has a\n * zero-argument constructor and implements the abstract methods specified\n * below.  A given invocation of the Java virtual machine maintains a single\n * system-wide default provider instance, which is returned by the {@link\n * #provider() provider} method.  The first invocation of that method will locate\n * the default provider as specified below.\n *\n * <p> The system-wide default provider is used by the static {@code open}\n * methods of the {@link java.nio.channels.DatagramChannel#open\n * DatagramChannel}, {@link java.nio.channels.Pipe#open Pipe}, {@link\n * java.nio.channels.Selector#open Selector}, {@link\n * java.nio.channels.ServerSocketChannel#open ServerSocketChannel}, and {@link\n * java.nio.channels.SocketChannel#open SocketChannel} classes.  It is also\n * used by the {@link java.lang.System#inheritedChannel System.inheritedChannel()}\n * method. A program may make use of a provider other than the default provider\n * by instantiating that provider and then directly invoking the {@code open}\n * methods defined in this class.\n *\n * <p> All of the methods in this class are safe for use by multiple concurrent\n * threads.  </p>\n *\n *\n * @author Mark Reinhold\n * @author JSR-51 Expert Group\n * @since 1.4\n */\npublic abstract class SelectorProvider {\n    private static final Object lock = new Object();\n    private static SelectorProvider provider = null;\n<fim_suffix>    private static Void checkPermission() {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null)\n            sm.checkPermission(new RuntimePermission(\"selectorProvider\"));\n        return null;\n    }\n    private SelectorProvider(Void ignore) { }\n    /**\n     * Initializes a new instance of this class.\n     *\n     * @throws  SecurityException\n     *          If a security manager has been installed and it denies\n     *          {@link RuntimePermission}{@code (\"selectorProvider\")}\n     */\n    protected SelectorProvider() {\n        this(checkPermission());\n    }\n    private static boolean loadProviderFromProperty() {\n        String cn = System.getProperty(\"java.nio.channels.spi.SelectorProvider\");\n        if (cn == null)\n            return false;\n        try {\n            @SuppressWarnings(\"deprecation\")\n            Object tmp = Class.forName(cn, true,\n                                       ClassLoader.getSystemClassLoader()).newInstance();\n            provider = (SelectorProvider)tmp;\n            return true;\n        } catch (ClassNotFoundException x) {\n            throw new ServiceConfigurationError(null, x);\n        } catch (IllegalAccessException x) {\n            throw new ServiceConfigurationError(null, x);\n        } catch (InstantiationException x) {\n            throw new ServiceConfigurationError(null, x);\n        } catch (SecurityException x) {\n            throw new ServiceConfigurationError(null, x);\n        }\n    }\n    private static boolean loadProviderAsService() {\n        ServiceLoader<SelectorProvider> sl =\n            ServiceLoader.load(SelectorProvider.class,\n                               ClassLoader.getSystemClassLoader());\n        Iterator<SelectorProvider> i = sl.iterator();\n        for (;;) {\n            try {\n                if (!i.hasNext())\n                    return false;\n                provider = i.next();\n                return true;\n            } catch (ServiceConfigurationError sce) {\n                if (sce.getCause() instanceof SecurityException) {\n                    // Ignore the security exception, try the next provider\n                    continue;\n                }\n                throw sce;\n            }\n        }\n    }\n    /**\n     * Returns the system-wide default selector provider for this invocation of\n     * the Java virtual machine.\n     *\n     * <p> The first invocation of this method locates the default provider\n     * object as follows: </p>\n     *\n     * <ol>\n     *\n     *   <li><p> If the system property\n     *   {@code java.nio.channels.spi.SelectorProvider} is defined then it is\n     *   taken to be the fully-qualified name of a concrete provider class.\n     *   The class is loaded and instantiated; if this process fails then an\n     *   unspecified error is thrown.  </p></li>\n     *\n     *   <li><p> If a provider class has been installed in a jar file that is\n     *   visible to the system class loader, and that jar file contains a\n     *   provider-configuration file named\n     *   {@code java.nio.channels.spi.SelectorProvider} in the resource\n     *   directory {@code META-INF/services}, then the first class name\n     *   specified in that file is taken.  The class is loaded and\n     *   instantiated; if this process fails then an unspecified error is\n     *   thrown.  </p></li>\n     *\n     *   <li><p> Finally, if no provider has been specified by any of the above\n     *   means then the system-default provider class is instantiated and the\n     *   result is returned.  </p></li>\n     *\n     * </ol>\n     *\n     * <p> Subsequent invocations of this method return the provider that was\n     * returned by the first invocation.  </p>\n     *\n     * @return  The system-wide default selector provider\n     */\n    public static SelectorProvider provider() {\n        synchronized (lock) {\n            if (provider != null)\n                return provider;\n            return AccessController.doPrivileged(\n                new PrivilegedAction<>() {\n                    public SelectorProvider run() {\n                            if (loadProviderFromProperty())\n                                return provider;\n                            if (loadProviderAsService())\n                                return provider;\n                            provider = sun.nio.ch.DefaultSelectorProvider.create();\n                            return provider;\n                        }\n                    });\n        }\n    }\n    /**\n     * Opens a datagram channel.\n     *\n     * @return  The new channel\n     *\n     * @throws  IOException\n     *          If an I/O error occurs\n     */\n    public abstract DatagramChannel openDatagramChannel()\n        throws IOException;\n    /**\n     * Opens a datagram channel.\n     *\n     * @param   family\n     *          The protocol family\n     *\n     * @return  A new datagram channel\n     *\n     * @throws  UnsupportedOperationException\n     *          If the specified protocol family is not supported\n     * @throws  IOException\n     *          If an I/O error occurs\n     *\n     * @since 1.7\n     */\n    public abstract DatagramChannel openDatagramChannel(ProtocolFamily family)\n        throws IOException;\n    /**\n     * Opens a pipe.\n     *\n     * @return  The new pipe\n     *\n     * @throws  IOException\n     *          If an I/O error occurs\n     */\n    public abstract Pipe openPipe()\n        throws IOException;\n    /**\n     * Opens a selector.\n     *\n     * @return  The new selector\n     *\n     * @throws  IOException\n     *          If an I/O error occurs\n     */\n    public abstract AbstractSelector openSelector()\n        throws IOException;\n    /**\n     * Opens a server-socket channel.\n     *\n     * @return  The new channel\n     *\n     * @throws  IOException\n     *          If an I/O error occurs\n     */\n    public abstract ServerSocketChannel openServerSocketChannel()\n        throws IOException;\n    /**\n     * Opens a socket channel.\n     *\n     * @return  The new channel\n     *\n     * @throws  IOException\n     *          If an I/O error occurs\n     */\n    public abstract SocketChannel openSocketChannel()\n        throws IOException;\n    /**<fim_middle>// function below has no smell\n"}