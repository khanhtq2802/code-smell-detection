{"text": "<fim_prefix>    public BlockMgrJournal(Transaction txn, FileRef fileRef, BlockMgr underlyingBlockMgr)\n    {\n        Context context = txn.getBaseDataset().getContext() ;\n        String mode = (null != context) ? (String) context.get(TDB.transactionJournalWriteBlockMode, \"\") : \"\" ;\n        if (\"direct\".equalsIgnoreCase(mode))\n            writeBlockBufferAllocator = new BufferAllocatorDirect() ;\n        else if (\"mapped\".equalsIgnoreCase(mode))\n            writeBlockBufferAllocator = new BufferAllocatorMapped(SystemTDB.BlockSize) ;\n        else\n            writeBlockBufferAllocator = new BufferAllocatorMem() ;\n        reset(txn, fileRef, underlyingBlockMgr) ;\n        if ( txn.getTxnMode() == ReadWrite.READ &&  underlyingBlockMgr instanceof BlockMgrJournal )\n            System.err.println(\"Two level BlockMgrJournal\") ;\n    }\n    @Override\n    public void begin(Transaction txn)\n    {\n        reset(txn, fileRef, blockMgr) ;\n    }\n    @Override\n    public void commitPrepare(Transaction txn)\n    {\n        checkActive() ;\n        for ( Block blk : writeBlocks.values() )\n            writeJournalEntry(blk) ;\n        this.active = false ;\n    }\n    @Override\n    public void committed(Transaction txn)\n    {}\n    @Override\n    public void enactCommitted(Transaction txn) {\n        // No-op : this is done by playing the master journal.\n    }\n    @Override\n    public void clearupCommitted(Transaction txn) {\n        // Persistent state is in the system journal.\n        clear(txn) ;\n    }\n    @Override\n    public void abort(Transaction txn)\n    {\n        // Ignore checkActive. abort() may be called in rollback.\n        this.active = false ;\n        clear(txn);\n    }\n    /** Set, or reset, this BlockMgr.\n     */\n    private void reset(Transaction txn, FileRef fileRef, BlockMgr underlyingBlockMgr)\n    {\n        this.fileRef = fileRef ;\n        this.blockMgr = underlyingBlockMgr ;\n        this.active = true ;\n        clear(txn) ;\n    }\n    private void clear(Transaction txn)\n    {\n        this.transaction = txn ;\n        this.readBlocks.clear() ;\n        this.iteratorBlocks.clear() ;\n        this.writeBlocks.clear() ;\n        this.freedBlocks.clear() ;\n        this.writeBlockBufferAllocator.clear() ;\n    }\n    @Override\n    public Block allocate(int blockSize)\n    {\n        checkIfClosed() ;\n        // Might as well allocate now. \n        // This allocates the id.\n        Block block = blockMgr.allocate(blockSize) ;\n        // But we \"copy\" it by allocating ByteBuffer space.\n        if ( active ) \n        {\n            block = replicate(block) ;\n            writeBlocks.put(block.getId(), block) ;\n        }\n        return block ;\n    }\n    @Override\n    public Block getRead(long id)\n    {\n        checkIfClosed() ;\n        Block block = localBlock(id) ;\n        if ( block != null )\n            return block ;\n        block = blockMgr.getRead(id) ;\n        if ( active ) \n            readBlocks.add(block.getId()) ;\n        return block ;\n    }\n    @Override\n    public Block getReadIterator(long id)\n    {\n        //logState() ;\n        checkIfClosed() ;\n        Block block = localBlock(id) ;\n        if ( block == null )\n            block = blockMgr.getReadIterator(id) ;\n        if ( block == null )\n            throw new BlockException(\"No such block: \"+getLabel()+\" \"+id) ;\n        if ( active ) \n            iteratorBlocks.add(block.getId()) ;\n        return block ;\n    }\n    @Override\n    public Block getWrite(long id)\n    {\n        // NB: If we are in a stack of BlockMgrs, after a transaction has committed,\n        // we would be called via getRead and the upper Blockgr does the promotion. \n        checkActive() ;\n        checkIfClosed() ;\n        Block block = localBlock(id) ;\n        if ( block != null )\n            return block ;\n        // Get-as-read.\n        block = blockMgr.getRead(id) ;\n        // If most blocks get modified, then a copy is needed\n        // anyway so now is as good a time as any.\n        block = _promote(block) ;\n        return block ;\n    }\n    private Block localBlock(long id)\n    {\n        checkIfClosed() ;\n        return writeBlocks.get(id) ;\n    }\n    @Override\n    public Block promote(Block block)\n    {\n        checkIfClosed() ;\n        if ( writeBlocks.containsKey(block.getId()) )\n            return block ;\n        return _promote(block) ;\n    }\n    private Block _promote(Block block)\n    {\n        checkActive() ; \n        block = replicate(block) ;\n        writeBlocks.put(block.getId(), block) ;\n        return block ;\n    }\n    @Override\n    public void release(Block block)\n    {\n        checkIfClosed() ;\n        Long id = block.getId() ;\n        // Only release unchanged blocks.\n        if ( ! writeBlocks.containsKey(id))\n            blockMgr.release(block) ;\n    }\n    @Override\n    public void write(Block block)\n    {\n        checkIfClosed() ;\n        if ( ! block.isModified() )\n            Log.warn(this, \"Page for block \"+fileRef+\"/\"+block.getId()+\" not modified\") ;\n        if ( ! writeBlocks.containsKey(block.getId()) )\n        {\n            Log.warn(this, \"Block not recognized: \"+block.getId()) ;\n            // Probably corruption by writing in-place.\n            // but at least when this transaction commits,\n            // the update data is written,\n            writeBlocks.put(block.getId(), block) ;\n        }\n    }\n    @Override\n    public void overwrite(Block block)\n    {\n        // We are in a chain of BlockMgrs - pass down to the base.\n        blockMgr.overwrite(block) ;\n    }\n    @Override\n    public void free(Block block)\n    {\n        checkIfClosed() ;\n        freedBlocks.put(block.getId(), block) ;\n    }\n    @Override\n    public boolean isEmpty()\n    {\n        checkIfClosed() ;\n        return writeBlocks.isEmpty() && blockMgr.isEmpty() ;\n    }\n    @Override\n    public boolean valid(int id)\n    {\n        checkIfClosed() ;\n        if ( writeBlocks.containsKey(Long.valueOf(id)))\n            return true ;\n        return blockMgr.valid(id) ; \n    }\n    @Override\n    public void close()\n    {\n        writeBlockBufferAllocator.close() ;\n        closed = true ;\n    }\n    @Override\n    public boolean isClosed()\n    {\n        return closed ;\n    }\n    private void checkIfClosed()\n    {\n        if ( closed )\n            Log.error(this, \"Already closed: \"+transaction.getTxnId()) ;\n    }\n    private void checkActive()\n    {\n        if ( ! active )\n            Log.error(this, \"Not active: \"+transaction.getTxnId()) ;\n        TxnState state = transaction.getState() ; \n        if ( state != TxnState.ACTIVE && state != TxnState.PREPARING )\n            Log.error(this, \"**** Not active: \"+transaction.getTxnId()) ;\n    }\n    @Override\n    public void sync()\n    {\n        checkIfClosed() ;\n    }\n    @Override\n    public void syncForce()\n    {\n        blockMgr.syncForce() ;\n    }\n    // we only use the underlying blockMgr in read-mode - we don't write back blocks.  \n    @Override\n    public void beginUpdate()           { checkIfClosed() ; blockMgr.beginRead() ; }\n    @Override\n    public void endUpdate()\n    {\n        checkIfClosed() ;\n        blockMgr.endRead() ;\n    }\n    private void writeJournalEntry(Block blk)\n    {\n        blk.getByteBuffer().rewind() ;\n        transaction.getJournal().write(JournalEntryType.Block, fileRef, blk) ;\n    }\n    private void logState()\n    {\n        Log.info(this, \"state: \"+getLabel()) ;\n        Log.info(this, \"  readBlocks:      \"+readBlocks) ;\n        Log.info(this, \"  writeBlocks:     \"+writeBlocks) ;\n        Log.info(this, \"  iteratorBlocks:  \"+iteratorBlocks) ;\n        Log.info(this, \"  freedBlocks:     \"+freedBlocks) ;\n    }\n    @Override\n    public void beginRead()             { checkIfClosed() ; blockMgr.beginRead() ; }\n    @Override\n    public void endRead()               { checkIfClosed() ; blockMgr.endRead() ; }\n    @Override\n    public void beginIterator(Iterator<?> iterator)\n    {\n        checkIfClosed() ; \n        transaction.addIterator(iterator) ;\n        // Don't pass down the beginIterator call - we track and manage here, not lower down.  \n        //blockMgr.beginIterator(iterator) ;\n    }\n<fim_suffix>    @Override\n    public void endIterator(Iterator<?> iterator)\n    {\n        checkIfClosed() ; \n        transaction.removeIterator(iterator) ;\n        // Don't pass down the beginIterator call - we track and manage here, not lower down.  \n        //blockMgr.endIterator(iterator) ;\n    }<fim_middle>// function below has no smell\n"}