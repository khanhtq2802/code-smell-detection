{"text": "<fim_prefix>/*\nCopyright 2011-2016 Google Inc. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\npackage com.google.security.zynamics.zylib.disassembly;\n\nimport java.math.BigInteger;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Strings;\n\n/**\n * This class represents (memory) addresses. It implements the {@code IAddress} interface and\n * provides additional typed overloads for performance.\n * \n * @author cblichmann@google.com (Christian Blichmann)\n */\n<fim_suffix>public class CAddress implements IAddress {\n  private final long m_address;\n\n  public CAddress(final BigInteger address) {\n    Preconditions.checkNotNull(address, \"Address argument can not be null\");\n\n    // longValue() does a narrowing conversion and returns the lower 64 bit\n    // verbatim (i.e. without respect to signedness)\n    m_address = address.longValue();\n  }\n\n  public CAddress(final CAddress address) {\n    Preconditions.checkNotNull(address, \"Address argument can not be null\");\n    m_address = address.m_address;\n  }\n\n  public CAddress(final IAddress address) {\n    Preconditions.checkNotNull(address, \"Address argument can not be null\");\n    m_address = address.toLong();\n  }\n\n  public CAddress(final long address) {\n    m_address = address;\n  }\n\n  /**\n   * Parses the given address {@link String} into a BigInteger and uses this as input for the actual\n   * {@link CAddress}.\n   * \n   * @param address The {@link String} representation of an address.\n   * @param base The base to which the String will be parsed.\n   */\n  public CAddress(final String address, final int base) {\n    Preconditions.checkNotNull(address, \"Address argument can not be null\");\n    Preconditions.checkArgument(base > 0, \"Base must be positive\");\n    m_address = new BigInteger(address, base).longValue();\n  }\n\n  /**\n   * Compares two Java {@code long} values for order, treating the values as unsigned. Returns a\n   * negative integer, zero, or a positive integer as the first specified value is less than, equal\n   * to, or greater than the second specified value.\n   * \n   * @param addr1 the first address to compare\n   * @param addr2 the second address to compare\n   * @return a negative integer, zero, or a positive integer as this object is less than, equal to,\n   *         or greater than the specified object.\n   */\n  public static int compare(final long addr1, final long addr2) {\n    // Perform arithmetic comparison first, resulting in -1, 0 or 1 if\n    // the second value is less than, equal or larger than the first,\n    // respectively.\n    final int result = addr1 < addr2 ? -1 : (addr1 > addr2 ? 1 : 0);\n\n    // If both values have the same sign value, return the result.\n    // Otherwise, one of the two values was negative and we need to \"flip\"\n    // the result.\n    return (addr1 & 0x8000000000000000L) == (addr2 & 0x8000000000000000L) ? result : -result;\n  }\n\n  /**\n   * @see #compareTo(IAddress)\n   */\n  public int compareTo(final CAddress addr) {\n    return compare(m_address, addr.m_address);\n  }\n\n  @Override\n  public int compareTo(final IAddress addr) {\n    return compare(m_address, addr.toLong());\n  }\n\n  /**\n   * @see #compareTo(IAddress)\n   */\n  public int compareTo(final long addr) {\n    return compare(m_address, addr);\n  }\n\n  /**\n   * @see #equals(Object)\n   */\n  public boolean equals(final CAddress address) {\n    return (address != null) && (m_address == address.m_address);\n  }\n\n  /**\n   * @see #equals(Object)\n   */\n  public boolean equals(final IAddress address) {\n    return (address != null) && (m_address == address.toLong());\n  }\n\n  /**\n   * @see #equals(Object)\n   */\n  public boolean equals(final long address) {\n    return m_address == address;\n  }\n\n  @Override\n  public boolean equals(final Object address) {\n    return (address instanceof IAddress) && (m_address == ((IAddress) address).toLong());\n  }\n\n  @Override\n  public int hashCode() {\n    return Long.valueOf(m_address).hashCode();\n  }\n\n  @Override\n  public BigInteger toBigInteger() {\n    // Use valueOf() to provide caching for frequently used values\n    if ((m_address & 0x8000000000000000L) == 0) {\n      return BigInteger.valueOf(m_address);\n    }\n\n    // Long.toHexString() interprets its argument unsigned\n    return new BigInteger(Long.toHexString(m_address), 16);\n  }\n\n  @Override\n  public String toHexString() {\n    // Long.toHexString() interprets its argument unsigned\n    return Strings.padStart(Long.toHexString(m_address).toUpperCase(),\n        (m_address & 0x7fffffffffffffffL) < 0x100000000L ? 8 : 16, '0');\n  }\n\n  @Override\n  public long toLong() {\n    return m_address;\n  }\n\n  @Override\n  public String toString() {\n    return toHexString();\n  }\n}<fim_middle>// class below is blob\n"}