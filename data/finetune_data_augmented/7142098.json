{"text": "<fim_prefix>   */\n  public void addResourcePackageNames(final String... packageNames)\n  {\n    _resourcePackageNames.addAll(Arrays.asList(packageNames));\n  }\n  /**\n   * @param classNames set of class names to be loaded\n   */\n  public void setResourceClassNamesSet(final Set<String> classNames)\n  {\n    if (classNames != null && !classNames.isEmpty())\n    {\n      _resourceClassNames.clear();\n      _resourceClassNames.addAll(classNames);\n    }\n  }\n  /**\n   * @param classNames collection of specific resource class names to be loaded\n   */\n  public void addResourceClassNames(final Collection<String> classNames)\n  {\n    _resourceClassNames.addAll(classNames);\n  }\n  /**\n   * @param classNames array of specific resource class names to be loaded\n   */\n  public void addResourceClassNames(final String... classNames)\n  {\n    _resourceClassNames.addAll(Arrays.asList(classNames));\n  }\n  public URI getServerNodeUri()\n  {\n    return _serverNodeUri;\n  }\n  public void setServerNodeUri(final URI serverNodeUri)\n  {\n    _serverNodeUri = serverNodeUri;\n  }\n  public RestLiDocumentationRequestHandler getDocumentationRequestHandler()\n  {\n    return _documentationRequestHandler;\n  }\n  public void setDocumentationRequestHandler(final RestLiDocumentationRequestHandler handler)\n  {\n    _documentationRequestHandler = handler;\n  }\n  /**\n   * Gets the list of debug request handlers in this Rest.li config.\n   * @return the list of debug request handlers.\n   */\n  public List<RestLiDebugRequestHandler> getDebugRequestHandlers()\n  {\n    return _debugRequestHandlers;\n  }\n  /**\n   * Adds a number of debug request handlers to this Rest.li config.\n   * @param handlers The debug request handlers to add.\n   */\n  public void addDebugRequestHandlers(final RestLiDebugRequestHandler... handlers)\n  {\n    _debugRequestHandlers.addAll(Arrays.asList(handlers));\n  }\n  /**\n   * Adds a number of debug request handlers to this Rest.li config.\n   * @param handlers The debug request handlers to add.\n   */\n  public void addDebugRequestHandlers(final Collection<RestLiDebugRequestHandler> handlers)\n  {\n    _debugRequestHandlers.addAll(handlers);\n  }\n  /**\n   * Sets the list of debug request handlers on this Rest.li config.\n   * @param handlers The debug request handlers to set.\n   */\n  public void setDebugRequestHandlers(final List<RestLiDebugRequestHandler> handlers)\n  {\n    _debugRequestHandlers = new ArrayList<RestLiDebugRequestHandler>(handlers);\n  }\n  /**\n   * Get the multiplexer singleton filter\n   * @return a multiplexer singletson filter\n   */\n  public MultiplexerSingletonFilter getMultiplexerSingletonFilter()\n  {\n    return _multiplexerSingletonFilter;\n  }\n  /**\n   * Set the multiplexer singleton filter.\n   * @param multiplexerSingletonFilter the multiplexer singleton filter to set\n   */\n  public void setMultiplexerSingletonFilter(final MultiplexerSingletonFilter multiplexerSingletonFilter)\n  {\n    _multiplexerSingletonFilter = multiplexerSingletonFilter;\n  }\n  public ErrorResponseFormat getErrorResponseFormat()\n  {\n    return _errorResponseFormat;\n  }\n  public void setErrorResponseFormat(ErrorResponseFormat errorResponseFormat)\n  {\n    this._errorResponseFormat = errorResponseFormat;\n  }\n  public String getInternalErrorMessage()\n  {\n    return _internalErrorMessage;\n  }\n  public void setInternalErrorMessage(String internalErrorMessage)\n  {\n    _internalErrorMessage = internalErrorMessage;\n  }\n  /**\n   * @deprecated There is no longer a notion of strict v.s. relaxed checking. The only check is that the version used\n   * by the client is between {@link com.linkedin.restli.internal.common.AllProtocolVersions#OLDEST_SUPPORTED_PROTOCOL_VERSION}\n   *  and {@link com.linkedin.restli.internal.common.AllProtocolVersions#NEXT_PROTOCOL_VERSION}\n   * @param restliProtocolCheck\n   */\n  @Deprecated\n  public void setRestliProtocolCheck(RestliProtocolCheck restliProtocolCheck)\n  {\n    if (restliProtocolCheck == null)\n    {\n      throw new IllegalArgumentException(\"Cannot be null!\");\n    }\n    _restliProtocolCheck = restliProtocolCheck;\n  }\n  /**\n   * @deprecated There is no longer a notion of strict v.s. relaxed checking. The only check is that the version used\n   * by the client is between {@link com.linkedin.restli.internal.common.AllProtocolVersions#OLDEST_SUPPORTED_PROTOCOL_VERSION}\n   *  and {@link com.linkedin.restli.internal.common.AllProtocolVersions#NEXT_PROTOCOL_VERSION}\n   */\n  @Deprecated\n  public RestliProtocolCheck getRestliProtocolCheck()\n  {\n    return _restliProtocolCheck;\n  }\n  /**\n   * Add filters to the filter list\n   *\n   * @param filters List of filters to be added to the filter list. Filters are the front of the list will be invoked\n   *                first on requests and will be invoked last on responses.\n   */\n  public void addFilter(Filter...filters)\n  {\n    _filters.addAll(Arrays.asList(filters));\n  }\n  /**\n   * Get a mutable reference to the filter list\n   *\n   * @return Mutable reference to the filter list\n   */\n  public List<Filter> getFilters()\n  {\n    return _filters;\n  }\n  /**\n   * Sets the filters stored in the filter list. Filters at the front of the list will be invoked first on requests\n   * and will be invoked last on responses\n   *\n   * @param filters List of filters.\n   */\n  public void setFilters(List<? extends Filter> filters)\n  {\n    if (filters != null) {\n      _filters.clear();\n      _filters.addAll(filters);\n    }\n  }\n  /**\n   * Get the maximum number of individual requests allowed in a multiplexed request.\n   *\n   * @return the maximum number of requests\n   */\n  public int getMaxRequestsMultiplexed()\n  {\n    return _maxRequestsMultiplexed;\n  }\n  /**\n   * Sets the maximum number of individual requests allowed in a multiplexed request.\n   *\n   * @param maxRequestsMultiplexed the maximum number of requests\n   */\n  public void setMaxRequestsMultiplexed(int maxRequestsMultiplexed)\n  {\n    _maxRequestsMultiplexed = maxRequestsMultiplexed;\n  }\n  /**\n   * Get the set of request header names that are allowed to be used in an IndividualRequest of a multiplexed request.\n   * @return a set of request header names\n   */\n  public Set<String> getMultiplexedIndividualRequestHeaderWhitelist()\n  {\n    return _individualRequestHeaderWhitelist;\n  }\n  /**\n   * Set the set of request header names that are allowed to be used in an IndividualRequest of a multiplexed request.\n   * @param headerNames a set of request header names\n   */\n  public void setMultiplexedIndividualRequestHeaderWhitelist(Set<String> headerNames)\n  {\n    _individualRequestHeaderWhitelist = (headerNames != null) ? headerNames : Collections.<String>emptySet();\n  }\n  public MultiplexerRunMode getMultiplexerRunMode()\n  {\n    return _multiplexerRunMode;\n  }\n  /**\n   * Set the MultiplexedRequest run mode. MultiplexerRunMode specifies if all requests belonging to the\n   * {@code MultiplexedRequest} will be executed as a single ParSeq plan ({@link MultiplexerRunMode#SINGLE_PLAN}) or if each request\n   * that belongs to the {@code MultiplexedRequest} will be executed as a separate ParSeq plan ({@link MultiplexerRunMode#MULTIPLE_PLANS}).\n   * {@link MultiplexerRunMode#SINGLE_PLAN} allows optimizations such as batching but it means that all tasks will be\n   * executed in sequence. {@link MultiplexerRunMode#MULTIPLE_PLANS} can potentially speed up execution because requests\n   * can execute physically in parallel but some ParSeq optimization will not work across different plans.\n   * @param multiplexerRunMode\n   */\n  public void setMultiplexerRunMode(MultiplexerRunMode multiplexerRunMode)\n  {\n    _multiplexerRunMode = multiplexerRunMode;\n  }\n  public List<ContentType> getCustomContentTypes()\n  {\n    return _customContentTypes;\n  }\n  /**\n   * Add the given mimeType as a supported Content-Type for the restli server and register the given codec as the one to\n   * use for serialization.\n   * @param mimeType custom Content-Type to add.\n   * @param codec CODEC to use for encoding/decoding.\n   */\n  public void addCustomContentType(String mimeType, DataCodec codec)\n  {\n    assert mimeType != null : \"Mimetype cannot be null\";\n    assert codec != null : \"Codec cannot be null\";\n    _customContentTypes.add(ContentType.createContentType(mimeType.toLowerCase(), codec));\n  }\n  /**\n   * Adds a {@link ResourceDefinitionListener}. The listener is notified when {@link ResourceDefinition}s are initialized.\n   */\n  public void addResourceDefinitionListener(ResourceDefinitionListener listener)\n  {\n    _resourceDefinitionListeners.add(listener);\n  }\n  /**\n   * Gets the <code>ResourceDefinitionListener</code>s.\n   */\n<fim_suffix>  List<ResourceDefinitionListener> getResourceDefinitionListeners()\n  {\n    return _resourceDefinitionListeners;\n  }<fim_middle>// function below has no smell\n"}