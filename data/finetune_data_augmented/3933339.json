{"text": "<fim_prefix>      } catch (Throwable e){\n        // whether the the exception is an error is an application decision\n        // if we catch an exception we decide carefully which one to\n        // throw onwards\n        Throwable exceptionToRethrow = null;\n        // if the exception came from a precall or postcall \n        // we will rethrow it\n        if (!inInvoke) {\n          exceptionToRethrow = e;\n        }\n        // if the exception didn't come from precall or postcall then it\n        // came from invoke\n        // we will rethrow this exception if it is not a runtime\n        // exception, but we must unwrap InvocationTargetExceptions\n        else {\n          if (!(e instanceof RuntimeException)) {\n            exceptionToRethrow = e;\n          }\n        }\n        try {\n          if(listener != null)\n            listener.postInvokeExceptionalReturn(token, method, null, e);\n        } catch (Throwable f) {\n          // we caught an exception from\n          // postInvokeExceptionalReturn\n          // if we haven't already chosen an exception to rethrow then\n          // we will throw this exception\n          if (exceptionToRethrow == null) {\n            exceptionToRethrow = f;\n          }\n        }\n        // if we made it this far without choosing an exception we\n        // should throw e\n        if (exceptionToRethrow == null) {\n          exceptionToRethrow = e;\n        }\n        throw exceptionToRethrow;\n      }\n    }\n    //...original method body\n      </code>\n *  \n *   \n */\npublic abstract class AbstractWovenProxyMethodAdapter extends GeneratorAdapter\n{\n  /** The type of a RuntimeException */\n  private static final Type RUNTIME_EX_TYPE = Type.getType(RuntimeException.class);\n  private static final Type THROWABLE_TYPE = Type.getType(Throwable.class);\n  /** The postInvoke method of an {@link InvocationListener} */\n  private static final Method POST_INVOKE_METHOD = getAsmMethodFromClass(InvocationListener.class, \"postInvoke\", Object.class,\n      Object.class, java.lang.reflect.Method.class, Object.class);\n  /** The postInvokeExceptionalReturn method of an {@link InvocationListener} */\n  private static final Method POST_INVOKE_EXCEPTIONAL_METHOD = getAsmMethodFromClass(InvocationListener.class, \n      \"postInvokeExceptionalReturn\", Object.class, Object.class,\n      java.lang.reflect.Method.class, Throwable.class);\n  /** The preInvoke method of an {@link InvocationListener} */\n  private static final Method PRE_INVOKE_METHOD = getAsmMethodFromClass(InvocationListener.class, \"preInvoke\", Object.class,\n      java.lang.reflect.Method.class, Object[].class);\n  /** The name of the static field that stores our {@link java.lang.reflect.Method} */\n  private final String methodStaticFieldName;\n  /** The current method */\n  protected final Method currentTransformMethod;\n  /** The type of <code>this</code> */\n  protected final Type typeBeingWoven;\n  /** True if this is a void method */\n  private final boolean isVoid;\n  //ints for local store\n  /** The local we use to store the {@link InvocationListener} token */\n  private int preInvokeReturnedToken;\n  /** The local we use to note whether we are in the original method body or not */\n  private int inNormalMethod;\n  /** The local we use to store the invocation target to dispatch to */\n  private int dispatchTarget;\n  /** The local for storing our method's result */\n  private int normalResult;\n  //the Labels we need for jumping around the pre/post/postexception and current method code\n  /** This marks the start of the try/catch around the pre/postInvoke*/\n  private final Label beginTry = new Label();\n  /** This marks the end of the try/catch around the pre/postInvoke*/\n  private final Label endTry = new Label();\n  /** The return type of this method */\n  private final Type returnType;\n  private final Type methodDeclaringType;\n  private final boolean isMethodDeclaringTypeInterface;\n  private boolean isDefaultMethod;\n  /**\n   * Construct a new method adapter\n   * @param mv - the method visitor to write to\n   * @param access - the access modifiers on this method\n   * @param name - the name of this method\n   * @param desc - the descriptor of this method\n   * @param methodStaticFieldName - the name of the static field that will hold\n   *                                the {@link java.lang.reflect.Method} representing\n   *                                this method.\n   * @param currentTransformMethod - the ASM representation of this method\n   * @param proxyType - the type being woven that contains this method\n   */\n  public AbstractWovenProxyMethodAdapter(MethodVisitor mv, int access, String name, String desc,\n      String methodStaticFieldName, Method currentTransformMethod, Type typeBeingWoven,\n      Type methodDeclaringType, boolean isMethodDeclaringTypeInterface, boolean isDefaultMethod)\n  {\n    super(ASM5, mv, access, name, desc);\n    this.methodStaticFieldName = methodStaticFieldName;\n    this.currentTransformMethod = currentTransformMethod;\n    returnType = currentTransformMethod.getReturnType();\n    isVoid = returnType.getSort() == Type.VOID;\n    this.typeBeingWoven = typeBeingWoven;\n    this.methodDeclaringType = methodDeclaringType;\n    this.isMethodDeclaringTypeInterface = isMethodDeclaringTypeInterface;\n    this.isDefaultMethod = isDefaultMethod;\n  }\n  @Override\n  public abstract void visitCode();\n  @Override\n  public abstract void visitMaxs(int stack, int locals);\n  /**\n   * Write out the bytecode instructions necessary to do the dispatch.\n   * We know the dispatcher is non-null, and we need a try/catch around the\n   * invocation and listener calls.\n   */\n  protected final void writeDispatcher() {\n    // Setup locals we will use in the dispatch\n    setupLocals();\n    //Write the try catch block\n    visitTryCatchBlock(beginTry, endTry, endTry, THROWABLE_INAME);\n    mark(beginTry);\n    //Start dispatching, get the target object and store it\n    loadThis();\n    getField(typeBeingWoven, DISPATCHER_FIELD, DISPATCHER_TYPE);\n    invokeInterface(DISPATCHER_TYPE, new Method(\"call\", OBJECT_TYPE, NO_ARGS));\n    storeLocal(dispatchTarget);\n    //Pre-invoke, invoke, post-invoke, return\n    writePreInvoke();\n    //Start the real method\n    push(true);\n    storeLocal(inNormalMethod);\n    //Dispatch the method and store the result (null for void)\n    loadLocal(dispatchTarget);\n    checkCast(methodDeclaringType);\n    loadArgs();\n    if(isMethodDeclaringTypeInterface) {\n      invokeInterface(methodDeclaringType, currentTransformMethod);\n    } else {\n      invokeVirtual(methodDeclaringType, currentTransformMethod);\n    }\n    if(isVoid) {\n      visitInsn(ACONST_NULL);\n    }\n    storeLocal(normalResult);\n    // finish the real method and post-invoke\n    push(false);\n    storeLocal(inNormalMethod);\n    writePostInvoke();\n    //Return, with the return value if necessary\n    if(!!!isVoid) {\n      loadLocal(normalResult);\n    }\n    returnValue();\n    //End of our try, start of our catch\n    mark(endTry);\n    writeMethodCatchHandler();\n  }\n  /**\n   * Setup the normalResult, inNormalMethod, preInvokeReturnedToken and\n   * dispatch target locals.\n   */\n  private final void setupLocals() {\n    if (isVoid){\n      normalResult = newLocal(OBJECT_TYPE);\n    } else{\n      normalResult = newLocal(returnType);\n    }\n    preInvokeReturnedToken = newLocal(OBJECT_TYPE);\n    visitInsn(ACONST_NULL);\n    storeLocal(preInvokeReturnedToken);\n    inNormalMethod = newLocal(Type.BOOLEAN_TYPE);\n    push(false);\n    storeLocal(inNormalMethod);\n    dispatchTarget = newLocal(OBJECT_TYPE);\n    visitInsn(ACONST_NULL);\n    storeLocal(dispatchTarget);\n  }\n  /**\n   * Begin trying to invoke the listener, if the listener is\n   * null the bytecode will branch to the supplied label, other\n   * otherwise it will load the listener onto the stack.\n   * @param l The label to branch to\n   */\n  private final void beginListenerInvocation(Label l) {\n    //If there's no listener then skip invocation\n    loadThis();\n    getField(typeBeingWoven, LISTENER_FIELD, LISTENER_TYPE);\n    ifNull(l);\n    loadThis();\n    getField(typeBeingWoven, LISTENER_FIELD, LISTENER_TYPE);\n  }\n  /**\n   * Write out the preInvoke. This copes with the listener being null\n   */\n<fim_suffix>  private final void writePreInvoke() {\n    //The place to go if the listener is null\n    Label nullListener = newLabel();\n    beginListenerInvocation(nullListener);\n    // The listener is on the stack, we need (target, method, args)\n    loadLocal(dispatchTarget);\n    getStatic(typeBeingWoven, methodStaticFieldName, METHOD_TYPE);\n    loadArgArray();\n    //invoke it and store the token returned\n    invokeInterface(LISTENER_TYPE, PRE_INVOKE_METHOD);\n    storeLocal(preInvokeReturnedToken);\n    mark(nullListener);\n  }<fim_middle>// function below has no smell\n"}