{"text": "<fim_prefix>     * (2) the cursor is not on one of this rowset's rows or its\n     * insert row, or (3) the designated column does not store an\n     * SQL <code>TINYINT, SMALLINT, INTEGER, <b>BIGINT</b>, REAL\n     * FLOAT, DOUBLE, DECIMAL, NUMERIC, BIT, CHAR, VARCHAR</code>\n     * or <code>LONGVARCHAR</code> value. The bold SQL type designates the\n     * recommended return type.\n     * @see #getLong(String)\n     */\n    public long getLong(int columnIndex) throws SQLException {\n        Object value;\n        // sanity check.\n        checkIndex(columnIndex);\n        // make sure the cursor is on a valid row\n        checkCursor();\n        setLastValueNull(false);\n        value = getCurrentRow().getColumnObject(columnIndex);\n        // check for SQL NULL\n        if (value == null) {\n            setLastValueNull(true);\n            return (long)0;\n        }\n        try {\n            return ((Long.valueOf(value.toString().trim())).longValue());\n        } catch (NumberFormatException ex) {\n            throw new SQLException(MessageFormat.format(resBundle.handleGetObject(\"cachedrowsetimpl.longfail\").toString(),\n                  new Object[] {value.toString().trim(), columnIndex}));\n        }\n    }\n    /**\n     * Retrieves the value of the designated column in the current row\n     * of this <code>CachedRowSetImpl</code> object as a\n     * <code>float</code> value.\n     *\n     * @param columnIndex the first column is <code>1</code>, the second\n     *        is <code>2</code>, and so on; must be <code>1</code> or larger\n     *        and equal to or less than the number of columns in the rowset\n     * @return the column value; if the value is SQL <code>NULL</code>, the\n     *         result is <code>0</code>\n     * @throws SQLException if (1) the given column index is out of bounds,\n     * (2) the cursor is not on one of this rowset's rows or its\n     * insert row, or (3) the designated column does not store an\n     * SQL <code>TINYINT, SMALLINT, INTEGER, BIGINT, <b>REAL</b>,\n     * FLOAT, DOUBLE, DECIMAL, NUMERIC, BIT, CHAR, VARCHAR</code>\n     * or <code>LONGVARCHAR</code> value. The bold SQL type designates the\n     * recommended return type.\n     * @see #getFloat(String)\n     */\n    public float getFloat(int columnIndex) throws SQLException {\n        Object value;\n        // sanity check.\n        checkIndex(columnIndex);\n        // make sure the cursor is on a valid row\n        checkCursor();\n        setLastValueNull(false);\n        value = getCurrentRow().getColumnObject(columnIndex);\n        // check for SQL NULL\n        if (value == null) {\n            setLastValueNull(true);\n            return (float)0;\n        }\n        try {\n            return Float.parseFloat(value.toString());\n        } catch (NumberFormatException ex) {\n            throw new SQLException(MessageFormat.format(resBundle.handleGetObject(\"cachedrowsetimpl.floatfail\").toString(),\n                  new Object[] {value.toString().trim(), columnIndex}));\n        }\n    }\n    /**\n     * Retrieves the value of the designated column in the current row\n     * of this <code>CachedRowSetImpl</code> object as a\n     * <code>double</code> value.\n     *\n     * @param columnIndex the first column is <code>1</code>, the second\n     *        is <code>2</code>, and so on; must be <code>1</code> or larger\n     *        and equal to or less than the number of columns in the rowset\n     * @return the column value; if the value is SQL <code>NULL</code>, the\n     *         result is <code>0</code>\n     * @throws SQLException if (1) the given column index is out of bounds,\n     * (2) the cursor is not on one of this rowset's rows or its\n     * insert row, or (3) the designated column does not store an\n     * SQL <code>TINYINT, SMALLINT, INTEGER, BIGINT, REAL,\n     * <b>FLOAT</b>, <b>DOUBLE</b>, DECIMAL, NUMERIC, BIT, CHAR, VARCHAR</code>\n     * or <code>LONGVARCHAR</code> value. The bold SQL type designates the\n     * recommended return type.\n     * @see #getDouble(String)\n     *\n     */\n    public double getDouble(int columnIndex) throws SQLException {\n        Object value;\n        // sanity check.\n        checkIndex(columnIndex);\n        // make sure the cursor is on a valid row\n        checkCursor();\n        setLastValueNull(false);\n        value = getCurrentRow().getColumnObject(columnIndex);\n        // check for SQL NULL\n        if (value == null) {\n            setLastValueNull(true);\n            return (double)0;\n        }\n        try {\n            return Double.parseDouble(value.toString().trim());\n        } catch (NumberFormatException ex) {\n            throw new SQLException(MessageFormat.format(resBundle.handleGetObject(\"cachedrowsetimpl.doublefail\").toString(),\n                  new Object[] {value.toString().trim(), columnIndex}));\n        }\n    }\n    /**\n     * Retrieves the value of the designated column in the current row\n     * of this <code>CachedRowSetImpl</code> object as a\n     * <code>java.math.BigDecimal</code> object.\n     * <P>\n     * This method is deprecated; use the version of <code>getBigDecimal</code>\n     * that does not take a scale parameter and returns a value with full\n     * precision.\n     *\n     * @param columnIndex the first column is <code>1</code>, the second\n     *        is <code>2</code>, and so on; must be <code>1</code> or larger\n     *        and equal to or less than the number of columns in the rowset\n     * @param scale the number of digits to the right of the decimal point in the\n     *        value returned\n     * @return the column value with the specified number of digits to the right\n     *         of the decimal point; if the value is SQL <code>NULL</code>, the\n     *         result is <code>null</code>\n     * @throws SQLException if the given column index is out of bounds,\n     *            the cursor is not on a valid row, or this method fails\n     * @deprecated\n     */\n    @Deprecated\n    public BigDecimal getBigDecimal(int columnIndex, int scale) throws SQLException {\n        Object value;\n        BigDecimal bDecimal, retVal;\n        // sanity check.\n        checkIndex(columnIndex);\n        // make sure the cursor is on a valid row\n        checkCursor();\n        setLastValueNull(false);\n        value = getCurrentRow().getColumnObject(columnIndex);\n        // check for SQL NULL\n        if (value == null) {\n            setLastValueNull(true);\n            return (new BigDecimal(0));\n        }\n        bDecimal = this.getBigDecimal(columnIndex);\n        retVal = bDecimal.setScale(scale);\n        return retVal;\n    }\n    /**\n     * Retrieves the value of the designated column in the current row\n     * of this <code>CachedRowSetImpl</code> object as a\n     * <code>byte</code> array value.\n     *\n     * @param columnIndex the first column is <code>1</code>, the second\n     *        is <code>2</code>, and so on; must be <code>1</code> or larger\n     *        and equal to or less than the number of columns in the rowset\n     * @return the column value as a <code>byte</code> array in the Java programming\n     * language; if the value is SQL <code>NULL</code>, the\n     * result is <code>null</code>\n     *\n     * @throws SQLException if (1) the given column index is out of bounds,\n     * (2) the cursor is not on one of this rowset's rows or its\n     * insert row, or (3) the designated column does not store an\n     * SQL <code><b>BINARY</b>, <b>VARBINARY</b> or\n     * LONGVARBINARY</code> value.\n     * The bold SQL type designates the recommended return type.\n     * @see #getBytes(String)\n     */\n<fim_suffix>    public byte[] getBytes(int columnIndex) throws SQLException {\n        // sanity check.\n        checkIndex(columnIndex);\n        // make sure the cursor is on a valid row\n        checkCursor();\n        if (isBinary(RowSetMD.getColumnType(columnIndex)) == false) {\n            throw new SQLException(resBundle.handleGetObject(\"cachedrowsetimpl.dtypemismt\").toString());\n        }\n        return (byte[])(getCurrentRow().getColumnObject(columnIndex));\n    }<fim_middle>// function below has no smell\n"}