{"text": "<fim_prefix>    if (ttsExtent == null) {\n      return null;\n    }\n    Matcher extentMatcher = PIXEL_COORDINATES.matcher(ttsExtent);\n    if (!extentMatcher.matches()) {\n      Log.w(TAG, \"Ignoring non-pixel tts extent: \" + ttsExtent);\n      return null;\n    }\n    try {\n      int width = Integer.parseInt(extentMatcher.group(1));\n      int height = Integer.parseInt(extentMatcher.group(2));\n      return new TtsExtent(width, height);\n    } catch (NumberFormatException e) {\n      Log.w(TAG, \"Ignoring malformed tts extent: \" + ttsExtent);\n      return null;\n    }\n  }\n  private Map<String, TtmlStyle> parseHeader(\n      XmlPullParser xmlParser,\n      Map<String, TtmlStyle> globalStyles,\n      CellResolution cellResolution,\n      TtsExtent ttsExtent,\n      Map<String, TtmlRegion> globalRegions,\n      Map<String, String> imageMap)\n      throws IOException, XmlPullParserException {\n    do {\n      xmlParser.next();\n      if (XmlPullParserUtil.isStartTag(xmlParser, TtmlNode.TAG_STYLE)) {\n        String parentStyleId = XmlPullParserUtil.getAttributeValue(xmlParser, ATTR_STYLE);\n        TtmlStyle style = parseStyleAttributes(xmlParser, new TtmlStyle());\n        if (parentStyleId != null) {\n          for (String id : parseStyleIds(parentStyleId)) {\n            style.chain(globalStyles.get(id));\n          }\n        }\n        if (style.getId() != null) {\n          globalStyles.put(style.getId(), style);\n        }\n      } else if (XmlPullParserUtil.isStartTag(xmlParser, TtmlNode.TAG_REGION)) {\n        TtmlRegion ttmlRegion = parseRegionAttributes(xmlParser, cellResolution, ttsExtent);\n        if (ttmlRegion != null) {\n          globalRegions.put(ttmlRegion.id, ttmlRegion);\n        }\n      } else if (XmlPullParserUtil.isStartTag(xmlParser, TtmlNode.TAG_METADATA)) {\n        parseMetadata(xmlParser, imageMap);\n      }\n    } while (!XmlPullParserUtil.isEndTag(xmlParser, TtmlNode.TAG_HEAD));\n    return globalStyles;\n  }\n  private void parseMetadata(XmlPullParser xmlParser, Map<String, String> imageMap)\n      throws IOException, XmlPullParserException {\n    do {\n      xmlParser.next();\n      if (XmlPullParserUtil.isStartTag(xmlParser, TtmlNode.TAG_IMAGE)) {\n        String id = XmlPullParserUtil.getAttributeValue(xmlParser, \"id\");\n        if (id != null) {\n          String encodedBitmapData = xmlParser.nextText();\n          imageMap.put(id, encodedBitmapData);\n        }\n      }\n    } while (!XmlPullParserUtil.isEndTag(xmlParser, TtmlNode.TAG_METADATA));\n  }\n  /**\n   * Parses a region declaration.\n   *\n   * <p>Supports both percentage and pixel defined regions. In case of pixel defined regions the\n   * passed {@code ttsExtent} is used as a reference window to convert the pixel values to\n   * fractions. In case of missing tts:extent the pixel defined regions can't be parsed, and null is\n   * returned.\n   */\n<fim_suffix>  private TtmlRegion parseRegionAttributes(\n      XmlPullParser xmlParser, CellResolution cellResolution, TtsExtent ttsExtent) {\n    String regionId = XmlPullParserUtil.getAttributeValue(xmlParser, TtmlNode.ATTR_ID);\n    if (regionId == null) {\n      return null;\n    }\n    float position;\n    float line;\n    String regionOrigin = XmlPullParserUtil.getAttributeValue(xmlParser, TtmlNode.ATTR_TTS_ORIGIN);\n    if (regionOrigin != null) {\n      Matcher originPercentageMatcher = PERCENTAGE_COORDINATES.matcher(regionOrigin);\n      Matcher originPixelMatcher = PIXEL_COORDINATES.matcher(regionOrigin);\n      if (originPercentageMatcher.matches()) {\n        try {\n          position = Float.parseFloat(originPercentageMatcher.group(1)) / 100f;\n          line = Float.parseFloat(originPercentageMatcher.group(2)) / 100f;\n        } catch (NumberFormatException e) {\n          Log.w(TAG, \"Ignoring region with malformed origin: \" + regionOrigin);\n          return null;\n        }\n      } else if (originPixelMatcher.matches()) {\n        if (ttsExtent == null) {\n          Log.w(TAG, \"Ignoring region with missing tts:extent: \" + regionOrigin);\n          return null;\n        }\n        try {\n          int width = Integer.parseInt(originPixelMatcher.group(1));\n          int height = Integer.parseInt(originPixelMatcher.group(2));\n          // Convert pixel values to fractions.\n          position = width / (float) ttsExtent.width;\n          line = height / (float) ttsExtent.height;\n        } catch (NumberFormatException e) {\n          Log.w(TAG, \"Ignoring region with malformed origin: \" + regionOrigin);\n          return null;\n        }\n      } else {\n        Log.w(TAG, \"Ignoring region with unsupported origin: \" + regionOrigin);\n        return null;\n      }\n    } else {\n      Log.w(TAG, \"Ignoring region without an origin\");\n      return null;\n      // TODO: Should default to top left as below in this case, but need to fix\n      // https://github.com/google/ExoPlayer/issues/2953 first.\n      // Origin is omitted. Default to top left.\n      // position = 0;\n      // line = 0;\n    }\n    float width;\n    float height;\n    String regionExtent = XmlPullParserUtil.getAttributeValue(xmlParser, TtmlNode.ATTR_TTS_EXTENT);\n    if (regionExtent != null) {\n      Matcher extentPercentageMatcher = PERCENTAGE_COORDINATES.matcher(regionExtent);\n      Matcher extentPixelMatcher = PIXEL_COORDINATES.matcher(regionExtent);\n      if (extentPercentageMatcher.matches()) {\n        try {\n          width = Float.parseFloat(extentPercentageMatcher.group(1)) / 100f;\n          height = Float.parseFloat(extentPercentageMatcher.group(2)) / 100f;\n        } catch (NumberFormatException e) {\n          Log.w(TAG, \"Ignoring region with malformed extent: \" + regionOrigin);\n          return null;\n        }\n      } else if (extentPixelMatcher.matches()) {\n        if (ttsExtent == null) {\n          Log.w(TAG, \"Ignoring region with missing tts:extent: \" + regionOrigin);\n          return null;\n        }\n        try {\n          int extentWidth = Integer.parseInt(extentPixelMatcher.group(1));\n          int extentHeight = Integer.parseInt(extentPixelMatcher.group(2));\n          // Convert pixel values to fractions.\n          width = extentWidth / (float) ttsExtent.width;\n          height = extentHeight / (float) ttsExtent.height;\n        } catch (NumberFormatException e) {\n          Log.w(TAG, \"Ignoring region with malformed extent: \" + regionOrigin);\n          return null;\n        }\n      } else {\n        Log.w(TAG, \"Ignoring region with unsupported extent: \" + regionOrigin);\n        return null;\n      }\n    } else {\n      Log.w(TAG, \"Ignoring region without an extent\");\n      return null;\n      // TODO: Should default to extent of parent as below in this case, but need to fix\n      // https://github.com/google/ExoPlayer/issues/2953 first.\n      // Extent is omitted. Default to extent of parent.\n      // width = 1;\n      // height = 1;\n    }\n    @Cue.AnchorType int lineAnchor = Cue.ANCHOR_TYPE_START;\n    String displayAlign = XmlPullParserUtil.getAttributeValue(xmlParser,\n        TtmlNode.ATTR_TTS_DISPLAY_ALIGN);\n    if (displayAlign != null) {\n      switch (Util.toLowerInvariant(displayAlign)) {\n        case \"center\":\n          lineAnchor = Cue.ANCHOR_TYPE_MIDDLE;\n          line += height / 2;\n          break;\n        case \"after\":\n          lineAnchor = Cue.ANCHOR_TYPE_END;\n          line += height;\n          break;\n        default:\n          // Default \"before\" case. Do nothing.\n          break;\n      }\n    }\n    float regionTextHeight = 1.0f / cellResolution.rows;\n    return new TtmlRegion(\n        regionId,\n        position,\n        line,\n        /* lineType= */ Cue.LINE_TYPE_FRACTION,\n        lineAnchor,\n        width,\n        /* textSizeType= */ Cue.TEXT_SIZE_TYPE_FRACTIONAL_IGNORE_PADDING,\n        /* textSize= */ regionTextHeight);\n  }<fim_middle>// function below is feature envy and long method\n"}