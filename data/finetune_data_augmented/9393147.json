{"text": "<fim_prefix>/*\n * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\npackage jdk.jfr.internal.instrument;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport jdk.internal.org.objectweb.asm.Label;\nimport jdk.internal.org.objectweb.asm.MethodVisitor;\nimport jdk.internal.org.objectweb.asm.Opcodes;\nimport jdk.internal.org.objectweb.asm.commons.LocalVariablesSorter;\nimport jdk.internal.org.objectweb.asm.commons.Remapper;\nimport jdk.internal.org.objectweb.asm.commons.SimpleRemapper;\nimport jdk.internal.org.objectweb.asm.tree.MethodNode;\nimport jdk.jfr.internal.LogLevel;\nimport jdk.jfr.internal.LogTag;\nimport jdk.jfr.internal.Logger;\n\n/**\n * Class responsible for finding the call to inline and inlining it.\n *\n * This code is heavily influenced by section 3.2.6 \"Inline Method\" in\n * \"Using ASM framework to implement common bytecode transformation patterns\",\n * E. Kuleshov, AOSD.07, March 2007, Vancouver, Canada.\n * http://asm.ow2.org/index.html\n */\n@Deprecated\nfinal class JIMethodCallInliner extends LocalVariablesSorter {\n\n    private final String oldClass;\n    private final String newClass;\n    private final MethodNode inlineTarget;\n    private final List<CatchBlock> blocks = new ArrayList<>();\n    private boolean inlining;\n\n    /**\n     * inlineTarget defines the method to inline and also contains the actual\n     * code to inline.\n     *\n     * @param access\n     * @param desc\n     * @param mv\n     * @param inlineTarget\n     * @param oldClass\n     * @param newClass\n     * @param logger\n     */\n    public JIMethodCallInliner(int access, String desc, MethodVisitor mv,\n            MethodNode inlineTarget, String oldClass, String newClass) {\n        super(Opcodes.ASM7, access, desc, mv);\n        this.oldClass = oldClass;\n        this.newClass = newClass;\n        this.inlineTarget = inlineTarget;\n\n        Logger.log(LogTag.JFR_SYSTEM_BYTECODE, LogLevel.DEBUG, \"MethodCallInliner: targetMethod=\" + newClass + \".\"\n                + inlineTarget.name + inlineTarget.desc);\n    }\n\n    @Override\n    public void visitMethodInsn(int opcode, String owner, String name,\n            String desc, boolean itf) {\n        // Now we are looking at method call in the source method\n        if (!shouldBeInlined(owner, name, desc)) {\n            // If this method call should not be inlined, just keep it\n            mv.visitMethodInsn(opcode, owner, name, desc, itf);\n            return;\n        }\n        // If the call should be inlined, we create a MethodInliningAdapter\n        // The MIA will walk the instructions in the inlineTarget and add them\n        // to the current method, doing the necessary name remappings.\n        Logger.log(LogTag.JFR_SYSTEM_BYTECODE, LogLevel.DEBUG, \"Inlining call to \" + name + desc);\n        Remapper remapper = new SimpleRemapper(oldClass, newClass);\n        Label end = new Label();\n        inlining = true;\n        inlineTarget.instructions.resetLabels();\n        JIMethodInliningAdapter mia = new JIMethodInliningAdapter(this, end,\n                opcode == Opcodes.INVOKESTATIC ? Opcodes.ACC_STATIC : 0, desc,\n                remapper);\n        inlineTarget.accept(mia);\n        inlining = false;\n        super.visitLabel(end);\n    }\n\n    /**\n     * Determine if the method should be inlined or not.\n     */\n    private boolean shouldBeInlined(String owner, String name, String desc) {\n        return inlineTarget.desc.equals(desc) && inlineTarget.name.equals(name)\n                && owner.equals(newClass.replace('.', '/'));\n    }\n\n<fim_suffix>    @Override\n    public void visitTryCatchBlock(Label start, Label end, Label handler,\n            String type) {\n        if (!inlining) {\n            // try-catch blocks are saved here and replayed at the end\n            // of the method (in visitMaxs)\n            blocks.add(new CatchBlock(start, end, handler, type));\n        } else {\n            super.visitTryCatchBlock(start, end, handler, type);\n        }\n    }\n\n    @Override\n    public void visitMaxs(int stack, int locals) {\n        for (CatchBlock b : blocks) {\n            super.visitTryCatchBlock(b.start, b.end, b.handler, b.type);\n        }\n        super.visitMaxs(stack, locals);\n    }\n\n    static final class CatchBlock {\n\n        final Label start;\n        final Label end;\n        final Label handler;\n        final String type;\n\n        CatchBlock(Label start, Label end, Label handler, String type) {\n            this.start = start;\n            this.end = end;\n            this.handler = handler;\n            this.type = type;\n        }\n    }\n}<fim_middle>// function below has no smell\n"}