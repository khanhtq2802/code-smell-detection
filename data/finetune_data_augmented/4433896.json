{"text": "<fim_prefix> * Singleton.\n */\n<fim_suffix>public final class InMemoryStateStore extends AbstractStateStore {\n    private Map<String, EntityState> entityStates = new HashMap<>();\n    // Keep it sorted\n    private SortedMap<String, InstanceState> instanceStates = Collections\n            .synchronizedSortedMap(new TreeMap<String, InstanceState>());\n    private static final StateStore STORE = new InMemoryStateStore();\n    private InMemoryStateStore() {}\n    public static StateStore get() {\n        return STORE;\n    }\n    @Override\n    public void putEntity(EntityState entityState) throws StateStoreException {\n        String key = new EntityID(entityState.getEntity()).getKey();\n        if (entityStates.containsKey(key)) {\n            throw new StateStoreException(\"Entity with key, \" + key + \" already exists.\");\n        }\n        entityStates.put(key, entityState);\n    }\n    @Override\n    public EntityState getEntity(EntityID entityId) throws StateStoreException {\n        if (!entityStates.containsKey(entityId.getKey())) {\n            throw new StateStoreException(\"Entity with key, \" + entityId + \" does not exist.\");\n        }\n        return entityStates.get(entityId.getKey());\n    }\n    @Override\n    public boolean entityExists(EntityID entityId) {\n        return entityStates.containsKey(entityId.getKey());\n    }\n    @Override\n    public Collection<Entity> getEntities(EntityState.STATE state) {\n        Collection<Entity> entities = new ArrayList<>();\n        for (EntityState entityState : entityStates.values()) {\n            if (entityState.getCurrentState().equals(state)) {\n                entities.add(entityState.getEntity());\n            }\n        }\n        return entities;\n    }\n    @Override\n    public Collection<EntityState> getAllEntities() {\n        return entityStates.values();\n    }\n    @Override\n    public void updateEntity(EntityState entityState) throws StateStoreException {\n        String key = new EntityID(entityState.getEntity()).getKey();\n        if (!entityStates.containsKey(key)) {\n            throw new StateStoreException(\"Entity with key, \" + key + \" does not exist.\");\n        }\n        entityStates.put(key, entityState);\n    }\n    @Override\n    public void deleteEntity(EntityID entityId) throws StateStoreException {\n        if (!entityStates.containsKey(entityId.getKey())) {\n            throw new StateStoreException(\"Entity with key, \" + entityId + \" does not exist.\");\n        }\n        deleteExecutionInstances(entityId);\n        entityStates.remove(entityId.getKey());\n    }\n    @Override\n    public void deleteEntities() throws StateStoreException {\n        entityStates.clear();\n    }\n    @Override\n    public boolean isEntityCompleted(EntityID entityId) {\n        // ToDo need to implement this, currently returning false.\n        return false;\n    }\n    @Override\n    public void putExecutionInstance(InstanceState instanceState) throws StateStoreException {\n        String key = new InstanceID(instanceState.getInstance()).getKey();\n        if (instanceStates.containsKey(key)) {\n            throw new StateStoreException(\"Instance with key, \" + key + \" already exists.\");\n        }\n        instanceStates.put(key, instanceState);\n    }\n    @Override\n    public InstanceState getExecutionInstance(InstanceID instanceId) throws StateStoreException {\n        if (!instanceStates.containsKey(instanceId.getKey())) {\n            throw new StateStoreException(\"Instance with key, \" + instanceId + \" does not exist.\");\n        }\n        return instanceStates.get(instanceId.toString());\n    }\n    @Override\n    public InstanceState getExecutionInstance(String externalID) throws StateStoreException {\n        if (StringUtils.isEmpty(externalID)) {\n            throw new StateStoreException(\"External ID for retrieving instance cannot be null\");\n        }\n        for (InstanceState instanceState : instanceStates.values()) {\n            if (externalID.equals(instanceState.getInstance().getExternalID())) {\n                return instanceState;\n            }\n        }\n        return null;\n    }\n    @Override\n    public void updateExecutionInstance(InstanceState instanceState) throws StateStoreException {\n        String key = new InstanceID(instanceState.getInstance()).getKey();\n        if (!instanceStates.containsKey(key)) {\n            throw new StateStoreException(\"Instance with key, \" + key + \" does not exist.\");\n        }\n        instanceStates.put(key, instanceState);\n    }\n    @Override\n    public Collection<InstanceState> getAllExecutionInstances(Entity entity, String cluster)\n        throws StateStoreException {\n        EntityClusterID id = new EntityClusterID(entity, cluster);\n        if (!entityStates.containsKey(id.getEntityID().getKey())) {\n            throw new StateStoreException(\"Entity with key, \" + id.getEntityID().getKey() + \" does not exist.\");\n        }\n        Collection<InstanceState> instances = new ArrayList<>();\n        for (Map.Entry<String, InstanceState> instanceState : instanceStates.entrySet()) {\n            if (instanceState.getKey().startsWith(id.toString())) {\n                instances.add(instanceState.getValue());\n            }\n        }\n        return instances;\n    }\n    @Override\n    public Collection<InstanceState> getExecutionInstances(Entity entity, String cluster,\n            Collection<InstanceState.STATE> states) throws StateStoreException {\n        EntityClusterID id = new EntityClusterID(entity, cluster);\n        return getExecutionInstances(id, states);\n    }\n    @Override\n    public Collection<InstanceState> getExecutionInstances(Entity entity, String cluster,\n            Collection<InstanceState.STATE> states, DateTime start, DateTime end) throws StateStoreException {\n        List<InstanceState> instancesToReturn = new ArrayList<>();\n        EntityClusterID id = new EntityClusterID(entity, cluster);\n        for (InstanceState state : getExecutionInstances(id, states)) {\n            ExecutionInstance instance = state.getInstance();\n            DateTime instanceTime = instance.getInstanceTime();\n            // Start date inclusive and end date exclusive.\n            // If start date and end date are equal no instances will be added.\n            if ((instanceTime.isEqual(start) || instanceTime.isAfter(start))\n                    && instanceTime.isBefore(end)) {\n                instancesToReturn.add(state);\n            }\n        }\n        return instancesToReturn;\n    }\n    @Override\n    public Collection<InstanceState> getExecutionInstances(EntityClusterID entityId,\n                                       Collection<InstanceState.STATE> states) throws StateStoreException {\n        Collection<InstanceState> instances = new ArrayList<>();\n        for (Map.Entry<String, InstanceState> instanceState : instanceStates.entrySet()) {\n            if (instanceState.getKey().startsWith(entityId.toString())\n                    && states.contains(instanceState.getValue().getCurrentState())) {\n                instances.add(instanceState.getValue());\n            }\n        }\n        return instances;\n    }\n    @Override\n    public Map<InstanceState.STATE, Long> getExecutionInstanceSummary(Entity entity, String cluster,\n            DateTime start, DateTime end) throws StateStoreException {\n        Map<InstanceState.STATE, Long> summary = new HashMap<>();\n        for (InstanceState state : getAllExecutionInstances(entity, cluster)) {\n            ExecutionInstance instance = state.getInstance();\n            DateTime instanceTime = instance.getInstanceTime();\n            // Start date inclusive and end date exclusive.\n            // If start date and end date are equal no instances will be added.\n            if ((instanceTime.isEqual(start) || instanceTime.isAfter(start))\n                    && instanceTime.isBefore(end)) {\n                if (summary.containsKey(state.getCurrentState())) {\n                    summary.put(state.getCurrentState(), summary.get(state.getCurrentState()) + 1L);\n                } else {\n                    summary.put(state.getCurrentState(), 1L);\n                }\n            }\n        }\n        return summary;\n    }\n    @Override\n    public InstanceState getLastExecutionInstance(Entity entity, String cluster) throws StateStoreException {\n        EntityClusterID id = new EntityClusterID(entity, cluster);\n        if (!entityStates.containsKey(id.getEntityID().getKey())) {\n            throw new StateStoreException(\"Entity with key, \" + id.getEntityID().getKey() + \" does not exist.\");\n        }\n        InstanceState latestState = null;\n        // TODO : Very crude. Iterating over all entries and getting the last one.\n        for (Map.Entry<String, InstanceState> instanceState : instanceStates.entrySet()) {\n            if (instanceState.getKey().startsWith(id.toString())) {\n                latestState = instanceState.getValue();\n            }\n        }\n        return latestState;\n    }\n    @Override\n    public boolean executionInstanceExists(InstanceID instanceId) {\n        return instanceStates.containsKey(instanceId.toString());\n    }\n    @Override\n    public void deleteExecutionInstances(EntityID entityId) {\n        for (String instanceKey : Lists.newArrayList(instanceStates.keySet())) {\n            if (instanceKey.startsWith(entityId.getKey())) {\n                instanceStates.remove(instanceKey);\n            }\n        }\n    }\n    @Override\n    public void deleteExecutionInstances() {\n        instanceStates.clear();\n    }\n    @Override\n    public void deleteExecutionInstance(InstanceID instanceID) throws StateStoreException {\n        if (!instanceStates.containsKey(instanceID.toString())) {\n            throw new StateStoreException(\"Instance with key, \" + instanceID.toString() + \" does not exist.\");\n        }\n        instanceStates.remove(instanceID.toString());\n    }\n    @Override\n    public void clear() {\n        entityStates.clear();\n        instanceStates.clear();\n    }\n}<fim_middle>// class below has no smell\n"}