{"text": "<fim_prefix>/*\n * Copyright 2012-2019 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.springframework.boot.devtools.remote.client;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy.Type;\nimport java.net.URL;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.springframework.beans.factory.InitializingBean;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.boot.devtools.autoconfigure.DevToolsProperties;\nimport org.springframework.boot.devtools.autoconfigure.DevToolsProperties.Restart;\nimport org.springframework.boot.devtools.autoconfigure.OptionalLiveReloadServer;\nimport org.springframework.boot.devtools.autoconfigure.RemoteDevToolsProperties;\nimport org.springframework.boot.devtools.autoconfigure.RemoteDevToolsProperties.Proxy;\nimport org.springframework.boot.devtools.autoconfigure.TriggerFileFilter;\nimport org.springframework.boot.devtools.classpath.ClassPathChangedEvent;\nimport org.springframework.boot.devtools.classpath.ClassPathFileSystemWatcher;\nimport org.springframework.boot.devtools.classpath.ClassPathRestartStrategy;\nimport org.springframework.boot.devtools.classpath.PatternClassPathRestartStrategy;\nimport org.springframework.boot.devtools.filewatch.FileSystemWatcher;\nimport org.springframework.boot.devtools.filewatch.FileSystemWatcherFactory;\nimport org.springframework.boot.devtools.livereload.LiveReloadServer;\nimport org.springframework.boot.devtools.restart.DefaultRestartInitializer;\nimport org.springframework.boot.devtools.restart.RestartScope;\nimport org.springframework.boot.devtools.restart.Restarter;\nimport org.springframework.context.ApplicationListener;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.support.PropertySourcesPlaceholderConfigurer;\nimport org.springframework.http.client.ClientHttpRequestFactory;\nimport org.springframework.http.client.ClientHttpRequestInterceptor;\nimport org.springframework.http.client.InterceptingClientHttpRequestFactory;\nimport org.springframework.http.client.SimpleClientHttpRequestFactory;\nimport org.springframework.util.Assert;\nimport org.springframework.util.StringUtils;\n/**\n * Configuration used to connect to remote Spring Boot applications.\n *\n * @author Phillip Webb\n * @since 1.3.0\n * @see org.springframework.boot.devtools.RemoteSpringApplication\n */\n@Configuration(proxyBeanMethods = false)\n@EnableConfigurationProperties(DevToolsProperties.class)\npublic class RemoteClientConfiguration implements InitializingBean {\n\tprivate static final Log logger = LogFactory.getLog(RemoteClientConfiguration.class);\n\tprivate final DevToolsProperties properties;\n\t@Value(\"${remoteUrl}\")\n\tprivate String remoteUrl;\n\tpublic RemoteClientConfiguration(DevToolsProperties properties) {\n\t\tthis.properties = properties;\n\t}\n\t@Bean\n\tpublic static PropertySourcesPlaceholderConfigurer propertySourcesPlaceholderConfigurer() {\n\t\treturn new PropertySourcesPlaceholderConfigurer();\n\t}\n\t@Bean\n\tpublic ClientHttpRequestFactory clientHttpRequestFactory() {\n\t\tList<ClientHttpRequestInterceptor> interceptors = Arrays\n\t\t\t\t.asList(getSecurityInterceptor());\n\t\tSimpleClientHttpRequestFactory requestFactory = new SimpleClientHttpRequestFactory();\n\t\tProxy proxy = this.properties.getRemote().getProxy();\n\t\tif (proxy.getHost() != null && proxy.getPort() != null) {\n\t\t\trequestFactory.setProxy(new java.net.Proxy(Type.HTTP,\n\t\t\t\t\tnew InetSocketAddress(proxy.getHost(), proxy.getPort())));\n\t\t}\n\t\treturn new InterceptingClientHttpRequestFactory(requestFactory, interceptors);\n\t}\n\tprivate ClientHttpRequestInterceptor getSecurityInterceptor() {\n\t\tRemoteDevToolsProperties remoteProperties = this.properties.getRemote();\n\t\tString secretHeaderName = remoteProperties.getSecretHeaderName();\n\t\tString secret = remoteProperties.getSecret();\n\t\tAssert.state(secret != null,\n\t\t\t\t\"The environment value 'spring.devtools.remote.secret' \"\n\t\t\t\t\t\t+ \"is required to secure your connection.\");\n\t\treturn new HttpHeaderInterceptor(secretHeaderName, secret);\n\t}\n\t@Override\n\tpublic void afterPropertiesSet() {\n\t\tlogWarnings();\n\t}\n\tprivate void logWarnings() {\n\t\tRemoteDevToolsProperties remoteProperties = this.properties.getRemote();\n\t\tif (!remoteProperties.getRestart().isEnabled()) {\n\t\t\tlogger.warn(\"Remote restart is disabled.\");\n\t\t}\n\t\tif (!this.remoteUrl.startsWith(\"https://\")) {\n\t\t\tlogger.warn(\"The connection to \" + this.remoteUrl\n\t\t\t\t\t+ \" is insecure. You should use a URL starting with 'https://'.\");\n\t\t}\n\t}\n\t/**\n\t * LiveReload configuration.\n\t */\n\t@Configuration(proxyBeanMethods = false)\n\t@ConditionalOnProperty(prefix = \"spring.devtools.livereload\", name = \"enabled\", matchIfMissing = true)\n\tstatic class LiveReloadConfiguration {\n\t\t@Autowired\n\t\tprivate DevToolsProperties properties;\n\t\t@Autowired(required = false)\n\t\tprivate LiveReloadServer liveReloadServer;\n\t\t@Autowired\n\t\tprivate ClientHttpRequestFactory clientHttpRequestFactory;\n\t\t@Value(\"${remoteUrl}\")\n\t\tprivate String remoteUrl;\n\t\tprivate ExecutorService executor = Executors.newSingleThreadExecutor();\n\t\t@Bean\n\t\t@RestartScope\n\t\t@ConditionalOnMissingBean\n\t\tpublic LiveReloadServer liveReloadServer() {\n\t\t\treturn new LiveReloadServer(this.properties.getLivereload().getPort(),\n\t\t\t\t\tRestarter.getInstance().getThreadFactory());\n\t\t}\n\t\t@Bean\n\t\tpublic ApplicationListener<ClassPathChangedEvent> liveReloadTriggeringClassPathChangedEventListener(\n\t\t\t\tOptionalLiveReloadServer optionalLiveReloadServer) {\n\t\t\treturn (event) -> {\n\t\t\t\tString url = this.remoteUrl\n\t\t\t\t\t\t+ this.properties.getRemote().getContextPath();\n\t\t\t\tthis.executor.execute(new DelayedLiveReloadTrigger(\n\t\t\t\t\t\toptionalLiveReloadServer, this.clientHttpRequestFactory, url));\n\t\t\t};\n\t\t}\n\t\t@Bean\n\t\tpublic OptionalLiveReloadServer optionalLiveReloadServer() {\n\t\t\treturn new OptionalLiveReloadServer(this.liveReloadServer);\n\t\t}\n\t\tfinal ExecutorService getExecutor() {\n\t\t\treturn this.executor;\n\t\t}\n\t}\n\t/**\n\t * Client configuration for remote update and restarts.\n\t */\n\t@Configuration(proxyBeanMethods = false)\n\t@ConditionalOnProperty(prefix = \"spring.devtools.remote.restart\", name = \"enabled\", matchIfMissing = true)\n\tstatic class RemoteRestartClientConfiguration {\n\t\t@Autowired\n\t\tprivate DevToolsProperties properties;\n\t\t@Value(\"${remoteUrl}\")\n\t\tprivate String remoteUrl;\n<fim_suffix>\t\t@Bean\n\t\tpublic ClassPathFileSystemWatcher classPathFileSystemWatcher(\n\t\t\t\tFileSystemWatcherFactory fileSystemWatcherFactory,\n\t\t\t\tClassPathRestartStrategy classPathRestartStrategy) {\n\t\t\tDefaultRestartInitializer restartInitializer = new DefaultRestartInitializer();\n\t\t\tURL[] urls = restartInitializer.getInitialUrls(Thread.currentThread());\n\t\t\tif (urls == null) {\n\t\t\t\turls = new URL[0];\n\t\t\t}\n\t\t\treturn new ClassPathFileSystemWatcher(fileSystemWatcherFactory,\n\t\t\t\t\tclassPathRestartStrategy, urls);\n\t\t}\n\t\t@Bean\n\t\tpublic FileSystemWatcherFactory getFileSystemWatcherFactory() {\n\t\t\treturn this::newFileSystemWatcher;\n\t\t}\n\t\tprivate FileSystemWatcher newFileSystemWatcher() {\n\t\t\tRestart restartProperties = this.properties.getRestart();\n\t\t\tFileSystemWatcher watcher = new FileSystemWatcher(true,\n\t\t\t\t\trestartProperties.getPollInterval(),\n\t\t\t\t\trestartProperties.getQuietPeriod());\n\t\t\tString triggerFile = restartProperties.getTriggerFile();\n\t\t\tif (StringUtils.hasLength(triggerFile)) {\n\t\t\t\twatcher.setTriggerFilter(new TriggerFileFilter(triggerFile));\n\t\t\t}\n\t\t\treturn watcher;\n\t\t}\n\t\t@Bean\n\t\tpublic ClassPathRestartStrategy classPathRestartStrategy() {\n\t\t\treturn new PatternClassPathRestartStrategy(<fim_middle>// function below has no smell\n"}