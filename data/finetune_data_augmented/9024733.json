{"text": "<fim_prefix>              (cmd.getVersion() == 0 ? versionOnUpdate : cmd.getVersion()), cmd.prevVersion, lastFoundVersion,\n              isReplayOrPeersync, cmd.getPrintableId());\n        }\n        while (Math.abs(lastFoundVersion) < cmd.prevVersion && !waitTimeout.hasTimedOut()) {\n          bucket.awaitNanos(waitTimeout.timeLeft(TimeUnit.NANOSECONDS));\n          lookedUpVersion = vinfo.lookupVersion(cmd.getIndexedId());\n          lastFoundVersion = lookedUpVersion == null ? 0L : lookedUpVersion;\n        }\n      } finally {\n        bucket.unlock();\n        vinfo.unlockForUpdate();\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to get version bucket lock in \" + bucket.getLockTimeoutMs() + \" ms\");\n    }\n    if (Math.abs(lastFoundVersion) > cmd.prevVersion) {\n      // This must've been the case due to a higher version full update succeeding concurrently, while we were waiting or\n      // trying to index this partial update. Since a full update more recent than this partial update has succeeded,\n      // we can drop the current update.\n      if (log.isDebugEnabled()) {\n        log.debug(\"Update was applied on version: {}, but last version I have is: {}\"\n            + \". Current update should be dropped. id={}\", cmd.prevVersion, lastFoundVersion, cmd.getPrintableId());\n      }\n      return -1;\n    } else if (Math.abs(lastFoundVersion) == cmd.prevVersion) {\n      assert 0 < lastFoundVersion : \"prevVersion \" + cmd.prevVersion + \" found but is a delete!\";\n      if (log.isDebugEnabled()) {\n        log.debug(\"Dependent update found. id={}\", cmd.getPrintableId());\n      }\n      return lastFoundVersion;\n    }\n    // We have waited enough, but dependent update didn't arrive. Its time to actively fetch it from leader\n    log.info(\"Missing update, on which current in-place update depends on, hasn't arrived. id={}, looking for version={}, last found version={}\", \n        cmd.getPrintableId(), cmd.prevVersion, lastFoundVersion);\n    UpdateCommand missingUpdate = fetchFullUpdateFromLeader(cmd, versionOnUpdate);\n    if (missingUpdate instanceof DeleteUpdateCommand) {\n      log.info(\"Tried to fetch document {} from the leader, but the leader says document has been deleted. \" \n          + \"Deleting the document here and skipping this update: Last found version: {}, was looking for: {}\", cmd.getPrintableId(), lastFoundVersion, cmd.prevVersion);\n      versionDelete((DeleteUpdateCommand)missingUpdate);\n      return -1;\n    } else {\n      assert missingUpdate instanceof AddUpdateCommand;\n      log.debug(\"Fetched the document: {}\", ((AddUpdateCommand)missingUpdate).getSolrInputDocument());\n      versionAdd((AddUpdateCommand)missingUpdate);\n      log.info(\"Added the fetched document, id=\"+((AddUpdateCommand)missingUpdate).getPrintableId()+\", version=\"+missingUpdate.getVersion());\n    }\n    return missingUpdate.getVersion();\n  }\n  /**\n   * This method is used when an update on which a particular in-place update has been lost for some reason. This method\n   * sends a request to the shard leader to fetch the latest full document as seen on the leader.\n   * @return AddUpdateCommand containing latest full doc at shard leader for the given id, or null if not found.\n   */\n  private UpdateCommand fetchFullUpdateFromLeader(AddUpdateCommand inplaceAdd, long versionOnUpdate) throws IOException {\n    String id = inplaceAdd.getPrintableId();\n    UpdateShardHandler updateShardHandler = inplaceAdd.getReq().getCore().getCoreContainer().getUpdateShardHandler();\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(DISTRIB, false);\n    params.set(\"getInputDocument\", id);\n    params.set(\"onlyIfActive\", true);\n    SolrRequest<SimpleSolrResponse> ur = new GenericSolrRequest(METHOD.GET, \"/get\", params);\n    String leaderUrl = getLeaderUrl(id);\n    if(leaderUrl == null) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Can't find document with id=\" + id);\n    }\n    NamedList<Object> rsp;\n    try {\n      ur.setBasePath(leaderUrl);\n      rsp = updateShardHandler.getUpdateOnlyHttpClient().request(ur);\n    } catch (SolrServerException e) {\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during fetching [\" + id +\n          \"] from leader (\" + leaderUrl + \"): \", e);\n    }\n    Object inputDocObj = rsp.get(\"inputDocument\");\n    Long version = (Long)rsp.get(\"version\");\n    SolrInputDocument leaderDoc = (SolrInputDocument) inputDocObj;\n    if (leaderDoc == null) {\n      // this doc was not found (deleted) on the leader. Lets delete it here as well.\n      DeleteUpdateCommand del = new DeleteUpdateCommand(inplaceAdd.getReq());\n      del.setIndexedId(inplaceAdd.getIndexedId());\n      del.setId(inplaceAdd.getIndexedId().utf8ToString());\n      del.setVersion((version == null || version == 0)? -versionOnUpdate: version);\n      return del;\n    }\n    AddUpdateCommand cmd = new AddUpdateCommand(req);\n    cmd.solrDoc = leaderDoc;\n    cmd.setVersion((long)leaderDoc.getFieldValue(CommonParams.VERSION_FIELD));\n    return cmd;\n  }\n  // TODO: may want to switch to using optimistic locking in the future for better concurrency\n  // that's why this code is here... need to retry in a loop closely around/in versionAdd\n  boolean getUpdatedDocument(AddUpdateCommand cmd, long versionOnUpdate) throws IOException {\n    if (!AtomicUpdateDocumentMerger.isAtomicUpdate(cmd)) return false;\n    Set<String> inPlaceUpdatedFields = AtomicUpdateDocumentMerger.computeInPlaceUpdatableFields(cmd);\n    if (inPlaceUpdatedFields.size() > 0) { // non-empty means this is suitable for in-place updates\n      if (docMerger.doInPlaceUpdateMerge(cmd, inPlaceUpdatedFields)) {\n        return true;\n      } else {\n        // in-place update failed, so fall through and re-try the same with a full atomic update\n      }\n    }\n    // full (non-inplace) atomic update\n    SolrInputDocument sdoc = cmd.getSolrInputDocument();\n    BytesRef id = cmd.getIndexedId();\n    SolrInputDocument oldDoc = RealTimeGetComponent.getInputDocument(cmd.getReq().getCore(), id);\n    if (oldDoc == null) {\n      // create a new doc by default if an old one wasn't found\n      if (versionOnUpdate <= 0) {\n        oldDoc = new SolrInputDocument();\n      } else {\n        // could just let the optimistic locking throw the error\n        throw new SolrException(ErrorCode.CONFLICT, \"Document not found for update.  id=\" + cmd.getPrintableId());\n      }\n    } else {\n      oldDoc.remove(CommonParams.VERSION_FIELD);\n    }\n    cmd.solrDoc = docMerger.merge(sdoc, oldDoc);\n    return true;\n  }\n  @Override\n  public void processDelete(DeleteUpdateCommand cmd) throws IOException {\n    assert TestInjection.injectFailUpdateRequests();\n    updateCommand = cmd;\n    if (!cmd.isDeleteById()) {\n      doDeleteByQuery(cmd);\n    } else {\n      doDeleteById(cmd);\n    }\n  }\n  // Implementing min_rf here was a bit tricky. When a request comes in for a delete by id to a replica that does _not_\n  // have any documents specified by those IDs, the request is not forwarded to any other replicas on that shard. Thus\n  // we have to spoof the replicationTracker and set the achieved rf to the number of active replicas.\n  //\n<fim_suffix>  protected void doDeleteById(DeleteUpdateCommand cmd) throws IOException {\n    setupRequest(cmd);\n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd  = versionDelete(cmd);\n    }\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n    doDistribDeleteById(cmd);\n    // cmd.getIndexId == null when delete by query\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && cmd.getIndexedId() != null && idField != null) {\n      if (deleteResponse == null) {\n        deleteResponse = new NamedList<>(1);\n        rsp.add(\"deletes\",deleteResponse);\n      }\n      if (scratch == null) scratch = new CharsRefBuilder();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      deleteResponse.add(scratch.toString(), cmd.getVersion());  // we're returning the version of the delete.. not the version of the doc we deleted.\n    }\n  }<fim_middle>// function below has no smell\n"}