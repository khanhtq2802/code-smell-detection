{"text": "<fim_prefix>/*\n * Copyright 2014-present Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License. You may obtain\n * a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage com.facebook.buck.android.packageable;\nimport com.facebook.buck.android.apkmodule.APKModule;\nimport com.facebook.buck.android.apkmodule.APKModuleGraph;\nimport com.facebook.buck.android.packageable.AndroidPackageableCollection.ResourceDetails;\nimport com.facebook.buck.core.exceptions.HumanReadableException;\nimport com.facebook.buck.core.model.BuildTarget;\nimport com.facebook.buck.core.model.targetgraph.TargetGraph;\nimport com.facebook.buck.core.rules.BuildRule;\nimport com.facebook.buck.core.rules.BuildRuleResolver;\nimport com.facebook.buck.core.sourcepath.SourcePath;\nimport com.facebook.buck.cxx.toolchain.nativelink.NativeLinkable;\nimport com.facebook.buck.jvm.core.HasJavaClassHashes;\nimport com.facebook.buck.rules.coercer.BuildConfigFields;\nimport com.facebook.buck.util.MoreSuppliers;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.collect.FluentIterable;\nimport com.google.common.collect.ImmutableCollection;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableMap.Builder;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.hash.HashCode;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.stream.Collectors;\npublic class AndroidPackageableCollector {\n  private final AndroidPackageableCollection.Builder collectionBuilder =\n      AndroidPackageableCollection.builder();\n  private final Map<APKModule, ResourceCollector> resourceCollectors = new HashMap<>();\n  // Map is used instead of ImmutableMap.Builder for its containsKey() method.\n  private final Map<String, BuildConfigFields> buildConfigs = new HashMap<>();\n  private final ImmutableSet.Builder<HasJavaClassHashes> javaClassHashesProviders =\n      ImmutableSet.builder();\n  private final BuildTarget collectionRoot;\n  private final ImmutableSet<BuildTarget> buildTargetsToExcludeFromDex;\n  private final ImmutableSet<BuildTarget> resourcesToExclude;\n  private final ImmutableCollection<SourcePath> nativeLibsToExclude;\n  private final ImmutableCollection<NativeLinkable> nativeLinkablesToExclude;\n  private final ImmutableCollection<SourcePath> nativeLibAssetsToExclude;\n  private final ImmutableCollection<NativeLinkable> nativeLinkablesAssetsToExclude;\n  private final APKModuleGraph apkModuleGraph;\n  @VisibleForTesting\n  public AndroidPackageableCollector(BuildTarget collectionRoot) {\n    this(collectionRoot, ImmutableSet.of(), new APKModuleGraph(TargetGraph.EMPTY, collectionRoot));\n  }\n  public AndroidPackageableCollector(\n      BuildTarget collectionRoot,\n      ImmutableSet<BuildTarget> buildTargetsToExcludeFromDex,\n      APKModuleGraph apkModuleGraph) {\n    this(\n        collectionRoot,\n        buildTargetsToExcludeFromDex,\n        ImmutableSet.of(),\n        ImmutableSet.of(),\n        ImmutableSet.of(),\n        ImmutableSet.of(),\n        ImmutableSet.of(),\n        apkModuleGraph);\n  }\n  /**\n   * @param resourcesToExclude Only relevant to {@link AndroidInstrumentationApk} which needs to\n   *     remove resources that are already included in the {@link\n   *     AndroidInstrumentationApkDescription.AndroidInstrumentationApkDescriptionArg#apk}. The same\n   *     goes for native libs and native linkables, and their asset counterparts.\n   */\n  public AndroidPackageableCollector(\n      BuildTarget collectionRoot,\n      ImmutableSet<BuildTarget> buildTargetsToExcludeFromDex,\n      ImmutableSet<BuildTarget> resourcesToExclude,\n      ImmutableCollection<SourcePath> nativeLibsToExclude,\n      ImmutableCollection<NativeLinkable> nativeLinkablesToExclude,\n      ImmutableCollection<SourcePath> nativeLibAssetsToExclude,\n      ImmutableCollection<NativeLinkable> nativeLinkableAssetsToExclude,\n      APKModuleGraph apkModuleGraph) {\n    this.collectionRoot = collectionRoot;\n    this.buildTargetsToExcludeFromDex = buildTargetsToExcludeFromDex;\n    this.resourcesToExclude = resourcesToExclude;\n    this.nativeLibsToExclude = nativeLibsToExclude;\n    this.nativeLinkablesToExclude = nativeLinkablesToExclude;\n    this.nativeLibAssetsToExclude = nativeLibAssetsToExclude;\n    this.nativeLinkablesAssetsToExclude = nativeLinkableAssetsToExclude;\n    this.apkModuleGraph = apkModuleGraph;\n    apkModuleGraph\n        .getAPKModules()\n        .forEach(module -> resourceCollectors.put(module, new ResourceCollector()));\n  }\n  /** Add packageables */\n  public void addPackageables(\n      Iterable<AndroidPackageable> packageables, BuildRuleResolver ruleResolver) {\n    Set<AndroidPackageable> explored = new HashSet<>();\n    for (AndroidPackageable packageable : packageables) {\n      postOrderTraverse(packageable, explored, ruleResolver);\n    }\n  }\n  private void postOrderTraverse(\n      AndroidPackageable packageable,\n      Set<AndroidPackageable> explored,\n      BuildRuleResolver ruleResolver) {\n    if (explored.contains(packageable)) {\n      return;\n    }\n    explored.add(packageable);\n    for (AndroidPackageable dep : packageable.getRequiredPackageables(ruleResolver)) {\n      postOrderTraverse(dep, explored, ruleResolver);\n    }\n    packageable.addToCollector(this);\n  }\n  /**\n   * Returns all {@link BuildRule}s of the given rules that are {@link AndroidPackageable}. Helper\n   * for implementations of AndroidPackageable that just want to return all of their packagable\n   * dependencies.\n   */\n  public static Iterable<AndroidPackageable> getPackageableRules(Iterable<BuildRule> rules) {\n    return FluentIterable.from(rules).filter(AndroidPackageable.class);\n  }\n  public AndroidPackageableCollector addStringWhitelistedResourceDirectory(\n      BuildTarget owner, SourcePath resourceDir) {\n    if (resourcesToExclude.contains(owner)) {\n      return this;\n    }\n    ResourceCollector collector = getResourceCollector(owner);\n    collector.addWhitelistedStringDirectories(resourceDir);\n    collector.doAddResourceDirectory(owner, resourceDir);\n    return this;\n  }\n  public AndroidPackageableCollector addResourceDirectory(\n      BuildTarget owner, SourcePath resourceDir) {\n    if (resourcesToExclude.contains(owner)) {\n      return this;\n    }\n    ResourceCollector collector = getResourceCollector(owner);\n    collector.doAddResourceDirectory(owner, resourceDir);\n    return this;\n  }\n  public AndroidPackageableCollector addNativeLibsDirectory(\n      BuildTarget owner, SourcePath nativeLibDir) {\n    if (nativeLibsToExclude.contains(nativeLibDir)) {\n      return this;\n    }\n    APKModule module = apkModuleGraph.findModuleForTarget(owner);\n    if (module.isRootModule()) {\n      collectionBuilder.putNativeLibsDirectories(module, nativeLibDir);\n    } else {\n      collectionBuilder.putNativeLibAssetsDirectories(module, nativeLibDir);\n    }\n    return this;\n  }\n  public AndroidPackageableCollector addNativeLinkable(NativeLinkable nativeLinkable) {\n    if (nativeLinkablesToExclude.contains(nativeLinkable)) {\n      return this;\n    }\n    APKModule module = apkModuleGraph.findModuleForTarget(nativeLinkable.getBuildTarget());\n    if (module.isRootModule()) {\n      collectionBuilder.putNativeLinkables(module, nativeLinkable);\n    } else {\n      collectionBuilder.putNativeLinkablesAssets(module, nativeLinkable);\n    }\n    return this;\n  }\n<fim_suffix>  public AndroidPackageableCollector addNativeLinkableAsset(NativeLinkable nativeLinkable) {\n    if (nativeLinkablesAssetsToExclude.contains(nativeLinkable)) {\n      return this;\n    }\n    APKModule module = apkModuleGraph.findModuleForTarget(nativeLinkable.getBuildTarget());\n    collectionBuilder.putNativeLinkablesAssets(module, nativeLinkable);\n    return this;\n  }\n  public AndroidPackageableCollector addNativeLibAssetsDirectory(\n      BuildTarget owner, SourcePath assetsDir) {\n    if (nativeLibAssetsToExclude.contains(assetsDir)) {\n      return this;\n    }\n    // We need to build the native target in order to have the assets available still.\n    APKModule module = apkModuleGraph.findModuleForTarget(owner);\n    collectionBuilder.putNativeLibAssetsDirectories(module, assetsDir);<fim_middle>// function below has no smell\n"}