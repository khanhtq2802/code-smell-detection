{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.sis.metadata;\nimport java.util.Iterator;\nimport java.util.Collections;\nimport java.util.AbstractCollection;\nimport java.util.NoSuchElementException;\nimport java.util.ConcurrentModificationException;\nimport org.apache.sis.util.collection.BackingStoreException;\nimport org.apache.sis.util.collection.TableColumn;\nimport org.apache.sis.util.collection.TreeTable;\nimport org.apache.sis.util.resources.Errors;\n/**\n * The collection of children to be returned by {@link TreeNode#getChildren()}.\n * This collection holds a reference to the metadata object at creation time;\n * it does not track changes in {@code parent.getUserObject()}.\n *\n * <div class=\"section\">Note on value existence policy</div>\n * It is better to use this class with {@link ValueExistencePolicy#NON_EMPTY} in order\n * to avoid code complication and surprising behavior of {@link Iter#remove()} operation.\n * If the policy is set to another value, we need to keep the following aspects in mind:\n *\n * <ul>\n *   <li>When {@link Iter#hasNext()} finds a null or empty collection,\n *       it may needs to simulate a singleton with a null value.</li>\n *   <li>In {@link TreeNode#getUserObject()}, we need the same check than above\n *       for simulating a singleton collection with a null value if the node is\n *       for the element at index 0.</li>\n * </ul>\n *\n * @author  Martin Desruisseaux (Geomatys)\n * @version 0.8\n * @since   0.3\n * @module\n */\nfinal class TreeNodeChildren extends AbstractCollection<TreeTable.Node> {\n    /**\n     * The parent of the children to be returned by the iterator.\n     * Some useful information are available indirectly through this parent:\n     *\n     * <ul>\n     *   <li>{@link ValueExistencePolicy}: {@code parent.table.valuePolicy}</li>\n     * </ul>\n     *\n     * @see #childAt(int, int)\n     */\n    private final TreeNode parent;\n    /**\n     * The metadata object for which property values will be the elements of this collection.\n     * This is typically an {@link AbstractMetadata} instance, but not necessarily.\n     * Any type for which {@link MetadataStandard#isMetadata(Class)} returns {@code true} is okay.\n     *\n     * <p>This field is a snapshot of the {@linkplain #parent} {@link TreeNode#getUserObject()} at\n     * creation time. This collection does not track changes in the reference returned by the above-cited\n     * {@code getUserObject()}. In other words, changes in the {@code metadata} object will be reflected\n     * in this collection, but if {@code parent.getUserObject()} returns a reference to another object,\n     * this change will not be reflected in this collection.\n     */\n    final Object metadata;\n    /**\n     * The accessor to use for accessing the property names, types and values of the\n     * {@link #metadata} object. This is given at construction time and shall be the\n     * same than the following code:\n     *\n     * {@preformat java\n     *     accessor = parent.table.standard.getAccessor(metadata.getClass(), true);\n     * }\n     */\n    final PropertyAccessor accessor;\n    /**\n     * The children to be returned by this collection. All elements in this collection are\n     * initially {@code null}, then created by {@link #childAt(int, int)} when first needed.\n     *\n     * <p>Not all elements in this array will be returned by the iterator.\n     * The value needs to be verified for the {@link ValueExistencePolicy}.</p>\n     */\n    private final TreeNode[] children;\n    /**\n     * Index of the property to write in the parent node instead than as a child.\n     * If a property has the same name than the parent property that contains it,\n     * we write its value in that parent property. For example instead of:\n     *\n     * {@preformat text\n     *   Citation\n     *    \u2514\u2500Date\n     *       \u251c\u2500Date\u2026\u2026\u2026\u2026\u2026\u2026\u2026 2012/01/01\n     *       \u2514\u2500Date type\u2026\u2026 Creation\n     * }\n     *\n     * We simplify as:\n     *\n     * {@preformat text\n     *   Citation\n     *    \u2514\u2500Date\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026 2012/01/01\n     *       \u2514\u2500Date type\u2026\u2026 Creation\n     * }\n     *\n     * @see <a href=\"https://issues.apache.org/jira/browse/SIS-298\">SIS-298</a>\n     */\n    final int titleProperty;\n    /**\n     * Modification count, incremented when the content of this collection is modified. This check\n     * is done on a <cite>best effort basis</cite> only, since we can't not track the changes which\n     * are done independently in the {@linkplain #metadata} object.\n     */\n    int modCount;\n    /**\n     * Creates a collection of children for the specified metadata.\n     *\n     * @param  parent    the parent for which this node is an element.\n     * @param  metadata  the metadata object for which property values will be the elements of this collection.\n     * @param  accessor  the accessor to use for accessing the property names, types and values of the metadata object.\n     */\n<fim_suffix>    TreeNodeChildren(final TreeNode parent, final Object metadata, final PropertyAccessor accessor) {\n        this.parent   = parent;\n        this.metadata = metadata;\n        this.accessor = accessor;\n        this.children = new TreeNode[accessor.count()];\n        /*\n         * Search for something that looks like the main property, to be associated with the parent node\n         * instead than provided as a child. The intent is to have more compact and easy to read trees.\n         * That property shall be a singleton for a simple value (not another metadata object).\n         */\n        if (parent.table.valuePolicy == ValueExistencePolicy.COMPACT) {\n            TitleProperty an = accessor.implementation.getAnnotation(TitleProperty.class);\n            if (an == null) {\n                Class<?> implementation = parent.table.standard.getImplementation(accessor.type);\n                if (implementation != null) {\n                    an = implementation.getAnnotation(TitleProperty.class);\n                }\n            }\n            if (an != null) {\n                final int index = accessor.indexOf(an.name(), false);\n                final Class<?> type = accessor.type(index, TypeValuePolicy.ELEMENT_TYPE);\n                if (type != null && !parent.isMetadata(type) && type == accessor.type(index, TypeValuePolicy.PROPERTY_TYPE)) {\n                    titleProperty = index;\n                    return;\n                }\n            }\n        }\n        titleProperty = -1;\n    }\n    /**\n     * If a simple value should be associated to the parent node, returns the type of that value.\n     * Otherwise returns {@code null}.\n     */\n    final Class<?> getParentType() {\n        return (titleProperty >= 0) ? accessor.type(titleProperty, TypeValuePolicy.ELEMENT_TYPE) : null;\n    }\n    /**\n     * If a simple value should be associated to the parent node, returns that value.\n     * Otherwise returns {@code null}.\n     */\n    final Object getParentTitle() {\n        return (titleProperty >= 0) ? valueAt(titleProperty) : null;\n    }\n    /**\n     * Sets the value associated to the parent node, if possible.\n     * This returned boolean tells whether the value has been written.\n     */\n    final boolean setParentTitle(final Object value) {\n        if (titleProperty < 0) {\n            return false;\n        }\n        accessor.set(titleProperty, metadata, value, PropertyAccessor.RETURN_NULL);\n        return true;\n    }\n    /**\n     * Clears the value at the given index. The given {@code index} is relative to\n     * the {@link #accessor} indexing, <strong>not</strong> to this collection.\n     *\n     * <p>The cleared elements may or may not be considered as removed, depending on the\n     * value policy. To check if the element shall be considered as removed (for example\n     * in order to update index), invoke {@code isSkipped(value)} after this method.</p>\n     *\n     * <div class=\"section\">Implementation note</div>\n     * This method sets the property to {@code null}. This is not strictly correct for collections,<fim_middle>// function below is long method\n"}