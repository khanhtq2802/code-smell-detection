{"text": "<fim_prefix>    private static final String DEBUG_COALESCING_PATH_PROPERTY = Config.PROPERTY_PREFIX + \"coalescing_debug_path\";\n    private static final String DEBUG_COALESCING_PATH = System.getProperty(DEBUG_COALESCING_PATH_PROPERTY, \"/tmp/coleascing_debug\");\n    public enum Strategy { MOVINGAVERAGE, FIXED, TIMEHORIZON, DISABLED }\n    static\n    {\n        if (DEBUG_COALESCING)\n        {\n            File directory = new File(DEBUG_COALESCING_PATH);\n            if (directory.exists())\n                FileUtils.deleteRecursive(directory);\n            if (!directory.mkdirs())\n                throw new ExceptionInInitializerError(\"Couldn't create log dir\");\n        }\n    }\n    public static interface Coalescable\n    {\n        long timestampNanos();\n    }\n    @VisibleForTesting\n    static long determineCoalescingTime(long averageGap, long maxCoalesceWindow)\n    {\n        // Don't bother waiting at all if we're unlikely to get any new message within our max window\n        if (averageGap > maxCoalesceWindow)\n            return -1;\n        // avoid the degenerate case of zero (very unlikely, but let's be safe)\n        if (averageGap <= 0)\n            return maxCoalesceWindow;\n        // assume we receive as many messages as we expect; apply the same logic to the future batch:\n        // expect twice as many messages to consider sleeping for \"another\" interval; this basically translates\n        // to doubling our sleep period until we exceed our max sleep window.\n        long sleep = averageGap;\n        while (sleep * 2 < maxCoalesceWindow)\n            sleep *= 2;\n        return sleep;\n    }\n    /**\n     * A coalescing strategy, that decides when to coalesce messages.\n     * <p>\n     * The general principle is that, when asked, the strategy returns the time delay we want to wait for more messages\n     * to arrive before sending so message can be coalesced. For that, the strategy must be fed new messages through\n     * the {@link #newArrival(Coalescable)} method (the only assumption we make on messages is that they have an associated\n     * timestamp). The strategy can then be queried for the time to wait for coalescing through\n     * {@link #currentCoalescingTimeNanos()}.\n     * <p>\n     * Note that it is expected that a call {@link #currentCoalescingTimeNanos()} will come just after a call to\n     * {@link #newArrival(Coalescable))}, as the intent of the value returned by the former method is \"Given a new message, how much\n     * time should I wait for more messages to arrive and be coalesced with that message\". But both calls are separated\n     * as one may not want to call {@link #currentCoalescingTimeNanos()} after every call to {@link #newArrival(Coalescable)}\n     * and we thus save processing. How arrivals influence the coalescing time is however entirely up to the strategy and some\n     * strategy may ignore arrivals completely and return a constant coalescing time.\n     */\n    public interface CoalescingStrategy\n    {\n        /**\n         * Inform the strategy of a new message to consider.\n         *\n         * @param message the message to consider.\n         */\n        void newArrival(Coalescable message);\n        /**\n         * The current time to wait for the purpose of coalescing messages.\n         *\n         * @return the coalescing time. A negative value can be returned if no coalescing should be done (which can be a\n         * transient thing).\n         */\n        long currentCoalescingTimeNanos();\n    }\n    public static abstract class AbstractCoalescingStrategy implements CoalescingStrategy\n    {\n        protected final Logger logger;\n        protected volatile boolean shouldLogAverage = false;\n        protected final ByteBuffer logBuffer;\n        private RandomAccessFile ras;\n        private final String displayName;\n        protected AbstractCoalescingStrategy(Logger logger, String displayName)\n        {\n            this.logger = logger;\n            this.displayName = displayName;\n            RandomAccessFile rasTemp = null;\n            ByteBuffer logBufferTemp = null;\n            if (DEBUG_COALESCING)\n            {\n                ScheduledExecutors.scheduledFastTasks.scheduleWithFixedDelay(() -> shouldLogAverage = true, 5, 5, TimeUnit.SECONDS);\n                try\n                {\n                    File outFile = FileUtils.createTempFile(\"coalescing_\" + this.displayName + \"_\", \".log\", new File(DEBUG_COALESCING_PATH));\n                    rasTemp = new RandomAccessFile(outFile, \"rw\");\n                    logBufferTemp = ras.getChannel().map(MapMode.READ_WRITE, 0, Integer.MAX_VALUE);\n                    logBufferTemp.putLong(0);\n                }\n                catch (Exception e)\n                {\n                    logger.error(\"Unable to create output file for debugging coalescing\", e);\n                }\n            }\n            ras = rasTemp;\n            logBuffer = logBufferTemp;\n        }\n        /*\n         * If debugging is enabled log to the logger the current average gap calculation result.\n         */\n        final protected void debugGap(long averageGap)\n        {\n            if (DEBUG_COALESCING && shouldLogAverage)\n            {\n                shouldLogAverage = false;\n                logger.info(\"{} gap {}\u03bcs\", this, TimeUnit.NANOSECONDS.toMicros(averageGap));\n            }\n        }\n        /*\n         * If debugging is enabled log the provided nanotime timestamp to a file.\n         */\n        final protected void debugTimestamp(long timestamp)\n        {\n            if(DEBUG_COALESCING && logBuffer != null)\n            {\n                logBuffer.putLong(0, logBuffer.getLong(0) + 1);\n                logBuffer.putLong(timestamp);\n            }\n        }\n        /*\n         * If debugging is enabled log the timestamps of all the items in the provided collection\n         * to a file.\n         */\n        final protected <C extends Coalescable> void debugTimestamps(Collection<C> coalescables)\n        {\n            if (DEBUG_COALESCING)\n            {\n                for (C coalescable : coalescables)\n                {\n                    debugTimestamp(coalescable.timestampNanos());\n                }\n            }\n        }\n    }\n    @VisibleForTesting\n    static class TimeHorizonMovingAverageCoalescingStrategy extends AbstractCoalescingStrategy\n    {\n        // for now we'll just use 64ms per bucket; this can be made configurable, but results in ~1s for 16 samples\n        private static final int INDEX_SHIFT = 26;\n        private static final long BUCKET_INTERVAL = 1L << 26;\n        private static final int BUCKET_COUNT = 16;\n        private static final long INTERVAL = BUCKET_INTERVAL * BUCKET_COUNT;\n        private static final long MEASURED_INTERVAL = BUCKET_INTERVAL * (BUCKET_COUNT - 1);\n        // the minimum timestamp we will now accept updates for; only moves forwards, never backwards\n        private long epoch;\n        // the buckets, each following on from epoch; the measurements run from ix(epoch) to ix(epoch - 1)\n        // ix(epoch-1) is a partial result, that is never actually part of the calculation, and most updates\n        // are expected to hit this bucket\n        private final int samples[] = new int[BUCKET_COUNT];\n        private long sum = 0;\n        private final long maxCoalesceWindow;\n        public TimeHorizonMovingAverageCoalescingStrategy(int maxCoalesceWindow, Logger logger, String displayName, long initialEpoch)\n        {\n            super(logger, displayName);\n            this.maxCoalesceWindow = TimeUnit.MICROSECONDS.toNanos(maxCoalesceWindow);\n            sum = 0;\n            epoch = initialEpoch;\n        }\n        private long averageGap()\n        {\n            if (sum == 0)\n                return Integer.MAX_VALUE;\n            return MEASURED_INTERVAL / sum;\n        }\n        // this sample extends past the end of the range we cover, so rollover\n<fim_suffix>        private long rollEpoch(long delta, long epoch, long nanos)\n        {\n            if (delta > 2 * INTERVAL)\n            {\n                // this sample is more than twice our interval ahead, so just clear our counters completely\n                epoch = epoch(nanos);\n                sum = 0;\n                Arrays.fill(samples, 0);\n            }\n            else\n            {\n                // ix(epoch - 1) => last index; this is our partial result bucket, so we add this to the sum\n                sum += samples[ix(epoch - 1)];\n                // then we roll forwards, clearing buckets, until our interval covers the new sample time\n                while (epoch + INTERVAL < nanos)\n                {\n                    int index = ix(epoch);\n                    sum -= samples[index];\n                    samples[index] = 0;\n                    epoch += BUCKET_INTERVAL;\n                }\n            }\n            // store the new epoch\n            this.epoch = epoch;\n            return epoch;\n        }<fim_middle>// function below has no smell\n"}