{"text": "<fim_prefix>            super(name);\n        }\n        public void uncaughtException(Thread thread, Throwable throwable) {\n            if (throwable instanceof ThreadDeath) {\n                return; // harmless\n            }\n            boolean doLog = false;\n            synchronized (this) {\n                // only remember the first one\n                if (uncaughtException == null) {\n                    uncaughtException = throwable; // will be reported\n                    // eventually\n                } else {\n                    doLog = true;\n                }\n            }\n            if (doLog) {\n                getLog().warn(\"an additional exception was thrown\", throwable);\n            }\n        }\n    }\n    private void joinNonDaemonThreads(ThreadGroup threadGroup) {\n        boolean foundNonDaemon;\n        do {\n            foundNonDaemon = false;\n            Collection<Thread> threads = getActiveThreads(threadGroup);\n            for (Thread thread : threads) {\n                if (thread.isDaemon()) {\n                    continue;\n                }\n                foundNonDaemon = true; // try again; maybe more threads were\n                // created while we were busy\n                joinThread(thread, 0);\n            }\n        } while (foundNonDaemon);\n    }\n    private void joinThread(Thread thread, long timeoutMsecs) {\n        try {\n            getLog().debug(\"joining on thread \" + thread);\n            thread.join(timeoutMsecs);\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt(); // good practice if don't throw\n            getLog().warn(\"interrupted while joining against thread \" + thread, e); // not\n            // expected!\n        }\n        // generally abnormal\n        if (thread.isAlive()) {\n            getLog().warn(\"thread \" + thread + \" was interrupted but is still alive after waiting at least \"\n                              + timeoutMsecs + \"msecs\");\n        }\n    }\n    private void terminateThreads(ThreadGroup threadGroup) {\n        long startTime = System.currentTimeMillis();\n        Set<Thread> uncooperativeThreads = new HashSet<>(); // these were not responsive\n        // to interruption\n        for (Collection<Thread> threads = getActiveThreads(threadGroup); !threads.isEmpty(); threads = getActiveThreads(threadGroup), threads\n            .removeAll(uncooperativeThreads)) {\n            // Interrupt all threads we know about as of this instant (harmless\n            // if spuriously went dead (! isAlive())\n            // or if something else interrupted it ( isInterrupted() ).\n            for (Thread thread : threads) {\n                getLog().debug(\"interrupting thread \" + thread);\n                thread.interrupt();\n            }\n            // Now join with a timeout and call stop() (assuming flags are set\n            // right)\n            for (Thread thread : threads) {\n                if (!thread.isAlive()) {\n                    continue; // and, presumably it won't show up in\n                    // getActiveThreads() next iteration\n                }\n                if (daemonThreadJoinTimeout <= 0) {\n                    joinThread(thread, 0); // waits until not alive; no timeout\n                    continue;\n                }\n                long timeout = daemonThreadJoinTimeout - (System.currentTimeMillis() - startTime);\n                if (timeout > 0) {\n                    joinThread(thread, timeout);\n                }\n                if (!thread.isAlive()) {\n                    continue;\n                }\n                uncooperativeThreads.add(thread); // ensure we don't process\n                // again\n                if (stopUnresponsiveDaemonThreads) {\n                    getLog().warn(\"thread \" + thread + \" will be Thread.stop()'ed\");\n                    thread.stop();\n                } else {\n                    getLog().warn(\"thread \" + thread\n                            + \" will linger despite being asked to die via interruption\");\n                }\n            }\n        }\n        if (!uncooperativeThreads.isEmpty()) {\n            getLog().warn(\"NOTE: \"\n                    + uncooperativeThreads.size()\n                          + \" thread(s) did not finish despite being asked to \"\n                          + \" via interruption. This is not a problem with exec:java, it is a problem with the running code.\"\n                          + \" Although not serious, it should be remedied.\");\n        } else {\n            int activeCount = threadGroup.activeCount();\n            if (activeCount != 0) {\n                // TODO this may be nothing; continue on anyway; perhaps don't\n                // even log in future\n                Thread[] threadsArray = new Thread[1];\n                threadGroup.enumerate(threadsArray);\n                if (getLog().isDebugEnabled()) {\n                    getLog().debug(\"strange; \" + activeCount + \" thread(s) still active in the group \"\n                                   + threadGroup + \" such as \" + threadsArray[0]);\n                }\n            }\n        }\n    }\n    private Collection<Thread> getActiveThreads(ThreadGroup threadGroup) {\n        Thread[] threads = new Thread[threadGroup.activeCount()];\n        int numThreads = threadGroup.enumerate(threads);\n        Collection<Thread> result = new ArrayList<>(numThreads);\n        for (int i = 0; i < threads.length && threads[i] != null; i++) {\n            result.add(threads[i]);\n        }\n        // note: result should be modifiable\n        return result;\n    }\n    /**\n     * Pass any given system properties to the java system properties.\n     */\n    private void setSystemProperties() {\n        if (systemProperties != null) {\n            originalSystemProperties = System.getProperties();\n            for (Property systemProperty : systemProperties) {\n                String value = systemProperty.getValue();\n                System.setProperty(systemProperty.getKey(), value == null ? \"\" : value);\n            }\n        }\n    }\n    @SuppressWarnings(\"unchecked\")\n    private boolean detectCDIOnClassPath() {\n        List<Dependency> deps = project.getCompileDependencies();\n        for (Dependency dep : deps) {\n            if (\"org.apache.camel\".equals(dep.getGroupId()) && \"camel-cdi\".equals(dep.getArtifactId())) {\n                getLog().info(\"camel-cdi detected on classpath\");\n                return true;\n            }\n        }\n        return false;\n    }\n    @SuppressWarnings(\"unchecked\")\n    private boolean detectBlueprintOnClassPathOrBlueprintXMLFiles() {\n        List<Dependency> deps = project.getCompileDependencies();\n        for (Dependency dep : deps) {\n            if (\"org.apache.camel\".equals(dep.getGroupId()) && \"camel-blueprint\".equals(dep.getArtifactId())) {\n                getLog().info(\"camel-blueprint detected on classpath\");\n            }\n        }\n        // maybe there is blueprint XML files\n        List<Resource> resources = project.getResources();\n        for (Resource res : resources) {\n            File dir = new File(res.getDirectory());\n            File xml = new File(dir, \"OSGI-INF/blueprint\");\n            if (xml.exists() && xml.isDirectory()) {\n                getLog().info(\"OSGi Blueprint XML files detected in directory \" + xml);\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Set up a classloader for the execution of the main class.\n     *\n     * @return the classloader\n     * @throws MojoExecutionException\n     */\n    private ClassLoader getClassLoader() throws MojoExecutionException {\n        Set<URL> classpathURLs = new LinkedHashSet<>();\n        // project classpath must be first\n        this.addRelevantProjectDependenciesToClasspath(classpathURLs);\n        // and extra plugin classpath\n        this.addExtraPluginDependenciesToClasspath(classpathURLs);\n        // and plugin classpath last\n        this.addRelevantPluginDependenciesToClasspath(classpathURLs);\n        if (logClasspath) {\n            getLog().info(\"Classpath:\");\n            for (URL url : classpathURLs) {\n                getLog().info(\"  \" + url.getFile().toString());\n            }\n        }\n        return new URLClassLoader(classpathURLs.toArray(new URL[classpathURLs.size()]));\n    }\n    /**\n     * Add any relevant project dependencies to the classpath. Indirectly takes\n     * includePluginDependencies and ExecutableDependency into consideration.\n     *\n     * @param path classpath of {@link java.net.URL} objects\n     * @throws MojoExecutionException\n     */\n<fim_suffix>    private void addRelevantPluginDependenciesToClasspath(Set<URL> path) throws MojoExecutionException {\n        if (hasCommandlineArgs()) {\n            arguments = parseCommandlineArgs();\n        }\n        try {\n            Iterator<Artifact> iter = this.determineRelevantPluginDependencies().iterator();\n            while (iter.hasNext()) {\n                Artifact classPathElement = iter.next();\n                // we must skip org.osgi.core, otherwise we get a\n                // java.lang.NoClassDefFoundError: org.osgi.vendor.framework property not set\n                if (classPathElement.getArtifactId().equals(\"org.osgi.core\")) {\n                    if (getLog().isDebugEnabled()) {\n                        getLog().debug(\"Skipping org.osgi.core -> \" + classPathElement.getGroupId() + \"/\" + classPathElement.getArtifactId() + \"/\" + classPathElement.getVersion());\n                    }\n                    continue;\n                }\n                getLog().debug(\"Adding plugin dependency artifact: \" + classPathElement.getArtifactId()\n                                   + \" to classpath\");\n                path.add(classPathElement.getFile().toURI().toURL());\n            }\n        } catch (MalformedURLException e) {\n            throw new MojoExecutionException(\"Error during setting up classpath\", e);\n        }\n    }<fim_middle>// function below is long method\n"}