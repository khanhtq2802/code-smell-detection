{"text": "<fim_prefix>                // Potential to remove key\n                // Upgrade to write lock\n                lock.unlock();\n                lock = keyLock.writeLock();\n                lock.lock();\n                if (objectDeque.getCreateCount().get() == 0 && objectDeque.getNumInterested().get() == 0) {\n                    // NOTE: Keys must always be removed from both poolMap and\n                    // poolKeyList at the same time while protected by\n                    // keyLock.writeLock()\n                    poolMap.remove(k);\n                    poolKeyList.remove(k);\n                }\n            }\n        } finally {\n            lock.unlock();\n        }\n    }\n    @Override\n    void ensureMinIdle() throws Exception {\n        final int minIdlePerKeySave = getMinIdlePerKey();\n        if (minIdlePerKeySave < 1) {\n            return;\n        }\n        for (final K k : poolMap.keySet()) {\n            ensureMinIdle(k);\n        }\n    }\n    /**\n     * Ensure that the configured number of minimum idle objects is available in\n     * the pool for the given key.\n     *\n     * @param key The key to check for idle objects\n     *\n     * @throws Exception If a new object is required and cannot be created\n     */\n    private void ensureMinIdle(final K key) throws Exception {\n        // Calculate current pool objects\n        ObjectDeque<T> objectDeque = poolMap.get(key);\n        // objectDeque == null is OK here. It is handled correctly by both\n        // methods called below.\n        // this method isn't synchronized so the\n        // calculateDeficit is done at the beginning\n        // as a loop limit and a second time inside the loop\n        // to stop when another thread already returned the\n        // needed objects\n        final int deficit = calculateDeficit(objectDeque);\n        for (int i = 0; i < deficit && calculateDeficit(objectDeque) > 0; i++) {\n            addObject(key);\n            // If objectDeque was null, it won't be any more. Obtain a reference\n            // to it so the deficit can be correctly calculated. It needs to\n            // take account of objects created in other threads.\n            if (objectDeque == null) {\n                objectDeque = poolMap.get(key);\n            }\n        }\n    }\n    /**\n     * Create an object using the {@link KeyedPooledObjectFactory#makeObject\n     * factory}, passivate it, and then place it in the idle object pool.\n     * <code>addObject</code> is useful for \"pre-loading\" a pool with idle\n     * objects.\n     *\n     * @param key the key a new instance should be added to\n     *\n     * @throws Exception when {@link KeyedPooledObjectFactory#makeObject}\n     *                   fails.\n     */\n    @Override\n    public void addObject(final K key) throws Exception {\n        assertOpen();\n        register(key);\n        try {\n            final PooledObject<T> p = create(key);\n            addIdleObject(key, p);\n        } finally {\n            deregister(key);\n        }\n    }\n    /**\n     * Add an object to the set of idle objects for a given key.\n     *\n     * @param key The key to associate with the idle object\n     * @param p The wrapped object to add.\n     *\n     * @throws Exception If the associated factory fails to passivate the object\n     */\n    private void addIdleObject(final K key, final PooledObject<T> p) throws Exception {\n        if (p != null) {\n            factory.passivateObject(key, p);\n            final LinkedBlockingDeque<PooledObject<T>> idleObjects =\n                    poolMap.get(key).getIdleObjects();\n            if (getLifo()) {\n                idleObjects.addFirst(p);\n            } else {\n                idleObjects.addLast(p);\n            }\n        }\n    }\n    /**\n     * Registers a key for pool control and ensures that\n     * {@link #getMinIdlePerKey()} idle instances are created.\n     *\n     * @param key - The key to register for pool control.\n     *\n     * @throws Exception If the associated factory throws an exception\n     */\n    public void preparePool(final K key) throws Exception {\n        final int minIdlePerKeySave = getMinIdlePerKey();\n        if (minIdlePerKeySave < 1) {\n            return;\n        }\n        ensureMinIdle(key);\n    }\n    /**\n     * Calculate the number of objects to test in a run of the idle object\n     * evictor.\n     *\n     * @return The number of objects to test for validity\n     */\n    private int getNumTests() {\n        final int totalIdle = getNumIdle();\n        final int numTests = getNumTestsPerEvictionRun();\n        if (numTests >= 0) {\n            return Math.min(numTests, totalIdle);\n        }\n        return(int)(Math.ceil(totalIdle/Math.abs((double)numTests)));\n    }\n    /**\n     * Calculate the number of objects that need to be created to attempt to\n     * maintain the minimum number of idle objects while not exceeded the limits\n     * on the maximum number of objects either per key or totally.\n     *\n     * @param objectDeque   The set of objects to check\n     *\n     * @return The number of new objects to create\n     */\n    private int calculateDeficit(final ObjectDeque<T> objectDeque) {\n        if (objectDeque == null) {\n            return getMinIdlePerKey();\n        }\n        // Used more than once so keep a local copy so the value is consistent\n        final int maxTotal = getMaxTotal();\n        final int maxTotalPerKeySave = getMaxTotalPerKey();\n        int objectDefecit = 0;\n        // Calculate no of objects needed to be created, in order to have\n        // the number of pooled objects < maxTotalPerKey();\n        objectDefecit = getMinIdlePerKey() - objectDeque.getIdleObjects().size();\n        if (maxTotalPerKeySave > 0) {\n            final int growLimit = Math.max(0,\n                    maxTotalPerKeySave - objectDeque.getIdleObjects().size());\n            objectDefecit = Math.min(objectDefecit, growLimit);\n        }\n        // Take the maxTotal limit into account\n        if (maxTotal > 0) {\n            final int growLimit = Math.max(0, maxTotal - getNumActive() - getNumIdle());\n            objectDefecit = Math.min(objectDefecit, growLimit);\n        }\n        return objectDefecit;\n    }\n    //--- JMX support ----------------------------------------------------------\n    @Override\n    public Map<String,Integer> getNumActivePerKey() {\n        final HashMap<String,Integer> result = new HashMap<>();\n        final Iterator<Entry<K,ObjectDeque<T>>> iter = poolMap.entrySet().iterator();\n        while (iter.hasNext()) {\n            final Entry<K,ObjectDeque<T>> entry = iter.next();\n            if (entry != null) {\n                final K key = entry.getKey();\n                final ObjectDeque<T> objectDequeue = entry.getValue();\n                if (key != null && objectDequeue != null) {\n                    result.put(key.toString(), Integer.valueOf(\n                            objectDequeue.getAllObjects().size() -\n                            objectDequeue.getIdleObjects().size()));\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Return an estimate of the number of threads currently blocked waiting for\n     * an object from the pool. This is intended for monitoring only, not for\n     * synchronization control.\n     *\n     * @return The estimate of the number of threads currently blocked waiting\n     *         for an object from the pool\n     */\n    @Override\n    public int getNumWaiters() {\n        int result = 0;\n        if (getBlockWhenExhausted()) {\n            final Iterator<ObjectDeque<T>> iter = poolMap.values().iterator();\n            while (iter.hasNext()) {\n                // Assume no overflow\n                result += iter.next().getIdleObjects().getTakeQueueLength();\n            }\n        }\n        return result;\n    }\n    /**\n     * Return an estimate of the number of threads currently blocked waiting for\n     * an object from the pool for each key. This is intended for\n     * monitoring only, not for synchronization control.\n     *\n     * @return The estimate of the number of threads currently blocked waiting\n     *         for an object from the pool for each key\n     */\n<fim_suffix>    @Override\n    public Map<String,Integer> getNumWaitersByKey() {\n        final Map<String,Integer> result = new HashMap<>();\n        for (final Map.Entry<K, ObjectDeque<T>> entry : poolMap.entrySet()) {\n            final K k = entry.getKey();\n            final ObjectDeque<T> deque = entry.getValue();\n            if (deque != null) {\n                if (getBlockWhenExhausted()) {\n                    result.put(k.toString(), Integer.valueOf(\n                            deque.getIdleObjects().getTakeQueueLength()));\n                } else {\n                    result.put(k.toString(), Integer.valueOf(0));\n                }\n            }\n        }\n        return result;\n    }<fim_middle>// function below has no smell\n"}