{"text": "<fim_prefix>import static org.apache.brooklyn.util.JavaGroovyEquivalents.groovyTruth;\nimport java.util.Collection;\nimport java.util.Map;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport org.apache.brooklyn.api.entity.Entity;\nimport org.apache.brooklyn.api.entity.EntityLocal;\nimport org.apache.brooklyn.api.location.Location;\nimport org.apache.brooklyn.api.location.MachineProvisioningLocation;\nimport org.apache.brooklyn.api.sensor.AttributeSensor;\nimport org.apache.brooklyn.api.sensor.Sensor;\nimport org.apache.brooklyn.api.sensor.SensorEvent;\nimport org.apache.brooklyn.api.sensor.SensorEventListener;\nimport org.apache.brooklyn.core.entity.Attributes;\nimport org.apache.brooklyn.core.policy.AbstractPolicy;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.apache.brooklyn.policy.followthesun.FollowTheSunPool.ContainerItemPair;\nimport org.apache.brooklyn.policy.loadbalancing.Movable;\nimport org.apache.brooklyn.util.collections.MutableMap;\nimport org.apache.brooklyn.util.core.flags.SetFromFlag;\nimport com.google.common.base.Function;\nimport com.google.common.collect.Iterables;\nimport com.google.common.util.concurrent.ThreadFactoryBuilder;\n    // removed from catalog because it cannot currently be configured via catalog mechanisms - \n    // PolicySpec.create fails due to no no-arg constructor\n    // TODO make model and parameters things which can be initialized from config then reinstate in catalog\n//@Catalog(name=\"Follow the Sun\", description=\"Policy for moving \\\"work\\\" around to follow the demand; \"\n//        + \"the work can be any \\\"Movable\\\" entity\")\npublic class FollowTheSunPolicy extends AbstractPolicy {\n    private static final Logger LOG = LoggerFactory.getLogger(FollowTheSunPolicy.class);\n    public static final String NAME = \"Follow the Sun (Inter-Geography Latency Optimization)\";\n    @SetFromFlag(defaultVal=\"100\")\n    private long minPeriodBetweenExecs;\n    @SetFromFlag\n    private Function<Entity, Location> locationFinder;\n    private final AttributeSensor<Map<? extends Movable, Double>> itemUsageMetric;\n    private final FollowTheSunModel<Entity, Movable> model;\n    private final FollowTheSunStrategy<Entity, Movable> strategy;\n    private final FollowTheSunParameters parameters;\n    private FollowTheSunPool poolEntity;\n    private volatile ScheduledExecutorService executor;\n    private final AtomicBoolean executorQueued = new AtomicBoolean(false);\n    private volatile long executorTime = 0;\n    private boolean loggedConstraintsIgnored = false;\n    private final Function<Entity, Location> defaultLocationFinder = new Function<Entity, Location>() {\n        @Override\n        public Location apply(Entity e) {\n            Collection<Location> locs = e.getLocations();\n            if (locs.isEmpty()) return null;\n            Location contender = Iterables.get(locs, 0);\n            while (contender.getParent() != null && !(contender instanceof MachineProvisioningLocation)) {\n                contender = contender.getParent();\n            }\n            return contender;\n        }\n    };\n    private final SensorEventListener<Object> eventHandler = new SensorEventListener<Object>() {\n        @Override\n        public void onEvent(SensorEvent<Object> event) {\n            if (LOG.isTraceEnabled()) LOG.trace(\"{} received event {}\", FollowTheSunPolicy.this, event);\n            Entity source = event.getSource();\n            Object value = event.getValue();\n            Sensor<?> sensor = event.getSensor();\n            if (sensor.equals(itemUsageMetric)) {\n                onItemMetricUpdated((Movable)source, (Map<? extends Movable, Double>) value, true);\n            } else if (sensor.equals(Attributes.LOCATION_CHANGED)) {\n                onContainerLocationUpdated(source, true);\n            } else if (sensor.equals(FollowTheSunPool.CONTAINER_ADDED)) {\n                onContainerAdded((Entity) value, true);\n            } else if (sensor.equals(FollowTheSunPool.CONTAINER_REMOVED)) {\n                onContainerRemoved((Entity) value, true);\n            } else if (sensor.equals(FollowTheSunPool.ITEM_ADDED)) {\n                onItemAdded((Movable) value, true);\n            } else if (sensor.equals(FollowTheSunPool.ITEM_REMOVED)) {\n                onItemRemoved((Movable) value, true);\n            } else if (sensor.equals(FollowTheSunPool.ITEM_MOVED)) {\n                ContainerItemPair pair = (ContainerItemPair) value;\n                onItemMoved((Movable)pair.item, pair.container, true);\n            }\n        }\n    };\n    // FIXME parameters: use a more groovy way of doing it, that's consistent with other policies/entities?\n    public FollowTheSunPolicy(AttributeSensor itemUsageMetric, \n            FollowTheSunModel<Entity, Movable> model, FollowTheSunParameters parameters) {\n        this(MutableMap.of(), itemUsageMetric, model, parameters);\n    }\n    public FollowTheSunPolicy(Map props, AttributeSensor itemUsageMetric, \n            FollowTheSunModel<Entity, Movable> model, FollowTheSunParameters parameters) {\n        super(props);\n        this.itemUsageMetric = itemUsageMetric;\n        this.model = model;\n        this.parameters = parameters;\n        this.strategy = new FollowTheSunStrategy<Entity, Movable>(model, parameters); // TODO: extract interface, inject impl\n        this.locationFinder = elvis(locationFinder, defaultLocationFinder);\n        // TODO Should re-use the execution manager's thread pool, somehow\n        executor = Executors.newSingleThreadScheduledExecutor(newThreadFactory());\n    }\n    @Override\n    public void setEntity(EntityLocal entity) {\n        checkArgument(entity instanceof FollowTheSunPool, \"Provided entity must be a FollowTheSunPool\");\n        super.setEntity(entity);\n        this.poolEntity = (FollowTheSunPool) entity;\n        // Detect when containers are added to or removed from the pool.\n        subscriptions().subscribe(poolEntity, FollowTheSunPool.CONTAINER_ADDED, eventHandler);\n        subscriptions().subscribe(poolEntity, FollowTheSunPool.CONTAINER_REMOVED, eventHandler);\n        subscriptions().subscribe(poolEntity, FollowTheSunPool.ITEM_ADDED, eventHandler);\n        subscriptions().subscribe(poolEntity, FollowTheSunPool.ITEM_REMOVED, eventHandler);\n        subscriptions().subscribe(poolEntity, FollowTheSunPool.ITEM_MOVED, eventHandler);\n        // Take heed of any extant containers.\n        for (Entity container : poolEntity.getContainerGroup().getMembers()) {\n            onContainerAdded(container, false);\n        }\n        for (Entity item : poolEntity.getItemGroup().getMembers()) {\n            onItemAdded((Movable)item, false);\n        }\n        scheduleLatencyReductionJig();\n    }\n    @Override\n    public void suspend() {\n        // TODO unsubscribe from everything? And resubscribe on resume?\n        super.suspend();\n        if (executor != null) executor.shutdownNow();\n        executorQueued.set(false);\n    }\n    @Override\n    public void resume() {\n        super.resume();\n        executor = Executors.newSingleThreadScheduledExecutor(newThreadFactory());\n        executorTime = 0;\n        executorQueued.set(false);\n    }\n    private ThreadFactory newThreadFactory() {\n        return new ThreadFactoryBuilder()\n                .setNameFormat(\"brooklyn-followthesunpolicy-%d\")\n                .build();\n    }\n    private void scheduleLatencyReductionJig() {\n        if (isRunning() && executorQueued.compareAndSet(false, true)) {\n            long now = System.currentTimeMillis();\n            long delay = Math.max(0, (executorTime + minPeriodBetweenExecs) - now);\n            executor.schedule(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        executorTime = System.currentTimeMillis();\n                        executorQueued.set(false);\n                        if (LOG.isTraceEnabled()) LOG.trace(\"{} executing follow-the-sun migration-strategy\", this);\n                        strategy.rebalance();\n                    } catch (RuntimeException e) {\n                        if (isRunning()) {\n                            LOG.error(\"Error during latency-reduction-jig\", e);\n                        } else {\n                            LOG.debug(\"Error during latency-reduction-jig, but no longer running\", e);\n                        }\n                    }\n                }},\n                delay,\n                TimeUnit.MILLISECONDS);\n        }\n    }\n<fim_suffix>    private void onContainerAdded(Entity container, boolean rebalanceNow) {\n        subscriptions().subscribe(container, Attributes.LOCATION_CHANGED, eventHandler);\n        Location location = locationFinder.apply(container);\n        if (LOG.isTraceEnabled()) LOG.trace(\"{} recording addition of container {} in location {}\", new Object[] {this, container, location});\n        model.onContainerAdded(container, location);\n        if (rebalanceNow) scheduleLatencyReductionJig();\n    }<fim_middle>// function below has no smell\n"}