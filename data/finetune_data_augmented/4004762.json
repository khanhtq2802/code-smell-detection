{"text": "<fim_prefix>\n<fim_suffix>public class GraphicsNodeRable8Bit \n    extends    AbstractRable \n    implements GraphicsNodeRable, PaintRable {\n    private AffineTransform cachedGn2dev   = null;\n    private AffineTransform cachedUsr2dev  = null;\n    private CachableRed     cachedRed      = null;\n    private Rectangle2D     cachedBounds = null;\n    /**\n     * Should GraphicsNodeRable call primitivePaint or Paint.\n     */\n    private boolean usePrimitivePaint = true;\n    /**\n     * Returns true if this Rable get's it's contents by calling\n     * primitivePaint on the associated <code>GraphicsNode</code> or\n     * false if it uses paint.\n     */\n    public boolean getUsePrimitivePaint() {\n        return usePrimitivePaint;\n    }\n    /**\n     * Set to true if this Rable should get it's contents by calling\n     * primitivePaint on the associated <code>GraphicsNode</code> or false\n     * if it should use paint.  \n     */\n    public void setUsePrimitivePaint(boolean usePrimitivePaint) {\n        this.usePrimitivePaint = usePrimitivePaint;\n    }\n    /**\n     * GraphicsNode this image can render\n     */\n    private GraphicsNode node;\n    /**\n     * Returns the <code>GraphicsNode</code> rendered by this image\n     */\n    public GraphicsNode getGraphicsNode(){\n        return node;\n    }\n    /**\n     * Sets the <code>GraphicsNode</code> this image should render\n     */\n    public void setGraphicsNode(GraphicsNode node){\n        if(node == null){\n            throw new IllegalArgumentException();\n        }\n        this.node = node;\n    }\n    /**\n     * Clear any cached Red.\n     */\n    public void clearCache() {\n        cachedRed     = null;\n        cachedUsr2dev = null;\n        cachedGn2dev  = null;\n        cachedBounds  = null;\n    }\n    /**\n     * @param node The GraphicsNode this image should represent\n     */\n    public GraphicsNodeRable8Bit(GraphicsNode node){\n        if(node == null)\n            throw new IllegalArgumentException();\n        this.node = node;\n        this.usePrimitivePaint = true;\n    }\n    /**\n     * @param node The GraphicsNode this image should represent\n     * @param props The Properties for this image.\n     */\n    public GraphicsNodeRable8Bit(GraphicsNode node,\n                                 Map props){\n        super((Filter)null, props);\n        if(node == null)\n            throw new IllegalArgumentException();\n        this.node = node;\n        this.usePrimitivePaint = true;\n    }\n    /**\n     * @param node      the GraphicsNode this image should represent\n     * @param usePrimitivePaint indicates if the image should\n     *        include any filters or mask operations on <code>node</code>\n     */\n    public GraphicsNodeRable8Bit(GraphicsNode node, \n                                 boolean      usePrimitivePaint){\n        if(node == null)\n            throw new IllegalArgumentException();\n        this.node = node;\n        this.usePrimitivePaint = usePrimitivePaint;\n    }\n    /**\n     * Returns the bounds of this Rable in the user coordinate system.\n     */\n    public Rectangle2D getBounds2D(){\n        if (usePrimitivePaint){\n            Rectangle2D primitiveBounds = node.getPrimitiveBounds();\n            if(primitiveBounds == null)\n                return new Rectangle2D.Double(0, 0, 0, 0);\n            return (Rectangle2D)(primitiveBounds.clone());\n        }\n        // When not using Primitive paint we return out bounds in our\n        // parent's user space.  This makes sense since this is the\n        // space that we will draw our selves into (since paint unlike\n        // primitivePaint incorporates the transform from our user\n        // space to our parents user space).\n        Rectangle2D bounds = node.getBounds();\n        if(bounds == null){\n            return new Rectangle2D.Double(0, 0, 0, 0);\n        }\n        AffineTransform at = node.getTransform();\n        if (at != null){\n           bounds = at.createTransformedShape(bounds).getBounds2D();\n        }\n        return bounds;\n    }\n    /**\n     * Returns true if successive renderings (that is, calls to\n     * createRendering() or createScaledRendering()) with the same arguments\n     * may produce different results.  This method may be used to\n     * determine whether an existing rendering may be cached and\n     * reused.  It is always safe to return true.\n     */\n    public boolean isDynamic(){\n        return false;\n    }\n    /**\n     * Should perform the equivilent action as \n     * createRendering followed by drawing the RenderedImage to \n     * Graphics2D, or return false.\n     *\n     * @param g2d The Graphics2D to draw to.\n     * @return true if the paint call succeeded, false if\n     *         for some reason the paint failed (in which \n     *         case a createRendering should be used).\n     */\n    public boolean paintRable(Graphics2D g2d) {\n        // This optimization only apply if we are using\n        // SrcOver.  Otherwise things break...\n        Composite c = g2d.getComposite();\n        if (!SVGComposite.OVER.equals(c))\n            return false;\n        ColorSpace g2dCS = GraphicsUtil.getDestinationColorSpace(g2d);\n        if ((g2dCS == null) ||\n            (g2dCS != ColorSpace.getInstance(ColorSpace.CS_sRGB))){\n            // Only draw directly into sRGB destinations...\n            return false;\n        }\n        // System.out.println(\"drawImage GNR: \" + g2dCS);\n        GraphicsNode gn = getGraphicsNode();\n        if (getUsePrimitivePaint()){\n            gn.primitivePaint(g2d);\n        }\n        else{\n            gn.paint(g2d);\n        }\n        // Paint did the work...\n        return true;\n    }\n    /**\n     * Creates a RenderedImage that represented a rendering of this image\n     * using a given RenderContext.  This is the most general way to obtain a\n     * rendering of a RenderableImage.\n     *\n     * <p> The created RenderedImage may have a property identified\n     * by the String HINTS_OBSERVED to indicate which RenderingHints\n     * (from the RenderContext) were used to create the image.\n     * In addition any RenderedImages\n     * that are obtained via the getSources() method on the created\n     * RenderedImage may have such a property.\n     *\n     * @param renderContext the RenderContext to use to produce the rendering.\n     * @return a RenderedImage containing the rendered data.\n     */\n    public RenderedImage createRendering(RenderContext renderContext){\n        // Get user space to device space transform\n        AffineTransform usr2dev = renderContext.getTransform();\n        AffineTransform gn2dev;\n        if (usr2dev == null) {\n            usr2dev = new AffineTransform();\n            gn2dev  = usr2dev;\n        } else {\n            gn2dev = (AffineTransform)usr2dev.clone();\n        }\n        // Get the nodes transform (so we can pick up changes in this.\n        AffineTransform gn2usr = node.getTransform();\n        if (gn2usr != null) {\n            gn2dev.concatenate(gn2usr);\n        }\n        Rectangle2D bounds2D = getBounds2D();\n        if ((cachedBounds != null)                            &&\n            (cachedGn2dev != null)                            &&\n            (cachedBounds.equals(bounds2D))                   &&\n            (gn2dev.getScaleX()  == cachedGn2dev.getScaleX()) &&\n            (gn2dev.getScaleY()  == cachedGn2dev.getScaleY()) &&\n            (gn2dev.getShearX()  == cachedGn2dev.getShearX()) &&\n            (gn2dev.getShearY()  == cachedGn2dev.getShearY()))\n        {\n            // Just some form of Translation\n            double deltaX = (usr2dev.getTranslateX() - \n                             cachedUsr2dev.getTranslateX());\n            double deltaY = (usr2dev.getTranslateY() - \n                             cachedUsr2dev.getTranslateY());\n            // System.out.println(\"Using Cached Red!!! \" + \n            //                    deltaX + \"x\" + deltaY);\n            if ((deltaX ==0) && (deltaY == 0))\n                // Actually no translation\n                return cachedRed;\n            // System.out.println(\"Delta: [\" + deltaX + \", \" + deltaY + \"]\");\n            // Integer translation in device space..\n            if ((deltaX == (int)deltaX) &&\n                (deltaY == (int)deltaY)) {\n                return new TranslateRed\n                    (cachedRed, \n                     (int)Math.round(cachedRed.getMinX()+deltaX),\n                     (int)Math.round(cachedRed.getMinY()+deltaY));\n            }\n        }\n        // Fell through let's do a new rendering...\n        if (false) {\n            System.out.println(\"Not using Cached Red: \" + usr2dev);\n            System.out.println(\"Old:                  \" + cachedUsr2dev);\n        }\n        if((bounds2D.getWidth()  > 0) && \n           (bounds2D.getHeight() > 0)) {<fim_middle>// class below has no smell\n"}