{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.hadoop.hive.llap.counters;\n\nimport java.util.concurrent.atomic.AtomicLongArray;\n\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.hive.conf.HiveConf;\nimport org.apache.hadoop.hive.conf.HiveConf.ConfVars;\nimport org.apache.hadoop.hive.llap.cache.LowLevelCacheCounters;\nimport org.apache.tez.common.counters.TezCounters;\n\n/**\n * Per query counters.\n */\npublic class QueryFragmentCounters implements LowLevelCacheCounters {\n  private final boolean doUseTimeCounters;\n\n  public static enum Desc {\n    MACHINE,\n    TABLE,\n    FILE,\n    STRIPES\n  }\n\n  private final AtomicLongArray fixedCounters;\n  private final Object[] descs;\n  private final TezCounters tezCounters;\n\n  public QueryFragmentCounters(Configuration conf, final TezCounters tezCounters) {\n    fixedCounters = new AtomicLongArray(LlapIOCounters.values().length);\n    descs = new Object[Desc.values().length];\n    doUseTimeCounters = HiveConf.getBoolVar(conf, ConfVars.LLAP_ORC_ENABLE_TIME_COUNTERS);\n    this.tezCounters = tezCounters;\n    if (!doUseTimeCounters) {\n      setCounter(LlapIOCounters.TOTAL_IO_TIME_NS, -1);\n      setCounter(LlapIOCounters.DECODE_TIME_NS, -1);\n      setCounter(LlapIOCounters.HDFS_TIME_NS, -1);\n      setCounter(LlapIOCounters.CONSUMER_TIME_NS, -1);\n    }\n  }\n\n  public void incrCounter(LlapIOCounters counter) {\n    incrCounter(counter, 1);\n  }\n\n  public void incrCounter(LlapIOCounters counter, long delta) {\n    fixedCounters.addAndGet(counter.ordinal(), delta);\n    if (tezCounters != null) {\n      tezCounters.findCounter(LlapIOCounters.values()[counter.ordinal()]).increment(delta);\n    }\n  }\n\n  @Override\n  public final long startTimeCounter() {\n    return (doUseTimeCounters ? System.nanoTime() : 0);\n  }\n\n  public void incrWallClockCounter(LlapIOCounters counter, long startTime) {\n    if (!doUseTimeCounters) return;\n    long delta = System.nanoTime() - startTime;\n    fixedCounters.addAndGet(counter.ordinal(), delta);\n    if (tezCounters != null) {\n      tezCounters.findCounter(LlapIOCounters.values()[counter.ordinal()]).increment(delta);\n    }\n  }\n\n  public void setCounter(LlapIOCounters counter, long value) {\n    fixedCounters.set(counter.ordinal(), value);\n    if (tezCounters != null) {\n      tezCounters.findCounter(LlapIOCounters.values()[counter.ordinal()]).setValue(value);\n    }\n  }\n\n  public void setDesc(Desc key, Object desc) {\n    descs[key.ordinal()] = desc;\n  }\n\n  @Override\n  public void recordCacheHit(long bytesHit) {\n    incrCounter(LlapIOCounters.CACHE_HIT_BYTES, bytesHit);\n  }\n\n  @Override\n  public void recordCacheMiss(long bytesMissed) {\n    incrCounter(LlapIOCounters.CACHE_MISS_BYTES, bytesMissed);\n  }\n\n<fim_suffix>  @Override\n  public void recordAllocBytes(long bytesUsed, long bytesAllocated) {\n    incrCounter(LlapIOCounters.ALLOCATED_USED_BYTES, bytesUsed);\n    incrCounter(LlapIOCounters.ALLOCATED_BYTES, bytesAllocated);\n  }\n\n  @Override\n  public void recordHdfsTime(long startTime) {\n    incrWallClockCounter(LlapIOCounters.HDFS_TIME_NS, startTime);\n  }\n\n  @Override\n  public void recordThreadTimes(long cpuNs, long userNs) {\n    incrCounter(LlapIOCounters.IO_CPU_NS, cpuNs);\n    incrCounter(LlapIOCounters.IO_USER_NS, userNs);\n  }\n\n  @Override\n  public String toString() {\n    // We rely on NDC information in the logs to map counters to attempt.\n    // If that is not available, appId should either be passed in, or extracted from NDC.\n    StringBuilder sb = new StringBuilder(\"Fragment counters for [\");\n    for (int i = 0; i < descs.length; ++i) {\n      if (i != 0) {\n        sb.append(\", \");\n      }\n      if (descs[i] != null) {\n        sb.append(descs[i]);\n      }\n    }\n    sb.append(\"]: [ \");\n    for (int i = 0; i < fixedCounters.length(); ++i) {\n      if (i != 0) {\n        sb.append(\", \");\n      }\n      sb.append(LlapIOCounters.values()[i].name()).append(\"=\").append(fixedCounters.get(i));\n    }\n    sb.append(\" ]\");\n    return sb.toString();\n  }\n\n  public TezCounters getTezCounters() {\n    return tezCounters;\n  }\n}<fim_middle>// function below has no smell\n"}