{"text": "<fim_prefix>            if (!ignoreRestartSetting && restart != null && restart.equalsIgnoreCase(\"false\")) {\n                return null;\n            }\n            if (proxy.getState() == VirtualMachine.State.Stopped) {\n                _itMgr.advanceStart(proxy.getUuid(), null, null);\n                proxy = _consoleProxyDao.findById(proxy.getId());\n                return proxy;\n            }\n            // For VMs that are in Stopping, Starting, Migrating state, let client to wait by returning null\n            // as sooner or later, Starting/Migrating state will be transited to Running and Stopping will be transited\n            // to Stopped to allow Starting of it\n            s_logger.warn(\"Console proxy is not in correct state to be started: \" + proxy.getState());\n            return null;\n        } catch (StorageUnavailableException e) {\n            s_logger.warn(\"Exception while trying to start console proxy\", e);\n            return null;\n        } catch (InsufficientCapacityException e) {\n            s_logger.warn(\"Exception while trying to start console proxy\", e);\n            return null;\n        } catch (ResourceUnavailableException e) {\n            s_logger.warn(\"Exception while trying to start console proxy\", e);\n            return null;\n        } catch (ConcurrentOperationException e) {\n            s_logger.warn(\"Runtime Exception while trying to start console proxy\", e);\n            return null;\n        } catch (CloudRuntimeException e) {\n            s_logger.warn(\"Runtime Exception while trying to start console proxy\", e);\n            return null;\n        } catch (OperationTimedoutException e) {\n            s_logger.warn(\"Runtime Exception while trying to start console proxy\", e);\n            return null;\n        }\n    }\n    public ConsoleProxyVO assignProxyFromRunningPool(long dataCenterId) {\n        if (s_logger.isTraceEnabled()) {\n            s_logger.trace(\"Assign console proxy from running pool for request from data center : \" + dataCenterId);\n        }\n        ConsoleProxyAllocator allocator = getCurrentAllocator();\n        assert (allocator != null);\n        List<ConsoleProxyVO> runningList = _consoleProxyDao.getProxyListInStates(dataCenterId, State.Running);\n        if (runningList != null && runningList.size() > 0) {\n            Iterator<ConsoleProxyVO> it = runningList.iterator();\n            while (it.hasNext()) {\n                ConsoleProxyVO proxy = it.next();\n                if (proxy.getActiveSession() >= _capacityPerProxy) {\n                    it.remove();\n                }\n            }\n            if (s_logger.isTraceEnabled()) {\n                s_logger.trace(\"Running proxy pool size : \" + runningList.size());\n                for (ConsoleProxyVO proxy : runningList) {\n                    s_logger.trace(\"Running proxy instance : \" + proxy.getHostName());\n                }\n            }\n            List<Pair<Long, Integer>> l = _consoleProxyDao.getProxyLoadMatrix();\n            Map<Long, Integer> loadInfo = new HashMap<Long, Integer>();\n            if (l != null) {\n                for (Pair<Long, Integer> p : l) {\n                    loadInfo.put(p.first(), p.second());\n                    if (s_logger.isTraceEnabled()) {\n                        s_logger.trace(\"Running proxy instance allocation load { proxy id : \" + p.first() + \", load : \" + p.second() + \"}\");\n                    }\n                }\n            }\n            Long allocated = allocator.allocProxy(runningList, loadInfo, dataCenterId);\n            if (allocated == null) {\n                s_logger.debug(\"Unable to find a console proxy \");\n                return null;\n            }\n            return _consoleProxyDao.findById(allocated);\n        } else {\n            if (s_logger.isTraceEnabled()) {\n                s_logger.trace(\"Empty running proxy pool for now in data center : \" + dataCenterId);\n            }\n        }\n        return null;\n    }\n    public ConsoleProxyVO assignProxyFromStoppedPool(long dataCenterId) {\n        // practically treat all console proxy VM that is not in Running state but can be entering into Running state as\n        // candidates\n        // this is to prevent launching unneccessary console proxy VMs because of temporarily unavailable state\n        List<ConsoleProxyVO> l = _consoleProxyDao.getProxyListInStates(dataCenterId, State.Starting, State.Stopped, State.Migrating, State.Stopping);\n        if (l != null && l.size() > 0) {\n            return l.get(0);\n        }\n        return null;\n    }\n    public ConsoleProxyVO startNew(long dataCenterId) throws ConcurrentOperationException {\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"Assign console proxy from a newly started instance for request from data center : \" + dataCenterId);\n        }\n        if (!allowToLaunchNew(dataCenterId)) {\n            s_logger.warn(\"The number of launched console proxy on zone \" + dataCenterId + \" has reached to limit\");\n            return null;\n        }\n        VMTemplateVO template = null;\n        HypervisorType availableHypervisor = _resourceMgr.getAvailableHypervisor(dataCenterId);\n        template = _templateDao.findSystemVMReadyTemplate(dataCenterId, availableHypervisor);\n        if (template == null) {\n            throw new CloudRuntimeException(\"Not able to find the System templates or not downloaded in zone \" + dataCenterId);\n        }\n        Map<String, Object> context = createProxyInstance(dataCenterId, template);\n        long proxyVmId = (Long)context.get(\"proxyVmId\");\n        if (proxyVmId == 0) {\n            if (s_logger.isTraceEnabled()) {\n                s_logger.trace(\"Creating proxy instance failed, data center id : \" + dataCenterId);\n            }\n            return null;\n        }\n        ConsoleProxyVO proxy = _consoleProxyDao.findById(proxyVmId);\n        if (proxy != null) {\n            SubscriptionMgr.getInstance().notifySubscribers(ConsoleProxyManager.ALERT_SUBJECT, this,\n                new ConsoleProxyAlertEventArgs(ConsoleProxyAlertEventArgs.PROXY_CREATED, dataCenterId, proxy.getId(), proxy, null));\n            return proxy;\n        } else {\n            if (s_logger.isDebugEnabled()) {\n                s_logger.debug(\"Unable to allocate console proxy storage, remove the console proxy record from DB, proxy id: \" + proxyVmId);\n            }\n        }\n        return null;\n    }\n    /**\n     * Get the default network for the console proxy VM, based on the zone it is in. Delegates to\n     * either {@link #getDefaultNetworkForZone(DataCenter)} or {@link #getDefaultNetworkForAdvancedSGZone(DataCenter)},\n     * depending on the zone network type and whether or not security groups are enabled in the zone.\n     * @param dc - The zone (DataCenter) of the console proxy VM.\n     * @return The default network for use with the console proxy VM.\n     */\n    protected NetworkVO getDefaultNetworkForCreation(DataCenter dc) {\n        if (dc.getNetworkType() == NetworkType.Advanced) {\n            return getDefaultNetworkForAdvancedZone(dc);\n        } else {\n            return getDefaultNetworkForBasicZone(dc);\n        }\n    }\n    /**\n     * Get default network for a console proxy VM starting up in an advanced zone. If the zone\n     * is security group-enabled, the first network found that supports SG services is returned.\n     * If the zone is not SG-enabled, the Public network is returned.\n     * @param dc - The zone.\n     * @return The selected default network.\n     * @throws CloudRuntimeException - If the zone is not a valid choice or a network couldn't be found.\n     */\n<fim_suffix>    protected NetworkVO getDefaultNetworkForAdvancedZone(DataCenter dc) {\n        if (dc.getNetworkType() != NetworkType.Advanced) {\n            throw new CloudRuntimeException(\"Zone \" + dc + \" is not advanced.\");\n        }\n        if (dc.isSecurityGroupEnabled()) {\n            List<NetworkVO> networks = _networkDao.listByZoneSecurityGroup(dc.getId());\n            if (CollectionUtils.isEmpty(networks)) {\n                throw new CloudRuntimeException(\"Can not found security enabled network in SG Zone \" + dc);\n            }\n            return networks.get(0);\n        }\n        else {\n            TrafficType defaultTrafficType = TrafficType.Public;\n            List<NetworkVO> defaultNetworks = _networkDao.listByZoneAndTrafficType(dc.getId(), defaultTrafficType);\n            // api should never allow this situation to happen\n            if (defaultNetworks.size() != 1) {\n                throw new CloudRuntimeException(\"Found \" + defaultNetworks.size() + \" networks of type \" + defaultTrafficType + \" when expect to find 1\");\n            }\n            return defaultNetworks.get(0);\n        }\n    }<fim_middle>// function below is long method\n"}