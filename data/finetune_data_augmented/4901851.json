{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.jackrabbit.oak.security.authentication.token;\n\nimport org.apache.jackrabbit.JcrConstants;\nimport org.apache.jackrabbit.oak.api.CommitFailedException;\nimport org.apache.jackrabbit.oak.api.PropertyState;\nimport org.apache.jackrabbit.oak.api.Tree;\nimport org.apache.jackrabbit.oak.api.Type;\nimport org.apache.jackrabbit.oak.plugins.tree.TreeProvider;\nimport org.apache.jackrabbit.oak.plugins.tree.TreeUtil;\nimport org.apache.jackrabbit.oak.spi.commit.CommitInfo;\nimport org.apache.jackrabbit.oak.spi.commit.DefaultValidator;\nimport org.apache.jackrabbit.oak.spi.commit.Validator;\nimport org.apache.jackrabbit.oak.spi.commit.ValidatorProvider;\nimport org.apache.jackrabbit.oak.spi.commit.VisibleValidator;\nimport org.apache.jackrabbit.oak.spi.security.ConfigurationParameters;\nimport org.apache.jackrabbit.oak.spi.security.authentication.token.TokenConstants;\nimport org.apache.jackrabbit.oak.spi.security.user.UserConstants;\nimport org.apache.jackrabbit.oak.spi.security.user.util.PasswordUtil;\nimport org.apache.jackrabbit.oak.spi.state.NodeState;\nimport org.apache.jackrabbit.util.Text;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nclass TokenValidatorProvider extends ValidatorProvider implements TokenConstants {\n\n    private static final Logger log = LoggerFactory.getLogger(TokenValidatorProvider.class);\n\n    private final String userRootPath;\n\n    private final TreeProvider treeProvider;\n\n    TokenValidatorProvider(@NotNull ConfigurationParameters userConfig, @NotNull TreeProvider treeProvider) {\n        userRootPath = userConfig.getConfigValue(UserConstants.PARAM_USER_PATH, UserConstants.DEFAULT_USER_PATH);\n        this.treeProvider = treeProvider;\n    }\n\n    @Override\n    protected Validator getRootValidator(NodeState before, NodeState after, CommitInfo commitInfo) {\n        return new TokenValidator(before, after, commitInfo);\n    }\n\n    private static CommitFailedException constraintViolation(int code, @NotNull String message) {\n        return new CommitFailedException(CommitFailedException.CONSTRAINT, code, message);\n    }\n\n    private final class TokenValidator extends DefaultValidator implements TokenConstants {\n\n        private final Tree parentBefore;\n        private final Tree parentAfter;\n        private final CommitInfo commitInfo;\n\n        TokenValidator(@NotNull NodeState parentBefore, @NotNull NodeState parentAfter, @NotNull CommitInfo commitInfo) {\n            this(treeProvider.createReadOnlyTree(parentBefore), treeProvider.createReadOnlyTree(parentAfter), commitInfo);\n        }\n\n        private TokenValidator(@Nullable Tree parentBefore, @NotNull Tree parentAfter, @NotNull CommitInfo commitInfo) {\n            this.parentBefore = parentBefore;\n            this.parentAfter = parentAfter;\n            this.commitInfo = commitInfo;\n        }\n\n        //------------------------------------------------------< Validator >---\n\n        @Override\n        public void propertyAdded(PropertyState after) throws CommitFailedException {\n            String name = after.getName();\n            if (TOKEN_PROPERTY_NAMES.contains(name)) {\n                // ensure that token specific properties are managed by the token provider.\n                verifyCommitInfo();\n                // make sure they are not solely located with a token node.\n                if (!isTokenTree(parentAfter)) {\n                    String msg = \"Attempt to create reserved token property \" + name;\n                    throw constraintViolation(60, msg);\n                }\n            }\n        }\n\n        @Override\n        public void propertyChanged(PropertyState before, PropertyState after) throws CommitFailedException {\n            String propertyName = after.getName();\n            if (TOKEN_ATTRIBUTE_KEY.equals(propertyName)) {\n                String msg = \"Attempt to change reserved token property \" + propertyName;\n                throw constraintViolation(61, msg);\n            } else if (TOKEN_ATTRIBUTE_EXPIRY.equals(propertyName)) {\n                verifyCommitInfo();\n            } else if (JcrConstants.JCR_PRIMARYTYPE.equals(propertyName)) {\n                if (TOKEN_NT_NAME.equals(after.getValue(Type.STRING))) {\n                    throw constraintViolation(62, \"Changing primary type of existing node to the reserved token node type.\");\n                }\n                if (isTokensParent(parentAfter) && TOKENS_NT_NAME.equals(before.getValue(Type.STRING))) {\n                    throw constraintViolation(69, \"Cannot change the primary type of an existing .tokens node.\");\n                }\n            }\n        }\n\n        @Override\n        public Validator childNodeAdded(String name, NodeState after) throws CommitFailedException {\n            Tree tree = checkNotNull(parentAfter.getChild(name));\n\n            if (isTokenTree(tree)) {\n                validateTokenTree(tree);\n                // no further validation required\n                return null;\n            } else if (isTokensParent(tree)) {\n                validateTokensParent(tree);\n            }\n            return new VisibleValidator(new TokenValidator(null, tree, commitInfo), true, true);\n        }\n\n<fim_suffix>        @Override\n        public Validator childNodeChanged(String name, NodeState before, NodeState after) throws CommitFailedException {\n            Tree beforeTree = (parentBefore == null) ? null : parentBefore.getChild(name);\n            Tree afterTree = parentAfter.getChild(name);\n\n            if (isTokenTree(beforeTree) || isTokenTree(afterTree)) {\n                validateTokenTree(afterTree);\n            } else if (isTokensParent(beforeTree) || isTokensParent(afterTree)) {\n                validateTokensParent(afterTree);\n            }\n\n            return new VisibleValidator(new TokenValidator(beforeTree, afterTree, commitInfo), true, true);\n        }\n\n        //--------------------------------------------------------< private >---\n        private void verifyCommitInfo() throws CommitFailedException {\n            if (!CommitMarker.isValidCommitInfo(commitInfo)) {\n                throw constraintViolation(63, \"Attempt to manually create or change a token node or it's parent.\");\n            }\n        }\n\n        private void verifyHierarchy(@NotNull String path) throws CommitFailedException {\n            if (!Text.isDescendant(userRootPath, path)) {\n                String msg = \"Attempt to create a token (or it's parent) outside of configured scope \" + path;\n                throw constraintViolation(64, msg);\n            }\n        }\n\n        private boolean isTokenTree(@Nullable Tree tree) {\n            return tree != null && TOKEN_NT_NAME.equals(TreeUtil.getPrimaryTypeName(tree));\n        }\n\n        private void validateTokenTree(@NotNull Tree tokenTree) throws CommitFailedException {\n            // enforce changing being made by the TokenProvider implementation\n            verifyCommitInfo();\n\n            verifyHierarchy(tokenTree.getPath());\n\n            Tree parent = tokenTree.getParent();\n            if (!isTokensParent(parent) || !UserConstants.NT_REP_USER.equals(TreeUtil.getPrimaryTypeName(parent.getParent()))) {\n                throw constraintViolation(65, \"Invalid location of token node.\");\n            }\n\n            // assert mandatory properties are present\n            String key = TreeUtil.getString(tokenTree, TOKEN_ATTRIBUTE_KEY);\n            if (PasswordUtil.isPlainTextPassword(key)) {\n                throw constraintViolation(66, \"Invalid token key.\");\n            }\n\n            if (TreeUtil.getString(tokenTree, TOKEN_ATTRIBUTE_EXPIRY) == null) {\n                throw constraintViolation(67, \"Mandatory token expiration missing.\");\n            }\n        }\n\n        private boolean isTokensParent(@Nullable Tree tree) {\n            return tree != null && TOKENS_NODE_NAME.equals(tree.getName());\n        }\n\n        private void validateTokensParent(@NotNull Tree tokensParent) throws CommitFailedException {\n\n            verifyHierarchy(tokensParent.getPath());\n\n            Tree userTree = tokensParent.getParent();\n            if (!UserConstants.NT_REP_USER.equals(TreeUtil.getPrimaryTypeName(userTree))) {\n                throw constraintViolation(68, \"Invalid location of .tokens node.\");\n            }\n\n            String nt = TreeUtil.getPrimaryTypeName(tokensParent);\n            if (!TOKENS_NT_NAME.equals(nt)) {\n                log.debug(\"Unexpected node type of .tokens node \" + nt + '.');\n            }\n        }\n    }\n}<fim_middle>// function below has no smell\n"}