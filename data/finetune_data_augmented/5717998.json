{"text": "<fim_prefix>\t\t\t\tsb.append(offset);\n\t\t\t\tsb.append(\"ELSE\\n\");\n\t\t\t\tfor( ProgramBlock pbc : ipb.getChildBlocksElseBody() ) \n\t\t\t\t\tsb.append( explainProgramBlock( pbc, level+1) );\n\t\t\t}\n\t\t}\n\t\telse if (pb instanceof ForProgramBlock) //incl parfor\n\t\t{\n\t\t\tForProgramBlock fpb = (ForProgramBlock) pb;\n\t\t\tStatementBlock fsb = pb.getStatementBlock();\n\t\t\tsb.append(offset);\n\t\t\tif( pb instanceof ParForProgramBlock )\n\t\t\t\tsb.append(\"PARFOR (lines \"+fpb.getBeginLine()+\"-\"+fpb.getEndLine()+\")\\n\");\n\t\t\telse {\n\t\t\t\tif( fsb != null && !fsb.getUpdateInPlaceVars().isEmpty() )\n\t\t\t\t\tsb.append(\"FOR (lines \"+fpb.getBeginLine()+\"-\"+fpb.getEndLine()+\") [in-place=\"+fsb.getUpdateInPlaceVars().toString()+\"]\\n\");\n\t\t\t\telse\n\t\t\t\t\tsb.append(\"FOR (lines \"+fpb.getBeginLine()+\"-\"+fpb.getEndLine()+\")\\n\");\n\t\t\t}\n\t\t\tsb.append(explainInstructions(fpb.getFromInstructions(), level+1));\n\t\t\tsb.append(explainInstructions(fpb.getToInstructions(), level+1));\n\t\t\tsb.append(explainInstructions(fpb.getIncrementInstructions(), level+1));\n\t\t\tfor( ProgramBlock pbc : fpb.getChildBlocks() ) \n\t\t\t\tsb.append( explainProgramBlock( pbc, level+1) );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsb.append(offset);\n\t\t\tif( pb.getStatementBlock()!=null )\n\t\t\t\tsb.append(\"GENERIC (lines \"+pb.getBeginLine()+\"-\"+pb.getEndLine()+\") [recompile=\"+pb.getStatementBlock().requiresRecompilation()+\"]\\n\");\n\t\t\telse\n\t\t\t\tsb.append(\"GENERIC (lines \"+pb.getBeginLine()+\"-\"+pb.getEndLine()+\") \\n\");\n\t\t\tsb.append(explainInstructions(pb.getInstructions(), level+1));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tprivate static String explainInstructions( ArrayList<Instruction> instSet, int level )\n\t{\n\t\tStringBuilder sb = new StringBuilder();\n\t\tString offsetInst = createOffset(level);\n\t\tfor( Instruction inst : instSet )\n\t\t{\n\t\t\tString tmp = explainGenericInstruction(inst, level);\n\t\t\tsb.append( offsetInst );\n\t\t\tsb.append( tmp );\n\t\t\tsb.append( '\\n' );\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tprivate static String explainGenericInstruction( Instruction inst, int level )\n\t{\n\t\tString tmp = null;\n\t\tif( inst instanceof MRJobInstruction )\n\t\t\ttmp = explainMRJobInstruction((MRJobInstruction)inst, level+1);\n\t\telse if ( inst instanceof SPInstruction || inst instanceof CPInstruction || inst instanceof GPUInstruction)\n\t\t\ttmp = inst.toString();\n\t\tif( REPLACE_SPECIAL_CHARACTERS ){\n\t\t\ttmp = tmp.replaceAll(Lop.OPERAND_DELIMITOR, \" \");\n\t\t\ttmp = tmp.replaceAll(Lop.DATATYPE_PREFIX, \".\");\n\t\t\ttmp = tmp.replaceAll(Lop.INSTRUCTION_DELIMITOR, \", \");\n\t\t}\n\t\treturn tmp;\n\t}\n\tprivate static String explainMRJobInstruction( MRJobInstruction inst, int level )\n\t{\t\t\n\t\tString instruction = \"MR-Job[\\n\";\n\t\tString offset = createOffset(level+1);\n\t\tinstruction += offset+\"  jobtype        = \" + inst.getJobType() + \" \\n\";\n\t\tinstruction += offset+\"  input labels   = \" + Arrays.toString(inst.getInputVars()) + \" \\n\";\n\t\tinstruction += offset+\"  recReader inst = \" + inst.getIv_recordReaderInstructions() + \" \\n\";\n\t\tinstruction += offset+\"  rand inst      = \" + inst.getIv_randInstructions() + \" \\n\";\n\t\tinstruction += offset+\"  mapper inst    = \" + inst.getIv_instructionsInMapper() + \" \\n\";\n\t\tinstruction += offset+\"  shuffle inst   = \" + inst.getIv_shuffleInstructions() + \" \\n\";\n\t\tinstruction += offset+\"  agg inst       = \" + inst.getIv_aggInstructions() + \" \\n\";\n\t\tinstruction += offset+\"  other inst     = \" + inst.getIv_otherInstructions() + \" \\n\";\n\t\tinstruction += offset+\"  output labels  = \" + Arrays.toString(inst.getOutputVars()) + \" \\n\";\n\t\tinstruction += offset+\"  result indices = \" + inst.getString(inst.getIv_resultIndices()) + \" \\n\";\n\t\t//instruction += offset+\"result dims unknown \" + getString(iv_resultDimsUnknown) + \" \\n\";\n\t\tinstruction += offset+\"  num reducers   = \" + inst.getIv_numReducers() + \" \\n\";\n\t\tinstruction += offset+\"  replication    = \" + inst.getIv_replication() + \" ]\";\n\t\t//instruction += offset+\"]\\n\";\n\t\treturn instruction;\n\t}\n\t@SuppressWarnings(\"unused\")\n\tprivate static String showMem(double mem, boolean units) \n\t{\n\t\tif( !SHOW_MEM_ABOVE_BUDGET && mem >= OptimizerUtils.DEFAULT_SIZE )\n\t\t\treturn \"MAX\";\n\t\treturn OptimizerUtils.toMB(mem) + (units?\"MB\":\"\");\n\t}\n\tprivate static String createOffset( int level )\n\t{\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor( int i=0; i<level; i++ )\n\t\t\tsb.append(\"--\");\n\t\treturn sb.toString();\n\t}\n\tprivate static void countCompiledInstructions( Program rtprog, ExplainCounts counts, boolean MR, boolean CP, boolean SP )\n\t{\n\t\t//analyze DML-bodied functions\n\t\tfor( FunctionProgramBlock fpb : rtprog.getFunctionProgramBlocks().values() )\n\t\t\tcountCompiledInstructions( fpb, counts, MR, CP, SP );\n\t\t//analyze main program\n\t\tfor( ProgramBlock pb : rtprog.getProgramBlocks() ) \n\t\t\tcountCompiledInstructions( pb, counts, MR, CP, SP ); \n\t}\n\t/**\n\t * Recursively counts the number of compiled MRJob instructions in the\n\t * given runtime program block. \n\t * \n\t * @param pb program block\n\t * @param counts explain countst\n\t * @param MR if true, count Hadoop instructions\n\t * @param CP if true, count CP instructions\n\t * @param SP if true, count Spark instructions\n\t */\n<fim_suffix>\tprivate static void countCompiledInstructions(ProgramBlock pb, ExplainCounts counts, boolean MR, boolean CP, boolean SP) \n\t{\n\t\tif (pb instanceof WhileProgramBlock)\n\t\t{\n\t\t\tWhileProgramBlock tmp = (WhileProgramBlock)pb;\n\t\t\tcountCompiledInstructions(tmp.getPredicate(), counts, MR, CP, SP);\n\t\t\tfor (ProgramBlock pb2 : tmp.getChildBlocks())\n\t\t\t\tcountCompiledInstructions(pb2, counts, MR, CP, SP);\n\t\t}\n\t\telse if (pb instanceof IfProgramBlock)\n\t\t{\n\t\t\tIfProgramBlock tmp = (IfProgramBlock)pb;\t\n\t\t\tcountCompiledInstructions(tmp.getPredicate(), counts, MR, CP, SP);\n\t\t\tfor( ProgramBlock pb2 : tmp.getChildBlocksIfBody() )\n\t\t\t\tcountCompiledInstructions(pb2, counts, MR, CP, SP);\n\t\t\tfor( ProgramBlock pb2 : tmp.getChildBlocksElseBody() )\n\t\t\t\tcountCompiledInstructions(pb2, counts, MR, CP, SP);\n\t\t}\n\t\telse if (pb instanceof ForProgramBlock) //includes ParFORProgramBlock\n\t\t{ \n\t\t\tForProgramBlock tmp = (ForProgramBlock)pb;\t\n\t\t\tcountCompiledInstructions(tmp.getFromInstructions(), counts, MR, CP, SP);\n\t\t\tcountCompiledInstructions(tmp.getToInstructions(), counts, MR, CP, SP);\n\t\t\tcountCompiledInstructions(tmp.getIncrementInstructions(), counts, MR, CP, SP);\n\t\t\tfor( ProgramBlock pb2 : tmp.getChildBlocks() )\n\t\t\t\tcountCompiledInstructions(pb2, counts, MR, CP, SP);\n\t\t\t//additional parfor jobs counted during runtime\n\t\t}\t\t\n\t\telse if (  pb instanceof FunctionProgramBlock ) //includes ExternalFunctionProgramBlock and ExternalFunctionProgramBlockCP\n\t\t{\n\t\t\tFunctionProgramBlock fpb = (FunctionProgramBlock)pb;\n\t\t\tfor( ProgramBlock pb2 : fpb.getChildBlocks() )\n\t\t\t\tcountCompiledInstructions(pb2, counts, MR, CP, SP);\n\t\t}\n\t\telse \n\t\t{\n\t\t\tcountCompiledInstructions(pb.getInstructions(), counts, MR, CP, SP);\n\t\t}\n\t}<fim_middle>// function below is long method\n"}