{"text": "<fim_prefix>/*\n * Copyright (C) 2016 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.android.exoplayer2.extractor.mp4;\n\nimport android.support.annotation.Nullable;\nimport com.google.android.exoplayer2.util.Log;\nimport com.google.android.exoplayer2.util.ParsableByteArray;\nimport java.nio.ByteBuffer;\nimport java.util.UUID;\n\n/**\n * Utility methods for handling PSSH atoms.\n */\n<fim_suffix>public final class PsshAtomUtil {\n\n  private static final String TAG = \"PsshAtomUtil\";\n\n  private PsshAtomUtil() {}\n\n  /**\n   * Builds a version 0 PSSH atom for a given system id, containing the given data.\n   *\n   * @param systemId The system id of the scheme.\n   * @param data The scheme specific data.\n   * @return The PSSH atom.\n   */\n  public static byte[] buildPsshAtom(UUID systemId, @Nullable byte[] data) {\n    return buildPsshAtom(systemId, null, data);\n  }\n\n  /**\n   * Builds a PSSH atom for the given system id, containing the given key ids and data.\n   *\n   * @param systemId The system id of the scheme.\n   * @param keyIds The key ids for a version 1 PSSH atom, or null for a version 0 PSSH atom.\n   * @param data The scheme specific data.\n   * @return The PSSH atom.\n   */\n  @SuppressWarnings(\"ParameterNotNullable\")\n  public static byte[] buildPsshAtom(\n      UUID systemId, @Nullable UUID[] keyIds, @Nullable byte[] data) {\n    int dataLength = data != null ? data.length : 0;\n    int psshBoxLength = Atom.FULL_HEADER_SIZE + 16 /* SystemId */ + 4 /* DataSize */ + dataLength;\n    if (keyIds != null) {\n      psshBoxLength += 4 /* KID_count */ + (keyIds.length * 16) /* KIDs */;\n    }\n    ByteBuffer psshBox = ByteBuffer.allocate(psshBoxLength);\n    psshBox.putInt(psshBoxLength);\n    psshBox.putInt(Atom.TYPE_pssh);\n    psshBox.putInt(keyIds != null ? 0x01000000 : 0 /* version=(buildV1Atom ? 1 : 0), flags=0 */);\n    psshBox.putLong(systemId.getMostSignificantBits());\n    psshBox.putLong(systemId.getLeastSignificantBits());\n    if (keyIds != null) {\n      psshBox.putInt(keyIds.length);\n      for (UUID keyId : keyIds) {\n        psshBox.putLong(keyId.getMostSignificantBits());\n        psshBox.putLong(keyId.getLeastSignificantBits());\n      }\n    }\n    if (data != null && data.length != 0) {\n      psshBox.putInt(data.length);\n      psshBox.put(data);\n    } // Else the last 4 bytes are a 0 DataSize.\n    return psshBox.array();\n  }\n\n  /**\n   * Returns whether the data is a valid PSSH atom.\n   *\n   * @param data The data to parse.\n   * @return Whether the data is a valid PSSH atom.\n   */\n  public static boolean isPsshAtom(byte[] data) {\n    return parsePsshAtom(data) != null;\n  }\n\n  /**\n   * Parses the UUID from a PSSH atom. Version 0 and 1 PSSH atoms are supported.\n   *\n   * <p>The UUID is only parsed if the data is a valid PSSH atom.\n   *\n   * @param atom The atom to parse.\n   * @return The parsed UUID. Null if the input is not a valid PSSH atom, or if the PSSH atom has an\n   *     unsupported version.\n   */\n  public static @Nullable UUID parseUuid(byte[] atom) {\n    PsshAtom parsedAtom = parsePsshAtom(atom);\n    if (parsedAtom == null) {\n      return null;\n    }\n    return parsedAtom.uuid;\n  }\n\n  /**\n   * Parses the version from a PSSH atom. Version 0 and 1 PSSH atoms are supported.\n   * <p>\n   * The version is only parsed if the data is a valid PSSH atom.\n   *\n   * @param atom The atom to parse.\n   * @return The parsed version. -1 if the input is not a valid PSSH atom, or if the PSSH atom has\n   *     an unsupported version.\n   */\n  public static int parseVersion(byte[] atom) {\n    PsshAtom parsedAtom = parsePsshAtom(atom);\n    if (parsedAtom == null) {\n      return -1;\n    }\n    return parsedAtom.version;\n  }\n\n  /**\n   * Parses the scheme specific data from a PSSH atom. Version 0 and 1 PSSH atoms are supported.\n   *\n   * <p>The scheme specific data is only parsed if the data is a valid PSSH atom matching the given\n   * UUID, or if the data is a valid PSSH atom of any type in the case that the passed UUID is null.\n   *\n   * @param atom The atom to parse.\n   * @param uuid The required UUID of the PSSH atom, or null to accept any UUID.\n   * @return The parsed scheme specific data. Null if the input is not a valid PSSH atom, or if the\n   *     PSSH atom has an unsupported version, or if the PSSH atom does not match the passed UUID.\n   */\n  public static @Nullable byte[] parseSchemeSpecificData(byte[] atom, UUID uuid) {\n    PsshAtom parsedAtom = parsePsshAtom(atom);\n    if (parsedAtom == null) {\n      return null;\n    }\n    if (uuid != null && !uuid.equals(parsedAtom.uuid)) {\n      Log.w(TAG, \"UUID mismatch. Expected: \" + uuid + \", got: \" + parsedAtom.uuid + \".\");\n      return null;\n    }\n    return parsedAtom.schemeData;\n  }\n\n  /**\n   * Parses a PSSH atom. Version 0 and 1 PSSH atoms are supported.\n   *\n   * @param atom The atom to parse.\n   * @return The parsed PSSH atom. Null if the input is not a valid PSSH atom, or if the PSSH atom\n   *     has an unsupported version.\n   */\n  // TODO: Support parsing of the key ids for version 1 PSSH atoms.\n  private static @Nullable PsshAtom parsePsshAtom(byte[] atom) {\n    ParsableByteArray atomData = new ParsableByteArray(atom);\n    if (atomData.limit() < Atom.FULL_HEADER_SIZE + 16 /* UUID */ + 4 /* DataSize */) {\n      // Data too short.\n      return null;\n    }\n    atomData.setPosition(0);\n    int atomSize = atomData.readInt();\n    if (atomSize != atomData.bytesLeft() + 4) {\n      // Not an atom, or incorrect atom size.\n      return null;\n    }\n    int atomType = atomData.readInt();\n    if (atomType != Atom.TYPE_pssh) {\n      // Not an atom, or incorrect atom type.\n      return null;\n    }\n    int atomVersion = Atom.parseFullAtomVersion(atomData.readInt());\n    if (atomVersion > 1) {\n      Log.w(TAG, \"Unsupported pssh version: \" + atomVersion);\n      return null;\n    }\n    UUID uuid = new UUID(atomData.readLong(), atomData.readLong());\n    if (atomVersion == 1) {\n      int keyIdCount = atomData.readUnsignedIntToInt();\n      atomData.skipBytes(16 * keyIdCount);\n    }\n    int dataSize = atomData.readUnsignedIntToInt();\n    if (dataSize != atomData.bytesLeft()) {\n      // Incorrect dataSize.\n      return null;\n    }\n    byte[] data = new byte[dataSize];\n    atomData.readBytes(data, 0, dataSize);\n    return new PsshAtom(uuid, atomVersion, data);\n  }\n\n  // TODO: Consider exposing this and making parsePsshAtom public.\n  private static class PsshAtom {\n\n    private final UUID uuid;\n    private final int version;\n    private final byte[] schemeData;\n\n    public PsshAtom(UUID uuid, int version, byte[] schemeData) {\n      this.uuid = uuid;\n      this.version = version;\n      this.schemeData = schemeData;\n    }\n\n  }\n\n}<fim_middle>// class below has no smell\n"}