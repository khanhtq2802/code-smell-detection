{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.avro.tool;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.LinkedHashSet;\nimport java.util.List;\n\nimport org.apache.avro.Protocol;\nimport org.apache.avro.Schema;\nimport org.apache.avro.compiler.specific.SpecificCompiler.DateTimeLogicalTypeImplementation;\nimport org.apache.avro.generic.GenericData.StringType;\nimport org.apache.avro.compiler.specific.SpecificCompiler;\n\n/**\n * A Tool for compiling avro protocols or schemas to Java classes using the Avro\n * SpecificCompiler.\n */\n\npublic class SpecificCompilerTool implements Tool {\n  @Override\n  public int run(InputStream in, PrintStream out, PrintStream err,\n      List<String> args) throws Exception {\n    if (args.size() < 3) {\n      System.err\n          .println(\"Usage: [-encoding <outputencoding>] [-string] [-bigDecimal] [-dateTimeLogicalTypeImpl <dateTimeType>] [-templateDir <templateDir>] (schema|protocol) input... outputdir\");\n      System.err\n          .println(\" input - input files or directories\");\n      System.err\n          .println(\" outputdir - directory to write generated java\");\n      System.err.println(\" -encoding <outputencoding> - set the encoding of \" +\n          \"output file(s)\");\n      System.err.println(\" -string - use java.lang.String instead of Utf8\");\n      System.err.println(\" -bigDecimal - use java.math.BigDecimal for \" +\n          \"decimal type instead of java.nio.ByteBuffer\");\n      System.err.println(\" -dateTimeLogicalTypeImpl [joda|jsr310] - use either \" +\n          \"Joda time classes (default) or Java 8 native date/time classes (JSR 310)\");\n      System.err.println(\" -templateDir - directory with custom Velocity templates\");\n      return 1;\n    }\n\n    StringType stringType = StringType.CharSequence;\n    boolean useLogicalDecimal = false;\n    Optional<DateTimeLogicalTypeImplementation> dateTimeLogicalTypeImplementation = Optional.empty();\n    Optional<String> encoding = Optional.empty();\n    Optional<String> templateDir = Optional.empty();\n\n    int arg = 0;\n\n    if (\"-encoding\".equals(args.get(arg))) {\n      arg++;\n      encoding = Optional.of(args.get(arg));\n      arg++;\n    }\n\n    if (\"-string\".equals(args.get(arg))) {\n      stringType = StringType.String;\n      arg++;\n    }\n\n    if (\"-bigDecimal\".equalsIgnoreCase(args.get(arg))) {\n      useLogicalDecimal = true;\n      arg++;\n    }\n\n    if (\"-dateTimeLogicalTypeImpl\".equalsIgnoreCase(args.get(arg))) {\n      arg++;\n      try {\n        dateTimeLogicalTypeImplementation = Optional.of(DateTimeLogicalTypeImplementation.valueOf(args.get(arg).toUpperCase()));\n      } catch (IllegalArgumentException | IndexOutOfBoundsException e) {\n        System.err.println(\"Expected one of \" + Arrays.toString(DateTimeLogicalTypeImplementation.values()));\n        return 1;\n      }\n      arg++;\n    }\n\n    if (\"-templateDir\".equals(args.get(arg))) {\n      arg++;\n      templateDir = Optional.of(args.get(arg));\n      arg++;\n    }\n\n\n    String method = args.get(arg);\n    List<File> inputs = new ArrayList<>();\n    File output = new File(args.get(args.size() - 1));\n\n    for (int i = arg+1; i < args.size() - 1; i++) {\n      inputs.add(new File(args.get(i)));\n    }\n\n    if (\"schema\".equals(method)) {\n      Schema.Parser parser = new Schema.Parser();\n      for (File src : determineInputs(inputs, SCHEMA_FILTER)) {\n        Schema schema = parser.parse(src);\n        SpecificCompiler compiler = new SpecificCompiler(schema,\n          dateTimeLogicalTypeImplementation.orElse(DateTimeLogicalTypeImplementation.JODA));\n        executeCompiler(compiler, encoding, stringType, useLogicalDecimal, templateDir, src, output);\n      }\n    } else if (\"protocol\".equals(method)) {\n      for (File src : determineInputs(inputs, PROTOCOL_FILTER)) {\n        Protocol protocol = Protocol.parse(src);\n        SpecificCompiler compiler = new SpecificCompiler(protocol,\n          dateTimeLogicalTypeImplementation.orElse(DateTimeLogicalTypeImplementation.JODA));\n        executeCompiler(compiler, encoding, stringType, useLogicalDecimal, templateDir, src, output);\n      }\n    } else {\n      System.err.println(\"Expected \\\"schema\\\" or \\\"protocol\\\".\");\n      return 1;\n    }\n    return 0;\n  }\n\n  private void executeCompiler(SpecificCompiler compiler,\n                               Optional<String> encoding,\n                               StringType stringType,\n                               boolean enableDecimalLogicalType,\n                               Optional<String> templateDir,\n                               File src,\n                               File output) throws IOException {\n    compiler.setStringType(stringType);\n    templateDir.ifPresent(compiler::setTemplateDir);\n    compiler.setEnableDecimalLogicalType(enableDecimalLogicalType);\n    encoding.ifPresent(compiler::setOutputCharacterEncoding);\n    compiler.compileToDestination(src, output);\n  }\n\n  @Override\n  public String getName() {\n    return \"compile\";\n  }\n\n  @Override\n  public String getShortDescription() {\n    return \"Generates Java code for the given schema.\";\n  }\n\n  /**\n   * For a List of files or directories, returns a File[] containing each file\n   * passed as well as each file with a matching extension found in the directory.\n   *\n   * @param inputs List of File objects that are files or directories\n   * @param filter File extension filter to match on when fetching files from a directory\n   * @return Unique array of files\n   */\n  private static File[] determineInputs(List<File> inputs, FilenameFilter filter) {\n    Set<File> fileSet = new LinkedHashSet<>(); // preserve order and uniqueness\n\n    for (File file : inputs) {\n      // if directory, look at contents to see what files match extension\n      if (file.isDirectory()) {\n        File[] files = file.listFiles(filter);\n        Collections.addAll(fileSet, files != null ? files : new File[0]);\n      }\n      // otherwise, just add the file.\n      else {\n        fileSet.add(file);\n      }\n    }\n\n    if (fileSet.size() > 0) {\n      System.err.println(\"Input files to compile:\");\n      for (File file : fileSet) {\n        System.err.println(\"  \" + file);\n      }\n    }\n    else {\n      System.err.println(\"No input files found.\");\n    }\n\n    return fileSet.toArray(new File[0]);\n  }\n\n  private static final FileExtensionFilter SCHEMA_FILTER =\n    new FileExtensionFilter(\"avsc\");\n  private static final FileExtensionFilter PROTOCOL_FILTER =\n    new FileExtensionFilter(\"avpr\");\n\n<fim_suffix>  private static class FileExtensionFilter implements FilenameFilter {\n    private String extension;\n\n    private FileExtensionFilter(String extension) {\n      this.extension = extension;\n    }\n\n    @Override\n    public boolean accept(File dir, String name) {\n      return name.endsWith(this.extension);\n    }\n  }\n}<fim_middle>// class below has no smell\n"}