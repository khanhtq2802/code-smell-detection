{"text": "<fim_prefix>            systemConfig.getHeronLoggingMaximumSize(),\n            systemConfig.getHeronLoggingMaximumFiles()));\n    LoggingHelper.addLoggingHandler(new ErrorReportLoggingHandler());\n    LOG.info(String.format(\"Starting Metrics Manager for topology %s with topologyId %s with \"\n            + \"Metrics Manager Id %s, Merics Manager Port: %d, for cluster/role/env %s.\",\n        topologyName, topologyId, metricsmgrId, metricsPort,\n        String.format(\"%s/%s/%s\", cluster, role, environment)));\n    LOG.info(\"System Config: \" + systemConfig);\n    // Populate the config\n    MetricsSinksConfig sinksConfig = new MetricsSinksConfig(metricsSinksConfigFilename);\n    LOG.info(\"Sinks Config:\" + sinksConfig.toString());\n    MetricsManager metricsManager =\n        new MetricsManager(topologyName, cluster, role, environment,\n            METRICS_MANAGER_HOST, metricsPort, metricsmgrId, systemConfig, sinksConfig);\n    metricsManager.start();\n    LOG.info(\"Loops terminated. Metrics Manager exits.\");\n  }\n  private void setupJVMMetrics(Duration systemMetricsSampleInterval) {\n    this.jvmMetrics.registerMetrics(metricsCollector);\n    // Attach sample Runnable to gatewayMetricsCollector\n    this.metricsCollector.registerMetricSampleRunnable(jvmMetrics.getJVMSampleRunnable(),\n        systemMetricsSampleInterval);\n  }\n  private void setupInternalMetricsExport() {\n    Runnable gatherInternalMetrics = new Runnable() {\n      @Override\n      public void run() {\n        while (!metricsQueue.isEmpty()) {\n          Metrics.MetricPublisherPublishMessage message = metricsQueue.poll();\n          metricsManagerServer.onInternalMessage(metricsManagerPublisher, message);\n        }\n        // It schedules itself in future\n        metricsManagerServerLoop.registerTimerEvent(heronMetricsExportInterval,\n            this);\n      }\n    };\n    metricsManagerServerLoop.registerTimerEvent(heronMetricsExportInterval,\n        gatherInternalMetrics);\n  }\n  private SinkExecutor initSinkExecutor(String sinkId) {\n    IMetricsSink sink;\n    String classname =\n        (String) config.getConfigForSink(sinkId).get(MetricsSinksConfig.CONFIG_KEY_CLASSNAME);\n    try {\n      sink = (IMetricsSink) Class.forName(classname).newInstance();\n    } catch (InstantiationException e) {\n      throw new RuntimeException(e + \" IMetricsSink class must have a no-arg constructor.\");\n    } catch (IllegalAccessException e) {\n      throw new RuntimeException(e + \" IMetricsSink class must be concrete.\");\n    } catch (ClassNotFoundException e) {\n      throw new RuntimeException(e + \" IMetricsSink class must be a class path.\");\n    }\n    SlaveLooper sinkExecutorLoop = new SlaveLooper();\n    Communicator<MetricsRecord> executorInMetricsQueue =\n        new Communicator<MetricsRecord>(null, sinkExecutorLoop);\n    // Since MetricsCollector is not thread-safe,\n    // we need to specify individual MetricsCollector and MultiCountMetric\n    // for different SinkExecutor\n    MetricsCollector sinkMetricsCollector = new MetricsCollector(sinkExecutorLoop, metricsQueue);\n    MultiCountMetric internalCounters = new MultiCountMetric();\n    sinkMetricsCollector\n        .registerMetric(sinkId, internalCounters, (int) heronMetricsExportInterval.getSeconds());\n    // Set up the SinkContext\n    SinkContext sinkContext =\n        new SinkContextImpl(topologyName, cluster, role, environment,\n            metricsmgrId, sinkId, internalCounters);\n    SinkExecutor sinkExecutor =\n        new SinkExecutor(sinkId, sink, sinkExecutorLoop, executorInMetricsQueue, sinkContext);\n    sinkExecutor.setPropertyMap(config.getConfigForSink(sinkId));\n    return sinkExecutor;\n  }\n  public void start() {\n    LOG.info(\"Starting the Executors.\");\n    // Execute the SinkExecutor in separate threads\n    for (SinkExecutor executor : sinkExecutors.values()) {\n      executors.execute(executor);\n    }\n    // The MetricsManagerServer would run in the main thread\n    // We do it in the final step since it would await the main thread\n    LOG.info(\"Starting Metrics Manager Server\");\n    metricsManagerServer.start();\n    metricsManagerServerLoop.loop();\n  }\n  /**\n   * Handler for catching exceptions thrown by any threads (owned either by topology or heron\n   * infrastructure).\n   * When one IMetricsSink throws uncaught exceptions, we would try to restart this sink unless\n   * we have hit the # of retry attempts.\n   * When Metrics Manager internal exceptions are caught or we have restart IMetricsSink with\n   * too many attempts, Metrics Manager would flush any remain logs and exit.\n   */\n<fim_suffix>  public class DefaultExceptionHandler implements Thread.UncaughtExceptionHandler {\n    /**\n     * Handler for uncaughtException\n     */\n    public void uncaughtException(Thread thread, Throwable exception) {\n      // Add try and catch block to prevent new exceptions stop the handling thread\n      try {\n        // Delegate to the actual one\n        handleException(thread, exception);\n        // SUPPRESS CHECKSTYLE IllegalCatch\n      } catch (Throwable t) {\n        LOG.log(Level.SEVERE, \"Failed to handle exception. Process halting\", t);\n        Runtime.getRuntime().halt(1);\n      }\n    }\n    // The actual uncaught exceptions handing logic\n    private void handleException(Thread thread, Throwable exception) {\n      // We would fail fast when errors occur\n      if (exception instanceof Error) {\n        LOG.log(Level.SEVERE,\n            \"Error caught in thread: \" + thread.getName()\n                + \" with thread id: \" + thread.getId() + \". Process halting...\",\n            exception);\n        Runtime.getRuntime().halt(1);\n      }\n      // We would fail fast when exceptions happen in main thread\n      if (thread.getId() == mainThreadId) {\n        LOG.log(Level.SEVERE,\n            \"Exception caught in main thread. Process halting...\",\n            exception);\n        Runtime.getRuntime().halt(1);\n      }\n      LOG.log(Level.SEVERE,\n          \"Exception caught in thread: \" + thread.getName()\n              + \" with thread id: \" + thread.getId(),\n          exception);\n      String sinkId = null;\n      Integer thisSinkRetryAttempts = 0;\n      // We enforced the name of thread running particular IMetricsSink equal to its sink-id\n      // If the thread name is a key of SinkExecutors, then it is a thread running IMetricsSink\n      if (sinkExecutors.containsKey(thread.getName())) {\n        sinkId = thread.getName();\n        // Remove the old sink executor\n        SinkExecutor oldSinkExecutor = sinkExecutors.remove(sinkId);\n        // Remove the unneeded Communicator bind with Metrics Manager Server\n        metricsManagerServer.removeSinkCommunicator(oldSinkExecutor.getCommunicator());\n        // Close the sink\n        SysUtils.closeIgnoringExceptions(oldSinkExecutor);\n        thisSinkRetryAttempts = sinksRetryAttempts.remove(sinkId);\n      }\n      if (sinkId != null && thisSinkRetryAttempts != 0) {\n        LOG.info(String.format(\"Restarting IMetricsSink: %s with %d available retries\",\n            sinkId, thisSinkRetryAttempts));\n        // That means it was a sinkExecutor throwing exceptions and threadName is sinkId\n        SinkExecutor newSinkExecutor = initSinkExecutor(sinkId);\n        // Update the SinkExecutor in sinkExecutors\n        sinkExecutors.put(sinkId, newSinkExecutor);\n        // Update the retry attempts if it is > 0\n        if (thisSinkRetryAttempts > 0) {\n          thisSinkRetryAttempts--;\n        }\n        sinksRetryAttempts.put(sinkId, thisSinkRetryAttempts);\n        // Update the list of Communicator in Metrics Manager Server\n        metricsManagerServer.addSinkCommunicator(newSinkExecutor.getCommunicator());\n        // Restart it\n        executors.execute(newSinkExecutor);\n      } else if (sinkId != null\n          && thisSinkRetryAttempts == 0\n          && sinkExecutors.size() > 0) {\n        // If the dead executor is the only one executor and it is removed,\n        // e.g. sinkExecutors.size() == 0, we would exit the process directly\n        LOG.severe(\"Failed to recover from exceptions for IMetricsSink: \" + sinkId);\n        LOG.info(sinkId + \" would close and keep running rest sinks: \" + sinkExecutors.keySet());\n      } else {\n        // It is not recoverable (retried too many times, or not an exception from IMetricsSink)\n        // So we would do basic cleaning and exit\n        LOG.info(\"Failed to recover from exceptions; Metrics Manager Exiting\");\n        for (Handler handler : java.util.logging.Logger.getLogger(\"\").getHandlers()) {\n          handler.close();\n        }\n        // Attempts to shutdown all the thread in threadsPool. This will send Interrupt to every\n        // thread in the pool. Threads may implement a clean Interrupt logic.\n        executors.shutdownNow();\n        // (including threads not owned by HeronInstance). To be safe, not sending these\n        // interrupts.\n        Runtime.getRuntime().halt(1);\n      }\n    }\n  }<fim_middle>// class below has no smell\n"}