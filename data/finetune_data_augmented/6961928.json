{"text": "<fim_prefix>  abstract boolean equalsSameBits(HashCode that);\n  /**\n   * Creates a 32-bit {@code HashCode} representation of the given int value. The underlying bytes\n   * are interpreted in little endian order.\n   *\n   * @since 15.0 (since 12.0 in HashCodes)\n   */\n  public static HashCode fromInt(int hash) {\n    return new IntHashCode(hash);\n  }\n  private static final class IntHashCode extends HashCode implements Serializable {\n    final int hash;\n    IntHashCode(int hash) {\n      this.hash = hash;\n    }\n    @Override\n    public int bits() {\n      return 32;\n    }\n    @Override\n    public byte[] asBytes() {\n      return new byte[] {(byte) hash, (byte) (hash >> 8), (byte) (hash >> 16), (byte) (hash >> 24)};\n    }\n    @Override\n    public int asInt() {\n      return hash;\n    }\n    @Override\n    public long asLong() {\n      throw new IllegalStateException(\"this HashCode only has 32 bits; cannot create a long\");\n    }\n    @Override\n    public long padToLong() {\n      return UnsignedInts.toLong(hash);\n    }\n    @Override\n    void writeBytesToImpl(byte[] dest, int offset, int maxLength) {\n      for (int i = 0; i < maxLength; i++) {\n        dest[offset + i] = (byte) (hash >> (i * 8));\n      }\n    }\n    @Override\n    boolean equalsSameBits(HashCode that) {\n      return hash == that.asInt();\n    }\n    private static final long serialVersionUID = 0;\n  }\n  /**\n   * Creates a 64-bit {@code HashCode} representation of the given long value. The underlying bytes\n   * are interpreted in little endian order.\n   *\n   * @since 15.0 (since 12.0 in HashCodes)\n   */\n  public static HashCode fromLong(long hash) {\n    return new LongHashCode(hash);\n  }\n  private static final class LongHashCode extends HashCode implements Serializable {\n    final long hash;\n    LongHashCode(long hash) {\n      this.hash = hash;\n    }\n    @Override\n    public int bits() {\n      return 64;\n    }\n    @Override\n    public byte[] asBytes() {\n      return new byte[] {\n        (byte) hash,\n        (byte) (hash >> 8),\n        (byte) (hash >> 16),\n        (byte) (hash >> 24),\n        (byte) (hash >> 32),\n        (byte) (hash >> 40),\n        (byte) (hash >> 48),\n        (byte) (hash >> 56)\n      };\n    }\n    @Override\n    public int asInt() {\n      return (int) hash;\n    }\n    @Override\n    public long asLong() {\n      return hash;\n    }\n    @Override\n    public long padToLong() {\n      return hash;\n    }\n    @Override\n    void writeBytesToImpl(byte[] dest, int offset, int maxLength) {\n      for (int i = 0; i < maxLength; i++) {\n        dest[offset + i] = (byte) (hash >> (i * 8));\n      }\n    }\n    @Override\n    boolean equalsSameBits(HashCode that) {\n      return hash == that.asLong();\n    }\n    private static final long serialVersionUID = 0;\n  }\n  /**\n   * Creates a {@code HashCode} from a byte array. The array is defensively copied to preserve the\n   * immutability contract of {@code HashCode}. The array cannot be empty.\n   *\n   * @since 15.0 (since 12.0 in HashCodes)\n   */\n  public static HashCode fromBytes(byte[] bytes) {\n    checkArgument(bytes.length >= 1, \"A HashCode must contain at least 1 byte.\");\n    return fromBytesNoCopy(bytes.clone());\n  }\n  /**\n   * Creates a {@code HashCode} from a byte array. The array is <i>not</i> copied defensively, so it\n   * must be handed-off so as to preserve the immutability contract of {@code HashCode}.\n   */\n  static HashCode fromBytesNoCopy(byte[] bytes) {\n    return new BytesHashCode(bytes);\n  }\n  private static final class BytesHashCode extends HashCode implements Serializable {\n    final byte[] bytes;\n    BytesHashCode(byte[] bytes) {\n      this.bytes = checkNotNull(bytes);\n    }\n    @Override\n    public int bits() {\n      return bytes.length * 8;\n    }\n    @Override\n    public byte[] asBytes() {\n      return bytes.clone();\n    }\n    @Override\n    public int asInt() {\n      checkState(\n          bytes.length >= 4,\n          \"HashCode#asInt() requires >= 4 bytes (it only has %s bytes).\",\n          bytes.length);\n      return (bytes[0] & 0xFF)\n          | ((bytes[1] & 0xFF) << 8)\n          | ((bytes[2] & 0xFF) << 16)\n          | ((bytes[3] & 0xFF) << 24);\n    }\n    @Override\n    public long asLong() {\n      checkState(\n          bytes.length >= 8,\n          \"HashCode#asLong() requires >= 8 bytes (it only has %s bytes).\",\n          bytes.length);\n      return padToLong();\n    }\n    @Override\n    public long padToLong() {\n      long retVal = (bytes[0] & 0xFF);\n      for (int i = 1; i < Math.min(bytes.length, 8); i++) {\n        retVal |= (bytes[i] & 0xFFL) << (i * 8);\n      }\n      return retVal;\n    }\n    @Override\n    void writeBytesToImpl(byte[] dest, int offset, int maxLength) {\n      System.arraycopy(bytes, 0, dest, offset, maxLength);\n    }\n    @Override\n    byte[] getBytesInternal() {\n      return bytes;\n    }\n    @Override\n    boolean equalsSameBits(HashCode that) {\n      // We don't use MessageDigest.isEqual() here because its contract does not guarantee\n      // constant-time evaluation (no short-circuiting).\n      if (this.bytes.length != that.getBytesInternal().length) {\n        return false;\n      }\n      boolean areEqual = true;\n      for (int i = 0; i < this.bytes.length; i++) {\n        areEqual &= (this.bytes[i] == that.getBytesInternal()[i]);\n      }\n      return areEqual;\n    }\n    private static final long serialVersionUID = 0;\n  }\n  /**\n   * Creates a {@code HashCode} from a hexadecimal ({@code base 16}) encoded string. The string must\n   * be at least 2 characters long, and contain only valid, lower-cased hexadecimal characters.\n   *\n   * <p>This method accepts the exact format generated by {@link #toString}. If you require more\n   * lenient {@code base 16} decoding, please use {@link com.google.common.io.BaseEncoding#decode}\n   * (and pass the result to {@link #fromBytes}).\n   *\n   * @since 15.0\n   */\n  public static HashCode fromString(String string) {\n    checkArgument(\n        string.length() >= 2, \"input string (%s) must have at least 2 characters\", string);\n    checkArgument(\n        string.length() % 2 == 0,\n        \"input string (%s) must have an even number of characters\",\n        string);\n    byte[] bytes = new byte[string.length() / 2];\n    for (int i = 0; i < string.length(); i += 2) {\n      int ch1 = decode(string.charAt(i)) << 4;\n      int ch2 = decode(string.charAt(i + 1));\n      bytes[i / 2] = (byte) (ch1 + ch2);\n    }\n    return fromBytesNoCopy(bytes);\n  }\n  private static int decode(char ch) {\n    if (ch >= '0' && ch <= '9') {\n      return ch - '0';\n    }\n    if (ch >= 'a' && ch <= 'f') {\n      return ch - 'a' + 10;\n    }\n    throw new IllegalArgumentException(\"Illegal hexadecimal character: \" + ch);\n  }\n  /**\n   * Returns {@code true} if {@code object} is a {@link HashCode} instance with the identical byte\n   * representation to this hash code.\n   *\n   * <p><b>Security note:</b> this method uses a constant-time (not short-circuiting) implementation\n   * to protect against <a href=\"http://en.wikipedia.org/wiki/Timing_attack\">timing attacks</a>.\n   */\n<fim_suffix>  @Override\n  public final boolean equals(@Nullable Object object) {\n    if (object instanceof HashCode) {\n      HashCode that = (HashCode) object;\n      return bits() == that.bits() && equalsSameBits(that);\n    }\n    return false;\n  }<fim_middle>// function below has no smell\n"}