{"text": "<fim_prefix> * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.solr.query;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.apache.lucene.index.BaseTermsEnum;\nimport org.apache.lucene.index.ImpactsEnum;\nimport org.apache.lucene.index.IndexReader;\nimport org.apache.lucene.index.LeafReaderContext;\nimport org.apache.lucene.index.PostingsEnum;\nimport org.apache.lucene.index.Term;\nimport org.apache.lucene.index.TermState;\nimport org.apache.lucene.index.TermStates;\nimport org.apache.lucene.index.Terms;\nimport org.apache.lucene.index.TermsEnum;\nimport org.apache.lucene.search.BooleanClause;\nimport org.apache.lucene.search.BooleanQuery;\nimport org.apache.lucene.search.BulkScorer;\nimport org.apache.lucene.search.ConstantScoreQuery;\nimport org.apache.lucene.search.ConstantScoreScorer;\nimport org.apache.lucene.search.ConstantScoreWeight;\nimport org.apache.lucene.search.DocIdSet;\nimport org.apache.lucene.search.DocIdSetIterator;\nimport org.apache.lucene.search.IndexSearcher;\nimport org.apache.lucene.search.Query;\nimport org.apache.lucene.search.QueryVisitor;\nimport org.apache.lucene.search.ScoreMode;\nimport org.apache.lucene.search.Scorer;\nimport org.apache.lucene.search.TermQuery;\nimport org.apache.lucene.search.Weight;\nimport org.apache.lucene.util.AttributeSource;\nimport org.apache.lucene.util.BytesRef;\nimport org.apache.lucene.util.DocIdSetBuilder;\nimport org.apache.lucene.util.FixedBitSet;\nimport org.apache.solr.search.BitDocSet;\nimport org.apache.solr.search.DocSet;\nimport org.apache.solr.search.DocSetBuilder;\nimport org.apache.solr.search.DocSetProducer;\nimport org.apache.solr.search.DocSetUtil;\nimport org.apache.solr.search.ExtendedQueryBase;\nimport org.apache.solr.search.Filter;\nimport org.apache.solr.search.SolrIndexSearcher;\n/** @lucene.experimental */\npublic final class SolrRangeQuery extends ExtendedQueryBase implements DocSetProducer {\n  private final String field;\n  private final BytesRef lower;\n  private final BytesRef upper;\n  private byte flags;\n  private static byte FLAG_INC_LOWER = 0x01;\n  private static byte FLAG_INC_UPPER = 0x02;\n  public SolrRangeQuery(String field, BytesRef lower, BytesRef upper, boolean includeLower, boolean includeUpper) {\n    this.field = field;\n    this.lower = lower;\n    this.upper = upper;\n    this.flags = (byte)((this.lower != null && includeLower ? FLAG_INC_LOWER : 0) | (this.upper != null && includeUpper ? FLAG_INC_UPPER : 0));\n  }\n  public String getField() {\n    return field;\n  }\n  public boolean includeLower() {\n    return (flags & FLAG_INC_LOWER) != 0;\n  }\n  public boolean includeUpper() {\n    return (flags & FLAG_INC_UPPER) != 0;\n  }\n  @Override\n  public int hashCode() {\n    int hash = 0x8f2c9ba7 * (flags+1);  // avoid multiplying by 0\n    hash = hash * 29 + ((lower == null) ? 0 : lower.hashCode());  // TODO: simpler hash code here?\n    hash = hash * 29 + ((upper == null) ? 0 : upper.hashCode());\n    return hash;\n  }\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj) {\n      return true;\n    }\n    if (!(obj instanceof SolrRangeQuery)) {\n      return false;\n    }\n    SolrRangeQuery other = (SolrRangeQuery)obj;\n    return (this.flags == other.flags)\n        && (this.field.equals(other.field))\n        && (this.lower == other.lower || (this.lower != null && other.lower != null && this.lower.equals(other.lower)))\n        && (this.upper == other.upper || (this.upper != null && other.upper != null && this.upper.equals(other.upper)))\n        ;\n  }\n  @Override\n  public String toString(String field) {\n    StringBuilder buffer = new StringBuilder();\n    if (!getField().equals(field)) {\n      buffer.append(getField());\n      buffer.append(\":\");\n    }\n    // TODO: use our schema?\n    buffer.append(includeLower() ? '[' : '{');\n    buffer.append(endpoint(lower));\n    buffer.append(\" TO \");\n    buffer.append(endpoint(upper));\n    buffer.append(includeUpper() ? ']' : '}');\n    return buffer.toString();\n  }\n  @Override\n  public void visit(QueryVisitor visitor) {\n    visitor.visitLeaf(this);\n  }\n  private String endpoint(BytesRef ref) {\n    if (ref == null) return \"*\";\n    String toStr = Term.toString(ref);\n    if (\"*\".equals(toStr)) {\n      toStr = \"\\\\*\";\n    }\n    // TODO: other escaping\n    return toStr;\n  }\n  @Override\n  public Query rewrite(IndexReader reader) throws IOException {\n    return this;\n  }\n  @Override\n  public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {\n    return new ConstWeight(searcher, scoreMode, boost);\n    /*\n    DocSet docs = createDocSet(searcher.getIndexReader().leaves(), searcher.getIndexReader().maxDoc());\n    SolrConstantScoreQuery csq = new SolrConstantScoreQuery( docs.getTopFilter() );\n    return csq.createWeight(searcher, needScores);\n    */\n  }\n  @Override\n  public DocSet createDocSet(SolrIndexSearcher searcher) throws IOException {\n    return createDocSet( searcher, Math.min(64,(searcher.maxDoc()>>>10)+4) );\n  }\n  private DocSet createDocSet(SolrIndexSearcher searcher, long cost) throws IOException {\n    int maxDoc = searcher.maxDoc();\n    BitDocSet liveDocs = searcher.getLiveDocSet();\n    FixedBitSet liveBits = liveDocs.size() == maxDoc ? null : liveDocs.getBits();\n    DocSetBuilder builder = new DocSetBuilder(maxDoc, cost);\n    List<LeafReaderContext> leaves = searcher.getTopReaderContext().leaves();\n    int maxTermsPerSegment = 0;\n    for (LeafReaderContext ctx : leaves) {\n      TermsEnum te = getTermsEnum(ctx);\n      int termsVisited = builder.add(te, ctx.docBase);\n      maxTermsPerSegment = Math.max(maxTermsPerSegment, termsVisited);\n    }\n    DocSet set =  maxTermsPerSegment <= 1 ? builder.buildUniqueInOrder(liveBits) : builder.build(liveBits);\n    return DocSetUtil.getDocSet(set, searcher);\n  }\n  private class RangeTermsEnum extends BaseTermsEnum {\n    TermsEnum te;\n    BytesRef curr;\n    boolean positioned;\n    public RangeTermsEnum(Terms terms) throws IOException {\n      if (terms == null) {\n        positioned = true;\n      } else {\n        te = terms.iterator();\n        if (lower != null) {\n          TermsEnum.SeekStatus status = te.seekCeil(lower);\n          if (status == TermsEnum.SeekStatus.END) {\n            positioned = true;\n            curr = null;\n          } else if (status == SeekStatus.FOUND) {\n            positioned = includeLower();\n            curr = te.term();\n          } else {\n            // lower bound not found, so includeLower is irrelevant\n            positioned = true;\n            curr = te.term();\n          }\n        }\n      }\n    }\n    @Override\n    public SeekStatus seekCeil(BytesRef text) throws IOException {\n      return te.seekCeil(text);\n    }\n    @Override\n    public void seekExact(long ord) throws IOException {\n      te.seekExact(ord);\n    }\n    @Override\n    public BytesRef term() throws IOException {\n      return te.term(); // should be equal to curr, except if we went past the end\n    }\n    @Override\n    public long ord() throws IOException {\n      return te.ord();\n    }\n<fim_suffix>    @Override\n    public int docFreq() throws IOException {\n      return te.docFreq();\n    }<fim_middle>// function below has no smell\n"}