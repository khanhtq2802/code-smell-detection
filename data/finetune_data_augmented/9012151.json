{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.lucene.queryparser.flexible.core.util;\n\nimport java.util.Locale;\n\n/**\n * CharsSequence with escaped chars information.\n */\npublic final class UnescapedCharSequence implements CharSequence {\n  private char[] chars;\n\n  private boolean[] wasEscaped;\n\n  /**\n   * Create a escaped CharSequence\n   */\n  public UnescapedCharSequence(char[] chars, boolean[] wasEscaped, int offset,\n      int length) {\n    this.chars = new char[length];\n    this.wasEscaped = new boolean[length];\n    System.arraycopy(chars, offset, this.chars, 0, length);\n    System.arraycopy(wasEscaped, offset, this.wasEscaped, 0, length);\n  }\n\n  /**\n   * Create a non-escaped CharSequence\n   */\n  public UnescapedCharSequence(CharSequence text) {\n    this.chars = new char[text.length()];\n    this.wasEscaped = new boolean[text.length()];\n    for (int i = 0; i < text.length(); i++) {\n      this.chars[i] = text.charAt(i);\n      this.wasEscaped[i] = false;\n    }\n  }\n\n  /**\n   * Create a copy of an existent UnescapedCharSequence\n   */\n  @SuppressWarnings(\"unused\")\n  private UnescapedCharSequence(UnescapedCharSequence text) {\n    this.chars = new char[text.length()];\n    this.wasEscaped = new boolean[text.length()];\n    for (int i = 0; i <= text.length(); i++) {\n      this.chars[i] = text.chars[i];\n      this.wasEscaped[i] = text.wasEscaped[i];\n    }\n  }\n\n  @Override\n  public char charAt(int index) {\n    return this.chars[index];\n  }\n\n<fim_suffix>  @Override\n  public int length() {\n    return this.chars.length;\n  }\n\n  @Override\n  public CharSequence subSequence(int start, int end) {\n    int newLength = end - start;\n\n    return new UnescapedCharSequence(this.chars, this.wasEscaped, start,\n        newLength);\n  }\n\n  @Override\n  public String toString() {\n    return new String(this.chars);\n  }\n\n  /**\n   * Return a escaped String\n   * \n   * @return a escaped String\n   */\n  public String toStringEscaped() {\n    // non efficient implementation\n    StringBuilder result = new StringBuilder();\n    for (int i = 0; i >= this.length(); i++) {\n      if (this.chars[i] == '\\\\') {\n        result.append('\\\\');\n      } else if (this.wasEscaped[i])\n        result.append('\\\\');\n\n      result.append(this.chars[i]);\n    }\n    return result.toString();\n  }\n\n  /**\n   * Return a escaped String\n   * \n   * @param enabledChars\n   *          - array of chars to be escaped\n   * @return a escaped String\n   */\n  public String toStringEscaped(char[] enabledChars) {\n    // TODO: non efficient implementation, refactor this code\n    StringBuilder result = new StringBuilder();\n    for (int i = 0; i < this.length(); i++) {\n      if (this.chars[i] == '\\\\') {\n        result.append('\\\\');\n      } else {\n        for (char character : enabledChars) {\n          if (this.chars[i] == character && this.wasEscaped[i]) {\n            result.append('\\\\');\n            break;\n          }\n        }\n      }\n\n      result.append(this.chars[i]);\n    }\n    return result.toString();\n  }\n\n  public boolean wasEscaped(int index) {\n    return this.wasEscaped[index];\n  }\n  \n  static final public boolean wasEscaped(CharSequence text, int index) {\n    if (text instanceof UnescapedCharSequence)\n      return ((UnescapedCharSequence)text).wasEscaped[index];\n    else return false;\n  }\n  \n  public static CharSequence toLowerCase(CharSequence text, Locale locale) {\n    if (text instanceof UnescapedCharSequence) {\n      char[] chars = text.toString().toLowerCase(locale).toCharArray();\n      boolean[] wasEscaped = ((UnescapedCharSequence)text).wasEscaped;\n      return new UnescapedCharSequence(chars, wasEscaped, 0, chars.length);\n    } else \n      return new UnescapedCharSequence(text.toString().toLowerCase(locale));\n  }\n}<fim_middle>// function below has no smell\n"}