{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n * <p/>\n * http://www.apache.org/licenses/LICENSE-2.0\n * <p/>\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.myriad.state.utils;\nimport com.google.gson.Gson;\nimport com.google.gson.GsonBuilder;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.apache.commons.collections.CollectionUtils;\nimport org.apache.commons.lang.ArrayUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.mesos.Protos;\nimport org.apache.mesos.protobuf.GeneratedMessageV3;\nimport org.apache.myriad.scheduler.ServiceResourceProfile;\nimport org.apache.myriad.scheduler.constraints.Constraint;\nimport org.apache.myriad.scheduler.constraints.Constraint.Type;\nimport org.apache.myriad.scheduler.constraints.LikeConstraint;\nimport org.apache.myriad.state.NodeTask;\n/**\n * ByteBuffer support for the Serialization of the StoreContext\n */\npublic class ByteBufferSupport {\n  public static final int INT_SIZE = Integer.SIZE / Byte.SIZE;\n  public static final String UTF8 = \"UTF-8\";\n  public static final byte[] ZERO_BYTES = new byte[0];\n  private static Gson gson = new Gson();\n  private static Gson gsonCustom = new GsonBuilder().registerTypeAdapter(ServiceResourceProfile.class,\n      new ServiceResourceProfile.CustomDeserializer()).create();\n  public static void addByteBuffers(List<ByteBuffer> list, ByteArrayOutputStream bytes) throws IOException {\n    // If list, add the list size, then the size of each buffer followed by the buffer.\n    if (CollectionUtils.isNotEmpty(list)) {\n      bytes.write(toIntBytes(list.size()));\n      for (ByteBuffer bb : list) {\n        addByteBuffer(bb, bytes);\n      }\n    } else {\n      bytes.write(toIntBytes(0));\n    }\n  }\n  public static void addByteBuffer(ByteBuffer bb, ByteArrayOutputStream bytes) throws IOException {\n    if (byteBufferNotEmpty(bb)) {\n      bytes.write(toIntBytes(bb.array().length));\n      bytes.write(bb.array());\n    }\n  }\n  public static ByteBuffer toByteBuffer(Protos.TaskID taskId) {\n    return toBuffer(taskId);\n  }\n  public static ByteBuffer toByteBuffer(Protos.FrameworkID frameworkId) {\n    return toBuffer(frameworkId);\n  }\n  /*\n   * Common method to convert Protobuf object to ByteBuffer \n   */\n  public static ByteBuffer toBuffer(GeneratedMessageV3 message) {\n    byte dst[];\n    int size;\n    if (message != null) {\n      size = message.getSerializedSize() + INT_SIZE;\n      dst = message.toByteArray();\n    } else {\n      size = INT_SIZE;\n      dst = ZERO_BYTES;\n    }\n    ByteBuffer bb = createBuffer(size);\n    putBytes(bb, dst);\n    bb.rewind();\n    return bb;\n  }\n  public static byte[] toIntBytes(int src) {\n    ByteBuffer bb = createBuffer(INT_SIZE);\n    bb.putInt(src);\n    return bb.array();\n  }\n  public static ByteBuffer toByteBuffer(NodeTask nt) {\n    // Determine the size of ByteBuffer to allocate\n    // The ServiceResourceProfile toString() returns Json, if this ever changes then this\n    // will fail. Json is expected.\n    byte[] profile = toBytes(nt.getProfile().toString());\n    int size = profile.length + INT_SIZE;\n    Constraint constraint = nt.getConstraint();\n    Constraint.Type type = constraint == null ? Type.NULL : constraint.getType();\n    size += INT_SIZE;\n    byte[] constraintBytes = ZERO_BYTES;\n    if (constraint != null) {\n      constraintBytes = toBytes(constraint.toString());\n      size += constraintBytes.length + INT_SIZE;\n    } else {\n      size += INT_SIZE;\n    }\n    byte[] hostname = toBytes(nt.getHostname());\n    size += hostname.length + INT_SIZE;\n    if (nt.getSlaveId() != null) {\n      size += nt.getSlaveId().getSerializedSize() + INT_SIZE;\n    } else {\n      size += INT_SIZE;\n    }\n    if (nt.getTaskStatus() != null) {\n      size += nt.getTaskStatus().getSerializedSize() + INT_SIZE;\n    } else {\n      size += INT_SIZE;\n    }\n    if (nt.getExecutorInfo() != null) {\n      size += nt.getExecutorInfo().getSerializedSize() + INT_SIZE;\n    } else {\n      size += INT_SIZE;\n    }\n    byte[] taskPrefixBytes = ZERO_BYTES;\n    if (nt.getTaskPrefix() != null) {\n      taskPrefixBytes = toBytes(nt.getTaskPrefix());\n      size += taskPrefixBytes.length + INT_SIZE;\n    }\n    // Allocate and populate the buffer.\n    ByteBuffer bb = createBuffer(size);\n    putBytes(bb, profile);\n    bb.putInt(type.ordinal());\n    putBytes(bb, constraintBytes);\n    putBytes(bb, hostname);\n    putBytes(bb, getSlaveBytes(nt));\n    putBytes(bb, getTaskBytes(nt));\n    putBytes(bb, getExecutorInfoBytes(nt));\n    putBytes(bb, taskPrefixBytes);\n    // Make sure the buffer is at the beginning\n    bb.rewind();\n    return bb;\n  }\n  /**\n   * Assumes the entire ByteBuffer is a TaskID.\n   *\n   * @param bb\n   * @return Protos.TaskID\n   */\n  public static Protos.TaskID toTaskId(ByteBuffer bb) {\n    try {\n      return Protos.TaskID.parseFrom(getBytes(bb, bb.getInt()));\n    } catch (Exception e) {\n      throw new RuntimeException(\"Failed to parse Task ID\", e);\n    }\n  }\n  /**\n   * Assumes the entire ByteBuffer is a FrameworkID.\n   *\n   * @param bb\n   * @return Protos.FrameworkID\n   */\n<fim_suffix>  public static Protos.FrameworkID toFrameworkID(ByteBuffer bb) {\n    try {\n      return Protos.FrameworkID.parseFrom(getBytes(bb, bb.getInt()));\n    } catch (Exception e) {\n      throw new RuntimeException(\"Failed to parse Framework ID\", e);\n    }\n  }\n  /**\n   * ByteBuffer is expected to have a NodeTask at its next position.\n   *\n   * @param bb\n   * @return NodeTask or null if buffer is empty. Can throw a RuntimeException\n   * if the buffer is not formatted correctly.\n   */\n  public static NodeTask toNodeTask(ByteBuffer bb) {\n    NodeTask nt = null;\n    if (byteBufferNotEmpty(bb)) {\n      nt = new NodeTask(getServiceResourceProfile(bb), getConstraint(bb));\n      nt.setHostname(toString(bb));\n      nt.setSlaveId(toSlaveId(bb));\n      nt.setTaskStatus(toTaskStatus(bb));\n      nt.setExecutorInfo(toExecutorInfo(bb));\n      nt.setTaskPrefix(toString(bb));\n    }\n    return nt;\n  }\n  private static boolean byteBufferNotEmpty(ByteBuffer bb) {\n    return bb != null && bb.array().length > 0;\n  }\n  public static byte[] getTaskBytes(NodeTask nt) {\n    if (nt.getTaskStatus() != null) {\n      return nt.getTaskStatus().toByteArray();\n    } else {\n      return ZERO_BYTES;\n    }\n  }\n  public static byte[] getExecutorInfoBytes(NodeTask nt) {\n    if (nt.getExecutorInfo() != null) {\n      return nt.getExecutorInfo().toByteArray();\n    } else {\n      return ZERO_BYTES;\n    }\n  }\n  public static byte[] getSlaveBytes(NodeTask nt) {\n    if (nt.getSlaveId() != null) {\n      return nt.getSlaveId().toByteArray();\n    } else {\n      return ZERO_BYTES;\n    }\n  }\n  public static void putBytes(ByteBuffer bb, byte bytes[]) {\n    if (ArrayUtils.isNotEmpty(bytes)) {\n      bb.putInt(bytes.length);\n      bb.put(bytes);\n    } else {\n      bb.putInt(0);\n    }\n  }\n  public static byte[] getBytes(ByteBuffer bb, int size) {\n    byte bytes[] = new byte[size];\n    bb.get(bytes);\n    return bytes;\n  }\n  /**\n   * This assumes the next position is the size as an int, and the following is a string<fim_middle>// function below has no smell\n"}