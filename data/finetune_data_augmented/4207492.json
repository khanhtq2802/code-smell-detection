{"text": "<fim_prefix>    /**\n     * Called to determine whether this index can provide a searcher to execute a query on the\n     * supplied column using the specified operator. This forms part of the query validation done\n     * before a CQL select statement is executed.\n     * @param column the target column of a search query predicate\n     * @param operator the operator of a search query predicate\n     * @return true if this index is capable of supporting such expressions, false otherwise\n     */\n    public boolean supportsExpression(ColumnMetadata column, Operator operator);\n    /**\n     * If the index supports custom search expressions using the\n     * {@code}SELECT * FROM table WHERE expr(index_name, expression){@code} syntax, this\n     * method should return the expected type of the expression argument.\n     * For example, if the index supports custom expressions as Strings, calls to this\n     * method should return {@code}UTF8Type.instance{@code}.\n     * If the index implementation does not support custom expressions, then it should\n     * return null.\n     * @return an the type of custom index expressions supported by this index, or an\n     *         null if custom expressions are not supported.\n     */\n    public AbstractType<?> customExpressionValueType();\n    /**\n     * Transform an initial RowFilter into the filter that will still need to applied\n     * to a set of Rows after the index has performed it's initial scan.\n     * Used in ReadCommand#executeLocal to reduce the amount of filtering performed on the\n     * results of the index query.\n     *\n     * @param filter the intial filter belonging to a ReadCommand\n     * @return the (hopefully) reduced filter that would still need to be applied after\n     *         the index was used to narrow the initial result set\n     */\n    public RowFilter getPostIndexQueryFilter(RowFilter filter);\n    /**\n     * Return an estimate of the number of results this index is expected to return for any given\n     * query that it can be used to answer. Used in conjunction with indexes() and supportsExpression()\n     * to determine the most selective index for a given ReadCommand. Additionally, this is also used\n     * by StorageProxy.estimateResultsPerRange to calculate the initial concurrency factor for range requests\n     *\n     * @return the estimated average number of results a Searcher may return for any given query\n     */\n    public long getEstimatedResultRows();\n    /*\n     * Input validation\n     */\n    /**\n     * Called at write time to ensure that values present in the update\n     * are valid according to the rules of all registered indexes which\n     * will process it. The partition key as well as the clustering and\n     * cell values for each row in the update may be checked by index\n     * implementations\n     * @param update PartitionUpdate containing the values to be validated by registered Index implementations\n     * @throws InvalidRequestException\n     */\n    public void validate(PartitionUpdate update) throws InvalidRequestException;\n    /*\n     * Update processing\n     */\n    /**\n     * Creates an new {@code Indexer} object for updates to a given partition.\n     *\n     * @param key key of the partition being modified\n     * @param columns the regular and static columns the created indexer will have to deal with.\n     * This can be empty as an update might only contain partition, range and row deletions, but\n     * the indexer is guaranteed to not get any cells for a column that is not part of {@code columns}.\n     * @param nowInSec current time of the update operation\n     * @param ctx WriteContext spanning the update operation\n     * @param transactionType indicates what kind of update is being performed on the base data\n     *                        i.e. a write time insert/update/delete or the result of compaction\n     * @return the newly created indexer or {@code null} if the index is not interested by the update\n     * (this could be because the index doesn't care about that particular partition, doesn't care about\n     * that type of transaction, ...).\n     */\n    public Indexer indexerFor(DecoratedKey key,\n                              RegularAndStaticColumns columns,\n                              int nowInSec,\n                              WriteContext ctx,\n                              IndexTransaction.Type transactionType);\n    /**\n     * Listener for processing events emitted during a single partition update.\n     * Instances of this are responsible for applying modifications to the index in response to a single update\n     * operation on a particular partition of the base table.\n     *\n     * That update may be generated by the normal write path, by iterating SSTables during streaming operations or when\n     * building or rebuilding an index from source. Updates also occur during compaction when multiple versions of a\n     * source partition from different SSTables are merged.\n     *\n     * Implementations should not make assumptions about resolution or filtering of the partition update being\n     * processed. That is to say that it is possible for an Indexer instance to receive notification of a\n     * PartitionDelete or RangeTombstones which shadow a Row it then receives via insertRow/updateRow.\n     *\n     * It is important to note that the only ordering guarantee made for the methods here is that the first call will\n     * be to begin() and the last call to finish(). The other methods may be called to process update events in any\n     * order. This can also include duplicate calls, in cases where a memtable partition is under contention from\n     * several updates. In that scenario, the same set of events may be delivered to the Indexer as memtable update\n     * which failed due to contention is re-applied.\n     */\n<fim_suffix>    public interface Indexer\n    {\n        /**\n         * Notification of the start of a partition update.\n         * This event always occurs before any other during the update.\n         */\n        public void begin();\n        /**\n         * Notification of a top level partition delete.\n         * @param deletionTime\n         */\n        public void partitionDelete(DeletionTime deletionTime);\n        /**\n         * Notification of a RangeTombstone.\n         * An update of a single partition may contain multiple RangeTombstones,\n         * and a notification will be passed for each of them.\n         * @param tombstone\n         */\n        public void rangeTombstone(RangeTombstone tombstone);\n        /**\n         * Notification that a new row was inserted into the Memtable holding the partition.\n         * This only implies that the inserted row was not already present in the Memtable,\n         * it *does not* guarantee that the row does not exist in an SSTable, potentially with\n         * additional column data.\n         *\n         * @param row the Row being inserted into the base table's Memtable.\n         */\n        public void insertRow(Row row);\n        /**\n         * Notification of a modification to a row in the base table's Memtable.\n         * This is allow an Index implementation to clean up entries for base data which is\n         * never flushed to disk (and so will not be purged during compaction).\n         * It's important to note that the old and new rows supplied here may not represent\n         * the totality of the data for the Row with this particular Clustering. There may be\n         * additional column data in SSTables which is not present in either the old or new row,\n         * so implementations should be aware of that.\n         * The supplied rows contain only column data which has actually been updated.\n         * oldRowData contains only the columns which have been removed from the Row's\n         * representation in the Memtable, while newRowData includes only new columns\n         * which were not previously present. Any column data which is unchanged by\n         * the update is not included.\n         *\n         * @param oldRowData data that was present in existing row and which has been removed from\n         *                   the base table's Memtable\n         * @param newRowData data that was not present in the existing row and is being inserted\n         *                   into the base table's Memtable\n         */\n        public void updateRow(Row oldRowData, Row newRowData);\n        /**\n         * Notification that a row was removed from the partition.\n         * Note that this is only called as part of either a compaction or a cleanup.\n         * This context is indicated by the TransactionType supplied to the indexerFor method.\n         *\n         * As with updateRow, it cannot be guaranteed that all data belonging to the Clustering\n         * of the supplied Row has been removed (although in the case of a cleanup, that is the\n         * ultimate intention).\n         * There may be data for the same row in other SSTables, so in this case Indexer implementations\n         * should *not* assume that all traces of the row have been removed. In particular,\n         * it is not safe to assert that all values associated with the Row's Clustering\n         * have been deleted, so implementations which index primary key columns should not\n         * purge those entries from their indexes.\n         *\n         * @param row data being removed from the base table\n         */\n        public void removeRow(Row row);\n        /**\n         * Notification of the end of the partition update.\n         * This event always occurs after all others for the particular update.\n         */\n        public void finish();\n    }<fim_middle>// class below has no smell\n"}