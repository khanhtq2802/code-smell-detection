{"text": "<fim_prefix> */\nfinal class TextReader {\n  static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(TextReader.class);\n  private static final byte NULL_BYTE = (byte) '\\0';\n  private final TextParsingContext context;\n  private final long recordsToRead;\n  private final TextParsingSettings settings;\n  private final TextInput input;\n  private final TextOutput output;\n  private final DrillBuf workBuf;\n  private byte ch;\n  // index of the field within this record\n  private int fieldIndex;\n  /** Behavior settings **/\n  private final boolean ignoreTrailingWhitespace;\n  private final boolean ignoreLeadingWhitespace;\n  private final boolean parseUnescapedQuotes;\n  /** Key Characters **/\n  private final byte comment;\n  private final byte delimiter;\n  private final byte quote;\n  private final byte quoteEscape;\n  private final byte newLine;\n  /**\n   * The CsvParser supports all settings provided by {@link CsvParserSettings}, and requires this configuration to be\n   * properly initialized.\n   * @param settings  the parser configuration\n   * @param input  input stream\n   * @param output  interface to produce output record batch\n   * @param workBuf  working buffer to handle whitespaces\n   */\n  public TextReader(TextParsingSettings settings, TextInput input, TextOutput output, DrillBuf workBuf) {\n    this.context = new TextParsingContext(input, output);\n    this.workBuf = workBuf;\n    this.settings = settings;\n    this.recordsToRead = settings.getNumberOfRecordsToRead() == -1 ? Long.MAX_VALUE : settings.getNumberOfRecordsToRead();\n    this.ignoreTrailingWhitespace = settings.isIgnoreTrailingWhitespaces();\n    this.ignoreLeadingWhitespace = settings.isIgnoreLeadingWhitespaces();\n    this.parseUnescapedQuotes = settings.isParseUnescapedQuotes();\n    this.delimiter = settings.getDelimiter();\n    this.quote = settings.getQuote();\n    this.quoteEscape = settings.getQuoteEscape();\n    this.newLine = settings.getNormalizedNewLine();\n    this.comment = settings.getComment();\n    this.input = input;\n    this.output = output;\n  }\n  public TextOutput getOutput(){\n    return output;\n  }\n  /* Check if the given byte is a white space. As per the univocity text reader\n   * any ASCII <= ' ' is considered a white space. However since byte in JAVA is signed\n   * we have an additional check to make sure its not negative\n   */\n  static final boolean isWhite(byte b){\n    return b <= ' ' && b > -1;\n  }\n  // Inform the output interface to indicate we are starting a new record batch\n  public void resetForNextBatch(){\n    output.startBatch();\n  }\n  public long getPos(){\n    return input.getPos();\n  }\n  /**\n   * Function encapsulates parsing an entire record, delegates parsing of the\n   * fields to parseField() function.\n   * We mark the start of the record and if there are any failures encountered (OOM for eg)\n   * then we reset the input stream to the marked position\n   * @return  true if parsing this record was successful; false otherwise\n   * @throws IOException\n   */\n  private boolean parseRecord() throws IOException {\n    final byte newLine = this.newLine;\n    final TextInput input = this.input;\n    input.mark();\n    fieldIndex = 0;\n    if (isWhite(ch) && ignoreLeadingWhitespace) {\n      skipWhitespace();\n    }\n    int fieldsWritten = 0;\n    try{\n      boolean earlyTerm = false;\n      while (ch != newLine) {\n        earlyTerm = !parseField();\n        fieldsWritten++;\n        if (ch != newLine) {\n          ch = input.nextChar();\n          if (ch == newLine) {\n            output.startField(fieldsWritten++);\n            output.endEmptyField();\n            break;\n          }\n        }\n        if(earlyTerm){\n          if(ch != newLine){\n            input.skipLines(1);\n          }\n          break;\n        }\n      }\n    }catch(StreamFinishedPseudoException e){\n      // if we've written part of a field or all of a field, we should send this row.\n      if(fieldsWritten == 0 && !output.rowHasData()){\n        throw e;\n      }\n    }\n    output.finishRecord();\n    return true;\n  }\n  /**\n   * Function parses an individual field and ignores any white spaces encountered\n   * by not appending it to the output vector\n   * @throws IOException\n   */\n  private void parseValueIgnore() throws IOException {\n    final byte newLine = this.newLine;\n    final byte delimiter = this.delimiter;\n    final TextOutput output = this.output;\n    final TextInput input = this.input;\n    byte ch = this.ch;\n    while (ch != delimiter && ch != newLine) {\n      output.appendIgnoringWhitespace(ch);\n//      fieldSize++;\n      ch = input.nextChar();\n    }\n    this.ch = ch;\n  }\n  /**\n   * Function parses an individual field and appends all characters till the delimeter (or newline)\n   * to the output, including white spaces\n   * @throws IOException\n   */\n  private void parseValueAll() throws IOException {\n    final byte newLine = this.newLine;\n    final byte delimiter = this.delimiter;\n    final TextOutput output = this.output;\n    final TextInput input = this.input;\n    byte ch = this.ch;\n    while (ch != delimiter && ch != newLine) {\n      output.append(ch);\n      ch = input.nextChar();\n    }\n    this.ch = ch;\n  }\n  /**\n   * Function simply delegates the parsing of a single field to the actual implementation based on parsing config\n   * @throws IOException\n   */\n  private void parseValue() throws IOException {\n    if (ignoreTrailingWhitespace) {\n      parseValueIgnore();\n    }else{\n      parseValueAll();\n    }\n  }\n  /**\n   * Recursive function invoked when a quote is encountered. Function also\n   * handles the case when there are non-white space characters in the field\n   * after the quoted value.\n   * @param prev  previous byte read\n   * @throws IOException\n   */\n<fim_suffix>  private void parseQuotedValue(byte prev) throws IOException {\n    final byte newLine = this.newLine;\n    final byte delimiter = this.delimiter;\n    final TextOutput output = this.output;\n    final TextInput input = this.input;\n    final byte quote = this.quote;\n    ch = input.nextCharNoNewLineCheck();\n    while (!(prev == quote && (ch == delimiter || ch == newLine || isWhite(ch)))) {\n      if (ch != quote) {\n        if (prev == quote) { // unescaped quote detected\n          if (parseUnescapedQuotes) {\n            output.append(quote);\n            output.append(ch);\n            parseQuotedValue(ch);\n            break;\n          } else {\n            throw new TextParsingException(\n                context,\n                \"Unescaped quote character '\"\n                    + quote\n                    + \"' inside quoted value of CSV field. To allow unescaped quotes, set 'parseUnescapedQuotes' to 'true' in the CSV parser settings. Cannot parse CSV input.\");\n          }\n        }\n        output.append(ch);\n        prev = ch;\n      } else if (prev == quoteEscape) {\n        output.append(quote);\n        prev = NULL_BYTE;\n      } else {\n        prev = ch;\n      }\n      ch = input.nextCharNoNewLineCheck();\n    }\n    // Handles whitespaces after quoted value:\n    // Whitespaces are ignored (i.e., ch <= ' ') if they are not used as delimiters (i.e., ch != ' ')\n    // For example, in tab-separated files (TSV files), '\\t' is used as delimiter and should not be ignored\n    // Content after whitespaces may be parsed if 'parseUnescapedQuotes' is enabled.\n    if (ch != newLine && ch <= ' ' && ch != delimiter) {\n      final DrillBuf workBuf = this.workBuf;\n      workBuf.resetWriterIndex();\n      do {\n        // saves whitespaces after value\n        workBuf.writeByte(ch);\n        ch = input.nextChar();\n        // found a new line, go to next record.\n        if (ch == newLine) {\n          return;\n        }\n      } while (ch <= ' ' && ch != delimiter);\n      // there's more stuff after the quoted value, not only empty spaces.\n      if (!(ch == delimiter || ch == newLine) && parseUnescapedQuotes) {\n        output.append(quote);\n        for(int i =0; i < workBuf.writerIndex(); i++){\n          output.append(workBuf.getByte(i));\n        }\n        // the next character is not the escape character, put it there\n        if (ch != quoteEscape) {\n          output.append(ch);\n        }\n        // sets this character as the previous character (may be escaping)\n        // calls recursively to keep parsing potentially quoted content\n        parseQuotedValue(ch);\n      }\n    }\n    if (!(ch == delimiter || ch == newLine)) {\n      throw new TextParsingException(context, \"Unexpected character '\" + ch\n          + \"' following quoted value of CSV field. Expecting '\" + delimiter + \"'. Cannot parse CSV input.\");\n    }\n  }<fim_middle>// function below is long method\n"}