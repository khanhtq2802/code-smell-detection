{"text": "<fim_prefix> *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.springframework.jca.cci.connection;\nimport javax.resource.ResourceException;\nimport javax.resource.cci.Connection;\nimport javax.resource.cci.ConnectionFactory;\nimport javax.resource.cci.ConnectionSpec;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.springframework.jca.cci.CannotGetCciConnectionException;\nimport org.springframework.lang.Nullable;\nimport org.springframework.transaction.support.ResourceHolderSynchronization;\nimport org.springframework.transaction.support.TransactionSynchronizationManager;\nimport org.springframework.util.Assert;\n/**\n * Helper class that provides static methods for obtaining CCI Connections\n * from a {@link javax.resource.cci.ConnectionFactory}. Includes special\n * support for Spring-managed transactional Connections, e.g. managed\n * by {@link CciLocalTransactionManager} or\n * {@link org.springframework.transaction.jta.JtaTransactionManager}.\n *\n * <p>Used internally by {@link org.springframework.jca.cci.core.CciTemplate},\n * Spring's CCI operation objects and the {@link CciLocalTransactionManager}.\n * Can also be used directly in application code.\n *\n * @author Thierry Templier\n * @author Juergen Hoeller\n * @since 1.2\n * @see #getConnection\n * @see #releaseConnection\n * @see CciLocalTransactionManager\n * @see org.springframework.transaction.jta.JtaTransactionManager\n * @see org.springframework.transaction.support.TransactionSynchronizationManager\n */\n<fim_suffix>public abstract class ConnectionFactoryUtils {\n\tprivate static final Log logger = LogFactory.getLog(ConnectionFactoryUtils.class);\n\t/**\n\t * Obtain a Connection from the given ConnectionFactory. Translates ResourceExceptions\n\t * into the Spring hierarchy of unchecked generic data access exceptions, simplifying\n\t * calling code and making any exception that is thrown more meaningful.\n\t * <p>Is aware of a corresponding Connection bound to the current thread, for example\n\t * when using {@link CciLocalTransactionManager}. Will bind a Connection to the thread\n\t * if transaction synchronization is active (e.g. if in a JTA transaction).\n\t * @param cf the ConnectionFactory to obtain Connection from\n\t * @return a CCI Connection from the given ConnectionFactory\n\t * @throws org.springframework.jca.cci.CannotGetCciConnectionException\n\t * if the attempt to get a Connection failed\n\t * @see #releaseConnection\n\t */\n\tpublic static Connection getConnection(ConnectionFactory cf) throws CannotGetCciConnectionException {\n\t\treturn getConnection(cf, null);\n\t}\n\t/**\n\t * Obtain a Connection from the given ConnectionFactory. Translates ResourceExceptions\n\t * into the Spring hierarchy of unchecked generic data access exceptions, simplifying\n\t * calling code and making any exception that is thrown more meaningful.\n\t * <p>Is aware of a corresponding Connection bound to the current thread, for example\n\t * when using {@link CciLocalTransactionManager}. Will bind a Connection to the thread\n\t * if transaction synchronization is active (e.g. if in a JTA transaction).\n\t * @param cf the ConnectionFactory to obtain Connection from\n\t * @param spec the ConnectionSpec for the desired Connection (may be {@code null}).\n\t * Note: If this is specified, a new Connection will be obtained for every call,\n\t * without participating in a shared transactional Connection.\n\t * @return a CCI Connection from the given ConnectionFactory\n\t * @throws org.springframework.jca.cci.CannotGetCciConnectionException\n\t * if the attempt to get a Connection failed\n\t * @see #releaseConnection\n\t */\n\tpublic static Connection getConnection(ConnectionFactory cf, @Nullable ConnectionSpec spec)\n\t\t\tthrows CannotGetCciConnectionException {\n\t\ttry {\n\t\t\tif (spec != null) {\n\t\t\t\tAssert.notNull(cf, \"No ConnectionFactory specified\");\n\t\t\t\treturn cf.getConnection(spec);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn doGetConnection(cf);\n\t\t\t}\n\t\t}\n\t\tcatch (ResourceException ex) {\n\t\t\tthrow new CannotGetCciConnectionException(\"Could not get CCI Connection\", ex);\n\t\t}\n\t}\n\t/**\n\t * Actually obtain a CCI Connection from the given ConnectionFactory.\n\t * Same as {@link #getConnection}, but throwing the original ResourceException.\n\t * <p>Is aware of a corresponding Connection bound to the current thread, for example\n\t * when using {@link CciLocalTransactionManager}. Will bind a Connection to the thread\n\t * if transaction synchronization is active (e.g. if in a JTA transaction).\n\t * <p>Directly accessed by {@link TransactionAwareConnectionFactoryProxy}.\n\t * @param cf the ConnectionFactory to obtain Connection from\n\t * @return a CCI Connection from the given ConnectionFactory\n\t * @throws ResourceException if thrown by CCI API methods\n\t * @see #doReleaseConnection\n\t */\n\tpublic static Connection doGetConnection(ConnectionFactory cf) throws ResourceException {\n\t\tAssert.notNull(cf, \"No ConnectionFactory specified\");\n\t\tConnectionHolder conHolder = (ConnectionHolder) TransactionSynchronizationManager.getResource(cf);\n\t\tif (conHolder != null) {\n\t\t\treturn conHolder.getConnection();\n\t\t}\n\t\tlogger.debug(\"Opening CCI Connection\");\n\t\tConnection con = cf.getConnection();\n\t\tif (TransactionSynchronizationManager.isSynchronizationActive()) {\n\t\t\tconHolder = new ConnectionHolder(con);\n\t\t\tconHolder.setSynchronizedWithTransaction(true);\n\t\t\tTransactionSynchronizationManager.registerSynchronization(new ConnectionSynchronization(conHolder, cf));\n\t\t\tTransactionSynchronizationManager.bindResource(cf, conHolder);\n\t\t}\n\t\treturn con;\n\t}\n\t/**\n\t * Determine whether the given JCA CCI Connection is transactional, that is,\n\t * bound to the current thread by Spring's transaction facilities.\n\t * @param con the Connection to check\n\t * @param cf the ConnectionFactory that the Connection was obtained from\n\t * (may be {@code null})\n\t * @return whether the Connection is transactional\n\t */\n\tpublic static boolean isConnectionTransactional(Connection con, @Nullable ConnectionFactory cf) {\n\t\tif (cf == null) {\n\t\t\treturn false;\n\t\t}\n\t\tConnectionHolder conHolder = (ConnectionHolder) TransactionSynchronizationManager.getResource(cf);\n\t\treturn (conHolder != null && conHolder.getConnection() == con);\n\t}\n\t/**\n\t * Close the given Connection, obtained from the given ConnectionFactory,\n\t * if it is not managed externally (that is, not bound to the thread).\n\t * @param con the Connection to close if necessary\n\t * (if this is {@code null}, the call will be ignored)\n\t * @param cf the ConnectionFactory that the Connection was obtained from\n\t * (can be {@code null})\n\t * @see #getConnection\n\t */\n\tpublic static void releaseConnection(@Nullable Connection con, @Nullable ConnectionFactory cf) {\n\t\ttry {\n\t\t\tdoReleaseConnection(con, cf);\n\t\t}\n\t\tcatch (ResourceException ex) {\n\t\t\tlogger.debug(\"Could not close CCI Connection\", ex);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\t// We don't trust the CCI driver: It might throw RuntimeException or Error.\n\t\t\tlogger.debug(\"Unexpected exception on closing CCI Connection\", ex);\n\t\t}\n\t}\n\t/**\n\t * Actually close the given Connection, obtained from the given ConnectionFactory.\n\t * Same as {@link #releaseConnection}, but throwing the original ResourceException.\n\t * <p>Directly accessed by {@link TransactionAwareConnectionFactoryProxy}.\n\t * @param con the Connection to close if necessary\n\t * (if this is {@code null}, the call will be ignored)\n\t * @param cf the ConnectionFactory that the Connection was obtained from\n\t * (can be {@code null})\n\t * @throws ResourceException if thrown by JCA CCI methods\n\t * @see #doGetConnection\n\t */\n\tpublic static void doReleaseConnection(@Nullable Connection con, @Nullable ConnectionFactory cf)\n\t\t\tthrows ResourceException {\n\t\tif (con == null || isConnectionTransactional(con, cf)) {\n\t\t\treturn;\n\t\t}\n\t\tcon.close();\n\t}\n\t/**\n\t * Callback for resource cleanup at the end of a non-native CCI transaction\n\t * (e.g. when participating in a JTA transaction).\n\t */\n\tprivate static class ConnectionSynchronization\n\t\t\textends ResourceHolderSynchronization<ConnectionHolder, ConnectionFactory> {\n\t\tpublic ConnectionSynchronization(ConnectionHolder connectionHolder, ConnectionFactory connectionFactory) {\n\t\t\tsuper(connectionHolder, connectionFactory);\n\t\t}\n\t\t@Override\n\t\tprotected void releaseResource(ConnectionHolder resourceHolder, ConnectionFactory resourceKey) {\n\t\t\treleaseConnection(resourceHolder.getConnection(), resourceKey);\n\t\t}\n\t}\n}<fim_middle>// class below has no smell\n"}