{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.nifi.toolkit.cli.impl.client;\n\nimport org.apache.commons.cli.MissingOptionException;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.nifi.registry.security.util.KeystoreType;\nimport org.apache.nifi.toolkit.cli.api.ClientFactory;\nimport org.apache.nifi.toolkit.cli.impl.client.nifi.ControllerClient;\nimport org.apache.nifi.toolkit.cli.impl.client.nifi.FlowClient;\nimport org.apache.nifi.toolkit.cli.impl.client.nifi.NiFiClient;\nimport org.apache.nifi.toolkit.cli.impl.client.nifi.NiFiClientConfig;\nimport org.apache.nifi.toolkit.cli.impl.client.nifi.ProcessGroupClient;\nimport org.apache.nifi.toolkit.cli.impl.client.nifi.VersionsClient;\nimport org.apache.nifi.toolkit.cli.impl.client.nifi.impl.JerseyNiFiClient;\nimport org.apache.nifi.toolkit.cli.impl.command.CommandOption;\n\nimport java.io.IOException;\nimport java.util.Properties;\n\n/**\n * Factory for obtaining an instance of NiFiClient from the given properties.\n */\npublic class NiFiClientFactory implements ClientFactory<NiFiClient> {\n\n    @Override\n    public NiFiClient createClient(final Properties properties) throws MissingOptionException {\n        final String url = properties.getProperty(CommandOption.URL.getLongName());\n        if (StringUtils.isBlank(url)) {\n            throw new MissingOptionException(\"Missing required option '\" + CommandOption.URL.getLongName() + \"'\");\n        }\n\n        final String keystore = properties.getProperty(CommandOption.KEYSTORE.getLongName());\n        final String keystoreType = properties.getProperty(CommandOption.KEYSTORE_TYPE.getLongName());\n        final String keystorePasswd = properties.getProperty(CommandOption.KEYSTORE_PASSWORD.getLongName());\n        final String keyPasswd = properties.getProperty(CommandOption.KEY_PASSWORD.getLongName());\n\n        final String truststore = properties.getProperty(CommandOption.TRUSTSTORE.getLongName());\n        final String truststoreType = properties.getProperty(CommandOption.TRUSTSTORE_TYPE.getLongName());\n        final String truststorePasswd = properties.getProperty(CommandOption.TRUSTSTORE_PASSWORD.getLongName());\n\n        final String proxiedEntity = properties.getProperty(CommandOption.PROXIED_ENTITY.getLongName());\n        final String protocol = properties.getProperty(CommandOption.PROTOCOL.getLongName());\n\n        final boolean secureUrl = url.startsWith(\"https\");\n\n        if (secureUrl && (StringUtils.isBlank(truststore)\n                || StringUtils.isBlank(truststoreType)\n                || StringUtils.isBlank(truststorePasswd))\n                ) {\n            throw new MissingOptionException(CommandOption.TRUSTSTORE.getLongName() + \", \" + CommandOption.TRUSTSTORE_TYPE.getLongName()\n                    + \", and \" + CommandOption.TRUSTSTORE_PASSWORD.getLongName() + \" are required when using an https url\");\n        }\n\n        final NiFiClientConfig.Builder clientConfigBuilder = new NiFiClientConfig.Builder()\n                .baseUrl(url);\n\n        if (secureUrl) {\n            if (!StringUtils.isBlank(keystore)) {\n                clientConfigBuilder.keystoreFilename(keystore);\n            }\n            if (!StringUtils.isBlank(keystoreType)) {\n                clientConfigBuilder.keystoreType(KeystoreType.valueOf(keystoreType.toUpperCase()));\n            }\n            if (!StringUtils.isBlank(keystorePasswd)) {\n                clientConfigBuilder.keystorePassword(keystorePasswd);\n            }\n            if (!StringUtils.isBlank(keyPasswd)) {\n                clientConfigBuilder.keyPassword(keyPasswd);\n            }\n            if (!StringUtils.isBlank(truststore)) {\n                clientConfigBuilder.truststoreFilename(truststore);\n            }\n            if (!StringUtils.isBlank(truststoreType)) {\n                clientConfigBuilder.truststoreType(KeystoreType.valueOf(truststoreType.toUpperCase()));\n            }\n            if (!StringUtils.isBlank(truststorePasswd)) {\n                clientConfigBuilder.truststorePassword(truststorePasswd);\n            }\n            if (!StringUtils.isBlank(protocol)) {\n                clientConfigBuilder.protocol(protocol);\n            }\n        }\n\n        final NiFiClient client = new JerseyNiFiClient.Builder().config(clientConfigBuilder.build()).build();\n\n        // if a proxied entity was specified then return a wrapped client, otherwise return the regular client\n        if (!StringUtils.isBlank(proxiedEntity)) {\n            return new NiFiClientFactory.ProxiedNiFiClient(client, proxiedEntity);\n        } else {\n            return client;\n        }\n    }\n\n    /**\n     * Wraps a NiFiClient and ensures that all methods to obtain a more specific client will\n     * call the proxied-entity variation so that callers don't have to care if proxying is taking place.\n     */\n<fim_suffix>    private static class ProxiedNiFiClient implements NiFiClient {\n\n        private final String proxiedEntity;\n        private final NiFiClient wrappedClient;\n\n        public ProxiedNiFiClient(final NiFiClient wrappedClient, final String proxiedEntity) {\n            this.proxiedEntity = proxiedEntity;\n            this.wrappedClient = wrappedClient;\n        }\n\n        @Override\n        public ControllerClient getControllerClient() {\n            return wrappedClient.getControllerClientForProxiedEntities(proxiedEntity);\n        }\n\n        @Override\n        public ControllerClient getControllerClientForProxiedEntities(String... proxiedEntity) {\n            return wrappedClient.getControllerClientForProxiedEntities(proxiedEntity);\n        }\n\n        @Override\n        public ControllerClient getControllerClientForToken(String token) {\n            return wrappedClient.getControllerClientForToken(token);\n        }\n\n        @Override\n        public FlowClient getFlowClient() {\n            return wrappedClient.getFlowClientForProxiedEntities(proxiedEntity);\n        }\n\n        @Override\n        public FlowClient getFlowClientForProxiedEntities(String... proxiedEntity) {\n            return wrappedClient.getFlowClientForProxiedEntities(proxiedEntity);\n        }\n\n        @Override\n        public FlowClient getFlowClientForToken(String token) {\n            return wrappedClient.getFlowClientForToken(token);\n        }\n\n        @Override\n        public ProcessGroupClient getProcessGroupClient() {\n            return wrappedClient.getProcessGroupClientForProxiedEntities(proxiedEntity);\n        }\n\n        @Override\n        public ProcessGroupClient getProcessGroupClientForProxiedEntities(String... proxiedEntity) {\n            return wrappedClient.getProcessGroupClientForProxiedEntities(proxiedEntity);\n        }\n\n        @Override\n        public ProcessGroupClient getProcessGroupClientForToken(String token) {\n            return wrappedClient.getProcessGroupClientForToken(token);\n        }\n\n        @Override\n        public VersionsClient getVersionsClient() {\n            return wrappedClient.getVersionsClientForProxiedEntities(proxiedEntity);\n        }\n\n        @Override\n        public VersionsClient getVersionsClientForProxiedEntities(String... proxiedEntity) {\n            return wrappedClient.getVersionsClientForProxiedEntities(proxiedEntity);\n        }\n\n        @Override\n        public VersionsClient getVersionsClientForToken(String token) {\n            return wrappedClient.getVersionsClientForToken(token);\n        }\n\n        @Override\n        public void close() throws IOException {\n            wrappedClient.close();\n        }\n    }\n}<fim_middle>// class below has no smell\n"}