{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.pig.builtin;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Set;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.apache.pig.backend.executionengine.ExecException;\nimport org.apache.pig.data.DataBag;\nimport org.apache.pig.data.Tuple;\nimport org.apache.pig.impl.PigContext;\nimport org.apache.pig.impl.logicalLayer.FrontendException;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Sets;\npublic class Invoker<T>  {\n    private static final Log LOG = LogFactory.getLog(Invoker.class);\n    private static final Class<?> DOUBLE_ARRAY_CLASS = new double[0].getClass();\n    private static final Class<?> INT_ARRAY_CLASS = new int[0].getClass();\n    private static final Class<?> FLOAT_ARRAY_CLASS = new float[0].getClass();\n    private static final Class<?> STRING_ARRAY_CLASS = new String[0].getClass();\n    private static final Class<?> LONG_ARRAY_CLASS = new long[0].getClass();\n    @SuppressWarnings(\"unchecked\")\n    private static final Set<Class<?>> ARRAY_CLASSES = Sets.newHashSet(\n        DOUBLE_ARRAY_CLASS, INT_ARRAY_CLASS, FLOAT_ARRAY_CLASS, STRING_ARRAY_CLASS,\n        LONG_ARRAY_CLASS);\n    private Method method_;\n    private Class<?>[] paramClasses_;\n    private boolean isStatic_;\n    private Class<?> selfClass_;\n    private Type returnType_;\n    public Invoker(String fullName, String paramSpecsStr)\n    throws ClassNotFoundException, FrontendException, SecurityException, NoSuchMethodException {\n        this(fullName, paramSpecsStr, \"true\");\n    }\n    public Invoker(String fullName, String paramSpecsStr, String isStatic)\n    throws ClassNotFoundException, FrontendException, SecurityException, NoSuchMethodException {\n        String className = fullName.substring(0, fullName.lastIndexOf('.'));\n        String methodName = fullName.substring(fullName.lastIndexOf('.')+1);\n        Class<?> klazz;\n        try {\n            klazz = PigContext.resolveClassName(className);\n        } catch (IOException e) {\n            // the amusing part is that PigContext throws this to wrap one of\n            // the exceptions we declare!\n            throw new FrontendException(e);\n        }\n        String[] paramSpecs = \"\".equals(paramSpecsStr) ? new String[0] : paramSpecsStr.split(\" \");\n        isStatic_ = \"static\".equalsIgnoreCase(isStatic) || \"true\".equals(isStatic);\n        paramClasses_ = new Class<?>[paramSpecs.length];\n        for (int i = 0; i < paramSpecs.length; i++) {\n            paramClasses_[i] = stringToClass(paramSpecs[i]);\n        }\n        if (!isStatic_) {\n            selfClass_ = paramClasses_[0];\n        }\n        method_ = klazz.getMethod(methodName, (isStatic_ ? paramClasses_ : dropFirstClass(paramClasses_)));\n        returnType_ = method_.getGenericReturnType();\n    }\n    @SuppressWarnings(\"rawtypes\")\n    public Type getReturnType() {\n        return unPrimitivize((Class) returnType_);\n    }\n    private static Class<?>[] dropFirstClass(Class<?>[] original) {\n        if (original.length < 2) {\n            return new Class[0];\n        } else {\n            return Arrays.copyOfRange(original, 1, original.length-1);\n        }\n    }\n    private static Object[] dropFirstObject(Object[] original) {\n        if (original.length < 2) {\n            return new Object[0];\n        } else {\n            return Arrays.copyOfRange(original, 1, original.length-1);\n        }\n    }\n<fim_suffix>    private static Class<?> stringToClass(String klass) throws FrontendException {\n        if (\"string\".equalsIgnoreCase(klass)) {\n            return String.class;\n        } else if (\"int\".equalsIgnoreCase(klass)) {\n            return Integer.TYPE;\n        } else if (\"double\".equalsIgnoreCase(klass)) {\n            return Double.TYPE;\n        } else if (\"float\".equalsIgnoreCase(klass)){\n            return Float.TYPE;\n        } else if (\"long\".equalsIgnoreCase(klass)) {\n            return Long.TYPE;\n        } else if (\"double[]\".equalsIgnoreCase(klass)) {\n          return DOUBLE_ARRAY_CLASS;\n        } else if (\"int[]\".equalsIgnoreCase(klass)) {\n          return INT_ARRAY_CLASS;\n        } else if (\"long[]\".equalsIgnoreCase(klass)) {\n          return LONG_ARRAY_CLASS;\n        } else if (\"float[]\".equalsIgnoreCase(klass)) {\n          return FLOAT_ARRAY_CLASS;\n        } else if (\"string[]\".equalsIgnoreCase(klass)) {\n          return STRING_ARRAY_CLASS;\n        } else {\n            throw new FrontendException(\"unable to find matching class for \" + klass);\n        }\n    }\n    private static Class<?> unPrimitivize(Class<?> klass) {\n        if (klass.equals(Integer.TYPE)) {\n            return Integer.class;\n        } if (klass.equals(Long.TYPE)) {\n            return Long.class;\n        } else if (klass.equals(Float.TYPE)) {\n            return Float.class;\n        } else if (klass.equals(Double.TYPE)) {\n            return Double.class;\n        } else {\n          return klass;\n        }\n    }\n    private static <T> T convertToExpectedArg(Class<T> klass, Object obj) throws ExecException {\n      if (ARRAY_CLASSES.contains(klass)) {\n        DataBag dbag = (DataBag) obj;\n        if (STRING_ARRAY_CLASS.equals(klass)) {\n          List<String> dataList = Lists.newArrayList();\n          for (Tuple t : dbag) {\n            dataList.add( (String) t.get(0));\n          }\n          String[] dataArray = new String[dataList.size()];\n          for (int i = 0; i < dataList.size(); i++) {\n            dataArray[i] = dataList.get(i);\n          }\n          obj = dataArray;\n        } else {\n          List<Number> dataList = bagToNumberList(dbag);\n          if (DOUBLE_ARRAY_CLASS.equals(klass)) {\n            double[] dataArray = new double[dataList.size()];\n            for (int i = 0; i < dataList.size(); i++) {\n              dataArray[i] = dataList.get(i).doubleValue();\n            }\n            obj = dataArray;\n          } else if (INT_ARRAY_CLASS.equals(klass)) {\n            int[] dataArray = new int[dataList.size()];\n            for (int i = 0; i < dataList.size(); i++) {\n              dataArray[i] = dataList.get(i).intValue();\n            }\n            obj = dataArray;\n          } else if (FLOAT_ARRAY_CLASS.equals(klass)) {\n            float[] dataArray = new float[dataList.size()];\n            for (int i = 0; i < dataList.size(); i++) {\n              dataArray[i] = dataList.get(i).floatValue();\n            }\n            obj = dataArray;\n          } else if (LONG_ARRAY_CLASS.equals(klass)) {\n            long[] dataArray = new long[dataList.size()];\n            for (int i = 0; i < dataList.size(); i++) {\n              dataArray[i] = dataList.get(i).longValue();\n            }\n            obj = dataArray;\n          }\n        }\n      }\n      try {\n        return klass.cast(obj);\n      } catch (ClassCastException e) {\n        LOG.error(\"Error in dynamic argument processing. Casting to: \"\n            + klass + \" from: \" + obj.getClass(), e);\n        throw new ExecException(e);\n      }\n    }\n    private static List<Number> bagToNumberList(DataBag dbag) throws ExecException {\n      List<Number> dataList = Lists.newArrayList();\n      for (Tuple t : dbag) {\n        dataList.add( (Number) t.get(0));\n      }\n      return dataList;\n    }\n    private Object[] tupleToArgs(Tuple t) throws ExecException {<fim_middle>// function below is long method and feature envy\n"}