{"text": "<fim_prefix>/*******************************************************************************\n * Copyright (c) 2012, 2013 Pivotal Software, Inc.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     Pivotal Software, Inc. - initial API and implementation\n *******************************************************************************/\npackage org.grails.ide.eclipse.core.launch;\nimport static org.grails.ide.eclipse.core.launch.LaunchListenerManager.getLaunchListener;\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URI;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.StringTokenizer;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.resources.ResourcesPlugin;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.NullProgressMonitor;\nimport org.eclipse.core.runtime.Status;\nimport org.eclipse.core.runtime.SubProgressMonitor;\nimport org.eclipse.core.runtime.jobs.Job;\nimport org.eclipse.debug.core.DebugEvent;\nimport org.eclipse.debug.core.DebugPlugin;\nimport org.eclipse.debug.core.IDebugEventSetListener;\nimport org.eclipse.debug.core.ILaunch;\nimport org.eclipse.debug.core.ILaunchConfiguration;\nimport org.eclipse.debug.core.ILaunchConfigurationType;\nimport org.eclipse.debug.core.ILaunchConfigurationWorkingCopy;\nimport org.eclipse.debug.core.ILaunchManager;\nimport org.eclipse.debug.core.model.IDebugTarget;\nimport org.eclipse.debug.core.model.IProcess;\nimport org.eclipse.jdt.internal.launching.LaunchingMessages;\nimport org.eclipse.jdt.launching.AbstractJavaLaunchConfigurationDelegate;\nimport org.eclipse.jdt.launching.IJavaLaunchConfigurationConstants;\nimport org.eclipse.jdt.launching.IVMConnector;\nimport org.eclipse.jdt.launching.IVMInstall;\nimport org.eclipse.jdt.launching.IVMRunner;\nimport org.eclipse.jdt.launching.JavaRuntime;\nimport org.eclipse.jdt.launching.VMRunnerConfiguration;\nimport org.eclipse.osgi.util.NLS;\nimport org.grails.ide.eclipse.core.GrailsCoreActivator;\nimport org.grails.ide.eclipse.core.model.GrailsBuildSettingsHelper;\nimport org.grails.ide.eclipse.core.model.GrailsVersion;\nimport org.grails.ide.eclipse.core.model.IGrailsInstall;\nimport org.grails.ide.eclipse.core.util.PortFinder;\nimport org.grails.ide.eclipse.core.workspace.GrailsWorkspace;\nimport org.grails.ide.eclipse.runtime.shared.DependencyData;\nimport org.springsource.ide.eclipse.commons.core.HttpUtil;\n/**\n * @author Christian Dupuis\n * @since 2.2.0\n */\npublic class GrailsLaunchConfigurationDelegate extends AbstractJavaLaunchConfigurationDelegate { \n\tprivate static final String SCRIPT_ATTR = GrailsCoreActivator.PLUGIN_ID + \".SCRIPT\";\n\tprivate static final String ORG_SCRIPT_ATTR = GrailsCoreActivator.PLUGIN_ID + \".ORG_SCRIPT\";\n\tprivate PortFinder portFinder = new PortFinder();\n\tstatic {\n\t\tLaunchListenerManager\n\t\t\t\t.promiseSupportForType(getLaunchConfigurationTypeId());\n\t}\n\t@Override\n\tpublic boolean preLaunchCheck(ILaunchConfiguration conf,\n\t\t\tString mode, IProgressMonitor monitor) throws CoreException {\n\t\tIGrailsInstall install = GrailsLaunchArgumentUtils.getGrailsInstall(conf);\n\t\tIStatus status = install.verify();\n\t\tif (!status.isOK()) {\n\t\t\tthrow new CoreException(status);\n\t\t}\n\t\treturn super.preLaunchCheck(conf, mode, monitor);\n\t}\n<fim_suffix>\t@Override\n\tpublic IVMInstall verifyVMInstall(ILaunchConfiguration conf) throws CoreException {\n\t\tIVMInstall javaInstall = super.verifyVMInstall(conf);\n\t\tIGrailsInstall grailsInstall = GrailsLaunchArgumentUtils.getGrailsInstall(conf);\n\t\tgrailsInstall.verifyJavaInstall(javaInstall);\n\t\treturn javaInstall;\n\t}\n\t/**\n\t * Create debugging target similar to a remote debugging session would and add them to the launch.\n\t * This is to support debugging of 'forked mode' run-app and test-app processes. These are\n\t * processes spun-off by Grails in new JVM. \n\t * @param port the remote launch will be listening on for forked process to connect to.\n\t */\n\tprivate void launchRemote(int port, ILaunchConfiguration configuration, String mode, ILaunch launch, IProgressMonitor monitor) throws CoreException {\n\t\tif (port<0) {\n\t\t\treturn;\n\t\t}\n\t\tif (monitor == null) {\n\t\t\tmonitor = new NullProgressMonitor();\n\t\t}\n\t\tmonitor.beginTask(NLS.bind(LaunchingMessages.JavaRemoteApplicationLaunchConfigurationDelegate_Attaching_to__0_____1, new String[]{configuration.getName()}), 3); \n\t\t// check for cancellation\n\t\tif (monitor.isCanceled()) {\n\t\t\treturn;\n\t\t}\t\t\t\t\t\t\n\t\ttry {\t\t\t\n\t\t\tmonitor.subTask(LaunchingMessages.JavaRemoteApplicationLaunchConfigurationDelegate_Verifying_launch_attributes____1); \n\t\t\tString connectorId = \"org.eclipse.jdt.launching.socketListenConnector\";//getVMConnectorId(configuration);\n\t\t\tIVMConnector connector = JavaRuntime.getVMConnector(connectorId);\n\t\t\tif (connector == null) {\n\t\t\t\tabort(LaunchingMessages.JavaRemoteApplicationLaunchConfigurationDelegate_Connector_not_specified_2, null, IJavaLaunchConfigurationConstants.ERR_CONNECTOR_NOT_AVAILABLE); \n\t\t\t}\n\t\t\tMap<String, String> argMap = new HashMap<String, String>();\n//\t        int connectTimeout = Platform.getPreferencesService().getInt(\n//\t        \t\tLaunchingPlugin.ID_PLUGIN, \n//\t        \t\tJavaRuntime.PREF_CONNECT_TIMEOUT, \n//\t        \t\tJavaRuntime.DEF_CONNECT_TIMEOUT, \n//\t        \t\tnull);\n\t        argMap.put(\"timeout\", \"120000\"); // Give grails run-app command enough time to build the app and kick off a forked process.\n\t        argMap.put(\"port\", \"\"+port);\n\t\t\t// check for cancellation\n\t\t\tif (monitor.isCanceled()) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmonitor.worked(1);\n\t\t\t//Don't think we need to set source location since the main launch method already does this.\n//\t\t\tmonitor.subTask(LaunchingMessages.JavaRemoteApplicationLaunchConfigurationDelegate_Creating_source_locator____2); \n//\t\t\t// set the default source locator if required\n//\t\t\tsetDefaultSourceLocator(launch, configuration);\n//\t\t\tmonitor.worked(1);\t\t\n\t\t\t// connect to remote VM\n\t\t\tconnector.connect(argMap, monitor, launch);\n\t\t\t// check for cancellation\n\t\t\tif (monitor.isCanceled()) {\n\t\t\t\tIDebugTarget[] debugTargets = launch.getDebugTargets();\n\t            for (int i = 0; i < debugTargets.length; i++) {\n\t                IDebugTarget target = debugTargets[i];\n\t                if (target.canDisconnect()) {\n\t                    target.disconnect();\n\t                }\n\t            }\n\t            return;\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tmonitor.done();\n\t\t}\n\t}\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void launch(ILaunchConfiguration configuration, String mode, ILaunch launch, IProgressMonitor monitor)\n\t\t\tthrows CoreException {\n\t\ttry {\n\t\t\tGrailsVersion version = GrailsLaunchArgumentUtils.getGrailsVersion(configuration);\n\t\t\tIProgressMonitor subMonitor = new SubProgressMonitor(monitor, 5);\n\t\t\tcheckCancelled(subMonitor);\n\t\t\tsubMonitor.beginTask(\"Starting Grails\", 5);\n\t\t\tsubMonitor.worked(1);\n\t\t\tcheckCancelled(subMonitor);\n\t\t\tsubMonitor.subTask(\"Configuring launch parameters...\");\n\t\t\t// FIXKDV FIXADE Copies of this code exist in \n\t        // GrailsLaunchArgumentUtils.prepareClasspath()\n\t        // and GrailsLaunchConfigurationDelegate.launch()\n\t        // consider refactoring to combine\n\t\t\tIVMRunner runner;\n\t\t\tIVMInstall vm = verifyVMInstall(configuration);<fim_middle>// function below has no smell\n"}