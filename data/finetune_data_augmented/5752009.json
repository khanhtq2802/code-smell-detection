{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.tajo.storage.jdbc;\n\nimport com.google.common.base.Function;\nimport org.apache.tajo.catalog.Column;\nimport org.apache.tajo.exception.TajoRuntimeException;\nimport org.apache.tajo.exception.UnsupportedException;\nimport org.apache.tajo.plan.Target;\nimport org.apache.tajo.plan.expr.EvalNode;\nimport org.apache.tajo.plan.logical.*;\nimport org.apache.tajo.util.StringUtils;\n\nimport javax.annotation.Nullable;\nimport java.sql.DatabaseMetaData;\nimport java.util.List;\nimport java.util.Stack;\n\n/**\n * Generator to build a SQL statement from a plan fragment\n */\npublic class SQLBuilder {\n  @SuppressWarnings(\"unused\")\n  private final DatabaseMetaData dbMetaData;\n  private final SQLExpressionGenerator sqlExprGen;\n\n  public static class SQLBuilderContext {\n    StringBuilder sb;\n  }\n\n  public SQLBuilder(DatabaseMetaData dbMetaData, SQLExpressionGenerator exprGen) {\n    this.dbMetaData = dbMetaData;\n    this.sqlExprGen = exprGen;\n  }\n\n  public String build(String tableName, Column [] targets, @Nullable EvalNode filter, @Nullable Long limit) {\n\n    StringBuilder selectClause = new StringBuilder(\"SELECT \");\n    if (targets.length > 0) {\n      selectClause.append(StringUtils.join(targets, \",\", new Function<Column, String>() {\n        @Override\n        public String apply(@Nullable Column input) {\n          return input.getSimpleName();\n        }\n      }));\n    } else {\n      selectClause.append(\"1\");\n    }\n    selectClause.append(\" \");\n\n    StringBuilder fromClause = new StringBuilder(\"FROM \");\n    fromClause.append(tableName).append(\" \");\n\n    StringBuilder whereClause = null;\n    if (filter != null) {\n      whereClause = new StringBuilder(\"WHERE \");\n      whereClause.append(sqlExprGen.generate(filter)).append(\" \");\n    }\n\n    StringBuilder limitClause = null;\n    if (limit != null) {\n      limitClause = new StringBuilder(\"LIMIT \");\n      limitClause.append(limit).append(\" \");\n    }\n\n    return generateSelectStmt(selectClause, fromClause, whereClause, limitClause);\n  }\n\n  public String generateSelectStmt(StringBuilder selectClause,\n                                   StringBuilder fromClause,\n                                   @Nullable StringBuilder whereClause,\n                                   @Nullable StringBuilder limitClause) {\n    return\n        selectClause.toString() +\n        fromClause.toString() +\n        (whereClause != null ? whereClause.toString() : \"\") +\n        (limitClause != null ? limitClause.toString() : \"\");\n  }\n\n  public String build(LogicalNode planPart) {\n    SQLBuilderContext context = new SQLBuilderContext();\n    visit(context, planPart, new Stack<LogicalNode>());\n    return context.sb.toString();\n  }\n\n<fim_suffix>  public void visit(SQLBuilderContext context, LogicalNode node, Stack<LogicalNode> stack) {\n    stack.push(node);\n\n    switch (node.getType()) {\n    case SCAN:\n      visitScan(context, (ScanNode) node, stack);\n      break;\n\n    case GROUP_BY:\n      visitGroupBy(context, (GroupbyNode) node, stack);\n      break;\n\n    case SELECTION:\n      visitFilter(context, (SelectionNode) node, stack);\n      break;\n\n    case PROJECTION:\n      visitProjection(context, (ProjectionNode) node, stack);\n      break;\n\n    case TABLE_SUBQUERY:\n      visitDerivedSubquery(context, (TableSubQueryNode) node, stack);\n      break;\n\n    default:\n      throw new TajoRuntimeException(new UnsupportedException(\"plan node '\" + node.getType().name() + \"'\"));\n    }\n\n    stack.pop();\n  }\n\n  public void visitDerivedSubquery(SQLBuilderContext ctx, TableSubQueryNode derivedSubquery, Stack<LogicalNode> stack) {\n    ctx.sb.append(\" (\");\n    visit(ctx, derivedSubquery.getSubQuery(), stack);\n    ctx.sb.append(\" ) \").append(derivedSubquery.getTableName());\n  }\n\n  public void visitProjection(SQLBuilderContext ctx, ProjectionNode projection, Stack<LogicalNode> stack) {\n\n    visit(ctx, projection.getChild(), stack);\n  }\n\n  public void visitGroupBy(SQLBuilderContext ctx, GroupbyNode groupby, Stack<LogicalNode> stack) {\n    visit(ctx, groupby.getChild(), stack);\n    ctx.sb.append(\"GROUP BY \").append(StringUtils.join(groupby.getGroupingColumns(), \",\", 0)).append(\" \");\n  }\n\n  public void visitFilter(SQLBuilderContext ctx, SelectionNode filter, Stack<LogicalNode> stack) {\n    visit(ctx, filter.getChild(), stack);\n    ctx.sb.append(\"WHERE \" + sqlExprGen.generate(filter.getQual()));\n  }\n\n  public void visitScan(SQLBuilderContext ctx, ScanNode scan, Stack<LogicalNode> stack) {\n\n    StringBuilder selectClause = new StringBuilder(\"SELECT \");\n    if (scan.getTargets().size() > 0) {\n      selectClause.append(generateTargetList(scan.getTargets()));\n    } else {\n      selectClause.append(\"1\");\n    }\n\n    selectClause.append(\" \");\n\n    ctx.sb.append(\"FROM \").append(scan.getTableName()).append(\" \");\n\n    if (scan.hasAlias()) {\n      ctx.sb.append(\"AS \").append(scan.getAlias()).append(\" \");\n    }\n\n    if (scan.hasQual()) {\n      ctx.sb.append(\"WHERE \" + sqlExprGen.generate(scan.getQual()));\n    }\n  }\n\n  public String generateTargetList(List<Target> targets) {\n    return StringUtils.join(targets, \",\", new Function<Target, String>() {\n      @Override\n      public String apply(@Nullable Target t) {\n        StringBuilder sb = new StringBuilder(sqlExprGen.generate(t.getEvalTree()));\n        if (t.hasAlias()) {\n          sb.append(\" AS \").append(t.getAlias());\n        }\n        return sb.toString();\n      }\n    });\n  }\n}<fim_middle>// function below has no smell\n"}