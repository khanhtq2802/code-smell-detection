{"text": "<fim_prefix>                case \"psignrank\":\n                    return StatsFunctionsNodes.Function2_2Node.create(new PSignrank());\n                case \"dnt\":\n                    return StatsFunctionsNodes.Function3_1Node.create(new Dnt());\n                case \"pnt\":\n                    return StatsFunctionsNodes.Function3_2Node.create(new Pnt());\n                case \"qnt\":\n                    return StatsFunctionsNodes.Function3_2Node.create(new Qnt());\n                case \"qsignrank\":\n                    return StatsFunctionsNodes.Function2_2Node.create(new QSignrank());\n                case \"qtukey\":\n                    return StatsFunctionsNodes.Function4_2Node.create(new QTukey());\n                case \"ptukey\":\n                    return StatsFunctionsNodes.Function4_2Node.create(new PTukey());\n                case \"rmultinom\":\n                    return RMultinomNode.create();\n                case \"Approx\":\n                    return Approx.create();\n                case \"ApproxTest\":\n                    return ApproxTest.create();\n                case \"Cdist\":\n                    return CdistNodeGen.create();\n                case \"DoubleCentre\":\n                    return DoubleCentreNodeGen.create();\n                case \"cutree\":\n                    return CutreeNodeGen.create();\n                case \"BinDist\":\n                    return BinDist.create();\n                case \"influence\":\n                    return Influence.create();\n                case \"mvfft\":\n                    // TODO: only transforms arguments and then calls already ported fft\n                    return new UnimplementedExternal(name);\n                case \"nextn\":\n                    // TODO: do not want to pull in fourier.c, should be simple to port\n                    return new UnimplementedExternal(name);\n                case \"r2dtable\":\n                    // TODO: do not want to pull in random.c + uses PutRNG(), we can pull in rcont.c\n                    // and then this\n                    // becomes simple wrapper around it.\n                    return new UnimplementedExternal(name);\n                case \"Fisher_sim\":\n                case \"chisq_sim\":\n                    // TODO: uses PutRNG(), with rcont.c may become moderately difficult to port\n                    return new UnimplementedExternal(name);\n                case \"Rsm\":\n                    return new UnimplementedExternal(name);\n                case \"optim\":\n                case \"optimhess\":\n                case \"dqagi\":\n                case \"dqags\":\n                case \"nlm\":\n                    // TODO: file optim.c uses Defn.h with non public RFFI API\n                    // It seems that Defn.h can be replaced with Rinternals.h\n                    // From GNUR R core it pulls few aux macros like F77_CALL, we can pull those\n                    // individually\n                    // Furthermore it requires to pull lbfgsb.c and linkpack (Appl/Linpack.h)\n                    // routines from core\n                    return new UnimplementedExternal(name);\n                case \"pp_sum\":\n                    return PPSumExternal.create();\n                case \"intgrt_vec\":\n                    return PPSum.IntgrtVecNode.create();\n                case \"updateform\":\n                    return getExternalModelBuiltinNode(\"updateform\");\n                case \"Cdqrls\":\n                    return new RInternalCodeBuiltinNode(\"stats\", RInternalCode.loadSourceRelativeTo(RandFunctionsNodes.class, \"lm.R\"), \"Cdqrls\");\n                case \"dnorm\":\n                    return StatsFunctionsNodes.Function3_1Node.create(new DNorm());\n                // tools\n                case \"doTabExpand\":\n                    return DoTabExpandNodeGen.create();\n                case \"codeFilesAppend\":\n                    return CodeFilesAppendNodeGen.create();\n                case \"Rmd5\":\n                    return Rmd5NodeGen.create();\n                case \"dirchmod\":\n                    return DirChmodNodeGen.create();\n                case \"delim_match\":\n                case \"C_getfmts\":\n                case \"check_nonASCII\":\n                case \"check_nonASCII2\":\n                case \"ps_kill\":\n                case \"ps_sigs\":\n                case \"ps_priority\":\n                case \"startHTTPD\":\n                case \"stopHTTPD\":\n                case \"C_deparseRd\":\n                    return new UnimplementedExternal(name);\n                // utils\n                case \"crc64\":\n                    return Crc64NodeGen.create();\n                case \"flushconsole\":\n                    return new Flushconsole();\n                case \"menu\":\n                    return MenuNodeGen.create();\n                case \"nsl\":\n                    return new UnimplementedExternal(name);\n                case \"objectSize\":\n                    return ObjectSizeNodeGen.create();\n                case \"octsize\":\n                    return OctSizeNode.create();\n                case \"processevents\":\n                case \"sockconnect\":\n                case \"sockread\":\n                case \"sockclose\":\n                case \"sockopen\":\n                case \"socklisten\":\n                case \"sockwrite\":\n                    return new UnimplementedExternal(name);\n                // parallel\n                case \"mc_is_child\":\n                    return MCIsChildNodeGen.create();\n                default:\n                    return null;\n            }\n            // Note: some externals that may be ported with reasonable effort\n            // tukeyline, rfilter, SWilk, acf, Burg, d2x2xk, pRho\n        }\n        /**\n         * {@code .NAME = NativeSymbolInfo} implemented as a builtin.\n         */\n        @SuppressWarnings(\"unused\")\n        @Specialization(limit = \"99\", guards = {\"cached == symbol\", \"builtin != null\"})\n        protected Object doExternal(VirtualFrame frame, RList symbol, RArgsValuesAndNames args, Object packageName,\n                        @Cached(\"symbol\") RList cached,\n                        @Cached(\"lookupBuiltin(symbol)\") RExternalBuiltinNode builtin) {\n            return builtin.call(frame, args);\n        }\n        /**\n         * {@code .NAME = NativeSymbolInfo} implementation remains in native code (e.g. non-builtin\n         * package)\n         */\n        @SuppressWarnings(\"unused\")\n        @Specialization(limit = \"getCacheSize(2)\", guards = {\"cached == symbol\", \"builtin == null\"})\n        protected Object callSymbolInfoFunction(VirtualFrame frame, RList symbol, RArgsValuesAndNames args, Object packageName,\n                        @Cached(\"symbol\") RList cached,\n                        @Cached(\"lookupBuiltin(symbol)\") RExternalBuiltinNode builtin,\n                        @Cached(\"new()\") ExtractNativeCallInfoNode extractSymbolInfo,\n                        @Cached(\"extractSymbolInfo.execute(symbol)\") NativeCallInfo nativeCallInfo,\n                        @Cached(\"createBinaryProfile()\") ConditionProfile registeredProfile) {\n            if (registeredProfile.profile(isRegisteredRFunction(nativeCallInfo))) {\n                return explicitCall(frame, nativeCallInfo, args);\n            } else {\n                return dispatch(nativeCallInfo, materializeArgs(args.getArguments()));\n            }\n        }\n        /**\n         * For some reason, the list instance may change, although it carries the same info. For\n         * such cases there is this generic version.\n         */\n        @Specialization(replaces = {\"callSymbolInfoFunction\", \"doExternal\"})\n        protected Object callSymbolInfoFunctionGeneric(VirtualFrame frame, RList symbol, RArgsValuesAndNames args, @SuppressWarnings(\"unused\") Object packageName,\n                        @Cached(\"new()\") ExtractNativeCallInfoNode extractSymbolInfo,\n                        @Cached(\"createBinaryProfile()\") ConditionProfile registeredProfile) {\n            RExternalBuiltinNode builtin = lookupBuiltin(symbol);\n            if (builtin != null) {\n                throw RInternalError.shouldNotReachHere(\"Cache for .Calls with FastR reimplementation (lookupBuiltin(...) != null) exceeded the limit\");\n            }\n            NativeCallInfo nativeCallInfo = extractSymbolInfo.execute(symbol);\n            if (registeredProfile.profile(isRegisteredRFunction(nativeCallInfo))) {\n                return explicitCall(frame, nativeCallInfo, args);\n            } else {\n                return dispatch(nativeCallInfo, materializeArgs(args.getArguments()));\n            }\n        }\n        /**\n         * {@code .NAME = string}, no package specified.\n         */\n<fim_suffix>        @Specialization\n        protected Object callNamedFunction(VirtualFrame frame, String symbol, RArgsValuesAndNames args, @SuppressWarnings(\"unused\") RMissing packageName,\n                        @Cached(\"createRegisteredNativeSymbol(CallNST)\") DLL.RegisteredNativeSymbol rns,\n                        @Cached(\"create()\") DLL.RFindSymbolNode findSymbolNode,\n                        @Cached(\"createBinaryProfile()\") ConditionProfile registeredProfile) {\n            return callNamedFunctionWithPackage(frame, symbol, args, null, rns, findSymbolNode, registeredProfile);\n        }<fim_middle>// function below has no smell\n"}