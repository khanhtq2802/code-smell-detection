{"text": "<fim_prefix>\n<fim_suffix>public class ReconcileQuery {\n    private static final Logger log = LoggerFactory.getLogger(ReconcileQuery.class);\n    /**\n     * The default limit for suggestions if not explicitly parsed\n     */\n    public static final Integer DEFAULT_LIMIT = 5;\n    /**\n     * The default entity type mode if not explicitly parsed by the query\n     */\n    public static final TYPE_STRICT DEFAULT_TYPE_STRICT = TYPE_STRICT.any;\n    private final String query;\n    private final Set<String> types;\n    private Integer limit;\n    private final Map<ReconcileProperty,Collection<ReconcileValue>> properties = new HashMap<ReconcileProperty,Collection<ReconcileValue>>();\n    private TYPE_STRICT typeStrict;\n    /**\n     * @return the limit\n     */\n    public final Integer getLimit() {\n        return limit;\n    }\n    /**\n     * @param limit the limit to set\n     */\n    public final void setLimit(Integer limit) {\n        this.limit = limit;\n    }\n    /**\n     * @return the typeStrict\n     */\n    public final TYPE_STRICT getTypeStrict() {\n        return typeStrict;\n    }\n    /**\n     * @param typeStrict the typeStrict to set\n     */\n    public final void setTypeStrict(TYPE_STRICT typeStrict) {\n        this.typeStrict = typeStrict;\n    }\n    /**\n     * @return the query\n     */\n    public final String getQuery() {\n        return query;\n    }\n    /**\n     * @return the types\n     */\n    public final Set<String> getTypes() {\n        return types;\n    }\n    public static enum TYPE_STRICT {any,all,should};\n    public ReconcileQuery(String query,Collection<String> types) {\n        if(query == null || query.isEmpty()){\n            throw new IllegalArgumentException(\"The parsed query string MUST NOT be NULL nor empty!\");\n        }\n        this.query = query;\n        if(types == null || types.isEmpty()){\n            this.types = Collections.emptySet();\n        } else {\n            Set<String> t = new HashSet<String>(types.size());\n            for(String type : types){\n                if(type != null && !type.isEmpty()){\n                    t.add(type);\n                }\n            }\n            this.types = Collections.unmodifiableSet(t);\n        }\n    }\n    public Collection<ReconcileValue> putProperty(String field, Collection<ReconcileValue> values, NamespacePrefixService nsPrefixService){\n        if(field == null || field.isEmpty()){\n            throw new IllegalArgumentException(\"The field for an property MUST NOT be NULL!\");\n        }\n        ReconcileProperty property = ReconcileProperty.parseProperty(field, nsPrefixService);\n        if(property != null){\n            if(values == null || values.isEmpty()){\n                return properties.remove(values);\n            } else {\n                return properties.put(property, values);\n            }\n        } else {\n            return null;\n        }\n    }\n    public Collection<ReconcileValue> removeProperty(String field){\n        return properties.remove(field);\n    }\n    public Collection<ReconcileValue> getProperty(String field){\n        return properties.get(field);\n    }\n    public Iterable<Entry<ReconcileProperty,Collection<ReconcileValue>>> getProperties(){\n        return properties.entrySet();\n    }\n    public static Map<String,ReconcileQuery> parseQueries(String queriesString,NamespacePrefixService nsPrefixService) throws WebApplicationException {\n        JSONObject jQueries;\n        try {\n            jQueries = new JSONObject(queriesString);\n        }catch (JSONException e) {\n            throw new WebApplicationException(\n                Response.status(Response.Status.BAD_REQUEST).entity(\n                    \"The parsed query is illegal formatted! \\n query: \\n\"+queriesString+\"\\n\").build());\n        }\n        @SuppressWarnings(\"unchecked\")\n        Iterator<String> keys = jQueries.keys();\n        Map<String,ReconcileQuery> queries = new HashMap<String,ReconcileQuery>();\n        while(keys.hasNext()){\n            String key = keys.next();\n            try {\n                ReconcileQuery query = parseQuery(jQueries.getJSONObject(key), nsPrefixService);\n                queries.put(key, query);\n            } catch (JSONException e) {\n                throw new WebApplicationException(\n                    Response.status(Response.Status.BAD_REQUEST).entity(\n                        \"The query of key '\"+key+\"is illegal formatted! \\n query: \\n\"\n                                + queriesString+\"\\n\").build());\n            }\n        }\n        return queries;\n    }\n    /**\n     * Parses a Google Refine Reconcile Query from the parsed String.\n     * @param queryString the string representation of the reconcile query\n     * @return the parsed {@link ReconcileQuery} object\n     * @throws WebApplicationException {@link Response.Status#BAD_REQUEST} in\n     * case of the parsed string is not a well formated query. Unsupported\n     * Properties are silently ignored (warnings are still logged).\n     */\n    public static ReconcileQuery parseQuery(String queryString, NamespacePrefixService nsPrefixService) throws WebApplicationException {\n        JSONObject jQuery;\n        try {\n            if(queryString.charAt(0) == '{') {\n                jQuery = new JSONObject(queryString);\n            } else {\n                jQuery = new JSONObject();\n                jQuery.put(\"query\", queryString);\n                //simple string query\n            }\n        }catch (JSONException e) {\n            throw new WebApplicationException(\n                Response.status(Response.Status.BAD_REQUEST).entity(\n                    \"The parsed query is illegal formatted! \\n query: \\n\"+queryString+\"\\n\").build());\n        }\n        return parseQuery(jQuery, nsPrefixService);\n    }\n    private static ReconcileQuery parseQuery(JSONObject jQuery, NamespacePrefixService nsPrefixService) throws WebApplicationException {\n        //query (string)\n        //limit (integer), optional\n        //type (string| [string]), optional\n        //type_strict (\"any\",\"all\",\"should\"), optional\n        //properties ([Property]), optional\n        //    Property:\n        //        p (string)  -> ignore\n        //        pid (string) -> uri\n        //        v (string/Value, [string/Value]), required\n        //    Value\n        //        id (uri)\n        String value = jQuery.optString(\"query\");\n        if(value == null || value.isEmpty()){\n            throw new WebApplicationException(\n                Response.status(Response.Status.BAD_REQUEST).entity(\n                    \"The parsed query is illegal formatted! \\n query: \\n\"+jQuery.toString()+\"\\n\").build());\n        }\n        JSONArray jTypes = null;\n        Collection<String> types;\n        if(!jQuery.has(\"type\")){\n            types = Collections.emptySet();\n        } else if((jTypes = jQuery.optJSONArray(\"type\")) != null){\n            types = new HashSet<String>(jTypes.length());\n            for(int i=0;i<jTypes.length();i++){\n                String type = nsPrefixService.getFullName(jTypes.optString(i));\n                if(type != null && !type.isEmpty()){\n                    types.add(type);\n                } else {\n                    log.warn(\"Unable to parse entity type from parsed type {}\",jTypes.optString(i));\n                }\n            }\n        } else {\n            String type = jQuery.optString(\"type\");\n            if(type != null && !type.isEmpty()){\n                types = Collections.singleton(type);\n            } else {\n                types = Collections.emptySet();\n            }\n        }\n        ReconcileQuery reconcileQuery = new ReconcileQuery(value,types);\n        //TYPE_STRICT typeStrict = null;\n        String jTypeStrict = jQuery.optString(\"type_strict\");\n        if(jTypeStrict != null){\n            try {\n                reconcileQuery.setTypeStrict(TYPE_STRICT.valueOf(jTypeStrict));\n            } catch (RuntimeException e) {\n                log.warn(\"Unknown \\\"type_strict\\\" value in Google Refine Reconcile\" +\n                        \" Request (use default '{}')\\n {}\",DEFAULT_TYPE_STRICT,jQuery.toString());\n                reconcileQuery.setTypeStrict(DEFAULT_TYPE_STRICT);\n            }\n        } else {\n            reconcileQuery.setTypeStrict(DEFAULT_TYPE_STRICT);\n        }\n        reconcileQuery.setLimit(jQuery.optInt(\"limit\", DEFAULT_LIMIT));\n        JSONArray jProperties = jQuery.optJSONArray(\"properties\");\n        if(jProperties != null){\n            for(int i=0;i<jProperties.length();i++){\n                parseProperty(reconcileQuery, jProperties.optJSONObject(i), nsPrefixService);\n            }\n        }\n        return reconcileQuery;\n    }\n    /**\n     * Internally used to parse a Property of a Google Refine Reconcile Query\n     * @param reconcileQuery the query to add the property\n     * @param jProperty the JSON formatted property\n     */\n    private static void parseProperty(ReconcileQuery reconcileQuery,JSONObject jProperty, NamespacePrefixService nsPrefixService) {\n        if(jProperty != null){\n            //parse property\n            String property = jProperty.optString(\"pid\");\n            if(property == null){\n                log.warn(\"Ignore Property because of missing 'pid'! \\n{}\",jProperty.toString());\n            } else {\n                //property keys may appear multiple times in queries\n                //so we need to initialise the property values with already\n                //existing values\n                Collection<ReconcileValue> values = reconcileQuery.getProperty(property);\n                if(values == null){ //if not create a new Set<fim_middle>// class below has no smell\n"}