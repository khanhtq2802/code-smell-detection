{"text": "<fim_prefix> * <em>only</em> serve RestLi resources.\n *\n * @author dellamag\n */\n<fim_suffix>public class StandaloneLauncher\n{\n  private final int _port;\n  private final String _contextPath;\n  private final int _threadPoolSize;\n  private final int _parseqThreadPoolSize;\n  private final String[] _packages;\n  private final HttpServer _server;\n  /**\n   * Construct a new standalone RestLi server that will listen on the given port and serve RestLi\n   * resources from the given packages.\n   *\n   * @param port the port to listen on\n   * @param packages package names to scan for RestLi resources\n   */\n  public StandaloneLauncher(final int port, final String... packages)\n  {\n    this(port,\n         HttpServerFactory.DEFAULT_CONTEXT_PATH,\n         HttpServerFactory.DEFAULT_THREAD_POOL_SIZE,\n         getDefaultParseqThreadPoolSize(),\n         HttpServerFactory.DEFAULT_SERVLET_TYPE,\n         HttpServerFactory.DEFAULT_ASYNC_TIMEOUT,\n         packages);\n  }\n  /**\n   * Construct a new standalone RestLi server that will listen on the given port and serve RestLi\n   * resources from the given packages.\n   *\n   * @param port the port to listen on\n   * @param threadPoolSize number of threads to keep in the server's netty request pool\n   * @param parseqThreadPoolSize number of threads to keep in the pool for outbound, parseq requests\n   * @param packages package names to scan for RestLi resources\n   */\n  public StandaloneLauncher(final int port,\n                            String contextPath,\n                            int threadPoolSize,\n                            int parseqThreadPoolSize,\n                            final String... packages)\n  {\n    this(port,\n          contextPath,\n          threadPoolSize,\n          parseqThreadPoolSize,\n          HttpServerFactory.DEFAULT_SERVLET_TYPE,\n          HttpServerFactory.DEFAULT_ASYNC_TIMEOUT);\n  }\n  public StandaloneLauncher(final int port,\n                            String contextPath,\n                            int threadPoolSize,\n                            int parseqThreadPoolSize,\n                            HttpJettyServer.ServletType servletType,\n                            int asyncTimeout,\n                            final String... packages)\n  {\n    _port = port;\n    _contextPath = contextPath;\n    _threadPoolSize = threadPoolSize;\n    _parseqThreadPoolSize = parseqThreadPoolSize;\n    _packages = packages;\n    final RestLiConfig config = new RestLiConfig();\n    config.setDocumentationRequestHandler(new DefaultDocumentationRequestHandler());\n    config.setServerNodeUri(URI.create(\"/\"));\n    config.addResourcePackageNames(_packages);\n    System.err.println(\"Jetty parseqThreadPoolSize: \" + parseqThreadPoolSize);\n    final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(_parseqThreadPoolSize);\n    final Engine engine = new EngineBuilder()\n        .setTaskExecutor(scheduler)\n        .setTimerScheduler(scheduler)\n        .build();\n    final RestLiServer restServer = new RestLiServer(config, new PrototypeResourceFactory(), engine);\n    final TransportDispatcher dispatcher = new DelegatingTransportDispatcher(restServer, restServer);\n    System.err.println(\"Jetty threadPoolSize: \" + threadPoolSize);\n    _server =\n        new HttpServerFactory(FilterChains.empty()).createServer(_port,\n                                                                 _contextPath,\n                                                                 _threadPoolSize,\n                                                                 dispatcher,\n                                                                 servletType,\n                                                                 asyncTimeout);\n  }\n  /**\n   * @return the port that this server is listening on\n   */\n  public int getPort()\n  {\n    return _port;\n  }\n  public String getContextPath()\n  {\n    return _contextPath;\n  }\n  public int getThreadPoolSize()\n  {\n    return _threadPoolSize;\n  }\n  public int getParseqThreadPoolSize()\n  {\n    return _parseqThreadPoolSize;\n  }\n  /**\n   * @return the packages that this server scanned for RestLi resources\n   */\n  public String[] getPackages()\n  {\n    return _packages;\n  }\n  /**\n   * Start the server\n   *\n   * @throws IOException server startup fails\n   */\n  public void start() throws IOException\n  {\n    _server.start();\n  }\n  /**\n   * Stop the server\n   *\n   * @throws IOException server shutdown fails\n   */\n  public void stop() throws IOException\n  {\n    _server.stop();\n  }\n  /**\n   * Start a standalone launcher using configuration specified in args. The port defaults to 1338\n   * and is optional, but the packages are required.\n   *\n   * @param args <code>[-port port] [-packages package1,package2,...]</code>\n   * @throws IOException startup/shutdown fails\n   */\n  public static void main(final String[] args) throws IOException\n  {\n    final StandaloneLauncher launcher = configureLauncher(args);\n    launcher.start();\n    System.out.printf(\"HttpServer running on port %d. Press any key to stop server\",\n                      launcher.getPort());\n    System.in.read();\n    launcher.stop();\n  }\n  private static int getDefaultParseqThreadPoolSize()\n  {\n    int numCores = Runtime.getRuntime().availableProcessors();\n    return numCores + 1;\n  }\n  /**\n   * Parse command line arguments\n   */\n  private static StandaloneLauncher configureLauncher(final String... args)\n  {\n    if (args.length < 2)\n    {\n      help();\n    }\n    int port = 1338;\n    String[] packages = null;\n    String contextPath = HttpServerFactory.DEFAULT_CONTEXT_PATH;\n    int threadPoolSize = HttpServerFactory.DEFAULT_THREAD_POOL_SIZE;\n    int parseqThreadPoolSize = getDefaultParseqThreadPoolSize();\n    HttpJettyServer.ServletType servletType = HttpServerFactory.DEFAULT_SERVLET_TYPE;\n    int asyncTimeout = HttpServerFactory.DEFAULT_ASYNC_TIMEOUT;\n    for (int i = 0; i < args.length; i++)\n    {\n      final boolean hasValueArg = i + 1 < args.length;\n      if (args[i].equals(\"-port\"))\n      {\n        if (hasValueArg)\n        {\n          try\n          {\n            port = Integer.parseInt(args[i + 1]);\n          }\n          catch (final NumberFormatException e)\n          {\n            System.out.println(\"Invalid port number: \" + args[i + 1]);\n            help();\n          }\n        }\n        else\n        {\n          System.out.println(\"Missing port number\");\n          help();\n        }\n      }\n      else if (args[i].equals(\"-contextpath\"))\n      {\n        if (hasValueArg)\n        {\n          contextPath = args[i + 1];\n        }\n        else\n        {\n          System.out.println(\"Missing context path\");\n          help();\n        }\n      }\n      else if (args[i].equals(\"-threads\"))\n      {\n        if (hasValueArg)\n        {\n          try\n          {\n            threadPoolSize = Integer.parseInt(args[i + 1]);\n          }\n          catch (final NumberFormatException e)\n          {\n            System.out.println(\"Invalid threads: \" + args[i + 1]);\n            help();\n          }\n        }\n        else\n        {\n          System.out.println(\"Missing thread count\");\n          help();\n        }\n      }\n      else if (args[i].equals(\"-parseqthreads\"))\n      {\n        if (hasValueArg)\n        {\n          try\n          {\n            parseqThreadPoolSize = Integer.parseInt(args[i + 1]);\n          }\n          catch (final NumberFormatException e)\n          {\n            System.out.println(\"Invalid parseqthreads: \" + args[i + 1]);\n            help();\n          }\n        }\n        else\n        {\n          System.out.println(\"Missing parseqthreads count\");\n          help();\n        }\n      }\n      else if (args[i].equals(\"-packages\"))\n      {\n        if (hasValueArg)\n        {\n          packages = args[i + 1].split(\",\");\n        }\n        else\n        {\n          System.out.println(\"Missing packages\");\n        }\n      }\n      else if (args[i].equals(\"-useAsync\"))\n      {\n        if (hasValueArg)\n        {\n          servletType = Boolean.parseBoolean(args[i + 1]) ? HttpJettyServer.ServletType.ASYNC_EVENT\n              : HttpServerFactory.DEFAULT_SERVLET_TYPE;\n        }\n        else\n        {\n          servletType = HttpJettyServer.ServletType.ASYNC_EVENT;\n        }\n      }\n      else if (args[i].equals(\"-asyncTimeout\"))\n      {\n        if (hasValueArg)\n        {\n          try\n          {\n            asyncTimeout = Integer.parseInt(args[i + 1]);\n          }\n          catch (final NumberFormatException e)\n          {\n            System.out.println(\"Invalid asyncTimeout: \" + args[i + 1]);\n            help();\n          }\n        }\n        else\n        {\n          System.out.println(\"Missing asyncTimeout value\");\n          help();\n        }\n      }\n    }\n    if (packages == null)\n    {\n      help();\n    }\n    return new StandaloneLauncher(port,\n                                  contextPath,\n                                  threadPoolSize,\n                                  parseqThreadPoolSize,\n                                  servletType,\n                                  asyncTimeout,\n                                  packages);\n  }\n  /**\n   * Print a usage message and quit\n   */\n  private static void help()\n  {\n    System.out.println(\"Usage: launcher [-port port] [-contextpath context_path] [-threads threadPoolSize] [-parseqthreads parseqThreadPoolSize] [-useAsync [true]] [-asyncTimeout timeoutInMilliseconds] [-packages package1,package2,...]\");\n    System.exit(0);\n  }\n}<fim_middle>// class below has no smell\n"}