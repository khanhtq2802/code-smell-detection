{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache license, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the license for the specific language governing permissions and\n * limitations under the license.\n */\npackage org.apache.logging.log4j.jdbc.appender;\nimport java.io.Serializable;\nimport java.io.StringReader;\nimport java.sql.Clob;\nimport java.sql.Connection;\nimport java.sql.DatabaseMetaData;\nimport java.sql.NClob;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSetMetaData;\nimport java.sql.SQLException;\nimport java.sql.Timestamp;\nimport java.sql.Types;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.concurrent.CountDownLatch;\nimport org.apache.logging.log4j.core.Layout;\nimport org.apache.logging.log4j.core.LogEvent;\nimport org.apache.logging.log4j.core.StringLayout;\nimport org.apache.logging.log4j.core.appender.AppenderLoggingException;\nimport org.apache.logging.log4j.core.appender.ManagerFactory;\nimport org.apache.logging.log4j.core.appender.db.AbstractDatabaseManager;\nimport org.apache.logging.log4j.core.appender.db.ColumnMapping;\nimport org.apache.logging.log4j.core.appender.db.DbAppenderLoggingException;\nimport org.apache.logging.log4j.core.config.plugins.convert.TypeConverters;\nimport org.apache.logging.log4j.core.util.Closer;\nimport org.apache.logging.log4j.core.util.Log4jThread;\nimport org.apache.logging.log4j.jdbc.convert.DateTypeConverter;\nimport org.apache.logging.log4j.message.MapMessage;\nimport org.apache.logging.log4j.spi.ThreadContextMap;\nimport org.apache.logging.log4j.spi.ThreadContextStack;\nimport org.apache.logging.log4j.util.IndexedReadOnlyStringMap;\nimport org.apache.logging.log4j.util.ReadOnlyStringMap;\nimport org.apache.logging.log4j.util.Strings;\n/**\n * An {@link AbstractDatabaseManager} implementation for relational databases accessed via JDBC.\n */\npublic final class JdbcDatabaseManager extends AbstractDatabaseManager {\n    /**\n     * Encapsulates data that {@link JdbcDatabaseManagerFactory} uses to create managers.\n     */\n    private static final class FactoryData extends AbstractDatabaseManager.AbstractFactoryData {\n        private final ConnectionSource connectionSource;\n        private final String tableName;\n        private final ColumnConfig[] columnConfigs;\n        private final ColumnMapping[] columnMappings;\n        private final boolean immediateFail;\n        private final boolean retry;\n        private final long reconnectIntervalMillis;\n        private final boolean truncateStrings;\n        protected FactoryData(final int bufferSize, final Layout<? extends Serializable> layout,\n                final ConnectionSource connectionSource, final String tableName, final ColumnConfig[] columnConfigs,\n                final ColumnMapping[] columnMappings, final boolean immediateFail, final long reconnectIntervalMillis,\n                final boolean truncateStrings) {\n            super(bufferSize, layout);\n            this.connectionSource = connectionSource;\n            this.tableName = tableName;\n            this.columnConfigs = columnConfigs;\n            this.columnMappings = columnMappings;\n            this.immediateFail = immediateFail;\n            this.retry = reconnectIntervalMillis > 0;\n            this.reconnectIntervalMillis = reconnectIntervalMillis;\n            this.truncateStrings = truncateStrings;\n        }\n        @Override\n        public String toString() {\n            return String.format(\n                    \"FactoryData [connectionSource=%s, tableName=%s, columnConfigs=%s, columnMappings=%s, immediateFail=%s, retry=%s, reconnectIntervalMillis=%s, truncateStrings=%s]\",\n                    connectionSource, tableName, Arrays.toString(columnConfigs), Arrays.toString(columnMappings),\n                    immediateFail, retry, reconnectIntervalMillis, truncateStrings);\n        }\n    }\n    /**\n     * Creates managers.\n     */\n    private static final class JdbcDatabaseManagerFactory implements ManagerFactory<JdbcDatabaseManager, FactoryData> {\n        private static final char PARAMETER_MARKER = '?';\n        @Override\n        public JdbcDatabaseManager createManager(final String name, final FactoryData data) {\n            final StringBuilder sb = new StringBuilder(\"insert into \").append(data.tableName).append(\" (\");\n            // so this gets a little more complicated now that there are two ways to configure column mappings, but\n            // both mappings follow the same exact pattern for the prepared statement\n            appendColumnNames(\"INSERT\", data, sb);\n            sb.append(\") values (\");\n            int i = 1;\n            if (data.columnMappings != null) {\n                for (final ColumnMapping mapping : data.columnMappings) {\n                    final String mappingName = mapping.getName();\n                    if (Strings.isNotEmpty(mapping.getLiteralValue())) {\n                        logger().trace(\"Adding INSERT VALUES literal for ColumnMapping[{}]: {}={} \", i, mappingName,\n                                mapping.getLiteralValue());\n                        sb.append(mapping.getLiteralValue());\n                    } else if (Strings.isNotEmpty(mapping.getParameter())) {\n                        logger().trace(\"Adding INSERT VALUES parameter for ColumnMapping[{}]: {}={} \", i, mappingName,\n                                mapping.getParameter());\n                        sb.append(mapping.getParameter());\n                    } else {\n                        logger().trace(\"Adding INSERT VALUES parameter marker for ColumnMapping[{}]: {}={} \", i,\n                                mappingName, PARAMETER_MARKER);\n                        sb.append(PARAMETER_MARKER);\n                    }\n                    sb.append(',');\n                    i++;\n                }\n            }\n            final int columnConfigsLen = data.columnConfigs == null ? 0 : data.columnConfigs.length;\n            final List<ColumnConfig> columnConfigs = new ArrayList<>(columnConfigsLen);\n            if (data.columnConfigs != null) {\n                for (final ColumnConfig config : data.columnConfigs) {\n                    if (Strings.isNotEmpty(config.getLiteralValue())) {\n                        sb.append(config.getLiteralValue());\n                    } else {\n                        sb.append(PARAMETER_MARKER);\n                        columnConfigs.add(config);\n                    }\n                    sb.append(',');\n                }\n            }\n            // at least one of those arrays is guaranteed to be non-empty\n            sb.setCharAt(sb.length() - 1, ')');\n            final String sqlStatement = sb.toString();\n            return new JdbcDatabaseManager(name, sqlStatement, columnConfigs, data);\n        }\n    }\n    /**\n     * Handles reconnecting to JDBC once on a Thread.\n     */\n    private final class Reconnector extends Log4jThread {\n        private final CountDownLatch latch = new CountDownLatch(1);\n        private volatile boolean shutdown = false;\n        private Reconnector() {\n            super(\"JdbcDatabaseManager-Reconnector\");\n        }\n        public void latch() {\n            try {\n                latch.await();\n            } catch (final InterruptedException ex) {\n                // Ignore the exception.\n            }\n        }\n        void reconnect() throws SQLException {\n            closeResources(false);\n            connectAndPrepare();\n            reconnector = null;\n            shutdown = true;\n            logger().debug(\"Connection reestablished to {}\", factoryData);\n        }\n<fim_suffix>        @Override\n        public void run() {\n            while (!shutdown) {\n                try {\n                    sleep(factoryData.reconnectIntervalMillis);\n                    reconnect();\n                } catch (final InterruptedException | SQLException e) {\n                    logger().debug(\"Cannot reestablish JDBC connection to {}: {}\", factoryData, e.getLocalizedMessage(),\n                            e);\n                } finally {\n                    latch.countDown();\n                }\n            }\n        }\n        public void shutdown() {\n            shutdown = true;\n        }\n    }\n    private static final class ResultSetColumnMetaData {\n        private final String schemaName;\n        private final String catalogName;\n        private final String tableName;\n        private final String name;\n        private final String nameKey;\n        private final String label;\n        private final int displaySize;\n        private final int type;\n        private final String typeName;\n        private final String className;\n        private final int precision;\n        private final int scale;\n        private final boolean isStringType;\n        public ResultSetColumnMetaData(final ResultSetMetaData rsMetaData, final int j) throws SQLException {\n            // @formatter:off\n            this(rsMetaData.getSchemaName(j),\n                 rsMetaData.getCatalogName(j),\n                 rsMetaData.getTableName(j),\n                 rsMetaData.getColumnName(j),\n                 rsMetaData.getColumnLabel(j),\n                 rsMetaData.getColumnDisplaySize(j),\n                 rsMetaData.getColumnType(j),<fim_middle>// function below has no smell\n"}