{"text": "<fim_prefix>\n<fim_suffix>public class UnorderedPartitionedKVWriter extends BaseUnorderedPartitionedKVWriter {\n  private static final Logger LOG = LoggerFactory.getLogger(UnorderedPartitionedKVWriter.class);\n  private static final int INT_SIZE = 4;\n  private static final int NUM_META = 3; // Number of meta fields.\n  private static final int INDEX_KEYLEN = 0; // KeyLength index\n  private static final int INDEX_VALLEN = 1; // ValLength index\n  private static final int INDEX_NEXT = 2; // Next Record Index.\n  private static final int META_SIZE = NUM_META * INT_SIZE; // Size of total meta-data\n  private final static int APPROX_HEADER_LENGTH = 150;\n  // Maybe setup a separate statistics class which can be shared between the\n  // buffer and the main path instead of having multiple arrays.\n  private final String destNameTrimmed;\n  private final long availableMemory;\n  @VisibleForTesting\n  final WrappedBuffer[] buffers;\n  @VisibleForTesting\n  final BlockingQueue<WrappedBuffer> availableBuffers;\n  private final ByteArrayOutputStream baos;\n  private final NonSyncDataOutputStream dos;\n  @VisibleForTesting\n  WrappedBuffer currentBuffer;\n  private final FileSystem rfs;\n  @VisibleForTesting\n  final List<SpillInfo> spillInfoList = Collections.synchronizedList(new ArrayList<SpillInfo>());\n  private final ListeningExecutorService spillExecutor;\n  private final int[] numRecordsPerPartition;\n  private long localOutputRecordBytesCounter;\n  private long localOutputBytesWithOverheadCounter;\n  private long localOutputRecordsCounter;\n  // notify after x records\n  private static final int NOTIFY_THRESHOLD = 1000;\n  // uncompressed size for each partition\n  private final long[] sizePerPartition;\n  private volatile long spilledSize = 0;\n  static final ThreadLocal<Deflater> deflater = new ThreadLocal<Deflater>() {\n    @Override\n    public Deflater initialValue() {\n      return TezCommonUtils.newBestCompressionDeflater();\n    }\n    @Override\n    public Deflater get() {\n      Deflater deflater = super.get();\n      deflater.reset();\n      return deflater;\n    }\n  };\n  private final Semaphore availableSlots;\n  /**\n   * Represents final number of records written (spills are not counted)\n   */\n  protected final TezCounter outputLargeRecordsCounter;\n  @VisibleForTesting\n  int numBuffers;\n  @VisibleForTesting\n  int sizePerBuffer;\n  @VisibleForTesting\n  int lastBufferSize;\n  @VisibleForTesting\n  int numInitializedBuffers;\n  @VisibleForTesting\n  int spillLimit;\n  private Throwable spillException;\n  private AtomicBoolean isShutdown = new AtomicBoolean(false);\n  @VisibleForTesting\n  final AtomicInteger numSpills = new AtomicInteger(0);\n  private final AtomicInteger pendingSpillCount = new AtomicInteger(0);\n  @VisibleForTesting\n  Path finalIndexPath;\n  @VisibleForTesting\n  Path finalOutPath;\n  //for single partition cases (e.g UnorderedKVOutput)\n  private final IFile.Writer writer;\n  @VisibleForTesting\n  final boolean skipBuffers;\n  private final ReentrantLock spillLock = new ReentrantLock();\n  private final Condition spillInProgress = spillLock.newCondition();\n  private final boolean pipelinedShuffle;\n  private final boolean isFinalMergeEnabled;\n  // To store events when final merge is disabled\n  private final List<Event> finalEvents;\n  // How partition stats should be reported.\n  final ReportPartitionStats reportPartitionStats;\n  private final long indexFileSizeEstimate;\n  private List<WrappedBuffer> filledBuffers = new ArrayList<>();\n  public UnorderedPartitionedKVWriter(OutputContext outputContext, Configuration conf,\n      int numOutputs, long availableMemoryBytes) throws IOException {\n    super(outputContext, conf, numOutputs);\n    Preconditions.checkArgument(availableMemoryBytes >= 0, \"availableMemory should be >= 0 bytes\");\n    this.destNameTrimmed = TezUtilsInternal.cleanVertexName(outputContext.getDestinationVertexName());\n    //Not checking for TEZ_RUNTIME_ENABLE_FINAL_MERGE_IN_OUTPUT as it might not add much value in\n    // this case.  Add it later if needed.\n    boolean pipelinedShuffleConf = this.conf.getBoolean(TezRuntimeConfiguration\n        .TEZ_RUNTIME_PIPELINED_SHUFFLE_ENABLED, TezRuntimeConfiguration\n        .TEZ_RUNTIME_PIPELINED_SHUFFLE_ENABLED_DEFAULT);\n    this.isFinalMergeEnabled = conf.getBoolean(\n        TezRuntimeConfiguration.TEZ_RUNTIME_ENABLE_FINAL_MERGE_IN_OUTPUT,\n        TezRuntimeConfiguration.TEZ_RUNTIME_ENABLE_FINAL_MERGE_IN_OUTPUT_DEFAULT);\n    this.pipelinedShuffle = pipelinedShuffleConf && !isFinalMergeEnabled;\n    this.finalEvents = Lists.newLinkedList();\n    if (availableMemoryBytes == 0) {\n      Preconditions.checkArgument(((numPartitions == 1) && !pipelinedShuffle), \"availableMemory \"\n          + \"can be set to 0 only when numPartitions=1 and \" + TezRuntimeConfiguration\n          .TEZ_RUNTIME_PIPELINED_SHUFFLE_ENABLED + \" is disabled. current numPartitions=\" +\n          numPartitions + \", \" + TezRuntimeConfiguration.TEZ_RUNTIME_PIPELINED_SHUFFLE_ENABLED + \"=\"\n          + pipelinedShuffle);\n    }\n    // Ideally, should be significantly larger.\n    availableMemory = availableMemoryBytes;\n    // Allow unit tests to control the buffer sizes.\n    int maxSingleBufferSizeBytes = conf.getInt(\n        TezRuntimeConfiguration.TEZ_RUNTIME_UNORDERED_OUTPUT_MAX_PER_BUFFER_SIZE_BYTES,\n        Integer.MAX_VALUE);\n    computeNumBuffersAndSize(maxSingleBufferSizeBytes);\n    availableBuffers = new LinkedBlockingQueue<WrappedBuffer>();\n    buffers = new WrappedBuffer[numBuffers];\n    // Set up only the first buffer to start with.\n    buffers[0] = new WrappedBuffer(numOutputs, sizePerBuffer);\n    numInitializedBuffers = 1;\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(destNameTrimmed + \": \" + \"Initializing Buffer #\" +\n          numInitializedBuffers + \" with size=\" + sizePerBuffer);\n    }\n    currentBuffer = buffers[0];\n    baos = new ByteArrayOutputStream();\n    dos = new NonSyncDataOutputStream(baos);\n    keySerializer.open(dos);\n    valSerializer.open(dos);\n    rfs = ((LocalFileSystem) FileSystem.getLocal(this.conf)).getRaw();\n    int maxThreads = Math.max(2, numBuffers/2);\n    //TODO: Make use of TezSharedExecutor later\n    ExecutorService executor = new ThreadPoolExecutor(1, maxThreads,\n        60L, TimeUnit.SECONDS,\n        new SynchronousQueue<Runnable>(),\n        new ThreadFactoryBuilder()\n            .setDaemon(true)\n            .setNameFormat(\n                \"UnorderedOutSpiller {\" + TezUtilsInternal.cleanVertexName(\n                    outputContext.getDestinationVertexName()) + \"} #%d\")\n            .build()\n    );\n    // to restrict submission of more tasks than threads (e.g numBuffers > numThreads)\n    // This is maxThreads - 1, to avoid race between callback thread releasing semaphore and the\n    // thread calling tryAcquire.\n    availableSlots = new Semaphore(maxThreads - 1, true);\n    spillExecutor = MoreExecutors.listeningDecorator(executor);\n    numRecordsPerPartition = new int[numPartitions];\n    reportPartitionStats = ReportPartitionStats.fromString(\n        conf.get(TezRuntimeConfiguration.TEZ_RUNTIME_REPORT_PARTITION_STATS,\n        TezRuntimeConfiguration.TEZ_RUNTIME_REPORT_PARTITION_STATS_DEFAULT));\n    sizePerPartition = (reportPartitionStats.isEnabled()) ?\n        new long[numPartitions] : null;\n    outputLargeRecordsCounter = outputContext.getCounters().findCounter(\n        TaskCounter.OUTPUT_LARGE_RECORDS);\n    indexFileSizeEstimate = numPartitions * Constants.MAP_OUTPUT_INDEX_RECORD_LENGTH;\n    if (numPartitions == 1 && !pipelinedShuffle) {\n      //special case, where in only one partition is available.\n      finalOutPath = outputFileHandler.getOutputFileForWrite();\n      finalIndexPath = outputFileHandler.getOutputIndexFileForWrite(indexFileSizeEstimate);\n      skipBuffers = true;\n      writer = new IFile.Writer(conf, rfs, finalOutPath, keyClass, valClass,\n          codec, outputRecordsCounter, outputRecordBytesCounter);\n    } else {\n      skipBuffers = false;\n      writer = null;\n    }\n    LOG.info(destNameTrimmed + \": \"\n        + \"numBuffers=\" + numBuffers\n        + \", sizePerBuffer=\" + sizePerBuffer\n        + \", skipBuffers=\" + skipBuffers\n        + \", numPartitions=\" + numPartitions\n        + \", availableMemory=\" + availableMemory\n        + \", maxSingleBufferSizeBytes=\" + maxSingleBufferSizeBytes\n        + \", pipelinedShuffle=\" + pipelinedShuffle<fim_middle>// class below is blob\n"}