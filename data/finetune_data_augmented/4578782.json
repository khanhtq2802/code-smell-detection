{"text": "<fim_prefix>                    return layer.makeReference();\n                }\n            }\n        }\n        if (navigators != null) {\n            for (PDFNavigator navigator : navigators) {\n                if (navigator.hasId(id)) {\n                    return navigator.makeReference();\n                }\n            }\n        }\n        if (navigatorActions != null) {\n            for (PDFNavigatorAction action : navigatorActions) {\n                if (action.hasId(id)) {\n                    return action.makeReference();\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * Writes out the entire document\n     *\n     * @param stream the OutputStream to output the document to\n     * @throws IOException if there is an exception writing to the output stream\n     */\n    public void output(OutputStream stream) throws IOException {\n        outputStarted = true;\n        //Write out objects until the list is empty. This approach (used with a\n        //LinkedList) allows for output() methods to create and register objects\n        //on the fly even during serialization.\n        while (this.objects.size() > 0) {\n            PDFObject object = this.objects.remove(0);\n            streamIndirectObject(object, stream);\n        }\n    }\n    protected void writeTrailer(OutputStream stream, int first, int last, int size, long mainOffset, long startxref)\n            throws IOException {\n        TrailerOutputHelper trailerOutputHelper = mayCompressStructureTreeElements()\n                ? new CompressedTrailerOutputHelper()\n                : new UncompressedTrailerOutputHelper();\n        if (structureTreeElements != null) {\n            trailerOutputHelper.outputStructureTreeElements(stream);\n        }\n        TrailerDictionary trailerDictionary = createTrailerDictionary(mainOffset != 0);\n        if (mainOffset != 0) {\n            trailerDictionary.getDictionary().put(\"Prev\", mainOffset);\n        }\n        trailerOutputHelper.outputCrossReferenceObject(stream, trailerDictionary, first, last, size);\n        String trailer = \"\\nstartxref\\n\" + startxref + \"\\n%%EOF\\n\";\n        stream.write(encode(trailer));\n    }\n    protected int streamIndirectObject(PDFObject o, OutputStream stream) throws IOException {\n        outputStarted = true;\n        recordObjectOffset(o);\n        int len = outputIndirectObject(o, stream);\n        this.position += len;\n        return len;\n    }\n    private void streamIndirectObjects(Collection<? extends PDFObject> objects, OutputStream stream)\n            throws IOException {\n        for (PDFObject o : objects) {\n            streamIndirectObject(o, stream);\n        }\n    }\n    private void recordObjectOffset(PDFObject object) {\n        int index = object.getObjectNumber().getNumber() - 1;\n        while (indirectObjectOffsets.size() <= index) {\n            indirectObjectOffsets.add(null);\n        }\n        indirectObjectOffsets.set(index, position);\n    }\n    /**\n     * Outputs the given object, wrapped by obj/endobj, to the given stream.\n     *\n     * @param object an indirect object, as described in Section 3.2.9 of the PDF 1.5\n     * Reference.\n     * @param stream the stream to which the object must be output\n     * @throws IllegalArgumentException if the object is not an indirect object\n     */\n    public static int outputIndirectObject(PDFObject object, OutputStream stream)\n            throws IOException {\n        if (!object.hasObjectNumber()) {\n            throw new IllegalArgumentException(\"Not an indirect object\");\n        }\n        byte[] obj = encode(object.getObjectID());\n        stream.write(obj);\n        int length = object.output(stream);\n        byte[] endobj = encode(\"\\nendobj\\n\");\n        stream.write(endobj);\n        return obj.length + length + endobj.length;\n    }\n    /**\n     * Write the PDF header.\n     *\n     * This method must be called prior to formatting\n     * and outputting AreaTrees.\n     *\n     * @param stream the OutputStream to write the header to\n     * @throws IOException if there is an exception writing to the output stream\n     */\n    public void outputHeader(OutputStream stream) throws IOException {\n        this.position = 0;\n        getProfile().verifyPDFVersion();\n        byte[] pdf = encode(\"%PDF-\" + getPDFVersionString() + \"\\n\");\n        stream.write(pdf);\n        this.position += pdf.length;\n        // output a binary comment as recommended by the PDF spec (3.4.1)\n        byte[] bin = {\n                (byte)'%',\n                (byte)0xAA,\n                (byte)0xAB,\n                (byte)0xAC,\n                (byte)0xAD,\n                (byte)'\\n' };\n        stream.write(bin);\n        this.position += bin.length;\n    }\n    /**\n     * Write the trailer\n     *\n     * @param stream the OutputStream to write the trailer to\n     * @throws IOException if there is an exception writing to the output stream\n     */\n    public void outputTrailer(OutputStream stream) throws IOException {\n        createDestinations();\n        output(stream);\n        outputTrailerObjectsAndXref(stream);\n    }\n    private void createDestinations() {\n        if (hasDestinations()) {\n            Collections.sort(this.destinations, new DestinationComparator());\n            PDFDests dests = getFactory().makeDests(this.destinations);\n            if (this.root.getNames() == null) {\n                this.root.setNames(getFactory().makeNames());\n            }\n            this.root.getNames().setDests(dests);\n        }\n    }\n    private void outputTrailerObjectsAndXref(OutputStream stream) throws IOException {\n        TrailerOutputHelper trailerOutputHelper = mayCompressStructureTreeElements()\n                ? new CompressedTrailerOutputHelper()\n                : new UncompressedTrailerOutputHelper();\n        if (structureTreeElements != null) {\n            trailerOutputHelper.outputStructureTreeElements(stream);\n        }\n        streamIndirectObjects(trailerObjects, stream);\n        TrailerDictionary trailerDictionary = createTrailerDictionary(true);\n        long startxref = trailerOutputHelper.outputCrossReferenceObject(stream, trailerDictionary, 0,\n                indirectObjectOffsets.size(), indirectObjectOffsets.size());\n        String trailer = \"\\nstartxref\\n\" + startxref + \"\\n%%EOF\\n\";\n        stream.write(encode(trailer));\n    }\n    private boolean mayCompressStructureTreeElements() {\n        return accessibilityEnabled\n                && versionController.getPDFVersion().compareTo(Version.V1_5) >= 0\n                && !isLinearizationEnabled();\n    }\n    private TrailerDictionary createTrailerDictionary(boolean addRoot) {\n        FileIDGenerator gen = getFileIDGenerator();\n        TrailerDictionary trailerDictionary = new TrailerDictionary(this);\n        if (addRoot) {\n            trailerDictionary.setRoot(root).setInfo(info);\n        }\n        trailerDictionary.setFileID(gen.getOriginalFileID(), gen.getUpdatedFileID());\n        if (isEncryptionActive()) {\n            trailerDictionary.setEncryption(encryption);\n        }\n        return trailerDictionary;\n    }\n    public boolean isMergeFontsEnabled() {\n        return mergeFontsEnabled;\n    }\n    public void setMergeFontsEnabled(boolean mergeFontsEnabled) {\n        this.mergeFontsEnabled = mergeFontsEnabled;\n        if (mergeFontsEnabled) {\n            getResources().createFontsAsObj();\n        }\n    }\n    private interface TrailerOutputHelper {\n        void outputStructureTreeElements(OutputStream stream) throws IOException;\n        /**\n         * @return the offset of the cross-reference object (the value of startxref)\n         */\n        long outputCrossReferenceObject(OutputStream stream, TrailerDictionary trailerDictionary,\n                                        int first, int last, int size)\n                throws IOException;\n    }\n    private class UncompressedTrailerOutputHelper implements TrailerOutputHelper {\n        public void outputStructureTreeElements(OutputStream stream)\n                throws IOException {\n            streamIndirectObjects(structureTreeElements, stream);\n        }\n        public long outputCrossReferenceObject(OutputStream stream,\n                TrailerDictionary trailerDictionary, int first, int last, int size) throws IOException {\n            new CrossReferenceTable(trailerDictionary, position,\n                    indirectObjectOffsets, first, last, size).output(stream);\n            return position;\n        }\n    }\n    private class CompressedTrailerOutputHelper implements TrailerOutputHelper {\n        private ObjectStreamManager structureTreeObjectStreams;\n        public void outputStructureTreeElements(OutputStream stream)\n                throws IOException {\n            assert structureTreeElements.size() > 0;\n            structureTreeObjectStreams = new ObjectStreamManager(PDFDocument.this);\n            for (PDFStructElem structElem : structureTreeElements) {\n                structureTreeObjectStreams.add(structElem);\n            }\n        }\n<fim_suffix>        public long outputCrossReferenceObject(OutputStream stream,\n                TrailerDictionary trailerDictionary, int first, int last, int size) throws IOException {\n            // Outputting the object streams should not have created new indirect objects\n            assert objects.isEmpty();\n            new CrossReferenceStream(PDFDocument.this, ++objectcount, trailerDictionary, position,\n                    indirectObjectOffsets,\n                    structureTreeObjectStreams.getCompressedObjectReferences())\n                    .output(stream);\n            return position;\n        }<fim_middle>// function below has no smell\n"}