{"text": "<fim_prefix>\n<fim_suffix>public class Plc4XEtherNetIpProtocol extends MessageToMessageCodec<EnipPacket, PlcRequestContainer<InternalPlcRequest, InternalPlcResponse>> {\n    private static final Logger LOGGER = LoggerFactory.getLogger(Plc4XEtherNetIpProtocol.class);\n    private static final int SERVICE_COMMUNICATIONS_TYPE_CODE = 0x0100;\n    private long sessionHandle = 0;\n    private static final AtomicLong messageId = new AtomicLong();\n    // General information about the remote communication endpoint.\n    private CipIdentityItem identityItem;\n    // Flag to signal, if the remote communication endpoint supports encapsulation of CIP data.\n    private boolean supportsCipEncapsulation = false;\n    // Flag to indicate, if implicit IO (subscription) is generally supported by the remote communication endpoint.\n    // This is handled via separate UDP socket, which would have to be established in parallel.\n    private boolean supportsClass0Or1UdpConnections = false;\n    // Map of non-cip interfaces, that might be used for specialized IO in future versions.\n    private Map<String, Integer> nonCipInterfaces = null;\n    // In CIP we are doing explicit connected messaging, this requires every used address to be registered at the\n    // remote server and to use that Addresses connectionId for accessing data. We are saving the references to\n    // these here.\n    // REMARK: Perhaps we should add a timeout to these so we unregister them after not being used\n    // for quire some time. Hereby freeing resources on both client and server.\n    private Map<PlcField, Long> fieldConnectionMap = new ConcurrentHashMap<>();\n    private final Map<Long, PlcRequestContainer<InternalPlcRequest, InternalPlcResponse>> requestsMap = new ConcurrentHashMap<>();\n    /**\n     * If the IsoTP protocol is used on top of the ISO on TCP protocol, then as soon as the pipeline receives the\n     * request to connect, an IsoTP connection request TPDU must be sent in order to initialize the connection.\n     *\n     * @param ctx the current protocol layers context\n     * @param evt the event\n     * @throws Exception throws an exception if something goes wrong internally\n     */\n    @Override\n    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n        // If the connection has just been established, start setting up the connection\n        // by sending a connection request to the plc.\n        if (evt instanceof ConnectEvent) {\n            LOGGER.debug(\"EtherNet/IP Protocol Sending Connection Request\");\n            EnipPacket packet = new EnipPacket(CommandCode.RegisterSession, 0, EnipStatus.EIP_SUCCESS,\n                messageId.getAndIncrement(), new RegisterSession());\n            ctx.channel().writeAndFlush(packet);\n        } else {\n            super.userEventTriggered(ctx, evt);\n        }\n    }\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n        LOGGER.trace(\"(-->ERR): {}\", ctx, cause);\n        super.exceptionCaught(ctx, cause);\n    }\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Encoding\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    @Override\n    protected void encode(ChannelHandlerContext ctx, PlcRequestContainer<InternalPlcRequest, InternalPlcResponse> msg, List<Object> out) {\n        LOGGER.trace(\"(<--OUT): {}, {}, {}\", ctx, msg, out);\n        // Reset transactionId on overflow\n        messageId.compareAndSet(Short.MAX_VALUE + 1L, 0);\n        PlcRequest request = msg.getRequest();\n        if (request instanceof PlcReadRequest) {\n            encodeReadRequest(msg, out);\n        } else if (request instanceof PlcWriteRequest) {\n            encodeWriteRequest(msg, out);\n        } /*else if(request instanceof PlcSubscriptionRequest) {\n            encodeSubscriptionRequest(msg, out);\n        } else if(request instanceof PlcUnsubscriptionRequest) {\n            TODO: Implement this and refactor PlcUnsubscriptionRequest first ...\n        }*/\n    }\n    private void encodeWriteRequest(PlcRequestContainer<InternalPlcRequest, InternalPlcResponse> msg, List<Object> out) {\n        if (!supportsCipEncapsulation) {\n            LOGGER.warn(\"CIP Encapsulation not supported by remote, payload encapsulation must be handled by target and originator\");\n        }\n        /*PlcWriteRequest request = (PlcWriteRequest) msg.getRequest();\n        // Create a ForwardOpen CIP request\n        // Create EIP UnconnectedDataItemRequest\n        UnconnectedDataItemRequest dataItem = new UnconnectedDataItemRequest(dataEncoder);\n        CpfPacket packet = new CpfPacket(new NullAddressItem(), dataItem);\n        // Send that via EIP SendRRData packet\n        CompletableFuture<T> future = new CompletableFuture<>();\n        sendRRData(new SendRRData(packet)).whenComplete((command, ex) -> {\n            if (command != null) {\n                CpfItem[] items = command.getPacket().getItems();\n                if (items.length == 2 &&\n                    items[0].getTypeId() == NullAddressItem.TYPE_ID &&\n                    items[1].getTypeId() == UnconnectedDataItemResponse.TYPE_ID) {\n                    ByteBuf data = ((UnconnectedDataItemResponse) items[1]).getData();\n                    future.complete(data);\n                } else {\n                    future.completeExceptionally(new Exception(\"received unexpected items\"));\n                }\n            } else {\n                future.completeExceptionally(ex);\n            }\n        });\n        channelManager.getChannel().whenComplete((ch, ex) -> {\n            if (ch != null) writeCommand(ch, command, future);\n            else future.completeExceptionally(ex);\n        });*/\n    }\n    private void encodeReadRequest(PlcRequestContainer<InternalPlcRequest, InternalPlcResponse> msg, List<Object> out) {\n        if (!supportsCipEncapsulation) {\n            LOGGER.warn(\"CIP Encapsulation not supported by remote, payload encapsulation must be handled by target and originator\");\n        }\n        InternalPlcReadRequest request = (InternalPlcReadRequest) msg.getRequest();\n        for (String fieldName : request.getFieldNames()) {\n            PlcField field = request.getField(fieldName);\n            // CIP Part\n            EtherNetIpField enipField = (EtherNetIpField) field;\n            EPath.PaddedEPath path = new EPath.PaddedEPath(new LogicalSegment.ClassId(enipField.getObjectNumber()),\n                new LogicalSegment.InstanceId(enipField.getInstanceNumber()),\n                new LogicalSegment.AttributeId(enipField.getAttributeNumber()));\n            GetAttributeSingleService service = new GetAttributeSingleService(path);\n            // ENIP Part\n            EnipPacket packet = new EnipPacket(CommandCode.SendRRData, sessionHandle, EnipStatus.EIP_SUCCESS,\n                messageId.getAndIncrement(), new SendRRData(new CpfPacket(\n                new NullAddressItem(),\n                new UnconnectedDataItemRequest(service::encodeRequest)\n            )));\n            requestsMap.put(packet.getSenderContext(), msg);\n            out.add(packet);\n        }\n    }\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    // Decoding\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    protected void decode(ChannelHandlerContext ctx, EnipPacket msg, List<Object> out) {\n        LOGGER.trace(\"(-->IN): {}, {}, {}\", ctx, msg, out);\n        LOGGER.debug(\"{}: session handle: {}, sender context: {}, EtherNetIPPacket:{}\", msg, msg.getSessionHandle(), msg.getSenderContext(), msg);\n        EnipPacket packet = null;\n        switch (msg.getCommandCode()) {\n            case RegisterSession:\n                handleRegisterSession(ctx, msg);\n                // Now try getting some detailed information about the remote.\n                packet = new EnipPacket(CommandCode.ListIdentity, sessionHandle, EnipStatus.EIP_SUCCESS,\n                    messageId.getAndIncrement(), new ListIdentity());\n                break;\n            case UnRegisterSession:\n                handleUnregisterSession(ctx, msg);\n                // Spec: The receiver shall initiate a close of the underlying\n                // TCP/IP connection when it receives this command.\n                ctx.channel().disconnect();\n                break;\n            case ListIdentity:\n                handleListIdentity(ctx, msg);\n                // Now try listing the services the remote has to offer.\n                packet = new EnipPacket(CommandCode.ListServices, sessionHandle, EnipStatus.EIP_SUCCESS,\n                    messageId.getAndIncrement(), new ListServices());\n                break;\n            case ListInterfaces:\n                handleListInterfaces(ctx, msg);\n                // Here we're done connecting.\n                ctx.channel().pipeline().fireUserEventTriggered(new ConnectedEvent());\n                break;\n            case ListServices:\n                handleListServices(ctx, msg);\n                // Now try listing the interfaces the remote has to offer.\n                packet = new EnipPacket(CommandCode.ListInterfaces, sessionHandle, EnipStatus.EIP_SUCCESS,\n                    messageId.getAndIncrement(), new ListInterfaces());\n                break;\n            case Nop:\n                handleNop(ctx, msg);\n                break;\n            case SendRRData:\n                handleSendRRDataResponse(ctx, msg);\n                break;\n            case SendUnitData:<fim_middle>// class below has no smell\n"}