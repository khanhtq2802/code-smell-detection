{"text": "<fim_prefix>/*\n * Copyright 2012-2019 the original author or authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *        https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.springframework.data.couchbase.repository.query;\n\nimport java.util.Iterator;\nimport java.util.Optional;\n\nimport org.springframework.data.couchbase.core.convert.CouchbaseConverter;\nimport org.springframework.data.domain.Pageable;\nimport org.springframework.data.domain.Sort;\nimport org.springframework.data.repository.query.ParameterAccessor;\nimport org.springframework.data.repository.query.parser.PartTree;\n\nimport com.couchbase.client.java.query.dsl.Expression;\nimport com.couchbase.client.java.query.dsl.path.LimitPath;\nimport com.couchbase.client.java.query.dsl.path.WherePath;\n\n/**\n *\n * @author Mark Ramach\n * @author Mark Paluch\n */\npublic class N1qlCountQueryCreator extends N1qlQueryCreator {\n\n\tpublic N1qlCountQueryCreator(PartTree tree, ParameterAccessor parameters, WherePath selectFrom,\n\t\t\tCouchbaseConverter converter, CouchbaseQueryMethod queryMethod) {\n\t\tsuper(tree, new CountParameterAccessor(parameters), selectFrom, converter, queryMethod);\n\t}\n\n\t@Override\n\tprotected LimitPath complete(Expression criteria, Sort sort) {\n\t\t// Sorting is not allowed on aggregate count queries.\n\t\treturn super.complete(criteria, Sort.unsorted());\n\t}\n\n\tprivate static class CountParameterAccessor implements ParameterAccessor {\n\n\t\tprivate ParameterAccessor delegate;\n\n\t\tpublic CountParameterAccessor(ParameterAccessor delegate) {\n\t\t\tthis.delegate = delegate;\n\t\t}\n\n\t\tpublic Pageable getPageable() {\n\t\t\treturn delegate.getPageable().isPaged() ? new CountPageable(delegate.getPageable()) : Pageable.unpaged();\n\t\t}\n\n\t\tpublic Sort getSort() {\n\t\t\treturn Sort.unsorted();\n\t\t}\n\n\t\tpublic Optional<Class<?>> getDynamicProjection() {\n\t\t\treturn delegate.getDynamicProjection();\n\t\t}\n\n\t\tpublic Object getBindableValue(int index) {\n\t\t\treturn delegate.getBindableValue(index);\n\t\t}\n\n\t\tpublic boolean hasBindableNullValue() {\n\t\t\treturn delegate.hasBindableNullValue();\n\t\t}\n\n\t\tpublic Iterator<Object> iterator() {\n\t\t\treturn delegate.iterator();\n\t\t}\n\n\t}\n\n<fim_suffix>\tprivate static class CountPageable implements Pageable {\n\n\t\tprivate Pageable delegate;\n\n\t\tpublic CountPageable(Pageable delegate) {\n\t\t\tthis.delegate = delegate;\n\t\t}\n\n\t\tpublic int getPageNumber() {\n\t\t\treturn delegate.getPageNumber();\n\t\t}\n\n\t\tpublic int getPageSize() {\n\t\t\treturn delegate.getPageSize();\n\t\t}\n\n\t\tpublic long getOffset() {\n\t\t\treturn delegate.getOffset();\n\t\t}\n\n\t\tpublic Sort getSort() {\n\t\t  // Sorting is not allowed on aggregate count queries.\n\t\t\treturn Sort.unsorted();\n\t\t}\n\n\t\tpublic Pageable next() {\n\t\t\treturn delegate.next();\n\t\t}\n\n\t\tpublic Pageable previousOrFirst() {\n\t\t\treturn delegate.previousOrFirst();\n\t\t}\n\n\t\tpublic Pageable first() {\n\t\t\treturn delegate.first();\n\t\t}\n\n\t\tpublic boolean hasPrevious() {\n\t\t\treturn delegate.hasPrevious();\n\t\t}\n\n\t}\n\n}<fim_middle>// class below has no smell\n"}