{"text": "<fim_prefix>import org.apache.pinot.common.utils.retry.RetryPolicy;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\npublic class HelixHelper {\n  public static final int MAX_PARTITION_COUNT_IN_UNCOMPRESSED_IDEAL_STATE = 1000;\n  private static final RetryPolicy DEFAULT_RETRY_POLICY = RetryPolicies.exponentialBackoffRetryPolicy(5, 1000L, 2.0f);\n  private static final Logger LOGGER = LoggerFactory.getLogger(HelixHelper.class);\n  private static final ZNRecordSerializer ZN_RECORD_SERIALIZER = new ZNRecordSerializer();\n  private static final String ONLINE = \"ONLINE\";\n  private static final String OFFLINE = \"OFFLINE\";\n  public static final String BROKER_RESOURCE = CommonConstants.Helix.BROKER_RESOURCE_INSTANCE;\n  public static IdealState cloneIdealState(IdealState idealState) {\n    return new IdealState(\n        (ZNRecord) ZN_RECORD_SERIALIZER.deserialize(ZN_RECORD_SERIALIZER.serialize(idealState.getRecord())));\n  }\n  /**\n   * Updates the ideal state, retrying if necessary in case of concurrent updates to the ideal state.\n   *\n   * @param helixManager The HelixManager used to interact with the Helix cluster\n   * @param resourceName The resource for which to update the ideal state\n   * @param updater A function that returns an updated ideal state given an input ideal state\n   */\n  // TODO: since updater always update ideal state in place, it should return boolean indicating whether the ideal state get changed.\n  public static void updateIdealState(final HelixManager helixManager, final String resourceName,\n      final Function<IdealState, IdealState> updater, RetryPolicy policy, final boolean noChangeOk) {\n    try {\n      policy.attempt(new Callable<Boolean>() {\n        @Override\n        public Boolean call() {\n          HelixDataAccessor dataAccessor = helixManager.getHelixDataAccessor();\n          PropertyKey idealStateKey = dataAccessor.keyBuilder().idealStates(resourceName);\n          IdealState idealState = dataAccessor.getProperty(idealStateKey);\n          // Make a copy of the the idealState above to pass it to the updater\n          // NOTE: new IdealState(idealState.getRecord()) does not work because it's shallow copy for map fields and\n          // list fields\n          IdealState idealStateCopy = cloneIdealState(idealState);\n          IdealState updatedIdealState;\n          try {\n            updatedIdealState = updater.apply(idealStateCopy);\n          } catch (PermanentUpdaterException e) {\n            LOGGER.error(\"Caught permanent exception while updating ideal state for resource: {}\", resourceName, e);\n            throw e;\n          } catch (Exception e) {\n            LOGGER.error(\"Caught exception while updating ideal state for resource: {}\", resourceName, e);\n            return false;\n          }\n          // If there are changes to apply, apply them\n          if (!EqualityUtils.isEqual(idealState, updatedIdealState) && updatedIdealState != null) {\n            // If the ideal state is large enough, enable compression\n            if (MAX_PARTITION_COUNT_IN_UNCOMPRESSED_IDEAL_STATE < updatedIdealState.getPartitionSet().size()) {\n              updatedIdealState.getRecord().setBooleanField(\"enableCompression\", true);\n            }\n            // Check version and set ideal state\n            try {\n              if (dataAccessor.getBaseDataAccessor()\n                  .set(idealStateKey.getPath(), updatedIdealState.getRecord(), idealState.getRecord().getVersion(),\n                      AccessOption.PERSISTENT)) {\n                return true;\n              } else {\n                LOGGER.warn(\"Failed to update ideal state for resource: {}\", resourceName);\n                return false;\n              }\n            } catch (ZkBadVersionException e) {\n              LOGGER.warn(\"Version changed while updating ideal state for resource: {}\", resourceName);\n              return false;\n            } catch (Exception e) {\n              boolean idealStateIsCompressed =\n                  updatedIdealState.getRecord().getBooleanField(\"enableCompression\", false);\n              LOGGER.warn(\"Caught exception while updating ideal state for resource: {} (compressed={})\", resourceName,\n                  idealStateIsCompressed, e);\n              return false;\n            }\n          } else {\n            if (noChangeOk) {\n              LOGGER.info(\"Idempotent or null ideal state update for resource {}, skipping update.\", resourceName);\n            } else {\n              LOGGER.warn(\"Idempotent or null ideal state update for resource {}, skipping update.\", resourceName);\n            }\n            return true;\n          }\n        }\n      });\n    } catch (Exception e) {\n      throw new RuntimeException(\"Caught exception while updating ideal state for resource: \" + resourceName, e);\n    }\n  }\n  /**\n   * Exception to be thrown by updater function to exit from retry in {@link HelixHelper::updatedIdealState}\n   */\n  public static class PermanentUpdaterException extends RuntimeException {\n    public PermanentUpdaterException(String message) {\n      super(message);\n    }\n    public PermanentUpdaterException(Throwable cause) {\n      super(cause);\n    }\n  }\n  public static void updateIdealState(final HelixManager helixManager, final String resourceName,\n      final Function<IdealState, IdealState> updater, RetryPolicy policy) {\n    updateIdealState(helixManager, resourceName, updater, policy, false);\n  }\n  /**\n   * Returns all instances for the given cluster.\n   *\n   * @param helixAdmin The HelixAdmin object used to interact with the Helix cluster\n   * @param clusterName Name of the cluster for which to get all the instances for.\n   * @return Returns a List of strings containing the instance names for the given cluster.\n   */\n  public static List<String> getAllInstances(HelixAdmin helixAdmin, String clusterName) {\n    return helixAdmin.getInstancesInCluster(clusterName);\n  }\n  /**\n   * Returns all instances for the given resource.\n   *\n   * @param idealState IdealState of the resource for which to return the instances of.\n   * @return Returns a Set of strings containing the instance names for the given cluster.\n   */\n  public static Set<String> getAllInstancesForResource(IdealState idealState) {\n    final Set<String> instances = new HashSet<String>();\n    for (final String partition : idealState.getPartitionSet()) {\n      for (final String instance : idealState.getInstanceSet(partition)) {\n        instances.add(instance);\n      }\n    }\n    return instances;\n  }\n  /**\n   * Toggle the state of the instance between OFFLINE and ONLINE.\n   *\n   * @param instanceName Name of the instance for which to toggle the state.\n   * @param clusterName Name of the cluster to which the instance belongs.\n   * @param admin HelixAdmin to access the cluster.\n   * @param enable Set enable to true for ONLINE and FALSE for OFFLINE.\n   */\n  public static void setInstanceState(String instanceName, String clusterName, HelixAdmin admin, boolean enable) {\n    admin.enableInstance(clusterName, instanceName, enable);\n  }\n  public static void setStateForInstanceList(List<String> instances, String clusterName, HelixAdmin admin,\n      boolean enable) {\n    for (final String instance : instances) {\n      setInstanceState(instance, clusterName, admin, enable);\n    }\n  }\n  public static void setStateForInstanceSet(Set<String> instances, String clusterName, HelixAdmin admin,\n      boolean enable) {\n    for (final String instanceName : instances) {\n      setInstanceState(instanceName, clusterName, admin, enable);\n    }\n  }\n  public static Map<String, String> getInstanceConfigsMapFor(String instanceName, String clusterName,\n      HelixAdmin admin) {\n    final HelixConfigScope scope = getInstanceScopefor(clusterName, instanceName);\n    final List<String> keys = admin.getConfigKeys(scope);\n    return admin.getConfig(scope, keys);\n  }\n  public static HelixConfigScope getInstanceScopefor(String clusterName, String instanceName) {\n    return new HelixConfigScopeBuilder(ConfigScopeProperty.PARTICIPANT, clusterName).forParticipant(instanceName)\n        .build();\n  }\n  public static HelixConfigScope getResourceScopeFor(String clusterName, String resourceName) {\n    return new HelixConfigScopeBuilder(ConfigScopeProperty.RESOURCE, clusterName).forResource(resourceName).build();\n  }\n  public static Map<String, String> getResourceConfigsFor(String clusterName, String resourceName, HelixAdmin admin) {\n    final HelixConfigScope scope = getResourceScopeFor(clusterName, resourceName);\n    final List<String> keys = admin.getConfigKeys(scope);\n    return admin.getConfig(scope, keys);\n  }\n<fim_suffix>  public static void updateResourceConfigsFor(Map<String, String> newConfigs, String resourceName, String clusterName,\n      HelixAdmin admin) {\n    final HelixConfigScope scope = getResourceScopeFor(clusterName, resourceName);\n    admin.setConfig(scope, newConfigs);\n  }<fim_middle>// function below has no smell\n"}