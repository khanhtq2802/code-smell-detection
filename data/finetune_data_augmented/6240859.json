{"text": "<fim_prefix> *\n * Contributors:\n *     Kiel University - initial API and implementation\n *******************************************************************************/\npackage org.eclipse.elk.alg.layered.intermediate;\nimport org.eclipse.elk.alg.common.nodespacing.NodeDimensionCalculation;\nimport org.eclipse.elk.alg.layered.graph.LGraph;\nimport org.eclipse.elk.alg.layered.graph.LGraphAdapters;\nimport org.eclipse.elk.alg.layered.graph.LLabel;\nimport org.eclipse.elk.alg.layered.graph.LNode;\nimport org.eclipse.elk.alg.layered.graph.LNode.NodeType;\nimport org.eclipse.elk.alg.layered.graph.LPort;\nimport org.eclipse.elk.alg.layered.graph.Layer;\nimport org.eclipse.elk.alg.layered.options.GraphProperties;\nimport org.eclipse.elk.alg.layered.options.InternalProperties;\nimport org.eclipse.elk.alg.layered.options.LayeredOptions;\nimport org.eclipse.elk.core.alg.ILayoutProcessor;\nimport org.eclipse.elk.core.math.ElkRectangle;\nimport org.eclipse.elk.core.math.KVector;\nimport org.eclipse.elk.core.options.PortLabelPlacement;\nimport org.eclipse.elk.core.util.IElkProgressMonitor;\n/**\n * Calculates node sizes, places ports, and places node and port labels.\n * \n * <p><i>Note:</i> Regarding port placement, this processor now does what the old\n * {@code PortPositionProcessor} did and thus replaces it.</p>\n * \n * <dl>\n *   <dt>Precondition:</dt>\n *     <dd>The graph is layered.</dd>\n *     <dd>Crossing minimization is finished.</dd>\n *     <dd>Port constraints are at least at {@code FIXED_ORDER}.</dd>\n *     <dd>Port lists are properly sorted going clockwise, starting at the leftmost northern port.</dd>\n *     <dd>External port dummies have the label-port and label-label spacing set that should apply to them.</dd>\n *   <dt>Postcondition:</dt>\n *     <dd>Port positions are fixed.</dd>\n *     <dd>Port labels are placed.</dd>\n *     <dd>Node labels are placed.</dd>\n *     <dd>Node sizes are set.</dd>\n *   <dt>Slots:</dt>\n *     <dd>Before phase 4.</dd>\n *   <dt>Same-slot dependencies:</dt>\n *     <dd>{@link LabelSideSelector}</dd>\n * </dl>\n * \n * @see LabelSideSelector\n * @author cds\n */\npublic final class LabelAndNodeSizeProcessor implements ILayoutProcessor<LGraph> {\n    /**\n     * {@inheritDoc}\n     */\n    public void process(final LGraph layeredGraph, final IElkProgressMonitor monitor) {\n        monitor.begin(\"Node and Port Label Placement and Node Sizing\", 1);\n        NodeDimensionCalculation.calculateLabelAndNodeSizes(LGraphAdapters.adapt(\n                layeredGraph,\n                false,\n                true,\n                node -> node.getType() == NodeType.NORMAL || node.getType() == NodeType.BIG_NODE));\n        // If the graph has external ports, we need to treat labels of external port dummies a bit differently,\n        // which is the reason why we haven't handed them to the label and node size processing code\n        if (layeredGraph.getProperty(InternalProperties.GRAPH_PROPERTIES).contains(GraphProperties.EXTERNAL_PORTS)) {\n            PortLabelPlacement portLabelPlacement = layeredGraph.getProperty(LayeredOptions.PORT_LABELS_PLACEMENT);\n            boolean placeNextToPort = layeredGraph.getProperty(LayeredOptions.PORT_LABELS_NEXT_TO_PORT_IF_POSSIBLE);\n            for (Layer layer : layeredGraph.getLayers()) {\n                layer.getNodes().stream()\n                        .filter(node -> node.getType() == NodeType.EXTERNAL_PORT)\n                        .forEach(dummy -> placeExternalPortDummyLabels(dummy, portLabelPlacement, placeNextToPort));\n            }\n        }\n        monitor.done();\n    }\n    /**\n     * Places the labels of the given external port dummy such that it results in correct node margins later on that\n     * will reserve enough space for the labels to be placed once label and node placement is called on the graph.\n     */\n    private void placeExternalPortDummyLabels(final LNode dummy, final PortLabelPlacement graphPortLabelPlacement,\n            final boolean placeNextToPortIfPossible) {\n        double labelPortSpacing = dummy.getProperty(LayeredOptions.SPACING_LABEL_PORT);\n        double labelLabelSpacing = dummy.getProperty(LayeredOptions.SPACING_LABEL_LABEL);\n        KVector dummySize = dummy.getSize();\n        // External port dummies have exactly one port (see ElkGraphImporter)\n        LPort dummyPort = dummy.getPorts().get(0);\n        KVector dummyPortPos = dummyPort.getPosition();\n        ElkRectangle portLabelBox = computePortLabelBox(dummyPort, labelLabelSpacing);\n        if (portLabelBox == null) {\n            return;\n        }\n        // Determine the position of the box\n        // TODO We could handle FIXED here as well\n        if (graphPortLabelPlacement == PortLabelPlacement.INSIDE) {\n            // (port label placement has to support this case first, though)\n            switch (dummy.getProperty(InternalProperties.EXT_PORT_SIDE)) {\n            case NORTH:\n                portLabelBox.x = (dummySize.x - portLabelBox.width) / 2 - dummyPortPos.x;\n                portLabelBox.y = labelPortSpacing;\n                break;\n            case SOUTH:\n                portLabelBox.x = (dummySize.x - portLabelBox.width) / 2 - dummyPortPos.x;\n                portLabelBox.y = -labelPortSpacing - portLabelBox.height;\n                break;\n            case EAST:\n                if (labelNextToPort(dummyPort, placeNextToPortIfPossible)) {\n                    portLabelBox.y = (dummySize.y - portLabelBox.height) / 2 - dummyPortPos.y;\n                } else {\n                    portLabelBox.y = dummySize.y + labelPortSpacing - dummyPortPos.y;\n                }\n                portLabelBox.x = -labelPortSpacing - portLabelBox.width;\n                break;\n            case WEST:\n                if (labelNextToPort(dummyPort, placeNextToPortIfPossible)) {\n                    portLabelBox.y = (dummySize.y - portLabelBox.height) / 2 - dummyPortPos.y;\n                } else {\n                    portLabelBox.y = dummySize.y + labelPortSpacing - dummyPortPos.y;\n                }\n                portLabelBox.x = labelPortSpacing;\n                break;\n            }\n        } else if (graphPortLabelPlacement == PortLabelPlacement.OUTSIDE) {\n            switch (dummy.getProperty(InternalProperties.EXT_PORT_SIDE)) {\n            case NORTH:\n            case SOUTH:\n                portLabelBox.x = dummyPortPos.x + labelPortSpacing;\n                break;\n            case EAST:\n            case WEST:\n                portLabelBox.y = dummyPortPos.y + labelPortSpacing;\n                break;\n            }\n        }\n        // Place the labels\n        double currentY = portLabelBox.y;\n        for (LLabel label : dummyPort.getLabels()) {\n            KVector labelPos = label.getPosition();\n            labelPos.x = portLabelBox.x;\n            labelPos.y = currentY;\n            currentY += label.getSize().y + labelLabelSpacing;\n        }\n    }\n    /**\n     * Returns the amount of space required to place the labels later, or {@code null} if there are no labels.\n     */\n    private ElkRectangle computePortLabelBox(final LPort dummyPort, final double labelLabelSpacing) {\n        if (dummyPort.getLabels().isEmpty()) {\n            return null;\n        } else {\n            ElkRectangle result = new ElkRectangle();\n            for (LLabel label : dummyPort.getLabels()) {\n                KVector labelSize = label.getSize();\n                result.width = Math.max(result.width, labelSize.x);\n                result.height += labelSize.y;\n            }\n            result.height += (dummyPort.getLabels().size() - 1) * labelLabelSpacing;\n            return result;\n        }\n    }\n    /**\n     * Checks whether the labels of the given port should be placed next to the port or below it. The former is the\n     * case if the user requested port labels to be placed next to the port, if possible, and if the port has no\n     * connections.\n     */\n<fim_suffix>    private boolean labelNextToPort(final LPort dummyPort, final boolean placeNextToPortIfPossible) {\n        return placeNextToPortIfPossible\n                && dummyPort.getIncomingEdges().isEmpty()\n                && dummyPort.getOutgoingEdges().isEmpty();\n    }<fim_middle>// function below has no smell\n"}