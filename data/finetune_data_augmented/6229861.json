{"text": "<fim_prefix>\n<fim_suffix>public class LayoutContext {\n\t/**\n\t * An {@link LayoutContext} notifies registered listeners about changes to\n\t * the layout algorithm using this property name.\n\t */\n\tpublic static final String LAYOUT_ALGORITHM_PROPERTY = \"layoutAlgorithm\";\n\tprivate ObjectProperty<ILayoutAlgorithm> layoutAlgorithmProperty = new SimpleObjectProperty<>(\n\t\t\tthis, LAYOUT_ALGORITHM_PROPERTY);\n\tprivate Graph graph;\n\tprivate final List<Runnable> postLayoutPass = new ArrayList<>();\n\tprivate final List<Runnable> preLayoutPass = new ArrayList<>();\n\tprivate final List<ILayoutFilter> layoutFilters = new ArrayList<>();\n\t/**\n\t * Adds the given ILayoutFilter to this {@link LayoutContext}.\n\t * \n\t * @param layoutFilter\n\t *            The ILayoutFilter to add to this context.\n\t */\n\tpublic void addLayoutFilter(ILayoutFilter layoutFilter) {\n\t\tlayoutFilters.add(layoutFilter);\n\t}\n\t/**\n\t * Applies the layout algorithm of this LayoutContext. The clean flag is\n\t * passed-in to the layout algorithm to indicate whether the context changed\n\t * significantly since the last layout pass.\n\t * \n\t * @param clear\n\t *            <code>true</code> to indicate that the algorithm has to fully\n\t *            re-compute the layout, otherwise <code>false</code>.\n\t */\n\tpublic void applyLayout(boolean clear) {\n\t\tILayoutAlgorithm layoutAlgorithm = layoutAlgorithmProperty.get();\n\t\tif (layoutAlgorithm != null) {\n\t\t\tpreLayout();\n\t\t\tlayoutAlgorithm.applyLayout(this, clear);\n\t\t\tpostLayout();\n\t\t}\n\t}\n\t/**\n\t * Initiated by the context or by an {@link ILayoutAlgorithm} to perform\n\t * steps that are scheduled to be run after the layout pass. Should not be\n\t * called by clients.\n\t */\n\tpublic void postLayout() {\n\t\tfor (Runnable r : new ArrayList<>(postLayoutPass)) {\n\t\t\tr.run();\n\t\t}\n\t}\n\t/**\n\t * Initiated by the context or by an {@link ILayoutAlgorithm} to perform\n\t * steps that are scheduled to be run before the layout pass. Should not be\n\t * called by clients.\n\t */\n\tpublic void preLayout() {\n\t\tfor (Runnable r : preLayoutPass) {\n\t\t\tr.run();\n\t\t}\n\t}\n\t/**\n\t * Returns the graph that is to be layouted.\n\t * \n\t * @return The {@link Graph} that is to be layouted.\n\t */\n\tpublic Graph getGraph() {\n\t\treturn graph;\n\t}\n\t/**\n\t * Sets the graph that is to be layouted by this context.\n\t * \n\t * @param graph\n\t *            The {@link Graph} to layout.\n\t */\n\tpublic void setGraph(Graph graph) {\n\t\t// TODO: we should not allow to pass in null here. Instead we should\n\t\t// guard ourselves against null.\n\t\tif (graph == null) {\n\t\t\tgraph = new Graph();\n\t\t}\n\t\tthis.graph = graph;\n\t}\n\t/**\n\t * Returns all the nodes that should be laid out. Replacing elements in the\n\t * returned array does not affect this context.\n\t * \n\t * @return array of nodes to lay out\n\t */\n\t// TODO: remove this (algorithms should use getGraph().getNodes())\n\tpublic Node[] getNodes() {\n\t\tObservableList<Node> nodes = graph.getNodes();\n\t\tList<Node> layoutRelevantNodes = new ArrayList<>();\n\t\tfor (Node n : nodes) {\n\t\t\tif (!isLayoutIrrelevant(n)) {\n\t\t\t\tlayoutRelevantNodes.add(n);\n\t\t\t}\n\t\t}\n\t\treturn layoutRelevantNodes.toArray(new Node[] {});\n\t}\n\t/**\n\t * Returns all the connections between nodes that should be laid out.\n\t * Replacing elements in the returned array does not affect this context.\n\t * \n\t * @return array of connections between nodes\n\t */\n\tpublic Edge[] getEdges() {\n\t\tObservableList<Edge> edges = graph.getEdges();\n\t\tList<Edge> layoutRelevantEdges = new ArrayList<>();\n\t\tfor (Edge e : edges) {\n\t\t\tif (!isLayoutIrrelevant(e)) {\n\t\t\t\tlayoutRelevantEdges.add(e);\n\t\t\t}\n\t\t}\n\t\treturn layoutRelevantEdges.toArray(new Edge[] {});\n\t}\n\t/**\n\t * Returns the static layout algorithm used to layout a newly initialized\n\t * graph or after heavy changes to it.\n\t * \n\t * @return The layout algorithm that is used by this {@link LayoutContext}.\n\t */\n\tpublic ILayoutAlgorithm getLayoutAlgorithm() {\n\t\treturn layoutAlgorithmProperty.get();\n\t}\n\t/**\n\t * Returns <code>true</code> when the given {@link Edge} is not relevant for\n\t * layout according to the configured {@link ILayoutFilter layout filters}.\n\t * Otherwise returns <code>false</code>.\n\t * \n\t * @param edge\n\t *            The {@link Edge} in question.\n\t * @return <code>true</code> when the given {@link Edge} is not relevant for\n\t *         layout according to the configure layout filters, otherwise\n\t *         <code>false</code>.\n\t */\n\tpublic boolean isLayoutIrrelevant(Edge edge) {\n\t\tfor (ILayoutFilter filter : layoutFilters) {\n\t\t\tif (filter.isLayoutIrrelevant(edge)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t/**\n\t * Returns <code>true</code> when the given {@link Node} is not relevant for\n\t * layout according to the configured {@link ILayoutFilter layout filters}.\n\t * Otherwise returns <code>false</code>.\n\t * \n\t * @param nodeLayout\n\t *            The {@link Node} in question.\n\t * @return <code>true</code> when the given {@link Node} is not relevant for\n\t *         layout according to the configure layout filters, otherwise\n\t *         <code>false</code>.\n\t */\n\tpublic boolean isLayoutIrrelevant(Node nodeLayout) {\n\t\tfor (ILayoutFilter filter : layoutFilters) {\n\t\t\tif (filter.isLayoutIrrelevant(nodeLayout)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t/**\n\t * A property representing the layout algorithm used by this\n\t * {@link LayoutContext}.\n\t * \n\t * @see #getLayoutAlgorithm()\n\t * @see #setLayoutAlgorithm(ILayoutAlgorithm)\n\t * \n\t * @return A property named {@link #LAYOUT_ALGORITHM_PROPERTY}.\n\t */\n\tpublic ObjectProperty<ILayoutAlgorithm> layoutAlgorithmProperty() {\n\t\treturn layoutAlgorithmProperty;\n\t};\n\t/**\n\t * Removes the given ILayoutFilter from this {@link LayoutContext}.\n\t * \n\t * @param layoutFilter\n\t *            The ILayoutFilter to remove to this context.\n\t */\n\tpublic void removeLayoutFilter(ILayoutFilter layoutFilter) {\n\t\tlayoutFilters.remove(layoutFilter);\n\t}\n\t/**\n\t * Adds the given {@link Runnable} to the list of runnables which are called\n\t * when this {@link LayoutContext} is asked to apply all changes made to its\n\t * elements to the display.\n\t * \n\t * @param runnable\n\t *            A {@link Runnable} called whenever this context is asked to\n\t *            apply all changes made to its elements to the display.\n\t */\n\tpublic void schedulePostLayoutPass(Runnable runnable) {\n\t\tif (runnable == null) {\n\t\t\tthrow new IllegalArgumentException(\"Runnable may not be null.\");\n\t\t}\n\t\tif (!postLayoutPass.contains(runnable)) {\n\t\t\tpostLayoutPass.add(runnable);\n\t\t}\n\t}\n\t/**\n\t * Adds the given {@link Runnable} to the list of {@link Runnable}s which\n\t * are executed before applying a layout, i.e. before\n\t * {@link #applyLayout(boolean)}.\n\t * \n\t * @param runnable\n\t *            The {@link Runnable} to add to the list of {@link Runnable}s\n\t *            which are executed before applying a layout.\n\t */\n\tpublic void schedulePreLayoutPass(Runnable runnable) {\n\t\tif (runnable == null) {\n\t\t\tthrow new IllegalArgumentException(\"Runnable may not be null.\");\n\t\t}\n\t\tif (!preLayoutPass.contains(runnable)) {\n\t\t\tpreLayoutPass.add(runnable);\n\t\t}\n\t}\n\t/**\n\t * Sets the layout algorithm for this context.\n\t * \n\t * @param algorithm\n\t *            The new {@link ILayoutAlgorithm} for this\n\t *            {@link LayoutContext}.\n\t */\n\tpublic void setLayoutAlgorithm(ILayoutAlgorithm algorithm) {\n\t\tlayoutAlgorithmProperty.set(algorithm);\n\t}\n\t/**\n\t * Removes the given {@link Runnable} from the list of runnables which are\n\t * called when this {@link LayoutContext} is asked to apply all changes made\n\t * to its elements to the display.\n\t * \n\t * @param runnable\n\t *            The {@link Runnable} that should no longer get called when\n\t *            flushing changes.\n\t */\n\tpublic void unschedulePostLayoutPass(Runnable runnable) {<fim_middle>// class below is blob\n"}