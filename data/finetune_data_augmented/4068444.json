{"text": "<fim_prefix>\n<fim_suffix>@StatsDoc(\n    name = BookKeeperClientStats.CHANNEL_SCOPE,\n    help = \"Per channel bookie client stats\"\n)\n@Sharable\npublic class PerChannelBookieClient extends ChannelInboundHandlerAdapter {\n    static final Logger LOG = LoggerFactory.getLogger(PerChannelBookieClient.class);\n    // this set contains the bookie error return codes that we do not consider for a bookie to be \"faulty\"\n    private static final Set<Integer> expectedBkOperationErrors = Collections.unmodifiableSet(Sets\n            .newHashSet(BKException.Code.BookieHandleNotAvailableException,\n                        BKException.Code.NoSuchEntryException,\n                        BKException.Code.NoSuchLedgerExistsException,\n                        BKException.Code.LedgerFencedException,\n                        BKException.Code.LedgerExistException,\n                        BKException.Code.DuplicateEntryIdException,\n                        BKException.Code.WriteOnReadOnlyBookieException));\n    private static final int DEFAULT_HIGH_PRIORITY_VALUE = 100; // We may add finer grained priority later.\n    private static final AtomicLong txnIdGenerator = new AtomicLong(0);\n    final BookieSocketAddress addr;\n    final EventLoopGroup eventLoopGroup;\n    final ByteBufAllocator allocator;\n    final OrderedExecutor executor;\n    final long addEntryTimeoutNanos;\n    final long readEntryTimeoutNanos;\n    final int maxFrameSize;\n    final int getBookieInfoTimeout;\n    final int startTLSTimeout;\n    private final ConcurrentOpenHashMap<CompletionKey, CompletionValue> completionObjects =\n        new ConcurrentOpenHashMap<CompletionKey, CompletionValue>();\n    // Map that hold duplicated read requests. The idea is to only use this map (synchronized) when there is a duplicate\n    // read request for the same ledgerId/entryId\n    private final SynchronizedHashMultiMap<CompletionKey, CompletionValue> completionObjectsV2Conflicts =\n        new SynchronizedHashMultiMap<>();\n    private final StatsLogger statsLogger;\n    @StatsDoc(\n        name = BookKeeperClientStats.CHANNEL_READ_OP,\n        help = \"channel stats of read entries requests\"\n    )\n    private final OpStatsLogger readEntryOpLogger;\n    @StatsDoc(\n        name = BookKeeperClientStats.CHANNEL_TIMEOUT_READ,\n        help = \"timeout stats of read entries requests\"\n    )\n    private final OpStatsLogger readTimeoutOpLogger;\n    @StatsDoc(\n        name = BookKeeperClientStats.CHANNEL_ADD_OP,\n        help = \"channel stats of add entries requests\"\n    )\n    private final OpStatsLogger addEntryOpLogger;\n    @StatsDoc(\n        name = BookKeeperClientStats.CHANNEL_WRITE_LAC_OP,\n        help = \"channel stats of write_lac requests\"\n    )\n    private final OpStatsLogger writeLacOpLogger;\n    @StatsDoc(\n        name = BookKeeperClientStats.CHANNEL_FORCE_OP,\n        help = \"channel stats of force requests\"\n    )\n    private final OpStatsLogger forceLedgerOpLogger;\n    @StatsDoc(\n        name = BookKeeperClientStats.CHANNEL_READ_LAC_OP,\n        help = \"channel stats of read_lac requests\"\n    )\n    private final OpStatsLogger readLacOpLogger;\n    @StatsDoc(\n        name = BookKeeperClientStats.CHANNEL_TIMEOUT_ADD,\n        help = \"timeout stats of add entries requests\"\n    )\n    private final OpStatsLogger addTimeoutOpLogger;\n    @StatsDoc(\n        name = BookKeeperClientStats.CHANNEL_TIMEOUT_WRITE_LAC,\n        help = \"timeout stats of write_lac requests\"\n    )\n    private final OpStatsLogger writeLacTimeoutOpLogger;\n    @StatsDoc(\n        name = BookKeeperClientStats.CHANNEL_TIMEOUT_FORCE,\n        help = \"timeout stats of force requests\"\n    )\n    private final OpStatsLogger forceLedgerTimeoutOpLogger;\n    @StatsDoc(\n        name = BookKeeperClientStats.CHANNEL_TIMEOUT_READ_LAC,\n        help = \"timeout stats of read_lac requests\"\n    )\n    private final OpStatsLogger readLacTimeoutOpLogger;\n    @StatsDoc(\n        name = BookKeeperClientStats.GET_BOOKIE_INFO_OP,\n        help = \"channel stats of get_bookie_info requests\"\n    )\n    private final OpStatsLogger getBookieInfoOpLogger;\n    @StatsDoc(\n        name = BookKeeperClientStats.TIMEOUT_GET_BOOKIE_INFO,\n        help = \"timeout stats of get_bookie_info requests\"\n    )\n    private final OpStatsLogger getBookieInfoTimeoutOpLogger;\n    @StatsDoc(\n        name = BookKeeperClientStats.CHANNEL_START_TLS_OP,\n        help = \"channel stats of start_tls requests\"\n    )\n    private final OpStatsLogger startTLSOpLogger;\n    @StatsDoc(\n        name = BookKeeperClientStats.CHANNEL_TIMEOUT_START_TLS_OP,\n        help = \"timeout stats of start_tls requests\"\n    )\n    private final OpStatsLogger startTLSTimeoutOpLogger;\n    @StatsDoc(\n        name = BookKeeperClientStats.CLIENT_CONNECT_TIMER,\n        help = \"channel stats of connect requests\"\n    )\n    private final OpStatsLogger connectTimer;\n    @StatsDoc(\n        name = BookKeeperClientStats.NETTY_EXCEPTION_CNT,\n        help = \"the number of exceptions received from this channel\"\n    )\n    private final Counter exceptionCounter;\n    @StatsDoc(\n        name = BookKeeperClientStats.ADD_OP_OUTSTANDING,\n        help = \"the number of outstanding add_entry requests\"\n    )\n    private final Counter addEntryOutstanding;\n    @StatsDoc(\n        name = BookKeeperClientStats.READ_OP_OUTSTANDING,\n        help = \"the number of outstanding add_entry requests\"\n    )\n    private final Counter readEntryOutstanding;\n    /* collect stats on all Ops that flows through netty pipeline */\n    @StatsDoc(\n        name = BookKeeperClientStats.NETTY_OPS,\n        help = \"channel stats for all operations flowing through netty pipeline\"\n    )\n    private final OpStatsLogger nettyOpLogger;\n    @StatsDoc(\n        name = BookKeeperClientStats.ACTIVE_NON_TLS_CHANNEL_COUNTER,\n        help = \"the number of active non-tls channels\"\n    )\n    private final Counter activeNonTlsChannelCounter;\n    @StatsDoc(\n        name = BookKeeperClientStats.ACTIVE_TLS_CHANNEL_COUNTER,\n        help = \"the number of active tls channels\"\n    )\n    private final Counter activeTlsChannelCounter;\n    @StatsDoc(\n        name = BookKeeperClientStats.FAILED_CONNECTION_COUNTER,\n        help = \"the number of failed connections\"\n    )\n    private final Counter failedConnectionCounter;\n    @StatsDoc(\n        name = BookKeeperClientStats.FAILED_TLS_HANDSHAKE_COUNTER,\n        help = \"the number of failed tls handshakes\"\n    )\n    private final Counter failedTlsHandshakeCounter;\n    private final boolean useV2WireProtocol;\n    private final boolean preserveMdcForTaskExecution;\n    /**\n     * The following member variables do not need to be concurrent, or volatile\n     * because they are always updated under a lock.\n     */\n    private volatile Queue<GenericCallback<PerChannelBookieClient>> pendingOps =\n            new ArrayDeque<GenericCallback<PerChannelBookieClient>>();\n    volatile Channel channel = null;\n    private final ClientConnectionPeer connectionPeer;\n    private volatile BookKeeperPrincipal authorizedId = BookKeeperPrincipal.ANONYMOUS;\n    enum ConnectionState {\n        DISCONNECTED, CONNECTING, CONNECTED, CLOSED, START_TLS\n    }\n    volatile ConnectionState state;\n    final ReentrantReadWriteLock closeLock = new ReentrantReadWriteLock();\n    private final ClientConfiguration conf;\n    private final PerChannelBookieClientPool pcbcPool;\n    private final ClientAuthProvider.Factory authProviderFactory;\n    private final ExtensionRegistry extRegistry;\n    private final SecurityHandlerFactory shFactory;\n    private volatile boolean isWritable = true;\n    public PerChannelBookieClient(OrderedExecutor executor, EventLoopGroup eventLoopGroup,\n                                  BookieSocketAddress addr) throws SecurityException {\n        this(new ClientConfiguration(), executor, eventLoopGroup, addr, NullStatsLogger.INSTANCE, null, null,\n                null);\n    }\n    public PerChannelBookieClient(OrderedExecutor executor, EventLoopGroup eventLoopGroup,\n                                  BookieSocketAddress addr,\n                                  ClientAuthProvider.Factory authProviderFactory,\n                                  ExtensionRegistry extRegistry) throws SecurityException {\n        this(new ClientConfiguration(), executor, eventLoopGroup, addr, NullStatsLogger.INSTANCE,\n                authProviderFactory, extRegistry, null);\n    }\n    public PerChannelBookieClient(ClientConfiguration conf, OrderedExecutor executor,\n                                  EventLoopGroup eventLoopGroup, BookieSocketAddress addr,\n                                  StatsLogger parentStatsLogger, ClientAuthProvider.Factory authProviderFactory,\n                                  ExtensionRegistry extRegistry,<fim_middle>// class below is blob\n"}