{"text": "<fim_prefix>/*\n * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n\n\npackage jdk.tools.jaotc.binformat.macho;\n\nimport java.nio.ByteBuffer;\nimport java.util.ArrayList;\n\nimport jdk.tools.jaotc.binformat.macho.MachO.nlist_64;\nimport jdk.tools.jaotc.binformat.macho.MachO.symtab_command;\n\n<fim_suffix>final class MachOSymtab {\n\n    /**\n     * ByteBuffer holding the LC_SYMTAB command contents.\n     */\n    private final ByteBuffer symtabCmd;\n\n    private int symtabDataSize;\n\n    private final ArrayList<MachOSymbol> localSymbols = new ArrayList<>();\n    private final ArrayList<MachOSymbol> globalSymbols = new ArrayList<>();\n    private final ArrayList<MachOSymbol> undefSymbols = new ArrayList<>();\n\n    /**\n     * Number of symbols added.\n     */\n    private int symbolCount;\n\n    /**\n     * String holding symbol table strings.\n     */\n    private final StringBuilder strTabContent = new StringBuilder();\n\n    /**\n     * Keeps track of bytes in string table since strTabContent.length() is number of chars, not\n     * bytes.\n     */\n    private int strTabNrOfBytes = 0;\n\n    MachOSymtab() {\n        symtabCmd = MachOByteBuffer.allocate(symtab_command.totalsize);\n\n        symtabCmd.putInt(symtab_command.cmd.off, symtab_command.LC_SYMTAB);\n        symtabCmd.putInt(symtab_command.cmdsize.off, symtab_command.totalsize);\n\n        symbolCount = 0;\n\n    }\n\n    static int getAlign() {\n        return (4);\n    }\n\n    MachOSymbol addSymbolEntry(String name, byte type, byte secHdrIndex, long offset) {\n        // Get the current symbol index and append symbol name to string table.\n        int index;\n        MachOSymbol sym;\n\n        if (name.isEmpty()) {\n            index = 0;\n            strTabContent.append('\\0');\n            strTabNrOfBytes += 1;\n            sym = new MachOSymbol(symbolCount, index, type, secHdrIndex, offset);\n            localSymbols.add(sym);\n        } else {\n            // We can't trust strTabContent.length() since that is\n            // chars (UTF16), keep track of bytes on our own.\n            index = strTabNrOfBytes;\n            strTabContent.append(\"_\").append(name).append('\\0');\n            // + 1 for null, + 1 for \"_\"\n            strTabNrOfBytes += (name.getBytes().length + 1 + 1);\n\n            sym = new MachOSymbol(symbolCount, index, type, secHdrIndex, offset);\n            switch (type) {\n                case nlist_64.N_EXT:\n                    undefSymbols.add(sym);\n                    break;\n                case nlist_64.N_SECT:\n                case nlist_64.N_UNDF:  // null symbol\n                    localSymbols.add(sym);\n                    break;\n                case nlist_64.N_SECT | nlist_64.N_EXT:\n                    globalSymbols.add(sym);\n                    break;\n                default:\n                    System.out.println(\"Unsupported Symbol type \" + type);\n                    break;\n            }\n        }\n        symbolCount++;\n        return (sym);\n    }\n\n    void setOffset(int symoff) {\n        symtabCmd.putInt(symtab_command.symoff.off, symoff);\n    }\n\n    // Update the symbol indexes once all symbols have been added.\n    // This is required since we'll be reordering the symbols in the\n    // file to be in the order of Local, global and Undefined.\n    void updateIndexes() {\n        int index = 0;\n\n        // Update the local symbol indexes\n        for (int i = 0; i < localSymbols.size(); i++) {\n            MachOSymbol sym = localSymbols.get(i);\n            sym.setIndex(index++);\n        }\n\n        // Update the global symbol indexes\n        for (int i = 0; i < globalSymbols.size(); i++) {\n            MachOSymbol sym = globalSymbols.get(i);\n            sym.setIndex(index++);\n        }\n\n        // Update the undefined symbol indexes\n        for (int i = index; i < undefSymbols.size(); i++) {\n            MachOSymbol sym = undefSymbols.get(i);\n            sym.setIndex(index++);\n        }\n    }\n\n    // Update LC_SYMTAB command fields based on the number of symbols added\n    // return the file size taken up by symbol table entries and strings\n    int calcSizes() {\n        int stroff;\n\n        stroff = symtabCmd.getInt(symtab_command.symoff.off) + (nlist_64.totalsize * symbolCount);\n        symtabCmd.putInt(symtab_command.nsyms.off, symbolCount);\n        symtabCmd.putInt(symtab_command.stroff.off, stroff);\n        symtabCmd.putInt(symtab_command.strsize.off, strTabNrOfBytes);\n        symtabDataSize = (nlist_64.totalsize * symbolCount) + strTabNrOfBytes;\n\n        return (symtabDataSize);\n    }\n\n    int getNumLocalSyms() {\n        return localSymbols.size();\n    }\n\n    int getNumGlobalSyms() {\n        return globalSymbols.size();\n    }\n\n    int getNumUndefSyms() {\n        return undefSymbols.size();\n    }\n\n    byte[] getCmdArray() {\n        return symtabCmd.array();\n    }\n\n    // Create a single byte array that contains the symbol table entries\n    // and string table\n    byte[] getDataArray() {\n        ByteBuffer symtabData = MachOByteBuffer.allocate(symtabDataSize);\n        byte[] retarray;\n\n        // Add the local symbols\n        for (int i = 0; i < localSymbols.size(); i++) {\n            MachOSymbol sym = localSymbols.get(i);\n            byte[] arr = sym.getArray();\n            symtabData.put(arr);\n        }\n        // Add the global symbols\n        for (int i = 0; i < globalSymbols.size(); i++) {\n            MachOSymbol sym = globalSymbols.get(i);\n            byte[] arr = sym.getArray();\n            symtabData.put(arr);\n        }\n        // Add the undefined symbols\n        for (int i = 0; i < undefSymbols.size(); i++) {\n            MachOSymbol sym = undefSymbols.get(i);\n            byte[] arr = sym.getArray();\n            symtabData.put(arr);\n        }\n\n        // Add the stringtable\n        byte[] strs = strTabContent.toString().getBytes();\n        symtabData.put(strs);\n\n        retarray = symtabData.array();\n\n        return (retarray);\n    }\n}<fim_middle>// class below has no smell\n"}