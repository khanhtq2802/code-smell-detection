{"text": "<fim_prefix>/*\n * Copyright (c) 2018 VMware, Inc. All Rights Reserved.\n *\n * This product is licensed to you under the Apache License, Version 2.0 (the \"License\").\n * You may not use this product except in compliance with the License.\n *\n * This product may include a number of subcomponents with separate copyright notices\n * and license terms. Your use of these subcomponents is subject to the terms and\n * conditions of the subcomponent's license, as noted in the LICENSE file.\n */\npackage com.vmware.photon.controller.model.resources;\nimport static com.vmware.photon.controller.model.resources.IPAddressService.IPAddressState.DEFAULT_IP_VERSION;\nimport java.util.UUID;\nimport io.netty.util.internal.StringUtil;\nimport com.vmware.photon.controller.model.ServiceUtils;\nimport com.vmware.photon.controller.model.UriPaths;\nimport com.vmware.photon.controller.model.resources.IPAddressService.IPAddressState.IPAddressStatus;\nimport com.vmware.photon.controller.model.support.IPVersion;\nimport com.vmware.photon.controller.model.util.AssertUtil;\nimport com.vmware.photon.controller.model.util.SubnetValidator;\nimport com.vmware.xenon.common.LocalizableValidationException;\nimport com.vmware.xenon.common.Operation;\nimport com.vmware.xenon.common.ServiceDocument;\nimport com.vmware.xenon.common.ServiceDocumentDescription;\nimport com.vmware.xenon.common.StatefulService;\nimport com.vmware.xenon.common.Utils;\n/**\n * Represents a statically assigned ip address from a pre-defined subnet range.\n *\n * @see SubnetRangeService.SubnetRangeState\n */\npublic class IPAddressService extends StatefulService {\n    public static final String FACTORY_LINK = UriPaths.RESOURCES + \"/ip-addresses\";\n    /**\n     * Represents the state of an ip address.\n     */\n    public static class IPAddressState extends ResourceState {\n        public static final String FIELD_NAME_SUBNET_RANGE_LINK = \"subnetRangeLink\";\n        public static final String FIELD_NAME_IP_ADDRESS_STATUS = \"ipAddressStatus\";\n        public static final String FIELD_NAME_CONNECTED_RESOURCE_LINK = \"connectedResourceLink\";\n        // Default values for non-required fields\n        public static final IPVersion DEFAULT_IP_VERSION = IPVersion.IPv4;\n        public enum IPAddressStatus {\n            ALLOCATED, // IP is allocated\n            RELEASED,  // IP is no longer allocated, but still not available to be re-allocated\n            AVAILABLE;  // IP is available for allocation, this is an intermediate state before the IPAddressState is being deleted\n            /**\n             * Allocated IPs should be in 'released' state before becoming 'available' again for allocation.\n             * This method validates the status transitions.\n             *\n             * @param currentStatus current IPAddressStatus\n             * @param newStatus     IPAddressStatus to transition to\n             * @return true if the transition is valid\n             */\n            static boolean isValidTransition(IPAddressStatus currentStatus,\n                    IPAddressStatus newStatus) {\n                return (currentStatus != null && currentStatus.equals(newStatus) ||\n                        (AVAILABLE.equals(currentStatus) && ALLOCATED.equals(newStatus)) ||\n                        (ALLOCATED.equals(currentStatus) && RELEASED.equals(newStatus)) ||\n                        (RELEASED.equals(currentStatus) && AVAILABLE.equals(newStatus)));\n            }\n        }\n        /**\n         * Link to the subnet range this IP belongs to.\n         */\n        @Documentation(description = \"Link to the parent subnet range.\")\n        @PropertyOptions(usage = {\n                ServiceDocumentDescription.PropertyUsageOption.OPTIONAL,\n                ServiceDocumentDescription.PropertyUsageOption.LINK,\n                ServiceDocumentDescription.PropertyUsageOption.SINGLE_ASSIGNMENT\n                })\n        public String subnetRangeLink;\n        /**\n         * Link to the resource this IP is assigned to.\n         */\n        @Documentation(description = \"Link to the resource this IP is assigned to.\")\n        @PropertyOptions(usage = {\n                ServiceDocumentDescription.PropertyUsageOption.OPTIONAL,\n                ServiceDocumentDescription.PropertyUsageOption.LINK,\n                ServiceDocumentDescription.PropertyUsageOption.AUTO_MERGE_IF_NOT_NULL\n                })\n        public String connectedResourceLink;\n        /**\n         * Ip address.\n         */\n        @Documentation(description = \"IP address\")\n        @PropertyOptions(usage = {\n                ServiceDocumentDescription.PropertyUsageOption.REQUIRED,\n                ServiceDocumentDescription.PropertyUsageOption.SINGLE_ASSIGNMENT\n                })\n        public String ipAddress;\n        /**\n         * Whether the start and end ip address is IPv4 or IPv6.\n         * If not set, default to IPv4.\n         */\n        @Documentation(description = \"IP address version: IPv4 or IPv6. Default: IPv4\")\n        @PropertyOptions(usage = {\n                ServiceDocumentDescription.PropertyUsageOption.OPTIONAL,\n                ServiceDocumentDescription.PropertyUsageOption.SINGLE_ASSIGNMENT\n                })\n        public IPVersion ipVersion;\n        /**\n         * The state of the IP address.\n         */\n        @Documentation(description = \"IP address status: ALLOCATED, RELEASED or AVAILABLE\")\n        @PropertyOptions(usage = {\n                ServiceDocumentDescription.PropertyUsageOption.REQUIRED\n                })\n        public IPAddressStatus ipAddressStatus;\n<fim_suffix>        public String toString() {\n            StringBuilder sb = new StringBuilder();\n            sb.append(\"name: \").append(this.name);\n            sb.append(\", id: \").append(this.id);\n            sb.append(\", subnet range link: \").append(this.subnetRangeLink);\n            sb.append(\", resource link: \").append(this.connectedResourceLink);\n            sb.append(\", IP address: \").append(this.ipAddress);\n            sb.append(\", IP version: \").append(this.ipVersion);\n            sb.append(\", status: \").append(this.ipAddressStatus);\n            return sb.toString();\n        }\n    }\n    public IPAddressService() {\n        super(IPAddressState.class);\n        super.toggleOption(ServiceOption.PERSISTENCE, true);\n        super.toggleOption(ServiceOption.REPLICATION, true);\n        super.toggleOption(ServiceOption.OWNER_SELECTION, true);\n        super.toggleOption(ServiceOption.IDEMPOTENT_POST, true);\n    }\n    @Override\n    public void handleStart(Operation start) {\n        processInput(start);\n        start.complete();\n    }\n    @Override\n    public void handlePost(Operation post) {\n        IPAddressState returnState = processInput(post);\n        setState(post, returnState);\n        post.complete();\n    }\n    @Override\n    public void handlePut(Operation put) {\n        IPAddressState newState = processInput(put);\n        // Verify valid status changes\n        IPAddressState currentState = getState(put);\n        validateIPAddressStatusTransition(currentState, newState);\n        setState(put, newState);\n        put.complete();\n    }\n    @Override\n    public void handlePatch(Operation patch) {\n        if (!patch.hasBody()) {\n            throw (new IllegalArgumentException(\"body is required\"));\n        }\n        IPAddressState currentState = getState(patch);\n        ResourceUtils.handlePatch(patch, currentState, getStateDescription(),\n                IPAddressState.class, op -> {\n                    IPAddressState patchState = patch.getBody(IPAddressState.class);\n                    boolean hasChanged = false;\n                    // Verify valid status changes\n                    if (patchState.ipAddressStatus != null\n                            && patchState.ipAddressStatus != currentState.ipAddressStatus) {\n                        validateIPAddressStatusTransition(currentState, patchState);\n                        currentState.ipAddressStatus = patchState.ipAddressStatus;\n                        validateIPAddressStatusWithConnectedResource(currentState);\n                        hasChanged = true;\n                    }\n                    return Boolean.valueOf(hasChanged);\n                });\n    }\n    @Override\n    public ServiceDocument getDocumentTemplate() {\n        ServiceDocument td = super.getDocumentTemplate();\n        ServiceUtils.setRetentionLimit(td);\n        IPAddressState template = (IPAddressState) td;\n        template.id = UUID.randomUUID().toString();\n        template.name = \"ip-address\";\n        return template;\n    }\n    /**\n     * @param op operation\n     * @return a valid IPAddressState\n     * @throws IllegalArgumentException if input invalid\n     */\n    private IPAddressState processInput(Operation op) {\n        if (!op.hasBody()) {\n            throw (new IllegalArgumentException(\"body is required\"));\n        }\n        IPAddressState state = op.getBody(IPAddressState.class);\n        validateState(state);\n        return state;\n    }\n    /**\n     * Validation upon creation of an IP address object.\n     * - valid IP address\n     * No need to validate that the IP is within the range.\n     *\n     * @param state IpAddressState to validate\n     * @throws IllegalArgumentException for invalid state\n     */\n    private void validateState(IPAddressState state) {\n        // Verify values based on the document description\n        Utils.validateState(getStateDescription(), state);\n        if (state.ipVersion == null) {\n            state.ipVersion = DEFAULT_IP_VERSION;\n        }\n        if (!SubnetValidator.isValidIPAddress(state.ipAddress, state.ipVersion)) {\n            throw new LocalizableValidationException(String.format(\"Invalid IP address: %s\",\n                    state.ipAddress),\n                    \"ip.address.invalid\", state.ipAddress);\n        }<fim_middle>// function below has no smell\n"}