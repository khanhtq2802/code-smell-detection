{"text": "<fim_prefix>            return hash;\n        }\n        @Override\n        public boolean equals(Object obj) {\n            if (obj == null) {\n                return false;\n            }\n            if (!super.equals(obj)) {\n                return false;\n            }\n            final MethodDescription other = (MethodDescription) obj;\n            if (!Objects.equals(this.name, other.name)) {\n                return false;\n            }\n            if (!Objects.equals(this.descriptor, other.descriptor)) {\n                return false;\n            }\n            if (!Objects.equals(this.thrownTypes, other.thrownTypes)) {\n                return false;\n            }\n            if (!Objects.equals(this.annotationDefaultValue, other.annotationDefaultValue)) {\n                return false;\n            }\n            return true;\n        }\n        @Override\n        public void write(Appendable output, String baselineVersion, String version) throws IOException {\n            if (shouldIgnore(baselineVersion, version))\n                return ;\n            if (!versions.contains(version)) {\n                output.append(\"-method\");\n                output.append(\" name \" + quote(name, false));\n                output.append(\" descriptor \" + quote(descriptor, false));\n                output.append(\"\\n\");\n                return ;\n            }\n            output.append(\"method\");\n            output.append(\" name \" + quote(name, false));\n            output.append(\" descriptor \" + quote(descriptor, false));\n            if (thrownTypes != null)\n                output.append(\" thrownTypes \" + serializeList(thrownTypes));\n            if (annotationDefaultValue != null)\n                output.append(\" annotationDefaultValue \" + quote(AnnotationDescription.dumpAnnotationValue(annotationDefaultValue), false));\n            writeAttributes(output);\n            if (classParameterAnnotations != null && !classParameterAnnotations.isEmpty()) {\n                output.append(\" classParameterAnnotations \");\n                for (List<AnnotationDescription> pa : classParameterAnnotations) {\n                    for (AnnotationDescription a : pa) {\n                        output.append(quote(a.toString(), false));\n                    }\n                    output.append(\";\");\n                }\n            }\n            if (runtimeParameterAnnotations != null && !runtimeParameterAnnotations.isEmpty()) {\n                output.append(\" runtimeParameterAnnotations \");\n                for (List<AnnotationDescription> pa : runtimeParameterAnnotations) {\n                    for (AnnotationDescription a : pa) {\n                        output.append(quote(a.toString(), false));\n                    }\n                    output.append(\";\");\n                }\n            }\n            output.append(\"\\n\");\n        }\n        @Override\n        public boolean read(LineBasedReader reader) throws IOException {\n            if (!\"method\".equals(reader.lineKey))\n                return false;\n            name = reader.attributes.get(\"name\");\n            descriptor = reader.attributes.get(\"descriptor\");\n            String thrownTypesValue = reader.attributes.get(\"thrownTypes\");\n            if (thrownTypesValue != null) {\n                thrownTypes = deserializeList(thrownTypesValue);\n            }\n            String inAnnotationDefaultValue = reader.attributes.get(\"annotationDefaultValue\");\n            if (inAnnotationDefaultValue != null) {\n                annotationDefaultValue = parseAnnotationValue(inAnnotationDefaultValue, new int[1]);\n            }\n            readAttributes(reader);\n            String inClassParamAnnotations = reader.attributes.get(\"classParameterAnnotations\");\n            if (inClassParamAnnotations != null) {\n                List<List<AnnotationDescription>> annos = new ArrayList<>();\n                int[] pointer = new int[1];\n                do {\n                    annos.add(parseAnnotations(inClassParamAnnotations, pointer));\n                    assert pointer[0] == inClassParamAnnotations.length() || inClassParamAnnotations.charAt(pointer[0]) == ';';\n                } while (++pointer[0] < inClassParamAnnotations.length());\n                classParameterAnnotations = annos;\n            }\n            String inRuntimeParamAnnotations = reader.attributes.get(\"runtimeParameterAnnotations\");\n            if (inRuntimeParamAnnotations != null) {\n                List<List<AnnotationDescription>> annos = new ArrayList<>();\n                int[] pointer = new int[1];\n                do {\n                    annos.add(parseAnnotations(inRuntimeParamAnnotations, pointer));\n                    assert pointer[0] == inRuntimeParamAnnotations.length() || inRuntimeParamAnnotations.charAt(pointer[0]) == ';';\n                } while (++pointer[0] < inRuntimeParamAnnotations.length());\n                runtimeParameterAnnotations = annos;\n            }\n            reader.moveNext();\n            return true;\n        }\n    }\n    static class FieldDescription extends FeatureDescription {\n        String name;\n        String descriptor;\n        Object constantValue;\n        @Override\n        public int hashCode() {\n            int hash = super.hashCode();\n            hash = 59 * hash + Objects.hashCode(this.name);\n            hash = 59 * hash + Objects.hashCode(this.descriptor);\n            hash = 59 * hash + Objects.hashCode(this.constantValue);\n            return hash;\n        }\n        @Override\n        public boolean equals(Object obj) {\n            if (obj == null) {\n                return false;\n            }\n            if (!super.equals(obj)) {\n                return false;\n            }\n            final FieldDescription other = (FieldDescription) obj;\n            if (!Objects.equals(this.name, other.name)) {\n                return false;\n            }\n            if (!Objects.equals(this.descriptor, other.descriptor)) {\n                return false;\n            }\n            if (!Objects.equals(this.constantValue, other.constantValue)) {\n                return false;\n            }\n            return true;\n        }\n        @Override\n        public void write(Appendable output, String baselineVersion, String version) throws IOException {\n            if (shouldIgnore(baselineVersion, version))\n                return ;\n            if (!versions.contains(version)) {\n                output.append(\"-field\");\n                output.append(\" name \" + quote(name, false));\n                output.append(\" descriptor \" + quote(descriptor, false));\n                output.append(\"\\n\");\n                return ;\n            }\n            output.append(\"field\");\n            output.append(\" name \" + name);\n            output.append(\" descriptor \" + descriptor);\n            if (constantValue != null) {\n                output.append(\" constantValue \" + quote(constantValue.toString(), false));\n            }\n            writeAttributes(output);\n            output.append(\"\\n\");\n        }\n        @Override\n        public boolean read(LineBasedReader reader) throws IOException {\n            if (!\"field\".equals(reader.lineKey))\n                return false;\n            name = reader.attributes.get(\"name\");\n            descriptor = reader.attributes.get(\"descriptor\");\n            String inConstantValue = reader.attributes.get(\"constantValue\");\n            if (inConstantValue != null) {\n                switch (descriptor) {\n                    case \"Z\": constantValue = \"true\".equals(inConstantValue); break;\n                    case \"B\": constantValue = Integer.parseInt(inConstantValue); break;\n                    case \"C\": constantValue = inConstantValue.charAt(0); break;\n                    case \"S\": constantValue = Integer.parseInt(inConstantValue); break;\n                    case \"I\": constantValue = Integer.parseInt(inConstantValue); break;\n                    case \"J\": constantValue = Long.parseLong(inConstantValue); break;\n                    case \"F\": constantValue = Float.parseFloat(inConstantValue); break;\n                    case \"D\": constantValue = Double.parseDouble(inConstantValue); break;\n                    case \"Ljava/lang/String;\": constantValue = inConstantValue; break;\n                    default:\n                        throw new IllegalStateException(\"Unrecognized field type: \" + descriptor);\n                }\n            }\n            readAttributes(reader);\n            reader.moveNext();\n            return true;\n        }\n    }\n    static final class AnnotationDescription {\n        String annotationType;\n        Map<String, Object> values;\n        public AnnotationDescription(String annotationType, Map<String, Object> values) {\n            this.annotationType = annotationType;\n            this.values = values;\n        }\n        @Override\n        public int hashCode() {\n            int hash = 7;\n            hash = 47 * hash + Objects.hashCode(this.annotationType);\n            hash = 47 * hash + Objects.hashCode(this.values);\n            return hash;\n        }\n<fim_suffix>        @Override\n        public boolean equals(Object obj) {\n            if (obj == null) {\n                return false;\n            }\n            if (getClass() != obj.getClass()) {\n                return false;\n            }\n            final AnnotationDescription other = (AnnotationDescription) obj;\n            if (!Objects.equals(this.annotationType, other.annotationType)) {\n                return false;\n            }\n            if (!Objects.equals(this.values, other.values)) {\n                return false;\n            }\n            return true;\n        }<fim_middle>// function below has no smell\n"}