{"text": "<fim_prefix>\t}\n\tprivate static final Class<?>[] EVENT_TYPES = { ApplicationStartingEvent.class,\n\t\t\tApplicationEnvironmentPreparedEvent.class, ApplicationPreparedEvent.class,\n\t\t\tContextClosedEvent.class, ApplicationFailedEvent.class };\n\tprivate static final Class<?>[] SOURCE_TYPES = { SpringApplication.class,\n\t\t\tApplicationContext.class };\n\tprivate static final AtomicBoolean shutdownHookRegistered = new AtomicBoolean(false);\n\tprivate final Log logger = LogFactory.getLog(getClass());\n\tprivate LoggingSystem loggingSystem;\n\tprivate int order = DEFAULT_ORDER;\n\tprivate boolean parseArgs = true;\n\tprivate LogLevel springBootLogging = null;\n\t@Override\n\tpublic boolean supportsEventType(ResolvableType resolvableType) {\n\t\treturn isAssignableFrom(resolvableType.getRawClass(), EVENT_TYPES);\n\t}\n\t@Override\n\tpublic boolean supportsSourceType(Class<?> sourceType) {\n\t\treturn isAssignableFrom(sourceType, SOURCE_TYPES);\n\t}\n\tprivate boolean isAssignableFrom(Class<?> type, Class<?>... supportedTypes) {\n\t\tif (type != null) {\n\t\t\tfor (Class<?> supportedType : supportedTypes) {\n\t\t\t\tif (supportedType.isAssignableFrom(type)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t@Override\n\tpublic void onApplicationEvent(ApplicationEvent event) {\n\t\tif (event instanceof ApplicationStartingEvent) {\n\t\t\tonApplicationStartingEvent((ApplicationStartingEvent) event);\n\t\t}\n\t\telse if (event instanceof ApplicationEnvironmentPreparedEvent) {\n\t\t\tonApplicationEnvironmentPreparedEvent(\n\t\t\t\t\t(ApplicationEnvironmentPreparedEvent) event);\n\t\t}\n\t\telse if (event instanceof ApplicationPreparedEvent) {\n\t\t\tonApplicationPreparedEvent((ApplicationPreparedEvent) event);\n\t\t}\n\t\telse if (event instanceof ContextClosedEvent && ((ContextClosedEvent) event)\n\t\t\t\t.getApplicationContext().getParent() == null) {\n\t\t\tonContextClosedEvent();\n\t\t}\n\t\telse if (event instanceof ApplicationFailedEvent) {\n\t\t\tonApplicationFailedEvent();\n\t\t}\n\t}\n\tprivate void onApplicationStartingEvent(ApplicationStartingEvent event) {\n\t\tthis.loggingSystem = LoggingSystem\n\t\t\t\t.get(event.getSpringApplication().getClassLoader());\n\t\tthis.loggingSystem.beforeInitialize();\n\t}\n\tprivate void onApplicationEnvironmentPreparedEvent(\n\t\t\tApplicationEnvironmentPreparedEvent event) {\n\t\tif (this.loggingSystem == null) {\n\t\t\tthis.loggingSystem = LoggingSystem\n\t\t\t\t\t.get(event.getSpringApplication().getClassLoader());\n\t\t}\n\t\tinitialize(event.getEnvironment(), event.getSpringApplication().getClassLoader());\n\t}\n\tprivate void onApplicationPreparedEvent(ApplicationPreparedEvent event) {\n\t\tConfigurableListableBeanFactory beanFactory = event.getApplicationContext()\n\t\t\t\t.getBeanFactory();\n\t\tif (!beanFactory.containsBean(LOGGING_SYSTEM_BEAN_NAME)) {\n\t\t\tbeanFactory.registerSingleton(LOGGING_SYSTEM_BEAN_NAME, this.loggingSystem);\n\t\t}\n\t}\n\tprivate void onContextClosedEvent() {\n\t\tif (this.loggingSystem != null) {\n\t\t\tthis.loggingSystem.cleanUp();\n\t\t}\n\t}\n\tprivate void onApplicationFailedEvent() {\n\t\tif (this.loggingSystem != null) {\n\t\t\tthis.loggingSystem.cleanUp();\n\t\t}\n\t}\n\t/**\n\t * Initialize the logging system according to preferences expressed through the\n\t * {@link Environment} and the classpath.\n\t * @param environment the environment\n\t * @param classLoader the classloader\n\t */\n\tprotected void initialize(ConfigurableEnvironment environment,\n\t\t\tClassLoader classLoader) {\n\t\tnew LoggingSystemProperties(environment).apply();\n\t\tLogFile logFile = LogFile.get(environment);\n\t\tif (logFile != null) {\n\t\t\tlogFile.applyToSystemProperties();\n\t\t}\n\t\tinitializeEarlyLoggingLevel(environment);\n\t\tinitializeSystem(environment, this.loggingSystem, logFile);\n\t\tinitializeFinalLoggingLevels(environment, this.loggingSystem);\n\t\tregisterShutdownHookIfNecessary(environment, this.loggingSystem);\n\t}\n\tprivate void initializeEarlyLoggingLevel(ConfigurableEnvironment environment) {\n\t\tif (this.parseArgs && this.springBootLogging == null) {\n\t\t\tif (isSet(environment, \"debug\")) {\n\t\t\t\tthis.springBootLogging = LogLevel.DEBUG;\n\t\t\t}\n\t\t\tif (isSet(environment, \"trace\")) {\n\t\t\t\tthis.springBootLogging = LogLevel.TRACE;\n\t\t\t}\n\t\t}\n\t}\n\tprivate boolean isSet(ConfigurableEnvironment environment, String property) {\n\t\tString value = environment.getProperty(property);\n\t\treturn (value != null && !value.equals(\"false\"));\n\t}\n\tprivate void initializeSystem(ConfigurableEnvironment environment,\n\t\t\tLoggingSystem system, LogFile logFile) {\n\t\tLoggingInitializationContext initializationContext = new LoggingInitializationContext(\n\t\t\t\tenvironment);\n\t\tString logConfig = environment.getProperty(CONFIG_PROPERTY);\n\t\tif (ignoreLogConfig(logConfig)) {\n\t\t\tsystem.initialize(initializationContext, null, logFile);\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\tResourceUtils.getURL(logConfig).openStream().close();\n\t\t\t\tsystem.initialize(initializationContext, logConfig, logFile);\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\t// NOTE: We can't use the logger here to report the problem\n\t\t\t\tSystem.err.println(\"Logging system failed to initialize \"\n\t\t\t\t\t\t+ \"using configuration from '\" + logConfig + \"'\");\n\t\t\t\tex.printStackTrace(System.err);\n\t\t\t\tthrow new IllegalStateException(ex);\n\t\t\t}\n\t\t}\n\t}\n\tprivate boolean ignoreLogConfig(String logConfig) {\n\t\treturn !StringUtils.hasLength(logConfig) || logConfig.startsWith(\"-D\");\n\t}\n\tprivate void initializeFinalLoggingLevels(ConfigurableEnvironment environment,\n\t\t\tLoggingSystem system) {\n\t\tif (this.springBootLogging != null) {\n\t\t\tinitializeLogLevel(system, this.springBootLogging);\n\t\t}\n\t\tsetLogLevels(system, environment);\n\t}\n\tprotected void initializeLogLevel(LoggingSystem system, LogLevel level) {\n\t\tLOG_LEVEL_LOGGERS.getOrDefault(level, Collections.emptyList()).stream()\n\t\t\t\t.flatMap((logger) -> DEFAULT_GROUP_LOGGERS\n\t\t\t\t\t\t.getOrDefault(logger, Collections.singletonList(logger)).stream())\n\t\t\t\t.forEach((logger) -> system.setLogLevel(logger, level));\n\t}\n\tprotected void setLogLevels(LoggingSystem system, Environment environment) {\n\t\tif (!(environment instanceof ConfigurableEnvironment)) {\n\t\t\treturn;\n\t\t}\n\t\tBinder binder = Binder.get(environment);\n\t\tMap<String, String[]> groups = getGroups();\n\t\tbinder.bind(LOGGING_GROUP, STRING_STRINGS_MAP.withExistingValue(groups));\n\t\tMap<String, String> levels = binder.bind(LOGGING_LEVEL, STRING_STRING_MAP)\n\t\t\t\t.orElseGet(Collections::emptyMap);\n\t\tlevels.forEach((name, level) -> {\n\t\t\tString[] groupedNames = groups.get(name);\n\t\t\tif (ObjectUtils.isEmpty(groupedNames)) {\n\t\t\t\tsetLogLevel(system, name, level);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsetLogLevel(system, groupedNames, level);\n\t\t\t}\n\t\t});\n\t}\n\tprivate Map<String, String[]> getGroups() {\n\t\tMap<String, String[]> groups = new LinkedHashMap<>();\n\t\tDEFAULT_GROUP_LOGGERS.forEach(\n\t\t\t\t(name, loggers) -> groups.put(name, StringUtils.toStringArray(loggers)));\n\t\treturn groups;\n\t}\n\tprivate void setLogLevel(LoggingSystem system, String[] names, String level) {\n\t\tfor (String name : names) {\n\t\t\tsetLogLevel(system, name, level);\n\t\t}\n\t}\n\tprivate void setLogLevel(LoggingSystem system, String name, String level) {\n\t\ttry {\n\t\t\tname = name.equalsIgnoreCase(LoggingSystem.ROOT_LOGGER_NAME) ? null : name;\n\t\t\tsystem.setLogLevel(name, coerceLogLevel(level));\n\t\t}\n\t\tcatch (RuntimeException ex) {\n\t\t\tthis.logger.error(\"Cannot set level '\" + level + \"' for '\" + name + \"'\");\n\t\t}\n\t}\n<fim_suffix>\tprivate LogLevel coerceLogLevel(String level) {\n\t\tString trimmedLevel = level.trim();\n\t\tif (\"false\".equalsIgnoreCase(trimmedLevel)) {\n\t\t\treturn LogLevel.OFF;\n\t\t}\n\t\treturn LogLevel.valueOf(trimmedLevel.toUpperCase(Locale.ENGLISH));\n\t}<fim_middle>// function below has no smell\n"}