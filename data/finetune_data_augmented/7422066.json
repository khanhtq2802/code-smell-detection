{"text": "<fim_prefix>/*\n * Copyright (c) 2017, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage com.oracle.truffle.tools.chromeinspector;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.Reader;\nimport java.nio.ByteBuffer;\nimport java.nio.CharBuffer;\nimport java.nio.channels.Channels;\nimport java.nio.channels.ReadableByteChannel;\n\npublic final class OutputHandler {\n\n    final ListeneableOutputStream out = new ListeneableOutputStream();\n    final ListeneableOutputStream err = new ListeneableOutputStream();\n\n    public OutputStream getOut() {\n        return out;\n    }\n\n    public OutputStream getErr() {\n        return err;\n    }\n\n    void setOutListener(Listener l) {\n        out.l = l;\n    }\n\n    void setErrListener(Listener l) {\n        err.l = l;\n    }\n\n    private static class ListeneableOutputStream extends OutputStream {\n\n        private final CharBuffer cb = CharBuffer.allocate(8192);\n        private final RBCH rbch = new RBCH();\n        private final Reader r = Channels.newReader(rbch, \"UTF-8\");\n        volatile Listener l;\n\n        @Override\n        public void write(int b) throws IOException {\n            rbch.put((byte) b);\n            wl();\n        }\n\n        @Override\n        public void write(byte[] b) throws IOException {\n            rbch.put(b);\n            wl();\n        }\n\n        @Override\n        public void write(byte[] b, int off, int len) throws IOException {\n            rbch.put(b, off, len);\n            wl();\n        }\n\n        private void wl() throws IOException {\n            if (l == null) {\n                return;\n            }\n            while (!rbch.isEmpty()) {\n                int n = r.read(cb);\n                if (n == 0) {\n                    break;\n                }\n                cb.flip();\n                String str = cb.toString();\n                l.outputText(str);\n                cb.clear();\n            }\n        }\n\n        private class RBCH implements ReadableByteChannel {\n\n            private byte[] b;\n            private int off;\n            private int len;\n\n            @SuppressWarnings(\"hiding\")\n            void put(int b) {\n                this.b = new byte[]{(byte) b};\n                this.off = 0;\n                this.len = 1;\n            }\n\n            @SuppressWarnings(\"hiding\")\n            void put(byte[] b) {\n                put(b, 0, b.length);\n            }\n\n            @SuppressWarnings(\"hiding\")\n            void put(byte[] b, int off, int len) {\n                this.b = b;\n                this.off = off;\n                this.len = len;\n            }\n\n            boolean isEmpty() {\n                return len == 0;\n            }\n\n            @Override\n            public int read(ByteBuffer dst) throws IOException {\n                if (len == 0) {\n                    return 0;\n                }\n                int n = dst.remaining();\n                n = Math.min(n, len);\n                dst.put(b, off, n);\n                off += n;\n                len -= n;\n                return n;\n            }\n\n<fim_suffix>            @Override\n            public boolean isOpen() {\n                return true;\n            }\n\n            @Override\n            public void close() throws IOException {\n            }\n\n        }\n    }\n\n    interface Listener {\n        void outputText(String str);\n    }\n\n    public interface Provider {\n        OutputHandler getOutputHandler();\n    }\n}<fim_middle>// function below has no smell\n"}