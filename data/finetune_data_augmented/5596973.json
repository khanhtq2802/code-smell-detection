{"text": "<fim_prefix>        return shapeRecords;\n    }\n    /**\n     * Utility method that calculates the minimum bounding rectangle that\n     * encloses a list of ShapeRecords, taking into account the possible maximum\n     * stroke width of any of the supplied linestyles.\n     * \n     * @return bounding box rectangle.\n     */\n    public static Rect getBounds(List<ShapeRecord> records, LineStyle ls, AbstractStrokeNode strokeNode)\n    {\n        if (records == null || records.size() == 0)\n        {\n            assert false: \"null records\";\n            return new Rect(0,0);\n        }\n        int x1 = 0;\n        int y1 = 0;\n        int x2 = 0;\n        int y2 = 0;\n        int x = 0;\n        int y = 0;\n        boolean firstMove = true;\n        Iterator<ShapeRecord> iterator = records.iterator();\n        while (iterator.hasNext())\n        {\n            ShapeRecord r = iterator.next();\n            if (r == null)\n                continue;\n            if (r instanceof StyleChangeRecord)\n            {\n                StyleChangeRecord scr = (StyleChangeRecord)r;\n                x = scr.getMoveDeltaX();\n                y = scr.getMoveDeltaY();\n                scr.setMove(x, y);\n                if (firstMove)\n                {\n                    x1 = x;\n                    y1 = y;\n                    x2 = x;\n                    y2 = y;\n                    firstMove = false;\n                }\n            }\n            else if (r instanceof StraightEdgeRecord)\n            {\n                StraightEdgeRecord ser = (StraightEdgeRecord)r;\n                x = x + ser.getDeltaX();\n                y = y + ser.getDeltaY();\n            }\n            else if (r instanceof CurvedEdgeRecord)\n            {\n                CurvedEdgeRecord cer = (CurvedEdgeRecord)r;\n                Rect currRect = new Rect(x1, x2, y1, y2);\n                if (!curveControlPointInsideCurrentRect(x, y, cer, currRect))\n                {                \n                \tRect curvBounds = computeCurveBounds(x, y, cer);\n                \tif (curvBounds.xMin() < x1) x1 = curvBounds.xMin();\n                \tif (curvBounds.yMin() < y1) y1 = curvBounds.yMin();\n                \tif (curvBounds.xMax() > x2) x2 = curvBounds.xMax();\n                \tif (curvBounds.yMax() > y2) y2 = curvBounds.yMax();\n                }\n                x = x + cer.getControlDeltaX() + cer.getAnchorDeltaX();\n                y = y + cer.getControlDeltaY() + cer.getAnchorDeltaY();\n            }\n            //update x1, y1 to min values and x2, y2 to max values\n            if (x < x1) x1 = x;\n            if (y < y1) y1 = y;\n            if (x > x2) x2 = x;\n            if (y > y2) y2 = y;\n        }\n        Rect newRect = new Rect(x1, x2, y1, y2);\n        if (ls == null)\n        {\n            return newRect;\n        }\n        // Inflate the bounding box from all sides with half of the stroke \n        // weight - pathBBox.inflate(weight/2, weight/2).\n        Rect strokeExtents = getStrokeExtents(strokeNode, ls);\n        newRect = new Rect(newRect.xMin() - strokeExtents.xMax(), newRect.xMax() + strokeExtents.xMax(), \n                newRect.yMin() - strokeExtents.yMax(), newRect.yMax() + strokeExtents.yMax());\n        // If there are less than two segments, then or joint style is not \n        //\"miterLimit\" finish - return pathBBox.\n        if (ls instanceof LineStyle2)\n        {\n            if (records.size() < 2 || ls == null || ((LineStyle2)ls).getJoinStyle() != LineStyle2.JS_MITER_JOIN)\n            {\n            \treturn newRect;\n            }\n        }\n        // Use strokeExtents to get the transformed stroke weight.\n        double halfWeight = (strokeExtents.xMax() - strokeExtents.xMin())/2.0;   \n        newRect = addJoint2Bounds(records, ls, strokeNode, halfWeight, newRect);\n        return newRect;\n    }\n    public static Rect addJoint2Bounds(List<ShapeRecord> records, LineStyle ls, AbstractStrokeNode stroke, double halfWeight, Rect pathBBox)\n    {\n        Rect newRect = pathBBox;\n        int count = records.size();\n\t    int start = 0;\n\t    int end = 0;\n\t    int lastMoveX = 0;\n\t    int lastMoveY = 0;\n\t    int lastOpenSegment = 0;\n\t    int x = 0, y = 0;\n        // Add miterLimit effect to the bounds.\n\t    double miterLimit = stroke.miterLimit;\n        // Miter limit is always at least 1\n        if (miterLimit < 1) miterLimit = 1;     \n        int[][] cooridinates = getCoordinates(records);\n        while (true)\n        {\n            // Find a segment with a valid tangent or stop at a MoveSegment\n            while (start < count && !(records.get(start) instanceof StyleChangeRecord))\n            {\n                x = cooridinates[start-1][0];\n                y = cooridinates[start-1][1];\n                if (tangentIsValid(records.get(start), x, y))\n                    break;\n                start++;\n            }\n            if (start >= count)\n                break; // No more segments with valid tangents\n            ShapeRecord startSegment = records.get(start);\n            if (startSegment instanceof StyleChangeRecord)\n            {\n                // remember the last move segment \n                lastOpenSegment = start + 1;\n                lastMoveX = ((StyleChangeRecord)startSegment).getMoveDeltaX();\n                lastMoveY = ((StyleChangeRecord)startSegment).getMoveDeltaY();\n                // move onto next segment:\n                start++;\n                continue;\n            }\n            // Does the current segment close to a previous segment and form a \n            // joint with it? \n            // Note, even if the segment was originally a close segment, \n            // it may not form a joint with the segment it closes to, unless \n            // it's followed by a MoveSegment or it's the last segment in the \n            // sequence.\n            int startSegmentX = cooridinates[start][0];\n            int startSegmentY = cooridinates[start][1];\n            if ((start == count - 1 || records.get(start + 1) instanceof StyleChangeRecord) && \n                    startSegmentX == lastMoveX &&\n                    startSegmentY == lastMoveY)\n            {\n                end = lastOpenSegment;\n            }\n            else\n            {\n                end = start + 1;\n            }\n            // Find a segment with a valid tangent or stop at a MoveSegment \n            while (end < count && !(records.get(end) instanceof StyleChangeRecord))\n            {       \n                if (tangentIsValid(records.get(end), startSegmentX, startSegmentY))\n                    break;\n                end++;\n            }\n            if (end >= count)\n                break; // No more segments with valid tangents\n            ShapeRecord endSegment = records.get(end);\n            if (!(endSegment instanceof StyleChangeRecord))\n            {\n                newRect = addMiterLimitStrokeToBounds(\n                                            startSegment,\n                                            endSegment, \n                                            miterLimit,\n                                            halfWeight,\n                                            newRect, x, y, startSegmentX, startSegmentY);\n            }\n            // Move on to the next segment, but never go back (end could be \n            // less than start, because of implicit/explicit CloseSegments)\n            start = start > end ? start + 1 : end;\n        }\n        return newRect;\n    }\n<fim_suffix>    private static int[][] getCoordinates(List<ShapeRecord> records)\n    {\n        int[][] coordinates = new int[records.size()][2];\n        ShapeRecord record;\n        for(int i=0; i<records.size(); i++)\n        {\n            record = records.get(i);\n            if (record instanceof StyleChangeRecord)\n            {\n                StyleChangeRecord scr = (StyleChangeRecord)record;\n                coordinates[i][0] = scr.getMoveDeltaX();\n                coordinates[i][1] = scr.getMoveDeltaY();\n            }\n            else if (record instanceof StraightEdgeRecord)\n            {\n                StraightEdgeRecord ser = (StraightEdgeRecord)record;\n                coordinates[i][0] = coordinates[i-1][0] + ser.getDeltaX();\n                coordinates[i][1] = coordinates[i-1][1] + ser.getDeltaY();\n            }\n            else if (record instanceof CurvedEdgeRecord)\n            {\n                CurvedEdgeRecord cer = (CurvedEdgeRecord)record;                    \n                coordinates[i][0] = coordinates[i-1][0] + cer.getControlDeltaX() + cer.getAnchorDeltaX();\n                coordinates[i][1] = coordinates[i-1][1] + cer.getControlDeltaY() + cer.getAnchorDeltaY();\n            }                  \n        }\n        return coordinates;\n    }<fim_middle>// function below has no smell\n"}