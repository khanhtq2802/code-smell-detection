{"text": "<fim_prefix>    for (Coder.Context context : ALL_CONTEXTS) {\n      coderDeterministicInContext(coder, context, value1, value2);\n    }\n  }\n  /**\n   * Verifies that for the given {@code Coder<T>}, {@code Coder.Context}, and values of type {@code\n   * T}, if the values are equal then the encoded bytes are equal.\n   */\n  public static <T> void coderDeterministicInContext(\n      Coder<T> coder, Coder.Context context, T value1, T value2) throws Exception {\n    try {\n      coder.verifyDeterministic();\n    } catch (NonDeterministicException e) {\n      throw new AssertionError(\"Expected that the coder is deterministic\", e);\n    }\n    assertThat(\"Expected that the passed in values are equal()\", value1, equalTo(value2));\n    assertThat(encode(coder, context, value1), equalTo(encode(coder, context, value2)));\n  }\n  /**\n   * Verifies that for the given {@code Coder<T>}, and value of type {@code T}, encoding followed by\n   * decoding yields an equal value of type {@code T}, in any {@code Coder.Context}.\n   */\n  public static <T> void coderDecodeEncodeEqual(Coder<T> coder, T value) throws Exception {\n    for (Coder.Context context : ALL_CONTEXTS) {\n      coderDecodeEncodeEqualInContext(coder, context, value);\n    }\n  }\n  /**\n   * Verifies that for the given {@code Coder<T>}, {@code Coder.Context}, and value of type {@code\n   * T}, encoding followed by decoding yields an equal value of type {@code T}.\n   */\n  public static <T> void coderDecodeEncodeEqualInContext(\n      Coder<T> coder, Coder.Context context, T value) throws Exception {\n    assertThat(decodeEncode(coder, context, value), equalTo(value));\n  }\n  /**\n   * Verifies that for the given {@code Coder<Collection<T>>}, and value of type {@code\n   * Collection<T>}, encoding followed by decoding yields an equal value of type {@code\n   * Collection<T>}, in any {@code Coder.Context}.\n   */\n  public static <T, CollectionT extends Collection<T>> void coderDecodeEncodeContentsEqual(\n      Coder<CollectionT> coder, CollectionT value) throws Exception {\n    for (Coder.Context context : ALL_CONTEXTS) {\n      coderDecodeEncodeContentsEqualInContext(coder, context, value);\n    }\n  }\n  /**\n   * Verifies that for the given {@code Coder<Collection<T>>}, and value of type {@code\n   * Collection<T>}, encoding followed by decoding yields an equal value of type {@code\n   * Collection<T>}, in the given {@code Coder.Context}.\n   */\n  @SuppressWarnings(\"unchecked\")\n  public static <T, CollectionT extends Collection<T>> void coderDecodeEncodeContentsEqualInContext(\n      Coder<CollectionT> coder, Coder.Context context, CollectionT value) throws Exception {\n    // Matchers.containsInAnyOrder() requires at least one element\n    Collection<T> result = decodeEncode(coder, context, value);\n    if (value.isEmpty()) {\n      assertThat(result, emptyIterable());\n    } else {\n      // This is the only Matchers.containInAnyOrder() overload that takes literal values\n      assertThat(result, containsInAnyOrder((T[]) value.toArray()));\n    }\n  }\n  /**\n   * Verifies that for the given {@code Coder<Collection<T>>}, and value of type {@code\n   * Collection<T>}, encoding followed by decoding yields an equal value of type {@code\n   * Collection<T>}, in any {@code Coder.Context}.\n   */\n  public static <T, IterableT extends Iterable<T>> void coderDecodeEncodeContentsInSameOrder(\n      Coder<IterableT> coder, IterableT value) throws Exception {\n    for (Coder.Context context : ALL_CONTEXTS) {\n      CoderProperties.coderDecodeEncodeContentsInSameOrderInContext(coder, context, value);\n    }\n  }\n  /**\n   * Verifies that for the given {@code Coder<Iterable<T>>}, and value of type {@code Iterable<T>},\n   * encoding followed by decoding yields an equal value of type {@code Collection<T>}, in the given\n   * {@code Coder.Context}.\n   */\n  @SuppressWarnings(\"unchecked\")\n  public static <T, IterableT extends Iterable<T>>\n      void coderDecodeEncodeContentsInSameOrderInContext(\n          Coder<IterableT> coder, Coder.Context context, IterableT value) throws Exception {\n    Iterable<T> result = decodeEncode(coder, context, value);\n    // Matchers.contains() requires at least one element\n    if (Iterables.isEmpty(value)) {\n      assertThat(result, emptyIterable());\n    } else {\n      // This is the only Matchers.contains() overload that takes literal values\n      assertThat(result, contains((T[]) Iterables.toArray(value, Object.class)));\n    }\n  }\n  /** Verifies that the given {@code Coder<T>} can be correctly serialized and deserialized. */\n  public static <T> void coderSerializable(Coder<T> coder) {\n    SerializableUtils.ensureSerializable(coder);\n  }\n  /**\n   * Verifies that for the given {@code Coder<T>} and values of type {@code T}, the values are equal\n   * if and only if the encoded bytes are equal.\n   */\n  public static <T> void coderConsistentWithEquals(Coder<T> coder, T value1, T value2)\n      throws Exception {\n    for (Coder.Context context : ALL_CONTEXTS) {\n      CoderProperties.coderConsistentWithEqualsInContext(coder, context, value1, value2);\n    }\n  }\n  /**\n   * Verifies that for the given {@code Coder<T>}, {@code Coder.Context}, and values of type {@code\n   * T}, the values are equal if and only if the encoded bytes are equal, in any {@code\n   * Coder.Context}.\n   */\n  public static <T> void coderConsistentWithEqualsInContext(\n      Coder<T> coder, Coder.Context context, T value1, T value2) throws Exception {\n    assertEquals(\n        value1.equals(value2),\n        Arrays.equals(encode(coder, context, value1), encode(coder, context, value2)));\n  }\n  /**\n   * Verifies that for the given {@code Coder<T>} and values of type {@code T}, the structural\n   * values are equal if and only if the encoded bytes are equal.\n   */\n  public static <T> void structuralValueConsistentWithEquals(Coder<T> coder, T value1, T value2)\n      throws Exception {\n    for (Coder.Context context : ALL_CONTEXTS) {\n      CoderProperties.structuralValueConsistentWithEqualsInContext(coder, context, value1, value2);\n    }\n  }\n  /**\n   * Verifies that for the given {@code Coder<T>}, {@code Coder.Context}, and values of type {@code\n   * T}, the structural values are equal if and only if the encoded bytes are equal, in any {@code\n   * Coder.Context}.\n   */\n  public static <T> void structuralValueConsistentWithEqualsInContext(\n      Coder<T> coder, Coder.Context context, T value1, T value2) throws Exception {\n    assertEquals(\n        coder.structuralValue(value1).equals(coder.structuralValue(value2)),\n        Arrays.equals(encode(coder, context, value1), encode(coder, context, value2)));\n  }\n  /**\n   * Verifies that for the given {@code Coder<T>} and value of type {@code T}, the structural value\n   * is equal to the structural value yield by encoding and decoding the original value.\n   *\n   * <p>This is useful to test the correct implementation of a Coder structural equality with values\n   * that don't implement the equals contract.\n   */\n  public static <T> void structuralValueDecodeEncodeEqual(Coder<T> coder, T value)\n      throws Exception {\n    for (Coder.Context context : ALL_CONTEXTS) {\n      CoderProperties.structuralValueDecodeEncodeEqualInContext(coder, context, value);\n    }\n  }\n  /**\n   * Verifies that for the given {@code Coder<T>}, {@code Coder.Context}, and value of type {@code\n   * T}, the structural value is equal to the structural value yield by encoding and decoding the\n   * original value, in any {@code Coder.Context}.\n   */\n<fim_suffix>  public static <T> void structuralValueDecodeEncodeEqualInContext(\n      Coder<T> coder, Coder.Context context, T value) throws Exception {\n    assertEquals(\n        coder.structuralValue(value), coder.structuralValue(decodeEncode(coder, context, value)));\n  }<fim_middle>// function below has no smell\n"}