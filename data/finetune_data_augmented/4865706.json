{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.pinot.thirdeye.dataframe;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport org.apache.commons.math.stat.correlation.Covariance;\nimport org.apache.commons.math.stat.correlation.PearsonsCorrelation;\n/**\n * Series container for primitive double.\n */\npublic final class DoubleSeries extends TypedSeries<DoubleSeries> {\n  public static final double NULL = Double.NaN;\n  public static final double INFINITY = Double.POSITIVE_INFINITY;\n  public static final double POSITIVE_INFINITY = Double.POSITIVE_INFINITY;\n  public static final double NEGATIVE_INFINITY = Double.NEGATIVE_INFINITY;\n  public static final double DEFAULT = 0.0d;\n  public static final double MIN_VALUE = Double.MIN_VALUE;\n  public static final double MAX_VALUE = Double.MAX_VALUE;\n  public static final DoubleFunction SUM = new DoubleSum();\n  public static final DoubleFunction PRODUCT = new DoubleProduct();\n  public static final DoubleFunction FIRST = new DoubleFirst();\n  public static final DoubleFunction LAST = new DoubleLast();\n  public static final DoubleFunction MIN = new DoubleMin();\n  public static final DoubleFunction MAX = new DoubleMax();\n  public static final DoubleFunction MEAN = new DoubleMean();\n  public static final DoubleFunction MEDIAN = new DoubleMedian();\n  public static final DoubleFunction STD = new DoubleStandardDeviation();\n  public static final DoubleFunction NEGATIVE = new DoubleNegative();\n  public static final class DoubleSum implements DoubleFunction {\n    @Override\n    public double apply(double[] values) {\n      if(values.length <= 0)\n        return NULL;\n      // TODO sort, add low to high for accuracy?\n      double result = 0.0d;\n      for(double v : values)\n        result += v;\n      return result;\n    }\n  }\n  public static final class DoubleProduct implements DoubleFunction {\n    @Override\n    public double apply(double[] values) {\n      if(values.length <= 0)\n        return NULL;\n      // TODO sort for accuracy?\n      double result = 1.0d;\n      for(double v : values)\n        result *= v;\n      return result;\n    }\n  }\n  public static final class DoubleMean implements DoubleFunction {\n    @Override\n    public double apply(double[] values) {\n      if(values.length <= 0)\n        return NULL;\n      // TODO sort, add low to high for accuracy?\n      double sum = 0.0d;\n      int count = 0;\n      for(double v : values) {\n        sum += v;\n        count++;\n      }\n      return sum / count;\n    }\n  }\n  public static final class DoubleMedian implements DoubleFunction {\n    @Override\n    public double apply(double[] values) {\n      if(values.length <= 0)\n        return NULL;\n      values = Arrays.copyOf(values, values.length);\n      Arrays.sort(values);\n      // odd N, return mid\n      if(values.length % 2 == 1)\n        return values[values.length / 2];\n      // even N, return mean of mid\n      return (values[values.length / 2 - 1] + values[values.length / 2]) / 2;\n    }\n  }\n  public static final class DoubleFirst implements DoubleFunction {\n    @Override\n    public double apply(double[] values) {\n      if(values.length <= 0)\n        return NULL;\n      return values[0];\n    }\n  }\n  public static final class DoubleLast implements DoubleFunction {\n    @Override\n    public double apply(double[] values) {\n      if(values.length <= 0)\n        return NULL;\n      return values[values.length - 1];\n    }\n  }\n  public static final class DoubleMin implements DoubleFunction {\n    @Override\n    public double apply(double[] values) {\n      if(values.length <= 0)\n        return NULL;\n      double min = values[0];\n      for(double v : values)\n        min = Math.min(min, v);\n      return min;\n    }\n  }\n  public static final class DoubleMax implements DoubleFunction {\n    @Override\n    public double apply(double[] values) {\n      if (values.length <= 0)\n        return NULL;\n      double max = values[0];\n      for (double v : values)\n        max = Math.max(max, v);\n      return max;\n    }\n  }\n  public static final class DoubleNegative implements DoubleFunction {\n    @Override\n    public double apply(double... values) {\n      if(values.length <= 0)\n        return NULL;\n      return -values[0];\n    }\n  }\n<fim_suffix>  public static final class DoubleStandardDeviation implements DoubleFunction {\n    @Override\n    public double apply(double... values) {\n      if(values.length <= 1)\n        return NULL;\n      double mean = MEAN.apply(values);\n      double var = 0.0;\n      for(double v : values)\n        var += (v - mean) * (v - mean);\n      return Math.sqrt(var / (values.length - 1));\n    }\n  }\n  public static final class DoubleMapZScore implements DoubleFunction {\n    final double mean;\n    final double std;\n    public DoubleMapZScore(double mean, double std) {\n      if(std <= 0.0d)\n        throw new IllegalArgumentException(\"std must be greater than 0\");\n      this.mean = mean;\n      this.std = std;\n    }\n    @Override\n    public double apply(double... values) {\n      return (values[0] - this.mean) / this.std;\n    }\n  }\n  public static final class DoubleMapNormalize implements DoubleFunction {\n    final double min;\n    final double max;\n    public DoubleMapNormalize(double min, double max) {\n      if(min == max)\n        throw new IllegalArgumentException(\"min and max must be different\");\n      this.min = min;\n      this.max = max;\n    }\n    @Override\n    public double apply(double... values) {\n      return (values[0] - this.min) / (this.max - this.min);\n    }\n  }\n  public static final class DoubleQuantile implements DoubleFunction {\n    final double q;\n    public DoubleQuantile(double q) {\n      if (q < 0 || q > 1.0)\n        throw new IllegalArgumentException(String.format(\"q must be between 0.0 and 1.0, but was %f\", q));\n      this.q = q;\n    }\n    @Override\n    public double apply(double... values) {\n      if (values.length <= 0)\n        return NULL;\n      values = Arrays.copyOf(values, values.length);\n      Arrays.sort(values);\n      double index = (values.length - 1) * this.q;\n      int lo = (int) Math.floor(index);\n      int hi = (int) Math.ceil(index);\n      double diff = values[hi] - values[lo];\n      return values[lo] + diff * (index - lo);\n    }\n  }\n  public static class Builder extends Series.Builder {\n    final List<double[]> arrays = new ArrayList<>();\n    private Builder() {\n      // left blank\n    }\n    public Builder addValues(double... values) {\n      this.arrays.add(values);\n      return this;\n    }\n    public Builder addValues(double value) {\n      return this.addValues(new double[] { value });\n    }\n    public Builder addValues(Collection<Double> values) {\n      double[] newValues = new double[values.size()];\n      int i = 0;\n      for(Double v : values)\n        newValues[i++] = valueOf(v);\n      return this.addValues(newValues);\n    }\n    public Builder addValues(Double... values) {\n      return this.addValues(Arrays.asList(values));\n    }\n    public Builder addValues(Double value) {\n      return this.addValues(new double[] { valueOf(value) });\n    }\n    public Builder fillValues(int count, double value) {\n      double[] values = new double[count];\n      Arrays.fill(values, value);\n      return this.addValues(values);\n    }\n    public Builder fillValues(int count, Double value) {\n      return this.fillValues(count, valueOf(value));\n    }\n    @Override<fim_middle>// class below has no smell\n"}