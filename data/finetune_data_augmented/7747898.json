{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.brooklyn.entity.webapp.jboss;\nimport static java.lang.String.format;\nimport static org.apache.brooklyn.util.text.Strings.isEmpty;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.brooklyn.core.entity.Attributes;\nimport org.apache.brooklyn.core.entity.Entities;\nimport org.apache.brooklyn.entity.java.UsesJmx;\nimport org.apache.brooklyn.entity.java.UsesJmx.JmxAgentModes;\nimport org.apache.brooklyn.entity.webapp.JavaWebAppSshDriver;\nimport org.apache.brooklyn.location.ssh.SshMachineLocation;\nimport org.apache.brooklyn.util.collections.MutableList;\nimport org.apache.brooklyn.util.collections.MutableMap;\nimport org.apache.brooklyn.util.net.Networking;\nimport org.apache.brooklyn.util.os.Os;\nimport org.apache.brooklyn.util.ssh.BashCommands;\npublic class JBoss6SshDriver extends JavaWebAppSshDriver implements JBoss6Driver {\n    public static final String SERVER_TYPE = \"standard\";\n    public static final int DEFAULT_HTTP_PORT = 8080;\n    private static final String PORT_GROUP_NAME = \"ports-brooklyn\";\n    public JBoss6SshDriver(JBoss6ServerImpl entity, SshMachineLocation machine) {\n        super(entity, machine);\n    }\n    @Override\n    public JBoss6ServerImpl getEntity() {\n        return (JBoss6ServerImpl) super.getEntity();\n    }\n    protected String getLogFileLocation() {\n        return Os.mergePathsUnix(getRunDir(), \"server\", SERVER_TYPE, \"log/server.log\");\n    }\n    protected String getDeploySubdir() {\n        return Os.mergePathsUnix(\"server\", SERVER_TYPE, \"deploy\");\n    } // FIXME what is this in as6?\n    protected String getBindAddress() {\n        return entity.getAttribute(JBoss6Server.BIND_ADDRESS);\n    }\n<fim_suffix>    protected Integer getPortIncrement() {\n        return entity.getAttribute(JBoss6Server.PORT_INCREMENT);\n    }\n    protected String getClusterName() {\n        return entity.getAttribute(JBoss6Server.CLUSTER_NAME);\n    }\n    // FIXME Should this pattern be used elsewhere? How?\n    @Override\n    public String getExpandedInstallDir() {\n        // Ensure never returns null, so if stop called even if install/start was not then don't throw exception.\n        String result = super.getExpandedInstallDir();\n        return (result != null) ? result : getInstallDir()+\"/\" + \"jboss-\"+getVersion();\n    }\n    @Override\n    public void postLaunch() {\n        entity.sensors().set(JBoss6Server.HTTP_PORT, DEFAULT_HTTP_PORT + getPortIncrement());\n        super.postLaunch();\n    }\n    @Override\n    public void preInstall() {\n        resolver = Entities.newDownloader(this);\n        setExpandedInstallDir(Os.mergePaths(getInstallDir(), resolver.getUnpackedDirectoryName(format(\"jboss-%s\", getVersion()))));\n    }\n    @Override\n    public void install() {\n        List<String> urls = resolver.getTargets();\n        String saveAs = resolver.getFilename();\n        // Note the -o option to unzip, to overwrite existing files without warning.\n        // The JBoss zip file contains lgpl.txt (at least) twice and the prompt to\n        // overwrite interrupts the installer.\n        List<String> commands = new LinkedList<String>();\n        commands.addAll(BashCommands.commandsToDownloadUrlsAs(urls, saveAs));\n        commands.add(BashCommands.INSTALL_UNZIP);\n        commands.add(format(\"unzip -o %s\",saveAs));\n        newScript(INSTALLING)\n                .body.append(commands)\n                .execute();\n    }\n    @Override\n    public void customize() {\n        newScript(CUSTOMIZING)\n                .body.append(\n                        format(\"mkdir -p %s/server\", getRunDir()),\n                        format(\"cd %s/server\", getRunDir()),\n                        format(\"cp -r %s/server/%s %s\", getExpandedInstallDir(), SERVER_TYPE, SERVER_TYPE),\n                        format(\"cd %s/conf/bindingservice.beans/META-INF/\",SERVER_TYPE),\n                        \"BJB=\\\"bindings-jboss-beans.xml\\\"\",\n                        format(\"sed -i.bk 's/ports-03/%s/' $BJB\",PORT_GROUP_NAME),\n                        format(\"sed -i.bk 's/<parameter>300<\\\\/parameter>/<parameter>%s<\\\\/parameter>/' $BJB\",getPortIncrement())\n                )\n                .execute();\n        getEntity().deployInitialWars();\n    }\n    @Override\n    public void launch() {\n        Map<String,Integer> ports = new HashMap<String, Integer>();\n        ports.put(\"httpPort\",getHttpPort());\n        if (isJmxEnabled()) ports.put(\"jmxPort\",getJmxPort());\n        Networking.checkPortsValid(ports);\n        String clusterArg = isEmpty(getClusterName()) ? \"\":\"-g \"+getClusterName();\n        // run.sh must be backgrounded otherwise the script will never return.\n        // Don't automatically create pid; instead set JBOSS_PIDFILE to create the pid file we need\n        // We wait for evidence of tomcat running because, using SshCliTool,\n        // we saw the ssh session return before the tomcat process was fully running \n        // so the process failed to start.\n        newScript(MutableMap.of(USE_PID_FILE, false), LAUNCHING)\n                .body.append(\n                        format(\"export JBOSS_CLASSPATH=%s/lib/jboss-logmanager.jar\",getExpandedInstallDir()),\n                        format(\"export JBOSS_PIDFILE=%s/%s\", getRunDir(), PID_FILENAME),\n                        format(\"%s/bin/run.sh -Djboss.service.binding.set=%s -Djboss.server.base.dir=$RUN_DIR/server \",getExpandedInstallDir(),PORT_GROUP_NAME) +\n                                format(\"-Djboss.server.base.url=file://$RUN_DIR/server -Djboss.messaging.ServerPeerID=%s \",entity.getId())+\n                                format(\"-Djboss.boot.server.log.dir=%s/server/%s/log \",getRunDir(),SERVER_TYPE) +\n                                format(\"-b %s %s -c %s \", getBindAddress(), clusterArg,SERVER_TYPE) +\n                                \">>$RUN_DIR/console 2>&1 </dev/null &\",\n                        \"for i in {1..10}\\n\" +\n                                \"do\\n\" +\n                                \"    grep -i 'starting' \"+getRunDir()+\"/console && exit\\n\" +\n                                \"    sleep 1\\n\" +\n                                \"done\\n\" +\n                                \"echo \\\"Couldn't determine if process is running (console output does not contain 'starting'); continuing but may subsequently fail\\\"\"\n                    )\n                .execute();\n    }\n    @Override\n    public boolean isRunning() {\n        JmxAgentModes jmxMode = entity.getConfig(UsesJmx.JMX_AGENT_MODE);\n        if (jmxMode == JmxAgentModes.JMX_RMI_CUSTOM_AGENT) {\n            String host = entity.getAttribute(Attributes.HOSTNAME);\n            Integer port = entity.getAttribute(UsesJmx.RMI_REGISTRY_PORT);\n            List<String> checkRunningScript = new LinkedList<String>();\n            checkRunningScript.add(\n                    format(\"%s/bin/twiddle.sh --host %s --port %s get \\\"jboss.system:type=Server\\\" Started | grep true || exit 1\",\n                            getExpandedInstallDir(), host, port));\n            //have to override the CLI/JMX options\n            Map<String, Object> flags = new LinkedHashMap<String, Object>();\n            flags.put(\"env\", new LinkedHashMap<String, String>());\n            int result = execute(flags, checkRunningScript, \"checkRunning \" + entity + \" on \" + getMachine());\n            if (result == 0) return true;\n            if (result == 1) return false;<fim_middle>// function below has no smell\n"}