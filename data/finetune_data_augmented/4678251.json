{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.flink.api.common.typeutils;\n\nimport org.apache.flink.annotation.Internal;\nimport org.apache.flink.core.memory.DataInputView;\nimport org.apache.flink.core.memory.DataOutputView;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.concurrent.atomic.AtomicReference;\n\n<fim_suffix>@Internal\npublic class SingleThreadAccessCheckingTypeSerializer<T> extends TypeSerializer<T> {\n\tprivate static final long serialVersionUID = 131020282727167064L;\n\n\tprivate final SingleThreadAccessChecker singleThreadAccessChecker;\n\tprivate final TypeSerializer<T> originalSerializer;\n\n\tpublic SingleThreadAccessCheckingTypeSerializer(TypeSerializer<T> originalSerializer) {\n\t\tthis.singleThreadAccessChecker = new SingleThreadAccessChecker();\n\t\tthis.originalSerializer = originalSerializer;\n\t}\n\n\t@Override\n\tpublic boolean isImmutableType() {\n\t\ttry (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) {\n\t\t\treturn originalSerializer.isImmutableType();\n\t\t}\n\t}\n\n\t@Override\n\tpublic TypeSerializer<T> duplicate() {\n\t\ttry (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) {\n\t\t\treturn new SingleThreadAccessCheckingTypeSerializer<>(originalSerializer.duplicate());\n\t\t}\n\t}\n\n\t@Override\n\tpublic T createInstance() {\n\t\ttry (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) {\n\t\t\treturn originalSerializer.createInstance();\n\t\t}\n\t}\n\n\t@Override\n\tpublic T copy(T from) {\n\t\ttry (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) {\n\t\t\treturn originalSerializer.copy(from);\n\t\t}\n\t}\n\n\t@Override\n\tpublic T copy(T from, T reuse) {\n\t\ttry (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) {\n\t\t\treturn originalSerializer.copy(from, reuse);\n\t\t}\n\t}\n\n\t@Override\n\tpublic int getLength() {\n\t\ttry (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) {\n\t\t\treturn originalSerializer.getLength();\n\t\t}\n\t}\n\n\t@Override\n\tpublic void serialize(T record, DataOutputView target) throws IOException {\n\t\ttry (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) {\n\t\t\toriginalSerializer.serialize(record, target);\n\t\t}\n\t}\n\n\t@Override\n\tpublic T deserialize(DataInputView source) throws IOException {\n\t\ttry (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) {\n\t\t\treturn originalSerializer.deserialize(source);\n\t\t}\n\t}\n\n\t@Override\n\tpublic T deserialize(T reuse, DataInputView source) throws IOException {\n\t\ttry (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) {\n\t\t\treturn originalSerializer.deserialize(reuse, source);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void copy(DataInputView source, DataOutputView target) throws IOException {\n\t\ttry (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) {\n\t\t\toriginalSerializer.copy(source, target);\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\ttry (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) {\n\t\t\treturn obj == this ||\n\t\t\t\t(obj != null && obj.getClass() == getClass() &&\n\t\t\t\t\toriginalSerializer.equals(obj));\n\t\t}\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\ttry (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) {\n\t\t\treturn originalSerializer.hashCode();\n\t\t}\n\t}\n\n\t@Override\n\tpublic TypeSerializerSnapshot<T> snapshotConfiguration() {\n\t\ttry (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) {\n\t\t\treturn new SingleThreadAccessCheckingTypeSerializerSnapshot<>(this);\n\t\t}\n\t}\n\n\tpublic static class SingleThreadAccessCheckingTypeSerializerSnapshot<T>\n\t\textends CompositeTypeSerializerSnapshot<T, SingleThreadAccessCheckingTypeSerializer<T>> {\n\n\t\t@SuppressWarnings({\"unchecked\", \"unused\"})\n\t\tpublic SingleThreadAccessCheckingTypeSerializerSnapshot() {\n\t\t\tsuper((Class<SingleThreadAccessCheckingTypeSerializer<T>>) (Class<?>) SingleThreadAccessCheckingTypeSerializer.class);\n\t\t}\n\n\t\tSingleThreadAccessCheckingTypeSerializerSnapshot(SingleThreadAccessCheckingTypeSerializer<T> serializerInstance) {\n\t\t\tsuper(serializerInstance);\n\t\t}\n\n\t\t@Override\n\t\tprotected int getCurrentOuterSnapshotVersion() {\n\t\t\treturn 1;\n\t\t}\n\n\t\t@Override\n\t\tprotected TypeSerializer<?>[] getNestedSerializers(SingleThreadAccessCheckingTypeSerializer<T> outerSerializer) {\n\t\t\treturn new TypeSerializer[] { outerSerializer.originalSerializer };\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\t@Override\n\t\tprotected SingleThreadAccessCheckingTypeSerializer<T> createOuterSerializerWithNestedSerializers(\n\t\t\tTypeSerializer<?>[] nestedSerializers) {\n\n\t\t\treturn new SingleThreadAccessCheckingTypeSerializer<>((TypeSerializer<T>) nestedSerializers[0]);\n\t\t}\n\t}\n\n\tprivate void writeObject(ObjectOutputStream outputStream) throws IOException {\n\t\ttry (SingleThreadAccessCheck ignored = singleThreadAccessChecker.startSingleThreadAccessCheck()) {\n\t\t\toutputStream.defaultWriteObject();\n\t\t}\n\t}\n\n\tprivate static class SingleThreadAccessChecker implements Serializable {\n\t\tprivate static final long serialVersionUID = 131020282727167064L;\n\n\t\tprivate transient AtomicReference<Thread> currentThreadRef = new AtomicReference<>();\n\n\t\tSingleThreadAccessCheck startSingleThreadAccessCheck() {\n\t\t\tassert(currentThreadRef.compareAndSet(null, Thread.currentThread())) :\n\t\t\t\t\"The checker has concurrent access from \" + currentThreadRef.get();\n\t\t\treturn new SingleThreadAccessCheck(currentThreadRef);\n\t\t}\n\n\t\tprivate void readObject(ObjectInputStream inputStream) throws ClassNotFoundException, IOException {\n\t\t\tinputStream.defaultReadObject();\n\t\t\tcurrentThreadRef = new AtomicReference<>();\n\t\t}\n\t}\n\n\tprivate static class SingleThreadAccessCheck implements AutoCloseable {\n\t\tprivate final AtomicReference<Thread> currentThreadRef;\n\n\t\tprivate SingleThreadAccessCheck(AtomicReference<Thread> currentThreadRef) {\n\t\t\tthis.currentThreadRef = currentThreadRef;\n\t\t}\n\n\t\t@Override\n\t\tpublic void close() {\n\t\t\tassert(currentThreadRef.compareAndSet(Thread.currentThread(), null)) :\n\t\t\t\t\"The checker has concurrent access from \" + currentThreadRef.get();\n\t\t}\n\t}\n}<fim_middle>// class below is blob\n"}