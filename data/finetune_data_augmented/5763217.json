{"text": "<fim_prefix>    private static final String CONNECTOR_TEST_TIMEOUT_PARAMETER = \"connector.test.timeout\";\n    private Integer connectorTestTimeout = null;\n    private static final String RESOURCE_TEST_TIMEOUT_PARAMETER = \"resource.test.timeout\";\n    private Integer resourceTestTimeout = null;\n    private final Set<String> runningResCheck = Collections.synchronizedSet(new HashSet<>());\n    private final Map<String, String> connectors = Collections.<String, String>synchronizedMap(new HashMap<>());\n    private final Set<String> runningConnCheck = Collections.synchronizedSet(new HashSet<>());\n    private final ConnectorRestClient connectorRestClient = new ConnectorRestClient();\n    private final ResourceRestClient resourceRestClient = new ResourceRestClient();\n    public TopologyWebSocketBehavior() {\n        // Handling with timeout as per SYNCOPE-1379\n        try {\n            // Loop just to avoid NotFound exception raising on the Core side\n            for (Attr param : new ConfRestClient().list()) {\n                if (!CollectionUtils.isEmpty(param.getValues())) {\n                    try {\n                        if (CONNECTOR_TEST_TIMEOUT_PARAMETER.equalsIgnoreCase(param.getSchema())) {\n                            connectorTestTimeout = Integer.parseInt(param.getValues().get(0));\n                        } else if (RESOURCE_TEST_TIMEOUT_PARAMETER.equalsIgnoreCase(param.getSchema())) {\n                            resourceTestTimeout = Integer.parseInt(param.getValues().get(0));\n                        }\n                    } catch (NumberFormatException e) {\n                        LOG.warn(\"Invalid timeout {}\", param);\n                    }\n                }\n            }\n        } catch (SyncopeClientException e) {\n            // ignore exception\n        }\n    }\n    @Override\n    protected void onMessage(final WebSocketRequestHandler handler, final TextMessage message) {\n        try {\n            JsonNode obj = OBJECT_MAPPER.readTree(message.getText());\n            switch (Topology.SupportedOperation.valueOf(obj.get(\"kind\").asText())) {\n                case CHECK_CONNECTOR:\n                    final String ckey = obj.get(\"target\").asText();\n                    if (connectors.containsKey(ckey)) {\n                        handler.push(connectors.get(ckey));\n                    } else {\n                        handler.push(String.format(\n                                \"{ \\\"status\\\": \\\"%s\\\", \\\"target\\\": \\\"%s\\\"}\", TopologyNode.Status.UNKNOWN, ckey));\n                    }\n                    if (runningConnCheck.contains(ckey)) {\n                        LOG.debug(\"Running connection check for connector {}\", ckey);\n                    } else {\n                        runningConnCheck.add(ckey);\n                    }\n                    try {\n                        SyncopeConsoleSession.get().execute(new ConnCheck(ckey));\n                    } catch (Exception e) {\n                        LOG.error(\"Unexpected error\", e);\n                    }\n                    break;\n                case CHECK_RESOURCE:\n                    final String rkey = obj.get(\"target\").asText();\n                    if (resources.containsKey(rkey)) {\n                        handler.push(resources.get(rkey));\n                    } else {\n                        handler.push(String.format(\n                                \"{ \\\"status\\\": \\\"%s\\\", \\\"target\\\": \\\"%s\\\"}\", TopologyNode.Status.UNKNOWN, rkey));\n                    }\n                    if (runningResCheck.contains(rkey)) {\n                        LOG.debug(\"Running connection check for resource {}\", rkey);\n                    } else {\n                        runningResCheck.add(rkey);\n                    }\n                    try {\n                        SyncopeConsoleSession.get().execute(new ResCheck(rkey));\n                    } catch (Exception e) {\n                        LOG.error(\"Unexpected error\", e);\n                    }\n                    break;\n                case ADD_ENDPOINT:\n                    handler.appendJavaScript(String.format(\"addEndpoint('%s', '%s', '%s');\",\n                            obj.get(\"source\").asText(),\n                            obj.get(\"target\").asText(),\n                            obj.get(\"scope\").asText()));\n                    break;\n                default:\n            }\n        } catch (IOException e) {\n            LOG.error(\"Eror managing websocket message\", e);\n        }\n    }\n    public boolean connCheckDone(final Collection<String> connectors) {\n        return this.connectors.keySet().containsAll(connectors);\n    }\n    public boolean resCheckDone(final Collection<String> resources) {\n        return this.resources.keySet().containsAll(resources);\n    }\n    private void timeoutHandlingConnectionChecker(\n            final Checker checker,\n            final Integer timeout,\n            final Map<String, String> responses,\n            final Set<String> running) {\n        String res = null;\n        try {\n            if (timeout == null) {\n                LOG.debug(\"No timeouts for resource connection checking ... \");\n                res = SyncopeConsoleSession.get().execute(checker).get();\n            } else if (timeout > 0) {\n                LOG.debug(\"Timeouts provided for resource connection checking ... \");\n                res = SyncopeConsoleSession.get().execute(checker).get(timeout, TimeUnit.SECONDS);\n            }\n        } catch (InterruptedException | TimeoutException e) {\n            LOG.warn(\"Connection with {} timed out\", checker.getKey());\n            res = String.format(\"{ \\\"status\\\": \\\"%s\\\", \\\"target\\\": \\\"%s\\\"}\",\n                    TopologyNode.Status.UNREACHABLE, checker.getKey());\n        } catch (Exception e) {\n            LOG.error(\"Unexpected exception conneting to {}\", checker.getKey(), e);\n            res = String.format(\"{ \\\"status\\\": \\\"%s\\\", \\\"target\\\": \\\"%s\\\"}\",\n                    TopologyNode.Status.FAILURE, checker.getKey());\n        }\n        if (res != null) {\n            responses.put(checker.getKey(), res);\n        }\n        running.remove(checker.getKey());\n    }\n    class ConnCheck implements Runnable {\n        private final String key;\n        private final Application application;\n        private final Session session;\n        ConnCheck(final String key) {\n            this.key = key;\n            this.application = Application.get();\n            this.session = Session.exists() ? Session.get() : null;\n        }\n        @Override\n        public void run() {\n            ThreadContext.setApplication(application);\n            ThreadContext.setSession(session);\n            try {\n                timeoutHandlingConnectionChecker(\n                        new ConnectorChecker(key, this.application),\n                        connectorTestTimeout,\n                        connectors,\n                        runningConnCheck);\n            } finally {\n                ThreadContext.detach();\n            }\n        }\n    }\n    class ResCheck implements Runnable {\n        private final String key;\n        private final Application application;\n        private final Session session;\n        ResCheck(final String key) {\n            this.key = key;\n            this.application = Application.get();\n            this.session = Session.exists() ? Session.get() : null;\n        }\n        @Override\n        public void run() {\n            ThreadContext.setApplication(application);\n            ThreadContext.setSession(session);\n            try {\n                timeoutHandlingConnectionChecker(\n                        new ResourceChecker(key, this.application),\n                        resourceTestTimeout,\n                        resources,\n                        runningResCheck);\n            } finally {\n                ThreadContext.detach();\n            }\n        }\n    }\n    abstract class Checker implements Callable<String> {\n        protected final String key;\n        protected final Application application;\n        protected final Session session;\n        Checker(final String key, final Application application) {\n            this.key = key;\n            this.application = application;\n            this.session = Session.exists() ? Session.get() : null;\n        }\n        public String getKey() {\n            return key;\n        }\n        @Override\n        public abstract String call() throws Exception;\n    }\n    class ConnectorChecker extends Checker {\n        ConnectorChecker(final String key, final Application application) {\n            super(key, application);\n        }\n        @Override\n        public String call() throws Exception {\n            ThreadContext.setApplication(application);\n            ThreadContext.setSession(session);\n            try {\n                final ConnInstanceTO connector = connectorRestClient.read(key);\n                return String.format(\"{ \\\"status\\\": \\\"%s\\\", \\\"target\\\": \\\"%s\\\"}\",\n                        connectorRestClient.check(connector).getLeft()\n                        ? TopologyNode.Status.REACHABLE : TopologyNode.Status.UNREACHABLE, key);\n            } catch (Exception e) {\n                LOG.warn(\"Error checking connection for {}\", key, e);\n                return String.format(\"{ \\\"status\\\": \\\"%s\\\", \\\"target\\\": \\\"%s\\\"}\",\n                        TopologyNode.Status.FAILURE, key);\n            } finally {\n                ThreadContext.detach();\n            }\n        }\n    }\n    class ResourceChecker extends Checker {\n        ResourceChecker(final String key, final Application application) {\n            super(key, application);\n        }\n<fim_suffix>        @Override\n        public String call() throws Exception {\n            ThreadContext.setApplication(application);\n            ThreadContext.setSession(session);\n            try {\n                final ResourceTO resource = resourceRestClient.read(key);\n                return String.format(\"{ \\\"status\\\": \\\"%s\\\", \\\"target\\\": \\\"%s\\\"}\",\n                        resourceRestClient.check(resource).getLeft()\n                        ? TopologyNode.Status.REACHABLE : TopologyNode.Status.UNREACHABLE, key);\n            } catch (Exception e) {\n                LOG.warn(\"Error checking connection for {}\", key, e);\n                return String.format(\"{ \\\"status\\\": \\\"%s\\\", \\\"target\\\": \\\"%s\\\"}\",\n                        TopologyNode.Status.FAILURE,\n                        key);\n            } finally {\n                ThreadContext.detach();\n            }\n        }<fim_middle>// function below has no smell\n"}