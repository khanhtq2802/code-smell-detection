{"text": "<fim_prefix>import jdk.internal.org.objectweb.asm.Handle;\nimport jdk.internal.org.objectweb.asm.Opcodes;\nimport jdk.internal.org.objectweb.asm.Type;\nimport jdk.internal.org.objectweb.asm.signature.SignatureReader;\nimport jdk.internal.org.objectweb.asm.signature.SignatureVisitor;\nimport jdk.internal.org.objectweb.asm.signature.SignatureWriter;\n/**\n * A class responsible for remapping types and names.\n *\n * @author Eugene Kuleshov\n */\npublic abstract class Remapper {\n    /**\n      * Returns the given descriptor, remapped with {@link #map(String)}.\n      *\n      * @param descriptor a type descriptor.\n      * @return the given descriptor, with its [array element type] internal name remapped with {@link\n      *     #map(String)} (if the descriptor corresponds to an array or object type, otherwise the\n      *     descriptor is returned as is).\n      */\n    public String mapDesc(final String descriptor) {\n        return mapType(Type.getType(descriptor)).getDescriptor();\n    }\n    /**\n      * Returns the given {@link Type}, remapped with {@link #map(String)} or {@link\n      * #mapMethodDesc(String)}.\n      *\n      * @param type a type, which can be a method type.\n      * @return the given type, with its [array element type] internal name remapped with {@link\n      *     #map(String)} (if the type is an array or object type, otherwise the type is returned as\n      *     is) or, of the type is a method type, with its descriptor remapped with {@link\n      *     #mapMethodDesc(String)}.\n      */\n    private Type mapType(final Type type) {\n        switch (type.getSort()) {\n            case Type.ARRAY:\n                StringBuilder remappedDescriptor = new StringBuilder();\n                for (int i = 0; i < type.getDimensions(); ++i) {\n                    remappedDescriptor.append('[');\n                }\n                remappedDescriptor.append(mapType(type.getElementType()).getDescriptor());\n                return Type.getType(remappedDescriptor.toString());\n            case Type.OBJECT:\n                String remappedInternalName = map(type.getInternalName());\n                return remappedInternalName != null ? Type.getObjectType(remappedInternalName) : type;\n            case Type.METHOD:\n                return Type.getMethodType(mapMethodDesc(type.getDescriptor()));\n            default:\n                return type;\n        }\n    }\n    /**\n      * Returns the given internal name, remapped with {@link #map(String)}.\n      *\n      * @param internalName the internal name (or array type descriptor) of some (array) class.\n      * @return the given internal name, remapped with {@link #map(String)}.\n      */\n    public String mapType(final String internalName) {\n        if (internalName == null) {\n            return null;\n        }\n        return mapType(Type.getObjectType(internalName)).getInternalName();\n    }\n    /**\n      * Returns the given internal names, remapped with {@link #map(String)}.\n      *\n      * @param internalNames the internal names (or array type descriptors) of some (array) classes.\n      * @return the given internal name, remapped with {@link #map(String)}.\n      */\n    public String[] mapTypes(final String[] internalNames) {\n        String[] remappedInternalNames = null;\n        for (int i = 0; i < internalNames.length; ++i) {\n            String internalName = internalNames[i];\n            String remappedInternalName = mapType(internalName);\n            if (remappedInternalName != null) {\n                if (remappedInternalNames == null) {\n                    remappedInternalNames = new String[internalNames.length];\n                    System.arraycopy(internalNames, 0, remappedInternalNames, 0, internalNames.length);\n                }\n                remappedInternalNames[i] = remappedInternalName;\n            }\n        }\n        return remappedInternalNames != null ? remappedInternalNames : internalNames;\n    }\n    /**\n      * Returns the given method descriptor, with its argument and return type descriptors remapped\n      * with {@link #mapDesc(String)}.\n      *\n      * @param methodDescriptor a method descriptor.\n      * @return the given method descriptor, with its argument and return type descriptors remapped\n      *     with {@link #mapDesc(String)}.\n      */\n    public String mapMethodDesc(final String methodDescriptor) {\n        if (\"()V\".equals(methodDescriptor)) {\n            return methodDescriptor;\n        }\n        StringBuilder stringBuilder = new StringBuilder(\"(\");\n        for (Type argumentType : Type.getArgumentTypes(methodDescriptor)) {\n            stringBuilder.append(mapType(argumentType).getDescriptor());\n        }\n        Type returnType = Type.getReturnType(methodDescriptor);\n        if (returnType == Type.VOID_TYPE) {\n            stringBuilder.append(\")V\");\n        } else {\n            stringBuilder.append(')').append(mapType(returnType).getDescriptor());\n        }\n        return stringBuilder.toString();\n    }\n    /**\n      * Returns the given value, remapped with this remapper. Possible values are {@link Boolean},\n      * {@link Byte}, {@link Short}, {@link Character}, {@link Integer}, {@link Long}, {@link Double},\n      * {@link Float}, {@link String}, {@link Type}, {@link Handle}, {@link ConstantDynamic} or arrays\n      * of primitive types .\n      *\n      * @param value an object. Only {@link Type}, {@link Handle} and {@link ConstantDynamic} values\n      *     are remapped.\n      * @return the given value, remapped with this remapper.\n      */\n    public Object mapValue(final Object value) {\n        if (value instanceof Type) {\n            return mapType((Type) value);\n        }\n        if (value instanceof Handle) {\n            Handle handle = (Handle) value;\n            return new Handle(\n                    handle.getTag(),\n                    mapType(handle.getOwner()),\n                    mapMethodName(handle.getOwner(), handle.getName(), handle.getDesc()),\n                    handle.getTag() <= Opcodes.H_PUTSTATIC\n                            ? mapDesc(handle.getDesc())\n                            : mapMethodDesc(handle.getDesc()),\n                    handle.isInterface());\n        }\n        if (value instanceof ConstantDynamic) {\n            ConstantDynamic constantDynamic = (ConstantDynamic) value;\n            int bootstrapMethodArgumentCount = constantDynamic.getBootstrapMethodArgumentCount();\n            Object[] remappedBootstrapMethodArguments = new Object[bootstrapMethodArgumentCount];\n            for (int i = 0; i < bootstrapMethodArgumentCount; ++i) {\n                remappedBootstrapMethodArguments[i] =\n                        mapValue(constantDynamic.getBootstrapMethodArgument(i));\n            }\n            String descriptor = constantDynamic.getDescriptor();\n            return new ConstantDynamic(\n                    mapInvokeDynamicMethodName(constantDynamic.getName(), descriptor),\n                    mapDesc(descriptor),\n                    (Handle) mapValue(constantDynamic.getBootstrapMethod()),\n                    remappedBootstrapMethodArguments);\n        }\n        return value;\n    }\n    /**\n      * Returns the given signature, remapped with the {@link SignatureVisitor} returned by {@link\n      * #createSignatureRemapper(SignatureVisitor)}.\n      *\n      * @param signature a <i>JavaTypeSignature</i>, <i>ClassSignature</i> or <i>MethodSignature</i>.\n      * @param typeSignature whether the given signature is a <i>JavaTypeSignature</i>.\n      * @return signature the given signature, remapped with the {@link SignatureVisitor} returned by\n      *     {@link #createSignatureRemapper(SignatureVisitor)}.\n      */\n    public String mapSignature(final String signature, final boolean typeSignature) {\n        if (signature == null) {\n            return null;\n        }\n        SignatureReader signatureReader = new SignatureReader(signature);\n        SignatureWriter signatureWriter = new SignatureWriter();\n        SignatureVisitor signatureRemapper = createSignatureRemapper(signatureWriter);\n        if (typeSignature) {\n            signatureReader.acceptType(signatureRemapper);\n        } else {\n            signatureReader.accept(signatureRemapper);\n        }\n        return signatureWriter.toString();\n    }\n    /**\n      * Constructs a new remapper for signatures. The default implementation of this method returns a\n      * new {@link SignatureRemapper}.\n      *\n      * @param signatureVisitor the SignatureVisitor the remapper must delegate to.\n      * @return the newly created remapper.\n      * @deprecated use {@link #createSignatureRemapper} instead.\n      */\n    @Deprecated\n    protected SignatureVisitor createRemappingSignatureAdapter(\n            final SignatureVisitor signatureVisitor) {\n        return createSignatureRemapper(signatureVisitor);\n    }\n    /**\n      * Constructs a new remapper for signatures. The default implementation of this method returns a\n      * new {@link SignatureRemapper}.\n      *\n      * @param signatureVisitor the SignatureVisitor the remapper must delegate to.\n      * @return the newly created remapper.\n      */\n<fim_suffix>    protected SignatureVisitor createSignatureRemapper(final SignatureVisitor signatureVisitor) {\n        return new SignatureRemapper(signatureVisitor, this);\n    }<fim_middle>// function below has no smell\n"}