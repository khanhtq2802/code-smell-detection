{"text": "<fim_prefix>/********************************************************************************\n * Copyright (c) 2011-2017 Red Hat Inc. and/or its affiliates and others\n *\n * This program and the accompanying materials are made available under the \n * terms of the Apache License, Version 2.0 which is available at\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * SPDX-License-Identifier: Apache-2.0 \n ********************************************************************************/\npackage org.eclipse.ceylon.cmr.impl;\n\nimport static org.eclipse.ceylon.cmr.api.ArtifactContext.getSuffixFromFilename;\nimport static org.eclipse.ceylon.cmr.resolver.javascript.JavaScriptResolver.readNpmDescriptor;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Map;\n\nimport org.eclipse.ceylon.cmr.api.ArtifactContext;\nimport org.eclipse.ceylon.cmr.spi.ContentHandle;\nimport org.eclipse.ceylon.cmr.spi.ContentOptions;\nimport org.eclipse.ceylon.cmr.spi.Node;\nimport org.eclipse.ceylon.cmr.spi.OpenNode;\nimport org.eclipse.ceylon.common.Constants;\nimport org.eclipse.ceylon.common.log.Logger;\nimport org.eclipse.ceylon.model.cmr.RepositoryException;\n\n/**\n * NPM content store.\n *\n * @author Tako Schotanus (tako@ceylon-lang.org)\n */\npublic class NpmContentStore extends AbstractContentStore {\n    \n    private final File out;\n    private final FileContentStore[] stores;\n    private final FileContentStore outstore;\n    private String npmCommand;\n    private String path;\n    \n    public NpmContentStore(File[] roots, File out, Logger log, boolean offline) {\n        super(log, offline, -1);\n        assert(roots.length > 0);\n        this.stores = new FileContentStore[roots.length];\n        int i = 0;\n        for (File root : roots) {\n            stores[i++] = new FileContentStore(root);\n        }\n        this.out = out;\n        if (out != null) {\n            outstore = new FileContentStore(out);\n        } else {\n            outstore = null;\n        }\n    }\n\n    public Iterable<File> getBaseDirectories() {\n        ArrayList<File> baseDirectories = new ArrayList<>(stores.length);\n        for (FileContentStore store : stores) {\n            for (File baseDir : store.getBaseDirectories()) {\n                baseDirectories.add(baseDir);\n            }\n        }\n        baseDirectories.add(out);\n        return baseDirectories;\n    }\n    \n    public OpenNode createRoot() {\n        return new RootNode(this, this);\n    }\n\n    public OpenNode find(Node parent, String child) {\n        DefaultNode node = null;\n        if (!hasContent(child) //TODO: this test looks like rubbish to me!\n                || parent.getLabel().startsWith(\"@\")\n                || parent instanceof RootNode) { //RootNode has an empty label\n            node = new DefaultNode(child);\n            node.setContentMarker();\n            return node;\n        } else {\n            if (getSuffixFromFilename(child)\n                    .equals(ArtifactContext.JS)) {\n                String artifactName = getTrueArtifactName(parent);\n                if (artifactName != null) {\n                    child = artifactName;\n                }\n            }\n            for (FileContentStore store : stores) {\n                OpenNode result = store.find(parent, child);\n                if (result != null) {\n                    return result;\n                }\n            }\n            installNpmModule(parent);\n            return outstore.find(parent, child);\n        }\n    }\n\n    public ContentHandle peekContent(Node node) {\n        for (FileContentStore store : stores) {\n            ContentHandle result = store.peekContent(node);\n            if (result != null) {\n                return result;\n            }\n        }\n        return null;\n    }\n\n    private String getTrueArtifactName(Node parent) {\n        final Node node;\n        try {\n            node = parent.getChild(\"package.json\");\n        } catch (NullPointerException ex) {\n            return null;\n        }\n        try {\n            File json = node.getContent(File.class);\n            if (json.exists() && json.isFile() && json.canRead()) {\n                //Parse json, get \"main\", that's the file we need\n                Map<String,Object> descriptor = readNpmDescriptor(json);\n                Object main = descriptor.get(\"main\");\n                if (main == null) {\n                    return \"index.js\";\n                } else if (main instanceof String) {\n                    String string = (String) main; \n                    if (string.endsWith(\".js\")) {\n                        return string;\n                    } else {\n                        //TODO: this is rubbish, but I don't understand    \n                        //      what the rules really are\n                        if (string.equals(\"lib\") || string.endsWith(\"/lib\")) {\n                            return string + \"/index.js\";\n                        }\n                        else {\n                            return string + \".js\";\n                        }\n                    }\n                } else {\n                    throw new RepositoryException(\"unexpected value for 'main' in npm descriptor: \" + json);\n                }\n            } else {\n                throw new RepositoryException(\"npm descriptor not found: \" + json);\n            }\n        } catch (IOException ex) {\n            throw new RepositoryException(\"error reading npm descriptor: \" + out + \"/package.json\", ex);\n        }\n    }\n    \n<fim_suffix>    public ContentHandle getContent(Node node) throws IOException {\n        ContentHandle result = peekContent(node);\n        if (result != null) {\n            return result;\n        }\n        \n        if (outstore != null) {\n            installNpmModule(node);\n            return outstore.getContent(node);\n        } else {\n            // Until now we used peekContent() which doesn't throw\n            // so we re-try with any store to get the error we want\n            return stores[0].getContent(node);\n        }\n    }\n\n    public void installNpmModule(Node node) {\n        try {\n            if (!out.exists()) {\n                out.mkdirs();\n            }\n            ArtifactContext ac = ArtifactContext.fromNode(node);\n            if (ac != null) {\n                String name = ac.getName();\n                if (name.contains(\":\")) {\n                    name = \"@\" + name.replace(':', '/');\n                }\n                String version = ac.getVersion();\n                String module = version.isEmpty() ? name : name + \"@\" + version;\n                if (log != null) {\n                    log.debug(\"installing npm module \" + module + \" in \" + out);\n                }\n                String npmCmd = npmCommand != null ? npmCommand : \n                    System.getProperty(Constants.PROP_CEYLON_EXTCMD_NPM, \"npm\");\n                ProcessBuilder pb = new ProcessBuilder()\n                        .command(npmCmd, \"install\", \"--silent\", \"--no-bin-links\", module)\n                        .directory(out.getParentFile())\n                        .inheritIO();\n                Map<String, String> env = pb.environment();\n                String pathVariableName = \"PATH\";\n                for (String key : env.keySet()) {\n                    if (key.equalsIgnoreCase(\"path\")) {\n                        pathVariableName = key;\n                        break;\n                    }\n                }\n                String pathForRunningNpm = path != null ? path : \n                    System.getProperty(Constants.PROP_CEYLON_EXTCMD_PATH, System.getenv(\"PATH\"));\n                env.put(pathVariableName, pathForRunningNpm);\n                \n                Process p = pb.start();\n                p.waitFor();\n                if (p.exitValue() != 0) {\n                    throw new RepositoryException(\"npm installer for '\" + name + \"' failed with exit code: \" + p.exitValue());\n                }\n            }\n        } catch (InterruptedException | IOException ex) {\n            throw new RepositoryException(\"error running npm installer (make sure 'npm' is installed and available in your PATH)\", ex);\n        }\n    }\n\n    public ContentHandle putContent(Node node, InputStream stream, ContentOptions options) throws IOException {\n        if (outstore != null) {\n            return outstore.putContent(node, stream, options);\n        } else {\n            return null;  // no output specified\n        }\n    }\n\n    public OpenNode create(Node parent, String child) {\n        if (outstore != null) {\n            return outstore.create(parent, child);\n        } else {\n            return null;  // no output specified\n        }\n    }\n\n    public Iterable<? extends OpenNode> find(Node parent) {\n        return Collections.emptyList(); // cannot find all children\n    }\n    \n    public String getDisplayString() {\n        String name = \"npm\";\n        if (offline) {\n            name += \" (offline)\";\n        }\n        return name;\n    }\n\n    @Override\n    public boolean isHerd() {\n        return false;\n    }\n\n    @Override\n    public boolean canHandleFolders() {\n        return false;\n    }\n\n    public void setNpmCommand(String npmCommand) {\n        this.npmCommand = npmCommand;\n    }\n\n    public void setPathForRunningNpm(String path) {\n        this.path = path;\n    }\n}<fim_middle>// function below has no smell\n"}