{"text": "<fim_prefix>     *\n     * @param value if {@code true}, execute after shutdown, else don't\n     * @see #getExecuteExistingDelayedTasksAfterShutdownPolicy\n     */\n    public void setExecuteExistingDelayedTasksAfterShutdownPolicy(boolean value) {\n        executeExistingDelayedTasksAfterShutdown = value;\n        if (!value && isShutdown())\n            onShutdown();\n    }\n    /**\n     * Gets the policy on whether to execute existing delayed\n     * tasks even when this executor has been {@code shutdown}.\n     * In this case, these tasks will only terminate upon\n     * {@code shutdownNow}, or after setting the policy to\n     * {@code false} when already shutdown.\n     * This value is by default {@code true}.\n     *\n     * @return {@code true} if will execute after shutdown\n     * @see #setExecuteExistingDelayedTasksAfterShutdownPolicy\n     */\n    public boolean getExecuteExistingDelayedTasksAfterShutdownPolicy() {\n        return executeExistingDelayedTasksAfterShutdown;\n    }\n    /**\n     * Sets the policy on whether cancelled tasks should be immediately\n     * removed from the work queue at time of cancellation.  This value is\n     * by default {@code false}.\n     *\n     * @param value if {@code true}, remove on cancellation, else don't\n     * @see #getRemoveOnCancelPolicy\n     * @since 1.7\n     */\n    public void setRemoveOnCancelPolicy(boolean value) {\n        removeOnCancel = value;\n    }\n    /**\n     * Gets the policy on whether cancelled tasks should be immediately\n     * removed from the work queue at time of cancellation.  This value is\n     * by default {@code false}.\n     *\n     * @return {@code true} if cancelled tasks are immediately removed\n     *         from the queue\n     * @see #setRemoveOnCancelPolicy\n     * @since 1.7\n     */\n    public boolean getRemoveOnCancelPolicy() {\n        return removeOnCancel;\n    }\n    /**\n     * Initiates an orderly shutdown in which previously submitted\n     * tasks are executed, but no new tasks will be accepted.\n     * Invocation has no additional effect if already shut down.\n     *\n     * <p>This method does not wait for previously submitted tasks to\n     * complete execution.  Use {@link #awaitTermination awaitTermination}\n     * to do that.\n     *\n     * <p>If the {@code ExecuteExistingDelayedTasksAfterShutdownPolicy}\n     * has been set {@code false}, existing delayed tasks whose delays\n     * have not yet elapsed are cancelled.  And unless the {@code\n     * ContinueExistingPeriodicTasksAfterShutdownPolicy} has been set\n     * {@code true}, future executions of existing periodic tasks will\n     * be cancelled.\n     */\n    // android-note: Removed \"throws SecurityException\" doc.\n    public void shutdown() {\n        super.shutdown();\n    }\n    /**\n     * Attempts to stop all actively executing tasks, halts the\n     * processing of waiting tasks, and returns a list of the tasks\n     * that were awaiting execution. These tasks are drained (removed)\n     * from the task queue upon return from this method.\n     *\n     * <p>This method does not wait for actively executing tasks to\n     * terminate.  Use {@link #awaitTermination awaitTermination} to\n     * do that.\n     *\n     * <p>There are no guarantees beyond best-effort attempts to stop\n     * processing actively executing tasks.  This implementation\n     * interrupts tasks via {@link Thread#interrupt}; any task that\n     * fails to respond to interrupts may never terminate.\n     *\n     * @return list of tasks that never commenced execution.\n     *         Each element of this list is a {@link ScheduledFuture}.\n     *         For tasks submitted via one of the {@code schedule}\n     *         methods, the element will be identical to the returned\n     *         {@code ScheduledFuture}.  For tasks submitted using\n     *         {@link #execute execute}, the element will be a\n     *         zero-delay {@code ScheduledFuture}.\n     */\n    // android-note: Removed \"throws SecurityException\" doc.\n    public List<Runnable> shutdownNow() {\n        return super.shutdownNow();\n    }\n    /**\n     * Returns the task queue used by this executor.  Access to the\n     * task queue is intended primarily for debugging and monitoring.\n     * This queue may be in active use.  Retrieving the task queue\n     * does not prevent queued tasks from executing.\n     *\n     * <p>Each element of this queue is a {@link ScheduledFuture}.\n     * For tasks submitted via one of the {@code schedule} methods, the\n     * element will be identical to the returned {@code ScheduledFuture}.\n     * For tasks submitted using {@link #execute execute}, the element\n     * will be a zero-delay {@code ScheduledFuture}.\n     *\n     * <p>Iteration over this queue is <em>not</em> guaranteed to traverse\n     * tasks in the order in which they will execute.\n     *\n     * @return the task queue\n     */\n    public BlockingQueue<Runnable> getQueue() {\n        return super.getQueue();\n    }\n    /**\n     * Specialized delay queue. To mesh with TPE declarations, this\n     * class must be declared as a BlockingQueue<Runnable> even though\n     * it can only hold RunnableScheduledFutures.\n     */\n    static class DelayedWorkQueue extends AbstractQueue<Runnable>\n        implements BlockingQueue<Runnable> {\n        /*\n         * A DelayedWorkQueue is based on a heap-based data structure\n         * like those in DelayQueue and PriorityQueue, except that\n         * every ScheduledFutureTask also records its index into the\n         * heap array. This eliminates the need to find a task upon\n         * cancellation, greatly speeding up removal (down from O(n)\n         * to O(log n)), and reducing garbage retention that would\n         * otherwise occur by waiting for the element to rise to top\n         * before clearing. But because the queue may also hold\n         * RunnableScheduledFutures that are not ScheduledFutureTasks,\n         * we are not guaranteed to have such indices available, in\n         * which case we fall back to linear search. (We expect that\n         * most tasks will not be decorated, and that the faster cases\n         * will be much more common.)\n         *\n         * All heap operations must record index changes -- mainly\n         * within siftUp and siftDown. Upon removal, a task's\n         * heapIndex is set to -1. Note that ScheduledFutureTasks can\n         * appear at most once in the queue (this need not be true for\n         * other kinds of tasks or work queues), so are uniquely\n         * identified by heapIndex.\n         */\n        private static final int INITIAL_CAPACITY = 16;\n        private RunnableScheduledFuture<?>[] queue =\n            new RunnableScheduledFuture<?>[INITIAL_CAPACITY];\n        private final ReentrantLock lock = new ReentrantLock();\n        private int size;\n        /**\n         * Thread designated to wait for the task at the head of the\n         * queue.  This variant of the Leader-Follower pattern\n         * (http://www.cs.wustl.edu/~schmidt/POSA/POSA2/) serves to\n         * minimize unnecessary timed waiting.  When a thread becomes\n         * the leader, it waits only for the next delay to elapse, but\n         * other threads await indefinitely.  The leader thread must\n         * signal some other thread before returning from take() or\n         * poll(...), unless some other thread becomes leader in the\n         * interim.  Whenever the head of the queue is replaced with a\n         * task with an earlier expiration time, the leader field is\n         * invalidated by being reset to null, and some waiting\n         * thread, but not necessarily the current leader, is\n         * signalled.  So waiting threads must be prepared to acquire\n         * and lose leadership while waiting.\n         */\n        private Thread leader;\n        /**\n         * Condition signalled when a newer task becomes available at the\n         * head of the queue or a new thread may need to become leader.\n         */\n        private final Condition available = lock.newCondition();\n        /**\n         * Sets f's heapIndex if it is a ScheduledFutureTask.\n         */\n        private void setIndex(RunnableScheduledFuture<?> f, int idx) {\n            if (f instanceof ScheduledFutureTask)\n                ((ScheduledFutureTask)f).heapIndex = idx;\n        }\n        /**\n         * Sifts element added at bottom up to its heap-ordered spot.\n         * Call only when holding lock.\n         */\n<fim_suffix>        private void siftUp(int k, RunnableScheduledFuture<?> key) {\n            while (k > 0) {\n                int parent = (k - 1) >>> 1;\n                RunnableScheduledFuture<?> e = queue[parent];\n                if (key.compareTo(e) >= 0)\n                    break;\n                queue[k] = e;\n                setIndex(e, k);\n                k = parent;\n            }\n            queue[k] = key;\n            setIndex(key, k);\n        }<fim_middle>// function below has no smell\n"}