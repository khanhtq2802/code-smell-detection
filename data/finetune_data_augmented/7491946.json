{"text": "<fim_prefix>        return env;\n    }\n    public Configuration getActiveConfiguration() {\n        return activeConfiguration;\n    }\n    public LLVMScope getGlobalScope() {\n        return globalScope;\n    }\n    @TruffleBoundary\n    public Object getThreadLocalStorage() {\n        Object value = tls.get(Thread.currentThread());\n        if (value != null) {\n            return value;\n        }\n        return LLVMNativePointer.createNull();\n    }\n    @TruffleBoundary\n    public void setThreadLocalStorage(Object value) {\n        tls.put(Thread.currentThread(), value);\n    }\n    @TruffleBoundary\n    public LLVMPointer getClearChildTid() {\n        LLVMPointer value = clearChildTid.get(Thread.currentThread());\n        if (value != null) {\n            return value;\n        }\n        return LLVMNativePointer.createNull();\n    }\n    @TruffleBoundary\n    public void setClearChildTid(LLVMPointer value) {\n        clearChildTid.put(Thread.currentThread(), value);\n    }\n    @TruffleBoundary\n    public LLVMFunctionDescriptor getFunctionDescriptor(LLVMNativePointer handle) {\n        return functionPointerRegistry.getDescriptor(handle);\n    }\n    @TruffleBoundary\n    public LLVMFunctionDescriptor createFunctionDescriptor(String name, FunctionType type) {\n        return functionPointerRegistry.create(name, type);\n    }\n    @TruffleBoundary\n    public void registerFunctionPointer(LLVMNativePointer address, LLVMFunctionDescriptor descriptor) {\n        functionPointerRegistry.register(address, descriptor);\n    }\n    public LLVMNativePointer getSigDfl() {\n        return sigDfl;\n    }\n    public LLVMNativePointer getSigIgn() {\n        return sigIgn;\n    }\n    public LLVMNativePointer getSigErr() {\n        return sigErr;\n    }\n    @TruffleBoundary\n    public boolean isHandle(LLVMNativePointer address) {\n        synchronized (handlesLock) {\n            return handleFromPointer.containsKey(address);\n        }\n    }\n    @TruffleBoundary\n    public TruffleObject getManagedObjectForHandle(LLVMNativePointer address) {\n        synchronized (handlesLock) {\n            final Handle handle = handleFromPointer.get(address);\n            if (handle == null) {\n                throw new UnsupportedOperationException(\"Cannot resolve native handle: \" + address);\n            }\n            return handle.managed;\n        }\n    }\n    @TruffleBoundary\n    public void releaseHandle(LLVMMemory memory, LLVMNativePointer address) {\n        synchronized (handlesLock) {\n            Handle handle = handleFromPointer.get(address);\n            if (handle == null) {\n                throw new UnsupportedOperationException(\"Cannot resolve native handle: \" + address);\n            }\n            if (--handle.refcnt == 0) {\n                handleFromPointer.removeKey(address);\n                handleFromManaged.removeKey(handle.managed);\n                memory.free(address);\n            }\n        }\n    }\n    public LLVMNativePointer getHandleForManagedObject(LLVMMemory memory, TruffleObject object) {\n        return getHandle(memory, object, false).copy();\n    }\n    public LLVMNativePointer getDerefHandleForManagedObject(LLVMMemory memory, TruffleObject object) {\n        return getHandle(memory, object, true).copy();\n    }\n    @TruffleBoundary\n    private LLVMNativePointer getHandle(LLVMMemory memory, TruffleObject object, boolean autoDeref) {\n        synchronized (handlesLock) {\n            Handle handle = handleFromManaged.get(object);\n            if (handle == null) {\n                LLVMNativePointer allocatedMemory = LLVMNativePointer.create(memory.allocateHandle(autoDeref));\n                handle = new Handle(allocatedMemory, object);\n                handleFromManaged.put(object, handle);\n                handleFromPointer.put(allocatedMemory, handle);\n            }\n            handle.refcnt++;\n            return handle.pointer;\n        }\n    }\n    @TruffleBoundary\n    public void registerNativeCall(LLVMFunctionDescriptor descriptor) {\n        if (nativeCallStatistics != null) {\n            String name = descriptor.getName() + \" \" + descriptor.getType();\n            if (nativeCallStatistics.containsKey(name)) {\n                int count = nativeCallStatistics.get(name) + 1;\n                nativeCallStatistics.put(name, count);\n            } else {\n                nativeCallStatistics.put(name, 1);\n            }\n        }\n    }\n    public LinkedList<LLVMNativePointer> getCaughtExceptionStack() {\n        return caughtExceptionStack;\n    }\n    public LLVMThreadingStack getThreadingStack() {\n        assert threadingStack != null;\n        return threadingStack;\n    }\n    public void registerDestructorFunctions(RootCallTarget destructor) {\n        assert destructor != null;\n        assert !destructorFunctions.contains(destructor);\n        destructorFunctions.add(destructor);\n    }\n    @TruffleBoundary\n    public boolean isScopeLoaded(LLVMScope scope) {\n        return dynamicLinkChain.containsScope(scope);\n    }\n    @TruffleBoundary\n    public void registerScope(LLVMScope scope) {\n        dynamicLinkChain.addScope(scope);\n    }\n    public synchronized void registerThread(LLVMThread thread) {\n        assert !runningThreads.contains(thread);\n        runningThreads.add(thread);\n    }\n    public synchronized void unregisterThread(LLVMThread thread) {\n        runningThreads.remove(thread);\n        assert !runningThreads.contains(thread);\n    }\n    @TruffleBoundary\n    public synchronized void shutdownThreads() {\n        // we need to iterate over a copy of the list, because stop() can modify the original list\n        for (LLVMThread node : new ArrayList<>(runningThreads)) {\n            node.stop();\n        }\n    }\n    @TruffleBoundary\n    public synchronized void awaitThreadTermination() {\n        shutdownThreads();\n        while (!runningThreads.isEmpty()) {\n            LLVMThread node = runningThreads.get(0);\n            node.awaitFinish();\n            assert !runningThreads.contains(node); // should be unregistered by LLVMThreadNode\n        }\n    }\n    public RootCallTarget[] getDestructorFunctions() {\n        return destructorFunctions.toArray(new RootCallTarget[destructorFunctions.size()]);\n    }\n    public synchronized List<LLVMThread> getRunningThreads() {\n        return Collections.unmodifiableList(runningThreads);\n    }\n    public void addDataLayout(DataLayout layout) {\n        this.dataLayout = this.dataLayout.merge(layout);\n    }\n    public LLVMSourceContext getSourceContext() {\n        return sourceContext;\n    }\n    @TruffleBoundary\n    public LLVMGlobal findGlobal(LLVMPointer pointer) {\n        return globalsReverseMap.get(pointer);\n    }\n    @TruffleBoundary\n    public void registerReadOnlyGlobals(LLVMPointer nonPointerStore) {\n        globalsReadOnlyStore.add(nonPointerStore);\n    }\n    @TruffleBoundary\n    public void registerGlobals(LLVMPointer nonPointerStore) {\n        globalsNonPointerStore.add(nonPointerStore);\n    }\n    @TruffleBoundary\n    public void registerGlobalReverseMap(LLVMGlobal global, LLVMPointer target) {\n        globalsReverseMap.put(target, global);\n    }\n    public void setCleanupNecessary(boolean value) {\n        cleanupNecessary = value;\n    }\n    @TruffleBoundary\n    public LLVMInteropType getInteropType(LLVMSourceType sourceType) {\n        return interopTypeRegistry.get(sourceType);\n    }\n    private void printNativeCallStatistic() {\n        if (nativeCallStatistics != null) {\n            LinkedHashMap<String, Integer> sorted = nativeCallStatistics.entrySet().stream().sorted(Map.Entry.comparingByValue()).collect(Collectors.toMap(\n                            Map.Entry::getKey,\n                            Map.Entry::getValue,\n                            (e1, e2) -> e1,\n                            LinkedHashMap::new));\n            for (String s : sorted.keySet()) {\n                System.err.println(String.format(\"Function %s \\t count: %d\", s, sorted.get(s)));\n            }\n        }\n    }\n    public static class ExternalLibrary {\n        private final String name;\n        private final Path path;\n        @CompilationFinal private boolean isNative;\n        private final boolean isInternal;\n        public static ExternalLibrary external(String name, boolean isNative) {\n            return new ExternalLibrary(name, isNative, false);\n        }\n        public static ExternalLibrary internal(String name, boolean isNative) {\n            return new ExternalLibrary(name, isNative, true);\n        }\n        public static ExternalLibrary external(Path path, boolean isNative) {\n            return new ExternalLibrary(path, isNative, false);\n        }\n        public static ExternalLibrary internal(Path path, boolean isNative) {\n            return new ExternalLibrary(path, isNative, true);\n        }\n        public ExternalLibrary(String name, boolean isNative, boolean isInternal) {\n            this(name, null, isNative, isInternal);\n        }\n        public ExternalLibrary(Path path, boolean isNative, boolean isInternal) {\n            this(extractName(path), path, isNative, isInternal);\n        }\n<fim_suffix>        private ExternalLibrary(String name, Path path, boolean isNative, boolean isInternal) {\n            this.name = name;\n            this.path = path;\n            this.isNative = isNative;\n            this.isInternal = isInternal;\n        }<fim_middle>// function below has no smell\n"}