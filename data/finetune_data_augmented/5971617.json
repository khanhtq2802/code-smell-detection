{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.openejb.math.stat.descriptive.rank;\n\nimport org.apache.openejb.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\n\nimport java.io.Serializable;\n\n/**\n * Returns the minimum of the available values.\n * <p>\n * <ul>\n * <li>The result is <code>NaN</code> iff all values are <code>NaN</code>\n * (i.e. <code>NaN</code> values have no impact on the value of the statistic).</li>\n * <li>If any of the values equals <code>Double.NEGATIVE_INFINITY</code>,\n * the result is <code>Double.NEGATIVE_INFINITY.</code></li>\n * </ul></p>\n * <p>\n * <strong>Note that this implementation is not synchronized.</strong> If\n * multiple threads access an instance of this class concurrently, and at least\n * one of the threads invokes the <code>increment()</code> or\n * <code>clear()</code> method, it must be synchronized externally.</p>\n *\n * @version $Revision: 811685 $ $Date: 2009-09-05 10:36:48 -0700 (Sat, 05 Sep 2009) $\n */\n<fim_suffix>public class Min extends AbstractStorelessUnivariateStatistic implements Serializable {\n\n    /**\n     * Serializable version identifier\n     */\n    private static final long serialVersionUID = -1231995784909003131L;\n\n    /**\n     * Number of values that have been added\n     */\n    private long n;\n\n    /**\n     * Current value of the statistic\n     */\n    private double value;\n\n    /**\n     * Create a Min instance\n     */\n    public Min() {\n        n = 0;\n        value = Double.NaN;\n    }\n\n    /**\n     * Copy constructor, creates a new {@code Min} identical\n     * to the {@code original}\n     *\n     * @param original the {@code Min} instance to copy\n     */\n    public Min(final Min original) {\n        copy(original, this);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void increment(final double d) {\n        if (d < value || Double.isNaN(value)) {\n            value = d;\n        }\n        n++;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void clear() {\n        value = Double.NaN;\n        n = 0;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getResult() {\n        return value;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public long getN() {\n        return n;\n    }\n\n    /**\n     * Returns the minimum of the entries in the specified portion of\n     * the input array, or <code>Double.NaN</code> if the designated subarray\n     * is empty.\n     * <p>\n     * Throws <code>IllegalArgumentException</code> if the array is null or\n     * the array index parameters are not valid.</p>\n     * <p>\n     * <ul>\n     * <li>The result is <code>NaN</code> iff all values are <code>NaN</code>\n     * (i.e. <code>NaN</code> values have no impact on the value of the statistic).</li>\n     * <li>If any of the values equals <code>Double.NEGATIVE_INFINITY</code>,\n     * the result is <code>Double.NEGATIVE_INFINITY.</code></li>\n     * </ul> </p>\n     *\n     * @param values the input array\n     * @param begin  index of the first array element to include\n     * @param length the number of elements to include\n     * @return the minimum of the values or Double.NaN if length = 0\n     * @throws IllegalArgumentException if the array is null or the array index\n     *                                  parameters are not valid\n     */\n    @Override\n    public double evaluate(final double[] values, final int begin, final int length) {\n        double min = Double.NaN;\n        if (test(values, begin, length)) {\n            min = values[begin];\n            for (int i = begin; i < begin + length; i++) {\n                if (!Double.isNaN(values[i])) {\n                    min = min < values[i] ? min : values[i];\n                }\n            }\n        }\n        return min;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Min copy() {\n        final Min result = new Min();\n        copy(this, result);\n        return result;\n    }\n\n    /**\n     * Copies source to dest.\n     * <p>Neither source nor dest can be null.</p>\n     *\n     * @param source Min to copy\n     * @param dest   Min to copy to\n     * @throws NullPointerException if either source or dest is null\n     */\n    public static void copy(final Min source, final Min dest) {\n        dest.n = source.n;\n        dest.value = source.value;\n    }\n}<fim_middle>// class below has no smell\n"}