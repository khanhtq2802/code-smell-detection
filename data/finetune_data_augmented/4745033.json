{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.netbeans.html.boot.impl;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport javax.annotation.processing.AbstractProcessor;\nimport javax.annotation.processing.Completion;\nimport javax.annotation.processing.Completions;\nimport javax.annotation.processing.Messager;\nimport javax.annotation.processing.Processor;\nimport javax.annotation.processing.RoundEnvironment;\nimport javax.lang.model.SourceVersion;\nimport javax.lang.model.element.AnnotationMirror;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.ElementKind;\nimport javax.lang.model.element.ExecutableElement;\nimport javax.lang.model.element.Modifier;\nimport javax.lang.model.element.Name;\nimport javax.lang.model.element.PackageElement;\nimport javax.lang.model.element.TypeElement;\nimport javax.lang.model.element.VariableElement;\nimport javax.lang.model.type.ArrayType;\nimport javax.lang.model.type.ExecutableType;\nimport javax.lang.model.type.TypeKind;\nimport javax.lang.model.type.TypeMirror;\nimport javax.lang.model.util.Types;\nimport javax.tools.Diagnostic;\nimport javax.tools.FileObject;\nimport javax.tools.StandardLocation;\nimport net.java.html.js.JavaScriptBody;\nimport net.java.html.js.JavaScriptResource;\nimport org.openide.util.lookup.ServiceProvider;\n/**\n *\n * @author Jaroslav Tulach\n */\n@ServiceProvider(service = Processor.class)\npublic final class JavaScriptProcesor extends AbstractProcessor {\n    private final Map<String,Map<String,ExecutableElement>> javacalls =\n        new HashMap<String,Map<String,ExecutableElement>>();\n    private final Map<String,Set<TypeElement>> bodies =\n        new HashMap<String, Set<TypeElement>>();\n    @Override\n    public Set<String> getSupportedAnnotationTypes() {\n        Set<String> set = new HashSet<String>();\n        set.add(JavaScriptBody.class.getName());\n        set.add(JavaScriptResource.class.getName());\n        set.add(JavaScriptResource.Group.class.getName());\n        return set;\n    }\n<fim_suffix>    @Override\n    public SourceVersion getSupportedSourceVersion() {\n        try {\n            return SourceVersion.valueOf(\"RELEASE_8\"); // NOI18N\n        } catch (IllegalArgumentException ex) {\n            return SourceVersion.RELEASE_7;\n        }\n    }\n    @Override\n    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n        final Messager msg = processingEnv.getMessager();\n        for (Element e : roundEnv.getElementsAnnotatedWith(JavaScriptBody.class)) {\n            if (e.getKind() != ElementKind.METHOD && e.getKind() != ElementKind.CONSTRUCTOR) {\n                continue;\n            }\n            ExecutableElement ee = (ExecutableElement)e;\n            List<? extends VariableElement> params = ee.getParameters();\n            JavaScriptBody jsb = e.getAnnotation(JavaScriptBody.class);\n            if (jsb == null) {\n                continue;\n            } else {\n                Set<TypeElement> classes = this.bodies.get(findPkg(e));\n                if (classes == null) {\n                    classes = new HashSet<TypeElement>();\n                    bodies.put(findPkg(e), classes);\n                }\n                Element t = e.getEnclosingElement();\n                while (!t.getKind().isClass() && !t.getKind().isInterface()) {\n                    t = t.getEnclosingElement();\n                }\n                classes.add((TypeElement)t);\n            }\n            String[] arr = jsb.args();\n            if (params.size() != arr.length) {\n                msg.printMessage(Diagnostic.Kind.ERROR, \"Number of args arguments does not match real arguments!\", e);\n            }\n            for (int i = 0; i < arr.length; i++) {\n                if (!params.get(i).getSimpleName().toString().equals(arr[i])) {\n                    msg.printMessage(Diagnostic.Kind.WARNING, \"Actual method parameter names and args ones \" + Arrays.toString(arr) + \" differ\", e);\n                }\n            }\n            if (!jsb.wait4js() && ee.getReturnType().getKind() != TypeKind.VOID) {\n                msg.printMessage(Diagnostic.Kind.ERROR, \"Methods that don't wait for JavaScript to finish must return void!\", e);\n            }\n            if (!jsb.javacall() && jsb.body().contains(\".@\")) {\n                msg.printMessage(Diagnostic.Kind.WARNING, \"Usage of .@ usually requires javacall=true\", e);\n            }\n            if (ee.getReturnType().getKind() == TypeKind.ARRAY) {\n                ArrayType at = (ArrayType) ee.getReturnType();\n                TypeMirror objectType = processingEnv.getElementUtils().getTypeElement(\"java.lang.Object\").asType();\n                    final TypeMirror componentType = at.getComponentType();\n                if (!processingEnv.getTypeUtils().isSameType(objectType, componentType)) {\n                    wrongArrayError(componentType, e);\n                }\n            }\n            if (jsb.javacall()) {\n                JsCallback verify = new VerifyCallback(e);\n                try {\n                    verify.parse(jsb.body());\n                } catch (IllegalStateException ex) {\n                    msg.printMessage(Diagnostic.Kind.ERROR, ex.getLocalizedMessage(), e);\n                }\n            }\n        }\n        for (Element e : roundEnv.getElementsAnnotatedWith(JavaScriptResource.class)) {\n            JavaScriptResource r = e.getAnnotation(JavaScriptResource.class);\n            if (r == null) {\n                continue;\n            }\n            checkJavaScriptBody(r, e, msg);\n        }\n        for (Element e : roundEnv.getElementsAnnotatedWith(JavaScriptResource.Group.class)) {\n            JavaScriptResource.Group g = e.getAnnotation(JavaScriptResource.Group.class);\n            if (g == null) {\n                continue;\n            }\n            for (JavaScriptResource r : g.value()) {\n                checkJavaScriptBody(r, e, msg);\n            }\n        }\n        if (roundEnv.processingOver()) {\n            generateCallbackClass(javacalls);\n            generateJavaScriptBodyList(bodies);\n            javacalls.clear();\n        }\n        return true;\n    }\n    private void checkJavaScriptBody(JavaScriptResource r, Element e, final Messager msg) {\n        final String res;\n        if (r.value().startsWith(\"/\")) {\n            res = r.value().substring(1);\n        } else {\n            res = findPkg(e).replace('.', '/') + \"/\" + r.value();\n        }\n        try {\n            FileObject os = processingEnv.getFiler().getResource(StandardLocation.SOURCE_PATH, \"\", res);\n            os.openInputStream().close();\n        } catch (IOException ex1) {\n            try {\n                FileObject os2 = processingEnv.getFiler().getResource(StandardLocation.CLASS_OUTPUT, \"\", res);\n                os2.openInputStream().close();\n            } catch (IOException ex2) {\n                try {\n                    FileObject os3 = processingEnv.getFiler().getResource(StandardLocation.CLASS_PATH, \"\", res);\n                    os3.openInputStream().close();\n                } catch (IOException ex3) {\n                    msg.printMessage(Diagnostic.Kind.ERROR, \"Cannot find resource \" + res, e);\n                }\n            }\n        }\n        boolean found = false;\n        for (Element mthod : e.getEnclosedElements()) {\n            if (mthod.getKind() != ElementKind.METHOD) {\n                continue;\n            }\n            if (mthod.getAnnotation(JavaScriptBody.class) != null) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            msg.printMessage(Diagnostic.Kind.ERROR, \"At least one method needs @JavaScriptBody annotation. \"\n                    + \"Otherwise it is not guaranteed the resource will ever be loaded,\", e\n            );\n        }\n    }\n    @Override<fim_middle>// function below has no smell\n"}