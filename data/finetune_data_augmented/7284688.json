{"text": "<fim_prefix>import java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport org.eclipse.core.resources.ISaveContext;\nimport org.eclipse.core.resources.ISaveParticipant;\nimport org.eclipse.core.resources.ResourcesPlugin;\nimport org.eclipse.core.runtime.Assert;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IPath;\nimport org.springsource.ide.eclipse.commons.core.Entry;\nimport org.springsource.ide.eclipse.commons.core.ICommandHistory;\nimport org.springsource.ide.eclipse.commons.internal.core.CorePlugin;\n/**\n * This provides a light-weight command history that is persisted in the user's\n * workspace.\n * @author Andrew Eisenberg\n * @author Christian Dupuis\n * @author Kris De Volder\n * @since 2.5.0\n */\npublic class CommandHistory implements Iterable<Entry>, ICommandHistory {\n\t/**\n\t * Our ISaveParticipant, responsible for persisting the CommandHistory in\n\t * the workspace.\n\t */\n\tprivate class CommandHistorySaver implements ISaveParticipant {\n\t\tpublic void doneSaving(ISaveContext context) {\n\t\t}\n\t\tpublic void prepareToSave(ISaveContext context) throws CoreException {\n\t\t}\n\t\tpublic void rollback(ISaveContext context) {\n\t\t}\n\t\tpublic void saving(ISaveContext context) throws CoreException {\n\t\t\tif (isDirty()) {\n\t\t\t\ttry {\n\t\t\t\t\tsave(getSavePath());\n\t\t\t\t}\n\t\t\t\tcatch (Exception e) {\n\t\t\t\t\tthrow new CoreException(CorePlugin.createErrorStatus(\"Couldn't save command history\", e));\n\t\t\t\t}\n\t\t\t\tcontext.needSaveNumber();\n\t\t\t}\n\t\t}\n\t}\n\tprivate static final String HISTORY_FILE_NAME = \".commandhistory\";\n\t/**\n\t * If the number of history entries exceeds maxSize, older items will be\n\t * automatically dropped.\n\t */\n\tprivate int maxSize = DEFAULT_MAX_SIZE;\n\tprivate boolean isDirty;\n\tprivate LinkedList<Entry> history = new LinkedList<Entry>();\n\tprivate final String natureId;\n\tprivate final String historyId;\n\tpublic CommandHistory(String historyId, String natureId) {\n\t\tthis.natureId = natureId;\n\t\tthis.historyId = historyId;\n\t}\n\t/**\n\t * Create an \"auto saving\" CommandHistory and register it as a save\n\t * participant with the workspace.\n\t */\n\tpublic CommandHistory(String historyId, String natureId, boolean persist) throws CoreException {\n\t\tthis.natureId = natureId;\n\t\tthis.historyId = historyId;\n\t\tif (persist) {\n\t\t\tCommandHistorySaver saver = new CommandHistorySaver();\n\t\t\t// Method addSaveParticipant(String, ISaveParticipant) is deprecated\n\t\t\t// on 3.6, but the alternative does not exist in 3.5\n\t\t\tResourcesPlugin.getWorkspace().addSaveParticipant(CorePlugin.getDefault(), saver);\n\t\t\tload(getSavePath());\n\t\t}\n\t}\n\t/**\n\t * Add an element to the history. If a similar element already exists in the\n\t * history, the older element is removed before adding the new one.\n\t * <p>\n\t * Adding an element beyond the maxSize will result in the oldest item being\n\t * discarded.\n\t */\n\tpublic void add(Entry entry) {\n\t\thistory.remove(entry);\n\t\thistory.addFirst(entry);\n\t\tdiscardOldEntries();\n\t\tisDirty = true;\n\t}\n\tpublic void clear() {\n\t\thistory.clear();\n\t\tisDirty = true;\n\t}\n\t/**\n\t * Throw away old entries until our size obeys the maxSize constraint.\n\t */\n\tprivate void discardOldEntries() {\n\t\twhile (size() > getMaxSize()) {\n\t\t\thistory.removeLast();\n\t\t}\n\t}\n\t/**\n\t * Return the last added element.\n\t */\n\tpublic Entry getLast() {\n\t\t// elements in backing collection are actually in inverse order\n\t\treturn history.getFirst();\n\t}\n\t/**\n\t * @return The number of items in the history is limited to.\n\t */\n\tpublic int getMaxSize() {\n\t\treturn maxSize;\n\t}\n\t/**\n\t * Retrieve a List of most recent entries, (most recent first).\n\t * @param limit Return at most this many elements.\n\t */\n\tpublic List<Entry> getRecentValid(int limit) {\n\t\tArrayList<Entry> result = new ArrayList<Entry>(limit);\n\t\tfor (Entry entry : validEntries()) {\n\t\t\tif (limit-- <= 0) {\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tresult.add(entry);\n\t\t}\n\t\treturn result;\n\t}\n\tprivate IPath getSavePath() {\n\t\treturn CorePlugin.getDefault().getStateLocation().append(historyId + HISTORY_FILE_NAME);\n\t}\n\t/**\n\t * Did this history get changed since it was last saved?\n\t */\n\tpublic boolean isDirty() {\n\t\treturn isDirty;\n\t}\n\tpublic boolean isEmpty() {\n\t\treturn history.isEmpty();\n\t}\n\t/**\n\t * Iterator that starts from the most recently added element.\n\t */\n\tpublic Iterator<Entry> iterator() {\n\t\treturn history.iterator();\n\t}\n\t/**\n\t * Load history contents from a file. If the file does not exist we silently\n\t * assume the history should be empty.\n\t * <p>\n\t * If there are errors loading file we keep the current history and log an\n\t * exception.\n\t */\n\tpublic void load(File file) {\n\t\ttry {\n\t\t\tif (file.exists()) {\n\t\t\t\tFileInputStream fIn = new FileInputStream(file);\n\t\t\t\tObjectInputStream oIn = null;\n\t\t\t\ttry {\n\t\t\t\t\toIn = new ObjectInputStream(fIn);\n\t\t\t\t\tload(oIn);\n\t\t\t\t\tisDirty = false;\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tif (oIn != null) {\n\t\t\t\t\t\toIn.close();\n\t\t\t\t\t}\n\t\t\t\t\telse if (fIn != null) {\n\t\t\t\t\t\tfIn.close();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tCorePlugin.log(\"Could not restore the command history\", e);\n\t\t\tif (file.exists()) {\n\t\t\t\t// File is corrupt...\n\t\t\t\tfile.delete();\n\t\t\t}\n\t\t}\n\t}\n\tprivate void load(IPath savePath) {\n\t\tload(savePath.toFile());\n\t}\n\t/**\n\t * Load the state from an InputOutputStream, let someone else worry where\n\t * this stream came from and how to handle error / exception making sure the\n\t * stream is closed no matter what.\n\t * @throws ClassNotFoundException\n\t * @throws IOException\n\t */\n\tprivate void load(ObjectInputStream in) throws IOException, ClassNotFoundException {\n\t\tint newMaxSize = in.readInt();\n\t\tEntry[] elements = new Entry[in.readInt()];\n\t\tfor (int i = 0; i < elements.length; i++) {\n\t\t\telements[i] = (Entry) in.readObject();\n\t\t}\n\t\t// We could do this in one go, but it is slightly nicer not to modify\n\t\t// the state of this history object until we are successful reading\n\t\t// all the elements.\n\t\tmaxSize = newMaxSize;\n\t\thistory = new LinkedList<Entry>();\n\t\tfor (Entry element : elements) {\n\t\t\thistory.add(element);\n\t\t}\n\t\tisDirty = false;\n\t}\n\t/**\n\t * Save this history to a file\n\t * @throws IOException\n\t */\n\tpublic void save(File file) throws IOException {\n\t\tif (isDirty()) {\n\t\t\tFileOutputStream fOut = new FileOutputStream(file);\n\t\t\tObjectOutputStream oOut = null;\n\t\t\ttry {\n\t\t\t\toOut = new ObjectOutputStream(fOut);\n\t\t\t\tsave(oOut);\n\t\t\t\tisDirty = false;\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (oOut != null) {\n\t\t\t\t\toOut.close();\n\t\t\t\t}\n\t\t\t\telse if (fOut != null) {\n\t\t\t\t\tfOut.close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * Save this history to a file\n\t * @throws IOException\n\t */\n\tprivate void save(IPath file) throws IOException {\n\t\tsave(file.toFile());\n\t}\n\t/**\n\t * Save the state to an ObjectOutputStream, let someone else worry where\n\t * this stream came from and how to handle error / exception making sure the\n\t * stream is closed no matter what.\n\t */\n<fim_suffix>\tprivate void save(ObjectOutputStream out) throws IOException {\n\t\tout.writeInt(maxSize);\n\t\tout.writeInt(size());\n\t\tfor (Entry entry : history) {\n\t\t\tout.writeObject(entry);\n\t\t}\n\t}<fim_middle>// function below has no smell\n"}