{"text": "<fim_prefix>        break;\n      else\n      {\n        // Conflict exists, we need to kill a recording that's on an encoder that's capable\n        // of recording this\n        // Conflict resolution, ask about what you're going to kill\n        parallelRecords.remove(fakeAir);\n        if (lastParallel != null && parallelRecords.equals(lastParallel))\n          return VideoFrame.WATCH_FAILED_USER_REJECTED_CONFLICT;\n        Object hookRes = (uiClient == null) ? null : uiClient.processUIClientHook(\"RecordRequestScheduleConflict\", new Object[] { orgMR.getSchedulingAiring(),\n            parallelRecords });\n        if (!(hookRes instanceof Boolean) || !(((Boolean) hookRes)))\n          return VideoFrame.WATCH_FAILED_USER_REJECTED_CONFLICT;\n        lastParallel = new Vector<Airing>(parallelRecords);\n      }\n    } while (true);\n    wiz.modifyManualRecord(startTimeModify, endTimeModify, orgMR);\n    PluginEventManager.postEvent(PluginEventManager.MANUAL_RECORD_MODIFIED,\n        new Object[] { PluginEventManager.VAR_AIRING, orgMR.getSchedulingAiring() });\n    sched.kick(false);\n    return VideoFrame.WATCH_OK;\n  }\n<fim_suffix>  private int addManualRecord(Airing recAir, UIClient uiClient)\n  {\n    // Check to make sure we have an encoder that can receive this station\n    Set<EncoderState> tryUs = new HashSet<EncoderState>(encoderStateMap.values());\n    Iterator<EncoderState> walker = tryUs.iterator();\n    // We only need to worry about conflicts with other recordings that occur within the same set of stations. If\n    // encoder A has no intersection with the stations on encoder B; then there's no reason to prompt about conflicts from\n    // that tuner since it won't help resolve scheduling issues. So this set will be all the stations that either directly or\n    // indirectly could resolve a conflict with the new recording.\n    // Due to the indirect nature of this; we have to keep checking through the encoders until this set stops growing in size\n    Set<Integer> unifiedStationSet = new HashSet<Integer>();\n    boolean encoderExists = false;\n    while (walker.hasNext())\n    {\n      EncoderState es = walker.next();\n      synchronized (es.stationSet) {\n        if (es.stationSet.contains(recAir.stationID))\n        {\n          encoderExists = true;\n          unifiedStationSet.addAll(es.stationSet);\n          walker.remove(); // to avoid redundant checking below\n          break;\n        }\n      }\n    }\n    if (!encoderExists)\n      return VideoFrame.WATCH_FAILED_NO_ENCODERS_HAVE_STATION;\n    int lastSetSize;\n    do\n    {\n      lastSetSize = unifiedStationSet.size();\n      walker = tryUs.iterator();\n      while (walker.hasNext())\n      {\n        EncoderState es = walker.next();\n        synchronized (es.stationSet) {\n          if (unifiedStationSet.removeAll(es.stationSet))\n          {\n            // There was an intersection, so use all of these stations, then ignore this one for later\n            unifiedStationSet.addAll(es.stationSet);\n            walker.remove();\n          }\n        }\n      }\n    } while (lastSetSize != unifiedStationSet.size() && !tryUs.isEmpty());\n    long defaultStartPadding = Sage.getLong(\"default_mr_start_padding\", 0);\n    long defaultStopPadding = Sage.getLong(\"default_mr_stop_padding\", 0);\n    long requestedStart = recAir.getStartTime() - defaultStartPadding;\n    long requestedStop = recAir.getEndTime() + defaultStopPadding;\n    long requestedDuration = requestedStop - requestedStart;\n    Airing schedAir = recAir;\n    if (defaultStartPadding != 0 || defaultStopPadding != 0)\n    {\n      schedAir = new Airing(0);\n      schedAir.time = requestedStart;\n      schedAir.duration = requestedDuration;\n      schedAir.stationID = recAir.stationID;\n      schedAir.showID = recAir.showID;\n    }\n    Vector<Airing> parallelRecords = new Vector<Airing>();\n    Vector<Airing> lastParallel = null;\n    do\n    {\n      parallelRecords.clear();\n      ManualRecord[] manualMustSee = wiz.getManualRecordsSortedByTime();\n      Vector<ManualRecord> parallelRecurs = new Vector<ManualRecord>();\n      for (int i = 0; i < manualMustSee.length; i++)\n      {\n        ManualRecord currRec = manualMustSee[i];\n        if (currRec.getContentAiring() == recAir)\n          return VideoFrame.WATCH_OK;\n        if (currRec.getEndTime() <= Sage.time()) continue;\n        if (currRec.doRecurrencesOverlap(requestedStart, requestedDuration, 0))\n        {\n          parallelRecords.addElement(manualMustSee[i].getSchedulingAiring());\n          if (currRec.recur != 0)\n            parallelRecurs.add(currRec);\n          else\n            parallelRecurs.add(null);\n        }\n      }\n      if (parallelRecords.isEmpty()) break;\n      parallelRecords.addElement(schedAir);\n      parallelRecurs.add(null);\n      if (sched.testMultiTunerSchedulingPermutation(parallelRecords))\n        break;\n      // Remove any recurrence duplicates from the parallel list that is presented to the user\n      for (int i = 0; i < parallelRecurs.size(); i++)\n      {\n        ManualRecord currRecur = parallelRecurs.get(i);\n        if (currRecur == null) continue;\n        for (int j = 0; j < parallelRecords.size(); j++)\n        {\n          if (i == j || parallelRecurs.get(j) == null) continue;\n          ManualRecord otherRecur = parallelRecurs.get(j);\n          if (currRecur.stationID == otherRecur.stationID && currRecur.duration == otherRecur.duration &&\n              currRecur.recur == otherRecur.recur && currRecur.isSameRecurrence(otherRecur.startTime))\n          {\n            parallelRecurs.remove(j);\n            parallelRecords.remove(j);\n            j--;\n          }\n        }\n      }\n      // Conflict exists, we need to kill a recording that's on an encoder that's capable\n      // of recording this\n      // Conflict resolution, ask about what you're going to kill\n      parallelRecords.remove(schedAir);\n      // Remove any items from the conflict options that would not end up in station set overlap either directly or indirectly\n      for (int i = 0; i < parallelRecords.size(); i++)\n        if (!unifiedStationSet.contains(parallelRecords.get(i).stationID))\n          parallelRecords.remove(i--);\n      // If we have the same conflicts as when we just checked, then bail. Most likely they\n      // aren't processing the Hook correctly and we'll be in an infinite loop.\n      if (lastParallel != null && parallelRecords.equals(lastParallel))\n        return VideoFrame.WATCH_FAILED_USER_REJECTED_CONFLICT;\n      Object hookRes = (uiClient == null) ? null : uiClient.processUIClientHook(\"RecordRequestScheduleConflict\", new Object[] { recAir, parallelRecords });\n      if (!(hookRes instanceof Boolean) || !((Boolean) hookRes))\n        return VideoFrame.WATCH_FAILED_USER_REJECTED_CONFLICT;\n      lastParallel = new Vector<Airing>(parallelRecords);\n    } while (true);\n    ManualRecord newMR;\n    if (schedAir.getStartTime() < Sage.time())\n    {\n      int[] errorReturn = new int[1];\n      EncoderState es = findBestEncoderForNow(schedAir, true, uiClient, errorReturn);\n      if (es == null)\n      {\n        if (errorReturn[0] == 0)\n          errorReturn[0] = VideoFrame.WATCH_FAILED_GENERAL_CANT_FIND_ENCODER;\n        return errorReturn[0];\n      }\n      synchronized (this)\n      {\n        es = checkForFoundBestEncoderNowRecordSwitch(es, recAir);\n        // Set the acquisition state to manual if it has already started recording\n        MediaFile mf = wiz.getFileForAiring(recAir);\n        if (mf != null)\n          mf.setAcquisitionTech(MediaFile.ACQUISITION_MANUAL);\n        newMR = wiz.addManualRecord(requestedStart, requestedDuration, 0, recAir.stationID,\n            \"\", \"\", recAir.id, 0);\n        es.forceWatch = newMR.getSchedulingAiring();\n        es.forceProcessed = false;\n        work();\n      }\n    }\n    else\n      newMR = wiz.addManualRecord(requestedStart, requestedDuration, 0, recAir.stationID,\n          \"\", \"\", recAir.id, 0);\n    PluginEventManager.postEvent(PluginEventManager.MANUAL_RECORD_ADDED,\n        new Object[] { PluginEventManager.VAR_AIRING, newMR.getSchedulingAiring() });\n    return VideoFrame.WATCH_OK;\n  }<fim_middle>// function below is long method\n"}