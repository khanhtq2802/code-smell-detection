{"text": "<fim_prefix>/*****************************************************************\n *   Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n ****************************************************************/\n\npackage org.apache.cayenne.exp.parser;\n\nimport java.util.Collection;\n\nimport org.apache.cayenne.exp.Expression;\nimport org.apache.cayenne.exp.ValueInjector;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * \"Equal To\" expression.\n * \n * @since 1.1\n */\npublic class ASTEqual extends ConditionNode implements ValueInjector {\n\n\tprivate static final long serialVersionUID = 1211234198602067833L;\n\t\n\tprivate static final Logger LOGGER = LoggerFactory.getLogger(ASTEqual.class);\n\n\t/**\n\t * Constructor used by expression parser. Do not invoke directly.\n\t */\n\tASTEqual(int id) {\n\t\tsuper(id);\n\t}\n\n\tpublic ASTEqual() {\n\t\tsuper(ExpressionParserTreeConstants.JJTEQUAL);\n\t}\n\n\t/**\n\t * Creates \"Equal To\" expression.\n\t */\n\tpublic ASTEqual(SimpleNode path, Object value) {\n\t\tsuper(ExpressionParserTreeConstants.JJTEQUAL);\n\t\tjjtAddChild(path, 0);\n\t\tjjtAddChild(new ASTScalar(value), 1);\n\t\tconnectChildren();\n\t}\n\n\t@Override\n\tprotected int getRequiredChildrenCount() {\n\t\treturn 2;\n\t}\n\n\t@Override\n\tprotected Boolean evaluateSubNode(Object o, Object[] evaluatedChildren) throws Exception {\n\t\tObject o2 = evaluatedChildren[1];\n\t\treturn evaluateImpl(o, o2) ? Boolean.TRUE : Boolean.FALSE;\n\t}\n\n\t/**\n\t * Compares two objects, if one of them is array, 'in' operation is\n\t * performed\n\t */\n<fim_suffix>\tstatic boolean evaluateImpl(Object o1, Object o2) {\n\t\t// TODO: maybe we need a comparison \"strategy\" here, instead of\n\t\t// a switch of all possible cases? ... there were other requests for\n\t\t// more relaxed type-unsafe comparison (e.g. numbers to strings)\n\n\t\tif (o1 == null && o2 == null) {\n\t\t\treturn true;\n\t\t} else if (o1 != null) {\n\t\t\t// Per CAY-419 we perform 'in' comparison if one object is a list, and other is not\n\t\t\tif (o2 instanceof Collection) {\n\t\t\t\tfor (Object element : ((Collection<?>) o2)) {\n\t\t\t\t\tif (element != null && Evaluator.evaluator(element).eq(element, o1)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn Evaluator.evaluator(o1).eq(o1, o2);\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Creates a copy of this expression node, without copying children.\n\t */\n\t@Override\n\tpublic Expression shallowCopy() {\n\t\treturn new ASTEqual(id);\n\t}\n\n\t@Override\n\tprotected String getExpressionOperator(int index) {\n\t\treturn \"=\";\n\t}\n\n\t@Override\n\tprotected String getEJBQLExpressionOperator(int index) {\n\t\tif (jjtGetChild(1) instanceof ASTScalar && ((ASTScalar) jjtGetChild(1)).getValue() == null) {\n\t\t\t// for ejbql, we need \"is null\" instead of \"= null\"\n\t\t\treturn \"is\";\n\t\t}\n\t\treturn getExpressionOperator(index);\n\t}\n\n\t@Override\n\tpublic int getType() {\n\t\treturn Expression.EQUAL_TO;\n\t}\n\n\tpublic void injectValue(Object o) {\n\t\t// try to inject value, if one of the operands is scalar, and other is a\n\t\t// path\n\n\t\tNode[] args = new Node[] { jjtGetChild(0), jjtGetChild(1) };\n\n\t\tint scalarIndex = -1;\n\t\tif (args[0] instanceof ASTScalar) {\n\t\t\tscalarIndex = 0;\n\t\t} else if (args[1] instanceof ASTScalar) {\n\t\t\tscalarIndex = 1;\n\t\t}\n\n\t\tif (scalarIndex != -1 && args[1 - scalarIndex] instanceof ASTObjPath) {\n\t\t\t// inject\n\t\t\tASTObjPath path = (ASTObjPath) args[1 - scalarIndex];\n\t\t\ttry {\n\t\t\t\tpath.injectValue(o, evaluateChild(scalarIndex, o));\n\t\t\t} catch (Exception ex) {\n\t\t\t\tLOGGER.warn(\"Failed to inject value \" + \" on path \" + path.getPath() + \" to \" + o, ex);\n\t\t\t}\n\t\t}\n\t}\n}<fim_middle>// function below is long method\n"}