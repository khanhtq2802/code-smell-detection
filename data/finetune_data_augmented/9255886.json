{"text": "<fim_prefix>        // warns that @SuppressWarnings(\"unused\") is unnecessary.\n        public void emitCode(@SuppressWarnings(\"all\") CompilationResultBuilder crb, AArch64MacroAssembler masm) {\n            assert barriers >= MemoryBarriers.LOAD_LOAD && barriers <= (MemoryBarriers.STORE_STORE | MemoryBarriers.STORE_LOAD | MemoryBarriers.LOAD_STORE | MemoryBarriers.LOAD_LOAD);\n            switch (barriers) {\n                case MemoryBarriers.STORE_STORE:\n                    masm.dmb(AArch64MacroAssembler.BarrierKind.STORE_STORE);\n                    break;\n                case MemoryBarriers.LOAD_LOAD:\n                case MemoryBarriers.LOAD_STORE:\n                case MemoryBarriers.LOAD_LOAD | MemoryBarriers.LOAD_STORE:\n                    masm.dmb(AArch64MacroAssembler.BarrierKind.LOAD_LOAD);\n                    break;\n                default:\n                    masm.dmb(AArch64MacroAssembler.BarrierKind.ANY_ANY);\n                    break;\n            }\n        }\n    }\n    abstract static class MemOp extends AArch64LIRInstruction implements StandardOp.ImplicitNullCheck {\n        protected final AArch64Kind kind;\n        @Use({COMPOSITE}) protected AArch64AddressValue addressValue;\n        @State protected LIRFrameState state;\n        MemOp(LIRInstructionClass<? extends MemOp> c, AArch64Kind kind, AArch64AddressValue address, LIRFrameState state) {\n            super(c);\n            this.kind = kind;\n            this.addressValue = address;\n            this.state = state;\n        }\n        protected abstract void emitMemAccess(CompilationResultBuilder crb, AArch64MacroAssembler masm);\n        @Override\n        public void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {\n            if (state != null) {\n                crb.recordImplicitException(masm.position(), state);\n            }\n            emitMemAccess(crb, masm);\n        }\n        @Override\n        public boolean makeNullCheckFor(Value value, LIRFrameState nullCheckState, int implicitNullCheckLimit) {\n            int displacement = addressValue.getDisplacement();\n            if (state == null && value.equals(addressValue.getBase()) && addressValue.getOffset().equals(Value.ILLEGAL) && displacement >= 0 && displacement < implicitNullCheckLimit) {\n                state = nullCheckState;\n                return true;\n            }\n            return false;\n        }\n    }\n    public static final class LoadOp extends MemOp {\n        public static final LIRInstructionClass<LoadOp> TYPE = LIRInstructionClass.create(LoadOp.class);\n        @Def protected AllocatableValue result;\n        public LoadOp(AArch64Kind kind, AllocatableValue result, AArch64AddressValue address, LIRFrameState state) {\n            super(TYPE, kind, address, state);\n            this.result = result;\n        }\n        @Override\n        protected void emitMemAccess(CompilationResultBuilder crb, AArch64MacroAssembler masm) {\n            AArch64Address address = addressValue.toAddress();\n            Register dst = asRegister(result);\n            int destSize = result.getPlatformKind().getSizeInBytes() * Byte.SIZE;\n            int srcSize = kind.getSizeInBytes() * Byte.SIZE;\n            if (kind.isInteger()) {\n                masm.ldr(srcSize, dst, address);\n            } else {\n                assert srcSize == destSize;\n                masm.fldr(srcSize, dst, address);\n            }\n        }\n    }\n    public static class StoreOp extends MemOp {\n        public static final LIRInstructionClass<StoreOp> TYPE = LIRInstructionClass.create(StoreOp.class);\n        @Use protected AllocatableValue input;\n        public StoreOp(AArch64Kind kind, AArch64AddressValue address, AllocatableValue input, LIRFrameState state) {\n            super(TYPE, kind, address, state);\n            this.input = input;\n        }\n        @Override\n        protected void emitMemAccess(CompilationResultBuilder crb, AArch64MacroAssembler masm) {\n            emitStore(crb, masm, kind, addressValue.toAddress(), input);\n        }\n    }\n    public static final class StoreConstantOp extends MemOp {\n        public static final LIRInstructionClass<StoreConstantOp> TYPE = LIRInstructionClass.create(StoreConstantOp.class);\n        protected final JavaConstant input;\n        public StoreConstantOp(AArch64Kind kind, AArch64AddressValue address, JavaConstant input, LIRFrameState state) {\n            super(TYPE, kind, address, state);\n            this.input = input;\n            if (!input.isDefaultForKind()) {\n                throw GraalError.shouldNotReachHere(\"Can only store null constants to memory\");\n            }\n        }\n        @Override\n        public void emitMemAccess(CompilationResultBuilder crb, AArch64MacroAssembler masm) {\n            emitStore(crb, masm, kind, addressValue.toAddress(), zr.asValue(LIRKind.combine(addressValue)));\n        }\n    }\n    public static final class NullCheckOp extends AArch64LIRInstruction implements NullCheck {\n        public static final LIRInstructionClass<NullCheckOp> TYPE = LIRInstructionClass.create(NullCheckOp.class);\n        @Use(COMPOSITE) protected AArch64AddressValue address;\n        @State protected LIRFrameState state;\n        public NullCheckOp(AArch64AddressValue address, LIRFrameState state) {\n            super(TYPE);\n            this.address = address;\n            this.state = state;\n        }\n        @Override\n        public void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {\n            crb.recordImplicitException(masm.position(), state);\n            masm.ldr(64, zr, address.toAddress());\n        }\n        @Override\n        public Value getCheckedValue() {\n            return address.base;\n        }\n        @Override\n        public LIRFrameState getState() {\n            return state;\n        }\n    }\n    private static void emitStore(@SuppressWarnings(\"unused\") CompilationResultBuilder crb, AArch64MacroAssembler masm, AArch64Kind kind, AArch64Address dst, Value src) {\n        int destSize = kind.getSizeInBytes() * Byte.SIZE;\n        if (kind.isInteger()) {\n            masm.str(destSize, asRegister(src), dst);\n        } else {\n            masm.fstr(destSize, asRegister(src), dst);\n        }\n    }\n    public static void move(CompilationResultBuilder crb, AArch64MacroAssembler masm, AllocatableValue result, Value input) {\n        if (isRegister(input)) {\n            if (isRegister(result)) {\n                reg2reg(crb, masm, result, asAllocatableValue(input));\n            } else if (isStackSlot(result)) {\n                reg2stack(crb, masm, result, asAllocatableValue(input));\n            } else {\n                throw GraalError.shouldNotReachHere();\n            }\n        } else if (isStackSlot(input)) {\n            if (isRegister(result)) {\n                stack2reg(crb, masm, result, asAllocatableValue(input));\n            } else if (isStackSlot(result)) {\n                emitStackMove(crb, masm, result, input);\n            } else {\n                throw GraalError.shouldNotReachHere();\n            }\n        } else if (isJavaConstant(input)) {\n            if (isRegister(result)) {\n                const2reg(crb, masm, result, asJavaConstant(input));\n            } else {\n                throw GraalError.shouldNotReachHere();\n            }\n        } else {\n            throw GraalError.shouldNotReachHere();\n        }\n    }\n<fim_suffix>    private static void emitStackMove(CompilationResultBuilder crb, AArch64MacroAssembler masm, AllocatableValue result, Value input) {\n        try (ScratchRegister r1 = masm.getScratchRegister()) {\n            try (ScratchRegister r2 = masm.getScratchRegister()) {\n                Register rscratch1 = r1.getRegister();\n                Register rscratch2 = r2.getRegister();\n                // use the slot kind to define the operand size\n                PlatformKind kind = input.getPlatformKind();\n                final int size = kind.getSizeInBytes() * Byte.SIZE;\n                // Always perform stack -> stack copies through integer registers\n                crb.blockComment(\"[stack -> stack copy]\");\n                AArch64Address src = loadStackSlotAddress(crb, masm, asStackSlot(input), rscratch2);\n                masm.ldr(size, rscratch1, src);\n                AArch64Address dst = loadStackSlotAddress(crb, masm, asStackSlot(result), rscratch2);\n                masm.str(size, rscratch1, dst);\n            }\n        }\n    }<fim_middle>// function below has no smell\n"}