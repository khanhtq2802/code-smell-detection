{"text": "<fim_prefix>        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(src);\n        InflaterInputStream inflaterInputStream = new InflaterInputStream(byteArrayInputStream);\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(src.length);\n        try {\n            while (true) {\n                int len = inflaterInputStream.read(uncompressData, 0, uncompressData.length);\n                if (len <= 0) {\n                    break;\n                }\n                byteArrayOutputStream.write(uncompressData, 0, len);\n            }\n            byteArrayOutputStream.flush();\n            result = byteArrayOutputStream.toByteArray();\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            try {\n                byteArrayInputStream.close();\n            } catch (IOException e) {\n                log.error(\"Failed to close the stream\", e);\n            }\n            try {\n                inflaterInputStream.close();\n            } catch (IOException e) {\n                log.error(\"Failed to close the stream\", e);\n            }\n            try {\n                byteArrayOutputStream.close();\n            } catch (IOException e) {\n                log.error(\"Failed to close the stream\", e);\n            }\n        }\n        return result;\n    }\n    public static byte[] compress(final byte[] src, final int level) throws IOException {\n        byte[] result = src;\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(src.length);\n        java.util.zip.Deflater defeater = new java.util.zip.Deflater(level);\n        DeflaterOutputStream deflaterOutputStream = new DeflaterOutputStream(byteArrayOutputStream, defeater);\n        try {\n            deflaterOutputStream.write(src);\n            deflaterOutputStream.finish();\n            deflaterOutputStream.close();\n            result = byteArrayOutputStream.toByteArray();\n        } catch (IOException e) {\n            defeater.end();\n            throw e;\n        } finally {\n            try {\n                byteArrayOutputStream.close();\n            } catch (IOException ignored) {\n            }\n            defeater.end();\n        }\n        return result;\n    }\n    public static int asInt(String str, int defaultValue) {\n        try {\n            return Integer.parseInt(str);\n        } catch (Exception e) {\n            return defaultValue;\n        }\n    }\n    public static long asLong(String str, long defaultValue) {\n        try {\n            return Long.parseLong(str);\n        } catch (Exception e) {\n            return defaultValue;\n        }\n    }\n    public static String formatDate(Date date, String pattern) {\n        SimpleDateFormat df = new SimpleDateFormat(pattern);\n        return df.format(date);\n    }\n    public static Date parseDate(String date, String pattern) {\n        SimpleDateFormat df = new SimpleDateFormat(pattern);\n        try {\n            return df.parse(date);\n        } catch (ParseException e) {\n            return null;\n        }\n    }\n    public static String responseCode2String(final int code) {\n        return Integer.toString(code);\n    }\n    public static String frontStringAtLeast(final String str, final int size) {\n        if (str != null) {\n            if (str.length() > size) {\n                return str.substring(0, size);\n            }\n        }\n        return str;\n    }\n    public static boolean isBlank(String str) {\n        int strLen;\n        if (str == null || (strLen = str.length()) == 0) {\n            return true;\n        }\n        for (int i = 0; i < strLen; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n    public static String jstack() {\n        return jstack(Thread.getAllStackTraces());\n    }\n    public static String jstack(Map<Thread, StackTraceElement[]> map) {\n        StringBuilder result = new StringBuilder();\n        try {\n            Iterator<Map.Entry<Thread, StackTraceElement[]>> ite = map.entrySet().iterator();\n            while (ite.hasNext()) {\n                Map.Entry<Thread, StackTraceElement[]> entry = ite.next();\n                StackTraceElement[] elements = entry.getValue();\n                Thread thread = entry.getKey();\n                if (elements != null && elements.length > 0) {\n                    String threadName = entry.getKey().getName();\n                    result.append(String.format(\"%-40sTID: %d STATE: %s%n\", threadName, thread.getId(), thread.getState()));\n                    for (StackTraceElement el : elements) {\n                        result.append(String.format(\"%-40s%s%n\", threadName, el.toString()));\n                    }\n                    result.append(\"\\n\");\n                }\n            }\n        } catch (Throwable e) {\n            result.append(RemotingHelper.exceptionSimpleDesc(e));\n        }\n        return result.toString();\n    }\n    public static boolean isInternalIP(byte[] ip) {\n        if (ip.length != 4) {\n            throw new RuntimeException(\"illegal ipv4 bytes\");\n        }\n        //10.0.0.0~10.255.255.255\n        //172.16.0.0~172.31.255.255\n        //192.168.0.0~192.168.255.255\n        if (ip[0] == (byte) 10) {\n            return true;\n        } else if (ip[0] == (byte) 172) {\n            if (ip[1] >= (byte) 16 && ip[1] <= (byte) 31) {\n                return true;\n            }\n        } else if (ip[0] == (byte) 192) {\n            if (ip[1] == (byte) 168) {\n                return true;\n            }\n        }\n        return false;\n    }\n    private static boolean ipCheck(byte[] ip) {\n        if (ip.length != 4) {\n            throw new RuntimeException(\"illegal ipv4 bytes\");\n        }\n//        if (ip[0] == (byte)30 && ip[1] == (byte)10 && ip[2] == (byte)163 && ip[3] == (byte)120) {\n//        }\n        if (ip[0] >= (byte) 1 && ip[0] <= (byte) 126) {\n            if (ip[1] == (byte) 1 && ip[2] == (byte) 1 && ip[3] == (byte) 1) {\n                return false;\n            }\n            if (ip[1] == (byte) 0 && ip[2] == (byte) 0 && ip[3] == (byte) 0) {\n                return false;\n            }\n            return true;\n        } else if (ip[0] >= (byte) 128 && ip[0] <= (byte) 191) {\n            if (ip[2] == (byte) 1 && ip[3] == (byte) 1) {\n                return false;\n            }\n            if (ip[2] == (byte) 0 && ip[3] == (byte) 0) {\n                return false;\n            }\n            return true;\n        } else if (ip[0] >= (byte) 192 && ip[0] <= (byte) 223) {\n            if (ip[3] == (byte) 1) {\n                return false;\n            }\n            if (ip[3] == (byte) 0) {\n                return false;\n            }\n            return true;\n        }\n        return false;\n    }\n    public static String ipToIPv4Str(byte[] ip) {\n        if (ip.length != 4) {\n            return null;\n        }\n        return new StringBuilder().append(ip[0] & 0xFF).append(\".\").append(\n            ip[1] & 0xFF).append(\".\").append(ip[2] & 0xFF)\n            .append(\".\").append(ip[3] & 0xFF).toString();\n    }\n<fim_suffix>    public static byte[] getIP() {\n        try {\n            Enumeration allNetInterfaces = NetworkInterface.getNetworkInterfaces();\n            InetAddress ip = null;\n            byte[] internalIP = null;\n            while (allNetInterfaces.hasMoreElements()) {\n                NetworkInterface netInterface = (NetworkInterface) allNetInterfaces.nextElement();\n                Enumeration addresses = netInterface.getInetAddresses();\n                while (addresses.hasMoreElements()) {\n                    ip = (InetAddress) addresses.nextElement();\n                    if (ip != null && ip instanceof Inet4Address) {\n                        byte[] ipByte = ip.getAddress();\n                        if (ipByte.length == 4) {\n                            if (ipCheck(ipByte)) {\n                                if (!isInternalIP(ipByte)) {\n                                    return ipByte;\n                                } else if (internalIP == null) {\n                                    internalIP = ipByte;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            if (internalIP != null) {\n                return internalIP;\n            } else {\n                throw new RuntimeException(\"Can not get local ip\");\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Can not get local ip\", e);\n        }\n    }<fim_middle>// function below is long method\n"}