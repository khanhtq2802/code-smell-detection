{"text": "<fim_prefix>     *\n     * @param input map of elements\n     * @return list of option models\n     */\n    public static <K, V> List<OptionModel> toOptionModels(Map<K, V> input)\n    {\n        assert input != null;\n        List<OptionModel> result = CollectionFactory.newList();\n        for (Map.Entry entry : input.entrySet())\n            result.add(toOptionModel(entry));\n        return result;\n    }\n    /**\n     * Wraps the result of {@link #toOptionModels(Map)} as a {@link SelectModel} (with no option groups).\n     */\n    public static <K, V> SelectModel toSelectModel(Map<K, V> input)\n    {\n        List<OptionModel> options = toOptionModels(input);\n        return new SelectModelImpl(null, options);\n    }\n    /**\n     * Converts an object to an {@link OptionModel}.\n     */\n    public static OptionModel toOptionModel(Object input)\n    {\n        String label = (input != null ? String.valueOf(input) : \"\");\n        return new OptionModelImpl(label, input);\n    }\n    /**\n     * Processes a list input into a series of objects compatible with {@link #toOptionModel(Object)}.\n     *\n     * @param input list of elements\n     * @return list of option models\n     */\n    public static <E> List<OptionModel> toOptionModels(List<E> input)\n    {\n        assert input != null;\n        List<OptionModel> result = CollectionFactory.newList();\n        for (E element : input)\n            result.add(toOptionModel(element));\n        return result;\n    }\n    /**\n     * Wraps the result of {@link #toOptionModels(List)} as a {@link SelectModel} (with no option groups).\n     */\n    public static <E> SelectModel toSelectModel(List<E> input)\n    {\n        List<OptionModel> options = toOptionModels(input);\n        return new SelectModelImpl(null, options);\n    }\n    /**\n     * Parses a key/value pair where the key and the value are seperated by an equals sign. The key and value are\n     * trimmed of leading and trailing whitespace, and returned as a {@link KeyValue}.\n     */\n    public static KeyValue parseKeyValue(String input)\n    {\n        int pos = input.indexOf('=');\n        if (pos < 1)\n            throw new IllegalArgumentException(String.format(\"Key/value pair '%s' is not properly formatted (it does not contain an equals sign).\", input));\n        String key = input.substring(0, pos);\n        String value = input.substring(pos + 1);\n        return new KeyValue(key.trim(), value.trim());\n    }\n    /**\n     * Used to convert a property expression into a key that can be used to locate various resources (Blocks, messages,\n     * etc.). Strips out any punctuation characters, leaving just words characters (letters, number and the\n     * underscore).\n     *\n     * @param expression a property expression\n     * @return the expression with punctuation removed\n     */\n    public static String extractIdFromPropertyExpression(String expression)\n    {\n        return InternalUtils.extractIdFromPropertyExpression(expression);\n    }\n    /**\n     * Looks for a label within the messages based on the id. If found, it is used, otherwise the name is converted to a\n     * user presentable form.\n     */\n    public static String defaultLabel(String id, Messages messages, String propertyExpression)\n    {\n        return InternalUtils.defaultLabel(id, messages, propertyExpression);\n    }\n    /**\n     * Strips a dotted sequence (such as a property expression, or a qualified class name) down to the last term of that\n     * expression, by locating the last period ('.') in the string.\n     */\n    public static String lastTerm(String input)\n    {\n        int dotx = input.lastIndexOf('.');\n        return input.substring(dotx + 1);\n    }\n    /**\n     * Converts an list of strings into a space-separated string combining them all, suitable for use as an HTML class\n     * attribute value.\n     *\n     * @param classes classes to combine\n     * @return the joined classes, or null if classes is empty\n     */\n    public static String toClassAttributeValue(List<String> classes)\n    {\n        if (classes.isEmpty())\n            return null;\n        return InternalUtils.join(classes, \" \");\n    }\n    /**\n     * Converts an enum to a label string, allowing for overrides from a message catalog.\n     *\n     * <ul>\n     * <li>As key <em>prefix</em>.<em>name</em> if present. Ex: \"ElementType.LOCAL_VARIABLE\"\n     * <li>As key <em>name</em> if present, i.e., \"LOCAL_VARIABLE\".\n     * <li>As a user-presentable version of the name, i.e., \"Local Variable\".\n     * </ul>\n     *\n     * @param messages the messages to search for the label\n     * @param prefix   prepended to key\n     * @param value    to get a label for\n     * @return the label\n     */\n    public static String getLabelForEnum(Messages messages, String prefix, Enum value)\n    {\n        String name = value.name();\n        String key = prefix + \".\" + name;\n        if (messages.contains(key))\n            return messages.get(key);\n        if (messages.contains(name))\n            return messages.get(name);\n        return toUserPresentable(name.toLowerCase());\n    }\n    public static String getLabelForEnum(Messages messages, Enum value)\n    {\n        String prefix = lastTerm(value.getClass().getName());\n        return getLabelForEnum(messages, prefix, value);\n    }\n    private static String replace(String input, Pattern pattern, String replacement)\n    {\n        return InternalUtils.replace(input, pattern, replacement);\n    }\n    /**\n     * Determines if the two values are equal. They are equal if they are the exact same value (including if they are\n     * both null). Otherwise standard equals() comparison is used.\n     *\n     * @param left  value to compare, possibly null\n     * @param right value to compare, possibly null\n     * @return true if same value, both null, or equal\n     */\n    public static <T> boolean isEqual(T left, T right)\n    {\n        if (left == right)\n            return true;\n        if (left == null)\n            return false;\n        return left.equals(right);\n    }\n    /**\n     * Splits a path at each slash.\n     */\n    public static String[] splitPath(String path)\n    {\n        return SLASH_PATTERN.split(path);\n    }\n    /**\n     * Splits a value around commas. Whitespace around the commas is removed, as is leading and trailing whitespace.\n     *\n     * @since 5.1.0.0\n     */\n    public static String[] splitAtCommas(String value)\n    {\n        if (InternalUtils.isBlank(value))\n            return InternalConstants.EMPTY_STRING_ARRAY;\n        return COMMA_PATTERN.split(value.trim());\n    }\n    /**\n     * Copies some content from an input stream to an output stream. It is the caller's responsibility to close the\n     * streams.\n     *\n     * @param in  source of data\n     * @param out sink of data\n     * @throws IOException\n     * @since 5.1.0.0\n     */\n    public static void copy(InputStream in, OutputStream out) throws IOException\n    {\n        byte[] buffer = new byte[BUFFER_SIZE];\n        while (true)\n        {\n            int length = in.read(buffer);\n            if (length < 0)\n                break;\n            out.write(buffer, 0, length);\n        }\n        // TAPESTRY-2415: WebLogic needs this flush() call.\n        out.flush();\n    }\n    public static boolean isEqual(EventContext left, EventContext right)\n    {\n        if (left == right)\n            return true;\n        int count = left.getCount();\n        if (count != right.getCount())\n            return false;\n        for (int i = 0; i < count; i++)\n        {\n            if (!left.get(Object.class, i).equals(right.get(Object.class, i)))\n                return false;\n        }\n        return true;\n    }\n    /**\n     * Converts an Asset to an Asset2 if necessary. When actually wrapping an Asset as an Asset2, the asset is assumed\n     * to be variant (i.e., not cacheable).\n     *\n     * @since 5.1.0.0\n     */\n<fim_suffix>    public static Asset2 toAsset2(final Asset asset)\n    {\n        if (asset instanceof Asset2)\n            return (Asset2) asset;\n        return new Asset2()\n        {\n            /** Returns false. */\n            public boolean isInvariant()\n            {\n                return false;\n            }\n            public Resource getResource()\n            {\n                return asset.getResource();\n            }\n            public String toClientURL()\n            {\n                return asset.toClientURL();\n            }\n            @Override\n            public String toString()\n            {\n                return asset.toString();\n            }\n        };\n    }<fim_middle>// function below has no smell\n"}