{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.karaf.shell.ssh;\n\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.nio.charset.Charset;\nimport java.util.Map;\n\nimport javax.security.auth.Subject;\n\nimport org.apache.karaf.shell.api.console.Session;\nimport org.apache.karaf.shell.api.console.SessionFactory;\nimport org.apache.karaf.shell.support.ShellUtil;\nimport org.apache.karaf.util.jaas.JaasHelper;\nimport org.apache.sshd.common.Factory;\nimport org.apache.sshd.server.Command;\nimport org.apache.sshd.server.Environment;\nimport org.apache.sshd.server.ExitCallback;\nimport org.apache.sshd.server.SessionAware;\nimport org.apache.sshd.server.session.ServerSession;\n\n/**\n * SSHD {@link org.apache.sshd.server.Command} factory which provides access to\n * Shell.\n */\n<fim_suffix>public class ShellFactoryImpl implements Factory<Command> {\n    private SessionFactory sessionFactory;\n\n    public ShellFactoryImpl(SessionFactory sessionFactory) {\n        this.sessionFactory = sessionFactory;\n    }\n\n    public Command create() {\n        return new ShellImpl();\n    }\n\n    public class ShellImpl implements Command, SessionAware {\n        private InputStream in;\n\n        private OutputStream out;\n\n        private OutputStream err;\n\n        private ExitCallback callback;\n\n        private ServerSession session;\n\n        private Session shell;\n\n        private SshTerminal terminal;\n\n        private boolean closed;\n\n        public void setInputStream(final InputStream in) {\n            this.in = in;\n        }\n\n        public void setOutputStream(final OutputStream out) {\n            this.out = out;\n        }\n\n        public void setErrorStream(final OutputStream err) {\n            this.err = err;\n        }\n\n        public void setExitCallback(ExitCallback callback) {\n            this.callback = callback;\n        }\n\n        public void setSession(ServerSession session) {\n            this.session = session;\n        }\n\n        public void start(final Environment env) throws IOException {\n            try {\n                final Subject subject = ShellImpl.this.session != null ? ShellImpl.this.session\n                        .getAttribute(KarafJaasAuthenticator.SUBJECT_ATTRIBUTE_KEY) : null;\n                String encoding = getEncoding(env);\n                terminal = new SshTerminal(env, in, out, encoding);\n                final PrintStream pout = new PrintStream(terminal.output(), true, encoding);\n                final PrintStream perr = err instanceof PrintStream ?\n                        (PrintStream) err : out == err ? pout : new PrintStream(err, true, encoding);\n                shell = sessionFactory.create(in, pout,\n                        perr, terminal, encoding, this::destroy);\n                for (Map.Entry<String, String> e : env.getEnv().entrySet()) {\n                    shell.put(e.getKey(), e.getValue());\n                }\n                JaasHelper.runAs(subject, () ->\n                    new Thread(shell, \"Karaf ssh console user \" + ShellUtil.getCurrentUserName()).start());\n            } catch (Exception e) {\n                throw new IOException(\"Unable to start shell\", e);\n            }\n        }\n\n        public void destroy() {\n            if (!closed) {\n                closed = true;\n                flush(out, err);\n                close(in, out, err);\n                callback.onExit(0);\n            }\n        }\n\n    }\n\n    /**\n     * Get the default encoding.  Will first look at the LC_CTYPE environment variable, then the input.encoding\n     * system property, then the default charset according to the JVM.\n     *\n     * @return The default encoding to use when none is specified.\n     */\n    public static String getEncoding(Environment env) {\n        // LC_CTYPE is usually in the form en_US.UTF-8\n        String ctype = env.getEnv().getOrDefault(\"LC_TYPE\", System.getenv(\"LC_CTYPE\"));\n        String envEncoding = extractEncodingFromCtype(ctype);\n        if (envEncoding != null) {\n            return envEncoding;\n        }\n        return System.getProperty(\"input.encoding\", Charset.defaultCharset().name());\n    }\n\n    /**\n     * Parses the LC_CTYPE value to extract the encoding according to the POSIX standard, which says that the LC_CTYPE\n     * environment variable may be of the format <code>[language[_territory][.codeset][@modifier]]</code>\n     *\n     * @param ctype The ctype to parse, may be null\n     * @return The encoding, if one was present, otherwise null\n     */\n    static String extractEncodingFromCtype(String ctype) {\n        if (ctype != null && ctype.indexOf('.') > 0) {\n            String encodingAndModifier = ctype.substring(ctype.indexOf('.') + 1);\n            if (encodingAndModifier.indexOf('@') > 0) {\n                return encodingAndModifier.substring(0, encodingAndModifier.indexOf('@'));\n            } else {\n                return encodingAndModifier;\n            }\n        }\n        return null;\n    }\n\n    private static void flush(OutputStream... streams) {\n        for (OutputStream s : streams) {\n            try {\n                s.flush();\n            } catch (IOException e) {\n                // Ignore\n            }\n        }\n    }\n\n    private static void close(Closeable... closeables) {\n        for (Closeable c : closeables) {\n            try {\n                c.close();\n            } catch (Exception e) {\n                // Ignore\n            }\n        }\n    }\n\n}<fim_middle>// class below has no smell\n"}