{"text": "<fim_prefix> *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.activemq.artemis.core.server.cluster;\nimport org.apache.activemq.artemis.api.core.ActiveMQException;\nimport org.apache.activemq.artemis.api.core.SimpleString;\nimport org.apache.activemq.artemis.api.core.TransportConfiguration;\nimport org.apache.activemq.artemis.core.client.impl.ClientSessionFactoryInternal;\nimport org.apache.activemq.artemis.core.config.ClusterConnectionConfiguration;\nimport org.apache.activemq.artemis.core.config.ConfigurationUtils;\nimport org.apache.activemq.artemis.core.protocol.core.Channel;\nimport org.apache.activemq.artemis.core.protocol.core.CoreRemotingConnection;\nimport org.apache.activemq.artemis.core.protocol.core.impl.ChannelImpl;\nimport org.apache.activemq.artemis.core.protocol.core.impl.PacketImpl;\nimport org.apache.activemq.artemis.core.protocol.core.impl.wireformat.BackupRegistrationMessage;\nimport org.apache.activemq.artemis.core.protocol.core.impl.wireformat.BackupRequestMessage;\nimport org.apache.activemq.artemis.core.protocol.core.impl.wireformat.BackupResponseMessage;\nimport org.apache.activemq.artemis.core.protocol.core.impl.wireformat.ClusterConnectMessage;\nimport org.apache.activemq.artemis.core.protocol.core.impl.wireformat.ClusterConnectReplyMessage;\nimport org.apache.activemq.artemis.core.protocol.core.impl.wireformat.NodeAnnounceMessage;\nimport org.apache.activemq.artemis.core.protocol.core.impl.wireformat.QuorumVoteMessage;\nimport org.apache.activemq.artemis.core.protocol.core.impl.wireformat.QuorumVoteReplyMessage;\nimport org.apache.activemq.artemis.core.protocol.core.impl.wireformat.ScaleDownAnnounceMessage;\nimport org.apache.activemq.artemis.core.server.ActiveMQMessageBundle;\nimport org.apache.activemq.artemis.core.server.ActiveMQServer;\nimport org.apache.activemq.artemis.core.server.ActiveMQServerLogger;\nimport org.apache.activemq.artemis.core.server.cluster.qourum.QuorumVoteHandler;\nimport org.apache.activemq.artemis.core.server.cluster.qourum.Vote;\n/**\n * handles the communication between a cluster node and the cluster, either the whole cluster or a specific node in the\n * cluster such as a replicating node.\n */\n<fim_suffix>public class ClusterControl implements AutoCloseable {\n   private Channel clusterChannel;\n   private final ClientSessionFactoryInternal sessionFactory;\n   private final ActiveMQServer server;\n   private final String clusterUser;\n   private final String clusterPassword;\n   public ClusterControl(ClientSessionFactoryInternal sessionFactory, ActiveMQServer server) {\n      this.sessionFactory = sessionFactory;\n      this.server = server;\n      this.clusterUser = server.getConfiguration().getClusterUser();\n      this.clusterPassword = server.getConfiguration().getClusterPassword();\n   }\n   /**\n    * authorise this cluster control so it can communicate with the cluster, it will set the cluster channel on a successful\n    * authentication.\n    *\n    * @throws ActiveMQException if authorisation wasn't successful.\n    */\n   public void authorize() throws ActiveMQException {\n      CoreRemotingConnection connection = (CoreRemotingConnection) sessionFactory.getConnection();\n      clusterChannel = connection.getChannel(ChannelImpl.CHANNEL_ID.CLUSTER.id, -1);\n      ClusterConnectReplyMessage packet = (ClusterConnectReplyMessage) clusterChannel.sendBlocking(new ClusterConnectMessage(clusterUser, clusterPassword), PacketImpl.CLUSTER_CONNECT_REPLY);\n      if (!packet.isAuthorized()) {\n         throw ActiveMQMessageBundle.BUNDLE.unableToValidateClusterUser(clusterUser);\n      }\n   }\n   /**\n    * XXX HORNETQ-720\n    *\n    * @param attemptingFailBack if {@code true} then this server wants to trigger a fail-back when\n    *                           up-to-date, that is it wants to take over the role of 'live' from the current 'live'\n    *                           server.\n    * @throws ActiveMQException\n    */\n   public void announceReplicatingBackupToLive(final boolean attemptingFailBack,\n                                               String replicationClusterName) throws ActiveMQException {\n      ClusterConnectionConfiguration config = ConfigurationUtils.getReplicationClusterConfiguration(server.getConfiguration(), replicationClusterName);\n      if (config == null) {\n         ActiveMQServerLogger.LOGGER.announceBackupNoClusterConnections();\n         throw new ActiveMQException(\"lacking cluster connection\");\n      }\n      TransportConfiguration connector = server.getConfiguration().getConnectorConfigurations().get(config.getConnectorName());\n      if (connector == null) {\n         ActiveMQServerLogger.LOGGER.announceBackupNoConnector(config.getConnectorName());\n         throw new ActiveMQException(\"lacking cluster connection\");\n      }\n      clusterChannel.send(new BackupRegistrationMessage(connector, clusterUser, clusterPassword, attemptingFailBack));\n   }\n   /**\n    * announce this node to the cluster.\n    *\n    * @param currentEventID     used if multiple announcements about this node are made.\n    * @param nodeID             the node id if the announcing node\n    * @param backupGroupName    the backup group name.\n    * @param scaleDownGroupName the scaledown group name\n    * @param isBackup           are we a backup\n    * @param config             the transports config\n    * @param backupConfig       the transports backup config\n    */\n   public void sendNodeAnnounce(final long currentEventID,\n                                String nodeID,\n                                String backupGroupName,\n                                String scaleDownGroupName,\n                                boolean isBackup,\n                                TransportConfiguration config,\n                                TransportConfiguration backupConfig) {\n      clusterChannel.send(new NodeAnnounceMessage(currentEventID, nodeID, backupGroupName, scaleDownGroupName, isBackup, config, backupConfig));\n   }\n   /**\n    * create a replication channel\n    *\n    * @return the replication channel\n    */\n   public Channel createReplicationChannel() {\n      CoreRemotingConnection connection = (CoreRemotingConnection) sessionFactory.getConnection();\n      return connection.getChannel(ChannelImpl.CHANNEL_ID.REPLICATION.id, -1);\n   }\n   /**\n    * get the session factory used to connect to the cluster\n    *\n    * @return the session factory\n    */\n   public ClientSessionFactoryInternal getSessionFactory() {\n      return sessionFactory;\n   }\n   /**\n    * close this cluster control and its resources\n    */\n   @Override\n   public void close() {\n      sessionFactory.close();\n   }\n   public Vote sendQuorumVote(SimpleString handler, Vote vote) {\n      try {\n         ActiveMQServerLogger.LOGGER.sendingQuorumVoteRequest(getSessionFactory().getConnection().getRemoteAddress(), vote.toString());\n         QuorumVoteReplyMessage replyMessage = (QuorumVoteReplyMessage) clusterChannel.sendBlocking(new QuorumVoteMessage(handler, vote), PacketImpl.QUORUM_VOTE_REPLY);\n         QuorumVoteHandler voteHandler = server.getClusterManager().getQuorumManager().getVoteHandler(replyMessage.getHandler());\n         replyMessage.decodeRest(voteHandler);\n         Vote voteResponse = replyMessage.getVote();\n         ActiveMQServerLogger.LOGGER.receivedQuorumVoteResponse(getSessionFactory().getConnection().getRemoteAddress(), voteResponse.toString());\n         return voteResponse;\n      } catch (ActiveMQException e) {\n         return null;\n      }\n   }\n   public boolean requestReplicatedBackup(int backupSize, SimpleString nodeID) {\n      BackupRequestMessage backupRequestMessage = new BackupRequestMessage(backupSize, nodeID);\n      return requestBackup(backupRequestMessage);\n   }\n   private boolean requestBackup(BackupRequestMessage backupRequestMessage) {\n      BackupResponseMessage packet;\n      try {\n         packet = (BackupResponseMessage) clusterChannel.sendBlocking(backupRequestMessage, PacketImpl.BACKUP_REQUEST_RESPONSE);\n      } catch (ActiveMQException e) {\n         return false;\n      }\n      return packet.isBackupStarted();\n   }\n   public boolean requestSharedStoreBackup(int backupSize,\n                                           String journalDirectory,\n                                           String bindingsDirectory,\n                                           String largeMessagesDirectory,\n                                           String pagingDirectory) {\n      BackupRequestMessage backupRequestMessage = new BackupRequestMessage(backupSize, journalDirectory, bindingsDirectory, largeMessagesDirectory, pagingDirectory);\n      return requestBackup(backupRequestMessage);\n   }\n   public void announceScaleDown(SimpleString targetNodeId, SimpleString scaledDownNodeId) {\n      ScaleDownAnnounceMessage announceMessage = new ScaleDownAnnounceMessage(targetNodeId, scaledDownNodeId);\n      clusterChannel.send(announceMessage);\n   }\n   public String getClusterUser() {\n      return clusterUser;\n   }\n   public String getClusterPassword() {\n      return clusterPassword;\n   }\n}<fim_middle>// class below has no smell\n"}