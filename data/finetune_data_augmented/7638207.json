{"text": "<fim_prefix>\n<fim_suffix>public class CloudCliServiceLaunchConfigurationDelegate extends BootCliLaunchConfigurationDelegate {\n\tprivate static final VersionRange SPRING_CLOUD_CLI_SINGLE_PROCESS_VERSION_RANGE = new VersionRange(\"1.3.0\");\n\tpublic final static String TYPE_ID = \"org.springframework.ide.eclipse.boot.launch.cloud.cli.service\";\n\tpublic final static String ATTR_CLOUD_SERVICE_ID = \"local-cloud-service-id\";\n\tprivate final static String PREF_DONT_SHOW_PLATFORM_WARNING = \"org.springframework.ide.eclipse.boot.launch.cloud.cli.NotSupportedPlatform\";\n\tprivate final static String PREF_DONT_SHOW_JRE_WARNING = \"org.springframework.ide.eclipse.boot.launch.cloud.cli.JRE\";\n\tprivate final static String PREF_DONT_SHOW_JDK_WARNING = \"org.springframework.ide.eclipse.boot.launch.cloud.cli.JDK\";\n\tprivate List<String> getCloudCliServiceLifeCycleVmArguments(ILaunchConfiguration configuration, int jmxPort) {\n\t\tList<String> vmArgs = new ArrayList<>();\n\t\t\tEnumSet<JmxBeanSupport.Feature> enabled = BootLaunchConfigurationDelegate\n\t\t\t\t\t.getEnabledJmxFeatures(configuration);\n\t\t\tif (!enabled.isEmpty()) {\n\t\t\t\tString enableLiveBeanArgs = JmxBeanSupport.jmxBeanVmArgs(jmxPort, enabled);\n\t\t\t\tvmArgs.addAll(Arrays.asList(enableLiveBeanArgs.split(\"\\n\")));\n\t\t\t}\n\t\treturn vmArgs;\n\t}\n\tprotected String[] getProgramArgs(IBootInstall bootInstall, ILaunch launch, ILaunchConfiguration configuration) {\n\t\ttry {\n\t\t\tCloudCliInstall cloudCliInstall = bootInstall.getExtension(CloudCliInstall.class);\n\t\t\tif (cloudCliInstall == null) {\n\t\t\t\tLog.error(\"No Spring Cloud CLI installation found\");\n\t\t\t} else {\n\t\t\t\tString serviceId = configuration.getAttribute(ATTR_CLOUD_SERVICE_ID, (String) null);\n\t\t\t\tVersion cloudCliVersion = cloudCliInstall.getVersion();\n\t\t\t\tList<String> vmArgs = new ArrayList<>();\n\t\t\t\tList<String> args = new ArrayList<>();\n\t\t\t\targs.add(CloudCliInstall.COMMAND_PREFIX);\n\t\t\t\targs.add(serviceId);\n\t\t\t\tif (cloudCliVersion != null && SPRING_CLOUD_CLI_SINGLE_PROCESS_VERSION_RANGE.includes(cloudCliVersion)) {\n\t\t\t\t\targs.add(\"--deployer=thin\");\n\t\t\t\t}\n\t\t\t\targs.add(\"--\");\n\t\t\t\targs.add(\"--logging.level.org.springframework.cloud.launcher.deployer=DEBUG\");\n\t\t\t\t// VM argument for the service log output\n\t\t\t\tif (BootLaunchConfigurationDelegate.supportsAnsiConsoleOutput()) {\n\t\t\t\t\tvmArgs.add(\"-Dspring.output.ansi.enabled=always\");\n\t\t\t\t}\n\t\t\t\tif (CloudCliServiceLaunchConfigurationDelegate.SPRING_CLOUD_CLI_SINGLE_PROCESS_VERSION_RANGE.includes(cloudCliVersion)) {\n\t\t\t\t\tif (!vmArgs.isEmpty()) {\n\t\t\t\t\t\targs.add(\"--spring.cloud.launcher.deployables.\" + serviceId + \".properties.spring.cloud.deployer.local.javaOpts=\" + String.join(\",\", vmArgs));\n\t\t\t\t\t}\n\t\t\t\t} else if (CloudCliInstall.CLOUD_CLI_JAVA_OPTS_SUPPORTING_VERSIONS.includes(cloudCliVersion)) {\n\t\t\t\t\tint jmxPort = getJmxPort(configuration);\n\t\t\t\t\t// Set the JMX port for launch\n\t\t\t\t\tlaunch.setAttribute(BootLaunchConfigurationDelegate.JMX_PORT, String.valueOf(jmxPort));\n\t\t\t\t\tvmArgs.addAll(getCloudCliServiceLifeCycleVmArguments(configuration, jmxPort));\n\t\t\t\t\t// Set the JMX port connection jvm args for the service\n\t\t\t\t\tif (!vmArgs.isEmpty()) {\n\t\t\t\t\t\targs.add(\"--spring.cloud.launcher.deployables.\" + serviceId + \".properties.JAVA_OPTS=\" + String.join(\",\", vmArgs));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn args.toArray(new String[args.size()]);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tLog.log(e);\n\t\t}\n\t\treturn new String[0];\n\t}\n\tprivate int getJmxPort(ILaunchConfiguration configuration) {\n\t\tint port = 0;\n\t\ttry {\n\t\t\tport = Integer.parseInt(BootLaunchConfigurationDelegate.getJMXPort(configuration));\n\t\t} catch (Exception e) {\n\t\t\t// ignore: bad data in launch config.\n\t\t}\n\t\tif (port == 0) {\n\t\t\ttry {\n\t\t\t\t// slightly better than calling JmxBeanSupport.randomPort()\n\t\t\t\tport = PortFinder.findFreePort();\n\t\t\t} catch (IOException e) {\n\t\t\t\tLog.log(e);\n\t\t\t}\n\t\t}\n\t\treturn port;\n\t}\n\tpublic static boolean isLocalCloudServiceLaunch(ILaunchConfiguration conf) {\n\t\ttry {\n\t\t\tif (conf!=null) {\n\t\t\t\t\tString type = conf.getType().getIdentifier();\n\t\t\t\treturn TYPE_ID.equals(type);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tLog.log(e);\n\t\t}\n\t\treturn false;\n\t}\n\tpublic static ILaunchConfigurationWorkingCopy createLaunchConfig(String serviceId) throws CoreException {\n\t\tILaunchManager launchManager = DebugPlugin.getDefault().getLaunchManager();\n\t\tILaunchConfigurationType type = launchManager.getLaunchConfigurationType(TYPE_ID);\n\t\tILaunchConfigurationWorkingCopy config = type.newInstance(null, serviceId);\n\t\t// Set default config with life cycle tracking support because it should cover with life cycle tracking and without\n\t\tBootLaunchConfigurationDelegate.setDefaults(config, null, null);\n\t\tconfig.setAttribute(ATTR_CLOUD_SERVICE_ID, serviceId);\n\t\t// Overwrite process factory class because for latest version of Cloud CLI life cycle tracking through JMX port is not available for services\n\t\tBootLaunchConfigurationDelegate.setProcessFactory(config, CloudCliProcessFactory.class);\n\t\treturn config;\n\t}\n\tpublic static boolean canUseLifeCycle(ILaunch launch) {\n\t\tILaunchConfiguration conf = launch.getLaunchConfiguration();\n\t\treturn conf!=null && canUseLifeCycle(conf);\n\t}\n\tpublic static boolean isSingleProcessServiceConfig(ILaunchConfiguration conf) {\n\t\ttry {\n\t\t\tif (isCloudCliService(conf)) {\n\t\t\t\tIBootInstall bootInstall = BootInstallManager.getInstance().getDefaultInstall();\n\t\t\t\tif (bootInstall != null) {\n\t\t\t\t\tVersion cloudCliVersion = bootInstall.getExtension(CloudCliInstall.class) == null ? null : bootInstall.getExtension(CloudCliInstall.class).getVersion();\n\t\t\t\t\treturn SPRING_CLOUD_CLI_SINGLE_PROCESS_VERSION_RANGE.includes(cloudCliVersion);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\t// ignore\n\t\t}\n\t\treturn false;\n\t}\n\tpublic static boolean isCloudCliService(ILaunchConfiguration conf) {\n\t\ttry {\n\t\t\treturn TYPE_ID.equals(conf.getType().getIdentifier());\n\t\t} catch (CoreException e) {\n\t\t\t// Ignore\n\t\t}\n\t\treturn false;\n\t}\n\tpublic static boolean canUseLifeCycle(ILaunchConfiguration conf) {\n\t\ttry {\n\t\t\tif (!isCloudCliService(conf)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tIBootInstall bootInstall = BootInstallManager.getInstance().getDefaultInstall();\n\t\t\tif (bootInstall == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tVersion cloudCliVersion = bootInstall.getExtension(CloudCliInstall.class) == null ? null : bootInstall.getExtension(CloudCliInstall.class).getVersion();\n\t\t\t// Cloud CLI version below 1.2.0 and over 1.3.0 can't have JMX connection to cloud service hence life cycle should be disabled.\n\t\t\tif (!canUseLifeCycle(cloudCliVersion)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn SPRING_CLOUD_CLI_SINGLE_PROCESS_VERSION_RANGE.includes(cloudCliVersion) || BootLaunchConfigurationDelegate.getEnableLifeCycle(conf);\n\t\t} catch (Exception e) {\n\t\t\t// Ignore\n\t\t}\n\t\treturn false;\n\t}\n\tprivate static boolean canUseLifeCycle(Version cloudCliVersion) {\n\t\t// Cloud CLI version below 1.2.0 and over 1.3.0 can't have JMX connection to cloud service hence life cycle should be disabled.\n\t\tif (cloudCliVersion == null\n\t\t\t\t|| !CloudCliInstall.CLOUD_CLI_JAVA_OPTS_SUPPORTING_VERSIONS.includes(cloudCliVersion)\n\t\t\t\t|| SPRING_CLOUD_CLI_SINGLE_PROCESS_VERSION_RANGE.includes(cloudCliVersion)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\tpublic static class CloudCliProcessFactory extends BootProcessFactory {<fim_middle>// class below is blob\n"}