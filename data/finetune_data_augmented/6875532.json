{"text": "<fim_prefix>    try {\n      this.connection.addEventListener(synchronizer);\n      this.connection.startConnection();\n    } catch (final ConnectException e) {\n      this.connection.removeEventListener(synchronizer);\n      this.connection = null;\n      throw new DebugExceptionWrapper(e);\n    }\n  }\n  @Override\n  public final void addListener(final IDebugEventListener listener) {\n    synchronizer.addListener(listener);\n  }\n  @Override\n  public void cancelTargetSelection() throws DebugExceptionWrapper {\n    ensureConnection();\n    try {\n      connection.sendCancelTargetSelection();\n    } catch (final IOException e) {\n      throw new DebugExceptionWrapper(e);\n    }\n  }\n  @Override\n  public boolean canDebug(final INaviModule module) {\n    return addressConverters.keySet().contains(module);\n  }\n  @Override\n  public void detach() throws DebugExceptionWrapper {\n    ensureConnection();\n    try {\n      connection.sendDetachMessage();\n    } catch (final IOException e) {\n      throw new DebugExceptionWrapper(e);\n    }\n  }\n  @Override\n  public RelocatedAddress fileToMemory(final INaviModule module, final UnrelocatedAddress address) {\n    if (module == null) {\n      return new RelocatedAddress(address.getAddress());\n    }\n    final IAddressConverter converter = addressConverters.get(module);\n    if (converter == null) {\n      throw new IllegalStateException(String.format(\n          \"Error: No address converter configured for module '%s'\",\n          module.getConfiguration().getName()));\n    }\n    return converter.fileToMemory(address);\n  }\n  @Override\n  public final BookmarkManager getBookmarkManager() {\n    return bookmarkManager;\n  }\n  @Override\n  public final BreakpointManager getBreakpointManager() {\n    return breakpointManager;\n  }\n  @Override\n  public void getMemoryMap() throws DebugExceptionWrapper {\n    ensureConnection();\n    try {\n      connection.sendMemoryMapMessage();\n    } catch (final IOException e) {\n      throw new DebugExceptionWrapper(e);\n    }\n  }\n  @Override\n  public final IMemoryProvider getMemoryProvider() {\n    return memorySynchronizer.getMemoryProvider();\n  }\n  @Override\n  public INaviModule getModule(final RelocatedAddress address) {\n    final List<Entry<INaviModule, IAddress>> baseList = new ArrayList<>(baseAddresses.entrySet());\n    Collections.sort(baseList, new Comparator<Entry<INaviModule, IAddress>>() {\n      @Override\n      public int compare(final Entry<INaviModule, IAddress> lhs,\n          final Entry<INaviModule, IAddress> rhs) {\n        return lhs.getValue().toBigInteger().compareTo(rhs.getValue().toBigInteger());\n      }\n    });\n    for (int i = 0; i < baseList.size(); i++) {\n      final Entry<INaviModule, IAddress> current = baseList.get(i);\n      if (i == (baseList.size() - 1)) {\n        return current.getKey();\n      }\n      final Entry<INaviModule, IAddress> next = baseList.get(i + 1);\n      if ((address.getAddress().toBigInteger().compareTo(current.getValue().toBigInteger())\n          >= 0) && (address.getAddress().toBigInteger().compareTo(next.getValue().toBigInteger())\n          == -1)) {\n        return current.getKey();\n      }\n    }\n    return null;\n  }\n  @Override\n  public List<INaviModule> getModules() {\n    return new ArrayList<INaviModule>(baseAddresses.keySet());\n  }\n  @Override\n  public final ProcessManager getProcessManager() {\n    return processManager;\n  }\n  @Override\n  public void halt() throws DebugExceptionWrapper {\n    ensureConnection();\n    try {\n      connection.sendHaltMessage();\n    } catch (final IOException e) {\n      throw new DebugExceptionWrapper(e);\n    }\n  }\n  @Override\n  public final boolean isConnected() {\n    return connection != null;\n  }\n  @Override\n  public final UnrelocatedAddress memoryToFile(final RelocatedAddress address) {\n    Preconditions.checkNotNull(address, \"IE00790: Address argument can not be null\");\n    final List<Entry<INaviModule, IAddress>> baseList = new ArrayList<>(baseAddresses.entrySet());\n    Collections.sort(baseList, new Comparator<Entry<INaviModule, IAddress>>() {\n      @Override\n      public int compare(final Entry<INaviModule, IAddress> lhs,\n          final Entry<INaviModule, IAddress> rhs) {\n        return lhs.getValue().toBigInteger().compareTo(rhs.getValue().toBigInteger());\n      }\n    });\n    for (int i = 0; i < baseList.size(); i++) {\n      final Entry<INaviModule, IAddress> current = baseList.get(i);\n      if (i == (baseList.size() - 1)) {\n        return memoryToFile(current.getKey(), address);\n      }\n      final Entry<INaviModule, IAddress> next = baseList.get(i + 1);\n      if ((address.getAddress().toBigInteger().compareTo(current.getValue().toBigInteger())\n          >= 0) && (address.getAddress().toBigInteger().compareTo(next.getValue().toBigInteger())\n          == -1)) {\n        return memoryToFile(current.getKey(), address);\n      }\n    }\n    throw new IllegalStateException(\"IE00791: No module in the debugger\");\n  }\n  @Override\n  public final UnrelocatedAddress memoryToFile(final INaviModule module,\n      final RelocatedAddress address) {\n    Preconditions.checkNotNull(module, \"IE00792: Module argument can not be null\");\n    Preconditions.checkNotNull(address, \"IE00793: Address argument can not be null\");\n    final IAddressConverter converter = addressConverters.get(module);\n    Preconditions.checkNotNull(converter,\n        \"IE00162: Module addresses can not be converted because the debugger has no relocation information for the module\");\n    return converter.memoryToFile(address);\n  }\n  @Override\n  public int readMemory(final IAddress offset, final int size) throws DebugExceptionWrapper {\n    Preconditions.checkNotNull(offset, \"IE00794: Address argument can not be null\");\n    ensureConnection();\n    try {\n      return connection.sendReadMemoryMessage(offset, size);\n    } catch (final IOException e) {\n      throw new DebugExceptionWrapper(e);\n    }\n  }\n  @Override\n  public void readRegisters() throws DebugExceptionWrapper {\n    ensureConnection();\n    try {\n      connection.sendRegisterRequestMessage();\n    } catch (final IOException e) {\n      throw new DebugExceptionWrapper(e);\n    }\n  }\n  @Override\n  public void removeBreakpoints(final Set<BreakpointAddress> addresses, final BreakpointType type)\n      throws DebugExceptionWrapper {\n    ensureConnection();\n    try {\n      connection.sendRemoveBreakpointsMessage(relocate(addresses), type);\n    } catch (final IOException e) {\n      throw new DebugExceptionWrapper(e);\n    }\n  }\n  @Override\n  public final void removeListener(final IDebugEventListener listener) {\n    synchronizer.removeListener(listener);\n  }\n  @Override\n  public int requestFileSystem() throws DebugExceptionWrapper {\n    ensureConnection();\n    try {\n      return connection.sendRequestFileSystem();\n    } catch (final IOException e) {\n      throw new DebugExceptionWrapper(e);\n    }\n  }\n  @Override\n  public void requestFileSystem(final String path) throws DebugExceptionWrapper {\n    ensureConnection();\n    try {\n      connection.sendRequestFileSystem(path);\n    } catch (final IOException e) {\n      throw new DebugExceptionWrapper(e);\n    }\n  }\n  @Override\n  public void requestMemoryRange(final IAddress address) throws DebugExceptionWrapper {\n    ensureConnection();\n    try {\n      connection.sendMemoryRangeMessage(address);\n    } catch (final IOException exception) {\n      throw new DebugExceptionWrapper(exception);\n    }\n  }\n  @Override\n  public int requestProcessList() throws DebugExceptionWrapper {\n    ensureConnection();\n    try {\n      return connection.sendRequestProcessList();\n    } catch (final IOException e) {\n      throw new DebugExceptionWrapper(e);\n    }\n  }\n  @Override\n  public void resume() throws DebugExceptionWrapper {\n    ensureConnection();\n    try {\n      connection.sendResumeMessage();\n    } catch (final IOException e) {\n      throw new DebugExceptionWrapper(e);\n    }\n  }\n  @Override\n  public void resumeThread(final long tid) throws DebugExceptionWrapper {\n    ensureConnection();\n    try {\n      connection.sendResumeThreadMessage(tid);\n    } catch (final IOException e) {\n      throw new DebugExceptionWrapper(e);\n    }\n  }\n  @Override\n  public int search(final IAddress start, final int size, final byte[] data)\n      throws DebugExceptionWrapper {\n    ensureConnection();\n    try {\n      return connection.sendSearchMessage(start, size, data);\n    } catch (final IOException e) {\n      throw new DebugExceptionWrapper(e);\n    }\n  }\n<fim_suffix>  @Override\n  public void selectFile(final String name) throws DebugExceptionWrapper {\n    ensureConnection();\n    try {\n      connection.sendSelectFileMessage(name);\n    } catch (final IOException e) {\n      throw new DebugExceptionWrapper(e);\n    }\n  }<fim_middle>// function below has no smell\n"}