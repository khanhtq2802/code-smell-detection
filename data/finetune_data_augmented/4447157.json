{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Generated by http://code.google.com/p/protostuff/ ... DO NOT EDIT!\n// Generated from protobuf\n\npackage org.apache.drill.exec.proto.beans;\n\nimport java.io.Externalizable;\nimport java.io.IOException;\nimport java.io.ObjectInput;\nimport java.io.ObjectOutput;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport com.dyuproject.protostuff.GraphIOUtil;\nimport com.dyuproject.protostuff.Input;\nimport com.dyuproject.protostuff.Message;\nimport com.dyuproject.protostuff.Output;\nimport com.dyuproject.protostuff.Schema;\n\npublic final class RunQuery implements Externalizable, Message<RunQuery>, Schema<RunQuery>\n{\n\n    public static Schema<RunQuery> getSchema()\n    {\n        return DEFAULT_INSTANCE;\n    }\n\n    public static RunQuery getDefaultInstance()\n    {\n        return DEFAULT_INSTANCE;\n    }\n\n    static final RunQuery DEFAULT_INSTANCE = new RunQuery();\n\n    \n    private QueryResultsMode resultsMode;\n    private QueryType type;\n    private String plan;\n    private List<PlanFragment> fragments;\n    private PreparedStatementHandle preparedStatementHandle;\n\n    public RunQuery()\n    {\n        \n    }\n\n    // getters and setters\n\n    // resultsMode\n\n    public QueryResultsMode getResultsMode()\n    {\n        return resultsMode == null ? QueryResultsMode.STREAM_FULL : resultsMode;\n    }\n\n    public RunQuery setResultsMode(QueryResultsMode resultsMode)\n    {\n        this.resultsMode = resultsMode;\n        return this;\n    }\n\n    // type\n\n    public QueryType getType()\n    {\n        return type == null ? QueryType.SQL : type;\n    }\n\n    public RunQuery setType(QueryType type)\n    {\n        this.type = type;\n        return this;\n    }\n\n    // plan\n\n    public String getPlan()\n    {\n        return plan;\n    }\n\n    public RunQuery setPlan(String plan)\n    {\n        this.plan = plan;\n        return this;\n    }\n\n    // fragments\n\n    public List<PlanFragment> getFragmentsList()\n    {\n        return fragments;\n    }\n\n    public RunQuery setFragmentsList(List<PlanFragment> fragments)\n    {\n        this.fragments = fragments;\n        return this;\n    }\n\n    // preparedStatementHandle\n\n    public PreparedStatementHandle getPreparedStatementHandle()\n    {\n        return preparedStatementHandle;\n    }\n\n    public RunQuery setPreparedStatementHandle(PreparedStatementHandle preparedStatementHandle)\n    {\n        this.preparedStatementHandle = preparedStatementHandle;\n        return this;\n    }\n\n    // java serialization\n\n    public void readExternal(ObjectInput in) throws IOException\n    {\n        GraphIOUtil.mergeDelimitedFrom(in, this, this);\n    }\n\n    public void writeExternal(ObjectOutput out) throws IOException\n    {\n        GraphIOUtil.writeDelimitedTo(out, this, this);\n    }\n\n    // message method\n\n    public Schema<RunQuery> cachedSchema()\n    {\n        return DEFAULT_INSTANCE;\n    }\n\n    // schema methods\n\n    public RunQuery newMessage()\n    {\n        return new RunQuery();\n    }\n\n    public Class<RunQuery> typeClass()\n    {\n        return RunQuery.class;\n    }\n\n    public String messageName()\n    {\n        return RunQuery.class.getSimpleName();\n    }\n\n    public String messageFullName()\n    {\n        return RunQuery.class.getName();\n    }\n\n    public boolean isInitialized(RunQuery message)\n    {\n        return true;\n    }\n\n<fim_suffix>    public void mergeFrom(Input input, RunQuery message) throws IOException\n    {\n        for(int number = input.readFieldNumber(this);; number = input.readFieldNumber(this))\n        {\n            switch(number)\n            {\n                case 0:\n                    return;\n                case 1:\n                    message.resultsMode = QueryResultsMode.valueOf(input.readEnum());\n                    break;\n                case 2:\n                    message.type = QueryType.valueOf(input.readEnum());\n                    break;\n                case 3:\n                    message.plan = input.readString();\n                    break;\n                case 4:\n                    if(message.fragments == null)\n                        message.fragments = new ArrayList<PlanFragment>();\n                    message.fragments.add(input.mergeObject(null, PlanFragment.getSchema()));\n                    break;\n\n                case 5:\n                    message.preparedStatementHandle = input.mergeObject(message.preparedStatementHandle, PreparedStatementHandle.getSchema());\n                    break;\n\n                default:\n                    input.handleUnknownField(number, this);\n            }   \n        }\n    }\n\n\n    public void writeTo(Output output, RunQuery message) throws IOException\n    {\n        if(message.resultsMode != null)\n             output.writeEnum(1, message.resultsMode.number, false);\n\n        if(message.type != null)\n             output.writeEnum(2, message.type.number, false);\n\n        if(message.plan != null)\n            output.writeString(3, message.plan, false);\n\n        if(message.fragments != null)\n        {\n            for(PlanFragment fragments : message.fragments)\n            {\n                if(fragments != null)\n                    output.writeObject(4, fragments, PlanFragment.getSchema(), true);\n            }\n        }\n\n\n        if(message.preparedStatementHandle != null)\n             output.writeObject(5, message.preparedStatementHandle, PreparedStatementHandle.getSchema(), false);\n\n    }\n\n    public String getFieldName(int number)\n    {\n        switch(number)\n        {\n            case 1: return \"resultsMode\";\n            case 2: return \"type\";\n            case 3: return \"plan\";\n            case 4: return \"fragments\";\n            case 5: return \"preparedStatementHandle\";\n            default: return null;\n        }\n    }\n\n    public int getFieldNumber(String name)\n    {\n        final Integer number = __fieldMap.get(name);\n        return number == null ? 0 : number.intValue();\n    }\n\n    private static final java.util.HashMap<String,Integer> __fieldMap = new java.util.HashMap<String,Integer>();\n    static\n    {\n        __fieldMap.put(\"resultsMode\", 1);\n        __fieldMap.put(\"type\", 2);\n        __fieldMap.put(\"plan\", 3);\n        __fieldMap.put(\"fragments\", 4);\n        __fieldMap.put(\"preparedStatementHandle\", 5);\n    }\n    \n}<fim_middle>// function below has no smell\n"}