{"text": "<fim_prefix>            for (int i = 0; i < bytes.length; ++i) {\n                gen[genPos++] = bytes[i];\n            }\n        }\n        int copyConstantPool(int constantPoolCount)\n            throws UnsupportedEncodingException, IOException {\n            int sdeIndex = -1;\n            // copy const pool index zero not in class file\n            for (int i = 1; i < constantPoolCount; ++i) {\n                int tag = readU1();\n                writeU1(tag);\n                switch (tag) {\n                    case 7 : // Class\n                    case 8 : // String\n                        if (log.isDebugEnabled())\n                            log.debug(i + \" copying 2 bytes\");\n                        copy(2);\n                        break;\n                    case 9 : // Field\n                    case 10 : // Method\n                    case 11 : // InterfaceMethod\n                    case 3 : // Integer\n                    case 4 : // Float\n                    case 12 : // NameAndType\n                        if (log.isDebugEnabled())\n                            log.debug(i + \" copying 4 bytes\");\n                        copy(4);\n                        break;\n                    case 5 : // Long\n                    case 6 : // Double\n                        if (log.isDebugEnabled())\n                            log.debug(i + \" copying 8 bytes\");\n                        copy(8);\n                        i++;\n                        break;\n                    case 1 : // Utf8\n                        int len = readU2();\n                        writeU2(len);\n                        byte[] utf8 = readBytes(len);\n                        String str = new String(utf8, \"UTF-8\");\n                        if (log.isDebugEnabled())\n                            log.debug(i + \" read class attr -- '\" + str + \"'\");\n                        if (str.equals(nameSDE)) {\n                            sdeIndex = i;\n                        }\n                        writeBytes(utf8);\n                        break;\n                    default :\n                        throw new IOException(\"unexpected tag: \" + tag);\n                }\n            }\n            return sdeIndex;\n        }\n        void writeUtf8ForSDE() {\n            int len = nameSDE.length();\n            writeU1(1); // Utf8 tag\n            writeU2(len);\n            for (int i = 0; i < len; ++i) {\n                writeU1(nameSDE.charAt(i));\n            }\n        }\n    }\n    public static void evaluateNodes(\n        Node.Nodes nodes,\n        SmapStratum s,\n        HashMap innerClassMap,\n        boolean breakAtLF) {\n        try {\n            nodes.visit(new SmapGenVisitor(s, breakAtLF, innerClassMap));\n        } catch (JasperException ex) {\n        }\n    }\n    static class SmapGenVisitor extends Node.Visitor {\n        private SmapStratum smap;\n        private boolean breakAtLF;\n        private HashMap innerClassMap;\n        SmapGenVisitor(SmapStratum s, boolean breakAtLF, HashMap map) {\n            this.smap = s;\n            this.breakAtLF = breakAtLF;\n            this.innerClassMap = map;\n        }\n        public void visitBody(Node n) throws JasperException {\n            SmapStratum smapSave = smap;\n            String innerClass = n.getInnerClassName();\n            if (innerClass != null) {\n                this.smap = (SmapStratum) innerClassMap.get(innerClass);\n            }\n            super.visitBody(n);\n            smap = smapSave;\n        }\n        public void visit(Node.Declaration n) throws JasperException {\n            doSmapText(n);\n        }\n        public void visit(Node.Expression n) throws JasperException {\n            doSmapText(n);\n        }\n        public void visit(Node.Scriptlet n) throws JasperException {\n            doSmapText(n);\n        }\n        public void visit(Node.IncludeAction n) throws JasperException {\n            doSmap(n);\n            visitBody(n);\n        }\n        public void visit(Node.ForwardAction n) throws JasperException {\n            doSmap(n);\n            visitBody(n);\n        }\n        public void visit(Node.GetProperty n) throws JasperException {\n            doSmap(n);\n            visitBody(n);\n        }\n        public void visit(Node.SetProperty n) throws JasperException {\n            doSmap(n);\n            visitBody(n);\n        }\n        public void visit(Node.UseBean n) throws JasperException {\n            doSmap(n);\n            visitBody(n);\n        }\n        public void visit(Node.PlugIn n) throws JasperException {\n            doSmap(n);\n            visitBody(n);\n        }\n        public void visit(Node.CustomTag n) throws JasperException {\n            doSmap(n);\n            visitBody(n);\n        }\n        public void visit(Node.UninterpretedTag n) throws JasperException {\n            doSmap(n);\n            visitBody(n);\n        }\n        public void visit(Node.JspElement n) throws JasperException {\n            doSmap(n);\n            visitBody(n);\n        }\n        public void visit(Node.JspText n) throws JasperException {\n            doSmap(n);\n            visitBody(n);\n        }\n        public void visit(Node.NamedAttribute n) throws JasperException {\n            visitBody(n);\n        }\n        public void visit(Node.JspBody n) throws JasperException {\n            doSmap(n);\n            visitBody(n);\n        }\n        public void visit(Node.InvokeAction n) throws JasperException {\n            doSmap(n);\n            visitBody(n);\n        }\n        public void visit(Node.DoBodyAction n) throws JasperException {\n            doSmap(n);\n            visitBody(n);\n        }\n        public void visit(Node.ELExpression n) throws JasperException {\n            doSmap(n);\n        }\n        public void visit(Node.TemplateText n) throws JasperException {\n            Mark mark = n.getStart();\n            if (mark == null) {\n                return;\n            }\n            //Add the file information\n            String fileName = mark.getFile();\n            smap.addFile(unqualify(fileName), fileName);\n            //Add a LineInfo that corresponds to the beginning of this node\n            int iInputStartLine = mark.getLineNumber();\n            int iOutputStartLine = n.getBeginJavaLine();\n            int iOutputLineIncrement = breakAtLF? 1: 0;\n            smap.addLineData(iInputStartLine, fileName, 1, iOutputStartLine, \n                             iOutputLineIncrement);\n            // Output additional mappings in the text\n            java.util.ArrayList extraSmap = n.getExtraSmap();\n            if (extraSmap != null) {\n                for (int i = 0; i < extraSmap.size(); i++) {\n                    iOutputStartLine += iOutputLineIncrement;\n                    smap.addLineData(\n                        iInputStartLine+((Integer)extraSmap.get(i)).intValue(),\n                        fileName,\n                        1,\n                        iOutputStartLine,\n                        iOutputLineIncrement);\n                }\n            }\n        }\n        private void doSmap(\n            Node n,\n            int inLineCount,\n            int outIncrement,\n            int skippedLines) {\n            Mark mark = n.getStart();\n            if (mark == null) {\n                return;\n            }\n            String unqualifiedName = unqualify(mark.getFile());\n            smap.addFile(unqualifiedName, mark.getFile());\n            smap.addLineData(\n                mark.getLineNumber() + skippedLines,\n                mark.getFile(),\n                inLineCount - skippedLines,\n                n.getBeginJavaLine() + skippedLines,\n                outIncrement);\n        }\n        private void doSmap(Node n) {\n            doSmap(n, 1, n.getEndJavaLine() - n.getBeginJavaLine(), 0);\n        }\n<fim_suffix>        private void doSmapText(Node n) {\n            String text = n.getText();\n            int index = 0;\n            int next = 0;\n            int lineCount = 1;\n            int skippedLines = 0;\n            boolean slashStarSeen = false;\n            boolean beginning = true;\n            // Count lines inside text, but skipping comment lines at the\n            // beginning of the text.\n            while ((next = text.indexOf('\\n', index)) > -1) {\n                if (beginning) {\n                    String line = text.substring(index, next).trim();\n                    if (!slashStarSeen && line.startsWith(\"/*\")) {\n                        slashStarSeen = true;\n                    }\n                    if (slashStarSeen) {\n                        skippedLines++;\n                        int endIndex = line.indexOf(\"*/\");\n                        if (endIndex >= 0) {\n                            // End of /* */ comment\n                            slashStarSeen = false;\n                            if (endIndex < line.length() - 2) {\n                                // Some executable code after comment\n                                skippedLines--;\n                                beginning = false;\n                            }\n                        }\n                    } else if (line.length() == 0 || line.startsWith(\"//\")) {\n                        skippedLines++;\n                    } else {\n                        beginning = false;\n                    }\n                }\n                lineCount++;\n                index = next + 1;\n            }\n            doSmap(n, lineCount, 1, skippedLines);\n        }<fim_middle>// function below is long method\n"}