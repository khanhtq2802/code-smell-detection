{"text": "<fim_prefix>/*\n * Copyright (c) 2009, 2018, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n\npackage org.graalvm.compiler.nodes.java;\n\nimport static org.graalvm.compiler.nodeinfo.NodeCycles.CYCLES_2;\nimport static org.graalvm.compiler.nodeinfo.NodeSize.SIZE_1;\n\nimport org.graalvm.compiler.core.common.type.StampFactory;\nimport org.graalvm.compiler.graph.NodeClass;\nimport org.graalvm.compiler.graph.spi.Canonicalizable;\nimport org.graalvm.compiler.graph.spi.CanonicalizerTool;\nimport org.graalvm.compiler.nodeinfo.NodeInfo;\nimport org.graalvm.compiler.nodes.ConstantNode;\nimport org.graalvm.compiler.nodes.FixedWithNextNode;\nimport org.graalvm.compiler.nodes.ValueNode;\nimport org.graalvm.compiler.nodes.spi.ArrayLengthProvider;\nimport org.graalvm.compiler.nodes.spi.Lowerable;\nimport org.graalvm.compiler.nodes.spi.LoweringTool;\nimport org.graalvm.compiler.nodes.spi.Virtualizable;\nimport org.graalvm.compiler.nodes.spi.VirtualizerTool;\nimport org.graalvm.compiler.nodes.util.GraphUtil;\nimport org.graalvm.compiler.nodes.virtual.VirtualArrayNode;\n\nimport jdk.vm.ci.meta.ConstantReflectionProvider;\n\n/**\n * The {@code ArrayLength} instruction gets the length of an array.\n */\n@NodeInfo(cycles = CYCLES_2, size = SIZE_1)\npublic final class ArrayLengthNode extends FixedWithNextNode implements Canonicalizable.Unary<ValueNode>, Lowerable, Virtualizable {\n\n    public static final NodeClass<ArrayLengthNode> TYPE = NodeClass.create(ArrayLengthNode.class);\n    @Input ValueNode array;\n\n    public ValueNode array() {\n        return array;\n    }\n\n    @Override\n    public ValueNode getValue() {\n        return array;\n    }\n\n    public ArrayLengthNode(ValueNode array) {\n        super(TYPE, StampFactory.positiveInt());\n        this.array = array;\n    }\n\n<fim_suffix>    public static ValueNode create(ValueNode forValue, ConstantReflectionProvider constantReflection) {\n        if (forValue instanceof NewArrayNode) {\n            NewArrayNode newArray = (NewArrayNode) forValue;\n            return newArray.length();\n        }\n\n        ValueNode length = readArrayLength(forValue, constantReflection);\n        if (length != null) {\n            return length;\n        }\n        return new ArrayLengthNode(forValue);\n    }\n\n    @Override\n    public ValueNode canonical(CanonicalizerTool tool, ValueNode forValue) {\n        ValueNode length = readArrayLength(forValue, tool.getConstantReflection());\n        if (length != null) {\n            return length;\n        }\n        return this;\n    }\n\n    /**\n     * Gets the length of an array if possible.\n     *\n     * @return a node representing the length of {@code array} or null if it is not available\n     */\n    public static ValueNode readArrayLength(ValueNode originalArray, ConstantReflectionProvider constantReflection) {\n        return GraphUtil.arrayLength(originalArray, ArrayLengthProvider.FindLengthMode.CANONICALIZE_READ, constantReflection);\n    }\n\n    @Override\n    public void lower(LoweringTool tool) {\n        tool.getLowerer().lower(this, tool);\n    }\n\n    @NodeIntrinsic\n    public static native int arrayLength(Object array);\n\n    @Override\n    public void virtualize(VirtualizerTool tool) {\n        ValueNode alias = tool.getAlias(array());\n        if (alias instanceof VirtualArrayNode) {\n            VirtualArrayNode virtualArray = (VirtualArrayNode) alias;\n            tool.replaceWithValue(ConstantNode.forInt(virtualArray.entryCount(), graph()));\n        }\n    }\n}<fim_middle>// function below has no smell\n"}