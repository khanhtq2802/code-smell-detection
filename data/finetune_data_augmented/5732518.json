{"text": "<fim_prefix>/***\n * ASM: a very small and fast Java bytecode manipulation framework\n * Copyright (c) 2000-2011 INRIA, France Telecom\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the copyright holders nor the names of its\n *    contributors may be used to endorse or promote products derived from\n *    this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage org.apache.tajo.org.objectweb.asm.optimizer;\n\nimport java.util.HashMap;\n\nimport org.apache.tajo.org.objectweb.asm.Handle;\nimport org.apache.tajo.org.objectweb.asm.Opcodes;\nimport org.apache.tajo.org.objectweb.asm.Type;\n\n/**\n * A constant pool.\n * \n * @author Eric Bruneton\n */\n<fim_suffix>public class ConstantPool extends HashMap<Constant, Constant> {\n\n    private final Constant key1 = new Constant();\n\n    private final Constant key2 = new Constant();\n\n    private final Constant key3 = new Constant();\n\n    private final Constant key4 = new Constant();\n\n    private final Constant key5 = new Constant();\n\n    public Constant newInteger(final int value) {\n        key1.set(value);\n        Constant result = get(key1);\n        if (result == null) {\n            result = new Constant(key1);\n            put(result);\n        }\n        return result;\n    }\n\n    public Constant newFloat(final float value) {\n        key1.set(value);\n        Constant result = get(key1);\n        if (result == null) {\n            result = new Constant(key1);\n            put(result);\n        }\n        return result;\n    }\n\n    public Constant newLong(final long value) {\n        key1.set(value);\n        Constant result = get(key1);\n        if (result == null) {\n            result = new Constant(key1);\n            put(result);\n        }\n        return result;\n    }\n\n    public Constant newDouble(final double value) {\n        key1.set(value);\n        Constant result = get(key1);\n        if (result == null) {\n            result = new Constant(key1);\n            put(result);\n        }\n        return result;\n    }\n\n    public Constant newUTF8(final String value) {\n        key1.set('s', value, null, null);\n        Constant result = get(key1);\n        if (result == null) {\n            result = new Constant(key1);\n            put(result);\n        }\n        return result;\n    }\n\n    private Constant newString(final String value) {\n        key2.set('S', value, null, null);\n        Constant result = get(key2);\n        if (result == null) {\n            newUTF8(value);\n            result = new Constant(key2);\n            put(result);\n        }\n        return result;\n    }\n\n    public Constant newClass(final String value) {\n        key2.set('C', value, null, null);\n        Constant result = get(key2);\n        if (result == null) {\n            newUTF8(value);\n            result = new Constant(key2);\n            put(result);\n        }\n        return result;\n    }\n\n    public Constant newMethodType(final String methodDescriptor) {\n        key2.set('t', methodDescriptor, null, null);\n        Constant result = get(key2);\n        if (result == null) {\n            newUTF8(methodDescriptor);\n            result = new Constant(key2);\n            put(result);\n        }\n        return result;\n    }\n\n    public Constant newHandle(final int tag, final String owner,\n            final String name, final String desc) {\n        key4.set((char) ('h' - 1 + tag), owner, name, desc);\n        Constant result = get(key4);\n        if (result == null) {\n            if (tag <= Opcodes.H_PUTSTATIC) {\n                newField(owner, name, desc);\n            } else {\n                newMethod(owner, name, desc, tag == Opcodes.H_INVOKEINTERFACE);\n            }\n            result = new Constant(key4);\n            put(result);\n        }\n        return result;\n    }\n\n    public Constant newConst(final Object cst) {\n        if (cst instanceof Integer) {\n            int val = ((Integer) cst).intValue();\n            return newInteger(val);\n        } else if (cst instanceof Float) {\n            float val = ((Float) cst).floatValue();\n            return newFloat(val);\n        } else if (cst instanceof Long) {\n            long val = ((Long) cst).longValue();\n            return newLong(val);\n        } else if (cst instanceof Double) {\n            double val = ((Double) cst).doubleValue();\n            return newDouble(val);\n        } else if (cst instanceof String) {\n            return newString((String) cst);\n        } else if (cst instanceof Type) {\n            Type t = (Type) cst;\n            int s = t.getSort();\n            if (s == Type.OBJECT) {\n                return newClass(t.getInternalName());\n            } else if (s == Type.METHOD) {\n                return newMethodType(t.getDescriptor());\n            } else { // s == primitive type or array\n                return newClass(t.getDescriptor());\n            }\n        } else if (cst instanceof Handle) {\n            Handle h = (Handle) cst;\n            return newHandle(h.getTag(), h.getOwner(), h.getName(), h.getDesc());\n        } else {\n            throw new IllegalArgumentException(\"value \" + cst);\n        }\n    }\n\n    public Constant newField(final String owner, final String name,\n            final String desc) {\n        key3.set('G', owner, name, desc);\n        Constant result = get(key3);\n        if (result == null) {\n            newClass(owner);\n            newNameType(name, desc);\n            result = new Constant(key3);\n            put(result);\n        }\n        return result;\n    }\n\n    public Constant newMethod(final String owner, final String name,\n            final String desc, final boolean itf) {\n        key3.set(itf ? 'N' : 'M', owner, name, desc);\n        Constant result = get(key3);\n        if (result == null) {\n            newClass(owner);\n            newNameType(name, desc);\n            result = new Constant(key3);\n            put(result);\n        }\n        return result;\n    }\n\n    public Constant newInvokeDynamic(String name, String desc, Handle bsm,\n            Object... bsmArgs) {\n        key5.set(name, desc, bsm, bsmArgs);\n        Constant result = get(key5);\n        if (result == null) {\n            newNameType(name, desc);\n            newHandle(bsm.getTag(), bsm.getOwner(), bsm.getName(),\n                    bsm.getDesc());\n            for (Object bsmArg : bsmArgs) {\n                newConst(bsmArg);\n            }\n            result = new Constant(key5);\n            put(result);\n        }\n        return result;\n    }\n\n    public Constant newNameType(final String name, final String desc) {\n        key2.set('T', name, desc, null);\n        Constant result = get(key2);\n        if (result == null) {\n            newUTF8(name);\n            newUTF8(desc);\n            result = new Constant(key2);\n            put(result);\n        }\n        return result;\n    }\n\n    private Constant get(final Constant key) {\n        return get((Object) key);\n    }\n\n    private void put(final Constant cst) {\n        put(cst, cst);\n    }\n}<fim_middle>// class below has no smell\n"}