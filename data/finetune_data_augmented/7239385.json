{"text": "<fim_prefix>package org.robolectric.res.android;\nimport static org.robolectric.res.android.Errors.NO_ERROR;\nimport static org.robolectric.res.android.Errors.NO_INIT;\nimport static org.robolectric.res.android.ResourceTypes.RES_STRING_POOL_TYPE;\nimport static org.robolectric.res.android.ResourceTypes.RES_TABLE_LIBRARY_TYPE;\nimport static org.robolectric.res.android.ResourceTypes.RES_TABLE_PACKAGE_TYPE;\nimport static org.robolectric.res.android.ResourceTypes.RES_TABLE_TYPE;\nimport static org.robolectric.res.android.ResourceTypes.RES_TABLE_TYPE_SPEC_TYPE;\nimport static org.robolectric.res.android.ResourceTypes.RES_TABLE_TYPE_TYPE;\nimport static org.robolectric.res.android.ResourceTypes.kResTableTypeMinSize;\nimport static org.robolectric.res.android.ResourceUtils.make_resid;\nimport static org.robolectric.res.android.Util.UNLIKELY;\nimport static org.robolectric.res.android.Util.dtohl;\nimport static org.robolectric.res.android.Util.dtohs;\nimport static org.robolectric.res.android.Util.isTruthy;\nimport static org.robolectric.res.android.Util.logError;\nimport static org.robolectric.res.android.Util.logWarning;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport org.robolectric.res.android.Chunk.Iterator;\nimport org.robolectric.res.android.Idmap.LoadedIdmap;\nimport org.robolectric.res.android.ResourceTypes.IdmapEntry_header;\nimport org.robolectric.res.android.ResourceTypes.ResStringPool_header;\nimport org.robolectric.res.android.ResourceTypes.ResTable_entry;\nimport org.robolectric.res.android.ResourceTypes.ResTable_header;\nimport org.robolectric.res.android.ResourceTypes.ResTable_lib_entry;\nimport org.robolectric.res.android.ResourceTypes.ResTable_lib_header;\nimport org.robolectric.res.android.ResourceTypes.ResTable_map;\nimport org.robolectric.res.android.ResourceTypes.ResTable_map_entry;\nimport org.robolectric.res.android.ResourceTypes.ResTable_package;\nimport org.robolectric.res.android.ResourceTypes.ResTable_sparseTypeEntry;\nimport org.robolectric.res.android.ResourceTypes.ResTable_type;\nimport org.robolectric.res.android.ResourceTypes.ResTable_typeSpec;\nimport org.robolectric.res.android.ResourceTypes.Res_value;\n// transliterated from https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/libs/androidfw/include/androidfw/LoadedArsc.h\n// and https://android.googlesource.com/platform/frameworks/base/+/android-9.0.0_r12/libs/androidfw/LoadedArsc.cpp\npublic class LoadedArsc {\n  //#ifndef LOADEDARSC_H_\n//#define LOADEDARSC_H_\n//\n//#include <memory>\n//#include <set>\n//#include <vector>\n//\n//#include \"android-base/macros.h\"\n//\n//#include \"androidfw/ByteBucketArray.h\"\n//#include \"androidfw/Chunk.h\"\n//#include \"androidfw/ResourceTypes.h\"\n//#include \"androidfw/Util.h\"\n//\n//namespace android {\n//\n<fim_suffix>  static class DynamicPackageEntry {\n    // public:\n    //\n    // DynamicPackageEntry() =default;\n    DynamicPackageEntry(String package_name, int package_id) {\n      this.package_name = package_name;\n      this.package_id = package_id;\n    }\n    String package_name;\n    int package_id = 0;\n  }\n  // TypeSpec is going to be immediately proceeded by\n// an array of Type structs, all in the same block of memory.\n  static class TypeSpec {\n    public static final int SIZEOF = ResTable_typeSpec.SIZEOF + IdmapEntry_header.SIZEOF;\n    // Pointer to the mmapped data where flags are kept.\n    // Flags denote whether the resource entry is public\n    // and under which configurations it varies.\n    ResTable_typeSpec type_spec;\n    // Pointer to the mmapped data where the IDMAP mappings for this type\n    // exist. May be nullptr if no IDMAP exists.\n    IdmapEntry_header idmap_entries;\n    // The number of types that follow this struct.\n    // There is a type for each configuration that entries are defined for.\n    int type_count;\n    // Trick to easily access a variable number of Type structs\n    // proceeding this struct, and to ensure their alignment.\n    // ResTable_type* types[0];\n    ResTable_type[] types;\n    int GetFlagsForEntryIndex(int entry_index) {\n      if (entry_index >= dtohl(type_spec.entryCount)) {\n        return 0;\n      }\n      // uint32_t* flags = reinterpret_cast<uint32_t*>(type_spec + 1);\n      int[] flags = type_spec.getSpecFlags();\n      return flags[entry_index];\n    }\n  }\n  // Returns the string pool where all string resource values\n  // (Res_value::dataType == Res_value::TYPE_STRING) are indexed.\n  public ResStringPool GetStringPool() {\n    return global_string_pool_;\n  }\n  // Returns a vector of LoadedPackage pointers, representing the packages in this LoadedArsc.\n  List<LoadedPackage> GetPackages() {\n    return packages_;\n  }\n  // Returns true if this is a system provided resource.\n  boolean IsSystem() {\n    return system_;\n  }\n  //\n// private:\n//  DISALLOW_COPY_AND_ASSIGN(LoadedArsc);\n//\n//  LoadedArsc() = default;\n//   bool LoadTable(const Chunk& chunk, const LoadedIdmap* loaded_idmap, bool load_as_shared_library);\n//\n  final ResStringPool global_string_pool_ = new ResStringPool();\n  final List<LoadedPackage> packages_ = new ArrayList<>();\n  boolean system_ = false;\n//};\n//\n//}  // namespace android\n//\n//#endif /* LOADEDARSC_H_ */\n//  #define ATRACE_TAG ATRACE_TAG_RESOURCES\n//\n//  #include \"androidfw/LoadedArsc.h\"\n//\n//  #include <cstddef>\n//  #include <limits>\n//\n//  #include \"android-base/logging.h\"\n//  #include \"android-base/stringprintf.h\"\n//  #include \"utils/ByteOrder.h\"\n//  #include \"utils/Trace.h\"\n//\n//  #ifdef _WIN32\n//  #ifdef ERROR\n//  #undef ERROR\n//  #endif\n//  #endif\n//\n//  #include \"androidfw/ByteBucketArray.h\"\n//  #include \"androidfw/Chunk.h\"\n//  #include \"androidfw/ResourceUtils.h\"\n//  #include \"androidfw/Util.h\"\n//\n//  using android::base::StringPrintf;\n//\n//  namespace android {\n  static final int kAppPackageId = 0x7f;\n//  namespace {\n  // Builder that helps accumulate Type structs and then create a single\n  // contiguous block of memory to store both the TypeSpec struct and\n  // the Type structs.\n  static class TypeSpecPtrBuilder {\n    // public:\n    TypeSpecPtrBuilder(ResTable_typeSpec header, IdmapEntry_header idmap_header) {\n      this.header_ = header;\n      this.idmap_header_ = idmap_header;\n    }\n    void AddType(ResTable_type type) {\n      types_.add(type);\n    }\n    TypeSpec Build() {\n      // Check for overflow.\n      // using ElementType = ResTable_type*;\n      // if ((std.numeric_limits<size_t>.max() - sizeof(TypeSpec)) / sizeof(ElementType) <\n      //     types_.size()) {\n      if ((Integer.MAX_VALUE - TypeSpec.SIZEOF) / 4 < types_.size()) {\n        return null; // {} ;\n      }\n      // TypeSpec* type_spec =\n      //     (TypeSpec*).malloc(sizeof(TypeSpec) + (types_.size() * sizeof(ElementType)));<fim_middle>// class below is data class\n"}