{"text": "<fim_prefix>/*\n * Copyright 2015 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.template.soy.jbcsrc.internal;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.template.soy.base.internal.UniqueNameGenerator;\nimport com.google.template.soy.jbcsrc.restricted.TypeInfo;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport org.objectweb.asm.ClassVisitor;\n\n/**\n * Tracks a collection of inner classes and aids in name management and calling {@link\n * ClassVisitor#visitInnerClass(String, String, String, int)} to ensure that they are registered\n * correctly.\n */\n<fim_suffix>public final class InnerClasses {\n  private final TypeInfo outer;\n  private final Map<TypeInfo, ClassData> innerClasses = new LinkedHashMap<>();\n  private final Map<TypeInfo, Integer> innerClassesAccessModifiers = new LinkedHashMap<>();\n  private final UniqueNameGenerator classNames = JbcSrcNameGenerators.forClassNames();\n\n  public InnerClasses(TypeInfo outer) {\n    this.outer = outer;\n  }\n\n  /** Returns all the {@link ClassData} for every InnerClass registered. */\n  public ImmutableList<ClassData> getInnerClassData() {\n    return ImmutableList.copyOf(innerClasses.values());\n  }\n\n  /**\n   * Register the given name as an inner class with the given access modifiers.\n   *\n   * @return A {@link TypeInfo} with the full class name\n   */\n  public TypeInfo registerInnerClass(String simpleName, int accessModifiers) {\n    classNames.claimName(simpleName);\n    TypeInfo innerClass = outer.innerClass(simpleName);\n    innerClassesAccessModifiers.put(innerClass, accessModifiers);\n    return innerClass;\n  }\n\n  /**\n   * Register the name (or a simpl mangling of it) as an inner class with the given access\n   * modifiers.\n   *\n   * @return A {@link TypeInfo} with the full (possibly mangled) class name\n   */\n  public TypeInfo registerInnerClassWithGeneratedName(String simpleName, int accessModifiers) {\n    simpleName = classNames.generateName(simpleName);\n    TypeInfo innerClass = outer.innerClass(simpleName);\n    innerClassesAccessModifiers.put(innerClass, accessModifiers);\n    return innerClass;\n  }\n\n  /**\n   * Adds the data for an inner class.\n   *\n   * @throws java.lang.IllegalArgumentException if the class wasn't previous registered via {@link\n   *     #registerInnerClass(String, int)} or {@link #registerInnerClassWithGeneratedName(String,\n   *     int)}.\n   */\n  public void add(ClassData classData) {\n    checkRegistered(classData.type());\n    innerClasses.put(classData.type(), classData);\n  }\n\n  private void checkRegistered(TypeInfo type) {\n    if (!classNames.hasName(type.simpleName())) {\n      throw new IllegalArgumentException(type + \" wasn't registered\");\n    }\n  }\n\n  /**\n   * Registers this factory as an inner class on the given class writer.\n   *\n   * <p>Registering an inner class is confusing. The inner class needs to call this and so does the\n   * outer class. Confirmed by running ASMIfier. Also, failure to call visitInnerClass on both\n   * classes either breaks reflective apis (like class.getSimpleName()/getEnclosingClass), or causes\n   * verifier errors (like IncompatibleClassChangeError).\n   */\n  public void registerAsInnerClass(ClassVisitor visitor, TypeInfo innerClass) {\n    checkRegistered(innerClass);\n    doRegister(visitor, innerClass);\n  }\n\n  /** Registers all inner classes to the given outer class. */\n  public void registerAllInnerClasses(ClassVisitor visitor) {\n    for (Map.Entry<TypeInfo, Integer> entry : innerClassesAccessModifiers.entrySet()) {\n      TypeInfo innerClass = entry.getKey();\n      doRegister(visitor, innerClass);\n    }\n  }\n\n  private void doRegister(ClassVisitor visitor, TypeInfo innerClass) {\n    visitor.visitInnerClass(\n        innerClass.internalName(), \n        outer.internalName(), \n        innerClass.simpleName(),\n        innerClassesAccessModifiers.get(innerClass));\n  }\n}<fim_middle>// class below has no smell\n"}