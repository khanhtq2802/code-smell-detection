{"text": "<fim_prefix>/*\n * Copyright (c) 2018 VMware, Inc. All Rights Reserved.\n *\n * This product is licensed to you under the Apache License, Version 2.0 (the \"License\").\n * You may not use this product except in compliance with the License.\n *\n * This product may include a number of subcomponents with separate copyright notices\n * and license terms. Your use of these subcomponents is subject to the terms and\n * conditions of the subcomponent's license, as noted in the LICENSE file.\n */\npackage com.vmware.xenon.services.rdbms;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.io.UnsupportedEncodingException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.TimeUnit;\nimport java.util.logging.Logger;\nimport javax.sql.DataSource;\nimport liquibase.Contexts;\nimport liquibase.LabelExpression;\nimport liquibase.Liquibase;\nimport liquibase.change.core.CreateIndexChange;\nimport liquibase.changelog.ChangeLogHistoryServiceFactory;\nimport liquibase.changelog.ChangeSet;\nimport liquibase.database.Database;\nimport liquibase.database.DatabaseFactory;\nimport liquibase.database.OfflineConnection;\nimport liquibase.database.jvm.JdbcConnection;\nimport liquibase.diff.DiffGeneratorFactory;\nimport liquibase.diff.DiffResult;\nimport liquibase.diff.compare.CompareControl;\nimport liquibase.diff.output.DiffOutputControl;\nimport liquibase.diff.output.changelog.DiffToChangeLog;\nimport liquibase.exception.LiquibaseException;\nimport liquibase.lockservice.DatabaseChangeLogLock;\nimport liquibase.resource.ClassLoaderResourceAccessor;\nimport liquibase.resource.ResourceAccessor;\nimport liquibase.serializer.LiquibaseSerializable;\nimport liquibase.serializer.SnapshotSerializerFactory;\nimport liquibase.serializer.core.xml.XMLChangeLogSerializer;\nimport liquibase.snapshot.DatabaseSnapshot;\nimport liquibase.snapshot.SnapshotControl;\nimport liquibase.snapshot.SnapshotGeneratorFactory;\nimport liquibase.structure.core.Catalog;\nimport liquibase.structure.core.Schema;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport com.vmware.xenon.common.Utils;\nimport com.vmware.xenon.common.config.XenonConfiguration;\nimport com.vmware.xenon.services.rdbms.PostgresSchemaManager.ColumnDescription;\npublic class PostgresLiquibaseUtils {\n    private static final Logger logger = Logger.getLogger(PostgresLiquibaseUtils.class.getName());\n    private static final long LOCK_RELEASE_TIMEOUT_MINUTES = XenonConfiguration.number(\n            PostgresLiquibaseUtils.class, \"lockReleaseTimeoutMinutes\", 0);\n    public static DiffResult compareSnapshots(String latestSnapshotJson,\n            String currentSnapshotJson) throws Exception {\n        // Resource accessor to read content from strings\n        ResourceAccessor resourceAccessor = new ResourceAccessor() {\n            @Override\n            public Set<InputStream> getResourcesAsStream(String path) throws IOException {\n                String content;\n                switch (path) {\n                case \"latest.json\":\n                    content = latestSnapshotJson;\n                    break;\n                case \"current.json\":\n                    content = currentSnapshotJson;\n                    break;\n                default:\n                    return null;\n                }\n                return Collections\n                        .singleton(new ByteArrayInputStream(content.getBytes(Utils.CHARSET)));\n            }\n            @Override\n            public Set<String> list(String relativeTo, String path, boolean includeFiles,\n                    boolean includeDirectories, boolean recursive) {\n                return null;\n            }\n            @Override\n            public ClassLoader toClassLoader() {\n                return null;\n            }\n        };\n        // loading current snapshot\n        OfflineConnection currentOfflineConnection = new OfflineConnection(\n                \"offline:postgresql?snapshot=current.json\", resourceAccessor);\n        Database currentDatabase = DatabaseFactory.getInstance()\n                .findCorrectDatabaseImplementation(currentOfflineConnection);\n        // Loading latest snapshot\n        OfflineConnection latestOfflineConnection = new OfflineConnection(\n                \"offline:postgresql?snapshot=latest.json\", resourceAccessor);\n        Database latestDatabase = DatabaseFactory.getInstance()\n                .findCorrectDatabaseImplementation(latestOfflineConnection);\n        // Compare\n        return DiffGeneratorFactory.getInstance().compare(currentDatabase, latestDatabase,\n                new CompareControl()\n                        .addSuppressedField(Catalog.class, \"name\")\n                        .addSuppressedField(Schema.class, \"name\"));\n    }\n    public static String getLatestSnapshotAsJson(String snapshotResourcePath) {\n        try {\n            // TODO: Potential issue with wrong class loader for getting resources\n            String json = PostgresHostUtils\n                    .getResourceAsString(Thread.currentThread().getContextClassLoader(),\n                            snapshotResourcePath);\n            if (json.isEmpty()) {\n                // Throw an Exception for empty content to treat it as empty database\n                throw new IOException(\"Empty content\");\n            }\n            return json;\n        } catch (IOException e) {\n            // Use empty snapshot if latest snapshot is missing, this is used for\n            // creating initial changelog\n            logger.warning(String.format(\n                    \"Missing %s resource, using empty snapshot for Liquibase change log creation: %s\",\n                    snapshotResourcePath, e));\n            return PostgresLiquibaseSnapshot.emptySnapshotAsJson();\n        }\n    }\n<fim_suffix>    private static class MyXMLChangeLogSerializer extends XMLChangeLogSerializer {\n        private final PostgresLiquibaseSnapshot currentSnapshot;\n        MyXMLChangeLogSerializer(PostgresLiquibaseSnapshot currentSnapshot) {\n            this.currentSnapshot = currentSnapshot;\n        }\n        @Override\n        public Element createNode(LiquibaseSerializable object) {\n            Element element = super.createNode(object);\n            if (object instanceof ChangeSet) {\n                ChangeSet changeSet = (ChangeSet) object;\n                changeSet.getChanges().forEach(change -> {\n                    if (change instanceof CreateIndexChange) {\n                        CreateIndexChange cic = (CreateIndexChange) change;\n                        if (cic.getColumns().size() != 1) {\n                            return;\n                        }\n                        ColumnDescription cd = this.currentSnapshot\n                                .getColumnDescriptionByIndexId(cic.getIndexName());\n                        String indexType = cd != null ? cd.getIndexType() : null;\n                        if (indexType != null) {\n                            Document doc = element.getOwnerDocument();\n                            Element modifySqlElement = doc.createElement(\"modifySql\");\n                            Element replaceElement = doc.createElement(\"regExpReplace\");\n                            replaceElement.setAttribute(\"replace\", \"\\\\(.+\\\\)\");\n                            replaceElement.setAttribute(\"with\",\n                                    String.format(\" USING %s $0\", indexType));\n                            modifySqlElement.appendChild(replaceElement);\n                            element.appendChild(modifySqlElement);\n                        }\n                    }\n                });\n            }\n            return element;\n        }\n    }\n    public static String diffToChangeLog(DiffResult diffResult,\n            PostgresLiquibaseSnapshot currentSnapshot) throws Exception {\n        DiffToChangeLog changeLogWriter = new DiffToChangeLog(diffResult, new DiffOutputControl()\n                .setIncludeSchema(false)\n                .setIncludeCatalog(false));\n        changeLogWriter.setDiffResult(diffResult);\n        ByteArrayOutputStream os = new ByteArrayOutputStream();\n        changeLogWriter.print(new PrintStream(os), new MyXMLChangeLogSerializer(currentSnapshot));\n        return os.toString();\n    }\n    public static boolean validateSnapshot(PostgresLiquibaseSnapshot currentSnapshot,\n            String latestSnapshotResourcePath, boolean createFilesOnDifference) throws Exception {\n        String currentSnapshotJson = currentSnapshot.getSnapshotAsJson();\n        // Get latest snapshot\n        String latestSnapshotJson = getLatestSnapshotAsJson(latestSnapshotResourcePath);\n        // Compare current snapshot with latest-snapshot.json\n        DiffResult diffResult = compareSnapshots(latestSnapshotJson, currentSnapshotJson);\n        if (diffResult.areEqual()) {\n            return true;\n        }\n        // Snapshots are different\n        logger.severe(String.format(\"Need to update '%s' to current Liquibase snapshot\",\n                latestSnapshotResourcePath));\n        if (createFilesOnDifference) {\n            Path latestSnapshotPath = Paths.get(\"current-snapshot.json\").toAbsolutePath();\n            logger.severe(String.format(\"*** Current Liquibase snapshot: %s\\n%s\\n\",\n                    latestSnapshotPath, currentSnapshotJson));\n            Files.write(latestSnapshotPath,\n                    currentSnapshotJson.getBytes(Utils.CHARSET),\n                    StandardOpenOption.CREATE,\n                    StandardOpenOption.TRUNCATE_EXISTING);\n            // change log\n            String changeLogXml = diffToChangeLog(diffResult, currentSnapshot);\n            Path latestChangeLogPath = Paths.get(\"current-changelog.xml\").toAbsolutePath();\n            logger.severe(String.format(\"*** Current Liquibase changelog: %s\\n%s\\n\",\n                    latestChangeLogPath, changeLogXml));\n            Files.write(latestChangeLogPath,\n                    changeLogXml.getBytes(Utils.CHARSET),\n                    StandardOpenOption.CREATE,<fim_middle>// class below has no smell\n"}