{"text": "<fim_prefix>package org.robolectric.shadows;\nimport static android.os.Build.VERSION_CODES.KITKAT;\nimport static android.os.Build.VERSION_CODES.LOLLIPOP;\nimport static android.os.Build.VERSION_CODES.M;\nimport static android.os.Build.VERSION_CODES.N;\nimport static android.os.Build.VERSION_CODES.O;\nimport static org.robolectric.RuntimeEnvironment.getApiLevel;\nimport android.net.ConnectivityManager;\nimport android.net.ConnectivityManager.OnNetworkActiveListener;\nimport android.net.LinkProperties;\nimport android.net.Network;\nimport android.net.NetworkCapabilities;\nimport android.net.NetworkInfo;\nimport android.net.NetworkRequest;\nimport android.os.Handler;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport org.robolectric.annotation.HiddenApi;\nimport org.robolectric.annotation.Implementation;\nimport org.robolectric.annotation.Implements;\nimport org.robolectric.shadow.api.Shadow;\n@Implements(ConnectivityManager.class)\npublic class ShadowConnectivityManager {\n  // Package-private for tests.\n  static final int NET_ID_WIFI = ConnectivityManager.TYPE_WIFI;\n  static final int NET_ID_MOBILE = ConnectivityManager.TYPE_MOBILE;\n  private NetworkInfo activeNetworkInfo;\n  private boolean backgroundDataSetting;\n  private int networkPreference = ConnectivityManager.DEFAULT_NETWORK_PREFERENCE;\n  private final Map<Integer, NetworkInfo> networkTypeToNetworkInfo = new HashMap<>();\n  private HashSet<ConnectivityManager.NetworkCallback> networkCallbacks = new HashSet<>();\n  private final Map<Integer, Network> netIdToNetwork = new HashMap<>();\n  private final Map<Integer, NetworkInfo> netIdToNetworkInfo = new HashMap<>();\n  private Network processBoundNetwork;\n  private boolean defaultNetworkActive;\n  private HashSet<ConnectivityManager.OnNetworkActiveListener> onNetworkActiveListeners =\n      new HashSet<>();\n  private Map<Network, Boolean> reportedNetworkConnectivity = new HashMap<>();\n  private Map<Network, NetworkCapabilities> networkCapabilitiesMap = new HashMap<>();\n  private String captivePortalServerUrl = \"http://10.0.0.2\";\n  private final Map<Network, LinkProperties> linkPropertiesMap = new HashMap<>();\n  public ShadowConnectivityManager() {\n    NetworkInfo wifi = ShadowNetworkInfo.newInstance(NetworkInfo.DetailedState.DISCONNECTED,\n        ConnectivityManager.TYPE_WIFI, 0, true, false);\n    networkTypeToNetworkInfo.put(ConnectivityManager.TYPE_WIFI, wifi);\n    NetworkInfo mobile = ShadowNetworkInfo.newInstance(NetworkInfo.DetailedState.CONNECTED,\n        ConnectivityManager.TYPE_MOBILE, ConnectivityManager.TYPE_MOBILE_MMS, true, true);\n    networkTypeToNetworkInfo.put(ConnectivityManager.TYPE_MOBILE, mobile);\n    this.activeNetworkInfo = mobile;\n    if (getApiLevel() >= LOLLIPOP) {\n      netIdToNetwork.put(NET_ID_WIFI, ShadowNetwork.newInstance(NET_ID_WIFI));\n      netIdToNetwork.put(NET_ID_MOBILE, ShadowNetwork.newInstance(NET_ID_MOBILE));\n      netIdToNetworkInfo.put(NET_ID_WIFI, wifi);\n      netIdToNetworkInfo.put(NET_ID_MOBILE, mobile);\n    }\n    defaultNetworkActive = true;\n  }\n  public Set<ConnectivityManager.NetworkCallback> getNetworkCallbacks() {\n    return networkCallbacks;\n  }\n  /**\n   * @return networks and their connectivity status which was reported with {@link\n   *     #reportNetworkConnectivity}.\n   */\n  public Map<Network, Boolean> getReportedNetworkConnectivity() {\n    return new HashMap<>(reportedNetworkConnectivity);\n  }\n  @Implementation(minSdk = LOLLIPOP)\n  protected void registerNetworkCallback(\n      NetworkRequest request, ConnectivityManager.NetworkCallback networkCallback) {\n    registerNetworkCallback(request, networkCallback, null);\n  }\n  @Implementation(minSdk = O)\n  protected void registerNetworkCallback(\n      NetworkRequest request,\n      ConnectivityManager.NetworkCallback networkCallback,\n      Handler handler) {\n    networkCallbacks.add(networkCallback);\n  }\n  @Implementation(minSdk = LOLLIPOP)\n  protected void requestNetwork(\n      NetworkRequest request, ConnectivityManager.NetworkCallback networkCallback) {\n    registerNetworkCallback(request, networkCallback);\n  }\n  @Implementation(minSdk = N)\n  protected void registerDefaultNetworkCallback(\n      ConnectivityManager.NetworkCallback networkCallback) {\n    networkCallbacks.add(networkCallback);\n  }\n  @Implementation(minSdk = LOLLIPOP)\n  protected void unregisterNetworkCallback(ConnectivityManager.NetworkCallback networkCallback) {\n    if (networkCallback == null) {\n      throw new IllegalArgumentException(\"Invalid NetworkCallback\");\n    }\n    if (networkCallbacks.contains(networkCallback)) {\n      networkCallbacks.remove(networkCallback);\n    }\n  }\n  @Implementation\n  protected NetworkInfo getActiveNetworkInfo() {\n    return activeNetworkInfo;\n  }\n  /**\n   * @see #setActiveNetworkInfo(NetworkInfo)\n   * @see #setNetworkInfo(int, NetworkInfo)\n   */\n<fim_suffix>  @Implementation(minSdk = M)\n  protected Network getActiveNetwork() {\n    if (defaultNetworkActive) {\n      return netIdToNetwork.get(getActiveNetworkInfo().getType());\n    }\n    return null;\n  }\n  /**\n   * @see #setActiveNetworkInfo(NetworkInfo)\n   * @see #setNetworkInfo(int, NetworkInfo)\n   */\n  @Implementation\n  protected NetworkInfo[] getAllNetworkInfo() {\n    // todo(xian): is `defaultNetworkActive` really relevant here?\n    if (defaultNetworkActive) {\n      return networkTypeToNetworkInfo\n          .values()\n          .toArray(new NetworkInfo[networkTypeToNetworkInfo.size()]);\n    }\n    return null;\n  }\n  @Implementation\n  protected NetworkInfo getNetworkInfo(int networkType) {\n    return networkTypeToNetworkInfo.get(networkType);\n  }\n  @Implementation(minSdk = LOLLIPOP)\n  protected NetworkInfo getNetworkInfo(Network network) {\n    if (network == null) {\n      return null;\n    }\n    ShadowNetwork shadowNetwork = Shadow.extract(network);\n    return netIdToNetworkInfo.get(shadowNetwork.getNetId());\n  }\n  @Implementation(minSdk = LOLLIPOP)\n  protected Network[] getAllNetworks() {\n    return netIdToNetwork.values().toArray(new Network[netIdToNetwork.size()]);\n  }\n  @Implementation\n  protected boolean getBackgroundDataSetting() {\n    return backgroundDataSetting;\n  }\n  @Implementation\n  protected void setNetworkPreference(int preference) {\n    networkPreference = preference;\n  }\n  @Implementation\n  protected int getNetworkPreference() {\n    return networkPreference;\n  }\n  /**\n   * Counts {@link ConnectivityManager#TYPE_MOBILE} networks as metered. Other types will be\n   * considered unmetered.\n   *\n   * @return `true` if the active network is metered, otherwise `false`.\n   * @see #setActiveNetworkInfo(NetworkInfo)\n   * @see #setDefaultNetworkActive(boolean)\n   */\n  @Implementation\n  protected boolean isActiveNetworkMetered() {\n    if (defaultNetworkActive && activeNetworkInfo != null) {\n      return activeNetworkInfo.getType() == ConnectivityManager.TYPE_MOBILE;\n    } else {\n      return false;\n    }\n  }\n  @Implementation(minSdk = M)\n  protected boolean bindProcessToNetwork(Network network) {\n    processBoundNetwork = network;\n    return true;\n  }\n  @Implementation(minSdk = M)\n  protected Network getBoundNetworkForProcess() {\n    return processBoundNetwork;\n  }\n  public void setNetworkInfo(int networkType, NetworkInfo networkInfo) {\n    networkTypeToNetworkInfo.put(networkType, networkInfo);\n  }\n  /**\n   * Returns the captive portal URL previously set with {@link #setCaptivePortalServerUrl}.\n   */\n  @Implementation(minSdk = N)\n  protected String getCaptivePortalServerUrl() {\n    return captivePortalServerUrl;\n  }\n  /**\n   * Sets the captive portal URL, which will be returned in {@link #getCaptivePortalServerUrl}.\n   *\n   * @param captivePortalServerUrl the url of captive portal.\n   */\n  public void setCaptivePortalServerUrl(String captivePortalServerUrl) {\n    this.captivePortalServerUrl = captivePortalServerUrl;\n  }\n  @HiddenApi @Implementation\n  public void setBackgroundDataSetting(boolean b) {\n    backgroundDataSetting = b;\n  }\n  public void setActiveNetworkInfo(NetworkInfo info) {\n    if (getApiLevel() >= LOLLIPOP) {\n      activeNetworkInfo = info;\n      if (info != null) {\n        networkTypeToNetworkInfo.put(info.getType(), info);\n        netIdToNetwork.put(info.getType(), ShadowNetwork.newInstance(info.getType()));\n        netIdToNetworkInfo.put(info.getType(), info);\n      } else {\n        networkTypeToNetworkInfo.clear();\n        netIdToNetwork.clear();\n      }\n    } else {\n      activeNetworkInfo = info;<fim_middle>// function below has no smell\n"}