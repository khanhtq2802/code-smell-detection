{"text": "<fim_prefix> * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.felix.framework;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.StringTokenizer;\nimport org.apache.felix.framework.ext.SecurityProvider;\nimport org.apache.felix.framework.security.SecurityConstants;\nimport org.apache.felix.framework.security.condpermadmin.ConditionalPermissionAdminImpl;\nimport org.apache.felix.framework.security.permissionadmin.PermissionAdminImpl;\nimport org.apache.felix.framework.security.util.Conditions;\nimport org.apache.felix.framework.security.util.LocalPermissions;\nimport org.apache.felix.framework.security.util.Permissions;\nimport org.apache.felix.framework.security.util.PropertiesCache;\nimport org.apache.felix.framework.util.SecureAction;\nimport org.osgi.framework.BundleActivator;\nimport org.osgi.framework.BundleContext;\nimport org.osgi.framework.BundleException;\nimport org.osgi.framework.Constants;\nimport org.osgi.service.condpermadmin.ConditionalPermissionAdmin;\nimport org.osgi.service.permissionadmin.PermissionAdmin;\n/**\n * <p>\n * This Felix specific activator installs a security provider with the Felix\n * framework. The security settings can be changed via the\n * {@link PermissionAdmin} and/or the {@link ConditionalPermissionAdmin}\n * services that may be published by this class.\n * </p>\n * <p>\n * Permission informations as well as caching data will be stored in several\n * files in a directory called <tt>security</tt> obtained by a call to\n * {@link BundleContext#getDataFile(String))}.\n * </p>\n * <p>\n * The following properties are recognized:\n * <p>\n * {@link SecurityConstants#ENABLE_PERMISSIONADMIN_PROP} - Whether or not (\n * <tt>true</tt>|<tt>false</tt>) to publish a{@link ConditionalPermissionAdmin}\n * service. The default is\n * {@link SecurityConstants#ENABLE_PERMISSIONADMIN_VALUE}.\n * </p>\n * <p>\n * {@link SecurityConstants#ENABLE_CONDPERMADMIN_PROP} - Whether or not (\n * <tt>true</tt>|<tt>false</tt>) to publish a{@link ConditionalPermissionAdmin}\n * service. The default is {@link SecurityConstants#ENABLE_CONDPERMADMIN_VALUE}.\n * </p>\n * <p>\n * {@link SecurityConstants#KEYSTORE_FILE_PROP} - The keystore URL(s) to use as\n * trusted CA stores. The urls must be separated by a guard (i.e., <tt>|</tt>).\n * The default is {@link SecurityConstants#KEYSTORE_FILE_VALUE}.\n * </p>\n * <p>\n * {@link SecurityConstants#KEYSTORE_PASS_PROP} - The keystore password(s) to\n * use for the given keystores. The passwords must be separated by a guard\n * (i.e., <tt>|</tt>).The default is\n * {@link SecurityConstants#KEYSTORE_PASS_VALUE}.\n * </p>\n * <p>\n * {@link SecurityConstants#KEYSTORE_TYPE_PROP} - The keystore type(s) to use\n * for the given keystores. The types must be separated by a guard (i.e.,\n * <tt>|</tt>).The default is {@link SecurityConstants#KEYSTORE_TYPE_VALUE}.\n * </p>\n * <p>\n * {@link SecurityConstants#CRL_FILE_PROP} - The CRL URL(s) to use for revoked\n * certificates. The urls must be separated by a guard (i.e., <tt>|</tt>). The\n * default is {@link SecurityConstants#CRL_FILE_VALUE}.\n * </p>\n * </p>\n */\n/*\n * TODO: using a string for passwords is bad. We need to investigate\n * alternatives.\n * \n * TODO: we might want to allow for the recognized properties to change without\n * a restart. This is trick because we can not publish a managed service due to\n * not being able to import as we are an extension bundle.\n */\npublic final class SecurityActivator implements BundleActivator\n{\n<fim_suffix>    public synchronized void start(BundleContext context) throws Exception\n    {\n        PermissionAdminImpl pai = null;\n        SecureAction action = new SecureAction();\n        Permissions permissions = new Permissions(context, action);\n        File tmp = context.getDataFile(\"security\" + File.separator + \"tmp\");\n        if ((tmp == null) || (!tmp.isDirectory() && !tmp.mkdirs()))\n        {\n            throw new IOException(\"Can't create tmp dir.\");\n        }\n        // TODO: log something if we can not clean-up the tmp dir\n        File[] old = tmp.listFiles();\n        if (old != null)\n        {\n            for (int i = 0; i < old.length; i++)\n            {\n                old[i].delete();\n            }\n        }\n        if (\"TRUE\".equalsIgnoreCase(getProperty(context,\n            SecurityConstants.ENABLE_PERMISSIONADMIN_PROP,\n            SecurityConstants.ENABLE_PERMISSIONADMIN_VALUE)))\n        {\n            File cache = context.getDataFile(\"security\" + File.separator\n                + \"pa.txt\");\n            if ((cache == null) || (!cache.isFile() && !cache.createNewFile()))\n            {\n                throw new IOException(\"Can't create cache file\");\n            }\n            pai = new PermissionAdminImpl(permissions, new PropertiesCache(\n                cache, tmp, action));\n        }\n        ConditionalPermissionAdminImpl cpai = null;\n        if (\"TRUE\".equalsIgnoreCase(getProperty(context,\n            SecurityConstants.ENABLE_CONDPERMADMIN_PROP,\n            SecurityConstants.ENABLE_CONDPERMADMIN_VALUE)))\n        {\n            File cpaCache = context.getDataFile(\"security\" + File.separator\n                + \"cpa.txt\");\n            if ((cpaCache == null)\n                || (!cpaCache.isFile() && !cpaCache.createNewFile()))\n            {\n                throw new IOException(\"Can't create cache file\");\n            }\n            LocalPermissions localPermissions = new LocalPermissions(\n                permissions);\n            cpai = new ConditionalPermissionAdminImpl(permissions,\n                new Conditions(action), localPermissions, new PropertiesCache(\n                    cpaCache, tmp, action), pai);\n        }\n        if ((pai != null) || (cpai != null))\n        {\n            String crlList = getProperty(context,\n                SecurityConstants.CRL_FILE_PROP,\n                SecurityConstants.CRL_FILE_VALUE);\n            String storeList = getProperty(context,\n                SecurityConstants.KEYSTORE_FILE_PROP,\n                SecurityConstants.KEYSTORE_FILE_VALUE);\n            String passwdList = getProperty(context,\n                SecurityConstants.KEYSTORE_PASS_PROP,\n                SecurityConstants.KEYSTORE_PASS_VALUE);\n            String typeList = getProperty(context,\n                SecurityConstants.KEYSTORE_TYPE_PROP,\n                SecurityConstants.KEYSTORE_TYPE_VALUE);\n            String osgi_keystores = getProperty(context,\n                Constants.FRAMEWORK_TRUST_REPOSITORIES, null);\n            if (osgi_keystores != null)\n            {\n                StringTokenizer tok = new StringTokenizer(osgi_keystores,\n                    File.pathSeparator);\n                if (storeList.length() == 0)\n                {\n                    storeList += \"file:\" + tok.nextToken();\n                    passwdList += \" \";\n                    typeList += \"JKS\";\n                }\n                while (tok.hasMoreTokens())\n                {\n                    storeList += \"|file:\" + tok.nextToken();\n                    passwdList += \"| \";\n                    typeList += \"|JKS\";\n                }\n            }\n            StringTokenizer storeTok = new StringTokenizer(storeList, \"|\");\n            StringTokenizer passwdTok = new StringTokenizer(passwdList, \"|\");\n            StringTokenizer typeTok = new StringTokenizer(typeList, \"|\");\n            if ((storeTok.countTokens() != typeTok.countTokens())\n                || (passwdTok.countTokens() != storeTok.countTokens()))\n            {\n                throw new BundleException(\n                    \"Each CACerts keystore must have one type and one passwd entry and vice versa.\");\n            }\n            SecurityProvider provider = new SecurityProviderImpl(crlList,\n                typeList, passwdList, storeList, pai, cpai, action, ((Felix) context.getBundle(0)).getLogger());\n            ((Felix) context.getBundle(0)).setSecurityProvider(provider);\n        }\n        if (pai != null)\n        {\n            context.registerService(PermissionAdmin.class.getName(), pai, null);\n        }\n        if (cpai != null)\n        {\n            context.registerService(ConditionalPermissionAdmin.class.getName(),\n                cpai, null);\n        }\n    }<fim_middle>// function below is long method and feature envy\n"}