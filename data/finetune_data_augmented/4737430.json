{"text": "<fim_prefix>        }\n        if (!HiveUtils.isNumberOI(OIs[0])) {\n            throw new UDFArgumentTypeException(0, \"Only number type argument is acceptable but \"\n                    + OIs[0].getTypeName() + \" was passed as `weight`\");\n        }\n        if (!HiveUtils.isIntegerOI(OIs[1])) {\n            throw new UDFArgumentTypeException(1, \"Only int type argument is acceptable but \"\n                    + OIs[1].getTypeName() + \" was passed as `num_of_bins`\");\n        }\n        if (OIs.length == 3) {\n            if (!HiveUtils.isBooleanOI(OIs[2])) {\n                throw new UDFArgumentTypeException(2,\n                    \"Only boolean type argument is acceptable but \" + OIs[2].getTypeName()\n                            + \" was passed as `auto_shrink`\");\n            }\n        }\n        return new BuildBinsUDAFEvaluator();\n    }\n<fim_suffix>    private static class BuildBinsUDAFEvaluator extends GenericUDAFEvaluator {\n        // PARTIAL1 and COMPLETE\n        private PrimitiveObjectInspector weightOI;\n        // PARTIAL2 and FINAL\n        private StructObjectInspector structOI;\n        private StructField autoShrinkField, histogramField, quantilesField;\n        private BooleanObjectInspector autoShrinkOI;\n        private StandardListObjectInspector histogramOI;\n        private DoubleObjectInspector histogramElOI;\n        private StandardListObjectInspector quantilesOI;\n        private DoubleObjectInspector quantileOI;\n        private int nBGBins = 10000; // # of bins for creating histogram (background bins)\n        private int nBins; // # of bins for result\n        private boolean autoShrink = false; // default: false\n        private double[] quantiles; // for reset\n        @AggregationType(estimable = true)\n        static final class BuildBinsAggregationBuffer extends AbstractAggregationBuffer {\n            boolean autoShrink;\n            NumericHistogram histogram; // histogram used for quantile approximation\n            double[] quantiles; // the quantiles requested\n            BuildBinsAggregationBuffer() {}\n            @Override\n            public int estimate() {\n                return (histogram != null ? histogram.lengthFor() : 0) // histogram\n                        + 20 + 8 * (quantiles != null ? quantiles.length : 0) // quantiles\n                        + 4; // autoShrink\n            }\n        }\n        @Override\n        public ObjectInspector init(Mode mode, ObjectInspector[] OIs) throws HiveException {\n            super.init(mode, OIs);\n            if (mode == Mode.PARTIAL1 || mode == Mode.COMPLETE) {\n                weightOI = HiveUtils.asDoubleCompatibleOI(OIs[0]);\n                // set const values\n                nBins = HiveUtils.getConstInt(OIs[1]);\n                if (OIs.length == 3) {\n                    autoShrink = HiveUtils.getConstBoolean(OIs[2]);\n                }\n                // check value of `num_of_bins`\n                if (nBins < 2) {\n                    throw new UDFArgumentException(\n                        \"Only greater than or equal to 2 is accepted but \" + nBins\n                                + \" was passed as `num_of_bins`.\");\n                }\n                quantiles = getQuantiles();\n            } else {\n                structOI = (StructObjectInspector) OIs[0];\n                autoShrinkField = structOI.getStructFieldRef(\"autoShrink\");\n                histogramField = structOI.getStructFieldRef(\"histogram\");\n                quantilesField = structOI.getStructFieldRef(\"quantiles\");\n                autoShrinkOI =\n                        (WritableBooleanObjectInspector) autoShrinkField.getFieldObjectInspector();\n                histogramOI =\n                        (StandardListObjectInspector) histogramField.getFieldObjectInspector();\n                quantilesOI =\n                        (StandardListObjectInspector) quantilesField.getFieldObjectInspector();\n                histogramElOI =\n                        (WritableDoubleObjectInspector) histogramOI.getListElementObjectInspector();\n                quantileOI =\n                        (WritableDoubleObjectInspector) quantilesOI.getListElementObjectInspector();\n            }\n            if (mode == Mode.PARTIAL1 || mode == Mode.PARTIAL2) {\n                final ArrayList<ObjectInspector> fieldOIs = new ArrayList<ObjectInspector>();\n                fieldOIs.add(PrimitiveObjectInspectorFactory.writableBooleanObjectInspector);\n                fieldOIs.add(ObjectInspectorFactory.getStandardListObjectInspector(\n                    PrimitiveObjectInspectorFactory.writableDoubleObjectInspector));\n                fieldOIs.add(ObjectInspectorFactory.getStandardListObjectInspector(\n                    PrimitiveObjectInspectorFactory.writableDoubleObjectInspector));\n                return ObjectInspectorFactory.getStandardStructObjectInspector(\n                    Arrays.asList(\"autoShrink\", \"histogram\", \"quantiles\"), fieldOIs);\n            } else {\n                return ObjectInspectorFactory.getStandardListObjectInspector(\n                    PrimitiveObjectInspectorFactory.writableDoubleObjectInspector);\n            }\n        }\n        private double[] getQuantiles() throws HiveException {\n            final int nQuantiles = nBins - 1;\n            final double[] result = new double[nQuantiles];\n            for (int i = 0; i < nQuantiles; i++) {\n                result[i] = ((double) (i + 1)) / (nQuantiles + 1);\n            }\n            return result;\n        }\n        @Override\n        public AbstractAggregationBuffer getNewAggregationBuffer() throws HiveException {\n            final BuildBinsAggregationBuffer myAgg = new BuildBinsAggregationBuffer();\n            myAgg.histogram = new NumericHistogram();\n            reset(myAgg);\n            return myAgg;\n        }\n        @Override\n        public void reset(@SuppressWarnings(\"deprecation\") AggregationBuffer agg)\n                throws HiveException {\n            final BuildBinsAggregationBuffer myAgg = (BuildBinsAggregationBuffer) agg;\n            myAgg.autoShrink = autoShrink;\n            myAgg.histogram.reset();\n            myAgg.histogram.allocate(nBGBins);\n            myAgg.quantiles = quantiles;\n        }\n        @Override\n        public void iterate(@SuppressWarnings(\"deprecation\") AggregationBuffer agg,\n                Object[] parameters) throws HiveException {\n            Preconditions.checkArgument(parameters.length == 2 || parameters.length == 3);\n            if (parameters[0] == null || parameters[1] == null) {\n                return;\n            }\n            final BuildBinsAggregationBuffer myAgg = (BuildBinsAggregationBuffer) agg;\n            // Get and process the current datum\n            myAgg.histogram.add(PrimitiveObjectInspectorUtils.getDouble(parameters[0], weightOI));\n        }\n        @Override\n        public void merge(@SuppressWarnings(\"deprecation\") AggregationBuffer agg, Object other)\n                throws HiveException {\n            if (other == null) {\n                return;\n            }\n            final BuildBinsAggregationBuffer myAgg = (BuildBinsAggregationBuffer) agg;\n            myAgg.autoShrink =\n                    autoShrinkOI.get(structOI.getStructFieldData(other, autoShrinkField));\n            final List<?> histogram = ((LazyBinaryArray) structOI.getStructFieldData(other,\n                histogramField)).getList();\n            myAgg.histogram.merge(histogram, histogramElOI);\n            final double[] quantiles = HiveUtils.asDoubleArray(\n                structOI.getStructFieldData(other, quantilesField), quantilesOI, quantileOI);\n            if (quantiles != null && quantiles.length > 0) {\n                myAgg.quantiles = quantiles;\n            }\n        }\n        @Override\n        public Object terminatePartial(@SuppressWarnings(\"deprecation\") AggregationBuffer agg)\n                throws HiveException {\n            final BuildBinsAggregationBuffer myAgg = (BuildBinsAggregationBuffer) agg;\n            final Object[] partialResult = new Object[3];\n            partialResult[0] = new BooleanWritable(myAgg.autoShrink);\n            partialResult[1] = myAgg.histogram.serialize();\n            partialResult[2] =\n                    (myAgg.quantiles != null) ? WritableUtils.toWritableList(myAgg.quantiles)\n                            : Collections.singletonList(new DoubleWritable(0));\n            return partialResult;\n        }\n        @Override\n        public Object terminate(@SuppressWarnings(\"deprecation\") AggregationBuffer agg)\n                throws HiveException {\n            final BuildBinsAggregationBuffer myAgg = (BuildBinsAggregationBuffer) agg;\n            if (myAgg.histogram.getUsedBins() < 1) { // SQL standard - return null for zero elements\n                return null;\n            } else {\n                Preconditions.checkNotNull(myAgg.quantiles);\n                final List<DoubleWritable> result = new ArrayList<DoubleWritable>();\n                double prev = Double.NEGATIVE_INFINITY;\n                result.add(new DoubleWritable(Double.NEGATIVE_INFINITY));\n                for (int i = 0; i < myAgg.quantiles.length; i++) {\n                    final double val = myAgg.histogram.quantile(myAgg.quantiles[i]);\n                    // check duplication\n                    if (prev == val) {\n                        if (!myAgg.autoShrink) {\n                            throw new HiveException(\n                                \"Quantiles were repeated even though `auto_shrink` is false.\"\n                                        + \" Reduce `num_of_bins` or enable `auto_shrink`.\");\n                        } // else: skip duplicated quantile\n                    } else {\n                        result.add(new DoubleWritable(val));\n                        prev = val;\n                    }\n                }\n                result.add(new DoubleWritable(Double.POSITIVE_INFINITY));\n                return result;\n            }\n        }\n    }<fim_middle>// class below is blob\n"}