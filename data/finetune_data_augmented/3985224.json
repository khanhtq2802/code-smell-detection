{"text": "<fim_prefix>/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n *\n */\npackage org.apache.polygene.library.sql.generator.implementation.transformation;\nimport java.util.Iterator;\nimport org.apache.polygene.library.sql.generator.grammar.common.SQLConstants;\nimport org.apache.polygene.library.sql.generator.grammar.common.ValueExpression;\nimport org.apache.polygene.library.sql.generator.grammar.modification.ColumnSourceByQuery;\nimport org.apache.polygene.library.sql.generator.grammar.modification.ColumnSourceByValues;\nimport org.apache.polygene.library.sql.generator.grammar.modification.DeleteBySearch;\nimport org.apache.polygene.library.sql.generator.grammar.modification.DynamicColumnSource;\nimport org.apache.polygene.library.sql.generator.grammar.modification.InsertStatement;\nimport org.apache.polygene.library.sql.generator.grammar.modification.SetClause;\nimport org.apache.polygene.library.sql.generator.grammar.modification.TargetTable;\nimport org.apache.polygene.library.sql.generator.grammar.modification.UpdateBySearch;\nimport org.apache.polygene.library.sql.generator.grammar.modification.UpdateSourceByExpression;\nimport org.apache.polygene.library.sql.generator.grammar.query.QueryExpression;\nimport org.apache.polygene.library.sql.generator.implementation.transformation.spi.SQLProcessorAggregator;\n/**\n * @author Stanislav Muhametsin\n */\npublic class ModificationProcessing\n{\n    public static abstract class DynamicColumnSourceProcessor<SourceType extends DynamicColumnSource>\n        extends\n        AbstractProcessor<SourceType>\n    {\n        public DynamicColumnSourceProcessor( Class<? extends SourceType> realType )\n        {\n            super( realType );\n        }\n        @Override\n        protected void doProcess( SQLProcessorAggregator processor, SourceType object,\n                                  StringBuilder builder )\n        {\n            if( object.getColumnNames() != null )\n            {\n                processor.process( object.getColumnNames(), builder );\n            }\n            this.doProcessColumnSource( processor, object, builder );\n        }\n        protected abstract void doProcessColumnSource( SQLProcessorAggregator processor,\n                                                       SourceType object,\n                                                       StringBuilder builder );\n    }\n    public static class ColumnSourceByQueryProcessor extends\n                                                     DynamicColumnSourceProcessor<ColumnSourceByQuery>\n    {\n        public ColumnSourceByQueryProcessor()\n        {\n            this( ColumnSourceByQuery.class );\n        }\n        protected ColumnSourceByQueryProcessor( Class<? extends ColumnSourceByQuery> realType )\n        {\n            super( realType );\n        }\n        @Override\n        protected void doProcessColumnSource( SQLProcessorAggregator processor,\n                                              ColumnSourceByQuery object,\n                                              StringBuilder builder )\n        {\n            builder.append( SQLConstants.NEWLINE );\n            processor.process( object.getQuery(), builder );\n        }\n    }\n    public static class ColumnSourceByValuesProcessor extends\n                                                      DynamicColumnSourceProcessor<ColumnSourceByValues>\n    {\n        public ColumnSourceByValuesProcessor()\n        {\n            this( ColumnSourceByValues.class );\n        }\n        public ColumnSourceByValuesProcessor( Class<? extends ColumnSourceByValues> realType )\n        {\n            super( realType );\n        }\n        @Override\n        protected void doProcessColumnSource( SQLProcessorAggregator processor,\n                                              ColumnSourceByValues object,\n                                              StringBuilder builder )\n        {\n            builder.append( SQLConstants.NEWLINE ).append( \"VALUES\" )\n                   .append( SQLConstants.OPEN_PARENTHESIS );\n            Iterator<ValueExpression> iter = object.getValues().iterator();\n            while( iter.hasNext() )\n            {\n                ValueExpression next = iter.next();\n                boolean needParenthesis = next instanceof QueryExpression;\n                if( needParenthesis )\n                {\n                    builder.append( SQLConstants.OPEN_PARENTHESIS );\n                }\n                processor.process( next, builder );\n                if( needParenthesis )\n                {\n                    builder.append( SQLConstants.CLOSE_PARENTHESIS );\n                }\n                if( iter.hasNext() )\n                {\n                    builder.append( SQLConstants.COMMA ).append( SQLConstants.TOKEN_SEPARATOR );\n                }\n            }\n            builder.append( SQLConstants.CLOSE_PARENTHESIS );\n        }\n    }\n<fim_suffix>    public static class DeleteBySearchProcessor extends AbstractProcessor<DeleteBySearch>\n    {\n        public DeleteBySearchProcessor()\n        {\n            this( DeleteBySearch.class );\n        }\n        public DeleteBySearchProcessor( Class<? extends DeleteBySearch> realType )\n        {\n            super( realType );\n        }\n        @Override\n        protected void doProcess( SQLProcessorAggregator processor, DeleteBySearch object,\n                                  StringBuilder builder )\n        {\n            builder.append( \"DELETE FROM\" ).append( SQLConstants.TOKEN_SEPARATOR );\n            processor.process( object.getTargetTable(), builder );\n            QueryProcessing.processOptionalBooleanExpression( processor, builder,\n                                                              object.getWhere(),\n                                                              SQLConstants.NEWLINE, SQLConstants.WHERE );\n        }\n    }\n    public static class InsertStatementProcessor extends AbstractProcessor<InsertStatement>\n    {\n        public InsertStatementProcessor()\n        {\n            this( InsertStatement.class );\n        }\n        public InsertStatementProcessor( Class<? extends InsertStatement> realType )\n        {\n            super( realType );\n        }\n        @Override\n        protected void doProcess( SQLProcessorAggregator processor, InsertStatement object,\n                                  StringBuilder builder )\n        {\n            builder.append( \"INSERT INTO\" ).append( SQLConstants.TOKEN_SEPARATOR );\n            processor.process( object.getTableName(), builder );\n            builder.append( SQLConstants.TOKEN_SEPARATOR );\n            processor.process( object.getColumnSource(), builder );\n        }\n    }\n    public static class SetClauseProcessor extends AbstractProcessor<SetClause>\n    {\n        public SetClauseProcessor()\n        {\n            this( SetClause.class );\n        }\n        public SetClauseProcessor( Class<? extends SetClause> realType )\n        {\n            super( realType );\n        }\n        @Override\n        protected void doProcess( SQLProcessorAggregator processor, SetClause object,\n                                  StringBuilder builder )\n        {\n            builder.append( object.getUpdateTarget() ).append( SQLConstants.TOKEN_SEPARATOR )\n                   .append( \"=\" )\n                   .append( SQLConstants.TOKEN_SEPARATOR );\n            processor.process( object.getUpdateSource(), builder );\n        }\n    }\n    public static class TargetTableProcessor extends AbstractProcessor<TargetTable>\n    {\n        public TargetTableProcessor()\n        {\n            this( TargetTable.class );\n        }\n        protected TargetTableProcessor( Class<? extends TargetTable> realType )\n        {\n            super( realType );\n        }\n        @Override\n        protected void doProcess( SQLProcessorAggregator processor, TargetTable object,\n                                  StringBuilder builder )\n        {\n            Boolean isOnly = object.isOnly();\n            if( isOnly )\n            {\n                builder.append( \"ONLY\" ).append( SQLConstants.OPEN_PARENTHESIS );\n            }\n            processor.process( object.getTableName(), builder );\n            if( isOnly )\n            {\n                builder.append( SQLConstants.CLOSE_PARENTHESIS );\n            }\n        }\n    }\n    public static class UpdateBySearchProcessor extends AbstractProcessor<UpdateBySearch>\n    {\n        public UpdateBySearchProcessor()\n        {\n            this( UpdateBySearch.class );\n        }\n        protected UpdateBySearchProcessor( Class<? extends UpdateBySearch> realType )\n        {\n            super( realType );\n        }\n        @Override\n        protected void doProcess( SQLProcessorAggregator processor, UpdateBySearch object,\n                                  StringBuilder builder )\n        {\n            builder.append( \"UPDATE\" ).append( SQLConstants.TOKEN_SEPARATOR );\n            processor.process( object.getTargetTable(), builder );\n            builder.append( SQLConstants.NEWLINE ).append( \"SET\" )\n                   .append( SQLConstants.TOKEN_SEPARATOR );\n            Iterator<SetClause> iter = object.getSetClauses().iterator();\n            while( iter.hasNext() )\n            {\n                processor.process( iter.next(), builder );\n                if( iter.hasNext() )\n                {\n                    builder.append( SQLConstants.COMMA ).append( SQLConstants.TOKEN_SEPARATOR );\n                }\n            }\n            QueryProcessing.processOptionalBooleanExpression( processor, builder,\n                                                              object.getWhere(),\n                                                              SQLConstants.NEWLINE, SQLConstants.WHERE );\n        }\n    }\n    public static class UpdateSourceByExpressionProcessor extends\n                                                          AbstractProcessor<UpdateSourceByExpression>\n    {\n        public UpdateSourceByExpressionProcessor()\n        {\n            this( UpdateSourceByExpression.class );\n        }\n        public UpdateSourceByExpressionProcessor( Class<? extends UpdateSourceByExpression> realType )\n        {\n            super( realType );<fim_middle>// class below has no smell\n"}