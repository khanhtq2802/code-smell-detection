{"text": "<fim_prefix>                cachedAcceptedState = new TransactionalState();\n                cachedAcceptedState.setOutcome(Accepted.getInstance());\n                cachedAcceptedState.setTxnId(getAmqpTransactionId());\n                cachedTransactedState = new TransactionalState();\n                cachedTransactedState.setTxnId(getAmqpTransactionId());\n                request.onSuccess();\n            }\n            @Override\n            public void onFailure(Throwable result) {\n                current = null;\n                cachedAcceptedState = null;\n                cachedTransactedState = null;\n                request.onFailure(result);\n            }\n            @Override\n            public boolean isComplete() {\n                return current != null;\n            }\n        };\n        if (coordinator == null || coordinator.isClosed()) {\n            AmqpTransactionCoordinatorBuilder builder =\n                new AmqpTransactionCoordinatorBuilder(this, session.getResourceInfo());\n            builder.buildResource(new AsyncResult() {\n                @Override\n                public void onSuccess() {\n                    try {\n                        coordinator.declare(txId, declareCompletion);\n                    } catch (Exception e) {\n                        request.onFailure(e);\n                    }\n                }\n                @Override\n                public void onFailure(Throwable result) {\n                    request.onFailure(result);\n                }\n                @Override\n                public boolean isComplete() {\n                    return request.isComplete();\n                }\n            });\n        } else {\n            coordinator.declare(txId, declareCompletion);\n        }\n    }\n    public void commit(final JmsTransactionInfo transactionInfo, JmsTransactionInfo nextTransactionInfo, final AsyncResult request) throws Exception {\n        if (!transactionInfo.getId().equals(current)) {\n            if (!transactionInfo.isInDoubt() && current == null) {\n                throw new IllegalStateException(\"Commit called with no active Transaction.\");\n            } else if (!transactionInfo.isInDoubt() && current != null) {\n                throw new IllegalStateException(\"Attempt to Commit a transaction other than the current one\");\n            } else {\n                throw new TransactionRolledBackException(\"Transaction in doubt and cannot be committed.\");\n            }\n        }\n        preCommit();\n        LOG.trace(\"TX Context[{}] committing current TX[[]]\", this, current);\n        DischargeCompletion completion = new DischargeCompletion(request, nextTransactionInfo, true);\n        coordinator.discharge(current, completion);\n        current = null;\n        if (completion.isPipelined()) {\n            // If the discharge completed abnormally then we don't bother creating a new TX as the\n            // caller will determine how to recover.\n            if (!completion.isComplete()) {\n                begin(nextTransactionInfo.getId(), completion.getDeclareCompletion());\n            } else {\n                completion.getDeclareCompletion().onFailure(completion.getFailureCause());\n            }\n        }\n    }\n    public void rollback(JmsTransactionInfo transactionInfo, JmsTransactionInfo nextTransactionInfo, final AsyncResult request) throws Exception {\n        if (!transactionInfo.getId().equals(current)) {\n            if (!transactionInfo.isInDoubt() && current == null) {\n                throw new IllegalStateException(\"Rollback called with no active Transaction.\");\n            } else if (!transactionInfo.isInDoubt() && current != null) {\n                throw new IllegalStateException(\"Attempt to rollback a transaction other than the current one\");\n            } else {\n                request.onSuccess();\n                return;\n            }\n        }\n        preRollback();\n        LOG.trace(\"TX Context[{}] rolling back current TX[[]]\", this, current);\n        DischargeCompletion completion = new DischargeCompletion(request, nextTransactionInfo, false);\n        coordinator.discharge(current, completion);\n        current = null;\n        if (completion.isPipelined()) {\n            // If the discharge completed abnormally then we don't bother creating a new TX as the\n            // caller will determine how to recover.\n            if (!completion.isComplete()) {\n                begin(nextTransactionInfo.getId(), completion.getDeclareCompletion());\n            } else {\n                completion.getDeclareCompletion().onFailure(completion.getFailureCause());\n            }\n        }\n    }\n    //----- Context utility methods ------------------------------------------//\n    public void registerTxConsumer(AmqpConsumer consumer) {\n        txConsumers.put(consumer.getConsumerId(), consumer);\n    }\n    public boolean isInTransaction(JmsConsumerId consumerId) {\n        return txConsumers.containsKey(consumerId);\n    }\n    public void registerTxProducer(AmqpProducer producer) {\n        txProducers.put(producer.getProducerId(), producer);\n    }\n    public boolean isInTransaction(JmsProducerId producerId) {\n        return txProducers.containsKey(producerId);\n    }\n    public AmqpSession getSession() {\n        return session;\n    }\n    public TransactionalState getTxnAcceptState() {\n        return cachedAcceptedState;\n    }\n    public TransactionalState getTxnEnrolledState() {\n        return cachedTransactedState;\n    }\n    public JmsTransactionId getTransactionId() {\n        return current;\n    }\n    public boolean isTransactionFailed() {\n        return coordinator == null ? false : coordinator.isClosed();\n    }\n    public Binary getAmqpTransactionId() {\n        Binary result = null;\n        if (current != null) {\n            result = (Binary) current.getProviderHint();\n        }\n        return result;\n    }\n    @Override\n    public String toString() {\n        return this.session.getSessionId() + \": txContext\";\n    }\n    //----- Transaction pre / post completion --------------------------------//\n    private void preCommit() {\n        for (AmqpConsumer consumer : txConsumers.values()) {\n            consumer.preCommit();\n        }\n    }\n    private void preRollback() {\n        for (AmqpConsumer consumer : txConsumers.values()) {\n            consumer.preRollback();\n        }\n    }\n    private void postCommit() {\n        for (AmqpConsumer consumer : txConsumers.values()) {\n            consumer.postCommit();\n        }\n        txConsumers.clear();\n        txProducers.clear();\n    }\n    private void postRollback() {\n        for (AmqpConsumer consumer : txConsumers.values()) {\n            consumer.postRollback();\n        }\n        txConsumers.clear();\n        txProducers.clear();\n    }\n    //----- Resource Parent implementation -----------------------------------//\n    @Override\n    public void addChildResource(AmqpResource resource) {\n        if (resource instanceof AmqpTransactionCoordinator) {\n            coordinator = (AmqpTransactionCoordinator) resource;\n        }\n    }\n    @Override\n    public void removeChildResource(AmqpResource resource) {\n        // We don't clear the coordinator link so that we can refer to it\n        // to check if the current TX has failed due to link closed during\n        // normal operations.\n    }\n    @Override\n    public AmqpProvider getProvider() {\n        return session.getProvider();\n    }\n    //----- Completion for Commit or Rollback operation ----------------------//\n    private abstract class Completion implements AsyncResult {\n        protected boolean complete;\n        protected Throwable failure;\n        @Override\n        public boolean isComplete() {\n            return complete;\n        }\n        public Throwable getFailureCause() {\n            return failure;\n        }\n    }\n    private class DeclareCompletion extends Completion {\n        protected final DischargeCompletion parent;\n        public DeclareCompletion(DischargeCompletion parent) {\n            this.parent = parent;\n        }\n        @Override\n        public void onFailure(Throwable result) {\n            complete = true;\n            failure = result;\n            parent.onDeclareFailure(result);\n        }\n        @Override\n        public void onSuccess() {\n            complete = true;\n            parent.onDeclareSuccess();\n        }\n    }\n    public class DischargeCompletion extends Completion {\n        private final DeclareCompletion declare;\n        private final AsyncResult request;\n        private final boolean commit;\n        public DischargeCompletion(AsyncResult request, JmsTransactionInfo nextTx, boolean commit) {\n            this.request = request;\n            this.commit = commit;\n            if (nextTx != null) {\n                this.declare = new DeclareCompletion(this);\n            } else {\n                this.declare = null;\n            }\n        }\n        public DeclareCompletion getDeclareCompletion() {\n            return declare;\n        }\n        public boolean isCommit() {\n            return commit;\n        }\n        public boolean isPipelined() {\n            return declare != null;\n        }\n        @Override\n        public void onFailure(Throwable result) {\n            complete = true;\n            failure = result;\n            onDischargeFailure(result);\n        }\n        @Override\n        public void onSuccess() {\n            complete = true;\n            onDischargeSuccess();\n        }\n        public void onDeclareSuccess() {\n            // If the discharge has not completed yet we wait until it does\n            // so we end up with the correct result.\n            if (isComplete()) {\n                if (getFailureCause() == null) {\n                    request.onSuccess();\n                } else {\n                    request.onFailure(getFailureCause());\n                }\n            }\n        }\n<fim_suffix>        public void onDischargeSuccess() {\n            cleanup();\n            // If the declare already returned a result we can proceed otherwise\n            // we need to wait for it finish in order to get the correct outcome.\n            if (declare == null) {\n                request.onSuccess();\n            } else if (declare.isComplete()) {\n                if (declare.getFailureCause() == null) {\n                    request.onSuccess();\n                } else {\n                    request.onFailure(declare.getFailureCause());\n                }\n            }\n        }<fim_middle>// function below has no smell\n"}