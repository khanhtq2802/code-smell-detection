{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.calcite.sql.type;\n\nimport org.apache.calcite.rel.type.RelDataType;\nimport org.apache.calcite.rel.type.RelDataTypePrecedenceList;\nimport org.apache.calcite.util.Glossary;\nimport org.apache.calcite.util.ImmutableNullableList;\nimport org.apache.calcite.util.Util;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\n\n/**\n * SqlTypeExplicitPrecedenceList implements the\n * {@link RelDataTypePrecedenceList} interface via an explicit list of\n * {@link SqlTypeName} entries.\n */\npublic class SqlTypeExplicitPrecedenceList\n    implements RelDataTypePrecedenceList {\n  //~ Static fields/initializers ---------------------------------------------\n\n  // NOTE jvs 25-Jan-2005:  the null entries delimit equivalence\n  // classes\n  private static final List<SqlTypeName> NUMERIC_TYPES =\n      ImmutableNullableList.of(\n          SqlTypeName.TINYINT,\n          null,\n          SqlTypeName.SMALLINT,\n          null,\n          SqlTypeName.INTEGER,\n          null,\n          SqlTypeName.BIGINT,\n          null,\n          SqlTypeName.DECIMAL,\n          null,\n          SqlTypeName.REAL,\n          null,\n          SqlTypeName.FLOAT,\n          SqlTypeName.DOUBLE);\n\n  private static final List<SqlTypeName> COMPACT_NUMERIC_TYPES =\n      ImmutableList.copyOf(Util.filter(NUMERIC_TYPES, Objects::nonNull));\n\n  /**\n   * Map from SqlTypeName to corresponding precedence list.\n   *\n   * @see Glossary#SQL2003 SQL:2003 Part 2 Section 9.5\n   */\n  private static final Map<SqlTypeName, SqlTypeExplicitPrecedenceList>\n      TYPE_NAME_TO_PRECEDENCE_LIST =\n      ImmutableMap.<SqlTypeName, SqlTypeExplicitPrecedenceList>builder()\n          .put(SqlTypeName.BOOLEAN, list(SqlTypeName.BOOLEAN))\n          .put(SqlTypeName.TINYINT, numeric(SqlTypeName.TINYINT))\n          .put(SqlTypeName.SMALLINT, numeric(SqlTypeName.SMALLINT))\n          .put(SqlTypeName.INTEGER, numeric(SqlTypeName.INTEGER))\n          .put(SqlTypeName.BIGINT, numeric(SqlTypeName.BIGINT))\n          .put(SqlTypeName.DECIMAL, numeric(SqlTypeName.DECIMAL))\n          .put(SqlTypeName.REAL, numeric(SqlTypeName.REAL))\n          .put(SqlTypeName.FLOAT, list(SqlTypeName.FLOAT, SqlTypeName.REAL, SqlTypeName.DOUBLE))\n          .put(SqlTypeName.DOUBLE, list(SqlTypeName.DOUBLE, SqlTypeName.DECIMAL))\n          .put(SqlTypeName.CHAR, list(SqlTypeName.CHAR, SqlTypeName.VARCHAR))\n          .put(SqlTypeName.VARCHAR, list(SqlTypeName.VARCHAR))\n          .put(SqlTypeName.BINARY,\n              list(SqlTypeName.BINARY, SqlTypeName.VARBINARY))\n          .put(SqlTypeName.VARBINARY, list(SqlTypeName.VARBINARY))\n          .put(SqlTypeName.DATE, list(SqlTypeName.DATE))\n          .put(SqlTypeName.TIME, list(SqlTypeName.TIME))\n          .put(SqlTypeName.TIMESTAMP,\n              list(SqlTypeName.TIMESTAMP, SqlTypeName.DATE, SqlTypeName.TIME))\n          .put(SqlTypeName.INTERVAL_YEAR,\n              list(SqlTypeName.YEAR_INTERVAL_TYPES))\n          .put(SqlTypeName.INTERVAL_YEAR_MONTH,\n              list(SqlTypeName.YEAR_INTERVAL_TYPES))\n          .put(SqlTypeName.INTERVAL_MONTH,\n              list(SqlTypeName.YEAR_INTERVAL_TYPES))\n          .put(SqlTypeName.INTERVAL_DAY,\n              list(SqlTypeName.DAY_INTERVAL_TYPES))\n          .put(SqlTypeName.INTERVAL_DAY_HOUR,\n              list(SqlTypeName.DAY_INTERVAL_TYPES))\n          .put(SqlTypeName.INTERVAL_DAY_MINUTE,\n              list(SqlTypeName.DAY_INTERVAL_TYPES))\n          .put(SqlTypeName.INTERVAL_DAY_SECOND,\n              list(SqlTypeName.DAY_INTERVAL_TYPES))\n          .put(SqlTypeName.INTERVAL_HOUR,\n              list(SqlTypeName.DAY_INTERVAL_TYPES))\n          .put(SqlTypeName.INTERVAL_HOUR_MINUTE,\n              list(SqlTypeName.DAY_INTERVAL_TYPES))\n          .put(SqlTypeName.INTERVAL_HOUR_SECOND,\n              list(SqlTypeName.DAY_INTERVAL_TYPES))\n          .put(SqlTypeName.INTERVAL_MINUTE,\n              list(SqlTypeName.DAY_INTERVAL_TYPES))\n          .put(SqlTypeName.INTERVAL_MINUTE_SECOND,\n              list(SqlTypeName.DAY_INTERVAL_TYPES))\n          .put(SqlTypeName.INTERVAL_SECOND,\n              list(SqlTypeName.DAY_INTERVAL_TYPES))\n          .build();\n\n  //~ Instance fields --------------------------------------------------------\n\n  private final List<SqlTypeName> typeNames;\n\n  //~ Constructors -----------------------------------------------------------\n\n  public SqlTypeExplicitPrecedenceList(Iterable<SqlTypeName> typeNames) {\n    this.typeNames = ImmutableNullableList.copyOf(typeNames);\n  }\n\n  //~ Methods ----------------------------------------------------------------\n\n  private static SqlTypeExplicitPrecedenceList list(SqlTypeName... typeNames) {\n    return list(Arrays.asList(typeNames));\n  }\n\n  private static SqlTypeExplicitPrecedenceList list(Iterable<SqlTypeName> typeNames) {\n    return new SqlTypeExplicitPrecedenceList(typeNames);\n  }\n\n  private static SqlTypeExplicitPrecedenceList numeric(SqlTypeName typeName) {\n    int i = getListPosition(typeName, COMPACT_NUMERIC_TYPES);\n    return new SqlTypeExplicitPrecedenceList(\n        Util.skip(COMPACT_NUMERIC_TYPES, i));\n  }\n\n  // implement RelDataTypePrecedenceList\n  public boolean containsType(RelDataType type) {\n    SqlTypeName typeName = type.getSqlTypeName();\n    return typeName != null && typeNames.contains(typeName);\n  }\n\n  // implement RelDataTypePrecedenceList\n<fim_suffix>  public int compareTypePrecedence(RelDataType type1, RelDataType type2) {\n    assert containsType(type1) : type1;\n    assert containsType(type2) : type2;\n\n    int p1 =\n        getListPosition(\n            type1.getSqlTypeName(),\n            typeNames);\n    int p2 =\n        getListPosition(\n            type2.getSqlTypeName(),\n            typeNames);\n    return p2 - p1;\n  }\n\n  private static int getListPosition(SqlTypeName type, List<SqlTypeName> list) {\n    int i = list.indexOf(type);\n    assert i != -1;\n\n    // adjust for precedence equivalence classes\n    for (int j = i - 1; j >= 0; --j) {\n      if (list.get(j) == null) {\n        return j;\n      }\n    }\n    return i;\n  }\n\n  static RelDataTypePrecedenceList getListForType(RelDataType type) {\n    SqlTypeName typeName = type.getSqlTypeName();\n    if (typeName == null) {\n      return null;\n    }\n    return TYPE_NAME_TO_PRECEDENCE_LIST.get(typeName);\n  }\n}\n\n// End SqlTypeExplicitPrecedenceList.java<fim_middle>// function below has no smell\n"}