{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions.aggregates;\n\nimport org.apache.hadoop.hive.ql.exec.Description;\nimport org.apache.hadoop.hive.ql.exec.vector.ColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorAggregationBufferRow;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorAggregationDesc;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\nimport org.apache.hadoop.hive.ql.udf.generic.GenericUDAFEvaluator.Mode;\nimport org.apache.hadoop.hive.ql.util.JavaDataModel;\n\n\n/**\n * VectorUDAFCountLong. Vectorized implementation for COUNT aggregates.\n */\n@Description(name = \"count\", value = \"_FUNC_(expr) - Returns the count (vectorized)\")\npublic class VectorUDAFCount extends VectorAggregateExpression {\n\n  private static final long serialVersionUID = 1L;\n\n    /**\n     * class for storing the current aggregate value.\n     */\n    static class Aggregation implements AggregationBuffer {\n\n      private static final long serialVersionUID = 1L;\n\n      transient private long count;\n\n      @Override\n      public int getVariableSize() {\n        throw new UnsupportedOperationException();\n      }\n\n      @Override\n      public void reset() {\n        count = 0L;\n      }\n    }\n\n    // This constructor is used to momentarily create the object so match can be called.\n    public VectorUDAFCount() {\n      super();\n    }\n\n    public VectorUDAFCount(VectorAggregationDesc vecAggrDesc) {\n      super(vecAggrDesc);\n      init();\n    }\n\n    private void init() {\n    }\n\n    private Aggregation getCurrentAggregationBuffer(\n        VectorAggregationBufferRow[] aggregationBufferSets,\n        int aggregateIndex,\n        int row) {\n      VectorAggregationBufferRow mySet = aggregationBufferSets[row];\n      Aggregation myagg = (Aggregation) mySet.getAggregationBuffer(aggregateIndex);\n      return myagg;\n    }\n\n    @Override\n    public void aggregateInputSelection(\n      VectorAggregationBufferRow[] aggregationBufferSets,\n      int aggregateIndex,\n      VectorizedRowBatch batch) throws HiveException {\n\n      int batchSize = batch.size;\n\n      if (batchSize == 0) {\n        return;\n      }\n\n      inputExpression.evaluate(batch);\n\n      ColumnVector inputVector = batch.cols[this.inputExpression.getOutputColumnNum()];\n\n      if (inputVector.isRepeating) {\n        if (inputVector.noNulls || !inputVector.isNull[0]) {\n          iterateNoNullsWithAggregationSelection(\n              aggregationBufferSets, aggregateIndex, batchSize);\n        }\n      } else if (inputVector.noNulls) {\n          // if there are no nulls then the iteration is the same on all cases\n          iterateNoNullsWithAggregationSelection(\n            aggregationBufferSets, aggregateIndex, batchSize);\n      } else if (!batch.selectedInUse) {\n          iterateHasNullsWithAggregationSelection(\n            aggregationBufferSets, aggregateIndex,\n            batchSize, inputVector.isNull);\n      } else if (batch.selectedInUse) {\n          iterateHasNullsSelectionWithAggregationSelection(\n            aggregationBufferSets, aggregateIndex,\n            batchSize, batch.selected, inputVector.isNull);\n      }\n    }\n\n    private void iterateNoNullsWithAggregationSelection(\n        VectorAggregationBufferRow[] aggregationBufferSets,\n        int aggregateIndex,\n        int batchSize) {\n\n        for (int i=0; i < batchSize; ++i) {\n          Aggregation myagg = getCurrentAggregationBuffer(\n            aggregationBufferSets,\n            aggregateIndex,\n            i);\n          myagg.count++;\n        }\n    }\n\n    private void iterateHasNullsWithAggregationSelection(\n        VectorAggregationBufferRow[] aggregationBufferSets,\n        int aggregateIndex,\n        int batchSize,\n        boolean[] isNull) {\n\n        for (int i=0; i < batchSize; ++i) {\n          if (!isNull[i]) {\n            Aggregation myagg = getCurrentAggregationBuffer(\n              aggregationBufferSets,\n              aggregateIndex,\n              i);\n            myagg.count++;\n          }\n        }\n    }\n\n    private void iterateHasNullsSelectionWithAggregationSelection(\n        VectorAggregationBufferRow[] aggregationBufferSets,\n        int aggregateIndex,\n        int batchSize,\n        int[] selection,\n        boolean[] isNull) {\n\n        for (int j=0; j < batchSize; ++j) {\n          int i = selection[j];\n          if (!isNull[i]) {\n            Aggregation myagg = getCurrentAggregationBuffer(\n              aggregationBufferSets,\n              aggregateIndex,\n              j);\n            myagg.count++;\n          }\n        }\n    }\n\n\n    @Override\n    public void aggregateInput(AggregationBuffer agg, VectorizedRowBatch batch)\n    throws HiveException {\n\n      inputExpression.evaluate(batch);\n\n      ColumnVector inputVector = batch.cols[this.inputExpression.getOutputColumnNum()];\n\n      int batchSize = batch.size;\n\n      if (batchSize == 0) {\n        return;\n      }\n\n      Aggregation myagg = (Aggregation)agg;\n\n      if (inputVector.isRepeating) {\n        if (inputVector.noNulls || !inputVector.isNull[0]) {\n          myagg.count += batchSize;\n        }\n        return;\n      }\n\n      if (inputVector.noNulls) {\n        myagg.count += batchSize;\n        return;\n      }\n      else if (!batch.selectedInUse) {\n        iterateNoSelectionHasNulls(myagg, batchSize, inputVector.isNull);\n      }\n      else {\n        iterateSelectionHasNulls(myagg, batchSize, inputVector.isNull, batch.selected);\n      }\n    }\n\n    private void iterateSelectionHasNulls(\n        Aggregation myagg,\n        int batchSize,\n        boolean[] isNull,\n        int[] selected) {\n\n      for (int j=0; j< batchSize; ++j) {\n        int i = selected[j];\n        if (!isNull[i]) {\n          myagg.count += 1;\n        }\n      }\n    }\n\n    private void iterateNoSelectionHasNulls(\n        Aggregation myagg,\n        int batchSize,\n        boolean[] isNull) {\n\n      for (int i=0; i< batchSize; ++i) {\n        if (!isNull[i]) {\n          myagg.count += 1;\n        }\n      }\n    }\n\n    @Override\n    public AggregationBuffer getNewAggregationBuffer() throws HiveException {\n      return new Aggregation();\n    }\n\n<fim_suffix>    @Override\n    public void reset(AggregationBuffer agg) throws HiveException {\n      Aggregation myAgg = (Aggregation) agg;\n      myAgg.reset();\n    }\n\n    @Override\n    public long getAggregationBufferFixedSize() {\n      JavaDataModel model = JavaDataModel.get();\n      return JavaDataModel.alignUp(\n        model.object() +\n        model.primitive2() +\n        model.primitive1(),\n        model.memoryAlign());\n    }\n\n  @Override\n  public boolean matches(String name, ColumnVector.Type inputColVectorType,\n      ColumnVector.Type outputColVectorType, Mode mode) {\n\n    /*\n     * Count *any* input except null which is for COUNT(*) and output is LONG.\n     *\n     * Just modes (PARTIAL1, COMPLETE).\n     */\n    return\n        name.equals(\"count\") &&\n        inputColVectorType != null &&\n        outputColVectorType == ColumnVector.Type.LONG &&\n        (mode == Mode.PARTIAL1 || mode == Mode.COMPLETE);\n  }\n\n  @Override\n  public void assignRowColumn(VectorizedRowBatch batch, int batchIndex, int columnNum,\n      AggregationBuffer agg) throws HiveException {\n\n    LongColumnVector outputColVector = (LongColumnVector) batch.cols[columnNum];\n    Aggregation myagg = (Aggregation) agg;\n    outputColVector.isNull[batchIndex] = false;\n    outputColVector.vector[batchIndex] = myagg.count;\n  }\n}<fim_middle>// function below has no smell\n"}