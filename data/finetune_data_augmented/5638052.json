{"text": "<fim_prefix>                PLAYERGLOBAL_HOME_TOKEN, playerglobalHome);\n            processed[i] = processed[i].replace( \n                AIR_HOME_TOKEN, airHome);\n        }\n        return processed;\n    }\n\t/**\n\t * Expands the {locale} token in a list of path elements\n\t * for the source-path or library-path,\n\t * and converts each path element from a String\n\t * to a VirtualFile.\n\t *\n\t * The treatment of a path element containing \"{locale}\"\n\t * depends on whether we are processing a source-path\n\t * or a library-path, and on whether we are compiling for\n\t * a single locale, multiple locales, or no locale:\n\t *\n\t * -source-path=foo,bar/{locale},baz -locale=en_US\n\t *   -> foo,bar/en_US,baz\n\t * -source-path=foo,bar/{locale},baz -locale=en_US,ja_JP\n\t *   -> foo,bar/en_US,bar/ja_JP,baz\n\t * -source-path=foo,bar/{locale},baz -locale=\n\t *   -> foo,baz\n\t * -library-path=foo,bar/{locale},baz -locale=en_US\n\t *   -> foo,bar/en_US,baz\n\t * -library-path=foo,bar/{locale},baz -locale=en_US,ja_JP\n\t *   -> foo,bar/en_US,bar/ja_JP,baz\n\t * -library-path=foo,bar/{locale},baz -locale=\n\t *   -> foo,baz\n\t */\n\tprivate VirtualFile[] expandLocaleToken(String[] pathlist, String[] locales, ConfigurationValue cv)\n\t\tthrows ConfigurationException\n\t{\n\t\tArrayList<VirtualFile> list = new ArrayList<VirtualFile>(pathlist.length);\n\t\t// Process each path element.\n\t\tfor (int i = 0; i < pathlist.length; i++)\n\t\t{\n\t\t\tString pathElement = pathlist[i];\n\t\t\t// Look for \"{locale}\".\n\t\t\tint localeTokenIndex = pathElement.indexOf(LOCALE_TOKEN);\n\t\t\tif (localeTokenIndex != -1)\n\t\t\t{\n\t\t\t\t// Expand this {locale}-containing path element\n\t\t\t\t// into 0, 1, or N path elements.\n\t\t\t\tfor (int j = 0; j < locales.length; j++)\n\t\t\t\t{\n\t\t\t\t\tString pathElementWithSubstitution = pathElement.replace(LOCALE_TOKEN, locales[j]);\n\t\t\t\t\taddPathElementToListAsVirtualFile(pathElementWithSubstitution, list, cv);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\taddPathElementToListAsVirtualFile(pathElement, list, cv);\n\t\t\t}\n\t\t}\n\t\tVirtualFile[] vfa = new VirtualFile[list.size()];\n\t\tlist.toArray(vfa);\n\t\treturn vfa;\n\t}\n\t/**\n\t * Helper method for getLocaleFileList().\n\t */\n\tprivate void addPathElementToListAsVirtualFile(String pathElement, ArrayList<VirtualFile> list, ConfigurationValue cv)\n\t\tthrows ConfigurationException\n\t{\n\t\ttry\n\t\t{\n\t\t\tVirtualFile vf = getVirtualFile(pathElement, cv);\n\t\t\tlist.add(vf);\n\t\t}\n\t\tcatch(ConfigurationException e)\n\t\t{\n\t\t\tif (cv == null)\n\t\t\t{\n\t\t\t\tthrow new ConfigurationException.CannotOpen(\n\t\t\t\t\t\tpathElement, null, null, -1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthrow new ConfigurationException.CannotOpen(\n\t\t\t\t\t\tpathElement, cv.getVar(), cv.getSource(), cv.getLine());\n\t\t\t}\n\t\t}\n\t}\n\t/*\n    private VirtualFile[] toVirtualFileArray(String[] files, ConfigurationValue cv)\n    \tthrows ConfigurationException\n    {\n    \tVirtualFile[] vfiles = new VirtualFile[files != null ? files.length : 0];\n    \tfor (int i = 0, length = vfiles.length; i < length; i++)\n    \t{\n    \t\tvfiles[i] = getVirtualFile(files[i], cv);\n    \t}\n    \treturn vfiles;\n    }\n    */\n    private VirtualFile getVirtualFile(String file, ConfigurationValue cv)\n    \tthrows ConfigurationException\n    {\n    \treturn ConfigurationPathResolver.getVirtualFile( file, configResolver, cv );\n    }\n    private File[] toFileArray(String[] files)\n    {\n    \tif(files != null) {\n\t\t\tFile[] fileArray = new File[files.length];\n\t\t\tint length = files.length;\n\t\t\tfor (int i = 0; i < length; i++) {\n\t\t\t\tfileArray[i] = new File(files[i]);\n\t\t\t}\n\t\t\treturn fileArray;\n\t\t}\n\t\treturn new File[0];\n    }\n    private Set<String> externs = new HashSet<String>();\n    Set<String> getExterns()\n    {\n        return externs;\n    }\n    public void addExtern(String extern)\n    {\n        this.externs.add(extern);\n    }\n    //\n    // 'compiler.accessible' option\n    //\n    private boolean accessible;\n    public boolean accessible()\n    {\n        return accessible;\n    }\n    public void setAccessible(boolean accessible)\n    {\n        this.accessible = accessible;\n    }\n    public void cfgAccessible( ConfigurationValue cv, boolean accessible )\n    {\n        this.accessible = accessible;\n    }\n\t//\n    // 'compiler.actionscript-file-encoding' option\n    //\n\t// user-defined AS3 file encoding\n\tprivate String actionscriptFileEncoding = null;\n\tpublic String getActionscriptFileEncoding()\n\t{\n\t\treturn actionscriptFileEncoding;\n\t}\n\tpublic String getEncoding()\n\t{\n\t\treturn getActionscriptFileEncoding();\n\t}\n\tpublic void cfgActionscriptFileEncoding(ConfigurationValue cv, String encoding)\n\t{\n\t\tactionscriptFileEncoding = encoding;\n\t}\n\t//\n    // 'compiler.adjust-opdebugline' option (hidden)\n    //\n\t// C: for internal use only. set it to false so that debugging mxmlc auto-generated code is easier.\n\tprivate boolean adjustOpDebugLine = true;\n\tpublic boolean adjustOpDebugLine()\n\t{\n\t\treturn adjustOpDebugLine;\n\t}\n\tpublic void cfgAdjustOpdebugline(ConfigurationValue cv, boolean b)\n\t{\n\t\tadjustOpDebugLine = b;\n\t}\n<fim_suffix>\tpublic static ConfigurationInfo getAdjustOpdebuglineInfo()\n\t{\n\t    return new AdvancedConfigurationInfo()\n\t    {\n\t\t    public boolean isHidden()\n\t\t    {\n\t\t\t    return true;\n\t\t    }\n\t    };\n\t}<fim_middle>// function below has no smell\n"}