{"text": "<fim_prefix>            // see PolyBezier about limits\n            final int count = (int)leis.readUInt();\n            final int points = Math.min(count, 16384);\n            size += LittleEndianConsts.INT_SIZE;\n            poly = new Path2D.Double(Path2D.WIND_EVEN_ODD, points);\n            Point2D pnt = new Point2D.Double();\n            for (int i=0; i<points; i++) {\n                size += readPoint(leis, pnt);\n                if (i==0) {\n                    if (hasStartPoint()) {\n                        poly.moveTo(pnt.getX(), pnt.getY());\n                    } else {\n                        // if this path is connected to the current position (= has no start point)\n                        // the first entry is a dummy entry and will be skipped later\n                        poly.moveTo(0,0);\n                        poly.lineTo(pnt.getX(), pnt.getY());\n                    }\n                } else {\n                    poly.lineTo(pnt.getX(), pnt.getY());\n                }\n            }\n            return size;\n        }\n        /**\n         * @return true, if start point is in the list of points. false, if start point is taken from the context\n         */\n        protected boolean hasStartPoint() {\n            return true;\n        }\n        @Override\n        protected FillDrawStyle getFillDrawStyle() {\n            // The polygon SHOULD be outlined using the current pen and filled using the current brush and\n            // polygon fill mode. The polygon SHOULD be closed automatically by drawing a line from the last\n            // vertex to the first.\n            return FillDrawStyle.FILL_DRAW;\n        }\n        @Override\n        public void draw(HemfGraphics ctx) {\n            ctx.draw(path -> path.append(poly, false), getFillDrawStyle());\n        }\n    }\n    /**\n     * The EMR_POLYGON16 record specifies a polygon consisting of two or more vertexes connected by straight lines.\n     * The polygon is outlined by using the current pen and filled by using the current brush and polygon fill mode.\n     * The polygon is closed automatically by drawing a line from the last vertex to the first\n     */\n    public static class EmfPolygon16 extends EmfPolygon {\n        @Override\n        public HemfRecordType getEmfRecordType() {\n            return HemfRecordType.polygon16;\n        }\n        @Override\n        protected long readPoint(LittleEndianInputStream leis, Point2D point) {\n            return readPointS(leis, point);\n        }\n    }\n    /**\n     * The EMR_POLYLINE record specifies a series of line segments by connecting the points in the\n     * specified array.\n     */\n    public static class EmfPolyline extends EmfPolygon {\n        @Override\n        public HemfRecordType getEmfRecordType() {\n            return HemfRecordType.polyline;\n        }\n        @Override\n        protected FillDrawStyle getFillDrawStyle() {\n            // The line segments SHOULD be drawn using the current pen.\n            return FillDrawStyle.DRAW;\n        }\n    }\n    /**\n     * The EMR_POLYLINE16 record specifies a series of line segments by connecting the points in the\n     * specified array.\n     */\n    public static class EmfPolyline16 extends EmfPolyline {\n        @Override\n        public HemfRecordType getEmfRecordType() {\n            return HemfRecordType.polyline16;\n        }\n        @Override\n        protected long readPoint(LittleEndianInputStream leis, Point2D point) {\n            return readPointS(leis, point);\n        }\n    }\n    /**\n     * The EMR_POLYBEZIERTO record specifies one or more Bezier curves based upon the current\n     * position.\n     */\n    public static class EmfPolyBezierTo extends EmfPolyBezier {\n        @Override\n        public HemfRecordType getEmfRecordType() {\n            return HemfRecordType.polyBezierTo;\n        }\n        @Override\n        protected boolean hasStartPoint() {\n            return false;\n        }\n        @Override\n        public void draw(HemfGraphics ctx) {\n            polyTo(ctx, poly, getFillDrawStyle());\n        }\n    }\n    /**\n     * The EMR_POLYBEZIERTO16 record specifies one or more Bezier curves based on the current\n     * position.\n     */\n    public static class EmfPolyBezierTo16 extends EmfPolyBezierTo {\n        @Override\n        public HemfRecordType getEmfRecordType() {\n            return HemfRecordType.polyBezierTo16;\n        }\n        @Override\n        protected long readPoint(LittleEndianInputStream leis, Point2D point) {\n            return readPointS(leis, point);\n        }\n    }\n    /** The EMR_POLYLINETO record specifies one or more straight lines based upon the current position. */\n    public static class EmfPolylineTo extends EmfPolyline {\n        @Override\n        public HemfRecordType getEmfRecordType() {\n            return HemfRecordType.polylineTo;\n        }\n        @Override\n        protected boolean hasStartPoint() {\n            return false;\n        }\n        @Override\n        public void draw(HemfGraphics ctx) {\n            polyTo(ctx, poly, getFillDrawStyle());\n        }\n    }\n    /**\n     * The EMR_POLYLINETO16 record specifies one or more straight lines based upon the current position.\n     * A line is drawn from the current position to the first point specified by the points field by using the\n     * current pen. For each additional line, drawing is performed from the ending point of the previous\n     * line to the next point specified by points.\n     */\n    public static class EmfPolylineTo16 extends EmfPolylineTo {\n        @Override\n        public HemfRecordType getEmfRecordType() {\n            return HemfRecordType.polylineTo16;\n        }\n        @Override\n        protected long readPoint(LittleEndianInputStream leis, Point2D point) {\n            return readPointS(leis, point);\n        }\n    }\n    /**\n     * The EMR_POLYPOLYGON record specifies a series of closed polygons.\n     */\n    public static class EmfPolyPolygon extends HwmfDraw.WmfPolyPolygon implements HemfRecord {\n        private final Rectangle2D bounds = new Rectangle2D.Double();\n        @Override\n        public HemfRecordType getEmfRecordType() {\n            return HemfRecordType.polyPolygon;\n        }\n        protected long readPoint(LittleEndianInputStream leis, Point2D point) {\n            return readPointL(leis, point);\n        }\n        @Override\n        public long init(LittleEndianInputStream leis, long recordSize, long recordId) throws IOException {\n            long size = readRectL(leis, bounds);\n            // A 32-bit unsigned integer that specifies the number of polygons.\n            long numberOfPolygons = leis.readUInt();\n            // A 32-bit unsigned integer that specifies the total number of points in all polygons.\n            long count = Math.min(16384, leis.readUInt());\n            size += 2 * LittleEndianConsts.INT_SIZE;\n            // An array of 32-bit unsigned integers that specifies the point count for each polygon.\n            long[] polygonPointCount = new long[(int)numberOfPolygons];\n            size += numberOfPolygons * LittleEndianConsts.INT_SIZE;\n            for (int i=0; i<numberOfPolygons; i++) {\n                polygonPointCount[i] = leis.readUInt();\n            }\n            Point2D pnt = new Point2D.Double();\n            for (long nPoints : polygonPointCount) {\n                /**\n                 * An array of WMF PointL objects that specifies the points for all polygons in logical units.\n                 * The number of points is specified by the Count field value.\n                 */\n                Path2D poly = new Path2D.Double(Path2D.WIND_EVEN_ODD, (int)nPoints);\n                for (int i=0; i<nPoints; i++) {\n                    size += readPoint(leis, pnt);\n                    if (i == 0) {\n                        poly.moveTo(pnt.getX(), pnt.getY());\n                    } else {\n                        poly.lineTo(pnt.getX(), pnt.getY());\n                    }\n                }\n                if (isClosed()) {\n                    poly.closePath();\n                }\n                polyList.add(poly);\n            }\n            return size;\n        }\n        @Override\n        public void draw(HemfGraphics ctx) {\n            Shape shape = getShape(ctx);\n            if (shape == null) {\n                return;\n            }\n            ctx.draw(path -> path.append(shape, false), getFillDrawStyle());\n        }\n    }\n    /**\n     * The EMR_POLYPOLYGON16 record specifies a series of closed polygons. Each polygon is outlined\n     * using the current pen, and filled using the current brush and polygon fill mode.\n     * The polygons drawn by this record can overlap.\n     */\n<fim_suffix>    public static class EmfPolyPolygon16 extends EmfPolyPolygon {\n        @Override\n        public HemfRecordType getEmfRecordType() {\n            return HemfRecordType.polyPolygon16;\n        }\n        @Override\n        protected long readPoint(LittleEndianInputStream leis, Point2D point) {\n            return readPointS(leis, point);\n        }\n    }<fim_middle>// class below has no smell\n"}