{"text": "<fim_prefix>        return atom;\n    }\n    private Atom getDREFAtom() {\n        Atom atom = new Atom(\"dref\", (byte)0, 0);\n        byte[] url = getURLAtom().getBytes();\n        byte[] data = new byte[4 + url.length];\n        data[3] = 0x01;  // entry count = 1\n        System.arraycopy(url, 0, data, 4, url.length);\n        atom.setData(data);\n        return atom;\n    }\n    private Atom getURLAtom() {\n        Atom atom = new Atom(\"url \", (byte)0, 0x01);  // flags = 0x01: data is self contained.\n        return atom;\n    }\n    private Atom getSTBLAtom() {\n        Atom atom = new Atom(\"stbl\");\n        atom.addChild(getSTSDAtom());\n        atom.addChild(getSTTSAtom());\n        atom.addChild(getSTSCAtom());\n        atom.addChild(getSTSZAtom());\n        atom.addChild(getSTCOAtom());\n        return atom;\n    }\n    private Atom getSTSDAtom() {\n        Atom atom = new Atom(\"stsd\", (byte)0, 0);\n        byte[] mp4a = getMP4AAtom().getBytes();\n        byte[] data = new byte[4 + mp4a.length];\n        data[3] = 0x01;  // entry count = 1\n        System.arraycopy(mp4a, 0, data, 4, mp4a.length);\n        atom.setData(data);\n        return atom;\n    }\n    // See also Part 14 section 5.6.1 of ISO/IEC 14496 for this atom.\n    private Atom getMP4AAtom() {\n        Atom atom = new Atom(\"mp4a\");\n        byte[] ase = new byte[] {  // Audio Sample Entry data\n                0, 0, 0, 0, 0, 0,  // reserved\n                0, 1,  // data reference index\n                0, 0, 0, 0,  // reserved\n                0, 0, 0, 0,  // reserved\n                (byte)(mChannels >> 8), (byte)mChannels,  // channel count\n                0, 0x10, // sample size\n                0, 0,  // pre-defined\n                0, 0,  // reserved\n                (byte)(mSampleRate >> 8), (byte)(mSampleRate), 0, 0,  // sample rate\n        };\n        byte[] esds = getESDSAtom().getBytes();\n        byte[] data = new byte[ase.length + esds.length];\n        System.arraycopy(ase, 0, data, 0, ase.length);\n        System.arraycopy(esds, 0, data, ase.length, esds.length);\n        atom.setData(data);\n        return atom;\n    }\n    private Atom getESDSAtom() {\n        Atom atom = new Atom(\"esds\", (byte)0, 0);\n        atom.setData(getESDescriptor());\n        return atom;\n    }\n    // Returns an ES Descriptor for an ISO/IEC 14496-3 audio stream, AAC LC, 44100Hz, 2 channels,\n    // 1024 samples per frame per channel. The decoder buffer size is set so that it can contain at\n    // least 2 frames. (See section 7.2.6.5 of ISO/IEC 14496-1 for more details).\n    private byte[] getESDescriptor() {\n        int[] samplingFrequencies = new int[] {96000, 88200, 64000, 48000, 44100, 32000, 24000,\n                22050, 16000, 12000, 11025, 8000, 7350};\n        // First 5 bytes of the ES Descriptor.\n        byte[] ESDescriptor_top = new byte[] {0x03, 0x19, 0x00, 0x00, 0x00};\n        // First 4 bytes of Decoder Configuration Descriptor. Audio ISO/IEC 14496-3, AudioStream.\n        byte[] decConfigDescr_top = new byte[] {0x04, 0x11, 0x40, 0x15};\n        // Audio Specific Configuration: AAC LC, 1024 samples/frame/channel.\n        // Sampling frequency and channels configuration are not set yet.\n        byte[] audioSpecificConfig = new byte[] {0x05, 0x02, 0x10, 0x00};\n        byte[] slConfigDescr = new byte[] {0x06, 0x01, 0x02};  // specific for MP4 file.\n        int offset;\n        int bufferSize = 0x300;\n        while (bufferSize < 2 * mMaxFrameSize) {\n            // TODO(nfaralli): what should be the minimum size of the decoder buffer?\n            // Should it be a multiple of 256?\n            bufferSize += 0x100;\n        }\n        // create the Decoder Configuration Descriptor\n        byte[] decConfigDescr = new byte[2 + decConfigDescr_top[1]];\n        System.arraycopy(decConfigDescr_top, 0, decConfigDescr, 0, decConfigDescr_top.length);\n        offset = decConfigDescr_top.length;\n        decConfigDescr[offset++] = (byte)((bufferSize >> 16) & 0xFF);\n        decConfigDescr[offset++] = (byte)((bufferSize >> 8) & 0xFF);\n        decConfigDescr[offset++] = (byte)(bufferSize & 0xFF);\n        decConfigDescr[offset++] = (byte)((mBitrate >> 24) & 0xFF);\n        decConfigDescr[offset++] = (byte)((mBitrate >> 16) & 0xFF);\n        decConfigDescr[offset++] = (byte)((mBitrate >> 8) & 0xFF);\n        decConfigDescr[offset++] = (byte)(mBitrate & 0xFF);\n        decConfigDescr[offset++] = (byte)((mBitrate >> 24) & 0xFF);\n        decConfigDescr[offset++] = (byte)((mBitrate >> 16) & 0xFF);\n        decConfigDescr[offset++] = (byte)((mBitrate >> 8) & 0xFF);\n        decConfigDescr[offset++] = (byte)(mBitrate & 0xFF);\n        int index;\n        for (index=0; index<samplingFrequencies.length; index++) {\n            if (samplingFrequencies[index] == mSampleRate) {\n                break;\n            }\n        }\n        if (index == samplingFrequencies.length) {\n            // TODO(nfaralli): log something here.\n            // Invalid sampling frequency. Default to 44100Hz...\n            index = 4;\n        }\n        audioSpecificConfig[2] |= (byte)((index >> 1) & 0x07);\n        audioSpecificConfig[3] |= (byte)(((index & 1) << 7) | ((mChannels & 0x0F) << 3));\n        System.arraycopy(\n                audioSpecificConfig, 0, decConfigDescr, offset, audioSpecificConfig.length);\n        // create the ES Descriptor\n        byte[] ESDescriptor = new byte[2 + ESDescriptor_top[1]];\n        System.arraycopy(ESDescriptor_top, 0, ESDescriptor, 0, ESDescriptor_top.length);\n        offset = ESDescriptor_top.length;\n        System.arraycopy(decConfigDescr, 0, ESDescriptor, offset, decConfigDescr.length);\n        offset += decConfigDescr.length;\n        System.arraycopy(slConfigDescr, 0, ESDescriptor, offset, slConfigDescr.length);\n        return ESDescriptor;\n    }\n<fim_suffix>    private Atom getSTTSAtom() {\n        Atom atom = new Atom(\"stts\", (byte)0, 0);\n        int numAudioFrames = mFrameSize.length - 1;\n        atom.setData(new byte[] {\n                0, 0, 0, 0x02,  // entry count\n                0, 0, 0, 0x01,  // first frame contains no audio\n                0, 0, 0, 0,\n                (byte)((numAudioFrames >> 24) & 0xFF), (byte)((numAudioFrames >> 16) & 0xFF),\n                (byte)((numAudioFrames >> 8) & 0xFF), (byte)(numAudioFrames & 0xFF),\n                0, 0, 0x04, 0,  // delay between frames = 1024 samples (cf. timescale = Fs)\n        });\n        return atom;\n    }<fim_middle>// function below has no smell\n"}