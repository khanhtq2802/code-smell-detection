{"text": "<fim_prefix>\n<fim_suffix>public final class PostgreSQLDatabaseFunctions {\n  /**\n   * Local cache for all tables currently in the database This is used to avoid multiple queries to\n   * the database if there are > 1 modules in the database.\n   */\n  protected static Multimap<Pair<CConnection, String>, String> m_cache = HashMultimap.create();\n  /**\n   * You are not supposed to instantiate this class.\n   */\n  private PostgreSQLDatabaseFunctions() {\n    // You are not supposed to instantiate this class.\n  }\n  /**\n   * Check arguments function to wrap a set of preconditions.\n   * \n   * @param provider The provider argument to check.\n   * @param debuggerManager The debugger manager argument to check.\n   */\n  protected static void checkArguments(final AbstractSQLProvider provider,\n      final DebuggerTemplateManager debuggerManager) {\n    Preconditions.checkNotNull(provider, \"IE00413: Provider argument can not be null\");\n    Preconditions.checkNotNull(debuggerManager,\n        \"IE01227: Debugger final manager argument can final not be null\");\n    Preconditions.checkArgument(debuggerManager.inSameDatabase(provider),\n        \"IE00415: Debugger manager is not part of the given database\");\n  }\n  /**\n   * Checks the existence of all necessary raw module tables.\n   * \n   * @param connection The connection to the database.\n   * @param databaseName The name of the database.\n   * @param rawModuleId The ID of the raw module whose tables are checked.\n   * @return True, if all necessary tables exist.\n   */\n  protected static boolean checkRawModulesTables(final CConnection connection,\n      final String databaseName, final int rawModuleId) {\n    Preconditions.checkNotNull(connection, \"IE02261: Connection argument can not be null\");\n    Preconditions.checkNotNull(databaseName, \"IE02262: Database name argument can not be null\");\n    Preconditions.checkArgument(rawModuleId > 0,\n        \"Raw module id %s must be a positive integer\", rawModuleId);\n    final ImmutableSet<String> rawTableNames =\n        ImmutableSet.of(String.format(CTableNames.RAW_ADDRESS_COMMENTS_TABLE, rawModuleId),\n            String.format(CTableNames.RAW_ADDRESS_REFERENCES_TABLE, rawModuleId),\n            String.format(CTableNames.RAW_BASE_TYPES, rawModuleId),\n            String.format(CTableNames.RAW_BASIC_BLOCK_INSTRUCTIONS_TABLE, rawModuleId),\n            String.format(CTableNames.RAW_BASIC_BLOCKS_TABLE, rawModuleId),\n            String.format(CTableNames.RAW_CALLGRAPH_TABLE, rawModuleId),\n            String.format(CTableNames.RAW_CONTROL_FLOW_GRAPHS_TABLE, rawModuleId),\n            String.format(CTableNames.RAW_EXPRESSION_NODES_TABLE, rawModuleId),\n            String.format(CTableNames.RAW_EXPRESSION_SUBSTITUTIONS_TABLE, rawModuleId),\n            String.format(CTableNames.RAW_EXPRESSION_TREE_NODES_TABLE, rawModuleId),\n            String.format(CTableNames.RAW_EXPRESSION_TREES_TABLE, rawModuleId),\n            String.format(CTableNames.RAW_EXPRESSION_TYPES_TABLE, rawModuleId),\n            String.format(CTableNames.RAW_FUNCTIONS_TABLE, rawModuleId),\n            String.format(CTableNames.RAW_INSTRUCTIONS_TABLE, rawModuleId),\n            String.format(CTableNames.RAW_OPERANDS_TABLE, rawModuleId),\n            String.format(CTableNames.RAW_SECTIONS, rawModuleId),\n            String.format(CTableNames.RAW_EXPRESSION_TYPE_INSTANCES, rawModuleId),\n            String.format(CTableNames.RAW_TYPE_INSTACES, rawModuleId),\n            String.format(CTableNames.RAW_TYPES, rawModuleId));\n    final Pair<CConnection, String> cacheKey = new Pair<>(connection, databaseName);\n    if (PostgreSQLDatabaseFunctions.queryCache(cacheKey, rawTableNames)) {\n      return true;\n    } else {\n      if (!PostgreSQLDatabaseFunctions.fillCache(cacheKey)) {\n        return false;\n      }\n      return PostgreSQLDatabaseFunctions.queryCache(cacheKey, rawTableNames);\n    }\n  }\n  /**\n   * Fill the local cache of all tables which are in the database.\n   * \n   * @return true if the cache could be filled.\n   */\n  protected static boolean fillCache(final Pair<CConnection, String> cacheKey) {\n    PostgreSQLDatabaseFunctions.m_cache.clear();\n    final String query =\n      \"SELECT table_name FROM information_schema.tables  WHERE table_catalog = '\"\n        + cacheKey.second() + \"' \";\n    try (ResultSet result = cacheKey.first().executeQuery(query, true)) {\n      while (result.next()) {\n        PostgreSQLDatabaseFunctions.m_cache.put(cacheKey, result.getString(1));\n      }\n    } catch (final SQLException exception) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Returns the raw module with the given ID.\n   * \n   * @param rawModuleId The ID to search for.\n   * @param rawModules The raw modules to search through.\n   * @return The raw module with the given ID.\n   */\n  protected static INaviRawModule findRawModule(final int rawModuleId,\n      final List<INaviRawModule> rawModules) {\n    Preconditions.checkArgument(rawModuleId > 0,\n        \"Raw module id %s must be positive integer\", rawModuleId);\n    Preconditions.checkNotNull(rawModules, \"IE02263: raw modules argument can not be null\");\n    for (final INaviRawModule rawModule : rawModules) {\n      if (rawModule.getId() == rawModuleId) {\n        return rawModule;\n      }\n    }\n    throw new IllegalStateException(\"IE00160: Could not find raw module\");\n  }\n  /**\n   * Determines the debuggers that are assigned to a project.\n   * \n   * @param connection Connection to the SQL database where the information is stored.\n   * @param projectId ID of the project in question.\n   * @param debuggerManager Debugger manager object that belongs to the given database.\n   * @return A list that contains the debugger templates assigned to the given project.\n   * @throws CouldntLoadDataException Thrown if the debugger templates could not be loaded.\n   */\n  protected static List<DebuggerTemplate> getAssignedDebuggers(final CConnection connection,\n      final int projectId, final DebuggerTemplateManager debuggerManager)\n      throws CouldntLoadDataException {\n    Preconditions.checkNotNull(connection, \"IE02264: Connection argument can not be null\");\n    Preconditions.checkArgument(projectId > 0, \"Project id %s must be a positive integer.\",\n        projectId);\n    Preconditions.checkNotNull(debuggerManager,\n        \"IE02265: debugger manager argument can not be null\");\n    final List<DebuggerTemplate> debuggerIds = new ArrayList<>();\n    final String query =\n        String.format(\"SELECT debugger_id FROM %s WHERE project_id = %d\",\n            CTableNames.PROJECT_DEBUGGERS_TABLE, projectId);\n    try (ResultSet resultSet = connection.executeQuery(query, true)) {\n      while (resultSet.next()) {\n        debuggerIds.add(debuggerManager.findDebugger(resultSet.getInt(\"debugger_id\")));\n      }\n    } catch (final SQLException exception) {\n      throw new CouldntLoadDataException(exception);\n    }\n    return debuggerIds;\n  }\n  /**\n   * Returns the number of functions in a raw module.\n   * \n   * @param connection Connection to the database.\n   * @param rawModuleId ID of the raw module.\n   * @return The number of functions in the raw module with the given ID.\n   * @throws SQLException Thrown if the number of functions could not be determined.\n   */\n  protected static int getRawModuleFunctionCount(final CConnection connection, final int rawModuleId)\n      throws SQLException {\n    Preconditions.checkNotNull(connection, \"IE02266: Connection argument can not be null\");\n    Preconditions.checkArgument(rawModuleId > 0,\n        \"Raw module id %s must be a positive integer\", rawModuleId);\n    final String query = \n        \"SELECT count(*) AS fcount \" + \" FROM ex_\" + rawModuleId\n            + \"_functions \" + \" WHERE address <> 0 \" + \" OR type <> 3\";\n    try (ResultSet resultSet = connection.executeQuery(query, true)) {\n      while (resultSet.next()) {\n        return resultSet.getInt(\"fcount\");\n      }\n    return 0;\n    } catch (final SQLException exception) {\n      throw new SQLException(\"Could not load function count\");\n    }\n  }\n  protected static ArrayList<Integer> getRawModuleIDs(final CConnection connection)\n      throws SQLException {\n    Preconditions.checkNotNull(connection, \"IE02267: Connection argument can not be null\");\n    final ArrayList<Integer> rawModuleIDs = new ArrayList<>();\n    try (ResultSet resultSet = connection.executeQuery(\"SELECT id FROM modules\", true)) {\n      while (resultSet.next()) {\n        rawModuleIDs.add(resultSet.getInt(\"id\"));\n      }\n    } catch (final Exception exception) {\n      return null;\n    }\n    return rawModuleIDs;\n  }<fim_middle>// class below is blob\n"}