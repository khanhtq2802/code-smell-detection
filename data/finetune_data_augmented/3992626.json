{"text": "<fim_prefix>import org.w3c.dom.Element;\nimport org.w3c.dom.events.Event;\nimport org.w3c.dom.events.EventTarget;\n/**\n * An abstract base class for elements that can have timing applied to them.\n * The concrete versions of this class do not necessarily have to be the\n * same as the DOM class, and in fact, this will mostly be impossible unless\n * creating new DOM classes that inherit from these elements.\n *\n * @author <a href=\"mailto:cam%40mcc%2eid%2eau\">Cameron McCormack</a>\n * @version $Id$\n */\npublic abstract class TimedElement implements SMILConstants {\n    // Constants for fill mode.\n    public static final int FILL_REMOVE = 0;\n    public static final int FILL_FREEZE = 1;\n    // Constants for restart mode.\n    public static final int RESTART_ALWAYS          = 0;\n    public static final int RESTART_WHEN_NOT_ACTIVE = 1;\n    public static final int RESTART_NEVER           = 2;\n    // Constants for time values.\n    public static final float INDEFINITE = Float.POSITIVE_INFINITY;\n    public static final float UNRESOLVED = Float.NaN;\n    /**\n     * The root time container.\n     */\n    protected TimedDocumentRoot root;\n    /**\n     * The parent time container.\n     */\n    protected TimeContainer parent;\n    /**\n     * Timing specifiers for the begin times of this element.\n     */\n    protected TimingSpecifier[] beginTimes;\n    /**\n     * Timing specifiers for the end times of this element.\n     */\n    protected TimingSpecifier[] endTimes;\n    /**\n     * Duration of this element, if {@link #durMedia} <code>= false</code>.\n     * If unspecified, it will be {@link #UNRESOLVED}.\n     */\n    protected float simpleDur;\n    /**\n     * Whether the simple duration of this element should be equal\n     * to the implicit duration.\n     */\n    protected boolean durMedia;\n    /**\n     * The number of repeats.  If unspecified, it will be\n     * {@link #UNRESOLVED}.\n     */\n    protected float repeatCount;\n    /**\n     * The duration of repeats.  If unspecified, it will be\n     * {@link #UNRESOLVED}.\n     */\n    protected float repeatDur;\n    /**\n     * The current repeat iteration.\n     */\n    protected int currentRepeatIteration;\n    /**\n     * The local active time of the last repeat.\n     */\n    protected float lastRepeatTime;\n    /**\n     * The fill mode for this element.  Uses the FILL_* constants\n     * defined in this class.\n     */\n    protected int fillMode;\n    /**\n     * The restart mode for this element.  Uses the RESTART_* constants\n     * defined in this class.\n     */\n    protected int restartMode;\n    /**\n     * The minimum active duration of this element.  If {@link #minMedia}\n     * <code>= true</code>, it will be <code>0f</code>.\n     */\n    protected float min;\n    /**\n     * Whether the min value was specified as 'media'.\n     */\n    protected boolean minMedia;\n    /**\n     * The maximum active duration of this element.  If {@link #maxMedia}\n     * <code>= true</code>, it will be {@link #INDEFINITE}.\n     */\n    protected float max;\n    /**\n     * Whether the max value was specified as 'media'.\n     */\n    protected boolean maxMedia;\n    /**\n     * Whether the element is currently active.\n     */\n    protected boolean isActive;\n    /**\n     * Whether the element is currently frozen.\n     */\n    protected boolean isFrozen;\n    /**\n     * The current time of this element in local active time.\n     */\n    protected float lastSampleTime;\n    /**\n     * The computed repeat duration of the element.\n     */\n    protected float repeatDuration;\n    /**\n     * List of begin InstanceTimes.\n     */\n    protected List beginInstanceTimes = new ArrayList();\n    /**\n     * List of end InstanceTimes.\n     */\n    protected List endInstanceTimes = new ArrayList();\n    /**\n     * The current Interval.\n     */\n    protected Interval currentInterval;\n    /**\n     * The end time of the previous interval, initially\n     * {@link Float#NEGATIVE_INFINITY}.\n     */\n    protected float lastIntervalEnd;\n    /**\n     * List of previous intervals.\n     */\n    // protected LinkedList previousIntervals = new LinkedList();\n    /**\n     * The previous interval.\n     */\n    protected Interval previousInterval;\n    /**\n     * List of TimingSpecifiers on other elements that depend on this\n     * element's begin times.\n     */\n    protected LinkedList beginDependents = new LinkedList();\n    /**\n     * List of TimingSpecifiers on other elements that depend on this\n     * element's end times.\n     */\n    protected LinkedList endDependents = new LinkedList();\n    /**\n     * Whether the list of instance times should be checked to update\n     * the current interval.\n     */\n    protected boolean shouldUpdateCurrentInterval = true;\n    /**\n     * Whether this timed element has parsed its timing attributes yet.\n     */\n    protected boolean hasParsed;\n    /**\n     * Map of {@link Event} objects to {@link HashSet}s of {@link\n     * TimingSpecifier}s that caught them.\n     */\n    protected Map handledEvents = new HashMap();\n    /**\n     * Whether this timed element is currently being sampled.\n     */\n    protected boolean isSampling;\n    /**\n     * Whether an instance time update message has already been propagated to\n     * this timed element.\n     */\n    protected boolean hasPropagated;\n    /**\n     * Creates a new TimedElement.\n     */\n    public TimedElement() {\n        beginTimes = new TimingSpecifier[0];\n        endTimes = beginTimes;\n        simpleDur = UNRESOLVED;\n        repeatCount = UNRESOLVED;\n        repeatDur = UNRESOLVED;\n        lastRepeatTime = UNRESOLVED;\n        max = INDEFINITE;\n        lastSampleTime = UNRESOLVED;\n        lastIntervalEnd = Float.NEGATIVE_INFINITY;\n    }\n    /**\n     * Returns the root time container of this timed element.\n     */\n    public TimedDocumentRoot getRoot() {\n        return root;\n    }\n    /**\n     * Returns the current active time of this element.\n     */\n    public float getActiveTime() {\n        return lastSampleTime;\n    }\n    /**\n     * Returns the current simple time of this element.\n     */\n    public float getSimpleTime() {\n        return lastSampleTime - lastRepeatTime;\n    }\n    /**\n     * Called by a TimingSpecifier of this element when a new\n     * InstanceTime is created.  This will be in response to an event\n     * firing, a DOM method being called or a new Instance being\n     * created by a syncbase element.\n     */\n    protected float addInstanceTime(InstanceTime time, boolean isBegin) {\n        // Trace.enter(this, \"addInstanceTime\", new Object[] { time, new Boolean(isBegin) } ); try {\n        hasPropagated = true;\n        List instanceTimes = isBegin ? beginInstanceTimes : endInstanceTimes;\n        int index = Collections.binarySearch(instanceTimes, time);\n        if (index < 0) {\n            index = -(index + 1);\n        }\n        instanceTimes.add(index, time);\n        shouldUpdateCurrentInterval = true;\n        float ret;\n        if (root.isSampling() && !isSampling) {\n            ret = sampleAt(root.getCurrentTime(), root.isHyperlinking());\n        } else {\n            ret = Float.POSITIVE_INFINITY;\n        }\n        hasPropagated = false;\n        root.currentIntervalWillUpdate();\n        return ret;\n        // } finally { Trace.exit(); }\n    }\n    /**\n     * Called by a TimingSpecifier of this element when an InstanceTime\n     * should be removed.  This will be in response to the pruning of an\n     * Interval.\n     */\n<fim_suffix>    protected float removeInstanceTime(InstanceTime time, boolean isBegin) {\n        // Trace.enter(this, \"removeInstanceTime\", new Object[] { time, new Boolean(isBegin) } ); try {\n        hasPropagated = true;\n        List instanceTimes = isBegin ? beginInstanceTimes : endInstanceTimes;\n        int index = Collections.binarySearch(instanceTimes, time);\n        for (int i = index; i >= 0; i--) {\n            InstanceTime it = (InstanceTime) instanceTimes.get(i);\n            if (it == time) {\n                instanceTimes.remove(i);\n                break;\n            }\n            if (it.compareTo(time) != 0) {\n                break;\n            }\n        }\n        int len = instanceTimes.size();\n        for (int i = index + 1; i < len; i++) {\n            InstanceTime it = (InstanceTime) instanceTimes.get(i);\n            if (it == time) {\n                instanceTimes.remove(i);\n                break;\n            }\n            if (it.compareTo(time) != 0) {\n                break;\n            }\n        }\n        shouldUpdateCurrentInterval = true;\n        float ret;\n        if (root.isSampling() && !isSampling) {\n            ret = sampleAt(root.getCurrentTime(), root.isHyperlinking());\n        } else {\n            ret = Float.POSITIVE_INFINITY;\n        }\n        hasPropagated = false;\n        root.currentIntervalWillUpdate();\n        return ret;\n        // } finally { Trace.exit(); }\n    }<fim_middle>// function below is long method\n"}