{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.dataflow.std.join;\nimport java.io.DataOutput;\nimport java.nio.ByteBuffer;\nimport org.apache.hyracks.api.comm.IFrame;\nimport org.apache.hyracks.api.comm.IFrameWriter;\nimport org.apache.hyracks.api.comm.VSizeFrame;\nimport org.apache.hyracks.api.context.IHyracksTaskContext;\nimport org.apache.hyracks.api.dataflow.value.IMissingWriter;\nimport org.apache.hyracks.api.dataflow.value.IPredicateEvaluator;\nimport org.apache.hyracks.api.dataflow.value.ITuplePairComparator;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\nimport org.apache.hyracks.api.io.FileReference;\nimport org.apache.hyracks.dataflow.common.comm.io.ArrayTupleBuilder;\nimport org.apache.hyracks.dataflow.common.comm.io.FrameTupleAccessor;\nimport org.apache.hyracks.dataflow.common.comm.io.FrameTupleAppender;\nimport org.apache.hyracks.dataflow.common.comm.util.FrameUtils;\nimport org.apache.hyracks.dataflow.common.io.RunFileReader;\nimport org.apache.hyracks.dataflow.common.io.RunFileWriter;\nimport org.apache.hyracks.dataflow.std.buffermanager.BufferInfo;\nimport org.apache.hyracks.dataflow.std.buffermanager.EnumFreeSlotPolicy;\nimport org.apache.hyracks.dataflow.std.buffermanager.FrameFreeSlotPolicyFactory;\nimport org.apache.hyracks.dataflow.std.buffermanager.VariableFrameMemoryManager;\nimport org.apache.hyracks.dataflow.std.buffermanager.VariableFramePool;\npublic class NestedLoopJoin {\n    private final FrameTupleAccessor accessorInner;\n    private final FrameTupleAccessor accessorOuter;\n    private final FrameTupleAppender appender;\n    private final ITuplePairComparator tpComparator;\n    private final IFrame outBuffer;\n    private final IFrame innerBuffer;\n    private final VariableFrameMemoryManager outerBufferMngr;\n    private final RunFileWriter runFileWriter;\n    private final boolean isLeftOuter;\n    private final ArrayTupleBuilder missingTupleBuilder;\n    private final IPredicateEvaluator predEvaluator;\n    private boolean isReversed; //Added for handling correct calling for predicate-evaluator upon recursive calls (in OptimizedHybridHashJoin) that cause role-reversal\n    private BufferInfo tempInfo = new BufferInfo(null, -1, -1);\n<fim_suffix>    public NestedLoopJoin(IHyracksTaskContext ctx, FrameTupleAccessor accessorOuter, FrameTupleAccessor accessorInner,\n            ITuplePairComparator comparatorsOuter2Inner, int memSize, IPredicateEvaluator predEval, boolean isLeftOuter,\n            IMissingWriter[] missingWriters) throws HyracksDataException {\n        this.accessorInner = accessorInner;\n        this.accessorOuter = accessorOuter;\n        this.appender = new FrameTupleAppender();\n        this.tpComparator = comparatorsOuter2Inner;\n        this.outBuffer = new VSizeFrame(ctx);\n        this.innerBuffer = new VSizeFrame(ctx);\n        this.appender.reset(outBuffer, true);\n        if (memSize < 3) {\n            throw new HyracksDataException(\"Not enough memory is available for Nested Loop Join\");\n        }\n        this.outerBufferMngr =\n                new VariableFrameMemoryManager(new VariableFramePool(ctx, ctx.getInitialFrameSize() * (memSize - 2)),\n                        FrameFreeSlotPolicyFactory.createFreeSlotPolicy(EnumFreeSlotPolicy.LAST_FIT, memSize - 2));\n        this.predEvaluator = predEval;\n        this.isReversed = false;\n        this.isLeftOuter = isLeftOuter;\n        if (isLeftOuter) {\n            int innerFieldCount = this.accessorInner.getFieldCount();\n            missingTupleBuilder = new ArrayTupleBuilder(innerFieldCount);\n            DataOutput out = missingTupleBuilder.getDataOutput();\n            for (int i = 0; i < innerFieldCount; i++) {\n                missingWriters[i].writeMissing(out);\n                missingTupleBuilder.addFieldEndOffset();\n            }\n        } else {\n            missingTupleBuilder = null;\n        }\n        FileReference file =\n                ctx.getJobletContext().createManagedWorkspaceFile(this.getClass().getSimpleName() + this.toString());\n        runFileWriter = new RunFileWriter(file, ctx.getIoManager());\n        runFileWriter.open();\n    }\n    public void cache(ByteBuffer buffer) throws HyracksDataException {\n        runFileWriter.nextFrame(buffer);\n    }\n    public void join(ByteBuffer outerBuffer, IFrameWriter writer) throws HyracksDataException {\n        if (outerBufferMngr.insertFrame(outerBuffer) < 0) {\n            RunFileReader runFileReader = runFileWriter.createReader();\n            try {\n                runFileReader.open();\n                while (runFileReader.nextFrame(innerBuffer)) {\n                    for (int i = 0; i < outerBufferMngr.getNumFrames(); i++) {\n                        blockJoin(outerBufferMngr.getFrame(i, tempInfo), innerBuffer.getBuffer(), writer);\n                    }\n                }\n            } finally {\n                runFileReader.close();\n            }\n            outerBufferMngr.reset();\n            if (outerBufferMngr.insertFrame(outerBuffer) < 0) {\n                throw new HyracksDataException(\"The given outer frame of size:\" + outerBuffer.capacity()\n                        + \" is too big to cache in the buffer. Please choose a larger buffer memory size\");\n            }\n        }\n    }\n    private void blockJoin(BufferInfo outerBufferInfo, ByteBuffer innerBuffer, IFrameWriter writer)\n            throws HyracksDataException {\n        accessorOuter.reset(outerBufferInfo.getBuffer(), outerBufferInfo.getStartOffset(), outerBufferInfo.getLength());\n        accessorInner.reset(innerBuffer);\n        int tupleCount0 = accessorOuter.getTupleCount();\n        int tupleCount1 = accessorInner.getTupleCount();\n        for (int i = 0; i < tupleCount0; ++i) {\n            boolean matchFound = false;\n            for (int j = 0; j < tupleCount1; ++j) {\n                int c = compare(accessorOuter, i, accessorInner, j);\n                boolean prdEval = evaluatePredicate(i, j);\n                if (c == 0 && prdEval) {\n                    matchFound = true;\n                    appendToResults(i, j, writer);\n                }\n            }\n            if (!matchFound && isLeftOuter) {\n                final int[] ntFieldEndOffsets = missingTupleBuilder.getFieldEndOffsets();\n                final byte[] ntByteArray = missingTupleBuilder.getByteArray();\n                final int ntSize = missingTupleBuilder.getSize();\n                FrameUtils.appendConcatToWriter(writer, appender, accessorOuter, i, ntFieldEndOffsets, ntByteArray, 0,\n                        ntSize);\n            }\n        }\n    }\n    private boolean evaluatePredicate(int tIx1, int tIx2) {\n        if (isReversed) { //Role Reversal Optimization is triggered\n            return ((predEvaluator == null) || predEvaluator.evaluate(accessorInner, tIx2, accessorOuter, tIx1));\n        } else {\n            return ((predEvaluator == null) || predEvaluator.evaluate(accessorOuter, tIx1, accessorInner, tIx2));\n        }\n    }\n    private void appendToResults(int outerTupleId, int innerTupleId, IFrameWriter writer) throws HyracksDataException {\n        if (isReversed) {\n            appendResultToFrame(accessorInner, innerTupleId, accessorOuter, outerTupleId, writer);\n        } else {\n            appendResultToFrame(accessorOuter, outerTupleId, accessorInner, innerTupleId, writer);\n        }\n    }\n    private void appendResultToFrame(FrameTupleAccessor accessor1, int tupleId1, FrameTupleAccessor accessor2,\n            int tupleId2, IFrameWriter writer) throws HyracksDataException {\n        FrameUtils.appendConcatToWriter(writer, appender, accessor1, tupleId1, accessor2, tupleId2);\n    }\n    public void closeCache() throws HyracksDataException {\n        if (runFileWriter != null) {\n            runFileWriter.close();\n        }<fim_middle>// function below is long method\n"}