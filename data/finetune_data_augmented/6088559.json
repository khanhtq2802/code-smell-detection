{"text": "<fim_prefix>     * We rely on our caller to have parsed the \"primary type\" and just handle\n     * the postfix {@code ?}, {@code [...]} or {@code (...)}\n     */\n    protected Type parsePrimaryType(Type type) {\n        while (lexer.lookingAt(TypeLexer.QN)\n                || lexer.lookingAt(TypeLexer.OPEN_SQ)\n                || lexer.lookingAt(TypeLexer.OPEN_PAR)) {\n            if (lexer.lookingAt(TypeLexer.QN)) {\n                type = parseOptionalType(type);\n            } else if (lexer.lookingAt(TypeLexer.OPEN_SQ)) {\n                type = parseSequenceType(type);\n            } else if (lexer.lookingAt(TypeLexer.OPEN_PAR)) {\n                type = parseCallableType(type);\n            }\n        }\n        return type;\n    }\n    /**\n     * Spec says:\n     * <blockquote><pre>\n     * CallableType: PrimaryType \"(\" (TypeList? | SpreadType) \")\"\n     * SpreadType: \"*\" UnionType\n     * </pre></blockquote>\n     * We rely on our caller to have parsed the primary type, and just handle \n     * the parenthesized argument list type.\n     */\n    private Type parseCallableType(Type primaryType) {\n        lexer.eat(TypeLexer.OPEN_PAR);\n        Type arguments;\n        if (lexer.lookingAt(TypeLexer.STAR)) {\n            lexer.eat(TypeLexer.STAR);\n            arguments = parseUnionType();\n        } else {\n            if (!lexer.lookingAt(TypeLexer.CLOSE_PAR)) {\n                TypeList typeList = parseTypeList();\n                arguments = typeList.asTuple();\n            } else {\n                arguments = unit.getEmptyType();\n            }\n        }\n        lexer.eat(TypeLexer.CLOSE_PAR);\n        return unit.getCallableDeclaration().appliedType(null, Arrays.asList(primaryType, arguments));\n    }\n    /**\n     * Spec says:\n     * <blockquote><pre>\n     *     SequenceType: PrimaryType \"[\" \"]\"\n     * </pre></blockquote>\n     * This method also handles the right hand variant of:\n     * <blockquote><pre>\n     *     TupleType: \"[\" TypeList \"]\" | PrimaryType \"[\" DecimalLiteral \"]\"\n     * </blockquote></pre>\n     * because it's more easily done here.\n     */\n    private Type parseSequenceType(Type elementType) {\n        lexer.eat(TypeLexer.OPEN_SQ);\n        Type result;\n        if (lexer.lookingAt(TypeLexer.WORD)) {\n            int length = lexer.eatDigits();\n            result = unit.getEmptyType();\n            while (length > 0) {\n                result = unit.getTupleDeclaration().appliedType(null, Arrays.asList(elementType, elementType, result));\n                length--;\n            }\n        } else {\n            result = unit.getSequentialType(elementType);\n        }\n        lexer.eat(TypeLexer.CLOSE_SQ);\n        return result;\n    }\n    /**\n     * Spec says:\n     * <blockquote><pre>\n     * OptionalType: PrimaryType \"?\"\n     * </pre></blockquote>\n     * We rely on our caller to have parsed the primary type\n     */\n    private Type parseOptionalType(Type type) {\n        lexer.eat(TypeLexer.QN);\n        return unit.getOptionalType(type);\n    }\n    /**\n     * Spec says:\n     * <blockquote><pre>\n     * IterableType: \"{\" UnionType (\"*\"|\"+\") \"}\"\n     * </blockquote></pre>\n     */\n    private Type parseIterableAbbreviatedType() {\n        lexer.eat(TypeLexer.OPEN_BR);\n        Type iterated = parseUnionType();\n        Type result = null;\n        if (lexer.lookingAt(TypeLexer.PLUS)) {\n            lexer.eat(TypeLexer.PLUS);\n            result = unit.getNonemptyIterableType(iterated);\n        } else if (lexer.lookingAt(TypeLexer.STAR)) {\n            lexer.eat(TypeLexer.STAR);\n            result = unit.getIterableType(iterated);\n        } else {\n            throw new TypeParserException(\"Expected multiplicity in abbreviated Iterable type: \"+lexer.index);\n        }\n        lexer.eat(TypeLexer.CLOSE_BR);\n        return result;\n    }\n    /**\n     * Spec says:\n     * <blockquote><pre>\n     * EmptyType: \"[\" \"]\"\n     * TupleType: \"[\" TypeList \"]\" | PrimaryType \"[\" DecimalLiteral \"]\"\n     * </blockquote></pre>\n     * This method doesn't handle the {@code X[123]} alternative of \n     * TupleType, that's done in {@link #parseSequenceType(Type)} instead.\n     */\n    private Type parseEmptyOrTupleType() {\n        lexer.eat(TypeLexer.OPEN_SQ);\n        if (lexer.lookingAt(TypeLexer.CLOSE_SQ)) {\n            return parseEmptyType();\n        }\n        TypeList typeList = parseTypeList();\n        final Type result = typeList.asTuple();\n        lexer.eat(TypeLexer.CLOSE_SQ);\n        return result;\n    }\n    /**\n     * Spec says:\n     * <blockquote><pre>\n     * EmptyType: \"[\" \"]\"\n     * </blockquote></pre>\n     */\n    protected Type parseEmptyType() {\n        lexer.eat(TypeLexer.CLOSE_SQ);\n        return unit.getEmptyType();\n    }\n    /**\n     * Helper for parsing tuple types.\n     */\n    class TypeList {\n        public TypeList(List<Type> types, boolean variadic, boolean atLeastOne, int defaulted) {\n            super();\n            this.types = types;\n            this.variadic = variadic;\n            this.atLeastOne = atLeastOne;\n            this.defaulted = defaulted;\n        }\n        public Type getFirst() {\n            return types.get(0);\n        }\n        List<Type> types;\n        boolean variadic;\n        boolean atLeastOne;\n        /**\n         * The number of defaulted types.\n         * For instance, the types <code>A,B,C,D,E</code> with <code>defaulted = 3</code>\n         * signify the type list <code>A,B,C=,D=,E=</code>.\n         * <p>\n         * Variadics are not counted as defaulted.\n         */\n        int defaulted;\n        Type getLast() {\n            return types.get(types.size()-1);\n        }\n<fim_suffix>        Type asTuple() {\n            final Type result;\n            if (types.size() == 0) {\n                result = unit.getEmptyType();\n            } else {\n                final Type sequentialType;\n                if (variadic) {\n                    Part part = new Part(\"Sequence\", Collections.singletonList(getLast()));\n                    sequentialType = loadType(\"ceylon.language\", \n                            atLeastOne ? \"ceylon.language.Sequence\" : \"ceylon.language.Sequential\", \n                                    part, null);\n                } else {\n                    sequentialType = unit.getEmptyType();\n                }\n                if (variadic && types.size() == 1) {\n                    result = sequentialType;\n                } else {\n                    Part part = new Part();\n                    // if we're variadic we put the element type there because we skip it below\n                    // if we're not variadic we are not going to skip it so let's not union it with itself\n                    Type union = variadic ? getLast() : null;\n                    Type tupleType = sequentialType;\n                    // A,B= \n                    // union = null\n                    // tupleType = []\n                    // t = B\n                    // union = B\n                    // tupleType = [B]\n                    // tupleType = [B]|[]\n                    // t = A\n                    // union = A|B\n                    // tupleType = [A,[B]|[]]\n                    // A=,B= \n                    // union = null\n                    // tupleType = []\n                    // t = B\n                    // union = B\n                    // tupleType = [B]\n                    // tupleType = [B]|[]\n                    // t = A\n                    // union = A|B\n                    // tupleType = [A,[B]|[]]\n                    // tupleType = [A,[B]|[]]|[]\n                    // A=,B* \n                    // union = B\n                    // tupleType = [B*]\n                    // t = A\n                    // union = A|B\n                    // tupleType = [A,[B*]]\n                    // tupleType = [A,[B*]]|[]\n                    int makeDefaulted = defaulted;\n                    for (int ii  = types.size()-(variadic? 2 : 1); ii >= 0; ii--) {\n                        Type t = types.get(ii);\n                        // FIXME: subtyping in the type parser may cause issues\n                        if(union != null) // any second element (variadic or not)\n                            union = ModelUtil.unionType(union, t, unit);\n                        else\n                            union = t; // any first element\n                        part.parameters = Arrays.asList(union, t, tupleType);\n                        part.name = \"Tuple\";\n                        tupleType = loadType(\"ceylon.language\", \"ceylon.language.Tuple\", part, null);\n                        if(makeDefaulted > 0){\n                            makeDefaulted--;\n                            tupleType = union(Arrays.asList(unit.getEmptyType(), tupleType), unit);\n                        }\n                    }\n                    result = tupleType;\n                }\n            }\n            return result;\n        }<fim_middle>// function below is long method\n"}