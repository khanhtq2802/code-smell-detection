{"text": "<fim_prefix>        if (!name.endsWith(\".mpg\") && !name.endsWith(\".ts\") && !name.endsWith(\".avi\") && !name.endsWith(\".mp4\") && !name.endsWith(\".mkv\")) continue;\n        if (accountedFiles.contains(testFiles[i].getAbsolutePath()) || ignoreFiles.contains(testFiles[i].getAbsolutePath())) continue;\n        if (testFiles[i].length() == 0)\n        {\n          if (testFiles[i].isFile())\n          {\n            if (Sage.DBG) System.out.println(\"Removing zero length file from video dir:\" + testFiles[i]);\n            testFiles[i].delete();\n          }\n          else\n          {\n            if (Sage.DBG) System.out.println(\"Skipping the removal of zero length file from video dir: \" + testFiles[i] + \" since it fails isFile()\");\n          }\n          continue;\n        }\n        // Make sure we can access the file. i.e. something else isn't still writing it\n        if (!checkFileAccess(testFiles[i]))\n        {\n          if (Sage.DBG) System.out.println(\"Ignoring file for import because we can't get access to it:\" + testFiles[i]);\n          continue;\n        }\n        if (Sage.getBoolean(\"advanced_video_file_recovery\", false))\n        {\n          if (tvFileList == null)\n          {\n            List<MediaFile> tempVec = new ArrayList<MediaFile>();\n            for (int j = 0; j < myFiles.length; j++)\n            {\n              if (myFiles[j].isTV())\n                tempVec.add(myFiles[j]);\n            }\n            tvFileList = tempVec.toArray(new MediaFile[0]);\n          }\n          MediaFile matchFile = doAdvancedFileRecovery(tvFileList, testFiles[i]);\n          if (matchFile != null)\n          {\n            tvFilesModified = true;\n            for (int k = 0; k < matchFile.getNumSegments(); k++)\n              accountedFiles.add(matchFile.getFile(k).getAbsolutePath());\n            continue;\n          }\n        }\n        /*\n         * This restores the media files if removed from the DB\n         */\n        Airing air = null;\n        int fileIdx = 0;\n        try\n        {\n          int idx1 = name.lastIndexOf('-');\n          if (idx1 != -1)\n          {\n            int idx2 = name.lastIndexOf('-', idx1 - 1);\n            if (idx2 != -1)\n            {\n              int airingID = Integer.parseInt(name.substring(idx2 + 1, idx1));\n              air = wiz.getAiringForID(airingID);\n              idx2 = name.indexOf('.', idx1);\n              if (idx2 != -1)\n                fileIdx = Integer.parseInt(name.substring(idx1 + 1, idx2));\n            }\n          }\n        }\n        catch (Exception nfe){}\n        if (air != null && fileIdx == 0)\n        {\n          if (wiz.getFileForAiring(air) != null)\n          {\n            // This happens when the user moves files between video directories. The correct\n            // way is to move things into a library import folder.\n            // If these files on longer exist that are in that MediaFile then switch them to be this file\n            MediaFile alternateMF = wiz.getFileForAiring(air);\n            if (alternateMF.getFile(0) != null && !alternateMF.getFile(0).exists())\n            {\n              if (Sage.DBG) System.out.println(\"Swapping MediaFile's file to be \" + testFiles[i] + \" from \" + alternateMF);\n              alternateMF.setFiles(new File[] { testFiles[i] });\n              alternateMF.thisIsComplete();\n            }\n            continue;\n          }\n          // If the timestamp for the file is totally off; then fix it. It's probably from an outside conversion\n          if (Math.abs(testFiles[i].lastModified() - air.getEndTime()) > Sage.MILLIS_PER_HR && air.getEndTime() < Sage.time())\n            testFiles[i].setLastModified(air.getEndTime());\n          MediaFile mf = wiz.addMediaFileRecovered(air, testFiles[i]);\n          // NARFLEX - 1-19-09 quite often we'll pull files back in through this recovery method; but they may have been\n          // edited. They could then end up as a partial and get auto-deleted; which is bad. So we should mark all of\n          // these as complete.\n          if (air.getEndTime() < Sage.time())\n          {\n            mf.thisIsComplete();\n          }\n          if (Sage.DBG) System.out.println(\"MediaFile RECOVERY Added \" + mf);\n          tvFilesModified = true;\n        }\n        else if (Sage.getBoolean(prefs + \"use_errant_dir\", false))\n        {\n          if (Sage.DBG) System.out.println(\"ERRANT VIDEO FILE \" + testFiles[i]);\n          File errantDir = new File(testFiles[i].getParentFile(), \"errant\");\n          IOUtils.safemkdirs(errantDir);\n          testFiles[i].renameTo(new File(errantDir, testFiles[i].getName()));\n        }\n        else\n        {\n          MediaFile mf = wiz.addMediaFile(testFiles[i], \"\", MediaFile.ACQUISITION_AUTOMATIC_BY_VIDEO_STORAGE_PATH);\n          PluginEventManager.postEvent(PluginEventManager.MEDIA_FILE_IMPORTED,\n              new Object[] { PluginEventManager.VAR_MEDIAFILE, mf });\n        }\n      }\n      if (tvFilesModified)\n        sched.kick(true);\n    }\n  }\n  private MediaFile doAdvancedFileRecovery(MediaFile[] fileList, File testFile)\n  {\n    boolean matchFound = false;\n    String name = testFile.getName();\n    for (int j = 0; j < fileList.length && !matchFound; j++)\n    {\n      for (int seg = 0; seg < fileList[j].getNumSegments(); seg++)\n      {\n        File segFile = fileList[j].getFile(seg);\n        // Make sure its name matches and that the original file is no longer there\n        String segFileName = segFile.getName();\n        // In case we converted over from Windows to Linux/Mac\n        if (!Sage.WINDOWS_OS)\n        {\n          int lastBS = segFileName.lastIndexOf('\\\\');\n          if (lastBS != -1)\n            segFileName = segFileName.substring(lastBS + 1);\n        }\n        if (segFileName.equals(name) && !segFile.isFile())\n        {\n          // Now check to make sure all the segment files in the set match\n          List<File> newFileSet = new ArrayList<File>();\n          for (int k = 0; k < fileList[j].getNumSegments(); k++)\n          {\n            File test2Seg = fileList[j].getFile(k);\n            if (k == seg)\n            {\n              newFileSet.add(testFile);\n              continue;\n            }\n            segFileName = test2Seg.getName();\n            // In case we converted over from Windows to Linux/Mac\n            if (!Sage.WINDOWS_OS)\n            {\n              int lastBS = segFileName.lastIndexOf('\\\\');\n              if (lastBS != -1)\n                segFileName = segFileName.substring(lastBS + 1);\n            }\n            File newSegFile = new File(testFile.getParentFile(), segFileName);\n            if (newSegFile.isFile() && !test2Seg.isFile())\n            {\n              newFileSet.add(newSegFile);\n              continue;\n            }\n            else\n            {\n              newFileSet = null;\n              break;\n            }\n          }\n          if (newFileSet != null)\n          {\n            if (Sage.DBG) System.out.println(\"Found matching media file for recovery of \" + testFile + \" to be \" + fileList[j]);\n            // Fix the modification timestamps on the files if they were copied and that was lost\n            for (int m = 0; m < newFileSet.size(); m++)\n              newFileSet.get(m).setLastModified(fileList[j].getEnd(m));\n            fileList[j].setFiles(newFileSet.toArray(new File[0]));\n            matchFound = true;\n            return fileList[j];\n          }\n          // stop checking segments for this file\n          break;\n        }\n      }\n    }\n    return null;\n  }\n  public boolean isDoingImportScan()\n  {\n    return currentlyImporting;\n  }\n<fim_suffix>  public void scanLibrary(boolean waitTillComplete)\n  {\n    doThoroughLibScan = true;\n    establishMountPoints();\n    if (!waitTillComplete)\n      libraryImportScan();\n    else\n    {\n      synchronized (importLock)\n      {\n        libraryImportScan();\n        while (currentlyImporting)\n        {\n          try { importLock.wait(0);}catch(InterruptedException e){}\n        }\n      }\n    }\n  }<fim_middle>// function below has no smell\n"}