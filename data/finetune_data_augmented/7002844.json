{"text": "<fim_prefix>// Copyright 2017 The Nomulus Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage google.registry.model.common;\n\nimport static com.google.common.collect.DiscreteDomain.integers;\nimport static com.google.common.collect.ImmutableList.toImmutableList;\nimport static google.registry.util.DateTimeUtils.END_OF_TIME;\nimport static google.registry.util.DateTimeUtils.START_OF_TIME;\nimport static google.registry.util.DateTimeUtils.isAtOrAfter;\nimport static google.registry.util.DateTimeUtils.isBeforeOrAt;\nimport static org.joda.time.DateTimeZone.UTC;\n\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.ContiguousSet;\nimport com.google.common.collect.Range;\nimport com.googlecode.objectify.annotation.Embed;\nimport com.googlecode.objectify.annotation.Index;\nimport google.registry.model.ImmutableObject;\nimport java.util.List;\nimport org.joda.time.DateTime;\n\n/**\n * A time of year (month, day, millis of day) that can be stored in a sort-friendly format.\n *\n * <p>This is conceptually similar to {@code MonthDay} in Joda or more generally to Joda's\n * {@code Partial}, but the parts we need are too simple to justify a full implementation of\n * {@code Partial}.\n *\n * <p>For simplicity, the native representation of this class's data is its stored format. This\n * allows it to be embeddable with no translation needed and also delays parsing of the string on\n * load until it's actually needed.\n */\n@Embed\npublic class TimeOfYear extends ImmutableObject {\n\n  /**\n   * The time as \"month day millis\" with all fields left-padded with zeroes so that lexographic\n   * sorting will do the right thing.\n   */\n  @Index\n  String timeString;\n\n  /**\n   * Constructs a {@link TimeOfYear} from a {@link DateTime}.\n   *\n   * <p>This handles leap years in an intentionally peculiar way by always treating February 29 as\n   * February 28. It is impossible to construct a {@link TimeOfYear} for February 29th.\n   */\n<fim_suffix>  public static TimeOfYear fromDateTime(DateTime dateTime) {\n    DateTime nextYear = dateTime.plusYears(1);  // This turns February 29 into February 28.\n    TimeOfYear instance = new TimeOfYear();\n    instance.timeString = String.format(\n        \"%02d %02d %08d\",\n        nextYear.getMonthOfYear(),\n        nextYear.getDayOfMonth(),\n        nextYear.getMillisOfDay());\n    return instance;\n  }\n\n  /**\n   * Returns an {@link Iterable} of {@link DateTime}s of every recurrence of this particular\n   * time of year within a given {@link Range} (usually one spanning many years).\n   *\n   * <p>WARNING: This can return a potentially very large {@link Iterable} if {@code END_OF_TIME}\n   * is used as the upper endpoint of the range.\n   */\n  public Iterable<DateTime> getInstancesInRange(Range<DateTime> range) {\n    // In registry world, all dates are within START_OF_TIME and END_OF_TIME, so restrict any\n    // ranges without bounds to our notion of zero-to-infinity.\n    Range<DateTime> normalizedRange = range.intersection(Range.closed(START_OF_TIME, END_OF_TIME));\n    Range<Integer> yearRange = Range.closed(\n        normalizedRange.lowerEndpoint().getYear(),\n        normalizedRange.upperEndpoint().getYear());\n    return ContiguousSet.create(yearRange, integers())\n        .stream()\n        .map(this::getDateTimeWithYear)\n        .filter(normalizedRange)\n        .collect(toImmutableList());\n  }\n\n  /** Get the first {@link DateTime} with this month/day/millis that is at or after the start. */\n  public DateTime getNextInstanceAtOrAfter(DateTime start) {\n    DateTime withSameYear = getDateTimeWithYear(start.getYear());\n    return isAtOrAfter(withSameYear, start) ? withSameYear : withSameYear.plusYears(1);\n  }\n\n  /** Get the first {@link DateTime} with this month/day/millis that is at or before the end. */\n  public DateTime getLastInstanceBeforeOrAt(DateTime end) {\n    DateTime withSameYear = getDateTimeWithYear(end.getYear());\n    return isBeforeOrAt(withSameYear, end) ? withSameYear : withSameYear.minusYears(1);\n  }\n\n  /**\n   * Return a new datetime with the same year as the parameter but projected to the month, day, and\n   * time of day of this object.\n   */\n  private DateTime getDateTimeWithYear(int year) {\n    List<String> monthDayMillis = Splitter.on(' ').splitToList(timeString);\n    // Do not be clever and use Ints.stringConverter here. That does radix guessing, and bad things\n    // will happen because of the leading zeroes.\n    return new DateTime(0, UTC)\n        .withYear(year)\n        .withMonthOfYear(Integer.parseInt(monthDayMillis.get(0)))\n        .withDayOfMonth(Integer.parseInt(monthDayMillis.get(1)))\n        .withMillisOfDay(Integer.parseInt(monthDayMillis.get(2)));\n  }\n}<fim_middle>// function below has no smell\n"}