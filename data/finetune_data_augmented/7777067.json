{"text": "<fim_prefix>import javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\npublic class ExpressionSelectors\n{\n  private ExpressionSelectors()\n  {\n    // No instantiation.\n  }\n  /**\n   * Makes a ColumnValueSelector whose getObject method returns an Object that is the value computed by\n   * an {@link ExprEval}.\n   *\n   * @see ExpressionSelectors#makeExprEvalSelector(ColumnSelectorFactory, Expr)\n   */\n  public static ColumnValueSelector makeColumnValueSelector(\n      ColumnSelectorFactory columnSelectorFactory,\n      Expr expression\n  )\n  {\n    final ColumnValueSelector<ExprEval> baseSelector = makeExprEvalSelector(columnSelectorFactory, expression);\n    return new ColumnValueSelector()\n    {\n      @Override\n      public double getDouble()\n      {\n        // No Assert for null handling as baseSelector already have it.\n        return baseSelector.getDouble();\n      }\n      @Override\n      public float getFloat()\n      {\n        // No Assert for null handling as baseSelector already have it.\n        return baseSelector.getFloat();\n      }\n      @Override\n      public long getLong()\n      {\n        // No Assert for null handling as baseSelector already have it.\n        return baseSelector.getLong();\n      }\n      @Override\n      public boolean isNull()\n      {\n        return baseSelector.isNull();\n      }\n      @Nullable\n      @Override\n      public Object getObject()\n      {\n        // No need for null check on getObject() since baseSelector impls will never return null.\n        //noinspection ConstantConditions\n        return baseSelector.getObject().value();\n      }\n      @Override\n      public Class classOfObject()\n      {\n        return Object.class;\n      }\n      @Override\n      public void inspectRuntimeShape(RuntimeShapeInspector inspector)\n      {\n        inspector.visit(\"baseSelector\", baseSelector);\n      }\n    };\n  }\n  /**\n   * Makes a ColumnValueSelector whose getObject method returns an {@link ExprEval}.\n   *\n   * @see ExpressionSelectors#makeColumnValueSelector(ColumnSelectorFactory, Expr)\n   */\n  public static ColumnValueSelector<ExprEval> makeExprEvalSelector(\n      ColumnSelectorFactory columnSelectorFactory,\n      Expr expression\n  )\n  {\n    final List<String> columns = Parser.findRequiredBindings(expression);\n    if (columns.size() == 1) {\n      final String column = Iterables.getOnlyElement(columns);\n      final ColumnCapabilities capabilities = columnSelectorFactory.getColumnCapabilities(column);\n      if (capabilities != null && capabilities.getType() == ValueType.LONG) {\n        // Optimization for expressions that hit one long column and nothing else.\n        return new SingleLongInputCachingExpressionColumnValueSelector(\n            columnSelectorFactory.makeColumnValueSelector(column),\n            expression,\n            !ColumnHolder.TIME_COLUMN_NAME.equals(column) // __time doesn't need an LRU cache since it is sorted.\n        );\n      } else if (capabilities != null\n                 && capabilities.getType() == ValueType.STRING\n                 && capabilities.isDictionaryEncoded()) {\n        // Optimization for expressions that hit one string column and nothing else.\n        return new SingleStringInputCachingExpressionColumnValueSelector(\n            columnSelectorFactory.makeDimensionSelector(new DefaultDimensionSpec(column, column, ValueType.STRING)),\n            expression\n        );\n      }\n    }\n    final Expr.ObjectBinding bindings = createBindings(expression, columnSelectorFactory);\n    if (bindings.equals(ExprUtils.nilBindings())) {\n      // Optimization for constant expressions.\n      return new ConstantExprEvalSelector(expression.eval(bindings));\n    }\n    // No special optimization.\n    return new ExpressionColumnValueSelector(expression, bindings);\n  }\n  public static DimensionSelector makeDimensionSelector(\n      final ColumnSelectorFactory columnSelectorFactory,\n      final Expr expression,\n      final ExtractionFn extractionFn\n  )\n  {\n    final List<String> columns = Parser.findRequiredBindings(expression);\n    if (columns.size() == 1) {\n      final String column = Iterables.getOnlyElement(columns);\n      final ColumnCapabilities capabilities = columnSelectorFactory.getColumnCapabilities(column);\n      if (capabilities != null\n          && capabilities.getType() == ValueType.STRING\n          && capabilities.isDictionaryEncoded()) {\n        // Optimization for dimension selectors that wrap a single underlying string column.\n        return new SingleStringInputDimensionSelector(\n            columnSelectorFactory.makeDimensionSelector(new DefaultDimensionSpec(column, column, ValueType.STRING)),\n            expression\n        );\n      }\n    }\n    final ColumnValueSelector<ExprEval> baseSelector = makeExprEvalSelector(columnSelectorFactory, expression);\n    if (baseSelector instanceof ConstantExprEvalSelector) {\n      // Optimization for dimension selectors on constants.\n      return DimensionSelector.constant(baseSelector.getObject().asString(), extractionFn);\n    } else if (baseSelector instanceof NilColumnValueSelector) {\n      // Optimization for null dimension selector.\n      return DimensionSelector.constant(null);\n    } else if (extractionFn == null) {\n      class DefaultExpressionDimensionSelector extends BaseSingleValueDimensionSelector\n      {\n        @Override\n        protected String getValue()\n        {\n          return NullHandling.emptyToNullIfNeeded(baseSelector.getObject().asString());\n        }\n        @Override\n        public void inspectRuntimeShape(RuntimeShapeInspector inspector)\n        {\n          inspector.visit(\"baseSelector\", baseSelector);\n        }\n      }\n      return new DefaultExpressionDimensionSelector();\n    } else {\n      class ExtractionExpressionDimensionSelector extends BaseSingleValueDimensionSelector\n      {\n        @Override\n        protected String getValue()\n        {\n          return extractionFn.apply(NullHandling.emptyToNullIfNeeded(baseSelector.getObject().asString()));\n        }\n        @Override\n        public void inspectRuntimeShape(RuntimeShapeInspector inspector)\n        {\n          inspector.visit(\"baseSelector\", baseSelector);\n          inspector.visit(\"extractionFn\", extractionFn);\n        }\n      }\n      return new ExtractionExpressionDimensionSelector();\n    }\n  }\n  private static Expr.ObjectBinding createBindings(Expr expression, ColumnSelectorFactory columnSelectorFactory)\n  {\n    final Map<String, Supplier<Object>> suppliers = new HashMap<>();\n    final List<String> columns = Parser.findRequiredBindings(expression);\n    for (String columnName : columns) {\n      final ColumnCapabilities columnCapabilities = columnSelectorFactory\n          .getColumnCapabilities(columnName);\n      final ValueType nativeType = columnCapabilities != null ? columnCapabilities.getType() : null;\n      final Supplier<Object> supplier;\n      if (nativeType == ValueType.FLOAT) {\n        ColumnValueSelector selector = columnSelectorFactory\n            .makeColumnValueSelector(columnName);\n        supplier = makeNullableSupplier(selector, selector::getFloat);\n      } else if (nativeType == ValueType.LONG) {\n        ColumnValueSelector selector = columnSelectorFactory\n            .makeColumnValueSelector(columnName);\n        supplier = makeNullableSupplier(selector, selector::getLong);\n      } else if (nativeType == ValueType.DOUBLE) {\n        ColumnValueSelector selector = columnSelectorFactory\n            .makeColumnValueSelector(columnName);\n        supplier = makeNullableSupplier(selector, selector::getDouble);\n      } else if (nativeType == ValueType.STRING) {\n        supplier = supplierFromDimensionSelector(\n            columnSelectorFactory\n                .makeDimensionSelector(new DefaultDimensionSpec(columnName, columnName))\n        );\n      } else if (nativeType == null) {\n        // Unknown ValueType. Try making an Object selector and see if that gives us anything useful.\n        supplier = supplierFromObjectSelector(columnSelectorFactory.makeColumnValueSelector(columnName));\n      } else {\n        // Unhandleable ValueType (COMPLEX).\n        supplier = null;\n      }\n      if (supplier != null) {\n        suppliers.put(columnName, supplier);\n      }\n    }\n    if (suppliers.isEmpty()) {\n      return ExprUtils.nilBindings();\n    } else if (suppliers.size() == 1 && columns.size() == 1) {\n      // If there's only one column (and it has a supplier), we can skip the Map and just use that supplier when\n      // asked for something.\n      final String column = Iterables.getOnlyElement(suppliers.keySet());\n      final Supplier<Object> supplier = Iterables.getOnlyElement(suppliers.values());\n      return identifierName -> {\n        // There's only one binding, and it must be the single column, so it can safely be ignored in production.\n        assert column.equals(identifierName);\n        return supplier.get();\n      };\n    } else {\n      return Parser.withSuppliers(suppliers);\n    }\n  }\n  private static <T> Supplier<T> makeNullableSupplier(\n      ColumnValueSelector selector,\n      Supplier<T> supplier\n  )\n  {\n    if (NullHandling.replaceWithDefault()) {\n      return supplier;\n    } else {\n      return () -> {\n        if (selector.isNull()) {\n          return null;\n        }\n        return supplier.get();\n      };\n    }\n  }\n<fim_suffix>  @VisibleForTesting\n  @Nonnull\n  static Supplier<Object> supplierFromDimensionSelector(final DimensionSelector selector)\n  {\n    Preconditions.checkNotNull(selector, \"selector\");\n    return () -> {\n      final IndexedInts row = selector.getRow();\n      if (row.size() == 1) {\n        return selector.lookupName(row.get(0));\n      } else {\n        // Can't handle non-singly-valued rows in expressions.\n        // Treat them as nulls until we think of something better to do.\n        return null;\n      }\n    };\n  }<fim_middle>// function below is feature envy\n"}