{"text": "<fim_prefix>import org.eclipse.birt.core.i18n.ResourceConstants;\nimport org.eclipse.birt.core.util.IOUtil;\n<fim_suffix>public class FolderArchiveFile implements IArchiveFile\n{\n\tprivate static final String METEDATA = \".metadata\";\n\tprivate static Logger logger = Logger.getLogger( FolderArchiveFile.class\n\t\t\t.getName( ) );\n\tprotected String folderName;\n\tprotected String systemId;\n\tprotected String dependId;\n\tprivate HashSet<RAFolderInputStream> inputStreams = new HashSet<RAFolderInputStream>( );\n\tprivate HashSet<RAFolderOutputStream> outputStreams = new HashSet<RAFolderOutputStream>( );\n\tprotected Map<String, String> properties = new HashMap<String, String>();\n    public FolderArchiveFile( String name ) throws IOException\n    {\n        if ( name == null || name.length( ) == 0 )\n            throw new IOException(\n                    CoreMessages\n                            .getString( ResourceConstants.FOLDER_NAME_IS_NULL ) );\n        File file = new File( name );\n        file.mkdirs( );\n        this.folderName = file.getCanonicalPath( );\n        readMetaData( );\n    }\n    public String getName( )\n    {\n        return folderName;\n    }\n    private void readMetaData( ) throws IOException\n    {\n        // serialize meta data into .metedata file\n        String meta = ArchiveUtil.getFullPath( folderName, METEDATA );\n        File file = new File( meta );\n        if ( file.exists( ) && file.isFile( ) )\n        {\n            DataInputStream data = new DataInputStream( new FileInputStream(\n                    file ) );\n            try\n            {\n                properties = (Map<String, String>) IOUtil.readMap( data );\n            }\n            finally\n            {\n                data.close( );\n            }\n        }\n    }\n    private void saveMetaData( ) throws IOException\n    {\n        // serialize meta data into .metedata file\n        String meta = ArchiveUtil.getFullPath( folderName, METEDATA );\n        File file = new File( meta );\n        DataOutputStream data = new DataOutputStream( new FileOutputStream(\n                file ) );\n        try\n        {\n            IOUtil.writeMap( data, this.properties );\n        }\n        finally\n        {\n            data.close( );\n        }\n    }\n    public void close( ) throws IOException\n    {\n        saveMetaData( );\n        IOException exception = null;\n        synchronized ( outputStreams )\n        {\n            ArrayList<RAFolderOutputStream> outputs = new ArrayList<RAFolderOutputStream>(\n                    outputStreams );\n            for ( RAFolderOutputStream output : outputs )\n            {\n                try\n                {\n                    output.close( );\n                }\n                catch ( IOException ex )\n                {\n                    logger.log( Level.SEVERE, ex.getMessage( ), ex );\n                    if ( exception != null )\n                    {\n                        exception = ex;\n                    }\n                }\n            }\n            outputStreams.clear( );\n        }\n        synchronized ( inputStreams )\n        {\n            ArrayList<RAFolderInputStream> inputs = new ArrayList<RAFolderInputStream>(\n                    inputStreams );\n            for ( RAFolderInputStream input : inputs )\n            {\n                try\n                {\n                    input.close( );\n                }\n                catch ( IOException ex )\n                {\n                    logger.log( Level.SEVERE, ex.getMessage( ), ex );\n                    if ( exception != null )\n                    {\n                        exception = ex;\n                    }\n                }\n            }\n            inputStreams.clear( );\n        }\n        if ( exception != null )\n        {\n            throw exception;\n        }\n        // ArchiveUtil.archive( folderName, null, fileName );\n    }\n\tpublic void flush( ) throws IOException\n\t{\n\t\tIOException ioex = null;\n\t\tsynchronized ( outputStreams )\n\t\t{\n\t\t\tfor ( RAOutputStream output : outputStreams )\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\toutput.flush( );\n\t\t\t\t}\n\t\t\t\tcatch ( IOException ex )\n\t\t\t\t{\n\t\t\t\t\tlogger.log(Level.SEVERE, ex.getMessage( ), ex);\n\t\t\t\t\tif ( ioex != null )\n\t\t\t\t\t{\n\t\t\t\t\t\tioex = ex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( ioex != null )\n\t\t{\n\t\t\tthrow ioex;\n\t\t}\n\t}\n\tpublic void refresh( ) throws IOException\n\t{\n\t}\n\tpublic boolean exists( String name )\n\t{\n\t\tString path = getFilePath( name );\n\t\tFile fd = new File( path );\n\t\treturn fd.exists( );\n\t}\n\tpublic void setCacheSize( long cacheSize )\n\t{\n\t}\n\tpublic long getUsedCache( )\n\t{\n\t\treturn 0;\n\t}\n\tpublic ArchiveEntry openEntry( String name ) throws IOException\n\t{\n        String fullPath = getFilePath( name );\n\t\tFile fd = new File( fullPath );\n\t\tif(fd.exists( ))\n\t\t{\n\t\t\treturn new FolderArchiveEntry( name, fd, inputStreams, outputStreams );\n\t\t}\n\t\tthrow new FileNotFoundException( fullPath );\n\t}\n    public List<String> listEntries( String namePattern )\n    {\n        ArrayList<String> streamList = new ArrayList<String>( );\n        String storagePath = getFolderPath( namePattern );\n        ArrayList<File> files = new ArrayList<File>( );\n        ArchiveUtil.listAllFiles( new File( storagePath ), files );\n        for ( File file : files )\n        {\n            String relativePath = ArchiveUtil.getRelativePath( folderName,\n                    file.getPath( ) );\n            if ( !ArchiveUtil.needSkip( relativePath ) )\n            {\n                String entryName = ArchiveUtil.getEntryName( folderName,\n                        file.getPath( ) );\n                streamList.add( entryName );\n            }\n        }\n        return streamList;\n    }\n\tpublic ArchiveEntry createEntry( String name ) throws IOException\n\t{\n\t\tString path = getFilePath( name );\n\t\tFile fd = new File( path );\n\t\tArchiveUtil.createParentFolder( fd );\n\t\tFolderArchiveEntry out = new FolderArchiveEntry( name, fd, inputStreams, outputStreams  );\n\t\treturn out;\n\t}\n\tpublic boolean removeEntry( String name ) throws IOException\n\t{\n        String path = getFilePath( name );\n\t\ttry\n\t\t{\n\t\t\tFile fd = new File( path );\n\t\t\treturn ArchiveUtil.removeFileAndFolder( fd );\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tsynchronized ( outputStreams )\n\t\t\t{\n\t\t\t\tArrayList<RAFolderOutputStream> outputs = new ArrayList<RAFolderOutputStream>(\n\t\t\t\t\t\toutputStreams );\n\t\t\t\tfor ( RAFolderOutputStream output : outputs )\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tif(name.equals( output.getName( ) ))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\toutput.close( );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcatch ( IOException ex )\n\t\t\t\t\t{\n\t\t\t\t\t\tlogger.log(Level.SEVERE, ex.getMessage( ), ex);\n\t\t\t\t\t\tthrow ex;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpublic Object lockEntry( String entry ) throws IOException\n\t{\n        String path = getFilePath( entry ) + \".lck\";\n\t\tIArchiveLockManager lockManager = ArchiveLockManager.getInstance( );\n\t\treturn lockManager.lock( path );\n\t}\n\tpublic void unlockEntry( Object locker ) throws IOException\n\t{\n\t\tIArchiveLockManager lockManager = ArchiveLockManager.getInstance( );\n\t\tlockManager.unlock( locker );\n\t}\n\tpublic String getSystemId( )\n\t{\n\t\tif ( properties.containsKey( ArchiveFileV3.PROPERTY_SYSTEM_ID ) )\n\t\t{\n\t\t\treturn properties.get( ArchiveFileV3.PROPERTY_SYSTEM_ID )\n\t\t\t\t\t.toString( );\n\t\t}\n\t\treturn null;\n\t}\n\tpublic String getDependId( )\n\t{\n\t\tif ( properties.containsKey( ArchiveFileV3.PROPERTY_DEPEND_ID ) )\n\t\t{\n\t\t\treturn properties.get( ArchiveFileV3.PROPERTY_DEPEND_ID )\n\t\t\t\t\t.toString( );\n\t\t}\n\t\treturn null;\n\t}\n\tpublic void setSystemId(String systemId)\n\t{\n\t\tif(systemId!=null)\n\t\t{\n\t\t\tthis.properties.put( ArchiveFileV3.PROPERTY_SYSTEM_ID, systemId );\n\t\t}\n\t}\n\tpublic void setDependId(String dependId)\n\t{\n\t\tif(dependId!=null)\n\t\t{\n\t\t\tthis.properties.put( ArchiveFileV3.PROPERTY_DEPEND_ID, dependId );\n\t\t}\n\t}\n\tpublic void save( ) throws IOException\n\t{\n\t\tflush();\n\t}\n\tpublic long getLength( )\n\t{\n\t\tlong result = 0;\n\t\tList<String> entries = listEntries( null );\n\t\tfor( String entry : entries )\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tresult += openEntry( entry ).getLength( );\n\t\t\t}\n\t\t\tcatch ( IOException e )\n\t\t\t{\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n    private String getFilePath( String entryName )\n    {\n        return ArchiveUtil.getFilePath( folderName, entryName );\n    }\n    private String getFolderPath( String entryName )\n    {\n        return ArchiveUtil.getFolderPath( folderName, entryName );\n    }\n}<fim_middle>// class below is data class\n"}