{"text": "<fim_prefix>import java.util.concurrent.ConcurrentMap;\nimport org.apache.cayenne.CayenneRuntimeException;\nimport org.apache.cayenne.map.Entity;\n/**\n * Utility methods to quickly access object properties. This class supports\n * simple and nested properties and also conversion of property values to match\n * property type. No converter customization is provided yet, so only basic\n * converters for Strings, Numbers and primitives are available.\n * \n * @since 1.2\n */\npublic class PropertyUtils {\n\tprivate static final ConcurrentMap<String, Accessor> PATH_ACCESSORS = new ConcurrentHashMap<>();\n\tprivate static final ConcurrentMap<Class<?>, ConcurrentMap<String, Accessor>> SEGMENT_ACCESSORS = new ConcurrentHashMap<>();\n    /**\n     * Factory for accessor, can be customized by {@link #installAccessorFactory(AccessorFactory)}\n     */\n\tprivate static AccessorFactory accessorFactory = BeanAccessor::new;\n\t/**\n\t * Compiles an accessor that can be used for fast access for the nested\n\t * property of the objects of a given class.\n\t * \n\t * @since 4.0\n\t */\n\tpublic static Accessor accessor(String nestedPropertyName) {\n\t\tif (nestedPropertyName == null) {\n\t\t\tthrow new IllegalArgumentException(\"Null property name.\");\n\t\t}\n\t\tif (nestedPropertyName.length() == 0) {\n\t\t\tthrow new IllegalArgumentException(\"Empty property name.\");\n\t\t}\n\t\t// PathAccessor is simply a chain of path segment wrappers. The actual\n\t\t// accessor is resolved (with caching) during evaluation. Otherwise we\n\t\t// won't be able to handle subclasses of declared property types...\n\t\t// TODO: perhaps Java 7 MethodHandles are the answer to truly \"compiled\"\n\t\t// path accessor?\n\t\treturn compilePathAccessor(nestedPropertyName);\n\t}\n\tstatic Accessor compilePathAccessor(String path) {\n\t\tAccessor accessor = PATH_ACCESSORS.get(path);\n\t\tif (accessor == null) {\n\t\t\tint dot = path.indexOf(Entity.PATH_SEPARATOR);\n\t\t\tif (dot == 0 || dot == path.length() - 1) {\n\t\t\t\tthrow new IllegalArgumentException(\"Invalid path: \" + path);\n\t\t\t}\n\t\t\tString segment = dot < 0 ? path : path.substring(0, dot);\n\t\t\tAccessor remainingAccessor = dot < 0 ? null : compilePathAccessor(path.substring(dot + 1));\n\t\t\tAccessor newAccessor = new PathAccessor(segment, remainingAccessor);\n\t\t\tAccessor existingAccessor = PATH_ACCESSORS.putIfAbsent(path, newAccessor);\n\t\t\taccessor = existingAccessor != null ? existingAccessor : newAccessor;\n\t\t}\n\t\treturn accessor;\n\t}\n\tstatic Accessor getOrCreateSegmentAccessor(Class<?> objectClass, String propertyName) {\n\t\tConcurrentMap<String, Accessor> forType = SEGMENT_ACCESSORS.get(objectClass);\n\t\tif (forType == null) {\n\t\t\tConcurrentMap<String, Accessor> newPropAccessors = new ConcurrentHashMap<String, Accessor>();\n\t\t\tConcurrentMap<String, Accessor> existingPropAccessors = SEGMENT_ACCESSORS.putIfAbsent(objectClass,\n\t\t\t\t\tnewPropAccessors);\n\t\t\tforType = existingPropAccessors != null ? existingPropAccessors : newPropAccessors;\n\t\t}\n\t\tAccessor a = forType.get(propertyName);\n\t\tif (a == null) {\n\t\t\tAccessor newA = createSegmentAccessor(objectClass, propertyName);\n\t\t\tAccessor existingA = forType.putIfAbsent(propertyName, newA);\n\t\t\ta = existingA != null ? existingA : newA;\n\t\t}\n\t\treturn a;\n\t}\n\tstatic Accessor createSegmentAccessor(Class<?> objectClass, String propertyName) {\n\t\tif (Map.class.isAssignableFrom(objectClass)) {\n\t\t\treturn new MapAccessor(propertyName);\n\t\t} else {\n\t\t\treturn accessorFactory.createAccessor(objectClass, propertyName, null);\n\t\t}\n\t}\n\t/**\n\t * Returns object property using JavaBean-compatible introspection with one\n\t * addition - a property can be a dot-separated property name path.\n\t */\n\tpublic static Object getProperty(Object object, String nestedPropertyName) throws CayenneRuntimeException {\n\t\treturn accessor(nestedPropertyName).getValue(object);\n\t}\n\t/**\n\t * Sets object property using JavaBean-compatible introspection with one\n\t * addition - a property can be a dot-separated property name path. Before\n\t * setting a value attempts to convert it to a type compatible with the\n\t * object property. Automatic conversion is supported between strings and\n\t * basic types like numbers or primitives.\n\t */\n\tpublic static void setProperty(Object object, String nestedPropertyName, Object value)\n\t\t\tthrows CayenneRuntimeException {\n\t\taccessor(nestedPropertyName).setValue(object, value);\n\t}\n\t/**\n\t * \"Normalizes\" passed type, converting primitive types to their object\n\t * counterparts.\n\t */\n\tstatic Class<?> normalizeType(Class<?> type) {\n\t\tif (type.isPrimitive()) {\n\t\t\tString className = type.getName();\n\t\t\tif (\"byte\".equals(className)) {\n\t\t\t\treturn Byte.class;\n\t\t\t} else if (\"int\".equals(className)) {\n\t\t\t\treturn Integer.class;\n\t\t\t} else if (\"long\".equals(className)) {\n\t\t\t\treturn Long.class;\n\t\t\t} else if (\"short\".equals(className)) {\n\t\t\t\treturn Short.class;\n\t\t\t} else if (\"char\".equals(className)) {\n\t\t\t\treturn Character.class;\n\t\t\t} else if (\"double\".equals(className)) {\n\t\t\t\treturn Double.class;\n\t\t\t} else if (\"float\".equals(className)) {\n\t\t\t\treturn Float.class;\n\t\t\t} else if (\"boolean\".equals(className)) {\n\t\t\t\treturn Boolean.class;\n\t\t\t}\n\t\t}\n\t\treturn type;\n\t}\n\t/**\n\t * Returns default value that should be used for nulls. For non-primitive\n\t * types, null is returned. For primitive types a default such as zero or\n\t * false is returned.\n\t */\n\tstatic Object defaultNullValueForType(Class<?> type) {\n\t\tif (type != null && type.isPrimitive()) {\n\t\t\tString className = type.getName();\n\t\t\tif (\"byte\".equals(className)) {\n\t\t\t\treturn (byte) 0;\n\t\t\t} else if (\"int\".equals(className)) {\n\t\t\t\treturn 0;\n\t\t\t} else if (\"long\".equals(className)) {\n\t\t\t\treturn 0L;\n\t\t\t} else if (\"short\".equals(className)) {\n\t\t\t\treturn (short) 0;\n\t\t\t} else if (\"char\".equals(className)) {\n\t\t\t\treturn (char) 0;\n\t\t\t} else if (\"double\".equals(className)) {\n\t\t\t\treturn 0.0d;\n\t\t\t} else if (\"float\".equals(className)) {\n\t\t\t\treturn 0.0f;\n\t\t\t} else if (\"boolean\".equals(className)) {\n\t\t\t\treturn Boolean.FALSE;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n    /**\n     * This method installs custom accessor factory to be used by property utils.\n     * <p>\n     * A factory that produces {@link BeanAccessor} is used by default.\n     *\n     * @param accessorFactory new factory to use\n     * @since 4.1\n     */\n\tpublic static void installAccessorFactory(AccessorFactory accessorFactory) {\n\t    PropertyUtils.accessorFactory = Objects.requireNonNull(accessorFactory);\n    }\n\tprivate PropertyUtils() {\n\t\tsuper();\n\t}\n<fim_suffix>\tstatic final class PathAccessor implements Accessor {\n\t\tprivate static final long serialVersionUID = 2056090443413498626L;\n\t\tprivate final String segmentName;\n\t\tprivate final Accessor nextAccessor;\n\t\tpublic PathAccessor(String segmentName, Accessor nextAccessor) {\n\t\t\t// trim outer join component\n\t\t\tif(segmentName.endsWith(Entity.OUTER_JOIN_INDICATOR)) {\n\t\t\t\tthis.segmentName = segmentName.substring(0, segmentName.length() - 1);\n\t\t\t} else {\n\t\t\t\tthis.segmentName = segmentName;\n\t\t\t}\n\t\t\tthis.nextAccessor = nextAccessor;\n\t\t}\n\t\t@Override\n\t\tpublic String getName() {\n\t\t\treturn segmentName;\n\t\t}\n\t\t@Override\n\t\tpublic Object getValue(Object object) throws PropertyException {\n\t\t\tif (object == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tObject value = getOrCreateSegmentAccessor(object.getClass(), segmentName).getValue(object);\n\t\t\treturn nextAccessor != null ? nextAccessor.getValue(value) : value;\n\t\t}\n\t\t@Override\n\t\tpublic void setValue(Object object, Object newValue) throws PropertyException {\n\t\t\tif (object == null) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tAccessor segmentAccessor = getOrCreateSegmentAccessor(object.getClass(), segmentName);\n\t\t\tif (nextAccessor != null) {\n\t\t\t\tnextAccessor.setValue(segmentAccessor.getValue(object), newValue);\n\t\t\t} else {\n\t\t\t\tsegmentAccessor.setValue(object, newValue);\n\t\t\t}\n\t\t}\n\t}<fim_middle>// class below has no smell\n"}