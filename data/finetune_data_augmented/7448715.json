{"text": "<fim_prefix>/*\n * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage org.graalvm.compiler.truffle.compiler.hotspot.libgraal;\n\nimport static org.graalvm.compiler.truffle.compiler.hotspot.libgraal.JNIUtil.PopLocalFrame;\nimport static org.graalvm.compiler.truffle.compiler.hotspot.libgraal.JNIUtil.PushLocalFrame;\n\nimport org.graalvm.compiler.truffle.common.hotspot.libgraal.HotSpotToSVM;\nimport org.graalvm.compiler.truffle.common.hotspot.libgraal.HotSpotToSVM.Id;\nimport org.graalvm.compiler.truffle.compiler.hotspot.libgraal.JNI.JNIEnv;\nimport org.graalvm.compiler.truffle.compiler.hotspot.libgraal.JNI.JObject;\n\n/**\n * Scope of a call from HotSpot to SVM. This also provides access to the {@link JNIEnv} value for\n * the current thread within the SVM call.\n *\n * If the SVM call returns a non-primitive value, the return value must be\n * {@linkplain #setObjectResult(JObject) set} within the try-with-resources statement and then\n * {@linkplain #getObjectResult() retrieved} and returned outside the try-with-resources statement.\n * This is necessary to support use of JNI local frames.\n */\npublic class HotSpotToSVMScope implements AutoCloseable {\n\n    private static final ThreadLocal<HotSpotToSVMScope> topScope = new ThreadLocal<>();\n\n    private final JNIEnv env;\n    private final HotSpotToSVMScope parent;\n    private HotSpotToSVMScope leaf;\n\n    /**\n     * List of scope local {@link HSObject}s that created within this scope. These are\n     * {@linkplain HSObject#invalidate(HSObject) invalidated} when the scope closes.\n     */\n    HSObject locals;\n\n    /**\n     * The SVM call for this scope.\n     */\n    private final Id id;\n\n    /**\n     * Gets the {@link JNIEnv} value for the current thread.\n     */\n    static JNIEnv env() {\n        return scope().env;\n    }\n\n    JNIEnv getEnv() {\n        return env;\n    }\n\n    /**\n     * Gets the inner most {@link HotSpotToSVMScope} value for the current thread.\n     */\n    static HotSpotToSVMScope scopeOrNull() {\n        HotSpotToSVMScope scope = topScope.get();\n        if (scope == null) {\n            return null;\n        }\n        return scope.leaf;\n    }\n\n    /**\n     * Gets the inner most {@link HotSpotToSVMScope} value for the current thread.\n     */\n    static HotSpotToSVMScope scope() {\n        HotSpotToSVMScope scope = topScope.get();\n        if (scope == null) {\n            throw new IllegalStateException(\"Not in the scope of an SVM call\");\n        }\n        return scope.leaf;\n    }\n\n    /**\n     * Enters the scope of an SVM call.\n     */\n    public HotSpotToSVMScope(HotSpotToSVM.Id id, JNIEnv env) {\n        HotSpotToSVMEntryPoints.trace(1, \"HS->SVM[enter]: %s\", id);\n        this.id = id;\n        HotSpotToSVMScope top = topScope.get();\n        this.env = env;\n        if (top == null) {\n            // Only push a JNI frame for the top level SVM call.\n            // HotSpot's JNI implementation currently ignores the `capacity` argument\n            PushLocalFrame(env, 64);\n            top = this;\n            parent = null;\n            topScope.set(this);\n        } else {\n            if (top.env != this.env) {\n                throw new IllegalStateException(\"Cannot mix JNI scopes: \" + this + \" and \" + top);\n            }\n            parent = top.leaf;\n        }\n        top.leaf = this;\n    }\n\n    /**\n     * Used to copy the handle to an object return value out of the JNI local frame.\n     */\n    private JObject objResult;\n\n    void setObjectResult(JObject obj) {\n        objResult = obj;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    <T extends JObject> T getObjectResult() {\n        return (T) objResult;\n    }\n\n<fim_suffix>    @Override\n    public void close() {\n        HSObject.invalidate(locals);\n        if (parent == null) {\n            if (topScope.get() != this) {\n                throw new IllegalStateException(\"Unexpected JNI scope: \" + topScope.get());\n            }\n            topScope.set(null);\n            objResult = PopLocalFrame(env, objResult);\n        } else {\n            HotSpotToSVMScope top = parent;\n            while (top.parent != null) {\n                top = top.parent;\n            }\n            top.leaf = parent;\n        }\n        HotSpotToSVMEntryPoints.trace(1, \"HS->SVM[ exit]: %s\", id);\n    }\n\n    int depth() {\n        int depth = 0;\n        HotSpotToSVMScope ancestor = parent;\n        while (ancestor != null) {\n            depth++;\n            ancestor = ancestor.parent;\n        }\n        return depth;\n    }\n\n    @Override\n    public String toString() {\n        return \"SVMCall[\" + depth() + \"]@\" + Long.toHexString(env.rawValue());\n    }\n}<fim_middle>// function below has no smell\n"}