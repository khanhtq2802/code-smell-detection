{"text": "<fim_prefix>/*[INCLUDE-IF Sidecar18-SE]*/\n/*******************************************************************************\n * Copyright (c) 2004, 2017 IBM Corp. and others\n *\n * This program and the accompanying materials are made available under\n * the terms of the Eclipse Public License 2.0 which accompanies this\n * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n * or the Apache License, Version 2.0 which accompanies this distribution and\n * is available at https://www.apache.org/licenses/LICENSE-2.0.\n *\n * This Source Code may also be made available under the following\n * Secondary Licenses when the conditions for such availability set\n * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n * General Public License, version 2 with the GNU Classpath\n * Exception [1] and GNU General Public License, version 2 with the\n * OpenJDK Assembly Exception [2].\n *\n * [1] https://www.gnu.org/software/classpath/license.html\n * [2] http://openjdk.java.net/legal/assembly-exception.html\n *\n * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n *******************************************************************************/\npackage com.ibm.dtfj.image.j9;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.Properties;\nimport java.util.Vector;\nimport com.ibm.dtfj.image.CorruptDataException;\nimport com.ibm.dtfj.image.DataUnavailable;\nimport com.ibm.dtfj.image.ImageModule;\nimport com.ibm.dtfj.java.j9.JavaRuntime;\n/**\n * @author jmdisher\n *\n */\npublic class ImageProcess implements com.ibm.dtfj.image.ImageProcess\n{\n\tprivate Vector _runtimes = new Vector();\n\tprivate Vector _libraries = new Vector();\n\tprivate Vector _threads = new Vector();\n\tprivate int _pointerSize;\n\tprivate ImageModule _executable;\n\tprivate String _id;\n\tprivate String _commandLine;\n\tprivate Properties _environment;\t//reading the env ahead of time like this is odd but saves us having to stuff the dump in here\n\tprivate ImageThread _currentThread;\n\tprivate long _faultingNativeID = 0;\t\t//the ID of the native thread which caused the GPF (if there was one)\n\tprivate int _signalNumber = 0;\n\tprivate Exception _runtimeCheckFailure;\n\tprivate static final String JAVA_COMMAND_LINE_ENVIRONMENT_VARIABLE = \"IBM_JAVA_COMMAND_LINE\";\n<fim_suffix>\tpublic ImageProcess(String pid, String commandLine, Properties environment, ImageThread currentThread, Iterator threads, ImageModule executable, Iterator libraries, int pointerSize)\n\t{\n\t\t_id = pid;\n\t\t_commandLine = commandLine;\n\t\t_environment = environment;\n\t\tsetCurrentThread(currentThread);\n\t\tsetThreads(threads);\n\t\t_executable = executable;\n\t\twhile (libraries.hasNext()) {\n\t\t\t_libraries.add(libraries.next());\n\t\t}\n\t\t_pointerSize = pointerSize;\n\t}\n\t/* (non-Javadoc)\n\t * @see com.ibm.dtfj.image.ImageProcess#getCommandLine()\n\t */\n\tpublic String getCommandLine() throws DataUnavailable, CorruptDataException\n\t{\n\t\t// We can't get the command line from the core dump on zOS, or on recent Windows versions. On Linux\n\t\t// it may be truncated. The java launcher stores the command line in an environment variable, so for\n\t\t// all platforms we now try that first, with the core reader as a fallback.\n\t\tProperties environment = getEnvironment();\n\t\tString javaCommandLine = environment.getProperty(JAVA_COMMAND_LINE_ENVIRONMENT_VARIABLE);\n\t\tif (javaCommandLine != null) {\n\t\t\treturn javaCommandLine;\n\t\t}\n\t\tif (_commandLine == null) {\n\t\t\tthrow new DataUnavailable(\"Command line unavailable from core dump\");\n\t\t}\n\t\treturn _commandLine;\n\t}\n\t/* (non-Javadoc)\n\t * @see com.ibm.dtfj.image.ImageProcess#getEnvironment()\n\t */\n\tpublic Properties getEnvironment() throws DataUnavailable,\n\t\t\tCorruptDataException\n\t{\n\t\tif (null == _environment)\n\t\t{\n\t\t\t//something went wrong so decide which kind of exception should be thrown\n\t\t\tif (null == _runtimeCheckFailure)\n\t\t\t{\n\t\t\t\t//no runtime startup failure so this must just be unavailable\n\t\t\t\tthrow new DataUnavailable(\"Environment base address when core file parsed\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//this is probably because the XML was corrupt\n\t\t\t\tthrow new CorruptDataException(new CorruptData(\"Environment not found due to:  \" + _runtimeCheckFailure.getMessage(), null));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//business as usual\n\t\t\treturn _environment;\n\t\t}\n\t}\n\t/* (non-Javadoc)\n\t * @see com.ibm.dtfj.image.ImageProcess#getID()\n\t */\n\tpublic String getID() throws DataUnavailable, CorruptDataException\n\t{\n\t\treturn _id;\n\t}\n\t/* (non-Javadoc)\n\t * @see com.ibm.dtfj.image.ImageProcess#getLibraries()\n\t */\n\tpublic Iterator getLibraries() throws DataUnavailable, CorruptDataException\n\t{\n\t\treturn _libraries.iterator();\n\t}\n\t/* (non-Javadoc)\n\t * @see com.ibm.dtfj.image.ImageProcess#getExecutable()\n\t */\n\tpublic ImageModule getExecutable() throws DataUnavailable,\n\t\t\tCorruptDataException\n\t{\n\t\tif (null == _executable) {\n\t\t\tthrow new DataUnavailable(\"Executable image not found\");\n\t\t} else {\n\t\t\treturn _executable;\n\t\t}\n\t}\n\t/* (non-Javadoc)\n\t * @see com.ibm.dtfj.image.ImageProcess#getThreads()\n\t */\n\tpublic Iterator getThreads()\n\t{\n\t\treturn _threads.iterator();\n\t}\n\t/* (non-Javadoc)\n\t * @see com.ibm.dtfj.image.ImageProcess#getCurrentThread()\n\t */\n\tpublic com.ibm.dtfj.image.ImageThread getCurrentThread() throws CorruptDataException\n\t{\n\t\tImageThread current = _currentThread;\n\t\tif (0 != _faultingNativeID) {\n\t\t\t//look up this thread\n\t\t\tIterator threads = getThreads();\n\t\t\twhile (threads.hasNext()) {\n\t\t\t\tObject next = threads.next();\n\t\t\t\tif (next instanceof CorruptData)\n\t\t\t\t\tcontinue;\n\t\t\t\tImageThread thread = (ImageThread) next;\n\t\t\t\tif (Long.decode(thread.getID()).longValue() == _faultingNativeID) {\n\t\t\t\t\tcurrent = thread;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//ensure that this is sane\n\t\tif ((0 != _faultingNativeID) && (null == current)) {\n\t\t\tthrow new CorruptDataException(new CorruptData(\"no current thread\", null));\n\t\t}\n\t\treturn current;\n\t}\n\t/* (non-Javadoc)\n\t * @see com.ibm.dtfj.image.ImageProcess#getRuntimes()\n\t */\n\tpublic Iterator getRuntimes()\n\t{\n\t\t//left un-initialized so the compiler will warn us if we miss a code path\n\t\tIterator iter;\n\t\tif (null == _runtimeCheckFailure)\n\t\t{\n\t\t\t//this is the normal case where we have a real list of runtimes to work with so just return the iterator\n\t\t\titer = _runtimes.iterator();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// If something went wrong during startup to the point where we didn't even get to see what the JavaRuntime \n\t\t\t// is (currently this happens if the XML is corrupt), fake up a corrupt data object and return it.\n\t\t\titer = Collections.singleton(new CorruptData(\"No runtimes due to early startup error:  \" + _runtimeCheckFailure.getMessage(), null)).iterator();\n\t\t}\n\t\treturn iter;\n\t}\n\t/* (non-Javadoc)\n\t * @see com.ibm.dtfj.image.ImageProcess#getSignalNumber()\n\t */\n\tpublic int getSignalNumber() throws DataUnavailable, CorruptDataException\n\t{\n\t\tint agreedSignal = (null == _currentThread) ? 0 : _currentThread.getSignal();\n\t\tif (0 != _signalNumber) {\n\t\t\t//this would happen if we are on a platform where we don't currently extract signal numbers from threads and the \"gpf\" tag over-rode us\n\t\t\t//TODO:  once those platforms can all access this information via the current thread, this _signalNumber ivar can be removed\n\t\t\tagreedSignal = _signalNumber;\n\t\t}\n\t\treturn agreedSignal;\n\t}<fim_middle>// function below has no smell\n"}