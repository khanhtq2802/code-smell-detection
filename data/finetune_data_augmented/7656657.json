{"text": "<fim_prefix>\t\tAssert.hasText(keyName, \"KeyName must not be empty\");\n\t\tAssert.hasText(ciphertext, \"Ciphertext must not be empty\");\n\t\tAssert.notNull(transitContext, \"VaultTransitContext must not be null\");\n\t\tMap<String, String> request = new LinkedHashMap<>();\n\t\trequest.put(\"ciphertext\", ciphertext);\n\t\tapplyTransitOptions(transitContext, request);\n\t\treturn (String) vaultOperations\n\t\t\t\t.write(String.format(\"%s/rewrap/%s\", path, keyName), request)\n\t\t\t\t.getRequiredData().get(\"ciphertext\");\n\t}\n\t@Override\n\tpublic Hmac getHmac(String keyName, Plaintext plaintext) {\n\t\tAssert.hasText(keyName, \"KeyName must not be empty\");\n\t\tAssert.notNull(plaintext, \"Plaintext must not be null\");\n\t\tVaultHmacRequest request = VaultHmacRequest.create(plaintext);\n\t\treturn getHmac(keyName, request);\n\t}\n\t@Override\n\tpublic Hmac getHmac(String keyName, VaultHmacRequest hmacRequest) {\n\t\tAssert.hasText(keyName, \"KeyName must not be empty\");\n\t\tAssert.notNull(hmacRequest, \"HMAC request must not be null\");\n\t\tMap<String, Object> request = new LinkedHashMap<>();\n\t\trequest.put(\"input\",\n\t\t\t\tBase64Utils.encodeToString(hmacRequest.getPlaintext().getPlaintext()));\n\t\tif (StringUtils.hasText(hmacRequest.getAlgorithm())) {\n\t\t\trequest.put(\"algorithm\", hmacRequest.getAlgorithm());\n\t\t}\n\t\tif (hmacRequest.getKeyVersion() != null) {\n\t\t\trequest.put(\"key_version \", hmacRequest.getKeyVersion());\n\t\t}\n\t\tString hmac = (String) vaultOperations\n\t\t\t\t.write(String.format(\"%s/hmac/%s\", path, keyName), request)\n\t\t\t\t.getRequiredData().get(\"hmac\");\n\t\treturn Hmac.of(hmac);\n\t}\n\t@Override\n\tpublic Signature sign(String keyName, Plaintext plaintext) {\n\t\tAssert.hasText(keyName, \"KeyName must not be empty\");\n\t\tAssert.notNull(plaintext, \"Plaintext must not be null\");\n\t\tVaultSignRequest request = VaultSignRequest.create(plaintext);\n\t\treturn sign(keyName, request);\n\t}\n\t@Override\n\tpublic Signature sign(String keyName, VaultSignRequest signRequest) {\n\t\tAssert.hasText(keyName, \"KeyName must not be empty\");\n\t\tAssert.notNull(signRequest, \"Sign request must not be null\");\n\t\tMap<String, Object> request = new LinkedHashMap<>();\n\t\trequest.put(\"input\",\n\t\t\t\tBase64Utils.encodeToString(signRequest.getPlaintext().getPlaintext()));\n\t\tif (StringUtils.hasText(signRequest.getAlgorithm())) {\n\t\t\trequest.put(\"algorithm\", signRequest.getAlgorithm());\n\t\t}\n\t\tString signature = (String) vaultOperations\n\t\t\t\t.write(String.format(\"%s/sign/%s\", path, keyName), request)\n\t\t\t\t.getRequiredData().get(\"signature\");\n\t\treturn Signature.of(signature);\n\t}\n\t@Override\n\tpublic boolean verify(String keyName, Plaintext plainText, Signature signature) {\n\t\tAssert.hasText(keyName, \"KeyName must not be empty\");\n\t\tAssert.notNull(plainText, \"Plaintext must not be null\");\n\t\tAssert.notNull(signature, \"Signature must not be null\");\n\t\tVaultSignatureVerificationRequest request = VaultSignatureVerificationRequest\n\t\t\t\t.create(plainText, signature);\n\t\treturn verify(keyName, request).isValid();\n\t}\n\t@Override\n\tpublic SignatureValidation verify(String keyName,\n\t\t\tVaultSignatureVerificationRequest verificationRequest) {\n\t\tAssert.hasText(keyName, \"KeyName must not be empty\");\n\t\tAssert.notNull(verificationRequest,\n\t\t\t\t\"Signature verification request must not be null\");\n\t\tMap<String, Object> request = new LinkedHashMap<>();\n\t\trequest.put(\"input\", Base64Utils.encodeToString(verificationRequest\n\t\t\t\t.getPlaintext().getPlaintext()));\n\t\tif (verificationRequest.getHmac() != null) {\n\t\t\trequest.put(\"hmac\", verificationRequest.getHmac().getHmac());\n\t\t}\n\t\tif (verificationRequest.getSignature() != null) {\n\t\t\trequest.put(\"signature\", verificationRequest.getSignature().getSignature());\n\t\t}\n\t\tif (StringUtils.hasText(verificationRequest.getAlgorithm())) {\n\t\t\trequest.put(\"algorithm\", verificationRequest.getAlgorithm());\n\t\t}\n\t\tMap<String, Object> response = vaultOperations.write(\n\t\t\t\tString.format(\"%s/verify/%s\", path, keyName), request).getRequiredData();\n\t\tif (response.containsKey(\"valid\") && Boolean.valueOf(\"\" + response.get(\"valid\"))) {\n\t\t\treturn SignatureValidation.valid();\n\t\t}\n\t\treturn SignatureValidation.invalid();\n\t}\n\tprivate static void applyTransitOptions(VaultTransitContext context,\n\t\t\tMap<String, String> request) {\n\t\tif (!ObjectUtils.isEmpty(context.getContext())) {\n\t\t\trequest.put(\"context\", Base64Utils.encodeToString(context.getContext()));\n\t\t}\n\t\tif (!ObjectUtils.isEmpty(context.getNonce())) {\n\t\t\trequest.put(\"nonce\", Base64Utils.encodeToString(context.getNonce()));\n\t\t}\n\t}\n\tprivate static List<VaultEncryptionResult> toEncryptionResults(\n\t\t\tVaultResponse vaultResponse, List<Plaintext> batchRequest) {\n\t\tList<VaultEncryptionResult> result = new ArrayList<VaultEncryptionResult>(\n\t\t\t\tbatchRequest.size());\n\t\tList<Map<String, String>> batchData = getBatchData(vaultResponse);\n\t\tfor (int i = 0; i < batchRequest.size(); i++) {\n\t\t\tVaultEncryptionResult encrypted;\n\t\t\tPlaintext plaintext = batchRequest.get(i);\n\t\t\tif (batchData.size() > i) {\n\t\t\t\tMap<String, String> data = batchData.get(i);\n\t\t\t\tif (StringUtils.hasText(data.get(\"error\"))) {\n\t\t\t\t\tencrypted = new VaultEncryptionResult(new VaultException(\n\t\t\t\t\t\t\tdata.get(\"error\")));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tencrypted = new VaultEncryptionResult(toCiphertext(\n\t\t\t\t\t\t\tdata.get(\"ciphertext\"), plaintext.getContext()));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tencrypted = new VaultEncryptionResult(new VaultException(\n\t\t\t\t\t\t\"No result for plaintext #\" + i));\n\t\t\t}\n\t\t\tresult.add(encrypted);\n\t\t}\n\t\treturn result;\n\t}\n\tprivate static List<VaultDecryptionResult> toDecryptionResults(\n\t\t\tVaultResponse vaultResponse, List<Ciphertext> batchRequest) {\n\t\tList<VaultDecryptionResult> result = new ArrayList<VaultDecryptionResult>(\n\t\t\t\tbatchRequest.size());\n\t\tList<Map<String, String>> batchData = getBatchData(vaultResponse);\n\t\tfor (int i = 0; i < batchRequest.size(); i++) {\n\t\t\tVaultDecryptionResult encrypted;\n\t\t\tCiphertext ciphertext = batchRequest.get(i);\n\t\t\tif (batchData.size() > i) {\n\t\t\t\tencrypted = getDecryptionResult(batchData.get(i), ciphertext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tencrypted = new VaultDecryptionResult(new VaultException(\n\t\t\t\t\t\t\"No result for ciphertext #\" + i));\n\t\t\t}\n\t\t\tresult.add(encrypted);\n\t\t}\n\t\treturn result;\n\t}\n\tprivate static VaultDecryptionResult getDecryptionResult(Map<String, String> data,\n\t\t\tCiphertext ciphertext) {\n\t\tif (StringUtils.hasText(data.get(\"error\"))) {\n\t\t\treturn new VaultDecryptionResult(new VaultException(data.get(\"error\")));\n\t\t}\n\t\tif (StringUtils.hasText(data.get(\"plaintext\"))) {\n\t\t\tbyte[] plaintext = Base64Utils.decodeFromString(data.get(\"plaintext\"));\n\t\t\treturn new VaultDecryptionResult(Plaintext.of(plaintext).with(\n\t\t\t\t\tciphertext.getContext()));\n\t\t}\n\t\treturn new VaultDecryptionResult(Plaintext.empty().with(ciphertext.getContext()));\n\t}\n<fim_suffix>\tprivate static Ciphertext toCiphertext(String ciphertext,\n\t\t\t@Nullable VaultTransitContext context) {\n\t\treturn context != null ? Ciphertext.of(ciphertext).with(context) : Ciphertext\n\t\t\t\t.of(ciphertext);\n\t}<fim_middle>// function below has no smell\n"}