{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.cassandra.cql3;\nimport java.io.IOException;\nimport java.util.*;\nimport com.fasterxml.jackson.core.util.BufferRecyclers;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport org.apache.cassandra.schema.ColumnMetadata;\nimport org.apache.cassandra.schema.TableMetadata;\nimport org.apache.cassandra.cql3.functions.Function;\nimport org.apache.cassandra.db.marshal.AbstractType;\nimport org.apache.cassandra.db.marshal.UTF8Type;\nimport org.apache.cassandra.exceptions.InvalidRequestException;\nimport org.apache.cassandra.serializers.MarshalException;\n/** Term-related classes for INSERT JSON support. */\npublic class Json\n{\n    public static final ObjectMapper JSON_OBJECT_MAPPER = new ObjectMapper();\n    public static final ColumnIdentifier JSON_COLUMN_ID = new ColumnIdentifier(\"[json]\", true);\n    /**\n     * Quotes string contents using standard JSON quoting.\n     */\n    public static String quoteAsJsonString(String s)\n    {\n        return new String(BufferRecyclers.getJsonStringEncoder().quoteAsString(s));\n    }\n    public static Object decodeJson(String json)\n    {\n        try\n        {\n            return JSON_OBJECT_MAPPER.readValue(json, Object.class);\n        }\n        catch (IOException exc)\n        {\n            throw new MarshalException(\"Error decoding JSON string: \" + exc.getMessage());\n        }\n    }\n    public interface Raw\n    {\n        public Prepared prepareAndCollectMarkers(TableMetadata metadata, Collection<ColumnMetadata> receivers, VariableSpecifications boundNames);\n    }\n    /**\n     * Represents a literal JSON string in an INSERT JSON statement.\n     * For example: INSERT INTO mytable (key, col) JSON '{\"key\": 0, \"col\": 0}';\n     */\n    public static class Literal implements Raw\n    {\n        private final String text;\n        public Literal(String text)\n        {\n            this.text = text;\n        }\n        public Prepared prepareAndCollectMarkers(TableMetadata metadata, Collection<ColumnMetadata> receivers, VariableSpecifications boundNames)\n        {\n            return new PreparedLiteral(parseJson(text, receivers));\n        }\n    }\n    /**\n     * Represents a marker for a JSON string in an INSERT JSON statement.\n     * For example: INSERT INTO mytable (key, col) JSON ?;\n     */\n    public static class Marker implements Raw\n    {\n        protected final int bindIndex;\n        public Marker(int bindIndex)\n        {\n            this.bindIndex = bindIndex;\n        }\n        public Prepared prepareAndCollectMarkers(TableMetadata metadata, Collection<ColumnMetadata> receivers, VariableSpecifications boundNames)\n        {\n            boundNames.add(bindIndex, makeReceiver(metadata));\n            return new PreparedMarker(bindIndex, receivers);\n        }\n        private ColumnSpecification makeReceiver(TableMetadata metadata)\n        {\n            return new ColumnSpecification(metadata.keyspace, metadata.name, JSON_COLUMN_ID, UTF8Type.instance);\n        }\n    }\n    /**\n     * A prepared, full set of JSON values.\n     */\n    public static abstract class Prepared\n    {\n        public abstract Term.Raw getRawTermForColumn(ColumnMetadata def, boolean defaultUnset);\n    }\n    /**\n     * A prepared literal set of JSON values\n     */\n    private static class PreparedLiteral extends Prepared\n    {\n        private final Map<ColumnIdentifier, Term> columnMap;\n        public PreparedLiteral(Map<ColumnIdentifier, Term> columnMap)\n        {\n            this.columnMap = columnMap;\n        }\n        public Term.Raw getRawTermForColumn(ColumnMetadata def, boolean defaultUnset)\n        {\n            Term value = columnMap.get(def.name);\n            return value == null\n                 ? (defaultUnset ? Constants.UNSET_LITERAL : Constants.NULL_LITERAL)\n                 : new ColumnValue(value);\n        }\n    }\n    /**\n     *  A prepared bind marker for a set of JSON values\n     */\n    private static class PreparedMarker extends Prepared\n    {\n        private final int bindIndex;\n        private final Collection<ColumnMetadata> columns;\n        public PreparedMarker(int bindIndex, Collection<ColumnMetadata> columns)\n        {\n            this.bindIndex = bindIndex;\n            this.columns = columns;\n        }\n        public RawDelayedColumnValue getRawTermForColumn(ColumnMetadata def, boolean defaultUnset)\n        {\n            return new RawDelayedColumnValue(this, def, defaultUnset);\n        }\n    }\n    /**\n     * A Terminal for a single column.\n     *\n     * Note that this is intrinsically an already prepared term, but this still implements Term.Raw so that we can\n     * easily use it to create raw operations.\n     */\n    private static class ColumnValue extends Term.Raw\n    {\n        private final Term term;\n        public ColumnValue(Term term)\n        {\n            this.term = term;\n        }\n        @Override\n        public Term prepare(String keyspace, ColumnSpecification receiver) throws InvalidRequestException\n        {\n            return term;\n        }\n        @Override\n        public TestResult testAssignment(String keyspace, ColumnSpecification receiver)\n        {\n            return TestResult.NOT_ASSIGNABLE;\n        }\n        public AbstractType<?> getExactTypeIfKnown(String keyspace)\n        {\n            return null;\n        }\n        public String getText()\n        {\n            return term.toString();\n        }\n    }\n    /**\n     * A Raw term for a single column. Like ColumnValue, this is intrinsically already prepared.\n     */\n    private static class RawDelayedColumnValue extends Term.Raw\n    {\n        private final PreparedMarker marker;\n        private final ColumnMetadata column;\n        private final boolean defaultUnset;\n        public RawDelayedColumnValue(PreparedMarker prepared, ColumnMetadata column, boolean defaultUnset)\n        {\n            this.marker = prepared;\n            this.column = column;\n            this.defaultUnset = defaultUnset;\n        }\n        @Override\n        public Term prepare(String keyspace, ColumnSpecification receiver) throws InvalidRequestException\n        {\n            return new DelayedColumnValue(marker, column, defaultUnset);\n        }\n        @Override\n        public TestResult testAssignment(String keyspace, ColumnSpecification receiver)\n        {\n            return TestResult.WEAKLY_ASSIGNABLE;\n        }\n        public AbstractType<?> getExactTypeIfKnown(String keyspace)\n        {\n            return null;\n        }\n        public String getText()\n        {\n            return marker.toString();\n        }\n    }\n    /**\n     * A NonTerminal for a single column. As with {@code ColumnValue}, this is intrinsically a prepared.\n     */\n    private static class DelayedColumnValue extends Term.NonTerminal\n    {\n        private final PreparedMarker marker;\n        private final ColumnMetadata column;\n        private final boolean defaultUnset;\n        public DelayedColumnValue(PreparedMarker prepared, ColumnMetadata column, boolean defaultUnset)\n        {\n            this.marker = prepared;\n            this.column = column;\n            this.defaultUnset = defaultUnset;\n        }\n        @Override\n        public void collectMarkerSpecification(VariableSpecifications boundNames)\n        {\n            // We've already collected what we should (and in practice this method is never called).\n        }\n        @Override\n        public boolean containsBindMarker()\n        {\n            return true;\n        }\n<fim_suffix>        @Override\n        public Terminal bind(QueryOptions options) throws InvalidRequestException\n        {\n            Term term = options.getJsonColumnValue(marker.bindIndex, column.name, marker.columns);\n            return term == null\n                 ? (defaultUnset ? Constants.UNSET_VALUE : null)\n                 : term.bind(options);\n        }\n        @Override\n        public void addFunctionsTo(List<Function> functions)\n        {\n        }\n    }\n    /**\n     * Given a JSON string, return a map of columns to their values for the insert.\n     */\n    public static Map<ColumnIdentifier, Term> parseJson(String jsonString, Collection<ColumnMetadata> expectedReceivers)\n    {\n        try\n        {\n            Map<String, Object> valueMap = JSON_OBJECT_MAPPER.readValue(jsonString, Map.class);\n            if (valueMap == null)\n                throw new InvalidRequestException(\"Got null for INSERT JSON values\");\n            handleCaseSensitivity(valueMap);\n            Map<ColumnIdentifier, Term> columnMap = new HashMap<>(expectedReceivers.size());\n            for (ColumnSpecification spec : expectedReceivers)\n            {\n                // We explicitely test containsKey() because the value itself can be null, and we want to distinguish an\n                // explicit null value from no value\n                if (!valueMap.containsKey(spec.name.toString()))\n                    continue;\n                Object parsedJsonObject = valueMap.remove(spec.name.toString());\n                if (parsedJsonObject == null)\n                {\n                    // This is an explicit user null<fim_middle>// function below has no smell\n"}