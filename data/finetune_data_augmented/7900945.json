{"text": "<fim_prefix>/*\n * Copyright 2017-present Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License. You may obtain\n * a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage com.facebook.buck.tools.consistency;\nimport com.facebook.buck.log.thrift.rulekeys.FullRuleKey;\nimport com.facebook.buck.log.thrift.rulekeys.RuleKeyHash;\nimport com.facebook.buck.log.thrift.rulekeys.Value;\nimport com.facebook.buck.tools.consistency.DifferState.DiffResult;\nimport com.facebook.buck.tools.consistency.DifferState.MaxDifferencesException;\nimport com.facebook.buck.tools.consistency.RuleKeyFileParser.ParsedRuleKeyFile;\nimport com.facebook.buck.tools.consistency.RuleKeyFileParser.RuleKeyNode;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Collectors;\n/**\n * Prints out differences found between rule keys and their properties.\n *\n * <p>Normal usage is to instantiate a printer, call {@link #addTarget(String)} when encountering a\n * new RuleKey, then calling {@link #addProperty(String)} on that target scope when examining\n * properties of a RuleKey\n */\npublic class RuleKeyDiffPrinter {\n  private final DiffPrinter diffPrinter;\n  private final DifferState differState;\n  /**\n   * The scope for printing information about a target. Helps ensure that target information is\n   * always printed if any differences are found within the target\n   */\n  public class TargetScope implements AutoCloseable {\n    private final String newKey;\n    private final String origKey;\n    private final String target;\n    private List<String> pathComponents = new ArrayList<>();\n    private boolean printedTarget = false;\n    private TargetScope(String target, String originalKey, String newKey) {\n      this.target = target;\n      this.origKey = originalKey;\n      this.newKey = newKey;\n    }\n    @Override\n    public void close() {}\n    /** Prints out the target name and old/new hash */\n    private void printHeader() {\n      if (!printedTarget) {\n        printedTarget = true;\n        diffPrinter.printHeader(target, String.format(\" (%s vs %s)\", origKey, newKey));\n      }\n    }\n    /**\n     * Adds a new property to the target scope. If any changes are recorded on this object (e.g.\n     * with {@link #added(ParsedRuleKeyFile, Value) added}), the details of the target will be\n     * printed first.\n     *\n     * @param propertyName The path to the property to print at the beginning of the line. e.g. '0'\n     *     for the first element of an array, or 'target_name' for a property named 'target_name' in\n     *     the main rule key map.\n     * @return A {@link PropertyScope} object that can record changes in the object.\n     */\n    public PropertyScope addProperty(String propertyName) {\n      return new PropertyScope(propertyName);\n    }\n    /**\n     * A scope representing a single property of a RuleKey, or a nested value of a RuleKey. This is\n     * used to print differences between two different {@link Value} objects\n     */\n    public class PropertyScope implements AutoCloseable {\n      private PropertyScope(String name) {\n        pathComponents.add(name);\n      }\n      /** Pops the most recent property off of the stack of nested properties */\n      @Override\n      public void close() {\n        pathComponents.remove(pathComponents.size() - 1);\n      }\n      /**\n       * Creates a nested property scope that is one level deeper. Useful for printing values inside\n       * of a map or list\n       */\n      public PropertyScope addNestedProperty(String newProperty) {\n        return new PropertyScope(newProperty);\n      }\n      /** Make sure we've printed the header and haven't encountered too many differences */\n      private void validateAndUpdateState() throws MaxDifferencesException {\n        differState.incrementDifferenceCount();\n        printHeader();\n      }\n      private void printAdd(ParsedRuleKeyFile file, Value value) {\n        diffPrinter.printAdd(\n            String.format(\n                \"%s: %s\", String.join(\"/\", pathComponents), valueAsReadableString(file, value)));\n      }\n<fim_suffix>      private void printRemove(ParsedRuleKeyFile file, Value value) {\n        diffPrinter.printRemove(\n            String.format(\n                \"%s: %s\", String.join(\"/\", pathComponents), valueAsReadableString(file, value)));\n      }\n      /**\n       * Prints that a property was removed from the original rule key in the new one\n       *\n       * @param file The file object that has all of the rule keys from the original log file\n       * @param value The value that was removed\n       * @throws MaxDifferencesException Thrown if the maximum number of differences was found\n       *     before this removal was printed\n       */\n      public void removed(ParsedRuleKeyFile file, Value value) throws MaxDifferencesException {\n        validateAndUpdateState();\n        printRemove(file, value);\n      }\n      /**\n       * Prints that a property was added to the new rule key that wasn't present in the original\n       * one\n       *\n       * @param file The file object that has all of the rule keys from the new log file\n       * @param value The value that was added\n       * @throws MaxDifferencesException Thrown if the maximum number of differences was found\n       *     before this addition was printed\n       */\n      public void added(ParsedRuleKeyFile file, Value value) throws MaxDifferencesException {\n        validateAndUpdateState();\n        printAdd(file, value);\n      }\n      /**\n       * Prints that there was a difference between two values that are at the same path. e.g. if\n       * two instances of a rule key have different files at index 0 of their sources list, the\n       * filenames would be printed out here.\n       *\n       * @param originalFile The file object that has all of the rule keys from the original log\n       *     file\n       * @param originalValue The value from the original rule key\n       * @param newFile The file object that has all of the rule keys from the new log file\n       * @param newValue The value from the new rule key\n       * @throws MaxDifferencesException Thrown if the maximum number of differences was found\n       *     before this change was printed\n       */\n      public void changed(\n          ParsedRuleKeyFile originalFile,\n          Value originalValue,\n          ParsedRuleKeyFile newFile,\n          Value newValue)\n          throws MaxDifferencesException {\n        validateAndUpdateState();\n        printRemove(originalFile, originalValue);\n        printAdd(newFile, newValue);\n      }\n      /**\n       * Record a change that should not have an add/remove/chage line printed. This ensures that we\n       * count the difference and print the header, but don't force rule key differences to be\n       * printed right before we recurse\n       */\n      public void recordEmptyChange() throws MaxDifferencesException {\n        differState.incrementDifferenceCount();\n        printHeader();\n      }\n    }\n  }\n  /**\n   * Creates an instance of {@link RuleKeyDiffPrinter}\n   *\n   * @param diffPrinter An object that prints additions/removals\n   * @param differState The state of the actual diffing\n   */\n  public RuleKeyDiffPrinter(DiffPrinter diffPrinter, DifferState differState) {\n    this.diffPrinter = diffPrinter;\n    this.differState = differState;\n  }\n  /**\n   * Determines whether any changes have been printed\n   *\n   * @return whether any changes have been printed\n   */\n  public DiffResult hasChanges() {\n    return differState.hasChanges();\n  }\n  /**\n   * Adds a new {@link TargetScope} to this printer.\n   *\n   * @param target The target name\n   * @param oldKey The old rule key hash\n   * @param newKey The new rule key hash\n   */\n  public TargetScope addTarget(String target, String oldKey, String newKey) {\n    return new TargetScope(target, oldKey, newKey);\n  }\n  /**\n   * Gets a string representation of a Value to use when printing diffs\n   *\n   * @param file The file that this value came from. This is used primarily for looking up readable\n   *     names should {@code value} be a {@link RuleKeyHash} type.\n   * @param value The value to convert to a string\n   * @return A string suitable for printing in a diff\n   */\n  public static String valueAsReadableString(ParsedRuleKeyFile file, Value value) {\n    switch (value.getSetField()) {\n      case STRING_VALUE:\n        return value.getStringValue();\n      case NUMBER_VALUE:\n        return String.valueOf(value.getNumberValue());\n      case BOOL_VALUE:\n        return String.valueOf(value.getBoolValue());\n      case NULL_VALUE:\n        return \"null\";\n      case HASHED_PATH:\n        return String.format(<fim_middle>// function below has no smell\n"}