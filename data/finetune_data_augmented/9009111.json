{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.solr.search.join;\nimport java.io.IOException;\nimport java.util.List;\nimport java.util.Objects;\nimport org.apache.lucene.index.DocValuesType;\nimport org.apache.lucene.search.IndexSearcher;\nimport org.apache.lucene.search.Query;\nimport org.apache.lucene.search.QueryVisitor;\nimport org.apache.lucene.search.Weight;\nimport org.apache.lucene.search.join.JoinUtil;\nimport org.apache.lucene.search.join.ScoreMode;\nimport org.apache.solr.cloud.ZkController;\nimport org.apache.solr.common.SolrException;\nimport org.apache.solr.common.cloud.Aliases;\nimport org.apache.solr.common.cloud.Replica;\nimport org.apache.solr.common.cloud.Slice;\nimport org.apache.solr.common.cloud.ZkStateReader;\nimport org.apache.solr.common.params.CommonParams;\nimport org.apache.solr.common.params.SolrParams;\nimport org.apache.solr.core.CoreContainer;\nimport org.apache.solr.core.SolrCore;\nimport org.apache.solr.request.LocalSolrQueryRequest;\nimport org.apache.solr.request.SolrQueryRequest;\nimport org.apache.solr.request.SolrRequestInfo;\nimport org.apache.solr.search.JoinQParserPlugin;\nimport org.apache.solr.search.QParser;\nimport org.apache.solr.search.QParserPlugin;\nimport org.apache.solr.search.SolrIndexSearcher;\nimport org.apache.solr.search.SyntaxError;\nimport org.apache.solr.uninverting.UninvertingReader;\nimport org.apache.solr.util.RefCounted;\n/**\n * Create a query-time join query with scoring. \n * It just calls  {@link JoinUtil#createJoinQuery(String, boolean, String, Query, org.apache.lucene.search.IndexSearcher, ScoreMode)}.\n * It runs subordinate query and collects values of \"from\"  field and scores, then it lookups these collected values in \"to\" field, and\n * yields aggregated scores.\n * Local parameters are similar to {@link JoinQParserPlugin} <a href=\"http://wiki.apache.org/solr/Join\">{!join}</a>\n * This plugin doesn't have own name, and is called by specifying local parameter <code>{!join score=...}...</code>. \n * Note: this parser is invoked even if you specify <code>score=none</code>.\n * <br>Example:<code>q={!join from=manu_id_s to=id score=total}foo</code>\n * <ul>\n *  <li>from - \"foreign key\" field name to collect values while enumerating subordinate query (denoted as <code>foo</code> in example above).\n *             it's better to have this field declared as <code>type=\"string\" docValues=\"true\"</code>.\n *             note: if <a href=\"http://wiki.apache.org/solr/DocValues\">docValues</a> are not enabled for this field, it will work anyway, \n *             but it costs some memory for {@link UninvertingReader}. \n *             Also, numeric doc values are not supported until <a href=\"https://issues.apache.org/jira/browse/LUCENE-5868\">LUCENE-5868</a>.\n *             Thus, it only supports {@link DocValuesType#SORTED}, {@link DocValuesType#SORTED_SET}, {@link DocValuesType#BINARY}.  </li>\n *  <li>fromIndex - optional parameter, a core name where subordinate query should run (and <code>from</code> values are collected) rather than current core.\n *             <br>Example:<code>q={!join from=manu_id_s to=id score=total fromIndex=products}foo</code> \n *  <li>to - \"primary key\" field name which is searched for values collected from subordinate query. \n *             it should be declared as <code>indexed=\"true\"</code>. Now it's treated as a single value field.</li>\n *  <li>score - one of {@link ScoreMode}: <code>none,avg,total,max,min</code>. Capital case is also accepted.</li>\n * </ul>\n */\npublic class ScoreJoinQParserPlugin extends QParserPlugin {\n  public static final String SCORE = \"score\";\n  static class OtherCoreJoinQuery extends SameCoreJoinQuery {\n    private final String fromIndex;\n    private final long fromCoreOpenTime;\n    public OtherCoreJoinQuery(Query fromQuery, String fromField,\n                              String fromIndex, long fromCoreOpenTime, ScoreMode scoreMode,\n                              String toField) {\n      super(fromQuery, fromField, toField, scoreMode);\n      this.fromIndex = fromIndex;\n      this.fromCoreOpenTime = fromCoreOpenTime;\n    }\n<fim_suffix>    @Override\n    public Weight createWeight(IndexSearcher searcher, org.apache.lucene.search.ScoreMode scoreMode, float boost) throws IOException {\n      SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n      CoreContainer container = info.getReq().getCore().getCoreContainer();\n      final SolrCore fromCore = container.getCore(fromIndex);\n      if (fromCore == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Cross-core join: no such core \" + fromIndex);\n      }\n      RefCounted<SolrIndexSearcher> fromHolder = null;\n      fromHolder = fromCore.getRegisteredSearcher();\n      final Query joinQuery;\n      try {\n        joinQuery = JoinUtil.createJoinQuery(fromField, true,\n            toField, fromQuery, fromHolder.get(), this.scoreMode);\n      } finally {\n        fromCore.close();\n        fromHolder.decref();\n      }\n      return joinQuery.rewrite(searcher.getIndexReader()).createWeight(searcher, scoreMode, boost);\n    }\n    @Override\n    public int hashCode() {\n      final int prime = 31;\n      int result = super.hashCode();\n      result = prime * result\n          + (int) (fromCoreOpenTime ^ (fromCoreOpenTime >>> 32));\n      result = prime * result\n          + ((fromIndex == null) ? 0 : fromIndex.hashCode());\n      return result;\n    }\n    @Override\n    public boolean equals(Object obj) {\n      if (this == obj) return true;\n      if (!super.equals(obj)) return false;\n      if (getClass() != obj.getClass()) return false;\n      OtherCoreJoinQuery other = (OtherCoreJoinQuery) obj;\n      if (fromCoreOpenTime != other.fromCoreOpenTime) return false;\n      if (fromIndex == null) {\n        if (other.fromIndex != null) return false;\n      } else if (!fromIndex.equals(other.fromIndex)) return false;\n      return true;\n    }\n    @Override\n    public String toString(String field) {\n      return \"OtherCoreJoinQuery [fromIndex=\" + fromIndex\n          + \", fromCoreOpenTime=\" + fromCoreOpenTime + \" extends \"\n          + super.toString(field) + \"]\";\n    }\n  }\n  static class SameCoreJoinQuery extends Query {\n    protected final Query fromQuery;\n    protected final ScoreMode scoreMode;\n    protected final String fromField;\n    protected final String toField;\n    SameCoreJoinQuery(Query fromQuery, String fromField, String toField,\n                      ScoreMode scoreMode) {\n      this.fromQuery = fromQuery;\n      this.scoreMode = scoreMode;\n      this.fromField = fromField;\n      this.toField = toField;\n    }\n    @Override\n    public Weight createWeight(IndexSearcher searcher, org.apache.lucene.search.ScoreMode scoreMode, float boost) throws IOException {\n      SolrRequestInfo info = SolrRequestInfo.getRequestInfo();\n      final Query jq = JoinUtil.createJoinQuery(fromField, true,\n          toField, fromQuery, info.getReq().getSearcher(), this.scoreMode);\n      return jq.rewrite(searcher.getIndexReader()).createWeight(searcher, scoreMode, boost);\n    }\n    @Override<fim_middle>// function below has no smell\n"}