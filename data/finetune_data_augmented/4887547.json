{"text": "<fim_prefix>import org.apache.jackrabbit.webdav.xml.DomUtil;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.xml.sax.SAXException;\nimport javax.jcr.PropertyType;\nimport javax.jcr.RepositoryException;\nimport javax.jcr.Value;\nimport javax.jcr.ValueFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.io.Serializable;\nimport java.util.Arrays;\nimport java.util.Map;\n/**\n * <code>ValueFactoryImpl</code>...\n */\nclass QValueFactoryImpl extends org.apache.jackrabbit.spi.commons.value.QValueFactoryImpl {\n    /**\n     * A dummy value for calling the constructor of AbstractQValue\n     */\n    private static final Object DUMMY_VALUE = new Serializable() {\n        private static final long serialVersionUID = -5667366239976271493L;\n    };\n    /**\n     * empty array\n     */\n    private static final byte[] EMPTY_BYTE_ARRAY = new byte[0];\n    static final int NO_INDEX = -1;\n    private final ValueLoader loader;\n    private final ValueFactory vf;\n    public QValueFactoryImpl() {\n        this(null, null);\n    }\n    QValueFactoryImpl(NamePathResolver resolver, ValueLoader loader) {\n        this.loader = loader;\n        vf = new ValueFactoryQImpl(this, resolver);\n    }\n    /**\n     * Create a BINARY QValue with the given length and the given uri used\n     * to retrieve the value.\n     *\n     * @param length Length of the binary value.\n     * @param uri Uri from which the the binary value can be accessed.\n     * @param index The index of the value within the values array.\n     * @return a new BINARY QValue.\n     */\n    QValue create(long length, String uri, int index) {\n        if (loader == null) {\n            throw new IllegalStateException();\n        }\n        return new BinaryQValue(length, uri, index);\n    }\n    /**\n     *\n     * @param uri The Uri from which the type info can be retrieved.\n     * @return the type of the property with the given <code>uri</code>.\n     * @throws IOException If an error occurs.\n     * @throws RepositoryException If an error occurs.\n     */\n    int retrieveType(String uri) throws IOException, RepositoryException {\n        return loader.loadType(uri);\n    }\n    //--------------------------------------------------------< Inner Class >---\n    /**\n     * <code>BinaryQValue</code> represents a binary <code>Value</code> which is\n     * backed by a resource or byte[]. Unlike <code>BinaryValue</code> it has no\n     * state, i.e. the <code>getStream()</code> method always returns a fresh\n     * <code>InputStream</code> instance.\n     */\n    private class BinaryQValue extends AbstractQValue implements ValueLoader.Target {\n        private static final long serialVersionUID = 2736654000266713469L;\n        /**\n         * max size for keeping tmp data in memory\n         */\n        private static final int MAX_BUFFER_SIZE = 0x10000;\n        /**\n         * underlying file\n         */\n        private transient File file;\n        /**\n         * flag indicating if this instance represents a <i>temporary</i> value\n         * whose dynamically allocated resources can be explicitly freed on\n         * {@link #discard()}.\n         */\n        private transient boolean temp;\n        /**\n         * Buffer for small-sized data\n         */\n        private byte[] buffer;\n        private Map<String, String> headers;\n        /**\n         * URI to retrieve the value from\n         */\n        private final String uri;\n        private final long length;\n        private final int index;\n        private boolean initialized = true;\n        private BinaryQValue(long length, String uri, int index) {\n            super(DUMMY_VALUE, PropertyType.BINARY);\n            this.length = length;\n            this.uri = uri;\n            this.index = index;\n            initialized = false;\n        }\n        /**\n         * Creates a new <code>BinaryQValue</code> instance from an\n         * <code>InputStream</code>. The contents of the stream is spooled\n         * to a temporary file or to a byte buffer if its size is smaller than\n         * {@link #MAX_BUFFER_SIZE}.\n         * <p>\n         * The <code>temp</code> parameter governs whether dynamically allocated\n         * resources will be freed explicitly on {@link #discard()}. Note that any\n         * dynamically allocated resources (temp file/buffer) will be freed\n         * implicitly once this instance has been gc'ed.\n         *\n         * @param in stream to be represented as a <code>BinaryQValue</code> instance\n         * @param temp flag indicating whether this instance represents a\n         *             <i>temporary</i> value whose resources can be explicitly freed\n         *             on {@link #discard()}.\n         * @throws IOException if an error occurs while reading from the stream or\n         *                     writing to the temporary file\n         */\n        private void init(InputStream in, boolean temp) throws IOException {\n            byte[] spoolBuffer = new byte[0x2000];\n            int read;\n            int len = 0;\n            OutputStream out = null;\n            File spoolFile = null;\n            try {\n                while ((read = in.read(spoolBuffer)) > 0) {\n                    if (out != null) {\n                        // spool to temp file\n                        out.write(spoolBuffer, 0, read);\n                        len += read;\n                    } else if (len + read > BinaryQValue.MAX_BUFFER_SIZE) {\n                        // threshold for keeping data in memory exceeded;\n                        // create temp file and spool buffer contents\n                        TransientFileFactory fileFactory = TransientFileFactory.getInstance();\n                        spoolFile = fileFactory.createTransientFile(\"bin\", null, null);\n                        out = new FileOutputStream(spoolFile);\n                        out.write(buffer, 0, len);\n                        out.write(spoolBuffer, 0, read);\n                        buffer = null;\n                        len += read;\n                    } else {\n                        // reallocate new buffer and spool old buffer contents\n                        if (buffer == null) {\n                            buffer = EMPTY_BYTE_ARRAY;\n                        }\n                        byte[] newBuffer = new byte[len + read];\n                        System.arraycopy(buffer, 0, newBuffer, 0, len);\n                        System.arraycopy(spoolBuffer, 0, newBuffer, len, read);\n                        buffer = newBuffer;\n                        len += read;\n                    }\n                }\n            } finally {\n                in.close();\n                if (out != null) {\n                    out.close();\n                }\n            }\n            if (spoolFile == null && buffer == null) {\n                // input stream was empty -> initialize an empty binary value\n                this.temp = false;\n                buffer = EMPTY_BYTE_ARRAY;\n            } else {\n                // init vars\n                file = spoolFile;\n                this.temp = temp;\n            }\n            initialized = true;\n        }\n        //---------------------------------------------------------< QValue >---\n        /**\n         * Returns the length of this <code>BinaryQValue</code>.\n         *\n         * @return The length, in bytes, of this <code>BinaryQValue</code>,\n         *         or -1L if the length can't be determined.\n         * @see QValue#getLength()\n         */\n        @Override\n        public long getLength() {\n            if (file != null) {\n                // this instance is backed by a 'real' file\n                if (file.exists()) {\n                    return file.length();\n                } else {\n                    return -1;\n                }\n            } else if (buffer != null) {\n                // this instance is backed by an in-memory buffer\n                return buffer.length;\n            } else {\n                // value has not yet been read from the server.\n                return length;\n            }\n        }\n        /**\n         * @see QValue#getStream()\n         */\n<fim_suffix>        public InputStream getStream() throws RepositoryException {\n            // if the value has not yet been loaded -> retrieve it first in\n            // order to make sure that either 'file' or 'buffer' is set.\n            if (file == null && buffer == null) {\n                try {\n                    loadBinary();\n                } catch (IOException e) {\n                    throw new RepositoryException(e);\n                }\n            }\n            // always return a 'fresh' stream\n            if (file != null) {\n                // this instance is backed by a 'real' file\n                try {\n                    return new FileInputStream(file);\n                } catch (FileNotFoundException fnfe) {\n                    throw new RepositoryException(\"file backing binary value not found\",\n                        fnfe);\n                }\n            } else {\n                return new ByteArrayInputStream(buffer);\n            }\n        }<fim_middle>// function below has no smell\n"}