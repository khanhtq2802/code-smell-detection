{"text": "<fim_prefix>  // Memoized width; Float.POSITIVE_INFINITY if contains forced breaks.\n  private boolean widthComputed = false;\n  private float width = 0.0F;\n  // Memoized flat; not defined (and never computed) if contains forced breaks.\n  private boolean flatComputed = false;\n  private String flat = \"\";\n  // Memoized Range.\n  private boolean rangeComputed = false;\n  private Range<Integer> range = EMPTY_RANGE;\n  /**\n   * Return the width of a {@code Doc}, or {@code Float.POSITIVE_INFINITY} if it must be broken.\n   *\n   * @return the width\n   */\n  final float getWidth() {\n    if (!widthComputed) {\n      width = computeWidth();\n      widthComputed = true;\n    }\n    return width;\n  }\n  /**\n   * Return a {@code Doc}'s flat-string value; not defined (and never called) if the (@code Doc}\n   * contains forced breaks.\n   *\n   * @return the flat-string value\n   */\n  final String getFlat() {\n    if (!flatComputed) {\n      flat = computeFlat();\n      flatComputed = true;\n    }\n    return flat;\n  }\n  /**\n   * Return the {@link Range} of a {@code Doc}.\n   *\n   * @return the {@code Doc}'s {@link Range}\n   */\n  final Range<Integer> range() {\n    if (!rangeComputed) {\n      range = computeRange();\n      rangeComputed = true;\n    }\n    return range;\n  }\n  /**\n   * Compute the {@code Doc}'s width.\n   *\n   * @return the width, or {@code Float.POSITIVE_INFINITY} if it must be broken\n   */\n  abstract float computeWidth();\n  /**\n   * Compute the {@code Doc}'s flat value. Not defined (and never called) if contains forced breaks.\n   *\n   * @return the flat value\n   */\n  abstract String computeFlat();\n  /**\n   * Compute the {@code Doc}'s {@link Range} of {@link Input.Token}s.\n   *\n   * @return the {@link Range}\n   */\n  abstract Range<Integer> computeRange();\n  /**\n   * Make breaking decisions for a {@code Doc}.\n   *\n   * @param maxWidth the maximum line width\n   * @param state the current output state\n   * @return the new output state\n   */\n  public abstract State computeBreaks(CommentsHelper commentsHelper, int maxWidth, State state);\n  /** Write a {@code Doc} to an {@link Output}, after breaking decisions have been made. */\n  public abstract void write(Output output);\n  /** A {@code Level} inside a {@link Doc}. */\n  static final class Level extends Doc {\n    private final Indent plusIndent; // The extra indent following breaks.\n    private final List<Doc> docs = new ArrayList<>(); // The elements of the level.\n    private Level(Indent plusIndent) {\n      this.plusIndent = plusIndent;\n    }\n    /**\n     * Factory method for {@code Level}s.\n     *\n     * @param plusIndent the extra indent inside the {@code Level}\n     * @return the new {@code Level}\n     */\n    static Level make(Indent plusIndent) {\n      return new Level(plusIndent);\n    }\n    /**\n     * Add a {@link Doc} to the {@code Level}.\n     *\n     * @param doc the {@link Doc} to add\n     */\n    void add(Doc doc) {\n      docs.add(doc);\n    }\n    @Override\n    float computeWidth() {\n      float thisWidth = 0.0F;\n      for (Doc doc : docs) {\n        thisWidth += doc.getWidth();\n      }\n      return thisWidth;\n    }\n    @Override\n    String computeFlat() {\n      StringBuilder builder = new StringBuilder();\n      for (Doc doc : docs) {\n        builder.append(doc.getFlat());\n      }\n      return builder.toString();\n    }\n    @Override\n    Range<Integer> computeRange() {\n      Range<Integer> docRange = EMPTY_RANGE;\n      for (Doc doc : docs) {\n        docRange = union(docRange, doc.range());\n      }\n      return docRange;\n    }\n    // State that needs to be preserved between calculating breaks and\n    // writing output.\n    // TODO(cushon): represent phases as separate immutable data.\n    /** True if the entire {@link Level} fits on one line. */\n    boolean oneLine = false;\n    /**\n     * Groups of {@link Doc}s that are children of the current {@link Level}, separated by {@link\n     * Break}s.\n     */\n    List<List<Doc>> splits = new ArrayList<>();\n    /** {@link Break}s between {@link Doc}s in the current {@link Level}. */\n    List<Break> breaks = new ArrayList<>();\n    @Override\n    public State computeBreaks(CommentsHelper commentsHelper, int maxWidth, State state) {\n      float thisWidth = getWidth();\n      if (state.column + thisWidth <= maxWidth) {\n        oneLine = true;\n        return state.withColumn(state.column + (int) thisWidth);\n      }\n      State broken =\n          computeBroken(\n              commentsHelper, maxWidth, new State(state.indent + plusIndent.eval(), state.column));\n      return state.withColumn(broken.column);\n    }\n    private static void splitByBreaks(List<Doc> docs, List<List<Doc>> splits, List<Break> breaks) {\n      splits.clear();\n      breaks.clear();\n      splits.add(new ArrayList<>());\n      for (Doc doc : docs) {\n        if (doc instanceof Break) {\n          breaks.add((Break) doc);\n          splits.add(new ArrayList<>());\n        } else {\n          getLast(splits).add(doc);\n        }\n      }\n    }\n    /** Compute breaks for a {@link Level} that spans multiple lines. */\n    private State computeBroken(CommentsHelper commentsHelper, int maxWidth, State state) {\n      splitByBreaks(docs, splits, breaks);\n      state =\n          computeBreakAndSplit(\n              commentsHelper, maxWidth, state, /* optBreakDoc= */ Optional.empty(), splits.get(0));\n      // Handle following breaks and split.\n      for (int i = 0; i < breaks.size(); i++) {\n        state =\n            computeBreakAndSplit(\n                commentsHelper, maxWidth, state, Optional.of(breaks.get(i)), splits.get(i + 1));\n      }\n      return state;\n    }\n    /** Lay out a Break-separated group of Docs in the current Level. */\n    private static State computeBreakAndSplit(\n        CommentsHelper commentsHelper,\n        int maxWidth,\n        State state,\n        Optional<Break> optBreakDoc,\n        List<Doc> split) {\n      float breakWidth = optBreakDoc.isPresent() ? optBreakDoc.get().getWidth() : 0.0F;\n      float splitWidth = getWidth(split);\n      boolean shouldBreak =\n          (optBreakDoc.isPresent() && optBreakDoc.get().fillMode == FillMode.UNIFIED)\n              || state.mustBreak\n              || state.column + breakWidth + splitWidth > maxWidth;\n      if (optBreakDoc.isPresent()) {\n        state = optBreakDoc.get().computeBreaks(state, state.lastIndent, shouldBreak);\n      }\n      boolean enoughRoom = state.column + splitWidth <= maxWidth;\n      state = computeSplit(commentsHelper, maxWidth, split, state.withMustBreak(false));\n      if (!enoughRoom) {\n        state = state.withMustBreak(true); // Break after, too.\n      }\n      return state;\n    }\n    private static State computeSplit(\n        CommentsHelper commentsHelper, int maxWidth, List<Doc> docs, State state) {\n      for (Doc doc : docs) {\n        state = doc.computeBreaks(commentsHelper, maxWidth, state);\n      }\n      return state;\n    }\n    @Override\n    public void write(Output output) {\n      if (oneLine) {\n        output.append(getFlat(), range()); // This is defined because width is finite.\n      } else {\n        writeFilled(output);\n      }\n    }\n    private void writeFilled(Output output) {\n      // Handle first split.\n      for (Doc doc : splits.get(0)) {\n        doc.write(output);\n      }\n      // Handle following breaks and split.\n      for (int i = 0; i < breaks.size(); i++) {\n        breaks.get(i).write(output);\n        for (Doc doc : splits.get(i + 1)) {\n          doc.write(output);\n        }\n      }\n    }\n    /**\n     * Get the width of a sequence of {@link Doc}s.\n     *\n     * @param docs the {@link Doc}s\n     * @return the width, or {@code Float.POSITIVE_INFINITY} if any {@link Doc} must be broken\n     */\n    static float getWidth(List<Doc> docs) {\n      float width = 0.0F;\n      for (Doc doc : docs) {\n        width += doc.getWidth();\n      }\n      return width;\n    }\n<fim_suffix>    private static Range<Integer> union(Range<Integer> x, Range<Integer> y) {\n      return x.isEmpty() ? y : y.isEmpty() ? x : x.span(y).canonical(INTEGERS);\n    }<fim_middle>// function below has no smell\n"}