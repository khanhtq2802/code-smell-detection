{"text": "<fim_prefix>\n<fim_suffix>final class DocumentsWriterDeleteQueue implements Accountable {\n  // the current end (latest delete operation) in the delete queue:\n  private volatile Node<?> tail;\n  /** Used to record deletes against all prior (already written to disk) segments.  Whenever any segment flushes, we bundle up this set of\n   *  deletes and insert into the buffered updates stream before the newly flushed segment(s). */\n  private final DeleteSlice globalSlice;\n  private final BufferedUpdates globalBufferedUpdates;\n  // only acquired to update the global deletes, pkg-private for access by tests:\n  final ReentrantLock globalBufferLock = new ReentrantLock();\n  final long generation;\n  /** Generates the sequence number that IW returns to callers changing the index, showing the effective serialization of all operations. */\n  private final AtomicLong nextSeqNo;\n  private final InfoStream infoStream;\n  // for asserts\n  long maxSeqNo = Long.MAX_VALUE;\n  DocumentsWriterDeleteQueue(InfoStream infoStream) {\n    // seqNo must start at 1 because some APIs negate this to also return a boolean\n    this(infoStream, 0, 1);\n  }\n  DocumentsWriterDeleteQueue(InfoStream infoStream, long generation, long startSeqNo) {\n    this(infoStream, new BufferedUpdates(\"global\"), generation, startSeqNo);\n  }\n  DocumentsWriterDeleteQueue(InfoStream infoStream, BufferedUpdates globalBufferedUpdates, long generation, long startSeqNo) {\n    this.infoStream = infoStream;\n    this.globalBufferedUpdates = globalBufferedUpdates;\n    this.generation = generation;\n    this.nextSeqNo = new AtomicLong(startSeqNo);\n    /*\n     * we use a sentinel instance as our initial tail. No slice will ever try to\n     * apply this tail since the head is always omitted.\n     */\n    tail = new Node<>(null); // sentinel\n    globalSlice = new DeleteSlice(tail);\n  }\n  long addDelete(Query... queries) {\n    long seqNo = add(new QueryArrayNode(queries));\n    tryApplyGlobalSlice();\n    return seqNo;\n  }\n  long addDelete(Term... terms) {\n    long seqNo = add(new TermArrayNode(terms));\n    tryApplyGlobalSlice();\n    return seqNo;\n  }\n  long addDocValuesUpdates(DocValuesUpdate... updates) {\n    long seqNo = add(new DocValuesUpdatesNode(updates));\n    tryApplyGlobalSlice();\n    return seqNo;\n  }\n  static Node<Term> newNode(Term term) {\n    return new TermNode(term);\n  }\n  static Node<DocValuesUpdate[]> newNode(DocValuesUpdate... updates) {\n    return new DocValuesUpdatesNode(updates);\n  }\n  /**\n   * invariant for document update\n   */\n  long add(Node<?> deleteNode, DeleteSlice slice) {\n    long seqNo = add(deleteNode);\n    /*\n     * this is an update request where the term is the updated documents\n     * delTerm. in that case we need to guarantee that this insert is atomic\n     * with regards to the given delete slice. This means if two threads try to\n     * update the same document with in turn the same delTerm one of them must\n     * win. By taking the node we have created for our del term as the new tail\n     * it is guaranteed that if another thread adds the same right after us we\n     * will apply this delete next time we update our slice and one of the two\n     * competing updates wins!\n     */\n    slice.sliceTail = deleteNode;\n    assert slice.sliceHead != slice.sliceTail : \"slice head and tail must differ after add\";\n    tryApplyGlobalSlice(); // TODO doing this each time is not necessary maybe\n    // we can do it just every n times or so?\n    return seqNo;\n  }\n  synchronized long add(Node<?> newNode) {\n    tail.next = newNode;\n    this.tail = newNode;\n    return getNextSequenceNumber();\n  }\n  boolean anyChanges() {\n    globalBufferLock.lock();\n    try {\n      /*\n       * check if all items in the global slice were applied \n       * and if the global slice is up-to-date\n       * and if globalBufferedUpdates has changes\n       */\n      return globalBufferedUpdates.any() || !globalSlice.isEmpty() || globalSlice.sliceTail != tail || tail.next != null;\n    } finally {\n      globalBufferLock.unlock();\n    }\n  }\n  void tryApplyGlobalSlice() {\n    if (globalBufferLock.tryLock()) {\n      /*\n       * The global buffer must be locked but we don't need to update them if\n       * there is an update going on right now. It is sufficient to apply the\n       * deletes that have been added after the current in-flight global slices\n       * tail the next time we can get the lock!\n       */\n      try {\n        if (updateSliceNoSeqNo(globalSlice)) {\n          globalSlice.apply(globalBufferedUpdates, BufferedUpdates.MAX_INT);\n        }\n      } finally {\n        globalBufferLock.unlock();\n      }\n    }\n  }\n  FrozenBufferedUpdates freezeGlobalBuffer(DeleteSlice callerSlice) throws IOException {\n    globalBufferLock.lock();\n    /*\n     * Here we freeze the global buffer so we need to lock it, apply all\n     * deletes in the queue and reset the global slice to let the GC prune the\n     * queue.\n     */\n    final Node<?> currentTail = tail; // take the current tail make this local any\n    // Changes after this call are applied later\n    // and not relevant here\n    if (callerSlice != null) {\n      // Update the callers slices so we are on the same page\n      callerSlice.sliceTail = currentTail;\n    }\n    try {\n      if (globalSlice.sliceTail != currentTail) {\n        globalSlice.sliceTail = currentTail;\n        globalSlice.apply(globalBufferedUpdates, BufferedUpdates.MAX_INT);\n      }\n      if (globalBufferedUpdates.any()) {\n        final FrozenBufferedUpdates packet = new FrozenBufferedUpdates(infoStream, globalBufferedUpdates, null);\n        globalBufferedUpdates.clear();\n        return packet;\n      } else {\n        return null;\n      }\n    } finally {\n      globalBufferLock.unlock();\n    }\n  }\n  DeleteSlice newSlice() {\n    return new DeleteSlice(tail);\n  }\n  /** Negative result means there were new deletes since we last applied */\n  synchronized long updateSlice(DeleteSlice slice) {\n    long seqNo = getNextSequenceNumber();\n    if (slice.sliceTail != tail) {\n      // new deletes arrived since we last checked\n      slice.sliceTail = tail;\n      seqNo = -seqNo;\n    }\n    return seqNo;\n  }\n  /** Just like updateSlice, but does not assign a sequence number */\n  boolean updateSliceNoSeqNo(DeleteSlice slice) {\n    if (slice.sliceTail != tail) {\n      // new deletes arrived since we last checked\n      slice.sliceTail = tail;\n      return true;\n    }\n    return false;\n  }\n  static class DeleteSlice {\n    // No need to be volatile, slices are thread captive (only accessed by one thread)!\n    Node<?> sliceHead; // we don't apply this one\n    Node<?> sliceTail;\n    DeleteSlice(Node<?> currentTail) {\n      assert currentTail != null;\n      /*\n       * Initially this is a 0 length slice pointing to the 'current' tail of\n       * the queue. Once we update the slice we only need to assign the tail and\n       * have a new slice\n       */\n      sliceHead = sliceTail = currentTail;\n    }\n    void apply(BufferedUpdates del, int docIDUpto) {\n      if (sliceHead == sliceTail) {\n        // 0 length slice\n        return;\n      }\n      /*\n       * When we apply a slice we take the head and get its next as our first\n       * item to apply and continue until we applied the tail. If the head and\n       * tail in this slice are not equal then there will be at least one more\n       * non-null node in the slice!\n       */\n      Node<?> current = sliceHead;\n      do {\n        current = current.next;\n        assert current != null : \"slice property violated between the head on the tail must not be a null node\";\n        current.apply(del, docIDUpto);\n      } while (current != sliceTail);\n      reset();\n    }\n    void reset() {\n      // Reset to a 0 length slice\n      sliceHead = sliceTail;\n    }\n    /**\n     * Returns <code>true</code> iff the given node is identical to the the slices tail,\n     * otherwise <code>false</code>.\n     */\n    boolean isTail(Node<?> node) {\n      return sliceTail == node;\n    }\n    /**\n     * Returns <code>true</code> iff the given item is identical to the item\n     * hold by the slices tail, otherwise <code>false</code>.\n     */\n    boolean isTailItem(Object object) {\n      return sliceTail.item == object;\n    }\n    boolean isEmpty() {\n      return sliceHead == sliceTail;\n    }\n  }\n  public int numGlobalTermDeletes() {\n    return globalBufferedUpdates.numTermDeletes.get();\n  }\n  void clear() {\n    globalBufferLock.lock();\n    try {\n      final Node<?> currentTail = tail;<fim_middle>// class below is blob\n"}