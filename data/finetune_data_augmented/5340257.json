{"text": "<fim_prefix>        for (int i = 0; i < 3; i++) {\n            executor.scheduleWithFixedDelay(new CleanupOldClaims(), 1000, 10, TimeUnit.MILLISECONDS);\n        }\n    }\n    @Override\n    public void shutdown() {\n        executor.shutdown();\n    }\n    /**\n     * Specifies a Backup Repository where data should be written if this\n     * Repository fills up\n     *\n     * @param backup repo backup\n     */\n    public void setBackupRepository(final ContentRepository backup) {\n        final boolean updated = backupRepositoryRef.compareAndSet(null, backup);\n        if (!updated) {\n            throw new IllegalStateException(\"Cannot change BackupRepository after it has already been set\");\n        }\n    }\n    public ContentRepository getBackupRepository() {\n        return backupRepositoryRef.get();\n    }\n    private StandardContentClaim resolveClaim(final ContentClaim claim) {\n        if (!(claim instanceof StandardContentClaim)) {\n            throw new IllegalArgumentException(\"Cannot increment ClaimantCount of \" + claim + \" because it does not belong to this ContentRepository\");\n        }\n        return (StandardContentClaim) claim;\n    }\n    private ContentClaim getBackupClaim(final ContentClaim claim) {\n        if (claim == null) {\n            return null;\n        }\n        return backupRepoClaimMap.get(claim);\n    }\n    @Override\n    public long getContainerCapacity(final String containerName) throws IOException {\n        return maxBytes;\n    }\n    @Override\n    public Set<String> getContainerNames() {\n        return Collections.singleton(CONTAINER_NAME);\n    }\n    @Override\n    public long getContainerUsableSpace(String containerName) throws IOException {\n        return maxBytes - repoSize.get();\n    }\n    @Override\n    public String getContainerFileStoreName(String containerName) {\n        return null;\n    }\n    @Override\n    public ContentClaim create(boolean lossTolerant) throws IOException {\n        if (lossTolerant) {\n            return createLossTolerant();\n        } else {\n            final ContentRepository backupRepo = getBackupRepository();\n            if (backupRepo == null) {\n                // TODO: Loss Tolerance is not yet configurable.\n                // Therefore, since this is an in-memory content repository, assume that this claim is loss-tolerant if there\n                // is not a backup repository\n                return createLossTolerant();\n            }\n            final ContentClaim backupClaim = backupRepo.create(lossTolerant);\n            backupRepoClaimMap.put(backupClaim, backupClaim);\n            return backupClaim;\n        }\n    }\n    private ContentClaim createLossTolerant() {\n        final long id = idGenerator.getAndIncrement();\n        final ResourceClaim resourceClaim = claimManager.newResourceClaim(CONTAINER_NAME, \"section\", String.valueOf(id), true, false);\n        final ContentClaim claim = new StandardContentClaim(resourceClaim, 0L);\n        final ContentBlock contentBlock = new ContentBlock(claim, repoSize);\n        claimManager.incrementClaimantCount(resourceClaim, true);\n        claimMap.put(claim, contentBlock);\n        logger.debug(\"Created {} and mapped to {}\", claim, contentBlock);\n        return claim;\n    }\n    @Override\n    public int incrementClaimaintCount(final ContentClaim claim) {\n        if (claim == null) {\n            return 0;\n        }\n        final ContentClaim backupClaim = getBackupClaim(claim);\n        if (backupClaim == null) {\n            return claimManager.incrementClaimantCount(resolveClaim(claim).getResourceClaim());\n        } else {\n            return getBackupRepository().incrementClaimaintCount(backupClaim);\n        }\n    }\n    @Override\n    public int decrementClaimantCount(final ContentClaim claim) {\n        if (claim == null) {\n            return 0;\n        }\n        final ContentClaim backupClaim = getBackupClaim(claim);\n        if (backupClaim == null) {\n            return claimManager.decrementClaimantCount(resolveClaim(claim).getResourceClaim());\n        } else {\n            return getBackupRepository().decrementClaimantCount(backupClaim);\n        }\n    }\n    @Override\n    public int getClaimantCount(final ContentClaim claim) {\n        if (claim == null) {\n            return 0;\n        }\n        final ContentClaim backupClaim = getBackupClaim(claim);\n        if (backupClaim == null) {\n            return claimManager.getClaimantCount(resolveClaim(claim).getResourceClaim());\n        } else {\n            return getBackupRepository().getClaimantCount(backupClaim);\n        }\n    }\n    @Override\n    public boolean remove(final ContentClaim claim) {\n        if (claim == null) {\n            return false;\n        }\n        final ContentClaim backupClaim = getBackupClaim(claim);\n        if (backupClaim == null) {\n            final ContentBlock content = claimMap.remove(claim);\n            if (content == null) {\n                logger.debug(\"Removed {} from repo but it did not exist\", claim);\n            } else {\n                logger.debug(\"Removed {} from repo; Content = {}\", claim, content);\n                content.destroy();\n            }\n        } else {\n            getBackupRepository().remove(backupClaim);\n        }\n        return true;\n    }\n    private boolean remove(final ResourceClaim claim) {\n        if (claim == null) {\n            return false;\n        }\n        final Set<ContentClaim> contentClaims = new HashSet<>();\n        for (final Map.Entry<ContentClaim, ContentBlock> entry : claimMap.entrySet()) {\n            final ContentClaim contentClaim = entry.getKey();\n            if (contentClaim.getResourceClaim().equals(claim)) {\n                contentClaims.add(contentClaim);\n            }\n        }\n        boolean removed = false;\n        for (final ContentClaim contentClaim : contentClaims) {\n            if (remove(contentClaim)) {\n                removed = true;\n            }\n        }\n        return removed;\n    }\n    @Override\n    public ContentClaim clone(final ContentClaim original, final boolean lossTolerant) throws IOException {\n        final ContentClaim createdClaim = create(lossTolerant);\n        try (final InputStream dataIn = read(original)) {\n            final ContentRepository createdClaimRepo = lossTolerant ? this : getBackupRepository();\n            if (createdClaimRepo == null) {\n                throw new IllegalStateException(\"Cannot create non-loss-tolerant ContentClaim because there is no persistent Content Repository configured\");\n            }\n            try (final OutputStream dataOut = createdClaimRepo.write(createdClaim)) {\n                StreamUtils.copy(dataIn, dataOut);\n            }\n        }\n        return createdClaim;\n    }\n    @Override\n    public long merge(final Collection<ContentClaim> claims, final ContentClaim destination, final byte[] header, final byte[] footer, final byte[] demarcator) throws IOException {\n        long bytes = 0L;\n        try (final OutputStream out = write(destination)) {\n            if (header != null) {\n                out.write(header);\n                bytes += header.length;\n            }\n            final Iterator<ContentClaim> itr = claims.iterator();\n            while (itr.hasNext()) {\n                final ContentClaim readClaim = itr.next();\n                try (final InputStream in = read(readClaim)) {\n                    bytes += StreamUtils.copy(in, out);\n                }\n                if (itr.hasNext() && demarcator != null) {\n                    bytes += demarcator.length;\n                    out.write(demarcator);\n                }\n            }\n            if (footer != null) {\n                bytes += footer.length;\n                out.write(footer);\n            }\n            return bytes;\n        }\n    }\n    @Override\n    public long importFrom(final Path content, final ContentClaim claim) throws IOException {\n        try (final InputStream in = new FileInputStream(content.toFile())) {\n            return importFrom(in, claim);\n        }\n    }\n    @Override\n    public long importFrom(final InputStream in, final ContentClaim claim) throws IOException {\n        final ContentClaim backupClaim = getBackupClaim(claim);\n        if (backupClaim == null) {\n            final ContentBlock content = getContent(claim);\n            content.reset();\n            return StreamUtils.copy(in, content.write());\n        } else {\n            return getBackupRepository().importFrom(in, claim);\n        }\n    }\n    @Override\n    public long exportTo(final ContentClaim claim, final Path destination, final boolean append) throws IOException {\n        return exportTo(claim, destination, append, 0L, size(claim));\n    }\n<fim_suffix>    @Override\n    public long exportTo(final ContentClaim claim, final Path destination, final boolean append, final long offset, final long length) throws IOException {\n        if (claim == null) {\n            if (append) {\n                return 0L;\n            }\n            Files.createFile(destination);\n            return 0L;\n        }\n        final StandardOpenOption openOption = append ? StandardOpenOption.APPEND : StandardOpenOption.CREATE;\n        try (final InputStream in = read(claim);\n                final OutputStream destinationStream = Files.newOutputStream(destination, openOption)) {\n            if (offset > 0) {\n                StreamUtils.skip(in, offset);\n            }\n            StreamUtils.copy(in, destinationStream, length);\n            return length;\n        }\n    }<fim_middle>// function below is feature envy\n"}