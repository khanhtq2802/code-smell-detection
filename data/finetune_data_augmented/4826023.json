{"text": "<fim_prefix>        public boolean hasSubclasses() {\n            return !classes.isEmpty();\n        }\n        public List<ObjectSpecification> toList() {\n            return Collections.unmodifiableList(classes);\n        }\n    }\n    //region > fields\n    protected final ServicesInjector servicesInjector;\n    private final DeploymentCategory deploymentCategory;\n    private PostProcessor postProcessor;\n    private final SpecificationLoader specificationLoader;\n    private final FacetProcessor facetProcessor;\n    protected Properties metadataProperties;\n    private final List<ObjectAssociation> associations = Lists.newArrayList();\n    private final List<ObjectAction> objectActions = Lists.newArrayList();\n    // partitions and caches objectActions by type; updated in sortCacheAndUpdateActions()\n    private final Map<ActionType, List<ObjectAction>> objectActionsByType = createObjectActionsByType();\n    private static Map<ActionType, List<ObjectAction>> createObjectActionsByType() {\n        final Map<ActionType, List<ObjectAction>> map = Maps.newHashMap();\n        for (final ActionType type : ActionType.values()) {\n            map.put(type, Lists.<ObjectAction>newArrayList());\n        }\n        return map;\n    }\n    private boolean contributeeAndMixedInAssociationsAdded;\n    private boolean contributeeAndMixedInActionsAdded;\n    private final List<ObjectSpecification> interfaces = Lists.newArrayList();\n    private final SubclassList directSubclasses = new SubclassList();\n    // built lazily\n    private SubclassList transitiveSubclasses;\n    private final Class<?> correspondingClass;\n    private final String fullName;\n    private final String shortName;\n    private final Identifier identifier;\n    private final boolean isAbstract;\n    // derived lazily, cached since immutable\n    protected ObjectSpecId specId;\n    private ObjectSpecification superclassSpec;\n    private Persistability persistability = Persistability.USER_PERSISTABLE;\n    private TitleFacet titleFacet;\n    private IconFacet iconFacet;\n    private CssClassFacet cssClassFacet;\n    private IntrospectionState introspectionState = IntrospectionState.NOT_INTROSPECTED;\n    //endregion\n    //region > Constructor\n    public ObjectSpecificationAbstract(\n            final Class<?> introspectedClass,\n            final String shortName,\n            final ServicesInjector servicesInjector,\n            final FacetProcessor facetProcessor,\n            final PostProcessor postProcessor) {\n        this.correspondingClass = introspectedClass;\n        this.fullName = introspectedClass.getName();\n        this.shortName = shortName;\n        this.isAbstract = ClassExtensions.isAbstract(introspectedClass);\n        this.identifier = Identifier.classIdentifier(introspectedClass);\n        this.servicesInjector = servicesInjector;\n        this.facetProcessor = facetProcessor;\n        this.specificationLoader = servicesInjector.getSpecificationLoader();\n        this.deploymentCategory = servicesInjector.getDeploymentCategoryProvider().getDeploymentCategory();\n        this.postProcessor = postProcessor;\n    }\n    //endregion\n    //region > Stuff immediately derivable from class\n    @Override\n    public FeatureType getFeatureType() {\n        return FeatureType.OBJECT;\n    }\n    @Override\n    public ObjectSpecId getSpecId() {\n        if(specId == null) {\n            final ObjectSpecIdFacet facet = getFacet(ObjectSpecIdFacet.class);\n            if(facet == null) {\n                throw new IllegalStateException(\"could not find an ObjectSpecIdFacet for \" + this.getFullIdentifier());\n            }\n            specId = facet.value();\n        }\n        return specId;\n    }\n    /**\n     * As provided explicitly within the constructor.\n     *\n     * <p>\n     * Not API, but <tt>public</tt> so that {@link FacetedMethodsBuilder} can\n     * call it.\n     */\n    @Override\n    public Class<?> getCorrespondingClass() {\n        return correspondingClass;\n    }\n    @Override\n    public String getShortIdentifier() {\n        return shortName;\n    }\n    /**\n     * The {@link Class#getName() (full) name} of the\n     * {@link #getCorrespondingClass() class}.\n     */\n    @Override\n    public String getFullIdentifier() {\n        return fullName;\n    }\n    //endregion\n    //region > Introspection\n    /**\n     * Keeps introspecting up to the level required.\n     */\n    public void introspectUpTo(final IntrospectionState upTo) {\n        LOG.debug(\"introspectingUpTo: {}, {}\", getFullIdentifier(), upTo);\n        switch (introspectionState) {\n        case NOT_INTROSPECTED:\n            if(this.introspectionState.compareTo(upTo) < 0) {\n                // set to avoid infinite loops\n                this.introspectionState = IntrospectionState.TYPE_BEING_INTROSPECTED;\n                introspectTypeHierarchy();\n                updateFromFacetValues();\n                this.introspectionState = IntrospectionState.TYPE_INTROSPECTED;\n            }\n            if(this.introspectionState.compareTo(upTo) < 0) {\n                this.introspectionState = IntrospectionState.MEMBERS_BEING_INTROSPECTED;\n                introspectMembers();\n                this.introspectionState = IntrospectionState.TYPE_AND_MEMBERS_INTROSPECTED;\n            }\n            // set to avoid infinite loops\n            break;\n        case TYPE_BEING_INTROSPECTED:\n            // nothing to do\n            break;\n        case TYPE_INTROSPECTED:\n            if(this.introspectionState.compareTo(upTo) < 0) {\n                // set to avoid infinite loops\n                this.introspectionState = IntrospectionState.MEMBERS_BEING_INTROSPECTED;\n                introspectMembers();\n                this.introspectionState = IntrospectionState.TYPE_AND_MEMBERS_INTROSPECTED;\n            }\n            break;\n        case MEMBERS_BEING_INTROSPECTED:\n            // nothing to do\n        case TYPE_AND_MEMBERS_INTROSPECTED:\n            // nothing to do\n            break;\n        }\n    }\n    protected abstract void introspectTypeHierarchy();\n    protected abstract void introspectMembers();\n    protected void loadSpecOfSuperclass(final Class<?> superclass) {\n        if (superclass == null) {\n            return;\n        }\n        superclassSpec = getSpecificationLoader().loadSpecification(superclass);\n        if (superclassSpec != null) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"  Superclass {}\", superclass.getName());\n            }\n            updateAsSubclassTo(superclassSpec);\n        }\n    }\n    protected void updateInterfaces(final List<ObjectSpecification> interfaces) {\n        this.interfaces.clear();\n        this.interfaces.addAll(interfaces);\n    }\n    private void updateAsSubclassTo(final ObjectSpecification supertypeSpec) {\n        if (!(supertypeSpec instanceof ObjectSpecificationAbstract)) {\n            return;\n        }\n        // downcast required because addSubclass is (deliberately) not public\n        // API\n        final ObjectSpecificationAbstract introspectableSpec = (ObjectSpecificationAbstract) supertypeSpec;\n        introspectableSpec.updateSubclasses(this);\n    }\n    protected void updateAsSubclassTo(final List<ObjectSpecification> supertypeSpecs) {\n        for (final ObjectSpecification supertypeSpec : supertypeSpecs) {\n            updateAsSubclassTo(supertypeSpec);\n        }\n    }\n    private void updateSubclasses(final ObjectSpecification subclass) {\n        this.directSubclasses.addSubclass(subclass);\n    }\n    protected void sortAndUpdateAssociations(final List<ObjectAssociation> associations) {\n        final List<ObjectAssociation> orderedAssociations = sortAssociations(associations);\n        synchronized (this.associations) {\n            this.associations.clear();\n            this.associations.addAll(orderedAssociations);\n        }\n    }\n    protected void sortCacheAndUpdateActions(final List<ObjectAction> objectActions) {\n        final List<ObjectAction> orderedActions = sortActions(objectActions);\n        synchronized (this.objectActions){\n            this.objectActions.clear();\n            this.objectActions.addAll(orderedActions);\n            for (final ActionType type : ActionType.values()) {\n                final List<ObjectAction> objectActionForType = objectActionsByType.get(type);\n                objectActionForType.clear();\n                objectActionForType.addAll(Collections2.filter(objectActions, ObjectAction.Predicates.ofType(type)));\n            }\n        }\n    }\n    private void updateFromFacetValues() {\n        titleFacet = getFacet(TitleFacet.class);\n        iconFacet = getFacet(IconFacet.class);\n        cssClassFacet = getFacet(CssClassFacet.class);\n        this.persistability = determinePersistability();\n    }\n<fim_suffix>    private Persistability determinePersistability() {\n        final NotPersistableFacet notPersistableFacet = getFacet(NotPersistableFacet.class);\n        if (notPersistableFacet == null) {\n            return Persistability.USER_PERSISTABLE;\n        }\n        final NotPersistable.By initiatedBy = notPersistableFacet.value();\n        if (initiatedBy == NotPersistable.By.USER_OR_PROGRAM) {\n            return Persistability.TRANSIENT;\n        } else if (initiatedBy == NotPersistable.By.USER) {\n            return Persistability.PROGRAM_PERSISTABLE;\n        } else {\n            return Persistability.USER_PERSISTABLE;\n        }\n    }<fim_middle>// function below has no smell\n"}