{"text": "<fim_prefix>package org.apache.samoa.moa.classifiers.core.attributeclassobservers;\n\n/*\n * #%L\n * SAMOA\n * %%\n * Copyright (C) 2014 - 2015 Apache Software Foundation\n * %%\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * #L%\n */\n\nimport org.apache.samoa.moa.classifiers.core.AttributeSplitSuggestion;\nimport org.apache.samoa.moa.classifiers.core.conditionaltests.NominalAttributeBinaryTest;\nimport org.apache.samoa.moa.classifiers.core.conditionaltests.NominalAttributeMultiwayTest;\nimport org.apache.samoa.moa.classifiers.core.splitcriteria.SplitCriterion;\nimport org.apache.samoa.moa.core.AutoExpandVector;\nimport org.apache.samoa.moa.core.DoubleVector;\nimport org.apache.samoa.moa.core.ObjectRepository;\nimport org.apache.samoa.moa.core.Utils;\nimport org.apache.samoa.moa.options.AbstractOptionHandler;\nimport org.apache.samoa.moa.tasks.TaskMonitor;\n\n/**\n * Class for observing the class data distribution for a nominal attribute. This observer monitors the class\n * distribution of a given attribute. Used in naive Bayes and decision trees to monitor data statistics on leaves.\n * \n * @author Richard Kirkby (rkirkby@cs.waikato.ac.nz)\n * @version $Revision: 7 $\n */\npublic class NominalAttributeClassObserver extends AbstractOptionHandler implements DiscreteAttributeClassObserver {\n\n  private static final long serialVersionUID = 1L;\n\n  protected double totalWeightObserved = 0.0;\n\n  protected double missingWeightObserved = 0.0;\n\n  public AutoExpandVector<DoubleVector> attValDistPerClass = new AutoExpandVector<>();\n\n  @Override\n  public void observeAttributeClass(double attVal, int classVal, double weight) {\n    if (Utils.isMissingValue(attVal)) {\n      this.missingWeightObserved += weight;\n    } else {\n      int attValInt = (int) attVal;\n      DoubleVector valDist = this.attValDistPerClass.get(classVal);\n      if (valDist == null) {\n        valDist = new DoubleVector();\n        this.attValDistPerClass.set(classVal, valDist);\n      }\n      valDist.addToValue(attValInt, weight);\n    }\n    this.totalWeightObserved += weight;\n  }\n\n<fim_suffix>  @Override\n  public double probabilityOfAttributeValueGivenClass(double attVal,\n      int classVal) {\n    DoubleVector obs = this.attValDistPerClass.get(classVal);\n    return obs != null ? (obs.getValue((int) attVal) + 1.0)\n        / (obs.sumOfValues() + obs.numValues()) : 0.0;\n  }\n\n  public double totalWeightOfClassObservations() {\n    return this.totalWeightObserved;\n  }\n\n  public double weightOfObservedMissingValues() {\n    return this.missingWeightObserved;\n  }\n\n  @Override\n  public AttributeSplitSuggestion getBestEvaluatedSplitSuggestion(\n      SplitCriterion criterion, double[] preSplitDist, int attIndex,\n      boolean binaryOnly) {\n    AttributeSplitSuggestion bestSuggestion = null;\n    int maxAttValsObserved = getMaxAttValsObserved();\n    if (!binaryOnly) {\n      double[][] postSplitDists = getClassDistsResultingFromMultiwaySplit(maxAttValsObserved);\n      double merit = criterion.getMeritOfSplit(preSplitDist,\n          postSplitDists);\n      bestSuggestion = new AttributeSplitSuggestion(\n          new NominalAttributeMultiwayTest(attIndex), postSplitDists,\n          merit);\n    }\n    for (int valIndex = 0; valIndex < maxAttValsObserved; valIndex++) {\n      double[][] postSplitDists = getClassDistsResultingFromBinarySplit(valIndex);\n      double merit = criterion.getMeritOfSplit(preSplitDist,\n          postSplitDists);\n      if ((bestSuggestion == null) || (merit > bestSuggestion.merit)) {\n        bestSuggestion = new AttributeSplitSuggestion(\n            new NominalAttributeBinaryTest(attIndex, valIndex),\n            postSplitDists, merit);\n      }\n    }\n    return bestSuggestion;\n  }\n\n  public int getMaxAttValsObserved() {\n    int maxAttValsObserved = 0;\n    for (DoubleVector attValDist : this.attValDistPerClass) {\n      if ((attValDist != null)\n          && (attValDist.numValues() > maxAttValsObserved)) {\n        maxAttValsObserved = attValDist.numValues();\n      }\n    }\n    return maxAttValsObserved;\n  }\n\n  public double[][] getClassDistsResultingFromMultiwaySplit(\n      int maxAttValsObserved) {\n    DoubleVector[] resultingDists = new DoubleVector[maxAttValsObserved];\n    for (int i = 0; i < resultingDists.length; i++) {\n      resultingDists[i] = new DoubleVector();\n    }\n    for (int i = 0; i < this.attValDistPerClass.size(); i++) {\n      DoubleVector attValDist = this.attValDistPerClass.get(i);\n      if (attValDist != null) {\n        for (int j = 0; j < attValDist.numValues(); j++) {\n          resultingDists[j].addToValue(i, attValDist.getValue(j));\n        }\n      }\n    }\n    double[][] distributions = new double[maxAttValsObserved][];\n    for (int i = 0; i < distributions.length; i++) {\n      distributions[i] = resultingDists[i].getArrayRef();\n    }\n    return distributions;\n  }\n\n  public double[][] getClassDistsResultingFromBinarySplit(int valIndex) {\n    DoubleVector equalsDist = new DoubleVector();\n    DoubleVector notEqualDist = new DoubleVector();\n    for (int i = 0; i < this.attValDistPerClass.size(); i++) {\n      DoubleVector attValDist = this.attValDistPerClass.get(i);\n      if (attValDist != null) {\n        for (int j = 0; j < attValDist.numValues(); j++) {\n          if (j == valIndex) {\n            equalsDist.addToValue(i, attValDist.getValue(j));\n          } else {\n            notEqualDist.addToValue(i, attValDist.getValue(j));\n          }\n        }\n      }\n    }\n    return new double[][] { equalsDist.getArrayRef(),\n        notEqualDist.getArrayRef() };\n  }\n\n  @Override\n  public void getDescription(StringBuilder sb, int indent) {\n    // TODO Auto-generated method stub\n  }\n\n  @Override\n  protected void prepareForUseImpl(TaskMonitor monitor, ObjectRepository repository) {\n    // TODO Auto-generated method stub\n  }\n\n  @Override\n  public void observeAttributeTarget(double attVal, double target) {\n    throw new UnsupportedOperationException(\"Not supported yet.\");\n  }\n\n}<fim_middle>// function below has no smell\n"}