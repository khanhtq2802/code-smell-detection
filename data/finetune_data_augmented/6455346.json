{"text": "<fim_prefix>\t\tfinal long offset;\n\t\tprivate final boolean computePadding;\n\t\t@Override\n\t\tpublic int compareTo(final J9ClassRegion region2) {\n\t\t\tfinal J9ClassRegion region1 = this;\n\t\t\tint delta;\n\t\t\t{\n\t\t\t\t/* compare slot pointers: lower addresses go first, and corrupt regions at the end */\n\t\t\t\tboolean corrupt = false;\n\t\t\t\tlong slot1 = 0;\n\t\t\t\tlong slot2 = 0;\n\t\t\t\ttry {\n\t\t\t\t\tslot1 = region1.getSlotPtr().longValue();\n\t\t\t\t} catch (CorruptDataException e) {\n\t\t\t\t\tcorrupt = true;\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tslot2 = region2.getSlotPtr().longValue();\n\t\t\t\t\tif (corrupt) {\n\t\t\t\t\t\t/* region1 is corrupt, but region2 is not */\n\t\t\t\t\t\treturn +1;\n\t\t\t\t\t}\n\t\t\t\t} catch (CorruptDataException e) {\n\t\t\t\t\tif (corrupt) {\n\t\t\t\t\t\t/* both regions are corrupt */\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* region2 is corrupt, but region1 is not */\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdelta = Long.compare(slot1, slot2);\n\t\t\t}\n\t\t\tif (0 == delta) {\n\t\t\t\tSlotType type1 = region1.getType();\n\t\t\t\tSlotType type2 = region2.getType();\n\t\t\t\t/* compare types: one with a lower ordinal goes first */\n\t\t\t\tdelta = Integer.compare(type2.ordinal(), type1.ordinal());\n\t\t\t\tif (0 == delta) {\n\t\t\t\t\tswitch (type1) {\n\t\t\t\t\tcase J9_SECTION_START:\n\t\t\t\t\tcase J9_SECTION_END:\n\t\t\t\t\t\t/* compare section lengths: a longer section goes first */\n\t\t\t\t\t\tdelta = Long.compare(region2.getLength(), region1.getLength());\n\t\t\t\t\t\tif (0 == delta) {\n\t\t\t\t\t\t\t/* compare section names: a longer name goes first */\n\t\t\t\t\t\t\tdelta = Integer.compare(region2.getName().length(), region1.getName().length());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (type1 == SlotType.J9_SECTION_END) {\n\t\t\t\t\t\t\t/* reverse ordering for section ends */\n\t\t\t\t\t\t\tdelta = -delta;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn delta;\n\t\t}\n\t\tpublic String getName() {\n\t\t\treturn name;\n\t\t}\n\t\tpublic long getLength() {\n\t\t\treturn length;\n\t\t}\n\t\tpublic SlotType getType() {\n\t\t\treturn type;\n\t\t}\n\t\tpublic AbstractPointer getSlotPtr() {\n\t\t\treturn slotPtr;\n\t\t}\n\t\tpublic boolean getComputePadding() {\n\t\t\treturn computePadding;\n\t\t}\n\t}\n\tpublic static class J9ClassRegionNode implements Comparable<J9ClassRegionNode> {\n\t\tprivate J9ClassRegion nodeValue;\n\t\tprivate LinkedList<J9ClassRegionNode> children;\n\t\tpublic J9ClassRegionNode(J9ClassRegion nodeValue) {\n\t\t\tthis.nodeValue = nodeValue;\n\t\t\tthis.children = new LinkedList<J9ClassRegionNode>();\n\t\t}\n\t\tpublic J9ClassRegion getNodeValue() {\n\t\t\treturn nodeValue;\n\t\t}\n\t\tpublic List<J9ClassRegionNode> getChildren() {\n\t\t\treturn children;\n\t\t}\n\t\tpublic void addChild(J9ClassRegionNode child) {\n\t\t\tthis.children.addLast(child);\n\t\t}\n\t\tpublic int compareTo(J9ClassRegionNode region2) {\n\t\t\tAbstractPointer slot1 = this.nodeValue.getSlotPtr();\n\t\t\tAbstractPointer slot2 = region2.nodeValue.getSlotPtr();\n\t\t\tif (slot1.lt(slot2)) {\n\t\t\t\treturn -1;\n\t\t\t} else if (slot1.gt(slot2)) {\n\t\t\t\treturn 1;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tprivate List<J9ClassRegion> classRegions = new LinkedList<J9ClassRegion>();\n\tprivate long firstJ9_ROM_UTF8 = Long.MAX_VALUE;\n\tprivate long lastJ9_ROM_UTF8 = Long.MIN_VALUE;\n\tpublic void addSlot(StructurePointer clazz, SlotType type,\n\t\t\tAbstractPointer slotPtr, String slotName)\n\t\t\tthrows CorruptDataException {\n\t\taddSlot(clazz, type, slotPtr, slotName, \"\");\n\t}\n\tpublic void addSlot(StructurePointer clazz, SlotType type,\n\t\t\tAbstractPointer slotPtr, String slotName, String additionalInfo)\n\t\t\tthrows CorruptDataException {\n\t\ttry {\n\t\t\tJ9ROMNameAndSignaturePointer nas;\n\t\t\tlong offset;\n\t\t\t/* The slots of the type J9_ROM_UTF8 are changed to have 2 slots:\n\t\t\t * -J9_SRP_TO_STRING\n\t\t\t * -J9_ROM_UTF8\n\t\t\t * This is done because we want to print the SRP field and also print\n\t\t\t * the UTF8 it is pointing to */\n\t\t\tswitch (type) {\n\t\t\t\tcase J9_ROM_UTF8:\n\t\t\t\t\toffset = slotPtr.getAddress() - clazz.getAddress();\n\t\t\t\t\tclassRegions.add(new J9ClassRegion(slotPtr, SlotType.J9_SRP_TO_STRING, slotName,\n\t\t\t\t\t\t\tadditionalInfo, type.getSize(), offset, true));\n\t\t\t\t\tVoidPointer srp = SelfRelativePointer.cast(slotPtr).get();\n\t\t\t\t\taddUTF8Region(clazz, slotName, additionalInfo, srp);\n\t\t\t\t\tbreak;\n\t\t\t\tcase J9_UTF8:\n\t\t\t\t\taddUTF8Region(clazz, slotName, additionalInfo, slotPtr);\n\t\t\t\t\tbreak;\n\t\t\t\t/* The fields of the type J9_SRPNAS or J9_SRP are changed to have 2 J9_ROM_UTF8\n\t\t\t\t * fields for their name and signature separated. */\n\t\t\t\tcase J9_SRPNAS:\n\t\t\t\t\tnas = J9ROMNameAndSignaturePointer.cast(SelfRelativePointer.cast(slotPtr).get());\n\t\t\t\t\tif (nas.notNull()) {\n\t\t\t\t\t\taddSlot(clazz, SlotType.J9_ROM_UTF8, nas.nameEA(), \"name\");\n\t\t\t\t\t\taddSlot(clazz, SlotType.J9_ROM_UTF8, nas.signatureEA(), \"signature\");\n\t\t\t\t\t}\n\t\t\t\t\t/* Since it is a SRP to a NAS, also print the SRP field. */\n\t\t\t\t\taddSlot(clazz, SlotType.J9_SRP, slotPtr, \"cpFieldNAS\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase J9_NAS:\n\t\t\t\t\tnas = J9ROMNameAndSignaturePointer.cast(slotPtr);\n\t\t\t\t\taddSlot(clazz, SlotType.J9_ROM_UTF8, nas.nameEA(), \"name\");\n\t\t\t\t\taddSlot(clazz, SlotType.J9_ROM_UTF8, nas.signatureEA(), \"signature\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase J9_IntermediateClassData:\n\t\t\t\t\toffset = slotPtr.getAddress() - clazz.getAddress();\n\t\t\t\t\tclassRegions.add(new J9ClassRegion(slotPtr, type, slotName,\n\t\t\t\t\t\t\tadditionalInfo, ((J9ROMClassPointer)clazz).intermediateClassDataLength().longValue(), offset, true));\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\toffset = slotPtr.getAddress() - clazz.getAddress();\n\t\t\t\t\tclassRegions.add(new J9ClassRegion(slotPtr, type, slotName,\n\t\t\t\t\t\t\tadditionalInfo, type.getSize(), offset, true));\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t}\n\t}\n<fim_suffix>\tprivate void addUTF8Region(StructurePointer clazz, String slotName,\n\t\t\tString additionalInfo, AbstractPointer utf8String)\n\t\t\tthrows CorruptDataException {\n\t\tlong offset = utf8String.getAddress() - clazz.getAddress();\n\t\t/* We do not want to print UTF8 outside of the ROM class. */\n\t\tlong clazzSize = ((J9ROMClassPointer) clazz).romSize().longValue();\n\t\tif ((offset > 0) && (offset < clazzSize)) {\n\t\t\tif (utf8String.notNull()) {\n\t\t\t\tlong UTF8Length = getUTF8Length(J9UTF8Pointer.cast(utf8String));\n\t\t\t\tif (utf8String.getAddress() < firstJ9_ROM_UTF8) {\n\t\t\t\t\tfirstJ9_ROM_UTF8 = utf8String.getAddress();\n\t\t\t\t}\n\t\t\t\tif ((utf8String.getAddress() + UTF8Length) > lastJ9_ROM_UTF8) {\n\t\t\t\t\tlastJ9_ROM_UTF8 = utf8String.getAddress() + UTF8Length;\n\t\t\t\t}\n\t\t\t\tclassRegions.add(new J9ClassRegion(utf8String,\n\t\t\t\t\t\tSlotType.J9_ROM_UTF8, slotName, additionalInfo,\n\t\t\t\t\t\tUTF8Length, offset, true));\n\t\t\t}\n\t\t}\n\t}<fim_middle>// function below is long method\n"}