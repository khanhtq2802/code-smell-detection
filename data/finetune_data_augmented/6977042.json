{"text": "<fim_prefix>   *\n   * @since 10.0 (previously, subclasses would override equivalent())\n   */\n  @ForOverride\n  protected abstract boolean doEquivalent(T a, T b);\n  /**\n   * Returns a hash code for {@code t}.\n   *\n   * <p>The {@code hash} has the following properties:\n   *\n   * <ul>\n   *   <li>It is <i>consistent</i>: for any reference {@code x}, multiple invocations of {@code\n   *       hash(x}} consistently return the same value provided {@code x} remains unchanged\n   *       according to the definition of the equivalence. The hash need not remain consistent from\n   *       one execution of an application to another execution of the same application.\n   *   <li>It is <i>distributable across equivalence</i>: for any references {@code x} and {@code\n   *       y}, if {@code equivalent(x, y)}, then {@code hash(x) == hash(y)}. It is <i>not</i>\n   *       necessary that the hash be distributable across <i>inequivalence</i>. If {@code\n   *       equivalence(x, y)} is false, {@code hash(x) == hash(y)} may still be true.\n   *   <li>{@code hash(null)} is {@code 0}.\n   * </ul>\n   */\n  public final int hash(@NullableDecl T t) {\n    if (t == null) {\n      return 0;\n    }\n    return doHash(t);\n  }\n  /**\n   * Implemented by the user to return a hash code for {@code t}, subject to the requirements\n   * specified in {@link #hash}.\n   *\n   * <p>This method should not be called except by {@link #hash}. When {@link #hash} calls this\n   * method, {@code t} is guaranteed to be non-null.\n   *\n   * @since 10.0 (previously, subclasses would override hash())\n   */\n  @ForOverride\n  protected abstract int doHash(T t);\n  /**\n   * Returns a new equivalence relation for {@code F} which evaluates equivalence by first applying\n   * {@code function} to the argument, then evaluating using {@code this}. That is, for any pair of\n   * non-null objects {@code x} and {@code y}, {@code equivalence.onResultOf(function).equivalent(a,\n   * b)} is true if and only if {@code equivalence.equivalent(function.apply(a), function.apply(b))}\n   * is true.\n   *\n   * <p>For example:\n   *\n   * <pre>{@code\n   * Equivalence<Person> SAME_AGE = Equivalence.equals().onResultOf(GET_PERSON_AGE);\n   * }</pre>\n   *\n   * <p>{@code function} will never be invoked with a null value.\n   *\n   * <p>Note that {@code function} must be consistent according to {@code this} equivalence\n   * relation. That is, invoking {@link Function#apply} multiple times for a given value must return\n   * equivalent results. For example, {@code\n   * Equivalence.identity().onResultOf(Functions.toStringFunction())} is broken because it's not\n   * guaranteed that {@link Object#toString}) always returns the same string instance.\n   *\n   * @since 10.0\n   */\n  public final <F> Equivalence<F> onResultOf(Function<F, ? extends T> function) {\n    return new FunctionalEquivalence<>(function, this);\n  }\n  /**\n   * Returns a wrapper of {@code reference} that implements {@link Wrapper#equals(Object)\n   * Object.equals()} such that {@code wrap(a).equals(wrap(b))} if and only if {@code equivalent(a,\n   * b)}.\n   *\n   * @since 10.0\n   */\n  public final <S extends T> Wrapper<S> wrap(@NullableDecl S reference) {\n    return new Wrapper<S>(this, reference);\n  }\n  /**\n   * Wraps an object so that {@link #equals(Object)} and {@link #hashCode()} delegate to an {@link\n   * Equivalence}.\n   *\n   * <p>For example, given an {@link Equivalence} for {@link String strings} named {@code equiv}\n   * that tests equivalence using their lengths:\n   *\n   * <pre>{@code\n   * equiv.wrap(\"a\").equals(equiv.wrap(\"b\")) // true\n   * equiv.wrap(\"a\").equals(equiv.wrap(\"hello\")) // false\n   * }</pre>\n   *\n   * <p>Note in particular that an equivalence wrapper is never equal to the object it wraps.\n   *\n   * <pre>{@code\n   * equiv.wrap(obj).equals(obj) // always false\n   * }</pre>\n   *\n   * @since 10.0\n   */\n  public static final class Wrapper<T> implements Serializable {\n    private final Equivalence<? super T> equivalence;\n    @NullableDecl private final T reference;\n    private Wrapper(Equivalence<? super T> equivalence, @NullableDecl T reference) {\n      this.equivalence = checkNotNull(equivalence);\n      this.reference = reference;\n    }\n    /** Returns the (possibly null) reference wrapped by this instance. */\n    @NullableDecl\n    public T get() {\n      return reference;\n    }\n    /**\n     * Returns {@code true} if {@link Equivalence#equivalent(Object, Object)} applied to the wrapped\n     * references is {@code true} and both wrappers use the {@link Object#equals(Object) same}\n     * equivalence.\n     */\n    @Override\n    public boolean equals(@NullableDecl Object obj) {\n      if (obj == this) {\n        return true;\n      }\n      if (obj instanceof Wrapper) {\n        Wrapper<?> that = (Wrapper<?>) obj; // note: not necessarily a Wrapper<T>\n        if (this.equivalence.equals(that.equivalence)) {\n          /*\n           * We'll accept that as sufficient \"proof\" that either equivalence should be able to\n           * handle either reference, so it's safe to circumvent compile-time type checking.\n           */\n          @SuppressWarnings(\"unchecked\")\n          Equivalence<Object> equivalence = (Equivalence<Object>) this.equivalence;\n          return equivalence.equivalent(this.reference, that.reference);\n        }\n      }\n      return false;\n    }\n    /** Returns the result of {@link Equivalence#hash(Object)} applied to the wrapped reference. */\n    @Override\n    public int hashCode() {\n      return equivalence.hash(reference);\n    }\n    /**\n     * Returns a string representation for this equivalence wrapper. The form of this string\n     * representation is not specified.\n     */\n    @Override\n    public String toString() {\n      return equivalence + \".wrap(\" + reference + \")\";\n    }\n    private static final long serialVersionUID = 0;\n  }\n  /**\n   * Returns an equivalence over iterables based on the equivalence of their elements. More\n   * specifically, two iterables are considered equivalent if they both contain the same number of\n   * elements, and each pair of corresponding elements is equivalent according to {@code this}. Null\n   * iterables are equivalent to one another.\n   *\n   * <p>Note that this method performs a similar function for equivalences as {@link\n   * com.google.common.collect.Ordering#lexicographical} does for orderings.\n   *\n   * @since 10.0\n   */\n  @GwtCompatible(serializable = true)\n  public final <S extends T> Equivalence<Iterable<S>> pairwise() {\n    // Ideally, the returned equivalence would support Iterable<? extends T>. However,\n    // the need for this is so rare that it's not worth making callers deal with the ugly wildcard.\n    return new PairwiseEquivalence<S>(this);\n  }\n  /**\n   * Returns a predicate that evaluates to true if and only if the input is equivalent to {@code\n   * target} according to this equivalence relation.\n   *\n   * @since 10.0\n   */\n  public final Predicate<T> equivalentTo(@NullableDecl T target) {\n    return new EquivalentToPredicate<T>(this, target);\n  }\n  private static final class EquivalentToPredicate<T> implements Predicate<T>, Serializable {\n    private final Equivalence<T> equivalence;\n    @NullableDecl private final T target;\n    EquivalentToPredicate(Equivalence<T> equivalence, @NullableDecl T target) {\n      this.equivalence = checkNotNull(equivalence);\n      this.target = target;\n    }\n    @Override\n    public boolean apply(@NullableDecl T input) {\n      return equivalence.equivalent(input, target);\n    }\n<fim_suffix>    @Override\n    public boolean equals(@NullableDecl Object obj) {\n      if (this == obj) {\n        return true;\n      }\n      if (obj instanceof EquivalentToPredicate) {\n        EquivalentToPredicate<?> that = (EquivalentToPredicate<?>) obj;\n        return equivalence.equals(that.equivalence) && Objects.equal(target, that.target);\n      }\n      return false;\n    }<fim_middle>// function below has no smell\n"}