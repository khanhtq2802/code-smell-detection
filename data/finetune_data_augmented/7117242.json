{"text": "<fim_prefix> *           <td style=\"vertical-align: top;\"></td>\n *           <td style=\"vertical-align: top;\">zero or one instance of <code>a</code><br>\n *           </td>\n *         </tr>\n *         <tr>\n *           <td style=\"white-space: nowrap; vertical-align: top;\"><code>a*</code></td>\n *           <td style=\"vertical-align: top;\"></td>\n *           <td style=\"vertical-align: top;\">one or more instances of <code>a</code><br>\n *           </td>\n *         </tr>\n *         <tr>\n *           <td style=\"white-space: nowrap; vertical-align: top;\"><code>a | b</code></td>\n *           <td style=\"vertical-align: top;\"></td>\n *           <td style=\"vertical-align: top;\">either <code>a</code> or <code>b</code><br>\n *           </td>\n *         </tr>\n *         <tr>\n *           <td style=\"white-space: nowrap; vertical-align: top;\"><code>'a'</code></td>\n *           <td style=\"vertical-align: top;\"></td>\n *           <td style=\"vertical-align: top;\">the literal string between the quotes </td>\n *         </tr>\n *       </table>\n *       </td>\n *     </tr>\n *   </table>\n * </blockquote>\n * <p>To iterate over contents of UnicodeSet, the following are available:\n * <ul><li>{@link #ranges()} to iterate through the ranges</li>\n * <li>{@link #strings()} to iterate through the strings</li>\n * <li>{@link #iterator()} to iterate through the entire contents in a single loop.\n * That method is, however, not particularly efficient, since it \"boxes\" each code point into a String.\n * </ul>\n * All of the above can be used in <b>for</b> loops.\n * The {@link android.icu.text.UnicodeSetIterator UnicodeSetIterator} can also be used, but not in <b>for</b> loops.\n * <p>To replace, count elements, or delete spans, see {@link android.icu.text.UnicodeSetSpanner UnicodeSetSpanner}.\n *\n * @author Alan Liu\n * @see UnicodeSetIterator\n * @see UnicodeSetSpanner\n */\npublic class UnicodeSet extends UnicodeFilter implements Iterable<String>, Comparable<UnicodeSet>, Freezable<UnicodeSet> {\n    /**\n     * Constant for the empty set.\n     */\n    public static final UnicodeSet EMPTY = new UnicodeSet().freeze();\n    /**\n     * Constant for the set of all code points. (Since UnicodeSets can include strings, does not include everything that a UnicodeSet can.)\n     */\n    public static final UnicodeSet ALL_CODE_POINTS = new UnicodeSet(0, 0x10FFFF).freeze();\n    private static XSymbolTable XSYMBOL_TABLE = null; // for overriding the the function processing\n    private static final int LOW = 0x000000; // LOW <= all valid values. ZERO for codepoints\n    private static final int HIGH = 0x110000; // HIGH > all valid values. 10000 for code units.\n    // 110000 for codepoints\n    /**\n     * Minimum value that can be stored in a UnicodeSet.\n     */\n    public static final int MIN_VALUE = LOW;\n    /**\n     * Maximum value that can be stored in a UnicodeSet.\n     */\n    public static final int MAX_VALUE = HIGH - 1;\n    private int len;      // length used; list may be longer to minimize reallocs\n    private int[] list;   // MUST be terminated with HIGH\n    private int[] rangeList; // internal buffer\n    private int[] buffer; // internal buffer\n    // NOTE: normally the field should be of type SortedSet; but that is missing a public clone!!\n    // is not private so that UnicodeSetIterator can get access\n    TreeSet<String> strings = new TreeSet<String>();\n    /**\n     * The pattern representation of this set.  This may not be the\n     * most economical pattern.  It is the pattern supplied to\n     * applyPattern(), with variables substituted and whitespace\n     * removed.  For sets constructed without applyPattern(), or\n     * modified using the non-pattern API, this string will be null,\n     * indicating that toPattern() must generate a pattern\n     * representation from the inversion list.\n     */\n    private String pat = null;\n    private static final int START_EXTRA = 16;         // initial storage. Must be >= 0\n    private static final int GROW_EXTRA = START_EXTRA; // extra amount for growth. Must be >= 0\n    // Special property set IDs\n    private static final String ANY_ID   = \"ANY\";   // [\\u0000-\\U0010FFFF]\n    private static final String ASCII_ID = \"ASCII\"; // [\\u0000-\\u007F]\n    private static final String ASSIGNED = \"Assigned\"; // [:^Cn:]\n    /**\n     * A set of all characters _except_ the second through last characters of\n     * certain ranges.  These ranges are ranges of characters whose\n     * properties are all exactly alike, e.g. CJK Ideographs from\n     * U+4E00 to U+9FA5.\n     */\n    private static UnicodeSet INCLUSIONS[] = null;\n    private volatile BMPSet bmpSet; // The set is frozen if bmpSet or stringSpan is not null.\n    private volatile UnicodeSetStringSpan stringSpan;\n    //----------------------------------------------------------------\n    // Public API\n    //----------------------------------------------------------------\n    /**\n     * Constructs an empty set.\n     */\n    public UnicodeSet() {\n        list = new int[1 + START_EXTRA];\n        list[len++] = HIGH;\n    }\n    /**\n     * Constructs a copy of an existing set.\n     */\n    public UnicodeSet(UnicodeSet other) {\n        set(other);\n    }\n    /**\n     * Constructs a set containing the given range. If <code>end &gt;\n     * start</code> then an empty set is created.\n     *\n     * @param start first character, inclusive, of range\n     * @param end last character, inclusive, of range\n     */\n    public UnicodeSet(int start, int end) {\n        this();\n        complement(start, end);\n    }\n    /**\n     * Quickly constructs a set from a set of ranges &lt;s0, e0, s1, e1, s2, e2, ..., sn, en&gt;.\n     * There must be an even number of integers, and they must be all greater than zero,\n     * all less than or equal to Character.MAX_CODE_POINT.\n     * In each pair (..., si, ei, ...) it must be true that si &lt;= ei\n     * Between adjacent pairs (...ei, sj...), it must be true that ei+1 &lt; sj\n     * @param pairs pairs of character representing ranges\n     */\n<fim_suffix>    public UnicodeSet(int... pairs) {\n        if ((pairs.length & 1) != 0) {\n            throw new IllegalArgumentException(\"Must have even number of integers\");\n        }\n        list = new int[pairs.length + 1]; // don't allocate extra space, because it is likely that this is a fixed set.\n        len = list.length;\n        int last = -1; // used to ensure that the results are monotonically increasing.\n        int i = 0;\n        while (i < pairs.length) {\n            // start of pair\n            int start = pairs[i];\n            if (last >= start) {\n                throw new IllegalArgumentException(\"Must be monotonically increasing.\");\n            }\n            list[i++] = last = start;\n            // end of pair\n            int end = pairs[i] + 1;\n            if (last >= end) {\n                throw new IllegalArgumentException(\"Must be monotonically increasing.\");\n            }\n            list[i++] = last = end;\n        }\n        list[i] = HIGH; // terminate\n    }<fim_middle>// function below has no smell\n"}