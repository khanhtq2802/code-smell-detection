{"text": "<fim_prefix>                 * someone is already using without a compelling reason.\n                 * Additionally the primary case where it is known\n                 * this behaviour is important is in certain composite\n                 * fonts, and since all the components of a given\n                 * composite are usually initialised together this\n                 * is unlikely. For this to be a problem, there would\n                 * have to be a case where two different composites used\n                 * different versions of the same-named font, and they\n                 * were initialised and used at separate times.\n                 * In that case we continue on and allow the new font to\n                 * be installed, but replaceFont will continue to allow\n                 * the original font to be used in Composite fonts.\n                 */\n                if (oldFont.mapper != null && rank > Font2D.FONT_CONFIG_RANK) {\n                    return oldFont;\n                }\n                /* Normally we require a higher rank to replace a font,\n                 * but as a special case, if the two fonts are the same rank,\n                 * and are instances of TrueTypeFont we want the\n                 * more complete (larger) one.\n                 */\n                if (oldFont.getRank() == rank) {\n                    if (oldFont instanceof TrueTypeFont &&\n                        newFont instanceof TrueTypeFont) {\n                        TrueTypeFont oldTTFont = (TrueTypeFont)oldFont;\n                        TrueTypeFont newTTFont = (TrueTypeFont)newFont;\n                        if (oldTTFont.fileSize >= newTTFont.fileSize) {\n                            return oldFont;\n                        }\n                    } else {\n                        return oldFont;\n                    }\n                }\n                /* Don't replace ever JRE fonts.\n                 * This test is in case a font configuration references\n                 * a Lucida font, which has been mapped to a Lucida\n                 * from the host O/S. The assumption here is that any\n                 * such font configuration file is probably incorrect, or\n                 * the host O/S version is for the use of AWT.\n                 * In other words if we reach here, there's a possible\n                 * problem with our choice of font configuration fonts.\n                 */\n                if (oldFont.platName.startsWith(jreFontDirName)) {\n                    if (FontUtilities.isLogging()) {\n                        FontUtilities.getLogger()\n                              .warning(\"Unexpected attempt to replace a JRE \" +\n                                       \" font \" + fontName + \" from \" +\n                                        oldFont.platName +\n                                       \" with \" + newFont.platName);\n                    }\n                    return oldFont;\n                }\n                if (FontUtilities.isLogging()) {\n                    FontUtilities.getLogger()\n                          .info(\"Replace in Family \" + familyName +\n                                \",Font \" + fontName + \" new rank=\"+rank +\n                                \" from \" + oldFont.platName +\n                                \" with \" + newFont.platName);\n                }\n                replaceFont(oldFont, newFont);\n                physicalFonts.put(fontName, newFont);\n                fullNameToFont.put(fontName.toLowerCase(Locale.ENGLISH),\n                                   newFont);\n                FontFamily family = FontFamily.getFamily(familyName);\n                if (family == null) {\n                    family = new FontFamily(familyName, false, rank);\n                    family.setFont(newFont, newFont.style);\n                } else {\n                    family.setFont(newFont, newFont.style);\n                }\n                return newFont;\n            } else {\n                return oldFont;\n            }\n        }\n    }\n    public Font2D[] getRegisteredFonts() {\n        PhysicalFont[] physFonts = getPhysicalFonts();\n        int mcf = maxCompFont; /* for MT-safety */\n        Font2D[] regFonts = new Font2D[physFonts.length+mcf];\n        System.arraycopy(compFonts, 0, regFonts, 0, mcf);\n        System.arraycopy(physFonts, 0, regFonts, mcf, physFonts.length);\n        return regFonts;\n    }\n    protected PhysicalFont[] getPhysicalFonts() {\n        return physicalFonts.values().toArray(new PhysicalFont[0]);\n    }\n    /* The class FontRegistrationInfo is used when a client says not\n     * to register a font immediately. This mechanism is used to defer\n     * initialisation of all the components of composite fonts at JRE\n     * start-up. The CompositeFont class is \"aware\" of this and when it\n     * is first used it asks for the registration of its components.\n     * Also in the event that any physical font is requested the\n     * deferred fonts are initialised before triggering a search of the\n     * system.\n     * Two maps are used. One to track the deferred fonts. The\n     * other to track the fonts that have been initialised through this\n     * mechanism.\n     */\n    private static final class FontRegistrationInfo {\n        String fontFilePath;\n        String[] nativeNames;\n        int fontFormat;\n        boolean javaRasterizer;\n        int fontRank;\n        FontRegistrationInfo(String fontPath, String[] names, int format,\n                             boolean useJavaRasterizer, int rank) {\n            this.fontFilePath = fontPath;\n            this.nativeNames = names;\n            this.fontFormat = format;\n            this.javaRasterizer = useJavaRasterizer;\n            this.fontRank = rank;\n        }\n    }\n    private final ConcurrentHashMap<String, FontRegistrationInfo>\n        deferredFontFiles =\n        new ConcurrentHashMap<String, FontRegistrationInfo>();\n    private final ConcurrentHashMap<String, Font2DHandle>\n        initialisedFonts = new ConcurrentHashMap<String, Font2DHandle>();\n    /* Remind: possibly enhance initialiseDeferredFonts() to be\n     * optionally given a name and a style and it could stop when it\n     * finds that font - but this would be a problem if two of the\n     * fonts reference the same font face name (cf the Solaris\n     * euro fonts).\n     */\n    protected synchronized void initialiseDeferredFonts() {\n        for (String fileName : deferredFontFiles.keySet()) {\n            initialiseDeferredFont(fileName);\n        }\n    }\n    protected synchronized void registerDeferredJREFonts(String jreDir) {\n        for (FontRegistrationInfo info : deferredFontFiles.values()) {\n            if (info.fontFilePath != null &&\n                info.fontFilePath.startsWith(jreDir)) {\n                initialiseDeferredFont(info.fontFilePath);\n            }\n        }\n    }\n    public boolean isDeferredFont(String fileName) {\n        return deferredFontFiles.containsKey(fileName);\n    }\n    PhysicalFont findJREDeferredFont(String name, int style) {\n        /* Iterate over the deferred font files looking for any in the\n         * jre directory that we didn't recognise, open each of these.\n         * In almost all installations this will quickly fall through\n         * because jreOtherFontFiles will be empty.\n         * noOtherJREFontFiles is used so we can skip this block as soon\n         * as its determined that it's not needed - almost always after the\n         * very first time through.\n         */\n        if (noOtherJREFontFiles) {\n            return null;\n        }\n        synchronized (jreFontDirName) {\n            if (jreOtherFontFiles == null) {\n                HashSet<String> otherFontFiles = new HashSet<String>();\n                for (String deferredFile : deferredFontFiles.keySet()) {\n                    File file = new File(deferredFile);\n                    String dir = file.getParent();\n                    String fname = file.getName();\n                    /* skip names which aren't absolute, aren't in the JRE\n                     * directory, or are known Lucida fonts.\n                     */\n                    if (dir == null || !dir.equals(jreFontDirName)) {\n                        continue;\n                    }\n                    otherFontFiles.add(deferredFile);\n                }\n                jreOtherFontFiles = otherFontFiles.toArray(STR_ARRAY);\n                if (jreOtherFontFiles.length == 0) {\n                    noOtherJREFontFiles = true;\n                }\n            }\n            for (int i=0; i<jreOtherFontFiles.length;i++) {\n                String fileName = jreOtherFontFiles[i];\n                if (fileName == null) {\n                    continue;\n                }\n                jreOtherFontFiles[i] = null;\n                PhysicalFont physicalFont = initialiseDeferredFont(fileName);\n                if (physicalFont != null &&\n                    (physicalFont.getFontName(null).equalsIgnoreCase(name) ||\n                     physicalFont.getFamilyName(null).equalsIgnoreCase(name))\n                    && physicalFont.style == style) {\n                    return physicalFont;\n                }\n            }\n        }\n        return null;\n    }\n    private PhysicalFont findOtherDeferredFont(String name, int style) {\n        for (String fileName : deferredFontFiles.keySet()) {\n            PhysicalFont physicalFont = initialiseDeferredFont(fileName);\n            if (physicalFont != null &&\n                (physicalFont.getFontName(null).equalsIgnoreCase(name) ||\n                physicalFont.getFamilyName(null).equalsIgnoreCase(name)) &&\n                physicalFont.style == style) {\n                return physicalFont;\n            }\n        }\n        return null;\n    }\n<fim_suffix>    private PhysicalFont findDeferredFont(String name, int style) {\n        PhysicalFont physicalFont = findJREDeferredFont(name, style);\n        if (physicalFont != null) {\n            return physicalFont;\n        } else {\n            return findOtherDeferredFont(name, style);\n        }\n    }<fim_middle>// function below has no smell\n"}