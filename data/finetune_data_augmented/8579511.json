{"text": "<fim_prefix> * Float.MAX_VALUE &lt; Float.POSITIVE_INFINITY &lt; Float.NaN\n * </p>\n * <p>\n * Floating point numbers are encoded as specified in IEEE 754. A 32-bit\n * single precision float consists of a sign bit, 8-bit unsigned exponent\n * encoded in offset-127 notation, and a 23-bit significand. The format is\n * described further in the <a\n * href=\"http://en.wikipedia.org/wiki/Single_precision\"> Single Precision\n * Floating Point Wikipedia page</a>\n * </p>\n * <p>\n * The value of a normal float is -1 <sup>sign bit</sup> &times;\n * 2<sup>exponent - 127</sup> &times; 1.significand\n * </p>\n * <p>\n * The IEE754 floating point format already preserves sort ordering for\n * positive floating point numbers when the raw bytes are compared in most\n * significant byte order. This is discussed further at <a href=\n * \"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\">\n * http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm</a>\n * </p>\n * <p>\n * Thus, we need only ensure that negative numbers sort in the the exact\n * opposite order as positive numbers (so that say, negative infinity is less\n * than negative 1), and that all negative numbers compare less than any\n * positive number. To accomplish this, we invert the sign bit of all floating\n * point numbers, and we also invert the exponent and significand bits if the\n * floating point number was negative.\n * </p>\n * <p>\n * More specifically, we first store the floating point bits into a 32-bit int\n * {@code j} using {@link Float#floatToIntBits}. This method collapses\n * all NaNs into a single, canonical NaN value but otherwise leaves the bits\n * unchanged. We then compute\n * </p>\n *\n * <pre>\n * j &circ;= (j &gt;&gt; (Integer.SIZE - 1)) | Integer.MIN_SIZE\n * </pre>\n * <p>\n * which inverts the sign bit and XOR's all other bits with the sign bit\n * itself. Comparing the raw bytes of {@code j} in most significant byte\n * order is equivalent to performing a single precision floating point\n * comparison on the underlying bits (ignoring NaN comparisons, as NaNs don't\n * compare equal to anything when performing floating point comparisons).\n * </p>\n * <p>\n * The resulting integer is then converted into a byte array by serializing\n * the integer one byte at a time in most significant byte order. The\n * serialized integer is prefixed by a single header byte. All serialized\n * values are 5 bytes in length.\n * </p>\n * <p>\n * {@code OrderedBytes} encodings are heavily influenced by the\n * <a href=\"http://sqlite.org/src4/doc/trunk/www/key_encoding.wiki\">SQLite4 Key\n * Encoding</a>. Slight deviations are make in the interest of order\n * correctness and user extensibility. Fixed-width {@code Long} and\n * {@link Double} encodings are based on implementations from the now defunct\n * Orderly library.\n * </p>\n */\n@InterfaceAudience.Public\npublic class OrderedBytes {\n  /*\n   * These constants define header bytes used to identify encoded values. Note\n   * that the values here are not exhaustive as the Numeric format encodes\n   * portions of its value within the header byte. The values listed here are\n   * directly applied to persisted data -- DO NOT modify the values specified\n   * here. Instead, gaps are placed intentionally between values so that new\n   * implementations can be inserted into the total ordering enforced here.\n   */\n  private static final byte NULL = 0x05;\n  // room for 1 expansion type\n  private static final byte NEG_INF = 0x07;\n  private static final byte NEG_LARGE = 0x08;\n  private static final byte NEG_MED_MIN = 0x09;\n  private static final byte NEG_MED_MAX = 0x13;\n  private static final byte NEG_SMALL = 0x14;\n  private static final byte ZERO = 0x15;\n  private static final byte POS_SMALL = 0x16;\n  private static final byte POS_MED_MIN = 0x17;\n  private static final byte POS_MED_MAX = 0x21;\n  private static final byte POS_LARGE = 0x22;\n  private static final byte POS_INF = 0x23;\n  // room for 2 expansion type\n  private static final byte NAN = 0x26;\n  // room for 2 expansion types\n  private static final byte FIXED_INT8 = 0x29;\n  private static final byte FIXED_INT16 = 0x2a;\n  private static final byte FIXED_INT32 = 0x2b;\n  private static final byte FIXED_INT64 = 0x2c;\n  // room for 3 expansion types\n  private static final byte FIXED_FLOAT32 = 0x30;\n  private static final byte FIXED_FLOAT64 = 0x31;\n  // room for 2 expansion type\n  private static final byte TEXT = 0x34;\n  // room for 2 expansion type\n  private static final byte BLOB_VAR = 0x37;\n  private static final byte BLOB_COPY = 0x38;\n  /*\n   * The following constant values are used by encoding implementations\n   */\n  public static final Charset UTF8 = Charset.forName(\"UTF-8\");\n  private static final byte TERM = 0x00;\n  private static final BigDecimal E8 = BigDecimal.valueOf(1e8);\n  private static final BigDecimal E32 = BigDecimal.valueOf(1e32);\n  private static final BigDecimal EN2 = BigDecimal.valueOf(1e-2);\n  private static final BigDecimal EN10 = BigDecimal.valueOf(1e-10);\n  /**\n   * Max precision guaranteed to fit into a {@code long}.\n   */\n  public static final int MAX_PRECISION = 31;\n  /**\n   * The context used to normalize {@link BigDecimal} values.\n   */\n  public static final MathContext DEFAULT_MATH_CONTEXT =\n      new MathContext(MAX_PRECISION, RoundingMode.HALF_UP);\n  /**\n   * Creates the standard exception when the encoded header byte is unexpected for the decoding\n   * context.\n   * @param header value used in error message.\n   */\n  private static IllegalArgumentException unexpectedHeader(byte header) {\n    throw new IllegalArgumentException(\"unexpected value in first byte: 0x\"\n        + Long.toHexString(header));\n  }\n  /**\n   * Perform unsigned comparison between two long values. Conforms to the same interface as\n   * {@link org.apache.hadoop.hbase.CellComparator}.\n   */\n  private static int unsignedCmp(long x1, long x2) {\n    int cmp;\n    if ((cmp = (x1 < x2 ? -1 : (x1 == x2 ? 0 : 1))) == 0) return 0;\n    // invert the result when either value is negative\n    if ((x1 < 0) != (x2 < 0)) return -cmp;\n    return cmp;\n  }\n  /**\n   * Write a 32-bit unsigned integer to {@code dst} as 4 big-endian bytes.\n   * @return number of bytes written.\n   */\n<fim_suffix>  private static int putUint32(PositionedByteRange dst, int val) {\n    dst.put((byte) (val >>> 24))\n       .put((byte) (val >>> 16))\n       .put((byte) (val >>> 8))\n       .put((byte) val);\n    return 4;\n  }<fim_middle>// function below has no smell\n"}