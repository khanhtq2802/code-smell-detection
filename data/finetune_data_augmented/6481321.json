{"text": "<fim_prefix>\t * org.eclipse.paho.client.mqttv3.IMqttActionListener)\n\t */\n\tpublic IMqttDeliveryToken publish(String topic, MqttMessage message, Object userContext,\n\t\t\tIMqttActionListener callback) throws MqttException, MqttPersistenceException {\n\t\tfinal String methodName = \"publish\";\n\t\t// @TRACE 111=< topic={0} message={1}userContext={1} callback={2}\n\t\tlog.fine(CLASS_NAME, methodName, \"111\", new Object[] { topic, userContext, callback });\n\t\t// Checks if a topic is valid when publishing a message.\n\t\tMqttTopic.validate(topic, false/* wildcards NOT allowed */);\n\t\tMqttDeliveryToken token = new MqttDeliveryToken(getClientId());\n\t\ttoken.setActionCallback(callback);\n\t\ttoken.setUserContext(userContext);\n\t\ttoken.setMessage(message);\n\t\ttoken.internalTok.setTopics(new String[] { topic });\n\t\tMqttPublish pubMsg = new MqttPublish(topic, message);\n\t\tcomms.sendNoWait(pubMsg, token);\n\t\t// @TRACE 112=<\n\t\tlog.fine(CLASS_NAME, methodName, \"112\");\n\t\treturn token;\n\t}\n\t/**\n\t * User triggered attempt to reconnect\n\t * \n\t * @throws MqttException\n\t *             if there is an issue with reconnecting\n\t */\n\tpublic void reconnect() throws MqttException {\n\t\tfinal String methodName = \"reconnect\";\n\t\t// @Trace 500=Attempting to reconnect client: {0}\n\t\tlog.fine(CLASS_NAME, methodName, \"500\", new Object[] { this.clientId });\n\t\t// Some checks to make sure that we're not attempting to reconnect an\n\t\t// already connected client\n\t\tif (comms.isConnected()) {\n\t\t\tthrow ExceptionHelper.createMqttException(MqttException.REASON_CODE_CLIENT_CONNECTED);\n\t\t}\n\t\tif (comms.isConnecting()) {\n\t\t\tthrow new MqttException(MqttException.REASON_CODE_CONNECT_IN_PROGRESS);\n\t\t}\n\t\tif (comms.isDisconnecting()) {\n\t\t\tthrow new MqttException(MqttException.REASON_CODE_CLIENT_DISCONNECTING);\n\t\t}\n\t\tif (comms.isClosed()) {\n\t\t\tthrow new MqttException(MqttException.REASON_CODE_CLIENT_CLOSED);\n\t\t}\n\t\t// We don't want to spam the server\n\t\tstopReconnectCycle();\n\t\tattemptReconnect();\n\t}\n\t/**\n\t * Attempts to reconnect the client to the server. If successful it will\n\t * make sure that there are no further reconnects scheduled. However if the\n\t * connect fails, the delay will double up to 128 seconds and will\n\t * re-schedule the reconnect for after the delay.\n\t *\n\t * Any thrown exceptions are logged but not acted upon as it is assumed that\n\t * they are being thrown due to the server being offline and so reconnect\n\t * attempts will continue.\n\t */\n\tprivate void attemptReconnect() {\n\t\tfinal String methodName = \"attemptReconnect\";\n\t\t// @Trace 500=Attempting to reconnect client: {0}\n\t\tlog.fine(CLASS_NAME, methodName, \"500\", new Object[] { this.clientId });\n\t\ttry {\n\t\t\tconnect(this.connOpts, this.userContext, new MqttReconnectActionListener(methodName));\n\t\t} catch (MqttSecurityException ex) {\n\t\t\t// @TRACE 804=exception\n\t\t\tlog.fine(CLASS_NAME, methodName, \"804\", null, ex);\n\t\t} catch (MqttException ex) {\n\t\t\t// @TRACE 804=exception\n\t\t\tlog.fine(CLASS_NAME, methodName, \"804\", null, ex);\n\t\t}\n\t}\n\tprivate void startReconnectCycle() {\n\t\tString methodName = \"startReconnectCycle\";\n\t\t// @Trace 503=Start reconnect timer for client: {0}, delay: {1}\n\t\tlog.fine(CLASS_NAME, methodName, \"503\", new Object[] { this.clientId, Long.valueOf(reconnectDelay) });\n\t\treconnectTimer = new Timer(\"MQTT Reconnect: \" + clientId);\n\t\treconnectTimer.schedule(new ReconnectTask(), reconnectDelay);\n\t}\n\tprivate void stopReconnectCycle() {\n\t\tString methodName = \"stopReconnectCycle\";\n\t\t// @Trace 504=Stop reconnect timer for client: {0}\n\t\tlog.fine(CLASS_NAME, methodName, \"504\", new Object[] { this.clientId });\n\t\tsynchronized (clientLock) {\n\t\t\tif (this.connOpts.isAutomaticReconnect()) {\n\t\t\t\tif (reconnectTimer != null) {\n\t\t\t\t\treconnectTimer.cancel();\n\t\t\t\t\treconnectTimer = null;\n\t\t\t\t}\n\t\t\t\treconnectDelay = 1000; // Reset Delay Timer\n\t\t\t}\n\t\t}\n\t}\n\tprivate class ReconnectTask extends TimerTask {\n\t\tprivate static final String methodName = \"ReconnectTask.run\";\n\t\tpublic void run() {\n\t\t\t// @Trace 506=Triggering Automatic Reconnect attempt.\n\t\t\tlog.fine(CLASS_NAME, methodName, \"506\");\n\t\t\tattemptReconnect();\n\t\t}\n\t}\n\tclass MqttReconnectCallback implements MqttCallbackExtended {\n\t\tfinal boolean automaticReconnect;\n\t\tMqttReconnectCallback(boolean isAutomaticReconnect) {\n\t\t\tautomaticReconnect = isAutomaticReconnect;\n\t\t}\n\t\tpublic void connectionLost(Throwable cause) {\n\t\t\tif (automaticReconnect) {\n\t\t\t\t// Automatic reconnect is set so make sure comms is in resting\n\t\t\t\t// state\n\t\t\t\tcomms.setRestingState(true);\n\t\t\t\treconnecting = true;\n\t\t\t\tstartReconnectCycle();\n\t\t\t}\n\t\t}\n\t\tpublic void messageArrived(String topic, MqttMessage message) throws Exception {\n\t\t}\n\t\tpublic void deliveryComplete(IMqttDeliveryToken token) {\n\t\t}\n\t\tpublic void connectComplete(boolean reconnect, String serverURI) {\n\t\t}\n\t}\n<fim_suffix>\tclass MqttReconnectActionListener implements IMqttActionListener {\n\t\tfinal String methodName;\n\t\tMqttReconnectActionListener(String methodName) {\n\t\t\tthis.methodName = methodName;\n\t\t}\n\t\tpublic void onSuccess(IMqttToken asyncActionToken) {\n\t\t\t// @Trace 501=Automatic Reconnect Successful: {0}\n\t\t\tlog.fine(CLASS_NAME, methodName, \"501\", new Object[] { asyncActionToken.getClient().getClientId() });\n\t\t\tcomms.setRestingState(false);\n\t\t\tstopReconnectCycle();\n\t\t}\n\t\tpublic void onFailure(IMqttToken asyncActionToken, Throwable exception) {\n\t\t\t// @Trace 502=Automatic Reconnect failed, rescheduling: {0}\n\t\t\tlog.fine(CLASS_NAME, methodName, \"502\", new Object[] { asyncActionToken.getClient().getClientId() });\n\t\t\tif (reconnectDelay < connOpts.getMaxReconnectDelay()) {\n\t\t\t\treconnectDelay = reconnectDelay * 2;\n\t\t\t}\n\t\t\trescheduleReconnectCycle(reconnectDelay);\n\t\t}\n\t\tprivate void rescheduleReconnectCycle(int delay) {\n\t\t\tString reschedulemethodName = methodName + \":rescheduleReconnectCycle\";\n\t\t\t// @Trace 505=Rescheduling reconnect timer for client: {0}, delay:\n\t\t\t// {1}\n\t\t\tlog.fine(CLASS_NAME, reschedulemethodName, \"505\",\n\t\t\t\t\tnew Object[] { MqttAsyncClient.this.clientId, String.valueOf(reconnectDelay) });\n\t\t\tsynchronized (clientLock) {\n\t\t\t\tif (MqttAsyncClient.this.connOpts.isAutomaticReconnect()) {\n\t\t\t\t\tif (reconnectTimer != null) {\n\t\t\t\t\t\treconnectTimer.schedule(new ReconnectTask(), delay);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// The previous reconnect timer was cancelled\n\t\t\t\t\t\treconnectDelay = delay;\n\t\t\t\t\t\tstartReconnectCycle();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}<fim_middle>// class below has no smell\n"}