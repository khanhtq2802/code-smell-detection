{"text": "<fim_prefix>        }\n        public void setEnabled(final boolean b) {\n            setDisabled(!b);\n        }\n        public String getBind() {\n            return options.get(name + \".bind\", \"\");\n        }\n        public void setBind(final String bind) {\n            properties.put(name + \".bind\", bind);\n        }\n        public int getThreads() {\n            return options.get(name + \".threads\", -1);\n        }\n        public void setThreads(final int threads) {\n            properties.put(name + \".threads\", threads + \"\");\n        }\n        public ServerService set(final String name, final String value) {\n            properties.put(this.name + \".\" + name, value);\n            return this;\n        }\n        public Object get(final String name) {\n            return properties.get(this.name + \".\" + name);\n        }\n        public ServerService threads(final int threads) {\n            setThreads(threads);\n            return this;\n        }\n        public ServerService port(final int port) {\n            setPort(port);\n            return this;\n        }\n        public ServerService enable() {\n            setEnabled(true);\n            return this;\n        }\n        public ServerService disable() {\n            setDisabled(true);\n            return this;\n        }\n        public ServerService bind(final String host) {\n            setBind(host);\n            return this;\n        }\n    }\n    public File getHome() {\n        return home;\n    }\n    public File getBase() {\n        return base;\n    }\n    public boolean isDebug() {\n        return debug;\n    }\n    public void setDebug(final boolean debug) {\n        this.debug = debug;\n    }\n    public int getDebugPort() {\n        return debugPort;\n    }\n    public void setDebugPort(final int debugPort) {\n        this.debugPort = debugPort;\n    }\n    public boolean isProfile() {\n        return profile;\n    }\n    public void setProfile(final boolean profile) {\n        this.profile = profile;\n    }\n    public Process getProcess() {\n        return process;\n    }\n    public void setProcess(final Process process) {\n        this.process = process;\n    }\n    public boolean isVerbose() {\n        return verbose;\n    }\n    public void setVerbose(final boolean verbose) {\n        this.verbose = verbose;\n    }\n    public OutputStream getOut() {\n        return out;\n    }\n    public void setOut(final OutputStream out) {\n        this.out = out;\n    }\n    public void ignoreOut() {\n        setOut(new DevNull());\n    }\n    public List<String> getJvmOpts() {\n        return jvmOpts;\n    }\n    public Properties getProperties() {\n        return properties;\n    }\n    public Object setProperty(final String key, final String value) {\n        return getProperties().setProperty(key, value);\n    }\n    public void start() {\n        start(0, TimeUnit.MILLISECONDS);\n    }\n    public void start(final int timeout, final TimeUnit minutes) {\n        if (process != null) {\n            throw new ServerRunningException(home, \"Server already running\");\n        }\n        try {\n            final List<String> args = new ArrayList<String>();\n            args.add(java.getAbsolutePath());\n            args.addAll(jvmOpts);\n            final Set<Map.Entry<Object, Object>> collection = properties.entrySet();\n            args.addAll(Join.strings(collection, new SystemPropertiesCallback()));\n            if (debug) {\n                args.add(\"-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=\" + debugPort);\n            }\n            args.add(\"-jar\");\n            args.add(openejbJar.getAbsolutePath());\n            args.add(\"start\");\n            final ProcessBuilder builder = new ProcessBuilder(args);\n            builder.redirectErrorStream(true);\n            if (verbose) {\n                System.out.println(Join.join(\"\\n\", args));\n            }\n            process = builder.start();\n            if (timeout > 0) {\n                final OutputScanner scanner = new OutputScanner(out, \"Ready!\");\n                Pipe.pipe(process.getInputStream(), scanner);\n                scanner.await(timeout, minutes);\n            } else {\n                out = System.out;\n                Pipe.pipe(process.getInputStream(), out);\n            }\n        } catch (final InterruptedException e) {\n            Thread.interrupted();\n            throw new IllegalStateException(\"Server failed to start in the expected time\");\n        } catch (final IOException e) {\n            throw new IllegalStateException(\"Server did not start correctly\", e);\n        }\n    }\n    private void edit() {\n        if (process != null) {\n            throw new ServerRunningException(home, \"Cannot change settings while server is running\");\n        }\n    }\n    public static class DevNull extends OutputStream {\n        @Override\n        public void write(final int b) throws IOException {\n        }\n    }\n    public void kill() {\n        if (process == null) {\n            return;\n        }\n        process.destroy();\n        waitForExit();\n    }\n    private void waitForExit() {\n        try {\n            process.waitFor();\n        } catch (final InterruptedException e) {\n            Thread.interrupted();\n        }\n        process = null;\n    }\n    private int command(final String... strings) {\n        return command(Arrays.asList(strings));\n    }\n    private int command(final List<String> strings) {\n        if (process == null) {\n            throw new ServerNotRunningException(home);\n        }\n        try {\n            final List<String> args = new ArrayList<String>();\n            args.add(java.getAbsolutePath());\n            args.add(\"-jar\");\n            args.add(openejbJar.getAbsolutePath());\n            args.addAll(strings);\n            final ProcessBuilder builder = new ProcessBuilder(args);\n            final Process command = builder.start();\n            Pipe.read(command);\n            return command.waitFor();\n        } catch (final IOException e) {\n            throw new ServerException(home, Join.join(\" \", strings), e);\n        } catch (final InterruptedException e) {\n            Thread.interrupted();\n        }\n        return -1;\n    }\n    public void deploy(final String path) {\n        final int code = command(\"deploy\", getServerUrl(), path);\n        if (code != 0) {\n            throw new DeployException(home, code, path);\n        }\n    }\n    public void undeploy(final String path) {\n        final int code = command(\"undeploy\", getServerUrl(), path);\n        if (code != 0) {\n            throw new UndeployException(home, code, path);\n        }\n    }\n    public void stop() {\n        final int code = command(\"stop\");\n        if (code != 0) {\n            throw new StopException(home, code);\n        }\n        waitForExit();\n    }\n    public void killOnExit() {\n        if (kill.contains(this)) {\n            return;\n        }\n        kill.add(this);\n    }\n    // Shutdown hook for recursive delete on tmp directories\n    static final List<StandaloneServer> kill = new ArrayList<StandaloneServer>();\n    static {\n        Runtime.getRuntime().addShutdownHook(new Thread() {\n            @Override\n            public void run() {\n                for (final StandaloneServer server : kill) {\n                    try {\n                        if (server.process != null) {\n                            server.process.destroy();\n                        }\n                    } catch (final Throwable e) {\n                        //Ignore\n                    }\n                }\n            }\n        });\n    }\n    public static class ServerException extends RuntimeException {\n        private final File home;\n        public ServerException(final File home) {\n            this.home = home;\n        }\n        public ServerException(final File home, final String message) {\n            super(message);\n            this.home = home;\n        }\n        public ServerException(final File home, final String message, final Throwable cause) {\n            super(message, cause);\n            this.home = home;\n        }\n        @Override\n        public String getMessage() {\n            return super.getMessage() + String.format(\"server path `%s`\", home.getAbsolutePath());\n        }\n    }\n    public static class ServerNotRunningException extends ServerException {\n        public ServerNotRunningException(final File home) {\n            super(home);\n        }\n    }\n    public static class ServerRunningException extends ServerException {\n        public ServerRunningException(final File home) {\n            super(home);\n        }\n        public ServerRunningException(final File home, final String message) {\n            super(home, message);\n        }\n    }\n    public static class ServerCommandException extends ServerException {\n        private final int returnCode;\n        private final String[] args;\n        public ServerCommandException(final File home, final int returnCode, final String... args) {\n            super(home);\n            this.returnCode = returnCode;\n            this.args = args;\n        }\n    }\n    public static class DeployException extends ServerCommandException {\n        public DeployException(final File home, final int returnCode, final String... args) {\n            super(home, returnCode, args);\n        }\n    }\n    public static class UndeployException extends ServerCommandException {\n        public UndeployException(final File home, final int returnCode, final String... args) {\n            super(home, returnCode, args);\n        }\n    }\n<fim_suffix>    public static class StopException extends ServerCommandException {\n        public StopException(final File home, final int returnCode, final String... args) {\n            super(home, returnCode, args);\n        }\n    }<fim_middle>// class below has no smell\n"}