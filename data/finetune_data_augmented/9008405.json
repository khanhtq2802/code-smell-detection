{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.lucene.search.vectorhighlight;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.apache.lucene.search.vectorhighlight.FieldPhraseList.WeightedPhraseInfo;\n\n/**\n * A abstract implementation of {@link FragListBuilder}.\n */\n<fim_suffix>public abstract class BaseFragListBuilder implements FragListBuilder {\n  \n  public static final int MARGIN_DEFAULT = 6;\n  public static final int MIN_FRAG_CHAR_SIZE_FACTOR = 3;\n\n  final int margin;\n  final int minFragCharSize;\n\n  public BaseFragListBuilder( int margin ){\n    if( margin < 0 )\n      throw new IllegalArgumentException( \"margin(\" + margin + \") is too small. It must be 0 or higher.\" );\n\n    this.margin = margin;\n    this.minFragCharSize = Math.max( 1, margin * MIN_FRAG_CHAR_SIZE_FACTOR );\n  }\n\n  public BaseFragListBuilder(){\n    this( MARGIN_DEFAULT );\n  }\n  \n protected FieldFragList createFieldFragList( FieldPhraseList fieldPhraseList, FieldFragList fieldFragList, int fragCharSize ){\n    if( fragCharSize < minFragCharSize )\n      throw new IllegalArgumentException( \"fragCharSize(\" + fragCharSize + \") is too small. It must be \" + minFragCharSize + \" or higher.\" );\n    \n    List<WeightedPhraseInfo> wpil = new ArrayList<>();\n    IteratorQueue<WeightedPhraseInfo> queue = new IteratorQueue<>(fieldPhraseList.getPhraseList().iterator());\n    WeightedPhraseInfo phraseInfo = null;\n    int startOffset = 0;\n    while((phraseInfo = queue.top()) != null){\n      // if the phrase violates the border of previous fragment, discard it and try next phrase\n      if( phraseInfo.getStartOffset() < startOffset )  {\n        queue.removeTop();\n        continue;\n      }\n      \n      wpil.clear();\n      final int currentPhraseStartOffset = phraseInfo.getStartOffset();\n      int currentPhraseEndOffset = phraseInfo.getEndOffset();\n      int spanStart = Math.max(currentPhraseStartOffset - margin, startOffset);\n      int spanEnd = Math.max(currentPhraseEndOffset, spanStart + fragCharSize);\n      if (acceptPhrase(queue.removeTop(),  currentPhraseEndOffset - currentPhraseStartOffset, fragCharSize)) {\n        wpil.add(phraseInfo);\n      }\n      while((phraseInfo = queue.top()) != null) { // pull until we crossed the current spanEnd\n        if (phraseInfo.getEndOffset() <= spanEnd) {\n          currentPhraseEndOffset = phraseInfo.getEndOffset();\n          if (acceptPhrase(queue.removeTop(),  currentPhraseEndOffset - currentPhraseStartOffset, fragCharSize)) {\n            wpil.add(phraseInfo);\n          }\n        } else {\n          break;\n        }\n      }\n      if (wpil.isEmpty()) {\n        continue;\n      }\n      \n      final int matchLen = currentPhraseEndOffset - currentPhraseStartOffset;\n      // now recalculate the start and end position to \"center\" the result\n      final int newMargin = Math.max(0, (fragCharSize-matchLen)/2); // matchLen can be > fragCharSize prevent IAOOB here\n      spanStart = currentPhraseStartOffset - newMargin;\n      if (spanStart < startOffset) {\n        spanStart = startOffset;\n      }\n      // whatever is bigger here we grow this out\n      spanEnd = spanStart + Math.max(matchLen, fragCharSize);  \n      startOffset = spanEnd;\n      fieldFragList.add(spanStart, spanEnd, wpil);\n    }\n    return fieldFragList;\n  }\n \n  /**\n   * A predicate to decide if the given {@link WeightedPhraseInfo} should be\n   * accepted as a highlighted phrase or if it should be discarded.\n   * <p>\n   * The default implementation discards phrases that are composed of more than one term\n   * and where the matchLength exceeds the fragment character size.\n   * \n   * @param info the phrase info to accept\n   * @param matchLength the match length of the current phrase\n   * @param fragCharSize the configured fragment character size\n   * @return <code>true</code> if this phrase info should be accepted as a highligh phrase\n   */\n protected boolean acceptPhrase(WeightedPhraseInfo info, int matchLength, int fragCharSize) {\n   return info.getTermsOffsets().size() <= 1 ||  matchLength <= fragCharSize;\n }\n \n private static final class IteratorQueue<T> {\n   private final Iterator<T> iter;\n   private T top;\n   \n   public IteratorQueue(Iterator<T> iter) {\n     this.iter = iter;\n     T removeTop = removeTop();\n     assert removeTop == null;\n   }\n   \n   public T top() {\n     return top;\n   }\n   \n   public T removeTop() {\n     T currentTop = top;\n     if (iter.hasNext()) {\n       top = iter.next();\n     } else {\n       top = null;\n     }\n     return currentTop;\n   }\n   \n }\n \n}<fim_middle>// class below has no smell\n"}