{"text": "<fim_prefix>    Collection<Slice> allSlices = coll.getSlices();\n    List<SolrCmdDistributor.Node> nodes = null;\n    for (Slice aslice : allSlices) {\n      final Slice.State state = aslice.getState();\n      if (state == Slice.State.CONSTRUCTION || state == Slice.State.RECOVERY)  {\n        DocRouter.Range myRange = coll.getSlice(shardId).getRange();\n        if (myRange == null) myRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        boolean isSubset = aslice.getRange() != null && aslice.getRange().isSubsetOf(myRange);\n        if (isSubset &&\n            (docId == null // in case of deletes\n                || coll.getRouter().isTargetSlice(docId, doc, req.getParams(), aslice.getName(), coll))) {\n          Replica sliceLeader = aslice.getLeader();\n          // slice leader can be null because node/shard is created zk before leader election\n          if (sliceLeader != null && zkController.getClusterState().liveNodesContain(sliceLeader.getNodeName()))  {\n            if (nodes == null) nodes = new ArrayList<>();\n            ZkCoreNodeProps nodeProps = new ZkCoreNodeProps(sliceLeader);\n            nodes.add(new SolrCmdDistributor.StdNode(nodeProps, coll.getName(), aslice.getName()));\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n  /** For {@link org.apache.solr.common.params.CollectionParams.CollectionAction#MIGRATE} */\n  protected List<SolrCmdDistributor.Node> getNodesByRoutingRules(ClusterState cstate, DocCollection coll, String id, SolrInputDocument doc)  {\n    DocRouter router = coll.getRouter();\n    List<SolrCmdDistributor.Node> nodes = null;\n    if (router instanceof CompositeIdRouter)  {\n      CompositeIdRouter compositeIdRouter = (CompositeIdRouter) router;\n      String myShardId = cloudDesc.getShardId();\n      Slice slice = coll.getSlice(myShardId);\n      Map<String, RoutingRule> routingRules = slice.getRoutingRules();\n      if (routingRules != null) {\n        // delete by query case\n        if (id == null) {\n          for (Map.Entry<String, RoutingRule> entry : routingRules.entrySet()) {\n            String targetCollectionName = entry.getValue().getTargetCollectionName();\n            final DocCollection docCollection = cstate.getCollectionOrNull(targetCollectionName);\n            if (docCollection != null && docCollection.getActiveSlicesArr().length > 0) {\n              final Slice[] activeSlices = docCollection.getActiveSlicesArr();\n              Slice any = activeSlices[0];\n              if (nodes == null) nodes = new ArrayList<>();\n              nodes.add(new SolrCmdDistributor.StdNode(new ZkCoreNodeProps(any.getLeader())));\n            }\n          }\n          return nodes;\n        }\n        String routeKey = SolrIndexSplitter.getRouteKey(id);\n        if (routeKey != null) {\n          RoutingRule rule = routingRules.get(routeKey + \"!\");\n          if (rule != null) {\n            if (! rule.isExpired()) {\n              List<DocRouter.Range> ranges = rule.getRouteRanges();\n              if (ranges != null && !ranges.isEmpty()) {\n                int hash = compositeIdRouter.sliceHash(id, doc, null, coll);\n                for (DocRouter.Range range : ranges) {\n                  if (range.includes(hash)) {\n                    DocCollection targetColl = cstate.getCollection(rule.getTargetCollectionName());\n                    Collection<Slice> activeSlices = targetColl.getRouter().getSearchSlicesSingle(id, null, targetColl);\n                    if (activeSlices == null || activeSlices.isEmpty()) {\n                      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                          \"No active slices serving \" + id + \" found for target collection: \" + rule.getTargetCollectionName());\n                    }\n                    Replica targetLeader = targetColl.getLeader(activeSlices.iterator().next().getName());\n                    nodes = new ArrayList<>(1);\n                    nodes.add(new SolrCmdDistributor.StdNode(new ZkCoreNodeProps(targetLeader)));\n                    break;\n                  }\n                }\n              }\n            } else  {\n              ReentrantLock ruleExpiryLock = req.getCore().getRuleExpiryLock();\n              if (!ruleExpiryLock.isLocked()) {\n                try {\n                  if (ruleExpiryLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n                    log.info(\"Going to expire routing rule\");\n                    try {\n                      Map<String, Object> map = Utils.makeMap(Overseer.QUEUE_OPERATION, OverseerAction.REMOVEROUTINGRULE.toLower(),\n                          ZkStateReader.COLLECTION_PROP, collection,\n                          ZkStateReader.SHARD_ID_PROP, myShardId,\n                          \"routeKey\", routeKey + \"!\");\n                      zkController.getOverseer().offerStateUpdate(Utils.toJSON(map));\n                    } catch (KeeperException e) {\n                      log.warn(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } catch (Exception e) {\n                      log.error(\"Exception while removing routing rule for route key: \" + routeKey, e);\n                    } finally {\n                      ruleExpiryLock.unlock();\n                    }\n                  }\n                } catch (InterruptedException e) {\n                  Thread.currentThread().interrupt();\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return nodes;\n  }\n<fim_suffix>  private void doDefensiveChecks(DistribPhase phase) {\n    boolean isReplayOrPeersync = (updateCommand.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    if (isReplayOrPeersync) return;\n    String from = req.getParams().get(DISTRIB_FROM);\n    ClusterState clusterState = zkController.getClusterState();\n    DocCollection docCollection = clusterState.getCollection(collection);\n    Slice mySlice = docCollection.getSlice(cloudDesc.getShardId());\n    boolean localIsLeader = cloudDesc.isLeader();\n    if (DistribPhase.FROMLEADER == phase && localIsLeader && from != null) { // from will be null on log replay\n      String fromShard = req.getParams().get(DISTRIB_FROM_PARENT);\n      if (fromShard != null) {\n        if (mySlice.getState() == Slice.State.ACTIVE)  {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but we are in active state\");\n        }\n        // shard splitting case -- check ranges to see if we are a sub-shard\n        Slice fromSlice = docCollection.getSlice(fromShard);\n        DocRouter.Range parentRange = fromSlice.getRange();\n        if (parentRange == null) parentRange = new DocRouter.Range(Integer.MIN_VALUE, Integer.MAX_VALUE);\n        if (mySlice.getRange() != null && !mySlice.getRange().isSubsetOf(parentRange)) {\n          throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n              \"Request says it is coming from parent shard leader but parent hash range is not superset of my range\");\n        }\n      } else {\n        String fromCollection = req.getParams().get(DISTRIB_FROM_COLLECTION); // is it because of a routing rule?\n        if (fromCollection == null)  {\n          log.error(\"Request says it is coming from leader, but we are the leader: \" + req.getParamString());\n          SolrException solrExc = new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE, \"Request says it is coming from leader, but we are the leader\");\n          solrExc.setMetadata(\"cause\", \"LeaderChanged\");\n          throw solrExc;\n        }\n      }\n    }\n    int count = 0;\n    while (((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) && count < 5) {\n      count++;\n      // re-getting localIsLeader since we published to ZK first before setting localIsLeader value\n      localIsLeader = cloudDesc.isLeader();\n      try {\n        Thread.sleep(500);\n      } catch (InterruptedException e) {\n        Thread.currentThread().interrupt();\n      }\n    }\n    if ((isLeader && !localIsLeader) || (isSubShardLeader && !localIsLeader)) {\n      log.error(\"ClusterState says we are the leader, but locally we don't think so\");\n      throw new SolrException(SolrException.ErrorCode.SERVICE_UNAVAILABLE,\n          \"ClusterState says we are the leader (\" + zkController.getBaseUrl()\n              + \"/\" + req.getCore().getName() + \"), but locally we don't think so. Request came from \" + from);\n    }\n  }<fim_middle>// function below is long method\n"}