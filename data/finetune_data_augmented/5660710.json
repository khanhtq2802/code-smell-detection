{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.sis.internal.referencing.j2d;\n\nimport java.util.Arrays;\nimport java.io.Serializable;\nimport java.awt.geom.AffineTransform;\nimport org.opengis.referencing.operation.Matrix;\nimport org.apache.sis.internal.referencing.Resources;\nimport org.apache.sis.internal.referencing.ExtendedPrecisionMatrix;\nimport org.apache.sis.referencing.operation.matrix.Matrices;\nimport org.apache.sis.util.ArgumentChecks;\n\n\n/**\n * The matrix of an {@link AffineTransform}, optionally with storage for the error terms\n * used in double-double arithmetic.\n *\n * @author  Martin Desruisseaux (Geomatys)\n * @version 0.8\n * @since   0.5\n * @module\n */\n<fim_suffix>final class AffineMatrix implements ExtendedPrecisionMatrix, Serializable, Cloneable {\n    /**\n     * For cross-version compatibility.\n     */\n    private static final long serialVersionUID = 1605578645060388327L;\n\n    /**\n     * The number of rows and columns of this matrix.\n     */\n    private static final int SIZE = 3;\n\n    /**\n     * The length of an array containing all matrix elements.\n     */\n    private static final int LENGTH = SIZE * SIZE;\n\n    /**\n     * The length of an array containing only the matrix elements to be stored.\n     * The last row is omitted because it is assumed to contain (0 0 1).\n     */\n    private static final int LENGTH_STORED = (SIZE - 1) * SIZE;\n\n    /**\n     * The length of an array containing all matrix elements together with error terms.\n     */\n    private static final int LENGTH_EXTENDED = 2 * LENGTH;\n\n    /**\n     * The transform from which to get the matrix terms.\n     */\n    private final AffineTransform transform;\n\n    /**\n     * The error terms, or {@code null} if none.\n     * If non-null, then the length of this array shall be 6.\n     */\n    private final double[] errors;\n\n    /**\n     * Creates a new matrix wrapping the given transform.\n     *\n     * @param transform  the transform to wrap.\n     * @param elements   the elements used for creating the matrix (optionally with error terms), or {@code null}.\n     */\n    AffineMatrix(final AffineTransform transform, final double[] elements) {\n        this.transform = transform;\n        if (elements != null) {\n            assert elements.length == LENGTH || elements.length == LENGTH_EXTENDED;\n            if (elements.length == LENGTH_EXTENDED) {\n                errors = Arrays.copyOfRange(elements, LENGTH, LENGTH + LENGTH_STORED);\n                /*\n                 * At this point we could check:\n                 *\n                 *   assert Arrays.equals(elements, getExtendedElements());\n                 *\n                 * but we do not, because the terms in the last row may not be exactly 0 or 1\n                 * because of rounding errors.\n                 */\n                return;\n            }\n        }\n        errors = null;\n    }\n\n    /**\n     * Gets the number of rows in the matrix.\n     */\n    @Override\n    public int getNumRow() {\n        return SIZE;\n    }\n\n    /**\n     * Gets the number of columns in the matrix.\n     */\n    @Override\n    public int getNumCol() {\n        return SIZE;\n    }\n\n    /**\n     * Returns {@code true} if the backing affine transform is the identity transform.\n     */\n    @Override\n    public boolean isIdentity() {\n        return transform.isIdentity();\n    }\n\n    /**\n     * Returns all matrix elements.\n     */\n    @Override\n    public double[] getExtendedElements() {\n        final double[] elements = new double[errors != null ? LENGTH_EXTENDED : LENGTH];\n        if (errors != null) {\n            System.arraycopy(errors, 0, elements, LENGTH, LENGTH_STORED);\n        }\n        elements[0] = transform.getScaleX();\n        elements[1] = transform.getShearX();\n        elements[2] = transform.getTranslateX();\n        elements[3] = transform.getShearY();\n        elements[4] = transform.getScaleY();\n        elements[5] = transform.getTranslateY();\n        elements[8] = 1;\n        return elements;\n    }\n\n    /**\n     * Returns the matrix element at the given index.\n     */\n    @Override\n    public final double getElement(final int row, final int column) {\n        ArgumentChecks.ensureBetween(\"row\",    0, SIZE, row);\n        ArgumentChecks.ensureBetween(\"column\", 0, SIZE, column);\n        switch (row * SIZE + column) {\n            case 0: return transform.getScaleX();\n            case 1: return transform.getShearX();\n            case 2: return transform.getTranslateX();\n            case 3: return transform.getShearY();\n            case 4: return transform.getScaleY();\n            case 5: return transform.getTranslateY();\n            case 6: // Fallthrough\n            case 7: return 0;\n            case 8: return 1;\n            default: throw new AssertionError();\n        }\n    }\n\n    /**\n     * Unsupported operation, since this matrix is unmodifiable.\n     */\n    @Override\n    public final void setElement(final int row, final int column, final double value) {\n        throw new UnsupportedOperationException(Resources.format(Resources.Keys.UnmodifiableAffineTransform));\n    }\n\n    /**\n     * Returns a copy of the matrix that user can modify.\n     */\n    @Override\n    @SuppressWarnings(\"CloneDoesntCallSuperClone\")\n    public final Matrix clone() {\n        return Matrices.copy(this);\n    }\n\n    /**\n     * Compares this matrix with the given object for equality, including error terms (if any).\n     */\n    @Override\n    public boolean equals(final Object obj) {\n        if (obj instanceof AffineMatrix) {\n            final AffineMatrix other = (AffineMatrix) obj;\n            return transform.equals(other.transform) && Arrays.equals(errors, other.errors);\n        }\n        return false;\n    }\n\n    /**\n     * Returns a hash code value for this matrix.\n     */\n    @Override\n    public int hashCode() {\n        return (transform.hashCode() * 31 + Arrays.hashCode(errors)) ^ (int) serialVersionUID;\n    }\n\n    /**\n     * Returns a string representation of this matrix.\n     *\n     * @return a string representation of this matrix.\n     */\n    @Override\n    public String toString() {\n        return Matrices.toString(this);\n    }\n}<fim_middle>// class below has no smell\n"}