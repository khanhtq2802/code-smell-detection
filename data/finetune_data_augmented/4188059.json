{"text": "<fim_prefix>/*****************************************************************\n *   Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n ****************************************************************/\npackage org.apache.cayenne.map;\nimport org.apache.cayenne.CayenneRuntimeException;\nimport org.apache.cayenne.configuration.ConfigurationNode;\nimport org.apache.cayenne.configuration.ConfigurationNodeVisitor;\nimport org.apache.cayenne.util.Util;\nimport org.apache.cayenne.util.XMLEncoder;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.Function;\n/**\n * A DbRelationship is a descriptor of a database inter-table relationship based\n * on one or more primary key/foreign key pairs.\n */\npublic class DbRelationship extends Relationship implements ConfigurationNode {\n    // The columns through which the join is implemented.\n    protected List<DbJoin> joins = new ArrayList<>(2);\n    // Is relationship from source to target points to dependent primary\n    // key (primary key column of destination table that is also a FK to the\n    // source\n    // column)\n    protected boolean toDependentPK;\n    public DbRelationship() {\n        super();\n    }\n<fim_suffix>    public DbRelationship(String name) {\n        super(name);\n    }\n    @Override\n    public DbEntity getSourceEntity() {\n        return (DbEntity) super.getSourceEntity();\n    }\n    /**\n     * @since 3.1\n     */\n    public <T> T acceptVisitor(ConfigurationNodeVisitor<T> visitor) {\n        return visitor.visitDbRelationship(this);\n    }\n    /**\n     * Prints itself as XML to the provided XMLEncoder.\n     * \n     * @since 1.1\n     */\n    public void encodeAsXML(XMLEncoder encoder, ConfigurationNodeVisitor delegate) {\n        encoder.start(\"db-relationship\")\n                .attribute(\"name\", getName())\n                .attribute(\"source\", getSourceEntity().getName());\n        if (getTargetEntityName() != null && getTargetEntity() != null) {\n            encoder.attribute(\"target\", getTargetEntityName());\n        }\n        encoder.attribute(\"toDependentPK\", isToDependentPK() && isValidForDepPk());\n        encoder.attribute(\"toMany\", isToMany());\n        encoder.nested(getJoins(), delegate);\n        delegate.visitDbRelationship(this);\n        encoder.end();\n    }\n    /**\n     * Returns a target of this relationship. If relationship is not attached to\n     * a DbEntity, and DbEntity doesn't have a namespace, and exception is\n     * thrown.\n     */\n    @Override\n    public DbEntity getTargetEntity() {\n        String targetName = getTargetEntityName();\n        if (targetName == null) {\n            return null;\n        }\n        return getNonNullNamespace().getDbEntity(targetName);\n    }\n    /**\n     * Returns a Collection of target attributes.\n     * \n     * @since 1.1\n     */\n    @SuppressWarnings(\"unchecked\")\n    public Collection<DbAttribute> getTargetAttributes() {\n        return mapJoinsToAttributes(DbJoin::getTarget);\n    }\n    /**\n     * Returns a Collection of source attributes.\n     * \n     * @since 1.1\n     */\n    @SuppressWarnings(\"unchecked\")\n    public Collection<DbAttribute> getSourceAttributes() {\n        return mapJoinsToAttributes(DbJoin::getSource);\n    }\n    private Collection<DbAttribute> mapJoinsToAttributes(Function<DbJoin, DbAttribute> mapper) {\n        if (joins.size() == 0) {\n            return Collections.emptyList();\n        }\n        // fast path for common case\n        if(joins.size() == 1) {\n            return Collections.singletonList(mapper.apply(joins.get(0)));\n        }\n        Collection<DbAttribute> result = new ArrayList<>(joins.size());\n        for(DbJoin join : joins) {\n            result.add(mapper.apply(join));\n        }\n        return result;\n    }\n    /**\n     * Creates a new relationship with the same set of joins, but going in the\n     * opposite direction.\n     * \n     * @since 1.0.5\n     */\n    public DbRelationship createReverseRelationship() {\n        DbEntity targetEntity = getTargetEntity();\n        DbRelationship reverse = new DbRelationship();\n        reverse.setSourceEntity(targetEntity);\n        reverse.setTargetEntityName(getSourceEntity().getName());\n        // TODO: andrus 12/24/2007 - one more case to handle - set reverse\n        // toDepPK = true\n        // if this relationship toDepPK is false, but the entities are joined on\n        // a PK...\n        // on the other hand, these can still be two independent entities...\n        if (isToDependentPK() && !toMany && joins.size() == targetEntity.getPrimaryKeys().size()) {\n            reverse.setToMany(false);\n        } else {\n            reverse.setToMany(!toMany);\n        }\n        for (DbJoin join : joins) {\n            DbJoin reverseJoin = join.createReverseJoin();\n            reverseJoin.setRelationship(reverse);\n            reverse.addJoin(reverseJoin);\n        }\n        return reverse;\n    }\n    /**\n     * Returns DbRelationship that is the opposite of this DbRelationship. This\n     * means a relationship from this target entity to this source entity with\n     * the same join semantics. Returns null if no such relationship exists.\n     */\n    public DbRelationship getReverseRelationship() {\n        DbEntity target = getTargetEntity();\n        if (target == null) {\n            return null;\n        }\n        Entity src = this.getSourceEntity();\n        // special case - relationship to self with no joins...\n        if (target == src && joins.size() == 0) {\n            return null;\n        }\n        TestJoin testJoin = new TestJoin(this);\n        for (DbRelationship rel : target.getRelationships()) {\n            if (rel.getTargetEntity() != src) {\n                continue;\n            }\n            List<DbJoin> otherJoins = rel.getJoins();\n            if (otherJoins.size() != joins.size()) {\n                continue;\n            }\n            boolean joinsMatch = true;\n            for (DbJoin join : otherJoins) {\n                // flip join and try to find similar\n                testJoin.setSourceName(join.getTargetName());\n                testJoin.setTargetName(join.getSourceName());\n                if (!joins.contains(testJoin)) {\n                    joinsMatch = false;\n                    break;\n                }\n            }\n            if (joinsMatch) {\n                return rel;\n            }\n        }\n        return null;\n    }\n    /**\n     * Returns true if the relationship points to at least one of the PK columns\n     * of the target entity.\n     * \n     * @since 1.1\n     */\n    public boolean isToPK() {\n        for (DbJoin join : getJoins()) {\n            DbAttribute target = join.getTarget();\n            if (target == null) {\n                return false;\n            }\n            if (!target.isPrimaryKey()) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * @since 3.0\n     */\n    public boolean isFromPK() {\n        for (DbJoin join : getJoins()) {\n            DbAttribute source = join.getSource();\n            if (source == null) {\n                return false;\n            }\n            if (source.isPrimaryKey()) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Returns <code>true</code> if a method <code>isToDependentPK</code> of\n     * reverse relationship of this relationship returns <code>true</code>.\n     */\n    public boolean isToMasterPK() {\n        if (isToMany() || isToDependentPK()) {\n            return false;\n        }\n        DbRelationship revRel = getReverseRelationship();\n        return revRel != null && revRel.isToDependentPK();\n    }\n    /**\n     * Returns a boolean indicating whether modifying a target of such\n     * relationship in any way will not change the underlying table row of the\n     * source.\n     * \n     * @since 4.0\n     */\n    public boolean isSourceIndependentFromTargetChange() {\n        // note - call \"isToPK\" at the end of the chain, since\n        // if it is to a dependent PK, we still should return true...\n        return isToMany() || isToDependentPK() || !isToPK();\n    }\n    /**\n     * Returns <code>true</code> if relationship from source to target points to\n     * dependent primary key. Dependent PK is a primary key column of the<fim_middle>// function below has no smell\n"}