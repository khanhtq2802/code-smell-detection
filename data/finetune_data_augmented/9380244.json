{"text": "<fim_prefix>/*\n * Copyright (c) 2002, 2018, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n *\n */\n\npackage sun.jvm.hotspot.debugger.linux;\n\nimport sun.jvm.hotspot.debugger.*;\n\n<fim_suffix>class LinuxThread implements ThreadProxy {\n    private LinuxDebugger debugger;\n    private int           lwp_id;\n\n    /** The address argument must be the address of the _thread_id in the\n        OSThread. It's value is result ::gettid() call. */\n    LinuxThread(LinuxDebugger debugger, Address addr) {\n        this.debugger = debugger;\n        // FIXME: size of data fetched here should be configurable.\n        // However, making it so would produce a dependency on the \"types\"\n        // package from the debugger package, which is not desired.\n        int pid = (int)addr.getCIntegerAt(0, 4, true);\n        if (debugger instanceof LinuxDebuggerLocal) {\n            int hostPID = ((LinuxDebuggerLocal)debugger).getHostPID(pid);\n            // Debuggee is not running in the container\n            if (hostPID != -1) {\n                pid = hostPID;\n            }\n        }\n        this.lwp_id = pid;\n\n    }\n\n    LinuxThread(LinuxDebugger debugger, long id) {\n        this.debugger = debugger;\n        this.lwp_id = (int) id;\n    }\n\n    public boolean equals(Object obj) {\n        if ((obj == null) || !(obj instanceof LinuxThread)) {\n            return false;\n        }\n\n        return (((LinuxThread) obj).lwp_id == lwp_id);\n    }\n\n    public int hashCode() {\n        return lwp_id;\n    }\n\n    public String toString() {\n        return Integer.toString(lwp_id);\n    }\n\n    public ThreadContext getContext() throws IllegalThreadStateException {\n        long[] data = debugger.getThreadIntegerRegisterSet(lwp_id);\n        ThreadContext context = LinuxThreadContextFactory.createThreadContext(debugger);\n        for (int i = 0; i < data.length; i++) {\n            context.setRegister(i, data[i]);\n        }\n        return context;\n    }\n\n    public boolean canSetContext() throws DebuggerException {\n        return false;\n    }\n\n    public void setContext(ThreadContext context)\n      throws IllegalThreadStateException, DebuggerException {\n        throw new DebuggerException(\"Unimplemented\");\n    }\n}<fim_middle>// class below has no smell\n"}