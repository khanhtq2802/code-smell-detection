{"text": "<fim_prefix>      for (URI ep : endpoints) {\n        if (HTTPS_SCHEME.equals(ep.getScheme())) {\n          loadSSLConfiguration();\n          break;\n        }\n      }\n      int requestHeaderSize = conf.getInt(\n          HTTP_MAX_REQUEST_HEADER_SIZE_KEY,\n          HTTP_MAX_REQUEST_HEADER_SIZE_DEFAULT);\n      int responseHeaderSize = conf.getInt(\n          HTTP_MAX_RESPONSE_HEADER_SIZE_KEY,\n          HTTP_MAX_RESPONSE_HEADER_SIZE_DEFAULT);\n      int idleTimeout = conf.getInt(HTTP_IDLE_TIMEOUT_MS_KEY,\n          HTTP_IDLE_TIMEOUT_MS_DEFAULT);\n      HttpConfiguration httpConfig = new HttpConfiguration();\n      httpConfig.setRequestHeaderSize(requestHeaderSize);\n      httpConfig.setResponseHeaderSize(responseHeaderSize);\n      httpConfig.setSendServerVersion(false);\n      int backlogSize = conf.getInt(HTTP_SOCKET_BACKLOG_SIZE_KEY,\n          HTTP_SOCKET_BACKLOG_SIZE_DEFAULT);\n      for (URI ep : endpoints) {\n        final ServerConnector connector;\n        String scheme = ep.getScheme();\n        if (HTTP_SCHEME.equals(scheme)) {\n          connector = createHttpChannelConnector(server.webServer,\n              httpConfig);\n        } else if (HTTPS_SCHEME.equals(scheme)) {\n          connector = createHttpsChannelConnector(server.webServer,\n              httpConfig);\n        } else {\n          throw new HadoopIllegalArgumentException(\n              \"unknown scheme for endpoint:\" + ep);\n        }\n        connector.setHost(ep.getHost());\n        connector.setPort(ep.getPort() == -1 ? 0 : ep.getPort());\n        connector.setAcceptQueueSize(backlogSize);\n        connector.setIdleTimeout(idleTimeout);\n        server.addListener(connector);\n      }\n      server.loadListeners();\n      return server;\n    }\n    private ServerConnector createHttpChannelConnector(\n        Server server, HttpConfiguration httpConfig) {\n      ServerConnector conn = new ServerConnector(server,\n          conf.getInt(HTTP_ACCEPTOR_COUNT_KEY, HTTP_ACCEPTOR_COUNT_DEFAULT),\n          conf.getInt(HTTP_SELECTOR_COUNT_KEY, HTTP_SELECTOR_COUNT_DEFAULT));\n      ConnectionFactory connFactory = new HttpConnectionFactory(httpConfig);\n      conn.addConnectionFactory(connFactory);\n      if(Shell.WINDOWS) {\n        // result of setting the SO_REUSEADDR flag is different on Windows\n        // http://msdn.microsoft.com/en-us/library/ms740621(v=vs.85).aspx\n        // without this 2 NN's can start on the same machine and listen on\n        // the same port with indeterminate routing of incoming requests to them\n        conn.setReuseAddress(false);\n      }\n      return conn;\n    }\n    private ServerConnector createHttpsChannelConnector(\n        Server server, HttpConfiguration httpConfig) {\n      httpConfig.setSecureScheme(HTTPS_SCHEME);\n      httpConfig.addCustomizer(new SecureRequestCustomizer());\n      ServerConnector conn = createHttpChannelConnector(server, httpConfig);\n      SslContextFactory sslContextFactory = new SslContextFactory();\n      sslContextFactory.setNeedClientAuth(needsClientAuth);\n      sslContextFactory.setKeyManagerPassword(keyPassword);\n      if (keyStore != null) {\n        sslContextFactory.setKeyStorePath(keyStore);\n        sslContextFactory.setKeyStoreType(keyStoreType);\n        sslContextFactory.setKeyStorePassword(keyStorePassword);\n      }\n      if (trustStore != null) {\n        sslContextFactory.setTrustStorePath(trustStore);\n        sslContextFactory.setTrustStoreType(trustStoreType);\n        sslContextFactory.setTrustStorePassword(trustStorePassword);\n      }\n      if(null != excludeCiphers && !excludeCiphers.isEmpty()) {\n        sslContextFactory.setExcludeCipherSuites(\n            StringUtils.getTrimmedStrings(excludeCiphers));\n        LOG.info(\"Excluded Cipher List:\" + excludeCiphers);\n      }\n      conn.addFirstConnectionFactory(new SslConnectionFactory(sslContextFactory,\n          HttpVersion.HTTP_1_1.asString()));\n      return conn;\n    }\n  }\n  private HttpServer2(final Builder b) throws IOException {\n    final String appDir = getWebAppsPath(b.name);\n    this.webServer = new Server();\n    this.adminsAcl = b.adminsAcl;\n    this.handlers = new HandlerCollection();\n    this.webAppContext = createWebAppContext(b, adminsAcl, appDir);\n    this.xFrameOptionIsEnabled = b.xFrameEnabled;\n    this.xFrameOption = b.xFrameOption;\n    try {\n      this.secretProvider =\n          constructSecretProvider(b, webAppContext.getServletContext());\n      this.webAppContext.getServletContext().setAttribute\n          (AuthenticationFilter.SIGNER_SECRET_PROVIDER_ATTRIBUTE,\n           secretProvider);\n    } catch(IOException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new IOException(e);\n    }\n    this.findPort = b.findPort;\n    this.portRanges = b.portRanges;\n    initializeWebServer(b.name, b.hostName, b.conf, b.pathSpecs);\n  }\n  private void initializeWebServer(String name, String hostName,\n      Configuration conf, String[] pathSpecs)\n      throws IOException {\n    Preconditions.checkNotNull(webAppContext);\n    int maxThreads = conf.getInt(HTTP_MAX_THREADS_KEY, -1);\n    // If HTTP_MAX_THREADS is not configured, QueueThreadPool() will use the\n    // default value (currently 250).\n    QueuedThreadPool threadPool = (QueuedThreadPool) webServer.getThreadPool();\n    threadPool.setDaemon(true);\n    if (maxThreads != -1) {\n      threadPool.setMaxThreads(maxThreads);\n    }\n    SessionManager sm = webAppContext.getSessionHandler().getSessionManager();\n    if (sm instanceof AbstractSessionManager) {\n      AbstractSessionManager asm = (AbstractSessionManager)sm;\n      asm.setHttpOnly(true);\n      asm.getSessionCookieConfig().setSecure(true);\n    }\n    ContextHandlerCollection contexts = new ContextHandlerCollection();\n    RequestLog requestLog = HttpRequestLog.getRequestLog(name);\n    handlers.addHandler(contexts);\n    if (requestLog != null) {\n      RequestLogHandler requestLogHandler = new RequestLogHandler();\n      requestLogHandler.setRequestLog(requestLog);\n      handlers.addHandler(requestLogHandler);\n    }\n    handlers.addHandler(webAppContext);\n    final String appDir = getWebAppsPath(name);\n    addDefaultApps(contexts, appDir, conf);\n    webServer.setHandler(handlers);\n    Map<String, String> xFrameParams = setHeaders(conf);\n    addGlobalFilter(\"safety\", QuotingInputFilter.class.getName(), xFrameParams);\n    final FilterInitializer[] initializers = getFilterInitializers(conf);\n    if (initializers != null) {\n      conf = new Configuration(conf);\n      conf.set(BIND_ADDRESS, hostName);\n      for (FilterInitializer c : initializers) {\n        c.initFilter(this, conf);\n      }\n    }\n    addDefaultServlets();\n    if (pathSpecs != null) {\n      for (String path : pathSpecs) {\n        LOG.info(\"adding path spec: \" + path);\n        addFilterPathMapping(path, webAppContext);\n      }\n    }\n  }\n  private void addListener(ServerConnector connector) {\n    listeners.add(connector);\n  }\n<fim_suffix>  private static WebAppContext createWebAppContext(Builder b,\n      AccessControlList adminsAcl, final String appDir) {\n    WebAppContext ctx = new WebAppContext();\n    ctx.setDefaultsDescriptor(null);\n    ServletHolder holder = new ServletHolder(new DefaultServlet());\n    Map<String, String> params = ImmutableMap. <String, String> builder()\n            .put(\"acceptRanges\", \"true\")\n            .put(\"dirAllowed\", \"false\")\n            .put(\"gzip\", \"true\")\n            .put(\"useFileMappedBuffer\", \"true\")\n            .build();\n    holder.setInitParameters(params);\n    ctx.setWelcomeFiles(new String[] {\"index.html\"});\n    ctx.addServlet(holder, \"/\");\n    ctx.setDisplayName(b.name);\n    ctx.setContextPath(\"/\");\n    ctx.setWar(appDir + \"/\" + b.name);\n    String tempDirectory = b.conf.get(HTTP_TEMP_DIR_KEY);\n    if (tempDirectory != null && !tempDirectory.isEmpty()) {\n      ctx.setTempDirectory(new File(tempDirectory));\n      ctx.setAttribute(\"javax.servlet.context.tempdir\", tempDirectory);\n    }\n    ctx.getServletContext().setAttribute(CONF_CONTEXT_ATTRIBUTE, b.conf);\n    ctx.getServletContext().setAttribute(ADMINS_ACL, adminsAcl);\n    addNoCacheFilter(ctx);\n    return ctx;\n  }<fim_middle>// function below has no smell\n"}