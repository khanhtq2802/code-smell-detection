{"text": "<fim_prefix>// Copyright (C) 2005 Google Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage com.google.caja.parser.js;\n\nimport com.google.caja.lexer.FilePosition;\nimport com.google.caja.lexer.TokenConsumer;\nimport com.google.caja.parser.ParseTreeNode;\nimport com.google.caja.reporting.RenderContext;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n *\n * @author mikesamuel@gmail.com\n */\n<fim_suffix>public final class SwitchStmt extends LabeledStatement {\n  private static final long serialVersionUID = -7284973291082281855L;\n\n  @ReflectiveCtor\n  public SwitchStmt(\n      FilePosition pos, String label, List<? extends ParseTreeNode> children) {\n    super(pos, label, ParseTreeNode.class);\n    createMutation().appendChildren(children).execute();\n  }\n\n  public SwitchStmt(\n      FilePosition pos, String label,\n      Expression valueExpr, List<SwitchCase> cases) {\n    super(pos, label, ParseTreeNode.class);\n    createMutation().appendChild(valueExpr).appendChildren(cases).execute();\n  }\n\n  @Override\n  protected void childrenChanged() {\n    super.childrenChanged();\n    List<? extends ParseTreeNode> children = children();\n    ParseTreeNode valueExpr = children.get(0);\n    if (!(valueExpr instanceof Expression)) {\n      throw new ClassCastException(\n          \"Expected \" + Expression.class.getName() + \" not \"\n          + valueExpr.getClass().getName());\n    }\n    for (ParseTreeNode node : children.subList(1, children.size())) {\n      if (!(node instanceof SwitchCase)) {\n        throw new ClassCastException(\n            \"Expected \" + SwitchCase.class.getName() + \" not \"\n            + (node != null ? node.getClass().getName() : \"<null>\"));\n      }\n    }\n  }\n\n  @Override\n  public void continues(Map<String, List<ContinueStmt>> contsReaching) {\n    // switch statements don't intercept continues\n    for (ParseTreeNode child : children()) {\n      if (child instanceof Statement) {\n        ((Statement) child).continues(contsReaching);\n      }\n    }\n  }\n\n  @Override\n  public boolean isTargetForContinue() { return false; }\n\n  public void render(RenderContext rc) {\n    TokenConsumer out = rc.getOut();\n    out.mark(getFilePosition());\n    String label = getRenderedLabel();\n    if (null != label) {\n      out.consume(label);\n      out.consume(\":\");\n    }\n    Iterator<? extends ParseTreeNode> it = children().iterator();\n    out.consume(\"switch\");\n    out.consume(\"(\");\n    it.next().render(rc);\n    out.consume(\")\");\n    out.consume(\"{\");\n    while (it.hasNext()) {\n      SwitchCase caseStmt = (SwitchCase) it.next();\n      caseStmt.render(rc);\n    }\n    out.mark(FilePosition.endOfOrNull(getFilePosition()));\n    out.consume(\"}\");\n  }\n\n  @Override\n  public boolean isTerminal() {\n    return true;\n  }\n\n  public boolean hasHangingConditional() { return false; }\n}<fim_middle>// class below has no smell\n"}