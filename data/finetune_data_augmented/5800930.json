{"text": "<fim_prefix>// ASM: a very small and fast Java bytecode manipulation framework\n// Copyright (c) 2000-2011 INRIA, France Telecom\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions\n// are met:\n// 1. Redistributions of source code must retain the above copyright\n//    notice, this list of conditions and the following disclaimer.\n// 2. Redistributions in binary form must reproduce the above copyright\n//    notice, this list of conditions and the following disclaimer in the\n//    documentation and/or other materials provided with the distribution.\n// 3. Neither the name of the copyright holders nor the names of its\n//    contributors may be used to endorse or promote products derived from\n//    this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n// THE POSSIBILITY OF SUCH DAMAGE.\npackage org.apache.tapestry5.internal.plastic.asm.tree.analysis;\n\nimport java.util.Set;\nimport org.apache.tapestry5.internal.plastic.asm.tree.AbstractInsnNode;\n\n/**\n * A {@link Value} which keeps track of the bytecode instructions that can produce it.\n *\n * @author Eric Bruneton\n */\npublic class SourceValue implements Value {\n\n  /**\n   * The size of this value, in 32 bits words. This size is 1 for byte, boolean, char, short, int,\n   * float, object and array types, and 2 for long and double.\n   */\n  public final int size;\n\n  /**\n   * The instructions that can produce this value. For example, for the Java code below, the\n   * instructions that can produce the value of {@code i} at line 5 are the two ISTORE instructions\n   * at line 1 and 3:\n   *\n   * <pre>\n   * 1: i = 0;\n   * 2: if (...) {\n   * 3:   i = 1;\n   * 4: }\n   * 5: return i;\n   * </pre>\n   */\n  public final Set<AbstractInsnNode> insns;\n\n  /**\n   * Constructs a new {@link SourceValue}.\n   *\n   * @param size the size of this value, in 32 bits words. This size is 1 for byte, boolean, char,\n   *     short, int, float, object and array types, and 2 for long and double.\n   */\n  public SourceValue(final int size) {\n    this(size, new SmallSet<AbstractInsnNode>());\n  }\n\n  /**\n   * Constructs a new {@link SourceValue}.\n   *\n   * @param size the size of this value, in 32 bits words. This size is 1 for byte, boolean, char,\n   *     short, int, float, object and array types, and 2 for long and double.\n   * @param insnNode an instruction that can produce this value.\n   */\n  public SourceValue(final int size, final AbstractInsnNode insnNode) {\n    this.size = size;\n    this.insns = new SmallSet<AbstractInsnNode>(insnNode);\n  }\n\n  /**\n   * Constructs a new {@link SourceValue}.\n   *\n   * @param size the size of this value, in 32 bits words. This size is 1 for byte, boolean, char,\n   *     short, int, float, object and array types, and 2 for long and double.\n   * @param insnSet the instructions that can produce this value.\n   */\n  public SourceValue(final int size, final Set<AbstractInsnNode> insnSet) {\n    this.size = size;\n    this.insns = insnSet;\n  }\n\n  /**\n   * Returns the size of this value.\n   *\n   * @return the size of this value, in 32 bits words. This size is 1 for byte, boolean, char,\n   *     short, int, float, object and array types, and 2 for long and double.\n   */\n<fim_suffix>  @Override\n  public int getSize() {\n    return size;\n  }\n\n  @Override\n  public boolean equals(final Object value) {\n    if (!(value instanceof SourceValue)) {\n      return false;\n    }\n    SourceValue sourceValue = (SourceValue) value;\n    return size == sourceValue.size && insns.equals(sourceValue.insns);\n  }\n\n  @Override\n  public int hashCode() {\n    return insns.hashCode();\n  }\n}<fim_middle>// function below has no smell\n"}