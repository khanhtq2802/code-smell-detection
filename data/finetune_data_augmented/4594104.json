{"text": "<fim_prefix> * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.giraph.types.heaps;\nimport it.unimi.dsi.fastutil.ints.AbstractInt2ByteMap;\nimport it.unimi.dsi.fastutil.ints.Int2ByteMap;\nimport it.unimi.dsi.fastutil.objects.ObjectIterator;\nimport java.io.DataInput;\nimport java.io.DataOutput;\nimport java.io.IOException;\nimport java.util.NoSuchElementException;\nimport org.apache.giraph.function.primitive.pairs.IntByteConsumer;\nimport org.apache.giraph.function.primitive.pairs.IntBytePredicate;\n// AUTO-GENERATED class via class:\n// org.apache.giraph.generate.GeneratePrimitiveClasses\n/**\n * Min heap which holds (int key, byte value) pairs with\n * the largest values as its elements, up to the given maximum number of\n * elements.\n *\n * When multiple elements with same values are added and there is no space for\n * all of them in the heap, the one with larger keys will be kept in the heap.\n *\n * You can remove a pair with the minimum value currently in the heap.\n */\npublic class FixedCapacityIntByteMinHeap\n    implements Int2ByteMapEntryIterable {\n  /** Keys in the heap */\n  private final int[] keys;\n  /** Values in the heap */\n  private final byte[] values;\n  /** Number of elements currently in the heap */\n  private int size;\n  /** Capacity of the heap */\n  private final int capacity;\n  /** Reusable iterator instance */\n  private final IteratorImpl iterator;\n  /**\n   * Initialize the heap with desired capacity\n   *\n   * @param capacity Capacity\n   */\n  public FixedCapacityIntByteMinHeap(int capacity) {\n    keys = new int[capacity];\n    values = new byte[capacity];\n    size = 0;\n    this.capacity = capacity;\n    iterator = new IteratorImpl();\n  }\n  /** Clear the heap */\n  public void clear() {\n    size = 0;\n  }\n  /**\n   * Add a key value pair\n   *\n   * @param key   Key\n   * @param value Value\n   */\n  public void add(int key, byte value) {\n    if (capacity == 0 ||\n        (size == capacity && compare(keys[0], values[0], key, value) >= 0)) {\n      // If the heap is full and smallest element in it is not smaller\n      // than value, do nothing\n      return;\n    }\n    int position;\n    if (size < capacity) {\n      // If the heap is not full, increase its size and find the position for\n      // new element (up-heap search)\n      position = size;\n      size++;\n      while (position > 0) {\n        int parent = (position - 1) >> 1;\n        if (compare(keys[parent], values[parent], key, value) < 0) {\n          break;\n        }\n        values[position] = values[parent];\n        keys[position] = keys[parent];\n        position = parent;\n      }\n    } else {\n      // If the heap is full, remove element from the root and find the position\n      // for new element (down-heap search)\n      position = removeRootAndFindPosition(key, value);\n    }\n    // Fill position with key value pair\n    keys[position] = key;\n    values[position] = value;\n  }\n  /**\n   * @return Key corresponding to the minimum value currently in the heap\n   * @throws NoSuchElementException if the heap is empty.\n   */\n  public int getMinKey() {\n    if (size() > 0) {\n      return keys[0];\n    } else {\n      throw new NoSuchElementException();\n    }\n  }\n  /**\n   * @return Minimum value currently in the heap\n   * @throws NoSuchElementException if the heap is empty.\n   */\n  public byte getMinValue() {\n    if (size() > 0) {\n      return values[0];\n    } else {\n      throw new NoSuchElementException();\n    }\n  }\n  /**\n   * Removes the (key, value) pair that corresponds to the minimum value\n   * currently in the heap.\n   */\n  public void removeMin() {\n    if (size() > 0) {\n      size--;\n      int position = removeRootAndFindPosition(keys[size], values[size]);\n      keys[position] = keys[size];\n      values[position] = values[size];\n    }\n  }\n  /**\n   * Comapre two (key, value) entries\n   *\n   * @param key1   First key\n   * @param value1 First value\n   * @param key2   Second key\n   * @param value2 Second value\n   * @return 0 if entries are equal, &lt; 0 if first entry is smaller than the\n   * second one, and &gt; 0 if first entry is larger than the second one\n   */\n  protected int compare(int key1, byte value1,\n      int key2, byte value2) {\n    int t = Byte.compare(value1, value2);\n    return (t == 0) ? Integer.compare(key1, key2) : t;\n  }\n  @Override\n  public ObjectIterator<Int2ByteMap.Entry> iterator() {\n    iterator.reset();\n    return iterator;\n  }\n  @Override\n  public int size() {\n    return size;\n  }\n  /**\n   * Check if the heap is empty\n   *\n   * @return True iff the heap is empty\n   */\n  public boolean isEmpty() {\n    return size == 0;\n  }\n  /**\n   * Get capacity of the heap\n   *\n   * @return Heap capacity\n   */\n  public int getCapacity() {\n    return capacity;\n  }\n  /**\n   * Serializes an object into data output.\n   *\n   * @param heap Object instance to serialize\n   * @param out  Data output\n   * @throws java.io.IOException\n   */\n  public static void write(FixedCapacityIntByteMinHeap heap,\n      DataOutput out) throws IOException {\n    out.writeInt(heap.capacity);\n    out.writeInt(heap.size);\n    for (int i = 0; i < heap.size(); i++) {\n      out.writeInt(heap.keys[i]);\n      out.writeByte(heap.values[i]);\n    }\n  }\n  /**\n   * Deserializes an object from data input.\n   *\n   * @param heap Object to reuse if possible\n   * @param in   Data input\n   * @return FixedCapacityIntByteMinHeap deserialized from data input.\n   * @throws IOException\n   */\n  public static FixedCapacityIntByteMinHeap read(\n      FixedCapacityIntByteMinHeap heap, DataInput in)\n      throws IOException {\n    int capacity = in.readInt();\n    if (heap == null || heap.capacity != capacity) {\n      heap = new FixedCapacityIntByteMinHeap(capacity);\n    } else {\n      heap.clear();\n    }\n    heap.size = in.readInt();\n    for (int i = 0; i < heap.size; i++) {\n      heap.keys[i] = in.readInt();\n      heap.values[i] = in.readByte();\n    }\n    return heap;\n  }\n  /**\n   * Takes a (key, value) pair, removes the root of the heap, and finds\n   * a position where the pair can be inserted.\n   *\n   * @param key   Key\n   * @param value Value\n   * @return Position in the heap where the (key, value) pair can be inserted\n   * while preserving the heap property.\n   */\n  private int removeRootAndFindPosition(int key, byte value) {\n    int position = 0;\n    while (position < size) {\n      // Find the left child\n      int minChild = (position << 1) + 1;\n      // Compare the left and the right child values - find the smaller one\n      if (minChild + 1 < size &&\n          compare(keys[minChild + 1], values[minChild + 1],\n              keys[minChild], values[minChild]) < 0) {\n        minChild++;\n      }\n      if (minChild >= size || compare(keys[minChild], values[minChild],\n          key, value) >= 0) {\n        break;\n      }\n      keys[position] = keys[minChild];\n      values[position] = values[minChild];\n      position = minChild;\n    }\n    return position;\n  }\n  /**\n   * Traverse all elements of the heap, calling given function on each element.\n   *\n   * @param f Function to call on each element.\n   */\n<fim_suffix>  public void forEachIntByte(IntByteConsumer f) {\n    for (int i = 0; i < size(); ++i) {\n      f.apply(keys[i], values[i]);\n    }\n  }<fim_middle>// function below has no smell\n"}