{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.proxy2.stub;\nimport java.lang.reflect.Array;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.Validate;\nimport org.apache.commons.lang3.reflect.TypeUtils;\nimport org.apache.commons.proxy2.Interceptor;\nimport org.apache.commons.proxy2.ObjectProvider;\nimport org.apache.commons.proxy2.interceptor.InterceptorUtils;\nimport org.apache.commons.proxy2.interceptor.matcher.ArgumentMatcher;\nimport org.apache.commons.proxy2.interceptor.matcher.argument.ArgumentMatcherUtils;\npublic abstract class BaseTrainer<S extends BaseTrainer<S, T>, T>\n{\n    //******************************************************************************************************************\n    // Fields\n    //******************************************************************************************************************\n    public final Class<T> traineeType;\n    //******************************************************************************************************************\n    // Constructors\n    //******************************************************************************************************************\n    /**\n     * Create a new {@link BaseTrainer} instance. This constructor should only be called by classes that explicitly\n     * assign the T parameter in the class definition. This should include basically any runtime-usable class.\n     */\n    protected BaseTrainer()\n    {\n        this(null);\n    }\n    protected BaseTrainer(Class<T> traineeType)\n    {\n        super();\n        if (traineeType != null)\n        {\n            this.traineeType = traineeType;\n            return;\n        }\n        @SuppressWarnings(\"unchecked\") // T is this class's second type parameter; thus the raw type is Class<T>\n        final Class<T> resolvedVariable = (Class<T>) TypeUtils.getRawType(BaseTrainer.class.getTypeParameters()[1],\n                getClass());\n        Validate.isTrue(resolvedVariable != null, \"Trainee type was not specified and could not be calculated for %s\",\n                getClass());\n        this.traineeType = resolvedVariable;\n    }\n    //******************************************************************************************************************\n    // Abstract Methods\n    //******************************************************************************************************************\n    protected abstract void train(T trainee);\n    //******************************************************************************************************************\n    // Other Methods\n    //******************************************************************************************************************\n    protected <R> R any(Class<R> type)\n    {\n        return argThat(ArgumentMatcherUtils.<R> any());\n    }\n    protected <R> R eq(R value)\n    {\n        return argThat(ArgumentMatcherUtils.eq(value));\n    }\n    protected <R> R isInstance(Class<R> type)\n    {\n        return argThat(ArgumentMatcherUtils.<R> isA(type));\n    }\n    protected <R> R argThat(ArgumentMatcher<R> matcher)\n    {\n        trainingContext().record(matcher);\n        return null;\n    }\n    protected void thenThrow(Exception e)\n    {\n        trainingContext().then(InterceptorUtils.throwing(e));\n    }\n    protected void thenThrow(ObjectProvider<? extends Exception> provider)\n    {\n        trainingContext().then(InterceptorUtils.throwing(provider));\n    }\n    protected TrainingContext trainingContext()\n    {\n        return TrainingContext.current();\n    }\n    public <R> WhenObject<R> when(R expression)\n    {\n        return new WhenObject<R>();\n    }\n    public WhenClass when(Class<?> expression)\n    {\n        return new WhenClass();\n    }\n    public WhenByteArray when(byte[] expression)\n    {\n        return new WhenByteArray();\n    }\n    public WhenBooleanArray when(boolean[] expression)\n    {\n        return new WhenBooleanArray();\n    }\n    public WhenIntArray when(int[] expression)\n    {\n        return new WhenIntArray();\n    }\n    public WhenShortArray when(short[] expresssion)\n    {\n        return new WhenShortArray();\n    }\n    public WhenLongArray when(long[] expression)\n    {\n        return new WhenLongArray();\n    }\n    public WhenFloatArray when(float[] expression)\n    {\n        return new WhenFloatArray();\n    }\n    public WhenDoubleArray when(double[] expression)\n    {\n        return new WhenDoubleArray();\n    }\n    public <R> WhenObjectArray<R> when(R[] expression)\n    {\n        @SuppressWarnings(\"unchecked\") // we can reasonably say that the component type of an R[] is Class<? extends R>:\n        final Class<? extends R> componentType = (Class<? extends R>) expression.getClass().getComponentType();\n        return new WhenObjectArray<R>(componentType);\n    }\n    public WhenCharArray when(char[] expression)\n    {\n        return new WhenCharArray();\n    }\n    protected S self()\n    {\n        @SuppressWarnings(\"unchecked\") // S is our \"self\" type parameter\n        final S self = (S) this;\n        return self;\n    }\n    //******************************************************************************************************************\n    // Inner Classes\n    //******************************************************************************************************************\n    protected abstract class BaseWhen<R>\n    {\n        public S thenThrow(Exception e)\n        {\n            return then(InterceptorUtils.throwing(e));\n        }\n        public S thenThrow(ObjectProvider<? extends Exception> provider)\n        {\n            return then(InterceptorUtils.throwing(provider));\n        }\n        public S thenAnswer(ObjectProvider<? extends R> provider)\n        {\n            return then(InterceptorUtils.provider(provider));\n        }\n        public S then(Interceptor interceptor)\n        {\n            trainingContext().then(interceptor);\n            return self();\n        }\n    }\n    protected class WhenBooleanArray extends BaseWhen<boolean[]>\n    {\n        public S thenReturn(boolean... values)\n        {\n            trainingContext().then(InterceptorUtils.constant(ArrayUtils.clone(values)));\n            return self();\n        }\n    }\n    protected class WhenByteArray extends BaseWhen<byte[]>\n    {\n        public S thenReturn(byte... values)\n        {\n            trainingContext().then(InterceptorUtils.constant(ArrayUtils.clone(values)));\n            return self();\n        }\n    }\n    protected class WhenCharArray extends BaseWhen<char[]>\n    {\n        public S thenReturn(char... values)\n        {\n            trainingContext().then(InterceptorUtils.constant(ArrayUtils.clone(values)));\n            return self();\n        }\n    }\n    protected class WhenDoubleArray extends BaseWhen<double[]>\n    {\n        public S thenReturn(double... values)\n        {\n            trainingContext().then(InterceptorUtils.constant(ArrayUtils.clone(values)));\n            return self();\n        }\n    }\n<fim_suffix>    protected class WhenFloatArray extends BaseWhen<float[]>\n    {\n        public S thenReturn(float... values)\n        {\n            trainingContext().then(InterceptorUtils.constant(ArrayUtils.clone(values)));\n            return self();\n        }\n    }\n    protected class WhenIntArray extends BaseWhen<int[]>\n    {\n        public S thenReturn(int... values)\n        {\n            trainingContext().then(InterceptorUtils.constant(ArrayUtils.clone(values)));\n            return self();\n        }\n    }\n    protected class WhenLongArray extends BaseWhen<long[]>\n    {\n        public S thenReturn(long... values)\n        {\n            trainingContext().then(InterceptorUtils.constant(ArrayUtils.clone(values)));\n            return self();\n        }\n    }\n    protected class WhenObject<R> extends BaseWhen<R>\n    {\n        public S thenReturn(R value)\n        {\n            trainingContext().then(InterceptorUtils.constant(value));\n            return self();\n        }\n        public S thenStub(BaseTrainer<?, R> trainer)\n        {\n            final R trainee = trainingContext().push(trainer.traineeType);\n            trainer.train(trainee);\n            trainingContext().then(InterceptorUtils.constant(trainingContext().pop()));\n            return self();\n        }\n    }\n    /**\n     * Intermediate result of a when(Class) call. Provided because it is such a common case to have a mismatch between a\n     * declared Class<?> return type and the bound parameter of a class literal.\n     */\n    protected class WhenClass extends BaseWhen<Class<?>>\n    {\n        public S thenReturn(Class<?> value)\n        {\n            trainingContext().then(InterceptorUtils.constant(value));\n            return self();\n        }\n    }\n    protected class WhenObjectArray<R> extends BaseWhen<R[]>\n    {\n        protected final Class<? extends R> componentType;\n        protected WhenObjectArray(Class<? extends R> componentType)\n        {\n            this.componentType = componentType;\n        }\n        public S thenReturn(R... values)\n        {\n            trainingContext().then(InterceptorUtils.constant(ArrayUtils.clone(values)));\n            return self();\n        }\n        public StubArrayBuilder<R> thenBuildArray()\n        {\n            return new StubArrayBuilder<R>(componentType);\n        }\n    }\n    protected class StubArrayBuilder<R>\n    {<fim_middle>// class below has no smell\n"}