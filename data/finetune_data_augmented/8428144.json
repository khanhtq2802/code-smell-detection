{"text": "<fim_prefix>\n<fim_suffix>public final class OgnlHelper {\n    private static final Pattern INDEX_PATTERN = Pattern.compile(\"^(.*)\\\\[(.*)\\\\]$\");\n    private OgnlHelper() {\n    }\n    /**\n     * Tests whether or not the given String is a Camel OGNL expression.\n     * <p/>\n     * An expression is considered an OGNL expression when it contains either one of the following chars: . or [\n     *\n     * @param expression  the String\n     * @return <tt>true</tt> if a Camel OGNL expression, otherwise <tt>false</tt>. \n     */\n    public static boolean isValidOgnlExpression(String expression) {\n        if (ObjectHelper.isEmpty(expression)) {\n            return false;\n        }\n        // the brackets should come in a pair\n        int bracketBegin = StringHelper.countChar(expression, '[');\n        int bracketEnd = StringHelper.countChar(expression, ']');\n        if (bracketBegin > 0 && bracketEnd > 0) {\n            return bracketBegin == bracketEnd;\n        }\n        return expression.contains(\".\");\n    }\n    public static boolean isInvalidValidOgnlExpression(String expression) {\n        if (ObjectHelper.isEmpty(expression)) {\n            return false;\n        }\n        if (!expression.contains(\".\") && !expression.contains(\"[\") && !expression.contains(\"]\")) {\n            return false;\n        }\n        // the brackets should come in pair\n        int bracketBegin = StringHelper.countChar(expression, '[');\n        int bracketEnd = StringHelper.countChar(expression, ']');\n        if (bracketBegin > 0 || bracketEnd > 0) {\n            return bracketBegin != bracketEnd;\n        }\n        // check for double dots\n        if (expression.contains(\"..\")) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Validates whether the method name is using valid java identifiers in the name\n     * Will throw {@link IllegalArgumentException} if the method name is invalid.\n     */\n    public static void validateMethodName(String method) {\n        if (ObjectHelper.isEmpty(method)) {\n            return;\n        }\n        for (int i = 0; i < method.length(); i++) {\n            char ch = method.charAt(i);\n            if (i == 0 && '.' == ch) {\n                // its a dot before a method name\n                continue;\n            }\n            if (ch == '(' || ch == '[' || ch == '.' || ch == '?') {\n                // break when method name ends and sub method or arguments begin\n                break;\n            }\n            if (i == 0 && !Character.isJavaIdentifierStart(ch)) {\n                throw new IllegalArgumentException(\"Method name must start with a valid java identifier at position: 0 in method: \" + method);\n            } else if (!Character.isJavaIdentifierPart(ch)) {\n                throw new IllegalArgumentException(\"Method name must be valid java identifier at position: \" + i + \" in method: \" + method);\n            }\n        }\n    }\n    /**\n     * Tests whether or not the given Camel OGNL expression is using the null safe operator or not.\n     *\n     * @param ognlExpression the Camel OGNL expression\n     * @return <tt>true</tt> if the null safe operator is used, otherwise <tt>false</tt>.\n     */\n    public static boolean isNullSafeOperator(String ognlExpression) {\n        if (ObjectHelper.isEmpty(ognlExpression)) {\n            return false;\n        }\n        return ognlExpression.startsWith(\"?\");\n    }\n    /**\n     * Removes any leading operators from the Camel OGNL expression.\n     * <p/>\n     * Will remove any leading of the following chars: ? or .\n     *\n     * @param ognlExpression  the Camel OGNL expression\n     * @return the Camel OGNL expression without any leading operators.\n     */\n    public static String removeLeadingOperators(String ognlExpression) {\n        if (ObjectHelper.isEmpty(ognlExpression)) {\n            return ognlExpression;\n        }\n        if (ognlExpression.startsWith(\"?\")) {\n            ognlExpression = ognlExpression.substring(1);\n        }\n        if (ognlExpression.startsWith(\".\")) {\n            ognlExpression = ognlExpression.substring(1);\n        }\n        return ognlExpression;\n    }\n    /**\n     * Removes any trailing operators from the Camel OGNL expression.\n     *\n     * @param ognlExpression  the Camel OGNL expression\n     * @return the Camel OGNL expression without any trailing operators.\n     */\n    public static String removeTrailingOperators(String ognlExpression) {\n        if (ObjectHelper.isEmpty(ognlExpression)) {\n            return ognlExpression;\n        }\n        if (ognlExpression.contains(\"[\")) {\n            return StringHelper.before(ognlExpression, \"[\");\n        }\n        return ognlExpression;\n    }\n    public static String removeOperators(String ognlExpression) {\n        return removeLeadingOperators(removeTrailingOperators(ognlExpression));\n    }\n    public static KeyValueHolder<String, String> isOgnlIndex(String ognlExpression) {\n        Matcher matcher = INDEX_PATTERN.matcher(ognlExpression);\n        if (matcher.matches()) {\n            // to avoid empty strings as we want key/value to be null in such cases\n            String key = matcher.group(1);\n            if (ObjectHelper.isEmpty(key)) {\n                key = null;\n            }\n            // to avoid empty strings as we want key/value to be null in such cases\n            String value = matcher.group(2);\n            if (ObjectHelper.isEmpty(value)) {\n                value = null;\n            }\n            return new KeyValueHolder<>(key, value);\n        }\n        return null;\n    }\n    /**\n     * Regular expression with repeating groups is a pain to get right\n     * and then nobody understands the reg exp afterwards.\n     * So we use a bit ugly/low-level Java code to split the OGNL into methods.\n     *\n     * @param ognl the ognl expression\n     * @return a list of methods, will return an empty list, if ognl expression has no methods\n     * @throws IllegalArgumentException if the last method has a missing ending parenthesis\n     */\n    public static List<String> splitOgnl(String ognl) {\n        List<String> methods = new ArrayList<>();\n        // return an empty list if ognl is empty\n        if (ObjectHelper.isEmpty(ognl)) {\n            return methods;\n        }\n        StringBuilder sb = new StringBuilder();\n        int j = 0; // j is used as counter per method\n        boolean squareBracket = false; // special to keep track if we are inside a square bracket block, eg: [foo]\n        boolean parenthesisBracket = false; // special to keep track if we are inside a parenthesis block, eg: bar(${body}, ${header.foo})\n        for (int i = 0; i < ognl.length(); i++) {\n            char ch = ognl.charAt(i);\n            // special for starting a new method\n            if (j == 0 || (j == 1 && ognl.charAt(i - 1) == '?')\n                    || (ch != '.' && ch != '?' && ch != ']')) {\n                sb.append(ch);\n                // special if we are doing square bracket\n                if (ch == '[' && !parenthesisBracket) {\n                    squareBracket = true;\n                } else if (ch == '(') {\n                    parenthesisBracket = true;\n                } else if (ch == ')') {\n                    parenthesisBracket = false;\n                }\n                j++; // advance\n            } else {\n                if (ch == '.' && !squareBracket && !parenthesisBracket) {\n                    // only treat dot as a method separator if not inside a square bracket block\n                    // as dots can be used in key names when accessing maps\n                    // a dit denotes end of this method and a new method is to be invoked\n                    String s = sb.toString();\n                    // reset sb\n                    sb.setLength(0);\n                    // pass over ? to the new method\n                    if (s.endsWith(\"?\")) {\n                        sb.append(\"?\");\n                        s = s.substring(0, s.length() - 1);\n                    }\n                    // add the method\n                    methods.add(s);\n                    // reset j to begin a new method\n                    j = 0;\n                } else if (ch == ']' && !parenthesisBracket) {\n                    // append ending ] to method name\n                    sb.append(ch);\n                    String s = sb.toString();\n                    // reset sb\n                    sb.setLength(0);\n                    // add the method\n                    methods.add(s);\n                    // reset j to begin a new method\n                    j = 0;\n                    // no more square bracket\n                    squareBracket = false;\n                }\n                // and don't lose the char if its not an ] end marker (as we already added that)\n                if (ch != ']' || parenthesisBracket) {\n                    sb.append(ch);\n                }\n                // only advance if already begun on the new method\n                if (j > 0) {\n                    j++;\n                }\n            }\n        }\n        // add remainder in buffer when reached end of data\n        if (sb.length() > 0) {\n            methods.add(sb.toString());\n        }<fim_middle>// class below is blob\n"}