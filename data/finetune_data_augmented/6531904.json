{"text": "<fim_prefix>\n<fim_suffix>@Component(service = RuleRegistry.class, immediate = true, property = { \"rule.reinitialization.delay:Long=500\" })\npublic class RuleRegistryImpl extends AbstractRegistry<Rule, String, RuleProvider>\n        implements RuleRegistry, RegistryChangeListener<RuleTemplate> {\n    /**\n     * Default value of delay between rule's re-initialization tries.\n     */\n    private static final long DEFAULT_REINITIALIZATION_DELAY = 500;\n    /**\n     * Delay between rule's re-initialization tries.\n     */\n    private static final String CONFIG_PROPERTY_REINITIALIZATION_DELAY = \"rule.reinitialization.delay\";\n    private static final String SOURCE = RuleRegistryImpl.class.getSimpleName();\n    private final Logger logger = LoggerFactory.getLogger(RuleRegistryImpl.class.getName());\n    /**\n     * Delay between rule's re-initialization tries.\n     */\n    private long scheduleReinitializationDelay;\n    private ModuleTypeRegistry moduleTypeRegistry;\n    private RuleTemplateRegistry templateRegistry;\n    /**\n     * {@link Map} of template UIDs to rules where these templates participated.\n     */\n    private final Map<String, Set<String>> mapTemplateToRules = new HashMap<String, Set<String>>();\n    /**\n     * Constructor that is responsible to invoke the super constructor with appropriate providerClazz\n     * {@link RuleProvider} - the class of the providers that should be tracked automatically after activation.\n     */\n    public RuleRegistryImpl() {\n        super(RuleProvider.class);\n    }\n    /**\n     * Activates this component. Called from DS.\n     *\n     * @param componentContext this component context.\n     */\n    @Activate\n    protected void activate(BundleContext bundleContext, Map<String, Object> properties) throws Exception {\n        modified(properties);\n        super.activate(bundleContext);\n    }\n    /**\n     * This method is responsible for updating the value of delay between rule's re-initialization tries.\n     *\n     * @param config a {@link Map} containing the new value of delay.\n     */\n    @Modified\n    protected void modified(Map<String, Object> config) {\n        Object value = config == null ? null : config.get(CONFIG_PROPERTY_REINITIALIZATION_DELAY);\n        this.scheduleReinitializationDelay = (value != null && value instanceof Number) ? (((Number) value).longValue())\n                : DEFAULT_REINITIALIZATION_DELAY;\n        if (value != null && !(value instanceof Number)) {\n            logger.warn(\"Invalid configuration value: {}. It MUST be Number.\", value);\n        }\n    }\n    @Override\n    @Deactivate\n    protected void deactivate() {\n        super.deactivate();\n    }\n    @Reference(cardinality = ReferenceCardinality.OPTIONAL, policy = ReferencePolicy.DYNAMIC)\n    @Override\n    protected void setEventPublisher(EventPublisher eventPublisher) {\n        super.setEventPublisher(eventPublisher);\n    }\n    @Override\n    protected void unsetEventPublisher(EventPublisher eventPublisher) {\n        super.unsetEventPublisher(eventPublisher);\n    }\n    @Reference(cardinality = ReferenceCardinality.OPTIONAL, policy = ReferencePolicy.DYNAMIC, name = \"ManagedRuleProvider\")\n    protected void setManagedProvider(ManagedRuleProvider managedProvider) {\n        super.setManagedProvider(managedProvider);\n    }\n    protected void unsetManagedProvider(ManagedRuleProvider managedProvider) {\n        super.unsetManagedProvider(managedProvider);\n    }\n    /**\n     * Bind the {@link ModuleTypeRegistry} service - called from DS.\n     *\n     * @param moduleTypeRegistry a {@link ModuleTypeRegistry} service.\n     */\n    @Reference(cardinality = ReferenceCardinality.MANDATORY, policy = ReferencePolicy.STATIC)\n    protected void setModuleTypeRegistry(ModuleTypeRegistry moduleTypeRegistry) {\n        this.moduleTypeRegistry = moduleTypeRegistry;\n    }\n    /**\n     * Unbind the {@link ModuleTypeRegistry} service - called from DS.\n     *\n     * @param moduleTypeRegistry a {@link ModuleTypeRegistry} service.\n     */\n    protected void unsetModuleTypeRegistry(ModuleTypeRegistry moduleTypeRegistry) {\n        this.moduleTypeRegistry = null;\n    }\n    /**\n     * Bind the {@link RuleTemplateRegistry} service - called from DS.\n     *\n     * @param templateRegistry a {@link RuleTemplateRegistry} service.\n     */\n    @Reference(cardinality = ReferenceCardinality.MANDATORY, policy = ReferencePolicy.STATIC)\n    protected void setTemplateRegistry(TemplateRegistry<RuleTemplate> templateRegistry) {\n        if (templateRegistry instanceof RuleTemplateRegistry) {\n            this.templateRegistry = (RuleTemplateRegistry) templateRegistry;\n            templateRegistry.addRegistryChangeListener(this);\n        }\n    }\n    /**\n     * Unbind the {@link RuleTemplateRegistry} service - called from DS.\n     *\n     * @param templateRegistry a {@link RuleTemplateRegistry} service.\n     */\n    protected void unsetTemplateRegistry(TemplateRegistry<RuleTemplate> templateRegistry) {\n        if (templateRegistry instanceof RuleTemplateRegistry) {\n            this.templateRegistry = null;\n            templateRegistry.removeRegistryChangeListener(this);\n        }\n    }\n    /**\n     * This method is used to register a {@link Rule} into the {@link RuleEngineImpl}. First the {@link Rule} become\n     * {@link RuleStatus#UNINITIALIZED}.\n     * Then verification procedure will be done and the Rule become {@link RuleStatus#IDLE}.\n     * If the verification fails, the Rule will stay {@link RuleStatus#UNINITIALIZED}.\n     *\n     * @param rule a {@link Rule} instance which have to be added into the {@link RuleEngineImpl}.\n     * @return a copy of the added {@link Rule}\n     * @throws RuntimeException\n     *                                  when passed module has a required configuration property and it is not specified\n     *                                  in rule definition\n     *                                  nor\n     *                                  in the module's module type definition.\n     * @throws IllegalArgumentException\n     *                                  when a module id contains dot or when the rule with the same UID already exists.\n     */\n    @Override\n    public Rule add(Rule rule) {\n        super.add(rule);\n        Rule ruleCopy = get(rule.getUID());\n        if (ruleCopy == null) {\n            throw new IllegalStateException();\n        }\n        return ruleCopy;\n    }\n    @Override\n    protected void notifyListenersAboutAddedElement(Rule element) {\n        postRuleAddedEvent(element);\n        postRuleStatusInfoEvent(element.getUID(), new RuleStatusInfo(RuleStatus.UNINITIALIZED));\n        super.notifyListenersAboutAddedElement(element);\n    }\n    @Override\n    protected void notifyListenersAboutUpdatedElement(Rule oldElement, Rule element) {\n        postRuleUpdatedEvent(element, oldElement);\n        super.notifyListenersAboutUpdatedElement(oldElement, element);\n    }\n    /**\n     * @see RuleRegistryImpl#postEvent(org.eclipse.smarthome.core.events.Event)\n     */\n    protected void postRuleAddedEvent(Rule rule) {\n        postEvent(RuleEventFactory.createRuleAddedEvent(rule, SOURCE));\n    }\n    /**\n     * @see RuleRegistryImpl#postEvent(org.eclipse.smarthome.core.events.Event)\n     */\n    protected void postRuleRemovedEvent(Rule rule) {\n        postEvent(RuleEventFactory.createRuleRemovedEvent(rule, SOURCE));\n    }\n    /**\n     * @see RuleRegistryImpl#postEvent(org.eclipse.smarthome.core.events.Event)\n     */\n    protected void postRuleUpdatedEvent(Rule rule, Rule oldRule) {\n        postEvent(RuleEventFactory.createRuleUpdatedEvent(rule, oldRule, SOURCE));\n    }\n    /**\n     * This method can be used in order to post events through the Eclipse SmartHome events bus. A common\n     * use case is to notify event subscribers about the {@link Rule}'s status change.\n     *\n     * @param ruleUID    the UID of the {@link Rule}, whose status is changed.\n     * @param statusInfo the new {@link Rule}s status.\n     */\n    protected void postRuleStatusInfoEvent(String ruleUID, RuleStatusInfo statusInfo) {\n        postEvent(RuleEventFactory.createRuleStatusInfoEvent(statusInfo, ruleUID, SOURCE));\n    }\n    @Override\n    protected void onRemoveElement(Rule rule) {\n        String uid = rule.getUID();\n        String templateUID = rule.getTemplateUID();\n        if (templateUID != null) {\n            updateRuleTemplateMapping(templateUID, uid, true);\n        }\n    }\n    @Override\n    protected void notifyListenersAboutRemovedElement(Rule element) {\n        super.notifyListenersAboutRemovedElement(element);\n        postRuleRemovedEvent(element);\n    }\n    @Override\n    public Collection<Rule> getByTag(String tag) {\n        Collection<Rule> result = new LinkedList<Rule>();\n        if (tag == null) {\n            forEach(result::add);\n        } else {\n            forEach(rule -> {\n                if (rule.getTags().contains(tag)) {\n                    result.add(rule);\n                }\n            });\n        }\n        return result;\n    }\n    @Override\n    public Collection<Rule> getByTags(String... tags) {<fim_middle>// class below is blob\n"}