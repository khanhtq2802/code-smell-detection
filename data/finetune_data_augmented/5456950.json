{"text": "<fim_prefix>                final String namespaceName = LoadManagerShared.getNamespaceNameFromBundleName(serviceUnitId);\n                final String bundleRange = LoadManagerShared.getBundleRangeFromBundleName(serviceUnitId);\n                ResourceQuota quota = this.getResourceQuota(serviceUnitId);\n                // Add preallocated bundle range so incoming bundles from the same namespace are not assigned to the\n                // same broker.\n                brokerToNamespaceToBundleRange\n                        .computeIfAbsent(selectedRU.getResourceId().replace(\"http://\", \"\"), k -> new HashMap<>())\n                        .computeIfAbsent(namespaceName, k -> new HashSet<>()).add(bundleRange);\n                ranking.addPreAllocatedServiceUnit(serviceUnitId, quota);\n                resourceUnitRankings.put(selectedRU, ranking);\n            }\n        }\n        return selectedRU;\n    }\n    private Multimap<Long, ResourceUnit> getFinalCandidates(ServiceUnitId serviceUnit,\n            Map<Long, Set<ResourceUnit>> availableBrokers) {\n        synchronized (brokerCandidateCache) {\n            final Multimap<Long, ResourceUnit> result = TreeMultimap.create();\n            availableBrokersCache.clear();\n            for (final Set<ResourceUnit> resourceUnits : availableBrokers.values()) {\n                for (final ResourceUnit resourceUnit : resourceUnits) {\n                    availableBrokersCache.add(resourceUnit.getResourceId().replace(\"http://\", \"\"));\n                }\n            }\n            brokerCandidateCache.clear();\n            try {\n                LoadManagerShared.applyNamespacePolicies(serviceUnit, policies, brokerCandidateCache, availableBrokersCache,\n                        brokerTopicLoadingPredicate);\n            } catch (Exception e) {\n                log.warn(\"Error when trying to apply policies: {}\", e);\n                for (final Map.Entry<Long, Set<ResourceUnit>> entry : availableBrokers.entrySet()) {\n                    result.putAll(entry.getKey(), entry.getValue());\n                }\n                return result;\n            }\n            // As long as there is at least one broker left, this will always leave brokerCandidateCache non-empty.\n            LoadManagerShared.removeMostServicingBrokersForNamespace(serviceUnit.toString(), brokerCandidateCache,\n                    brokerToNamespaceToBundleRange);\n            // After LoadManagerShared is finished applying the filter, put the results back into a multimap.\n            for (final Map.Entry<Long, Set<ResourceUnit>> entry : availableBrokers.entrySet()) {\n                final Long rank = entry.getKey();\n                final Set<ResourceUnit> resourceUnits = entry.getValue();\n                for (final ResourceUnit resourceUnit : resourceUnits) {\n                    if (brokerCandidateCache.contains(resourceUnit.getResourceId().replace(\"http://\", \"\"))) {\n                        result.put(rank, resourceUnit);\n                    }\n                }\n            }\n            return result;\n        }\n    }\n    public Optional<ResourceUnit> getLeastLoaded(ServiceUnitId serviceUnit) throws Exception {\n        return Optional.ofNullable(getLeastLoadedBroker(serviceUnit, getAvailableBrokers(serviceUnit)));\n    }\n    public Multimap<Long, ResourceUnit> getResourceAvailabilityFor(ServiceUnitId serviceUnitId) throws Exception {\n        return getFinalCandidates(serviceUnitId, getAvailableBrokers(serviceUnitId));\n    }\n    private Map<Long, Set<ResourceUnit>> getAvailableBrokers(ServiceUnitId serviceUnitId) throws Exception {\n        Map<Long, Set<ResourceUnit>> availableBrokers = sortedRankings.get();\n        // Normal case: we are the leader and we do have load reports information available\n        if (availableBrokers.isEmpty()) {\n            // Create a map with all available brokers with no load information\n            Set<String> activeBrokers = availableActiveBrokers.get(LOADBALANCE_BROKERS_ROOT);\n            List<String> brokersToShuffle = new ArrayList<>(activeBrokers);\n            Collections.shuffle(brokersToShuffle);\n            activeBrokers = new HashSet<>(brokersToShuffle);\n            availableBrokers = Maps.newTreeMap();\n            for (String broker : activeBrokers) {\n                ResourceUnit resourceUnit = new SimpleResourceUnit(String.format(\"http://%s\", broker),\n                        new PulsarResourceDescription());\n                availableBrokers.computeIfAbsent(0L, key -> Sets.newTreeSet()).add(resourceUnit);\n            }\n            log.info(\"Choosing at random from broker list: [{}]\", availableBrokers.values());\n        }\n        return availableBrokers;\n    }\n    private synchronized ResourceUnit getLeastLoadedBroker(ServiceUnitId serviceUnit,\n            Map<Long, Set<ResourceUnit>> availableBrokers) {\n        ResourceUnit selectedBroker = null;\n        // If the broker is already assigned, return that candidate.\n        for (final Map.Entry<ResourceUnit, ResourceUnitRanking> entry : resourceUnitRankings.entrySet()) {\n            final ResourceUnit resourceUnit = entry.getKey();\n            final ResourceUnitRanking ranking = entry.getValue();\n            if (ranking.isServiceUnitPreAllocated(serviceUnit.toString())) {\n                return resourceUnit;\n            }\n        }\n        Multimap<Long, ResourceUnit> finalCandidates = getFinalCandidates(serviceUnit, availableBrokers);\n        // Remove candidates that point to inactive brokers\n        Set<String> activeBrokers = Collections.emptySet();\n        try {\n            activeBrokers = availableActiveBrokers.get();\n            // Need to use an explicit Iterator object to prevent concurrent modification exceptions\n            Iterator<Map.Entry<Long, ResourceUnit>> candidateIterator = finalCandidates.entries().iterator();\n            while (candidateIterator.hasNext()) {\n                Map.Entry<Long, ResourceUnit> candidate = candidateIterator.next();\n                String candidateBrokerName = candidate.getValue().getResourceId().replace(\"http://\", \"\");\n                if (!activeBrokers.contains(candidateBrokerName)) {\n                    candidateIterator.remove(); // Current candidate points to an inactive broker, so remove it\n                }\n            }\n        } catch (Exception e) {\n            log.warn(\"Error during attempt to remove inactive brokers while searching for least active broker\", e);\n        }\n        if (finalCandidates.size() > 0) {\n            if (this.getLoadBalancerPlacementStrategy().equals(LOADBALANCER_STRATEGY_LLS)\n                    || this.getLoadBalancerPlacementStrategy().equals(LOADBALANCER_STRATEGY_LEAST_MSG)) {\n                selectedBroker = findBrokerForPlacement(finalCandidates, serviceUnit);\n            } else {\n                selectedBroker = placementStrategy.findBrokerForPlacement(finalCandidates);\n            }\n            log.info(\"Selected : [{}] for ServiceUnit : [{}]\", selectedBroker.getResourceId(), serviceUnit.toString());\n            return selectedBroker;\n        } else {\n            // No available broker found\n            log.warn(\"No broker available to acquire service unit: [{}]\", serviceUnit);\n            return null;\n        }\n    }\n    /*\n     * only update the report if a minute has elapsed since last update, since brokers update their report every minute.\n     *\n     * we should calculate the rank only for updated path but for now we read all the reports and re-calculate\n     * everything\n     */\n    @Override\n    public void onUpdate(String path, LoadReport data, Stat stat) {\n        log.debug(\"Received updated load report from broker node - [{}], scheduling re-ranking of brokers.\", path);\n        scheduler.submit(this::updateRanking);\n    }\n    private void updateRanking() {\n        try {\n            synchronized (currentLoadReports) {\n                currentLoadReports.clear();\n                Set<String> activeBrokers = availableActiveBrokers.get();\n                for (String broker : activeBrokers) {\n                    try {\n                        String key = String.format(\"%s/%s\", LOADBALANCE_BROKERS_ROOT, broker);\n                        LoadReport lr = loadReportCacheZk.get(key)\n                                .orElseThrow(() -> new KeeperException.NoNodeException());\n                        ResourceUnit ru = new SimpleResourceUnit(String.format(\"http://%s\", lr.getName()),\n                                fromLoadReport(lr));\n                        this.currentLoadReports.put(ru, lr);\n                    } catch (Exception e) {\n                        log.warn(\"Error reading load report from Cache for broker - [{}], [{}]\", broker, e);\n                    }\n                }\n                updateRealtimeResourceQuota();\n                doLoadRanking();\n            }\n        } catch (Exception e) {\n            log.warn(\"Error reading active brokers list from zookeeper while re-ranking load reports [{}]\", e);\n        }\n    }\n    public static boolean isAboveLoadLevel(SystemResourceUsage usage, float thresholdPercentage) {\n        return (usage.bandwidthOut.percentUsage() > thresholdPercentage\n                || usage.bandwidthIn.percentUsage() > thresholdPercentage\n                || usage.cpu.percentUsage() > thresholdPercentage\n                || usage.directMemory.percentUsage() > thresholdPercentage);\n    }\n<fim_suffix>    public static boolean isBelowLoadLevel(SystemResourceUsage usage, float thresholdPercentage) {\n        return (usage.bandwidthOut.percentUsage() < thresholdPercentage\n                && usage.bandwidthIn.percentUsage() < thresholdPercentage\n                && usage.cpu.percentUsage() < thresholdPercentage\n                && usage.directMemory.percentUsage() < thresholdPercentage);\n    }<fim_middle>// function below is feature envy\n"}