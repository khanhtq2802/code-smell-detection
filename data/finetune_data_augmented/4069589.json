{"text": "<fim_prefix>        long capacity = 0;\n        for (Section s : sections) {\n            capacity += s.capacity;\n        }\n        return capacity;\n    }\n    public boolean isEmpty() {\n        for (Section s : sections) {\n            if (s.size != 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    long getUsedBucketCount() {\n        long usedBucketCount = 0;\n        for (Section s : sections) {\n            usedBucketCount += s.usedBuckets;\n        }\n        return usedBucketCount;\n    }\n    public boolean contains(long item) {\n        checkBiggerEqualZero(item);\n        long h = hash(item);\n        return getSection(h).contains(item, (int) h);\n    }\n    public boolean add(long item) {\n        checkBiggerEqualZero(item);\n        long h = hash(item);\n        return getSection(h).add(item, (int) h);\n    }\n    /**\n     * Remove an existing entry if found.\n     *\n     * @param item\n     * @return true if removed or false if item was not present\n     */\n    public boolean remove(long item) {\n        checkBiggerEqualZero(item);\n        long h = hash(item);\n        return getSection(h).remove(item, (int) h);\n    }\n    private Section getSection(long hash) {\n        // Use 32 msb out of long to get the section\n        final int sectionIdx = (int) (hash >>> 32) & (sections.length - 1);\n        return sections[sectionIdx];\n    }\n    public void clear() {\n        for (Section s : sections) {\n            s.clear();\n        }\n    }\n    public void forEach(ConsumerLong processor) {\n        for (Section s : sections) {\n            s.forEach(processor);\n        }\n    }\n    /**\n     * @return a new list of all keys (makes a copy)\n     */\n    public Set<Long> items() {\n        Set<Long> items = new HashSet<>();\n        forEach(items::add);\n        return items;\n    }\n    // A section is a portion of the hash map that is covered by a single\n    @SuppressWarnings(\"serial\")\n    private static final class Section extends StampedLock {\n        // Keys and values are stored interleaved in the table array\n        private volatile long[] table;\n        private volatile int capacity;\n        private volatile int size;\n        private int usedBuckets;\n        private int resizeThreshold;\n        Section(int capacity) {\n            this.capacity = alignToPowerOfTwo(capacity);\n            this.table = new long[this.capacity];\n            this.size = 0;\n            this.usedBuckets = 0;\n            this.resizeThreshold = (int) (this.capacity * SetFillFactor);\n            Arrays.fill(table, EmptyItem);\n        }\n        boolean contains(long item, int hash) {\n            long stamp = tryOptimisticRead();\n            boolean acquiredLock = false;\n            int bucket = signSafeMod(hash, capacity);\n            try {\n                while (true) {\n                    // First try optimistic locking\n                    long storedItem = table[bucket];\n                    if (!acquiredLock && validate(stamp)) {\n                        // The values we have read are consistent\n                        if (item == storedItem) {\n                            return true;\n                        } else if (storedItem == EmptyItem) {\n                            // Not found\n                            return false;\n                        }\n                    } else {\n                        // Fallback to acquiring read lock\n                        if (!acquiredLock) {\n                            stamp = readLock();\n                            acquiredLock = true;\n                            bucket = signSafeMod(hash, capacity);\n                            storedItem = table[bucket];\n                        }\n                        if (item == storedItem) {\n                            return true;\n                        } else if (storedItem == EmptyItem) {\n                            // Not found\n                            return false;\n                        }\n                    }\n                    bucket = (bucket + 1) & (table.length - 1);\n                }\n            } finally {\n                if (acquiredLock) {\n                    unlockRead(stamp);\n                }\n            }\n        }\n        boolean add(long item, long hash) {\n            long stamp = writeLock();\n            int bucket = signSafeMod(hash, capacity);\n            // Remember where we find the first available spot\n            int firstDeletedItem = -1;\n            try {\n                while (true) {\n                    long storedItem = table[bucket];\n                    if (item == storedItem) {\n                        // Item was already in set\n                        return false;\n                    } else if (storedItem == EmptyItem) {\n                        // Found an empty bucket. This means the key is not in the map. If we've already seen a deleted\n                        // key, we should write at that position\n                        if (firstDeletedItem != -1) {\n                            bucket = firstDeletedItem;\n                        } else {\n                            ++usedBuckets;\n                        }\n                        table[bucket] = item;\n                        ++size;\n                        return true;\n                    } else if (storedItem == DeletedItem) {\n                        // The bucket contained a different deleted key\n                        if (firstDeletedItem == -1) {\n                            firstDeletedItem = bucket;\n                        }\n                    }\n                    bucket = (bucket + 1) & (table.length - 1);\n                }\n            } finally {\n                if (usedBuckets > resizeThreshold) {\n                    try {\n                        rehash();\n                    } finally {\n                        unlockWrite(stamp);\n                    }\n                } else {\n                    unlockWrite(stamp);\n                }\n            }\n        }\n        private boolean remove(long item, int hash) {\n            long stamp = writeLock();\n            int bucket = signSafeMod(hash, capacity);\n            try {\n                while (true) {\n                    long storedItem = table[bucket];\n                    if (item == storedItem) {\n                        --size;\n                        cleanBucket(bucket);\n                        return true;\n                    } else if (storedItem == EmptyItem) {\n                        // Key wasn't found\n                        return false;\n                    }\n                    bucket = (bucket + 1) & (table.length - 1);\n                }\n            } finally {\n                unlockWrite(stamp);\n            }\n        }\n        private void cleanBucket(int bucket) {\n            int nextInArray = (bucket + 1) & (table.length - 1);\n            if (table[nextInArray] == EmptyItem) {\n                table[bucket] = EmptyItem;\n                --usedBuckets;\n            } else {\n                table[bucket] = DeletedItem;\n            }\n        }\n        void clear() {\n            long stamp = writeLock();\n            try {\n                Arrays.fill(table, EmptyItem);\n                this.size = 0;\n                this.usedBuckets = 0;\n            } finally {\n                unlockWrite(stamp);\n            }\n        }\n        public void forEach(ConsumerLong processor) {\n            long stamp = tryOptimisticRead();\n            long[] table = this.table;\n            boolean acquiredReadLock = false;\n            try {\n                // Validate no rehashing\n                if (!validate(stamp)) {\n                    // Fallback to read lock\n                    stamp = readLock();\n                    acquiredReadLock = true;\n                    table = this.table;\n                }\n                // Go through all the buckets for this section\n                for (int bucket = 0; bucket < table.length; bucket++) {\n                    long storedItem = table[bucket];\n                    if (!acquiredReadLock && !validate(stamp)) {\n                        // Fallback to acquiring read lock\n                        stamp = readLock();\n                        acquiredReadLock = true;\n                        storedItem = table[bucket];\n                    }\n                    if (storedItem != DeletedItem && storedItem != EmptyItem) {\n                        processor.accept(storedItem);\n                    }\n                }\n            } finally {\n                if (acquiredReadLock) {\n                    unlockRead(stamp);\n                }\n            }\n        }\n        private void rehash() {\n            // Expand the hashmap\n            int newCapacity = capacity * 2;\n            long[] newTable = new long[newCapacity];\n            Arrays.fill(newTable, EmptyItem);\n            // Re-hash table\n            for (int i = 0; i < table.length; i++) {\n                long storedItem = table[i];\n                if (storedItem != EmptyItem && storedItem != DeletedItem) {\n                    insertKeyValueNoLock(newTable, newCapacity, storedItem);\n                }\n            }\n            table = newTable;\n            usedBuckets = size;\n            // Capacity needs to be updated after the values, so that we won't see\n            // a capacity value bigger than the actual array size\n            capacity = newCapacity;\n            resizeThreshold = (int) (capacity * SetFillFactor);\n        }\n        private static void insertKeyValueNoLock(long[] table, int capacity, long item) {\n            int bucket = signSafeMod(hash(item), capacity);\n            while (true) {\n                long storedKey = table[bucket];\n                if (storedKey == EmptyItem) {\n                    // The bucket is empty, so we can use it\n                    table[bucket] = item;\n                    return;\n                }\n                bucket = (bucket + 1) & (table.length - 1);\n            }\n        }\n    }\n    private static final long HashMixer = 0xc6a4a7935bd1e995L;\n    private static final int R = 47;\n<fim_suffix>    static final long hash(long key) {\n        long hash = key * HashMixer;\n        hash ^= hash >>> R;\n        hash *= HashMixer;\n        return hash;\n    }<fim_middle>// function below has no smell\n"}