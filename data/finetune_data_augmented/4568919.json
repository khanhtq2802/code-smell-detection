{"text": "<fim_prefix>                            if (glyphIdx < mtxTab.length) {\n                                mtxTab[glyphIdx].getUnicodeIndex().add(j);\n                            } else {\n                                log.debug(\"Glyph \" + glyphIdx\n                                                   + \" out of range: \"\n                                                   + mtxTab.length);\n                            }\n                            unicodeMappings.add(new UnicodeMapping(this, glyphIdx, j));\n                            if (glyphIdx < mtxTab.length) {\n                                mtxTab[glyphIdx].getUnicodeIndex().add(j);\n                            } else {\n                                log.debug(\"Glyph \" + glyphIdx\n                                                   + \" out of range: \"\n                                                   + mtxTab.length);\n                            }\n                            // Also add winAnsiWidth\n                            List<Integer> v = ansiIndex.get(j);\n                            if (v != null) {\n                                for (Integer aIdx : v) {\n                                    ansiWidth[aIdx] = mtxTab[glyphIdx].getWx();\n                                }\n                            }\n                            //getLogger().debug(\"IIdx: \" +\n                            //    mtxPtr +\n                            //    \" Delta: \" + cmap_deltas[i] +\n                            //    \" Unicode: \" + j +\n                            //    \" name: \" +\n                            //    mtxTab[(j+cmap_deltas[i]) & 0xffff].name);\n                        }\n                        if (glyphIdx < mtxTab.length) {\n                            if (mtxTab[glyphIdx].getUnicodeIndex().size() < 2) {\n                                mtxPtr++;\n                            }\n                        }\n                    }\n                }\n            }\n        } else if (cmapFormat == 12) {\n            long nGroups = fontFile.readTTFULong();\n            for (long i = 0; i < nGroups; ++i) {\n                long startCharCode = fontFile.readTTFULong();\n                long endCharCode = fontFile.readTTFULong();\n                long startGlyphCode = fontFile.readTTFULong();\n                if (startCharCode < 0 || startCharCode > 0x10FFFFL) {\n                    log.warn(\"startCharCode outside Unicode range\");\n                    continue;\n                }\n                if (startCharCode >= 0xD800 && startCharCode <= 0xDFFF) {\n                    log.warn(\"startCharCode is a surrogate pair: \" + startCharCode);\n                }\n                //endCharCode outside unicode range or is surrogate pair.\n                if (endCharCode > 0 && endCharCode < startCharCode || endCharCode > 0x10FFFFL) {\n                    log.warn(\"startCharCode outside Unicode range\");\n                    continue;\n                }\n                if (endCharCode >= 0xD800 && endCharCode <= 0xDFFF) {\n                    log.warn(\"endCharCode is a surrogate pair: \" + startCharCode);\n                }\n                for (long offset = 0; offset <= endCharCode - startCharCode; ++offset) {\n                    long glyphIndexL = startGlyphCode + offset;\n                    long charCodeL = startCharCode + offset;\n                    if (glyphIndexL >= numberOfGlyphs) {\n                        log.warn(\"Format 12 cmap contains an invalid glyph index\");\n                        break;\n                    }\n                    if (charCodeL > 0x10FFFFL) {\n                        log.warn(\"Format 12 cmap contains character beyond UCS-4\");\n                    }\n                    if (glyphIndexL > Integer.MAX_VALUE) {\n                        log.error(\"glyphIndex > Integer.MAX_VALUE\");\n                        continue;\n                    }\n                    if (charCodeL > Integer.MAX_VALUE) {\n                        log.error(\"startCharCode + j > Integer.MAX_VALUE\");\n                        continue;\n                    }\n                    // Update lastChar\n                    if (charCodeL < 0xFF && charCodeL > lastChar) {\n                        lastChar = (short) charCodeL;\n                    }\n                    int charCode = (int) charCodeL;\n                    int glyphIndex = (int) glyphIndexL;\n                    // Also add winAnsiWidth.\n                    List<Integer> ansiIndexes = null;\n                    if (charCodeL <= Character.MAX_VALUE) {\n                        ansiIndexes = ansiIndex.get((int) charCodeL);\n                    }\n                    unicodeMappings.add(new UnicodeMapping(this, glyphIndex, charCode));\n                    mtxTab[glyphIndex].getUnicodeIndex().add(charCode);\n                    if (ansiIndexes == null) {\n                        continue;\n                    }\n                    for (Integer aIdx : ansiIndexes) {\n                        ansiWidth[aIdx] = mtxTab[glyphIndex].getWx();\n                        if (log.isTraceEnabled()) {\n                            log.trace(\"Added width \"\n                                    + mtxTab[glyphIndex].getWx()\n                                    + \" uni: \" + offset\n                                    + \" ansi: \" + aIdx);\n                        }\n                    }\n                }\n            }\n        } else {\n            log.error(\"Cmap format not supported: \" + cmapFormat);\n            return false;\n        }\n        return true;\n    }\n    private boolean isInPrivateUseArea(int start, int end) {\n        return (isInPrivateUseArea(start) || isInPrivateUseArea(end));\n    }\n    private boolean isInPrivateUseArea(int unicode) {\n        return (unicode >= 0xE000 && unicode <= 0xF8FF);\n    }\n    /**\n     *\n     * @return mmtx data\n     */\n    public List<OFMtxEntry> getMtx() {\n        return Collections.unmodifiableList(Arrays.asList(mtxTab));\n    }\n    /**\n     * Print first char/last char\n     */\n    /* not used\n    private void printMaxMin() {\n        int min = 255;\n        int max = 0;\n        for (int i = 0; i < mtxTab.length; i++) {\n            if (mtxTab[i].getIndex() < min) {\n                min = mtxTab[i].getIndex();\n            }\n            if (mtxTab[i].getIndex() > max) {\n                max = mtxTab[i].getIndex();\n            }\n        }\n        log.info(\"Min: \" + min);\n        log.info(\"Max: \" + max);\n    }\n    */\n    /**\n     * Reads the font using a FontFileReader.\n     *\n     * @param in The FontFileReader to use\n     * @throws IOException In case of an I/O problem\n     */\n    public void readFont(FontFileReader in, String header) throws IOException {\n        readFont(in, header, (String)null);\n    }\n    /**\n     * initialize the ansiWidths array (for winAnsiEncoding)\n     * and fill with the missingwidth\n     */\n    protected void initAnsiWidths() {\n        ansiWidth = new int[256];\n        for (int i = 0; i < 256; i++) {\n            ansiWidth[i] = mtxTab[0].getWx();\n        }\n        // Create an index hash to the ansiWidth\n        // Can't just index the winAnsiEncoding when inserting widths\n        // same char (eg bullet) is repeated more than one place\n        ansiIndex = new HashMap<Integer, List<Integer>>();\n        for (int i = 32; i < Glyphs.WINANSI_ENCODING.length; i++) {\n            Integer ansi = i;\n            Integer uni = (int) Glyphs.WINANSI_ENCODING[i];\n            List<Integer> v = ansiIndex.get(uni);\n            if (v == null) {\n                v = new ArrayList<Integer>();\n                ansiIndex.put(uni, v);\n            }\n            v.add(ansi);\n        }\n    }\n    /**\n     * Read the font data.\n     * If the fontfile is a TrueType Collection (.ttc file)\n     * the name of the font to read data for must be supplied,\n     * else the name is ignored.\n     *\n     * @param in The FontFileReader to use\n     * @param name The name of the font\n     * @return boolean Returns true if the font is valid\n     * @throws IOException In case of an I/O problem\n     */\n<fim_suffix>    public boolean readFont(FontFileReader in, String header, String name) throws IOException {\n        initializeFont(in);\n        /*\n         * Check if TrueType collection, and that the name\n         * exists in the collection\n         */\n        if (!checkTTC(header, name)) {\n            if (name == null) {\n                throw new IllegalArgumentException(\n                    \"For TrueType collection you must specify which font \"\n                    + \"to select (-ttcname)\");\n            } else {\n                throw new IOException(\n                    \"Name does not exist in the TrueType collection: \" + name);\n            }\n        }\n        readDirTabs();\n        readFontHeader();\n        getNumGlyphs();\n        if (log.isDebugEnabled()) {\n            log.debug(\"Number of glyphs in font: \" + numberOfGlyphs);\n        }\n        readHorizontalHeader();\n        readHorizontalMetrics();\n        initAnsiWidths();\n        readPostScript();\n        readOS2();\n        determineAscDesc();\n        readName();\n        boolean pcltFound = readPCLT();\n        // Read cmap table and fill in ansiwidths\n        boolean valid = readCMAP();\n        if (!valid) {\n            return false;\n        }\n        // Create cmaps for bfentries\n        createCMaps();\n        updateBBoxAndOffset();\n        if (useKerning) {\n            readKerning();\n        }\n        handleCharacterSpacing(in);\n        guessVerticalMetricsFromGlyphBBox();\n        return true;\n    }<fim_middle>// function below is long method\n"}