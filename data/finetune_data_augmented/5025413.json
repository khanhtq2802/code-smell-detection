{"text": "<fim_prefix>    also higher in the hierarchy depending on the value of the\n    additivity flag.\n    <p><b>WARNING</b> Note that passing a {@link Throwable} to this\n    method will print the name of the Throwable but no stack trace. To\n    print a stack trace use the {@link #info(Object, Throwable)} form\n    instead.\n    @param message the message object to log */\n  public\n  void info(Object message) {\n    if(repository.isDisabled(Level.INFO_INT)) {\n        return;\n    }\n    if(Level.INFO.isGreaterOrEqual(this.getEffectiveLevel())) {\n        forcedLog(FQCN, Level.INFO, message, null);\n    }\n  }\n  /**\n   Log a message object with the <code>INFO</code> level including\n   the stack trace of the {@link Throwable} <code>t</code> passed as\n   parameter.\n   <p>See {@link #info(Object)} for more detailed information.\n   @param message the message object to log.\n   @param t the exception to log, including its stack trace.  */\n  public\n  void info(Object message, Throwable t) {\n    if(repository.isDisabled(Level.INFO_INT)) {\n        return;\n    }\n    if(Level.INFO.isGreaterOrEqual(this.getEffectiveLevel())) {\n        forcedLog(FQCN, Level.INFO, message, t);\n    }\n  }\n  /**\n     Is the appender passed as parameter attached to this category?\n   */\n  public\n  boolean isAttached(Appender appender) {\n    if(appender == null || aai == null) {\n        return false;\n    } else {\n      return aai.isAttached(appender);\n    }\n  }\n  /**\n    *  Check whether this category is enabled for the <code>DEBUG</code>\n    *  Level.\n    *\n    *  <p> This function is intended to lessen the computational cost of\n    *  disabled log debug statements.\n    *\n    *  <p> For some <code>cat</code> Category object, when you write,\n    *  <pre>\n    *      cat.debug(\"This is entry number: \" + i );\n    *  </pre>\n    *\n    *  <p>You incur the cost constructing the message, concatenatiion in\n    *  this case, regardless of whether the message is logged or not.\n    *\n    *  <p>If you are worried about speed, then you should write\n    *  <pre>\n    * \t if(cat.isDebugEnabled()) {\n    * \t   cat.debug(\"This is entry number: \" + i );\n    * \t }\n    *  </pre>\n    *\n    *  <p>This way you will not incur the cost of parameter\n    *  construction if debugging is disabled for <code>cat</code>. On\n    *  the other hand, if the <code>cat</code> is debug enabled, you\n    *  will incur the cost of evaluating whether the category is debug\n    *  enabled twice. Once in <code>isDebugEnabled</code> and once in\n    *  the <code>debug</code>.  This is an insignificant overhead\n    *  since evaluating a category takes about 1%% of the time it\n    *  takes to actually log.\n    *\n    *  @return boolean - <code>true</code> if this category is debug\n    *  enabled, <code>false</code> otherwise.\n    *   */\n  public\n  boolean isDebugEnabled() {\n    if(repository.isDisabled( Level.DEBUG_INT)) {\n        return false;\n    }\n    return Level.DEBUG.isGreaterOrEqual(this.getEffectiveLevel());\n  }\n  /**\n     Check whether this category is enabled for a given {@link\n     Level} passed as parameter.\n     See also {@link #isDebugEnabled}.\n     @return boolean True if this category is enabled for <code>level</code>.\n  */\n  public\n  boolean isEnabledFor(Priority level) {\n    if(repository.isDisabled(level.level)) {\n        return false;\n    }\n    return level.isGreaterOrEqual(this.getEffectiveLevel());\n  }\n  /**\n    Check whether this category is enabled for the info Level.\n    See also {@link #isDebugEnabled}.\n    @return boolean - <code>true</code> if this category is enabled\n    for level info, <code>false</code> otherwise.\n  */\n  public\n  boolean isInfoEnabled() {\n    if(repository.isDisabled(Level.INFO_INT)) {\n        return false;\n    }\n    return Level.INFO.isGreaterOrEqual(this.getEffectiveLevel());\n  }\n  /**\n     Log a localized message. The user supplied parameter\n     <code>key</code> is replaced by its localized version from the\n     resource bundle.\n     @see #setResourceBundle\n     @since 0.8.4 */\n  public\n  void l7dlog(Priority priority, String key, Throwable t) {\n    if(repository.isDisabled(priority.level)) {\n      return;\n    }\n    if(priority.isGreaterOrEqual(this.getEffectiveLevel())) {\n      String msg = getResourceBundleString(key);\n      // if message corresponding to 'key' could not be found in the\n      // resource bundle, then default to 'key'.\n      if(msg == null) {\n\tmsg = key;\n      }\n      forcedLog(FQCN, priority, msg, t);\n    }\n  }\n  /**\n     Log a localized and parameterized message. First, the user\n     supplied <code>key</code> is searched in the resource\n     bundle. Next, the resulting pattern is formatted using\n     {@link java.text.MessageFormat#format(String,Object[])} method with the\n     user supplied object array <code>params</code>.\n     @since 0.8.4\n  */\n  public\n  void l7dlog(Priority priority, String key,  Object[] params, Throwable t) {\n    if(repository.isDisabled(priority.level)) {\n      return;\n    }\n    if(priority.isGreaterOrEqual(this.getEffectiveLevel())) {\n      String pattern = getResourceBundleString(key);\n      String msg;\n      if(pattern == null) {\n        msg = key;\n    } else {\n        msg = java.text.MessageFormat.format(pattern, params);\n    }\n      forcedLog(FQCN, priority, msg, t);\n    }\n  }\n  /**\n     This generic form is intended to be used by wrappers.\n   */\n  public\n  void log(Priority priority, Object message, Throwable t) {\n    if(repository.isDisabled(priority.level)) {\n      return;\n    }\n    if(priority.isGreaterOrEqual(this.getEffectiveLevel())) {\n        forcedLog(FQCN, priority, message, t);\n    }\n  }\n /**\n    This generic form is intended to be used by wrappers.\n */\n  public\n  void log(Priority priority, Object message) {\n    if(repository.isDisabled(priority.level)) {\n      return;\n    }\n    if(priority.isGreaterOrEqual(this.getEffectiveLevel())) {\n        forcedLog(FQCN, priority, message, null);\n    }\n  }\n  /**\n     This is the most generic printing method. It is intended to be\n     invoked by <b>wrapper</b> classes.\n     @param callerFQCN The wrapper class' fully qualified class name.\n     @param level The level of the logging request.\n     @param message The message of the logging request.\n     @param t The throwable of the logging request, may be null.  */\n  public\n  void log(String callerFQCN, Priority level, Object message, Throwable t) {\n    if(repository.isDisabled(level.level)) {\n      return;\n    }\n    if(level.isGreaterOrEqual(this.getEffectiveLevel())) {\n      forcedLog(callerFQCN, level, message, t);\n    }\n  }\n    /**\n      *  LoggerRepository forgot the fireRemoveAppenderEvent method,\n      *     if using the stock Hierarchy implementation, then call its fireRemove.\n      *     Custom repositories can implement HierarchyEventListener if they\n      *     want remove notifications.\n     * @param appender appender, may be null.\n     */\n   private void fireRemoveAppenderEvent(final Appender appender) {\n       if (appender != null) {\n         if (repository instanceof Hierarchy) {\n           ((Hierarchy) repository).fireRemoveAppenderEvent(this, appender);\n         } else if (repository instanceof HierarchyEventListener) {\n             ((HierarchyEventListener) repository).removeAppenderEvent(this, appender);\n         }\n       }\n   }\n  /**\n     Remove all previously added appenders from this Category\n     instance.\n     <p>This is useful when re-reading configuration information.\n  */\n<fim_suffix>  synchronized\n  public\n  void removeAllAppenders() {\n    if(aai != null) {\n      Vector appenders = new Vector();\n      for (Enumeration iter = aai.getAllAppenders(); iter != null && iter.hasMoreElements();) {\n          appenders.add(iter.nextElement());\n      }\n      aai.removeAllAppenders();\n      for(Enumeration iter = appenders.elements(); iter.hasMoreElements();) {\n          fireRemoveAppenderEvent((Appender) iter.nextElement());\n      }\n      aai = null;\n    }\n  }<fim_middle>// function below has no smell\n"}