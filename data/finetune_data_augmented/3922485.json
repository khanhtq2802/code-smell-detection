{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.aries.rsa.provider.fastbin.tcp;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.URI;\nimport java.net.UnknownHostException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ReadableByteChannel;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.SocketChannel;\nimport java.nio.channels.WritableByteChannel;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.concurrent.TimeUnit;\nimport org.apache.aries.rsa.provider.fastbin.io.ProtocolCodec;\nimport org.apache.aries.rsa.provider.fastbin.io.Transport;\nimport org.apache.aries.rsa.provider.fastbin.io.TransportListener;\nimport org.fusesource.hawtdispatch.Dispatch;\nimport org.fusesource.hawtdispatch.DispatchQueue;\nimport org.fusesource.hawtdispatch.DispatchSource;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\npublic class TcpTransport implements Transport {\n    private static final Logger LOG = LoggerFactory.getLogger(TcpTransport.class);\n    protected State _serviceState = new CREATED();\n    protected Map<String, Object> socketOptions;\n    protected URI remoteLocation;\n    protected URI localLocation;\n    protected TransportListener listener;\n    protected String remoteAddress;\n    protected ProtocolCodec codec;\n    protected SocketChannel channel;\n    protected SocketState socketState = new DISCONNECTED();\n    protected DispatchQueue dispatchQueue;\n    private DispatchSource readSource;\n    private DispatchSource writeSource;\n    protected boolean useLocalHost = true;\n    int max_read_rate;\n    int max_write_rate;\n    protected RateLimitingChannel rateLimitingChannel;\n    boolean drained = true;\n    private final Runnable CANCEL_HANDLER = new Runnable() {\n        public void run() {\n            socketState.onCanceled();\n        }\n    };\n    final public void start() {\n        start(null);\n    }\n    final public void stop() {\n        stop(null);\n    }\n    final public void start(final Runnable onCompleted) {\n        queue().execute(new Runnable() {\n            public void run() {\n                if (_serviceState.isCreated() || _serviceState.isStopped()) {\n                    final STARTING state = new STARTING();\n                    state.add(onCompleted);\n                    _serviceState = state;\n                    _start(new Runnable() {\n                        public void run() {\n                            _serviceState = new STARTED();\n                            state.done();\n                        }\n                    });\n                } else if (_serviceState.isStarting()) {\n                    _serviceState.add(onCompleted);\n                } else if (_serviceState.isStarted()) {\n                    if (onCompleted != null) {\n                        onCompleted.run();\n                    }\n                } else {\n                    if (onCompleted != null) {\n                        onCompleted.run();\n                    }\n                    LOG.error(\"start should not be called from state: \" + _serviceState);\n                }\n            }\n        });\n    }\n    final public void stop(final Runnable onCompleted) {\n        queue().execute(new Runnable() {\n            public void run() {\n                if (_serviceState instanceof STARTED) {\n                    final STOPPING state = new STOPPING();\n                    state.add(onCompleted);\n                    _serviceState = state;\n                    _stop(new Runnable() {\n                        public void run() {\n                            _serviceState = new STOPPED();\n                            state.done();\n                        }\n                    });\n                } else if (_serviceState instanceof STOPPING) {\n                    _serviceState.add(onCompleted);\n                } else if (_serviceState instanceof STOPPED) {\n                    if (onCompleted != null) {\n                        onCompleted.run();\n                    }\n                } else {\n                    if (onCompleted != null) {\n                        onCompleted.run();\n                    }\n                    LOG.error(\"stop should not be called from state: \" + _serviceState);\n                }\n            }\n        });\n    }\n    protected State getServiceState() {\n        return _serviceState;\n    }\n<fim_suffix>    public void connected(SocketChannel channel) throws IOException, Exception {\n        this.channel = channel;\n        if( codec !=null ) {\n            initializeCodec();\n        }\n        this.channel.configureBlocking(false);\n        this.remoteAddress = channel.socket().getRemoteSocketAddress().toString();\n        channel.socket().setSoLinger(true, 0);\n        channel.socket().setTcpNoDelay(true);\n        this.socketState = new CONNECTED();\n    }\n    protected void initializeCodec() {\n        codec.setReadableByteChannel(readChannel());\n        codec.setWritableByteChannel(writeChannel());\n    }\n    public void connecting(URI remoteLocation, URI localLocation) throws IOException, Exception {\n        this.channel = SocketChannel.open();\n        this.channel.configureBlocking(false);\n        this.remoteLocation = remoteLocation;\n        this.localLocation = localLocation;\n        if (localLocation != null) {\n            InetSocketAddress localAddress = new InetSocketAddress(InetAddress.getByName(localLocation.getHost()), localLocation.getPort());\n            channel.socket().bind(localAddress);\n        }\n        String host = resolveHostName(remoteLocation.getHost());\n        InetSocketAddress remoteAddress = new InetSocketAddress(host, remoteLocation.getPort());\n        channel.connect(remoteAddress);\n        this.socketState = new CONNECTING();\n    }\n    public DispatchQueue queue() {\n        return dispatchQueue;\n    }\n    public void setDispatchQueue(DispatchQueue queue) {\n        this.dispatchQueue = queue;\n    }\n    public void _start(Runnable onCompleted) {\n        try {\n            if (socketState.isConnecting()) {\n                trace(\"connecting...\");\n                // this allows the connect to complete..\n                readSource = Dispatch.createSource(channel, SelectionKey.OP_CONNECT, dispatchQueue);\n                readSource.setEventHandler(new Runnable() {\n                    public void run() {\n                        if (!(getServiceState().isStarted())) {\n                            return;\n                        }\n                        try {\n                            trace(\"connected.\");\n                            channel.finishConnect();\n                            readSource.setCancelHandler(null);\n                            readSource.cancel();\n                            readSource=null;\n                            socketState = new CONNECTED();\n                            onConnected();\n                        } catch (IOException e) {\n                            onTransportFailure(e);\n                        }\n                    }\n                });\n                readSource.setCancelHandler(CANCEL_HANDLER);\n                readSource.resume();\n            } else if (socketState.isConnected()) {\n                dispatchQueue.execute(new Runnable() {\n                    public void run() {\n                        try {\n                            trace(\"was connected.\");\n                            onConnected();\n                        } catch (IOException e) {\n                             onTransportFailure(e);\n                        }\n                    }\n                });\n            } else {\n                System.err.println(\"cannot be started.  socket state is: \"+socketState);\n            }\n        } finally {\n            if( onCompleted!=null ) {\n                onCompleted.run();\n            }\n        }\n    }\n    public void _stop(final Runnable onCompleted) {\n        trace(\"stopping.. at state: \"+socketState);\n        socketState.onStop(onCompleted);\n    }\n    protected String resolveHostName(String host) throws UnknownHostException {\n        try {\n            if(isUseLocalHost()) {\n                String localName = InetAddress.getLocalHost().getHostName();\n                if (localName != null) {\n                    if (localName.equals(host)) {\n                        return \"localhost\";\n                    }\n                }\n            }\n        } catch (Exception e) {\n            LOG.warn(\"Failed to resolve local host address\",e);\n        }\n        return host;\n    }\n    protected void onConnected() throws IOException {\n        readSource = Dispatch.createSource(channel, SelectionKey.OP_READ, dispatchQueue);\n        writeSource = Dispatch.createSource(channel, SelectionKey.OP_WRITE, dispatchQueue);\n        readSource.setCancelHandler(CANCEL_HANDLER);\n        writeSource.setCancelHandler(CANCEL_HANDLER);\n        readSource.setEventHandler(new Runnable() {\n            public void run() {\n                drainInbound();\n            }\n        });\n        writeSource.setEventHandler(new Runnable() {\n            public void run() {\n                drainOutbound();\n            }\n        });\n        if( max_read_rate!=0 || max_write_rate!=0 ) {\n            rateLimitingChannel = new RateLimitingChannel();\n            schedualRateAllowanceReset();\n        }\n        remoteAddress = channel.socket().getRemoteSocketAddress().toString();\n        listener.onTransportConnected(this);\n    }\n    private void schedualRateAllowanceReset() {<fim_middle>// function below is feature envy\n"}