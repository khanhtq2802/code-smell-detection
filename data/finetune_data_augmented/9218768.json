{"text": "<fim_prefix>                                K ek;\n                                if (e.hash == h &&\n                                    ((ek = e.key) == key ||\n                                     (ek != null && key.equals(ek)))) {\n                                    val = remappingFunction.apply(key, e.val);\n                                    if (val != null)\n                                        e.val = val;\n                                    else {\n                                        delta = -1;\n                                        Node<K,V> en = e.next;\n                                        if (pred != null)\n                                            pred.next = en;\n                                        else\n                                            setTabAt(tab, i, en);\n                                    }\n                                    break;\n                                }\n                                pred = e;\n                                if ((e = e.next) == null) {\n                                    val = remappingFunction.apply(key, null);\n                                    if (val != null) {\n                                        if (pred.next != null)\n                                            throw new IllegalStateException(\"Recursive update\");\n                                        delta = 1;\n                                        pred.next = new Node<K,V>(h, key, val);\n                                    }\n                                    break;\n                                }\n                            }\n                        }\n                        else if (f instanceof TreeBin) {\n                            binCount = 1;\n                            TreeBin<K,V> t = (TreeBin<K,V>)f;\n                            TreeNode<K,V> r, p;\n                            if ((r = t.root) != null)\n                                p = r.findTreeNode(h, key, null);\n                            else\n                                p = null;\n                            V pv = (p == null) ? null : p.val;\n                            val = remappingFunction.apply(key, pv);\n                            if (val != null) {\n                                if (p != null)\n                                    p.val = val;\n                                else {\n                                    delta = 1;\n                                    t.putTreeVal(h, key, val);\n                                }\n                            }\n                            else if (p != null) {\n                                delta = -1;\n                                if (t.removeTreeNode(p))\n                                    setTabAt(tab, i, untreeify(t.first));\n                            }\n                        }\n                        else if (f instanceof ReservationNode)\n                            throw new IllegalStateException(\"Recursive update\");\n                    }\n                }\n                if (binCount != 0) {\n                    if (binCount >= TREEIFY_THRESHOLD)\n                        treeifyBin(tab, i);\n                    break;\n                }\n            }\n        }\n        if (delta != 0)\n            addCount((long)delta, binCount);\n        return val;\n    }\n    /**\n     * If the specified key is not already associated with a\n     * (non-null) value, associates it with the given value.\n     * Otherwise, replaces the value with the results of the given\n     * remapping function, or removes if {@code null}. The entire\n     * method invocation is performed atomically.  Some attempted\n     * update operations on this map by other threads may be blocked\n     * while computation is in progress, so the computation should be\n     * short and simple, and must not attempt to update any other\n     * mappings of this Map.\n     *\n     * @param key key with which the specified value is to be associated\n     * @param value the value to use if absent\n     * @param remappingFunction the function to recompute a value if present\n     * @return the new value associated with the specified key, or null if none\n     * @throws NullPointerException if the specified key or the\n     *         remappingFunction is null\n     * @throws RuntimeException or Error if the remappingFunction does so,\n     *         in which case the mapping is unchanged\n     */\n    public V merge(K key, V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction) {\n        if (key == null || value == null || remappingFunction == null)\n            throw new NullPointerException();\n        int h = spread(key.hashCode());\n        V val = null;\n        int delta = 0;\n        int binCount = 0;\n        for (Node<K,V>[] tab = table;;) {\n            Node<K,V> f; int n, i, fh;\n            if (tab == null || (n = tab.length) == 0)\n                tab = initTable();\n            else if ((f = tabAt(tab, i = (n - 1) & h)) == null) {\n                if (casTabAt(tab, i, null, new Node<K,V>(h, key, value))) {\n                    delta = 1;\n                    val = value;\n                    break;\n                }\n            }\n            else if ((fh = f.hash) == MOVED)\n                tab = helpTransfer(tab, f);\n            else {\n                synchronized (f) {\n                    if (tabAt(tab, i) == f) {\n                        if (fh >= 0) {\n                            binCount = 1;\n                            for (Node<K,V> e = f, pred = null;; ++binCount) {\n                                K ek;\n                                if (e.hash == h &&\n                                    ((ek = e.key) == key ||\n                                     (ek != null && key.equals(ek)))) {\n                                    val = remappingFunction.apply(e.val, value);\n                                    if (val != null)\n                                        e.val = val;\n                                    else {\n                                        delta = -1;\n                                        Node<K,V> en = e.next;\n                                        if (pred != null)\n                                            pred.next = en;\n                                        else\n                                            setTabAt(tab, i, en);\n                                    }\n                                    break;\n                                }\n                                pred = e;\n                                if ((e = e.next) == null) {\n                                    delta = 1;\n                                    val = value;\n                                    pred.next = new Node<K,V>(h, key, val);\n                                    break;\n                                }\n                            }\n                        }\n                        else if (f instanceof TreeBin) {\n                            binCount = 2;\n                            TreeBin<K,V> t = (TreeBin<K,V>)f;\n                            TreeNode<K,V> r = t.root;\n                            TreeNode<K,V> p = (r == null) ? null :\n                                r.findTreeNode(h, key, null);\n                            val = (p == null) ? value :\n                                remappingFunction.apply(p.val, value);\n                            if (val != null) {\n                                if (p != null)\n                                    p.val = val;\n                                else {\n                                    delta = 1;\n                                    t.putTreeVal(h, key, val);\n                                }\n                            }\n                            else if (p != null) {\n                                delta = -1;\n                                if (t.removeTreeNode(p))\n                                    setTabAt(tab, i, untreeify(t.first));\n                            }\n                        }\n                        else if (f instanceof ReservationNode)\n                            throw new IllegalStateException(\"Recursive update\");\n                    }\n                }\n                if (binCount != 0) {\n                    if (binCount >= TREEIFY_THRESHOLD)\n                        treeifyBin(tab, i);\n                    break;\n                }\n            }\n        }\n        if (delta != 0)\n            addCount((long)delta, binCount);\n        return val;\n    }\n    // Hashtable legacy methods\n    /**\n     * Tests if some key maps into the specified value in this table.\n     *\n     * <p>Note that this method is identical in functionality to\n     * {@link #containsValue(Object)}, and exists solely to ensure\n     * full compatibility with class {@link java.util.Hashtable},\n     * which supported this method prior to introduction of the\n     * Java Collections Framework.\n     *\n     * @param  value a value to search for\n     * @return {@code true} if and only if some key maps to the\n     *         {@code value} argument in this table as\n     *         determined by the {@code equals} method;\n     *         {@code false} otherwise\n     * @throws NullPointerException if the specified value is null\n     */\n    public boolean contains(Object value) {\n        return containsValue(value);\n    }\n    /**\n     * Returns an enumeration of the keys in this table.\n     *\n     * @return an enumeration of the keys in this table\n     * @see #keySet()\n     */\n<fim_suffix>    public Enumeration<K> keys() {\n        Node<K,V>[] t;\n        int f = (t = table) == null ? 0 : t.length;\n        return new KeyIterator<K,V>(t, f, 0, f, this);\n    }<fim_middle>// function below has no smell\n"}