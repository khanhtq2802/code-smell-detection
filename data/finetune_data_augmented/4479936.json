{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.drill.common.expression;\nimport java.math.BigDecimal;\nimport java.util.Collections;\nimport java.util.GregorianCalendar;\nimport java.util.Iterator;\nimport org.apache.drill.shaded.guava.com.google.common.collect.ImmutableList;\nimport org.apache.drill.common.expression.visitors.ExprVisitor;\nimport org.apache.drill.common.types.TypeProtos.DataMode;\nimport org.apache.drill.common.types.TypeProtos.MajorType;\nimport org.apache.drill.common.types.TypeProtos.MinorType;\nimport org.apache.drill.common.types.Types;\npublic class ValueExpressions {\n  public static LogicalExpression getBigInt(long l){\n    return new LongExpression(l);\n  }\n  public static LogicalExpression getInt(int i){\n    return new IntExpression(i, ExpressionPosition.UNKNOWN);\n  }\n  public static LogicalExpression getFloat8(double d){\n    return new DoubleExpression(d, ExpressionPosition.UNKNOWN);\n  }\n  public static LogicalExpression getFloat4(float f){\n    return new FloatExpression(f, ExpressionPosition.UNKNOWN);\n  }\n  public static LogicalExpression getBit(boolean b){\n    return new BooleanExpression(Boolean.toString(b), ExpressionPosition.UNKNOWN);\n  }\n  public static LogicalExpression getChar(String s, int precision){\n    return new QuotedString(s, precision, ExpressionPosition.UNKNOWN);\n  }\n  public static LogicalExpression getDate(GregorianCalendar date) {\n    return new org.apache.drill.common.expression.ValueExpressions.DateExpression(date.getTimeInMillis());\n  }\n  public static LogicalExpression getDate(long milliSecond){\n    return new org.apache.drill.common.expression.ValueExpressions.DateExpression(milliSecond);\n  }\n  public static LogicalExpression getTime(GregorianCalendar time) {\n      int millis = time.get(GregorianCalendar.HOUR_OF_DAY) * 60 * 60 * 1000 +\n                   time.get(GregorianCalendar.MINUTE) * 60 * 1000 +\n                   time.get(GregorianCalendar.SECOND) * 1000 +\n                   time.get(GregorianCalendar.MILLISECOND);\n      return new TimeExpression(millis);\n  }\n  public static LogicalExpression getTime(int milliSeconds) {\n    return new TimeExpression(milliSeconds);\n  }\n  public static LogicalExpression getTimeStamp(GregorianCalendar date) {\n    return new org.apache.drill.common.expression.ValueExpressions.TimeStampExpression(date.getTimeInMillis());\n  }\n  public static LogicalExpression getTimeStamp(long milliSeconds) {\n    return new org.apache.drill.common.expression.ValueExpressions.TimeStampExpression(milliSeconds);\n  }\n  public static LogicalExpression getIntervalYear(int months) {\n    return new IntervalYearExpression(months);\n  }\n<fim_suffix>  public static LogicalExpression getIntervalDay(long intervalInMillis) {\n      return new IntervalDayExpression(intervalInMillis);\n  }\n  public static LogicalExpression getVarDecimal(BigDecimal input, int precision, int scale) {\n    return new VarDecimalExpression(input, precision, scale, ExpressionPosition.UNKNOWN);\n  }\n  public static LogicalExpression getNumericExpression(String sign, String s, ExpressionPosition ep) {\n    String numStr = (sign == null) ? s : sign+s;\n    try {\n        int a = Integer.parseInt(numStr);\n        return new IntExpression(a, ep);\n    } catch (Exception e) {\n    }\n    try {\n      long l = Long.parseLong(numStr);\n      return new LongExpression(l, ep);\n    } catch (Exception e) {\n    }\n    try {\n      double d = Double.parseDouble(numStr);\n      return new DoubleExpression(d, ep);\n    } catch (Exception e) {\n    }\n    throw new IllegalArgumentException(String.format(\"Unable to parse string %s as integer or floating point number.\",\n        numStr));\n  }\n  public static LogicalExpression getParameterExpression(String name, MajorType type) {\n    return new ParameterExpression(name, type, ExpressionPosition.UNKNOWN);\n  }\n  protected static abstract class ValueExpression<V> extends LogicalExpressionBase {\n    public final V value;\n    protected ValueExpression(String value, ExpressionPosition pos) {\n      super(pos);\n      this.value = parseValue(value);\n    }\n    protected abstract V parseValue(String s);\n    @Override\n    public Iterator<LogicalExpression> iterator() {\n      return Collections.emptyIterator();\n    }\n  }\n  public static class BooleanExpression extends ValueExpression<Boolean> {\n    public static final BooleanExpression TRUE = new BooleanExpression(\"true\", ExpressionPosition.UNKNOWN);\n    public static final BooleanExpression FALSE = new BooleanExpression(\"false\", ExpressionPosition.UNKNOWN);\n    public BooleanExpression(String value, ExpressionPosition pos) {\n      super(value, pos);\n    }\n    @Override\n    protected Boolean parseValue(String s) {\n      return Boolean.parseBoolean(s);\n    }\n    @Override\n    public MajorType getMajorType() {\n      return Types.REQUIRED_BIT;\n    }\n    @Override\n    public <T, V, E extends Exception> T accept(ExprVisitor<T, V, E> visitor, V value) throws E {\n      return visitor.visitBooleanConstant(this, value);\n    }\n    public boolean getBoolean() {\n      return value;\n    }\n  }\n  public static class FloatExpression extends LogicalExpressionBase {\n    private float f;\n    private static final MajorType FLOAT_CONSTANT = Types.required(MinorType.FLOAT4);\n    public FloatExpression(float f, ExpressionPosition pos) {\n      super(pos);\n      this.f = f;\n    }\n    public float getFloat() {\n      return f;\n    }\n    @Override\n    public MajorType getMajorType() {\n      return FLOAT_CONSTANT;\n    }\n    @Override\n    public <T, V, E extends Exception> T accept(ExprVisitor<T, V, E> visitor, V value) throws E {\n      return visitor.visitFloatConstant(this, value);\n    }\n    @Override\n    public Iterator<LogicalExpression> iterator() {\n      return Collections.emptyIterator();\n    }\n  }\n  public static class IntExpression extends LogicalExpressionBase {\n    private static final MajorType INT_CONSTANT = Types.required(MinorType.INT);\n    private int i;\n    public IntExpression(int i, ExpressionPosition pos) {\n      super(pos);\n      this.i = i;\n    }\n    public int getInt() {\n      return i;\n    }\n    @Override\n    public MajorType getMajorType() {\n      return INT_CONSTANT;\n    }\n    @Override\n    public <T, V, E extends Exception> T accept(ExprVisitor<T, V, E> visitor, V value) throws E {\n      return visitor.visitIntConstant(this, value);\n    }\n    @Override\n    public Iterator<LogicalExpression> iterator() {\n      return Collections.emptyIterator();\n    }\n  }\n  public static class Decimal9Expression extends LogicalExpressionBase {\n    private int decimal;\n    private int scale;\n    private int precision;\n    public Decimal9Expression(BigDecimal input, ExpressionPosition pos) {\n      super(pos);\n      this.scale = input.scale();\n      this.precision = input.precision();\n      this.decimal = input.setScale(scale, BigDecimal.ROUND_HALF_UP).intValue();\n    }\n    public int getIntFromDecimal() {\n      return decimal;\n    }\n    public int getScale() {\n      return scale;\n    }\n    public int getPrecision() {\n      return precision;\n    }\n    @Override\n    public MajorType getMajorType() {\n      return MajorType.newBuilder().setMinorType(MinorType.DECIMAL9).setScale(scale).setPrecision(precision).setMode(DataMode.REQUIRED).build();\n    }\n    @Override\n    public <T, V, E extends Exception> T accept(ExprVisitor<T, V, E> visitor, V value) throws E {\n      return visitor.visitDecimal9Constant(this, value);\n    }\n    @Override\n    public Iterator<LogicalExpression> iterator() {\n      return Collections.emptyIterator();\n    }\n  }\n  public static class Decimal18Expression extends LogicalExpressionBase {\n    private long decimal;\n    private int scale;\n    private int precision;\n    public Decimal18Expression(BigDecimal input, ExpressionPosition pos) {\n      super(pos);\n      this.scale = input.scale();\n      this.precision = input.precision();\n      this.decimal = input.setScale(scale, BigDecimal.ROUND_HALF_UP).longValue();\n    }<fim_middle>// function below has no smell\n"}