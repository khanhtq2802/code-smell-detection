{"text": "<fim_prefix>\n<fim_suffix>@SuppressWarnings(\"serial\") // Superclass is not serializable across versions\npublic class BasicDirectoryModel extends AbstractListModel<Object> implements PropertyChangeListener {\n    private JFileChooser filechooser = null;\n    // PENDING(jeff) pick the size more sensibly\n    private Vector<File> fileCache = new Vector<File>(50);\n    private FilesLoader filesLoader = null;\n    private Vector<File> files = null;\n    private Vector<File> directories = null;\n    private int fetchID = 0;\n    private PropertyChangeSupport changeSupport;\n    private boolean busy = false;\n    /**\n     * Constructs a new instance of {@code BasicDirectoryModel}.\n     *\n     * @param filechooser an instance of {JFileChooser}\n     */\n    public BasicDirectoryModel(JFileChooser filechooser) {\n        this.filechooser = filechooser;\n        validateFileCache();\n    }\n    public void propertyChange(PropertyChangeEvent e) {\n        String prop = e.getPropertyName();\n        if(prop == JFileChooser.DIRECTORY_CHANGED_PROPERTY ||\n           prop == JFileChooser.FILE_VIEW_CHANGED_PROPERTY ||\n           prop == JFileChooser.FILE_FILTER_CHANGED_PROPERTY ||\n           prop == JFileChooser.FILE_HIDING_CHANGED_PROPERTY ||\n           prop == JFileChooser.FILE_SELECTION_MODE_CHANGED_PROPERTY) {\n            validateFileCache();\n        } else if (\"UI\".equals(prop)) {\n            Object old = e.getOldValue();\n            if (old instanceof BasicFileChooserUI) {\n                BasicFileChooserUI ui = (BasicFileChooserUI) old;\n                BasicDirectoryModel model = ui.getModel();\n                if (model != null) {\n                    model.invalidateFileCache();\n                }\n            }\n        } else if (\"JFileChooserDialogIsClosingProperty\".equals(prop)) {\n            invalidateFileCache();\n        }\n    }\n    /**\n     * This method is used to interrupt file loading thread.\n     */\n    public void invalidateFileCache() {\n        if (filesLoader != null) {\n            filesLoader.loadThread.interrupt();\n            filesLoader.cancelRunnables();\n            filesLoader = null;\n        }\n    }\n    /**\n     * Returns a list of directories.\n     *\n     * @return a list of directories\n     */\n    public Vector<File> getDirectories() {\n        synchronized(fileCache) {\n            if (directories != null) {\n                return directories;\n            }\n            Vector<File> fls = getFiles();\n            return directories;\n        }\n    }\n    /**\n     * Returns a list of files.\n     *\n     * @return a list of files\n     */\n    public Vector<File> getFiles() {\n        synchronized(fileCache) {\n            if (files != null) {\n                return files;\n            }\n            files = new Vector<File>();\n            directories = new Vector<File>();\n            directories.addElement(filechooser.getFileSystemView().createFileObject(\n                filechooser.getCurrentDirectory(), \"..\")\n            );\n            for (int i = 0; i < getSize(); i++) {\n                File f = fileCache.get(i);\n                if (filechooser.isTraversable(f)) {\n                    directories.add(f);\n                } else {\n                    files.add(f);\n                }\n            }\n            return files;\n        }\n    }\n    /**\n     * Validates content of file cache.\n     */\n    public void validateFileCache() {\n        File currentDirectory = filechooser.getCurrentDirectory();\n        if (currentDirectory == null) {\n            return;\n        }\n        if (filesLoader != null) {\n            filesLoader.loadThread.interrupt();\n            filesLoader.cancelRunnables();\n        }\n        setBusy(true, ++fetchID);\n        filesLoader = new FilesLoader(currentDirectory, fetchID);\n    }\n    /**\n     * Renames a file in the underlying file system.\n     *\n     * @param oldFile a <code>File</code> object representing\n     *        the existing file\n     * @param newFile a <code>File</code> object representing\n     *        the desired new file name\n     * @return <code>true</code> if rename succeeded,\n     *        otherwise <code>false</code>\n     * @since 1.4\n     */\n    public boolean renameFile(File oldFile, File newFile) {\n        synchronized(fileCache) {\n            if (oldFile.renameTo(newFile)) {\n                validateFileCache();\n                return true;\n            }\n            return false;\n        }\n    }\n    /**\n     * Invoked when a content is changed.\n     */\n    public void fireContentsChanged() {\n        fireContentsChanged(this, 0, getSize() - 1);\n    }\n    public int getSize() {\n        return fileCache.size();\n    }\n    /**\n     * Returns {@code true} if an element {@code o} is in file cache,\n     * otherwise, returns {@code false}.\n     *\n     * @param o an element\n     * @return {@code true} if an element {@code o} is in file cache\n     */\n    public boolean contains(Object o) {\n        return fileCache.contains(o);\n    }\n    /**\n     * Returns an index of element {@code o} in file cache.\n     *\n     * @param o an element\n     * @return an index of element {@code o} in file cache\n     */\n    public int indexOf(Object o) {\n        return fileCache.indexOf(o);\n    }\n    public Object getElementAt(int index) {\n        return fileCache.get(index);\n    }\n    /**\n     * Obsolete - not used.\n     * @param e list data event\n     */\n    public void intervalAdded(ListDataEvent e) {\n    }\n    /**\n     * Obsolete - not used.\n     * @param e list data event\n     */\n    public void intervalRemoved(ListDataEvent e) {\n    }\n    /**\n     * Sorts a list of files.\n     *\n     * @param v a list of files\n     */\n    protected void sort(Vector<? extends File> v){\n        ShellFolder.sort(v);\n    }\n    /**\n     * Obsolete - not used\n     * @return a comparison of the file names\n     * @param a a file\n     * @param b another file\n     */\n    protected boolean lt(File a, File b) {\n        // First ignore case when comparing\n        int diff = a.getName().toLowerCase().compareTo(b.getName().toLowerCase());\n        if (diff != 0) {\n            return diff < 0;\n        } else {\n            // May differ in case (e.g. \"mail\" vs. \"Mail\")\n            return a.getName().compareTo(b.getName()) < 0;\n        }\n    }\n    class FilesLoader implements Runnable {\n        File currentDirectory = null;\n        int fid;\n        Vector<DoChangeContents> runnables = new Vector<DoChangeContents>(10);\n        final Thread loadThread;\n        public FilesLoader(File currentDirectory, int fid) {\n            this.currentDirectory = currentDirectory;\n            this.fid = fid;\n            String name = \"Basic L&F File Loading Thread\";\n            this.loadThread = new Thread(null, this, name, 0, false);\n            this.loadThread.start();\n        }\n        @Override\n        public void run() {\n            run0();\n            setBusy(false, fid);\n        }\n        public void run0() {\n            FileSystemView fileSystem = filechooser.getFileSystemView();\n            if (loadThread.isInterrupted()) {\n                return;\n            }\n            File[] list = fileSystem.getFiles(currentDirectory, filechooser.isFileHidingEnabled());\n            if (loadThread.isInterrupted()) {\n                return;\n            }\n            final Vector<File> newFileCache = new Vector<File>();\n            Vector<File> newFiles = new Vector<File>();\n            // run through the file list, add directories and selectable files to fileCache\n            // Note that this block must be OUTSIDE of Invoker thread because of\n            // deadlock possibility with custom synchronized FileSystemView\n            for (File file : list) {\n                if (filechooser.accept(file)) {\n                    boolean isTraversable = filechooser.isTraversable(file);\n                    if (isTraversable) {\n                        newFileCache.addElement(file);\n                    } else if (filechooser.isFileSelectionEnabled()) {\n                        newFiles.addElement(file);\n                    }\n                    if (loadThread.isInterrupted()) {\n                        return;\n                    }\n                }\n            }\n            // First sort alphabetically by filename\n            sort(newFileCache);\n            sort(newFiles);\n            newFileCache.addAll(newFiles);\n            // To avoid loads of synchronizations with Invoker and improve performance we\n            // execute the whole block on the COM thread\n            DoChangeContents doChangeContents = ShellFolder.invoke(new Callable<DoChangeContents>() {\n                public DoChangeContents call() {\n                    int newSize = newFileCache.size();\n                    int oldSize = fileCache.size();\n                    if (newSize > oldSize) {\n                        //see if interval is added\n                        int start = oldSize;\n                        int end = newSize;\n                        for (int i = 0; i < oldSize; i++) {\n                            if (!newFileCache.get(i).equals(fileCache.get(i))) {\n                                start = i;\n                                for (int j = i; j < newSize; j++) {<fim_middle>// class below has no smell\n"}