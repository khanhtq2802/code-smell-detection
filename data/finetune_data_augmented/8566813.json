{"text": "<fim_prefix>/**\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.hadoop.hbase.regionserver.wal;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.fs.Path;\nimport org.apache.hadoop.fs.FileSystem;\nimport org.apache.hadoop.fs.FSDataInputStream;\nimport org.apache.hadoop.hbase.codec.Codec;\nimport org.apache.hadoop.hbase.HBaseInterfaceAudience;\nimport org.apache.hadoop.hbase.shaded.protobuf.ProtobufUtil;\nimport org.apache.hadoop.hbase.shaded.protobuf.generated.WALProtos;\nimport org.apache.hadoop.hbase.shaded.protobuf.generated.WALProtos.WALHeader.Builder;\nimport org.apache.hadoop.hbase.shaded.protobuf.generated.WALProtos.WALKey;\nimport org.apache.hadoop.hbase.shaded.protobuf.generated.WALProtos.WALTrailer;\nimport org.apache.hadoop.hbase.util.Bytes;\nimport org.apache.hadoop.hbase.wal.WAL.Entry;\nimport org.apache.yetus.audience.InterfaceAudience;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.apache.hbase.thirdparty.com.google.common.io.ByteStreams;\nimport org.apache.hbase.thirdparty.com.google.protobuf.CodedInputStream;\nimport org.apache.hbase.thirdparty.com.google.protobuf.InvalidProtocolBufferException;\n/**\n * A Protobuf based WAL has the following structure:\n * <p>\n * &lt;PB_WAL_MAGIC&gt;&lt;WALHeader&gt;&lt;WALEdits&gt;...&lt;WALEdits&gt;&lt;Trailer&gt;\n * &lt;TrailerSize&gt; &lt;PB_WAL_COMPLETE_MAGIC&gt;\n * </p>\n * The Reader reads meta information (WAL Compression state, WALTrailer, etc) in\n * ProtobufLogReader#initReader(FSDataInputStream). A WALTrailer is an extensible structure\n * which is appended at the end of the WAL. This is empty for now; it can contain some meta\n * information such as Region level stats, etc in future.\n */\n@InterfaceAudience.LimitedPrivate({HBaseInterfaceAudience.COPROC, HBaseInterfaceAudience.PHOENIX,\n  HBaseInterfaceAudience.CONFIG})\npublic class ProtobufLogReader extends ReaderBase {\n  private static final Logger LOG = LoggerFactory.getLogger(ProtobufLogReader.class);\n  // public for WALFactory until we move everything to o.a.h.h.wal\n  @InterfaceAudience.Private\n  public static final byte[] PB_WAL_MAGIC = Bytes.toBytes(\"PWAL\");\n  // public for TestWALSplit\n  @InterfaceAudience.Private\n  public static final byte[] PB_WAL_COMPLETE_MAGIC = Bytes.toBytes(\"LAWP\");\n  /**\n   * Configuration name of WAL Trailer's warning size. If a waltrailer's size is greater than the\n   * configured size, providers should log a warning. e.g. this is used with Protobuf reader/writer.\n   */\n  static final String WAL_TRAILER_WARN_SIZE = \"hbase.regionserver.waltrailer.warn.size\";\n  static final int DEFAULT_WAL_TRAILER_WARN_SIZE = 1024 * 1024; // 1MB\n  protected FSDataInputStream inputStream;\n  protected Codec.Decoder cellDecoder;\n  protected WALCellCodec.ByteStringUncompressor byteStringUncompressor;\n  protected boolean hasCompression = false;\n  protected boolean hasTagCompression = false;\n  // walEditsStopOffset is the position of the last byte to read. After reading the last WALEdit\n  // entry in the wal, the inputstream's position is equal to walEditsStopOffset.\n  private long walEditsStopOffset;\n  private boolean trailerPresent;\n  protected WALTrailer trailer;\n  // maximum size of the wal Trailer in bytes. If a user writes/reads a trailer with size larger\n  // than this size, it is written/read respectively, with a WARN message in the log.\n  protected int trailerWarnSize;\n  private static List<String> writerClsNames = new ArrayList<>();\n  static {\n    writerClsNames.add(ProtobufLogWriter.class.getSimpleName());\n    writerClsNames.add(AsyncProtobufLogWriter.class.getSimpleName());\n  }\n  // cell codec classname\n  private String codecClsName = null;\n  @InterfaceAudience.Private\n  public long trailerSize() {\n    if (trailerPresent) {\n      // sizeof PB_WAL_COMPLETE_MAGIC + sizof trailerSize + trailer\n      final long calculatedSize = (long) PB_WAL_COMPLETE_MAGIC.length + Bytes.SIZEOF_INT\n          + trailer.getSerializedSize();\n      final long expectedSize = fileLength - walEditsStopOffset;\n      if (expectedSize != calculatedSize) {\n        LOG.warn(\"After parsing the trailer, we expect the total footer to be {} bytes, but we \"\n            + \"calculate it as being {}\", expectedSize, calculatedSize);\n      }\n      return expectedSize;\n    } else {\n      return -1L;\n    }\n  }\n  enum WALHdrResult {\n    EOF,                   // stream is at EOF when method starts\n    SUCCESS,\n    UNKNOWN_WRITER_CLS     // name of writer class isn't recognized\n  }\n  // context for WALHdr carrying information such as Cell Codec classname\n  static class WALHdrContext {\n    WALHdrResult result;\n    String cellCodecClsName;\n    WALHdrContext(WALHdrResult result, String cellCodecClsName) {\n      this.result = result;\n      this.cellCodecClsName = cellCodecClsName;\n    }\n    WALHdrResult getResult() {\n      return result;\n    }\n    String getCellCodecClsName() {\n      return cellCodecClsName;\n    }\n  }\n  public ProtobufLogReader() {\n    super();\n  }\n  @Override\n  public void close() throws IOException {\n    if (this.inputStream != null) {\n      this.inputStream.close();\n      this.inputStream = null;\n    }\n  }\n  @Override\n  public long getPosition() throws IOException {\n    return inputStream.getPos();\n  }\n  @Override\n  public void reset() throws IOException {\n    String clsName = initInternal(null, false);\n    initAfterCompression(clsName); // We need a new decoder (at least).\n  }\n  @Override\n  public void init(FileSystem fs, Path path, Configuration conf, FSDataInputStream stream)\n      throws IOException {\n    this.trailerWarnSize = conf.getInt(WAL_TRAILER_WARN_SIZE, DEFAULT_WAL_TRAILER_WARN_SIZE);\n    super.init(fs, path, conf, stream);\n  }\n  @Override\n  protected String initReader(FSDataInputStream stream) throws IOException {\n    return initInternal(stream, true);\n  }\n  /*\n   * Returns names of the accepted writer classes\n   */\n  public List<String> getWriterClsNames() {\n    return writerClsNames;\n  }\n  /*\n   * Returns the cell codec classname\n   */\n  public String getCodecClsName() {\n      return codecClsName;\n  }\n<fim_suffix>  protected WALHdrContext readHeader(Builder builder, FSDataInputStream stream)\n      throws IOException {\n     boolean res = builder.mergeDelimitedFrom(stream);\n     if (!res) return new WALHdrContext(WALHdrResult.EOF, null);\n     if (builder.hasWriterClsName() &&\n         !getWriterClsNames().contains(builder.getWriterClsName())) {\n       return new WALHdrContext(WALHdrResult.UNKNOWN_WRITER_CLS, null);\n     }\n     String clsName = null;\n     if (builder.hasCellCodecClsName()) {\n       clsName = builder.getCellCodecClsName();\n     }\n     return new WALHdrContext(WALHdrResult.SUCCESS, clsName);\n  }\n  private String initInternal(FSDataInputStream stream, boolean isFirst)\n      throws IOException {\n    close();\n    long expectedPos = PB_WAL_MAGIC.length;\n    if (stream == null) {\n      stream = fs.open(path);<fim_middle>// function below has no smell\n"}