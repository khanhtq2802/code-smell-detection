{"text": "<fim_prefix>/*\n * Copyright 2006-2012 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.retry.backoff;\n\nimport org.springframework.retry.RetryContext;\n\nimport java.util.Random;\n\n/**\n * Implementation of {@link org.springframework.retry.backoff.ExponentialBackOffPolicy}\n * that chooses a random multiple of the interval that would come from a simple\n * deterministic exponential. The random multiple is uniformly distributed between 1 and\n * the deterministic multiplier (so in practice the interval is somewhere between the next\n * and next but one intervals in the deterministic case).\n *\n * This has shown to at least be useful in testing scenarios where excessive contention is\n * generated by the test needing many retries. In test, usually threads are started at the\n * same time, and thus stomp together onto the next interval. Using this\n * {@link BackOffPolicy} can help avoid that scenario.\n *\n * Example: initialInterval = 50 multiplier = 2.0 maxInterval = 3000 numRetries = 5\n *\n * {@link ExponentialBackOffPolicy} yields: [50, 100, 200, 400, 800]\n *\n * {@link ExponentialRandomBackOffPolicy} may yield [76, 151, 304, 580, 901] or [53, 190,\n * 267, 451, 815]\n *\n * @author Jon Travis\n * @author Dave Syer\n */\n@SuppressWarnings(\"serial\")\npublic class ExponentialRandomBackOffPolicy extends ExponentialBackOffPolicy {\n\n\t/**\n\t * Returns a new instance of {@link org.springframework.retry.backoff.BackOffContext},\n\t * seeded with this policies settings.\n\t */\n\tpublic BackOffContext start(RetryContext context) {\n\t\treturn new ExponentialRandomBackOffContext(getInitialInterval(), getMultiplier(),\n\t\t\t\tgetMaxInterval());\n\t}\n\n\tprotected ExponentialBackOffPolicy newInstance() {\n\t\treturn new ExponentialRandomBackOffPolicy();\n\t}\n\n<fim_suffix>\tstatic class ExponentialRandomBackOffContext\n\t\t\textends ExponentialBackOffPolicy.ExponentialBackOffContext {\n\n\t\tprivate final Random r = new Random();\n\n\t\tpublic ExponentialRandomBackOffContext(long expSeed, double multiplier,\n\t\t\t\tlong maxInterval) {\n\t\t\tsuper(expSeed, multiplier, maxInterval);\n\t\t}\n\n\t\t@Override\n\t\tpublic synchronized long getSleepAndIncrement() {\n\t\t\tlong next = super.getSleepAndIncrement();\n\t\t\tnext = (long) (next * (1 + r.nextFloat() * (getMultiplier() - 1)));\n\t\t\treturn next;\n\t\t}\n\n\t}\n\n}<fim_middle>// class below has no smell\n"}