{"text": "<fim_prefix>// Copyright 2012 Google Inc. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\npackage org.eclipse.che.ide.util.dom;\nimport com.google.common.base.Strings;\nimport com.google.gwt.core.client.GWT;\nimport com.google.gwt.user.client.DOM;\nimport com.google.gwt.user.client.ui.UIObject;\nimport com.google.gwt.user.client.ui.Widget;\nimport elemental.dom.Element;\nimport elemental.dom.Node;\nimport elemental.events.Event;\nimport elemental.events.EventListener;\nimport elemental.events.MouseEvent;\nimport elemental.html.ClientRect;\nimport elemental.html.DivElement;\nimport elemental.js.dom.JsElement;\nimport org.eclipse.che.ide.util.browser.UserAgent;\n/** Utility methods for DOM manipulation. */\npublic final class DomUtils {\n  private static final ZIndexImpl zIndexImpl = GWT.create(ZIndexImpl.class);\n  public static class ZIndexImpl {\n    private int zIndexId = 1000000;\n    int incrementAndGetTopZIndex() {\n      return ++zIndexId;\n    }\n    int incrementAndGetTopZIndex(int i) {\n      zIndexId = zIndexId + i + 1;\n      return zIndexId;\n    }\n  }\n  public static class Offset {\n    public int top = 0;\n    public int left = 0;\n    private Offset() {}\n    private Offset(int top, int left) {\n      this.top = top;\n      this.left = left;\n    }\n  }\n  /**\n   * Increments and returns the top z-index value.\n   *\n   * @return index of z-index value\n   */\n  public static int incrementAndGetTopZIndex() {\n    return zIndexImpl.incrementAndGetTopZIndex();\n  }\n  /**\n   * Increments and returns the top z-index value.\n   *\n   * @param i increment index\n   * @return index of z-index value\n   */\n  public static int incrementAndGetTopZIndex(int i) {\n    return zIndexImpl.incrementAndGetTopZIndex(i);\n  }\n  private static final EventListener STOP_PROPAGATION_EVENT_LISTENER =\n      new EventListener() {\n        @Override\n        public void handleEvent(Event evt) {\n          evt.stopPropagation();\n          evt.preventDefault();\n        }\n      };\n  /** Returns the client offset to the top-left of the given element. */\n  @Deprecated\n  public static Offset calculateElementClientOffset(Element element) {\n    return calculateElementOffset(element, null, false);\n  }\n  /**\n   * Returns an offset to the top-left of a child element relative to the top-left of an ancestor\n   * element, optionally including any scroll top or left in elements from the ancestor (inclusive)\n   * to the child (exclusive).\n   *\n   * @param ancestorElement optional, if null the offset from the top-left of the page will be\n   *     given. Should not be the childElement.\n   */\n  @Deprecated\n  public static Offset calculateElementOffset(\n      Element childElement, Element ancestorElement, boolean includeScroll) {\n    Offset offset = new Offset();\n    Element element = childElement;\n    for (;\n        element.getOffsetParent() != null && element != ancestorElement;\n        element = element.getOffsetParent()) {\n      offset.top += element.getOffsetTop();\n      offset.left += element.getOffsetLeft();\n      if (!includeScroll) {\n        offset.top -= element.getOffsetParent().getScrollTop();\n        offset.left -= element.getOffsetParent().getScrollLeft();\n      }\n    }\n    return offset;\n  }\n  /**\n   * Wrapper for getting the offsetX from a mouse event that provides a fallback implementation for\n   * Firefox. (See https://bugzilla.mozilla.org/show_bug.cgi?id=122665#c3 )\n   */\n  public static int getOffsetX(MouseEvent event) {\n    if (UserAgent.isFirefox()) {\n      return event.getClientX() - calculateElementClientOffset((Element) event.getTarget()).left;\n    } else {\n      return event.getOffsetX();\n    }\n  }\n  /** @see #getOffsetX(MouseEvent) */\n  public static int getOffsetY(MouseEvent event) {\n    if (UserAgent.isFirefox()) {\n      return event.getClientY() - calculateElementClientOffset((Element) event.getTarget()).top;\n    } else {\n      return event.getOffsetY();\n    }\n  }\n  public static Element getNthChild(Element element, int index) {\n    Element child = getFirstChildElement(element);\n    while (child != null && index > 0) {\n      --index;\n      child = getNextSiblingElement(element);\n    }\n    return child;\n  }\n  public static Element getNthChildWithClassName(Element element, int index, String className) {\n    Element child = getFirstChildElement(element);\n    while (child != null) {\n      if (Elements.hasClassName(className, child)) {\n        --index;\n        if (index < 0) {\n          break;\n        }\n      }\n      child = getNextSiblingElement(child);\n    }\n    return child;\n  }\n  /** @return number of previous sibling elements that have the given class */\n<fim_suffix>  public static int getSiblingIndexWithClassName(Element element, String className) {\n    int index = 0;\n    while (element != null) {\n      element = (Element) element.getPreviousSibling();\n      if (element != null && Elements.hasClassName(className, element)) {\n        ++index;\n      }\n    }\n    return index;\n  }\n  public static Element getFirstElementByClassName(Element element, String className) {\n    return (Element) element.getElementsByClassName(className).item(0);\n  }\n  public static DivElement appendDivWithTextContent(Element root, String className, String text) {\n    DivElement element = Elements.createDivElement(className);\n    element.setTextContent(text);\n    root.appendChild(element);\n    return element;\n  }\n  /**\n   * Ensures that the {@code scrollable} element is scrolled such that {@code target} is visible.\n   *\n   * <p>Note: This can trigger a synchronous layout.\n   */\n  public static boolean ensureScrolledTo(Element scrollable, Element target) {\n    ClientRect targetBounds = target.getBoundingClientRect();\n    ClientRect scrollableBounds = scrollable.getBoundingClientRect();\n    int deltaBottoms = (int) (targetBounds.getBottom() - scrollableBounds.getBottom());\n    int deltaTops = (int) (targetBounds.getTop() - scrollableBounds.getTop());\n    if (deltaTops >= 0 && deltaBottoms <= 0) {\n      // In bounds\n      return false;\n    }\n    if (targetBounds.getHeight() > scrollableBounds.getHeight() || deltaTops < 0) {\n      /*\n       * Selected is taller than viewport height or selected is scrolled above\n       * viewport, so set to top\n       */\n      scrollable.setScrollTop(scrollable.getScrollTop() + deltaTops);\n    } else {\n      // Selected is scrolled below viewport\n      scrollable.setScrollTop(scrollable.getScrollTop() + deltaBottoms);\n    }\n    return true;\n  }\n  /**\n   * Checks whether the given {@code target} element is fully visible in {@code scrollable}'s\n   * scrolled viewport.\n   *\n   * <p>Note: This can trigger a synchronous layout.\n   */\n  public static boolean isFullyInScrollViewport(Element scrollable, Element target) {\n    ClientRect targetBounds = target.getBoundingClientRect();\n    ClientRect scrollableBounds = scrollable.getBoundingClientRect();\n    return targetBounds.getTop() >= scrollableBounds.getTop()\n        && targetBounds.getBottom() <= scrollableBounds.getBottom();\n  }\n  /** Stops propagation for the common mouse events (down, move, up, click, dblclick). */\n  public static void stopMousePropagation(Element element) {\n    element.addEventListener(Event.MOUSEDOWN, STOP_PROPAGATION_EVENT_LISTENER, false);\n    element.addEventListener(Event.MOUSEMOVE, STOP_PROPAGATION_EVENT_LISTENER, false);\n    element.addEventListener(Event.MOUSEUP, STOP_PROPAGATION_EVENT_LISTENER, false);\n    element.addEventListener(Event.CLICK, STOP_PROPAGATION_EVENT_LISTENER, false);\n    element.addEventListener(Event.DBLCLICK, STOP_PROPAGATION_EVENT_LISTENER, false);\n  }\n  /**\n   * Prevent propagation of scrolling to parent containers on mouse wheeling, when target container\n   * can not be scrolled anymore.\n   */<fim_middle>// function below has no smell\n"}