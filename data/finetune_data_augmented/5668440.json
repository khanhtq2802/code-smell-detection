{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.streams.cli;\n\nimport fmpp.Engine;\nimport fmpp.TemplateEnvironment;\nimport fmpp.localdatabuilders.MapLocalDataBuilder;\nimport fmpp.progresslisteners.ConsoleProgressListener;\nimport fmpp.progresslisteners.TerseConsoleProgressListener;\nimport fmpp.setting.Settings;\nimport freemarker.cache.FileTemplateLoader;\nimport freemarker.template.Configuration;\n\nimport java.io.FileWriter;\nimport java.io.Writer;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.Callable;\n\nimport com.typesafe.config.Config;\n\nimport com.typesafe.config.ConfigFactory;\nimport freemarker.template.SimpleHash;\nimport freemarker.template.Template;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static fmpp.setting.Settings.DEFAULT_CFG_FILE_NAME;\nimport static fmpp.setting.Settings.NAME_DATA;\nimport static fmpp.setting.Settings.NAME_DATA_ROOT;\nimport static fmpp.setting.Settings.NAME_LOCAL_DATA;\nimport static fmpp.setting.Settings.NAME_OUTPUT_ROOT;\nimport static fmpp.setting.Settings.NAME_SOURCE_ROOT;\n\n<fim_suffix>public class RdfFreemarkerCli implements Callable {\n\n  private final static Logger LOGGER = LoggerFactory.getLogger(RdfFreemarkerCli.class);\n  private String[] args;\n  private Config typesafe;\n\n  public static void main(String[] args) throws Exception {\n    RdfFreemarkerCli cli = new RdfFreemarkerCli(args);\n    try {\n      cli.call();\n    } catch( Exception e ) {\n      LOGGER.error(\"Error\", e);\n      System.exit(1);\n    }\n    System.exit(0);\n  }\n\n  public RdfFreemarkerCli(String[] args) {\n    ConfigFactory.invalidateCaches();\n    this.args = args;\n    this.typesafe = ConfigFactory.load();\n  }\n\n  public Boolean call() throws Exception {\n\n    String baseDir;\n    if (typesafe.hasPath(\"baseDir\"))\n      baseDir = typesafe.getString(\"baseDir\");\n    else\n      baseDir = args[0];\n\n    LOGGER.info(\"baseDir: \" + baseDir);\n    Path baseDirPath = Paths.get(baseDir);\n    assert( Files.exists(baseDirPath) );\n    assert( Files.isDirectory(baseDirPath) );\n\n    String settingsFile;\n    if (typesafe.hasPath(\"settingsFile\"))\n      settingsFile = typesafe.getString(\"settingsFile\");\n    else\n      settingsFile = args[1];\n\n    LOGGER.info(\"settingsFile: \" + settingsFile);\n    Path settingsFilePath = Paths.get(settingsFile);\n    assert( Files.exists(settingsFilePath) );\n    assert( !Files.isDirectory(settingsFilePath) );\n\n    String sourceRoot;\n    if (typesafe.hasPath(\"sourceRoot\"))\n      sourceRoot = typesafe.getString(\"sourceRoot\");\n    else\n      sourceRoot = args[2];\n\n    LOGGER.info(\"sourceRoot: \" + sourceRoot);\n    Path sourceRootPath = Paths.get(sourceRoot);\n    assert( Files.exists(sourceRootPath) );\n    assert( Files.isDirectory(sourceRootPath) );\n\n    String dataRoot;\n    if (typesafe.hasPath(\"dataRoot\"))\n      dataRoot = typesafe.getString(\"dataRoot\");\n    else\n      dataRoot = args[3];\n\n    LOGGER.info(\"dataRoot: \" + dataRoot);\n    Path dataRootPath = Paths.get(dataRoot);\n    assert( Files.exists(dataRootPath) );\n    assert( Files.isDirectory(dataRootPath) );\n\n    String outputRoot;\n    if (typesafe.hasPath(\"outputRoot\"))\n      outputRoot = typesafe.getString(\"outputRoot\");\n    else\n      outputRoot = args[4];\n\n    LOGGER.info(\"outputRoot: \" + outputRoot);\n    Path outputRootPath = Paths.get(outputRoot);\n    assert( Files.exists(outputRootPath) );\n    assert( Files.isDirectory(outputRootPath) );\n\n    String namespace;\n    if (typesafe.hasPath(\"namespace\"))\n      namespace = typesafe.getString(\"namespace\");\n    else\n      namespace = args[5];\n\n    String id;\n    if (typesafe.hasPath(\"id\"))\n      id = typesafe.getString(\"id\");\n    else\n      id = args[6];\n\n    Settings settings = new Settings(baseDirPath.toFile());\n    settings.load(settingsFilePath.toFile());\n    settings.set(NAME_DATA_ROOT, dataRoot);\n    settings.set(NAME_SOURCE_ROOT, sourceRoot);\n    settings.set(NAME_OUTPUT_ROOT, outputRoot);\n\n    Map<String, String> vars = new HashMap<>();\n    vars.put(\"dataRoot\", dataRoot);\n    vars.put(\"id\", id);\n    vars.put(\"namespace\", namespace);\n\n    settings.set(NAME_DATA, vars);\n\n//    settings.define(\"id\", Settings.TYPE_STRING, true, true);\n//    settings.set(\"id\", id);\n//    settings.define(\"namespace\", Settings.TYPE_STRING, true, true);\n//    settings.set(\"namespace\", namespace);\n\n    ConsoleProgressListener listener = new ConsoleProgressListener();\n    settings.addProgressListener(listener);\n\n    try {\n      settings.execute();\n    } catch( Exception ex ) {\n      LOGGER.error(\"settings.execute() Exception\", ex);\n      return false;\n    }\n    LOGGER.info(\"settings.execute() Success\");\n    return true;\n  }\n\n  public String dropExtension(String path) {\n    return path.substring(0, path.lastIndexOf('.'));\n  }\n\n}<fim_middle>// class below has no smell\n"}