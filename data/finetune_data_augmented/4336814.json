{"text": "<fim_prefix>/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n * \n *    http://www.apache.org/licenses/LICENSE-2.0\n * \n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n * \n */\npackage org.apache.directory.server.core.partition.impl.btree.jdbm;\nimport java.io.IOException;\nimport jdbm.btree.BTree;\nimport org.apache.directory.api.ldap.model.constants.Loggers;\nimport org.apache.directory.api.ldap.model.cursor.AbstractCursor;\nimport org.apache.directory.api.ldap.model.cursor.Cursor;\nimport org.apache.directory.api.ldap.model.cursor.CursorException;\nimport org.apache.directory.api.ldap.model.cursor.InvalidCursorPositionException;\nimport org.apache.directory.api.ldap.model.cursor.Tuple;\nimport org.apache.directory.api.ldap.model.exception.LdapException;\nimport org.apache.directory.server.core.avltree.ArrayTree;\nimport org.apache.directory.server.core.avltree.ArrayTreeCursor;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n/**\n * A Cursor over a BTree which manages duplicate keys.\n *\n * @author <a href=\"mailto:dev@directory.apache.org\">Apache Directory Project</a>\n */\nclass DupsCursor<K, V> extends AbstractCursor<Tuple<K, V>>\n{\n    private static final Logger LOG = LoggerFactory.getLogger( DupsCursor.class );\n    /** A dedicated log for cursors */\n    private static final Logger LOG_CURSOR = LoggerFactory.getLogger( Loggers.CURSOR_LOG.getName() );\n    /** Speedup for logs */\n    private static final boolean IS_DEBUG = LOG_CURSOR.isDebugEnabled();\n    /**\n     * The JDBM backed table this Cursor traverses over.\n     */\n    private final JdbmTable<K, V> table;\n    /**\n     * An wrappedCursor Cursor which returns Tuples whose values are\n     * DupsContainer objects representing either AvlTrees or BTreeRedirect\n     * objects used to store the values of duplicate keys.  It does not return\n     * different values for the same key.\n     */\n    private final DupsContainerCursor<K, V> containerCursor;\n    /**\n     * The current Tuple returned from the wrappedCursor DupsContainerCursor.\n     */\n    private final Tuple<K, DupsContainer<V>> containerTuple = new Tuple<>();\n    /**\n     * A Cursor over a set of value objects for the current key held in the\n     * containerTuple.  A new Cursor will be set for each new key as we\n     * traverse.  The Cursor traverses over either a AvlTree object full\n     * of values in a multi-valued key or it traverses over a BTree which\n     * contains the values in the key field of it's Tuples.\n     */\n    private Cursor<V> dupsCursor;\n    /**\n     * The Tuple that is used to return values via the get() method. This\n     * same Tuple instance will be returned every time.  At different\n     * positions it may return different values for the same key.\n     */\n    private final Tuple<K, V> returnedTuple = new Tuple<>();\n    /**\n     * Whether or not a value is available when get() is called.\n     */\n    private boolean valueAvailable;\n    DupsCursor( JdbmTable<K, V> table )\n    {\n        if ( IS_DEBUG )\n        {\n            LOG_CURSOR.debug( \"Creating DupsCursor {}\", this );\n        }\n        this.table = table;\n        this.containerCursor = new DupsContainerCursor<>( table );\n        LOG.debug( \"Created on table {}\", table );\n    }\n    public boolean available()\n    {\n        return valueAvailable;\n    }\n    public void beforeKey( K key ) throws Exception\n    {\n        beforeValue( key, null );\n    }\n    public void beforeValue( K key, V value ) throws LdapException, CursorException\n    {\n        checkNotClosed();\n        containerCursor.before( new Tuple<K, DupsContainer<V>>( key, null ) );\n        if ( containerCursor.next() )\n        {\n            containerTuple.setBoth( containerCursor.get() );\n            DupsContainer<V> values = containerTuple.getValue();\n            if ( values.isArrayTree() )\n            {\n                ArrayTree<V> set = values.getArrayTree();\n                dupsCursor = new ArrayTreeCursor<>( set );\n            }\n            else\n            {\n                try\n                {\n                    BTree tree = table.getBTree( values.getBTreeRedirect() );\n                    dupsCursor = new KeyBTreeCursor<>( tree, table.getValueComparator() );\n                }\n                catch ( IOException e )\n                {\n                    throw new CursorException( e );\n                }\n            }\n            if ( value == null )\n            {\n                return;\n            }\n            // advance the dupsCursor only if we're on same key\n            if ( table.getKeyComparator().compare( containerTuple.getKey(), key ) == 0 )\n            {\n                dupsCursor.before( value );\n            }\n            return;\n        }\n        clearValue();\n        containerTuple.setKey( null );\n        containerTuple.setValue( null );\n    }\n    public void afterKey( K key ) throws Exception\n    {\n        afterValue( key, null );\n    }\n<fim_suffix>    public void afterValue( K key, V value ) throws LdapException, CursorException\n    {\n        checkNotClosed();\n        /*\n         * There is a subtle difference between after and before handling\n         * with duplicate key values.  Say we have the following tuples:\n         *\n         * (0, 0)\n         * (1, 1)\n         * (1, 2)\n         * (1, 3)\n         * (2, 2)\n         *\n         * If we request an after cursor on (1, 2).  We must make sure that\n         * the container cursor does not advance after the entry with key 1\n         * since this would result in us skip returning (1. 3) on the call to\n         * next which will incorrectly return (2, 2) instead.\n         *\n         * So if the value is null in the element then we don't care about\n         * this obviously since we just want to advance past the duplicate key\n         * values all together.  But when it is not null, then we want to\n         * go right before this key instead of after it.\n         */\n        if ( value == null )\n        {\n            containerCursor.after( new Tuple<K, DupsContainer<V>>( key, null ) );\n        }\n        else\n        {\n            containerCursor.before( new Tuple<K, DupsContainer<V>>( key, null ) );\n        }\n        if ( containerCursor.next() )\n        {\n            containerTuple.setBoth( containerCursor.get() );\n            DupsContainer<V> values = containerTuple.getValue();\n            if ( values.isArrayTree() )\n            {\n                ArrayTree<V> set = values.getArrayTree();\n                dupsCursor = new ArrayTreeCursor<>( set );\n            }\n            else\n            {\n                try\n                {\n                    BTree tree = table.getBTree( values.getBTreeRedirect() );\n                    dupsCursor = new KeyBTreeCursor<>( tree, table.getValueComparator() );\n                }\n                catch ( IOException e )\n                {\n                    throw new CursorException( e );\n                }\n            }\n            if ( value == null )\n            {\n                return;\n            }\n            // only advance the dupsCursor if we're on same key\n            if ( table.getKeyComparator().compare( containerTuple.getKey(), key ) == 0 )\n            {\n                dupsCursor.after( value );\n            }\n            return;\n        }\n        clearValue();\n        containerTuple.setKey( null );\n        containerTuple.setValue( null );\n    }\n    /**\n     * {@inheritDoc}\n     */\n    public void before( Tuple<K, V> element ) throws LdapException, CursorException\n    {\n        beforeValue( element.getKey(), element.getValue() );\n    }\n    /**\n     * {@inheritDoc}\n     */\n    public void after( Tuple<K, V> element ) throws LdapException, CursorException\n    {\n        afterValue( element.getKey(), element.getValue() );\n    }\n    /**\n     * {@inheritDoc}\n     */\n    public void beforeFirst() throws LdapException, CursorException\n    {\n        checkNotClosed();\n        clearValue();\n        containerCursor.beforeFirst();\n        containerTuple.setKey( null );\n        containerTuple.setValue( null );\n        dupsCursor = null;\n    }\n    /**\n     * {@inheritDoc}\n     */<fim_middle>// function below is long method\n"}