{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.alipay.dw.jstorm.transcation;\n\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.alibaba.starter.utils.Assert;\nimport com.alibaba.starter.utils.JStormHelper;\n\nimport backtype.storm.Config;\nimport backtype.storm.coordination.BatchOutputCollector;\nimport backtype.storm.task.TopologyContext;\nimport backtype.storm.testing.MemoryTransactionalSpout;\nimport backtype.storm.topology.OutputFieldsDeclarer;\nimport backtype.storm.topology.base.BaseBatchBolt;\nimport backtype.storm.topology.base.BaseTransactionalBolt;\nimport backtype.storm.transactional.ICommitter;\nimport backtype.storm.transactional.TransactionAttempt;\nimport backtype.storm.transactional.TransactionalTopologyBuilder;\nimport backtype.storm.tuple.Fields;\nimport backtype.storm.tuple.Tuple;\nimport backtype.storm.tuple.Values;\n\n/**\n * This is a basic example of a transactional topology. It keeps a count of the\n * number of tuples seen so far in a database. The source of data and the\n * databases are mocked out as in memory maps for demonstration purposes. This\n * class is defined in depth on the wiki at\n * https://github.com/nathanmarz/storm/wiki/Transactional-topologies\n */\npublic class TransactionalGlobalCount {\n    private static final Logger LOG = LoggerFactory.getLogger(TransactionalGlobalCount.class);\n    \n    public static final int                              PARTITION_TAKE_PER_BATCH = 3;\n    public static final Map<Integer, List<List<Object>>> DATA                     = new HashMap<Integer, List<List<Object>>>() {\n        {\n            put(0, new ArrayList<List<Object>>() {\n                {\n                    add(new Values(\"cat\"));\n                    add(new Values(\"dog\"));\n                    add(new Values(\"chicken\"));\n                    add(new Values(\"cat\"));\n                    add(new Values(\"dog\"));\n                    add(new Values(\"apple\"));\n                }\n            });\n            put(1, new ArrayList<List<Object>>() {\n                {\n                    add(new Values(\"cat\"));\n                    add(new Values(\"dog\"));\n                    add(new Values(\"apple\"));\n                    add(new Values(\"banana\"));\n                }\n            });\n            put(2, new ArrayList<List<Object>>() {\n                {\n                    add(new Values(\"cat\"));\n                    add(new Values(\"cat\"));\n                    add(new Values(\"cat\"));\n                    add(new Values(\"cat\"));\n                    add(new Values(\"cat\"));\n                    add(new Values(\"dog\"));\n                    add(new Values(\"dog\"));\n                    add(new Values(\"dog\"));\n                    add(new Values(\"dog\"));\n                }\n            });\n        }\n    };\n    \n<fim_suffix>    public static class Value {\n        int        count = 0;\n        BigInteger txid;\n    }\n    \n    public static Map<String, Value> DATABASE         = new HashMap<String, Value>();\n    public static final String       GLOBAL_COUNT_KEY = \"GLOBAL-COUNT\";\n    \n    public static class BatchCount extends BaseBatchBolt {\n        Object               _id;\n        BatchOutputCollector _collector;\n        \n        int _count = 0;\n        \n        @Override\n        public void prepare(Map conf, TopologyContext context, BatchOutputCollector collector, Object id) {\n            _collector = collector;\n            _id = id;\n        }\n        \n        @Override\n        public void execute(Tuple tuple) {\n            _count++;\n            LOG.info(\"---BatchCount.execute(), _count=\" + _count);\n        }\n        \n        @Override\n        public void finishBatch() {\n            _collector.emit(new Values(_id, _count));\n            LOG.info(\"---BatchCount.finishBatch(), _id=\" + _id + \", _count=\" + _count);\n        }\n        \n        @Override\n        public void declareOutputFields(OutputFieldsDeclarer declarer) {\n            declarer.declare(new Fields(\"id\", \"count\"));\n        }\n    }\n    \n    public static class UpdateGlobalCount extends BaseTransactionalBolt implements ICommitter {\n        TransactionAttempt   _attempt;\n        BatchOutputCollector _collector;\n        \n        int _sum = 0;\n        \n        @Override\n        public void prepare(Map conf, TopologyContext context, BatchOutputCollector collector,\n                TransactionAttempt attempt) {\n            _collector = collector;\n            _attempt = attempt;\n        }\n        \n        @Override\n        public void execute(Tuple tuple) {\n            _sum += tuple.getInteger(1);\n            LOG.info(\"---UpdateGlobalCount.execute(), _sum=\" + _sum);\n        }\n        \n        @Override\n        public void finishBatch() {\n            Value val = DATABASE.get(GLOBAL_COUNT_KEY);\n            Value newval;\n            if (val == null || !val.txid.equals(_attempt.getTransactionId())) {\n                newval = new Value();\n                newval.txid = _attempt.getTransactionId();\n                if (val == null) {\n                    newval.count = _sum;\n                } else {\n                    newval.count = _sum + val.count;\n                }\n                DATABASE.put(GLOBAL_COUNT_KEY, newval);\n            } else {\n                newval = val;\n            }\n            _collector.emit(new Values(_attempt, newval.count));\n            LOG.info(\"---UpdateGlobalCount.finishBatch(), _attempt=\" + _attempt + \", newval=(\" + newval.txid + \",\"\n                    + newval.count + \")\");\n        }\n        \n        @Override\n        public void declareOutputFields(OutputFieldsDeclarer declarer) {\n            declarer.declare(new Fields(\"id\", \"sum\"));\n        }\n    }\n    \n    static boolean isLocal = true;\n    static Config  conf    = JStormHelper.getConfig(null);\n    \n    public static void test() {\n        MemoryTransactionalSpout spout = new MemoryTransactionalSpout(DATA, new Fields(\"word\"),\n                PARTITION_TAKE_PER_BATCH);\n        TransactionalTopologyBuilder builder = new TransactionalTopologyBuilder(\"global-count\", \"spout\", spout, 1);\n        builder.setBolt(\"partial-count\", new BatchCount(), 2).noneGrouping(\"spout\");\n        builder.setBolt(\"sum\", new UpdateGlobalCount(), 1).globalGrouping(\"partial-count\");\n        \n        conf.setDebug(true);\n        conf.setMaxSpoutPending(3);\n        \n        String[] className = Thread.currentThread().getStackTrace()[1].getClassName().split(\"\\\\.\");\n        String topologyName = className[className.length - 1];\n        try {\n            JStormHelper.runTopology(builder.buildTopology(), topologyName, conf, 60,\n                    new JStormHelper.CheckAckedFail(conf), isLocal);\n        } catch (Exception e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n            Assert.fail(\"Failed\");\n        }\n    }\n    \n    public static void main(String[] args) throws Exception {\n        isLocal = false;\n        conf = JStormHelper.getConfig(args);\n        test();\n    }\n}<fim_middle>// class below is data class\n"}