{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the  \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/*\n * $Id: NodeSequence.java 469367 2006-10-31 04:41:08Z minchau $\n */\npackage org.apache.xpath.axes;\nimport java.util.Vector;\nimport org.apache.xml.dtm.DTM;\nimport org.apache.xml.dtm.DTMFilter;\nimport org.apache.xml.dtm.DTMIterator;\nimport org.apache.xml.dtm.DTMManager;\nimport org.apache.xml.utils.NodeVector;\nimport org.apache.xpath.NodeSetDTM;\nimport org.apache.xpath.XPathContext;\nimport org.apache.xpath.objects.XObject;\n/**\n * This class is the dynamic wrapper for a Xalan DTMIterator instance, and \n * provides random access capabilities.\n */\npublic class NodeSequence extends XObject\n  implements DTMIterator, Cloneable, PathComponent\n{\n    static final long serialVersionUID = 3866261934726581044L;\n  /** The index of the last node in the iteration. */\n  protected int m_last = -1;\n  /**\n   * The index of the next node to be fetched.  Useful if this\n   * is a cached iterator, and is being used as random access\n   * NodeList.\n   */\n  protected int m_next = 0;\n  /**\n   * A cache of a list of nodes obtained from the iterator so far.\n   * This list is appended to until the iterator is exhausted and\n   * the cache is complete.\n   * <p>\n   * Multiple NodeSequence objects may share the same cache.\n   */\n  private IteratorCache m_cache;\n  /**\n   * If this iterator needs to cache nodes that are fetched, they\n   * are stored in the Vector in the generic object.\n   */\n  protected NodeVector getVector() {\n      NodeVector nv = (m_cache != null) ?  m_cache.getVector() : null;\n      return nv;\n  }\n  /**\n   * Get the cache (if any) of nodes obtained from\n   * the iterator so far. Note that the cache keeps\n   * growing until the iterator is walked to exhaustion,\n   * at which point the cache is \"complete\".\n   */\n  private IteratorCache getCache() {\n      return m_cache;\n  }\n  /**\n   * Set the vector where nodes will be cached.\n   */\n  protected void SetVector(NodeVector v)\n  {\n  \tsetObject(v);\n  }\n  /**\n   * If the iterator needs to cache nodes as they are fetched,\n   * then this method returns true. \n   */\n  public boolean hasCache()\n  {\n    final NodeVector nv = getVector();\n  \treturn (nv != null);\n  }\n  /**\n   * If this NodeSequence has a cache, and that cache is \n   * fully populated then this method returns true, otherwise\n   * if there is no cache or it is not complete it returns false.\n   */\n  private boolean cacheComplete() {\n      final boolean complete;\n      if (m_cache != null) {\n          complete = m_cache.isComplete();\n      } else {\n          complete = false;\n      }\n      return complete;\n  }\n  /**\n   * If this NodeSequence has a cache, mark that it is complete.\n   * This method should be called after the iterator is exhausted.\n   */\n  private void markCacheComplete() {\n      NodeVector nv = getVector();\n      if (nv != null) {\n          m_cache.setCacheComplete(true);\n      }      \n  }\n  /**\n   * The functional iterator that fetches nodes.\n   */\n  protected DTMIterator m_iter;\n  /**\n   * Set the functional iterator that fetches nodes.\n   * @param iter The iterator that is to be contained.\n   */\n  public final void setIter(DTMIterator iter)\n  {\n  \tm_iter = iter;\n  }\n  /**\n   * Get the functional iterator that fetches nodes.\n   * @return The contained iterator.\n   */\n  public final DTMIterator getContainedIter()\n  {\n  \treturn m_iter;\n  }\n  /**\n   * The DTMManager to use if we're using a NodeVector only.\n   * We may well want to do away with this, and store it in the NodeVector.\n   */\n  protected DTMManager m_dtmMgr;\n  // ==== Constructors ====\n  /**\n   * Create a new NodeSequence from a (already cloned) iterator.\n   * \n   * @param iter Cloned (not static) DTMIterator.\n   * @param context The initial context node.\n   * @param xctxt The execution context.\n   * @param shouldCacheNodes True if this sequence can random access.\n   */\n  private NodeSequence(DTMIterator iter, int context, XPathContext xctxt, boolean shouldCacheNodes)\n  {\n  \tsetIter(iter);\n  \tsetRoot(context, xctxt);\n  \tsetShouldCacheNodes(shouldCacheNodes);\n  }\n  /**\n   * Create a new NodeSequence from a (already cloned) iterator.\n   * \n   * @param nodeVector\n   */\n  public NodeSequence(Object nodeVector)\n  {\n  \tsuper(nodeVector);\n    if (nodeVector instanceof NodeVector) {\n        SetVector((NodeVector) nodeVector);\n    }\n  \tif(null != nodeVector)\n  \t{\n  \t\tassertion(nodeVector instanceof NodeVector, \n  \t\t\t\"Must have a NodeVector as the object for NodeSequence!\");\n  \t\tif(nodeVector instanceof DTMIterator)\n  \t\t{\n  \t\t\tsetIter((DTMIterator)nodeVector);\n  \t\t\tm_last = ((DTMIterator)nodeVector).getLength();\n  \t\t}\n  \t}\n  }\n  /**\n   * Construct an empty XNodeSet object.  This is used to create a mutable \n   * nodeset to which random nodes may be added.\n   */\n  private NodeSequence(DTMManager dtmMgr)\n  {\n    super(new NodeVector());\n    m_last = 0;\n    m_dtmMgr = dtmMgr;\n  }\n  /**\n   * Create a new NodeSequence in an invalid (null) state.\n   */\n  public NodeSequence()\n  {\n      return;\n  }\n  /**\n   * @see DTMIterator#getDTM(int)\n   */\n  public DTM getDTM(int nodeHandle)\n  {\n  \tDTMManager mgr = getDTMManager();\n  \tif(null != mgr)\n    \treturn getDTMManager().getDTM(nodeHandle);\n    else\n    {\n    \tassertion(false, \"Can not get a DTM Unless a DTMManager has been set!\");\n    \treturn null;\n    }\n  }\n  /**\n   * @see DTMIterator#getDTMManager()\n   */\n  public DTMManager getDTMManager()\n  {\n    return m_dtmMgr;\n  }\n  /**\n   * @see DTMIterator#getRoot()\n   */\n<fim_suffix>  public int getRoot()\n  {\n  \tif(null != m_iter)\n    \treturn m_iter.getRoot();\n  \telse\n  \t{\n  \t\t// NodeSetDTM will call this, and so it's not a good thing to throw \n  \t\t// an assertion here.\n  \t\t// assertion(false, \"Can not get the root from a non-iterated NodeSequence!\");\n  \t\treturn DTM.NULL;\n  \t}\n  }\n  /**\n   * @see DTMIterator#setRoot(int, Object)\n   */\n  public void setRoot(int nodeHandle, Object environment)\n  {\n  \tif(null != m_iter)\n  \t{\n  \t\tXPathContext xctxt = (XPathContext)environment;\n  \t\tm_dtmMgr = xctxt.getDTMManager();\n  \t\tm_iter.setRoot(nodeHandle, environment);\n  \t\tif(!m_iter.isDocOrdered())\n  \t\t{\n  \t\t\tif(!hasCache())\n  \t\t\t\tsetShouldCacheNodes(true);\n  \t\t\trunTo(-1);\n  \t\t\tm_next=0;\n  \t\t}\n  \t}\n  \telse\n  \t\tassertion(false, \"Can not setRoot on a non-iterated NodeSequence!\");\n  }\n  /**\n   * @see DTMIterator#reset()\n   */\n  public void reset()\n  {\n  \tm_next = 0;\n  \t// not resetting the iterator on purpose!!!\n  }\n  /**\n   * @see DTMIterator#getWhatToShow()\n   */\n  public int getWhatToShow()\n  {<fim_middle>// function below has no smell\n"}