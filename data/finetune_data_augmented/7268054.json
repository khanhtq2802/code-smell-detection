{"text": "<fim_prefix>                      int width, boolean fixedWidth, boolean topLineOnly,\n                      boolean outlineOnly, double dataFactor, PointsComputer computer) {\n        super((int)Math.ceil(lineWidth), fillColor != null ||\n              (!topLineOnly && !outlineOnly), dataFactor);\n        if (lineColor == null && fillColor == null)\n            throw new IllegalArgumentException(\"lineColor or fillColor must not be null\"); // NOI18N\n        this.lineWidth = (int)Math.ceil(lineWidth);\n        this.lineColor = Utils.checkedColor(lineColor);\n        this.fillColor = Utils.checkedColor(fillColor);\n        definingColor = lineColor != null ? lineColor : fillColor;\n        this.lineStroke = new BasicStroke(lineWidth, BasicStroke.CAP_ROUND,\n                                          BasicStroke.JOIN_ROUND);\n        this.width = width;\n        this.fixedWidth = fixedWidth;\n        this.topLineOnly = topLineOnly;\n        this.outlineOnly = outlineOnly;\n        this.computer = computer;\n    }\n    protected Color getDefiningColor() {\n        return definingColor;\n    }\n    protected void paint(XYItem item, List<ItemSelection> highlighted,\n                         List<ItemSelection> selected, Graphics2D g,\n                         Rectangle dirtyArea, SynchronousXYChartContext context) {\n        int zeroY = 0;\n        int zeroYLimit = 0;\n        if (fillColor != null || !topLineOnly) {\n            zeroY = Utils.checkedInt(context.getViewY(context.getDataOffsetY()));\n            zeroY = Math.max(Utils.checkedInt(context.getViewportOffsetY()), zeroY);\n            zeroY = Math.min(Utils.checkedInt(context.getViewportOffsetY() +\n                                              context.getViewportHeight()), zeroY);\n            zeroYLimit = zeroY - lineWidth + 1;\n        }\n        int outlineWidth = lineColor == null || topLineOnly || outlineOnly ? 0 :\n                           Math.max(1, (width > 0 ? 2 : 1) * lineWidth - 1);\n        int valuesCount = item.getValuesCount();\n        if (width > 0 || lineColor == null || topLineOnly) {\n            int[][] idxs = computer.getVisible(dirtyArea, valuesCount, context,\n                                               1, 0);\n            if (idxs == null) return;\n            int[] visibleIndexes = idxs[0];\n            int npoints = idxs[1][0];\n            int[][] points = computer.createPoints(visibleIndexes, npoints, item,\n                                                   dataFactor, context);\n            int[] xpoints = points[0];\n            int[] ypoints = points[1];\n            int startX = xpoints[0];\n            int stopX;\n            int currentX = startX;\n            int nextX = 0;\n            int itemsOffset = fixedWidth ? 0 : width;\n            for (int i = 0; i < npoints; i++) {\n                int height = zeroY - ypoints[i];\n                if (fixedWidth) {\n                    startX = Math.max(startX, currentX - width / 2);\n                    nextX = i == npoints - 1 ? xpoints[i] : xpoints[i + 1];\n                    stopX = currentX + Math.min(width / 2, (nextX - currentX) / 2);\n                } else {\n                    nextX = i == npoints - 1 ? xpoints[i] : xpoints[i + 1];\n                    int diff = nextX - currentX;\n                    itemsOffset = Math.min(diff, width + 1);\n                    stopX = currentX + (diff - itemsOffset) / 2;\n                }\n                int segmentWidth = stopX - startX;\n                if (fillColor != null && segmentWidth >= outlineWidth) {\n                    g.setColor(fillColor);\n                    g.fillRect(startX, zeroY - height, segmentWidth + 1, height);\n                }\n                if (lineColor != null) {\n                    g.setColor(lineColor);\n                    g.setStroke(lineStroke);\n                    if (topLineOnly) {\n                        g.drawLine(startX, zeroY - height, Math.max(startX + 1, stopX), zeroY - height);\n                    } else if (segmentWidth + 1 <= lineWidth) {\n                        g.drawLine(startX, zeroY - height, startX, zeroYLimit);\n                    } else {\n                        int[] xx;\n                        int[] yy;\n                        if (i == 0) {\n                            xx = xArr(startX, stopX, stopX);\n                            yy = yArr(zeroY - height, zeroY - height, zeroYLimit);\n                        } else if (i == npoints - 1) {\n                            xx = xArr(startX, startX, stopX);\n                            yy = yArr(zeroYLimit, zeroY - height, zeroY - height);\n                        } else {\n                            xx = xArr(startX, startX, stopX, stopX);\n                            yy = yArr(zeroYLimit, zeroY - height, zeroY - height, zeroYLimit);\n                        }\n                        g.drawPolyline(xx, yy, xx.length);\n                    }\n                }\n                currentX = nextX;\n                startX = stopX + itemsOffset;\n            }\n        } else {\n            int extraPoints = fillColor != null ? 2 : 0;\n            int[][] idxs = computer.getVisible(dirtyArea, valuesCount, context,\n                                               2, extraPoints);\n            if (idxs == null) return;\n            int[] visibleIndexes = idxs[0];\n            int npoints = idxs[1][0];\n            int[][] points = computer.createPoints(visibleIndexes, npoints, item,\n                                                   dataFactor, context);\n            int[] xpoints = points[0];\n            int[] ypoints = points[1];\n            int npointse = npoints;\n            npoints -= extraPoints;\n            int index = 1;\n            int lastX = xpoints[0];\n            while (index < npoints - 2) {\n                int currentX = xpoints[index + 1];\n                currentX -= (currentX - lastX) / 2;\n                xpoints[index] = currentX;\n                lastX = xpoints[index + 1];\n                xpoints[index + 1] = currentX;\n                index += 2;\n            }\n            if (fillColor != null) {\n                xpoints[npointse - 2] = xpoints[npointse - 3];\n                ypoints[npointse - 2] = zeroY;\n                xpoints[npointse - 1] = xpoints[0];\n                ypoints[npointse - 1] = ypoints[npointse - 2];\n                POLYGON.xpoints = xpoints;\n                POLYGON.ypoints = ypoints;\n                POLYGON.npoints = npointse;\n                g.setPaint(fillColor);\n                g.fill(POLYGON);\n            }\n            g.setColor(lineColor);\n            g.setStroke(lineStroke);\n            g.drawPolyline(xpoints, ypoints, npoints);\n            if (!outlineOnly) {\n                g.setColor(lineColor);\n                g.setStroke(lineStroke);\n                int i = 1;\n                while (i < npoints - 1) {\n                    int y = ypoints[i] + lineWidth / 2;\n                    if (y < zeroYLimit) g.drawLine(xpoints[i], y, xpoints[i], zeroYLimit);\n                    i += 3;\n                    if (i >= npoints - 1) break;\n                    y = ypoints[i] + lineWidth / 2;\n                    if (y < zeroYLimit) g.drawLine(xpoints[i], y, xpoints[i], zeroYLimit);\n                    i++;\n                }\n            }\n        }\n    }\n    private static int[] xArr(int... vals) {\n        if (vals.length == 3) {\n            x3arr[0] = vals[0];\n            x3arr[1] = vals[1];\n            x3arr[2] = vals[2];\n            return x3arr;\n        } else {\n            x4arr[0] = vals[0];\n            x4arr[1] = vals[1];\n            x4arr[2] = vals[2];\n            x4arr[3] = vals[3];\n            return x4arr;\n        }\n    }\n<fim_suffix>    private static int[] yArr(int... vals) {\n        if (vals.length == 3) {\n            y3arr[0] = vals[0];\n            y3arr[1] = vals[1];\n            y3arr[2] = vals[2];\n            return y3arr;\n        } else {\n            y4arr[0] = vals[0];\n            y4arr[1] = vals[1];\n            y4arr[2] = vals[2];\n            y4arr[3] = vals[3];\n            return y4arr;\n        }\n    }<fim_middle>// function below has no smell\n"}