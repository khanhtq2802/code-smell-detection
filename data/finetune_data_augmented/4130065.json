{"text": "<fim_prefix>  private static void redoReplacement(List<Replacement> replacement) {\n    for (Replacement r : replacement) {\n      r.before.replaceInParent(r.after);\n    }\n  }\n  private static void reverseSubstitute(RelBuilder relBuilder, Holder query,\n      List<List<Replacement>> matches, List<RelNode> sub,\n      int replaceCount, int maxCount) {\n    if (matches.isEmpty()) {\n      return;\n    }\n    final List<List<Replacement>> rem = matches.subList(1, matches.size());\n    reverseSubstitute(relBuilder, query, rem, sub, replaceCount, maxCount);\n    undoReplacement(matches.get(0));\n    if (++replaceCount < maxCount) {\n      sub.add(MutableRels.fromMutable(query.getInput(), relBuilder));\n    }\n    reverseSubstitute(relBuilder, query, rem, sub, replaceCount, maxCount);\n    redoReplacement(matches.get(0));\n  }\n  private UnifyResult matchRecurse(MutableRel target) {\n    assert false; // not called\n    final List<MutableRel> targetInputs = target.getInputs();\n    MutableRel queryParent = null;\n    for (MutableRel targetInput : targetInputs) {\n      UnifyResult unifyResult = matchRecurse(targetInput);\n      if (unifyResult == null) {\n        return null;\n      }\n      queryParent = unifyResult.call.query.replaceInParent(unifyResult.result);\n    }\n    if (targetInputs.isEmpty()) {\n      for (MutableRel queryLeaf : queryLeaves) {\n        for (UnifyRule rule : applicableRules(queryLeaf, target)) {\n          final UnifyResult x = apply(rule, queryLeaf, target);\n          if (x != null) {\n            if (DEBUG) {\n              System.out.println(\"Rule: \" + rule\n                  + \"\\nQuery:\\n\"\n                  + queryParent\n                  + (x.call.query != queryParent\n                     ? \"\\nQuery (original):\\n\"\n                     + queryParent\n                     : \"\")\n                  + \"\\nTarget:\\n\"\n                  + target.deep()\n                  + \"\\nResult:\\n\"\n                  + x.result.deep()\n                  + \"\\n\");\n            }\n            return x;\n          }\n        }\n      }\n    } else {\n      assert queryParent != null;\n      for (UnifyRule rule : applicableRules(queryParent, target)) {\n        final UnifyResult x = apply(rule, queryParent, target);\n        if (x != null) {\n          if (DEBUG) {\n            System.out.println(\n                \"Rule: \" + rule\n                + \"\\nQuery:\\n\"\n                + queryParent.deep()\n                + (x.call.query != queryParent\n                   ? \"\\nQuery (original):\\n\"\n                   + queryParent.toString()\n                   : \"\")\n                + \"\\nTarget:\\n\"\n                + target.deep()\n                + \"\\nResult:\\n\"\n                + x.result.deep()\n                + \"\\n\");\n          }\n          return x;\n        }\n      }\n    }\n    if (DEBUG) {\n      System.out.println(\n          \"Unify failed:\"\n          + \"\\nQuery:\\n\"\n          + queryParent.toString()\n          + \"\\nTarget:\\n\"\n          + target.toString()\n          + \"\\n\");\n    }\n    return null;\n  }\n  private UnifyResult apply(UnifyRule rule, MutableRel query,\n      MutableRel target) {\n    final UnifyRuleCall call = new UnifyRuleCall(rule, query, target, null);\n    return rule.apply(call);\n  }\n  private List<UnifyRule> applicableRules(MutableRel query,\n      MutableRel target) {\n    final Class queryClass = query.getClass();\n    final Class targetClass = target.getClass();\n    final Pair<Class, Class> key = Pair.of(queryClass, targetClass);\n    List<UnifyRule> list = ruleMap.get(key);\n    if (list == null) {\n      final ImmutableList.Builder<UnifyRule> builder =\n          ImmutableList.builder();\n      for (UnifyRule rule : rules) {\n        //noinspection unchecked\n        if (mightMatch(rule, queryClass, targetClass)) {\n          builder.add(rule);\n        }\n      }\n      list = builder.build();\n      ruleMap.put(key, list);\n    }\n    return list;\n  }\n  private static boolean mightMatch(UnifyRule rule,\n      Class queryClass, Class targetClass) {\n    return rule.queryOperand.clazz.isAssignableFrom(queryClass)\n        && rule.targetOperand.clazz.isAssignableFrom(targetClass);\n  }\n  /** Exception thrown to exit a matcher. Not really an error. */\n  protected static class MatchFailed extends ControlFlowException {\n    @SuppressWarnings(\"ThrowableInstanceNeverThrown\")\n    public static final MatchFailed INSTANCE = new MatchFailed();\n  }\n  /** Rule that attempts to match a query relational expression\n   * against a target relational expression.\n   *\n   * <p>The rule declares the query and target types; this allows the\n   * engine to fire only a few rules in a given context.</p>\n   */\n  protected abstract static class UnifyRule {\n    protected final int slotCount;\n    protected final Operand queryOperand;\n    protected final Operand targetOperand;\n    protected UnifyRule(int slotCount, Operand queryOperand,\n        Operand targetOperand) {\n      this.slotCount = slotCount;\n      this.queryOperand = queryOperand;\n      this.targetOperand = targetOperand;\n    }\n    /**\n     * <p>Applies this rule to a particular node in a query. The goal is\n     * to convert {@code query} into {@code target}. Before the rule is\n     * invoked, Calcite has made sure that query's children are equivalent\n     * to target's children.\n     *\n     * <p>There are 3 possible outcomes:</p>\n     *\n     * <ul>\n     *\n     * <li>{@code query} already exactly matches {@code target}; returns\n     * {@code target}</li>\n     *\n     * <li>{@code query} is sufficiently close to a match for\n     * {@code target}; returns {@code target}</li>\n     *\n     * <li>{@code query} cannot be made to match {@code target}; returns\n     * null</li>\n     *\n     * </ul>\n     *\n     * <p>REVIEW: Is possible that we match query PLUS one or more of its\n     * ancestors?</p>\n     *\n     * @param call Input parameters\n     */\n    protected abstract UnifyResult apply(UnifyRuleCall call);\n    protected UnifyRuleCall match(SubstitutionVisitor visitor, MutableRel query,\n        MutableRel target) {\n      if (queryOperand.matches(visitor, query)) {\n        if (targetOperand.matches(visitor, target)) {\n          return visitor.new UnifyRuleCall(this, query, target,\n              copy(visitor.slots, slotCount));\n        }\n      }\n      return null;\n    }\n    protected <E> ImmutableList<E> copy(E[] slots, int slotCount) {\n      // Optimize if there are 0 or 1 slots.\n      switch (slotCount) {\n      case 0:\n        return ImmutableList.of();\n      case 1:\n        return ImmutableList.of(slots[0]);\n      default:\n        return ImmutableList.copyOf(slots).subList(0, slotCount);\n      }\n    }\n  }\n  /**\n   * Arguments to an application of a {@link UnifyRule}.\n   */\n<fim_suffix>  protected class UnifyRuleCall {\n    protected final UnifyRule rule;\n    public final MutableRel query;\n    public final MutableRel target;\n    protected final ImmutableList<MutableRel> slots;\n    public UnifyRuleCall(UnifyRule rule, MutableRel query, MutableRel target,\n        ImmutableList<MutableRel> slots) {\n      this.rule = Objects.requireNonNull(rule);\n      this.query = Objects.requireNonNull(query);\n      this.target = Objects.requireNonNull(target);\n      this.slots = Objects.requireNonNull(slots);\n    }\n    public UnifyResult result(MutableRel result) {\n      assert MutableRels.contains(result, target);\n      assert equalType(\"result\", result, \"query\", query,\n          Litmus.THROW);\n      MutableRel replace = replacementMap.get(target);\n      if (replace != null) {\n        assert false; // replacementMap is always empty\n        // result =\n        replace(result, target, replace);\n      }\n      register(result, query);\n      return new UnifyResult(this, result);\n    }\n    /**\n     * Creates a {@link UnifyRuleCall} based on the parent of {@code query}.\n     */\n    public UnifyRuleCall create(MutableRel query) {\n      return new UnifyRuleCall(rule, query, target, slots);\n    }\n    public RelOptCluster getCluster() {\n      return cluster;\n    }\n    public RexSimplify getSimplify() {\n      return simplify;\n    }\n  }<fim_middle>// class below is data class\n"}