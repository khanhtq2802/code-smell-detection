{"text": "<fim_prefix>        (List<String>) (directoryNameBlackList == null ? Collections.emptyList()\n          : directoryNameBlackList);\n    }\n    @Override\n    protected boolean accept(Path p, @CheckForNull Boolean isDir) {\n      if (!isValidName(p.getName())) {\n        return false;\n      }\n      try {\n        return isDirectory(fs, isDir, p);\n      } catch (IOException e) {\n        LOG.warn(\"An error occurred while verifying if [\" + p.toString()\n            + \"] is a valid directory. Returning 'not valid' and continuing.\", e);\n        return false;\n      }\n    }\n    protected boolean isValidName(final String name) {\n      return !blacklist.contains(name);\n    }\n  }\n  /**\n   * A {@link PathFilter} that only allows directories.\n   */\n  public static class DirFilter extends BlackListDirFilter {\n    public DirFilter(FileSystem fs) {\n      super(fs, null);\n    }\n  }\n  /**\n   * A {@link PathFilter} that returns usertable directories. To get all directories use the\n   * {@link BlackListDirFilter} with a <tt>null</tt> blacklist\n   */\n  public static class UserTableDirFilter extends BlackListDirFilter {\n    public UserTableDirFilter(FileSystem fs) {\n      super(fs, HConstants.HBASE_NON_TABLE_DIRS);\n    }\n    @Override\n    protected boolean isValidName(final String name) {\n      if (!super.isValidName(name))\n        return false;\n      try {\n        TableName.isLegalTableQualifierName(Bytes.toBytes(name));\n      } catch (IllegalArgumentException e) {\n        LOG.info(\"INVALID NAME \" + name);\n        return false;\n      }\n      return true;\n    }\n  }\n  public void recoverFileLease(final FileSystem fs, final Path p, Configuration conf)\n      throws IOException {\n    recoverFileLease(fs, p, conf, null);\n  }\n  /**\n   * Recover file lease. Used when a file might be suspect\n   * to be had been left open by another process.\n   * @param fs FileSystem handle\n   * @param p Path of file to recover lease\n   * @param conf Configuration handle\n   * @throws IOException\n   */\n  public abstract void recoverFileLease(final FileSystem fs, final Path p,\n      Configuration conf, CancelableProgressable reporter) throws IOException;\n  public static List<Path> getTableDirs(final FileSystem fs, final Path rootdir)\n      throws IOException {\n    List<Path> tableDirs = new LinkedList<>();\n    for(FileStatus status :\n        fs.globStatus(new Path(rootdir,\n            new Path(HConstants.BASE_NAMESPACE_DIR, \"*\")))) {\n      tableDirs.addAll(FSUtils.getLocalTableDirs(fs, status.getPath()));\n    }\n    return tableDirs;\n  }\n  /**\n   * @param fs\n   * @param rootdir\n   * @return All the table directories under <code>rootdir</code>. Ignore non table hbase folders such as\n   * .logs, .oldlogs, .corrupt folders.\n   * @throws IOException\n   */\n  public static List<Path> getLocalTableDirs(final FileSystem fs, final Path rootdir)\n      throws IOException {\n    // presumes any directory under hbase.rootdir is a table\n    FileStatus[] dirs = fs.listStatus(rootdir, new UserTableDirFilter(fs));\n    List<Path> tabledirs = new ArrayList<>(dirs.length);\n    for (FileStatus dir: dirs) {\n      tabledirs.add(dir.getPath());\n    }\n    return tabledirs;\n  }\n  /**\n   * Filter for all dirs that don't start with '.'\n   */\n  public static class RegionDirFilter extends AbstractFileStatusFilter {\n    // This pattern will accept 0.90+ style hex region dirs and older numeric region dir names.\n    final public static Pattern regionDirPattern = Pattern.compile(\"^[0-9a-f]*$\");\n    final FileSystem fs;\n    public RegionDirFilter(FileSystem fs) {\n      this.fs = fs;\n    }\n    @Override\n    protected boolean accept(Path p, @CheckForNull Boolean isDir) {\n      if (!regionDirPattern.matcher(p.getName()).matches()) {\n        return false;\n      }\n      try {\n        return isDirectory(fs, isDir, p);\n      } catch (IOException ioe) {\n        // Maybe the file was moved or the fs was disconnected.\n        LOG.warn(\"Skipping file \" + p +\" due to IOException\", ioe);\n        return false;\n      }\n    }\n  }\n  /**\n   * Given a particular table dir, return all the regiondirs inside it, excluding files such as\n   * .tableinfo\n   * @param fs A file system for the Path\n   * @param tableDir Path to a specific table directory &lt;hbase.rootdir&gt;/&lt;tabledir&gt;\n   * @return List of paths to valid region directories in table dir.\n   * @throws IOException\n   */\n  public static List<Path> getRegionDirs(final FileSystem fs, final Path tableDir) throws IOException {\n    // assumes we are in a table dir.\n    List<FileStatus> rds = listStatusWithStatusFilter(fs, tableDir, new RegionDirFilter(fs));\n    if (rds == null) {\n      return Collections.emptyList();\n    }\n    List<Path> regionDirs = new ArrayList<>(rds.size());\n    for (FileStatus rdfs: rds) {\n      Path rdPath = rdfs.getPath();\n      regionDirs.add(rdPath);\n    }\n    return regionDirs;\n  }\n  public static Path getRegionDir(Path tableDir, RegionInfo region) {\n    return new Path(tableDir, ServerRegionReplicaUtil.getRegionInfoForFs(region).getEncodedName());\n  }\n  /**\n   * Filter for all dirs that are legal column family names.  This is generally used for colfam\n   * dirs &lt;hbase.rootdir&gt;/&lt;tabledir&gt;/&lt;regiondir&gt;/&lt;colfamdir&gt;.\n   */\n  public static class FamilyDirFilter extends AbstractFileStatusFilter {\n    final FileSystem fs;\n    public FamilyDirFilter(FileSystem fs) {\n      this.fs = fs;\n    }\n    @Override\n    protected boolean accept(Path p, @CheckForNull Boolean isDir) {\n      try {\n        // throws IAE if invalid\n        HColumnDescriptor.isLegalFamilyName(Bytes.toBytes(p.getName()));\n      } catch (IllegalArgumentException iae) {\n        // path name is an invalid family name and thus is excluded.\n        return false;\n      }\n      try {\n        return isDirectory(fs, isDir, p);\n      } catch (IOException ioe) {\n        // Maybe the file was moved or the fs was disconnected.\n        LOG.warn(\"Skipping file \" + p +\" due to IOException\", ioe);\n        return false;\n      }\n    }\n  }\n  /**\n   * Given a particular region dir, return all the familydirs inside it\n   *\n   * @param fs A file system for the Path\n   * @param regionDir Path to a specific region directory\n   * @return List of paths to valid family directories in region dir.\n   * @throws IOException\n   */\n  public static List<Path> getFamilyDirs(final FileSystem fs, final Path regionDir) throws IOException {\n    // assumes we are in a region dir.\n    FileStatus[] fds = fs.listStatus(regionDir, new FamilyDirFilter(fs));\n    List<Path> familyDirs = new ArrayList<>(fds.length);\n    for (FileStatus fdfs: fds) {\n      Path fdPath = fdfs.getPath();\n      familyDirs.add(fdPath);\n    }\n    return familyDirs;\n  }\n  public static List<Path> getReferenceFilePaths(final FileSystem fs, final Path familyDir) throws IOException {\n    List<FileStatus> fds = listStatusWithStatusFilter(fs, familyDir, new ReferenceFileFilter(fs));\n    if (fds == null) {\n      return Collections.emptyList();\n    }\n    List<Path> referenceFiles = new ArrayList<>(fds.size());\n    for (FileStatus fdfs: fds) {\n      Path fdPath = fdfs.getPath();\n      referenceFiles.add(fdPath);\n    }\n    return referenceFiles;\n  }\n  /**\n   * Filter for HFiles that excludes reference files.\n   */\n<fim_suffix>  public static class HFileFilter extends AbstractFileStatusFilter {\n    final FileSystem fs;\n    public HFileFilter(FileSystem fs) {\n      this.fs = fs;\n    }\n    @Override\n    protected boolean accept(Path p, @CheckForNull Boolean isDir) {\n      if (!StoreFileInfo.isHFile(p)) {\n        return false;\n      }\n      try {\n        return isFile(fs, isDir, p);\n      } catch (IOException ioe) {\n        // Maybe the file was moved or the fs was disconnected.\n        LOG.warn(\"Skipping file \" + p +\" due to IOException\", ioe);\n        return false;\n      }\n    }\n  }<fim_middle>// class below has no smell\n"}