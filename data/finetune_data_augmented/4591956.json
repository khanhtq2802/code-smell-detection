{"text": "<fim_prefix>      fieldName = mapping.columnMap.get(new Pair<Text,Text>(entry.getKey().getColumnFamily(), null));\n    }\n    return fieldName;\n  }\n  private void setFetchColumns(Scanner scanner, String[] fields) {\n    fields = getFieldsToQuery(fields);\n    for (String field : fields) {\n      Pair<Text,Text> col = mapping.fieldMap.get(field);\n      if (col != null) {\n        if (col.getSecond() == null) {\n          scanner.fetchColumnFamily(col.getFirst());\n        } else {\n          scanner.fetchColumn(col.getFirst(), col.getSecond());\n        }\n      } else {\n        LOG.error(\"Mapping not found for field: {}\", field);\n      }\n    }\n  }\n  @Override\n  public T get(K key, String[] fields) throws GoraException {\n    try {\n      // TODO make isolated scanner optional?\n      Scanner scanner = new IsolatedScanner(conn.createScanner(mapping.tableName, Authorizations.EMPTY));\n      Range rowRange = new Range(new Text(toBytes(key)));\n      scanner.setRange(rowRange);\n      setFetchColumns(scanner, fields);\n      T persistent = newPersistent();\n      ByteSequence row = populate(scanner.iterator(), persistent);\n      if (row == null)\n        return null;\n      return persistent;\n    } catch (Exception e) {\n      throw new GoraException(e);\n    }\n  }\n  @Override\n  public void put(K key, T val) throws GoraException {\n    try{\n      Mutation m = new Mutation(new Text(toBytes(key)));\n      Schema schema = val.getSchema();\n      List<Field> fields = schema.getFields();\n      int count = 0;\n      for (int i = 0; i < fields.size(); i++) {\n        if (!val.isDirty(i)) {\n          continue;\n        }\n        Field field = fields.get(i);\n        Object o = val.get(field.pos());\n        Pair<Text,Text> col = mapping.fieldMap.get(field.name());\n        if (col == null) {\n          throw new GoraException(\"Please define the gora to accumulo mapping for field \" + field.name());\n        }\n        switch (field.schema().getType()) {\n        case MAP:\n          count = putMap(m, count, field.schema().getValueType(), o, col, field.name());\n          break;\n        case ARRAY:\n          count = putArray(m, count, o, col, field.name());\n          break;\n        case UNION: // default value of null acts like union with null\n          Schema effectiveSchema = field.schema().getTypes()\n          .get(firstNotNullSchemaTypeIndex(field.schema()));\n          // map and array need to compute qualifier\n          if (effectiveSchema.getType() == Type.ARRAY) {\n            count = putArray(m, count, o, col, field.name());\n            break;\n          }\n          else if (effectiveSchema.getType() == Type.MAP) {\n            count = putMap(m, count, effectiveSchema.getValueType(), o, col, field.name());\n            break;\n          }\n          // continue like a regular top-level union\n        case RECORD:\n          final SpecificDatumWriter<Object> writer = new SpecificDatumWriter<>(field.schema());\n          final byte[] byteData = IOUtils.serialize(writer, o);\n          m.put(col.getFirst(), col.getSecond(), new Value(byteData));\n          count++;\n          break;\n        default:\n          m.put(col.getFirst(), col.getSecond(), new Value(toBytes(o)));\n          count++;\n        }\n      }\n      if (count > 0)\n        try {\n          getBatchWriter().addMutation(m);\n        } catch (MutationsRejectedException e) {\n          LOG.error(e.getMessage(), e);\n        }\n    } catch (GoraException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new GoraException(e);\n    }\n  }\n  private int putMap(Mutation m, int count, Schema valueType, Object o, Pair<Text, Text> col, String fieldName) throws GoraException {\n    // First of all we delete map field on accumulo store\n    Text rowKey = new Text(m.getRow());\n    Query<K, T> query = newQuery();\n    query.setFields(fieldName);\n    query.setStartKey((K)rowKey.toString());\n    query.setEndKey((K)rowKey.toString());\n    deleteByQuery(query);\n    flush();\n    if (o == null){\n      return 0;\n    }\n    Set<?> es = ((Map<?, ?>)o).entrySet();\n    for (Object entry : es) {\n      Object mapKey = ((Entry<?, ?>) entry).getKey();\n      Object mapVal = ((Entry<?, ?>) entry).getValue();\n      if ((o instanceof DirtyMapWrapper && ((DirtyMapWrapper<?, ?>)o).isDirty())\n          || !(o instanceof DirtyMapWrapper)) {\n        m.put(col.getFirst(), new Text(toBytes(mapKey)), new Value(toBytes(valueType, mapVal)));\n        count++;\n      }\n      // TODO map value deletion\n    }\n    return count;\n  }\n  private int putArray(Mutation m, int count, Object o, Pair<Text, Text> col, String fieldName) throws GoraException {\n    // First of all we delete array field on accumulo store\n    Text rowKey = new Text(m.getRow());\n    Query<K, T> query = newQuery();\n    query.setFields(fieldName);\n    query.setStartKey((K)rowKey.toString());\n    query.setEndKey((K)rowKey.toString());\n    deleteByQuery(query);\n    flush();\n    if (o == null){\n      return 0;\n    }\n    List<?> array = (List<?>) o;  // both GenericArray and DirtyListWrapper\n    int j = 0;\n    for (Object item : array) {\n      m.put(col.getFirst(), new Text(toBytes(j++)), new Value(toBytes(item)));\n      count++;\n    }\n    return count;\n  }\n  @Override\n  public boolean delete(K key) throws GoraException {\n    Query<K,T> q = newQuery();\n    q.setKey(key);\n    return deleteByQuery(q) > 0;\n  }\n  @Override\n  public long deleteByQuery(Query<K,T> query) throws GoraException {\n    try {\n      Scanner scanner = createScanner(query);\n      // add iterator that drops values on the server side\n      scanner.addScanIterator(new IteratorSetting(Integer.MAX_VALUE, SortedKeyIterator.class));\n      RowIterator iterator = new RowIterator(scanner.iterator());\n      long count = 0;\n      while (iterator.hasNext()) {\n        Iterator<Entry<Key,Value>> row = iterator.next();\n        Mutation m = null;\n        while (row.hasNext()) {\n          Entry<Key,Value> entry = row.next();\n          Key key = entry.getKey();\n          if (m == null)\n            m = new Mutation(key.getRow());\n          // TODO optimize to avoid continually creating column vis? prob does not matter for empty\n          m.putDelete(key.getColumnFamily(), key.getColumnQualifier(), new ColumnVisibility(key.getColumnVisibility()), key.getTimestamp());\n        }\n        getBatchWriter().addMutation(m);\n        count++;\n      }\n      return count;\n    } catch (Exception e) {\n      throw new GoraException(e);\n    }\n  }\n  private Range createRange(Query<K,T> query) {\n    Text startRow = null;\n    Text endRow = null;\n    if (query.getStartKey() != null)\n      startRow = new Text(toBytes(query.getStartKey()));\n    if (query.getEndKey() != null)\n      endRow = new Text(toBytes(query.getEndKey()));\n    return new Range(startRow, true, endRow, true);\n  }\n<fim_suffix>  private Scanner createScanner(Query<K,T> query) throws TableNotFoundException {\n    // TODO make isolated scanner optional?\n    Scanner scanner = new IsolatedScanner(conn.createScanner(mapping.tableName, Authorizations.EMPTY));\n    setFetchColumns(scanner, query.getFields());\n    scanner.setRange(createRange(query));\n    if (query.getStartTime() != -1 || query.getEndTime() != -1) {\n      IteratorSetting is = new IteratorSetting(30, TimestampFilter.class);\n      if (query.getStartTime() != -1)\n        TimestampFilter.setStart(is, query.getStartTime(), true);\n      if (query.getEndTime() != -1)\n        TimestampFilter.setEnd(is, query.getEndTime(), true);\n      scanner.addScanIterator(is);\n    }\n    return scanner;\n  }<fim_middle>// function below has no smell\n"}