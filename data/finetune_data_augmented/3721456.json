{"text": "<fim_prefix>                boolean newlyAdded = (Boolean)hook.apply(item);\n                assert newlyAdded;\n            });\n            set.clear();\n        }\n        void commit() {\n            Set var10001 = this.classes;\n            AtlasVirtualFile.VirtualFileIndexedItemCollection var10002 = this.base;\n            this.base.getClass();\n            this.commitItemsIn(var10001, var10002::addClass);\n            var10001 = this.fields;\n            var10002 = this.base;\n            this.base.getClass();\n            this.commitItemsIn(var10001, var10002::addField);\n            var10001 = this.methods;\n            var10002 = this.base;\n            this.base.getClass();\n            this.commitItemsIn(var10001, var10002::addMethod);\n            var10001 = this.protos;\n            var10002 = this.base;\n            this.base.getClass();\n            this.commitItemsIn(var10001, var10002::addProto);\n            var10001 = this.types;\n            var10002 = this.base;\n            this.base.getClass();\n            this.commitItemsIn(var10001, var10002::addType);\n            var10001 = this.strings;\n            var10002 = this.base;\n            this.base.getClass();\n            this.commitItemsIn(var10001, var10002::addString);\n            var10001 = this.callSites;\n            var10002 = this.base;\n            this.base.getClass();\n            this.commitItemsIn(var10001, var10002::addCallSite);\n            var10001 = this.methodHandles;\n            var10002 = this.base;\n            this.base.getClass();\n            this.commitItemsIn(var10001, var10002::addMethodHandle);\n        }\n        void abort() {\n            this.classes.clear();\n            this.fields.clear();\n            this.methods.clear();\n            this.protos.clear();\n            this.types.clear();\n            this.strings.clear();\n        }\n        public boolean isEmpty() {\n            return this.classes.isEmpty() && this.fields.isEmpty() && this.methods.isEmpty() && this.protos.isEmpty() && this.types.isEmpty() && this.strings.isEmpty();\n        }\n        int getNumberOfStrings() {\n            return this.strings.size() + this.base.getNumberOfStrings();\n        }\n        int getNumberOfClasses() {\n            return this.classes.size() + this.base.classes.size();\n        }\n    }\n    private static class VirtualFileIndexedItemCollection implements IndexedItemCollection {\n        final int id;\n        private final List<DexProgramClass> classes;\n        private final List<DexProto> protos;\n        private final List<DexType> types;\n        private final List<DexMethod> methods;\n        private final List<DexField> fields;\n        private final List<DexString> strings;\n        private final List<DexCallSite> callSites;\n        private final List<DexMethodHandle> methodHandles;\n        private final Set<DexClass> seenClasses;\n        private VirtualFileIndexedItemCollection(int id) {\n            this.classes = new ArrayList();\n            this.protos = new ArrayList();\n            this.types = new ArrayList();\n            this.methods = new ArrayList();\n            this.fields = new ArrayList();\n            this.strings = new ArrayList();\n            this.callSites = new ArrayList();\n            this.methodHandles = new ArrayList();\n            this.seenClasses = Sets.newIdentityHashSet();\n            this.id = id;\n        }\n        private <T extends IndexedDexItem> boolean addItem(T item, List<T> itemList) {\n            assert item != null;\n            if (item.assignToVirtualFile(this.id)) {\n                itemList.add(item);\n                return true;\n            } else {\n                return false;\n            }\n        }\n        public boolean addClass(DexProgramClass clazz) {\n            if (this.seenClasses.add(clazz)) {\n                this.classes.add(clazz);\n                return true;\n            } else {\n                return false;\n            }\n        }\n        public boolean addField(DexField field) {\n            return this.addItem(field, this.fields);\n        }\n        public boolean addMethod(DexMethod method) {\n            return this.addItem(method, this.methods);\n        }\n        public boolean addString(DexString string) {\n            return this.addItem(string, this.strings);\n        }\n        public boolean addProto(DexProto proto) {\n            return this.addItem(proto, this.protos);\n        }\n        public boolean addCallSite(DexCallSite callSite) {\n            return this.addItem(callSite, this.callSites);\n        }\n        public boolean addMethodHandle(DexMethodHandle methodHandle) {\n            return this.addItem(methodHandle, this.methodHandles);\n        }\n        public boolean addType(DexType type) {\n            return this.addItem(type, this.types);\n        }\n        public int getNumberOfMethods() {\n            return this.methods.size();\n        }\n        public int getNumberOfFields() {\n            return this.fields.size();\n        }\n        public int getNumberOfStrings() {\n            return this.strings.size();\n        }\n    }\n<fim_suffix>    public static class PackageMapDistributor extends AtlasVirtualFile.DistributorBase {\n        private final PackageDistribution packageDistribution;\n        private final ExecutorService executorService;\n        PackageMapDistributor(ApplicationWriter writer, PackageDistribution packageDistribution, ExecutorService executorService) {\n            super(writer);\n            this.packageDistribution = packageDistribution;\n            this.executorService = executorService;\n        }\n        public Map<Integer, AtlasVirtualFile> run() throws ExecutionException, IOException {\n            assert this.nameToFileMap.size() == 1;\n            assert this.nameToFileMap.containsKey(0);\n            int maxReferencedIndex = this.packageDistribution.maxReferencedIndex();\n            for(int index = 1; index <= maxReferencedIndex; ++index) {\n                AtlasVirtualFile file = new AtlasVirtualFile(index, this.writer.namingLens);\n                this.nameToFileMap.put(index, file);\n            }\n            this.fillForMainDexList(this.classes);\n            this.classes = this.sortClassesByPackage(this.classes, this.originalNames);\n            Set<String> usedPrefixes = this.fillForDistribution(this.classes, this.originalNames);\n            Map newAssignments;\n            if (this.classes.isEmpty()) {\n                newAssignments = Collections.emptyMap();\n            } else {\n                newAssignments = (new AtlasVirtualFile.PackageSplitPopulator(this.nameToFileMap, this.classes, this.originalNames, usedPrefixes, this.application.dexItemFactory, AtlasVirtualFile.FillStrategy.LEAVE_SPACE_FOR_GROWTH, this.writer.namingLens)).call();\n                if (!newAssignments.isEmpty() && this.nameToFileMap.size() > 1) {\n                    System.err.println(\" * The used package map is missing entries. The following default mappings have been used:\");\n                    this.writeAssignments(newAssignments, new OutputStreamWriter(System.err));\n                    System.err.println(\" * Consider updating the map.\");\n                }\n            }\n            Path newPackageMap = Paths.get(\"package.map\");\n            System.out.println(\" - \" + newPackageMap.toString());\n            PackageDistribution.writePackageToFileMap(newPackageMap, newAssignments, this.packageDistribution);\n            return this.nameToFileMap;\n        }\n        private Set<String> fillForDistribution(Set<DexProgramClass> classes, Map<DexProgramClass, String> originalNames) throws ExecutionException {\n            Set<String> usedPrefixes = null;\n            if (this.packageDistribution != null) {\n                ArrayList<Future<List<DexProgramClass>>> futures = new ArrayList(this.nameToFileMap.size());\n                usedPrefixes = this.packageDistribution.getFiles();\n                Iterator var5 = this.nameToFileMap.values().iterator();\n                while(var5.hasNext()) {\n                    AtlasVirtualFile file = (AtlasVirtualFile)var5.next();\n                    AtlasVirtualFile.PackageMapPopulator populator = new AtlasVirtualFile.PackageMapPopulator(file, classes, this.packageDistribution, originalNames);\n                    futures.add(this.executorService.submit(populator));\n                }\n                ThreadUtils.awaitFutures(futures).forEach(classes::removeAll);\n            }\n            return usedPrefixes;\n        }\n        private void writeAssignments(Map<String, Integer> assignments, Writer output) throws IOException {\n            Iterator var3 = assignments.entrySet().iterator();\n            while(var3.hasNext()) {\n                Map.Entry<String, Integer> entry = (Map.Entry)var3.next();\n                output.write(\"    \");\n                PackageDistribution.formatEntry(entry, output);\n                output.write(\"\\n\");\n            }\n            output.flush();\n        }\n    }<fim_middle>// class below has no smell\n"}