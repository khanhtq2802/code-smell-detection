{"text": "<fim_prefix> * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.hama.ipc;\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.*;\nimport io.netty.channel.epoll.EpollEventLoopGroup;\nimport io.netty.channel.epoll.EpollServerSocketChannel;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.handler.codec.LengthFieldBasedFrameDecoder;\nimport io.netty.util.ReferenceCountUtil;\nimport io.netty.util.concurrent.GenericFutureListener;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.io.IOUtils;\nimport org.apache.hadoop.io.Writable;\nimport org.apache.hadoop.io.WritableUtils;\nimport org.apache.hadoop.security.SaslRpcServer.AuthMethod;\nimport org.apache.hadoop.security.UserGroupInformation;\nimport org.apache.hadoop.security.token.SecretManager;\nimport org.apache.hadoop.security.token.TokenIdentifier;\nimport org.apache.hadoop.util.ReflectionUtils;\nimport org.apache.hadoop.util.StringUtils;\nimport java.io.*;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.WritableByteChannel;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.*;\n/**\n * An abstract IPC service using netty. IPC calls take a single {@link Writable}\n * as a parameter, and return a {@link Writable}*\n * \n * @see AsyncServer\n */\npublic abstract class AsyncServer {\n  private AuthMethod authMethod;\n  static final ByteBuffer HEADER = ByteBuffer.wrap(\"hrpc\".getBytes());\n  static int INITIAL_RESP_BUF_SIZE = 1024;\n  UserGroupInformation user = null;\n  // 1 : Introduce ping and server does not throw away RPCs\n  // 3 : Introduce the protocol into the RPC connection header\n  // 4 : Introduced SASL security layer\n  static final byte CURRENT_VERSION = 4;\n  static final int HEADER_LENGTH = 10;\n  // follows version is read\n  private Configuration conf;\n  private final boolean tcpNoDelay; // if T then disable Nagle's Algorithm\n  private int backlogLength;;\n  InetSocketAddress address;\n  private static final Log LOG = LogFactory.getLog(AsyncServer.class);\n  private static int NIO_BUFFER_LIMIT = 8 * 1024;\n  private final int maxRespSize;\n  static final String IPC_SERVER_RPC_MAX_RESPONSE_SIZE_KEY = \"ipc.server.max.response.size\";\n  static final int IPC_SERVER_RPC_MAX_RESPONSE_SIZE_DEFAULT = 1024 * 1024;\n  private static final ThreadLocal<AsyncServer> SERVER = new ThreadLocal<AsyncServer>();\n  private int port; // port we listen on\n  private Class<? extends Writable> paramClass; // class of call parameters\n  // Configure the server.(constructor is thread num)\n  private EventLoopGroup bossGroup = new EpollEventLoopGroup(1);\n  private EventLoopGroup workerGroup = new EpollEventLoopGroup();\n  private static final Map<String, Class<?>> PROTOCOL_CACHE = new ConcurrentHashMap<String, Class<?>>();\n  private ExceptionsHandler exceptionsHandler = new ExceptionsHandler();\n  static Class<?> getProtocolClass(String protocolName, Configuration conf)\n      throws ClassNotFoundException {\n    Class<?> protocol = PROTOCOL_CACHE.get(protocolName);\n    if (protocol == null) {\n      protocol = conf.getClassByName(protocolName);\n      PROTOCOL_CACHE.put(protocolName, protocol);\n    }\n    return protocol;\n  }\n  /**\n   * Getting address\n   * \n   * @return InetSocketAddress\n   */\n  public InetSocketAddress getAddress() {\n    return address;\n  }\n  /**\n   * Returns the server instance called under or null. May be called under\n   * {@link #call(Writable, long)} implementations, and under {@link Writable}\n   * methods of paramters and return values. Permits applications to access the\n   * server context.\n   * \n   * @return NioServer\n   */\n  public static AsyncServer get() {\n    return SERVER.get();\n  }\n  /**\n   * Constructs a server listening on the named port and address. Parameters\n   * passed must be of the named class. The\n   * <code>handlerCount</handlerCount> determines\n   * the number of handler threads that will be used to process calls.\n   * \n   * @param bindAddress\n   * @param port\n   * @param paramClass\n   * @param handlerCount\n   * @param conf\n   * @throws IOException\n   */\n  protected AsyncServer(String bindAddress, int port,\n      Class<? extends Writable> paramClass, int handlerCount, Configuration conf)\n      throws IOException {\n    this(bindAddress, port, paramClass, handlerCount, conf, Integer\n        .toString(port), null);\n  }\n  protected AsyncServer(String bindAddress, int port,\n      Class<? extends Writable> paramClass, int handlerCount,\n      Configuration conf, String serverName) throws IOException {\n    this(bindAddress, port, paramClass, handlerCount, conf, serverName, null);\n  }\n  protected AsyncServer(String bindAddress, int port,\n      Class<? extends Writable> paramClass, int handlerCount,\n      Configuration conf, String serverName,\n      SecretManager<? extends TokenIdentifier> secretManager)\n      throws IOException {\n    this.conf = conf;\n    this.port = port;\n    this.address = new InetSocketAddress(bindAddress, port);\n    this.paramClass = paramClass;\n    this.maxRespSize = conf.getInt(IPC_SERVER_RPC_MAX_RESPONSE_SIZE_KEY,\n        IPC_SERVER_RPC_MAX_RESPONSE_SIZE_DEFAULT);\n    this.tcpNoDelay = conf.getBoolean(\"ipc.server.tcpnodelay\", true);\n    this.backlogLength = conf.getInt(\"ipc.server.listen.queue.size\", 100);\n  }\n  /** start server listener */\n  public void start() throws ExecutionException, InterruptedException {\n    ExecutorService es = Executors.newSingleThreadExecutor();\n    Future<ChannelFuture> future = es.submit(new NioServerListener());\n    try {\n      ChannelFuture closeFuture = future.get();\n      closeFuture\n          .addListener(new GenericFutureListener<io.netty.util.concurrent.Future<Void>>() {\n            @Override\n            public void operationComplete(\n                io.netty.util.concurrent.Future<Void> voidFuture)\n                throws Exception {\n              // Stop the server gracefully if it's not terminated.\n              stop();\n            }\n          });\n    } finally {\n      es.shutdown();\n    }\n  }\n<fim_suffix>  private class NioServerListener implements Callable<ChannelFuture> {\n    /**\n     * Configure and start nio server\n     */\n    @Override\n    public ChannelFuture call() throws Exception {\n      SERVER.set(AsyncServer.this);\n      // ServerBootstrap is a helper class that sets up a server\n      ServerBootstrap b = new ServerBootstrap();\n      b.group(bossGroup, workerGroup)\n          .channel(EpollServerSocketChannel.class)\n          .option(ChannelOption.SO_BACKLOG, backlogLength)\n          .childOption(ChannelOption.MAX_MESSAGES_PER_READ, NIO_BUFFER_LIMIT)\n          .childOption(ChannelOption.TCP_NODELAY, tcpNoDelay)\n          .childOption(ChannelOption.SO_KEEPALIVE, true)\n          .childOption(ChannelOption.SO_RCVBUF, 30 * 1024 * 1024)\n          .childOption(ChannelOption.RCVBUF_ALLOCATOR,\n              new FixedRecvByteBufAllocator(100 * 1024))\n          .childHandler(new ChannelInitializer<SocketChannel>() {\n            @Override\n            public void initChannel(SocketChannel ch) throws Exception {\n              ChannelPipeline p = ch.pipeline();\n              // Register accumulation processing handler\n              p.addLast(new NioFrameDecoder(100 * 1024 * 1024, 0, 4, 0, 0));\n              // Register message processing handler\n              p.addLast(new NioServerInboundHandler());\n            }\n          });\n      // Bind and start to accept incoming connections.\n      ChannelFuture f = b.bind(port).sync();\n      LOG.info(\"AsyncServer startup\");\n      return f.channel().closeFuture();\n    }\n  }<fim_middle>// class below is blob\n"}