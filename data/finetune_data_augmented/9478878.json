{"text": "<fim_prefix>\n<fim_suffix>@InterfaceAudience.Private\npublic class KMSClientProvider extends KeyProvider implements CryptoExtension,\n    KeyProviderDelegationTokenExtension.DelegationTokenExtension {\n  static final Logger LOG =\n      LoggerFactory.getLogger(KMSClientProvider.class);\n  private static final String INVALID_SIGNATURE = \"Invalid signature\";\n  private static final String ANONYMOUS_REQUESTS_DISALLOWED = \"Anonymous requests are disallowed\";\n  public static final String TOKEN_KIND_STR = KMSDelegationToken.TOKEN_KIND_STR;\n  public static final Text TOKEN_KIND = KMSDelegationToken.TOKEN_KIND;\n  public static final String SCHEME_NAME = \"kms\";\n  private static final String UTF8 = \"UTF-8\";\n  private static final String CONTENT_TYPE = \"Content-Type\";\n  private static final String APPLICATION_JSON_MIME = \"application/json\";\n  private static final String HTTP_GET = \"GET\";\n  private static final String HTTP_POST = \"POST\";\n  private static final String HTTP_PUT = \"PUT\";\n  private static final String HTTP_DELETE = \"DELETE\";\n  private static final String CONFIG_PREFIX = \"hadoop.security.kms.client.\";\n  /* Number of times to retry authentication in the event of auth failure\n   * (normally happens due to stale authToken) \n   */\n  public static final String AUTH_RETRY = CONFIG_PREFIX\n      + \"authentication.retry-count\";\n  public static final int DEFAULT_AUTH_RETRY = 1;\n  private final ValueQueue<EncryptedKeyVersion> encKeyVersionQueue;\n  private KeyProviderDelegationTokenExtension.DelegationTokenExtension\n      clientTokenProvider = this;\n  // the token's service.\n  private final Text dtService;\n  // alias in the credentials.\n  private final Text canonicalService;\n  private class EncryptedQueueRefiller implements\n    ValueQueue.QueueRefiller<EncryptedKeyVersion> {\n    @Override\n    public void fillQueueForKey(String keyName,\n        Queue<EncryptedKeyVersion> keyQueue, int numEKVs) throws IOException {\n      checkNotNull(keyName, \"keyName\");\n      Map<String, String> params = new HashMap<String, String>();\n      params.put(KMSRESTConstants.EEK_OP, KMSRESTConstants.EEK_GENERATE);\n      params.put(KMSRESTConstants.EEK_NUM_KEYS, \"\" + numEKVs);\n      URL url = createURL(KMSRESTConstants.KEY_RESOURCE, keyName,\n          KMSRESTConstants.EEK_SUB_RESOURCE, params);\n      HttpURLConnection conn = createConnection(url, HTTP_GET);\n      conn.setRequestProperty(CONTENT_TYPE, APPLICATION_JSON_MIME);\n      List response = call(conn, null,\n          HttpURLConnection.HTTP_OK, List.class);\n      List<EncryptedKeyVersion> ekvs =\n          parseJSONEncKeyVersions(keyName, response);\n      keyQueue.addAll(ekvs);\n    }\n  }\n  static class TokenSelector extends AbstractDelegationTokenSelector {\n    static final TokenSelector INSTANCE = new TokenSelector();\n    TokenSelector() {\n      super(TOKEN_KIND);\n    }\n  }\n  /**\n   * The KMS implementation of {@link TokenRenewer}.\n   */\n  public static class KMSTokenRenewer extends TokenRenewer {\n    private static final Logger LOG =\n        LoggerFactory.getLogger(KMSTokenRenewer.class);\n    @Override\n    public boolean handleKind(Text kind) {\n      return kind.equals(TOKEN_KIND);\n    }\n    @Override\n    public boolean isManaged(Token<?> token) throws IOException {\n      return true;\n    }\n    @Override\n    public long renew(Token<?> token, Configuration conf) throws IOException {\n      LOG.debug(\"Renewing delegation token {}\", token);\n      KeyProvider keyProvider = createKeyProvider(token, conf);\n      try {\n        if (!(keyProvider instanceof\n            KeyProviderDelegationTokenExtension.DelegationTokenExtension)) {\n          throw new IOException(String\n              .format(\"keyProvider %s cannot renew token [%s]\",\n                  keyProvider == null ? \"null\" : keyProvider.getClass(),\n                  token));\n        }\n        return ((KeyProviderDelegationTokenExtension.DelegationTokenExtension)\n            keyProvider).renewDelegationToken(token);\n      } finally {\n        if (keyProvider != null) {\n          keyProvider.close();\n        }\n      }\n    }\n    @Override\n    public void cancel(Token<?> token, Configuration conf) throws IOException {\n      LOG.debug(\"Canceling delegation token {}\", token);\n      KeyProvider keyProvider = createKeyProvider(token, conf);\n      try {\n        if (!(keyProvider instanceof\n            KeyProviderDelegationTokenExtension.DelegationTokenExtension)) {\n          throw new IOException(String\n              .format(\"keyProvider %s cannot cancel token [%s]\",\n                  keyProvider == null ? \"null\" : keyProvider.getClass(),\n                  token));\n        }\n        ((KeyProviderDelegationTokenExtension.DelegationTokenExtension)\n            keyProvider).cancelDelegationToken(token);\n      } finally {\n        if (keyProvider != null) {\n          keyProvider.close();\n        }\n      }\n    }\n    private static KeyProvider createKeyProvider(\n        Token<?> token, Configuration conf) throws IOException {\n      String service = token.getService().toString();\n      URI uri;\n      if (service != null && service.startsWith(SCHEME_NAME + \":/\")) {\n        LOG.debug(\"Creating key provider with token service value {}\", service);\n        uri = URI.create(service);\n      } else { // conf fallback\n        uri = KMSUtil.getKeyProviderUri(conf);\n      }\n      return (uri != null) ? KMSUtil.createKeyProviderFromUri(conf, uri) : null;\n    }\n  }\n  public static class KMSEncryptedKeyVersion extends EncryptedKeyVersion {\n    public KMSEncryptedKeyVersion(String keyName, String keyVersionName,\n        byte[] iv, String encryptedVersionName, byte[] keyMaterial) {\n      super(keyName, keyVersionName, iv, new KMSKeyVersion(null, \n          encryptedVersionName, keyMaterial));\n    }\n  }\n  private static void writeJson(Object obj, OutputStream os)\n      throws IOException {\n    Writer writer = new OutputStreamWriter(os, StandardCharsets.UTF_8);\n    JsonSerialization.writer().writeValue(writer, obj);\n  }\n  /**\n   * The factory to create KMSClientProvider, which is used by the\n   * ServiceLoader.\n   */\n  public static class Factory extends KeyProviderFactory {\n    /**\n     * This provider expects URIs in the following form :\n     * {@literal kms://<PROTO>@<AUTHORITY>/<PATH>}\n     *\n     * where :\n     * - PROTO = http or https\n     * - AUTHORITY = {@literal <HOSTS>[:<PORT>]}\n     * - HOSTS = {@literal <HOSTNAME>[;<HOSTS>]}\n     * - HOSTNAME = string\n     * - PORT = integer\n     *\n     * This will always create a {@link LoadBalancingKMSClientProvider}\n     * if the uri is correct.\n     */\n    @Override\n    public KeyProvider createProvider(URI providerUri, Configuration conf)\n        throws IOException {\n      if (SCHEME_NAME.equals(providerUri.getScheme())) {\n        URL origUrl = new URL(extractKMSPath(providerUri).toString());\n        String authority = origUrl.getAuthority();\n        // check for ';' which delimits the backup hosts\n        if (Strings.isNullOrEmpty(authority)) {\n          throw new IOException(\n              \"No valid authority in kms uri [\" + origUrl + \"]\");\n        }\n        // Check if port is present in authority\n        // In the current scheme, all hosts have to run on the same port\n        int port = -1;\n        String hostsPart = authority;\n        if (authority.contains(\":\")) {\n          String[] t = authority.split(\":\");\n          try {\n            port = Integer.parseInt(t[1]);\n          } catch (Exception e) {\n            throw new IOException(\n                \"Could not parse port in kms uri [\" + origUrl + \"]\");\n          }\n          hostsPart = t[0];\n        }\n        KMSClientProvider[] providers =\n            createProviders(conf, origUrl, port, hostsPart);\n        return new LoadBalancingKMSClientProvider(providerUri, providers, conf);\n      }\n      return null;\n    }\n    private KMSClientProvider[] createProviders(Configuration conf,\n        URL origUrl, int port, String hostsPart) throws IOException {\n      String[] hosts = hostsPart.split(\";\");\n      KMSClientProvider[] providers = new KMSClientProvider[hosts.length];\n      for (int i = 0; i < hosts.length; i++) {\n        try {\n          providers[i] =\n              new KMSClientProvider(\n                  new URI(\"kms\", origUrl.getProtocol(), hosts[i], port,\n                      origUrl.getPath(), null, null), conf);\n        } catch (URISyntaxException e) {\n          throw new IOException(\"Could not instantiate KMSProvider.\", e);\n        }\n      }\n      return providers;\n    }\n  }\n  private URL kmsUrl;\n  private SSLFactory sslFactory;\n  private ConnectionConfigurator configurator;\n  private DelegationTokenAuthenticatedURL.Token authToken;<fim_middle>// class below has no smell\n"}