{"text": "<fim_prefix>/*\n * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage jdk.jfr.internal.consumer;\nimport java.io.DataInput;\nimport java.io.EOFException;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.nio.charset.Charset;\npublic final class RecordingInput implements DataInput, AutoCloseable {\n    public static final byte STRING_ENCODING_NULL = 0;\n    public static final byte STRING_ENCODING_EMPTY_STRING = 1;\n    public static final byte STRING_ENCODING_CONSTANT_POOL = 2;\n    public static final byte STRING_ENCODING_UTF8_BYTE_ARRAY = 3;\n    public static final byte STRING_ENCODING_CHAR_ARRAY = 4;\n    public static final byte STRING_ENCODING_LATIN1_BYTE_ARRAY = 5;\n    private final static int DEFAULT_BLOCK_SIZE = 16 * 1024 * 1024;\n    private final static Charset UTF8 = Charset.forName(\"UTF-8\");\n    private final static Charset LATIN1 = Charset.forName(\"ISO-8859-1\");\n<fim_suffix>    private static final class Block {\n        private byte[] bytes = new byte[0];\n        private long blockPosition;\n        boolean contains(long position) {\n            return position >= blockPosition && position < blockPosition + bytes.length;\n        }\n        public void read(RandomAccessFile file, int amount) throws IOException {\n            blockPosition = file.getFilePointer();\n            // reuse byte array, if possible\n            if (amount != bytes.length) {\n                bytes = new byte[amount];\n            }\n            file.readFully(bytes);\n        }\n        public byte get(long position) {\n            return bytes[(int) (position - blockPosition)];\n        }\n    }\n    private final RandomAccessFile file;\n    private final long size;\n    private Block currentBlock = new Block();\n    private Block previousBlock = new Block();\n    private long position;\n    private final int blockSize;\n    private RecordingInput(File f, int blockSize) throws IOException {\n        this.size = f.length();\n        this.blockSize = blockSize;\n        this.file = new RandomAccessFile(f, \"r\");\n        if (size < 8) {\n            throw new IOException(\"Not a valid Flight Recorder file. File length is only \" + size + \" bytes.\");\n        }\n    }\n    public RecordingInput(File f) throws IOException {\n        this(f, DEFAULT_BLOCK_SIZE);\n    }\n    @Override\n    public final byte readByte() throws IOException {\n        if (!currentBlock.contains(position)) {\n            position(position);\n        }\n        return currentBlock.get(position++);\n    }\n    @Override\n    public final void readFully(byte[] dest, int offset, int length) throws IOException {\n        // TODO: Optimize, use Arrays.copy if all bytes are in current block\n        // array\n        for (int i = 0; i < length; i++) {\n            dest[i + offset] = readByte();\n        }\n    }\n    @Override\n    public final void readFully(byte[] dst) throws IOException {\n        readFully(dst, 0, dst.length);\n    }\n    public final short readRawShort() throws IOException {\n        // copied from java.io.Bits\n        byte b0 = readByte();\n        byte b1 = readByte();\n        return (short) ((b1 & 0xFF) + (b0 << 8));\n    }\n    @Override\n    public final double readDouble() throws IOException {\n        // copied from java.io.Bits\n        return Double.longBitsToDouble(readRawLong());\n    }\n    @Override\n    public final float readFloat() throws IOException {\n        // copied from java.io.Bits\n        return Float.intBitsToFloat(readRawInt());\n    }\n    public final int readRawInt() throws IOException {\n        // copied from java.io.Bits\n        byte b0 = readByte();\n        byte b1 = readByte();\n        byte b2 = readByte();\n        byte b3 = readByte();\n        return ((b3 & 0xFF)) + ((b2 & 0xFF) << 8) + ((b1 & 0xFF) << 16) + ((b0) << 24);\n    }\n    public final long readRawLong() throws IOException {\n        // copied from java.io.Bits\n        byte b0 = readByte();\n        byte b1 = readByte();\n        byte b2 = readByte();\n        byte b3 = readByte();\n        byte b4 = readByte();\n        byte b5 = readByte();\n        byte b6 = readByte();\n        byte b7 = readByte();\n        return ((b7 & 0xFFL)) + ((b6 & 0xFFL) << 8) + ((b5 & 0xFFL) << 16) + ((b4 & 0xFFL) << 24) + ((b3 & 0xFFL) << 32) + ((b2 & 0xFFL) << 40) + ((b1 & 0xFFL) << 48) + (((long) b0) << 56);\n    }\n    public final long position() throws IOException {\n        return position;\n    }\n    public final void position(long newPosition) throws IOException {\n        if (!currentBlock.contains(newPosition)) {\n            if (!previousBlock.contains(newPosition)) {\n                if (newPosition > size()) {\n                    throw new EOFException(\"Trying to read at \" + newPosition + \", but file is only \" + size() + \" bytes.\");\n                }\n                long blockStart = trimToFileSize(calculateBlockStart(newPosition));\n                file.seek(blockStart);\n                // trim amount to file size\n                long amount = Math.min(size() - blockStart, blockSize);\n                previousBlock.read(file, (int) amount);\n            }\n            // swap previous and current\n            Block tmp = currentBlock;\n            currentBlock = previousBlock;\n            previousBlock = tmp;\n        }\n        position = newPosition;\n    }\n    private final long trimToFileSize(long position) throws IOException {\n        return Math.min(size(), Math.max(0, position));\n    }\n    private final long calculateBlockStart(long newPosition) {\n        // align to end of current block\n        if (currentBlock.contains(newPosition - blockSize)) {\n            return currentBlock.blockPosition + currentBlock.bytes.length;\n        }\n        // align before current block\n        if (currentBlock.contains(newPosition + blockSize)) {\n            return currentBlock.blockPosition - blockSize;\n        }\n        // not near current block, pick middle\n        return newPosition - blockSize / 2;\n    }\n    public final long size() throws IOException {\n        return size;\n    }\n    public final void close() throws IOException {\n        file.close();\n    }\n    @Override\n    public final int skipBytes(int n) throws IOException {\n        long position = position();\n        position(position + n);\n        return (int) (position() - position);\n    }\n    @Override\n    public final boolean readBoolean() throws IOException {\n        return readByte() != 0;\n    }\n    @Override\n    public int readUnsignedByte() throws IOException {\n        return readByte() & 0x00FF;\n    }\n    @Override\n    public int readUnsignedShort() throws IOException {\n        return readShort() & 0xFFFF;\n    }\n    @Override\n    public final String readLine() throws IOException {\n        throw new UnsupportedOperationException();\n    }\n    // NOTE, this method should really be called readString\n    // but can't be renamed without making RecordingInput a\n    // public class.\n    //\n    // This method DOES Not read as expected (s2 + utf8 encoded character)\n    // instead it read:\n    // byte encoding\n    // int size\n    // data (byte or char)\n    //\n    // where encoding\n    //\n    // 0, means null\n    // 1, means UTF8 encoded byte array\n    // 2, means char array<fim_middle>// class below has no smell\n"}