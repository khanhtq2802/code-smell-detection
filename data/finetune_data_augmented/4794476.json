{"text": "<fim_prefix> *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.shardingsphere.shardingjdbc.jdbc.core.statement;\nimport lombok.RequiredArgsConstructor;\nimport lombok.SneakyThrows;\nimport org.apache.shardingsphere.core.optimize.OptimizeEngineFactory;\nimport org.apache.shardingsphere.core.optimize.result.OptimizeResult;\nimport org.apache.shardingsphere.core.parse.parser.sql.SQLStatement;\nimport org.apache.shardingsphere.core.rewrite.EncryptSQLRewriteEngine;\nimport org.apache.shardingsphere.core.rewrite.SQLBuilder;\nimport org.apache.shardingsphere.core.route.SQLUnit;\nimport org.apache.shardingsphere.shardingjdbc.jdbc.adapter.AbstractShardingPreparedStatementAdapter;\nimport org.apache.shardingsphere.shardingjdbc.jdbc.core.connection.EncryptConnection;\nimport org.apache.shardingsphere.shardingjdbc.jdbc.core.resultset.EncryptResultSet;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.Collection;\nimport java.util.LinkedList;\n/**\n * Encrypt prepared statement.\n *\n * @author panjuan\n */\npublic final class EncryptPreparedStatement extends AbstractShardingPreparedStatementAdapter {\n    private final String sql;\n    private final EncryptPreparedStatementGenerator preparedStatementGenerator;\n    private final Collection<SQLUnit> sqlUnits = new LinkedList<>();\n    private PreparedStatement preparedStatement;\n    private EncryptResultSet resultSet;\n    @SneakyThrows\n    public EncryptPreparedStatement(final EncryptConnection connection, final String sql) {\n        this.sql = sql;\n        preparedStatementGenerator = new EncryptPreparedStatementGenerator(connection);\n    }\n    @SneakyThrows\n    public EncryptPreparedStatement(final EncryptConnection connection, final String sql, final int resultSetType, final int resultSetConcurrency) {\n        this.sql = sql;\n        preparedStatementGenerator = new EncryptPreparedStatementGenerator(connection, resultSetType, resultSetConcurrency);\n    }\n    @SneakyThrows\n    public EncryptPreparedStatement(final EncryptConnection connection, final String sql, final int resultSetType, final int resultSetConcurrency, final int resultSetHoldability) {\n        this.sql = sql;\n        preparedStatementGenerator = new EncryptPreparedStatementGenerator(connection, resultSetType, resultSetConcurrency, resultSetHoldability);\n    }\n    @SneakyThrows\n    public EncryptPreparedStatement(final EncryptConnection connection, final String sql, final int autoGeneratedKeys) {\n        this.sql = sql;\n        preparedStatementGenerator = new EncryptPreparedStatementGenerator(connection, autoGeneratedKeys);\n    }\n    @SneakyThrows\n    public EncryptPreparedStatement(final EncryptConnection connection, final String sql, final int[] columnIndexes) {\n        this.sql = sql;\n        preparedStatementGenerator = new EncryptPreparedStatementGenerator(connection, columnIndexes);\n    }\n    @SneakyThrows\n    public EncryptPreparedStatement(final EncryptConnection connection, final String sql, final String[] columnNames) {\n        this.sql = sql;\n        preparedStatementGenerator = new EncryptPreparedStatementGenerator(connection, columnNames);\n    }\n    @Override\n    public ResultSet executeQuery() throws SQLException {\n        try {\n            SQLUnit sqlUnit = getSQLUnit(sql);\n            preparedStatement = preparedStatementGenerator.createPreparedStatement(sqlUnit.getSql());\n            replaySetParameter(preparedStatement, sqlUnit.getParameters());\n            this.resultSet = new EncryptResultSet(this, preparedStatement.executeQuery(), preparedStatementGenerator.connection.getEncryptRule());\n            return resultSet;\n        } finally {\n            clearParameters();\n        }\n    }\n    @Override\n    public ResultSet getResultSet() {\n        return resultSet;\n    }\n    @Override\n    public int executeUpdate() throws SQLException {\n        try {\n            SQLUnit sqlUnit = getSQLUnit(sql);\n            preparedStatement = preparedStatementGenerator.createPreparedStatement(sqlUnit.getSql());\n            replaySetParameter(preparedStatement, sqlUnit.getParameters());\n            return preparedStatement.executeUpdate();\n        } finally {\n            clearParameters();\n        }\n    }\n    @Override\n    public boolean execute() throws SQLException {\n        try {\n            SQLUnit sqlUnit = getSQLUnit(sql);\n            preparedStatement = preparedStatementGenerator.createPreparedStatement(sqlUnit.getSql());\n            replaySetParameter(preparedStatement, sqlUnit.getParameters());\n            boolean result = preparedStatement.execute();\n            this.resultSet = createEncryptResultSet(preparedStatement);\n            return result;\n        } finally {\n            clearParameters();\n        }\n    }\n    private EncryptResultSet createEncryptResultSet(final PreparedStatement preparedStatement) throws SQLException {\n        return null == preparedStatement.getResultSet() ? null : new EncryptResultSet(this, preparedStatement.getResultSet(), preparedStatementGenerator.connection.getEncryptRule());\n    }\n    @Override\n    public void addBatch() {\n        sqlUnits.add(getSQLUnit(sql));\n        clearParameters();\n    }\n    private SQLUnit getSQLUnit(final String sql) {\n        EncryptConnection connection = preparedStatementGenerator.connection;\n        SQLStatement sqlStatement = connection.getEncryptSQLParsingEngine().parse(false, sql);\n        OptimizeResult optimizeResult = OptimizeEngineFactory.newInstance(connection.getEncryptRule(), sqlStatement, getParameters()).optimize();\n        SQLBuilder sqlBuilder = new EncryptSQLRewriteEngine(connection.getEncryptRule(), sql, connection.getDatabaseType(), sqlStatement, getParameters(), optimizeResult).rewrite();\n        return sqlBuilder.toSQL();\n    }\n    @Override\n    public int[] executeBatch() throws SQLException {\n        try {\n            preparedStatement = preparedStatementGenerator.createPreparedStatement(sqlUnits.iterator().next().getSql());\n            replayBatchPreparedStatement();\n            return preparedStatement.executeBatch();\n        } finally {\n            clearBatch();\n        }\n    }\n    private void replayBatchPreparedStatement() throws SQLException {\n        for (SQLUnit each : sqlUnits) {\n            replaySetParameter(preparedStatement, each.getParameters());\n            preparedStatement.addBatch();\n        }\n    }\n    @Override\n    public void clearBatch() throws SQLException {\n        preparedStatement.clearBatch();\n        sqlUnits.clear();\n        clearParameters();\n    }\n    @Override\n    public ResultSet getGeneratedKeys() throws SQLException {\n        return preparedStatement.getGeneratedKeys();\n    }\n    @Override\n    public Connection getConnection() {\n        return preparedStatementGenerator.connection;\n    }\n    @Override\n    public int getResultSetConcurrency() {\n        return preparedStatementGenerator.resultSetConcurrency;\n    }\n    @Override\n    public int getResultSetType() {\n        return preparedStatementGenerator.resultSetType;\n    }\n    @Override\n    public int getResultSetHoldability() {\n        return preparedStatementGenerator.resultSetHoldability;\n    }\n    @Override\n    protected boolean isAccumulate() {\n        return false;\n    }\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    protected Collection<? extends Statement> getRoutedStatements() {\n        Collection<Statement> result = new LinkedList();\n        result.add(preparedStatement);\n        return result;\n    }\n<fim_suffix>    @RequiredArgsConstructor\n    private final class EncryptPreparedStatementGenerator {\n        private final EncryptConnection connection;\n        private final int resultSetType;\n        private final int resultSetConcurrency;\n        private final int resultSetHoldability;\n        private final int autoGeneratedKeys;\n        private final int[] columnIndexes;\n        private final String[] columnNames;\n        private EncryptPreparedStatementGenerator(final EncryptConnection connection) {\n            this(connection, -1, -1, -1, -1, null, null);\n        }\n        private EncryptPreparedStatementGenerator(final EncryptConnection connection, final int resultSetType, final int resultSetConcurrency) {\n            this(connection, resultSetType, resultSetConcurrency, -1, -1, null, null);\n        }\n        private EncryptPreparedStatementGenerator(final EncryptConnection connection, final int resultSetType, final int resultSetConcurrency, final int resultSetHoldability) {\n            this(connection, resultSetType, resultSetConcurrency, resultSetHoldability, -1, null, null);\n        }\n        private EncryptPreparedStatementGenerator(final EncryptConnection connection, final int autoGeneratedKeys) {\n            this(connection, -1, -1, -1, autoGeneratedKeys, null, null);\n        }\n        private EncryptPreparedStatementGenerator(final EncryptConnection connection, final int[] columnIndexes) {\n            this(connection, -1, -1, -1, -1, columnIndexes, null);\n        }\n        private EncryptPreparedStatementGenerator(final EncryptConnection connection, final String[] columnNames) {\n            this(connection, -1, -1, -1, -1, null, columnNames);\n        }\n        private PreparedStatement createPreparedStatement(final String sql) throws SQLException {\n            if (-1 != resultSetType && -1 != resultSetConcurrency && -1 != resultSetHoldability) {\n                return connection.getConnection().prepareStatement(sql, resultSetType, resultSetConcurrency, resultSetHoldability);\n            }\n            if (-1 != resultSetType && -1 != resultSetConcurrency) {\n                return connection.getConnection().prepareStatement(sql, resultSetType, resultSetConcurrency);\n            }\n            if (-1 != autoGeneratedKeys) {\n                return connection.getConnection().prepareStatement(sql, autoGeneratedKeys);\n            }\n            if (null != columnIndexes) {\n                return connection.getConnection().prepareStatement(sql, columnIndexes);\n            }\n            if (null != columnNames) {\n                return connection.getConnection().prepareStatement(sql, columnNames);\n            }\n            return connection.getConnection().prepareStatement(sql);\n        }\n    }<fim_middle>// class below has no smell\n"}