{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.openejb.loader;\nimport org.apache.openejb.loader.event.ComponentAdded;\nimport org.apache.openejb.loader.event.ComponentRemoved;\nimport org.apache.openejb.loader.provisining.ProvisioningResolver;\nimport org.apache.openejb.observer.ObserverManager;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.concurrent.atomic.AtomicReference;\n/**\n * This class aims to be the one and only static in the entire SYSTEM\n A static, singleton, instance of this class can be created with the {@link #init(Properties)} method\n * <p/>\n * It is assumed that only one singleton per classloader is possible in any given VM\n * Thus loading this instance in a classloader will mean there can only be one OpenEJB\n * instance for that classloader and all children classloaders.\n *\n * @version $Revision$ $Date$\n * @org.apache.xbean.XBean element=\"system\"\n */\npublic final class SystemInstance {\n    private static final String PROFILE_PROP = \"openejb.profile\";\n    private static final String DEFAULT_PROFILE = \"development\";\n    private final long startTime = System.currentTimeMillis();\n    /**\n     * Properties that have to be away from System (i.e. {@link System#setProperty(String, String)} must not be called)\n     */\n    private final Properties internalProperties = new Properties(System.getProperties());\n    private final Options options;\n    private final FileUtils home;\n    private final FileUtils base;\n    private final ClassLoader classLoader;\n    private final Map<Class, Object> components;\n    private final ClassPath classPath;\n    private final ObserverManager observerManager = new ObserverManager();\n    private SystemInstance(final Properties properties) {\n        this.components = new HashMap<>();\n        // import JVM SYSTEM property config (if a resource/container/... is set through this way)\n        for (final String key : System.getProperties().stringPropertyNames()) {\n            if (key.startsWith(\"sun.\")) {\n                continue;\n            }\n            if (key.startsWith(\"os.\")) {\n                continue;\n            }\n            if (key.startsWith(\"user.\")) {\n                continue;\n            }\n            if (key.startsWith(\"awt.\")) {\n                continue;\n            }\n            if (key.startsWith(\"java.\")) {\n                final String pkg = key.substring(\"java.\".length());\n                if (pkg.startsWith(\"vm.\")) {\n                    continue;\n                }\n                if (pkg.startsWith(\"runtime.\")) {\n                    continue;\n                }\n                if (pkg.startsWith(\"awt.\")) {\n                    continue;\n                }\n                if (pkg.startsWith(\"specification.\")) {\n                    continue;\n                }\n                if (pkg.startsWith(\"class.\")) {\n                    continue;\n                }\n                if (pkg.startsWith(\"library.\")) {\n                    continue;\n                }\n                if (pkg.startsWith(\"ext.\")) {\n                    continue;\n                }\n                if (pkg.startsWith(\"vendor.\")) {\n                    continue;\n                }\n                if (pkg.startsWith(\"endorsed.\")) {\n                    continue;\n                }\n            }\n            final String value = System.getProperty(key);\n            if (value != null) {\n                this.internalProperties.put(key, value);\n            }\n        }\n        this.internalProperties.putAll(properties);\n        this.options = new Options(internalProperties, new Options(System.getProperties()));\n        this.home = new FileUtils(\"openejb.home\", \"user.dir\", this.internalProperties);\n        this.base = new FileUtils(\"openejb.base\", \"openejb.home\", this.internalProperties);\n        this.classPath = ClassPathFactory.createClassPath(this.internalProperties.getProperty(\"openejb.loader\", \"context\"));\n        this.classLoader = classPath.getClassLoader();\n        final String homeDirCanonicalPath;\n        final String baseDirCanonicalPath;\n        try {\n            homeDirCanonicalPath = home.getDirectory().getCanonicalPath();\n            baseDirCanonicalPath = base.getDirectory().getCanonicalPath();\n        } catch (final IOException e) {\n            throw new LoaderRuntimeException(\"Failed to create default instance of SystemInstance\", e);\n        }\n        this.internalProperties.setProperty(\"openejb.home\", homeDirCanonicalPath);\n        this.internalProperties.setProperty(\"openejb.base\", baseDirCanonicalPath);\n        System.setProperty(\"derby.system.home\", System.getProperty(\"derby.system.home\", baseDirCanonicalPath));\n    }\n    public <E> E fireEvent(final E event) {\n        return observerManager.fireEvent(event);\n    }\n    public boolean addObserver(final Object observer) {\n        return observerManager.addObserver(observer);\n    }\n    public boolean removeObserver(final Object observer) {\n        return observerManager.removeObserver(observer);\n    }\n    @SuppressWarnings(\"unused\")\n    public long getStartTime() {\n        return startTime;\n    }\n    public Options getOptions() {\n        return options;\n    }\n    public Properties getProperties() {\n        return internalProperties;\n    }\n    public String getProperty(final String key) {\n        return internalProperties.getProperty(key);\n    }\n    public String getProperty(final String key, final String defaultValue) {\n        return internalProperties.getProperty(key, defaultValue);\n    }\n    public Object setProperty(final String key, final String value) {\n        return setProperty(key, value, false);\n    }\n    /**\n     * @param key                property name\n     * @param value              property value\n     * @param isExternalProperty should the property be set to System by {@link System#setProperty(String, String)}\n     * @return property value\n     */\n<fim_suffix>    public Object setProperty(final String key, final String value, final boolean isExternalProperty) {\n        if (isExternalProperty) {\n            System.setProperty(key, value);\n        }\n        return internalProperties.setProperty(key, value);\n    }\n    public FileUtils getHome() {\n        if (!isInitialized()) {\n            return new FileUtils(\"openejb.home\", \"user.dir\", System.getProperties());\n        }\n        return home;\n    }\n    public FileUtils getBase() {\n        if (!isInitialized()) {\n            return new FileUtils(\"openejb.base\", \"openejb.home\", System.getProperties());\n        }\n        return base;\n    }\n    public ClassPath getClassPath() {\n        return classPath;\n    }\n    public ClassLoader getClassLoader() {\n        return classLoader;\n    }\n    /**\n     * I'm not sure how this will play out, but I've used class instances instead of strings\n     * for lookups as class instances are classloader scoped and there is an implicit \"namespace\"\n     * associated with that.  Theoretically, you can't lookup things that you can't already see\n     * in your classloader.\n     *\n     * @param type Class\n     * @return the object associated with the class type or null\n     * @throws IllegalStateException of the component isn't found\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T getComponent(final Class<T> type) {\n        final T component = (T) components.get(type);\n        if (component != null) {\n            return component;\n        }\n        final String classname = getProperty(type.getName());\n        if (classname != null) {\n            try {\n                final T instance = type.cast(Thread.currentThread().getContextClassLoader()\n                    .loadClass(classname).newInstance());\n                components.put(type, instance);\n                return instance;\n            } catch (final Throwable e) {\n                // no-op\n                System.err.println(\"Failed to load class: \" + classname);\n            }\n        }\n        return null;\n    }\n    @SuppressWarnings(\"unchecked\")\n    public <T> T removeComponent(final Class<T> type) {\n        final T component = (T) components.remove(type);\n        if (component != null) {\n            fireEvent(new ComponentRemoved(type, component));\n        }\n        return component;\n    }\n    /**\n     * @param type the class type of the component required\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T> T setComponent(final Class<T> type, final T value) {\n        final T removed = (T) components.put(type, value);\n        if (removed != null) {\n            fireEvent(new ComponentRemoved(type, value));\n        }\n        if (value != null) {\n            fireEvent(new ComponentAdded(type, value));\n        }\n        return removed;\n    }\n    private static final AtomicReference<SystemInstance> SYSTEM = new AtomicReference<>();\n    static {\n        reset();\n    }<fim_middle>// function below has no smell\n"}