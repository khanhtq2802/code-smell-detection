{"text": "<fim_prefix>\n<fim_suffix>public class JAXRSOutInterceptor extends AbstractOutDatabindingInterceptor {\n    private static final Logger LOG = LogUtils.getL7dLogger(JAXRSOutInterceptor.class);\n    private static final ResourceBundle BUNDLE = BundleUtils.getBundle(JAXRSOutInterceptor.class);\n    public JAXRSOutInterceptor() {\n        super(Phase.MARSHAL);\n    }\n    public void handleMessage(Message message) {\n        ServerProviderFactory providerFactory = ServerProviderFactory.getInstance(message);\n        try {\n            processResponse(providerFactory, message);\n        } finally {\n            ServerProviderFactory.releaseRequestState(providerFactory, message);\n        }\n    }\n    @SuppressWarnings(\"resource\") // Response shouldn't be closed here\n    private void processResponse(ServerProviderFactory providerFactory, Message message) {\n        if (isResponseAlreadyHandled(message)) {\n            return;\n        }\n        MessageContentsList objs = MessageContentsList.getContentsList(message);\n        if (objs == null || objs.isEmpty()) {\n            return;\n        }\n        Object responseObj = objs.get(0);\n        Response response = null;\n        if (responseObj instanceof Response) {\n            response = (Response)responseObj;\n            if (response.getStatus() == 500\n                && message.getExchange().get(JAXRSUtils.EXCEPTION_FROM_MAPPER) != null) {\n                message.put(Message.RESPONSE_CODE, 500);\n                return;\n            }\n        } else {\n            int status = getStatus(message, responseObj != null ? 200 : 204);\n            response = JAXRSUtils.toResponseBuilder(status).entity(responseObj).build();\n        }\n        Exchange exchange = message.getExchange();\n        OperationResourceInfo ori = (OperationResourceInfo)exchange.get(OperationResourceInfo.class\n            .getName());\n        serializeMessage(providerFactory, message, response, ori, true);\n    }\n    private int getStatus(Message message, int defaultValue) {\n        Object customStatus = message.getExchange().get(Message.RESPONSE_CODE);\n        return customStatus == null ? defaultValue : (Integer)customStatus;\n    }\n    private void serializeMessage(ServerProviderFactory providerFactory,\n                                  Message message,\n                                  Response theResponse,\n                                  OperationResourceInfo ori,\n                                  boolean firstTry) {\n        ResponseImpl response = (ResponseImpl)JAXRSUtils.copyResponseIfNeeded(theResponse);\n        final Exchange exchange = message.getExchange();\n        boolean headResponse = response.getStatus() == 200 && firstTry\n            && ori != null && HttpMethod.HEAD.equals(ori.getHttpMethod());\n        Object entity = response.getActualEntity();\n        if (headResponse && entity != null) {\n            LOG.info(new org.apache.cxf.common.i18n.Message(\"HEAD_WITHOUT_ENTITY\", BUNDLE).toString());\n            entity = null;\n        }\n        Method invoked = ori == null ? null : ori.getAnnotatedMethod() != null\n            ? ori.getAnnotatedMethod() : ori.getMethodToInvoke();\n        Annotation[] annotations = null;\n        Annotation[] staticAnns = ori != null ? ori.getOutAnnotations() : new Annotation[]{};\n        Annotation[] responseAnns = response.getEntityAnnotations();\n        if (responseAnns != null) {\n            annotations = new Annotation[staticAnns.length + responseAnns.length];\n            System.arraycopy(staticAnns, 0, annotations, 0, staticAnns.length);\n            System.arraycopy(responseAnns, 0, annotations, staticAnns.length, responseAnns.length);\n        } else {\n            annotations = staticAnns;\n        }\n        response.setStatus(getActualStatus(response.getStatus(), entity));\n        response.setEntity(entity, annotations);\n        // Prepare the headers\n        MultivaluedMap<String, Object> responseHeaders =\n            prepareResponseHeaders(message, response, entity, firstTry);\n        // Run the filters\n        try {\n            JAXRSUtils.runContainerResponseFilters(providerFactory, response, message, ori, invoked);\n        } catch (Throwable ex) {\n            handleWriteException(providerFactory, message, ex, firstTry);\n            return;\n        }\n        // Write the entity\n        entity = InjectionUtils.getEntity(response.getActualEntity());\n        setResponseStatus(message, getActualStatus(response.getStatus(), entity));\n        if (entity == null) {\n            if (!headResponse) {\n                responseHeaders.putSingle(HttpHeaders.CONTENT_LENGTH, \"0\");\n                if (MessageUtils.getContextualBoolean(message, \"remove.content.type.for.empty.response\", false)) {\n                    responseHeaders.remove(HttpHeaders.CONTENT_TYPE);\n                    message.remove(Message.CONTENT_TYPE);\n                }\n            }\n            HttpUtils.convertHeaderValuesToString(responseHeaders, true);\n            return;\n        }\n        Object ignoreWritersProp = exchange.get(JAXRSUtils.IGNORE_MESSAGE_WRITERS);\n        boolean ignoreWriters =\n            ignoreWritersProp != null && Boolean.valueOf(ignoreWritersProp.toString());\n        if (ignoreWriters) {\n            writeResponseToStream(message.getContent(OutputStream.class), entity);\n            return;\n        }\n        MediaType responseMediaType =\n            getResponseMediaType(responseHeaders.getFirst(HttpHeaders.CONTENT_TYPE));\n        Class<?> serviceCls = invoked != null ? ori.getClassResourceInfo().getServiceClass() : null;\n        Class<?> targetType = InjectionUtils.getRawResponseClass(entity);\n        Type genericType = InjectionUtils.getGenericResponseType(invoked, serviceCls,\n                                                                 response.getActualEntity(), targetType, exchange);\n        targetType = InjectionUtils.updateParamClassToTypeIfNeeded(targetType, genericType);\n        annotations = response.getEntityAnnotations();\n        List<WriterInterceptor> writers = providerFactory\n            .createMessageBodyWriterInterceptor(targetType, genericType, annotations, responseMediaType, message,\n                                                ori == null ? null : ori.getNameBindings());\n        OutputStream outOriginal = message.getContent(OutputStream.class);\n        if (writers == null || writers.isEmpty()) {\n            writeResponseErrorMessage(message, outOriginal, \"NO_MSG_WRITER\", targetType, responseMediaType);\n            return;\n        }\n        try {\n            boolean checkWriters = false;\n            if (responseMediaType.isWildcardSubtype()) {\n                Produces pM = AnnotationUtils.getMethodAnnotation(ori == null ? null : ori.getAnnotatedMethod(),\n                                                                              Produces.class);\n                Produces pC = AnnotationUtils.getClassAnnotation(serviceCls, Produces.class);\n                checkWriters = pM == null && pC == null;\n            }\n            responseMediaType = checkFinalContentType(responseMediaType, writers, checkWriters);\n        } catch (Throwable ex) {\n            handleWriteException(providerFactory, message, ex, firstTry);\n            return;\n        }\n        String finalResponseContentType = JAXRSUtils.mediaTypeToString(responseMediaType);\n        if (LOG.isLoggable(Level.FINE)) {\n            LOG.fine(\"Response content type is: \" + finalResponseContentType);\n        }\n        responseHeaders.putSingle(HttpHeaders.CONTENT_TYPE, finalResponseContentType);\n        message.put(Message.CONTENT_TYPE, finalResponseContentType);\n        boolean enabled = checkBufferingMode(message, writers, firstTry);\n        try {\n            try {\n                JAXRSUtils.writeMessageBody(writers,\n                        entity,\n                        targetType,\n                        genericType,\n                        annotations,\n                        responseMediaType,\n                        responseHeaders,\n                        message);\n                if (isResponseRedirected(message)) {\n                    return;\n                }\n                checkCachedStream(message, outOriginal, enabled);\n            } finally {\n                if (enabled) {\n                    OutputStream os = message.getContent(OutputStream.class);\n                    if (os != outOriginal && os instanceof CachedOutputStream) {\n                        os.close();\n                    }\n                    message.setContent(OutputStream.class, outOriginal);\n                    message.put(XMLStreamWriter.class.getName(), null);\n                }\n            }\n        } catch (Throwable ex) {\n            logWriteError(firstTry, targetType, responseMediaType);\n            handleWriteException(providerFactory, message, ex, firstTry);\n        }\n    }\n    private MultivaluedMap<String, Object> prepareResponseHeaders(Message message,\n                                                                  ResponseImpl response,\n                                                                  Object entity,\n                                                                  boolean firstTry) {\n        MultivaluedMap<String, Object> responseHeaders = response.getMetadata();\n        @SuppressWarnings(\"unchecked\")\n        Map<String, List<Object>> userHeaders = (Map<String, List<Object>>)message.get(Message.PROTOCOL_HEADERS);\n        if (firstTry && userHeaders != null) {\n            responseHeaders.putAll(userHeaders);\n        }\n        if (entity != null) {\n            Object customContentType = responseHeaders.getFirst(HttpHeaders.CONTENT_TYPE);\n            if (customContentType == null) {\n                String initialResponseContentType = (String)message.get(Message.CONTENT_TYPE);\n                if (initialResponseContentType != null) {\n                    responseHeaders.putSingle(HttpHeaders.CONTENT_TYPE, initialResponseContentType);\n                }\n            } else {\n                message.put(Message.CONTENT_TYPE, customContentType.toString());<fim_middle>// class below is blob\n"}