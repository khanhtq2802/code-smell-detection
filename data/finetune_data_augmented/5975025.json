{"text": "<fim_prefix>                            continue;\n                        }\n                        if (port.getHandlerChains() == null) {\n                            continue;\n                        }\n                        for (final org.apache.openejb.jee.HandlerChain handlerChain : port.getHandlerChains().getHandlerChain()) {\n                            for (final Handler handler : handlerChain.getHandler()) {\n                                final String handlerClass = realClassName(handler.getHandlerClass());\n                                if (handlerClass != null) {\n                                    classes.add(handlerClass);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            // classes.add(bean.getEjbClass());\n            final AnnotationFinder handlersFinder = finder.select(classes);\n            buildAnnotatedRefs(bean, handlersFinder, ejbModule.getClassLoader());\n        }\n        /**\n         * Scan for @EJB, @Resource, @WebServiceRef, @PersistenceUnit, and @PersistenceContext on WebService HandlerChain classes\n         *\n         * @param consumer\n         * @param classLoader\n         * @throws OpenEJBException\n         */\n        private void processWebServiceClientHandlers(final JndiConsumer consumer, final AnnotationFinder finder, final ClassLoader classLoader) throws OpenEJBException {\n            if (SystemInstance.get().hasProperty(\"openejb.geronimo\")) {\n                return;\n            }\n            final Set<String> processedClasses = new HashSet<>();\n            final Set<String> handlerClasses = new HashSet<>();\n            do {\n                // get unprocessed handler classes\n                handlerClasses.clear();\n                for (final ServiceRef serviceRef : consumer.getServiceRef()) {\n                    final HandlerChains chains = serviceRef.getAllHandlers();\n                    if (chains == null) {\n                        continue;\n                    }\n                    for (final org.apache.openejb.jee.HandlerChain handlerChain : chains.getHandlerChain()) {\n                        for (final Handler handler : handlerChain.getHandler()) {\n                            if (handler.getHandlerClass() != null) {\n                                handlerClasses.add(realClassName(handler.getHandlerClass()));\n                            }\n                        }\n                    }\n                }\n                handlerClasses.removeAll(processedClasses);\n                if (handlerClasses.isEmpty()) {\n                    continue;\n                }\n                // process handler classes\n                final AnnotationFinder handlerAnnotationFinder = finder != null ? finder.select(handlerClasses) :\n                        new FinderFactory.OpenEJBAnnotationFinder(new FinderFactory.DoLoadClassesArchive(classLoader, handlerClasses));\n                /*\n                 * @EJB\n                 * @Resource\n                 * @WebServiceRef\n                 * @PersistenceUnit\n                 * @PersistenceContext\n                 */\n                buildAnnotatedRefs(consumer, handlerAnnotationFinder, classLoader);\n                processedClasses.addAll(handlerClasses);\n            } while (!handlerClasses.isEmpty());\n        }\n        // ----------------------------------------------------------------------\n        //\n        //  Utility methods and classes\n        //\n        // ----------------------------------------------------------------------\n        private List<String> getDeclaredClassPermissions(final AssemblyDescriptor assemblyDescriptor, final String ejbName) {\n            final List<MethodPermission> permissions = assemblyDescriptor.getMethodPermission();\n            final List<String> classPermissions = new ArrayList<>();\n            for (final MethodPermission permission : permissions) {\n                for (final org.apache.openejb.jee.Method method : permission.getMethod()) {\n                    if (!method.getEjbName().equals(ejbName)) {\n                        continue;\n                    }\n                    if (!\"*\".equals(method.getMethodName())) {\n                        continue;\n                    }\n                    String className = method.getClassName();\n                    if (className == null) {\n                        className = \"*\";\n                    }\n                    classPermissions.add(className);\n                }\n            }\n            return classPermissions;\n        }\n        public interface AnnotationHandler<A extends Annotation> {\n            Class<A> getAnnotationClass();\n            Map<String, List<MethodAttribute>> getExistingDeclarations();\n            void addClassLevelDeclaration(A annotation, Class clazz);\n            void addMethodLevelDeclaration(A annotation, Method method);\n        }\n        public static class TransactionAttributeHandler implements AnnotationHandler<TransactionAttribute> {\n            private final AssemblyDescriptor assemblyDescriptor;\n            private final String ejbName;\n            public TransactionAttributeHandler(final AssemblyDescriptor assemblyDescriptor, final String ejbName) {\n                this.assemblyDescriptor = assemblyDescriptor;\n                this.ejbName = ejbName;\n            }\n            public Map<String, List<MethodAttribute>> getExistingDeclarations() {\n                return assemblyDescriptor.getMethodTransactionMap(ejbName);\n            }\n            public void addClassLevelDeclaration(final TransactionAttribute attribute, final Class type) {\n                final ContainerTransaction ctx = new ContainerTransaction(cast(attribute.value()), type.getName(), ejbName, \"*\");\n                assemblyDescriptor.getContainerTransaction().add(ctx);\n            }\n            public void addMethodLevelDeclaration(final TransactionAttribute attribute, final Method method) {\n                final ContainerTransaction ctx = new ContainerTransaction(cast(attribute.value()), ejbName, method);\n                assemblyDescriptor.getContainerTransaction().add(ctx);\n            }\n            public Class<TransactionAttribute> getAnnotationClass() {\n                return TransactionAttribute.class;\n            }\n            private TransAttribute cast(final TransactionAttributeType transactionAttributeType) {\n                return TransAttribute.valueOf(transactionAttributeType.toString());\n            }\n        }\n        private static class ConcurrentMethodHandler {\n            protected final AssemblyDescriptor assemblyDescriptor;\n            protected final SessionBean bean;\n            protected final Map<Object, ContainerConcurrency> methods;\n            public ConcurrentMethodHandler(final AssemblyDescriptor assemblyDescriptor,\n                                           final SessionBean bean,\n                                           final Map<Object, ContainerConcurrency> methods) {\n                this.assemblyDescriptor = assemblyDescriptor;\n                this.bean = bean;\n                this.methods = methods;\n            }\n            public Map<String, List<MethodAttribute>> getExistingDeclarations() {\n                final Map<String, List<MethodAttribute>> declarations = new HashMap<>();\n                final List<ConcurrentMethod> methods = bean.getConcurrentMethod();\n                for (final ConcurrentMethod method : methods) {\n                    List<MethodAttribute> list = declarations.computeIfAbsent(method.getMethod().getMethodName(), k -> new ArrayList<>());\n                    list.add(new MethodAttribute(null, bean.getEjbName(), method.getMethod()));\n                }\n                return declarations;\n            }\n            public ContainerConcurrency getContainerConcurrency(final Method method) {\n                ContainerConcurrency concurrency = methods.get(method);\n                if (concurrency == null) {\n                    concurrency = new ContainerConcurrency(null, bean.getEjbName(), method);\n                    methods.put(method, concurrency);\n                    assemblyDescriptor.getContainerConcurrency().add(concurrency);\n                }\n                return concurrency;\n            }\n            public ContainerConcurrency getContainerConcurrency(final Class clazz) {\n                ContainerConcurrency concurrency = methods.get(clazz);\n                if (concurrency == null) {\n                    concurrency = new ContainerConcurrency(null, clazz.getName(), bean.getEjbName(), \"*\");\n                    methods.put(clazz, concurrency);\n                    assemblyDescriptor.getContainerConcurrency().add(concurrency);\n                }\n                return concurrency;\n            }\n            protected Map<Object, ContainerConcurrency> getContainerConcurrency() {\n                return methods;\n            }\n        }\n<fim_suffix>        public static class LockHandler extends ConcurrentMethodHandler implements AnnotationHandler<Lock> {\n            public LockHandler(final AssemblyDescriptor assemblyDescriptor,\n                               final SessionBean bean) {\n                this(assemblyDescriptor, bean, new HashMap<Object, ContainerConcurrency>());\n            }\n            public LockHandler(final AssemblyDescriptor assemblyDescriptor,\n                               final SessionBean bean,\n                               final Map<Object, ContainerConcurrency> methods) {\n                super(assemblyDescriptor, bean, methods);\n            }\n            public void addClassLevelDeclaration(final Lock attribute, final Class type) {\n                final ContainerConcurrency concurrency = getContainerConcurrency(type);\n                concurrency.setLock(toLock(attribute));\n            }\n            public void addMethodLevelDeclaration(final Lock attribute, final Method method) {\n                final ContainerConcurrency concurrency = getContainerConcurrency(method);\n                concurrency.setLock(toLock(attribute));\n            }\n            private ConcurrentLockType toLock(final Lock annotation) {\n                if (LockType.READ.equals(annotation.value())) {\n                    return ConcurrentLockType.READ;\n                } else if (LockType.WRITE.equals(annotation.value())) {\n                    return ConcurrentLockType.WRITE;\n                } else {\n                    throw new IllegalArgumentException(\"Unknown lock annotation: \" + annotation.value());\n                }\n            }\n            public Class<Lock> getAnnotationClass() {\n                return Lock.class;\n            }\n        }<fim_middle>// class below has no smell\n"}