{"text": "<fim_prefix>/*\n * Copyright 2017 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.springframework.data.release.build;\n\nimport lombok.AccessLevel;\nimport lombok.NonNull;\nimport lombok.RequiredArgsConstructor;\nimport lombok.Value;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.function.BooleanSupplier;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport org.springframework.data.release.model.Masked;\nimport org.springframework.util.Assert;\n\n/**\n * Value object to represent a Maven command line.\n * \n * @author Oliver Gierke\n */\n@Value\nclass CommandLine {\n\n\t@NonNull List<Goal> goals;\n\t@NonNull List<Argument> arguments;\n\n\t/**\n\t * Creates a new {@link CommandLine} for the given {@link Goal} and {@link Argument}s.\n\t * \n\t * @param goal must not be {@literal null}.\n\t * @param argument must not be {@literal null}.\n\t * @return\n\t */\n\tpublic static CommandLine of(Goal goal, Argument... argument) {\n\t\treturn new CommandLine(Collections.singletonList(goal), Arrays.asList(argument));\n\t}\n\n\t/**\n\t * Creates a new {@link CommandLine} for the given {@link Goal}s and {@link Argument}s.\n\t * \n\t * @param goal must not be {@literal null}.\n\t * @param argument must not be {@literal null}.\n\t * @return\n\t */\n\tpublic static CommandLine of(Goal first, Goal second, Argument... argument) {\n\t\treturn new CommandLine(Arrays.asList(first, second), Arrays.asList(argument));\n\t}\n\n\t/**\n\t * Returns a new {@link CommandLine} with the given {@link Argument} added in case the given {@link BooleanSupplier}\n\t * evaluates to {@literal true}.\n\t * \n\t * @param argument must not be {@literal null}.\n\t * @param condition must not be {@literal null}.\n\t * @return\n\t */\n\tpublic CommandLine conditionalAnd(Argument argument, BooleanSupplier condition) {\n\t\treturn condition.getAsBoolean() ? and(argument) : this;\n\t}\n\n\t/**\n\t * Returns a new {@link CommandLine} with the given {@link Argument} added.\n\t * \n\t * @param argument must not be {@literal null}.\n\t * @return\n\t */\n\tpublic CommandLine and(Argument argument) {\n\n\t\tAssert.notNull(argument, \"Argument must not be null!\");\n\n\t\tList<Argument> newArguments = new ArrayList<Argument>(arguments.size() + 1);\n\t\tnewArguments.addAll(arguments);\n\t\tnewArguments.add(argument);\n\n\t\treturn new CommandLine(goals, newArguments);\n\t}\n\n\t/**\n\t * Renders the current {@link CommandLine} as a plain {@link List} of {@link String}s using the given {@link Function}\n\t * to expand the {@link Goal}s.\n\t * \n\t * @param goalExpansion must not be {@literal null}.\n\t * @return\n\t */\n\tpublic List<String> toCommandLine(Function<Goal, String> goalExpansion) {\n\n\t\tStream<String> goalStream = goals.stream().map(goalExpansion);\n\t\tStream<String> argumentStream = arguments.stream().map(it -> it.toCommandLineArgument());\n\n\t\treturn Stream.concat(goalStream, argumentStream).collect(Collectors.toList());\n\t}\n\n\t/* \n\t * (non-Javadoc)\n\t * @see java.lang.Object#toString()\n\t */\n\t@Override\n\tpublic String toString() {\n\n\t\tStream<String> goalStream = goals.stream().map(it -> it.getGoal());\n\t\tStream<String> argumentStream = arguments.stream().map(Object::toString);\n\n\t\treturn Stream.concat(goalStream, argumentStream).collect(Collectors.joining(\" \"));\n\t}\n\n\t/**\n\t * Represents a Maven goal to invoke. Can be a custom one but also one of the predefined instances.\n\t *\n\t * @author Oliver Gierke\n\t */\n\t@Value(staticConstructor = \"goal\")\n\tpublic static class Goal {\n\n\t\tpublic static final Goal CLEAN = Goal.goal(\"clean\");\n\t\tpublic static final Goal INSTALL = Goal.goal(\"install\");\n\t\tpublic static final Goal DEPLOY = Goal.goal(\"deploy\");\n\t\tpublic static final Goal VALIDATE = Goal.goal(\"validate\");\n\n\t\tString goal;\n\t}\n\n\t@Value\n\t@RequiredArgsConstructor(access = AccessLevel.PRIVATE)\n\tpublic static class Argument {\n\n\t\tpublic static Argument SKIP_TESTS = Argument.arg(\"skipTests\");\n\n\t\t@NonNull String name;\n\t\t@NonNull Optional<ArgumentValue<?>> value;\n\n\t\tprivate Argument(String name, ArgumentValue<?> value) {\n\t\t\tthis(name, Optional.of(value));\n\t\t}\n\n\t\tstatic Argument of(String name) {\n\t\t\treturn new Argument(name, Optional.empty());\n\t\t}\n\n\t\t/**\n\t\t * Enables the given comma-separated profiles for the {@link CommandLine}.\n\t\t * \n\t\t * @param name must not be {@literal null} or empty.\n\t\t * @return\n\t\t */\n\t\tpublic static Argument profile(String name, String... others) {\n\n\t\t\tAssert.hasText(name, \"Profiles must not be null or empty!\");\n\t\t\tAssert.notNull(others, \"Other profiles must not be null!\");\n\n\t\t\tString profiles = Stream.concat(Stream.of(name), Arrays.stream(others)).collect(Collectors.joining(\",\"));\n\n\t\t\treturn Argument.of(\"-P\".concat(profiles));\n\t\t}\n\n\t\tpublic static Argument arg(String name) {\n\t\t\treturn Argument.of(\"-D\".concat(name));\n\t\t}\n\n\t\tpublic static Argument debug() {\n\t\t\treturn Argument.of(\"-X\");\n\t\t}\n\n\t\tpublic Argument withValue(Object value) {\n\t\t\treturn new Argument(name, ArgumentValue.of(value));\n\t\t}\n\n\t\tpublic Argument withQuotedValue(Object value) {\n\t\t\treturn new Argument(name, ArgumentValue.of(value, it -> String.format(\"\\\"%s\\\"\", it.toString())));\n\t\t}\n\n\t\tpublic Argument withValue(Masked masked) {\n\t\t\treturn new Argument(name, ArgumentValue.of(masked));\n\t\t}\n\n\t\tpublic String toCommandLineArgument() {\n\t\t\treturn toNameValuePair(value.map(ArgumentValue::toCommandLine));\n\t\t}\n\n\t\t/* \n\t\t * (non-Javadoc)\n\t\t * @see java.lang.Object#toString()\n\t\t */\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn toNameValuePair(value.map(Object::toString));\n\t\t}\n\n\t\tprivate String toNameValuePair(Optional<String> source) {\n\n\t\t\treturn source//\n\t\t\t\t\t.map(it -> String.format(\"%s=%s\", name, it))//\n\t\t\t\t\t.orElse(name);\n\t\t}\n\n\t\t@RequiredArgsConstructor(access = AccessLevel.PRIVATE)\n\t\tprivate static class ArgumentValue<T> {\n\n\t\t\tprivate final @NonNull T value;\n\t\t\tprivate final @NonNull Optional<Function<T, String>> preparer;\n\t\t\tprivate final @NonNull Optional<Function<T, String>> toString;\n\n\t\t\tpublic static <T> ArgumentValue<T> of(T value) {\n\t\t\t\treturn new ArgumentValue<>(value, Optional.empty(), Optional.empty());\n\t\t\t}\n\n\t\t\tpublic static <T> ArgumentValue<T> of(T value, Function<T, String> preparer) {\n\t\t\t\treturn new ArgumentValue<>(value, Optional.of(preparer), Optional.empty());\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Returns an {@link ArgumentValue} for the given {@link Masked} value.\n\t\t\t * \n\t\t\t * @param masked must not be {@literal null}.\n\t\t\t * @return\n\t\t\t */\n\t\t\tpublic static <T extends Masked> ArgumentValue<T> of(T masked) {\n\t\t\t\treturn new ArgumentValue<>(masked, Optional.empty(), Optional.of(it -> it.masked()));\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * Returns the {@link String} variant of the argument value.\n\t\t\t * \n\t\t\t * @return\n\t\t\t */\n<fim_suffix>\t\t\tpublic String toCommandLine() {\n\t\t\t\treturn preparer.map(it -> it.apply(value)).orElseGet(() -> value.toString());\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * (non-Javadoc)\n\t\t\t * @see java.lang.Object#toString()\n\t\t\t */\n\t\t\tpublic String toString() {\n\t\t\t\treturn toString.map(it -> it.apply(value)).orElseGet(() -> toCommandLine());\n\t\t\t}\n\t\t}\n\t}\n}<fim_middle>// function below has no smell\n"}