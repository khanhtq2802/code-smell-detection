{"text": "<fim_prefix>    options.put(Command.CompletionSet.TABLENAMES, modifiedTablenames);\n    options.put(Command.CompletionSet.NAMESPACES, modifiedNamespaces);\n    options.put(Command.CompletionSet.COMMANDS, commands);\n    for (Command[] cmdGroup : commandGrouping.values()) {\n      for (Command c : cmdGroup) {\n        c.getOptionsWithHelp(); // prep the options for the command\n        // so that the completion can\n        // include them\n        c.registerCompletion(rootToken, options);\n      }\n    }\n    return new ShellCompletor(rootToken, options);\n  }\n  /**\n   * The Command class represents a command to be run in the shell. It contains the methods to\n   * execute along with some methods to help tab completion, and return the command name, help, and\n   * usage.\n   */\n  public abstract static class Command {\n    // Helper methods for completion\n    public enum CompletionSet {\n      TABLENAMES, USERNAMES, COMMANDS, NAMESPACES\n    }\n    public void registerCompletionGeneral(Token root, Set<String> args, boolean caseSens) {\n      Token t = new Token(args);\n      t.setCaseSensitive(caseSens);\n      Token command = new Token(getName());\n      command.addSubcommand(t);\n      root.addSubcommand(command);\n    }\n    public void registerCompletionForTables(Token root,\n        Map<CompletionSet,Set<String>> completionSet) {\n      registerCompletionGeneral(root, completionSet.get(CompletionSet.TABLENAMES), true);\n    }\n    public void registerCompletionForUsers(Token root,\n        Map<CompletionSet,Set<String>> completionSet) {\n      registerCompletionGeneral(root, completionSet.get(CompletionSet.USERNAMES), true);\n    }\n    public void registerCompletionForCommands(Token root,\n        Map<CompletionSet,Set<String>> completionSet) {\n      registerCompletionGeneral(root, completionSet.get(CompletionSet.COMMANDS), false);\n    }\n    public void registerCompletionForNamespaces(Token root,\n        Map<CompletionSet,Set<String>> completionSet) {\n      registerCompletionGeneral(root, completionSet.get(CompletionSet.NAMESPACES), true);\n    }\n    // abstract methods to override\n    public abstract int execute(String fullCommand, CommandLine cl, Shell shellState)\n        throws Exception;\n    public abstract String description();\n    /**\n     * If the number of arguments is not always zero (not including those arguments handled through\n     * Options), make sure to override the {@link #usage()} method. Otherwise, {@link #usage()} does\n     * need to be overridden.\n     */\n    public abstract int numArgs();\n    // OPTIONAL methods to override:\n    // the general version of getName uses reflection to get the class name\n    // and then cuts off the suffix -Command to get the name of the command\n    public String getName() {\n      String s = this.getClass().getName();\n      int st = Math.max(s.lastIndexOf('$'), s.lastIndexOf('.'));\n      int i = s.indexOf(\"Command\");\n      return i > 0 ? s.substring(st + 1, i).toLowerCase(Locale.ENGLISH) : null;\n    }\n    // The general version of this method adds the name\n    // of the command to the completion tree\n    public void registerCompletion(Token root, Map<CompletionSet,Set<String>> completion_set) {\n      root.addSubcommand(new Token(getName()));\n    }\n    // The general version of this method uses the HelpFormatter\n    // that comes with the apache Options package to print out the help\n    public final void printHelp(Shell shellState) throws IOException {\n      shellState.printHelp(usage(), \"description: \" + this.description(), getOptionsWithHelp());\n    }\n    public final void printHelp(Shell shellState, int width) throws IOException {\n      shellState.printHelp(usage(), \"description: \" + this.description(), getOptionsWithHelp(),\n          width);\n    }\n    // Get options with help\n    public final Options getOptionsWithHelp() {\n      Options opts = getOptions();\n      opts.addOption(new Option(helpOption, helpLongOption, false, \"display this help\"));\n      return opts;\n    }\n    // General usage is just the command\n    public String usage() {\n      return getName();\n    }\n    // General Options are empty\n    public Options getOptions() {\n      return new Options();\n    }\n  }\n  public interface PrintLine extends AutoCloseable {\n    void print(String s);\n    @Override\n    void close();\n  }\n  public static class PrintShell implements PrintLine {\n    ConsoleReader reader;\n    public PrintShell(ConsoleReader reader) {\n      this.reader = reader;\n    }\n    @Override\n    public void print(String s) {\n      try {\n        reader.println(s);\n      } catch (Exception ex) {\n        throw new RuntimeException(ex);\n      }\n    }\n    @Override\n    public void close() {}\n  }\n  public static class PrintFile implements PrintLine {\n    PrintWriter writer;\n    @SuppressFBWarnings(value = \"PATH_TRAVERSAL_OUT\",\n        justification = \"app is run in same security context as user providing the filename\")\n    public PrintFile(String filename) throws FileNotFoundException {\n      writer = new PrintWriter(\n          new BufferedWriter(new OutputStreamWriter(new FileOutputStream(filename), UTF_8)));\n    }\n    @Override\n    public void print(String s) {\n      writer.println(s);\n    }\n    @Override\n    public void close() {\n      writer.close();\n    }\n  }\n  public final void printLines(Iterator<String> lines, boolean paginate) throws IOException {\n    printLines(lines, paginate, null);\n  }\n  public final void printLines(Iterator<String> lines, boolean paginate, PrintLine out)\n      throws IOException {\n    double linesPrinted = 0;\n    String prompt = \"-- hit any key to continue or 'q' to quit --\";\n    int lastPromptLength = prompt.length();\n    int termWidth = reader.getTerminal().getWidth();\n    int maxLines = reader.getTerminal().getHeight();\n    String peek = null;\n    while (lines.hasNext()) {\n      String nextLine = lines.next();\n      if (nextLine == null)\n        continue;\n      for (String line : nextLine.split(\"\\\\n\")) {\n        if (out == null) {\n          if (peek != null) {\n            reader.println(peek);\n            if (paginate) {\n              linesPrinted += peek.length() == 0 ? 0 : Math.ceil(peek.length() * 1.0 / termWidth);\n              // check if displaying the next line would result in\n              // scrolling off the screen\n              if (linesPrinted + Math.ceil(lastPromptLength * 1.0 / termWidth)\n                  + Math.ceil(prompt.length() * 1.0 / termWidth)\n                  + Math.ceil(line.length() * 1.0 / termWidth) > maxLines) {\n                linesPrinted = 0;\n                int numdashes = (termWidth - prompt.length()) / 2;\n                String nextPrompt = repeat(\"-\", numdashes) + prompt + repeat(\"-\", numdashes);\n                lastPromptLength = nextPrompt.length();\n                reader.print(nextPrompt);\n                reader.flush();\n                if (Character.toUpperCase((char) reader.readCharacter()) == 'Q') {\n                  reader.println();\n                  return;\n                }\n                reader.println();\n                termWidth = reader.getTerminal().getWidth();\n                maxLines = reader.getTerminal().getHeight();\n              }\n            }\n          }\n          peek = line;\n        } else {\n          out.print(line);\n        }\n      }\n    }\n    if (out == null && peek != null) {\n      reader.println(peek);\n    }\n  }\n  public final void printRecords(Iterable<Entry<Key,Value>> scanner, FormatterConfig config,\n      boolean paginate, Class<? extends Formatter> formatterClass, PrintLine outFile)\n      throws IOException {\n    printLines(FormatterFactory.getFormatter(formatterClass, scanner, config), paginate, outFile);\n  }\n  public final void printRecords(Iterable<Entry<Key,Value>> scanner, FormatterConfig config,\n      boolean paginate, Class<? extends Formatter> formatterClass) throws IOException {\n    printLines(FormatterFactory.getFormatter(formatterClass, scanner, config), paginate);\n  }\n<fim_suffix>  public static String repeat(String s, int c) {\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < c; i++)\n      sb.append(s);\n    return sb.toString();\n  }<fim_middle>// function below has no smell\n"}