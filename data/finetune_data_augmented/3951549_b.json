{"text": "<fim_prefix> * used to specify only those columns that need an update. This ways a read and Update pattern can be merged to a\n * simple update pattern thus avoiding a read if required.</p>\n *\n * @since 3.8.0\n * */\n@InterfaceStability.Evolving\npublic abstract class AbstractKuduOutputOperator extends BaseOperator\n    implements Operator.ActivationListener<Context.OperatorContext>,Operator.CheckpointNotificationListener\n{\n  private transient ApexKuduConnection apexKuduConnection;\n  private transient  KuduTable kuduTable;\n  private transient  KuduSession kuduSession;\n  private transient KuduClient kuduClientHandle;\n  private transient Map<String,ColumnSchema> allColumnDefs;\n  private transient Map<String,Object> kuduColumnBasedGetters;\n  private Set<String> primaryKeyColumnNames;\n  private static final transient Logger LOG = LoggerFactory.getLogger(AbstractKuduOutputOperator.class);\n  @NotNull\n  protected WindowDataManager windowDataManager;\n  private transient long currentWindowId;\n  private transient boolean isInReplayMode;\n  private transient boolean isInReconcilingMode;\n  private transient long reconcilingWindowId;\n  @AutoMetric\n  transient long numInserts;\n  @AutoMetric\n  transient long numUpserts;\n  @AutoMetric\n  transient long numDeletes;\n  @AutoMetric\n  transient long numUpdates;\n  @AutoMetric\n  transient long numOpsErrors;\n  @AutoMetric\n  transient long numBytesWritten;\n  @AutoMetric\n  transient long numRpcErrors;\n  @AutoMetric\n  transient long numWriteOps;\n  @AutoMetric\n  transient long numWriteRPCs;\n  @AutoMetric\n  long totalOpsErrors = 0;\n  @AutoMetric\n  long totalBytesWritten = 0;\n  @AutoMetric\n  long totalRpcErrors = 0;\n  @AutoMetric\n  long totalWriteOps = 0;\n  @AutoMetric\n  long totalWriteRPCs = 0;\n  @AutoMetric\n  long totalInsertsSinceStart;\n  @AutoMetric\n  long totalUpsertsSinceStart;\n  @AutoMetric\n  long totalDeletesSinceStart;\n  @AutoMetric\n  long totalUpdatesSinceStart;\n  public final transient DefaultInputPort<KuduExecutionContext> input = new DefaultInputPort<KuduExecutionContext>()\n  {\n    @Override\n    public void process(KuduExecutionContext kuduExecutionContext)\n    {\n      processTuple(kuduExecutionContext);\n    }\n  }; // end input port implementation\n  public void processTuple(KuduExecutionContext kuduExecutionContext)\n  {\n    if ( isInReconcilingMode || isInReplayMode) {\n      if ( !isEligibleForPassivationInReconcilingWindow(kuduExecutionContext, currentWindowId)) {\n        return;\n      }\n    }\n    KuduMutationType mutationType = kuduExecutionContext.getMutationType();\n    switch (mutationType) {\n      case DELETE:\n        processForDelete(kuduExecutionContext);\n        numDeletes += 1;\n        totalDeletesSinceStart += 1;\n        break;\n      case INSERT:\n        processForInsert(kuduExecutionContext);\n        numInserts += 1;\n        totalInsertsSinceStart += 1;\n        break;\n      case UPDATE:\n        processForUpdate(kuduExecutionContext);\n        numUpdates += 1;\n        totalUpdatesSinceStart += 1;\n        break;\n      case UPSERT:\n        processForUpsert(kuduExecutionContext);\n        numUpserts += 1;\n        totalUpsertsSinceStart += 1;\n        break;\n      default:\n        break;\n    }\n  }\n  /***\n   * Sets the values from the Pojo into the Kudu mutation object.\n   * @param currentOperation The operation instance that represents the current mutation. This will be applied to the\n   *                         current session\n   * @param kuduExecutionContext The tuple that contains the payload as well as other information like mutation type etc\n   */\n<fim_suffix>  @SuppressWarnings(value = \"unchecked\")\n  private void performCommonProcessing(Operation currentOperation, KuduExecutionContext kuduExecutionContext)\n  {\n    currentOperation.setExternalConsistencyMode(kuduExecutionContext.getExternalConsistencyMode());\n    Long propagatedTimeStamp = kuduExecutionContext.getPropagatedTimestamp();\n    if ( propagatedTimeStamp != null) { // set propagation timestamp only if enabled\n      currentOperation.setPropagatedTimestamp(propagatedTimeStamp);\n    }\n    PartialRow partialRow = currentOperation.getRow();\n    Object payload = kuduExecutionContext.getPayload();\n    Set<String> doNotWriteColumns = kuduExecutionContext.getDoNotWriteColumns();\n    if (doNotWriteColumns == null) {\n      doNotWriteColumns = new HashSet<>();\n    }\n    for (String columnName: kuduColumnBasedGetters.keySet()) {\n      if ( doNotWriteColumns.contains(columnName)) {\n        continue;\n      }\n      ColumnSchema columnSchema = allColumnDefs.get(columnName);\n      Type dataType = columnSchema.getType();\n      try {\n        switch (dataType) {\n          case STRING:\n            PojoUtils.Getter<Object, String> stringGetter = ((PojoUtils.Getter<Object, String>)kuduColumnBasedGetters\n                .get(columnName));\n            if (stringGetter != null) {\n              final String stringValue = stringGetter.get(payload);\n              if (stringValue != null) {\n                partialRow.addString(columnName, stringValue);\n              }\n            }\n            break;\n          case BINARY:\n            PojoUtils.Getter<Object, ByteBuffer> byteBufferGetter = ((PojoUtils.Getter<Object, ByteBuffer>)\n                kuduColumnBasedGetters.get(columnName));\n            if (byteBufferGetter != null) {\n              final ByteBuffer byteBufferValue = byteBufferGetter.get(payload);\n              if (byteBufferValue != null) {\n                partialRow.addBinary(columnName, byteBufferValue);\n              }\n            }\n            break;\n          case BOOL:\n            PojoUtils.GetterBoolean<Object> boolGetter = ((PojoUtils.GetterBoolean<Object>)kuduColumnBasedGetters.get(\n                columnName));\n            if (boolGetter != null) {\n              final boolean boolValue = boolGetter.get(payload);\n              partialRow.addBoolean(columnName, boolValue);\n            }\n            break;\n          case DOUBLE:\n            PojoUtils.GetterDouble<Object> doubleGetter = ((PojoUtils.GetterDouble<Object>)kuduColumnBasedGetters.get(\n                columnName));\n            if (doubleGetter != null) {\n              final double doubleValue = doubleGetter.get(payload);\n              partialRow.addDouble(columnName, doubleValue);\n            }\n            break;\n          case FLOAT:\n            PojoUtils.GetterFloat<Object> floatGetter = ((PojoUtils.GetterFloat<Object>)kuduColumnBasedGetters.get(\n                columnName));\n            if (floatGetter != null) {\n              final float floatValue = floatGetter.get(payload);\n              partialRow.addFloat(columnName, floatValue);\n            }\n            break;\n          case INT8:\n            PojoUtils.GetterByte<Object> byteGetter = ((PojoUtils.GetterByte<Object>)kuduColumnBasedGetters.get(\n                columnName));\n            if (byteGetter != null) {\n              final byte byteValue = byteGetter.get(payload);\n              partialRow.addByte(columnName, byteValue);\n            }\n            break;\n          case INT16:\n            PojoUtils.GetterShort<Object> shortGetter = ((PojoUtils.GetterShort<Object>)kuduColumnBasedGetters.get(\n                columnName));\n            if (shortGetter != null) {\n              final short shortValue = shortGetter.get(payload);\n              partialRow.addShort(columnName, shortValue);\n            }\n            break;\n          case INT32:\n            PojoUtils.GetterInt<Object> intGetter = ((PojoUtils.GetterInt<Object>)\n                kuduColumnBasedGetters.get(columnName));\n            if (intGetter != null) {\n              final int intValue = intGetter.get(payload);\n              partialRow.addInt(columnName, intValue);\n            }\n            break;\n          case INT64:\n          case UNIXTIME_MICROS:\n            PojoUtils.GetterLong<Object> longGetter = ((PojoUtils.GetterLong<Object>)kuduColumnBasedGetters.get(\n                columnName));\n            if (longGetter != null) {\n              final long longValue = longGetter.get(payload);\n              partialRow.addLong(columnName, longValue);\n            }\n            break;\n          default:\n            LOG.error(columnName + \" is not of the supported data type\");\n            throw new UnsupportedOperationException(\"Kudu does not support data type for column \" + columnName);\n        }\n      } catch ( Exception ex ) {\n        LOG.error(\" Exception while fetching the value of \" + columnName + \" because \" + ex.getMessage());\n        partialRow.setNull(columnName);\n      }\n    }\n    try {\n      kuduSession.apply(currentOperation);\n    } catch (KuduException e) {\n      throw new RuntimeException(\"Could not execute operation because \" + e.getMessage(), e);\n    }\n  }<fim_middle>// function below is long method and feature envy\n"}