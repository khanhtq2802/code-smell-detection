{"text": "<fim_prefix> *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage jdk.internal.net.http;\nimport java.lang.System.Logger.Level;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.concurrent.locks.ReentrantLock;\nimport jdk.internal.net.http.common.Logger;\nimport jdk.internal.net.http.common.Utils;\n/**\n * A Send Window Flow-Controller that is used to control outgoing Connection\n * and Stream flows, per HTTP/2 connection.\n *\n * A Http2Connection has its own unique single instance of a WindowController\n * that it shares with its Streams. Each stream must acquire the appropriate\n * amount of Send Window from the controller before sending data.\n *\n * WINDOW_UPDATE frames, both connection and stream specific, must notify the\n * controller of their increments. SETTINGS frame's INITIAL_WINDOW_SIZE must\n * notify the controller so that it can adjust the active stream's window size.\n */\nfinal class WindowController {\n    static final Logger debug =\n            Utils.getDebugLogger(\"WindowController\"::toString, Utils.DEBUG);\n    /**\n     * Default initial connection Flow-Control Send Window size, as per HTTP/2.\n     */\n    private static final int DEFAULT_INITIAL_WINDOW_SIZE = 64 * 1024 - 1;\n    /** The connection Send Window size. */\n    private int connectionWindowSize;\n    /** A Map of the active streams, where the key is the stream id, and the\n     *  value is the stream's Send Window size, which may be negative. */\n    private final Map<Integer,Integer> streams = new HashMap<>();\n    /** A Map of streams awaiting Send Window. The key is the stream id. The\n     * value is a pair of the Stream ( representing the key's stream id ) and\n     * the requested amount of send Window. */\n    private final Map<Integer, Map.Entry<Stream<?>, Integer>> pending\n            = new LinkedHashMap<>();\n    private final ReentrantLock controllerLock = new ReentrantLock();\n    /** A Controller with the default initial window size. */\n    WindowController() {\n        connectionWindowSize = DEFAULT_INITIAL_WINDOW_SIZE;\n    }\n//    /** A Controller with the given initial window size. */\n//    WindowController(int initialConnectionWindowSize) {\n//        connectionWindowSize = initialConnectionWindowSize;\n//    }\n    /** Registers the given stream with this controller. */\n    void registerStream(int streamid, int initialStreamWindowSize) {\n        controllerLock.lock();\n        try {\n            Integer old = streams.put(streamid, initialStreamWindowSize);\n            if (old != null)\n                throw new InternalError(\"Unexpected entry [\"\n                        + old + \"] for streamid: \" + streamid);\n        } finally {\n            controllerLock.unlock();\n        }\n    }\n    /** Removes/De-registers the given stream with this controller. */\n    void removeStream(int streamid) {\n        controllerLock.lock();\n        try {\n            Integer old = streams.remove(streamid);\n            // Odd stream numbers (client streams) should have been registered.\n            // Even stream numbers (server streams - aka Push Streams) should\n            // not be registered\n            final boolean isClientStream = (streamid & 0x1) == 1;\n            if (old == null && isClientStream) {\n                throw new InternalError(\"Expected entry for streamid: \" + streamid);\n            } else if (old != null && !isClientStream) {\n                throw new InternalError(\"Unexpected entry for streamid: \" + streamid);\n            }\n        } finally {\n            controllerLock.unlock();\n        }\n    }\n    /**\n     * Attempts to acquire the requested amount of Send Window for the given\n     * stream.\n     *\n     * The actual amount of Send Window available may differ from the requested\n     * amount. The actual amount, returned by this method, is the minimum of,\n     * 1) the requested amount, 2) the stream's Send Window, and 3) the\n     * connection's Send Window.\n     *\n     * A negative or zero value is returned if there's no window available.\n     * When the result is negative or zero, this method arranges for the\n     * given stream's {@link Stream#signalWindowUpdate()} method to be invoke at\n     * a later time when the connection and/or stream window's have been\n     * increased. The {@code tryAcquire} method should then be invoked again to\n     * attempt to acquire the available window.\n     */\n    int tryAcquire(int requestAmount, int streamid, Stream<?> stream) {\n        controllerLock.lock();\n        try {\n            Integer streamSize = streams.get(streamid);\n            if (streamSize == null)\n                throw new InternalError(\"Expected entry for streamid: \"\n                                        + streamid);\n            int x = Math.min(requestAmount,\n                             Math.min(streamSize, connectionWindowSize));\n            if (x <= 0)  { // stream window size may be negative\n                if (debug.on())\n                    debug.log(\"Stream %d requesting %d but only %d available (stream: %d, connection: %d)\",\n                              streamid, requestAmount, Math.min(streamSize, connectionWindowSize),\n                              streamSize, connectionWindowSize);\n                // If there's not enough window size available, put the\n                // caller in a pending list.\n                pending.put(streamid, Map.entry(stream, requestAmount));\n                return x;\n            }\n            // Remove the caller from the pending list ( if was waiting ).\n            pending.remove(streamid);\n            // Update window sizes and return the allocated amount to the caller.\n            streamSize -= x;\n            streams.put(streamid, streamSize);\n            connectionWindowSize -= x;\n            if (debug.on())\n                debug.log(\"Stream %d amount allocated %d, now %d available (stream: %d, connection: %d)\",\n                          streamid, x, Math.min(streamSize, connectionWindowSize),\n                          streamSize, connectionWindowSize);\n            return x;\n        } finally {\n            controllerLock.unlock();\n        }\n    }\n    /**\n     * Increases the Send Window size for the connection.\n     *\n     * A number of awaiting requesters, from unfulfilled tryAcquire requests,\n     * may have their stream's {@link Stream#signalWindowUpdate()} method\n     * scheduled to run ( i.e. awake awaiters ).\n     *\n     * @return false if, and only if, the addition of the given amount would\n     *         cause the Send Window to exceed 2^31-1 (overflow), otherwise true\n     */\n<fim_suffix>    boolean increaseConnectionWindow(int amount) {\n        List<Stream<?>> candidates = null;\n        controllerLock.lock();\n        try {\n            int size = connectionWindowSize;\n            size += amount;\n            if (size < 0)\n                return false;\n            connectionWindowSize = size;\n            if (debug.on())\n                debug.log(\"Connection window size is now %d (amount added %d)\",\n                          size, amount);\n            // Notify waiting streams, until the new increased window size is\n            // effectively exhausted.\n            Iterator<Map.Entry<Integer,Map.Entry<Stream<?>,Integer>>> iter =\n                    pending.entrySet().iterator();\n            while (iter.hasNext() && size > 0) {\n                Map.Entry<Integer,Map.Entry<Stream<?>,Integer>> item = iter.next();\n                Integer streamSize = streams.get(item.getKey());\n                if (streamSize == null) {\n                    iter.remove();\n                } else {\n                    Map.Entry<Stream<?>,Integer> e = item.getValue();\n                    int requestedAmount = e.getValue();\n                    // only wakes up the pending streams for which there is\n                    // at least 1 byte of space in both windows\n                    int minAmount = 1;\n                    if (size >= minAmount && streamSize >= minAmount) {\n                        size -= Math.min(streamSize, requestedAmount);\n                        iter.remove();\n                        if (candidates == null)\n                            candidates = new ArrayList<>();\n                        candidates.add(e.getKey());\n                    }\n                }\n            }\n        } finally {\n            controllerLock.unlock();\n        }\n        if (candidates != null) {\n            candidates.forEach(Stream::signalWindowUpdate);\n        }\n        return true;\n    }<fim_middle>// function below is long method\n"}