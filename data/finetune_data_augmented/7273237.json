{"text": "<fim_prefix>        if (retained) {\n            if (!DataType.RETAINED_SIZE.valuesAvailable(h1))\n                DataType.RETAINED_SIZE.computeValuesImmediately(h1);\n            if (!DataType.RETAINED_SIZE.valuesAvailable(h2))\n                DataType.RETAINED_SIZE.computeValuesImmediately(h2);\n        }\n        Map<JavaClassID, DiffClassNode> classes = new HashMap();\n        List<JavaClass> classes1 = h1.getAllClasses();\n        for (JavaClass jc1 : classes1) {\n            JavaClassID id1 = JavaClassID.create(jc1);\n            DiffClassNode djc1 = classes.get(id1);\n            if (djc1 == null) {\n                djc1 = DiffClassNode.own(jc1, retained);\n                classes.put(id1, djc1);\n            } else {\n                djc1.mergeOwn(jc1);\n            }\n        }\n        List<JavaClass> classes2 = h2.getAllClasses();\n        for (JavaClass jc2 : classes2) {\n            JavaClassID id2 = JavaClassID.create(jc2);\n            DiffClassNode djc2 = classes.get(id2);\n            if (djc2 == null) {\n                djc2 = DiffClassNode.external(new ExternalJavaClass(jc2, retained), retained);\n                classes.put(id2, djc2);\n            } else {\n                djc2.mergeExternal(jc2);\n            }\n        }\n        return new ArrayList(classes.values());\n    }\n    private static class JavaClassID {\n        static JavaClassID create(JavaClass jc) {\n            return new JavaClassID(jc);\n        }\n        private final String id;\n        private JavaClassID(JavaClass jc) {\n            id = jc.getName();\n        }\n        @Override\n        public boolean equals(Object o) {\n            if (!(o instanceof JavaClassID)) return false;\n            return id.equals(((JavaClassID)o).id);\n        }\n        @Override\n        public int hashCode() {\n            return id.hashCode();\n        }\n    }\n    private static class DiffClassNode extends ClassNode {\n        private final boolean trackRetained;\n        private final boolean ownClass;\n        private int instancesCount;\n        private long ownSize;\n        private long retainedSize;\n        static DiffClassNode own(JavaClass ownClass, boolean trackRetained) {\n            DiffClassNode dClass = new DiffClassNode(ownClass, true, trackRetained);\n            dClass.mergeOwn(ownClass);\n            return dClass;\n        }\n        static DiffClassNode external(JavaClass externalClass, boolean trackRetained) {\n            DiffClassNode dClass = new DiffClassNode(externalClass, false, trackRetained);\n            dClass.mergeExternal(externalClass);\n            return dClass;\n        }\n        private DiffClassNode(JavaClass jClass, boolean ownClass, boolean trackRetained) {\n            super(jClass);\n            this.trackRetained = trackRetained;\n            this.ownClass = ownClass;\n            setChildren(NO_NODES);\n        }\n        boolean isOwnClass() {\n            return this.ownClass;\n        }\n        void mergeOwn(JavaClass ownClass) {\n            instancesCount += ownClass.getInstancesCount();\n            ownSize += ownClass.getAllInstancesSize();\n            if (trackRetained) retainedSize += ownClass.getRetainedSizeByClass();\n        }\n        void mergeExternal(JavaClass externalClass) {\n            instancesCount -= externalClass.getInstancesCount();\n            ownSize -= externalClass.getAllInstancesSize();\n            if (trackRetained) retainedSize -= externalClass.getRetainedSizeByClass();\n        }\n        // NOTE: returning null breaks filtering\n//        public JavaClass getJavaClass() {\n//            return isOwnClass() ? super.getJavaClass() : null;\n//        }\n        public int getInstancesCount() {\n            return instancesCount;\n        }\n        public long getOwnSize() {\n            return ownSize;\n        }\n        public long getRetainedSize(Heap heap) {\n            return trackRetained ? retainedSize : DataType.RETAINED_SIZE.getNotAvailableValue();\n        }\n        public boolean isLeaf() {\n            return true;\n        }\n        public ClassNode createCopy() {\n            return ownClass ? super.createCopy() : null;\n        }\n        @Override\n        public boolean equals(Object o) {\n            if (o == this) return true;\n            if (!(o instanceof ClassNode)) return false;\n            return getName().equals(((ClassNode)o).getName());\n        }\n        @Override\n        public int hashCode() {\n            return getName().hashCode();\n        }\n        protected Object getValue(DataType type, Heap heap) {\n            if (type == DataType.NAME) return getName();\n            if (type == DataType.COUNT) return getInstancesCount();\n            if (type == DataType.OWN_SIZE) return getOwnSize();\n            if (type == DataType.RETAINED_SIZE) return getRetainedSize(heap);\n            if (type == DataType.CLASS) return getJavaClass();\n            return type.getNotAvailableValue();\n        }\n    }\n    private static class DiffPackageNode extends ClassesContainer.Nodes {\n        private final boolean trackRetained;\n        DiffPackageNode (String name, boolean trackRetained) {\n            super(name);\n            this.trackRetained = trackRetained;\n            count = 0;\n            ownSize = 0;\n            if (trackRetained) retainedSize = 0;\n        }\n        public void add(ClassNode item, Heap heap) {\n            items.add(item);\n            count += getCount(item, heap);\n            ownSize += getOwnSize(item, heap);\n            if (trackRetained) retainedSize += getRetainedSize(item, heap);\n        }\n    }\n    private static class DiffClassNodeRenderer implements HeapViewerRenderer {\n        private final Heap heap;\n        private ClassNodeRenderer currentRenderer;\n        private ClassNodeRenderer ownRenderer;\n        private ClassNodeRenderer externalRenderer;\n        public DiffClassNodeRenderer(Heap heap) {\n            this.heap = heap;\n        }\n        @Override\n        public Icon getIcon() {\n            return currentRenderer.getIcon();\n        }\n        @Override\n        public String getShortName() {\n            return currentRenderer.getShortName();\n        }\n        @Override\n        public void setValue(Object o, int i) {\n            if (o == null) return;\n            DiffClassNode cdn = (DiffClassNode)o;\n            currentRenderer = cdn.isOwnClass() ? ownRenderer() : externalRenderer();\n            currentRenderer.setValue(o, i);\n        }\n        @Override\n        public int getHorizontalAlignment() {\n            return currentRenderer.getHorizontalAlignment();\n        }\n        @Override\n        public JComponent getComponent() {\n            return currentRenderer.getComponent();\n        }\n        @Override\n        public void move(int i, int i1) {\n            currentRenderer.move(i, i1);\n        }\n        @Override\n        public AccessibleContext getAccessibleContext() {\n            return currentRenderer.getAccessibleContext();\n        }\n        @Override\n        public String toString() {\n            return currentRenderer == null ? \"\" : currentRenderer.toString(); // NOI18N\n        }\n        private ClassNodeRenderer ownRenderer() {\n            if (ownRenderer == null) ownRenderer = new ClassNodeRenderer(heap);\n            return ownRenderer;\n        }\n        private ClassNodeRenderer externalRenderer() {\n            if (externalRenderer == null) {\n//                Image dis = GrayFilter.createDisabledImage(Icons.getImage(LanguageIcons.CLASS));\n//                Icon dis = ImageUtilities.createDisabledIcon(Icons.getIcon(LanguageIcons.CLASS));\n                Icon dis = UIManager.getLookAndFeel().getDisabledIcon(new JLabel(), Icons.getIcon(LanguageIcons.CLASS));\n                externalRenderer = new ClassNodeRenderer(dis, heap);\n            }\n            return externalRenderer;\n        }\n    }\n    @ServiceProvider(service=HeapViewerRenderer.Provider.class)\n    public static class DiffClassNodeRendererProvider extends HeapViewerRenderer.Provider {\n        public boolean supportsView(HeapContext context, String viewID) {\n            return viewID.startsWith(\"diff\") && JavaHeapFragment.isJavaHeap(context); // NOI18N\n        }\n        public void registerRenderers(Map<Class<? extends HeapViewerNode>, HeapViewerRenderer> renderers, HeapContext context) {\n            Heap heap = context.getFragment().getHeap();\n            DiffClassNodeRenderer dcnRenderer = new DiffClassNodeRenderer(heap);\n            renderers.put(DiffClassNode.class, dcnRenderer);\n        }\n    }\n    private static class ExternalJavaClass implements JavaClass {\n        private final long allInstancesSize;\n        private final boolean isArray;\n        private final int instanceSize;\n        private final int instancesCount;\n        private final long retainedSizeByClass;\n        private final long javaClassId;\n        private final String name;\n<fim_suffix>        ExternalJavaClass(JavaClass javaClass, boolean retained) {\n            allInstancesSize = javaClass.getAllInstancesSize();\n            isArray = javaClass.isArray();\n            instanceSize = javaClass.getInstanceSize();\n            instancesCount = javaClass.getInstancesCount();\n            retainedSizeByClass = retained ? javaClass.getRetainedSizeByClass() : DataType.RETAINED_SIZE.getNotAvailableValue();\n            javaClassId = javaClass.getJavaClassId();\n            name = javaClass.getName();\n        }<fim_middle>// function below has no smell\n"}