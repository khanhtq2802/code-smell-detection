{"text": "<fim_prefix>        private final Iterator<F> mI;\n        private F mCur;\n        IteratorWrapper(Iterator<F> it) {\n            mI = it;\n        }\n        public boolean hasNext() {\n            return mI.hasNext();\n        }\n        public F next() {\n            return (mCur = mI.next());\n        }\n        public void remove() {\n            if (mCur != null) {\n                removeFilterInternal(mCur);\n            }\n            mI.remove();\n        }\n    }\n    /**\n     * Returns an iterator allowing filters to be removed.\n     */\n    public Iterator<F> filterIterator() {\n        return new IteratorWrapper(mFilters.iterator());\n    }\n    /**\n     * Returns a read-only set of the filters.\n     */\n    public Set<F> filterSet() {\n        return Collections.unmodifiableSet(mFilters);\n    }\n    public List<R> queryIntentFromList(Intent intent, String resolvedType, \n            boolean defaultOnly, ArrayList<F[]> listCut) {\n        ArrayList<R> resultList = new ArrayList<R>();\n        final boolean debug = localLOGV ||\n                ((intent.getFlags() & Intent.FLAG_DEBUG_LOG_RESOLUTION) != 0);\n        FastImmutableArraySet<String> categories = getFastIntentCategories(intent);\n        final String scheme = intent.getScheme();\n        int N = listCut.size();\n        for (int i = 0; i < N; ++i) {\n            buildResolveList(intent, categories, debug, defaultOnly,\n                    resolvedType, scheme, listCut.get(i), resultList);\n        }\n        sortResults(resultList);\n        return resultList;\n    }\n    public List<R> queryIntent(Intent intent, String resolvedType, boolean defaultOnly) {\n        String scheme = intent.getScheme();\n        ArrayList<R> finalList = new ArrayList<R>();\n        final boolean debug = localLOGV ||\n                ((intent.getFlags() & Intent.FLAG_DEBUG_LOG_RESOLUTION) != 0);\n        F[] firstTypeCut = null;\n        F[] secondTypeCut = null;\n        F[] thirdTypeCut = null;\n        F[] schemeCut = null;\n        // If the intent includes a MIME type, then we want to collect all of\n        // the filters that match that MIME type.\n        if (resolvedType != null) {\n            int slashpos = resolvedType.indexOf('/');\n            if (slashpos > 0) {\n                final String baseType = resolvedType.substring(0, slashpos);\n                if (!baseType.equals(\"*\")) {\n                    if (resolvedType.length() != slashpos+2\n                            || resolvedType.charAt(slashpos+1) != '*') {\n                        // Not a wild card, so we can just look for all filters that\n                        // completely match or wildcards whose base type matches.\n                        firstTypeCut = mTypeToFilter.get(resolvedType);\n                        secondTypeCut = mWildTypeToFilter.get(baseType);\n                    } else {\n                        // We can match anything with our base type.\n                        firstTypeCut = mBaseTypeToFilter.get(baseType);\n                        secondTypeCut = mWildTypeToFilter.get(baseType);\n                    }\n                    // Any */* types always apply, but we only need to do this\n                    // if the intent type was not already */*.\n                    thirdTypeCut = mWildTypeToFilter.get(\"*\");\n                } else if (intent.getAction() != null) {\n                    // The intent specified any type ({@literal *}/*).  This\n                    // can be a whole heck of a lot of things, so as a first\n                    // cut let's use the action instead.\n                    firstTypeCut = mTypedActionToFilter.get(intent.getAction());\n                }\n            }\n        }\n        // If the intent includes a data URI, then we want to collect all of\n        // the filters that match its scheme (we will further refine matches\n        // on the authority and path by directly matching each resulting filter).\n        if (scheme != null) {\n            schemeCut = mSchemeToFilter.get(scheme);\n        }\n        // If the intent does not specify any data -- either a MIME type or\n        // a URI -- then we will only be looking for matches against empty\n        // data.\n        if (resolvedType == null && scheme == null && intent.getAction() != null) {\n            firstTypeCut = mActionToFilter.get(intent.getAction());\n        }\n        FastImmutableArraySet<String> categories = getFastIntentCategories(intent);\n        if (firstTypeCut != null) {\n            buildResolveList(intent, categories, debug, defaultOnly,\n                    resolvedType, scheme, firstTypeCut, finalList);\n        }\n        if (secondTypeCut != null) {\n            buildResolveList(intent, categories, debug, defaultOnly,\n                    resolvedType, scheme, secondTypeCut, finalList);\n        }\n        if (thirdTypeCut != null) {\n            buildResolveList(intent, categories, debug, defaultOnly,\n                    resolvedType, scheme, thirdTypeCut, finalList);\n        }\n        if (schemeCut != null) {\n            buildResolveList(intent, categories, debug, defaultOnly,\n                    resolvedType, scheme, schemeCut, finalList);\n        }\n        sortResults(finalList);\n        return finalList;\n    }\n    /**\n     * Control whether the given filter is allowed to go into the result\n     * list.  Mainly intended to prevent adding multiple filters for the\n     * same target object.\n     */\n    protected boolean allowFilterResult(F filter, List<R> dest) {\n        return true;\n    }\n    /**\n     * Returns whether the object associated with the given filter is\n     * \"stopped,\" that is whether it should not be included in the result\n     * if the intent requests to excluded stopped objects.\n     */\n    protected boolean isFilterStopped(F filter) {\n        return false;\n    }\n    /**\n     * Returns whether this filter is owned by this package. This must be\n     * implemented to provide correct filtering of Intents that have\n     * specified a package name they are to be delivered to.\n     */\n    protected abstract boolean isPackageForFilter(String packageName, F filter);\n    protected abstract F[] newArray(int size);\n    @SuppressWarnings(\"unchecked\")\n    protected R newResult(F filter, int match) {\n        return (R)filter;\n    }\n    @SuppressWarnings(\"unchecked\")\n    protected void sortResults(List<R> results) {\n        Collections.sort(results, mResolvePrioritySorter);\n    }\n    protected void dumpFilter(PrintWriter out, String prefix, F filter) {\n        out.print(prefix); out.println(filter);\n    }\n    private final void addFilter(HashMap<String, F[]> map, String name, F filter) {\n        F[] array = map.get(name);\n        if (array == null) {\n            array = newArray(2);\n            map.put(name,  array);\n            array[0] = filter;\n        } else {\n            final int N = array.length;\n            int i = N;\n            while (i > 0 && array[i-1] == null) {\n                i--;\n            }\n            if (i < N) {\n                array[i] = filter;\n            } else {\n                F[] newa = newArray((N*3)/2);\n                System.arraycopy(array, 0, newa, 0, N);\n                newa[N] = filter;\n                map.put(name, newa);\n            }\n        }\n    }\n<fim_suffix>    private final int register_mime_types(F filter, String prefix) {\n        final Iterator<String> i = filter.typesIterator();\n        if (i == null) {\n            return 0;\n        }\n        int num = 0;\n        while (i.hasNext()) {\n            String name = i.next();\n            num++;\n            String baseName = name;\n            final int slashpos = name.indexOf('/');\n            if (slashpos > 0) {\n                baseName = name.substring(0, slashpos).intern();\n            } else {\n                name = name + \"/*\";\n            }\n            addFilter(mTypeToFilter, name, filter);\n            if (slashpos > 0) {\n                addFilter(mBaseTypeToFilter, baseName, filter);\n            } else {\n                addFilter(mWildTypeToFilter, baseName, filter);\n            }\n        }\n        return num;\n    }<fim_middle>// function below has no smell\n"}