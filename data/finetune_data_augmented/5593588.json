{"text": "<fim_prefix>import org.apache.poi.hwmf.usermodel.HwmfPicture;\nimport org.apache.poi.util.IOUtils;\nimport org.apache.poi.util.Internal;\nimport org.apache.poi.util.LittleEndianConsts;\nimport org.apache.poi.util.LittleEndianInputStream;\nimport org.apache.poi.util.LocaleUtil;\nimport org.apache.poi.util.RecordFormatException;\n/**\n * Contains arbitrary data\n */\n@Internal\npublic class HemfComment {\n    private static final int MAX_RECORD_LENGTH = HwmfPicture.MAX_RECORD_LENGTH;\n    public enum HemfCommentRecordType {\n        emfGeneric(-1, EmfCommentDataGeneric::new, false),\n        emfSpool(0x00000000, EmfCommentDataGeneric::new, false),\n        emfPlus(0x2B464D45, EmfCommentDataPlus::new, false),\n        emfPublic(0x43494447, null, false),\n        emfBeginGroup(0x00000002, EmfCommentDataBeginGroup::new, true),\n        emfEndGroup(0x00000003, EmfCommentDataEndGroup::new, true),\n        emfMultiFormats(0x40000004, EmfCommentDataMultiformats::new, true),\n        emfWMF(0x80000001, EmfCommentDataWMF::new, true),\n        emfUnicodeString(0x00000040, EmfCommentDataUnicode::new, true),\n        emfUnicodeEnd(0x00000080, EmfCommentDataUnicode::new, true)\n        ;\n        public final long id;\n        public final Supplier<? extends EmfCommentData> constructor;\n        public final boolean isEmfPublic;\n        HemfCommentRecordType(long id, Supplier<? extends EmfCommentData> constructor, boolean isEmfPublic) {\n            this.id = id;\n            this.constructor = constructor;\n            this.isEmfPublic = isEmfPublic;\n        }\n        public static HemfCommentRecordType getById(long id, boolean isEmfPublic) {\n            for (HemfCommentRecordType wrt : values()) {\n                if (wrt.id == id && wrt.isEmfPublic == isEmfPublic) return wrt;\n            }\n            return emfGeneric;\n        }\n    }\n    public interface EmfCommentData {\n        HemfCommentRecordType getCommentRecordType();\n        long init(LittleEndianInputStream leis, long dataSize) throws IOException;\n    }\n    public static class EmfComment implements HemfRecord {\n        private EmfCommentData data;\n        @Override\n        public HemfRecordType getEmfRecordType() {\n            return HemfRecordType.comment;\n        }\n        @Override\n        public long init(LittleEndianInputStream leis, long recordSize, long recordId) throws IOException {\n            int startIdx = leis.getReadIndex();\n            data = new EmfCommentDataIterator(leis, (int)recordSize, true).next();\n            return leis.getReadIndex()-startIdx;\n        }\n        public EmfCommentData getCommentData() {\n            return data;\n        }\n        @Override\n        public String toString() {\n            return \"{ data: \"+data+\" }\";\n        }\n    }\n    public static class EmfCommentDataIterator implements Iterator<EmfCommentData> {\n        private final LittleEndianInputStream leis;\n        private final int startIdx;\n        private final int limit;\n        private EmfCommentData currentRecord;\n        /** is the caller the EmfComment */\n        private final boolean emfParent;\n        public EmfCommentDataIterator(LittleEndianInputStream leis, int limit, boolean emfParent) {\n            this.leis = leis;\n            this.limit = limit;\n            this.emfParent = emfParent;\n            startIdx = leis.getReadIndex();\n            //queue the first non-header record\n            currentRecord = _next();\n        }\n        @Override\n        public boolean hasNext() {\n            return currentRecord != null;\n        }\n        @Override\n        public EmfCommentData next() {\n            EmfCommentData toReturn = currentRecord;\n            final boolean isEOF = (limit == -1 || leis.getReadIndex() >= startIdx+limit);\n            // (currentRecord instanceof HemfPlusMisc.EmfEof)\n            currentRecord = isEOF ? null : _next();\n            return toReturn;\n        }\n        private EmfCommentData _next() {\n            long type, recordSize;\n            if (currentRecord == null && emfParent) {\n                type = HemfRecordType.comment.id;\n                recordSize = limit;\n            } else {\n                // A 32-bit unsigned integer from the RecordType enumeration that identifies this record\n                // as a comment record. This value MUST be 0x00000046.\n                try {\n                    type = leis.readUInt();\n                } catch (RuntimeException e) {\n                    // EOF\n                    return null;\n                }\n                assert(type == HemfRecordType.comment.id);\n                // A 32-bit unsigned integer that specifies the size in bytes of this record in the\n                // metafile. This value MUST be a multiple of 4 bytes.\n                recordSize = leis.readUInt();\n            }\n            // A 32-bit unsigned integer that specifies the size, in bytes, of the CommentIdentifier and\n            // CommentRecordParm fields in the RecordBuffer field that follows.\n            // It MUST NOT include the size of itself or the size of the AlignmentPadding field, if present.\n            long dataSize = leis.readUInt();\n            try {\n                leis.mark(2*LittleEndianConsts.INT_SIZE);\n                // An optional, 32-bit unsigned integer that identifies the type of comment record.\n                // See the preceding table for descriptions of these record types.\n                // Valid comment identifier values are listed in the following table.\n                //\n                // If this field contains any other value, the comment record MUST be an EMR_COMMENT record\n                final int commentIdentifier = (int)leis.readUInt();\n                // A 32-bit unsigned integer that identifies the type of public comment record.\n                final int publicCommentIdentifier = (int)leis.readUInt();\n                final boolean isEmfPublic = (commentIdentifier == HemfCommentRecordType.emfPublic.id);\n                leis.reset();\n                final HemfCommentRecordType commentType = HemfCommentRecordType.getById\n                    (isEmfPublic ? publicCommentIdentifier : commentIdentifier, isEmfPublic);\n                assert(commentType != null);\n                final EmfCommentData record = commentType.constructor.get();\n                long readBytes = record.init(leis, dataSize);\n                final int skipBytes = (int)(recordSize-4-readBytes);\n                assert (skipBytes >= 0);\n                leis.skipFully(skipBytes);\n                return record;\n            } catch (IOException e) {\n                throw new RecordFormatException(e);\n            }\n        }\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException(\"Remove not supported\");\n        }\n    }\n    /**\n     * Private data is unknown to EMF; it is meaningful only to applications that know the format of the\n     * data and how to use it. EMR_COMMENT private data records MAY be ignored.\n     */\n    public static class EmfCommentDataGeneric implements EmfCommentData {\n        private byte[] privateData;\n        @Override\n        public HemfCommentRecordType getCommentRecordType() {\n            return HemfCommentRecordType.emfGeneric;\n        }\n        @Override\n        public long init(LittleEndianInputStream leis, long dataSize) throws IOException {\n            privateData = IOUtils.safelyAllocate(dataSize, MAX_RECORD_LENGTH);\n            leis.readFully(privateData);\n            return privateData.length;\n        }\n        @Override\n        public String toString() {\n            return \"\\\"\"+new String(privateData, LocaleUtil.CHARSET_1252).replaceAll(\"\\\\p{Cntrl}\", \".\")+\"\\\"\";\n        }\n    }\n    /** The EMR_COMMENT_EMFPLUS record contains embedded EMF+ records. */\n<fim_suffix>    public static class EmfCommentDataPlus implements EmfCommentData {\n        private final List<HemfPlusRecord> records = new ArrayList<>();\n        @Override\n        public HemfCommentRecordType getCommentRecordType() {\n            return HemfCommentRecordType.emfPlus;\n        }\n        @Override\n        public long init(final LittleEndianInputStream leis, final long dataSize)\n        throws IOException {\n            long startIdx = leis.getReadIndex();\n            int commentIdentifier = leis.readInt();\n            assert (commentIdentifier == HemfCommentRecordType.emfPlus.id);\n            new HemfPlusRecordIterator(leis, (int)dataSize-LittleEndianConsts.INT_SIZE).forEachRemaining(records::add);\n            return leis.getReadIndex()-startIdx;\n        }\n        public List<HemfPlusRecord> getRecords() {\n            return Collections.unmodifiableList(records);\n        }\n    }<fim_middle>// class below has no smell\n"}