{"text": "<fim_prefix>        } else {\n          out.println(\"    frame \" + (isSeekFrame ? \"(seek, loaded)\" : \"(next, loaded)\") + \" ord=\" + ord + \" fp=\" + f.fp + (f.isFloor ? (\" (fpOrig=\" + f.fpOrig + \")\") : \"\") + \" prefixLen=\" + f.prefix + \" prefix=\" + prefix + \" nextEnt=\" + f.nextEnt + (f.nextEnt == -1 ? \"\" : (\" (of \" + f.entCount + \")\")) + \" hasTerms=\" + f.hasTerms + \" isFloor=\" + f.isFloor + \" code=\" + ((f.fp<< BlockTreeTermsReader.OUTPUT_FLAGS_NUM_BITS) + (f.hasTerms ? BlockTreeTermsReader.OUTPUT_FLAG_HAS_TERMS:0) + (f.isFloor ? BlockTreeTermsReader.OUTPUT_FLAG_IS_FLOOR:0)) + \" lastSubFP=\" + f.lastSubFP + \" isLastInFloor=\" + f.isLastInFloor + \" mdUpto=\" + f.metaDataUpto + \" tbOrd=\" + f.getTermBlockOrd());\n        }\n        if (fr.index != null) {\n          assert !isSeekFrame || f.arc != null: \"isSeekFrame=\" + isSeekFrame + \" f.arc=\" + f.arc;\n          if (f.prefix > 0 && isSeekFrame && f.arc.label != (term.byteAt(f.prefix-1)&0xFF)) {\n            out.println(\"      broken seek state: arc.label=\" + (char) f.arc.label + \" vs term byte=\" + (char) (term.byteAt(f.prefix-1)&0xFF));\n            throw new RuntimeException(\"seek state is broken\");\n          }\n          BytesRef output = Util.get(fr.index, prefix);\n          if (output == null) {\n            out.println(\"      broken seek state: prefix is not final in index\");\n            throw new RuntimeException(\"seek state is broken\");\n          } else if (isSeekFrame && !f.isFloor) {\n            final ByteArrayDataInput reader = new ByteArrayDataInput(output.bytes, output.offset, output.length);\n            final long codeOrig = reader.readVLong();\n            final long code = (f.fp << BlockTreeTermsReader.OUTPUT_FLAGS_NUM_BITS) | (f.hasTerms ? BlockTreeTermsReader.OUTPUT_FLAG_HAS_TERMS:0) | (f.isFloor ? BlockTreeTermsReader.OUTPUT_FLAG_IS_FLOOR:0);\n            if (codeOrig != code) {\n              out.println(\"      broken seek state: output code=\" + codeOrig + \" doesn't match frame code=\" + code);\n              throw new RuntimeException(\"seek state is broken\");\n            }\n          }\n        }\n        if (f == currentFrame) {\n          break;\n        }\n        if (f.prefix == validIndexPrefix) {\n          isSeekFrame = false;\n        }\n        ord++;\n      }\n    }\n  }\n  /* Decodes only the term bytes of the next term.  If caller then asks for\n     metadata, ie docFreq, totalTermFreq or pulls a D/&PEnum, we then (lazily)\n     decode all metadata up to the current term. */\n  @Override\n  public BytesRef next() throws IOException {\n    if (in == null) {\n      // Fresh TermsEnum; seek to first term:\n      final FST.Arc<BytesRef> arc;\n      if (fr.index != null) {\n        arc = fr.index.getFirstArc(arcs[0]);\n        // Empty string prefix must have an output in the index!\n        assert arc.isFinal();\n      } else {\n        arc = null;\n      }\n      currentFrame = pushFrame(arc, fr.rootCode, 0);\n      currentFrame.loadBlock();\n    }\n    targetBeforeCurrentLength = currentFrame.ord;\n    assert !eof;\n    // if (DEBUG) {\n    //   System.out.println(\"\\nBTTR.next seg=\" + fr.parent.segment + \" term=\" + brToString(term) + \" termExists?=\" + termExists + \" field=\" + fr.fieldInfo.name + \" termBlockOrd=\" + currentFrame.state.termBlockOrd + \" validIndexPrefix=\" + validIndexPrefix);\n    //   printSeekState(System.out);\n    // }\n    if (currentFrame == staticFrame) {\n      // If seek was previously called and the term was\n      // cached, or seek(TermState) was called, usually\n      // caller is just going to pull a D/&PEnum or get\n      // docFreq, etc.  But, if they then call next(),\n      // this method catches up all internal state so next()\n      // works properly:\n      //if (DEBUG) System.out.println(\"  re-seek to pending term=\" + term.utf8ToString() + \" \" + term);\n      final boolean result = seekExact(term.get());\n      assert result;\n    }\n    // Pop finished blocks\n    while (currentFrame.nextEnt == currentFrame.entCount) {\n      if (!currentFrame.isLastInFloor) {\n        // Advance to next floor block\n        currentFrame.loadNextFloorBlock();\n        break;\n      } else {\n        //if (DEBUG) System.out.println(\"  pop frame\");\n        if (currentFrame.ord == 0) {\n          //if (DEBUG) System.out.println(\"  return null\");\n          assert setEOF();\n          term.clear();\n          validIndexPrefix = 0;\n          currentFrame.rewind();\n          termExists = false;\n          return null;\n        }\n        final long lastFP = currentFrame.fpOrig;\n        currentFrame = stack[currentFrame.ord-1];\n        if (currentFrame.nextEnt == -1 || currentFrame.lastSubFP != lastFP) {\n          // We popped into a frame that's not loaded\n          // yet or not scan'd to the right entry\n          currentFrame.scanToFloorFrame(term.get());\n          currentFrame.loadBlock();\n          currentFrame.scanToSubBlock(lastFP);\n        }\n        // Note that the seek state (last seek) has been\n        // invalidated beyond this depth\n        validIndexPrefix = Math.min(validIndexPrefix, currentFrame.prefix);\n        //if (DEBUG) {\n        //System.out.println(\"  reset validIndexPrefix=\" + validIndexPrefix);\n        //}\n      }\n    }\n    while(true) {\n      if (currentFrame.next()) {\n        // Push to new block:\n        //if (DEBUG) System.out.println(\"  push frame\");\n        currentFrame = pushFrame(null, currentFrame.lastSubFP, term.length());\n        // This is a \"next\" frame -- even if it's\n        // floor'd we must pretend it isn't so we don't\n        // try to scan to the right floor frame:\n        currentFrame.loadBlock();\n      } else {\n        //if (DEBUG) System.out.println(\"  return term=\" + brToString(term) + \" currentFrame.ord=\" + currentFrame.ord);\n        return term.get();\n      }\n    }\n  }\n  @Override\n  public BytesRef term() {\n    assert !eof;\n    return term.get();\n  }\n  @Override\n  public int docFreq() throws IOException {\n    assert !eof;\n    //if (DEBUG) System.out.println(\"BTR.docFreq\");\n    currentFrame.decodeMetaData();\n    //if (DEBUG) System.out.println(\"  return \" + currentFrame.state.docFreq);\n    return currentFrame.state.docFreq;\n  }\n  @Override\n  public long totalTermFreq() throws IOException {\n    assert !eof;\n    currentFrame.decodeMetaData();\n    return currentFrame.state.totalTermFreq;\n  }\n<fim_suffix>  @Override\n  public PostingsEnum postings(PostingsEnum reuse, int flags) throws IOException {\n    assert !eof;\n    //if (DEBUG) {\n    //System.out.println(\"BTTR.docs seg=\" + segment);\n    //}\n    currentFrame.decodeMetaData();\n    //if (DEBUG) {\n    //System.out.println(\"  state=\" + currentFrame.state);\n    //}\n    return fr.parent.postingsReader.postings(fr.fieldInfo, currentFrame.state, reuse, flags);\n  }<fim_middle>// function below has no smell\n"}