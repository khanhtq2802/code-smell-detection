{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.yarn.service.provider;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.hadoop.fs.FileStatus;\nimport org.apache.hadoop.fs.FileSystem;\nimport org.apache.hadoop.fs.Path;\nimport org.apache.hadoop.yarn.service.api.records.Artifact;\nimport org.apache.hadoop.yarn.service.api.records.ConfigFile;\nimport org.apache.hadoop.yarn.service.utils.ServiceUtils;\n\nimport java.io.IOException;\nimport java.nio.file.Paths;\nimport java.text.MessageFormat;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport static org.apache.hadoop.yarn.service.conf.YarnServiceConstants.CONTENT;\n\n<fim_suffix>public abstract class AbstractClientProvider {\n\n  public AbstractClientProvider() {\n  }\n\n  /**\n   * Generates a fixed format of application tags given one or more of\n   * application name, version and description. This allows subsequent query for\n   * an application with a name only, version only or description only or any\n   * combination of those as filters.\n   *\n   * @param appName name of the application\n   * @param appVersion version of the application\n   * @param appDescription brief description of the application\n   * @return\n   */\n  public static final Set<String> createApplicationTags(String appName,\n      String appVersion, String appDescription) {\n    Set<String> tags = new HashSet<>();\n    tags.add(ServiceUtils.createNameTag(appName));\n    if (appVersion != null) {\n      tags.add(ServiceUtils.createVersionTag(appVersion));\n    }\n    if (appDescription != null) {\n      tags.add(ServiceUtils.createDescriptionTag(appDescription));\n    }\n    return tags;\n  }\n\n  /**\n   * Validate the artifact.\n   * @param artifact\n   */\n  public abstract void validateArtifact(Artifact artifact, String compName,\n      FileSystem fileSystem) throws IOException;\n\n  protected abstract void validateConfigFile(ConfigFile configFile,\n      String compName, FileSystem fileSystem) throws IOException;\n\n  /**\n   * Validate the config files.\n   * @param configFiles config file list\n   * @param fs file system\n   */\n  public void validateConfigFiles(List<ConfigFile> configFiles, String compName,\n      FileSystem fs) throws IOException {\n    Set<String> destFileSet = new HashSet<>();\n\n    for (ConfigFile file : configFiles) {\n      if (file.getType() == null) {\n        throw new IllegalArgumentException(\"File type is empty\");\n      }\n      ConfigFile.TypeEnum fileType = file.getType();\n\n      if (fileType.equals(ConfigFile.TypeEnum.TEMPLATE)) {\n        if (StringUtils.isEmpty(file.getSrcFile()) &&\n            !file.getProperties().containsKey(CONTENT)) {\n          throw new IllegalArgumentException(MessageFormat.format(\"For {0} \" +\n                  \"format, either src_file must be specified in ConfigFile,\" +\n                  \" or the \\\"{1}\\\" key must be specified in \" +\n                  \"the 'properties' field of ConfigFile. \",\n              ConfigFile.TypeEnum.TEMPLATE, CONTENT));\n        }\n      } else if (fileType.equals(ConfigFile.TypeEnum.STATIC) || fileType.equals(\n          ConfigFile.TypeEnum.ARCHIVE)) {\n        if (!file.getProperties().isEmpty()) {\n          throw new IllegalArgumentException(String\n              .format(\"For %s format, should not specify any 'properties.'\",\n                  fileType));\n        }\n\n        String srcFile = file.getSrcFile();\n        if (srcFile == null || srcFile.isEmpty()) {\n          throw new IllegalArgumentException(String.format(\n              \"For %s format, should make sure that srcFile is specified\",\n              fileType));\n        }\n        FileStatus fileStatus = fs.getFileStatus(new Path(srcFile));\n        if (fileStatus != null && fileStatus.isDirectory()) {\n          throw new IllegalArgumentException(\"srcFile=\" + srcFile +\n              \" is a directory, which is not supported.\");\n        }\n      }\n      if (!StringUtils.isEmpty(file.getSrcFile())) {\n        Path p = new Path(file.getSrcFile());\n        if (!fs.exists(p)) {\n          throw new IllegalArgumentException(\n              \"Specified src_file does not exist on \" + fs.getScheme() + \": \"\n                  + file.getSrcFile());\n        }\n      }\n\n      if (StringUtils.isEmpty(file.getDestFile())) {\n        throw new IllegalArgumentException(\"dest_file is empty.\");\n      }\n\n      if (destFileSet.contains(file.getDestFile())) {\n        throw new IllegalArgumentException(\n            \"Duplicated ConfigFile exists: \" + file.getDestFile());\n      }\n      destFileSet.add(file.getDestFile());\n\n      java.nio.file.Path destPath = Paths.get(file.getDestFile());\n      if (!destPath.isAbsolute() && destPath.getNameCount() > 1) {\n        throw new IllegalArgumentException(\"Non-absolute dest_file has more \" +\n            \"than one path element\");\n      }\n\n      // provider-specific validation\n      validateConfigFile(file, compName, fs);\n    }\n  }\n}<fim_middle>// class below is blob\n"}