{"text": "<fim_prefix>/**\n * Copyright 2016 LinkedIn Corp. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n */\npackage com.github.ambry.network;\nimport com.codahale.metrics.MetricRegistry;\nimport com.github.ambry.commons.SSLFactory;\nimport com.github.ambry.config.NetworkConfig;\nimport com.github.ambry.config.SSLConfig;\nimport com.github.ambry.utils.ByteBufferInputStream;\nimport com.github.ambry.utils.SystemTime;\nimport com.github.ambry.utils.Time;\nimport com.github.ambry.utils.Utils;\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.SocketException;\nimport java.nio.channels.ClosedChannelException;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n/**\n * A NIO socket server. The threading model is\n *   1 Acceptor thread that handles new connections\n *   N Processor threads that each have their own selector and read requests from sockets\n *   M Handler threads that handle requests and produce responses back to the processor threads for writing.\n */\npublic class SocketServer implements NetworkServer {\n  private final String host;\n  private final int port;\n  private final int numProcessorThreads;\n  private final int maxQueuedRequests;\n  private final int sendBufferSize;\n  private final int recvBufferSize;\n  private final int maxRequestSize;\n  private final ArrayList<Processor> processors;\n  private volatile ArrayList<Acceptor> acceptors;\n  private final SocketRequestResponseChannel requestResponseChannel;\n  private Logger logger = LoggerFactory.getLogger(getClass());\n  private final ServerNetworkMetrics metrics;\n  private final HashMap<PortType, Port> ports;\n  private SSLFactory sslFactory;\n<fim_suffix>  public SocketServer(NetworkConfig config, SSLConfig sslConfig, MetricRegistry registry, ArrayList<Port> portList) {\n    this.host = config.hostName;\n    this.port = config.port;\n    this.numProcessorThreads = config.numIoThreads;\n    this.maxQueuedRequests = config.queuedMaxRequests;\n    this.sendBufferSize = config.socketSendBufferBytes;\n    this.recvBufferSize = config.socketReceiveBufferBytes;\n    this.maxRequestSize = config.socketRequestMaxBytes;\n    processors = new ArrayList<Processor>(numProcessorThreads);\n    requestResponseChannel = new SocketRequestResponseChannel(numProcessorThreads, maxQueuedRequests);\n    metrics = new ServerNetworkMetrics(requestResponseChannel, registry, processors);\n    this.acceptors = new ArrayList<Acceptor>();\n    this.ports = new HashMap<PortType, Port>();\n    this.validatePorts(portList);\n    this.initializeSSLFactory(sslConfig);\n  }\n  public String getHost() {\n    return host;\n  }\n  public int getPort() {\n    return port;\n  }\n  public int getSSLPort() {\n    Port sslPort = ports.get(PortType.SSL);\n    if (sslPort != null) {\n      return sslPort.getPort();\n    }\n    throw new IllegalStateException(\"No SSL Port Exists for Server \" + host + \":\" + port);\n  }\n  private void initializeSSLFactory(SSLConfig sslConfig) {\n    if (ports.get(PortType.SSL) != null) {\n      try {\n        this.sslFactory = SSLFactory.getNewInstance(sslConfig);\n        metrics.sslFactoryInitializationCount.inc();\n      } catch (Exception e) {\n        metrics.sslFactoryInitializationErrorCount.inc();\n        throw new IllegalStateException(\"Exception thrown during initialization of SSLFactory \", e);\n      }\n    }\n  }\n  public int getNumProcessorThreads() {\n    return numProcessorThreads;\n  }\n  public int getMaxQueuedRequests() {\n    return maxQueuedRequests;\n  }\n  public int getSendBufferSize() {\n    return sendBufferSize;\n  }\n  public int getRecvBufferSize() {\n    return recvBufferSize;\n  }\n  public int getMaxRequestSize() {\n    return maxRequestSize;\n  }\n  @Override\n  public RequestResponseChannel getRequestResponseChannel() {\n    return requestResponseChannel;\n  }\n  private void validatePorts(ArrayList<Port> portList) {\n    HashSet<PortType> portTypeSet = new HashSet<PortType>();\n    for (Port port : portList) {\n      if (portTypeSet.contains(port.getPortType())) {\n        throw new IllegalArgumentException(\"Not more than one port of same type is allowed : \" + port.getPortType());\n      } else {\n        portTypeSet.add(port.getPortType());\n        this.ports.put(port.getPortType(), port);\n      }\n    }\n  }\n  public void start() throws IOException, InterruptedException {\n    logger.info(\"Starting {} processor threads\", numProcessorThreads);\n    for (int i = 0; i < numProcessorThreads; i++) {\n      processors.add(i, new Processor(i, maxRequestSize, requestResponseChannel, metrics, sslFactory));\n      Utils.newThread(\"ambry-processor-\" + port + \" \" + i, processors.get(i), false).start();\n    }\n    requestResponseChannel.addResponseListener(new ResponseListener() {\n      @Override\n      public void onResponse(int processorId) {\n        processors.get(processorId).wakeup();\n      }\n    });\n    // start accepting connections\n    logger.info(\"Starting acceptor threads\");\n    Acceptor plainTextAcceptor = new Acceptor(port, processors, sendBufferSize, recvBufferSize, metrics);\n    this.acceptors.add(plainTextAcceptor);\n    Utils.newThread(\"ambry-acceptor\", plainTextAcceptor, false).start();\n    Port sslPort = ports.get(PortType.SSL);\n    if (sslPort != null) {\n      SSLAcceptor sslAcceptor = new SSLAcceptor(sslPort.getPort(), processors, sendBufferSize, recvBufferSize, metrics);\n      acceptors.add(sslAcceptor);\n      Utils.newThread(\"ambry-sslacceptor\", sslAcceptor, false).start();\n    }\n    for (Acceptor acceptor : acceptors) {\n      acceptor.awaitStartup();\n    }\n    logger.info(\"Started server\");\n  }\n  public void shutdown() {\n    try {\n      logger.info(\"Shutting down server\");\n      for (Acceptor acceptor : acceptors) {\n        if (acceptor != null) {\n          acceptor.shutdown();\n        }\n      }\n      for (Processor processor : processors) {\n        processor.shutdown();\n      }\n      logger.info(\"Shutdown completed\");\n    } catch (Exception e) {\n      logger.error(\"Error shutting down socket server {}\", e);\n    }\n  }\n}\n/**\n * A base class with some helper variables and methods\n */\nabstract class AbstractServerThread implements Runnable {\n  private final CountDownLatch startupLatch;\n  private final CountDownLatch shutdownLatch;\n  private final AtomicBoolean alive;\n  protected Logger logger = LoggerFactory.getLogger(getClass());\n  public AbstractServerThread() throws IOException {\n    startupLatch = new CountDownLatch(1);\n    shutdownLatch = new CountDownLatch(1);\n    alive = new AtomicBoolean(false);\n  }\n  /**\n   * Initiates a graceful shutdown by signaling to stop and waiting for the shutdown to complete\n   */\n  public void shutdown() throws InterruptedException {\n    alive.set(false);\n    shutdownLatch.await();\n  }\n  /**\n   * Wait for the thread to completely start up\n   */\n  public void awaitStartup() throws InterruptedException {\n    startupLatch.await();\n  }\n  /**\n   * Record that the thread startup is complete\n   */\n  protected void startupComplete() {\n    alive.set(true);\n    startupLatch.countDown();\n  }\n  /**\n   * Record that the thread shutdown is complete\n   */\n  protected void shutdownComplete() {\n    shutdownLatch.countDown();\n  }\n  /**\n   * Is the server still running?\n   */\n  protected boolean isRunning() {\n    return alive.get();\n  }\n}\n/**\n * Thread that accepts and configures new connections.\n */\nclass Acceptor extends AbstractServerThread {\n  private final ArrayList<Processor> processors;\n  private final int sendBufferSize;\n  private final int recvBufferSize;\n  private final ServerSocketChannel serverChannel;\n  private final java.nio.channels.Selector nioSelector;\n  private static final long selectTimeOutMs = 500;<fim_middle>// function below is long method\n"}