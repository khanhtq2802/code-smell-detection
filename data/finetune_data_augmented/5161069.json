{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n*/\npackage org.apache.kylin.dict;\n\nimport java.util.ArrayList;\n\nimport org.apache.kylin.common.KylinConfig;\nimport org.apache.kylin.common.exceptions.TooBigDictionaryException;\nimport org.apache.kylin.common.util.ByteArray;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Build a trie dictionary forest if the input values is ordered, or the forest falls back to a single trie.\n */\n<fim_suffix>public class TrieDictionaryForestBuilder<T> {\n\n    public static int DEFAULT_MAX_TRIE_TREE_SIZE_MB = 500;\n\n    private static final Logger logger = LoggerFactory.getLogger(TrieDictionaryForestBuilder.class);\n\n    private BytesConverter<T> bytesConverter;\n\n    private int curTreeSize = 0;\n\n    private TrieDictionaryBuilder<T> trieBuilder;\n\n    private ArrayList<TrieDictionary<T>> trees = new ArrayList<>();\n\n    private ArrayList<ByteArray> valueDivide = new ArrayList<>(); //find tree\n\n    private ArrayList<Integer> accuOffset = new ArrayList<>(); //find tree\n\n    private ByteArray previousValue = null; //value use for remove duplicate\n\n    private int baseId;\n\n    private int curOffset;\n\n    private int maxTrieTreeSize;\n\n    private boolean isOrdered = true;\n\n    public TrieDictionaryForestBuilder(BytesConverter<T> bytesConverter) {\n        this(bytesConverter, 0);\n    }\n\n    public TrieDictionaryForestBuilder(BytesConverter<T> bytesConverter, int baseId) {\n        this(bytesConverter, baseId, getMaxTrieSizeInMB());\n    }\n\n    public TrieDictionaryForestBuilder(BytesConverter<T> bytesConverter, int baseId, int maxTrieTreeSizeMB) {\n        this.bytesConverter = bytesConverter;\n        this.trieBuilder = new TrieDictionaryBuilder<T>(bytesConverter);\n        this.baseId = baseId;\n        this.curOffset = 0;\n        this.maxTrieTreeSize = maxTrieTreeSizeMB * 1024 * 1024;\n    }\n\n    public void addValue(T value) {\n        if (value == null)\n            return;\n        byte[] valueBytes = bytesConverter.convertToBytes(value);\n        addValue(valueBytes);\n    }\n\n    private void addValue(byte[] valueBytes) {\n        ByteArray valueByteArray = new ByteArray(valueBytes);\n        if (previousValue != null && isOrdered) {\n            int comp = previousValue.compareTo(valueByteArray);\n            if (comp == 0) {\n                return; //duplicate value\n            }\n            if (comp > 0) {\n                logger.info(\"values not in ascending order, previous '{}', current '{}'\", previousValue, valueByteArray);\n                isOrdered = false;\n                if (trees.size() > 0) {\n                    throw new IllegalStateException(\"Invalid input data. Unordered data cannot be split into multi trees\");\n                }\n            }\n        }\n        previousValue = valueByteArray;\n        trieBuilder.addValue(valueBytes);\n        curTreeSize += valueBytes.length;\n\n        if (curTreeSize >= maxTrieTreeSize && isOrdered) {\n            TrieDictionary<T> tree = trieBuilder.build(0);\n            addTree(tree);\n            reset();\n        }\n    }\n\n    public TrieDictionaryForest<T> build() {\n        if (trieBuilder.isHasValue()) { //last tree\n            TrieDictionary<T> tree = trieBuilder.build(0);\n            addTree(tree);\n            reset();\n        }\n        TrieDictionaryForest<T> forest = new TrieDictionaryForest<T>(this.trees, this.valueDivide, this.accuOffset, this.bytesConverter, baseId);\n        // if input values are not in ascending order and tree num>1,TrieDictionaryForest can not work correctly.\n        if (forest.getTrees().size() > 1 && !isOrdered) {\n            throw new IllegalStateException(\"Invalid input data. Unordered data can not be split into multi trees\");\n        }\n        return forest;\n    }\n\n    public int getMaxTrieTreeSize() {\n        return maxTrieTreeSize;\n    }\n\n    void setMaxTrieTreeSize(int maxTrieTreeSize) {\n        this.maxTrieTreeSize = maxTrieTreeSize;\n        logger.info(\"maxTrieSize is set to:\" + maxTrieTreeSize + \"B\");\n    }\n\n    private void addTree(TrieDictionary<T> tree) {\n        trees.add(tree);\n        int minId = tree.getMinId();\n        accuOffset.add(curOffset);\n        byte[] valueBytes = tree.getValueBytesFromIdWithoutCache(minId);\n        valueDivide.add(new ByteArray(valueBytes, 0, valueBytes.length));\n        curOffset += (tree.getMaxId() + 1);\n        \n        checkDictSize();\n    }\n\n    private void checkDictSize() {\n        // due to the limitation of resource store, no dictionary beyond 2GB is allowed\n        long size = 0;\n        for (TrieDictionary trie : trees) {\n            size += trie.getStorageSizeInBytes();\n        }\n        if (size > TrieDictionaryBuilder._2GB)\n            throw new TooBigDictionaryException(\"Too big dictionary, dictionary cannot be bigger than 2GB\");\n    }\n\n    private void reset() {\n        curTreeSize = 0;\n        trieBuilder = new TrieDictionaryBuilder<T>(bytesConverter);\n    }\n\n    public static int getMaxTrieSizeInMB() {\n        KylinConfig config = null;\n        try {\n            config = KylinConfig.getInstanceFromEnv();\n        } catch (RuntimeException e) {\n            logger.info(\"cannot get KylinConfig from env.Use default setting:\" + DEFAULT_MAX_TRIE_TREE_SIZE_MB + \"MB\");\n        }\n        int maxTrieTreeSizeMB;\n        if (config != null) {\n            maxTrieTreeSizeMB = config.getTrieDictionaryForestMaxTrieSizeMB();\n        } else {\n            maxTrieTreeSizeMB = DEFAULT_MAX_TRIE_TREE_SIZE_MB;\n        }\n        return maxTrieTreeSizeMB;\n    }\n\n}<fim_middle>// class below has no smell\n"}