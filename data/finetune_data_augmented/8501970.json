{"text": "<fim_prefix>\n<fim_suffix>public class ServerFormatListPDU extends BaseElement {\n    protected ClipboardState state;\n    public ServerFormatListPDU(String id, ClipboardState state) {\n        super(id);\n        this.state = state;\n    }\n    @Override\n    public void handleData(ByteBuffer buf, Link link) {\n        if (verbose)\n            System.out.println(\"[\" + this + \"] INFO: Data received: \" + buf + \".\");\n        parseFormatNames(buf);\n        buf.unref();\n        // Automatically send request for text-based data to insert it into local\n        // clipboard\n        ClipboardDataFormat textFormat = ClipboardDataFormat.findBestTextFormat(state.serverClipboardDataFormats);\n        if (textFormat != null) {\n            // Send response: OK\n            sendFormatListParseResponse(true);\n            // Request data\n            sendFormatDataRequest(textFormat);\n        } else {\n            // Send response: FAIL, we are not interested in this data\n            sendFormatListParseResponse(false);\n        }\n    }\n    /**\n     * The Format Data Request PDU is sent by the recipient of the Format List\n     * PDU. It is used to request the data for one of the formats that was listed\n     * in the Format List PDU.\n     */\n    protected void sendFormatDataRequest(ClipboardDataFormat textFormat) {\n        if (verbose)\n            System.out.println(\"[\" + this + \"] INFO: Sending request for data in following format: \" + textFormat + \".\");\n        // Store data format to parse server response later\n        state.serverRequestedFormat = textFormat;\n        ByteBuffer buf = new ByteBuffer(12, true);\n        // Type\n        buf.writeShortLE(ServerClipRdrChannelRouter.CB_FORMAT_DATA_REQUEST);\n        // Message flags\n        buf.writeShortLE(0);\n        // Length\n        buf.writeIntLE(4);\n        // ID of chosen format\n        buf.writeIntLE(textFormat.id);\n        buf.trimAtCursor();\n        pushDataToPad(STDOUT, buf);\n    }\n    /**\n     * The Format List Response PDU is sent as a reply to the Format List PDU. It\n     * is used to indicate whether processing of the Format List PDU was\n     * successful.\n     *\n     * @param b\n     */\n    protected void sendFormatListParseResponse(boolean ok) {\n        ByteBuffer buf = new ByteBuffer(8, true);\n        // Type\n        buf.writeShortLE(ServerClipRdrChannelRouter.CB_FORMAT_LIST_RESPONSE);\n        // Message flags\n        buf.writeShortLE((ok) ? ServerClipRdrChannelRouter.CB_RESPONSE_OK : ServerClipRdrChannelRouter.CB_RESPONSE_FAIL);\n        // Length\n        buf.writeIntLE(0);\n        buf.trimAtCursor();\n        pushDataToPad(STDOUT, buf);\n    }\n    protected void parseFormatNames(ByteBuffer buf) {\n        // Set will not be modified after creation, so there is no need to make it\n        // synchronous.\n        Map<Object, ClipboardDataFormat> formats = new HashMap<Object, ClipboardDataFormat>();\n        while (buf.cursor < buf.length) {\n            int id = buf.readSignedIntLE();\n            String name;\n            if (state.serverUseLongFormatNames) {\n                // Long format names in Unicode\n                name = buf.readVariableWideString(RdpConstants.CHARSET_16);\n            } else {\n                Boolean asciiNames = (Boolean)buf.getMetadata(ServerClipRdrChannelRouter.ASCII_NAMES);\n                if (asciiNames != null && asciiNames) {\n                    // Short format names in ASCII\n                    name = buf.readString(32, RdpConstants.CHARSET_8);\n                } else {\n                    // Short format names in Unicode\n                    name = buf.readString(32, RdpConstants.CHARSET_16);\n                }\n            }\n            // Store format in map by both ID and name (if name is not empty)\n            formats.put(id, new ClipboardDataFormat(id, name));\n            if (name.length() > 0)\n                formats.put(name, new ClipboardDataFormat(id, name));\n        }\n        if (verbose)\n            System.out.println(\"Server supports following formats for clipboard data: \" + formats.values().toString() + \".\");\n        state.serverClipboardDataFormats = formats;\n    }\n    /**\n     * Example.\n     */\n    public static void main(String[] args) {\n        // System.setProperty(\"streamer.Link.debug\", \"true\");\n        System.setProperty(\"streamer.Element.debug\", \"true\");\n        // System.setProperty(\"streamer.Pipeline.debug\", \"true\");\n        /* @formatter:off */\n        byte[] packet = new byte[] {\n                0x02, 0x00,  //  CLIPRDR_HEADER::msgType = CB_FORMAT_LIST (2)\n                0x00, 0x00,  //  CLIPRDR_HEADER::msgFlags = 0\n                (byte) 0xe0, 0x00, 0x00, 0x00,  //  CLIPRDR_HEADER::dataLen = 0xe0 = 224 bytes\n                (byte) 0x8a, (byte) 0xc0, 0x00, 0x00,  //  CLIPRDR_LONG_FORMAT_NAME::formatId = 0xc08a = 49290\n                0x52, 0x00, 0x69, 0x00, 0x63, 0x00, 0x68, 0x00, 0x20, 0x00, 0x54, 0x00, 0x65, 0x00, 0x78, 0x00, 0x74, 0x00, 0x20, 0x00, 0x46, 0x00, 0x6f, 0x00, 0x72, 0x00, 0x6d, 0x00, 0x61, 0x00, 0x74, 0x00, 0x00, 0x00,  //  CLIPRDR_LONG_FORMAT_NAME::formatName = \"Rich Text Format\"\n                0x45, (byte) 0xc1, 0x00, 0x00,  //  CLIPRDR_LONG_FORMAT_NAME::formatId = 0xc145 = 49477\n                0x52, 0x00, 0x69, 0x00, 0x63, 0x00, 0x68, 0x00, 0x20, 0x00, 0x54, 0x00, 0x65, 0x00, 0x78, 0x00,\n                0x74, 0x00, 0x20, 0x00, 0x46, 0x00, 0x6f, 0x00, 0x72, 0x00, 0x6d, 0x00, 0x61, 0x00, 0x74, 0x00,\n                0x20, 0x00, 0x57, 0x00, 0x69, 0x00, 0x74, 0x00, 0x68, 0x00, 0x6f, 0x00, 0x75, 0x00, 0x74, 0x00,\n                0x20, 0x00, 0x4f, 0x00, 0x62, 0x00, 0x6a, 0x00, 0x65, 0x00, 0x63, 0x00, 0x74, 0x00, 0x73, 0x00,\n                0x00, 0x00,  //  CLIPRDR_LONG_FORMAT_NAME::formatName = \"Rich Text Format Without Objects\"\n                0x43, (byte) 0xc1, 0x00, 0x00,  //  CLIPRDR_LONG_FORMAT_NAME::formatId = 0xc143 = 49475<fim_middle>// class below is blob\n"}