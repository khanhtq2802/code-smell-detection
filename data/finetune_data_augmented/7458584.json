{"text": "<fim_prefix>                deepNodeCount += profile.getDeepNodeCount();\n            }\n        }\n        return callSites;\n    }\n    public int getInlinedNodeCount() {\n        int sum = 0;\n        for (TruffleInliningDecision callSite : getCallSites()) {\n            if (callSite.shouldInline()) {\n                sum += callSite.getProfile().getDeepNodeCount();\n            }\n        }\n        return sum;\n    }\n    public int countCalls() {\n        int sum = 0;\n        for (TruffleInliningDecision callSite : getCallSites()) {\n            sum += callSite.shouldInline() ? callSite.countCalls() + 1 : 1;\n        }\n        return sum;\n    }\n    public int countInlinedCalls() {\n        int sum = 0;\n        for (TruffleInliningDecision callSite : getCallSites()) {\n            if (callSite.shouldInline()) {\n                sum += callSite.countInlinedCalls() + 1;\n            }\n        }\n        return sum;\n    }\n    public final List<TruffleInliningDecision> getCallSites() {\n        return callSites;\n    }\n    @Override\n    public Iterator<TruffleInliningDecision> iterator() {\n        return callSites.iterator();\n    }\n    @Override\n    public Decision findDecision(JavaConstant callNodeConstant) {\n        OptimizedDirectCallNode callNode = runtime().asObject(OptimizedDirectCallNode.class, callNodeConstant);\n        return findByCall(callNode);\n    }\n    static class TruffleSourceLanguagePosition implements org.graalvm.compiler.truffle.common.TruffleSourceLanguagePosition {\n        private final SourceSection sourceSection;\n        TruffleSourceLanguagePosition(SourceSection section) {\n            this.sourceSection = section;\n        }\n        @Override\n        public String getDescription() {\n            return sourceSection.getSource().getURI() + \" \" + sourceSection.getStartLine() + \":\" + sourceSection.getStartColumn();\n        }\n        @Override\n        public int getOffsetEnd() {\n            return sourceSection.getCharEndIndex();\n        }\n        @Override\n        public int getOffsetStart() {\n            return sourceSection.getCharIndex();\n        }\n        @Override\n        public int getLineNumber() {\n            return sourceSection.getStartLine();\n        }\n        @Override\n        public URI getURI() {\n            return sourceSection.getSource().getURI();\n        }\n        @Override\n        public String getLanguage() {\n            return sourceSection.getSource().getLanguage();\n        }\n    }\n    @Override\n    public org.graalvm.compiler.truffle.common.TruffleSourceLanguagePosition getPosition(JavaConstant node) {\n        Node truffleNode = runtime().asObject(Node.class, node);\n        if (truffleNode == null) {\n            return null;\n        }\n        SourceSection section = null;\n        if (truffleNode instanceof DirectCallNode) {\n            section = ((DirectCallNode) truffleNode).getCurrentRootNode().getSourceSection();\n        }\n        if (section == null) {\n            section = truffleNode.getSourceSection();\n        }\n        if (section == null) {\n            Node cur = truffleNode.getParent();\n            while (cur != null) {\n                section = cur.getSourceSection();\n                if (section != null) {\n                    break;\n                }\n                cur = cur.getParent();\n            }\n        }\n        if (section != null) {\n            return new TruffleSourceLanguagePosition(section);\n        }\n        return null;\n    }\n    public TruffleInliningDecision findByCall(OptimizedDirectCallNode callNode) {\n        for (TruffleInliningDecision d : getCallSites()) {\n            if (d.getProfile().getCallNode() == callNode) {\n                return d;\n            }\n        }\n        return null;\n    }\n    /**\n     * Visits all nodes of the {@link CallTarget} and all of its inlined calls.\n     */\n    public void accept(OptimizedCallTarget target, NodeVisitor visitor) {\n        target.getRootNode().accept(new CallTreeNodeVisitorImpl(visitor));\n    }\n    /**\n     * Creates an iterator for all nodes of the {@link CallTarget} and all of its inlined calls.\n     */\n    public Iterator<Node> makeNodeIterator(OptimizedCallTarget target) {\n        return new CallTreeNodeIterator(target);\n    }\n    /**\n     * This visitor extends the {@link NodeVisitor} interface to be usable for traversing the full\n     * call tree.\n     */\n    public interface CallTreeNodeVisitor extends NodeVisitor {\n        boolean visit(List<TruffleInlining> decisionStack, Node node);\n        @Override\n        default boolean visit(Node node) {\n            return visit(null, node);\n        }\n        static int getNodeDepth(List<TruffleInlining> decisionStack, Node node) {\n            int depth = calculateNodeDepth(node);\n            if (decisionStack != null) {\n                for (int i = decisionStack.size() - 1; i > 0; i--) {\n                    TruffleInliningDecision decision = (TruffleInliningDecision) decisionStack.get(i);\n                    depth += calculateNodeDepth(decision.getProfile().getCallNode());\n                }\n            }\n            return depth;\n        }\n        static int calculateNodeDepth(Node node) {\n            int depth = 0;\n            Node traverseNode = node;\n            while (traverseNode != null) {\n                depth++;\n                traverseNode = traverseNode.getParent();\n            }\n            return depth;\n        }\n        static TruffleInliningDecision getCurrentInliningDecision(List<TruffleInlining> decisionStack) {\n            if (decisionStack == null || decisionStack.size() <= 1) {\n                return null;\n            }\n            return (TruffleInliningDecision) decisionStack.get(decisionStack.size() - 1);\n        }\n    }\n    /**\n     * This visitor wraps an existing {@link NodeVisitor} or {@link CallTreeNodeVisitor} and\n     * traverses the full Truffle tree including inlined call sites.\n     */\n    private final class CallTreeNodeVisitorImpl implements NodeVisitor {\n        protected final List<TruffleInlining> stack = new ArrayList<>();\n        private final NodeVisitor visitor;\n        private boolean continueTraverse = true;\n        CallTreeNodeVisitorImpl(NodeVisitor visitor) {\n            stack.add(TruffleInlining.this);\n            this.visitor = visitor;\n        }\n        @Override\n        public boolean visit(Node node) {\n            if (node instanceof OptimizedDirectCallNode) {\n                OptimizedDirectCallNode callNode = (OptimizedDirectCallNode) node;\n                TruffleInlining inlining = stack.get(stack.size() - 1);\n                if (inlining != null) {\n                    TruffleInliningDecision childInlining = inlining.findByCall(callNode);\n                    if (childInlining != null) {\n                        stack.add(childInlining);\n                        continueTraverse = visitNode(node);\n                        if (continueTraverse && childInlining.shouldInline()) {\n                            childInlining.getTarget().getRootNode().accept(this);\n                        }\n                        stack.remove(stack.size() - 1);\n                    }\n                }\n                return continueTraverse;\n            } else {\n                continueTraverse = visitNode(node);\n                return continueTraverse;\n            }\n        }\n        private boolean visitNode(Node node) {\n            if (visitor instanceof CallTreeNodeVisitor) {\n                return ((CallTreeNodeVisitor) visitor).visit(stack, node);\n            } else {\n                return visitor.visit(node);\n            }\n        }\n    }\n    private final class CallTreeNodeIterator implements Iterator<Node> {\n        private List<TruffleInlining> inliningDecisionStack = new ArrayList<>();\n        private List<Iterator<Node>> iteratorStack = new ArrayList<>();\n        CallTreeNodeIterator(OptimizedCallTarget target) {\n            inliningDecisionStack.add(TruffleInlining.this);\n            iteratorStack.add(NodeUtil.makeRecursiveIterator(target.getRootNode()));\n        }\n        @Override\n        public boolean hasNext() {\n            return peekIterator() != null;\n        }\n        @Override\n        public Node next() {\n            Iterator<Node> iterator = peekIterator();\n            if (iterator == null) {\n                throw new NoSuchElementException();\n            }\n            Node node = iterator.next();\n            if (node instanceof OptimizedDirectCallNode) {\n                visitInlinedCall(node);\n            }\n            return node;\n        }\n        private void visitInlinedCall(Node node) {\n            TruffleInlining currentDecision = inliningDecisionStack.get(inliningDecisionStack.size() - 1);\n            if (currentDecision == null) {\n                return;\n            }\n            TruffleInliningDecision decision = currentDecision.findByCall((OptimizedDirectCallNode) node);\n            if (decision != null && decision.shouldInline()) {\n                inliningDecisionStack.add(decision);\n                iteratorStack.add(NodeUtil.makeRecursiveIterator(decision.getTarget().getRootNode()));\n            }\n        }\n        private Iterator<Node> peekIterator() {\n            int tos = iteratorStack.size() - 1;\n            while (tos >= 0) {\n                Iterator<Node> iterable = iteratorStack.get(tos);\n                if (iterable.hasNext()) {\n                    return iterable;\n                } else {\n                    iteratorStack.remove(tos);\n                    inliningDecisionStack.remove(tos--);\n                }\n            }\n            return null;\n        }\n<fim_suffix>        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }<fim_middle>// function below has no smell\n"}