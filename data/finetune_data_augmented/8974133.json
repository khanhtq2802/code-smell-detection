{"text": "<fim_prefix>   * @throws IOException if an I/O error occurred.\n   */\n  public abstract void addSortedNumericField(FieldInfo field, DocValuesProducer valuesProducer) throws IOException;\n  /**\n   * Writes pre-sorted set docvalues for a field\n   * @param field field information\n   * @param valuesProducer produces the values to write\n   * @throws IOException if an I/O error occurred.\n   */\n  public abstract void addSortedSetField(FieldInfo field, DocValuesProducer valuesProducer) throws IOException;\n  /** Merges in the fields from the readers in \n   *  <code>mergeState</code>. The default implementation \n   *  calls {@link #mergeNumericField}, {@link #mergeBinaryField},\n   *  {@link #mergeSortedField}, {@link #mergeSortedSetField},\n   *  or {@link #mergeSortedNumericField} for each field,\n   *  depending on its type.\n   *  Implementations can override this method \n   *  for more sophisticated merging (bulk-byte copying, etc). */\n  public void merge(MergeState mergeState) throws IOException {\n    for(DocValuesProducer docValuesProducer : mergeState.docValuesProducers) {\n      if (docValuesProducer != null) {\n        docValuesProducer.checkIntegrity();\n      }\n    }\n    for (FieldInfo mergeFieldInfo : mergeState.mergeFieldInfos) {\n      DocValuesType type = mergeFieldInfo.getDocValuesType();\n      if (type != DocValuesType.NONE) {\n        if (type == DocValuesType.NUMERIC) {\n          mergeNumericField(mergeFieldInfo, mergeState);\n        } else if (type == DocValuesType.BINARY) {\n          mergeBinaryField(mergeFieldInfo, mergeState);\n        } else if (type == DocValuesType.SORTED) {\n          mergeSortedField(mergeFieldInfo, mergeState);\n        } else if (type == DocValuesType.SORTED_SET) {\n          mergeSortedSetField(mergeFieldInfo, mergeState);\n        } else if (type == DocValuesType.SORTED_NUMERIC) {\n          mergeSortedNumericField(mergeFieldInfo, mergeState);\n        } else {\n          throw new AssertionError(\"type=\" + type);\n        }\n      }\n    }\n  }\n  /** Tracks state of one numeric sub-reader that we are merging */\n  private static class NumericDocValuesSub extends DocIDMerger.Sub {\n    final NumericDocValues values;\n    public NumericDocValuesSub(MergeState.DocMap docMap, NumericDocValues values) {\n      super(docMap);\n      this.values = values;\n      assert values.docID() == -1;\n    }\n    @Override\n    public int nextDoc() throws IOException {\n      return values.nextDoc();\n    }\n  }\n  /**\n   * Merges the numeric docvalues from <code>MergeState</code>.\n   * <p>\n   * The default implementation calls {@link #addNumericField}, passing\n   * a DocValuesProducer that merges and filters deleted documents on the fly.\n   */\n  public void mergeNumericField(final FieldInfo mergeFieldInfo, final MergeState mergeState) throws IOException {\n    addNumericField(mergeFieldInfo,\n                    new EmptyDocValuesProducer() {\n                      @Override\n                      public NumericDocValues getNumeric(FieldInfo fieldInfo) throws IOException {\n                        if (fieldInfo != mergeFieldInfo) {\n                          throw new IllegalArgumentException(\"wrong fieldInfo\");\n                        }\n                        List<NumericDocValuesSub> subs = new ArrayList<>();\n                        assert mergeState.docMaps.length == mergeState.docValuesProducers.length;\n                        long cost = 0;\n                        for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n                          NumericDocValues values = null;\n                          DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n                          if (docValuesProducer != null) {\n                            FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(mergeFieldInfo.name);\n                            if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.NUMERIC) {\n                              values = docValuesProducer.getNumeric(readerFieldInfo);\n                            }\n                          }\n                          if (values != null) {\n                            cost += values.cost();\n                            subs.add(new NumericDocValuesSub(mergeState.docMaps[i], values));\n                          }\n                        }\n                        final DocIDMerger<NumericDocValuesSub> docIDMerger = DocIDMerger.of(subs, mergeState.needsIndexSort);\n                        final long finalCost = cost;\n                        return new NumericDocValues() {\n                          private int docID = -1;\n                          private NumericDocValuesSub current;\n                          @Override\n                          public int docID() {\n                            return docID;\n                          }\n                          @Override\n                          public int nextDoc() throws IOException {\n                            current = docIDMerger.next();\n                            if (current == null) {\n                              docID = NO_MORE_DOCS;\n                            } else {\n                              docID = current.mappedDocID;\n                            }\n                            return docID;\n                          }\n                          @Override\n                          public int advance(int target) throws IOException {\n                            throw new UnsupportedOperationException();\n                          }\n                          @Override\n                          public boolean advanceExact(int target) throws IOException {\n                            throw new UnsupportedOperationException();\n                          }\n                          @Override\n                          public long cost() {\n                            return finalCost;\n                          }\n                          @Override\n                          public long longValue() throws IOException {\n                            return current.values.longValue();\n                          }\n                        };\n                      }\n                    });\n  }\n  /** Tracks state of one binary sub-reader that we are merging */\n  private static class BinaryDocValuesSub extends DocIDMerger.Sub {\n    final BinaryDocValues values;\n    public BinaryDocValuesSub(MergeState.DocMap docMap, BinaryDocValues values) {\n      super(docMap);\n      this.values = values;\n      assert values.docID() == -1;\n    }\n    @Override\n    public int nextDoc() throws IOException {\n      return values.nextDoc();\n    }\n  }\n  /**\n   * Merges the binary docvalues from <code>MergeState</code>.\n   * <p>\n   * The default implementation calls {@link #addBinaryField}, passing\n   * a DocValuesProducer that merges and filters deleted documents on the fly.\n   */\n  public void mergeBinaryField(FieldInfo mergeFieldInfo, final MergeState mergeState) throws IOException {\n    addBinaryField(mergeFieldInfo,\n                   new EmptyDocValuesProducer() {\n                     @Override\n                     public BinaryDocValues getBinary(FieldInfo fieldInfo) throws IOException {\n                       if (fieldInfo != mergeFieldInfo) {\n                         throw new IllegalArgumentException(\"wrong fieldInfo\");\n                       }\n                       List<BinaryDocValuesSub> subs = new ArrayList<>();\n                       long cost = 0;\n                       for (int i=0;i<mergeState.docValuesProducers.length;i++) {\n                         BinaryDocValues values = null;\n                         DocValuesProducer docValuesProducer = mergeState.docValuesProducers[i];\n                         if (docValuesProducer != null) {\n                           FieldInfo readerFieldInfo = mergeState.fieldInfos[i].fieldInfo(mergeFieldInfo.name);\n                           if (readerFieldInfo != null && readerFieldInfo.getDocValuesType() == DocValuesType.BINARY) {\n                             values = docValuesProducer.getBinary(readerFieldInfo);\n                           }\n                         }\n                         if (values != null) {\n                           cost += values.cost();\n                           subs.add(new BinaryDocValuesSub(mergeState.docMaps[i], values));\n                         }\n                       }\n                       final DocIDMerger<BinaryDocValuesSub> docIDMerger = DocIDMerger.of(subs, mergeState.needsIndexSort);\n                       final long finalCost = cost;\n                       return new BinaryDocValues() {\n                         private BinaryDocValuesSub current;\n                         private int docID = -1;\n                         @Override\n                         public int docID() {\n                           return docID;\n                         }\n                         @Override\n                         public int nextDoc() throws IOException {\n                           current = docIDMerger.next();\n                           if (current == null) {\n                             docID = NO_MORE_DOCS;\n                           } else {\n                             docID = current.mappedDocID;\n                           }\n                           return docID;\n                         }\n                         @Override\n                         public int advance(int target) throws IOException {\n                           throw new UnsupportedOperationException();\n                         }\n                         @Override\n                         public boolean advanceExact(int target) throws IOException {\n                           throw new UnsupportedOperationException();\n                         }\n                         @Override\n                         public long cost() {\n                           return finalCost;\n                         }\n                         @Override\n                         public BytesRef binaryValue() throws IOException {\n                           return current.values.binaryValue();\n                         }\n                       };\n                     }\n                   });\n  }\n  /** Tracks state of one sorted numeric sub-reader that we are merging */\n<fim_suffix>  private static class SortedNumericDocValuesSub extends DocIDMerger.Sub {\n    final SortedNumericDocValues values;\n    public SortedNumericDocValuesSub(MergeState.DocMap docMap, SortedNumericDocValues values) {\n      super(docMap);\n      this.values = values;\n      assert values.docID() == -1;\n    }\n    @Override\n    public int nextDoc() throws IOException {\n      return values.nextDoc();\n    }\n  }<fim_middle>// class below has no smell\n"}