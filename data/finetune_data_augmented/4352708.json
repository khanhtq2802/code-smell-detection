{"text": "<fim_prefix> * NormalizeResultSetNode instead of to the UnionNode.\n * \n * After this, we go back to UnionNode.addNewNodes() where we see the following:\n * \n *\n *  treeTop = (ResultSetNode) getNodeFactory().getNode(\n *                   C_NodeTypes.DISTINCT_NODE,\n *                   treeTop.genProjectRestrict(),\n *                   Boolean.FALSE,\n *                   tableProperties,\n *                   getContextManager());\n *\n *\n * I.e. we have to generate a DistinctNode to eliminate duplicates because the query \n * specified UNION, not UNION ALL.\n * \n * Note the call to treeTop.genProjectRestrict().  Since NormalizeResultSetNode \n * now sits on top of the UnionNode, treeTop is a reference to the \n * NormalizeResultSetNode.  That means we end up at the genProjectRestrict() \n * method of NormalizeResultSetNode.  And guess what?  The method does \n * something very similar to what we did in NormalizeResultSetNode.init(), \n * namely:\n *\n *   ResultColumnList prRCList = resultColumns;\n *   resultColumns = resultColumns.copyListAndObjects();\n *\n * and then creates a ProjectRestrictNode whose result column list is prRCList.  This gives us:\n *\n *                     PRN0\n *                    (RCL0)\n *             (restriction: a > 28 {RCL1})\n *                       |\n *                     PRN6\n *                    (RCL1)              // RCL1 \"pulled up\" to new PRN.\n *                       |\n *             NormalizeResultSetNode\n *                    (RCL3)              // RCL3 is a (modified) copy of RCL1\n *                       |\n *                   UnionNode\n *                     (RCL2)             // RCL2 is a (modified) copy of RCL1\n *                    /      \\\n *                  PRN2     PRN3\n *                    |        |\n *                  PRN4     PRN5\n *                    |        |\n *                    T1       T1\n *\n * On top of that we then put a DistinctNode.  And since the init() method \n * of DistinctNode does the same kind of thing as the previously-discussed \n * methods, we ultimatley end up with:\n *\n *                     PRN0\n *                     (RCL0)\n *             (restriction: a > 28 {RCL1})\n *                       |\n *                  DistinctNode\n *                    (RCL1)              // RCL1 pulled up to DistinctNode\n *                       |\n *                     PRN6\n *                    (RCL4)              // RCL4 is a (modified) copy of RCL1\n *                       |\n *             NormalizeResultSetNode\n *                    (RCL3)              // RCL3 is a (modified) copy of RCL1\n *                       |\n *                   UnionNode\n *                     (RCL2)             // RCL2 is a (modified) copy of RCL1\n *                    /      \\\n *                  PRN2     PRN3\n *                    |        |\n *                  PRN4     PRN5\n *                    |        |\n *                    T1       T1\n *\n * And thus the predicate a > 28, which (still) points to RCL1, is now \n * pointing to the DistinctNode instead of to the UnionNode. And this \n * is what we want: i.e. we want the predicate a > 28 to be applied \n * to the rows that we retrieve from the node at the *top* of the \n * subtree generated for the UnionNode. It is the non-intuitive code \n * in the normalize node creation that allows this to happen.\n *\n *\n */\nclass NormalizeResultSetNode extends SingleChildResultSetNode\n{\n\t/**\n\t * this indicates if the normalize is being performed for an Update\n\t * statement or not. The row passed to update also has\n\t * before values of the columns being updated-- we need not \n\t * normalize these values. \n\t */\n\tprivate boolean forUpdate;\n\t/**\n     * Constructor  for a NormalizeResultSetNode.\n     * ColumnReferences must continue to point to the same ResultColumn, so\n\t * that ResultColumn must percolate up to the new PRN.  However,\n\t * that ResultColumn will point to a new expression, a VirtualColumnNode, \n\t * which points to the FromTable and the ResultColumn that is the source for\n\t * the ColumnReference.  \n\t * (The new NRSN will have the original of the ResultColumnList and\n\t * the ResultColumns from that list.  The FromTable will get shallow copies\n\t * of the ResultColumnList and its ResultColumns.  ResultColumn.expression\n\t * will remain at the FromTable, with the PRN getting a new \n\t * VirtualColumnNode for each ResultColumn.expression.)\n\t *\n\t * This is useful for UNIONs, where we want to generate a DistinctNode above\n\t * the UnionNode to eliminate the duplicates, because the type going into the\n\t * sort has to agree with what the sort expects.\n\t * (insert into t1 (smallintcol) values 1 union all values 2;\n\t *\n     * @param chldRes   The child ResultSetNode\n     * @param targetResultColumnList The target resultColumnList from \n     *                          the InsertNode or UpdateNode. These will\n     *                          be the types used for the NormalizeResultSetNode.\n\t * @param tableProperties\tProperties list associated with the table\n\t * @param forUpdate \ttells us if the normalize operation is being\n\t * performed on behalf of an update statement. \n     * @param cm                The context manager\n\t * @throws StandardException \n\t */\n<fim_suffix>    NormalizeResultSetNode(ResultSetNode chldRes,\n                           ResultColumnList targetResultColumnList,\n                           Properties tableProperties,\n                           boolean forUpdate,\n                           ContextManager cm) throws StandardException\n\t{\n        super(chldRes, tableProperties, cm);\n        this.forUpdate = forUpdate;\n        ResultColumnList rcl = chldRes.getResultColumns();\n        ResultColumnList targetRCL = targetResultColumnList;\n\t\t/* We get a shallow copy of the ResultColumnList and its \n\t\t * ResultColumns.  (Copy maintains ResultColumn.expression for now.)\n\t\t * \n\t\t * Setting this.resultColumns to the modified child result column list,\n\t\t * and making a new copy for the child result set node\n\t\t * ensures that the ProjectRestrictNode restrictions still points to \n\t\t * the same list.  See d3494_npe_writeup-4.html in DERBY-3494 for a\n\t\t * detailed explanation of how this works.\n\t\t */\n\t\tResultColumnList prRCList = rcl;\n        chldRes.setResultColumns(rcl.copyListAndObjects());\n\t\t// Remove any columns that were generated.\n\t\tprRCList.removeGeneratedGroupingColumns();\n        // And also columns that were added for ORDER BY (DERBY-6006).\n        prRCList.removeOrderByColumns();\n\t\t/* Replace ResultColumn.expression with new VirtualColumnNodes\n\t\t * in the NormalizeResultSetNode's ResultColumnList.  (VirtualColumnNodes include\n\t\t * pointers to source ResultSetNode, rsn, and source ResultColumn.)\n\t\t */\n        prRCList.genVirtualColumnNodes(chldRes, chldRes.getResultColumns());\n\t\tsetResultColumns( prRCList );\n\t\t// Propagate the referenced table map if it's already been created\n        if (chldRes.getReferencedTableMap() != null)\n\t\t    {\n\t\t\tsetReferencedTableMap((JBitSet) getReferencedTableMap().clone());\n\t\t    }\n\t\tif (targetResultColumnList != null) {\n\t\t    int size = Math.min(targetRCL.size(), getResultColumns().size());\n            for (int index = 0; index < size; index++) {\n                ResultColumn sourceRC = getResultColumns().elementAt(index);\n                ResultColumn resultColumn = targetRCL.elementAt(index);\n                sourceRC.setType(resultColumn.getTypeServices());\n\t\t    }\n\t\t}\n\t}<fim_middle>// function below is feature envy\n"}