{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.solr.update;\nimport java.io.IOException;\nimport java.lang.invoke.MethodHandles;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.function.Supplier;\nimport com.codahale.metrics.Counter;\nimport com.codahale.metrics.Timer;\nimport org.apache.http.client.HttpClient;\nimport org.apache.solr.client.solrj.SolrRequest;\nimport org.apache.solr.client.solrj.SolrServerException;\nimport org.apache.solr.client.solrj.impl.HttpSolrClient;\nimport org.apache.solr.client.solrj.request.QueryRequest;\nimport org.apache.solr.client.solrj.response.QueryResponse;\nimport org.apache.solr.cloud.ZkController;\nimport org.apache.solr.common.SolrException;\nimport org.apache.solr.common.params.ModifiableSolrParams;\nimport org.apache.solr.common.util.NamedList;\nimport org.apache.solr.core.SolrCore;\nimport org.apache.solr.core.SolrInfoBean;\nimport org.apache.solr.logging.MDCLoggingContext;\nimport org.apache.solr.metrics.SolrMetricManager;\nimport org.apache.solr.metrics.SolrMetricProducer;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport static org.apache.solr.common.params.CommonParams.DISTRIB;\nimport static org.apache.solr.update.PeerSync.MissedUpdatesRequest;\nimport static org.apache.solr.update.PeerSync.absComparator;\nimport static org.apache.solr.update.PeerSync.percentile;\npublic class PeerSyncWithLeader implements SolrMetricProducer {\n  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n  private boolean debug = log.isDebugEnabled();\n  private String leaderUrl;\n  private int nUpdates;\n  private UpdateHandler uhandler;\n  private UpdateLog ulog;\n  private HttpSolrClient clientToLeader;\n  private boolean doFingerprint;\n  private SolrCore core;\n  private PeerSync.Updater updater;\n  private MissedUpdatesFinder missedUpdatesFinder;\n  private Set<Long> bufferedUpdates;\n  // metrics\n  private Timer syncTime;\n  private Counter syncErrors;\n  private Counter syncSkipped;\n<fim_suffix>  public PeerSyncWithLeader(SolrCore core, String leaderUrl, int nUpdates) {\n    this.core = core;\n    this.leaderUrl = leaderUrl;\n    this.nUpdates = nUpdates;\n    this.doFingerprint = !\"true\".equals(System.getProperty(\"solr.disableFingerprint\"));\n    this.uhandler = core.getUpdateHandler();\n    this.ulog = uhandler.getUpdateLog();\n    HttpClient httpClient = core.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient();\n    this.clientToLeader = new HttpSolrClient.Builder(leaderUrl).withHttpClient(httpClient).build();\n    this.updater = new PeerSync.Updater(msg(), core);\n    core.getCoreMetricManager().registerMetricProducer(SolrInfoBean.Category.REPLICATION.toString(), this);\n  }\n  public static final String METRIC_SCOPE = \"peerSync\";\n  @Override\n  public void initializeMetrics(SolrMetricManager manager, String registry, String tag, String scope) {\n    syncTime = manager.timer(null, registry, \"time\", scope, METRIC_SCOPE);\n    syncErrors = manager.counter(null, registry, \"errors\", scope, METRIC_SCOPE);\n    syncSkipped = manager.counter(null, registry, \"skipped\", scope, METRIC_SCOPE);\n  }\n  // start of peersync related debug messages.  includes the core name for correlation.\n  private String msg() {\n    ZkController zkController = uhandler.core.getCoreContainer().getZkController();\n    String myURL = \"\";\n    if (zkController != null) {\n      myURL = zkController.getBaseUrl();\n    }\n    return \"PeerSync: core=\"+uhandler.core.getName()+ \" url=\"+myURL +\" \";\n  }\n  /**\n   * Sync with leader\n   * @param startingVersions : recent versions on startup\n   * @return result of PeerSync with leader\n   */\n  public PeerSync.PeerSyncResult sync(List<Long> startingVersions){\n    if (ulog == null) {\n      syncErrors.inc();\n      return PeerSync.PeerSyncResult.failure();\n    }\n    if (startingVersions.isEmpty()) {\n      log.warn(\"no frame of reference to tell if we've missed updates\");\n      syncErrors.inc();\n      return PeerSync.PeerSyncResult.failure();\n    }\n    MDCLoggingContext.setCore(core);\n    Timer.Context timerContext = null;\n    try {\n      log.info(msg() + \"START leader=\" + leaderUrl + \" nUpdates=\" + nUpdates);\n      if (debug) {\n        log.debug(msg() + \"startingVersions=\" + startingVersions.size() + \" \" + startingVersions);\n      }\n      // check if we already in sync to begin with\n      if(doFingerprint && alreadyInSync()) {\n        syncSkipped.inc();\n        return PeerSync.PeerSyncResult.success();\n      }\n      // measure only when actual sync is performed\n      timerContext = syncTime.time();\n      List<Long> ourUpdates;\n      try (UpdateLog.RecentUpdates recentUpdates = ulog.getRecentUpdates()) {\n        ourUpdates = recentUpdates.getVersions(nUpdates);\n        bufferedUpdates = recentUpdates.getBufferUpdates();\n      }\n      ourUpdates.sort(absComparator);\n      startingVersions.sort(absComparator);\n      long ourLowThreshold = percentile(startingVersions, 0.8f);\n      long ourHighThreshold = percentile(startingVersions, 0.2f);\n      // now make sure that the starting updates overlap our updates\n      // there shouldn't be reorders, so any overlap will do.\n      long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size() - 1));\n      if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {\n        log.warn(msg()\n            + \"too many updates received since start - startingUpdates no longer overlaps with our currentUpdates\");\n        syncErrors.inc();\n        return PeerSync.PeerSyncResult.failure();\n      }\n      // let's merge the lists\n      for (Long ver : startingVersions) {\n        if (Math.abs(ver) < smallestNewUpdate) {\n          ourUpdates.add(ver);\n        }\n      }\n      boolean success = doSync(ourUpdates, ourLowThreshold, ourHighThreshold);\n      log.info(msg() + \"DONE. sync \" + (success ? \"succeeded\" : \"failed\"));\n      if (!success) {\n        syncErrors.inc();\n      }\n      return success ?  PeerSync.PeerSyncResult.success() : PeerSync.PeerSyncResult.failure();\n    } finally {\n      if (timerContext != null) {\n        timerContext.close();\n      }\n      try {\n        clientToLeader.close();\n      } catch (IOException e) {\n        log.warn(\"{} unable to close client to leader\", msg(), e);\n      }\n      MDCLoggingContext.clear();\n    }\n  }\n  private boolean doSync(List<Long> ourUpdates, long ourLowThreshold, long ourHighThreshold) {\n    // get leader's recent versions and fingerprint\n    // note: by getting leader's versions later, we guarantee that leader's versions always super set of {@link bufferedUpdates}\n    NamedList<Object> leaderVersionsAndFingerprint = getVersions();\n    IndexFingerprint leaderFingerprint = getFingerprint(leaderVersionsAndFingerprint);\n    if (doFingerprint) {\n      if (leaderFingerprint == null) {\n        log.warn(\"Could not get fingerprint from the leader\");\n        return false;\n      }\n      log.info(\"Leader fingerprint {}\", leaderFingerprint);\n    }\n    missedUpdatesFinder = new MissedUpdatesFinder(ourUpdates, msg(), nUpdates, ourLowThreshold);\n    MissedUpdatesRequest missedUpdates = buildMissedUpdatesRequest(leaderVersionsAndFingerprint);\n    if (missedUpdates == MissedUpdatesRequest.ALREADY_IN_SYNC) return true;\n    if (missedUpdates != MissedUpdatesRequest.UNABLE_TO_SYNC) {\n      NamedList<Object> missedUpdatesRsp = requestUpdates(missedUpdates);\n      if (handleUpdates(missedUpdatesRsp, missedUpdates.totalRequestedUpdates, leaderFingerprint)) {\n        if (doFingerprint) {<fim_middle>// function below has no smell\n"}