{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.syncope.client.console.rest;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport javax.ws.rs.core.Response;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.syncope.client.lib.batch.BatchRequest;\nimport org.apache.syncope.common.lib.to.ExecTO;\nimport org.apache.syncope.common.lib.to.JobTO;\nimport org.apache.syncope.common.lib.to.ReportTO;\nimport org.apache.syncope.common.lib.to.ReportTemplateTO;\nimport org.apache.syncope.common.lib.types.JobAction;\nimport org.apache.syncope.common.lib.types.ReportExecExportFormat;\nimport org.apache.syncope.common.lib.types.ReportTemplateFormat;\nimport org.apache.syncope.common.rest.api.batch.BatchRequestItem;\nimport org.apache.syncope.common.rest.api.batch.BatchResponseItem;\nimport org.apache.syncope.common.rest.api.beans.ExecQuery;\nimport org.apache.syncope.common.rest.api.beans.ExecuteQuery;\nimport org.apache.syncope.common.rest.api.service.ReportService;\nimport org.apache.syncope.common.rest.api.service.ReportTemplateService;\nimport org.apache.wicket.extensions.markup.html.repeater.util.SortParam;\n\npublic class ReportRestClient extends BaseRestClient\n        implements ExecutionRestClient, TemplateRestClient<ReportTemplateTO, ReportTemplateFormat> {\n\n    private static final long serialVersionUID = 1644689667998953604L;\n\n    public ReportTO read(final String reportKey) {\n        return getService(ReportService.class).read(reportKey);\n    }\n\n    public List<ReportTO> list() {\n        return getService(ReportService.class).list();\n    }\n\n    public JobTO getJob(final String key) {\n        return getService(ReportService.class).getJob(key);\n    }\n\n    public List<JobTO> listJobs() {\n        return getService(ReportService.class).listJobs();\n    }\n\n    public void actionJob(final String refKey, final JobAction jobAction) {\n        getService(ReportService.class).actionJob(refKey, jobAction);\n    }\n\n    public void create(final ReportTO reportTO) {\n        getService(ReportService.class).create(reportTO);\n    }\n\n    public void update(final ReportTO reportTO) {\n        getService(ReportService.class).update(reportTO);\n    }\n\n    /**\n     * Delete specified report.\n     *\n     * @param reportKey report to delete\n     */\n    public void delete(final String reportKey) {\n        getService(ReportService.class).delete(reportKey);\n    }\n\n    @Override\n    public void startExecution(final String reportKey, final Date start) {\n        getService(ReportService.class).execute(new ExecuteQuery.Builder().key(reportKey).startAt(start).build());\n    }\n\n    @Override\n    public void deleteExecution(final String reportExecKey) {\n        getService(ReportService.class).deleteExecution(reportExecKey);\n    }\n\n    @Override\n    public List<ExecTO> listRecentExecutions(final int max) {\n        return getService(ReportService.class).listRecentExecutions(max);\n    }\n\n    public Response exportExecutionResult(final String executionKey, final ReportExecExportFormat fmt) {\n        return getService(ReportService.class).exportExecutionResult(executionKey, fmt);\n    }\n\n    @Override\n    public List<ExecTO> listExecutions(\n            final String taskKey, final int page, final int size, final SortParam<String> sort) {\n\n        return getService(ReportService.class).\n                listExecutions(new ExecQuery.Builder().key(taskKey).page(page).size(size).\n                        orderBy(toOrderBy(sort)).build()).getResult();\n    }\n\n<fim_suffix>    @Override\n    public int countExecutions(final String taskKey) {\n        return getService(ReportService.class).\n                listExecutions(new ExecQuery.Builder().key(taskKey).page(1).size(1).build()).getTotalCount();\n    }\n\n    @Override\n    public List<ReportTemplateTO> listTemplates() {\n        return getService(ReportTemplateService.class).list();\n    }\n\n    @Override\n    public void createTemplate(final ReportTemplateTO reportTemplateTO) {\n        getService(ReportTemplateService.class).create(reportTemplateTO);\n    }\n\n    @Override\n    public void deleteTemplate(final String key) {\n        getService(ReportTemplateService.class).delete(key);\n    }\n\n    @Override\n    public ReportTemplateTO readTemplate(final String key) {\n        return getService(ReportTemplateService.class).read(key);\n    }\n\n    @Override\n    public String readTemplateFormat(final String key, final ReportTemplateFormat format) {\n        try {\n            return IOUtils.toString(InputStream.class.cast(\n                    getService(ReportTemplateService.class).getFormat(key, format).getEntity()),\n                    StandardCharsets.UTF_8);\n        } catch (Exception e) {\n            LOG.error(\"Error retrieving mail template {} as {}\", key, format, e);\n            return StringUtils.EMPTY;\n        }\n    }\n\n    @Override\n    public void updateTemplateFormat(final String key, final String content, final ReportTemplateFormat format) {\n        getService(ReportTemplateService.class).setFormat(\n                key, format, IOUtils.toInputStream(content, StandardCharsets.UTF_8));\n    }\n\n    @Override\n    public Map<String, String> batch(final BatchRequest batchRequest) {\n        List<BatchRequestItem> batchRequestItems = new ArrayList<>(batchRequest.getItems());\n\n        Map<String, String> result = new LinkedHashMap<>();\n        try {\n            List<BatchResponseItem> batchResponseItems = batchRequest.commit().getItems();\n            for (int i = 0; i < batchResponseItems.size(); i++) {\n                String status = getStatus(batchResponseItems.get(i).getStatus());\n\n                if (batchRequestItems.get(i).getRequestURI().contains(\"/execute\")) {\n                    result.put(StringUtils.substringAfterLast(\n                            StringUtils.substringBefore(batchRequestItems.get(i).getRequestURI(), \"/execute\"), \"/\"),\n                            status);\n                } else {\n                    result.put(StringUtils.substringAfterLast(\n                            batchRequestItems.get(i).getRequestURI(), \"/\"), status);\n                }\n            }\n        } catch (IOException e) {\n            LOG.error(\"While processing Batch response\", e);\n        }\n\n        return result;\n    }\n}<fim_middle>// function below has no smell\n"}