{"text": "<fim_prefix>/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n */\n\npackage org.apache.qpid.server.qmf2.agentdata;\n\n// Misc Imports\nimport java.util.Collections;\nimport java.util.Map;\n\n// Simple Logging Facade 4 Java\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n// QMF2 Imports\nimport org.apache.qpid.qmf2.agent.QmfAgentData;\nimport org.apache.qpid.qmf2.common.QmfEvent;\nimport org.apache.qpid.qmf2.common.ObjectId;\nimport org.apache.qpid.qmf2.common.QmfEvent;\nimport org.apache.qpid.qmf2.common.SchemaEventClass;\n//import org.apache.qpid.qmf2.common.SchemaMethod;\nimport org.apache.qpid.qmf2.common.SchemaObjectClass;\n//import org.apache.qpid.qmf2.common.SchemaProperty;\n\nimport org.apache.qpid.server.model.ExclusivityPolicy;\nimport org.apache.qpid.server.model.Queue;\n\n/**\n * This class provides a concrete implementation of QmfAgentData for the Subscription Management Object.\n * In general it's possible to use QmfAgentData without sub-classing as it's really a \"bean\" style class\n * that retains its properties in a Map, but in the case of the Java Broker Management Agent it's useful\n * to sub-class as we need to map between the properties/statistics as specified in the Java Broker\n * management model and those specified in qpid/spec/management-schema.xml which is what the C++ broker \n * uses. This class retains a reference to its peer org.apache.qpid.server.model.Consumer and does the\n * necessary mapping when its mapEncode() method is called (which is used to serialise the QmfAgentData).\n *\n * @author Fraser Adams\n */\npublic class Subscription extends QmfAgentData\n{\n    private static final Logger _log = LoggerFactory.getLogger(Subscription.class);\n\n    /**\n     * This static initialiser block initialises the QMF2 Schema information needed by the Agent to find\n     * QmfAgentData and QmfEvent Objects of a given type.\n     */\n    private static final SchemaObjectClass _schema;\n    private static final SchemaEventClass _subscribeSchema;\n    private static final SchemaEventClass _unsubscribeSchema;\n\n    /**\n     * Returns the schema for the Subscription class.\n     * @return the SchemaObjectClass for the Subscription class.\n     */\n    public static SchemaObjectClass getSchema()\n    {\n        return _schema;\n    }\n\n    /**\n     * Returns the schema for the Subscribe Event.\n     * @return the SchemaEventClass for the Subscribe Event.\n     */\n    public static SchemaEventClass getSubscribeSchema()\n    {\n        return _subscribeSchema;\n    }\n\n    /**\n     * Returns the schema for the Unsubscribe Event.\n     * @return the SchemaEventClass for the Unsubscribe Event.\n     */\n    public static SchemaEventClass getUnsubscribeSchema()\n    {\n        return _unsubscribeSchema;\n    }\n\n    static\n    {\n        // Declare the schema for the QMF2 subscription class.\n        _schema = new SchemaObjectClass(\"org.apache.qpid.broker\", \"subscription\");\n\n        // TODO\n        //_schema.addProperty(new SchemaProperty(\"whatHappened\", QmfType.TYPE_STRING));\n\n        // Declare the schema for the QMF2 subscribe Event class.\n        _subscribeSchema = new SchemaEventClass(\"org.apache.qpid.broker\", \"subscribe\");\n\n        // Declare the schema for the QMF2 unsubscribe Event class.\n        _unsubscribeSchema = new SchemaEventClass(\"org.apache.qpid.broker\", \"unsubscribe\");\n    }\n    // End of static initialiser.\n\n    private final org.apache.qpid.server.model.Consumer _subscription;\n\n    private boolean _exclusive = false;\n    private String _qName = \"\";\n\n    /**\n     * Constructor.\n     * @param subscription the Consumer ConfiguredObject from the broker model.\n     */\n    public Subscription(final org.apache.qpid.server.model.Consumer subscription)\n    {\n        super(getSchema());\n        _subscription = subscription; // Will eventually be used in mapEncode() to retrieve statistics.\n\n        setValue(\"name\", subscription.getName());\n        setValue(\"browsing\", false);      // TODO not supported in Java Broker.\n        setValue(\"acknowledged\", true);   // TODO not supported in Java Broker.\n        setValue(\"creditMode\", \"WINDOW\"); // TODO not supported in Java Broker.\n    }\n\n    /**\n     * Set the sessionRef property.\n     * @param sessionRef the sessionRef ObjectId.\n     */\n    public void setSessionRef(final ObjectId sessionRef)\n    {\n        setRefValue(\"sessionRef\", sessionRef);\n    }\n\n    /**\n     * Set the queueRef property.\n     * @param queueRef the queueRef ObjectId.\n     */\n    public void setQueueRef(final ObjectId queueRef, final Queue queue)\n    {\n        setRefValue(\"queueRef\", queueRef);\n\n        // Unfortunately the org.apache.qpid.server.model.Consumer doesn't yet allow access to its associated Queue\n        // so we pass a reference ourselves when we do setQueueRef. This is because some Subscription properties\n        // are *actually\" related to the associated Queue.\n        _qName = queue.getName();\n\n        // In the Java Broker exclusivity may be NONE, SESSION, CONNECTION, CONTAINER, PRINCIPAL, LINK\n        // We map these to a boolean value to be consistent with the C++ Broker QMF values.\n        // TODO The C++ and Java Brokers should really return consistent information.\n        ExclusivityPolicy exclusivityPolicy = queue.getExclusive();\n        _exclusive = (exclusivityPolicy != ExclusivityPolicy.NONE) ? true : false;\n    }\n\n    /**\n     * Factory method to create a Subscribe Event Object with timestamp of now.\n     * @return the newly created Subscribe Event Object.\n     */\n    public QmfEvent createSubscribeEvent()\n    {\n        QmfEvent subscribe = new QmfEvent(_subscribeSchema);\n        subscribe.setSeverity(\"info\");\n        subscribe.setValue(\"args\", Collections.EMPTY_MAP);\n        subscribe.setValue(\"dest\", getStringValue(\"name\"));\n        subscribe.setValue(\"excl\", _exclusive);\n        subscribe.setValue(\"qName\", _qName);\n        // TODO Not sure of a way to get these for Java Broker Subscription.\n        //subscribe.setValue(\"rhost\", _connection.getName());\n        //subscribe.setValue(\"user\", getStringValue(\"authIdentity\"));\n        return subscribe;\n    }\n\n    /**\n     * Factory method to create an Unsubscribe Event Object with timestamp of now.\n     * @return the newly created Unsubscribe Event Object.\n     */\n<fim_suffix>    public QmfEvent createUnsubscribeEvent()\n    {\n        QmfEvent unsubscribe = new QmfEvent(_unsubscribeSchema);\n        unsubscribe.setSeverity(\"info\");\n        unsubscribe.setValue(\"dest\", getStringValue(\"name\"));\n        // TODO Not sure of a way to get these for Java Broker Subscription.\n        //unsubscribe.setValue(\"rhost\", _connection.getName());\n        //unsubscribe.setValue(\"user\", getStringValue(\"authIdentity\"));\n        return unsubscribe;\n    }\n\n    /**\n     * This method maps the org.apache.qpid.server.model.Consumer to QMF2 subscribe properties where possible then\n     * serialises into the underlying Map for transmission via AMQP. This method is called by handleQueryRequest()\n     * in the org.apache.qpid.qmf2.agent.Agent class implementing the main QMF2 Agent behaviour.\n     * \n     * @return the underlying map. \n     */\n    @Override\n    public Map<String, Object> mapEncode()\n    {\n        // Statistics \n        setValue(\"delivered\", _subscription.getMessagesOut());\n\n        setValue(\"exclusive\", _exclusive);\n\n        update(); // TODO Only Update if statistics have changes.\n        return super.mapEncode();\n    }\n}<fim_middle>// function below has no smell\n"}