{"text": "<fim_prefix>    // with.\n    private final Set<File> scannedUris = Sets.newHashSet();\n    public final void scan(ClassLoader classloader) throws IOException {\n      for (Entry<File, ClassLoader> entry : getClassPathEntries(classloader).entrySet()) {\n        scan(entry.getKey(), entry.getValue());\n      }\n    }\n    @VisibleForTesting\n    final void scan(File file, ClassLoader classloader) throws IOException {\n      if (scannedUris.add(file.getCanonicalFile())) {\n        scanFrom(file, classloader);\n      }\n    }\n    /** Called when a directory is scanned for resource files. */\n    protected abstract void scanDirectory(ClassLoader loader, File directory) throws IOException;\n    /** Called when a jar file is scanned for resource entries. */\n    protected abstract void scanJarFile(ClassLoader loader, JarFile file) throws IOException;\n    private void scanFrom(File file, ClassLoader classloader) throws IOException {\n      try {\n        if (!file.exists()) {\n          return;\n        }\n      } catch (SecurityException e) {\n        logger.warning(\"Cannot access \" + file + \": \" + e);\n        // TODO(emcmanus): consider whether to log other failure cases too.\n        return;\n      }\n      if (file.isDirectory()) {\n        scanDirectory(classloader, file);\n      } else {\n        scanJar(file, classloader);\n      }\n    }\n    private void scanJar(File file, ClassLoader classloader) throws IOException {\n      JarFile jarFile;\n      try {\n        jarFile = new JarFile(file);\n      } catch (IOException e) {\n        // Not a jar file\n        return;\n      }\n      try {\n        for (File path : getClassPathFromManifest(file, jarFile.getManifest())) {\n          scan(path, classloader);\n        }\n        scanJarFile(classloader, jarFile);\n      } finally {\n        try {\n          jarFile.close();\n        } catch (IOException ignored) {\n        }\n      }\n    }\n    /**\n     * Returns the class path URIs specified by the {@code Class-Path} manifest attribute, according\n     * to <a\n     * href=\"http://docs.oracle.com/javase/8/docs/technotes/guides/jar/jar.html#Main_Attributes\">JAR\n     * File Specification</a>. If {@code manifest} is null, it means the jar file has no manifest,\n     * and an empty set will be returned.\n     */\n    @VisibleForTesting\n    static ImmutableSet<File> getClassPathFromManifest(\n        File jarFile, @NullableDecl Manifest manifest) {\n      if (manifest == null) {\n        return ImmutableSet.of();\n      }\n      ImmutableSet.Builder<File> builder = ImmutableSet.builder();\n      String classpathAttribute =\n          manifest.getMainAttributes().getValue(Attributes.Name.CLASS_PATH.toString());\n      if (classpathAttribute != null) {\n        for (String path : CLASS_PATH_ATTRIBUTE_SEPARATOR.split(classpathAttribute)) {\n          URL url;\n          try {\n            url = getClassPathEntry(jarFile, path);\n          } catch (MalformedURLException e) {\n            // Ignore bad entry\n            logger.warning(\"Invalid Class-Path entry: \" + path);\n            continue;\n          }\n          if (url.getProtocol().equals(\"file\")) {\n            builder.add(toFile(url));\n          }\n        }\n      }\n      return builder.build();\n    }\n    @VisibleForTesting\n    static ImmutableMap<File, ClassLoader> getClassPathEntries(ClassLoader classloader) {\n      LinkedHashMap<File, ClassLoader> entries = Maps.newLinkedHashMap();\n      // Search parent first, since it's the order ClassLoader#loadClass() uses.\n      ClassLoader parent = classloader.getParent();\n      if (parent != null) {\n        entries.putAll(getClassPathEntries(parent));\n      }\n      for (URL url : getClassLoaderUrls(classloader)) {\n        if (url.getProtocol().equals(\"file\")) {\n          File file = toFile(url);\n          if (!entries.containsKey(file)) {\n            entries.put(file, classloader);\n          }\n        }\n      }\n      return ImmutableMap.copyOf(entries);\n    }\n    private static ImmutableList<URL> getClassLoaderUrls(ClassLoader classloader) {\n      if (classloader instanceof URLClassLoader) {\n        return ImmutableList.copyOf(((URLClassLoader) classloader).getURLs());\n      }\n      if (classloader.equals(ClassLoader.getSystemClassLoader())) {\n        return parseJavaClassPath();\n      }\n      return ImmutableList.of();\n    }\n    /**\n     * Returns the URLs in the class path specified by the {@code java.class.path} {@linkplain\n     * System#getProperty system property}.\n     */\n    @VisibleForTesting // TODO(b/65488446): Make this a public API.\n    static ImmutableList<URL> parseJavaClassPath() {\n      ImmutableList.Builder<URL> urls = ImmutableList.builder();\n      for (String entry : Splitter.on(PATH_SEPARATOR.value()).split(JAVA_CLASS_PATH.value())) {\n        try {\n          try {\n            urls.add(new File(entry).toURI().toURL());\n          } catch (SecurityException e) { // File.toURI checks to see if the file is a directory\n            urls.add(new URL(\"file\", null, new File(entry).getAbsolutePath()));\n          }\n        } catch (MalformedURLException e) {\n          logger.log(WARNING, \"malformed classpath entry: \" + entry, e);\n        }\n      }\n      return urls.build();\n    }\n    /**\n     * Returns the absolute uri of the Class-Path entry value as specified in <a\n     * href=\"http://docs.oracle.com/javase/8/docs/technotes/guides/jar/jar.html#Main_Attributes\">JAR\n     * File Specification</a>. Even though the specification only talks about relative urls,\n     * absolute urls are actually supported too (for example, in Maven surefire plugin).\n     */\n    @VisibleForTesting\n    static URL getClassPathEntry(File jarFile, String path) throws MalformedURLException {\n      return new URL(jarFile.toURI().toURL(), path);\n    }\n  }\n  @VisibleForTesting\n  static final class DefaultScanner extends Scanner {\n    private final SetMultimap<ClassLoader, String> resources =\n        MultimapBuilder.hashKeys().linkedHashSetValues().build();\n    ImmutableSet<ResourceInfo> getResources() {\n      ImmutableSet.Builder<ResourceInfo> builder = ImmutableSet.builder();\n      for (Entry<ClassLoader, String> entry : resources.entries()) {\n        builder.add(ResourceInfo.of(entry.getValue(), entry.getKey()));\n      }\n      return builder.build();\n    }\n    @Override\n    protected void scanJarFile(ClassLoader classloader, JarFile file) {\n      Enumeration<JarEntry> entries = file.entries();\n      while (entries.hasMoreElements()) {\n        JarEntry entry = entries.nextElement();\n        if (entry.isDirectory() || entry.getName().equals(JarFile.MANIFEST_NAME)) {\n          continue;\n        }\n        resources.get(classloader).add(entry.getName());\n      }\n    }\n    @Override\n    protected void scanDirectory(ClassLoader classloader, File directory) throws IOException {\n      Set<File> currentPath = new HashSet<>();\n      currentPath.add(directory.getCanonicalFile());\n      scanDirectory(directory, classloader, \"\", currentPath);\n    }\n    /**\n     * Recursively scan the given directory, adding resources for each file encountered. Symlinks\n     * which have already been traversed in the current tree path will be skipped to eliminate\n     * cycles; otherwise symlinks are traversed.\n     *\n     * @param directory the root of the directory to scan\n     * @param classloader the classloader that includes resources found in {@code directory}\n     * @param packagePrefix resource path prefix inside {@code classloader} for any files found\n     *     under {@code directory}\n     * @param currentPath canonical files already visited in the current directory tree path, for\n     *     cycle elimination\n     */\n    private void scanDirectory(\n        File directory, ClassLoader classloader, String packagePrefix, Set<File> currentPath)\n        throws IOException {\n      File[] files = directory.listFiles();\n      if (files == null) {\n        logger.warning(\"Cannot read directory \" + directory);\n        // IO error, just skip the directory\n        return;\n      }\n      for (File f : files) {\n        String name = f.getName();\n        if (f.isDirectory()) {\n          File deref = f.getCanonicalFile();\n          if (currentPath.add(deref)) {\n            scanDirectory(deref, classloader, packagePrefix + name + \"/\", currentPath);\n            currentPath.remove(deref);\n          }\n        } else {\n          String resourceName = packagePrefix + name;\n          if (!resourceName.equals(JarFile.MANIFEST_NAME)) {\n            resources.get(classloader).add(resourceName);\n          }\n        }\n      }\n    }\n  }\n<fim_suffix>  @VisibleForTesting\n  static String getClassName(String filename) {\n    int classNameEnd = filename.length() - CLASS_FILE_NAME_EXTENSION.length();\n    return filename.substring(0, classNameEnd).replace('/', '.');\n  }<fim_middle>// function below has no smell\n"}