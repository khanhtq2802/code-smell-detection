{"text": "<fim_prefix>/*\n * Copyright (c) 2016 VMware, Inc. All Rights Reserved.\n *\n * This product is licensed to you under the Apache License, Version 2.0 (the \"License\").\n * You may not use this product except in compliance with the License.\n *\n * This product may include a number of subcomponents with separate copyright notices\n * and license terms. Your use of these subcomponents is subject to the terms and\n * conditions of the subcomponent's license, as noted in the LICENSE file.\n */\npackage com.vmware.admiral.request;\nimport static com.vmware.admiral.compute.container.SystemContainerDescriptions.isSystemContainer;\nimport static com.vmware.admiral.request.utils.RequestUtils.FIELD_NAME_ALLOCATION_REQUEST;\nimport static com.vmware.admiral.request.utils.RequestUtils.FIELD_NAME_CONTEXT_ID_KEY;\nimport static com.vmware.xenon.common.ServiceDocumentDescription.PropertyIndexingOption.STORE_ONLY;\nimport static com.vmware.xenon.common.ServiceDocumentDescription.PropertyUsageOption.AUTO_MERGE_IF_NOT_NULL;\nimport static com.vmware.xenon.common.ServiceDocumentDescription.PropertyUsageOption.REQUIRED;\nimport static com.vmware.xenon.common.ServiceDocumentDescription.PropertyUsageOption.SERVICE_USE;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.EnumSet;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.function.Consumer;\nimport java.util.stream.Collectors;\nimport com.vmware.admiral.common.ManagementUriParts;\nimport com.vmware.admiral.common.util.QueryUtil;\nimport com.vmware.admiral.common.util.ServiceDocumentQuery;\nimport com.vmware.admiral.compute.ComputeConstants;\nimport com.vmware.admiral.compute.container.CompositeComponentFactoryService;\nimport com.vmware.admiral.compute.container.CompositeComponentRegistry;\nimport com.vmware.admiral.compute.container.CompositeComponentRegistry.ComponentMeta;\nimport com.vmware.admiral.compute.container.ContainerService.ContainerState;\nimport com.vmware.admiral.request.ClusteringTaskService.ClusteringTaskState.SubStage;\nimport com.vmware.admiral.request.RequestBrokerService.RequestBrokerState;\nimport com.vmware.admiral.request.utils.RequestUtils;\nimport com.vmware.admiral.service.common.AbstractTaskStatefulService;\nimport com.vmware.admiral.service.common.ServiceTaskCallback;\nimport com.vmware.admiral.service.common.ServiceTaskCallback.ServiceTaskCallbackResponse;\nimport com.vmware.photon.controller.model.resources.ComputeService.ComputeState;\nimport com.vmware.photon.controller.model.resources.ResourceState;\nimport com.vmware.xenon.common.LocalizableValidationException;\nimport com.vmware.xenon.common.Operation;\nimport com.vmware.xenon.common.TaskState;\nimport com.vmware.xenon.common.UriUtils;\nimport com.vmware.xenon.common.Utils;\nimport com.vmware.xenon.services.common.QueryTask;\nimport com.vmware.xenon.services.common.QueryTask.QuerySpecification;\nimport com.vmware.xenon.services.common.QueryTask.QuerySpecification.QueryOption;\n/**\n * Task for clusterization of resources: handles both increase and decrease of the number of the\n * resources in a cluster.\n */\npublic class ClusteringTaskService extends\n        AbstractTaskStatefulService<ClusteringTaskService.ClusteringTaskState, ClusteringTaskService.ClusteringTaskState.SubStage> {\n    public static final String DISPLAY_NAME = \"Resource Clustering\";\n    public static final String FACTORY_LINK = ManagementUriParts.REQUEST_RESOURCE_CLUSTERING_TASK;\n    public static class ClusteringTaskState extends\n            com.vmware.admiral.service.common.TaskServiceDocument<ClusteringTaskState.SubStage> {\n        public enum SubStage {\n            CREATED,\n            CLUSTERING,\n            COMPLETED,\n            ERROR;\n            static final Set<SubStage> TRANSIENT_SUB_STAGES = new HashSet<>(\n                    Arrays.asList(CLUSTERING));\n        }\n        public String contextId;\n        /** The description that defines the requested resource. */\n        @PropertyOptions(usage = { REQUIRED }, indexing = STORE_ONLY)\n        public String resourceDescriptionLink;\n        /** (Required) Type of resource to create. */\n        @PropertyOptions(usage = { REQUIRED }, indexing = STORE_ONLY)\n        public String resourceType;\n        /** (Required) Number of resources to provision. */\n        public long resourceCount;\n        /** Indicating that it is in the second phase after allocation */\n        public boolean postAllocation;\n        // Service use fields:\n        @PropertyOptions(usage = { SERVICE_USE, AUTO_MERGE_IF_NOT_NULL }, indexing = STORE_ONLY)\n        public Set<String> resourceLinks;\n    }\n    public ClusteringTaskService() {\n        super(ClusteringTaskState.class, SubStage.class, DISPLAY_NAME);\n        super.toggleOption(ServiceOption.PERSISTENCE, true);\n        super.toggleOption(ServiceOption.REPLICATION, true);\n        super.toggleOption(ServiceOption.OWNER_SELECTION, true);\n        super.transientSubStages = SubStage.TRANSIENT_SUB_STAGES;\n    }\n    @Override\n    protected Collection<String> getRelatedResourcesLinks(ClusteringTaskState state) {\n        return state.resourceLinks;\n    }\n    @Override\n    protected Class<? extends ResourceState> getRelatedResourceStateType(ClusteringTaskState state) {\n        return getStateClass(state.resourceType);\n    }\n    @Override\n    protected BaseExtensibilityCallbackResponse notificationPayload(ClusteringTaskState state) {\n        return new BaseExtensibilityCallbackResponse();\n    }\n    @Override\n    protected void validateStateOnStart(ClusteringTaskState state)\n            throws IllegalArgumentException {\n        if (state.resourceCount < 1) {\n            throw new LocalizableValidationException(\"'resourceCount' must be greater than 0.\", \"request.resource-count.zero\");\n        }\n    }\n    @Override\n    protected void handleStartedStagePatch(ClusteringTaskState state) {\n        switch (state.taskSubStage) {\n        case CREATED:\n            provisionOrRemoveResources(state, null);\n            break;\n        case CLUSTERING:\n            break;\n        case COMPLETED:\n            complete();\n            break;\n        case ERROR:\n            completeWithError();\n            break;\n        default:\n            break;\n        }\n    }\n    @Override\n    protected ServiceTaskCallbackResponse getFinishedCallbackResponse(\n            ClusteringTaskState state) {\n        CallbackCompleteResponse finishedResponse = new CallbackCompleteResponse();\n        finishedResponse.copy(state.serviceTaskCallback.getFinishedResponse());\n        finishedResponse.resourceLinks = state.resourceLinks;\n        if (state.resourceLinks == null || state.resourceLinks.isEmpty()) {\n            logWarning(\"No resourceLinks found for allocated resources.\");\n        }\n        return finishedResponse;\n    }\n<fim_suffix>    protected static class CallbackCompleteResponse extends ServiceTaskCallbackResponse {\n        Set<String> resourceLinks;\n    }\n    private void provisionOrRemoveResources(ClusteringTaskState state,\n            Set<ResourceState> resourcesStates) {\n        if (resourcesStates == null) {\n            retrieveResources(state,\n                    (resources) -> this.provisionOrRemoveResources(state, resources));\n            return;\n        }\n        if (!validate(resourcesStates)) {\n            return;\n        }\n        List<ResourceState> sortedResources = sortResourcesByImportance(resourcesStates);\n        int desiredResourceCount = (int) state.resourceCount;\n        int resourcesToAdd = 0;\n        /*\n         * Split the sorted list into two based on the desired resources count. The right hand side\n         * consists of resources to be deleted. The remaining resources can be further examined to\n         * check if they need to be \"redeployed\".\n         */\n        List<ResourceState> resourcesToRemove = Collections.emptyList();\n        if (desiredResourceCount > sortedResources.size()) {\n            resourcesToAdd = desiredResourceCount - sortedResources.size();\n        } else if (desiredResourceCount == sortedResources.size()) {\n            proceedTo(SubStage.COMPLETED);\n            return;\n        } else {\n            resourcesToRemove = sortedResources\n                    .subList(desiredResourceCount, sortedResources.size());\n        }\n        String groupResourcePlacementLink = null;\n        if (sortedResources.size() >= 1) {\n            groupResourcePlacementLink = getGroupResourcePlacementLink(sortedResources.get(0));\n        }\n        if (resourcesToAdd >= 1) {\n            createAdditionalResources(state, state.resourceDescriptionLink,\n                    groupResourcePlacementLink, resourcesToAdd);\n        } else {\n            removeResources(state, state.resourceDescriptionLink, resourcesToRemove);\n        }\n    }\n    private String getGroupResourcePlacementLink(ResourceState r) {\n        if (r instanceof ContainerState) {\n            return ((ContainerState) r).groupResourcePlacementLink;\n        } else if (r instanceof ComputeState) {<fim_middle>// class below has no smell\n"}