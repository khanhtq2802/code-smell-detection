{"text": "<fim_prefix>\n<fim_suffix>public interface Connection extends ShutdownNotifier, Closeable { // rename to AMQPConnection later, this is a temporary name\n    /**\n     * Retrieve the host.\n     * @return the hostname of the peer we're connected to.\n     */\n    InetAddress getAddress();\n    /**\n     * Retrieve the port number.\n     * @return the port number of the peer we're connected to.\n     */\n    int getPort();\n    /**\n     * Get the negotiated maximum channel number. Usable channel\n     * numbers range from 1 to this number, inclusive.\n     *\n     * @return the maximum channel number permitted for this connection.\n     */\n    int getChannelMax();\n    /**\n     * Get the negotiated maximum frame size.\n     *\n     * @return the maximum frame size, in octets; zero if unlimited\n     */\n    int getFrameMax();\n    /**\n     * Get the negotiated heartbeat interval.\n     *\n     * @return the heartbeat interval, in seconds; zero if none\n     */\n    int getHeartbeat();\n    /**\n     * Get a copy of the map of client properties sent to the server\n     *\n     * @return a copy of the map of client properties\n     */\n    Map<String, Object> getClientProperties();\n    /**\n     * Returns client-provided connection name, if any. Note that the value\n     * returned does not uniquely identify a connection and cannot be used\n     * as a connection identifier in HTTP API requests.\n     *\n     *\n     *\n     * @return client-provided connection name, if any\n     * @see ConnectionFactory#newConnection(Address[], String)\n     * @see ConnectionFactory#newConnection(ExecutorService, Address[], String)\n     */\n    String getClientProvidedName();\n    /**\n     * Retrieve the server properties.\n     * @return a map of the server properties. This typically includes the product name and version of the server.\n     */\n    Map<String, Object> getServerProperties();\n    /**\n     * Create a new channel, using an internally allocated channel number.\n     * If <a href=\"https://www.rabbitmq.com/api-guide.html#recovery\">automatic connection recovery</a>\n     * is enabled, the channel returned by this method will be {@link Recoverable}.\n     * <p>\n     * Use {@link #openChannel()} if you want to use an {@link Optional} to deal\n     * with a {@null} value.\n     *\n     * @return a new channel descriptor, or null if none is available\n     * @throws IOException if an I/O problem is encountered\n     */\n    Channel createChannel() throws IOException;\n    /**\n     * Create a new channel, using the specified channel number if possible.\n     * <p>\n     * Use {@link #openChannel(int)} if you want to use an {@link Optional} to deal\n     * with a {@null} value.\n     *\n     * @param channelNumber the channel number to allocate\n     * @return a new channel descriptor, or null if this channel number is already in use\n     * @throws IOException if an I/O problem is encountered\n     */\n    Channel createChannel(int channelNumber) throws IOException;\n    /**\n     * Create a new channel wrapped in an {@link Optional}.\n     * The channel number is allocated internally.\n     * <p>\n     * If <a href=\"https://www.rabbitmq.com/api-guide.html#recovery\">automatic connection recovery</a>\n     * is enabled, the channel returned by this method will be {@link Recoverable}.\n     * <p>\n     * Use {@link #createChannel()} to return directly a {@link Channel} or {@code null}.\n     *\n     * @return an {@link Optional} containing the channel;\n     * never {@code null} but potentially empty if no channel is available\n     * @throws IOException if an I/O problem is encountered\n     * @see #createChannel()\n     * @since 5.6.0\n     */\n    default Optional<Channel> openChannel() throws IOException {\n        return Optional.ofNullable(createChannel());\n    }\n    /**\n     * Create a new channel, using the specified channel number if possible.\n     * <p>\n     * Use {@link #createChannel(int)} to return directly a {@link Channel} or {@code null}.\n     *\n     * @param channelNumber the channel number to allocate\n     * @return an {@link Optional} containing the channel,\n     * never {@code null} but potentially empty if this channel number is already in use\n     * @throws IOException if an I/O problem is encountered\n     * @see #createChannel(int)\n     * @since 5.6.0\n     */\n    default Optional<Channel> openChannel(int channelNumber) throws IOException {\n        return Optional.ofNullable(createChannel(channelNumber));\n    }\n    /**\n     * Close this connection and all its channels\n     * with the {@link com.rabbitmq.client.AMQP#REPLY_SUCCESS} close code\n     * and message 'OK'.\n     *\n     * Waits for all the close operations to complete.\n     *\n     * @throws IOException if an I/O problem is encountered\n     */\n    @Override\n    void close() throws IOException;\n    /**\n     * Close this connection and all its channels.\n     *\n     * Waits for all the close operations to complete.\n     *\n     * @param closeCode the close code (See under \"Reply Codes\" in the AMQP specification)\n     * @param closeMessage a message indicating the reason for closing the connection\n     * @throws IOException if an I/O problem is encountered\n     */\n    void close(int closeCode, String closeMessage) throws IOException;\n    /**\n     * Close this connection and all its channels\n     * with the {@link com.rabbitmq.client.AMQP#REPLY_SUCCESS} close code\n     * and message 'OK'.\n     * \n     * This method behaves in a similar way as {@link #close()}, with the only difference\n     * that it waits with a provided timeout for all the close operations to\n     * complete. When timeout is reached the socket is forced to close.\n     * \n     * @param timeout timeout (in milliseconds) for completing all the close-related\n     * operations, use -1 for infinity\n     * @throws IOException if an I/O problem is encountered\n     */\n    void close(int timeout) throws IOException;\n    /**\n     * Close this connection and all its channels.\n     *\n     * Waits with the given timeout for all the close operations to complete.\n     * When timeout is reached the socket is forced to close.\n     * \n     * @param closeCode the close code (See under \"Reply Codes\" in the AMQP specification)\n     * @param closeMessage a message indicating the reason for closing the connection\n     * @param timeout timeout (in milliseconds) for completing all the close-related\n     * operations, use -1 for infinity\n     * @throws IOException if an I/O problem is encountered\n     */\n    void close(int closeCode, String closeMessage, int timeout) throws IOException;\n    /**\n     * Abort this connection and all its channels\n     * with the {@link com.rabbitmq.client.AMQP#REPLY_SUCCESS} close code\n     * and message 'OK'.\n     *\n     * Forces the connection to close.\n     * Any encountered exceptions in the close operations are silently discarded.\n     */\n    void abort();\n    /**\n     * Abort this connection and all its channels.\n     *\n     * Forces the connection to close and waits for all the close operations to complete.\n     * Any encountered exceptions in the close operations are silently discarded.\n     * \n     * @param closeCode the close code (See under \"Reply Codes\" in the AMQP specification)\n     * @param closeMessage a message indicating the reason for closing the connection\n     */\n    void abort(int closeCode, String closeMessage);\n    /**\n     * Abort this connection and all its channels\n     * with the {@link com.rabbitmq.client.AMQP#REPLY_SUCCESS} close code\n     * and message 'OK'.\n     *\n     * This method behaves in a similar way as {@link #abort()}, with the only difference\n     * that it waits with a provided timeout for all the close operations to\n     * complete. When timeout is reached the socket is forced to close.\n     *\n     * @param timeout timeout (in milliseconds) for completing all the close-related\n     * operations, use -1 for infinity\n     */\n    void abort(int timeout);\n    /**\n     * Abort this connection and all its channels.\n     *\n     * Forces the connection to close and waits with the given timeout\n     * for all the close operations to complete. When timeout is reached\n     * the socket is forced to close.\n     * Any encountered exceptions in the close operations are silently discarded.\n     *\n     * @param closeCode the close code (See under \"Reply Codes\" in the AMQP specification)\n     * @param closeMessage a message indicating the reason for closing the connection\n     * @param timeout timeout (in milliseconds) for completing all the close-related\n     * operations, use -1 for infinity\n     */\n    void abort(int closeCode, String closeMessage, int timeout);\n    /**\n     * Add a {@link BlockedListener}.\n     * @param listener the listener to add\n     */\n    void addBlockedListener(BlockedListener listener);\n    /**\n     * Add a lambda-based {@link BlockedListener}.\n     * @see BlockedListener\n     * @see BlockedCallback\n     * @see UnblockedCallback\n     * @param blockedCallback the callback when the connection is blocked<fim_middle>// class below has no smell\n"}