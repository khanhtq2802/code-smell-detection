{"text": "<fim_prefix>/*\n * Copyright 2015 The Closure Compiler Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.javascript.jscomp;\nimport com.google.common.base.Function;\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableMultimap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Iterables;\nimport com.google.javascript.jscomp.CompilerOptions.LanguageMode;\nimport com.google.javascript.jscomp.parsing.parser.FeatureSet;\nimport com.google.javascript.jscomp.resources.ResourceLoader;\nimport com.google.javascript.rhino.Node;\nimport java.util.Collection;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\n/**\n * Injects polyfill libraries to ensure that ES6 library functions are available.\n */\npublic class RewritePolyfills implements HotSwapCompilerPass {\n  static final DiagnosticType INSUFFICIENT_OUTPUT_VERSION_ERROR = DiagnosticType.disabled(\n      \"JSC_INSUFFICIENT_OUTPUT_VERSION\",\n      \"Built-in ''{0}'' not supported in output version {1}\");\n  /**\n   * Represents a single polyfill: specifically, for a native symbol\n   * (not part of this object, but stored as the key to the map\n   * containing the Polyfill instance), a set of native and polyfill\n   * versions, and a library to ensure is injected if the output version\n   * is less than the native version.  This is a simple value type.\n   */\n<fim_suffix>  private static class Polyfill {\n    /**\n     * The language version at (or above) which the native symbol is\n     * available and sufficient.  If the language out flag is at least\n     * as high as {@code nativeVersion} then no rewriting will happen.\n     */\n    final FeatureSet nativeVersion;\n    /**\n     * The required language version for the polyfill to work.  This\n     * should not be higher than {@code nativeVersion}, but may be the same\n     * in cases where there is no polyfill provided.  This is used to\n     * emit a warning if the language out flag is too low.\n     */\n    final FeatureSet polyfillVersion;\n    /**\n     * Runtime library to inject for the polyfill, e.g. \"es6/map\".\n     */\n    final String library;\n    Polyfill(FeatureSet nativeVersion, FeatureSet polyfillVersion, String library) {\n      this.nativeVersion = nativeVersion;\n      this.polyfillVersion = polyfillVersion;\n      this.library = library;\n    }\n  }\n  /**\n   * Describes all the available polyfills, including native and\n   * required versions, and how to use them.\n   */\n  static class Polyfills {\n    // Map of method polyfills, keyed by native method name.\n    private final ImmutableMultimap<String, Polyfill> methods;\n    // Map of static polyfills, keyed by fully-qualified native name.\n    private final ImmutableMap<String, Polyfill> statics;\n    // Set of suffixes of qualified names.\n    private final ImmutableSet<String> suffixes;\n    private Polyfills(\n        ImmutableMultimap<String, Polyfill> methods, ImmutableMap<String, Polyfill> statics) {\n      this.methods = methods;\n      this.statics = statics;\n      this.suffixes = ImmutableSet.copyOf(Iterables.transform(statics.keySet(), EXTRACT_SUFFIX));\n    }\n    /**\n     * Builds a Polyfills instance from a polyfill table, which is a simple\n     * text file with lines containing space-separated tokens:\n     *   [NATIVE_SYMBOL] [NATIVE_VERSION] [POLYFILL_VERSION] [LIBRARY]\n     * For example,\n     *   Array.prototype.fill es6 es3 es6/array/fill\n     *   Map es6 es3 es6/map\n     *   WeakMap es6 es6\n     * The last line, WeakMap, does not have a polyfill available, so the\n     * library token is empty.\n     */\n    static Polyfills fromTable(String table) {\n      ImmutableMultimap.Builder<String, Polyfill> methods = ImmutableMultimap.builder();\n      ImmutableMap.Builder<String, Polyfill> statics = ImmutableMap.builder();\n      for (String line : Splitter.on('\\n').omitEmptyStrings().split(table)) {\n        List<String> tokens = Splitter.on(' ').omitEmptyStrings().splitToList(line.trim());\n        if (tokens.size() == 1 && tokens.get(0).isEmpty()) {\n          continue;\n        } else if (tokens.size() < 3) {\n          throw new IllegalArgumentException(\"Invalid table: too few tokens on line: \" + line);\n        }\n        String symbol = tokens.get(0);\n        Polyfill polyfill =\n            new Polyfill(\n                FeatureSet.valueOf(tokens.get(1)),\n                FeatureSet.valueOf(tokens.get(2)),\n                tokens.size() > 3 ? tokens.get(3) : \"\");\n        if (symbol.contains(\".prototype.\")) {\n          methods.put(symbol.replaceAll(\".*\\\\.prototype\\\\.\", \"\"), polyfill);\n        } else {\n          statics.put(symbol, polyfill);\n        }\n      }\n      return new Polyfills(methods.build(), statics.build());\n    }\n    /**\n     * Given a qualified name {@code node}, checks whether the suffix\n     * of the name could possibly match a static polyfill.\n     */\n    boolean checkSuffix(Node node) {\n      return node.isGetProp() ? suffixes.contains(node.getLastChild().getString())\n          : node.isName() ? suffixes.contains(node.getString())\n          : false;\n    }\n    private static final Function<String, String> EXTRACT_SUFFIX =\n        new Function<String, String>() {\n          @Override\n          public String apply(String arg) {\n            return arg.substring(arg.lastIndexOf('.') + 1);\n          }\n        };\n  }\n  private final AbstractCompiler compiler;\n  private final Polyfills polyfills;\n  public RewritePolyfills(AbstractCompiler compiler) {\n    this(\n        compiler,\n        Polyfills.fromTable(\n            ResourceLoader.loadTextResource(RewritePolyfills.class, \"js/polyfills.txt\")));\n  }\n  // Visible for testing\n  RewritePolyfills(AbstractCompiler compiler, Polyfills polyfills) {\n    this.compiler = compiler;\n    this.polyfills = polyfills;\n  }\n  @Override\n  public void hotSwapScript(Node scriptRoot, Node originalRoot) {\n    Traverser traverser = new Traverser();\n    NodeTraversal.traverse(compiler, scriptRoot, traverser);\n    if (!traverser.libraries.isEmpty()) {\n      Node lastNode = null;\n      for (String library : traverser.libraries) {\n        lastNode = compiler.ensureLibraryInjected(library, false);\n      }\n      if (lastNode != null) {\n        Node parent = lastNode.getParent();\n        removeUnneededPolyfills(parent, lastNode.getNext());\n        compiler.reportChangeToEnclosingScope(parent);\n      }\n    }\n  }\n  // Remove any $jscomp.polyfill calls whose 3rd parameter (the language version\n  // that already contains the library) is the same or lower than languageOut.\n  private void removeUnneededPolyfills(Node parent, Node runtimeEnd) {\n    Node node = parent.getFirstChild();\n    while (node != null && node != runtimeEnd) {\n      Node next = node.getNext();\n      if (NodeUtil.isExprCall(node)) {\n        Node call = node.getFirstChild();\n        Node name = call.getFirstChild();\n        if (name.matchesQualifiedName(\"$jscomp.polyfill\")) {\n          FeatureSet nativeVersion =\n              FeatureSet.valueOf(name.getNext().getNext().getNext().getString());\n          if (languageOutIsAtLeast(nativeVersion)) {\n            NodeUtil.removeChild(parent, node);\n          }\n        }\n      }\n      node = next;\n    }\n  }\n  @Override\n  public void process(Node externs, Node root) {\n    hotSwapScript(root, null);\n  }\n  private class Traverser extends GuardedCallback<String> {\n    final Set<String> libraries = new LinkedHashSet<>();\n    Traverser() {\n      super(compiler);\n    }\n    @Override\n    public void visitGuarded(NodeTraversal traversal, Node node, Node parent) {\n      // Find qualified names that match static calls\n      if (node.isQualifiedName() && polyfills.checkSuffix(node)) {\n        String name = node.getQualifiedName();\n        // TODO(sdh): We could reduce some work here by combining the global names<fim_middle>// class below has no smell\n"}