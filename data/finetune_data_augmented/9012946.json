{"text": "<fim_prefix> * limitations under the License.\n */\npackage org.apache.lucene.analysis.ja.dict;\nimport java.io.BufferedInputStream;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.FileNotFoundException;\nimport java.io.InputStream;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.Channels;\nimport java.nio.channels.ReadableByteChannel;\nimport org.apache.lucene.codecs.CodecUtil;\nimport org.apache.lucene.store.DataInput;\nimport org.apache.lucene.store.InputStreamDataInput;\nimport org.apache.lucene.util.IntsRef;\nimport org.apache.lucene.util.IOUtils;\n/**\n * Base class for a binary-encoded in-memory dictionary.\n */\npublic abstract class BinaryDictionary implements Dictionary {\n  public static final String DICT_FILENAME_SUFFIX = \"$buffer.dat\";\n  public static final String TARGETMAP_FILENAME_SUFFIX = \"$targetMap.dat\";\n  public static final String POSDICT_FILENAME_SUFFIX = \"$posDict.dat\";\n  public static final String DICT_HEADER = \"kuromoji_dict\";\n  public static final String TARGETMAP_HEADER = \"kuromoji_dict_map\";\n  public static final String POSDICT_HEADER = \"kuromoji_dict_pos\";\n  public static final int VERSION = 1;\n  private final ByteBuffer buffer;\n  private final int[] targetMapOffsets, targetMap;\n  private final String[] posDict;\n  private final String[] inflTypeDict;\n  private final String[] inflFormDict;\n  protected BinaryDictionary() throws IOException {\n    InputStream mapIS = null, dictIS = null, posIS = null;\n    int[] targetMapOffsets = null, targetMap = null;\n    String[] posDict = null;\n    String[] inflFormDict = null;\n    String[] inflTypeDict = null;\n    ByteBuffer buffer = null;\n    boolean success = false;\n    try {\n      mapIS = getResource(TARGETMAP_FILENAME_SUFFIX);\n      mapIS = new BufferedInputStream(mapIS);\n      DataInput in = new InputStreamDataInput(mapIS);\n      CodecUtil.checkHeader(in, TARGETMAP_HEADER, VERSION, VERSION);\n      targetMap = new int[in.readVInt()];\n      targetMapOffsets = new int[in.readVInt()];\n      int accum = 0, sourceId = 0;\n      for (int ofs = 0; ofs < targetMap.length; ofs++) {\n        final int val = in.readVInt();\n        if ((val & 0x01) != 0) {\n          targetMapOffsets[sourceId] = ofs;\n          sourceId++;\n        }\n        accum += val >>> 1;\n        targetMap[ofs] = accum;\n      }\n      if (sourceId + 1 != targetMapOffsets.length)\n        throw new IOException(\"targetMap file format broken\");\n      targetMapOffsets[sourceId] = targetMap.length;\n      mapIS.close(); mapIS = null;\n      posIS = getResource(POSDICT_FILENAME_SUFFIX);\n      posIS = new BufferedInputStream(posIS);\n      in = new InputStreamDataInput(posIS);\n      CodecUtil.checkHeader(in, POSDICT_HEADER, VERSION, VERSION);\n      int posSize = in.readVInt();\n      posDict = new String[posSize];\n      inflTypeDict = new String[posSize];\n      inflFormDict = new String[posSize];\n      for (int j = 0; j < posSize; j++) {\n        posDict[j] = in.readString();\n        inflTypeDict[j] = in.readString();\n        inflFormDict[j] = in.readString();\n        // this is how we encode null inflections\n        if (inflTypeDict[j].length() == 0) {\n          inflTypeDict[j] = null;\n        }\n        if (inflFormDict[j].length() == 0) {\n          inflFormDict[j] = null;\n        }\n      }\n      posIS.close(); posIS = null;\n      dictIS = getResource(DICT_FILENAME_SUFFIX);\n      // no buffering here, as we load in one large buffer\n      in = new InputStreamDataInput(dictIS);\n      CodecUtil.checkHeader(in, DICT_HEADER, VERSION, VERSION);\n      final int size = in.readVInt();\n      final ByteBuffer tmpBuffer = ByteBuffer.allocateDirect(size);\n      final ReadableByteChannel channel = Channels.newChannel(dictIS);\n      final int read = channel.read(tmpBuffer);\n      if (read != size) {\n        throw new EOFException(\"Cannot read whole dictionary\");\n      }\n      dictIS.close(); dictIS = null;\n      buffer = tmpBuffer.asReadOnlyBuffer();\n      success = true;\n    } finally {\n      if (success) {\n        IOUtils.close(mapIS, posIS, dictIS);\n      } else {\n        IOUtils.closeWhileHandlingException(mapIS, posIS, dictIS);\n      }\n    }\n    this.targetMap = targetMap;\n    this.targetMapOffsets = targetMapOffsets;\n    this.posDict = posDict;\n    this.inflTypeDict = inflTypeDict;\n    this.inflFormDict = inflFormDict;\n    this.buffer = buffer;\n  }\n  protected final InputStream getResource(String suffix) throws IOException {\n    return getClassResource(getClass(), suffix);\n  }\n  // util, reused by ConnectionCosts and CharacterDefinition\n  public static final InputStream getClassResource(Class<?> clazz, String suffix) throws IOException {\n    final InputStream is = clazz.getResourceAsStream(clazz.getSimpleName() + suffix);\n    if (is == null)\n      throw new FileNotFoundException(\"Not in classpath: \" + clazz.getName().replace('.','/') + suffix);\n    return is;\n  }\n  public void lookupWordIds(int sourceId, IntsRef ref) {\n    ref.ints = targetMap;\n    ref.offset = targetMapOffsets[sourceId];\n    // targetMapOffsets always has one more entry pointing behind last:\n    ref.length = targetMapOffsets[sourceId + 1] - ref.offset;\n  }\n  @Override\n  public int getLeftId(int wordId) {\n    return buffer.getShort(wordId) >>> 3;\n  }\n  @Override\n  public int getRightId(int wordId) {\n    return buffer.getShort(wordId) >>> 3;\n  }\n  @Override\n  public int getWordCost(int wordId) {\n    return buffer.getShort(wordId + 2);  // Skip id\n  }\n  @Override\n  public String getBaseForm(int wordId, char surfaceForm[], int off, int len) {\n    if (hasBaseFormData(wordId)) {\n      int offset = baseFormOffset(wordId);\n      int data = buffer.get(offset++) & 0xff;\n      int prefix = data >>> 4;\n      int suffix = data & 0xF;\n      char text[] = new char[prefix+suffix];\n      System.arraycopy(surfaceForm, off, text, 0, prefix);\n      for (int i = 0; i < suffix; i++) {\n        text[prefix+i] = buffer.getChar(offset + (i << 1));\n      }\n      return new String(text);\n    } else {\n      return null;\n    }\n  }\n  @Override\n  public String getReading(int wordId, char surface[], int off, int len) {\n    if (hasReadingData(wordId)) {\n      int offset = readingOffset(wordId);\n      int readingData = buffer.get(offset++) & 0xff;\n      return readString(offset, readingData >>> 1, (readingData & 1) == 1);\n    } else {\n      // the reading is the surface form, with hiragana shifted to katakana\n      char text[] = new char[len];\n      for (int i = 0; i < len; i++) {\n        char ch = surface[off+i];\n        if (ch > 0x3040 && ch < 0x3097) {\n          text[i] = (char)(ch + 0x60);\n        } else {\n          text[i] = ch;\n        }\n      }\n      return new String(text);\n    }\n  }\n  @Override\n  public String getPartOfSpeech(int wordId) {\n    return posDict[getLeftId(wordId)];\n  }\n  @Override\n  public String getPronunciation(int wordId, char surface[], int off, int len) {\n    if (hasPronunciationData(wordId)) {\n      int offset = pronunciationOffset(wordId);\n      int pronunciationData = buffer.get(offset++) & 0xff;\n      return readString(offset, pronunciationData >>> 1, (pronunciationData & 1) == 1);\n    } else {\n      return getReading(wordId, surface, off, len); // same as the reading\n    }\n  }\n  @Override\n  public String getInflectionType(int wordId) {\n    return inflTypeDict[getLeftId(wordId)];\n  }\n<fim_suffix>  @Override\n  public String getInflectionForm(int wordId) {\n    return inflFormDict[getLeftId(wordId)];\n  }<fim_middle>// function below has no smell\n"}