{"text": "<fim_prefix>\n<fim_suffix>public abstract class AbstractIterativeTask<S extends Function, OT> extends BatchTask<S, OT>\n\t\timplements Terminable {\n\tprivate static final Logger log = LoggerFactory.getLogger(AbstractIterativeTask.class);\n\tprotected LongSumAggregator worksetAggregator;\n\tprotected BlockingBackChannel worksetBackChannel;\n\tprotected boolean isWorksetIteration;\n\tprotected boolean isWorksetUpdate;\n\tprotected boolean isSolutionSetUpdate;\n\tprivate RuntimeAggregatorRegistry iterationAggregators;\n\tprivate String brokerKey;\n\tprivate int superstepNum = 1;\n\tprivate volatile boolean terminationRequested;\n\t// --------------------------------------------------------------------------------------------\n\t/**\n\t * Create an Invokable task and set its environment.\n\t *\n\t * @param environment The environment assigned to this invokable.\n\t */\n\tpublic AbstractIterativeTask(Environment environment) {\n\t\tsuper(environment);\n\t}\n\t// --------------------------------------------------------------------------------------------\n\t// Main life cycle methods that implement the iterative behavior\n\t// --------------------------------------------------------------------------------------------\n\t@Override\n\tprotected void initialize() throws Exception {\n\t\tsuper.initialize();\n\t\t// check if the driver is resettable\n\t\tif (this.driver instanceof ResettableDriver) {\n\t\t\tfinal ResettableDriver<?, ?> resDriver = (ResettableDriver<?, ?>) this.driver;\n\t\t\t// make sure that the according inputs are not reset\n\t\t\tfor (int i = 0; i < resDriver.getNumberOfInputs(); i++) {\n\t\t\t\tif (resDriver.isInputResettable(i)) {\n\t\t\t\t\texcludeFromReset(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tTaskConfig config = getLastTasksConfig();\n\t\tisWorksetIteration = config.getIsWorksetIteration();\n\t\tisWorksetUpdate = config.getIsWorksetUpdate();\n\t\tisSolutionSetUpdate = config.getIsSolutionSetUpdate();\n\t\tif (isWorksetUpdate) {\n\t\t\tworksetBackChannel = BlockingBackChannelBroker.instance().getAndRemove(brokerKey());\n\t\t\tif (isWorksetIteration) {\n\t\t\t\tworksetAggregator = getIterationAggregators().getAggregator(WorksetEmptyConvergenceCriterion.AGGREGATOR_NAME);\n\t\t\t\tif (worksetAggregator == null) {\n\t\t\t\t\tthrow new RuntimeException(\"Missing workset elements count aggregator.\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t@Override\n\tpublic void run() throws Exception {\n\t\tif (inFirstIteration()) {\n\t\t\tif (this.driver instanceof ResettableDriver) {\n\t\t\t\t// initialize the repeatable driver\n\t\t\t\t((ResettableDriver<?, ?>) this.driver).initialize();\n\t\t\t}\n\t\t} else {\n\t\t\treinstantiateDriver();\n\t\t\tresetAllInputs();\n\t\t\t// re-read the iterative broadcast variables\n\t\t\tfor (int i : this.iterativeBroadcastInputs) {\n\t\t\t\tfinal String name = getTaskConfig().getBroadcastInputName(i);\n\t\t\t\treadAndSetBroadcastInput(i, name, this.runtimeUdfContext, superstepNum);\n\t\t\t}\n\t\t}\n\t\t// call the parent to execute the superstep\n\t\tsuper.run();\n\t\t// release the iterative broadcast variables\n\t\tfor (int i : this.iterativeBroadcastInputs) {\n\t\t\tfinal String name = getTaskConfig().getBroadcastInputName(i);\n\t\t\treleaseBroadcastVariables(name, superstepNum, this.runtimeUdfContext);\n\t\t}\n\t}\n\t@Override\n\tprotected void closeLocalStrategiesAndCaches() {\n\t\ttry {\n\t\t\tsuper.closeLocalStrategiesAndCaches();\n\t\t}\n\t\tfinally {\n\t\t\tif (this.driver instanceof ResettableDriver) {\n\t\t\t\tfinal ResettableDriver<?, ?> resDriver = (ResettableDriver<?, ?>) this.driver;\n\t\t\t\ttry {\n\t\t\t\t\tresDriver.teardown();\n\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\tlog.error(\"Error while shutting down an iterative operator.\", t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t@Override\n\tpublic DistributedRuntimeUDFContext createRuntimeContext(MetricGroup metrics) {\n\t\tEnvironment env = getEnvironment();\n\t\treturn new IterativeRuntimeUdfContext(env.getTaskInfo(), getUserCodeClassLoader(),\n\t\t\t\tgetExecutionConfig(), env.getDistributedCacheEntries(), this.accumulatorMap, metrics);\n\t}\n\t// --------------------------------------------------------------------------------------------\n\t// Utility Methods for Iteration Handling\n\t// --------------------------------------------------------------------------------------------\n\tprotected boolean inFirstIteration() {\n\t\treturn this.superstepNum == 1;\n\t}\n\tprotected int currentIteration() {\n\t\treturn this.superstepNum;\n\t}\n\tprotected void incrementIterationCounter() {\n\t\tthis.superstepNum++;\n\t}\n\tpublic String brokerKey() {\n\t\tif (brokerKey == null) {\n\t\t\tint iterationId = config.getIterationId();\n\t\t\tbrokerKey = getEnvironment().getJobID().toString() + '#' + iterationId + '#' +\n\t\t\t\t\tgetEnvironment().getTaskInfo().getIndexOfThisSubtask();\n\t\t}\n\t\treturn brokerKey;\n\t}\n\tprivate void reinstantiateDriver() throws Exception {\n\t\tif (this.driver instanceof ResettableDriver) {\n\t\t\tfinal ResettableDriver<?, ?> resDriver = (ResettableDriver<?, ?>) this.driver;\n\t\t\tresDriver.reset();\n\t\t} else {\n\t\t\tClass<? extends Driver<S, OT>> driverClass = this.config.getDriver();\n\t\t\tthis.driver = InstantiationUtil.instantiate(driverClass, Driver.class);\n\t\t\ttry {\n\t\t\t\tthis.driver.setup(this);\n\t\t\t}\n\t\t\tcatch (Throwable t) {\n\t\t\t\tthrow new Exception(\"The pact driver setup for '\" + this.getEnvironment().getTaskInfo().getTaskName() +\n\t\t\t\t\t\t\"' , caused an error: \" + t.getMessage(), t);\n\t\t\t}\n\t\t}\n\t}\n\tpublic RuntimeAggregatorRegistry getIterationAggregators() {\n\t\tif (this.iterationAggregators == null) {\n\t\t\tthis.iterationAggregators = IterationAggregatorBroker.instance().get(brokerKey());\n\t\t}\n\t\treturn this.iterationAggregators;\n\t}\n\tprotected void verifyEndOfSuperstepState() throws IOException {\n\t\t// sanity check that there is at least one iterative input reader\n\t\tif (this.iterativeInputs.length == 0 && this.iterativeBroadcastInputs.length == 0) {\n\t\t\tthrow new IllegalStateException(\"Error: Iterative task without a single iterative input.\");\n\t\t}\n\t\tfor (int inputNum : this.iterativeInputs) {\n\t\t\tMutableReader<?> reader = this.inputReaders[inputNum];\n\t\t\tif (!reader.isFinished()) {\n\t\t\t\tif (reader.hasReachedEndOfSuperstep()) {\n\t\t\t\t\treader.startNextSuperstep();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// need to read and drop all non-consumed data until we reach the end-of-superstep\n\t\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\t\tMutableObjectIterator<Object> inIter = (MutableObjectIterator<Object>) this.inputIterators[inputNum];\n\t\t\t\t\tObject o = this.inputSerializers[inputNum].getSerializer().createInstance();\n\t\t\t\t\twhile ((o = inIter.next(o)) != null) {\n\t\t\t\t\t}\n\t\t\t\t\tif (!reader.isFinished()) {\n\t\t\t\t\t\t// also reset the end-of-superstep state\n\t\t\t\t\t\treader.startNextSuperstep();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int inputNum : this.iterativeBroadcastInputs) {\n\t\t\tMutableReader<?> reader = this.broadcastInputReaders[inputNum];\n\t\t\tif (!reader.isFinished()) {\n\t\t\t\t// sanity check that the BC input is at the end of the superstep\n\t\t\t\tif (!reader.hasReachedEndOfSuperstep()) {\n\t\t\t\t\tthrow new IllegalStateException(\"An iterative broadcast input has not been fully consumed.\");\n\t\t\t\t}\n\t\t\t\treader.startNextSuperstep();\n\t\t\t}\n\t\t}\n\t}\n\t@Override\n\tpublic boolean terminationRequested() {\n\t\treturn this.terminationRequested;\n\t}\n\t@Override\n\tpublic void requestTermination() {\n\t\tthis.terminationRequested = true;\n\t}\n\t@Override\n\tpublic void cancel() throws Exception {\n\t\trequestTermination();\n\t\tsuper.cancel();\n\t}\n\t// -----------------------------------------------------------------------------------------------------------------\n\t// Iteration State Update Handling\n\t// -----------------------------------------------------------------------------------------------------------------\n\t/**\n\t * Creates a new {@link WorksetUpdateOutputCollector}.\n\t *\n\t * <p>This collector is used by {@link IterationIntermediateTask} or {@link IterationTailTask} to update the\n\t * workset.\n\t *\n\t * <p>If a non-null delegate is given, the new {@link Collector} will write to the solution set and also call\n\t * collect(T) of the delegate.\n\t *\n\t * @param delegate null -OR- the delegate on which to call collect() by the newly created collector\n\t * @return a new {@link WorksetUpdateOutputCollector}<fim_middle>// class below has no smell\n"}