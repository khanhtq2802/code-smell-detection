{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.pig.impl.util;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.io.SequenceInputStream;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.fs.FileStatus;\nimport org.apache.hadoop.fs.FileSystem;\nimport org.apache.hadoop.fs.Path;\nimport org.apache.hadoop.fs.PathFilter;\nimport org.apache.hadoop.io.compress.BZip2Codec;\nimport org.apache.hadoop.io.compress.GzipCodec;\nimport org.apache.hadoop.mapred.JobConf;\nimport org.apache.hadoop.mapreduce.Job;\nimport org.apache.hadoop.util.ShutdownHookManager;\nimport org.apache.pig.FileInputLoadFunc;\nimport org.apache.pig.FuncSpec;\nimport org.apache.pig.LoadFunc;\nimport org.apache.pig.PigConfiguration;\nimport org.apache.pig.PigException;\nimport org.apache.pig.ResourceSchema;\nimport org.apache.pig.ResourceSchema.ResourceFieldSchema;\nimport org.apache.pig.backend.executionengine.ExecException;\nimport org.apache.pig.backend.hadoop.datastorage.ConfigurationUtil;\nimport org.apache.pig.backend.hadoop.executionengine.mapReduceLayer.MRConfiguration;\nimport org.apache.pig.data.DataType;\nimport org.apache.pig.data.Tuple;\nimport org.apache.pig.impl.PigContext;\nimport org.apache.pig.impl.PigImplConstants;\nimport org.apache.pig.impl.io.InterStorage;\nimport org.apache.pig.impl.io.ReadToEndLoader;\nimport org.apache.pig.impl.io.SequenceFileInterStorage;\nimport org.apache.pig.impl.io.TFileStorage;\nimport org.apache.pig.impl.logicalLayer.schema.Schema;\nimport org.apache.pig.impl.logicalLayer.schema.Schema.FieldSchema;\nimport org.apache.pig.newplan.logical.relational.LogicalSchema;\nimport org.apache.pig.parser.ParserException;\nimport org.apache.pig.parser.QueryParserDriver;\nimport org.joda.time.DateTimeZone;\nimport com.google.common.collect.Lists;\nimport com.google.common.primitives.Longs;\n/**\n * Class with utility static methods\n */\npublic class Utils {\n    private static final Log log = LogFactory.getLog(Utils.class);\n    private static final Pattern JAVA_MAXHEAPSIZE_PATTERN = Pattern.compile(\"-Xmx(([0-9]+)[mMgG])\");\n    /**\n     * This method checks whether JVM vendor is IBM\n     * @return true if IBM JVM is being used\n     * false otherwise\n     */\n    public static boolean isVendorIBM() {\n    \t  return System.getProperty(\"java.vendor\").contains(\"IBM\");\n    }\n<fim_suffix>    public static boolean is64bitJVM() {\n        String arch = System.getProperties().getProperty(\"sun.arch.data.model\",\n                System.getProperty(\"com.ibm.vm.bitmode\"));\n        return arch != null && arch.equals(\"64\");\n    }\n    /**\n     * This method is a helper for classes to implement {@link java.lang.Object#equals(java.lang.Object)}\n     * checks if two objects are equals - two levels of checks are\n     * made - first if both are null or not null. If either is null,\n     * check is made whether both are null.\n     * If both are non null, equality also is checked if so indicated\n     * @param obj1 first object to be compared\n     * @param obj2 second object to be compared\n     * @param checkEquality flag to indicate whether object equality should\n     * be checked if obj1 and obj2 are non-null\n     * @return true if the two objects are equal\n     * false otherwise\n     */\n    public static boolean checkNullEquals(Object obj1, Object obj2, boolean checkEquality) {\n        if(obj1 == null || obj2 == null) {\n            return obj1 == obj2;\n        }\n        if(checkEquality) {\n            if(!obj1.equals(obj2)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * This method is a helper for classes to implement {@link java.lang.Object#equals(java.lang.Object)}\n     * The method checks whether the two arguments are both null or both not null and\n     * whether they are of the same class\n     * @param obj1 first object to compare\n     * @param obj2 second object to compare\n     * @return true if both objects are null or both are not null\n     * and if both are of the same class if not null\n     * false otherwise\n     */\n    public static boolean checkNullAndClass(Object obj1, Object obj2) {\n        if(checkNullEquals(obj1, obj2, false)) {\n            if(obj1 != null) {\n                return obj1.getClass() == obj2.getClass();\n            } else {\n                return true; // both obj1 and obj2 should be null\n            }\n        } else {\n            return false;\n        }\n    }\n    /**\n     * A helper function for retrieving the script schema set by the LOLoad\n     * function.\n     *\n     * @param loadFuncSignature\n     * @param conf\n     * @return Schema\n     * @throws IOException\n     */\n    public static Schema getScriptSchema(\n            String loadFuncSignature,\n            Configuration conf) throws IOException {\n        Schema scriptSchema = null;\n        String scriptField = conf.get(getScriptSchemaKey(loadFuncSignature));\n        if (scriptField != null) {\n            scriptSchema = (Schema) ObjectSerializer.deserialize(scriptField);\n        }\n        return scriptSchema;\n    }\n    public static String getScriptSchemaKey(String loadFuncSignature) {\n        return loadFuncSignature + \".scriptSchema\";\n    }\n    public static ResourceSchema getSchema(LoadFunc wrappedLoadFunc, String location, boolean checkExistence, Job job)\n            throws IOException {\n        Configuration conf = job.getConfiguration();\n        if (checkExistence) {\n            Path path = new Path(location);\n            if (!FileSystem.get(conf).exists(path)) {\n                // At compile time in batch mode, the file may not exist\n                // (such as intermediate file). Just return null - the\n                // same way as we would if we did not get a valid record\n                return null;\n            }\n        }\n        ReadToEndLoader loader = new ReadToEndLoader(wrappedLoadFunc, conf, location, 0);\n        // get the first record from the input file\n        // and figure out the schema from the data in\n        // the first record\n        Tuple t = loader.getNext();\n        if (t == null) {\n            // we couldn't get a valid record from the input\n            return null;\n        }\n        int numFields = t.size();\n        Schema s = new Schema();\n        for (int i = 0; i < numFields; i++) {\n            try {\n                s.add(DataType.determineFieldSchema(t.get(i)));\n            }\n            catch (Exception e) {\n                int errCode = 2104;\n                String msg = \"Error while determining schema of SequenceFileStorage data.\";\n                throw new ExecException(msg, errCode, PigException.BUG, e);\n            }\n        }\n        return new ResourceSchema(s);\n    }\n    /**\n     * @param schemaString a String representation of the Schema <b>without</b>\n     *                     any enclosing curly-braces.<b>Not</b> for use with\n     *                     <code>Schema#toString</code>\n     * @return Schema instance<fim_middle>// function below has no smell\n"}