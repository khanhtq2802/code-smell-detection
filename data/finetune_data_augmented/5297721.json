{"text": "<fim_prefix>/* \n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n * \n *   http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.parquet.thrift;\nimport java.nio.ByteBuffer;\nimport java.util.LinkedList;\nimport java.util.List;\nimport org.apache.thrift.TException;\nimport org.apache.thrift.protocol.TField;\nimport org.apache.thrift.protocol.TList;\nimport org.apache.thrift.protocol.TMap;\nimport org.apache.thrift.protocol.TMessage;\nimport org.apache.thrift.protocol.TProtocol;\nimport org.apache.thrift.protocol.TSet;\nimport org.apache.thrift.protocol.TStruct;\nimport org.apache.thrift.protocol.TType;\nimport org.apache.parquet.ParquetRuntimeException;\nimport org.apache.parquet.ShouldNeverHappenException;\nimport org.apache.parquet.thrift.struct.ThriftField;\nimport org.apache.parquet.thrift.struct.ThriftType;\nimport org.apache.parquet.thrift.struct.ThriftType.ListType;\nimport org.apache.parquet.thrift.struct.ThriftType.MapType;\nimport org.apache.parquet.thrift.struct.ThriftType.SetType;\nimport org.apache.parquet.thrift.struct.ThriftType.StructType;\nimport org.apache.parquet.thrift.struct.ThriftType.StructType.StructOrUnionType;\nimport org.apache.parquet.thrift.struct.ThriftTypeID;\n/**\n * Class to read from one protocol in a buffer and then write to another one\n * When there is an exception during reading, it's a skippable exception.\n * When schema is not compatible, the {@link SkippableException} will be thrown.\n * <p>\n * When there are fields in the data that are not defined in the schema, the fields will be ignored and the handler will\n * be notified through {@link FieldIgnoredHandler#handleFieldIgnored(org.apache.thrift.protocol.TField)}\n * and {@link FieldIgnoredHandler#handleRecordHasFieldIgnored()}\n */\npublic class BufferedProtocolReadToWrite implements ProtocolPipe {\n  private interface Action {\n    void write(TProtocol out) throws TException;\n    String toDebugString();\n  }\n  private static final Action STRUCT_END = new Action() {\n    @Override\n    public void write(TProtocol out) throws TException {\n      out.writeFieldStop();\n      out.writeStructEnd();\n    }\n    @Override\n    public String toDebugString() {\n      return \")\";\n    }\n  };\n  private static final Action FIELD_END = new Action() {\n    @Override\n    public void write(TProtocol out) throws TException {\n      out.writeFieldEnd();\n    }\n    @Override\n    public String toDebugString() {\n      return \";\";\n    }\n  };\n  private static final Action MAP_END = new Action() {\n    @Override\n    public void write(TProtocol out) throws TException {\n      out.writeMapEnd();\n    }\n    @Override\n    public String toDebugString() {\n      return \"]\";\n    }\n  };\n  private static final Action LIST_END = new Action() {\n    @Override\n    public void write(TProtocol out) throws TException {\n      out.writeListEnd();\n    }\n    @Override\n    public String toDebugString() {\n      return \"}\";\n    }\n  };\n  private static final Action SET_END = new Action() {\n    @Override\n    public void write(TProtocol out) throws TException {\n      out.writeSetEnd();\n    }\n    @Override\n    public String toDebugString() {\n      return \"*}\";\n    }\n  };\n  //error handler is global\n  private final FieldIgnoredHandler errorHandler;\n  private final StructType thriftType;\n  public BufferedProtocolReadToWrite(StructType thriftType) {\n    this(thriftType, null);\n  }\n<fim_suffix>  public BufferedProtocolReadToWrite(StructType thriftType, FieldIgnoredHandler errorHandler) {\n    super();\n    this.thriftType = thriftType;\n    this.errorHandler = errorHandler;\n  }\n  /**\n   * Reads one record from in and writes it to out.\n   * Exceptions encountered during reading are treated as skippable exceptions,\n   * {@link FieldIgnoredHandler} will be notified when registered.\n   *\n   * @param in  input protocol\n   * @param out output protocol\n   * @throws org.apache.thrift.TException         when an error happened while writing. Those are usually not recoverable\n   */\n  @Override\n  public void readOne(TProtocol in, TProtocol out) throws TException {\n    List<Action> buffer = new LinkedList<Action>();\n    try{\n        boolean hasFieldsIgnored = readOneStruct(in, buffer, thriftType);\n        if (hasFieldsIgnored) {\n          notifyRecordHasFieldIgnored();\n        }\n    } catch (Exception e) {\n      throw new SkippableException(error(\"Error while reading\", buffer), e);\n    }\n    try {\n      for (Action a : buffer) {\n        a.write(out);\n      }\n    } catch (Exception e) {\n      throw new TException(error(\"Can not write record\", buffer), e);\n    }\n  }\n  private void notifyRecordHasFieldIgnored() {\n    if (errorHandler != null) {\n      errorHandler.handleRecordHasFieldIgnored();\n    }\n  }\n  private void notifyIgnoredFieldsOfRecord(TField field) {\n    if (errorHandler != null) {\n      errorHandler.handleFieldIgnored(field);\n    }\n  }\n  private String error(String message, List<Action> buffer) {\n    StringBuilder sb = new StringBuilder(message).append(\": \");\n    for (Action action : buffer) {\n      sb.append(action.toDebugString());\n    }\n    return sb.toString();\n  }\n  /**\n   * @return true when all value is consumed, false when some values is ignored due to the field is not defined in expectedType\n   * @throws TException\n   */\n  private boolean readOneValue(TProtocol in, byte type, List<Action> buffer, ThriftType expectedType) throws TException {\n    if (expectedType != null && expectedType.getType().getSerializedThriftType() != type) {\n      throw new DecodingSchemaMismatchException(\"the data type does not match the expected thrift structure: expected \" + expectedType + \" got \" + typeName(type));\n    }\n    boolean hasFieldsIgnored = false;\n    switch (type) {\n    case TType.LIST:\n      hasFieldsIgnored = readOneList(in, buffer, (ListType)expectedType);\n      break;\n    case TType.MAP:\n      hasFieldsIgnored = readOneMap(in, buffer, (MapType)expectedType);\n      break;\n    case TType.SET:\n      hasFieldsIgnored = readOneSet(in, buffer, (SetType)expectedType);\n      break;\n    case TType.STRUCT:\n      hasFieldsIgnored = readOneStruct(in, buffer, (StructType)expectedType);\n      break;\n    case TType.STOP:\n      break;\n    case TType.BOOL:\n      final boolean bool = in.readBool();\n      writeBoolAction(buffer, bool);\n      break;\n    case TType.BYTE:\n      final byte b = in.readByte();\n      writeByteAction(buffer, b);\n      break;\n    case TType.DOUBLE:\n      final double d = in.readDouble();\n      writeDoubleAction(buffer, d);\n      break;\n    case TType.I16:\n      final short s = in.readI16();\n      writeShortAction(buffer, s);\n      break;\n    case TType.ENUM: // same as i32 => actually never seen in the protocol layer as enums are written as a i32 field\n    case TType.I32:\n      final int i = in.readI32();\n      checkEnum(expectedType,i);\n      writeIntAction(buffer, i);\n      break;\n    case TType.I64:\n      final long l = in.readI64();\n      writeLongAction(buffer, l);\n      break;\n    case TType.STRING:\n      final ByteBuffer bin = in.readBinary();\n      writeStringAction(buffer, bin);\n      break;\n    case TType.VOID:\n      break;\n    default:\n      throw new TException(\"Unknown type: \" + type);\n    }\n    return hasFieldsIgnored;\n  }\n  private void writeStringAction(List<Action> buffer, final ByteBuffer bin) {\n    buffer.add(new Action() {\n      @Override\n      public void write(TProtocol out) throws TException {\n        out.writeBinary(bin);\n      }\n      @Override\n      public String toDebugString() {\n        return String.valueOf(bin);\n      }\n    });\n  }\n  private void writeLongAction(List<Action> buffer, final long l) {<fim_middle>// function below has no smell\n"}