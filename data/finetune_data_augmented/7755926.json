{"text": "<fim_prefix>        String singlecmd = Joiner.on(separator).join(allcmds);\n        if (Boolean.TRUE.equals(getOptionalVal(props, PROP_RUN_AS_ROOT))) {\n            LOG.warn(\"Cannot run as root when executing as command; run as a script instead (will run as normal user): \"+singlecmd);\n        }\n        if (LOG.isTraceEnabled()) LOG.trace(\"Running command at {}: {}\", host, singlecmd);\n        Command result = acquire(new ExecAction(singlecmd, out, err, execTimeout));\n        if (LOG.isTraceEnabled()) LOG.trace(\"Running command at {} completed: exit code {}\", host, result.getExitStatus());\n        // can be null if no exit status is received (observed on kill `ps aux | grep thing-to-grep-for | awk {print $2}`\n        if (result.getExitStatus()==null) LOG.warn(\"Null exit status running at {}: {}\", host, singlecmd);\n        return asInt(result.getExitStatus(), -1);\n    }\n    protected void checkConnected() {\n        if (!isConnected()) {\n            throw new IllegalStateException(String.format(\"(%s) ssh not connected!\", toString()));\n        }\n    }\n    protected void backoffForAttempt(int retryAttempt, String message) {\n        backoffLimitedRetryHandler.imposeBackoffExponentialDelay(retryAttempt, message);\n    }\n    protected <T, C extends SshAction<T>> T acquire(C action) {\n        return acquire(action, sshTries, sshTriesTimeout == 0 ? Duration.PRACTICALLY_FOREVER : Duration.millis(sshTriesTimeout));\n    }\n    protected <T, C extends SshAction<T>> T acquire(C action, int sshTries, Duration sshTriesTimeout) {\n        Stopwatch stopwatch = Stopwatch.createStarted();\n        for (int i = 0; i < sshTries; i++) {\n            try {\n                action.clear();\n                if (LOG.isTraceEnabled()) LOG.trace(\">> ({}) acquiring {}\", toString(), action);\n                Stopwatch perfStopwatch = Stopwatch.createStarted();\n                T returnVal;\n                try {\n                    returnVal = action.create();\n                } catch (AssertionError e) {\n                    /*\n                     * TODO In net.schmizz.sshj.SSHClient.auth(SSHClient.java:204) throws AssertionError\n                     * if not connected. This can happen if another thread has called disconnect\n                     * concurrently. This is changed in sshj v0.9.0 to instead throw an IllegalStateException.\n                     * \n                     * For now, we'll retry. See \"TODO\" at top of class about synchronization.\n                     */\n                    throw new IllegalStateException(\"Problem in \"+toString()+\" for \"+action, e);\n                }\n                if (LOG.isTraceEnabled()) LOG.trace(\"<< ({}) acquired {}\", toString(), returnVal);\n                if (LOG.isTraceEnabled()) LOG.trace(\"SSH Performance: {} {} took {}\", new Object[] {\n                        sshClientConnection.getHostAndPort(), \n                        action.getClass().getSimpleName() != null ? action.getClass().getSimpleName() : action, \n                        Time.makeTimeStringRounded(perfStopwatch)});\n                return returnVal;\n            } catch (Exception e) {\n                // uninformative net.schmizz.sshj.connection.ConnectionException: \n                //    Request failed (reason=UNKNOWN) may mean remote Subsytem is disabled (e.g. for FTP)\n                // if key is missing, get a UserAuth error\n                String errorMessage = String.format(\"(%s) error acquiring %s\", toString(), action);\n                String fullMessage = String.format(\"%s (attempt %s/%s, in time %s/%s)\", \n                        errorMessage, (i+1), sshTries, Time.makeTimeStringRounded(stopwatch.elapsed(TimeUnit.MILLISECONDS)), \n                        (sshTriesTimeout.equals(Duration.PRACTICALLY_FOREVER) ? \"unlimited\" : Time.makeTimeStringRounded(sshTriesTimeout)));\n                try {\n                    disconnect();\n                } catch (Exception e2) {\n                    LOG.debug(\"<< (\"+toString()+\") error closing connection: \"+e+\" / \"+e2, e);\n                }\n                if (i + 1 == sshTries) {\n                    LOG.debug(\"<< {} (rethrowing, out of retries): {}\", fullMessage, e.getMessage());\n                    throw propagate(e, fullMessage + \"; out of retries\");\n                } else if (sshTriesTimeout.isShorterThan(stopwatch)) {\n                    LOG.debug(\"<< {} (rethrowing, out of time - max {}): {}\", new Object[] { fullMessage, Time.makeTimeStringRounded(sshTriesTimeout), e.getMessage() });\n                    throw new RuntimeTimeoutException(fullMessage + \"; out of time\", e);\n                } else {\n                    if (LOG.isDebugEnabled()) LOG.debug(\"<< {}: {}\", fullMessage, e.getMessage());\n                    backoffForAttempt(i + 1, errorMessage + \": \" + e.getMessage());\n                    if (action != sshClientConnection)\n                        connect();\n                    continue;\n                }\n            }\n        }\n        assert false : \"should not reach here\";\n        return null;\n    }\n    private final SshAction<SFTPClient> sftpConnection = new SshAction<SFTPClient>() {\n        private SFTPClient sftp;\n        @Override\n        public void clear() {\n            closeWhispering(sftp, this);\n            sftp = null;\n        }\n        @Override\n        public SFTPClient create() throws IOException {\n            checkConnected();\n            sftp = sshClientConnection.ssh.newSFTPClient();\n            return sftp;\n        }\n        @Override\n        public String toString() {\n            return \"SFTPClient()\";\n        }\n    };\n    private class GetFileAction implements SshAction<InputStream> {\n        private final String path;\n        private SFTPClient sftp;\n        GetFileAction(String path) {\n            this.path = checkNotNull(path, \"path\");\n        }\n        @Override\n        public void clear() throws IOException {\n            closeWhispering(sftp, this);\n            sftp = null;\n        }\n        @Override\n        public InputStream create() throws Exception {\n            sftp = acquire(sftpConnection);\n            return new CloseFtpChannelOnCloseInputStream(\n                    sftp.getSFTPEngine().open(path).getInputStream(), sftp);\n        }\n        @Override\n        public String toString() {\n            return \"Payload(path=[\" + path + \"])\";\n        }\n    }\n<fim_suffix>    private class PutFileAction implements SshAction<Void> {\n        // TODO support backup as a property?\n        private SFTPClient sftp;\n        private final String path;\n        private final int permissionsMask;\n        private final long lastModificationDate;\n        private final long lastAccessDate;\n        private final int uid;\n        private final Supplier<InputStream> contentsSupplier;\n        private final Integer length;\n        PutFileAction(Map<String,?> props, String path, Supplier<InputStream> contentsSupplier, long length) {\n            String permissions = getOptionalVal(props, PROP_PERMISSIONS);\n            long lastModificationDateVal = getOptionalVal(props, PROP_LAST_MODIFICATION_DATE);\n            long lastAccessDateVal = getOptionalVal(props, PROP_LAST_ACCESS_DATE);\n            if (lastAccessDateVal <= 0 ^ lastModificationDateVal <= 0) {\n                lastAccessDateVal = Math.max(lastAccessDateVal, lastModificationDateVal);\n                lastModificationDateVal = Math.max(lastAccessDateVal, lastModificationDateVal);\n            }\n            this.permissionsMask = Integer.parseInt(permissions, 8);\n            this.lastAccessDate = lastAccessDateVal;\n            this.lastModificationDate = lastModificationDateVal;\n            this.uid = getOptionalVal(props, PROP_OWNER_UID);\n            this.path = checkNotNull(path, \"path\");\n            this.contentsSupplier = checkNotNull(contentsSupplier, \"contents\");\n            this.length = Ints.checkedCast(checkNotNull((long)length, \"size\"));\n        }\n        @Override\n        public void clear() {\n            closeWhispering(sftp, this);\n            sftp = null;\n        }\n        @Override\n        public Void create() throws Exception {\n            final AtomicReference<InputStream> inputStreamRef = new AtomicReference<InputStream>();\n            sftp = acquire(sftpConnection);\n            try {\n                sftp.put(new InMemorySourceFile() {\n                    @Override public String getName() {\n                        return path;\n                    }\n                    @Override public long getLength() {\n                        return length;\n                    }\n                    @Override public InputStream getInputStream() throws IOException {\n                        InputStream contents = contentsSupplier.get();\n                        inputStreamRef.set(contents);\n                        return contents;\n                    }\n                }, path);\n                sftp.chmod(path, permissionsMask);\n                if (uid != -1) {\n                    sftp.chown(path, uid);\n                }\n                if (lastAccessDate > 0) {\n                    sftp.setattr(path, new FileAttributes.Builder()\n                            .withAtimeMtime(lastAccessDate, lastModificationDate)\n                            .build());\n                }\n            } finally {\n                closeWhispering(inputStreamRef.get(), this);\n            }\n            return null;\n        }\n        @Override\n        public String toString() {\n            return \"Put(path=[\" + path + \" \"+length+\"])\";\n        }\n    }<fim_middle>// class below has no smell\n"}