{"text": "<fim_prefix>\t\treturn createSharedEntityManager(emf, properties, synchronizedWithTransaction,\n\t\t\t\t(emIfc == null ? NO_ENTITY_MANAGER_INTERFACES : new Class<?>[] {emIfc}));\n\t}\n\t/**\n\t * Create a transactional EntityManager proxy for the given EntityManagerFactory.\n\t * @param emf the EntityManagerFactory to obtain EntityManagers from as needed\n\t * @param properties the properties to be passed into the\n\t * {@code createEntityManager} call (may be {@code null})\n\t * @param entityManagerInterfaces the interfaces to be implemented by the\n\t * EntityManager. Allows the addition or specification of proprietary interfaces.\n\t * @return a shareable transactional EntityManager proxy\n\t */\n\tpublic static EntityManager createSharedEntityManager(\n\t\t\tEntityManagerFactory emf, @Nullable Map<?, ?> properties, Class<?>... entityManagerInterfaces) {\n\t\treturn createSharedEntityManager(emf, properties, true, entityManagerInterfaces);\n\t}\n\t/**\n\t * Create a transactional EntityManager proxy for the given EntityManagerFactory.\n\t * @param emf the EntityManagerFactory to obtain EntityManagers from as needed\n\t * @param properties the properties to be passed into the\n\t * {@code createEntityManager} call (may be {@code null})\n\t * @param synchronizedWithTransaction whether to automatically join ongoing\n\t * transactions (according to the JPA 2.1 SynchronizationType rules)\n\t * @param entityManagerInterfaces the interfaces to be implemented by the\n\t * EntityManager. Allows the addition or specification of proprietary interfaces.\n\t * @return a shareable transactional EntityManager proxy\n\t * @since 4.0\n\t */\n\tpublic static EntityManager createSharedEntityManager(EntityManagerFactory emf, @Nullable Map<?, ?> properties,\n\t\t\tboolean synchronizedWithTransaction, Class<?>... entityManagerInterfaces) {\n\t\tClassLoader cl = null;\n\t\tif (emf instanceof EntityManagerFactoryInfo) {\n\t\t\tcl = ((EntityManagerFactoryInfo) emf).getBeanClassLoader();\n\t\t}\n\t\tClass<?>[] ifcs = new Class<?>[entityManagerInterfaces.length + 1];\n\t\tSystem.arraycopy(entityManagerInterfaces, 0, ifcs, 0, entityManagerInterfaces.length);\n\t\tifcs[entityManagerInterfaces.length] = EntityManagerProxy.class;\n\t\treturn (EntityManager) Proxy.newProxyInstance(\n\t\t\t\t(cl != null ? cl : SharedEntityManagerCreator.class.getClassLoader()),\n\t\t\t\tifcs, new SharedEntityManagerInvocationHandler(emf, properties, synchronizedWithTransaction));\n\t}\n\t/**\n\t * Invocation handler that delegates all calls to the current\n\t * transactional EntityManager, if any; else, it will fall back\n\t * to a newly created EntityManager per operation.\n\t */\n\t@SuppressWarnings(\"serial\")\n\tprivate static class SharedEntityManagerInvocationHandler implements InvocationHandler, Serializable {\n\t\tprivate final Log logger = LogFactory.getLog(getClass());\n\t\tprivate final EntityManagerFactory targetFactory;\n\t\t@Nullable\n\t\tprivate final Map<?, ?> properties;\n\t\tprivate final boolean synchronizedWithTransaction;\n\t\t@Nullable\n\t\tprivate transient volatile ClassLoader proxyClassLoader;\n\t\tpublic SharedEntityManagerInvocationHandler(\n\t\t\t\tEntityManagerFactory target, @Nullable Map<?, ?> properties, boolean synchronizedWithTransaction) {\n\t\t\tthis.targetFactory = target;\n\t\t\tthis.properties = properties;\n\t\t\tthis.synchronizedWithTransaction = synchronizedWithTransaction;\n\t\t\tinitProxyClassLoader();\n\t\t}\n\t\tprivate void initProxyClassLoader() {\n\t\t\tif (this.targetFactory instanceof EntityManagerFactoryInfo) {\n\t\t\t\tthis.proxyClassLoader = ((EntityManagerFactoryInfo) this.targetFactory).getBeanClassLoader();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.proxyClassLoader = this.targetFactory.getClass().getClassLoader();\n\t\t\t}\n\t\t}\n<fim_suffix>\t\t@Override\n\t\t@Nullable\n\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n\t\t\t// Invocation on EntityManager interface coming in...\n\t\t\tif (method.getName().equals(\"equals\")) {\n\t\t\t\t// Only consider equal when proxies are identical.\n\t\t\t\treturn (proxy == args[0]);\n\t\t\t}\n\t\t\telse if (method.getName().equals(\"hashCode\")) {\n\t\t\t\t// Use hashCode of EntityManager proxy.\n\t\t\t\treturn hashCode();\n\t\t\t}\n\t\t\telse if (method.getName().equals(\"toString\")) {\n\t\t\t\t// Deliver toString without touching a target EntityManager.\n\t\t\t\treturn \"Shared EntityManager proxy for target factory [\" + this.targetFactory + \"]\";\n\t\t\t}\n\t\t\telse if (method.getName().equals(\"getEntityManagerFactory\")) {\n\t\t\t\t// JPA 2.0: return EntityManagerFactory without creating an EntityManager.\n\t\t\t\treturn this.targetFactory;\n\t\t\t}\n\t\t\telse if (method.getName().equals(\"getCriteriaBuilder\") || method.getName().equals(\"getMetamodel\")) {\n\t\t\t\t// JPA 2.0: return EntityManagerFactory's CriteriaBuilder/Metamodel (avoid creation of EntityManager)\n\t\t\t\ttry {\n\t\t\t\t\treturn EntityManagerFactory.class.getMethod(method.getName()).invoke(this.targetFactory);\n\t\t\t\t}\n\t\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\t\tthrow ex.getTargetException();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (method.getName().equals(\"unwrap\")) {\n\t\t\t\t// JPA 2.0: handle unwrap method - could be a proxy match.\n\t\t\t\tClass<?> targetClass = (Class<?>) args[0];\n\t\t\t\tif (targetClass != null && targetClass.isInstance(proxy)) {\n\t\t\t\t\treturn proxy;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (method.getName().equals(\"isOpen\")) {\n\t\t\t\t// Handle isOpen method: always return true.\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (method.getName().equals(\"close\")) {\n\t\t\t\t// Handle close method: suppress, not valid.\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\telse if (method.getName().equals(\"getTransaction\")) {\n\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\"Not allowed to create transaction on shared EntityManager - \" +\n\t\t\t\t\t\t\"use Spring transactions or EJB CMT instead\");\n\t\t\t}\n\t\t\t// Determine current EntityManager: either the transactional one\n\t\t\t// managed by the factory or a temporary one for the given invocation.\n\t\t\tEntityManager target = EntityManagerFactoryUtils.doGetTransactionalEntityManager(\n\t\t\t\t\tthis.targetFactory, this.properties, this.synchronizedWithTransaction);\n\t\t\tif (method.getName().equals(\"getTargetEntityManager\")) {\n\t\t\t\t// Handle EntityManagerProxy interface.\n\t\t\t\tif (target == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"No transactional EntityManager available\");\n\t\t\t\t}\n\t\t\t\treturn target;\n\t\t\t}\n\t\t\telse if (method.getName().equals(\"unwrap\")) {\n\t\t\t\tClass<?> targetClass = (Class<?>) args[0];\n\t\t\t\tif (targetClass == null) {\n\t\t\t\t\treturn (target != null ? target : proxy);\n\t\t\t\t}\n\t\t\t\t// We need a transactional target now.\n\t\t\t\tif (target == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"No transactional EntityManager available\");\n\t\t\t\t}\n\t\t\t\t// Still perform unwrap call on target EntityManager.\n\t\t\t}\n\t\t\telse if (transactionRequiringMethods.contains(method.getName())) {\n\t\t\t\t// We need a transactional target now, according to the JPA spec.\n\t\t\t\t// Otherwise, the operation would get accepted but remain unflushed...\n\t\t\t\tif (target == null || (!TransactionSynchronizationManager.isActualTransactionActive() &&\n\t\t\t\t\t\t!target.getTransaction().isActive())) {\n\t\t\t\t\tthrow new TransactionRequiredException(\"No EntityManager with actual transaction available \" +\n\t\t\t\t\t\t\t\"for current thread - cannot reliably process '\" + method.getName() + \"' call\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Regular EntityManager operations.\n\t\t\tboolean isNewEm = false;\n\t\t\tif (target == null) {\n\t\t\t\tlogger.debug(\"Creating new EntityManager for shared EntityManager invocation\");\n\t\t\t\ttarget = (!CollectionUtils.isEmpty(this.properties) ?\n\t\t\t\t\t\tthis.targetFactory.createEntityManager(this.properties) :\n\t\t\t\t\t\tthis.targetFactory.createEntityManager());\n\t\t\t\tisNewEm = true;\n\t\t\t}\n\t\t\t// Invoke method on current EntityManager.\n\t\t\ttry {\n\t\t\t\tObject result = method.invoke(target, args);\n\t\t\t\tif (result instanceof Query) {\n\t\t\t\t\tQuery query = (Query) result;\n\t\t\t\t\tif (isNewEm) {\n\t\t\t\t\t\tClass<?>[] ifcs = ClassUtils.getAllInterfacesForClass(query.getClass(), this.proxyClassLoader);\n\t\t\t\t\t\tresult = Proxy.newProxyInstance(this.proxyClassLoader, ifcs,\n\t\t\t\t\t\t\t\tnew DeferredQueryInvocationHandler(query, target));\n\t\t\t\t\t\tisNewEm = false;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tEntityManagerFactoryUtils.applyTransactionTimeout(query, this.targetFactory);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tcatch (InvocationTargetException ex) {\n\t\t\t\tthrow ex.getTargetException();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (isNewEm) {\n\t\t\t\t\tEntityManagerFactoryUtils.closeEntityManager(target);\n\t\t\t\t}\n\t\t\t}\n\t\t}<fim_middle>// function below is long method\n"}