{"text": "<fim_prefix>        // case '/': // we check start of comment in the caller where we\n        //              can peek ahead for the following slash or asterisk\n            return true;\n        default:\n            return false;\n        }\n    }\n    public static boolean isDigit(int codePoint, int radix)\n    {\n        switch (codePoint) {\n        case '0': case '1': case '2': case '3': case '4':\n        case '5': case '6': case '7':\n            return (radix == 8 || radix == 10 || radix == 16);\n        case '8': case '9':\n            return (radix == 10 || radix == 16);\n        case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n        case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n            return (radix == 16);\n        }\n        return false;\n    }\n    public static boolean isIdentifierStart(int codePoint) {\n        return PrivateIonTextAppender.isIdentifierStart(codePoint);\n    }\n    public static boolean isIdentifierPart(int codePoint) {\n        return PrivateIonTextAppender.isIdentifierPart(codePoint);\n    }\n    public static boolean isOperatorPart(int codePoint) {\n        return PrivateIonTextAppender.isOperatorPart(codePoint);\n    }\n    /**\n     * Determines whether the text of a symbol represents an identifier, an\n     * operator, or a symbol that always requires (single) quotes.\n     *\n     * @param symbol must be a non-empty string.\n     *\n     * @return the variant of the symbol.\n     *\n     * @throws NullPointerException\n     *         if <code>symbol</code> is <code>null</code>.\n     */\n    public static SymbolVariant symbolVariant(CharSequence symbol)\n    {\n        int length = symbol.length(); // acts as null check\n        // If the symbol's text matches an Ion keyword or it's an empty symbol, we must quote it.\n        // Eg, the symbol 'false' and '' must be rendered quoted.\n        if(length == 0 || isIdentifierKeyword(symbol))\n        {\n            return SymbolVariant.QUOTED;\n        }\n        char c = symbol.charAt(0);\n        // Surrogates are neither identifierStart nor operatorPart, so the\n        // first one we hit will fall through and return QUOTED.\n        // TODO test that\n        if (isIdentifierStart(c))\n        {\n            for (int ii = 0; ii < length; ii++) {\n                c = symbol.charAt(ii);\n                if ((c == '\\'' || c < 32 || c > 126)\n                    || !isIdentifierPart(c))\n                {\n                    return SymbolVariant.QUOTED;\n                }\n            }\n            return SymbolVariant.IDENTIFIER;\n        }\n        if (isOperatorPart(c))\n        {\n            for (int ii = 0; ii < length; ii++) {\n                c = symbol.charAt(ii);\n                // We don't need to look for escapes since all\n                // operator characters are ASCII.\n                if (!isOperatorPart(c)) {\n                    return SymbolVariant.QUOTED;\n                }\n            }\n            return SymbolVariant.OPERATOR;\n        }\n        return SymbolVariant.QUOTED;\n    }\n    //=========================================================================\n    /**\n     * Prints a single Unicode code point for use in an ASCII-safe Ion string.\n     *\n     * @param out the stream to receive the data.\n     * @param codePoint a Unicode code point.\n     */\n    public static void printStringCodePoint(Appendable out, int codePoint)\n        throws IOException\n    {\n        printCodePoint(out, codePoint, EscapeMode.ION_STRING);\n    }\n    /**\n     * Prints a single Unicode code point for use in an ASCII-safe Ion symbol.\n     *\n     * @param out the stream to receive the data.\n     * @param codePoint a Unicode code point.\n     */\n    public static void printSymbolCodePoint(Appendable out, int codePoint)\n        throws IOException\n    {\n        printCodePoint(out, codePoint, EscapeMode.ION_SYMBOL);\n    }\n    /**\n     * Prints a single Unicode code point for use in an ASCII-safe JSON string.\n     *\n     * @param out the stream to receive the data.\n     * @param codePoint a Unicode code point.\n     */\n    public static void printJsonCodePoint(Appendable out, int codePoint)\n        throws IOException\n    {\n        // JSON only allows double-quote strings.\n        printCodePoint(out, codePoint, EscapeMode.JSON);\n    }\n    /**\n     * Prints a single code point, ASCII safe.\n     */\n    private static void printCodePoint(Appendable out, int c, EscapeMode mode)\n        throws IOException\n    {\n        // JSON only allows uHHHH numeric escapes.\n        switch (c) {\n            case 0:\n                out.append(mode == EscapeMode.JSON ? \"\\\\u0000\" : \"\\\\0\");\n                return;\n            case '\\t':\n                out.append(\"\\\\t\");\n                return;\n            case '\\n':\n                if (mode == EscapeMode.ION_LONG_STRING) {\n                    out.append('\\n');\n                }\n                else {\n                    out.append(\"\\\\n\");\n                }\n                return;\n            case '\\r':\n                out.append(\"\\\\r\");\n                return;\n            case '\\f':\n                out.append(\"\\\\f\");\n                return;\n            case '\\u0008':\n                out.append(\"\\\\b\");\n                return;\n            case '\\u0007':\n                out.append(mode == EscapeMode.JSON ? \"\\\\u0007\" : \"\\\\a\");\n                return;\n            case '\\u000B':\n                out.append(mode == EscapeMode.JSON ? \"\\\\u000b\" : \"\\\\v\");\n                return;\n            case '\\\"':\n                if (mode == EscapeMode.JSON || mode == EscapeMode.ION_STRING) {\n                    out.append(\"\\\\\\\"\");\n                    return;\n                }\n                break; // Treat as normal code point for long string or symbol.\n            case '\\'':\n                if (mode == EscapeMode.ION_SYMBOL ||\n                    mode == EscapeMode.ION_LONG_STRING)\n                {\n                    out.append(\"\\\\\\'\");\n                    return;\n                }\n                break;\n            case '\\\\':\n                out.append(\"\\\\\\\\\");\n                return;\n            default:\n                break;\n        }\n        if (c < 32) {\n            if (mode == EscapeMode.JSON) {\n                printCodePointAsFourHexDigits(out, c);\n            }\n            else {\n                printCodePointAsTwoHexDigits(out, c);\n            }\n        }\n        else if (c < 0x7F) {  // Printable ASCII\n            out.append((char)c);\n        }\n        else if (c <= 0xFF) {\n            if (mode == EscapeMode.JSON) {\n                printCodePointAsFourHexDigits(out, c);\n            }\n            else {\n                printCodePointAsTwoHexDigits(out, c);\n            }\n        }\n        else if (c <= 0xFFFF) {\n            printCodePointAsFourHexDigits(out, c);\n        }\n        else {\n            if (mode == EscapeMode.JSON) {\n                // JSON does not have a \\Uxxxxyyyy escape, surrogates\n                // must be used as per RFC-4627\n                //\n                // http://www.ietf.org/rfc/rfc4627.txt\n                // [...]\n                //   To escape an extended character that is not in the Basic Multilingual\n                //   Plane, the character is represented as a twelve-character sequence,\n                //   encoding the UTF-16 surrogate pair.  So, for example, a string\n                //   containing only the G clef character (U+1D11E) may be represented as\n                //   \"\\uD834\\uDD1E\".\n                // [...]\n                printCodePointAsSurrogatePairHexDigits(out, c);\n            }\n            else {\n                printCodePointAsEightHexDigits(out, c);\n            }\n        }\n    }\n    /**\n     * Generates a two-digit hex escape sequence,\n     * {@code \"\\x}<i>{@code HH}</i>{@code \"},\n     * using lower-case for alphabetics.\n     */\n    private static void printCodePointAsTwoHexDigits(Appendable out, int c)\n        throws IOException\n    {\n        String s = Integer.toHexString(c);\n        out.append(\"\\\\x\");\n        if (s.length() < 2) {\n            out.append(ZERO_PADDING[2-s.length()]);\n        }\n        out.append(s);\n    }\n    /**\n     * Generates a four-digit hex escape sequence,\n     * {@code \"\\}{@code u}<i>{@code HHHH}</i>{@code \"},\n     * using lower-case for alphabetics.\n     */\n<fim_suffix>    private static void printCodePointAsFourHexDigits(Appendable out, int c)\n        throws IOException\n    {\n        String s = Integer.toHexString(c);\n        out.append(\"\\\\u\");\n        out.append(ZERO_PADDING[4-s.length()]);\n        out.append(s);\n    }<fim_middle>// function below has no smell\n"}