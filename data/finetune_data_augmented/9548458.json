{"text": "<fim_prefix> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.hadoop.metrics2.sink.ganglia;\nimport java.io.IOException;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Set;\nimport org.apache.commons.configuration2.SubsetConfiguration;\nimport org.apache.commons.configuration2.convert.DefaultListDelimiterHandler;\nimport org.apache.hadoop.classification.InterfaceAudience;\nimport org.apache.hadoop.metrics2.AbstractMetric;\nimport org.apache.hadoop.metrics2.MetricsException;\nimport org.apache.hadoop.metrics2.MetricsRecord;\nimport org.apache.hadoop.metrics2.MetricsTag;\nimport org.apache.hadoop.metrics2.impl.MsInfo;\nimport org.apache.hadoop.metrics2.util.MetricsCache;\nimport org.apache.hadoop.metrics2.util.MetricsCache.Record;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n/**\n * This code supports Ganglia 3.0\n * \n */\n<fim_suffix>public class GangliaSink30 extends AbstractGangliaSink {\n  public final Logger LOG = LoggerFactory.getLogger(this.getClass());\n  private static final String TAGS_FOR_PREFIX_PROPERTY_PREFIX = \"tagsForPrefix.\";\n  private MetricsCache metricsCache = new MetricsCache();\n  // a key with a NULL value means ALL\n  private Map<String,Set<String>> useTagsMap = new HashMap<String,Set<String>>();\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public void init(SubsetConfiguration conf) {\n    super.init(conf);\n    conf.setListDelimiterHandler(new DefaultListDelimiterHandler(','));\n    Iterator<String> it = (Iterator<String>) conf.getKeys();\n    while (it.hasNext()) {\n      String propertyName = it.next();\n      if (propertyName.startsWith(TAGS_FOR_PREFIX_PROPERTY_PREFIX)) {\n        String contextName = propertyName.substring(TAGS_FOR_PREFIX_PROPERTY_PREFIX.length());\n        String[] tags = conf.getStringArray(propertyName);\n        boolean useAllTags = false;\n        Set<String> set = new HashSet<>();\n        for (String tag : tags) {\n          tag = tag.trim();\n          useAllTags |= tag.equals(\"*\");\n          if (tag.length() > 0) {\n            set.add(tag);\n          }\n        }\n        if (useAllTags) {\n          set = null;\n        }\n        useTagsMap.put(contextName, set);\n      }\n    }\n  }\n  @InterfaceAudience.Private\n  public void appendPrefix(MetricsRecord record, StringBuilder sb) {\n    String contextName = record.context();\n    Collection<MetricsTag> tags = record.tags();\n    if (useTagsMap.containsKey(contextName)) {\n      Set<String> useTags = useTagsMap.get(contextName);\n      for (MetricsTag t : tags) {\n        if (useTags == null || useTags.contains(t.name())) {\n          // the context is always skipped here because it is always added\n          // the hostname is always skipped to avoid case-mismatches \n          // from different DNSes.\n          if (t.info() != MsInfo.Context && t.info() != MsInfo.Hostname && t.value() != null) {\n            sb.append('.').append(t.name()).append('=').append(t.value());\n          }\n        }\n      }\n    }          \n  }\n  @Override\n  public void putMetrics(MetricsRecord record) {\n    // The method handles both cases whether Ganglia support dense publish\n    // of metrics of sparse (only on change) publish of metrics\n    try {\n      String recordName = record.name();\n      String contextName = record.context();\n      StringBuilder sb = new StringBuilder();\n      sb.append(contextName);\n      sb.append('.');\n      sb.append(recordName);\n      appendPrefix(record, sb);\n      String groupName = sb.toString();\n      sb.append('.');\n      int sbBaseLen = sb.length();\n      String type = null;\n      GangliaSlope slopeFromMetric = null;\n      GangliaSlope calculatedSlope = null;\n      Record cachedMetrics = null;\n      resetBuffer();  // reset the buffer to the beginning\n      if (!isSupportSparseMetrics()) {\n        // for sending dense metrics, update metrics cache\n        // and get the updated data\n        cachedMetrics = metricsCache.update(record);\n        if (cachedMetrics != null && cachedMetrics.metricsEntrySet() != null) {\n          for (Map.Entry<String, AbstractMetric> entry : cachedMetrics\n              .metricsEntrySet()) {\n            AbstractMetric metric = entry.getValue();\n            sb.append(metric.name());\n            String name = sb.toString();\n            // visit the metric to identify the Ganglia type and\n            // slope\n            metric.visit(gangliaMetricVisitor);\n            type = gangliaMetricVisitor.getType();\n            slopeFromMetric = gangliaMetricVisitor.getSlope();\n            GangliaConf gConf = getGangliaConfForMetric(name);\n            calculatedSlope = calculateSlope(gConf, slopeFromMetric);\n            // send metric to Ganglia\n            emitMetric(groupName, name, type, metric.value().toString(), gConf,\n                calculatedSlope);\n            // reset the length of the buffer for next iteration\n            sb.setLength(sbBaseLen);\n          }\n        }\n      } else {\n        // we support sparse updates\n        Collection<AbstractMetric> metrics = (Collection<AbstractMetric>) record\n            .metrics();\n        if (metrics.size() > 0) {\n          // we got metrics. so send the latest\n          for (AbstractMetric metric : record.metrics()) {\n            sb.append(metric.name());\n            String name = sb.toString();\n            // visit the metric to identify the Ganglia type and\n            // slope\n            metric.visit(gangliaMetricVisitor);\n            type = gangliaMetricVisitor.getType();\n            slopeFromMetric = gangliaMetricVisitor.getSlope();\n            GangliaConf gConf = getGangliaConfForMetric(name);\n            calculatedSlope = calculateSlope(gConf, slopeFromMetric);\n            // send metric to Ganglia\n            emitMetric(groupName, name, type, metric.value().toString(), gConf,\n                calculatedSlope);\n            // reset the length of the buffer for next iteration\n            sb.setLength(sbBaseLen);\n          }\n        }\n      }\n    } catch (IOException io) {\n      throw new MetricsException(\"Failed to putMetrics\", io);\n    }\n  }\n  // Calculate the slope from properties and metric\n  private GangliaSlope calculateSlope(GangliaConf gConf,\n      GangliaSlope slopeFromMetric) {\n    if (gConf.getSlope() != null) {\n      // if slope has been specified in properties, use that\n      return gConf.getSlope();\n    } else if (slopeFromMetric != null) {\n      // slope not specified in properties, use derived from Metric\n      return slopeFromMetric;\n    } else {\n      return DEFAULT_SLOPE;\n    }\n  }\n  /**\n   * The method sends metrics to Ganglia servers. The method has been taken from\n   * org.apache.hadoop.metrics.ganglia.GangliaContext30 with minimal changes in\n   * order to keep it in sync.\n   * @param groupName The group name of the metric\n   * @param name The metric name\n   * @param type The type of the metric\n   * @param value The value of the metric\n   * @param gConf The GangliaConf for this metric\n   * @param gSlope The slope for this metric\n   * @throws IOException\n   */\n  protected void emitMetric(String groupName, String name, String type,\n      String value, GangliaConf gConf, GangliaSlope gSlope) throws IOException {\n    if (name == null) {\n      LOG.warn(\"Metric was emitted with no name.\");\n      return;\n    } else if (value == null) {\n      LOG.warn(\"Metric name \" + name + \" was emitted with a null value.\");\n      return;\n    } else if (type == null) {\n      LOG.warn(\"Metric name \" + name + \", value \" + value + \" has no type.\");\n      return;\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Emitting metric \" + name + \", type \" + type + \", value \"\n          + value + \", slope \" + gSlope.name() + \" from hostname \"\n          + getHostName());\n    }\n    xdr_int(0); // metric_user_defined\n    xdr_string(type);\n    xdr_string(name);\n    xdr_string(value);\n    xdr_string(gConf.getUnits());\n    xdr_int(gSlope.ordinal());\n    xdr_int(gConf.getTmax());\n    xdr_int(gConf.getDmax());\n    // send the metric to Ganglia hosts\n    emitToGangliaHosts();\n  }\n}<fim_middle>// class below has no smell\n"}