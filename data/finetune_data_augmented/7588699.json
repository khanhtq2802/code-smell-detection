{"text": "<fim_prefix>\t\t}\n\t\tif (metadata instanceof StandardMethodMetadata) {\n\t\t\tbeanDef.setResolvedFactoryMethod(((StandardMethodMetadata) metadata).getIntrospectedMethod());\n\t\t}\n\t\tbeanDef.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_CONSTRUCTOR);\n\t\tbeanDef.setAttribute(org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor.\n\t\t\t\tSKIP_REQUIRED_CHECK_ATTRIBUTE, Boolean.TRUE);\n\t\tAnnotationConfigUtils.processCommonDefinitionAnnotations(beanDef, metadata);\n\t\tAutowire autowire = bean.getEnum(\"autowire\");\n\t\tif (autowire.isAutowire()) {\n\t\t\tbeanDef.setAutowireMode(autowire.value());\n\t\t}\n\t\tboolean autowireCandidate = bean.getBoolean(\"autowireCandidate\");\n\t\tif (!autowireCandidate) {\n\t\t\tbeanDef.setAutowireCandidate(false);\n\t\t}\n\t\tString initMethodName = bean.getString(\"initMethod\");\n\t\tif (StringUtils.hasText(initMethodName)) {\n\t\t\tbeanDef.setInitMethodName(initMethodName);\n\t\t}\n\t\tString destroyMethodName = bean.getString(\"destroyMethod\");\n\t\tbeanDef.setDestroyMethodName(destroyMethodName);\n\t\t// Consider scoping\n\t\tScopedProxyMode proxyMode = ScopedProxyMode.NO;\n\t\tAnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(metadata, Scope.class);\n\t\tif (attributes != null) {\n\t\t\tbeanDef.setScope(attributes.getString(\"value\"));\n\t\t\tproxyMode = attributes.getEnum(\"proxyMode\");\n\t\t\tif (proxyMode == ScopedProxyMode.DEFAULT) {\n\t\t\t\tproxyMode = ScopedProxyMode.NO;\n\t\t\t}\n\t\t}\n\t\t// Replace the original bean definition with the target one, if necessary\n\t\tBeanDefinition beanDefToRegister = beanDef;\n\t\tif (proxyMode != ScopedProxyMode.NO) {\n\t\t\tBeanDefinitionHolder proxyDef = ScopedProxyCreator.createScopedProxy(\n\t\t\t\t\tnew BeanDefinitionHolder(beanDef, beanName), this.registry,\n\t\t\t\t\tproxyMode == ScopedProxyMode.TARGET_CLASS);\n\t\t\tbeanDefToRegister = new ConfigurationClassBeanDefinition(\n\t\t\t\t\t(RootBeanDefinition) proxyDef.getBeanDefinition(), configClass, metadata);\n\t\t}\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(String.format(\"Registering bean definition for @Bean method %s.%s()\",\n\t\t\t\t\tconfigClass.getMetadata().getClassName(), beanName));\n\t\t}\n\t\tthis.registry.registerBeanDefinition(beanName, beanDefToRegister);\n\t}\n\tprotected boolean isOverriddenByExistingDefinition(BeanMethod beanMethod, String beanName) {\n\t\tif (!this.registry.containsBeanDefinition(beanName)) {\n\t\t\treturn false;\n\t\t}\n\t\tBeanDefinition existingBeanDef = this.registry.getBeanDefinition(beanName);\n\t\t// Is the existing bean definition one that was created from a configuration class?\n\t\t// -> allow the current bean method to override, since both are at second-pass level.\n\t\t// However, if the bean method is an overloaded case on the same configuration class,\n\t\t// preserve the existing bean definition.\n\t\tif (existingBeanDef instanceof ConfigurationClassBeanDefinition) {\n\t\t\tConfigurationClassBeanDefinition ccbd = (ConfigurationClassBeanDefinition) existingBeanDef;\n\t\t\tif (ccbd.getMetadata().getClassName().equals(\n\t\t\t\t\tbeanMethod.getConfigurationClass().getMetadata().getClassName())) {\n\t\t\t\tif (ccbd.getFactoryMethodMetadata().getMethodName().equals(ccbd.getFactoryMethodName())) {\n\t\t\t\t\tccbd.setNonUniqueFactoryMethodName(ccbd.getFactoryMethodMetadata().getMethodName());\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t// A bean definition resulting from a component scan can be silently overridden\n\t\t// by an @Bean method, as of 4.2...\n\t\tif (existingBeanDef instanceof ScannedGenericBeanDefinition) {\n\t\t\treturn false;\n\t\t}\n\t\t// Has the existing bean definition bean marked as a framework-generated bean?\n\t\t// -> allow the current bean method to override it, since it is application-level\n\t\tif (existingBeanDef.getRole() > BeanDefinition.ROLE_APPLICATION) {\n\t\t\treturn false;\n\t\t}\n\t\t// At this point, it's a top-level override (probably XML), just having been parsed\n\t\t// before configuration class processing kicks in...\n\t\tif (this.registry instanceof DefaultListableBeanFactory &&\n\t\t\t\t!((DefaultListableBeanFactory) this.registry).isAllowBeanDefinitionOverriding()) {\n\t\t\tthrow new BeanDefinitionStoreException(beanMethod.getConfigurationClass().getResource().getDescription(),\n\t\t\t\t\tbeanName, \"@Bean definition illegally overridden by existing bean definition: \" + existingBeanDef);\n\t\t}\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(String.format(\"Skipping bean definition for %s: a definition for bean '%s' \" +\n\t\t\t\t\t\"already exists. This top-level bean definition is considered as an override.\",\n\t\t\t\t\tbeanMethod, beanName));\n\t\t}\n\t\treturn true;\n\t}\n\tprivate void loadBeanDefinitionsFromImportedResources(\n\t\t\tMap<String, Class<? extends BeanDefinitionReader>> importedResources) {\n\t\tMap<Class<?>, BeanDefinitionReader> readerInstanceCache = new HashMap<>();\n\t\timportedResources.forEach((resource, readerClass) -> {\n\t\t\t// Default reader selection necessary?\n\t\t\tif (BeanDefinitionReader.class == readerClass) {\n\t\t\t\tif (StringUtils.endsWithIgnoreCase(resource, \".groovy\")) {\n\t\t\t\t\t// When clearly asking for Groovy, that's what they'll get...\n\t\t\t\t\treaderClass = GroovyBeanDefinitionReader.class;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Primarily \".xml\" files but for any other extension as well\n\t\t\t\t\treaderClass = XmlBeanDefinitionReader.class;\n\t\t\t\t}\n\t\t\t}\n\t\t\tBeanDefinitionReader reader = readerInstanceCache.get(readerClass);\n\t\t\tif (reader == null) {\n\t\t\t\ttry {\n\t\t\t\t\t// Instantiate the specified BeanDefinitionReader\n\t\t\t\t\treader = readerClass.getConstructor(BeanDefinitionRegistry.class).newInstance(this.registry);\n\t\t\t\t\t// Delegate the current ResourceLoader to it if possible\n\t\t\t\t\tif (reader instanceof AbstractBeanDefinitionReader) {\n\t\t\t\t\t\tAbstractBeanDefinitionReader abdr = ((AbstractBeanDefinitionReader) reader);\n\t\t\t\t\t\tabdr.setResourceLoader(this.resourceLoader);\n\t\t\t\t\t\tabdr.setEnvironment(this.environment);\n\t\t\t\t\t}\n\t\t\t\t\treaderInstanceCache.put(readerClass, reader);\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\t\"Could not instantiate BeanDefinitionReader class [\" + readerClass.getName() + \"]\");\n\t\t\t\t}\n\t\t\t}\n\t\t\t// TODO SPR-6310: qualify relative path locations as done in AbstractContextLoader.modifyLocations\n\t\t\treader.loadBeanDefinitions(resource);\n\t\t});\n\t}\n\tprivate void loadBeanDefinitionsFromRegistrars(Map<ImportBeanDefinitionRegistrar, AnnotationMetadata> registrars) {\n\t\tregistrars.forEach((registrar, metadata) ->\n\t\t\t\tregistrar.registerBeanDefinitions(metadata, this.registry, this.importBeanNameGenerator));\n\t}\n\t/**\n\t * {@link RootBeanDefinition} marker subclass used to signify that a bean definition\n\t * was created from a configuration class as opposed to any other configuration source.\n\t * Used in bean overriding cases where it's necessary to determine whether the bean\n\t * definition was created externally.\n\t */\n\t@SuppressWarnings(\"serial\")\n\tprivate static class ConfigurationClassBeanDefinition extends RootBeanDefinition implements AnnotatedBeanDefinition {\n\t\tprivate final AnnotationMetadata annotationMetadata;\n\t\tprivate final MethodMetadata factoryMethodMetadata;\n\t\tpublic ConfigurationClassBeanDefinition(ConfigurationClass configClass, MethodMetadata beanMethodMetadata) {\n\t\t\tthis.annotationMetadata = configClass.getMetadata();\n\t\t\tthis.factoryMethodMetadata = beanMethodMetadata;\n\t\t\tsetLenientConstructorResolution(false);\n\t\t}\n\t\tpublic ConfigurationClassBeanDefinition(\n\t\t\t\tRootBeanDefinition original, ConfigurationClass configClass, MethodMetadata beanMethodMetadata) {\n\t\t\tsuper(original);\n\t\t\tthis.annotationMetadata = configClass.getMetadata();\n\t\t\tthis.factoryMethodMetadata = beanMethodMetadata;\n\t\t}\n\t\tprivate ConfigurationClassBeanDefinition(ConfigurationClassBeanDefinition original) {\n\t\t\tsuper(original);\n\t\t\tthis.annotationMetadata = original.annotationMetadata;\n\t\t\tthis.factoryMethodMetadata = original.factoryMethodMetadata;\n\t\t}\n\t\t@Override\n\t\tpublic AnnotationMetadata getMetadata() {\n\t\t\treturn this.annotationMetadata;\n\t\t}\n<fim_suffix>\t\t@Override\n\t\t@NonNull\n\t\tpublic MethodMetadata getFactoryMethodMetadata() {\n\t\t\treturn this.factoryMethodMetadata;\n\t\t}<fim_middle>// function below has no smell\n"}