{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.cxf.tools.corba.processors.idl;\n\nimport javax.wsdl.Definition;\nimport javax.xml.namespace.QName;\n\nimport antlr.collections.AST;\n\nimport org.apache.cxf.binding.corba.wsdl.Alias;\nimport org.apache.cxf.binding.corba.wsdl.CorbaConstants;\nimport org.apache.cxf.binding.corba.wsdl.CorbaType;\nimport org.apache.ws.commons.schema.XmlSchema;\nimport org.apache.ws.commons.schema.XmlSchemaType;\nimport org.apache.ws.commons.schema.constants.Constants;\n\n<fim_suffix>public class TypedefVisitor extends VisitorBase {\n\n    public TypedefVisitor(Scope scope,\n                          Definition defn,\n                          XmlSchema schemaRef,\n                          WSDLASTVisitor wsdlVisitor) {\n        super(scope, defn, schemaRef, wsdlVisitor);\n    }\n\n    public static boolean accept(AST node) {\n        return node.getType() == IDLTokenTypes.LITERAL_typedef;\n    }\n\n    public void visit(AST typedefNode) {\n        // \"typedef\" <type_declarator>\n        // <type_declarator> ::= <type_spec> <declarators>\n\n        AST typeDeclaratorNode = typedefNode.getFirstChild();\n        AST identifierNode = TypesUtils.getCorbaTypeNameNode(typeDeclaratorNode);\n        TypesVisitor typesVisitor = new TypesVisitor(getScope(),\n                                                     definition,\n                                                     schema,\n                                                     wsdlVisitor,\n                                                     identifierNode);\n        typesVisitor.visit(typeDeclaratorNode);\n\n        XmlSchemaType schemaType = typesVisitor.getSchemaType();\n        CorbaType corbaType = typesVisitor.getCorbaType();\n        Scope fullyQualifiedName = typesVisitor.getFullyQualifiedName();\n        Scope typedefScope = new Scope(getScope(), identifierNode);\n\n        if (SequenceVisitor.accept(typeDeclaratorNode)\n            || FixedVisitor.accept(typeDeclaratorNode)) {\n            // Handle cases \"typedef sequence\"\n            //              \"typedef fixed\"\n            DeclaratorVisitor declaratorVisitor = new DeclaratorVisitor(typedefScope,\n                                                                        definition,\n                                                                        schema,\n                                                                        wsdlVisitor,\n                                                                        schemaType,\n                                                                        corbaType,\n                                                                        fullyQualifiedName);\n            declaratorVisitor.visit(identifierNode);\n\n        } else if (StringVisitor.accept(typeDeclaratorNode)) {\n            // Handle cases \"typedef string\"\n            //              \"typedef wstring\"\n\n            if (StringVisitor.isBounded(typeDeclaratorNode)\n                && !wsdlVisitor.getBoundedStringOverride()) {\n                DeclaratorVisitor declaratorVisitor = new DeclaratorVisitor(typedefScope,\n                                                                            definition,\n                                                                            schema,\n                                                                            wsdlVisitor,\n                                                                            schemaType,\n                                                                            corbaType,\n                                                                            fullyQualifiedName);\n                declaratorVisitor.visit(identifierNode);\n\n            } else {\n                // unbounded string type is already in the XmlSchema and only needs to be added\n                // to the CorbaTypeMap, therefore we cannot use DeclaratorVisitor here.\n\n                while (identifierNode != null) {\n                    if (ArrayVisitor.accept(identifierNode)) {\n                        ArrayVisitor arrayVisitor = new ArrayVisitor(new Scope(getScope(),\n                                                                               identifierNode.getText()),\n                                                                     definition,\n                                                                     schema,\n                                                                     wsdlVisitor,\n                                                                     identifierNode,\n                                                                     fullyQualifiedName);\n                        arrayVisitor.setSchemaType(schemaType);\n                        arrayVisitor.setCorbaType(corbaType);\n                        arrayVisitor.visit(identifierNode);\n\n                    } else {\n                        generateStringAlias(typeDeclaratorNode,\n                                            identifierNode,\n                                            schemaType,\n                                            corbaType,\n                                            fullyQualifiedName);\n                    }\n                    identifierNode = identifierNode.getNextSibling();\n                }\n            }\n\n        } else {\n            // typedef used to define an alias\n            // if declaring an array, do not generate aliases\n            if (!ArrayVisitor.accept(identifierNode)) {\n                generateAlias(identifierNode,\n                              schemaType,\n                              corbaType,\n                              fullyQualifiedName);\n                corbaType = getCorbaType();\n            }\n            DeclaratorVisitor declaratorVisitor = new DeclaratorVisitor(typedefScope,\n                                                                        definition,\n                                                                        schema,\n                                                                        wsdlVisitor,\n                                                                        schemaType,\n                                                                        corbaType,\n                                                                        fullyQualifiedName);\n            declaratorVisitor.visit(identifierNode);\n\n        }\n\n\n        setSchemaType(schemaType);\n        setCorbaType(corbaType);\n        setFullyQualifiedName(fullyQualifiedName);\n    }\n\n    private void generateAlias(AST identifierNode,\n                               XmlSchemaType schemaType,\n                               CorbaType corbaType,\n                               Scope fqName) {\n\n        Scope scopedName = new Scope(getScope(), identifierNode);\n        // corba:alias\n        Alias alias = new Alias();\n        alias.setQName(new QName(typeMap.getTargetNamespace(), scopedName.toString()));\n        if (corbaType != null) {\n            alias.setBasetype(corbaType.getQName());\n        // if (schemaType == null) might not be correct here\n        } else if (schemaType == null) {\n            wsdlVisitor.getDeferredActions().\n                add(fqName, new TypedefDeferredAction(alias));\n            scopedNames.add(scopedName);\n        }\n        alias.setRepositoryID(scopedName.toIDLRepositoryID());\n\n        // add corba:alias\n        setCorbaType(alias);\n    }\n\n    private void generateStringAlias(AST typeDeclaratorNode,\n                                     AST identifierNode,\n                                     XmlSchemaType schemaType,\n                                     CorbaType corbaType,\n                                     Scope fqName) {\n\n        Scope typedefScope = new Scope(getScope(), identifierNode);\n\n        Alias corbaString = new Alias();\n        if (typeDeclaratorNode.getType() == IDLTokenTypes.LITERAL_string) {\n            corbaString.setBasetype(CorbaConstants.NT_CORBA_STRING);\n        } else if (typeDeclaratorNode.getType() == IDLTokenTypes.LITERAL_wstring) {\n            corbaString.setBasetype(CorbaConstants.NT_CORBA_WSTRING);\n        } else {\n            // should never get here\n            throw new RuntimeException(\"[TypedefVisitor] Attempted to visit an invalid node: \"\n                                       + typeDeclaratorNode.toString());\n        }\n        Scope newScope = new Scope(typedefScope.getParent(), identifierNode);\n        corbaString.setQName(new QName(typeMap.getTargetNamespace(), newScope.toString()));\n        corbaString.setType(Constants.XSD_STRING);\n        corbaString.setRepositoryID(newScope.toIDLRepositoryID());\n\n        typeMap.getStructOrExceptionOrUnion().add(corbaString);\n\n    }\n\n\n}<fim_middle>// class below has no smell\n"}