{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.hadoop.mapred;\n\nimport java.util.Comparator;\nimport org.apache.hadoop.io.IntWritable;\nimport org.apache.hadoop.util.MergeSort;\nimport org.apache.hadoop.io.SequenceFile.Sorter.RawKeyValueIterator;\n\n/** This class implements the sort method from BasicTypeSorterBase class as\n * MergeSort. Note that this class is really a wrapper over the actual\n * mergesort implementation that is there in the util package. The main intent\n * of providing this class is to setup the input data for the util.MergeSort\n * algo so that the latter doesn't need to bother about the various data \n * structures that have been created for the Map output but rather concentrate \n * on the core algorithm (thereby allowing easy integration of a mergesort\n * implementation). The bridge between this class and the util.MergeSort class\n * is the Comparator.\n */\n<fim_suffix>class MergeSorter extends BasicTypeSorterBase \nimplements Comparator<IntWritable> {\n  private static int progressUpdateFrequency = 10000;\n  private int progressCalls = 0;\n  \n  /** The sort method derived from BasicTypeSorterBase and overridden here*/\n  public RawKeyValueIterator sort() {\n    MergeSort m = new MergeSort(this);\n    int count = super.count;\n    if (count == 0) return null;\n    int [] pointers = super.pointers;\n    int [] pointersCopy = new int[count];\n    System.arraycopy(pointers, 0, pointersCopy, 0, count);\n    m.mergeSort(pointers, pointersCopy, 0, count);\n    return new MRSortResultIterator(super.keyValBuffer, pointersCopy, \n                                    super.startOffsets, super.keyLengths, super.valueLengths);\n  }\n  /** The implementation of the compare method from Comparator. Note that\n   * Comparator.compare takes objects as inputs and so the int values are\n   * wrapped in (reusable) IntWritables from the class util.MergeSort\n   * @param i\n   * @param j\n   * @return int as per the specification of Comparator.compare\n   */\n  public int compare (IntWritable i, IntWritable j) {\n    // indicate we're making progress but do a batch update\n    if (progressCalls < progressUpdateFrequency) {\n      progressCalls++;\n    } else {\n      progressCalls = 0;\n      reporter.progress();\n    }  \n    return comparator.compare(keyValBuffer.getData(), startOffsets[i.get()],\n                              keyLengths[i.get()],\n                              keyValBuffer.getData(), startOffsets[j.get()], \n                              keyLengths[j.get()]);\n  }\n  \n  /** Add the extra memory that will be utilized by the sort method */\n  public long getMemoryUtilized() {\n    //this is memory that will be actually utilized (considering the temp\n    //array that will be allocated by the sort() method (mergesort))\n    return super.getMemoryUtilized() + super.count * 4; \n  }\n\n}<fim_middle>// class below has no smell\n"}