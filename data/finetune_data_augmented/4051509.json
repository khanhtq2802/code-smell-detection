{"text": "<fim_prefix>     * </pre>\n     *\n     * <p>Simple properties are able to bound to {@link String}, {@link Class}, enums and Java\n     * primitives {@code boolean}, {@code byte}, {@code short}, {@code int}, {@code long}, {@code\n     * float}, {@code double} and their primitive wrapper classes.\n     *\n     * <p>Simple list style properties are able to be bound to {@code boolean[]}, {@code char[]},\n     * {@code short[]}, {@code int[]}, {@code long[]}, {@code float[]}, {@code double[]}, {@code\n     * Class[]}, enum arrays, {@code String[]}, and {@code List<String>}.\n     *\n     * <p>JSON format is required for all other types.\n     *\n     * <p>By default, strict parsing is enabled and arguments must conform to be either {@code\n     * --booleanArgName} or {@code --argName=argValue}. Strict parsing can be disabled with {@link\n     * Builder#withoutStrictParsing()}. Empty or null arguments will be ignored whether or not\n     * strict parsing is enabled.\n     *\n     * <p>Help information can be output to {@link System#out} by specifying {@code --help} as an\n     * argument. After help is printed, the application will exit. Specifying only {@code --help}\n     * will print out the list of {@link PipelineOptionsFactory#getRegisteredOptions() registered\n     * options} by invoking {@link PipelineOptionsFactory#printHelp(PrintStream)}. Specifying {@code\n     * --help=PipelineOptionsClassName} will print out detailed usage information about the\n     * specifically requested PipelineOptions by invoking {@link\n     * PipelineOptionsFactory#printHelp(PrintStream, Class)}.\n     */\n    public Builder fromArgs(String... args) {\n      checkNotNull(args, \"Arguments should not be null.\");\n      return new Builder(args, validation, strictParsing, true);\n    }\n    /**\n     * After creation we will validate that {@link PipelineOptions} conforms to all the validation\n     * criteria from {@code <T>}. See {@link PipelineOptionsValidator#validate(Class,\n     * PipelineOptions)} for more details about validation.\n     */\n    public Builder withValidation() {\n      return new Builder(args, true, strictParsing, isCli);\n    }\n    /**\n     * During parsing of the arguments, we will skip over improperly formatted and unknown\n     * arguments.\n     */\n    public Builder withoutStrictParsing() {\n      return new Builder(args, validation, false, isCli);\n    }\n    /**\n     * Creates and returns an object that implements {@link PipelineOptions} using the values\n     * configured on this builder during construction.\n     *\n     * @return An object that implements {@link PipelineOptions}.\n     */\n    public PipelineOptions create() {\n      return as(PipelineOptions.class);\n    }\n    /**\n     * Creates and returns an object that implements {@code <T>} using the values configured on this\n     * builder during construction.\n     *\n     * <p>Note that {@code <T>} must be composable with every registered interface with this\n     * factory. See {@link PipelineOptionsFactory.Cache#validateWellFormed(Class)} for more details.\n     *\n     * @return An object that implements {@code <T>}.\n     */\n    public <T extends PipelineOptions> T as(Class<T> klass) {\n      Map<String, Object> initialOptions = Maps.newHashMap();\n      // Attempt to parse the arguments into the set of initial options to use\n      if (args != null) {\n        ListMultimap<String, String> options = parseCommandLine(args, strictParsing);\n        LOG.debug(\"Provided Arguments: {}\", options);\n        printHelpUsageAndExitIfNeeded(options, System.out, true /* exit */);\n        initialOptions = parseObjects(klass, options, strictParsing);\n      }\n      // Create our proxy\n      ProxyInvocationHandler handler = new ProxyInvocationHandler(initialOptions);\n      T t = handler.as(klass);\n      // Set the application name to the default if none was set.\n      ApplicationNameOptions appNameOptions = t.as(ApplicationNameOptions.class);\n      if (appNameOptions.getAppName() == null) {\n        appNameOptions.setAppName(defaultAppName);\n      }\n      // Ensure the options id has been populated either by the user using the command line\n      // or by the default value factory.\n      t.getOptionsId();\n      if (validation) {\n        if (isCli) {\n          PipelineOptionsValidator.validateCli(klass, t);\n        } else {\n          PipelineOptionsValidator.validate(klass, t);\n        }\n      }\n      return t;\n    }\n  }\n  /**\n   * Determines whether the generic {@code --help} was requested or help was requested for a\n   * specific class and invokes the appropriate {@link\n   * PipelineOptionsFactory#printHelp(PrintStream)} and {@link\n   * PipelineOptionsFactory#printHelp(PrintStream, Class)} variant. Prints to the specified {@link\n   * PrintStream}, and exits if requested.\n   *\n   * <p>Visible for testing. {@code printStream} and {@code exit} used for testing.\n   */\n  @SuppressWarnings(\"unchecked\")\n  static boolean printHelpUsageAndExitIfNeeded(\n      ListMultimap<String, String> options, PrintStream printStream, boolean exit) {\n    if (options.containsKey(\"help\")) {\n      final String helpOption = Iterables.getOnlyElement(options.get(\"help\"));\n      // Print the generic help if only --help was specified.\n      if (Boolean.TRUE.toString().equals(helpOption)) {\n        printHelp(printStream);\n        if (exit) {\n          System.exit(0);\n        } else {\n          return true;\n        }\n      }\n      // Otherwise attempt to print the specific help option.\n      try {\n        Class<?> klass = Class.forName(helpOption, true, ReflectHelpers.findClassLoader());\n        if (!PipelineOptions.class.isAssignableFrom(klass)) {\n          throw new ClassNotFoundException(\"PipelineOptions of type \" + klass + \" not found.\");\n        }\n        printHelp(printStream, (Class<? extends PipelineOptions>) klass);\n      } catch (ClassNotFoundException e) {\n        // If we didn't find an exact match, look for any that match the class name.\n        Iterable<Class<? extends PipelineOptions>> matches =\n            getRegisteredOptions().stream()\n                .filter(\n                    input -> {\n                      if (helpOption.contains(\".\")) {\n                        return input.getName().endsWith(helpOption);\n                      } else {\n                        return input.getSimpleName().equals(helpOption);\n                      }\n                    })\n                .collect(Collectors.toList());\n        try {\n          printHelp(printStream, Iterables.getOnlyElement(matches));\n        } catch (NoSuchElementException exception) {\n          printStream.format(\"Unable to find option %s.%n\", helpOption);\n          printHelp(printStream);\n        } catch (IllegalArgumentException exception) {\n          printStream.format(\n              \"Multiple matches found for %s: %s.%n\",\n              helpOption,\n              StreamSupport.stream(matches.spliterator(), false)\n                  .map(ReflectHelpers.CLASS_NAME::apply)\n                  .collect(Collectors.toList()));\n          printHelp(printStream);\n        }\n      }\n      if (exit) {\n        System.exit(0);\n      } else {\n        return true;\n      }\n    }\n    return false;\n  }\n  /** Returns the simple name of the calling class using the current threads stack. */\n  private static String findCallersClassName() {\n    Iterator<StackTraceElement> elements =\n        Iterators.forArray(Thread.currentThread().getStackTrace());\n    // First find the PipelineOptionsFactory/Builder class in the stack trace.\n    while (elements.hasNext()) {\n      StackTraceElement next = elements.next();\n      if (PIPELINE_OPTIONS_FACTORY_CLASSES.contains(next.getClassName())) {\n        break;\n      }\n    }\n    // Then find the first instance after that is not the PipelineOptionsFactory/Builder class.\n    while (elements.hasNext()) {\n      StackTraceElement next = elements.next();\n      if (!PIPELINE_OPTIONS_FACTORY_CLASSES.contains(next.getClassName())) {\n        try {\n          return Class.forName(next.getClassName(), true, ReflectHelpers.findClassLoader())\n              .getSimpleName();\n        } catch (ClassNotFoundException e) {\n          break;\n        }\n      }\n    }\n    return \"unknown\";\n  }\n  /**\n   * Stores the generated proxyClass and its respective {@link BeanInfo} object.\n   *\n   * @param <T> The type of the proxyClass.\n   */\n<fim_suffix>  static class Registration<T extends PipelineOptions> {\n    private final Class<T> proxyClass;\n    private final List<PropertyDescriptor> propertyDescriptors;\n    public Registration(Class<T> proxyClass, List<PropertyDescriptor> beanInfo) {\n      this.proxyClass = proxyClass;\n      this.propertyDescriptors = beanInfo;\n    }\n    List<PropertyDescriptor> getPropertyDescriptors() {\n      return propertyDescriptors;\n    }\n    Class<T> getProxyClass() {\n      return proxyClass;\n    }\n  }<fim_middle>// class below has no smell\n"}