{"text": "<fim_prefix>\t{\n\t\treturn byteStream.toByteArray();\n\t}\n\t/**\n\t * Return the current buffer size\n\t * \n\t * @return The buffer size\n\t */\n\t@Override\n\tpublic int getBufferSize()\n\t{\n\t\tif (mode == MODE_NONE)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\telse if (mode == MODE_BINARY)\n\t\t{\n\t\t\treturn byteStream.size();\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn stringWriter.getBuffer().length();\n\t\t}\n\t}\n\t/**\n\t * Get the character encoding of the response.\n\t * \n\t * @return The character encoding\n\t */\n\t@Override\n\tpublic String getCharacterEncoding()\n\t{\n\t\treturn characterEncoding;\n\t}\n\t/**\n\t * Get all of the cookies that have been added to the response.\n\t * \n\t * @return The collection of cookies\n\t */\n\tpublic List<Cookie> getCookies()\n\t{\n\t\tList<Cookie> copies = new ArrayList<Cookie>();\n\t\tfor (Cookie cookie : cookies)\n\t\t{\n\t\t\tcopies.add(Cookies.copyOf(cookie));\n\t\t}\n\t\treturn copies;\n\t}\n\t/**\n\t * Get the text document that was written as part of this response.\n\t * \n\t * @return The document\n\t */\n\tpublic String getDocument()\n\t{\n\t\tif (mode == MODE_BINARY)\n\t\t{\n\t\t\treturn new String(byteStream.toByteArray());\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn stringWriter.getBuffer().toString();\n\t\t}\n\t}\n\t/**\n\t * Get the error message.\n\t * \n\t * @return The error message, or null if no message\n\t */\n\tpublic String getErrorMessage()\n\t{\n\t\treturn errorMessage;\n\t}\n\t/**\n\t * Return the value of the given named header.\n\t * \n\t * @param name\n\t *            The header name\n\t * @return The value, or null\n\t */\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic String getHeader(final String name)\n\t{\n\t\tList<String> l = (List<String>)headers.get(name);\n\t\tif (l == null || l.size() < 1)\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn l.get(0);\n\t\t}\n\t}\n\t/**\n\t * Get the names of all of the headers.\n\t * \n\t * @return The header names\n\t */\n\t@Override\n\tpublic Set<String> getHeaderNames()\n\t{\n\t\treturn headers.keySet();\n\t}\n\t/**\n\t * Get the encoded locale\n\t * \n\t * @return The locale\n\t */\n\t@Override\n\tpublic Locale getLocale()\n\t{\n\t\treturn locale;\n\t}\n\t/**\n\t * Get the output stream for writing binary data from the servlet.\n\t * \n\t * @return The binary output stream.\n\t */\n\t@Override\n\tpublic ServletOutputStream getOutputStream()\n\t{\n\t\tif (mode == MODE_TEXT)\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\"Can't write binary after already selecting text\");\n\t\t}\n\t\tmode = MODE_BINARY;\n\t\treturn servletStream;\n\t}\n\t/**\n\t * Get the location that was redirected to.\n\t * \n\t * @return The redirect location, or null if not a redirect\n\t */\n\tpublic String getRedirectLocation()\n\t{\n\t\treturn redirectLocation;\n\t}\n\t/**\n\t * Get the status code.\n\t * \n\t * @return The status code\n\t */\n\t@Override\n\tpublic int getStatus()\n\t{\n\t\treturn status;\n\t}\n\t/**\n\t * Get the print writer for writing text output for this response.\n\t * \n\t * @return The writer\n\t * @throws IOException\n\t *             Not used\n\t */\n\t@Override\n\tpublic PrintWriter getWriter() throws IOException\n\t{\n\t\tif (mode == MODE_BINARY)\n\t\t{\n\t\t\tthrow new IllegalArgumentException(\"Can't write text after already selecting binary\");\n\t\t}\n\t\tmode = MODE_TEXT;\n\t\treturn printWriter;\n\t}\n\t/**\n\t * Reset the response ready for reuse.\n\t */\n\tpublic void initialize()\n\t{\n\t\tcookies.clear();\n\t\theaders.clear();\n\t\terrorMessage = null;\n\t\tredirectLocation = null;\n\t\tstatus = HttpServletResponse.SC_OK;\n\t\tcharacterEncoding = \"UTF-8\";\n\t\tlocale = null;\n\t\tbyteStream = new ByteArrayOutputStream();\n\t\tservletStream = new ServletOutputStream()\n\t\t{\n\t\t\t@Override\n\t\t\tpublic boolean isReady()\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void setWriteListener(WriteListener writeListener)\n\t\t\t{\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void write(int b)\n\t\t\t{\n\t\t\t\tbyteStream.write(b);\n\t\t\t}\n\t\t};\n\t\tstringWriter = new StringWriter();\n\t\tprintWriter = new PrintWriter(stringWriter)\n\t\t{\n\t\t\t@Override\n\t\t\tpublic void close()\n\t\t\t{\n\t\t\t\t// Do nothing\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void flush()\n\t\t\t{\n\t\t\t\t// Do nothing\n\t\t\t}\n\t\t};\n\t\tmode = MODE_NONE;\n\t}\n\t/**\n\t * Always returns false.\n\t * \n\t * @return Always false\n\t */\n\t@Override\n\tpublic boolean isCommitted()\n\t{\n\t\treturn false;\n\t}\n\t/**\n\t * Return whether the servlet returned an error code or not.\n\t * \n\t * @return Whether an error occurred or not\n\t */\n\tpublic boolean isError()\n\t{\n\t\treturn (status != HttpServletResponse.SC_OK);\n\t}\n\t/**\n\t * Check whether the response was redirected or not.\n\t * \n\t * @return Whether the state was redirected or not\n\t */\n\tpublic boolean isRedirect()\n\t{\n\t\treturn (redirectLocation != null);\n\t}\n\t/**\n\t * Delegate to initialize method.\n\t */\n\t@Override\n\tpublic void reset()\n\t{\n\t\tinitialize();\n\t}\n\t/**\n\t * Clears the buffer.\n\t */\n\t@Override\n\tpublic void resetBuffer()\n\t{\n\t\tif (mode == MODE_BINARY)\n\t\t{\n\t\t\tbyteStream.reset();\n\t\t}\n\t\telse if (mode == MODE_TEXT)\n\t\t{\n\t\t\tstringWriter.getBuffer().delete(0, stringWriter.getBuffer().length());\n\t\t}\n\t}\n\t/**\n\t * Send an error code. This implementation just sets the internal error state information.\n\t * \n\t * @param code\n\t *            The code\n\t * @throws IOException\n\t *             Not used\n\t */\n\t@Override\n\tpublic void sendError(final int code) throws IOException\n\t{\n\t\tstatus = code;\n\t\terrorMessage = null;\n\t}\n\t/**\n\t * Send an error code. This implementation just sets the internal error state information.\n\t * \n\t * @param code\n\t *            The error code\n\t * @param msg\n\t *            The error message\n\t * @throws IOException\n\t *             Not used\n\t */\n\t@Override\n\tpublic void sendError(final int code, final String msg) throws IOException\n\t{\n\t\tstatus = code;\n\t\terrorMessage = msg;\n\t}\n\t/**\n\t * Indicate sending of a redirectLocation to a particular named resource. This implementation\n\t * just keeps hold of the redirectLocation info and makes it available for query.\n\t * \n\t * @param location\n\t *            The location to redirectLocation to\n\t * @throws IOException\n\t *             Not used\n\t */\n\t@Override\n\tpublic void sendRedirect(String location) throws IOException\n\t{\n\t\tredirectLocation = location;\n\t\tstatus = HttpServletResponse.SC_FOUND;\n\t}\n\t/**\n\t * Method ignored.\n\t * \n\t * @param size\n\t *            The size\n\t */\n\t@Override\n\tpublic void setBufferSize(final int size)\n\t{\n\t}\n\t/**\n\t * Set the character encoding.\n\t * \n\t * @param characterEncoding\n\t *            The character encoding\n\t */\n\t@Override\n\tpublic void setCharacterEncoding(final String characterEncoding)\n\t{\n\t\tthis.characterEncoding = characterEncoding;\n\t}\n\t/**\n\t * Set the content length.\n\t * \n\t * @param length\n\t *            The length\n\t */\n<fim_suffix>\t@Override\n\tpublic void setContentLength(final int length)\n\t{\n\t\tsetIntHeader(\"Content-Length\", length);\n\t}<fim_middle>// function below has no smell\n"}