{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.druid.sql.avatica;\n\nimport org.apache.calcite.avatica.metrics.Counter;\nimport org.apache.calcite.avatica.metrics.Gauge;\nimport org.apache.calcite.avatica.metrics.Histogram;\nimport org.apache.calcite.avatica.metrics.Meter;\nimport org.apache.calcite.avatica.metrics.MetricsSystem;\nimport org.apache.calcite.avatica.metrics.Timer;\nimport org.apache.druid.java.util.common.StringUtils;\nimport org.apache.druid.java.util.common.logger.Logger;\nimport org.apache.druid.java.util.emitter.service.ServiceEmitter;\nimport org.apache.druid.java.util.emitter.service.ServiceMetricEvent;\nimport org.apache.druid.java.util.metrics.AbstractMonitor;\n\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicLong;\n\n<fim_suffix>public class AvaticaMonitor extends AbstractMonitor implements MetricsSystem\n{\n  private static final Logger log = new Logger(AvaticaMonitor.class);\n\n  private final ConcurrentMap<String, AtomicLong> counters = new ConcurrentHashMap<>();\n  private final ConcurrentMap<String, Gauge<?>> gauges = new ConcurrentHashMap<>();\n\n  @Override\n  public boolean doMonitor(final ServiceEmitter emitter)\n  {\n    for (final Map.Entry<String, AtomicLong> entry : counters.entrySet()) {\n      final String name = entry.getKey();\n      final long value = entry.getValue().getAndSet(0);\n      emitter.emit(ServiceMetricEvent.builder().build(fullMetricName(name), value));\n    }\n\n    for (Map.Entry<String, Gauge<?>> entry : gauges.entrySet()) {\n      final String name = entry.getKey();\n      final Object value = entry.getValue().getValue();\n      if (value instanceof Number) {\n        emitter.emit(ServiceMetricEvent.builder().build(fullMetricName(name), (Number) value));\n      } else {\n        log.debug(\"Not emitting gauge[%s] since value[%s] type was[%s].\", name, value, value.getClass().getName());\n      }\n    }\n\n    return true;\n  }\n\n  @Override\n  public Timer getTimer(final String name)\n  {\n    final AtomicLong counter = makeCounter(name);\n    return new Timer()\n    {\n      @Override\n      public Context start()\n      {\n        final long start = System.currentTimeMillis();\n        final AtomicBoolean closed = new AtomicBoolean();\n        return new Context()\n        {\n          @Override\n          public void close()\n          {\n            if (closed.compareAndSet(false, true)) {\n              counter.addAndGet(System.currentTimeMillis() - start);\n            }\n          }\n        };\n      }\n    };\n  }\n\n  @Override\n  public Histogram getHistogram(final String name)\n  {\n    // Return a dummy Histogram. We don't support Histogram metrics.\n    return new Histogram()\n    {\n      @Override\n      public void update(int i)\n      {\n        // Do nothing.\n      }\n\n      @Override\n      public void update(long l)\n      {\n        // Do nothing.\n      }\n    };\n  }\n\n  @Override\n  public Meter getMeter(final String name)\n  {\n    final AtomicLong counter = makeCounter(name);\n    return new Meter()\n    {\n      @Override\n      public void mark()\n      {\n        counter.incrementAndGet();\n      }\n\n      @Override\n      public void mark(long events)\n      {\n        counter.addAndGet(events);\n      }\n    };\n  }\n\n  @Override\n  public Counter getCounter(final String name)\n  {\n    final AtomicLong counter = makeCounter(name);\n    return new Counter()\n    {\n      @Override\n      public void increment()\n      {\n        counter.incrementAndGet();\n      }\n\n      @Override\n      public void increment(long n)\n      {\n        counter.addAndGet(n);\n      }\n\n      @Override\n      public void decrement()\n      {\n        counter.decrementAndGet();\n      }\n\n      @Override\n      public void decrement(long n)\n      {\n        counter.addAndGet(-n);\n      }\n    };\n  }\n\n  @Override\n  public <T> void register(final String name, final Gauge<T> gauge)\n  {\n    if (gauges.putIfAbsent(name, gauge) != null) {\n      log.warn(\"Ignoring gauge[%s], one with the same name was already registered.\", name);\n    }\n  }\n\n  private AtomicLong makeCounter(final String name)\n  {\n    counters.putIfAbsent(name, new AtomicLong());\n    return counters.get(name);\n  }\n\n  private String fullMetricName(final String name)\n  {\n    return StringUtils.replace(name, \"org.apache.calcite.avatica\", \"avatica\").replace('.', '/');\n  }\n}<fim_middle>// class below has no smell\n"}