{"text": "<fim_prefix>\n<fim_suffix>public class DynamicWebAppClusterImpl extends DynamicClusterImpl implements DynamicWebAppCluster {\n    private static final Logger log = LoggerFactory.getLogger(DynamicWebAppClusterImpl.class);\n    private static final FilenameToWebContextMapper FILENAME_TO_WEB_CONTEXT_MAPPER = new FilenameToWebContextMapper();\n    /**\n     * Instantiate a new DynamicWebAppCluster.  Parameters as per {@link DynamicCluster#DynamicCluster()}\n     */\n    public DynamicWebAppClusterImpl() {\n        super();\n    }\n    @Override\n    public void init() {\n        super.init();\n        // Enricher attribute setup.  A way of automatically discovering these (but avoiding\n        // averaging things like HTTP port and response codes) would be neat.\n        List<? extends List<? extends AttributeSensor<? extends Number>>> summingEnricherSetup = ImmutableList.of(\n                ImmutableList.of(REQUEST_COUNT, REQUEST_COUNT),\n                ImmutableList.of(ERROR_COUNT, ERROR_COUNT),\n                ImmutableList.of(REQUESTS_PER_SECOND_LAST, REQUESTS_PER_SECOND_LAST),\n                ImmutableList.of(REQUESTS_PER_SECOND_IN_WINDOW, REQUESTS_PER_SECOND_IN_WINDOW),\n                ImmutableList.of(TOTAL_PROCESSING_TIME, TOTAL_PROCESSING_TIME),\n                ImmutableList.of(PROCESSING_TIME_FRACTION_IN_WINDOW, PROCESSING_TIME_FRACTION_IN_WINDOW)\n        );\n        List<? extends List<? extends AttributeSensor<? extends Number>>> averagingEnricherSetup = ImmutableList.of(\n                ImmutableList.of(REQUEST_COUNT, REQUEST_COUNT_PER_NODE),\n                ImmutableList.of(ERROR_COUNT, ERROR_COUNT_PER_NODE),\n                ImmutableList.of(REQUESTS_PER_SECOND_LAST, REQUESTS_PER_SECOND_LAST_PER_NODE),\n                ImmutableList.of(REQUESTS_PER_SECOND_IN_WINDOW, REQUESTS_PER_SECOND_IN_WINDOW_PER_NODE),\n                ImmutableList.of(TOTAL_PROCESSING_TIME, TOTAL_PROCESSING_TIME_PER_NODE),\n                ImmutableList.of(PROCESSING_TIME_FRACTION_IN_WINDOW, PROCESSING_TIME_FRACTION_IN_WINDOW_PER_NODE)\n        );\n        for (List<? extends AttributeSensor<? extends Number>> es : summingEnricherSetup) {\n            AttributeSensor<? extends Number> t = es.get(0);\n            AttributeSensor<? extends Number> total = es.get(1);\n            enrichers().add(Enrichers.builder()\n                    .aggregating(t)\n                    .publishing(total)\n                    .fromMembers()\n                    .computingSum()\n                    .build());\n        }\n        for (List<? extends AttributeSensor<? extends Number>> es : averagingEnricherSetup) {\n            @SuppressWarnings(\"unchecked\")\n            AttributeSensor<Number> t = (AttributeSensor<Number>) es.get(0);\n            @SuppressWarnings(\"unchecked\")\n            AttributeSensor<Double> average = (AttributeSensor<Double>) es.get(1);\n            enrichers().add(Enrichers.builder()\n                    .aggregating(t)\n                    .publishing(average)\n                    .fromMembers()\n                    .computingAverage()\n                    .defaultValueForUnreportedSensors(0)\n                    .build());\n        }\n    }\n    // TODO this will probably be useful elsewhere ... but where to put it?\n    // TODO add support for this in DependentConfiguration (see TODO there)\n    /** Waits for the given target to report service up, then runs the given task\n     * (often an invocation on that entity), with the given name.\n     * If the target goes away, this task marks itself inessential\n     * before failing so as not to cause a parent task to fail. */\n    static <T> Task<T> whenServiceUp(final Entity target, final TaskAdaptable<T> task, String name) {\n        return Tasks.<T>builder().displayName(name).dynamic(true).body(new Callable<T>() {\n            @Override\n            public T call() {\n                try {\n                    while (true) {\n                        if (!Entities.isManaged(target)) {\n                            Tasks.markInessential();\n                            throw new IllegalStateException(\"Target \"+target+\" is no longer managed\");\n                        }\n                        if (Boolean.TRUE.equals(target.getAttribute(Attributes.SERVICE_UP))) {\n                            Tasks.resetBlockingDetails();\n                            TaskTags.markInessential(task);\n                            DynamicTasks.queue(task);\n                            try {\n                                return task.asTask().getUnchecked();\n                            } catch (Exception e) {\n                                if (Entities.isManaged(target)) {\n                                    throw Exceptions.propagate(e);\n                                } else {\n                                    Tasks.markInessential();\n                                    throw new IllegalStateException(\"Target \"+target+\" is no longer managed\", e);\n                                }\n                            }\n                        } else {\n                            Tasks.setBlockingDetails(\"Waiting on \"+target+\" to be ready\");\n                        }\n                        // TODO replace with subscription?\n                        Time.sleep(Duration.ONE_SECOND);\n                    }\n                } finally {\n                    Tasks.resetBlockingDetails();\n                }\n            }\n        }).build();        \n    }\n    @Override\n    public void deploy(String url, String targetName) {\n        checkNotNull(url, \"url\");\n        checkNotNull(targetName, \"targetName\");\n        targetName = FILENAME_TO_WEB_CONTEXT_MAPPER.convertDeploymentTargetNameToContext(targetName);\n        // set it up so future nodes get the right wars\n        addToWarsByContext(this, url, targetName);\n        log.debug(\"Deploying \"+targetName+\"->\"+url+\" across cluster \"+this+\"; WARs now \"+getConfig(WARS_BY_CONTEXT));\n        Iterable<CanDeployAndUndeploy> targets = Iterables.filter(getChildren(), CanDeployAndUndeploy.class);\n        TaskBuilder<Void> tb = Tasks.<Void>builder().parallel(true).displayName(\"Deploy \"+targetName+\" to cluster (size \"+Iterables.size(targets)+\")\");\n        for (Entity target: targets) {\n            tb.add(whenServiceUp(target, Effectors.invocation(target, DEPLOY, MutableMap.of(\"url\", url, \"targetName\", targetName)),\n                \"Deploy \"+targetName+\" to \"+target+\" when ready\"));\n        }\n        DynamicTasks.queueIfPossible(tb.build()).orSubmitAsync(this).asTask().getUnchecked();\n        // Update attribute\n        // TODO support for atomic sensor update (should be part of standard tooling; NB there is some work towards this, according to @aledsage)\n        Set<String> deployedWars = MutableSet.copyOf(getAttribute(DEPLOYED_WARS));\n        deployedWars.add(targetName);\n        sensors().set(DEPLOYED_WARS, deployedWars);\n    }\n    @Override\n    public void undeploy(String targetName) {\n        checkNotNull(targetName, \"targetName\");\n        targetName = FILENAME_TO_WEB_CONTEXT_MAPPER.convertDeploymentTargetNameToContext(targetName);\n        // set it up so future nodes get the right wars\n        if (!removeFromWarsByContext(this, targetName)) {\n            DynamicTasks.submit(Tasks.warning(\"Context \"+targetName+\" not known at \"+this+\"; attempting to undeploy regardless\", null), this);\n        }\n        log.debug(\"Undeploying \"+targetName+\" across cluster \"+this+\"; WARs now \"+getConfig(WARS_BY_CONTEXT));\n        Iterable<CanDeployAndUndeploy> targets = Iterables.filter(getChildren(), CanDeployAndUndeploy.class);\n        TaskBuilder<Void> tb = Tasks.<Void>builder().parallel(true).displayName(\"Undeploy \"+targetName+\" across cluster (size \"+Iterables.size(targets)+\")\");\n        for (Entity target: targets) {\n            tb.add(whenServiceUp(target, Effectors.invocation(target, UNDEPLOY, MutableMap.of(\"targetName\", targetName)),\n                \"Undeploy \"+targetName+\" at \"+target+\" when ready\"));\n        }\n        DynamicTasks.queueIfPossible(tb.build()).orSubmitAsync(this).asTask().getUnchecked();\n        // Update attribute\n        Set<String> deployedWars = MutableSet.copyOf(getAttribute(DEPLOYED_WARS));\n        deployedWars.remove( FILENAME_TO_WEB_CONTEXT_MAPPER.convertDeploymentTargetNameToContext(targetName) );\n        sensors().set(DEPLOYED_WARS, deployedWars);\n    }\n    static void addToWarsByContext(Entity entity, String url, String targetName) {\n        targetName = FILENAME_TO_WEB_CONTEXT_MAPPER.convertDeploymentTargetNameToContext(targetName);\n        // TODO a better way to do atomic updates, see comment above\n        synchronized (entity) {\n            Map<String,String> newWarsMap = MutableMap.copyOf(entity.getConfig(WARS_BY_CONTEXT));\n            newWarsMap.put(targetName, url);\n            entity.config().set(WARS_BY_CONTEXT, newWarsMap);\n        }\n    }\n    static boolean removeFromWarsByContext(Entity entity, String targetName) {\n        targetName = FILENAME_TO_WEB_CONTEXT_MAPPER.convertDeploymentTargetNameToContext(targetName);<fim_middle>// class below has no smell\n"}