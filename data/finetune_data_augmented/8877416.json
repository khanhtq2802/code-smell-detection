{"text": "<fim_prefix>\n<fim_suffix>public class ExplainTask extends Task<ExplainWork> implements Serializable {\n  public static final String STAGE_DEPENDENCIES = \"STAGE DEPENDENCIES\";\n  private static final long serialVersionUID = 1L;\n  public static final String EXPL_COLUMN_NAME = \"Explain\";\n  private final Set<Operator<?>> visitedOps = new HashSet<Operator<?>>();\n  private boolean isLogical = false;\n  protected final Logger LOG;\n  public ExplainTask() {\n    super();\n    LOG = LoggerFactory.getLogger(this.getClass().getName());\n  }\n  /*\n   * Below method returns the dependencies for the passed in query to EXPLAIN.\n   * The dependencies are the set of input tables and partitions, and are\n   * provided back as JSON output for the EXPLAIN command.\n   * Example output:\n   * {\"input_tables\":[{\"tablename\": \"default@test_sambavi_v1\", \"tabletype\": \"TABLE\"}],\n   *  \"input partitions\":[\"default@srcpart@ds=2008-04-08/hr=11\"]}\n   */\n  @VisibleForTesting\n  static JSONObject getJSONDependencies(ExplainWork work)\n      throws Exception {\n    assert(work.getDependency());\n    JSONObject outJSONObject = new JSONObject(new LinkedHashMap<>());\n    JSONArray inputTableInfo = new JSONArray();\n    JSONArray inputPartitionInfo = new JSONArray();\n    for (ReadEntity input: work.getInputs()) {\n      switch (input.getType()) {\n        case TABLE:\n          Table table = input.getTable();\n          JSONObject tableInfo = new JSONObject();\n          tableInfo.put(\"tablename\", table.getCompleteName());\n          tableInfo.put(\"tabletype\", table.getTableType().toString());\n          if ((input.getParents() != null) && (!input.getParents().isEmpty())) {\n            tableInfo.put(\"tableParents\", input.getParents().toString());\n          }\n          inputTableInfo.put(tableInfo);\n          break;\n        case PARTITION:\n          JSONObject partitionInfo = new JSONObject();\n          partitionInfo.put(\"partitionName\", input.getPartition().getCompleteName());\n          if ((input.getParents() != null) && (!input.getParents().isEmpty())) {\n            partitionInfo.put(\"partitionParents\", input.getParents().toString());\n          }\n          inputPartitionInfo.put(partitionInfo);\n          break;\n        default:\n          break;\n      }\n    }\n    outJSONObject.put(\"input_tables\", inputTableInfo);\n    outJSONObject.put(\"input_partitions\", inputPartitionInfo);\n    return outJSONObject;\n  }\n  public JSONObject getJSONCBOPlan(PrintStream out, ExplainWork work) throws Exception {\n    JSONObject outJSONObject = new JSONObject(new LinkedHashMap<>());\n    boolean jsonOutput = work.isFormatted();\n    String cboPlan = work.getCboPlan();\n    if (cboPlan != null) {\n      if (jsonOutput) {\n        outJSONObject.put(\"CBOPlan\", cboPlan);\n      } else {\n        out.println(\"CBO PLAN:\");\n        out.println(cboPlan);\n      }\n    }\n    return outJSONObject;\n  }\n  public JSONObject getJSONLogicalPlan(PrintStream out, ExplainWork work) throws Exception {\n    isLogical = true;\n    JSONObject outJSONObject = new JSONObject(new LinkedHashMap<>());\n    boolean jsonOutput = work.isFormatted();\n    if (jsonOutput) {\n      out = null;\n    }\n    if (work.getParseContext() != null) {\n      if (out != null) {\n        out.print(\"LOGICAL PLAN:\");\n      }\n      JSONObject jsonPlan = outputMap(work.getParseContext().getTopOps(), true,\n                                      out, work.getExtended(), jsonOutput, 0);\n      if (out != null) {\n        out.println();\n      }\n      if (jsonOutput) {\n        outJSONObject.put(\"LOGICAL PLAN\", jsonPlan);\n      }\n    } else {\n      System.err.println(\"No parse context!\");\n    }\n    return outJSONObject;\n  }\n  private static String trueCondNameVectorizationEnabled =\n      HiveConf.ConfVars.HIVE_VECTORIZATION_ENABLED.varname + \" IS true\";\n  private static String falseCondNameVectorizationEnabled =\n      HiveConf.ConfVars.HIVE_VECTORIZATION_ENABLED.varname + \" IS false\";\n  @VisibleForTesting\n  ImmutablePair<Boolean, JSONObject> outputPlanVectorization(PrintStream out, boolean jsonOutput)\n      throws Exception {\n    if (out != null) {\n      out.println(\"PLAN VECTORIZATION:\");\n    }\n    JSONObject json = jsonOutput ? new JSONObject(new LinkedHashMap<>()) : null;\n    HiveConf hiveConf = queryState.getConf();\n    boolean isVectorizationEnabled = HiveConf.getBoolVar(hiveConf,\n        HiveConf.ConfVars.HIVE_VECTORIZATION_ENABLED);\n    String isVectorizationEnabledCondName =\n        (isVectorizationEnabled ?\n            trueCondNameVectorizationEnabled :\n              falseCondNameVectorizationEnabled);\n    List<String> isVectorizationEnabledCondList = Arrays.asList(isVectorizationEnabledCondName);\n    if (out != null) {\n      out.print(indentString(2));\n      out.print(\"enabled: \");\n      out.println(isVectorizationEnabled);\n      out.print(indentString(2));\n      if (!isVectorizationEnabled) {\n        out.print(\"enabledConditionsNotMet: \");\n      } else {\n        out.print(\"enabledConditionsMet: \");\n      }\n      out.println(isVectorizationEnabledCondList);\n    }\n    if (jsonOutput) {\n      json.put(\"enabled\", isVectorizationEnabled);\n      JSONArray jsonArray = new JSONArray(Arrays.asList(isVectorizationEnabledCondName));\n      if (!isVectorizationEnabled) {\n        json.put(\"enabledConditionsNotMet\", jsonArray);\n      } else {\n        json.put(\"enabledConditionsMet\", jsonArray);\n      }\n    }\n    return new ImmutablePair<Boolean, JSONObject>(isVectorizationEnabled, jsonOutput ? json : null);\n  }\n  public JSONObject getJSONPlan(PrintStream out, ExplainWork work)\n      throws Exception {\n    return getJSONPlan(out, work.getRootTasks(), work.getFetchTask(),\n        work.isFormatted(), work.getExtended(), work.isAppendTaskType(), work.getCboInfo(),\n        work.getOptimizedSQL());\n  }\n  public JSONObject getJSONPlan(PrintStream out, List<Task<?>> tasks, Task<?> fetchTask,\n      boolean jsonOutput, boolean isExtended, boolean appendTaskType, String cboInfo,\n      String optimizedSQL) throws Exception {\n    // If the user asked for a formatted output, dump the json output\n    // in the output stream\n    JSONObject outJSONObject = new JSONObject(new LinkedHashMap<>());\n    if (jsonOutput) {\n      out = null;\n    }\n    if (optimizedSQL != null) {\n      if (jsonOutput) {\n        outJSONObject.put(\"optimizedSQL\", optimizedSQL);\n      } else {\n        out.print(\"OPTIMIZED SQL: \");\n        out.println(optimizedSQL);\n      }\n    }\n    List<Task> ordered = StageIDsRearranger.getExplainOrder(conf, tasks);\n    if (fetchTask != null) {\n      fetchTask.setParentTasks((List)StageIDsRearranger.getFetchSources(tasks));\n      if (fetchTask.getNumParent() == 0) {\n        fetchTask.setRootTask(true);\n      }\n      ordered.add(fetchTask);\n    }\n    boolean suppressOthersForVectorization = false;\n    if (this.work != null && this.work.isVectorization()) {\n      ImmutablePair<Boolean, JSONObject> planVecPair = outputPlanVectorization(out, jsonOutput);\n      if (this.work.isVectorizationOnly()) {\n        // Suppress the STAGES if vectorization is off.\n        suppressOthersForVectorization = !planVecPair.left;\n      }\n      if (out != null) {\n        out.println();\n      }\n      if (jsonOutput) {\n        outJSONObject.put(\"PLAN VECTORIZATION\", planVecPair.right);\n      }\n    }\n    if (!suppressOthersForVectorization) {\n      JSONObject jsonDependencies = outputDependencies(out, jsonOutput, appendTaskType, ordered);\n      if (out != null) {\n        out.println();\n      }\n      if (jsonOutput) {\n        if (cboInfo != null) {\n          outJSONObject.put(\"cboInfo\", cboInfo);\n        }\n        outJSONObject.put(STAGE_DEPENDENCIES, jsonDependencies);\n      }\n      // Go over all the tasks and dump out the plans\n      JSONObject jsonPlan = outputStagePlans(out, ordered,\n           jsonOutput, isExtended);\n      if (jsonOutput) {\n        outJSONObject.put(\"STAGE PLANS\", jsonPlan);\n      }\n      if (fetchTask != null) {\n        fetchTask.setParentTasks(null);\n      }\n    }\n    return jsonOutput ? outJSONObject : null;\n  }\n  private List<String> toString(Collection<?> objects) {\n    List<String> list = new ArrayList<String>();\n    for (Object object : objects) {\n      list.add(String.valueOf(object));\n    }\n    return list;\n  }<fim_middle>// class below is blob\n"}