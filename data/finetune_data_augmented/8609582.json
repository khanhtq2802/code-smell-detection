{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ignite.internal.processors.cache.persistence.file;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\nimport java.nio.file.OpenOption;\nimport java.util.concurrent.ConcurrentHashMap;\nimport org.apache.ignite.IgniteLogger;\nimport org.apache.ignite.IgniteSystemProperties;\nimport org.apache.ignite.configuration.DataStorageConfiguration;\nimport org.apache.ignite.internal.util.GridUnsafe;\nimport org.apache.ignite.internal.util.typedef.internal.U;\nimport org.jetbrains.annotations.NotNull;\n\n/**\n * Direct native IO factory for block IO operations on aligned memory structures.<br>\n * This limited functionality is used for page store operations.<br>\n * <b>Note: </b> This type of IO not applicable for WAL or other files.<br> <br>\n * This IO tries to minimize cache effects of the I/O (page caching by OS). <br> <br>\n * In general this will degrade performance, but it is useful in special\n * situations, such as when applications do their own caching.<br>\n */\n<fim_suffix>public class AlignedBuffersDirectFileIOFactory implements FileIOFactory {\n    /** Logger. */\n    private final IgniteLogger log;\n\n    /** Page size from durable memory. */\n    private final int pageSize;\n\n    /** Backup factory for files in case native is not available or not applicable. */\n    private final FileIOFactory backupFactory;\n\n    /** File system/os block size, negative value if library init was failed. */\n    private final int ioBlockSize;\n\n    /** Use backup factory, {@code true} if direct IO setup failed. */\n    private boolean useBackupFactory;\n\n    /** Thread local with buffers with capacity = one page {@code pageSize} and aligned using {@code fsBlockSize}. */\n    private ThreadLocal<ByteBuffer> tlbOnePageAligned;\n\n    /**\n     * Managed aligned buffers. This collection is used to free buffers, an for checking if buffer is known to be\n     * already aligned.\n     */\n    private final ConcurrentHashMap<Long, Thread> managedAlignedBuffers = new ConcurrentHashMap<>();\n\n    /**\n     * Creates direct native IO factory.\n     *\n     * @param log Logger.\n     * @param storePath Storage path, used to check FS settings.\n     * @param pageSize durable memory page size.\n     * @param backupFactory fallback factory if init failed.\n     */\n    public AlignedBuffersDirectFileIOFactory(\n        final IgniteLogger log,\n        final File storePath,\n        final int pageSize,\n        final FileIOFactory backupFactory) {\n        this.log = log;\n        this.pageSize = pageSize;\n        this.backupFactory = backupFactory;\n\n        useBackupFactory = true;\n        ioBlockSize = IgniteNativeIoLib.getDirectIOBlockSize(storePath.getAbsolutePath(), log);\n\n        if(!IgniteSystemProperties.getBoolean(IgniteSystemProperties.IGNITE_DIRECT_IO_ENABLED, true)) {\n            if (log.isInfoEnabled())\n                log.info(\"Direct IO is explicitly disabled by system property.\");\n\n            return;\n        }\n\n        if (ioBlockSize > 0) {\n            int blkSize = ioBlockSize;\n\n            if (pageSize % blkSize != 0) {\n                U.warn(log, String.format(\"Unable to setup Direct IO for Ignite [pageSize=%d bytes;\" +\n                        \" file system block size=%d]. For speeding up Ignite consider setting %s.setPageSize(%d).\" +\n                        \" Direct IO is disabled.\",\n                    pageSize, blkSize, DataStorageConfiguration.class.getSimpleName(), blkSize));\n            }\n            else {\n                useBackupFactory = false;\n\n                tlbOnePageAligned = new ThreadLocal<ByteBuffer>() {\n                    @Override protected ByteBuffer initialValue() {\n                        return createManagedBuffer(pageSize);\n                    }\n                };\n\n                if (log.isInfoEnabled()) {\n                    log.info(String.format(\"Direct IO is enabled for block IO operations on aligned memory structures.\" +\n                        \" [block size = %d, durable memory page size = %d]\", blkSize, pageSize));\n                }\n            }\n        }\n        else {\n            if (log.isInfoEnabled()) {\n                log.info(String.format(\"Direct IO library is not available on current operating system [%s].\" +\n                    \" Direct IO is not enabled.\", System.getProperty(\"os.version\")));\n            }\n        }\n\n    }\n\n    /**\n     * <b>Note: </b> Use only if {@link #isDirectIoAvailable()}.\n     *\n     * @param size buffer size to allocate.\n     * @return new byte buffer.\n     */\n    @NotNull ByteBuffer createManagedBuffer(int size) {\n        assert !useBackupFactory : \"Direct IO is disabled, aligned managed buffer creation is disabled now\";\n        assert managedAlignedBuffers != null : \"Direct buffers not available\";\n\n        ByteBuffer allocate = AlignedBuffers.allocate(ioBlockSize, size).order(ByteOrder.nativeOrder());\n\n        managedAlignedBuffers.put(GridUnsafe.bufferAddress(allocate), Thread.currentThread());\n\n        return allocate;\n    }\n\n    /** {@inheritDoc} */\n    @Override public FileIO create(File file, OpenOption... modes) throws IOException {\n        if (useBackupFactory)\n            return backupFactory.create(file, modes);\n\n        return new AlignedBuffersDirectFileIO(ioBlockSize, pageSize, file, modes, tlbOnePageAligned, managedAlignedBuffers, log);\n\n    }\n\n    /**\n     * @return {@code true} if Direct IO can be used on current OS and file system settings\n     */\n    boolean isDirectIoAvailable() {\n        return !useBackupFactory;\n    }\n\n    /**\n     * Managed aligned buffers and its associated threads. This collection is used to free buffers, an for checking if\n     * buffer is known to be already aligned.\n     *\n     * @return map address->thread.\n     */\n    ConcurrentHashMap<Long, Thread> managedAlignedBuffers() {\n        return managedAlignedBuffers;\n    }\n}<fim_middle>// class below has no smell\n"}