{"text": "<fim_prefix>        addLast(e);\n        return true;\n    }\n    /**\n     * Retrieves, but does not remove, the first element of this list,\n     * or returns {@code null} if this list is empty.\n     *\n     * @return the first element of this list, or {@code null}\n     *         if this list is empty\n     * @since 1.6\n     */\n    public E peekFirst() {\n        final Node<E> f = first;\n        return (f == null) ? null : f.item;\n     }\n    /**\n     * Retrieves, but does not remove, the last element of this list,\n     * or returns {@code null} if this list is empty.\n     *\n     * @return the last element of this list, or {@code null}\n     *         if this list is empty\n     * @since 1.6\n     */\n    public E peekLast() {\n        final Node<E> l = last;\n        return (l == null) ? null : l.item;\n    }\n    /**\n     * Retrieves and removes the first element of this list,\n     * or returns {@code null} if this list is empty.\n     *\n     * @return the first element of this list, or {@code null} if\n     *     this list is empty\n     * @since 1.6\n     */\n    public E pollFirst() {\n        final Node<E> f = first;\n        return (f == null) ? null : unlinkFirst(f);\n    }\n    /**\n     * Retrieves and removes the last element of this list,\n     * or returns {@code null} if this list is empty.\n     *\n     * @return the last element of this list, or {@code null} if\n     *     this list is empty\n     * @since 1.6\n     */\n    public E pollLast() {\n        final Node<E> l = last;\n        return (l == null) ? null : unlinkLast(l);\n    }\n    /**\n     * Pushes an element onto the stack represented by this list.  In other\n     * words, inserts the element at the front of this list.\n     *\n     * <p>This method is equivalent to {@link #addFirst}.\n     *\n     * @param e the element to push\n     * @since 1.6\n     */\n    public void push(E e) {\n        addFirst(e);\n    }\n    /**\n     * Pops an element from the stack represented by this list.  In other\n     * words, removes and returns the first element of this list.\n     *\n     * <p>This method is equivalent to {@link #removeFirst()}.\n     *\n     * @return the element at the front of this list (which is the top\n     *         of the stack represented by this list)\n     * @throws NoSuchElementException if this list is empty\n     * @since 1.6\n     */\n    public E pop() {\n        return removeFirst();\n    }\n    /**\n     * Removes the first occurrence of the specified element in this\n     * list (when traversing the list from head to tail).  If the list\n     * does not contain the element, it is unchanged.\n     *\n     * @param o element to be removed from this list, if present\n     * @return {@code true} if the list contained the specified element\n     * @since 1.6\n     */\n    public boolean removeFirstOccurrence(Object o) {\n        return remove(o);\n    }\n    /**\n     * Removes the last occurrence of the specified element in this\n     * list (when traversing the list from head to tail).  If the list\n     * does not contain the element, it is unchanged.\n     *\n     * @param o element to be removed from this list, if present\n     * @return {@code true} if the list contained the specified element\n     * @since 1.6\n     */\n    public boolean removeLastOccurrence(Object o) {\n        if (o == null) {\n            for (Node<E> x = last; x != null; x = x.prev) {\n                if (x.item == null) {\n                    unlink(x);\n                    return true;\n                }\n            }\n        } else {\n            for (Node<E> x = last; x != null; x = x.prev) {\n                if (o.equals(x.item)) {\n                    unlink(x);\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    /**\n     * Returns a list-iterator of the elements in this list (in proper\n     * sequence), starting at the specified position in the list.\n     * Obeys the general contract of {@code List.listIterator(int)}.<p>\n     *\n     * The list-iterator is <i>fail-fast</i>: if the list is structurally\n     * modified at any time after the Iterator is created, in any way except\n     * through the list-iterator's own {@code remove} or {@code add}\n     * methods, the list-iterator will throw a\n     * {@code ConcurrentModificationException}.  Thus, in the face of\n     * concurrent modification, the iterator fails quickly and cleanly, rather\n     * than risking arbitrary, non-deterministic behavior at an undetermined\n     * time in the future.\n     *\n     * @param index index of the first element to be returned from the\n     *              list-iterator (by a call to {@code next})\n     * @return a ListIterator of the elements in this list (in proper\n     *         sequence), starting at the specified position in the list\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     * @see List#listIterator(int)\n     */\n    public ListIterator<E> listIterator(int index) {\n        checkPositionIndex(index);\n        return new ListItr(index);\n    }\n    private class ListItr implements ListIterator<E> {\n        private Node<E> lastReturned = null;\n        private Node<E> next;\n        private int nextIndex;\n        private int expectedModCount = modCount;\n        ListItr(int index) {\n            // assert isPositionIndex(index);\n            next = (index == size) ? null : node(index);\n            nextIndex = index;\n        }\n        public boolean hasNext() {\n            return nextIndex < size;\n        }\n        public E next() {\n            checkForComodification();\n            if (!hasNext())\n                throw new NoSuchElementException();\n            lastReturned = next;\n            next = next.next;\n            nextIndex++;\n            return lastReturned.item;\n        }\n        public boolean hasPrevious() {\n            return nextIndex > 0;\n        }\n        public E previous() {\n            checkForComodification();\n            if (!hasPrevious())\n                throw new NoSuchElementException();\n            lastReturned = next = (next == null) ? last : next.prev;\n            nextIndex--;\n            return lastReturned.item;\n        }\n        public int nextIndex() {\n            return nextIndex;\n        }\n        public int previousIndex() {\n            return nextIndex - 1;\n        }\n        public void remove() {\n            checkForComodification();\n            if (lastReturned == null)\n                throw new IllegalStateException();\n            Node<E> lastNext = lastReturned.next;\n            unlink(lastReturned);\n            if (next == lastReturned)\n                next = lastNext;\n            else\n                nextIndex--;\n            lastReturned = null;\n            expectedModCount++;\n        }\n        public void set(E e) {\n            if (lastReturned == null)\n                throw new IllegalStateException();\n            checkForComodification();\n            lastReturned.item = e;\n        }\n        public void add(E e) {\n            checkForComodification();\n            lastReturned = null;\n            if (next == null)\n                linkLast(e);\n            else\n                linkBefore(e, next);\n            nextIndex++;\n            expectedModCount++;\n        }\n        @Override\n        public void forEachRemaining(Consumer<? super E> action) {\n            Objects.requireNonNull(action);\n            while (modCount == expectedModCount && nextIndex < size) {\n                action.accept(next.item);\n                lastReturned = next;\n                next = next.next;\n                nextIndex++;\n            }\n            checkForComodification();\n        }\n        final void checkForComodification() {\n            if (modCount != expectedModCount)\n                throw new ConcurrentModificationException();\n        }\n    }\n    private static class Node<E> {\n        E item;\n        Node<E> next;\n        @Weak Node<E> prev;\n        Node(Node<E> prev, E element, Node<E> next) {\n            this.item = element;\n            this.next = next;\n            this.prev = prev;\n        }\n    }\n    /**\n     * @since 1.6\n     */\n    public Iterator<E> descendingIterator() {\n        return new DescendingIterator();\n    }\n    /**\n     * Adapter to provide descending iterators via ListItr.previous\n     */\n<fim_suffix>    private class DescendingIterator implements Iterator<E> {\n        private final ListItr itr = new ListItr(size());\n        public boolean hasNext() {\n            return itr.hasPrevious();\n        }\n        public E next() {\n            return itr.previous();\n        }\n        public void remove() {\n            itr.remove();\n        }\n    }<fim_middle>// class below has no smell\n"}