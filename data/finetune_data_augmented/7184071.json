{"text": "<fim_prefix>/* Copyright (c) 2014, 2018, Oracle and/or its affiliates. \nAll rights reserved.*/\n/*\n   DESCRIPTION\n    Parser for JSON paths found in QBE documents, index specifications, etc.\n   NOTES\n    A path consists of a series of steps. There are two kinds of steps:\n      - field steps\n      - array steps\n    A path may start with a field step or an array step.\n    A field step is a series of allowed characters, or a string enclosed\n    in backquotes. Certain characters (such as path step syntactic characters)\n    must be enclosed in backquotes. A * is a special field step that is\n    treated as a wildcard.\n    A dot (.) must be followed by a field step, and field steps after\n    the first step must be preceded by a dot.\n    An array step is delimited by square brackets.\n    An array step may follow a field step or another array step.\n */\n/**\n * This class is not part of the public API, and is\n * subject to change.\n *\n * Do not rely on it in your application code.\n *\n *  @author  Rahul Kadwe\n *  @author  Doug McMahon\n */\npackage oracle.json.parser;\nimport java.util.ArrayList;\nimport java.util.Formatter;\npublic class PathParser\n{\n  private static final char STEP_SEPARATOR = '.';  // period\n  private static final char SEG_DELIMITER  = '`';  // backquote\n  private static final char SQL_DELIMITER  = '\"';  // double quotes\n  private static final char ESCAPE_CHAR    = '\\\\'; // backslash\n  private static final char ARRAY_START    = '[';\n  private static final char ARRAY_STOP     = ']';\n  private static final char WILD_STEP      = '*';\n  private static final char ROOT_STEP      = '$';\n  private static final char CONTEXT_STEP   = '@';\n  private final String pathString;\n  private static final String ALPHA_NUM_UNDER =\n    \"_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n  private static final int    IS_DIGIT_POS = ALPHA_NUM_UNDER.indexOf('0');\n  /**\n   * Create a path parser for the given path string.\n   */\n  public PathParser(String pathString)\n  {\n    this.pathString = pathString;\n  }\n  private String buildStep(StringBuilder sb, int pos,\n                           boolean needsQuotes, boolean quotedStep)\n    throws QueryException\n  {\n    String result;\n    if ((needsQuotes) && (!quotedStep))\n    {\n      // Unquoted empty steps are not allowed\n      if (sb.length() == 1)\n        throwPathException(QueryMessage.EX_EMPTY_PATH_STEP, pos);\n      if (sb.length() == 2)\n      {\n        char ch = sb.charAt(1);\n        // Naked $ or @ sign not allowed\n        if ((ch == ROOT_STEP) || (ch == CONTEXT_STEP))\n          throwPathException(QueryMessage.EX_PATH_SYNTAX_ERROR, pos);\n        // This strips the quotes from a singleton * step\n        if (ch == WILD_STEP)\n          needsQuotes = false;\n      }\n    }\n    if (!needsQuotes)\n      result = sb.substring(1);\n    else\n    {\n      sb.append(SQL_DELIMITER);\n      result = sb.toString();\n    }\n    sb.setLength(1);\n    return(result);\n  }\n  private String buildArrayStep(StringBuilder sb)\n  {\n    String result;\n    sb.append(ARRAY_STOP);\n    result = sb.toString();\n    sb.setLength(0);\n    sb.append(SQL_DELIMITER);\n    return(result);\n  }\n  private void throwException(QueryMessage msg, Object... params)\n    throws QueryException\n  {\n    throw new QueryException(msg.get(params));\n  }\n  private void throwPathException(QueryMessage msg, int position)\n    throws QueryException\n  {\n    throwException(msg, pathString, Integer.toString(position));\n  }\n  private void throwArrayException(String arrStep)\n    throws QueryException\n  {\n    throwException(QueryMessage.EX_BAD_ARRAY_SUBSCRIPT,\n                   pathString, arrStep);\n  }\n  /*\n  ** Allowed forms:\n  **   [*]            wildcard (must be the only entry)\n  **   [123]          single entry\n  **   [1 to 4]       range of entries\n  **   [1,2,3]        series of entries\n  **   [1, 3 to 5, 8] series of entries and ranges\n  */\n<fim_suffix>  private void validateArrayStep(String arrStep)\n    throws QueryException\n  {\n    boolean wildAllowed  = true;    // * is allowed initially\n    boolean digitAllowed = true;    // Digit is allowed as next char\n    boolean commaAllowed = false;   // Comma is allowed as next char\n    boolean afterDigit    = false;  // Last non-space was a digit\n    boolean toAllowed     = false;  // Any space after digit allows \"to\"\n    boolean afterTo       = false;  // After \"to\" expecting range end\n    boolean toInProgress  = false;  // Prior char was 't' in \"to\"\n    boolean spaceRequired = false;  // A whitespace is required (after \"to\")\n    boolean digitRequired = false;  // Digit required after comma or \"to\"\n    for (int i = 1; i < arrStep.length() - 1; ++i)\n    {\n      char currentChar = arrStep.charAt(i);\n      if (currentChar == '*')\n      {\n        if (!wildAllowed)\n          throwArrayException(arrStep);\n        wildAllowed  = false;  // We've seen the only allowed wildcard\n        digitAllowed = false;  // Only whitespace is allowed afterward\n      }\n      else if (currentChar == ',')\n      {\n        if (!commaAllowed)\n          throwArrayException(arrStep);\n        commaAllowed  = false;\n        toAllowed     = false;\n        afterDigit    = false;\n        afterTo       = false;\n        digitRequired = true;  // Next non-space must be a digit\n      }\n      else if (\"0123456789\".indexOf(currentChar) >= 0)\n      {\n        if (!digitAllowed)\n          throwArrayException(arrStep);\n        wildAllowed   = false; // Wildcard no longer allowed\n        commaAllowed  = true;\n        afterDigit    = true;\n        digitRequired = false;\n      }\n      else if (\" \\t\\n\\r\".indexOf(currentChar) >= 0)\n      {\n        // Whitespace not allowed when parsing \"to\"\n        if (toInProgress)\n          throwArrayException(arrStep);\n        if (afterDigit)\n        {\n          // Last non-space was a digit - next non-space is \"to\" or comma\n          digitAllowed = false;\n          toAllowed    = !afterTo;\n          commaAllowed = true;\n        }\n        else if (spaceRequired)\n        {\n          // This is the whitespace required after \"to\"\n          digitAllowed  = true;\n          spaceRequired = false;\n          digitRequired = true;  // At least one digit must follow\n        }\n      }\n      else if (currentChar == 't')\n      {\n        if (!toAllowed)\n          throwArrayException(arrStep);\n        toInProgress = true;  // Next char must be the 'o' in \"to\"\n        commaAllowed = false;\n        afterDigit   = false;\n      }\n      else if (currentChar == 'o')\n      {\n        if (!toInProgress)\n          throwArrayException(arrStep);\n        toInProgress  = false;\n        toAllowed     = false;\n        afterTo       = true;\n        spaceRequired = true;  // \"to\" must be followed by whitespace\n      }\n      else\n      {\n        // Invalid character\n        throwArrayException(arrStep);\n      }\n    }\n    // Empty array or only whitespace found\n    if (wildAllowed)\n      throwArrayException(arrStep);\n    // Incomplete \"to\" or comma sequence at end of subscript\n    if (toInProgress || spaceRequired || digitRequired)\n      throwArrayException(arrStep);\n  }\n  /**\n   * Parse the path into an array of steps.\n   * The steps are suitable for assembly into a single\n   * single-quoted literal, meaning that any necessary\n   * escaping and/or double quoting has been done.\n   * Returns null if the path cannot be parsed properly.\n   */\n  public String[] splitAndSQLEscape()\n    throws QueryException\n  {\n    if (pathString == null)\n      throwException(QueryMessage.EX_EMPTY_PATH);\n    return(splitSteps(true));\n  }\n  /**\n   * Parse the path into an array of steps.\n   * The steps are suitable for assembly into a single\n   * single-quoted literal, meaning that any necessary\n   * escaping and/or double quoting has been done.\n   * Returns null if the path cannot be parsed properly.\n   */\n  public String[] splitSteps(boolean doSqlEscape)\n    throws QueryException\n  {\n    if (pathString == null)\n      throwException(QueryMessage.EX_EMPTY_PATH);\n    char [] pathChars = pathString.toCharArray();\n    int pathLen = pathChars.length;<fim_middle>// function below is long method\n"}