{"text": "<fim_prefix>            cfOptions.positionInfo = positionInfo;\n            cfOptions.localInfo = localInfo;\n            cfOptions.strictNameCheck = strictNameCheck;\n            cfOptions.optimize = optimize;\n            cfOptions.optimizeListFile = optimizeListFile;\n            cfOptions.dontOptimizeListFile = dontOptimizeListFile;\n            cfOptions.statistics = statistics;\n            if (warnings) {\n                cfOptions.warn = DxConsole.err;\n            } else {\n                cfOptions.warn = DxConsole.noop;\n            }\n            dexOptions = new DexOptions();\n            dexOptions.forceJumbo = forceJumbo;\n        }\n    }\n    /**\n     * Callback class for processing input file bytes, produced by the\n     * ClassPathOpener.\n     */\n    private  class FileBytesConsumer implements ClassPathOpener.Consumer {\n        @Override\n        public boolean processFileBytes(String name, long lastModified,\n                byte[] bytes)   {\n            return Main.this.processFileBytes(name, lastModified, bytes);\n        }\n        @Override\n        public void onException(Exception ex) {\n            if (ex instanceof StopProcessing) {\n                throw (StopProcessing) ex;\n            } else if (ex instanceof SimException) {\n                DxConsole.err.println(\"\\nEXCEPTION FROM SIMULATION:\");\n                DxConsole.err.println(ex.getMessage() + \"\\n\");\n                DxConsole.err.println(((SimException) ex).getContext());\n            } else if (ex instanceof ParseException) {\n                DxConsole.err.println(\"\\nPARSE ERROR:\");\n                ParseException parseException = (ParseException) ex;\n                if (args.debug) {\n                    parseException.printStackTrace(DxConsole.err);\n                } else {\n                    parseException.printContext(DxConsole.err);\n                }\n            } else {\n                DxConsole.err.println(\"\\nUNEXPECTED TOP-LEVEL EXCEPTION:\");\n                ex.printStackTrace(DxConsole.err);\n            }\n            errors.incrementAndGet();\n        }\n        @Override\n        public void onProcessArchiveStart(File file) {\n            if (args.verbose) {\n                DxConsole.out.println(\"processing archive \" + file + \"...\");\n            }\n        }\n    }\n    /** Callable helper class to parse class bytes. */\n    private  class ClassParserTask implements Callable<DirectClassFile> {\n        String name;\n        byte[] bytes;\n        private ClassParserTask(String name, byte[] bytes) {\n            this.name = name;\n            this.bytes = bytes;\n        }\n        @Override\n        public DirectClassFile call() throws Exception {\n            DirectClassFile cf =  parseClass(name, bytes);\n            return cf;\n        }\n    }\n    /**\n     * Callable helper class used to sequentially collect the results of\n     * the (optionally parallel) translation phase, in correct input file order.\n     * This class is also responsible for coordinating dex file rotation\n     * with the ClassDefItemConsumer class.\n     * We maintain invariant that the number of indices used in the current\n     * dex file plus the max number of indices required by classes passed to\n     * the translation phase and not yet added to the dex file, is less than\n     * or equal to the dex file limit.\n     * For each parsed file, we estimate the maximum number of indices it may\n     * require. If passing the file to the translation phase would invalidate\n     * the invariant, we wait, until the next class is added to the dex file,\n     * and then reevaluate the invariant. If there are no further classes in\n     * the translation phase, we rotate the dex file.\n     */\n    private  class DirectClassFileConsumer implements Callable<Boolean> {\n        String name;\n        byte[] bytes;\n        Future<DirectClassFile> dcff;\n        private DirectClassFileConsumer(String name, byte[] bytes,\n                Future<DirectClassFile> dcff) {\n            this.name = name;\n            this.bytes = bytes;\n            this.dcff = dcff;\n        }\n        @Override\n        public Boolean call() throws Exception {\n            DirectClassFile cf = dcff.get();\n            return call(cf);\n        }\n        private Boolean call(DirectClassFile cf) {\n            int maxMethodIdsInClass = 0;\n            int maxFieldIdsInClass = 0;\n            if (args.multiDex) {\n                // Calculate max number of indices this class will add to the\n                // dex file.\n                // The possibility of overloading means that we can't easily\n                // know how many constant are needed for declared methods and\n                // fields. We therefore make the simplifying assumption that\n                // all constants are external method or field references.\n                int constantPoolSize = cf.getConstantPool().size();\n                maxMethodIdsInClass = constantPoolSize + cf.getMethods().size()\n                        + MAX_METHOD_ADDED_DURING_DEX_CREATION;\n                maxFieldIdsInClass = constantPoolSize + cf.getFields().size()\n                        + MAX_FIELD_ADDED_DURING_DEX_CREATION;\n                synchronized(dexRotationLock) {\n                    int numMethodIds;\n                    int numFieldIds;\n                    // Number of indices used in current dex file.\n                    synchronized(outputDex) {\n                        numMethodIds = outputDex.getMethodIds().items().size();\n                        numFieldIds = outputDex.getFieldIds().items().size();\n                    }\n                    // Wait until we're sure this class will fit in the current\n                    // dex file.\n                    while(((numMethodIds + maxMethodIdsInClass + maxMethodIdsInProcess\n                            > args.maxNumberOfIdxPerDex) ||\n                           (numFieldIds + maxFieldIdsInClass + maxFieldIdsInProcess\n                            > args.maxNumberOfIdxPerDex))) {\n                        if (maxMethodIdsInProcess > 0 || maxFieldIdsInProcess > 0) {\n                            // There are classes in the translation phase that\n                            // have not yet been added to the dex file, so we\n                            // wait for the next class to complete.\n                            try {\n                                dexRotationLock.wait();\n                            } catch(InterruptedException ex) {\n                                /* ignore */\n                            }\n                        } else if (outputDex.getClassDefs().items().size() > 0) {\n                            // There are no further classes in the translation\n                            // phase, and we have a full dex file. Rotate!\n                            rotateDexFile();\n                        } else {\n                            // The estimated number of indices is too large for\n                            // an empty dex file. We proceed hoping the actual\n                            // number of indices needed will fit.\n                            break;\n                        }\n                        synchronized(outputDex) {\n                            numMethodIds = outputDex.getMethodIds().items().size();\n                            numFieldIds = outputDex.getFieldIds().items().size();\n                        }\n                    }\n                    // Add our estimate to the total estimate for\n                    // classes under translation.\n                    maxMethodIdsInProcess += maxMethodIdsInClass;\n                    maxFieldIdsInProcess += maxFieldIdsInClass;\n                }\n            }\n            // Submit class to translation phase.\n            if (args.numThreads > 1){\n                Future<ClassDefItem> cdif = classTranslatorPool.submit(\n                        new ClassTranslatorTask(name, bytes, cf));\n                Future<Boolean> res = classDefItemConsumer.submit(new ClassDefItemConsumer(\n                        name, cdif, maxMethodIdsInClass, maxFieldIdsInClass));\n                addToDexFutures.add(res);\n            }else {\n//\n                ClassDefItem classDefItem = new ClassTranslatorTask(name, bytes, cf).call();\n                try {\n                    Boolean result = new ClassDefItemConsumer(name, classDefItem, maxMethodIdsInClass, maxFieldIdsInClass).call();\n                    resultList.add(result);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n            return true;\n        }\n    }\n    /** Callable helper class to translate classes in parallel  */\n    private  class ClassTranslatorTask implements Callable<ClassDefItem> {\n        String name;\n        byte[] bytes;\n        DirectClassFile classFile;\n        private ClassTranslatorTask(String name, byte[] bytes,\n                DirectClassFile classFile) {\n            this.name = name;\n            this.bytes = bytes;\n            this.classFile = classFile;\n        }\n        @Override\n        public ClassDefItem call() {\n            ClassDefItem clazz = translateClass(bytes, classFile);\n            return clazz;\n        }\n    }\n    /**\n     * Callable helper class used to collect the results of\n     * the parallel translation phase, adding the translated classes to\n     * the current dex file in correct (deterministic) file order.\n     * This class is also responsible for coordinating dex file rotation\n     * with the DirectClassFileConsumer class.\n     */\n    private  class ClassDefItemConsumer implements Callable<Boolean> {\n        String name;\n        Future<ClassDefItem> futureClazz;\n        int maxMethodIdsInClass;\n        int maxFieldIdsInClass;\n        private ClassDefItem clazz;\n<fim_suffix>        private ClassDefItemConsumer(String name, Future<ClassDefItem> futureClazz,\n                int maxMethodIdsInClass, int maxFieldIdsInClass) {\n            this.name = name;\n            this.futureClazz = futureClazz;\n            this.maxMethodIdsInClass = maxMethodIdsInClass;\n            this.maxFieldIdsInClass = maxFieldIdsInClass;\n        }<fim_middle>// function below has no smell\n"}