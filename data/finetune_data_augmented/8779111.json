{"text": "<fim_prefix>\n<fim_suffix>@InterfaceAudience.Private\n@Metrics(context=\"metricssystem\")\npublic class MetricsSystemImpl extends MetricsSystem implements MetricsSource {\n  static final Log LOG = LogFactory.getLog(MetricsSystemImpl.class);\n  static final String MS_NAME = \"MetricsSystem\";\n  static final String MS_STATS_NAME = MS_NAME +\",sub=Stats\";\n  static final String MS_STATS_DESC = \"Metrics system metrics\";\n  static final String MS_CONTROL_NAME = MS_NAME +\",sub=Control\";\n  static final String MS_INIT_MODE_KEY = \"hadoop.metrics.init.mode\";\n  enum InitMode { NORMAL, STANDBY }\n  private final Map<String, MetricsSourceAdapter> sources;\n  private final Map<String, MetricsSource> allSources;\n  private final Map<String, MetricsSinkAdapter> sinks;\n  private final Map<String, MetricsSink> allSinks;\n  private final List<Callback> callbacks;\n  private final MetricsCollectorImpl collector;\n  private final MetricsRegistry registry = new MetricsRegistry(MS_NAME);\n  @Metric({\"Snapshot\", \"Snapshot stats\"}) MutableStat snapshotStat;\n  @Metric({\"Publish\", \"Publishing stats\"}) MutableStat publishStat;\n  @Metric(\"Dropped updates by all sinks\") MutableCounterLong droppedPubAll;\n  private final List<MetricsTag> injectedTags;\n  // Things that are changed by init()/start()/stop()\n  private String prefix;\n  private MetricsFilter sourceFilter;\n  private MetricsConfig config;\n  private Map<String, MetricsConfig> sourceConfigs, sinkConfigs;\n  private boolean monitoring = false;\n  private Timer timer;\n  private int period; // seconds\n  private long logicalTime; // number of timer invocations * period\n  private ObjectName mbeanName;\n  private boolean publishSelfMetrics = true;\n  private MetricsSourceAdapter sysSource;\n  private int refCount = 0; // for mini cluster mode\n  /**\n   * Construct the metrics system\n   * @param prefix  for the system\n   */\n  public MetricsSystemImpl(String prefix) {\n    this.prefix = prefix;\n    allSources = Maps.newHashMap();\n    sources = Maps.newLinkedHashMap();\n    allSinks = Maps.newHashMap();\n    sinks = Maps.newLinkedHashMap();\n    sourceConfigs = Maps.newHashMap();\n    sinkConfigs = Maps.newHashMap();\n    callbacks = Lists.newArrayList();\n    injectedTags = Lists.newArrayList();\n    collector = new MetricsCollectorImpl();\n    if (prefix != null) {\n      // prefix could be null for default ctor, which requires init later\n      initSystemMBean();\n    }\n  }\n  /**\n   * Construct the system but not initializing (read config etc.) it.\n   */\n  public MetricsSystemImpl() {\n    this(null);\n  }\n  /**\n   * Initialized the metrics system with a prefix.\n   * @param prefix  the system will look for configs with the prefix\n   * @return the metrics system object itself\n   */\n  @Override\n  public synchronized MetricsSystem init(String prefix) {\n    if (monitoring && !DefaultMetricsSystem.inMiniClusterMode()) {\n      LOG.warn(this.prefix +\" metrics system already initialized!\");\n      return this;\n    }\n    this.prefix = checkNotNull(prefix, \"prefix\");\n    ++refCount;\n    if (monitoring) {\n      // in mini cluster mode\n      LOG.info(this.prefix +\" metrics system started (again)\");\n      return this;\n    }\n    switch (initMode()) {\n      case NORMAL:\n        try { start(); }\n        catch (MetricsConfigException e) {\n          // Configuration errors (e.g., typos) should not be fatal.\n          // We can always start the metrics system later via JMX.\n          LOG.warn(\"Metrics system not started: \"+ e.getMessage());\n          LOG.debug(\"Stacktrace: \", e);\n        }\n        break;\n      case STANDBY:\n        LOG.info(prefix +\" metrics system started in standby mode\");\n    }\n    initSystemMBean();\n    return this;\n  }\n  @Override\n  public synchronized void start() {\n    checkNotNull(prefix, \"prefix\");\n    if (monitoring) {\n      LOG.warn(prefix +\" metrics system already started!\",\n               new MetricsException(\"Illegal start\"));\n      return;\n    }\n    for (Callback cb : callbacks) cb.preStart();\n    configure(prefix);\n    startTimer();\n    monitoring = true;\n    LOG.info(prefix +\" metrics system started\");\n    for (Callback cb : callbacks) cb.postStart();\n  }\n  @Override\n  public synchronized void stop() {\n    if (!monitoring && !DefaultMetricsSystem.inMiniClusterMode()) {\n      LOG.warn(prefix +\" metrics system not yet started!\",\n               new MetricsException(\"Illegal stop\"));\n      return;\n    }\n    if (!monitoring) {\n      // in mini cluster mode\n      LOG.info(prefix +\" metrics system stopped (again)\");\n      return;\n    }\n    for (Callback cb : callbacks) cb.preStop();\n    LOG.info(\"Stopping \"+ prefix +\" metrics system...\");\n    stopTimer();\n    stopSources();\n    stopSinks();\n    clearConfigs();\n    monitoring = false;\n    LOG.info(prefix +\" metrics system stopped.\");\n    for (Callback cb : callbacks) cb.postStop();\n  }\n  @Override public synchronized <T>\n  T register(String name, String desc, T source) {\n    MetricsSourceBuilder sb = MetricsAnnotations.newSourceBuilder(source);\n    final MetricsSource s = sb.build();\n    MetricsInfo si = sb.info();\n    String name2 = name == null ? si.name() : name;\n    final String finalDesc = desc == null ? si.description() : desc;\n    final String finalName = // be friendly to non-metrics tests\n        DefaultMetricsSystem.sourceName(name2, !monitoring);\n    allSources.put(finalName, s);\n    LOG.debug(finalName +\", \"+ finalDesc);\n    if (monitoring) {\n      registerSource(finalName, finalDesc, s);\n    }\n    // We want to re-register the source to pick up new config when the\n    // metrics system restarts.\n    register(new AbstractCallback() {\n      @Override public void postStart() {\n        registerSource(finalName, finalDesc, s);\n      }\n    });\n    return source;\n  }\n  @Override public synchronized\n  void unregisterSource(String name) {\n    if (sources.containsKey(name)) {\n      sources.get(name).stop();\n      sources.remove(name);\n    }\n    if (allSources.containsKey(name)) {\n      allSources.remove(name);\n    }\n  }\n  synchronized\n  void registerSource(String name, String desc, MetricsSource source) {\n    checkNotNull(config, \"config\");\n    MetricsConfig conf = sourceConfigs.get(name);\n    MetricsSourceAdapter sa = new MetricsSourceAdapter(prefix, name, desc,\n        source, injectedTags, period, conf != null ? conf\n            : config.subset(SOURCE_KEY));\n    sources.put(name, sa);\n    sa.start();\n    LOG.debug(\"Registered source \"+ name);\n  }\n  @Override public synchronized <T extends MetricsSink>\n  T register(final String name, final String description, final T sink) {\n    LOG.debug(name +\", \"+ description);\n    if (allSinks.containsKey(name)) {\n      LOG.warn(\"Sink \"+ name +\" already exists!\");\n      return sink;\n    }\n    allSinks.put(name, sink);\n    if (config != null) {\n      registerSink(name, description, sink);\n    }\n    // We want to re-register the sink to pick up new config\n    // when the metrics system restarts.\n    register(new AbstractCallback() {\n      @Override public void postStart() {\n        register(name, description, sink);\n      }\n    });\n    return sink;\n  }\n  synchronized void registerSink(String name, String desc, MetricsSink sink) {\n    checkNotNull(config, \"config\");\n    MetricsConfig conf = sinkConfigs.get(name);\n    MetricsSinkAdapter sa = conf != null\n        ? newSink(name, desc, sink, conf)\n        : newSink(name, desc, sink, config.subset(SINK_KEY));\n    sinks.put(name, sa);\n    sa.start();\n    LOG.info(\"Registered sink \"+ name);\n  }\n  @Override\n  public synchronized void register(final Callback callback) {\n    callbacks.add((Callback) Proxy.newProxyInstance(\n        callback.getClass().getClassLoader(), new Class<?>[] { Callback.class },\n        new InvocationHandler() {\n          @Override\n          public Object invoke(Object proxy, Method method, Object[] args)\n              throws Throwable {\n            try {\n              return method.invoke(callback, args);\n            } catch (Exception e) {\n              // These are not considered fatal.\n              LOG.warn(\"Caught exception in callback \"+ method.getName(), e);\n            }\n            return null;\n          }\n        }));\n  }\n  @Override\n  public synchronized void startMetricsMBeans() {\n    for (MetricsSourceAdapter sa : sources.values()) {\n      sa.startMBeans();\n    }\n  }\n  @Override\n  public synchronized void stopMetricsMBeans() {\n    for (MetricsSourceAdapter sa : sources.values()) {\n      sa.stopMBeans();\n    }\n  }\n  @Override<fim_middle>// class below is blob\n"}