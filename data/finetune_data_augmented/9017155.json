{"text": "<fim_prefix>\n<fim_suffix>public class IntRange extends Field {\n  /** stores integer values so number of bytes is 4 */\n  public static final int BYTES = Integer.BYTES;\n  /**\n   * Create a new IntRange type, from min/max parallel arrays\n   *\n   * @param name field name. must not be null.\n   * @param min range min values; each entry is the min value for the dimension\n   * @param max range max values; each entry is the max value for the dimension\n   */\n  public IntRange(String name, final int[] min, final int[] max) {\n    super(name, getType(min.length));\n    setRangeValues(min, max);\n  }\n  /** set the field type */\n  private static FieldType getType(int dimensions) {\n    if (dimensions > 4) {\n      throw new IllegalArgumentException(\"IntRange does not support greater than 4 dimensions\");\n    }\n    FieldType ft = new FieldType();\n    // dimensions is set as 2*dimension size (min/max per dimension)\n    ft.setDimensions(dimensions*2, BYTES);\n    ft.freeze();\n    return ft;\n  }\n  /**\n   * Changes the values of the field.\n   * @param min array of min values. (accepts {@code Integer.NEGATIVE_INFINITY})\n   * @param max array of max values. (accepts {@code Integer.POSITIVE_INFINITY})\n   * @throws IllegalArgumentException if {@code min} or {@code max} is invalid\n   */\n  public void setRangeValues(int[] min, int[] max) {\n    checkArgs(min, max);\n    if (min.length*2 != type.pointDataDimensionCount() || max.length*2 != type.pointDataDimensionCount()) {\n      throw new IllegalArgumentException(\"field (name=\" + name + \") uses \" + type.pointDataDimensionCount()/2\n          + \" dimensions; cannot change to (incoming) \" + min.length + \" dimensions\");\n    }\n    final byte[] bytes;\n    if (fieldsData == null) {\n      bytes = new byte[BYTES*2*min.length];\n      fieldsData = new BytesRef(bytes);\n    } else {\n      bytes = ((BytesRef)fieldsData).bytes;\n    }\n    verifyAndEncode(min, max, bytes);\n  }\n  /** validate the arguments */\n  private static void checkArgs(final int[] min, final int[] max) {\n    if (min == null || max == null || min.length == 0 || max.length == 0) {\n      throw new IllegalArgumentException(\"min/max range values cannot be null or empty\");\n    }\n    if (min.length != max.length) {\n      throw new IllegalArgumentException(\"min/max ranges must agree\");\n    }\n    if (min.length > 4) {\n      throw new IllegalArgumentException(\"IntRange does not support greater than 4 dimensions\");\n    }\n  }\n  /**\n   * Encodes the min, max ranges into a byte array\n   */\n  private static byte[] encode(int[] min, int[] max) {\n    checkArgs(min, max);\n    byte[] b = new byte[BYTES*2*min.length];\n    verifyAndEncode(min, max, b);\n    return b;\n  }\n  /**\n   * encode the ranges into a sortable byte array ({@code Double.NaN} not allowed)\n   * <p>\n   * example for 4 dimensions (8 bytes per dimension value):\n   * minD1 ... minD4 | maxD1 ... maxD4\n   */\n  static void verifyAndEncode(int[] min, int[] max, byte[] bytes) {\n    for (int d=0,i=0,j=min.length*BYTES; d<min.length; ++d, i+=BYTES, j+=BYTES) {\n      if (Double.isNaN(min[d])) {\n        throw new IllegalArgumentException(\"invalid min value (\" + Double.NaN + \")\" + \" in IntRange\");\n      }\n      if (Double.isNaN(max[d])) {\n        throw new IllegalArgumentException(\"invalid max value (\" + Double.NaN + \")\" + \" in IntRange\");\n      }\n      if (min[d] > max[d]) {\n        throw new IllegalArgumentException(\"min value (\" + min[d] + \") is greater than max value (\" + max[d] + \")\");\n      }\n      encode(min[d], bytes, i);\n      encode(max[d], bytes, j);\n    }\n  }\n  /** encode the given value into the byte array at the defined offset */\n  private static void encode(int val, byte[] bytes, int offset) {\n    NumericUtils.intToSortableBytes(val, bytes, offset);\n  }\n  /**\n   * Get the min value for the given dimension\n   * @param dimension the dimension, always positive\n   * @return the decoded min value\n   */\n  public int getMin(int dimension) {\n    FutureObjects.checkIndex(dimension, type.pointDataDimensionCount()/2);\n    return decodeMin(((BytesRef)fieldsData).bytes, dimension);\n  }\n  /**\n   * Get the max value for the given dimension\n   * @param dimension the dimension, always positive\n   * @return the decoded max value\n   */\n  public int getMax(int dimension) {\n    FutureObjects.checkIndex(dimension, type.pointDataDimensionCount()/2);\n    return decodeMax(((BytesRef)fieldsData).bytes, dimension);\n  }\n  /** decodes the min value (for the defined dimension) from the encoded input byte array */\n  static int decodeMin(byte[] b, int dimension) {\n    int offset = dimension*BYTES;\n    return NumericUtils.sortableBytesToInt(b, offset);\n  }\n  /** decodes the max value (for the defined dimension) from the encoded input byte array */\n  static int decodeMax(byte[] b, int dimension) {\n    int offset = b.length/2 + dimension*BYTES;\n    return NumericUtils.sortableBytesToInt(b, offset);\n  }\n  /**\n   * Create a query for matching indexed ranges that intersect the defined range.\n   * @param field field name. must not be null.\n   * @param min array of min values. (accepts {@code Integer.MIN_VALUE})\n   * @param max array of max values. (accepts {@code Integer.MAX_VALUE})\n   * @return query for matching intersecting ranges (overlap, within, or contains)\n   * @throws IllegalArgumentException if {@code field} is null, {@code min} or {@code max} is invalid\n   */\n  public static Query newIntersectsQuery(String field, final int[] min, final int[] max) {\n    return newRelationQuery(field, min, max, QueryType.INTERSECTS);\n  }\n  /**\n   * Create a query for matching indexed ranges that contain the defined range.\n   * @param field field name. must not be null.\n   * @param min array of min values. (accepts {@code Integer.MIN_VALUE})\n   * @param max array of max values. (accepts {@code Integer.MAX_VALUE})\n   * @return query for matching ranges that contain the defined range\n   * @throws IllegalArgumentException if {@code field} is null, {@code min} or {@code max} is invalid\n   */\n  public static Query newContainsQuery(String field, final int[] min, final int[] max) {\n    return newRelationQuery(field, min, max, QueryType.CONTAINS);\n  }\n  /**\n   * Create a query for matching indexed ranges that are within the defined range.\n   * @param field field name. must not be null.\n   * @param min array of min values. (accepts {@code Integer.MIN_VALUE})\n   * @param max array of max values. (accepts {@code Integer.MAX_VALUE})\n   * @return query for matching ranges within the defined range\n   * @throws IllegalArgumentException if {@code field} is null, {@code min} or {@code max} is invalid\n   */\n  public static Query newWithinQuery(String field, final int[] min, final int[] max) {\n    return newRelationQuery(field, min, max, QueryType.WITHIN);\n  }\n  /**\n   * Create a query for matching indexed ranges that cross the defined range.\n   * A CROSSES is defined as any set of ranges that are not disjoint and not wholly contained by\n   * the query. Effectively, its the complement of union(WITHIN, DISJOINT).\n   * @param field field name. must not be null.\n   * @param min array of min values. (accepts {@code Integer.MIN_VALUE})\n   * @param max array of max values. (accepts {@code Integer.MAX_VALUE})\n   * @return query for matching ranges within the defined range\n   * @throws IllegalArgumentException if {@code field} is null, {@code min} or {@code max} is invalid\n   */\n  public static Query newCrossesQuery(String field, final int[] min, final int[] max) {\n    return newRelationQuery(field, min, max, QueryType.CROSSES);\n  }\n  /** helper method for creating the desired relational query */\n  private static Query newRelationQuery(String field, final int[] min, final int[] max, QueryType relation) {\n    checkArgs(min, max);\n    return new RangeFieldQuery(field, encode(min, max), min.length, relation) {<fim_middle>// class below has no smell\n"}