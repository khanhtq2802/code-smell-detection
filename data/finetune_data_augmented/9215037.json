{"text": "<fim_prefix>/*\n * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n\npackage org.graalvm.compiler.hotspot.nodes.profiling;\n\nimport org.graalvm.compiler.graph.NodeClass;\nimport org.graalvm.compiler.graph.iterators.NodeIterable;\nimport org.graalvm.compiler.nodeinfo.NodeInfo;\nimport org.graalvm.compiler.nodes.StructuredGraph;\nimport org.graalvm.compiler.nodes.ValueNode;\nimport org.graalvm.compiler.nodes.calc.ConditionalNode;\n\nimport jdk.vm.ci.meta.ResolvedJavaMethod;\n\n@NodeInfo\npublic class ProfileBranchNode extends ProfileWithNotificationNode {\n    public static final NodeClass<ProfileBranchNode> TYPE = NodeClass.create(ProfileBranchNode.class);\n\n    @OptionalInput ValueNode branchCondition;\n    protected int bci;\n    protected int targetBci;\n\n    public ProfileBranchNode(ResolvedJavaMethod method, int freqLog, int probabilityLog, ConditionalNode branchCondition, int bci, int targetBci) {\n        super(TYPE, method, freqLog, probabilityLog);\n        assert targetBci <= bci;\n        this.branchCondition = branchCondition;\n        this.bci = bci;\n        this.targetBci = targetBci;\n    }\n\n<fim_suffix>    public ProfileBranchNode(ResolvedJavaMethod method, int freqLog, int probabilityLog, int bci, int targetBci) {\n        super(TYPE, method, freqLog, probabilityLog);\n        assert targetBci <= bci;\n        this.branchCondition = null;\n        this.bci = bci;\n        this.targetBci = targetBci;\n    }\n\n    public int bci() {\n        return bci;\n    }\n\n    public int targetBci() {\n        return targetBci;\n    }\n\n    public ValueNode branchCondition() {\n        return branchCondition;\n    }\n\n    public boolean hasCondition() {\n        return branchCondition != null;\n    }\n\n    @Override\n    protected boolean canBeMergedWith(ProfileNode p) {\n        if (p instanceof ProfileBranchNode) {\n            ProfileBranchNode that = (ProfileBranchNode) p;\n            return this.method.equals(that.method) && this.bci == that.bci;\n        }\n        return false;\n    }\n\n    /**\n     * Gathers all the {@link ProfileBranchNode}s that are inputs to the\n     * {@linkplain StructuredGraph#getNodes() live nodes} in a given graph.\n     */\n    public static NodeIterable<ProfileBranchNode> getProfileBranchNodes(StructuredGraph graph) {\n        return graph.getNodes().filter(ProfileBranchNode.class);\n    }\n}<fim_middle>// function below has no smell\n"}