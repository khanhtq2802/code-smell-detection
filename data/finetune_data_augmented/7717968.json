{"text": "<fim_prefix>/*\n * Copyright (c) 2018 VMware, Inc. All Rights Reserved.\n *\n * This product is licensed to you under the Apache License, Version 2.0 (the \"License\").\n * You may not use this product except in compliance with the License.\n *\n * This product may include a number of subcomponents with separate copyright notices\n * and license terms. Your use of these subcomponents is subject to the terms and\n * conditions of the subcomponent's license, as noted in the LICENSE file.\n */\n\npackage com.vmware.admiral.common.util;\n\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.concurrent.CompletionException;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.logging.Level;\nimport java.util.stream.Collectors;\n\nimport com.vmware.photon.controller.model.query.QueryUtils.QueryByPages;\nimport com.vmware.photon.controller.model.resources.ResourceState;\nimport com.vmware.xenon.common.DeferredResult;\nimport com.vmware.xenon.common.Operation;\nimport com.vmware.xenon.common.ServiceDocument;\nimport com.vmware.xenon.common.ServiceHost;\nimport com.vmware.xenon.common.Utils;\nimport com.vmware.xenon.services.common.QueryTask.Query;\nimport com.vmware.xenon.services.common.QueryTask.Query.Builder;\nimport com.vmware.xenon.services.common.QueryTask.Query.Occurance;\nimport com.vmware.xenon.services.common.QueryTask.QuerySpecification;\n\n<fim_suffix>public class CertificateCleanupUtil {\n\n    private static final List<String> TRUST_CERT_CUSTOM_PROPERTY_NAMES = Collections\n            .unmodifiableList(\n                    Arrays.asList(\n                            CertificateUtilExtended.CUSTOM_PROPERTY_TRUST_CERT_LINK,\n                            CertificateUtilExtended.CUSTOM_PROPERTY_PKS_UAA_TRUST_CERT_LINK,\n                            CertificateUtilExtended.CUSTOM_PROPERTY_PKS_API_TRUST_CERT_LINK));\n\n    /**\n     * Finds which of the passed certificates are currently not used by any state and deletes them.\n     *\n     * @param serviceHost\n     *            a host to carry out operations\n     * @param trustCertLinks\n     *            the links to the certificates that are suspected to be unused\n     * @param ignoredUsageLinks\n     *            links to documents which usage of the certificate should be ignored\n     */\n    public static DeferredResult<Void> removeTrustCertsIfUnused(ServiceHost serviceHost,\n            Collection<String> trustCertLinks, Collection<String> ignoredUsageLinks) {\n\n        trustCertLinks = sanitizeCollection(trustCertLinks);\n        if (trustCertLinks.isEmpty()) {\n            return DeferredResult.completed(null);\n        }\n        ignoredUsageLinks = sanitizeCollection(ignoredUsageLinks);\n\n        // Start with a set of all certificate links\n        Set<String> unusedCertLinks = ConcurrentHashMap.newKeySet();\n        unusedCertLinks.addAll(trustCertLinks);\n\n        // Build a query that selects all entities that use the specified certs\n        Query usagesQuery = buildCertUsageSelectionQuery(trustCertLinks, ignoredUsageLinks);\n        // ResourceState is used instead of ServiceDocument so we can\n        // check the custom properties as part of the query\n        QueryByPages<ResourceState> queryByPages = new QueryByPages<>(serviceHost,\n                usagesQuery, ResourceState.class, null);\n\n        return queryByPages\n                // remove all used certificates from the deletion list\n                .queryDocuments(usage -> {\n                    TRUST_CERT_CUSTOM_PROPERTY_NAMES.forEach(propName -> {\n                        String propValue = usage.customProperties.get(propName);\n                        if (propValue != null && !propName.isEmpty()) {\n                            unusedCertLinks.remove(propValue);\n                        }\n                    });\n                })\n                // delete the remaining certificates\n                .thenCompose(ignore -> deleteCertificatesByLink(serviceHost, unusedCertLinks));\n    }\n\n    /**\n     * Converts <code>null</code> collections to empty collections, drops <code>null</code> elements\n     * in the passed collection, drops duplicated elements.\n     */\n    private static Set<String> sanitizeCollection(Collection<String> c) {\n        if (c == null) {\n            return Collections.emptySet();\n        }\n\n        return c.stream().filter(Objects::nonNull).collect(Collectors.toSet());\n    }\n\n    /**\n     * Builds a query that will select all (not ignored) documents that use any of the specified\n     * certificates.\n     */\n    private static Query buildCertUsageSelectionQuery(Collection<String> trustCertLinks,\n            Collection<String> ignoredUsageLinks) {\n        Builder queryBuilder = Query.Builder.create();\n\n        addClauseToQuery(queryBuilder, buildCertLinkClause(trustCertLinks));\n        addClauseToQuery(queryBuilder, buildSelfLinkExclusionClause(ignoredUsageLinks));\n\n        return queryBuilder.build();\n    }\n\n    private static void addClauseToQuery(Builder queryBuilder, Query clause) {\n        if (clause != null) {\n            queryBuilder.addClause(clause);\n        }\n    }\n\n    /**\n     * Builds a query that will select all documents that use any of the specified certificates.\n     */\n    private static Query buildCertLinkClause(Collection<String> trustCertLinks) {\n        if (trustCertLinks == null || trustCertLinks.isEmpty()) {\n            return null;\n        }\n\n        Builder builder = Query.Builder.create(Occurance.MUST_OCCUR);\n\n        TRUST_CERT_CUSTOM_PROPERTY_NAMES.forEach(propName -> {\n            builder.addInClause(\n                    QuerySpecification.buildCompositeFieldName(\n                            ResourceState.FIELD_NAME_CUSTOM_PROPERTIES,\n                            propName),\n                    trustCertLinks, Occurance.SHOULD_OCCUR);\n        });\n\n        return builder.build();\n    }\n\n    /**\n     * Builds a query that will select all documents that are not present in the ignored list\n     */\n    private static Query buildSelfLinkExclusionClause(Collection<String> ignoredUsageLinks) {\n        if (ignoredUsageLinks == null || ignoredUsageLinks.isEmpty()) {\n            return null;\n        }\n\n        return Query.Builder.create(Occurance.MUST_NOT_OCCUR)\n                .addInClause(ServiceDocument.FIELD_NAME_SELF_LINK, ignoredUsageLinks)\n                .build();\n    }\n\n    /**\n     * Deletes the specified certificates.\n     */\n    private static DeferredResult<Void> deleteCertificatesByLink(ServiceHost serviceHost,\n            Collection<String> certLinks) {\n\n        if (certLinks == null || certLinks.isEmpty()) {\n            return DeferredResult.completed(null);\n        }\n\n        List<DeferredResult<Void>> deleteOps = certLinks.stream()\n                .map(certLink -> {\n                    Operation delete = Operation.createDelete(serviceHost, certLink)\n                            .setReferer(\"/certificate-cleanup\");\n                    return serviceHost.sendWithDeferredResult(delete)\n                            .thenAccept(ignore -> {\n                                serviceHost.log(Level.INFO,\n                                        \"Deleted unused trust cert [%s]\",\n                                        certLink);\n                            })\n                            .exceptionally(ex -> {\n                                serviceHost.log(Level.WARNING,\n                                        \"Failed to delete trust cert [%s]: %s\",\n                                        certLink, Utils.toString(ex));\n                                throw ex instanceof CompletionException\n                                        ? (CompletionException) ex\n                                        : new CompletionException(ex);\n                            });\n                }).collect(Collectors.toList());\n\n        return DeferredResult.allOf(deleteOps)\n                .thenAccept(ignore -> {\n                    // convert return type to DeferredResult<Void>\n                });\n    }\n\n}<fim_middle>// class below has no smell\n"}