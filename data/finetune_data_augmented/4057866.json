{"text": "<fim_prefix>    static final long LOGRECORD_METADATA_POSITION_UMASK = 0xffff00000000ffffL;\n    static final int LOGRECORD_METADATA_POSITION_SHIFT = 16;\n    static final long LOGRECORD_METADATA_UNUSED_MASK = 0xffff000000000000L;\n    // TODO: Replace with EnumSet\n    static final long LOGRECORD_FLAGS_CONTROL_MESSAGE = 0x1;\n    static final long LOGRECORD_FLAGS_END_OF_STREAM = 0x2;\n    static final long LOGRECORD_FLAGS_RECORD_SET = 0x4;\n    private long metadata;\n    private long txid;\n    private ByteBuf payload;\n    /**\n     * Construct an uninitialized log record.\n     *\n     * <p>NOTE: only deserializer should call this constructor.\n     */\n    protected LogRecord() {\n        this.txid = 0;\n        this.metadata = 0;\n    }\n    /**\n     * Construct a log record with <i>TransactionId</i> and payload.\n     *\n     * <p>Usually writer would construct the log record for writing.\n     *\n     * @param txid\n     *          application defined transaction id.\n     * @param payload\n     *          record data\n     */\n    public LogRecord(long txid, byte[] payload) {\n        this.txid = txid;\n        this.payload = Unpooled.wrappedBuffer(payload);\n    }\n    /**\n     * Construct a log record with <i>txid</i> and payload <i>buffer</i>.\n     *\n     * @param txid application defined transaction id.\n     * @param buffer payload buffer.\n     */\n    public LogRecord(long txid, ByteBuffer buffer) {\n        this.txid = txid;\n        this.payload = Unpooled.wrappedBuffer(buffer);\n    }\n    /**\n     * Construct a log record with <i>txid</i> and ByteBuf <i>payload</i>.\n     *\n     * @param txid transaction id\n     * @param payload playload\n     */\n    public LogRecord(long txid, ByteBuf payload) {\n        this.txid = txid;\n        this.payload = payload;\n        this.metadata = 0;\n    }\n    //\n    // Accessors\n    //\n    /**\n     * Return application defined transaction id.\n     *\n     * @return transacton id.\n     */\n    public long getTransactionId() {\n        return txid;\n    }\n    /**\n     * Set application defined transaction id.\n     *\n     * @param txid application defined transaction id.\n     */\n    protected void setTransactionId(long txid) {\n        this.txid = txid;\n    }\n    /**\n     * Return the payload of this log record.\n     *\n     * @return payload of this log record.\n     */\n    public byte[] getPayload() {\n        return ByteBufUtils.getArray(payload);\n    }\n    /**\n     * Return the payload buf of this log record.\n     *\n     * @return payload buf of this record.\n     * @since 0.5.0\n     */\n    public ByteBuf getPayloadBuf() {\n        return payload.slice();\n    }\n    void setPayloadBuf(ByteBuf payload, boolean copyData) {\n        if (null != this.payload) {\n            this.payload.release();\n        }\n        if (copyData) {\n            this.payload = Unpooled.copiedBuffer(payload);\n        } else {\n            this.payload = payload;\n        }\n    }\n    /**\n     * Return the payload as an {@link InputStream}.\n     *\n     * @return payload as input stream\n     */\n    public InputStream getPayLoadInputStream() {\n        return new ByteBufInputStream(payload.retainedSlice(), true);\n    }\n    //\n    // Metadata & Flags\n    //\n    protected void setMetadata(long metadata) {\n        this.metadata = metadata;\n    }\n    protected long getMetadata() {\n        return this.metadata;\n    }\n    /**\n     * Set the position in the log segment.\n     *\n     * @see #getPositionWithinLogSegment()\n     * @param positionWithinLogSegment position in the log segment.\n     */\n    void setPositionWithinLogSegment(int positionWithinLogSegment) {\n        assert(positionWithinLogSegment >= 0);\n        metadata = (metadata & LOGRECORD_METADATA_POSITION_UMASK)\n            | (((long) positionWithinLogSegment) << LOGRECORD_METADATA_POSITION_SHIFT);\n    }\n    /**\n     * The position in the log segment means how many records (inclusive) added to the log segment so far.\n     *\n     * @return position of the record in the log segment.\n     */\n    public int getPositionWithinLogSegment() {\n        long ret = (metadata & LOGRECORD_METADATA_POSITION_MASK) >> LOGRECORD_METADATA_POSITION_SHIFT;\n        if (ret < 0 || ret > Integer.MAX_VALUE) {\n            throw new IllegalArgumentException\n                (ret + \" position should never exceed max integer value\");\n        }\n        return (int) ret;\n    }\n    /**\n     * Get the last position of this record in the log segment.\n     *\n     * <p>If the record isn't record set, it would be same as {@link #getPositionWithinLogSegment()},\n     * otherwise, it would be {@link #getPositionWithinLogSegment()} + numRecords - 1. If the record set\n     * version is unknown, it would be same as {@link #getPositionWithinLogSegment()}.\n     *\n     * @return last position of this record in the log segment.\n     */\n    int getLastPositionWithinLogSegment() {\n        if (isRecordSet()) {\n            try {\n                return getPositionWithinLogSegment() + LogRecordSet.numRecords(this) - 1;\n            } catch (IOException e) {\n                // if it is unrecognized record set, we will return the position of this record set.\n                return getPositionWithinLogSegment();\n            }\n        } else {\n            return getPositionWithinLogSegment();\n        }\n    }\n    /**\n     * Set the record to represent a set of records.\n     *\n     * <p>The bytes in this record is the serialized format of {@link LogRecordSet}.\n     */\n    public void setRecordSet() {\n        metadata = metadata | LOGRECORD_FLAGS_RECORD_SET;\n    }\n    /**\n     * Check if the record represents a set of records.\n     *\n     * @return true if the record represents a set of records, otherwise false.\n     * @see #setRecordSet()\n     */\n    public boolean isRecordSet() {\n        return isRecordSet(metadata);\n    }\n    public static boolean isRecordSet(long metadata) {\n        return ((metadata & LOGRECORD_FLAGS_RECORD_SET) != 0);\n    }\n    @VisibleForTesting\n    public void setControl() {\n        metadata = metadata | LOGRECORD_FLAGS_CONTROL_MESSAGE;\n    }\n    /**\n     * Check if the record is a control record.\n     *\n     * @return true if the record is a control record, otherwise false.\n     */\n    public boolean isControl() {\n        return isControl(metadata);\n    }\n    /**\n     * Check flags to see if it indicates a control record.\n     *\n     * @param flags record flags\n     * @return true if the record is a control record, otherwise false.\n     */\n    public static boolean isControl(long flags) {\n        return ((flags & LOGRECORD_FLAGS_CONTROL_MESSAGE) != 0);\n    }\n    /**\n     * Set the record as <code>EoS</code> mark.\n     *\n     * @see #isEndOfStream()\n     */\n    void setEndOfStream() {\n        metadata = metadata | LOGRECORD_FLAGS_END_OF_STREAM;\n    }\n    /**\n     * Check if the record is a <code>EoS</code> mark.\n     *\n     * <p><code>EoS</code> mark is a special record that writer would\n     * add to seal a log. after <code>Eos</code> mark is written,\n     * writers can't write any more records and readers will get\n     * {@link org.apache.distributedlog.exceptions.EndOfStreamException}\n     * when they reach <code>EoS</code>.\n     *\n     * @return true\n     */\n    boolean isEndOfStream() {\n        return ((metadata & LOGRECORD_FLAGS_END_OF_STREAM) != 0);\n    }\n    //\n    // Serialization & Deserialization\n    //\n<fim_suffix>    protected void readPayload(ByteBuf in, boolean copyData) throws IOException {\n        int length = in.readInt();\n        if (length < 0) {\n            throw new EOFException(\"Log Record is corrupt: Negative length \" + length);\n        }\n        if (copyData) {\n            setPayloadBuf(in.slice(in.readerIndex(), length), true);\n        } else {\n            setPayloadBuf(in.retainedSlice(in.readerIndex(), length), false);\n        }\n        in.skipBytes(length);\n    }<fim_middle>// function below has no smell\n"}