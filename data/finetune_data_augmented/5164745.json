{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.metamodel.jdbc.dialects;\n\nimport java.sql.Timestamp;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Set;\n\nimport org.apache.metamodel.jdbc.JdbcDataContext;\nimport org.apache.metamodel.query.AggregateFunction;\nimport org.apache.metamodel.query.AverageAggregateFunction;\nimport org.apache.metamodel.query.CountAggregateFunction;\nimport org.apache.metamodel.query.FilterItem;\nimport org.apache.metamodel.query.FromItem;\nimport org.apache.metamodel.query.FunctionType;\nimport org.apache.metamodel.query.MaxAggregateFunction;\nimport org.apache.metamodel.query.MinAggregateFunction;\nimport org.apache.metamodel.query.OperatorType;\nimport org.apache.metamodel.query.Query;\nimport org.apache.metamodel.query.ScalarFunction;\nimport org.apache.metamodel.query.SelectItem;\nimport org.apache.metamodel.query.SumAggregateFunction;\nimport org.apache.metamodel.schema.ColumnType;\nimport org.apache.metamodel.util.CollectionUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Generic query rewriter that adds syntax enhancements that are only possible to resolve just before execution time.\n */\npublic class DefaultQueryRewriter extends AbstractQueryRewriter {\n\n    private static final Logger logger = LoggerFactory.getLogger(DefaultQueryRewriter.class);\n\n    private static final String SPECIAL_ALIAS_CHARACTERS = \"- ,.|*%()!#\u00a4/\\\\=?;:~\";\n    private static final Set<Class<? extends FunctionType>> SUPPORTED_FUNCTION_CLASSES = new HashSet<>(\n            Arrays.<Class<? extends FunctionType>> asList(CountAggregateFunction.class, SumAggregateFunction.class,\n                    MaxAggregateFunction.class, MinAggregateFunction.class, AverageAggregateFunction.class));\n\n    public DefaultQueryRewriter(JdbcDataContext dataContext) {\n        super(dataContext);\n    }\n\n<fim_suffix>    @Override\n    protected Query beforeRewrite(Query query) {\n        query = query.clone();\n\n        JdbcDataContext dataContext = getDataContext();\n        if (dataContext != null) {\n            String identifierQuoteString = dataContext.getIdentifierQuoteString();\n            if (identifierQuoteString != null) {\n                List<SelectItem> selectItems = query.getSelectClause().getItems();\n                for (SelectItem item : selectItems) {\n                    String alias = item.getAlias();\n                    if (needsQuoting(alias, identifierQuoteString)) {\n                        item.setAlias(identifierQuoteString + alias + identifierQuoteString);\n                    }\n                }\n                List<FromItem> fromItems = query.getFromClause().getItems();\n                for (FromItem item : fromItems) {\n                    String alias = item.getAlias();\n                    if (needsQuoting(alias, identifierQuoteString)) {\n                        item.setAlias(identifierQuoteString + alias + identifierQuoteString);\n                    }\n                }\n            }\n        }\n        return query;\n    }\n\n    @Override\n    public String rewriteColumnType(ColumnType columnType, Integer columnSize) {\n        if (columnType == ColumnType.STRING) {\n            // convert STRING to VARCHAR as the default SQL type for strings\n            return rewriteColumnType(ColumnType.VARCHAR, columnSize);\n        }\n        if (columnType == ColumnType.NUMBER) {\n            // convert NUMBER to FLOAT as the default SQL type for numbers\n            return rewriteColumnType(ColumnType.FLOAT, columnSize);\n        }\n        return super.rewriteColumnType(columnType, columnSize);\n    }\n\n    protected boolean needsQuoting(String alias, String identifierQuoteString) {\n        boolean result = false;\n        if (alias != null && identifierQuoteString != null) {\n            if (alias.indexOf(identifierQuoteString) == -1) {\n                for (int i = 0; i < SPECIAL_ALIAS_CHARACTERS.length(); i++) {\n                    char specialCharacter = SPECIAL_ALIAS_CHARACTERS.charAt(i);\n                    if (alias.indexOf(specialCharacter) != -1) {\n                        result = true;\n                        break;\n                    }\n                }\n            }\n        }\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"needsQuoting(\" + alias + \",\" + identifierQuoteString + \") = \" + result);\n        }\n        return result;\n    }\n\n    @Override\n    public String rewriteFilterItem(FilterItem item) {\n        Object operand = item.getOperand();\n        if (operand != null) {\n            if (operand instanceof String) {\n                String str = (String) operand;\n                // escape single quotes\n                if (str.indexOf('\\'') != -1) {\n                    str = escapeQuotes(str);\n                    FilterItem replacementFilterItem = new FilterItem(item.getSelectItem(), item.getOperator(), str);\n                    return super.rewriteFilterItem(replacementFilterItem);\n                }\n            } else if (operand instanceof Timestamp) {\n                final String timestampLiteral = rewriteTimestamp((Timestamp) operand);\n                return rewriteFilterItemWithOperandLiteral(item, timestampLiteral);\n            } else if (operand instanceof Iterable || operand.getClass().isArray()) {\n                // operand is a set of values (typically in combination with an\n                // IN or NOT IN operator). Each individual element must be escaped.\n\n                assert OperatorType.IN.equals(item.getOperator()) || OperatorType.NOT_IN.equals(item.getOperator());\n\n                @SuppressWarnings(\"unchecked\") final List<Object> elements =\n                        (List<Object>) CollectionUtils.toList(operand);\n\n                for (ListIterator<Object> it = elements.listIterator(); it.hasNext();) {\n                    Object next = it.next();\n                    if (next == null) {\n                        logger.warn(\n                                \"element in IN list is NULL, which isn't supported by SQL. Stripping the element from the list: {}\",\n                                item);\n                        it.remove();\n                    } else if (next instanceof String) {\n                        String str = (String) next;\n                        if (str.indexOf('\\'') != -1) {\n                            str = escapeQuotes(str);\n                            it.set(str);\n                        }\n                    }\n                }\n\n                FilterItem replacementFilterItem = new FilterItem(item.getSelectItem(), item.getOperator(), elements);\n                return super.rewriteFilterItem(replacementFilterItem);\n            }\n        }\n        return super.rewriteFilterItem(item);\n    }\n\n    /**\n     * Rewrites a (non-compound) {@link FilterItem} when it's operand has already been rewritten into a SQL literal.\n     * \n     * @param item\n     * @param operandLiteral\n     * @return\n     */\n    protected String rewriteFilterItemWithOperandLiteral(FilterItem item, String operandLiteral) {\n        final OperatorType operator = item.getOperator();\n        final SelectItem selectItem = item.getSelectItem();\n        final StringBuilder sb = new StringBuilder();\n        sb.append(selectItem.getSameQueryAlias(false));\n        FilterItem.appendOperator(sb, item.getOperand(), operator);\n        sb.append(operandLiteral);\n        return sb.toString();\n    }\n\n    /**\n     * Rewrites a {@link Timestamp} into it's literal representation as known by this SQL dialect.\n     * \n     * This default implementation returns the JDBC spec's escape syntax for a timestamp: {ts 'yyyy-mm-dd hh:mm:ss.f . .\n     * .'}\n     * \n     * @param ts\n     * @return\n     */\n    protected String rewriteTimestamp(Timestamp ts) {\n        return \"{ts '\" + ts.toString() + \"'}\";\n    }\n\n    @Override\n    public boolean isScalarFunctionSupported(ScalarFunction function) {\n        return SUPPORTED_FUNCTION_CLASSES.contains(function.getClass());\n    }\n\n    @Override\n    public boolean isAggregateFunctionSupported(AggregateFunction function) {\n        return SUPPORTED_FUNCTION_CLASSES.contains(function.getClass());\n    }\n\n    @Override\n    public boolean isFirstRowSupported(final Query query) {\n        return false;\n    }\n\n    @Override\n    public boolean isMaxRowsSupported() {\n        return false;\n    }\n\n    @Override\n    public String escapeQuotes(String item) {\n        return item.replaceAll(\"\\\\'\", \"\\\\'\\\\'\");\n    }\n\n\t@Override\n\tpublic boolean isPrimaryKeySupported() {\n\t\treturn true;\n\t}\n}<fim_middle>// function below has no smell\n"}