{"text": "<fim_prefix>/*\n * Copyright (c) 2011-2018 Pivotal Software Inc, All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage reactor.core.publisher;\n\nimport java.util.Objects;\nimport java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\nimport java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\nimport java.util.stream.Stream;\n\nimport org.reactivestreams.Publisher;\nimport org.reactivestreams.Subscription;\nimport reactor.core.CoreSubscriber;\nimport reactor.core.Exceptions;\nimport reactor.core.Scannable;\nimport reactor.util.annotation.Nullable;\nimport reactor.util.context.Context;\n\n/**\n * Waits for all Mono sources to produce a value or terminate, and if all of them produced\n * a value, emit a Tuples of those values; otherwise terminate.\n */\n<fim_suffix>final class MonoWhen extends Mono<Void> implements SourceProducer<Void>  {\n\n\tfinal boolean delayError;\n\n\tfinal Publisher<?>[] sources;\n\n\tfinal Iterable<? extends Publisher<?>> sourcesIterable;\n\n\tMonoWhen(boolean delayError, Publisher<?>... sources) {\n\t\tthis.delayError = delayError;\n\t\tthis.sources = Objects.requireNonNull(sources, \"sources\");\n\t\tthis.sourcesIterable = null;\n\t}\n\n\tMonoWhen(boolean delayError, Iterable<? extends Publisher<?>> sourcesIterable) {\n\t\tthis.delayError = delayError;\n\t\tthis.sources = null;\n\t\tthis.sourcesIterable = Objects.requireNonNull(sourcesIterable, \"sourcesIterable\");\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Nullable\n\tMono<Void> whenAdditionalSource(Publisher<?> source) {\n\t\tPublisher[] oldSources = sources;\n\t\tif (oldSources != null) {\n\t\t\tint oldLen = oldSources.length;\n\t\t\tPublisher<?>[] newSources = new Publisher[oldLen + 1];\n\t\t\tSystem.arraycopy(oldSources, 0, newSources, 0, oldLen);\n\t\t\tnewSources[oldLen] = source;\n\n\t\t\treturn new MonoWhen(delayError, newSources);\n\t\t}\n\t\treturn null;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic void subscribe(CoreSubscriber<? super Void> actual) {\n\t\tPublisher<?>[] a;\n\t\tint n = 0;\n\t\tif (sources != null) {\n\t\t\ta = sources;\n\t\t\tn = a.length;\n\t\t}\n\t\telse {\n\t\t\ta = new Publisher[8];\n\t\t\tfor (Publisher<?> m : sourcesIterable) {\n\t\t\t\tif (n == a.length) {\n\t\t\t\t\tPublisher<?>[] b = new Publisher[n + (n >> 2)];\n\t\t\t\t\tSystem.arraycopy(a, 0, b, 0, n);\n\t\t\t\t\ta = b;\n\t\t\t\t}\n\t\t\t\ta[n++] = m;\n\t\t\t}\n\t\t}\n\n\t\tif (n == 0) {\n\t\t\tOperators.complete(actual);\n\t\t\treturn;\n\t\t}\n\n\t\tWhenCoordinator parent = new WhenCoordinator(actual, n, delayError);\n\t\tactual.onSubscribe(parent);\n\t\tparent.subscribe(a);\n\t}\n\n\t@Override\n\tpublic Object scanUnsafe(Attr key) {\n\t\tif (key == Attr.DELAY_ERROR) return delayError;\n\t\treturn null;\n\t}\n\n\tstatic final class WhenCoordinator extends Operators.MonoSubscriber<Object, Void> {\n\n\t\tfinal WhenInner[] subscribers;\n\n\t\tfinal boolean delayError;\n\n\t\tvolatile int done;\n\t\t@SuppressWarnings(\"rawtypes\")\n\t\tstatic final AtomicIntegerFieldUpdater<WhenCoordinator> DONE =\n\t\t\t\tAtomicIntegerFieldUpdater.newUpdater(WhenCoordinator.class, \"done\");\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tWhenCoordinator(CoreSubscriber<? super Void> subscriber,\n\t\t\t\tint n,\n\t\t\t\tboolean delayError) {\n\t\t\tsuper(subscriber);\n\t\t\tthis.delayError = delayError;\n\t\t\tsubscribers = new WhenInner[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tsubscribers[i] = new WhenInner(this);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic Object scanUnsafe(Attr key) {\n\t\t\tif (key == Attr.TERMINATED) {\n\t\t\t\treturn done == subscribers.length;\n\t\t\t}\n\t\t\tif (key == Attr.BUFFERED) {\n\t\t\t\treturn subscribers.length;\n\t\t\t}\n\t\t\tif (key == Attr.DELAY_ERROR) {\n\t\t\t\treturn delayError;\n\t\t\t}\n\n\t\t\treturn super.scanUnsafe(key);\n\t\t}\n\n\t\t@Override\n\t\tpublic Stream<? extends Scannable> inners() {\n\t\t\treturn Stream.of(subscribers);\n\t\t}\n\n\t\tvoid subscribe(Publisher<?>[] sources) {\n\t\t\tWhenInner[] a = subscribers;\n\t\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\t\tsources[i].subscribe(a[i]);\n\t\t\t}\n\t\t}\n\n\t\tvoid signalError(Throwable t) {\n\t\t\tif (delayError) {\n\t\t\t\tsignal();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint n = subscribers.length;\n\t\t\t\tif (DONE.getAndSet(this, n) != n) {\n\t\t\t\t\tcancel();\n\t\t\t\t\tactual.onError(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tvoid signal() {\n\t\t\tWhenInner[] a = subscribers;\n\t\t\tint n = a.length;\n\t\t\tif (DONE.incrementAndGet(this) != n) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tThrowable error = null;\n\t\t\tThrowable compositeError = null;\n\n\t\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\t\tWhenInner m = a[i];\n\t\t\t\tThrowable e = m.error;\n\t\t\t\tif (e != null) {\n\t\t\t\t\tif (compositeError != null) {\n\t\t\t\t\t\t//this is ok as the composite created below is never a singleton\n\t\t\t\t\t\tcompositeError.addSuppressed(e);\n\t\t\t\t\t}\n\t\t\t\t\telse if (error != null) {\n\t\t\t\t\t\tcompositeError = Exceptions.multiple(error, e);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\terror = e;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif (compositeError != null) {\n\t\t\t\tactual.onError(compositeError);\n\t\t\t}\n\t\t\telse if (error != null) {\n\t\t\t\tactual.onError(error);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tactual.onComplete();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void cancel() {\n\t\t\tif (!isCancelled()) {\n\t\t\t\tsuper.cancel();\n\t\t\t\tfor (WhenInner ms : subscribers) {\n\t\t\t\t\tms.cancel();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic final class WhenInner implements InnerConsumer<Object> {\n\n\t\tfinal WhenCoordinator parent;\n\n\t\tvolatile Subscription s;\n\t\t@SuppressWarnings(\"rawtypes\")\n\t\tstatic final AtomicReferenceFieldUpdater<WhenInner, Subscription> S =\n\t\t\t\tAtomicReferenceFieldUpdater.newUpdater(WhenInner.class,\n\t\t\t\t\t\tSubscription.class,\n\t\t\t\t\t\t\"s\");\n\t\tThrowable error;\n\n\t\tWhenInner(WhenCoordinator parent) {\n\t\t\tthis.parent = parent;\n\t\t}\n\n\t\t@Override\n\t\t@Nullable\n\t\tpublic Object scanUnsafe(Attr key) {\n\t\t\tif (key == Attr.CANCELLED) {\n\t\t\t\treturn s == Operators.cancelledSubscription();\n\t\t\t}\n\t\t\tif (key == Attr.PARENT) {\n\t\t\t\treturn s;\n\t\t\t}\n\t\t\tif (key == Attr.ACTUAL) {\n\t\t\t\treturn parent;\n\t\t\t}\n\t\t\tif (key == Attr.ERROR) {\n\t\t\t\treturn error;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tpublic Context currentContext() {\n\t\t\treturn parent.currentContext();\n\t\t}\n\n\t\t@Override\n\t\tpublic void onSubscribe(Subscription s) {\n\t\t\tif (Operators.setOnce(S, this, s)) {\n\t\t\t\ts.request(Long.MAX_VALUE);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ts.cancel();\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void onNext(Object t) {\n\t\t}\n\n\t\t@Override\n\t\tpublic void onError(Throwable t) {\n\t\t\terror = t;\n\t\t\tparent.signalError(t);\n\t\t}\n\n\t\t@Override\n\t\tpublic void onComplete() {\n\t\t\tparent.signal();\n\t\t}\n\n\t\tvoid cancel() {\n\t\t\tOperators.terminate(S, this);\n\t\t}\n\t}\n}<fim_middle>// class below is blob\n"}