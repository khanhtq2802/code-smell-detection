{"text": "<fim_prefix>/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *  \n *    http://www.apache.org/licenses/LICENSE-2.0\n *  \n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License. \n *  \n */\npackage org.apache.directory.api.ldap.model.schema.syntaxCheckers;\n\n\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport org.apache.directory.api.i18n.I18n;\nimport org.apache.directory.api.ldap.model.constants.SchemaConstants;\nimport org.apache.directory.api.ldap.model.schema.SyntaxChecker;\nimport org.apache.directory.api.util.Chars;\nimport org.apache.directory.api.util.Strings;\n\n\n/**\n * A SyntaxChecker which verifies that a value is a DSEType according to \n * http://tools.ietf.org/id/draft-ietf-asid-ldapv3-attributes-03.txt, par 6.2.1.5 :\n * <pre>\n * &lt;DSEType&gt;    ::= '(' &lt;sp&gt;* &lt;DSEBit&gt; &lt;sp&gt;* &lt;DSEBitList&gt; ')'\n * &lt;DSEBitList&gt; ::= '$' &lt;sp&gt;* &lt;DSEBit&gt; &lt;sp&gt;* &lt;DSEBitList&gt; | e      \n * &lt;DSEBit&gt;     ::= 'root' | 'glue' | 'cp' | 'entry' | 'alias' | 'subr' |\n *                  'nssr' | 'supr' | 'xr' | 'admPoint' | 'subentry' |\n *                  'shadow' | 'zombie' | 'immSupr' | 'rhob' | 'sa'\n * </pre>\n *\n * @author <a href=\"mailto:dev@directory.apache.org\">Apache Directory Project</a>\n */\n@SuppressWarnings(\"serial\")\npublic final class DseTypeSyntaxChecker extends SyntaxChecker\n{\n    /** The DSE BITS keywords */\n    private static final String[] DSE_BITS_STRINGS =\n        {\n            \"root\", \"glue\", \"cp\", \"entry\", \"alias\", \"subr\",\n            \"nssr\", \"supr\", \"xr\", \"admPoint\", \"subentry\",\n            \"shadow\", \"zombie\", \"immSupr\", \"rhob\", \"sa\"\n    };\n\n    /** The Set which contains the DESBits */\n    private static final Set<String> DSE_BITS = new HashSet<>();\n    \n    /** Initialization of the country set */\n    static\n    {\n        for ( String country : DSE_BITS_STRINGS )\n        {\n            DSE_BITS.add( country );\n        }\n    }\n\n    /**\n     * A static instance of DseTypeSyntaxChecker\n     */\n    public static final DseTypeSyntaxChecker INSTANCE = new DseTypeSyntaxChecker( SchemaConstants.DSE_TYPE_SYNTAX );\n    \n    /**\n     * A static Builder for this class\n     */\n    public static final class Builder extends SCBuilder<DseTypeSyntaxChecker>\n    {\n        /**\n         * The Builder constructor\n         */\n        private Builder()\n        {\n            super( SchemaConstants.DSE_TYPE_SYNTAX );\n        }\n        \n        \n        /**\n         * Create a new instance of DseTypeSyntaxChecker\n         * @return A new instance of DseTypeSyntaxChecker\n         */\n        @Override\n        public DseTypeSyntaxChecker build()\n        {\n            return new DseTypeSyntaxChecker( oid );\n        }\n    }\n\n    \n    /** Initialization of the country set */\n    static\n    {\n        for ( String country : DSE_BITS_STRINGS )\n        {\n            DSE_BITS.add( country );\n        }\n    }\n\n\n    /**\n     * Creates a new instance of DSETypeSyntaxChecker.\n     *\n     * @param oid The OID to use for this SyntaxChecker\n     */\n    private DseTypeSyntaxChecker( String oid )\n    {\n        super( oid );\n    }\n\n    \n    /**\n     * @return An instance of the Builder for this class\n     */\n    public static Builder builder()\n    {\n        return new Builder();\n    }\n\n\n    /**\n     * {@inheritDoc}\n     */\n<fim_suffix>    @Override\n    public boolean isValidSyntax( Object value )\n    {\n        String strValue;\n\n        if ( value == null )\n        {\n            if ( LOG.isDebugEnabled() )\n            {\n                LOG.debug( I18n.err( I18n.ERR_13210_SYNTAX_INVALID, \"null\" ) );\n            }\n            \n            return false;\n        }\n\n        if ( value instanceof String )\n        {\n            strValue = ( String ) value;\n        }\n        else if ( value instanceof byte[] )\n        {\n            strValue = Strings.utf8ToString( ( byte[] ) value );\n        }\n        else\n        {\n            strValue = value.toString();\n        }\n\n        // We must have at least '(cp)', '(xr)' or '(ca)'\n        if ( strValue.length() < 4 )\n        {\n            if ( LOG.isDebugEnabled() )\n            {\n                LOG.debug( I18n.err( I18n.ERR_13210_SYNTAX_INVALID, value ) );\n            }\n            \n            return false;\n        }\n\n        // Check the opening and closing parenthesis\n        if ( ( strValue.charAt( 0 ) != '(' )\n            || ( strValue.charAt( strValue.length() - 1 ) != ')' ) )\n        {\n            if ( LOG.isDebugEnabled() )\n            {\n                LOG.debug( I18n.err( I18n.ERR_13210_SYNTAX_INVALID, value ) );\n            }\n            \n            return false;\n        }\n\n        Set<String> keywords = new HashSet<>();\n        int len = strValue.length() - 1;\n        boolean needKeyword = true;\n\n        // \n        for ( int i = 1; i < len; /* */)\n        {\n            // Skip spaces\n            while ( ( i < len ) && ( strValue.charAt( i ) == ' ' ) )\n            {\n                i++;\n            }\n\n            int pos = i;\n\n            // Search for a keyword\n            while ( ( i < len ) && Chars.isAlphaASCII( strValue, pos ) )\n            {\n                pos++;\n            }\n\n            if ( pos == i )\n            {\n                // No keyword : error\n                if ( LOG.isDebugEnabled() )\n                {\n                    LOG.debug( I18n.err( I18n.ERR_13210_SYNTAX_INVALID, value ) );\n                }\n                \n                return false;\n            }\n\n            String keyword = strValue.substring( i, pos );\n            i = pos;\n\n            if ( !DSE_BITS.contains( keyword ) )\n            {\n                // Unknown keyword\n                if ( LOG.isDebugEnabled() )\n                {\n                    LOG.debug( I18n.err( I18n.ERR_13210_SYNTAX_INVALID, value ) );\n                }\n                \n                return false;\n            }\n\n            // Check that the keyword has not been met\n            if ( keywords.contains( keyword ) )\n            {\n                if ( LOG.isDebugEnabled() )\n                {\n                    LOG.debug( I18n.err( I18n.ERR_13210_SYNTAX_INVALID, value ) );\n                }\n                \n                return false;\n            }\n\n            keywords.add( keyword );\n            needKeyword = false;\n\n            // Skip spaces\n            while ( ( i < len ) && ( strValue.charAt( i ) == ' ' ) )\n            {\n                i++;\n            }\n\n            // Do we have another keyword ?\n            if ( ( i < len ) && ( strValue.charAt( i ) == '$' ) )\n            {\n                // yes\n                i++;\n                needKeyword = true;\n            }\n        }\n\n        // We are done\n        if ( LOG.isDebugEnabled() )\n        {\n            if ( needKeyword )\n            {\n                LOG.debug( I18n.err( I18n.ERR_13210_SYNTAX_INVALID, value ) );\n            }\n            else\n            {\n                LOG.debug( I18n.msg( I18n.MSG_13701_SYNTAX_VALID, value ) );\n            }\n        }\n\n        return !needKeyword;\n    }\n}<fim_middle>// function below is long method\n"}