{"text": "<fim_prefix>    @Override public final void onContextInitialized(final IgniteSpiContext spiCtx) throws IgniteSpiException {\n        assert spiCtx != null;\n        this.spiCtx = spiCtx;\n        if (!Boolean.getBoolean(IGNITE_SKIP_CONFIGURATION_CONSISTENCY_CHECK)) {\n            spiCtx.addLocalEventListener(paramsLsnr = new GridLocalEventListener() {\n                @Override public void onEvent(Event evt) {\n                    assert evt instanceof DiscoveryEvent : \"Invalid event [expected=\" + EVT_NODE_JOINED +\n                        \", actual=\" + evt.type() + \", evt=\" + evt + ']';\n                    ClusterNode node = spiCtx.node(((DiscoveryEvent)evt).eventNode().id());\n                    if (node != null)\n                        try {\n                            checkConfigurationConsistency(spiCtx, node, false);\n                            checkConfigurationConsistency0(spiCtx, node, false);\n                        }\n                        catch (IgniteSpiException e) {\n                            U.error(log, \"Spi consistency check failed [node=\" + node.id() + \", spi=\" + getName() + ']',\n                                e);\n                        }\n                }\n            }, EVT_NODE_JOINED);\n            final Collection<ClusterNode> remotes = F.concat(false, spiCtx.remoteNodes(), spiCtx.remoteDaemonNodes());\n            for (ClusterNode node : remotes) {\n                checkConfigurationConsistency(spiCtx, node, true);\n                checkConfigurationConsistency0(spiCtx, node, true);\n            }\n        }\n        onContextInitialized0(spiCtx);\n    }\n    /**\n     * Method to be called in the end of onContextInitialized method.\n     *\n     * @param spiCtx SPI context.\n     * @throws IgniteSpiException In case of errors.\n     */\n    protected void onContextInitialized0(final IgniteSpiContext spiCtx) throws IgniteSpiException {\n        // No-op.\n    }\n    /** {@inheritDoc} */\n    @Override public final void onContextDestroyed() {\n        onContextDestroyed0();\n        if (spiCtx != null && paramsLsnr != null)\n            spiCtx.removeLocalEventListener(paramsLsnr);\n        ClusterNode locNode = spiCtx == null ? null : spiCtx.localNode();\n        // Set dummy no-op context.\n        spiCtx = new GridDummySpiContext(locNode, true, spiCtx);\n    }\n    /** {@inheritDoc} */\n    @Override public void onClientDisconnected(IgniteFuture<?> reconnectFut) {\n        // No-op.\n    }\n    /** {@inheritDoc} */\n    @Override public void onClientReconnected(boolean clusterRestarted) {\n        // No-op.\n    }\n    /**\n     * Inject ignite instance.\n     *\n     * @param ignite Ignite instance.\n     */\n    @IgniteInstanceResource\n    protected void injectResources(Ignite ignite) {\n        this.ignite = ignite;\n        if (ignite != null)\n            igniteInstanceName = ignite.name();\n    }\n    /**\n     * Method to be called in the beginning of onContextDestroyed() method.\n     */\n    protected void onContextDestroyed0() {\n        // No-op.\n    }\n    /**\n     * This method returns SPI internal instances that need to be injected as well.\n     * Usually these will be instances provided to SPI externally by user, e.g. during\n     * SPI configuration.\n     *\n     * @return Internal SPI objects that also need to be injected.\n     */\n    public Collection<Object> injectables() {\n        return Collections.emptyList();\n    }\n    /**\n     * Gets SPI context.\n     *\n     * @return SPI context.\n     */\n    public IgniteSpiContext getSpiContext() {\n        return spiCtx;\n    }\n    /**\n     * Gets Exception registry.\n     *\n     * @return Exception registry.\n     */\n    public IgniteExceptionRegistry getExceptionRegistry() {\n        return IgniteExceptionRegistry.get();\n    }\n    /** {@inheritDoc} */\n    @Override public Map<String, Object> getNodeAttributes() throws IgniteSpiException {\n        return Collections.emptyMap();\n    }\n    /**\n     * Throws exception with uniform error message if given parameter's assertion condition\n     * is {@code false}.\n     *\n     * @param cond Assertion condition to check.\n     * @param condDesc Description of failed condition. Note that this description should include\n     *      JavaBean name of the property (<b>not</b> a variable name) as well condition in\n     *      Java syntax like, for example:\n     *      <pre name=\"code\" class=\"java\">\n     *      ...\n     *      assertParameter(dirPath != null, \"dirPath != null\");\n     *      ...\n     *      </pre>\n     *      Note that in case when variable name is the same as JavaBean property you\n     *      can just copy Java condition expression into description as a string.\n     * @throws IgniteSpiException Thrown if given condition is {@code false}\n     */\n    protected final void assertParameter(boolean cond, String condDesc) throws IgniteSpiException {\n        if (!cond)\n            throw new IgniteSpiException(\"SPI parameter failed condition check: \" + condDesc);\n    }\n    /**\n     * Gets uniformly formatted message for SPI start.\n     *\n     * @return Uniformly formatted message for SPI start.\n     */\n    protected final String startInfo() {\n        return \"SPI started ok [startMs=\" + startTstamp + \", spiMBean=\" + spiMBean + ']';\n    }\n    /**\n     * Gets SPI startup time.\n     * @return Time in millis.\n     */\n    final long getStartTstamp() {\n        return startTstamp;\n    }\n    /**\n     * Gets uniformly format message for SPI stop.\n     *\n     * @return Uniformly format message for SPI stop.\n     */\n    protected final String stopInfo() {\n        return \"SPI stopped ok.\";\n    }\n    /**\n     * Gets uniformed string for configuration parameter.\n     *\n     * @param name Parameter name.\n     * @param val Parameter value.\n     * @return Uniformed string for configuration parameter.\n     */\n    protected final String configInfo(String name, Object val) {\n        assert name != null;\n        return \"Using parameter [\" + name + '=' + val + ']';\n    }\n    /**\n     * @param msg Error message.\n     * @param locVal Local node value.\n     * @return Error text.\n     */\n    private static String format(String msg, Object locVal) {\n        return msg + U.nl() +\n            \">>> => Local node:  \" + locVal + U.nl();\n    }\n    /**\n     * @param msg Error message.\n     * @param locVal Local node value.\n     * @param rmtVal Remote node value.\n     * @return Error text.\n     */\n    private static String format(String msg, Object locVal, Object rmtVal) {\n        return msg + U.nl() +\n            \">>> => Local node:  \" + locVal + U.nl() +\n            \">>> => Remote node: \" + rmtVal + U.nl();\n    }\n    /**\n     * Registers SPI MBean. Note that SPI can only register one MBean.\n     *\n     * @param igniteInstanceName Ignite instance name. If null, then name will be empty.\n     * @param impl MBean implementation.\n     * @param mbeanItf MBean interface (if {@code null}, then standard JMX\n     *    naming conventions are used.\n     * @param <T> Type of the MBean\n     * @throws IgniteSpiException If registration failed.\n     */\n    protected final <T extends IgniteSpiManagementMBean> void registerMBean(String igniteInstanceName, T impl, Class<T> mbeanItf\n       ) throws IgniteSpiException {\n        if(ignite == null || U.IGNITE_MBEANS_DISABLED)\n            return;\n        MBeanServer jmx = ignite.configuration().getMBeanServer();\n        assert mbeanItf == null || mbeanItf.isInterface();\n        assert jmx != null;\n        try {\n            spiMBean = U.registerMBean(jmx, igniteInstanceName, \"SPIs\", getName(), impl, mbeanItf);\n            if (log.isDebugEnabled())\n                log.debug(\"Registered SPI MBean: \" + spiMBean);\n        }\n        catch (JMException e) {\n            throw new IgniteSpiException(\"Failed to register SPI MBean: \" + spiMBean, e);\n        }\n    }\n    /**\n     * Unregisters MBean.\n     *\n     * @throws IgniteSpiException If bean could not be unregistered.\n     */\n<fim_suffix>    protected final void unregisterMBean() throws IgniteSpiException {\n        // Unregister SPI MBean.\n        if (spiMBean != null && ignite != null) {\n            assert !U.IGNITE_MBEANS_DISABLED;\n            MBeanServer jmx = ignite.configuration().getMBeanServer();\n            assert jmx != null;\n            try {\n                jmx.unregisterMBean(spiMBean);\n                if (log.isDebugEnabled())\n                    log.debug(\"Unregistered SPI MBean: \" + spiMBean);\n            }\n            catch (JMException e) {\n                throw new IgniteSpiException(\"Failed to unregister SPI MBean: \" + spiMBean, e);\n            }\n        }\n    }<fim_middle>// function below has no smell\n"}