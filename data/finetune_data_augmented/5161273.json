{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *  \n *     http://www.apache.org/licenses/LICENSE-2.0\n *  \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.kylin.storage.gtrecord;\n\nimport java.io.IOException;\nimport java.util.Iterator;\n\nimport org.apache.kylin.common.util.ImmutableBitSet;\nimport org.apache.kylin.gridtable.GTInfo;\nimport org.apache.kylin.gridtable.GTRecord;\nimport org.apache.kylin.gridtable.GTScanRequest;\nimport org.apache.kylin.gridtable.IGTScanner;\nimport org.apache.kylin.storage.StorageContext;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.google.common.base.Function;\nimport com.google.common.collect.Iterators;\n\n/**\n * scatter the blob returned from region server to a iterable of gtrecords\n */\npublic class StorageResponseGTScatter implements IGTScanner {\n\n    private static final Logger logger = LoggerFactory.getLogger(StorageResponseGTScatter.class);\n\n    private final GTInfo info;\n    private IPartitionStreamer partitionStreamer;\n    private final Iterator<byte[]> blocks;\n    private final ImmutableBitSet columns;\n    private final ImmutableBitSet groupByDims;\n    private final boolean needSorted; // whether scanner should return sorted records\n\n<fim_suffix>    public StorageResponseGTScatter(GTScanRequest scanRequest, IPartitionStreamer partitionStreamer,\n            StorageContext context) {\n        this.info = scanRequest.getInfo();\n        this.partitionStreamer = partitionStreamer;\n        this.blocks = partitionStreamer.asByteArrayIterator();\n        this.columns = scanRequest.getColumns();\n        this.groupByDims = scanRequest.getAggrGroupBy();\n        this.needSorted = (context.getFinalPushDownLimit() != Integer.MAX_VALUE) || context.isStreamAggregateEnabled();\n    }\n\n    @Override\n    public GTInfo getInfo() {\n        return info;\n    }\n\n    @Override\n    public void close() throws IOException {\n        //If upper consumer failed while consuming the GTRecords, the consumer should call IGTScanner's close method to ensure releasing resource\n        partitionStreamer.close();\n    }\n\n    @Override\n    public Iterator<GTRecord> iterator() {\n        Iterator<PartitionResultIterator> iterators = Iterators.transform(blocks,\n                new Function<byte[], PartitionResultIterator>() {\n                    public PartitionResultIterator apply(byte[] input) {\n                        return new PartitionResultIterator(input, info, columns);\n                    }\n                });\n\n        if (!needSorted) {\n            logger.debug(\"Using Iterators.concat to pipeline partition results\");\n            return Iterators.concat(iterators);\n        }\n\n        return new SortMergedPartitionResultIterator(iterators, info, GTRecord.getComparator(groupByDims));\n    }\n}<fim_middle>// function below has no smell\n"}