{"text": "<fim_prefix>/*[INCLUDE-IF Sidecar17]*/\n/*******************************************************************************\n * Copyright (c) 2009, 2017 IBM Corp. and others\n *\n * This program and the accompanying materials are made available under\n * the terms of the Eclipse Public License 2.0 which accompanies this\n * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n * or the Apache License, Version 2.0 which accompanies this distribution and\n * is available at https://www.apache.org/licenses/LICENSE-2.0.\n *\n * This Source Code may also be made available under the following\n * Secondary Licenses when the conditions for such availability set\n * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n * General Public License, version 2 with the GNU Classpath\n * Exception [1] and GNU General Public License, version 2 with the\n * OpenJDK Assembly Exception [2].\n *\n * [1] https://www.gnu.org/software/classpath/license.html\n * [2] http://openjdk.java.net/legal/assembly-exception.html\n *\n * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n *******************************************************************************/\n\npackage java.lang.invoke;\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\n\n<fim_suffix>abstract class IndirectHandle extends PrimitiveHandle {\n\tIndirectHandle(MethodType type, Class<?> referenceClass, String name, byte kind, int modifiers) {\n\t\tsuper(type, referenceClass, name, kind, modifiers, null);\n\t}\n\t\n\tIndirectHandle(MethodType type, Class<?> referenceClass, String name, byte kind) {\n\t\tsuper(type, referenceClass, name, kind, null);\n\t}\n\n\tIndirectHandle(IndirectHandle originalHandle, MethodType newType) {\n\t\tsuper(originalHandle, newType);\n\t}\n\n\t// {{{ JIT support\n\tprotected abstract long vtableOffset(Object receiver);\n\tprotected final long vtableIndexArgument(Object receiver){ return - vtableOffset(receiver); }\n\n\tprotected final long jittedMethodAddress(Object receiver) {\n\t\tlong receiverClass = getJ9ClassFromClass(receiver.getClass());\n\t\tlong result; \n\t\tif (VTABLE_ENTRY_SIZE == 4) {\n\t\t\tresult = UNSAFE.getInt(receiverClass - vtableOffset(receiver));\n\t\t} else { \n\t\t\tresult = UNSAFE.getLong(receiverClass - vtableOffset(receiver));\n\t\t}\n\t\treturn result;\n\t}\n\n\t@Override\n\tboolean canRevealDirect() {\n\t\treturn true;\n\t}\n\n\t// }}} JIT support\n\n\tprotected static final MethodType indirectMethodType(Method method) {\n\t\tMethodType originalType = MethodType.methodType(method.getReturnType(), method.getParameterTypes());\n\t\treturn indirectMethodType(originalType, method.getDeclaringClass());\n\t}\n\t\n\t/* Indirect MethodHandles have the receiver type inserted as \n\t * first argument of the MH's type.\n\t */\n\tprotected static final MethodType indirectMethodType(MethodType type, Class<?> referenceClazz) {\n\t\treturn type.insertParameterTypes(0, referenceClazz);\n\t}\n\t\n\t@Override\n\tpublic MethodHandle bindTo(Object value) throws IllegalArgumentException, ClassCastException {\n\t\tif (null == value) {\n\t\t\treturn super.bindTo(value);\n\t\t}\n\t\t\n\t\t/*\n\t\t * Check whether the first parameter has a reference type assignable from value. Note that MethodType.parameterType(0) will\n\t\t * throw an IllegalArgumentException if type has no parameters.\n\t\t */\n\t\tClass<?> firstParameterType = type().parameterType(0);\n\t\tif (firstParameterType.isPrimitive()) {\n\t\t\tthrow new IllegalArgumentException();\n\t\t}\n\n\t\t/*\n\t\t * Ensure type compatibility.\n\t\t */\n\t\tvalue = firstParameterType.cast(value);\n\n\t\t/*\n\t\t * Devirtualize virtual/interface handles.\n\t\t */\n\t\ttry {\n\t\t\tMethodHandle result = MethodHandles.Lookup.internalPrivilegedLookup.bind(value, name, type().dropFirstParameterType());\n\n\t\t\t/*\n\t\t\t * An interface method must devirtualize to a public method. If the devirtualized method is not public,\n\t\t\t * an IllegalAccessError will be thrown when the MethodHandle is invoked. In order to enforce this behaviour,\n\t\t\t * we must preserve the original MethodHandle, i.e. not optimize to a ReceiverBoundHandle. \n\t\t\t */\n\t\t\tif (this instanceof InterfaceHandle) { \n\t\t\t\tif ((result.getModifiers() & Modifier.PUBLIC) == 0) {\n\t\t\t\t\tthrow new IllegalAccessException();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn result;\n\t\t} catch (IllegalAccessException e) {\n\t\t\t/*\n\t\t\t * Create a receiver bound MethodHandle by inserting the receiver object as an argument. This is done to \n\t\t\t * ensure that invocation is done using the original MethodHandle, which will result in an IllegalAccessError.\n\t\t\t */\n\t\t\treturn MethodHandles.insertArguments(this, 0, value);\n\t\t} catch (NoSuchMethodException e) {\n\t\t\tthrow new Error(e);\n\t\t}\n\t}\n\t\n\tfinal void compareWithIndirect(IndirectHandle left, Comparator c) {\n\t\tc.compareStructuralParameter(left.referenceClass, this.referenceClass);\n\t\tc.compareStructuralParameter(left.vmSlot, this.vmSlot);\n\t}\n}\n<fim_middle>// class below has no smell\n"}