{"text": "<fim_prefix>      tok.quoteChar('\"');\n      tok.parseNumbers();\n      tok.ordinaryChar(',');\n      tok.ordinaryChar('(');\n      tok.ordinaryChar(')');\n      tok.wordChars('$','$');\n      tok.wordChars('_','_');\n    }\n    Token next() throws IOException {\n      int type = tok.nextToken();\n      switch (type) {\n        case StreamTokenizer.TT_EOF:\n        case StreamTokenizer.TT_EOL:\n          return null;\n        case StreamTokenizer.TT_NUMBER:\n          return new NumToken(tok.nval);\n        case StreamTokenizer.TT_WORD:\n          return new StrToken(TType.IDENT, tok.sval);\n        case '\"':\n          return new StrToken(TType.QUOT, tok.sval);\n        default:\n          switch (type) {\n            case ',':\n              return new Token(TType.COMMA);\n            case '(':\n              return new Token(TType.LPAREN);\n            case ')':\n              return new Token(TType.RPAREN);\n            default:\n              throw new IOException(\"Unexpected: \" + type);\n          }\n      }\n    }\n  }\n@SuppressWarnings(\"unchecked\")\n@InterfaceAudience.Public\n@InterfaceStability.Evolving\npublic abstract static class Node extends ComposableInputFormat {\n    /**\n     * Return the node type registered for the particular identifier.\n     * By default, this is a CNode for any composite node and a WNode\n     * for &quot;wrapped&quot; nodes. User nodes will likely be composite\n     * nodes.\n     * @see #addIdentifier(java.lang.String, java.lang.Class[], java.lang.Class, java.lang.Class)\n     * @see CompositeInputFormat#setFormat(org.apache.hadoop.mapred.JobConf)\n     */\n    static Node forIdent(String ident) throws IOException {\n      try {\n        if (!nodeCstrMap.containsKey(ident)) {\n          throw new IOException(\"No nodetype for \" + ident);\n        }\n        return nodeCstrMap.get(ident).newInstance(ident);\n      } catch (IllegalAccessException e) {\n        throw new IOException(e);\n      } catch (InstantiationException e) {\n        throw new IOException(e);\n      } catch (InvocationTargetException e) {\n        throw new IOException(e);\n      }\n    }\n    private static final Class<?>[] ncstrSig = { String.class };\n    private static final\n        Map<String,Constructor<? extends Node>> nodeCstrMap =\n        new HashMap<String,Constructor<? extends Node>>();\n    protected static final Map<String,Constructor<? extends \n        ComposableRecordReader>> rrCstrMap =\n        new HashMap<String,Constructor<? extends ComposableRecordReader>>();\n    /**\n     * For a given identifier, add a mapping to the nodetype for the parse\n     * tree and to the ComposableRecordReader to be created, including the\n     * formals required to invoke the constructor.\n     * The nodetype and constructor signature should be filled in from the\n     * child node.\n     */\n    protected static void addIdentifier(String ident, Class<?>[] mcstrSig,\n                              Class<? extends Node> nodetype,\n                              Class<? extends ComposableRecordReader> cl)\n        throws NoSuchMethodException {\n      Constructor<? extends Node> ncstr =\n        nodetype.getDeclaredConstructor(ncstrSig);\n      ncstr.setAccessible(true);\n      nodeCstrMap.put(ident, ncstr);\n      Constructor<? extends ComposableRecordReader> mcstr =\n        cl.getDeclaredConstructor(mcstrSig);\n      mcstr.setAccessible(true);\n      rrCstrMap.put(ident, mcstr);\n    }\n    // inst\n    protected int id = -1;\n    protected String ident;\n    protected Class<? extends WritableComparator> cmpcl;\n    protected Node(String ident) {\n      this.ident = ident;\n    }\n    protected void setID(int id) {\n      this.id = id;\n    }\n    protected void setKeyComparator(\n        Class<? extends WritableComparator> cmpcl) {\n      this.cmpcl = cmpcl;\n    }\n    abstract void parse(List<Token> args, Configuration conf) \n        throws IOException;\n  }\n  /**\n   * Nodetype in the parse tree for &quot;wrapped&quot; InputFormats.\n   */\n  static class WNode extends Node {\n    private static final Class<?>[] cstrSig =\n      { Integer.TYPE, RecordReader.class, Class.class };\n    @SuppressWarnings(\"unchecked\")\n\tstatic void addIdentifier(String ident,\n                              Class<? extends ComposableRecordReader> cl)\n        throws NoSuchMethodException {\n      Node.addIdentifier(ident, cstrSig, WNode.class, cl);\n    }\n    private String indir;\n    private InputFormat<?, ?> inf;\n    public WNode(String ident) {\n      super(ident);\n    }\n    /**\n     * Let the first actual define the InputFormat and the second define\n     * the <tt>mapred.input.dir</tt> property.\n     */\n    @Override\n    public void parse(List<Token> ll, Configuration conf) throws IOException {\n      StringBuilder sb = new StringBuilder();\n      Iterator<Token> i = ll.iterator();\n      while (i.hasNext()) {\n        Token t = i.next();\n        if (TType.COMMA.equals(t.getType())) {\n          try {\n          \tinf = (InputFormat<?, ?>)ReflectionUtils.newInstance(\n          \t\t\tconf.getClassByName(sb.toString()), conf);\n          } catch (ClassNotFoundException e) {\n            throw new IOException(e);\n          } catch (IllegalArgumentException e) {\n            throw new IOException(e);\n          }\n          break;\n        }\n        sb.append(t.getStr());\n      }\n      if (!i.hasNext()) {\n        throw new IOException(\"Parse error\");\n      }\n      Token t = i.next();\n      if (!TType.QUOT.equals(t.getType())) {\n        throw new IOException(\"Expected quoted string\");\n      }\n      indir = t.getStr();\n      // no check for ll.isEmpty() to permit extension\n    }\n    private Configuration getConf(Configuration jconf) throws IOException {\n      Job job = new Job(jconf);\n      FileInputFormat.setInputPaths(job, indir);\n      return job.getConfiguration();\n    }\n    public List<InputSplit> getSplits(JobContext context)\n        throws IOException, InterruptedException {\n      return inf.getSplits(\n                 new JobContextImpl(getConf(context.getConfiguration()), \n                                    context.getJobID()));\n    }\n    public ComposableRecordReader<?, ?> createRecordReader(InputSplit split, \n        TaskAttemptContext taskContext) \n        throws IOException, InterruptedException {\n      try {\n        if (!rrCstrMap.containsKey(ident)) {\n          throw new IOException(\"No RecordReader for \" + ident);\n        }\n        Configuration conf = getConf(taskContext.getConfiguration());\n        TaskAttemptContext context = \n          new TaskAttemptContextImpl(conf, \n              TaskAttemptID.forName(conf.get(MRJobConfig.TASK_ATTEMPT_ID)), \n              new WrappedStatusReporter(taskContext));\n        return rrCstrMap.get(ident).newInstance(id,\n            inf.createRecordReader(split, context), cmpcl);\n      } catch (IllegalAccessException e) {\n        throw new IOException(e);\n      } catch (InstantiationException e) {\n        throw new IOException(e);\n      } catch (InvocationTargetException e) {\n        throw new IOException(e);\n      }\n    }\n    public String toString() {\n      return ident + \"(\" + inf.getClass().getName() + \",\\\"\" + indir + \"\\\")\";\n    }\n  }\n  private static class WrappedStatusReporter extends StatusReporter {\n    TaskAttemptContext context;\n    public WrappedStatusReporter(TaskAttemptContext context) {\n      this.context = context; \n    }\n    @Override\n    public Counter getCounter(Enum<?> name) {\n      return context.getCounter(name);\n    }\n    @Override\n    public Counter getCounter(String group, String name) {\n      return context.getCounter(group, name);\n    }\n    @Override\n    public void progress() {\n      context.progress();\n    }\n    @Override\n    public float getProgress() {\n      return context.getProgress();\n    }\n    @Override\n    public void setStatus(String status) {\n      context.setStatus(status);\n    }\n  }\n  /**\n   * Internal nodetype for &quot;composite&quot; InputFormats.\n   */\n  static class CNode extends Node {\n    private static final Class<?>[] cstrSig =\n      { Integer.TYPE, Configuration.class, Integer.TYPE, Class.class };\n    @SuppressWarnings(\"unchecked\")\n\tstatic void addIdentifier(String ident,\n                              Class<? extends ComposableRecordReader> cl)\n        throws NoSuchMethodException {\n      Node.addIdentifier(ident, cstrSig, CNode.class, cl);\n    }\n    // inst\n    private ArrayList<Node> kids = new ArrayList<Node>();\n    public CNode(String ident) {\n      super(ident);\n    }\n<fim_suffix>    @Override\n    public void setKeyComparator(Class<? extends WritableComparator> cmpcl) {\n      super.setKeyComparator(cmpcl);\n      for (Node n : kids) {\n        n.setKeyComparator(cmpcl);\n      }\n    }<fim_middle>// function below has no smell\n"}