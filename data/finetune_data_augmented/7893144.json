{"text": "<fim_prefix>/*\n * Copyright 2016-present Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License. You may obtain\n * a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\n\npackage com.facebook.buck.cxx;\n\nimport com.facebook.buck.core.rulekey.AddToRuleKey;\nimport com.facebook.buck.core.rulekey.AddsToRuleKey;\nimport com.facebook.buck.core.rules.BuildRule;\nimport com.facebook.buck.core.rules.SourcePathRuleFinder;\nimport com.facebook.buck.core.rules.common.BuildableSupport;\nimport com.facebook.buck.core.rules.modern.annotations.CustomFieldBehavior;\nimport com.facebook.buck.core.rules.modern.annotations.DefaultFieldSerialization;\nimport com.facebook.buck.core.sourcepath.SourcePath;\nimport com.facebook.buck.core.sourcepath.resolver.SourcePathResolver;\nimport com.facebook.buck.core.util.immutables.BuckStyleImmutable;\nimport com.facebook.buck.cxx.toolchain.DebugPathSanitizer;\nimport com.facebook.buck.cxx.toolchain.PathShortener;\nimport com.facebook.buck.cxx.toolchain.Preprocessor;\nimport com.facebook.buck.rules.args.Arg;\nimport com.facebook.buck.rules.args.StringArg;\nimport com.facebook.buck.rules.coercer.FrameworkPath;\nimport com.facebook.buck.util.Optionals;\nimport com.google.common.collect.ImmutableList;\nimport java.nio.file.Path;\nimport java.util.Optional;\nimport java.util.function.Function;\nimport org.immutables.value.Value;\n\n@Value.Immutable(copy = true)\n@BuckStyleImmutable\nabstract class AbstractPreprocessorFlags implements AddsToRuleKey {\n\n  /** File set via {@code -include}. This might be a prefix header or a precompiled header. */\n  @AddToRuleKey\n  @Value.Parameter\n  public abstract Optional<SourcePath> getPrefixHeader();\n\n  /** Other flags included as is. */\n  @AddToRuleKey\n  @Value.Parameter\n  @Value.Default\n  public CxxToolFlags getOtherFlags() {\n    return CxxToolFlags.of();\n  }\n\n  /** Directories set via {@code -I}. */\n  @AddToRuleKey\n  @Value.Parameter\n  public abstract ImmutableList<CxxHeaders> getIncludes();\n\n  /** Directories set via {@code -F}. */\n  @AddToRuleKey\n  @Value.Parameter\n  public abstract ImmutableList<FrameworkPath> getFrameworkPaths();\n\n  @CustomFieldBehavior(DefaultFieldSerialization.class)\n  @Value.Derived\n  public CxxIncludePaths getCxxIncludePaths() {\n    return CxxIncludePaths.of(getIncludes(), getFrameworkPaths());\n  }\n\n  public Iterable<BuildRule> getDeps(SourcePathRuleFinder ruleFinder) {\n    ImmutableList.Builder<BuildRule> deps = ImmutableList.builder();\n    deps.addAll(\n        Optionals.toStream(getPrefixHeader())\n            .flatMap(ruleFinder.FILTER_BUILD_RULE_INPUTS)\n            .iterator());\n    for (CxxHeaders cxxHeaders : getIncludes()) {\n      cxxHeaders.getDeps(ruleFinder).forEachOrdered(deps::add);\n    }\n    for (FrameworkPath frameworkPath : getFrameworkPaths()) {\n      deps.addAll(frameworkPath.getDeps(ruleFinder));\n    }\n    for (Arg arg : getOtherFlags().getAllFlags()) {\n      deps.addAll(BuildableSupport.getDepsCollection(arg, ruleFinder));\n    }\n    return deps.build();\n  }\n\n  public CxxToolFlags getIncludePathFlags(\n      SourcePathResolver resolver,\n      PathShortener pathShortener,\n      Function<FrameworkPath, Path> frameworkPathTransformer,\n      Preprocessor preprocessor) {\n    return CxxToolFlags.explicitBuilder()\n        .addAllRuleFlags(\n            StringArg.from(\n                getCxxIncludePaths()\n                    .getFlags(resolver, pathShortener, frameworkPathTransformer, preprocessor)))\n        .build();\n  }\n\n  public CxxToolFlags getSanitizedIncludePathFlags(\n      DebugPathSanitizer sanitizer,\n      SourcePathResolver resolver,\n      PathShortener pathShortener,\n      Function<FrameworkPath, Path> frameworkPathTransformer,\n      Preprocessor preprocessor) {\n    return CxxToolFlags.explicitBuilder()\n        .addAllRuleFlags(\n            StringArg.from(\n                sanitizer.sanitizeFlags(\n                    getCxxIncludePaths()\n                        .getFlags(\n                            resolver, pathShortener, frameworkPathTransformer, preprocessor))))\n        .build();\n  }\n\n<fim_suffix>  public CxxToolFlags getNonIncludePathFlags(\n      SourcePathResolver resolver, Optional<PrecompiledHeaderData> pch, Preprocessor preprocessor) {\n    ExplicitCxxToolFlags.Builder builder = CxxToolFlags.explicitBuilder();\n    ExplicitCxxToolFlags.addCxxToolFlags(builder, getOtherFlags());\n    if (pch.isPresent()) {\n      builder.addAllRuleFlags(\n          StringArg.from(\n              preprocessor.prefixOrPCHArgs(\n                  pch.get().isPrecompiled(), resolver.getAbsolutePath(pch.get().getHeader()))));\n    }\n    return builder.build();\n  }\n\n  public CxxToolFlags toToolFlags(\n      SourcePathResolver resolver,\n      PathShortener pathShortener,\n      Function<FrameworkPath, Path> frameworkPathTransformer,\n      Preprocessor preprocessor,\n      Optional<PrecompiledHeaderData> precompiledHeader) {\n    return CxxToolFlags.concat(\n        getNonIncludePathFlags(resolver, precompiledHeader, preprocessor),\n        getIncludePathFlags(resolver, pathShortener, frameworkPathTransformer, preprocessor));\n  }\n}<fim_middle>// function below has no smell\n"}