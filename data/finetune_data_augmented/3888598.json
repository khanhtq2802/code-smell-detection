{"text": "<fim_prefix>import org.jctools.queues.SpscArrayQueue;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport com.datatorrent.api.Sink;\nimport com.datatorrent.netlet.util.CircularBuffer;\nimport com.datatorrent.netlet.util.UnsafeBlockingQueue;\nimport com.datatorrent.stram.tuple.Tuple;\nimport static java.lang.Thread.sleep;\n/**\n * Abstract Sweepable Reservoir implementation. Implements all methods of {@link SweepableReservoir} except\n * {@link SweepableReservoir#sweep}. Classes that extend {@link AbstractReservoir} must implement\n * {@link BlockingQueue} interface.\n *\n * @since 3.4.0\n */\npublic abstract class AbstractReservoir implements SweepableReservoir, BlockingQueue<Object>\n{\n  private static final Logger logger = LoggerFactory.getLogger(AbstractReservoir.class);\n  static final String reservoirClassNameProperty = \"com.datatorrent.stram.engine.Reservoir\";\n  private static final int SPSC_ARRAY_BLOCKING_QUEUE_CAPACITY_THRESHOLD = 64 * 1024;\n  /**\n   * Reservoir factory. Constructs concrete implementation of {@link AbstractReservoir} based on\n   * {@link AbstractReservoir#reservoirClassNameProperty} property.\n   * @param id reservoir identifier\n   * @param capacity reservoir capacity\n   * @return concrete implementation of {@link AbstractReservoir}\n   */\n  public static AbstractReservoir newReservoir(final String id, final int capacity)\n  {\n    String reservoirClassName = System.getProperty(reservoirClassNameProperty);\n    if (reservoirClassName == null) {\n      if (capacity >= SPSC_ARRAY_BLOCKING_QUEUE_CAPACITY_THRESHOLD) {\n        return new SpscArrayQueueReservoir(id, capacity);\n      } else {\n        return new SpscArrayBlockingQueueReservoir(id, capacity);\n      }\n    } else if (reservoirClassName.equals(SpscArrayQueueReservoir.class.getName())) {\n      return new SpscArrayQueueReservoir(id, capacity);\n    } else if (reservoirClassName.equals(SpscArrayBlockingQueueReservoir.class.getName())) {\n      return new SpscArrayBlockingQueueReservoir(id, capacity);\n    } else if (reservoirClassName.equals(CircularBufferReservoir.class.getName())) {\n      return new CircularBufferReservoir(id, capacity);\n    } else if (reservoirClassName.equals(ArrayBlockingQueueReservoir.class.getName())) {\n      return new ArrayBlockingQueueReservoir(id, capacity);\n    } else {\n      try {\n        final Constructor<?> constructor = Class.forName(reservoirClassName).getConstructor(String.class, int.class);\n        return (AbstractReservoir)constructor.newInstance(id, capacity);\n      } catch (ReflectiveOperationException e) {\n        logger.debug(\"Fail to construct reservoir {}\", reservoirClassName, e);\n        throw new RuntimeException(\"Fail to construct reservoir \" + reservoirClassName, e);\n      }\n    }\n  }\n  private Sink<Object> sink;\n  private String id;\n  protected int count;\n  protected AbstractReservoir(final String id)\n  {\n    this.id = id;\n  }\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public Sink<Object> setSink(Sink<Object> sink)\n  {\n    try {\n      return this.sink;\n    } finally {\n      this.sink = sink;\n    }\n  }\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public int getCount(boolean reset)\n  {\n    try {\n      return count;\n    } finally {\n      if (reset) {\n        count = 0;\n      }\n    }\n  }\n  /**\n   * @return allocated reservoir capacity\n   */\n  public abstract int capacity();\n  /**\n   * @return reservoir id\n   */\n  public String getId()\n  {\n    return id;\n  }\n  /**\n   * @param id the id to set\n   */\n  public void setId(String id)\n  {\n    this.id = id;\n  }\n  protected Sink<Object> getSink()\n  {\n    return sink;\n  }\n  @Override\n  public String toString()\n  {\n    return getClass().getName() + '@' + Integer.toHexString(hashCode()) +\n      \"{sink=\" + sink + \", id=\" + id + \", count=\" + count + '}';\n  }\n  /**\n   * <p>SpscArrayQueueReservoir</p>\n   * {@link SweepableReservoir} implementation that extends AbstractReservoir and delegates {@link BlockingQueue}\n   * implementation to {@see <a href=http://jctools.github.io/JCTools/>JCTools</a>} SpscArrayQueue.\n   */\n<fim_suffix>  private static class SpscArrayQueueReservoir extends AbstractReservoir\n  {\n    private final int maxSpinMillis = 10;\n    private final SpscArrayQueue<Object> queue;\n    private SpscArrayQueueReservoir(final String id, final int capacity)\n    {\n      super(id);\n      queue = new SpscArrayQueue<>(capacity);\n    }\n    @Override\n    public Tuple sweep()\n    {\n      Object o;\n      final SpscArrayQueue<Object> queue = this.queue;\n      final Sink<Object> sink = getSink();\n      while ((o = queue.peek()) != null) {\n        if (o instanceof Tuple) {\n          return (Tuple)o;\n        }\n        count++;\n        sink.put(queue.poll());\n      }\n      return null;\n    }\n    @Override\n    public boolean add(Object o)\n    {\n      return queue.add(o);\n    }\n    @Override\n    public Object remove()\n    {\n      return queue.remove();\n    }\n    @Override\n    public Object peek()\n    {\n      return queue.peek();\n    }\n    @Override\n    public int size(final boolean dataTupleAware)\n    {\n      return queue.size();\n    }\n    @Override\n    public int capacity()\n    {\n      return queue.capacity();\n    }\n    @Override\n    public int drainTo(final Collection<? super Object> container)\n    {\n      return queue.drain(new MessagePassingQueue.Consumer<Object>()\n      {\n        @Override\n        public void accept(Object o)\n        {\n          container.add(o);\n        }\n      });\n    }\n    @Override\n    public boolean offer(Object o)\n    {\n      return queue.offer(o);\n    }\n    @Override\n    public void put(Object o) throws InterruptedException\n    {\n      long spinMillis = 0;\n      final SpscArrayQueue<Object> queue = this.queue;\n      while (!queue.offer(o)) {\n        sleep(spinMillis);\n        spinMillis = Math.min(maxSpinMillis, spinMillis + 1);\n      }\n    }\n    @Override\n    public boolean offer(Object o, long timeout, TimeUnit unit) throws InterruptedException\n    {\n      throw new UnsupportedOperationException();\n    }\n    @Override\n    public Object take() throws InterruptedException\n    {\n      throw new UnsupportedOperationException();\n    }\n    @Override\n    public Object poll(long timeout, TimeUnit unit) throws InterruptedException\n    {\n      throw new UnsupportedOperationException();\n    }\n    @Override\n    public int remainingCapacity()\n    {\n      final SpscArrayQueue<Object> queue = this.queue;\n      return queue.capacity() - queue.size();\n    }\n    @Override\n    public boolean remove(Object o)\n    {\n      return queue.remove(o);\n    }\n    @Override\n    public boolean contains(Object o)\n    {\n      return queue.contains(o);\n    }\n    @Override\n    public int drainTo(final Collection<? super Object> collection, int maxElements)\n    {\n      return queue.drain(new MessagePassingQueue.Consumer<Object>()\n      {\n        @Override\n        public void accept(Object o)\n        {\n          collection.add(o);\n        }\n      }, maxElements);\n    }\n    @Override\n    public Object poll()\n    {\n      return queue.poll();\n    }\n    @Override\n    public Object element()\n    {\n      return queue.element();\n    }\n    @Override\n    public boolean isEmpty()\n    {\n      return queue.peek() == null;\n    }\n    @Override\n    public Iterator<Object> iterator()\n    {\n      return queue.iterator();\n    }\n    @Override\n    public Object[] toArray()\n    {\n      return queue.toArray();\n    }\n    @Override\n    public <T> T[] toArray(T[] a)\n    {\n      return queue.toArray(a);\n    }\n    @Override\n    public boolean containsAll(Collection<?> c)\n    {\n      return queue.containsAll(c);\n    }\n    @Override\n    public boolean addAll(Collection<?> c)\n    {\n      return queue.addAll(c);\n    }\n    @Override\n    public boolean removeAll(Collection<?> c)\n    {\n      return queue.removeAll(c);\n    }\n    @Override\n    public boolean retainAll(Collection<?> c)\n    {\n      return queue.retainAll(c);\n    }\n    @Override\n    public int size()\n    {\n      return queue.size();\n    }\n    @Override\n    public void clear()\n    {\n      queue.clear();\n    }\n    protected SpscArrayQueue<Object> getQueue()\n    {\n      return queue;\n    }\n  }<fim_middle>// class below has no smell\n"}