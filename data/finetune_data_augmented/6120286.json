{"text": "<fim_prefix>        }\n        return this.nonSentinel(cur);\n    }\n    private T chainedPut(T key, int index)\n    {\n        Object realKey = UnifiedSet.toSentinelIfNull(key);\n        if (this.table[index] instanceof ChainedBucket)\n        {\n            ChainedBucket bucket = (ChainedBucket) this.table[index];\n            do\n            {\n                if (this.nonNullTableObjectEquals(bucket.zero, key))\n                {\n                    return this.nonSentinel(bucket.zero);\n                }\n                if (bucket.one == null)\n                {\n                    bucket.one = realKey;\n                    if (++this.occupied > this.maxSize)\n                    {\n                        this.rehash();\n                    }\n                    return key;\n                }\n                if (this.nonNullTableObjectEquals(bucket.one, key))\n                {\n                    return this.nonSentinel(bucket.one);\n                }\n                if (bucket.two == null)\n                {\n                    bucket.two = realKey;\n                    if (++this.occupied > this.maxSize)\n                    {\n                        this.rehash();\n                    }\n                    return key;\n                }\n                if (this.nonNullTableObjectEquals(bucket.two, key))\n                {\n                    return this.nonSentinel(bucket.two);\n                }\n                if (bucket.three instanceof ChainedBucket)\n                {\n                    bucket = (ChainedBucket) bucket.three;\n                    continue;\n                }\n                if (bucket.three == null)\n                {\n                    bucket.three = realKey;\n                    if (++this.occupied > this.maxSize)\n                    {\n                        this.rehash();\n                    }\n                    return key;\n                }\n                if (this.nonNullTableObjectEquals(bucket.three, key))\n                {\n                    return this.nonSentinel(bucket.three);\n                }\n                bucket.three = new ChainedBucket(bucket.three, realKey);\n                if (++this.occupied > this.maxSize)\n                {\n                    this.rehash();\n                }\n                return key;\n            }\n            while (true);\n        }\n        ChainedBucket newBucket = new ChainedBucket(this.table[index], realKey);\n        this.table[index] = newBucket;\n        if (++this.occupied > this.maxSize)\n        {\n            this.rehash();\n        }\n        return key;\n    }\n    @Override\n    public T removeFromPool(T key)\n    {\n        int index = this.index(key);\n        Object cur = this.table[index];\n        if (cur == null)\n        {\n            return null;\n        }\n        if (cur instanceof ChainedBucket)\n        {\n            return this.removeFromChainForPool((ChainedBucket) cur, key, index);\n        }\n        if (this.nonNullTableObjectEquals(cur, key))\n        {\n            this.table[index] = null;\n            this.occupied--;\n            return this.nonSentinel(cur);\n        }\n        return null;\n    }\n    private T removeFromChainForPool(ChainedBucket bucket, T key, int index)\n    {\n        if (this.nonNullTableObjectEquals(bucket.zero, key))\n        {\n            Object result = bucket.zero;\n            bucket.zero = bucket.removeLast(0);\n            if (bucket.zero == null)\n            {\n                this.table[index] = null;\n            }\n            this.occupied--;\n            return this.nonSentinel(result);\n        }\n        if (bucket.one == null)\n        {\n            return null;\n        }\n        if (this.nonNullTableObjectEquals(bucket.one, key))\n        {\n            Object result = bucket.one;\n            bucket.one = bucket.removeLast(1);\n            this.occupied--;\n            return this.nonSentinel(result);\n        }\n        if (bucket.two == null)\n        {\n            return null;\n        }\n        if (this.nonNullTableObjectEquals(bucket.two, key))\n        {\n            Object result = bucket.two;\n            bucket.two = bucket.removeLast(2);\n            this.occupied--;\n            return this.nonSentinel(result);\n        }\n        if (bucket.three == null)\n        {\n            return null;\n        }\n        if (bucket.three instanceof ChainedBucket)\n        {\n            return this.removeDeepChainForPool(bucket, key);\n        }\n        if (this.nonNullTableObjectEquals(bucket.three, key))\n        {\n            Object result = bucket.three;\n            bucket.three = bucket.removeLast(3);\n            this.occupied--;\n            return this.nonSentinel(result);\n        }\n        return null;\n    }\n    private T removeDeepChainForPool(ChainedBucket oldBucket, T key)\n    {\n        do\n        {\n            ChainedBucket bucket = (ChainedBucket) oldBucket.three;\n            if (this.nonNullTableObjectEquals(bucket.zero, key))\n            {\n                Object result = bucket.zero;\n                bucket.zero = bucket.removeLast(0);\n                if (bucket.zero == null)\n                {\n                    oldBucket.three = null;\n                }\n                this.occupied--;\n                return this.nonSentinel(result);\n            }\n            if (bucket.one == null)\n            {\n                return null;\n            }\n            if (this.nonNullTableObjectEquals(bucket.one, key))\n            {\n                Object result = bucket.one;\n                bucket.one = bucket.removeLast(1);\n                this.occupied--;\n                return this.nonSentinel(result);\n            }\n            if (bucket.two == null)\n            {\n                return null;\n            }\n            if (this.nonNullTableObjectEquals(bucket.two, key))\n            {\n                Object result = bucket.two;\n                bucket.two = bucket.removeLast(2);\n                this.occupied--;\n                return this.nonSentinel(result);\n            }\n            if (bucket.three == null)\n            {\n                return null;\n            }\n            if (bucket.three instanceof ChainedBucket)\n            {\n                oldBucket = bucket;\n                continue;\n            }\n            if (this.nonNullTableObjectEquals(bucket.three, key))\n            {\n                Object result = bucket.three;\n                bucket.three = bucket.removeLast(3);\n                this.occupied--;\n                return this.nonSentinel(result);\n            }\n            return null;\n        }\n        while (true);\n    }\n    private T nonSentinel(Object key)\n    {\n        return key == NULL_KEY ? null : (T) key;\n    }\n    private static Object toSentinelIfNull(Object key)\n    {\n        if (key == null)\n        {\n            return NULL_KEY;\n        }\n        return key;\n    }\n    private boolean nonNullTableObjectEquals(Object cur, T key)\n    {\n        return cur == key || (cur == NULL_KEY ? key == null : cur.equals(key));\n    }\n    @Override\n    @Beta\n    public ParallelUnsortedSetIterable<T> asParallel(ExecutorService executorService, int batchSize)\n    {\n        if (executorService == null)\n        {\n            throw new NullPointerException();\n        }\n        if (batchSize < 1)\n        {\n            throw new IllegalArgumentException();\n        }\n        return new UnifiedSetParallelUnsortedIterable(executorService, batchSize);\n    }\n    private final class UnifiedUnsortedSetBatch extends AbstractBatch<T> implements RootUnsortedSetBatch<T>\n    {\n        private final int chunkStartIndex;\n        private final int chunkEndIndex;\n        private UnifiedUnsortedSetBatch(int chunkStartIndex, int chunkEndIndex)\n        {\n            this.chunkStartIndex = chunkStartIndex;\n            this.chunkEndIndex = chunkEndIndex;\n        }\n        @Override\n        public void forEach(Procedure<? super T> procedure)\n        {\n            UnifiedSet.this.each(procedure, this.chunkStartIndex, this.chunkEndIndex);\n        }\n        @Override\n        public boolean anySatisfy(Predicate<? super T> predicate)\n        {\n            return UnifiedSet.this.shortCircuit(predicate, true, true, false, this.chunkStartIndex, this.chunkEndIndex);\n        }\n        @Override\n        public boolean allSatisfy(Predicate<? super T> predicate)\n        {\n            return UnifiedSet.this.shortCircuit(predicate, false, false, true, this.chunkStartIndex, this.chunkEndIndex);\n        }\n        @Override\n        public T detect(Predicate<? super T> predicate)\n        {\n            return UnifiedSet.this.detect(predicate, this.chunkStartIndex, this.chunkEndIndex);\n        }\n        @Override\n        public UnsortedSetBatch<T> select(Predicate<? super T> predicate)\n        {\n            return new SelectUnsortedSetBatch<>(this, predicate);\n        }\n        @Override\n        public <V> UnsortedBagBatch<V> collect(Function<? super T, ? extends V> function)\n        {\n            return new CollectUnsortedBagBatch<>(this, function);\n        }\n<fim_suffix>        @Override\n        public <V> UnsortedBagBatch<V> flatCollect(Function<? super T, ? extends Iterable<V>> function)\n        {\n            return new FlatCollectUnsortedBagBatch<>(this, function);\n        }<fim_middle>// function below has no smell\n"}