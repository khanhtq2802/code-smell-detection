{"text": "<fim_prefix>\t\t\t\tbreak;\n\t\t\t  case SYSDUMMY1_CATALOG_NUM:\n\t\t\t\tretval = new TabInfoImpl(new SYSDUMMY1RowFactory(\n\t\t\t\t\t\t\t\t\t\t\t\t luuidFactory, exFactory, dvf));\t\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t  case SYSTABLEPERMS_CATALOG_NUM:\n\t\t\t\tretval = new TabInfoImpl(new SYSTABLEPERMSRowFactory(\n\t\t\t\t\t\t\t\t\t\t\t\t luuidFactory, exFactory, dvf));\t\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t  case SYSCOLPERMS_CATALOG_NUM:\n\t\t\t\tretval = new TabInfoImpl(new SYSCOLPERMSRowFactory(\n\t\t\t\t\t\t\t\t\t\t\t\t luuidFactory, exFactory, dvf));\t\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t  case SYSROUTINEPERMS_CATALOG_NUM:\n\t\t\t\tretval = new TabInfoImpl(new SYSROUTINEPERMSRowFactory(\n\t\t\t\t\t\t\t\t\t\t\t\t luuidFactory, exFactory, dvf));\t\t\t\t\t \n\t\t\t\tbreak;\n\t\t\t  case SYSROLES_CATALOG_NUM:\n\t\t\t\tretval = new TabInfoImpl(new SYSROLESRowFactory(\n\t\t\t\t\t\t\t\t\t\t\t luuidFactory, exFactory, dvf));\n\t\t\t\tbreak;\n              case SYSSEQUENCES_CATALOG_NUM:\n\t\t\t\tretval = new TabInfoImpl(new SYSSEQUENCESRowFactory(\n\t\t\t\t\t\t\t\t\t\t\t luuidFactory, exFactory, dvf));\n\t\t\t\tbreak;\n              case SYSPERMS_CATALOG_NUM:\n\t\t\t\tretval = new TabInfoImpl(new SYSPERMSRowFactory(\n\t\t\t\t\t\t\t\t\t\t\t luuidFactory, exFactory, dvf));\n\t\t\t\tbreak;            \n              case SYSUSERS_CATALOG_NUM:\n\t\t\t\tretval = new TabInfoImpl(new SYSUSERSRowFactory(\n\t\t\t\t\t\t\t\t\t\t\t luuidFactory, exFactory, dvf));\n\t\t\t\tbreak;            \n            }\n\t\t\tinitSystemIndexVariables(retval);\n\t\t\tnoncoreInfo[nonCoreNum] = retval;\n\t\t}\n\t\treturn retval;\n\t}\n\tprotected void initSystemIndexVariables(TabInfoImpl ti)\n\t\t\t\t\t\tthrows StandardException\n\t{\n\t\tint numIndexes = ti.getNumberOfIndexes();\n        for (int indexCtr = 0; indexCtr < numIndexes; indexCtr++)\n        {\n            initSystemIndexVariables(ti, indexCtr);\n        }\n\t}\n\t// Expected to be called only during boot time, so no synchronization.\n\tprivate void clearNoncoreTable(int nonCoreNum)\n\t{\n\t\tnoncoreInfo[nonCoreNum] = null;\n\t}\n\t/**\n\t  *\tFinishes building a TabInfoImpl if it hasn't already been faulted in.\n\t  *\tNOP if TabInfoImpl has already been faulted in.\n\t  *\n\t  *\t@param\tti\tTabInfoImpl to fault in.\n\t  *\n\t  * @exception StandardException\t\tThrown on error\n\t  */\n    private void faultInTabInfo(TabInfoImpl ti)\n\t\tthrows StandardException\n\t{\n\t\tint\t\tnumIndexes;\n\t\t/* Most of the time, the noncoreInfo will be complete.\n\t\t * It's okay to do an unsynchronized check and return\n\t\t * if it is complete, since it never becomes \"un-complete\".\n\t\t * If we change the code, for some reason, to allow\n\t\t * it to become \"un-complete\" after being complete,\n\t\t * then we will have to do a synchronized check here\n\t\t * as well.\n\t\t */\n\t\tif (ti.isComplete())\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t/* The completing of the noncoreInfo entry must be synchronized. \n\t\t * NOTE: We are assuming that we will not access a different\n\t\t * noncoreInfo in the course of completing of this noncoreInfo,\n\t\t * otherwise a deadlock could occur.\n\t\t */\n\t\tsynchronized(ti)\n\t\t{\n\t\t\t/* Now that we can run, the 1st thing that we must do\n\t\t\t * is to verify that we still need to complete the\n\t\t\t * object.  (We may have been blocked on another user\n\t\t\t * doing the same.)\n\t\t\t */\n\t\t\tif (ti.isComplete())\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tTableDescriptor td = getTableDescriptor(ti.getTableName(),\n\t\t\t\t\t\t\t\t\t\t\t\t\tgetSystemSchemaDescriptor(), null);\n\t\t\t// It's possible that the system table is not there right\n\t\t\t// now. This can happen, for example, if we're in the\n\t\t\t// process of upgrading a source or target to Xena, in \n\t\t\t// which case SYSSYNCINSTANTS is dropped and re-created.\n\t\t\t// Just return in this case, so we don't get a null pointer\n\t\t\t// exception.\n\t\t\tif (td == null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tConglomerateDescriptor cd = null;\n\t\t\tConglomerateDescriptor[] cds = td.getConglomerateDescriptors();\n\t\t\t/* Init the heap conglomerate here */\n\t\t\tfor (int index = 0; index < cds.length; index++)\n\t\t\t{\n\t\t\t\tcd = cds[index];\n\t\t\t\tif (! cd.isIndex())\n\t\t\t\t{\n\t\t\t\t\tti.setHeapConglomerate(cd.getConglomerateNumber());\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (SanityManager.DEBUG)\n\t\t\t{\n\t\t\t\tif (cd == null)\n\t\t\t\t{\n\t\t\t\t\tSanityManager.THROWASSERT(\"No heap conglomerate found for \" \n\t\t\t\t\t\t+ ti.getTableName());\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* Initialize the index conglomerates */\n\t\t\tnumIndexes = ti.getCatalogRowFactory().getNumIndexes();\n\t\t\tif (numIndexes == 0)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t/* For each index, we get its id from the CDL */\n\t\t\tConglomerateDescriptor icd = null;\n\t\t\tint\tindexCount = 0;\n\t\t\tfor (int index = 0; index < cds.length; index++)\n\t\t\t{\n\t\t\t\ticd = cds[index];\n\t\t\t\tif (icd.isIndex())\n\t\t\t\t{\n\t\t\t\t\tti.setIndexConglomerate(icd);\n\t\t\t\t\tindexCount++;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (SanityManager.DEBUG)\n\t\t\t{\n\t\t\t\tif (indexCount != ti.getCatalogRowFactory().getNumIndexes())\n\t\t\t\t{\n\t\t\t\t\tSanityManager.THROWASSERT(\"Number of indexes found (\" + indexCount + \n\t\t\t\t\t\t\") does not match the number expected (\" +\n\t\t\t\t\t\tti.getCatalogRowFactory().getNumIndexes() + \")\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * Get an index row based on a row from the heap.\n\t *\n\t * @param irg\t\tIndexRowGenerator to use\n\t * @param rl\t\tRowLocation for heap\n\t * @param heapRow\tRow from the heap\n\t *\n\t * @return ExecIndexRow\tIndex row.\n\t *\n\t * @exception StandardException\t\tThrown on error\n\t */\n<fim_suffix>\tpublic static\tExecIndexRow getIndexRowFromHeapRow(IndexRowGenerator irg,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tRowLocation rl,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tExecRow heapRow)\n\t\tthrows StandardException\n\t{\n\t\tExecIndexRow\t\tindexRow;\n\t\tindexRow = irg.getIndexRowTemplate();\n\t\t// Get an index row based on the base row\n\t\tirg.getIndexRow(heapRow, rl, indexRow, (FormatableBitSet) null);\n\t\treturn indexRow;\n\t}<fim_middle>// function below has no smell\n"}