{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.qpid.jms.provider;\n\nimport java.util.Map;\n\n/**\n * Factory for provider future instances that will create specific versions based on\n * configuration.\n */\npublic abstract class ProviderFutureFactory {\n\n    public static final String PROVIDER_FUTURE_TYPE_KEY = \"futureType\";\n\n    private static final String OS_NAME = System.getProperty(\"os.name\");\n    private static final String WINDOWS_OS_PREFIX = \"Windows\";\n    private static final boolean IS_WINDOWS = isOsNameMatch(OS_NAME, WINDOWS_OS_PREFIX);\n\n    private static final String CONSERVATIVE = \"conservative\";\n    private static final String BALANCED = \"balanced\";\n    private static final String PROGRESSIVE = \"progressive\";\n\n    /**\n     * Create a new Provider\n     *\n     * @param providerOptions\n     * \t\tConfiguration options to be consumed by this factory create method\n     *\n     * @return a new ProviderFutureFactory that will be used to create the desired future types.\n     */\n    public static ProviderFutureFactory create(Map<String, String> providerOptions) {\n        String futureTypeKey = providerOptions.remove(PROVIDER_FUTURE_TYPE_KEY);\n\n        if (futureTypeKey == null || futureTypeKey.isEmpty()) {\n            if (Runtime.getRuntime().availableProcessors() < 4) {\n                return new ConservativeProviderFutureFactory();\n            } else if (isWindows()) {\n                return new BalancedProviderFutureFactory();\n            } else {\n                return new ProgressiveProviderFutureFactory();\n            }\n        }\n\n        switch (futureTypeKey.toLowerCase()) {\n            case CONSERVATIVE:\n                return new ConservativeProviderFutureFactory();\n            case BALANCED:\n                return new BalancedProviderFutureFactory();\n            case PROGRESSIVE:\n                return new ProgressiveProviderFutureFactory();\n            default:\n                throw new IllegalArgumentException(\n                    \"No ProviderFuture implementation with name \" + futureTypeKey + \" found\");\n        }\n    }\n\n    /**\n     * @return a new ProviderFuture instance.\n     */\n    public abstract ProviderFuture createFuture();\n\n    /**\n     * @param synchronization\n     * \t\tThe {@link ProviderSynchronization} to assign to the returned {@link ProviderFuture}.\n     *\n     * @return a new ProviderFuture instance.\n     */\n    public abstract ProviderFuture createFuture(ProviderSynchronization synchronization);\n\n    /**\n     * @return a ProviderFuture that treats failures as success calls that simply complete the operation.\n     */\n    public abstract ProviderFuture createUnfailableFuture();\n\n    //----- Internal support methods -----------------------------------------//\n\n    private static boolean isWindows() {\n        return IS_WINDOWS;\n    }\n\n    private static boolean isOsNameMatch(final String currentOSName, final String osNamePrefix) {\n        if (currentOSName == null || currentOSName.isEmpty()) {\n            return false;\n        }\n\n        return currentOSName.startsWith(osNamePrefix);\n    }\n\n    //----- ProviderFutureFactory implementation -----------------------------//\n\n<fim_suffix>    private static class ConservativeProviderFutureFactory extends ProviderFutureFactory {\n\n        @Override\n        public ProviderFuture createFuture() {\n            return new ConservativeProviderFuture();\n        }\n\n        @Override\n        public ProviderFuture createFuture(ProviderSynchronization synchronization) {\n            return new ConservativeProviderFuture(synchronization);\n        }\n\n        @Override\n        public ProviderFuture createUnfailableFuture() {\n            return new ConservativeProviderFuture() {\n\n                @Override\n                public void onFailure(Throwable t) {\n                    this.onSuccess();\n                }\n            };\n        }\n    }\n\n    private static class BalancedProviderFutureFactory extends ProviderFutureFactory {\n\n        @Override\n        public ProviderFuture createFuture() {\n            return new BalancedProviderFuture();\n        }\n\n        @Override\n        public ProviderFuture createFuture(ProviderSynchronization synchronization) {\n            return new BalancedProviderFuture(synchronization);\n        }\n\n        @Override\n        public ProviderFuture createUnfailableFuture() {\n            return new BalancedProviderFuture() {\n\n                @Override\n                public void onFailure(Throwable t) {\n                    this.onSuccess();\n                }\n            };\n        }\n    }\n\n    private static class ProgressiveProviderFutureFactory extends ProviderFutureFactory {\n\n        @Override\n        public ProviderFuture createFuture() {\n            return new ProgressiveProviderFuture();\n        }\n\n        @Override\n        public ProviderFuture createFuture(ProviderSynchronization synchronization) {\n            return new ProgressiveProviderFuture(synchronization);\n        }\n\n        @Override\n        public ProviderFuture createUnfailableFuture() {\n            return new ProgressiveProviderFuture() {\n\n                @Override\n                public void onFailure(Throwable t) {\n                    this.onSuccess();\n                }\n            };\n        }\n    }\n}<fim_middle>// class below has no smell\n"}