{"text": "<fim_prefix>    if (cp < 0x20) {\n      return ((cp != 0x9) && (cp != 0xa) && (cp != 0xd));\n    } else if ((0xd7ff < cp) && (cp < 0xe000)) {\n      return true;\n    } else if ((cp == 0xfffe) || (cp == 0xffff)) {\n      return true;\n    } else if (cp == 0x5c) {\n      // we mangle backslash to simplify decoding... it's\n      // easier if backslashes always begin mangled sequences. \n      return true;\n    }\n    return false;\n  }\n  private static final int NUM_SLASH_POSITIONS = 4;\n  private static String mangleCodePoint(int cp) {\n    return String.format(\"\\\\%0\" + NUM_SLASH_POSITIONS + \"x;\", cp);\n  }\n  private static String codePointToEntityRef(int cp) {\n    switch (cp) {\n      case '&':\n        return \"&amp;\";\n      case '\\\"':\n        return \"&quot;\";\n      case '\\'':\n        return \"&apos;\";\n      case '<':\n        return \"&lt;\";\n      case '>':\n        return \"&gt;\";\n      default:\n        return null;\n    }\n  }\n  /**\n   * Mangle a string so that it can be represented in an XML document.\n   * \n   * There are three kinds of code points in XML:\n   * - Those that can be represented normally,\n   * - Those that have to be escaped (for example, &amp; must be represented\n   *     as {@literal &amp;})\n   * - Those that cannot be represented at all in XML.\n   *\n   * The built-in SAX functions will handle the first two types for us just\n   * fine.  However, sometimes we come across a code point of the third type.\n   * In this case, we have to mangle the string in order to represent it at\n   * all.  We also mangle backslash to avoid confusing a backslash in the\n   * string with part our escape sequence.\n   * \n   * The encoding used here is as follows: an illegal code point is\n   * represented as '\\ABCD;', where ABCD is the hexadecimal value of \n   * the code point.\n   *\n   * @param str     The input string.\n   *\n   * @return        The mangled string.\n   */\n  public static String mangleXmlString(String str, boolean createEntityRefs) {\n    final StringBuilder bld = new StringBuilder();\n    final int length = str.length();\n    for (int offset = 0; offset < length; ) {\n       final int cp = str.codePointAt(offset);\n       final int len = Character.charCount(cp);\n       if (codePointMustBeMangled(cp)) {\n         bld.append(mangleCodePoint(cp));\n       } else {\n         String entityRef = null;\n         if (createEntityRefs) {\n           entityRef = codePointToEntityRef(cp);\n         }\n         if (entityRef != null) {\n           bld.append(entityRef);\n         } else {\n           for (int i = 0; i < len; i++) {\n             bld.append(str.charAt(offset + i));\n           }\n         }\n       }\n       offset += len;\n    }\n    return bld.toString();\n  }\n  /**\n   * Demangle a string from an XML document.\n   * See {@link #mangleXmlString(String, boolean)} for a description of the\n   * mangling format.\n   *\n   * @param str    The string to be demangled.\n   * \n   * @return       The unmangled string\n   * @throws       UnmanglingError if the input is malformed.\n   */\n  public static String unmangleXmlString(String str, boolean decodeEntityRefs)\n        throws UnmanglingError {\n    int slashPosition = -1;\n    String escapedCp = \"\";\n    StringBuilder bld = new StringBuilder();\n    StringBuilder entityRef = null;\n    for (int i = 0; i < str.length(); i++) {\n      char ch = str.charAt(i);\n      if (entityRef != null) {\n        entityRef.append(ch);\n        if (ch == ';') {\n          String e = entityRef.toString();\n          if (e.equals(\"&quot;\")) {\n            bld.append(\"\\\"\");\n          } else if (e.equals(\"&apos;\")) {\n            bld.append(\"\\'\");\n          } else if (e.equals(\"&amp;\")) {\n            bld.append(\"&\");\n          } else if (e.equals(\"&lt;\")) {\n            bld.append(\"<\");\n          } else if (e.equals(\"&gt;\")) {\n            bld.append(\">\");\n          } else {\n            throw new UnmanglingError(\"Unknown entity ref \" + e);\n          }\n          entityRef = null;\n        }\n      } else  if ((slashPosition >= 0) && (slashPosition < NUM_SLASH_POSITIONS)) {\n        escapedCp += ch;\n        ++slashPosition;\n      } else if (slashPosition == NUM_SLASH_POSITIONS) {\n        if (ch != ';') {\n          throw new UnmanglingError(\"unterminated code point escape: \" +\n              \"expected semicolon at end.\");\n        }\n        try {\n          bld.appendCodePoint(Integer.parseInt(escapedCp, 16));\n        } catch (NumberFormatException e) {\n          throw new UnmanglingError(\"error parsing unmangling escape code\", e);\n        }\n        escapedCp = \"\";\n        slashPosition = -1;\n      } else if (ch == '\\\\') {\n        slashPosition = 0;\n      } else {\n        boolean startingEntityRef = false;\n        if (decodeEntityRefs) {\n          startingEntityRef = (ch == '&');\n        }\n        if (startingEntityRef) {\n          entityRef = new StringBuilder();\n          entityRef.append(\"&\");\n        } else {\n          bld.append(ch);\n        }\n      }\n    }\n    if (entityRef != null) {\n      throw new UnmanglingError(\"unterminated entity ref starting with \" +\n          entityRef.toString());\n    } else if (slashPosition != -1) {\n      throw new UnmanglingError(\"unterminated code point escape: string \" +\n          \"broke off in the middle\");\n    }\n    return bld.toString();\n  }\n  /**\n   * Add a SAX tag with a string inside.\n   *\n   * @param contentHandler     the SAX content handler\n   * @param tag                the element tag to use  \n   * @param val                the string to put inside the tag\n   */\n  public static void addSaxString(ContentHandler contentHandler,\n      String tag, String val) throws SAXException {\n    contentHandler.startElement(\"\", \"\", tag, new AttributesImpl());\n    char c[] = mangleXmlString(val, false).toCharArray();\n    contentHandler.characters(c, 0, c.length);\n    contentHandler.endElement(\"\", \"\", tag);\n  }\n  /**\n   * Represents a bag of key-value pairs encountered during parsing an XML\n   * file.\n   */\n  static public class Stanza {\n    private final TreeMap<String, LinkedList <Stanza > > subtrees;\n    /** The unmangled value of this stanza. */\n    private String value;\n    public Stanza() {\n      subtrees = new TreeMap<String, LinkedList <Stanza > >();\n      value = \"\";\n    }\n    public void setValue(String value) {\n      this.value = value;\n    }\n    public String getValue() {\n      return this.value;\n    }\n    /** \n     * Discover if a stanza has a given entry.\n     *\n     * @param name        entry to look for\n     * \n     * @return            true if the entry was found\n     */\n    public boolean hasChildren(String name) {\n      return subtrees.containsKey(name);\n    }\n    /** \n     * Pull an entry from a stanza.\n     *\n     * @param name        entry to look for\n     * \n     * @return            the entry\n     */\n    public List<Stanza> getChildren(String name) throws InvalidXmlException {\n      LinkedList <Stanza> children = subtrees.get(name);\n      if (children == null) {\n        throw new InvalidXmlException(\"no entry found for \" + name);\n      }\n      return children;\n    }\n    /** \n     * Pull a string entry from a stanza.\n     *\n     * @param name        entry to look for\n     * \n     * @return            the entry\n     */\n    public String getValue(String name) throws InvalidXmlException {\n      String ret = getValueOrNull(name);\n      if (ret == null) {\n        throw new InvalidXmlException(\"no entry found for \" + name);\n      }\n      return ret;\n    }\n    /** \n     * Pull a string entry from a stanza, or null.\n     *\n     * @param name        entry to look for\n     * \n     * @return            the entry, or null if it was not found.\n     */\n<fim_suffix>    public String getValueOrNull(String name) throws InvalidXmlException {\n      if (!subtrees.containsKey(name)) {\n        return null;\n      }\n      LinkedList <Stanza> l = subtrees.get(name);\n      if (l.size() != 1) {\n        throw new InvalidXmlException(\"More than one value found for \" + name);\n      }\n      return l.get(0).getValue();\n    }<fim_middle>// function below has no smell\n"}