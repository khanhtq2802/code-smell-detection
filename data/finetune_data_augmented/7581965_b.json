{"text": "<fim_prefix>\t\t\t\t\t\t// Prefer regular method over bridge...\n\t\t\t\t\t\ttargetMethod = method;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// Additional candidate with same length\n\t\t\t\t\t\tnumMethodsFoundWithCurrentMinimumArgs++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (numMethodsFoundWithCurrentMinimumArgs > 1) {\n\t\t\tthrow new IllegalArgumentException(\"Cannot resolve method '\" + methodName +\n\t\t\t\t\t\"' to a unique method. Attempted to resolve to overloaded method with \" +\n\t\t\t\t\t\"the least number of parameters but there were \" +\n\t\t\t\t\tnumMethodsFoundWithCurrentMinimumArgs + \" candidates.\");\n\t\t}\n\t\treturn targetMethod;\n\t}\n\t/**\n\t * Parse a method signature in the form {@code methodName[([arg_list])]},\n\t * where {@code arg_list} is an optional, comma-separated list of fully-qualified\n\t * type names, and attempts to resolve that signature against the supplied {@code Class}.\n\t * <p>When not supplying an argument list ({@code methodName}) the method whose name\n\t * matches and has the least number of parameters will be returned. When supplying an\n\t * argument type list, only the method whose name and argument types match will be returned.\n\t * <p>Note then that {@code methodName} and {@code methodName()} are <strong>not</strong>\n\t * resolved in the same way. The signature {@code methodName} means the method called\n\t * {@code methodName} with the least number of arguments, whereas {@code methodName()}\n\t * means the method called {@code methodName} with exactly 0 arguments.\n\t * <p>If no method can be found, then {@code null} is returned.\n\t * @param signature the method signature as String representation\n\t * @param clazz the class to resolve the method signature against\n\t * @return the resolved Method\n\t * @see #findMethod\n\t * @see #findMethodWithMinimalParameters\n\t */\n\t@Nullable\n\tpublic static Method resolveSignature(String signature, Class<?> clazz) {\n\t\tAssert.hasText(signature, \"'signature' must not be empty\");\n\t\tAssert.notNull(clazz, \"Class must not be null\");\n\t\tint startParen = signature.indexOf('(');\n\t\tint endParen = signature.indexOf(')');\n\t\tif (startParen > -1 && endParen == -1) {\n\t\t\tthrow new IllegalArgumentException(\"Invalid method signature '\" + signature +\n\t\t\t\t\t\"': expected closing ')' for args list\");\n\t\t}\n\t\telse if (startParen == -1 && endParen > -1) {\n\t\t\tthrow new IllegalArgumentException(\"Invalid method signature '\" + signature +\n\t\t\t\t\t\"': expected opening '(' for args list\");\n\t\t}\n\t\telse if (startParen == -1) {\n\t\t\treturn findMethodWithMinimalParameters(clazz, signature);\n\t\t}\n\t\telse {\n\t\t\tString methodName = signature.substring(0, startParen);\n\t\t\tString[] parameterTypeNames =\n\t\t\t\t\tStringUtils.commaDelimitedListToStringArray(signature.substring(startParen + 1, endParen));\n\t\t\tClass<?>[] parameterTypes = new Class<?>[parameterTypeNames.length];\n\t\t\tfor (int i = 0; i < parameterTypeNames.length; i++) {\n\t\t\t\tString parameterTypeName = parameterTypeNames[i].trim();\n\t\t\t\ttry {\n\t\t\t\t\tparameterTypes[i] = ClassUtils.forName(parameterTypeName, clazz.getClassLoader());\n\t\t\t\t}\n\t\t\t\tcatch (Throwable ex) {\n\t\t\t\t\tthrow new IllegalArgumentException(\"Invalid method signature: unable to resolve type [\" +\n\t\t\t\t\t\t\tparameterTypeName + \"] for argument \" + i + \". Root cause: \" + ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn findMethod(clazz, methodName, parameterTypes);\n\t\t}\n\t}\n\t/**\n\t * Retrieve the JavaBeans {@code PropertyDescriptor}s of a given class.\n\t * @param clazz the Class to retrieve the PropertyDescriptors for\n\t * @return an array of {@code PropertyDescriptors} for the given class\n\t * @throws BeansException if PropertyDescriptor look fails\n\t */\n\tpublic static PropertyDescriptor[] getPropertyDescriptors(Class<?> clazz) throws BeansException {\n\t\tCachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz);\n\t\treturn cr.getPropertyDescriptors();\n\t}\n\t/**\n\t * Retrieve the JavaBeans {@code PropertyDescriptors} for the given property.\n\t * @param clazz the Class to retrieve the PropertyDescriptor for\n\t * @param propertyName the name of the property\n\t * @return the corresponding PropertyDescriptor, or {@code null} if none\n\t * @throws BeansException if PropertyDescriptor lookup fails\n\t */\n\t@Nullable\n\tpublic static PropertyDescriptor getPropertyDescriptor(Class<?> clazz, String propertyName)\n\t\t\tthrows BeansException {\n\t\tCachedIntrospectionResults cr = CachedIntrospectionResults.forClass(clazz);\n\t\treturn cr.getPropertyDescriptor(propertyName);\n\t}\n\t/**\n\t * Find a JavaBeans {@code PropertyDescriptor} for the given method,\n\t * with the method either being the read method or the write method for\n\t * that bean property.\n\t * @param method the method to find a corresponding PropertyDescriptor for,\n\t * introspecting its declaring class\n\t * @return the corresponding PropertyDescriptor, or {@code null} if none\n\t * @throws BeansException if PropertyDescriptor lookup fails\n\t */\n\t@Nullable\n\tpublic static PropertyDescriptor findPropertyForMethod(Method method) throws BeansException {\n\t\treturn findPropertyForMethod(method, method.getDeclaringClass());\n\t}\n\t/**\n\t * Find a JavaBeans {@code PropertyDescriptor} for the given method,\n\t * with the method either being the read method or the write method for\n\t * that bean property.\n\t * @param method the method to find a corresponding PropertyDescriptor for\n\t * @param clazz the (most specific) class to introspect for descriptors\n\t * @return the corresponding PropertyDescriptor, or {@code null} if none\n\t * @throws BeansException if PropertyDescriptor lookup fails\n\t * @since 3.2.13\n\t */\n\t@Nullable\n\tpublic static PropertyDescriptor findPropertyForMethod(Method method, Class<?> clazz) throws BeansException {\n\t\tAssert.notNull(method, \"Method must not be null\");\n\t\tPropertyDescriptor[] pds = getPropertyDescriptors(clazz);\n\t\tfor (PropertyDescriptor pd : pds) {\n\t\t\tif (method.equals(pd.getReadMethod()) || method.equals(pd.getWriteMethod())) {\n\t\t\t\treturn pd;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\t/**\n\t * Find a JavaBeans PropertyEditor following the 'Editor' suffix convention\n\t * (e.g. \"mypackage.MyDomainClass\" -> \"mypackage.MyDomainClassEditor\").\n\t * <p>Compatible to the standard JavaBeans convention as implemented by\n\t * {@link java.beans.PropertyEditorManager} but isolated from the latter's\n\t * registered default editors for primitive types.\n\t * @param targetType the type to find an editor for\n\t * @return the corresponding editor, or {@code null} if none found\n\t */\n<fim_suffix>\t@Nullable\n\tpublic static PropertyEditor findEditorByConvention(@Nullable Class<?> targetType) {\n\t\tif (targetType == null || targetType.isArray() || unknownEditorTypes.contains(targetType)) {\n\t\t\treturn null;\n\t\t}\n\t\tClassLoader cl = targetType.getClassLoader();\n\t\tif (cl == null) {\n\t\t\ttry {\n\t\t\t\tcl = ClassLoader.getSystemClassLoader();\n\t\t\t\tif (cl == null) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Throwable ex) {\n\t\t\t\t// e.g. AccessControlException on Google App Engine\n\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\tlogger.debug(\"Could not access system ClassLoader: \" + ex);\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tString editorName = targetType.getName() + \"Editor\";\n\t\ttry {\n\t\t\tClass<?> editorClass = cl.loadClass(editorName);\n\t\t\tif (!PropertyEditor.class.isAssignableFrom(editorClass)) {\n\t\t\t\tif (logger.isInfoEnabled()) {\n\t\t\t\t\tlogger.info(\"Editor class [\" + editorName +\n\t\t\t\t\t\t\t\"] does not implement [java.beans.PropertyEditor] interface\");\n\t\t\t\t}\n\t\t\t\tunknownEditorTypes.add(targetType);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn (PropertyEditor) instantiateClass(editorClass);\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\tif (logger.isTraceEnabled()) {\n\t\t\t\tlogger.trace(\"No property editor [\" + editorName + \"] found for type \" +\n\t\t\t\t\t\ttargetType.getName() + \" according to 'Editor' suffix convention\");\n\t\t\t}\n\t\t\tunknownEditorTypes.add(targetType);\n\t\t\treturn null;\n\t\t}\n\t}<fim_middle>// function below is long method and feature envy\n"}