{"text": "<fim_prefix>    */\n   @Override\n   public void flowControl(final int messageBytes, final boolean discountSlowConsumer) throws ActiveMQException {\n      if (clientWindowSize >= 0) {\n         creditsToSend += messageBytes;\n         if (creditsToSend >= clientWindowSize) {\n            if (clientWindowSize == 0 && discountSlowConsumer) {\n               if (logger.isTraceEnabled()) {\n                  logger.trace(this + \"::FlowControl::Sending \" + creditsToSend + \" -1, for slow consumer\");\n               }\n               // sending the credits - 1 initially send to fire the slow consumer, or the slow consumer would be\n               // always buffering one after received the first message\n               final int credits = creditsToSend - 1;\n               creditsToSend = 0;\n               if (credits > 0) {\n                  sendCredits(credits);\n               }\n            } else {\n               if (logger.isDebugEnabled()) {\n                  logger.debug(\"Sending \" + messageBytes + \" from flow-control\");\n               }\n               final int credits = creditsToSend;\n               creditsToSend = 0;\n               if (credits > 0) {\n                  sendCredits(credits);\n               }\n            }\n         }\n      }\n   }\n   // Public\n   // ---------------------------------------------------------------------------------------\n   // Package protected\n   // ---------------------------------------------------------------------------------------\n   // Protected\n   // ---------------------------------------------------------------------------------------\n   // Private\n   // ---------------------------------------------------------------------------------------\n   /**\n    * Sending an initial credit for slow consumers\n    */\n   private void startSlowConsumer() {\n      if (logger.isTraceEnabled()) {\n         logger.trace(this + \"::Sending 1 credit to start delivering of one message to slow consumer\");\n      }\n      sendCredits(1);\n      try {\n         // We use an executor here to guarantee the messages will arrive in order.\n         // However when starting a slow consumer, we have to guarantee the credit was sent before we can perform any\n         // operations like forceDelivery\n         pendingFlowControl.await(10, TimeUnit.SECONDS);\n      } catch (InterruptedException e) {\n         // will just ignore and forward the ignored\n         Thread.currentThread().interrupt();\n      }\n   }\n   private void resetIfSlowConsumer() {\n      if (clientWindowSize == 0) {\n         sendCredits(0);\n         // If resetting a slow consumer, we need to wait the execution\n         final CountDownLatch latch = new CountDownLatch(1);\n         flowControlExecutor.execute(new Runnable() {\n            @Override\n            public void run() {\n               latch.countDown();\n            }\n         });\n         try {\n            latch.await(10, TimeUnit.SECONDS);\n         } catch (InterruptedException e) {\n            throw new ActiveMQInterruptedException(e);\n         }\n      }\n   }\n   private void requeueExecutors() {\n      for (int i = 0; i < buffer.size(); i++) {\n         queueExecutor();\n      }\n   }\n   private void queueExecutor() {\n      if (logger.isTraceEnabled()) {\n         logger.trace(this + \"::Adding Runner on Executor for delivery\");\n      }\n      sessionExecutor.execute(runner);\n   }\n   /**\n    * @param credits\n    */\n   private void sendCredits(final int credits) {\n      pendingFlowControl.countUp();\n      flowControlExecutor.execute(new Runnable() {\n         @Override\n         public void run() {\n            try {\n               sessionContext.sendConsumerCredits(ClientConsumerImpl.this, credits);\n            } finally {\n               pendingFlowControl.countDown();\n            }\n         }\n      });\n   }\n   private void waitForOnMessageToComplete(boolean waitForOnMessage) {\n      if (handler == null) {\n         return;\n      }\n      if (!waitForOnMessage || Thread.currentThread() == onMessageThread) {\n         // If called from inside onMessage then return immediately - otherwise would block\n         return;\n      }\n      FutureLatch future = new FutureLatch();\n      sessionExecutor.execute(future);\n      boolean ok = future.await(ClientConsumerImpl.CLOSE_TIMEOUT_MILLISECONDS);\n      if (!ok) {\n         ActiveMQClientLogger.LOGGER.timeOutWaitingForProcessing();\n      }\n   }\n   private void checkClosed() throws ActiveMQException {\n      if (closed) {\n         throw ActiveMQClientMessageBundle.BUNDLE.consumerClosed();\n      }\n   }\n   private void callOnMessage() throws Exception {\n      if (closing || stopped) {\n         return;\n      }\n      session.workDone();\n      // We pull the message from the buffer from inside the Runnable so we can ensure priority\n      // ordering. If we just added a Runnable with the message to the executor immediately as we get it\n      // we could not do that\n      ClientMessageInternal message;\n      // Must store handler in local variable since might get set to null\n      // otherwise while this is executing and give NPE when calling onMessage\n      MessageHandler theHandler = handler;\n      if (theHandler != null) {\n         if (rateLimiter != null) {\n            rateLimiter.limit();\n         }\n         failedOver = false;\n         synchronized (this) {\n            message = buffer.poll();\n         }\n         if (message != null) {\n            if (message.containsProperty(ClientConsumerImpl.FORCED_DELIVERY_MESSAGE)) {\n               //Ignore, this could be a relic from a previous receiveImmediate();\n               return;\n            }\n            boolean expired = message.isExpired();\n            flowControlBeforeConsumption(message);\n            if (!expired) {\n               if (logger.isTraceEnabled()) {\n                  logger.trace(this + \"::Calling handler.onMessage\");\n               }\n               final ClassLoader originalLoader = AccessController.doPrivileged(new PrivilegedAction<ClassLoader>() {\n                  @Override\n                  public ClassLoader run() {\n                     ClassLoader originalLoader = Thread.currentThread().getContextClassLoader();\n                     Thread.currentThread().setContextClassLoader(contextClassLoader);\n                     return originalLoader;\n                  }\n               });\n               onMessageThread = Thread.currentThread();\n               try {\n                  theHandler.onMessage(message);\n               } finally {\n                  try {\n                     AccessController.doPrivileged(new PrivilegedAction<Object>() {\n                        @Override\n                        public Object run() {\n                           Thread.currentThread().setContextClassLoader(originalLoader);\n                           return null;\n                        }\n                     });\n                  } catch (Exception e) {\n                     ActiveMQClientLogger.LOGGER.failedPerformPostActionsOnMessage(e);\n                  }\n                  onMessageThread = null;\n               }\n               if (logger.isTraceEnabled()) {\n                  logger.trace(this + \"::Handler.onMessage done\");\n               }\n               if (message.isLargeMessage()) {\n                  message.discardBody();\n               }\n            } else {\n               session.expire(this, message);\n            }\n            // If slow consumer, we need to send 1 credit to make sure we get another message\n            if (clientWindowSize == 0) {\n               startSlowConsumer();\n            }\n         }\n      }\n   }\n   /**\n    * @param message\n    * @throws ActiveMQException\n    */\n   private void flowControlBeforeConsumption(final ClientMessageInternal message) throws ActiveMQException {\n      // Chunk messages will execute the flow control while receiving the chunks\n      if (message.getFlowControlSize() != 0) {\n         // on large messages we should discount 1 on the first packets as we need continuity until the last packet\n         flowControl(message.getFlowControlSize(), !message.isLargeMessage());\n      }\n   }\n   private void doCleanUp(final boolean sendCloseMessage) throws ActiveMQException {\n      try {\n         if (closed) {\n            return;\n         }\n         // We need an extra flag closing, since we need to prevent any more messages getting queued to execute\n         // after this and we can't just set the closed flag to true here, since after/in onmessage the message\n         // might be acked and if the consumer is already closed, the ack will be ignored\n         closing = true;\n         // Now we wait for any current handler runners to run.\n         waitForOnMessageToComplete(true);\n         resetLargeMessageController();\n         closed = true;\n         synchronized (this) {\n            if (receiverThread != null) {\n               // Wake up any receive() thread that might be waiting\n               notify();\n            }\n            handler = null;\n            receiverThread = null;\n         }\n         flushAcks();\n         clearBuffer();\n         if (sendCloseMessage) {\n            sessionContext.closeConsumer(this);\n         }\n      } catch (Throwable t) {\n         // Consumer close should always return without exception\n      }\n      session.removeConsumer(this);\n   }\n   private void clearBuffer() {\n      buffer.clear();\n   }\n   private void doAck(final ClientMessageInternal message) throws ActiveMQException {\n      ackBytes = 0;\n      lastAckedMessage = null;\n      if (logger.isTraceEnabled()) {\n         logger.trace(this + \"::Acking message \" + message);\n      }\n      session.acknowledge(this, message);\n   }\n   @Override\n   public String toString() {\n      return super.toString() + \"{\" +\n         \"consumerContext=\" + consumerContext +\n         \", queueName=\" + queueName +\n         '}';\n   }\n   // Inner classes\n   // --------------------------------------------------------------------------------\n   private class Runner implements Runnable {\n<fim_suffix>      @Override\n      public void run() {\n         try {\n            callOnMessage();\n         } catch (Exception e) {\n            ActiveMQClientLogger.LOGGER.onMessageError(e);\n            lastException = e;\n         }\n      }<fim_middle>// function below has no smell\n"}