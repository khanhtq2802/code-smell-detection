{"text": "<fim_prefix> * saveStream are called.\n */\npublic class LargeMessageControllerImpl implements LargeMessageController {\n   // Constants -----------------------------------------------------\n   private static final String READ_ONLY_ERROR_MESSAGE = \"This is a read-only buffer, setOperations are not supported\";\n   // Attributes ----------------------------------------------------\n   private final ClientConsumerInternal consumerInternal;\n   private final LinkedBlockingQueue<LargeData> largeMessageData = new LinkedBlockingQueue<>();\n   private volatile LargeData currentPacket = null;\n   private final long totalSize;\n   private final int bufferSize;\n   private boolean streamEnded = false;\n   private boolean streamClosed = false;\n   private final long readTimeout;\n   private long readerIndex = 0;\n   /**\n    * This is to control if packets are arriving for a better timeout control\n    */\n   private boolean packetAdded = false;\n   private long packetPosition = -1;\n   private long lastIndex = 0;\n   private long packetLastPosition = -1;\n   private OutputStream outStream;\n   // There's no need to wait a synchronization\n   // we just set the exception and let other threads to get it as soon as possible\n   private volatile Exception handledException;\n   private final FileCache fileCache;\n   private boolean local = false;\n   // Static --------------------------------------------------------\n   // Constructors --------------------------------------------------\n   public LargeMessageControllerImpl(final ClientConsumerInternal consumerInternal,\n                                     final long totalSize,\n                                     final long readTimeout) {\n      this(consumerInternal, totalSize, readTimeout, null);\n   }\n   public LargeMessageControllerImpl(final ClientConsumerInternal consumerInternal,\n                                     final long totalSize,\n                                     final long readTimeout,\n                                     final File cachedFile) {\n      this(consumerInternal, totalSize, readTimeout, cachedFile, 10 * 1024);\n   }\n   public LargeMessageControllerImpl(final ClientConsumerInternal consumerInternal,\n                                     final long totalSize,\n                                     final long readTimeout,\n                                     final File cachedFile,\n                                     final int bufferSize) {\n      this.consumerInternal = consumerInternal;\n      this.readTimeout = readTimeout;\n      this.totalSize = totalSize;\n      if (cachedFile == null) {\n         fileCache = null;\n      } else {\n         fileCache = new FileCache(cachedFile);\n      }\n      this.bufferSize = bufferSize;\n   }\n   // Public --------------------------------------------------------\n   public void setLocal(boolean local) {\n      this.local = local;\n   }\n   @Override\n   public void discardUnusedPackets() {\n      if (outStream == null) {\n         if (local)\n            return;\n         try {\n            checkForPacket(totalSize - 1);\n         } catch (Throwable ignored) {\n         }\n      }\n   }\n   /**\n    * TODO: move this to ConsumerContext as large message is a protocol specific thing\n    * Add a buff to the List, or save it to the OutputStream if set\n    */\n   @Override\n   public void addPacket(byte[] chunk, int flowControlSize, boolean isContinues) {\n      int flowControlCredit = 0;\n      synchronized (this) {\n         packetAdded = true;\n         if (outStream != null) {\n            try {\n               if (!isContinues) {\n                  streamEnded = true;\n               }\n               if (fileCache != null) {\n                  fileCache.cachePackage(chunk);\n               }\n               outStream.write(chunk);\n               flowControlCredit = flowControlSize;\n               notifyAll();\n               if (streamEnded) {\n                  outStream.close();\n               }\n            } catch (Exception e) {\n               ActiveMQClientLogger.LOGGER.errorAddingPacket(e);\n               handledException = e;\n            }\n         } else {\n            if (fileCache != null) {\n               try {\n                  fileCache.cachePackage(chunk);\n               } catch (Exception e) {\n                  ActiveMQClientLogger.LOGGER.errorAddingPacket(e);\n                  handledException = e;\n               }\n            }\n            largeMessageData.offer(new LargeData(chunk, flowControlSize, isContinues));\n         }\n      }\n      if (flowControlCredit != 0) {\n         try {\n            consumerInternal.flowControl(flowControlCredit, !isContinues);\n         } catch (Exception e) {\n            ActiveMQClientLogger.LOGGER.errorAddingPacket(e);\n            handledException = e;\n         }\n      }\n   }\n   @Override\n   public void cancel() {\n      this.handledException = ActiveMQClientMessageBundle.BUNDLE.largeMessageInterrupted();\n      synchronized (this) {\n         int totalSize = 0;\n         LargeData polledPacket = null;\n         while ((polledPacket = largeMessageData.poll()) != null) {\n            totalSize += polledPacket.getFlowControlSize();\n         }\n         try {\n            consumerInternal.flowControl(totalSize, false);\n         } catch (Exception ignored) {\n            // what else can we do here?\n            ActiveMQClientLogger.LOGGER.errorCallingCancel(ignored);\n         }\n         largeMessageData.offer(new LargeData());\n         streamEnded = true;\n         streamClosed = true;\n         notifyAll();\n      }\n   }\n   @Override\n   public synchronized void close() {\n      if (fileCache != null) {\n         fileCache.close();\n      }\n   }\n   @Override\n   public void setOutputStream(final OutputStream output) throws ActiveMQException {\n      int totalFlowControl = 0;\n      boolean continues = false;\n      synchronized (this) {\n         if (currentPacket != null) {\n            sendPacketToOutput(output, currentPacket);\n            currentPacket = null;\n         }\n         while (handledException == null) {\n            LargeData packet = largeMessageData.poll();\n            if (packet == null) {\n               break;\n            }\n            totalFlowControl += packet.getFlowControlSize();\n            continues = packet.isContinues();\n            sendPacketToOutput(output, packet);\n         }\n         checkException();\n         outStream = output;\n      }\n      if (totalFlowControl > 0) {\n         consumerInternal.flowControl(totalFlowControl, !continues);\n      }\n   }\n   @Override\n   public synchronized void saveBuffer(final OutputStream output) throws ActiveMQException {\n      if (streamClosed) {\n         throw ActiveMQClientMessageBundle.BUNDLE.largeMessageLostSession();\n      }\n      setOutputStream(output);\n      waitCompletion(0);\n   }\n   /**\n    * @param timeWait Milliseconds to Wait. 0 means forever\n    * @throws ActiveMQException\n    */\n   @Override\n   public synchronized boolean waitCompletion(final long timeWait) throws ActiveMQException {\n      if (outStream == null) {\n         // There is no stream.. it will never achieve the end of streaming\n         return false;\n      }\n      long timeOut;\n      // If timeWait = 0, we will use the readTimeout\n      // And we will check if no packets have arrived within readTimeout milliseconds\n      if (timeWait != 0) {\n         timeOut = System.currentTimeMillis() + timeWait;\n      } else {\n         timeOut = System.currentTimeMillis() + readTimeout;\n      }\n      while (!streamEnded && handledException == null) {\n         try {\n            this.wait(timeWait == 0 ? readTimeout : timeWait);\n         } catch (InterruptedException e) {\n            throw new ActiveMQInterruptedException(e);\n         }\n         if (!streamEnded && handledException == null) {\n            if (timeWait != 0 && System.currentTimeMillis() > timeOut) {\n               throw ActiveMQClientMessageBundle.BUNDLE.timeoutOnLargeMessage();\n            } else if (System.currentTimeMillis() > timeOut && !packetAdded) {\n               throw ActiveMQClientMessageBundle.BUNDLE.timeoutOnLargeMessage();\n            }\n         }\n      }\n      checkException();\n      return streamEnded;\n   }\n   /**\n    * @throws ActiveMQException\n    */\n   private void checkException() throws ActiveMQException {\n      // it's not needed to copy it as we never set it back to null\n      // once the exception is set, the controller is pretty much useless\n      if (handledException != null) {\n         if (handledException instanceof ActiveMQException) {\n            ActiveMQException nestedException;\n            // This is just to be user friendly and give the user a proper exception trace,\n            // instead to just where it was canceled.\n            if (handledException instanceof ActiveMQLargeMessageInterruptedException) {\n               nestedException = new ActiveMQLargeMessageInterruptedException(handledException.getMessage());\n            } else {\n               nestedException = new ActiveMQException(((ActiveMQException) handledException).getType(), handledException.getMessage());\n            }\n            nestedException.initCause(handledException);\n            throw nestedException;\n         } else {\n            throw new ActiveMQException(ActiveMQExceptionType.LARGE_MESSAGE_ERROR_BODY, \"Error on saving LargeMessageBufferImpl\", handledException);\n         }\n      }\n   }\n   // Channel Buffer Implementation ---------------------------------\n   @Override\n   public int capacity() {\n      return -1;\n   }\n   @Override\n   public byte readByte() {\n      return getByte(readerIndex++);\n   }\n   @Override\n   public byte getByte(final int index) {\n      return getByte((long) index);\n   }\n<fim_suffix>   private byte getByte(final long index) {\n      checkForPacket(index);\n      if (fileCache != null && index < packetPosition) {\n         return fileCache.getByteFromCache(index);\n      } else {\n         return currentPacket.getChunk()[(int) (index - packetPosition)];\n      }\n   }<fim_middle>// function below has no smell\n"}