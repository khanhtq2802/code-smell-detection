{"text": "<fim_prefix>    private volatile boolean m_errorsLogged;\n    // We implement OSGI log service.\n    protected ServiceRegistration logService;\n    // Our bundle context\n    protected BundleContext context;\n    // Our dependency manager used to create test components.\n    protected volatile DependencyManager m_dm;\n    // The Registration for the DM threadpool.\n    private ServiceRegistration m_componentExecutorFactoryReg;\n    public TestBase() {\n    }\n    protected void setParallel() {\n        m_parallel = true;\n    }\n    public void setUp() throws Exception {\n    \twarn(\"Setting up test \" + getClass().getName());\n    \tcontext = FrameworkUtil.getBundle(this.getClass()).getBundleContext();\n    \tHashtable<String, Object> props = new Hashtable<>();\n    \tprops.put(Constants.SERVICE_RANKING, new Integer(Integer.MAX_VALUE));\n        logService = context.registerService(LogService.class.getName(), this, props);\n        context.addFrameworkListener(this);\n        m_dm = new DependencyManager(context);\n        if (m_parallel) {\n            warn(\"Using threadpool ...\");\n            m_threadPool = new ForkJoinPool(Runtime.getRuntime().availableProcessors());\n            m_componentExecutorFactoryReg = context.registerService(ComponentExecutorFactory.class.getName(), \n                new ComponentExecutorFactory() {\n                    @Override\n                    public Executor getExecutorFor(Component component) {\n                        return m_threadPool;\n                    }\n                },\n                null);\n        }\n    }\n    public void tearDown() throws Exception {\n    \twarn(\"Tearing down test \" + getClass().getName());\n    \tlogService.unregister();\n    \tcontext.removeFrameworkListener(this);\n        clearComponents();\n        if (m_parallel && m_componentExecutorFactoryReg != null) {\n    \t    m_componentExecutorFactoryReg.unregister();\n    \t    m_threadPool.shutdown();\n            try {\n                m_threadPool.awaitTermination(60, TimeUnit.SECONDS);\n            } catch (InterruptedException e) {\n            }\n    \t}\n        Assert.assertFalse(errorsLogged());\n    }\n    protected DependencyManager getDM() {\n        return m_dm;\n    }\n    protected void clearComponents() {\n        m_dm.clear();\n        warn(\"All component cleared.\");\n    }\n    /**\n     * Creates and provides an Ensure object with a name service property into the OSGi service registry.\n     */\n    protected ServiceRegistration register(Ensure e, String name) {\n        Hashtable<String, String> props = new Hashtable<String, String>();\n        props.put(\"name\", name);\n        return context.registerService(Ensure.class.getName(), e, props);\n    }\n    /**\n     * Helper method used to stop a given bundle.\n     * \n     * @param symbolicName\n     *            the symbolic name of the bundle to be stopped.\n     */\n    protected void stopBundle(String symbolicName) {\n        // Stop the test.annotation bundle\n        boolean found = false;\n        for (Bundle b : context.getBundles()) {\n            if (b.getSymbolicName().equals(symbolicName)) {\n                try {\n                    found = true;\n                    b.stop();\n                } catch (BundleException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        if (!found) {\n            throw new IllegalStateException(\"bundle \" + symbolicName + \" not found\");\n        }\n    }\n    /**\n     * Helper method used to start a given bundle.\n     * \n     * @param symbolicName\n     *            the symbolic name of the bundle to be started.\n     */\n    protected void startBundle(String symbolicName) {\n        // Stop the test.annotation bundle\n        boolean found = false;\n        for (Bundle b : context.getBundles()) {\n            if (b.getSymbolicName().equals(symbolicName)) {\n                try {\n                    found = true;\n                    b.start();\n                } catch (BundleException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        if (!found) {\n            throw new IllegalStateException(\"bundle \" + symbolicName + \" not found\");\n        }\n    }\n    /**\n     * Helper method used to get a given bundle.\n     * \n     * @param symbolicName\n     *            the symbolic name of the bundle to get.\n     */\n    protected Bundle getBundle(String symbolicName) {\n        for (Bundle b : context.getBundles()) {\n            if (b.getSymbolicName().equals(symbolicName)) {\n                return b;\n            }\n        }\n        throw new IllegalStateException(\"bundle \" + symbolicName + \" not found\");\n    }\n    /**\n     * Suspend the current thread for a while.\n     * \n     * @param n\n     *            the number of milliseconds to wait for.\n     */\n    protected void sleep(int ms) {\n        try {\n            Thread.sleep(ms);\n        } catch (InterruptedException e) {\n        }\n    }\n    /**\n     * Helper method used to convert a dictionary which with untyped keys to a dictionary having a String key.\n     * (this method is useful when converting a Properties object into a compatible Dictionary<String, Object>\n     * object that is often needed in OSGI R6 API. \n     */\n    @SuppressWarnings(\"unchecked\")\n\tpublic static Dictionary<String, ?> toR6Dictionary(Dictionary<?,?> properties) {\n    \treturn (Dictionary<String, ?>) properties;\n    }\n    public void log(int level, String message) {\n        checkError(level, null);\n        if (LOG_LEVEL >= level) {\n            System.out.println(getLevel(level) + \" - \" + Thread.currentThread().getName() + \" : \" + message);\n        }\n    }\n    public void log(int level, String message, Throwable exception) {\n        checkError(level, exception);\n        if (LOG_LEVEL >= level) {\n            StringBuilder sb = new StringBuilder();\n            sb.append(getLevel(level) + \" - \" + Thread.currentThread().getName() + \" : \");\n            sb.append(message);\n            parse(sb, exception);\n            System.out.println(sb.toString());\n        }\n    }\n    public void log(ServiceReference sr, int level, String message) {\n        checkError(level, null);\n        if (LOG_LEVEL >= level) {\n            StringBuilder sb = new StringBuilder();\n            sb.append(getLevel(level) + \" - \" + Thread.currentThread().getName() + \" : \");\n            sb.append(message);\n            System.out.println(sb.toString());\n        }\n    }\n    public void log(ServiceReference sr, int level, String message, Throwable exception) {\n        checkError(level, exception);\n        if (LOG_LEVEL >= level) {\n            StringBuilder sb = new StringBuilder();\n            sb.append(getLevel(level) + \" - \" + Thread.currentThread().getName() + \" : \");\n            sb.append(message);\n            parse(sb, exception);\n            System.out.println(sb.toString());\n        }\n    }\n    protected boolean errorsLogged() {\n        return m_errorsLogged;\n    }\n    private void parse(StringBuilder sb, Throwable t) {\n        if (t != null) {\n            sb.append(\" - \");\n            StringWriter buffer = new StringWriter();\n            PrintWriter pw = new PrintWriter(buffer);\n            t.printStackTrace(pw);\n            sb.append(buffer.toString());\n            m_errorsLogged = true;\n        }\n    }\n    private String getLevel(int level) {\n        switch (level) {\n            case LogService.LOG_DEBUG :\n                return \"DEBUG\";\n            case LogService.LOG_ERROR :\n                return \"ERROR\";\n            case LogService.LOG_INFO :\n                return \"INFO\";\n            case LogService.LOG_WARNING :\n                return \"WARN\";\n            default :\n                return \"\";\n        }\n    }\n    private void checkError(int level, Throwable exception) {\n        if (level <= LOG_ERROR) {\n            m_errorsLogged = true;\n        }\n        if (exception != null) {\n            m_errorsLogged = true;\n        }\n    }\n    public void frameworkEvent(FrameworkEvent event) {\n        int eventType = event.getType();\n        String msg = getFrameworkEventMessage(eventType);\n        int level = (eventType == FrameworkEvent.ERROR) ? LOG_ERROR : LOG_WARNING;\n        if (msg != null) {\n            log(level, msg, event.getThrowable());\n        } else {\n            log(level, \"Unknown fwk event: \" + event);\n        }\n    }\n    private String getFrameworkEventMessage(int event) {\n        switch (event) {\n            case FrameworkEvent.ERROR :\n                return \"FrameworkEvent: ERROR\";\n            case FrameworkEvent.INFO :\n                return \"FrameworkEvent INFO\";\n            case FrameworkEvent.PACKAGES_REFRESHED :\n                return \"FrameworkEvent: PACKAGE REFRESHED\";\n            case FrameworkEvent.STARTED :\n                return \"FrameworkEvent: STARTED\";\n            case FrameworkEvent.STARTLEVEL_CHANGED :\n                return \"FrameworkEvent: STARTLEVEL CHANGED\";\n            case FrameworkEvent.WARNING :\n                return \"FrameworkEvent: WARNING\";\n            default :\n                return null;\n        }\n    }\n<fim_suffix>    protected void warn(String msg, Object ... params) {\n\tif (LOG_LEVEL >= LogService.LOG_WARNING) {\n\t    log(LogService.LOG_WARNING, params.length > 0 ? String.format(msg, params) : msg);\n\t}\n    }<fim_middle>// function below has no smell\n"}