{"text": "<fim_prefix>/*\n * ====================================================================\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n * ====================================================================\n *\n * This software consists of voluntary contributions made by many\n * individuals on behalf of the Apache Software Foundation.  For more\n * information on the Apache Software Foundation, please see\n * <http://www.apache.org/>.\n *\n */\n\npackage org.apache.hc.core5.testing.nio;\n\nimport java.io.IOException;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport org.apache.hc.core5.function.Callback;\nimport org.apache.hc.core5.http.nio.command.ShutdownCommand;\nimport org.apache.hc.core5.io.CloseMode;\nimport org.apache.hc.core5.reactor.ExceptionEvent;\nimport org.apache.hc.core5.reactor.IOEventHandlerFactory;\nimport org.apache.hc.core5.reactor.IOReactorConfig;\nimport org.apache.hc.core5.reactor.IOReactorService;\nimport org.apache.hc.core5.reactor.IOReactorStatus;\nimport org.apache.hc.core5.reactor.IOSession;\nimport org.apache.hc.core5.util.Args;\nimport org.apache.hc.core5.util.Asserts;\nimport org.apache.hc.core5.util.TimeValue;\n\nabstract class IOReactorExecutor<T extends IOReactorService> implements AutoCloseable {\n\n    enum Status { READY, RUNNING, TERMINATED }\n\n    private final IOReactorConfig ioReactorConfig;\n    private final ThreadFactory workerThreadFactory;\n    private final AtomicReference<T> ioReactorRef;\n    private final AtomicReference<Status> status;\n\n    IOReactorExecutor(final IOReactorConfig ioReactorConfig, final ThreadFactory workerThreadFactory) {\n        super();\n        this.ioReactorConfig = ioReactorConfig != null ? ioReactorConfig : IOReactorConfig.DEFAULT;\n        this.workerThreadFactory = workerThreadFactory;\n        this.ioReactorRef = new AtomicReference<>(null);\n        this.status = new AtomicReference<>(Status.READY);\n    }\n\n    abstract T createIOReactor(\n            IOEventHandlerFactory ioEventHandlerFactory,\n            IOReactorConfig ioReactorConfig,\n            ThreadFactory threadFactory,\n            Callback<IOSession> sessionShutdownCallback) throws IOException;\n\n<fim_suffix>    protected void execute(final IOEventHandlerFactory ioEventHandlerFactory) throws IOException {\n        Args.notNull(ioEventHandlerFactory, \"Handler factory\");\n        if (ioReactorRef.compareAndSet(null, createIOReactor(\n                ioEventHandlerFactory,\n                ioReactorConfig,\n                workerThreadFactory,\n                ShutdownCommand.GRACEFUL_NORMAL_CALLBACK))) {\n            if (status.compareAndSet(Status.READY, Status.RUNNING)) {\n                ioReactorRef.get().start();\n            }\n        } else {\n            throw new IllegalStateException(\"I/O reactor has already been started\");\n        }\n    }\n\n    private T ensureRunning() {\n        final T ioReactor = ioReactorRef.get();\n        Asserts.check(ioReactor != null, \"I/O reactor has not been started\");\n        return ioReactor;\n    }\n\n    T reactor() {\n        return ensureRunning();\n    }\n\n    public IOReactorStatus getStatus() {\n        final T ioReactor = ioReactorRef.get();\n        return ioReactor != null ? ioReactor.getStatus() : IOReactorStatus.INACTIVE;\n    }\n\n    public List<ExceptionEvent> getExceptionLog() {\n        final T ioReactor = ioReactorRef.get();\n        return ioReactor != null ? ioReactor.getExceptionLog() : Collections.<ExceptionEvent>emptyList();\n    }\n\n    public void awaitShutdown(final TimeValue waitTime) throws InterruptedException {\n        Args.notNull(waitTime, \"Wait time\");\n        final T ioReactor = ioReactorRef.get();\n        if (ioReactor != null) {\n            ioReactor.awaitShutdown(waitTime);\n        }\n    }\n\n    public void initiateShutdown() {\n        final T ioReactor = ioReactorRef.get();\n        if (ioReactor != null) {\n            if (status.compareAndSet(Status.RUNNING, Status.TERMINATED)) {\n                ioReactor.initiateShutdown();\n            }\n        }\n    }\n\n    public void shutdown(final TimeValue graceTime) {\n        Args.notNull(graceTime, \"Grace time\");\n        final T ioReactor = ioReactorRef.get();\n        if (ioReactor != null) {\n            if (status.compareAndSet(Status.RUNNING, Status.TERMINATED)) {\n                ioReactor.initiateShutdown();\n            }\n            try {\n                ioReactor.awaitShutdown(graceTime);\n            } catch (final InterruptedException ex) {\n                Thread.currentThread().interrupt();\n            }\n            ioReactor.close(CloseMode.IMMEDIATE);\n        }\n    }\n\n    @Override\n    public void close() throws Exception {\n        shutdown(TimeValue.ofSeconds(5));\n    }\n\n}<fim_middle>// function below has no smell\n"}