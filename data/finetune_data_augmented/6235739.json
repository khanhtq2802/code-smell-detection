{"text": "<fim_prefix>\t\tassertFalse(preciseRect.equals(new Object()));\n\t\t// test precision tolerance, therefore increment by an amount not\n\t\t// 'recognizable'\n\t\tRectangle unrecognizableExpanded = preciseRect.getExpanded(\n\t\t\t\tUNRECOGNIZABLE_FRACTION, UNRECOGNIZABLE_FRACTION, 0, 0);\n\t\tRectangle unrecognizableShrinked = preciseRect.getShrinked(0, 0,\n\t\t\t\tUNRECOGNIZABLE_FRACTION, UNRECOGNIZABLE_FRACTION);\n\t\t// equals should not recognize the changes\n\t\tassertTrue(preciseRect.equals(unrecognizableExpanded));\n\t\tassertTrue(preciseRect.equals(unrecognizableShrinked));\n\t\t// increment by an amount 'recognizable'\n\t\tRectangle recognizableExpanded = preciseRect.getExpanded(\n\t\t\t\tRECOGNIZABLE_FRACTION, RECOGNIZABLE_FRACTION, 0, 0);\n\t\tRectangle recognizableShrinked = preciseRect.getShrinked(0, 0,\n\t\t\t\tRECOGNIZABLE_FRACTION, RECOGNIZABLE_FRACTION);\n\t\t// equals should now recognize the changes\n\t\tassertFalse(preciseRect.equals(recognizableExpanded));\n\t\tassertFalse(preciseRect.equals(recognizableShrinked));\n\t\tassertFalse(recognizableExpanded.equals(recognizableShrinked));\n\t}\n\t@Test\n\tpublic void test_getBounds() {\n\t\tforRectangles(new IAction() {\n\t\t\t@Override\n\t\t\tpublic void action(Rectangle rect, Point tl, Point br) {\n\t\t\t\tassertEquals(rect, rect.getBounds());\n\t\t\t}\n\t\t});\n\t}\n\t@Test\n\tpublic void test_getCopy() {\n\t\tRectangle preciseRect = new Rectangle(-9.486614173228347,\n\t\t\t\t-34.431496062992125, 41.99055118110236, 25.92755905511811);\n\t\tRectangle copy = preciseRect.getCopy();\n\t\tassertTrue(preciseRect.equals(copy));\n\t\tassertFalse(preciseRect == copy);\n\t}\n\t@Test\n\tpublic void test_getIntersected() {\n\t\tRectangle r1 = new Rectangle(0, 0, 10, 10);\n\t\t// check no intersection, containment, partial intersection and identity\n\t\tassertEquals(new Rectangle(),\n\t\t\t\tr1.getIntersected(new Rectangle(-20, -20, 5, 5)));\n\t\tassertEquals(new Rectangle(5, 5, 5, 5),\n\t\t\t\tr1.getIntersected(new Rectangle(5, 5, 10, 10)));\n\t\tassertEquals(new Rectangle(2, 2, 6, 6),\n\t\t\t\tr1.getIntersected(new Rectangle(2, 2, 6, 6)));\n\t\tassertEquals(r1, r1.getIntersected(r1));\n\t}\n\t@Test\n\tpublic void test_getLocation() {\n\t\tRectangle r1 = new Rectangle(5, 10, 1, 2);\n\t\tassertEquals(new Point(5, 10), r1.getLocation());\n\t}\n\t@Test\n\tpublic void test_getRotatedCCW() {\n\t\tforRectangles(new IAction() {\n\t\t\t@Override\n\t\t\tpublic void action(Rectangle rect, Point tl, Point br) {\n\t\t\t\tassertEquals(\n\t\t\t\t\t\tfromRectangle(tl.x, tl.y - rect.getWidth(),\n\t\t\t\t\t\t\t\trect.getHeight(), rect.getWidth()),\n\t\t\t\t\t\trect.getRotatedCCW(Angle.fromDeg(90),\n\t\t\t\t\t\t\t\trect.getLocation()));\n\t\t\t}\n\t\t});\n\t}\n\t@Test\n\tpublic void test_getRotatedCW() {\n\t\tforRectangles(new IAction() {\n\t\t\t@Override\n\t\t\tpublic void action(Rectangle rect, Point tl, Point br) {\n\t\t\t\tPolygon expected = fromRectangle(tl.x - rect.getHeight(), tl.y,\n\t\t\t\t\t\trect.getHeight(), rect.getWidth());\n\t\t\t\tPolygon rotatedCW = rect.getRotatedCW(Angle.fromDeg(90),\n\t\t\t\t\t\trect.getLocation());\n\t\t\t\t// DEBUG\n\t\t\t\t// if (!expected.equals(rotatedCW))\n\t\t\t\t// throw new IllegalStateException(\"\");\n\t\t\t\tassertEquals(expected, rotatedCW);\n\t\t\t}\n\t\t});\n\t}\n\t@Test\n\tpublic void test_getScaled() {\n\t\tRectangle rect = new Rectangle(-9.486614173228347, -34.431496062992125,\n\t\t\t\t41.99055118110236, 25.92755905511811)\n\t\t\t\t\t\t.getScaled(26.458333333333332)\n\t\t\t\t\t\t.getScaled(1.0 / 26.458333333333332);\n\t\tassertTrue(PrecisionUtils.equal(-9.486614173228347, rect.getX()));\n\t\tassertTrue(PrecisionUtils.equal(-34.431496062992125, rect.getY()));\n\t\tassertTrue(PrecisionUtils.equal(41.99055118110236, rect.getWidth()));\n\t\tassertTrue(PrecisionUtils.equal(25.92755905511811, rect.getHeight()));\n\t\trect = new Rectangle(-9.486614173228347, -34.431496062992125,\n\t\t\t\t2 * 9.486614173228347, 34.431496062992125).getScaled(2, 0);\n\t\tassertTrue(PrecisionUtils.equal(2 * -9.486614173228347, rect.getX()));\n\t\tassertTrue(\n\t\t\t\tPrecisionUtils.equal(0.5 * -34.431496062992125, rect.getY()));\n\t\tassertTrue(\n\t\t\t\tPrecisionUtils.equal(4 * 9.486614173228347, rect.getWidth()));\n\t\tassertTrue(PrecisionUtils.equal(0, rect.getHeight()));\n\t\t// TODO: is this the desired behavior?\n\t\t// assertTrue(PrecisionUtils.equal(-9.486614173228347, rect.getX()));\n\t\t// assertTrue(PrecisionUtils.equal(-34.431496062992125, rect.getY()));\n\t\t// assertTrue(PrecisionUtils.equal(2 * 41.99055118110236,\n\t\t// rect.getWidth()));\n\t\t// assertTrue(PrecisionUtils.equal(0, rect.getHeight()));\n\t}\n\t@Test\n\tpublic void test_getSegments() {\n\t\tforRectangles(new IAction() {\n\t\t\t@Override\n\t\t\tpublic void action(Rectangle rect, Point tl, Point br) {\n\t\t\t\tLine[] segments = rect.getOutlineSegments();\n\t\t\t\t// segments are top, right, bottom, left. in order.\n\t\t\t\tPoint tr = tl.getTranslated(br.x - tl.x, 0);\n\t\t\t\tPoint bl = tl.getTranslated(0, br.y - tl.y);\n\t\t\t\tassertEquals(new Line(tl, tr), segments[0]);\n\t\t\t\tassertEquals(new Line(tr, br), segments[1]);\n\t\t\t\tassertEquals(new Line(br, bl), segments[2]);\n\t\t\t\tassertEquals(new Line(bl, tl), segments[3]);\n\t\t\t}\n\t\t});\n\t}\n<fim_suffix>\t@Test\n\tpublic void test_getSize() {\n\t\tforRectangles(new IAction() {\n\t\t\t@Override\n\t\t\tpublic void action(Rectangle rect, Point tl, Point br) {\n\t\t\t\tassertEquals(new Dimension(br.x - tl.x, br.y - tl.y),\n\t\t\t\t\t\trect.getSize());\n\t\t\t}\n\t\t});\n\t}<fim_middle>// function below has no smell\n"}