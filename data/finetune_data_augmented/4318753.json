{"text": "<fim_prefix>/*\n\n   Derby - Class org.apache.derby.impl.sql.execute.GenericAggregateResultSet\n\n   Licensed to the Apache Software Foundation (ASF) under one or more\n   contributor license agreements.  See the NOTICE file distributed with\n   this work for additional information regarding copyright ownership.\n   The ASF licenses this file to you under the Apache License, Version 2.0\n   (the \"License\"); you may not use this file except in compliance with\n   the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n */\n\npackage org.apache.derby.impl.sql.execute;\n\nimport java.util.Vector;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\nimport org.apache.derby.shared.common.error.SQLWarningFactory;\nimport org.apache.derby.shared.common.error.StandardException;\nimport org.apache.derby.shared.common.reference.SQLState;\nimport org.apache.derby.iapi.services.loader.ClassFactory;\nimport org.apache.derby.iapi.sql.Activation;\nimport org.apache.derby.iapi.sql.conn.LanguageConnectionContext;\nimport org.apache.derby.iapi.sql.execute.ExecIndexRow;\nimport org.apache.derby.iapi.sql.execute.ExecPreparedStatement;\nimport org.apache.derby.iapi.sql.execute.ExecRowBuilder;\nimport org.apache.derby.iapi.sql.execute.ExecutionFactory;\nimport org.apache.derby.iapi.sql.execute.NoPutResultSet;\n\n/**\n * Generic aggregation utilities.\n *\n */\nabstract class GenericAggregateResultSet extends NoPutResultSetImpl\n{\n\tprotected GenericAggregator[]\t\taggregates;\t\n\tprotected AggregatorInfoList\taggInfoList;\t\n\tpublic NoPutResultSet source;\n\tprotected\tNoPutResultSet\toriginalSource; // used for run time stats only\n    private final ExecIndexRow rowTemplate;\n\n\t/**\n\t * Constructor\n\t *\n\t * @param a activation\n\t * @param ra reference to a saved row allocator instance\n\t * @param resultSetNumber result set number\n\t * @param optimizerEstimatedRowCount optimizer estimated row count\n\t * @param optimizerEstimatedCost optimizer estimated cost\n\t *\n\t * @exception StandardException Thrown on error\n\t */\n\tGenericAggregateResultSet\n\t(\n\t\tNoPutResultSet s,\n\t\tint\taggregateItem,\n\t\tActivation \ta,\n\t\tint ra,\n\t\tint \t\t\tresultSetNumber,\n\t\tdouble \t\t\toptimizerEstimatedRowCount,\n\t\tdouble \t\t\toptimizerEstimatedCost\n\t) \n\t\tthrows StandardException \n\t{\n\t\tsuper(a, resultSetNumber, optimizerEstimatedRowCount, optimizerEstimatedCost);\n\t\tsource = s;\n\t\toriginalSource = s;\n\n        ExecPreparedStatement ps = a.getPreparedStatement();\n        ExecutionFactory ef = a.getExecutionFactory();\n\n        rowTemplate = ef.getIndexableRow(\n                ((ExecRowBuilder) ps.getSavedObject(ra)).build(ef));\n\n\t\taggInfoList = (AggregatorInfoList) ps.getSavedObject(aggregateItem);\n\t\taggregates = getSortAggregators(aggInfoList, false, \n\t\t\t\ta.getLanguageConnectionContext(), s);\n\t}\n\n    /**\n     * Get a template row of the right shape for sorting or returning results.\n     * The template is cached, so it may need to be cloned if callers use it\n     * for multiple purposes at the same time.\n     *\n     * @return a row template of the right shape for this result set\n     */\n    ExecIndexRow getRowTemplate() {\n        return rowTemplate;\n    }\n\n\t/**\n\t * For each AggregatorInfo in the list, generate a\n\t * GenericAggregator and stick it in an array of\n\t * GenericAggregators.\n\t *\n\t * @param list \tthe list of aggregators to set up\t\n\t * @param eliminateDistincts\tshould distincts be ignored.  \n\t *\t\tUsed to toss out distinct aggregates for a prelim\n\t *\t\tsort.\n\t * @param lcc the lcc\n\t * @param inputResultSet the incoming result set\n\t *\n\t * @return the array of GenericAggregators\n\t * \n\t * @exception StandardException on error\n\t */\t\n    @SuppressWarnings(\"UseOfObsoleteCollectionType\")\n\tprotected final GenericAggregator[] getSortAggregators\n\t(\n\t\tAggregatorInfoList \t\t\tlist,\n\t\tboolean \t\t\t\t\teliminateDistincts,\n\t\tLanguageConnectionContext\tlcc,\n\t\tNoPutResultSet\t\t\t\tinputResultSet\t\n\t) throws StandardException\n\t{\n\t\tGenericAggregator \taggregators[]; \n        Vector<GenericAggregator>\n                tmpAggregators = new Vector<GenericAggregator>();\n\t\tClassFactory\t\tcf = lcc.getLanguageConnectionFactory().getClassFactory();\n\n        for (AggregatorInfo aggInfo : list)\n\t\t{\n\t\t\tif (! (eliminateDistincts && aggInfo.isDistinct()))\n\t\t\t// if (eliminateDistincts == aggInfo.isDistinct())\n\t\t\t{\n\t\t\t\ttmpAggregators.addElement(new GenericAggregator(aggInfo, cf));\n\t\t\t}\n\t\t}\n\n\n\n\t\taggregators = new GenericAggregator[tmpAggregators.size()];\n\t\ttmpAggregators.copyInto(aggregators);\n\t\t// System.out.println(\"size of sort aggregates \" + tmpAggregators.size());\n\n\t\treturn aggregators;\n\t}\n\n\t/**\n\t * Finish the aggregation for the current row.  \n\t * Basically call finish() on each aggregator on\n\t * this row.  Called once per grouping on a vector\n\t * aggregate or once per table on a scalar aggregate.\n\t *\n\t * If the input row is null, then rowAllocator is\n\t * invoked to create a new row.  That row is then\n\t * initialized and used for the output of the aggregation.\n\t *\n\t * @param \trow\tthe row to finish aggregation\n\t *\n\t * @return\tthe result row.  If the input row != null, then\n\t *\tthe result row == input row\n\t *\n\t * @exception StandardException Thrown on error\n\t */\n\tprotected final ExecIndexRow finishAggregation(ExecIndexRow row)\n\t\tthrows StandardException\n\t{\n\t\tint\tsize = aggregates.length;\n\n\t\t/*\n\t\t** If the row in which we are to place the aggregate\n\t\t** result is null, then we have an empty input set.\n\t\t** So we'll have to create our own row and set it\n\t\t** up.  Note: we needn't initialize in this case,\n\t\t** finish() will take care of it for us.\n\t\t*/ \n\t\tif (row == null)\n\t\t{\n\t\t\trow = getRowTemplate();\n\t\t}\n\n\t\tsetCurrentRow(row);\n\n\t\tboolean eliminatedNulls = false;\n\t\tfor (int i = 0; i < size; i++)\n\t\t{\n\t\t\tGenericAggregator currAggregate = aggregates[i];\n\t\t\tif (currAggregate.finish(row))\n\t\t\t\teliminatedNulls = true;\n\t\t}\n\n\t\tif (eliminatedNulls)\n\t\t\taddWarning(SQLWarningFactory.newSQLWarning(SQLState.LANG_NULL_ELIMINATED_IN_SET_FUNCTION));\n\t\n\t\treturn row;\n\t}\n\n<fim_suffix>    @Override\n\tpublic void finish() throws StandardException {\n\t\tsource.finish();\n\t\tsuper.finish();\n\t}\n\n    public Element toXML( Element parentNode, String tag ) throws Exception\n    {\n        // don't report the redundant originalSource node\n        \n        Element result = super.toXML( parentNode, tag );\n        NodeList    children = result.getChildNodes();\n        for ( int i = 0; i < children.getLength(); i++ )\n        {\n            Node child = children.item( 0 );\n            if ( \"originalSource\".equals( child.getNodeName() ) ) { result.removeChild( child ); }\n        }\n\n        return result;\n    }\n}<fim_middle>// function below has no smell\n"}