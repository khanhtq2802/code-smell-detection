{"text": "<fim_prefix>package org.robolectric.annotation.processing.generator;\n\nimport com.google.common.base.Joiner;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.TreeMap;\nimport javax.annotation.processing.Filer;\nimport javax.annotation.processing.Messager;\nimport javax.annotation.processing.ProcessingEnvironment;\nimport javax.tools.Diagnostic;\nimport javax.tools.JavaFileObject;\nimport org.robolectric.annotation.processing.RobolectricModel;\nimport org.robolectric.annotation.processing.RobolectricModel.ShadowInfo;\nimport org.robolectric.annotation.processing.RobolectricProcessor;\n\n/**\n * Generator that creates the \"ShadowProvider\" implementation for a shadow package.\n */\npublic class ShadowProviderGenerator extends Generator {\n  private final Filer filer;\n  private final Messager messager;\n  private final RobolectricModel model;\n  private final String shadowPackage;\n  private final boolean shouldInstrumentPackages;\n  private final int priority;\n\n<fim_suffix>  public ShadowProviderGenerator(\n      RobolectricModel model,\n      ProcessingEnvironment environment,\n      String shadowPackage,\n      boolean shouldInstrumentPackages,\n      int priority) {\n    this.messager = environment.getMessager();\n    this.filer = environment.getFiler();\n    this.model = model;\n    this.shadowPackage = shadowPackage;\n    this.shouldInstrumentPackages = shouldInstrumentPackages;\n    this.priority = priority;\n  }\n\n  @Override\n  public void generate() {\n    if (shadowPackage == null) {\n      return;\n    }\n\n    final String shadowClassName = shadowPackage + '.' + GEN_CLASS;\n\n    // TODO: Because this was fairly simple to begin with I haven't\n    // included a templating engine like Velocity but simply used\n    // raw print() statements, in an effort to reduce the number of\n    // dependencies that RAP has. However, if it gets too complicated\n    // then using Velocity might be a good idea.\n    try {\n      JavaFileObject jfo = filer.createSourceFile(shadowClassName);\n      try (PrintWriter writer = new PrintWriter(jfo.openWriter())) {\n        generate(writer);\n      }\n    } catch (IOException e) {\n      messager.printMessage(Diagnostic.Kind.ERROR, \"Failed to write shadow class file: \" + e);\n      throw new RuntimeException(e);\n    }\n  }\n\n  void generate(PrintWriter writer) {\n    writer.print(\"package \" + shadowPackage + \";\\n\");\n    for (String name : model.getImports()) {\n      writer.println(\"import \" + name + ';');\n    }\n    writer.println();\n    writer.println(\"/**\");\n    writer.println(\" * Shadow mapper. Automatically generated by the Robolectric Annotation Processor.\");\n    writer.println(\" */\");\n    writer.println(\"@Generated(\\\"\" + RobolectricProcessor.class.getCanonicalName() + \"\\\")\");\n    if (priority != 0) {\n      writer.println(\"@javax.annotation.Priority(\" + priority + \")\");\n    }\n    writer.println(\"@SuppressWarnings({\\\"unchecked\\\",\\\"deprecation\\\"})\");\n    writer.println(\"public class \" + GEN_CLASS + \" implements ShadowProvider {\");\n\n    writer.println(\"  private static final Map<String, String> SHADOW_MAP = new HashMap<>(\" + (\n        model.getAllShadowTypes().size() + model.getExtraShadowTypes().size()) + \");\");\n    writer.println();\n\n    writer.println(\"  static {\");\n    for (ShadowInfo shadowInfo : model.getAllShadowTypes()) {\n      final String shadow = shadowInfo.getShadowBinaryName();\n      final String actual = shadowInfo.getActualName();\n      if (shadowInfo.getShadowPickerBinaryName() == null) {\n        writer.println(\"    SHADOW_MAP.put(\\\"\" + actual + \"\\\", \\\"\" + shadow + \"\\\");\");\n      }\n    }\n\n    for (Map.Entry<String, String> entry : model.getExtraShadowTypes().entrySet()) {\n      final String shadow = entry.getKey();\n      final String actual = entry.getValue();\n      writer.println(\"    SHADOW_MAP.put(\\\"\" + actual + \"\\\", \\\"\" + shadow + \"\\\");\");\n    }\n\n    writer.println(\"  }\");\n    writer.println();\n\n    for (ShadowInfo shadowInfo : model.getVisibleShadowTypes()) {\n      if (!shadowInfo.actualIsPublic()) {\n        continue;\n      }\n\n      if (shadowInfo.getShadowPickerBinaryName() != null) {\n        continue;\n      }\n\n      if (shadowInfo.shadowIsDeprecated()) {\n        writer.println(\"  @Deprecated\");\n      }\n      String paramDefStr = shadowInfo.getParamDefStr();\n      final String shadow = shadowInfo.getShadowTypeWithParams();\n      writer.println(\"  public static \" + (paramDefStr.isEmpty() ? \"\" : paramDefStr + \" \") + shadow\n          + \" shadowOf(\" + shadowInfo.getActualTypeWithParams() + \" actual) {\");\n      writer.println(\"    return (\" + shadow + \") Shadow.extract(actual);\");\n      writer.println(\"  }\");\n      writer.println();\n    }\n\n    // this sucks, kill:\n    for (Entry<String, ShadowInfo> entry : model.getShadowPickers().entrySet()) {\n      ShadowInfo shadowInfo = entry.getValue();\n\n      if (!shadowInfo.actualIsPublic() || !shadowInfo.isInAndroidSdk()) {\n        continue;\n      }\n\n      if (shadowInfo.shadowIsDeprecated()) {\n        writer.println(\"  @Deprecated\");\n      }\n      String paramDefStr = shadowInfo.getParamDefStr();\n      final String shadow = shadowInfo.getShadowName();\n      writer.println(\"  public static \" + (paramDefStr.isEmpty() ? \"\" : paramDefStr + \" \") + shadow\n          + \" shadowOf(\" + shadowInfo.getActualTypeWithParams() + \" actual) {\");\n      writer.println(\"    return (\" + shadow + \") Shadow.extract(actual);\");\n      writer.println(\"  }\");\n      writer.println();\n    }\n\n    writer.println(\"  @Override\");\n    writer.println(\"  public void reset() {\");\n    for (RobolectricModel.ResetterInfo resetterInfo : model.getResetters()) {\n      int minSdk = resetterInfo.getMinSdk();\n      int maxSdk = resetterInfo.getMaxSdk();\n      String ifClause;\n      if (minSdk != -1 && maxSdk != -1) {\n        ifClause = \"if (org.robolectric.RuntimeEnvironment.getApiLevel() >= \" + minSdk\n            + \" && org.robolectric.RuntimeEnvironment.getApiLevel() <= \" + maxSdk + \") \";\n      } else if (maxSdk != -1) {\n        ifClause = \"if (org.robolectric.RuntimeEnvironment.getApiLevel() <= \" + maxSdk + \") \";\n      } else if (minSdk != -1) {\n        ifClause = \"if (org.robolectric.RuntimeEnvironment.getApiLevel() >= \" + minSdk + \") \";\n      } else {\n        ifClause = \"\";\n      }\n      writer.println(\"    \" + ifClause + resetterInfo.getMethodCall());\n    }\n    writer.println(\"  }\");\n    writer.println();\n\n    writer.println(\"  @Override\");\n    writer.println(\"  public Map<String, String> getShadowMap() {\");\n    writer.println(\"    return SHADOW_MAP;\");\n    writer.println(\"  }\");\n    writer.println();\n\n    writer.println(\"  @Override\");\n    writer.println(\"  public String[] getProvidedPackageNames() {\");\n    writer.println(\"    return new String[] {\");\n    if (shouldInstrumentPackages) {\n      writer.println(\"      \" + Joiner.on(\",\\n      \").join(model.getShadowedPackages()));\n    }\n    writer.println(\"    };\");\n    writer.println(\"  }\");\n    writer.println();\n\n    TreeMap<String, ShadowInfo> shadowPickers = model.getShadowPickers();\n    if (!shadowPickers.isEmpty()) {\n      writer.println(\"  private static final Map<String, String> SHADOW_PICKER_MAP = \" +\n          \"new HashMap<>(\" + shadowPickers.size() + \");\");\n      writer.println();\n\n      writer.println(\"  static {\");\n      for (Entry<String, ShadowInfo> entry : shadowPickers.entrySet()) {\n        ShadowInfo shadowInfo = entry.getValue();\n        final String actualBinaryName = shadowInfo.getActualBinaryName();\n        final String shadowPickerClassName = shadowInfo.getShadowPickerBinaryName();\n        writer.println(\"    SHADOW_PICKER_MAP.put(\\\"\" + actualBinaryName + \"\\\", \" +\n            \"\\\"\" + shadowPickerClassName + \"\\\");\");\n      }\n      writer.println(\"  }\");\n      writer.println();\n\n      writer.println(\"  @Override\");\n      writer.println(\"  public Map<String, String> getShadowPickerMap() {\");\n      writer.println(\"    return SHADOW_PICKER_MAP;\");\n      writer.println(\"  }\");\n    }\n\n    writer.println('}');\n  }\n}<fim_middle>// function below has no smell\n"}