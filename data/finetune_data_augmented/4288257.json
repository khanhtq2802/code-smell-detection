{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.cxf.fediz.was.servlet.filter;\n\nimport java.io.IOException;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.Map;\n\nimport javax.security.auth.Subject;\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.w3c.dom.Element;\n\nimport com.ibm.websphere.security.WSSecurityException;\nimport com.ibm.websphere.security.auth.WSSubject;\n\nimport org.apache.cxf.fediz.core.SecurityTokenThreadLocal;\nimport org.apache.cxf.fediz.core.processor.FedizResponse;\nimport org.apache.cxf.fediz.was.Constants;\nimport org.apache.cxf.fediz.was.tai.FedizInterceptor;\n\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/*\n * A Servlet Filter that MUST be configured to match the '/*' request scheme on each Web Application\n * to enforce SAML assertion TimeToLive checking\n *\n * Only needed if TAI Interceptor is not registered with option \"beforeSSO=true\". Otherwise use FederationFilter\n * instead.\n */\npublic class SecurityContextTTLChecker extends HttpServlet implements Filter {\n    private static final Logger LOG = LoggerFactory.getLogger(SecurityContextTTLChecker.class);\n    private static final long serialVersionUID = 5732969339258858728L;\n\n    private String contextPath;\n\n    /*\n     * (non-Java-doc)\n     * @see java.lang.Object#Object()\n     */\n    public SecurityContextTTLChecker() {\n        super();\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    @Override\n    public void init(ServletConfig config) throws ServletException {\n        super.init(config);\n        contextPath = config.getServletContext().getContextPath();\n        FedizInterceptor.registerContext(contextPath);\n    }\n\n    /*\n     * (non-Java-doc)\n     * @see javax.servlet.Filter#doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n     */\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n        throws IOException, ServletException {\n\n        try {\n            FedizResponse fedResponse = null;\n            Subject subject = WSSubject.getCallerSubject();\n            boolean validSecurityTokenFound = false;\n            if (subject != null) {\n                fedResponse = getCachedFederationResponse(subject);\n                validSecurityTokenFound = checkSecurityToken(fedResponse);\n            }\n            if (!validSecurityTokenFound) {\n                if (LOG.isInfoEnabled()) {\n                    LOG.info(\"Security token not found or WS-Federation session has expired\");\n                }\n                // delete the session\n                if (request instanceof HttpServletRequest) {\n                    HttpServletRequest req = (HttpServletRequest)request;\n                    req.getSession().invalidate();\n                }\n            } else {\n                Element el = (Element)fedResponse.getToken();\n                if (el != null) {\n                    SecurityTokenThreadLocal.setToken(el);\n                }\n                LOG.debug(\"Security token is still valid. Forwarding request\");\n            }\n            chain.doFilter(request, response);\n        } catch (WSSecurityException e) {\n            throw new ServletException(\"Unable to get a valid Subject instance in Filter chain context\", e);\n        } catch (Exception e) {\n            LOG.error(\"Failed validating cached security token\", e);\n            throw new ServletException(\"Failed validating cached security token\", e);\n        } finally {\n            SecurityTokenThreadLocal.setToken(null);\n        }\n    }\n\n<fim_suffix>    private boolean checkSecurityToken(FedizResponse response) {\n        if (response == null) {\n            return false;\n        }\n        long currentTime = System.currentTimeMillis();\n        return response.getTokenExpires().getTime() > currentTime;\n    }\n\n    private FedizResponse getCachedFederationResponse(Subject subject) {\n        Iterator<?> i = subject.getPublicCredentials().iterator();\n\n        while (i.hasNext()) {\n            Object o = i.next();\n            if (o instanceof Hashtable) {\n                @SuppressWarnings(\"unchecked\")\n                Map<Object, Object> table = (Hashtable<Object, Object>)o;\n                return (FedizResponse)table.get(Constants.SUBJECT_TOKEN_KEY);\n            }\n        }\n        return null;\n    }\n\n\n    /*\n     * (non-Java-doc)\n     * @see javax.servlet.Filter#destroy()\n     */\n    @SuppressWarnings(\"deprecation\")\n    public void destroy() {\n        FedizInterceptor.deRegisterContext(contextPath);\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n        contextPath = filterConfig.getServletContext().getContextPath();\n        FedizInterceptor.registerContext(contextPath);\n    }\n\n}<fim_middle>// function below has no smell\n"}