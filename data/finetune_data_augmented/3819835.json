{"text": "<fim_prefix>    public void put(Key key, Value value) {\n      // Always a MemKey, so account for the kvCount int\n      bytesInMemory.addAndGet(key.getLength() + 4);\n      bytesInMemory.addAndGet(value.getSize());\n      if (map.put(key, value) == null)\n        size.incrementAndGet();\n    }\n    @Override\n    public int size() {\n      return size.get();\n    }\n    @Override\n    public InterruptibleIterator skvIterator(SamplerConfigurationImpl samplerConfig) {\n      if (samplerConfig != null)\n        throw new SampleNotPresentException();\n      if (map == null)\n        throw new IllegalStateException();\n      return new SortedMapIterator(map);\n    }\n    @Override\n    public synchronized void delete() {\n      map = null;\n    }\n    public long getOverheadPerEntry() {\n      // all of the java objects that are used to hold the\n      // data and make it searchable have overhead... this\n      // overhead is estimated using test.EstimateInMemMapOverhead\n      // and is in bytes.. the estimates were obtained by running\n      // java 6_16 in 64 bit server mode\n      return 200;\n    }\n    @Override\n    public void mutate(List<Mutation> mutations, int kvCount) {\n      for (Mutation m : mutations) {\n        for (ColumnUpdate cvp : m.getUpdates()) {\n          Key newKey = new MemKey(m.getRow(), cvp.getColumnFamily(), cvp.getColumnQualifier(),\n              cvp.getColumnVisibility(), cvp.getTimestamp(), cvp.isDeleted(), false, kvCount++);\n          Value value = new Value(cvp.getValue());\n          put(newKey, value);\n        }\n      }\n    }\n    @Override\n    public long getMemoryUsed() {\n      return bytesInMemory.get() + (size() * getOverheadPerEntry());\n    }\n  }\n  private static class NativeMapWrapper implements SimpleMap {\n    private NativeMap nativeMap;\n    NativeMapWrapper() {\n      nativeMap = new NativeMap();\n    }\n    @Override\n    public int size() {\n      return nativeMap.size();\n    }\n    @Override\n    public InterruptibleIterator skvIterator(SamplerConfigurationImpl samplerConfig) {\n      if (samplerConfig != null)\n        throw new SampleNotPresentException();\n      return (InterruptibleIterator) nativeMap.skvIterator();\n    }\n    @Override\n    public void delete() {\n      nativeMap.delete();\n    }\n    @Override\n    public long getMemoryUsed() {\n      return nativeMap.getMemoryUsed();\n    }\n    @Override\n    public void mutate(List<Mutation> mutations, int kvCount) {\n      nativeMap.mutate(mutations, kvCount);\n    }\n  }\n  private AtomicInteger nextKVCount = new AtomicInteger(1);\n  private AtomicInteger kvCount = new AtomicInteger(0);\n  private Object writeSerializer = new Object();\n  /**\n   * Applies changes to a row in the InMemoryMap\n   *\n   */\n  public void mutate(List<Mutation> mutations, int numKVs) {\n    // Can not update mutationCount while writes that started before\n    // are in progress, this would cause partial mutations to be seen.\n    // Also, can not continue until mutation count is updated, because\n    // a read may not see a successful write. Therefore writes must\n    // wait for writes that started before to finish.\n    //\n    // using separate lock from this map, to allow read/write in parallel\n    synchronized (writeSerializer) {\n      int kv = nextKVCount.getAndAdd(numKVs);\n      try {\n        map.mutate(mutations, kv);\n      } finally {\n        kvCount.set(kv + numKVs - 1);\n      }\n    }\n  }\n  /**\n   * Returns a long representing the size of the InMemoryMap\n   *\n   * @return bytesInMemory\n   */\n  public synchronized long estimatedSizeInBytes() {\n    if (map == null)\n      return 0;\n    return map.getMemoryUsed();\n  }\n  public synchronized long getNumEntries() {\n    if (map == null)\n      return 0;\n    return map.size();\n  }\n  private final Set<MemoryIterator> activeIters = Collections.synchronizedSet(new HashSet<>());\n  class MemoryDataSource implements DataSource {\n    private boolean switched = false;\n    private InterruptibleIterator iter;\n    private FileSKVIterator reader;\n    private MemoryDataSource parent;\n    private IteratorEnvironment env;\n    private AtomicBoolean iflag;\n    private SamplerConfigurationImpl iteratorSamplerConfig;\n    private SamplerConfigurationImpl getSamplerConfig() {\n      if (env != null) {\n        if (env.isSamplingEnabled()) {\n          return new SamplerConfigurationImpl(env.getSamplerConfiguration());\n        } else {\n          return null;\n        }\n      } else {\n        return iteratorSamplerConfig;\n      }\n    }\n    MemoryDataSource(SamplerConfigurationImpl samplerConfig) {\n      this(null, false, null, null, samplerConfig);\n    }\n    public MemoryDataSource(MemoryDataSource parent, boolean switched, IteratorEnvironment env,\n        AtomicBoolean iflag, SamplerConfigurationImpl samplerConfig) {\n      this.parent = parent;\n      this.switched = switched;\n      this.env = env;\n      this.iflag = iflag;\n      this.iteratorSamplerConfig = samplerConfig;\n    }\n    @Override\n    public boolean isCurrent() {\n      if (switched)\n        return true;\n      else\n        return memDumpFile == null;\n    }\n    @Override\n    public DataSource getNewDataSource() {\n      if (switched)\n        throw new IllegalStateException();\n      if (!isCurrent()) {\n        switched = true;\n        iter = null;\n        try {\n          // ensure files are referenced even if iterator was never seeked before\n          iterator();\n        } catch (IOException e) {\n          throw new RuntimeException();\n        }\n      }\n      return this;\n    }\n    private synchronized FileSKVIterator getReader() throws IOException {\n      if (reader == null) {\n        Configuration conf = context.getHadoopConf();\n        FileSystem fs = FileSystem.getLocal(conf);\n        reader = new RFileOperations().newReaderBuilder()\n            .forFile(memDumpFile, fs, conf, context.getCryptoService())\n            .withTableConfiguration(context.getConfiguration()).seekToBeginning().build();\n        if (iflag != null)\n          reader.setInterruptFlag(iflag);\n        if (getSamplerConfig() != null) {\n          reader = reader.getSample(getSamplerConfig());\n        }\n      }\n      return reader;\n    }\n    @Override\n    public SortedKeyValueIterator<Key,Value> iterator() throws IOException {\n      if (iter == null)\n        if (!switched) {\n          iter = map.skvIterator(getSamplerConfig());\n          if (iflag != null)\n            iter.setInterruptFlag(iflag);\n        } else {\n          if (parent == null)\n            iter = new MemKeyConversionIterator(getReader());\n          else\n            synchronized (parent) {\n              // synchronize deep copy operation on parent, this prevents multiple threads from deep\n              // copying the rfile shared from parent its possible that the\n              // thread deleting an InMemoryMap and scan thread could be switching different deep\n              // copies\n              iter = new MemKeyConversionIterator(parent.getReader().deepCopy(env));\n            }\n        }\n      return iter;\n    }\n    @Override\n    public DataSource getDeepCopyDataSource(IteratorEnvironment env) {\n      return new MemoryDataSource(parent == null ? this : parent, switched, env, iflag,\n          iteratorSamplerConfig);\n    }\n    @Override\n    public void setInterruptFlag(AtomicBoolean flag) {\n      this.iflag = flag;\n    }\n  }\n<fim_suffix>  public class MemoryIterator extends WrappingIterator implements InterruptibleIterator {\n    private AtomicBoolean closed;\n    private SourceSwitchingIterator ssi;\n    private MemoryDataSource mds;\n    private MemoryIterator(InterruptibleIterator source) {\n      this(source, new AtomicBoolean(false));\n    }\n    private MemoryIterator(SortedKeyValueIterator<Key,Value> source, AtomicBoolean closed) {\n      setSource(source);\n      this.closed = closed;\n    }\n    @Override\n    public SortedKeyValueIterator<Key,Value> deepCopy(IteratorEnvironment env) {\n      return new MemoryIterator(getSource().deepCopy(env), closed);\n    }\n    public void close() {\n      synchronized (this) {\n        if (closed.compareAndSet(false, true)) {\n          try {\n            if (mds.reader != null)\n              mds.reader.close();\n          } catch (IOException e) {\n            log.warn(\"{}\", e.getMessage(), e);\n          }\n        }\n      }\n      // remove outside of sync to avoid deadlock\n      activeIters.remove(this);\n    }\n    private synchronized boolean switchNow() throws IOException {\n      if (closed.get())\n        return false;\n      ssi.switchNow();\n      return true;\n    }\n    @Override\n    public void setInterruptFlag(AtomicBoolean flag) {\n      ((InterruptibleIterator) getSource()).setInterruptFlag(flag);\n    }\n    private void setSSI(SourceSwitchingIterator ssi) {\n      this.ssi = ssi;\n    }\n    public void setMDS(MemoryDataSource mds) {\n      this.mds = mds;\n    }\n  }<fim_middle>// class below has no smell\n"}