{"text": "<fim_prefix>        this.useCompression = useCompression;\n    }\n    public boolean isObjectMessageSerializationDefered() {\n        return objectMessageSerializationDefered;\n    }\n    /**\n     * When an object is set on an ObjectMessage, the JMS spec requires the\n     * object to be serialized by that set method. Enabling this flag causes the\n     * object to not get serialized. The object may subsequently get serialized\n     * if the message needs to be sent over a socket or stored to disk.\n     */\n    public void setObjectMessageSerializationDefered(boolean objectMessageSerializationDefered) {\n        this.objectMessageSerializationDefered = objectMessageSerializationDefered;\n    }\n    public boolean isDispatchAsync() {\n        return dispatchAsync;\n    }\n    /**\n     * Enables or disables the default setting of whether or not consumers have\n     * their messages <a\n     * href=\"http://activemq.apache.org/consumer-dispatch-async.html\">dispatched\n     * synchronously or asynchronously by the broker</a>. For non-durable\n     * topics for example we typically dispatch synchronously by default to\n     * minimize context switches which boost performance. However sometimes its\n     * better to go slower to ensure that a single blocked consumer socket does\n     * not block delivery to other consumers.\n     *\n     * @param asyncDispatch If true then consumers created on this connection\n     *                will default to having their messages dispatched\n     *                asynchronously. The default value is true.\n     */\n    public void setDispatchAsync(boolean asyncDispatch) {\n        this.dispatchAsync = asyncDispatch;\n    }\n    /**\n     * @return Returns the closeTimeout.\n     */\n    public int getCloseTimeout() {\n        return closeTimeout;\n    }\n    /**\n     * Sets the timeout before a close is considered complete. Normally a\n     * close() on a connection waits for confirmation from the broker; this\n     * allows that operation to timeout to save the client hanging if there is\n     * no broker\n     */\n    public void setCloseTimeout(int closeTimeout) {\n        this.closeTimeout = closeTimeout;\n    }\n    /**\n     * @return Returns the alwaysSessionAsync.\n     */\n    public boolean isAlwaysSessionAsync() {\n        return alwaysSessionAsync;\n    }\n    /**\n     * If this flag is not set then a separate thread is not used for dispatching messages for each Session in\n     * the Connection. However, a separate thread is always used if there is more than one session, or the session\n     * isn't in auto acknowledge or duplicates ok mode.  By default this value is set to true and session dispatch\n     * happens asynchronously.\n     */\n    public void setAlwaysSessionAsync(boolean alwaysSessionAsync) {\n        this.alwaysSessionAsync = alwaysSessionAsync;\n    }\n    /**\n     * @return Returns the optimizeAcknowledge.\n     */\n    public boolean isOptimizeAcknowledge() {\n        return optimizeAcknowledge;\n    }\n    /**\n     * @param optimizeAcknowledge The optimizeAcknowledge to set.\n     */\n    public void setOptimizeAcknowledge(boolean optimizeAcknowledge) {\n        this.optimizeAcknowledge = optimizeAcknowledge;\n    }\n    /**\n     * The max time in milliseconds between optimized ack batches\n     * @param optimizeAcknowledgeTimeOut\n     */\n    public void setOptimizeAcknowledgeTimeOut(long optimizeAcknowledgeTimeOut) {\n        this.optimizeAcknowledgeTimeOut =  optimizeAcknowledgeTimeOut;\n    }\n    public long getOptimizeAcknowledgeTimeOut() {\n        return optimizeAcknowledgeTimeOut;\n    }\n    public boolean isNestedMapAndListEnabled() {\n        return nestedMapAndListEnabled;\n    }\n    /**\n     * Enables/disables whether or not Message properties and MapMessage entries\n     * support <a\n     * href=\"http://activemq.apache.org/structured-message-properties-and-mapmessages.html\">Nested\n     * Structures</a> of Map and List objects\n     */\n    public void setNestedMapAndListEnabled(boolean structuredMapsEnabled) {\n        this.nestedMapAndListEnabled = structuredMapsEnabled;\n    }\n    public String getClientIDPrefix() {\n        return clientIDPrefix;\n    }\n    /**\n     * Sets the prefix used by autogenerated JMS Client ID values which are used\n     * if the JMS client does not explicitly specify on.\n     *\n     * @param clientIDPrefix\n     */\n    public void setClientIDPrefix(String clientIDPrefix) {\n        this.clientIDPrefix = clientIDPrefix;\n    }\n    protected synchronized IdGenerator getClientIdGenerator() {\n        if (clientIdGenerator == null) {\n            if (clientIDPrefix != null) {\n                clientIdGenerator = new IdGenerator(clientIDPrefix);\n            } else {\n                clientIdGenerator = new IdGenerator();\n            }\n        }\n        return clientIdGenerator;\n    }\n    protected void setClientIdGenerator(IdGenerator clientIdGenerator) {\n        this.clientIdGenerator = clientIdGenerator;\n    }\n    /**\n     * Sets the prefix used by connection id generator\n     * @param connectionIDPrefix\n     */\n    public void setConnectionIDPrefix(String connectionIDPrefix) {\n        this.connectionIDPrefix = connectionIDPrefix;\n    }\n    protected synchronized IdGenerator getConnectionIdGenerator() {\n        if (connectionIdGenerator == null) {\n            if (connectionIDPrefix != null) {\n                connectionIdGenerator = new IdGenerator(connectionIDPrefix);\n            } else {\n                connectionIdGenerator = new IdGenerator();\n            }\n        }\n        return connectionIdGenerator;\n    }\n    protected void setConnectionIdGenerator(IdGenerator connectionIdGenerator) {\n        this.connectionIdGenerator = connectionIdGenerator;\n    }\n    /**\n     * @return the statsEnabled\n     */\n    public boolean isStatsEnabled() {\n        return this.factoryStats.isEnabled();\n    }\n    /**\n     * @param statsEnabled the statsEnabled to set\n     */\n    public void setStatsEnabled(boolean statsEnabled) {\n        this.factoryStats.setEnabled(statsEnabled);\n    }\n    public synchronized int getProducerWindowSize() {\n        return producerWindowSize;\n    }\n    public synchronized void setProducerWindowSize(int producerWindowSize) {\n        this.producerWindowSize = producerWindowSize;\n    }\n    public long getWarnAboutUnstartedConnectionTimeout() {\n        return warnAboutUnstartedConnectionTimeout;\n    }\n    /**\n     * Enables the timeout from a connection creation to when a warning is\n     * generated if the connection is not properly started via\n     * {@link Connection#start()} and a message is received by a consumer. It is\n     * a very common gotcha to forget to <a\n     * href=\"http://activemq.apache.org/i-am-not-receiving-any-messages-what-is-wrong.html\">start\n     * the connection</a> so this option makes the default case to create a\n     * warning if the user forgets. To disable the warning just set the value to <\n     * 0 (say -1).\n     */\n    public void setWarnAboutUnstartedConnectionTimeout(long warnAboutUnstartedConnectionTimeout) {\n        this.warnAboutUnstartedConnectionTimeout = warnAboutUnstartedConnectionTimeout;\n    }\n    public TransportListener getTransportListener() {\n        return transportListener;\n    }\n    /**\n     * Allows a listener to be configured on the ConnectionFactory so that when this factory is used\n     * with frameworks which don't expose the Connection such as Spring JmsTemplate, you can still register\n     * a transport listener.\n     *\n     * @param transportListener sets the listener to be registered on all connections\n     * created by this factory\n     */\n    public void setTransportListener(TransportListener transportListener) {\n        this.transportListener = transportListener;\n    }\n    public ExceptionListener getExceptionListener() {\n        return exceptionListener;\n    }\n    /**\n     * Allows an {@link ExceptionListener} to be configured on the ConnectionFactory so that when this factory\n     * is used by frameworks which don't expose the Connection such as Spring JmsTemplate, you can register\n     * an exception listener.\n     * <p> Note: access to this exceptionLinstener will <b>not</b> be serialized if it is associated with more than\n     * on connection (as it will be if more than one connection is subsequently created by this connection factory)\n     * @param exceptionListener sets the exception listener to be registered on all connections\n     * created by this factory\n     */\n    public void setExceptionListener(ExceptionListener exceptionListener) {\n        this.exceptionListener = exceptionListener;\n    }\n    public int getAuditDepth() {\n        return auditDepth;\n    }\n    public void setAuditDepth(int auditDepth) {\n        this.auditDepth = auditDepth;\n    }\n    public int getAuditMaximumProducerNumber() {\n        return auditMaximumProducerNumber;\n    }\n    public void setAuditMaximumProducerNumber(int auditMaximumProducerNumber) {\n        this.auditMaximumProducerNumber = auditMaximumProducerNumber;\n    }\n    public void setUseDedicatedTaskRunner(boolean useDedicatedTaskRunner) {\n        this.useDedicatedTaskRunner = useDedicatedTaskRunner;\n    }\n    public boolean isUseDedicatedTaskRunner() {\n        return useDedicatedTaskRunner;\n    }\n    public void setConsumerFailoverRedeliveryWaitPeriod(long consumerFailoverRedeliveryWaitPeriod) {\n        this.consumerFailoverRedeliveryWaitPeriod = consumerFailoverRedeliveryWaitPeriod;\n    }\n<fim_suffix>    public long getConsumerFailoverRedeliveryWaitPeriod() {\n        return consumerFailoverRedeliveryWaitPeriod;\n    }<fim_middle>// function below has no smell\n"}