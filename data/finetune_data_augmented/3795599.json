{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.alibaba.jstorm.utils;\n\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.concurrent.LinkedBlockingDeque;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Expires keys that have not been updated in the configured number of seconds.\n * The algorithm used will take between expirationSecs and expirationSecs * (1 + 1 / (numBuckets-1))\n * to actually expire the message.\n *\n * get, put, remove, containsKey, and size take O(numBuckets) time to run.\n *\n * The advantage of this design is that the expiration thread only locks the object for O(1) time,\n * meaning the object is essentially always available for poll/offer\n */\npublic class TimeCacheQueue<K> {\n    // this default ensures things expire at most 50% past the expiration time\n    public static final int DEFAULT_NUM_BUCKETS = 3;\n\n    public interface ExpiredCallback<K> {\n        void expire(K entry);\n    }\n\n<fim_suffix>    public static class DefaultExpiredCallback<K> implements ExpiredCallback<K> {\n        protected static final Logger LOG = LoggerFactory.getLogger(TimeCacheQueue.DefaultExpiredCallback.class);\n\n        protected String queueName;\n\n        public DefaultExpiredCallback(String queueName) {\n            this.queueName = queueName;\n        }\n\n        public void expire(K entry) {\n            LOG.info(\"TimeCacheQueue \" + queueName + \" entry:\" + entry + \", timeout\");\n        }\n    }\n\n    protected LinkedList<LinkedBlockingDeque<K>> _buckets;\n\n    protected final Object _lock = new Object();\n    protected Thread _cleaner;\n    protected ExpiredCallback _callback;\n\n    public TimeCacheQueue(int expirationSecs, int numBuckets, ExpiredCallback<K> callback) {\n        if (numBuckets < 2) {\n            throw new IllegalArgumentException(\"numBuckets must be >= 2\");\n        }\n        _buckets = new LinkedList<>();\n        for (int i = 0; i < numBuckets; i++) {\n            _buckets.add(new LinkedBlockingDeque<K>());\n        }\n\n        _callback = callback;\n        final long expirationMillis = expirationSecs * 1000L;\n        final long sleepTime = expirationMillis / (numBuckets - 1);\n        _cleaner = new Thread(new Runnable() {\n            public void run() {\n                try {\n                    while (true) {\n                        LinkedBlockingDeque<K> dead;\n\n                        Thread.sleep(sleepTime);\n\n                        synchronized (_lock) {\n                            dead = _buckets.removeLast();\n                            _buckets.addFirst(new LinkedBlockingDeque<K>());\n                        }\n                        if (_callback != null) {\n                            for (K entry : dead) {\n                                _callback.expire(entry);\n                            }\n                        }\n                    }\n                } catch (InterruptedException ignored) {\n                }\n            }\n        });\n        _cleaner.setDaemon(true);\n        _cleaner.start();\n    }\n\n    public TimeCacheQueue(int expirationSecs, ExpiredCallback<K> callback) {\n        this(expirationSecs, DEFAULT_NUM_BUCKETS, callback);\n    }\n\n    public TimeCacheQueue(int expirationSecs) {\n        this(expirationSecs, DEFAULT_NUM_BUCKETS, null);\n    }\n\n    public TimeCacheQueue(int expirationSecs, int numBuckets) {\n        this(expirationSecs, numBuckets, null);\n    }\n\n    public boolean containsKey(K entry) {\n        synchronized (_lock) {\n            for (LinkedBlockingDeque<K> bucket : _buckets) {\n                if (bucket.contains(entry)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n\n    public K poll() {\n        synchronized (_lock) {\n            Iterator<LinkedBlockingDeque<K>> itr = _buckets.descendingIterator();\n            while (itr.hasNext()) {\n                LinkedBlockingDeque<K> bucket = itr.next();\n                K entry = bucket.poll();\n                if (entry != null) {\n                    return entry;\n                }\n            }\n\n            return null;\n        }\n    }\n\n    public void offer(K entry) {\n        synchronized (_lock) {\n            LinkedBlockingDeque<K> bucket = _buckets.getFirst();\n\n            bucket.offer(entry);\n        }\n    }\n\n    public void remove(K entry) {\n        synchronized (_lock) {\n            for (LinkedBlockingDeque<K> bucket : _buckets) {\n                if (bucket.contains(entry)) {\n                    bucket.remove(entry);\n                    return;\n                }\n            }\n        }\n    }\n\n    public int size() {\n        synchronized (_lock) {\n            int size = 0;\n            for (LinkedBlockingDeque<K> bucket : _buckets) {\n                size += bucket.size();\n            }\n            return size;\n        }\n    }\n\n    @Override\n    protected void finalize() throws Throwable {\n        try {\n            _cleaner.interrupt();\n        } finally {\n            super.finalize();\n        }\n    }\n\n}<fim_middle>// class below has no smell\n"}