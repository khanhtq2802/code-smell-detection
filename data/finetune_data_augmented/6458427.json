{"text": "<fim_prefix>/*******************************************************************************\n * Copyright (c) 2015 IBH SYSTEMS GmbH.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     IBH SYSTEMS GmbH - initial API and implementation\n *******************************************************************************/\npackage org.eclipse.packagedrone.repo.channel.impl;\nimport static java.util.stream.Collectors.toSet;\nimport static org.eclipse.packagedrone.repo.channel.ChannelService.NAME_PATTERN;\nimport java.time.Instant;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\nimport org.eclipse.packagedrone.repo.channel.deploy.DeployGroup;\nimport org.eclipse.packagedrone.repo.channel.deploy.DeployKey;\nimport org.eclipse.packagedrone.repo.channel.impl.model.ChannelConfiguration;\nimport org.eclipse.packagedrone.repo.utils.Tokens;\nimport org.eclipse.packagedrone.utils.Holder;\nimport com.google.common.collect.LinkedHashMultimap;\nimport com.google.common.collect.Multimap;\npublic class ChannelServiceModify implements ChannelServiceAccess\n{\n    private final ChannelServiceModel model;\n    private final Multimap<String, String> idToNameMap;\n    private final Map<String, String> nameToIdMap;\n    /**\n     * A map holding the deploy groups\n     */\n    private final Map<String, DeployGroup> deployGroups;\n    /**\n     * A map holding the deploy keys\n     */\n    private final Map<String, DeployKey> deployKeys;\n    /**\n     * A map holding the channel configuration information\n     */\n    private final Map<String, ChannelConfiguration> channels;\n    public ChannelServiceModify ( final ChannelServiceModel model )\n    {\n        this.model = new ChannelServiceModel ( model );\n        this.nameToIdMap = new HashMap<> ();\n        this.idToNameMap = LinkedHashMultimap.create ();\n        for ( final Map.Entry<String, List<String>> entry : model.getNameMap ().entrySet () )\n        {\n            this.idToNameMap.putAll ( entry.getKey (), entry.getValue () );\n            entry.getValue ().stream ().forEach ( name -> this.nameToIdMap.put ( name, entry.getKey () ) );\n        }\n        this.deployGroups = model.getDeployGroups ().stream ().collect ( Collectors.toMap ( DeployGroup::getId, i -> i ) );\n        this.deployKeys = model.getDeployGroups ().stream ().flatMap ( group -> group.getKeys ().stream () ).collect ( Collectors.toMap ( DeployKey::getId, i -> i ) );\n        this.channels = new HashMap<> ( model.getChannels ().size () );\n        for ( final Map.Entry<String, ChannelConfiguration> entry : model.getChannels ().entrySet () )\n        {\n            this.channels.put ( entry.getKey (), new ChannelConfiguration ( entry.getValue () ) );\n        }\n    }\n    public ChannelServiceModify ( final ChannelServiceModify other )\n    {\n        this ( other.model );\n        // FIXME: improve speed\n    }\n    @Override\n    public String mapToId ( final String name )\n    {\n        return this.nameToIdMap.get ( name );\n    }\n    public void putMapping ( final String channelId, final String name )\n    {\n        if ( name == null || name.isEmpty () )\n        {\n            return;\n        }\n        channelExists ( channelId );\n        checkChannelName ( name );\n        if ( this.nameToIdMap.containsKey ( name ) )\n        {\n            throw new IllegalStateException ( String.format ( \"There already is a channel with the name '%s'\", name ) );\n        }\n        this.nameToIdMap.put ( name, channelId );\n        this.idToNameMap.put ( channelId, name );\n        this.model.getNameMap ().put ( channelId, new ArrayList<> ( this.idToNameMap.get ( channelId ) ) );\n    }\n    private void channelExists ( final String channelId )\n    {\n        if ( !this.channels.containsKey ( channelId ) )\n        {\n            throw new IllegalArgumentException ( String.format ( \"Channel '%s' does not exists\", channelId ) );\n        }\n    }\n    /**\n     * Check if the name is a valid channel name\n     *\n     * @param name\n     *            the name to check\n     * @throws IllegalArgumentException\n     *             if the name is not a valid channel name\n     */\n    private static void checkChannelName ( final String name )\n    {\n        if ( !NAME_PATTERN.matcher ( name ).matches () )\n        {\n            throw new IllegalArgumentException ( String.format ( \"Channel name must match pattern: %s\", NAME_PATTERN.pattern () ) );\n        }\n    }\n<fim_suffix>    public String deleteMapping ( final String channelId, final String name )\n    {\n        if ( !this.idToNameMap.containsEntry ( channelId, name ) )\n        {\n            return null;\n        }\n        this.nameToIdMap.remove ( name );\n        this.idToNameMap.remove ( channelId, name );\n        final Collection<String> names = this.model.getNameMap ().get ( channelId );\n        if ( names != null )\n        {\n            names.remove ( name );\n        }\n        return channelId;\n    }\n    public void createChannel ( final String channelId, final ChannelConfiguration cfg )\n    {\n        this.channels.put ( channelId, cfg );\n        this.model.getChannels ().put ( channelId, cfg );\n    }\n    public void deleteChannel ( final String channelId )\n    {\n        // delete channel name mapping\n        clearChannelNameMappings ( channelId );\n        // remove channel\n        this.model.getChannels ().remove ( channelId );\n        this.channels.remove ( channelId );\n        // delete channel group mapping\n        this.model.getDeployGroupMap ().remove ( channelId );\n    }\n    private void clearChannelNameMappings ( final String channelId )\n    {\n        final Collection<String> names = this.idToNameMap.removeAll ( channelId );\n        if ( names != null )\n        {\n            names.forEach ( this.nameToIdMap::remove );\n        }\n        this.model.getNameMap ().remove ( channelId );\n    }\n    ChannelServiceModel getModel ()\n    {\n        return this.model;\n    }\n    public DeployGroup createGroup ( final String name )\n    {\n        final DeployGroup result = new DeployGroup ( UUID.randomUUID ().toString (), name, Collections.emptyList () );\n        internalAdd ( result );\n        return result;\n    }\n    @Override\n    public DeployGroup getDeployGroup ( final String groupId )\n    {\n        return this.deployGroups.get ( groupId );\n    }\n    @Override\n    public Map<String, Set<String>> getDeployGroupMap ()\n    {\n        return Collections.unmodifiableMap ( this.model.getDeployGroupMap () );\n    }\n    public void updateGroup ( final String groupId, final String name )\n    {\n        modifyGroup ( groupId, old -> new DeployGroup ( old.getId (), name, old.getKeys () ) );\n    }\n    private void internalAdd ( final DeployGroup group )\n    {\n        this.model.getDeployGroups ().add ( group );\n        this.deployGroups.put ( group.getId (), group );\n        group.getKeys ().forEach ( key -> this.deployKeys.put ( key.getId (), key ) );\n    }\n    private DeployGroup internalRemove ( final String groupId )\n    {\n        final DeployGroup result = this.deployGroups.remove ( groupId );\n        if ( result != null )\n        {\n            this.model.getDeployGroups ().remove ( result );\n            // remove all keys from the deployKey map\n            result.getKeys ().stream ().map ( DeployKey::getId ).forEach ( this.deployKeys::remove );\n        }\n        return result;\n    }\n    public void deleteGroup ( final String groupId )\n    {\n        final DeployGroup group = internalRemove ( groupId );\n        if ( group != null )\n        {\n            // iterate over all channel -> group assignments and remove the groups\n            boolean cleanup = false;\n            for ( final Set<String> groups : this.model.getDeployGroupMap ().values () )\n            {\n                if ( groups.remove ( groupId ) )\n                {\n                    cleanup = true;\n                }\n            }\n            if ( cleanup )\n            {\n                // remove empty groups from the model map\n                final Iterator<Set<String>> i = this.model.getDeployGroupMap ().values ().iterator ();\n                while ( i.hasNext () )\n                {\n                    if ( i.next ().isEmpty () )\n                    {\n                        i.remove ();\n                    }\n                }\n            }\n        }\n    }\n    @Override\n    public List<DeployGroup> getDeployGroups ()\n    {\n        return Collections.unmodifiableList ( this.model.getDeployGroups () );\n    }<fim_middle>// function below has no smell\n"}