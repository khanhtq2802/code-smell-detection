{"text": "<fim_prefix>\n<fim_suffix>public class GroupByMergingQueryRunnerV2 implements QueryRunner<Row>\n{\n  private static final Logger log = new Logger(GroupByMergingQueryRunnerV2.class);\n  private static final String CTX_KEY_MERGE_RUNNERS_USING_CHAINED_EXECUTION = \"mergeRunnersUsingChainedExecution\";\n  private final GroupByQueryConfig config;\n  private final Iterable<QueryRunner<Row>> queryables;\n  private final ListeningExecutorService exec;\n  private final QueryWatcher queryWatcher;\n  private final int concurrencyHint;\n  private final BlockingPool<ByteBuffer> mergeBufferPool;\n  private final ObjectMapper spillMapper;\n  private final String processingTmpDir;\n  private final int mergeBufferSize;\n  public GroupByMergingQueryRunnerV2(\n      GroupByQueryConfig config,\n      ExecutorService exec,\n      QueryWatcher queryWatcher,\n      Iterable<QueryRunner<Row>> queryables,\n      int concurrencyHint,\n      BlockingPool<ByteBuffer> mergeBufferPool,\n      int mergeBufferSize,\n      ObjectMapper spillMapper,\n      String processingTmpDir\n  )\n  {\n    this.config = config;\n    this.exec = MoreExecutors.listeningDecorator(exec);\n    this.queryWatcher = queryWatcher;\n    this.queryables = Iterables.unmodifiableIterable(Iterables.filter(queryables, Predicates.notNull()));\n    this.concurrencyHint = concurrencyHint;\n    this.mergeBufferPool = mergeBufferPool;\n    this.spillMapper = spillMapper;\n    this.processingTmpDir = processingTmpDir;\n    this.mergeBufferSize = mergeBufferSize;\n  }\n  @Override\n  public Sequence<Row> run(final QueryPlus<Row> queryPlus, final Map<String, Object> responseContext)\n  {\n    final GroupByQuery query = (GroupByQuery) queryPlus.getQuery();\n    final GroupByQueryConfig querySpecificConfig = config.withOverrides(query);\n    // CTX_KEY_MERGE_RUNNERS_USING_CHAINED_EXECUTION is here because realtime servers use nested mergeRunners calls\n    // (one for the entire query and one for each sink). We only want the outer call to actually do merging with a\n    // merge buffer, otherwise the query will allocate too many merge buffers. This is potentially sub-optimal as it\n    // will involve materializing the results for each sink before starting to feed them into the outer merge buffer.\n    // I'm not sure of a better way to do this without tweaking how realtime servers do queries.\n    final boolean forceChainedExecution = query.getContextBoolean(\n        CTX_KEY_MERGE_RUNNERS_USING_CHAINED_EXECUTION,\n        false\n    );\n    final QueryPlus<Row> queryPlusForRunners = queryPlus\n        .withQuery(\n            query.withOverriddenContext(ImmutableMap.of(CTX_KEY_MERGE_RUNNERS_USING_CHAINED_EXECUTION, true))\n        )\n        .withoutThreadUnsafeState();\n    if (QueryContexts.isBySegment(query) || forceChainedExecution) {\n      ChainedExecutionQueryRunner<Row> runner = new ChainedExecutionQueryRunner<>(exec, queryWatcher, queryables);\n      return runner.run(queryPlusForRunners, responseContext);\n    }\n    final boolean isSingleThreaded = querySpecificConfig.isSingleThreaded();\n    final AggregatorFactory[] combiningAggregatorFactories = new AggregatorFactory[query.getAggregatorSpecs().size()];\n    for (int i = 0; i < query.getAggregatorSpecs().size(); i++) {\n      combiningAggregatorFactories[i] = query.getAggregatorSpecs().get(i).getCombiningFactory();\n    }\n    final File temporaryStorageDirectory = new File(\n        processingTmpDir,\n        StringUtils.format(\"druid-groupBy-%s_%s\", UUID.randomUUID(), query.getId())\n    );\n    final int priority = QueryContexts.getPriority(query);\n    // Figure out timeoutAt time now, so we can apply the timeout to both the mergeBufferPool.take and the actual\n    // query processing together.\n    final long queryTimeout = QueryContexts.getTimeout(query);\n    final boolean hasTimeout = QueryContexts.hasTimeout(query);\n    final long timeoutAt = System.currentTimeMillis() + queryTimeout;\n    return new BaseSequence<>(\n        new BaseSequence.IteratorMaker<Row, CloseableGrouperIterator<RowBasedKey, Row>>()\n        {\n          @Override\n          public CloseableGrouperIterator<RowBasedKey, Row> make()\n          {\n            final List<ReferenceCountingResourceHolder> resources = new ArrayList<>();\n            try {\n              final LimitedTemporaryStorage temporaryStorage = new LimitedTemporaryStorage(\n                  temporaryStorageDirectory,\n                  querySpecificConfig.getMaxOnDiskStorage()\n              );\n              final ReferenceCountingResourceHolder<LimitedTemporaryStorage> temporaryStorageHolder =\n                  ReferenceCountingResourceHolder.fromCloseable(temporaryStorage);\n              resources.add(temporaryStorageHolder);\n              // If parallelCombine is enabled, we need two merge buffers for parallel aggregating and parallel combining\n              final int numMergeBuffers = querySpecificConfig.getNumParallelCombineThreads() > 1 ? 2 : 1;\n              final List<ReferenceCountingResourceHolder<ByteBuffer>> mergeBufferHolders = getMergeBuffersHolder(\n                  numMergeBuffers,\n                  hasTimeout,\n                  timeoutAt\n              );\n              resources.addAll(mergeBufferHolders);\n              final ReferenceCountingResourceHolder<ByteBuffer> mergeBufferHolder = mergeBufferHolders.get(0);\n              final ReferenceCountingResourceHolder<ByteBuffer> combineBufferHolder = numMergeBuffers == 2 ?\n                                                                                      mergeBufferHolders.get(1) :\n                                                                                      null;\n              Pair<Grouper<RowBasedKey>, Accumulator<AggregateResult, Row>> pair =\n                  RowBasedGrouperHelper.createGrouperAccumulatorPair(\n                      query,\n                      false,\n                      null,\n                      config,\n                      Suppliers.ofInstance(mergeBufferHolder.get()),\n                      combineBufferHolder,\n                      concurrencyHint,\n                      temporaryStorage,\n                      spillMapper,\n                      combiningAggregatorFactories,\n                      exec,\n                      priority,\n                      hasTimeout,\n                      timeoutAt,\n                      mergeBufferSize\n                  );\n              final Grouper<RowBasedKey> grouper = pair.lhs;\n              final Accumulator<AggregateResult, Row> accumulator = pair.rhs;\n              grouper.init();\n              final ReferenceCountingResourceHolder<Grouper<RowBasedKey>> grouperHolder =\n                  ReferenceCountingResourceHolder.fromCloseable(grouper);\n              resources.add(grouperHolder);\n              ListenableFuture<List<AggregateResult>> futures = Futures.allAsList(\n                  Lists.newArrayList(\n                      Iterables.transform(\n                          queryables,\n                          new Function<QueryRunner<Row>, ListenableFuture<AggregateResult>>()\n                          {\n                            @Override\n                            public ListenableFuture<AggregateResult> apply(final QueryRunner<Row> input)\n                            {\n                              if (input == null) {\n                                throw new ISE(\n                                    \"Null queryRunner! Looks to be some segment unmapping action happening\"\n                                );\n                              }\n                              ListenableFuture<AggregateResult> future = exec.submit(\n                                  new AbstractPrioritizedCallable<AggregateResult>(priority)\n                                  {\n                                    @Override\n                                    public AggregateResult call()\n                                    {\n                                      try (\n                                          // These variables are used to close releasers automatically.\n                                          @SuppressWarnings(\"unused\")\n                                          Releaser bufferReleaser = mergeBufferHolder.increment();\n                                          @SuppressWarnings(\"unused\")\n                                          Releaser grouperReleaser = grouperHolder.increment()\n                                      ) {\n                                        final AggregateResult retVal = input.run(queryPlusForRunners, responseContext)\n                                                                            .accumulate(\n                                                                                AggregateResult.ok(),\n                                                                                accumulator\n                                                                            );\n                                        // Return true if OK, false if resources were exhausted.\n                                        return retVal;\n                                      }\n                                      catch (QueryInterruptedException e) {\n                                        throw e;\n                                      }\n                                      catch (Exception e) {\n                                        log.error(e, \"Exception with one of the sequences!\");\n                                        throw new RuntimeException(e);\n                                      }\n                                    }\n                                  }\n                              );\n                              if (isSingleThreaded) {\n                                waitForFutureCompletion(\n                                    query,\n                                    Futures.allAsList(ImmutableList.of(future)),\n                                    hasTimeout,\n                                    timeoutAt - System.currentTimeMillis()\n                                );\n                              }\n                              return future;\n                            }\n                          }\n                      )\n                  )\n              );\n              if (!isSingleThreaded) {\n                waitForFutureCompletion(query, futures, hasTimeout, timeoutAt - System.currentTimeMillis());\n              }\n              return RowBasedGrouperHelper.makeGrouperIterator(\n                  grouper,\n                  query,\n                  new Closeable()\n                  {\n                    @Override\n                    public void close()\n                    {\n                      for (Closeable closeable : Lists.reverse(resources)) {\n                        CloseQuietly.close(closeable);\n                      }\n                    }\n                  }\n              );\n            }\n            catch (Throwable e) {\n              // Exception caught while setting up the iterator; release resources.\n              for (Closeable closeable : Lists.reverse(resources)) {\n                CloseQuietly.close(closeable);\n              }\n              throw e;\n            }\n          }\n          @Override\n          public void cleanup(CloseableGrouperIterator<RowBasedKey, Row> iterFromMake)\n          {\n            iterFromMake.close();\n          }\n        }\n    );\n  }\n  private List<ReferenceCountingResourceHolder<ByteBuffer>> getMergeBuffersHolder(<fim_middle>// class below is blob\n"}