{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.io;\n\nimport org.apache.hadoop.hive.serde2.objectinspector.ObjectInspector;\nimport org.apache.hadoop.hive.serde2.objectinspector.ObjectInspectorFactory;\nimport org.apache.hadoop.hive.serde2.objectinspector.primitive.PrimitiveObjectInspectorFactory;\nimport org.apache.hadoop.hive.serde2.typeinfo.TypeInfo;\nimport org.apache.hadoop.hive.serde2.typeinfo.TypeInfoFactory;\nimport org.apache.hadoop.io.WritableComparable;\n\nimport java.io.DataInput;\nimport java.io.DataOutput;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * Gives the Record identifier information for the current record.\n */\npublic class RecordIdentifier implements WritableComparable<RecordIdentifier> {\n  /**\n   * This is in support of {@link org.apache.hadoop.hive.ql.metadata.VirtualColumn#ROWID}\n   * Contains metadata about each field in RecordIdentifier that needs to be part of ROWID\n   * which is represented as a struct {@link org.apache.hadoop.hive.ql.io.RecordIdentifier.StructInfo}.\n   * Each field of RecordIdentifier which should be part of ROWID should be in this enum... which \n   * really means that it should be part of VirtualColumn (so make a subclass for rowid).\n   */\n  public enum Field {\n    //note the enum names match field names in the struct\n    writeId(TypeInfoFactory.longTypeInfo,\n      PrimitiveObjectInspectorFactory.javaLongObjectInspector),\n    bucketId(TypeInfoFactory.intTypeInfo, PrimitiveObjectInspectorFactory.javaIntObjectInspector),\n    rowId(TypeInfoFactory.longTypeInfo, PrimitiveObjectInspectorFactory.javaLongObjectInspector);\n    public final TypeInfo fieldType;\n    public final ObjectInspector fieldOI;\n    Field(TypeInfo fieldType, ObjectInspector fieldOI) {\n      this.fieldType = fieldType;\n      this.fieldOI = fieldOI;\n    }\n  }\n  /**\n   * RecordIdentifier is passed along the operator tree as a struct.  This class contains a few\n   * utilities for that.\n   */\n  public static final class StructInfo {\n    private static final List<String> fieldNames = new ArrayList<String>(Field.values().length);\n    private static final List<TypeInfo> fieldTypes = new ArrayList<TypeInfo>(fieldNames.size());\n    private static final List<ObjectInspector> fieldOis = \n      new ArrayList<ObjectInspector>(fieldNames.size());\n    static {\n      for(Field f : Field.values()) {\n        fieldNames.add(f.name());\n        fieldTypes.add(f.fieldType);\n        fieldOis.add(f.fieldOI);\n      }\n    }\n    public static final TypeInfo typeInfo = \n      TypeInfoFactory.getStructTypeInfo(fieldNames, fieldTypes);\n    public static final ObjectInspector oi = \n      ObjectInspectorFactory.getStandardStructObjectInspector(fieldNames, fieldOis);\n\n    /**\n     * Copies relevant fields from {@code ri} to {@code struct}\n     * @param ri\n     * @param struct must be of size Field.values().size()\n     */\n    public static void toArray(RecordIdentifier ri, Object[] struct) {\n      assert struct != null && struct.length == Field.values().length;\n      if(ri == null) {\n        Arrays.fill(struct, null);\n        return;\n      }\n      struct[Field.writeId.ordinal()] = ri.getWriteId();\n      struct[Field.bucketId.ordinal()] = ri.getBucketProperty();\n      struct[Field.rowId.ordinal()] = ri.getRowId();\n    }\n  }\n  \n  private long writeId;\n  private int bucketId;\n  private long rowId;\n\n  public RecordIdentifier() {\n  }\n\n  public RecordIdentifier(long writeId, int bucket, long rowId) {\n    this.writeId = writeId;\n    this.bucketId = bucket;\n    this.rowId = rowId;\n  }\n\n  /**\n   * Set the identifier.\n   * @param writeId the write id\n   * @param bucketId the bucket id\n   * @param rowId the row id\n   */\n  public void setValues(long writeId, int bucketId, long rowId) {\n    this.writeId = writeId;\n    this.bucketId = bucketId;\n    this.rowId = rowId;\n  }\n\n  /**\n   * Set this object to match the given object.\n   * @param other the object to copy from\n   */\n  public void set(RecordIdentifier other) {\n    this.writeId = other.writeId;\n    this.bucketId = other.bucketId;\n    this.rowId = other.rowId;\n  }\n\n  public void setRowId(long rowId) {\n    this.rowId = rowId;\n  }\n\n  /**\n   * What was the original write id for the last row?\n   * @return the write id\n   */\n  public long getWriteId() {\n    return writeId;\n  }\n\n  /**\n   * See {@link BucketCodec} for details\n   * @return the bucket value;\n   */\n  public int getBucketProperty() {\n    return bucketId;\n  }\n\n  /**\n   * What was the original row id for the last row?\n   * @return the row id\n   */\n  public long getRowId() {\n    return rowId;\n  }\n\n  protected int compareToInternal(RecordIdentifier other) {\n    if (other == null) {\n      return -1;\n    }\n    if (writeId != other.writeId) {\n      return writeId < other.writeId ? -1 : 1;\n    }\n    if (bucketId != other.bucketId) {\n      return bucketId < other.bucketId ? - 1 : 1;\n    }\n    if (rowId != other.rowId) {\n      return rowId < other.rowId ? -1 : 1;\n    }\n    return 0;\n  }\n\n<fim_suffix>  @Override\n  public int compareTo(RecordIdentifier other) {\n    if (other.getClass() != RecordIdentifier.class) {\n      //WTF?  assumes that other instanceof OrcRawRecordMerger.ReaderKey???\n      return -other.compareTo(this);\n    }\n    return compareToInternal(other);\n  }\n\n  @Override\n  public void write(DataOutput dataOutput) throws IOException {\n    dataOutput.writeLong(writeId);\n    dataOutput.writeInt(bucketId);\n    dataOutput.writeLong(rowId);\n  }\n\n  @Override\n  public void readFields(DataInput dataInput) throws IOException {\n    writeId = dataInput.readLong();\n    bucketId = dataInput.readInt();\n    rowId = dataInput.readLong();\n  }\n\n  @Override\n  public boolean equals(Object other) {\n    if(other == this) {\n      return true;\n    }\n    if (other == null || other.getClass() != getClass()) {\n      return false;\n    }\n    RecordIdentifier oth = (RecordIdentifier) other;\n    return oth.writeId == writeId &&\n        oth.bucketId == bucketId &&\n        oth.rowId == rowId;\n  }\n  @Override\n  public int hashCode() {\n    int result = 17;\n    result = 31 * result + (int)(writeId ^ (writeId >>> 32));\n    result = 31 * result + bucketId;\n    result = 31 * result + (int)(rowId ^ (rowId >>> 32));\n    return result;\n  }\n\n  @Override\n  public String toString() {\n    return \"RecordIdentifier(\" + writeId + \", \" + bucketToString(bucketId) + \",\"\n        + getRowId() +\")\";\n  }\n  public static String bucketToString(int bucketId) {\n    if (bucketId == -1) return \"\" + bucketId;\n    BucketCodec codec =\n      BucketCodec.determineVersion(bucketId);\n    return  bucketId + \"(\" + codec.getVersion() + \".\" +\n        codec.decodeWriterId(bucketId) + \".\" +\n        codec.decodeStatementId(bucketId) + \")\";\n  }\n}<fim_middle>// function below has no smell\n"}