{"text": "<fim_prefix>// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\npackage streamer;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport streamer.debug.FakeSink;\nimport streamer.debug.FakeSource;\npublic class PipelineImpl implements Pipeline {\n    protected String id;\n    protected boolean verbose = System.getProperty(\"streamer.Pipeline.debug\", \"false\").equals(\"true\");\n    public PipelineImpl(String id) {\n        this.id = id;\n        elements = initElementMap(id);\n    }\n    protected Map<String, Element> elements;\n    protected HashMap<String, Element> initElementMap(String id) {\n        HashMap<String, Element> map = new HashMap<String, Element>();\n        map.put(IN, new BaseElement(id + \".\" + IN));\n        map.put(OUT, new BaseElement(id + \".\" + OUT));\n        return map;\n    }\n    @Override\n    public Link getLink(String padName) {\n        Link link = elements.get(IN).getLink(padName);\n        if (link == null)\n            link = elements.get(OUT).getLink(padName);\n        return link;\n    }\n    @Override\n    public Set<String> getPads(Direction direction) {\n        switch (direction) {\n        case IN:\n            return elements.get(IN).getPads(direction);\n        case OUT:\n            return elements.get(OUT).getPads(direction);\n        }\n        return null;\n    }\n    @Override\n    public void validate() {\n        for (Element element : elements.values())\n            element.validate();\n        // Check IN element\n        {\n            Element element = get(IN);\n            int outPadsNumber = element.getPads(Direction.OUT).size();\n            int inPadsNumber = element.getPads(Direction.IN).size();\n            if ((outPadsNumber | inPadsNumber) > 0 && (outPadsNumber == 0 || inPadsNumber == 0))\n                throw new RuntimeException(\"[ \" + this + \"] Pads of input element of pipeline are not balanced. Element: \" + element + \", output pads: \"\n                        + element.getPads(Direction.OUT).toString() + \", input pads: \" + element.getPads(Direction.IN).toString() + \".\");\n        }\n        // Check OUT element\n        {\n            Element element = get(OUT);\n            int outPadsNumber = element.getPads(Direction.OUT).size();\n            int inPadsNumber = element.getPads(Direction.IN).size();\n            if ((outPadsNumber | inPadsNumber) > 0 && (outPadsNumber == 0 || inPadsNumber == 0))\n                throw new RuntimeException(\"[ \" + this + \"] Pads of output element of pipeline are not balanced. Element: \" + element + \", output pads: \"\n                        + element.getPads(Direction.OUT).toString() + \", input pads: \" + element.getPads(Direction.IN).toString() + \".\");\n        }\n    }\n    @Override\n    public void dropLink(String padName) {\n        if (elements.get(IN).getLink(padName) != null)\n            elements.get(IN).dropLink(padName);\n        if (elements.get(OUT).getLink(padName) != null)\n            elements.get(OUT).dropLink(padName);\n    }\n    @Override\n    public void dropLink(Link link) {\n        elements.get(IN).dropLink(link);\n        elements.get(OUT).dropLink(link);\n    }\n    @Override\n    public void replaceLink(Link existingLink, Link newLink) {\n        elements.get(IN).replaceLink(existingLink, newLink);\n        elements.get(OUT).replaceLink(existingLink, newLink);\n    }\n    @Override\n    public void setLink(String padName, Link link, Direction direction) {\n        // Wire links to internal elements instead\n        elements.get(direction.toString()).setLink(padName, link, direction);\n    }\n    @Override\n    public void poll(boolean block) {\n        throw new RuntimeException(\"Not implemented.\");\n    }\n    @Override\n    public void handleData(ByteBuffer buf, Link link) {\n        get(IN).handleData(buf, link);\n    }\n    @Override\n    public void handleEvent(Event event, Direction direction) {\n        switch (direction) {\n        case IN:\n            get(IN).handleEvent(event, direction);\n            break;\n        case OUT:\n            get(OUT).handleEvent(event, direction);\n            break;\n        }\n    }\n    @Override\n    public void add(Element... elements) {\n        for (Element element : elements) {\n            String id = element.getId();\n            if (this.elements.containsKey(id))\n                throw new RuntimeException(\"This pipeline already contains element with same ID. New element: \" + element + \", existing element: \"\n                        + this.elements.get(id) + \".\");\n            this.elements.put(id, element);\n        }\n    }\n    @Override\n    public void link(String... elementNames) {\n        elementNames = filterOutEmptyStrings(elementNames);\n        if (elementNames.length < 2)\n            throw new RuntimeException(\"At least two elements are necessary to create link between them.\");\n        // Parse array of element and pad names\n        Element elements[] = new Element[elementNames.length];\n        String inputPads[] = new String[elementNames.length];\n        String outputPads[] = new String[elementNames.length];\n        int i = 0;\n        for (String elementName : elementNames) {\n            if (elementName.contains(\"< \")) {\n                inputPads[i] = elementName.substring(0, elementName.indexOf(\"< \"));\n                elementName = elementName.substring(elementName.indexOf(\"< \") + 2);\n            } else {\n                inputPads[i] = STDIN;\n            }\n            if (elementName.contains(\" >\")) {\n                outputPads[i] = elementName.substring(elementName.indexOf(\" >\") + 2);\n                elementName = elementName.substring(0, elementName.indexOf(\" >\"));\n            } else {\n                outputPads[i] = STDOUT;\n            }\n            elements[i] = get(elementName);\n            if (elements[i] == null)\n                throw new RuntimeException(\"Cannot find element by name in this pipeline. Element name: \\\"\" + elementName + \"\\\" (\" + elementNames[i] + \"), pipeline: \"\n                        + this + \".\");\n            i++;\n        }\n        // Link elements\n        for (i = 0; i < elements.length - 1; i++) {\n            Element leftElement = elements[i];\n            Element rightElement = elements[i + 1];\n            String leftPad = outputPads[i];\n            String rightPad = inputPads[i + 1];\n            String linkId = leftElement.getId() + \" >\" + leftPad + \" | \" + rightPad + \"< \" + rightElement.getId();\n            if (verbose)\n                System.out.println(\"[\" + this + \"] INFO: Linking: \" + linkId + \".\");\n            Link link = new SyncLink(linkId);\n            leftElement.setLink(leftPad, link, Direction.OUT);\n            rightElement.setLink(rightPad, link, Direction.IN);\n        }\n    }\n    /**\n     * Filter out empty strings from array and return new array with non-empty\n     * elements only. If array contains no empty string, returns same array.\n     */\n    private String[] filterOutEmptyStrings(String[] strings) {\n        boolean found = false;\n        for (String string : strings) {\n            if (string == null || string.isEmpty()) {\n                found = true;\n                break;\n            }\n        }\n        if (!found)\n            return strings;\n        List<String> filteredStrings = new ArrayList<String>(strings.length);\n        for (String string : strings)\n            if (string != null && !string.isEmpty())\n                filteredStrings.add(string);\n        return filteredStrings.toArray(new String[filteredStrings.size()]);\n    }\n    @Override\n    public void addAndLink(Element... elements) {\n        add(elements);\n        link(elements);\n    }\n    private void link(Element... elements) {\n        String elementNames[] = new String[elements.length];\n        int i = 0;\n        for (Element element : elements) {\n            elementNames[i++] = element.getId();\n        }\n        link(elementNames);\n    }\n    @Override\n    public Element get(String elementName) {\n        return elements.get(elementName);\n    }\n    @Override\n    public Link getLink(String elementName, String padName) {\n        return elements.get(elementName).getLink(padName);\n    }\n<fim_suffix>    @Override\n    public void setLink(String elementName, String padName, Link link, Direction direction) {\n        elements.get(elementName).setLink(padName, link, direction);\n    }<fim_middle>// function below has no smell\n"}