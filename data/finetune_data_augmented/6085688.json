{"text": "<fim_prefix>import ceylon.language.meta.model.ValueModel;\n@Ceylon(major = 8)\n@org.eclipse.ceylon.compiler.java.metadata.Class\n@TypeParameters({\n    @TypeParameter(value = \"Type\", variance = Variance.OUT),\n    @TypeParameter(value = \"Arguments\", variance = Variance.IN, satisfies = \"ceylon.language::Sequential<ceylon.language::Anything>\"),\n    })\npublic class ClassImpl<Type, Arguments extends Sequential<? extends Object>> \n    extends ClassOrInterfaceImpl<Type>\n    implements ceylon.language.meta.model.Class<Type, Arguments>, DefaultValueProvider {\n    @Ignore\n    public final TypeDescriptor $reifiedArguments;\n    private Object instance;\n    private final ceylon.language.meta.model.Type<?> container;\n    private volatile boolean initialized = false;\n    private ConstructorDispatch<Type,Arguments> dispatch = null;\n    // FIXME: get rid of duplicate instantiations of AppliedClassType when the type in question has no type parameters\n    public ClassImpl(@Ignore TypeDescriptor $reifiedType, \n                        @Ignore TypeDescriptor $reifiedArguments,\n                        org.eclipse.ceylon.model.typechecker.model.Type producedType, \n                        ceylon.language.meta.model.Type<?> container, Object instance) {\n        super($reifiedType, producedType);\n        this.$reifiedArguments = $reifiedArguments;\n        this.container = container;\n        this.instance = instance;\n    }\n    @Override\n    @TypeInfo(\"ceylon.language.meta.declaration::ClassDeclaration\")\n    public ceylon.language.meta.declaration.ClassDeclaration getDeclaration() {\n        return (ceylon.language.meta.declaration.ClassDeclaration) super.getDeclaration();\n    }\n    protected boolean hasConstructors() {\n        org.eclipse.ceylon.model.typechecker.model.Class decl = (org.eclipse.ceylon.model.typechecker.model.Class) producedType.getDeclaration();\n        return decl.hasConstructors();\n    }\n    protected boolean hasEnumerated() {\n        org.eclipse.ceylon.model.typechecker.model.Class decl = (org.eclipse.ceylon.model.typechecker.model.Class) producedType.getDeclaration();\n        return decl.hasEnumerated();\n    }\n    void checkConstructor() {\n        ClassDeclarationImpl classDeclaration = (ClassDeclarationImpl)declaration;\n        if(classDeclaration.getAbstract())\n            throw new InvocationException(\"Abstract class cannot be instantiated\");\n        if(classDeclaration.getAnonymous())\n            throw new InvocationException(\"Object class cannot be instantiated\");\n        if (producedType.getDeclaration().isAbstraction())\n            throw new InvocationException(\"Class with overloaded constructors cannot be instantiated\");\n    }\n    ConstructorDispatch<Type, Arguments> getDispatch() {\n        if (!initialized) {\n            synchronized(this) {\n                if (!initialized) {\n                    checkConstructor();\n                    Reference reference;\n                    if (!hasConstructors() && !hasEnumerated()) {\n                        reference = producedType;\n                    } else {\n                        reference = ((org.eclipse.ceylon.model.typechecker.model.Class)declaration.declaration).getDefaultConstructor().appliedReference(producedType, null);\n                    }\n                    this.dispatch = new ConstructorDispatch<Type,Arguments>(\n                            reference,\n                            this, null,\n                            ((Class)producedType.getDeclaration()).getFirstParameterList().getParameters(), \n                            instance);\n                    this.initialized = true;\n                }\n            }\n        }\n        return dispatch;\n    }\n    @Ignore\n    @Override\n    public Type $call$() {\n        ConstructorDispatch<Type, Arguments> dc = getDispatch();\n        if (dc != null) {\n            return dc.$call$();\n        } else {\n            throw new AssertionError(\"class lacks a default constructor\");\n        }\n    }\n    @Ignore\n    @Override\n    public Type $call$(Object arg0) {\n        ConstructorDispatch<Type, Arguments> dc = getDispatch();\n        if (dc != null) {\n            return dc.$call$(arg0);\n        } else {\n            throw new AssertionError(\"class lacks a default constructor\");\n        }\n    }\n    @Ignore\n    @Override\n    public Type $call$(Object arg0, Object arg1) {\n        ConstructorDispatch<Type, Arguments> dc = getDispatch();\n        if (dc != null) {\n            return dc.$call$(arg0, arg1);\n        } else {\n            throw new AssertionError(\"class lacks a default constructor\");\n        }\n    }\n    @Ignore\n    @Override\n    public Type $call$(Object arg0, Object arg1, Object arg2) {\n        ConstructorDispatch<Type, Arguments> dc = getDispatch();\n        if (dc != null) {\n            return dc.$call$(arg0, arg1, arg2);\n        } else {\n            throw new AssertionError(\"class lacks a default constructor\");\n        }\n    }\n    @Ignore\n    @Override\n    public Type $call$(Object... args) {\n        ConstructorDispatch<Type, Arguments> dc = getDispatch();\n        if (dc != null) {\n            return dc.$call$((Object[])args);\n        } else {\n            throw new AssertionError(\"class lacks a default constructor\");\n        }\n    }\n    @Override\n    @Ignore\n    public Type $callvariadic$() {\n        return $call$();\n    }\n    @Override\n    @Ignore\n    public Type $callvariadic$(Sequential<?> varargs) {\n        return $call$(varargs);\n    }\n    @Override\n    @Ignore\n    public Type $callvariadic$(Object arg0,\n            Sequential<?> varargs) {\n        return $call$(arg0, varargs);\n    }\n    @Override\n    @Ignore\n    public Type $callvariadic$(Object arg0,\n            Object arg1, Sequential<?> varargs) {\n        return $call$(arg0, arg1, varargs);\n    }\n    @Override\n    @Ignore\n    public Type $callvariadic$(Object arg0,\n            Object arg1, Object arg2, Sequential<?> varargs) {\n        return $call$(arg0, arg1, arg2, varargs);\n    }\n    @Override\n    @Ignore\n    public Type $callvariadic$(Object... argsAndVarargs) {\n        return $call$((Object[])argsAndVarargs);\n    }\n    @Override\n    @Ignore\n    public Type $callvariadic$(Object arg0) {\n        return $call$(arg0, empty_.get_());\n    }\n    @Override\n    @Ignore\n    public Type $callvariadic$(Object arg0, Object arg1) {\n        return $call$(arg0, arg1, empty_.get_());\n    }\n    @Override\n    @Ignore\n    public Type $callvariadic$(Object arg0, Object arg1, Object arg2) {\n        return $call$(arg0, arg1, arg2, empty_.get_());\n    }\n    @Ignore\n    @Override\n    public short $getVariadicParameterIndex$() {\n        ConstructorDispatch<Type, Arguments> dc = getDispatch();\n        if (dc != null) {\n            return dc.$getVariadicParameterIndex$();\n        } else {\n            throw new AssertionError(\"class lacks a default constructor\");\n        }\n    }\n    @Ignore\n    @Override\n    public Type apply(){\n        return apply(empty_.get_());\n    }\n    @Override\n    public int hashCode() {\n        int result = 1;\n        // in theory, if our instance is the same, our containing type should be the same\n        // and if we don't have an instance we're a toplevel and have no containing type\n        result = 37 * result + (instance == null ? 0 : instance.hashCode());\n        result = 37 * result + getDeclaration().hashCode();\n        result = 37 * result + getTypeArgumentWithVariances().hashCode();\n        return result;\n    }\n    @Override\n    public boolean equals(Object obj) {\n        if(obj == null)\n            return false;\n        if(obj == this)\n            return true;\n        if(obj instanceof ClassImpl == false)\n            return false;\n        ClassImpl<?,?> other = (ClassImpl<?,?>) obj;\n        // in theory, if our instance is the same, our containing type should be the same\n        // and if we don't have an instance we're a toplevel and have no containing type\n        return getDeclaration().equals(other.getDeclaration())\n                && Util.eq(instance, other.instance)\n                && getTypeArgumentWithVariances().equals(other.getTypeArgumentWithVariances());\n    }\n    @Override\n    @TypeInfo(\"ceylon.language.meta.model::Type<ceylon.language::Anything>|ceylon.language::Null\")\n    public ceylon.language.meta.model.Type<?> getContainer(){\n        return container;\n    }\n    @Ignore\n    @Override\n    public TypeDescriptor $getType$() {\n        return TypeDescriptor.klass(ClassImpl.class, $reifiedType, $reifiedArguments);\n    }\n<fim_suffix>    @Override\n    @TypeInfo(\"ceylon.language.meta.model::CallableConstructor<Type,Arguments>|ceylon.language::Null\")\n    public CallableConstructor<Type, Arguments> getDefaultConstructor() {\n        if (hasConstructors() || hasEnumerated()) {\n            Object ctor = getConstructor($reifiedArguments, \"\");\n            if (ctor instanceof CallableConstructor) {\n                return ((CallableConstructor<Type, Arguments>)ctor);\n            } else {\n                return null;\n            }\n        } else {\n            return new ClassInitializerConstructor<>(this);\n        }\n    }<fim_middle>// function below has no smell\n"}