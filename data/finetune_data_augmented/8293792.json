{"text": "<fim_prefix>import com.datastax.driver.core.UDTValue;\nimport com.github.fge.lambdas.Throwing;\nimport com.github.steveash.guavate.Guavate;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport reactor.core.publisher.Mono;\npublic class CassandraMailRepositoryMailDAO implements CassandraMailRepositoryMailDaoAPI {\n    private final CassandraAsyncExecutor executor;\n    private final PreparedStatement insertMail;\n    private final PreparedStatement deleteMail;\n    private final PreparedStatement selectMail;\n    private final BlobId.Factory blobIdFactory;\n    private final CassandraTypesProvider cassandraTypesProvider;\n    @Inject\n    @VisibleForTesting\n    CassandraMailRepositoryMailDAO(Session session, BlobId.Factory blobIdFactory,\n                                   CassandraTypesProvider cassandraTypesProvider) {\n        this.executor = new CassandraAsyncExecutor(session);\n        this.insertMail = prepareInsert(session);\n        this.deleteMail = prepareDelete(session);\n        this.selectMail = prepareSelect(session);\n        this.blobIdFactory = blobIdFactory;\n        this.cassandraTypesProvider = cassandraTypesProvider;\n    }\n    private PreparedStatement prepareDelete(Session session) {\n        return session.prepare(delete()\n            .from(CONTENT_TABLE_NAME)\n            .where(eq(REPOSITORY_NAME, bindMarker(REPOSITORY_NAME)))\n            .and(eq(MAIL_KEY, bindMarker(MAIL_KEY))));\n    }\n    private PreparedStatement prepareInsert(Session session) {\n        return session.prepare(insertInto(CONTENT_TABLE_NAME)\n            .value(REPOSITORY_NAME, bindMarker(REPOSITORY_NAME))\n            .value(MAIL_KEY, bindMarker(MAIL_KEY))\n            .value(MESSAGE_SIZE, bindMarker(MESSAGE_SIZE))\n            .value(STATE, bindMarker(STATE))\n            .value(SENDER, bindMarker(SENDER))\n            .value(RECIPIENTS, bindMarker(RECIPIENTS))\n            .value(ATTRIBUTES, bindMarker(ATTRIBUTES))\n            .value(ERROR_MESSAGE, bindMarker(ERROR_MESSAGE))\n            .value(REMOTE_ADDR, bindMarker(REMOTE_ADDR))\n            .value(REMOTE_HOST, bindMarker(REMOTE_HOST))\n            .value(LAST_UPDATED, bindMarker(LAST_UPDATED))\n            .value(HEADER_BLOB_ID, bindMarker(HEADER_BLOB_ID))\n            .value(BODY_BLOB_ID, bindMarker(BODY_BLOB_ID))\n            .value(PER_RECIPIENT_SPECIFIC_HEADERS, bindMarker(PER_RECIPIENT_SPECIFIC_HEADERS)));\n    }\n    private PreparedStatement prepareSelect(Session session) {\n        return session.prepare(\n            select(MAIL_PROPERTIES)\n                .from(CONTENT_TABLE_NAME)\n                .where(eq(REPOSITORY_NAME, bindMarker(REPOSITORY_NAME)))\n                .and(eq(MAIL_KEY, bindMarker(MAIL_KEY))));\n    }\n    @Override\n    public Mono<Void> store(MailRepositoryUrl url, Mail mail, BlobId headerId, BlobId bodyId) {\n        return Mono.fromCallable(() -> insertMail.bind()\n                .setString(REPOSITORY_NAME, url.asString())\n                .setString(MAIL_KEY, mail.getName())\n                .setString(HEADER_BLOB_ID, headerId.asString())\n                .setString(BODY_BLOB_ID, bodyId.asString())\n                .setString(STATE, mail.getState())\n                .setString(SENDER, mail.getMaybeSender().asString(null))\n                .setList(RECIPIENTS, asStringList(mail.getRecipients()))\n                .setString(ERROR_MESSAGE, mail.getErrorMessage())\n                .setString(REMOTE_ADDR, mail.getRemoteAddr())\n                .setString(REMOTE_HOST, mail.getRemoteHost())\n                .setLong(MESSAGE_SIZE, mail.getMessageSize())\n                .setTimestamp(LAST_UPDATED, mail.getLastUpdated())\n                .setMap(ATTRIBUTES, toRawAttributeMap(mail))\n                .setMap(PER_RECIPIENT_SPECIFIC_HEADERS, toHeaderMap(mail.getPerRecipientSpecificHeaders())))\n            .flatMap(executor::executeVoid);\n    }\n    @Override\n    public Mono<Void> remove(MailRepositoryUrl url, MailKey key) {\n        return executor.executeVoid(deleteMail.bind()\n            .setString(REPOSITORY_NAME, url.asString())\n            .setString(MAIL_KEY, key.asString()));\n    }\n    @Override\n    public Mono<Optional<MailDTO>> read(MailRepositoryUrl url, MailKey key) {\n        return executor.executeSingleRowOptional(selectMail.bind()\n                .setString(REPOSITORY_NAME, url.asString())\n                .setString(MAIL_KEY, key.asString()))\n            .map(rowOptional -> rowOptional.map(this::toMail));\n    }\n    private MailDTO toMail(Row row) {\n        MaybeSender sender = Optional.ofNullable(row.getString(SENDER))\n            .map(MaybeSender::getMailSender)\n            .orElse(MaybeSender.nullSender());\n        List<MailAddress> recipients = row.getList(RECIPIENTS, String.class)\n            .stream()\n            .map(Throwing.function(MailAddress::new))\n            .collect(Guavate.toImmutableList());\n        String state = row.getString(STATE);\n        String remoteAddr = row.getString(REMOTE_ADDR);\n        String remoteHost = row.getString(REMOTE_HOST);\n        String errorMessage = row.getString(ERROR_MESSAGE);\n        String name = row.getString(MAIL_KEY);\n        Date lastUpdated = row.getTimestamp(LAST_UPDATED);\n        Map<String, ByteBuffer> rawAttributes = row.getMap(ATTRIBUTES, String.class, ByteBuffer.class);\n        PerRecipientHeaders perRecipientHeaders = fromHeaderMap(row.getMap(PER_RECIPIENT_SPECIFIC_HEADERS, String.class, UDTValue.class));\n        MailImpl.Builder mailBuilder = MailImpl.builder()\n            .name(name)\n            .sender(sender)\n            .addRecipients(recipients)\n            .lastUpdated(lastUpdated)\n            .errorMessage(errorMessage)\n            .remoteHost(remoteHost)\n            .remoteAddr(remoteAddr)\n            .state(state)\n            .addAllHeadersForRecipients(perRecipientHeaders)\n            .addAttributes(toAttributes(rawAttributes));\n        return new MailDTO(mailBuilder,\n            blobIdFactory.from(row.getString(HEADER_BLOB_ID)),\n            blobIdFactory.from(row.getString(BODY_BLOB_ID)));\n    }\n    private ImmutableList<Attribute> toAttributes(Map<String, ByteBuffer> rowAttributes) {\n        return rowAttributes.entrySet()\n            .stream()\n            .map(entry -> new Attribute(AttributeName.of(entry.getKey()), fromByteBuffer(entry.getValue())))\n            .collect(Guavate.toImmutableList());\n    }\n    private ImmutableList<String> asStringList(Collection<MailAddress> mailAddresses) {\n        return mailAddresses.stream().map(MailAddress::asString).collect(Guavate.toImmutableList());\n    }\n    private ImmutableMap<String, ByteBuffer> toRawAttributeMap(Mail mail) {\n        return mail.attributes()\n            .map(attribute -> Pair.of(attribute.getName(), attribute.getValue()))\n            .collect(Guavate.toImmutableMap(\n                pair -> pair.getLeft().asString(),\n                pair -> toByteBuffer((Serializable) pair.getRight().value())));\n    }\n    private ImmutableMap<String, UDTValue> toHeaderMap(PerRecipientHeaders perRecipientHeaders) {\n        return perRecipientHeaders.getHeadersByRecipient()\n            .asMap()\n            .entrySet()\n            .stream()\n            .flatMap(entry -> entry.getValue().stream().map(value -> Pair.of(entry.getKey(), value)))\n            .map(entry -> Pair.of(entry.getKey().asString(),\n                cassandraTypesProvider.getDefinedUserType(HEADER_TYPE)\n                    .newValue()\n                    .setString(HEADER_NAME, entry.getRight().getName())\n                    .setString(HEADER_VALUE, entry.getRight().getValue())))\n            .collect(Guavate.toImmutableMap(Pair::getLeft, Pair::getRight));\n    }\n    private PerRecipientHeaders fromHeaderMap(Map<String, UDTValue> rawMap) {\n        PerRecipientHeaders result = new PerRecipientHeaders();\n        rawMap.forEach((key, value) -> result.addHeaderForRecipient(PerRecipientHeaders.Header.builder()\n                .name(value.getString(HEADER_NAME))\n                .value(value.getString(HEADER_VALUE))\n                .build(),\n            toMailAddress(key)));\n        return result;\n    }\n<fim_suffix>    private ByteBuffer toByteBuffer(Serializable serializable) {\n        try {\n            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n            new ObjectOutputStream(outputStream).writeObject(serializable);\n            return ByteBuffer.wrap(outputStream.toByteArray());\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }<fim_middle>// function below is feature envy\n"}