{"text": "<fim_prefix>            start -= 2;\n        }\n        if (a0 == 0) {\n            return start;\n        }\n        for (int i = start; i < changesReferenceRowCount; i += 2) {\n            if (a0 < changesReferenceRow[i]) {\n                lastChangingElement = i;\n                return i;\n            }\n        }\n        return -1;\n    }\n    private void decodeRowType2() throws IOException {\n        if (optionByteAligned)\n        {\n            resetBuffer();\n        }\n        decode1D();\n    }\n    private void decodeRowType4() throws IOException {\n        if(optionByteAligned) {\n            resetBuffer();\n        }\n        eof: while (true) {\n            // read till next EOL code\n            Node n = eolOnlyTree.root;\n            while (true) {\n                n = n.walk(readBit());\n                if (n == null) {\n                    continue eof;\n                }\n                if (n.isLeaf) {\n                    break eof;\n                }\n            }\n        }\n        if (!optionG32D || readBit()) {\n            decode1D();\n        }\n        else {\n            decode2D();\n        }\n    }\n    private void decodeRowType6() throws IOException {\n        if(optionByteAligned) {\n            resetBuffer();\n        }\n        decode2D();\n    }\n    private void decodeRow() throws IOException {\n        switch (type) {\n            case TIFFExtension.COMPRESSION_CCITT_MODIFIED_HUFFMAN_RLE:\n                decodeRowType2();\n                break;\n            case TIFFExtension.COMPRESSION_CCITT_T4:\n                decodeRowType4();\n                break;\n            case TIFFExtension.COMPRESSION_CCITT_T6:\n                decodeRowType6();\n                break;\n        }\n        int index = 0;\n        boolean white = true;\n            lastChangingElement = 0;\n            for (int i = 0; i <= changesCurrentRowCount; i++) {\n            int nextChange = columns;\n            if (i != changesCurrentRowCount) {\n                nextChange = changesCurrentRow[i];\n            }\n            if (nextChange > columns) {\n                nextChange = columns;\n            }\n            int byteIndex = index / 8;\n            while (index % 8 != 0 && (nextChange - index) > 0) {\n                decodedRow[byteIndex] |= (white ? 0 : 1 << (7 - ((index) % 8)));\n                index++;\n            }\n            if (index % 8 == 0) {\n                byteIndex = index / 8;\n                final byte value = (byte) (white ? 0x00 : 0xff);\n                while ((nextChange - index) > 7) {\n                    decodedRow[byteIndex] = value;\n                    index += 8;\n                    ++byteIndex;\n                }\n            }\n            while ((nextChange - index) > 0) {\n                if (index % 8 == 0) {\n                    decodedRow[byteIndex] = 0;\n                }\n                decodedRow[byteIndex] |= (white ? 0 : 1 << (7 - ((index) % 8)));\n                index++;\n            }\n            white = !white;\n        }\n        if (index != columns) {\n            throw new IOException(\"Sum of run-lengths does not equal scan line width: \" + index + \" > \" + columns);\n        }\n        decodedLength = (index + 7) / 8;\n    }\n    private int decodeRun(final Tree tree) throws IOException {     \n        int total = 0;\n        Node n = tree.root;\n        while (true) {\n            boolean bit = readBit();\n            n = n.walk(bit);\n            if (n == null) {\n                throw new IOException(\"Unknown code in Huffman RLE stream\");\n            }\n            if (n.isLeaf) {\n                total += n.value;\n                if (n.value < 64) {\n                    return total;\n                }\n                else {\n                    n = tree.root;\n                }\n            }\n        }\n    }\n    private void resetBuffer() throws IOException {\n        bufferPos = -1;\n    }\n    int buffer = -1;\n    int bufferPos = -1;\n    private boolean readBit() throws IOException {\n        if (bufferPos < 0 || bufferPos > 7) {\n            buffer = in.read();\n            if (buffer == -1) {\n                throw new EOFException(\"Unexpected end of Huffman RLE stream\");\n            }\n            bufferPos = 0;\n        }\n        boolean isSet;\n        if (fillOrder == TIFFExtension.FILL_LEFT_TO_RIGHT) {\n            isSet = ((buffer >> (7 - bufferPos)) & 1) == 1;\n        }\n        else {\n            isSet = ((buffer >> (bufferPos)) & 1) == 1;\n        }\n        bufferPos++;\n        if (bufferPos > 7) {\n            bufferPos = -1;\n        }\n        return isSet;\n    }\n    @Override\n    public int read() throws IOException {\n        if (decodedLength < 0) {\n            return 0x0;\n        }\n        if (decodedPos >= decodedLength) {\n            fetch();\n            if (decodedLength < 0) {\n                return 0x0;\n            }\n        }\n        return decodedRow[decodedPos++] & 0xff;\n    }\n    @Override\n    public int read(byte[] b, int off, int len) throws IOException {\n        if (decodedLength < 0) {\n            //TODO better? Math.min(off + len, b.length)\n            Arrays.fill(b, off, off + len, (byte) 0x0);\n            return len;\n        }\n        if (decodedPos >= decodedLength) {\n            fetch();\n            if (decodedLength < 0) {\n                Arrays.fill(b, off, off + len, (byte) 0x0);\n                return len;\n            }\n        }\n        int read = Math.min(decodedLength - decodedPos, len);\n        System.arraycopy(decodedRow, decodedPos, b, off, read);\n        decodedPos += read;\n        return read;\n    }\n    @Override\n    public long skip(long n) throws IOException {\n        if (decodedLength < 0) {\n            return -1;\n        }\n        if (decodedPos >= decodedLength) {\n            fetch();\n            if (decodedLength < 0) {\n                return -1;\n            }\n        }\n        int skipped = (int) Math.min(decodedLength - decodedPos, n);\n        decodedPos += skipped;\n        return skipped;\n    }\n    @Override\n    public boolean markSupported() {\n        return false;\n    }\n    @Override\n    public synchronized void reset() throws IOException {\n        throw new IOException(\"mark/reset not supported\");\n    }\n    private static final class Node {\n        Node left;\n        Node right;\n        int value; // > 63 non term.\n        boolean canBeFill = false;\n        boolean isLeaf = false;\n        void set(final boolean next, final Node node) {\n            if (!next) {\n                left = node;\n            }\n            else {\n                right = node;\n            }\n        }\n        Node walk(final boolean next) {\n            return next ? right : left;\n        }\n        @Override\n        public String toString() {\n            return \"[leaf=\" + isLeaf + \", value=\" + value + \", canBeFill=\" + canBeFill + \"]\";\n        }\n    }\n<fim_suffix>    private static final class Tree {\n        final Node root = new Node();\n        void fill(final int depth, final int path, final int value) throws IOException {\n            Node current = root;\n            for (int i = 0; i < depth; i++) {\n                int bitPos = depth - 1 - i;\n                boolean isSet = ((path >> bitPos) & 1) == 1;\n                Node next = current.walk(isSet);\n                if (next == null) {\n                    next = new Node();\n                    if (i == depth - 1) {\n                        next.value = value;\n                        next.isLeaf = true;\n                    }\n                    if (path == 0) {\n                        next.canBeFill = true;\n                    }\n                    current.set(isSet, next);\n                }\n                else {\n                    if (next.isLeaf) {\n                        throw new IOException(\"node is leaf, no other following\");\n                    }\n                }\n                current = next;\n            }\n        }\n        void fill(final int depth, final int path, final Node node) throws IOException {\n            Node current = root;\n            for (int i = 0; i < depth; i++) {\n                int bitPos = depth - 1 - i;\n                boolean isSet = ((path >> bitPos) & 1) == 1;\n                Node next = current.walk(isSet);\n                if (next == null) {\n                    if (i == depth - 1) {\n                        next = node;\n                    }\n                    else {\n                        next = new Node();\n                    }\n                    if (path == 0) {\n                        next.canBeFill = true;\n                    }\n                    current.set(isSet, next);\n                }\n                else {\n                    if (next.isLeaf) {\n                        throw new IOException(\"node is leaf, no other following\");\n                    }\n                }\n                current = next;\n            }\n        }\n    }<fim_middle>// class below has no smell\n"}