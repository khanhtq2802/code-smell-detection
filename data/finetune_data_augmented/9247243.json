{"text": "<fim_prefix>/*\n * Copyright (c) 2005, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\npackage sun.security.jgss;\n\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.EOFException;\nimport sun.security.util.*;\n\n/**\n * Utilities for processing GSS Tokens.\n *\n */\n\npublic abstract class GSSToken {\n\n    /**\n     * Copies an integer value to a byte array in little endian form.\n     * @param value the integer value to write\n     * @param array the byte array into which the integer must be copied. It\n     * is assumed that the array will be large enough to hold the 4 bytes of\n     * the integer.\n     */\n    public static final void writeLittleEndian(int value, byte[] array) {\n        writeLittleEndian(value, array, 0);\n    }\n\n    /**\n     * Copies an integer value to a byte array in little endian form.\n     * @param value the integer value to write\n     * @param array the byte array into which the integer must be copied. It\n     * is assumed that the array will be large enough to hold the 4 bytes of\n     * the integer.\n     * @param pos the position at which to start writing\n     */\n    public static final void writeLittleEndian(int value, byte[] array,\n                                               int pos) {\n        array[pos++] = (byte)(value);\n        array[pos++] = (byte)((value>>>8));\n        array[pos++] = (byte)((value>>>16));\n        array[pos++] = (byte)((value>>>24));\n    }\n\n    public static final void writeBigEndian(int value, byte[] array) {\n        writeBigEndian(value, array, 0);\n    }\n\n    public static final void writeBigEndian(int value, byte[] array,\n                                               int pos) {\n        array[pos++] = (byte)((value>>>24));\n        array[pos++] = (byte)((value>>>16));\n        array[pos++] = (byte)((value>>>8));\n        array[pos++] = (byte)(value);\n    }\n\n    /**\n     * Reads an integer value from a byte array in little endian form. This\n     * method allows the reading of two byte values as well as four bytes\n     * values both of which are needed in the Kerberos v5 GSS-API mechanism.\n     *\n     * @param data the array containing the bytes of the integer value\n     * @param pos the offset in the array\n     * @param size the number of bytes to read from the array.\n     * @return the integer value\n     */\n    public static final int readLittleEndian(byte[] data, int pos, int size) {\n        int retVal = 0;\n        int shifter = 0;\n        while (size > 0) {\n            retVal += (data[pos] & 0xff) << shifter;\n            shifter += 8;\n            pos++;\n            size--;\n        }\n        return retVal;\n    }\n\n    public static final int readBigEndian(byte[] data, int pos, int size) {\n        int retVal = 0;\n        int shifter = (size-1)*8;\n        while (size > 0) {\n            retVal += (data[pos] & 0xff) << shifter;\n            shifter -= 8;\n            pos++;\n            size--;\n        }\n        return retVal;\n    }\n\n    /**\n     * Writes a two byte integer value to a OutputStream.\n     *\n     * @param val the integer value. It will lose the high-order two bytes.\n     * @param os the OutputStream to write to\n     * @throws IOException if an error occurs while writing to the OutputStream\n     */\n    public static final void writeInt(int val, OutputStream os)\n        throws IOException {\n        os.write(val>>>8);\n        os.write(val);\n    }\n\n    /**\n     * Writes a two byte integer value to a byte array.\n     *\n     * @param val the integer value. It will lose the high-order two bytes.\n     * @param dest the byte array to write to\n     * @param pos the offset to start writing to\n     */\n    public static final int writeInt(int val, byte[] dest, int pos) {\n        dest[pos++] = (byte)(val>>>8);\n        dest[pos++] = (byte)val;\n        return pos;\n    }\n\n    /**\n     * Reads a two byte integer value from an InputStream.\n     *\n     * @param is the InputStream to read from\n     * @return the integer value\n     * @throws IOException if some errors occurs while reading the integer\n     * bytes.\n     */\n    public static final int readInt(InputStream is) throws IOException {\n        return (((0xFF & is.read()) << 8)\n                 | (0xFF & is.read()));\n    }\n\n    /**\n     * Reads a two byte integer value from a byte array.\n     *\n     * @param src the byte arra to read from\n     * @param pos the offset to start reading from\n     * @return the integer value\n     */\n    public static final int readInt(byte[] src, int pos) {\n        return ((0xFF & src[pos])<<8 | (0xFF & src[pos+1]));\n    }\n\n    /**\n     * Blocks till the required number of bytes have been read from the\n     * input stream.\n     *\n     * @param is the InputStream to read from\n     * @param buffer the buffer to store the bytes into\n     * @throws EOFException if EOF is reached before all bytes are\n     *         read.\n     * @throws IOException is an error occurs while reading\n     */\n    public static final void readFully(InputStream is, byte[] buffer)\n        throws IOException {\n        readFully(is, buffer, 0, buffer.length);\n    }\n\n    /**\n     * Blocks till the required number of bytes have been read from the\n     * input stream.\n     *\n     * @param is the InputStream to read from\n     * @param buffer the buffer to store the bytes into\n     * @param offset the offset to start storing at\n     * @param len the number of bytes to read\n     * @throws EOFException if EOF is reached before all bytes are\n     *         read.\n     * @throws IOException is an error occurs while reading\n     */\n    public static final void readFully(InputStream is,\n                                       byte[] buffer, int offset, int len)\n        throws IOException {\n        int temp;\n        while (len > 0) {\n            temp = is.read(buffer, offset, len);\n            if (temp == -1)\n                throw new EOFException(\"Cannot read all \"\n                                       + len\n                                       + \" bytes needed to form this token!\");\n            offset += temp;\n            len -= temp;\n        }\n    }\n\n    public static final void debug(String str) {\n        System.err.print(str);\n    }\n\n    public static final  String getHexBytes(byte[] bytes) {\n        return getHexBytes(bytes, 0, bytes.length);\n    }\n\n    public static final  String getHexBytes(byte[] bytes, int len) {\n        return getHexBytes(bytes, 0, len);\n    }\n\n<fim_suffix>    public static final String getHexBytes(byte[] bytes, int pos, int len) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = pos; i < (pos+len); i++) {\n            int b1 = (bytes[i]>>4) & 0x0f;\n            int b2 = bytes[i] & 0x0f;\n\n            sb.append(Integer.toHexString(b1));\n            sb.append(Integer.toHexString(b2));\n            sb.append(' ');\n        }\n        return sb.toString();\n    }\n\n}<fim_middle>// function below has no smell\n"}