{"text": "<fim_prefix>\n<fim_suffix>public class Hierarchy implements LoggerRepository, RendererSupport, ThrowableRendererSupport {\n  private LoggerFactory defaultFactory;\n  private Vector listeners;\n  Hashtable ht;\n  Logger root;\n  RendererMap rendererMap;\n  int thresholdInt;\n  Level threshold;\n  boolean emittedNoAppenderWarning = false;\n  boolean emittedNoResourceBundleWarning = false;\n  private ThrowableRenderer throwableRenderer = null;\n  /**\n     Create a new logger hierarchy.\n     @param root The root of the new hierarchy.\n   */\n  public\n  Hierarchy(Logger root) {\n    ht = new Hashtable();\n    listeners = new Vector(1);\n    this.root = root;\n    // Enable all level levels by default.\n    setThreshold(Level.ALL);\n    this.root.setHierarchy(this);\n    rendererMap = new RendererMap();\n    defaultFactory = new DefaultCategoryFactory();\n  }\n  /**\n     Add an object renderer for a specific class.\n   */\n  public\n  void addRenderer(Class classToRender, ObjectRenderer or) {\n    rendererMap.put(classToRender, or);\n  }\n  public\n  void addHierarchyEventListener(HierarchyEventListener listener) {\n    if(listeners.contains(listener)) {\n      LogLog.warn(\"Ignoring attempt to add an existent listener.\");\n    } else {\n      listeners.addElement(listener);\n    }\n  }\n  /**\n     This call will clear all logger definitions from the internal\n     hashtable. Invoking this method will irrevocably mess up the\n     logger hierarchy.\n     <p>You should <em>really</em> know what you are doing before\n     invoking this method.\n     @since 0.9.0 */\n  public\n  void clear() {\n    //System.out.println(\"\\n\\nAbout to clear internal hash table.\");\n    ht.clear();\n  }\n  public\n  void emitNoAppenderWarning(Category cat) {\n    // No appenders in hierarchy, warn user only once.\n    if(!this.emittedNoAppenderWarning) {\n      LogLog.warn(\"No appenders could be found for logger (\" +\n\t\t   cat.getName() + \").\");\n      LogLog.warn(\"Please initialize the log4j system properly.\");\n      LogLog.warn(\"See http://logging.apache.org/log4j/1.2/faq.html#noconfig for more info.\");\n      this.emittedNoAppenderWarning = true;\n    }\n  }\n  /**\n     Check if the named logger exists in the hierarchy. If so return\n     its reference, otherwise returns <code>null</code>.\n     @param name The name of the logger to search for.\n  */\n  public\n  Logger exists(String name) {\n    Object o = ht.get(new CategoryKey(name));\n    if(o instanceof Logger) {\n      return (Logger) o;\n    } else {\n      return null;\n    }\n  }\n  /**\n     The string form of {@link #setThreshold(Level)}.\n  */\n  public\n  void setThreshold(String levelStr) {\n    Level l = Level.toLevel(levelStr, null);\n    if(l != null) {\n      setThreshold(l);\n    } else {\n      LogLog.warn(\"Could not convert [\"+levelStr+\"] to Level.\");\n    }\n  }\n  /**\n     Enable logging for logging requests with level <code>l</code> or\n     higher. By default all levels are enabled.\n     @param l The minimum level for which logging requests are sent to\n     their appenders.  */\n  public\n  void setThreshold(Level l) {\n    if(l != null) {\n      thresholdInt = l.level;\n      threshold = l;\n    }\n  }\n  public\n  void fireAddAppenderEvent(Category logger, Appender appender) {\n    if(listeners != null) {\n      int size = listeners.size();\n      HierarchyEventListener listener;\n      for(int i = 0; i < size; i++) {\n\tlistener = (HierarchyEventListener) listeners.elementAt(i);\n\tlistener.addAppenderEvent(logger, appender);\n      }\n    }\n  }\n  void fireRemoveAppenderEvent(Category logger, Appender appender) {\n    if(listeners != null) {\n      int size = listeners.size();\n      HierarchyEventListener listener;\n      for(int i = 0; i < size; i++) {\n\tlistener = (HierarchyEventListener) listeners.elementAt(i);\n\tlistener.removeAppenderEvent(logger, appender);\n      }\n    }\n  }\n  /**\n     Returns a {@link Level} representation of the <code>enable</code>\n     state.\n     @since 1.2 */\n  public\n  Level getThreshold() {\n    return threshold;\n  }\n  /**\n     Returns an integer representation of the this repository's\n     threshold.\n     @since 1.2 */\n  //public\n  //int getThresholdInt() {\n  //  return thresholdInt;\n  //}\n  /**\n     Return a new logger instance named as the first parameter using\n     the default factory.\n     <p>If a logger of that name already exists, then it will be\n     returned.  Otherwise, a new logger will be instantiated and\n     then linked with its existing ancestors as well as children.\n     @param name The name of the logger to retrieve.\n */\n  public\n  Logger getLogger(String name) {\n    return getLogger(name, defaultFactory);\n  }\n /**\n     Return a new logger instance named as the first parameter using\n     <code>factory</code>.\n     <p>If a logger of that name already exists, then it will be\n     returned.  Otherwise, a new logger will be instantiated by the\n     <code>factory</code> parameter and linked with its existing\n     ancestors as well as children.\n     @param name The name of the logger to retrieve.\n     @param factory The factory that will make the new logger instance.\n */\n  public\n  Logger getLogger(String name, LoggerFactory factory) {\n    //System.out.println(\"getInstance(\"+name+\") called.\");\n    CategoryKey key = new CategoryKey(name);\n    // Synchronize to prevent write conflicts. Read conflicts (in\n    // getChainedLevel method) are possible only if variable\n    // assignments are non-atomic.\n    Logger logger;\n    synchronized(ht) {\n      Object o = ht.get(key);\n      if(o == null) {\n\tlogger = factory.makeNewLoggerInstance(name);\n\tlogger.setHierarchy(this);\n\tht.put(key, logger);\n\tupdateParents(logger);\n\treturn logger;\n      } else if(o instanceof Logger) {\n\treturn (Logger) o;\n      } else if (o instanceof ProvisionNode) {\n\t//System.out.println(\"(\"+name+\") ht.get(this) returned ProvisionNode\");\n\tlogger = factory.makeNewLoggerInstance(name);\n\tlogger.setHierarchy(this);\n\tht.put(key, logger);\n\tupdateChildren((ProvisionNode) o, logger);\n\tupdateParents(logger);\n\treturn logger;\n      }\n      else {\n\t// It should be impossible to arrive here\n\treturn null;  // but let's keep the compiler happy.\n      }\n    }\n  }\n  /**\n     Returns all the currently defined categories in this hierarchy as\n     an {@link java.util.Enumeration Enumeration}.\n     <p>The root logger is <em>not</em> included in the returned\n     {@link Enumeration}.  */\n  public\n  Enumeration getCurrentLoggers() {\n    // The accumlation in v is necessary because not all elements in\n    // ht are Logger objects as there might be some ProvisionNodes\n    // as well.\n    Vector v = new Vector(ht.size());\n    Enumeration elems = ht.elements();\n    while(elems.hasMoreElements()) {\n      Object o = elems.nextElement();\n      if(o instanceof Logger) {\n\tv.addElement(o);\n      }\n    }\n    return v.elements();\n  }\n  /**\n     @deprecated Please use {@link #getCurrentLoggers} instead.\n   */\n  public\n  Enumeration getCurrentCategories() {\n    return getCurrentLoggers();\n  }\n  /**\n     Get the renderer map for this hierarchy.\n  */\n  public\n  RendererMap getRendererMap() {\n    return rendererMap;\n  }\n  /**\n     Get the root of this hierarchy.\n     @since 0.9.0\n   */\n  public\n  Logger getRootLogger() {\n    return root;\n  }\n  /**\n     This method will return <code>true</code> if this repository is\n     disabled for <code>level</code> object passed as parameter and\n     <code>false</code> otherwise. See also the {@link\n     #setThreshold(Level) threshold} emthod.  */\n  public\n  boolean isDisabled(int level) {\n    return thresholdInt > level;\n  }\n  /**\n     @deprecated Deprecated with no replacement.\n  */\n  public\n  void overrideAsNeeded(String override) {\n    LogLog.warn(\"The Hiearchy.overrideAsNeeded method has been deprecated.\");\n  }\n  /**\n     Reset all values contained in this hierarchy instance to their\n     default.  This removes all appenders from all categories, sets\n     the level of all non-root categories to <code>null</code>,\n     sets their additivity flag to <code>true</code> and sets the level<fim_middle>// class below has no smell\n"}