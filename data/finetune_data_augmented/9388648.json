{"text": "<fim_prefix>/*\n * Copyright (c) 2000, 2004, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n *\n */\npackage sun.jvm.hotspot.ui;\nimport java.awt.BorderLayout;\nimport java.awt.Dimension;\nimport java.awt.event.*;\nimport java.io.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.swing.event.ListSelectionEvent;\nimport javax.swing.event.ListSelectionListener;\nimport javax.swing.table.*;\nimport sun.jvm.hotspot.debugger.*;\nimport sun.jvm.hotspot.runtime.*;\nimport sun.jvm.hotspot.types.*;\nimport sun.jvm.hotspot.ui.action.*;\nimport com.sun.java.swing.ui.*;\nimport com.sun.java.swing.action.*;\n/**\n * This panel contains a JTable which displays the list of Java\n * threads as their native thread identifiers combined with their\n * Java names. It allows selection and examination of any of the\n * threads.\n */\npublic class JavaThreadsPanel extends SAPanel implements ActionListener {\n    private JavaThreadsTableModel dataModel;\n    private StatusBar statusBar;\n    private JTable     threadTable;\n    private java.util.List<CachedThread> cachedThreads = new ArrayList();\n    private static AddressField crashThread;\n    static {\n        VM.registerVMInitializedObserver(\n                            (o, a) -> initialize(VM.getVM().getTypeDataBase()));\n    }\n    private static void initialize(TypeDataBase db) {\n        crashThread = db.lookupType(\"VMError\").getAddressField(\"_thread\");\n    }\n    /** Constructor assumes the threads panel is created while the VM is\n        suspended. Subsequent resume and suspend operations of the VM\n        will cause the threads panel to clear and fill itself back in,\n        respectively. */\n    public JavaThreadsPanel() {\n        VM.getVM().registerVMResumedObserver(new Observer() {\n                public void update(Observable o, Object data) {\n                    decache();\n                }\n            });\n        VM.getVM().registerVMSuspendedObserver(new Observer() {\n                public void update(Observable o, Object data) {\n                    cache();\n                }\n            });\n        cache();\n        setLayout(new BorderLayout());\n        dataModel = new JavaThreadsTableModel(cachedThreads);\n        statusBar = new StatusBar();\n        threadTable = new JTable(dataModel, new JavaThreadsColumnModel());\n        threadTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n        threadTable.addMouseListener(new MouseAdapter() {\n                public void mouseClicked(MouseEvent evt) {\n                    if (evt.getClickCount() == 2) {\n                        // double clicking will display the oop inspector.\n                        fireShowThreadOopInspector();\n                    }\n                }\n            });\n        add(new JavaThreadsToolBar(statusBar), BorderLayout.NORTH);\n        add(new ThreadPanel(threadTable), BorderLayout.CENTER);\n        add(statusBar, BorderLayout.SOUTH);\n        registerActions();\n    }\n    /**\n     * A splitpane panel which contains the thread table and the Thread Info.\n     * the thread info is toggleable\n     */\n    private class ThreadPanel extends JPanel {\n        private JSplitPane splitPane;\n        private JTable threadTable;\n        private ThreadInfoPanel threadInfo;\n        private int dividerSize;\n        private int dividerLocation = -1;\n        private boolean actionsEnabled = false;\n        public ThreadPanel(JTable table) {\n            setLayout(new BorderLayout());\n            this.threadInfo = new ThreadInfoPanel();\n            this.threadTable = table;\n            splitPane = new JSplitPane(JSplitPane.VERTICAL_SPLIT);\n            splitPane.setOneTouchExpandable(true);\n            splitPane.setTopComponent(new JScrollPane(table));\n            // Set the size of the divider to 0 but save it so it can be restored\n            dividerSize = splitPane.getDividerSize();\n            splitPane.setDividerSize(0);\n            add(splitPane, BorderLayout.CENTER);\n            // Register an ItemListener on the LogViewerAction which toggles\n            // the apearance of the ThreadInfoPanel\n            ActionManager manager = HSDBActionManager.getInstance();\n            StateChangeAction action = manager.getStateChangeAction(ThreadInfoAction.VALUE_COMMAND);\n            if (action != null) {\n                action.setItemListener(new ItemListener() {\n                        public void itemStateChanged(ItemEvent evt) {\n                            if (evt.getStateChange() == ItemEvent.SELECTED) {\n                                showOutputPane();\n                            } else {\n                                hideOutputPane();\n                            }\n                        }\n                    });\n            }\n            // A listener is added to listen to changes in row selection\n            // and changes the contents of the ThreadInfoPanel.\n            ListSelectionModel selModel = table.getSelectionModel();\n            selModel.addListSelectionListener(new ListSelectionListener() {\n                    public void valueChanged(ListSelectionEvent evt) {\n                        if (evt.getValueIsAdjusting() == false) {\n                            setActionsEnabled(true);\n                            if (isInfoVisible()) {\n                                showCurrentThreadInfo();\n                            }\n                        }\n                    }\n                });\n        }\n        /**\n         * Returns a flag to indicate if the thread info is visible\n         */\n        private boolean isInfoVisible() {\n            return (splitPane.getBottomComponent() != null);\n        }\n        private void showOutputPane()  {\n            if (splitPane.getBottomComponent() == null)  {\n                splitPane.setBottomComponent(threadInfo);\n                if (dividerLocation == -1)  {\n                    // Calculate the divider location from the pref size.\n                    Dimension pSize = this.getSize();\n                    dividerLocation = pSize.height / 2;\n                }\n                splitPane.setDividerSize(dividerSize);\n                splitPane.setDividerLocation(dividerLocation);\n                showCurrentThreadInfo();\n            }\n        }\n        private void hideOutputPane()  {\n            dividerLocation = splitPane.getDividerLocation();\n            splitPane.remove(threadInfo);\n            splitPane.setDividerSize(0);\n        }\n        private void showCurrentThreadInfo() {\n            int row = threadTable.getSelectedRow();\n            if (row >= 0) {\n                threadInfo.setJavaThread(dataModel.getJavaThread(row));\n            }\n        }\n        private void setActionsEnabled(boolean enabled) {\n            if (actionsEnabled != enabled) {\n                ActionManager manager = ActionManager.getInstance();\n                manager.setActionEnabled(InspectAction.VALUE_COMMAND, enabled);\n                manager.setActionEnabled(MemoryAction.VALUE_COMMAND, enabled);\n                manager.setActionEnabled(JavaStackTraceAction.VALUE_COMMAND, enabled);\n                actionsEnabled = enabled;\n            }\n        }\n    } // end ThreadPanel\n<fim_suffix>    private class JavaThreadsToolBar extends CommonToolBar {\n        public JavaThreadsToolBar(StatusBar status) {\n            super(HSDBActionManager.getInstance(), status);\n        }\n        protected void addComponents() {\n            addButton(manager.getAction(InspectAction.VALUE_COMMAND));\n            addButton(manager.getAction(MemoryAction.VALUE_COMMAND));\n            addButton(manager.getAction(JavaStackTraceAction.VALUE_COMMAND));\n            addToggleButton(manager.getStateChangeAction(ThreadInfoAction.VALUE_COMMAND));\n            addButton(manager.getAction(FindCrashesAction.VALUE_COMMAND));\n        }\n    }\n    private class JavaThreadsColumnModel extends DefaultTableColumnModel {\n        private String[] columnNames = { \"OS Thread ID\", \"Java Thread Name\" };\n        public JavaThreadsColumnModel() {\n            // Should actually get the line metrics for\n            int PREF_WIDTH = 80;\n            int MAX_WIDTH = 100;\n            int HUGE_WIDTH = 140;\n            TableColumn column;\n            // Thread ID\n            column = new TableColumn(0, MAX_WIDTH);\n            column.setHeaderValue(columnNames[0]);\n            column.setMaxWidth(MAX_WIDTH);\n            column.setResizable(false);\n            addColumn(column);\n            // Thread name\n            column = new TableColumn(1, HUGE_WIDTH);\n            column.setHeaderValue(columnNames[1]);\n            column.setResizable(false);\n            addColumn(column);\n        }\n    } // end class JavaThreadsColumnModel\n    /**\n     * Encapsulates the set of threads in a table model\n     */\n    private class JavaThreadsTableModel extends AbstractTableModel {<fim_middle>// class below has no smell\n"}