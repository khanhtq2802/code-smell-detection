{"text": "<fim_prefix> * a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage com.facebook.buck.android.agent;\nimport com.facebook.buck.android.agent.util.AgentUtil;\nimport java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.concurrent.TimeUnit;\nimport java.util.logging.Level;\nimport java.util.logging.Logger; // NOPMD\n/**\n * Main class for an agent that runs on an Android device to aid app installation.\n *\n * <p>This does not run as a normal Android app. It is packaged into an APK and installed as a\n * convenient way to get it on the device, but it is run from the \"adb shell\" command line using the\n * \"dalvikvm\" command. Therefore, we do not have an Android Context and therefore cannot interact\n * with any system services.\n */\npublic class AgentMain {\n  private AgentMain() {}\n  public static final int LINE_LENGTH_LIMIT = 4096;\n  public static final int CONNECT_TIMEOUT_MS = 5000;\n  public static final int RECEIVE_TIMEOUT_MS = 20000;\n  public static final int TOTAL_RECEIVE_TIMEOUT_MS_PER_MB = 2000;\n  private static final Logger LOG = Logger.getLogger(AgentMain.class.getName());\n  public static void main(String args[]) {\n    if (args.length == 0) {\n      LOG.severe(\"No command specified\");\n      System.exit(1);\n    }\n    String command = args[0];\n    List<String> userArgs =\n        Collections.unmodifiableList(Arrays.asList(args).subList(1, args.length));\n    try {\n      if (command.equals(\"get-signature\")) {\n        doGetSignature(userArgs);\n      } else if (command.equals(\"mkdir-p\")) {\n        doMkdirP(userArgs);\n      } else if (command.equals(\"multi-receive-file\")) {\n        doMultiReceiveFile(userArgs);\n      } else {\n        throw new IllegalArgumentException(\"Unknown command: \" + command);\n      }\n    } catch (Exception e) {\n      LOG.log(Level.SEVERE, \"Command failed\", e);\n      System.exit(1);\n    }\n    System.exit(0);\n  }\n  /**\n   * Print the signature of an APK to stdout. The APK path is passed as the only command line\n   * argument.\n   */\n  private static void doGetSignature(List<String> userArgs) throws IOException {\n    if (userArgs.size() != 1) {\n      throw new IllegalArgumentException(\"usage: get-signature FILE\");\n    }\n    String packagePath = userArgs.get(0);\n    System.out.println(AgentUtil.getJarSignature(packagePath));\n  }\n  /**\n   * Roughly equivalent to the shell command \"mkdir -p\".\n   *\n   * <p>Note that some (all?) versions of Android will force restrictive permissions on the created\n   * directories.\n   */\n  private static void doMkdirP(List<String> userArgs) throws IOException {\n    if (userArgs.size() != 1) {\n      throw new IllegalArgumentException(\"usage: mkdir -p PATH\");\n    }\n    File path = new File(userArgs.get(0));\n    boolean success = path.mkdirs();\n    if (!success) {\n      throw new IOException(\"Creating directory failed.\");\n    }\n  }\n  private static BufferedInputStream acceptAuthenticConnectionFromClient(int port)\n      throws IOException {\n    BufferedInputStream input;\n    ServerSocket serverSocket = null;\n    try {\n      // First make sure we can bind to the port.\n      serverSocket = new ServerSocket(port);\n      byte[] secretKey = createAndSendSessionKey();\n      // Open the connection with appropriate timeouts.\n      serverSocket.setSoTimeout(CONNECT_TIMEOUT_MS);\n      Socket connectionSocket = serverSocket.accept();\n      connectionSocket.setSoTimeout(RECEIVE_TIMEOUT_MS);\n      input = new BufferedInputStream(connectionSocket.getInputStream());\n      // Report that the socket has been opened.\n      System.out.write(new byte[] {'z', '1', '\\n'});\n      System.out.flush();\n      // NOTE: We leak the client socket if this validation fails,\n      // but this is a short-lived program, so it's probably\n      // not worth the complexity to clean it up.\n      receiveAndValidateSessionKey(secretKey, input);\n    } finally {\n      if (serverSocket != null) {\n        serverSocket.close();\n      }\n    }\n    return input;\n  }\n  private static byte[] createAndSendSessionKey() throws IOException {\n    // Generate a random key to authenticate the network connection.\n    // On some devices, I had trouble using SecureRandom in a non-app context\n    // (it failed to find a native library), so just access urandom directly.\n    byte[] binaryKey = new byte[AgentUtil.BINARY_SECRET_KEY_SIZE];\n    InputStream urandom = new BufferedInputStream(new FileInputStream(\"/dev/urandom\"));\n    try {\n      int got = urandom.read(binaryKey);\n      if (got != binaryKey.length) {\n        throw new RuntimeException(\"Failed to receive sufficient random bytes for key.\");\n      }\n    } finally {\n      urandom.close();\n    }\n    StringBuilder keyBuilder = new StringBuilder();\n    for (byte b : binaryKey) {\n      keyBuilder.append(String.format((Locale) null, \"%02X\", b));\n    }\n    byte[] secretKey = keyBuilder.toString().getBytes();\n    if (secretKey.length != AgentUtil.TEXT_SECRET_KEY_SIZE) {\n      throw new RuntimeException(\"Bug in secret key formatting\");\n    }\n    // Send the key over stdout so only the host can read it.\n    System.out.write(secretKey);\n    System.out.write('\\n');\n    System.out.flush();\n    return secretKey;\n  }\n  private static void receiveAndValidateSessionKey(byte[] secretKey, InputStream clientInput)\n      throws IOException {\n    byte[] receivedKey = new byte[secretKey.length];\n    int receivedKeySize = clientInput.read(receivedKey);\n    if (receivedKeySize != receivedKey.length) {\n      throw new IllegalStateException(\"Did not receive full-length key.\");\n    }\n    if (!Arrays.equals(secretKey, receivedKey)) {\n      throw new IllegalStateException(\"Received incorrect secret key.\");\n    }\n  }\n<fim_suffix>  private static void doRawReceiveFile(File path, int size, InputStream clientInput)\n      throws IOException {\n    // Create a temp file to receive the payload, so we don't need to worry about\n    // partially-received files.  The host takes care of deleting temp files.\n    File tempfile =\n        File.createTempFile(\n            AgentUtil.TEMP_PREFIX + path.getName() + \"-\", \".tmp\", path.getParentFile());\n    FileOutputStream output = new FileOutputStream(tempfile);\n    // Keep track of our starting time so we can enforce a timeout on slow but steady uploads.\n    long receiveStartMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime());\n    // Keep track of the total received size to verify the payload.\n    long totalSize = 0;\n    long totalReceiveTimeoutMs =\n        RECEIVE_TIMEOUT_MS + TOTAL_RECEIVE_TIMEOUT_MS_PER_MB * (size / 1024 / 1024);\n    try {\n      int bufferSize = 128 * 1024;\n      byte[] buf = new byte[bufferSize];\n      while (true) {\n        long currentTimeMs = TimeUnit.NANOSECONDS.toMillis(System.nanoTime());\n        if (currentTimeMs - receiveStartMs > totalReceiveTimeoutMs) {\n          throw new RuntimeException(\"Receive failed to complete before timeout.\");\n        }\n        int remaining = size - (int) totalSize;\n        if (remaining == 0) {\n          break;\n        }\n        int want = bufferSize;\n        if (want > remaining) {\n          want = remaining;\n        }\n        int got = clientInput.read(buf, 0, want);\n        if (got == -1) {\n          break;\n        }\n        output.write(buf, 0, got);\n        totalSize += got;\n      }\n    } finally {\n      output.close();\n    }\n    if (totalSize != size) {\n      throw new RuntimeException(\"Received only \" + totalSize + \" of \" + size + \" bytes.\");\n    }\n    boolean success = tempfile.renameTo(path);\n    if (!success) {\n      throw new RuntimeException(\"Failed to rename temp file.\");\n    }\n  }<fim_middle>// function below is long method\n"}