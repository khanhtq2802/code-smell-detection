{"text": "<fim_prefix>        left = initLeft.add(comparator, e, count, result);\n        if (result[0] == 0) {\n          distinctElements++;\n        }\n        this.totalCount += count;\n        return (left.height == initHeight) ? this : rebalance();\n      } else if (cmp > 0) {\n        AvlNode<E> initRight = right;\n        if (initRight == null) {\n          result[0] = 0;\n          return addRightChild(e, count);\n        }\n        int initHeight = initRight.height;\n        right = initRight.add(comparator, e, count, result);\n        if (result[0] == 0) {\n          distinctElements++;\n        }\n        this.totalCount += count;\n        return (right.height == initHeight) ? this : rebalance();\n      }\n      // adding count to me!  No rebalance possible.\n      result[0] = elemCount;\n      long resultCount = (long) elemCount + count;\n      checkArgument(resultCount <= Integer.MAX_VALUE);\n      this.elemCount += count;\n      this.totalCount += count;\n      return this;\n    }\n    AvlNode<E> remove(Comparator<? super E> comparator, @Nullable E e, int count, int[] result) {\n      int cmp = comparator.compare(e, elem);\n      if (cmp < 0) {\n        AvlNode<E> initLeft = left;\n        if (initLeft == null) {\n          result[0] = 0;\n          return this;\n        }\n        left = initLeft.remove(comparator, e, count, result);\n        if (result[0] > 0) {\n          if (count >= result[0]) {\n            this.distinctElements--;\n            this.totalCount -= result[0];\n          } else {\n            this.totalCount -= count;\n          }\n        }\n        return (result[0] == 0) ? this : rebalance();\n      } else if (cmp > 0) {\n        AvlNode<E> initRight = right;\n        if (initRight == null) {\n          result[0] = 0;\n          return this;\n        }\n        right = initRight.remove(comparator, e, count, result);\n        if (result[0] > 0) {\n          if (count >= result[0]) {\n            this.distinctElements--;\n            this.totalCount -= result[0];\n          } else {\n            this.totalCount -= count;\n          }\n        }\n        return rebalance();\n      }\n      // removing count from me!\n      result[0] = elemCount;\n      if (count >= elemCount) {\n        return deleteMe();\n      } else {\n        this.elemCount -= count;\n        this.totalCount -= count;\n        return this;\n      }\n    }\n    AvlNode<E> setCount(Comparator<? super E> comparator, @Nullable E e, int count, int[] result) {\n      int cmp = comparator.compare(e, elem);\n      if (cmp < 0) {\n        AvlNode<E> initLeft = left;\n        if (initLeft == null) {\n          result[0] = 0;\n          return (count > 0) ? addLeftChild(e, count) : this;\n        }\n        left = initLeft.setCount(comparator, e, count, result);\n        if (count == 0 && result[0] != 0) {\n          this.distinctElements--;\n        } else if (count > 0 && result[0] == 0) {\n          this.distinctElements++;\n        }\n        this.totalCount += count - result[0];\n        return rebalance();\n      } else if (cmp > 0) {\n        AvlNode<E> initRight = right;\n        if (initRight == null) {\n          result[0] = 0;\n          return (count > 0) ? addRightChild(e, count) : this;\n        }\n        right = initRight.setCount(comparator, e, count, result);\n        if (count == 0 && result[0] != 0) {\n          this.distinctElements--;\n        } else if (count > 0 && result[0] == 0) {\n          this.distinctElements++;\n        }\n        this.totalCount += count - result[0];\n        return rebalance();\n      }\n      // setting my count\n      result[0] = elemCount;\n      if (count == 0) {\n        return deleteMe();\n      }\n      this.totalCount += count - elemCount;\n      this.elemCount = count;\n      return this;\n    }\n    AvlNode<E> setCount(\n        Comparator<? super E> comparator,\n        @Nullable E e,\n        int expectedCount,\n        int newCount,\n        int[] result) {\n      int cmp = comparator.compare(e, elem);\n      if (cmp < 0) {\n        AvlNode<E> initLeft = left;\n        if (initLeft == null) {\n          result[0] = 0;\n          if (expectedCount == 0 && newCount > 0) {\n            return addLeftChild(e, newCount);\n          }\n          return this;\n        }\n        left = initLeft.setCount(comparator, e, expectedCount, newCount, result);\n        if (result[0] == expectedCount) {\n          if (newCount == 0 && result[0] != 0) {\n            this.distinctElements--;\n          } else if (newCount > 0 && result[0] == 0) {\n            this.distinctElements++;\n          }\n          this.totalCount += newCount - result[0];\n        }\n        return rebalance();\n      } else if (cmp > 0) {\n        AvlNode<E> initRight = right;\n        if (initRight == null) {\n          result[0] = 0;\n          if (expectedCount == 0 && newCount > 0) {\n            return addRightChild(e, newCount);\n          }\n          return this;\n        }\n        right = initRight.setCount(comparator, e, expectedCount, newCount, result);\n        if (result[0] == expectedCount) {\n          if (newCount == 0 && result[0] != 0) {\n            this.distinctElements--;\n          } else if (newCount > 0 && result[0] == 0) {\n            this.distinctElements++;\n          }\n          this.totalCount += newCount - result[0];\n        }\n        return rebalance();\n      }\n      // setting my count\n      result[0] = elemCount;\n      if (expectedCount == elemCount) {\n        if (newCount == 0) {\n          return deleteMe();\n        }\n        this.totalCount += newCount - elemCount;\n        this.elemCount = newCount;\n      }\n      return this;\n    }\n    private AvlNode<E> deleteMe() {\n      int oldElemCount = this.elemCount;\n      this.elemCount = 0;\n      successor(pred, succ);\n      if (left == null) {\n        return right;\n      } else if (right == null) {\n        return left;\n      } else if (left.height >= right.height) {\n        AvlNode<E> newTop = pred;\n        // newTop is the maximum node in my left subtree\n        newTop.left = left.removeMax(newTop);\n        newTop.right = right;\n        newTop.distinctElements = distinctElements - 1;\n        newTop.totalCount = totalCount - oldElemCount;\n        return newTop.rebalance();\n      } else {\n        AvlNode<E> newTop = succ;\n        newTop.right = right.removeMin(newTop);\n        newTop.left = left;\n        newTop.distinctElements = distinctElements - 1;\n        newTop.totalCount = totalCount - oldElemCount;\n        return newTop.rebalance();\n      }\n    }\n    // Removes the minimum node from this subtree to be reused elsewhere\n    private AvlNode<E> removeMin(AvlNode<E> node) {\n      if (left == null) {\n        return right;\n      } else {\n        left = left.removeMin(node);\n        distinctElements--;\n        totalCount -= node.elemCount;\n        return rebalance();\n      }\n    }\n    // Removes the maximum node from this subtree to be reused elsewhere\n    private AvlNode<E> removeMax(AvlNode<E> node) {\n      if (right == null) {\n        return left;\n      } else {\n        right = right.removeMax(node);\n        distinctElements--;\n        totalCount -= node.elemCount;\n        return rebalance();\n      }\n    }\n    private void recomputeMultiset() {\n      this.distinctElements =\n          1 + TreeMultiset.distinctElements(left) + TreeMultiset.distinctElements(right);\n      this.totalCount = elemCount + totalCount(left) + totalCount(right);\n    }\n<fim_suffix>    private void recomputeHeight() {\n      this.height = 1 + Math.max(height(left), height(right));\n    }<fim_middle>// function below has no smell\n"}