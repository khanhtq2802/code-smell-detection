{"text": "<fim_prefix>  final TreeMap<String, Dest> routes = Maps.newTreeMap(); // path->dest\n  /**\n   * Add a route to the router.\n   * e.g., add(GET, \"/foo/show\", FooController.class, \"show\", [name...]);\n   * The name list is from /foo/show/:name/...\n   */\n  synchronized Dest add(WebApp.HTTP httpMethod, String path,\n                        Class<? extends Controller> cls,\n                        String action, List<String> names) {\n    LOG.debug(\"adding {}({})->{}#{}\", new Object[]{path, names, cls, action});\n    Dest dest = addController(httpMethod, path, cls, action, names);\n    addDefaultView(dest);\n    return dest;\n  }\n  private Dest addController(WebApp.HTTP httpMethod, String path,\n                             Class<? extends Controller> cls,\n                             String action, List<String> names) {\n    try {\n      // Look for the method in all public methods declared in the class\n      // or inherited by the class.\n      // Note: this does not distinguish methods with the same signature\n      // but different return types.\n      // TODO: We may want to deal with methods that take parameters in the future\n      Method method = cls.getMethod(action, null);\n      Dest dest = routes.get(path);\n      if (dest == null) {\n        method.setAccessible(true); // avoid any runtime checks\n        dest = new Dest(path, method, cls, names, httpMethod);\n        routes.put(path, dest);\n        return dest;\n      }\n      dest.methods.add(httpMethod);\n      return dest;\n    } catch (NoSuchMethodException nsme) {\n      throw new WebAppException(action + \"() not found in \" + cls);\n    } catch (SecurityException se) {\n      throw new WebAppException(\"Security exception thrown for \" + action +\n        \"() in \" + cls);\n    }\n  }\n  private void addDefaultView(Dest dest) {\n    String controllerName = dest.controllerClass.getSimpleName();\n    if (controllerName.endsWith(\"Controller\")) {\n      controllerName = controllerName.substring(0,\n          controllerName.length() - 10);\n    }\n    dest.defaultViewClass = find(View.class,\n                                 dest.controllerClass.getPackage().getName(),\n                                 join(controllerName + \"View\"));\n  }\n  void setHostClass(Class<?> cls) {\n    hostClass = cls;\n  }\n  /**\n   * Resolve a path to a destination.\n   */\n  synchronized Dest resolve(String httpMethod, String path) {\n    WebApp.HTTP method = WebApp.HTTP.valueOf(httpMethod); // can throw\n    Dest dest = lookupRoute(method, path);\n    if (dest == null) {\n      return resolveDefault(method, path);\n    }\n    return dest;\n  }\n  private Dest lookupRoute(WebApp.HTTP method, String path) {\n    String key = path;\n    do {\n      Dest dest = routes.get(key);\n      if (dest != null && methodAllowed(method, dest)) {\n        if ((Object)key == path) { // shut up warnings\n          LOG.debug(\"exact match for {}: {}\", key, dest.action);\n          return dest;\n        } else if (isGoodMatch(dest, path)) {\n          LOG.debug(\"prefix match2 for {}: {}\", key, dest.action);\n          return dest;\n        }\n        return resolveAction(method, dest, path);\n      }\n      Map.Entry<String, Dest> lower = routes.lowerEntry(key);\n      if (lower == null) {\n        return null;\n      }\n      dest = lower.getValue();\n      if (prefixMatches(dest, path)) {\n        if (methodAllowed(method, dest)) {\n          if (isGoodMatch(dest, path)) {\n            LOG.debug(\"prefix match for {}: {}\", lower.getKey(), dest.action);\n            return dest;\n          }\n          return resolveAction(method, dest, path);\n        }\n        // check other candidates\n        int slashPos = key.lastIndexOf('/');\n        key = slashPos > 0 ? path.substring(0, slashPos) : \"/\";\n      } else {\n        key = \"/\";\n      }\n    } while (true);\n  }\n  static boolean methodAllowed(WebApp.HTTP method, Dest dest) {\n    // Accept all methods by default, unless explicity configured otherwise.\n    return dest.methods.contains(method) || (dest.methods.size() == 1 &&\n           dest.methods.contains(WebApp.HTTP.GET));\n  }\n  static boolean prefixMatches(Dest dest, String path) {\n    LOG.debug(\"checking prefix {}{} for path: {}\", new Object[]{dest.prefix,\n              dest.pathParams, path});\n    if (!path.startsWith(dest.prefix)) {\n      return false;\n    }\n    int prefixLen = dest.prefix.length();\n    if (prefixLen > 1 && path.length() > prefixLen &&\n        path.charAt(prefixLen) != '/') {\n      return false;\n    }\n    // prefix is / or prefix is path or prefix/...\n    return true;\n  }\n  static boolean isGoodMatch(Dest dest, String path) {\n    if (SLASH.countIn(dest.prefix) > 1) {\n      return true;\n    }\n    // We want to match (/foo, :a) for /foo/bar/blah and (/, :a) for /123\n    // but NOT / for /foo or (/, :a) for /foo or /foo/ because default route\n    // (FooController#index) for /foo and /foo/ takes precedence.\n    if (dest.prefix.length() == 1) {\n      return dest.pathParams.size() > 0 && !maybeController(path);\n    }\n    return dest.pathParams.size() > 0 || // /foo should match /foo/\n        (path.endsWith(\"/\") && SLASH.countIn(path) == 2);\n  }\n  static boolean maybeController(String path) {\n    return controllerRe.matcher(path).matches();\n  }\n  // Assume /controller/action style path\n  private Dest resolveDefault(WebApp.HTTP method, String path) {\n    List<String> parts = WebApp.parseRoute(path);\n    String controller = parts.get(WebApp.R_CONTROLLER);\n    String action = parts.get(WebApp.R_ACTION);\n    // NameController is encouraged default\n    Class<? extends Controller> cls = find(Controller.class,\n                                           join(controller, \"Controller\"));\n    if (cls == null) {\n      cls = find(Controller.class, controller);\n    }\n    if (cls == null) {\n      throw new WebAppException(join(path, \": controller for \", controller,\n                                \" not found\"));\n    }\n    return add(method, defaultPrefix(controller, action), cls, action, null);\n  }\n  private String defaultPrefix(String controller, String action) {\n    if (controller.equals(\"default\") && action.equals(\"index\")) {\n      return \"/\";\n    }\n    if (action.equals(\"index\")) {\n      return join('/', controller);\n    }\n    return pjoin(\"\", controller, action);\n  }\n  private <T> Class<? extends T> find(Class<T> cls, String cname) {\n    String pkg = hostClass.getPackage().getName();\n    return find(cls, pkg, cname);\n  }\n  private <T> Class<? extends T> find(Class<T> cls, String pkg, String cname) {\n    String name = StringUtils.capitalize(cname);\n    Class<? extends T> found = load(cls, djoin(pkg, name));\n    if (found == null) {\n      found = load(cls, djoin(pkg, \"webapp\", name));\n    }\n    if (found == null) {\n      found = load(cls, join(hostClass.getName(), '$', name));\n    }\n    return found;\n  }\n  @SuppressWarnings(\"unchecked\")\n  private <T> Class<? extends T> load(Class<T> cls, String className) {\n    LOG.debug(\"trying: {}\", className);\n    try {\n      Class<?> found = Class.forName(className);\n      if (cls.isAssignableFrom(found)) {\n        LOG.debug(\"found {}\", className);\n        return (Class<? extends T>) found;\n      }\n      LOG.warn(\"found a {} but it's not a {}\", className, cls.getName());\n    } catch (ClassNotFoundException e) {\n      // OK in this case.\n    }\n    return null;\n  }\n  // Dest may contain a candidate controller\n<fim_suffix>  private Dest resolveAction(WebApp.HTTP method, Dest dest, String path) {\n    if (dest.prefix.length() == 1) {\n      return null;\n    }\n    checkState(!isGoodMatch(dest, path), dest.prefix);\n    checkState(SLASH.countIn(path) > 1, path);\n    List<String> parts = WebApp.parseRoute(path);\n    String controller = parts.get(WebApp.R_CONTROLLER);\n    String action = parts.get(WebApp.R_ACTION);\n    return add(method, pjoin(\"\", controller, action), dest.controllerClass,\n               action, null);\n  }<fim_middle>// function below has no smell\n"}