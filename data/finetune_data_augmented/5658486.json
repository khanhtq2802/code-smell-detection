{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.sis.referencing.operation.transform;\nimport java.util.Arrays;\nimport java.io.Serializable;\nimport org.opengis.parameter.ParameterValueGroup;\nimport org.opengis.parameter.ParameterDescriptorGroup;\nimport org.opengis.referencing.operation.Matrix;\nimport org.opengis.referencing.operation.MathTransform;\nimport org.opengis.referencing.operation.MathTransformFactory;\nimport org.opengis.referencing.operation.NoninvertibleTransformException;\nimport org.apache.sis.referencing.operation.matrix.Matrices;\nimport org.apache.sis.internal.referencing.provider.Affine;\nimport org.apache.sis.internal.referencing.Resources;\nimport org.apache.sis.internal.util.Numerics;\nimport org.apache.sis.util.ComparisonMode;\nimport org.apache.sis.util.resources.Errors;\nimport org.opengis.util.FactoryException;\n/**\n * Base class of linear transforms. For efficiency reasons, this transform implements itself the matrix\n * to be returned by {@link #getMatrix()}.\n *\n * <p>Subclasses need to implement the following methods:</p>\n * <ul>\n *   <li>{@link #getElement(int, int)}</li>\n *   <li>{@link #equalsSameClass(Object)}</li>\n * </ul>\n *\n * @author  Martin Desruisseaux (Geomatys)\n * @version 1.0\n * @since   0.6\n * @module\n */\n@SuppressWarnings(\"CloneInNonCloneableClass\")   // Intentionally not Cloneable despite the clone() method.\nabstract class AbstractLinearTransform extends AbstractMathTransform implements LinearTransform, Matrix, Serializable {\n    /**\n     * For cross-version compatibility.\n     */\n    private static final long serialVersionUID = -4649708313541868599L;\n    /**\n     * The inverse transform, or {@code null} if not yet created.\n     * This field is part of the serialization form in order to avoid rounding errors if a user\n     * asks for the inverse of the inverse (i.e. the original transform) after deserialization.\n     */\n    volatile LinearTransform inverse;\n    /**\n     * Constructs a transform.\n     */\n    AbstractLinearTransform() {\n    }\n    /**\n     * Returns {@code true} if this transform is affine.\n     *\n     * @return {@code true} if this transform is affine, or {@code false} otherwise.\n     */\n    @Override\n    public boolean isAffine() {\n        return Matrices.isAffine(this);\n    }\n    /**\n     * Returns a copy of the matrix that user can modify.\n     */\n<fim_suffix>    @Override\n    @SuppressWarnings(\"CloneDoesntCallSuperClone\")\n    public final Matrix clone() {\n        return Matrices.copy(this);\n    }\n    /**\n     * Returns an immutable view of the matrix for this transform.\n     */\n    @Override\n    public final Matrix getMatrix() {\n        return this;\n    }\n    /**\n     * Gets the number of rows in the matrix.\n     */\n    @Override\n    public int getNumRow() {\n        return getTargetDimensions() + 1;\n    }\n    /**\n     * Gets the number of columns in the matrix.\n     */\n    @Override\n    public int getNumCol() {\n        return getSourceDimensions() + 1;\n    }\n    /**\n     * Returns an identity transform if this transform is the inverse of the given transform.\n     * If this method is unsure, it conservatively returns {@code null}.\n     */\n    @Override\n    protected final MathTransform tryConcatenate(boolean applyOtherFirst, MathTransform other, MathTransformFactory factory)\n            throws FactoryException\n    {\n        if (other instanceof LinearTransform) {\n            return super.tryConcatenate(applyOtherFirst, other, factory);\n        }\n        return null;        // No need to compute the inverse if the other transform is not linear.\n    }\n    /**\n     * Creates the inverse transform of this object.\n     */\n    @Override\n    @SuppressWarnings(\"DoubleCheckedLocking\")                           // Okay since 'inverse' is volatile.\n    public LinearTransform inverse() throws NoninvertibleTransformException {\n        LinearTransform inv = inverse;\n        if (inv == null) {\n            synchronized (this) {\n                inv = inverse;\n                if (inv == null) {\n                    /*\n                     * Should never be the identity transform at this point (except during tests) because\n                     * MathTransforms.linear(\u2026) should never instantiate this class in the identity case.\n                     * But we check anyway as a paranoiac safety.\n                     */\n                    if (isIdentity()) {\n                        inv = this;\n                    } else {\n                        inv = MathTransforms.linear(Matrices.inverse(this));\n                        if (inv instanceof AbstractLinearTransform) {\n                            ((AbstractLinearTransform) inv).inverse = this;\n                        }\n                    }\n                    inverse = inv;\n                }\n            }\n        }\n        return inv;\n    }\n    /**\n     * Returns the parameter descriptors for this math transform.\n     *\n     * @return {@inheritDoc}\n     */\n    @Override\n    public ParameterDescriptorGroup getParameterDescriptors() {\n        return Affine.getProvider(getSourceDimensions(), getTargetDimensions(), isAffine()).getParameters();\n    }\n    /**\n     * Returns the matrix elements as a group of parameters values. The number of parameters depends on the\n     * matrix size. Only matrix elements different from their default value will be included in this group.\n     *\n     * @return the parameter values for this math transform.\n     */\n    @Override\n    public ParameterValueGroup getParameterValues() {\n        return Affine.parameters(this);\n    }\n    /**\n     * Unsupported operation, since this matrix is unmodifiable.\n     */\n    @Override\n    public final void setElement(final int row, final int column, final double value) {\n        throw new UnsupportedOperationException(isAffine()\n                ? Resources.format(Resources.Keys.UnmodifiableAffineTransform)\n                : Errors.format(Errors.Keys.UnmodifiableObject_1, AbstractLinearTransform.class));\n    }\n    /**\n     * Transforms an array of relative distance vectors. Distance vectors are transformed without applying\n     * the translation components. The default implementation is not very efficient, but it should not be\n     * an issue since this method is not invoked often.\n     *\n     * @since 0.7\n     */\n    @Override\n    public void deltaTransform(double[] srcPts, int srcOff, double[] dstPts, int dstOff, int numPts) {\n        int offFinal = 0;\n        double[] dstFinal = null;\n        final int srcDim, dstDim;\n        int srcInc = srcDim = getSourceDimensions();\n        int dstInc = dstDim = getTargetDimensions();\n        if (srcPts == dstPts) {\n            switch (IterationStrategy.suggest(srcOff, srcDim, dstOff, dstDim, numPts)) {\n                case ASCENDING: {\n                    break;\n                }\n                case DESCENDING: {\n                    srcOff += (numPts - 1) * srcDim;  srcInc = -srcInc;\n                    dstOff += (numPts - 1) * dstDim;  dstInc = -dstInc;\n                    break;\n                }\n                default: {\n                    srcPts = Arrays.copyOfRange(srcPts, srcOff, srcOff + numPts*srcDim);\n                    srcOff = 0;\n                    break;\n                }\n                case BUFFER_TARGET: {\n                    dstFinal = dstPts; dstPts = new double[numPts * dstInc];\n                    offFinal = dstOff; dstOff = 0;\n                    break;\n                }\n            }\n        }\n        final double[] buffer = new double[dstDim];\n        while (--numPts >= 0) {\n            for (int j=0; j<dstDim; j++) {\n                double sum = 0;\n                for (int i=0; i<srcDim; i++) {\n                    final double e = getElement(j, i);\n                    if (e != 0) {   // See the comment in ProjectiveTransform for the purpose of this test.\n                        sum += srcPts[srcOff + i] * e;\n                    }\n                }\n                buffer[j] = sum;\n            }\n            System.arraycopy(buffer, 0, dstPts, dstOff, dstDim);\n            srcOff += srcInc;\n            dstOff += dstInc;\n        }\n        if (dstFinal != null) {\n            System.arraycopy(dstPts, 0, dstFinal, offFinal, dstPts.length);\n        }\n    }\n    /**\n     * Compares this math transform with an object which is known to be of the same class.<fim_middle>// function below has no smell\n"}