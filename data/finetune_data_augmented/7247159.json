{"text": "<fim_prefix>        }\n        if (zoomOutAction != null) {\n            zoomOutAction.setEnabled(isFit() ? false : prefWidth >= width / MIN_VIEW);\n        }\n    }\n    private long getFirstTime() {\n        return data.getStartTime();\n    }\n    public int getViewWidth() {\n        return (int)(getDataWidth() * zoom);\n    }\n    private int getDataWidth() {\n        return (int)(data.getEndTime() - data.getStartTime());\n    }\n    public long getFirstTimeMark(boolean _offset) {\n        return _offset ? _firstTimeMark : firstTimeMark;\n    }\n    public long getTimeMarksStep() {\n        return timeMarksStep;\n    }\n    public String getTimeMarksFormat() {\n        return format;\n    }\n    public int getTimePosition(long time, boolean _offset) {\n        return !_offset || isFit() ? (int)((time - data.getStartTime()) * zoom) :\n                                     (int)((time - data.getStartTime()) * zoom) - offset;\n    }\n    private long firstTimeMark;\n    private long _firstTimeMark;\n    private long timeMarksStep;\n    private String format;\n    private void updateTimeMarks(boolean updateStep) {\n        if (updateStep) timeMarksStep = TimeAxisUtils.getTimeUnits(zoom, MIN_TIMEMARK_STEP);\n        long first = data.getStartTime();\n        long _first = first + (long)(offset / zoom);\n        firstTimeMark = first / timeMarksStep * timeMarksStep + timeMarksStep;\n        _firstTimeMark = _first / timeMarksStep * timeMarksStep + timeMarksStep;\n        long last = first + (long)(width / zoom);\n        format = TimeAxisUtils.getFormatString(timeMarksStep, first, last);\n    }\n    public RowView getRowView(int row) {\n        RowView rowView = rowViews.get(row);\n        if (rowView == null) {\n            rowView = new RowView(data.getThreadData(row));\n            rowViews.put(row, rowView);\n        }\n        return rowView;\n    }\n    public void update() {\n        if (isFit()) zoomChanged(zoom, width / (double)getDataWidth());\n    }\n    public void reset() {\n        zoom = 0.03f;\n        lastZoom = zoom;\n        rowViews.clear();\n        updateTimeMarks(true);\n    }\n    public void columnOffsetChanged(int column, int oldO, int newO) {\n        if (this.column != column) return;\n        offset = newO;\n        updateTimeMarks(false);\n        for (RowView view : rowViews.values()) view.offsetChanged(oldO, newO);\n    }\n    public void columnWidthChanged(int column, int oldW, int newW) {\n        if (this.column != column) return;\n        width = newW;\n        if (!isFit()) for (RowView view : rowViews.values()) view.widthChanged(oldW, newW);\n        updateActions();\n    }\n    public void columnPreferredWidthChanged(int column, int oldW, int newW) {\n        if (this.column != column) return;\n        prefWidth = newW;\n        updateTimeMarks(false);\n        if (!isFit()) for (RowView view : rowViews.values()) view.preferredWidthChanged(oldW, newW);\n        updateActions();\n    }\n    public void zoomChanged(double oldZoom, double newZoom) {\n        zoom = newZoom;\n        updateTimeMarks(true);\n        for (RowView view : rowViews.values()) view.zoomChanged(oldZoom, newZoom);\n    }\n    public void setFit(boolean f) {\n        fit = f;\n    }\n    public boolean isFit() {\n        return fit;\n    }\n    private boolean isTrackingEnd() {\n        return offset + width >= prefWidth;\n    }\n<fim_suffix>    public class RowView implements Comparable<RowView> {\n        private final ThreadData data;\n        private int i = -1;\n        RowView(ThreadData data) {\n            this.data = data;\n            if (getMaxIndex() >= 0) i = findLastIndex();\n        }\n        public int getLastIndex() {\n            return i == Integer.MIN_VALUE || i == Integer.MAX_VALUE ? -1 : i;\n        }\n        public int getMaxIndex() {\n            return data.size() - 1;\n        }\n        public long getTime(int index) {\n            return data.getTimeStampAt(index);\n        }\n        public int getState(int index) {\n            return data.getStateAt(index);\n        }\n        public int getPosition(long time) {\n            return (int)((time - getFirstTime()) * zoom);\n        }\n        // TODO: should return end of last alive state for dead threads\n        public int getMaxPosition() {\n            return getViewWidth();\n        }\n        // TODO: optimize based on current offset / visible area\n        private int findLastIndex() {\n//            if (data.getThreadRecordsCount(row) == 0) return -1;\n            if (isTrackingEnd() || isFit()) return getMaxIndex();\n            i = Integer.MIN_VALUE;\n            return findLastIndexLeft();\n        }\n        private int findLastIndexLeft() {\n            // All indexes already on right\n            if (i == Integer.MAX_VALUE) return i;\n            int maxIndex = getMaxIndex();\n            int newIndex = i == Integer.MIN_VALUE ? maxIndex : i;\n            Position position = getIndexPosition(newIndex);\n            while (newIndex > 0 && Position.RIGHT.equals(position))\n                position = getIndexPosition(--newIndex);\n            // All indexes on right\n            if (Position.RIGHT.equals(position)) return Integer.MAX_VALUE;\n            // All indexes on left\n            if (Position.LEFT.equals(position) && newIndex == maxIndex &&\n                getMaxPosition() - offset < 0) return Integer.MIN_VALUE;\n            // Last visible index\n            return newIndex;\n        }\n        private int findLastIndexRight() {\n            // All indexes already on right\n            if (i == Integer.MIN_VALUE) return i;\n            int maxIndex = getMaxIndex();\n            int newIndex = i == Integer.MAX_VALUE ? 0 : i;\n            Position position = getIndexPosition(newIndex);\n            while (newIndex < maxIndex && !Position.RIGHT.equals(position))\n                position = getIndexPosition(++newIndex);\n            // First invisible inedx or all indexes on right\n            if (Position.RIGHT.equals(position))\n                return newIndex == 0 ? Integer.MAX_VALUE : newIndex - 1;\n            // All indexes on left\n            if (Position.LEFT.equals(position) && newIndex == maxIndex &&\n                getMaxPosition() - offset < 0) return Integer.MIN_VALUE;\n            // Last visible index\n            return newIndex;\n        }\n        private Position getIndexPosition(int index) {\n            int position = getPosition(getTime(index)) - offset;\n            if (position < 0) return Position.LEFT;\n            else if (position >= width) return Position.RIGHT;\n            else return Position.WITHIN;\n        }\n        private void offsetChanged(int oldOffset, int newOffset) {\n            int maxIndex = getMaxIndex();\n            if (maxIndex == -1) return;\n            if (isTrackingEnd()) {\n                i = maxIndex;\n            } else {\n                if (newOffset > oldOffset) {\n                    i = i == -1 ? findLastIndex() : findLastIndexRight();\n                } else {\n                    i = i == -1 ? findLastIndex() : findLastIndexLeft();\n                }\n            }\n        }\n        private void widthChanged(int oldWidth, int newWidth) {\n            int maxIndex = getMaxIndex();\n            if (maxIndex == -1) return;\n            if (isTrackingEnd() || isFit()) {\n                i = maxIndex;\n            } else {\n                if (newWidth > oldWidth) {\n                    i = i == -1 ? findLastIndex() : findLastIndexRight();\n                } else {\n                    i = i == -1 ? findLastIndex() : findLastIndexLeft();\n                }\n            }\n        }\n        private boolean lastMaxIn = true;\n        private void preferredWidthChanged(int oldWidth, int newWidth) {\n            int maxIndex = getMaxIndex();\n            if (maxIndex == -1) return;\n            int currPos = getMaxPosition() - offset;\n            if (currPos >= 0 && currPos < width) { // TODO: verify\n                i = maxIndex;\n                lastMaxIn = true;\n            } else {\n                if (lastMaxIn && currPos >= width) {\n                    // preferred width increases with new data\n                    i = maxIndex;\n                    findLastIndexLeft();\n                }\n                lastMaxIn = false;\n            }\n        }\n        private void zoomChanged(double oldZoom, double newZoom) {\n            int maxIndex = getMaxIndex();\n            if (maxIndex == -1) return;\n            if (isTrackingEnd() || isFit()) {\n                i = maxIndex;\n            } else {\n                i = findLastIndex();\n            }\n        }\n        public int compareTo(RowView view) {\n            return Long.compare(data.getFirstTimeStamp(), view.data.getFirstTimeStamp());\n        }\n        public String toString() {\n            return BUNDLE().getString(\"COL_Timeline\"); // NOI18N\n        }\n    }<fim_middle>// class below has no smell\n"}