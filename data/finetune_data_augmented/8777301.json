{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.hadoop.ipc;\n\nimport java.io.IOException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport java.net.InetSocketAddress;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.TreeMap;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.ipc.protobuf.ProtocolInfoProtos.GetProtocolSignatureRequestProto;\nimport org.apache.hadoop.ipc.protobuf.ProtocolInfoProtos.GetProtocolSignatureResponseProto;\nimport org.apache.hadoop.ipc.protobuf.ProtocolInfoProtos.ProtocolSignatureProto;\nimport org.apache.hadoop.net.NetUtils;\n\nimport com.google.protobuf.RpcController;\nimport com.google.protobuf.ServiceException;\n\n/**\n * This class maintains a cache of protocol versions and corresponding protocol\n * signatures, keyed by server address, protocol and rpc kind.\n * The cache is lazily populated. \n */\npublic class RpcClientUtil {\n  private static RpcController NULL_CONTROLLER = null;\n  private static final int PRIME = 16777619;\n  \n  private static class ProtoSigCacheKey {\n    private InetSocketAddress serverAddress;\n    private String protocol;\n    private String rpcKind;\n    \n    ProtoSigCacheKey(InetSocketAddress addr, String p, String rk) {\n      this.serverAddress = addr;\n      this.protocol = p;\n      this.rpcKind = rk;\n    }\n    \n<fim_suffix>    @Override //Object\n    public int hashCode() {\n      int result = 1;\n      result = PRIME * result\n          + ((serverAddress == null) ? 0 : serverAddress.hashCode());\n      result = PRIME * result + ((protocol == null) ? 0 : protocol.hashCode());\n      result = PRIME * result + ((rpcKind == null) ? 0 : rpcKind.hashCode());\n      return result;\n    }\n    \n    @Override //Object\n    public boolean equals(Object other) {\n      if (other == this) {\n        return true;\n      }\n      if (other instanceof ProtoSigCacheKey) {\n        ProtoSigCacheKey otherKey = (ProtoSigCacheKey) other;\n        return (serverAddress.equals(otherKey.serverAddress) &&\n            protocol.equals(otherKey.protocol) &&\n            rpcKind.equals(otherKey.rpcKind));\n      }\n      return false;\n    }\n  }\n  \n  private static ConcurrentHashMap<ProtoSigCacheKey, Map<Long, ProtocolSignature>> \n  signatureMap = new ConcurrentHashMap<ProtoSigCacheKey, Map<Long, ProtocolSignature>>();\n\n  private static void putVersionSignatureMap(InetSocketAddress addr,\n      String protocol, String rpcKind, Map<Long, ProtocolSignature> map) {\n    signatureMap.put(new ProtoSigCacheKey(addr, protocol, rpcKind), map);\n  }\n  \n  private static Map<Long, ProtocolSignature> getVersionSignatureMap(\n      InetSocketAddress addr, String protocol, String rpcKind) {\n    return signatureMap.get(new ProtoSigCacheKey(addr, protocol, rpcKind));\n  }\n\n  /**\n   * Returns whether the given method is supported or not.\n   * The protocol signatures are fetched and cached. The connection id for the\n   * proxy provided is re-used.\n   * @param rpcProxy Proxy which provides an existing connection id.\n   * @param protocol Protocol for which the method check is required.\n   * @param rpcKind The RpcKind for which the method check is required.\n   * @param version The version at the client.\n   * @param methodName Name of the method.\n   * @return true if the method is supported, false otherwise.\n   * @throws IOException\n   */\n  public static boolean isMethodSupported(Object rpcProxy, Class<?> protocol,\n      RPC.RpcKind rpcKind, long version, String methodName) throws IOException {\n    InetSocketAddress serverAddress = RPC.getServerAddress(rpcProxy);\n    Map<Long, ProtocolSignature> versionMap = getVersionSignatureMap(\n        serverAddress, protocol.getName(), rpcKind.toString());\n\n    if (versionMap == null) {\n      Configuration conf = new Configuration();\n      RPC.setProtocolEngine(conf, ProtocolMetaInfoPB.class,\n          ProtobufRpcEngine.class);\n      ProtocolMetaInfoPB protocolInfoProxy = getProtocolMetaInfoProxy(rpcProxy,\n          conf);\n      GetProtocolSignatureRequestProto.Builder builder = \n          GetProtocolSignatureRequestProto.newBuilder();\n      builder.setProtocol(protocol.getName());\n      builder.setRpcKind(rpcKind.toString());\n      GetProtocolSignatureResponseProto resp;\n      try {\n        resp = protocolInfoProxy.getProtocolSignature(NULL_CONTROLLER,\n            builder.build());\n      } catch (ServiceException se) {\n        throw ProtobufHelper.getRemoteException(se);\n      }\n      versionMap = convertProtocolSignatureProtos(resp\n          .getProtocolSignatureList());\n      putVersionSignatureMap(serverAddress, protocol.getName(),\n          rpcKind.toString(), versionMap);\n    }\n    // Assuming unique method names.\n    Method desiredMethod;\n    Method[] allMethods = protocol.getMethods();\n    desiredMethod = null;\n    for (Method m : allMethods) {\n      if (m.getName().equals(methodName)) {\n        desiredMethod = m;\n        break;\n      }\n    }\n    if (desiredMethod == null) {\n      return false;\n    }\n    int methodHash = ProtocolSignature.getFingerprint(desiredMethod);\n    return methodExists(methodHash, version, versionMap);\n  }\n  \n  private static Map<Long, ProtocolSignature> \n  convertProtocolSignatureProtos(List<ProtocolSignatureProto> protoList) {\n    Map<Long, ProtocolSignature> map = new TreeMap<Long, ProtocolSignature>();\n    for (ProtocolSignatureProto p : protoList) {\n      int [] methods = new int[p.getMethodsList().size()];\n      int index=0;\n      for (int m : p.getMethodsList()) {\n        methods[index++] = m;\n      }\n      map.put(p.getVersion(), new ProtocolSignature(p.getVersion(), methods));\n    }\n    return map;\n  }\n\n  private static boolean methodExists(int methodHash, long version,\n      Map<Long, ProtocolSignature> versionMap) {\n    ProtocolSignature sig = versionMap.get(version);\n    if (sig != null) {\n      for (int m : sig.getMethods()) {\n        if (m == methodHash) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n  \n  // The proxy returned re-uses the underlying connection. This is a special \n  // mechanism for ProtocolMetaInfoPB.\n  // Don't do this for any other protocol, it might cause a security hole.\n  private static ProtocolMetaInfoPB getProtocolMetaInfoProxy(Object proxy,\n      Configuration conf) throws IOException {\n    RpcInvocationHandler inv = (RpcInvocationHandler) Proxy\n        .getInvocationHandler(proxy);\n    return RPC\n        .getProtocolEngine(ProtocolMetaInfoPB.class, conf)\n        .getProtocolMetaInfoProxy(inv.getConnectionId(), conf,\n            NetUtils.getDefaultSocketFactory(conf)).getProxy();\n  }\n}<fim_middle>// function below has no smell\n"}