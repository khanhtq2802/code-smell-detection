{"text": "<fim_prefix>/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.aries.subsystem.core.archive;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.apache.aries.subsystem.core.internal.ResourceHelper;\nimport org.apache.aries.subsystem.core.internal.Utils;\nimport org.osgi.framework.Version;\nimport org.osgi.resource.Requirement;\nimport org.osgi.resource.Resource;\nimport org.osgi.service.subsystem.SubsystemConstants;\n\npublic class ProvisionResourceHeader extends AbstractClauseBasedHeader<ProvisionResourceHeader.Clause> implements RequirementHeader<ProvisionResourceHeader.Clause> {\n    public static class Clause extends AbstractClause {\n\t\tpublic static final String ATTRIBUTE_DEPLOYEDVERSION = DeployedVersionAttribute.NAME;\n\t\tpublic static final String ATTRIBUTE_RESOURCEID = \"resourceId\";\n\t\tpublic static final String ATTRIBUTE_TYPE = TypeAttribute.NAME;\n\t\t\n\t\tpublic Clause(String clause) {\n\t\t\tsuper(\n            \t\tparsePath(clause, Patterns.SYMBOLIC_NAME, false), \n            \t\tparseParameters(clause, false), \n            \t\tgenerateDefaultParameters(\n            \t\t\t\tTypeAttribute.DEFAULT));\n\t\t}\n\t\t\n\t\tpublic Clause(Resource resource) {\n\t\t\tthis(appendResource(resource, new StringBuilder()).toString());\n\t\t}\n\t\t\n\t\tpublic boolean contains(Resource resource) {\n\t\t\treturn getSymbolicName().equals(\n\t\t\t\t\tResourceHelper.getSymbolicNameAttribute(resource))\n\t\t\t\t\t&& getDeployedVersion().equals(\n\t\t\t\t\t\t\tResourceHelper.getVersionAttribute(resource))\n\t\t\t\t\t&& getType().equals(\n\t\t\t\t\t\t\tResourceHelper.getTypeAttribute(resource));\n\t\t}\n\t\t\n\t\tpublic Version getDeployedVersion() {\n\t\t\treturn ((DeployedVersionAttribute)getAttribute(ATTRIBUTE_DEPLOYEDVERSION)).getVersion();\n\t\t}\n\n\t\tpublic String getSymbolicName() {\n\t\t\treturn path;\n\t\t}\n\t\t\n\t\tpublic String getType() {\n\t\t\treturn ((TypeAttribute)getAttribute(ATTRIBUTE_TYPE)).getType();\n\t\t}\n\t\t\n\t\tpublic ProvisionResourceRequirement toRequirement(Resource resource) {\n\t\t\treturn new ProvisionResourceRequirement(this, resource);\n\t\t}\n\t}\n\t\n\tpublic static final String NAME = SubsystemConstants.PROVISION_RESOURCE;\n\t\n\tpublic static ProvisionResourceHeader newInstance(Collection<Resource> resources) {\n\t\tStringBuilder builder = new StringBuilder();\n\t\tfor (Resource resource : resources) {\n\t\t\tappendResource(resource, builder);\n\t\t\tbuilder.append(',');\n\t\t}\n\t\t// Remove the trailing comma.\n\t\t// TODO Intentionally letting the exception propagate since there must be at least one resource.\n\t\tbuilder.deleteCharAt(builder.length() - 1);\n\t\treturn new ProvisionResourceHeader(builder.toString());\n\t}\n\t\n\tprivate static StringBuilder appendResource(Resource resource, StringBuilder builder) {\n\t\tString symbolicName = ResourceHelper.getSymbolicNameAttribute(resource);\n\t\tVersion version = ResourceHelper.getVersionAttribute(resource);\n\t\tString type = ResourceHelper.getTypeAttribute(resource);\n\t\tbuilder.append(symbolicName)\n\t\t\t.append(';')\n\t\t\t.append(Clause.ATTRIBUTE_DEPLOYEDVERSION)\n\t\t\t.append('=')\n\t\t\t.append(version.toString())\n\t\t\t.append(';')\n\t\t\t.append(Clause.ATTRIBUTE_TYPE)\n\t\t\t.append('=')\n\t\t\t.append(type)\n\t\t\t.append(';')\n\t\t\t.append(Clause.ATTRIBUTE_RESOURCEID)\n\t\t\t.append('=')\n\t\t\t.append(Utils.getId(resource));\n\t\treturn builder;\n\t}\n\t\t\n\tpublic ProvisionResourceHeader(Collection<Clause> clauses) {\n\t\tsuper(clauses);\n\t}\n\t\n\tpublic ProvisionResourceHeader(String value) {\n\t\tsuper(\n\t\t\t\tvalue, \n\t\t\t\tnew ClauseFactory<Clause>() {\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic Clause newInstance(String clause) {\n\t\t\t\t\t\treturn new Clause(clause);\n\t\t\t\t\t}\n\t\t\t\t});\n\t}\n\t\n\tpublic boolean contains(Resource resource) {\n\t\tfor (Clause clause : getClauses())\n\t\t\tif (clause.contains(resource))\n\t\t\t\treturn true;\n\t\treturn false;\n\t}\n\t\n<fim_suffix>\tpublic Clause getClause(Resource resource) {\n\t\tString symbolicName = ResourceHelper.getSymbolicNameAttribute(resource);\n\t\tVersion version = ResourceHelper.getVersionAttribute(resource);\n\t\tString type = ResourceHelper.getTypeAttribute(resource);\n\t\tfor (Clause clause : clauses) {\n\t\t\tif (symbolicName.equals(clause.getPath())\n\t\t\t\t\t&& clause.getDeployedVersion().equals(version)\n\t\t\t\t\t&& type.equals(clause.getType()))\n\t\t\t\treturn clause;\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic String getName() {\n\t\treturn NAME;\n\t}\n\n\t@Override\n\tpublic String getValue() {\n\t\treturn toString();\n\t}\n\t\n\t@Override\n\tpublic List<Requirement> toRequirements(Resource resource) {\n\t\tList<Requirement> requirements = new ArrayList<Requirement>(clauses.size());\n\t\tfor (Clause clause : clauses)\n\t\t\trequirements.add(clause.toRequirement(resource));\n\t\treturn requirements;\n\t}\n}<fim_middle>// function below has no smell\n"}