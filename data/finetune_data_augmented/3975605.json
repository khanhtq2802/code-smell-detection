{"text": "<fim_prefix>  private static class IntSchema extends Schema {\n    public IntSchema() { super(Type.INT); }\n  }\n  private static class LongSchema extends Schema {\n    public LongSchema() { super(Type.LONG); }\n  }\n  private static class FloatSchema extends Schema {\n    public FloatSchema() { super(Type.FLOAT); }\n  }\n  private static class DoubleSchema extends Schema {\n    public DoubleSchema() { super(Type.DOUBLE); }\n  }\n  private static class BooleanSchema extends Schema {\n    public BooleanSchema() { super(Type.BOOLEAN); }\n  }\n  private static class NullSchema extends Schema {\n    public NullSchema() { super(Type.NULL); }\n  }\n  /** A parser for JSON-format schemas.  Each named schema parsed with a parser\n   * is added to the names known to the parser so that subsequently parsed\n   * schemas may refer to it by name. */\n  public static class Parser {\n    private Names names = new Names();\n    private boolean validate = true;\n    private boolean validateDefaults = true;\n    /** Adds the provided types to the set of defined, named types known to\n     * this parser. */\n    public Parser addTypes(Map<String,Schema> types) {\n      for (Schema s : types.values())\n        names.add(s);\n      return this;\n    }\n    /** Returns the set of defined, named types known to this parser. */\n    public Map<String,Schema> getTypes() {\n      Map<String,Schema> result = new LinkedHashMap<>();\n      for (Schema s : names.values())\n        result.put(s.getFullName(), s);\n      return result;\n    }\n    /** Enable or disable name validation. */\n    public Parser setValidate(boolean validate) {\n      this.validate = validate;\n      return this;\n    }\n    /** True iff names are validated.  True by default. */\n    public boolean getValidate() { return this.validate; }\n    /** Enable or disable default value validation. */\n    public Parser setValidateDefaults(boolean validateDefaults) {\n      this.validateDefaults = validateDefaults;\n      return this;\n    }\n    /** True iff default values are validated.  False by default. */\n    public boolean getValidateDefaults() { return this.validateDefaults; }\n    /** Parse a schema from the provided file.\n     * If named, the schema is added to the names known to this parser. */\n    public Schema parse(File file) throws IOException {\n      return parse(FACTORY.createParser(file));\n    }\n    /** Parse a schema from the provided stream.\n     * If named, the schema is added to the names known to this parser.\n     * The input stream stays open after the parsing. */\n    public Schema parse(InputStream in) throws IOException {\n      return parse(FACTORY.createParser(in).disable(\n              JsonParser.Feature.AUTO_CLOSE_SOURCE));\n    }\n    /** Read a schema from one or more json strings */\n    public Schema parse(String s, String... more) {\n      StringBuilder b = new StringBuilder(s);\n      for (String part : more)\n        b.append(part);\n      return parse(b.toString());\n    }\n    /** Parse a schema from the provided string.\n     * If named, the schema is added to the names known to this parser. */\n    public Schema parse(String s) {\n      try {\n        return parse(FACTORY.createParser(s));\n      } catch (IOException e) {\n        throw new SchemaParseException(e);\n      }\n    }\n    private Schema parse(JsonParser parser) throws IOException {\n      boolean saved = validateNames.get();\n      boolean savedValidateDefaults = VALIDATE_DEFAULTS.get();\n      try {\n        validateNames.set(validate);\n        VALIDATE_DEFAULTS.set(validateDefaults);\n        return Schema.parse(MAPPER.readTree(parser), names);\n      } catch (JsonParseException e) {\n        throw new SchemaParseException(e);\n      } finally {\n        parser.close();\n        validateNames.set(saved);\n        VALIDATE_DEFAULTS.set(savedValidateDefaults);\n      }\n    }\n  }\n  /**\n   * Constructs a Schema object from JSON schema file <tt>file</tt>.\n   * The contents of <tt>file</tt> is expected to be in UTF-8 format.\n   * @param file  The file to read the schema from.\n   * @return  The freshly built Schema.\n   * @throws IOException if there was trouble reading the contents or they are invalid\n   * @deprecated use {@link Schema.Parser} instead.\n   */\n  @Deprecated\n  public static Schema parse(File file) throws IOException {\n    return new Parser().parse(file);\n  }\n  /**\n   * Constructs a Schema object from JSON schema stream <tt>in</tt>.\n   * The contents of <tt>in</tt> is expected to be in UTF-8 format.\n   * @param in  The input stream to read the schema from.\n   * @return  The freshly built Schema.\n   * @throws IOException if there was trouble reading the contents or they are invalid\n   * @deprecated use {@link Schema.Parser} instead.\n   */\n  @Deprecated\n  public static Schema parse(InputStream in) throws IOException {\n    return new Parser().parse(in);\n  }\n  /** Construct a schema from <a href=\"http://json.org/\">JSON</a> text.\n   * @deprecated use {@link Schema.Parser} instead.\n   */\n  @Deprecated\n  public static Schema parse(String jsonSchema) {\n    return new Parser().parse(jsonSchema);\n  }\n  /** Construct a schema from <a href=\"http://json.org/\">JSON</a> text.\n   * @param validate true if names should be validated, false if not.\n   * @deprecated use {@link Schema.Parser} instead.\n   */\n  @Deprecated\n  public static Schema parse(String jsonSchema, boolean validate) {\n    return new Parser().setValidate(validate).parse(jsonSchema);\n  }\n  static final Map<String,Type> PRIMITIVES = new HashMap<>();\n  static {\n    PRIMITIVES.put(\"string\",  Type.STRING);\n    PRIMITIVES.put(\"bytes\",   Type.BYTES);\n    PRIMITIVES.put(\"int\",     Type.INT);\n    PRIMITIVES.put(\"long\",    Type.LONG);\n    PRIMITIVES.put(\"float\",   Type.FLOAT);\n    PRIMITIVES.put(\"double\",  Type.DOUBLE);\n    PRIMITIVES.put(\"boolean\", Type.BOOLEAN);\n    PRIMITIVES.put(\"null\",    Type.NULL);\n  }\n  static class Names extends LinkedHashMap<Name, Schema> {\n    private static final long serialVersionUID = 1L;\n    private String space;                         // default namespace\n    public Names() {}\n    public Names(String space) { this.space = space; }\n    public String space() { return space; }\n    public void space(String space) { this.space = space; }\n    public Schema get(String o) {\n      Type primitive = PRIMITIVES.get(o);\n      if (primitive != null) {\n        return Schema.create(primitive);\n      }\n      Name name = new Name(o, space);\n      if (!containsKey(name)) {\n        // if not in default try anonymous\n        name = new Name(o, \"\");\n      }\n      return super.get(name);\n    }\n    public boolean contains(Schema schema) {\n      return get(((NamedSchema)schema).name) != null;\n    }\n    public void add(Schema schema) {\n      put(((NamedSchema)schema).name, schema);\n    }\n    @Override\n    public Schema put(Name name, Schema schema) {\n      if (containsKey(name))\n        throw new SchemaParseException(\"Can't redefine: \"+name);\n      return super.put(name, schema);\n    }\n  }\n  private static ThreadLocal<Boolean> validateNames\n    = ThreadLocal.withInitial(() -> true);\n  private static String validateName(String name) {\n    if (!validateNames.get()) return name;        // not validating names\n    int length = name.length();\n    if (length == 0)\n      throw new SchemaParseException(\"Empty name\");\n    char first = name.charAt(0);\n    if (!(Character.isLetter(first) || first == '_'))\n      throw new SchemaParseException(\"Illegal initial character: \"+name);\n    for (int i = 1; i < length; i++) {\n      char c = name.charAt(i);\n      if (!(Character.isLetterOrDigit(c) || c == '_'))\n        throw new SchemaParseException(\"Illegal character in: \"+name);\n    }\n    return name;\n  }\n  private static final ThreadLocal<Boolean> VALIDATE_DEFAULTS\n    = ThreadLocal.withInitial(() -> true);\n<fim_suffix>  private static JsonNode validateDefault(String fieldName, Schema schema,\n                                          JsonNode defaultValue) {\n    if (VALIDATE_DEFAULTS.get() && (defaultValue != null)\n        && !isValidDefault(schema, defaultValue)) { // invalid default\n      String message = \"Invalid default for field \"+fieldName\n        +\": \"+defaultValue+\" not a \"+schema;\n      throw new AvroTypeException(message);     // throw exception\n    }\n    return defaultValue;\n  }<fim_middle>// function below has no smell\n"}