{"text": "<fim_prefix>      return new AccessibilityNodeInfo[size];\n    }};\n  private static int sAllocationCount = 0;\n  private static final int CLICKABLE_MASK = 0x00000001;\n  private static final int LONGCLICKABLE_MASK = 0x00000002;\n  private static final int FOCUSABLE_MASK = 0x00000004;\n  private static final int FOCUSED_MASK = 0x00000008;\n  private static final int VISIBLE_TO_USER_MASK = 0x00000010;\n  private static final int SCROLLABLE_MASK = 0x00000020;\n  private static final int PASTEABLE_MASK = 0x00000040;\n  private static final int EDITABLE_MASK = 0x00000080;\n  private static final int TEXT_SELECTION_SETABLE_MASK = 0x00000100;\n  private static final int CHECKABLE_MASK = 0x00001000; //14\n  private static final int CHECKED_MASK = 0x00002000; //14\n  private static final int ENABLED_MASK = 0x00010000; //14\n  private static final int PASSWORD_MASK = 0x00040000; //14\n  private static final int SELECTED_MASK = 0x00080000; //14\n  private static final int A11YFOCUSED_MASK = 0x00000800;  //16\n  private static final int MULTILINE_MASK = 0x00020000; //19\n  private static final int CONTENT_INVALID_MASK = 0x00004000; //19\n  private static final int DISMISSABLE_MASK = 0x00008000; //19\n  private static final int CAN_OPEN_POPUP_MASK = 0x00100000; //19\n  /**\n   * Uniquely identifies the origin of the AccessibilityNodeInfo for equality\n   * testing. Two instances that come from the same node info should have the\n   * same ID.\n   */\n  private long mOriginNodeId;\n  private List<AccessibilityNodeInfo> children;\n  private Rect boundsInScreen = new Rect();\n  private Rect boundsInParent = new Rect();\n  private List<Pair<Integer, Bundle>> performedActionAndArgsList;\n  // In API prior to 21, actions are stored in a flag, after 21 they are stored in array of\n  // AccessibilityAction so custom actions can be supported.\n  private ArrayList<AccessibilityAction> actionsArray;\n  private int actionsMask;\n  // Storage of flags\n  private int propertyFlags;\n  private AccessibilityNodeInfo parent;\n  private AccessibilityNodeInfo labelFor;\n  private AccessibilityNodeInfo labeledBy;\n  private View view;\n  private CharSequence contentDescription;\n  private CharSequence text;\n  private CharSequence className;\n  private int textSelectionStart = UNDEFINED_SELECTION_INDEX;\n  private int textSelectionEnd = UNDEFINED_SELECTION_INDEX;\n  private boolean refreshReturnValue = true;\n  private int movementGranularities; //16\n  private CharSequence packageName; //14\n  private String viewIdResourceName; //18\n  private CollectionInfo collectionInfo; //19\n  private CollectionItemInfo collectionItemInfo; //19\n  private int inputType; //19\n  private int liveRegion; //19\n  private RangeInfo rangeInfo; //19\n  private int maxTextLength; //21\n  private CharSequence error; //21\n  private AccessibilityWindowInfo accessibilityWindowInfo;\n  private AccessibilityNodeInfo traversalAfter; //22\n  private AccessibilityNodeInfo traversalBefore; //22\n  private OnPerformActionListener actionListener;\n  private int drawingOrder; // 24\n  @RealObject\n  private AccessibilityNodeInfo realAccessibilityNodeInfo;\n  @Implementation\n  protected void __constructor__() {\n    ReflectionHelpers.setStaticField(AccessibilityNodeInfo.class, \"CREATOR\", ShadowAccessibilityNodeInfo.CREATOR);\n  }\n  @Implementation\n  protected static AccessibilityNodeInfo obtain(AccessibilityNodeInfo info) {\n    final ShadowAccessibilityNodeInfo shadowInfo = Shadow.extract(info);\n    final AccessibilityNodeInfo obtainedInstance = shadowInfo.getClone();\n    sAllocationCount++;\n    if (shadowInfo.mOriginNodeId == 0) {\n      shadowInfo.mOriginNodeId = sAllocationCount;\n    }\n    StrictEqualityNodeWrapper wrapper = new StrictEqualityNodeWrapper(obtainedInstance);\n    obtainedInstances.put(wrapper, Thread.currentThread().getStackTrace());\n    orderedInstances.put(sAllocationCount, wrapper);\n    return obtainedInstance;\n  }\n  @Implementation\n  protected static AccessibilityNodeInfo obtain(View view) {\n    // We explicitly avoid allocating the AccessibilityNodeInfo from the actual pool by using the\n    // private constructor. Not doing so affects test suites which use both shadow and\n    // non-shadow objects.\n    final AccessibilityNodeInfo obtainedInstance =\n        ReflectionHelpers.callConstructor(AccessibilityNodeInfo.class);\n    final ShadowAccessibilityNodeInfo shadowObtained = Shadow.extract(obtainedInstance);\n    /*\n     * We keep a separate list of actions for each object newly obtained\n     * from a view, and perform a shallow copy during getClone. That way the\n     * list of actions performed contains all actions performed on the view\n     * by the tree of nodes initialized from it. Note that initializing two\n     * nodes with the same view will not merge the two lists, as so the list\n     * of performed actions will not contain all actions performed on the\n     * underlying view.\n     */\n    shadowObtained.performedActionAndArgsList = new ArrayList<>();\n    shadowObtained.view = view;\n    sAllocationCount++;\n    if (shadowObtained.mOriginNodeId == 0) {\n      shadowObtained.mOriginNodeId = sAllocationCount;\n    }\n    StrictEqualityNodeWrapper wrapper = new StrictEqualityNodeWrapper(obtainedInstance);\n    obtainedInstances.put(wrapper, Thread.currentThread().getStackTrace());\n    orderedInstances.put(sAllocationCount, wrapper);\n    return obtainedInstance;\n  }\n  @Implementation\n  protected static AccessibilityNodeInfo obtain() {\n    return obtain(new View(RuntimeEnvironment.application.getApplicationContext()));\n  }\n  @Implementation\n  protected static AccessibilityNodeInfo obtain(View root, int virtualDescendantId) {\n    AccessibilityNodeInfo node = obtain(root);\n    return node;\n  }\n  /**\n   * Check for leaked objects that were {@code obtain}ed but never\n   * {@code recycle}d.\n   *\n   * @param printUnrecycledNodesToSystemErr - if true, stack traces of calls\n   *        to {@code obtain} that lack matching calls to {@code recycle} are\n   *        dumped to System.err.\n   * @return {@code true} if there are unrecycled nodes\n   */\n  public static boolean areThereUnrecycledNodes(boolean printUnrecycledNodesToSystemErr) {\n    if (printUnrecycledNodesToSystemErr) {\n      for (final StrictEqualityNodeWrapper wrapper : obtainedInstances.keySet()) {\n        final ShadowAccessibilityNodeInfo shadow = Shadow.extract(wrapper.mInfo);\n        System.err.println(String.format(\n            \"Leaked contentDescription = %s. Stack trace:\", shadow.getContentDescription()));\n        for (final StackTraceElement stackTraceElement : obtainedInstances.get(wrapper)) {\n          System.err.println(stackTraceElement.toString());\n        }\n      }\n    }\n    return (obtainedInstances.size() != 0);\n  }\n  /**\n   * Clear list of obtained instance objects. {@code areThereUnrecycledNodes}\n   * will always return false if called immediately afterwards.\n   */\n  @Resetter\n  public static void resetObtainedInstances() {\n    obtainedInstances.clear();\n    orderedInstances.clear();\n  }\n  @Implementation\n  protected void recycle() {\n    final StrictEqualityNodeWrapper wrapper =\n        new StrictEqualityNodeWrapper(realAccessibilityNodeInfo);\n    if (!obtainedInstances.containsKey(wrapper)) {\n      throw new IllegalStateException();\n    }\n    if (labelFor != null) {\n      labelFor.recycle();\n    }\n    if (labeledBy != null) {\n      labeledBy.recycle();\n    }\n    if (getApiLevel() >= LOLLIPOP_MR1) {\n      if (traversalAfter != null) {\n        traversalAfter.recycle();\n      }\n      if (traversalBefore != null) {\n        traversalBefore.recycle();\n      }\n    }\n    obtainedInstances.remove(wrapper);\n    int keyOfWrapper = -1;\n    for (int i = 0; i < orderedInstances.size(); i++) {\n      int key = orderedInstances.keyAt(i);\n      if (orderedInstances.get(key).equals(wrapper)) {\n        keyOfWrapper = key;\n        break;\n      }\n    }\n    orderedInstances.remove(keyOfWrapper);\n  }\n<fim_suffix>  @Implementation\n  protected int getChildCount() {\n    if (children == null) {\n      return 0;\n    }\n    return children.size();\n  }<fim_middle>// function below has no smell\n"}