{"text": "<fim_prefix>import org.apache.drill.exec.proto.ExecProtos.FragmentHandle;\nimport org.apache.drill.exec.proto.GeneralRPCProtos.Ack;\nimport org.apache.drill.exec.proto.UserBitShared.QueryId;\nimport org.apache.drill.exec.proto.UserBitShared.QueryProfile;\nimport org.apache.drill.exec.proto.helper.QueryIdHelper;\nimport org.apache.drill.exec.rpc.Acks;\nimport org.apache.drill.exec.rpc.RequestHandler;\nimport org.apache.drill.exec.rpc.Response;\nimport org.apache.drill.exec.rpc.ResponseSender;\nimport org.apache.drill.exec.rpc.RpcConstants;\nimport org.apache.drill.exec.rpc.RpcException;\nimport org.apache.drill.exec.rpc.UserRpcException;\nimport org.apache.drill.exec.rpc.control.ControlConnection;\nimport org.apache.drill.exec.rpc.control.ControlRpcConfig;\nimport org.apache.drill.exec.rpc.control.CustomHandlerRegistry;\nimport org.apache.drill.exec.server.DrillbitContext;\nimport org.apache.drill.exec.work.WorkManager.WorkerBee;\nimport org.apache.drill.exec.work.foreman.Foreman;\nimport org.apache.drill.exec.work.fragment.FragmentExecutor;\nimport org.apache.drill.exec.work.fragment.FragmentManager;\nimport org.apache.drill.exec.work.fragment.FragmentStatusReporter;\nimport org.apache.drill.exec.work.fragment.NonRootFragmentManager;\nimport static org.apache.drill.exec.rpc.RpcBus.get;\npublic class ControlMessageHandler implements RequestHandler<ControlConnection> {\n  private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(ControlMessageHandler.class);\n  private final WorkerBee bee;\n  private final CustomHandlerRegistry handlerRegistry = new CustomHandlerRegistry();\n  public ControlMessageHandler(final WorkerBee bee) {\n    this.bee = bee;\n  }\n  @Override\n  public void handle(ControlConnection connection, int rpcType, ByteBuf pBody, ByteBuf dBody,\n                     ResponseSender sender) throws RpcException {\n    if (RpcConstants.EXTRA_DEBUGGING) {\n      logger.debug(\"Received bit com message of type {}\", rpcType);\n    }\n    switch (rpcType) {\n    case RpcType.REQ_CANCEL_FRAGMENT_VALUE: {\n      final FragmentHandle handle = get(pBody, FragmentHandle.PARSER);\n      cancelFragment(handle);\n      sender.send(ControlRpcConfig.OK);\n      break;\n    }\n    case RpcType.REQ_CUSTOM_VALUE: {\n      final CustomMessage customMessage = get(pBody, CustomMessage.PARSER);\n      sender.send(handlerRegistry.handle(customMessage, (DrillBuf) dBody));\n      break;\n    }\n    case RpcType.REQ_RECEIVER_FINISHED_VALUE: {\n      final FinishedReceiver finishedReceiver = get(pBody, FinishedReceiver.PARSER);\n      receivingFragmentFinished(finishedReceiver);\n      sender.send(ControlRpcConfig.OK);\n      break;\n    }\n    case RpcType.REQ_FRAGMENT_STATUS_VALUE:\n      final FragmentStatus status = get(pBody, FragmentStatus.PARSER);\n      requestFragmentStatus(status);\n      // TODO: Support a type of message that has no response.\n      sender.send(ControlRpcConfig.OK);\n      break;\n    case RpcType.REQ_QUERY_CANCEL_VALUE: {\n      final QueryId queryId = get(pBody, QueryId.PARSER);\n      final Ack cancelStatus = requestQueryCancel(queryId);\n      if (cancelStatus.getOk()) {\n        sender.send(ControlRpcConfig.OK);\n      } else {\n        sender.send(ControlRpcConfig.FAIL);\n      }\n      break;\n    }\n    case RpcType.REQ_INITIALIZE_FRAGMENTS_VALUE: {\n      final InitializeFragments fragments = get(pBody, InitializeFragments.PARSER);\n      initializeFragment(fragments);\n      sender.send(ControlRpcConfig.OK);\n      break;\n    }\n    case RpcType.REQ_QUERY_STATUS_VALUE: {\n      final QueryId queryId = get(pBody, QueryId.PARSER);\n      final QueryProfile profile = requestQueryStatus(queryId);\n      sender.send(new Response(RpcType.RESP_QUERY_STATUS, profile));\n      break;\n    }\n    case RpcType.REQ_UNPAUSE_FRAGMENT_VALUE: {\n      final FragmentHandle handle = get(pBody, FragmentHandle.PARSER);\n      resumeFragment(handle);\n      sender.send(ControlRpcConfig.OK);\n      break;\n    }\n    default:\n      throw new RpcException(\"Not yet supported.\");\n    }\n  }\n  /**\n   * Start a new fragment on this node. These fragments can be leaf or intermediate fragments\n   * which are scheduled by remote or local Foreman node.\n   * @param fragment\n   * @throws UserRpcException\n   */\n  public void startNewFragment(final PlanFragment fragment, final DrillbitContext drillbitContext)\n      throws UserRpcException {\n    logger.debug(\"Received remote fragment start instruction\", fragment);\n    try {\n      final FragmentContextImpl fragmentContext = new FragmentContextImpl(drillbitContext, fragment,\n          drillbitContext.getFunctionImplementationRegistry());\n      final FragmentStatusReporter statusReporter = new FragmentStatusReporter(fragmentContext);\n      final FragmentExecutor fragmentExecutor = new FragmentExecutor(fragmentContext, fragment, statusReporter);\n      // we either need to start the fragment if it is a leaf fragment, or set up a fragment manager if it is non leaf.\n      if (fragment.getLeafFragment()) {\n        bee.addFragmentRunner(fragmentExecutor);\n      } else {\n        // isIntermediate, store for incoming data.\n        final NonRootFragmentManager manager = new NonRootFragmentManager(fragment, fragmentExecutor, statusReporter);\n        drillbitContext.getWorkBus().addFragmentManager(manager);\n      }\n    } catch (final ExecutionSetupException ex) {\n      throw new UserRpcException(drillbitContext.getEndpoint(), \"Failed to create fragment context\", ex);\n    } catch (final Exception e) {\n        throw new UserRpcException(drillbitContext.getEndpoint(),\n            \"Failure while trying to start remote fragment\", e);\n    } catch (final OutOfMemoryError t) {\n      if (t.getMessage().startsWith(\"Direct buffer\")) {\n        throw new UserRpcException(drillbitContext.getEndpoint(),\n            \"Out of direct memory while trying to start remote fragment\", t);\n      } else {\n        throw t;\n      }\n    }\n  }\n  /* (non-Javadoc)\n   * @see org.apache.drill.exec.work.batch.BitComHandler#cancelFragment(org.apache.drill.exec.proto.ExecProtos.FragmentHandle)\n   */\n  public Ack cancelFragment(final FragmentHandle handle) {\n    /**\n     * For case 1, see {@link org.apache.drill.exec.work.foreman.QueryManager#cancelExecutingFragments}.\n     * In comments below, \"active\" refers to fragment states: SENDING, AWAITING_ALLOCATION, RUNNING and\n     * \"inactive\" refers to FINISHED, CANCELLATION_REQUESTED, CANCELLED, FAILED\n     */\n    // Case 2: Cancel active intermediate fragment. Such a fragment will be in the work bus. Delegate cancel to the\n    // work bus.\n    final boolean removed = bee.getContext().getWorkBus().removeFragmentManager(handle, true);\n    if (removed) {\n      return Acks.OK;\n    }\n    // Case 3: Cancel active leaf fragment. Such a fragment will be with the worker bee if and only if it is running.\n    // Cancel directly in this case.\n    final FragmentExecutor runner = bee.getFragmentRunner(handle);\n    if (runner != null) {\n      runner.cancel();\n      return Acks.OK;\n    }\n    // Other cases: Fragment completed or does not exist. Currently known cases:\n    // (1) Leaf or intermediate fragment that is inactive: although we should not receive a cancellation\n    //     request; it is possible that before the fragment state was updated in the QueryManager, this handler\n    //     received a cancel signal.\n    // (2) Unknown fragment.\n    logger.warn(\"Dropping request to cancel fragment. {} does not exist.\", QueryIdHelper.getQueryIdentifier(handle));\n    return Acks.OK;\n  }\n<fim_suffix>  public Ack resumeFragment(final FragmentHandle handle) {\n    // resume a pending fragment\n    final FragmentManager manager = bee.getContext().getWorkBus().getFragmentManager(handle);\n    if (manager != null) {\n      manager.unpause();\n      return Acks.OK;\n    }\n    // resume a paused fragment\n    final FragmentExecutor runner = bee.getFragmentRunner(handle);\n    if (runner != null) {\n      runner.unpause();\n      return Acks.OK;\n    }\n    // fragment completed or does not exist\n    logger.warn(\"Dropping request to resume fragment. {} does not exist.\", QueryIdHelper.getQueryIdentifier(handle));\n    return Acks.OK;\n  }<fim_middle>// function below has no smell\n"}