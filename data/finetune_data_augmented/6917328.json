{"text": "<fim_prefix>    return (short) ((data[position++] & 0xFF) << 8\n        | (data[position++] & 0xFF));\n  }\n  /**\n   * Reads the next two bytes as a signed value.\n   */\n  public short readLittleEndianShort() {\n    return (short) ((data[position++] & 0xFF) | (data[position++] & 0xFF) << 8);\n  }\n  /**\n   * Reads the next three bytes as an unsigned value.\n   */\n  public int readUnsignedInt24() {\n    return (data[position++] & 0xFF) << 16\n        | (data[position++] & 0xFF) << 8\n        | (data[position++] & 0xFF);\n  }\n  /**\n   * Reads the next three bytes as a signed value.\n   */\n  public int readInt24() {\n    return ((data[position++] & 0xFF) << 24) >> 8\n        | (data[position++] & 0xFF) << 8\n        | (data[position++] & 0xFF);\n  }\n  /**\n   * Reads the next three bytes as a signed value in little endian order.\n   */\n  public int readLittleEndianInt24() {\n    return (data[position++] & 0xFF)\n        | (data[position++] & 0xFF) << 8\n        | (data[position++] & 0xFF) << 16;\n  }\n  /**\n   * Reads the next three bytes as an unsigned value in little endian order.\n   */\n  public int readLittleEndianUnsignedInt24() {\n    return (data[position++] & 0xFF)\n        | (data[position++] & 0xFF) << 8\n        | (data[position++] & 0xFF) << 16;\n  }\n  /**\n   * Reads the next four bytes as an unsigned value.\n   */\n  public long readUnsignedInt() {\n    return (data[position++] & 0xFFL) << 24\n        | (data[position++] & 0xFFL) << 16\n        | (data[position++] & 0xFFL) << 8\n        | (data[position++] & 0xFFL);\n  }\n  /**\n   * Reads the next four bytes as an unsigned value in little endian order.\n   */\n  public long readLittleEndianUnsignedInt() {\n    return (data[position++] & 0xFFL)\n        | (data[position++] & 0xFFL) << 8\n        | (data[position++] & 0xFFL) << 16\n        | (data[position++] & 0xFFL) << 24;\n  }\n  /**\n   * Reads the next four bytes as a signed value\n   */\n  public int readInt() {\n    return (data[position++] & 0xFF) << 24\n        | (data[position++] & 0xFF) << 16\n        | (data[position++] & 0xFF) << 8\n        | (data[position++] & 0xFF);\n  }\n  /**\n   * Reads the next four bytes as a signed value in little endian order.\n   */\n  public int readLittleEndianInt() {\n    return (data[position++] & 0xFF)\n        | (data[position++] & 0xFF) << 8\n        | (data[position++] & 0xFF) << 16\n        | (data[position++] & 0xFF) << 24;\n  }\n  /**\n   * Reads the next eight bytes as a signed value.\n   */\n  public long readLong() {\n    return (data[position++] & 0xFFL) << 56\n        | (data[position++] & 0xFFL) << 48\n        | (data[position++] & 0xFFL) << 40\n        | (data[position++] & 0xFFL) << 32\n        | (data[position++] & 0xFFL) << 24\n        | (data[position++] & 0xFFL) << 16\n        | (data[position++] & 0xFFL) << 8\n        | (data[position++] & 0xFFL);\n  }\n  /**\n   * Reads the next eight bytes as a signed value in little endian order.\n   */\n  public long readLittleEndianLong() {\n    return (data[position++] & 0xFFL)\n        | (data[position++] & 0xFFL) << 8\n        | (data[position++] & 0xFFL) << 16\n        | (data[position++] & 0xFFL) << 24\n        | (data[position++] & 0xFFL) << 32\n        | (data[position++] & 0xFFL) << 40\n        | (data[position++] & 0xFFL) << 48\n        | (data[position++] & 0xFFL) << 56;\n  }\n  /**\n   * Reads the next four bytes, returning the integer portion of the fixed point 16.16 integer.\n   */\n  public int readUnsignedFixedPoint1616() {\n    int result = (data[position++] & 0xFF) << 8\n        | (data[position++] & 0xFF);\n    position += 2; // Skip the non-integer portion.\n    return result;\n  }\n  /**\n   * Reads a Synchsafe integer.\n   * <p>\n   * Synchsafe integers keep the highest bit of every byte zeroed. A 32 bit synchsafe integer can\n   * store 28 bits of information.\n   *\n   * @return The parsed value.\n   */\n  public int readSynchSafeInt() {\n    int b1 = readUnsignedByte();\n    int b2 = readUnsignedByte();\n    int b3 = readUnsignedByte();\n    int b4 = readUnsignedByte();\n    return (b1 << 21) | (b2 << 14) | (b3 << 7) | b4;\n  }\n  /**\n   * Reads the next four bytes as an unsigned integer into an integer, if the top bit is a zero.\n   *\n   * @throws IllegalStateException Thrown if the top bit of the input data is set.\n   */\n  public int readUnsignedIntToInt() {\n    int result = readInt();\n    if (result < 0) {\n      throw new IllegalStateException(\"Top bit not zero: \" + result);\n    }\n    return result;\n  }\n  /**\n   * Reads the next four bytes as a little endian unsigned integer into an integer, if the top bit\n   * is a zero.\n   *\n   * @throws IllegalStateException Thrown if the top bit of the input data is set.\n   */\n  public int readLittleEndianUnsignedIntToInt() {\n    int result = readLittleEndianInt();\n    if (result < 0) {\n      throw new IllegalStateException(\"Top bit not zero: \" + result);\n    }\n    return result;\n  }\n  /**\n   * Reads the next eight bytes as an unsigned long into a long, if the top bit is a zero.\n   *\n   * @throws IllegalStateException Thrown if the top bit of the input data is set.\n   */\n  public long readUnsignedLongToLong() {\n    long result = readLong();\n    if (result < 0) {\n      throw new IllegalStateException(\"Top bit not zero: \" + result);\n    }\n    return result;\n  }\n  /**\n   * Reads the next four bytes as a 32-bit floating point value.\n   */\n  public float readFloat() {\n    return Float.intBitsToFloat(readInt());\n  }\n  /**\n   * Reads the next eight bytes as a 64-bit floating point value.\n   */\n  public double readDouble() {\n    return Double.longBitsToDouble(readLong());\n  }\n  /**\n   * Reads the next {@code length} bytes as UTF-8 characters.\n   *\n   * @param length The number of bytes to read.\n   * @return The string encoded by the bytes.\n   */\n  public String readString(int length) {\n    return readString(length, Charset.forName(C.UTF8_NAME));\n  }\n  /**\n   * Reads the next {@code length} bytes as characters in the specified {@link Charset}.\n   *\n   * @param length The number of bytes to read.\n   * @param charset The character set of the encoded characters.\n   * @return The string encoded by the bytes in the specified character set.\n   */\n  public String readString(int length, Charset charset) {\n    String result = new String(data, position, length, charset);\n    position += length;\n    return result;\n  }\n  /**\n   * Reads the next {@code length} bytes as UTF-8 characters. A terminating NUL byte is discarded,\n   * if present.\n   *\n   * @param length The number of bytes to read.\n   * @return The string, not including any terminating NUL byte.\n   */\n<fim_suffix>  public String readNullTerminatedString(int length) {\n    if (length == 0) {\n      return \"\";\n    }\n    int stringLength = length;\n    int lastIndex = position + length - 1;\n    if (lastIndex < limit && data[lastIndex] == 0) {\n      stringLength--;\n    }\n    String result = Util.fromUtf8Bytes(data, position, stringLength);\n    position += length;\n    return result;\n  }<fim_middle>// function below has no smell\n"}