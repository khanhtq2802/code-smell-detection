{"text": "<fim_prefix>      SchedulingMode schedulingMode, boolean activeMode) {\n    // preselect stored map as per active user-limit or all user computation.\n    Map<String, Map<SchedulingMode, Resource>> computedMap = null;\n    computedMap = (activeMode)\n        ? preComputedActiveUserLimit\n        : preComputedAllUserLimit;\n    Map<SchedulingMode, Resource> userLimitPerSchedulingMode = computedMap\n        .get(nodePartition);\n    if (userLimitPerSchedulingMode == null) {\n      userLimitPerSchedulingMode = new ConcurrentHashMap<>();\n      computedMap.put(nodePartition, userLimitPerSchedulingMode);\n    }\n    // compute user-limit per scheduling mode.\n    Resource computedUserLimit = computeUserLimit(userName, clusterResource,\n        nodePartition, schedulingMode, activeMode);\n    // update in local storage\n    userLimitPerSchedulingMode.put(schedulingMode, computedUserLimit);\n    computeNumActiveUsersWithOnlyPendingApps();\n    return userLimitPerSchedulingMode;\n  }\n  // This method is called within the lock.\n  private void computeNumActiveUsersWithOnlyPendingApps() {\n    int numPendingUsers = 0;\n    for (User user : users.values()) {\n      if ((user.getPendingApplications() > 0)\n          && (user.getActiveApplications() <= 0)) {\n        numPendingUsers++;\n      }\n    }\n    activeUsersWithOnlyPendingApps = new AtomicInteger(numPendingUsers);\n  }\n  private Resource computeUserLimit(String userName, Resource clusterResource,\n      String nodePartition, SchedulingMode schedulingMode, boolean activeUser) {\n    Resource partitionResource = labelManager.getResourceByLabel(nodePartition,\n        clusterResource);\n    /*\n     * What is our current capacity?\n     * * It is equal to the max(required, queue-capacity) if we're running\n     * below capacity. The 'max' ensures that jobs in queues with miniscule\n     * capacity (< 1 slot) make progress\n     * * If we're running over capacity, then its (usedResources + required)\n     * (which extra resources we are allocating)\n     */\n    Resource queueCapacity = lQueue.getEffectiveCapacity(nodePartition);\n    /*\n     * Assume we have required resource equals to minimumAllocation, this can\n     * make sure user limit can continuously increase till queueMaxResource\n     * reached.\n     */\n    Resource required = lQueue.getMinimumAllocation();\n    // Allow progress for queues with miniscule capacity\n    queueCapacity = Resources.max(resourceCalculator, partitionResource,\n        queueCapacity, required);\n    /*\n     * We want to base the userLimit calculation on\n     * max(queueCapacity, usedResources+required). However, we want\n     * usedResources to be based on the combined ratios of all the users in the\n     * queue so we use consumedRatio to calculate such.\n     * The calculation is dependent on how the resourceCalculator calculates the\n     * ratio between two Resources. DRF Example: If usedResources is greater\n     * than queueCapacity and users have the following [mem,cpu] usages:\n     *\n     * User1: [10%,20%] - Dominant resource is 20%\n     * User2: [30%,10%] - Dominant resource is 30%\n     * Then total consumedRatio is then 20+30=50%. Yes, this value can be\n     * larger than 100% but for the purposes of making sure all users are\n     * getting their fair share, it works.\n     */\n    Resource consumed = Resources.multiplyAndNormalizeUp(resourceCalculator,\n        partitionResource, getUsageRatio(nodePartition),\n        lQueue.getMinimumAllocation());\n    Resource currentCapacity = Resources.lessThan(resourceCalculator,\n        partitionResource, consumed, queueCapacity)\n            ? queueCapacity\n            : Resources.add(consumed, required);\n    /*\n     * Never allow a single user to take more than the queue's configured\n     * capacity * user-limit-factor. Also, the queue's configured capacity\n     * should be higher than queue-hard-limit * ulMin\n     */\n    float usersSummedByWeight = activeUsersTimesWeights;\n    Resource resourceUsed = Resources.add(\n                            totalResUsageForActiveUsers.getUsed(nodePartition),\n                            required);\n    // For non-activeUser calculation, consider all users count.\n    if (!activeUser) {\n      resourceUsed = currentCapacity;\n      usersSummedByWeight = allUsersTimesWeights;\n    }\n    /*\n     * User limit resource is determined by: max(currentCapacity / #activeUsers,\n     * currentCapacity * user-limit-percentage%)\n     */\n    Resource userLimitResource = Resources.max(resourceCalculator,\n        partitionResource,\n        Resources.divideAndCeil(resourceCalculator, resourceUsed,\n            usersSummedByWeight),\n        Resources.divideAndCeil(resourceCalculator,\n            Resources.multiplyAndRoundDown(currentCapacity, getUserLimit()),\n            100));\n    // User limit is capped by maxUserLimit\n    // - maxUserLimit = queueCapacity * user-limit-factor\n    // (RESPECT_PARTITION_EXCLUSIVITY)\n    // - maxUserLimit = total-partition-resource (IGNORE_PARTITION_EXCLUSIVITY)\n    //\n    // In IGNORE_PARTITION_EXCLUSIVITY mode, if a queue cannot access a\n    // partition, its guaranteed resource on that partition is 0. And\n    // user-limit-factor computation is based on queue's guaranteed capacity. So\n    // we will not cap user-limit as well as used resource when doing\n    // IGNORE_PARTITION_EXCLUSIVITY allocation.\n    Resource maxUserLimit = Resources.none();\n    if (schedulingMode == SchedulingMode.RESPECT_PARTITION_EXCLUSIVITY) {\n      maxUserLimit = Resources.multiplyAndRoundDown(queueCapacity,\n          getUserLimitFactor());\n    } else if (schedulingMode == SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      maxUserLimit = partitionResource;\n    }\n    // Cap final user limit with maxUserLimit\n    userLimitResource = Resources\n        .roundUp(resourceCalculator,\n            Resources.min(resourceCalculator, partitionResource,\n                userLimitResource, maxUserLimit),\n            lQueue.getMinimumAllocation());\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"User limit computation for \" + userName\n          + \",  in queue: \" + lQueue.getQueueName()\n          + \",  userLimitPercent=\" + lQueue.getUserLimit()\n          + \",  userLimitFactor=\" + lQueue.getUserLimitFactor()\n          + \",  required=\" + required\n          + \",  consumed=\" + consumed\n          + \",  user-limit-resource=\" + userLimitResource\n          + \",  queueCapacity=\" + queueCapacity\n          + \",  qconsumed=\" + lQueue.getQueueResourceUsage().getUsed()\n          + \",  currentCapacity=\" + currentCapacity\n          + \",  activeUsers=\" + usersSummedByWeight\n          + \",  clusterCapacity=\" + clusterResource\n          + \",  resourceByLabel=\" + partitionResource\n          + \",  usageratio=\" + getUsageRatio(nodePartition)\n          + \",  Partition=\" + nodePartition\n          + \",  resourceUsed=\" + resourceUsed\n          + \",  maxUserLimit=\" + maxUserLimit\n          + \",  userWeight=\" + getUser(userName).getWeight()\n      );\n    }\n    return userLimitResource;\n  }\n  /**\n   * Update new usage ratio.\n   *\n   * @param partition\n   *          Node partition\n   * @param clusterResource\n   *          Cluster Resource\n   */\n  public void updateUsageRatio(String partition, Resource clusterResource) {\n    writeLock.lock();\n    try {\n      Resource resourceByLabel = labelManager.getResourceByLabel(partition,\n          clusterResource);\n      float consumed = 0;\n      User user;\n      for (Map.Entry<String, User> entry : getUsers().entrySet()) {\n        user = entry.getValue();\n        consumed += user.setAndUpdateUsageRatio(resourceCalculator,\n            resourceByLabel, partition);\n      }\n      qUsageRatios.setUsageRatio(partition, consumed);\n    } finally {\n      writeLock.unlock();\n    }\n  }\n  /*\n   * Increment Queue Usage Ratio.\n   */\n  private void incQueueUsageRatio(String nodePartition, float delta) {\n    qUsageRatios.incUsageRatio(nodePartition, delta);\n  }\n<fim_suffix>  @Override\n  public void activateApplication(String user, ApplicationId applicationId) {\n    this.writeLock.lock();\n    try {\n      User userDesc = getUser(user);\n      if (userDesc != null && userDesc.getActiveApplications() <= 0) {\n        return;\n      }\n      Set<ApplicationId> userApps = usersApplications.get(user);\n      if (userApps == null) {\n        userApps = new HashSet<ApplicationId>();\n        usersApplications.put(user, userApps);\n        activeUsers.incrementAndGet();\n        metrics.incrActiveUsers();\n        // A user is added to active list. Invalidate user-limit cache.\n        userLimitNeedsRecompute();\n        updateActiveUsersResourceUsage(user);\n        LOG.debug(\"User {} added to activeUsers, currently: {}\",\n            user, activeUsers);\n      }\n      if (userApps.add(applicationId)) {\n        metrics.activateApp(user);\n      }\n    } finally {\n      this.writeLock.unlock();\n    }\n  }<fim_middle>// function below has no smell\n"}