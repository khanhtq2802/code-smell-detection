{"text": "<fim_prefix>     * This field holds a list with an {@link AutomationResourceBundlesEventQueue} instances owned by\n     * {@link AbstractResourceBundleProvider}s of {@link ModuleType}s, {@link Template}s and {@link Rule}s.\n     */\n    @SuppressWarnings(\"rawtypes\")\n    private final List<AutomationResourceBundlesEventQueue> providerEventsQueue = new ArrayList<AutomationResourceBundlesEventQueue>();\n    /**\n     * This field holds a reference to an importer of {@link Rule}s.\n     */\n    protected RuleResourceBundleImporter rImporter;\n    /**\n     * This field is a bundle tracker for bundles providing automation resources.\n     */\n    private BundleTracker<Bundle> bTracker;\n    /**\n     * This field serves for saving the BundleEvents for the bundles providing automation resources until their\n     * processing completes. The events have been for adding, modifying or removing a bundle.\n     */\n    private final List<BundleEvent> queue = new LinkedList<BundleEvent>();\n    public AutomationResourceBundlesTracker() {\n        rImporter = createImporter();\n    }\n    protected RuleResourceBundleImporter createImporter() {\n        return new RuleResourceBundleImporter();\n    }\n    @Activate\n    protected void activate(BundleContext bc) {\n        bTracker = new BundleTracker<Bundle>(bc, ~Bundle.UNINSTALLED, this);\n        bTracker.open();\n    }\n    @Deactivate\n    protected void deactivate(BundleContext bc) {\n        bTracker.close();\n        bTracker = null;\n        rImporter.deactivate();\n    }\n    @SuppressWarnings({ \"rawtypes\" })\n    @Reference(cardinality = ReferenceCardinality.MULTIPLE, policy = ReferencePolicy.DYNAMIC, target = \"(provider.type=bundle)\")\n    protected void addProvider(Provider provider) {\n        if (provider instanceof AbstractResourceBundleProvider) {\n            addAbstractResourceBundleProvider((AbstractResourceBundleProvider) provider);\n        }\n    }\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    protected void addAbstractResourceBundleProvider(AbstractResourceBundleProvider provider) {\n        AutomationResourceBundlesEventQueue queue = provider.getQueue();\n        synchronized (this.queue) {\n            queue.addAll(this.queue);\n            providerEventsQueue.add(queue);\n        }\n    }\n    @SuppressWarnings({ \"rawtypes\" })\n    protected void removeProvider(Provider provider) {\n        if (provider instanceof AbstractResourceBundleProvider) {\n            removeAbstractResourceBundleProvider((AbstractResourceBundleProvider) provider);\n        }\n    }\n    @SuppressWarnings({ \"rawtypes\" })\n    protected void removeAbstractResourceBundleProvider(AbstractResourceBundleProvider provider) {\n        AutomationResourceBundlesEventQueue queue = provider.getQueue();\n        synchronized (this.queue) {\n            providerEventsQueue.remove(queue);\n        }\n    }\n    @Reference(cardinality = ReferenceCardinality.OPTIONAL, policy = ReferencePolicy.DYNAMIC)\n    protected void setManagedRuleProvider(ManagedRuleProvider mProvider) {\n        rImporter.setManagedRuleProvider(mProvider);\n        rImporter.activate(null);\n        addAbstractResourceBundleProvider(rImporter);\n    }\n    protected void unsetManagedRuleProvider(ManagedRuleProvider mProvider) {\n        removeAbstractResourceBundleProvider(rImporter);\n        rImporter.deactivate();\n    }\n    /**\n     * This method provides functionality for tracking {@link Parser} services.\n     *\n     * @param parser {@link Parser} service\n     * @param properties of the service that has been added.\n     */\n    @Reference(cardinality = ReferenceCardinality.MULTIPLE, policy = ReferencePolicy.DYNAMIC, target = \"(parser.type=parser.rule)\")\n    protected void addParser(Parser<Rule> parser, Map<String, String> properties) {\n        rImporter.addParser(parser, properties);\n    }\n    /**\n     * This method provides functionality for tracking {@link Parser} services.\n     *\n     * @param parser {@link Parser} service\n     * @param properties of the service that has been removed.\n     */\n    protected void removeParser(Parser<Rule> parser, Map<String, String> properties) {\n        rImporter.removeParser(parser, properties);\n    }\n    @Reference\n    protected void setPackageAdmin(PackageAdmin pkgAdmin) {\n        HostFragmentMappingUtil.pkgAdmin = pkgAdmin;\n    }\n    protected void unsetPackageAdmin(PackageAdmin pkgAdmin) {\n        HostFragmentMappingUtil.pkgAdmin = null;\n    }\n    /**\n     * A bundle that provides automation resources is being added to the {@code BundleTracker}.\n     *\n     * <p>\n     * This method is called before a bundle that provides automation resources is added to the {@code BundleTracker}.\n     * This method returns the object to be tracked for the specified {@code Bundle}. The returned object is stored in\n     * the {@code BundleTracker} and is available from the {@link BundleTracker#getObject(Bundle) getObject} method.\n     *\n     * @param bundle The {@code Bundle} being added to the {@code BundleTracker} .\n     * @param event The bundle event which caused this customizer method to be\n     *            called or {@code null} if there is no bundle event associated with\n     *            the call to this method.\n     * @return The object to be tracked for the specified {@code Bundle} object\n     *         or {@code null} if the specified {@code Bundle} object should not\n     *         be tracked.\n     */\n    @Override\n    public Bundle addingBundle(Bundle bundle, BundleEvent event) {\n        if (isAnAutomationProvider(bundle)) {\n            if (HostFragmentMappingUtil.isFragmentBundle(bundle)) {\n                List<Bundle> hosts = HostFragmentMappingUtil.returnHostBundles(bundle);\n                if (HostFragmentMappingUtil.needToProcessFragment(bundle, hosts)) {\n                    addEvent(bundle, event);\n                    HostFragmentMappingUtil.fillHostFragmentMapping(hosts);\n                }\n            } else {\n                HostFragmentMappingUtil.fillHostFragmentMapping(bundle);\n                addEvent(bundle, event);\n            }\n        } else if (!HostFragmentMappingUtil.isFragmentBundle(bundle)) {\n            List<Bundle> fragments = HostFragmentMappingUtil.fillHostFragmentMapping(bundle);\n            for (Bundle fragment : fragments) {\n                if (isAnAutomationProvider(fragment)) {\n                    addEvent(bundle, event);\n                    break;\n                }\n            }\n        }\n        return bundle;\n    }\n    /**\n     * A bundle tracked by the {@code BundleTracker} has been modified.\n     *\n     * <p>\n     * This method is called when a bundle being tracked by the {@code BundleTracker} has had its state modified.\n     *\n     * @param bundle The {@code Bundle} whose state has been modified.\n     * @param event The bundle event which caused this customizer method to be\n     *            called or {@code null} if there is no bundle event associated with\n     *            the call to this method.\n     * @param object The tracked object for the specified bundle.\n     */\n    @Override\n    public void modifiedBundle(Bundle bundle, BundleEvent event, Bundle object) {\n        int type = event.getType();\n        if (type == BundleEvent.UPDATED || type == BundleEvent.RESOLVED) {\n            addEvent(bundle, event);\n        }\n    }\n    /**\n     * A bundle tracked by the {@code BundleTracker} has been removed.\n     *\n     * <p>\n     * This method is called after a bundle is no longer being tracked by the {@code BundleTracker}.\n     *\n     * @param bundle The {@code Bundle} that has been removed.\n     * @param event The bundle event which caused this customizer method to be\n     *            called or {@code null} if there is no bundle event associated with\n     *            the call to this method.\n     * @param object The tracked object for the specified bundle.\n     */\n    @Override\n    public void removedBundle(Bundle bundle, BundleEvent event, Bundle object) {\n        if (HostFragmentMappingUtil.isFragmentBundle(bundle)) {\n            for (Entry<Bundle, List<Bundle>> entry : HostFragmentMappingUtil.getMapping()) {\n                if (entry.getValue().contains(bundle)) {\n                    Bundle host = entry.getKey();\n                    addEvent(host, new BundleEvent(BundleEvent.UPDATED, host));\n                }\n            }\n        } else {\n            addEvent(bundle, event);\n        }\n    }\n    /**\n     * This method is called when a new event for a bundle providing automation resources is received. It causes a\n     * creation of a new thread if there is no other created yet and starting the thread. If the thread already exists,\n     * it is waiting for events and will be notified for the event.\n     *\n     * @param bundle\n     *\n     * @param event for a bundle tracked by the {@code BundleTracker}. It has been for adding, modifying or removing the\n     *            bundle.\n     */\n    @SuppressWarnings({ \"rawtypes\" })\n    protected void addEvent(Bundle bundle, BundleEvent event) {\n        BundleEvent e = event != null ? event : initializeEvent(bundle);\n        synchronized (queue) {\n            queue.add(e);\n            for (AutomationResourceBundlesEventQueue queue : providerEventsQueue) {\n                queue.addEvent(bundle, e);\n            }\n        }\n    }\n<fim_suffix>    private BundleEvent initializeEvent(Bundle bundle) {\n        switch (bundle.getState()) {\n            case Bundle.INSTALLED:\n                return new BundleEvent(BundleEvent.INSTALLED, bundle);\n            case Bundle.RESOLVED:\n                return new BundleEvent(BundleEvent.RESOLVED, bundle);\n            default:\n                return new BundleEvent(BundleEvent.STARTED, bundle);\n        }\n    }<fim_middle>// function below has no smell\n"}