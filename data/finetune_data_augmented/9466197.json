{"text": "<fim_prefix>          long value = RMServerUtils\n              .getOrDefault(resourceSecondsMap, entry.getName(), 0L);\n          value += entry.getValue() * usedMillis\n              / DateUtils.MILLIS_PER_SECOND;\n          resourceSecondsMap.put(entry.getName(), value);\n        }\n      }\n      lastMemoryAggregateAllocationUpdateTime = currentTimeMillis;\n      lastResourceSecondsMap = resourceSecondsMap;\n    }\n    return new AggregateAppResourceUsage(lastResourceSecondsMap);\n  }\n  public ApplicationResourceUsageReport getResourceUsageReport() {\n    writeLock.lock();\n    try {\n      AggregateAppResourceUsage runningResourceUsage =\n          getRunningAggregateAppResourceUsage();\n      Resource usedResourceClone = Resources.clone(\n          attemptResourceUsage.getAllUsed());\n      Resource reservedResourceClone = Resources.clone(\n          attemptResourceUsage.getReserved());\n      Resource cluster = rmContext.getScheduler().getClusterResource();\n      ResourceCalculator calc =\n          rmContext.getScheduler().getResourceCalculator();\n      Map<String, Long> preemptedResourceSecondsMaps = new HashMap<>();\n      preemptedResourceSecondsMaps\n          .put(ResourceInformation.MEMORY_MB.getName(), 0L);\n      preemptedResourceSecondsMaps\n          .put(ResourceInformation.VCORES.getName(), 0L);\n      float queueUsagePerc = 0.0f;\n      float clusterUsagePerc = 0.0f;\n      if (!calc.isInvalidDivisor(cluster)) {\n        float queueCapacityPerc = queue.getQueueInfo(false, false)\n            .getCapacity();\n        if (queueCapacityPerc != 0) {\n          queueUsagePerc = calc.divide(cluster, usedResourceClone,\n              Resources.multiply(cluster, queueCapacityPerc)) * 100;\n        }\n        clusterUsagePerc =\n            calc.divide(cluster, usedResourceClone, cluster) * 100;\n      }\n      return ApplicationResourceUsageReport\n          .newInstance(liveContainers.size(), reservedContainers.size(),\n              usedResourceClone, reservedResourceClone,\n              Resources.add(usedResourceClone, reservedResourceClone),\n              runningResourceUsage.getResourceUsageSecondsMap(), queueUsagePerc,\n              clusterUsagePerc, preemptedResourceSecondsMaps);\n    } finally {\n      writeLock.unlock();\n    }\n  }\n  @VisibleForTesting\n  public Map<ContainerId, RMContainer> getLiveContainersMap() {\n    return this.liveContainers;\n  }\n  public Map<SchedulerRequestKey, Long>\n      getLastScheduledContainer() {\n    return this.lastScheduledContainer;\n  }\n  public void transferStateFromPreviousAttempt(\n      SchedulerApplicationAttempt appAttempt) {\n    writeLock.lock();\n    try {\n      this.liveContainers = appAttempt.getLiveContainersMap();\n      // this.reReservations = appAttempt.reReservations;\n      this.attemptResourceUsage.copyAllUsed(appAttempt.attemptResourceUsage);\n      this.setHeadroom(appAttempt.resourceLimit);\n      // this.currentReservation = appAttempt.currentReservation;\n      // this.newlyAllocatedContainers = appAttempt.newlyAllocatedContainers;\n      // this.schedulingOpportunities = appAttempt.schedulingOpportunities;\n      this.lastScheduledContainer = appAttempt.getLastScheduledContainer();\n      this.appSchedulingInfo.transferStateFromPreviousAppSchedulingInfo(\n          appAttempt.appSchedulingInfo);\n    } finally {\n      writeLock.unlock();\n    }\n  }\n  public void move(Queue newQueue) {\n    writeLock.lock();\n    try {\n      QueueMetrics oldMetrics = queue.getMetrics();\n      QueueMetrics newMetrics = newQueue.getMetrics();\n      String newQueueName = newQueue.getQueueName();\n      String user = getUser();\n      for (RMContainer liveContainer : liveContainers.values()) {\n        Resource resource = liveContainer.getContainer().getResource();\n        ((RMContainerImpl) liveContainer).setQueueName(newQueueName);\n        oldMetrics.releaseResources(liveContainer.getNodeLabelExpression(),\n            user, 1, resource);\n        newMetrics.allocateResources(liveContainer.getNodeLabelExpression(),\n            user, 1, resource, false);\n      }\n      for (Map<NodeId, RMContainer> map : reservedContainers.values()) {\n        for (RMContainer reservedContainer : map.values()) {\n          ((RMContainerImpl) reservedContainer).setQueueName(newQueueName);\n          Resource resource = reservedContainer.getReservedResource();\n          oldMetrics.unreserveResource(\n              reservedContainer.getNodeLabelExpression(), user, resource);\n          newMetrics.reserveResource(\n              reservedContainer.getNodeLabelExpression(), user, resource);\n        }\n      }\n      if (!isStopped) {\n        appSchedulingInfo.move(newQueue);\n      }\n      this.queue = newQueue;\n    } finally {\n      writeLock.unlock();\n    }\n  }\n  public void recoverContainer(SchedulerNode node,\n      RMContainer rmContainer) {\n    writeLock.lock();\n    try {\n      // recover app scheduling info\n      appSchedulingInfo.recoverContainer(rmContainer, node.getPartition());\n      if (rmContainer.getState().equals(RMContainerState.COMPLETED)) {\n        return;\n      }\n      LOG.info(\"SchedulerAttempt \" + getApplicationAttemptId()\n          + \" is recovering container \" + rmContainer.getContainerId());\n      addRMContainer(rmContainer.getContainerId(), rmContainer);\n      if (rmContainer.getExecutionType() == ExecutionType.GUARANTEED) {\n        attemptResourceUsage.incUsed(node.getPartition(),\n            rmContainer.getContainer().getResource());\n      }\n      // resourceLimit: updated when LeafQueue#recoverContainer#allocateResource\n      // is called.\n      // newlyAllocatedContainers.add(rmContainer);\n      // schedulingOpportunities\n      // lastScheduledContainer\n    } finally {\n      writeLock.unlock();\n    }\n  }\n  public void incNumAllocatedContainers(NodeType containerType,\n      NodeType requestType) {\n    if (containerType == null || requestType == null) {\n      // Sanity check\n      return;\n    }\n    RMApp app = rmContext.getRMApps().get(attemptId.getApplicationId());\n    if (app != null) {\n      RMAppAttempt attempt = app.getCurrentAppAttempt();\n      if (attempt != null) {\n        attempt.getRMAppAttemptMetrics()\n            .incNumAllocatedContainers(containerType, requestType);\n      }\n    }\n  }\n  public void setApplicationHeadroomForMetrics(Resource headroom) {\n    RMAppAttempt attempt =\n        rmContext.getRMApps().get(attemptId.getApplicationId())\n            .getCurrentAppAttempt();\n    if (attempt != null) {\n      attempt.getRMAppAttemptMetrics().setApplicationAttemptHeadRoom(\n          Resources.clone(headroom));\n    }\n  }\n  public void recordContainerRequestTime(long value) {\n    firstAllocationRequestSentTime.compareAndSet(0, value);\n  }\n  public void recordContainerAllocationTime(long value) {\n    if (firstContainerAllocatedTime.compareAndSet(0, value)) {\n      long timediff = firstContainerAllocatedTime.longValue() -\n          firstAllocationRequestSentTime.longValue();\n      if (timediff > 0) {\n        queue.getMetrics().addAppAttemptFirstContainerAllocationDelay(timediff);\n      }\n    }\n  }\n  public Set<String> getBlacklistedNodes() {\n    return this.appSchedulingInfo.getBlackListCopy();\n  }\n  @Private\n  public boolean hasPendingResourceRequest(String nodePartition,\n      SchedulingMode schedulingMode) {\n    // We need to consider unconfirmed allocations\n    if (schedulingMode == SchedulingMode.IGNORE_PARTITION_EXCLUSIVITY) {\n      nodePartition = RMNodeLabelsManager.NO_LABEL;\n    }\n    Resource pending = attemptResourceUsage.getPending(nodePartition);\n    // TODO, need consider node partition here\n    // To avoid too many allocation-proposals rejected for non-default\n    // partition allocation\n    if (StringUtils.equals(nodePartition, RMNodeLabelsManager.NO_LABEL)) {\n      pending = Resources.subtractNonNegative(pending, Resources\n          .createResource(unconfirmedAllocatedMem.get(),\n              unconfirmedAllocatedVcores.get()));\n    }\n    return !Resources.isNone(pending);\n  }\n  /*\n   * Note that the behavior of appAttemptResourceUsage is different from queue's\n   * For queue, used = actual-used + reserved\n   * For app, used = actual-used.\n   *\n   * TODO (wangda): Need to make behaviors of queue/app's resource usage\n   * consistent\n   */\n  @VisibleForTesting\n  public ResourceUsage getAppAttemptResourceUsage() {\n    return this.attemptResourceUsage;\n  }\n  @Override\n  public Priority getPriority() {\n    return appPriority;\n  }\n  public void setPriority(Priority appPriority) {\n    this.appPriority = appPriority;\n  }\n  @Override\n  public String getId() {\n    return getApplicationId().toString();\n  }\n<fim_suffix>  @Override\n  public int compareInputOrderTo(SchedulableEntity other) {\n    if (other instanceof SchedulerApplicationAttempt) {\n      return getApplicationId().compareTo(\n        ((SchedulerApplicationAttempt)other).getApplicationId());\n    }\n    return 1;//let other types go before this, if any\n  }<fim_middle>// function below has no smell\n"}