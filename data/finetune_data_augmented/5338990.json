{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.nifi.remote.protocol.http;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.nifi.events.EventReporter;\nimport org.apache.nifi.remote.AbstractTransaction;\nimport org.apache.nifi.remote.Peer;\nimport org.apache.nifi.remote.TransferDirection;\nimport org.apache.nifi.remote.codec.StandardFlowFileCodec;\nimport org.apache.nifi.remote.io.http.HttpCommunicationsSession;\nimport org.apache.nifi.remote.protocol.Response;\nimport org.apache.nifi.remote.protocol.ResponseCode;\nimport org.apache.nifi.remote.util.SiteToSiteRestApiClient;\nimport org.apache.nifi.web.api.entity.TransactionResultEntity;\n\npublic class HttpClientTransaction extends AbstractTransaction {\n\n    private SiteToSiteRestApiClient apiClient;\n    private String transactionUrl;\n\n    public HttpClientTransaction(final int protocolVersion, final Peer peer, TransferDirection direction,\n                                 final boolean useCompression, final String portId, int penaltyMillis, EventReporter eventReporter) throws IOException {\n        super(peer, direction, useCompression, new StandardFlowFileCodec(), eventReporter, protocolVersion, penaltyMillis, portId);\n    }\n\n    public void initialize(SiteToSiteRestApiClient apiUtil, String transactionUrl) throws IOException {\n        this.transactionUrl = transactionUrl;\n        this.apiClient = apiUtil;\n        if(TransferDirection.RECEIVE.equals(direction)){\n            dataAvailable = apiUtil.openConnectionForReceive(transactionUrl, peer);\n        } else {\n            apiUtil.openConnectionForSend(transactionUrl, peer);\n        }\n    }\n\n    @Override\n    protected Response readTransactionResponse() throws IOException {\n        HttpCommunicationsSession commSession = (HttpCommunicationsSession) peer.getCommunicationsSession();\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        DataOutputStream dos = new DataOutputStream(bos);\n        if(TransferDirection.RECEIVE.equals(direction)){\n            switch (state){\n                case TRANSACTION_STARTED:\n                case DATA_EXCHANGED:\n                    logger.debug(\"{} {} readTransactionResponse. checksum={}\", this, peer, commSession.getChecksum());\n                    if(StringUtils.isEmpty(commSession.getChecksum())){\n                        // We don't know if there's more data to receive, so just continue it.\n                        ResponseCode.CONTINUE_TRANSACTION.writeResponse(dos);\n                    } else {\n                        // We got a checksum to send to server.\n                        if (TransactionState.TRANSACTION_STARTED.equals(state)) {\n                            logger.debug(\"{} {} There's no transaction to confirm.\", this, peer);\n                            ResponseCode.CONFIRM_TRANSACTION.writeResponse(dos, \"\");\n                        } else {\n                            TransactionResultEntity transactionResult\n                                    = apiClient.commitReceivingFlowFiles(transactionUrl, ResponseCode.CONFIRM_TRANSACTION, commSession.getChecksum());\n                            ResponseCode responseCode = ResponseCode.fromCode(transactionResult.getResponseCode());\n                            if(responseCode.containsMessage()){\n                                String message = transactionResult.getMessage();\n                                responseCode.writeResponse(dos, message == null ? \"\" : message);\n                            } else {\n                                responseCode.writeResponse(dos);\n                            }\n                        }\n                    }\n                    break;\n            }\n        } else {\n            switch (state){\n                case DATA_EXCHANGED:\n                    // Some flow files have been sent via stream, finish transferring.\n                    apiClient.finishTransferFlowFiles(commSession);\n                    ResponseCode.CONFIRM_TRANSACTION.writeResponse(dos, commSession.getChecksum());\n                    break;\n                case TRANSACTION_CONFIRMED:\n                    TransactionResultEntity resultEntity = apiClient.commitTransferFlowFiles(transactionUrl, ResponseCode.CONFIRM_TRANSACTION);\n                    ResponseCode responseCode = ResponseCode.fromCode(resultEntity.getResponseCode());\n                    if(responseCode.containsMessage()){\n                        responseCode.writeResponse(dos, resultEntity.getMessage());\n                    } else {\n                        responseCode.writeResponse(dos);\n                    }\n                    break;\n            }\n        }\n        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());\n        return Response.read(new DataInputStream(bis));\n    }\n\n<fim_suffix>    @Override\n    protected void writeTransactionResponse(ResponseCode response, String explanation) throws IOException {\n        HttpCommunicationsSession commSession = (HttpCommunicationsSession) peer.getCommunicationsSession();\n        if(TransferDirection.RECEIVE.equals(direction)){\n            switch (response) {\n                case CONFIRM_TRANSACTION:\n                    logger.debug(\"{} Confirming transaction. checksum={}\", this, explanation);\n                    commSession.setChecksum(explanation);\n                    break;\n                case TRANSACTION_FINISHED:\n                    logger.debug(\"{} Finishing transaction.\", this);\n                    break;\n                case CANCEL_TRANSACTION:\n                    logger.debug(\"{} Canceling transaction. explanation={}\", this, explanation);\n                    TransactionResultEntity resultEntity = apiClient.commitReceivingFlowFiles(transactionUrl, ResponseCode.CANCEL_TRANSACTION, null);\n                    ResponseCode cancelResponse = ResponseCode.fromCode(resultEntity.getResponseCode());\n                    switch (cancelResponse) {\n                        case CANCEL_TRANSACTION:\n                            logger.debug(\"{} CANCEL_TRANSACTION, The transaction is canceled on server properly.\", this);\n                            break;\n                        default:\n                            logger.warn(\"{} CANCEL_TRANSACTION, Expected the transaction is canceled on server, but received {}.\", this, cancelResponse);\n                            break;\n                    }\n                    break;\n            }\n        } else {\n            switch (response) {\n                case FINISH_TRANSACTION:\n                    // The actual HTTP request will be sent in readTransactionResponse.\n                    logger.debug(\"{} Finished sending flow files.\", this);\n                    break;\n                case BAD_CHECKSUM: {\n                        TransactionResultEntity resultEntity = apiClient.commitTransferFlowFiles(transactionUrl, ResponseCode.BAD_CHECKSUM);\n                        ResponseCode badChecksumCancelResponse = ResponseCode.fromCode(resultEntity.getResponseCode());\n                        switch (badChecksumCancelResponse) {\n                            case CANCEL_TRANSACTION:\n                                logger.debug(\"{} BAD_CHECKSUM, The transaction is canceled on server properly.\", this);\n                                break;\n                            default:\n                                logger.warn(\"{} BAD_CHECKSUM, Expected the transaction is canceled on server, but received {}.\", this, badChecksumCancelResponse);\n                                break;\n                        }\n\n                    }\n                    break;\n                case CONFIRM_TRANSACTION:\n                    // The actual HTTP request will be sent in readTransactionResponse.\n                    logger.debug(\"{} Transaction is confirmed.\", this);\n                    break;\n                case CANCEL_TRANSACTION: {\n                        logger.debug(\"{} Canceling transaction.\", this);\n                        TransactionResultEntity resultEntity = apiClient.commitTransferFlowFiles(transactionUrl, ResponseCode.CANCEL_TRANSACTION);\n                        ResponseCode cancelResponse = ResponseCode.fromCode(resultEntity.getResponseCode());\n                        switch (cancelResponse) {\n                            case CANCEL_TRANSACTION:\n                                logger.debug(\"{} CANCEL_TRANSACTION, The transaction is canceled on server properly.\", this);\n                                break;\n                            default:\n                                logger.warn(\"{} CANCEL_TRANSACTION, Expected the transaction is canceled on server, but received {}.\", this, cancelResponse);\n                                break;\n                        }\n                    }\n                    break;\n            }\n        }\n    }\n\n\n    @Override\n    protected void close() throws IOException {\n        if (apiClient != null) {\n            apiClient.close();\n        }\n    }\n}\n<fim_middle>// function below is long method\n"}