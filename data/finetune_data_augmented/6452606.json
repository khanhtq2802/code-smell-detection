{"text": "<fim_prefix>\t\tthis.readerCache = new CachedReader(stream, parentImage);\n\t\tthis.stream = stream;\n\t\tthis.file = null;\n\t}\n\tPHDJavaHeap(File file, final PHDImage parentImage, ImageAddressSpace space, PHDJavaRuntime runtime) throws IOException {\n\t\tthis.file = file;\n\t\tthis.image = parentImage;\n\t\tthis.space = space;\n\t\tthis.runtime = runtime;\n\t\tHeapdumpReader reader = new HeapdumpReader(file, parentImage);\n\t\tthis.isJ9V4 = reader.version() == 4 && reader.isJ9();\n\t\treader.close();\n\t\tthis.readerCache = new CachedReader(file, parentImage);\n\t\tthis.stream = null;\n\t}\n\tpublic String getName() {\n\t\treturn \"Java heap\";\n\t}\n\t/**\n\t * Return all the objects in the heap\n\t * Accumulate the objects in several chunks so that not everything has to be active at once\n\t * Iterate over each chunk\n\t */\n\tprivate Iterator<JavaObject> getObjects0() {\n\t\ttry {\n\t\t\treturn new Iterator<JavaObject>() {\n\t\t\t\tint count[] = new int[1];\n\t\t\t\tint prev;\n\t\t\t\t// Initial chunk\n\t\t\t\tIterator<JavaObject> it = getObjectsViaCache(STEP, count, false).values().iterator();\n\t\t\t\tpublic boolean hasNext() {\n\t\t\t\t\tif (it == null) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t} else if (it.hasNext()) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// When we processed the previous chunk did the end user require references from the JavaObjects?\n\t\t\t\t\t\t// If so, then get the references for this chunk\n\t\t\t\t\t\tboolean withRefs = withRefs(prev);\n\t\t\t\t\t\tprev = count[0];\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tit = getObjectsViaCache(STEP, count, withRefs).values().iterator();\n\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (it.hasNext()) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tit = null;\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpublic JavaObject next() {\n\t\t\t\t\tif (!hasNext()) throw new NoSuchElementException(); \n\t\t\t\t\treturn it.next();\n\t\t\t\t}\n\t\t\t\tpublic void remove() {\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\t\t\t};\n\t\t} catch (IOException e) {\n\t\t\treturn new ArrayList<JavaObject>().iterator();\n\t\t}\n\t}\n\t/**\n\t * Used to index objects from addresses.\n\t * Subclasses of this can be a bit smaller than a Long - perhaps 16 bytes, not 24.\n\t *\n\t */\n\tstatic abstract class AddressKey {\n\t\tabstract long value(PHDJavaHeap jh);\n\t\t/**\n\t\t * Factory to create an AddressKey\n\t\t * @param jh The PHDJavaHeap\n\t\t * @param addr The address to compress\n\t\t * @return\n\t\t */\n\t\tstatic AddressKey getAddress(PHDJavaHeap jh, long addr)\n\t\t{\n\t\t\t// It is not safe to not compress on creating of HashMap entry key,\n\t\t\t// but to compress on retrieval as then the key is different and will not match\n\t\t\tif (jh.runtime.noCompress())\n\t\t\t\tthrow new IllegalStateException(\"Unable to compress addresses\");\n\t\t\tint iv = jh.runtime.compressAddress(addr);\n\t\t\tlong addr2 = jh.runtime.expandAddress(iv);\n\t\t\tif (addr == addr2)\n\t\t\t\treturn new IntAddressKey(iv);\n\t\t\telse\n\t\t\t\treturn new LongAddressKey(addr);\n\t\t}\n\t}\n\tprivate final static class IntAddressKey extends AddressKey {\n\t\tfinal int val;\n\t\tprivate IntAddressKey(int v) {\n\t\t\tval = v;\n\t\t}\n\t\tlong value(PHDJavaHeap jh) {\n\t\t\treturn jh.runtime.expandAddress(val);\n\t\t}\n\t\tpublic int hashCode() {\n\t\t\treturn val;\n\t\t}\n\t\tpublic boolean equals(Object o) {\n\t\t\tif (this == o) return true;\n\t\t\treturn o instanceof IntAddressKey && val == ((IntAddressKey)o).val ;\n\t\t}\n\t}\t\n\tprivate final static class LongAddressKey extends AddressKey {\n\t\tfinal long val;\n\t\tprivate LongAddressKey(long v) {\n\t\t\tval = v;\n\t\t}\n\t\tlong value(PHDJavaHeap jh) {\n\t\t\treturn val;\n\t\t}\n\t\tpublic int hashCode() {\n\t\t\treturn (int)val^(int)(val>>>32);\n\t\t}\n\t\tpublic boolean equals(Object o) {\n\t\t\tif (this == o) return true;\n\t\t\treturn o instanceof LongAddressKey && val == ((LongAddressKey)o).val;\n\t\t}\n\t}\t\n\t/**\n\t * Used to store all objects from part of the heap.\n\t * The actual objects can be discarded if we run out of memory, but the range and details remain\n\t * so that if we want an object from this segment we can decide to refetch just this segment details,\n\t * rather than searching the entire heap.\n\t * We can also selectively build objects with or without all outbound references.\n\t */\n\tstatic class CacheHeapSegment {\n\t\t/** The number in the heap of the first object in the chunk */\n\t\tfinal int index;\n\t\t/** How many references were accumulated in this chunk. Use the same number when rereading the chunk. */\n\t\tfinal int maxSize;\n\t\t/** The number in the heap of the next object after the objects in the chunk. Used to find the next chunk */\n\t\tfinal int nextIndex;\n\t\t/** The actual JavaObjects, held via a SoftReference to avoid OutOfMemoryErrors */\n\t\tSoftReference<Map<AddressKey,JavaObject>> objects;\n\t\t/** Whether the JavaObjects have references available */\n\t\tboolean withRefs;\n\t\t/** Smallest address - used to find if a JavaObject at a particular address might be in this chunk. */ \n\t\tfinal long minAddress;\n\t\t/** Largest address - used to find if a JavaObject at a particular address might be in this chunk. */\n\t\tfinal long maxAddress;\n\t\t/**\n\t\t * Construct the metadeta for a chunk.\n\t\t * @param index\n\t\t * @param size\n\t\t * @param nextIndex\n\t\t * @param objs\n\t\t * @param withRefs\n\t\t */\n\t\tCacheHeapSegment(int index, int size, int nextIndex, Map<AddressKey,JavaObject> objs, boolean withRefs) {\n\t\t\tobjects = new SoftReference<Map<AddressKey,JavaObject>>(objs);\n\t\t\t// Find the maximum and minimum addresses\n\t\t\tlong max = Long.MIN_VALUE;\n\t\t\tlong min = Long.MAX_VALUE;\n\t\t\tfor (JavaObject jo : objs.values()) {\n\t\t\t\tif (jo instanceof CorruptData) continue;\n\t\t\t\tlong addr = jo.getID().getAddress();\n\t\t\t\tmax = Math.max(max, addr);\n\t\t\t\tmin = Math.min(min, addr);\n\t\t\t}\n\t\t\tthis.index = index;\n\t\t\tthis.maxSize = size;\n\t\t\tthis.nextIndex = nextIndex;\n\t\t\tthis.maxAddress = max;\n\t\t\tthis.minAddress = min;\n\t\t\tthis.withRefs = withRefs;\n\t\t}\n\t}\n\t/**\n\t * Used to save PHD readers to continue reading from later on in the file\n\t *\n\t */\n<fim_suffix>\tstatic class CachedReader {\n\t\tFile file;\n\t\tImageInputStream stream;\n\t\tfinal PHDImage parentImage;\n\t\tclass ReaderPos {\n\t\t\tint where;\n\t\t\tHeapdumpReader reader;\n\t\t\tReaderPos(PHDImage parentImage) throws IOException {\n\t\t\t\tif(stream == null) {\n\t\t\t\t\treader = new HeapdumpReader(file, parentImage);\n\t\t\t\t} else {\n\t\t\t\t\treader = new HeapdumpReader(stream, parentImage);\n\t\t\t\t}\n\t\t\t\twhere = 0;\n\t\t\t}\n\t\t}\n\t\tList<ReaderPos> readers = new ArrayList<ReaderPos>();\n\t\tCachedReader(File f, PHDImage parentImage) {\n\t\t\tfile = f;\n\t\t\tthis.parentImage = parentImage;\n\t\t}\n\t\tCachedReader(ImageInputStream stream, PHDImage parentImage) {\n\t\t\tthis.stream = stream;\n\t\t\tthis.parentImage = parentImage;\n\t\t}\n\t\tReaderPos getReader(int n) throws IOException {\n\t\t\tReaderPos best = null;\n\t\t\tfor (ReaderPos rp : readers) {\n\t\t\t\tif (rp.where <= n && (best == null || best.where < rp.where)) {\n\t\t\t\t\tbest =rp;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (best == null) {\t\n\t\t\t\tbest = new ReaderPos(parentImage);\n\t\t\t} else {\n\t\t\t\treaders.remove(best);\n\t\t\t}\n\t\t\treturn best;\n\t\t}\n\t\tvoid returnReader(ReaderPos rdr) {\n\t\t\treaders.add(rdr);\n\t\t}\n\t}<fim_middle>// class below has no smell\n"}