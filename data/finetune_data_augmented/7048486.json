{"text": "<fim_prefix>    }\n    // The iterator for replicas from [targetSize (inclusive), maxSize (exclusive)]\n    Iterator<ReplicaWrapper> ascendingLargerIter = null;\n    // The iterator for replicas from [minSize (exclusive), targetSize (inclusive)]\n    Iterator<ReplicaWrapper> descendingLessIter = null;\n    // Check if the target size falls in the range or not. This is needed to avoid passing invalid targetSize to\n    // the tailSet() or headSet().\n    if (targetSize <= minSize) {\n      ascendingLargerIter = candidates.iterator();\n    } else if (targetSize >= maxSize) {\n      descendingLessIter = candidates.descendingIterator();\n    } else {\n      ascendingLargerIter = candidates.tailSet(ReplicaWrapper.greaterThanOrEqualsTo(targetSize), true).iterator();\n      descendingLessIter = candidates.headSet(ReplicaWrapper.lessThanOrEqualsTo(targetSize), true).descendingIterator();\n    }\n    // Advance the ascending and descending iterator in the ascending order of their distance from target size,\n    // return the first replica that can swap. Otherwise return null.\n    ReplicaWrapper low = null;\n    ReplicaWrapper high = null;\n    ReplicaWrapper candidateReplica = null;\n    while (true) {\n      // The last checked replica is from the high end, advance the ascending iterator.\n      if (candidateReplica == high) {\n        high = ascendingLargerIter != null && ascendingLargerIter.hasNext() ? ascendingLargerIter.next() : null;\n      }\n      // The last checked replica is from the low end, advance the descending iterator.\n      if (candidateReplica == low) {\n        low = descendingLessIter != null && descendingLessIter.hasNext() ? descendingLessIter.next() : null;\n      }\n      // No more replicas to check, give up.\n      if (high == null && low == null) {\n        return null;\n      } else if (high == null) {\n        // Use the lower end\n        candidateReplica = low;\n      } else if (low == null) {\n        // Use the higher end\n        candidateReplica = high;\n      } else {\n        // pick a replica closer to the target.\n        double lowDiff = targetSize - low.size();\n        double highDiff = high.size() - targetSize;\n        candidateReplica = lowDiff <= highDiff ? low : high;\n      }\n      if (canSwap(replica, candidateReplica.replica(), clusterModel)) {\n        return candidateReplica.replica();\n      }\n    }\n  }\n  /**\n   * Checks if a replica is possible to be moved to a broker.\n   *\n   * A replica is possible to move to a broker if\n   * 1. the rack of the broker does not contain a replica of the same partition, OR\n   * 2. the rack of the broker contains the replica, but the replica is not in the given broker.\n   *\n   * @param replica the replica to move.\n   * @param destinationBroker the broker to move the replica to.\n   * @param clusterModel the cluster model.\n   *\n   * @return true if it is possible to move the replica to the broker, false otherwise.\n   */\n  private boolean possibleToMove(Replica replica, Broker destinationBroker, ClusterModel clusterModel) {\n    TopicPartition tp = replica.topicPartition();\n    boolean case1 = !clusterModel.partition(tp).partitionRacks().contains(destinationBroker.rack());\n    boolean case2 = replica.broker().rack() == destinationBroker.rack() && destinationBroker.replica(tp) == null;\n    return case1 || case2;\n  }\n  /**\n   * Checks whether the two replicas can swap with each other. Two replicas can swap if:\n   * 1. r1 and r2 are in the same rack (this assumes the initial assignment is already rack aware), OR\n   * 2. partition of r1 does not have replica in the rack of r2, and vice versa\n   *\n   * In addition, r1 and r2 must have the same role, i.e. either both are leaders or both are followers.\n   * @param r1 the first replica to swap\n   * @param r2 the second replica to swap with the first replica\n   * @param clusterModel the cluster model\n   * @return true if the two replicas can be swapped, false otherwise.\n   */\n  boolean canSwap(Replica r1, Replica r2, ClusterModel clusterModel) {\n    boolean inSameRack = r1.broker().rack() == r2.broker().rack() && r1.broker() != r2.broker();\n    boolean rackAware = !clusterModel.partition(r1.topicPartition()).partitionRacks().contains(r2.broker().rack())\n        && !clusterModel.partition(r2.topicPartition()).partitionRacks().contains(r1.broker().rack());\n    boolean sameRole = r1.isLeader() == r2.isLeader();\n    return (inSameRack || rackAware) && sameRole;\n  }\n  private NavigableSet<ReplicaWrapper> sortReplicasAscend(BrokerAndSortedReplicas bas, Set<String> excludedTopics) {\n    NavigableSet<ReplicaWrapper> sortedReplicas = new TreeSet<>();\n    bas.sortedReplicas().forEach(r -> {\n      if (!excludedTopics.contains(r.topicPartition().topic())) {\n        sortedReplicas.add(new ReplicaWrapper(r, replicaSize(r)));\n      }\n    });\n    return sortedReplicas;\n  }\n  private NavigableSet<ReplicaWrapper> sortedFollowerReplicas(BrokerAndSortedReplicas bas, Set<String> excludedTopics) {\n    NavigableSet<ReplicaWrapper> sortedFollowers = new TreeSet<>();\n    bas.sortedReplicas().forEach(r -> {\n      if (!r.isLeader() || excludedTopics.contains(r.topicPartition().topic())) {\n        sortedFollowers.add(new ReplicaWrapper(r, replicaSize(r)));\n      }\n    });\n    return sortedFollowers;\n  }\n  @Override\n  public ActionAcceptance actionAcceptance(BalancingAction action, ClusterModel clusterModel) {\n    throw new IllegalStateException(\"No goal should be executed after \" + name());\n  }\n  @Override\n  public String name() {\n    return KafkaAssignerDiskUsageDistributionGoal.class.getSimpleName();\n  }\n  private double diskUsage(BrokerAndSortedReplicas bas) {\n    // Ensure that if the disk capacity is non-positive, we do not report a positive disk usage.\n    double diskCapacity = bas.broker().capacityFor(DISK);\n    return Double.compare(diskCapacity, 0.0) < 1 ? 0.0 : bas.broker().load().expectedUtilizationFor(DISK) / diskCapacity;\n  }\n  private double diskUsage(Broker broker) {\n    // Ensure that if the disk capacity is non-positive, we do not report a positive disk usage.\n    double diskCapacity = broker.capacityFor(DISK);\n    return Double.compare(diskCapacity, 0.0) < 1 ? 0.0 : broker.load().expectedUtilizationFor(DISK) / diskCapacity;\n  }\n  private double replicaSize(Replica replica) {\n    return replica.load().expectedUtilizationFor(DISK);\n  }\n  private double brokerSize(BrokerAndSortedReplicas bas) {\n    return diskUsage(bas) * bas.broker().capacityFor(DISK);\n  }\n  /**\n   * To avoid churns, we add a balance margin to the user specified rebalance threshold. e.g. when user sets the\n   * threshold to be resourceBalancePercentage, we use (resourceBalancePercentage-1)*balanceMargin instead.\n   * @return the rebalance threshold with a margin.\n   */\n  private double balancePercentageWithMargin() {\n    return (_balancingConstraint.resourceBalancePercentage(DISK) - 1) * BALANCE_MARGIN;\n  }\n  private DoubleWrapper dWrap(double value) {\n    return new DoubleWrapper(value);\n  }\n  /**\n   * This is the same comparator code as the one in\n   * {@link com.linkedin.kafka.cruisecontrol.analyzer.goals.ResourceDistributionGoal}\n   */\n<fim_suffix>  private class DiskDistributionGoalStatsComparator implements ClusterModelStatsComparator {\n    private String _reasonForLastNegativeResult;\n    @Override\n    public int compare(ClusterModelStats stats1, ClusterModelStats stats2) {\n      // Number of balanced brokers in the highest priority resource cannot be more than the pre-optimized\n      // stats. This constraint is applicable for the rest of the resources, if their higher priority resources\n      // have the same number of balanced brokers in their corresponding pre- and post-optimized stats.\n      int numBalancedBroker1 = stats1.numBalancedBrokersByResource().get(DISK);\n      int numBalancedBroker2 = stats2.numBalancedBrokersByResource().get(DISK);\n      // First compare the\n      if (numBalancedBroker2 > numBalancedBroker1) {\n        _reasonForLastNegativeResult = String.format(\n            \"Violated %s. [Number of Balanced Brokers] for resource %s. post-optimization:%d pre-optimization:%d\",\n            name(), DISK, numBalancedBroker1, numBalancedBroker2);\n        return -1;\n      }\n      return 1;\n    }\n    @Override\n    public String explainLastComparison() {\n      return _reasonForLastNegativeResult;\n    }\n  }<fim_middle>// class below has no smell\n"}