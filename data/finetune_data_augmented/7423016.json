{"text": "<fim_prefix>        final Set<AccessMode> modesSet = EnumSet.noneOf(AccessMode.class);\n        Collections.addAll(modesSet, modes);\n        return checkAccess(modesSet);\n    }\n    private boolean checkAccess(Set<? extends AccessMode> modes, LinkOption... linkOptions) {\n        try {\n            fileSystemContext.fileSystem.checkAccess(normalizedPath, modes, linkOptions);\n            return true;\n        } catch (IOException ioe) {\n            return false;\n        }\n    }\n    private <T> T getAttributeImpl(String attribute, Class<T> type, LinkOption... options) throws IOException {\n        return getAttributeImpl(normalizedPath, attribute, type, options);\n    }\n    private <T> T getAttributeImpl(Path forPath, String attribute, Class<T> type, LinkOption... options) throws IOException {\n        final Object value = getAttributeImpl(forPath, attribute, options);\n        return value == null ? null : type.cast(value);\n    }\n    private Object getAttributeImpl(final Path forPath, final String attribute, final LinkOption... options) throws IOException {\n        final Map<String, Object> map = fileSystemContext.fileSystem.readAttributes(forPath, attribute, options);\n        final int index = attribute.indexOf(':');\n        final String key = index < 0 ? attribute : attribute.substring(index + 1);\n        return map.get(key);\n    }\n    private Path createDirectoryImpl(Path dir, FileAttribute<?>... attrs) throws IOException {\n        fileSystemContext.fileSystem.createDirectory(dir, attrs);\n        return dir;\n    }\n    private Path createDirAndCheck(Path dir, FileAttribute<?>... attrs) throws IOException {\n        try {\n            return createDirectoryImpl(dir, attrs);\n        } catch (FileAlreadyExistsException faee) {\n            try {\n                if (getAttributeImpl(dir, \"isDirectory\", Boolean.class, LinkOption.NOFOLLOW_LINKS)) {\n                    return dir;\n                } else {\n                    throw faee;\n                }\n            } catch (IOException ioe) {\n                throw faee;\n            }\n        }\n    }\n    private Path findExisting(Path forPath) throws IOException {\n        final Set<AccessMode> mode = EnumSet.noneOf(AccessMode.class);\n        for (Path p = forPath.getParent(); p != null; p = p.getParent()) {\n            try {\n                fileSystemContext.fileSystem.checkAccess(p, mode);\n                return p;\n            } catch (NoSuchFileException nsfe) {\n                // Still does not exist\n            }\n        }\n        return null;\n    }\n    private <T extends Throwable> RuntimeException wrapHostException(T t) {\n        throw wrapHostException(t, fileSystemContext.fileSystem);\n    }\n    static <T extends Throwable> RuntimeException wrapHostException(T t, FileSystem fs) {\n        if (TruffleLanguage.AccessAPI.engineAccess().isDefaultFileSystem(fs)) {\n            throw sthrow(t);\n        }\n        throw TruffleLanguage.AccessAPI.engineAccess().wrapHostException(null, TruffleLanguage.AccessAPI.engineAccess().getCurrentHostContext(), t);\n    }\n    @SuppressWarnings(\"unchecked\")\n    private static <T extends RuntimeException> T sthrow(final Throwable t) throws T {\n        throw (T) t;\n    }\n    private static final class AllFiles implements DirectoryStream.Filter<Path> {\n        static final DirectoryStream.Filter<Path> INSTANCE = new AllFiles();\n        private AllFiles() {\n        }\n        @Override\n        public boolean accept(Path entry) throws IOException {\n            return true;\n        }\n    }\n    private static final class ByteChannelDecorator implements SeekableByteChannel {\n        private final SeekableByteChannel delegate;\n        ByteChannelDecorator(final SeekableByteChannel delegate) {\n            this.delegate = delegate;\n        }\n        @Override\n        public int read(ByteBuffer dst) throws IOException {\n            return delegate.read(dst);\n        }\n        @Override\n        public int write(ByteBuffer src) throws IOException {\n            return delegate.write(src);\n        }\n        @Override\n        public boolean isOpen() {\n            return delegate.isOpen();\n        }\n        @Override\n        public void close() throws IOException {\n            delegate.close();\n        }\n        @Override\n        public long position() throws IOException {\n            return delegate.position();\n        }\n        @Override\n        public SeekableByteChannel position(long newPosition) throws IOException {\n            delegate.position(newPosition);\n            return this;\n        }\n        @Override\n        public long size() throws IOException {\n            return delegate.size();\n        }\n        @Override\n        public SeekableByteChannel truncate(long size) throws IOException {\n            delegate.truncate(size);\n            return this;\n        }\n        static SeekableByteChannel create(final SeekableByteChannel delegate) {\n            Objects.requireNonNull(delegate, \"Delegate must be non null.\");\n            return new ByteChannelDecorator(delegate);\n        }\n    }\n    private static final class TruffleFileDirectoryStream implements DirectoryStream<TruffleFile> {\n        private final TruffleFile directory;\n        private final DirectoryStream<Path> delegate;\n        TruffleFileDirectoryStream(TruffleFile directory, DirectoryStream<Path> delegate) {\n            this.directory = directory;\n            this.delegate = delegate;\n        }\n        @Override\n        public Iterator<TruffleFile> iterator() {\n            try {\n                final Iterator<Path> delegateIterator = delegate.iterator();\n                final boolean normalized = directory.isNormalized();\n                return new IteratorImpl(directory, delegateIterator, normalized);\n            } catch (Throwable t) {\n                throw directory.wrapHostException(t);\n            }\n        }\n        @Override\n        public void close() throws IOException {\n            try {\n                this.delegate.close();\n            } catch (IOException e) {\n                throw e;\n            } catch (Throwable t) {\n                throw directory.wrapHostException(t);\n            }\n        }\n        private static final class IteratorImpl implements Iterator<TruffleFile> {\n            private final TruffleFile directory;\n            private final Iterator<? extends Path> delegateIterator;\n            private final boolean normalized;\n            IteratorImpl(TruffleFile directory, Iterator<? extends Path> delegateIterator, boolean normalized) {\n                this.directory = directory;\n                this.delegateIterator = delegateIterator;\n                this.normalized = normalized;\n            }\n            @Override\n            public boolean hasNext() {\n                try {\n                    return delegateIterator.hasNext();\n                } catch (Throwable t) {\n                    throw directory.wrapHostException(t);\n                }\n            }\n            @Override\n            public TruffleFile next() {\n                try {\n                    Path path = delegateIterator.next();\n                    return new TruffleFile(\n                                    directory.fileSystemContext,\n                                    normalized ? path : directory.path.resolve(path.getFileName()),\n                                    normalized ? path : directory.normalizedPath.resolve(path.getFileName()));\n                } catch (DirectoryIteratorException e) {\n                    throw e;\n                } catch (Throwable t) {\n                    throw directory.wrapHostException(t);\n                }\n            }\n        }\n    }\n    private static final class Walker implements Iterable<Walker.Event> {\n        private final TruffleFile start;\n        private final int maxDepth;\n        private final boolean followSymLinks;\n        private IteratorImpl currentIterator;\n        Walker(TruffleFile start, int maxDepth, FileVisitOption... options) {\n            this.start = start;\n            this.maxDepth = maxDepth;\n            boolean followSymLinksTmp = false;\n            for (FileVisitOption option : options) {\n                if (option == FileVisitOption.FOLLOW_LINKS) {\n                    followSymLinksTmp = true;\n                    break;\n                }\n            }\n            this.followSymLinks = followSymLinksTmp;\n        }\n        @Override\n        public Iterator<Event> iterator() {\n            if (currentIterator != null) {\n                throw new IllegalStateException(\"Multiple iterators are not allowed.\");\n            }\n            currentIterator = new IteratorImpl(start, maxDepth, followSymLinks);\n            return currentIterator;\n        }\n        void pop() {\n            if (!currentIterator.stack.isEmpty()) {\n                try {\n                    currentIterator.stack.removeLast().close();\n                } catch (IOException ignored) {\n                }\n            }\n        }\n        void skipRemainingSiblings() {\n            if (!currentIterator.stack.isEmpty()) {\n                currentIterator.stack.peekLast().setSkipped(true);\n            }\n        }\n<fim_suffix>        static class Event {\n            final Type type;\n            final TruffleFile file;\n            final IOException ioe;\n            final BasicFileAttributes attrs;\n            Event(Type type, TruffleFile file, BasicFileAttributes attrs) {\n                this.type = type;\n                this.file = file;\n                this.attrs = attrs;\n                this.ioe = null;\n            }\n            Event(Type type, TruffleFile file, IOException ioe) {\n                this.type = type;\n                this.file = file;\n                this.attrs = null;\n                this.ioe = ioe;\n            }\n            enum Type {\n                PRE_VISIT_DIRECTORY,\n                VISIT,\n                POST_VISIT_DIRECTORY\n            }\n        }<fim_middle>// class below is data class\n"}