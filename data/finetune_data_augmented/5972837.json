{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.openejb.util;\n\nimport org.apache.commons.lang3.text.StrLookup;\nimport org.apache.commons.lang3.text.StrSubstitutor;\nimport org.apache.openejb.cipher.PasswordCipher;\nimport org.apache.openejb.cipher.PasswordCipherException;\nimport org.apache.openejb.cipher.PasswordCipherFactory;\nimport org.apache.openejb.cipher.SafePasswordCipher;\nimport org.apache.openejb.loader.SystemInstance;\n\nimport java.util.Map;\nimport java.util.Properties;\n\npublic final class PropertyPlaceHolderHelper {\n    private static final String PREFIX = \"${\";\n    private static final String SUFFIX = \"}\";\n    private static final Properties CACHE = new Properties();\n\n    private static final PropertiesLookup RESOLVER = new PropertiesLookup();\n    public static final StrSubstitutor SUBSTITUTOR = new StrSubstitutor(RESOLVER);\n\n    static {\n        SUBSTITUTOR.setEnableSubstitutionInVariables(true);\n        SUBSTITUTOR.setValueDelimiter(JavaSecurityManagers.getSystemProperty(\"openejb.placehodler.delimiter\", \":-\")); // default one of [lang3]\n    }\n\n    public static final String CIPHER_PREFIX = \"cipher:\";\n\n    private PropertyPlaceHolderHelper() {\n        // no-op\n    }\n\n    public static void reset() {\n        CACHE.clear();\n        RESOLVER.reload();\n    }\n\n    public static String simpleValue(final String raw) {\n        if (raw == null) {\n            return null;\n        }\n        if (!raw.contains(PREFIX) || !raw.contains(SUFFIX)) {\n            return String.class.cast(decryptIfNeeded(raw.replace(PREFIX, \"\").replace(SUFFIX, \"\"), false));\n        }\n\n        String value = SUBSTITUTOR.replace(raw);\n        if (!value.equals(raw) && value.startsWith(\"java:\")) {\n            value = value.substring(5);\n        }\n        return String.class.cast(decryptIfNeeded(value.replace(PREFIX, \"\").replace(SUFFIX, \"\"), false));\n    }\n\n    public static Object simpleValueAsStringOrCharArray(final String raw) {\n        if (raw == null) {\n            return null;\n        }\n        if (!raw.contains(PREFIX) || !raw.contains(SUFFIX)) {\n            return decryptIfNeeded(raw.replace(PREFIX, \"\").replace(SUFFIX, \"\"), true);\n        }\n\n        String value = SUBSTITUTOR.replace(raw);\n        if (!value.equals(raw) && value.startsWith(\"java:\")) {\n            value = value.substring(5);\n        }\n        return decryptIfNeeded(value.replace(PREFIX, \"\").replace(SUFFIX, \"\"), true);\n    }\n\n    private static Object decryptIfNeeded(final String replace, final boolean acceptCharArray) {\n        if (replace.startsWith(CIPHER_PREFIX)) {\n            final String algo = replace.substring(CIPHER_PREFIX.length(), replace.indexOf(':', CIPHER_PREFIX.length() + 1));\n            PasswordCipher cipher;\n            try {\n                cipher = PasswordCipherFactory.getPasswordCipher(algo);\n            } catch (final PasswordCipherException ex) {\n                try {\n                    cipher = PasswordCipher.class.cast(Thread.currentThread().getContextClassLoader().loadClass(algo).newInstance());\n                } catch (final Exception e) {\n                    throw new IllegalArgumentException(e);\n                }\n            }\n\n            final char[] input = replace.substring(CIPHER_PREFIX.length() + algo.length() + 1).toCharArray();\n            return acceptCharArray && SafePasswordCipher.class.isInstance(cipher) ?\n                SafePasswordCipher.class.cast(cipher).decryptAsCharArray(input) :\n                cipher.decrypt(input);\n        }\n        return replace;\n    }\n\n    public static String value(final String aw) {\n        if (aw == null) {\n            return null;\n        }\n        if (!aw.contains(PREFIX) || !aw.contains(SUFFIX)) {\n            return String.class.cast(decryptIfNeeded(aw, false));\n        }\n\n        String value = CACHE.getProperty(aw);\n        if (value != null) {\n            return value;\n        }\n\n        value = simpleValue(aw);\n        CACHE.setProperty(aw, value);\n        return value;\n    }\n\n    public static Properties simpleHolds(final Properties properties) {\n        return holds(properties, false);\n    }\n\n    public static Properties holds(final Properties properties) {\n        return holds(properties, true);\n    }\n\n    private static Properties holds(final Properties properties, final boolean cache) {\n        // we can put null values in SuperProperties, since properties is often of this type we need to tolerate it\n        final Properties updated = new SuperProperties();\n        if (properties == null) {\n            return updated;\n        }\n\n        for (final Map.Entry<Object, Object> entry : properties.entrySet()) {\n            final Object rawValue = entry.getValue();\n            if (rawValue instanceof String) {\n                final String value = (String) rawValue;\n                updated.put(entry.getKey(), cache ? value(value) : simpleValueAsStringOrCharArray(value));\n            } else {\n                updated.put(entry.getKey(), rawValue);\n            }\n        }\n        return updated;\n    }\n\n    public static void holdsWithUpdate(final Properties props) {\n        final Properties toUpdate = holds(props);\n        props.putAll(toUpdate);\n    }\n\n<fim_suffix>    private static class PropertiesLookup extends StrLookup<Object> {\n        private static final Map<String, String> ENV = System.getenv();\n\n        @Override\n        public synchronized String lookup(final String key) {\n            String value = SystemInstance.get().getProperties().getProperty(key);\n            if (value != null) {\n                return value;\n            }\n\n            value = ENV.get(key);\n            if (value != null) {\n                return value;\n            }\n\n            return null;\n        }\n\n        public synchronized void reload() {\n            //no-op\n        }\n    }\n}<fim_middle>// class below has no smell\n"}