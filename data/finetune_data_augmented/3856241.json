{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.accumulo.core.security;\n\nimport java.util.ArrayList;\n\nimport org.apache.accumulo.core.data.ArrayByteSequence;\nimport org.apache.accumulo.core.data.ByteSequence;\nimport org.apache.accumulo.core.security.ColumnVisibility.Node;\n\n/**\n * A class which evaluates visibility expressions against a set of authorizations.\n */\n<fim_suffix>public class VisibilityEvaluator {\n  private AuthorizationContainer auths;\n\n  /**\n   * Authorizations in column visibility expression are in escaped form. Column visibility parsing\n   * does not unescape. This class wraps an AuthorizationContainer and unescapes auths before\n   * checking the wrapped container.\n   */\n  private static class UnescapingAuthorizationContainer implements AuthorizationContainer {\n\n    private AuthorizationContainer wrapped;\n\n    UnescapingAuthorizationContainer(AuthorizationContainer wrapee) {\n      this.wrapped = wrapee;\n    }\n\n    @Override\n    public boolean contains(ByteSequence auth) {\n      return wrapped.contains(unescape(auth));\n    }\n  }\n\n  static ByteSequence unescape(ByteSequence auth) {\n    int escapeCharCount = 0;\n    for (int i = 0; i < auth.length(); i++) {\n      byte b = auth.byteAt(i);\n      if (b == '\"' || b == '\\\\') {\n        escapeCharCount++;\n      }\n    }\n\n    if (escapeCharCount > 0) {\n      if (escapeCharCount % 2 == 1) {\n        throw new IllegalArgumentException(\"Illegal escape sequence in auth : \" + auth);\n      }\n\n      byte[] unescapedCopy = new byte[auth.length() - escapeCharCount / 2];\n      int pos = 0;\n      for (int i = 0; i < auth.length(); i++) {\n        byte b = auth.byteAt(i);\n        if (b == '\\\\') {\n          i++;\n          b = auth.byteAt(i);\n          if (b != '\"' && b != '\\\\') {\n            throw new IllegalArgumentException(\"Illegal escape sequence in auth : \" + auth);\n          }\n        } else if (b == '\"') {\n          // should only see quote after a slash\n          throw new IllegalArgumentException(\"Illegal escape sequence in auth : \" + auth);\n        }\n\n        unescapedCopy[pos++] = b;\n      }\n\n      return new ArrayByteSequence(unescapedCopy);\n    } else {\n      return auth;\n    }\n  }\n\n  /**\n   * Creates a new {@link Authorizations} object with escaped forms of the authorizations in the\n   * given object.\n   *\n   * @param auths\n   *          original authorizations\n   * @return authorizations object with escaped authorization strings\n   * @see #escape(byte[], boolean)\n   */\n  static Authorizations escape(Authorizations auths) {\n    ArrayList<byte[]> retAuths = new ArrayList<>(auths.getAuthorizations().size());\n\n    for (byte[] auth : auths.getAuthorizations())\n      retAuths.add(escape(auth, false));\n\n    return new Authorizations(retAuths);\n  }\n\n  /**\n   * Properly escapes an authorization string. The string can be quoted if desired.\n   *\n   * @param auth\n   *          authorization string, as UTF-8 encoded bytes\n   * @param quote\n   *          true to wrap escaped authorization in quotes\n   * @return escaped authorization string\n   */\n  public static byte[] escape(byte[] auth, boolean quote) {\n    int escapeCount = 0;\n\n    for (int i = 0; i < auth.length; i++)\n      if (auth[i] == '\"' || auth[i] == '\\\\')\n        escapeCount++;\n\n    if (escapeCount > 0 || quote) {\n      byte[] escapedAuth = new byte[auth.length + escapeCount + (quote ? 2 : 0)];\n      int index = quote ? 1 : 0;\n      for (int i = 0; i < auth.length; i++) {\n        if (auth[i] == '\"' || auth[i] == '\\\\')\n          escapedAuth[index++] = '\\\\';\n        escapedAuth[index++] = auth[i];\n      }\n\n      if (quote) {\n        escapedAuth[0] = '\"';\n        escapedAuth[escapedAuth.length - 1] = '\"';\n      }\n\n      auth = escapedAuth;\n    }\n    return auth;\n  }\n\n  /**\n   * Creates a new evaluator for the authorizations found in the given container.\n   *\n   * @since 1.7.0\n   */\n  public VisibilityEvaluator(AuthorizationContainer authsContainer) {\n    this.auths = new UnescapingAuthorizationContainer(authsContainer);\n  }\n\n  /**\n   * Creates a new evaluator for the given collection of authorizations. Each authorization string\n   * is escaped before handling, and the original strings are unchanged.\n   *\n   * @param authorizations\n   *          authorizations object\n   */\n  public VisibilityEvaluator(Authorizations authorizations) {\n    this.auths = escape(authorizations);\n  }\n\n  /**\n   * Evaluates the given column visibility against the authorizations provided to this evaluator. A\n   * visibility passes evaluation if all authorizations in it are contained in those known to the\n   * evaluator, and all AND and OR subexpressions have at least two children.\n   *\n   * @param visibility\n   *          column visibility to evaluate\n   * @return true if visibility passes evaluation\n   * @throws VisibilityParseException\n   *           if an AND or OR subexpression has less than two children, or a subexpression is of an\n   *           unknown type\n   */\n  public boolean evaluate(ColumnVisibility visibility) throws VisibilityParseException {\n    // The VisibilityEvaluator computes a trie from the given Authorizations, that ColumnVisibility\n    // expressions can be evaluated against.\n    return evaluate(visibility.getExpression(), visibility.getParseTree());\n  }\n\n  private final boolean evaluate(final byte[] expression, final Node root)\n      throws VisibilityParseException {\n    if (expression.length == 0)\n      return true;\n    switch (root.type) {\n      case TERM:\n        return auths.contains(root.getTerm(expression));\n      case AND:\n        if (root.children == null || root.children.size() < 2)\n          throw new VisibilityParseException(\"AND has less than 2 children\", expression,\n              root.start);\n        for (Node child : root.children) {\n          if (!evaluate(expression, child))\n            return false;\n        }\n        return true;\n      case OR:\n        if (root.children == null || root.children.size() < 2)\n          throw new VisibilityParseException(\"OR has less than 2 children\", expression, root.start);\n        for (Node child : root.children) {\n          if (evaluate(expression, child))\n            return true;\n        }\n        return false;\n      default:\n        throw new VisibilityParseException(\"No such node type\", expression, root.start);\n    }\n  }\n}<fim_middle>// class below has no smell\n"}