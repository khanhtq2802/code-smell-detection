{"text": "<fim_prefix>\t */\n\tpublic boolean performCancel( )\n\t{\n\t\tdisposeAll( );\n\t\treturn super.performCancel( );\n\t}\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.eclipse.birt.report.designer.ui.dialogs.properties.AbstractPropertyPage#performOk()\n\t */\n\tpublic boolean performOk( )\n\t{\n\t\tif ( !modelChanged )\n\t\t{\n\t\t\tdisposeAll( );\n\t\t\treturn super.performOk( );\n\t\t}\n\t\tif ( isValid( ) )\n\t\t{\n\t\t\trefreshPositions( );\n\t\t\tdisposeAll( );\n\t\t\treturn super.performOk( );\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdisposeAll( );\n\t\t\treturn false;\n\t\t}\n\t}\n\t/**\n\t * Check the alias names whether is valid. The invalid situation may be the\n\t * same name of alias or the same name between column name and alias name.\n\t *  \n\t */\n\tprivate boolean isValid( )\n\t{\n\t\tboolean validate = true;\n\t\tString newColumnNameOrAlias;\n\t\tif ( columnHints == null )\n\t\t{\n\t\t\tcolumnHints = ( (DataSetHandle) getContainer( ).getModel( ) ).getPropertyHandle( DataSetHandle.COLUMN_HINTS_PROP );\n\t\t}\n\t\tIterator iterator1 = columnHints.iterator( );\n\t\tfor ( int i = 0; iterator1.hasNext( ) && validate; i++ )\n\t\t{\n\t\t\tColumnHintHandle columnHint = (ColumnHintHandle) iterator1.next( );\n\t\t\tnewColumnNameOrAlias = columnHint.getAlias( );\n\t\t\tIterator iterator2 = columnHints.iterator( );\n\t\t\tif ( newColumnNameOrAlias != null\n\t\t\t\t\t&& newColumnNameOrAlias.length( ) > 0 )\n\t\t\t{\n\t\t\t\tfor ( int n = 0; iterator2.hasNext( ); n++ )\n\t\t\t\t{\n\t\t\t\t\tColumnHintHandle columnHint2 = (ColumnHintHandle) iterator2.next( );\n\t\t\t\t\tif ( i == n )\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif ( ( columnHint2.getColumnName( ) != null && columnHint2.getColumnName( )\n\t\t\t\t\t\t\t.equals( newColumnNameOrAlias ) )\n\t\t\t\t\t\t\t|| ( columnHint2.getAlias( ) != null && columnHint2.getAlias( )\n\t\t\t\t\t\t\t\t\t.equals( newColumnNameOrAlias ) ) )\n\t\t\t\t\t{\n\t\t\t\t\t\tvalidate = false;\n\t\t\t\t\t\tgetContainer( ).setMessage( Messages.getFormattedString( \"dataset.editor.error.columnOrAliasNameAlreadyUsed\", //$NON-NLS-1$\n\t\t\t\t\t\t\t\tnew Object[]{\n\t\t\t\t\t\t\t\tnewColumnNameOrAlias,\n\t\t\t\t\t\t\t\t\t\tn > i ? Integer.valueOf( i + 1 )\n\t\t\t\t\t\t\t\t\t\t\t\t: Integer.valueOf( n + 1 ),\n\t\t\t\t\t\t\t\t\t\tn > i ? Integer.valueOf( n + 1 )\n\t\t\t\t\t\t\t\t\t\t\t\t: Integer.valueOf( i + 1 )\n\t\t\t\t\t\t\t\t} ),\n\t\t\t\t\t\t\t\tIMessageProvider.ERROR );\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn validate;\n\t}\n\tprotected void updateMessage( )\n\t{\n\t\tif ( isValid( ) )\n\t\t\tgetContainer( ).setMessage( Messages.getString( \"dataset.editor.outputColumns\" ), //$NON-NLS-1$\n\t\t\t\t\tIMessageProvider.NONE );\n\t}\n\tprivate void disposeAll( )\n\t{\n\t\trsColumnMap = null;\n\t\tcolumnHintMap = null;\n\t\t( (DataSetHandle) getContainer( ).getModel( ) ).removeListener( this );\n\t}\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.eclipse.birt.report.designer.ui.dialogs.properties.AbstractDescriptionPropertyPage#getPageDescription()\n\t */\n\tpublic String getPageDescription( )\n\t{\n\t\treturn Messages.getString( \"OutputColumnDefnPage.description\" ); //$NON-NLS-1$\n\t}\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see org.eclipse.birt.report.designer.ui.dialogs.properties.AbstractPropertyPage#canLeave()\n\t */\n\tpublic boolean canLeave( )\n\t{\n\t\tif ( !this.modelChanged )\n\t\t\treturn true;\n\t\tif ( isValid( ) )\n\t\t{\n\t\t\trefreshPositions( );\n\t\t\treturn super.canLeave( );\n\t\t}\n\t\telse\n\t\t\treturn false;\n\t}\n\tprivate void refreshCachedMap( )\n\t{\n\t\tcolumnHintMap.clear( );\n\t\trsColumnMap.clear( );\n\t\tfor ( Iterator iterator = columnHints.iterator( ); iterator.hasNext( ); )\n\t\t{\n\t\t\tColumnHintHandle handle = (ColumnHintHandle) iterator.next( );\n\t\t\tcolumnHintMap.put( handle.getColumnName( ), handle.getStructure( ) );\n\t\t}\n\t\tIStructure toDelete = null;\n\t\tif ( rsColumns == null )\n\t\t\treturn;\n\t\tfor ( Iterator iterator = rsColumns.iterator( ); iterator.hasNext( ); )\n\t\t{\n\t\t\tResultSetColumnHandle handle = (ResultSetColumnHandle) iterator.next( );\n\t\t\tif ( columnHintMap.get( handle.getColumnName( ) ) == null )\n\t\t\t{\n\t\t\t\ttoDelete = handle.getStructure( );\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trsColumnMap.put( handle.getColumnName( ), handle.getStructure( ) );\n\t\t}\n\t\tif ( toDelete != null )\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\trsColumns.removeItem( toDelete );\n\t\t\t}\n\t\t\tcatch ( PropertyValueException e )\n\t\t\t{\n\t\t\t\tExceptionHandler.handle( e );\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * \n\t * \n\t */\n\tprivate void createCachedMap( )\n\t{\n\t\tif ( rsColumns == null )\n\t\t\treturn;\n\t\tfor ( Iterator iterator = rsColumns.iterator( ); iterator.hasNext( ); )\n\t\t{\n\t\t\tResultSetColumnHandle handle = (ResultSetColumnHandle) iterator.next( );\n\t\t\trsColumnMap.put( handle.getColumnName( ), handle.getStructure( ) );\n\t\t}\n\t\tfor ( Iterator iterator = columnHints.iterator( ); iterator.hasNext( ); )\n\t\t{\n\t\t\tColumnHintHandle handle = (ColumnHintHandle) iterator.next( );\n\t\t\tcolumnHintMap.put( handle.getColumnName( ), handle.getStructure( ) );\n\t\t}\n\t}\n\t/**\n\t * A class that contain one ResultSetColumnHandle and one ColumnHintHandle.\n\t * @author lzhu\n\t *\n\t */\n\tprivate static class ColumnHandles\n\t{\n\t\tprivate PropertyHandle rsColumnHandle;\n\t\tprivate PropertyHandle chHandle;\n\t\tprivate List colList = null;\n\t\tColumnHandles( PropertyHandle rsch, PropertyHandle chh )\n\t\t{\n\t\t\tthis.rsColumnHandle = rsch;\n\t\t\tthis.chHandle = chh;\n\t\t}\n\t\tpublic PropertyHandle getResultSetColumnHandle( )\n\t\t{\n\t\t\treturn this.rsColumnHandle;\n\t\t}\n\t\tpublic PropertyHandle getColumnHintHandle( )\n\t\t{\n\t\t\treturn this.chHandle;\n\t\t}\n\t\tpublic List getColumnDefn( )\n\t\t{\n\t\t\tcolList = new ArrayList( );\n\t\t\tIterator rsIter = this.rsColumnHandle.iterator( );\n\t\t\tIterator hintIter = this.chHandle.iterator( );\n\t\t\twhile( rsIter.hasNext( ) )\n\t\t\t{\n\t\t\t\tcolList.add( new ColumnDefn( (ResultSetColumnHandle) rsIter.next( ),\n\t\t\t\t\t\t(ColumnHintHandle) hintIter.next( ) ) );\n\t\t\t}\n\t\t\treturn colList;\n\t\t}\n\t\tpublic int size( )\n\t\t{\n\t\t\tif( colList== null )\n\t\t\t{\n\t\t\t\tgetColumnDefn( );\n\t\t\t}\n\t\t\treturn this.colList.size( );\t\n\t\t}\n\t}\n\t/**\n\t * The class which serves as input data of one single table item in column definition table.\n\t * @author lzhu\n\t *\n\t */\n\tprotected static class ColumnDefn\n\t{\n\t\tprivate ResultSetColumnHandle rsColumnHandle;\n\t\tprivate ColumnHintHandle columnHintHandle;\n\t\tprivate ResultSetColumn rsColumn;\n\t\tprivate ColumnHint columnHint;\n\t\tpublic ColumnDefn(){\n\t\t\trsColumn = new ResultSetColumn();\n\t\t\tcolumnHint = new ColumnHint();\n\t\t\t//default type is \"string\"\n\t\t\tthis.setDataType( DesignChoiceConstants.PARAM_TYPE_STRING );\n\t\t}\n<fim_suffix>\t\tpublic ColumnDefn( ResultSetColumnHandle rsHandle, ColumnHintHandle colHintHandle )\n\t\t{\n\t\t\tthis.rsColumnHandle = rsHandle;\n\t\t\tthis.columnHintHandle = colHintHandle;\n\t\t}<fim_middle>// function below has no smell\n"}