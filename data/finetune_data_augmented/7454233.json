{"text": "<fim_prefix>/*\n * Copyright (c) 2017, 2017, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage com.oracle.svm.core.option;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.EnumSet;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport org.graalvm.collections.EconomicSet;\nimport org.graalvm.collections.UnmodifiableEconomicMap;\nimport org.graalvm.compiler.api.replacements.Fold;\nimport org.graalvm.compiler.options.ModifiableOptionValues;\nimport org.graalvm.compiler.options.NestedBooleanOptionKey;\nimport org.graalvm.compiler.options.OptionDescriptor;\nimport org.graalvm.compiler.options.OptionKey;\nimport org.graalvm.compiler.options.OptionValues;\nimport org.graalvm.nativeimage.Feature;\nimport org.graalvm.nativeimage.ImageSingletons;\nimport org.graalvm.nativeimage.RuntimeOptions.OptionClass;\nimport org.graalvm.nativeimage.impl.RuntimeOptionsSupport;\nimport org.graalvm.options.OptionDescriptors;\nimport org.graalvm.options.OptionType;\nimport com.oracle.svm.core.annotate.AnnotateOriginal;\nimport com.oracle.svm.core.annotate.AutomaticFeature;\nimport com.oracle.svm.core.annotate.RestrictHeapAccess;\nimport com.oracle.svm.core.annotate.TargetClass;\nimport com.oracle.svm.core.util.VMError;\n/**\n * The singleton holder of runtime options.\n *\n * @see com.oracle.svm.core.option\n */\npublic class RuntimeOptionValues extends ModifiableOptionValues {\n    private EconomicSet<String> allOptionNames;\n    public RuntimeOptionValues(UnmodifiableEconomicMap<OptionKey<?>, Object> values, EconomicSet<String> allOptionNames) {\n        super(values);\n        this.allOptionNames = allOptionNames;\n    }\n    @Fold\n    public static RuntimeOptionValues singleton() {\n        return ImageSingletons.lookup(RuntimeOptionValues.class);\n    }\n    @Fold\n    public EconomicSet<String> getAllOptionNames() {\n        return allOptionNames;\n    }\n}\nclass RuntimeOptionsSupportImpl implements RuntimeOptionsSupport {\n    @Override\n    public void set(String optionName, Object value) {\n        if (setXOption(optionName)) {\n            return;\n        }\n        if (!RuntimeOptionValues.singleton().getAllOptionNames().contains(optionName)) {\n            throw new RuntimeException(\"Unknown option: \" + optionName);\n        }\n        Optional<OptionDescriptor> descriptor = RuntimeOptionParser.singleton().getDescriptor(optionName);\n        if (descriptor.isPresent()) {\n            OptionDescriptor desc = descriptor.get();\n            Class<?> valueType = value.getClass();\n            if (desc.getOptionValueType().isAssignableFrom(valueType)) {\n                RuntimeOptionValues.singleton().update(desc.getOptionKey(), value);\n            } else {\n                throw new RuntimeException(\"Invalid type of option '\" + optionName + \"': required \" + desc.getOptionValueType().getSimpleName() + \", provided \" + valueType);\n            }\n        }\n    }\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <T> T get(String optionName) {\n        if (!RuntimeOptionValues.singleton().getAllOptionNames().contains(optionName)) {\n            throw new RuntimeException(\"Unknown option: \" + optionName);\n        }\n        Optional<OptionDescriptor> descriptor = RuntimeOptionParser.singleton().getDescriptor(optionName);\n        OptionKey<T> optionKey = (OptionKey<T>) descriptor\n                        .orElseThrow(() -> new RuntimeException(\"Option \" + optionName + \" exists but it is not reachable in the application. It is not possible to get its value.\"))\n                        .getOptionKey();\n        return optionKey.getValue(RuntimeOptionValues.singleton());\n    }\n    @Override\n    public OptionDescriptors getOptions(EnumSet<OptionClass> classes) {\n        Collection<OptionDescriptor> descriptors = RuntimeOptionParser.singleton().getDescriptors();\n        List<org.graalvm.options.OptionDescriptor> graalvmDescriptors = new ArrayList<>(descriptors.size());\n        for (OptionDescriptor descriptor : descriptors) {\n            if (classes.contains(getOptionClass(descriptor))) {\n                org.graalvm.options.OptionDescriptor.Builder builder = org.graalvm.options.OptionDescriptor.newBuilder(asGraalVMOptionKey(descriptor), descriptor.getName());\n                String helpMsg = descriptor.getHelp();\n                int helpLen = helpMsg.length();\n                if (helpLen > 0 && helpMsg.charAt(helpLen - 1) != '.') {\n                    helpMsg += '.';\n                }\n                builder.help(helpMsg);\n                graalvmDescriptors.add(builder.build());\n            }\n        }\n        return OptionDescriptors.create(graalvmDescriptors);\n    }\n<fim_suffix>    private static OptionClass getOptionClass(OptionDescriptor descriptor) {\n        if (descriptor.getOptionKey() instanceof RuntimeOptionKey) {\n            return OptionClass.VM;\n        }\n        return OptionClass.Compiler;\n    }\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    private static <T> org.graalvm.options.OptionKey<T> asGraalVMOptionKey(OptionDescriptor descriptor) {\n        Class<T> clazz = (Class<T>) descriptor.getOptionValueType();\n        OptionType<T> type;\n        if (clazz.isEnum()) {\n            type = (OptionType<T>) ENUM_TYPE_CACHE.computeIfAbsent(clazz, c -> new OptionType<>(c.getSimpleName(), null, s -> (T) Enum.valueOf((Class<? extends Enum>) c, s)));\n        } else if (clazz == Long.class) {\n            type = (OptionType<T>) LONG_OPTION_TYPE;\n        } else {\n            type = OptionType.defaultType(clazz);\n            if (type == null) {\n                throw VMError.shouldNotReachHere(\"unsupported type: \" + clazz);\n            }\n        }\n        OptionKey<T> optionKey = (OptionKey<T>) descriptor.getOptionKey();\n        while (optionKey instanceof NestedBooleanOptionKey) {\n            optionKey = (OptionKey<T>) ((NestedBooleanOptionKey) optionKey).getMasterOption();\n        }\n        T defaultValue = optionKey.getDefaultValue();\n        return new org.graalvm.options.OptionKey<>(defaultValue, type);\n    }\n    private static final Map<Class<?>, OptionType<?>> ENUM_TYPE_CACHE = new HashMap<>();\n    private static final OptionType<Long> LONG_OPTION_TYPE = new OptionType<>(\"long\", 0L, RuntimeOptionsSupportImpl::parseLong);\n    private static long parseLong(String v) {\n        String valueString = v.toLowerCase();\n        long scale = 1;\n        if (valueString.endsWith(\"k\")) {\n            scale = 1024L;\n        } else if (valueString.endsWith(\"m\")) {\n            scale = 1024L * 1024L;\n        } else if (valueString.endsWith(\"g\")) {\n            scale = 1024L * 1024L * 1024L;\n        } else if (valueString.endsWith(\"t\")) {\n            scale = 1024L * 1024L * 1024L * 1024L;\n        }\n        if (scale != 1) {\n            /* Remove trailing scale character. */\n            valueString = valueString.substring(0, valueString.length() - 1);\n        }\n        return Long.parseLong(valueString) * scale;\n    }\n    /*<fim_middle>// function below has no smell\n"}