{"text": "<fim_prefix>\t\tint numPartitions = (int)Math.ceil(((double)rlen*16)/hdfsBlocksize);\n\t\tJavaRDD<ValueIndexPair> sdvals = dvals\n\t\t\t.sortByKey(new IndexComparator(asc), true, numPartitions)\n\t\t\t.keys(); //workaround for index comparator\n\t\t//create target indexes by original index\n\t\tJavaPairRDD<MatrixIndexes, MatrixBlock> ixmap = sdvals\n\t\t\t.zipWithIndex()\n\t\t\t.mapToPair(new ExtractIndexFunction())\n\t\t\t.sortByKey()\n\t\t\t.mapPartitionsToPair(new ConvertToBinaryBlockFunction4(rlen, brlen));\n\t\tixmap = RDDAggregateUtils.mergeByKey(ixmap, false);\n\t\t//actual data sort\n\t\treturn sortDataByIx(data, ixmap, rlen, clen, brlen, bclen);\n\t}\n\tpublic static JavaPairRDD<MatrixIndexes, MatrixBlock> sortDataByVals( JavaPairRDD<MatrixIndexes, MatrixBlock> val, \n\t\tJavaPairRDD<MatrixIndexes, MatrixBlock> data, boolean asc, long rlen, long clen, long clen2, int brlen, int bclen )\n\t{\n\t\t//create value-index rdd from inputs\n\t\tJavaPairRDD<ValuesIndexPair, double[]> dvals = val\n\t\t\t.flatMapToPair(new ExtractDoubleValuesWithIndexFunction2(brlen));\n\t\t//sort (creates sorted range per partition)\n\t\tint numPartitions = SparkUtils.getNumPreferredPartitions(\n\t\t\tnew MatrixCharacteristics(rlen, clen2+1, brlen, brlen));\n\t\tJavaRDD<ValuesIndexPair> sdvals = dvals\n\t\t\t.sortByKey(new IndexComparator2(asc), true, numPartitions)\n\t\t\t.keys(); //workaround for index comparator\n\t\t//create target indexes by original index\n\t\tJavaPairRDD<MatrixIndexes, MatrixBlock> ixmap = sdvals\n\t\t\t.zipWithIndex()\n\t\t\t.mapToPair(new ExtractIndexFunction2())\n\t\t\t.sortByKey()\n\t\t\t.mapPartitionsToPair(new ConvertToBinaryBlockFunction4(rlen, brlen));\n\t\tixmap = RDDAggregateUtils.mergeByKey(ixmap, false);\n\t\t//actual data sort\n\t\treturn sortDataByIx(data, ixmap, rlen, clen, brlen, bclen);\n\t}\n\tpublic static JavaPairRDD<MatrixIndexes, MatrixBlock> sortDataByIx(JavaPairRDD<MatrixIndexes,MatrixBlock> data,\n\t\tJavaPairRDD<MatrixIndexes,MatrixBlock> ixmap, long rlen, long clen, int brlen, int bclen) {\n\t\t//replicate indexes for all column blocks\n\t\tlong numRep = (long)Math.ceil((double)clen/bclen);\n\t\tJavaPairRDD<MatrixIndexes, MatrixBlock> rixmap = ixmap\n\t\t\t.flatMapToPair(new ReplicateVectorFunction(false, numRep));\n\t\t//create binary block output\n\t\tJavaPairRDD<MatrixIndexes, RowMatrixBlock> ret = data\n\t\t\t.join(rixmap)\n\t\t\t.mapPartitionsToPair(new ShuffleMatrixBlockRowsFunction(rlen, brlen));\n\t\treturn RDDAggregateUtils.mergeRowsByKey(ret);\n\t}\n\t/**\n\t * This function collects and sorts value column in memory and then broadcasts it. \n\t * \n\t * @param val value as {@code JavaPairRDD<MatrixIndexes, MatrixBlock>}\n\t * @param data data as {@code JavaPairRDD<MatrixIndexes, MatrixBlock>}\n\t * @param asc if true, sort ascending\n\t * @param rlen number of rows\n\t * @param clen number of columns\n\t * @param brlen number of rows in a block\n\t * @param bclen number of columns in a block\n\t * @param sec spark execution context\n\t * @param r_op reorg operator\n\t * @return data as {@code JavaPairRDD<MatrixIndexes, MatrixBlock>}\n\t */\n\tpublic static JavaPairRDD<MatrixIndexes, MatrixBlock> sortDataByValMemSort( JavaPairRDD<MatrixIndexes, MatrixBlock> val, \n\t\t\tJavaPairRDD<MatrixIndexes, MatrixBlock> data, boolean asc, long rlen, long clen, int brlen, int bclen, \n\t\t\tSparkExecutionContext sec, ReorgOperator r_op) \n\t{\n\t\t//collect orderby column for in-memory sorting\n\t\tMatrixBlock inMatBlock = SparkExecutionContext\n\t\t\t\t.toMatrixBlock(val, (int)rlen, 1, brlen, bclen, -1);\n\t\t//in-memory sort operation (w/ index return: source index in target position)\n\t\tReorgOperator lrop = new ReorgOperator(new SortIndex(1, !asc, true));\n\t\tMatrixBlock sortedIx = (MatrixBlock) inMatBlock\n\t\t\t\t.reorgOperations(lrop, new MatrixBlock(), -1, -1, -1);\n\t\t//flip sort indices from <source ix in target pos> to <target ix in source pos>\n\t\tMatrixBlock sortedIxSrc = new MatrixBlock(sortedIx.getNumRows(), 1, false); \n\t\tfor (int i=0; i < sortedIx.getNumRows(); i++) \n\t\t\tsortedIxSrc.quickSetValue((int)sortedIx.quickGetValue(i,0)-1, 0, i+1);\n\t\t//broadcast index vector\n\t\tPartitionedBlock<MatrixBlock> pmb = new PartitionedBlock<>(sortedIxSrc, brlen, bclen);\n\t\tBroadcast<PartitionedBlock<MatrixBlock>> _pmb = sec.getSparkContext().broadcast(pmb);\t\n\t\t//sort data with broadcast index vector\n\t\tJavaPairRDD<MatrixIndexes, RowMatrixBlock> ret = data\n\t\t\t\t.mapPartitionsToPair(new ShuffleMatrixBlockRowsInMemFunction(rlen, brlen, _pmb));\n\t\treturn RDDAggregateUtils.mergeRowsByKey(ret);\n\t}\n\tprivate static class ExtractDoubleValuesFunction implements FlatMapFunction<MatrixBlock,Double> \n\t{\n\t\tprivate static final long serialVersionUID = 6888003502286282876L;\n\t\t@Override\n\t\tpublic Iterator<Double> call(MatrixBlock arg0) \n\t\t\tthrows Exception {\n\t\t\treturn DataConverter.convertToDoubleList(arg0).iterator();\n\t\t}\n\t}\n\tprivate static class ExtractRowsFunction implements FlatMapFunction<MatrixBlock,MatrixBlock> \n\t{\n\t\tprivate static final long serialVersionUID = -2786968469468554974L;\n\t\t@Override\n\t\tpublic Iterator<MatrixBlock> call(MatrixBlock arg0) \n\t\t\tthrows Exception {\n\t\t\tArrayList<MatrixBlock> rows = new ArrayList<>();\n\t\t\tfor(int i=0; i<arg0.getNumRows(); i++)\n\t\t\t\trows.add(arg0.slice(i, i));\n\t\t\treturn rows.iterator();\n\t\t}\n\t}\n\tprivate static class ExtractDoubleValuesFunction2 implements FlatMapFunction<Tuple2<MatrixBlock,MatrixBlock>,DoublePair> \n\t{\n\t\tprivate static final long serialVersionUID = 2132672563825289022L;\n\t\t@Override\n\t\tpublic Iterator<DoublePair> call(Tuple2<MatrixBlock,MatrixBlock> arg0) \n\t\t\tthrows Exception \n\t\t{\n\t\t\tArrayList<DoublePair> ret = new ArrayList<>(); \n\t\t\tMatrixBlock mb1 = arg0._1();\n\t\t\tMatrixBlock mb2 = arg0._2();\n\t\t\tfor( int i=0; i<mb1.getNumRows(); i++) {\n\t\t\t\tret.add(new DoublePair(\n\t\t\t\t\t\tmb1.quickGetValue(i, 0),\n\t\t\t\t\t\tmb2.quickGetValue(i, 0)));\n\t\t\t}\n\t\t\treturn ret.iterator();\n\t\t}\t\t\n\t}\n\tprivate static class ExtractDoubleValuesWithIndexFunction implements PairFlatMapFunction<Tuple2<MatrixIndexes,MatrixBlock>,ValueIndexPair,Double> \n\t{\n\t\tprivate static final long serialVersionUID = -3976735381580482118L;\n\t\tprivate int _brlen = -1;\n\t\tpublic ExtractDoubleValuesWithIndexFunction(int brlen)\n\t\t{\n\t\t\t_brlen = brlen;\n\t\t}\n<fim_suffix>\t\t@Override\n\t\tpublic Iterator<Tuple2<ValueIndexPair,Double>> call(Tuple2<MatrixIndexes,MatrixBlock> arg0) \n\t\t\tthrows Exception \n\t\t{\n\t\t\tArrayList<Tuple2<ValueIndexPair,Double>> ret = new ArrayList<>(); \n\t\t\tMatrixIndexes ix = arg0._1();\n\t\t\tMatrixBlock mb = arg0._2();\n\t\t\tlong ixoffset = (ix.getRowIndex()-1)*_brlen;\n\t\t\tfor( int i=0; i<mb.getNumRows(); i++) {\n\t\t\t\tdouble val = mb.quickGetValue(i, 0);\n\t\t\t\tret.add(new Tuple2<>(new ValueIndexPair(val,ixoffset+i+1), val));\n\t\t\t}\n\t\t\treturn ret.iterator();\n\t\t}<fim_middle>// function below has no smell\n"}