{"text": "<fim_prefix>   *      public boolean filter(T o) {\n   *          ...\n   *      }\n   * }.map(new B() {\n   *      public T apply(T o) {\n   *          ...\n   *      }\n   * }\n   *\n   * We call:\n   *   - A.filter - The filter method (not Observable.filter)\n   *   - B.apply - The map method (not Observable.map)\n   *   - observable.filter().map() is the observable call chain, and 'Observable.map' is the outer call of\n   *   'Observable.filter'). In general, for observable.a().b().c(), c is the outer call of b and b the outer call\n   *   of a in the chain.\n   *\n   * This class works by building the following maps which keep enough state outside of the standard dataflow\n   * analysis for us to figure out what's going on:\n   *\n   * Note: If this state ever becomes a memory issue, we can discard it as soon as we exit any method at the\n   * topmost scope (e.g. not a method called from an anonymous inner class inside another method or a lambda).\n   */\n  // Set of filter methods found thus far (e.g. A.filter, see above)\n  private final Set<Tree> filterMethodOrLambdaSet = new LinkedHashSet<Tree>();\n  // Maps each call in the observable call chain to its outer call (see above).\n  private final Map<MethodInvocationTree, MethodInvocationTree> observableOuterCallInChain =\n      new LinkedHashMap<MethodInvocationTree, MethodInvocationTree>();\n  // Maps the call in the observable call chain to the relevant inner method or lambda.\n  // e.g. In the example above:\n  //   observable.filter() => A.filter\n  //   observable.filter().map() => B.apply\n  private final Map<MethodInvocationTree, Tree> observableCallToInnerMethodOrLambda =\n      new LinkedHashMap<MethodInvocationTree, Tree>();\n  // Map from map method (or lambda) to corresponding previous filter method (e.g. B.apply =>\n  // A.filter)\n  private final Map<Tree, MaplikeToFilterInstanceRecord> mapToFilterMap =\n      new LinkedHashMap<Tree, MaplikeToFilterInstanceRecord>();\n  /*\n   * Note that the above methods imply a diagram like the following:\n   *\n   *                              /--- observable.filter(new A() {\n   *                              |      \\->public boolean filter(T o) {<---\\\n   * [observableOuterCallInChain] |             ...                         |\n   *                              |         }                               | [mapToFilterMap]\n   *                              \\--> }.map(new B() {                      |\n   *                                     \\->public T apply(T o) {        ---/\n   *                                            ...\n   *                                        }\n   *                                   }\n   */\n  // Map from filter method (or lambda) to corresponding nullability info after the function returns\n  // true.\n  // Specifically, this is the least upper bound of the \"then\" store on the branch of every return\n  // statement in which the expression after the return can be true.\n  private final Map<Tree, NullnessStore> filterToNSMap = new LinkedHashMap<Tree, NullnessStore>();\n  // Maps the body of a method or lambda to the corresponding enclosing tree, used because the\n  // dataflow analysis\n  // loses the pointer to the tree by the time we hook into its body.\n  private final Map<Tree, Tree> bodyToMethodOrLambda = new LinkedHashMap<Tree, Tree>();\n  // Maps the return statements of the filter method to the filter tree itself, similar issue as\n  // above.\n  private final Map<ReturnTree, Tree> returnToEnclosingMethodOrLambda =\n      new LinkedHashMap<ReturnTree, Tree>();\n  // Similar to above, but mapping expression-bodies to their enclosing lambdas\n  private final Map<ExpressionTree, LambdaExpressionTree> expressionBodyToFilterLambda =\n      new LinkedHashMap<ExpressionTree, LambdaExpressionTree>();\n  RxNullabilityPropagator() {\n    super();\n  }\n  @Override\n  public void onMatchTopLevelClass(\n      NullAway analysis, ClassTree tree, VisitorState state, Symbol.ClassSymbol classSymbol) {\n    // Clear compilation unit specific state\n    this.filterMethodOrLambdaSet.clear();\n    this.observableOuterCallInChain.clear();\n    this.observableCallToInnerMethodOrLambda.clear();\n    this.mapToFilterMap.clear();\n    this.filterToNSMap.clear();\n    this.bodyToMethodOrLambda.clear();\n    this.returnToEnclosingMethodOrLambda.clear();\n  }\n  @Override\n  public void onMatchMethodInvocation(\n      NullAway analysis,\n      MethodInvocationTree tree,\n      VisitorState state,\n      Symbol.MethodSymbol methodSymbol) {\n    Type receiverType = ASTHelpers.getReceiverType(tree);\n    for (StreamTypeRecord streamType : RX_MODELS) {\n      if (streamType.matchesType(receiverType, state)) {\n        String methodName = methodSymbol.toString();\n        // Build observable call chain\n        buildObservableCallChain(tree);\n        // Dispatch to code handling specific observer methods\n        if (streamType.isFilterMethod(methodSymbol) && methodSymbol.getParameters().length() == 1) {\n          ExpressionTree argTree = tree.getArguments().get(0);\n          if (argTree instanceof NewClassTree) {\n            ClassTree annonClassBody = ((NewClassTree) argTree).getClassBody();\n            // Ensure that this `new A() ...` has a custom class body, otherwise, we skip for now.\n            // In the future, we could look at the declared type and its inheritance chain, at least\n            // for\n            // filters.\n            if (annonClassBody != null) {\n              handleFilterAnonClass(streamType, tree, annonClassBody, state);\n            }\n          } else if (argTree instanceof LambdaExpressionTree) {\n            LambdaExpressionTree lambdaTree = (LambdaExpressionTree) argTree;\n            handleFilterLambda(streamType, tree, lambdaTree, state);\n          }\n        } else if (streamType.isMapMethod(methodSymbol)\n            && methodSymbol.getParameters().length() == 1) {\n          ExpressionTree argTree = tree.getArguments().get(0);\n          if (argTree instanceof NewClassTree) {\n            ClassTree annonClassBody = ((NewClassTree) argTree).getClassBody();\n            // Ensure that this `new B() ...` has a custom class body, otherwise, we skip for now.\n            if (annonClassBody != null) {\n              MaplikeMethodRecord methodRecord = streamType.getMaplikeMethodRecord(methodSymbol);\n              handleMapAnonClass(methodRecord, tree, annonClassBody, state);\n            }\n          } else if (argTree instanceof LambdaExpressionTree) {\n            observableCallToInnerMethodOrLambda.put(tree, (LambdaExpressionTree) argTree);\n          } else if (argTree instanceof MemberReferenceTree) {\n            observableCallToInnerMethodOrLambda.put(tree, (MemberReferenceTree) argTree);\n          }\n        }\n      }\n    }\n  }\n  private void buildObservableCallChain(MethodInvocationTree tree) {\n    ExpressionTree methodSelect = tree.getMethodSelect();\n    if (methodSelect instanceof MemberSelectTree) {\n      ExpressionTree receiverExpression = ((MemberSelectTree) methodSelect).getExpression();\n      if (receiverExpression instanceof MethodInvocationTree) {\n        observableOuterCallInChain.put((MethodInvocationTree) receiverExpression, tree);\n      }\n    } // ToDo: What else can be here? If there are other cases than MemberSelectTree, handle them.\n  }\n<fim_suffix>  private void handleChainFromFilter(\n      StreamTypeRecord streamType,\n      MethodInvocationTree observableDotFilter,\n      Tree filterMethodOrLambda,\n      VisitorState state) {\n    MethodInvocationTree outerCallInChain = observableDotFilter;\n    if (outerCallInChain == null) {\n      return;\n    }\n    // Traverse the observable call chain out through any pass-through methods\n    do {\n      outerCallInChain = observableOuterCallInChain.get(outerCallInChain);\n      // Check for a map method (which might be a pass-through method or the first method after a\n      // pass-through chain)\n      MethodInvocationTree mapCallsite = observableOuterCallInChain.get(observableDotFilter);\n      if (observableCallToInnerMethodOrLambda.containsKey(outerCallInChain)) {\n        // Update mapToFilterMap\n        Symbol.MethodSymbol mapMethod = ASTHelpers.getSymbol(outerCallInChain);\n        if (streamType.isMapMethod(mapMethod)) {\n          MaplikeToFilterInstanceRecord record =\n              new MaplikeToFilterInstanceRecord(\n                  streamType.getMaplikeMethodRecord(mapMethod), filterMethodOrLambda);\n          mapToFilterMap.put(observableCallToInnerMethodOrLambda.get(outerCallInChain), record);\n        }\n      }\n    } while (outerCallInChain != null\n        && streamType.matchesType(ASTHelpers.getReceiverType(outerCallInChain), state)\n        && streamType.isPassthroughMethod(ASTHelpers.getSymbol(outerCallInChain)));\n  }<fim_middle>// function below is long method\n"}