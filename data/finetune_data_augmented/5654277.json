{"text": "<fim_prefix>\n<fim_suffix>final class Prefixes {\n    /**\n     * The SI \u201cdeca\u201d prefix. This is the only SI prefix encoded on two letters instead than one.\n     * It can be represented by the CJK compatibility character \u201c\u3372\u201d, but use of those characters\n     * is generally not recommended outside of Chinese, Japanese or Korean texts.\n     */\n    private static final String DECA = \"da\";\n    /**\n     * The SI prefixes in increasing order. The only two-letters prefix \u2013 \u201cda\u201d \u2013 is encoded using the JCK compatibility\n     * character \u201c\u3372\u201d. The Greek letter \u03bc is repeated twice: the U+00B5 character for micro sign (this is the character\n     * that Apache SIS uses in unit symbols) and the U+03BC character for the Greek small letter \u201cmu\u201d (the later is the\n     * character that appears when decomposing JCK compatibility characters with {@link java.text.Normalizer}).\n     * Both characters have same appearance but different values.\n     *\n     * <p>For each prefix at index <var>i</var>, the multiplication factor is given by 10 raised to power {@code POWERS[i]}.</p>\n     */\n    private static final char[] PREFIXES = {'E','G','M','P','T','Y','Z','a','c','d','f','h','k','m','n','p','y','z','\u00b5','\u03bc','\u3372'};\n    private static final byte[] POWERS   = {18,  9,  6, 15, 12, 24, 21,-18, -2, -1,-15,  2,  3, -3, -9,-12,-24,-21, -6, -6,  1};\n    /**\n     * The SI prefixes from smallest to largest. Power of tens go from -24 to +24 inclusive with a step of 3,\n     * except for the addition of -2, -1, +1, +2 and the omission of 0.\n     *\n     * @see #symbol(double, int)\n     */\n    private static final char[] ENUM = {'y','z','a','f','p','n','\u00b5','m','c','d','\u3372','h','k','M','G','T','P','E','Z','Y'};\n    /**\n     * The maximal power of 1000 for the prefixes in the {@link #ENUM} array. Note that 1000\u2078 = 1E+24.\n     */\n    static final int MAX_POWER = 8;\n    /**\n     * The converters for SI prefixes, created when first needed.\n     *\n     * @see #converter(char)\n     */\n    private static final LinearConverter[] CONVERTERS = new LinearConverter[POWERS.length];\n    /**\n     * Do not allow instantiation of this class.\n     */\n    private Prefixes() {\n    }\n    /**\n     * Returns the converter for the given SI prefix, or {@code null} if none.\n     * Those converters are created when first needed and cached for reuse.\n     */\n    static LinearConverter converter(final char prefix) {\n        final int i = Arrays.binarySearch(PREFIXES, prefix);\n        if (i < 0) {\n            return null;\n        }\n        synchronized (CONVERTERS) {\n            LinearConverter c = CONVERTERS[i];\n            if (c == null) {\n                final int p = POWERS[i];\n                final double numerator, denominator;\n                if (p >= 0) {\n                    numerator = MathFunctions.pow10(p);\n                    denominator = 1;\n                } else {\n                    numerator = 1;\n                    denominator = MathFunctions.pow10(-p);\n                }\n                c = LinearConverter.scale(numerator, denominator);\n                CONVERTERS[i] = c;\n            }\n            return c;\n        }\n    }\n    /**\n     * Returns the SI prefix symbol for the given scale factor, or 0 if none.\n     *\n     * @param  scale  the scale factor.\n     * @param  power  the unit power. For example if we are scaling m\u00b2, then this is 2.\n     * @return the prefix, or 0 if none.\n     */\n    static char symbol(double scale, final int power) {\n        switch (power) {\n            case 0:  return 0;\n            case 1:  break;\n            case 2:  scale = Math.sqrt(scale); break;\n            case 3:  scale = Math.cbrt(scale); break;\n            default: scale = Math.pow(scale, 1.0/power);\n        }\n        final int n = Numerics.toExp10(Math.getExponent(scale)) + 1;\n        if (AbstractConverter.epsilonEquals(MathFunctions.pow10(n), scale)) {\n            int i = Math.abs(n);\n            switch (i) {\n                case 0:  return 0;\n                case 1:  // Fallthrough\n                case 2:  break;\n                default: {\n                    if (i > (MAX_POWER*3) || (i % 3) != 0) {\n                        return 0;\n                    }\n                    i = i/3 + 2;\n                    break;\n                }\n            }\n            return ENUM[n >= 0 ? (MAX_POWER+1) + i : (MAX_POWER+2) - i];\n        }\n        return 0;\n    }\n    /**\n     * Returns the concatenation of the given prefix with the given unit symbol.\n     */\n    static String concat(final char prefix, final String unit) {\n        return (prefix == '\u3372') ? DECA + unit : prefix + unit;\n    }\n    /**\n     * Returns the unit for the given symbol, taking the SI prefix in account. The given string is usually a single symbol\n     * like \"km\", but may be an expression like \"m\u00b3\" or \"m/s\" if the given symbol is explicitly registered as an item that\n     * {@link Units#get(String)} recognizes. This method does not perform any arithmetic operation on {@code Unit},\n     * except a check for the exponent.\n     *\n     * @param  uom  a symbol compliant with the rules documented in {@link AbstractUnit#symbol}.\n     * @return the unit for the given symbol, or {@code null} if no unit is found.\n     */\n    static Unit<?> getUnit(final String uom) {\n        Unit<?> unit = Units.get(uom);\n        if (unit == null && uom.length() >= 2) {\n            int s = 1;\n            char prefix = uom.charAt(0);\n            if (prefix == 'd' && uom.charAt(1) == 'a') {\n                prefix = '\u3372';      // Converse of above 'concat(char, String)' method.\n                s = 2;              // Skip \"da\", which we represent by '\u3372'.\n            }\n            unit = Units.get(uom.substring(s));\n            if (AbstractUnit.isPrefixable(unit)) {\n                LinearConverter c = Prefixes.converter(prefix);\n                if (c != null) {\n                    String symbol = unit.getSymbol();\n                    final int power = ConventionalUnit.power(symbol);\n                    if (power != 0) {\n                        if (power != 1) {\n                            c = LinearConverter.pow(c, power, false);\n                        }\n                        symbol = Prefixes.concat(prefix, symbol);\n                        return new ConventionalUnit<>((AbstractUnit<?>) unit, c, symbol.intern(), (byte) 0, (short) 0);\n                    }\n                }\n            }\n            unit = null;\n        }\n        return unit;\n    }\n    /**\n     * If the given system unit should be replaced by pseudo-unit for the purpose of formatting,\n     * returns that pseudo-unit. Otherwise returns {@code null}. This method is for handling the\n     * Special case of {@link Units#KILOGRAM}, to be replaced by {@link Units#GRAM} so a prefix\n     * can be computed. The kilogram may appear in an expression like \"kg/m\", which we want to\n     * replace by \"g/m\". We do that by dividing the unit by 1000 (the converter for \"milli\" prefix).\n     */\n    @SuppressWarnings(\"unchecked\")\n    static <Q extends Quantity<Q>> ConventionalUnit<Q> pseudoSystemUnit(final SystemUnit<Q> unit) {\n        if ((unit.scope & ~UnitRegistry.SI) == 0 && unit.dimension.numeratorIs('M')) {\n            if (unit == Units.KILOGRAM) {\n                return (ConventionalUnit<Q>) Units.GRAM;            // Optimization for a common case.\n            } else {\n                String symbol = unit.getSymbol();\n                if (symbol != null && symbol.length() >= 3 && symbol.startsWith(\"kg\")\n                        && !AbstractUnit.isSymbolChar(symbol.codePointAt(2)))\n                {\n                    symbol = symbol.substring(1);\n                    UnitConverter c = converter('m');<fim_middle>// class below is blob\n"}