{"text": "<fim_prefix>/*\n * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 3 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 3 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 3 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage com.oracle.truffle.r.runtime.conn;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.ProcessBuilder.Redirect;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.ByteChannel;\nimport java.nio.channels.Channels;\nimport java.nio.channels.ReadableByteChannel;\nimport java.nio.channels.WritableByteChannel;\n\nimport com.oracle.truffle.r.runtime.RError;\nimport com.oracle.truffle.r.runtime.conn.ConnectionSupport.AbstractOpenMode;\nimport com.oracle.truffle.r.runtime.conn.ConnectionSupport.BaseRConnection;\nimport com.oracle.truffle.r.runtime.conn.ConnectionSupport.ConnectionClass;\n\npublic class PipeConnections {\n\n    private static Process executeAndJoin(String command) throws IOException {\n        ProcessBuilder pb = new ProcessBuilder(\"/bin/sh\", \"-c\", command);\n        pb.redirectError(Redirect.INHERIT);\n        Process p = pb.start();\n        try {\n            p.waitFor();\n        } catch (InterruptedException e) {\n            // TODO not sure how to handle an interrupted exception at this point\n        }\n        return p;\n    }\n\n    public static class PipeRConnection extends BaseRConnection {\n\n        private final String command;\n\n        public PipeRConnection(String command, String open, String encoding) throws IOException {\n            super(ConnectionClass.FIFO, open, AbstractOpenMode.Read, encoding);\n            this.command = command;\n            openNonLazyConnection();\n        }\n\n        @Override\n        protected void createDelegateConnection() throws IOException {\n            final DelegateRConnection delegate;\n            switch (getOpenMode().abstractOpenMode) {\n                case Read:\n                case ReadBinary:\n                    delegate = new PipeReadRConnection(this, command);\n                    break;\n                case Write:\n                case WriteBinary:\n                    delegate = new PipeWriteConnection(this, command);\n                    break;\n                case ReadAppend:\n                case ReadWrite:\n                case ReadWriteBinary:\n                case ReadWriteTrunc:\n                case ReadWriteTruncBinary:\n                    delegate = new PipeReadWriteConnection(this, command);\n                    break;\n                default:\n                    throw RError.nyi(RError.SHOW_CALLER2, \"open mode: \" + getOpenMode());\n            }\n            setDelegate(delegate);\n        }\n\n        @Override\n        public String getSummaryDescription() {\n            return command;\n        }\n    }\n\n<fim_suffix>    static class PipeReadRConnection extends DelegateReadRConnection {\n        private final ByteChannel channel;\n\n        protected PipeReadRConnection(BaseRConnection base, String command) throws IOException {\n            super(base);\n            Process p = PipeConnections.executeAndJoin(command);\n            channel = ConnectionSupport.newChannel(p.getInputStream());\n        }\n\n        @Override\n        public ByteChannel getChannel() {\n            return channel;\n        }\n\n        @Override\n        public boolean isSeekable() {\n            return false;\n        }\n    }\n\n    private static class PipeWriteConnection extends DelegateWriteRConnection {\n        private final ByteChannel channel;\n\n        PipeWriteConnection(BaseRConnection base, String command) throws IOException {\n            super(base);\n            Process p = PipeConnections.executeAndJoin(command);\n            channel = ConnectionSupport.newChannel(p.getOutputStream());\n        }\n\n        @Override\n        public ByteChannel getChannel() {\n            return channel;\n        }\n\n        @Override\n        public boolean isSeekable() {\n            return false;\n        }\n    }\n\n    private static class PipeReadWriteConnection extends DelegateReadWriteRConnection {\n\n        private final RWChannel channel;\n\n        protected PipeReadWriteConnection(BaseRConnection base, String command) throws IOException {\n            super(base);\n            Process p = PipeConnections.executeAndJoin(command);\n            channel = new RWChannel(p.getInputStream(), p.getOutputStream());\n        }\n\n        @Override\n        public ByteChannel getChannel() {\n            return channel;\n        }\n\n        @Override\n        public boolean isSeekable() {\n            return false;\n        }\n\n        private static final class RWChannel implements ByteChannel {\n            private final ReadableByteChannel rchannel;\n            private final WritableByteChannel wchannel;\n\n            RWChannel(InputStream in, OutputStream out) {\n                rchannel = Channels.newChannel(in);\n                wchannel = Channels.newChannel(out);\n            }\n\n            @Override\n            public int read(ByteBuffer dst) throws IOException {\n                return rchannel.read(dst);\n            }\n\n            @Override\n            public boolean isOpen() {\n                return rchannel.isOpen() && wchannel.isOpen();\n            }\n\n            @Override\n            public void close() throws IOException {\n                rchannel.close();\n                wchannel.close();\n            }\n\n            @Override\n            public int write(ByteBuffer src) throws IOException {\n                return wchannel.write(src);\n            }\n        }\n\n    }\n}<fim_middle>// class below has no smell\n"}