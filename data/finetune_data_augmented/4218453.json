{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.cassandra.index.sasi.plan;\nimport java.nio.ByteBuffer;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\nimport org.apache.cassandra.schema.ColumnMetadata;\nimport org.apache.cassandra.cql3.Operator;\nimport org.apache.cassandra.index.sasi.analyzer.AbstractAnalyzer;\nimport org.apache.cassandra.index.sasi.conf.ColumnIndex;\nimport org.apache.cassandra.index.sasi.disk.OnDiskIndex;\nimport org.apache.cassandra.index.sasi.utils.TypeUtil;\nimport org.apache.cassandra.db.marshal.AbstractType;\nimport org.apache.cassandra.db.marshal.UTF8Type;\nimport org.apache.cassandra.utils.ByteBufferUtil;\nimport org.apache.cassandra.utils.FBUtilities;\nimport org.apache.commons.lang3.builder.HashCodeBuilder;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.collect.Iterators;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\npublic class Expression\n{\n    private static final Logger logger = LoggerFactory.getLogger(Expression.class);\n    public enum Op\n    {\n        EQ, MATCH, PREFIX, SUFFIX, CONTAINS, NOT_EQ, RANGE;\n        public static Op valueOf(Operator operator)\n        {\n            switch (operator)\n            {\n                case EQ:\n                    return EQ;\n                case NEQ:\n                    return NOT_EQ;\n                case LT:\n                case GT:\n                case LTE:\n                case GTE:\n                    return RANGE;\n                case LIKE_PREFIX:\n                    return PREFIX;\n                case LIKE_SUFFIX:\n                    return SUFFIX;\n                case LIKE_CONTAINS:\n                    return CONTAINS;\n                case LIKE_MATCHES:\n                    return MATCH;\n                default:\n                    throw new IllegalArgumentException(\"unknown operator: \" + operator);\n            }\n        }\n    }\n    private final QueryController controller;\n    public final AbstractAnalyzer analyzer;\n    public final ColumnIndex index;\n    public final AbstractType<?> validator;\n    public final boolean isLiteral;\n    @VisibleForTesting\n    protected Op operation;\n    public Bound lower, upper;\n    public List<ByteBuffer> exclusions = new ArrayList<>();\n    public Expression(Expression other)\n    {\n        this(other.controller, other.index);\n        operation = other.operation;\n    }\n    public Expression(QueryController controller, ColumnIndex columnIndex)\n    {\n        this.controller = controller;\n        this.index = columnIndex;\n        this.analyzer = columnIndex.getAnalyzer();\n        this.validator = columnIndex.getValidator();\n        this.isLiteral = columnIndex.isLiteral();\n    }\n    @VisibleForTesting\n    public Expression(String name, AbstractType<?> validator)\n    {\n        this(null, new ColumnIndex(UTF8Type.instance, ColumnMetadata.regularColumn(\"sasi\", \"internal\", name, validator), null));\n    }\n    public Expression setLower(Bound newLower)\n    {\n        lower = newLower == null ? null : new Bound(newLower.value, newLower.inclusive);\n        return this;\n    }\n<fim_suffix>    public Expression setUpper(Bound newUpper)\n    {\n        upper = newUpper == null ? null : new Bound(newUpper.value, newUpper.inclusive);\n        return this;\n    }\n    public Expression setOp(Op op)\n    {\n        this.operation = op;\n        return this;\n    }\n    public Expression add(Operator op, ByteBuffer value)\n    {\n        boolean lowerInclusive = false, upperInclusive = false;\n        switch (op)\n        {\n            case LIKE_PREFIX:\n            case LIKE_SUFFIX:\n            case LIKE_CONTAINS:\n            case LIKE_MATCHES:\n            case EQ:\n                lower = new Bound(value, true);\n                upper = lower;\n                operation = Op.valueOf(op);\n                break;\n            case NEQ:\n                // index expressions are priority sorted\n                // and NOT_EQ is the lowest priority, which means that operation type\n                // is always going to be set before reaching it in case of RANGE or EQ.\n                if (operation == null)\n                {\n                    operation = Op.NOT_EQ;\n                    lower = new Bound(value, true);\n                    upper = lower;\n                }\n                else\n                    exclusions.add(value);\n                break;\n            case LTE:\n                if (index.getDefinition().isReversedType())\n                    lowerInclusive = true;\n                else\n                    upperInclusive = true;\n            case LT:\n                operation = Op.RANGE;\n                if (index.getDefinition().isReversedType())\n                    lower = new Bound(value, lowerInclusive);\n                else\n                    upper = new Bound(value, upperInclusive);\n                break;\n            case GTE:\n                if (index.getDefinition().isReversedType())\n                    upperInclusive = true;\n                else\n                    lowerInclusive = true;\n            case GT:\n                operation = Op.RANGE;\n                if (index.getDefinition().isReversedType())\n                    upper = new Bound(value, upperInclusive);\n                else\n                    lower = new Bound(value, lowerInclusive);\n                break;\n        }\n        return this;\n    }\n    public Expression addExclusion(ByteBuffer value)\n    {\n        exclusions.add(value);\n        return this;\n    }\n    public boolean isSatisfiedBy(ByteBuffer value)\n    {\n        if (!TypeUtil.isValid(value, validator))\n        {\n            int size = value.remaining();\n            if ((value = TypeUtil.tryUpcast(value, validator)) == null)\n            {\n                logger.error(\"Can't cast value for {} to size accepted by {}, value size is {}.\",\n                             index.getColumnName(),\n                             validator,\n                             FBUtilities.prettyPrintMemory(size));\n                return false;\n            }\n        }\n        if (lower != null)\n        {\n            // suffix check\n            if (isLiteral)\n            {\n                if (!validateStringValue(value, lower.value))\n                    return false;\n            }\n            else\n            {\n                // range or (not-)equals - (mainly) for numeric values\n                int cmp = validator.compare(lower.value, value);\n                // in case of (NOT_)EQ lower == upper\n                if (operation == Op.EQ || operation == Op.NOT_EQ)\n                    return cmp == 0;\n                if (cmp > 0 || (cmp == 0 && !lower.inclusive))\n                    return false;\n            }\n        }\n        if (upper != null && lower != upper)\n        {\n            // string (prefix or suffix) check\n            if (isLiteral)\n            {\n                if (!validateStringValue(value, upper.value))\n                    return false;\n            }\n            else\n            {\n                // range - mainly for numeric values\n                int cmp = validator.compare(upper.value, value);\n                if (cmp < 0 || (cmp == 0 && !upper.inclusive))\n                    return false;\n            }\n        }\n        // as a last step let's check exclusions for the given field,\n        // this covers EQ/RANGE with exclusions.\n        for (ByteBuffer term : exclusions)\n        {\n            if (isLiteral && validateStringValue(value, term))\n                return false;\n            else if (validator.compare(term, value) == 0)\n                return false;\n        }\n        return true;\n    }\n    private boolean validateStringValue(ByteBuffer columnValue, ByteBuffer requestedValue)\n    {\n        analyzer.reset(columnValue.duplicate());\n        while (analyzer.hasNext())\n        {\n            ByteBuffer term = analyzer.next();\n            boolean isMatch = false;\n            switch (operation)\n            {\n                case EQ:\n                case MATCH:\n                // Operation.isSatisfiedBy handles conclusion on !=,\n                // here we just need to make sure that term matched it\n                case NOT_EQ:\n                    isMatch = validator.compare(term, requestedValue) == 0;\n                    break;\n                case PREFIX:\n                    isMatch = ByteBufferUtil.startsWith(term, requestedValue);\n                    break;\n                case SUFFIX:\n                    isMatch = ByteBufferUtil.endsWith(term, requestedValue);\n                    break;\n                case CONTAINS:\n                    isMatch = ByteBufferUtil.contains(term, requestedValue);\n                    break;\n            }\n            if (isMatch)\n                return true;\n        }\n        return false;\n    }\n    public Op getOp()\n    {\n        return operation;\n    }\n    public void checkpoint()\n    {\n        if (controller == null)\n            return;\n        controller.checkpoint();\n    }\n    public boolean hasLower()\n    {\n        return lower != null;\n    }\n    public boolean hasUpper()\n    {\n        return upper != null;\n    }<fim_middle>// function below has no smell\n"}