{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.cassandra.service;\n\nimport java.util.concurrent.atomic.AtomicIntegerFieldUpdater;\n\nimport org.apache.cassandra.exceptions.RequestFailureReason;\nimport org.apache.cassandra.exceptions.WriteFailureException;\nimport org.apache.cassandra.exceptions.WriteTimeoutException;\nimport org.apache.cassandra.locator.InetAddressAndPort;\nimport org.apache.cassandra.net.MessageIn;\n\n<fim_suffix>public class BatchlogResponseHandler<T> extends AbstractWriteResponseHandler<T>\n{\n    AbstractWriteResponseHandler<T> wrapped;\n    BatchlogCleanup cleanup;\n    protected volatile int requiredBeforeFinish;\n    private static final AtomicIntegerFieldUpdater<BatchlogResponseHandler> requiredBeforeFinishUpdater\n            = AtomicIntegerFieldUpdater.newUpdater(BatchlogResponseHandler.class, \"requiredBeforeFinish\");\n\n    public BatchlogResponseHandler(AbstractWriteResponseHandler<T> wrapped, int requiredBeforeFinish, BatchlogCleanup cleanup, long queryStartNanoTime)\n    {\n        super(wrapped.replicaPlan, wrapped.callback, wrapped.writeType, queryStartNanoTime);\n        this.wrapped = wrapped;\n        this.requiredBeforeFinish = requiredBeforeFinish;\n        this.cleanup = cleanup;\n    }\n\n    protected int ackCount()\n    {\n        return wrapped.ackCount();\n    }\n\n    public void response(MessageIn<T> msg)\n    {\n        wrapped.response(msg);\n        if (requiredBeforeFinishUpdater.decrementAndGet(this) == 0)\n            cleanup.ackMutation();\n    }\n\n    public boolean isLatencyForSnitch()\n    {\n        return wrapped.isLatencyForSnitch();\n    }\n\n    public void onFailure(InetAddressAndPort from, RequestFailureReason failureReason)\n    {\n        wrapped.onFailure(from, failureReason);\n    }\n\n    public void get() throws WriteTimeoutException, WriteFailureException\n    {\n        wrapped.get();\n    }\n\n    protected int blockFor()\n    {\n        return wrapped.blockFor();\n    }\n\n    protected int candidateReplicaCount()\n    {\n        return wrapped.candidateReplicaCount();\n    }\n\n    protected boolean waitingFor(InetAddressAndPort from)\n    {\n        return wrapped.waitingFor(from);\n    }\n\n    protected void signal()\n    {\n        wrapped.signal();\n    }\n\n    public static class BatchlogCleanup\n    {\n        private final BatchlogCleanupCallback callback;\n\n        protected volatile int mutationsWaitingFor;\n        private static final AtomicIntegerFieldUpdater<BatchlogCleanup> mutationsWaitingForUpdater\n            = AtomicIntegerFieldUpdater.newUpdater(BatchlogCleanup.class, \"mutationsWaitingFor\");\n\n        public BatchlogCleanup(int mutationsWaitingFor, BatchlogCleanupCallback callback)\n        {\n            this.mutationsWaitingFor = mutationsWaitingFor;\n            this.callback = callback;\n        }\n\n        public void ackMutation()\n        {\n            if (mutationsWaitingForUpdater.decrementAndGet(this) == 0)\n                callback.invoke();\n        }\n    }\n\n    public interface BatchlogCleanupCallback\n    {\n        void invoke();\n    }\n}<fim_middle>// class below has no smell\n"}