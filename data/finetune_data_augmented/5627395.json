{"text": "<fim_prefix>/*\n *\n *  Licensed to the Apache Software Foundation (ASF) under one or more\n *  contributor license agreements.  See the NOTICE file distributed with\n *  this work for additional information regarding copyright ownership.\n *  The ASF licenses this file to You under the Apache License, Version 2.0\n *  (the \"License\"); you may not use this file except in compliance with\n *  the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n */\npackage org.apache.royale.compiler.internal.as.codegen;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Vector;\nimport org.apache.royale.abc.instructionlist.InstructionList;\nimport org.apache.royale.abc.semantics.Label;\nimport org.apache.royale.compiler.exceptions.DuplicateLabelException;\nimport org.apache.royale.compiler.exceptions.UnknownControlFlowTargetException;\nimport org.apache.royale.compiler.internal.tree.as.LabeledStatementNode;\nimport org.apache.royale.compiler.internal.tree.as.SwitchNode;\nimport org.apache.royale.compiler.tree.as.IASNode;\nimport org.apache.royale.compiler.tree.as.ICatchNode;\nimport org.apache.royale.compiler.tree.as.ITryNode;\nimport static org.apache.royale.abc.ABCConstants.*;\n/**\n *  The ControlFlowContextManager is the code generator's\n *  keeper of active control-flow contexts and the associated\n *  (implicit in the configuration of contexts) model of the scope stack.\n *\n *  Control-flow contexts come in several varieties:\n *  <ul>\n *  <li>  Ordinary control-flow contexts, established by a \n *        labeled statement or a statement with break/continue semantics.\n *  <li>  Exception-handling contexts, established by try \n *        with a catch or finally.\n *  <li>  With statements.\n *  </ul>\n *\n *  These various types of context have few common elements, aside\n *  from participating in the model of control flow and the scope\n *  stack, so this class manages the active configuration of contexts\n *  and embodies the code generator's control-flow and scope stack model.\n */\npublic class ControlFlowContextManager\n{\n    /**\n     *  The LexicalScope that established this \n     *  ControlFlowContextManager.\n     *  Used to allocate temporary storage,\n     *  report problems, etc.\n     */\n    final LexicalScope currentScope;\n    /**\n     * Base class for all control flow context search criteria\n     * classes.\n     * All subclass are anonymous classes.\n     */\n    static abstract class ControlFlowContextSearchCriteria\n    {\n        /**\n         * Determines if this search criteria matches the specified\n         * {@link ControlFlowContext}.\n         * \n         * @param c {@link ControlFlowContext} to check.\n         * @return true if this search criteria matches the specified\n         * {@link ControlFlowContext}, false otherwise.\n         */\n        abstract boolean match(ControlFlowContext c);\n        /**\n         * Gets the {@link Label} in the specified {@link ControlFlowContext}\n         * that should be jumped to when this criteria matches the specified\n         * {@link ControlFlowContext}.\n         * \n         * @param c {@link ControlFlowContext} containing a label that should be\n         * jumped to.\n         * @return The {@link Label} that should be jumped to.\n         */\n        abstract Label getLabel(ControlFlowContext c);\n        /**\n         * Determines whether the control flow context is search from the inner\n         * most control flow context to the outer most or vice versa, when\n         * searching for a control flow context that matches this search\n         * criteria.\n         * \n         * @return true if the control flow context stack should be search from\n         * inner most to outer most, false if the stack should be search outer\n         * most to inner most.\n         */\n        abstract boolean innerToOuter();\n    }\n    /**\n     *  Search criterion which finds all active contexts.\n     */\n    public static final ControlFlowContextSearchCriteria FIND_ALL_CONTEXTS =\n        new ControlFlowContextSearchCriteria()\n    {\n        @Override\n        boolean match(ControlFlowContext c)\n        {\n            return true;\n        }\n        @Override\n        Label getLabel(ControlFlowContext c)\n        {\n            return null;\n        }\n        @Override\n        boolean innerToOuter()\n        {\n            return false;\n        }\n    };\n    /**\n     * A {@link ControlFlowContextSearchCriteria} which finds the first enclosing\n     * context that can be targetted with a break with no label.\n     */\n    static ControlFlowContextSearchCriteria breakWithOutLabelCriteria =\n        new ControlFlowContextSearchCriteria()\n    {\n        @Override\n        boolean match(ControlFlowContext c)\n        {\n            return c.hasDefaultBreakLabel();\n        }\n        @Override\n        Label getLabel(ControlFlowContext c)\n        {\n            assert match(c);\n            return c.getBreakLabel();\n        }\n        @Override\n        boolean innerToOuter()\n        {\n            return true;\n        }\n    };\n    /**\n     * A {@link ControlFlowContextSearchCriteria} which finds the first\n     * enclosing context that can be targetted with a continue with no label.\n     */\n    static ControlFlowContextSearchCriteria continueWithOutLabelCriteria =\n        new ControlFlowContextSearchCriteria()\n    {\n        @Override\n        boolean match(ControlFlowContext c)\n        {\n            return c.hasDefaultContinueLabel();\n        }\n        @Override\n        Label getLabel(ControlFlowContext c)\n        {\n            assert match(c);\n            return c.getContinueLabel();\n        }\n<fim_suffix>        @Override\n        boolean innerToOuter()\n        {\n            return true;\n        } \n    };\n    /**\n     * Creates a {@link ControlFlowContextSearchCriteria} which finds the first\n     * enclosing context that contains a labeled statement with the specified\n     * label and whose\n     * {@link ControlFlowContextSearchCriteria#getLabel(ControlFlowContext)}\n     * will return the break label for the found context.\n     * \n     * @param label Name of the label to find.\n     * @return A {@link ControlFlowContextSearchCriteria} which finds the first\n     * enclosing context that contains a labeled statement with the specified\n     * label and whose\n     * {@link ControlFlowContextSearchCriteria#getLabel(ControlFlowContext)}\n     * will return the break label for the found context.\n     */\n    ControlFlowContextSearchCriteria breakWithLabelCriteria(final String label)\n    {\n        return new ControlFlowContextSearchCriteria()\n        {\n            @Override\n            boolean match(ControlFlowContext c)\n            {\n                return c.hasBreakLabel(label);\n            }\n            @Override\n            Label getLabel(ControlFlowContext c)\n            {\n                assert match(c);\n                return c.getBreakLabel();\n            }\n            @Override\n            boolean innerToOuter()\n            {\n                return false;\n            } \n        };\n    }\n    /**\n     * Creates a {@link ControlFlowContextSearchCriteria} which finds the first\n     * enclosing context that contains a labeled loop statement with the\n     * specified label and whose\n     * {@link ControlFlowContextSearchCriteria#getLabel(ControlFlowContext)}\n     * will return the continue label for the found context.\n     * \n     * @param label Name of the label to find.\n     * @return A {@link ControlFlowContextSearchCriteria} which finds the first\n     * enclosing context that contains a labeled loop statement with the\n     * specified label and whose\n     * {@link ControlFlowContextSearchCriteria#getLabel(ControlFlowContext)}\n     * will return the continue label for the found context.\n     */\n    ControlFlowContextSearchCriteria continueWithLabelCriteria(final String label)\n    {\n        return new ControlFlowContextSearchCriteria()\n        {\n            @Override\n            boolean match(ControlFlowContext c)\n            {\n                return c.hasContinueLabel(label);\n            }\n            @Override\n            Label getLabel(ControlFlowContext c)\n            {\n                assert match(c);\n                return c.getContinueLabel();\n            }\n            @Override\n            boolean innerToOuter()\n            {\n                return false;\n            } \n        };\n    }\n    /**\n     * Creates a {@link ControlFlowContextSearchCriteria} which finds the first\n     * enclosing context that contains a labeled statement with the specified\n     * label and whose\n     * {@link ControlFlowContextSearchCriteria#getLabel(ControlFlowContext)}\n     * will return the goto label for the found context.\n     * \n     * @param label Name of the label to find.\n     * @return A {@link ControlFlowContextSearchCriteria} which finds the first\n     * enclosing context that contains a labeled statement with the specified\n     * label and whose\n     * {@link ControlFlowContextSearchCriteria#getLabel(ControlFlowContext)}\n     * will return the goto label for the found context.\n     */\n    ControlFlowContextSearchCriteria gotoLabelCriteria(final String label, final boolean allowDuplicates)\n    {\n        return new ControlFlowContextSearchCriteria()\n        {\n            @Override\n            boolean match(ControlFlowContext c)\n            {<fim_middle>// function below has no smell\n"}