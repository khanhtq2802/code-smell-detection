{"text": "<fim_prefix> *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage android.text;\nimport android.util.Log;\nimport android.util.Printer;\nimport com.android.internal.util.ArrayUtils;\nimport libcore.icu.ICU;\nimport java.lang.reflect.Array;\nimport java.util.Iterator;\nimport java.util.Locale;\nimport java.util.regex.Pattern;\npublic class TextUtils {\n    private static final String TAG = \"TextUtils\";\n    private TextUtils() { /* cannot be instantiated */ }\n    public static void getChars(CharSequence s, int start, int end,\n                                char[] dest, int destoff) {\n        Class<? extends CharSequence> c = s.getClass();\n        if (c == String.class)\n            ((String) s).getChars(start, end, dest, destoff);\n        else if (c == StringBuffer.class)\n            ((StringBuffer) s).getChars(start, end, dest, destoff);\n        else if (c == StringBuilder.class)\n            ((StringBuilder) s).getChars(start, end, dest, destoff);\n        else if (s instanceof GetChars)\n            ((GetChars) s).getChars(start, end, dest, destoff);\n        else {\n            for (int i = start; i < end; i++)\n                dest[destoff++] = s.charAt(i);\n        }\n    }\n    public static int indexOf(CharSequence s, char ch) {\n        return indexOf(s, ch, 0);\n    }\n    public static int indexOf(CharSequence s, char ch, int start) {\n        Class<? extends CharSequence> c = s.getClass();\n        if (c == String.class)\n            return ((String) s).indexOf(ch, start);\n        return indexOf(s, ch, start, s.length());\n    }\n    public static int indexOf(CharSequence s, char ch, int start, int end) {\n        Class<? extends CharSequence> c = s.getClass();\n        if (s instanceof GetChars || c == StringBuffer.class ||\n            c == StringBuilder.class || c == String.class) {\n            final int INDEX_INCREMENT = 500;\n            char[] temp = obtain(INDEX_INCREMENT);\n            while (start < end) {\n                int segend = start + INDEX_INCREMENT;\n                if (segend > end)\n                    segend = end;\n                getChars(s, start, segend, temp, 0);\n                int count = segend - start;\n                for (int i = 0; i < count; i++) {\n                    if (temp[i] == ch) {\n                        recycle(temp);\n                        return i + start;\n                    }\n                }\n                start = segend;\n            }\n            recycle(temp);\n            return -1;\n        }\n        for (int i = start; i < end; i++)\n            if (s.charAt(i) == ch)\n                return i;\n        return -1;\n    }\n    public static int lastIndexOf(CharSequence s, char ch) {\n        return lastIndexOf(s, ch, s.length() - 1);\n    }\n    public static int lastIndexOf(CharSequence s, char ch, int last) {\n        Class<? extends CharSequence> c = s.getClass();\n        if (c == String.class)\n            return ((String) s).lastIndexOf(ch, last);\n        return lastIndexOf(s, ch, 0, last);\n    }\n    public static int lastIndexOf(CharSequence s, char ch,\n                                  int start, int last) {\n        if (last < 0)\n            return -1;\n        if (last >= s.length())\n            last = s.length() - 1;\n        int end = last + 1;\n        Class<? extends CharSequence> c = s.getClass();\n        if (s instanceof GetChars || c == StringBuffer.class ||\n            c == StringBuilder.class || c == String.class) {\n            final int INDEX_INCREMENT = 500;\n            char[] temp = obtain(INDEX_INCREMENT);\n            while (start < end) {\n                int segstart = end - INDEX_INCREMENT;\n                if (segstart < start)\n                    segstart = start;\n                getChars(s, segstart, end, temp, 0);\n                int count = end - segstart;\n                for (int i = count - 1; i >= 0; i--) {\n                    if (temp[i] == ch) {\n                        recycle(temp);\n                        return i + segstart;\n                    }\n                }\n                end = segstart;\n            }\n            recycle(temp);\n            return -1;\n        }\n        for (int i = end - 1; i >= start; i--)\n            if (s.charAt(i) == ch)\n                return i;\n        return -1;\n    }\n    public static int indexOf(CharSequence s, CharSequence needle) {\n        return indexOf(s, needle, 0, s.length());\n    }\n    public static int indexOf(CharSequence s, CharSequence needle, int start) {\n        return indexOf(s, needle, start, s.length());\n    }\n    public static int indexOf(CharSequence s, CharSequence needle,\n                              int start, int end) {\n        int nlen = needle.length();\n        if (nlen == 0)\n            return start;\n        char c = needle.charAt(0);\n        for (;;) {\n            start = indexOf(s, c, start);\n            if (start > end - nlen) {\n                break;\n            }\n            if (start < 0) {\n                return -1;\n            }\n            if (regionMatches(s, start, needle, 0, nlen)) {\n                return start;\n            }\n            start++;\n        }\n        return -1;\n    }\n    public static boolean regionMatches(CharSequence one, int toffset,\n                                        CharSequence two, int ooffset,\n                                        int len) {\n        char[] temp = obtain(2 * len);\n        getChars(one, toffset, toffset + len, temp, 0);\n        getChars(two, ooffset, ooffset + len, temp, len);\n        boolean match = true;\n        for (int i = 0; i < len; i++) {\n            if (temp[i] != temp[i + len]) {\n                match = false;\n                break;\n            }\n        }\n        recycle(temp);\n        return match;\n    }\n    /**\n     * Create a new String object containing the given range of characters\n     * from the source string.  This is different than simply calling\n     * {@link CharSequence#subSequence(int, int) CharSequence.subSequence}\n     * in that it does not preserve any style runs in the source sequence,\n     * allowing a more efficient implementation.\n     */\n    public static String substring(CharSequence source, int start, int end) {\n        if (source instanceof String)\n            return ((String) source).substring(start, end);\n        if (source instanceof StringBuilder)\n            return ((StringBuilder) source).substring(start, end);\n        if (source instanceof StringBuffer)\n            return ((StringBuffer) source).substring(start, end);\n        char[] temp = obtain(end - start);\n        getChars(source, start, end, temp, 0);\n        String ret = new String(temp, 0, end - start);\n        recycle(temp);\n        return ret;\n    }\n    /**\n     * Returns list of multiple {@link CharSequence} joined into a single\n     * {@link CharSequence} separated by localized delimiter such as \", \".\n     *\n     * @hide\n     */\n    public static CharSequence join(Iterable<CharSequence> list) {\n        // final CharSequence delimiter = Resources.getSystem().getText(R.string.list_delimeter);\n        CharSequence delimiter = \",\";\n        return join(delimiter, list);\n    }\n    /**\n     * Returns a string containing the tokens joined by delimiters.\n     * @param tokens an array objects to be joined. Strings will be formed from\n     *     the objects by calling object.toString().\n     */\n    public static String join(CharSequence delimiter, Object[] tokens) {\n        StringBuilder sb = new StringBuilder();\n        boolean firstTime = true;\n        for (Object token: tokens) {\n            if (firstTime) {\n                firstTime = false;\n            } else {\n                sb.append(delimiter);\n            }\n            sb.append(token);\n        }\n        return sb.toString();\n    }\n    /**\n     * Returns a string containing the tokens joined by delimiters.\n     * @param tokens an array objects to be joined. Strings will be formed from\n     *     the objects by calling object.toString().\n     */\n<fim_suffix>    public static String join(CharSequence delimiter, Iterable tokens) {\n        StringBuilder sb = new StringBuilder();\n        boolean firstTime = true;\n        for (Object token: tokens) {\n            if (firstTime) {\n                firstTime = false;\n            } else {\n                sb.append(delimiter);\n            }\n            sb.append(token);\n        }\n        return sb.toString();\n    }<fim_middle>// function below has no smell\n"}