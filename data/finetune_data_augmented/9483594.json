{"text": "<fim_prefix>  private ValueIterable iterable = new ValueIterable();\n  private boolean isMarked = false;\n  private BackupStore<KEYIN,VALUEIN> backupStore;\n  private final SerializationFactory serializationFactory;\n  private final Class<KEYIN> keyClass;\n  private final Class<VALUEIN> valueClass;\n  private final Configuration conf;\n  private final TaskAttemptID taskid;\n  private int currentKeyLength = -1;\n  private int currentValueLength = -1;\n  public ReduceContextImpl(Configuration conf, TaskAttemptID taskid,\n                           RawKeyValueIterator input, \n                           Counter inputKeyCounter,\n                           Counter inputValueCounter,\n                           RecordWriter<KEYOUT,VALUEOUT> output,\n                           OutputCommitter committer,\n                           StatusReporter reporter,\n                           RawComparator<KEYIN> comparator,\n                           Class<KEYIN> keyClass,\n                           Class<VALUEIN> valueClass\n                          ) throws InterruptedException, IOException{\n    super(conf, taskid, output, committer, reporter);\n    this.input = input;\n    this.inputKeyCounter = inputKeyCounter;\n    this.inputValueCounter = inputValueCounter;\n    this.comparator = comparator;\n    this.serializationFactory = new SerializationFactory(conf);\n    this.keyDeserializer = serializationFactory.getDeserializer(keyClass);\n    this.keyDeserializer.open(buffer);\n    this.valueDeserializer = serializationFactory.getDeserializer(valueClass);\n    this.valueDeserializer.open(buffer);\n    hasMore = input.next();\n    this.keyClass = keyClass;\n    this.valueClass = valueClass;\n    this.conf = conf;\n    this.taskid = taskid;\n  }\n  /** Start processing next unique key. */\n  public boolean nextKey() throws IOException,InterruptedException {\n    while (hasMore && nextKeyIsSame) {\n      nextKeyValue();\n    }\n    if (hasMore) {\n      if (inputKeyCounter != null) {\n        inputKeyCounter.increment(1);\n      }\n      return nextKeyValue();\n    } else {\n      return false;\n    }\n  }\n  /**\n   * Advance to the next key/value pair.\n   */\n  @Override\n  public boolean nextKeyValue() throws IOException, InterruptedException {\n    if (!hasMore) {\n      key = null;\n      value = null;\n      return false;\n    }\n    firstValue = !nextKeyIsSame;\n    DataInputBuffer nextKey = input.getKey();\n    currentRawKey.set(nextKey.getData(), nextKey.getPosition(), \n                      nextKey.getLength() - nextKey.getPosition());\n    buffer.reset(currentRawKey.getBytes(), 0, currentRawKey.getLength());\n    key = keyDeserializer.deserialize(key);\n    DataInputBuffer nextVal = input.getValue();\n    buffer.reset(nextVal.getData(), nextVal.getPosition(), nextVal.getLength()\n        - nextVal.getPosition());\n    value = valueDeserializer.deserialize(value);\n    currentKeyLength = nextKey.getLength() - nextKey.getPosition();\n    currentValueLength = nextVal.getLength() - nextVal.getPosition();\n    if (isMarked) {\n      backupStore.write(nextKey, nextVal);\n    }\n    hasMore = input.next();\n    if (hasMore) {\n      nextKey = input.getKey();\n      nextKeyIsSame = comparator.compare(currentRawKey.getBytes(), 0, \n                                     currentRawKey.getLength(),\n                                     nextKey.getData(),\n                                     nextKey.getPosition(),\n                                     nextKey.getLength() - nextKey.getPosition()\n                                         ) == 0;\n    } else {\n      nextKeyIsSame = false;\n    }\n    inputValueCounter.increment(1);\n    return true;\n  }\n  public KEYIN getCurrentKey() {\n    return key;\n  }\n  @Override\n  public VALUEIN getCurrentValue() {\n    return value;\n  }\n  BackupStore<KEYIN,VALUEIN> getBackupStore() {\n    return backupStore;\n  }\n  protected class ValueIterator implements ReduceContext.ValueIterator<VALUEIN> {\n    private boolean inReset = false;\n    private boolean clearMarkFlag = false;\n    @Override\n    public boolean hasNext() {\n      try {\n        if (inReset && backupStore.hasNext()) {\n          return true;\n        } \n      } catch (Exception e) {\n        e.printStackTrace();\n        throw new RuntimeException(\"hasNext failed\", e);\n      }\n      return firstValue || nextKeyIsSame;\n    }\n    @Override\n    public VALUEIN next() {\n      if (inReset) {\n        try {\n          if (backupStore.hasNext()) {\n            backupStore.next();\n            DataInputBuffer next = backupStore.nextValue();\n            buffer.reset(next.getData(), next.getPosition(), next.getLength()\n                - next.getPosition());\n            value = valueDeserializer.deserialize(value);\n            return value;\n          } else {\n            inReset = false;\n            backupStore.exitResetMode();\n            if (clearMarkFlag) {\n              clearMarkFlag = false;\n              isMarked = false;\n            }\n          }\n        } catch (IOException e) {\n          e.printStackTrace();\n          throw new RuntimeException(\"next value iterator failed\", e);\n        }\n      } \n      // if this is the first record, we don't need to advance\n      if (firstValue) {\n        firstValue = false;\n        return value;\n      }\n      // if this isn't the first record and the next key is different, they\n      // can't advance it here.\n      if (!nextKeyIsSame) {\n        throw new NoSuchElementException(\"iterate past last value\");\n      }\n      // otherwise, go to the next key/value pair\n      try {\n        nextKeyValue();\n        return value;\n      } catch (IOException ie) {\n        throw new RuntimeException(\"next value iterator failed\", ie);\n      } catch (InterruptedException ie) {\n        // this is bad, but we can't modify the exception list of java.util\n        throw new RuntimeException(\"next value iterator interrupted\", ie);        \n      }\n    }\n    @Override\n    public void remove() {\n      throw new UnsupportedOperationException(\"remove not implemented\");\n    }\n    @Override\n    public void mark() throws IOException {\n      if (getBackupStore() == null) {\n        backupStore = new BackupStore<KEYIN,VALUEIN>(conf, taskid);\n      }\n      isMarked = true;\n      if (!inReset) {\n        backupStore.reinitialize();\n        if (currentKeyLength == -1) {\n          // The user has not called next() for this iterator yet, so\n          // there is no current record to mark and copy to backup store.\n          return;\n        }\n        assert (currentValueLength != -1);\n        int requestedSize = currentKeyLength + currentValueLength + \n          WritableUtils.getVIntSize(currentKeyLength) +\n          WritableUtils.getVIntSize(currentValueLength);\n        DataOutputStream out = backupStore.getOutputStream(requestedSize);\n        writeFirstKeyValueBytes(out);\n        backupStore.updateCounters(requestedSize);\n      } else {\n        backupStore.mark();\n      }\n    }\n    @Override\n    public void reset() throws IOException {\n      // We reached the end of an iteration and user calls a \n      // reset, but a clearMark was called before, just throw\n      // an exception\n      if (clearMarkFlag) {\n        clearMarkFlag = false;\n        backupStore.clearMark();\n        throw new IOException(\"Reset called without a previous mark\");\n      }\n      if (!isMarked) {\n        throw new IOException(\"Reset called without a previous mark\");\n      }\n      inReset = true;\n      backupStore.reset();\n    }\n    @Override\n    public void clearMark() throws IOException {\n      if (getBackupStore() == null) {\n        return;\n      }\n      if (inReset) {\n        clearMarkFlag = true;\n        backupStore.clearMark();\n      } else {\n        inReset = isMarked = false;\n        backupStore.reinitialize();\n      }\n    }\n    /**\n     * This method is called when the reducer moves from one key to \n     * another.\n     * @throws IOException\n     */\n    public void resetBackupStore() throws IOException {\n      if (getBackupStore() == null) {\n        return;\n      }\n      inReset = isMarked = false;\n      backupStore.reinitialize();\n      currentKeyLength = -1;\n    }\n    /**\n     * This method is called to write the record that was most recently\n     * served (before a call to the mark). Since the framework reads one\n     * record in advance, to get this record, we serialize the current key\n     * and value\n     * @param out\n     * @throws IOException\n     */\n    private void writeFirstKeyValueBytes(DataOutputStream out) \n    throws IOException {\n      assert (getCurrentKey() != null && getCurrentValue() != null);\n      WritableUtils.writeVInt(out, currentKeyLength);\n      WritableUtils.writeVInt(out, currentValueLength);\n      Serializer<KEYIN> keySerializer = \n        serializationFactory.getSerializer(keyClass);\n      keySerializer.open(out);\n      keySerializer.serialize(getCurrentKey());\n      Serializer<VALUEIN> valueSerializer = \n        serializationFactory.getSerializer(valueClass);\n      valueSerializer.open(out);\n      valueSerializer.serialize(getCurrentValue());\n    }\n  }\n<fim_suffix>  protected class ValueIterable implements Iterable<VALUEIN> {\n    private ValueIterator iterator = new ValueIterator();\n    @Override\n    public Iterator<VALUEIN> iterator() {\n      return iterator;\n    } \n  }<fim_middle>// class below is data class\n"}