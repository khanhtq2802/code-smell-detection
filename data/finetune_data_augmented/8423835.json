{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.crypto;\n\nimport java.security.KeyStore;\nimport java.security.PrivateKey;\nimport java.security.PublicKey;\nimport java.security.SecureRandom;\nimport java.security.cert.Certificate;\n\nimport org.apache.camel.Consumer;\nimport org.apache.camel.Processor;\nimport org.apache.camel.Producer;\nimport org.apache.camel.component.crypto.processor.SigningProcessor;\nimport org.apache.camel.component.crypto.processor.VerifyingProcessor;\nimport org.apache.camel.spi.UriEndpoint;\nimport org.apache.camel.spi.UriParam;\nimport org.apache.camel.support.DefaultEndpoint;\n\n/**\n * The crypto component is used for signing and verifying exchanges using the Signature Service of the Java Cryptographic Extension (JCE).\n */\n@UriEndpoint(firstVersion = \"2.3.0\", scheme = \"crypto\", title = \"Crypto (JCE)\", syntax = \"crypto:cryptoOperation:name\", producerOnly = true, label = \"security,transformation\")\npublic class DigitalSignatureEndpoint extends DefaultEndpoint {\n    @UriParam\n    private DigitalSignatureConfiguration configuration;\n\n    public DigitalSignatureEndpoint(String uri, DigitalSignatureComponent component, DigitalSignatureConfiguration configuration) {\n        super(uri, component);\n        this.configuration = configuration;\n    }\n\n    public Producer createProducer() throws Exception {\n        if (CryptoOperation.sign == configuration.getCryptoOperation()) {\n            return new DigitalSignatureProducer(this, new SigningProcessor(configuration));\n        } else {\n            return new DigitalSignatureProducer(this, new VerifyingProcessor(configuration));\n        }\n    }\n\n    public Consumer createConsumer(Processor processor) throws Exception {\n        throw new UnsupportedOperationException(\"Digital Signatures endpoints are not meant to be consumed from. They are meant be used as an intermediate endpoints\");\n    }\n\n    public boolean isSingleton() {\n        return true;\n    }\n\n    /**\n     * Sets the configuration to use\n     */\n    public void setConfiguration(DigitalSignatureConfiguration configuration) {\n        this.configuration = configuration;\n    }\n\n    public DigitalSignatureConfiguration getConfiguration() {\n        return configuration;\n    }\n\n    public PublicKey getPublicKey() throws Exception {\n        return getConfiguration().getPublicKey();\n    }\n\n    public void setPublicKey(PublicKey publicKey) {\n        getConfiguration().setPublicKey(publicKey);\n    }\n\n    public void setPublicKey(String publicKeyName) {\n        getConfiguration().setPublicKeyName(publicKeyName);\n    }\n\n<fim_suffix>    public Certificate getCertificate() throws Exception {\n        return getConfiguration().getCertificate();\n    }\n\n    public PrivateKey getPrivateKey() throws Exception {\n        return getConfiguration().getPrivateKey();\n    }\n\n    public void setPrivateKey(PrivateKey privateKey) {\n        getConfiguration().setPrivateKey(privateKey);\n    }\n\n    public KeyStore getKeystore() {\n        return getConfiguration().getKeystore();\n    }\n\n    public void setKeystore(KeyStore keystore) {\n        getConfiguration().setKeystore(keystore);\n    }\n\n    public char[] getPassword() {\n        return getConfiguration().getPassword();\n    }\n\n    public void setKeyPassword(char[] keyPassword) {\n        getConfiguration().setPassword(keyPassword);\n    }\n\n    public SecureRandom getSecureRandom() {\n        return getConfiguration().getSecureRandom();\n    }\n\n    public void setSecureRandom(SecureRandom secureRandom) {\n        getConfiguration().setSecureRandom(secureRandom);\n    }\n\n    public String getAlgorithm() {\n        return getConfiguration().getAlgorithm();\n    }\n\n    public void setAlgorithm(String algorithm) {\n        getConfiguration().setAlgorithm(algorithm);\n    }\n\n    public Integer getBuffersize() {\n        return getConfiguration().getBufferSize();\n    }\n\n    public void setBuffersize(Integer buffersize) {\n        getConfiguration().setBufferSize(buffersize);\n    }\n\n    public String getProvider() {\n        return getConfiguration().getProvider();\n    }\n\n    public void setProvider(String provider) {\n        getConfiguration().setProvider(provider);\n    }\n\n    public String getSignatureHeader() {\n        return getConfiguration().getSignatureHeaderName();\n    }\n\n    public void setSignatureHeader(String signatureHeaderName) {\n        getConfiguration().setSignatureHeaderName(signatureHeaderName);\n    }\n\n    public String getAlias() {\n        return getConfiguration().getAlias();\n    }\n\n    public void setAlias(String alias) {\n        getConfiguration().setAlias(alias);\n    }\n\n    public boolean isClearHeaders() {\n        return getConfiguration().isClearHeaders();\n    }\n\n    public void setClearHeaders(boolean clearHeaders) {\n        getConfiguration().setClearHeaders(clearHeaders);\n    }\n}<fim_middle>// function below has no smell\n"}