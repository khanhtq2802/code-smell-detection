{"text": "<fim_prefix>        else\n          capabilities[0].setOutputs(newIOs);\n      }\n    }\n    return bRes;\n  }\n  // returns true if no type priorities were modified, false otherwise\n  public boolean validateTypePriorities(Map typeNameHash) {\n    boolean bRes = true;\n    TypePriorities priorities = aeDescription.getAnalysisEngineMetaData().getTypePriorities();\n    if (priorities != null) {\n      TypePriorityList[] priorityLists = priorities.getPriorityLists();\n      if (priorityLists != null) {\n        for (int i = 0; i < priorityLists.length; i++) {\n          String[] typeNames = priorityLists[i].getTypes();\n          if (typeNames != null) {\n            int nCountNewTypeNames = 0;\n            for (int j = 0; j < typeNames.length; j++) {\n              if (typeNameHash.containsKey(typeNames[j])) {\n                nCountNewTypeNames++;\n              }\n            }\n            if (nCountNewTypeNames < typeNames.length) {\n              bRes = false;\n              String[] newTypeNames = new String[nCountNewTypeNames];\n              for (int j = 0, k = 0; j < typeNames.length; j++) {\n                if (typeNameHash.containsKey(typeNames[j])) {\n                  newTypeNames[k++] = typeNames[j];\n                }\n              }\n              priorityLists[i].setTypes(newTypeNames);\n            }\n          }\n        }\n      }\n    }\n    return bRes;\n  }\n  private static final int previewSize = 1024 * 16;\n  /**\n   * Used by code to get lists of delegate components by input/output type specs.\n   */\n  public static ResourceSpecifier getDelegateResourceSpecifier(IFile iFile,\n          String[] componentHeaders) {\n    if (!iFile.getName().toLowerCase().endsWith(\".xml\")) { //$NON-NLS-1$\n      return null;\n    }\n    // make a quick assesment of whether file is a TAE\n    // looking in the first part of the file, but 1024 isn't big enough\n    // because initial comment blocks like the apache license are that big\n    // Do 16 K\n    char[] acBuffer = new char[previewSize];\n    FileReader fileReader = null;\n    int nCharsRead = 0;\n    try {\n      // FileReader is FileInputStream using \"default\" char-encoding\n      fileReader = new FileReader(iFile.getLocation().toString());\n      while (true) {\n        int tempCharsRead = fileReader.read(acBuffer, nCharsRead, previewSize - nCharsRead);\n        if (-1 == tempCharsRead)\n          break;\n        nCharsRead = nCharsRead + tempCharsRead;\n        if (nCharsRead >= previewSize)\n          break;\n      }\n    } catch (FileNotFoundException e) {\n      return null;\n    } catch (IOException e) {\n      return null;\n    } finally {\n      if (null != fileReader)\n        try {\n          fileReader.close();\n        } catch (IOException e1) {\n        }\n    }\n    if (-1 == nCharsRead)\n      return null;\n    String sBuffer = (new String(acBuffer, 0, nCharsRead)).toLowerCase();\n    for (int i = 0; i < componentHeaders.length; i++) {\n      if (-1 != sBuffer.indexOf(componentHeaders[i]))\n        break;\n      if (i == (componentHeaders.length - 1))\n        return null;\n    }\n    try {\n      XMLInputSource input = new XMLInputSource(iFile.getLocation().toFile());\n      XMLizable inputDescription = AbstractSection.parseDescriptor(input);\n      if (inputDescription instanceof AnalysisEngineDescription\n              || inputDescription instanceof CasConsumerDescription\n              || inputDescription instanceof FlowControllerDescription)\n        return (ResourceCreationSpecifier) inputDescription;\n      else if (inputDescription instanceof ResourceServiceSpecifier)\n        return (ResourceSpecifier) inputDescription;\n      return null;\n    } catch (IOException e) {\n      return null;\n    } catch (InvalidXMLException e) {\n      return null;\n    }\n  }\n  // **************************************************\n  // * Getting exception messages down to root\n  // **************************************************\n  public String getMessagesToRootCause(Throwable e) {\n    boolean wantStackTrace = false;\n    StringBuffer b = new StringBuffer(200);\n    String messagePart = e.getMessage();\n    // messages for noClassDef found and NPE don't say what the problem was,\n    // so always include the exception class also\n    formatMessageWithClass(e, b, messagePart);\n    if (null == messagePart) {\n      wantStackTrace = true;\n    }\n//    if (null == messagePart) {\n//      b.append(e.getClass().getName());\n//      wantStackTrace = true;\n//    } else\n//      b.append(messagePart);\n    Throwable cur = e;\n    Throwable next;\n    while (null != (next = cur.getCause())) {\n      String message = next.getMessage();\n      wantStackTrace = false; // only do stack trace if last item has no message\n      if (null == message) {\n        b.append(next.getClass().getName());\n        wantStackTrace = true;\n      }\n      if (null != message && !message.equals(messagePart)) {\n        b.append(Messages.getString(\"MultiPageEditor.causedBy\"));\n        formatMessageWithClass(next, b, message);\n        messagePart = message;\n      }\n      cur = next;\n    }\n    if (wantStackTrace) {\n      ByteArrayOutputStream ba = new ByteArrayOutputStream();\n      PrintStream ps = new PrintStream(ba);\n      cur.printStackTrace(ps);\n      ps.flush();\n      b.append(ba.toString());\n      ps.close();\n    }\n    return b.toString();\n  }\n  private void formatMessageWithClass(Throwable e, StringBuffer b, String messagePart) {\n    String name = e.getClass().getName();\n    //because this is a message for ordinary users, and\n    // because the exceptions are more easily readable without their package prefixes,\n    //  remove the package prefix from the displayed name\n    int lastDot = name.lastIndexOf('.');\n    if (lastDot >= 0) {\n      name = name.substring(lastDot + 1);\n    }\n    b.append(name);\n    if (null != messagePart) {\n      b.append(\": \").append(messagePart);\n    }\n  }\n  public static class JCasGenProgressMonitor implements\n          org.apache.uima.tools.jcasgen.IProgressMonitor {\n    IProgressMonitor m_progressMonitor;\n    public JCasGenProgressMonitor(IProgressMonitor progressMonitor) {\n      m_progressMonitor = progressMonitor;\n    }\n    /*\n     * (non-Javadoc)\n     * \n     * @see org.apache.uima.jcas.jcasgen_gen.IProgressMonitor#done()\n     */\n    public void done() {\n      m_progressMonitor.done();\n    }\n    /*\n     * (non-Javadoc)\n     * \n     * @see org.apache.uima.jcas.jcasgen_gen.IProgressMonitor#beginTask(java.lang.String, int)\n     */\n    public void beginTask(String name, int totalWorked) {\n      m_progressMonitor.beginTask(name, totalWorked);\n    }\n    /*\n     * (non-Javadoc)\n     * \n     * @see org.apache.uima.jcas.jcasgen_gen.IProgressMonitor#subTask(java.lang.String)\n     */\n    public void subTask(String name) {\n      m_progressMonitor.subTask(name);\n    }\n    /*\n     * (non-Javadoc)\n     * \n     * @see org.apache.uima.jcas.jcasgen_gen.IProgressMonitor#worked(int)\n     */\n    public void worked(int work) {\n      m_progressMonitor.worked(work);\n    }\n  }\n<fim_suffix>  public static class JCasGenThrower implements IError {\n    private Level logLevels[] = { Level.INFO, Level.WARNING, Level.SEVERE };\n    private String m_message = null;\n    /*\n     * (non-Javadoc)\n     * \n     * @see org.apache.uima.jcas.jcasgen_gen.IError#newError(int, java.lang.String)\n     */\n    public void newError(int severity, String message, Exception ex) {\n      Logger log = UIMAFramework.getLogger();\n      log.log(logLevels[severity], \"JCasGen: \" + message); //$NON-NLS-1$\n      System.out.println(Messages.getString(\"MultiPageEditor.JCasGenErr\") //$NON-NLS-1$\n              + message);\n      if (null != ex)\n        ex.printStackTrace();\n      if (IError.WARN < severity) {\n        m_message = message;\n        throw new Jg.ErrorExit();\n      }\n    }\n    public String getMessage() {\n      return m_message;\n    }\n  }<fim_middle>// class below has no smell\n"}