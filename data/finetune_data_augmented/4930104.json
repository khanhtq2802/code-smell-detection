{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.joshua.decoder.ff.fragmentlm;\nimport java.io.IOException;\nimport java.io.PushbackReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport org.apache.joshua.corpus.Vocabulary;\n/**\n * Tools for displaying, reading, and modifying trees. Borrowed from the Berkeley Parser.\n * \n * @author Dan Klein\n */\npublic class Trees {\n  public static class PennTreeReader implements Iterator<Tree> {\n    public static final String ROOT_LABEL = \"ROOT\";\n    final PushbackReader in;\n    Tree nextTree;\n    public boolean hasNext() {\n      return (nextTree != null);\n    }\n    public Tree next() {\n      if (!hasNext())\n        throw new NoSuchElementException();\n      Tree tree = nextTree;\n      nextTree = readRootTree();\n      // System.out.println(nextTree);\n      return tree;\n    }\n    private Tree readRootTree() {\n      try {\n        readWhiteSpace();\n        if (!isLeftParen(peek()))\n          return null;\n        return readTree(true);\n      } catch (IOException e) {\n        throw new RuntimeException(\"Error reading tree.\");\n      }\n    }\n    private Tree readTree(boolean isRoot) throws IOException {\n      if (!isLeftParen(peek())) {\n        return readLeaf();\n      } else {\n        readLeftParen();\n        String label = readLabel();\n        if (label.length() == 0 && isRoot)\n          label = ROOT_LABEL;\n        List<Tree> children = readChildren();\n        readRightParen();\n        return new Tree(label, children);\n      }\n    }\n    private String readLabel() throws IOException {\n      readWhiteSpace();\n      return readText();\n    }\n    private String readText() throws IOException {\n      StringBuilder sb = new StringBuilder();\n      int ch = in.read();\n      while (!isWhiteSpace(ch) && !isLeftParen(ch) && !isRightParen(ch)) {\n        sb.append((char) ch);\n        ch = in.read();\n      }\n      in.unread(ch);\n      // System.out.println(\"Read text: [\"+sb+\"]\");\n      return sb.toString().intern();\n    }\n    private List<Tree> readChildren() throws IOException {\n      readWhiteSpace();\n      // if (!isLeftParen(peek()))\n      // return Collections.singletonList(readLeaf());\n      return readChildList();\n    }\n    private int peek() throws IOException {\n      int ch = in.read();\n      in.unread(ch);\n      return ch;\n    }\n    private Tree readLeaf() throws IOException {\n      String label = readText();\n      return new Tree(label);\n    }\n    private List<Tree> readChildList() throws IOException {\n      List<Tree> children = new ArrayList<>();\n      readWhiteSpace();\n      while (!isRightParen(peek())) {\n        children.add(readTree(false));\n        readWhiteSpace();\n      }\n      return children;\n    }\n    private void readLeftParen() throws IOException {\n      // System.out.println(\"Read left.\");\n      readWhiteSpace();\n      int ch = in.read();\n      if (!isLeftParen(ch))\n        throw new RuntimeException(\"Format error reading tree. (leftParen)\");\n    }\n    private void readRightParen() throws IOException {\n      // System.out.println(\"Read right.\");\n      readWhiteSpace();\n      int ch = in.read();\n      if (!isRightParen(ch)) {\n        System.out.println((char) ch);\n        throw new RuntimeException(\"Format error reading tree. (rightParen)\");\n      }\n    }\n    private void readWhiteSpace() throws IOException {\n      int ch = in.read();\n      while (isWhiteSpace(ch)) {\n        ch = in.read();\n      }\n      in.unread(ch);\n    }\n    private boolean isWhiteSpace(int ch) {\n      return (ch == ' ' || ch == '\\t' || ch == '\\f' || ch == '\\r' || ch == '\\n');\n    }\n    private boolean isLeftParen(int ch) {\n      return ch == '(';\n    }\n    private boolean isRightParen(int ch) {\n      return ch == ')';\n    }\n    public void remove() {\n      throw new UnsupportedOperationException();\n    }\n    public PennTreeReader(Reader in) {\n      this.in = new PushbackReader(in);\n      nextTree = readRootTree();\n      // System.out.println(nextTree);\n    }\n  }\n  /**\n   * Renderer for pretty-printing trees according to the Penn Treebank indenting guidelines\n   * (mutliline). Adapted from code originally written by Dan Klein and modified by Chris Manning.\n   */\n  public static class PennTreeRenderer {\n    /**\n     * Print the tree as done in Penn Treebank merged files. The formatting should be exactly the\n     * same, but we don't print the trailing whitespace found in Penn Treebank trees. The basic\n     * deviation from a bracketed indented tree is to in general collapse the printing of adjacent\n     * preterminals onto one line of tags and words. Additional complexities are that conjunctions\n     * (tag CC) are not collapsed in this way, and that the unlabeled outer brackets are collapsed\n     * onto the same line as the next bracket down.\n     * \n     * @param tree you wish to render and print\n     * @return a rendered String representation of the tree\n     */\n    public static  String render(Tree tree) {\n      StringBuilder sb = new StringBuilder();\n      renderTree(tree, 0, false, false, false, true, sb);\n      sb.append('\\n');\n      return sb.toString();\n    }\n    /**\n     * Display a node, implementing Penn Treebank style layout\n     */\n    private static  void renderTree(Tree tree, int indent, boolean parentLabelNull,\n        boolean firstSibling, boolean leftSiblingPreTerminal, boolean topLevel, StringBuilder sb) {\n      // the condition for staying on the same line in Penn Treebank\n      boolean suppressIndent = (parentLabelNull || (firstSibling && tree.isPreTerminal()) || (leftSiblingPreTerminal\n          && tree.isPreTerminal()));\n      if (suppressIndent) {\n        sb.append(' ');\n      } else {\n        if (!topLevel) {\n          sb.append('\\n');\n        }\n        for (int i = 0; i < indent; i++) {\n          sb.append(\"  \");\n        }\n      }\n      if (tree.isLeaf() || tree.isPreTerminal()) {\n        renderFlat(tree, sb);\n        return;\n      }\n      sb.append('(');\n      sb.append(tree.getLabel());\n      renderChildren(tree.getChildren(), indent + 1, false, sb);\n      sb.append(')');\n    }\n    private static  void renderFlat(Tree tree, StringBuilder sb) {\n      if (tree.isLeaf()) {\n        sb.append(Vocabulary.word(tree.getLabel()));\n        return;\n      }\n      sb.append('(');\n      sb.append(Vocabulary.word(tree.getLabel()));\n      sb.append(' ');\n      sb.append(Vocabulary.word(tree.getChildren().get(0).getLabel()));\n      sb.append(')');\n    }\n<fim_suffix>    private static void renderChildren(List<Tree> children, int indent,\n        boolean parentLabelNull, StringBuilder sb) {\n      boolean firstSibling = true;\n      boolean leftSibIsPreTerm = true; // counts as true at beginning\n      for (Tree child : children) {\n        renderTree(child, indent, parentLabelNull, firstSibling, leftSibIsPreTerm, false, sb);\n        leftSibIsPreTerm = child.isPreTerminal();\n        firstSibling = false;\n      }\n    }\n  }\n  public static void main(String[] args) {\n    String ptbTreeString = \"((S (NP (DT the) (JJ quick) (JJ brown) (NN fox)) (VP (VBD jumped) (PP (IN over) (NP (DT the) (JJ lazy) (NN dog)))) (. .)))\";\n    if (args.length > 0) {\n      String tree = \"\";\n      for (String str : args) {\n        tree += \" \" + str;\n      }\n      ptbTreeString = tree.substring(1);\n    }\n    PennTreeReader reader = new PennTreeReader(new StringReader(ptbTreeString));\n    Tree tree = reader.next();<fim_middle>// function below has no smell\n"}