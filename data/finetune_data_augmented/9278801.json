{"text": "<fim_prefix>/*\n * Copyright (c) 2001, 2008, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\npackage sun.font;\n\nimport java.nio.CharBuffer;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.*;\nimport sun.nio.cs.*;\n\npublic abstract class X11CNS11643 extends Charset {\n    private final int plane;\n    public X11CNS11643 (int plane, String name) {\n        super(name, null);\n        switch (plane) {\n        case 1:\n            this.plane = 0; // CS1\n            break;\n        case 2:\n        case 3:\n            this.plane = plane;\n            break;\n        default:\n            throw new IllegalArgumentException\n                (\"Only planes 1, 2, and 3 supported\");\n        }\n    }\n\n    public CharsetEncoder newEncoder() {\n        return new Encoder(this, plane);\n    }\n\n<fim_suffix>    public CharsetDecoder newDecoder() {\n        return new Decoder(this, plane);\n    }\n\n    public boolean contains(Charset cs) {\n        return cs instanceof X11CNS11643;\n    }\n\n    private class Encoder extends EUC_TW.Encoder {\n        private int plane;\n        public Encoder(Charset cs, int plane) {\n            super(cs);\n            this.plane = plane;\n        }\n\n        private byte[] bb = new byte[4];\n        public boolean canEncode(char c) {\n            if (c <= 0x7F) {\n                return false;\n            }\n            int nb = toEUC(c, bb);\n            if (nb == -1)\n                return false;\n            int p = 0;\n            if (nb == 4)\n                p = (bb[1] & 0xff) - 0xa0;\n            return (p == plane);\n        }\n\n        public boolean isLegalReplacement(byte[] repl) {\n            return true;\n        }\n\n        protected CoderResult encodeLoop(CharBuffer src, ByteBuffer dst) {\n            char[] sa = src.array();\n            int sp = src.arrayOffset() + src.position();\n            int sl = src.arrayOffset() + src.limit();\n            byte[] da = dst.array();\n            int dp = dst.arrayOffset() + dst.position();\n            int dl = dst.arrayOffset() + dst.limit();\n\n            try {\n                while (sp < sl) {\n                    char c = sa[sp];\n                    if ( c > '\\u007f'&& c < '\\uFFFE') {\n                        int nb = toEUC(c, bb);\n                        if (nb != -1) {\n                            int p = 0;\n                            if (nb == 4)\n                                p = (bb[1] & 0xff) - 0xa0;\n                            if (p == plane) {\n                                if (dl - dp < 2)\n                                    return CoderResult.OVERFLOW;\n                                if (nb == 2) {\n                                    da[dp++] = (byte)(bb[0] & 0x7f);\n                                    da[dp++] = (byte)(bb[1] & 0x7f);\n                                } else {\n                                    da[dp++] = (byte)(bb[2] & 0x7f);\n                                    da[dp++] = (byte)(bb[3] & 0x7f);\n                                }\n                                sp++;\n                                continue;\n                            }\n                        }\n                    }\n                    return CoderResult.unmappableForLength(1);\n                }\n                return CoderResult.UNDERFLOW;\n            } finally {\n                src.position(sp - src.arrayOffset());\n                dst.position(dp - dst.arrayOffset());\n            }\n        }\n    }\n\n    private class Decoder extends EUC_TW.Decoder {\n        int plane;\n        private String table;\n        protected Decoder(Charset cs, int plane) {\n            super(cs);\n            if (plane == 0)\n                this.plane = plane;\n            else if (plane == 2 || plane == 3)\n                this.plane = plane - 1;\n            else\n                throw new IllegalArgumentException\n                    (\"Only planes 1, 2, and 3 supported\");\n        }\n\n        //we only work on array backed buffer.\n        protected CoderResult decodeLoop(ByteBuffer src, CharBuffer dst) {\n            byte[] sa = src.array();\n            int sp = src.arrayOffset() + src.position();\n            int sl = src.arrayOffset() + src.limit();\n\n            char[] da = dst.array();\n            int dp = dst.arrayOffset() + dst.position();\n            int dl = dst.arrayOffset() + dst.limit();\n\n            try {\n                while (sp < sl) {\n                    if ( sl - sp < 2) {\n                        return CoderResult.UNDERFLOW;\n                    }\n                    int b1 = (sa[sp] & 0xff) | 0x80;\n                    int b2 = (sa[sp + 1] & 0xff) | 0x80;\n                    char[] cc = toUnicode(b1, b2, plane);\n                    // plane3 has non-bmp characters(added), x11cnsp3\n                    // however does not support them\n                    if (cc == null || cc.length == 2)\n                        return CoderResult.unmappableForLength(2);\n                    if (dl - dp < 1)\n                        return CoderResult.OVERFLOW;\n                    da[dp++] = cc[0];\n                    sp +=2;\n                }\n                return CoderResult.UNDERFLOW;\n            } finally {\n                src.position(sp - src.arrayOffset());\n                dst.position(dp - dst.arrayOffset());\n            }\n        }\n    }\n}<fim_middle>// function below has no smell\n"}