{"text": "<fim_prefix>/*\n * Copyright (c) 2014, 2018, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 3 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 3 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 3 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage com.oracle.truffle.r.runtime.conn;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.nio.channels.ByteChannel;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.HashMap;\nimport java.util.Set;\n\nimport com.oracle.truffle.api.CompilerDirectives.TruffleBoundary;\nimport com.oracle.truffle.r.runtime.RRuntime;\nimport com.oracle.truffle.r.runtime.conn.ConnectionSupport.AbstractOpenMode;\nimport com.oracle.truffle.r.runtime.conn.ConnectionSupport.BaseRConnection;\nimport com.oracle.truffle.r.runtime.conn.ConnectionSupport.ConnectionClass;\n\npublic class SocketConnections {\n    /**\n     * Base class for socket connections.\n     *\n     * While binary operations, e.g. {@code writeBin} are only legal on binary connections, text\n     * operations are legal on text and binary connections.\n     */\n    public static class RSocketConnection extends BaseRConnection {\n        protected final boolean server;\n        protected final String host;\n        protected final int port;\n        protected final int timeout;\n\n        public RSocketConnection(String modeString, boolean server, String host, int port, boolean blocking, int timeout, String encoding) throws IOException {\n            super(ConnectionClass.Socket, modeString, AbstractOpenMode.Read, blocking, encoding);\n            this.server = server;\n            this.host = host;\n            this.port = port;\n            this.timeout = timeout;\n            openNonLazyConnection();\n        }\n\n        @Override\n        public boolean canRead() {\n            // socket connections can always be read\n            return true;\n        }\n\n        @Override\n        public boolean canWrite() {\n            // socket connections can always be written\n            return true;\n        }\n\n        @Override\n        @TruffleBoundary\n        protected void createDelegateConnection() throws IOException {\n            DelegateRConnection delegate;\n            if (server) {\n                delegate = new RServerSocketConnection(this);\n            } else {\n                if (isBlocking()) {\n                    delegate = new RClientSocketConnection(this);\n                } else {\n                    delegate = new RClientSocketNonBlockConnection(this);\n                }\n            }\n            setDelegate(delegate);\n        }\n\n        @Override\n        public String getSummaryDescription() {\n            return (server ? \"<-\" : \"->\") + host + \":\" + port;\n        }\n\n        @TruffleBoundary\n        public static byte[] select(RSocketConnection[] socketConnections, boolean write, long timeout) throws IOException {\n            int op = write ? SelectionKey.OP_WRITE : SelectionKey.OP_READ;\n\n            HashMap<RSocketConnection, SelectionKey> table = new HashMap<>();\n            Selector selector = Selector.open();\n            for (RSocketConnection con : socketConnections) {\n                con.checkOpen();\n\n                SocketChannel sc = (SocketChannel) con.theConnection.getChannel();\n                sc.configureBlocking(false);\n                table.put(con, sc.register(selector, op));\n            }\n            int select;\n            if (timeout >= 0) {\n                select = selector.select(timeout);\n            } else {\n                select = selector.select();\n            }\n\n            byte[] result = new byte[socketConnections.length];\n            if (select > 0) {\n                Set<SelectionKey> selectedKeys = selector.selectedKeys();\n                for (int i = 0; i < result.length; i++) {\n                    result[i] = RRuntime.asLogical(selectedKeys.contains(table.get(socketConnections[i])));\n                }\n            }\n            return result;\n        }\n    }\n\n<fim_suffix>    private abstract static class RSocketReadWriteConnection extends DelegateReadWriteRConnection {\n        private Socket socket;\n        private SocketChannel channel;\n        protected final RSocketConnection thisBase;\n\n        protected RSocketReadWriteConnection(RSocketConnection base) {\n            super(base, 0);\n            this.thisBase = base;\n        }\n\n        protected void openStreams(SocketChannel socketArg) throws IOException {\n            channel = socketArg;\n            socket = socketArg.socket();\n            if (thisBase.isBlocking()) {\n                channel.configureBlocking(true);\n                // Java (int) timeouts do not meet the POSIX standard of 31 days\n                long millisTimeout = ((long) thisBase.timeout) * 1000;\n                if (millisTimeout > Integer.MAX_VALUE) {\n                    millisTimeout = Integer.MAX_VALUE;\n                }\n                socket.setSoTimeout((int) millisTimeout);\n            } else {\n                channel.configureBlocking(false);\n            }\n        }\n\n        @Override\n        public ByteChannel getChannel() {\n            return channel;\n        }\n\n        @Override\n        public boolean isSeekable() {\n            return false;\n        }\n    }\n\n    private abstract static class RSocketReadWriteNonBlockConnection extends DelegateReadWriteRConnection {\n        private Socket socket;\n        private SocketChannel socketChannel;\n\n        protected RSocketReadWriteNonBlockConnection(RSocketConnection base) {\n            super(base, 0);\n        }\n\n        protected void openStreams(Socket socketArg) throws IOException {\n            this.socket = socketArg;\n            this.socketChannel = socket.getChannel();\n            socketChannel.configureBlocking(false);\n        }\n\n        @Override\n        public void close() throws IOException {\n            socketChannel.close();\n            socket.close();\n        }\n\n        @Override\n        public ByteChannel getChannel() {\n            return socketChannel;\n        }\n\n        @Override\n        public boolean isSeekable() {\n            return false;\n        }\n    }\n\n    private static class RServerSocketConnection extends RSocketReadWriteConnection {\n        private final SocketChannel connectionSocket;\n\n        RServerSocketConnection(RSocketConnection base) throws IOException {\n            super(base);\n            InetSocketAddress addr = new InetSocketAddress(base.port);\n            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n\n            // we expect only one connection per-server socket; furthermore, we need to accommodate\n            // for multiple connections being established locally on the same server port;\n            // consequently, we close the server socket at the end of the constructor and allow\n            // address reuse to be able to open the next connection after the current one closes\n            serverSocketChannel.socket().setReuseAddress(true);\n            serverSocketChannel.socket().bind(addr);\n            connectionSocket = serverSocketChannel.accept();\n            openStreams(connectionSocket);\n            serverSocketChannel.close();\n        }\n\n        @Override\n        public void close() throws IOException {\n            super.close();\n            connectionSocket.close();\n        }\n\n        @Override\n        public ByteChannel getChannel() {\n            return connectionSocket;\n        }\n\n    }\n\n    private static class RClientSocketConnection extends RSocketReadWriteConnection {\n\n        RClientSocketConnection(RSocketConnection base) throws IOException {\n            super(base);\n            SocketChannel socketChannel = SocketChannel.open(new InetSocketAddress(base.host, base.port));\n            openStreams(socketChannel);\n        }\n    }\n\n    private static class RClientSocketNonBlockConnection extends RSocketReadWriteNonBlockConnection {\n\n        RClientSocketNonBlockConnection(RSocketConnection base) throws IOException {\n            super(base);\n            SocketChannel socketChannel = SocketChannel.open(new InetSocketAddress(base.host, base.port));\n            openStreams(socketChannel.socket());\n        }\n    }\n}<fim_middle>// class below has no smell\n"}