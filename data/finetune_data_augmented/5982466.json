{"text": "<fim_prefix>            @Override\n            public ValueExpressionColumn createColumnExpression(final String aColumnName) {\n                //if (statementTypeOnly) {return null;}\n                ValueExpressionColumn colExpr = super.createColumnExpression(aColumnName);\n                colExpr.setName(convertSQLIdentifierToCatalogFormat(aColumnName, getDelimitedIdentifierQuote()));\n                return colExpr;\n            }\n        });\n        return manager;\n    }\n    SQLException wrapIntoSqlException(final Exception e) {\n        SQLException ex;\n        if (e instanceof SQLException) {\n            ex = (SQLException) e;\n        } else {\n            ex = new SQLException(e.getLocalizedMessage());\n            ex.initCause(e);\n        }\n        return ex;\n    }\n    static String convertSQLIdentifierToCatalogFormat(final String sqlIdentifier, final char idDelimiterQuote) {\n        String catalogIdentifier = sqlIdentifier;\n        if (sqlIdentifier != null) {\n            String delimiter = String.valueOf(idDelimiterQuote);\n            boolean isDelimited = sqlIdentifier.startsWith(delimiter) && sqlIdentifier.endsWith(delimiter);\n            boolean containsQuotedDelimiters = sqlIdentifier.indexOf(delimiter + delimiter) > -1;\n            if (isDelimited) {\n                catalogIdentifier = sqlIdentifier.substring(1, sqlIdentifier.length() - 1);\n                if (containsQuotedDelimiters) {\n                    catalogIdentifier = catalogIdentifier.replaceAll(delimiter + delimiter, delimiter);\n                }\n            } else {\n                catalogIdentifier = sqlIdentifier;\n            }\n        }\n        return catalogIdentifier;\n    }\n    private void trimSQL() {\n        this.sql = this.sql.trim();\n        Matcher m = PATTERN_WHITESPACE_BEGIN.matcher(this.sql);\n        if (m.find()) {\n            this.sql = this.sql.substring(m.end());\n        }\n        m = PATTERN_WHITESPACE_END.matcher(this.sql);\n        if (m.find()) {\n            this.sql = this.sql.substring(0, m.start());\n        }\n        if (this.sql.endsWith(\";\")) {\n            this.sql = this.sql.substring(0, this.sql.length() - 1);\n        }\n    }\n    public String getDomainName() {\n        Matcher m = PATTERN_FROM_CLAUSE.matcher(this.sql);\n        if (m.find()) {\n            String fromExpression = this.sql.substring(m.start(), m.end());\n            m = PATTERN_WHITESPACE.matcher(fromExpression);\n            if (m.find()) {\n                String domainName = convertSQLIdentifierToCatalogFormat(fromExpression.substring(m.end()),\n                        DELIMITED_IDENTIFIER_QUOTE);\n                return domainName;\n            }\n        }\n        return null;\n    }\n    /*\n     * Collect as many items as SimpleDB allows and return the NextToken, which\n     * is used to continue the query in a subsequent call to SimpleDB.\n     */\n    ExecutionResult execute(final String queryText, final int startingRow, final int maxRows, final int requestSize,\n            final String nextToken) throws SQLException {\n        if (this.data.getPersistedColumnNum() == 0) {\n            extractColumnNamesFromSelect();\n        }\n        //    System.out.println(\"FINAL QUERY: \" + queryText);\n        SelectRequest request = new SelectRequest();\n        request.setSelectExpression(queryText);\n        if (nextToken != null) {\n            request.setNextToken(nextToken);\n        }\n        SelectResult queryResult;\n        try {\n            queryResult = this.conn.getClient().select(request);\n        } catch (Exception e) {\n            throw wrapIntoSqlException(e);\n        }\n        boolean shouldAddItemName = this.data.getPersistedColumnNum() == 0\n        || this.data.getAttributes().contains(SimpleDBItemName.ITEM_HEADER);\n        int row = startingRow;\n        //      List<GetAttributesResponse> responses = new ArrayList<GetAttributesResponse>();\n        for (Item item : queryResult.getItems()) {\n            if (this.cancel) {\n                break;\n            }\n            if (shouldAddItemName) {\n                this.data.addItemName(item.getName(), row);\n            }\n            List<Attribute> attributes = item.getAttributes();\n            for (Attribute attr : attributes) {\n                this.data.add(attr.getName(), attr.getValue(), row);\n            }\n            if (attributes.isEmpty()) {\n                this.data.ensureRows(row);\n            }\n            //        GetAttributesRequest aRequest = new GetAttributesRequest();\n            //        aRequest.setItemName(item.getName());\n            //        aRequest.setDomainName(getDomainName() /*request.getDomainName()*/);\n            //        try {\n            //          responses.add(this.conn.service.getAttributes(aRequest));\n            //        } catch (Exception e) {\n            //          throw wrapIntoSqlException(e);\n            //        }\n            row++;\n        }\n        //      row = startingRow;\n        //      for (GetAttributesResponse aResponse : responses) {\n        //        if (this.cancel) {\n        //          break;\n        //        }\n        //\n        //        try {\n        //          GetAttributesResult aResult = aResponse.getGetAttributesResult();\n        //          for (Attribute attribute : aResult.getAttribute()) {\n        //            this.data.add(attribute.getName(), attribute.getValue(), row);\n        //          }\n        //        } catch (Exception e) {\n        //          throw wrapIntoSqlException(e);\n        //        }\n        //\n        //        row++;\n        //      }\n        String newNextToken = queryResult.getNextToken();\n        return new ExecutionResult(newNextToken, row - startingRow);\n    }\n    @Override\n    public ResultSet executeQuery(final String sql) throws SQLException {\n        if (execute(sql)) {\n            return getResultSet();\n        } else {\n            throw new SQLException(\"query didn't return a ResultSet\");\n        }\n    }\n<fim_suffix>    @Override\n    @SuppressWarnings(\"unchecked\")\n    public int executeUpdate(final String inSql) throws SQLException {\n        this.sql = inSql;\n        if (this.sql == null) {\n            throw new SQLException(\"sql is null\");\n        }\n        trimSQL();\n        if (this.sql.length() == 0) {\n            throw new SQLException(\"empty sql\");\n        }\n        String lowcaseSql = this.sql.toLowerCase();\n        Object req = null;\n        // TODO use patterns\n        if (lowcaseSql.startsWith(\"create domain\") || lowcaseSql.startsWith(\"create table\")) { //$NON-NLS-1$\n            int pos = this.sql.lastIndexOf(\" \");\n            String domain = convertSQLIdentifierToCatalogFormat(this.sql.substring(pos + 1).trim(),\n                    DELIMITED_IDENTIFIER_QUOTE);\n            req = new CreateDomainRequest().withDomainName(domain);\n        } else if (lowcaseSql.startsWith(\"delete domain\") || lowcaseSql.startsWith(\"delete table\") //$NON-NLS-1$\n                || lowcaseSql.startsWith(\"drop table\")) {\n            int pos = this.sql.lastIndexOf(\" \");\n            String domain = convertSQLIdentifierToCatalogFormat(this.sql.substring(pos + 1).trim(),\n                    DELIMITED_IDENTIFIER_QUOTE);\n            List<String> pending = this.conn.getPendingColumns(domain);\n            if (pending != null) {\n                pending = new ArrayList<>(pending);\n                for (String attr : pending) {\n                    this.conn.removePendingColumn(domain, attr);\n                }\n            }\n            req = new DeleteDomainRequest().withDomainName(domain);\n        } else if (lowcaseSql.startsWith(\"delete from\")) {\n            req = prepareDeleteRowRequest();\n        } else if (lowcaseSql.startsWith(\"alter table \")) {\n            req = prepareDropAttributeRequest();\n        } else if (lowcaseSql.startsWith(\"insert \")) {\n            req = prepareInsertRequest();\n        } else if (lowcaseSql.startsWith(\"update \")) {\n            req = prepareUpdateRequest();\n        } else if (lowcaseSql.startsWith(\"create testdomain \")) {\n            req = new ArrayList<>();\n            String domain = convertSQLIdentifierToCatalogFormat(this.sql.substring(this.sql.lastIndexOf(\" \") + 1).trim(), //$NON-NLS-1$\n                    DELIMITED_IDENTIFIER_QUOTE);\n            ((List<Object>) req).add(new CreateDomainRequest().withDomainName(domain));\n            ReplaceableAttribute attr  = new ReplaceableAttribute().withName(\"attr1\").withValue(\"val1\").withReplace(Boolean.TRUE);\n            for (int i = 0; i < 570; i++) {\n                ((List<Object>) req).add(new PutAttributesRequest().withDomainName(domain).withItemName(\"item\" + i).withAttributes(attr));\n            }\n        }\n        if (req != null) {\n            int result = executeSDBRequest(req);\n            if (this.params != null) {\n                for (Object obj : this.params) {\n                    if (obj instanceof SimpleDBItemName) {\n                        ((SimpleDBItemName) obj).setPersisted(true);\n                    }\n                }\n            }\n            return result;\n        }\n        throw new SQLException(\"unsupported update: \" + this.sql);\n    }<fim_middle>// function below is long method\n"}