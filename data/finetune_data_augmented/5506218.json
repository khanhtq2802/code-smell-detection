{"text": "<fim_prefix>        cmd.customHeader = customHeader;\n        setCmdVersion(cmd);\n        return cmd;\n    }\n    private static void setCmdVersion(RemotingCommand cmd) {\n        if (configVersion >= 0) {\n            cmd.setVersion(configVersion);\n        } else {\n            String v = System.getProperty(REMOTING_VERSION_KEY);\n            if (v != null) {\n                int value = Integer.parseInt(v);\n                cmd.setVersion(value);\n                configVersion = value;\n            }\n        }\n    }\n    public static RemotingCommand createResponseCommand(Class<? extends CommandCustomHeader> classHeader) {\n        return createResponseCommand(RemotingSysResponseCode.SYSTEM_ERROR, \"not set any response code\", classHeader);\n    }\n    public static RemotingCommand createResponseCommand(int code, String remark,\n        Class<? extends CommandCustomHeader> classHeader) {\n        RemotingCommand cmd = new RemotingCommand();\n        cmd.markResponseType();\n        cmd.setCode(code);\n        cmd.setRemark(remark);\n        setCmdVersion(cmd);\n        if (classHeader != null) {\n            try {\n                CommandCustomHeader objectHeader = classHeader.newInstance();\n                cmd.customHeader = objectHeader;\n            } catch (InstantiationException e) {\n                return null;\n            } catch (IllegalAccessException e) {\n                return null;\n            }\n        }\n        return cmd;\n    }\n    public static RemotingCommand createResponseCommand(int code, String remark) {\n        return createResponseCommand(code, remark, null);\n    }\n    public static RemotingCommand decode(final byte[] array) {\n        ByteBuffer byteBuffer = ByteBuffer.wrap(array);\n        return decode(byteBuffer);\n    }\n    public static RemotingCommand decode(final ByteBuffer byteBuffer) {\n        int length = byteBuffer.limit();\n        int oriHeaderLen = byteBuffer.getInt();\n        int headerLength = getHeaderLength(oriHeaderLen);\n        byte[] headerData = new byte[headerLength];\n        byteBuffer.get(headerData);\n        RemotingCommand cmd = headerDecode(headerData, getProtocolType(oriHeaderLen));\n        int bodyLength = length - 4 - headerLength;\n        byte[] bodyData = null;\n        if (bodyLength > 0) {\n            bodyData = new byte[bodyLength];\n            byteBuffer.get(bodyData);\n        }\n        cmd.body = bodyData;\n        return cmd;\n    }\n    public static int getHeaderLength(int length) {\n        return length & 0xFFFFFF;\n    }\n    private static RemotingCommand headerDecode(byte[] headerData, SerializeType type) {\n        switch (type) {\n            case JSON:\n                RemotingCommand resultJson = RemotingSerializable.decode(headerData, RemotingCommand.class);\n                resultJson.setSerializeTypeCurrentRPC(type);\n                return resultJson;\n            case ROCKETMQ:\n                RemotingCommand resultRMQ = RocketMQSerializable.rocketMQProtocolDecode(headerData);\n                resultRMQ.setSerializeTypeCurrentRPC(type);\n                return resultRMQ;\n            default:\n                break;\n        }\n        return null;\n    }\n    public static SerializeType getProtocolType(int source) {\n        return SerializeType.valueOf((byte) ((source >> 24) & 0xFF));\n    }\n    public static int createNewRequestId() {\n        return requestId.incrementAndGet();\n    }\n    public static SerializeType getSerializeTypeConfigInThisServer() {\n        return serializeTypeConfigInThisServer;\n    }\n    private static boolean isBlank(String str) {\n        int strLen;\n        if (str == null || (strLen = str.length()) == 0) {\n            return true;\n        }\n        for (int i = 0; i < strLen; i++) {\n            if (!Character.isWhitespace(str.charAt(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n    public static byte[] markProtocolType(int source, SerializeType type) {\n        byte[] result = new byte[4];\n        result[0] = type.getCode();\n        result[1] = (byte) ((source >> 16) & 0xFF);\n        result[2] = (byte) ((source >> 8) & 0xFF);\n        result[3] = (byte) (source & 0xFF);\n        return result;\n    }\n    public void markResponseType() {\n        int bits = 1 << RPC_TYPE;\n        this.flag |= bits;\n    }\n    public CommandCustomHeader readCustomHeader() {\n        return customHeader;\n    }\n    public void writeCustomHeader(CommandCustomHeader customHeader) {\n        this.customHeader = customHeader;\n    }\n    public CommandCustomHeader decodeCommandCustomHeader(\n        Class<? extends CommandCustomHeader> classHeader) throws RemotingCommandException {\n        CommandCustomHeader objectHeader;\n        try {\n            objectHeader = classHeader.newInstance();\n        } catch (InstantiationException e) {\n            return null;\n        } catch (IllegalAccessException e) {\n            return null;\n        }\n        if (this.extFields != null) {\n            Field[] fields = getClazzFields(classHeader);\n            for (Field field : fields) {\n                if (!Modifier.isStatic(field.getModifiers())) {\n                    String fieldName = field.getName();\n                    if (!fieldName.startsWith(\"this\")) {\n                        try {\n                            String value = this.extFields.get(fieldName);\n                            if (null == value) {\n                                if (!isFieldNullable(field)) {\n                                    throw new RemotingCommandException(\"the custom field <\" + fieldName + \"> is null\");\n                                }\n                                continue;\n                            }\n                            field.setAccessible(true);\n                            String type = getCanonicalName(field.getType());\n                            Object valueParsed;\n                            if (type.equals(STRING_CANONICAL_NAME)) {\n                                valueParsed = value;\n                            } else if (type.equals(INTEGER_CANONICAL_NAME_1) || type.equals(INTEGER_CANONICAL_NAME_2)) {\n                                valueParsed = Integer.parseInt(value);\n                            } else if (type.equals(LONG_CANONICAL_NAME_1) || type.equals(LONG_CANONICAL_NAME_2)) {\n                                valueParsed = Long.parseLong(value);\n                            } else if (type.equals(BOOLEAN_CANONICAL_NAME_1) || type.equals(BOOLEAN_CANONICAL_NAME_2)) {\n                                valueParsed = Boolean.parseBoolean(value);\n                            } else if (type.equals(DOUBLE_CANONICAL_NAME_1) || type.equals(DOUBLE_CANONICAL_NAME_2)) {\n                                valueParsed = Double.parseDouble(value);\n                            } else {\n                                throw new RemotingCommandException(\"the custom field <\" + fieldName + \"> type is not supported\");\n                            }\n                            field.set(objectHeader, valueParsed);\n                        } catch (Throwable e) {\n                            log.error(\"Failed field [{}] decoding\", fieldName, e);\n                        }\n                    }\n                }\n            }\n            objectHeader.checkFields();\n        }\n        return objectHeader;\n    }\n    private Field[] getClazzFields(Class<? extends CommandCustomHeader> classHeader) {\n        Field[] field = CLASS_HASH_MAP.get(classHeader);\n        if (field == null) {\n            field = classHeader.getDeclaredFields();\n            synchronized (CLASS_HASH_MAP) {\n                CLASS_HASH_MAP.put(classHeader, field);\n            }\n        }\n        return field;\n    }\n    private boolean isFieldNullable(Field field) {\n        if (!NULLABLE_FIELD_CACHE.containsKey(field)) {\n            Annotation annotation = field.getAnnotation(CFNotNull.class);\n            synchronized (NULLABLE_FIELD_CACHE) {\n                NULLABLE_FIELD_CACHE.put(field, annotation == null);\n            }\n        }\n        return NULLABLE_FIELD_CACHE.get(field);\n    }\n    private String getCanonicalName(Class clazz) {\n        String name = CANONICAL_NAME_CACHE.get(clazz);\n        if (name == null) {\n            name = clazz.getCanonicalName();\n            synchronized (CANONICAL_NAME_CACHE) {\n                CANONICAL_NAME_CACHE.put(clazz, name);\n            }\n        }\n        return name;\n    }\n    public ByteBuffer encode() {\n        // 1> header length size\n        int length = 4;\n        // 2> header data length\n        byte[] headerData = this.headerEncode();\n        length += headerData.length;\n        // 3> body data length\n        if (this.body != null) {\n            length += body.length;\n        }\n        ByteBuffer result = ByteBuffer.allocate(4 + length);\n        // length\n        result.putInt(length);\n        // header length\n        result.put(markProtocolType(headerData.length, serializeTypeCurrentRPC));\n        // header data\n        result.put(headerData);\n        // body data;\n        if (this.body != null) {\n            result.put(this.body);\n        }\n        result.flip();\n        return result;\n    }\n<fim_suffix>    private byte[] headerEncode() {\n        this.makeCustomHeaderToNet();\n        if (SerializeType.ROCKETMQ == serializeTypeCurrentRPC) {\n            return RocketMQSerializable.rocketMQProtocolEncode(this);\n        } else {\n            return RemotingSerializable.encode(this);\n        }\n    }<fim_middle>// function below has no smell\n"}