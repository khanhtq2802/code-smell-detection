{"text": "<fim_prefix>            _MiscTemplateException {\n        String catchAllParamName = macro.getCatchAll();\n        if (namedArgs != null) {\n            final SimpleHash catchAllParamValue;\n            if (catchAllParamName != null) {\n                catchAllParamValue = new SimpleHash((ObjectWrapper) null);\n                macroCtx.setLocalVar(catchAllParamName, catchAllParamValue);\n            } else {\n                catchAllParamValue = null;\n            }\n            for (Iterator it = namedArgs.entrySet().iterator(); it.hasNext();) {\n                final Map.Entry argNameAndValExp = (Map.Entry) it.next();\n                final String argName = (String) argNameAndValExp.getKey();\n                final boolean isArgNameDeclared = macro.hasArgNamed(argName);\n                if (isArgNameDeclared || catchAllParamName != null) {\n                    Expression argValueExp = (Expression) argNameAndValExp.getValue();\n                    TemplateModel argValue = argValueExp.eval(this);\n                    if (isArgNameDeclared) {\n                        macroCtx.setLocalVar(argName, argValue);\n                    } else {\n                        catchAllParamValue.put(argName, argValue);\n                    }\n                } else {\n                    throw new _MiscTemplateException(this,\n                            (macro.isFunction() ? \"Function \" : \"Macro \"), new _DelayedJQuote(macro.getName()),\n                            \" has no parameter with name \", new _DelayedJQuote(argName), \".\");\n                }\n            }\n        } else if (positionalArgs != null) {\n            final SimpleSequence catchAllParamValue;\n            if (catchAllParamName != null) {\n                catchAllParamValue = new SimpleSequence((ObjectWrapper) null);\n                macroCtx.setLocalVar(catchAllParamName, catchAllParamValue);\n            } else {\n                catchAllParamValue = null;\n            }\n            String[] argNames = macro.getArgumentNamesInternal();\n            final int argsCnt = positionalArgs.size();\n            if (argNames.length < argsCnt && catchAllParamName == null) {\n                throw new _MiscTemplateException(this,\n                        (macro.isFunction() ? \"Function \" : \"Macro \"), new _DelayedJQuote(macro.getName()),\n                        \" only accepts \", new _DelayedToString(argNames.length), \" parameters, but got \",\n                        new _DelayedToString(argsCnt), \".\");\n            }\n            for (int i = 0; i < argsCnt; i++) {\n                Expression argValueExp = positionalArgs.get(i);\n                TemplateModel argValue = argValueExp.eval(this);\n                try {\n                    if (i < argNames.length) {\n                        String argName = argNames[i];\n                        macroCtx.setLocalVar(argName, argValue);\n                    } else {\n                        catchAllParamValue.add(argValue);\n                    }\n                } catch (RuntimeException re) {\n                    throw new _MiscTemplateException(re, this);\n                }\n            }\n        }\n    }\n    /**\n     * Defines the given macro in the current namespace (doesn't call it).\n     */\n    void visitMacroDef(Macro macro) {\n        macroToNamespaceLookup.put(macro, currentNamespace);\n        currentNamespace.put(macro.getName(), macro);\n    }\n    Namespace getMacroNamespace(Macro macro) {\n        return (Namespace) macroToNamespaceLookup.get(macro);\n    }\n    void recurse(TemplateNodeModel node, TemplateSequenceModel namespaces)\n            throws TemplateException, IOException {\n        if (node == null) {\n            node = this.getCurrentVisitorNode();\n            if (node == null) {\n                throw new _TemplateModelException(\n                        \"The target node of recursion is missing or null.\");\n            }\n        }\n        TemplateSequenceModel children = node.getChildNodes();\n        if (children == null) {\n            return;\n        }\n        int size = children.size();\n        for (int i = 0; i < size; i++) {\n            TemplateNodeModel child = (TemplateNodeModel) children.get(i);\n            if (child != null) {\n                invokeNodeHandlerFor(child, namespaces);\n            }\n        }\n    }\n    Macro.Context getCurrentMacroContext() {\n        return currentMacroContext;\n    }\n    private void handleTemplateException(TemplateException templateException)\n            throws TemplateException {\n        if (templateException instanceof TemplateModelException\n                && ((TemplateModelException) templateException).getReplaceWithCause()\n                && templateException.getCause() instanceof TemplateException) {\n            templateException = (TemplateException) templateException.getCause();\n        }\n        // Logic to prevent double-handling of the exception in\n        // nested visit() calls.\n        if (lastThrowable == templateException) {\n            throw templateException;\n        }\n        lastThrowable = templateException;\n        if (getLogTemplateExceptions() && LOG.isErrorEnabled()\n                && !isInAttemptBlock() /* because then the AttemptExceptionReporter will report this */) {\n            LOG.error(\"Error executing FreeMarker template\", templateException);\n        }\n        try {\n            // Stop exception is not passed to the handler, but\n            // explicitly rethrown.\n            if (templateException instanceof StopException) {\n                throw templateException;\n            }\n            // Finally, pass the exception to the handler\n            getTemplateExceptionHandler().handleTemplateException(templateException, this, out);\n        } catch (TemplateException e) {\n            // Note that if the TemplateExceptionHandler doesn't rethrow the exception, we don't get in there.\n            if (isInAttemptBlock()) {\n                this.getAttemptExceptionReporter().report(templateException, this);\n            }\n            throw e;\n        }\n    }\n    @Override\n    public void setTemplateExceptionHandler(TemplateExceptionHandler templateExceptionHandler) {\n        super.setTemplateExceptionHandler(templateExceptionHandler);\n        lastThrowable = null;\n    }\n    @Override\n    public void setLocale(Locale locale) {\n        Locale prevLocale = getLocale();\n        super.setLocale(locale);\n        if (!locale.equals(prevLocale)) {\n            cachedTemplateNumberFormats = null;\n            if (cachedTemplateNumberFormat != null && cachedTemplateNumberFormat.isLocaleBound()) {\n                cachedTemplateNumberFormat = null;\n            }\n            if (cachedTempDateFormatArray != null) {\n                for (int i = 0; i < CACHED_TDFS_LENGTH; i++) {\n                    final TemplateDateFormat f = cachedTempDateFormatArray[i];\n                    if (f != null && f.isLocaleBound()) {\n                        cachedTempDateFormatArray[i] = null;\n                    }\n                }\n            }\n            cachedTempDateFormatsByFmtStrArray = null;\n            cachedCollator = null;\n        }\n    }\n    @Override\n    public void setTimeZone(TimeZone timeZone) {\n        TimeZone prevTimeZone = getTimeZone();\n        super.setTimeZone(timeZone);\n        if (!timeZone.equals(prevTimeZone)) {\n            if (cachedTempDateFormatArray != null) {\n                for (int i = 0; i < CACHED_TDFS_SQL_D_T_TZ_OFFS; i++) {\n                    TemplateDateFormat f = cachedTempDateFormatArray[i];\n                    if (f != null && f.isTimeZoneBound()) {\n                        cachedTempDateFormatArray[i] = null;\n                    }\n                }\n            }\n            if (cachedTempDateFormatsByFmtStrArray != null) {\n                for (int i = 0; i < CACHED_TDFS_SQL_D_T_TZ_OFFS; i++) {\n                    cachedTempDateFormatsByFmtStrArray[i] = null;\n                }\n            }\n            cachedSQLDateAndTimeTimeZoneSameAsNormal = null;\n        }\n    }\n    @Override\n    public void setSQLDateAndTimeTimeZone(TimeZone timeZone) {\n        TimeZone prevTimeZone = getSQLDateAndTimeTimeZone();\n        super.setSQLDateAndTimeTimeZone(timeZone);\n        if (!nullSafeEquals(timeZone, prevTimeZone)) {\n            if (cachedTempDateFormatArray != null) {\n                for (int i = CACHED_TDFS_SQL_D_T_TZ_OFFS; i < CACHED_TDFS_LENGTH; i++) {\n                    TemplateDateFormat format = cachedTempDateFormatArray[i];\n                    if (format != null && format.isTimeZoneBound()) {\n                        cachedTempDateFormatArray[i] = null;\n                    }\n                }\n            }\n            if (cachedTempDateFormatsByFmtStrArray != null) {\n                for (int i = CACHED_TDFS_SQL_D_T_TZ_OFFS; i < CACHED_TDFS_LENGTH; i++) {\n                    cachedTempDateFormatsByFmtStrArray[i] = null;\n                }\n            }\n            cachedSQLDateAndTimeTimeZoneSameAsNormal = null;\n        }\n    }\n    // Replace with Objects.equals in Java 7\n    private static boolean nullSafeEquals(Object o1, Object o2) {\n        if (o1 == o2) return true;\n        if (o1 == null || o2 == null) return false;\n        return o1.equals(o2);\n    }\n    /**\n     * Tells if the same concrete time zone is used for SQL date-only and time-only values as for other\n     * date/time/date-time values.\n     */\n<fim_suffix>    boolean isSQLDateAndTimeTimeZoneSameAsNormal() {\n        if (cachedSQLDateAndTimeTimeZoneSameAsNormal == null) {\n            cachedSQLDateAndTimeTimeZoneSameAsNormal = Boolean.valueOf(\n                    getSQLDateAndTimeTimeZone() == null\n                            || getSQLDateAndTimeTimeZone().equals(getTimeZone()));\n        }\n        return cachedSQLDateAndTimeTimeZoneSameAsNormal.booleanValue();\n    }<fim_middle>// function below has no smell\n"}