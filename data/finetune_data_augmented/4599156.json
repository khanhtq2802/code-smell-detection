{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.giraph.ooc.persistence;\n\nimport org.apache.giraph.conf.GiraphConstants;\nimport org.apache.giraph.conf.ImmutableClassesGiraphConfiguration;\nimport org.apache.giraph.conf.IntConfOption;\nimport org.apache.giraph.utils.ExtendedDataOutput;\nimport org.apache.giraph.utils.io.BigDataInput;\nimport org.apache.giraph.utils.io.BigDataOutput;\n\nimport java.io.DataInput;\nimport java.io.DataOutput;\nimport java.io.IOException;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.LinkedBlockingDeque;\n\n/**\n * Implementation of data accessor which keeps all the data serialized but in\n * memory. Useful to keep the number of used objects under control.\n */\npublic class InMemoryDataAccessor implements OutOfCoreDataAccessor {\n  /** Configuration */\n  private final ImmutableClassesGiraphConfiguration<?, ?, ?> conf;\n  /** Factory for data outputs */\n  private final PooledBigDataOutputFactory outputFactory;\n  /** DataInputOutput for each DataIndex used */\n  private final ConcurrentHashMap<\n      DataIndex, PooledBigDataOutputFactory.Output> data;\n\n  /**\n   * Constructor\n   *\n   * @param conf Configuration\n   */\n  public InMemoryDataAccessor(\n      ImmutableClassesGiraphConfiguration<?, ?, ?> conf) {\n    this.conf = conf;\n    outputFactory = new PooledBigDataOutputFactory(conf);\n    data = new ConcurrentHashMap<>();\n  }\n\n  @Override\n  public void initialize() {\n    // No-op\n  }\n\n  @Override\n  public void shutdown() {\n    // No-op\n  }\n\n  @Override\n  public int getNumAccessorThreads() {\n    return GiraphConstants.NUM_OUT_OF_CORE_THREADS.get(conf);\n  }\n\n  @Override\n  public DataInputWrapper prepareInput(int threadId,\n      DataIndex index) throws IOException {\n    return new InMemoryDataInputWrapper(\n        new BigDataInput(data.get(index)), index);\n  }\n\n  @Override\n  public DataOutputWrapper prepareOutput(int threadId,\n      DataIndex index, boolean shouldAppend) throws IOException {\n    // Don't need to worry about synchronization here since only one thread\n    // can deal with one index\n    PooledBigDataOutputFactory.Output output = data.get(index);\n    if (output == null || !shouldAppend) {\n      output = outputFactory.createOutput();\n      data.put(index, output);\n    }\n    return new InMemoryDataOutputWrapper(output);\n  }\n\n  @Override\n  public boolean dataExist(int threadId, DataIndex index) {\n    return data.containsKey(index);\n  }\n\n  /**\n   * {@link DataOutputWrapper} implementation for {@link InMemoryDataAccessor}\n   */\n  public static class InMemoryDataOutputWrapper implements DataOutputWrapper {\n    /** Output to write data to */\n    private final BigDataOutput output;\n    /** Size of output at the moment it was created */\n    private final long initialSize;\n\n    /**\n     * Constructor\n     *\n     * @param output Output to write data to\n     */\n    public InMemoryDataOutputWrapper(BigDataOutput output) {\n      this.output = output;\n      initialSize = output.getSize();\n    }\n\n    @Override\n    public DataOutput getDataOutput() {\n      return output;\n    }\n\n    @Override\n    public long finalizeOutput() {\n      return output.getSize() - initialSize;\n    }\n  }\n\n  /**\n   * {@link DataInputWrapper} implementation for {@link InMemoryDataAccessor}\n   */\n<fim_suffix>  public class InMemoryDataInputWrapper implements DataInputWrapper {\n    /** Input to read data from */\n    private final BigDataInput input;\n    /** DataIndex which this wrapper belongs to */\n    private final DataIndex index;\n\n    /**\n     * Constructor\n     *\n     * @param input Input to read data from\n     * @param index DataIndex which this wrapper belongs to\n     */\n    public InMemoryDataInputWrapper(\n        BigDataInput input, DataIndex index) {\n      this.input = input;\n      this.index = index;\n    }\n\n    @Override\n    public DataInput getDataInput() {\n      return input;\n    }\n\n    @Override\n    public long finalizeInput(boolean deleteOnClose) {\n      if (deleteOnClose) {\n        data.remove(index).returnData();\n      }\n      return input.getPos();\n    }\n  }\n\n  /**\n   * Factory for pooled big data outputs\n   */\n  private static class PooledBigDataOutputFactory {\n    /** How big pool of byte arrays to keep */\n    public static final IntConfOption BYTE_ARRAY_POOL_SIZE =\n        new IntConfOption(\"giraph.inMemoryDataAccessor.poolSize\", 1024,\n            \"How big pool of byte arrays to keep\");\n    /** How big byte arrays to make */\n    public static final IntConfOption BYTE_ARRAY_SIZE =\n        new IntConfOption(\"giraph.inMemoryDataAccessor.byteArraySize\", 1 << 21,\n            \"How big byte arrays to make\");\n\n    /** Configuration */\n    private final ImmutableClassesGiraphConfiguration conf;\n    /** Pool of reusable byte[] */\n    private final LinkedBlockingDeque<byte[]> byteArrayPool;\n    /** How big byte arrays to make */\n    private final int byteArraySize;\n\n    /**\n     * Constructor\n     *\n     * @param conf Configuration\n     */\n    public PooledBigDataOutputFactory(\n        ImmutableClassesGiraphConfiguration conf) {\n      this.conf = conf;\n      byteArrayPool = new LinkedBlockingDeque<>(BYTE_ARRAY_POOL_SIZE.get(conf));\n      byteArraySize = BYTE_ARRAY_SIZE.get(conf);\n    }\n\n    /**\n     * Create new output to write to\n     *\n     * @return Output to write to\n     */\n    public Output createOutput() {\n      return new Output(conf);\n    }\n\n    /**\n     * Implementation of BigDataOutput\n     */\n    private class Output extends BigDataOutput {\n      /**\n       * Constructor\n       *\n       * @param conf Configuration\n       */\n      public Output(ImmutableClassesGiraphConfiguration conf) {\n        super(conf);\n      }\n\n      /**\n       * Return all data structures related to this data output.\n       * Can't use the same instance after this call anymore.\n       */\n      protected void returnData() {\n        if (dataOutputs != null) {\n          for (ExtendedDataOutput dataOutput : dataOutputs) {\n            byteArrayPool.offer(dataOutput.getByteArray());\n          }\n        }\n        byteArrayPool.offer(currentDataOutput.getByteArray());\n      }\n\n      @Override\n      protected ExtendedDataOutput createOutput(int size) {\n        byte[] data = byteArrayPool.pollLast();\n        return conf.createExtendedDataOutput(\n            data == null ? new byte[byteArraySize] : data, 0);\n      }\n\n      @Override\n      protected int getMaxSize() {\n        return byteArraySize;\n      }\n    }\n  }\n}<fim_middle>// class below has no smell\n"}