{"text": "<fim_prefix>/*******************************************************************************\n * Copyright (c) 2013 Pivotal Software, Inc.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     Pivotal Software, Inc. - initial API and implementation\n *******************************************************************************/\npackage org.grails.ide.eclipse.longrunning.client;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.StringWriter;\n\n/**\n * Utility to get a stacktrace from an external grails process by calling jps and jstack.\n * \n * @author Kris De Volder\n */\n<fim_suffix>public class GrailsProcessStackTracer {\n\n\t/**\n\t * Reads input from process and keeps it all until someone asks for it.\n\t */\n\tpublic class OutputFetcher extends Thread {\n\t\tByteArrayOutputStream output = new ByteArrayOutputStream();\n\t\tprivate boolean killed = false;\n\t\tprivate byte[] buffer = new byte[1024 * 4];\n\t\tprivate InputStream in;\n\t\t\n\t\tpublic OutputFetcher(InputStream in) {\n\t\t\tthis.start();\n\t\t\tthis.in = in;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void run() {\n\t\t\ttry {\n\t\t\t\twhile (!killed) {\n\t\t\t\t\t//Don't block if no input is available or the thread may hang indefinitely\n\t\t\t\t\tint count = in.read(buffer);\n\t\t\t\t\tif (count == -1) {\n\t\t\t\t\t\t//end reached\n\t\t\t\t\t\tkilled = true;\n\t\t\t\t\t} else if (count > 0) {\n\t\t\t\t\t\t//Got some data\n\t\t\t\t\t\toutput.write(buffer, 0, count);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\t// exeptions will implicitly kill the thread.\n\t\t\t}\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn output.toString();\n\t\t}\n\n\t\tpublic void kill() {\n\t\t\tthis.killed = true;\n\t\t}\n\t}\n\n\t/**\n\t * @return pid of GrailsStarter process or -1 if no such process is found.\n\t */\n\tint getGrailsProcessId() throws IOException {\n\t\tString jpsOut = exec(\"jps\");\n\t\tSystem.out.println(jpsOut);\n\t\tString[] lines = jpsOut.split(\"[\\\\r\\\\n]+\");\n\t\tint found = -1;\n\t\tfor (int i = 0; i < lines.length && found < 0; i++) {\n\t\t\ttry {\n\t\t\t\tString[] pieces = lines[i].split(\"\\\\s+\");\n\t\t\t\tint pid = Integer.valueOf(pieces[0]);\n\t\t\t\tString name = pieces[1];\n\t\t\t\tif (name.contains(\"GrailsStarter\")) {\n\t\t\t\t\tfound = pid;\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\t//Some unexpected doesn't parse? Ignore\n\t\t\t}\n\t\t}\n\t\treturn found;\n\t}\n\t\n\tpublic String getStackTraces() throws IOException {\n\t\tint pid = getGrailsProcessId();\n\t\tif (pid>=0) {\n\t\t\treturn \"Dumping a stacktrace before killing hanging process ...\\n\" + exec(\"jstack\", \"\"+pid);\n\t\t} else {\n\t\t\treturn \"Couldn't collect a stacktrace because Grails process was not found\";\n\t\t}\n\t}\n\t\n\tprivate String exec(String... command) throws IOException {\n\t\tboolean done = false;\n\t\tProcessBuilder pb = new ProcessBuilder(command);\n\t\tpb.redirectErrorStream(true);\n\t\tProcess p = pb.start();\n\t\tOutputFetcher output = new OutputFetcher(p.getInputStream());\n\t\ttry {\n\t\t\tdone = false;\n\t\t\twhile (!done) {\n\t\t\t\ttry {\n\t\t\t\t\tp.waitFor();\n\t\t\t\t\tdone = true;\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t}\n\t\t\t}\n\t\t} finally {\n\t\t\t//Ensure the thread stops spinning after process is dead.\n\t\t\toutput.kill();\n\t\t}\n\t\tdone = false;\n\t\twhile (!done) {\n\t\t\ttry {\n\t\t\t\toutput.join();\n\t\t\t\tdone = true;\n\t\t\t} catch (InterruptedException e) {\n\t\t\t}\n\t\t}\n\t\treturn output.toString();\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint pid = new GrailsProcessStackTracer().getGrailsProcessId();\n\t\tSystem.out.println(\"Grails process id = \"+pid);\n\t}\n\n}<fim_middle>// class below has no smell\n"}