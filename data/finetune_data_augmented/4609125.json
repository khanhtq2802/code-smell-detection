{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.flink.graph.types.valuearray;\nimport org.apache.flink.api.common.ExecutionConfig;\nimport org.apache.flink.api.common.functions.InvalidTypesException;\nimport org.apache.flink.api.common.typeinfo.AtomicType;\nimport org.apache.flink.api.common.typeinfo.TypeInformation;\nimport org.apache.flink.api.common.typeutils.TypeComparator;\nimport org.apache.flink.api.common.typeutils.TypeSerializer;\nimport org.apache.flink.api.java.typeutils.ValueTypeInfo;\nimport org.apache.flink.types.ByteValue;\nimport org.apache.flink.types.CharValue;\nimport org.apache.flink.types.DoubleValue;\nimport org.apache.flink.types.FloatValue;\nimport org.apache.flink.types.IntValue;\nimport org.apache.flink.types.LongValue;\nimport org.apache.flink.types.NullValue;\nimport org.apache.flink.types.ShortValue;\nimport org.apache.flink.types.StringValue;\nimport org.apache.flink.types.Value;\nimport org.apache.flink.util.Preconditions;\nimport java.util.HashMap;\nimport java.util.Map;\n/**\n * A {@link TypeInformation} for the {@link ValueArray} type.\n *\n * @param <T> the {@link Value} type\n */\npublic class ValueArrayTypeInfo<T> extends TypeInformation<ValueArray<T>> implements AtomicType<ValueArray<T>> {\n\tprivate static final long serialVersionUID = 1L;\n\tpublic static final ValueArrayTypeInfo<ByteValue> BYTE_VALUE_ARRAY_TYPE_INFO = new ValueArrayTypeInfo<>(ValueTypeInfo.BYTE_VALUE_TYPE_INFO);\n\tpublic static final ValueArrayTypeInfo<IntValue> INT_VALUE_ARRAY_TYPE_INFO = new ValueArrayTypeInfo<>(ValueTypeInfo.INT_VALUE_TYPE_INFO);\n\tpublic static final ValueArrayTypeInfo<LongValue> LONG_VALUE_ARRAY_TYPE_INFO = new ValueArrayTypeInfo<>(ValueTypeInfo.LONG_VALUE_TYPE_INFO);\n\tpublic static final ValueArrayTypeInfo<NullValue> NULL_VALUE_ARRAY_TYPE_INFO = new ValueArrayTypeInfo<>(ValueTypeInfo.NULL_VALUE_TYPE_INFO);\n\tpublic static final ValueArrayTypeInfo<StringValue> STRING_VALUE_ARRAY_TYPE_INFO = new ValueArrayTypeInfo<>(ValueTypeInfo.STRING_VALUE_TYPE_INFO);\n\tprivate final TypeInformation<T> valueType;\n\tprivate final Class<T> type;\n\tpublic ValueArrayTypeInfo(TypeInformation<T> valueType) {\n\t\tthis.valueType = valueType;\n\t\tthis.type = valueType == null ? null : valueType.getTypeClass();\n\t}\n\t@Override\n\tpublic int getArity() {\n\t\treturn 1;\n\t}\n\t@Override\n\tpublic int getTotalFields() {\n\t\treturn 1;\n\t}\n\t@SuppressWarnings(\"unchecked\")\n\t@Override\n\tpublic Class<ValueArray<T>> getTypeClass() {\n\t\treturn (Class<ValueArray<T>>) (Class<?>) ValueArray.class;\n\t}\n\t@Override\n\tpublic boolean isBasicType() {\n\t\treturn false;\n\t}\n\t@Override\n\tpublic boolean isTupleType() {\n\t\treturn false;\n\t}\n\t@Override\n\tpublic boolean isKeyType() {\n\t\tPreconditions.checkNotNull(type, \"TypeInformation type class is required\");\n\t\treturn Comparable.class.isAssignableFrom(type);\n\t}\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic TypeSerializer<ValueArray<T>> createSerializer(ExecutionConfig executionConfig) {\n\t\tPreconditions.checkNotNull(type, \"TypeInformation type class is required\");\n\t\tif (ByteValue.class.isAssignableFrom(type)) {\n\t\t\treturn (TypeSerializer<ValueArray<T>>) (TypeSerializer<?>) new ByteValueArraySerializer();\n\t\t} else if (CharValue.class.isAssignableFrom(type)) {\n\t\t\treturn (TypeSerializer<ValueArray<T>>) (TypeSerializer<?>) new CharValueArraySerializer();\n\t\t} else if (DoubleValue.class.isAssignableFrom(type)) {\n\t\t\treturn (TypeSerializer<ValueArray<T>>) (TypeSerializer<?>) new DoubleValueArraySerializer();\n\t\t} else if (FloatValue.class.isAssignableFrom(type)) {\n\t\t\treturn (TypeSerializer<ValueArray<T>>) (TypeSerializer<?>) new FloatValueArraySerializer();\n\t\t} else if (IntValue.class.isAssignableFrom(type)) {\n\t\t\treturn (TypeSerializer<ValueArray<T>>) (TypeSerializer<?>) new IntValueArraySerializer();\n\t\t} else if (LongValue.class.isAssignableFrom(type)) {\n\t\t\treturn (TypeSerializer<ValueArray<T>>) (TypeSerializer<?>) new LongValueArraySerializer();\n\t\t} else if (NullValue.class.isAssignableFrom(type)) {\n\t\t\treturn (TypeSerializer<ValueArray<T>>) (TypeSerializer<?>) new NullValueArraySerializer();\n\t\t} else if (ShortValue.class.isAssignableFrom(type)) {\n\t\t\treturn (TypeSerializer<ValueArray<T>>) (TypeSerializer<?>) new ShortValueArraySerializer();\n\t\t} else if (StringValue.class.isAssignableFrom(type)) {\n\t\t\treturn (TypeSerializer<ValueArray<T>>) (TypeSerializer<?>) new StringValueArraySerializer();\n\t\t} else {\n\t\t\tthrow new InvalidTypesException(\"No ValueArray class exists for \" + type);\n\t\t}\n\t}\n\t@SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n\t@Override\n\tpublic TypeComparator<ValueArray<T>> createComparator(boolean sortOrderAscending, ExecutionConfig executionConfig) {\n\t\tPreconditions.checkNotNull(type, \"TypeInformation type class is required\");\n\t\tif (ByteValue.class.isAssignableFrom(type)) {\n\t\t\treturn (TypeComparator<ValueArray<T>>) (TypeComparator<?>) new ByteValueArrayComparator(sortOrderAscending);\n\t\t} else if (CharValue.class.isAssignableFrom(type)) {\n\t\t\treturn (TypeComparator<ValueArray<T>>) (TypeComparator<?>) new CharValueArrayComparator(sortOrderAscending);\n\t\t} else if (DoubleValue.class.isAssignableFrom(type)) {\n\t\t\treturn (TypeComparator<ValueArray<T>>) (TypeComparator<?>) new DoubleValueArrayComparator(sortOrderAscending);\n\t\t} else if (FloatValue.class.isAssignableFrom(type)) {\n\t\t\treturn (TypeComparator<ValueArray<T>>) (TypeComparator<?>) new FloatValueArrayComparator(sortOrderAscending);\n\t\t} else if (IntValue.class.isAssignableFrom(type)) {\n\t\t\treturn (TypeComparator<ValueArray<T>>) (TypeComparator<?>) new IntValueArrayComparator(sortOrderAscending);\n\t\t} else if (LongValue.class.isAssignableFrom(type)) {\n\t\t\treturn (TypeComparator<ValueArray<T>>) (TypeComparator<?>) new LongValueArrayComparator(sortOrderAscending);\n\t\t} else if (NullValue.class.isAssignableFrom(type)) {\n\t\t\treturn (TypeComparator<ValueArray<T>>) (TypeComparator<?>) new NullValueArrayComparator(sortOrderAscending);\n\t\t} else if (ShortValue.class.isAssignableFrom(type)) {\n\t\t\treturn (TypeComparator<ValueArray<T>>) (TypeComparator<?>) new ShortValueArrayComparator(sortOrderAscending);\n\t\t} else if (StringValue.class.isAssignableFrom(type)) {\n\t\t\treturn (TypeComparator<ValueArray<T>>) (TypeComparator<?>) new StringValueArrayComparator(sortOrderAscending);\n\t\t} else {\n\t\t\tthrow new InvalidTypesException(\"No ValueArray class exists for \" + type);\n\t\t}\n\t}\n\t@Override\n\tpublic Map<String, TypeInformation<?>> getGenericParameters() {\n\t\tMap<String, TypeInformation<?>> m = new HashMap<>(1);\n\t\tm.put(\"T\", valueType);\n\t\treturn m;\n\t}\n\t// --------------------------------------------------------------------------------------------\n<fim_suffix>\t@Override\n\tpublic int hashCode() {\n\t\tPreconditions.checkNotNull(type, \"TypeInformation type class is required\");\n\t\treturn type.hashCode();\n\t}\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (obj instanceof ValueArrayTypeInfo) {\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tValueArrayTypeInfo<T> valueArrayTypeInfo = (ValueArrayTypeInfo<T>) obj;<fim_middle>// function below has no smell\n"}