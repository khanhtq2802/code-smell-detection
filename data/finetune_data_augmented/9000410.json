{"text": "<fim_prefix>              if (debug) {\n                log.debug(logPrefix + \"deleteByQuery \" + cmd);\n              }\n              proc.processDelete(cmd);\n              break;\n            }\n            case UpdateLog.UPDATE_INPLACE:\n            {\n              AddUpdateCommand cmd = UpdateLog.convertTlogEntryToAddUpdateCommand(req, entry, oper, version);\n              cmd.setFlags(UpdateCommand.PEER_SYNC | UpdateCommand.IGNORE_AUTOCOMMIT);\n              if (debug) {\n                log.debug(logPrefix + \"inplace update \" + cmd + \" prevVersion=\" + cmd.prevVersion + \", doc=\" + cmd.solrDoc);\n              }\n              proc.processAdd(cmd);\n              break;\n            }\n            default:\n              throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,  \"Unknown Operation! \" + oper);\n          }\n        }\n      } catch (IOException e) {\n        // TODO: should this be handled separately as a problem with us?\n        // I guess it probably already will by causing replication to be kicked off.\n        log.error(logPrefix + \"Error applying updates from \" + updateFrom + \" ,update=\" + o, e);\n        throw e;\n      } catch (Exception e) {\n        log.error(logPrefix + \"Error applying updates from \" + updateFrom + \" ,update=\" + o, e);\n        throw e;\n      } finally {\n        try {\n          proc.finish();\n        } catch (Exception e) {\n          log.error(logPrefix + \"Error applying updates from \" + updateFrom + \" ,finish()\", e);\n          throw e;\n        } finally {\n          IOUtils.closeQuietly(proc);\n        }\n      }\n    }\n  }\n  static abstract class MissedUpdatesFinderBase {\n    private Set<Long> ourUpdateSet;\n    private Set<Long> requestedUpdateSet = new HashSet<>();\n    long ourLowThreshold;  // 20th percentile\n    List<Long> ourUpdates;\n    MissedUpdatesFinderBase(List<Long> ourUpdates, long ourLowThreshold) {\n      assert sorted(ourUpdates);\n      this.ourUpdates = ourUpdates;\n      this.ourUpdateSet = new HashSet<>(ourUpdates);\n      this.ourLowThreshold = ourLowThreshold;\n    }\n    private boolean sorted(List<Long> list) {\n      long prev = Long.MAX_VALUE;\n      for (long a : list) {\n        if (Math.abs(a) > prev) return false;\n        prev = Math.abs(a);\n      }\n      return true;\n    }\n    MissedUpdatesRequest handleVersionsWithRanges(List<Long> otherVersions, boolean completeList) {\n      // we may endup asking for updates for too many versions, causing 2MB post payload limit. Construct a range of\n      // versions to request instead of asking individual versions\n      List<String> rangesToRequest = new ArrayList<>();\n      // construct ranges to request\n      // both ourUpdates and otherVersions are sorted with highest range first\n      // may be we can create another reverse the lists and avoid confusion\n      int ourUpdatesIndex = ourUpdates.size() - 1;\n      int otherUpdatesIndex = otherVersions.size() - 1;\n      long totalRequestedVersions = 0;\n      while (otherUpdatesIndex >= 0) {\n        // we have run out of ourUpdates, pick up all the remaining versions from the other versions\n        if (ourUpdatesIndex < 0) {\n          String range = otherVersions.get(otherUpdatesIndex) + \"...\" + otherVersions.get(0);\n          rangesToRequest.add(range);\n          totalRequestedVersions += otherUpdatesIndex + 1;\n          break;\n        }\n        // stop when the entries get old enough that reorders may lead us to see updates we don't need\n        if (!completeList && Math.abs(otherVersions.get(otherUpdatesIndex)) < ourLowThreshold) break;\n        if (ourUpdates.get(ourUpdatesIndex).longValue() == otherVersions.get(otherUpdatesIndex).longValue()) {\n          ourUpdatesIndex--;\n          otherUpdatesIndex--;\n        } else if (Math.abs(ourUpdates.get(ourUpdatesIndex)) < Math.abs(otherVersions.get(otherUpdatesIndex))) {\n          ourUpdatesIndex--;\n        } else {\n          long rangeStart = otherVersions.get(otherUpdatesIndex);\n          while ((otherUpdatesIndex < otherVersions.size())\n              && (Math.abs(otherVersions.get(otherUpdatesIndex)) < Math.abs(ourUpdates.get(ourUpdatesIndex)))) {\n            otherUpdatesIndex--;\n            totalRequestedVersions++;\n          }\n          // construct range here\n          rangesToRequest.add(rangeStart + \"...\" + otherVersions.get(otherUpdatesIndex + 1));\n        }\n      }\n      String rangesToRequestStr = rangesToRequest.stream().collect(Collectors.joining(\",\"));\n      return MissedUpdatesRequest.of(rangesToRequestStr, totalRequestedVersions);\n    }\n    MissedUpdatesRequest handleIndividualVersions(List<Long> otherVersions, boolean completeList) {\n      List<Long> toRequest = new ArrayList<>();\n      for (Long otherVersion : otherVersions) {\n        // stop when the entries get old enough that reorders may lead us to see updates we don't need\n        if (!completeList && Math.abs(otherVersion) < ourLowThreshold) break;\n        if (ourUpdateSet.contains(otherVersion) || requestedUpdateSet.contains(otherVersion)) {\n          // we either have this update, or already requested it\n          // TODO: what if the shard we previously requested this from returns failure (because it goes\n          // down)\n          continue;\n        }\n        toRequest.add(otherVersion);\n        requestedUpdateSet.add(otherVersion);\n      }\n      return MissedUpdatesRequest.of(StrUtils.join(toRequest, ','), toRequest.size());\n    }\n  }\n  /**\n   * Helper class for doing comparison ourUpdates and other replicas's updates to find the updates that we missed\n   */\n<fim_suffix>  public static class MissedUpdatesFinder extends MissedUpdatesFinderBase {\n    private long ourHighThreshold; // 80th percentile\n    private long ourHighest;  // currently just used for logging/debugging purposes\n    private String logPrefix;\n    private long nUpdates;\n    MissedUpdatesFinder(List<Long> ourUpdates, String logPrefix, long nUpdates,\n                        long ourLowThreshold, long ourHighThreshold) {\n      super(ourUpdates, ourLowThreshold);\n      this.logPrefix = logPrefix;\n      this.ourHighThreshold = ourHighThreshold;\n      this.ourHighest = ourUpdates.get(0);\n      this.nUpdates = nUpdates;\n    }\n    public MissedUpdatesRequest find(List<Long> otherVersions, Object updateFrom, Supplier<Boolean> canHandleVersionRanges) {\n      otherVersions.sort(absComparator);\n      if (debug) {\n        log.debug(\"{} sorted versions from {} = {}\", logPrefix, otherVersions, updateFrom);\n      }\n      long otherHigh = percentile(otherVersions, .2f);\n      long otherLow = percentile(otherVersions, .8f);\n      long otherHighest = otherVersions.get(0);\n      if (ourHighThreshold < otherLow) {\n        // Small overlap between version windows and ours is older\n        // This means that we might miss updates if we attempted to use this method.\n        // Since there exists just one replica that is so much newer, we must\n        // fail the sync.\n        log.info(\"{} Our versions are too old. ourHighThreshold={} otherLowThreshold={} ourHighest={} otherHighest={}\",\n            logPrefix, ourHighThreshold, otherLow, ourHighest, otherHighest);\n        return MissedUpdatesRequest.UNABLE_TO_SYNC;\n      }\n      if (ourLowThreshold > otherHigh && ourHighest >= otherHighest) {\n        // Small overlap between windows and ours is newer.\n        // Using this list to sync would result in requesting/replaying results we don't need\n        // and possibly bringing deleted docs back to life.\n        log.info(\"{} Our versions are newer. ourHighThreshold={} otherLowThreshold={} ourHighest={} otherHighest={}\",\n            logPrefix, ourHighThreshold, otherLow, ourHighest, otherHighest);\n        // Because our versions are newer, IndexFingerprint with the remote would not match us.\n        // We return true on our side, but the remote peersync with us should fail.\n        return MissedUpdatesRequest.ALREADY_IN_SYNC;\n      }\n      boolean completeList = otherVersions.size() < nUpdates;\n      MissedUpdatesRequest updatesRequest;\n      if (canHandleVersionRanges.get()) {\n        updatesRequest = handleVersionsWithRanges(otherVersions, completeList);\n      } else {\n        updatesRequest = handleIndividualVersions(otherVersions, completeList);\n      }\n      if (updatesRequest.totalRequestedUpdates > nUpdates) {\n        log.info(\"{} PeerSync will fail because number of missed updates is more than:{}\", logPrefix, nUpdates);\n        return MissedUpdatesRequest.UNABLE_TO_SYNC;\n      }\n      if (updatesRequest == MissedUpdatesRequest.EMPTY) {\n        log.info(\"{} No additional versions requested. ourHighThreshold={} otherLowThreshold={} ourHighest={} otherHighest={}\",\n            logPrefix, ourHighThreshold, otherLow, ourHighest, otherHighest);\n      }\n      return updatesRequest;\n    }\n  }<fim_middle>// class below is blob\n"}