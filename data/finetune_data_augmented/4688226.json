{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.hama.util;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.lang.reflect.Field;\nimport java.util.Arrays;\n/**\n * Byte array output stream that uses Unsafe methods to serialize/deserialize\n * much faster\n */\n@SuppressWarnings(\"restriction\")\npublic class UnsafeByteArrayOutputStream extends OutputStream implements\n    ExtendedDataOutput {\n  static {\n    try {\n      Field field = sun.misc.Unsafe.class.getDeclaredField(\"theUnsafe\");\n      field.setAccessible(true);\n      UNSAFE = (sun.misc.Unsafe) field.get(null);\n      // Checkstyle exception due to needing to check if unsafe is allowed\n      // CHECKSTYLE: stop IllegalCatch\n    } catch (Exception e) {\n      // CHECKSTYLE: resume IllegalCatch\n      throw new RuntimeException(\"UnsafeByteArrayOutputStream: Failed to \"\n          + \"get unsafe\", e);\n    }\n  }\n  /** Default number of bytes */\n  private static final int DEFAULT_BYTES = 32;\n  /** Access to the unsafe class */\n  private static final sun.misc.Unsafe UNSAFE;\n  /** Offset of a byte array */\n  private static final long BYTE_ARRAY_OFFSET = UNSAFE\n      .arrayBaseOffset(byte[].class);\n  /** Byte buffer */\n  private byte[] buf;\n  /** Position in the buffer */\n  private int pos = 0;\n  /**\n   * Constructor\n   */\n  public UnsafeByteArrayOutputStream() {\n    this(DEFAULT_BYTES);\n  }\n  /**\n   * Constructor\n   *\n   * @param size Initial size of the underlying byte array\n   */\n  public UnsafeByteArrayOutputStream(int size) {\n    buf = new byte[size];\n  }\n  /**\n   * Constructor to take in a buffer\n   *\n   * @param buf Buffer to start with, or if null, create own buffer\n   */\n  public UnsafeByteArrayOutputStream(byte[] buf) {\n    if (buf == null) {\n      this.buf = new byte[DEFAULT_BYTES];\n    } else {\n      this.buf = buf;\n    }\n  }\n  /**\n   * Constructor to take in a buffer with a given position into that buffer\n   *\n   * @param buf Buffer to start with\n   * @param pos Position to write at the buffer\n   */\n  public UnsafeByteArrayOutputStream(byte[] buf, int pos) {\n    this(buf);\n    this.pos = pos;\n  }\n  /**\n   * Ensure that this buffer has enough remaining space to add the size. Creates\n   * and copies to a new buffer if necessary\n   *\n   * @param size Size to add\n   */\n  private void ensureSize(int size) {\n    if (pos + size > buf.length) {\n      byte[] newBuf = new byte[(buf.length + size) << 1];\n      System.arraycopy(buf, 0, newBuf, 0, pos);\n      buf = newBuf;\n    }\n  }\n  @Override\n  public byte[] getByteArray() {\n    return buf;\n  }\n  @Override\n  public byte[] toByteArray() {\n    return Arrays.copyOf(buf, pos);\n  }\n  @Override\n  public byte[] toByteArray(int offset, int length) {\n    if (offset + length > pos) {\n      throw new IndexOutOfBoundsException(String.format(\"Offset: %d + \"\n          + \"Length: %d exceeds the size of buf : %d\", offset, length, pos));\n    }\n    return Arrays.copyOfRange(buf, offset, length);\n  }\n  @Override\n  public void reset() {\n    pos = 0;\n  }\n  @Override\n  public int getPos() {\n    return pos;\n  }\n  @Override\n  public void write(int b) throws IOException {\n    ensureSize(ByteUtils.SIZE_OF_BYTE);\n    buf[pos] = (byte) b;\n    pos += ByteUtils.SIZE_OF_BYTE;\n  }\n  @Override\n  public void write(byte[] b) throws IOException {\n    ensureSize(b.length);\n    System.arraycopy(b, 0, buf, pos, b.length);\n    pos += b.length;\n  }\n  @Override\n  public void write(byte[] b, int off, int len) throws IOException {\n    ensureSize(len);\n    System.arraycopy(b, off, buf, pos, len);\n    pos += len;\n  }\n  @Override\n  public void writeBoolean(boolean v) throws IOException {\n    ensureSize(ByteUtils.SIZE_OF_BOOLEAN);\n    UNSAFE.putBoolean(buf, BYTE_ARRAY_OFFSET + pos, v);\n    pos += ByteUtils.SIZE_OF_BOOLEAN;\n  }\n<fim_suffix>  @Override\n  public void writeByte(int v) throws IOException {\n    ensureSize(ByteUtils.SIZE_OF_BYTE);\n    UNSAFE.putByte(buf, BYTE_ARRAY_OFFSET + pos, (byte) v);\n    pos += ByteUtils.SIZE_OF_BYTE;\n  }\n  @Override\n  public void writeShort(int v) throws IOException {\n    ensureSize(ByteUtils.SIZE_OF_SHORT);\n    UNSAFE.putShort(buf, BYTE_ARRAY_OFFSET + pos, (short) v);\n    pos += ByteUtils.SIZE_OF_SHORT;\n  }\n  @Override\n  public void writeChar(int v) throws IOException {\n    ensureSize(ByteUtils.SIZE_OF_CHAR);\n    UNSAFE.putChar(buf, BYTE_ARRAY_OFFSET + pos, (char) v);\n    pos += ByteUtils.SIZE_OF_CHAR;\n  }\n  @Override\n  public void writeInt(int v) throws IOException {\n    ensureSize(ByteUtils.SIZE_OF_INT);\n    UNSAFE.putInt(buf, BYTE_ARRAY_OFFSET + pos, v);\n    pos += ByteUtils.SIZE_OF_INT;\n  }\n  @Override\n  public void ensureWritable(int minSize) {\n    if ((pos + minSize) > buf.length) {\n      buf = Arrays.copyOf(buf, Math.max(buf.length << 1, pos + minSize));\n    }\n  }\n  @Override\n  public void skipBytes(int bytesToSkip) {\n    ensureWritable(bytesToSkip);\n    pos += bytesToSkip;\n  }\n  @Override\n  public void writeInt(int pos, int value) {\n    if (pos + ByteUtils.SIZE_OF_INT > this.pos) {\n      throw new IndexOutOfBoundsException(\n          \"writeInt: Tried to write int to position \" + pos\n              + \" but current length is \" + this.pos);\n    }\n    UNSAFE.putInt(buf, BYTE_ARRAY_OFFSET + pos, value);\n  }\n  @Override\n  public void writeLong(long v) throws IOException {\n    ensureSize(ByteUtils.SIZE_OF_LONG);\n    UNSAFE.putLong(buf, BYTE_ARRAY_OFFSET + pos, v);\n    pos += ByteUtils.SIZE_OF_LONG;\n  }\n  @Override\n  public void writeFloat(float v) throws IOException {\n    ensureSize(ByteUtils.SIZE_OF_FLOAT);\n    UNSAFE.putFloat(buf, BYTE_ARRAY_OFFSET + pos, v);\n    pos += ByteUtils.SIZE_OF_FLOAT;\n  }\n  @Override\n  public void writeDouble(double v) throws IOException {\n    ensureSize(ByteUtils.SIZE_OF_DOUBLE);\n    UNSAFE.putDouble(buf, BYTE_ARRAY_OFFSET + pos, v);\n    pos += ByteUtils.SIZE_OF_DOUBLE;\n  }\n  @Override\n  public void writeBytes(String s) throws IOException {\n    // Note that this code is mostly copied from DataOutputStream\n    int len = s.length();\n    ensureSize(len);\n    for (int i = 0; i < len; i++) {\n      int v = s.charAt(i);\n      writeByte(v);\n    }\n  }\n  @Override\n  public void writeChars(String s) throws IOException {\n    // Note that this code is mostly copied from DataOutputStream\n    int len = s.length();\n    ensureSize(len * ByteUtils.SIZE_OF_CHAR);\n    for (int i = 0; i < len; i++) {\n      int v = s.charAt(i);\n      writeChar(v);\n    }\n  }\n  @Override\n  public void writeUTF(String s) throws IOException {\n    // Note that this code is mostly copied from DataOutputStream\n    int strlen = s.length();\n    int utflen = 0;\n    int c;\n    /* use charAt instead of copying String to char array */\n    for (int i = 0; i < strlen; i++) {\n      c = s.charAt(i);<fim_middle>// function below has no smell\n"}