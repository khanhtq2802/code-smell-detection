{"text": "<fim_prefix>   * This implementation returns true if the {@link AudioSink} indicates that encoded audio output\n   * is supported.\n   *\n   * @param channelCount The number of channels in the input media, or {@link Format#NO_VALUE} if\n   *     not known.\n   * @param mimeType The type of input media.\n   * @return Whether passthrough playback is supported.\n   */\n  protected boolean allowPassthrough(int channelCount, String mimeType) {\n    return audioSink.supportsOutput(channelCount, MimeTypes.getEncoding(mimeType));\n  }\n  @Override\n  protected void configureCodec(\n      MediaCodecInfo codecInfo,\n      MediaCodec codec,\n      Format format,\n      MediaCrypto crypto,\n      float codecOperatingRate) {\n    codecMaxInputSize = getCodecMaxInputSize(codecInfo, format, getStreamFormats());\n    log.setTAG(codecInfo.name + \"-\" + TAG); // AMZN_CHANGE_ONELINE\n    codecNeedsDiscardChannelsWorkaround = codecNeedsDiscardChannelsWorkaround(codecInfo.name);\n    codecNeedsEosBufferTimestampWorkaround = codecNeedsEosBufferTimestampWorkaround(codecInfo.name);\n    passthroughEnabled = codecInfo.passthrough;\n    String codecMimeType = codecInfo.mimeType == null ? MimeTypes.AUDIO_RAW : codecInfo.mimeType;\n    MediaFormat mediaFormat =\n        getMediaFormat(format, codecMimeType, codecMaxInputSize, codecOperatingRate);\n    codec.configure(mediaFormat, /* surface= */ null, crypto, /* flags= */ 0);\n    if (passthroughEnabled) {\n      // Store the input MIME type if we're using the passthrough codec.\n      passthroughMediaFormat = mediaFormat;\n      passthroughMediaFormat.setString(MediaFormat.KEY_MIME, format.sampleMimeType);\n    } else {\n      passthroughMediaFormat = null;\n    }\n  }\n  @Override\n  protected @KeepCodecResult int canKeepCodec(\n      MediaCodec codec, MediaCodecInfo codecInfo, Format oldFormat, Format newFormat) {\n    if (getCodecMaxInputSize(codecInfo, newFormat) <= codecMaxInputSize\n        && codecInfo.isSeamlessAdaptationSupported(\n            oldFormat, newFormat, /* isNewFormatComplete= */ true)\n        && oldFormat.encoderDelay == 0\n        && oldFormat.encoderPadding == 0\n        && newFormat.encoderDelay == 0\n        && newFormat.encoderPadding == 0) {\n      return KEEP_CODEC_RESULT_YES_WITHOUT_RECONFIGURATION;\n    } else {\n      return KEEP_CODEC_RESULT_NO;\n    }\n  }\n  @Override\n  public MediaClock getMediaClock() {\n    return this;\n  }\n  @Override\n  protected float getCodecOperatingRate(\n      float operatingRate, Format format, Format[] streamFormats) {\n    // Use the highest known stream sample-rate up front, to avoid having to reconfigure the codec\n    // should an adaptive switch to that stream occur.\n    int maxSampleRate = -1;\n    for (Format streamFormat : streamFormats) {\n      int streamSampleRate = streamFormat.sampleRate;\n      if (streamSampleRate != Format.NO_VALUE) {\n        maxSampleRate = Math.max(maxSampleRate, streamSampleRate);\n      }\n    }\n    return maxSampleRate == -1 ? CODEC_OPERATING_RATE_UNSET : (maxSampleRate * operatingRate);\n  }\n  @Override\n  protected void onCodecInitialized(String name, long initializedTimestampMs,\n      long initializationDurationMs) {\n    eventDispatcher.decoderInitialized(name, initializedTimestampMs, initializationDurationMs);\n  }\n  @Override\n  protected void onInputFormatChanged(Format newFormat) throws ExoPlaybackException {\n    super.onInputFormatChanged(newFormat);\n    eventDispatcher.inputFormatChanged(newFormat);\n    // If the input format is anything other than PCM then we assume that the audio decoder will\n    // output 16-bit PCM.\n    pcmEncoding = MimeTypes.AUDIO_RAW.equals(newFormat.sampleMimeType) ? newFormat.pcmEncoding\n        : C.ENCODING_PCM_16BIT;\n    channelCount = newFormat.channelCount;\n    encoderDelay = newFormat.encoderDelay;\n    encoderPadding = newFormat.encoderPadding;\n  }\n  @Override\n  protected void onOutputFormatChanged(MediaCodec codec, MediaFormat outputFormat)\n      throws ExoPlaybackException {\n    log.i(\"onOutputFormatChanged: outputFormat:\" + outputFormat\n            + \", codec:\" + codec);\n    @C.Encoding int encoding;\n    MediaFormat format;\n    if (passthroughMediaFormat != null) {\n      encoding = MimeTypes.getEncoding(passthroughMediaFormat.getString(MediaFormat.KEY_MIME));\n      format = passthroughMediaFormat;\n    } else {\n      // AMZN_CHANGE_BEGIN\n      // In Amazon Devices, some platform dolby decoders may output mime types depending on the\n      // audio capabilities of the connected device and Dolby settings. So, as a general rule, if\n      // platform decoder is being used instead of OMX.google.raw.decoder, need to\n      // configure audio track based on the output mime type returned by the media codec.\n      format = outputFormat;\n      encoding = AmazonQuirks.isAmazonDevice() ?\n              MimeTypes.getEncoding(format.getString(MediaFormat.KEY_MIME)) : pcmEncoding;\n      // AMZN_CHANGE_END\n    }\n    int channelCount = format.getInteger(MediaFormat.KEY_CHANNEL_COUNT);\n    int sampleRate = format.getInteger(MediaFormat.KEY_SAMPLE_RATE);\n    int[] channelMap;\n    if (codecNeedsDiscardChannelsWorkaround && channelCount == 6 && this.channelCount < 6) {\n      channelMap = new int[this.channelCount];\n      for (int i = 0; i < this.channelCount; i++) {\n        channelMap[i] = i;\n      }\n    } else {\n      channelMap = null;\n    }\n    try {\n      audioSink.configure(encoding, channelCount, sampleRate, 0, channelMap, encoderDelay,\n          encoderPadding);\n    } catch (AudioSink.ConfigurationException e) {\n      throw ExoPlaybackException.createForRenderer(e, getIndex());\n    }\n  }\n  /**\n   * Called when the audio session id becomes known. The default implementation is a no-op. One\n   * reason for overriding this method would be to instantiate and enable a {@link Virtualizer} in\n   * order to spatialize the audio channels. For this use case, any {@link Virtualizer} instances\n   * should be released in {@link #onDisabled()} (if not before).\n   *\n   * @see AudioSink.Listener#onAudioSessionId(int)\n   */\n  protected void onAudioSessionId(int audioSessionId) {\n    // Do nothing.\n  }\n  /**\n   * @see AudioSink.Listener#onPositionDiscontinuity()\n   */\n  protected void onAudioTrackPositionDiscontinuity() {\n    // Do nothing.\n  }\n  /**\n   * @see AudioSink.Listener#onUnderrun(int, long, long)\n   */\n  protected void onAudioTrackUnderrun(int bufferSize, long bufferSizeMs,\n      long elapsedSinceLastFeedMs) {\n    // Do nothing.\n  }\n  @Override\n  protected void onEnabled(boolean joining) throws ExoPlaybackException {\n    super.onEnabled(joining);\n    eventDispatcher.enabled(decoderCounters);\n    int tunnelingAudioSessionId = getConfiguration().tunnelingAudioSessionId;\n    if (tunnelingAudioSessionId != C.AUDIO_SESSION_ID_UNSET) {\n      audioSink.enableTunnelingV21(tunnelingAudioSessionId);\n    } else {\n      audioSink.disableTunneling();\n    }\n  }\n  @Override\n  protected void onStreamChanged(Format[] formats, long offsetUs) throws ExoPlaybackException {\n    super.onStreamChanged(formats, offsetUs);\n    if (lastInputTimeUs != C.TIME_UNSET) {\n      if (pendingStreamChangeCount == pendingStreamChangeTimesUs.length) {\n        Log.w(\n            TAG,\n            \"Too many stream changes, so dropping change at \"\n                + pendingStreamChangeTimesUs[pendingStreamChangeCount - 1]);\n      } else {\n        pendingStreamChangeCount++;\n      }\n      pendingStreamChangeTimesUs[pendingStreamChangeCount - 1] = lastInputTimeUs;\n    }\n  }\n  @Override\n  protected void onPositionReset(long positionUs, boolean joining) throws ExoPlaybackException {\n    super.onPositionReset(positionUs, joining);\n    audioSink.reset();\n    currentPositionUs = positionUs;\n    allowFirstBufferPositionDiscontinuity = true;\n    allowPositionDiscontinuity = true;\n    lastInputTimeUs = C.TIME_UNSET;\n    pendingStreamChangeCount = 0;\n  }\n  @Override\n  protected void onStarted() {\n    super.onStarted();\n    audioSink.play();\n  }\n<fim_suffix>  @Override\n  protected void onStopped() {\n    updateCurrentPosition();\n    audioSink.pause();\n    super.onStopped();\n  }<fim_middle>// function below has no smell\n"}