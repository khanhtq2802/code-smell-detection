{"text": "<fim_prefix>\n<fim_suffix>    class Cel4rreg {\n        long seghigh;\n        long seglow;\n        int p_dsafmt = -1;\n        long p_dsaptr;\n        RegisterSet regs;\n        /**\n         * Creates the instance and attempts to locate the registers.\n         */\n        Cel4rreg() {\n            /* Debug option - before we do anything else, try using the old svcdump code */\n            String useSvcdump = System.getProperty(\"zebedee.use.svcdump\");\n            if (useSvcdump != null && useSvcdump.equals(\"true\")) {\n                getRegistersFromSvcdump();\n                return;\n            }\n            /*\n             * Try and get the registers from the following locations:\n             *\n             * 1) RTM2 work area\n             * 2) BPXGMSTA service\n             * 3) linkage stack entries\n             * 4) TCB\n             * 5) Usta\n             *\n             * if any succeeds we return otherwise move to the next location.\n             */\n            int whereCount = 0;\n            try {\n                if ((regs = getRegistersFromRTM2()) != null && whereCount++ >= whereSkip) {\n                    whereFound = \"RTM2\";\n                    failingRegisters = regs;\n                    registers = regs;\n                    return;\n                }\n            } catch (IOException e) {\n                throw new Error(\"oops: \" + e);\n            }\n            /* If we still have not found a dsa, invoke kernel svs */\n            try {\n                if ((regs = getRegistersFromBPXGMSTA()) != null && whereCount++ >= whereSkip) {\n                    whereFound = regs.whereFound();\n                    if (whereFound == null)\n                        whereFound = \"BPXGMSTA\";\n                    if (tcb.tcbcmp() != 0)\n                        failingRegisters = regs;\n                    registers = regs;\n                    return;\n                }\n            } catch (IOException e) {\n                //throw new Error(\"oops: \" + e);\n            }\n            try {\n                if ((regs = getRegistersFromLinkageStack()) != null && whereCount++ >= whereSkip) {\n                    whereFound = \"Linkage\";\n                    if (tcb.tcbcmp() != 0)\n                        failingRegisters = regs;\n                    registers = regs;\n                    return;\n                }\n            } catch (IOException e) {\n                log.logp(Level.WARNING,\"com.ibm.j9ddr.corereaders.tdump.zebedee.le.Caa.Cel4rreg\", \"Cel4rreg\",\"Unexepected exception\", e);\n                throw new Error(\"Unexpected IOException: \" + e);\n            }\n            try {\n                if ((regs = getRegistersFromTCB()) != null && whereCount++ >= whereSkip) {\n                    whereFound = \"TCB\";\n                    if (tcb.tcbcmp() != 0)\n                        failingRegisters = regs;\n                    registers = regs;\n                    return;\n                }\n            } catch (IOException e) {\n                throw new Error(\"oops: \" + e);\n            }\n            try {\n                if (is64bit) {\n                    /* This is from celqrreg.plx370: \"Get the save R4 from a NOSTACK call\" */\n                    long lca = CeexlaaTemplate.getCeelaa_lca64(inputStream, laa);\n                    p_dsaptr = CeelcaTemplate.getCeelca_savstack(inputStream, lca);\n                    log.fine(\"p_dsaptr from lca = \" + hex(p_dsaptr));\n                    p_dsafmt = stackdirection = CEECAASTACK_DOWN;\n                    if (validateDSA() == 0 && whereCount++ >= whereSkip) {\n                        whereFound = \"LCA\";\n                        return;\n                    }\n                }\n            } catch (IOException e) {\n                throw new Error(\"oops: \" + e);\n            }\n            /* Last ditch */\n            try {\n                if ((regs = getRegistersFromUsta()) != null && whereCount++ >= whereSkip) {\n                    whereFound = regs.whereFound();\n                    if (tcb.tcbcmp() != 0)\n                        failingRegisters = regs;\n                    registers = regs;\n                    return;\n                }\n            } catch (IOException e) {\n            }\n            whereFound = \"not found\";\n        }\n        /**\n         * Try and get the registers from the RTM2 work area. Returns null if none found. As a\n         * side-effect it also sets the stackdirection.\n         */\n        private RegisterSet getRegistersFromRTM2() throws IOException {\n            int level = ceecaalevel();\n            log.finer(\"caa level is \" + level);\n            /* If the CAA level is 13 or greater, get stack direction from \n             * CAA.  For older releases or the dummy CAA, default stack \n             * direction to UP.\n             */\n            if (is64bit) {\n                /* Always use downstack in 64-bit mode? */\n                stackdirection = CEECAASTACK_DOWN;\n                log.finer(\"stack direction is down\");\n            } else if (level >= 13) { /* If LE 2.10 or higher */\n                /* Obtain dsa format from the CAA */\n                stackdirection = ceecaa_stackdirection();\n                log.finer(\"stack direction is \" + (stackdirection == CEECAASTACK_UP ? \"up\" : \"down\"));\n            } else {\n                stackdirection = CEECAASTACK_UP;\n                log.finer(\"stack direction is up\");\n            }\n            if ((stackdirection == CEECAASTACK_DOWN) && !is64bit) {\n                try {\n                    long tempptr = ceecaasmcb();\t\t\t//the ceecaasmcb call is not currently supported for 64 bit CAAs\n                    seghigh = SmcbTemplate.getSmcb_dsbos(inputStream, tempptr);\n                    seglow = CeexstkhTemplate.getStkh_stackfloor(inputStream, seghigh);\n                } catch (Exception e) {\n                    //throw new Error(\"oops: \" + e);\n                    return null;\n                }\n            }\n            /* At this point, a valid CAA has been obtained. Access the RTM2 to obtain the DSA. */\n            long rtm2ptr = tcb.tcbrtwa();\n            if (rtm2ptr != 0) {\n                try {\n                    log.finer(\"found some rtm2 registers\");\n                    RegisterSet regs = new RegisterSet();\n                    long rtm2grs = rtm2ptr + Ihartm2aTemplate.getRtm2ereg$offset();\n                    long rtm2grshi = rtm2ptr + Ihartm2aTemplate.getRtm2g64h$offset();\n                    for (int i = 0; i < 16; i++) {\n                        long low = space.readUnsignedInt(rtm2grs + i*4);\n                        long high = is64bit ? space.readUnsignedInt(rtm2grshi + i*4) : 0;\n                        regs.setRegister(i, (high << 32) | low);\n                    }\n                    long rtm2psw = rtm2ptr + Ihartm2aTemplate.getRtm2apsw$offset();\n                    regs.setPSW(space.readLong(rtm2psw));\n                    if (registersValid(regs)) {\n                        log.finer(\"found good dsa in rtm2\");\n                    } else {\n                        log.finer(\"bad dsa in rtm2\");\n                        regs = null;\n                    }\n                    return regs;\n                } catch (IOException e) {\n                    throw e;\n                } catch (Exception e) {\n                    throw new Error(\"oops: \" + e);\n                }\n            } else {\n                log.finer(\"failed to get registers from rtm2\");\n                return null;\n            }\n        }\n        /**\n         * Validates the given register set with retry for down stack\n         */\n        private boolean registersValid(RegisterSet regs) throws IOException {\n            if (regs == null)\n                return false;\n            p_dsafmt = stackdirection;\n            if (p_dsafmt == CEECAASTACK_DOWN) {\n                p_dsaptr = regs.getRegisterAsAddress(4);\n                log.finer(\"p_dsaptr from reg 4 = \" + hex(p_dsaptr));\n            } else {\n                p_dsaptr = regs.getRegisterAsAddress(13);\n                log.finer(\"p_dsaptr from reg 13 = \" + hex(p_dsaptr));\n            }\n            int lastrc = validateDSA();\n            if (lastrc == 0) {\n                log.finer(\"found valid dsa\");\n                return true;\n            } else {\n                if (stackdirection == CEECAASTACK_DOWN) {\n                    p_dsaptr = regs.getRegisterAsAddress(13);\n                    log.finer(\"p_dsaptr from reg 13 (again) = \" + hex(p_dsaptr));\n                    p_dsafmt = CEECAASTACK_UP;\n                    lastrc = validateDSA();\n                    if (lastrc == WARNING) {\n                        lastrc = validateDSA();<fim_middle>// class below is blob\n"}