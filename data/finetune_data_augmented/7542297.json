{"text": "<fim_prefix>/*\n * Copyright 2010-2012 VMware and contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.springsource.loaded;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport org.objectweb.asm.Type;\nimport org.objectweb.asm.tree.MethodNode;\n/**\n * Captures the information about the reloaded parts of a type that vary each time a new version is loaded.\n *\n * @author Andy Clement\n * @since 0.5.0\n */\npublic class CurrentLiveVersion {\n\tprivate static Logger log = Logger.getLogger(CurrentLiveVersion.class.getName());\n\t// Which reloadable type this represents the live version of\n\tfinal ReloadableType reloadableType;\n\t// Type descriptor for this live version\n\tfinal TypeDescriptor typeDescriptor;\n\t// 'stamp' (i.e. suffix) for this version\n\tfinal String versionstamp;\n\tpublic final IncrementalTypeDescriptor incrementalTypeDescriptor;\n\tString dispatcherName;\n\tbyte[] dispatcher;\n\tClass<?> dispatcherClass;\n\tObject dispatcherInstance;\n\tString executorName;\n\tbyte[] executor;\n\tClass<?> executorClass;\n\tTypeDelta typeDelta;\n\tprivate Method staticInitializer;\n\tprivate boolean haveLookedForStaticInitializer;\n\tpublic boolean staticInitializedNeedsRerunningOnDefine = false;\n<fim_suffix>\tpublic CurrentLiveVersion(ReloadableType reloadableType, String versionstamp, byte[] newbytedata) {\n\t\tif (GlobalConfiguration.logging && log.isLoggable(Level.FINER)) {\n\t\t\tlog.entering(\"CurrentLiveVersion\", \"<init>\", \" new version of \" + reloadableType.getName()\n\t\t\t\t\t+ \" loaded, version stamp '\"\n\t\t\t\t\t+ versionstamp + \"'\");\n\t\t}\n\t\tthis.reloadableType = reloadableType;\n\t\tthis.typeDescriptor = reloadableType.getTypeRegistry().getExtractor().extract(newbytedata, true);\n\t\tthis.versionstamp = versionstamp;\n\t\tif (GlobalConfiguration.assertsMode) {\n\t\t\tif (!this.typeDescriptor.getName().equals(reloadableType.typedescriptor.getName())) {\n\t\t\t\tthrow new IllegalStateException(\"New version has wrong name.  Expected \"\n\t\t\t\t\t\t+ reloadableType.typedescriptor.getName()\n\t\t\t\t\t\t+ \" but was \" + typeDescriptor.getName());\n\t\t\t}\n\t\t}\n\t\tnewbytedata = GlobalConfiguration.callsideRewritingOn ? MethodInvokerRewriter.rewrite(\n\t\t\t\treloadableType.typeRegistry,\n\t\t\t\tnewbytedata) : newbytedata;\n\t\tthis.incrementalTypeDescriptor = new IncrementalTypeDescriptor(reloadableType.typedescriptor);\n\t\tthis.incrementalTypeDescriptor.setLatestTypeDescriptor(this.typeDescriptor);\n\t\t// Executors for interfaces simply hold annotations\n\t\tthis.executor = reloadableType.getTypeRegistry().executorBuilder.createFor(reloadableType, versionstamp,\n\t\t\t\ttypeDescriptor,\n\t\t\t\tnewbytedata);\n\t\tif (GlobalConfiguration.classesToDump != null\n\t\t\t\t&& GlobalConfiguration.classesToDump.contains(reloadableType.getSlashedName())) {\n\t\t\tUtils.dump(Utils.getExecutorName(reloadableType.getName(), versionstamp).replace('.', '/'), this.executor);\n\t\t}\n\t\t// DEFAULT METHODS - REMOVE THE IF\n\t\tif (!typeDescriptor.isInterface()) {\n\t\t\tthis.dispatcherName = Utils.getDispatcherName(reloadableType.getName(), versionstamp);\n\t\t\tthis.executorName = Utils.getExecutorName(reloadableType.getName(), versionstamp);\n\t\t\tthis.dispatcher = DispatcherBuilder.createFor(reloadableType, incrementalTypeDescriptor, versionstamp);\n\t\t}\n\t\treloadableType.typeRegistry.checkChildClassLoader(reloadableType);\n\t\tdefine();\n\t}\n\t/**\n\t * Defines this version. Called up front but can also be called later if the ChildClassLoader in a type registry is\n\t * discarded and recreated.\n\t */\n\tpublic void define() {\n\t\tstaticInitializer = null;\n\t\thaveLookedForStaticInitializer = false;\n\t\t// DEFAULT METHODS - remove the if\n\t\tif (!typeDescriptor.isInterface()) {\n\t\t\ttry {\n\t\t\t\tdispatcherClass = reloadableType.typeRegistry.defineClass(dispatcherName, dispatcher, false);\n\t\t\t}\n\t\t\tcatch (RuntimeException t) {\n\t\t\t\t// TODO check for something strange.  something to do with the file detection misbehaving, see the same file attempted to be reloaded twice...\n\t\t\t\tif (t.getMessage().indexOf(\"duplicate class definition\") == -1) {\n\t\t\t\t\tthrow t;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tt.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttry {\n\t\t\texecutorClass = reloadableType.typeRegistry.defineClass(executorName, executor, false);\n\t\t}\n\t\tcatch (RuntimeException t) {\n\t\t\t// TODO check for something strange.  something to do with the file detection misbehaving, see the same file attempted to be reloaded twice...\n\t\t\tif (t.getMessage().indexOf(\"duplicate class definition\") == -1) {\n\t\t\t\tthrow t;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tt.printStackTrace();\n\t\t\t}\n\t\t}\n\t\t// DEFAULT METHODS - remove the if\n\t\tif (!typeDescriptor.isInterface()) {\n\t\t\ttry {\n\t\t\t\tdispatcherInstance = dispatcherClass.newInstance();\n\t\t\t}\n\t\t\tcatch (InstantiationException e) {\n\t\t\t\tthrow new RuntimeException(\"Unable to build dispatcher class instance\", e);\n\t\t\t}\n\t\t\tcatch (IllegalAccessException e) {\n\t\t\t\tthrow new RuntimeException(\"Unable to build dispatcher class instance\", e);\n\t\t\t}\n\t\t}\n\t}\n\tpublic MethodMember getReloadableMethod(String name, String descriptor) {\n\t\t// Look through the methods on the latest loaded version and find the method we want\n\t\tMethodMember[] methods = incrementalTypeDescriptor.getLatestTypeDescriptor().getMethods();\n\t\tfor (MethodMember rmethod : methods) {\n\t\t\tif (rmethod.getName().equals(name)) {\n\t\t\t\tif (descriptor.equals(rmethod.getDescriptor())) {\n\t\t\t\t\treturn rmethod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\t// TODO should be caching the result in the MethodMember objects for speed\n\tpublic Method getExecutorMethod(MethodMember methodMember) {\n\t\tString executorDescriptor;\n\t\tString name;\n\t\t//What to search for:\n\t\tif (methodMember.isConstructor()) {\n\t\t\tname = Constants.mInitializerName;\n\t\t}\n\t\telse {\n\t\t\tname = methodMember.getName();\n\t\t}\n\t\texecutorDescriptor = getExecutorDescriptor(methodMember);\n\t\t//Search for it:\n\t\tif (executorClass != null) {\n\t\t\tMethod[] executorMethods = executorClass.getDeclaredMethods();\n\t\t\tfor (Method executor : executorMethods) {\n\t\t\t\tif (executor.getName().equals(name) && Type.getMethodDescriptor(executor).equals(executorDescriptor)) {\n\t\t\t\t\treturn executor;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\tprivate String getExecutorDescriptor(MethodMember methodMember) {\n\t\tType[] params = Type.getArgumentTypes(methodMember.getDescriptor());\n\t\tType[] newParametersArray = params;\n\t\tif (!methodMember.isStatic()) {\n\t\t\tnewParametersArray = new Type[params.length + 1];\n\t\t\tSystem.arraycopy(params, 0, newParametersArray, 1, params.length);\n\t\t\tnewParametersArray[0] = Type.getType(reloadableType.getClazz());\n\t\t}\n\t\tString executorDescriptor = Type.getMethodDescriptor(Type.getReturnType(methodMember.getDescriptor()),\n\t\t\t\tnewParametersArray);\n\t\treturn executorDescriptor;\n\t}\n\t@Override\n\tpublic String toString() {\n\t\treturn \"CurrentLiveVersion [reloadableType=\" + reloadableType + \", typeDescriptor=\" + typeDescriptor\n\t\t\t\t+ \", versionstamp=\"\n\t\t\t\t+ versionstamp + \", dispatcherName=\" + dispatcherName + \", executorName=\" + executorName + \"]\";\n\t}\n\tpublic Class<?> getExecutorClass() {\n\t\treturn executorClass;\n\t}\n\tpublic String getVersionStamp() {\n\t\treturn versionstamp;\n\t}\n\tpublic Field getExecutorField(String name) throws SecurityException, NoSuchFieldException {\n\t\treturn executorClass.getDeclaredField(name);\n\t}\n\tpublic TypeDelta getTypeDelta() {\n\t\treturn typeDelta;\n\t}<fim_middle>// function below is long method\n"}