{"text": "<fim_prefix>/*\n * Copyright (c) 2008, 2018, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\npackage sun.nio.fs;\n\nimport static sun.nio.fs.WindowsNativeDispatcher.*;\nimport static sun.nio.fs.WindowsConstants.*;\n\n/**\n * Security related utility methods.\n */\n\nclass WindowsSecurity {\n    private WindowsSecurity() { }\n\n    // opens process token for given access\n<fim_suffix>    private static long openProcessToken(int access) {\n        try {\n            return OpenProcessToken(GetCurrentProcess(), access);\n        } catch (WindowsException x) {\n            return 0L;\n        }\n    }\n\n    /**\n     * Returns the access token for this process with TOKEN_DUPLICATE access\n     */\n    static final long processTokenWithDuplicateAccess =\n        openProcessToken(TOKEN_DUPLICATE);\n\n    /**\n     * Returns the access token for this process with TOKEN_QUERY access\n     */\n    static final long processTokenWithQueryAccess =\n        openProcessToken(TOKEN_QUERY);\n\n    /**\n     * Returned by enablePrivilege when code may require a given privilege.\n     * The drop method should be invoked after the operation completes so as\n     * to revert the privilege.\n     */\n    static interface Privilege {\n        void drop();\n    }\n\n    /**\n     * Attempts to enable the given privilege for this method.\n     */\n    static Privilege enablePrivilege(String priv) {\n        final long pLuid;\n        try {\n            pLuid = LookupPrivilegeValue(priv);\n        } catch (WindowsException x) {\n            // indicates bug in caller\n            throw new AssertionError(x);\n        }\n\n        long hToken = 0L;\n        boolean impersontating = false;\n        boolean elevated = false;\n        try {\n            hToken = OpenThreadToken(GetCurrentThread(),\n                                     TOKEN_ADJUST_PRIVILEGES, false);\n            if (hToken == 0L && processTokenWithDuplicateAccess != 0L) {\n                hToken = DuplicateTokenEx(processTokenWithDuplicateAccess,\n                    (TOKEN_ADJUST_PRIVILEGES|TOKEN_IMPERSONATE));\n                SetThreadToken(0L, hToken);\n                impersontating = true;\n            }\n\n            if (hToken != 0L) {\n                AdjustTokenPrivileges(hToken, pLuid, SE_PRIVILEGE_ENABLED);\n                elevated = true;\n            }\n        } catch (WindowsException x) {\n            // nothing to do, privilege not enabled\n        }\n\n        final long token = hToken;\n        final boolean stopImpersontating = impersontating;\n        final boolean needToRevert = elevated;\n\n        return () -> {\n            try {\n                if (token != 0L) {\n                    try {\n                        if (stopImpersontating)\n                            SetThreadToken(0L, 0L);\n                        else if (needToRevert)\n                            AdjustTokenPrivileges(token, pLuid, 0);\n                    } catch (WindowsException x) {\n                        // should not happen\n                        throw new AssertionError(x);\n                    } finally {\n                        CloseHandle(token);\n                    }\n                }\n            } finally {\n                LocalFree(pLuid);\n            }\n        };\n    }\n\n    /**\n     * Check the access right against the securityInfo in the current thread.\n     */\n    static boolean checkAccessMask(long securityInfo, int accessMask,\n        int genericRead, int genericWrite, int genericExecute, int genericAll)\n        throws WindowsException\n    {\n        int privileges = TOKEN_QUERY;\n        long hToken = OpenThreadToken(GetCurrentThread(), privileges, false);\n        if (hToken == 0L && processTokenWithDuplicateAccess != 0L)\n            hToken = DuplicateTokenEx(processTokenWithDuplicateAccess,\n                privileges);\n\n        boolean hasRight = false;\n        if (hToken != 0L) {\n            try {\n                hasRight = AccessCheck(hToken, securityInfo, accessMask,\n                    genericRead, genericWrite, genericExecute, genericAll);\n            } finally {\n                CloseHandle(hToken);\n            }\n        }\n        return hasRight;\n    }\n\n}<fim_middle>// function below is feature envy\n"}