{"text": "<fim_prefix>\t\treturn forMethodParameter(methodParameter, (Type) null);\n\t}\n\t/**\n\t * Return a {@link ResolvableType} for the specified {@link MethodParameter} with a\n\t * given implementation type. Use this variant when the class that declares the method\n\t * includes generic parameter variables that are satisfied by the implementation type.\n\t * @param methodParameter the source method parameter (must not be {@code null})\n\t * @param implementationType the implementation type\n\t * @return a {@link ResolvableType} for the specified method parameter\n\t * @see #forMethodParameter(MethodParameter)\n\t */\n\tpublic static ResolvableType forMethodParameter(MethodParameter methodParameter,\n\t\t\t@Nullable ResolvableType implementationType) {\n\t\tAssert.notNull(methodParameter, \"MethodParameter must not be null\");\n\t\timplementationType = (implementationType != null ? implementationType :\n\t\t\t\tforType(methodParameter.getContainingClass()));\n\t\tResolvableType owner = implementationType.as(methodParameter.getDeclaringClass());\n\t\treturn forType(null, new MethodParameterTypeProvider(methodParameter), owner.asVariableResolver()).\n\t\t\t\tgetNested(methodParameter.getNestingLevel(), methodParameter.typeIndexesPerLevel);\n\t}\n\t/**\n\t * Return a {@link ResolvableType} for the specified {@link MethodParameter},\n\t * overriding the target type to resolve with a specific given type.\n\t * @param methodParameter the source method parameter (must not be {@code null})\n\t * @param targetType the type to resolve (a part of the method parameter's type)\n\t * @return a {@link ResolvableType} for the specified method parameter\n\t * @see #forMethodParameter(Method, int)\n\t */\n\tpublic static ResolvableType forMethodParameter(MethodParameter methodParameter, @Nullable Type targetType) {\n\t\tAssert.notNull(methodParameter, \"MethodParameter must not be null\");\n\t\tResolvableType owner = forType(methodParameter.getContainingClass()).as(methodParameter.getDeclaringClass());\n\t\treturn forType(targetType, new MethodParameterTypeProvider(methodParameter), owner.asVariableResolver()).\n\t\t\t\tgetNested(methodParameter.getNestingLevel(), methodParameter.typeIndexesPerLevel);\n\t}\n\t/**\n\t * Resolve the top-level parameter type of the given {@code MethodParameter}.\n\t * @param methodParameter the method parameter to resolve\n\t * @since 4.1.9\n\t * @see MethodParameter#setParameterType\n\t */\n\tstatic void resolveMethodParameter(MethodParameter methodParameter) {\n\t\tAssert.notNull(methodParameter, \"MethodParameter must not be null\");\n\t\tResolvableType owner = forType(methodParameter.getContainingClass()).as(methodParameter.getDeclaringClass());\n\t\tmethodParameter.setParameterType(\n\t\t\t\tforType(null, new MethodParameterTypeProvider(methodParameter), owner.asVariableResolver()).resolve());\n\t}\n\t/**\n\t * Return a {@link ResolvableType} as a array of the specified {@code componentType}.\n\t * @param componentType the component type\n\t * @return a {@link ResolvableType} as an array of the specified component type\n\t */\n\tpublic static ResolvableType forArrayComponent(ResolvableType componentType) {\n\t\tAssert.notNull(componentType, \"Component type must not be null\");\n\t\tClass<?> arrayClass = Array.newInstance(componentType.resolve(), 0).getClass();\n\t\treturn new ResolvableType(arrayClass, null, null, componentType);\n\t}\n\t/**\n\t * Return a {@link ResolvableType} for the specified {@link Type}.\n\t * <p>Note: The resulting {@link ResolvableType} instance may not be {@link Serializable}.\n\t * @param type the source type (potentially {@code null})\n\t * @return a {@link ResolvableType} for the specified {@link Type}\n\t * @see #forType(Type, ResolvableType)\n\t */\n\tpublic static ResolvableType forType(@Nullable Type type) {\n\t\treturn forType(type, null, null);\n\t}\n\t/**\n\t * Return a {@link ResolvableType} for the specified {@link Type} backed by the given\n\t * owner type.\n\t * <p>Note: The resulting {@link ResolvableType} instance may not be {@link Serializable}.\n\t * @param type the source type or {@code null}\n\t * @param owner the owner type used to resolve variables\n\t * @return a {@link ResolvableType} for the specified {@link Type} and owner\n\t * @see #forType(Type)\n\t */\n\tpublic static ResolvableType forType(@Nullable Type type, @Nullable ResolvableType owner) {\n\t\tVariableResolver variableResolver = null;\n\t\tif (owner != null) {\n\t\t\tvariableResolver = owner.asVariableResolver();\n\t\t}\n\t\treturn forType(type, variableResolver);\n\t}\n\t/**\n\t * Return a {@link ResolvableType} for the specified {@link ParameterizedTypeReference}.\n\t * <p>Note: The resulting {@link ResolvableType} instance may not be {@link Serializable}.\n\t * @param typeReference the reference to obtain the source type from\n\t * @return a {@link ResolvableType} for the specified {@link ParameterizedTypeReference}\n\t * @since 4.3.12\n\t * @see #forType(Type)\n\t */\n\tpublic static ResolvableType forType(ParameterizedTypeReference<?> typeReference) {\n\t\treturn forType(typeReference.getType(), null, null);\n\t}\n\t/**\n\t * Return a {@link ResolvableType} for the specified {@link Type} backed by a given\n\t * {@link VariableResolver}.\n\t * @param type the source type or {@code null}\n\t * @param variableResolver the variable resolver or {@code null}\n\t * @return a {@link ResolvableType} for the specified {@link Type} and {@link VariableResolver}\n\t */\n\tstatic ResolvableType forType(@Nullable Type type, @Nullable VariableResolver variableResolver) {\n\t\treturn forType(type, null, variableResolver);\n\t}\n\t/**\n\t * Return a {@link ResolvableType} for the specified {@link Type} backed by a given\n\t * {@link VariableResolver}.\n\t * @param type the source type or {@code null}\n\t * @param typeProvider the type provider or {@code null}\n\t * @param variableResolver the variable resolver or {@code null}\n\t * @return a {@link ResolvableType} for the specified {@link Type} and {@link VariableResolver}\n\t */\n<fim_suffix>\tstatic ResolvableType forType(\n\t\t\t@Nullable Type type, @Nullable TypeProvider typeProvider, @Nullable VariableResolver variableResolver) {\n\t\tif (type == null && typeProvider != null) {\n\t\t\ttype = SerializableTypeWrapper.forTypeProvider(typeProvider);\n\t\t}\n\t\tif (type == null) {\n\t\t\treturn NONE;\n\t\t}\n\t\t// For simple Class references, build the wrapper right away -\n\t\t// no expensive resolution necessary, so not worth caching...\n\t\tif (type instanceof Class) {\n\t\t\treturn new ResolvableType(type, typeProvider, variableResolver, (ResolvableType) null);\n\t\t}\n\t\t// Purge empty entries on access since we don't have a clean-up thread or the like.\n\t\tcache.purgeUnreferencedEntries();\n\t\t// Check the cache - we may have a ResolvableType which has been resolved before...\n\t\tResolvableType resultType = new ResolvableType(type, typeProvider, variableResolver);\n\t\tResolvableType cachedType = cache.get(resultType);\n\t\tif (cachedType == null) {\n\t\t\tcachedType = new ResolvableType(type, typeProvider, variableResolver, resultType.hash);\n\t\t\tcache.put(cachedType, cachedType);\n\t\t}\n\t\tresultType.resolved = cachedType.resolved;\n\t\treturn resultType;\n\t}<fim_middle>// function below is long method\n"}