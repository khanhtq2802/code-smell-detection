{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.chukwa.util;\n\n\nimport java.util.Random;\nimport java.util.regex.*;\nimport org.apache.hadoop.chukwa.*;\nimport org.apache.hadoop.chukwa.datacollection.*;\nimport org.apache.hadoop.chukwa.datacollection.adaptor.*;\nimport org.apache.hadoop.conf.Configuration;\n\n/**\n * Emits chunks at a roughly constant data rate. Chunks are in a very particular\n * format: the output data is verifiable, but sufficiently non-deterministic\n * that two different instances of this adaptor are very likely to have\n * distinct outputs.\n * \n * \n * Each chunk is full of random bytes; the randomness comes from \n * an instance of java.util.Random seeded with the offset xored\n * with the time-of-generation. The time of generation is stored, big-endian,\n * in the first eight bytes of each chunk.\n */\n<fim_suffix>public class ConstRateAdaptor extends AbstractAdaptor implements Runnable {\n\n  private int SLEEP_VARIANCE = 200;\n  private int MIN_SLEEP = 300;\n\n  private long offset;\n  private int bytesPerSec;\n\n  Random timeCoin;\n  long seed;\n  \n  private volatile boolean stopping = false;\n\n  public String getCurrentStatus() {\n    return type.trim() + \" \" + bytesPerSec + \" \" + seed;\n  }\n\n  public void start(long offset) throws AdaptorException {\n\n    this.offset = offset;\n    Configuration conf = control.getConfiguration();\n    MIN_SLEEP = conf.getInt(\"constAdaptor.minSleep\", MIN_SLEEP);\n    SLEEP_VARIANCE = conf.getInt(\"constAdaptor.sleepVariance\", SLEEP_VARIANCE);\n    \n    timeCoin = new Random(seed);\n    long o =0;\n    while(o < offset)\n      o += (int) ((timeCoin.nextInt(SLEEP_VARIANCE) + MIN_SLEEP) *\n          (long) bytesPerSec / 1000L) + 8;\n    new Thread(this).start(); // this is a Thread.start\n  }\n\n  public String parseArgs(String bytesPerSecParam) {\n    try {\n      Matcher m = Pattern.compile(\"([0-9]+)(?:\\\\s+([0-9]+))?\\\\s*\").matcher(bytesPerSecParam);\n      if(!m.matches())\n        return null;\n      bytesPerSec = Integer.parseInt(m.group(1));\n      String rate = m.group(2);\n      if(rate != null)\n        seed = Long.parseLong(m.group(2));\n      else\n        seed = System.currentTimeMillis();\n    } catch (NumberFormatException e) {\n      //(\"bad argument to const rate adaptor: [\"  + bytesPerSecParam + \"]\");\n      return null;\n    }\n    return bytesPerSecParam;\n  }\n\n  public void run() {\n    try {\n      while (!stopping) {\n        int MSToSleep = timeCoin.nextInt(SLEEP_VARIANCE) + MIN_SLEEP; \n        int arraySize = (int) (MSToSleep * (long) bytesPerSec / 1000L) + 8;\n        ChunkImpl evt = nextChunk(arraySize );\n\n        dest.add(evt);\n\n        Thread.sleep(MSToSleep);\n      } // end while\n    } catch (InterruptedException ie) {\n    } // abort silently\n  }\n\n  public ChunkImpl nextChunk(int arraySize) {\n    byte[] data = new byte[arraySize];\n    Random dataPattern = new Random(offset ^ seed);\n    long s = this.seed;\n    offset += data.length;\n    dataPattern.nextBytes(data);\n    for(int i=0; i < 8; ++i)  {\n      data[7-i] = (byte) (s & 0xFF);\n      s >>= 8;\n    }\n    ChunkImpl evt = new ChunkImpl(type, \"random (\"+ this.seed+\")\", offset, data,\n        this);\n    return evt;\n  }\n\n  public String toString() {\n    return \"const rate \" + type;\n  }\n\n  @Override\n  public long shutdown(AdaptorShutdownPolicy shutdownPolicy) {\n    stopping = true;\n    return offset;\n  }\n  \n  public static boolean checkChunk(Chunk chunk) {\n    byte[] data = chunk.getData();\n    byte[] correctData = new byte[data.length];\n    \n    long seed = 0;\n    for(int i=0; i < 8; ++i) \n      seed = (seed << 8) | (0xFF & data[i] );\n\n    seed ^= (chunk.getSeqID() - data.length);\n    Random dataPattern = new Random(seed);\n    dataPattern.nextBytes(correctData);\n    for(int i=8; i < data.length ; ++i) \n      if(data [i] != correctData[i])\n        return false;\n     \n    return true;\n  }\n  \n  void test_init(String type) {\n    this.type = type;\n    seed = System.currentTimeMillis();\n  }\n}<fim_middle>// class below is blob\n"}