{"text": "<fim_prefix>\t\t\treturn null;\n\t\tString textKey = searchForExternalizedValue( element, propIDName,\n\t\t\t\tlocale );\n\t\tif ( !StringUtil.isBlank( textKey ) )\n\t\t\treturn textKey;\n\t\t// use static text.\n\t\treturn element.getStringProperty( element.getRoot( ), propName );\n\t}\n\t/**\n\t * Returns externalized value.\n\t * \n\t * @param module\n\t *            module\n\t * @param structure\n\t *            structure.\n\t * @param propIDName\n\t *            ID of property\n\t * @param propName\n\t *            Name of property\n\t * @param locale\n\t *            the locale\n\t * @return externalized value.\n\t */\n\tpublic static String getExternalizedStructValue( DesignElement element,\n\t\t\tIStructure structure, String propIDName, String propName,\n\t\t\tULocale locale )\n\t{\n\t\tif ( structure == null )\n\t\t\treturn null;\n\t\tString textKey = (String) structure.getProperty( element.getRoot( ), propIDName );\n\t\tif ( !StringUtil.isBlank( textKey ) )\n\t\t{\n\t\t\tDesignElement temp = element;\n\t\t\tString externalizedText = null;\n\t\t\twhile ( temp != null )\n\t\t\t{\n\t\t\t\texternalizedText = temp.getRoot( ).getMessage( textKey,\n\t\t\t\t\t\tlocale );\n\t\t\t\tif ( !StringUtil.isBlank( externalizedText ) )\n\t\t\t\t\treturn externalizedText;\n\t\t\t\tif ( DesignElement.NO_BASE_ID != temp.getBaseId( ) )\n\t\t\t\t\ttemp = temp.getVirtualParent( );\n\t\t\t\telse\n\t\t\t\t\ttemp = temp.getExtendsElement( );\n\t\t\t}\n\t\t}\n\t\treturn (String) structure.getProperty( element.getRoot( ), propName );\n\t}\n\t/**\n\t * Returns a list whose entry is of <code>IVersionInfo</code> type. Each\n\t * kind of automatical conversion information is stored in one instance of\n\t * <code>IVersionInfo</code>. If the size of the return list is 0, there is\n\t * no conversion information.\n\t * \n\t * @param version\n\t *            the design file version\n\t * @return a list containing <code>IVersionInfo</code>\n\t * @deprecated using checkVersion( String version, boolean isSupportedUnknownVersion ) for replacing\n\t */\n\tpublic static List<IVersionInfo> checkVersion( String version )\n\t{\n\t\tList<IVersionInfo> rtnList = new ArrayList<IVersionInfo>( );\n\t\tint versionNo = -1;\n\t\ttry\n\t\t{\n\t\t\tversionNo = VersionUtil.parseVersion( version );\n\t\t}\n\t\tcatch ( NumberFormatException e )\n\t\t{\n\t\t}\n\t\tcatch ( IllegalArgumentException e )\n\t\t{\n\t\t}\n\t\tif ( versionNo < 0\n\t\t\t\t|| versionNo > DesignSchemaConstants.REPORT_VERSION_NUMBER )\n\t\t\trtnList.add( new VersionInfo( version, VersionInfo.INVALID_VERSION ) );\n\t\tif ( versionNo <= VersionInfo.COLUMN_BINDING_FROM_VERSION\n\t\t\t\t&& DesignSchemaConstants.REPORT_VERSION_NUMBER > VersionInfo.COLUMN_BINDING_FROM_VERSION )\n\t\t\trtnList.add( new VersionInfo( version,\n\t\t\t\t\tVersionInfo.CONVERT_FOR_COLUMN_BINDING ) );\n\t\treturn rtnList;\n\t}\n\t/**\n\t * Returns a list whose entry is of <code>IVersionInfo</code> type. Each\n\t * kind of automatical conversion information is stored in one instance of\n\t * <code>IVersionInfo</code>. If the size of the return list is 0, there is\n\t * no conversion information.\n\t * \n\t * @param version\n\t *            the design file version\n\t * @param isSupportedUnknownVersion whether support unknown version\n\t * @return a list containing <code>IVersionInfo</code>\n\t *\n\t */\n\tpublic static List<IVersionInfo> checkVersion( String version, boolean isSupportedUnknownVersion )\n\t{\n\t\tList<IVersionInfo> rtnList = new ArrayList<IVersionInfo>( );\n\t\tint versionNo = -1;\n\t\ttry\n\t\t{\n\t\t\tversionNo = VersionUtil.parseVersion( version );\n\t\t}\n\t\tcatch ( NumberFormatException e )\n\t\t{\n\t\t}\n\t\tcatch ( IllegalArgumentException e )\n\t\t{\n\t\t}\n\t\tif( versionNo < 0 )\n\t\t{\n\t\t\trtnList.add( new VersionInfo( version, VersionInfo.INVALID_VERSION ) );\n\t\t}\n\t\telse if( versionNo > DesignSchemaConstants.REPORT_VERSION_NUMBER )\n\t\t{\n\t\t\tif( isSupportedUnknownVersion )\n\t\t\t{\n\t\t\t\trtnList.add( new VersionInfo( version, VersionInfo.LATER_VERSION ) );\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\trtnList.add( new VersionInfo( version, VersionInfo.INVALID_VERSION ) );\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tif ( versionNo <= VersionInfo.COLUMN_BINDING_FROM_VERSION\n\t\t\t\t&& DesignSchemaConstants.REPORT_VERSION_NUMBER > VersionInfo.COLUMN_BINDING_FROM_VERSION )\n\t\t\trtnList.add( new VersionInfo( version,\n\t\t\t\t\tVersionInfo.CONVERT_FOR_COLUMN_BINDING ) );\n\t\treturn rtnList;\n\t}\n\t/**\n\t * Justifies whether the given element supports template transform\n\t * \n\t * @param element\n\t *            the element to check\n\t * @return true if Model supports the template element for the given one,\n\t *         otherwise false\n\t */\n\tpublic static boolean isTemplateSupported( DesignElement element )\n\t{\n\t\t// all the data sets support template\n\t\tif ( element instanceof DataSet )\n\t\t\treturn true;\n\t\t// not all the report items support template, eg. auto text does not\n\t\t// support template\n\t\tif ( element instanceof ReportItem )\n\t\t{\n\t\t\tIChoiceSet choiceSet = MetaDataDictionary.getInstance( )\n\t\t\t\t\t.getChoiceSet(\n\t\t\t\t\t\t\tDesignChoiceConstants.CHOICE_TEMPLATE_ELEMENT_TYPE );\n\t\t\tassert choiceSet != null;\n\t\t\tIChoice[] choices = choiceSet.getChoices( );\n\t\t\tfor ( int i = 0; i < choices.length; i++ )\n\t\t\t{\n\t\t\t\tString name = choices[i].getName( );\n\t\t\t\tMetaDataDictionary dd = MetaDataDictionary.getInstance( );\n\t\t\t\t// if name is 'ExtendedItem', then all the extension from\n\t\t\t\t// ReportItem is supported\n\t\t\t\tif ( DesignChoiceConstants.TEMPLATE_ELEMENT_TYPE_EXTENDED_ITEM\n\t\t\t\t\t\t.equals( name ) )\n\t\t\t\t{\n\t\t\t\t\tif ( element instanceof ExtendedItem\n\t\t\t\t\t\t\t&& element\n\t\t\t\t\t\t\t\t\t.getDefn( )\n\t\t\t\t\t\t\t\t\t.isKindOf(\n\t\t\t\t\t\t\t\t\t\t\tdd.getElement( ReportDesignConstants.REPORT_ITEM ) ) )\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tIElementDefn defn = MetaDataDictionary.getInstance( )\n\t\t\t\t\t\t\t.getElement( name );\n\t\t\t\t\tif ( element.getDefn( ).isKindOf( defn ) )\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t/**\n\t * Checks whether the compound element is valid if the element has no\n\t * extends property value or if the current element is compound elements and\n\t * extends value is unresovled.\n\t * \n\t * @param module\n\t *            the root module of the element\n\t * @param element\n\t *            the element to justify\n\t * \n\t * @return <code>true</code> if the compound element is valid. Otherwise\n\t *         <code>false</code>.\n\t * \n\t * @deprecated\n\t */\n<fim_suffix>\tpublic static boolean isValidReferenceForCompoundElement( Module module,\n\t\t\tDesignElement element )\n\t{\n\t\tElementRefValue refValue = (ElementRefValue) element.getLocalProperty(\n\t\t\t\tmodule, IDesignElementModel.EXTENDS_PROP );\n\t\tif ( refValue == null )\n\t\t\treturn true;\n\t\tif ( element.getDefn( ).isContainer( ) && !refValue.isResolved( ) )\n\t\t\treturn false;\n\t\t// if any ancestor of this element loses extended element, return false\n\t\tDesignElement parent = element.getExtendsElement( );\n\t\twhile ( parent != null )\n\t\t{\n\t\t\tif ( !isValidReferenceForCompoundElement( parent.getRoot( ), parent ) )\n\t\t\t\treturn false;\n\t\t\tparent = parent.getExtendsElement( );\n\t\t}\n\t\treturn true;\n\t}<fim_middle>// function below has no smell\n"}