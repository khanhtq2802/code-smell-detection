{"text": "<fim_prefix>import org.apache.royale.compiler.units.requests.IFileScopeRequestResult;\nimport org.apache.royale.compiler.units.requests.IOutgoingDependenciesRequestResult;\nimport org.apache.royale.compiler.units.requests.IRequest;\nimport org.apache.royale.compiler.units.requests.ISWFTagsRequestResult;\nimport org.apache.royale.compiler.units.requests.ISyntaxTreeRequestResult;\nimport org.apache.royale.utils.JSXUtil;\nimport com.google.common.base.Strings;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Iterables;\npublic class ASCompilationUnit extends CompilationUnitBase\n{\n    /**\n     * Implementation of {@link ISyntaxTreeRequestResult} that has the added feature\n     * of being able to transform the reference to the syntax tree to a weak reference.\n     */\n    private static class ASSyntaxTreeRequestResult implements ISyntaxTreeRequestResult\n    {\n        private static class HardToWeakRef<T> extends WeakReference<T>\n        {\n            /**\n             * Constructs a reference to the specified object.\n             * @param referent Object to refer to.\n             */\n            public HardToWeakRef(T referent)\n            {\n                super(referent);\n                this.referent = referent;\n            }\n            private T referent;\n            public void makeWeak()\n            {\n                // No lock here because we are writing a single\n                // reference variable that is not a long or double.\n                referent = null;\n            }\n            @Override\n            public T get()\n            {\n                // Overriding this method just to make\n                // sure the java compiler or vm does not\n                // optimize away the member variable that holds\n                // strong reference.\n                // No lock here because we are reading a single reference\n                // variable that is not a long or double.\n                //\n                // We read the member variable into a local so we can return it\n                // without worrying about the another thread bashing\n                // the member variable.\n                T referent = this.referent;\n                if (referent != null)\n                    return referent;\n                return super.get();\n            }\n        }\n        ASSyntaxTreeRequestResult(ASCompilationUnit owner, IRequest<ISyntaxTreeRequestResult, ICompilationUnit> syntaxTreeRequest, IASNode ast, ImmutableSet<String> includedFiles, long lastModified, Collection<ICompilerProblem> problems)\n        {\n            ownerRef = new WeakReference<ASCompilationUnit>(owner);\n            this.syntaxTreeRequest = syntaxTreeRequest;\n            astRef = new HardToWeakRef<IASNode>(ast);\n            this.includedFiles = includedFiles;\n            this.problems = problems.toArray(new ICompilerProblem[problems.size()]);\n            this.lastModified = lastModified;\n        }\n        private final WeakReference<ASCompilationUnit> ownerRef;\n        private final IRequest<ISyntaxTreeRequestResult, ICompilationUnit> syntaxTreeRequest;\n        private final HardToWeakRef<IASNode> astRef;\n        private final ImmutableSet<String> includedFiles;\n        private final long lastModified;\n        private final ICompilerProblem[] problems;\n        @Override\n        public ICompilerProblem[] getProblems()\n        {\n            return problems;\n        }\n        @Override\n        public IASNode getAST() throws InterruptedException\n        {\n            // This method needs to return the syntax tree\n            // for this compilation unit.\n            //\n            // Since we might have allowed the syntax tree\n            // to be GC'd we may have to repase the file.\n            // First see if we still have the AST..\n            IASNode result = astRef.get();\n            if (result != null)\n                return result;\n            // We allowed the syntax tree to be gc'd.\n            // Now we have to get hold of our owning\n            // compilation unit to tell it to reparse the file.\n            ASCompilationUnit owner = ownerRef.get();\n            // If our owning compilation unit has been gc'd\n            // then we are just a stale result object.  Just bail.\n            if (owner == null)\n                return null;\n            // The reference to our owner is still good.\n            // Use compare and set to atomically update our\n            // owner's reference to us.  We don't care if it\n            // ends up being null or a pointing to someone else.\n            owner.syntaxTreeRequest.compareAndSet(syntaxTreeRequest, null);\n            // Now ask our owner for the syntax tree.\n            return owner.getSyntaxTreeRequest().get().getAST();\n        }\n        /**\n         * Called by the {@link ASCompilationUnit} to make the reference to the syntax\n         * tree held by this class a weak reference.\n         */\n        public void dropASTRef()\n        {\n            astRef.makeWeak();\n        }\n        @Override\n        public Set<String> getRequiredResourceBundles() throws InterruptedException\n        {\n            IASNode tree = getAST();\n            if(tree instanceof IFileNodeAccumulator)\n            {\n                return ((IFileNodeAccumulator)tree).getRequiredResourceBundles();\n            }\n            return Collections.emptySet();\n        }\n        @Override\n        public ImmutableSet<String> getIncludedFiles()\n        {\n            return includedFiles;\n        }\n        @Override\n        public long getLastModified()\n        {\n            return lastModified;\n        }\n    }\n    /**\n     * Create a main compilation unit for ASC client. This factory method will\n     * setup the included files specified by {@code -in} option onto the\n     * tokenizer.\n     * <p>\n     * Using this factory method so that we don't have to expose\n     * {@code ASCompilationUnit#setIncludedFiles(List)}, because it is specific\n     * to {@link ASC} only.\n     * \n     * @param project Compiler project.\n     * @param mainFile Main source file.\n     * @param asc ASC client instance.\n     * @return Main ActionScript compilation unit.\n     */\n    public static ASCompilationUnit createMainCompilationUnitForASC(\n            final CompilerProject project,\n            final IFileSpecification mainFile,\n            final ASC asc)\n    {\n        assert project != null : \"Expecting project.\";\n        assert mainFile != null : \"Expecting main file.\";\n        assert asc != null : \"Expecting ASC client.\";\n        final ASCompilationUnit mainCompilationUnit = new ASCompilationUnit(\n                project,\n                mainFile.getPath(),\n                DefinitionPriority.BasePriority.SOURCE_LIST);\n        mainCompilationUnit.includedFiles.addAll(asc.getIncludeFilenames());\n        return mainCompilationUnit;\n    }\n    public ASCompilationUnit(CompilerProject project, String path, DefinitionPriority.BasePriority basePriority)\n    {\n        this(project, path, basePriority, 0);\n    }\n    public ASCompilationUnit(CompilerProject project, String path, DefinitionPriority.BasePriority basePriority, int order)\n    {\n        this(project, path, basePriority, order, null);\n    }\n    public ASCompilationUnit(CompilerProject project, String path,\n                             DefinitionPriority.BasePriority basePriority,\n                             int order,\n                             String qname)\n    {\n        super(project, path, basePriority, qname);\n        this.qname = qname;\n        ((DefinitionPriority) getDefinitionPriority()).setOrder(order);\n    }\n    // The fully-qualified name of the one externally-visible definition\n    // expected to be found in this compilation unit, or null if none is expected.\n    // This qname is determined from the name of the file\n    // and the file's location relative to the source path.\n    private final String qname;\n    /**\n     * This field is specific to {@link ASC} client. It's a list of files\n     * included by {@code -in} option.\n     */\n    private final List<String> includedFiles = new ArrayList<String>();\n    @Override\n    public UnitType getCompilationUnitType()\n    {\n        return UnitType.AS_UNIT;\n    }\n    /**\n     * Creates the FileNode to be returned by the syntax tree request\n     * \n     * @param specification the {@link IFileSpecification} for the given file\n     * @return a {@link FileNode}\n     */\n<fim_suffix>    protected FileNode createFileNode(IFileSpecification specification)\n    {\n        // Only defer function body if the compilation unit is from an actual AS \n        // file, and the compilation unit is not \"invisible\" (currently not \n        // open in IDE). \"isInvisible\" means the compilation unit is invisible \n        // to semantic analyzer. It, however, is \"visible\" to the user in the \n        // IDE.\n        final DeferFunctionBody deferFunctionBody;\n        if(!isInvisible() && specification instanceof FileSpecification)\n            deferFunctionBody = DeferFunctionBody.ENABLED;\n        else\n            deferFunctionBody = DeferFunctionBody.DISABLED;\n        final IASProject flashProject;\n        if(getProject() instanceof IASProject)\n            flashProject = (IASProject)getProject();\n        else\n            flashProject = null;\n        // Parse the AS file into an AST and build a symbol table for it.\n        return ASParser.parseFile(\n                specification,\n                getFileSpecificationGetter(),\n                EnumSet.of(PostProcessStep.CALCULATE_OFFSETS),\n                this.getProject().getProjectConfigVariables(),\n                true,\n                this.getProject().isAssetEmbeddingSupported(),\n                includedFiles,\n                deferFunctionBody,\n                flashProject,\n                this);\n    }<fim_middle>// function below has no smell\n"}