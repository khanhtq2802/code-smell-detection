{"text": "<fim_prefix>/*\n * Copyright (C) 2013 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.common.collect;\n\nimport static com.google.common.collect.CollectPreconditions.checkEntryNotNull;\n\nimport com.google.common.annotations.GwtIncompatible;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n\n/**\n * Implementation of {@code Entry} for {@link ImmutableMap} that adds extra methods to traverse hash\n * buckets for the key and the value. This allows reuse in {@link RegularImmutableMap} and {@link\n * RegularImmutableBiMap}, which don't have to recopy the entries created by their {@code Builder}\n * implementations.\n *\n * <p>This base implementation has no key or value pointers, so instances of ImmutableMapEntry (but\n * not its subclasses) can be reused when copied from one ImmutableMap to another.\n *\n * @author Louis Wasserman\n */\n<fim_suffix>@GwtIncompatible // unnecessary\nclass ImmutableMapEntry<K, V> extends ImmutableEntry<K, V> {\n  /**\n   * Creates an {@code ImmutableMapEntry} array to hold parameterized entries. The result must never\n   * be upcast back to ImmutableMapEntry[] (or Object[], etc.), or allowed to escape the class.\n   */\n  @SuppressWarnings(\"unchecked\") // Safe as long as the javadocs are followed\n  static <K, V> ImmutableMapEntry<K, V>[] createEntryArray(int size) {\n    return new ImmutableMapEntry[size];\n  }\n\n  ImmutableMapEntry(K key, V value) {\n    super(key, value);\n    checkEntryNotNull(key, value);\n  }\n\n  ImmutableMapEntry(ImmutableMapEntry<K, V> contents) {\n    super(contents.getKey(), contents.getValue());\n    // null check would be redundant\n  }\n\n  @Nullable\n  ImmutableMapEntry<K, V> getNextInKeyBucket() {\n    return null;\n  }\n\n  @Nullable\n  ImmutableMapEntry<K, V> getNextInValueBucket() {\n    return null;\n  }\n\n  /**\n   * Returns true if this entry has no bucket links and can safely be reused as a terminal entry in\n   * a bucket in another map.\n   */\n  boolean isReusable() {\n    return true;\n  }\n\n  static class NonTerminalImmutableMapEntry<K, V> extends ImmutableMapEntry<K, V> {\n    private final transient ImmutableMapEntry<K, V> nextInKeyBucket;\n\n    NonTerminalImmutableMapEntry(K key, V value, ImmutableMapEntry<K, V> nextInKeyBucket) {\n      super(key, value);\n      this.nextInKeyBucket = nextInKeyBucket;\n    }\n\n    @Override\n    final @Nullable ImmutableMapEntry<K, V> getNextInKeyBucket() {\n      return nextInKeyBucket;\n    }\n\n    @Override\n    final boolean isReusable() {\n      return false;\n    }\n  }\n\n  static final class NonTerminalImmutableBiMapEntry<K, V>\n      extends NonTerminalImmutableMapEntry<K, V> {\n    private final transient ImmutableMapEntry<K, V> nextInValueBucket;\n\n    NonTerminalImmutableBiMapEntry(\n        K key,\n        V value,\n        ImmutableMapEntry<K, V> nextInKeyBucket,\n        ImmutableMapEntry<K, V> nextInValueBucket) {\n      super(key, value, nextInKeyBucket);\n      this.nextInValueBucket = nextInValueBucket;\n    }\n\n    @Override\n    @Nullable\n    ImmutableMapEntry<K, V> getNextInValueBucket() {\n      return nextInValueBucket;\n    }\n  }\n}<fim_middle>// class below has no smell\n"}