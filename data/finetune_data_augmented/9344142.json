{"text": "<fim_prefix>                  g.drawLine(0, cw, cw, 0);                // top slant\n                  g.setColor(Color.black);\n                  g.drawLine(0, h-1-cw, cw, h-1 );         // bottom slant\n                  g.drawLine(cw, h-1, w-1, h-1);           // bottom\n                  g.setColor(shadowColor);\n                  g.drawLine(cw, h-2, w-2,  h-2 );         // bottom\n                  g.drawLine(w-1, 1, w-1,  h-2 );          // right\n            }\n        }\n        g.translate(-knobBounds.x, -knobBounds.y);\n    }\n    // Used exclusively by setThumbLocation()\n    private static Rectangle unionRect = new Rectangle();\n    /**\n     * Sets the thumb location.\n     * @param x the x coordinate\n     * @param y the y coordinate\n     */\n    public void setThumbLocation(int x, int y)  {\n        unionRect.setBounds( thumbRect );\n        thumbRect.setLocation( x, y );\n        SwingUtilities.computeUnion( thumbRect.x, thumbRect.y, thumbRect.width, thumbRect.height, unionRect );\n        slider.repaint( unionRect.x, unionRect.y, unionRect.width, unionRect.height );\n    }\n    /**\n     * Scrolls by block.\n     * @param direction the direction\n     */\n    public void scrollByBlock(int direction)    {\n        synchronized(slider)    {\n            int blockIncrement =\n                (slider.getMaximum() - slider.getMinimum()) / 10;\n            if (blockIncrement == 0) {\n                blockIncrement = 1;\n            }\n            int tickSpacing = getTickSpacing();\n            if (slider.getSnapToTicks()) {\n                if (blockIncrement < tickSpacing) {\n                    blockIncrement = tickSpacing;\n                }\n            }\n            else {\n                if (tickSpacing > 0) {\n                    blockIncrement = tickSpacing;\n                }\n            }\n            int delta = blockIncrement * ((direction > 0) ? POSITIVE_SCROLL : NEGATIVE_SCROLL);\n            slider.setValue(slider.getValue() + delta);\n        }\n    }\n    /**\n     * Scrolls by unit.\n     * @param direction the direction\n     */\n    public void scrollByUnit(int direction) {\n        synchronized(slider)    {\n            int delta = ((direction > 0) ? POSITIVE_SCROLL : NEGATIVE_SCROLL);\n            if (slider.getSnapToTicks()) {\n                delta *= getTickSpacing();\n            }\n            slider.setValue(slider.getValue() + delta);\n        }\n    }\n    /**\n     * This function is called when a mousePressed was detected in the track,\n     * not in the thumb. The default behavior is to scroll by block. You can\n     * override this method to stop it from scrolling or to add additional\n     * behavior.\n     *\n     * @param dir the direction and number of blocks to scroll\n     */\n    protected void scrollDueToClickInTrack( int dir ) {\n        scrollByBlock( dir );\n    }\n    /**\n     * Returns the x position for a value.\n     * @param value the value\n     * @return the x position for a value\n     */\n    protected int xPositionForValue( int value )    {\n        int min = slider.getMinimum();\n        int max = slider.getMaximum();\n        int trackLength = trackRect.width;\n        double valueRange = (double)max - (double)min;\n        double pixelsPerValue = (double)trackLength / valueRange;\n        int trackLeft = trackRect.x;\n        int trackRight = trackRect.x + (trackRect.width - 1);\n        int xPosition;\n        if ( !drawInverted() ) {\n            xPosition = trackLeft;\n            xPosition += Math.round( pixelsPerValue * ((double)value - min) );\n        }\n        else {\n            xPosition = trackRight;\n            xPosition -= Math.round( pixelsPerValue * ((double)value - min) );\n        }\n        xPosition = Math.max( trackLeft, xPosition );\n        xPosition = Math.min( trackRight, xPosition );\n        return xPosition;\n    }\n    /**\n     * Returns the y position for a value.\n     * @param value the value\n     * @return the y position for a value\n     */\n    protected int yPositionForValue( int value )  {\n        return yPositionForValue(value, trackRect.y, trackRect.height);\n    }\n    /**\n     * Returns the y location for the specified value.  No checking is\n     * done on the arguments.  In particular if <code>trackHeight</code> is\n     * negative undefined results may occur.\n     *\n     * @param value the slider value to get the location for\n     * @param trackY y-origin of the track\n     * @param trackHeight the height of the track\n     * @return the y location for the specified value of the slider\n     * @since 1.6\n     */\n    protected int yPositionForValue(int value, int trackY, int trackHeight) {\n        int min = slider.getMinimum();\n        int max = slider.getMaximum();\n        double valueRange = (double)max - (double)min;\n        double pixelsPerValue = (double)trackHeight / valueRange;\n        int trackBottom = trackY + (trackHeight - 1);\n        int yPosition;\n        if ( !drawInverted() ) {\n            yPosition = trackY;\n            yPosition += Math.round( pixelsPerValue * ((double)max - value ) );\n        }\n        else {\n            yPosition = trackY;\n            yPosition += Math.round( pixelsPerValue * ((double)value - min) );\n        }\n        yPosition = Math.max( trackY, yPosition );\n        yPosition = Math.min( trackBottom, yPosition );\n        return yPosition;\n    }\n    /**\n     * Returns the value at the y position. If {@code yPos} is beyond the\n     * track at the bottom or the top, this method sets the value to either\n     * the minimum or maximum value of the slider, depending on if the slider\n     * is inverted or not.\n     *\n     * @param yPos the location of the slider along the y axis\n     * @return the value at the y position\n     */\n    public int valueForYPosition( int yPos ) {\n        int value;\n        final int minValue = slider.getMinimum();\n        final int maxValue = slider.getMaximum();\n        final int trackLength = trackRect.height;\n        final int trackTop = trackRect.y;\n        final int trackBottom = trackRect.y + (trackRect.height - 1);\n        if ( yPos <= trackTop ) {\n            value = drawInverted() ? minValue : maxValue;\n        }\n        else if ( yPos >= trackBottom ) {\n            value = drawInverted() ? maxValue : minValue;\n        }\n        else {\n            int distanceFromTrackTop = yPos - trackTop;\n            double valueRange = (double)maxValue - (double)minValue;\n            double valuePerPixel = valueRange / (double)trackLength;\n            int valueFromTrackTop = (int)Math.round( distanceFromTrackTop * valuePerPixel );\n            value = drawInverted() ? minValue + valueFromTrackTop : maxValue - valueFromTrackTop;\n        }\n        return value;\n    }\n    /**\n     * Returns the value at the x position.  If {@code xPos} is beyond the\n     * track at the left or the right, this method sets the value to either the\n     * minimum or maximum value of the slider, depending on if the slider is\n     * inverted or not.\n     *\n     * @param xPos the location of the slider along the x axis\n     * @return the value of the x position\n     */\n    public int valueForXPosition( int xPos ) {\n        int value;\n        final int minValue = slider.getMinimum();\n        final int maxValue = slider.getMaximum();\n        final int trackLength = trackRect.width;\n        final int trackLeft = trackRect.x;\n        final int trackRight = trackRect.x + (trackRect.width - 1);\n        if ( xPos <= trackLeft ) {\n            value = drawInverted() ? maxValue : minValue;\n        }\n        else if ( xPos >= trackRight ) {\n            value = drawInverted() ? minValue : maxValue;\n        }\n        else {\n            int distanceFromTrackLeft = xPos - trackLeft;\n            double valueRange = (double)maxValue - (double)minValue;\n            double valuePerPixel = valueRange / (double)trackLength;\n            int valueFromTrackLeft = (int)Math.round( distanceFromTrackLeft * valuePerPixel );\n            value = drawInverted() ? maxValue - valueFromTrackLeft :\n              minValue + valueFromTrackLeft;\n        }\n        return value;\n    }\n    private class Handler implements ChangeListener,\n            ComponentListener, FocusListener, PropertyChangeListener {\n        // Change Handler\n<fim_suffix>        public void stateChanged(ChangeEvent e) {\n            if (!isDragging) {\n                calculateThumbLocation();\n                slider.repaint();\n            }\n            lastValue = slider.getValue();\n        }<fim_middle>// function below has no smell\n"}