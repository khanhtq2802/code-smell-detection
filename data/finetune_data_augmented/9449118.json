{"text": "<fim_prefix> *  If you write code that depends on this, you do so at your own risk.\n *  This code and its internal interfaces are subject to change or\n *  deletion without notice.</b>\n */\npublic class AnnotationWriter extends BasicWriter {\n    static AnnotationWriter instance(Context context) {\n        AnnotationWriter instance = context.get(AnnotationWriter.class);\n        if (instance == null)\n            instance = new AnnotationWriter(context);\n        return instance;\n    }\n    protected AnnotationWriter(Context context) {\n        super(context);\n        classWriter = ClassWriter.instance(context);\n        constantWriter = ConstantWriter.instance(context);\n    }\n    public void write(Annotation annot) {\n        write(annot, false);\n        println();\n        indent(+1);\n        write(annot, true);\n        indent(-1);\n    }\n    public void write(Annotation annot, boolean resolveIndices) {\n        writeDescriptor(annot.type_index, resolveIndices);\n        if (resolveIndices) {\n            boolean showParens = annot.num_element_value_pairs > 0;\n            if (showParens) {\n                println(\"(\");\n                indent(+1);\n            }\n            for (int i = 0; i < annot.num_element_value_pairs; i++) {\n                write(annot.element_value_pairs[i], true);\n                println();\n            }\n            if (showParens) {\n                indent(-1);\n                print(\")\");\n            }\n        } else {\n            print(\"(\");\n            for (int i = 0; i < annot.num_element_value_pairs; i++) {\n                if (i > 0)\n                    print(\",\");\n                write(annot.element_value_pairs[i], false);\n            }\n            print(\")\");\n        }\n    }\n    public void write(TypeAnnotation annot) {\n        write(annot, true, false);\n        println();\n        indent(+1);\n        write(annot.annotation, true);\n        indent(-1);\n    }\n    public void write(TypeAnnotation annot, boolean showOffsets, boolean resolveIndices) {\n        write(annot.annotation, resolveIndices);\n        print(\": \");\n        write(annot.position, showOffsets);\n    }\n    public void write(TypeAnnotation.Position pos, boolean showOffsets) {\n        print(pos.type);\n        switch (pos.type) {\n        // instanceof\n        case INSTANCEOF:\n        // new expression\n        case NEW:\n        // constructor/method reference receiver\n        case CONSTRUCTOR_REFERENCE:\n        case METHOD_REFERENCE:\n            if (showOffsets) {\n                print(\", offset=\");\n                print(pos.offset);\n            }\n            break;\n        // local variable\n        case LOCAL_VARIABLE:\n        // resource variable\n        case RESOURCE_VARIABLE:\n            if (pos.lvarOffset == null) {\n                print(\", lvarOffset is Null!\");\n                break;\n            }\n            print(\", {\");\n            for (int i = 0; i < pos.lvarOffset.length; ++i) {\n                if (i != 0) print(\"; \");\n                if (showOffsets) {\n                    print(\"start_pc=\");\n                    print(pos.lvarOffset[i]);\n                }\n                print(\", length=\");\n                print(pos.lvarLength[i]);\n                print(\", index=\");\n                print(pos.lvarIndex[i]);\n            }\n            print(\"}\");\n            break;\n        // exception parameter\n        case EXCEPTION_PARAMETER:\n            print(\", exception_index=\");\n            print(pos.exception_index);\n            break;\n        // method receiver\n        case METHOD_RECEIVER:\n            // Do nothing\n            break;\n        // type parameter\n        case CLASS_TYPE_PARAMETER:\n        case METHOD_TYPE_PARAMETER:\n            print(\", param_index=\");\n            print(pos.parameter_index);\n            break;\n        // type parameter bound\n        case CLASS_TYPE_PARAMETER_BOUND:\n        case METHOD_TYPE_PARAMETER_BOUND:\n            print(\", param_index=\");\n            print(pos.parameter_index);\n            print(\", bound_index=\");\n            print(pos.bound_index);\n            break;\n        // class extends or implements clause\n        case CLASS_EXTENDS:\n            print(\", type_index=\");\n            print(pos.type_index);\n            break;\n        // throws\n        case THROWS:\n            print(\", type_index=\");\n            print(pos.type_index);\n            break;\n        // method parameter\n        case METHOD_FORMAL_PARAMETER:\n            print(\", param_index=\");\n            print(pos.parameter_index);\n            break;\n        // type cast\n        case CAST:\n        // method/constructor/reference type argument\n        case CONSTRUCTOR_INVOCATION_TYPE_ARGUMENT:\n        case METHOD_INVOCATION_TYPE_ARGUMENT:\n        case CONSTRUCTOR_REFERENCE_TYPE_ARGUMENT:\n        case METHOD_REFERENCE_TYPE_ARGUMENT:\n            if (showOffsets) {\n                print(\", offset=\");\n                print(pos.offset);\n            }\n            print(\", type_index=\");\n            print(pos.type_index);\n            break;\n        // We don't need to worry about these\n        case METHOD_RETURN:\n        case FIELD:\n            break;\n        case UNKNOWN:\n            throw new AssertionError(\"AnnotationWriter: UNKNOWN target type should never occur!\");\n        default:\n            throw new AssertionError(\"AnnotationWriter: Unknown target type for position: \" + pos);\n        }\n        // Append location data for generics/arrays.\n        if (!pos.location.isEmpty()) {\n            print(\", location=\");\n            print(pos.location);\n        }\n    }\n    public void write(Annotation.element_value_pair pair, boolean resolveIndices) {\n        writeIndex(pair.element_name_index, resolveIndices);\n        print(\"=\");\n        write(pair.value, resolveIndices);\n    }\n    public void write(Annotation.element_value value) {\n        write(value, false);\n        println();\n        indent(+1);\n        write(value, true);\n        indent(-1);\n    }\n    public void write(Annotation.element_value value, boolean resolveIndices) {\n        ev_writer.write(value, resolveIndices);\n    }\n    private void writeDescriptor(int index, boolean resolveIndices) {\n        if (resolveIndices) {\n            try {\n                ConstantPool constant_pool = classWriter.getClassFile().constant_pool;\n                Descriptor d = new Descriptor(index);\n                print(d.getFieldType(constant_pool));\n                return;\n            } catch (ConstantPoolException | InvalidDescriptor ignore) {\n            }\n        }\n        print(\"#\" + index);\n    }\n    private void writeIndex(int index, boolean resolveIndices) {\n        if (resolveIndices) {\n            print(constantWriter.stringValue(index));\n        } else\n            print(\"#\" + index);\n    }\n    element_value_Writer ev_writer = new element_value_Writer();\n    class element_value_Writer implements Annotation.element_value.Visitor<Void,Boolean> {\n        public void write(Annotation.element_value value, boolean resolveIndices) {\n            value.accept(this, resolveIndices);\n        }\n        @Override\n        public Void visitPrimitive(Primitive_element_value ev, Boolean resolveIndices) {\n            if (resolveIndices) {\n                int index = ev.const_value_index;\n                switch (ev.tag) {\n                    case 'B':\n                        print(\"(byte) \");\n                        print(constantWriter.stringValue(index));\n                        break;\n                    case 'C':\n                        print(\"'\");\n                        print(constantWriter.charValue(index));\n                        print(\"'\");\n                        break;\n                    case 'D':\n                    case 'F':\n                    case 'I':\n                    case 'J':\n                        print(constantWriter.stringValue(index));\n                        break;\n                    case 'S':\n                        print(\"(short) \");\n                        print(constantWriter.stringValue(index));\n                        break;\n                    case 'Z':\n                        print(constantWriter.booleanValue(index));\n                        break;\n                    case 's':\n                        print(\"\\\"\");\n                        print(constantWriter.stringValue(index));\n                        print(\"\\\"\");\n                        break;\n                    default:\n                        print(((char) ev.tag) + \"#\" + ev.const_value_index);\n                        break;\n                }\n            } else {\n                print(((char) ev.tag) + \"#\" + ev.const_value_index);\n            }\n            return null;\n        }\n        @Override\n        public Void visitEnum(Enum_element_value ev, Boolean resolveIndices) {\n            if (resolveIndices) {\n                writeIndex(ev.type_name_index, resolveIndices);\n                print(\".\");\n                writeIndex(ev.const_name_index, resolveIndices);\n            } else {\n                print(((char) ev.tag) + \"#\" + ev.type_name_index + \".#\" + ev.const_name_index);\n            }\n            return null;\n        }\n        @Override\n        public Void visitClass(Class_element_value ev, Boolean resolveIndices) {\n            if (resolveIndices) {\n                print(\"class \");\n                writeIndex(ev.class_info_index, resolveIndices);\n            } else {\n                print(((char) ev.tag) + \"#\" + ev.class_info_index);\n            }\n            return null;\n        }\n<fim_suffix>        @Override\n        public Void visitAnnotation(Annotation_element_value ev, Boolean resolveIndices) {\n            print((char) ev.tag);\n            AnnotationWriter.this.write(ev.annotation_value, resolveIndices);\n            return null;\n        }<fim_middle>// function below has no smell\n"}