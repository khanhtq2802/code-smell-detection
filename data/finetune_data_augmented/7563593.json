{"text": "<fim_prefix>/*\n * Copyright 2002-2019 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.annotation;\n\nimport java.lang.annotation.Annotation;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\n\nimport org.springframework.lang.Nullable;\nimport org.springframework.util.Assert;\nimport org.springframework.util.ObjectUtils;\n\n/**\n * Predicate implementations that provide various test operations for\n * {@link MergedAnnotation MergedAnnotations}.\n *\n * @author Phillip Webb\n * @since 5.2\n */\npublic abstract class MergedAnnotationPredicates {\n\n\tprivate MergedAnnotationPredicates() {\n\t}\n\n\n\t/**\n\t * Returns a new {@link Predicate} that evaluates {@code true} if the\n\t * {@link MergedAnnotation#getType() merged annotation type} is contained in\n\t * the specified array.\n\t * @param <A> the annotation type\n\t * @param typeNames the names that should be matched\n\t * @return a {@link Predicate} to test the annotation type\n\t */\n\tpublic static <A extends Annotation> Predicate<MergedAnnotation<? extends A>> typeIn(String... typeNames) {\n\t\treturn annotation -> ObjectUtils.containsElement(typeNames, annotation.getType());\n\t}\n\n\t/**\n\t * Returns a new {@link Predicate} that evaluates {@code true} if the\n\t * {@link MergedAnnotation#getType() merged annotation type} is contained in\n\t * the specified array.\n\t * @param <A> the annotation type\n\t * @param types the types that should be matched\n\t * @return a {@link Predicate} to test the annotation type\n\t */\n\tpublic static <A extends Annotation> Predicate<MergedAnnotation<? extends A>> typeIn(Class<?>... types) {\n\t\treturn annotation -> Arrays.stream(types).anyMatch(type -> type.getName().equals(annotation.getType()));\n\t}\n\n\t/**\n\t * Returns a new {@link Predicate} that evaluates {@code true} if the\n\t * {@link MergedAnnotation#getType() merged annotation type} is contained in\n\t * the collection.\n\t * @param <A> the annotation type\n\t * @param types the type names or classes that should be matched\n\t * @return a {@link Predicate} to test the annotation type\n\t */\n\tpublic static <A extends Annotation> Predicate<MergedAnnotation<? extends A>> typeIn(Collection<?> types) {\n\t\treturn annotation -> types.stream()\n\t\t\t\t.map(type -> type instanceof Class ? ((Class<?>) type).getName() : type.toString())\n\t\t\t\t.anyMatch(typeName -> typeName.equals(annotation.getType()));\n\t}\n\n\t/**\n\t * Returns a new stateful, single use {@link Predicate} that matches only\n\t * the first run of an extracted value. For example,\n\t * {@code MergedAnnotationPredicates.firstRunOf(MergedAnnotation::depth)}\n\t * will return the first annotation and a subsequent run of the same depth.\n\t * NOTE: this predicate only matches the first first run, once the extracted\n\t * value changes the predicate always returns {@code false}.\n\t * @param valueExtractor function used to extract the value to check\n\t * @return a {@link Predicate} that matches the first run of the extracted\n\t * values\n\t */\n\tpublic static <A extends Annotation> Predicate<MergedAnnotation<A>> firstRunOf(\n\t\t\tFunction<? super MergedAnnotation<A>, ?> valueExtractor) {\n\n\t\treturn new FirstRunOfPredicate<>(valueExtractor);\n\t}\n\n\t/**\n\t * Returns a new stateful, single use {@link Predicate} that matches\n\t * annotations that are unique based on extracted key. For example\n\t * {@code MergedAnnotationPredicates.unique(MergedAnnotation::type)} will\n\t * match the first time a unique type is seen.\n\t * @param keyExtractor function used to extract the key used to test for\n\t * uniqueness\n\t * @return a {@link Predicate} that matches unique annotation based on the\n\t * extracted key\n\t */\n\tpublic static <A extends Annotation, K> Predicate<MergedAnnotation<A>> unique(\n\t\t\tFunction<? super MergedAnnotation<A>, K> keyExtractor) {\n\n\t\treturn new UniquePredicate<>(keyExtractor);\n\t}\n\n\n\t/**\n\t * {@link Predicate} implementation used for\n\t * {@link MergedAnnotationPredicates#firstRunOf(Function)}.\n\t */\n\tprivate static class FirstRunOfPredicate<A extends Annotation> implements Predicate<MergedAnnotation<A>> {\n\n\t\tprivate final Function<? super MergedAnnotation<A>, ?> valueExtractor;\n\n\t\tprivate boolean hasLastValue;\n\n\t\t@Nullable\n\t\tprivate Object lastValue;\n\n\t\tFirstRunOfPredicate(Function<? super MergedAnnotation<A>, ?> valueExtractor) {\n\t\t\tAssert.notNull(valueExtractor, \"Value extractor must not be null\");\n\t\t\tthis.valueExtractor = valueExtractor;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean test(@Nullable MergedAnnotation<A> annotation) {\n\t\t\tif (!this.hasLastValue) {\n\t\t\t\tthis.hasLastValue = true;\n\t\t\t\tthis.lastValue = this.valueExtractor.apply(annotation);\n\t\t\t}\n\t\t\tObject value = this.valueExtractor.apply(annotation);\n\t\t\treturn ObjectUtils.nullSafeEquals(value, this.lastValue);\n\n\t\t}\n\n\t}\n\n\n\t/**\n\t * {@link Predicate} implementation used for\n\t * {@link MergedAnnotationPredicates#unique(Function)}.\n\t */\n<fim_suffix>\tprivate static class UniquePredicate<A extends Annotation, K> implements Predicate<MergedAnnotation<A>> {\n\n\t\tprivate final Function<? super MergedAnnotation<A>, K> keyExtractor;\n\n\t\tprivate final Set<K> seen = new HashSet<>();\n\n\t\tUniquePredicate(Function<? super MergedAnnotation<A>, K> keyExtractor) {\n\t\t\tAssert.notNull(keyExtractor, \"Key extractor must not be null\");\n\t\t\tthis.keyExtractor = keyExtractor;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean test(@Nullable MergedAnnotation<A> annotation) {\n\t\t\tK key = this.keyExtractor.apply(annotation);\n\t\t\treturn this.seen.add(key);\n\t\t}\n\n\t}\n\n}<fim_middle>// class below has no smell\n"}