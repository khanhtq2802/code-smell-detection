{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.felix.example.extenderbased.host.launch;\n\nimport java.util.Map;\nimport java.util.ServiceLoader;\nimport org.apache.felix.example.extenderbased.host.Activator;\nimport org.osgi.framework.Bundle;\nimport org.osgi.framework.BundleContext;\nimport org.osgi.framework.BundleException;\nimport org.osgi.framework.launch.Framework;\nimport org.osgi.framework.launch.FrameworkFactory;\n\n/**\n * This class provides a static {@code main()} method so that the bundle can be\n * run as a stand-alone host application. In such a scenario, the application\n * creates its own embedded OSGi framework instance and interacts with the\n * internal extensions to providing drawing functionality. To successfully\n * launch the stand-alone application, it must be run from this bundle's\n * installation directory using \"{@code java -jar}\".\n * The locations of any additional extensions that have to be started, have to\n * be passed as command line arguments to this method.\n */\n<fim_suffix>public class Application\n{\n    private static Framework m_framework = null;\n\n    /**\n     * Enables the bundle to run as a stand-alone application. When this\n     * static {@code main()} method is invoked, the application creates\n     * its own embedded OSGi framework instance and interacts with the\n     * internal extensions to provide drawing functionality. To successfully\n     * launch as a stand-alone application, this method should be invoked from\n     * the bundle's installation directory using \"{@code java -jar}\".\n     * The location of any extension that shall be installed can be passed\n     * as parameters.\n     * <p>\n     * For example if you build the bundles inside your workspace, maven will\n     * create a target directory in every project. To start the application\n     * from within your IDE you should pass:\n     * <p>\n     * <pre>\n     * {@code file:../extenderbased.circle/target/extenderbased.circle-1.0.0.jar\n     * file:../extenderbased.square/target/extenderbased.square-1.0.0.jar\n     * file:../extenderbased.triangle/target/extenderbased.triangle-1.0.0.jar}\n     * </pre>\n     *\n     * @param args The locations of additional bundles to start.\n    **/\n    public static void main(String[] args)\n    {\n        // args should never be null if the application is run from the command line. Check it anyway.\n        String[] locations = args != null ? args : new String[0];\n\n        // Print welcome banner.\n        System.out.println(\"\\nWelcome to My Launcher\");\n        System.out.println(\"======================\\n\");\n\n        try\n        {\n            Map<String, String> config = ConfigUtil.createConfig();\n            m_framework = createFramework(config);\n            m_framework.init();\n            m_framework.start();\n            installAndStartBundles(locations);\n            m_framework.waitForStop(0);\n            System.exit(0);\n        }\n        catch (Exception ex)\n        {\n            System.err.println(\"Could not create framework: \" + ex);\n            ex.printStackTrace();\n            System.exit(-1);\n        }\n    }\n\n    /**\n     * Util method for creating an embedded Framework. Tries to create a {@link FrameworkFactory}\n     * which is then be used to create the framework.\n     *\n     * @param config the configuration to create the framework with\n     * @return a Framework with the given configuration\n     */\n    private static Framework createFramework(Map<String, String> config)\n    {\n        ServiceLoader<FrameworkFactory> factoryLoader = ServiceLoader.load(FrameworkFactory.class);\n        for(FrameworkFactory factory : factoryLoader){\n            return factory.newFramework(config);\n        }\n        throw new IllegalStateException(\"Unable to load FrameworkFactory service.\");\n    }\n\n    /**\n     * Installs and starts all bundles used by the application. Therefore the host bundle will be started. The locations\n     * of extensions for the host bundle can be passed in as parameters.\n     *\n     * @param bundleLocations the locations where extension for the host bundle are located. Must not be {@code null}!\n     * @throws BundleException if something went wrong while installing or starting the bundles.\n     */\n    private static void installAndStartBundles(String... bundleLocations) throws BundleException\n    {\n        BundleContext bundleContext = m_framework.getBundleContext();\n        Activator hostActivator = new Activator();\n        hostActivator.start(bundleContext);\n        for (String location : bundleLocations)\n        {\n            Bundle addition = bundleContext.installBundle(location);\n            addition.start();\n        }\n    }\n}<fim_middle>// class below has no smell\n"}