{"text": "<fim_prefix>\n<fim_suffix>public class Logger {\n    private static final Handler emptyHandlers[] = new Handler[0];\n    private static final int offValue = Level.OFF.intValue();\n    private LogManager manager;\n    private String name;\n    private final CopyOnWriteArrayList<Handler> handlers =\n        new CopyOnWriteArrayList<>();\n    private String resourceBundleName;\n    private volatile boolean useParentHandlers = true;\n    private volatile Filter filter;\n    private boolean anonymous;\n    private ResourceBundle catalog;     // Cached resource bundle\n    private String catalogName;         // name associated with catalog\n    private Locale catalogLocale;       // locale associated with catalog\n    // The fields relating to parent-child relationships and levels\n    // are managed under a separate lock, the treeLock.\n    private static Object treeLock = new Object();\n    // We keep weak references from parents to children, but strong\n    // references from children to parents.\n    @Weak\n    private volatile Logger parent;    // our nearest parent.\n    private ArrayList<LogManager.LoggerWeakRef> kids;   // WeakReferences to loggers that have us as parent\n    private volatile Level levelObject;\n    private volatile int levelValue;  // current effective level value\n    private WeakReference<ClassLoader> callersClassLoaderRef;\n    /**\n     * GLOBAL_LOGGER_NAME is a name for the global logger.\n     *\n     * @since 1.6\n     */\n    public static final String GLOBAL_LOGGER_NAME = \"global\";\n    /**\n     * Return global logger object with the name Logger.GLOBAL_LOGGER_NAME.\n     *\n     * @return global logger object\n     * @since 1.7\n     */\n    public static final Logger getGlobal() {\n        return global;\n    }\n    /**\n     * The \"global\" Logger object is provided as a convenience to developers\n     * who are making casual use of the Logging package.  Developers\n     * who are making serious use of the logging package (for example\n     * in products) should create and use their own Logger objects,\n     * with appropriate names, so that logging can be controlled on a\n     * suitable per-Logger granularity. Developers also need to keep a\n     * strong reference to their Logger objects to prevent them from\n     * being garbage collected.\n     * <p>\n     * @deprecated Initialization of this field is prone to deadlocks.\n     * The field must be initialized by the Logger class initialization\n     * which may cause deadlocks with the LogManager class initialization.\n     * In such cases two class initialization wait for each other to complete.\n     * The preferred way to get the global logger object is via the call\n     * <code>Logger.getGlobal()</code>.\n     * For compatibility with old JDK versions where the\n     * <code>Logger.getGlobal()</code> is not available use the call\n     * <code>Logger.getLogger(Logger.GLOBAL_LOGGER_NAME)</code>\n     * or <code>Logger.getLogger(\"global\")</code>.\n     */\n    @Deprecated\n    public static final Logger global = new Logger(GLOBAL_LOGGER_NAME);\n    /**\n     * Protected method to construct a logger for a named subsystem.\n     * <p>\n     * The logger will be initially configured with a null Level\n     * and with useParentHandlers set to true.\n     *\n     * @param   name    A name for the logger.  This should\n     *                          be a dot-separated name and should normally\n     *                          be based on the package name or class name\n     *                          of the subsystem, such as java.net\n     *                          or javax.swing.  It may be null for anonymous Loggers.\n     * @param   resourceBundleName  name of ResourceBundle to be used for localizing\n     *                          messages for this logger.  May be null if none\n     *                          of the messages require localization.\n     * @throws MissingResourceException if the resourceBundleName is non-null and\n     *             no corresponding resource can be found.\n     */\n    protected Logger(String name, String resourceBundleName) {\n        this(name, resourceBundleName, null);\n    }\n    Logger(String name, String resourceBundleName, Class<?> caller) {\n        this.manager = LogManager.getLogManager();\n        setupResourceInfo(resourceBundleName, caller);\n        this.name = name;\n        levelValue = Level.INFO.intValue();\n    }\n    /* J2ObjC removed.\n    private void setCallersClassLoaderRef(Class<?> caller) {\n        ClassLoader callersClassLoader = ((caller != null)\n                                         ? caller.getClassLoader()\n                                         : null);\n        if (callersClassLoader != null) {\n            this.callersClassLoaderRef = new WeakReference(callersClassLoader);\n        }\n    }\n    */\n    private ClassLoader getCallersClassLoader() {\n        return (callersClassLoaderRef != null)\n                ? callersClassLoaderRef.get()\n                : null;\n    }\n    // This constructor is used only to create the global Logger.\n    // It is needed to break a cyclic dependence between the LogManager\n    // and Logger static initializers causing deadlocks.\n    private Logger(String name) {\n        // The manager field is not initialized here.\n        this.name = name;\n        levelValue = Level.INFO.intValue();\n    }\n    // It is called from the LogManager.<clinit> to complete\n    // initialization of the global Logger.\n    void setLogManager(LogManager manager) {\n        this.manager = manager;\n    }\n    private void checkPermission() throws SecurityException {\n        if (!anonymous) {\n            if (manager == null) {\n                // Complete initialization of the global Logger.\n                manager = LogManager.getLogManager();\n            }\n            manager.checkPermission();\n        }\n    }\n    // Until all JDK code converted to call sun.util.logging.PlatformLogger\n    // (see 7054233), we need to determine if Logger.getLogger is to add\n    // a system logger or user logger.\n    //\n    // As an interim solution, if the immediate caller whose caller loader is\n    // null, we assume it's a system logger and add it to the system context.\n    // These system loggers only set the resource bundle to the given\n    // resource bundle name (rather than the default system resource bundle).\n    private static class LoggerHelper {\n        static boolean disableCallerCheck =\n            getBooleanProperty(\"sun.util.logging.disableCallerCheck\");\n        // workaround to turn on the old behavior for resource bundle search\n        static boolean allowStackWalkSearch =\n            getBooleanProperty(\"jdk.logging.allowStackWalkSearch\");\n        private static boolean getBooleanProperty(final String key) {\n            /* J2ObjC removed.\n            String s = AccessController.doPrivileged(new PrivilegedAction<String>() {\n                public String run() {\n                    return System.getProperty(key);\n                }\n            });\n            */\n            String s = System.getProperty(key);\n            return Boolean.valueOf(s);\n        }\n    }\n    private static Logger demandLogger(String name, String resourceBundleName, Class<?> caller) {\n        LogManager manager = LogManager.getLogManager();\n        /* J2ObjC modified.\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null && !LoggerHelper.disableCallerCheck) {\n        */\n        if (caller != null && !LoggerHelper.disableCallerCheck) {\n            if (caller.getClassLoader() == null) {\n                return manager.demandSystemLogger(name, resourceBundleName);\n            }\n        }\n        return manager.demandLogger(name, resourceBundleName, caller);\n        // ends up calling new Logger(name, resourceBundleName, caller)\n        // iff the logger doesn't exist already\n    }\n    /**\n     * Find or create a logger for a named subsystem.  If a logger has\n     * already been created with the given name it is returned.  Otherwise\n     * a new logger is created.\n     * <p>\n     * If a new logger is created its log level will be configured\n     * based on the LogManager configuration and it will configured\n     * to also send logging output to its parent's Handlers.  It will\n     * be registered in the LogManager global namespace.\n     * <p>\n     * Note: The LogManager may only retain a weak reference to the newly\n     * created Logger. It is important to understand that a previously\n     * created Logger with the given name may be garbage collected at any\n     * time if there is no strong reference to the Logger. In particular,\n     * this means that two back-to-back calls like\n     * {@code getLogger(\"MyLogger\").log(...)} may use different Logger\n     * objects named \"MyLogger\" if there is no strong reference to the\n     * Logger named \"MyLogger\" elsewhere in the program.\n     *\n     * @param   name            A name for the logger.  This should\n     *                          be a dot-separated name and should normally<fim_middle>// class below is blob\n"}