{"text": "<fim_prefix>   *\n   * @return the last segment of this path, or <code>null</code>\n   * @since 4.0.0-RC5\n   */\n  public String lastSegment() {\n    int len = segments.length;\n    return len == 0 ? null : segments[len - 1];\n  }\n  /**\n   * Returns an absolute path with the segments and device id of this path. Absolute paths start\n   * with a path separator. If this path is absolute, it is simply returned.\n   *\n   * @return the new path\n   * @since 4.0.0-RC5\n   */\n  public Path makeAbsolute() {\n    if (isAbsolute()) {\n      return this;\n    }\n    Path result = new Path(device, segments, separators | HAS_LEADING);\n    // may need canonicalizing if it has leading \"..\" or \".\" segments\n    if (result.segmentCount() > 0) {\n      String first = result.segment(0);\n      assert first != null;\n      if (first.equals(\"..\") || first.equals(\".\")) {\n        result.canonicalize();\n      }\n    }\n    return result;\n  }\n  /**\n   * Returns a relative path with the segments and device id of this path. Absolute paths start with\n   * a path separator and relative paths do not. If this path is relative, it is simply returned.\n   *\n   * @return the new path\n   * @since 4.0.0-RC5\n   */\n  public Path makeRelative() {\n    if (!isAbsolute()) {\n      return this;\n    }\n    return new Path(device, segments, separators & HAS_TRAILING);\n  }\n  /**\n   * Returns a path equivalent to this path, but relative to the given base path if possible.\n   *\n   * <p>The path is only made relative if the base path if both paths have the same device and have\n   * a non-zero length common prefix. If the paths have different devices, or no common prefix, then\n   * this path is simply returned. If the path is successfully made relative, then appending the\n   * returned path to the base will always produce a path equal to this path.\n   *\n   * @param base The base path to make this path relative to\n   * @return A path relative to the base path, or this path if it could not be made relative to the\n   *     given base\n   * @since 4.0.0-RC5\n   */\n  public Path makeRelativeTo(Path base) {\n    // can't make relative if devices are not equal\n    if (device != base.getDevice()\n        && (device == null || !device.equalsIgnoreCase(base.getDevice()))) return this;\n    int commonLength = matchingFirstSegments(base);\n    final int differenceLength = base.segmentCount() - commonLength;\n    final int newSegmentLength = differenceLength + segmentCount() - commonLength;\n    if (newSegmentLength == 0) return Path.EMPTY;\n    String[] newSegments = new String[newSegmentLength];\n    // add parent references for each segment different from the base\n    Arrays.fill(newSegments, 0, differenceLength, \"..\"); // $NON-NLS-1$\n    // append the segments of this path not in common with the base\n    System.arraycopy(\n        segments, commonLength, newSegments, differenceLength, newSegmentLength - differenceLength);\n    return new Path(null, newSegments, separators & HAS_TRAILING);\n  }\n  /**\n   * Return a new path which is the equivalent of this path converted to UNC form (if the given\n   * boolean is true) or this path not as a UNC path (if the given boolean is false). If UNC, the\n   * returned path will not have a device and the first 2 characters of the path string will be\n   * <code>Path.SEPARATOR</code>. If not UNC, the first 2 characters of the returned path string\n   * will not be <code>Path.SEPARATOR</code>.\n   *\n   * @param toUNC true if converting to UNC, false otherwise\n   * @return the new path, either in UNC form or not depending on the boolean parameter\n   * @since 4.0.0-RC5\n   */\n  public Path makeUNC(boolean toUNC) {\n    // if we are already in the right form then just return\n    if (!(toUNC ^ isUNC())) return this;\n    int newSeparators = this.separators;\n    if (toUNC) {\n      newSeparators |= HAS_LEADING | IS_UNC;\n    } else {\n      // mask out the UNC bit\n      newSeparators &= HAS_LEADING | HAS_TRAILING;\n    }\n    return new Path(toUNC ? null : device, segments, newSeparators);\n  }\n  /**\n   * Returns a count of the number of segments which match in this path and the given path (device\n   * ids are ignored), comparing in increasing segment number order.\n   *\n   * @param anotherPath the other path\n   * @return the number of matching segments\n   * @since 4.0.0-RC5\n   */\n  public int matchingFirstSegments(Path anotherPath) {\n    checkNotNull(anotherPath);\n    int anotherPathLen = anotherPath.segmentCount();\n    int max = Math.min(segments.length, anotherPathLen);\n    int count = 0;\n    for (int i = 0; i < max; i++) {\n      if (!segments[i].equals(anotherPath.segment(i))) {\n        return count;\n      }\n      count++;\n    }\n    return count;\n  }\n  /**\n   * Returns a new path which is the same as this path but with the file extension removed. If this\n   * path does not have an extension, this path is returned.\n   *\n   * <p>The file extension portion is defined as the string following the last period (\".\")\n   * character in the last segment. If there is no period in the last segment, the path has no file\n   * extension portion. If the last segment ends in a period, the file extension portion is the\n   * empty string.\n   *\n   * @return the new path\n   * @see #addFileExtension(String)\n   * @since 4.0.0-RC5\n   */\n  public Path removeFileExtension() {\n    String extension = getFileExtension();\n    if (extension == null || extension.equals(\"\")) {\n      return this;\n    }\n    String lastSegment = lastSegment();\n    int index = lastSegment.lastIndexOf(extension) - 1;\n    return removeLastSegments(1).append(lastSegment.substring(0, index));\n  }\n  /**\n   * Returns a copy of this path with the given number of segments removed from the beginning. The\n   * device id is preserved. The number must be greater or equal zero. If the count is zero, this\n   * path is returned. The resulting path will always be a relative path with respect to this path.\n   * If the number equals or exceeds the number of segments in this path, an empty relative path is\n   * returned.\n   *\n   * @param count the number of segments to remove\n   * @return the new path\n   * @since 4.0.0-RC5\n   */\n  public Path removeFirstSegments(int count) {\n    if (count == 0) return this;\n    if (count >= segments.length) {\n      return new Path(device, NO_SEGMENTS, 0);\n    }\n    checkArgument(count > 0);\n    int newSize = segments.length - count;\n    String[] newSegments = new String[newSize];\n    System.arraycopy(this.segments, count, newSegments, 0, newSize);\n    // result is always a relative path\n    return new Path(device, newSegments, separators & HAS_TRAILING);\n  }\n  /**\n   * Returns a copy of this path with the given number of segments removed from the end. The device\n   * id is preserved. The number must be greater or equal zero. If the count is zero, this path is\n   * returned.\n   *\n   * <p>If this path has a trailing separator, it will still have a trailing separator after the\n   * last segments are removed (assuming there are some segments left). If there is no trailing\n   * separator, the result will not have a trailing separator. If the number equals or exceeds the\n   * number of segments in this path, a path with no segments is returned.\n   *\n   * @param count the number of segments to remove\n   * @return the new path\n   * @since 4.0.0-RC5\n   */\n<fim_suffix>  public Path removeLastSegments(int count) {\n    if (count == 0) return this;\n    if (count >= segments.length) {\n      // result will have no trailing separator\n      return new Path(device, NO_SEGMENTS, separators & (HAS_LEADING | IS_UNC));\n    }\n    checkArgument(count > 0);\n    int newSize = segments.length - count;\n    String[] newSegments = new String[newSize];\n    System.arraycopy(this.segments, 0, newSegments, 0, newSize);\n    return new Path(device, newSegments, separators & (HAS_LEADING | IS_UNC));\n  }<fim_middle>// function below has no smell\n"}