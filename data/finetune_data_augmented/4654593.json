{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.flink.graph.types.valuearray;\nimport org.apache.flink.core.memory.DataInputView;\nimport org.apache.flink.core.memory.DataOutputView;\nimport org.apache.flink.core.memory.MemorySegment;\nimport org.apache.flink.graph.utils.MurmurHash;\nimport org.apache.flink.types.DoubleValue;\nimport org.apache.flink.types.IntValue;\nimport org.apache.flink.util.Preconditions;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Iterator;\n/**\n * An array of {@link DoubleValue}.\n */\npublic class DoubleValueArray\nimplements ValueArray<DoubleValue> {\n\tprotected static final int ELEMENT_LENGTH_IN_BYTES = 8;\n\tprotected static final int DEFAULT_CAPACITY_IN_BYTES = 1024;\n\t// see note in ArrayList, HashTable, ...\n\tprivate static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n\tprivate boolean isBounded;\n\tprivate double[] data;\n\t// the number of elements currently stored\n\tprivate int position;\n\t// location of the bookmark used by mark() and reset()\n\tprivate transient int mark;\n\t// hasher used to generate the normalized key\n\tprivate MurmurHash hash = new MurmurHash(0xae2f2cb7);\n\t// hash result stored as normalized key\n\tprivate IntValue hashValue = new IntValue();\n\t/**\n\t * Initializes an expandable array with default capacity.\n\t */\n\tpublic DoubleValueArray() {\n\t\tisBounded = false;\n\t\tinitialize(DEFAULT_CAPACITY_IN_BYTES);\n\t}\n\t/**\n\t * Initializes a fixed-size array with the provided number of doubles.\n\t *\n\t * @param bytes number of bytes of the encapsulated array\n\t */\n\tpublic DoubleValueArray(int bytes) {\n\t\tisBounded = true;\n\t\tinitialize(bytes);\n\t}\n\t/**\n\t * Initializes the array with the provided number of bytes.\n\t *\n\t * @param bytes initial size of the encapsulated array in bytes\n\t */\n\tprivate void initialize(int bytes) {\n\t\tint capacity = bytes / ELEMENT_LENGTH_IN_BYTES;\n\t\tPreconditions.checkArgument(capacity > 0, \"Requested array with zero capacity\");\n\t\tPreconditions.checkArgument(capacity <= MAX_ARRAY_SIZE, \"Requested capacity exceeds limit of \" + MAX_ARRAY_SIZE);\n\t\tdata = new double[capacity];\n\t}\n\t// --------------------------------------------------------------------------------------------\n\t/**\n\t * If the size of the array is insufficient to hold the given capacity then\n\t * copy the array into a new, larger array.\n\t *\n\t * @param minCapacity minimum required number of elements\n\t */\n\tprivate void ensureCapacity(int minCapacity) {\n\t\tlong currentCapacity = data.length;\n\t\tif (minCapacity <= currentCapacity) {\n\t\t\treturn;\n\t\t}\n\t\t// increase capacity by at least ~50%\n\t\tlong expandedCapacity = Math.max(minCapacity, currentCapacity + (currentCapacity >> 1));\n\t\tint newCapacity = (int) Math.min(MAX_ARRAY_SIZE, expandedCapacity);\n\t\tif (newCapacity < minCapacity) {\n\t\t\t// throw exception as unbounded arrays are not expected to fill\n\t\t\tthrow new RuntimeException(\"Requested array size \" + minCapacity + \" exceeds limit of \" + MAX_ARRAY_SIZE);\n\t\t}\n\t\tdata = Arrays.copyOf(data, newCapacity);\n\t}\n\t@Override\n\tpublic String toString() {\n\t\tStringBuilder sb = new StringBuilder(\"[\");\n\t\tfor (int idx = 0; idx < this.position; idx++) {\n\t\t\tsb.append(data[idx]);\n\t\t\tif (idx < position - 1) {\n\t\t\t\tsb.append(\",\");\n\t\t\t}\n\t\t}\n\t\tsb.append(\"]\");\n\t\treturn sb.toString();\n\t}\n\t// --------------------------------------------------------------------------------------------\n\t// Iterable\n\t// --------------------------------------------------------------------------------------------\n\tprivate final ReadIterator iterator = new ReadIterator();\n\t@Override\n\tpublic Iterator<DoubleValue> iterator() {\n\t\titerator.reset();\n\t\treturn iterator;\n\t}\n\tprivate class ReadIterator\n\timplements Iterator<DoubleValue> {\n\t\tprivate DoubleValue value = new DoubleValue();\n\t\tprivate int pos;\n\t\t@Override\n\t\tpublic boolean hasNext() {\n\t\t\treturn pos < position;\n\t\t}\n\t\t@Override\n\t\tpublic DoubleValue next() {\n\t\t\tvalue.setValue(data[pos++]);\n\t\t\treturn value;\n\t\t}\n\t\t@Override\n\t\tpublic void remove() {\n\t\t\tthrow new UnsupportedOperationException(\"remove\");\n\t\t}\n\t\tpublic void reset() {\n\t\t\tpos = 0;\n\t\t}\n\t}\n\t// --------------------------------------------------------------------------------------------\n\t// IOReadableWritable\n\t// --------------------------------------------------------------------------------------------\n<fim_suffix>\t@Override\n\tpublic void write(DataOutputView out) throws IOException {\n\t\tout.writeInt(position);\n\t\tfor (int i = 0; i < position; i++) {\n\t\t\tout.writeDouble(data[i]);\n\t\t}\n\t}\n\t@Override\n\tpublic void read(DataInputView in) throws IOException {\n\t\tposition = in.readInt();\n\t\tmark = 0;\n\t\tensureCapacity(position);\n\t\tfor (int i = 0; i < position; i++) {\n\t\t\tdata[i] = in.readDouble();\n\t\t}\n\t}\n\t// --------------------------------------------------------------------------------------------\n\t// NormalizableKey\n\t// --------------------------------------------------------------------------------------------\n\t@Override\n\tpublic int getMaxNormalizedKeyLen() {\n\t\treturn hashValue.getMaxNormalizedKeyLen();\n\t}\n\t@Override\n\tpublic void copyNormalizedKey(MemorySegment target, int offset, int len) {\n\t\thash.reset();\n\t\thash.hash(position);\n\t\tfor (int i = 0; i < position; i++) {\n\t\t\thash.hash(data[i]);\n\t\t}\n\t\thashValue.setValue(hash.hash());\n\t\thashValue.copyNormalizedKey(target, offset, len);\n\t}\n\t// --------------------------------------------------------------------------------------------\n\t// Comparable\n\t// --------------------------------------------------------------------------------------------\n\t@Override\n\tpublic int compareTo(ValueArray<DoubleValue> o) {\n\t\tDoubleValueArray other = (DoubleValueArray) o;\n\t\tint min = Math.min(position, other.position);\n\t\tfor (int i = 0; i < min; i++) {\n\t\t\tint cmp = Double.compare(data[i], other.data[i]);\n\t\t\tif (cmp != 0) {\n\t\t\t\treturn cmp;\n\t\t\t}\n\t\t}\n\t\treturn Integer.compare(position, other.position);\n\t}\n\t// --------------------------------------------------------------------------------------------\n\t// Key\n\t// --------------------------------------------------------------------------------------------\n\t@Override\n\tpublic int hashCode() {\n\t\tint hash = 0;\n\t\tfor (int i = 0; i < position; i++) {\n\t\t\tlong bits = Double.doubleToLongBits(data[i]);\n\t\t\thash = 31 * hash + (int) (bits + bits >>> 32);\n\t\t}\n\t\treturn hash;\n\t}\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (obj instanceof DoubleValueArray) {\n\t\t\tDoubleValueArray other = (DoubleValueArray) obj;\n\t\t\tif (position != other.position) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (int i = 0; i < position; i++) {\n\t\t\t\tif (data[i] != other.data[i]) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t// --------------------------------------------------------------------------------------------\n\t// ResettableValue\n\t// --------------------------------------------------------------------------------------------\n\t@Override\n\tpublic void setValue(ValueArray<DoubleValue> value) {\n\t\tvalue.copyTo(this);\n\t}\n\t// --------------------------------------------------------------------------------------------\n\t// CopyableValue\n\t// --------------------------------------------------------------------------------------------\n\t@Override\n\tpublic int getBinaryLength() {\n\t\treturn -1;\n\t}\n\t@Override\n\tpublic void copyTo(ValueArray<DoubleValue> target) {<fim_middle>// function below has no smell\n"}