{"text": "<fim_prefix>\t\tpublic static final String ACK_RANDOM_FACTOR = \"ACK_RANDOM_FACTOR\";\n\t\tpublic static final String ACK_TIMEOUT_SCALE = \"ACK_TIMEOUT_SCALE\";\n\t\tpublic static final String MAX_RETRANSMIT = \"MAX_RETRANSMIT\";\n\t\t/**\n\t\t * The EXCHANGE_LIFETIME as defined by the CoAP spec in MILLISECONDS.\n\t\t */\n\t\tpublic static final String EXCHANGE_LIFETIME = \"EXCHANGE_LIFETIME\";\n\t\tpublic static final String NON_LIFETIME = \"NON_LIFETIME\";\n\t\tpublic static final String MAX_TRANSMIT_WAIT = \"MAX_TRANSMIT_WAIT\";\n\t\tpublic static final String NSTART = \"NSTART\";\n\t\tpublic static final String LEISURE = \"LEISURE\";\n\t\tpublic static final String PROBING_RATE = \"PROBING_RATE\";\n\t\tpublic static final String USE_RANDOM_MID_START = \"USE_RANDOM_MID_START\";\n\t\tpublic static final String MID_TRACKER = \"MID_TACKER\";\n\t\tpublic static final String MID_TRACKER_GROUPS = \"MID_TRACKER_GROUPS\";\n\t\tpublic static final String TOKEN_SIZE_LIMIT = \"TOKEN_SIZE_LIMIT\";\n\t\t/**\n\t\t * The block size (number of bytes) to use when doing a blockwise\n\t\t * transfer. This value serves as the upper limit for block size in\n\t\t * blockwise transfers.\n\t\t */\n\t\tpublic static final String PREFERRED_BLOCK_SIZE = \"PREFERRED_BLOCK_SIZE\";\n\t\t/**\n\t\t * The maximum payload size (in bytes) that can be transferred in a\n\t\t * single message, i.e. without requiring a blockwise transfer.\n\t\t * \n\t\t * NB: this value MUST be adapted to the maximum message size supported\n\t\t * by the transport layer. In particular, this value cannot exceed the\n\t\t * network's MTU if UDP is used as the transport protocol.\n\t\t */\n\t\tpublic static final String MAX_MESSAGE_SIZE = \"MAX_MESSAGE_SIZE\";\n\t\t/**\n\t\t * The maximum size of a resource body (in bytes) that will be accepted\n\t\t * as the payload of a POST/PUT or the response to a GET request in a\n\t\t * <em>transparent</em> blockwise transfer.\n\t\t * <p>\n\t\t * This option serves as a safeguard against excessive memory\n\t\t * consumption when many resources contain large bodies that cannot be\n\t\t * transferred in a single CoAP message. This option has no impact on\n\t\t * *manually* managed blockwise transfers in which the blocks are\n\t\t * handled individually.\n\t\t * <p>\n\t\t * Note that this option does not prevent local clients or resource\n\t\t * implementations from sending large bodies as part of a request or\n\t\t * response to a peer.\n\t\t * <p>\n\t\t * The default value of this property is\n\t\t * {@link NetworkConfigDefaults#DEFAULT_MAX_RESOURCE_BODY_SIZE}.\n\t\t * <p>\n\t\t * A value of {@code 0} turns off transparent handling of blockwise\n\t\t * transfers altogether.\n\t\t */\n\t\tpublic static final String MAX_RESOURCE_BODY_SIZE = \"MAX_RESOURCE_BODY_SIZE\";\n\t\t/**\n\t\t * The maximum amount of time (in milliseconds) allowed between\n\t\t * transfers of individual blocks in a blockwise transfer before the\n\t\t * blockwise transfer state is discarded.\n\t\t * <p>\n\t\t * The default value of this property is\n\t\t * {@link NetworkConfigDefaults#DEFAULT_BLOCKWISE_STATUS_LIFETIME}.\n\t\t */\n\t\tpublic static final String BLOCKWISE_STATUS_LIFETIME = \"BLOCKWISE_STATUS_LIFETIME\";\n\t\tpublic static final String NOTIFICATION_CHECK_INTERVAL_TIME = \"NOTIFICATION_CHECK_INTERVAL\";\n\t\tpublic static final String NOTIFICATION_CHECK_INTERVAL_COUNT = \"NOTIFICATION_CHECK_INTERVAL_COUNT\";\n\t\tpublic static final String NOTIFICATION_REREGISTRATION_BACKOFF = \"NOTIFICATION_REREGISTRATION_BACKOFF\";\n\t\tpublic static final String USE_CONGESTION_CONTROL = \"USE_CONGESTION_CONTROL\";\n\t\tpublic static final String CONGESTION_CONTROL_ALGORITHM = \"CONGESTION_CONTROL_ALGORITHM\";\n\t\tpublic static final String PROTOCOL_STAGE_THREAD_COUNT = \"PROTOCOL_STAGE_THREAD_COUNT\";\n\t\tpublic static final String NETWORK_STAGE_RECEIVER_THREAD_COUNT = \"NETWORK_STAGE_RECEIVER_THREAD_COUNT\";\n\t\tpublic static final String NETWORK_STAGE_SENDER_THREAD_COUNT = \"NETWORK_STAGE_SENDER_THREAD_COUNT\";\n\t\tpublic static final String UDP_CONNECTOR_DATAGRAM_SIZE = \"UDP_CONNECTOR_DATAGRAM_SIZE\";\n\t\tpublic static final String UDP_CONNECTOR_RECEIVE_BUFFER = \"UDP_CONNECTOR_RECEIVE_BUFFER\";\n\t\tpublic static final String UDP_CONNECTOR_SEND_BUFFER = \"UDP_CONNECTOR_SEND_BUFFER\";\n\t\tpublic static final String UDP_CONNECTOR_OUT_CAPACITY = \"UDP_CONNECTOR_OUT_CAPACITY\";\n\t\tpublic static final String DEDUPLICATOR = \"DEDUPLICATOR\";\n\t\tpublic static final String DEDUPLICATOR_MARK_AND_SWEEP = \"DEDUPLICATOR_MARK_AND_SWEEP\";\n\t\t/**\n\t\t * The interval after which the next sweep run should occur (in\n\t\t * MILLISECONDS).\n\t\t */\n\t\tpublic static final String MARK_AND_SWEEP_INTERVAL = \"MARK_AND_SWEEP_INTERVAL\";\n\t\tpublic static final String DEDUPLICATOR_CROP_ROTATION = \"DEDUPLICATOR_CROP_ROTATION\";\n\t\tpublic static final String CROP_ROTATION_PERIOD = \"CROP_ROTATION_PERIOD\";\n\t\tpublic static final String NO_DEDUPLICATOR = \"NO_DEDUPLICATOR\";\n\t\tpublic static final String USE_STRICT_RESPONSE_MATCHING = \"USE_STRICT_RESPONSE_MATCHING\";\n\t\tpublic static final String HTTP_PORT = \"HTTP_PORT\";\n\t\tpublic static final String HTTP_SERVER_SOCKET_TIMEOUT = \"HTTP_SERVER_SOCKET_TIMEOUT\";\n\t\tpublic static final String HTTP_SERVER_SOCKET_BUFFER_SIZE = \"HTTP_SERVER_SOCKET_BUFFER_SIZE\";\n\t\tpublic static final String HTTP_CACHE_RESPONSE_MAX_AGE = \"HTTP_CACHE_RESPONSE_MAX_AGE\";\n\t\tpublic static final String HTTP_CACHE_SIZE = \"HTTP_CACHE_SIZE\";\n\t\tpublic static final String HEALTH_STATUS_PRINT_LEVEL = \"HEALTH_STATUS_PRINT_LEVEL\";\n\t\tpublic static final String HEALTH_STATUS_INTERVAL = \"HEALTH_STATUS_INTERVAL\";\n\t\t/** Properties for TCP connector. */\n\t\tpublic static final String TCP_CONNECTION_IDLE_TIMEOUT = \"TCP_CONNECTION_IDLE_TIMEOUT\";\n\t\tpublic static final String TCP_CONNECT_TIMEOUT = \"TCP_CONNECT_TIMEOUT\";\n\t\tpublic static final String TCP_WORKER_THREADS = \"TCP_WORKER_THREADS\";\n\t}\n\t/**\n\t * Gives access to the standard network configuration. When a new endpoint\n\t * or server is created without a specific network configuration, it will\n\t * use this standard configuration.\n\t * \n\t * @return the standard configuration\n\t */\n\tpublic static NetworkConfig getStandard() {\n\t\tsynchronized (NetworkConfig.class) {\n\t\t\tif (standard == null)\n\t\t\t\tcreateStandardWithFile(new File(DEFAULT_FILE_NAME));\n\t\t}\n\t\treturn standard;\n\t}\n\t/**\n\t * Sets the standard configuration.\n\t *\n\t * @param standard the new standard\n\t */\n\tpublic static void setStandard(final NetworkConfig standard) {\n\t\tNetworkConfig.standard = standard;\n\t}\n\t/**\n\t * Creates the standard without reading it or writing it to a file.\n\t *\n\t * @return the configuration\n\t */\n\tpublic static NetworkConfig createStandardWithoutFile() {\n\t\tLOGGER.config(\"Creating standard network configuration properties without a file\");\n\t\treturn standard = new NetworkConfig();\n\t}\n\t/**\n\t * Creates the standard from stream.\n\t *\n\t * Support environments without file access.\n\t * \n\t * @param inStream input stream to read properties.\n\t * @return the configuration\n\t */\n<fim_suffix>\tpublic static NetworkConfig createStandardFromStream(InputStream inStream) {\n\t\tLOGGER.config(\"Creating standard network configuration properties from stream\");\n\t\tstandard = new NetworkConfig();\n\t\ttry {\n\t\t\tstandard.load(inStream);\n\t\t} catch (IOException e) {\n\t\t\tLOGGER.log(Level.WARNING, \"cannot load properties from stream: {0}\", e.getMessage());\n\t\t}\n\t\treturn standard;\n\t}<fim_middle>// function below has no smell\n"}