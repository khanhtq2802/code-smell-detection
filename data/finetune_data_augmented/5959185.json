{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.openejb.core.security.jacc;\n\nimport org.apache.openejb.assembler.classic.DelegatePermissionCollection;\nimport org.apache.openejb.loader.SystemInstance;\n\nimport javax.security.jacc.PolicyConfiguration;\nimport javax.security.jacc.PolicyContextException;\nimport java.security.Permission;\nimport java.security.PermissionCollection;\nimport java.security.Principal;\nimport java.security.ProtectionDomain;\nimport java.util.Enumeration;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * @version $Rev$ $Date$\n */\npublic class BasicPolicyConfiguration implements PolicyConfiguration {\n    static final int OPEN = 1;\n    static final int IN_SERVICE = 2;\n    static final int DELETED = 3;\n\n    private final String contextID;\n    private int state;\n    protected final Map<String, PermissionCollection> rolePermissionsMap = new LinkedHashMap<>();\n    protected PermissionCollection unchecked;\n    protected PermissionCollection excluded;\n\n    protected BasicPolicyConfiguration(final String contextID) {\n        this.contextID = contextID;\n        this.state = OPEN;\n    }\n\n    public String getContextID() throws PolicyContextException {\n        return contextID;\n    }\n\n    public boolean implies(final ProtectionDomain domain, final Permission permission) {\n\n        if (excluded != null && excluded.implies(permission)) {\n            return false;\n        }\n\n        if (unchecked != null && unchecked.implies(permission)) {\n            return true;\n        }\n\n        final Principal[] principals = domain.getPrincipals();\n        if (principals.length == 0) {\n            return false;\n        }\n\n        final RoleResolver roleResolver = SystemInstance.get().getComponent(RoleResolver.class);\n        final Set<String> roles = roleResolver.getLogicalRoles(principals, rolePermissionsMap.keySet());\n\n        for (final String role : roles) {\n            final PermissionCollection permissions = rolePermissionsMap.get(role);\n\n            if (permissions != null && permissions.implies(permission)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public void addToRole(final String roleName, final PermissionCollection permissions) throws PolicyContextException {\n        if (state != OPEN) {\n            throw new UnsupportedOperationException(\"Not in an open state\");\n        }\n\n        final Enumeration e = permissions.elements();\n        while (e.hasMoreElements()) {\n            addToRole(roleName, (Permission) e.nextElement());\n        }\n    }\n\n    public void addToRole(final String roleName, final Permission permission) throws PolicyContextException {\n        if (state != OPEN) {\n            throw new UnsupportedOperationException(\"Not in an open state\");\n        }\n\n        PermissionCollection permissions = rolePermissionsMap.get(roleName);\n        if (permissions == null) {\n            permissions = new DelegatePermissionCollection();\n            rolePermissionsMap.put(roleName, permissions);\n        }\n        permissions.add(permission);\n    }\n\n    public void addToUncheckedPolicy(final PermissionCollection permissions) throws PolicyContextException {\n        if (state != OPEN) {\n            throw new UnsupportedOperationException(\"Not in an open state\");\n        }\n\n        final Enumeration e = permissions.elements();\n        while (e.hasMoreElements()) {\n            addToUncheckedPolicy((Permission) e.nextElement());\n        }\n    }\n\n    public void addToUncheckedPolicy(final Permission permission) throws PolicyContextException {\n        if (state != OPEN) {\n            throw new UnsupportedOperationException(\"Not in an open state\");\n        }\n\n        if (unchecked == null) {\n            unchecked = new DelegatePermissionCollection();\n        }\n\n        unchecked.add(permission);\n    }\n\n    public void addToExcludedPolicy(final PermissionCollection permissions) throws PolicyContextException {\n        if (state != OPEN) {\n            throw new UnsupportedOperationException(\"Not in an open state\");\n        }\n\n        final Enumeration e = permissions.elements();\n        while (e.hasMoreElements()) {\n            addToExcludedPolicy((Permission) e.nextElement());\n        }\n    }\n\n    public void addToExcludedPolicy(final Permission permission) throws PolicyContextException {\n        if (state != OPEN) {\n            throw new UnsupportedOperationException(\"Not in an open state\");\n        }\n\n        if (excluded == null) {\n            excluded = new DelegatePermissionCollection();\n        }\n\n        excluded.add(permission);\n    }\n\n    public void removeRole(final String roleName) throws PolicyContextException {\n        if (state != OPEN) {\n            throw new UnsupportedOperationException(\"Not in an open state\");\n        }\n\n        rolePermissionsMap.remove(roleName);\n    }\n\n    public void removeUncheckedPolicy() throws PolicyContextException {\n        if (state != OPEN) {\n            throw new UnsupportedOperationException(\"Not in an open state\");\n        }\n\n        unchecked = null;\n    }\n\n    public void removeExcludedPolicy() throws PolicyContextException {\n        if (state != OPEN) {\n            throw new UnsupportedOperationException(\"Not in an open state\");\n        }\n\n        excluded = null;\n    }\n\n    public void linkConfiguration(final PolicyConfiguration link) throws PolicyContextException {\n        if (state != OPEN) {\n            throw new UnsupportedOperationException(\"Not in an open state\");\n        }\n    }\n\n    public void delete() throws PolicyContextException {\n        state = DELETED;\n    }\n\n    public void commit() throws PolicyContextException {\n        if (state != OPEN) {\n            throw new UnsupportedOperationException(\"Not in an open state\");\n        }\n        state = IN_SERVICE;\n    }\n\n    public boolean inService() throws PolicyContextException {\n        return state == IN_SERVICE;\n    }\n\n    //TODO I have no idea what side effects this might have, but it's needed in some form from PolicyConfigurationFactoryImpl.\n    //see JACC spec 1.0 section 3.1.1.1 discussion of in service and deleted.\n    //spec p. 31 3.1.7 on the effects of remove:\n    //If the getPolicyConfiguration method  is used, the value true should be passed as the second\n    //  argument to cause the  corresponding policy statements to be deleted from the context.\n<fim_suffix>    public void open(final boolean remove) {\n        if (remove) {\n            rolePermissionsMap.clear();\n            unchecked = null;\n            excluded = null;\n        }\n        state = OPEN;\n    }\n\n    int getState() {\n        return state;\n    }\n\n    public interface RoleResolver {\n        Set<String> getLogicalRoles(Principal[] principals, Set<String> logicalRoles);\n    }\n}<fim_middle>// function below has no smell\n"}