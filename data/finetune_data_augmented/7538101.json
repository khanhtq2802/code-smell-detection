{"text": "<fim_prefix>\t * <p>\n\t * The actual list is delegated to the {@link SearchExecutor} and each\n\t * {@link NameClassPair} (this might be a NameClassPair or a subclass\n\t * thereof) is passed to the CallbackHandler. Any encountered\n\t * NamingException will be translated using the NamingExceptionTranslator.\n\t * \n\t * @param se the SearchExecutor to use for performing the actual list.\n\t * @param handler the NameClassPairCallbackHandler to which each found entry\n\t * will be passed.\n\t * @param processor DirContextProcessor for custom pre- and post-processing.\n\t * Must not be <code>null</code>. If no custom processing should take place,\n\t * please use e.g.\n\t * {@link #search(SearchExecutor, NameClassPairCallbackHandler)}.\n\t * @throws NamingException if any error occurs. Note that a\n\t * NameNotFoundException will be ignored. Instead this is interpreted that\n\t * no entries were found.\n\t */\n    @Override\n\tpublic void search(SearchExecutor se, NameClassPairCallbackHandler handler, DirContextProcessor processor) {\n\t\tDirContext ctx = contextSource.getReadOnlyContext();\n\t\tNamingEnumeration results = null;\n\t\tRuntimeException ex = null;\n\t\ttry {\n\t\t\tprocessor.preProcess(ctx);\n\t\t\tresults = se.executeSearch(ctx);\n\t\t\twhile (results.hasMore()) {\n\t\t\t\tNameClassPair result = (NameClassPair) results.next();\n\t\t\t\thandler.handleNameClassPair(result);\n\t\t\t}\n\t\t}\n\t\tcatch (NameNotFoundException e) {\n\t\t\t// It is possible to ignore errors caused by base not found\n\t\t\tif (ignoreNameNotFoundException) {\n\t\t\t\tLOG.warn(\"Base context not found, ignoring: \" + e.getMessage());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tex = LdapUtils.convertLdapException(e);\n\t\t\t}\n\t\t}\n\t\tcatch (PartialResultException e) {\n\t\t\t// Workaround for AD servers not handling referrals correctly.\n\t\t\tif (ignorePartialResultException) {\n\t\t\t\tLOG.debug(\"PartialResultException encountered and ignored\", e);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tex = LdapUtils.convertLdapException(e);\n\t\t\t}\n\t\t}\n        catch(SizeLimitExceededException e) {\n            if(ignoreSizeLimitExceededException) {\n                LOG.debug(\"SizeLimitExceededException encountered and ignored\", e);\n            }\n            else {\n                ex = LdapUtils.convertLdapException(e);\n            }\n        }\n\t\tcatch (javax.naming.NamingException e) {\n\t\t\tex = LdapUtils.convertLdapException(e);\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tprocessor.postProcess(ctx);\n\t\t\t}\n\t\t\tcatch (javax.naming.NamingException e) {\n\t\t\t\tif (ex == null) {\n\t\t\t\t\tex = LdapUtils.convertLdapException(e);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// We already had an exception from above and should ignore\n\t\t\t\t\t// this one.\n\t\t\t\t\tLOG.debug(\"Ignoring Exception from postProcess, \" + \"main exception thrown instead\", e);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcloseContextAndNamingEnumeration(ctx, results);\n\t\t\t// If we got an exception it should be thrown.\n\t\t\tif (ex != null) {\n\t\t\t\tthrow ex;\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * Perform a search operation, such as a search(), list() or listBindings().\n\t * This method handles all the plumbing; getting a readonly context; looping\n\t * through the NamingEnumeration and closing the context and enumeration.\n\t * <p>\n\t * The actual list is delegated to the {@link SearchExecutor} and each\n\t * {@link NameClassPair} (this might be a NameClassPair or a subclass\n\t * thereof) is passed to the CallbackHandler. Any encountered\n\t * NamingException will be translated using the NamingExceptionTranslator.\n\t * \n\t * @param se the SearchExecutor to use for performing the actual list.\n\t * @param handler the NameClassPairCallbackHandler to which each found entry\n\t * will be passed.\n\t * @throws NamingException if any error occurs. Note that a\n\t * NameNotFoundException will be ignored. Instead this is interpreted that\n\t * no entries were found.\n\t */\n    @Override\n\tpublic void search(SearchExecutor se, NameClassPairCallbackHandler handler) {\n\t\tsearch(se, handler, new NullDirContextProcessor());\n\t}\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n\tpublic void search(Name base, String filter, NameClassPairCallbackHandler handler) {\n\t\tSearchControls controls = getDefaultSearchControls(defaultSearchScope, DONT_RETURN_OBJ_FLAG, ALL_ATTRIBUTES);\n\t\tif (handler instanceof ContextMapperCallbackHandler) {\n\t\t\tassureReturnObjFlagSet(controls);\n\t\t}\n\t\tsearch(base, filter, controls, handler);\n\t}\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n\tpublic void search(String base, String filter, NameClassPairCallbackHandler handler) {\n\t\tSearchControls controls = getDefaultSearchControls(defaultSearchScope, DONT_RETURN_OBJ_FLAG, ALL_ATTRIBUTES);\n\t\tif (handler instanceof ContextMapperCallbackHandler) {\n\t\t\tassureReturnObjFlagSet(controls);\n\t\t}\n\t\tsearch(base, filter, controls, handler);\n\t}\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n\tpublic <T> List<T> search(Name base, String filter, int searchScope, String[] attrs, AttributesMapper<T> mapper) {\n\t\treturn search(base, filter, getDefaultSearchControls(searchScope, DONT_RETURN_OBJ_FLAG, attrs), mapper);\n\t}\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n\tpublic <T> List<T> search(String base, String filter, int searchScope, String[] attrs, AttributesMapper<T> mapper) {\n\t\treturn search(base, filter, getDefaultSearchControls(searchScope, DONT_RETURN_OBJ_FLAG, attrs), mapper);\n\t}\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n\tpublic <T> List<T> search(Name base, String filter, int searchScope, AttributesMapper<T> mapper) {\n\t\treturn search(base, filter, searchScope, ALL_ATTRIBUTES, mapper);\n\t}\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n\tpublic <T> List<T> search(String base, String filter, int searchScope, AttributesMapper<T> mapper) {\n\t\treturn search(base, filter, searchScope, ALL_ATTRIBUTES, mapper);\n\t}\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n\tpublic <T> List<T> search(Name base, String filter, AttributesMapper<T> mapper) {\n\t\treturn search(base, filter, defaultSearchScope, mapper);\n\t}\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n\tpublic <T> List<T> search(String base, String filter, AttributesMapper<T> mapper) {\n\t\treturn search(base, filter, defaultSearchScope, mapper);\n\t}\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n\tpublic <T> List<T> search(Name base, String filter, int searchScope, String[] attrs, ContextMapper<T> mapper) {\n\t\treturn search(base, filter, getDefaultSearchControls(searchScope, RETURN_OBJ_FLAG, attrs), mapper);\n\t}\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n\tpublic <T> List<T> search(String base, String filter, int searchScope, String[] attrs, ContextMapper<T> mapper) {\n\t\treturn search(base, filter, getDefaultSearchControls(searchScope, RETURN_OBJ_FLAG, attrs), mapper);\n\t}\n    /**\n     * {@inheritDoc}\n     */\n<fim_suffix>    @Override\n\tpublic <T> List<T> search(Name base, String filter, int searchScope, ContextMapper<T> mapper) {\n\t\treturn search(base, filter, searchScope, ALL_ATTRIBUTES, mapper);\n\t}<fim_middle>// function below has no smell\n"}