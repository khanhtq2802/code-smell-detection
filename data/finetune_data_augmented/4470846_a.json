{"text": "<fim_prefix> * {@link SchemaPath} objects, provided by the physical plan. The structure of\n * <tt>SchemaPath</tt> is a bit awkward:\n * <p>\n * <ul>\n * <li><tt>SchemaPath> is a wrapper for a column which directly holds the\n * <tt>NameSegment</tt> for the top-level column.</li>\n * <li><tt>NameSegment</tt> holds a name. This can be a top name such as\n * `a`, or parts of a compound name such as `a`.`b`. Each <tt>NameSegment</tt>\n * has a \"child\" that points to the option following parts of the name.</li>\n * <li><PathSegment</tt> is the base class for the parts of a name.</tt>\n * <li><tt>ArraySegment</tt> is the other kind of name part and represents\n * an array index such as the \"[1]\" in `columns`[1].</li>\n * <ul>\n * The parser here consumes only names, this mechanism does not consider\n * array indexes. As a result, there may be multiple projected columns that\n * map to the same projection here: `columns`[1] and `columns`[2] both map to\n * the name `columns`, for example.\n */\npublic class RequestedTupleImpl implements RequestedTuple {\n  private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(RequestedTupleImpl.class);\n  private final RequestedColumnImpl parent;\n  private final TupleNameSpace<RequestedColumn> projection = new TupleNameSpace<>();\n  public RequestedTupleImpl() {\n    parent = null;\n  }\n  public RequestedTupleImpl(RequestedColumnImpl parent) {\n    this.parent = parent;\n  }\n  public RequestedTupleImpl(List<RequestedColumn> cols) {\n    parent = null;\n    for (RequestedColumn col : cols) {\n      projection.add(col.name(), col);\n    }\n  }\n  @Override\n  public RequestedColumn get(String colName) {\n    return projection.get(colName.toLowerCase());\n  }\n  private RequestedColumnImpl getImpl(String colName) {\n    return (RequestedColumnImpl) get(colName);\n  }\n  @Override\n  public ProjectionType projectionType(String colName) {\n    RequestedColumn col = get(colName);\n    return col == null ? ProjectionType.UNPROJECTED : col.type();\n  }\n  @Override\n  public RequestedTuple mapProjection(String colName) {\n    RequestedColumnImpl col = getImpl(colName);\n    RequestedTuple mapProj = (col == null) ? null : col.mapProjection();\n    if (mapProj != null) {\n      return mapProj;\n    }\n    // No explicit information for the map. Members inherit the\n    // same projection as the map itself.\n    if (col != null) {\n      return col.projectAllMembers(true);\n    }\n    return ImpliedTupleRequest.NO_MEMBERS;\n  }\n  /**\n   * Create a requested tuple projection from a rewritten top-level\n   * projection list. The columns within the list have already been parsed to\n   * pick out arrays, maps and scalars. The list must not include the\n   * wildcard: a wildcard list must be passed in as a null list. An\n   * empty list means project nothing. Null list means project all, else\n   * project only the columns in the list.\n   *\n   * @param projList top-level, parsed columns\n   * @return the tuple projection for the top-leel row\n   */\n  public static RequestedTuple build(List<RequestedColumn> projList) {\n    if (projList == null) {\n      return new ImpliedTupleRequest(true);\n    }\n    if (projList.isEmpty()) {\n      return new ImpliedTupleRequest(false);\n    }\n    return new RequestedTupleImpl(projList);\n  }\n  /**\n   * Parse a projection list. The list should consist of a list of column names;\n   * or wildcards. An empty list means\n   * nothing is projected. A null list means everything is projected (that is, a\n   * null list here is equivalent to a wildcard in the SELECT statement.)\n   * <p>\n   * The projection list may include both a wildcard and column names (as in\n   * the case of implicit columns.) This results in a final list that both\n   * says that everything is projected, and provides the list of columns.\n   * <p>\n   * Parsing is used at two different times. First, to parse the list from\n   * the physical operator. This has the case above: an explicit wildcard\n   * and/or additional columns. Then, this class is used again to prepare the\n   * physical projection used when reading. In this case, wildcards should\n   * be removed, implicit columns pulled out, and just the list of read-level\n   * columns should remain.\n   *\n   * @param projList\n   *          the list of projected columns, or null if no projection is to be\n   *          done\n   * @return a projection set that implements the specified projection\n   */\n  public static RequestedTuple parse(Collection<SchemaPath> projList) {\n    if (projList == null) {\n      return new ImpliedTupleRequest(true);\n    }\n    if (projList.isEmpty()) {\n      return new ImpliedTupleRequest(false);\n    }\n    RequestedTupleImpl projSet = new RequestedTupleImpl();\n    for (SchemaPath col : projList) {\n      projSet.parseSegment(col.getRootSegment());\n    }\n    return projSet;\n  }\n  @Override\n  public void parseSegment(PathSegment pathSeg) {\n    if (pathSeg.isLastPath()) {\n      parseLeaf((NameSegment) pathSeg);\n    } else if (pathSeg.getChild().isArray()) {\n      parseArray((NameSegment) pathSeg);\n    } else {\n      parseInternal((NameSegment) pathSeg);\n    }\n  }\n  private void parseLeaf(NameSegment nameSeg) {\n    String name = nameSeg.getPath();\n    RequestedColumnImpl member = getImpl(name);\n    if (member == null) {\n      projection.add(name, new RequestedColumnImpl(this, name));\n      return;\n    }\n    if (member.isSimple() || member.isWildcard()) {\n      throw UserException\n        .validationError()\n        .message(\"Duplicate column in project list: %s\",\n            member.fullName())\n        .build(logger);\n    }\n    if (member.isArray()) {\n      // Saw both a and a[x]. Occurs in project list.\n      // Project all elements.\n      member.projectAllElements();\n      return;\n    }\n    // Else the column is a known map.\n    assert member.isTuple();\n    // Allow both a.b (existing) and a (this column)\n    // Since we we know a is a map, and we've projected the\n    // whole map, modify the projection of the column to\n    // project the entire map.\n    member.projectAllMembers(true);\n  }\n  private void parseInternal(NameSegment nameSeg) {\n    String name = nameSeg.getPath();\n    RequestedColumnImpl member = getImpl(name);\n    RequestedTuple map;\n    if (member == null) {\n      // New member. Since this is internal, this new member\n      // must be a map.\n      member = new RequestedColumnImpl(this, name);\n      projection.add(name, member);\n      map = member.asTuple();\n    } else if (member.isTuple()) {\n      // Known map. Add to it.\n      map = member.asTuple();\n    } else {\n      // Member was previously projected by itself. We now\n      // know it is a map. So, project entire map. (Earlier\n      // we saw `a`. Now we see `a`.`b`.)\n      map = member.projectAllMembers(true);\n    }\n    map.parseSegment(nameSeg.getChild());\n  }\n<fim_suffix>  private void parseArray(NameSegment nameSeg) {\n    String name = nameSeg.getPath();\n    ArraySegment arraySeg = ((ArraySegment) nameSeg.getChild());\n    int index = arraySeg.getIndex();\n    RequestedColumnImpl member = getImpl(name);\n    if (member == null) {\n      member = new RequestedColumnImpl(this, name);\n      projection.add(name, member);\n    } else if (member.isSimple()) {\n      // Saw both a and a[x]. Occurs in project list.\n      // Project all elements.\n      member.projectAllElements();\n      return;\n    } else if (member.hasIndex(index)) {\n      throw UserException\n        .validationError()\n        .message(\"Duplicate array index in project list: %s[%d]\",\n            member.fullName(), index)\n        .build(logger);\n    }\n    member.addIndex(index);\n    // Drills SQL parser does not support map arrays: a[0].c\n    // But, the SchemaPath does support them, so no harm in\n    // parsing them here.\n    if (! arraySeg.isLastPath()) {\n      parseInternal(nameSeg);\n    }\n  }<fim_middle>// function below is feature envy and long method\n"}