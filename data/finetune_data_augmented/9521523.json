{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.hadoop.fs.azurebfs.services;\nimport java.io.EOFException;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport com.google.common.base.Preconditions;\nimport org.apache.hadoop.fs.FSExceptionMessages;\nimport org.apache.hadoop.fs.FSInputStream;\nimport org.apache.hadoop.fs.FileSystem.Statistics;\nimport org.apache.hadoop.fs.azurebfs.contracts.exceptions.AbfsRestOperationException;\nimport org.apache.hadoop.fs.azurebfs.contracts.exceptions.AzureBlobFileSystemException;\n/**\n * The AbfsInputStream for AbfsClient.\n */\npublic class AbfsInputStream extends FSInputStream {\n  private final AbfsClient client;\n  private final Statistics statistics;\n  private final String path;\n  private final long contentLength;\n  private final int bufferSize; // default buffer size\n  private final int readAheadQueueDepth;         // initialized in constructor\n  private final String eTag;                  // eTag of the path when InputStream are created\n  private final boolean tolerateOobAppends; // whether tolerate Oob Appends\n  private final boolean readAheadEnabled; // whether enable readAhead;\n  private byte[] buffer = null;            // will be initialized on first use\n  private long fCursor = 0;  // cursor of buffer within file - offset of next byte to read from remote server\n  private long fCursorAfterLastRead = -1;\n  private int bCursor = 0;   // cursor of read within buffer - offset of next byte to be returned from buffer\n  private int limit = 0;     // offset of next byte to be read into buffer from service (i.e., upper marker+1\n  //                                                      of valid bytes in buffer)\n  private boolean closed = false;\n  public AbfsInputStream(\n      final AbfsClient client,\n      final Statistics statistics,\n      final String path,\n      final long contentLength,\n      final int bufferSize,\n      final int readAheadQueueDepth,\n      final boolean tolerateOobAppends,\n      final String eTag) {\n    this.client = client;\n    this.statistics = statistics;\n    this.path = path;\n    this.contentLength = contentLength;\n    this.bufferSize = bufferSize;\n    this.readAheadQueueDepth = (readAheadQueueDepth >= 0) ? readAheadQueueDepth : Runtime.getRuntime().availableProcessors();\n    this.tolerateOobAppends = tolerateOobAppends;\n    this.eTag = eTag;\n    this.readAheadEnabled = true;\n  }\n  public String getPath() {\n    return path;\n  }\n  @Override\n  public int read() throws IOException {\n    byte[] b = new byte[1];\n    int numberOfBytesRead = read(b, 0, 1);\n    if (numberOfBytesRead < 0) {\n      return -1;\n    } else {\n      return (b[0] & 0xFF);\n    }\n  }\n<fim_suffix>  @Override\n  public synchronized int read(final byte[] b, final int off, final int len) throws IOException {\n    int currentOff = off;\n    int currentLen = len;\n    int lastReadBytes;\n    int totalReadBytes = 0;\n    do {\n      lastReadBytes = readOneBlock(b, currentOff, currentLen);\n      if (lastReadBytes > 0) {\n        currentOff += lastReadBytes;\n        currentLen -= lastReadBytes;\n        totalReadBytes += lastReadBytes;\n      }\n      if (currentLen <= 0 || currentLen > b.length - currentOff) {\n        break;\n      }\n    } while (lastReadBytes > 0);\n    return totalReadBytes > 0 ? totalReadBytes : lastReadBytes;\n  }\n  private int readOneBlock(final byte[] b, final int off, final int len) throws IOException {\n    if (closed) {\n      throw new IOException(FSExceptionMessages.STREAM_IS_CLOSED);\n    }\n    Preconditions.checkNotNull(b);\n    if (len == 0) {\n      return 0;\n    }\n    if (this.available() == 0) {\n      return -1;\n    }\n    if (off < 0 || len < 0 || len > b.length - off) {\n      throw new IndexOutOfBoundsException();\n    }\n    //If buffer is empty, then fill the buffer.\n    if (bCursor == limit) {\n      //If EOF, then return -1\n      if (fCursor >= contentLength) {\n        return -1;\n      }\n      long bytesRead = 0;\n      //reset buffer to initial state - i.e., throw away existing data\n      bCursor = 0;\n      limit = 0;\n      if (buffer == null) {\n        buffer = new byte[bufferSize];\n      }\n      // Enable readAhead when reading sequentially\n      if (-1 == fCursorAfterLastRead || fCursorAfterLastRead == fCursor || b.length >= bufferSize) {\n        bytesRead = readInternal(fCursor, buffer, 0, bufferSize, false);\n      } else {\n        bytesRead = readInternal(fCursor, buffer, 0, b.length, true);\n      }\n      if (bytesRead == -1) {\n        return -1;\n      }\n      limit += bytesRead;\n      fCursor += bytesRead;\n      fCursorAfterLastRead = fCursor;\n    }\n    //If there is anything in the buffer, then return lesser of (requested bytes) and (bytes in buffer)\n    //(bytes returned may be less than requested)\n    int bytesRemaining = limit - bCursor;\n    int bytesToRead = Math.min(len, bytesRemaining);\n    System.arraycopy(buffer, bCursor, b, off, bytesToRead);\n    bCursor += bytesToRead;\n    if (statistics != null) {\n      statistics.incrementBytesRead(bytesToRead);\n    }\n    return bytesToRead;\n  }\n  private int readInternal(final long position, final byte[] b, final int offset, final int length,\n                           final boolean bypassReadAhead) throws IOException {\n    if (readAheadEnabled && !bypassReadAhead) {\n      // try reading from read-ahead\n      if (offset != 0) {\n        throw new IllegalArgumentException(\"readahead buffers cannot have non-zero buffer offsets\");\n      }\n      int receivedBytes;\n      // queue read-aheads\n      int numReadAheads = this.readAheadQueueDepth;\n      long nextSize;\n      long nextOffset = position;\n      while (numReadAheads > 0 && nextOffset < contentLength) {\n        nextSize = Math.min((long) bufferSize, contentLength - nextOffset);\n        ReadBufferManager.getBufferManager().queueReadAhead(this, nextOffset, (int) nextSize);\n        nextOffset = nextOffset + nextSize;\n        numReadAheads--;\n      }\n      // try reading from buffers first\n      receivedBytes = ReadBufferManager.getBufferManager().getBlock(this, position, length, b);\n      if (receivedBytes > 0) {\n        return receivedBytes;\n      }\n      // got nothing from read-ahead, do our own read now\n      receivedBytes = readRemote(position, b, offset, length);\n      return receivedBytes;\n    } else {\n      return readRemote(position, b, offset, length);\n    }\n  }\n  int readRemote(long position, byte[] b, int offset, int length) throws IOException {\n    if (position < 0) {\n      throw new IllegalArgumentException(\"attempting to read from negative offset\");\n    }\n    if (position >= contentLength) {\n      return -1;  // Hadoop prefers -1 to EOFException\n    }\n    if (b == null) {\n      throw new IllegalArgumentException(\"null byte array passed in to read() method\");\n    }\n    if (offset >= b.length) {\n      throw new IllegalArgumentException(\"offset greater than length of array\");\n    }\n    if (length < 0) {\n      throw new IllegalArgumentException(\"requested read length is less than zero\");\n    }\n    if (length > (b.length - offset)) {\n      throw new IllegalArgumentException(\"requested read length is more than will fit after requested offset in buffer\");\n    }\n    final AbfsRestOperation op;\n    try {\n      op = client.read(path, position, b, offset, length, tolerateOobAppends ? \"*\" : eTag);\n    } catch (AzureBlobFileSystemException ex) {\n      if (ex instanceof AbfsRestOperationException) {<fim_middle>// function below has no smell\n"}