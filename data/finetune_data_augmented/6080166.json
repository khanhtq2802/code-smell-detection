{"text": "<fim_prefix>        if (options.isSet(Option.CEYLONDISABLEOPT)) {\n            disabledOptimizations = EnumSet.allOf(Optimization.class);\n        } else {\n            disabledOptimizations = EnumSet.noneOf(Optimization.class);\n        }\n    }\n    public JCBlock transform(Tree.Block block) {\n        return block == null ? null : at(block).Block(0, transformBlock(block));\n    }\n    public List<JCStatement> transformBlock(Tree.Block block) {\n        return transformBlock(block, false);\n    }\n    public List<JCStatement> transformBlock(Tree.Block block, boolean revertRet) {\n        if (block == null) {\n            return List.<JCStatement>nil();\n        }\n        at(block);\n        CeylonVisitor v = gen().visitor;\n        final ListBuffer<JCTree> prevDefs = v.defs;\n        final boolean prevInInitializer = v.inInitializer;\n        final ClassDefinitionBuilder prevClassBuilder = v.classBuilder;\n        Tree.Block oldBlock = block;\n        currentBlock = block;\n        List<JCStatement> result;\n        try {\n            v.defs = new ListBuffer<JCTree>();\n            v.inInitializer = false;\n            v.classBuilder = current();\n            pushBlockImports(block);\n            java.util.Iterator<Statement> statements = block.getStatements().iterator();\n            while (statements.hasNext()) {\n                Tree.Statement stmt = statements.next();\n                Transformer<JCStatement, Return> returnTransformer;\n                if (revertRet \n                        && stmt instanceof Tree.Declaration) {\n                    returnTransformer = returnTransformer(defaultReturnTransformer);\n                } else {\n                    returnTransformer = this.returnTransformer;\n                }\n                try {\n                    HasErrorException error = errors().getFirstErrorBlock(stmt);\n                    if (error == null) {\n                        stmt.visit(v);\n                    } else {\n                        v.append(this.makeThrowUnresolvedCompilationError(error));\n                        break;\n                    }\n                } finally {\n                    returnTransformer(returnTransformer);\n                }\n            }\n            popBlockImports(block);\n            result = (List<JCStatement>) v.getResult().toList();\n            Runnable r = onEndBlock.get(block);\n            if (r != null) {\n                r.run();\n            }\n        } finally {\n            v.classBuilder = prevClassBuilder;\n            v.inInitializer = prevInInitializer;\n            v.defs = prevDefs;\n            // Close Substitutions which were scoped to this block\n            Scope scope = block.getScope();\n            while (scope instanceof ConditionScope) {\n                scope = scope.getScope();\n            }\n            naming.closeScopedSubstitutions(scope);\n            currentBlock = oldBlock;\n        }\n        return result;\n    }\n    private java.util.List<Tree.ImportList> blockImports = new ArrayList<>();\n    private void pushBlockImports(Tree.Block block) {\n        Tree.ImportList importList = block.getImportList();\n        if (importList != null) {\n            blockImports.add(importList);\n        }\n    }\n    private void popBlockImports(Tree.Block block) {\n        Tree.ImportList importList = block.getImportList();\n        if (importList != null) {\n            blockImports.remove(blockImports.size()-1);\n        }\n    }\n    /**\n     * Lookup the import of the given declaration, including in block local imports\n     * @param node The node where the lookup is required.\n     * @param decl The declaration to look up\n     * @return The import\n     */\n    @NonNull\n    public Import findImport(Node node, Declaration decl) {\n        Import foundImport = null;\n        // Try local imports first\n        for (int ii = blockImports.size()-1; ii >= 0; ii--) {\n            Tree.ImportList il = blockImports.get(ii);\n            for (Tree.Import i : il.getImports()) {\n                for (Tree.ImportMemberOrType importMemberOrType : i.getImportMemberOrTypeList().getImportMemberOrTypes()) {\n                    foundImport = findImport(decl, importMemberOrType);\n                    if (foundImport != null) {\n                        break;\n                    }\n                }\n            }\n        }\n        // Try the unit imports\n        if (foundImport == null) {\n            for(Import imp : node.getUnit().getImports()){\n                if(!imp.isAmbiguous()\n                        && imp.getTypeDeclaration() != null\n                        && imp.getDeclaration().equals(decl)){\n                    foundImport = imp;\n                    break;\n                }\n            }\n        }\n        if(foundImport == null)\n            throw new BugException(node, decl.getQualifiedNameString() + \" was not found as an import\");\n        return foundImport;\n    }\n    private Import findImport(Declaration decl, Tree.ImportMemberOrType importMemberOrType) {\n        Import foundImport = null;\n        Import imp = importMemberOrType.getImportModel();\n        if(!imp.isAmbiguous()\n                && imp.getTypeDeclaration() != null\n                && imp.getDeclaration().equals(decl)){\n            foundImport = imp;\n        }\n        if (foundImport == null) {\n            for (Tree.ImportMemberOrType nestedImport : importMemberOrType.getImportMemberOrTypeList().getImportMemberOrTypes()) {\n                foundImport = findImport(decl, nestedImport);\n                if (foundImport != null) {\n                    break;\n                }\n            }\n        }\n        return foundImport;\n    }\n<fim_suffix>    abstract class CondList {\n        protected final Node thenPart;\n        protected final java.util.List<Tree.Condition> conditions;\n        public CondList(java.util.List<Tree.Condition> conditions, Tree.Block thenPart) {\n            this.conditions = conditions;\n            this.thenPart = thenPart;\n        }\n        public CondList(java.util.List<Tree.Condition> conditions, Tree.Expression thenPart) {\n            this.conditions = conditions;\n            this.thenPart = thenPart;\n        }\n        protected Cond getConditionTransformer(Tree.Condition cond) {\n            return getConditionTransformer(cond, null);\n        }\n        protected Cond getConditionTransformer(Tree.Condition cond, Tree.Variable elseVariable) {\n            if (cond instanceof Tree.IsCondition) {\n                Tree.IsCondition is = (Tree.IsCondition)cond;\n                IsVarTrans var = new IsVarTrans(is.getVariable());\n                IsVarTrans elseVar = (elseVariable != null) ? new IsVarTrans(elseVariable, var.getTestVariableName()) : null;\n                return new IsCond(is, var, elseVar);\n            } else if (cond instanceof Tree.ExistsCondition) {\n                Tree.ExistsCondition exists = (Tree.ExistsCondition)cond;\n                ExistsVarTrans var = new ExistsVarTrans(exists.getVariable());\n                ExistsVarTrans elseVar = (elseVariable != null) ? new ExistsVarTrans(elseVariable, var.getTestVariableName()) : null;\n                return new ExistsCond(exists, var, elseVar);\n            } else if (cond instanceof Tree.NonemptyCondition) {\n                Tree.NonemptyCondition nonempty = (Tree.NonemptyCondition)cond;\n                NonemptyVarTrans var = new NonemptyVarTrans(nonempty.getVariable());\n                NonemptyVarTrans elseVar = (elseVariable != null) ? new NonemptyVarTrans(elseVariable, var.getTestVariableName()) : null;\n                return new NonemptyCond(nonempty, var, elseVar);\n            } else if (cond instanceof Tree.BooleanCondition) {\n                if (this instanceof AssertCondList) {\n                    Tree.Term booleanExpr = TreeUtil.unwrapExpressionUntilTerm(((Tree.BooleanCondition)cond).getExpression());\n                    boolean negated;\n                    if (booleanExpr instanceof Tree.NotOp) {\n                        negated = true;\n                        booleanExpr = TreeUtil.unwrapExpressionUntilTerm(((Tree.NotOp)booleanExpr).getTerm());\n                    } else {\n                        negated = false;\n                    }\n                    if (booleanExpr instanceof Tree.IsOp) {\n                        return new IsOpBooleanCond((Tree.BooleanCondition)cond, negated, (Tree.IsOp)booleanExpr);\n                    } else if (booleanExpr instanceof Tree.EqualityOp\n                            ||booleanExpr instanceof Tree.ComparisonOp) {\n                        return new EqualityOpBooleanCond((Tree.BooleanCondition)cond, negated, (Tree.BinaryOperatorExpression)booleanExpr);\n                    } else if (booleanExpr instanceof Tree.WithinOp) {\n                        return new WithinOpBooleanCond((Tree.BooleanCondition)cond, negated, (Tree.WithinOp)booleanExpr);\n                    }\n                }\n                return new BooleanCond((Tree.BooleanCondition)cond);\n            }\n            throw BugException.unhandledNodeCase(cond);\n        }\n        protected List<JCStatement> transformList(java.util.List<Tree.Condition> conditions) {\n            Tree.Condition condition = conditions.get(0);\n            at(condition);\n            if (conditions.size() == 1) {\n                return transformInnermost(condition);\n            } else {\n                return transformIntermediate(condition, conditions.subList(1, conditions.size()));\n            }\n        }\n        protected abstract List<JCStatement> transformInnermost(Tree.Condition condition);\n        protected List<JCStatement> transformIntermediate(Tree.Condition condition, java.util.List<Tree.Condition> rest) {\n            return transformList(rest);\n        }\n        public abstract List<JCStatement> getResult();\n    }<fim_middle>// class below has no smell\n"}