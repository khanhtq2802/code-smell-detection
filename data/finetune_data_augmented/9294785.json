{"text": "<fim_prefix>/*\n * Copyright (c) 2010, 2013, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage jdk.nashorn.internal.objects;\nimport static jdk.nashorn.internal.codegen.CompilerConstants.specialCall;\nimport java.lang.invoke.MethodHandle;\nimport java.lang.invoke.MethodHandles;\nimport java.nio.ByteBuffer;\nimport java.nio.DoubleBuffer;\nimport jdk.nashorn.internal.objects.annotations.Attribute;\nimport jdk.nashorn.internal.objects.annotations.Constructor;\nimport jdk.nashorn.internal.objects.annotations.Function;\nimport jdk.nashorn.internal.objects.annotations.Property;\nimport jdk.nashorn.internal.objects.annotations.ScriptClass;\nimport jdk.nashorn.internal.objects.annotations.Where;\nimport jdk.nashorn.internal.runtime.JSType;\nimport jdk.nashorn.internal.runtime.PropertyMap;\nimport jdk.nashorn.internal.runtime.ScriptObject;\nimport jdk.nashorn.internal.runtime.arrays.ArrayData;\nimport jdk.nashorn.internal.runtime.arrays.TypedArrayData;\n/**\n * Float64 array for the TypedArray extension\n */\n@ScriptClass(\"Float64Array\")\npublic final class NativeFloat64Array extends ArrayBufferView {\n    /**\n     * The size in bytes of each element in the array.\n     */\n    @Property(attributes = Attribute.NOT_ENUMERABLE | Attribute.NOT_WRITABLE | Attribute.NOT_CONFIGURABLE, where = Where.CONSTRUCTOR)\n    public static final int BYTES_PER_ELEMENT = 8;\n    // initialized by nasgen\n    @SuppressWarnings(\"unused\")\n    private static PropertyMap $nasgenmap$;\n    private static final Factory FACTORY = new Factory(BYTES_PER_ELEMENT) {\n        @Override\n        public ArrayBufferView construct(final NativeArrayBuffer buffer, final int byteOffset, final int length) {\n            return new NativeFloat64Array(buffer, byteOffset, length);\n        }\n        @Override\n        public Float64ArrayData createArrayData(final ByteBuffer nb, final int start, final int length) {\n            return new Float64ArrayData(nb.asDoubleBuffer(), start, length);\n        }\n        @Override\n        public String getClassName() {\n            return \"Float64Array\";\n        }\n    };\n    private static final class Float64ArrayData extends TypedArrayData<DoubleBuffer> {\n        private static final MethodHandle GET_ELEM = specialCall(MethodHandles.lookup(), Float64ArrayData.class, \"getElem\", double.class, int.class).methodHandle();\n        private static final MethodHandle SET_ELEM = specialCall(MethodHandles.lookup(), Float64ArrayData.class, \"setElem\", void.class, int.class, double.class).methodHandle();\n        private Float64ArrayData(final DoubleBuffer nb, final int start, final int end) {\n            super((nb.position(start).limit(end)).slice(), end - start);\n        }\n        @Override\n        protected MethodHandle getGetElem() {\n            return GET_ELEM;\n        }\n        @Override\n        protected MethodHandle getSetElem() {\n            return SET_ELEM;\n        }\n        @Override\n        public Class<?> getElementType() {\n            return double.class;\n        }\n        @Override\n        public Class<?> getBoxedElementType() {\n            return Double.class;\n        }\n        private double getElem(final int index) {\n            try {\n                return nb.get(index);\n            } catch (final IndexOutOfBoundsException e) {\n                throw new ClassCastException(); //force relink - this works for unoptimistic too\n            }\n        }\n<fim_suffix>        private void setElem(final int index, final double elem) {\n            try {\n                if (index < nb.limit()) {\n                    nb.put(index, elem);\n                }\n            } catch (final IndexOutOfBoundsException e) {\n                throw new ClassCastException();\n             }\n        }\n        @Override\n        public MethodHandle getElementGetter(final Class<?> returnType, final int programPoint) {\n            if (returnType == int.class) {\n                return null;\n            }\n            return getContinuousElementGetter(getClass(), GET_ELEM, returnType, programPoint);\n        }\n        @Override\n        public int getInt(final int index) {\n            return (int)getDouble(index);\n        }\n        @Override\n        public double getDouble(final int index) {\n            return getElem(index);\n        }\n        @Override\n        public double getDoubleOptimistic(final int index, final int programPoint) {\n            return getElem(index);\n        }\n        @Override\n        public Object getObject(final int index) {\n            return getDouble(index);\n        }\n        @Override\n        public ArrayData set(final int index, final Object value, final boolean strict) {\n            return set(index, JSType.toNumber(value), strict);\n        }\n        @Override\n        public ArrayData set(final int index, final int value, final boolean strict) {\n            return set(index, (double)value, strict);\n        }\n        @Override\n        public ArrayData set(final int index, final double value, final boolean strict) {\n            setElem(index, value);\n            return this;\n        }\n    }\n    /**\n     * Constructor\n     *\n     * @param newObj is this typed array instantiated with the new operator\n     * @param self   self reference\n     * @param args   args\n     *\n     * @return new typed array\n     */\n    @Constructor(arity = 1)\n    public static NativeFloat64Array constructor(final boolean newObj, final Object self, final Object... args) {\n        return (NativeFloat64Array)constructorImpl(newObj, args, FACTORY);\n    }\n    NativeFloat64Array(final NativeArrayBuffer buffer, final int byteOffset, final int length) {\n        super(buffer, byteOffset, length);\n    }\n    @Override\n    protected Factory factory() {\n        return FACTORY;\n    }\n    @Override\n    protected boolean isFloatArray() {\n        return true;\n    }\n    /**\n     * Set values\n     * @param self   self reference\n     * @param array  multiple values of array's type to set\n     * @param offset optional start index, interpreted  0 if undefined\n     * @return undefined\n     */\n    @Function(attributes = Attribute.NOT_ENUMERABLE)\n    protected static Object set(final Object self, final Object array, final Object offset) {\n        return ArrayBufferView.setImpl(self, array, offset);\n    }\n    /**\n     * Returns a new TypedArray view of the ArrayBuffer store for this TypedArray,\n     * referencing the elements at begin, inclusive, up to end, exclusive. If either\n     * begin or end is negative, it refers to an index from the end of the array,\n     * as opposed to from the beginning.\n     * <p>\n     * If end is unspecified, the subarray contains all elements from begin to the end\n     * of the TypedArray. The range specified by the begin and end values is clamped to\n     * the valid index range for the current array. If the computed length of the new\n     * TypedArray would be negative, it is clamped to zero.\n     * <p>\n     * The returned TypedArray will be of the same type as the array on which this\n     * method is invoked.\n     *\n     * @param self self reference\n     * @param begin begin position\n     * @param end end position\n     *\n     * @return sub array\n     */\n    @Function(attributes = Attribute.NOT_ENUMERABLE)\n    protected static NativeFloat64Array subarray(final Object self, final Object begin, final Object end) {\n        return (NativeFloat64Array)ArrayBufferView.subarrayImpl(self, begin, end);\n    }\n    /**\n     * ECMA 6 22.2.3.30 %TypedArray%.prototype [ @@iterator ] ( )\n     *\n     * @param self the self reference<fim_middle>// function below has no smell\n"}