{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.struts2.el.parser;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\nimport javax.el.ELException;\nimport javax.el.FunctionMapper;\n\nimport org.apache.struts2.el.lang.EvaluationContext;\nimport org.apache.struts2.el.util.MessageFactory;\n\n\n/**\n * @author Jacob Hookom [jacob@hookom.net]\n * @version $Change: 181177 $$DateTime: 2001/06/26 08:45:09 $$Author: markt $\n */\npublic final class AstFunction extends SimpleNode {\n\n    protected String localName = \"\";\n\n    protected String prefix = \"\";\n\n    public AstFunction(int id) {\n        super(id);\n    }\n\n    public String getLocalName() {\n        return localName;\n    }\n\n<fim_suffix>    public String getOutputName() {\n        if (this.prefix == null) {\n            return this.localName;\n        } else {\n            return this.prefix + \":\" + this.localName;\n        }\n    }\n\n    public String getPrefix() {\n        return prefix;\n    }\n\n    public Class getType(EvaluationContext ctx)\n            throws ELException {\n        \n        FunctionMapper fnMapper = ctx.getFunctionMapper();\n        \n        // quickly validate again for this request\n        if (fnMapper == null) {\n            throw new ELException(MessageFactory.get(\"error.fnMapper.null\"));\n        }\n        Method m = fnMapper.resolveFunction(this.prefix, this.localName);\n        if (m == null) {\n            throw new ELException(MessageFactory.get(\"error.fnMapper.method\",\n                    this.getOutputName()));\n        }\n        return m.getReturnType();\n    }\n\n    public Object getValue(EvaluationContext ctx)\n            throws ELException {\n        \n        FunctionMapper fnMapper = ctx.getFunctionMapper();\n        \n        // quickly validate again for this request\n        if (fnMapper == null) {\n            throw new ELException(MessageFactory.get(\"error.fnMapper.null\"));\n        }\n        Method m = fnMapper.resolveFunction(this.prefix, this.localName);\n        if (m == null) {\n            throw new ELException(MessageFactory.get(\"error.fnMapper.method\",\n                    this.getOutputName()));\n        }\n\n        Class[] paramTypes = m.getParameterTypes();\n        Object[] params = null;\n        Object result = null;\n        int numParams = this.jjtGetNumChildren();\n        if (numParams > 0) {\n            params = new Object[numParams];\n            try {\n                for (int i = 0; i < numParams; i++) {\n                    params[i] = this.children[i].getValue(ctx);\n                    params[i] = coerceToType(params[i], paramTypes[i]);\n                }\n            } catch (ELException ele) {\n                throw new ELException(MessageFactory.get(\"error.function\", this\n                        .getOutputName()), ele);\n            }\n        }\n        try {\n            result = m.invoke(null, params);\n        } catch (IllegalAccessException iae) {\n            throw new ELException(MessageFactory.get(\"error.function\", this\n                    .getOutputName()), iae);\n        } catch (InvocationTargetException ite) {\n            throw new ELException(MessageFactory.get(\"error.function\", this\n                    .getOutputName()), ite.getCause());\n        }\n        return result;\n    }\n\n    public void setLocalName(String localName) {\n        this.localName = localName;\n    }\n\n    public void setPrefix(String prefix) {\n        this.prefix = prefix;\n    }\n    \n    \n    public String toString()\n    {\n        return ELParserTreeConstants.jjtNodeName[id] + \"[\" + this.getOutputName() + \"]\";\n    }\n}<fim_middle>// function below has no smell\n"}