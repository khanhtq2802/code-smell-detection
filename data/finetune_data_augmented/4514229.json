{"text": "<fim_prefix>      }\n      for (int i = 0; i < numberQuadruple; i++)\n      {\n         dataIndex = i * 4;\n         marker0 = base64Data[dataIndex + 2];\n         marker1 = base64Data[dataIndex + 3];\n         b1 = base64Alphabet[base64Data[dataIndex]];\n         b2 = base64Alphabet[base64Data[dataIndex + 1]];\n         if (marker0 != PAD && marker1 != PAD)\n         {\n            //No PAD e.g 3cQl\n            b3 = base64Alphabet[marker0];\n            b4 = base64Alphabet[marker1];\n            decodedData[encodedIndex] = (byte)(b1 << 2 | b2 >> 4);\n            decodedData[encodedIndex + 1] =\n                    (byte)(((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n            decodedData[encodedIndex + 2] = (byte)(b3 << 6 | b4);\n         }\n         else if (marker0 == PAD)\n         {\n            //Two PAD e.g. 3c[Pad][Pad]\n            decodedData[encodedIndex] = (byte)(b1 << 2 | b2 >> 4);\n         }\n         else if (marker1 == PAD)\n         {\n            //One PAD e.g. 3cQ[Pad]\n            b3 = base64Alphabet[marker0];\n            decodedData[encodedIndex] = (byte)(b1 << 2 | b2 >> 4);\n            decodedData[encodedIndex + 1] =\n                    (byte)(((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));\n         }\n         encodedIndex += 3;\n      }\n      return decodedData;\n   }\n   private static byte[] encodeBase64Chunked(byte[] binaryData)\n   {\n      return (encodeBase64(binaryData, true));\n   }\n   private static boolean isBase64(byte octect)\n   {\n      if (octect == PAD)\n      {\n         return true;\n      }\n      else if (base64Alphabet[octect] == -1)\n      {\n         return false;\n      }\n      else\n      {\n         return true;\n      }\n   }\n<fim_suffix>   private static byte[] encodeBase64(byte[] binaryData, boolean isChunked)\n   {\n      int lengthDataBits = binaryData.length * EIGHTBIT;\n      int fewerThan24bits = lengthDataBits % TWENTYFOURBITGROUP;\n      int numberTriplets = lengthDataBits / TWENTYFOURBITGROUP;\n      byte encodedData[] = null;\n      int encodedDataLength = 0;\n      int nbrChunks = 0;\n      if (fewerThan24bits != 0)\n      {\n         //data not divisible by 24 bit\n         encodedDataLength = (numberTriplets + 1) * 4;\n      }\n      else\n      {\n         // 16 or 8 bit\n         encodedDataLength = numberTriplets * 4;\n      }\n      // If the output is to be \"chunked\" into 76 character sections,\n      // for compliance with RFC 2045 MIME, then it is important to\n      // allow for extra length to account for the separator(s)\n      if (isChunked)\n      {\n         nbrChunks =\n                 (CHUNK_SEPARATOR.length == 0\n                 ? 0\n                 : (int)Math.ceil((float)encodedDataLength / CHUNK_SIZE));\n         encodedDataLength += nbrChunks * CHUNK_SEPARATOR.length;\n      }\n      encodedData = new byte[encodedDataLength];\n      byte k = 0, l = 0, b1 = 0, b2 = 0, b3 = 0;\n      int encodedIndex = 0;\n      int dataIndex = 0;\n      int i = 0;\n      int nextSeparatorIndex = CHUNK_SIZE;\n      int chunksSoFar = 0;\n      //log.debug(\"number of triplets = \" + numberTriplets);\n      for (i = 0; i < numberTriplets; i++)\n      {\n         dataIndex = i * 3;\n         b1 = binaryData[dataIndex];\n         b2 = binaryData[dataIndex + 1];\n         b3 = binaryData[dataIndex + 2];\n         //log.debug(\"b1= \" + b1 +\", b2= \" + b2 + \", b3= \" + b3);\n         l = (byte)(b2 & 0x0f);\n         k = (byte)(b1 & 0x03);\n         byte val1 =\n                 ((b1 & SIGN) == 0)\n                 ? (byte)(b1 >> 2)\n                 : (byte)((b1) >> 2 ^ 0xc0);\n         byte val2 =\n                 ((b2 & SIGN) == 0)\n                 ? (byte)(b2 >> 4)\n                 : (byte)((b2) >> 4 ^ 0xf0);\n         byte val3 =\n                 ((b3 & SIGN) == 0)\n                 ? (byte)(b3 >> 6)\n                 : (byte)((b3) >> 6 ^ 0xfc);\n         encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n         //log.debug( \"val2 = \" + val2 );\n         //log.debug( \"k4   = \" + (k<<4) );\n         //log.debug(  \"vak  = \" + (val2 | (k<<4)) );\n         encodedData[encodedIndex + 1] =\n                 lookUpBase64Alphabet[val2 | (k << 4)];\n         encodedData[encodedIndex + 2] =\n                 lookUpBase64Alphabet[(l << 2) | val3];\n         encodedData[encodedIndex + 3] = lookUpBase64Alphabet[b3 & 0x3f];\n         encodedIndex += 4;\n         // If we are chunking, let's put a chunk separator down.\n         if (isChunked)\n         {\n            // this assumes that CHUNK_SIZE % 4 == 0\n            if (encodedIndex == nextSeparatorIndex)\n            {\n               System.arraycopy(\n                       CHUNK_SEPARATOR,\n                       0,\n                       encodedData,\n                       encodedIndex,\n                       CHUNK_SEPARATOR.length);\n               chunksSoFar++;\n               nextSeparatorIndex =\n                       (CHUNK_SIZE * (chunksSoFar + 1))\n                       + (chunksSoFar * CHUNK_SEPARATOR.length);\n               encodedIndex += CHUNK_SEPARATOR.length;\n            }\n         }\n      }\n      // form integral number of 6-bit groups\n      dataIndex = i * 3;\n      if (fewerThan24bits == EIGHTBIT)\n      {\n         b1 = binaryData[dataIndex];\n         k = (byte)(b1 & 0x03);\n         //log.debug(\"b1=\" + b1);\n         //log.debug(\"b1<<2 = \" + (b1>>2) );\n         byte val1 =\n                 ((b1 & SIGN) == 0)\n                 ? (byte)(b1 >> 2)\n                 : (byte)((b1) >> 2 ^ 0xc0);\n         encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n         encodedData[encodedIndex + 1] = lookUpBase64Alphabet[k << 4];\n         encodedData[encodedIndex + 2] = PAD;\n         encodedData[encodedIndex + 3] = PAD;\n      }\n      else if (fewerThan24bits == SIXTEENBIT)\n      {\n         b1 = binaryData[dataIndex];\n         b2 = binaryData[dataIndex + 1];\n         l = (byte)(b2 & 0x0f);\n         k = (byte)(b1 & 0x03);\n         byte val1 =\n                 ((b1 & SIGN) == 0)\n                 ? (byte)(b1 >> 2)\n                 : (byte)((b1) >> 2 ^ 0xc0);\n         byte val2 =\n                 ((b2 & SIGN) == 0)\n                 ? (byte)(b2 >> 4)\n                 : (byte)((b2) >> 4 ^ 0xf0);\n         encodedData[encodedIndex] = lookUpBase64Alphabet[val1];\n         encodedData[encodedIndex + 1] =\n                 lookUpBase64Alphabet[val2 | (k << 4)];\n         encodedData[encodedIndex + 2] = lookUpBase64Alphabet[l << 2];\n         encodedData[encodedIndex + 3] = PAD;\n      }\n      if (isChunked)\n      {\n         // we also add a separator to the end of the final chunk.\n         if (chunksSoFar < nbrChunks)\n         {\n            System.arraycopy(\n                    CHUNK_SEPARATOR,\n                    0,\n                    encodedData,\n                    encodedDataLength - CHUNK_SEPARATOR.length,\n                    CHUNK_SEPARATOR.length);\n         }\n      }\n      return encodedData;\n   }<fim_middle>// function below is long method\n"}