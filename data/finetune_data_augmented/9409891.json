{"text": "<fim_prefix>/*\n * Copyright (c) 1999, 2013, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage com.sun.jndi.toolkit.url;\nimport javax.naming.*;\nimport javax.naming.spi.ResolveResult;\nimport javax.naming.spi.NamingManager;\nimport java.util.Hashtable;\nimport java.net.MalformedURLException;\n/**\n * This abstract class is a generic URL context that accepts as the\n * name argument either a string URL or a Name whose first component\n * is a URL. It resolves the URL to a target context and then continues\n * the operation using the remaining name in the target context as if\n * the first component names a junction.\n *\n * A subclass must define getRootURLContext()\n * to process the URL into head/tail pieces. If it wants to control how\n * URL strings are parsed and compared for the rename() operation, then\n * it should override getNonRootURLSuffixes() and urlEquals().\n *\n * @author Scott Seligman\n * @author Rosanna Lee\n */\nabstract public class GenericURLContext implements Context {\n    protected Hashtable<String, Object> myEnv = null;\n    @SuppressWarnings(\"unchecked\") // Expect Hashtable<String, Object>\n    public GenericURLContext(Hashtable<?,?> env) {\n        // context that is not tied to any specific URL\n        myEnv =\n            (Hashtable<String, Object>)(env == null ? null : env.clone());\n    }\n    public void close() throws NamingException {\n        myEnv = null;\n    }\n    public String getNameInNamespace() throws NamingException {\n        return \"\"; // %%% check this out: A URL context's name is \"\"\n    }\n    /**\n      * Resolves 'name' into a target context with remaining name.\n      * For example, with a JNDI URL \"jndi://dnsname/rest_name\",\n      * this method resolves \"jndi://dnsname/\" to a target context,\n      * and returns the target context with \"rest_name\".\n      * The definition of \"root URL\" and how much of the URL to\n      * consume is implementation specific.\n      * If rename() is supported for a particular URL scheme,\n      * getRootURLContext(), getURLPrefix(), and getURLSuffix()\n      * must be in sync wrt how URLs are parsed and returned.\n      */\n    abstract protected ResolveResult getRootURLContext(String url,\n        Hashtable<?,?> env) throws NamingException;\n    /**\n      * Returns the suffix of the url. The result should be identical to\n      * that of calling getRootURLContext().getRemainingName(), but\n      * without the overhead of doing anything with the prefix like\n      * creating a context.\n      *<p>\n      * This method returns a Name instead of a String because to give\n      * the provider an opportunity to return a Name (for example,\n      * for weakly separated naming systems like COS naming).\n      *<p>\n      * The default implementation uses skips 'prefix', calls\n      * UrlUtil.decode() on it, and returns the result as a single component\n      * CompositeName.\n      * Subclass should override if this is not appropriate.\n      * This method is used only by rename().\n      * If rename() is supported for a particular URL scheme,\n      * getRootURLContext(), getURLPrefix(), and getURLSuffix()\n      * must be in sync wrt how URLs are parsed and returned.\n      *<p>\n      * For many URL schemes, this method is very similar to URL.getFile(),\n      * except getFile() will return a leading slash in the\n      * 2nd, 3rd, and 4th cases. For schemes like \"ldap\" and \"iiop\",\n      * the leading slash must be skipped before the name is an acceptable\n      * format for operation by the Context methods. For schemes that treat the\n      * leading slash as significant (such as \"file\"),\n      * the subclass must override getURLSuffix() to get the correct behavior.\n      * Remember, the behavior must match getRootURLContext().\n      *\n      * <pre>{@code\n      * URL                                     Suffix\n      * foo://host:port                         <empty string>\n      * foo://host:port/rest/of/name            rest/of/name\n      * foo:///rest/of/name                     rest/of/name\n      * foo:/rest/of/name                       rest/of/name\n      * foo:rest/of/name                        rest/of/name\n      * }</pre>\n      */\n    protected Name getURLSuffix(String prefix, String url) throws NamingException {\n        String suffix = url.substring(prefix.length());\n        if (suffix.length() == 0) {\n            return new CompositeName();\n        }\n        if (suffix.charAt(0) == '/') {\n            suffix = suffix.substring(1); // skip leading slash\n        }\n        try {\n            return new CompositeName().add(UrlUtil.decode(suffix));\n        } catch (MalformedURLException e) {\n            throw new InvalidNameException(e.getMessage());\n        }\n    }\n    /**\n      * Finds the prefix of a URL.\n      * Default implementation looks for slashes and then extracts\n      * prefixes using String.substring().\n      * Subclass should override if this is not appropriate.\n      * This method is used only by rename().\n      * If rename() is supported for a particular URL scheme,\n      * getRootURLContext(), getURLPrefix(), and getURLSuffix()\n      * must be in sync wrt how URLs are parsed and returned.\n      *<p>\n      * URL                                     Prefix\n      * foo://host:port                         foo://host:port\n      * foo://host:port/rest/of/name            foo://host:port\n      * foo:///rest/of/name                     foo://\n      * foo:/rest/of/name                       foo:\n      * foo:rest/of/name                        foo:\n      */\n    protected String getURLPrefix(String url) throws NamingException {\n        int start = url.indexOf(':');\n        if (start < 0) {\n            throw new OperationNotSupportedException(\"Invalid URL: \" + url);\n        }\n        ++start; // skip ':'\n        if (url.startsWith(\"//\", start)) {\n            start += 2;  // skip double slash\n            // find last slash\n            int posn = url.indexOf('/', start);\n            if (posn >= 0) {\n                start = posn;\n            } else {\n                start = url.length();  // rest of URL\n            }\n        }\n        // else 0 or 1 initial slashes; start is unchanged\n        return url.substring(0, start);\n    }\n    /**\n     * Determines whether two URLs are the same.\n     * Default implementation uses String.equals().\n     * Subclass should override if this is not appropriate.\n     * This method is used by rename().\n     */\n    protected boolean urlEquals(String url1, String url2) {\n        return url1.equals(url2);\n    }\n    /**\n     * Gets the context in which to continue the operation. This method\n     * is called when this context is asked to process a multicomponent\n     * Name in which the first component is a URL.\n     * Treat the first component like a junction: resolve it and then use\n     * NamingManager.getContinuationContext() to get the target context in\n     * which to operate on the remainder of the name (n.getSuffix(1)).\n     */\n<fim_suffix>    protected Context getContinuationContext(Name n) throws NamingException {\n        Object obj = lookup(n.get(0));\n        CannotProceedException cpe = new CannotProceedException();\n        cpe.setResolvedObj(obj);\n        cpe.setEnvironment(myEnv);\n        return NamingManager.getContinuationContext(cpe);\n    }\n    public Object lookup(String name) throws NamingException {\n        ResolveResult res = getRootURLContext(name, myEnv);\n        Context ctx = (Context)res.getResolvedObj();\n        try {\n            return ctx.lookup(res.getRemainingName());\n        } finally {\n            ctx.close();\n        }\n    }<fim_middle>// function below has no smell\n"}