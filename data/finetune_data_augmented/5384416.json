{"text": "<fim_prefix>                    int numHosts = 0;\n                    for (String hostName : hostNames) {\n                        if (StringUtils.isNotBlank(hostName)) {\n                            hostNames[numHosts++] = hostName;\n                        }\n                    }\n                    if (numHosts > numRels) {\n                        results.add(new ValidationResult.Builder()\n                                .subject(\"Number of Relationships and Hostnames\")\n                                .explanation(\"Number of Relationships must be equal to, or greater than, the number of host names\")\n                                .valid(false).build());\n                    } else {\n                        // create new relationships with descriptions of hostname\n                        Set<Relationship> relsWithDesc = new TreeSet<>();\n                        for (int i = 0; i < numHosts; i++) {\n                            relsWithDesc.add(new Relationship.Builder().name(String.valueOf(i + 1))\n                                    .description(hostNames[i]).build());\n                        }\n                        // add add'l rels if configuration requires it...it probably shouldn't\n                        for (int i = numHosts + 1; i <= numRels; i++) {\n                            relsWithDesc.add(createRelationship(i));\n                        }\n                        relationshipsRef.set(Collections.unmodifiableSet(relsWithDesc));\n                    }\n                }\n            }\n        }\n        return results;\n    }\n    @OnScheduled\n    public void createWeightedList(final ProcessContext context) {\n        final Map<Integer, Integer> weightings = new LinkedHashMap<>();\n        String distStrat = context.getProperty(DISTRIBUTION_STRATEGY).getValue();\n        if (distStrat.equals(STRATEGY_LOAD_DISTRIBUTION_SERVICE)) {\n            String hostNamesValue = context.getProperty(HOSTNAMES).getValue();\n            String[] hostNames = hostNamesValue.split(\"(?:,+|;+|\\\\s+)\");\n            Set<String> hostNameSet = new HashSet<>();\n            for (String hostName : hostNames) {\n                if (StringUtils.isNotBlank(hostName)) {\n                    hostNameSet.add(hostName);\n                }\n            }\n            LoadDistributionService svc = context.getProperty(LOAD_DISTRIBUTION_SERVICE_TEMPLATE).asControllerService(LoadDistributionService.class);\n            myListener = new LoadDistributionListener() {\n                @Override\n                public void update(Map<String, Integer> loadInfo) {\n                    for (Relationship rel : relationshipsRef.get()) {\n                        String hostname = rel.getDescription();\n                        Integer weight = 1;\n                        if (loadInfo.containsKey(hostname)) {\n                            weight = loadInfo.get(hostname);\n                        }\n                        weightings.put(Integer.decode(rel.getName()), weight);\n                    }\n                    updateWeightedRelationships(weightings);\n                }\n            };\n            Map<String, Integer> loadInfo = svc.getLoadDistribution(hostNameSet, myListener);\n            for (Relationship rel : relationshipsRef.get()) {\n                String hostname = rel.getDescription();\n                Integer weight = 1;\n                if (loadInfo.containsKey(hostname)) {\n                    weight = loadInfo.get(hostname);\n                }\n                weightings.put(Integer.decode(rel.getName()), weight);\n            }\n        } else {\n            final int numRelationships = context.getProperty(NUM_RELATIONSHIPS).asInteger();\n            for (int i = 1; i <= numRelationships; i++) {\n                weightings.put(i, 1);\n            }\n            for (final PropertyDescriptor propDesc : context.getProperties().keySet()) {\n                if (!this.properties.contains(propDesc)) {\n                    final int relationship = Integer.parseInt(propDesc.getName());\n                    final int weighting = context.getProperty(propDesc).asInteger();\n                    weightings.put(relationship, weighting);\n                }\n            }\n        }\n        updateWeightedRelationships(weightings);\n    }\n    private void updateWeightedRelationships(final Map<Integer, Integer> weightings) {\n        final List<Relationship> relationshipList = new ArrayList<>();\n        for (final Map.Entry<Integer, Integer> entry : weightings.entrySet()) {\n            final String relationshipName = String.valueOf(entry.getKey());\n            final Relationship relationship = new Relationship.Builder().name(relationshipName).build();\n            for (int i = 0; i < entry.getValue(); i++) {\n                relationshipList.add(relationship);\n            }\n        }\n        this.weightedRelationshipListRef.set(Collections.unmodifiableList(relationshipList));\n    }\n    @Override\n    public void onTrigger(final ProcessContext context, final ProcessSession session) {\n        final FlowFile flowFile = session.get();\n        if (flowFile == null) {\n            return;\n        }\n        final DistributionStrategy strategy = strategyRef.get();\n        final Set<Relationship> available = context.getAvailableRelationships();\n        final int numRelationships = context.getProperty(NUM_RELATIONSHIPS).asInteger();\n        final boolean allDestinationsAvailable = (available.size() == numRelationships);\n        if (!allDestinationsAvailable && strategy.requiresAllDestinationsAvailable()) {\n            // can't transfer the FlowFiles. Roll back and yield\n            session.rollback();\n            context.yield();\n            return;\n        }\n        final Relationship relationship = strategy.mapToRelationship(context, flowFile);\n        if (relationship == null) {\n            // can't transfer the FlowFiles. Roll back and yield\n            session.rollback();\n            context.yield();\n            return;\n        }\n        session.transfer(flowFile, relationship);\n        session.getProvenanceReporter().route(flowFile, relationship);\n    }\n    private static class InvalidPropertyNameValidator implements Validator {\n        private final String propertyName;\n        public InvalidPropertyNameValidator(final String propertyName) {\n            this.propertyName = propertyName;\n        }\n        @Override\n        public ValidationResult validate(final String subject, final String input, final ValidationContext validationContext) {\n            return new ValidationResult.Builder().subject(\"Property Name\").input(propertyName)\n                    .explanation(\"Property Name must be a positive integer between 1 and the number of relationships (inclusive)\")\n                    .valid(false).build();\n        }\n    }\n    /**\n     * Implementations must be thread-safe.\n     */\n    private static interface DistributionStrategy {\n        /**\n         * @param context context\n         * @param flowFile flowFile\n         * @return a mapping of FlowFile to Relationship or <code>null</code> if the needed relationships are not available to accept files\n         */\n        Relationship mapToRelationship(ProcessContext context, FlowFile flowFile);\n        boolean requiresAllDestinationsAvailable();\n    }\n    private class LoadDistributionStrategy implements DistributionStrategy {\n        private final AtomicLong counter = new AtomicLong(0L);\n        @Override\n        public Relationship mapToRelationship(final ProcessContext context, final FlowFile flowFile) {\n            final List<Relationship> relationshipList = DistributeLoad.this.weightedRelationshipListRef.get();\n            final int numRelationships = relationshipList.size();\n            // create a HashSet that contains all of the available relationships, as calling #contains on HashSet\n            // is much faster than calling it on a List\n            boolean foundFreeRelationship = false;\n            Relationship relationship = null;\n            int attempts = 0;\n            while (!foundFreeRelationship) {\n                final long counterValue = counter.getAndIncrement();\n                final int idx = (int) (counterValue % numRelationships);\n                relationship = relationshipList.get(idx);\n                foundFreeRelationship = context.getAvailableRelationships().contains(relationship);\n                if (++attempts % numRelationships == 0 && !foundFreeRelationship) {\n                    return null;\n                }\n            }\n            return relationship;\n        }\n        @Override\n        public boolean requiresAllDestinationsAvailable() {\n            return false;\n        }\n    }\n    private class RoundRobinStrategy implements DistributionStrategy {\n        private final AtomicLong counter = new AtomicLong(0L);\n        @Override\n        public Relationship mapToRelationship(final ProcessContext context, final FlowFile flowFile) {\n            final List<Relationship> relationshipList = DistributeLoad.this.weightedRelationshipListRef.get();\n            final long counterValue = counter.getAndIncrement();\n            final int idx = (int) (counterValue % relationshipList.size());\n            final Relationship relationship = relationshipList.get(idx);\n            return relationship;\n        }\n        @Override\n        public boolean requiresAllDestinationsAvailable() {\n            return true;\n        }\n    }\n    private class NextAvailableStrategy implements DistributionStrategy {\n        private final AtomicLong counter = new AtomicLong(0L);\n<fim_suffix>        @Override\n        public Relationship mapToRelationship(final ProcessContext context, final FlowFile flowFile) {\n            final List<Relationship> relationshipList = DistributeLoad.this.weightedRelationshipListRef.get();\n            final int numRelationships = relationshipList.size();\n            // create a HashSet that contains all of the available relationships, as calling #contains on HashSet\n            // is much faster than calling it on a List\n            boolean foundFreeRelationship = false;\n            Relationship relationship = null;\n            int attempts = 0;\n            while (!foundFreeRelationship) {\n                final long counterValue = counter.getAndIncrement();\n                final int idx = (int) (counterValue % numRelationships);\n                relationship = relationshipList.get(idx);\n                foundFreeRelationship = context.getAvailableRelationships().contains(relationship);\n                if (++attempts % numRelationships == 0 && !foundFreeRelationship) {\n                    return null;\n                }\n            }\n            return relationship;\n        }<fim_middle>// function below has no smell\n"}