{"text": "<fim_prefix>         */\n        private Consumer<Operation> operationConsumer;\n        /**\n         * A callback to invoke when a filter suspends the operation.\n         * The callback is expected to perform non-blocking operations.\n         */\n        private Consumer<Operation> suspendConsumer;\n        private OperationProcessingContext(ServiceHost host, OperationProcessingChain opProcessingChain) {\n            this.host = host;\n            this.opProcessingChain = opProcessingChain;\n            this.currentFilterPosition = -1;\n        }\n        public ServiceHost getHost() {\n            return this.host;\n        }\n        public Service getService() {\n            return this.service;\n        }\n        public OperationProcessingChain getOpProcessingChain() {\n            return this.opProcessingChain;\n        }\n        public int getCurrentFilterPosition() {\n            return this.currentFilterPosition;\n        }\n        public void setService(Service service) {\n            this.service = service;\n        }\n        public void setSuspendConsumer(Consumer<Operation> suspendConsumer) {\n            this.suspendConsumer = suspendConsumer;\n        }\n        /**\n         * Delegate to {@link OperationProcessingChain} with current context.\n         *\n         * @param op               the operation that has been suspended and is now being resumed\n         * @param filterReturnCode the filter's indication of whether to continue processing\n         *                         the request or to stop it (with success or with failure)\n         * @param e                a Throwable in case the filter return code is FAILED_STOP_PROCESSING\n         */\n        public void resumeProcessingRequest(Operation op, FilterReturnCode filterReturnCode, Throwable e) {\n            this.opProcessingChain.resumeProcessingRequest(op, this, filterReturnCode, e);\n        }\n    }\n    public interface Filter {\n        FilterReturnCode processRequest(Operation op, OperationProcessingContext context);\n        default void init() {}\n        default void close() {}\n    }\n    public OperationProcessingContext createContext(ServiceHost host) {\n        return new OperationProcessingContext(host, this);\n    }\n    public OperationProcessingChain setLogLevel(Level logLevel) {\n        this.logLevel = logLevel;\n        return this;\n    }\n    public OperationProcessingChain toggleLogging(boolean loggingEnabled) {\n        this.loggingEnabled = loggingEnabled;\n        return this;\n    }\n    public OperationProcessingChain setLogFilter(Predicate<Operation> logFilter) {\n        this.logFilter = logFilter;\n        return this;\n    }\n    private Level logLevel;\n    private boolean loggingEnabled;\n    private Predicate<Operation> logFilter;\n    private List<Filter> filters;\n    private OperationProcessingChain() {\n        this.filters = new ArrayList<>();\n    }\n    public static OperationProcessingChain create(Filter... filters) {\n        OperationProcessingChain opProcessingChain = new OperationProcessingChain();\n        for (Filter filter : filters) {\n            filter.init();\n            opProcessingChain.filters.add(filter);\n        }\n        return opProcessingChain;\n    }\n    public void close() {\n        for (Filter filter : this.filters) {\n            filter.close();\n        }\n        this.filters.clear();\n    }\n    /**\n     * Processes an operation by passing it through the chain of filters.\n     * After the filters in the chain have processed the operation, the provided\n     * consumerOperation's accept() method is invoked if and when the caller\n     * should continue processing the operation.\n     */\n    public void processRequest(Operation op, OperationProcessingContext context,\n            Consumer<Operation> operationConsumer) {\n        // sticking the operation consumer in the context, so that we can find it\n        // in case a filter decides to suspend processing of the operation and later\n        // resume it. This detail is abstracted from the caller of this public method.\n        context.operationConsumer = operationConsumer;\n        FilterReturnCode rc = processRequest(op, context, 0);\n        if (rc == FilterReturnCode.CONTINUE_PROCESSING) {\n            operationConsumer.accept(op);\n        }\n    }\n    /**\n     * A reentrant method to allow a filter to resume processing the request by chain filters.\n     * The filters in the chain after the invoking one are invoked sequentially, as usual,\n     * and if the chain end is reached, i.e. the request has not been dropped by any\n     * filter, the request is passed to the service for continued processing.\n     *\n     * @param op the operation the has been suspended and is now being resumed\n     * @param context the operation's processing context\n     * @param filterReturnCode the filter's indication of whether to continue processing\n     *  the request or to stop it (with success or with failure)\n     * @param e a Throwable in case the filter return code is FAILED_STOP_PROCESSING\n     */\n    public void resumeProcessingRequest(Operation op, OperationProcessingContext context,\n            FilterReturnCode filterReturnCode, Throwable e) {\n        if (shouldLog(op)) {\n            String msg = \"\";\n            switch (filterReturnCode) {\n            case SUCCESS_STOP_PROCESSING:\n                msg = \"Operation completed\";\n                break;\n            case FAILED_STOP_PROCESSING:\n                msg = \"Operation failed\";\n                if (e != null) {\n                    msg += \": \" + e.getMessage();\n                }\n                break;\n            case CONTINUE_PROCESSING:\n                msg = \"Operation processing continued\";\n                break;\n            case RESUME_PROCESSING:\n                msg = \"Operation processing resumed\";\n                break;\n            default:\n                throw new IllegalArgumentException(\"unexpected FilterReturnCode: \" + filterReturnCode);\n            }\n            log(op, context, msg, this.logLevel);\n        }\n        if (filterReturnCode != FilterReturnCode.CONTINUE_PROCESSING &&\n                filterReturnCode != FilterReturnCode.RESUME_PROCESSING) {\n            // filter has instructed us not not continue processing\n            return;\n        }\n        // resume or continue processing\n        int nextFilterStartIndex = filterReturnCode == FilterReturnCode.RESUME_PROCESSING ?\n                context.currentFilterPosition : context.currentFilterPosition + 1;\n        FilterReturnCode rc = FilterReturnCode.CONTINUE_PROCESSING;\n        if (nextFilterStartIndex < this.filters.size()) {\n            rc = processRequest(op, context, nextFilterStartIndex);\n        }\n        if (rc == FilterReturnCode.CONTINUE_PROCESSING) {\n            context.operationConsumer.accept(op);\n        }\n    }\n    public Filter findFilter(Predicate<Filter> tester) {\n        return this.filters.stream().filter(tester).findFirst().orElse(null);\n    }\n    private FilterReturnCode processRequest(Operation op, OperationProcessingContext context, int startIndex) {\n        boolean shouldLog = shouldLog(op);\n        for (int i = startIndex; i < this.filters.size(); i++) {\n            Filter filter = this.filters.get(i);\n            context.currentFilterPosition = i;\n            FilterReturnCode rc = filter.processRequest(op, context);\n            String msg = shouldLog ? String.format(\"returned %s\", rc) : null;\n            switch (rc) {\n            case CONTINUE_PROCESSING:\n                if (shouldLog) {\n                    log(op, context, msg, this.logLevel);\n                }\n                continue;\n            case SUCCESS_STOP_PROCESSING:\n                if (shouldLog) {\n                    msg += \". Operation completed - stopping processing\";\n                    log(op, context, msg, this.logLevel);\n                }\n                return rc;\n            case FAILED_STOP_PROCESSING:\n                if (shouldLog) {\n                    msg += \". Operation failed - stopping processing\";\n                    log(op, context, msg, this.logLevel);\n                }\n                return rc;\n            case SUSPEND_PROCESSING:\n                if (shouldLog) {\n                    msg += \". Operation will be resumed asynchronously - suspend processing\";\n                    log(op, context, msg, this.logLevel);\n                }\n                if (context.suspendConsumer == null) {\n                    throw new IllegalStateException(\n                            String.format(\"Operation %d %s has been suspended with a null suspendConsumer\",\n                            op.getId(), op.getAction()));\n                }\n                Consumer<Operation> suspendConsumer = context.suspendConsumer;\n                context.suspendConsumer = null;\n                suspendConsumer.accept(op);\n                return rc;\n            default:\n                msg += \". Unexpected returned code - failing operation and stopping processing\";\n                log(op, context, msg, Level.SEVERE);\n            }\n        }\n        return FilterReturnCode.CONTINUE_PROCESSING;\n    }\n    private boolean shouldLog(Operation op) {\n        boolean shouldLog = this.loggingEnabled;\n        if (this.logFilter != null) {\n            shouldLog &= this.logFilter.test(op);\n        }\n        return shouldLog;\n    }\n<fim_suffix>    private void log(Operation op, OperationProcessingContext context, String msg, Level logLevel) {\n        String hostId = context.host != null ? context.host.getId() : \"\";\n        String path = op.getUri() != null ? op.getUri().getPath() : \"\";\n        Filter filter = this.filters.get(context.currentFilterPosition);\n        String filterName = filter != null ? filter.getClass().getSimpleName() : \"\";\n        String logMsg = String.format(\"(host: %s, op %d %s %s) filter %s: %s\",\n                hostId, op.getId(), op.getAction(),  path, filterName, msg);\n        Level level = logLevel != null ? logLevel : Level.INFO;\n        Utils.log(getClass(), op.getUri().getPath(), level, logMsg);\n    }<fim_middle>// function below is long method\n"}