{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.lucene.analysis.phonetic;\n\nimport java.io.IOException;\nimport java.util.LinkedList;\n\nimport org.apache.commons.codec.language.DoubleMetaphone;\nimport org.apache.lucene.analysis.TokenFilter;\nimport org.apache.lucene.analysis.TokenStream;\nimport org.apache.lucene.analysis.tokenattributes.CharTermAttribute;\nimport org.apache.lucene.analysis.tokenattributes.PositionIncrementAttribute;\n\n/**\n * Filter for DoubleMetaphone (supporting secondary codes)\n */\npublic final class DoubleMetaphoneFilter extends TokenFilter {\n\n  private static final String TOKEN_TYPE = \"DoubleMetaphone\";\n  \n  private final LinkedList<State> remainingTokens = new LinkedList<>();\n  private final DoubleMetaphone encoder = new DoubleMetaphone();\n  private final boolean inject;\n  private final CharTermAttribute termAtt = addAttribute(CharTermAttribute.class);\n  private final PositionIncrementAttribute posAtt = addAttribute(PositionIncrementAttribute.class);\n\n  /** Creates a DoubleMetaphoneFilter with the specified maximum code length, \n   *  and either adding encoded forms as synonyms (<code>inject=true</code>) or\n   *  replacing them.\n   */\n  public DoubleMetaphoneFilter(TokenStream input, int maxCodeLength, boolean inject) {\n    super(input);\n    this.encoder.setMaxCodeLen(maxCodeLength);\n    this.inject = inject;\n  }\n\n<fim_suffix>  @Override\n  public boolean incrementToken() throws IOException {\n    for(;;) {\n\n      if (!remainingTokens.isEmpty()) {\n        // clearAttributes();  // not currently necessary\n        restoreState(remainingTokens.removeFirst());\n        return true;\n      }\n\n      if (!input.incrementToken()) return false;\n\n      int len = termAtt.length();\n      if (len==0) return true; // pass through zero length terms\n      \n      int firstAlternativeIncrement = inject ? 0 : posAtt.getPositionIncrement();\n\n      String v = termAtt.toString();\n      String primaryPhoneticValue = encoder.doubleMetaphone(v);\n      String alternatePhoneticValue = encoder.doubleMetaphone(v, true);\n\n      // a flag to lazily save state if needed... this avoids a save/restore when only\n      // one token will be generated.\n      boolean saveState=inject;\n\n      if (primaryPhoneticValue!=null && primaryPhoneticValue.length() > 0 && !primaryPhoneticValue.equals(v)) {\n        if (saveState) {\n          remainingTokens.addLast(captureState());\n        }\n        posAtt.setPositionIncrement( firstAlternativeIncrement );\n        firstAlternativeIncrement = 0;\n        termAtt.setEmpty().append(primaryPhoneticValue);\n        saveState = true;\n      }\n\n      if (alternatePhoneticValue!=null && alternatePhoneticValue.length() > 0\n              && !alternatePhoneticValue.equals(primaryPhoneticValue)\n              && !primaryPhoneticValue.equals(v)) {\n        if (saveState) {\n          remainingTokens.addLast(captureState());\n          saveState = false;\n        }\n        posAtt.setPositionIncrement( firstAlternativeIncrement );\n        termAtt.setEmpty().append(alternatePhoneticValue);\n        saveState = true;\n      }\n\n      // Just one token to return, so no need to capture/restore\n      // any state, simply return it.\n      if (remainingTokens.isEmpty()) {\n        return true;\n      }\n\n      if (saveState) {\n        remainingTokens.addLast(captureState());\n      }\n    }\n  }\n\n  @Override\n  public void reset() throws IOException {\n    input.reset();\n    remainingTokens.clear();\n  }\n}<fim_middle>// function below is long method\n"}