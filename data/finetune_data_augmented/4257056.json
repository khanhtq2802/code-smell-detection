{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.net.finger;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.BufferedOutputStream;\nimport java.io.DataOutputStream;\n\nimport org.apache.commons.net.SocketClient;\nimport org.apache.commons.net.util.Charsets;\n\n/***\n * The FingerClient class implements the client side of the Internet Finger\n * Protocol defined in RFC 1288.  To finger a host you create a\n * FingerClient instance, connect to the host, query the host, and finally\n * disconnect from the host.  If the finger service you want to query is on\n * a non-standard port, connect to the host at that port.\n * Here's a sample use:\n * <pre>\n *    FingerClient finger;\n *\n *    finger = new FingerClient();\n *\n *    try {\n *      finger.connect(\"foo.bar.com\");\n *      System.out.println(finger.query(\"foobar\", false));\n *      finger.disconnect();\n *    } catch(IOException e) {\n *      System.err.println(\"Error I/O exception: \" + e.getMessage());\n *      return;\n *    }\n * </pre>\n *\n ***/\n\n<fim_suffix>public class FingerClient extends SocketClient\n{\n    /***\n     * The default FINGER port.  Set to 79 according to RFC 1288.\n     ***/\n    public static final int DEFAULT_PORT = 79;\n\n    private static final String __LONG_FLAG = \"/W \";\n\n    private transient char[] __buffer = new char[1024];\n\n    /***\n     * The default FingerClient constructor.  Initializes the\n     * default port to <code> DEFAULT_PORT </code>.\n     ***/\n    public FingerClient()\n    {\n        setDefaultPort(DEFAULT_PORT);\n    }\n\n\n    /***\n     * Fingers a user at the connected host and returns the output\n     * as a String.  You must first connect to a finger server before\n     * calling this method, and you should disconnect afterward.\n     *\n     * @param longOutput Set to true if long output is requested, false if not.\n     * @param username  The name of the user to finger.\n     * @return The result of the finger query.\n     * @throws IOException If an I/O error occurs while reading the socket.\n     ***/\n    public String query(boolean longOutput, String username) throws IOException\n    {\n        int read;\n        StringBuilder result = new StringBuilder(__buffer.length);\n        BufferedReader input;\n\n        input =\n            new BufferedReader(new InputStreamReader(getInputStream(longOutput,\n                               username), getCharset()));\n\n        try {\n            while (true)\n            {\n                read = input.read(__buffer, 0, __buffer.length);\n                if (read <= 0) {\n                    break;\n                }\n                result.append(__buffer, 0, read);\n            }\n        } finally {\n            input.close();\n        }\n\n        return result.toString();\n    }\n\n\n    /***\n     * Fingers the connected host and returns the output\n     * as a String.  You must first connect to a finger server before\n     * calling this method, and you should disconnect afterward.\n     * This is equivalent to calling <code> query(longOutput, \"\") </code>.\n     *\n     * @param longOutput Set to true if long output is requested, false if not.\n     * @return The result of the finger query.\n     * @throws IOException If an I/O error occurs while reading the socket.\n     ***/\n    public String query(boolean longOutput) throws IOException\n    {\n        return query(longOutput, \"\");\n    }\n\n\n    /***\n     * Fingers a user and returns the input stream from the network connection\n     * of the finger query.  You must first connect to a finger server before\n     * calling this method, and you should disconnect after finishing reading\n     * the stream.\n     *\n     * @param longOutput Set to true if long output is requested, false if not.\n     * @param username  The name of the user to finger.\n     * @return The InputStream of the network connection of the finger query.\n     *         Can be read to obtain finger results.\n     * @throws IOException If an I/O error during the operation.\n     ***/\n    public InputStream getInputStream(boolean longOutput, String username)\n    throws IOException\n    {\n        return getInputStream(longOutput, username, null);\n    }\n\n    /***\n     * Fingers a user and returns the input stream from the network connection\n     * of the finger query.  You must first connect to a finger server before\n     * calling this method, and you should disconnect after finishing reading\n     * the stream.\n     *\n     * @param longOutput Set to true if long output is requested, false if not.\n     * @param username  The name of the user to finger.\n     * @param encoding the character encoding that should be used for the query,\n     *        null for the platform's default encoding\n     * @return The InputStream of the network connection of the finger query.\n     *         Can be read to obtain finger results.\n     * @throws IOException If an I/O error during the operation.\n     ***/\n    public InputStream getInputStream(boolean longOutput, String username, String encoding)\n    throws IOException\n    {\n        DataOutputStream output;\n        StringBuilder buffer = new StringBuilder(64);\n        if (longOutput) {\n            buffer.append(__LONG_FLAG);\n        }\n        buffer.append(username);\n        buffer.append(SocketClient.NETASCII_EOL);\n\n        // Note: Charsets.toCharset() returns the platform default for null input\n        byte[] encodedQuery = buffer.toString().getBytes(Charsets.toCharset(encoding).name()); // Java 1.6 can use charset directly\n\n        output = new DataOutputStream(new BufferedOutputStream(_output_, 1024));\n        output.write(encodedQuery, 0, encodedQuery.length);\n        output.flush();\n\n        return _input_;\n    }\n\n\n    /***\n     * Fingers the connected host and returns the input stream from\n     * the network connection of the finger query.  This is equivalent to\n     * calling getInputStream(longOutput, \"\").  You must first connect to a\n     * finger server before calling this method, and you should disconnect\n     * after finishing reading the stream.\n     *\n     * @param longOutput Set to true if long output is requested, false if not.\n     * @return The InputStream of the network connection of the finger query.\n     *         Can be read to obtain finger results.\n     * @throws IOException If an I/O error during the operation.\n     ***/\n    public InputStream getInputStream(boolean longOutput) throws IOException\n    {\n        return getInputStream(longOutput, \"\");\n    }\n\n}<fim_middle>// class below has no smell\n"}