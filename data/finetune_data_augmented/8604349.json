{"text": "<fim_prefix>                long initCntr = part.initialUpdateCounter();\n                if (skipZeros && initCntr == 0L && updCntr == 0L)\n                    continue;\n                res.add(part.id(), initCntr, updCntr);\n            }\n            res.trim();\n            return res;\n        }\n        finally {\n            lock.readLock().unlock();\n        }\n    }\n    /** {@inheritDoc} */\n    @Override public Map<Integer, Long> partitionSizes() {\n        lock.readLock().lock();\n        try {\n            Map<Integer, Long> partitionSizes = new HashMap<>();\n            for (int p = 0; p < locParts.length(); p++) {\n                GridDhtLocalPartition part = locParts.get(p);\n                if (part == null || part.fullSize() == 0)\n                    continue;\n                partitionSizes.put(part.id(), part.fullSize());\n            }\n            return partitionSizes;\n        }\n        finally {\n            lock.readLock().unlock();\n        }\n    }\n    /** {@inheritDoc} */\n    @Override public Map<Integer, Long> globalPartSizes() {\n        lock.readLock().lock();\n        try {\n            if (globalPartSizes == null)\n                return Collections.emptyMap();\n            return Collections.unmodifiableMap(globalPartSizes);\n        }\n        finally {\n            lock.readLock().unlock();\n        }\n    }\n    /** {@inheritDoc} */\n    @Override public void globalPartSizes(@Nullable Map<Integer, Long> partSizes) {\n        lock.writeLock().lock();\n        try {\n            this.globalPartSizes = partSizes;\n        }\n        finally {\n            lock.writeLock().unlock();\n        }\n    }\n    /** {@inheritDoc} */\n    @Override public boolean rebalanceFinished(AffinityTopologyVersion topVer) {\n        AffinityTopologyVersion curTopVer = this.readyTopVer;\n        return curTopVer.equals(topVer) && curTopVer.equals(rebalancedTopVer);\n    }\n    /** {@inheritDoc} */\n    @Override public boolean hasMovingPartitions() {\n        lock.readLock().lock();\n        try {\n            if (node2part == null)\n                return false;\n            assert node2part.valid() : \"Invalid node2part [node2part: \" + node2part +\n                \", grp=\" + grp.cacheOrGroupName() +\n                \", stopping=\" + stopping +\n                \", locNodeId=\" + ctx.localNodeId() +\n                \", locName=\" + ctx.igniteInstanceName() + ']';\n            for (GridDhtPartitionMap map : node2part.values()) {\n                if (map.hasMovingPartitions())\n                    return true;\n            }\n            return false;\n        }\n        finally {\n            lock.readLock().unlock();\n        }\n    }\n    /**\n     * @param cacheId Cache ID.\n     */\n    public void onCacheStopped(int cacheId) {\n        if (!grp.sharedGroup())\n            return;\n        for (int i = 0; i < locParts.length(); i++) {\n            GridDhtLocalPartition part = locParts.get(i);\n            if (part != null)\n                part.onCacheStopped(cacheId);\n        }\n    }\n    /** {@inheritDoc} */\n    @Override public void printMemoryStats(int threshold) {\n        X.println(\">>>  Cache partition topology stats [igniteInstanceName=\" + ctx.igniteInstanceName() +\n            \", grp=\" + grp.cacheOrGroupName() + ']');\n        lock.readLock().lock();\n        try {\n            for (int i = 0; i < locParts.length(); i++) {\n                GridDhtLocalPartition part = locParts.get(i);\n                if (part == null)\n                    continue;\n                long size = part.dataStore().fullSize();\n                if (size >= threshold)\n                    X.println(\">>>   Local partition [part=\" + part.id() + \", size=\" + size + ']');\n            }\n        }\n        finally {\n            lock.readLock().unlock();\n        }\n    }\n    /**\n     * @param part Partition.\n     * @param aff Affinity assignments.\n     * @return {@code True} if given partition belongs to local node.\n     */\n    private boolean localNode(int part, List<List<ClusterNode>> aff) {\n        return aff.get(part).contains(ctx.localNode());\n    }\n    /**\n     * @param affVer Affinity version.\n     * @param aff Affinity assignments.\n     */\n    private void updateRebalanceVersion(AffinityTopologyVersion affVer, List<List<ClusterNode>> aff) {\n        if (!grp.isReplicated() && !affVer.equals(diffFromAffinityVer))\n            return;\n        if (!rebalancedTopVer.equals(readyTopVer)) {\n            if (node2part == null || !node2part.valid())\n                return;\n            for (int i = 0; i < grp.affinity().partitions(); i++) {\n                List<ClusterNode> affNodes = aff.get(i);\n                // Topology doesn't contain server nodes (just clients).\n                if (affNodes.isEmpty())\n                    continue;\n                Set<ClusterNode> owners = U.newHashSet(affNodes.size());\n                for (ClusterNode node : affNodes) {\n                    if (hasState(i, node.id(), OWNING))\n                        owners.add(node);\n                }\n                if (!grp.isReplicated()) {\n                    Set<UUID> diff = diffFromAffinity.get(i);\n                    if (diff != null) {\n                        for (UUID nodeId : diff) {\n                            if (hasState(i, nodeId, OWNING)) {\n                                ClusterNode node = ctx.discovery().node(nodeId);\n                                if (node != null)\n                                    owners.add(node);\n                            }\n                        }\n                    }\n                }\n                if (affNodes.size() != owners.size() || !owners.containsAll(affNodes))\n                    return;\n            }\n            rebalancedTopVer = readyTopVer;\n            if (log.isDebugEnabled())\n                log.debug(\"Updated rebalanced version [grp=\" + grp.cacheOrGroupName() + \", ver=\" + rebalancedTopVer + ']');\n        }\n    }\n    /**\n     * Checks that state of partition {@code p} for node {@code nodeId} in local {@code node2part} map\n     * matches to one of the specified states {@code match} or {@ode matches}.\n     *\n     * @param p Partition id.\n     * @param nodeId Node ID.\n     * @param match State to match.\n     * @param matches Additional states.\n     * @return {@code True} if partition matches to one of the specified states.\n     */\n    private boolean hasState(final int p, @Nullable UUID nodeId, final GridDhtPartitionState match,\n        final GridDhtPartitionState... matches) {\n        if (nodeId == null)\n            return false;\n        GridDhtPartitionMap parts = node2part.get(nodeId);\n        // Set can be null if node has been removed.\n        if (parts != null) {\n            GridDhtPartitionState state = parts.get(p);\n            if (state == match)\n                return true;\n            if (matches != null && matches.length > 0) {\n                for (GridDhtPartitionState s : matches) {\n                    if (state == s)\n                        return true;\n                }\n            }\n        }\n        return false;\n    }\n    /**\n     * Checks consistency after all operations.\n     */\n    private void consistencyCheck() {\n        // no-op\n    }\n    /**\n     * Collects states of local partitions.\n     *\n     * @return String representation of all local partition states.\n     */\n    private String dumpPartitionStates() {\n        SB sb = new SB();\n        for (int p = 0; p < locParts.length(); p++) {\n            GridDhtLocalPartition part = locParts.get(p);\n            if (part == null)\n                continue;\n            sb.a(\"Part [\");\n            sb.a(\"id=\" + part.id() + \", \");\n            sb.a(\"state=\" + part.state() + \", \");\n            sb.a(\"initCounter=\" + part.initialUpdateCounter() + \", \");\n            sb.a(\"updCounter=\" + part.updateCounter() + \", \");\n            sb.a(\"size=\" + part.fullSize() + \"] \");\n        }\n        return sb.toString();\n    }\n    /**\n     * Iterator over current local partitions.\n     */\n    private class CurrentPartitionsIterator implements Iterator<GridDhtLocalPartition> {\n        /** Next index. */\n        private int nextIdx;\n        /** Next partition. */\n        private GridDhtLocalPartition nextPart;\n        /**\n         * Constructor\n         */\n        private CurrentPartitionsIterator() {\n            advance();\n        }\n        /**\n         * Try to advance to next partition.\n         */\n<fim_suffix>        private void advance() {\n            while (nextIdx < locParts.length()) {\n                GridDhtLocalPartition part = locParts.get(nextIdx);\n                if (part != null && part.state().active()) {\n                    nextPart = part;\n                    return;\n                }\n                nextIdx++;\n            }\n        }<fim_middle>// function below has no smell\n"}