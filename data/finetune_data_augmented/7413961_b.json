{"text": "<fim_prefix>\n<fim_suffix>final class PolyglotExceptionImpl extends AbstractExceptionImpl implements com.oracle.truffle.polyglot.PolyglotImpl.VMObject {\n    private static final String CAUSE_CAPTION = \"Caused by host exception: \";\n    private static final boolean TRACE_STACK_TRACE_WALKING = false;\n    private PolyglotException api;\n    final PolyglotContextImpl context;\n    private final PolyglotEngineImpl engine;\n    final Throwable exception;\n    private final List<TruffleStackTraceElement> guestFrames;\n    private StackTraceElement[] javaStackTrace;\n    private List<StackFrame> materializedFrames;\n    private final SourceSection sourceLocation;\n    private final boolean internal;\n    private final boolean cancelled;\n    private final boolean exit;\n    private final boolean incompleteSource;\n    private final boolean syntaxError;\n    private final int exitStatus;\n    private final Value guestObject;\n    private final String message;\n    private Object fileSystemContext;\n    // Exception coming from a language\n    PolyglotExceptionImpl(PolyglotLanguageContext languageContext, Throwable original) {\n        this(languageContext.getImpl(), languageContext.getEngine(), languageContext, original);\n    }\n    // Exception coming from an instrument\n    PolyglotExceptionImpl(PolyglotEngineImpl engine, Throwable original) {\n        this(engine.impl, engine, null, original);\n    }\n    private PolyglotExceptionImpl(AbstractPolyglotImpl impl, PolyglotEngineImpl engine, PolyglotLanguageContext languageContext, Throwable original) {\n        super(impl);\n        Objects.requireNonNull(engine);\n        this.engine = engine;\n        this.context = (languageContext != null) ? languageContext.context : null;\n        this.exception = original;\n        this.guestFrames = TruffleStackTrace.getStackTrace(original);\n        if (exception instanceof TruffleException) {\n            TruffleException truffleException = (TruffleException) exception;\n            this.internal = truffleException.isInternalError();\n            this.cancelled = truffleException.isCancelled();\n            this.syntaxError = truffleException.isSyntaxError();\n            this.incompleteSource = truffleException.isIncompleteSource();\n            this.exit = truffleException.isExit();\n            this.exitStatus = this.exit ? truffleException.getExitStatus() : 0;\n            com.oracle.truffle.api.source.SourceSection section = truffleException.getSourceLocation();\n            if (section != null) {\n                Objects.requireNonNull(languageContext, \"Source location can not be accepted without language context.\");\n                com.oracle.truffle.api.source.Source truffleSource = section.getSource();\n                String language = truffleSource.getLanguage();\n                if (language == null) {\n                    PolyglotLanguage foundLanguage = languageContext.getEngine().findLanguage(language, truffleSource.getMimeType(), false);\n                    if (foundLanguage != null) {\n                        language = foundLanguage.getId();\n                    }\n                }\n                Source source = getAPIAccess().newSource(language, truffleSource);\n                this.sourceLocation = getAPIAccess().newSourceSection(source, section);\n            } else {\n                this.sourceLocation = null;\n            }\n            Object exceptionObject;\n            if (languageContext != null && !(exception instanceof HostException) && (exceptionObject = ((TruffleException) exception).getExceptionObject()) != null) {\n                /*\n                 * Allow proxies in guest language objects. This is for legacy support. Ideally we\n                 * should get rid of this if it is no longer relied upon.\n                 */\n                Object receiver = exceptionObject;\n                if (receiver instanceof Proxy) {\n                    receiver = languageContext.toGuestValue(receiver);\n                }\n                this.guestObject = languageContext.asValue(receiver);\n            } else {\n                this.guestObject = null;\n            }\n        } else {\n            this.cancelled = false;\n            this.internal = true;\n            this.syntaxError = false;\n            this.incompleteSource = false;\n            this.exit = false;\n            this.exitStatus = 0;\n            this.sourceLocation = null;\n            this.guestObject = null;\n        }\n        if (isHostException()) {\n            this.message = asHostException().getMessage();\n        } else {\n            if (internal) {\n                this.message = exception.toString();\n            } else {\n                this.message = exception.getMessage();\n            }\n        }\n        // late materialization of host frames. only needed if polyglot exceptions cross the\n        // host boundary.\n        VMAccessor.LANGUAGE.materializeHostFrames(original);\n    }\n    @Override\n    public boolean equals(Object obj) {\n        if (obj instanceof PolyglotExceptionImpl) {\n            return exception == ((PolyglotExceptionImpl) obj).exception;\n        }\n        return false;\n    }\n    @Override\n    public int hashCode() {\n        return exception.hashCode();\n    }\n    @Override\n    public org.graalvm.polyglot.SourceSection getSourceLocation() {\n        return sourceLocation;\n    }\n    @Override\n    public void onCreate(PolyglotException instance) {\n        this.api = instance;\n    }\n    @Override\n    public boolean isHostException() {\n        return exception instanceof HostException;\n    }\n    @Override\n    public Throwable asHostException() {\n        if (!(exception instanceof HostException)) {\n            throw new PolyglotUnsupportedException(\n                            String.format(\"Unsupported operation %s.%s. You can ensure that the operation is supported using %s.%s.\",\n                                            PolyglotException.class.getSimpleName(), \"asHostException()\",\n                                            PolyglotException.class.getSimpleName(), \"isHostException()\"));\n        }\n        return ((HostException) exception).getOriginal();\n    }\n    @Override\n    public void printStackTrace(PrintWriter s) {\n        printStackTrace(new WrappedPrintWriter(s));\n    }\n    @Override\n    public void printStackTrace(PrintStream s) {\n        printStackTrace(new WrappedPrintStream(s));\n    }\n    private void printStackTrace(PrintStreamOrWriter s) {\n        // Guard against malicious overrides of Throwable.equals by\n        // using a Set with identity equality semantics.\n        synchronized (s.lock()) {\n            // Print our stack trace\n            if (isInternalError() || getMessage() == null || getMessage().isEmpty()) {\n                s.println(api);\n            } else {\n                s.println(getMessage());\n            }\n            materialize();\n            int languageIdLength = 0; // java\n            for (StackFrame traceElement : getPolyglotStackTrace()) {\n                if (!traceElement.isHostFrame()) {\n                    languageIdLength = Math.max(languageIdLength, getAPIAccess().getImpl(traceElement).getLanguage().getId().length());\n                }\n            }\n            for (StackFrame traceElement : getPolyglotStackTrace()) {\n                s.println(\"\\tat \" + getAPIAccess().getImpl(traceElement).toStringImpl(languageIdLength));\n            }\n            // Print cause, if any\n            if (isHostException()) {\n                s.println(CAUSE_CAPTION + asHostException());\n            }\n            if (isInternalError()) {\n                s.println(\"Original Internal Error: \");\n                s.printStackTrace(exception);\n            }\n        }\n    }\n    @Override\n    public String getMessage() {\n        return message;\n    }\n    public StackTraceElement[] getJavaStackTrace() {\n        if (javaStackTrace == null) {\n            materialize();\n            javaStackTrace = new StackTraceElement[materializedFrames.size()];\n            for (int i = 0; i < javaStackTrace.length; i++) {\n                javaStackTrace[i] = materializedFrames.get(i).toHostFrame();\n            }\n        }\n        return javaStackTrace;\n    }\n    private void materialize() {\n        if (this.materializedFrames == null) {\n            List<StackFrame> frames = new ArrayList<>();\n            for (StackFrame frame : getPolyglotStackTrace()) {\n                frames.add(frame);\n            }\n            this.materializedFrames = Collections.unmodifiableList(frames);\n        }\n    }\n    @Override\n    public StackTraceElement[] getStackTrace() {\n        return getJavaStackTrace().clone();\n    }\n    @Override\n    public PolyglotEngineImpl getEngine() {\n        return engine;\n    }\n    @Override\n    public boolean isInternalError() {\n        return internal;\n    }\n    @Override\n    public Iterable<StackFrame> getPolyglotStackTrace() {\n        if (materializedFrames != null) {\n            return materializedFrames;\n        } else {\n            return new Iterable<StackFrame>() {\n                public Iterator<StackFrame> iterator() {\n                    return new StackFrameIterator(PolyglotExceptionImpl.this);\n                }\n            };\n        }\n    }\n    @Override\n    public boolean isCancelled() {\n        return cancelled;\n    }\n    @Override\n    public boolean isExit() {\n        return exit;\n    }\n    @Override\n    public boolean isIncompleteSource() {\n        return incompleteSource;\n    }\n    @Override\n    public int getExitStatus() {\n        return exitStatus;\n    }\n    @Override\n    public boolean isSyntaxError() {\n        return syntaxError;\n    }\n    @Override\n    public Value getGuestObject() {\n        return guestObject;\n    }\n    Object getFileSystemContext() {<fim_middle>// class below is data class and blob\n"}