{"text": "<fim_prefix>      return toOption().get();\n    }\n    @Override\n\tpublic <X extends Throwable> A getOrThrow(Supplier<X> ifUndefined) throws X {\n      return toOption().get();\n    }\n    @Override\n\tpublic final A getOrElse(final Supplier<? extends A> a) {\n      return isDefined() ? get() : a.get();\n    }\n    @Override\n\tpublic final <X extends A> A getOrElse(final X x) {\n      return isDefined() ? get() : x;\n    }\n    @Override\n\tpublic final void foreach(final Effect<? super A> f) {\n      if (isDefined()) {\n        f.apply(get());\n      }\n    }\n  }\n  /**\n   * A left projection of an either value.\n   */\n  @SuppressWarnings(\"unused\")\n  public final class LeftProjection extends AbstractProjection<L, R> implements Projection<L, R, L, R> {\n    private LeftProjection() {}\n    @Override\n\tpublic L get() {\n      return getLeft();\n    }\n    @Override\n\tpublic boolean isDefined() {\n      return isLeft();\n    }\n    @Override\n\tpublic L on(final Function<? super R, ? extends L> f) {\n      return isLeft() ? get() : f.apply(right().get());\n    }\n    //\n    // definitions that can't be shared without higher-kinded types\n    //\n    /**\n     * Map the given function across this projection's value if it has one.\n     * \n     * @param <X> the LHS type\n     * @param f The function to map across this projection.\n     * @return A new either value after mapping.\n     */\n    public <X> Either<X, R> map(final Function<? super L, X> f) {\n      return isLeft() ? new Left<X, R>(f.apply(get())) : this.<X> toRight();\n    }\n    /**\n     * Binds the given function across this projection's value if it has one.\n     * \n     * @param <X> the LHS type\n     * @param f The function to bind across this projection.\n     * @return A new either value after binding.\n     */\n    public <X> Either<X, R> flatMap(final Function<? super L, Either<X, R>> f) {\n      return isLeft() ? f.apply(get()) : this.<X> toRight();\n    }\n    <X> Right<X, R> toRight() {\n      return new Right<X, R>(getRight());\n    }\n    /**\n     * Anonymous bind through this projection.\n     * \n     * @param <X> the LHS type\n     * @param e The value to bind with.\n     * @return An either after binding through this projection.\n     */\n    public <X> Either<X, R> sequence(final Either<X, R> e) {\n      return flatMap(Functions.<Either<X, R>> constant(e));\n    }\n    /**\n     * Returns <code>None</code> if this projection has no value or if the given\n     * predicate <code>p</code> does not hold for the value, otherwise, returns\n     * a right in <code>Some</code>.\n     * \n     * @param <X> the RHS type\n     * @param f The predicate function to test on this projection's value.\n     * @return <code>None</code> if this projection has no value or if the given\n     * predicate <code>p</code> does not hold for the value, otherwise, returns\n     * a right in <code>Some</code>.\n     */\n    public <X> Optional<Either<L, X>> filter(final Predicate<? super L> f) {\n      if (isLeft() && f.apply(get())) {\n        final Either<L, X> result = new Left<L, X>(get());\n        return Optional.of(result);\n      }\n      return Optional.absent();\n    }\n    /**\n     * Function application on this projection's value.\n     * \n     * @param <X> the LHS type\n     * @param either The either of the function to apply on this projection's\n     * value.\n     * @return The result of function application within either.\n     */\n    public <X> Either<X, R> apply(final Either<Function<L, X>, R> either) {\n      return either.left().flatMap(new Function<Function<L, X>, Either<X, R>>() {\n        @Override\n\t\tpublic Either<X, R> apply(final Function<L, X> f) {\n          return map(f);\n        }\n      });\n    }\n    /**\n     * Coerces our right type as X. Dangerous, isLeft() must be true\n     * \n     * @param <X> the type to coerce to.\n     * @return an either with the coerced right type.\n     */\n    <X> Either<L, X> as() {\n      return left(get());\n    }\n  }\n  /**\n   * A right projection of an either value.\n   */\n<fim_suffix>  @SuppressWarnings(\"unused\")\n  public final class RightProjection extends AbstractProjection<R, L> implements Projection<R, L, L, R> {\n    private RightProjection() {}\n    @Override\n\tpublic R get() {\n      return getRight();\n    }\n    @Override\n\tpublic boolean isDefined() {\n      return isRight();\n    }\n    @Override\n\tpublic R on(final Function<? super L, ? extends R> f) {\n      return isRight() ? get() : f.apply(left().get());\n    }\n    //\n    // definitions that can't be shared without higher-kinded types\n    //\n    /**\n     * Map the given function across this projection's value if it has one.\n     * \n     * @param <X> the RHS type\n     * @param f The function to map across this projection.\n     * @return A new either value after mapping.\n     */\n    public <X> Either<L, X> map(final Function<? super R, X> f) {\n      return isRight() ? new Right<L, X>(f.apply(get())) : this.<X> toLeft();\n    }\n    /**\n     * Binds the given function across this projection's value if it has one.\n     * \n     * @param <X> the RHS type\n     * @param f The function to bind across this projection.\n     * @return A new either value after binding.\n     */\n    public <X> Either<L, X> flatMap(final Function<? super R, Either<L, X>> f) {\n      return isRight() ? f.apply(get()) : this.<X> toLeft();\n    }\n    <X> Left<L, X> toLeft() {\n      return new Left<L, X>(left().get());\n    }\n    /**\n     * Anonymous bind through this projection.\n     * \n     * @param <X> the RHS type\n     * @param e The value to bind with.\n     * @return An either after binding through this projection.\n     */\n    public <X> Either<L, X> sequence(final Either<L, X> e) {\n      return flatMap(Functions.<Either<L, X>> constant(e));\n    }\n    /**\n     * Returns <code>None</code> if this projection has no value or if the given\n     * predicate <code>p</code> does not hold for the value, otherwise, returns\n     * a left in <code>Some</code>.\n     * \n     * @param <X> the LHS type\n     * @param f The predicate function to test on this projection's value.\n     * @return <code>None</code> if this projection has no value or if the given\n     * predicate <code>p</code> does not hold for the value, otherwise, returns\n     * a left in <code>Some</code>.\n     */\n    public <X> Optional<Either<X, R>> filter(final Predicate<? super R> f) {\n      if (isRight() && f.apply(get())) {\n        final Either<X, R> result = new Right<X, R>(get());\n        return Optional.of(result);\n      }\n      return Optional.absent();\n    }\n    /**\n     * Function application on this projection's value.\n     * \n     * @param <X> the RHS type\n     * @param either The either of the function to apply on this projection's\n     * value.\n     * @return The result of function application within either.\n     */\n    public <X> Either<L, X> apply(final Either<L, Function<R, X>> either) {\n      return either.right().flatMap(new Function<Function<R, X>, Either<L, X>>() {\n        @Override\n\t\tpublic Either<L, X> apply(final Function<R, X> f) {\n          return map(f);\n        }\n      });\n    }\n    /**\n     * Coerces our left type as X. Dangerous, isRight() must be true\n     * \n     * @param <X> the type to coerce to.\n     * @return an either with the coerced left type.\n     */\n    <X> Either<X, R> as() {\n      return right(get());\n    }\n  }<fim_middle>// class below has no smell\n"}