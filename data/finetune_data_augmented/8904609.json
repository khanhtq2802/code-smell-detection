{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.hadoop.hive.serde2.lazybinary;\nimport java.util.Arrays;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.apache.hadoop.hive.serde2.lazy.ByteArrayRef;\nimport org.apache.hadoop.hive.serde2.lazybinary.LazyBinaryUtils.RecordInfo;\nimport org.apache.hadoop.hive.serde2.lazybinary.LazyBinaryUtils.VInt;\nimport org.apache.hadoop.hive.serde2.lazybinary.objectinspector.LazyBinaryMapObjectInspector;\nimport org.apache.hadoop.hive.serde2.objectinspector.MapObjectInspector;\nimport org.apache.hadoop.hive.serde2.objectinspector.PrimitiveObjectInspector;\n/**\n * LazyBinaryMap is serialized as follows: start A b c b c b c end bytes[] -&gt;\n * |--------|---|---|---|---| ... |---|---|\n * \n * Section A is the null-bytes. Suppose the map has N key-value pairs, then\n * there are (N*2+7)/8 bytes used as null-bytes. Each bit corresponds to a key\n * or a value and it indicates whether that key or value is null (0) or not null\n * (1).\n * \n * After A, all the bytes are actual serialized data of the map, which are\n * key-value pairs. b represent the keys and c represent the values. Each of\n * them is again a LazyBinaryObject.\n * \n */\npublic class LazyBinaryMap extends\n    LazyBinaryNonPrimitive<LazyBinaryMapObjectInspector> {\n  private static final Logger LOG = LoggerFactory.getLogger(LazyBinaryMap.class.getName());\n  /**\n   * Whether the data is already parsed or not.\n   */\n  boolean parsed;\n  /**\n   * The size of the map. Only valid when the data is parsed. -1 when the map is\n   * NULL.\n   */\n  int mapSize = 0;\n  /**\n   * The beginning position and length of key[i] and value[i]. Only valid when\n   * the data is parsed.\n   */\n  int[] keyStart;\n  int[] keyLength;\n  int[] valueStart;\n  int[] valueLength;\n  /**\n   * Whether valueObjects[i]/keyObjects[i] is initialized or not.\n   */\n  boolean[] keyInited;\n  boolean[] valueInited;\n  /**\n   * Whether valueObjects[i]/keyObjects[i] is null or not This could not be\n   * inferred from the length of the object. In particular, a 0-length string is\n   * not null.\n   */\n  boolean[] keyIsNull;\n  boolean[] valueIsNull;\n  /**\n   * The keys are stored in an array of LazyPrimitives.\n   */\n  LazyBinaryPrimitive<?, ?>[] keyObjects;\n  /**\n   * The values are stored in an array of LazyObjects. value[index] will start\n   * from KeyEnd[index] + 1, and ends before KeyStart[index+1] - 1.\n   */\n  LazyBinaryObject[] valueObjects;\n  protected LazyBinaryMap(LazyBinaryMapObjectInspector oi) {\n    super(oi);\n  }\n  /**\n   * Set the row data for this LazyBinaryMap.\n   * \n   * @see LazyBinaryObject#init(ByteArrayRef, int, int)\n   */\n  @Override\n  public void init(ByteArrayRef bytes, int start, int length) {\n    super.init(bytes, start, length);\n    parsed = false;\n  }\n  /**\n   * Adjust the size of arrays: keyStart, keyLength valueStart, valueLength\n   * keyInited, keyIsNull valueInited, valueIsNull.\n   */\n<fim_suffix>  protected void adjustArraySize(int newSize) {\n    if (keyStart == null || keyStart.length < newSize) {\n      keyStart = new int[newSize];\n      keyLength = new int[newSize];\n      valueStart = new int[newSize];\n      valueLength = new int[newSize];\n      keyInited = new boolean[newSize];\n      keyIsNull = new boolean[newSize];\n      valueInited = new boolean[newSize];\n      valueIsNull = new boolean[newSize];\n      keyObjects = new LazyBinaryPrimitive<?, ?>[newSize];\n      valueObjects = new LazyBinaryObject[newSize];\n    }\n  }\n  boolean nullMapKey = false;\n  VInt vInt = new LazyBinaryUtils.VInt();\n  RecordInfo recordInfo = new LazyBinaryUtils.RecordInfo();\n  /**\n   * Parse the byte[] and fill keyStart, keyLength, keyIsNull valueStart,\n   * valueLength and valueIsNull.\n   */\n  private void parse() {\n    byte[] bytes = this.bytes.getData();\n    // get the VInt that represents the map size\n    LazyBinaryUtils.readVInt(bytes, start, vInt);\n    mapSize = vInt.value;\n    if (0 == mapSize) {\n      parsed = true;\n      return;\n    }\n    // adjust arrays\n    adjustArraySize(mapSize);\n    // find out the null-bytes\n    int mapByteStart = start + vInt.length;\n    int nullByteCur = mapByteStart;\n    int nullByteEnd = mapByteStart + (mapSize * 2 + 7) / 8;\n    int lastElementByteEnd = nullByteEnd;\n    // parsing the keys and values one by one\n    for (int i = 0; i < mapSize; i++) {\n      // parse a key\n      keyIsNull[i] = true;\n      if ((bytes[nullByteCur] & (1 << ((i * 2) % 8))) != 0) {\n        keyIsNull[i] = false;\n        LazyBinaryUtils.checkObjectByteInfo(((MapObjectInspector) oi)\n            .getMapKeyObjectInspector(), bytes, lastElementByteEnd, recordInfo, vInt);\n        keyStart[i] = lastElementByteEnd + recordInfo.elementOffset;\n        keyLength[i] = recordInfo.elementSize;\n        lastElementByteEnd = keyStart[i] + keyLength[i];\n      } else if (!nullMapKey) {\n        nullMapKey = true;\n        LOG.warn(\"Null map key encountered! Ignoring similar problems.\");\n      }\n      // parse a value\n      valueIsNull[i] = true;\n      if ((bytes[nullByteCur] & (1 << ((i * 2 + 1) % 8))) != 0) {\n        valueIsNull[i] = false;\n        LazyBinaryUtils.checkObjectByteInfo(((MapObjectInspector) oi)\n            .getMapValueObjectInspector(), bytes, lastElementByteEnd,\n            recordInfo, vInt);\n        valueStart[i] = lastElementByteEnd + recordInfo.elementOffset;\n        valueLength[i] = recordInfo.elementSize;\n        lastElementByteEnd = valueStart[i] + valueLength[i];\n      }\n      // move onto the next null byte\n      if (3 == (i % 4)) {\n        nullByteCur++;\n      }\n    }\n    Arrays.fill(keyInited, 0, mapSize, false);\n    Arrays.fill(valueInited, 0, mapSize, false);\n    parsed = true;\n  }\n  /**\n   * Get the value object with the index without checking parsed.\n   * \n   * @param index\n   *          The index into the array starting from 0\n   */\n  private LazyBinaryObject uncheckedGetValue(int index) {\n    if (valueIsNull[index]) {\n      return null;\n    }\n    if (!valueInited[index]) {\n      valueInited[index] = true;\n      if (valueObjects[index] == null) {\n        valueObjects[index] = LazyBinaryFactory\n            .createLazyBinaryObject(((MapObjectInspector) oi)\n            .getMapValueObjectInspector());\n      }\n      valueObjects[index].init(bytes, valueStart[index], valueLength[index]);\n    }\n    return valueObjects[index];\n  }\n  /**\n   * Get the value in the map for the key.\n   * \n   * If there are multiple matches (which is possible in the serialized format),\n   * only the first one is returned.\n   * \n   * The most efficient way to get the value for the key is to serialize the key\n   * and then try to find it in the array. We do linear search because in most\n   * cases, user only wants to get one or two values out of the map, and the\n   * cost of building up a HashMap is substantially higher.\n   * \n   * @param key<fim_middle>// function below has no smell\n"}