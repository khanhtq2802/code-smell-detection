{"text": "<fim_prefix>// Copyright (C) 2007 Google Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\npackage com.google.caja.parser.quasiliteral;\nimport com.google.caja.SomethingWidgyHappenedError;\nimport com.google.caja.lexer.CharProducer;\nimport com.google.caja.lexer.FilePosition;\nimport com.google.caja.lexer.InputSource;\nimport com.google.caja.lexer.JsLexer;\nimport com.google.caja.lexer.JsTokenQueue;\nimport com.google.caja.lexer.ParseException;\nimport com.google.caja.parser.ParseTreeNode;\nimport com.google.caja.parser.ParserBase;\nimport com.google.caja.parser.js.Block;\nimport com.google.caja.parser.js.DirectivePrologue;\nimport com.google.caja.parser.js.Expression;\nimport com.google.caja.parser.js.ExpressionStmt;\nimport com.google.caja.parser.js.FormalParam;\nimport com.google.caja.parser.js.FunctionConstructor;\nimport com.google.caja.parser.js.FunctionDeclaration;\nimport com.google.caja.parser.js.Identifier;\nimport com.google.caja.parser.js.LabeledStatement;\nimport com.google.caja.parser.js.LabeledStmtWrapper;\nimport com.google.caja.parser.js.ObjProperty;\nimport com.google.caja.parser.js.ObjectConstructor;\nimport com.google.caja.parser.js.Parser;\nimport com.google.caja.parser.js.Reference;\nimport com.google.caja.parser.js.Statement;\nimport com.google.caja.parser.js.StringLiteral;\nimport com.google.caja.parser.js.ValueProperty;\nimport com.google.caja.reporting.DevNullMessageQueue;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n/**\n * Creates a JavaScript {@link QuasiNode} tree given a JavaScript\n * {@link com.google.caja.parser.ParseTreeNode} tree.\n *\n * @author ihab.awad@gmail.com (Ihab Awad)\n */\npublic class QuasiBuilder {\n  private static final Map<String, QuasiNode> patternCache\n      = Collections.synchronizedMap(new LinkedHashMap<String, QuasiNode>() {\n        private static final long serialVersionUID = 8370964871936109547L;\n        @Override\n        public boolean removeEldestEntry(Map.Entry<String, QuasiNode> e) {\n          return this.size() > 256;\n        }\n      });\n  /**\n   * Match a quasiliteral pattern against a specimen.\n   *\n   * @param patternText a quasiliteral pattern.\n   * @param specimen a specimen parse tree node.\n   * @return whether the match succeeded.\n   * @see QuasiNode#match(com.google.caja.parser.ParseTreeNode)\n   */\n  public static boolean match(String patternText, ParseTreeNode specimen) {\n    return match(patternText, specimen, makeBindings());\n  }\n  /**\n   * Match a quasiliteral pattern against a specimen, returning any\n   * hole bindings found in a client supplied map.\n   *\n   * @param patternText a quasiliteral pattern.\n   * @param specimen a specimen parse tree node.\n   * @param bindings a map into which hole bindings resulting from the match\n   *     will be placed.\n   * @return whether the match succeeded.\n   * @see QuasiNode#match(com.google.caja.parser.ParseTreeNode)\n   */\n<fim_suffix>  public static boolean match(\n      String patternText,\n      ParseTreeNode specimen,\n      Map<String, ParseTreeNode> bindings) {\n    Map<String, ParseTreeNode> tempBindings = getPatternNode(patternText)\n        .match(specimen);\n    if (tempBindings != null) {\n      bindings.putAll(tempBindings);\n      return true;\n    }\n    return false;\n  }\n  /**\n   * Substitute variables into a quasiliteral pattern, returning a\n   * concrete parse tree node.\n   *\n   * @param patternText a quasiliteral pattern.\n   * @param bindings a set of bindings from names to parse tree nodes.\n   * @return a new parse tree node resulting from the substitution.\n   * @see QuasiNode#substitute(java.util.Map)\n   */\n  public static ParseTreeNode subst(\n      String patternText, Map<String, ParseTreeNode> bindings) {\n    return getPatternNode(patternText).substitute(bindings);\n  }\n  /**\n   * Substitute variables into a quasiliteral pattern, returning a concrete\n   * parse tree node, passing the bindings as a variable arguments list.\n   *\n   * @param patternText a quasiliteral pattern.\n   * @param args an even number of values arranged in pairs of\n   *     ({@code String}, {@code ParseTreeNode}) representing bindings to\n   *     substitute into the pattern.\n   * @return a new parse tree node resulting from the substitution.\n   * @see #subst(String, java.util.Map)\n   */\n  public static ParseTreeNode substV(String patternText, Object... args) {\n    if (args.length % 2 != 0) {\n      throw new SomethingWidgyHappenedError(\"Wrong # of args for subst()\");\n    }\n    Map<String, ParseTreeNode> bindings = makeBindings();\n    for (int i = 0; i < args.length; i += 2) {\n      ParseTreeNode value = (ParseTreeNode) args[i + 1];\n      if (value != null) {\n        // TODO(felix8a): can't do this because of ArrayIndexOptimization\n        //value.makeImmutable();\n      }\n      bindings.put((String) args[i], value);\n    }\n    ParseTreeNode result = subst(patternText, bindings);\n    if (result == null) {\n      throw new NullPointerException(\n          \"'\" + patternText + \"' > \" + bindings.keySet());\n    }\n    return result;\n  }\n  /**\n   * Given a quasiliteral pattern expressed as text, return a {@code QuasiNode}\n   * representing the pattern.\n   *\n   * @param inputSource description of input source of pattern text.\n   * @param pattern a quasiliteral pattern.\n   * @return the QuasiNode representation of the input.\n   * @exception ParseException if there is a parsing problem.\n   */\n  public static QuasiNode parseQuasiNode(\n      InputSource inputSource, String pattern)\n      throws ParseException {\n    // The top-level node returned from the parser is always a Block.\n    Block topLevelBlock = (Block) parse(inputSource, pattern);\n    ParseTreeNode topLevelNode = topLevelBlock;\n    // If the top-level Block contains a single child, promote it to allow it to\n    // match anywhere.\n    if (topLevelNode.children().size() == 1) {\n      topLevelNode = topLevelNode.children().get(0);\n    }\n    // If the top level is an ExpressionStmt, with one child, then promote its\n    // single child to the top level to allow the contained expression to match\n    // anywhere.\n    if (topLevelNode instanceof ExpressionStmt) {\n      topLevelNode = topLevelNode.children().get(0);\n    }\n    // If the top level is a FunctionDeclaration, promote its single child to\n    // the top level to allow the contained FunctionConstructor to match in any\n    // context.\n    if (topLevelNode instanceof FunctionDeclaration) {\n      topLevelNode = ((FunctionDeclaration) topLevelNode).getInitializer();\n    }\n    return build(topLevelNode);\n  }\n  /**\n   * @see #parseQuasiNode(InputSource,String)\n   * @see FilePosition#UNKNOWN\n   */\n  public static QuasiNode parseQuasiNode(String pattern) throws ParseException {\n    return parseQuasiNode(FilePosition.UNKNOWN.source(), pattern);\n  }\n  /** This parallels the fuzzing done in\n   * {@link QuasiBuilder#parseQuasiNode(InputSource, String)} */\n  // TODO(felix8a): why is this comment a lie?\n  public static Class<? extends ParseTreeNode> fuzzType(\n      Class<? extends ParseTreeNode> nodeClass) {<fim_middle>// function below has no smell\n"}