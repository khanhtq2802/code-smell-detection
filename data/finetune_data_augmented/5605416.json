{"text": "<fim_prefix>     * }, etc. If there are no children, this will be null.\n     */\n    private IMXMLNode[] children;\n    /**\n     * A map of the child nodes of this node which specify properties. The keys\n     * are the property names. If there are no properties specified, this will\n     * be null.\n     */\n    private Map<String, IMXMLPropertySpecifierNode> propertyNodeMap;\n    /**\n     * All child property nodes.  The propertyNodeMap only has the last value\n     * specified for a property name.  There can be more than one value\n     * specified if there is different values for different states.\n     */\n    private List<IMXMLPropertySpecifierNode> allPropertyNodes;\n    /**\n     * A map of child nodes of this node which specify events. The keys are the\n     * event names. If there are no events specified, this will be null.\n     */\n    private Map<String, IMXMLEventSpecifierNode> eventNodeMap;\n    /**\n     * All child event nodes.  The eventNodeMap only has the last value\n     * specified for a event name.  There can be more than one value\n     * specified if there is different values for different states.\n     */\n    private List<IMXMLEventSpecifierNode> allEventNodes;\n    /**\n     * A map of suffix (specifying a state or state group) to the child nodes\n     * with this suffix.\n     */\n    private Map<String, Collection<IMXMLSpecifierNode>> suffixSpecifierMap;\n    /**\n     * The definition of the default property. This gets lazily initialized by\n     * {@code getDefaultPropertyDefinition()} if we need to know it.\n     */\n    private IVariableDefinition defaultPropertyDefinition;\n    /**\n     * The definition of an alternate default property. This gets lazily initialized by\n     * {@code getDefaultPropertyDefinition()} if we need to know it.\n     */\n    private IVariableDefinition altDefaultPropertyDefinition;\n    /**\n     * A flag that keeps track of whether the {@code defaultPropertyDefinition}\n     * field has been initialized. Simply checking whether it is\n     * <code>null</code> doesn't work, because <code>null</code> means\n     * \"no default property\" rather than \"default property not determined yet\".\n     */\n    private boolean defaultPropertyDefinitionInitialized = false;\n    /**\n     * A flag that keeps track of whether we are processing a content unit for\n     * the default property. For example, you can have MXML like\n     * \n     * <pre>\n     * &lt;Application&gt;\n     *     &lt;width&gt;100&lt;/width&gt;\n     *     &lt;Button/&gt;\n     *     &lt;Button/&gt;\n     *     &lt;height&gt;100&lt;/height&gt;\n     * &lt;/Application&gt;\n     * </pre>\n     * \n     * where the two <code>Button</code> tags specify an implicit array for the\n     * <code>mxmlContentFactory</code> property. This flag is set true on the\n     * first <code>Button</code> tag and then set back to false on the\n     * <code>height</code> tag.\n     */\n    private boolean processingDefaultProperty = false;\n    /**\n     * A flag that keeps track of whether we have complete the processing of the\n     * content units for the default property, so that we don't process\n     * non-contiguous units.\n     */\n    private boolean processedDefaultProperty = false;\n    /**\n     * The implicit node created to represent the default property.\n     */\n    private MXMLPropertySpecifierNode defaultPropertyNode;\n    /**\n     * A list that accumulates content units for the default property.\n     */\n    private List<IMXMLUnitData> defaultPropertyContentUnits;\n    @Override\n    public IASNode getChild(int i)\n    {\n        return children != null ? children[i] : null;\n    }\n    @Override\n    public int getChildCount()\n    {\n        return children != null ? children.length : 0;\n    }\n    @Override\n    public String getName()\n    {\n        // The classReference can be null when getName() is called from toString()\n        // in the debugger if the node is not yet fully initialized.\n        return classReference != null ? classReference.getQualifiedName() : \"\";\n    }\n    @Override\n    public IClassDefinition getClassReference(ICompilerProject project)\n    {\n        return classReference;\n    }\n    @Override\n    public boolean isMXMLObject()\n    {\n        return isMXMLObject;\n    }\n    @Override\n    public boolean isContainer()\n    {\n        return isContainer;\n    }\n    @Override\n    public boolean isVisualElementContainer()\n    {\n        return isVisualElementContainer;\n    }\n    @Override\n    public boolean isDeferredInstantiationUIComponent()\n    {\n        return isDeferredInstantiationUIComponent;\n    }\n    /**\n     * Sets the definition of the ActionScript class to which this node refers.\n     */\n    void setClassReference(RoyaleProject project, IClassDefinition classReference)\n    {\n        this.classReference = classReference;\n        // TODO Optimize this by enumerating all interfaces one time.\n        // Keep track of whether the class implements mx.core.IMXML,\n        // because that affects code generation.\n        String mxmlObjectInterface = project.getMXMLObjectInterface();\n        isMXMLObject = classReference.isInstanceOf(mxmlObjectInterface, project);\n        // Keep track of whether the class implements mx.core.IVisualElementContainer,\n        // because that affects code generation.\n        String visualElementContainerInterface = project.getVisualElementContainerInterface();\n        isVisualElementContainer = classReference.isInstanceOf(visualElementContainerInterface, project);\n        // Keep track of whether the class implements mx.core.IContainer,\n        // because that affects code generation.\n        String containerInterface = project.getContainerInterface();\n        isContainer = classReference.isInstanceOf(containerInterface, project);\n        // Keep track of whether the class implements mx.core.IDeferredInstantiationUIComponent\n        // because that affects code generation.\n        String deferredInstantiationUIComponentInterface = project.getDeferredInstantiationUIComponentInterface();\n        isDeferredInstantiationUIComponent = classReference.isInstanceOf(deferredInstantiationUIComponentInterface, project);\n    }\n    /**\n     * Sets the definition of the ActionScript class to which this node refers,\n     * from its fully qualified name.\n     * \n     * @param project An {@code ICompilerProject}, used for finding the class by\n     * name.\n     * @param qname A fully qualified class name.\n     */\n    void setClassReference(RoyaleProject project, String qname)\n    {\n        ASProjectScope projectScope = (ASProjectScope)project.getScope();\n        IDefinition definition = projectScope.findDefinitionByName(qname);\n        // TODO This method is getting called by MXML tree-building\n        // with an interface qname if there is a property whose type is an interface.\n        // Until databinding is implemented, we need to protect against this.\n        if (definition instanceof IClassDefinition)\n            setClassReference(project, (IClassDefinition)definition);\n    }\n    /**\n     * Sets the child nodes of this node.\n     * \n     * @param children An array of {@code IMXMLNode} objects.\n     */\n    void setChildren(IMXMLNode[] children)\n    {\n        this.children = children;\n        if (children != null)\n        {\n            for (IMXMLNode child : children)\n            {\n                if (child instanceof IMXMLPropertySpecifierNode)\n                {\n                    if (propertyNodeMap == null)\n                    {\n                        propertyNodeMap = new HashMap<String, IMXMLPropertySpecifierNode>();\n                        allPropertyNodes = new ArrayList<IMXMLPropertySpecifierNode>();\n                    }\n                    propertyNodeMap.put(child.getName(), (IMXMLPropertySpecifierNode)child);\n                    allPropertyNodes.add((IMXMLPropertySpecifierNode)child);\n                }\n                else if (child instanceof IMXMLEventSpecifierNode)\n                {\n                    if (eventNodeMap == null)\n                    {\n                        eventNodeMap = new HashMap<String, IMXMLEventSpecifierNode>();\n                        allEventNodes = new ArrayList<IMXMLEventSpecifierNode>();\n                    }\n                    eventNodeMap.put(child.getName(), (IMXMLEventSpecifierNode)child);\n                    allEventNodes.add((IMXMLEventSpecifierNode)child);\n                }\n                if (child instanceof IMXMLSpecifierNode)\n                {\n                    if (suffixSpecifierMap == null)\n                        suffixSpecifierMap = new HashMap<String, Collection<IMXMLSpecifierNode>>();\n                    //                    suffixSpecifierMap.put(((IMXMLSpecifierNode)child).getSuffix(),\n                    //                                           (IMXMLSpecifierNode)child);\n                }\n            }\n        }\n    }\n    @Override\n    public IMXMLPropertySpecifierNode getPropertySpecifierNode(String name)\n    {\n        return propertyNodeMap != null ? propertyNodeMap.get(name) : null;\n    }\n    @Override\n    public IMXMLPropertySpecifierNode[] getPropertySpecifierNodes()\n    {\n        return allPropertyNodes != null ?\n        \t\tallPropertyNodes.toArray(new IMXMLPropertySpecifierNode[0]) :\n                null;\n    }\n<fim_suffix>    @Override\n    public IMXMLEventSpecifierNode getEventSpecifierNode(String name)\n    {\n        return eventNodeMap != null ? eventNodeMap.get(name) : null;\n    }<fim_middle>// function below has no smell\n"}