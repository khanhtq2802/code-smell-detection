{"text": "<fim_prefix>        @Override\n        ReferenceLookupResult boundResult(ReferenceLookupResult boundRes) {\n            return !boundRes.isSuccess() || boundRes.hasKind(StaticKind.NON_STATIC) ?\n                    boundRes : //the search produces a non-static method\n                    ReferenceLookupResult.error(new BadMethodReferenceError(boundRes.sym, false));\n        }\n        @Override\n        ReferenceLookupResult unboundResult(ReferenceLookupResult boundRes, ReferenceLookupResult unboundRes) {\n            if (boundRes.hasKind(StaticKind.STATIC) &&\n                    (!unboundRes.isSuccess() || unboundRes.hasKind(StaticKind.STATIC))) {\n                //the first search produces a static method and no non-static method is applicable\n                //during the second search\n                return boundRes;\n            } else if (unboundRes.hasKind(StaticKind.NON_STATIC) &&\n                    (!boundRes.isSuccess() || boundRes.hasKind(StaticKind.NON_STATIC))) {\n                //the second search produces a non-static method and no static method is applicable\n                //during the first search\n                return unboundRes;\n            } else if (boundRes.isSuccess() && unboundRes.isSuccess()) {\n                //both searches produce some result; ambiguity (error recovery)\n                return ReferenceLookupResult.error(ambiguityError(boundRes.sym, unboundRes.sym));\n            } else if (boundRes.isSuccess() || unboundRes.isSuccess()) {\n                //Both searches failed to produce a result with correct staticness (i.e. first search\n                //produces an non-static method). Alternatively, a given search produced a result\n                //with the right staticness, but the other search has applicable methods with wrong\n                //staticness (error recovery)\n                return ReferenceLookupResult.error(new BadMethodReferenceError(boundRes.isSuccess() ?\n                        boundRes.sym : unboundRes.sym, true));\n            } else {\n                //both searches fail to produce a result - pick 'better' error using heuristics (error recovery)\n                return (boundRes.canIgnore() && !unboundRes.canIgnore()) ?\n                        unboundRes : boundRes;\n            }\n        }\n    };\n    /**\n     * This chooser implements the selection strategy used during an arity-based lookup; this logic\n     * is described in JLS SE 8 (15.12.2.1).\n     */\n    ReferenceChooser structuralReferenceChooser = new ReferenceChooser() {\n        @Override\n        ReferenceLookupResult boundResult(ReferenceLookupResult boundRes) {\n            return (!boundRes.isSuccess() || !boundRes.hasKind(StaticKind.STATIC)) ?\n                    boundRes : //the search has at least one applicable non-static method\n                    ReferenceLookupResult.error(new BadMethodReferenceError(boundRes.sym, false));\n        }\n        @Override\n        ReferenceLookupResult unboundResult(ReferenceLookupResult boundRes, ReferenceLookupResult unboundRes) {\n            if (boundRes.isSuccess() && !boundRes.hasKind(StaticKind.NON_STATIC)) {\n                //the first serach has at least one applicable static method\n                return boundRes;\n            } else if (unboundRes.isSuccess() && !unboundRes.hasKind(StaticKind.STATIC)) {\n                //the second search has at least one applicable non-static method\n                return unboundRes;\n            } else if (boundRes.isSuccess() || unboundRes.isSuccess()) {\n                //either the first search produces a non-static method, or second search produces\n                //a non-static method (error recovery)\n                return ReferenceLookupResult.error(new BadMethodReferenceError(boundRes.isSuccess() ?\n                        boundRes.sym : unboundRes.sym, true));\n            } else {\n                //both searches fail to produce a result - pick 'better' error using heuristics (error recovery)\n                return (boundRes.canIgnore() && !unboundRes.canIgnore()) ?\n                        unboundRes : boundRes;\n            }\n        }\n    };\n    /**\n     * Helper for defining custom method-like lookup logic; a lookup helper\n     * provides hooks for (i) the actual lookup logic and (ii) accessing the\n     * lookup result (this step might result in compiler diagnostics to be generated)\n     */\n    abstract class LookupHelper {\n        /** name of the symbol to lookup */\n        Name name;\n        /** location in which the lookup takes place */\n        Type site;\n        /** actual types used during the lookup */\n        List<Type> argtypes;\n        /** type arguments used during the lookup */\n        List<Type> typeargtypes;\n        /** Max overload resolution phase handled by this helper */\n        MethodResolutionPhase maxPhase;\n        LookupHelper(Name name, Type site, List<Type> argtypes, List<Type> typeargtypes, MethodResolutionPhase maxPhase) {\n            this.name = name;\n            this.site = site;\n            this.argtypes = argtypes;\n            this.typeargtypes = typeargtypes;\n            this.maxPhase = maxPhase;\n        }\n        /**\n         * Should lookup stop at given phase with given result\n         */\n        final boolean shouldStop(Symbol sym, MethodResolutionPhase phase) {\n            return phase.ordinal() > maxPhase.ordinal() ||\n                !sym.kind.isResolutionError() || sym.kind == AMBIGUOUS;\n        }\n        /**\n         * Search for a symbol under a given overload resolution phase - this method\n         * is usually called several times, once per each overload resolution phase\n         */\n        abstract Symbol lookup(Env<AttrContext> env, MethodResolutionPhase phase);\n        /**\n         * Dump overload resolution info\n         */\n        void debug(DiagnosticPosition pos, Symbol sym) {\n            //do nothing\n        }\n        /**\n         * Validate the result of the lookup\n         */\n        abstract Symbol access(Env<AttrContext> env, DiagnosticPosition pos, Symbol location, Symbol sym);\n    }\n    abstract class BasicLookupHelper extends LookupHelper {\n        BasicLookupHelper(Name name, Type site, List<Type> argtypes, List<Type> typeargtypes) {\n            this(name, site, argtypes, typeargtypes, MethodResolutionPhase.VARARITY);\n        }\n        BasicLookupHelper(Name name, Type site, List<Type> argtypes, List<Type> typeargtypes, MethodResolutionPhase maxPhase) {\n            super(name, site, argtypes, typeargtypes, maxPhase);\n        }\n        @Override\n        final Symbol lookup(Env<AttrContext> env, MethodResolutionPhase phase) {\n            Symbol sym = doLookup(env, phase);\n            if (sym.kind == AMBIGUOUS) {\n                AmbiguityError a_err = (AmbiguityError)sym.baseSymbol();\n                sym = a_err.mergeAbstracts(site);\n            }\n            return sym;\n        }\n        abstract Symbol doLookup(Env<AttrContext> env, MethodResolutionPhase phase);\n        @Override\n        Symbol access(Env<AttrContext> env, DiagnosticPosition pos, Symbol location, Symbol sym) {\n            if (sym.kind.isResolutionError()) {\n                //if nothing is found return the 'first' error\n                sym = accessMethod(sym, pos, location, site, name, true, argtypes, typeargtypes);\n            }\n            return sym;\n        }\n        @Override\n        void debug(DiagnosticPosition pos, Symbol sym) {\n            reportVerboseResolutionDiagnostic(pos, name, site, argtypes, typeargtypes, sym);\n        }\n    }\n    /**\n     * Helper class for member reference lookup. A reference lookup helper\n     * defines the basic logic for member reference lookup; a method gives\n     * access to an 'unbound' helper used to perform an unbound member\n     * reference lookup.\n     */\n<fim_suffix>    abstract class ReferenceLookupHelper extends LookupHelper {\n        /** The member reference tree */\n        JCMemberReference referenceTree;\n        ReferenceLookupHelper(JCMemberReference referenceTree, Name name, Type site,\n                List<Type> argtypes, List<Type> typeargtypes, MethodResolutionPhase maxPhase) {\n            super(name, site, argtypes, typeargtypes, maxPhase);\n            this.referenceTree = referenceTree;\n        }\n        /**\n         * Returns an unbound version of this lookup helper. By default, this\n         * method returns an dummy lookup helper.\n         */\n        ReferenceLookupHelper unboundLookup(InferenceContext inferenceContext) {\n            return null;\n        }\n        /**\n         * Get the kind of the member reference\n         */\n        abstract JCMemberReference.ReferenceKind referenceKind(Symbol sym);\n        Symbol access(Env<AttrContext> env, DiagnosticPosition pos, Symbol location, Symbol sym) {\n            if (sym.kind == AMBIGUOUS) {\n                AmbiguityError a_err = (AmbiguityError)sym.baseSymbol();\n                sym = a_err.mergeAbstracts(site);\n            }\n            //skip error reporting\n            return sym;\n        }\n    }<fim_middle>// class below has no smell\n"}