{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.flink.runtime.concurrent;\n\nimport javax.annotation.Nonnull;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.CancellationException;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/** The direct executor service directly executes the runnables and the callables in the calling thread. */\n<fim_suffix>class DirectExecutorService implements ExecutorService {\n\tstatic final DirectExecutorService INSTANCE = new DirectExecutorService();\n\n\tprivate boolean isShutdown = false;\n\n\t@Override\n\tpublic void shutdown() {\n\t\tisShutdown = true;\n\t}\n\n\t@Override\n\t@Nonnull\n\tpublic List<Runnable> shutdownNow() {\n\t\tisShutdown = true;\n\t\treturn Collections.emptyList();\n\t}\n\n\t@Override\n\tpublic boolean isShutdown() {\n\t\treturn isShutdown;\n\t}\n\n\t@Override\n\tpublic boolean isTerminated() {\n\t\treturn isShutdown;\n\t}\n\n\t@Override\n\tpublic boolean awaitTermination(long timeout, @Nonnull TimeUnit unit) {\n\t\treturn isShutdown;\n\t}\n\n\t@Override\n\t@Nonnull\n\tpublic <T> Future<T> submit(@Nonnull Callable<T> task) {\n\t\ttry {\n\t\t\tT result = task.call();\n\n\t\t\treturn new CompletedFuture<>(result, null);\n\t\t} catch (Exception e) {\n\t\t\treturn new CompletedFuture<>(null, e);\n\t\t}\n\t}\n\n\t@Override\n\t@Nonnull\n\tpublic <T> Future<T> submit(@Nonnull Runnable task, T result) {\n\t\ttask.run();\n\n\t\treturn new CompletedFuture<>(result, null);\n\t}\n\n\t@Override\n\t@Nonnull\n\tpublic Future<?> submit(@Nonnull Runnable task) {\n\t\ttask.run();\n\t\treturn new CompletedFuture<>(null, null);\n\t}\n\n\t@Override\n\t@Nonnull\n\tpublic <T> List<Future<T>> invokeAll(@Nonnull Collection<? extends Callable<T>> tasks) {\n\t\tArrayList<Future<T>> result = new ArrayList<>();\n\n\t\tfor (Callable<T> task : tasks) {\n\t\t\ttry {\n\t\t\t\tresult.add(new CompletedFuture<>(task.call(), null));\n\t\t\t} catch (Exception e) {\n\t\t\t\tresult.add(new CompletedFuture<>(null, e));\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t@Override\n\t@Nonnull\n\tpublic <T> List<Future<T>> invokeAll(\n\t\t@Nonnull Collection<? extends Callable<T>> tasks, long timeout, @Nonnull TimeUnit unit) {\n\n\t\tlong end = System.currentTimeMillis() + unit.toMillis(timeout);\n\t\tIterator<? extends Callable<T>> iterator = tasks.iterator();\n\t\tArrayList<Future<T>> result = new ArrayList<>();\n\n\t\twhile (end > System.currentTimeMillis() && iterator.hasNext()) {\n\t\t\tCallable<T> callable = iterator.next();\n\n\t\t\ttry {\n\t\t\t\tresult.add(new CompletedFuture<>(callable.call(), null));\n\t\t\t} catch (Exception e) {\n\t\t\t\tresult.add(new CompletedFuture<>(null, e));\n\t\t\t}\n\t\t}\n\n\t\twhile (iterator.hasNext()) {\n\t\t\titerator.next();\n\t\t\tresult.add(new Future<T>() {\n\t\t\t\t@Override\n\t\t\t\tpublic boolean cancel(boolean mayInterruptIfRunning) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean isCancelled() {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic boolean isDone() {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic T get() {\n\t\t\t\t\tthrow new CancellationException(\"Task has been cancelled.\");\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic T get(long timeout, @Nonnull TimeUnit unit) {\n\t\t\t\t\tthrow new CancellationException(\"Task has been cancelled.\");\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t@Override\n\t@Nonnull\n\tpublic <T> T invokeAny(@Nonnull Collection<? extends Callable<T>> tasks) throws ExecutionException {\n\t\tException exception = null;\n\n\t\tfor (Callable<T> task : tasks) {\n\t\t\ttry {\n\t\t\t\treturn task.call();\n\t\t\t} catch (Exception e) {\n\t\t\t\t// try next task\n\t\t\t\texception = e;\n\t\t\t}\n\t\t}\n\n\t\tthrow new ExecutionException(\"No tasks finished successfully.\", exception);\n\t}\n\n\t@Override\n\tpublic <T> T invokeAny(\n\t\t@Nonnull Collection<? extends Callable<T>> tasks,\n\t\tlong timeout,\n\t\t@Nonnull TimeUnit unit) throws ExecutionException, TimeoutException {\n\n\t\tlong end = System.currentTimeMillis() + unit.toMillis(timeout);\n\t\tException exception = null;\n\n\t\tIterator<? extends Callable<T>> iterator = tasks.iterator();\n\n\t\twhile (end > System.currentTimeMillis() && iterator.hasNext()) {\n\t\t\tCallable<T> callable = iterator.next();\n\n\t\t\ttry {\n\t\t\t\treturn callable.call();\n\t\t\t} catch (Exception e) {\n\t\t\t\t// ignore exception and try next\n\t\t\t\texception = e;\n\t\t\t}\n\t\t}\n\n\t\tif (iterator.hasNext()) {\n\t\t\tthrow new TimeoutException(\"Could not finish execution of tasks within time.\");\n\t\t} else {\n\t\t\tthrow new ExecutionException(\"No tasks finished successfully.\", exception);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void execute(@Nonnull Runnable command) {\n\t\tcommand.run();\n\t}\n\n\tstatic class CompletedFuture<V> implements Future<V> {\n\t\tprivate final V value;\n\t\tprivate final Exception exception;\n\n\t\tCompletedFuture(V value, Exception exception) {\n\t\t\tthis.value = value;\n\t\t\tthis.exception = exception;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean cancel(boolean mayInterruptIfRunning) {\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isCancelled() {\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean isDone() {\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic V get() throws ExecutionException {\n\t\t\tif (exception != null) {\n\t\t\t\tthrow new ExecutionException(exception);\n\t\t\t} else {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic V get(long timeout, @Nonnull TimeUnit unit) throws ExecutionException {\n\t\t\treturn get();\n\t\t}\n\t}\n}<fim_middle>// class below is blob\n"}