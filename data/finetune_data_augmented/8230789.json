{"text": "<fim_prefix>     * collection entries are listed first.\n     */\n    protected String sort;\n    /** The reverse parameter reverses the sort order. <code>false</code> is default. */\n    protected boolean reverse;\n    /** The regular expression for the root pattern. */\n    protected RE rootRE;\n    /** The regular expression for the include pattern. */\n    protected RE includeRE;\n    /** The regular expression for the exclude pattern. */\n    protected RE excludeRE;\n    /**\n     * This is only set to true for the requested source specified by the\n     * <code>src</code> attribute on the generator's configuration.\n     */\n    protected boolean isRequestedSource;\n    /**\n     * Set the request parameters. Must be called before the generate method.\n     *\n     * @param resolver     the SourceResolver object\n     * @param objectModel  a <code>Map</code> containing model object\n     * @param src          the Traversable Source to be XMLized specified as\n     *                     <code>src</code> attribute on &lt;map:generate/>\n     * @param par          configuration parameters\n     */\n    public void setup(SourceResolver resolver, Map objectModel, String src, Parameters par)\n    throws ProcessingException, SAXException, IOException {\n        if (src == null) {\n            throw new ProcessingException(\"No src attribute pointing to a traversable source to be XMLized specified.\");\n        }\n        super.setup(resolver, objectModel, src, par);\n        this.cacheKeyParList = new ArrayList();\n        this.cacheKeyParList.add(src);\n        this.depth = par.getParameterAsInteger(\"depth\", 1);\n        this.cacheKeyParList.add(String.valueOf(this.depth));\n        String dateFormatString = par.getParameter(\"dateFormat\", null);\n        this.cacheKeyParList.add(dateFormatString);\n        if (dateFormatString != null) {\n            String locale = par.getParameter(\"locale\", null);\n            if (locale != null) {\n                this.dateFormatter = new SimpleDateFormat(dateFormatString, new Locale(locale, \"\"));\n            } else {\n                this.dateFormatter = new SimpleDateFormat(dateFormatString);\n            }\n        } else {\n            this.dateFormatter = new SimpleDateFormat();\n        }\n        String timeZone = par.getParameter(\"timeZone\", null);\n        if (timeZone != null) {\n            this.dateFormatter.setTimeZone(TimeZone.getTimeZone(timeZone));\n        }\n        this.sort = par.getParameter(\"sort\", \"name\");\n        this.cacheKeyParList.add(this.sort);\n        this.reverse = par.getParameterAsBoolean(\"reverse\", false);\n        this.cacheKeyParList.add(String.valueOf(this.reverse));\n        this.refreshDelay = par.getParameterAsLong(\"refreshDelay\", 1L) * 1000L;\n        this.cacheKeyParList.add(String.valueOf(this.refreshDelay));\n        if (this.getLogger().isDebugEnabled()) {\n            this.getLogger().debug(\"depth: \" + this.depth);\n            this.getLogger().debug(\"dateFormat: \" + this.dateFormatter.toPattern());\n            this.getLogger().debug(\"timeZone: \" + timeZone);\n            this.getLogger().debug(\"sort: \" + this.sort);\n            this.getLogger().debug(\"reverse: \" + this.reverse);\n            this.getLogger().debug(\"refreshDelay: \" + this.refreshDelay);\n        }\n        String rePattern = null;\n        try {\n            rePattern = par.getParameter(\"root\", null);\n            if (this.getLogger().isDebugEnabled()) {\n                this.getLogger().debug(\"root pattern: \" + rePattern);\n            }\n            this.cacheKeyParList.add(rePattern);\n            this.rootRE = (rePattern == null) ? null : new RE(rePattern);\n            rePattern = par.getParameter(\"include\", null);\n            if (this.getLogger().isDebugEnabled()) {\n                this.getLogger().debug(\"include pattern: \" + rePattern);\n            }\n            this.cacheKeyParList.add(rePattern);\n            this.includeRE = (rePattern == null) ? null : new RE(rePattern);\n            rePattern = par.getParameter(\"exclude\", null);\n            if (this.getLogger().isDebugEnabled()) {\n                this.getLogger().debug(\"exclude pattern: \" + rePattern);\n            }\n            this.cacheKeyParList.add(rePattern);\n            this.excludeRE = (rePattern == null) ? null : new RE(rePattern);\n        } catch (RESyntaxException rese) {\n            throw new ProcessingException(\"Syntax error in regexp pattern '\"\n            \t\t\t                  + rePattern + \"'\", rese);\n        }\n        this.isRequestedSource = false;\n        this.attributes = new AttributesImpl();\n    }\n    /* (non-Javadoc)\n     * @see org.apache.cocoon.caching.CacheableProcessingComponent#getKey()\n     */\n    public Serializable getKey() {\n        StringBuffer buffer = new StringBuffer();\n        int len = this.cacheKeyParList.size();\n        for (int i = 0; i < len; i++) {\n            buffer.append(this.cacheKeyParList.get(i));\n            buffer.append(':');\n        }\n        return buffer.toString();\n    }\n    /**\n     * Gets the source validity, using a deferred validity object. The validity\n     * is initially empty since the resources that define it are not known\n     * before generation has occured. So the returned object is kept by the\n     * generator and filled with each of the resources that is traversed.\n     *\n     * @see org.apache.cocoon.components.source.impl.MultiSourceValidity\n     */\n    public SourceValidity getValidity() {\n        if (this.validity == null) {\n            this.validity = new MultiSourceValidity(this.resolver, this.refreshDelay);\n        }\n        return this.validity;\n    }\n    /**\n     * Generate XML data.\n     *\n     * @throws  SAXException if an error occurs while outputting the document\n     * @throws  ProcessingException if something went wrong while traversing\n     *                              the source hierarchy\n     */\n    public void generate() throws SAXException, ProcessingException {\n        Source src = null;\n        Stack ancestors = null;\n        try {\n            src = this.resolver.resolveURI(this.source);\n            if (!(src instanceof TraversableSource)) {\n                throw new SourceException(this.source + \" is not a traversable source\");\n            }\n            final TraversableSource inputSource = (TraversableSource) src;\n            if (!inputSource.exists()) {\n                throw new ResourceNotFoundException(this.source + \" does not exist.\");\n            }\n            this.contentHandler.startDocument();\n            this.contentHandler.startPrefixMapping(PREFIX, URI);\n            ancestors = getAncestors(inputSource);\n            addAncestorPath(inputSource, ancestors);\n            this.contentHandler.endPrefixMapping(PREFIX);\n            this.contentHandler.endDocument();\n            if (this.validity != null) {\n                this.validity.close();\n            }\n        } catch (SourceException se) {\n            throw SourceUtil.handle(se);\n        } catch (IOException ioe) {\n            throw new ResourceNotFoundException(\"Could not read collection \"\n                                                + this.source, ioe);\n        } finally {\n            if (src != null) {\n                this.resolver.release(src);\n            }\n            if (ancestors != null) {\n                Enumeration enumeration = ancestors.elements();\n                while (enumeration.hasMoreElements()) {\n                    resolver.release((Source) enumeration.nextElement());\n                }\n            }\n        }\n    }\n    /**\n     * Creates a stack containing the ancestors of a traversable source up to\n     * specific parent matching the root pattern.\n     *\n     * @param source the traversable source whose ancestors shall be retrieved\n     * @return a Stack containing the ancestors.\n     */\n    protected Stack getAncestors(TraversableSource source) throws IOException {\n        TraversableSource parent = source;\n        Stack ancestors = new Stack();\n        while ((parent != null) && !isRoot(parent)) {\n            parent = (TraversableSource) parent.getParent();\n            if (parent != null) {\n                ancestors.push(parent);\n            } else {\n                // no ancestor matched the root pattern\n                ancestors.clear();\n            }\n        }\n        return ancestors;\n    }\n    /**\n     * Adds recursively the path from the source matched by the root pattern\n     * down to the requested source.\n     *\n     * @param source       the requested source.\n     * @param ancestors  the stack of the ancestors.\n     * @throws SAXException\n     * @throws ProcessingException\n     */\n<fim_suffix>    protected void addAncestorPath(TraversableSource source, Stack ancestors)\n    throws SAXException, ProcessingException {\n        if (ancestors.empty()) {\n            this.isRequestedSource = true;\n            addPath(source, depth);\n        } else {\n            startNode(COL_NODE_NAME, (TraversableSource) ancestors.pop());\n            addAncestorPath(source, ancestors);\n            endNode(COL_NODE_NAME);\n        }\n    }<fim_middle>// function below has no smell\n"}