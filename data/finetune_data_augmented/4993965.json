{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jclouds.googlecomputeengine.compute.functions;\n\nimport com.google.common.base.Function;\nimport com.google.common.base.Optional;\nimport com.google.common.base.Splitter;\nimport com.google.common.base.Supplier;\nimport com.google.common.cache.LoadingCache;\nimport com.google.common.collect.ImmutableList;\nimport org.jclouds.collect.Memoized;\nimport org.jclouds.compute.domain.Hardware;\nimport org.jclouds.compute.domain.HardwareBuilder;\nimport org.jclouds.compute.domain.NodeMetadata;\nimport org.jclouds.compute.domain.NodeMetadata.Status;\nimport org.jclouds.compute.domain.NodeMetadataBuilder;\nimport org.jclouds.compute.domain.Processor;\nimport org.jclouds.compute.functions.GroupNamingConvention;\nimport org.jclouds.domain.Location;\nimport org.jclouds.googlecomputeengine.domain.Image;\nimport org.jclouds.googlecomputeengine.domain.Instance;\n\nimport javax.inject.Inject;\nimport java.net.URI;\nimport java.util.List;\nimport java.util.Map;\n\nimport static org.jclouds.compute.util.ComputeServiceUtils.groupFromMapOrName;\n\n<fim_suffix>public final class InstanceToNodeMetadata implements Function<Instance, NodeMetadata> {\n\n   private final Map<Instance.Status, NodeMetadata.Status> toPortableNodeStatus;\n   private final GroupNamingConvention nodeNamingConvention;\n   private final LoadingCache<URI, Optional<Image>> diskURIToImage;\n   private final Supplier<Map<URI, Hardware>> hardwares;\n   private final Supplier<Map<URI, Location>> locationsByUri;\n\n   @Inject InstanceToNodeMetadata(Map<Instance.Status, NodeMetadata.Status> toPortableNodeStatus,\n                                  GroupNamingConvention.Factory namingConvention,\n                                  LoadingCache<URI, Optional<Image>> diskURIToImage,\n                                  @Memoized Supplier<Map<URI, Hardware>> hardwares,\n                                  @Memoized Supplier<Map<URI, Location>> locationsByUri) {\n      this.toPortableNodeStatus = toPortableNodeStatus;\n      this.nodeNamingConvention = namingConvention.createWithoutPrefix();\n      this.diskURIToImage = diskURIToImage;\n      this.hardwares = hardwares;\n      this.locationsByUri = locationsByUri;\n   }\n\n   @Override public NodeMetadata apply(Instance input) {\n      String group = groupFromMapOrName(input.metadata().asMap(), input.name(), nodeNamingConvention);\n      NodeMetadataBuilder builder = new NodeMetadataBuilder();\n\n      Location zone = locationsByUri.get().get(input.zone());\n      if (zone == null) {\n         throw new IllegalStateException(\n               String.format(\"zone %s not present in %s\", input.zone(), locationsByUri.get().keySet()));\n      }\n\n      // The boot disk is the first disk. It may have been created from an image, so look it up.\n      //\n      // Note: This will be present if we created the node. In the future we could choose to make diskToSourceImage\n      // a loading cache. That would be more expensive, but could ensure this isn't null.\n\n      URI diskSource = input.disks().get(0).source();\n      Optional<Image> image = diskURIToImage.getUnchecked(diskSource);\n\n      Hardware hardware;\n      if (isCustomMachineTypeURI(input.machineType())) {\n         hardware = machineTypeURIToCustomHardware(input.machineType());\n      }\n      else {\n         hardware = hardwares.get().get(input.machineType());\n      }\n\n      builder.id(input.selfLink().toString())\n             .name(input.name())\n             .providerId(input.id())\n             .hostname(input.name())\n             .location(zone)\n             .imageId(image.isPresent() ? image.get().selfLink().toString() : null)\n             .hardware(hardware)\n             .status(input.status() != null ? toPortableNodeStatus.get(input.status()) : Status.UNRECOGNIZED)\n             .tags(input.tags().items())\n             .uri(input.selfLink())\n             .userMetadata(input.metadata().asMap())\n             .group(group)\n             .privateAddresses(collectPrivateAddresses(input))\n             .publicAddresses(collectPublicAddresses(input));\n      return builder.build();\n   }\n\n   private List<String> collectPrivateAddresses(Instance input) {\n      ImmutableList.Builder<String> privateAddressesBuilder = ImmutableList.builder();\n      for (Instance.NetworkInterface networkInterface : input.networkInterfaces()) {\n         if (networkInterface.networkIP() != null) {\n            privateAddressesBuilder.add(networkInterface.networkIP());\n         }\n      }\n      return privateAddressesBuilder.build();\n   }\n\n   private List<String> collectPublicAddresses(Instance input) {\n      ImmutableList.Builder<String> publicAddressesBuilder = ImmutableList.builder();\n      for (Instance.NetworkInterface networkInterface : input.networkInterfaces()) {\n         for (Instance.NetworkInterface.AccessConfig accessConfig : networkInterface.accessConfigs()) {\n            if (accessConfig.natIP() != null) {\n               publicAddressesBuilder.add(accessConfig.natIP());\n            }\n         }\n      }\n      return publicAddressesBuilder.build();\n   }\n\n   public static boolean isCustomMachineTypeURI(URI machineType) {\n      return machineType.toString().contains(\"machineTypes/custom\");\n   }\n\n   public static Hardware machineTypeURIToCustomHardware(URI machineType) {\n      String uri = machineType.toString();\n      String values = uri.substring(uri.lastIndexOf('/') + 8);\n      List<String> hardwareValues = Splitter.on('-')\n            .trimResults()\n            .splitToList(values);\n      return new HardwareBuilder()\n            .id(uri)\n            .providerId(uri)\n            .processor(new Processor(Double.parseDouble(hardwareValues.get(0)), 1.0))\n            .ram(Integer.parseInt(hardwareValues.get(1)))\n            .uri(machineType)\n            .build();\n   }\n}<fim_middle>// class below has no smell\n"}