{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.drill.exec.vector.complex.fn;\nimport io.netty.buffer.DrillBuf;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.List;\nimport org.apache.drill.common.exceptions.UserException;\nimport org.apache.drill.common.expression.SchemaPath;\nimport org.apache.drill.exec.physical.base.GroupScan;\nimport org.apache.drill.exec.store.easy.json.reader.BaseJsonProcessor;\nimport org.apache.drill.exec.vector.complex.fn.VectorOutput.ListVectorOutput;\nimport org.apache.drill.exec.vector.complex.fn.VectorOutput.MapVectorOutput;\nimport org.apache.drill.exec.vector.complex.writer.BaseWriter.ComplexWriter;\nimport org.apache.drill.exec.vector.complex.writer.BaseWriter.ListWriter;\nimport org.apache.drill.exec.vector.complex.writer.BaseWriter.MapWriter;\nimport com.fasterxml.jackson.core.JsonParser;\nimport com.fasterxml.jackson.core.JsonToken;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport org.apache.drill.shaded.guava.com.google.common.base.Charsets;\nimport org.apache.drill.shaded.guava.com.google.common.base.Preconditions;\nimport org.apache.drill.shaded.guava.com.google.common.collect.Lists;\npublic class JsonReader extends BaseJsonProcessor {\n  private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory\n      .getLogger(JsonReader.class);\n  public final static int MAX_RECORD_SIZE = 128 * 1024;\n  private final WorkingBuffer workingBuffer;\n  private final List<SchemaPath> columns;\n  private final boolean allTextMode;\n  private final MapVectorOutput mapOutput;\n  private final ListVectorOutput listOutput;\n  private final boolean extended = true;\n  private final boolean readNumbersAsDouble;\n  /**\n   * Collection for tracking empty array writers during reading\n   * and storing them for initializing empty arrays\n   */\n  private final List<ListWriter> emptyArrayWriters = Lists.newArrayList();\n  /**\n   * Describes whether or not this reader can unwrap a single root array record\n   * and treat it like a set of distinct records.\n   */\n  private final boolean skipOuterList;\n  /**\n   * Whether the reader is currently in a situation where we are unwrapping an\n   * outer list.\n   */\n  private boolean inOuterList;\n  private FieldSelection selection;\n  private JsonReader(Builder builder) {\n    super(builder.managedBuf, builder.enableNanInf, builder.enableEscapeAnyChar);\n    selection = FieldSelection.getFieldSelection(builder.columns);\n    workingBuffer = builder.workingBuffer;\n    skipOuterList = builder.skipOuterList;\n    allTextMode = builder.allTextMode;\n    columns = builder.columns;\n    mapOutput = builder.mapOutput;\n    listOutput = builder.listOutput;\n    currentFieldName = builder.currentFieldName;\n    readNumbersAsDouble = builder.readNumbersAsDouble;\n  }\n  public static class Builder {\n    private  DrillBuf managedBuf;\n    private  WorkingBuffer workingBuffer;\n    private  List<SchemaPath> columns;\n    private  MapVectorOutput mapOutput;\n    private  ListVectorOutput listOutput;\n    private  String currentFieldName = \"<none>\";\n    private  boolean readNumbersAsDouble;\n    private  boolean skipOuterList;\n    private  boolean allTextMode;\n    private  boolean enableNanInf;\n    private  boolean enableEscapeAnyChar;\n    public Builder(DrillBuf managedBuf) {\n      this.managedBuf = managedBuf;\n      this.workingBuffer = new WorkingBuffer(managedBuf);\n      this.mapOutput = new MapVectorOutput(workingBuffer);\n      this.listOutput = new ListVectorOutput(workingBuffer);\n      this.enableNanInf = true;\n    }\n    public Builder readNumbersAsDouble(boolean readNumbersAsDouble) {\n      this.readNumbersAsDouble = readNumbersAsDouble;\n      return this;\n    }\n    public Builder skipOuterList(boolean skipOuterList) {\n      this.skipOuterList = skipOuterList;\n      return this;\n    }\n    public Builder allTextMode(boolean allTextMode) {\n      this.allTextMode = allTextMode;\n      return this;\n    }\n    public Builder enableNanInf(boolean enableNanInf) {\n      this.enableNanInf = enableNanInf;\n      return this;\n    }\n    public Builder enableEscapeAnyChar(boolean enableEscapeAnyChar) {\n      this.enableEscapeAnyChar = enableEscapeAnyChar;\n      return this;\n    }\n<fim_suffix>    public Builder defaultSchemaPathColumns() {\n      this.columns = GroupScan.ALL_COLUMNS;\n      return this;\n    }\n    public Builder schemaPathColumns(List<SchemaPath> columns) {\n      this.columns = columns;\n      return this;\n    }\n    public JsonReader build() {\n      if (columns == null) {\n        throw new IllegalStateException(\"You need to set SchemaPath columns in order to build JsonReader\");\n      }\n      assert Preconditions.checkNotNull(columns).size() > 0 : \"JSON record reader requires at least one column\";\n      return new JsonReader(this);\n    }\n  }\n  @SuppressWarnings(\"resource\")\n  @Override\n  public void ensureAtLeastOneField(ComplexWriter writer) {\n    JsonReaderUtils.ensureAtLeastOneField(writer, columns, allTextMode, emptyArrayWriters);\n  }\n  public void setSource(int start, int end, DrillBuf buf) throws IOException {\n    setSource(DrillBufInputStream.getStream(start, end, buf));\n  }\n  @Override\n  public void setSource(InputStream is) throws IOException {\n    super.setSource(is);\n    mapOutput.setParser(parser);\n    listOutput.setParser(parser);\n  }\n  @Override\n  public void setSource(JsonNode node) {\n    super.setSource(node);\n    mapOutput.setParser(parser);\n    listOutput.setParser(parser);\n  }\n  public void setSource(String data) throws IOException {\n    setSource(data.getBytes(Charsets.UTF_8));\n  }\n  @SuppressWarnings(\"resource\")\n  public void setSource(byte[] bytes) throws IOException {\n    setSource(new SeekableBAIS(bytes));\n  }\n  @Override\n  public ReadState write(ComplexWriter writer) throws IOException {\n    ReadState readState = null;\n    try {\n      JsonToken t = lastSeenJsonToken;\n      if (t == null || t == JsonToken.END_OBJECT) {\n        t = parser.nextToken();\n      }\n      while (!parser.hasCurrentToken() && !parser.isClosed()) {\n        t = parser.nextToken();\n      }\n      lastSeenJsonToken = null;\n      if (parser.isClosed()) {\n        return ReadState.END_OF_STREAM;\n      }\n      readState = writeToVector(writer, t);\n      switch (readState) {\n      case END_OF_STREAM:\n        break;\n      case WRITE_SUCCEED:\n        break;\n      default:\n        throw getExceptionWithContext(UserException.dataReadError(), null).message(\n            \"Failure while reading JSON. (Got an invalid read state %s )\", readState.toString())\n            .build(logger);\n      }\n    } catch (com.fasterxml.jackson.core.JsonParseException ex) {\n      if (ignoreJSONParseError()) {\n        if (processJSONException() == JsonExceptionProcessingState.END_OF_STREAM) {\n          return ReadState.JSON_RECORD_PARSE_EOF_ERROR;\n        } else {\n          return ReadState.JSON_RECORD_PARSE_ERROR;\n        }\n      } else {\n        throw ex;\n      }\n    }\n    return readState;\n  }\n  private void confirmLast() throws IOException {\n    parser.nextToken();\n    if (!parser.isClosed()) {\n      String message = \"Drill attempted to unwrap a toplevel list in your document. \"\n          + \"However, it appears that there is trailing content after this top level list.  Drill only \"\n          + \"supports querying a set of distinct maps or a single json array with multiple inner maps.\";\n      throw getExceptionWithContext(UserException.dataReadError(), message).build(logger);\n    }\n  }\n  private ReadState writeToVector(ComplexWriter writer, JsonToken t)\n      throws IOException {\n    switch (t) {\n    case START_OBJECT:<fim_middle>// function below has no smell\n"}