{"text": "<fim_prefix>   * Converts CharSequence to Text and creates a Key using {@link #Key(Text,Text,Text,Text)}.\n   *\n   * @see #builder()\n   */\n  public Key(CharSequence row, CharSequence cf, CharSequence cq, CharSequence cv) {\n    this(new Text(row.toString()), new Text(cf.toString()), new Text(cq.toString()),\n        new Text(cv.toString()));\n  }\n  /**\n   * Converts CharSequence to Text and creates a Key using {@link #Key(Text,Text,Text,long)}.\n   *\n   * @see #builder()\n   */\n  public Key(CharSequence row, CharSequence cf, CharSequence cq, long ts) {\n    this(new Text(row.toString()), new Text(cf.toString()), new Text(cq.toString()), ts);\n  }\n  /**\n   * Converts CharSequence to Text and creates a Key using {@link #Key(Text,Text,Text,Text,long)}.\n   *\n   * @see #builder()\n   */\n  public Key(CharSequence row, CharSequence cf, CharSequence cq, CharSequence cv, long ts) {\n    this(new Text(row.toString()), new Text(cf.toString()), new Text(cq.toString()),\n        new Text(cv.toString()), ts);\n  }\n  /**\n   * Converts CharSequence to Text and creates a Key using\n   * {@link #Key(Text,Text,Text,ColumnVisibility,long)}.\n   *\n   * @see #builder()\n   */\n  public Key(CharSequence row, CharSequence cf, CharSequence cq, ColumnVisibility cv, long ts) {\n    this(new Text(row.toString()), new Text(cf.toString()), new Text(cq.toString()),\n        new Text(cv.getExpression()), ts);\n  }\n  private byte[] followingArray(byte[] ba) {\n    byte[] fba = new byte[ba.length + 1];\n    System.arraycopy(ba, 0, fba, 0, ba.length);\n    fba[ba.length] = (byte) 0x00;\n    return fba;\n  }\n  /**\n   * Returns a key that will sort immediately after this key.\n   *\n   * @param part\n   *          PartialKey except {@link PartialKey#ROW_COLFAM_COLQUAL_COLVIS_TIME_DEL}\n   */\n  public Key followingKey(PartialKey part) {\n    Key returnKey = new Key();\n    switch (part) {\n      case ROW:\n        returnKey.row = followingArray(row);\n        break;\n      case ROW_COLFAM:\n        returnKey.row = row;\n        returnKey.colFamily = followingArray(colFamily);\n        break;\n      case ROW_COLFAM_COLQUAL:\n        returnKey.row = row;\n        returnKey.colFamily = colFamily;\n        returnKey.colQualifier = followingArray(colQualifier);\n        break;\n      case ROW_COLFAM_COLQUAL_COLVIS:\n        // This isn't useful for inserting into accumulo, but may be useful for lookups.\n        returnKey.row = row;\n        returnKey.colFamily = colFamily;\n        returnKey.colQualifier = colQualifier;\n        returnKey.colVisibility = followingArray(colVisibility);\n        break;\n      case ROW_COLFAM_COLQUAL_COLVIS_TIME:\n        returnKey.row = row;\n        returnKey.colFamily = colFamily;\n        returnKey.colQualifier = colQualifier;\n        returnKey.colVisibility = colVisibility;\n        returnKey.setTimestamp(timestamp - 1);\n        returnKey.deleted = false;\n        break;\n      default:\n        throw new IllegalArgumentException(\"Partial key specification \" + part + \" disallowed\");\n    }\n    return returnKey;\n  }\n  /**\n   * Creates a key with the same row, column family, column qualifier, column visibility, timestamp,\n   * and delete marker as the given key.\n   */\n  public Key(Key other) {\n    set(other);\n  }\n  /**\n   * Creates a key from Thrift.\n   *\n   * @param tkey\n   *          Thrift key\n   */\n  public Key(TKey tkey) {\n    this.row = toBytes(tkey.row);\n    this.colFamily = toBytes(tkey.colFamily);\n    this.colQualifier = toBytes(tkey.colQualifier);\n    this.colVisibility = toBytes(tkey.colVisibility);\n    this.timestamp = tkey.timestamp;\n    this.deleted = false;\n    if (row == null) {\n      throw new IllegalArgumentException(\"null row\");\n    }\n    if (colFamily == null) {\n      throw new IllegalArgumentException(\"null column family\");\n    }\n    if (colQualifier == null) {\n      throw new IllegalArgumentException(\"null column qualifier\");\n    }\n    if (colVisibility == null) {\n      throw new IllegalArgumentException(\"null column visibility\");\n    }\n  }\n  /**\n   * Writes the row ID into the given <code>Text</code>. This method gives users control over\n   * allocation of Text objects by copying into the passed in text.\n   *\n   * @param r\n   *          <code>Text</code> object to copy into\n   * @return the <code>Text</code> that was passed in\n   */\n  public Text getRow(Text r) {\n    r.set(row, 0, row.length);\n    return r;\n  }\n  /**\n   * Returns the row ID as a byte sequence. This method returns a pointer to the key's internal data\n   * and does not copy it.\n   *\n   * @return ByteSequence that points to the internal key row ID data\n   */\n  public ByteSequence getRowData() {\n    return new ArrayByteSequence(row);\n  }\n  /**\n   * Gets the row ID as a <code>Text</code> object.\n   *\n   * @return Text containing the row ID\n   */\n  public Text getRow() {\n    return getRow(new Text());\n  }\n  /**\n   * Compares this key's row ID with another.\n   *\n   * @param r\n   *          row ID to compare\n   * @return same as {@link #getRow()}.compareTo(r)\n   */\n  public int compareRow(Text r) {\n    return WritableComparator.compareBytes(row, 0, row.length, r.getBytes(), 0, r.getLength());\n  }\n  /**\n   * Returns the column family as a byte sequence. This method returns a pointer to the key's\n   * internal data and does not copy it.\n   *\n   * @return ByteSequence that points to the internal key column family data\n   */\n  public ByteSequence getColumnFamilyData() {\n    return new ArrayByteSequence(colFamily);\n  }\n  /**\n   * Writes the column family into the given <code>Text</code>. This method gives users control over\n   * allocation of Text objects by copying into the passed in text.\n   *\n   * @param cf\n   *          <code>Text</code> object to copy into\n   * @return the <code>Text</code> that was passed in\n   */\n  public Text getColumnFamily(Text cf) {\n    cf.set(colFamily, 0, colFamily.length);\n    return cf;\n  }\n  /**\n   * Gets the column family as a <code>Text</code> object.\n   *\n   * @return Text containing the column family\n   */\n  public Text getColumnFamily() {\n    return getColumnFamily(new Text());\n  }\n  /**\n   * Compares this key's column family with another.\n   *\n   * @param cf\n   *          column family to compare\n   * @return same as {@link #getColumnFamily()}.compareTo(cf)\n   */\n  public int compareColumnFamily(Text cf) {\n    return WritableComparator.compareBytes(colFamily, 0, colFamily.length, cf.getBytes(), 0,\n        cf.getLength());\n  }\n  /**\n   * Returns the column qualifier as a byte sequence. This method returns a pointer to the key's\n   * internal data and does not copy it.\n   *\n   * @return ByteSequence that points to the internal key column qualifier data\n   */\n  public ByteSequence getColumnQualifierData() {\n    return new ArrayByteSequence(colQualifier);\n  }\n  /**\n   * Writes the column qualifier into the given <code>Text</code>. This method gives users control\n   * over allocation of Text objects by copying into the passed in text.\n   *\n   * @param cq\n   *          <code>Text</code> object to copy into\n   * @return the <code>Text</code> that was passed in\n   */\n  public Text getColumnQualifier(Text cq) {\n    cq.set(colQualifier, 0, colQualifier.length);\n    return cq;\n  }\n  /**\n   * Gets the column qualifier as a <code>Text</code> object.\n   *\n   * @return Text containing the column qualifier\n   */\n  public Text getColumnQualifier() {\n    return getColumnQualifier(new Text());\n  }\n  /**\n   * Compares this key's column qualifier with another.\n   *\n   * @param cq\n   *          column qualifier to compare\n   * @return same as {@link #getColumnQualifier()}.compareTo(cq)\n   */\n<fim_suffix>  public int compareColumnQualifier(Text cq) {\n    return WritableComparator.compareBytes(colQualifier, 0, colQualifier.length, cq.getBytes(), 0,\n        cq.getLength());\n  }<fim_middle>// function below has no smell\n"}