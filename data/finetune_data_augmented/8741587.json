{"text": "<fim_prefix>      INodeDirectory parent) throws IOException {\n    // the INode in the created list should be a reference to another INode\n    // in posterior SnapshotDiffs or one of the current children\n    for (DirectoryDiff postDiff : parent.getDiffs()) {\n      final INode d = postDiff.getChildrenDiff().search(ListType.DELETED,\n          createdNodeName);\n      if (d != null) {\n        return d;\n      } // else go to the next SnapshotDiff\n    } \n    // use the current child\n    INode currentChild = parent.getChild(createdNodeName,\n        Snapshot.CURRENT_STATE_ID);\n    if (currentChild == null) {\n      throw new IOException(\"Cannot find an INode associated with the INode \"\n          + DFSUtil.bytes2String(createdNodeName)\n          + \" in created list while loading FSImage.\");\n    }\n    return currentChild;\n  }\n  /**\n   * Load the created list from fsimage.\n   * @param parent The directory that the created list belongs to.\n   * @param in The {@link DataInput} to read.\n   * @return The created list.\n   */\n  private static List<INode> loadCreatedList(INodeDirectory parent,\n      DataInput in) throws IOException {\n    // read the size of the created list\n    int createdSize = in.readInt();\n    List<INode> createdList = new ArrayList<INode>(createdSize);\n    for (int i = 0; i < createdSize; i++) {\n      byte[] createdNodeName = FSImageSerialization.readLocalName(in);\n      INode created = loadCreated(createdNodeName, parent);\n      createdList.add(created);\n    }\n    return createdList;\n  }\n  /**\n   * Load the deleted list from the fsimage.\n   * \n   * @param parent The directory that the deleted list belongs to.\n   * @param createdList The created list associated with the deleted list in \n   *                    the same Diff.\n   * @param in The {@link DataInput} to read.\n   * @param loader The {@link Loader} instance.\n   * @return The deleted list.\n   */\n  private static List<INode> loadDeletedList(INodeDirectory parent,\n      List<INode> createdList, DataInput in, FSImageFormat.Loader loader)\n      throws IOException {\n    int deletedSize = in.readInt();\n    List<INode> deletedList = new ArrayList<INode>(deletedSize);\n    for (int i = 0; i < deletedSize; i++) {\n      final INode deleted = loader.loadINodeWithLocalName(true, in, true);\n      deletedList.add(deleted);\n      // set parent: the parent field of an INode in the deleted list is not \n      // useful, but set the parent here to be consistent with the original \n      // fsdir tree.\n      deleted.setParent(parent);\n      if (deleted.isFile()) {\n        loader.updateBlocksMap(deleted.asFile());\n      }\n    }\n    return deletedList;\n  }\n  /**\n   * Load snapshots and snapshotQuota for a Snapshottable directory.\n   *\n   * @param snapshottableParent\n   *          The snapshottable directory for loading.\n   * @param numSnapshots\n   *          The number of snapshots that the directory has.\n   * @param loader\n   *          The loader\n   */\n  public static void loadSnapshotList(INodeDirectory snapshottableParent,\n      int numSnapshots, DataInput in, FSImageFormat.Loader loader)\n      throws IOException {\n    DirectorySnapshottableFeature sf = snapshottableParent\n        .getDirectorySnapshottableFeature();\n    Preconditions.checkArgument(sf != null);\n    for (int i = 0; i < numSnapshots; i++) {\n      // read snapshots\n      final Snapshot s = loader.getSnapshot(in);\n      s.getRoot().setParent(snapshottableParent);\n      sf.addSnapshot(s);\n    }\n    int snapshotQuota = in.readInt();\n    snapshottableParent.setSnapshotQuota(snapshotQuota);\n  }\n  /**\n   * Load the {@link SnapshotDiff} list for the INodeDirectoryWithSnapshot\n   * directory.\n   *\n   * @param dir\n   *          The snapshottable directory for loading.\n   * @param in\n   *          The {@link DataInput} instance to read.\n   * @param loader\n   *          The loader\n   */\n  public static void loadDirectoryDiffList(INodeDirectory dir,\n      DataInput in, FSImageFormat.Loader loader) throws IOException {\n    final int size = in.readInt();\n    if (dir.isWithSnapshot()) {\n      DirectoryDiffList diffs = dir.getDiffs();\n      for (int i = 0; i < size; i++) {\n        diffs.addFirst(loadDirectoryDiff(dir, in, loader));\n      }\n    }\n  }\n  /**\n   * Load the snapshotINode field of {@link AbstractINodeDiff}.\n   * @param snapshot The Snapshot associated with the {@link AbstractINodeDiff}.\n   * @param in The {@link DataInput} to read.\n   * @param loader The {@link Loader} instance that this loading procedure is\n   *               using.\n   * @return The snapshotINode.\n   */\n  private static INodeDirectoryAttributes loadSnapshotINodeInDirectoryDiff(\n      Snapshot snapshot, DataInput in, FSImageFormat.Loader loader)\n      throws IOException {\n    // read the boolean indicating whether snapshotINode == Snapshot.Root\n    boolean useRoot = in.readBoolean();      \n    if (useRoot) {\n      return snapshot.getRoot();\n    } else {\n      // another boolean is used to indicate whether snapshotINode is non-null\n      return in.readBoolean()? loader.loadINodeDirectoryAttributes(in): null;\n    }\n  }\n  /**\n   * Load {@link DirectoryDiff} from fsimage.\n   * @param parent The directory that the SnapshotDiff belongs to.\n   * @param in The {@link DataInput} instance to read.\n   * @param loader The {@link Loader} instance that this loading procedure is \n   *               using.\n   * @return A {@link DirectoryDiff}.\n   */\n  private static DirectoryDiff loadDirectoryDiff(INodeDirectory parent,\n      DataInput in, FSImageFormat.Loader loader) throws IOException {\n    // 1. Read the full path of the Snapshot root to identify the Snapshot\n    final Snapshot snapshot = loader.getSnapshot(in);\n    // 2. Load DirectoryDiff#childrenSize\n    int childrenSize = in.readInt();\n    // 3. Load DirectoryDiff#snapshotINode \n    INodeDirectoryAttributes snapshotINode = loadSnapshotINodeInDirectoryDiff(\n        snapshot, in, loader);\n    // 4. Load the created list in SnapshotDiff#Diff\n    List<INode> createdList = loadCreatedList(parent, in);\n    // 5. Load the deleted list in SnapshotDiff#Diff\n    List<INode> deletedList = loadDeletedList(parent, createdList, in, loader);\n    // 6. Compose the SnapshotDiff\n    List<DirectoryDiff> diffs = parent.getDiffs().asList();\n    DirectoryDiff sdiff = new DirectoryDiff(snapshot.getId(), snapshotINode,\n        diffs.isEmpty() ? null : diffs.get(0), childrenSize, createdList,\n        deletedList, snapshotINode == snapshot.getRoot());\n    return sdiff;\n  }\n  /** A reference map for fsimage serialization. */\n<fim_suffix>  public static class ReferenceMap {\n    /**\n     * Used to indicate whether the reference node itself has been saved\n     */\n    private final Map<Long, INodeReference.WithCount> referenceMap\n        = new HashMap<Long, INodeReference.WithCount>();\n    /**\n     * Used to record whether the subtree of the reference node has been saved \n     */\n    private final Map<Long, Long> dirMap = new HashMap<Long, Long>();\n    public void writeINodeReferenceWithCount(\n        INodeReference.WithCount withCount, DataOutput out,\n        boolean writeUnderConstruction) throws IOException {\n      final INode referred = withCount.getReferredINode();\n      final long id = withCount.getId();\n      final boolean firstReferred = !referenceMap.containsKey(id);\n      out.writeBoolean(firstReferred);\n      if (firstReferred) {\n        FSImageSerialization.saveINode2Image(referred, out,\n            writeUnderConstruction, this);\n        referenceMap.put(id, withCount);\n      } else {\n        out.writeLong(id);\n      }\n    }\n    public boolean toProcessSubtree(long id) {\n      if (dirMap.containsKey(id)) {\n        return false;\n      } else {\n        dirMap.put(id, id);\n        return true;\n      }\n    }\n    public INodeReference.WithCount loadINodeReferenceWithCount(\n        boolean isSnapshotINode, DataInput in, FSImageFormat.Loader loader\n        ) throws IOException {\n      final boolean firstReferred = in.readBoolean();\n      final INodeReference.WithCount withCount;\n      if (firstReferred) {\n        final INode referred = loader.loadINodeWithLocalName(isSnapshotINode,\n            in, true);\n        withCount = new INodeReference.WithCount(null, referred);\n        referenceMap.put(withCount.getId(), withCount);\n      } else {\n        final long id = in.readLong();\n        withCount = referenceMap.get(id);\n      }\n      return withCount;\n    }\n  }<fim_middle>// class below has no smell\n"}