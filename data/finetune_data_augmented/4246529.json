{"text": "<fim_prefix>package org.apache.commons.jcs.auxiliary.disk.jdbc.mysql;\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport java.sql.Connection;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport javax.sql.DataSource;\nimport org.apache.commons.jcs.auxiliary.disk.jdbc.TableState;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n/**\n * The MySQL Table Optimizer can optimize MySQL tables. It knows how to optimize for MySQL databases\n * in particular and how to repair the table if it is corrupted in the process.\n * <p>\n * We will probably be able to abstract out a generic optimizer interface from this class in the\n * future.\n * <p>\n * @author Aaron Smuts\n */\npublic class MySQLTableOptimizer\n{\n    /** The logger */\n    private static final Log log = LogFactory.getLog( MySQLTableOptimizer.class );\n    /** The data source */\n    private DataSource dataSource = null;\n    /** The name of the table. */\n    private String tableName = null;\n    /** optimizing, etc. */\n    private TableState tableState;\n    /**\n     * This constructs an optimizer with the disk cacn properties.\n     * <p>\n     * @param attributes\n     * @param tableState We mark the table status as optimizing when this is happening.\n     * @param dataSource access to the database\n     */\n    public MySQLTableOptimizer( MySQLDiskCacheAttributes attributes, TableState tableState, DataSource dataSource )\n    {\n        setTableName( attributes.getTableName() );\n        this.tableState = tableState;\n        this.dataSource = dataSource;\n    }\n    /**\n     * A scheduler will call this method. When it is called the table state is marked as optimizing.\n     * TODO we need to verify that no deletions are running before we call optimize. We should wait\n     * if a deletion is in progress.\n     * <p>\n     * This restores when there is an optimization error. The error output looks like this:\n     *\n     * <pre>\n     *           mysql&gt; optimize table JCS_STORE_FLIGHT_OPTION_ITINERARY;\n     *               +---------------------------------------------+----------+----------+---------------------+\n     *               | Table                                       | Op       | Msg_type | Msg_text            |\n     *               +---------------------------------------------+----------+----------+---------------------+\n     *               | jcs_cache.JCS_STORE_FLIGHT_OPTION_ITINERARY | optimize | error    | 2 when fixing table |\n     *               | jcs_cache.JCS_STORE_FLIGHT_OPTION_ITINERARY | optimize | status   | Operation failed    |\n     *               +---------------------------------------------+----------+----------+---------------------+\n     *               2 rows in set (51.78 sec)\n     * </pre>\n     *\n     * A successful repair response looks like this:\n     *\n     * <pre>\n     *        mysql&gt; REPAIR TABLE JCS_STORE_FLIGHT_OPTION_ITINERARY;\n     *            +---------------------------------------------+--------+----------+----------------------------------------------+\n     *            | Table                                       | Op     | Msg_type | Msg_text                                     |\n     *            +---------------------------------------------+--------+----------+----------------------------------------------+\n     *            | jcs_cache.JCS_STORE_FLIGHT_OPTION_ITINERARY | repair | error    | 2 when fixing table                          |\n     *            | jcs_cache.JCS_STORE_FLIGHT_OPTION_ITINERARY | repair | warning  | Number of rows changed from 131276 to 260461 |\n     *            | jcs_cache.JCS_STORE_FLIGHT_OPTION_ITINERARY | repair | status   | OK                                           |\n     *            +---------------------------------------------+--------+----------+----------------------------------------------+\n     *            3 rows in set (3 min 5.94 sec)\n     * </pre>\n     *\n     * A successful optimization looks like this:\n     *\n     * <pre>\n     *       mysql&gt; optimize table JCS_STORE_DEFAULT;\n     *           +-----------------------------+----------+----------+----------+\n     *           | Table                       | Op       | Msg_type | Msg_text |\n     *           +-----------------------------+----------+----------+----------+\n     *           | jcs_cache.JCS_STORE_DEFAULT | optimize | status   | OK       |\n     *           +-----------------------------+----------+----------+----------+\n     *           1 row in set (1.10 sec)\n     * </pre>\n     * @return true if it worked\n     */\n    public boolean optimizeTable()\n    {\n        long start = System.currentTimeMillis();\n        boolean success = false;\n        if ( tableState.getState() == TableState.OPTIMIZATION_RUNNING )\n        {\n            log\n                .warn( \"Skipping optimization.  Optimize was called, but the table state indicates that an optimization is currently running.\" );\n            return false;\n        }\n        try\n        {\n            tableState.setState( TableState.OPTIMIZATION_RUNNING );\n            if ( log.isInfoEnabled() )\n            {\n                log.info( \"Optimizing table [\" + this.getTableName() + \"]\" );\n            }\n            try (Connection con = dataSource.getConnection())\n            {\n                // TEST\n                try (Statement sStatement = con.createStatement())\n                {\n                    ResultSet rs = sStatement.executeQuery( \"optimize table \" + this.getTableName() );\n                    // first row is error, then status\n                    // if there is only one row in the result set, everything\n                    // should be fine.\n                    // This may be mysql version specific.\n                    if ( rs.next() )\n                    {\n                        String status = rs.getString( \"Msg_type\" );\n                        String message = rs.getString( \"Msg_text\" );\n                        if ( log.isInfoEnabled() )\n                        {\n                            log.info( \"Message Type: \" + status );\n                            log.info( \"Message: \" + message );\n                        }\n                        if ( \"error\".equals( status ) )\n                        {\n                            log.warn( \"Optimization was in error. Will attempt to repair the table. Message: \"\n                                + message );\n                            // try to repair the table.\n                            success = repairTable( sStatement );\n                        }\n                        else\n                        {\n                            success = true;\n                        }\n                    }\n                    // log the table status\n                    String statusString = getTableStatus( sStatement );\n                    if ( log.isInfoEnabled() )\n                    {\n                        log.info( \"Table status after optimizing table [\" + this.getTableName() + \"]\\n\" + statusString );\n                    }\n                }\n                catch ( SQLException e )\n                {\n                    log.error( \"Problem optimizing table [\" + this.getTableName() + \"]\", e );\n                    return false;\n                }\n            }\n            catch ( SQLException e )\n            {\n                log.error( \"Problem getting connection.\", e );\n            }\n        }\n        finally\n        {\n            tableState.setState( TableState.FREE );\n            long end = System.currentTimeMillis();\n            if ( log.isInfoEnabled() )\n            {\n                log.info( \"Optimization of table [\" + this.getTableName() + \"] took \" + ( end - start ) + \" ms.\" );\n            }\n        }\n        return success;\n    }\n    /**\n     * This calls show table status and returns the result as a String.\n     * <p>\n     * @param sStatement\n     * @return String\n     * @throws SQLException\n     */\n<fim_suffix>    protected String getTableStatus( Statement sStatement )\n        throws SQLException\n    {\n        ResultSet statusResultSet = sStatement.executeQuery( \"show table status\" );\n        StringBuilder statusString = new StringBuilder();\n        int numColumns = statusResultSet.getMetaData().getColumnCount();\n        while ( statusResultSet.next() )\n        {\n            statusString.append( \"\\n\" );\n            for ( int i = 1; i <= numColumns; i++ )\n            {\n                statusString.append( statusResultSet.getMetaData().getColumnLabel( i ) + \" [\"\n                    + statusResultSet.getString( i ) + \"]  |  \" );\n            }\n        }\n        return statusString.toString();\n    }\n    /**\n     * This is called if the optimization is in error.\n     * <p>\n     * It looks for \"OK\" in response. If it find \"OK\" as a message in any result set row, it returns\n     * true. Otherwise we assume that the repair failed.\n     * <p>\n     * @param sStatement\n     * @return true if successful\n     * @throws SQLException\n     */\n    protected boolean repairTable( Statement sStatement )\n        throws SQLException\n    {\n        boolean success = false;<fim_middle>// function below has no smell\n"}