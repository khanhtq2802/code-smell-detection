{"text": "<fim_prefix>\n<fim_suffix>public class CASMgrSerializer implements Serializable {\n  // Constants to do different things depending on source (like name mapping).\n  public static final int SOURCE_JEDI = 0;\n  public static final int SOURCE_TAF = 1;\n  static final long serialVersionUID = 5549299679614131956L;\n  // Implementation note: when making changes, keep in mind that numbering of\n  // types and features starts at 1, not 0. This makes book-keeping in the\n  // various arrays a bit tricky at times.\n  // ///////////////////////////////////////////////////////////////////////////\n  // Encoding of index repository. Inherited index specifications are not\n  // encoded explicitly. I.e., the fact that tokens are in any index that\n  // annotations are in is implicit.\n  public int[] typeOrder = null;\n  /**\n   * The index identifiers. Note that more than one identifier can refer to the same index.\n   */\n  public String[] indexNames;\n  /**\n   * A mapping from index names to index IDs. We have that\n   * <code>indexNames.length == nameToIndexMap.length</code> and for each <code>i</code> in\n   * <code>nameToIndexMap</code>, <code>0 &lt;= i &lt;\n   * indexTypes.length</code>.\n   */\n  public int[] nameToIndexMap;\n  /**\n   * For each index, the type of that index (encoded as a reference into the type table).\n   */\n  // public int[] indexTypes;\n  /**\n   * For each index, the indexing strategy of that index. Current options are\n   * {@link org.apache.uima.cas.FSIndex#SORTED_INDEX SORTED_INDEX},\n   * {@link org.apache.uima.cas.FSIndex#SET_INDEX SET_INDEX} and\n   * {@link org.apache.uima.cas.FSIndex#BAG_INDEX BAG_INDEX}.\n   * <code>indexingStrategy.length == indexTypes.length</code>.\n   */\n  public int[] indexingStrategy;\n  /**\n   * For each index, where the corresponding comparator starts in the\n   * {@link #comparators comparators} field.\n   * <code>comparatorIndex.length == indexTypes.length</code>.\n   */\n  public int[] comparatorIndex;\n  /**\n   * Encodings of the actual comparators. Each comparator occupies an odd number of cells: one for\n   * the type, then feature/comparison pairs. The feature is encoded with its type system code, and\n   * comparison operations are encoded with\n   * {@link org.apache.uima.cas.admin.FSIndexComparator#STANDARD_COMPARE STANDARD_COMPARE} and\n   * {@link org.apache.uima.cas.admin.FSIndexComparator#REVERSE_STANDARD_COMPARE REVERSE_STANDARD_COMPARE}.\n   */\n  public int[] comparators;\n  // ///////////////////////////////////////////////////////////////////////////\n  // Type system encoding.\n  /**\n   * A list of type names (symbol table). fs-typed arrays have names XXXX[]. \n   * Note: numbering of types starts at <code>1</code>, and\n   * we index the names according to their internal code. That means that\n   * <code>typeNames[0] == null</code>.\n   */\n  public String[] typeNames = null;\n  /**\n   * A list of feature names (symbol table). Note: numbering of features starts at <code>1</code>, ,\n   * and we index the names according to their internal code. That means that\n   * <code>featureNames[0] == null</code>.\n   */\n  public String[] featureNames = null;\n  /**\n   * Type inheritance information: for each type other than the top type, we provide the parent in\n   * the inheritance scheme. We use the internal type codes for indexing, which means that cells 0\n   * (no type) and 1 (top type doesn't inherit from anything) are not used.\n   */\n  public int[] typeInheritance;\n  /**\n   * Feature declarations. For each feature code <code>i</code> (which is an integer &ge; 1), \n   * <code>featDecls[(i-1)*3]</code> is the domain type code, <code>featDecls[(i-1)*3+1]</code> is \n   * the range type code, and <code>featDecls[(i-1)*3+2]</code> is the multipleReferencesAllowed \n   * flag (0 or 1).\n   */\n  public int[] featDecls;\n  /**\n   * The internal code of the top type. Optional, used for sanity checks.\n   */\n  public int topTypeCode;\n  /**\n   * The offsets for features. Optional, used for sanity checks. Since feature numbering starts at\n   * 1, the length of the array is 1 + number of features.\n   */\n  public int[] featureOffsets;\n  /**\n   * A list of type codes for the string subtypes.\n   */\n  public int[] stringSubtypes;\n  /**\n   * The string values for the string subtypes. Start and end postions for the values for the\n   * individual types are in <code>stringSubtypeValuePos</code>.\n   */\n  public String[] stringSubtypeValues;\n  /**\n   * The start positions of the string value subarrays of <code>stringSubtypeValues</code>.\n   * <code>stringSubtypeValuePos.length == \n   * stringSubtypes.length</code>. For each <code>i &lt; \n   * stringSubtypes.length</code>,\n   * <code>stringSubtypeValuePos[i]</code> is the start of the string values for\n   * <code>stringSubtypes[i]</code>.\n   */\n  public int[] stringSubtypeValuePos;\n  // ////////////////////////////////////////////////////////////////////////////\n  // Other stuff\n  /**\n   * Set this appropriately.\n   */\n  public int source = SOURCE_JEDI;\n  // public int source = SOURCE_TAF;\n  /**\n   * Constructor for CASMgrSerializer.\n   */\n  public CASMgrSerializer() {\n    super();\n  }\n  /**\n   * Serialize index repository.\n   * \n   * @param ir\n   *          The index repository to be serialized.\n   */\n  public void addIndexRepository(FSIndexRepositoryImpl ir) {\n    // Encode the type order.\n    this.typeOrder = ir.getDefaultTypeOrder().getOrder();\n    // Collect the index labels in a list, as we don't know how many there\n    // are.\n    final List<String> names = new ArrayList<String>();\n    // Create an iterator over the names.\n    final Iterator<String> namesIt = ir.getLabels();\n    // Add the names to the list, filtering out auto-indexes.\n    while (namesIt.hasNext()) {\n      String name = namesIt.next();\n      if (ir.getIndex(name).getIndexingStrategy() != FSIndex.DEFAULT_BAG_INDEX) { \n        names.add(name);\n      }\n    }\n    // Now we know how many labels there are.\n    final int numNames = names.size();\n    // Create the array for the labels.\n    this.indexNames = new String[numNames];\n    String label;\n    // Fill the name array.\n    for (int i = 0; i < numNames; i++) {\n      // Get the next label.\n      label = names.get(i);\n      // Add the label.\n      this.indexNames[i] = label;\n    }\n    // Create a vector of the indexes, and build the name-to-index map.\n    this.nameToIndexMap = new int[numNames];\n    Vector<FSIndex<FeatureStructure>> indexVector = new Vector<FSIndex<FeatureStructure>>();\n    FSIndex<FeatureStructure> index;\n    int pos;\n    for (int i = 0; i < numNames; i++) {\n      index = ir.getIndex(this.indexNames[i]);\n      pos = indexVector.indexOf(index);\n      if (pos < 0) {\n        indexVector.add(index);\n        pos = indexVector.size() - 1;\n      }\n      this.nameToIndexMap[i] = pos;\n    }\n    // Now we know how many indexes there are.\n    final int numIndexes = indexVector.size();\n    // Create the array with index types.\n    // this.indexTypes = new int[numIndexes];\n    // for (int i = 0; i < numIndexes; i++) {\n    // // This looks ugly, but it just records the type code for each index.\n    // indexTypes[i] =\n    // ((TypeImpl) ((FSIndex) indexVector.get(i)).getType()).getCode();\n    // }\n    // Create the array with the indexing strategy.\n    this.indexingStrategy = new int[numIndexes];\n    for (int i = 0; i < numIndexes; i++) {\n      this.indexingStrategy[i] = indexVector.get(i).getIndexingStrategy();\n    }\n    // Create the array for the comparator index.\n    this.comparatorIndex = new int[numIndexes];<fim_middle>// class below has no smell\n"}