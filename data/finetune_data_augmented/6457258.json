{"text": "<fim_prefix>/*[INCLUDE-IF Sidecar17]*/\n/*******************************************************************************\n * Copyright (c) 2005, 2019 IBM Corp. and others\n *\n * This program and the accompanying materials are made available under\n * the terms of the Eclipse Public License 2.0 which accompanies this\n * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n * or the Apache License, Version 2.0 which accompanies this distribution and\n * is available at https://www.apache.org/licenses/LICENSE-2.0.\n *\n * This Source Code may also be made available under the following\n * Secondary Licenses when the conditions for such availability set\n * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n * General Public License, version 2 with the GNU Classpath\n * Exception [1] and GNU General Public License, version 2 with the\n * OpenJDK Assembly Exception [2].\n *\n * [1] https://www.gnu.org/software/classpath/license.html\n * [2] http://openjdk.java.net/legal/assembly-exception.html\n *\n * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n *******************************************************************************/\npackage com.ibm.java.lang.management.internal;\nimport java.lang.management.PlatformLoggingMXBean;\n/*[IF Sidecar19-SE]*/\nimport java.lang.Module;\nimport java.lang.ModuleLayer;\n/*[ENDIF]*/\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.List;\n/*[IF !Sidecar19-SE]\nimport java.util.logging.LoggingMXBean;\nimport java.util.logging.Level;\nimport java.util.logging.LogManager;\nimport java.util.logging.Logger;\n/*[ENDIF]*/\nimport javax.management.ObjectName;\nimport javax.management.StandardMBean;\n/**\n * Runtime type for {@link java.lang.management.PlatformLoggingMXBean}.\n *\n * @since 1.5\n */\npublic final class LoggingMXBeanImpl\n\t\textends StandardMBean\n\t\timplements\n/*[IF !Sidecar19-SE]\n\t\t\tLoggingMXBean,\n/*[ENDIF]*/\n\t\t\tPlatformLoggingMXBean {\n\tprivate static final LoggingMXBeanImpl instance;\n/*[IF Sidecar19-SE]*/\n\tprivate static final Method logManager_getLogManager;\n\tprivate static final Method logManager_getLogger;\n\tprivate static final Method logManager_getLoggerNames;\n\tprivate static final Method logger_getLevel;\n\tprivate static final Method logger_getParent;\n\tprivate static final Method logger_getName;\n\tprivate static final Method logger_setLevel;\n\tprivate static final Method level_getName;\n\tprivate static final Method level_parse;\n\tprivate static final String logManager_LOGGING_MXBEAN_NAME;\n/*[ENDIF]*/\t\n\tstatic {\n/*[IF Sidecar19-SE]*/\n\t\ttry {\n\t\t\tModule java_logging = ModuleLayer.boot().findModule(\"java.logging\").get(); //$NON-NLS-1$\n\t\t\tClass<?>[] logClasses = AccessController.doPrivileged((PrivilegedAction<Class<?>[]>)\n\t\t\t\t() -> new Class[] {\n\t\t\t\t\tClass.forName(java_logging, \"java.util.logging.LogManager\"), //$NON-NLS-1$\n\t\t\t\t\tClass.forName(java_logging, \"java.util.logging.Logger\"), //$NON-NLS-1$\n\t\t\t\t\tClass.forName(java_logging, \"java.util.logging.Level\") //$NON-NLS-1$\n\t\t\t\t});\n\t\t\tClass<?> logManagerClass = logClasses[0];\n\t\t\tClass<?> loggerClass = logClasses[1];\n\t\t\tClass<?> levelClass = logClasses[2];\n\t\t\tlogManager_getLogManager = logManagerClass.getMethod(\"getLogManager\"); //$NON-NLS-1$\n\t\t\tlogManager_getLogger = logManagerClass.getMethod(\"getLogger\", String.class); //$NON-NLS-1$\n\t\t\tlogManager_getLoggerNames = logManagerClass.getMethod(\"getLoggerNames\"); //$NON-NLS-1$\n\t\t\tlogger_getLevel = loggerClass.getMethod(\"getLevel\"); //$NON-NLS-1$\n\t\t\tlogger_getParent = loggerClass.getMethod(\"getParent\"); //$NON-NLS-1$\n\t\t\tlogger_getName = loggerClass.getMethod(\"getName\"); //$NON-NLS-1$\n\t\t\tlogger_setLevel = loggerClass.getMethod(\"setLevel\", levelClass); //$NON-NLS-1$\n\t\t\tlevel_getName = levelClass.getMethod(\"getName\"); //$NON-NLS-1$\n\t\t\tlevel_parse = levelClass.getMethod(\"parse\", String.class); //$NON-NLS-1$\n\t\t\tlogManager_LOGGING_MXBEAN_NAME = logManagerClass.getField(\"LOGGING_MXBEAN_NAME\").get(null).toString(); //$NON-NLS-1$\n\t\t} catch (Exception e) {\n\t\t\tthrow handleError(e);\n\t\t}\n/*[ENDIF]*/\t\t\n\t\t/* Initialize class */\n\t\tinstance = new LoggingMXBeanImpl();\n\t}\n\t/**\n\t * the object name\n\t */\n\tprivate final ObjectName objectName;\n\t/**\n\t * Constructor intentionally private to prevent instantiation by others.\n\t * Sets the metadata for this bean.\n\t */\n\tprivate LoggingMXBeanImpl() {\n\t\tsuper(PlatformLoggingMXBean.class, true);\n/*[IF Sidecar19-SE]*/\n\t\tobjectName = ManagementUtils.createObjectName(logManager_LOGGING_MXBEAN_NAME);\n/*[ELSE]\t\t\n\t\tobjectName = ManagementUtils.createObjectName(LogManager.LOGGING_MXBEAN_NAME);\n/*[ENDIF]*/\n\t}\n\t/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic ObjectName getObjectName() {\n\t\treturn objectName;\n\t}\n\t/**\n\t * Singleton accessor method.\n\t *\n\t * @return the <code>LoggingMXBeanImpl</code> singleton.\n\t */\n\tpublic static LoggingMXBeanImpl getInstance() {\n\t\treturn instance;\n\t}\n\t/**\n\t * {@inheritDoc}\n\t */\n<fim_suffix>\t@Override\n\tpublic String getLoggerLevel(String loggerName) {\n\t\tString result = null;\n/*[IF Sidecar19-SE]*/\n\t\ttry {\n\t\t\tObject logger = getLoggerFromName(loggerName);\n/*[ELSE]\t\n\t\t\tLogger logger = LogManager.getLogManager().getLogger(loggerName);\n/*[ENDIF]*/\t\t\t\n\t\t\tif (logger != null) {\n\t\t\t\t// The named Logger exists. Now attempt to obtain its log level.\n/*[IF Sidecar19-SE]*/\n\t\t\t\tObject level = logger_getLevel.invoke(logger);\n/*[ELSE]\t\t\t\t\t\n\t\t\t\tLevel level = logger.getLevel();\n/*[ENDIF]*/\t\t\t\t\t\n\t\t\t\tif (level != null) {\n/*[IF Sidecar19-SE]*/\n\t\t\t\t\tresult = (String)level_getName.invoke(level);\n/*[ELSE]\t\n\t\t\t\t\tresult = level.getName();\n/*[ENDIF]*/\t\n\t\t\t\t} else {\n\t\t\t\t\t// A null return from getLevel() means that the Logger\n\t\t\t\t\t// is inheriting its log level from an ancestor. Return an\n\t\t\t\t\t// empty string to the caller.\n\t\t\t\t\tresult = \"\"; //$NON-NLS-1$\n\t\t\t\t}\n\t\t\t}\n/*[IF Sidecar19-SE]*/\n\t\t} catch (Exception e) {\n\t\t\tthrow handleError(e);\n\t\t}\n/*[ENDIF]*/\n\t\treturn result;\n\t}\n\t/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic List<String> getLoggerNames() {\n\t\t// By default, return an empty list to caller\n\t\tList<String> result = new ArrayList<>();\n\t\tEnumeration<?> enumeration;\n/*[IF Sidecar19-SE]*/\n\t\ttry {\n\t\t\tObject logManagerInstance = logManager_getLogManager.invoke(null);\n\t\t\tenumeration = (Enumeration<?>) logManager_getLoggerNames.invoke(logManagerInstance);\n\t\t} catch (Exception e) {\n\t\t\tthrow handleError(e);\n\t\t}\n/*[ELSE]\t\n\t\tenumeration = LogManager.getLogManager().getLoggerNames();\n/*[ENDIF]*/\t\n\t\tif (enumeration != null) {\n\t\t\twhile (enumeration.hasMoreElements()) {\n\t\t\t\tresult.add((String)enumeration.nextElement());\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\t/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic String getParentLoggerName(String loggerName) {\n\t\tString result = null;<fim_middle>// function below is long method\n"}