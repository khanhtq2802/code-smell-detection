{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.usergrid.corepersistence.pipeline.read.search;\n\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.UUID;\n\nimport org.apache.usergrid.corepersistence.index.IndexLocationStrategyFactory;\nimport org.apache.usergrid.persistence.index.*;\nimport org.apache.usergrid.persistence.index.impl.IndexProducer;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport org.apache.usergrid.corepersistence.pipeline.read.AbstractFilter;\nimport org.apache.usergrid.corepersistence.pipeline.read.FilterResult;\nimport org.apache.usergrid.persistence.collection.EntityCollectionManager;\nimport org.apache.usergrid.persistence.collection.EntityCollectionManagerFactory;\nimport org.apache.usergrid.persistence.collection.MvccLogEntry;\nimport org.apache.usergrid.persistence.collection.VersionSet;\nimport org.apache.usergrid.persistence.core.scope.ApplicationScope;\nimport org.apache.usergrid.persistence.model.entity.Id;\n\nimport com.fasterxml.uuid.UUIDComparator;\nimport com.google.inject.Inject;\n\nimport rx.Observable;\n\n\n/**\n * Responsible for verifying candidate result versions, then emitting the Ids of these versions Input is a batch of\n * candidate results, output is a stream of validated Ids\n */\npublic class CandidateIdFilter extends AbstractFilter<FilterResult<Candidate>, FilterResult<Id>> {\n\n    private final EntityCollectionManagerFactory entityCollectionManagerFactory;\n    private final EntityIndexFactory entityIndexFactory;\n    private final IndexLocationStrategyFactory indexLocationStrategyFactory;\n    private final IndexProducer indexProducer;\n\n\n<fim_suffix>    @Inject\n    public CandidateIdFilter( final EntityCollectionManagerFactory entityCollectionManagerFactory,\n                              final EntityIndexFactory entityIndexFactory,\n                              final IndexLocationStrategyFactory indexLocationStrategyFactory,\n                              final IndexProducer indexProducer) {\n        this.entityCollectionManagerFactory = entityCollectionManagerFactory;\n        this.entityIndexFactory = entityIndexFactory;\n        this.indexLocationStrategyFactory = indexLocationStrategyFactory;\n        this.indexProducer = indexProducer;\n    }\n\n\n    @Override\n    public Observable<FilterResult<Id>> call( final Observable<FilterResult<Candidate>> filterResultObservable ) {\n\n\n        /**\n         * A bit kludgy from old 1.0 -> 2.0 apis.  Refactor this as we clean up our lower levels and create new results\n         * objects\n         */\n\n        final ApplicationScope applicationScope = pipelineContext.getApplicationScope();\n\n        final EntityCollectionManager entityCollectionManager =\n            entityCollectionManagerFactory.createCollectionManager( applicationScope );\n\n\n        final EntityIndex applicationIndex =\n            entityIndexFactory.createEntityIndex(indexLocationStrategyFactory.getIndexLocationStrategy(applicationScope));\n\n        final Observable<FilterResult<Id>> searchIdSetObservable =\n            filterResultObservable.buffer( pipelineContext.getLimit() ).flatMap( candidateResults -> {\n                    //flatten toa list of ids to load\n                    final Observable<List<Id>> candidateIds = Observable.from( candidateResults ).map(\n                        candidate -> candidate.getValue().getCandidateResult().getId() ).toList();\n\n                    //load the ids\n                    final Observable<VersionSet> versionSetObservable =\n                        candidateIds.flatMap( ids -> entityCollectionManager.getLatestVersion( ids ) );\n\n                    //now we have a collection, validate our canidate set is correct.\n\n                    return versionSetObservable.map(\n                        entitySet -> new EntityCollector( applicationIndex.createBatch(), entitySet,\n                            candidateResults, indexProducer ) ).doOnNext( entityCollector -> entityCollector.merge() ).flatMap(\n                        entityCollector -> Observable.from( entityCollector.collectResults() ) );\n                } );\n\n        return searchIdSetObservable;\n    }\n\n\n    /**\n     * Map a new cp entity to an old entity.  May be null if not present\n     */\n    private static final class EntityCollector {\n\n        private static final Logger logger = LoggerFactory.getLogger( EntityCollector.class );\n        private List<FilterResult<Id>> results = new ArrayList<>();\n\n        private final EntityIndexBatch batch;\n        private final List<FilterResult<Candidate>> candidateResults;\n        private final IndexProducer indexProducer;\n        private final VersionSet versionSet;\n\n\n        public EntityCollector( final EntityIndexBatch batch, final VersionSet versionSet,\n                                final List<FilterResult<Candidate>> candidateResults, final IndexProducer indexProducer ) {\n            this.batch = batch;\n            this.versionSet = versionSet;\n            this.candidateResults = candidateResults;\n            this.indexProducer = indexProducer;\n            this.results = new ArrayList<>( versionSet.size() );\n        }\n\n\n        /**\n         * Merge our candidates and our entity set into results\n         */\n        public void merge() {\n\n            for ( final FilterResult<Candidate> candidateResult : candidateResults ) {\n                validate( candidateResult );\n            }\n\n            indexProducer.put( batch.build()).toBlocking().lastOrDefault(null);//want to rethrow if batch fails\n\n        }\n\n\n        public List<FilterResult<Id>> collectResults() {\n            return results;\n        }\n\n\n        /**\n         * Validate each candidate results vs the data loaded from cass\n         */\n        private void validate( final FilterResult<Candidate> filterCandidate ) {\n\n            final CandidateResult candidateResult = filterCandidate.getValue().getCandidateResult();\n\n            final SearchEdge searchEdge = filterCandidate.getValue().getSearchEdge();\n\n            final MvccLogEntry logEntry = versionSet.getMaxVersion( candidateResult.getId() );\n\n            final UUID candidateVersion = candidateResult.getVersion();\n\n            final UUID entityVersion = logEntry.getVersion();\n\n            final Id entityId = logEntry.getEntityId();\n\n            //entity is newer than ES version\n            if ( UUIDComparator.staticCompare( entityVersion, candidateVersion ) > 0 ) {\n\n                logger.warn( \"Deindexing stale entity on edge {} for entityId {} and version {}\",\n                        searchEdge, entityId, entityVersion );\n                batch.deindex( searchEdge, entityId, entityVersion );\n                return;\n            }\n\n            //ES is newer than cass, it means we haven't repaired the record in Cass, we don't want to\n            //remove the ES record, since the read in cass should cause a read repair, just ignore\n            if ( UUIDComparator.staticCompare( candidateVersion, entityVersion ) > 0 ) {\n\n                logger.warn(\n                    \"Found a newer version in ES over cassandra for edge {} for entityId {} and version {}.  Repair should be run\",\n                        searchEdge, entityId, entityVersion );\n            }\n\n            //they're the same add it\n\n            final FilterResult<Id> result = new FilterResult<>( entityId, filterCandidate.getPath() );\n\n            results.add( result );\n        }\n    }\n}<fim_middle>// function below has no smell\n"}