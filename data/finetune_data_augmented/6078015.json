{"text": "<fim_prefix>/********************************************************************************\n * Copyright (c) 2011-2017 Red Hat Inc. and/or its affiliates and others\n *\n * This program and the accompanying materials are made available under the \n * terms of the Apache License, Version 2.0 which is available at\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * SPDX-License-Identifier: Apache-2.0 \n ********************************************************************************/\npackage org.eclipse.ceylon.compiler.typechecker.analyzer;\nimport static org.eclipse.ceylon.model.typechecker.model.ModelUtil.formatPath;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport org.eclipse.ceylon.cmr.api.ArtifactContext;\nimport org.eclipse.ceylon.cmr.api.ModuleDependencyInfo;\nimport org.eclipse.ceylon.cmr.api.ModuleInfo;\nimport org.eclipse.ceylon.cmr.api.Overrides;\nimport org.eclipse.ceylon.cmr.api.RepositoryManager;\nimport org.eclipse.ceylon.common.Backend;\nimport org.eclipse.ceylon.common.Backends;\nimport org.eclipse.ceylon.compiler.typechecker.context.Context;\nimport org.eclipse.ceylon.compiler.typechecker.context.PhasedUnits;\nimport org.eclipse.ceylon.compiler.typechecker.io.ClosableVirtualFile;\nimport org.eclipse.ceylon.compiler.typechecker.tree.Node;\nimport org.eclipse.ceylon.compiler.typechecker.tree.Tree;\nimport org.eclipse.ceylon.compiler.typechecker.tree.Tree.ModuleDescriptor;\nimport org.eclipse.ceylon.model.cmr.ArtifactResult;\nimport org.eclipse.ceylon.model.loader.JdkProvider;\nimport org.eclipse.ceylon.model.typechecker.model.Module;\nimport org.eclipse.ceylon.model.typechecker.model.ModuleImport;\nimport org.eclipse.ceylon.model.typechecker.model.Modules;\nimport org.eclipse.ceylon.model.typechecker.model.Package;\nimport org.eclipse.ceylon.model.typechecker.util.ModuleManager;\nimport java.util.Set;\nimport java.util.TreeMap;\nimport java.util.WeakHashMap;\npublic class ModuleSourceMapper {\n    JdkProvider defaultJdkProvider = new JdkProvider();\n<fim_suffix>    public static class ModuleDependencyAnalysisError extends AnalysisError {\n        private boolean isError = true;\n        public ModuleDependencyAnalysisError(Node treeNode, String message, int code) {\n            super(treeNode, message, code);\n        }\n        public ModuleDependencyAnalysisError(Node treeNode, String message, int code, Backend backend) {\n            super(treeNode, message, code, backend);\n        }\n        public ModuleDependencyAnalysisError(Node treeNode, String message) {\n            super(treeNode, message);\n        }\n        public ModuleDependencyAnalysisError(Node treeNode, String message, boolean isError) {\n            super(treeNode, message);\n            this.isError = isError;\n        }\n        public ModuleDependencyAnalysisError(Node treeNode, String message, Backend backend) {\n            super(treeNode, message, backend);\n        }\n        @Override\n        public boolean isWarning() {\n            return !isError;\n        }\n    }\n    private final LinkedList<Package> packageStack = new LinkedList<Package>();\n    private Module currentModule;\n    private final Map<ModuleImport,WeakHashMap<Node, Object>> moduleImportToNode = new HashMap<ModuleImport, WeakHashMap<Node, Object>>();\n    private Map<List<String>, Set<String>> topLevelErrorsPerModuleName = new HashMap<List<String>,Set<String>>();\n    private Map<Module, Node> moduleToNode = new TreeMap<Module, Node>();\n    private ModuleManager moduleManager;\n    private Context context;\n    private Modules modules;\n    private HashSet<String> reportedModuleConflictErrors = new HashSet<>();\n    private HashSet<String> reportedModuleConflictWarnings = new HashSet<>();\n    private static Object PRESENT = new Object();\n    public ModuleSourceMapper(Context context, ModuleManager moduleManager) {\n        this.context = context;\n        this.moduleManager = moduleManager;\n        this.modules = context.getModules();\n    }\n    public void initCoreModules(){\n        moduleManager.initCoreModules(modules);\n        packageStack.clear();\n        packageStack.addLast( modules.getDefaultModule().getPackages().get(0) );\n    }\n    public void push(String path) {\n        createPackageAndAddToModule(path);\n    }\n    public void pop() {\n        removeLastPackageAndModuleIfNecessary();\n    }\n    public Package getCurrentPackage() {\n        return packageStack.peekLast();\n    }\n    public void visitModuleFile() {\n        if ( currentModule == null ) {\n            final Package currentPkg = packageStack.peekLast();\n            final List<String> moduleName = currentPkg.getName();\n            //we don't know the version at this stage, will be filled later\n            currentModule = moduleManager.getOrCreateModule(moduleName, null);\n            if ( currentModule != null ) {\n                currentModule.setAvailable(true); // TODO : not necessary anymore ? the phasedUnit will be added. And the buildModuleImport()\n                                                  //        function (which calls module.setAvailable()) will be called by the typeChecker\n                                                  //        BEFORE the ModuleValidator.verifyModuleDependencyTree() call that uses \n                                                  //        isAvailable()\n                Package pkg = currentModule.getDirectPackage(currentPkg.getNameAsString());\n                if (pkg == null) {\n                    moduleManager.bindPackageToModule(currentPkg, currentModule);\n                } else {\n                    // Tako: this is a work-around for the fact that the Package gets\n                    // created before the Module it belongs to and that with multiple\n                    // source folders we could end up with duplicate Packages.\n                    // So we pop the newly created Package and replace it with the\n                    // existing one we found in the Module\n                    packageStack.pollLast();\n                    packageStack.addLast(pkg);\n                }\n            }\n            else {\n                addErrorToModule(new ArrayList<String>(), \n                        \"module may not be defined at the top level of the hierarchy\");\n            }\n        }\n        else {\n            StringBuilder error = new StringBuilder(\"two modules within the same hierarchy: '\");\n            error.append( formatPath( currentModule.getName() ) )\n                .append( \"' and '\" )\n                .append( formatPath( packageStack.peekLast().getName() ) )\n                .append(\"'\");\n            addErrorToModule(currentModule.getName(), error.toString());\n            addErrorToModule(packageStack.peekLast().getName(), error.toString());\n        }\n    }\n    private void createPackageAndAddToModule(String path) {\n        final Package lastPkg = packageStack.peekLast();\n        List<String> parentName = lastPkg.getName();\n        final ArrayList<String> name = new ArrayList<String>(parentName.size() + 1);\n        name.addAll(parentName);\n        name.add(path);\n        Package pkg = moduleManager.createPackage(formatPath(name), \n                currentModule != null ? currentModule : modules.getDefaultModule());\n        packageStack.addLast(pkg);\n    }\n    private void removeLastPackageAndModuleIfNecessary() {\n        packageStack.pollLast();\n        final boolean moveAboveModuleLevel = currentModule != null\n                && currentModule.getName().size() > packageStack.size() -1; //first package is the empty package\n        if (moveAboveModuleLevel) {\n            currentModule = null;\n        }\n    }\n    public void addModuleDependencyDefinition(ModuleImport moduleImport, Node definition) {\n        WeakHashMap<Node, Object> moduleDepDefinition = moduleImportToNode.get(moduleImport);\n        if (moduleDepDefinition == null) {\n            moduleDepDefinition = new WeakHashMap<Node, Object>();\n            moduleImportToNode.put(moduleImport, moduleDepDefinition);\n        }\n        moduleDepDefinition.put(definition, PRESENT);\n    }\n    public void attachErrorToDependencyDeclaration(ModuleImport moduleImport, List<Module> dependencyTree, String error,\n            boolean isError) {\n        if (!attachErrorToDependencyDeclaration(moduleImport, error, isError)) {\n            //This probably can happen if the missing dependency is found deep in the dependency structure (ie the binary version of a module)\n            // in theory the first item in the dependency tree is the compiled module, and the second one is the import we have to add\n            // the error to\n            if(dependencyTree.size() >= 2){\n                Module rootModule = dependencyTree.get(0);\n                Module originalImportedModule = dependencyTree.get(1);\n                // find the original import\n                for(ModuleImport imp : rootModule.getImports()){\n                    if(imp.getModule() == originalImportedModule){\n                        // found it, try to attach the error\n                        if(attachErrorToDependencyDeclaration(imp, error, isError)){\n                            // we're done\n                            return;\n                        }else{\n                            // failed\n                            break;\n                        }\n                    }\n                }\n            }<fim_middle>// class below has no smell\n"}