{"text": "<fim_prefix>     * when threads ready to commit have to wait for a commit in progress.\n     */\n    private static final int COMMIT_WAIT_WARN_MILLIS = Integer\n            .getInteger(\"oak.segmentNodeStore.commitWaitWarnMillis\", 60000);\n    /**\n     * Maximum number of milliseconds to wait before re-attempting to update the current\n     * head state after a successful commit, provided a concurrent head state update happens.\n     */\n    private static final long MAXIMUM_BACKOFF = MILLISECONDS.convert(10, SECONDS);\n    /**\n     * Sets the number of seconds to wait for the attempt to grab the lock to\n     * create a checkpoint\n     */\n    private final int checkpointsLockWaitTime = Integer.getInteger(\"oak.checkpoints.lockWaitTime\", 10);\n    static final String ROOT = \"root\";\n    /**\n     * Semaphore that controls access to the {@link #head} variable. Only a\n     * single local commit is allowed at a time. When such a commit is in\n     * progress, no external updates will be seen.\n     */\n    private final Semaphore commitSemaphore = new Semaphore(1, COMMIT_FAIR_LOCK);\n    @NotNull\n    private final SegmentReader reader;\n    @NotNull\n    private final Revisions revisions;\n    protected final AtomicReference<SegmentNodeState> head;\n    private final SegmentNodeStoreStats stats;\n    private final Histogram commitTimeHistogram = new Histogram(new UniformReservoir());\n    private final Random random = new Random();\n    private final CommitSemaphoreLogging commitSemaphoreLogging = new CommitSemaphoreLogging();\n    /*\n     * Logging of commits that are either blocked for longer than COMMIT_WAIT_WARN_MILLIS\n     * or on a commit that crossed the gc boundary. See OAK-8071.\n     */\n    private class CommitSemaphoreLogging {\n        @Nullable\n        private volatile Commit commit;\n        private volatile long timeStamp;\n        public void commitStarted(@NotNull Commit commit) {\n            this.commit = commit;\n            this.timeStamp = System.currentTimeMillis();\n        }\n        public void commitEnded() {\n            this.commit = null;\n        }\n        public void warnOnBlockingCommit() {\n            Commit currentCommit = commit;\n            GCGeneration headGeneration = head.get().getGcGeneration();\n            GCGeneration commitGeneration = currentCommit == null\n                ? null\n                : currentCommit.getGCGeneration();\n            long dt = System.currentTimeMillis() - timeStamp;\n            boolean isBlocking = currentCommit != null && dt > COMMIT_WAIT_WARN_MILLIS;\n            boolean isOldGeneration = commitGeneration != null\n                    && headGeneration.getFullGeneration() > commitGeneration.getFullGeneration();\n            if (isBlocking) {\n                log.warn(\"This commit is blocked by a commit that is in progress since {} ms\", dt);\n            }\n            if (isOldGeneration) {\n                log.warn(\"The commit in progress is from an old GC generation {}. Head is at {}\",\n                         commitGeneration, headGeneration);\n            }\n        }\n    }\n    public LockBasedScheduler(LockBasedSchedulerBuilder builder) {\n        if (COMMIT_FAIR_LOCK) {\n            log.info(\"Initializing SegmentNodeStore with the commitFairLock option enabled.\");\n        }\n        this.reader = builder.reader;\n        this.revisions = builder.revisions;\n        this.stats = builder.stats;\n        this.head = new AtomicReference<SegmentNodeState>(reader.readHeadState(revisions));\n    }\n    @Override\n    public NodeState getHeadNodeState() {\n        long delay = (long) commitTimeHistogram.getSnapshot().getValue(SCHEDULER_FETCH_COMMIT_DELAY_QUANTILE);\n        try {\n            if (commitSemaphore.tryAcquire(delay, NANOSECONDS)) {\n                try {\n                    refreshHead(true);\n                } finally {\n                    commitSemaphore.release();\n                }\n            } \n        } catch (InterruptedException e) {\n            currentThread().interrupt();\n        }\n        return head.get();\n    }\n    /**\n     * Refreshes the head state. Should only be called while holding a permit\n     * from the {@link #commitSemaphore}.\n     * \n     * @param dispatchChanges\n     *            if set to true the changes would also be dispatched\n     */\n    private void refreshHead(boolean dispatchChanges) {\n        SegmentNodeState state = reader.readHeadState(revisions);\n        if (!state.getRecordId().equals(head.get().getRecordId())) {\n            head.set(state);\n            if (dispatchChanges) {\n                contentChanged(state.getChildNode(ROOT), CommitInfo.EMPTY_EXTERNAL);\n            }\n        }\n    }\n    protected void contentChanged(NodeState root, CommitInfo info) {\n        // do nothing without a change dispatcher\n    }\n    @Override\n    public NodeState schedule(@NotNull Commit commit, SchedulerOption... schedulingOptions)\n            throws CommitFailedException {\n        try {\n            commitSemaphoreLogging.warnOnBlockingCommit();\n            long queuedTime = System.nanoTime();\n            stats.onCommitQueued(Thread.currentThread(), commit::getGCGeneration);\n            commitSemaphore.acquire();\n            commitSemaphoreLogging.commitStarted(commit);\n            try {\n                long dequeuedTime = System.nanoTime();\n                stats.onCommitDequeued(Thread.currentThread(), dequeuedTime - queuedTime);\n                long beforeCommitTime = System.nanoTime();\n                SegmentNodeState merged = (SegmentNodeState) execute(commit);\n                commit.applied(merged);\n                long afterCommitTime = System.nanoTime();\n                commitTimeHistogram.update(afterCommitTime - beforeCommitTime);\n                stats.onCommit(Thread.currentThread(), afterCommitTime - beforeCommitTime);\n                return merged;\n            } finally {\n                commitSemaphoreLogging.commitEnded();\n                commitSemaphore.release();\n            }\n        } catch (InterruptedException e) {\n            currentThread().interrupt();\n            throw new CommitFailedException(\"Segment\", 2, \"Merge interrupted\", e);\n        } catch (SegmentOverflowException e) {\n            throw new CommitFailedException(\"Segment\", 3, \"Merge failed\", e);\n        }\n    }\n    private NodeState execute(Commit commit) throws CommitFailedException, InterruptedException {\n        // only do the merge if there are some changes to commit\n        if (commit.hasChanges()) {\n            long start = System.nanoTime();\n            int count = 0;\n            for (long backoff = 1; backoff < MAXIMUM_BACKOFF; backoff *= 2) {\n                refreshHead(true);\n                SegmentNodeState before = head.get();\n                SegmentNodeState after = commit.apply(before);\n                if (revisions.setHead(before.getRecordId(), after.getRecordId())) {\n                    head.set(after);\n                    contentChanged(after.getChildNode(ROOT), commit.info());\n                    return head.get().getChildNode(ROOT);\n                } \n                count++;\n                int randNs = random.nextInt(1_000_000);\n                log.info(\"Scheduler detected concurrent commits. Retrying after {} ms and {} ns\", backoff, randNs);\n                Thread.sleep(backoff, randNs);\n            }\n            long finish = System.nanoTime();\n            String message = MessageFormat.format(\n                    \"The commit could not be executed after {} attempts. Total wait time: {} ms\",\n                    count, NANOSECONDS.toMillis(finish - start));\n            throw new CommitFailedException(\"Segment\", 3, message);\n        }\n        return head.get().getChildNode(ROOT);\n    }\n    @Override\n    public String checkpoint(long lifetime, @NotNull Map<String, String> properties) {\n        checkArgument(lifetime > 0);\n        checkNotNull(properties);\n        String name = UUID.randomUUID().toString();\n        try {\n            CPCreator cpc = new CPCreator(name, lifetime, properties);\n            if (commitSemaphore.tryAcquire(checkpointsLockWaitTime, TimeUnit.SECONDS)) {\n                try {\n                    if (cpc.call()) {\n                        return name;\n                    }\n                } finally {\n                    // Explicitly give up reference to the previous root state\n                    // otherwise they would block cleanup. See OAK-3347\n                    refreshHead(true);\n                    commitSemaphore.release();\n                }\n            }\n            log.warn(\"Failed to create checkpoint {} in {} seconds.\", name, checkpointsLockWaitTime);\n        } catch (InterruptedException e) {\n            currentThread().interrupt();\n            log.error(\"Failed to create checkpoint {}.\", name, e);\n        } catch (Exception e) {\n            log.error(\"Failed to create checkpoint {}.\", name, e);\n        }\n        return name;\n    }\n<fim_suffix>    @Override\n    public boolean removeCheckpoint(String name) {\n        checkNotNull(name);\n        // try 5 times\n        for (int i = 0; i < 5; i++) {\n            if (commitSemaphore.tryAcquire()) {\n                try {\n                    refreshHead(true);\n                    SegmentNodeState state = head.get();\n                    SegmentNodeBuilder builder = state.builder();\n                    NodeBuilder cp = builder.child(\"checkpoints\").child(name);\n                    if (cp.exists()) {\n                        cp.remove();\n                        SegmentNodeState newState = builder.getNodeState();\n                        if (revisions.setHead(state.getRecordId(), newState.getRecordId())) {\n                            refreshHead(false);\n                            return true;\n                        }\n                    }\n                } finally {\n                    commitSemaphore.release();\n                }\n            }\n        }\n        return false;\n    }<fim_middle>// function below has no smell\n"}