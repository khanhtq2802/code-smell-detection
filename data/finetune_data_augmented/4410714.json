{"text": "<fim_prefix>                            PolicyUtils.assertPolicy(aim,\n                                                     new QName(token.getName().getNamespaceURI(),\n                                                               SPConstants.HTTP_DIGEST_AUTHENTICATION));\n                        }\n                    }\n                } else {\n                    ai.setNotAsserted(\"Not an HTTPs connection\");\n                }\n                if (!ai.isAsserted()) {\n                    throw new PolicyException(ai);\n                }\n            }\n        }\n    }\n<fim_suffix>    static class HttpsTokenInInterceptor extends AbstractPhaseInterceptor<Message> {\n        HttpsTokenInInterceptor() {\n            super(Phase.PRE_STREAM);\n            addBefore(WSS4JStaxInInterceptor.class.getName());\n        }\n        public void handleMessage(Message message) throws Fault {\n            AssertionInfoMap aim = message.get(AssertionInfoMap.class);\n            // extract Assertion information\n            if (aim != null) {\n                Collection<AssertionInfo> ais =\n                    PolicyUtils.getAllAssertionsByLocalname(aim, SPConstants.HTTPS_TOKEN);\n                boolean requestor = isRequestor(message);\n                if (ais.isEmpty()) {\n                    if (!requestor) {\n                        try {\n                            assertNonHttpsTransportToken(message);\n                        } catch (XMLSecurityException e) {\n                            LOG.fine(e.getMessage());\n                        }\n                    }\n                    return;\n                }\n                if (!requestor) {\n                    try {\n                        assertHttps(aim, ais, message);\n                    } catch (XMLSecurityException e) {\n                        LOG.fine(e.getMessage());\n                    }\n                    // Store the TLS principal on the message context\n                    SecurityContext sc = message.get(SecurityContext.class);\n                    if (sc == null || sc.getUserPrincipal() == null) {\n                        TLSSessionInfo tlsInfo = message.get(TLSSessionInfo.class);\n                        if (tlsInfo != null && tlsInfo.getPeerCertificates() != null\n                                && tlsInfo.getPeerCertificates().length > 0\n                                && (tlsInfo.getPeerCertificates()[0] instanceof X509Certificate)\n                        ) {\n                            X509Certificate cert = (X509Certificate)tlsInfo.getPeerCertificates()[0];\n                            message.put(\n                                SecurityContext.class, createSecurityContext(cert.getSubjectX500Principal())\n                            );\n                        }\n                    }\n                } else {\n                    //client side should be checked on the way out\n                    for (AssertionInfo ai : ais) {\n                        ai.setAsserted(true);\n                    }\n                    PolicyUtils.assertPolicy(aim, SPConstants.HTTP_DIGEST_AUTHENTICATION);\n                    PolicyUtils.assertPolicy(aim, SPConstants.HTTP_BASIC_AUTHENTICATION);\n                    PolicyUtils.assertPolicy(aim, SPConstants.REQUIRE_CLIENT_CERTIFICATE);\n                }\n            }\n        }\n        private void assertHttps(\n            AssertionInfoMap aim,\n            Collection<AssertionInfo> ais,\n            Message message\n        ) throws XMLSecurityException {\n            List<SecurityEvent> securityEvents = getSecurityEventList(message);\n            AuthorizationPolicy policy = message.get(AuthorizationPolicy.class);\n            for (AssertionInfo ai : ais) {\n                boolean asserted = true;\n                HttpsToken token = (HttpsToken)ai.getAssertion();\n                HttpsTokenSecurityEvent httpsTokenSecurityEvent = new HttpsTokenSecurityEvent();\n                Map<String, List<String>> headers = getProtocolHeaders(message);\n                if (token.getAuthenticationType() == HttpsToken.AuthenticationType.HttpBasicAuthentication) {\n                    List<String> auth = headers.get(\"Authorization\");\n                    if (auth == null || auth.isEmpty()\n                        || !auth.get(0).startsWith(\"Basic\")) {\n                        asserted = false;\n                    } else {\n                        httpsTokenSecurityEvent.setAuthenticationType(\n                            HttpsTokenSecurityEvent.AuthenticationType.HttpBasicAuthentication\n                        );\n                        HttpsSecurityTokenImpl httpsSecurityToken =\n                            new HttpsSecurityTokenImpl(true, policy.getUserName());\n                        httpsSecurityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);\n                        httpsTokenSecurityEvent.setSecurityToken(httpsSecurityToken);\n                        PolicyUtils.assertPolicy(aim,\n                                                 new QName(token.getName().getNamespaceURI(),\n                                                           SPConstants.HTTP_BASIC_AUTHENTICATION));\n                    }\n                }\n                if (token.getAuthenticationType() == HttpsToken.AuthenticationType.HttpDigestAuthentication) {\n                    List<String> auth = headers.get(\"Authorization\");\n                    if (auth == null || auth.isEmpty()\n                        || !auth.get(0).startsWith(\"Digest\")) {\n                        asserted = false;\n                    } else {\n                        httpsTokenSecurityEvent.setAuthenticationType(\n                            HttpsTokenSecurityEvent.AuthenticationType.HttpDigestAuthentication\n                        );\n                        HttpsSecurityTokenImpl httpsSecurityToken =\n                            new HttpsSecurityTokenImpl(false, policy.getUserName());\n                        httpsSecurityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);\n                        httpsTokenSecurityEvent.setSecurityToken(httpsSecurityToken);\n                        PolicyUtils.assertPolicy(aim,\n                                                 new QName(token.getName().getNamespaceURI(),\n                                                           SPConstants.HTTP_DIGEST_AUTHENTICATION));\n                    }\n                }\n                TLSSessionInfo tlsInfo = message.get(TLSSessionInfo.class);\n                if (tlsInfo != null) {\n                    if (token.getAuthenticationType()\n                        == HttpsToken.AuthenticationType.RequireClientCertificate) {\n                        if (tlsInfo.getPeerCertificates() == null\n                            || tlsInfo.getPeerCertificates().length == 0) {\n                            asserted = false;\n                        } else {\n                            PolicyUtils.assertPolicy(aim,\n                                                     new QName(token.getName().getNamespaceURI(),\n                                                               SPConstants.REQUIRE_CLIENT_CERTIFICATE));\n                        }\n                    }\n                    if (tlsInfo.getPeerCertificates() != null && tlsInfo.getPeerCertificates().length > 0) {\n                        httpsTokenSecurityEvent.setAuthenticationType(\n                            HttpsTokenSecurityEvent.AuthenticationType.HttpsClientCertificateAuthentication\n                        );\n                        HttpsSecurityTokenImpl httpsSecurityToken =\n                            new HttpsSecurityTokenImpl((X509Certificate)tlsInfo.getPeerCertificates()[0]);\n                        httpsSecurityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);\n                        httpsTokenSecurityEvent.setSecurityToken(httpsSecurityToken);\n                    } else if (httpsTokenSecurityEvent.getAuthenticationType() == null) {\n                        httpsTokenSecurityEvent.setAuthenticationType(\n                            HttpsTokenSecurityEvent.AuthenticationType.HttpsNoAuthentication\n                        );\n                        HttpsSecurityTokenImpl httpsSecurityToken = new HttpsSecurityTokenImpl();\n                        httpsSecurityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);\n                        httpsTokenSecurityEvent.setSecurityToken(httpsSecurityToken);\n                    }\n                } else {\n                    asserted = false;\n                }\n                ai.setAsserted(asserted);\n                if (asserted) {\n                    securityEvents.add(httpsTokenSecurityEvent);\n                }\n            }\n        }\n        // We might have an IssuedToken TransportToken\n        private void assertNonHttpsTransportToken(Message message) throws XMLSecurityException {\n            TLSSessionInfo tlsInfo = message.get(TLSSessionInfo.class);\n            if (tlsInfo != null) {\n                HttpsTokenSecurityEvent httpsTokenSecurityEvent = new HttpsTokenSecurityEvent();\n                if (tlsInfo.getPeerCertificates() != null && tlsInfo.getPeerCertificates().length > 0) {\n                    httpsTokenSecurityEvent.setAuthenticationType(\n                        HttpsTokenSecurityEvent.AuthenticationType.HttpsClientCertificateAuthentication\n                    );\n                    HttpsSecurityTokenImpl httpsSecurityToken =\n                        new HttpsSecurityTokenImpl((X509Certificate)tlsInfo.getPeerCertificates()[0]);\n                    httpsSecurityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);\n                    httpsTokenSecurityEvent.setSecurityToken(httpsSecurityToken);\n                } else if (httpsTokenSecurityEvent.getAuthenticationType() == null) {\n                    httpsTokenSecurityEvent.setAuthenticationType(\n                        HttpsTokenSecurityEvent.AuthenticationType.HttpsNoAuthentication\n                    );\n                    HttpsSecurityTokenImpl httpsSecurityToken = new HttpsSecurityTokenImpl();\n                    httpsSecurityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);\n                    httpsTokenSecurityEvent.setSecurityToken(httpsSecurityToken);\n                }\n                List<SecurityEvent> securityEvents = getSecurityEventList(message);\n                securityEvents.add(httpsTokenSecurityEvent);\n            }\n        }\n        private List<SecurityEvent> getSecurityEventList(Message message) {\n            @SuppressWarnings(\"unchecked\")\n            List<SecurityEvent> securityEvents =\n                (List<SecurityEvent>) message.getExchange().get(SecurityEvent.class.getName() + \".out\");\n            if (securityEvents == null) {\n                securityEvents = new ArrayList<>();\n                message.getExchange().put(SecurityEvent.class.getName() + \".out\", securityEvents);\n            }\n            return securityEvents;\n        }\n        private SecurityContext createSecurityContext(final Principal p) {\n            return new SecurityContext() {\n                public Principal getUserPrincipal() {\n                    return p;\n                }\n                public boolean isUserInRole(String role) {\n                    return false;\n                }\n            };\n        }\n    }<fim_middle>// class below is blob\n"}