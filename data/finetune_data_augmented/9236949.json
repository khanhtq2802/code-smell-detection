{"text": "<fim_prefix>/*\n * Copyright (c) 2010, 2014, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage sun.font;\nimport java.io.*;\nimport java.util.*;\nimport sun.awt.*;\nimport sun.java2d.xr.*;\n/**\n * Glyph cache used by the XRender pipeline.\n *\n * @author Clemens Eisserer\n */\npublic class XRGlyphCache implements GlyphDisposedListener {\n    XRBackend con;\n    XRCompositeManager maskBuffer;\n    HashMap<MutableInteger, XRGlyphCacheEntry> cacheMap = new HashMap<MutableInteger, XRGlyphCacheEntry>(256);\n    int nextID = 1;\n    MutableInteger tmp = new MutableInteger(0);\n    int grayGlyphSet;\n    int lcdGlyphSet;\n    int time = 0;\n    int cachedPixels = 0;\n    static final int MAX_CACHED_PIXELS = 100000;\n    ArrayList<Integer> freeGlyphIDs = new ArrayList<Integer>(255);\n    static final boolean batchGlyphUpload = true; // Boolean.parseBoolean(System.getProperty(\"sun.java2d.xrender.batchGlyphUpload\"));\n    public XRGlyphCache(XRCompositeManager maskBuf) {\n        this.con = maskBuf.getBackend();\n        this.maskBuffer = maskBuf;\n        grayGlyphSet = con.XRenderCreateGlyphSet(XRUtils.PictStandardA8);\n        lcdGlyphSet = con.XRenderCreateGlyphSet(XRUtils.PictStandardARGB32);\n        StrikeCache.addGlyphDisposedListener(this);\n    }\n    public void glyphDisposed(ArrayList<Long> glyphPtrList) {\n        try {\n            SunToolkit.awtLock();\n            GrowableIntArray glyphIDList = new GrowableIntArray(1, glyphPtrList.size());\n            for (long glyphPtr : glyphPtrList) {\n                int glyphID = XRGlyphCacheEntry.getGlyphID(glyphPtr);\n                //Check if glyph hasn't been freed already\n                if (glyphID != 0) {\n                   glyphIDList.addInt(glyphID);\n                }\n            }\n            freeGlyphs(glyphIDList);\n        } finally {\n            SunToolkit.awtUnlock();\n        }\n    }\n    protected int getFreeGlyphID() {\n        if (freeGlyphIDs.size() > 0) {\n            int newID = freeGlyphIDs.remove(freeGlyphIDs.size() - 1);\n            return newID;\n        }\n        return nextID++;\n    }\n    protected XRGlyphCacheEntry getEntryForPointer(long imgPtr) {\n        int id = XRGlyphCacheEntry.getGlyphID(imgPtr);\n        if (id == 0) {\n            return null;\n        }\n        tmp.setValue(id);\n        return cacheMap.get(tmp);\n    }\n    public XRGlyphCacheEntry[] cacheGlyphs(GlyphList glyphList) {\n        time++;\n        XRGlyphCacheEntry[] entries = new XRGlyphCacheEntry[glyphList.getNumGlyphs()];\n        long[] imgPtrs = glyphList.getImages();\n        ArrayList<XRGlyphCacheEntry> uncachedGlyphs = null;\n        for (int i = 0; i < glyphList.getNumGlyphs(); i++) {\n            XRGlyphCacheEntry glyph;\n            // Find uncached glyphs and queue them for upload\n            if ((glyph = getEntryForPointer(imgPtrs[i])) == null) {\n                glyph = new XRGlyphCacheEntry(imgPtrs[i], glyphList);\n                glyph.setGlyphID(getFreeGlyphID());\n                cacheMap.put(new MutableInteger(glyph.getGlyphID()), glyph);\n                if (uncachedGlyphs == null) {\n                    uncachedGlyphs = new ArrayList<XRGlyphCacheEntry>();\n                }\n                uncachedGlyphs.add(glyph);\n            }\n            glyph.setLastUsed(time);\n            entries[i] = glyph;\n        }\n        // Add glyphs to cache\n        if (uncachedGlyphs != null) {\n            uploadGlyphs(entries, uncachedGlyphs, glyphList, null);\n        }\n        return entries;\n    }\n    protected void uploadGlyphs(XRGlyphCacheEntry[] glyphs, ArrayList<XRGlyphCacheEntry> uncachedGlyphs, GlyphList gl, int[] glIndices) {\n        for (XRGlyphCacheEntry glyph : uncachedGlyphs) {\n            cachedPixels += glyph.getPixelCnt();\n        }\n        if (cachedPixels > MAX_CACHED_PIXELS) {\n            clearCache(glyphs);\n        }\n        boolean containsLCDGlyphs = containsLCDGlyphs(uncachedGlyphs);\n        List<XRGlyphCacheEntry>[] seperatedGlyphList = seperateGlyphTypes(uncachedGlyphs, containsLCDGlyphs);\n        List<XRGlyphCacheEntry> grayGlyphList = seperatedGlyphList[0];\n        List<XRGlyphCacheEntry> lcdGlyphList = seperatedGlyphList[1];\n        /*\n         * Some XServers crash when uploading multiple glyphs at once. TODO:\n         * Implement build-switch in local case for distributors who know their\n         * XServer is fixed\n         */\n        if (batchGlyphUpload) {\n            if (grayGlyphList != null && grayGlyphList.size() > 0) {\n                con.XRenderAddGlyphs(grayGlyphSet, gl, grayGlyphList, generateGlyphImageStream(grayGlyphList));\n            }\n            if (lcdGlyphList != null && lcdGlyphList.size() > 0) {\n                con.XRenderAddGlyphs(lcdGlyphSet, gl, lcdGlyphList, generateGlyphImageStream(lcdGlyphList));\n            }\n        } else {\n            ArrayList<XRGlyphCacheEntry> tmpList = new ArrayList<XRGlyphCacheEntry>(1);\n            tmpList.add(null);\n            for (XRGlyphCacheEntry entry : uncachedGlyphs) {\n                tmpList.set(0, entry);\n                if (entry.getGlyphSet() == grayGlyphSet) {\n                    con.XRenderAddGlyphs(grayGlyphSet, gl, tmpList, generateGlyphImageStream(tmpList));\n                } else {\n                    con.XRenderAddGlyphs(lcdGlyphSet, gl, tmpList, generateGlyphImageStream(tmpList));\n                }\n            }\n        }\n    }\n    /**\n     * Seperates lcd and grayscale glyphs queued for upload, and sets the\n     * appropriate glyphset for the cache entries.\n     */\n<fim_suffix>    protected List<XRGlyphCacheEntry>[] seperateGlyphTypes(List<XRGlyphCacheEntry> glyphList, boolean containsLCDGlyphs) {\n        ArrayList<XRGlyphCacheEntry> lcdGlyphs = null;\n        ArrayList<XRGlyphCacheEntry> grayGlyphs = null;\n        for (XRGlyphCacheEntry cacheEntry : glyphList) {\n            if (cacheEntry.isGrayscale(containsLCDGlyphs)) {\n                if (grayGlyphs == null) {\n                    grayGlyphs = new ArrayList<>(glyphList.size());\n                }\n                cacheEntry.setGlyphSet(grayGlyphSet);\n                grayGlyphs.add(cacheEntry);\n            } else {\n                if (lcdGlyphs == null) {\n                    lcdGlyphs = new ArrayList<>(glyphList.size());\n                }\n                cacheEntry.setGlyphSet(lcdGlyphSet);\n                lcdGlyphs.add(cacheEntry);\n            }\n        }\n        // Arrays and generics don't play well together\n        @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n        List<XRGlyphCacheEntry>[] tmp =\n            (List<XRGlyphCacheEntry>[]) (new List[] { grayGlyphs, lcdGlyphs });\n        return tmp;\n    }\n    /**\n     * Copies the glyph-images into a continous buffer, required for uploading.\n     */\n    protected byte[] generateGlyphImageStream(List<XRGlyphCacheEntry> glyphList) {\n        boolean isLCDGlyph = glyphList.get(0).getGlyphSet() == lcdGlyphSet;\n        ByteArrayOutputStream stream = new ByteArrayOutputStream((isLCDGlyph ? 4 : 1) * 48 * glyphList.size());<fim_middle>// function below has no smell\n"}