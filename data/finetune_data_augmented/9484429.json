{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.hadoop.hdfs.server.federation.router;\n\nimport java.io.IOException;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\n\nimport com.google.common.annotations.VisibleForTesting;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.hdfs.server.federation.store.CachedRecordStore;\nimport org.apache.hadoop.hdfs.server.federation.store.MembershipStore;\nimport org.apache.hadoop.hdfs.server.federation.store.MountTableStore;\nimport org.apache.hadoop.hdfs.server.federation.store.RecordStore;\nimport org.apache.hadoop.hdfs.server.federation.store.RouterStore;\nimport org.apache.hadoop.hdfs.server.federation.store.StateStoreService;\nimport org.apache.hadoop.hdfs.server.federation.store.protocol.RouterHeartbeatRequest;\nimport org.apache.hadoop.hdfs.server.federation.store.protocol.RouterHeartbeatResponse;\nimport org.apache.hadoop.hdfs.server.federation.store.records.BaseRecord;\nimport org.apache.hadoop.hdfs.server.federation.store.records.RouterState;\nimport org.apache.hadoop.hdfs.server.federation.store.records.StateStoreVersion;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Service to periodically update the Router current state in the State Store.\n */\npublic class RouterHeartbeatService extends PeriodicService {\n\n  private static final Logger LOG =\n      LoggerFactory.getLogger(RouterHeartbeatService.class);\n\n  /** Router we are hearbeating. */\n  private final Router router;\n\n  /**\n   * Create a new Router heartbeat service.\n   *\n   * @param router Router to heartbeat.\n   */\n  public RouterHeartbeatService(Router router) {\n    super(RouterHeartbeatService.class.getSimpleName());\n    this.router = router;\n  }\n\n  /**\n   * Trigger the update of the Router state asynchronously.\n   */\n<fim_suffix>  protected void updateStateAsync() {\n    Thread thread = new Thread(new Runnable() {\n      @Override\n      public void run() {\n        updateStateStore();\n      }\n    }, \"Router Heartbeat Async\");\n    thread.setDaemon(true);\n    thread.start();\n  }\n\n  /**\n   * Update the state of the Router in the State Store.\n   */\n  @VisibleForTesting\n  synchronized void updateStateStore() {\n    String routerId = router.getRouterId();\n    if (routerId == null) {\n      LOG.error(\"Cannot heartbeat for router: unknown router id\");\n      return;\n    }\n    if (isStoreAvailable()) {\n      RouterStore routerStore = router.getRouterStateManager();\n      try {\n        RouterState record = RouterState.newInstance(\n            routerId, router.getStartTime(), router.getRouterState());\n        StateStoreVersion stateStoreVersion = StateStoreVersion.newInstance(\n            getStateStoreVersion(MembershipStore.class),\n            getStateStoreVersion(MountTableStore.class));\n        record.setStateStoreVersion(stateStoreVersion);\n        RouterHeartbeatRequest request =\n            RouterHeartbeatRequest.newInstance(record);\n        RouterHeartbeatResponse response = routerStore.routerHeartbeat(request);\n        if (!response.getStatus()) {\n          LOG.warn(\"Cannot heartbeat router {}\", routerId);\n        } else {\n          LOG.debug(\"Router heartbeat for router {}\", routerId);\n        }\n      } catch (IOException e) {\n        LOG.error(\"Cannot heartbeat router {}\", routerId, e);\n      }\n    } else {\n      LOG.warn(\"Cannot heartbeat router {}: State Store unavailable\", routerId);\n    }\n  }\n\n  /**\n   * Get the version of the data in the State Store.\n   *\n   * @param clazz Class in the State Store.\n   * @return Version of the data.\n   */\n  private <R extends BaseRecord, S extends RecordStore<R>>\n      long getStateStoreVersion(final Class<S> clazz) {\n    long version = -1;\n    try {\n      StateStoreService stateStore = router.getStateStore();\n      S recordStore = stateStore.getRegisteredRecordStore(clazz);\n      if (recordStore != null) {\n        if (recordStore instanceof CachedRecordStore) {\n          CachedRecordStore<R> cachedRecordStore =\n              (CachedRecordStore<R>) recordStore;\n          List<R> records = cachedRecordStore.getCachedRecords();\n          for (BaseRecord record : records) {\n            if (record.getDateModified() > version) {\n              version = record.getDateModified();\n            }\n          }\n        }\n      }\n    } catch (Exception e) {\n      LOG.error(\"Cannot get version for {}\", clazz, e);\n    }\n    return version;\n  }\n\n  @Override\n  protected void serviceInit(Configuration conf) throws Exception {\n\n    long interval = conf.getTimeDuration(\n        RBFConfigKeys.DFS_ROUTER_HEARTBEAT_STATE_INTERVAL_MS,\n        RBFConfigKeys.DFS_ROUTER_HEARTBEAT_STATE_INTERVAL_MS_DEFAULT,\n        TimeUnit.MILLISECONDS);\n    this.setIntervalMs(interval);\n\n    super.serviceInit(conf);\n  }\n\n  @Override\n  public void periodicInvoke() {\n    updateStateStore();\n  }\n\n  private boolean isStoreAvailable() {\n    if (router.getRouterStateManager() == null) {\n      return false;\n    }\n    if (router.getStateStore() == null) {\n      return false;\n    }\n    return router.getStateStore().isDriverReady();\n  }\n}<fim_middle>// function below has no smell\n"}