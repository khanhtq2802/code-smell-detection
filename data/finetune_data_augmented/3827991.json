{"text": "<fim_prefix> * the start, the DBF is a <code>1 * m</code> bit matrix, i.e., it is composed of a single standard\n * Bloom filter. It assumes that <code>n<sub>r</sub></code> elements are recorded in the initial bit\n * vector, where <code>n<sub>r</sub> &lt;= n</code> (<code>n</code> is the cardinality of the set\n * <code>A</code> to record in the filter).\n * <p>\n * As the size of <code>A</code> grows during the execution of the application, several keys must be\n * inserted in the DBF. When inserting a key into the DBF, one must first get an active Bloom filter\n * in the matrix. A Bloom filter is active when the number of recorded keys,\n * <code>n<sub>r</sub></code>, is strictly less than the current cardinality of <code>A</code>,\n * <code>n</code>. If an active Bloom filter is found, the key is inserted and\n * <code>n<sub>r</sub></code> is incremented by one. On the other hand, if there is no active Bloom\n * filter, a new one is created (i.e., a new row is added to the matrix) according to the current\n * size of <code>A</code> and the element is added in this new Bloom filter and the\n * <code>n<sub>r</sub></code> value of this new Bloom filter is set to one. A given key is said to\n * belong to the DBF if the <code>k</code> positions are set to one in one of the matrix rows.\n * <p>\n * Originally created by <a href=\"http://www.one-lab.org\">European Commission One-Lab Project\n * 034819</a>.\n *\n * @see Filter The general behavior of a filter\n * @see BloomFilter A Bloom filter\n *\n * @see <a href=\n *      \"http://www.cse.fau.edu/~jie/research/publications/Publication_files/infocom2006.pdf\">Theory\n *      and Network Applications of Dynamic Bloom Filters</a>\n */\n<fim_suffix>public class DynamicBloomFilter extends Filter {\n  /**\n   * Threshold for the maximum number of key to record in a dynamic Bloom filter row.\n   */\n  private int nr;\n  /**\n   * The number of keys recorded in the current standard active Bloom filter.\n   */\n  private int currentNbRecord;\n  /**\n   * The matrix of Bloom filter.\n   */\n  private BloomFilter[] matrix;\n  /**\n   * Zero-args constructor for the serialization.\n   */\n  public DynamicBloomFilter() {}\n  /**\n   * Constructor.\n   * <p>\n   * Builds an empty Dynamic Bloom filter.\n   *\n   * @param vectorSize\n   *          The number of bits in the vector.\n   * @param nbHash\n   *          The number of hash function to consider.\n   * @param hashType\n   *          type of the hashing function (see {@link org.apache.hadoop.util.hash.Hash}).\n   * @param nr\n   *          The threshold for the maximum number of keys to record in a dynamic Bloom filter row.\n   */\n  public DynamicBloomFilter(final int vectorSize, final int nbHash, final int hashType,\n      final int nr) {\n    super(vectorSize, nbHash, hashType);\n    this.nr = nr;\n    this.currentNbRecord = 0;\n    matrix = new BloomFilter[1];\n    matrix[0] = new BloomFilter(this.vectorSize, this.nbHash, this.hashType);\n  }\n  @Override\n  public boolean add(final Key key) {\n    if (key == null) {\n      throw new NullPointerException(\"Key can not be null\");\n    }\n    BloomFilter bf = getActiveStandardBF();\n    if (bf == null) {\n      addRow();\n      bf = matrix[matrix.length - 1];\n      currentNbRecord = 0;\n    }\n    boolean added = bf.add(key);\n    if (added)\n      currentNbRecord++;\n    return added;\n  }\n  @Override\n  public void and(final Filter filter) {\n    if (filter == null || !(filter instanceof DynamicBloomFilter)\n        || filter.vectorSize != this.vectorSize || filter.nbHash != this.nbHash) {\n      throw new IllegalArgumentException(\"filters cannot be and-ed\");\n    }\n    DynamicBloomFilter dbf = (DynamicBloomFilter) filter;\n    if (dbf.matrix.length != this.matrix.length || dbf.nr != this.nr) {\n      throw new IllegalArgumentException(\"filters cannot be and-ed\");\n    }\n    for (int i = 0; i < matrix.length; i++) {\n      matrix[i].and(dbf.matrix[i]);\n    }\n  }\n  @Override\n  public boolean membershipTest(final Key key) {\n    if (key == null) {\n      return true;\n    }\n    for (int i = 0; i < matrix.length; i++) {\n      if (matrix[i].membershipTest(key)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  @Override\n  public void not() {\n    for (int i = 0; i < matrix.length; i++) {\n      matrix[i].not();\n    }\n  }\n  @Override\n  public void or(final Filter filter) {\n    if (filter == null || !(filter instanceof DynamicBloomFilter)\n        || filter.vectorSize != this.vectorSize || filter.nbHash != this.nbHash) {\n      throw new IllegalArgumentException(\"filters cannot be or-ed\");\n    }\n    DynamicBloomFilter dbf = (DynamicBloomFilter) filter;\n    if (dbf.matrix.length != this.matrix.length || dbf.nr != this.nr) {\n      throw new IllegalArgumentException(\"filters cannot be or-ed\");\n    }\n    for (int i = 0; i < matrix.length; i++) {\n      matrix[i].or(dbf.matrix[i]);\n    }\n  }\n  @Override\n  public void xor(final Filter filter) {\n    if (filter == null || !(filter instanceof DynamicBloomFilter)\n        || filter.vectorSize != this.vectorSize || filter.nbHash != this.nbHash) {\n      throw new IllegalArgumentException(\"filters cannot be xor-ed\");\n    }\n    DynamicBloomFilter dbf = (DynamicBloomFilter) filter;\n    if (dbf.matrix.length != this.matrix.length || dbf.nr != this.nr) {\n      throw new IllegalArgumentException(\"filters cannot be xor-ed\");\n    }\n    for (int i = 0; i < matrix.length; i++) {\n      matrix[i].xor(dbf.matrix[i]);\n    }\n  }\n  @Override\n  public String toString() {\n    StringBuilder res = new StringBuilder();\n    for (int i = 0; i < matrix.length; i++) {\n      res.append(matrix[i]);\n      res.append(Character.LINE_SEPARATOR);\n    }\n    return res.toString();\n  }\n  // Writable\n  @Override\n  public void write(final DataOutput out) throws IOException {\n    super.write(out);\n    out.writeInt(nr);\n    out.writeInt(currentNbRecord);\n    out.writeInt(matrix.length);\n    for (int i = 0; i < matrix.length; i++) {\n      matrix[i].write(out);\n    }\n  }\n  @Override\n  public void readFields(final DataInput in) throws IOException {\n    super.readFields(in);\n    nr = in.readInt();\n    currentNbRecord = in.readInt();\n    int len = in.readInt();\n    matrix = new BloomFilter[len];\n    for (int i = 0; i < matrix.length; i++) {\n      matrix[i] = new BloomFilter();\n      matrix[i].readFields(in);\n    }\n  }\n  /**\n   * Adds a new row to <i>this</i> dynamic Bloom filter.\n   */\n  private void addRow() {\n    BloomFilter[] tmp = new BloomFilter[matrix.length + 1];\n    for (int i = 0; i < matrix.length; i++) {\n      tmp[i] = matrix[i];\n    }\n    tmp[tmp.length - 1] = new BloomFilter(vectorSize, nbHash, hashType);\n    matrix = tmp;\n  }\n  /**\n   * Returns the active standard Bloom filter in <i>this</i> dynamic Bloom filter.\n   *\n   * @return BloomFilter The active standard Bloom filter. <code>Null</code> otherwise.\n   */\n  private BloomFilter getActiveStandardBF() {\n    if (currentNbRecord >= nr) {\n      return null;\n    }\n    return matrix[matrix.length - 1];\n  }\n}<fim_middle>// class below has no smell\n"}