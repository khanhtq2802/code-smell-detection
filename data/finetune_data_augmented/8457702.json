{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.language.simple;\nimport java.util.List;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport org.apache.camel.language.simple.types.SimpleToken;\nimport org.apache.camel.language.simple.types.SimpleTokenType;\nimport org.apache.camel.language.simple.types.TokenType;\nimport org.apache.camel.util.ObjectHelper;\n/**\n * Tokenizer to create {@link SimpleToken} from the input.\n */\npublic final class SimpleTokenizer {\n    // use CopyOnWriteArrayList so we can modify it in the for loop when changing function start/end tokens\n    private static final List<SimpleTokenType> KNOWN_TOKENS = new CopyOnWriteArrayList<>();\n    // optimise to be able to quick check for start functions\n    private static final String[] FUNCTION_START = new String[]{\"${\", \"$simple{\"};\n    static {\n        // add known tokens\n        KNOWN_TOKENS.add(new SimpleTokenType(TokenType.functionStart, \"${\"));\n        KNOWN_TOKENS.add(new SimpleTokenType(TokenType.functionStart, \"$simple{\"));\n        KNOWN_TOKENS.add(new SimpleTokenType(TokenType.functionEnd, \"}\"));\n        KNOWN_TOKENS.add(new SimpleTokenType(TokenType.whiteSpace, \" \"));\n        KNOWN_TOKENS.add(new SimpleTokenType(TokenType.whiteSpace, \"\\t\"));\n        KNOWN_TOKENS.add(new SimpleTokenType(TokenType.whiteSpace, \"\\n\"));\n        KNOWN_TOKENS.add(new SimpleTokenType(TokenType.whiteSpace, \"\\r\"));\n        KNOWN_TOKENS.add(new SimpleTokenType(TokenType.singleQuote, \"'\"));\n        KNOWN_TOKENS.add(new SimpleTokenType(TokenType.doubleQuote, \"\\\"\"));\n        KNOWN_TOKENS.add(new SimpleTokenType(TokenType.booleanValue, \"true\"));\n        KNOWN_TOKENS.add(new SimpleTokenType(TokenType.booleanValue, \"false\"));\n        KNOWN_TOKENS.add(new SimpleTokenType(TokenType.nullValue, \"null\"));\n        KNOWN_TOKENS.add(new SimpleTokenType(TokenType.escape, \"\\\\\"));\n        // binary operators\n        KNOWN_TOKENS.add(new SimpleTokenType(TokenType.binaryOperator, \"==\"));\n        KNOWN_TOKENS.add(new SimpleTokenType(TokenType.binaryOperator, \"=~\"));\n        KNOWN_TOKENS.add(new SimpleTokenType(TokenType.binaryOperator, \">=\"));\n        KNOWN_TOKENS.add(new SimpleTokenType(TokenType.binaryOperator, \"<=\"));\n        KNOWN_TOKENS.add(new SimpleTokenType(TokenType.binaryOperator, \">\"));\n        KNOWN_TOKENS.add(new SimpleTokenType(TokenType.binaryOperator, \"<\"));\n        KNOWN_TOKENS.add(new SimpleTokenType(TokenType.binaryOperator, \"!=\"));\n        KNOWN_TOKENS.add(new SimpleTokenType(TokenType.binaryOperator, \"not is\"));\n        KNOWN_TOKENS.add(new SimpleTokenType(TokenType.binaryOperator, \"is\"));\n        KNOWN_TOKENS.add(new SimpleTokenType(TokenType.binaryOperator, \"not contains\"));\n        KNOWN_TOKENS.add(new SimpleTokenType(TokenType.binaryOperator, \"contains\"));\n        KNOWN_TOKENS.add(new SimpleTokenType(TokenType.binaryOperator, \"~~\"));\n        KNOWN_TOKENS.add(new SimpleTokenType(TokenType.binaryOperator, \"not regex\"));\n        KNOWN_TOKENS.add(new SimpleTokenType(TokenType.binaryOperator, \"regex\"));\n        KNOWN_TOKENS.add(new SimpleTokenType(TokenType.binaryOperator, \"not in\"));\n        KNOWN_TOKENS.add(new SimpleTokenType(TokenType.binaryOperator, \"in\"));\n        KNOWN_TOKENS.add(new SimpleTokenType(TokenType.binaryOperator, \"range\"));\n        KNOWN_TOKENS.add(new SimpleTokenType(TokenType.binaryOperator, \"not range\"));\n        KNOWN_TOKENS.add(new SimpleTokenType(TokenType.binaryOperator, \"starts with\"));\n        KNOWN_TOKENS.add(new SimpleTokenType(TokenType.binaryOperator, \"ends with\"));\n        // unary operators\n        KNOWN_TOKENS.add(new SimpleTokenType(TokenType.unaryOperator, \"++\"));\n        KNOWN_TOKENS.add(new SimpleTokenType(TokenType.unaryOperator, \"--\"));\n        // logical operators\n        KNOWN_TOKENS.add(new SimpleTokenType(TokenType.logicalOperator, \"&&\"));\n        KNOWN_TOKENS.add(new SimpleTokenType(TokenType.logicalOperator, \"||\"));\n        //binary operator \n        // it is added as the last item because unary -- has the priority\n        // if unary not found it is highly possible - operator is run into.\n        KNOWN_TOKENS.add(new SimpleTokenType(TokenType.minusValue, \"-\"));\n    }\n    private SimpleTokenizer() {\n        // static methods\n    }\n    /**\n     * Does the expression include a simple function.\n     *\n     * @param expression the expression\n     * @return <tt>true</tt> if one or more simple function is included in the expression\n     */\n    public static boolean hasFunctionStartToken(String expression) {\n        if (expression != null) {\n            return expression.contains(FUNCTION_START[0]) || expression.contains(FUNCTION_START[1]);\n        }\n        return false;\n    }\n    /**\n     * @see SimpleLanguage#changeFunctionStartToken(String...)\n     */\n    public static void changeFunctionStartToken(String... startToken) {\n        for (SimpleTokenType type : KNOWN_TOKENS) {\n            if (type.getType() == TokenType.functionStart) {\n                KNOWN_TOKENS.remove(type);\n            }\n        }\n        if (startToken.length > 2) {\n            throw new IllegalArgumentException(\"At most 2 start tokens is allowed\");\n        }\n        // reset\n        FUNCTION_START[0] = \"\";\n        FUNCTION_START[1] = \"\";\n        // add in start of list as its a more common token to be used\n        for (int i = 0; i < startToken.length; i++) {\n            String token = startToken[i];\n            FUNCTION_START[i] = token;\n            KNOWN_TOKENS.add(0, new SimpleTokenType(TokenType.functionStart, token));\n        }\n    }\n    /**\n     * @see SimpleLanguage#changeFunctionEndToken(String...)\n     */\n<fim_suffix>    public static void changeFunctionEndToken(String... endToken) {\n        for (SimpleTokenType type : KNOWN_TOKENS) {\n            if (type.getType() == TokenType.functionEnd) {\n                KNOWN_TOKENS.remove(type);\n            }\n        }\n        // add after the start tokens\n        int pos = 0;\n        for (SimpleTokenType type : KNOWN_TOKENS) {\n            if (type.getType() == TokenType.functionStart) {\n                pos++;\n            }\n        }\n        // add after function start of list as its a more common token to be used\n        for (String token : endToken) {\n            KNOWN_TOKENS.add(pos, new SimpleTokenType(TokenType.functionEnd, token));\n        }\n    }\n    /**\n     * Create the next token\n     *\n     * @param expression  the input expression\n     * @param index       the current index\n     * @param allowEscape whether to allow escapes\n     * @param filter      defines the accepted token types to be returned (character is always used as fallback)\n     * @return the created token, will always return a token\n     */\n    public static SimpleToken nextToken(String expression, int index, boolean allowEscape, TokenType... filter) {\n        return doNextToken(expression, index, allowEscape, filter);\n    }\n    /**\n     * Create the next token\n     *\n     * @param expression  the input expression\n     * @param index       the current index\n     * @param allowEscape whether to allow escapes\n     * @return the created token, will always return a token\n     */\n    public static SimpleToken nextToken(String expression, int index, boolean allowEscape) {\n        return doNextToken(expression, index, allowEscape);\n    }\n    private static SimpleToken doNextToken(String expression, int index, boolean allowEscape, TokenType... filters) {\n        boolean numericAllowed = acceptType(TokenType.numericValue, filters);\n        if (numericAllowed) {\n            // is it a numeric value\n            StringBuilder sb = new StringBuilder();<fim_middle>// function below has no smell\n"}