{"text": "<fim_prefix> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.template.soy.passes;\nimport static com.google.common.base.Preconditions.checkState;\nimport com.google.common.base.Optional;\nimport com.google.common.base.Preconditions;\nimport com.google.template.soy.base.SourceLocation;\nimport com.google.template.soy.base.internal.IdGenerator;\nimport com.google.template.soy.error.ErrorReporter;\nimport com.google.template.soy.error.SoyErrorKind;\nimport com.google.template.soy.exprtree.AbstractExprNodeVisitor;\nimport com.google.template.soy.exprtree.ExprNode;\nimport com.google.template.soy.exprtree.ExprNode.ParentExprNode;\nimport com.google.template.soy.exprtree.ExprRootNode;\nimport com.google.template.soy.exprtree.GlobalNode;\nimport com.google.template.soy.exprtree.VarDefn;\nimport com.google.template.soy.exprtree.VarRefNode;\nimport com.google.template.soy.soytree.AbstractSoyNodeVisitor;\nimport com.google.template.soy.soytree.ForNonemptyNode;\nimport com.google.template.soy.soytree.LetContentNode;\nimport com.google.template.soy.soytree.LetValueNode;\nimport com.google.template.soy.soytree.PrintNode;\nimport com.google.template.soy.soytree.SoyFileNode;\nimport com.google.template.soy.soytree.SoyNode;\nimport com.google.template.soy.soytree.SoyNode.BlockNode;\nimport com.google.template.soy.soytree.SoyNode.ExprHolderNode;\nimport com.google.template.soy.soytree.SoyNode.ParentSoyNode;\nimport com.google.template.soy.soytree.TemplateElementNode;\nimport com.google.template.soy.soytree.TemplateNode;\nimport com.google.template.soy.soytree.defn.LocalVar;\nimport com.google.template.soy.soytree.defn.LoopVar;\nimport com.google.template.soy.soytree.defn.TemplateParam;\nimport com.google.template.soy.soytree.defn.TemplateStateVar;\nimport com.google.template.soy.soytree.defn.UndeclaredVar;\nimport java.util.ArrayDeque;\nimport java.util.BitSet;\nimport java.util.Deque;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n/**\n * Visitor which resolves all variable and parameter references to point to the corresponding\n * declaration object.\n *\n */\npublic final class ResolveNamesPass extends CompilerFilePass {\n  private static final SoyErrorKind GLOBAL_MATCHES_VARIABLE =\n      SoyErrorKind.of(\n          \"Found global reference aliasing a local variable ''{0}'', did you mean ''${0}''?\");\n  private static final SoyErrorKind VARIABLE_ALREADY_DEFINED =\n      SoyErrorKind.of(\"Variable ''${0}'' already defined{1}.\");\n  /**\n   * A data structure that assigns a unique (small) integer to all local variable definitions that\n   * are active within a given lexical scope.\n   *\n   * <p>A 'slot' is a small integer that is assigned to a {@link VarDefn} such that at any given\n   * point of execution while that variable could be referenced there is only one variable with that\n   * index.\n   */\n<fim_suffix>  private final class LocalVariables {\n    private final BitSet availableSlots = new BitSet();\n    private final Deque<Map<String, VarDefn>> currentScope = new ArrayDeque<>();\n    private final BitSet slotsToRelease = new BitSet();\n    /** Tracks the next unused slot to claim. */\n    private int nextSlotToClaim = 0;\n    /**\n     * A counter that tracks when to release the {@link #slotsToRelease} set.\n     *\n     * <p>We add {@link #slotsToRelease} to {@link #availableSlots} only when exiting a scope if\n     * this value == 0.\n     */\n    private int activeLazySlots = 0;\n    /**\n     * Enters a new scope. Variables {@link #define defined} will have a lifetime that extends until\n     * a matching call to {@link #exitScope()}.\n     */\n    void enterScope() {\n      currentScope.push(new LinkedHashMap<String, VarDefn>());\n    }\n    /**\n     * Enters a new scope.\n     *\n     * <p>Variables defined in a lazy scope have a lifetime that extends to the matching {@link\n     * #exitLazyScope()} call, but the variable slots reserved have their lifetimes extended until\n     * the parent scope closes.\n     */\n    void enterLazyScope() {\n      activeLazySlots++;\n      enterScope();\n    }\n    /** Exits the current scope. */\n    void exitLazyScope() {\n      checkState(activeLazySlots > 0, \"Exiting a lazy scope when we aren't in one\");\n      exitScope();\n      activeLazySlots--;\n    }\n    /**\n     * Exits the current lazy scope.\n     *\n     * <p>This releases all the variable indices associated with the variables defined in this frame\n     * so that they can be reused.\n     */\n    void exitScope() {\n      Map<String, VarDefn> variablesGoingOutOfScope = currentScope.pop();\n      for (VarDefn var : variablesGoingOutOfScope.values()) {\n        if (var instanceof LoopVar) {\n          LoopVar loopVar = (LoopVar) var;\n          slotsToRelease.set(loopVar.currentLoopIndexIndex());\n          slotsToRelease.set(loopVar.isLastIteratorIndex());\n        }\n        slotsToRelease.set(var.localVariableIndex());\n      }\n      if (activeLazySlots == 0) {\n        availableSlots.or(slotsToRelease);\n        slotsToRelease.clear();\n      }\n    }\n    /**\n     * Returns the {@link VarDefn} associated with the given name by searching through the current\n     * scope and all parent scopes.\n     */\n    VarDefn lookup(String name) {\n      for (Map<String, VarDefn> scope : currentScope) {\n        VarDefn defn = scope.get(name);\n        if (defn != null) {\n          return defn;\n        }\n      }\n      return null;\n    }\n    /**\n     * Defines a {@link LoopVar}. Unlike normal local variables and params loop variables get 2\n     * extra implicit local variables for tracking the current index and whether or not we are at\n     * the last index.\n     */\n    boolean define(LoopVar defn, SoyNode definingNode) {\n      if (!define((VarDefn) defn, definingNode)) {\n        return false;\n      }\n      // only allocate the extra slots if definition succeeded\n      defn.setExtraLoopIndices(claimSlot(), claimSlot());\n      return true;\n    }\n    /** Defines a variable. */\n    boolean define(VarDefn defn, SoyNode definingNode) {\n      // Search for the name to see if it is being redefined.\n      VarDefn preexisting = lookup(defn.name());\n      if (preexisting != null) {\n        Optional<SourceLocation> sourceLocation = forVarDefn(preexisting);\n        String location =\n            sourceLocation.isPresent() ? \" at line \" + sourceLocation.get().getBeginLine() : \"\";\n        errorReporter.report(\n            definingNode.getSourceLocation(), VARIABLE_ALREADY_DEFINED, defn.name(), location);\n        return false;\n      }\n      currentScope.peek().put(defn.name(), defn);\n      defn.setLocalVariableIndex(claimSlot());\n      return true;\n    }\n    /**\n     * Returns the smallest available local variable slot or claims a new one if there is none\n     * available.\n     */\n    private int claimSlot() {\n      int nextSetBit = availableSlots.nextSetBit(0);\n      int slotToUse;\n      if (nextSetBit != -1) {\n        slotToUse = nextSetBit;\n        availableSlots.clear(nextSetBit);\n      } else {\n        slotToUse = nextSlotToClaim;\n        nextSlotToClaim++;\n      }\n      return slotToUse;\n    }\n    void verify() {\n      checkState(activeLazySlots == 0, \"%s lazy scope(s) are still active\", activeLazySlots);\n      checkState(slotsToRelease.isEmpty(), \"%s slots are waiting to be released\", slotsToRelease);\n      BitSet unavailableSlots = new BitSet(nextSlotToClaim);\n      unavailableSlots.set(0, nextSlotToClaim);\n      // now the only bits on will be the ones where available slots has '0'.\n      unavailableSlots.xor(availableSlots);\n      checkState(\n          unavailableSlots.isEmpty(), \"Expected all slots to be available: %s\", unavailableSlots);\n    }\n  }<fim_middle>// class below has no smell\n"}