{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.math4.ode.nonstiff;\nimport java.util.Arrays;\nimport org.apache.commons.math4.RealFieldElement;\nimport org.apache.commons.math4.linear.Array2DRowFieldMatrix;\nimport org.apache.commons.math4.ode.FieldEquationsMapper;\nimport org.apache.commons.math4.ode.FieldODEStateAndDerivative;\nimport org.apache.commons.math4.ode.sampling.AbstractFieldStepInterpolator;\nimport org.apache.commons.math4.util.MathArrays;\n/**\n * This class implements an interpolator for Adams integrators using Nordsieck representation.\n *\n * <p>This interpolator computes dense output around the current point.\n * The interpolation equation is based on Taylor series formulas.\n *\n * @see AdamsBashforthFieldIntegrator\n * @see AdamsMoultonFieldIntegrator\n * @param <T> the type of the field elements\n * @since 3.6\n */\nclass AdamsFieldStepInterpolator<T extends RealFieldElement<T>> extends AbstractFieldStepInterpolator<T> {\n    /** Step size used in the first scaled derivative and Nordsieck vector. */\n    private T scalingH;\n    /** Reference state.\n     * <p>Sometimes, the reference state is the same as globalPreviousState,\n     * sometimes it is the same as globalCurrentState, so we use a separate\n     * field to avoid any confusion.\n     * </p>\n     */\n    private final FieldODEStateAndDerivative<T> reference;\n    /** First scaled derivative. */\n    private final T[] scaled;\n    /** Nordsieck vector. */\n    private final Array2DRowFieldMatrix<T> nordsieck;\n    /** Simple constructor.\n     * @param stepSize step size used in the scaled and Nordsieck arrays\n     * @param reference reference state from which Taylor expansion are estimated\n     * @param scaled first scaled derivative\n     * @param nordsieck Nordsieck vector\n     * @param isForward integration direction indicator\n     * @param globalPreviousState start of the global step\n     * @param globalCurrentState end of the global step\n     * @param equationsMapper mapper for ODE equations primary and secondary components\n     */\n<fim_suffix>    AdamsFieldStepInterpolator(final T stepSize, final FieldODEStateAndDerivative<T> reference,\n                               final T[] scaled, final Array2DRowFieldMatrix<T> nordsieck,\n                               final boolean isForward,\n                               final FieldODEStateAndDerivative<T> globalPreviousState,\n                               final FieldODEStateAndDerivative<T> globalCurrentState,\n                               final FieldEquationsMapper<T> equationsMapper) {\n        this(stepSize, reference, scaled, nordsieck,\n             isForward, globalPreviousState, globalCurrentState,\n             globalPreviousState, globalCurrentState, equationsMapper);\n    }\n    /** Simple constructor.\n     * @param stepSize step size used in the scaled and Nordsieck arrays\n     * @param reference reference state from which Taylor expansion are estimated\n     * @param scaled first scaled derivative\n     * @param nordsieck Nordsieck vector\n     * @param isForward integration direction indicator\n     * @param globalPreviousState start of the global step\n     * @param globalCurrentState end of the global step\n     * @param softPreviousState start of the restricted step\n     * @param softCurrentState end of the restricted step\n     * @param equationsMapper mapper for ODE equations primary and secondary components\n     */\n    private AdamsFieldStepInterpolator(final T stepSize, final FieldODEStateAndDerivative<T> reference,\n                                       final T[] scaled, final Array2DRowFieldMatrix<T> nordsieck,\n                                       final boolean isForward,\n                                       final FieldODEStateAndDerivative<T> globalPreviousState,\n                                       final FieldODEStateAndDerivative<T> globalCurrentState,\n                                       final FieldODEStateAndDerivative<T> softPreviousState,\n                                       final FieldODEStateAndDerivative<T> softCurrentState,\n                                       final FieldEquationsMapper<T> equationsMapper) {\n        super(isForward, globalPreviousState, globalCurrentState,\n              softPreviousState, softCurrentState, equationsMapper);\n        this.scalingH  = stepSize;\n        this.reference = reference;\n        this.scaled    = scaled.clone();\n        this.nordsieck = new Array2DRowFieldMatrix<>(nordsieck.getData(), false);\n    }\n    /** Create a new instance.\n     * @param newForward integration direction indicator\n     * @param newGlobalPreviousState start of the global step\n     * @param newGlobalCurrentState end of the global step\n     * @param newSoftPreviousState start of the restricted step\n     * @param newSoftCurrentState end of the restricted step\n     * @param newMapper equations mapper for the all equations\n     * @return a new instance\n     */\n    @Override\n    protected AdamsFieldStepInterpolator<T> create(boolean newForward,\n                                                   FieldODEStateAndDerivative<T> newGlobalPreviousState,\n                                                   FieldODEStateAndDerivative<T> newGlobalCurrentState,\n                                                   FieldODEStateAndDerivative<T> newSoftPreviousState,\n                                                   FieldODEStateAndDerivative<T> newSoftCurrentState,\n                                                   FieldEquationsMapper<T> newMapper) {\n        return new AdamsFieldStepInterpolator<>(scalingH, reference, scaled, nordsieck,\n                                                 newForward,\n                                                 newGlobalPreviousState, newGlobalCurrentState,\n                                                 newSoftPreviousState, newSoftCurrentState,\n                                                 newMapper);\n    }\n    /** {@inheritDoc} */\n    @Override\n    protected FieldODEStateAndDerivative<T> computeInterpolatedStateAndDerivatives(final FieldEquationsMapper<T> equationsMapper,\n                                                                                   final T time, final T theta,\n                                                                                   final T thetaH, final T oneMinusThetaH) {\n        return taylor(reference, time, scalingH, scaled, nordsieck);\n    }\n    /** Estimate state by applying Taylor formula.\n     * @param reference reference state\n     * @param time time at which state must be estimated\n     * @param stepSize step size used in the scaled and Nordsieck arrays\n     * @param scaled first scaled derivative\n     * @param nordsieck Nordsieck vector\n     * @return estimated state\n     * @param <S> the type of the field elements\n     */\n    public static <S extends RealFieldElement<S>> FieldODEStateAndDerivative<S> taylor(final FieldODEStateAndDerivative<S> reference,\n                                                                                       final S time, final S stepSize,\n                                                                                       final S[] scaled,\n                                                                                       final Array2DRowFieldMatrix<S> nordsieck) {\n        final S x = time.subtract(reference.getTime());\n        final S normalizedAbscissa = x.divide(stepSize);\n        S[] stateVariation = MathArrays.buildArray(time.getField(), scaled.length);\n        Arrays.fill(stateVariation, time.getField().getZero());\n        S[] estimatedDerivatives = MathArrays.buildArray(time.getField(), scaled.length);\n        Arrays.fill(estimatedDerivatives, time.getField().getZero());\n        // apply Taylor formula from high order to low order,\n        // for the sake of numerical accuracy\n        final S[][] nData = nordsieck.getDataRef();\n        for (int i = nData.length - 1; i >= 0; --i) {\n            final int order = i + 2;\n            final S[] nDataI = nData[i];\n            final S power = normalizedAbscissa.pow(order);\n            for (int j = 0; j < nDataI.length; ++j) {\n                final S d = nDataI[j].multiply(power);\n                stateVariation[j]          = stateVariation[j].add(d);\n                estimatedDerivatives[j] = estimatedDerivatives[j].add(d.multiply(order));\n            }\n        }\n        S[] estimatedState = reference.getState();\n        for (int j = 0; j < stateVariation.length; ++j) {\n            stateVariation[j]    = stateVariation[j].add(scaled[j].multiply(normalizedAbscissa));\n            estimatedState[j] = estimatedState[j].add(stateVariation[j]);\n            estimatedDerivatives[j] =\n                estimatedDerivatives[j].add(scaled[j].multiply(normalizedAbscissa)).divide(x);\n        }<fim_middle>// function below has no smell\n"}