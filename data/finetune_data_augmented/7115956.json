{"text": "<fim_prefix>        }\n        /**\n         * Get the number of records in the bucket.\n         *\n         * @return number of records in bucket\n         */\n        public int size() {\n            return records == null ? 0 : records.size();\n        }\n        /**\n         * Iterator over the records in the bucket\n         */\n        @Override\n        public Iterator<Record<V>> iterator() {\n            if (records == null) {\n                return Collections.<Record<V>>emptyList().iterator();\n            }\n            return records.iterator();\n        }\n        /**\n         * Standard toString()\n         */\n        @Override\n        public String toString() {\n            return \"{\" +\n            \"labelType=\" + labelType\n            + \", \" +\n            \"lowerBoundary=\" + lowerBoundary\n            + \", \" +\n            \"label=\" + label\n            + \"}\"\n            ;\n        }\n    }\n    private BucketList<V> createBucketList() {\n        // Initialize indexCharacters.\n        List<String> indexCharacters = initLabels();\n        // Variables for hasMultiplePrimaryWeights().\n        long variableTop;\n        if (collatorPrimaryOnly.isAlternateHandlingShifted()) {\n            variableTop = collatorPrimaryOnly.getVariableTop() & 0xffffffffL;\n        } else {\n            variableTop = 0;\n        }\n        boolean hasInvisibleBuckets = false;\n        // Helper arrays for Chinese Pinyin collation.\n        @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n        Bucket<V>[] asciiBuckets = new Bucket[26];\n        @SuppressWarnings({ \"rawtypes\", \"unchecked\" })\n        Bucket<V>[] pinyinBuckets = new Bucket[26];\n        boolean hasPinyin = false;\n        ArrayList<Bucket<V>> bucketList = new ArrayList<Bucket<V>>();\n        // underflow bucket\n        bucketList.add(new Bucket<V>(getUnderflowLabel(), \"\", LabelType.UNDERFLOW));\n        // fix up the list, adding underflow, additions, overflow\n        // Insert inflow labels as needed.\n        int scriptIndex = -1;\n        String scriptUpperBoundary = \"\";\n        for (String current : indexCharacters) {\n            if (collatorPrimaryOnly.compare(current, scriptUpperBoundary) >= 0) {\n                // We crossed the script boundary into a new script.\n                String inflowBoundary = scriptUpperBoundary;\n                boolean skippedScript = false;\n                for (;;) {\n                    scriptUpperBoundary = firstCharsInScripts.get(++scriptIndex);\n                    if (collatorPrimaryOnly.compare(current, scriptUpperBoundary) < 0) {\n                        break;\n                    }\n                    skippedScript = true;\n                }\n                if (skippedScript && bucketList.size() > 1) {\n                    // We are skipping one or more scripts,\n                    // and we are not just getting out of the underflow label.\n                    bucketList.add(new Bucket<V>(getInflowLabel(), inflowBoundary,\n                            LabelType.INFLOW));\n                }\n            }\n            // Add a bucket with the current label.\n            Bucket<V> bucket = new Bucket<V>(fixLabel(current), current, LabelType.NORMAL);\n            bucketList.add(bucket);\n            // Remember ASCII and Pinyin buckets for Pinyin redirects.\n            char c;\n            if (current.length() == 1 && 'A' <= (c = current.charAt(0)) && c <= 'Z') {\n                asciiBuckets[c - 'A'] = bucket;\n            } else if (current.length() == BASE.length() + 1 && current.startsWith(BASE) &&\n                    'A' <= (c = current.charAt(BASE.length())) && c <= 'Z') {\n                pinyinBuckets[c - 'A'] = bucket;\n                hasPinyin = true;\n            }\n            // Check for multiple primary weights.\n            if (!current.startsWith(BASE) &&\n                    hasMultiplePrimaryWeights(collatorPrimaryOnly, variableTop, current) &&\n                    !current.endsWith(\"\\uffff\")) {\n                // \"\u00c6\" or \"Sch\" etc.\n                for (int i = bucketList.size() - 2;; --i) {\n                    Bucket<V> singleBucket = bucketList.get(i);\n                    if (singleBucket.labelType != LabelType.NORMAL) {\n                        // There is no single-character bucket since the last\n                        // underflow or inflow label.\n                        break;\n                    }\n                    if (singleBucket.displayBucket == null &&\n                            !hasMultiplePrimaryWeights(collatorPrimaryOnly, variableTop, singleBucket.lowerBoundary)) {\n                        // Add an invisible bucket that redirects strings greater than the expansion\n                        // to the previous single-character bucket.\n                        // For example, after ... Q R S Sch we add Sch\\uFFFF->S\n                        // and after ... Q R S Sch Sch\\uFFFF St we add St\\uFFFF->S.\n                        bucket = new Bucket<V>(\"\", current + \"\\uFFFF\", LabelType.NORMAL);\n                        bucket.displayBucket = singleBucket;\n                        bucketList.add(bucket);\n                        hasInvisibleBuckets = true;\n                        break;\n                    }\n                }\n            }\n        }\n        if (bucketList.size() == 1) {\n            // No real labels, show only the underflow label.\n            return new BucketList<V>(bucketList, bucketList);\n        }\n        // overflow bucket\n        bucketList.add(new Bucket<V>(getOverflowLabel(), scriptUpperBoundary, LabelType.OVERFLOW)); // final\n        if (hasPinyin) {\n            // Redirect Pinyin buckets.\n            Bucket<V> asciiBucket = null;\n            for (int i = 0; i < 26; ++i) {\n                if (asciiBuckets[i] != null) {\n                    asciiBucket = asciiBuckets[i];\n                }\n                if (pinyinBuckets[i] != null && asciiBucket != null) {\n                    pinyinBuckets[i].displayBucket = asciiBucket;\n                    hasInvisibleBuckets = true;\n                }\n            }\n        }\n        if (!hasInvisibleBuckets) {\n            return new BucketList<V>(bucketList, bucketList);\n        }\n        // Merge inflow buckets that are visually adjacent.\n        // Iterate backwards: Merge inflow into overflow rather than the other way around.\n        int i = bucketList.size() - 1;\n        Bucket<V> nextBucket = bucketList.get(i);\n        while (--i > 0) {\n            Bucket<V> bucket = bucketList.get(i);\n            if (bucket.displayBucket != null) {\n                continue;  // skip invisible buckets\n            }\n            if (bucket.labelType == LabelType.INFLOW) {\n                if (nextBucket.labelType != LabelType.NORMAL) {\n                    bucket.displayBucket = nextBucket;\n                    continue;\n                }\n            }\n            nextBucket = bucket;\n        }\n        ArrayList<Bucket<V>> publicBucketList = new ArrayList<Bucket<V>>();\n        for (Bucket<V> bucket : bucketList) {\n            if (bucket.displayBucket == null) {\n                publicBucketList.add(bucket);\n            }\n        }\n        return new BucketList<V>(bucketList, publicBucketList);\n    }\n<fim_suffix>    private static class BucketList<V> implements Iterable<Bucket<V>> {\n        private final ArrayList<Bucket<V>> bucketList;\n        private final List<Bucket<V>> immutableVisibleList;\n        private BucketList(ArrayList<Bucket<V>> bucketList, ArrayList<Bucket<V>> publicBucketList) {\n            this.bucketList = bucketList;\n            int displayIndex = 0;\n            for (Bucket<V> bucket : publicBucketList) {\n                bucket.displayIndex = displayIndex++;\n            }\n            immutableVisibleList = Collections.unmodifiableList(publicBucketList);\n        }\n        private int getBucketCount() {\n            return immutableVisibleList.size();\n        }\n        private int getBucketIndex(CharSequence name, Collator collatorPrimaryOnly) {\n            // binary search\n            int start = 0;\n            int limit = bucketList.size();\n            while ((start + 1) < limit) {\n                int i = (start + limit) / 2;\n                Bucket<V> bucket = bucketList.get(i);\n                int nameVsBucket = collatorPrimaryOnly.compare(name, bucket.lowerBoundary);\n                if (nameVsBucket < 0) {\n                    limit = i;\n                } else {\n                    start = i;\n                }\n            }\n            Bucket<V> bucket = bucketList.get(start);\n            if (bucket.displayBucket != null) {\n                bucket = bucket.displayBucket;\n            }\n            return bucket.displayIndex;\n        }\n        /**\n         * Private iterator over all the buckets, visible and invisible\n         */\n        private Iterator<Bucket<V>> fullIterator() {\n            return bucketList.iterator();\n        }\n        /**\n         * Iterator over just the visible buckets.\n         */\n        @Override\n        public Iterator<Bucket<V>> iterator() {\n            return immutableVisibleList.iterator(); // use immutable list to prevent remove().\n        }\n    }<fim_middle>// class below is blob\n"}