{"text": "<fim_prefix>/*******************************************************************************\n * Copyright (c) 2015, 2017 Red Hat, Inc. \n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * \tContributors:\n * \t\t Red Hat Inc. - initial API and implementation and/or initial documentation\n * \t\t IBM Corporation - initial API and implementation\n *******************************************************************************/\npackage org.eclipse.thym.core.internal.cordova;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Map;\n\nimport org.eclipse.core.externaltools.internal.IExternalToolConstants;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IProgressMonitor;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.Status;\nimport org.eclipse.debug.core.DebugPlugin;\nimport org.eclipse.debug.core.ILaunchConfiguration;\nimport org.eclipse.debug.core.ILaunchConfigurationType;\nimport org.eclipse.debug.core.ILaunchConfigurationWorkingCopy;\nimport org.eclipse.debug.core.ILaunchManager;\nimport org.eclipse.debug.core.IStreamListener;\nimport org.eclipse.debug.core.model.IProcess;\nimport org.eclipse.debug.core.model.IStreamsProxy;\nimport org.eclipse.thym.core.HybridCore;\nimport org.eclipse.thym.core.internal.util.ExternalProcessUtility;\n\n/**\n * Wrapper around Cordova CLI. Provides low level \n * access to Cordova CLI.\n *\n *@author Gorkem Ercan\n *\n */\n@SuppressWarnings(\"restriction\")\npublic class CordovaCLI {\n\t\n\tprivate Map<String,String> additionalEnvProps;\n\t\n\tpublic CordovaCLI(){\n\t\tadditionalEnvProps = HybridCore.getEnvVariables();\n\t}\n\t\n<fim_suffix>\tpublic CordovaCLIResult version(final IProgressMonitor monitor) throws CoreException{\n\t\tfinal CordovaCLIStreamListener streamListener = new CordovaCLIStreamListener();\n\t\tIProcess process = startShell(streamListener, monitor, getLaunchConfiguration(\"cordova -version\"));\n\t\tString cordovaCommand = \"cordova -version\\n\";\n\t\tsendCordovaCommand(process, cordovaCommand, monitor);\n\t\tCordovaCLIResult result = new CordovaCLIResult(streamListener.getMessage());\n\t\treturn result;\t\t\n\t}\n\t\n\tpublic CordovaCLIResult nodeVersion(final IProgressMonitor monitor) throws CoreException{\n\t\tfinal CordovaCLIStreamListener streamListener = new CordovaCLIStreamListener();\n\t\tIProcess process = startShell(streamListener, monitor, getLaunchConfiguration(\"node -v\"));\n\t\tString command = \"node -v\\n\";\n\t\tsendCordovaCommand(process, command, monitor);\n\t\tCordovaCLIResult result= new CordovaCLIResult(streamListener.getMessage());\n\t\treturn result;\n\t}\n\n\tprotected void sendCordovaCommand(final IProcess process, final String cordovaCommand,\n\t\t\tfinal IProgressMonitor monitor) throws CoreException {\n\t\ttry {\n\t\t\tfinal IStreamsProxy streamProxy = process.getStreamsProxy();\n\t\t\tstreamProxy.write(cordovaCommand.toString());\n\t\t\twhile (!process.isTerminated()) {\n\t\t\t\t//exit the shell after sending the command\n\t\t\t\ttry{\n\t\t\t\t\tstreamProxy.write(\"exit\\n\");\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t//ignore\n\t\t\t\t}\n\t\t\t\tif (monitor.isCanceled()) {\n\t\t\t\t\tprocess.terminate();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tThread.sleep(50);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new CoreException(new Status(IStatus.ERROR, HybridCore.PLUGIN_ID, \"Fatal error invoking cordova CLI\", e));\n\t\t} catch (InterruptedException e) {\n\t\t\tHybridCore.log(IStatus.INFO, \"Exception waiting for process to terminate\", e);\n\t\t}\n\t}\n\t\n\t//public visibility to support testing\n\tpublic IProcess startShell(final IStreamListener listener, final IProgressMonitor monitor, \n\t\t\tfinal ILaunchConfiguration launchConfiguration) throws CoreException{\n\t\tArrayList<String> commandList = new ArrayList<String>();\n\t\tif(isWindows()){\n\t\t\tcommandList.add(\"cmd\");\n\t\t}else{\n\t\t\tcommandList.add(\"/bin/bash\");\n\t\t\tcommandList.add(\"-l\");\n\t\t}\n\t\t\n\t\tExternalProcessUtility ep = new ExternalProcessUtility();\n\t\tIProcess process = ep.exec(commandList.toArray(new String[commandList.size()]), getWorkingDirectory(), \n\t\t\t\tmonitor, null, launchConfiguration, listener, listener);\n\t\t return process;\n\t}\n\t\n\tprotected boolean isWindows(){\n\t\tString OS = System.getProperty(\"os.name\",\"unknown\");\n\t\treturn OS.toLowerCase().indexOf(\"win\")>-1;\n\t}\n\t\n\tprotected ILaunchConfiguration getLaunchConfiguration(String label){\n\t\tILaunchManager manager = DebugPlugin.getDefault().getLaunchManager();\n\t\tILaunchConfigurationType type = manager.getLaunchConfigurationType(IExternalToolConstants.ID_PROGRAM_LAUNCH_CONFIGURATION_TYPE);\n\t\ttry {\n\t\t\tILaunchConfiguration cfg = type.newInstance(null, \"cordova\");\n\t\t\tILaunchConfigurationWorkingCopy wc = cfg.getWorkingCopy();\n\t\t\twc.setAttribute(IProcess.ATTR_PROCESS_LABEL, label);\n\t\t\tif(additionalEnvProps != null && !additionalEnvProps.isEmpty()){\n\t\t\t\twc.setAttribute(ILaunchManager.ATTR_ENVIRONMENT_VARIABLES,additionalEnvProps);\n\t\t\t}\n\t\t\tcfg = wc.doSave();\n\t\t\treturn cfg;\n\t\t} catch (CoreException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tprotected File getWorkingDirectory(){\n\t\treturn null;\n\t}\n}<fim_middle>// function below has no smell\n"}