{"text": "<fim_prefix>        buf.append(\" ON \");\n        k = 0;\n        for (IntPair pair : node1.link) {\n          if (k++ > 0) {\n            buf.append(\" AND \");\n          }\n          final Column left = columns.get(node1.parent.startCol + pair.source);\n          left.toSql(w);\n          buf.append(\" = \");\n          final Column right = columns.get(node.startCol + pair.target);\n          right.toSql(w);\n        }\n      }\n    }\n    if (CalciteSystemProperty.DEBUG.value()) {\n      System.out.println(\"Lattice SQL:\\n\"\n          + buf);\n    }\n    if (group) {\n      if (groupSet.isEmpty()) {\n        groupBuf.append(\"()\");\n      }\n      buf.append(groupBuf);\n    }\n    return buf.toString();\n  }\n  /** Creates a context to which SQL can be generated. */\n  public SqlWriter createSqlWriter(SqlDialect dialect, StringBuilder buf,\n      IntFunction<SqlNode> field) {\n    return new SqlWriter(this, dialect, buf,\n        new SqlImplementor.SimpleContext(dialect, field));\n  }\n  /** Returns a SQL query that counts the number of distinct values of the\n   * attributes given in {@code groupSet}. */\n  public String countSql(ImmutableBitSet groupSet) {\n    return \"select count(*) as c from (\"\n        + sql(groupSet, ImmutableList.of())\n        + \")\";\n  }\n  public StarTable createStarTable() {\n    final List<Table> tables = new ArrayList<>();\n    for (LatticeNode node : rootNode.descendants) {\n      tables.add(node.table.t.unwrap(Table.class));\n    }\n    return StarTable.of(this, tables);\n  }\n  public static Builder builder(CalciteSchema calciteSchema, String sql) {\n    return builder(new LatticeSpace(MapSqlStatisticProvider.INSTANCE),\n        calciteSchema, sql);\n  }\n  static Builder builder(LatticeSpace space, CalciteSchema calciteSchema,\n      String sql) {\n    return new Builder(space, calciteSchema, sql);\n  }\n  public List<Measure> toMeasures(List<AggregateCall> aggCallList) {\n    return Lists.transform(aggCallList, this::toMeasure);\n  }\n  private Measure toMeasure(AggregateCall aggCall) {\n    return new Measure(aggCall.getAggregation(), aggCall.isDistinct(),\n        aggCall.name, Lists.transform(aggCall.getArgList(), columns::get));\n  }\n  public Iterable<? extends Tile> computeTiles() {\n    if (!algorithm) {\n      return tiles;\n    }\n    return new TileSuggester(this).tiles();\n  }\n  /** Returns an estimate of the number of rows in the un-aggregated star. */\n  public double getFactRowCount() {\n    return rowCountEstimate;\n  }\n  /** Returns an estimate of the number of rows in the tile with the given\n   * dimensions. */\n  public double getRowCount(List<Column> columns) {\n    return statisticProvider.cardinality(columns);\n  }\n  /** Returns an estimate of the number of rows in the tile with the given\n   * dimensions. */\n  public static double getRowCount(double factCount, double... columnCounts) {\n    return getRowCount(factCount, Primitive.asList(columnCounts));\n  }\n  /** Returns an estimate of the number of rows in the tile with the given\n   * dimensions. */\n  public static double getRowCount(double factCount,\n      List<Double> columnCounts) {\n    // The expected number of distinct values when choosing p values\n    // with replacement from n integers is n . (1 - ((n - 1) / n) ^ p).\n    //\n    // If we have several uniformly distributed attributes A1 ... Am\n    // with N1 ... Nm distinct values, they behave as one uniformly\n    // distributed attribute with N1 * ... * Nm distinct values.\n    double n = 1d;\n    for (Double columnCount : columnCounts) {\n      if (columnCount > 1d) {\n        n *= columnCount;\n      }\n    }\n    final double a = (n - 1d) / n;\n    if (a == 1d) {\n      // A under-flows if nn is large.\n      return factCount;\n    }\n    final double v = n * (1d - Math.pow(a, factCount));\n    // Cap at fact-row-count, because numerical artifacts can cause it\n    // to go a few % over.\n    return Math.min(v, factCount);\n  }\n  public List<String> uniqueColumnNames() {\n    return Lists.transform(columns, column -> column.alias);\n  }\n  Pair<Path, Integer> columnToPathOffset(BaseColumn c) {\n    for (Pair<LatticeNode, Path> p\n        : Pair.zip(rootNode.descendants, rootNode.paths)) {\n      if (p.left.alias.equals(c.table)) {\n        return Pair.of(p.right, c.ordinal - p.left.startCol);\n      }\n    }\n    throw new AssertionError(\"lattice column not found: \" + c);\n  }\n  /** Returns the set of tables in this lattice. */\n  public Set<LatticeTable> tables() {\n    return rootNode.descendants.stream().map(n -> n.table)\n        .collect(Collectors.toCollection(LinkedHashSet::new));\n  }\n  /** Returns the ordinal, within all of the columns in this Lattice, of the\n   * first column in the table with a given alias.\n   * Returns -1 if the table is not found. */\n  public int firstColumn(String tableAlias) {\n    for (Column column : columns) {\n      if (column instanceof BaseColumn\n          && ((BaseColumn) column).table.equals(tableAlias)) {\n        return column.ordinal;\n      }\n    }\n    return -1;\n  }\n  /** Edge in the temporary graph. */\n  private static class Edge extends DefaultEdge {\n    public static final DirectedGraph.EdgeFactory<Vertex, Edge> FACTORY =\n        Edge::new;\n    final List<IntPair> pairs = new ArrayList<>();\n    Edge(Vertex source, Vertex target) {\n      super(source, target);\n    }\n    Vertex getTarget() {\n      return (Vertex) target;\n    }\n    Vertex getSource() {\n      return (Vertex) source;\n    }\n  }\n  /** Vertex in the temporary graph. */\n  private static class Vertex {\n    final LatticeTable table;\n    final String alias;\n    private Vertex(LatticeTable table, String alias) {\n      this.table = table;\n      this.alias = alias;\n    }\n  }\n  /** A measure within a {@link Lattice}.\n   *\n   * <p>It is immutable.\n   *\n   * <p>Examples: SUM(products.weight), COUNT() (means \"COUNT(*\")),\n   * COUNT(DISTINCT customer.id).\n   */\n  public static class Measure implements Comparable<Measure> {\n    public final SqlAggFunction agg;\n    public final boolean distinct;\n    @Nullable public final String name;\n    public final ImmutableList<Column> args;\n    public final String digest;\n    public Measure(SqlAggFunction agg, boolean distinct, @Nullable String name,\n        Iterable<Column> args) {\n      this.agg = Objects.requireNonNull(agg);\n      this.distinct = distinct;\n      this.name = name;\n      this.args = ImmutableList.copyOf(args);\n      final StringBuilder b = new StringBuilder()\n          .append(agg)\n          .append(distinct ? \"(DISTINCT \" : \"(\");\n      for (Ord<Column> arg : Ord.zip(this.args)) {\n        if (arg.i > 0) {\n          b.append(\", \");\n        }\n        if (arg.e instanceof BaseColumn) {\n          b.append(((BaseColumn) arg.e).table);\n          b.append('.');\n          b.append(((BaseColumn) arg.e).column);\n        } else {\n          b.append(arg.e.alias);\n        }\n      }\n      b.append(')');\n      this.digest = b.toString();\n    }\n    public int compareTo(@Nonnull Measure measure) {\n      int c = compare(args, measure.args);\n      if (c == 0) {\n        c = agg.getName().compareTo(measure.agg.getName());\n        if (c == 0) {\n          c = Boolean.compare(distinct, measure.distinct);\n        }\n      }\n      return c;\n    }\n    @Override public String toString() {\n      return digest;\n    }\n    @Override public int hashCode() {\n      return Objects.hash(agg, args);\n    }\n<fim_suffix>    @Override public boolean equals(Object obj) {\n      return obj == this\n          || obj instanceof Measure\n          && this.agg.equals(((Measure) obj).agg)\n          && this.args.equals(((Measure) obj).args)\n          && this.distinct == ((Measure) obj).distinct;\n    }<fim_middle>// function below has no smell\n"}