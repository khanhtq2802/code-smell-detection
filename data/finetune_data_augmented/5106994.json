{"text": "<fim_prefix>        // run the database query and if it yields a result, construct a new node; the method call will take care of\n        // caching the constructed node for future calls\n        try (ResultSet result = query.executeQuery()) {\n            if (result.next()) {\n                return constructNamespaceFromDatabase(result);\n            }\n        }\n        return null;\n    }\n    /**\n     * Store the namespace passed as argument in the database. The database might enfore unique constraints and\n     * thus throw an exception in case the prefix or URI is already used.\n     *\n     * @param namespace the namespace to store\n     * @throws SQLException the prefix or URI is already used, or a database error occurred\n     */\n    public void storeNamespace(KiWiNamespace namespace) throws SQLException {\n        // TODO: add unique constraints to table\n        if (namespace.getId() >= 0) {\n            log.warn(\"trying to store namespace which is already persisted: {}\",namespace);\n            return;\n        }\n        requireJDBCConnection();\n        namespace.setId(getNextSequence());\n        PreparedStatement insertNamespace = getPreparedStatement(\"store.namespace\");\n        insertNamespace.setLong(1,namespace.getId());\n        insertNamespace.setString(2,namespace.getPrefix());\n        insertNamespace.setString(3,namespace.getUri());\n        insertNamespace.setTimestamp(4,new Timestamp(namespace.getCreated().getTime()));\n        insertNamespace.executeUpdate();\n        namespacePrefixCache.put(namespace.getPrefix(), namespace);\n        namespaceUriCache.put(namespace.getUri(),namespace);\n    }\n    /**\n     * Delete the namespace passed as argument from the database and from the caches.\n     * @param namespace the namespace to delete\n     * @throws SQLException in case a database error occurred\n     */\n    public void deleteNamespace(KiWiNamespace namespace) throws SQLException {\n        if (namespace.getId() < 0) {\n            log.warn(\"trying to remove namespace which is not persisted: {}\",namespace);\n            return;\n        }\n        requireJDBCConnection();\n        PreparedStatement deleteNamespace = getPreparedStatement(\"delete.namespace\");\n        deleteNamespace.setLong(1, namespace.getId());\n        deleteNamespace.executeUpdate();\n        namespacePrefixCache.remove(namespace.getPrefix());\n        namespaceUriCache.remove(namespace.getUri());\n    }\n    /**\n     * Count all non-deleted triples in the triple store\n     * @return number of non-deleted triples in the triple store\n     * @throws SQLException\n     */\n    public long getSize() throws SQLException {\n        requireJDBCConnection();\n        PreparedStatement querySize = getPreparedStatement(\"query.size\");\n        try (ResultSet result = querySize.executeQuery()) {\n            if (result.next()) {\n                return result.getLong(1) + (tripleBatch != null ? tripleBatch.size() : 0);\n            }\n        }\n        return tripleBatch != null ? tripleBatch.size() : 0;\n    }\n    /**\n     * Count all non-deleted triples in the triple store\n     * @param context the context to count\n     * @return number of non-deleted triples in the provided context\n     * @throws SQLException\n     */\n    public long getSize(KiWiResource context) throws SQLException {\n        if (context.getId() < 0) {\n            return 0;\n        }\n        requireJDBCConnection();\n        PreparedStatement querySize = getPreparedStatement(\"query.size_ctx\");\n        querySize.setLong(1,context.getId());\n        try (ResultSet result = querySize.executeQuery()) {\n            if (result.next()) {\n                return result.getLong(1) + (tripleBatch != null ? tripleBatch.listTriples(null, null, null, context, false).size() : 0);\n            }\n        }\n        return tripleBatch != null ? tripleBatch.listTriples(null, null, null, context, false).size() : 0;\n    }\n    /**\n     * Load a KiWiNode by database ID. The method will first look in the node cache for cached nodes. If\n     * no cache entry is found, it will run a database query ('load.node_by_id') on the NODES table and\n     * construct an appropriate subclass instance of KiWiNode with the obtained values. The result will be\n     * constructed based on the value of the NTYPE column as follows:\n     * <ul>\n     *     <li>'uri' - KiWiUriResource using the id and svalue (as URI) columns</li>\n     *     <li>'bnode' - KiWiAnonResource using the id and svalue (as AnonId) columns</li>\n     *     <li>'string' - KiWiStringLiteral using the id, svalue (literal value), lang (literal\n     *         language) and ltype (literal type) columns</li>\n     *     <li>'int' - KiWiIntLiteral using the id, svalue (string value), ivalue (integer value)\n     *         and ltype (literal type) columns</li>\n     *     <li>'double' - KiWiDoubleLiteral using the id, svalue (string value), dvalue (double\n     *         value) and ltype (literal type) columns</li>\n     *     <li>'boolean' - KiWiBooleanLiteral using the id, svalue (string value), bvalue (boolean\n     *         value) and ltype (literal type) columns</li>\n     *     <li>'date' - KiWiDateLiteral using the id, svalue (string value), tvalue (time value)\n     *         and ltype (literal type) columns</li>\n     * </ul>\n     * When a node is loaded from the database, it will be added to the different caches to speed up\n     * subsequent requests.\n     *\n     * @param id the database id of the node to load\n     * @return an instance of a KiWiNode subclass representing the node with the given database id;\n     *     type depends on value of the ntype column\n     */\n    public KiWiNode loadNodeById(long id) throws SQLException {\n        // look in cache\n        KiWiNode element = nodeCache.get(id);\n        if (element != null) {\n            return element;\n        }\n        requireJDBCConnection();\n        // prepare a query; we will only iterate once, read only, and need only one result row since the id is unique\n        final PreparedStatement query = getPreparedStatement(\"load.node_by_id\");\n        synchronized (query) {\n            query.setLong(1,id);\n            query.setMaxRows(1);\n            // run the database query and if it yields a result, construct a new node; the method call will take care of\n            // caching the constructed node for future calls\n            try (ResultSet result = query.executeQuery()) {\n                if (result.next()) {\n                    return constructNodeFromDatabase(result);\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * Batch load the nodes with the given ids. This method aims to offer performance improvements by reducing\n     * database roundtrips.\n     * @param ids array of ids to retrieve\n     * @return array of nodes corresponding to these ids (in the same order)\n     * @throws SQLException\n     */\n    public KiWiNode[] loadNodesByIds(long... ids) throws SQLException {\n        requireJDBCConnection();\n        KiWiNode[] result = new KiWiNode[ids.length];\n        // first look in the cache for any ids that have already been loaded\n        ArrayList<Long> toFetch = new ArrayList<>(ids.length);\n        for(int i=0; i < ids.length; i++) {\n            if(ids[i] != 0) {\n                result[i] = nodeCache.get(ids[i]);\n                if(result[i] == null) {\n                    toFetch.add(ids[i]);\n                }\n            }\n        }\n        if(toFetch.size() > 0) {\n            // declare variables before to optimize stack allocation\n            int position = 0;\n            int nextBatchSize;\n            PreparedStatement query;\n            KiWiNode node;\n            while(position < toFetch.size()) {\n                nextBatchSize = computeBatchSize(position, toFetch.size());\n                query = getPreparedStatement(\"load.nodes_by_ids\", nextBatchSize);\n                synchronized (query) {\n                    for(int i=0; i<nextBatchSize; i++) {\n                        query.setLong(i+1, toFetch.get(position + i));\n                    }\n                    query.setMaxRows(nextBatchSize);\n                    // run the database query and if it yields a result, construct a new node; the method call will take care of\n                    // caching the constructed node for future calls\n                    try (ResultSet rows = query.executeQuery()) {\n                        while (rows.next()) {\n                            node = constructNodeFromDatabase(rows);\n                            for (int i = 0; i < ids.length; i++) {\n                                if (ids[i] == node.getId()) {\n                                    result[i] = node;\n                                }\n                            }\n                        }\n                    }\n                    position += nextBatchSize;\n                }\n            }\n        }\n        return result;\n    }\n<fim_suffix>    private int computeBatchSize(int position, int length) {\n        int batchSize = QUERY_BATCH_SIZE;\n        while (length - position < batchSize) {\n            batchSize = batchSize >> 1;\n        }\n        return batchSize;\n    }<fim_middle>// function below has no smell\n"}