{"text": "<fim_prefix>        long rootGrossTimeAbs = ti.rootGrossTimeAbs;\n        // System.err.println(\"\\n*** CPUCallGraphBuilder: rootGrossTimeAbs = \"\n        // + rootGrossTimeAbs + \", totalNInv = \" + ti.totalNInv);  // NOI18N\n        if (ti.stackTopIdx != -1) {\n            long time0 = getDumpAbsTimeStamp();\n            if (ti.topMethodEntryTime0 > time0) {\n                time0 = ti.topMethodEntryTime0;\n            }\n            rootGrossTimeAbs += (time0 - ti.rootMethodEntryTimeAbs);\n            //System.err.println(\"*** dumpAbsTimeStamp = \" + status.dumpAbsTimeStamp + \", ti.topMethodEntryTime0 = \"\n            // + ti.topMethodEntryTime0 + \", ti.rootMethodEntryTimeAbs = \" + ti.rootMethodEntryTimeAbs); // NOI18N\n            //System.err.println(\"*** Adjusted rootGrossTimeAbs = \" + rootGrossTimeAbs); // NOI18N\n        }\n        //System.err.println(\"*** rootGrossTimeAbs in ms = \" + ((double) rootGrossTimeAbs) * 1000 / status.timerCountsInSecond[0]); // NOI18N\n        long rootGrossTimeCPU = ti.rootGrossTimeThreadCPU;\n        //System.err.println(\"*** ti.rootGrossTimeThreadCPU = \" + ti.rootGrossTimeThreadCPU + \", totalNInv = \" + ti.totalNInv); // NOI18N\n        if (ti.stackTopIdx != -1) {\n            if (isCollectingTwoTimeStamps()) {\n                rootGrossTimeCPU += (ti.topMethodEntryTime1 - ti.rootMethodEntryTimeThreadCPU);\n                //System.err.println(\"*** ti.topMethodEntryTime1 = \" + ti.topMethodEntryTime1 + \", ti.rootMethodEntryTimeThreadCPU = \" + ti.rootMethodEntryTimeThreadCPU);\n                //System.err.println(\"*** adjustment for CPU time = \" + (ti.topMethodEntryTime1 - ti.rootMethodEntryTimeThreadCPU)); // NOI18N\n            } else {\n                rootGrossTimeCPU = -1;\n            }\n        }\n        //System.err.println(\"*** Adjusted rootGrossTimeCPU = \" + rootGrossTimeCPU + \", in ms = \" + ((double) rootGrossTimeCPU) * 1000 / status.timerCountsInSecond[1]); // NOI18N\n        int nRootInv = rootNode.getNCalls();\n        double timeInInjectedCodeInAbsCounts;\n        double timeInInjectedCodeInThreadCPUCounts = 0;\n        // Calculate timeInInjectedCodeInAbsCounts.\n        timeInInjectedCodeInAbsCounts = timingAdjuster.delta(nRootInv, (int) (ti.totalNInv - nRootInv), false);\n        //System.err.println(\"*** timeInInjectedCodeInAbsCounts = \" + timeInInjectedCodeInAbsCounts + \", in ms = \" + ((double) timeInInjectedCodeInAbsCounts) * 1000 / status.timerCountsInSecond[0]); // NOI18N\n        // Now calculate timeInInjectedCodeInThreadCPUCounts\n        if (isCollectingTwoTimeStamps()) {\n            timeInInjectedCodeInThreadCPUCounts = timingAdjuster.delta(nRootInv, (int) (ti.totalNInv - nRootInv), true);\n        } else { // Same calculation whether we have absoluteTimerOn == true or not\n                 // Just convert the known time into thread CPU time units\n            timeInInjectedCodeInThreadCPUCounts = (timeInInjectedCodeInAbsCounts * timingAdjuster.getInstrTimingData().timerCountsInSecond1) / timingAdjuster.getInstrTimingData().timerCountsInSecond0;\n        }\n        //System.err.println(\"*** timeInInjectedCodeInThreadCPUCounts = \" + timeInInjectedCodeInThreadCPUCounts); // NOI18N\n        return new double[] {\n                   (double) rootGrossTimeAbs, (double) rootGrossTimeCPU, timeInInjectedCodeInAbsCounts,\n                   timeInInjectedCodeInThreadCPUCounts\n               };\n    }\n    protected void doBatchStart() {\n        /****************************************************************************/\n        /* Timing adjuster must be initialized here as in doStartup() it may happen */\n        /* that the instrumentation type has not been set yet                       */\n        /****************************************************************************/\n        ProfilerClient client = getClient();\n        if (client != null) {\n            timingAdjuster = TimingAdjusterOld.getInstance(client.getStatus());\n        }\n        threadInfos.beginTrans(true);\n    }\n    protected void doBatchStop() {\n        threadInfos.endTrans();\n    }\n    protected void doReset() {\n        boolean threadLocked = threadInfos.beginTrans(true, true);\n        if (threadLocked) { // ignore request for reset received durin an ongoing active transaction\n            try {\n                threadInfos.reset();\n            } finally {\n                threadInfos.endTrans();\n            }\n        }\n    }\n    protected void doShutdown() {\n        threadInfos.reset();\n        instrFilter = null;\n    }\n    protected void doStartup(final ProfilerClient profilerClient) {\n        instrFilter = profilerClient.getSettings().getInstrumentationFilter();\n        setMethodInfoMapper(new MethodInfoMapper() {\n            final private String INVALID_MID=ResourceBundle.getBundle(\"org.graalvm.visualvm.lib.jfluid.results.cpu.Bundle\").getString(\"MSG_INVALID_METHODID\"); // NOI18N\n            @Override\n            public String getInstrMethodClass(int methodId) {\n                String[] cNames = profilerClient.getStatus().getInstrMethodClasses();\n                if (methodId < cNames.length) {\n                    return cNames[methodId];\n                } else {\n                    LOGGER.log(Level.WARNING, INVALID_MID, new Object[]{methodId, cNames.length - 1});\n                    return null;\n                }\n            }\n            @Override\n            public String getInstrMethodName(int methodId) {\n                String[] mNames = profilerClient.getStatus().getInstrMethodNames();\n                if (methodId < mNames.length) {\n                    return mNames[methodId];\n                } else {\n                    LOGGER.log(Level.WARNING, INVALID_MID, new Object[]{methodId, mNames.length - 1});\n                    return null;\n                }\n            }\n            @Override\n            public String getInstrMethodSignature(int methodId) {\n                String[] sNames = profilerClient.getStatus().getInstrMethodSignatures();\n                if (methodId < sNames.length) {\n                    return sNames[methodId];\n                } else {\n                    LOGGER.log(Level.WARNING, INVALID_MID, new Object[]{methodId, sNames.length - 1});\n                    return null;\n                }\n            }\n            @Override\n            public int getMinMethodId() {\n                return 1;\n            }\n            @Override\n            public int getMaxMethodId() {\n                return profilerClient.getStatus().getNInstrMethods();\n            }\n            @Override\n            public void lock(boolean mutable) {\n                profilerClient.getStatus().beginTrans(mutable);\n            }\n            @Override\n            public void unlock() {\n                profilerClient.getStatus().endTrans();\n            }\n        });\n        profilerClient.registerCPUCCTProvider(this);\n    }\n    protected void setFilter(InstrumentationFilter filter) {\n        this.instrFilter = filter;\n    }\n    private synchronized DebugInfoCollector getDebugCollector() {\n        if (debugCollector == null) {\n            debugCollector = new DebugInfoCollector();\n        }\n        return debugCollector;\n    }\n    protected boolean isReady() {\n        return (status != null) && (instrFilter != null);\n    }\n    private String debugMethod(int methodId) {\n        StringBuilder buffer = new StringBuilder();\n        try {\n            methodInfoMapper.lock(false);\n            buffer.append(methodInfoMapper.getInstrMethodClass(methodId)).append('.').append(methodInfoMapper.getInstrMethodName(methodId)); // NOI18N\n            buffer.append(methodInfoMapper.getInstrMethodSignature(methodId)).append(\" (methodId = \").append(methodId).append(')'); // NOI18N\n        } finally {\n            methodInfoMapper.unlock();\n        }\n        return buffer.toString();\n    }\n    private String debugNode(RuntimeCPUCCTNode node) {\n        return getDebugCollector().getInfo(node);\n    }\n<fim_suffix>    private String dumpStack(ThreadInfo ti) {\n        StringBuilder buffer = new StringBuilder();\n        buffer.append(\"*** Thread stack dump:\\n\"); // NOI18N\n        for (int i = ti.stackTopIdx; i >= 0; i--) {\n            DebugInfoCollector collector = new DebugInfoCollector();\n            TimedCPUCCTNode frame = ti.stack[i];\n            RuntimeCCTNodeProcessor.process(frame, collector);\n            buffer.append(collector.getInfo(frame)).append('\\n'); // NOI18N\n        }\n        return buffer.toString();\n    }<fim_middle>// function below has no smell\n"}