{"text": "<fim_prefix>/*\nCopyright 2011-2016 Google Inc. All Rights Reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n    http://www.apache.org/licenses/LICENSE-2.0\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\npackage com.google.security.zynamics.binnavi.Database.PostgreSQL.Notifications.parsers;\nimport com.google.common.base.Optional;\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.Lists;\nimport com.google.security.zynamics.binnavi.Database.CTableNames;\nimport com.google.security.zynamics.binnavi.Database.Exceptions.CouldntLoadDataException;\nimport com.google.security.zynamics.binnavi.Database.Interfaces.SQLProvider;\nimport com.google.security.zynamics.binnavi.Database.PostgreSQL.Notifications.containers.TypesNotificationContainer;\nimport com.google.security.zynamics.binnavi.Database.PostgreSQL.Notifications.interfaces.PostgreSQLNotificationParser;\nimport com.google.security.zynamics.binnavi.Database.cache.InstructionCache;\nimport com.google.security.zynamics.binnavi.disassembly.INaviInstruction;\nimport com.google.security.zynamics.binnavi.disassembly.INaviModule;\nimport com.google.security.zynamics.binnavi.disassembly.INaviOperandTree;\nimport com.google.security.zynamics.binnavi.disassembly.INaviOperandTreeNode;\nimport com.google.security.zynamics.binnavi.disassembly.types.BaseType;\nimport com.google.security.zynamics.binnavi.disassembly.types.RawTypeSubstitution;\nimport com.google.security.zynamics.binnavi.disassembly.types.TypeManager;\nimport com.google.security.zynamics.binnavi.disassembly.types.TypeMember;\nimport com.google.security.zynamics.binnavi.disassembly.types.TypeSubstitution;\nimport com.google.security.zynamics.zylib.disassembly.CAddress;\nimport com.google.security.zynamics.zylib.disassembly.OperandOrderIterator;\nimport org.postgresql.PGNotification;\nimport java.math.BigInteger;\nimport java.util.Collection;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n/**\n * Class that parses and informs about {@link PGNotification notifications} related to\n * {@link TypeMember type members}, {@link BaseType base types} and {@link TypeSubstitution type\n * substitutions}.\n */\npublic class PostgreSQLTypesNotificationParser implements\nPostgreSQLNotificationParser<TypesNotificationContainer> {\n  /**\n   * The regular expression pattern for a {@link CTableNames bn_expression_types}\n   * {@link PGNotification notification}.\n   */\n  private static final String EXPRESSION_TYPES_NOTIFICATION_REGEX = \"^(\"\n      + CTableNames.EXPRESSION_TYPES_TABLE + \")\" + \"\\\\s(INSERT|UPDATE|DELETE)\" + \"\\\\s(\\\\d*)\"\n      + \"\\\\s(\\\\d*)\" + \"\\\\s(\\\\d*)\" + \"\\\\s(\\\\d*)\";\n  private static final Pattern EXPRESSION_TYPES_NOTIFICATION_PATTERN;\n  /**\n   * The regular expression pattern for a {@link CTableNames bn_types} {@link PGNotification\n   * notification}.\n   */\n  private static final String TYPES_NOTIFICATION_REGEX = \"^(\" + CTableNames.TYPE_MEMBERS_TABLE + \")\"\n      + \"\\\\s(INSERT|UPDATE|DELETE)\" + \"\\\\s(\\\\d*)\" + \"\\\\s(\\\\d*)\";\n  private static final Pattern TYPES_NOTIFICATION_PATTERN;\n  /**\n   * The regular expression pattern for a {@link CTableNames bn_base_types} {@link PGNotification\n   * notification}.\n   */\n  private static final String BASE_TYPE_NOTIFICATION_REGEX = \"^(\" + CTableNames.BASE_TYPES_TABLE\n      + \")\" + \"\\\\s(INSERT|UPDATE|DELETE)\" + \"\\\\s(\\\\d*)\" + \"\\\\s(\\\\d*)\";\n  private static final Pattern BASE_TYPES_NOTIFICATION_PATTERN;\n  /**\n   * Static initializer to only compile the used patterns in the class once.\n   */\n  static {\n    EXPRESSION_TYPES_NOTIFICATION_PATTERN = Pattern.compile(EXPRESSION_TYPES_NOTIFICATION_REGEX);\n    TYPES_NOTIFICATION_PATTERN = Pattern.compile(TYPES_NOTIFICATION_REGEX);\n    BASE_TYPES_NOTIFICATION_PATTERN = Pattern.compile(BASE_TYPE_NOTIFICATION_REGEX);\n  }\n  /**\n   * Only used internally to find the necessary {@link INaviOperandTreeNode operand node} where a\n   * {@link TypeSubstitution type substitution} is associated to.\n   * \n   * @param provider The {@link SQLProvider} used to differentiate between the different caches used\n   *        for getting {@link INaviInstruction instructions}.\n   * @param moduleId The id of the {@link INaviModule module} this {@link TypeSubstitution type\n   *        substitution} is associated to.\n   * @param address The {@link CAddress} of the {@link INaviInstruction instruction} where the\n   *        {@link TypeSubstitution type substitution} is associated to.\n   * @param position The {@link INaviOperandTree operand tree} position where the\n   *        {@link TypeSubstitution type substitution} is associated to.\n   * @param operandNodeId the id of the {@link INaviOperandTreeNode operand node} to which the\n   *        {@link TypeSubstitution type substitution} is associated.\n   * @return A {@link INaviOperandTreeNode} if it is in the cache otherwise null;\n   */\n  private INaviOperandTreeNode findOperandTreeNode(final SQLProvider provider, final int moduleId,\n      final CAddress address, final int position, final int operandNodeId) {\n    final INaviInstruction instruction =\n        InstructionCache.get(provider).getInstructionByAddress(address, moduleId);\n    if (instruction != null) {\n      final INaviOperandTree operandTree = instruction.getOperands().get(position);\n      final INaviOperandTreeNode root = operandTree.getRootNode();\n      final OperandOrderIterator iterator = new OperandOrderIterator(root);\n      while (iterator.next()) {\n        final INaviOperandTreeNode currentNode = (INaviOperandTreeNode) iterator.current();\n        if (currentNode.getId() == operandNodeId) {\n          return currentNode;\n        }\n      }\n    }\n    return null;\n  }\n  /**\n   * Informs the {@link TypeManager type manager} about the given change from the\n   * {@link PGNotification notification}.\n   *\n   * @param container The {@link TypesNotificationContainer} which carries the parsed information.\n   * @param provider The {@link SQLProvider} used to access the database.\n   *\n   * @throws CouldntLoadDataException if the necessary information could not be loaded from the\n   *         database.\n   */\n<fim_suffix>  private void informBaseTypesNotification(final TypesNotificationContainer container,\n      final SQLProvider provider) throws CouldntLoadDataException {\n    final TypeManager typeManager = provider.findModule(container.getModuleId()).getTypeManager();\n    if (container.getDatabaseOperation().equals(\"INSERT\")) {\n      typeManager.loadAndInitializeBaseType(container.getBaseTypeId().get());\n    } else if (container.getDatabaseOperation().equals(\"UPDATE\")) {\n      typeManager.loadAndUpdateBaseType(container.getBaseTypeId().get());\n    } else if (container.getDatabaseOperation().equals(\"DELETE\")) {\n      typeManager.removeBaseTypeInstance(container.getBaseTypeId().get());\n    }\n  }\n  /**\n   * Informs about necessary state changes related to {@link TypeSubstitution type substitutions}.\n   *\n   * @param container The {@link TypesNotificationContainer} holding the parsed\n   *        {@link PGNotification notification} information.\n   * @param provider The {@link SQLProvider} used to access the database with.\n   *\n   * @throws CouldntLoadDataException if the required information could not be loaded from the\n   *         database.\n   */\n  private void informExpressionTypesNotification(final TypesNotificationContainer container,\n      final SQLProvider provider) throws CouldntLoadDataException {\n    final INaviModule module = provider.findModule(container.getModuleId());\n    final TypeManager typeManager = module.getTypeManager();\n    final INaviOperandTreeNode node =\n        findOperandTreeNode(provider, container.getModuleId(), new CAddress(container.getAddress()\n            .get()), container.position().get(), container.expressionId().get());\n    if (node == null) {\n      return;\n    }\n    if (container.getDatabaseOperation().equals(\"INSERT\")) {\n      final RawTypeSubstitution rawSubstitution = provider.loadTypeSubstitution(\n          module, container.getAddress().get(), container.position().get(),\n          container.expressionId().get());\n      typeManager.initializeTypeSubstitution(node, rawSubstitution);\n    } else if (container.getDatabaseOperation().equals(\"UPDATE\")) {\n      final RawTypeSubstitution rawSubstitution = provider.loadTypeSubstitution(\n          module, container.getAddress().get(), container.position().get(),<fim_middle>// function below has no smell\n"}