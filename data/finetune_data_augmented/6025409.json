{"text": "<fim_prefix>/*\n * Copyright (c) 2017 the original author or authors.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n */\n\npackage org.eclipse.buildship.core.internal.launch;\n\nimport java.util.Set;\n\nimport com.google.common.base.Optional;\nimport com.google.common.collect.Sets;\n\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.debug.core.ILaunchConfiguration;\nimport org.eclipse.jdt.core.IClasspathEntry;\nimport org.eclipse.jdt.core.IPackageFragmentRoot;\n\nimport org.eclipse.buildship.core.internal.CorePlugin;\nimport org.eclipse.buildship.core.internal.util.classpath.ClasspathUtils;\n\n/**\n * Represents the scope associated with the current launch configuration.\n *\n * @author Donat Csikos\n */\npublic abstract class LaunchConfigurationScope {\n\n    /**\n     * Launch configuration scope that doesn't filter any entries.\n     */\n    public static final LaunchConfigurationScope INCLUDE_ALL = new IncludeAllLaunchConfigurationScope();\n\n    /**\n     * Returns {@code true} if the classpath entry is part of this scope.\n     *\n     * @param entry the target classpath entry\n     * @param scopes the name of the scopes to look for\n     *\n     * @return whether the scopes contain the the entry's dependency scope\n     */\n    public abstract boolean isEntryIncluded(IClasspathEntry entry);\n\n    /**\n     * Creates a launch configuration scope from the target launch configuration. If the scope\n     * information cannot be calculated then the result scope doesn't filter any entries.\n     *\n     * @param configuration the target launch configuration\n     * @return the created scope\n     */\n    public static LaunchConfigurationScope from(ILaunchConfiguration configuration) {\n        Set<String> result = Sets.newHashSet();\n        try {\n            Set<IPackageFragmentRoot> soureFolders = SupportedLaunchConfigType.collectSourceFolders(configuration);\n            for (IPackageFragmentRoot sourceFolder : soureFolders) {\n                Optional<Set<String>> scope = ClasspathUtils.scopesFor(sourceFolder.getRawClasspathEntry());\n                if (!scope.isPresent()) {\n                    return INCLUDE_ALL;\n                }\n                result.addAll(scope.get());\n            }\n            return new FilteringLaunchConfigurationScope(result);\n        } catch (CoreException e) {\n            CorePlugin.logger().warn(\"Cannot collect dependency scope information for launch configuration \" + configuration.getName(), e);\n            return INCLUDE_ALL;\n        }\n    }\n\n\n    /**\n     * Doesn't filter any entries.\n     */\n<fim_suffix>    private static final class IncludeAllLaunchConfigurationScope extends LaunchConfigurationScope {\n\n        @Override\n        public boolean isEntryIncluded(IClasspathEntry entry) {\n            return true;\n        }\n    }\n\n    /**\n     * Filters entries if they are not used by the represented scopes.\n     */\n    private static final class FilteringLaunchConfigurationScope extends LaunchConfigurationScope {\n\n        private final Set<String> scopes;\n\n        public FilteringLaunchConfigurationScope(Set<String> scopes) {\n            this.scopes = scopes;\n        }\n\n        @Override\n        public boolean isEntryIncluded(IClasspathEntry entry) {\n            if (this.scopes == null || this.scopes.isEmpty()) {\n                return true;\n            }\n\n            Optional<Set<String>> entryUsedByScopes = ClasspathUtils.usedByScopesFor(entry);\n            if (!entryUsedByScopes.isPresent() || entryUsedByScopes.get().isEmpty()) {\n                return true;\n            }\n\n            return !Sets.intersection(this.scopes, entryUsedByScopes.get()).isEmpty();\n        }\n    }\n}<fim_middle>// class below has no smell\n"}