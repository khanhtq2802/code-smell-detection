{"text": "<fim_prefix>\t\t\t\tColumnDescriptorList coldl;\n\t\t\t\tint[] refColumns; \n\t\t\t\tColumnDescriptor cold; \n\t\t\t\tint[] colArray = remapReferencedColumns(cd, rowMap);\n\t\t\t\tfor (int inner = 0; inner < size; inner++)\n\t\t\t\t{\n                    ForeignKeyConstraintDescriptor fkcd =\n                        (ForeignKeyConstraintDescriptor) fkcdl.elementAt(inner);\n                    fkSetupArrays(\n                        dd, fkcd,\n                        inner, uuids, conglomNumbers, fkNames,\n                        isSelfReferencingFK, raRules, deferrable, fkIds);\n\t\t\t\t\tif((raRules[inner] == StatementType.RA_CASCADE) || \n\t\t\t\t\t   (raRules[inner] ==StatementType.RA_SETNULL))\n\t\t\t\t\t{\n\t\t\t\t\t\t//find  the referencing  table Name\n\t\t\t\t\t\tfktd = fkcd.getTableDescriptor();\n\t\t\t\t\t\trefSchemaNames.add(fktd.getSchemaName());\n\t\t\t\t\t\trefTableNames.add(fktd.getName());\n                        refActions.add(Integer.valueOf(raRules[inner]));\n\t\t\t\t\t\t//find the referencing column name required for update null.\n\t\t\t\t\t\trefColumns = fkcd.getReferencedColumns();\n\t\t\t\t\t\tcoldl = fktd.getColumnDescriptorList();\n\t\t\t\t\t\tColumnDescriptorList releventColDes = new ColumnDescriptorList();\n\t\t\t\t\t\tfor(int i = 0 ; i < refColumns.length; i++)\n\t\t\t\t\t\t{\n                            cold = coldl.elementAt(refColumns[i]-1);\n\t\t\t\t\t\t\treleventColDes.add(cold);\n\t\t\t\t\t\t}\n\t\t\t\t\t\trefColDescriptors.add(releventColDes);\n                        refIndexConglomNum.add(\n                            Long.valueOf(conglomNumbers[inner]));\n\t\t\t\t\t\tfkColMap.add(colArray);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n            final TableDescriptor   pktd = refcd.getTableDescriptor();\n            final UUID pkIndexId = refcd.getIndexId();\n            final ConglomerateDescriptor pkIndexConglom =\n                    pktd.getConglomerateDescriptor(pkIndexId);\n            final TableDescriptor refTd = cd.getTableDescriptor();\n            fkList.add(\n                new FKInfo(\n                    fkNames,                // foreign key names\n                    cd.getSchemaDescriptor().getSchemaName(),\n                    refTd.getName(),        // table being modified\n                    statementType,          // INSERT|UPDATE|DELETE\n                    type,                   // FOREIGN_KEY|REFERENCED_KEY\n                    pkIndexId,              // referenced backing index uuid\n                    pkIndexConglom.getConglomerateNumber(),\n                                            // referenced backing index conglom\n                    refcd.getUUID(),\n                    refcd.deferrable(),     // referenced constraint is\n                                            // deferrable?\n                    uuids,                  // fk backing index uuids\n                    conglomNumbers,         // fk backing index congloms\n                    isSelfReferencingFK,    // is self ref array of bool\n                    remapReferencedColumns(cd, rowMap),\n                                            // columns referenced by key\n                    dd.getRowLocationTemplate(getLanguageConnectionContext(),\n                                              refTd),\n                                            // row location template for table\n                                            // being modified\n                    raRules,                // referential action rules\n                    deferrable,             // deferrable flags\n                    fkIds));                // UUID of fks\n\t\t}\n        // Now convert the list into an array.\n        if (!fkList.isEmpty()) {\n            fkInfo = fkList.toArray(new FKInfo[fkList.size()]);\n        }\n        // Convert the ref action info lists to arrays.\n\t\tint size = refActions.size();\n\t\tif (size > 0)\n\t\t{\n\t\t\tfkTableNames = new String[size];\n\t\t\tfkSchemaNames = new String[size];\n\t\t\tfkRefActions  = new int[size];\n\t\t\tfkColDescriptors = new ColumnDescriptorList[size];\n\t\t\tfkIndexConglomNumbers = new long[size];\n\t\t\tfkColArrays = new int[size][];\n\t\t\tfor (int i = 0; i < size; i++)\n\t\t\t{\n\t\t\t\tfkTableNames[i] = refTableNames.get(i);\n\t\t\t\tfkSchemaNames[i] = refSchemaNames.get(i);\n\t\t\t\tfkRefActions[i]  = (refActions.get(i)).intValue();\n\t\t\t\tfkColDescriptors[i] =\n\t\t\t\t\trefColDescriptors.get(i);\n\t\t\t\tfkIndexConglomNumbers[i] =\n\t\t\t\t\t(refIndexConglomNum.get(i)).longValue();\n\t\t\t\tfkColArrays[i] = (fkColMap.get(i));\n\t\t\t}\n\t\t}\t\t\n\t}\n\t/*\n\t** Simple little helper method\n\t*/\t\n\tprivate void fkSetupArrays\n\t(\n\t\tDataDictionary\t\t\t\t\t\tdd,\n\t\tForeignKeyConstraintDescriptor \t\tfkcd,\n\t\tint\t\t\t\t\t\t\t\t\tindex,\n\t\tUUID[]\t\t\t\t\t\t\t\tuuids,\n\t\tlong[]\t\t\t\t\t\t\t\tconglomNumbers,\n\t\tString[]\t\t\t\t\t\t\tfkNames,\n\t\tboolean[]\t\t\t\t\t\t\tisSelfReferencingFK,\n        int[]                               raRules,\n        boolean[]                           isDeferrable,\n        UUID[]                              fkIds\n\t)\n\t\tthrows StandardException\n\t{\n\t\tfkNames[index] = fkcd.getConstraintName();\n\t\tuuids[index] = fkcd.getIndexId();\n        isDeferrable[index] = fkcd.deferrable();\n        fkIds[index] = fkcd.getUUID();\n\t\tconglomNumbers[index] = fkcd.getIndexConglomerateDescriptor(dd).getConglomerateNumber();\n\t\tisSelfReferencingFK[index] = fkcd.isSelfReferencingFK();\n\t\tif(statementType == StatementType.DELETE)\n\t\t\traRules[index] = fkcd.getRaDeleteRule();\n\t\telse if(statementType == StatementType.UPDATE)\n\t\t\traRules[index] = fkcd.getRaUpdateRule();\n\t}\n\t/**\n\t * Generate the TriggerInfo structures used during code generation.\n\t *\n\t * @param triggerList\t\t\t\tThe trigger descriptor list\n\t */\n    private void generateTriggerInfo(TriggerDescriptorList triggerList)\n\t{\t\n        if ((triggerList != null) && (!triggerList.isEmpty()))\n\t\t{\n            triggerInfo = new TriggerInfo(triggerList);\n\t\t}\n\t}\n\t/**\n\t * Return the FKInfo structure.  Just  a little wrapper\n\t * to make sure we don't try to access it until after\n\t * binding.\n\t *\n\t * @return the array of fkinfos\n\t */\n    FKInfo[] getFKInfo()\n\t{\n\t\tif (SanityManager.DEBUG)\n\t\t{\n\t\t\tSanityManager.ASSERT(bound, \"attempt to access FKInfo \"+\n\t\t\t\t\t\"before binding\");\n\t\t}\n\t\treturn fkInfo;\n\t}\n\t/**\n\t * Return the TriggerInfo structure.  Just  a little wrapper\n\t * to make sure we don't try to access it until after\n\t * binding.\n\t *\n\t * @return the trigger info\n\t */\n    TriggerInfo getTriggerInfo()\n\t{\n\t\tif (SanityManager.DEBUG)\n\t\t{\n\t\t\tSanityManager.ASSERT(bound, \"attempt to access TriggerInfo \"+\n\t\t\t\t\t\"before binding\");\n\t\t}\n\t\treturn triggerInfo;\n\t}\n\t/**\n\t * Get the check constraints for this node\n\t *\n\t * @return the check constraints, may be null\n\t */\n    ValueNode getCheckConstraints()\n\t{\n\t\tif (SanityManager.DEBUG)\n\t\t{\n\t\t\tSanityManager.ASSERT(bound, \"attempt to access FKInfo \"+\n\t\t\t\t\t\"before binding\");\n\t\t}\n\t\treturn checkConstraints;\n\t}\t\n\t/**\n\t * Makes the calling object (usually a Statement) dependent on all the constraints.\n\t *\n\t * @param tdl\t\t\t\tThe trigger descriptor list\n\t * @param dependent\t\t\tParent object that will depend on all the constraints\n\t *\t\t\t\t\t\t\tthat we look up. If this argument is null, then we\n\t *\t\t\t\t\t\t\tuse the default dependent (the statement being compiled).\n\t *\n\t * @exception StandardException\t\tThrown on failure\n\t */\n<fim_suffix>\tprivate void createTriggerDependencies\n\t(\n        TriggerDescriptorList       tdl,\n\t\tDependent\t\t\t\t\tdependent\n\t)\n\t\tthrows StandardException\n\t{\n\t\tCompilerContext \t\t\tcompilerContext = getCompilerContext();\n        for (TriggerDescriptor td : tdl) {\n            /*\n            ** The dependent now depends on this trigger.\n            ** The default dependent is the statement being compiled.\n            */\n            if (dependent == null) {\n                compilerContext.createDependency(td);\n            } else {\n                compilerContext.createDependency(dependent, td);\n            }\n        }\n\t}<fim_middle>// function below has no smell\n"}