{"text": "<fim_prefix>\t\tb.childOption(OBSERVER_OPTION, connectionObserver);\n\t}\n\t/**\n\t * Obtain and remove the current childHandler {@link ConnectionObserver} from the\n\t * bootstrap.\n\t *\n\t * @param b the bootstrap to scan\n\t *\n\t * @return current {@link ConnectionObserver} or null\n\t *\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static ConnectionObserver childConnectionObserver(ServerBootstrap b) {\n\t\tObjects.requireNonNull(b, \"bootstrap\");\n\t\tConnectionObserver obs = (ConnectionObserver) b.config()\n\t\t                                               .childOptions()\n\t\t                                               .get(OBSERVER_OPTION);\n\t\tif (obs == null) {\n\t\t\treturn ConnectionObserver.emptyListener(); //will not be triggered in\n\t\t}\n\t\tb.childOption(OBSERVER_OPTION, null);\n\t\treturn obs;\n\t}\n\t/**\n\t * Add the configuration consumer to this {@link Bootstrap} given a unique\n\t * configuration name. Configuration will be run on channel init.\n\t *\n\t * @param b a bootstrap\n\t * @param name a configuration name\n\t * @param c a configuration consumer\n\t * @return the mutated bootstrap\n\t */\n\tpublic static Bootstrap updateConfiguration(Bootstrap b, String name,\n\t\t\t\t\t\t\t\t\t\t\t\tBiConsumer<ConnectionObserver, ? super Channel> c) {\n\t\tObjects.requireNonNull(b, \"bootstrap\");\n\t\tObjects.requireNonNull(name, \"name\");\n\t\tObjects.requireNonNull(c, \"configuration\");\n\t\tb.handler(updateConfiguration(b.config().handler(), name, c));\n\t\treturn b;\n\t}\n\t/**\n\t * Add the configuration consumer to this {@link Bootstrap} given a unique\n\t * configuration name. Configuration will be run on channel init.\n\t *\n\t * @param b a bootstrap\n\t * @param name a configuration name\n\t * @param c a deferred configuration consumer\n\t * @return the mutated bootstrap\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static Bootstrap updateConfiguration(Bootstrap b, String name,\n\t\t\t\t\t\t\t\t\t\t\t\tFunction<? super Bootstrap, ? extends BiConsumer<ConnectionObserver, ? super Channel>> c) {\n\t\tObjects.requireNonNull(b, \"bootstrap\");\n\t\tObjects.requireNonNull(name, \"name\");\n\t\tObjects.requireNonNull(c, \"configuration\");\n\t\tb.handler(updateConfiguration(b.config().handler(), name,\n\t\t\t\t(Function<AbstractBootstrap<?, ?>, BiConsumer<ConnectionObserver, ? super Channel>>)c));\n\t\treturn b;\n\t}\n\t/**\n\t * Add the configuration consumer to this {@link ServerBootstrap} given a unique\n\t * configuration name. Configuration will be run on child channel init.\n\t *\n\t * @param b a server bootstrap\n\t * @param name a configuration name\n\t * @param c a configuration consumer\n\t * @return the mutated bootstrap\n\t */\n\tpublic static ServerBootstrap updateConfiguration(ServerBootstrap b,\n\t\t\tString name,\n\t\t\tBiConsumer<ConnectionObserver, ? super Channel> c) {\n\t\tObjects.requireNonNull(b, \"bootstrap\");\n\t\tObjects.requireNonNull(name, \"name\");\n\t\tObjects.requireNonNull(c, \"configuration\");\n\t\tb.childHandler(updateConfiguration(b.config().childHandler(), name, c));\n\t\treturn b;\n\t}\n\t/**\n\t * Configure log support for a {@link Bootstrap}\n\t *\n\t * @param b the bootstrap to setup\n\t * @param handler the logging handler to setup\n\t *\n\t * @return a mutated {@link Bootstrap}\n\t */\n\tpublic static Bootstrap updateLogSupport(Bootstrap b, LoggingHandler handler) {\n\t\tupdateConfiguration(b, NettyPipeline.LoggingHandler, logConfiguration(handler, SSL_CLIENT_DEBUG));\n\t\treturn b;\n\t}\n\t/**\n\t * Configure log support for a {@link ServerBootstrap}\n\t *\n\t * @param b the bootstrap to setup\n\t * @param handler the logging handler to setup\n\t *\n\t * @return a mutated {@link ServerBootstrap}\n\t */\n\tpublic static ServerBootstrap updateLogSupport(ServerBootstrap b,\n\t\t\t\t\t\t\t\t\t\t\t\t   LoggingHandler handler) {\n\t\tupdateConfiguration(b, NettyPipeline.LoggingHandler, logConfiguration(handler, SSL_SERVER_DEBUG));\n\t\treturn b;\n\t}\n\tstatic ChannelHandler removeConfiguration(ChannelHandler handler, String name) {\n\t\tif (handler instanceof BootstrapPipelineHandler) {\n\t\t\tBootstrapPipelineHandler rph =\n\t\t\t\t\tnew BootstrapPipelineHandler((BootstrapPipelineHandler) handler);\n\t\t\tfor (int i = 0; i < rph.size(); i++) {\n\t\t\t\tif (rph.get(i).name.equals(name)) {\n\t\t\t\t\trph.remove(i);\n\t\t\t\t\treturn rph;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn handler;\n\t}\n\tstatic BootstrapPipelineHandler getOrCreateInitializer(@Nullable ChannelHandler\n\t\t\thandler) {\n\t\tif (handler instanceof BootstrapPipelineHandler) {\n\t\t\treturn new BootstrapPipelineHandler((BootstrapPipelineHandler) handler);\n\t\t}\n\t\telse {\n\t\t\tBootstrapPipelineHandler p = new BootstrapPipelineHandler(Collections.emptyList());\n\t\t\tif (handler != null) {\n\t\t\t\tp.add(new PipelineConfiguration((ctx, ch) -> ch.pipeline()\n\t\t\t\t                                               .addFirst(handler),\n\t\t\t\t\t\t\"user\"));\n\t\t\t}\n\t\t\treturn p;\n\t\t}\n\t}\n\tstatic ChannelHandler updateConfiguration(@Nullable ChannelHandler handler,\n\t\t\tString name,\n\t\t\tBiConsumer<ConnectionObserver, ? super Channel> c) {\n\t\tBootstrapPipelineHandler p = getOrCreateInitializer(handler);\n\t\tp.add(new PipelineConfiguration(c, name));\n\t\treturn p;\n\t}\n\tstatic ChannelHandler updateConfiguration(@Nullable ChannelHandler handler,\n\t\t\tString name,\n\t\t\tFunction<AbstractBootstrap<?, ?>, BiConsumer<ConnectionObserver, ? super Channel>> c) {\n\t\tBootstrapPipelineHandler p = getOrCreateInitializer(handler);\n\t\tp.add(new PipelineConfiguration(c, name));\n\t\treturn p;\n\t}\n\tstatic BiConsumer<ConnectionObserver, ? super Channel> logConfiguration(LoggingHandler handler, boolean debugSsl) {\n\t\tObjects.requireNonNull(handler, \"loggingHandler\");\n\t\treturn new LoggingHandlerSupportConsumer(handler, debugSsl);\n\t}\n\t@ChannelHandler.Sharable\n\tstatic final class BootstrapInitializerHandler extends ChannelInitializer<Channel> {\n\t\tfinal BootstrapPipelineHandler pipeline;\n\t\tfinal ConnectionObserver       listener;\n\t\tfinal ChannelOperations.OnSetup opsFactory;\n\t\tBootstrapInitializerHandler(@Nullable BootstrapPipelineHandler pipeline,\n\t\t\t\tChannelOperations.OnSetup opsFactory,\n\t\t\t\tConnectionObserver listener) {\n\t\t\tthis.pipeline = pipeline;\n\t\t\tthis.opsFactory = opsFactory;\n\t\t\tthis.listener = listener;\n\t\t}\n\t\t@Override\n\t\tprotected void initChannel(Channel ch) {\n\t\t\tif (pipeline != null) {\n\t\t\t\tfor (PipelineConfiguration pipelineConfiguration : pipeline) {\n\t\t\t\t\tpipelineConfiguration.consumer.accept(listener, ch);\n\t\t\t\t}\n\t\t\t}\n\t\t\tChannelOperations.addReactiveBridge(ch, opsFactory, listener);\n\t\t\tif (log.isDebugEnabled()) {\n\t\t\t\tlog.debug(format(ch, \"Initialized pipeline {}\"), ch.pipeline().toString());\n\t\t\t}\n\t\t}\n\t\t@Override\n\t\tpublic void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {\n\t\t\tctx.fireExceptionCaught(cause);\n\t\t}\n\t\t@Override\n\t\tpublic void channelInactive(ChannelHandlerContext ctx) {\n\t\t\tctx.fireChannelInactive();\n\t\t}\n\t}\n\tstatic final Logger log = Loggers.getLogger(BootstrapHandlers.class);\n\tstatic final class PipelineConfiguration {\n\t\tfinal BiConsumer<ConnectionObserver, ? super Channel> consumer;\n\t\tfinal String                                          name;\n\t\tfinal Function<AbstractBootstrap<?, ?>, BiConsumer<ConnectionObserver, ? super Channel>> deferredConsumer;\n\t\tPipelineConfiguration(BiConsumer<ConnectionObserver, ? super Channel> consumer, String name) {\n\t\t\tthis.consumer = consumer;\n\t\t\tthis.name = name;\n\t\t\tthis.deferredConsumer = null;\n\t\t}\n\t\tPipelineConfiguration(Function<AbstractBootstrap<?, ?>, BiConsumer<ConnectionObserver, ? super Channel>> deferredConsumer, String name) {\n\t\t\tthis.consumer = null;\n\t\t\tthis.name = name;\n\t\t\tthis.deferredConsumer = deferredConsumer;\n\t\t}\n\t\t@Override\n\t\tpublic boolean equals(Object o) {\n\t\t\tif (this == o) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (o == null || getClass() != o.getClass()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tPipelineConfiguration that = (PipelineConfiguration) o;\n\t\t\treturn Objects.equals(consumer, that.consumer) &&\n\t\t\t\t\tObjects.equals(name, that.name) &&\n\t\t\t\t\tObjects.equals(deferredConsumer, that.deferredConsumer);\n\t\t}\n<fim_suffix>\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn Objects.hash(consumer, name, deferredConsumer);\n\t\t}<fim_middle>// function below has no smell\n"}