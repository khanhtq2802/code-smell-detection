{"text": "<fim_prefix>        LOG.debug(\"hadoop login commit\");\n      }\n      // if we already have a user, we are done.\n      if (!subject.getPrincipals(User.class).isEmpty()) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"using existing subject:\"+subject.getPrincipals());\n        }\n        return true;\n      }\n      Principal user = null;\n      // if we are using kerberos, try it out\n      if (isAuthenticationMethodEnabled(AuthenticationMethod.KERBEROS)) {\n        user = getCanonicalUser(KerberosPrincipal.class);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"using kerberos user:\"+user);\n        }\n      }\n      //If we don't have a kerberos user and security is disabled, check\n      //if user is specified in the environment or properties\n      if (!isSecurityEnabled() && (user == null)) {\n        String envUser = System.getenv(HADOOP_USER_NAME);\n        if (envUser == null) {\n          envUser = System.getProperty(HADOOP_USER_NAME);\n        }\n        user = envUser == null ? null : new User(envUser);\n      }\n      // use the OS user\n      if (user == null) {\n        user = getCanonicalUser(OS_PRINCIPAL_CLASS);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"using local user:\"+user);\n        }\n      }\n      // if we found the user, add our principal\n      if (user != null) {\n        subject.getPrincipals().add(new User(user.getName()));\n        return true;\n      }\n      LOG.error(\"Can't find user in \" + subject);\n      throw new LoginException(\"Can't find user name\");\n    }\n    @Override\n    public void initialize(Subject subject, CallbackHandler callbackHandler,\n                           Map<String, ?> sharedState, Map<String, ?> options) {\n      this.subject = subject;\n    }\n    @Override\n    public boolean login() throws LoginException {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"hadoop login\");\n      }\n      return true;\n    }\n    @Override\n    public boolean logout() throws LoginException {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"hadoop logout\");\n      }\n      return true;\n    }\n  }\n  /** Metrics to track UGI activity */\n  static UgiMetrics metrics = UgiMetrics.create();\n  /** The auth method to use */\n  private static AuthenticationMethod authenticationMethod;\n  /** Server-side groups fetching service */\n  private static Groups groups;\n  /** Min time (in seconds) before relogin for Kerberos */\n  private static long kerberosMinSecondsBeforeRelogin;\n  /** The configuration to use */\n  private static Configuration conf;\n  /**Environment variable pointing to the token cache file*/\n  public static final String HADOOP_TOKEN_FILE_LOCATION = \n    \"HADOOP_TOKEN_FILE_LOCATION\";\n  /** \n   * A method to initialize the fields that depend on a configuration.\n   * Must be called before useKerberos or groups is used.\n   */\n  private static void ensureInitialized() {\n    if (conf == null) {\n      synchronized(UserGroupInformation.class) {\n        if (conf == null) { // someone might have beat us\n          initialize(new Configuration(), false);\n        }\n      }\n    }\n  }\n  /**\n   * Initialize UGI and related classes.\n   * @param conf the configuration to use\n   */\n  private static synchronized void initialize(Configuration conf,\n                                              boolean overrideNameRules) {\n    authenticationMethod = SecurityUtil.getAuthenticationMethod(conf);\n    if (overrideNameRules || !HadoopKerberosName.hasRulesBeenSet()) {\n      try {\n        HadoopKerberosName.setConfiguration(conf);\n      } catch (IOException ioe) {\n        throw new RuntimeException(\n            \"Problem with Kerberos auth_to_local name configuration\", ioe);\n      }\n    }\n    try {\n        kerberosMinSecondsBeforeRelogin = 1000L * conf.getLong(\n                HADOOP_KERBEROS_MIN_SECONDS_BEFORE_RELOGIN,\n                HADOOP_KERBEROS_MIN_SECONDS_BEFORE_RELOGIN_DEFAULT);\n    }\n    catch(NumberFormatException nfe) {\n        throw new IllegalArgumentException(\"Invalid attribute value for \" +\n                HADOOP_KERBEROS_MIN_SECONDS_BEFORE_RELOGIN + \" of \" +\n                conf.get(HADOOP_KERBEROS_MIN_SECONDS_BEFORE_RELOGIN));\n    }\n    // If we haven't set up testing groups, use the configuration to find it\n    if (!(groups instanceof TestingGroups)) {\n      groups = Groups.getUserToGroupsMappingService(conf);\n    }\n    UserGroupInformation.conf = conf;\n    if (metrics.getGroupsQuantiles == null) {\n      int[] intervals = conf.getInts(HADOOP_USER_GROUP_METRICS_PERCENTILES_INTERVALS);\n      if (intervals != null && intervals.length > 0) {\n        final int length = intervals.length;\n        MutableQuantiles[] getGroupsQuantiles = new MutableQuantiles[length];\n        for (int i = 0; i < length; i++) {\n          getGroupsQuantiles[i] = metrics.registry.newQuantiles(\n            \"getGroups\" + intervals[i] + \"s\",\n            \"Get groups\", \"ops\", \"latency\", intervals[i]);\n        }\n        metrics.getGroupsQuantiles = getGroupsQuantiles;\n      }\n    }\n  }\n  /**\n   * Set the static configuration for UGI.\n   * In particular, set the security authentication mechanism and the\n   * group look up service.\n   * @param conf the configuration to use\n   */\n  @InterfaceAudience.Public\n  @InterfaceStability.Evolving\n  public static void setConfiguration(Configuration conf) {\n    initialize(conf, true);\n  }\n  @InterfaceAudience.Private\n  @VisibleForTesting\n  static void reset() {\n    authenticationMethod = null;\n    conf = null;\n    groups = null;\n    kerberosMinSecondsBeforeRelogin = 0;\n    setLoginUser(null);\n    HadoopKerberosName.setRules(null);\n  }\n  /**\n   * Determine if UserGroupInformation is using Kerberos to determine\n   * user identities or is relying on simple authentication\n   * \n   * @return true if UGI is working in a secure environment\n   */\n  public static boolean isSecurityEnabled() {\n    return !isAuthenticationMethodEnabled(AuthenticationMethod.SIMPLE);\n  }\n  @InterfaceAudience.Private\n  @InterfaceStability.Evolving\n  private static boolean isAuthenticationMethodEnabled(AuthenticationMethod method) {\n    ensureInitialized();\n    return (authenticationMethod == method);\n  }\n  /**\n   * Information about the logged in user.\n   */\n  private static UserGroupInformation loginUser = null;\n  private static String keytabPrincipal = null;\n  private static String keytabFile = null;\n  private final Subject subject;\n  // All non-static fields must be read-only caches that come from the subject.\n  private final User user;\n  private final boolean isKeytab;\n  private final boolean isKrbTkt;\n  private static String OS_LOGIN_MODULE_NAME;\n  private static Class<? extends Principal> OS_PRINCIPAL_CLASS;\n  private static final boolean windows =\n      System.getProperty(\"os.name\").startsWith(\"Windows\");\n  private static final boolean is64Bit =\n      System.getProperty(\"os.arch\").contains(\"64\");\n  private static final boolean aix = System.getProperty(\"os.name\").equals(\"AIX\");\n  /* Return the OS login module class name */\n  private static String getOSLoginModuleName() {\n    if (IBM_JAVA) {\n      if (windows) {\n        return is64Bit ? \"com.ibm.security.auth.module.Win64LoginModule\"\n            : \"com.ibm.security.auth.module.NTLoginModule\";\n      } else if (aix) {\n        return is64Bit ? \"com.ibm.security.auth.module.AIX64LoginModule\"\n            : \"com.ibm.security.auth.module.AIXLoginModule\";\n      } else {\n        return \"com.ibm.security.auth.module.LinuxLoginModule\";\n      }\n    } else {\n      return windows ? \"com.sun.security.auth.module.NTLoginModule\"\n        : \"com.sun.security.auth.module.UnixLoginModule\";\n    }\n  }\n  /* Return the OS principal class */\n<fim_suffix>  @SuppressWarnings(\"unchecked\")\n  private static Class<? extends Principal> getOsPrincipalClass() {\n    ClassLoader cl = ClassLoader.getSystemClassLoader();\n    try {\n      String principalClass = null;\n      if (IBM_JAVA) {\n        if (is64Bit) {\n          principalClass = \"com.ibm.security.auth.UsernamePrincipal\";\n        } else {\n          if (windows) {\n            principalClass = \"com.ibm.security.auth.NTUserPrincipal\";\n          } else if (aix) {\n            principalClass = \"com.ibm.security.auth.AIXPrincipal\";\n          } else {\n            principalClass = \"com.ibm.security.auth.LinuxPrincipal\";\n          }\n        }\n      } else {\n        principalClass = windows ? \"com.sun.security.auth.NTUserPrincipal\"\n            : \"com.sun.security.auth.UnixPrincipal\";\n      }\n      return (Class<? extends Principal>) cl.loadClass(principalClass);\n    } catch (ClassNotFoundException e) {\n      LOG.error(\"Unable to find JAAS classes:\" + e.getMessage());\n    }\n    return null;\n  }<fim_middle>// function below has no smell\n"}