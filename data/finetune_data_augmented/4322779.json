{"text": "<fim_prefix>\t\t\t * temporary conglomerate.  If we're not doing a deferred delete,\n\t\t\t * just delete the rows immediately.\n\t\t\t */\n\t\t\trowsFound = true;\n\t\t\trlColumn = row.getColumn( row.nColumns() );\n\t\t\tif (constants.deferred || cascadeDelete)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t** If we are deferred because of a trigger or foreign\n\t\t\t\t** key, we need to save off the entire row.  Otherwise,\n\t\t\t\t** we just save the RID.\n\t\t\t\t*/\n\t\t\t\tif (noTriggersOrFks)\n\t\t\t\t{\n\t\t\t\t\tdeferredRLRow.setColumn(1, rlColumn);\n\t\t\t\t\trowHolder.insert(deferredRLRow);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\trowHolder.insert(row);\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\t** If we haven't already, lets get a template to\n\t\t\t\t** use as a template for our rescan of the base table.\n\t\t\t\t** Do this now while we have a real row to use\n\t\t\t\t** as a copy.\n\t\t\t\t**\n\t\t\t\t** There is one less column in the base row than\n\t\t\t\t** there is in source row, because the base row\n\t\t\t\t** doesn't contain the row location.\n\t\t\t\t*/\n\t\t\t\tif (deferredBaseRow == null)\n\t\t\t\t{\n\t\t\t\t\tdeferredBaseRow = RowUtil.getEmptyValueRow(numberOfBaseColumns - 1, lcc);\n\t\t\t\t\tRowUtil.copyCloneColumns(deferredBaseRow, row, \n\t\t\t\t\t\t\t\t\t\t\tnumberOfBaseColumns - 1);\n\t\t\t\t\tdeferredSparseRow = makeDeferredSparseRow(deferredBaseRow,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbaseRowReadList,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlcc);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (fkChecker != null)\n\t\t\t\t{\n                    // Argument \"2\" below: If a PK referenced by an FK is\n                    // deferred, require at least two rows to be present in the\n                    // primary table since we are deleting one of them below,\n                    // and we need at least one to fulfill the constraint.\n                    fkChecker.doPKCheck(activation, row, false, 2);\n\t\t\t\t}\n\t\t\t\tbaseRowLocation = \n\t\t\t\t\t(RowLocation) (rlColumn).getObject();\n                if (SanityManager.DEBUG)\n\t\t\t\t{\n\t\t\t\t\tSanityManager.ASSERT(baseRowLocation != null,\n\t\t\t\t\t\t\t\"baseRowLocation is null\");\n\t\t\t\t}\n\t\t\t\trc.deleteRow(row,baseRowLocation);\n\t\t\t\tsource.markRowAsDeleted();\n\t\t\t}\n            rowCount++;\n\t\t\t// No need to do a next on a single row source\n\t\t\tif (constants.singleRowSource)\n\t\t\t{\n\t\t\t\trow = null;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\trow = getNextRowCore(source);\n\t\t\t}\n\t\t}\n\t\treturn rowsFound;\n\t}\n\t// execute the before triggers set on the table\n    void fireBeforeTriggers() throws StandardException\n\t{\n\t\tif (triggerInfo != null)\n\t\t{\n\t\t\tif (triggerActivator == null)\n\t\t\t{\n\t\t\t\ttriggerActivator = new TriggerEventActivator(lcc, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t constants.targetUUID,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t triggerInfo,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t TriggerExecutionContext.DELETE_EVENT,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t activation, null\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttriggerActivator.reopen();\n\t\t\t}\n\t\t\t// fire BEFORE trigger\n\t\t\ttriggerActivator.notifyEvent(TriggerEvents.BEFORE_DELETE, \n\t\t\t\t\t\t\t\t\t\t rowHolder.getResultSet(), \n\t\t\t\t\t\t\t\t\t\t (CursorResultSet)null,\n\t\t\t\t\t\t\t\t\t\t constants.getBaseRowReadMap());\n\t\t\ttriggerActivator.cleanup();\n\t\t}\n\t}\n\t//execute the after triggers set on the table.\n\tvoid fireAfterTriggers() throws StandardException\n\t{\n\t\t// fire AFTER trigger\n\t\tif (triggerActivator != null)\n\t\t{\n\t\t\ttriggerActivator.reopen();\n\t\t\ttriggerActivator.notifyEvent(TriggerEvents.AFTER_DELETE, \n\t\t\t\t\t\t\t\t\t\t rowHolder.getResultSet(),\n\t\t\t\t\t\t\t\t\t\t (CursorResultSet)null,\n\t\t\t\t\t\t\t\t\t\t constants.getBaseRowReadMap());\n\t\t\ttriggerActivator.cleanup();\n\t\t}\n\t}\n\t//delete the rows that in case deferred case and\n\t//during cascade delete (All deletes are deferred during cascade action)\n\tvoid deleteDeferredRows() throws StandardException\n\t{\n\t\tDataValueDescriptor\t\trlColumn;\n \t\tRowLocation\tbaseRowLocation;\n        ExecRow     defRLRow;\n        deferredBaseCC = tc.openCompiledConglomerate(\n                false,\n                (TransactionController.OPENMODE_FORUPDATE|\n                 TransactionController.OPENMODE_SECONDARY_LOCKED),\n                lockMode,\n                TransactionController.ISOLATION_SERIALIZABLE,\n                constants.heapSCOCI,\n                heapDCOCI);\n\t\tCursorResultSet rs = rowHolder.getResultSet();\n\t\ttry\n\t\t{\n\t\t\t/*\n\t\t\t** We need to do a fetch doing a partial row\n\t\t\t** read.  We need to shift our 1-based bit\n\t\t\t** set to a zero based bit set like the store\n\t\t\t** expects.\n\t\t\t*/\n\t\t\tFormatableBitSet readBitSet = RowUtil.shift(baseRowReadList, 1);\n\t\t\trs.open();\n            while ((defRLRow = rs.getNextRow()) != null)\n\t\t\t{\n                rlColumn = defRLRow.getColumn(rlColumnNumber);\n\t\t\t\tbaseRowLocation = \n\t\t\t\t\t(RowLocation) (rlColumn).getObject();\n\t\t\t\t/* Get the base row at the given RowLocation */\n\t\t\t\tboolean row_exists = \n\t\t\t\t\tdeferredBaseCC.fetch(\n\t\t\t\t\t\t\t\t\t\t baseRowLocation, deferredSparseRow.getRowArray(), \n\t\t\t\t\t\t\t\t\t\t readBitSet);\n\t\t\t\t// In case of cascade delete , things like before triggers can delete \n\t\t\t\t// the rows before the dependent result get a chance to delete\n\t\t\t\tif(cascadeDelete && !row_exists)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (SanityManager.DEBUG)\n\t\t\t\t{\n\t\t\t\t\tif (!row_exists)\n\t\t\t\t\t{\n                        \tSanityManager.THROWASSERT(\"could not find row \"+baseRowLocation);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trc.deleteRow(deferredBaseRow, baseRowLocation);\n\t\t\t\tsource.markRowAsDeleted();\n\t\t\t}\n\t\t} finally\n\t\t{\n\t\t\t\trs.close();\n\t\t}\n\t}\n    /**\n     * Make sure foreign key constraints are not violated\n     */\n    void runFkChecker(boolean restrictCheckOnly)\n            throws StandardException\n\t{\n\t\tif (fkChecker != null)\n\t\t{\n\t\t\t/*\n\t\t\t** Second scan to make sure all the foreign key\n\t\t\t** constraints are ok.  We have to do this after\n\t\t\t** we have completed the deletes in case of self referencing\n\t\t\t** constraints.\n\t\t\t*/\n\t\t\tCursorResultSet rs = rowHolder.getResultSet();\n\t\t\ttry\n\t\t\t{\n\t\t\t\trs.open();\n                ExecRow defRLRow;\n                while ((defRLRow = rs.getNextRow()) != null)\n\t\t\t\t{\n                    // Argument \"1\" below: If a PK referenced by an FK is\n                    // deferred, require at least one to be present in the\n                    // primary table since we have deleted the row unless\n                    // postCheck == true, in which the call to postChecks does\n                    // the actual checking, and we need at least one to fulfill\n                    // the constraint.\n                    fkChecker.doPKCheck(\n                            activation,\n                            defRLRow,\n                            restrictCheckOnly,\n                            1);\n\t\t\t\t}\n                if (restrictCheckOnly) {\n                    fkChecker.postCheck();\n                }\n\t\t\t} finally\n\t\t\t{\n\t\t\t\trs.close();\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t  *\tcreate a source for the dependent table\n\t  *\n\t  * <P>Delete Cascade ResultSet class will override this method.\n\t  *\n\t  * @exception StandardException\t\tThrown on error\n\t  */\n\tNoPutResultSet createDependentSource(RowChanger rc)\n\t\tthrows StandardException\n\t{\n\t\treturn null;\n\t}\n\t/**\n\t * @see ResultSet#cleanUp\n\t *\n\t * @exception StandardException\t\tThrown on error\n\t */\n    @Override\n\tpublic void\tcleanUp() throws StandardException\n\t{ \n\t\tnumOpens = 0;\n\t\t/* Close down the source ResultSet tree */\n\t\tif (source != null)\n\t\t{\n\t\t\tsource.close();\n\t\t\t// source is reused across executions\n\t\t}\n\t\tif (rc != null)\n\t\t{\n\t\t\trc.close();\n\t\t\t// rc is reused across executions\n\t\t}\n\t\tif (rowHolder != null)\n\t\t{\n\t\t\trowHolder.close();\n\t\t\t// rowHolder is reused across executions\n\t\t}\n\t\tif (fkChecker != null)\n\t\t{\n\t\t\tfkChecker.close();\n\t\t\t// fkcheckers is reused across executions\n\t\t}\n\t\tif (deferredBaseCC != null)\n\t\t\tdeferredBaseCC.close();\n\t\tdeferredBaseCC = null;\n\t\tif (rc != null) {\n\t\t\trc.close();\n\t\t}\n\t\tclose();\n\t}\n<fim_suffix>    @Override\n    public void close() throws StandardException\n    {\n        super.close( constants.underMerge() );\n    }<fim_middle>// function below has no smell\n"}