{"text": "<fim_prefix>     * However, if the table has been resized, then all future steps\n     * must traverse both the bin at the current index as well as at\n     * (index + baseSize); and so on for further resizings. To\n     * paranoically cope with potential sharing by users of iterators\n     * across threads, iteration terminates if a bounds checks fails\n     * for a table read.\n     */\n    static class Traverser<K,V> {\n        Node<K,V>[] tab;        // current table; updated if resized\n        Node<K,V> next;         // the next entry to use\n        TableStack<K,V> stack, spare; // to save/restore on ForwardingNodes\n        int index;              // index of bin to use next\n        int baseIndex;          // current index of initial table\n        int baseLimit;          // index bound for initial table\n        final int baseSize;     // initial table size\n        Traverser(Node<K,V>[] tab, int size, int index, int limit) {\n            this.tab = tab;\n            this.baseSize = size;\n            this.baseIndex = this.index = index;\n            this.baseLimit = limit;\n            this.next = null;\n        }\n        /**\n         * Advances if possible, returning next valid node, or null if none.\n         */\n        final Node<K,V> advance() {\n            Node<K,V> e;\n            if ((e = next) != null)\n                e = e.next;\n            for (;;) {\n                Node<K,V>[] t; int i, n;  // must use locals in checks\n                if (e != null)\n                    return next = e;\n                if (baseIndex >= baseLimit || (t = tab) == null ||\n                    (n = t.length) <= (i = index) || i < 0)\n                    return next = null;\n                if ((e = tabAt(t, i)) != null && e.hash < 0) {\n                    if (e instanceof ForwardingNode) {\n                        tab = ((ForwardingNode<K,V>)e).nextTable;\n                        e = null;\n                        pushState(t, i, n);\n                        continue;\n                    }\n                    else if (e instanceof TreeBin)\n                        e = ((TreeBin<K,V>)e).first;\n                    else\n                        e = null;\n                }\n                if (stack != null)\n                    recoverState(n);\n                else if ((index = i + baseSize) >= n)\n                    index = ++baseIndex; // visit upper slots if present\n            }\n        }\n        /**\n         * Saves traversal state upon encountering a forwarding node.\n         */\n        private void pushState(Node<K,V>[] t, int i, int n) {\n            TableStack<K,V> s = spare;  // reuse if possible\n            if (s != null)\n                spare = s.next;\n            else\n                s = new TableStack<K,V>();\n            s.tab = t;\n            s.length = n;\n            s.index = i;\n            s.next = stack;\n            stack = s;\n        }\n        /**\n         * Possibly pops traversal state.\n         *\n         * @param n length of current table\n         */\n        private void recoverState(int n) {\n            TableStack<K,V> s; int len;\n            while ((s = stack) != null && (index += (len = s.length)) >= n) {\n                n = len;\n                index = s.index;\n                tab = s.tab;\n                s.tab = null;\n                TableStack<K,V> next = s.next;\n                s.next = spare; // save for reuse\n                stack = next;\n                spare = s;\n            }\n            if (s == null && (index += baseSize) >= n)\n                index = ++baseIndex;\n        }\n    }\n    /**\n     * Base of key, value, and entry Iterators. Adds fields to\n     * Traverser to support iterator.remove.\n     */\n    static class BaseIterator<K,V> extends Traverser<K,V> {\n        final ConcurrentHashMap<K,V> map;\n        Node<K,V> lastReturned;\n        BaseIterator(Node<K,V>[] tab, int size, int index, int limit,\n                    ConcurrentHashMap<K,V> map) {\n            super(tab, size, index, limit);\n            this.map = map;\n            advance();\n        }\n        public final boolean hasNext() { return next != null; }\n        public final boolean hasMoreElements() { return next != null; }\n        public final void remove() {\n            Node<K,V> p;\n            if ((p = lastReturned) == null)\n                throw new IllegalStateException();\n            lastReturned = null;\n            map.replaceNode(p.key, null, null);\n        }\n    }\n    static final class KeyIterator<K,V> extends BaseIterator<K,V>\n        implements Iterator<K>, Enumeration<K> {\n        KeyIterator(Node<K,V>[] tab, int index, int size, int limit,\n                    ConcurrentHashMap<K,V> map) {\n            super(tab, index, size, limit, map);\n        }\n        public final K next() {\n            Node<K,V> p;\n            if ((p = next) == null)\n                throw new NoSuchElementException();\n            K k = p.key;\n            lastReturned = p;\n            advance();\n            return k;\n        }\n        public final K nextElement() { return next(); }\n    }\n    static final class ValueIterator<K,V> extends BaseIterator<K,V>\n        implements Iterator<V>, Enumeration<V> {\n        ValueIterator(Node<K,V>[] tab, int index, int size, int limit,\n                      ConcurrentHashMap<K,V> map) {\n            super(tab, index, size, limit, map);\n        }\n        public final V next() {\n            Node<K,V> p;\n            if ((p = next) == null)\n                throw new NoSuchElementException();\n            V v = p.val;\n            lastReturned = p;\n            advance();\n            return v;\n        }\n        public final V nextElement() { return next(); }\n    }\n    static final class EntryIterator<K,V> extends BaseIterator<K,V>\n        implements Iterator<Map.Entry<K,V>> {\n        EntryIterator(Node<K,V>[] tab, int index, int size, int limit,\n                      ConcurrentHashMap<K,V> map) {\n            super(tab, index, size, limit, map);\n        }\n        public final Map.Entry<K,V> next() {\n            Node<K,V> p;\n            if ((p = next) == null)\n                throw new NoSuchElementException();\n            K k = p.key;\n            V v = p.val;\n            lastReturned = p;\n            advance();\n            return new MapEntry<K,V>(k, v, map);\n        }\n    }\n    /**\n     * Exported Entry for EntryIterator.\n     */\n    static final class MapEntry<K,V> implements Map.Entry<K,V> {\n        final K key; // non-null\n        V val;       // non-null\n        final ConcurrentHashMap<K,V> map;\n        MapEntry(K key, V val, ConcurrentHashMap<K,V> map) {\n            this.key = key;\n            this.val = val;\n            this.map = map;\n        }\n        public K getKey()        { return key; }\n        public V getValue()      { return val; }\n        public int hashCode()    { return key.hashCode() ^ val.hashCode(); }\n        public String toString() {\n            return Helpers.mapEntryToString(key, val);\n        }\n<fim_suffix>        public boolean equals(Object o) {\n            Object k, v; Map.Entry<?,?> e;\n            return ((o instanceof Map.Entry) &&\n                    (k = (e = (Map.Entry<?,?>)o).getKey()) != null &&\n                    (v = e.getValue()) != null &&\n                    (k == key || k.equals(key)) &&\n                    (v == val || v.equals(val)));\n        }<fim_middle>// function below has no smell\n"}