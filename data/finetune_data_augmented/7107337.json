{"text": "<fim_prefix>            case ATTRIBUTE_NODE:\n            case TEXT_NODE:\n            case CDATA_SECTION_NODE:\n            case PROCESSING_INSTRUCTION_NODE:\n            case COMMENT_NODE:\n            case NOTATION_NODE:\n                setNodeValue(textContent);\n                return;\n            default:\n                throw new DOMException(DOMException.NOT_SUPPORTED_ERR,\n                        \"Unsupported node type \" + getNodeType());\n        }\n    }\n    public boolean isSameNode(Node other) {\n        return this == other;\n    }\n    /**\n     * Returns the element whose namespace definitions apply to this node. Use\n     * this element when mapping prefixes to URIs and vice versa.\n     */\n    private NodeImpl getNamespacingElement() {\n        switch (this.getNodeType()) {\n            case ELEMENT_NODE:\n                return this;\n            case DOCUMENT_NODE:\n                return (NodeImpl) ((Document) this).getDocumentElement();\n            case ENTITY_NODE:\n            case NOTATION_NODE:\n            case DOCUMENT_FRAGMENT_NODE:\n            case DOCUMENT_TYPE_NODE:\n                return null;\n            case ATTRIBUTE_NODE:\n                return (NodeImpl) ((Attr) this).getOwnerElement();\n            case TEXT_NODE:\n            case CDATA_SECTION_NODE:\n            case ENTITY_REFERENCE_NODE:\n            case PROCESSING_INSTRUCTION_NODE:\n            case COMMENT_NODE:\n                return getContainingElement();\n            default:\n                throw new DOMException(DOMException.NOT_SUPPORTED_ERR,\n                        \"Unsupported node type \" + getNodeType());\n        }\n    }\n    /**\n     * Returns the nearest ancestor element that contains this node.\n     */\n    private NodeImpl getContainingElement() {\n        for (Node p = getParentNode(); p != null; p = p.getParentNode()) {\n            if (p.getNodeType() == ELEMENT_NODE) {\n                return (NodeImpl) p;\n            }\n        }\n        return null;\n    }\n    public final String lookupPrefix(String namespaceURI) {\n        if (namespaceURI == null) {\n            return null;\n        }\n        // the XML specs define some prefixes (like \"xml\" and \"xmlns\") but this\n        // API is explicitly defined to ignore those.\n        NodeImpl target = getNamespacingElement();\n        for (NodeImpl node = target; node != null; node = node.getContainingElement()) {\n            // check this element's namespace first\n            if (namespaceURI.equals(node.getNamespaceURI())\n                    && target.isPrefixMappedToUri(node.getPrefix(), namespaceURI)) {\n                return node.getPrefix();\n            }\n            // search this element for an attribute of this form:\n            //   xmlns:foo=\"http://namespaceURI\"\n            if (!node.hasAttributes()) {\n                continue;\n            }\n            NamedNodeMap attributes = node.getAttributes();\n            for (int i = 0, length = attributes.getLength(); i < length; i++) {\n                Node attr = attributes.item(i);\n                if (!\"http://www.w3.org/2000/xmlns/\".equals(attr.getNamespaceURI())\n                        || !\"xmlns\".equals(attr.getPrefix())\n                        || !namespaceURI.equals(attr.getNodeValue())) {\n                    continue;\n                }\n                if (target.isPrefixMappedToUri(attr.getLocalName(), namespaceURI)) {\n                    return attr.getLocalName();\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * Returns true if the given prefix is mapped to the given URI on this\n     * element. Since child elements can redefine prefixes, this check is\n     * necessary: {@code\n     * <foo xmlns:a=\"http://good\">\n     *   <bar xmlns:a=\"http://evil\">\n     *     <a:baz />\n     *   </bar>\n     * </foo>}\n     *\n     * @param prefix the prefix to find. Nullable.\n     * @param uri the URI to match. Non-null.\n     */\n    boolean isPrefixMappedToUri(String prefix, String uri) {\n        if (prefix == null) {\n            return false;\n        }\n        String actual = lookupNamespaceURI(prefix);\n        return uri.equals(actual);\n    }\n    public final boolean isDefaultNamespace(String namespaceURI) {\n        String actual = lookupNamespaceURI(null); // null yields the default namespace\n        return namespaceURI == null\n                ? actual == null\n                : namespaceURI.equals(actual);\n    }\n    public final String lookupNamespaceURI(String prefix) {\n        NodeImpl target = getNamespacingElement();\n        for (NodeImpl node = target; node != null; node = node.getContainingElement()) {\n            // check this element's namespace first\n            String nodePrefix = node.getPrefix();\n            if (node.getNamespaceURI() != null) {\n                if (prefix == null // null => default prefix\n                        ? nodePrefix == null\n                        : prefix.equals(nodePrefix)) {\n                    return node.getNamespaceURI();\n                }\n            }\n            // search this element for an attribute of the appropriate form.\n            //    default namespace: xmlns=\"http://resultUri\"\n            //          non default: xmlns:specifiedPrefix=\"http://resultUri\"\n            if (!node.hasAttributes()) {\n                continue;\n            }\n            NamedNodeMap attributes = node.getAttributes();\n            for (int i = 0, length = attributes.getLength(); i < length; i++) {\n                Node attr = attributes.item(i);\n                if (!\"http://www.w3.org/2000/xmlns/\".equals(attr.getNamespaceURI())) {\n                    continue;\n                }\n                if (prefix == null // null => default prefix\n                        ? \"xmlns\".equals(attr.getNodeName())\n                        : \"xmlns\".equals(attr.getPrefix()) && prefix.equals(attr.getLocalName())) {\n                    String value = attr.getNodeValue();\n                    return value.length() > 0 ? value : null;\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * Returns a list of objects such that two nodes are equal if their lists\n     * are equal. Be careful: the lists may contain NamedNodeMaps and Nodes,\n     * neither of which override Object.equals(). Such values must be compared\n     * manually.\n     */\n    private static List<Object> createEqualityKey(Node node) {\n        List<Object> values = new ArrayList<Object>();\n        values.add(node.getNodeType());\n        values.add(node.getNodeName());\n        values.add(node.getLocalName());\n        values.add(node.getNamespaceURI());\n        values.add(node.getPrefix());\n        values.add(node.getNodeValue());\n        for (Node child = node.getFirstChild(); child != null; child = child.getNextSibling()) {\n            values.add(child);\n        }\n        switch (node.getNodeType()) {\n            case DOCUMENT_TYPE_NODE:\n                DocumentTypeImpl doctype = (DocumentTypeImpl) node;\n                values.add(doctype.getPublicId());\n                values.add(doctype.getSystemId());\n                values.add(doctype.getInternalSubset());\n                values.add(doctype.getEntities());\n                values.add(doctype.getNotations());\n                break;\n            case ELEMENT_NODE:\n                Element element = (Element) node;\n                values.add(element.getAttributes());\n                break;\n        }\n        return values;\n    }\n    public final boolean isEqualNode(Node arg) {\n        if (arg == this) {\n            return true;\n        }\n        List<Object> listA = createEqualityKey(this);\n        List<Object> listB = createEqualityKey(arg);\n        if (listA.size() != listB.size()) {\n            return false;\n        }\n        for (int i = 0; i < listA.size(); i++) {\n            Object a = listA.get(i);\n            Object b = listB.get(i);\n            if (a == b) {\n                continue;\n            } else if (a == null || b == null) {\n                return false;\n            } else if (a instanceof String || a instanceof Short) {\n                if (!a.equals(b)) {\n                    return false;\n                }\n            } else if (a instanceof NamedNodeMap) {\n                if (!(b instanceof NamedNodeMap)\n                        || !namedNodeMapsEqual((NamedNodeMap) a, (NamedNodeMap) b)) {\n                    return false;\n                }\n            } else if (a instanceof Node) {\n                if (!(b instanceof Node)\n                        || !((Node) a).isEqualNode((Node) b)) {\n                    return false;\n                }\n            } else {\n                throw new AssertionError(); // unexpected type\n            }\n        }\n        return true;\n    }\n<fim_suffix>    private boolean namedNodeMapsEqual(NamedNodeMap a, NamedNodeMap b) {\n        if (a.getLength() != b.getLength()) {\n            return false;\n        }\n        for (int i = 0; i < a.getLength(); i++) {\n            Node aNode = a.item(i);\n            Node bNode = aNode.getLocalName() == null\n                    ? b.getNamedItem(aNode.getNodeName())\n                    : b.getNamedItemNS(aNode.getNamespaceURI(), aNode.getLocalName());\n            if (bNode == null || !aNode.isEqualNode(bNode)) {\n                return false;\n            }\n        }\n        return true;\n    }<fim_middle>// function below has no smell\n"}