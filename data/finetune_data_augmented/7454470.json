{"text": "<fim_prefix>/*\n * Copyright (c) 2017, 2018, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * The Universal Permissive License (UPL), Version 1.0\n *\n * Subject to the condition set forth below, permission is hereby granted to any\n * person obtaining a copy of this software, associated documentation and/or\n * data (collectively the \"Software\"), free of charge and under any and all\n * copyright rights in the Software, and any and all patent rights owned or\n * freely licensable by each licensor hereunder covering either (i) the\n * unmodified Software as contributed to or provided by such licensor, or (ii)\n * the Larger Works (as defined below), to deal in both\n *\n * (a) the Software, and\n *\n * (b) any piece of software and/or hardware listed in the lrgrwrks.txt file if\n * one is included with the Software each a \"Larger Work\" to which the Software\n * is contributed by such licensors),\n *\n * without restriction, including without limitation the rights to copy, create\n * derivative works of, display, perform, and distribute the Software and make,\n * use, sell, offer for sale, import, export, have made, and have sold the\n * Software and the Larger Work(s), and to sublicense the foregoing rights on\n * either these or other terms.\n *\n * This license is subject to the following condition:\n *\n * The above copyright notice and either this complete permission notice or at a\n * minimum a reference to the UPL must be included in all copies or substantial\n * portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\npackage com.oracle.truffle.polyglot;\n\nimport static com.oracle.truffle.polyglot.VMAccessor.INSTRUMENT;\n\nimport org.graalvm.options.OptionDescriptors;\nimport org.graalvm.polyglot.Instrument;\nimport org.graalvm.polyglot.impl.AbstractPolyglotImpl.AbstractInstrumentImpl;\n\nimport com.oracle.truffle.api.InstrumentInfo;\n\nclass PolyglotInstrument extends AbstractInstrumentImpl implements com.oracle.truffle.polyglot.PolyglotImpl.VMObject {\n\n    Instrument api;\n    InstrumentInfo info;\n    final InstrumentCache cache;\n    final PolyglotEngineImpl engine;\n    private final Object instrumentLock = new Object();\n\n    private volatile OptionDescriptors options;\n    private volatile OptionValuesImpl optionValues;\n    private volatile boolean initialized;\n    private volatile boolean created;\n\n    PolyglotInstrument(PolyglotEngineImpl engine, InstrumentCache cache) {\n        super(engine.impl);\n        this.engine = engine;\n        this.cache = cache;\n    }\n\n    @Override\n    public OptionDescriptors getOptions() {\n        engine.checkState();\n        ensureInitialized();\n        return options;\n    }\n\n    OptionValuesImpl getOptionValues() {\n        if (optionValues == null) {\n            synchronized (instrumentLock) {\n                if (optionValues == null) {\n                    optionValues = new OptionValuesImpl(engine, getOptions());\n                }\n            }\n        }\n        return optionValues;\n    }\n\n    @Override\n    public PolyglotEngineImpl getEngine() {\n        return engine;\n    }\n\n    void ensureInitialized() {\n        if (!initialized) {\n            synchronized (instrumentLock) {\n                if (!initialized) {\n                    try {\n                        Class<?> loadedInstrument = cache.getInstrumentationClass();\n                        INSTRUMENT.initializeInstrument(engine.instrumentationHandler, this, loadedInstrument);\n                        this.options = INSTRUMENT.describeOptions(engine.instrumentationHandler, this, cache.getId());\n                    } catch (Exception e) {\n                        throw new IllegalStateException(String.format(\"Error initializing instrument '%s' using class '%s'.\", cache.getId(), cache.getClassName()), e);\n                    }\n                    initialized = true;\n                }\n            }\n        }\n    }\n\n    void ensureCreated() {\n        if (!created) {\n            synchronized (instrumentLock) {\n                if (!created) {\n                    if (!initialized) {\n                        ensureInitialized();\n                    }\n                    INSTRUMENT.createInstrument(engine.instrumentationHandler, this, cache.services(), getOptionValues());\n                    created = true;\n                }\n            }\n        }\n    }\n\n    void notifyClosing() {\n        if (created) {\n            synchronized (instrumentLock) {\n                if (created) {\n                    INSTRUMENT.finalizeInstrument(engine.instrumentationHandler, this);\n                }\n            }\n        }\n    }\n\n    void ensureClosed() {\n        assert Thread.holdsLock(engine);\n        if (created) {\n            synchronized (instrumentLock) {\n                if (created) {\n                    INSTRUMENT.disposeInstrument(engine.instrumentationHandler, this, false);\n                }\n                created = false;\n                initialized = false;\n                options = null;\n                optionValues = null;\n            }\n        }\n    }\n\n    @Override\n    public <T> T lookup(Class<T> serviceClass) {\n        return lookup(serviceClass, true);\n    }\n\n<fim_suffix>    <T> T lookup(Class<T> serviceClass, boolean wrapExceptions) {\n        engine.checkState();\n        if (cache.supportsService(serviceClass)) {\n            try {\n                ensureCreated();\n            } catch (Throwable t) {\n                if (wrapExceptions) {\n                    throw PolyglotImpl.wrapGuestException(engine, t);\n                } else {\n                    throw t;\n                }\n            }\n            return INSTRUMENT.getInstrumentationHandlerService(engine.instrumentationHandler, this, serviceClass);\n        } else {\n            return null;\n        }\n    }\n\n    @Override\n    public String getId() {\n        return cache.getId();\n    }\n\n    @Override\n    public String getName() {\n        return cache.getName();\n    }\n\n    @Override\n    public String getVersion() {\n        final String version = cache.getVersion();\n        if (version.equals(\"inherit\")) {\n            return engine.getVersion();\n        } else {\n            return version;\n        }\n    }\n\n}<fim_middle>// function below has no smell\n"}