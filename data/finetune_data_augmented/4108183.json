{"text": "<fim_prefix>\n<fim_suffix>public class ARecordPointable extends AbstractPointable {\n    public static final ARecordPointableFactory FACTORY = new ARecordPointableFactory();\n    private final UTF8StringWriter utf8Writer = new UTF8StringWriter();\n    public static final class ARecordPointableFactory implements IPointableFactory {\n        private static final long serialVersionUID = 1L;\n        private ARecordPointableFactory() {\n        }\n        @Override\n        public ARecordPointable createPointable() {\n            return new ARecordPointable();\n        }\n        @Override\n        public ITypeTraits getTypeTraits() {\n            return VarLengthTypeTrait.INSTANCE;\n        }\n        @Override\n        public JsonNode toJson(IPersistedResourceRegistry registry) throws HyracksDataException {\n            return registry.getClassIdentifier(getClass(), serialVersionUID);\n        }\n        @SuppressWarnings(\"squid:S1172\") // unused parameter\n        public static IJsonSerializable fromJson(IPersistedResourceRegistry registry, JsonNode json) {\n            return FACTORY;\n        }\n    }\n    public static final IObjectFactory<IPointable, ATypeTag> ALLOCATOR = type -> new ARecordPointable();\n    static final int TAG_SIZE = 1;\n    static final int RECORD_LENGTH_SIZE = 4;\n    static final int EXPANDED_SIZE = 1;\n    static final int OPEN_OFFSET_SIZE = 4;\n    static final int CLOSED_COUNT_SIZE = 4;\n    static final int FIELD_OFFSET_SIZE = 4;\n    static final int OPEN_COUNT_SIZE = 4;\n    private static final int OPEN_FIELD_HASH_SIZE = 4;\n    private static final int OPEN_FIELD_OFFSET_SIZE = 4;\n    private static final int OPEN_FIELD_HEADER = OPEN_FIELD_HASH_SIZE + OPEN_FIELD_OFFSET_SIZE;\n    private static boolean isOpen(ARecordType recordType) {\n        return recordType == null || recordType.isOpen();\n    }\n    public final int getSchemeFieldCount(ARecordType recordType) {\n        return recordType.getFieldNames().length;\n    }\n    @Override\n    public int getLength() {\n        return IntegerPointable.getInteger(bytes, start + TAG_SIZE);\n    }\n    private boolean isExpanded(ARecordType recordType) {\n        return isOpen(recordType) && BooleanPointable.getBoolean(bytes, start + TAG_SIZE + RECORD_LENGTH_SIZE);\n    }\n    private int getOpenPartOffset(ARecordType recordType) {\n        return start + TAG_SIZE + RECORD_LENGTH_SIZE + (isOpen(recordType) ? EXPANDED_SIZE : 0);\n    }\n    private int getNullBitmapOffset(ARecordType recordType) {\n        return getOpenPartOffset(recordType) + (isExpanded(recordType) ? OPEN_OFFSET_SIZE : 0) + CLOSED_COUNT_SIZE;\n    }\n    private int getNullBitmapSize(ARecordType recordType) {\n        return RecordUtil.computeNullBitmapSize(recordType);\n    }\n    public boolean isClosedFieldNull(ARecordType recordType, int fieldId) {\n        return getNullBitmapSize(recordType) > 0\n                && RecordUtil.isNull(bytes[getNullBitmapOffset(recordType) + fieldId / 4], fieldId);\n    }\n    private boolean isClosedFieldMissing(ARecordType recordType, int fieldId) {\n        return getNullBitmapSize(recordType) > 0\n                && RecordUtil.isMissing(bytes[getNullBitmapOffset(recordType) + fieldId / 4], fieldId);\n    }\n    // -----------------------\n    // Closed field accessors.\n    // -----------------------\n    public final void getClosedFieldValue(ARecordType recordType, int fieldId, DataOutput dOut) throws IOException {\n        if (isClosedFieldNull(recordType, fieldId)) {\n            dOut.writeByte(ATypeTag.SERIALIZED_NULL_TYPE_TAG);\n        } else if (isClosedFieldMissing(recordType, fieldId)) {\n            dOut.writeByte(ATypeTag.SERIALIZED_MISSING_TYPE_TAG);\n        } else {\n            dOut.write(getClosedFieldTag(recordType, fieldId));\n            dOut.write(bytes, getClosedFieldOffset(recordType, fieldId), getClosedFieldSize(recordType, fieldId));\n        }\n    }\n    /**\n     * This is always untagged\n     *\n     * @param recordType\n     * @param fieldId\n     * @param pointable\n     * @throws IOException\n     */\n    public final void getClosedFieldValue(ARecordType recordType, int fieldId, IPointable pointable)\n            throws IOException {\n        if (isClosedFieldNull(recordType, fieldId) || isClosedFieldMissing(recordType, fieldId)) {\n            throw new IllegalStateException(\"Can't read a null or missing field\");\n        }\n        pointable.set(bytes, getClosedFieldOffset(recordType, fieldId), getClosedFieldSize(recordType, fieldId));\n    }\n    private String getClosedFieldName(ARecordType recordType, int fieldId) {\n        return recordType.getFieldNames()[fieldId];\n    }\n    public final void getClosedFieldName(ARecordType recordType, int fieldId, DataOutput dOut) throws IOException {\n        dOut.writeByte(ATypeTag.SERIALIZED_STRING_TYPE_TAG);\n        utf8Writer.writeUTF8(getClosedFieldName(recordType, fieldId), dOut);\n    }\n    public final byte getClosedFieldTag(ARecordType recordType, int fieldId) {\n        return getClosedFieldType(recordType, fieldId).getTypeTag().serialize();\n    }\n    public final IAType getClosedFieldType(ARecordType recordType, int fieldId) {\n        IAType aType = recordType.getFieldTypes()[fieldId];\n        if (NonTaggedFormatUtil.isOptional(aType)) {\n            // optional field: add the embedded non-null type tag\n            aType = ((AUnionType) aType).getActualType();\n        }\n        return aType;\n    }\n    public final int getClosedFieldSize(ARecordType recordType, int fieldId) throws HyracksDataException {\n        if (isClosedFieldNull(recordType, fieldId)) {\n            return 0;\n        }\n        return NonTaggedFormatUtil.getFieldValueLength(bytes, getClosedFieldOffset(recordType, fieldId),\n                getClosedFieldType(recordType, fieldId).getTypeTag(), false);\n    }\n    public final int getClosedFieldOffset(ARecordType recordType, int fieldId) {\n        int offset = getNullBitmapOffset(recordType) + getNullBitmapSize(recordType) + fieldId * FIELD_OFFSET_SIZE;\n        return start + IntegerPointable.getInteger(bytes, offset);\n    }\n    // -----------------------\n    // Open field count.\n    // -----------------------\n    public final int getOpenFieldCount(ARecordType recordType) {\n        return isExpanded(recordType) ? IntegerPointable.getInteger(bytes, getOpenFieldCountOffset(recordType)) : 0;\n    }\n    private int getOpenFieldCountSize(ARecordType recordType) {\n        return isExpanded(recordType) ? OPEN_COUNT_SIZE : 0;\n    }\n    private int getOpenFieldCountOffset(ARecordType recordType) {\n        return start + IntegerPointable.getInteger(bytes, getOpenPartOffset(recordType));\n    }\n    // -----------------------\n    // Open field accessors.\n    // -----------------------\n    public final void getOpenFieldValue(ARecordType recordType, int fieldId, DataOutput dOut) throws IOException {\n        dOut.write(bytes, getOpenFieldValueOffset(recordType, fieldId), getOpenFieldValueSize(recordType, fieldId));\n    }\n    public final int getOpenFieldValueOffset(ARecordType recordType, int fieldId) {\n        return getOpenFieldNameOffset(recordType, fieldId) + getOpenFieldNameSize(recordType, fieldId);\n    }\n    public final int getOpenFieldValueSize(ARecordType recordType, int fieldId) throws HyracksDataException {\n        int offset = getOpenFieldValueOffset(recordType, fieldId);\n        ATypeTag tag = EnumDeserializer.ATYPETAGDESERIALIZER.deserialize(getOpenFieldTag(recordType, fieldId));\n        return NonTaggedFormatUtil.getFieldValueLength(bytes, offset, tag, true);\n    }\n    public final void getOpenFieldName(ARecordType recordType, int fieldId, DataOutput dOut) throws IOException {\n        dOut.writeByte(ATypeTag.SERIALIZED_STRING_TYPE_TAG);\n        dOut.write(bytes, getOpenFieldNameOffset(recordType, fieldId), getOpenFieldNameSize(recordType, fieldId));\n    }\n    public final String getOpenFieldName(ARecordType recordType, int fieldId) {\n        StringBuilder str = new StringBuilder();\n        int offset = getOpenFieldNameOffset(recordType, fieldId);\n        return UTF8StringUtil.toString(str, bytes, offset).toString();\n    }\n    private int getOpenFieldNameSize(ARecordType recordType, int fieldId) {\n        int utfleng = UTF8StringUtil.getUTFLength(bytes, getOpenFieldNameOffset(recordType, fieldId));\n        return utfleng + UTF8StringUtil.getNumBytesToStoreLength(utfleng);<fim_middle>// class below has no smell\n"}