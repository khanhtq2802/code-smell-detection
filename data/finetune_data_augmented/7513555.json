{"text": "<fim_prefix>/*\n * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage org.graalvm.compiler.replacements.nodes;\n\nimport static org.graalvm.compiler.nodeinfo.NodeCycles.CYCLES_2;\nimport static org.graalvm.compiler.nodeinfo.NodeSize.SIZE_1;\n\nimport org.graalvm.compiler.core.common.type.IntegerStamp;\nimport org.graalvm.compiler.core.common.type.PrimitiveStamp;\nimport org.graalvm.compiler.core.common.type.Stamp;\nimport org.graalvm.compiler.core.common.type.StampFactory;\nimport org.graalvm.compiler.graph.NodeClass;\nimport org.graalvm.compiler.graph.spi.CanonicalizerTool;\nimport org.graalvm.compiler.lir.gen.ArithmeticLIRGeneratorTool;\nimport org.graalvm.compiler.nodeinfo.NodeInfo;\nimport org.graalvm.compiler.nodes.ConstantNode;\nimport org.graalvm.compiler.nodes.NodeView;\nimport org.graalvm.compiler.nodes.ValueNode;\nimport org.graalvm.compiler.nodes.calc.UnaryNode;\nimport org.graalvm.compiler.nodes.spi.ArithmeticLIRLowerable;\nimport org.graalvm.compiler.nodes.spi.NodeLIRBuilderTool;\n\nimport jdk.vm.ci.code.CodeUtil;\nimport jdk.vm.ci.meta.JavaConstant;\nimport jdk.vm.ci.meta.JavaKind;\n\n/**\n * Determines the index of the least significant \"1\" bit. Note that the result is undefined if the\n * input is zero.\n */\n<fim_suffix>@NodeInfo(cycles = CYCLES_2, size = SIZE_1)\npublic final class BitScanForwardNode extends UnaryNode implements ArithmeticLIRLowerable {\n\n    public static final NodeClass<BitScanForwardNode> TYPE = NodeClass.create(BitScanForwardNode.class);\n\n    public BitScanForwardNode(ValueNode value) {\n        super(TYPE, StampFactory.forInteger(JavaKind.Int, 0, ((PrimitiveStamp) value.stamp(NodeView.DEFAULT)).getBits()), value);\n        assert value.getStackKind() == JavaKind.Int || value.getStackKind() == JavaKind.Long;\n    }\n\n    @Override\n    public Stamp foldStamp(Stamp newStamp) {\n        assert newStamp.isCompatible(getValue().stamp(NodeView.DEFAULT));\n        IntegerStamp valueStamp = (IntegerStamp) newStamp;\n        int min;\n        int max;\n        long mask = CodeUtil.mask(valueStamp.getBits());\n        int firstAlwaysSetBit = scan(valueStamp.downMask() & mask);\n        int firstMaybeSetBit = scan(valueStamp.upMask() & mask);\n        if (firstAlwaysSetBit == -1) {\n            int lastMaybeSetBit = BitScanReverseNode.scan(valueStamp.upMask() & mask);\n            min = firstMaybeSetBit;\n            max = lastMaybeSetBit;\n        } else {\n            min = firstMaybeSetBit;\n            max = firstAlwaysSetBit;\n        }\n        return StampFactory.forInteger(JavaKind.Int, min, max);\n    }\n\n    public static ValueNode tryFold(ValueNode value) {\n        if (value.isConstant()) {\n            JavaConstant c = value.asJavaConstant();\n            if (c.asLong() != 0) {\n                return ConstantNode.forInt(value.getStackKind() == JavaKind.Int ? scan(c.asInt()) : scan(c.asLong()));\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public ValueNode canonical(CanonicalizerTool tool, ValueNode forValue) {\n        ValueNode folded = tryFold(forValue);\n        return folded != null ? folded : this;\n    }\n\n    /**\n     * Utility method with defined return value for 0.\n     *\n     * @param v\n     * @return number of trailing zeros or -1 if {@code v} == 0.\n     */\n    public static int scan(long v) {\n        if (v == 0) {\n            return -1;\n        }\n        return Long.numberOfTrailingZeros(v);\n    }\n\n    /**\n     * Utility method with defined return value for 0.\n     *\n     * @param v\n     * @return number of trailing zeros or -1 if {@code v} == 0.\n     */\n    public static int scan(int v) {\n        return scan(0xffffffffL & v);\n    }\n\n    /**\n     * Raw intrinsic for bsf instruction.\n     *\n     * @param v\n     * @return number of trailing zeros or an undefined value if {@code v} == 0.\n     */\n    @NodeIntrinsic\n    public static native int unsafeScan(long v);\n\n    /**\n     * Raw intrinsic for bsf instruction.\n     *\n     * @param v\n     * @return number of trailing zeros or an undefined value if {@code v} == 0.\n     */\n    @NodeIntrinsic\n    public static native int unsafeScan(int v);\n\n    @Override\n    public void generate(NodeLIRBuilderTool builder, ArithmeticLIRGeneratorTool gen) {\n        builder.setResult(this, gen.emitBitScanForward(builder.operand(getValue())));\n    }\n}<fim_middle>// class below has no smell\n"}