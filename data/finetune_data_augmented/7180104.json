{"text": "<fim_prefix>        }\n        File file = new File(root, filename);\n        if (hist == null) {\n            hist = new History();\n            // File based history cache does not store files for individual\n            // changesets so strip them unless it is history for the repository.\n            for (HistoryEntry ent : historyEntries) {\n                if (file.isDirectory() && filename.equals(repository.getDirectoryName())) {\n                    ent.stripTags();\n                } else {\n                    ent.strip();\n                }\n            }\n            // add all history entries\n            hist.setHistoryEntries(historyEntries);\n        } else {\n            for (HistoryEntry ent : hist.getHistoryEntries()) {\n                ent.strip();\n            }\n        }\n        // Assign tags to changesets they represent.\n        if (env.isTagsEnabled() && repository.hasFileBasedTags()) {\n            repository.assignTagsInHistory(hist);\n        }\n        // Only store directory history for the top-level.\n        if (!file.isDirectory() || filename.equals(repository.getDirectoryName())) {\n            storeFile(hist, file, repository, !renamed);\n        }\n    }\n    private boolean isRenamedFile(String filename,\n            RuntimeEnvironment env,\n            Repository repository, History history) throws IOException {\n        String repodir;\n        try {\n            repodir = env.getPathRelativeToSourceRoot(\n                new File(repository.getDirectoryName()));\n        } catch (ForbiddenSymlinkException e) {\n            LOGGER.log(Level.FINER, e.getMessage());\n            return false;\n        }\n        String shortestfile = filename.substring(repodir.length() + 1);\n        return (history.isRenamed(shortestfile));\n    }\n    static class FilePersistenceDelegate extends PersistenceDelegate {\n        @Override\n        protected Expression instantiate(Object oldInstance, Encoder out) {\n            File f = (File)oldInstance;\n            return new Expression(oldInstance, f.getClass(), \"new\",\n                new Object[] {f.toString()});\n        }\n    }\n    @Override\n    public void initialize() {\n        // nothing to do\n    }\n    @Override\n    public void optimize() {\n        // nothing to do\n    }\n    @Override\n    public boolean supportsRepository(Repository repository) {\n        // all repositories are supported\n        return true;\n    }\n    /**\n     * Get a <code>File</code> object describing the cache file.\n     *\n     * @param file the file to find the cache for\n     * @return file that might contain cached history for <code>file</code>\n     */\n    private static File getCachedFile(File file) throws HistoryException,\n            ForbiddenSymlinkException {\n        RuntimeEnvironment env = RuntimeEnvironment.getInstance();\n        StringBuilder sb = new StringBuilder();\n        sb.append(env.getDataRootPath());\n        sb.append(File.separatorChar);\n        sb.append(HISTORY_CACHE_DIR_NAME);\n        try {\n            String add = env.getPathRelativeToSourceRoot(file);\n            if (add.length() == 0) {\n                add = File.separator;\n            }\n            sb.append(add);\n            if (file.isDirectory()) {\n                sb.append(File.separator);\n                sb.append(DIRECTORY_FILE_PREFIX);\n            }\n        } catch (IOException e) {\n            throw new HistoryException(\"Failed to get path relative to \" +\n                    \"source root for \" + file, e);\n        }\n        return new File(TandemPath.join(sb.toString(), \".gz\"));\n    }\n    /**\n     * Read history from a file.\n     */\n    private static History readCache(File file) throws IOException {\n        try (FileInputStream in = new FileInputStream(file);\n            XMLDecoder d = new XMLDecoder(new GZIPInputStream(\n                new BufferedInputStream(in)))) {\n            return (History) d.readObject();\n        }\n    }\n    /**\n     * Store history in file on disk.\n     * @param dir directory where the file will be saved\n     * @param history history to store\n     * @param cacheFile the file to store the history to\n     * @throws HistoryException\n     */\n    private void writeHistoryToFile(File dir, History history, File cacheFile) throws HistoryException {\n        // We have a problem that multiple threads may access the cache layer\n        // at the same time. Since I would like to avoid read-locking, I just\n        // serialize the write access to the cache file. The generation of the\n        // cache file would most likely be executed during index generation, and\n        // that happens sequencial anyway....\n        // Generate the file with a temporary name and move it into place when\n        // I'm done so I don't have to protect the readers for partially updated\n        // files...\n        final File output;\n        try {\n            output = File.createTempFile(\"oghist\", null, dir);\n            try (FileOutputStream out = new FileOutputStream(output);\n                XMLEncoder e = new XMLEncoder(new GZIPOutputStream(\n                    new BufferedOutputStream(out)))) {\n                e.setPersistenceDelegate(File.class,\n                        new FilePersistenceDelegate());\n                e.writeObject(history);\n            }\n        } catch (IOException ioe) {\n            throw new HistoryException(\"Failed to write history\", ioe);\n        }\n        synchronized (lock) {\n            if (!cacheFile.delete() && cacheFile.exists()) {\n                if (!output.delete()) {\n                    LOGGER.log(Level.WARNING,\n                            \"Failed to remove temporary history cache file\");\n                }\n                throw new HistoryException(\n                        \"Cachefile exists, and I could not delete it.\");\n            }\n            if (!output.renameTo(cacheFile)) {\n                if (!output.delete()) {\n                    LOGGER.log(Level.WARNING,\n                            \"Failed to remove temporary history cache file\");\n                }\n                throw new HistoryException(\"Failed to rename cache tmpfile.\");\n            }\n        }\n    }\n    /**\n     * Read history from cacheFile and merge it with histNew, return merged history.\n     *\n     * @param cacheFile file to where the history object will be stored\n     * @param histNew history object with new history entries\n     * @param repo repository to where pre pre-image of the cacheFile belong\n     * @return merged history (can be null if merge failed for some reason)\n     * @throws HistoryException\n     */\n    private History mergeOldAndNewHistory(File cacheFile, History histNew, Repository repo)\n            throws HistoryException {\n        History histOld;\n        History history = null;\n        try {\n            histOld = readCache(cacheFile);\n            // Merge old history with the new history.\n            List<HistoryEntry> listOld = histOld.getHistoryEntries();\n            if (!listOld.isEmpty()) {\n                RuntimeEnvironment env = RuntimeEnvironment.getInstance();\n                List<HistoryEntry> listNew = histNew.getHistoryEntries();\n                ListIterator<HistoryEntry> li = listNew.listIterator(listNew.size());\n                while (li.hasPrevious()) {\n                    listOld.add(0, li.previous());\n                }\n                history = new History(listOld);\n                // Retag the last changesets in case there have been some new\n                // tags added to the repository. Technically we should just\n                // retag the last revision from the listOld however this\n                // does not solve the problem when listNew contains new tags\n                // retroactively tagging changesets from listOld so we resort\n                // to this somewhat crude solution.\n                if (env.isTagsEnabled() && repo.hasFileBasedTags()) {\n                    for (HistoryEntry ent : history.getHistoryEntries()) {\n                        ent.setTags(null);\n                    }\n                    repo.assignTagsInHistory(history);\n                }\n            }\n        } catch (IOException ex) {\n            LOGGER.log(Level.SEVERE,\n                String.format(\"Cannot open history cache file %s\", cacheFile.getPath()), ex);\n        }\n        return history;\n    }\n    /**\n     * Store history object (encoded as XML and compressed with gzip) in a file.\n     *\n     * @param histNew history object to store\n     * @param file file to store the history object into\n     * @param repo repository for the file\n     * @param mergeHistory whether to merge the history with existing or\n     *                     store the histNew as is\n     * @throws HistoryException\n     */\n<fim_suffix>    private void storeFile(History histNew, File file, Repository repo,\n            boolean mergeHistory) throws HistoryException {\n        File cacheFile;\n        try {\n            cacheFile = getCachedFile(file);\n        } catch (ForbiddenSymlinkException e) {\n            LOGGER.log(Level.FINER, e.getMessage());\n            return;\n        }\n        History history = histNew;\n        File dir = cacheFile.getParentFile();\n        if (!dir.isDirectory() && !dir.mkdirs()) {\n            throw new HistoryException(\n                    \"Unable to create cache directory '\" + dir + \"'.\");\n        }\n        if (mergeHistory && cacheFile.exists()) {\n            history = mergeOldAndNewHistory(cacheFile, histNew, repo);\n        }\n        // If the merge failed, null history will be returned.\n        // In such case store at least new history as a best effort.\n        if (history != null) {\n            writeHistoryToFile(dir, history, cacheFile);\n        } else {\n            writeHistoryToFile(dir, histNew, cacheFile);\n        }\n    }<fim_middle>// function below has no smell\n"}