{"text": "<fim_prefix>      }\n      return locs;\n    } else {\n      return null;\n    }\n  }\n  private RegionLocations locateRowBeforeInCache(TableCache tableCache, TableName tableName,\n      byte[] row, int replicaId) {\n    boolean isEmptyStopRow = isEmptyStopRow(row);\n    Map.Entry<byte[], RegionLocations> entry =\n      isEmptyStopRow ? tableCache.cache.lastEntry() : tableCache.cache.lowerEntry(row);\n    if (entry == null) {\n      return null;\n    }\n    RegionLocations locs = entry.getValue();\n    HRegionLocation loc = locs.getRegionLocation(replicaId);\n    if (loc == null) {\n      return null;\n    }\n    if (isEmptyStopRow(loc.getRegion().getEndKey()) ||\n      (!isEmptyStopRow && Bytes.compareTo(loc.getRegion().getEndKey(), row) >= 0)) {\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(\"Found {} in cache for {}, row='{}', locateType={}, replicaId={}\", loc, tableName,\n          Bytes.toStringBinary(row), RegionLocateType.BEFORE, replicaId);\n      }\n      return locs;\n    } else {\n      return null;\n    }\n  }\n  private void locateInMeta(TableName tableName, LocateRequest req) {\n    if (LOG.isTraceEnabled()) {\n      LOG.trace(\"Try locate '\" + tableName + \"', row='\" + Bytes.toStringBinary(req.row) +\n        \"', locateType=\" + req.locateType + \" in meta\");\n    }\n    byte[] metaStartKey;\n    if (req.locateType.equals(RegionLocateType.BEFORE)) {\n      if (isEmptyStopRow(req.row)) {\n        byte[] binaryTableName = tableName.getName();\n        metaStartKey = Arrays.copyOf(binaryTableName, binaryTableName.length + 1);\n      } else {\n        metaStartKey = createRegionName(tableName, req.row, ZEROES, false);\n      }\n    } else {\n      metaStartKey = createRegionName(tableName, req.row, NINES, false);\n    }\n    byte[] metaStopKey =\n      RegionInfo.createRegionName(tableName, HConstants.EMPTY_START_ROW, \"\", false);\n    conn.getTable(META_TABLE_NAME)\n      .scan(new Scan().withStartRow(metaStartKey).withStopRow(metaStopKey, true)\n        .addFamily(HConstants.CATALOG_FAMILY).setReversed(true).setCaching(locatePrefetchLimit)\n        .setReadType(ReadType.PREAD), new AdvancedScanResultConsumer() {\n          private boolean completeNormally = false;\n          private boolean tableNotFound = true;\n          @Override\n          public void onError(Throwable error) {\n            complete(tableName, req, null, error);\n          }\n          @Override\n          public void onComplete() {\n            if (tableNotFound) {\n              complete(tableName, req, null, new TableNotFoundException(tableName));\n            } else if (!completeNormally) {\n              complete(tableName, req, null, new IOException(\"Unable to find region for '\" +\n                Bytes.toStringBinary(req.row) + \"' in \" + tableName));\n            }\n          }\n          @Override\n          public void onNext(Result[] results, ScanController controller) {\n            if (results.length == 0) {\n              return;\n            }\n            tableNotFound = false;\n            int i = 0;\n            for (; i < results.length; i++) {\n              if (onScanNext(tableName, req, results[i])) {\n                completeNormally = true;\n                controller.terminate();\n                i++;\n                break;\n              }\n            }\n            // Add the remaining results into cache\n            if (i < results.length) {\n              TableCache tableCache = getTableCache(tableName);\n              for (; i < results.length; i++) {\n                RegionLocations locs = MetaTableAccessor.getRegionLocations(results[i]);\n                if (locs == null) {\n                  continue;\n                }\n                HRegionLocation loc = locs.getDefaultRegionLocation();\n                if (loc == null) {\n                  continue;\n                }\n                RegionInfo info = loc.getRegion();\n                if (info == null || info.isOffline() || info.isSplitParent()) {\n                  continue;\n                }\n                RegionLocations addedLocs = addToCache(tableCache, locs);\n                synchronized (tableCache) {\n                  tableCache.clearCompletedRequests(Optional.of(addedLocs));\n                }\n              }\n            }\n          }\n        });\n  }\n  private RegionLocations locateInCache(TableCache tableCache, TableName tableName, byte[] row,\n      int replicaId, RegionLocateType locateType) {\n    return locateType.equals(RegionLocateType.BEFORE)\n      ? locateRowBeforeInCache(tableCache, tableName, row, replicaId)\n      : locateRowInCache(tableCache, tableName, row, replicaId);\n  }\n  // locateToPrevious is true means we will use the start key of a region to locate the region\n  // placed before it. Used for reverse scan. See the comment of\n  // AsyncRegionLocator.getPreviousRegionLocation.\n  private CompletableFuture<RegionLocations> getRegionLocationsInternal(TableName tableName,\n      byte[] row, int replicaId, RegionLocateType locateType, boolean reload) {\n    // AFTER should be convert to CURRENT before calling this method\n    assert !locateType.equals(RegionLocateType.AFTER);\n    TableCache tableCache = getTableCache(tableName);\n    if (!reload) {\n      RegionLocations locs = locateInCache(tableCache, tableName, row, replicaId, locateType);\n      if (isGood(locs, replicaId)) {\n        return CompletableFuture.completedFuture(locs);\n      }\n    }\n    CompletableFuture<RegionLocations> future;\n    LocateRequest req;\n    boolean sendRequest = false;\n    synchronized (tableCache) {\n      // check again\n      if (!reload) {\n        RegionLocations locs = locateInCache(tableCache, tableName, row, replicaId, locateType);\n        if (isGood(locs, replicaId)) {\n          return CompletableFuture.completedFuture(locs);\n        }\n      }\n      req = new LocateRequest(row, locateType);\n      future = tableCache.allRequests.get(req);\n      if (future == null) {\n        future = new CompletableFuture<>();\n        tableCache.allRequests.put(req, future);\n        if (tableCache.hasQuota(maxConcurrentLocateRequestPerTable) && !tableCache.isPending(req)) {\n          tableCache.send(req);\n          sendRequest = true;\n        }\n      }\n    }\n    if (sendRequest) {\n      locateInMeta(tableName, req);\n    }\n    return future;\n  }\n  CompletableFuture<RegionLocations> getRegionLocations(TableName tableName, byte[] row,\n      int replicaId, RegionLocateType locateType, boolean reload) {\n    // as we know the exact row after us, so we can just create the new row, and use the same\n    // algorithm to locate it.\n    if (locateType.equals(RegionLocateType.AFTER)) {\n      row = createClosestRowAfter(row);\n      locateType = RegionLocateType.CURRENT;\n    }\n    return getRegionLocationsInternal(tableName, row, replicaId, locateType, reload);\n  }\n  private void removeLocationFromCache(HRegionLocation loc) {\n    TableCache tableCache = cache.get(loc.getRegion().getTable());\n    if (tableCache == null) {\n      return;\n    }\n    byte[] startKey = loc.getRegion().getStartKey();\n    for (;;) {\n      RegionLocations oldLocs = tableCache.cache.get(startKey);\n      HRegionLocation oldLoc = oldLocs.getRegionLocation(loc.getRegion().getReplicaId());\n      if (!canUpdateOnError(loc, oldLoc)) {\n        return;\n      }\n      RegionLocations newLocs = removeRegionLocation(oldLocs, loc.getRegion().getReplicaId());\n      if (newLocs == null) {\n        if (tableCache.cache.remove(startKey, oldLocs)) {\n          return;\n        }\n      } else {\n        if (tableCache.cache.replace(startKey, oldLocs, newLocs)) {\n          return;\n        }\n      }\n    }\n  }\n  private void addLocationToCache(HRegionLocation loc) {\n    addToCache(getTableCache(loc.getRegion().getTable()), createRegionLocations(loc));\n  }\n  private HRegionLocation getCachedLocation(HRegionLocation loc) {\n    TableCache tableCache = cache.get(loc.getRegion().getTable());\n    if (tableCache == null) {\n      return null;\n    }\n    RegionLocations locs = tableCache.cache.get(loc.getRegion().getStartKey());\n    return locs != null ? locs.getRegionLocation(loc.getRegion().getReplicaId()) : null;\n  }\n<fim_suffix>  void updateCachedLocationOnError(HRegionLocation loc, Throwable exception) {\n    AsyncRegionLocatorHelper.updateCachedLocationOnError(loc, exception, this::getCachedLocation,\n      this::addLocationToCache, this::removeLocationFromCache);\n  }<fim_middle>// function below has no smell\n"}