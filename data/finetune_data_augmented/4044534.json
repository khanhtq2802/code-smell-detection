{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.beam.runners.core.construction;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.apache.beam.sdk.Pipeline;\nimport org.apache.beam.sdk.runners.AppliedPTransform;\nimport org.apache.beam.sdk.runners.PTransformOverrideFactory;\nimport org.apache.beam.sdk.transforms.DoFn;\nimport org.apache.beam.sdk.transforms.Flatten;\nimport org.apache.beam.sdk.transforms.Flatten.PCollections;\nimport org.apache.beam.sdk.transforms.PTransform;\nimport org.apache.beam.sdk.transforms.ParDo;\nimport org.apache.beam.sdk.values.PCollection;\nimport org.apache.beam.sdk.values.PCollectionList;\nimport org.apache.beam.sdk.values.PValue;\nimport org.apache.beam.sdk.values.TupleTag;\nimport org.apache.beam.vendor.guava.v20_0.com.google.common.annotations.VisibleForTesting;\n\n/**\n * A {@link PTransformOverrideFactory} that will apply a flatten where no element appears in the\n * input {@link PCollectionList} more than once.\n */\npublic class DeduplicatedFlattenFactory<T>\n    implements PTransformOverrideFactory<\n        PCollectionList<T>, PCollection<T>, Flatten.PCollections<T>> {\n\n  public static <T> DeduplicatedFlattenFactory<T> create() {\n    return new DeduplicatedFlattenFactory<>();\n  }\n\n  private DeduplicatedFlattenFactory() {}\n\n  @Override\n  public PTransformReplacement<PCollectionList<T>, PCollection<T>> getReplacementTransform(\n      AppliedPTransform<PCollectionList<T>, PCollection<T>, PCollections<T>> transform) {\n    return PTransformReplacement.of(\n        getInput(transform.getInputs(), transform.getPipeline()),\n        new FlattenWithoutDuplicateInputs<>());\n  }\n\n  /**\n   * {@inheritDoc}.\n   *\n   * <p>The input {@link PCollectionList} that is constructed will have the same values in the same\n   */\n  private PCollectionList<T> getInput(Map<TupleTag<?>, PValue> inputs, Pipeline p) {\n    PCollectionList<T> pCollections = PCollectionList.empty(p);\n    for (PValue input : inputs.values()) {\n      PCollection<T> pcollection = (PCollection<T>) input;\n      pCollections = pCollections.and(pcollection);\n    }\n    return pCollections;\n  }\n\n  @Override\n  public Map<PValue, ReplacementOutput> mapOutputs(\n      Map<TupleTag<?>, PValue> outputs, PCollection<T> newOutput) {\n    return ReplacementOutputs.singleton(outputs, newOutput);\n  }\n\n<fim_suffix>  @VisibleForTesting\n  static class FlattenWithoutDuplicateInputs<T>\n      extends PTransform<PCollectionList<T>, PCollection<T>> {\n    @Override\n    public PCollection<T> expand(PCollectionList<T> input) {\n      Map<PCollection<T>, Integer> instances = new HashMap<>();\n      for (PCollection<T> pCollection : input.getAll()) {\n        int existing = instances.get(pCollection) == null ? 0 : instances.get(pCollection);\n        instances.put(pCollection, existing + 1);\n      }\n      PCollectionList<T> output = PCollectionList.empty(input.getPipeline());\n      for (Map.Entry<PCollection<T>, Integer> instanceEntry : instances.entrySet()) {\n        if (instanceEntry.getValue().equals(1)) {\n          output = output.and(instanceEntry.getKey());\n        } else {\n          String duplicationName = String.format(\"Multiply %s\", instanceEntry.getKey().getName());\n          PCollection<T> duplicated =\n              instanceEntry\n                  .getKey()\n                  .apply(duplicationName, ParDo.of(new DuplicateFn<>(instanceEntry.getValue())));\n          output = output.and(duplicated);\n        }\n      }\n      return output.apply(Flatten.pCollections());\n    }\n  }\n\n  private static class DuplicateFn<T> extends DoFn<T, T> {\n    private final int numTimes;\n\n    private DuplicateFn(int numTimes) {\n      this.numTimes = numTimes;\n    }\n\n    @ProcessElement\n    public void emitCopies(ProcessContext context) {\n      for (int i = 0; i < numTimes; i++) {\n        context.output(context.element());\n      }\n    }\n  }\n}<fim_middle>// class below has no smell\n"}