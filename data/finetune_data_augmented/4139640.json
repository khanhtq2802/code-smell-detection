{"text": "<fim_prefix> * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.calcite.schema.impl;\nimport org.apache.calcite.plan.RelOptTable;\nimport org.apache.calcite.plan.RelOptUtil;\nimport org.apache.calcite.rel.type.RelDataType;\nimport org.apache.calcite.rel.type.RelDataTypeFactory;\nimport org.apache.calcite.rel.type.RelDataTypeField;\nimport org.apache.calcite.rel.type.RelDataTypeImpl;\nimport org.apache.calcite.rel.type.RelProtoDataType;\nimport org.apache.calcite.rex.RexBuilder;\nimport org.apache.calcite.rex.RexNode;\nimport org.apache.calcite.schema.ColumnStrategy;\nimport org.apache.calcite.schema.ExtensibleTable;\nimport org.apache.calcite.schema.ModifiableView;\nimport org.apache.calcite.schema.Path;\nimport org.apache.calcite.schema.Table;\nimport org.apache.calcite.schema.Wrapper;\nimport org.apache.calcite.sql.SqlFunction;\nimport org.apache.calcite.sql2rel.InitializerContext;\nimport org.apache.calcite.sql2rel.InitializerExpressionFactory;\nimport org.apache.calcite.sql2rel.NullInitializerExpressionFactory;\nimport org.apache.calcite.util.ImmutableIntList;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport static org.apache.calcite.sql.validate.SqlValidatorUtil.mapNameToIndex;\n/** Extension to {@link ViewTable} that is modifiable. */\npublic class ModifiableViewTable extends ViewTable\n    implements ModifiableView, Wrapper {\n  private final Table table;\n  private final Path tablePath;\n  private final RexNode constraint;\n  private final ImmutableIntList columnMapping;\n  private final InitializerExpressionFactory initializerExpressionFactory;\n  /** Creates a ModifiableViewTable. */\n  public ModifiableViewTable(Type elementType, RelProtoDataType rowType,\n      String viewSql, List<String> schemaPath, List<String> viewPath,\n      Table table, Path tablePath, RexNode constraint,\n      ImmutableIntList columnMapping) {\n    super(elementType, rowType, viewSql, schemaPath, viewPath);\n    this.table = table;\n    this.tablePath = tablePath;\n    this.constraint = constraint;\n    this.columnMapping = columnMapping;\n    this.initializerExpressionFactory = new ModifiableViewTableInitializerExpressionFactory();\n  }\n  public RexNode getConstraint(RexBuilder rexBuilder,\n      RelDataType tableRowType) {\n    return rexBuilder.copy(constraint);\n  }\n  public ImmutableIntList getColumnMapping() {\n    return columnMapping;\n  }\n  public Table getTable() {\n    return table;\n  }\n  public Path getTablePath() {\n    return tablePath;\n  }\n  @Override public <C> C unwrap(Class<C> aClass) {\n    if (aClass.isInstance(initializerExpressionFactory)) {\n      return aClass.cast(initializerExpressionFactory);\n    } else if (aClass.isInstance(table)) {\n      return aClass.cast(table);\n    }\n    return super.unwrap(aClass);\n  }\n  /**\n   * Extends the underlying table and returns a new view with updated row-type\n   * and column-mapping.\n   *\n   * <p>The type factory is used to perform some scratch calculations, viz the\n   * type mapping, but the \"real\" row-type will be assigned later, when the\n   * table has been bound to the statement's type factory. The is important,\n   * because adding types to type factories that do not belong to a statement\n   * could potentially leak memory.\n   *\n   * @param extendedColumns Extended fields\n   * @param typeFactory Type factory\n   */\n  public final ModifiableViewTable extend(\n      List<RelDataTypeField> extendedColumns, RelDataTypeFactory typeFactory) {\n    final ExtensibleTable underlying = unwrap(ExtensibleTable.class);\n    assert underlying != null;\n    final RelDataTypeFactory.Builder builder = typeFactory.builder();\n    final RelDataType rowType = getRowType(typeFactory);\n    for (RelDataTypeField column : rowType.getFieldList()) {\n      builder.add(column);\n    }\n    for (RelDataTypeField column : extendedColumns) {\n      builder.add(column);\n    }\n    // The characteristics of the new view.\n    final RelDataType newRowType = builder.build();\n    final ImmutableIntList newColumnMapping =\n        getNewColumnMapping(underlying, getColumnMapping(), extendedColumns,\n            typeFactory);\n    // Extend the underlying table with only the fields that\n    // duplicate column names in neither the view nor the base table.\n    final List<RelDataTypeField> underlyingColumns =\n        underlying.getRowType(typeFactory).getFieldList();\n    final List<RelDataTypeField> columnsOfExtendedBaseTable =\n        RelOptUtil.deduplicateColumns(underlyingColumns, extendedColumns);\n    final List<RelDataTypeField> extendColumnsOfBaseTable =\n        columnsOfExtendedBaseTable.subList(\n            underlyingColumns.size(), columnsOfExtendedBaseTable.size());\n    final Table extendedTable = underlying.extend(extendColumnsOfBaseTable);\n    return extend(extendedTable, RelDataTypeImpl.proto(newRowType),\n        newColumnMapping);\n  }\n  /**\n   * Creates a mapping from the view index to the index in the underlying table.\n   */\n  private static ImmutableIntList getNewColumnMapping(Table underlying,\n      ImmutableIntList oldColumnMapping, List<RelDataTypeField> extendedColumns,\n      RelDataTypeFactory typeFactory) {\n    final List<RelDataTypeField> baseColumns =\n        underlying.getRowType(typeFactory).getFieldList();\n    final Map<String, Integer> nameToIndex = mapNameToIndex(baseColumns);\n    final ImmutableList.Builder<Integer> newMapping = ImmutableList.builder();\n    newMapping.addAll(oldColumnMapping);\n    int newMappedIndex = baseColumns.size();\n    for (RelDataTypeField extendedColumn : extendedColumns) {\n      if (nameToIndex.containsKey(extendedColumn.getName())) {\n        // The extended column duplicates a column in the underlying table.\n        // Map to the index in the underlying table.\n        newMapping.add(nameToIndex.get(extendedColumn.getName()));\n      } else {\n        // The extended column is not in the underlying table.\n        newMapping.add(newMappedIndex++);\n      }\n    }\n    return ImmutableIntList.copyOf(newMapping.build());\n  }\n  protected ModifiableViewTable extend(Table extendedTable,\n      RelProtoDataType protoRowType, ImmutableIntList newColumnMapping) {\n    return new ModifiableViewTable(getElementType(), protoRowType, getViewSql(),\n        getSchemaPath(), getViewPath(), extendedTable, getTablePath(),\n        constraint, newColumnMapping);\n  }\n  /**\n   * Initializes columns based on the view constraint.\n   */\n  private class ModifiableViewTableInitializerExpressionFactory\n      extends NullInitializerExpressionFactory {\n    private final ImmutableMap<Integer, RexNode> projectMap;\n    private ModifiableViewTableInitializerExpressionFactory() {\n      super();\n      final Map<Integer, RexNode> projectMap = new HashMap<>();\n      final List<RexNode> filters = new ArrayList<>();\n      RelOptUtil.inferViewPredicates(projectMap, filters, constraint);\n      assert filters.isEmpty();\n      this.projectMap = ImmutableMap.copyOf(projectMap);\n    }\n<fim_suffix>    @Override public ColumnStrategy generationStrategy(RelOptTable table,\n        int iColumn) {\n      final ModifiableViewTable viewTable =\n          table.unwrap(ModifiableViewTable.class);\n      assert iColumn < viewTable.columnMapping.size();\n      // Use the view constraint to generate the default value if the column is\n      // constrained.\n      final int mappedOrdinal = viewTable.columnMapping.get(iColumn);\n      final RexNode viewConstraint = projectMap.get(mappedOrdinal);\n      if (viewConstraint != null) {\n        return ColumnStrategy.DEFAULT;\n      }\n      // Otherwise use the default value of the underlying table.\n      final Table schemaTable = viewTable.getTable();\n      if (schemaTable instanceof Wrapper) {\n        final InitializerExpressionFactory initializerExpressionFactory =\n            ((Wrapper) schemaTable).unwrap(InitializerExpressionFactory.class);\n        if (initializerExpressionFactory != null) {\n          return initializerExpressionFactory.generationStrategy(table,\n              iColumn);\n        }\n      }\n      return super.generationStrategy(table, iColumn);\n    }<fim_middle>// function below has no smell\n"}