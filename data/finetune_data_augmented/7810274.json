{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n * agreements. See the NOTICE file distributed with this work for additional information regarding\n * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n * copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\npackage org.apache.geode.cache.client.internal;\nimport java.io.ByteArrayInputStream;\nimport java.io.DataInputStream;\nimport java.net.SocketTimeoutException;\nimport org.apache.logging.log4j.Logger;\nimport org.apache.geode.InternalGemFireError;\nimport org.apache.geode.cache.client.ServerConnectivityException;\nimport org.apache.geode.cache.client.ServerOperationException;\nimport org.apache.geode.internal.HeapDataOutputStream;\nimport org.apache.geode.internal.Version;\nimport org.apache.geode.internal.cache.PutAllPartialResultException;\nimport org.apache.geode.internal.cache.TXManagerImpl;\nimport org.apache.geode.internal.cache.tier.MessageType;\nimport org.apache.geode.internal.cache.tier.sockets.ChunkedMessage;\nimport org.apache.geode.internal.cache.tier.sockets.Message;\nimport org.apache.geode.internal.cache.tier.sockets.Part;\nimport org.apache.geode.internal.cache.tier.sockets.ServerConnection;\nimport org.apache.geode.internal.logging.LogService;\nimport org.apache.geode.internal.logging.log4j.LogMarker;\n/**\n * Represents an operation that can be performed in a client by sending a message to a server.\n *\n * @since GemFire 5.7\n */\npublic abstract class AbstractOp implements Op {\n  private static final Logger logger = LogService.getLogger();\n  private final Message msg;\n  private boolean allowDuplicateMetadataRefresh;\n  protected AbstractOp(int msgType, int msgParts) {\n    this.msg = new Message(msgParts, Version.CURRENT);\n    getMessage().setMessageType(msgType);\n  }\n  /**\n   * Returns the message that this op will send to the server\n   */\n  protected Message getMessage() {\n    return this.msg;\n  }\n  protected void initMessagePart() {\n  }\n  /**\n   * Sets the transaction id on the message\n   */\n  private void setMsgTransactionId() {\n    if (participateInTransaction() && getMessage().getTransactionId() == TXManagerImpl.NOTX) {\n      getMessage().setTransactionId(TXManagerImpl.getCurrentTXUniqueId());\n    }\n  }\n  /**\n   * Attempts to send this operation's message out on the given connection\n   *\n   * @param cnx the connection to use when sending\n   * @throws Exception if the send fails\n   */\n  protected void attemptSend(Connection cnx) throws Exception {\n    setMsgTransactionId();\n    if (logger.isTraceEnabled(LogMarker.DISTRIBUTION_BRIDGE_SERVER_VERBOSE)) {\n      logger.trace(LogMarker.DISTRIBUTION_BRIDGE_SERVER_VERBOSE, \"Sending op={} using {}\",\n          getShortClassName(), cnx);\n    }\n    getMessage().setComms(cnx.getSocket(), cnx.getInputStream(), cnx.getOutputStream(),\n        cnx.getCommBuffer(), cnx.getStats());\n    try {\n      sendMessage(cnx);\n    } finally {\n      getMessage().unsetComms();\n    }\n  }\n  /** returns the class name w/o package information. useful in logging */\n  public String getShortClassName() {\n    String cname = getClass().getName();\n    return cname.substring(getClass().getPackage().getName().length() + 1);\n  }\n  /**\n   * New implementations of AbstractOp should override this method if the implementation should be\n   * excluded from client authentication. e.g. PingOp#sendMessage(Connection cnx)\n   *\n   * @see AbstractOp#needsUserId()\n   * @see AbstractOp#processSecureBytes(Connection, Message)\n   * @see ServerConnection#updateAndGetSecurityPart()\n   */\n<fim_suffix>  protected void sendMessage(Connection cnx) throws Exception {\n    if (cnx.getServer().getRequiresCredentials()) {\n      // Security is enabled on client as well as on server\n      getMessage().setMessageHasSecurePartFlag();\n      long userId = -1;\n      if (UserAttributes.userAttributes.get() == null) { // single user mode\n        userId = cnx.getServer().getUserId();\n      } else { // multi user mode\n        Object id = UserAttributes.userAttributes.get().getServerToId().get(cnx.getServer());\n        if (id == null) {\n          // This will ensure that this op is retried on another server, unless\n          // the retryCount is exhausted. Fix for Bug 41501\n          throw new ServerConnectivityException(\"Connection error while authenticating user\");\n        }\n        userId = (Long) id;\n      }\n      HeapDataOutputStream hdos = new HeapDataOutputStream(Version.CURRENT);\n      try {\n        hdos.writeLong(cnx.getConnectionID());\n        hdos.writeLong(userId);\n        getMessage().setSecurePart(((ConnectionImpl) cnx).encryptBytes(hdos.toByteArray()));\n      } finally {\n        hdos.close();\n      }\n    }\n    getMessage().send(false);\n  }\n  /**\n   * Process the security information in a response from the server. If the server sends a security\n   * \"part\" we must process it so all subclasses should allow this method to be invoked.\n   *\n   * @see ServerConnection#updateAndGetSecurityPart()\n   */\n  protected void processSecureBytes(Connection cnx, Message message) throws Exception {\n    if (cnx.getServer().getRequiresCredentials()) {\n      if (!message.isSecureMode()) {\n        // This can be seen during shutdown\n        if (logger.isTraceEnabled(LogMarker.BRIDGE_SERVER_VERBOSE)) {\n          logger.trace(LogMarker.BRIDGE_SERVER_VERBOSE,\n              \"Response message from {} for {} has no secure part.\", cnx, this);\n        }\n        return;\n      }\n      byte[] partBytes = message.getSecureBytes();\n      if (partBytes == null) {\n        if (logger.isDebugEnabled()) {\n          logger.debug(\"Response message for {} has no bytes in secure part.\", this);\n        }\n        return;\n      }\n      byte[] bytes = ((ConnectionImpl) cnx).decryptBytes(partBytes);\n      DataInputStream dis = new DataInputStream(new ByteArrayInputStream(bytes));\n      cnx.setConnectionID(dis.readLong());\n    }\n  }\n  /**\n   * New implementations of AbstractOp should override this method to return false if the\n   * implementation should be excluded from client authentication. e.g. PingOp#needsUserId()\n   * <P/>\n   * Also, such an operation's <code>MessageType</code> must be added in the 'if' condition in\n   * {@link ServerConnection#updateAndGetSecurityPart()}\n   *\n   * @see AbstractOp#sendMessage(Connection)\n   * @see ServerConnection#updateAndGetSecurityPart()\n   */\n  protected boolean needsUserId() {\n    return true;\n  }\n  /**\n   * Attempts to read a response to this operation by reading it from the given connection, and\n   * returning it.\n   *\n   * @param cnx the connection to read the response from\n   * @return the result of the operation or <code>null</code> if the operation has no result.\n   * @throws Exception if the execute failed\n   */\n  protected Object attemptReadResponse(Connection cnx) throws Exception {\n    Message msg = createResponseMessage();\n    if (msg != null) {\n      msg.setComms(cnx.getSocket(), cnx.getInputStream(), cnx.getOutputStream(),\n          cnx.getCommBuffer(), cnx.getStats());\n      if (msg instanceof ChunkedMessage) {\n        try {\n          return processResponse(msg, cnx);\n        } finally {\n          msg.unsetComms();\n          processSecureBytes(cnx, msg);\n        }\n      } else {\n        try {\n          msg.receive();\n        } finally {\n          msg.unsetComms();\n          processSecureBytes(cnx, msg);\n        }\n        return processResponse(msg, cnx);\n      }\n    } else {\n      return null;\n    }\n  }\n  /**\n   * By default just create a normal one part msg. Subclasses can override this.\n   */\n  protected Message createResponseMessage() {\n    return new Message(1, Version.CURRENT);\n  }\n  protected Object processResponse(Message m, Connection con) throws Exception {\n    return processResponse(m);\n  }\n  /**\n   * Processes the given response message returning the result, if any, of the processing.\n   *\n   * @return the result of processing the response; null if no result\n   * @throws Exception if response could not be processed or we received a response with a server<fim_middle>// function below is long method\n"}