{"text": "<fim_prefix>import org.apache.druid.query.filter.Filter;\nimport org.apache.druid.query.filter.ValueMatcher;\nimport org.apache.druid.segment.Capabilities;\nimport org.apache.druid.segment.ColumnSelectorFactory;\nimport org.apache.druid.segment.Cursor;\nimport org.apache.druid.segment.DimensionIndexer;\nimport org.apache.druid.segment.DimensionSelector;\nimport org.apache.druid.segment.Metadata;\nimport org.apache.druid.segment.StorageAdapter;\nimport org.apache.druid.segment.VirtualColumns;\nimport org.apache.druid.segment.column.ColumnCapabilities;\nimport org.apache.druid.segment.column.ColumnHolder;\nimport org.apache.druid.segment.data.Indexed;\nimport org.apache.druid.segment.data.ListIndexed;\nimport org.apache.druid.segment.filter.BooleanValueMatcher;\nimport org.joda.time.DateTime;\nimport org.joda.time.Interval;\nimport javax.annotation.Nullable;\nimport java.util.Iterator;\n/**\n */\npublic class IncrementalIndexStorageAdapter implements StorageAdapter\n{\n  private final IncrementalIndex<?> index;\n  public IncrementalIndexStorageAdapter(IncrementalIndex<?> index)\n  {\n    this.index = index;\n  }\n  @Override\n  public String getSegmentIdentifier()\n  {\n    throw new UnsupportedOperationException();\n  }\n  @Override\n  public Interval getInterval()\n  {\n    return index.getInterval();\n  }\n  @Override\n  public Indexed<String> getAvailableDimensions()\n  {\n    return new ListIndexed<>(index.getDimensionNames());\n  }\n  @Override\n  public Iterable<String> getAvailableMetrics()\n  {\n    return index.getMetricNames();\n  }\n  @Override\n  public int getDimensionCardinality(String dimension)\n  {\n    if (dimension.equals(ColumnHolder.TIME_COLUMN_NAME)) {\n      return Integer.MAX_VALUE;\n    }\n    IncrementalIndex.DimensionDesc desc = index.getDimension(dimension);\n    if (desc == null) {\n      return 0;\n    }\n    DimensionIndexer indexer = desc.getIndexer();\n    int cardinality = indexer.getCardinality();\n    return cardinality != DimensionSelector.CARDINALITY_UNKNOWN ? cardinality : Integer.MAX_VALUE;\n  }\n  @Override\n  public int getNumRows()\n  {\n    return index.size();\n  }\n  @Override\n  public DateTime getMinTime()\n  {\n    return index.getMinTime();\n  }\n  @Override\n  public DateTime getMaxTime()\n  {\n    return index.getMaxTime();\n  }\n  @Nullable\n  @Override\n  public Comparable getMinValue(String column)\n  {\n    IncrementalIndex.DimensionDesc desc = index.getDimension(column);\n    if (desc == null) {\n      return null;\n    }\n    DimensionIndexer indexer = desc.getIndexer();\n    return indexer.getMinValue();\n  }\n  @Nullable\n  @Override\n  public Comparable getMaxValue(String column)\n  {\n    IncrementalIndex.DimensionDesc desc = index.getDimension(column);\n    if (desc == null) {\n      return null;\n    }\n    DimensionIndexer indexer = desc.getIndexer();\n    return indexer.getMaxValue();\n  }\n  @Override\n  public Capabilities getCapabilities()\n  {\n    return Capabilities.builder().dimensionValuesSorted(false).build();\n  }\n  @Override\n  public ColumnCapabilities getColumnCapabilities(String column)\n  {\n    return index.getCapabilities(column);\n  }\n  @Override\n  public String getColumnTypeName(String column)\n  {\n    final String metricType = index.getMetricType(column);\n    if (metricType != null) {\n      return metricType;\n    }\n    ColumnCapabilities columnCapabilities = getColumnCapabilities(column);\n    if (columnCapabilities != null) {\n      return columnCapabilities.getType().toString();\n    } else {\n      return null;\n    }\n  }\n  @Override\n  public DateTime getMaxIngestedEventTime()\n  {\n    return index.getMaxIngestedEventTime();\n  }\n  @Override\n  public Sequence<Cursor> makeCursors(\n      @Nullable final Filter filter,\n      final Interval interval,\n      final VirtualColumns virtualColumns,\n      final Granularity gran,\n      final boolean descending,\n      @Nullable QueryMetrics<?> queryMetrics\n  )\n  {\n    if (index.isEmpty()) {\n      return Sequences.empty();\n    }\n    final Interval dataInterval = new Interval(getMinTime(), gran.bucketEnd(getMaxTime()));\n    if (!interval.overlaps(dataInterval)) {\n      return Sequences.empty();\n    }\n    final Interval actualInterval = interval.overlap(dataInterval);\n    Iterable<Interval> intervals = gran.getIterable(actualInterval);\n    if (descending) {\n      intervals = Lists.reverse(ImmutableList.copyOf(intervals));\n    }\n    return Sequences\n        .simple(intervals)\n        .map(i -> new IncrementalIndexCursor(virtualColumns, descending, filter, i, actualInterval, gran));\n  }\n  @Override\n  public Metadata getMetadata()\n  {\n    return index.getMetadata();\n  }\n<fim_suffix>  private class IncrementalIndexCursor implements Cursor\n  {\n    private IncrementalIndexRowHolder currEntry;\n    private final ColumnSelectorFactory columnSelectorFactory;\n    private final ValueMatcher filterMatcher;\n    private final int maxRowIndex;\n    private Iterator<IncrementalIndexRow> baseIter;\n    private Iterable<IncrementalIndexRow> cursorIterable;\n    private boolean emptyRange;\n    private final DateTime time;\n    private int numAdvanced;\n    private boolean done;\n    IncrementalIndexCursor(\n        VirtualColumns virtualColumns,\n        boolean descending,\n        Filter filter,\n        Interval interval,\n        Interval actualInterval,\n        Granularity gran\n    )\n    {\n      currEntry = new IncrementalIndexRowHolder();\n      columnSelectorFactory = new IncrementalIndexColumnSelectorFactory(index, virtualColumns, descending, currEntry);\n      // Set maxRowIndex before creating the filterMatcher. See https://github.com/apache/incubator-druid/pull/6340\n      maxRowIndex = index.getLastRowIndex();\n      filterMatcher = filter == null ? BooleanValueMatcher.of(true) : filter.makeMatcher(columnSelectorFactory);\n      numAdvanced = -1;\n      final long timeStart = Math.max(interval.getStartMillis(), actualInterval.getStartMillis());\n      cursorIterable = index.getFacts().timeRangeIterable(\n          descending,\n          timeStart,\n          Math.min(actualInterval.getEndMillis(), gran.increment(interval.getStart()).getMillis())\n      );\n      emptyRange = !cursorIterable.iterator().hasNext();\n      time = gran.toDateTime(interval.getStartMillis());\n      reset();\n    }\n    @Override\n    public ColumnSelectorFactory getColumnSelectorFactory()\n    {\n      return columnSelectorFactory;\n    }\n    @Override\n    public DateTime getTime()\n    {\n      return time;\n    }\n    @Override\n    public void advance()\n    {\n      if (!baseIter.hasNext()) {\n        done = true;\n        return;\n      }\n      while (baseIter.hasNext()) {\n        BaseQuery.checkInterrupted();\n        IncrementalIndexRow entry = baseIter.next();\n        if (beyondMaxRowIndex(entry.getRowIndex())) {\n          continue;\n        }\n        currEntry.set(entry);\n        if (filterMatcher.matches()) {\n          return;\n        }\n      }\n      done = true;\n    }\n    @Override\n    public void advanceUninterruptibly()\n    {\n      if (!baseIter.hasNext()) {\n        done = true;\n        return;\n      }\n      while (baseIter.hasNext()) {\n        if (Thread.currentThread().isInterrupted()) {\n          return;\n        }\n        IncrementalIndexRow entry = baseIter.next();\n        if (beyondMaxRowIndex(entry.getRowIndex())) {\n          continue;\n        }\n        currEntry.set(entry);\n        if (filterMatcher.matches()) {\n          return;\n        }\n      }\n      done = true;\n    }\n    @Override\n    public void advanceTo(int offset)\n    {\n      int count = 0;\n      while (count < offset && !isDone()) {\n        advance();\n        count++;\n      }\n    }\n    @Override\n    public boolean isDone()\n    {\n      return done;\n    }\n    @Override\n    public boolean isDoneOrInterrupted()\n    {\n      return isDone() || Thread.currentThread().isInterrupted();\n    }\n    @Override\n    public void reset()\n    {\n      baseIter = cursorIterable.iterator();\n      if (numAdvanced == -1) {\n        numAdvanced = 0;\n      } else {\n        Iterators.advance(baseIter, numAdvanced);\n      }\n      BaseQuery.checkInterrupted();\n      boolean foundMatched = false;\n      while (baseIter.hasNext()) {\n        IncrementalIndexRow entry = baseIter.next();\n        if (beyondMaxRowIndex(entry.getRowIndex())) {\n          numAdvanced++;\n          continue;\n        }\n        currEntry.set(entry);\n        if (filterMatcher.matches()) {\n          foundMatched = true;\n          break;\n        }\n        numAdvanced++;\n      }\n      done = !foundMatched && (emptyRange || !baseIter.hasNext());\n    }\n    private boolean beyondMaxRowIndex(int rowIndex)\n    {\n      // ignore rows whose rowIndex is beyond the maxRowIndex\n      // rows are order by timestamp, not rowIndex,\n      // so we still need to go through all rows to skip rows added after cursor created\n      return rowIndex > maxRowIndex;\n    }\n  }<fim_middle>// class below has no smell\n"}