{"text": "<fim_prefix>        int i = Collections.binarySearch(withNameList, refWithName,\n            WITHNAME_COMPARATOR);\n        Preconditions.checkState(i < 0);\n        withNameList.add(-i - 1, refWithName);\n      } else if (ref instanceof DstReference) {\n        setParentReference(ref);\n      }\n    }\n    /** Decrement and then return the reference count. */\n    public void removeReference(INodeReference ref) {\n      if (ref instanceof WithName) {\n        int i = Collections.binarySearch(withNameList, (WithName) ref,\n            WITHNAME_COMPARATOR);\n        if (i >= 0) {\n          withNameList.remove(i);\n        }\n      } else if (ref == getParentReference()) {\n        setParent(null);\n      }\n    }\n    /** Return the last WithName reference if there is any, null otherwise. */\n    public WithName getLastWithName() {\n      return withNameList.size() > 0 ? \n          withNameList.get(withNameList.size() - 1) : null;\n    }\n    WithName getPriorWithName(WithName post) {\n      int i = Collections.binarySearch(withNameList, post, WITHNAME_COMPARATOR);\n      if (i > 0) {\n        return withNameList.get(i - 1);\n      } else if (i == 0 || i == -1) {\n        return null;\n      } else {\n        return withNameList.get(-i - 2);\n      }\n    }\n    /**\n     * @return the WithName/DstReference node contained in the given snapshot.\n     */\n    public INodeReference getParentRef(int snapshotId) {\n      int start = 0;\n      int end = withNameList.size() - 1;\n      while (start < end) {\n        int mid = start + (end - start) / 2;\n        int sid = withNameList.get(mid).lastSnapshotId; \n        if (sid == snapshotId) {\n          return withNameList.get(mid);\n        } else if (sid < snapshotId) {\n          start = mid + 1;\n        } else {\n          end = mid;\n        }\n      }\n      if (start < withNameList.size() &&\n          withNameList.get(start).lastSnapshotId >= snapshotId) {\n        return withNameList.get(start);\n      } else {\n        return this.getParentReference();\n      }\n    }\n  }\n  /** A reference with a fixed name. */\n<fim_suffix>  public static class WithName extends INodeReference {\n    private final byte[] name;\n    /**\n     * The id of the last snapshot in the src tree when this WithName node was \n     * generated. When calculating the quota usage of the referred node, only \n     * the files/dirs existing when this snapshot was taken will be counted for \n     * this WithName node and propagated along its ancestor path.\n     */\n    private final int lastSnapshotId;\n    public WithName(INodeDirectory parent, WithCount referred, byte[] name,\n        int lastSnapshotId) {\n      super(parent, referred);\n      this.name = name;\n      this.lastSnapshotId = lastSnapshotId;\n      referred.addReference(this);\n    }\n    @Override\n    public final byte[] getLocalNameBytes() {\n      return name;\n    }\n    @Override\n    public final void setLocalName(byte[] name) {\n      throw new UnsupportedOperationException(\"Cannot set name: \" + getClass()\n          + \" is immutable.\");\n    }\n    public int getLastSnapshotId() {\n      return lastSnapshotId;\n    }\n    @Override\n    public final ContentSummaryComputationContext computeContentSummary(\n        int snapshotId, ContentSummaryComputationContext summary) {\n      final int s = snapshotId < lastSnapshotId ? snapshotId : lastSnapshotId;\n      // only count storagespace for WithName\n      final QuotaCounts q = computeQuotaUsage(\n          summary.getBlockStoragePolicySuite(), getStoragePolicyID(), false, s);\n      summary.getCounts().addContent(Content.DISKSPACE, q.getStorageSpace());\n      summary.getCounts().addTypeSpaces(q.getTypeSpaces());\n      return summary;\n    }\n    @Override\n    public final QuotaCounts computeQuotaUsage(BlockStoragePolicySuite bsps,\n        byte blockStoragePolicyId, boolean useCache, int lastSnapshotId) {\n      // if this.lastSnapshotId < lastSnapshotId, the rename of the referred\n      // node happened before the rename of its ancestor. This should be\n      // impossible since for WithName node we only count its children at the\n      // time of the rename.\n      Preconditions.checkState(lastSnapshotId == Snapshot.CURRENT_STATE_ID\n          || this.lastSnapshotId >= lastSnapshotId);\n      final INode referred = this.getReferredINode().asReference()\n          .getReferredINode();\n      // We will continue the quota usage computation using the same snapshot id\n      // as time line (if the given snapshot id is valid). Also, we cannot use \n      // cache for the referred node since its cached quota may have already \n      // been updated by changes in the current tree.\n      int id = lastSnapshotId != Snapshot.CURRENT_STATE_ID ? \n          lastSnapshotId : this.lastSnapshotId;\n      return referred.computeQuotaUsage(bsps, blockStoragePolicyId, false, id);\n    }\n    @Override\n    public void cleanSubtree(ReclaimContext reclaimContext, final int snapshot,\n        int prior) {\n      // since WithName node resides in deleted list acting as a snapshot copy,\n      // the parameter snapshot must be non-null\n      Preconditions.checkArgument(snapshot != Snapshot.CURRENT_STATE_ID);\n      // if prior is NO_SNAPSHOT_ID, we need to check snapshot belonging to the\n      // previous WithName instance\n      if (prior == Snapshot.NO_SNAPSHOT_ID) {\n        prior = getPriorSnapshot(this);\n      }\n      if (prior != Snapshot.NO_SNAPSHOT_ID\n          && Snapshot.ID_INTEGER_COMPARATOR.compare(snapshot, prior) <= 0) {\n        return;\n      }\n      // record the old quota delta\n      QuotaCounts old = reclaimContext.quotaDelta().getCountsCopy();\n      getReferredINode().cleanSubtree(reclaimContext, snapshot, prior);\n      INodeReference ref = getReferredINode().getParentReference();\n      if (ref != null) {\n        QuotaCounts current = reclaimContext.quotaDelta().getCountsCopy();\n        current.subtract(old);\n        // we need to update the quota usage along the parent path from ref\n        reclaimContext.quotaDelta().addUpdatePath(ref, current);\n      }\n      if (snapshot < lastSnapshotId) {\n        // for a WithName node, when we compute its quota usage, we only count\n        // in all the nodes existing at the time of the corresponding rename op.\n        // Thus if we are deleting a snapshot before/at the snapshot associated \n        // with lastSnapshotId, we do not need to update the quota upwards.\n        reclaimContext.quotaDelta().setCounts(old);\n      }\n    }\n    @Override\n    public void destroyAndCollectBlocks(ReclaimContext reclaimContext) {\n      int snapshot = getSelfSnapshot();\n      reclaimContext.quotaDelta().add(computeQuotaUsage(reclaimContext.bsps));\n      if (removeReference(this) <= 0) {\n        getReferredINode().destroyAndCollectBlocks(reclaimContext.getCopy());\n      } else {\n        int prior = getPriorSnapshot(this);\n        INode referred = getReferredINode().asReference().getReferredINode();\n        if (snapshot != Snapshot.NO_SNAPSHOT_ID) {\n          if (prior != Snapshot.NO_SNAPSHOT_ID && snapshot <= prior) {\n            // the snapshot to be deleted has been deleted while traversing \n            // the src tree of the previous rename operation. This usually \n            // happens when rename's src and dst are under the same \n            // snapshottable directory. E.g., the following operation sequence:\n            // 1. create snapshot s1 on /test\n            // 2. rename /test/foo/bar to /test/foo2/bar\n            // 3. create snapshot s2 on /test\n            // 4. rename foo2 again\n            // 5. delete snapshot s2\n            return;\n          }\n          ReclaimContext newCtx = reclaimContext.getCopy();\n          referred.cleanSubtree(newCtx, snapshot, prior);\n          INodeReference ref = getReferredINode().getParentReference();\n          if (ref != null) {\n            // we need to update the quota usage along the parent path from ref\n            reclaimContext.quotaDelta().addUpdatePath(ref,\n                newCtx.quotaDelta().getCountsCopy());\n          }\n        }\n      }\n    }\n    private int getSelfSnapshot() {\n      INode referred = getReferredINode().asReference().getReferredINode();\n      int snapshot = Snapshot.NO_SNAPSHOT_ID;\n      if (referred.isFile() && referred.asFile().isWithSnapshot()) {\n        snapshot = referred.asFile().getDiffs().getPrior(lastSnapshotId);\n      } else if (referred.isDirectory()) {\n        DirectoryWithSnapshotFeature sf = referred.asDirectory()\n            .getDirectoryWithSnapshotFeature();\n        if (sf != null) {\n          snapshot = sf.getDiffs().getPrior(lastSnapshotId);\n        }\n      }\n      return snapshot;\n    }\n  }<fim_middle>// class below has no smell\n"}