{"text": "<fim_prefix>     * the specified collection is modified while the operation is in\n     * progress.  (Note that this will occur if the specified collection is\n     * this list, and it's nonempty.)\n     *\n     * @param c collection containing elements to be added to this list\n     * @return {@code true} if this list changed as a result of the call\n     * @throws NullPointerException if the specified collection is null\n     */\n    public boolean addAll(Collection<? extends E> c) {\n        return addAll(size, c);\n    }\n    /**\n     * Inserts all of the elements in the specified collection into this\n     * list, starting at the specified position.  Shifts the element\n     * currently at that position (if any) and any subsequent elements to\n     * the right (increases their indices).  The new elements will appear\n     * in the list in the order that they are returned by the\n     * specified collection's iterator.\n     *\n     * @param index index at which to insert the first element\n     *              from the specified collection\n     * @param c collection containing elements to be added to this list\n     * @return {@code true} if this list changed as a result of the call\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     * @throws NullPointerException if the specified collection is null\n     */\n    public boolean addAll(int index, Collection<? extends E> c) {\n        checkPositionIndex(index);\n        Object[] a = c.toArray();\n        int numNew = a.length;\n        if (numNew == 0)\n            return false;\n        Node<E> pred, succ;\n        if (index == size) {\n            succ = null;\n            pred = last;\n        } else {\n            succ = node(index);\n            pred = succ.prev;\n        }\n        for (Object o : a) {\n            @SuppressWarnings(\"unchecked\") E e = (E) o;\n            Node<E> newNode = new Node<>(pred, e, null);\n            if (pred == null)\n                first = newNode;\n            else\n                pred.next = newNode;\n            pred = newNode;\n        }\n        if (succ == null) {\n            last = pred;\n        } else {\n            pred.next = succ;\n            succ.prev = pred;\n        }\n        size += numNew;\n        modCount++;\n        return true;\n    }\n    /**\n     * Removes all of the elements from this list.\n     * The list will be empty after this call returns.\n     */\n    public void clear() {\n        // Clearing all of the links between nodes is \"unnecessary\", but:\n        // - helps a generational GC if the discarded nodes inhabit\n        //   more than one generation\n        // - is sure to free memory even if there is a reachable Iterator\n        for (Node<E> x = first; x != null; ) {\n            Node<E> next = x.next;\n            x.item = null;\n            x.next = null;\n            x.prev = null;\n            x = next;\n        }\n        first = last = null;\n        size = 0;\n        modCount++;\n    }\n    // Positional Access Operations\n    /**\n     * Returns the element at the specified position in this list.\n     *\n     * @param index index of the element to return\n     * @return the element at the specified position in this list\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */\n    public E get(int index) {\n        checkElementIndex(index);\n        return node(index).item;\n    }\n    /**\n     * Replaces the element at the specified position in this list with the\n     * specified element.\n     *\n     * @param index index of the element to replace\n     * @param element element to be stored at the specified position\n     * @return the element previously at the specified position\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */\n    public E set(int index, E element) {\n        checkElementIndex(index);\n        Node<E> x = node(index);\n        E oldVal = x.item;\n        x.item = element;\n        return oldVal;\n    }\n    /**\n     * Inserts the specified element at the specified position in this list.\n     * Shifts the element currently at that position (if any) and any\n     * subsequent elements to the right (adds one to their indices).\n     *\n     * @param index index at which the specified element is to be inserted\n     * @param element element to be inserted\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */\n    public void add(int index, E element) {\n        checkPositionIndex(index);\n        if (index == size)\n            linkLast(element);\n        else\n            linkBefore(element, node(index));\n    }\n    /**\n     * Removes the element at the specified position in this list.  Shifts any\n     * subsequent elements to the left (subtracts one from their indices).\n     * Returns the element that was removed from the list.\n     *\n     * @param index the index of the element to be removed\n     * @return the element previously at the specified position\n     * @throws IndexOutOfBoundsException {@inheritDoc}\n     */\n    public E remove(int index) {\n        checkElementIndex(index);\n        return unlink(node(index));\n    }\n    /**\n     * Tells if the argument is the index of an existing element.\n     */\n    private boolean isElementIndex(int index) {\n        return index >= 0 && index < size;\n    }\n    /**\n     * Tells if the argument is the index of a valid position for an\n     * iterator or an add operation.\n     */\n    private boolean isPositionIndex(int index) {\n        return index >= 0 && index <= size;\n    }\n    /**\n     * Constructs an IndexOutOfBoundsException detail message.\n     * Of the many possible refactorings of the error handling code,\n     * this \"outlining\" performs best with both server and client VMs.\n     */\n    private String outOfBoundsMsg(int index) {\n        return \"Index: \"+index+\", Size: \"+size;\n    }\n    private void checkElementIndex(int index) {\n        if (!isElementIndex(index))\n            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n    }\n    private void checkPositionIndex(int index) {\n        if (!isPositionIndex(index))\n            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));\n    }\n    /**\n     * Returns the (non-null) Node at the specified element index.\n     */\n    Node<E> node(int index) {\n        // assert isElementIndex(index);\n        if (index < (size >> 1)) {\n            Node<E> x = first;\n            for (int i = 0; i < index; i++)\n                x = x.next;\n            return x;\n        } else {\n            Node<E> x = last;\n            for (int i = size - 1; i > index; i--)\n                x = x.prev;\n            return x;\n        }\n    }\n    // Search Operations\n    /**\n     * Returns the index of the first occurrence of the specified element\n     * in this list, or -1 if this list does not contain the element.\n     * More formally, returns the lowest index {@code i} such that\n     * {@code Objects.equals(o, get(i))},\n     * or -1 if there is no such index.\n     *\n     * @param o element to search for\n     * @return the index of the first occurrence of the specified element in\n     *         this list, or -1 if this list does not contain the element\n     */\n    public int indexOf(Object o) {\n        int index = 0;\n        if (o == null) {\n            for (Node<E> x = first; x != null; x = x.next) {\n                if (x.item == null)\n                    return index;\n                index++;\n            }\n        } else {\n            for (Node<E> x = first; x != null; x = x.next) {\n                if (o.equals(x.item))\n                    return index;\n                index++;\n            }\n        }\n        return -1;\n    }\n    /**\n     * Returns the index of the last occurrence of the specified element\n     * in this list, or -1 if this list does not contain the element.\n     * More formally, returns the highest index {@code i} such that\n     * {@code Objects.equals(o, get(i))},\n     * or -1 if there is no such index.\n     *\n     * @param o element to search for\n     * @return the index of the last occurrence of the specified element in\n     *         this list, or -1 if this list does not contain the element\n     */\n<fim_suffix>    public int lastIndexOf(Object o) {\n        int index = size;\n        if (o == null) {\n            for (Node<E> x = last; x != null; x = x.prev) {\n                index--;\n                if (x.item == null)\n                    return index;\n            }\n        } else {\n            for (Node<E> x = last; x != null; x = x.prev) {\n                index--;\n                if (o.equals(x.item))\n                    return index;\n            }\n        }\n        return -1;\n    }<fim_middle>// function below has no smell\n"}