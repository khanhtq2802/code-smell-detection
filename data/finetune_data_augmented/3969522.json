{"text": "<fim_prefix>/**\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.aurora.benchmark;\n\nimport java.util.Set;\nimport java.util.concurrent.TimeUnit;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\nimport com.google.common.collect.Iterables;\nimport com.google.inject.AbstractModule;\nimport com.google.inject.Guice;\nimport com.google.inject.Injector;\n\nimport org.apache.aurora.benchmark.fakes.FakeDriver;\nimport org.apache.aurora.benchmark.fakes.FakeEventSink;\nimport org.apache.aurora.benchmark.fakes.FakeRescheduleCalculator;\nimport org.apache.aurora.common.stats.StatsProvider;\nimport org.apache.aurora.common.util.Clock;\nimport org.apache.aurora.gen.ScheduleStatus;\nimport org.apache.aurora.scheduler.TaskIdGenerator;\nimport org.apache.aurora.scheduler.async.AsyncModule;\nimport org.apache.aurora.scheduler.events.EventSink;\nimport org.apache.aurora.scheduler.mesos.Driver;\nimport org.apache.aurora.scheduler.scheduling.RescheduleCalculator;\nimport org.apache.aurora.scheduler.state.StateManager;\nimport org.apache.aurora.scheduler.state.StateManagerImpl;\nimport org.apache.aurora.scheduler.storage.Storage;\nimport org.apache.aurora.scheduler.storage.TaskStore;\nimport org.apache.aurora.scheduler.storage.entities.IScheduledTask;\nimport org.apache.aurora.scheduler.storage.entities.ITaskConfig;\nimport org.apache.aurora.scheduler.storage.mem.MemStorageModule;\nimport org.apache.aurora.scheduler.testing.FakeStatsProvider;\nimport org.openjdk.jmh.annotations.Benchmark;\nimport org.openjdk.jmh.annotations.BenchmarkMode;\nimport org.openjdk.jmh.annotations.Fork;\nimport org.openjdk.jmh.annotations.Level;\nimport org.openjdk.jmh.annotations.Measurement;\nimport org.openjdk.jmh.annotations.Mode;\nimport org.openjdk.jmh.annotations.OutputTimeUnit;\nimport org.openjdk.jmh.annotations.Param;\nimport org.openjdk.jmh.annotations.Scope;\nimport org.openjdk.jmh.annotations.Setup;\nimport org.openjdk.jmh.annotations.State;\nimport org.openjdk.jmh.annotations.TearDown;\nimport org.openjdk.jmh.annotations.Warmup;\n\npublic class StateManagerBenchmarks {\n\n  @BenchmarkMode(Mode.Throughput)\n  @OutputTimeUnit(TimeUnit.SECONDS)\n  @Warmup(iterations = 5, time = 10, timeUnit = TimeUnit.SECONDS)\n  @Measurement(iterations = 10, time = 30, timeUnit = TimeUnit.SECONDS)\n  @Fork(1)\n  @State(Scope.Thread)\n  public static class InsertPendingTasksBenchmark {\n    private StateManager manager;\n    private Storage storage;\n\n    @Param({\"1000\", \"10000\", \"50000\"})\n    private int numPendingTasks;\n\n    // Used to prevent job key collisions\n    private int numIterations = 0;\n\n    @Setup\n    public void setUp() {\n      Injector injector = getInjector();\n      manager = injector.getInstance(StateManager.class);\n      storage = injector.getInstance(Storage.class);\n      storage.prepare();\n    }\n\n    @TearDown\n    public void tearDown() {\n      storage.write(new Storage.MutateWork.NoResult.Quiet() {\n        @Override\n        public void execute(Storage.MutableStoreProvider storeProvider) throws RuntimeException {\n          storeProvider.getUnsafeTaskStore().deleteAllTasks();\n        }\n      });\n    }\n\n    @Benchmark\n    public Set<Integer> run() {\n      IScheduledTask task =\n          Iterables.getOnlyElement(new Tasks.Builder().setJob(\"iter_\" + numIterations).build(1));\n      ITaskConfig config = task.getAssignedTask().getTask();\n      Set<Integer> taskIds =\n          IntStream.range(0, numPendingTasks).boxed().collect(Collectors.toSet());\n\n      numIterations++;\n\n      return storage.write((Storage.MutateWork.Quiet<Set<Integer>>) storeProvider -> {\n        manager.insertPendingTasks(\n            storeProvider,\n            config,\n            taskIds\n        );\n\n        return taskIds;\n      });\n    }\n  }\n\n<fim_suffix>  @BenchmarkMode(Mode.Throughput)\n  @OutputTimeUnit(TimeUnit.SECONDS)\n  @Warmup(iterations = 5, time = 10, timeUnit = TimeUnit.SECONDS)\n  @Measurement(iterations = 10, time = 30, timeUnit = TimeUnit.SECONDS)\n  @Fork(1)\n  @State(Scope.Thread)\n  public static class DeleteTasksBenchmark {\n    private StateManager manager;\n    private Storage storage;\n    private Set<String> taskIds;\n\n    @Param({\"1000\", \"10000\", \"50000\"})\n    private int numTasksToDelete;\n\n    @Setup(Level.Trial)\n    public void setUpStorage() {\n      Injector injector = getInjector();\n      manager = injector.getInstance(StateManager.class);\n      storage = injector.getInstance(Storage.class);\n      storage.prepare();\n    }\n\n    // JMH warns heavily against using `Invocation` but this test seems to meet the requirements\n    // of using it. Each benchmark will take more than one ms and it avoids awkward logic to\n    // setup storage before the benchmark.\n    @Setup(Level.Invocation)\n    public void setUp() {\n      storage.write(new Storage.MutateWork.NoResult.Quiet() {\n        @Override\n        public void execute(Storage.MutableStoreProvider storeProvider) throws RuntimeException {\n          taskIds = bulkInsertTasks(numTasksToDelete, storeProvider.getUnsafeTaskStore());\n        }\n      });\n    }\n\n    @Benchmark\n    public Set<String> run() {\n      return storage.write((Storage.MutateWork.Quiet<Set<String>>) storeProvider -> {\n        manager.deleteTasks(storeProvider, taskIds);\n        return taskIds;\n      });\n    }\n  }\n\n  private static Set<String> bulkInsertTasks(int num, TaskStore.Mutable store) {\n    Set<IScheduledTask> tasks =\n        new Tasks.Builder().setScheduleStatus(ScheduleStatus.FINISHED).build(num);\n    store.saveTasks(tasks);\n\n    return tasks.stream().map(t -> t.getAssignedTask().getTaskId()).collect(Collectors.toSet());\n  }\n\n  private static Injector getInjector() {\n    return Guice.createInjector(\n        new AbstractModule() {\n          @Override\n          protected void configure() {\n            bind(Clock.class).toInstance(Clock.SYSTEM_CLOCK);\n            bind(Driver.class).toInstance(new FakeDriver());\n            bind(EventSink.class).toInstance(new FakeEventSink());\n            // We want to measure the throughput of the state manager so we fake out the\n            // rescheduling calculator.\n            bind(RescheduleCalculator.class).toInstance(new FakeRescheduleCalculator());\n            bind(TaskIdGenerator.class).to(TaskIdGenerator.TaskIdGeneratorImpl.class);\n            // This is what we want to benchmark\n            bind(StateManager.class).to(StateManagerImpl.class);\n            // This is needed for storage\n            bind(StatsProvider.class).toInstance(new FakeStatsProvider());\n          }\n        },\n        new MemStorageModule(),\n        // This is needed for storage\n        new AsyncModule(new AsyncModule.Options())\n    );\n  }\n}<fim_middle>// class below is blob\n"}