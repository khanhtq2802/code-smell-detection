{"text": "<fim_prefix>\n<fim_suffix>public class DruidDataSource extends DruidAbstractDataSource implements DruidDataSourceMBean, ManagedDataSource, Referenceable, Closeable, Cloneable, ConnectionPoolDataSource, MBeanRegistration {\n    private final static Log                 LOG                       = LogFactory.getLog(DruidDataSource.class);\n    private static final long                serialVersionUID          = 1L;\n    // stats\n    private volatile long                    recycleErrorCount         = 0L;\n    private long                             connectCount              = 0L;\n    private long                             closeCount                = 0L;\n    private volatile long                    connectErrorCount         = 0L;\n    private long                             recycleCount              = 0L;\n    private long                             removeAbandonedCount      = 0L;\n    private long                             notEmptyWaitCount         = 0L;\n    private long                             notEmptySignalCount       = 0L;\n    private long                             notEmptyWaitNanos         = 0L;\n    private int                              keepAliveCheckCount       = 0;\n    private int                              activePeak                = 0;\n    private long                             activePeakTime            = 0;\n    private int                              poolingPeak               = 0;\n    private long                             poolingPeakTime           = 0;\n    // store\n    private volatile DruidConnectionHolder[] connections;\n    private int                              poolingCount              = 0;\n    private int                              activeCount               = 0;\n    private volatile long                    discardCount              = 0;\n    private int                              notEmptyWaitThreadCount   = 0;\n    private int                              notEmptyWaitThreadPeak    = 0;\n    //\n    private DruidConnectionHolder[]          evictConnections;\n    private DruidConnectionHolder[]          keepAliveConnections;\n    // threads\n    private volatile ScheduledFuture<?>      destroySchedulerFuture;\n    private DestroyTask                      destroyTask;\n    private volatile Future<?>               createSchedulerFuture;\n    private CreateConnectionThread           createConnectionThread;\n    private DestroyConnectionThread          destroyConnectionThread;\n    private LogStatsThread                   logStatsThread;\n    private int                              createTaskCount;\n    private final CountDownLatch             initedLatch               = new CountDownLatch(2);\n    private volatile boolean                 enable                    = true;\n    private boolean                          resetStatEnable           = true;\n    private volatile long                    resetCount                = 0L;\n    private String                           initStackTrace;\n    private volatile boolean                 closing                   = false;\n    private volatile boolean                 closed                    = false;\n    private long                             closeTimeMillis           = -1L;\n    protected JdbcDataSourceStat             dataSourceStat;\n    private boolean                          useGlobalDataSourceStat   = false;\n    private boolean                          mbeanRegistered           = false;\n    public static ThreadLocal<Long>          waitNanosLocal            = new ThreadLocal<Long>();\n    private boolean                          logDifferentThread        = true;\n    private volatile boolean                 keepAlive                 = false;\n    private boolean                          asyncInit                 = false;\n    protected boolean                        killWhenSocketReadTimeout = false;\n    private static List<Filter>              autoFilters               = null;\n    private boolean                          loadSpifilterSkip         = false;\n    protected static final AtomicLongFieldUpdater<DruidDataSource> recycleErrorCountUpdater\n            = AtomicLongFieldUpdater.newUpdater(DruidDataSource.class, \"recycleErrorCount\");\n    protected static final AtomicLongFieldUpdater<DruidDataSource> connectErrorCountUpdater\n            = AtomicLongFieldUpdater.newUpdater(DruidDataSource.class, \"connectErrorCount\");\n    protected static final AtomicLongFieldUpdater<DruidDataSource> resetCountUpdater\n            = AtomicLongFieldUpdater.newUpdater(DruidDataSource.class, \"resetCount\");\n    public DruidDataSource(){\n        this(false);\n    }\n    public DruidDataSource(boolean fairLock){\n        super(fairLock);\n        configFromPropety(System.getProperties());\n    }\n    public boolean isAsyncInit() {\n        return asyncInit;\n    }\n    public void setAsyncInit(boolean asyncInit) {\n        this.asyncInit = asyncInit;\n    }\n    public void configFromPropety(Properties properties) {\n        {\n            String property = properties.getProperty(\"druid.name\");\n            if (property != null) {\n                this.setName(property);\n            }\n        }\n        {\n            String property = properties.getProperty(\"druid.url\");\n            if (property != null) {\n                this.setUrl(property);\n            }\n        }\n        {\n            String property = properties.getProperty(\"druid.username\");\n            if (property != null) {\n                this.setUsername(property);\n            }\n        }\n        {\n            String property = properties.getProperty(\"druid.password\");\n            if (property != null) {\n                this.setPassword(property);\n            }\n        }\n        {\n            Boolean value = getBoolean(properties, \"druid.testWhileIdle\");\n            if (value != null) {\n                this.testWhileIdle = value;\n            }\n        }\n        {\n            Boolean value = getBoolean(properties, \"druid.testOnBorrow\");\n            if (value != null) {\n                this.testOnBorrow = value;\n            }\n        }\n        {\n            String property = properties.getProperty(\"druid.validationQuery\");\n            if (property != null && property.length() > 0) {\n                this.setValidationQuery(property);\n            }\n        }\n        {\n            Boolean value = getBoolean(properties, \"druid.useGlobalDataSourceStat\");\n            if (value != null) {\n                this.setUseGlobalDataSourceStat(value);\n            }\n        }\n        {\n            Boolean value = getBoolean(properties, \"druid.useGloalDataSourceStat\"); // compatible for early versions\n            if (value != null) {\n                this.setUseGlobalDataSourceStat(value);\n            }\n        }\n        {\n            Boolean value = getBoolean(properties, \"druid.asyncInit\"); // compatible for early versions\n            if (value != null) {\n                this.setAsyncInit(value);\n            }\n        }\n        {\n            String property = properties.getProperty(\"druid.filters\");\n            if (property != null && property.length() > 0) {\n                try {\n                    this.setFilters(property);\n                } catch (SQLException e) {\n                    LOG.error(\"setFilters error\", e);\n                }\n            }\n        }\n        {\n            String property = properties.getProperty(Constants.DRUID_TIME_BETWEEN_LOG_STATS_MILLIS);\n            if (property != null && property.length() > 0) {\n                try {\n                    long value = Long.parseLong(property);\n                    this.setTimeBetweenLogStatsMillis(value);\n                } catch (NumberFormatException e) {\n                    LOG.error(\"illegal property '\" + Constants.DRUID_TIME_BETWEEN_LOG_STATS_MILLIS + \"'\", e);\n                }\n            }\n        }\n        {\n            String property = properties.getProperty(Constants.DRUID_STAT_SQL_MAX_SIZE);\n            if (property != null && property.length() > 0) {\n                try {\n                    int value = Integer.parseInt(property);\n                    if (dataSourceStat != null) {\n                        dataSourceStat.setMaxSqlSize(value);\n                    }\n                } catch (NumberFormatException e) {\n                    LOG.error(\"illegal property '\" + Constants.DRUID_STAT_SQL_MAX_SIZE + \"'\", e);\n                }\n            }\n        }\n        {\n            Boolean value = getBoolean(properties, \"druid.clearFiltersEnable\");\n            if (value != null) {\n                this.setClearFiltersEnable(value);\n            }\n        }\n        {\n            Boolean value = getBoolean(properties, \"druid.resetStatEnable\");\n            if (value != null) {\n                this.setResetStatEnable(value);\n            }\n        }\n        {\n            String property = properties.getProperty(\"druid.notFullTimeoutRetryCount\");\n            if (property != null && property.length() > 0) {\n                try {\n                    int value = Integer.parseInt(property);\n                    this.setNotFullTimeoutRetryCount(value);\n                } catch (NumberFormatException e) {\n                    LOG.error(\"illegal property 'druid.notFullTimeoutRetryCount'\", e);\n                }\n            }\n        }\n        {\n            String property = properties.getProperty(\"druid.timeBetweenEvictionRunsMillis\");\n            if (property != null && property.length() > 0) {\n                try {\n                    long value = Long.parseLong(property);\n                    this.setTimeBetweenEvictionRunsMillis(value);\n                } catch (NumberFormatException e) {\n                    LOG.error(\"illegal property 'druid.timeBetweenEvictionRunsMillis'\", e);\n                }\n            }\n        }\n        {\n            String property = properties.getProperty(\"druid.maxWaitThreadCount\");\n            if (property != null && property.length() > 0) {\n                try {\n                    int value = Integer.parseInt(property);\n                    this.setMaxWaitThreadCount(value);\n                } catch (NumberFormatException e) {\n                    LOG.error(\"illegal property 'druid.maxWaitThreadCount'\", e);\n                }\n            }\n        }\n        {\n            String property = properties.getProperty(\"druid.maxWait\");\n            if (property != null && property.length() > 0) {\n                try {<fim_middle>// class below is blob and data class\n"}