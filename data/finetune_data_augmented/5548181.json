{"text": "<fim_prefix>    });\n  }\n  /**\n   * Renames the existing authzObj to a new one in the authzObj -> [Paths] mapping.\n   * And updates its existing path with a new path, while keeps the rest of its paths\n   * untouched if there is any.\n   *\n   * @param pm PersistenceManager\n   * @param oldObj the existing authzObj\n   * @param newObj the new name to be changed to\n   * @param oldPath a existing path of the given authzObj\n   * @param newPath a new path to be changed to\n   * @throws SentryNoSuchObjectException if cannot find the existing authzObj or path.\n   */\n  private void renameAuthzPathsMappingCore(PersistenceManager pm, String oldObj,\n        String newObj, String oldPath, String newPath) {\n    long currentSnapshotID = getCurrentAuthzPathsSnapshotID(pm);\n    if (currentSnapshotID <= EMPTY_PATHS_SNAPSHOT_ID) {\n      LOGGER.error(\"No paths snapshot ID is found. Cannot rename authzoObj: {}\", oldObj);\n    }\n    MAuthzPathsMapping mAuthzPathsMapping = getMAuthzPathsMappingCore(pm, currentSnapshotID, oldObj);\n    if (mAuthzPathsMapping != null) {\n      mAuthzPathsMapping.deletePersistent(pm,Collections.singleton(oldPath));\n      mAuthzPathsMapping.setAuthzObjName(newObj);\n      mAuthzPathsMapping.addPathToPersist(Collections.singleton(newPath));\n      mAuthzPathsMapping.makePersistent(pm);\n    } else {\n      LOGGER.error(\"nonexistent authzObj: {} on current paths snapshot ID #{}\",\n          oldObj, currentSnapshotID);\n    }\n  }\n  /**\n   * Renames the existing authzObj to a new one in the authzObj -> [Paths] mapping,\n   * but keeps its paths mapping as-is. As well as persist the corresponding delta path\n   * change to MSentryPathChange table in a single transaction.\n   *\n   * @param oldObj the existing authzObj\n   * @param newObj the new name to be changed to\n   * @param update the corresponding path delta update\n   */\n  public void renameAuthzObj(final String oldObj, final String newObj,\n      final UniquePathsUpdate update) throws Exception {\n    execute(update, pm -> {\n      pm.setDetachAllOnCommit(false); // No need to detach objects\n      renameAuthzObjCore(pm, oldObj, newObj);\n      return null;\n    });\n  }\n  /**\n   * Renames the existing authzObj to a new one in the authzObj -> [Paths] mapping,\n   * but keeps its paths mapping as-is.\n   *\n   * @param pm PersistenceManager\n   * @param oldObj the existing authzObj\n   * @param newObj the new name to be changed to\n   * @throws SentryNoSuchObjectException if cannot find the existing authzObj.\n   */\n  private void renameAuthzObjCore(PersistenceManager pm, String oldObj,\n      String newObj) {\n    long currentSnapshotID = getCurrentAuthzPathsSnapshotID(pm);\n    if (currentSnapshotID <= EMPTY_PATHS_SNAPSHOT_ID) {\n      LOGGER.error(\"No paths snapshot ID is found. Cannot rename authzoObj: {}\", oldObj);\n    }\n    MAuthzPathsMapping mAuthzPathsMapping = getMAuthzPathsMappingCore(pm, currentSnapshotID, oldObj);\n    if (mAuthzPathsMapping != null) {\n      mAuthzPathsMapping.setAuthzObjName(newObj);\n      pm.makePersistent(mAuthzPathsMapping);\n    } else {\n      LOGGER.error(\"nonexistent authzObj: {} on current paths snapshot ID #{}\",\n          oldObj, currentSnapshotID);\n    }\n  }\n  /**\n   * Tells if there are any records in MAuthzPathsMapping\n   *\n   * @return true if there are no entries in <code>MAuthzPathsMapping</code>\n   * false if there are entries\n   * @throws Exception\n   */\n  public boolean isAuthzPathsMappingEmpty() throws Exception {\n    return tm.executeTransactionWithRetry(\n            pm -> {\n              pm.setDetachAllOnCommit(false); // No need to detach objects\n              return isTableEmptyCore(pm, MAuthzPathsMapping.class);\n            });\n  }\n  /**\n   * Tells if there are any records in MSentryHmsNotification\n   *\n   * @return true if there are no entries in <code>MSentryHmsNotification</code>\n   * false if there are entries\n   * @throws Exception\n   */\n  public boolean isHmsNotificationEmpty() throws Exception {\n    return tm.executeTransactionWithRetry(\n            pm -> {\n              pm.setDetachAllOnCommit(false); // No need to detach objects\n              return isTableEmptyCore(pm, MSentryHmsNotification.class);\n            });\n  }\n  /**\n   * Tells if there are any records in MAuthzPathsMapping\n   *\n   * @return true if there are no entries in <code>MAuthzPathsMapping</code>\n   * false if there are entries\n   * @throws Exception\n   */\n  public boolean isAuthzPathsSnapshotEmpty() throws Exception {\n    return tm.executeTransactionWithRetry(\n            pm -> {\n              pm.setDetachAllOnCommit(false); // No need to detach objects\n              return isTableEmptyCore(pm, MAuthzPathsMapping.class);\n            });\n  }\n  /**\n   * Updates authzObj -> [Paths] mapping to replace an existing path with a new one\n   * given an authzObj. As well as persist the corresponding delta path change to\n   * MSentryPathChange table in a single transaction.\n   *\n   * @param authzObj an authzObj\n   * @param oldPath the existing path maps to the given authzObj\n   * @param newPath a new path to replace the existing one\n   * @param update the corresponding path delta update\n   * @throws Exception\n   */\n  public void updateAuthzPathsMapping(final String authzObj, final String oldPath,\n        final String newPath, final UniquePathsUpdate update) throws Exception {\n    execute(update, pm -> {\n      pm.setDetachAllOnCommit(false); // No need to detach objects\n      updateAuthzPathsMappingCore(pm, authzObj, oldPath, newPath);\n      return null;\n    });\n  }\n  /**\n   * Updates authzObj -> [Paths] mapping to replace an existing path with a new one\n   * given an authzObj.\n   *\n   * @param pm PersistenceManager\n   * @param authzObj an authzObj\n   * @param oldPath the existing path maps to the given authzObj\n   * @param newPath a non-empty path to replace the existing one\n   * @throws SentryNoSuchObjectException if no such path found\n   *        in the authzObj -> [Paths] mapping.\n   */\n  private void updateAuthzPathsMappingCore(PersistenceManager pm, String authzObj,\n        String oldPath, String newPath) {\n    long currentSnapshotID = getCurrentAuthzPathsSnapshotID(pm);\n    if (currentSnapshotID <= EMPTY_PATHS_SNAPSHOT_ID) {\n      LOGGER.error(\"No paths snapshot ID is found. Cannot update authzoObj: {}\", authzObj);\n    }\n    MAuthzPathsMapping mAuthzPathsMapping = getMAuthzPathsMappingCore(pm, currentSnapshotID, authzObj);\n    if (mAuthzPathsMapping == null) {\n      mAuthzPathsMapping = new MAuthzPathsMapping(currentSnapshotID, getNextAuthzObjectID(pm), authzObj,\n              Collections.singleton(newPath));\n    } else {\n      mAuthzPathsMapping.deletePersistent(pm, Collections.singleton(oldPath));\n      mAuthzPathsMapping.addPathToPersist(Collections.singleton(newPath));\n    }\n    mAuthzPathsMapping.makePersistent(pm);\n  }\n  /**\n   * Get the Collection of MPath associated with snapshot id and authzObj\n   * @param authzSnapshotID Snapshot ID\n   * @param authzObj Object name\n   * @return Path mapping for object provided.\n   * @throws Exception\n   */\n<fim_suffix>  @VisibleForTesting\n   Set<MPath> getMAuthzPaths(long authzSnapshotID, String authzObj) throws Exception {\n    return tm.executeTransactionWithRetry( pm -> {\n      MAuthzPathsMapping mapping = null;\n      pm.setDetachAllOnCommit(true); // No need to detach objects\n      mapping = getMAuthzPathsMappingCore(pm, authzSnapshotID, authzObj);\n      if(mapping != null) {\n        Set<MPath> paths = mapping.getPathsPersisted();\n        return paths;\n      } else {\n        return Collections.emptySet();\n      }\n    });\n  }<fim_middle>// function below has no smell\n"}