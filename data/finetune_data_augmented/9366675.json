{"text": "<fim_prefix> * CertPathBuilder implementation.\n */\nclass PKIX {\n    private static final Debug debug = Debug.getInstance(\"certpath\");\n    private PKIX() { }\n    static boolean isDSAPublicKeyWithoutParams(PublicKey publicKey) {\n        return (publicKey instanceof DSAPublicKey &&\n               ((DSAPublicKey)publicKey).getParams() == null);\n    }\n    static ValidatorParams checkParams(CertPath cp, CertPathParameters params)\n        throws InvalidAlgorithmParameterException\n    {\n        if (!(params instanceof PKIXParameters)) {\n            throw new InvalidAlgorithmParameterException(\"inappropriate \"\n                + \"params, must be an instance of PKIXParameters\");\n        }\n        return new ValidatorParams(cp, (PKIXParameters)params);\n    }\n    static BuilderParams checkBuilderParams(CertPathParameters params)\n        throws InvalidAlgorithmParameterException\n    {\n        if (!(params instanceof PKIXBuilderParameters)) {\n            throw new InvalidAlgorithmParameterException(\"inappropriate \"\n                + \"params, must be an instance of PKIXBuilderParameters\");\n        }\n        return new BuilderParams((PKIXBuilderParameters)params);\n    }\n    /**\n     * PKIXParameters that are shared by the PKIX CertPathValidator\n     * implementation. Provides additional functionality and avoids\n     * unnecessary cloning.\n     */\n    static class ValidatorParams {\n        private final PKIXParameters params;\n        private CertPath certPath;\n        private List<PKIXCertPathChecker> checkers;\n        private List<CertStore> stores;\n        private boolean gotDate;\n        private Date date;\n        private Set<String> policies;\n        private boolean gotConstraints;\n        private CertSelector constraints;\n        private Set<TrustAnchor> anchors;\n        private List<X509Certificate> certs;\n        private Timestamp timestamp;\n        private String variant;\n        ValidatorParams(CertPath cp, PKIXParameters params)\n            throws InvalidAlgorithmParameterException\n        {\n            this(params);\n            if (!cp.getType().equals(\"X.509\") && !cp.getType().equals(\"X509\")) {\n                throw new InvalidAlgorithmParameterException(\"inappropriate \"\n                    + \"CertPath type specified, must be X.509 or X509\");\n            }\n            this.certPath = cp;\n        }\n        ValidatorParams(PKIXParameters params)\n            throws InvalidAlgorithmParameterException\n        {\n            if (params instanceof PKIXExtendedParameters) {\n                timestamp = ((PKIXExtendedParameters) params).getTimestamp();\n                variant = ((PKIXExtendedParameters) params).getVariant();\n            }\n            this.anchors = params.getTrustAnchors();\n            // Make sure that none of the trust anchors include name constraints\n            // (not supported).\n            for (TrustAnchor anchor : this.anchors) {\n                if (anchor.getNameConstraints() != null) {\n                    throw new InvalidAlgorithmParameterException\n                        (\"name constraints in trust anchor not supported\");\n                }\n            }\n            this.params = params;\n        }\n        CertPath certPath() {\n            return certPath;\n        }\n        // called by CertPathBuilder after path has been built\n        void setCertPath(CertPath cp) {\n            this.certPath = cp;\n        }\n        List<X509Certificate> certificates() {\n            if (certs == null) {\n                if (certPath == null) {\n                    certs = Collections.emptyList();\n                } else {\n                    // Reverse the ordering for validation so that the target\n                    // cert is the last certificate\n                    @SuppressWarnings(\"unchecked\")\n                    List<X509Certificate> xc = new ArrayList<>\n                        ((List<X509Certificate>)certPath.getCertificates());\n                    Collections.reverse(xc);\n                    certs = xc;\n                }\n            }\n            return certs;\n        }\n        List<PKIXCertPathChecker> certPathCheckers() {\n            if (checkers == null)\n                checkers = params.getCertPathCheckers();\n            return checkers;\n        }\n        List<CertStore> certStores() {\n            if (stores == null)\n                stores = params.getCertStores();\n            return stores;\n        }\n        Date date() {\n            if (!gotDate) {\n                date = params.getDate();\n                if (date == null)\n                    date = new Date();\n                gotDate = true;\n            }\n            return date;\n        }\n        Set<String> initialPolicies() {\n            if (policies == null)\n                policies = params.getInitialPolicies();\n            return policies;\n        }\n        CertSelector targetCertConstraints() {\n            if (!gotConstraints) {\n                constraints = params.getTargetCertConstraints();\n                gotConstraints = true;\n            }\n            return constraints;\n        }\n        Set<TrustAnchor> trustAnchors() {\n            return anchors;\n        }\n        boolean revocationEnabled() {\n            return params.isRevocationEnabled();\n        }\n        boolean policyMappingInhibited() {\n            return params.isPolicyMappingInhibited();\n        }\n        boolean explicitPolicyRequired() {\n            return params.isExplicitPolicyRequired();\n        }\n        boolean policyQualifiersRejected() {\n            return params.getPolicyQualifiersRejected();\n        }\n        String sigProvider() { return params.getSigProvider(); }\n        boolean anyPolicyInhibited() { return params.isAnyPolicyInhibited(); }\n        // in rare cases we need access to the original params, for example\n        // in order to clone CertPathCheckers before building a new chain\n        PKIXParameters getPKIXParameters() {\n            return params;\n        }\n        Timestamp timestamp() {\n            return timestamp;\n        }\n        String variant() {\n            return variant;\n        }\n    }\n    static class BuilderParams extends ValidatorParams {\n        private PKIXBuilderParameters params;\n        private List<CertStore> stores;\n        private X500Principal targetSubject;\n        BuilderParams(PKIXBuilderParameters params)\n            throws InvalidAlgorithmParameterException\n        {\n            super(params);\n            checkParams(params);\n        }\n        private void checkParams(PKIXBuilderParameters params)\n            throws InvalidAlgorithmParameterException\n        {\n            CertSelector sel = targetCertConstraints();\n            if (!(sel instanceof X509CertSelector)) {\n                throw new InvalidAlgorithmParameterException(\"the \"\n                    + \"targetCertConstraints parameter must be an \"\n                    + \"X509CertSelector\");\n            }\n            this.params = params;\n            this.targetSubject = getTargetSubject(\n                certStores(), (X509CertSelector)targetCertConstraints());\n        }\n        @Override List<CertStore> certStores() {\n            if (stores == null) {\n                // reorder CertStores so that local CertStores are tried first\n                stores = new ArrayList<>(params.getCertStores());\n                Collections.sort(stores, new CertStoreComparator());\n            }\n            return stores;\n        }\n        int maxPathLength() { return params.getMaxPathLength(); }\n        PKIXBuilderParameters params() { return params; }\n        X500Principal targetSubject() { return targetSubject; }\n        /**\n         * Returns the target subject DN from the first X509Certificate that\n         * is fetched that matches the specified X509CertSelector.\n         */\n        private static X500Principal getTargetSubject(List<CertStore> stores,\n                                                      X509CertSelector sel)\n            throws InvalidAlgorithmParameterException\n        {\n            X500Principal subject = sel.getSubject();\n            if (subject != null) {\n                return subject;\n            }\n            X509Certificate cert = sel.getCertificate();\n            if (cert != null) {\n                subject = cert.getSubjectX500Principal();\n            }\n            if (subject != null) {\n                return subject;\n            }\n            for (CertStore store : stores) {\n                try {\n                    Collection<? extends Certificate> certs =\n                        (Collection<? extends Certificate>)\n                            store.getCertificates(sel);\n                    if (!certs.isEmpty()) {\n                        X509Certificate xc =\n                            (X509Certificate)certs.iterator().next();\n                        return xc.getSubjectX500Principal();\n                    }\n                } catch (CertStoreException e) {\n                    // ignore but log it\n                    if (debug != null) {\n                        debug.println(\"BuilderParams.getTargetSubjectDN: \" +\n                            \"non-fatal exception retrieving certs: \" + e);\n                        e.printStackTrace();\n                    }\n                }\n            }\n            throw new InvalidAlgorithmParameterException\n                (\"Could not determine unique target subject\");\n        }\n    }\n    /**\n     * A CertStoreException with additional information about the type of\n     * CertStore that generated the exception.\n     */\n    static class CertStoreTypeException extends CertStoreException {\n        private static final long serialVersionUID = 7463352639238322556L;\n        private final String type;\n        CertStoreTypeException(String type, CertStoreException cse) {\n            super(cse.getMessage(), cse.getCause());\n            this.type = type;\n        }\n        String getType() {\n            return type;\n        }\n    }\n    /**\n     * Comparator that orders CertStores so that local CertStores come before\n     * remote CertStores.\n     */\n<fim_suffix>    private static class CertStoreComparator implements Comparator<CertStore> {\n        @Override\n        public int compare(CertStore store1, CertStore store2) {\n            if (store1.getType().equals(\"Collection\") ||\n                store1.getCertStoreParameters() instanceof\n                CollectionCertStoreParameters) {\n                return -1;\n            } else {\n                return 1;\n            }\n        }\n    }<fim_middle>// class below has no smell\n"}