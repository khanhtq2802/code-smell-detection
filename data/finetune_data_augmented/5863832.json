{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n * \n *   http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.uima.cas.impl;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.ByteBuffer;\nimport org.apache.uima.UIMARuntimeException;\n/**\n * Common de/serialization \n */\npublic class CommonSerDes {\n  int version1;\n  int version2;\n  boolean isDelta;\n  boolean isCompressed;\n  /*********************************************\n   * HEADERS\n   * Serialization versioning\n   *   There are 1 or 2 words used for versioning.\n   *     Compressed formats and plain formats with bit xx on in first word use 2nd word\n   *     \n   *   First word:\n   *   \n   *     - bit in 0x01 position: on for binary non-delta (redundant)   \n   *     - bit in 0x02 position: on means delta, off - not delta\n   *     - bit in 0x04 position: on means compressed, off means plain binary\n   *     - bit in 0x08 position: on means type system + indexes def included\n   *     - bit in 0x10 position: on means type system (only) included\n   *     - bits  0xF0 reserved\n   *     \n   *     - byte in 0xFF 00 position: \n   *               a sequential version number, incrementing (starting w/ 0)\n   *     \n   *         Form 4:  0 = original (UIMA v2)\n   *                  1 = fixes to original found during V3 development\n   *                  2 = V3\n   *                       \n   *     - byte in 0xFF 00 00  position: special flags with some shared meaning\n   *       -- bit 0x01 00 00: V3 formats\n   *         \n   *   Second word:\n   *     - bit in 0x01 position: on means form6, off = form 4 \n   *********************************************/\n  public static class Header {\n    boolean isDelta;\n    boolean isCompressed;\n    boolean form4;\n    boolean form6;\n    boolean typeSystemIncluded;  // for form 6, TS only\n    boolean typeSystemIndexDefIncluded;\n    byte seqVersionNbr;\n    boolean isV3;\n    boolean swap;\n    int v;      // for error messages\n    Reading reading;\n    /* **********  BUILDERS ************/\n    public Header delta() {isDelta = true;  return this; }\n    public Header delta(boolean v2) {isDelta = v2;  return this; }\n    public Header form4() {isCompressed = form4 = true; form6 = false; return this; }\n    public Header form6() {isCompressed = form6 = true; form4 = false; return this; }\n    public Header typeSystemIncluded(boolean f) {typeSystemIncluded = f; return this; }\n    public Header typeSystemIndexDefIncluded(boolean f) {typeSystemIndexDefIncluded = f; return this; }\n    public Header seqVer(int v2) { assert (v2 >= 0 && v2 < 256); seqVersionNbr = (byte)v2; return this; }\n    public Header v3() {isV3 = true; return this; }\n    public void write(DataOutputStream dos) throws IOException {\n      v = (!isCompressed && !isDelta) ? 1 : 0;\n      if (isDelta) v |= 0x02;\n      if (isCompressed) v |= 0x04;\n      if (typeSystemIndexDefIncluded) v |= 0x08;\n      if (typeSystemIncluded) v |= 0x10;\n      v |= (seqVersionNbr << 8);\n      if (isV3) v |= 0x010000;\n      byte[] uima = new byte[4];\n      uima[0] = 85; // U\n      uima[1] = 73; // I\n      uima[2] = 77; // M\n      uima[3] = 65; // A\n      ByteBuffer buf = ByteBuffer.wrap(uima);\n      int key = buf.asIntBuffer().get();\n      dos.writeInt(key);\n      dos.writeInt(v);\n      if (isCompressed) {\n        dos.writeInt(form6 ? 1 : 0);\n      }\n    }\n    /* ******** Header Properties **********/\n    public boolean isDelta() {\n      return isDelta;\n    }\n    public boolean isCompressed() {\n      return isCompressed;\n    }\n    public boolean isForm4() {\n      return form4;\n    }\n    public boolean isForm6() {\n      return form6;\n    }\n<fim_suffix>    public boolean isTypeSystemIndexDefIncluded() {\n      return typeSystemIndexDefIncluded;\n    }\n    public boolean isTypeSystemIncluded() {\n      return typeSystemIncluded;\n    }    \n    public byte getSeqVersionNbr() {\n      return seqVersionNbr;\n    }\n    public boolean isV3() {\n      return isV3;\n    }\n  }\n  public static Header createHeader() {\n    return new Header();\n  }\n  public static boolean isBinaryHeader(DataInputStream dis) {\n    dis.mark(4);\n    byte[] bytebuf = new byte[4];\n    try {\n      bytebuf[0] = dis.readByte(); // U\n      bytebuf[1] = dis.readByte(); // I\n      bytebuf[2] = dis.readByte(); // M\n      bytebuf[3] = dis.readByte(); // A\n      String s = new String(bytebuf, \"UTF-8\");\n      return s.equals(\"UIMA\") || s.equals(\"AMIU\");\n    } catch (IOException e) {\n      return false;\n    } finally {\n      try {\n        dis.reset();\n      } catch (IOException e) {\n        throw new UIMARuntimeException(e);\n      }\n    }\n  }\n  public static Header readHeader(DataInputStream dis) throws IOException {\n    Header h = new Header();\n    // key\n    // determine if byte swap if needed based on key\n    byte[] bytebuf = new byte[4];\n    bytebuf[0] = dis.readByte(); // U\n    bytebuf[1] = dis.readByte(); // I\n    bytebuf[2] = dis.readByte(); // M\n    bytebuf[3] = dis.readByte(); // A\n    h.swap = (bytebuf[0] != 85);\n    Reading r = new Reading(dis, h.swap);\n    h.reading = r;\n    int v = h.v = r.readInt();  // h.v for error message use\n    h.isDelta = (v & 2) != 0;\n    h.isCompressed = (v & 4) != 0;\n    h.typeSystemIndexDefIncluded = (v & 8) != 0;\n    h.typeSystemIncluded = (v & 16) != 0;\n    h.seqVersionNbr = (byte) ((v & 0xFF00) >> 8);\n    h.isV3 = (v & 0x010000) != 0;\n    if (h.isCompressed) {\n      v = r.readInt();\n      h.form4 = v == 0;\n      h.form6 = v == 1;\n    } \n    return h;\n  }\n  public static DataOutputStream maybeWrapToDataOutputStream(OutputStream os) {\n    if (os instanceof DataOutputStream) {\n      return (DataOutputStream) os;\n    }\n    return new DataOutputStream(os);\n  }\n  public static DataInputStream maybeWrapToDataInputStream(InputStream os) {\n    if (os instanceof DataInputStream) {\n      return (DataInputStream) os;\n    }\n    return new DataInputStream(os);\n  }\n  /** \n   * byte swapping reads of integer forms\n   */\n  public static class Reading {\n    final DataInputStream dis;\n    final boolean swap;\n    Reading(DataInputStream dis, boolean swap) {\n      this.dis = dis;\n      this.swap = swap;\n    }\n    long readLong() throws IOException {\n      long v = dis.readLong();\n      return swap ? Long.reverseBytes(v) : v;\n    }\n    int readInt() throws IOException {\n      int v = dis.readInt();\n      return swap ? Integer.reverseBytes(v) : v;\n    }\n    short readShort() throws IOException {\n      short v = dis.readShort();<fim_middle>// function below has no smell\n"}