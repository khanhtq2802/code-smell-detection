{"text": "<fim_prefix>     * @return true if the value is within the bounds\n     */\n    @Override\n    public boolean containsWithinBounds(Object value) {\n        final int result = compareTo(from, value);\n        return result == 0 || result < 0 && compareTo(to, value) >= 0;\n    }\n    /**\n     * protection against calls from Groovy\n     */\n    @SuppressWarnings(\"unused\")\n    private void setSize(int size) {\n        throw new UnsupportedOperationException(\"size must not be changed\");\n    }\n    @Override\n    public int size() {\n        if (size == -1) {\n            calcSize(from, to, stepSize);\n        }\n        return size;\n    }\n    void calcSize(Comparable from, Comparable to, Number stepSize) {\n        int tempsize = 0;\n        boolean shortcut = false;\n        if (isIntegral(stepSize)) {\n            if ((from instanceof Integer || from instanceof Long)\n                    && (to instanceof Integer || to instanceof Long)) {\n                // let's fast calculate the size\n                final BigInteger fromNum = new BigInteger(from.toString());\n                final BigInteger toTemp = new BigInteger(to.toString());\n                final BigInteger toNum = inclusive ? toTemp : toTemp.subtract(BigInteger.ONE);\n                final BigInteger sizeNum = new BigDecimal(toNum.subtract(fromNum)).divide(new BigDecimal(stepSize.longValue()), BigDecimal.ROUND_DOWN).toBigInteger().add(BigInteger.ONE);\n                tempsize = sizeNum.compareTo(BigInteger.valueOf(Integer.MAX_VALUE)) == -1 ? sizeNum.intValue() : Integer.MAX_VALUE;\n                shortcut = true;\n            } else if (((from instanceof BigDecimal || from instanceof BigInteger) && to instanceof Number) ||\n                    ((to instanceof BigDecimal || to instanceof BigInteger) && from instanceof Number)) {\n                // let's fast calculate the size\n                final BigDecimal fromNum = new BigDecimal(from.toString());\n                final BigDecimal toTemp = new BigDecimal(to.toString());\n                final BigDecimal toNum = inclusive ? toTemp : toTemp.subtract(new BigDecimal(\"1.0\"));\n                final BigInteger sizeNum = toNum.subtract(fromNum).divide(new BigDecimal(stepSize.longValue()), BigDecimal.ROUND_DOWN).toBigInteger().add(BigInteger.ONE);\n                tempsize = sizeNum.compareTo(BigInteger.valueOf(Integer.MAX_VALUE)) == -1 ? sizeNum.intValue() : Integer.MAX_VALUE;\n                shortcut = true;\n            }\n        }\n        if (!shortcut) {\n            // let's brute-force calculate the size by iterating start to end\n            final Iterator iter = new StepIterator(this, stepSize);\n            while (iter.hasNext()) {\n                tempsize++;\n                // integer overflow\n                if (tempsize < 0) {\n                    break;\n                }\n                iter.next();\n            }\n            // integer overflow\n            if (tempsize < 0) {\n                tempsize = Integer.MAX_VALUE;\n            }\n        }\n        size = tempsize;\n    }\n    private boolean isIntegral(Number stepSize) {\n        BigDecimal tempStepSize = new BigDecimal(stepSize.toString());\n        return tempStepSize.equals(new BigDecimal(tempStepSize.toBigInteger()));\n    }\n    @Override\n    public List<Comparable> subList(int fromIndex, int toIndex) {\n        if (fromIndex < 0) {\n            throw new IndexOutOfBoundsException(\"fromIndex = \" + fromIndex);\n        }\n        if (fromIndex > toIndex) {\n            throw new IllegalArgumentException(\"fromIndex(\" + fromIndex + \") > toIndex(\" + toIndex + \")\");\n        }\n        if (fromIndex == toIndex) {\n            return new EmptyRange<Comparable>(from);\n        }\n        // Performance detail:\n        // not using get(fromIndex), get(toIndex) in the following to avoid stepping over elements twice\n        final Iterator<Comparable> iter = new StepIterator(this, stepSize);\n        Comparable value = iter.next();\n        int i = 0;\n        for (; i < fromIndex; i++) {\n            if (!iter.hasNext()) {\n                throw new IndexOutOfBoundsException(\"Index: \" + i + \" is too big for range: \" + this);\n            }\n            value = iter.next();\n        }\n        final Comparable fromValue = value;\n        for (; i < toIndex - 1; i++) {\n            if (!iter.hasNext()) {\n                throw new IndexOutOfBoundsException(\"Index: \" + i + \" is too big for range: \" + this);\n            }\n            value = iter.next();\n        }\n        final Comparable toValue = value;\n        return new NumberRange(comparableNumber(fromValue), comparableNumber(toValue), comparableNumber(stepSize), true);\n    }\n    @Override\n    public String toString() {\n        return getToString(to.toString(), from.toString());\n    }\n    @Override\n    public String inspect() {\n        return getToString(InvokerHelper.inspect(to), InvokerHelper.inspect(from));\n    }\n    private String getToString(String toText, String fromText) {\n        String sep = inclusive ? \"..\" : \"..<\";\n        String base = reverse ? \"\" + toText + sep + fromText : \"\" + fromText + sep + toText;\n        return Integer.valueOf(1).equals(stepSize) ? base : base + \".by(\" + stepSize + \")\";\n    }\n    /**\n     * iterates over all values and returns true if one value matches.\n     * Also see containsWithinBounds.\n     */\n    @Override\n    public boolean contains(Object value) {\n        if (value == null) {\n            return false;\n        }\n        final Iterator it = new StepIterator(this, stepSize);\n        while (it.hasNext()) {\n            if (compareEqual(value, it.next())) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void step(int numSteps, Closure closure) {\n        if (numSteps == 0 && compareTo(from, to) == 0) {\n            return; // from == to and step == 0, nothing to do, so return\n        }\n        final StepIterator iter = new StepIterator(this, multiply(numSteps, stepSize));\n        while (iter.hasNext()) {\n            closure.call(iter.next());\n        }\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Iterator<Comparable> iterator() {\n        return new StepIterator(this, stepSize);\n    }\n    /**\n     * convenience class to serve in other methods.\n     * It's not thread-safe, and lazily produces the next element only on calls of hasNext() or next()\n     */\n    private class StepIterator implements Iterator<Comparable> {\n        private final NumberRange range;\n        private final Number step;\n        private final boolean isAscending;\n        private boolean isNextFetched = false;\n        private Comparable next = null;\n        StepIterator(NumberRange range, Number step) {\n            if (compareEqual(step, 0) && compareNotEqual(range.getFrom(), range.getTo())) {\n                throw new GroovyRuntimeException(\"Infinite loop detected due to step size of 0\");\n            }\n            this.range = range;\n            if (compareLessThan(step, 0)) {\n                this.step = multiply(step, -1);\n                isAscending = range.isReverse();\n            } else {\n                this.step = step;\n                isAscending = !range.isReverse();\n            }\n        }\n        @Override\n        public boolean hasNext() {\n            fetchNextIfNeeded();\n            return (next != null) && (isAscending\n                    ? (range.inclusive ? compareLessThanEqual(next, range.getTo()) : compareLessThan(next, range.getTo()))\n                    : (range.inclusive ? compareGreaterThanEqual(next, range.getFrom()) : compareGreaterThan(next, range.getFrom())));\n        }\n        @Override\n        public Comparable next() {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            fetchNextIfNeeded();\n            isNextFetched = false;\n            return next;\n        }\n        private void fetchNextIfNeeded() {\n            if (!isNextFetched) {\n                isNextFetched = true;\n                if (next == null) {\n                    // make the first fetch lazy too\n                    next = isAscending ? range.getFrom() : range.getTo();\n                } else {\n                    next = isAscending ? increment(next, step) : decrement(next, step);\n                }\n            }\n        }\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    }\n    @Override\n    public List<Comparable> step(int numSteps) {\n        final IteratorClosureAdapter<Comparable> adapter = new IteratorClosureAdapter<Comparable>(this);\n        step(numSteps, adapter);\n        return adapter.asList();\n    }\n    /**\n     * Increments by given step\n     *\n     * @param value the value to increment\n     * @param step the amount to increment\n     * @return the incremented value\n     */\n<fim_suffix>    @SuppressWarnings(\"unchecked\")\n    private Comparable increment(Object value, Number step) {\n        return (Comparable) plus((Number) value, step);\n    }<fim_middle>// function below has no smell\n"}