{"text": "<fim_prefix>\t * transactions for, not a TransactionAwareDataSourceProxy. Only data access\n\t * code may work with TransactionAwareDataSourceProxy, while the transaction\n\t * manager needs to work on the underlying target DataSource. If there's\n\t * nevertheless a TransactionAwareDataSourceProxy passed in, it will be\n\t * unwrapped to extract its target DataSource.\n\t * <p><b>NOTE: For scenarios with many transactions that just read data from\n\t * Hibernate's cache (and do not actually access the database), consider using\n\t * a {@link org.springframework.jdbc.datasource.LazyConnectionDataSourceProxy}\n\t * for the actual target DataSource. Alternatively, consider switching\n\t * {@link #setPrepareConnection \"prepareConnection\"} to {@code false}.</b>\n\t * In both cases, this transaction manager will not eagerly acquire a\n\t * JDBC Connection for each Hibernate Session anymore (as of Spring 5.1).\n\t * @see #setAutodetectDataSource\n\t * @see TransactionAwareDataSourceProxy\n\t * @see org.springframework.jdbc.datasource.LazyConnectionDataSourceProxy\n\t * @see org.springframework.jdbc.core.JdbcTemplate\n\t */\n\tpublic void setDataSource(@Nullable DataSource dataSource) {\n\t\tif (dataSource instanceof TransactionAwareDataSourceProxy) {\n\t\t\t// If we got a TransactionAwareDataSourceProxy, we need to perform transactions\n\t\t\t// for its underlying target DataSource, else data access code won't see\n\t\t\t// properly exposed transactions (i.e. transactions for the target DataSource).\n\t\t\tthis.dataSource = ((TransactionAwareDataSourceProxy) dataSource).getTargetDataSource();\n\t\t}\n\t\telse {\n\t\t\tthis.dataSource = dataSource;\n\t\t}\n\t}\n\t/**\n\t * Return the JDBC DataSource that this instance manages transactions for.\n\t */\n\t@Nullable\n\tpublic DataSource getDataSource() {\n\t\treturn this.dataSource;\n\t}\n\t/**\n\t * Set whether to autodetect a JDBC DataSource used by the Hibernate SessionFactory,\n\t * if set via LocalSessionFactoryBean's {@code setDataSource}. Default is \"true\".\n\t * <p>Can be turned off to deliberately ignore an available DataSource, in order\n\t * to not expose Hibernate transactions as JDBC transactions for that DataSource.\n\t * @see #setDataSource\n\t */\n\tpublic void setAutodetectDataSource(boolean autodetectDataSource) {\n\t\tthis.autodetectDataSource = autodetectDataSource;\n\t}\n\t/**\n\t * Set whether to prepare the underlying JDBC Connection of a transactional\n\t * Hibernate Session, that is, whether to apply a transaction-specific\n\t * isolation level and/or the transaction's read-only flag to the underlying\n\t * JDBC Connection.\n\t * <p>Default is \"true\". If you turn this flag off, the transaction manager\n\t * will not support per-transaction isolation levels anymore. It will not\n\t * call {@code Connection.setReadOnly(true)} for read-only transactions\n\t * anymore either. If this flag is turned off, no cleanup of a JDBC Connection\n\t * is required after a transaction, since no Connection settings will get modified.\n\t * @see Connection#setTransactionIsolation\n\t * @see Connection#setReadOnly\n\t */\n\tpublic void setPrepareConnection(boolean prepareConnection) {\n\t\tthis.prepareConnection = prepareConnection;\n\t}\n\t/**\n\t * Set whether to allow result access after completion, typically via Hibernate's\n\t * ScrollableResults mechanism.\n\t * <p>Default is \"false\". Turning this flag on enforces over-commit holdability on the\n\t * underlying JDBC Connection (if {@link #prepareConnection \"prepareConnection\"} is on)\n\t * and skips the disconnect-on-completion step.\n\t * @see Connection#setHoldability\n\t * @see ResultSet#HOLD_CURSORS_OVER_COMMIT\n\t * @see #disconnectOnCompletion(Session)\n\t */\n\tpublic void setAllowResultAccessAfterCompletion(boolean allowResultAccessAfterCompletion) {\n\t\tthis.allowResultAccessAfterCompletion = allowResultAccessAfterCompletion;\n\t}\n\t/**\n\t * Set whether to operate on a Hibernate-managed Session instead of a\n\t * Spring-managed Session, that is, whether to obtain the Session through\n\t * Hibernate's {@link SessionFactory#getCurrentSession()}\n\t * instead of {@link SessionFactory#openSession()} (with a Spring\n\t * {@link TransactionSynchronizationManager}\n\t * check preceding it).\n\t * <p>Default is \"false\", i.e. using a Spring-managed Session: taking the current\n\t * thread-bound Session if available (e.g. in an Open-Session-in-View scenario),\n\t * creating a new Session for the current transaction otherwise.\n\t * <p>Switch this flag to \"true\" in order to enforce use of a Hibernate-managed Session.\n\t * Note that this requires {@link SessionFactory#getCurrentSession()}\n\t * to always return a proper Session when called for a Spring-managed transaction;\n\t * transaction begin will fail if the {@code getCurrentSession()} call fails.\n\t * <p>This mode will typically be used in combination with a custom Hibernate\n\t * {@link org.hibernate.context.spi.CurrentSessionContext} implementation that stores\n\t * Sessions in a place other than Spring's TransactionSynchronizationManager.\n\t * It may also be used in combination with Spring's Open-Session-in-View support\n\t * (using Spring's default {@link SpringSessionContext}), in which case it subtly\n\t * differs from the Spring-managed Session mode: The pre-bound Session will <i>not</i>\n\t * receive a {@code clear()} call (on rollback) or a {@code disconnect()}\n\t * call (on transaction completion) in such a scenario; this is rather left up\n\t * to a custom CurrentSessionContext implementation (if desired).\n\t */\n\tpublic void setHibernateManagedSession(boolean hibernateManagedSession) {\n\t\tthis.hibernateManagedSession = hibernateManagedSession;\n\t}\n\t/**\n\t * Set the bean name of a Hibernate entity interceptor that allows to inspect\n\t * and change property values before writing to and reading from the database.\n\t * Will get applied to any new Session created by this transaction manager.\n\t * <p>Requires the bean factory to be known, to be able to resolve the bean\n\t * name to an interceptor instance on session creation. Typically used for\n\t * prototype interceptors, i.e. a new interceptor instance per session.\n\t * <p>Can also be used for shared interceptor instances, but it is recommended\n\t * to set the interceptor reference directly in such a scenario.\n\t * @param entityInterceptorBeanName the name of the entity interceptor in\n\t * the bean factory\n\t * @see #setBeanFactory\n\t * @see #setEntityInterceptor\n\t */\n\tpublic void setEntityInterceptorBeanName(String entityInterceptorBeanName) {\n\t\tthis.entityInterceptor = entityInterceptorBeanName;\n\t}\n\t/**\n\t * Set a Hibernate entity interceptor that allows to inspect and change\n\t * property values before writing to and reading from the database.\n\t * Will get applied to any new Session created by this transaction manager.\n\t * <p>Such an interceptor can either be set at the SessionFactory level,\n\t * i.e. on LocalSessionFactoryBean, or at the Session level, i.e. on\n\t * HibernateTransactionManager.\n\t * @see LocalSessionFactoryBean#setEntityInterceptor\n\t */\n\tpublic void setEntityInterceptor(@Nullable Interceptor entityInterceptor) {\n\t\tthis.entityInterceptor = entityInterceptor;\n\t}\n\t/**\n\t * Return the current Hibernate entity interceptor, or {@code null} if none.\n\t * Resolves an entity interceptor bean name via the bean factory,\n\t * if necessary.\n\t * @throws IllegalStateException if bean name specified but no bean factory set\n\t * @throws BeansException if bean name resolution via the bean factory failed\n\t * @see #setEntityInterceptor\n\t * @see #setEntityInterceptorBeanName\n\t * @see #setBeanFactory\n\t */\n<fim_suffix>\t@Nullable\n\tpublic Interceptor getEntityInterceptor() throws IllegalStateException, BeansException {\n\t\tif (this.entityInterceptor instanceof Interceptor) {\n\t\t\treturn (Interceptor) this.entityInterceptor;\n\t\t}\n\t\telse if (this.entityInterceptor instanceof String) {\n\t\t\tif (this.beanFactory == null) {\n\t\t\t\tthrow new IllegalStateException(\"Cannot get entity interceptor via bean name if no bean factory set\");\n\t\t\t}\n\t\t\tString beanName = (String) this.entityInterceptor;\n\t\t\treturn this.beanFactory.getBean(beanName, Interceptor.class);\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}<fim_middle>// function below has no smell\n"}