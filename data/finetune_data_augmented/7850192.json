{"text": "<fim_prefix>  /**\n   * Used during recovery to calculate the OplogEntryId of the next MOD_ENTRY record.\n   *\n   * @since GemFire prPersistSprint1\n   */\n  private long recoverModEntryId = DiskStoreImpl.INVALID_ID;\n  /**\n   * Added to fix bug 41301. High water mark of modified entries.\n   */\n  private long recoverModEntryIdHWM = DiskStoreImpl.INVALID_ID;\n  /**\n   * Added to fix bug 41340. High water mark of deleted entries.\n   */\n  private long recoverDelEntryIdHWM = DiskStoreImpl.INVALID_ID;\n  /**\n   * Used during writing to remember the last DEL_ENTRY OplogEntryId written to this oplog.\n   *\n   * @since GemFire prPersistSprint1\n   */\n  private long writeDelEntryId = DiskStoreImpl.INVALID_ID;\n  /**\n   * Used during recovery to calculate the OplogEntryId of the next DEL_ENTRY record.\n   *\n   * @since GemFire prPersistSprint1\n   */\n  private long recoverDelEntryId = DiskStoreImpl.INVALID_ID;\n  private void setRecoverNewEntryId(long v) {\n    this.recoverNewEntryId = v;\n  }\n  private long incRecoverNewEntryId() {\n    this.recoverNewEntryId += 1;\n    return this.recoverNewEntryId;\n  }\n  /**\n   * Given a delta calculate the OplogEntryId for a MOD_ENTRY.\n   */\n  public long calcModEntryId(long delta) {\n    long oplogKeyId = this.recoverModEntryId + delta;\n    if (logger.isTraceEnabled(LogMarker.PERSIST_RECOVERY_VERBOSE)) {\n      logger.trace(LogMarker.PERSIST_RECOVERY_VERBOSE,\n          \"calcModEntryId delta={} recoverModEntryId={}  oplogKeyId={}\", delta,\n          this.recoverModEntryId, oplogKeyId);\n    }\n    this.recoverModEntryId = oplogKeyId;\n    if (oplogKeyId > this.recoverModEntryIdHWM) {\n      this.recoverModEntryIdHWM = oplogKeyId; // fixes bug 41301\n    }\n    return oplogKeyId;\n  }\n  /**\n   * Given a delta calculate the OplogEntryId for a DEL_ENTRY.\n   */\n  public long calcDelEntryId(long delta) {\n    long oplogKeyId = this.recoverDelEntryId + delta;\n    if (logger.isTraceEnabled(LogMarker.PERSIST_RECOVERY_VERBOSE)) {\n      logger.trace(LogMarker.PERSIST_RECOVERY_VERBOSE,\n          \"calcDelEntryId delta={} recoverModEntryId={}  oplogKeyId={}\", delta,\n          this.recoverModEntryId, oplogKeyId);\n    }\n    this.recoverDelEntryId = oplogKeyId;\n    if (oplogKeyId > this.recoverDelEntryIdHWM) {\n      this.recoverDelEntryIdHWM = oplogKeyId; // fixes bug 41340\n    }\n    return oplogKeyId;\n  }\n  private boolean crashed;\n  boolean isCrashed() {\n    return this.crashed;\n  }\n  /**\n   * Return bytes read.\n   */\n<fim_suffix>  long recoverDrf(OplogEntryIdSet deletedIds, boolean alreadyRecoveredOnce, boolean latestOplog) {\n    File drfFile = this.drf.f;\n    if (drfFile == null) {\n      this.haveRecoveredDrf = true;\n      return 0L;\n    }\n    lockCompactor();\n    try {\n      if (this.haveRecoveredDrf && !getHasDeletes())\n        return 0L; // do this while holding lock\n      if (!this.haveRecoveredDrf) {\n        this.haveRecoveredDrf = true;\n      }\n      logger.info(\"Recovering {} {} for disk store {}.\",\n          new Object[] {toString(), drfFile.getAbsolutePath(), getParent().getName()});\n      this.recoverDelEntryId = DiskStoreImpl.INVALID_ID;\n      boolean readLastRecord = true;\n      CountingDataInputStream dis = null;\n      try {\n        int recordCount = 0;\n        boolean foundDiskStoreRecord = false;\n        FileInputStream fis = null;\n        try {\n          fis = new FileInputStream(drfFile);\n          dis = new CountingDataInputStream(new BufferedInputStream(fis, 32 * 1024),\n              drfFile.length());\n          boolean endOfLog = false;\n          while (!endOfLog) {\n            if (dis.atEndOfFile()) {\n              endOfLog = true;\n              break;\n            }\n            readLastRecord = false;\n            byte opCode = dis.readByte();\n            if (logger.isTraceEnabled(LogMarker.PERSIST_RECOVERY_VERBOSE)) {\n              logger.trace(LogMarker.PERSIST_RECOVERY_VERBOSE, \"drf byte={} location={}\", opCode,\n                  Long.toHexString(dis.getCount()));\n            }\n            switch (opCode) {\n              case OPLOG_EOF_ID:\n                // we are at the end of the oplog. So we need to back up one byte\n                dis.decrementCount();\n                endOfLog = true;\n                break;\n              case OPLOG_DEL_ENTRY_1ID:\n              case OPLOG_DEL_ENTRY_2ID:\n              case OPLOG_DEL_ENTRY_3ID:\n              case OPLOG_DEL_ENTRY_4ID:\n              case OPLOG_DEL_ENTRY_5ID:\n              case OPLOG_DEL_ENTRY_6ID:\n              case OPLOG_DEL_ENTRY_7ID:\n              case OPLOG_DEL_ENTRY_8ID:\n                readDelEntry(dis, opCode, deletedIds, parent);\n                recordCount++;\n                break;\n              case OPLOG_DISK_STORE_ID:\n                readDiskStoreRecord(dis, this.drf.f);\n                foundDiskStoreRecord = true;\n                recordCount++;\n                break;\n              case OPLOG_MAGIC_SEQ_ID:\n                readOplogMagicSeqRecord(dis, this.drf.f, OPLOG_TYPE.DRF);\n                break;\n              case OPLOG_GEMFIRE_VERSION:\n                readGemfireVersionRecord(dis, this.drf.f);\n                recordCount++;\n                break;\n              case OPLOG_RVV:\n                long idx = dis.getCount();\n                readRVVRecord(dis, this.drf.f, true, latestOplog);\n                recordCount++;\n                break;\n              default:\n                throw new DiskAccessException(\n                    String.format(\"Unknown opCode %s found in disk operation log.\",\n                        opCode),\n                    getParent());\n            }\n            readLastRecord = true;\n            // @todo\n            // if (rgn.isDestroyed()) {\n            // break;\n            // }\n          } // while\n        } finally {\n          if (dis != null) {\n            dis.close();\n          }\n          if (fis != null) {\n            fis.close();\n          }\n        }\n        if (!foundDiskStoreRecord && recordCount > 0) {\n          throw new DiskAccessException(\n              \"The oplog file \\\"\" + this.drf.f + \"\\\" does not belong to the init file \\\"\"\n                  + getParent().getInitFile() + \"\\\". Drf did not contain a disk store id.\",\n              getParent());\n        }\n      } catch (EOFException ignore) {\n        // ignore since a partial record write can be caused by a crash\n      } catch (IOException ex) {\n        getParent().getCancelCriterion().checkCancelInProgress(ex);\n        throw new DiskAccessException(\n            String.format(\"Failed to read file during recovery from %s\",\n                drfFile.getPath()),\n            ex, getParent());\n      } catch (CancelException e) {\n        if (logger.isDebugEnabled()) {\n          logger.debug(\"Oplog::readOplog:Error in recovery as Cache was closed\", e);\n        }\n      } catch (RegionDestroyedException e) {\n        if (logger.isDebugEnabled()) {\n          logger.debug(\"Oplog::readOplog:Error in recovery as Region was destroyed\", e);\n        }\n      }\n      // Add the Oplog size to the Directory Holder which owns this oplog,\n      // so that available space is correctly calculated & stats updated.\n      long byteCount = 0;\n      if (!readLastRecord) {\n        // this means that there was a crash\n        // and hence we should not continue to read\n        // the next oplog\n        this.crashed = true;\n        if (dis != null) {\n          byteCount = dis.getFileLength();\n        }\n      } else {\n        if (dis != null) {\n          byteCount = dis.getCount();\n        }\n      }\n      if (!alreadyRecoveredOnce) {\n        setRecoveredDrfSize(byteCount);\n        this.dirHolder.incrementTotalOplogSize(byteCount);\n      }\n      return byteCount;\n    } finally {\n      unlockCompactor();\n    }\n  }<fim_middle>// function below is long method\n"}