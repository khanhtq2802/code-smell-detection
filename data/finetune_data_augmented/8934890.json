{"text": "<fim_prefix>      case BYTE:\n      case SHORT:\n      case INT:\n      case LONG:\n      case TIMESTAMP:\n        break;\n      default:\n        throw new UDFArgumentTypeException(3, \"Only integers are accepted but \"\n            + parameters[3].getTypeName() + \" was passed as parameter 4.\");\n      }\n    }\n    return new GenericUDAFnGramEvaluator();\n  }\n  /**\n   * A constant-space heuristic to estimate the top-k n-grams.\n   */\n  public static class GenericUDAFnGramEvaluator extends GenericUDAFEvaluator {\n    // For PARTIAL1 and COMPLETE: ObjectInspectors for original data\n    private transient ListObjectInspector outerInputOI;\n    private transient StandardListObjectInspector innerInputOI;\n    private transient PrimitiveObjectInspector inputOI;\n    private transient PrimitiveObjectInspector nOI;\n    private transient PrimitiveObjectInspector kOI;\n    private transient PrimitiveObjectInspector pOI;\n    // For PARTIAL2 and FINAL: ObjectInspectors for partial aggregations\n    private transient ListObjectInspector loi;\n    @Override\n    public ObjectInspector init(Mode m, ObjectInspector[] parameters) throws HiveException {\n      super.init(m, parameters);\n      // Init input object inspectors\n      if (m == Mode.PARTIAL1 || m == Mode.COMPLETE) {\n        outerInputOI = (ListObjectInspector) parameters[0];\n        if(outerInputOI.getListElementObjectInspector().getCategory() ==\n            ObjectInspector.Category.LIST) {\n          // We're dealing with input that is an array of arrays of strings\n          innerInputOI = (StandardListObjectInspector) outerInputOI.getListElementObjectInspector();\n          inputOI = (PrimitiveObjectInspector) innerInputOI.getListElementObjectInspector();\n        } else {\n          // We're dealing with input that is an array of strings\n          inputOI = (PrimitiveObjectInspector) outerInputOI.getListElementObjectInspector();\n          innerInputOI = null;\n        }\n        nOI = (PrimitiveObjectInspector) parameters[1];\n        kOI = (PrimitiveObjectInspector) parameters[2];\n        if(parameters.length == 4) {\n          pOI = (PrimitiveObjectInspector) parameters[3];\n        } else {\n          pOI = null;\n        }\n      } else {\n          // Init the list object inspector for handling partial aggregations\n          loi = (ListObjectInspector) parameters[0];\n      }\n      // Init output object inspectors.\n      //\n      // The return type for a partial aggregation is still a list of strings.\n      //\n      // The return type for FINAL and COMPLETE is a full aggregation result, which is\n      // an array of structures containing the n-gram and its estimated frequency.\n      if (m == Mode.PARTIAL1 || m == Mode.PARTIAL2) {\n        return ObjectInspectorFactory.getStandardListObjectInspector(\n            PrimitiveObjectInspectorFactory.writableStringObjectInspector);\n      } else {\n        // Final return type that goes back to Hive: a list of structs with n-grams and their\n        // estimated frequencies.\n        ArrayList<ObjectInspector> foi = new ArrayList<ObjectInspector>();\n        foi.add(ObjectInspectorFactory.getStandardListObjectInspector(\n                  PrimitiveObjectInspectorFactory.writableStringObjectInspector));\n        foi.add(PrimitiveObjectInspectorFactory.writableDoubleObjectInspector);\n        ArrayList<String> fname = new ArrayList<String>();\n        fname.add(\"ngram\");\n        fname.add(\"estfrequency\");\n        return ObjectInspectorFactory.getStandardListObjectInspector(\n                 ObjectInspectorFactory.getStandardStructObjectInspector(fname, foi) );\n      }\n    }\n    @Override\n    public void merge(AggregationBuffer agg, Object partial) throws HiveException {\n      if(partial == null) {\n        return;\n      }\n      NGramAggBuf myagg = (NGramAggBuf) agg;\n      List partialNGrams = (List) loi.getList(partial);\n      int n = Integer.parseInt(partialNGrams.get(partialNGrams.size()-1).toString());\n      // A value of 0 for n indicates that the mapper processed data that does not meet\n      // filter criteria, so merge() should be NO-OP.\n      if (n == 0) {\n        return;\n      }\n      if(myagg.n > 0 && myagg.n != n) {\n        throw new HiveException(getClass().getSimpleName() + \": mismatch in value for 'n'\"\n            + \", which usually is caused by a non-constant expression. Found '\"+n+\"' and '\"\n            + myagg.n + \"'.\");\n      }\n      myagg.n = n;\n      partialNGrams.remove(partialNGrams.size()-1);\n      myagg.nge.merge(partialNGrams);\n    }\n    @Override\n    public Object terminatePartial(AggregationBuffer agg) throws HiveException {\n      NGramAggBuf myagg = (NGramAggBuf) agg;\n      ArrayList<Text> result = myagg.nge.serialize();\n      result.add(new Text(Integer.toString(myagg.n)));\n      return result;\n    }\n    private void processNgrams(NGramAggBuf agg, ArrayList<String> seq) throws HiveException {\n      for(int i = seq.size()-agg.n; i >= 0; i--) {\n        ArrayList<String> ngram = new ArrayList<String>();\n        for(int j = 0; j < agg.n; j++)  {\n          ngram.add(seq.get(i+j));\n        }\n        agg.nge.add(ngram);\n      }\n    }\n    @Override\n    public void iterate(AggregationBuffer agg, Object[] parameters) throws HiveException {\n      assert (parameters.length == 3 || parameters.length == 4);\n      if(parameters[0] == null || parameters[1] == null || parameters[2] == null) {\n        return;\n      }\n      NGramAggBuf myagg = (NGramAggBuf) agg;\n      // Parse out 'n' and 'k' if we haven't already done so, and while we're at it,\n      // also parse out the precision factor 'pf' if the user has supplied one.\n      if(!myagg.nge.isInitialized()) {\n        int n = PrimitiveObjectInspectorUtils.getInt(parameters[1], nOI);\n        int k = PrimitiveObjectInspectorUtils.getInt(parameters[2], kOI);\n        int pf = 0;\n        if(n < 1) {\n          throw new HiveException(getClass().getSimpleName() + \" needs 'n' to be at least 1, \"\n                                  + \"but you supplied \" + n);\n        }\n        if(k < 1) {\n          throw new HiveException(getClass().getSimpleName() + \" needs 'k' to be at least 1, \"\n                                  + \"but you supplied \" + k);\n        }\n        if(parameters.length == 4) {\n          pf = PrimitiveObjectInspectorUtils.getInt(parameters[3], pOI);\n          if(pf < 1) {\n            throw new HiveException(getClass().getSimpleName() + \" needs 'pf' to be at least 1, \"\n                + \"but you supplied \" + pf);\n          }\n        } else {\n          pf = 1; // placeholder; minimum pf value is enforced in NGramEstimator\n        }\n        // Set the parameters\n        myagg.n = n;\n        myagg.nge.initialize(k, pf, n);\n      }\n      // get the input expression\n      List<Text> outer = (List<Text>) outerInputOI.getList(parameters[0]);\n      if(innerInputOI != null) {\n        // we're dealing with an array of arrays of strings\n        for(int i = 0; i < outer.size(); i++) {\n          List<Text> inner = (List<Text>) innerInputOI.getList(outer.get(i));\n          ArrayList<String> words = new ArrayList<String>();\n          for(int j = 0; j < inner.size(); j++) {\n            String word = PrimitiveObjectInspectorUtils.getString(inner.get(j), inputOI);\n            words.add(word);\n          }\n          // parse out n-grams, update frequency counts\n          processNgrams(myagg, words);\n        }\n      } else {\n        // we're dealing with an array of strings\n        ArrayList<String> words = new ArrayList<String>();\n        for(int i = 0; i < outer.size(); i++) {\n          String word = PrimitiveObjectInspectorUtils.getString(outer.get(i), inputOI);\n          words.add(word);\n        }\n        // parse out n-grams, update frequency counts\n        processNgrams(myagg, words);\n      }\n    }\n    @Override\n    public Object terminate(AggregationBuffer agg) throws HiveException {\n      NGramAggBuf myagg = (NGramAggBuf) agg;\n      return myagg.nge.getNGrams();\n    }\n    // Aggregation buffer methods.\n    static class NGramAggBuf extends AbstractAggregationBuffer {\n      NGramEstimator nge;\n      int n;\n    };\n<fim_suffix>    @Override\n    public AggregationBuffer getNewAggregationBuffer() throws HiveException {\n      NGramAggBuf result = new NGramAggBuf();\n      result.nge = new NGramEstimator();\n      reset(result);\n      return result;\n    }<fim_middle>// function below has no smell\n"}