{"text": "<fim_prefix>\n<fim_suffix>public class ViewUpdateGenerator\n{\n    private final View view;\n    private final int nowInSec;\n    private final TableMetadata baseMetadata;\n    private final DecoratedKey baseDecoratedKey;\n    private final ByteBuffer[] basePartitionKey;\n    private final TableMetadata viewMetadata;\n    private final boolean baseEnforceStrictLiveness;\n    private final Map<DecoratedKey, PartitionUpdate.Builder> updates = new HashMap<>();\n    // Reused internally to build a new entry\n    private final ByteBuffer[] currentViewEntryPartitionKey;\n    private final Row.Builder currentViewEntryBuilder;\n    /**\n     * The type of type update action to perform to the view for a given base table\n     * update.\n     */\n    private enum UpdateAction\n    {\n        NONE,            // There was no view entry and none should be added\n        NEW_ENTRY,       // There was no entry but there is one post-update\n        DELETE_OLD,      // There was an entry but there is nothing after update\n        UPDATE_EXISTING, // There was an entry and the update modifies it\n        SWITCH_ENTRY     // There was an entry and there is still one after update,\n                         // but they are not the same one.\n    }\n    /**\n     * Creates a new {@code ViewUpdateBuilder}.\n     *\n     * @param view the view for which this will be building updates for.\n     * @param basePartitionKey the partition key for the base table partition for which\n     * we'll handle updates for.\n     * @param nowInSec the current time in seconds. Used to decide if data are live or not\n     * and as base reference for new deletions.\n     */\n    public ViewUpdateGenerator(View view, DecoratedKey basePartitionKey, int nowInSec)\n    {\n        this.view = view;\n        this.nowInSec = nowInSec;\n        this.baseMetadata = view.getDefinition().baseTableMetadata();\n        this.baseEnforceStrictLiveness = baseMetadata.enforceStrictLiveness();\n        this.baseDecoratedKey = basePartitionKey;\n        this.basePartitionKey = extractKeyComponents(basePartitionKey, baseMetadata.partitionKeyType);\n        this.viewMetadata = Schema.instance.getTableMetadata(view.getDefinition().metadata.id);\n        this.currentViewEntryPartitionKey = new ByteBuffer[viewMetadata.partitionKeyColumns().size()];\n        this.currentViewEntryBuilder = BTreeRow.sortedBuilder();\n    }\n    private static ByteBuffer[] extractKeyComponents(DecoratedKey partitionKey, AbstractType<?> type)\n    {\n        return type instanceof CompositeType\n             ? ((CompositeType)type).split(partitionKey.getKey())\n             : new ByteBuffer[]{ partitionKey.getKey() };\n    }\n    /**\n     * Adds to this generator the updates to be made to the view given a base table row\n     * before and after an update.\n     *\n     * @param existingBaseRow the base table row as it is before an update.\n     * @param mergedBaseRow the base table row after the update is applied (note that\n     * this is not just the new update, but rather the resulting row).\n     */\n    public void addBaseTableUpdate(Row existingBaseRow, Row mergedBaseRow)\n    {\n        switch (updateAction(existingBaseRow, mergedBaseRow))\n        {\n            case NONE:\n                return;\n            case NEW_ENTRY:\n                createEntry(mergedBaseRow);\n                return;\n            case DELETE_OLD:\n                deleteOldEntry(existingBaseRow, mergedBaseRow);\n                return;\n            case UPDATE_EXISTING:\n                updateEntry(existingBaseRow, mergedBaseRow);\n                return;\n            case SWITCH_ENTRY:\n                createEntry(mergedBaseRow);\n                deleteOldEntry(existingBaseRow, mergedBaseRow);\n                return;\n        }\n    }\n    /**\n     * Returns the updates that needs to be done to the view given the base table updates\n     * passed to {@link #addBaseTableUpdate}.\n     *\n     * @return the updates to do to the view.\n     */\n    public Collection<PartitionUpdate> generateViewUpdates()\n    {\n        return updates.values().stream().map(PartitionUpdate.Builder::build).collect(Collectors.toList());\n    }\n    /**\n     * Clears the current state so that the generator may be reused.\n     */\n    public void clear()\n    {\n        updates.clear();\n    }\n    /**\n     * Compute which type of action needs to be performed to the view for a base table row\n     * before and after an update.\n     */\n    private UpdateAction updateAction(Row existingBaseRow, Row mergedBaseRow)\n    {\n        // Having existing empty is useful, it just means we'll insert a brand new entry for mergedBaseRow,\n        // but if we have no update at all, we shouldn't get there.\n        assert !mergedBaseRow.isEmpty();\n        // Note that none of the base PK columns will differ since we're intrinsically dealing\n        // with the same base row. So we have to check 3 things:\n        //   1) that the clustering doesn't have a null, which can happen for compact tables. If that's the case,\n        //      there is no corresponding entries.\n        //   2) if there is a column not part of the base PK in the view PK, whether it is changed by the update.\n        //   3) whether mergedBaseRow actually match the view SELECT filter\n        if (baseMetadata.isCompactTable())\n        {\n            Clustering clustering = mergedBaseRow.clustering();\n            for (int i = 0; i < clustering.size(); i++)\n            {\n                if (clustering.get(i) == null)\n                    return UpdateAction.NONE;\n            }\n        }\n        assert view.baseNonPKColumnsInViewPK.size() <= 1 : \"We currently only support one base non-PK column in the view PK\";\n        if (view.baseNonPKColumnsInViewPK.isEmpty())\n        {\n            // The view entry is necessarily the same pre and post update.\n            // Note that we allow existingBaseRow to be null and treat it as empty (see MultiViewUpdateBuilder.generateViewsMutations).\n            boolean existingHasLiveData = existingBaseRow != null && existingBaseRow.hasLiveData(nowInSec, baseEnforceStrictLiveness);\n            boolean mergedHasLiveData = mergedBaseRow.hasLiveData(nowInSec, baseEnforceStrictLiveness);\n            return existingHasLiveData\n                 ? (mergedHasLiveData ? UpdateAction.UPDATE_EXISTING : UpdateAction.DELETE_OLD)\n                 : (mergedHasLiveData ? UpdateAction.NEW_ENTRY : UpdateAction.NONE);\n        }\n        ColumnMetadata baseColumn = view.baseNonPKColumnsInViewPK.get(0);\n        assert !baseColumn.isComplex() : \"A complex column couldn't be part of the view PK\";\n        Cell before = existingBaseRow == null ? null : existingBaseRow.getCell(baseColumn);\n        Cell after = mergedBaseRow.getCell(baseColumn);\n        // If the update didn't modified this column, the cells will be the same object so it's worth checking\n        if (before == after)\n            return isLive(before) ? UpdateAction.UPDATE_EXISTING : UpdateAction.NONE;\n        if (!isLive(before))\n            return isLive(after) ? UpdateAction.NEW_ENTRY : UpdateAction.NONE;\n        if (!isLive(after))\n        {\n            return UpdateAction.DELETE_OLD;\n        }\n        return baseColumn.cellValueType().compare(before.value(), after.value()) == 0\n             ? UpdateAction.UPDATE_EXISTING\n             : UpdateAction.SWITCH_ENTRY;\n    }\n    private boolean matchesViewFilter(Row baseRow)\n    {\n        return view.matchesViewFilter(baseDecoratedKey, baseRow, nowInSec);\n    }\n    private boolean isLive(Cell cell)\n    {\n        return cell != null && cell.isLive(nowInSec);\n    }\n    /**\n     * Creates a view entry corresponding to the provided base row.\n     * <p>\n     * This method checks that the base row does match the view filter before applying it.\n     */\n    private void createEntry(Row baseRow)\n    {\n        // Before create a new entry, make sure it matches the view filter\n        if (!matchesViewFilter(baseRow))\n            return;\n        startNewUpdate(baseRow);\n        currentViewEntryBuilder.addPrimaryKeyLivenessInfo(computeLivenessInfoForEntry(baseRow));\n        currentViewEntryBuilder.addRowDeletion(baseRow.deletion());\n        for (ColumnData data : baseRow)\n        {\n            ColumnMetadata viewColumn = view.getViewColumn(data.column());\n            // If that base table column is not denormalized in the view, we had nothing to do.\n            // Alose, if it's part of the view PK it's already been taken into account in the clustering.\n            if (viewColumn == null || viewColumn.isPrimaryKeyColumn())\n                continue;\n            addColumnData(viewColumn, data);\n        }\n        submitUpdate();\n    }\n    /**\n     * Creates the updates to apply to the existing view entry given the base table row before\n     * and after the update, assuming that the update hasn't changed to which view entry the\n     * row correspond (that is, we know the columns composing the view PK haven't changed).\n     * <p>\n     * This method checks that the base row (before and after) does match the view filter before\n     * applying anything.\n     */<fim_middle>// class below has no smell\n"}