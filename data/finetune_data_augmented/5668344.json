{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.streams.facebook.provider.pagefeed;\n\nimport org.apache.streams.core.StreamsDatum;\nimport org.apache.streams.facebook.FacebookConfiguration;\nimport org.apache.streams.facebook.IdConfig;\nimport org.apache.streams.facebook.provider.FacebookDataCollector;\nimport org.apache.streams.jackson.StreamsJacksonMapper;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport facebook4j.FacebookException;\nimport facebook4j.Paging;\nimport facebook4j.Post;\nimport facebook4j.Reading;\nimport facebook4j.ResponseList;\nimport facebook4j.json.DataObjectFactory;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.concurrent.BlockingQueue;\n\n/**\n * Collects the page feed data from public Facebook pages.\n */\n<fim_suffix>public class FacebookPageFeedDataCollector extends FacebookDataCollector {\n\n  private static final Logger LOGGER = LoggerFactory.getLogger(FacebookPageFeedDataCollector.class);\n  private static final int MAX_ATTEMPTS = 5;\n  private static final ObjectMapper MAPPER = StreamsJacksonMapper.getInstance();\n  private static final int LIMIT = 100;\n\n  public FacebookPageFeedDataCollector(BlockingQueue<StreamsDatum> queue, FacebookConfiguration configuration) {\n    super(configuration, queue);\n  }\n\n  @Override\n  protected void getData(IdConfig id) throws Exception {\n    boolean exit = false;\n\n    ResponseList<Post> facebookPosts = getPosts(id.getId());\n    LOGGER.debug(\"Post received : {}\", facebookPosts.size());\n    backOff.reset();\n    do {\n      for (Post post : facebookPosts) {\n        if (id.getBeforeDate() != null && id.getAfterDate() != null) {\n          if (id.getBeforeDate().isAfter(post.getCreatedTime().getTime())\n              && id.getAfterDate().isBefore(post.getCreatedTime().getTime())) {\n            super.outputData(MAPPER.readValue(DataObjectFactory.getRawJSON(post), org.apache.streams.facebook.Post.class), post.getId());\n\n          }\n        } else if (id.getBeforeDate() != null && id.getBeforeDate().isAfter(post.getCreatedTime().getTime())) {\n          super.outputData(MAPPER.readValue(DataObjectFactory.getRawJSON(post), org.apache.streams.facebook.Post.class), post.getId());\n        } else if (id.getAfterDate() != null && id.getAfterDate().isBefore(post.getCreatedTime().getTime())) {\n          super.outputData(MAPPER.readValue(DataObjectFactory.getRawJSON(post), org.apache.streams.facebook.Post.class), post.getId());\n        } else if (id.getBeforeDate() == null && id.getAfterDate() == null) {\n          super.outputData(MAPPER.readValue(DataObjectFactory.getRawJSON(post), org.apache.streams.facebook.Post.class), post.getId());\n        } else {\n          exit = true;\n          LOGGER.debug(\"Breaking on post, {}, with createdAtDate {}\", post.getId(), post.getCreatedTime());\n          break;\n        }\n      }\n      if (facebookPosts.getPaging() != null && !exit) {\n        LOGGER.debug(\"Paging. . .\");\n        facebookPosts = getPosts(facebookPosts.getPaging());\n        backOff.reset();\n        LOGGER.debug(\"Paging received {} posts*\", facebookPosts.size());\n      } else {\n        LOGGER.debug(\"No more paging.\");\n        facebookPosts = null;\n      }\n    }\n    while (facebookPosts != null && facebookPosts.size() != 0);\n\n  }\n\n  private ResponseList<Post> getPosts(Paging<Post> paging) throws Exception {\n    return getPosts(null, paging);\n  }\n\n  private ResponseList<Post> getPosts(String pageId) throws Exception {\n    return getPosts(pageId, null);\n  }\n\n  /**\n   * Queries facebook.  Attempts requests up to 5 times and backs off on each facebook exception.\n   * @param pageId pageId\n   * @param paging paging\n   * @return ResponseList of $link{facebook4j.Post}\n   * @throws Exception Exception\n   */\n  private ResponseList<Post> getPosts(String pageId, Paging<Post> paging) throws Exception {\n    int attempt = 0;\n    while (attempt < MAX_ATTEMPTS) {\n      ++attempt;\n      try {\n        if (pageId != null) {\n          Reading reading = new Reading();\n          reading.limit(LIMIT);\n          return getNextFacebookClient().getPosts(pageId, reading);\n        } else {\n          return getNextFacebookClient().fetchNext(paging);\n        }\n      } catch (FacebookException fe) {\n        LOGGER.error(\"Facebook returned an exception : {}\", fe);\n        LOGGER.error(\"Facebook returned an exception while trying to get feed for page, {} : {}\", pageId, fe.getMessage());\n        //TODO Rate limit exceptions with facebook4j unclear http://facebook4j.org/oldjavadocs/1.1.12-2.0.0/2.0.0/index.html?facebook4j/internal/http/HttpResponseCode.html\n        // back off at all exceptions until figured out.\n        int errorCode = fe.getErrorCode();\n\n        //Some sort of rate limiting\n        if (errorCode == 17 || errorCode == 4 || errorCode == 341) {\n          super.backOff.backOff();\n        }\n      }\n    }\n    throw new Exception(\"Failed to get data from facebook after \" + MAX_ATTEMPTS);\n  }\n}<fim_middle>// class below is blob\n"}