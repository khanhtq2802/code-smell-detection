{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.nifi.controller.queue.clustered.server;\n\nimport org.apache.nifi.engine.FlowEngine;\nimport org.apache.nifi.events.EventReporter;\nimport org.apache.nifi.reporting.Severity;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLServerSocket;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.SocketTimeoutException;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.TimeUnit;\n\n\n<fim_suffix>public class ConnectionLoadBalanceServer {\n    private static final Logger logger = LoggerFactory.getLogger(ConnectionLoadBalanceServer.class);\n\n    private final String hostname;\n    private final int port;\n    private final SSLContext sslContext;\n    private final ExecutorService threadPool;\n    private final LoadBalanceProtocol loadBalanceProtocol;\n    private final int connectionTimeoutMillis;\n    private final int numThreads;\n    private final EventReporter eventReporter;\n\n    private volatile Set<CommunicateAction> communicationActions = Collections.emptySet();\n    private final BlockingQueue<Socket> connectionQueue = new LinkedBlockingQueue<>();\n\n    private volatile AcceptConnection acceptConnection;\n    private volatile ServerSocket serverSocket;\n    private volatile boolean stopped = true;\n\n    public ConnectionLoadBalanceServer(final String hostname, final int port, final SSLContext sslContext, final int numThreads, final LoadBalanceProtocol loadBalanceProtocol,\n                                       final EventReporter eventReporter, final int connectionTimeoutMillis) {\n        this.hostname = hostname;\n        this.port = port;\n        this.sslContext = sslContext;\n        this.loadBalanceProtocol = loadBalanceProtocol;\n        this.connectionTimeoutMillis = connectionTimeoutMillis;\n        this.numThreads = numThreads;\n        this.eventReporter = eventReporter;\n\n        threadPool = new FlowEngine(numThreads, \"Load Balance Server\");\n    }\n\n    public void start() throws IOException {\n        if (!stopped) {\n            return;\n        }\n\n        stopped = false;\n        if (serverSocket != null) {\n            return;\n        }\n\n        try {\n            serverSocket = createServerSocket();\n        } catch (final Exception e) {\n            throw new IOException(\"Could not begin listening for incoming connections in order to load balance data across the cluster. Please verify the values of the \" +\n                    \"'nifi.cluster.load.balance.port' and 'nifi.cluster.load.balance.host' properties as well as the 'nifi.security.*' properties\", e);\n        }\n\n        final Set<CommunicateAction> actions = new HashSet<>(numThreads);\n        for (int i=0; i < numThreads; i++) {\n            final CommunicateAction action = new CommunicateAction(loadBalanceProtocol);\n            actions.add(action);\n            threadPool.submit(action);\n        }\n\n        this.communicationActions = actions;\n\n        acceptConnection = new AcceptConnection(serverSocket);\n        final Thread receiveConnectionThread = new Thread(acceptConnection);\n        receiveConnectionThread.setName(\"Receive Queue Load-Balancing Connections\");\n        receiveConnectionThread.start();\n    }\n\n    public int getPort() {\n        return serverSocket.getLocalPort();\n    }\n\n    public void stop() {\n        stopped = false;\n        threadPool.shutdown();\n\n        if (acceptConnection != null) {\n            acceptConnection.stop();\n        }\n\n        communicationActions.forEach(CommunicateAction::stop);\n\n        Socket socket;\n        while ((socket = connectionQueue.poll()) != null) {\n            try {\n                socket.close();\n                logger.info(\"{} Closed connection to {} on Server stop\", this, socket.getRemoteSocketAddress());\n            } catch (final IOException ioe) {\n                logger.warn(\"Failed to properly close socket to \" + socket.getRemoteSocketAddress(), ioe);\n            }\n        }\n    }\n\n    private ServerSocket createServerSocket() throws IOException {\n        final InetAddress inetAddress = hostname == null ? null : InetAddress.getByName(hostname);\n\n        if (sslContext == null) {\n            return new ServerSocket(port, 50, InetAddress.getByName(hostname));\n        } else {\n            final ServerSocket serverSocket = sslContext.getServerSocketFactory().createServerSocket(port, 50, inetAddress);\n            ((SSLServerSocket) serverSocket).setNeedClientAuth(true);\n            return serverSocket;\n        }\n    }\n\n\n    private class CommunicateAction implements Runnable {\n        private final LoadBalanceProtocol loadBalanceProtocol;\n        private volatile boolean stopped = false;\n\n        public CommunicateAction(final LoadBalanceProtocol loadBalanceProtocol) {\n            this.loadBalanceProtocol = loadBalanceProtocol;\n        }\n\n        public void stop() {\n            this.stopped = true;\n        }\n\n        @Override\n        public void run() {\n            String peerDescription = \"<Unknown Client>\";\n\n            while (!stopped) {\n                Socket socket = null;\n                try {\n                    socket = connectionQueue.poll(1, TimeUnit.SECONDS);\n                    if (socket == null) {\n                        continue;\n                    }\n\n                    peerDescription = socket.getRemoteSocketAddress().toString();\n\n                    if (socket.isClosed()) {\n                        logger.debug(\"Connection to Peer {} is closed. Will not attempt to communicate over this Socket.\", peerDescription);\n                        continue;\n                    }\n\n                    logger.debug(\"Receiving FlowFiles from Peer {}\", peerDescription);\n                    loadBalanceProtocol.receiveFlowFiles(socket);\n\n                    if (socket.isConnected()) {\n                        logger.debug(\"Finished receiving FlowFiles from Peer {}. Will recycle connection.\", peerDescription);\n                        connectionQueue.offer(socket);\n                    } else {\n                        logger.debug(\"Finished receiving FlowFiles from Peer {}. Socket is no longer connected so will not recycle connection.\", peerDescription);\n                    }\n                } catch (final Exception e) {\n                    if (socket != null) {\n                        try {\n                            socket.close();\n                        } catch (final IOException ioe) {\n                            e.addSuppressed(ioe);\n                        }\n                    }\n\n                    logger.error(\"Failed to communicate with Peer {}\", peerDescription, e);\n                    eventReporter.reportEvent(Severity.ERROR, \"Load Balanced Connection\", \"Failed to receive FlowFiles for Load Balancing due to \" + e);\n                }\n            }\n\n            logger.info(\"Connection Load Balance Server shutdown. Will no longer handle incoming requests.\");\n        }\n    }\n\n\n    private class AcceptConnection implements Runnable {\n        private final ServerSocket serverSocket;\n        private volatile boolean stopped = false;\n\n        public AcceptConnection(final ServerSocket serverSocket) {\n            this.serverSocket = serverSocket;\n        }\n\n        public void stop() {\n            stopped = true;\n        }\n\n        @Override\n        public void run() {\n            try {\n                serverSocket.setSoTimeout(1000);\n            } catch (final Exception e) {\n                logger.error(\"Failed to set soTimeout on Server Socket for Load Balancing data across cluster\", e);\n            }\n\n            while (!stopped) {\n                try {\n                    final Socket socket;\n                    try {\n                        socket = serverSocket.accept();\n                    } catch (final SocketTimeoutException ste) {\n                        continue;\n                    }\n\n                    socket.setSoTimeout(connectionTimeoutMillis);\n                    connectionQueue.offer(socket);\n                } catch (final Exception e) {\n                    logger.error(\"{} Failed to accept connection from other node in cluster\", ConnectionLoadBalanceServer.this, e);\n                }\n            }\n\n            try {\n                serverSocket.close();\n            } catch (final Exception e) {\n                logger.warn(\"Failed to properly shutdown Server Socket for Load Balancing\", e);\n            }\n        }\n    }\n\n    @Override\n    public String toString() {\n        return \"ConnectionLoadBalanceServer[hostname=\" + hostname + \", port=\" + port + \", secure=\" + (sslContext != null) + \"]\";\n    }\n}<fim_middle>// class below has no smell\n"}