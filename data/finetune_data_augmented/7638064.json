{"text": "<fim_prefix>import org.springframework.ide.eclipse.editor.support.yaml.ast.NodeUtil;\nimport org.springframework.ide.eclipse.editor.support.yaml.ast.YamlFileAST;\nimport org.springframework.ide.eclipse.editor.support.yaml.path.YamlPath;\nimport org.springframework.ide.eclipse.editor.support.yaml.path.YamlPathSegment;\nimport org.springframework.ide.eclipse.editor.support.yaml.schema.ASTDynamicSchemaContext;\nimport org.springframework.ide.eclipse.editor.support.yaml.schema.DynamicSchemaContext;\nimport org.springframework.ide.eclipse.editor.support.yaml.schema.YType;\nimport org.springframework.ide.eclipse.editor.support.yaml.schema.YTypeUtil;\nimport org.springframework.ide.eclipse.editor.support.yaml.schema.YTypedProperty;\nimport org.springframework.ide.eclipse.editor.support.yaml.schema.YamlSchema;\nimport org.springframework.ide.eclipse.editor.support.yaml.schema.constraints.Constraint;\nimport org.springsource.ide.eclipse.commons.core.util.StringUtil;\nimport org.springsource.ide.eclipse.commons.livexp.util.ExceptionUtil;\nimport org.yaml.snakeyaml.nodes.MappingNode;\nimport org.yaml.snakeyaml.nodes.Node;\nimport org.yaml.snakeyaml.nodes.NodeTuple;\nimport org.yaml.snakeyaml.nodes.ScalarNode;\nimport org.yaml.snakeyaml.nodes.SequenceNode;\npublic class SchemaBasedYamlASTReconciler implements YamlASTReconciler {\n\tprivate final IProblemCollector problems;\n\tprivate final YamlSchema schema;\n\tprivate final YTypeUtil typeUtil;\n\tprivate List<Runnable> delayedConstraints = new ArrayList<>();\n\t// keeps track of dynamic constraints discovered during reconciler walk\n\t// the constraints are validated at the end of the walk rather than during the walk.\n\t// This facilitates constraints that depend on, for example, the contents of the ast type cache being\n\t// populated prior to checking.\n\tpublic SchemaBasedYamlASTReconciler(IProblemCollector problems, YamlSchema schema) {\n\t\tthis.problems = new DuplicateFilterProblemCollector(problems);\n\t\tthis.schema = schema;\n\t\tthis.typeUtil = schema.getTypeUtil();\n\t}\n\t@Override\n\tpublic void reconcile(YamlFileAST ast, IProgressMonitor mon) {\n\t\tList<Node> nodes = ast.getNodes();\n\t\tif (nodes!=null && !nodes.isEmpty()) {\n\t\t\tmon.beginTask(\"Reconcile\", nodes.size());\n\t\t\ttry {\n\t\t\t\tif (nodes!=null && !nodes.isEmpty()) {\n\t\t\t\t\tfor (int i = 0; i < nodes.size(); i++) {\n\t\t\t\t\t\tNode node = nodes.get(i);\n\t\t\t\t\t\treconcile(ast, new YamlPath(YamlPathSegment.valueAt(i)), /*parent*/null, node, schema.getTopLevelType());\n\t\t\t\t\t\tmon.worked(1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tverifyDelayedConstraints();\n\t\t\t\tmon.done();\n\t\t\t}\n\t\t}\n\t}\n\tprivate void reconcile(YamlFileAST ast, YamlPath path, Node parent, Node node, YType type) {\n\t\tif (type!=null) {\n\t\t\tDynamicSchemaContext schemaContext = new ASTDynamicSchemaContext(ast, path, node);\n//\t\t\ttype = typeUtil.inferMoreSpecificType(type, schemaContext);\n//\t\t\tif (typeCollector!=null) {\n//\t\t\t\ttypeCollector.accept(node, type);\n//\t\t\t}\n\t\t\tcheckConstraints(parent, node, type, schemaContext);\n\t\t\tswitch (node.getNodeId()) {\n\t\t\tcase mapping:\n\t\t\t\tMappingNode map = (MappingNode) node;\n\t\t\t\tif (typeUtil.isMap(type)) {\n\t\t\t\t\tfor (NodeTuple entry : map.getValue()) {\n\t\t\t\t\t\tString key = NodeUtil.asScalar(entry.getKeyNode());\n\t\t\t\t\t\treconcile(ast, keyAt(path, key), map, entry.getKeyNode(), typeUtil.getKeyType(type));\n\t\t\t\t\t\treconcile(ast, valueAt(path, key), map, entry.getValueNode(), typeUtil.getDomainType(type));\n\t\t\t\t\t}\n\t\t\t\t} else if (typeUtil.isBean(type)) {\n\t\t\t\t\tMap<String, YTypedProperty> beanProperties = typeUtil.getPropertiesMap(type);\n\t\t\t\t\tfor (NodeTuple entry : map.getValue()) {\n\t\t\t\t\t\tNode keyNode = entry.getKeyNode();\n\t\t\t\t\t\tString key = NodeUtil.asScalar(keyNode);\n\t\t\t\t\t\tif (key==null) {\n\t\t\t\t\t\t\texpectScalar(node);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tYTypedProperty prop = beanProperties.get(key);\n\t\t\t\t\t\t\tif (prop==null) {\n\t\t\t\t\t\t\t\tunknownBeanProperty(keyNode, type, key);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (prop.isDeprecated()) {\n\t\t\t\t\t\t\t\t\tString msg = prop.getDeprecationMessage();\n\t\t\t\t\t\t\t\t\tif (StringUtil.hasText(msg)) {\n\t\t\t\t\t\t\t\t\t\tproblems.accept(YamlSchemaProblems.deprecatedProperty(msg, keyNode));\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tproblems.accept(YamlSchemaProblems.deprecatedProperty(keyNode, type, prop));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treconcile(ast, valueAt(path, key), map, entry.getValueNode(), prop.getType());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\texpectTypeButFoundMap(type, node);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase sequence:\n\t\t\t\tSequenceNode seq = (SequenceNode) node;\n\t\t\t\tif (typeUtil.isSequencable(type)) {\n\t\t\t\t\tfor (int i = 0; i < seq.getValue().size(); i++) {\n\t\t\t\t\t\tNode el = seq.getValue().get(i);\n\t\t\t\t\t\treconcile(ast, valueAt(path, i), seq, el, typeUtil.getDomainType(type));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\texpectTypeButFoundSequence(type, node);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase scalar:\n\t\t\t\tif (typeUtil.isAtomic(type)) {\n\t\t\t\t\tValueParser parser = typeUtil.getValueParser(type);\n\t\t\t\t\tif (parser!=null) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tString value = NodeUtil.asScalar(node);\n\t\t\t\t\t\t\tif (value!=null) {\n\t\t\t\t\t\t\t\tparser.parse(value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t\tProblemType problemType = getProblemType(e);\n\t\t\t\t\t\t\tDocumentRegion region = getRegion(e, ast.getDocument(), node);\n\t\t\t\t\t\t\tString msg = getMessage(e);\n\t\t\t\t\t\t\tvalueParseError(type, region, msg, problemType, getValueReplacement(e));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\texpectTypeButFoundScalar(type, node);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t// other stuff we don't check\n\t\t\t}\n\t\t}\n\t}\n\tprotected ReplacementQuickfix getValueReplacement(Exception _e) {\n\t\tif (_e instanceof ReconcileException) {\n\t\t\tReconcileException e = (ReconcileException) _e;\n\t\t\treturn e.getReplacement();\n\t\t}\n\t\treturn null;\n\t}\n\tprotected DocumentRegion getRegion(Exception e, IDocument doc, Node node) {\n\t\tDocumentRegion region = new DocumentRegion(doc, node.getStartMark().getIndex(), node.getEndMark().getIndex());\n\t\tif (e instanceof ValueParseException) {\n\t\t\tValueParseException parseException = (ValueParseException) e;\n\t\t\tint start = parseException.getStartIndex() >= 0\n\t\t\t\t\t? Math.min(node.getStartMark().getIndex() + parseException.getStartIndex(),\n\t\t\t\t\t\t\tnode.getEndMark().getIndex())\n\t\t\t\t\t: node.getStartMark().getIndex();\n\t\t\tint end = parseException.getEndIndex() >= 0\n\t\t\t\t\t? Math.min(node.getStartMark().getIndex() + parseException.getEndIndex(),\n\t\t\t\t\t\t\tnode.getEndMark().getIndex())\n\t\t\t\t\t: node.getEndMark().getIndex();\n\t\t\tregion = new DocumentRegion(doc, start, end);\n\t\t}\n\t\treturn region;\n\t}\n<fim_suffix>\tprivate String getMessage(Exception _e) {\n\t\tThrowable e = ExceptionUtil.getDeepestCause(_e);\n\t\t// If value parse exception, do not append any additional information\n\t\tif (e instanceof ValueParseException) {\n\t\t\tString msg = e.getMessage();\n\t\t\tif (StringUtil.hasText(msg)) {\n\t\t\t\treturn msg;\n\t\t\t} else {\n\t\t\t\treturn \"An error occurred: \" + getSimpleError(e);\n\t\t\t}\n\t\t} else {\n\t\t\treturn ExceptionUtil.getMessage(e);\n\t\t}\n\t}<fim_middle>// function below has no smell\n"}