{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.hadoop.hdfs.server.namenode;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport org.apache.hadoop.fs.permission.FsPermission;\nimport org.apache.hadoop.fs.permission.PermissionStatus;\nimport org.apache.hadoop.hdfs.protocol.QuotaExceededException;\nimport org.apache.hadoop.hdfs.server.namenode.snapshot.DirectoryWithSnapshotFeature;\nimport org.apache.hadoop.hdfs.server.namenode.snapshot.Snapshot;\nimport org.apache.hadoop.hdfs.server.namenode.XAttrFeature;\nimport com.google.common.base.Preconditions;\n/**\n * An anonymous reference to an inode.\n *\n * This class and its subclasses are used to support multiple access paths.\n * A file/directory may have multiple access paths when it is stored in some\n * snapshots and it is renamed/moved to other locations.\n * \n * For example,\n * (1) Suppose we have /abc/foo, say the inode of foo is inode(id=1000,name=foo)\n * (2) create snapshot s0 for /abc\n * (3) mv /abc/foo /xyz/bar, i.e. inode(id=1000,name=...) is renamed from \"foo\"\n *     to \"bar\" and its parent becomes /xyz.\n * \n * Then, /xyz/bar and /abc/.snapshot/s0/foo are two different access paths to\n * the same inode, inode(id=1000,name=bar).\n *\n * With references, we have the following\n * - /abc has a child ref(id=1001,name=foo).\n * - /xyz has a child ref(id=1002) \n * - Both ref(id=1001,name=foo) and ref(id=1002) point to another reference,\n *   ref(id=1003,count=2).\n * - Finally, ref(id=1003,count=2) points to inode(id=1000,name=bar).\n * \n * Note 1: For a reference without name, e.g. ref(id=1002), it uses the name\n *         of the referred inode.\n * Note 2: getParent() always returns the parent in the current state, e.g.\n *         inode(id=1000,name=bar).getParent() returns /xyz but not /abc.\n */\npublic abstract class INodeReference extends INode {\n  /**\n   * Try to remove the given reference and then return the reference count.\n   * If the given inode is not a reference, return -1;\n   */\n  public static int tryRemoveReference(INode inode) {\n    if (!inode.isReference()) {\n      return -1;\n    }\n    return removeReference(inode.asReference());\n  }\n  /**\n   * Remove the given reference and then return the reference count.\n   * If the referred inode is not a WithCount, return -1;\n   */\n  private static int removeReference(INodeReference ref) {\n    final INode referred = ref.getReferredINode();\n    if (!(referred instanceof WithCount)) {\n      return -1;\n    }\n    WithCount wc = (WithCount) referred;\n    wc.removeReference(ref);\n    return wc.getReferenceCount();\n  }\n  /**\n   * When destroying a reference node (WithName or DstReference), we call this\n   * method to identify the snapshot which is the latest snapshot before the\n   * reference node's creation. \n   */\n  static int getPriorSnapshot(INodeReference ref) {\n    WithCount wc = (WithCount) ref.getReferredINode();\n    WithName wn = null;\n    if (ref instanceof DstReference) {\n      wn = wc.getLastWithName();\n    } else if (ref instanceof WithName) {\n      wn = wc.getPriorWithName((WithName) ref);\n    }\n    if (wn != null) {\n      INode referred = wc.getReferredINode();\n      if (referred.isFile() && referred.asFile().isWithSnapshot()) {\n        return referred.asFile().getDiffs().getPrior(wn.lastSnapshotId);\n      } else if (referred.isDirectory()) {\n        DirectoryWithSnapshotFeature sf = referred.asDirectory()\n            .getDirectoryWithSnapshotFeature();\n        if (sf != null) {\n          return sf.getDiffs().getPrior(wn.lastSnapshotId);\n        }\n      }\n    }\n    return Snapshot.NO_SNAPSHOT_ID;\n  }\n  private INode referred;\n  public INodeReference(INode parent, INode referred) {\n    super(parent);\n    this.referred = referred;\n  }\n  public final INode getReferredINode() {\n    return referred;\n  }\n  public final void setReferredINode(INode referred) {\n    this.referred = referred;\n  }\n  @Override\n  public final boolean isReference() {\n    return true;\n  }\n  @Override\n  public final INodeReference asReference() {\n    return this;\n  }\n  @Override\n  public final boolean isFile() {\n    return referred.isFile();\n  }\n  @Override\n  public final INodeFile asFile() {\n    return referred.asFile();\n  }\n  @Override\n  public final boolean isDirectory() {\n    return referred.isDirectory();\n  }\n  @Override\n  public final INodeDirectory asDirectory() {\n    return referred.asDirectory();\n  }\n  @Override\n  public final boolean isSymlink() {\n    return referred.isSymlink();\n  }\n  @Override\n  public final INodeSymlink asSymlink() {\n    return referred.asSymlink();\n  }\n  @Override\n  public byte[] getLocalNameBytes() {\n    return referred.getLocalNameBytes();\n  }\n  @Override\n  public void setLocalName(byte[] name) {\n    referred.setLocalName(name);\n  }\n  @Override\n  public final long getId() {\n    return referred.getId();\n  }\n  @Override\n  public final PermissionStatus getPermissionStatus(int snapshotId) {\n    return referred.getPermissionStatus(snapshotId);\n  }\n  @Override\n  public final String getUserName(int snapshotId) {\n    return referred.getUserName(snapshotId);\n  }\n  @Override\n  final void setUser(String user) {\n    referred.setUser(user);\n  }\n  @Override\n  public final String getGroupName(int snapshotId) {\n    return referred.getGroupName(snapshotId);\n  }\n  @Override\n  final void setGroup(String group) {\n    referred.setGroup(group);\n  }\n  @Override\n  public final FsPermission getFsPermission(int snapshotId) {\n    return referred.getFsPermission(snapshotId);\n  }\n  @Override\n  final AclFeature getAclFeature(int snapshotId) {\n    return referred.getAclFeature(snapshotId);\n  }\n  @Override\n  final void addAclFeature(AclFeature aclFeature) {\n    referred.addAclFeature(aclFeature);\n  }\n  @Override\n  final void removeAclFeature() {\n    referred.removeAclFeature();\n  }\n  @Override\n  final XAttrFeature getXAttrFeature(int snapshotId) {\n    return referred.getXAttrFeature(snapshotId);\n  }\n  @Override\n  final void addXAttrFeature(XAttrFeature xAttrFeature) {\n    referred.addXAttrFeature(xAttrFeature);\n  }\n  @Override\n  final void removeXAttrFeature() {\n    referred.removeXAttrFeature();\n  }\n<fim_suffix>  @Override\n  public final short getFsPermissionShort() {\n    return referred.getFsPermissionShort();\n  }\n  @Override\n  void setPermission(FsPermission permission) {\n    referred.setPermission(permission);\n  }\n  @Override\n  public long getPermissionLong() {\n    return referred.getPermissionLong();\n  }\n  @Override\n  public final long getModificationTime(int snapshotId) {\n    return referred.getModificationTime(snapshotId);\n  }\n  @Override\n  public final INode updateModificationTime(long mtime, int latestSnapshotId) \n      throws QuotaExceededException {\n    return referred.updateModificationTime(mtime, latestSnapshotId);\n  }\n  @Override\n  public final void setModificationTime(long modificationTime) {\n    referred.setModificationTime(modificationTime);\n  }\n  @Override<fim_middle>// function below has no smell\n"}