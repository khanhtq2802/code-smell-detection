{"text": "<fim_prefix>                || \"CFB\".equalsIgnoreCase(algorithmMode))\n            return new BaseEncryptionManager(algorithm,\n                    new SecretKeySpec(encryptionKey, algorithmName),\n                    providerName);\n//        else if(\"ECB\".equalsIgnoreCase(algorithmMode)) {\n            // Note: ECB is not an appropriate mode for secure communications.\n//            return new ECBEncryptionManager(algorithm, new SecretKeySpec(encryptionKey, algorithmName), providerName);\n        else\n            throw new IllegalArgumentException(sm.getString(\"encryptInterceptor.algorithm.unsupported-mode\", algorithmMode));\n    }\n    private static class BaseEncryptionManager {\n        /**\n         * The fully-specified algorithm e.g. AES/CBC/PKCS5Padding.\n         */\n        private final String algorithm;\n        /**\n         * The block size of the cipher.\n         */\n        private final int blockSize;\n        /**\n         * The cryptographic provider name.\n         */\n        private final String providerName;\n        /**\n         * The secret key to use for encryption and decryption operations.\n         */\n        private final SecretKeySpec secretKey;\n        /**\n         * A pool of Cipher objects. Ciphers are expensive to create, but not\n         * to re-initialize, so we use a pool of them which grows as necessary.\n         */\n        private final ConcurrentLinkedQueue<Cipher> cipherPool;\n        /**\n         * A pool of SecureRandom objects. Each encrypt operation requires access\n         * to a source of randomness. SecureRandom is thread-safe, but sharing a\n         * single instance will likely be a bottleneck.\n         */\n        private final ConcurrentLinkedQueue<SecureRandom> randomPool;\n        public BaseEncryptionManager(String algorithm, SecretKeySpec secretKey, String providerName)\n            throws NoSuchAlgorithmException, NoSuchPaddingException, NoSuchProviderException {\n            this.algorithm = algorithm;\n            this.providerName = providerName;\n            this.secretKey = secretKey;\n            cipherPool = new ConcurrentLinkedQueue<>();\n            Cipher cipher = createCipher();\n            blockSize = cipher.getBlockSize();\n            cipherPool.offer(cipher);\n            randomPool = new ConcurrentLinkedQueue<>();\n        }\n        public void shutdown() {\n            // Individual Cipher and SecureRandom objects need no explicit teardown\n            cipherPool.clear();\n            randomPool.clear();\n        }\n        private String getAlgorithm() {\n            return algorithm;\n        }\n        private SecretKeySpec getSecretKey() {\n            return secretKey;\n        }\n        /**\n         * Gets the size, in bytes, of the initialization vector for the\n         * cipher being used. The IV size is often, but not always, the block\n         * size for the cipher.\n         *\n         * @return The size of the initialization vector for this algorithm.\n         */\n        protected int getIVSize() {\n            return blockSize;\n        }\n        private String getProviderName() {\n            return providerName;\n        }\n        private Cipher createCipher()\n            throws NoSuchAlgorithmException, NoSuchPaddingException, NoSuchProviderException {\n            String providerName = getProviderName();\n            if(null == providerName) {\n                return Cipher.getInstance(getAlgorithm());\n            } else {\n                return Cipher.getInstance(getAlgorithm(), providerName);\n            }\n        }\n        private Cipher getCipher() throws GeneralSecurityException {\n            Cipher cipher = cipherPool.poll();\n            if(null == cipher) {\n                cipher = createCipher();\n            }\n            return cipher;\n        }\n        private void returnCipher(Cipher cipher) {\n            cipherPool.offer(cipher);\n        }\n        private SecureRandom getRandom() {\n            SecureRandom random = randomPool.poll();\n            if(null == random) {\n                random = new SecureRandom();\n            }\n            return random;\n        }\n        private void returnRandom(SecureRandom random) {\n            randomPool.offer(random);\n        }\n        /**\n         * Encrypts the input <code>bytes</code> into two separate byte arrays:\n         * one for the random initialization vector (IV) used for this message,\n         * and the second one containing the actual encrypted payload.\n         *\n         * This method returns a pair of byte arrays instead of a single\n         * concatenated one to reduce the number of byte buffers created\n         * and copied during the whole operation -- including message re-building.\n         *\n         * @param bytes The data to encrypt.\n         *\n         * @return The IV in [0] and the encrypted data in [1].\n         *\n         * @throws GeneralSecurityException If the input data cannot be encrypted.\n         */\n        private byte[][] encrypt(byte[] bytes) throws GeneralSecurityException {\n            Cipher cipher = null;\n            // Always use a random IV For cipher setup.\n            // The recipient doesn't need the (matching) IV because we will always\n            // pre-pad messages with the IV as a nonce.\n            byte[] iv = generateIVBytes();\n            try {\n                cipher = getCipher();\n                cipher.init(Cipher.ENCRYPT_MODE, getSecretKey(), generateIV(iv, 0, getIVSize()));\n                // Prepend the IV to the beginning of the encrypted data\n                byte[][] data = new byte[2][];\n                data[0] = iv;\n                data[1] = cipher.doFinal(bytes);\n                return data;\n            } finally {\n                if(null != cipher)\n                    returnCipher(cipher);\n            }\n        }\n        /**\n         * Decrypts the input <code>bytes</code>.\n         *\n         * @param bytes The data to decrypt.\n         *\n         * @return The decrypted data.\n         *\n         * @throws GeneralSecurityException If the input data cannot be decrypted.\n         */\n        private byte[] decrypt(byte[] bytes) throws GeneralSecurityException {\n            Cipher cipher = null;\n            int ivSize = getIVSize();\n            AlgorithmParameterSpec IV = generateIV(bytes, 0, ivSize);\n            try {\n                cipher = getCipher();\n                cipher.init(Cipher.DECRYPT_MODE, getSecretKey(), IV);\n                // Decrypt remainder of the message.\n                return cipher.doFinal(bytes, ivSize, bytes.length - ivSize);\n            } finally {\n                if(null != cipher)\n                    returnCipher(cipher);\n            }\n        }\n        protected byte[] generateIVBytes() {\n            byte[] ivBytes = new byte[getIVSize()];\n            SecureRandom random = null;\n            try {\n                random = getRandom();\n                // Always use a random IV For cipher setup.\n                // The recipient doesn't need the (matching) IV because we will always\n                // pre-pad messages with the IV as a nonce.\n                random.nextBytes(ivBytes);\n                return ivBytes;\n            } finally {\n                if(null != random)\n                    returnRandom(random);\n            }\n        }\n        protected AlgorithmParameterSpec generateIV(byte[] ivBytes, int offset, int length) {\n            return new IvParameterSpec(ivBytes, offset, length);\n        }\n    }\n    /**\n     * Implements an EncryptionManager for using GCM block cipher modes.\n     *\n     * GCM works a little differently than some of the other block cipher modes\n     * supported by EncryptInterceptor. First of all, it requires a different\n     * kind of AlgorithmParameterSpec object to be used, and second, it\n     * requires a slightly different initialization vector and something called\n     * an \"authentication tag\".\n     *\n     * The choice of IV length can be somewhat arbitrary, but there is consensus\n     * that 96-bit (12-byte) IVs for GCM are the best trade-off between security\n     * and performance. For other block cipher modes, IV length is the same as\n     * the block size.\n     *\n     * The \"authentication tag\" is a computed authentication value based upon\n     * the message and the encryption process. GCM defines these tags as the\n     * number of bits to use for the authentication tag, and it's clear that\n     * the highest number of bits supported 128-bit provide the best security.\n     */\n    private static class GCMEncryptionManager extends BaseEncryptionManager\n    {\n        public GCMEncryptionManager(String algorithm, SecretKeySpec secretKey, String providerName)\n                throws NoSuchAlgorithmException, NoSuchPaddingException, NoSuchProviderException {\n            super(algorithm, secretKey, providerName);\n        }\n        @Override\n        protected int getIVSize() {\n            return 12; // See class javadoc for explanation of this magic number (12)\n        }\n        @Override\n        protected AlgorithmParameterSpec generateIV(byte[] bytes, int offset, int length) {\n            // See class javadoc for explanation of this magic number (128)\n            return new GCMParameterSpec(128, bytes, offset, length);\n        }\n    }\n    @SuppressWarnings(\"unused\")\n    private static class ECBEncryptionManager extends BaseEncryptionManager\n    {\n        public ECBEncryptionManager(String algorithm, SecretKeySpec secretKey, String providerName)\n                throws NoSuchAlgorithmException, NoSuchPaddingException, NoSuchProviderException {\n            super(algorithm, secretKey, providerName);\n        }\n        private static final byte[] EMPTY_IV = new byte[0];\n        @Override\n        protected int getIVSize() {\n            return 0;\n        }\n        @Override\n        protected byte[] generateIVBytes() {\n            return EMPTY_IV;\n        }\n        @Override\n        protected AlgorithmParameterSpec generateIV(byte[] bytes, int offset, int length) {\n            return null;\n        }\n    }\n<fim_suffix>    static class ChannelConfigException\n        extends ChannelException\n    {\n        private static final long serialVersionUID = 1L;\n        public ChannelConfigException(String message) {\n            super(message);\n        }\n    }<fim_middle>// class below has no smell\n"}