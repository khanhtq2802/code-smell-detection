{"text": "<fim_prefix>import org.apache.kylin.metadata.tuple.TupleInfo;\nimport org.apache.kylin.storage.IStorageQuery;\nimport org.apache.kylin.storage.StorageContext;\nimport org.apache.kylin.storage.translate.DerivedFilterTranslator;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Sets;\npublic abstract class GTCubeStorageQueryBase implements IStorageQuery {\n    private static final Logger logger = LoggerFactory.getLogger(GTCubeStorageQueryBase.class);\n    protected CubeInstance cubeInstance;\n    protected CubeDesc cubeDesc;\n    public GTCubeStorageQueryBase(CubeInstance cube) {\n        this.cubeInstance = cube;\n        this.cubeDesc = cube.getDescriptor();\n    }\n    @Override\n    public ITupleIterator search(StorageContext context, SQLDigest sqlDigest, TupleInfo returnTupleInfo) {\n        GTCubeStorageQueryRequest request = getStorageQueryRequest(context, sqlDigest, returnTupleInfo);\n        List<CubeSegmentScanner> scanners = Lists.newArrayList();\n        SegmentPruner segPruner = new SegmentPruner(sqlDigest.filter);\n        for (CubeSegment cubeSeg : segPruner.listSegmentsForQuery(cubeInstance)) {\n            CubeSegmentScanner scanner = new CubeSegmentScanner(cubeSeg, request.getCuboid(), request.getDimensions(), //\n                    request.getGroups(), request.getDynGroups(), request.getDynGroupExprs(), //\n                    request.getMetrics(), request.getDynFuncs(), //\n                    request.getFilter(), request.getHavingFilter(), request.getContext());\n            if (!scanner.isSegmentSkipped())\n                scanners.add(scanner);\n        }\n        if (scanners.isEmpty())\n            return ITupleIterator.EMPTY_TUPLE_ITERATOR;\n        return new SequentialCubeTupleIterator(scanners, request.getCuboid(), request.getDimensions(),\n                request.getDynGroups(), request.getGroups(), request.getMetrics(), returnTupleInfo, request.getContext(), sqlDigest);\n    }\n    public GTCubeStorageQueryRequest getStorageQueryRequest(StorageContext context, SQLDigest sqlDigest,\n            TupleInfo returnTupleInfo) {\n        context.setStorageQuery(this);\n        //cope with queries with no aggregations\n        RawQueryLastHacker.hackNoAggregations(sqlDigest, cubeDesc, returnTupleInfo);\n        // Customized measure taking effect: e.g. allow custom measures to help raw queries\n        notifyBeforeStorageQuery(sqlDigest);\n        Collection<TblColRef> groups = sqlDigest.groupbyColumns;\n        TupleFilter filter = sqlDigest.filter;\n        // build dimension & metrics\n        Set<TblColRef> dimensions = new LinkedHashSet<>();\n        Set<FunctionDesc> metrics = new LinkedHashSet<>();\n        buildDimensionsAndMetrics(sqlDigest, dimensions, metrics);\n        // all dimensions = groups + other(like filter) dimensions\n        Set<TblColRef> otherDims = Sets.newHashSet(dimensions);\n        otherDims.removeAll(groups);\n        // expand derived (xxxD means contains host columns only, derived columns were translated)\n        Set<TblColRef> derivedPostAggregation = Sets.newHashSet();\n        Set<TblColRef> groupsD = expandDerived(groups, derivedPostAggregation);\n        Set<TblColRef> otherDimsD = expandDerived(otherDims, derivedPostAggregation);\n        otherDimsD.removeAll(groupsD);\n        // identify cuboid\n        Set<TblColRef> dimensionsD = new LinkedHashSet<>();\n        dimensionsD.addAll(groupsD);\n        dimensionsD.addAll(otherDimsD);\n        Cuboid cuboid = findCuboid(cubeInstance, dimensionsD, metrics);\n        context.setCuboid(cuboid);\n        // set cuboid to GridTable mapping\n        boolean noDynamicCols;\n        // dynamic dimensions\n        List<TblColRef> dynGroups = Lists.newArrayList(sqlDigest.dynGroupbyColumns.keySet());\n        noDynamicCols = dynGroups.isEmpty();\n        List<TupleExpression> dynGroupExprs = Lists.newArrayListWithExpectedSize(sqlDigest.dynGroupbyColumns.size());\n        for (TblColRef dynGroupCol : dynGroups) {\n            dynGroupExprs.add(sqlDigest.dynGroupbyColumns.get(dynGroupCol));\n        }\n        // dynamic measures\n        List<DynamicFunctionDesc> dynFuncs = sqlDigest.dynAggregations;\n        noDynamicCols = noDynamicCols && dynFuncs.isEmpty();\n        CuboidToGridTableMapping mapping = noDynamicCols ? new CuboidToGridTableMapping(cuboid)\n                : new CuboidToGridTableMappingExt(cuboid, dynGroups, dynFuncs);\n        context.setMapping(mapping);\n        // set whether to aggr at storage\n        Set<TblColRef> singleValuesD = findSingleValueColumns(filter);\n        context.setNeedStorageAggregation(isNeedStorageAggregation(cuboid, groupsD, singleValuesD));\n        // exactAggregation mean: needn't aggregation at storage and query engine both.\n        boolean exactAggregation = isExactAggregation(context, cuboid, groups, otherDimsD, singleValuesD,\n                derivedPostAggregation, sqlDigest.aggregations, sqlDigest.aggrSqlCalls, sqlDigest.groupByExpression);\n        context.setExactAggregation(exactAggregation);\n        // replace derived columns in filter with host columns; columns on loosened condition must be added to group by\n        Set<TblColRef> loosenedColumnD = Sets.newHashSet();\n        Set<TblColRef> filterColumnD = Sets.newHashSet();\n        TupleFilter filterD = translateDerived(filter, loosenedColumnD);\n        groupsD.addAll(loosenedColumnD);\n        TupleFilter.collectColumns(filterD, filterColumnD);\n        context.setFilterMask(getQueryFilterMask(filterColumnD));\n        // set limit push down\n        enableStorageLimitIfPossible(cuboid, groups, dynGroups, derivedPostAggregation, groupsD, filterD,\n                loosenedColumnD, sqlDigest.aggregations, context);\n        // set whether to aggregate results from multiple partitions\n        enableStreamAggregateIfBeneficial(cuboid, groupsD, context);\n        // check query deadline\n        QueryContextFacade.current().checkMillisBeforeDeadline();\n        // push down having clause filter if possible\n        TupleFilter havingFilter = checkHavingCanPushDown(sqlDigest.havingFilter, groupsD, sqlDigest.aggregations,\n                metrics);\n        logger.info(\n                \"Cuboid identified: cube={}, cuboidId={}, groupsD={}, filterD={}, limitPushdown={}, limitLevel={}, storageAggr={}\",\n                cubeInstance.getName(), cuboid.getId(), groupsD, filterColumnD, context.getFinalPushDownLimit(),\n                context.getStorageLimitLevel(), context.isNeedStorageAggregation());\n        return new GTCubeStorageQueryRequest(cuboid, dimensionsD, groupsD, dynGroups, dynGroupExprs, filterColumnD,\n                metrics, dynFuncs, filterD, havingFilter, context);\n    }\n    protected abstract String getGTStorage();\n    protected Cuboid findCuboid(CubeInstance cubeInstance, Set<TblColRef> dimensionsD, Set<FunctionDesc> metrics) {\n        return Cuboid.findCuboid(cubeInstance.getCuboidScheduler(), dimensionsD, metrics);\n    }\n    protected ITupleConverter newCubeTupleConverter(CubeSegment cubeSeg, Cuboid cuboid,\n            Set<TblColRef> selectedDimensions, Set<FunctionDesc> selectedMetrics, int[] gtColIdx, TupleInfo tupleInfo) {\n        return new CubeTupleConverter(cubeSeg, cuboid, selectedDimensions, selectedMetrics, gtColIdx, tupleInfo);\n    }\n    protected void buildDimensionsAndMetrics(SQLDigest sqlDigest, Collection<TblColRef> dimensions,\n            Collection<FunctionDesc> metrics) {\n        for (FunctionDesc func : sqlDigest.aggregations) {\n            if (!func.isDimensionAsMetric() && !FunctionDesc.FUNC_GROUPING.equalsIgnoreCase(func.getExpression())) {\n                // use the FunctionDesc from cube desc as much as possible, that has more info such as HLLC precision\n                metrics.add(findAggrFuncFromCubeDesc(func));\n            }\n        }\n        for (TblColRef column : sqlDigest.allColumns) {\n            // skip measure columns\n            if ((sqlDigest.metricColumns.contains(column) || sqlDigest.rtMetricColumns.contains(column))\n                    && !(sqlDigest.groupbyColumns.contains(column) || sqlDigest.filterColumns.contains(column)\n                            || sqlDigest.rtDimensionColumns.contains(column))) {\n                continue;\n            }\n            dimensions.add(column);\n        }\n    }\n<fim_suffix>    private FunctionDesc findAggrFuncFromCubeDesc(FunctionDesc aggrFunc) {\n        for (MeasureDesc measure : cubeDesc.getMeasures()) {\n            if (measure.getFunction().equals(aggrFunc))\n                return measure.getFunction();\n        }\n        return aggrFunc;\n    }<fim_middle>// function below has no smell\n"}