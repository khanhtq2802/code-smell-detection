{"text": "<fim_prefix>     */\n    @GuardedBy(\"this\")\n    E removeFromChain(E first, E entry) {\n      int newCount = count;\n      E newFirst = entry.getNext();\n      for (E e = first; e != entry; e = e.getNext()) {\n        E next = copyEntry(e, newFirst);\n        if (next != null) {\n          newFirst = next;\n        } else {\n          newCount--;\n        }\n      }\n      this.count = newCount;\n      return newFirst;\n    }\n    /** Removes an entry whose key has been garbage collected. */\n    @CanIgnoreReturnValue\n    boolean reclaimKey(E entry, int hash) {\n      lock();\n      try {\n        int newCount = count - 1;\n        AtomicReferenceArray<E> table = this.table;\n        int index = hash & (table.length() - 1);\n        E first = table.get(index);\n        for (E e = first; e != null; e = e.getNext()) {\n          if (e == entry) {\n            ++modCount;\n            E newFirst = removeFromChain(first, e);\n            newCount = this.count - 1;\n            table.set(index, newFirst);\n            this.count = newCount; // write-volatile\n            return true;\n          }\n        }\n        return false;\n      } finally {\n        unlock();\n      }\n    }\n    /** Removes an entry whose value has been garbage collected. */\n    @CanIgnoreReturnValue\n    boolean reclaimValue(K key, int hash, WeakValueReference<K, V, E> valueReference) {\n      lock();\n      try {\n        int newCount = this.count - 1;\n        AtomicReferenceArray<E> table = this.table;\n        int index = hash & (table.length() - 1);\n        E first = table.get(index);\n        for (E e = first; e != null; e = e.getNext()) {\n          K entryKey = e.getKey();\n          if (e.getHash() == hash\n              && entryKey != null\n              && map.keyEquivalence.equivalent(key, entryKey)) {\n            WeakValueReference<K, V, E> v = ((WeakValueEntry<K, V, E>) e).getValueReference();\n            if (v == valueReference) {\n              ++modCount;\n              E newFirst = removeFromChain(first, e);\n              newCount = this.count - 1;\n              table.set(index, newFirst);\n              this.count = newCount; // write-volatile\n              return true;\n            }\n            return false;\n          }\n        }\n        return false;\n      } finally {\n        unlock();\n      }\n    }\n    /** Clears a value that has not yet been set, and thus does not require count to be modified. */\n    @CanIgnoreReturnValue\n    boolean clearValueForTesting(\n        K key,\n        int hash,\n        WeakValueReference<K, V, ? extends InternalEntry<K, V, ?>> valueReference) {\n      lock();\n      try {\n        AtomicReferenceArray<E> table = this.table;\n        int index = hash & (table.length() - 1);\n        E first = table.get(index);\n        for (E e = first; e != null; e = e.getNext()) {\n          K entryKey = e.getKey();\n          if (e.getHash() == hash\n              && entryKey != null\n              && map.keyEquivalence.equivalent(key, entryKey)) {\n            WeakValueReference<K, V, E> v = ((WeakValueEntry<K, V, E>) e).getValueReference();\n            if (v == valueReference) {\n              E newFirst = removeFromChain(first, e);\n              table.set(index, newFirst);\n              return true;\n            }\n            return false;\n          }\n        }\n        return false;\n      } finally {\n        unlock();\n      }\n    }\n    @GuardedBy(\"this\")\n    boolean removeEntryForTesting(E entry) {\n      int hash = entry.getHash();\n      int newCount = this.count - 1;\n      AtomicReferenceArray<E> table = this.table;\n      int index = hash & (table.length() - 1);\n      E first = table.get(index);\n      for (E e = first; e != null; e = e.getNext()) {\n        if (e == entry) {\n          ++modCount;\n          E newFirst = removeFromChain(first, e);\n          newCount = this.count - 1;\n          table.set(index, newFirst);\n          this.count = newCount; // write-volatile\n          return true;\n        }\n      }\n      return false;\n    }\n    /**\n     * Returns {@code true} if the value has been partially collected, meaning that the value is\n     * null.\n     */\n    static <K, V, E extends InternalEntry<K, V, E>> boolean isCollected(E entry) {\n      return entry.getValue() == null;\n    }\n    /**\n     * Gets the value from an entry. Returns {@code null} if the entry is invalid or\n     * partially-collected.\n     */\n    @NullableDecl\n    V getLiveValue(E entry) {\n      if (entry.getKey() == null) {\n        tryDrainReferenceQueues();\n        return null;\n      }\n      V value = entry.getValue();\n      if (value == null) {\n        tryDrainReferenceQueues();\n        return null;\n      }\n      return value;\n    }\n    /**\n     * Performs routine cleanup following a read. Normally cleanup happens during writes, or from\n     * the cleanupExecutor. If cleanup is not observed after a sufficient number of reads, try\n     * cleaning up from the read thread.\n     */\n    void postReadCleanup() {\n      if ((readCount.incrementAndGet() & DRAIN_THRESHOLD) == 0) {\n        runCleanup();\n      }\n    }\n    /**\n     * Performs routine cleanup prior to executing a write. This should be called every time a write\n     * thread acquires the segment lock, immediately after acquiring the lock.\n     */\n    @GuardedBy(\"this\")\n    void preWriteCleanup() {\n      runLockedCleanup();\n    }\n    void runCleanup() {\n      runLockedCleanup();\n    }\n    void runLockedCleanup() {\n      if (tryLock()) {\n        try {\n          maybeDrainReferenceQueues();\n          readCount.set(0);\n        } finally {\n          unlock();\n        }\n      }\n    }\n  }\n  /** Concrete implementation of {@link Segment} for strong keys and strong values. */\n  static final class StrongKeyStrongValueSegment<K, V>\n      extends Segment<K, V, StrongKeyStrongValueEntry<K, V>, StrongKeyStrongValueSegment<K, V>> {\n    StrongKeyStrongValueSegment(\n        MapMakerInternalMap<\n                K, V, StrongKeyStrongValueEntry<K, V>, StrongKeyStrongValueSegment<K, V>>\n            map,\n        int initialCapacity,\n        int maxSegmentSize) {\n      super(map, initialCapacity, maxSegmentSize);\n    }\n    @Override\n    StrongKeyStrongValueSegment<K, V> self() {\n      return this;\n    }\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public StrongKeyStrongValueEntry<K, V> castForTesting(InternalEntry<K, V, ?> entry) {\n      return (StrongKeyStrongValueEntry<K, V>) entry;\n    }\n  }\n  /** Concrete implementation of {@link Segment} for strong keys and weak values. */\n  static final class StrongKeyWeakValueSegment<K, V>\n      extends Segment<K, V, StrongKeyWeakValueEntry<K, V>, StrongKeyWeakValueSegment<K, V>> {\n    private final ReferenceQueue<V> queueForValues = new ReferenceQueue<V>();\n    StrongKeyWeakValueSegment(\n        MapMakerInternalMap<K, V, StrongKeyWeakValueEntry<K, V>, StrongKeyWeakValueSegment<K, V>>\n            map,\n        int initialCapacity,\n        int maxSegmentSize) {\n      super(map, initialCapacity, maxSegmentSize);\n    }\n    @Override\n    StrongKeyWeakValueSegment<K, V> self() {\n      return this;\n    }\n    @Override\n    ReferenceQueue<V> getValueReferenceQueueForTesting() {\n      return queueForValues;\n    }\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public StrongKeyWeakValueEntry<K, V> castForTesting(InternalEntry<K, V, ?> entry) {\n      return (StrongKeyWeakValueEntry<K, V>) entry;\n    }\n    @Override\n    public WeakValueReference<K, V, StrongKeyWeakValueEntry<K, V>> getWeakValueReferenceForTesting(\n        InternalEntry<K, V, ?> e) {\n      return castForTesting(e).getValueReference();\n    }\n<fim_suffix>    @Override\n    public WeakValueReference<K, V, StrongKeyWeakValueEntry<K, V>> newWeakValueReferenceForTesting(\n        InternalEntry<K, V, ?> e, V value) {\n      return new WeakValueReferenceImpl<>(queueForValues, value, castForTesting(e));\n    }<fim_middle>// function below has no smell\n"}