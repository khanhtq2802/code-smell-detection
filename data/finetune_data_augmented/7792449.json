{"text": "<fim_prefix> *   &lt;body&gt;\n *     First Middle Last\n *   &lt;/body&gt;\n *   &lt;/html&gt;\n * </pre>\n * \n * In other words, the body of the myBorder component is substituted into the border's associated\n * markup at the position indicated by the &lt;wicket:body&gt; tag.\n * <p>\n * Regarding &lt;wicket:body/&gt; you have two options. Either use &lt;wicket:body/&gt; (open-close\n * tag) which will automatically be expanded to &lt;wicket:body&gt;body content&lt;/wicket:body&gt;\n * or use &lt;wicket:body&gt;preview region&lt;/wicket:body&gt; in your border's markup. The preview\n * region (everything in between the open and close tag) will automatically be removed.\n * <p>\n * The border body container will automatically be created for you and added to the border\n * container. It is accessible via {@link #getBodyContainer()}. In case the body markup is not an\n * immediate child of border (see the example below), then you must use code such as\n * <code>someContainer.add(getBodyContainer())</code> to add the body component to the correct\n * container.\n * \n * <pre>\n *   &lt;html&gt;\n *   &lt;body&gt;\n *     &lt;wicket:border&gt;\n *       &lt;span wicket:id=&quot;someContainer&quot;&gt;\n *         &lt;wicket:body/&gt;\n *       &lt;/span&gt;\n *     &lt;/wicket:border&gt;\n *   &lt;/body&gt;\n *   &lt;/html&gt;\n * </pre>\n * \n * The component \"someContainer\" in the previous example must be added to the border, and not the\n * body, which is achieved via {@link #addToBorder(Component...)}.\n * <p/>\n * {@link #add(Component...)} is an alias to {@code getBodyContainer().add(Component...)} and will\n * add a child component to the border body as shown in the example below.\n * \n * <pre>\n *   &lt;html&gt;\n *   &lt;body&gt;\n *     &lt;span wicket:id = &quot;myBorder&quot;&gt;\n *       &lt;input wicket:id=&quot;name&quot/;&gt;\n *     &lt;/span&gt;\n *   &lt;/body&gt;\n *   &lt;/html&gt;\n * </pre>\n * \n * This implementation does not apply any magic with respect to component handling. In doubt think\n * simple. But everything you can do with a MarkupContainer or Component, you can do with a Border\n * or its Body as well.\n * <p/>\n * \n * Other methods like {@link #remove()}, {@link #get(int)}, {@link #iterator()}, etc. are not\n * aliased to work on the border's body and attention must be paid when they need to be used.\n * \n * @see BorderPanel An alternative implementation based on Panel\n * @see BorderBehavior A behavior which adds (raw) markup before and after the component\n * \n * @author Jonathan Locke\n * @author Juergen Donnerstag\n */\npublic abstract class Border extends WebMarkupContainer implements IComponentResolver, IQueueRegion\n{\n\tprivate static final long serialVersionUID = 1L;\n\t/** */\n\tpublic static final String BODY = \"body\";\n\t/** */\n\tpublic static final String BORDER = \"border\";\n\t/** The body component associated with <wicket:body> */\n\tprivate final BorderBodyContainer body;\n\t/**\n\t * @see org.apache.wicket.Component#Component(String)\n\t */\n\tpublic Border(final String id)\n\t{\n\t\tthis(id, null);\n\t}\n\t/**\n\t * @see org.apache.wicket.Component#Component(String, IModel)\n\t */\n\tpublic Border(final String id, final IModel<?> model)\n\t{\n\t\tsuper(id, model);\n\t\tbody = new BorderBodyContainer(id + \"_\" + BODY);\n\t\tqueueToBorder(body);\n\t}\n\t/**\n\t * Returns the border body container. \n\t * \n\t * NOTE: this component is NOT meant to be directly handled by users, meaning that you \n\t * can not explicitly add it to an arbitrary container or remove it from its original parent container.\n\t * \n\t * @return The border body container\n\t */\n\tpublic final BorderBodyContainer getBodyContainer()\n\t{\n\t\treturn body;\n\t}\n\t/**\n\t * This is for all components which have been added to the markup like this:\n\t * \n\t * <pre>\n\t * \t&lt;span wicket:id=\"myBorder\"&gt;\n\t * \t\t&lt;input wicket:id=\"text1\" .. /&gt;\n\t * \t\t...\n\t * \t&lt;/span&gt;\n\t * \n\t * </pre>\n\t * \n\t * Whereas {@link #addToBorder(Component...)} will add a component associated with the following\n\t * markup:\n\t * \n\t * <pre>\n\t * \t&lt;wicket:border&gt;\n\t * \t\t&lt;form wicket:id=\"myForm\" .. &gt;\n\t * \t\t\t&lt;wicket:body/&gt;\n\t * \t\t&lt;/form&gt;\n\t * \t&lt;/wicket:border&gt;\n\t * \n\t * </pre>\n\t * \n\t * @see org.apache.wicket.MarkupContainer#add(org.apache.wicket.Component[])\n\t */\n\t@Override\n\tpublic Border add(final Component... children)\n\t{\n\t\tfor (Component component : children)\n\t\t{\n\t\t\tif (component == body || component.isAuto())\n\t\t\t{\n\t\t\t\taddToBorder(component);\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tgetBodyContainer().add(component);\t\t\t\t\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\t@Override\n\tpublic Border addOrReplace(final Component... children)\n\t{\n\t\tfor (Component component : children)\n\t\t{\n\t\t\tif (component == body)\n\t\t\t{\n\t\t\t\t// in this case we do not want to redirect to body\n\t\t\t\t// container but to border's old remove.\n\t\t\t\tsuper.addOrReplace(component);\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tgetBodyContainer().addOrReplace(component);\t\t\t\t\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\t@Override\n\tpublic Border remove(final Component component)\n\t{\n\t\tif (component == body)\n\t\t{\n\t\t\t// in this case we do not want to redirect to body\n\t\t\t// container but to border's old remove.\n\t\t\tremoveFromBorder(component);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgetBodyContainer().remove(component);\n\t\t}\n\t\treturn this;\n\t}\n\t@Override\n\tpublic Border remove(final String id)\n\t{\n\t\tif (body.getId().equals(id))\n\t\t{\n\t\t\t// in this case we do not want to redirect to body\n\t\t\t// container but to border's old remove.\n\t\t\tsuper.remove(id);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgetBodyContainer().remove(id);\n\t\t}\n\t\treturn this;\n\t}\n\t@Override\n\tpublic Border removeAll()\n\t{\n\t\tgetBodyContainer().removeAll();\n\t\treturn this;\n\t}\n\t@Override\n\tpublic Border replace(final Component replacement)\n\t{\n\t\tif (body.getId().equals(replacement.getId()))\n\t\t{\n\t\t\t// in this case we do not want to redirect to body\n\t\t\t// container but to border's old remove.\n\t\t\treplaceInBorder(replacement);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tgetBodyContainer().replace(replacement);\n\t\t}\n\t\treturn this;\n\t}\n\t/**\n\t * Adds children components to the Border itself\n\t * \n\t * @param children\n\t *            the children components to add\n\t * @return this\n\t */\n\tpublic Border addToBorder(final Component... children)\n\t{\n\t\tsuper.add(children);\n\t\treturn this;\n\t}\n\t@Override\n\tpublic Border queue(Component... components)\n\t{\n\t\tgetBodyContainer().queue(components);\n\t\treturn this;\n\t}\n<fim_suffix>\t@Override\n\tprotected void onConfigure() \n\t{\n\t\tsuper.onConfigure();\n\t\tdequeue();\n\t}<fim_middle>// function below has no smell\n"}