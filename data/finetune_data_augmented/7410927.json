{"text": "<fim_prefix>/*\n * Copyright 2010-2019 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.springframework.data.gemfire.serialization;\nimport java.io.Serializable;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Modifier;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.atomic.AtomicLong;\nimport org.apache.geode.DataSerializable;\nimport org.apache.geode.Instantiator;\nimport org.springframework.asm.ClassWriter;\nimport org.springframework.asm.FieldVisitor;\nimport org.springframework.asm.MethodVisitor;\nimport org.springframework.asm.Opcodes;\nimport org.springframework.asm.Type;\nimport org.springframework.beans.BeanUtils;\nimport org.springframework.util.Assert;\n/**\n * ASM based {@link InstantiatorGenerator} implementation. This class relies on ASM 2.x package\n * repacked by Spring framework to minimize the number of dependencies and avoid any versioning\n * confusion.\n *\n * @author Costin Leau\n */\npublic class AsmInstantiatorGenerator implements InstantiatorGenerator, Opcodes {\n\tprivate static final String PKG = \"org/springextensions/gef/serialization\";\n\tprivate static final String CLASS_LABEL = \"Instantiator$Synthetic\";\n\tprivate static final String INSTANTIATOR_NAME = Type.getInternalName(Instantiator.class);\n\tprivate static final String SERIALIZABLE_NAME = Type.getInternalName(Serializable.class);\n\tprivate static final String CLASS_DESCRIPTOR = Type.getDescriptor(Class.class);\n\tprivate static final String CLASS_FIELD_NAME = \"clazz\";\n\tprivate static final String ID_FIELD_NAME = \"classId\";\n\tprivate static final String INIT = \"<init>\";\n\tprivate static final String CINIT = \"<clinit>\";\n\tprivate static final String NEW_INSTANCE = \"newInstance\";\n\tprivate static final String NEW_INSTANCE_DESC = Type.getMethodDescriptor(Type.getType(DataSerializable.class),\n\t\t\tnew Type[] {});\n\t// generated class counter\n\tprivate static final AtomicLong counter = new AtomicLong(1);\n\t// class cache\n\tprivate final ConcurrentMap<Class<? extends DataSerializable>, Instantiator> cache = new ConcurrentHashMap<Class<? extends DataSerializable>, Instantiator>();\n<fim_suffix>\tprivate static final class BytecodeClassLoader extends ClassLoader {\n\t\tpublic BytecodeClassLoader(ClassLoader loader) {\n\t\t\tsuper(loader);\n\t\t}\n\t\tpublic Class<?> loadClass(String name, byte[] bytecode) {\n\t\t\treturn defineClass(name, bytecode, 0, bytecode.length);\n\t\t}\n\t}\n\tprivate final BytecodeClassLoader classLoader;\n\tpublic AsmInstantiatorGenerator() {\n\t\tthis(AsmInstantiatorGenerator.class.getClassLoader());\n\t}\n\tpublic AsmInstantiatorGenerator(final ClassLoader classLoader) {\n\t\tAssert.notNull(classLoader);\n\t\tthis.classLoader = AccessController.doPrivileged(new PrivilegedAction<BytecodeClassLoader>() {\n\t\t\tpublic BytecodeClassLoader run() {\n\t\t\t\treturn new BytecodeClassLoader(classLoader);\n\t\t\t}\n\t\t});\n\t}\n\tpublic Instantiator getInstantiator(Class<? extends DataSerializable> clazz, int classId) {\n\t\tInstantiator instantiator = cache.get(clazz);\n\t\tif (instantiator == null) {\n\t\t\tsynchronized (cache) {\n\t\t\t\tinstantiator = cache.get(clazz);\n\t\t\t\tif (instantiator == null) {\n\t\t\t\t\t// create Instantiator\n\t\t\t\t\tinstantiator = createInstantiator(clazz, classId);\n\t\t\t\t\tcache.putIfAbsent(clazz, instantiator);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn instantiator;\n\t}\n\t/**\n\t * Returns an instance of the custom instantiator created for the given class.\n\t *\n\t * @param clazz\n\t * @param classId\n\t * @return\n\t */\n\tprivate Instantiator createInstantiator(Class<? extends DataSerializable> clazz, int classId) {\n\t\tvalidateClass(clazz);\n\t\tClass<?> clz = createCustomInstantiatorClass(clazz, classId);\n\t\treturn (Instantiator) BeanUtils.instantiate(clz);\n\t}\n\t/**\n\t * Does basic sanity checks to make sure the constructor can be properly invoked by our generated\n\t * class.\n\t *\n\t * @param clazz\n\t */\n\tprivate void validateClass(Class<? extends DataSerializable> clazz) {\n\t\tAssert.isTrue(!Modifier.isAbstract(clazz.getModifiers()), \"Cannot instantiate abstract classes\");\n\t\tAssert.isTrue(Modifier.isPublic(clazz.getModifiers()), \"Only public classes are supported\");\n\t\ttry {\n\t\t\tConstructor<? extends DataSerializable> ctor = clazz.getConstructor();\n\t\t\tAssert.isTrue(Modifier.isPublic(ctor.getModifiers()), \"Default constructor is not public\");\n\t\t} catch (Exception ex) {\n\t\t\tthrow new IllegalArgumentException(\"Class \" + clazz + \" unsuitable for instantiation\", ex);\n\t\t}\n\t}\n\t/**\n\t * Generates a new Instantiator class for the given custom class.\n\t *\n\t * The generated class has the following definition:\n\t *\n\t * <pre>\n\t * package org.springframework.data.gemfire.serialization;\n\t *\n\t * public class &lt;<i>T</i>>Instantiator$Synthetic<i>Counter</i> extends Instantiator implements Serializable {\n\t *\n\t *  private static final Class&lt;<i>T</i>> clazz = T.class;\n\t *  private static final int classId = <i>value</i>;\n\t *\n\t *  public DateInstantiator() {\n\t *     this(clazz, classId);\n\t *  }\n\t *\n\t *  public DateInstantiator(Class<? extends DataSerializable> c, int classId) {\n\t *     super(c, classId);\n\t *  }\n\t *\n\t *  public <i>T</i> newInstance() {\n\t *     return new <i>T</i>();\n\t *  }\n\t * }\n\t * </pre>\n\t *\n\t * @param clazz\n\t * @return\n\t */\n\tClass<?> createCustomInstantiatorClass(Class<? extends DataSerializable> clazz, int classId) {\n\t\tString classInternalName = PKG + clazz.getSimpleName() + CLASS_LABEL + counter.getAndIncrement();\n\t\tbyte[] bytecode = generateClassBytecode(classInternalName, clazz, classId);\n\t\t// translate internal name to binary form\n\t\treturn classLoader.loadClass(classInternalName.replace('/', '.'), bytecode);\n\t}\n\tbyte[] generateClassBytecode(String className, Class<? extends DataSerializable> clazz, int classId) {\n\t\tClassWriter cw = new ClassWriter(0);\n\t\tcw.visit(V1_5, ACC_PUBLIC + ACC_SUPER, className, null, INSTANTIATOR_NAME, new String[] { SERIALIZABLE_NAME });\n\t\tFieldVisitor fv = cw.visitField(ACC_PRIVATE + ACC_FINAL + ACC_STATIC, CLASS_FIELD_NAME, CLASS_DESCRIPTOR, null,\n\t\t\t\tnull);\n\t\tfv.visitEnd();\n\t\tfv = cw.visitField(ACC_PRIVATE + ACC_FINAL + ACC_STATIC, ID_FIELD_NAME, Type.INT_TYPE.getDescriptor(), null,\n\t\t\t\tInteger.valueOf(classId));\n\t\tfv.visitEnd();\n\t\tString voidNoArgMethodDescriptor = Type.getMethodDescriptor(Type.VOID_TYPE, new Type[] {});\n\t\t// field class loading\n\t\tMethodVisitor mv = cw.visitMethod(ACC_STATIC, CINIT, voidNoArgMethodDescriptor, null, null);\n\t\tmv.visitCode();\n\t\tmv.visitLdcInsn(Type.getType(clazz));\n\t\tmv.visitFieldInsn(PUTSTATIC, className, CLASS_FIELD_NAME, CLASS_DESCRIPTOR);\n\t\tmv.visitInsn(RETURN);\n\t\tmv.visitMaxs(1, 0);\n\t\tmv.visitEnd();\n\t\tString voidArgClassAndIntDescriptor = Type.getMethodDescriptor(Type.VOID_TYPE, new Type[] {\n\t\t\t\tType.getType(Class.class), Type.INT_TYPE });\n\t\t// default constructor\n\t\tmv = cw.visitMethod(ACC_PUBLIC, INIT, voidNoArgMethodDescriptor, null, null);\n\t\tmv.visitCode();\n\t\tmv.visitVarInsn(ALOAD, 0);\n\t\tmv.visitFieldInsn(GETSTATIC, className, CLASS_FIELD_NAME, CLASS_DESCRIPTOR);<fim_middle>// class below has no smell\n"}