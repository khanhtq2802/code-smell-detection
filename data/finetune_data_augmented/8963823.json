{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.hadoop.hive.ql.optimizer.calcite.functions;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.calcite.rel.core.AggregateCall;\nimport org.apache.calcite.rel.type.RelDataType;\nimport org.apache.calcite.rel.type.RelDataTypeFactory;\nimport org.apache.calcite.rex.RexBuilder;\nimport org.apache.calcite.rex.RexNode;\nimport org.apache.calcite.sql.SqlAggFunction;\nimport org.apache.calcite.sql.SqlFunctionCategory;\nimport org.apache.calcite.sql.SqlKind;\nimport org.apache.calcite.sql.SqlSplittableAggFunction;\nimport org.apache.calcite.sql.SqlSyntax;\nimport org.apache.calcite.sql.SqlSplittableAggFunction.CountSplitter;\nimport org.apache.calcite.sql.SqlSplittableAggFunction.Registry;\nimport org.apache.calcite.sql.fun.SqlStdOperatorTable;\nimport org.apache.calcite.sql.type.SqlOperandTypeChecker;\nimport org.apache.calcite.sql.type.SqlOperandTypeInference;\nimport org.apache.calcite.sql.type.SqlReturnTypeInference;\nimport org.apache.calcite.sql.type.SqlTypeName;\nimport org.apache.calcite.util.ImmutableIntList;\n\nimport com.google.common.collect.ImmutableList;\n\npublic class HiveSqlCountAggFunction extends SqlAggFunction implements CanAggregateDistinct {\n\n  final boolean                isDistinct;\n  final SqlReturnTypeInference returnTypeInference;\n  final SqlOperandTypeInference operandTypeInference;\n  final SqlOperandTypeChecker operandTypeChecker;\n\n  public HiveSqlCountAggFunction(boolean isDistinct, SqlReturnTypeInference returnTypeInference,\n      SqlOperandTypeInference operandTypeInference, SqlOperandTypeChecker operandTypeChecker) {\n    super(\n        \"count\",\n        SqlKind.COUNT,\n        returnTypeInference,\n        operandTypeInference,\n        operandTypeChecker,\n        SqlFunctionCategory.NUMERIC);\n    this.isDistinct = isDistinct;\n    this.returnTypeInference = returnTypeInference;\n    this.operandTypeChecker = operandTypeChecker;\n    this.operandTypeInference = operandTypeInference;\n  }\n\n  @Override\n  public boolean isDistinct() {\n    return isDistinct;\n  }\n\n  @Override\n  public SqlSyntax getSyntax() {\n    return SqlSyntax.FUNCTION_STAR;\n  }\n\n  @Override\n  public <T> T unwrap(Class<T> clazz) {\n    if (clazz == SqlSplittableAggFunction.class) {\n      return clazz.cast(new HiveCountSplitter());\n    }\n    return super.unwrap(clazz);\n  }\n\n  // We need to override these methods due to difference in nullability between Hive and\n  // Calcite for the return types of the aggregation  (in particular, for COUNT and SUM0).\n  // TODO: We should close the semantics gaps between Hive and Calcite for nullability of\n  // aggregation calls return types. This might be useful to trigger some additional\n  // rewriting rules that would remove unnecessary predicates, etc.\n  class HiveCountSplitter extends CountSplitter {\n\n<fim_suffix>    @Override\n    public AggregateCall other(RelDataTypeFactory typeFactory, AggregateCall e) {\n      return AggregateCall.create(\n          new HiveSqlCountAggFunction(isDistinct, returnTypeInference, operandTypeInference, operandTypeChecker),\n          false, ImmutableIntList.of(), -1,\n          typeFactory.createTypeWithNullability(typeFactory.createSqlType(SqlTypeName.BIGINT), true), \"count\");\n    }\n\n    @Override\n    public AggregateCall topSplit(RexBuilder rexBuilder,\n        Registry<RexNode> extra, int offset, RelDataType inputRowType,\n        AggregateCall aggregateCall, int leftSubTotal, int rightSubTotal) {\n      final List<RexNode> merges = new ArrayList<>();\n      if (leftSubTotal >= 0) {\n        merges.add(\n            rexBuilder.makeInputRef(aggregateCall.type, leftSubTotal));\n      }\n      if (rightSubTotal >= 0) {\n        merges.add(\n            rexBuilder.makeInputRef(aggregateCall.type, rightSubTotal));\n      }\n      RexNode node;\n      switch (merges.size()) {\n      case 1:\n        node = merges.get(0);\n        break;\n      case 2:\n        node = rexBuilder.makeCall(SqlStdOperatorTable.MULTIPLY, merges);\n        break;\n      default:\n        throw new AssertionError(\"unexpected count \" + merges);\n      }\n      int ordinal = extra.register(node);\n      return AggregateCall.create(\n          new HiveSqlSumEmptyIsZeroAggFunction(isDistinct, returnTypeInference, operandTypeInference, operandTypeChecker),\n          false, ImmutableList.of(ordinal), -1, aggregateCall.type, aggregateCall.name);\n    }\n  }\n}<fim_middle>// function below has no smell\n"}