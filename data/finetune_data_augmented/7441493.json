{"text": "<fim_prefix>/*\n * Copyright (c) 2018, 2018, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage com.oracle.svm.core.windows;\nimport org.graalvm.nativeimage.Feature;\nimport org.graalvm.nativeimage.ImageSingletons;\nimport org.graalvm.nativeimage.ObjectHandle;\nimport org.graalvm.nativeimage.Platform;\nimport org.graalvm.nativeimage.Platform.HOSTED_ONLY;\nimport org.graalvm.nativeimage.Platforms;\nimport org.graalvm.nativeimage.StackValue;\nimport org.graalvm.nativeimage.UnmanagedMemory;\nimport org.graalvm.nativeimage.c.function.CEntryPoint;\nimport org.graalvm.nativeimage.c.function.CEntryPointLiteral;\nimport org.graalvm.nativeimage.c.function.CFunctionPointer;\nimport org.graalvm.nativeimage.c.struct.RawField;\nimport org.graalvm.nativeimage.c.struct.RawStructure;\nimport org.graalvm.nativeimage.c.struct.SizeOf;\nimport org.graalvm.nativeimage.c.type.CCharPointer;\nimport org.graalvm.nativeimage.c.type.CIntPointer;\nimport org.graalvm.word.WordBase;\nimport org.graalvm.word.WordFactory;\nimport com.oracle.svm.core.annotate.AutomaticFeature;\nimport com.oracle.svm.core.c.CGlobalData;\nimport com.oracle.svm.core.c.CGlobalDataFactory;\nimport com.oracle.svm.core.c.function.CEntryPointActions;\nimport com.oracle.svm.core.c.function.CEntryPointOptions;\nimport com.oracle.svm.core.c.function.CEntryPointOptions.Publish;\nimport com.oracle.svm.core.c.function.CEntryPointSetup.LeaveDetachThreadEpilogue;\nimport com.oracle.svm.core.log.Log;\nimport com.oracle.svm.core.thread.JavaThreads;\nimport com.oracle.svm.core.thread.ParkEvent;\nimport com.oracle.svm.core.thread.ParkEvent.ParkEventFactory;\nimport com.oracle.svm.core.util.VMError;\nimport com.oracle.svm.core.windows.headers.Process;\nimport com.oracle.svm.core.windows.headers.SynchAPI;\nimport com.oracle.svm.core.windows.headers.WinBase;\n<fim_suffix>@Platforms(Platform.WINDOWS.class)\npublic final class WindowsJavaThreads extends JavaThreads {\n    @Platforms(HOSTED_ONLY.class)\n    WindowsJavaThreads() {\n    }\n    @Override\n    protected void doStartThread(Thread thread, long stackSize) {\n        int threadStackSize = (int) stackSize;\n        int initFlag = Process.CREATE_SUSPENDED();\n        WindowsThreadStartData startData = UnmanagedMemory.malloc(SizeOf.get(WindowsThreadStartData.class));\n        prepareStartData(thread, startData);\n        // If caller specified a stack size, don't commit it all at once.\n        if (threadStackSize != 0) {\n            initFlag |= Process.STACK_SIZE_PARAM_IS_A_RESERVATION();\n        }\n        CIntPointer osThreadID = StackValue.get(CIntPointer.class);\n        WinBase.HANDLE osThreadHandle = Process._beginthreadex(WordFactory.nullPointer(), threadStackSize, WindowsJavaThreads.osThreadStartRoutine.getFunctionPointer(), startData, initFlag,\n                        osThreadID);\n        VMError.guarantee(osThreadHandle.rawValue() != 0, \"Could not create thread\");\n        startData.setOSThreadHandle(osThreadHandle);\n        // Start the thread running\n        Process.ResumeThread(osThreadHandle);\n    }\n    /**\n     * Windows doesn't support setting a native threads name unless process is attached to a\n     * debugger.\n     */\n    @Override\n    protected void setNativeName(Thread thread, String name) {\n    }\n    @Override\n    protected void yield() {\n        Process.SwitchToThread();\n    }\n    @RawStructure\n    interface WindowsThreadStartData extends ThreadStartData {\n        @RawField\n        WinBase.HANDLE getOSThreadHandle();\n        @RawField\n        void setOSThreadHandle(WinBase.HANDLE osHandle);\n    }\n    private static final CEntryPointLiteral<CFunctionPointer> osThreadStartRoutine = CEntryPointLiteral.create(WindowsJavaThreads.class, \"osThreadStartRoutine\", WindowsThreadStartData.class);\n    private static class OSThreadStartRoutinePrologue {\n        private static final CGlobalData<CCharPointer> errorMessage = CGlobalDataFactory.createCString(\"Failed to attach a newly launched thread.\");\n        @SuppressWarnings(\"unused\")\n        static void enter(WindowsThreadStartData data) {\n            int code = CEntryPointActions.enterAttachThread(data.getIsolate());\n            if (code != 0) {\n                CEntryPointActions.failFatally(code, errorMessage.get());\n            }\n        }\n    }\n    @CEntryPoint\n    @CEntryPointOptions(prologue = OSThreadStartRoutinePrologue.class, epilogue = LeaveDetachThreadEpilogue.class, publishAs = Publish.NotPublished, include = CEntryPointOptions.NotIncludedAutomatically.class)\n    static WordBase osThreadStartRoutine(WindowsThreadStartData data) {\n        ObjectHandle threadHandle = data.getThreadHandle();\n        WinBase.HANDLE osThreadHandle = data.getOSThreadHandle();\n        UnmanagedMemory.free(data);\n        try {\n            threadStartRoutine(threadHandle);\n        } finally {\n            WinBase.CloseHandle(osThreadHandle);\n        }\n        return WordFactory.nullPointer();\n    }\n}\n@Platforms(Platform.WINDOWS.class)\nclass WindowsParkEvent extends ParkEvent {\n    /** opaque Event Object Handle from the operating system. */\n    private final WinBase.HANDLE eventHandle;\n    WindowsParkEvent() {\n        /* Create an Event */\n        eventHandle = SynchAPI.CreateEventA(WordFactory.nullPointer(), 0, 0, WordFactory.nullPointer());\n        VMError.guarantee(eventHandle.rawValue() != 0, \"CreateEventA failed\");\n    }\n    @Override\n    protected WaitResult condWait() {\n        WaitResult result = WaitResult.UNPARKED;\n        try {\n            if (resetEventBeforeWait) {\n                event = false;\n            }\n            /*\n             * Wait while the ticket is not available. Note that the ticket might already be\n             * available before we enter the loop the first time, in which case we do not want to\n             * wait at all.\n             */\n            while (!event) {\n                /* Before blocking, check if this thread has been interrupted. */\n                if (Thread.interrupted()) {\n                    result = WaitResult.INTERRUPTED;\n                    SynchAPI.ResetEvent(eventHandle);\n                    return result;\n                }\n                int status = SynchAPI.WaitForSingleObject(eventHandle, SynchAPI.INFINITE());\n                /*\n                 * If the status isn't WAIT_OBJECT_0, then something went wrong.\n                 */\n                if (status != SynchAPI.WAIT_OBJECT_0()) {\n                    Log.log().newline().string(\"WindowsParkEvent.condWait failed, status returned:  \").hex(status);\n                    Log.log().newline().string(\"GetLastError returned:  \").hex(WinBase.GetLastError()).newline();\n                    result = WaitResult.INTERRUPTED;\n                    break;\n                }\n            }\n            if (event) {\n                /* If the ticket is available, then someone unparked me. */\n                event = false;\n                result = WaitResult.UNPARKED;\n            }\n        } finally {\n            SynchAPI.ResetEvent(eventHandle);\n        }<fim_middle>// class below has no smell\n"}