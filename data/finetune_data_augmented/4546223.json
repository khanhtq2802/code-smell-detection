{"text": "<fim_prefix>    }\n    @PostConstruct\n    public void loadAllJobs() {\n        final List<FineractPlatformTenant> allTenants = this.tenantDetailsService.findAllTenants();\n        for (final FineractPlatformTenant tenant : allTenants) {\n            ThreadLocalContextUtil.setTenant(tenant);\n            final List<ScheduledJobDetail> scheduledJobDetails = this.schedularWritePlatformService.retrieveAllJobs();\n            for (final ScheduledJobDetail jobDetails : scheduledJobDetails) {\n                scheduleJob(jobDetails);\n                jobDetails.updateTriggerMisfired(false);\n                this.schedularWritePlatformService.saveOrUpdate(jobDetails);\n            }\n            final SchedulerDetail schedulerDetail = this.schedularWritePlatformService.retriveSchedulerDetail();\n            if (schedulerDetail.isResetSchedulerOnBootup()) {\n                schedulerDetail.updateSuspendedState(false);\n                this.schedularWritePlatformService.updateSchedulerDetail(schedulerDetail);\n            }\n        }\n    }\n    public void executeJob(final ScheduledJobDetail scheduledJobDetail, String triggerType) {\n        try {\n            final JobDataMap jobDataMap = new JobDataMap();\n            if (triggerType == null) {\n                triggerType = SchedulerServiceConstants.TRIGGER_TYPE_APPLICATION;\n            }\n            jobDataMap.put(SchedulerServiceConstants.TRIGGER_TYPE_REFERENCE, triggerType);\n            jobDataMap.put(SchedulerServiceConstants.TENANT_IDENTIFIER, ThreadLocalContextUtil.getTenant().getTenantIdentifier());\n            final String key = scheduledJobDetail.getJobKey();\n            final JobKey jobKey = constructJobKey(key);\n            final String schedulerName = getSchedulerName(scheduledJobDetail);\n            final Scheduler scheduler = this.schedulers.get(schedulerName);\n            if (scheduler == null || !scheduler.checkExists(jobKey)) {\n                final JobDetail jobDetail = createJobDetail(scheduledJobDetail);\n                final String tempSchedulerName = \"temp\" + scheduledJobDetail.getId();\n                final Scheduler tempScheduler = createScheduler(tempSchedulerName, 1, schedulerJobListener, schedulerStopListener);\n                tempScheduler.addJob(jobDetail, true);\n                jobDataMap.put(SchedulerServiceConstants.SCHEDULER_NAME, tempSchedulerName);\n                this.schedulers.put(tempSchedulerName, tempScheduler);\n                tempScheduler.triggerJob(jobDetail.getKey(), jobDataMap);\n            } else {\n                scheduler.triggerJob(jobKey, jobDataMap);\n            }\n        } catch (final Exception e) {\n            final String msg = \"Job execution failed for job with id:\" + scheduledJobDetail.getId();\n            logger.error(msg, e);\n            throw new PlatformInternalServerException(\"error.msg.sheduler.job.execution.failed\", msg, scheduledJobDetail.getId());\n        }\n    }\n    public void rescheduleJob(final ScheduledJobDetail scheduledJobDetail) {\n        try {\n            final String jobIdentity = scheduledJobDetail.getJobKey();\n            final JobKey jobKey = constructJobKey(jobIdentity);\n            final String schedulername = getSchedulerName(scheduledJobDetail);\n            final Scheduler scheduler = this.schedulers.get(schedulername);\n            if (scheduler != null) {\n                scheduler.deleteJob(jobKey);\n            }\n            scheduleJob(scheduledJobDetail);\n            this.schedularWritePlatformService.saveOrUpdate(scheduledJobDetail);\n        } catch (final Throwable throwable) {\n            final String stackTrace = getStackTraceAsString(throwable);\n            scheduledJobDetail.updateErrorLog(stackTrace);\n            this.schedularWritePlatformService.saveOrUpdate(scheduledJobDetail);\n        }\n    }\n    @Override\n    public void pauseScheduler() {\n        final SchedulerDetail schedulerDetail = this.schedularWritePlatformService.retriveSchedulerDetail();\n        if (!schedulerDetail.isSuspended()) {\n            schedulerDetail.updateSuspendedState(true);\n            this.schedularWritePlatformService.updateSchedulerDetail(schedulerDetail);\n        }\n    }\n    @Override\n    public void startScheduler() {\n        final SchedulerDetail schedulerDetail = this.schedularWritePlatformService.retriveSchedulerDetail();\n        if (schedulerDetail.isSuspended()) {\n            schedulerDetail.updateSuspendedState(false);\n            this.schedularWritePlatformService.updateSchedulerDetail(schedulerDetail);\n            if (schedulerDetail.isExecuteInstructionForMisfiredJobs()) {\n                final List<ScheduledJobDetail> scheduledJobDetails = this.schedularWritePlatformService.retrieveAllJobs();\n                for (final ScheduledJobDetail jobDetail : scheduledJobDetails) {\n                    if (jobDetail.isTriggerMisfired()) {\n                        if (jobDetail.isActiveSchedular()) {\n                            executeJob(jobDetail, SchedulerServiceConstants.TRIGGER_TYPE_CRON);\n                        }\n                        final String schedulerName = getSchedulerName(jobDetail);\n                        final Scheduler scheduler = this.schedulers.get(schedulerName);\n                        if (scheduler != null) {\n                            final String key = jobDetail.getJobKey();\n                            final JobKey jobKey = constructJobKey(key);\n                            try {\n                                final List<? extends Trigger> triggers = scheduler.getTriggersOfJob(jobKey);\n                                for (final Trigger trigger : triggers) {\n                                    if (trigger.getNextFireTime() != null && trigger.getNextFireTime().after(jobDetail.getNextRunTime())) {\n                                        jobDetail.updateNextRunTime(trigger.getNextFireTime());\n                                    }\n                                }\n                            } catch (final SchedulerException e) {\n                                logger.error(e.getMessage(), e);\n                            }\n                        }\n                        jobDetail.updateTriggerMisfired(false);\n                        this.schedularWritePlatformService.saveOrUpdate(jobDetail);\n                    }\n                }\n            }\n        }\n    }\n    @Override\n    public void rescheduleJob(final Long jobId) {\n        final ScheduledJobDetail scheduledJobDetail = this.schedularWritePlatformService.findByJobId(jobId);\n        rescheduleJob(scheduledJobDetail);\n    }\n    @Override\n    public void executeJob(final Long jobId) {\n        final ScheduledJobDetail scheduledJobDetail = this.schedularWritePlatformService.findByJobId(jobId);\n        if (scheduledJobDetail == null) { throw new JobNotFoundException(String.valueOf(jobId)); }\n        executeJob(scheduledJobDetail, null);\n    }\n    @Override\n    public boolean isSchedulerRunning() {\n        return !this.schedularWritePlatformService.retriveSchedulerDetail().isSuspended();\n    }\n    /**\n     * Need to use ContextClosedEvent instead of ContextStoppedEvent because in\n     * case Spring Boot fails to start-up (e.g. because Tomcat port is already\n     * in use) then org.springframework.boot.SpringApplication.run(String...)\n     * does a context.close(); and not a context.stop();\n     */\n    @Override\n    public void onApplicationEvent(@SuppressWarnings(\"unused\") ContextClosedEvent event) {\n        this.stopAllSchedulers();\n    }\n    private void scheduleJob(final ScheduledJobDetail scheduledJobDetails) {\n        if (!scheduledJobDetails.isActiveSchedular()) {\n            scheduledJobDetails.updateNextRunTime(null);\n            scheduledJobDetails.updateCurrentlyRunningStatus(false);\n            return;\n        }\n        try {\n            final JobDetail jobDetail = createJobDetail(scheduledJobDetails);\n            final Trigger trigger = createTrigger(scheduledJobDetails, jobDetail);\n            final Scheduler scheduler = getScheduler(scheduledJobDetails);\n            scheduler.scheduleJob(jobDetail, trigger);\n            scheduledJobDetails.updateJobKey(getJobKeyAsString(jobDetail.getKey()));\n            scheduledJobDetails.updateNextRunTime(trigger.getNextFireTime());\n            scheduledJobDetails.updateErrorLog(null);\n        } catch (final Throwable throwable) {\n            scheduledJobDetails.updateNextRunTime(null);\n            final String stackTrace = getStackTraceAsString(throwable);\n            scheduledJobDetails.updateErrorLog(stackTrace);\n            logger.error(\"Could not schedule job: \" + scheduledJobDetails.getJobName(), throwable);\n        }\n        scheduledJobDetails.updateCurrentlyRunningStatus(false);\n    }\n    @Override\n    public void stopAllSchedulers() {\n        for (Scheduler scheduler : this.schedulers.values()) {\n            try {\n                scheduler.shutdown();\n            } catch (final SchedulerException e) {\n                logger.error(e.getMessage(), e);\n            }\n        }\n    }\n    private Scheduler getScheduler(final ScheduledJobDetail scheduledJobDetail) throws Exception {\n        final String schedulername = getSchedulerName(scheduledJobDetail);\n        Scheduler scheduler = this.schedulers.get(schedulername);\n        if (scheduler == null) {\n            int noOfThreads = SchedulerServiceConstants.DEFAULT_THREAD_COUNT;\n            if (scheduledJobDetail.getSchedulerGroup() > 0) {\n                noOfThreads = SchedulerServiceConstants.GROUP_THREAD_COUNT;\n            }\n            scheduler = createScheduler(schedulername, noOfThreads, schedulerJobListener);\n            this.schedulers.put(schedulername, scheduler);\n        }\n        return scheduler;\n    }\n<fim_suffix>    @Override\n    public void stopScheduler(final String name) {\n        final Scheduler scheduler = this.schedulers.remove(name);\n        try {\n            scheduler.shutdown();\n        } catch (final SchedulerException e) {\n            logger.error(e.getMessage(), e);\n        }\n    }<fim_middle>// function below has no smell\n"}