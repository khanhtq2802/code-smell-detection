{"text": "<fim_prefix>\n<fim_suffix>public class AllocationManager {\n  private static final AtomicLong MANAGER_ID_GENERATOR = new AtomicLong(0);\n  private static final AtomicLong LEDGER_ID_GENERATOR = new AtomicLong(0);\n  static final PooledByteBufAllocatorL INNER_ALLOCATOR = new PooledByteBufAllocatorL(DrillMetrics.getRegistry());\n  private final RootAllocator root;\n  private final long allocatorManagerId = MANAGER_ID_GENERATOR.incrementAndGet();\n  private final int size;\n  private final UnsafeDirectLittleEndian underlying;\n  private final IdentityHashMap<BufferAllocator, BufferLedger> map = new IdentityHashMap<>();\n  private final ReadWriteLock lock = new ReentrantReadWriteLock();\n  private final AutoCloseableLock readLock = new AutoCloseableLock(lock.readLock());\n  private final AutoCloseableLock writeLock = new AutoCloseableLock(lock.writeLock());\n  private final long amCreationTime = System.nanoTime();\n  private volatile BufferLedger owningLedger;\n  private volatile long amDestructionTime = 0;\n  AllocationManager(BaseAllocator accountingAllocator, int size) {\n    Preconditions.checkNotNull(accountingAllocator);\n    accountingAllocator.assertOpen();\n    this.root = accountingAllocator.root;\n    this.underlying = INNER_ALLOCATOR.allocate(size);\n    // we do a no retain association since our creator will want to retrieve the newly created ledger and will create a\n    // reference count at that point\n    this.owningLedger = associate(accountingAllocator, false);\n    this.size = underlying.capacity();\n  }\n  /**\n   * Associate the existing underlying buffer with a new allocator. This will\n   * increase the reference count to the provided ledger by 1.\n   *\n   * @param allocator\n   *          The target allocator to associate this buffer with.\n   * @return The Ledger (new or existing) that associates the underlying buffer\n   *         to this new ledger.\n   */\n  BufferLedger associate(final BaseAllocator allocator) {\n    return associate(allocator, true);\n  }\n  private BufferLedger associate(final BaseAllocator allocator, final boolean retain) {\n    allocator.assertOpen();\n    if (root != allocator.root) {\n      throw new IllegalStateException(\n          \"A buffer can only be associated between two allocators that share the same root.\");\n    }\n    try (@SuppressWarnings(\"unused\") Closeable read = readLock.open()) {\n      final BufferLedger ledger = map.get(allocator);\n      if (ledger != null) {\n        if (retain) {\n          ledger.inc();\n        }\n        return ledger;\n      }\n    }\n    try (@SuppressWarnings(\"unused\") Closeable write = writeLock.open()) {\n      // we have to recheck existing ledger since a second reader => writer could be competing with us.\n      final BufferLedger existingLedger = map.get(allocator);\n      if (existingLedger != null) {\n        if (retain) {\n          existingLedger.inc();\n        }\n        return existingLedger;\n      }\n      final BufferLedger ledger = new BufferLedger(allocator, new ReleaseListener(allocator));\n      if (retain) {\n        ledger.inc();\n      }\n      BufferLedger oldLedger = map.put(allocator, ledger);\n      Preconditions.checkArgument(oldLedger == null);\n      allocator.associateLedger(ledger);\n      return ledger;\n    }\n  }\n  public static int chunkSize() {\n    return INNER_ALLOCATOR.getChunkSize();\n  }\n  /**\n   * The way that a particular BufferLedger communicates back to the\n   * AllocationManager that it now longer needs to hold a reference to\n   * particular piece of memory.\n   */\n  private class ReleaseListener {\n    private final BufferAllocator allocator;\n    public ReleaseListener(BufferAllocator allocator) {\n      this.allocator = allocator;\n    }\n    /**\n     * Can only be called when you already hold the writeLock.\n     */\n    public void release() {\n      allocator.assertOpen();\n      final BufferLedger oldLedger = map.remove(allocator);\n      oldLedger.allocator.dissociateLedger(oldLedger);\n      if (oldLedger == owningLedger) {\n        if (map.isEmpty()) {\n          // no one else owns, lets release.\n          oldLedger.allocator.releaseBytes(size);\n          underlying.release();\n          amDestructionTime = System.nanoTime();\n          owningLedger = null;\n        } else {\n          // we need to change the owning allocator. we've been removed so we'll get whatever is top of list\n          BufferLedger newLedger = map.values().iterator().next();\n          // we'll forcefully transfer the ownership and not worry about whether we exceeded the limit\n          // since this consumer can't do anything with this.\n          oldLedger.transferBalance(newLedger);\n        }\n      } else {\n        if (map.isEmpty()) {\n          throw new IllegalStateException(\"The final removal of a ledger should be connected to the owning ledger.\");\n        }\n      }\n    }\n  }\n  /**\n   * The reference manager that binds an allocator manager to a particular\n   * BaseAllocator. Also responsible for creating a set of DrillBufs that share\n   * a common fate and set of reference counts. As with AllocationManager, the\n   * only reason this is public is due to DrillBuf being in io.netty.buffer\n   * package.\n   */\n  public class BufferLedger {\n    private final IdentityHashMap<DrillBuf, Object> buffers =\n        BaseAllocator.DEBUG ? new IdentityHashMap<DrillBuf, Object>() : null;\n    private final long ledgerId = LEDGER_ID_GENERATOR.incrementAndGet(); // unique ID assigned to each ledger\n    private final AtomicInteger bufRefCnt = new AtomicInteger(0); // start at zero so we can manage request for retain\n                                                                  // correctly\n    private final long lCreationTime = System.nanoTime();\n    private volatile long lDestructionTime = 0;\n    private final BaseAllocator allocator;\n    private final ReleaseListener listener;\n    private final HistoricalLog historicalLog = BaseAllocator.DEBUG ? new HistoricalLog(BaseAllocator.DEBUG_LOG_LENGTH,\n        \"BufferLedger[%d]\", 1)\n        : null;\n    private BufferLedger(BaseAllocator allocator, ReleaseListener listener) {\n      this.allocator = allocator;\n      this.listener = listener;\n    }\n    /**\n     * Transfer any balance the current ledger has to the target ledger. In the case that the current ledger holds no\n     * memory, no transfer is made to the new ledger.\n     * @param target\n     *          The ledger to transfer ownership account to.\n     * @return Whether transfer fit within target ledgers limits.\n     */\n    public boolean transferBalance(final BufferLedger target) {\n      Preconditions.checkNotNull(target);\n      Preconditions.checkArgument(allocator.root == target.allocator.root,\n          \"You can only transfer between two allocators that share the same root.\");\n      allocator.assertOpen();\n      target.allocator.assertOpen();\n      // if we're transferring to ourself, just return.\n      if (target == this) {\n        return true;\n      }\n      // since two balance transfers out from the allocator manager could cause incorrect accounting, we need to ensure\n      // that this won't happen by synchronizing on the allocator manager instance.\n      try (@SuppressWarnings(\"unused\") Closeable write = writeLock.open()) {\n        if (owningLedger != this) {\n          return true;\n        }\n        if (BaseAllocator.DEBUG) {\n          this.historicalLog.recordEvent(\"transferBalance(%s)\", target.allocator.name);\n          target.historicalLog.recordEvent(\"incoming(from %s)\", owningLedger.allocator.name);\n        }\n        boolean overlimit = target.allocator.forceAllocate(size);\n        allocator.releaseBytes(size);\n        owningLedger = target;\n        return overlimit;\n      }\n    }\n    /**\n     * Print the current ledger state to a the provided StringBuilder.\n     * @param sb\n     *          The StringBuilder to populate.\n     * @param indent\n     *          The level of indentation to position the data.\n     * @param verbosity\n     *          The level of verbosity to print.\n     */\n    public void print(StringBuilder sb, int indent, Verbosity verbosity) {\n      indent(sb, indent)\n          .append(\"ledger[\")\n          .append(ledgerId)\n          .append(\"] allocator: \")\n          .append(allocator.name)\n          .append(\"), isOwning: \")\n          .append(owningLedger == this)\n          .append(\", size: \")\n          .append(size)\n          .append(\", references: \")\n          .append(bufRefCnt.get())\n          .append(\", life: \")\n          .append(lCreationTime)\n          .append(\"..\")\n          .append(lDestructionTime)\n          .append(\", allocatorManager: [\")\n          .append(AllocationManager.this.allocatorManagerId)\n          .append(\", life: \")\n          .append(amCreationTime)\n          .append(\"..\")\n          .append(amDestructionTime);\n      if (!BaseAllocator.DEBUG) {\n        sb.append(\"]\\n\");\n      } else {\n        synchronized (buffers) {\n          sb.append(\"] holds \")\n              .append(buffers.size())\n              .append(\" buffers. \\n\");\n          for (DrillBuf buf : buffers.keySet()) {\n            buf.print(sb, indent + 2, verbosity);\n            sb.append('\\n');\n          }<fim_middle>// class below is blob\n"}