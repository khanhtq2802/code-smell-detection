{"text": "<fim_prefix>        bufcolumn = newbufcolumn;\n        bufpos -= tokenBegin;\n      }\n    }\n    catch (Throwable t)\n    {\n      throw new Error(t.getMessage());\n    }\n    available = (bufsize += 2048);\n    tokenBegin = 0;\n  }\n  protected void FillBuff() throws java.io.IOException\n  {\n    int i;\n    if (maxNextCharInd == 4096)\n      maxNextCharInd = nextCharInd = 0;\n    try {\n      if ((i = inputStream.read(nextCharBuf, maxNextCharInd,\n                                          4096 - maxNextCharInd)) == -1)\n      {\n        inputStream.close();\n        throw new java.io.IOException();\n      }\n      else\n         maxNextCharInd += i;\n      return;\n    }\n    catch(java.io.IOException e) {\n      if (bufpos != 0)\n      {\n        --bufpos;\n        backup(0);\n      }\n      else\n      {\n        bufline[bufpos] = line;\n        bufcolumn[bufpos] = column;\n      }\n      throw e;\n    }\n  }\n  protected char ReadByte() throws java.io.IOException\n  {\n    if (++nextCharInd >= maxNextCharInd)\n      FillBuff();\n    return nextCharBuf[nextCharInd];\n  }\n/** @return starting character for token. */\n  public char BeginToken() throws java.io.IOException\n  {\n    if (inBuf > 0)\n    {\n      --inBuf;\n      if (++bufpos == bufsize)\n        bufpos = 0;\n      tokenBegin = bufpos;\n      return buffer[bufpos];\n    }\n    tokenBegin = 0;\n    bufpos = -1;\n    return readChar();\n  }\n  protected void AdjustBuffSize()\n  {\n    if (available == bufsize)\n    {\n      if (tokenBegin > 2048)\n      {\n        bufpos = 0;\n        available = tokenBegin;\n      }\n      else\n        ExpandBuff(false);\n    }\n    else if (available > tokenBegin)\n      available = bufsize;\n    else if ((tokenBegin - available) < 2048)\n      ExpandBuff(true);\n    else\n      available = tokenBegin;\n  }\n  protected void UpdateLineColumn(char c)\n  {\n    column++;\n    if (prevCharIsLF)\n    {\n      prevCharIsLF = false;\n      line += (column = 1);\n    }\n    else if (prevCharIsCR)\n    {\n      prevCharIsCR = false;\n      if (c == '\\n')\n      {\n        prevCharIsLF = true;\n      }\n      else\n        line += (column = 1);\n    }\n    switch (c)\n    {\n      case '\\r' :\n        prevCharIsCR = true;\n        break;\n      case '\\n' :\n        prevCharIsLF = true;\n        break;\n      case '\\t' :\n        column--;\n        column += (tabSize - (column % tabSize));\n        break;\n      default :\n        break;\n    }\n    bufline[bufpos] = line;\n    bufcolumn[bufpos] = column;\n  }\n/** Read a character. */\n  public char readChar() throws java.io.IOException\n  {\n    if (inBuf > 0)\n    {\n      --inBuf;\n      if (++bufpos == bufsize)\n        bufpos = 0;\n      return buffer[bufpos];\n    }\n    char c;\n    if (++bufpos == available)\n      AdjustBuffSize();\n    if ((buffer[bufpos] = c = ReadByte()) == '\\\\')\n    {\n      if (trackLineColumn) { UpdateLineColumn(c); }\n      int backSlashCnt = 1;\n      for (;;) // Read all the backslashes\n      {\n        if (++bufpos == available)\n          AdjustBuffSize();\n        try\n        {\n          if ((buffer[bufpos] = c = ReadByte()) != '\\\\')\n          {\n            if (trackLineColumn) { UpdateLineColumn(c); }\n            // found a non-backslash char.\n            if ((c == 'u') && ((backSlashCnt & 1) == 1))\n            {\n              if (--bufpos < 0)\n                bufpos = bufsize - 1;\n              break;\n            }\n            backup(backSlashCnt);\n            return '\\\\';\n          }\n        }\n        catch(java.io.IOException e)\n        {\n\t  // We are returning one backslash so we should only backup (count-1)\n          if (backSlashCnt > 1)\n            backup(backSlashCnt-1);\n          return '\\\\';\n        }\n        if (trackLineColumn) { UpdateLineColumn(c); }\n        backSlashCnt++;\n      }\n      // Here, we have seen an odd number of backslash's followed by a 'u'\n      try\n      {\n        while ((c = ReadByte()) == 'u')\n          ++column;\n        buffer[bufpos] = c = (char)(hexval(c) << 12 |\n                                    hexval(ReadByte()) << 8 |\n                                    hexval(ReadByte()) << 4 |\n                                    hexval(ReadByte()));\n        column += 4;\n      }\n      catch(java.io.IOException e)\n      {\n        throw new Error(\"Invalid escape character at line \" + line +\n                                         \" column \" + column + \".\");\n      }\n      if (backSlashCnt == 1)\n        return c;\n      else\n      {\n        backup(backSlashCnt - 1);\n        return '\\\\';\n      }\n    }\n    else\n    {\n      UpdateLineColumn(c);\n      return c;\n    }\n  }\n  @Deprecated\n  /**\n   * @deprecated\n   * @see #getEndColumn\n   */\n  public int getColumn() {\n    return bufcolumn[bufpos];\n  }\n  @Deprecated\n  /**\n   * @deprecated\n   * @see #getEndLine\n   */\n  public int getLine() {\n    return bufline[bufpos];\n  }\n/** Get end column. */\n  public int getEndColumn() {\n    return bufcolumn[bufpos];\n  }\n/** Get end line. */\n  public int getEndLine() {\n    return bufline[bufpos];\n  }\n/** @return column of token start */\n  public int getBeginColumn() {\n    return bufcolumn[tokenBegin];\n  }\n/** @return line number of token start */\n  public int getBeginLine() {\n    return bufline[tokenBegin];\n  }\n/** Retreat. */\n  public void backup(int amount) {\n    inBuf += amount;\n    if ((bufpos -= amount) < 0)\n      bufpos += bufsize;\n  }\n/** Constructor. */\n  public JavaCharStream(java.io.Reader dstream,\n                 int startline, int startcolumn, int buffersize)\n  {\n    inputStream = dstream;\n    line = startline;\n    column = startcolumn - 1;\n    available = bufsize = buffersize;\n    buffer = new char[buffersize];\n    bufline = new int[buffersize];\n    bufcolumn = new int[buffersize];\n    nextCharBuf = new char[4096];\n  }\n/** Constructor. */\n  public JavaCharStream(java.io.Reader dstream,\n                                        int startline, int startcolumn)\n  {\n    this(dstream, startline, startcolumn, 4096);\n  }\n/** Constructor. */\n  public JavaCharStream(java.io.Reader dstream)\n  {\n    this(dstream, 1, 1, 4096);\n  }\n/** Reinitialise. */\n  public void ReInit(java.io.Reader dstream,\n                 int startline, int startcolumn, int buffersize)\n  {\n    inputStream = dstream;\n    line = startline;\n    column = startcolumn - 1;\n    if (buffer == null || buffersize != buffer.length)\n    {\n      available = bufsize = buffersize;\n      buffer = new char[buffersize];\n      bufline = new int[buffersize];\n      bufcolumn = new int[buffersize];\n      nextCharBuf = new char[4096];\n    }\n    prevCharIsLF = prevCharIsCR = false;\n    tokenBegin = inBuf = maxNextCharInd = 0;\n    nextCharInd = bufpos = -1;\n  }\n/** Reinitialise. */\n  public void ReInit(java.io.Reader dstream,\n                                        int startline, int startcolumn)\n  {\n    ReInit(dstream, startline, startcolumn, 4096);\n  }\n/** Reinitialise. */\n  public void ReInit(java.io.Reader dstream)\n  {\n    ReInit(dstream, 1, 1, 4096);\n  }\n/** Constructor. */\n<fim_suffix>  public JavaCharStream(java.io.InputStream dstream, String encoding, int startline,\n  int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException\n  {\n    this(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);\n  }<fim_middle>// function below has no smell\n"}