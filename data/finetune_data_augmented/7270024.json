{"text": "<fim_prefix> * \"[Contributor] elects to include this software in this distribution\n * under the [CDDL or GPL Version 2] license.\" If you do not indicate a\n * single choice of license, a recipient has the option to distribute\n * your version of this file under either the CDDL, the GPL Version 2 or\n * to extend the choice of license to its licensees as provided above.\n * However, if you add GPL Version 2 code and therefore, elected the GPL\n * Version 2 license, then the option applies only if the new code is\n * made subject to such option by the copyright holder.\n */\npackage org.graalvm.visualvm.lib.charts.xy.synchronous;\nimport org.graalvm.visualvm.lib.charts.swing.Utils;\nimport org.graalvm.visualvm.lib.charts.ChartContext;\nimport org.graalvm.visualvm.lib.charts.ChartItem;\nimport org.graalvm.visualvm.lib.charts.ChartItemChange;\nimport org.graalvm.visualvm.lib.charts.ItemSelection;\nimport org.graalvm.visualvm.lib.charts.swing.LongRect;\nimport org.graalvm.visualvm.lib.charts.xy.XYItem;\nimport org.graalvm.visualvm.lib.charts.xy.XYItemChange;\nimport org.graalvm.visualvm.lib.charts.xy.XYItemPainter;\nimport org.graalvm.visualvm.lib.charts.xy.XYItemSelection;\nimport java.awt.BasicStroke;\nimport java.awt.Color;\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.awt.Stroke;\nimport java.util.List;\n/**\n *\n * @author Jiri Sedlacek\n */\npublic class SynchronousXYItemMarker extends XYItemPainter.Abstract {\n    protected final int markRadius;\n    protected final int line1Width;\n    protected final Color line1Color;\n    protected final int line2Width;\n    protected final Color line2Color;\n    protected final Color fillColor;\n    protected final Stroke line1Stroke;\n    protected final Stroke line2Stroke;\n    protected final int decorationRadius;\n    protected final int type;\n    protected final int maxValueOffset;\n    // --- Constructor ---------------------------------------------------------\n    public static SynchronousXYItemMarker absolutePainter(int markRadius,\n                                                       float line1Width,\n                                                       Color line1Color,\n                                                       float line2Width,\n                                                       Color line2Color,\n                                                       Color fillColor) {\n        return new SynchronousXYItemMarker(markRadius, line1Width, line1Color,\n                                        line2Width, line2Color, fillColor,\n                                        TYPE_ABSOLUTE, 0);\n    }\n    public static SynchronousXYItemMarker relativePainter(int markRadius,\n                                                       float line1Width,\n                                                       Color line1Color,\n                                                       float line2Width,\n                                                       Color line2Color,\n                                                       Color fillColor,\n                                                       int maxOffset) {\n        return new SynchronousXYItemMarker(markRadius, line1Width, line1Color,\n                                        line2Width, line2Color, fillColor,\n                                        TYPE_RELATIVE, maxOffset);\n    }\n    public SynchronousXYItemMarker(int markRadius, float line1Width, Color line1Color,\n                                 float line2Width, Color line2Color, Color fillColor,\n                                 int type, int maxValueOffset) {\n        if (line1Color == null && line2Color == null && fillColor == null)\n            throw new IllegalArgumentException(\"No parameters defined\"); // NOI18N\n        this.markRadius = markRadius;\n        this.line1Width = (int)Math.ceil(line1Width);\n        this.line1Color = Utils.checkedColor(line1Color);\n        this.line2Width = (int)Math.ceil(line2Width);\n        this.line2Color = Utils.checkedColor(line2Color);\n        this.fillColor = Utils.checkedColor(fillColor);\n        this.line1Stroke = line1Color == null ? null :\n                           new BasicStroke(line1Width, BasicStroke.CAP_ROUND,\n                                           BasicStroke.JOIN_ROUND);\n        this.line2Stroke = line2Color == null ? null :\n                           new BasicStroke(line2Width, BasicStroke.CAP_ROUND,\n                                         BasicStroke.JOIN_ROUND);\n        decorationRadius = markRadius + this.line1Width + this.line2Width;\n        this.type = type;\n        this.maxValueOffset = maxValueOffset;\n    }\n    // --- ItemPainter implementation ------------------------------------------\n    public LongRect getItemBounds(ChartItem item) {\n//        if (!(item instanceof ProfilerXYItem))\n//            throw new UnsupportedOperationException(\"Unsupported item: \" + item); // NOI18N\n        SynchronousXYItem xyItem = (SynchronousXYItem)item;\n        if (type == TYPE_ABSOLUTE) {\n            return xyItem.getBounds();\n        } else {\n            LongRect itemBounds1 = new LongRect(xyItem.getBounds());\n            itemBounds1.y = 0;\n            itemBounds1.height = 0;\n            return itemBounds1;\n        }\n    }\n    public LongRect getItemBounds(ChartItem item, ChartContext context) {\n//        if (!(item instanceof ProfilerXYItem))\n//            throw new UnsupportedOperationException(\"Unsupported item: \" + item); // NOI18N\n        SynchronousXYItem xyItem = (SynchronousXYItem)item;\n        return getViewBounds(xyItem, null, context);\n    }\n    public boolean isBoundsChange(ChartItemChange itemChange) {\n//        if (!(itemChange instanceof XYItemChange))\n//            throw new UnsupportedOperationException(\"Unsupported itemChange: \" + itemChange);\n        // Items can only be added => always bounds change\n        XYItemChange change = (XYItemChange)itemChange;\n        return !LongRect.equals(change.getOldValuesBounds(),\n                                change.getNewValuesBounds());\n    }\n    public boolean isAppearanceChange(ChartItemChange itemChange) {\n//        if (!(itemChange instanceof XYItemChange))\n//            throw new UnsupportedOperationException(\"Unsupported itemChange: \" + itemChange);\n        // Items can only be added => always appearance change\n        XYItemChange change = (XYItemChange)itemChange;\n        LongRect dirtyBounds = change.getDirtyValuesBounds();\n        return dirtyBounds.width != 0 || dirtyBounds.height != 0;\n    }\n    public LongRect getDirtyBounds(ChartItemChange itemChange, ChartContext context) {\n//        if (!(itemChange instanceof XYItemChange))\n//            throw new UnsupportedOperationException(\"Unsupported itemChange: \" + itemChange);\n        // Items can only be added => always dirty bounds for last value\n        XYItemChange change = (XYItemChange)itemChange;\n        return getViewBounds(change.getItem(), change.getValuesIndexes(), context);\n    }\n    public boolean supportsHovering(ChartItem item) {\n        return true;\n    }\n    public boolean supportsSelecting(ChartItem item) {\n        return true;\n    }\n    public LongRect getSelectionBounds(ItemSelection selection, ChartContext context) {\n//        if (!(selection instanceof XYItemSelection))\n//            throw new UnsupportedOperationException(\"Unsupported selection: \" + selection); // NOI18N\n        XYItemSelection sel = (XYItemSelection)selection;\n        XYItem item  = sel.getItem();\n        int selectedValueIndex = sel.getValueIndex();\n        if (selectedValueIndex == -1 ||\n            selectedValueIndex >= item.getValuesCount())\n            // This happens on reset - bounds of the selection are unknown, let's clear whole area\n            return new LongRect(0, 0, context.getViewportWidth(),\n                                context.getViewportHeight());\n        else\n            return getViewBounds(item, new int[] { sel.getValueIndex() }, context);\n    }\n    public XYItemSelection getClosestSelection(ChartItem item, int viewX,\n                                               int viewY, ChartContext context) {\n//        if (!(item instanceof ProfilerXYItem))\n//            throw new UnsupportedOperationException(\"Unsupported item: \" + item); // NOI18N\n//        if (!(context instanceof ProfilerXYChartComponent.Context))\n//            throw new UnsupportedOperationException(\"Unsupported context: \" + context);\n        SynchronousXYChartContext contx = (SynchronousXYChartContext)context;\n        int nearestTimestampIndex = contx.getNearestTimestampIndex(viewX, viewY);\n        if (nearestTimestampIndex == -1) return null; // item not visible\n        SynchronousXYItem xyItem = (SynchronousXYItem)item;\n        return new XYItemSelection.Default(xyItem, nearestTimestampIndex);\n    }\n<fim_suffix>    public void paintItem(ChartItem item, List<ItemSelection> highlighted,\n                          List<ItemSelection> selected, Graphics2D g,\n                          Rectangle dirtyArea, ChartContext context) {\n//        if (!(item instanceof ProfilerXYItem))\n//            throw new UnsupportedOperationException(\"Unsupported item: \" + item); // NOI18N\n//        if (!(context instanceof ProfilerXYChartComponent.Context))\n//            throw new UnsupportedOperationException(\"Unsupported context: \" + context);\n        paint((SynchronousXYItem)item, highlighted, selected, g, dirtyArea,\n              (SynchronousXYChartContext)context);\n    }<fim_middle>// function below has no smell\n"}