{"text": "<fim_prefix>/*\n * MIT License\n *\n * Copyright (c) 2016 EPAM Systems\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\npackage com.epam.catgenome.dao.reference;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Required;\nimport org.springframework.jdbc.core.RowMapper;\nimport org.springframework.jdbc.core.namedparam.MapSqlParameterSource;\nimport org.springframework.jdbc.core.namedparam.NamedParameterJdbcDaoSupport;\nimport org.springframework.transaction.annotation.Propagation;\nimport org.springframework.transaction.annotation.Transactional;\nimport com.epam.catgenome.dao.BiologicalDataItemDao;\nimport com.epam.catgenome.dao.DaoHelper;\nimport com.epam.catgenome.entity.BiologicalDataItem;\nimport com.epam.catgenome.entity.reference.Bookmark;\nimport com.epam.catgenome.entity.reference.Chromosome;\n/**\n * <p>\n * A DAO class to handle database operations with {@code Bookmark} entities.\n * </p>\n */\npublic class BookmarkDao extends NamedParameterJdbcDaoSupport {\n    private String bookmarkSequenceName;\n    private String bookmarkItemSequenceName;\n    private String insertBookmarkQuery;\n    private String updateBookmarkQuery;\n    private String loadAllBookmarksQuery;\n    private String searchBookmarksQuery;\n    private String searchBookmarkCountQuery;\n    private String loadBookmarkByIdQuery;\n    private String loadBookmarksByIdsQuery;\n    private String deleteBookmarkQuery;\n    private String insertBookmarkItemsQuery;\n    private String deleteBookmarkItemsQuery;\n    private String loadBookmarksItemsQuery;\n    @Autowired\n    private DaoHelper daoHelper;\n    /**\n     * Saves a database entity to a database. To perform a {@code Bookmark} update, an ID should be set.\n     * @param bookmark a {@code Bookmark} to save\n     */\n    @Transactional(propagation = Propagation.MANDATORY)\n    public void saveBookmark(Bookmark bookmark) {\n        if (bookmark.getId() == null) {\n            bookmark.setId(daoHelper.createId(bookmarkSequenceName));\n            getNamedParameterJdbcTemplate().update(insertBookmarkQuery, BookmarkParameters.getParameters(bookmark));\n        } else {\n            getNamedParameterJdbcTemplate().update(updateBookmarkQuery, BookmarkParameters.getParameters(bookmark));\n        }\n    }\n    /**\n     * Loads {@code Bookmark} entities, saved for given project ID and chromosome ID\n     * @return {@code List&lt;Bookmark&gt;}\n     */\n    @Transactional(propagation = Propagation.SUPPORTS)\n    public List<Bookmark> loadAllBookmarks(long userId) {\n        return getJdbcTemplate().query(loadAllBookmarksQuery, BookmarkParameters.getRowMapper(), userId);\n    }\n    @Transactional(propagation = Propagation.SUPPORTS)\n    public List<Bookmark> searchBookmarks(String searchStr, long userId, int limit) {\n        MapSqlParameterSource params = new MapSqlParameterSource();\n        params.addValue(BookmarkParameters.BOOKMARK_NAME.name(), searchStr + '%');\n        params.addValue(BookmarkParameters.CREATED_BY.name(), userId);\n        params.addValue(\"SEARCH_LIMIT\", limit);\n        return getNamedParameterJdbcTemplate().query(searchBookmarksQuery, params, BookmarkParameters.getRowMapper());\n    }\n    @Transactional(propagation = Propagation.SUPPORTS)\n    public int searchBookmarkCount(String searchStr, long userId) {\n        MapSqlParameterSource params = new MapSqlParameterSource();\n        params.addValue(BookmarkParameters.BOOKMARK_NAME.name(), searchStr + '%');\n        params.addValue(BookmarkParameters.CREATED_BY.name(), userId);\n        return getNamedParameterJdbcTemplate().queryForObject(searchBookmarkCountQuery, params, Integer.class);\n    }\n    /**\n     * Loads a {@code Bookmark} entity, saved for given ID\n     * @param bookmarkId {@code Long} a {@code Bookmark} to load\n     * @return {@code Bookmark}\n     */\n    @Transactional(propagation = Propagation.SUPPORTS)\n    public Bookmark loadBookmarkById(long bookmarkId) {\n        List<Bookmark> bookmarks = getJdbcTemplate().query(loadBookmarkByIdQuery, BookmarkParameters.getRowMapper(),\n                bookmarkId);\n        return bookmarks.isEmpty() ? null : bookmarks.get(0);\n    }\n    /**\n     * Loads a {@code List} of {@code Bookmark} entities, saved for given IDs\n     * @param bookmarkIds {@code List} of {@code Bookmark} IDs to load\n     * @return {@code Bookmark}\n     */\n    @Transactional(propagation = Propagation.MANDATORY)\n    public List<Bookmark> loadBookmarksByIds(final Collection<Long> bookmarkIds) {\n        if (bookmarkIds == null || bookmarkIds.isEmpty()) {\n            return Collections.emptyList();\n        }\n        Long listId = daoHelper.createTempLongList(bookmarkIds);\n        List<Bookmark> bookmarks = getJdbcTemplate().query(loadBookmarksByIdsQuery, BookmarkParameters.getRowMapper(),\n                listId);\n        daoHelper.clearTempList(listId);\n        return bookmarks;\n    }\n    /**\n     * Deletes a {@code Bookmark} entity, specified by ID\n     * @param bookmarkId {@code Long} an ID of a bookmark to delete\n     */\n    @Transactional(propagation = Propagation.MANDATORY)\n    public void deleteBookmark(long bookmarkId) {\n        getJdbcTemplate().update(deleteBookmarkQuery, bookmarkId);\n    }\n    /**\n     * Saves bookmarked {@code ProjectItem} entities into the database\n     * @param bookmarkItems a {@code List&lt;ProjectItem&gt;} of bookmarked project items to save\n     * @param bookmarkId an ID of a bookmark to save items\n     */\n    @Transactional(propagation = Propagation.MANDATORY)\n    public void insertBookmarkItems(List<BiologicalDataItem> bookmarkItems, long bookmarkId) {\n        if (bookmarkItems == null || bookmarkItems.isEmpty()) {\n            return;\n        }\n        getNamedParameterJdbcTemplate().batchUpdate(insertBookmarkItemsQuery, BookmarkItemParameters.getParameters(\n                bookmarkItems, bookmarkId, daoHelper, bookmarkItemSequenceName));\n    }\n    /**\n     * Deletes bookmarked project items for a given bookmark ID\n     * @param bookmarkId {@code Long} a bookmark ID to delete items\n     */\n    @Transactional(propagation = Propagation.MANDATORY)\n    public void deleteBookmarkItems(long bookmarkId) {\n        getJdbcTemplate().update(deleteBookmarkItemsQuery, bookmarkId);\n    }\n    /**\n     * Loads bookmarked project items by given list of bookmark IDs\n     * @param bookmarkIds a {@code List&lt;Long&gt;} of bookmarks IDs to load items for\n     * @return a {@code Map} of {@code List}s of {@code ProjectItem}, mapped to their bookmark's IDs\n     */\n<fim_suffix>    @Transactional(propagation = Propagation.MANDATORY)\n    public Map<Long, List<BiologicalDataItem>> loadBookmarkItemsByBookmarkIds(Collection<Long> bookmarkIds) {\n        if (bookmarkIds == null || bookmarkIds.isEmpty()) {\n            return Collections.emptyMap();\n        }\n        Long listId = daoHelper.createTempLongList(bookmarkIds);\n        Map<Long, List<BiologicalDataItem>> itemsMap = new HashMap<>();\n        getJdbcTemplate().query(loadBookmarksItemsQuery, rs -> {\n            BiologicalDataItem dataItem = BiologicalDataItemDao.BiologicalDataItemParameters.getRowMapper()\n                .mapRow(rs, 0);\n            long bookmarkId = rs.getLong(BookmarkItemParameters.BOOKMARK_ID.name());\n            if (!itemsMap.containsKey(bookmarkId)) {\n                itemsMap.put(bookmarkId, new ArrayList<>());\n            }\n            itemsMap.get(bookmarkId).add(dataItem);\n        }, listId);\n        daoHelper.clearTempList(listId);\n        return itemsMap;\n    }\n    enum BookmarkParameters {<fim_middle>// function below is long method\n"}