{"text": "<fim_prefix>                System.arraycopy(srcPts, srcOff, dstPts, dstOff,\n                                 numPts * 2);\n            }\n            return;\n        }\n        /* NOTREACHED */\n    }\n    /**\n     * Transforms the relative distance vector specified by\n     * {@code ptSrc} and stores the result in {@code ptDst}.\n     * A relative distance vector is transformed without applying the\n     * translation components of the affine transformation matrix\n     * using the following equations:\n     * <pre>\n     *  [  x' ]   [  m00  m01 (m02) ] [  x  ]   [ m00x + m01y ]\n     *  [  y' ] = [  m10  m11 (m12) ] [  y  ] = [ m10x + m11y ]\n     *  [ (1) ]   [  (0)  (0) ( 1 ) ] [ (1) ]   [     (1)     ]\n     * </pre>\n     * If {@code ptDst} is {@code null}, a new\n     * {@code Point2D} object is allocated and then the result of the\n     * transform is stored in this object.\n     * In either case, {@code ptDst}, which contains the\n     * transformed point, is returned for convenience.\n     * If {@code ptSrc} and {@code ptDst} are the same object,\n     * the input point is correctly overwritten with the transformed\n     * point.\n     * @param ptSrc the distance vector to be delta transformed\n     * @param ptDst the resulting transformed distance vector\n     * @return {@code ptDst}, which contains the result of the\n     * transformation.\n     * @since 1.2\n     */\n    public Point2D deltaTransform(Point2D ptSrc, Point2D ptDst) {\n        if (ptDst == null) {\n            if (ptSrc instanceof Point2D.Double) {\n                ptDst = new Point2D.Double();\n            } else {\n                ptDst = new Point2D.Float();\n            }\n        }\n        // Copy source coords into local variables in case src == dst\n        double x = ptSrc.getX();\n        double y = ptSrc.getY();\n        switch (state) {\n        default:\n            stateError();\n            /* NOTREACHED */\n            return null;\n        case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):\n        case (APPLY_SHEAR | APPLY_SCALE):\n            ptDst.setLocation(x * m00 + y * m01, x * m10 + y * m11);\n            return ptDst;\n        case (APPLY_SHEAR | APPLY_TRANSLATE):\n        case (APPLY_SHEAR):\n            ptDst.setLocation(y * m01, x * m10);\n            return ptDst;\n        case (APPLY_SCALE | APPLY_TRANSLATE):\n        case (APPLY_SCALE):\n            ptDst.setLocation(x * m00, y * m11);\n            return ptDst;\n        case (APPLY_TRANSLATE):\n        case (APPLY_IDENTITY):\n            ptDst.setLocation(x, y);\n            return ptDst;\n        }\n        /* NOTREACHED */\n    }\n    /**\n     * Transforms an array of relative distance vectors by this\n     * transform.\n     * A relative distance vector is transformed without applying the\n     * translation components of the affine transformation matrix\n     * using the following equations:\n     * <pre>\n     *  [  x' ]   [  m00  m01 (m02) ] [  x  ]   [ m00x + m01y ]\n     *  [  y' ] = [  m10  m11 (m12) ] [  y  ] = [ m10x + m11y ]\n     *  [ (1) ]   [  (0)  (0) ( 1 ) ] [ (1) ]   [     (1)     ]\n     * </pre>\n     * The two coordinate array sections can be exactly the same or\n     * can be overlapping sections of the same array without affecting the\n     * validity of the results.\n     * This method ensures that no source coordinates are\n     * overwritten by a previous operation before they can be transformed.\n     * The coordinates are stored in the arrays starting at the indicated\n     * offset in the order {@code [x0, y0, x1, y1, ..., xn, yn]}.\n     * @param srcPts the array containing the source distance vectors.\n     * Each vector is stored as a pair of relative x,&nbsp;y coordinates.\n     * @param dstPts the array into which the transformed distance vectors\n     * are returned.  Each vector is stored as a pair of relative\n     * x,&nbsp;y coordinates.\n     * @param srcOff the offset to the first vector to be transformed\n     * in the source array\n     * @param dstOff the offset to the location of the first\n     * transformed vector that is stored in the destination array\n     * @param numPts the number of vector coordinate pairs to be\n     * transformed\n     * @since 1.2\n     */\n    public void deltaTransform(double[] srcPts, int srcOff,\n                               double[] dstPts, int dstOff,\n                               int numPts) {\n        double M00, M01, M10, M11;      // For caching\n        if (dstPts == srcPts &&\n            dstOff > srcOff && dstOff < srcOff + numPts * 2)\n        {\n            // If the arrays overlap partially with the destination higher\n            // than the source and we transform the coordinates normally\n            // we would overwrite some of the later source coordinates\n            // with results of previous transformations.\n            // To get around this we use arraycopy to copy the points\n            // to their final destination with correct overwrite\n            // handling and then transform them in place in the new\n            // safer location.\n            System.arraycopy(srcPts, srcOff, dstPts, dstOff, numPts * 2);\n            // srcPts = dstPts;         // They are known to be equal.\n            srcOff = dstOff;\n        }\n        switch (state) {\n        default:\n            stateError();\n            /* NOTREACHED */\n            return;\n        case (APPLY_SHEAR | APPLY_SCALE | APPLY_TRANSLATE):\n        case (APPLY_SHEAR | APPLY_SCALE):\n            M00 = m00; M01 = m01;\n            M10 = m10; M11 = m11;\n            while (--numPts >= 0) {\n                double x = srcPts[srcOff++];\n                double y = srcPts[srcOff++];\n                dstPts[dstOff++] = x * M00 + y * M01;\n                dstPts[dstOff++] = x * M10 + y * M11;\n            }\n            return;\n        case (APPLY_SHEAR | APPLY_TRANSLATE):\n        case (APPLY_SHEAR):\n            M01 = m01; M10 = m10;\n            while (--numPts >= 0) {\n                double x = srcPts[srcOff++];\n                dstPts[dstOff++] = srcPts[srcOff++] * M01;\n                dstPts[dstOff++] = x * M10;\n            }\n            return;\n        case (APPLY_SCALE | APPLY_TRANSLATE):\n        case (APPLY_SCALE):\n            M00 = m00; M11 = m11;\n            while (--numPts >= 0) {\n                dstPts[dstOff++] = srcPts[srcOff++] * M00;\n                dstPts[dstOff++] = srcPts[srcOff++] * M11;\n            }\n            return;\n        case (APPLY_TRANSLATE):\n        case (APPLY_IDENTITY):\n            if (srcPts != dstPts || srcOff != dstOff) {\n                System.arraycopy(srcPts, srcOff, dstPts, dstOff,\n                                 numPts * 2);\n            }\n            return;\n        }\n        /* NOTREACHED */\n    }\n    /**\n     * Returns a new {@link Shape} object defined by the geometry of the\n     * specified {@code Shape} after it has been transformed by\n     * this transform.\n     * @param pSrc the specified {@code Shape} object to be\n     * transformed by this transform.\n     * @return a new {@code Shape} object that defines the geometry\n     * of the transformed {@code Shape}, or null if {@code pSrc} is null.\n     * @since 1.2\n     */\n<fim_suffix>    public Shape createTransformedShape(Shape pSrc) {\n        if (pSrc == null) {\n            return null;\n        }\n        return new Path2D.Double(pSrc, this);\n    }<fim_middle>// function below has no smell\n"}