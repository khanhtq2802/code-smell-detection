{"text": "<fim_prefix>\n<fim_suffix>public class PeriodFormatterData {\n  final DataRecord dr;\n  String localeName;\n  // debug\n  public static boolean trace = false;\n  public PeriodFormatterData(String localeName, DataRecord dr) {\n    this.dr = dr;\n    this.localeName = localeName;\n    if(localeName == null) {\n        throw new NullPointerException(\"localename is null\");\n    }\n//    System.err.println(\"** localeName is \" + localeName);\n    if (dr == null) {\n//      Thread.dumpStack();\n      throw new NullPointerException(\"data record is null\");\n    }\n  }\n  // none - chinese (all forms the same)\n  // plural - english, special form for 1\n  // dual - special form for 1 and 2\n  // paucal - russian, special form for 1, for 2-4 and n > 20 && n % 10 == 2-4\n  // rpt_dual_few - slovenian, special form for 1, 2, 3-4 and n as above\n  // hebrew, dual plus singular form for years > 11\n  // arabic, dual, plus singular form for all terms > 10\n  /**\n   * Return the pluralization format used by this locale.\n   * @return the pluralization format\n   */\n  public int pluralization() {\n    return dr.pl;\n  }\n  /**\n   * Return true if zeros are allowed in the display.\n   * @return true if zeros should be allowed\n   */\n  public boolean allowZero() {\n    return dr.allowZero;\n  }\n  public boolean weeksAloneOnly() {\n    return dr.weeksAloneOnly;\n  }\n  public int useMilliseconds() {\n    return dr.useMilliseconds;\n  }\n  /**\n   * Append the appropriate prefix to the string builder, depending on whether and\n   * how a limit and direction are to be displayed.\n   *\n   * @param tl how and whether to display the time limit\n   * @param td how and whether to display the time direction\n   * @param sb the string builder to which to append the text\n   * @return true if a following digit will require a digit prefix\n   */\n  public boolean appendPrefix(int tl, int td, StringBuffer sb) {\n    if (dr.scopeData != null) {\n      int ix = tl * 3 + td;\n      ScopeData sd = dr.scopeData[ix];\n      if (sd != null) {\n        String prefix = sd.prefix;\n        if (prefix != null) {\n          sb.append(prefix);\n          return sd.requiresDigitPrefix;\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * Append the appropriate suffix to the string builder, depending on whether and\n   * how a limit and direction are to be displayed.\n   *\n   * @param tl how and whether to display the time limit\n   * @param td how and whether to display the time direction\n   * @param sb the string builder to which to append the text\n   */\n  public void appendSuffix(int tl, int td, StringBuffer sb) {\n    if (dr.scopeData != null) {\n      int ix = tl * 3 + td;\n      ScopeData sd = dr.scopeData[ix];\n      if (sd != null) {\n        String suffix = sd.suffix;\n        if (suffix != null) {\n          if (trace) {\n            System.out.println(\"appendSuffix '\" + suffix + \"'\");\n          }\n          sb.append(suffix);\n        }\n      }\n    }\n  }\n  /**\n   * Append the count and unit to the string builder.\n   *\n   * @param unit the unit to append\n   * @param count the count of units, * 1000\n   * @param cv the format to use for displaying the count\n   * @param uv the format to use for displaying the unit\n   * @param useCountSep if false, force no separator between count and unit\n   * @param useDigitPrefix if true, use the digit prefix\n   * @param multiple true if there are multiple units in this string\n   * @param last true if this is the last unit\n   * @param wasSkipped true if the unit(s) before this were skipped\n   * @param sb the string builder to which to append the text\n   * @return true if will require skip marker\n   */\n  @SuppressWarnings(\"fallthrough\")\n  public boolean appendUnit(TimeUnit unit, int count, int cv, \n                            int uv, boolean useCountSep, \n                            boolean useDigitPrefix, boolean multiple, \n                            boolean last, boolean wasSkipped, \n                            StringBuffer sb) {\n    int px = unit.ordinal();\n    boolean willRequireSkipMarker = false;\n    if (dr.requiresSkipMarker != null && dr.requiresSkipMarker[px] && \n        dr.skippedUnitMarker != null) {\n      if (!wasSkipped && last) {\n        sb.append(dr.skippedUnitMarker);\n      }\n      willRequireSkipMarker = true;\n    }\n    if (uv != EUnitVariant.PLURALIZED) {\n      boolean useMedium = uv == EUnitVariant.MEDIUM; \n      String[] names = useMedium ? dr.mediumNames : dr.shortNames;\n      if (names == null || names[px] == null) {\n        names = useMedium ? dr.shortNames : dr.mediumNames;\n      }\n      if (names != null && names[px] != null) {\n        appendCount(unit, false, false, count, cv, useCountSep, \n                    names[px], last, sb); // omit suffix, ok?\n        return false; // omit skip marker\n      }\n    }\n    // check cv\n    if (cv == ECountVariant.HALF_FRACTION && dr.halfSupport != null) {\n      switch (dr.halfSupport[px]) {\n        case EHalfSupport.YES: break;\n        case EHalfSupport.ONE_PLUS:\n          if (count > 1000) {\n            break;\n          }\n          // else fall through to decimal\n        case EHalfSupport.NO: {\n          count = (count / 500) * 500;  // round to 1/2\n          cv = ECountVariant.DECIMAL1; \n        } break;\n      }\n    }\n    String name = null;\n    int form = computeForm(unit, count, cv, multiple && last);\n    if (form == FORM_SINGULAR_SPELLED) {\n      if (dr.singularNames == null) {\n        form = FORM_SINGULAR;\n        name = dr.pluralNames[px][form];\n      } else {\n        name = dr.singularNames[px];\n      }\n    } else if (form == FORM_SINGULAR_NO_OMIT) {\n      name = dr.pluralNames[px][FORM_SINGULAR];\n    } else if (form == FORM_HALF_SPELLED) {\n      name = dr.halfNames[px];\n    } else { \n      try {\n        name = dr.pluralNames[px][form];\n      } catch (NullPointerException e) {\n        System.out.println(\"Null Pointer in PeriodFormatterData[\"+localeName+\"].au px: \" + px + \" form: \" + form + \" pn: \" + Arrays.toString(dr.pluralNames));\n        throw e;\n      }\n    }\n    if (name == null) {\n      form = FORM_PLURAL;\n      name = dr.pluralNames[px][form];\n    }\n    boolean omitCount =\n      (form == FORM_SINGULAR_SPELLED || form == FORM_HALF_SPELLED) ||\n      (dr.omitSingularCount && form == FORM_SINGULAR) ||\n      (dr.omitDualCount && form == FORM_DUAL);\n    int suffixIndex = appendCount(unit, omitCount, useDigitPrefix, count, cv, \n                                  useCountSep, name, last, sb);\n    if (last && suffixIndex >= 0) {\n      String suffix = null;\n      if (dr.rqdSuffixes != null && suffixIndex < dr.rqdSuffixes.length) {\n        suffix = dr.rqdSuffixes[suffixIndex];\n      }\n      if (suffix == null && dr.optSuffixes != null && \n          suffixIndex < dr.optSuffixes.length) {\n        suffix = dr.optSuffixes[suffixIndex];\n      }\n      if (suffix != null) {\n        sb.append(suffix);\n      }\n    }\n    return willRequireSkipMarker;\n  }\n  /**\n   * Append a count to the string builder.\n   *\n   * @param unit the unit\n   * @param count the count\n   * @param cv the format to use for displaying the count\n   * @param useSep whether to use the count separator, if available\n   * @param name the term name\n   * @param last true if this is the last unit to be formatted\n   * @param sb the string builder to which to append the text\n   * @return index to use if might have required or optional suffix, or -1 if none required\n   */\n  public int appendCount(TimeUnit unit, boolean omitCount, \n                         boolean useDigitPrefix, \n                         int count, int cv, boolean useSep, \n                         String name, boolean last, StringBuffer sb) {\n    if (cv == ECountVariant.HALF_FRACTION && dr.halves == null) {\n      cv = ECountVariant.INTEGER;\n    }\n    if (!omitCount && useDigitPrefix && dr.digitPrefix != null) {<fim_middle>// class below has no smell\n"}