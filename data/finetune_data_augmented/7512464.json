{"text": "<fim_prefix>/*\n * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * The Universal Permissive License (UPL), Version 1.0\n *\n * Subject to the condition set forth below, permission is hereby granted to any\n * person obtaining a copy of this software, associated documentation and/or\n * data (collectively the \"Software\"), free of charge and under any and all\n * copyright rights in the Software, and any and all patent rights owned or\n * freely licensable by each licensor hereunder covering either (i) the\n * unmodified Software as contributed to or provided by such licensor, or (ii)\n * the Larger Works (as defined below), to deal in both\n *\n * (a) the Software, and\n *\n * (b) any piece of software and/or hardware listed in the lrgrwrks.txt file if\n * one is included with the Software each a \"Larger Work\" to which the Software\n * is contributed by such licensors),\n *\n * without restriction, including without limitation the rights to copy, create\n * derivative works of, display, perform, and distribute the Software and make,\n * use, sell, offer for sale, import, export, have made, and have sold the\n * Software and the Larger Work(s), and to sublicense the foregoing rights on\n * either these or other terms.\n *\n * This license is subject to the following condition:\n *\n * The above copyright notice and either this complete permission notice or at a\n * minimum a reference to the UPL must be included in all copies or substantial\n * portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\npackage com.oracle.truffle.api.source;\n\nimport java.net.URI;\nimport java.net.URL;\nimport java.util.Objects;\n\nimport org.graalvm.polyglot.io.ByteSequence;\n\nfinal class SourceImpl extends Source {\n\n    private final Key key;\n    private final Object sourceId;\n\n    private SourceImpl(Key key) {\n        this.key = key;\n        /*\n         * SourceImpl instances are interned so a single instance can identify it. We cannot use\n         * SourceImpl directly as the sourceId needs to be shared when a source is cloned.\n         */\n        this.sourceId = new SourceId(key.hashCode());\n    }\n\n    private SourceImpl(Key key, Object sourceId) {\n        this.key = key;\n        this.sourceId = sourceId;\n    }\n\n    @Override\n    protected Object getSourceId() {\n        return sourceId;\n    }\n\n    @Override\n    public CharSequence getCharacters() {\n        if (hasCharacters()) {\n            return (CharSequence) key.content;\n        } else {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    @Override\n    public ByteSequence getBytes() {\n        if (hasBytes()) {\n            return (ByteSequence) key.content;\n        } else {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    @Override\n    public boolean hasBytes() {\n        return key.content instanceof ByteSequence;\n    }\n\n    @Override\n    public boolean hasCharacters() {\n        return key.content instanceof CharSequence;\n    }\n\n    @Override\n    Source copy() {\n        return new SourceImpl(key, sourceId);\n    }\n\n    @Override\n    public boolean isCached() {\n        return key.cached;\n    }\n\n    @Override\n    public String getName() {\n        return key.name;\n    }\n\n    @Override\n    public String getPath() {\n        return key.path;\n    }\n\n    @Override\n    public boolean isInternal() {\n        return key.internal;\n    }\n\n    @Override\n    boolean isLegacy() {\n        return key.legacy;\n    }\n\n    @Override\n    public boolean isInteractive() {\n        return key.interactive;\n    }\n\n    @Override\n    public URL getURL() {\n        return key.url;\n    }\n\n    @Override\n    public URI getOriginalURI() {\n        return key.uri;\n    }\n\n    @Override\n    public String getMimeType() {\n        return key.mimeType;\n    }\n\n    @Override\n    public String getLanguage() {\n        return key.language;\n    }\n\n    Key toKey() {\n        return key;\n    }\n\n    private static final class SourceId {\n\n        /*\n         * We store the hash of the key to have stable source hashCode for each run.\n         */\n        final int hash;\n\n        SourceId(int hash) {\n            this.hash = hash;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            return this == obj;\n        }\n\n        @Override\n        public int hashCode() {\n            return hash;\n        }\n\n    }\n\n<fim_suffix>    static final class Key {\n\n        final Object content;\n        final URI uri;\n        final URL url;\n        final String name;\n        final String mimeType;\n        final String language;\n        final String path;\n        final boolean internal;\n        final boolean interactive;\n        final boolean cached;\n        // TODO remove legacy field with deprecated Source builders.\n        final boolean legacy;\n\n        Key(Object content, String mimeType, String languageId, URL url, URI uri, String name, String path, boolean internal, boolean interactive, boolean cached, boolean legacy) {\n            this.content = content;\n            this.mimeType = mimeType;\n            this.language = languageId;\n            this.name = name;\n            this.path = path;\n            this.internal = internal;\n            this.interactive = interactive;\n            this.cached = cached;\n            this.url = url;\n            this.uri = uri;\n            this.legacy = legacy;\n        }\n\n        @Override\n        public int hashCode() {\n            int result = 31 * 1 + ((content == null) ? 0 : content.hashCode());\n            result = 31 * result + (interactive ? 1231 : 1237);\n            result = 31 * result + (internal ? 1231 : 1237);\n            result = 31 * result + (cached ? 1231 : 1237);\n            result = 31 * result + ((language == null) ? 0 : language.hashCode());\n            result = 31 * result + ((mimeType == null) ? 0 : mimeType.hashCode());\n            result = 31 * result + ((name == null) ? 0 : name.hashCode());\n            result = 31 * result + ((path == null) ? 0 : path.hashCode());\n            result = 31 * result + ((uri == null) ? 0 : uri.hashCode());\n            result = 31 * result + ((url == null) ? 0 : url.hashCode());\n            return result;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) {\n                return true;\n            } else if (!(obj instanceof Key)) {\n                return false;\n            }\n            Key other = (Key) obj;\n            /*\n             * Compare characters last as it is likely the most expensive comparison in the worst\n             * case.\n             */\n            return Objects.equals(language, other.language) && //\n                            Objects.equals(mimeType, other.mimeType) && //\n                            Objects.equals(name, other.name) && //\n                            Objects.equals(path, other.path) && //\n                            Objects.equals(uri, other.uri) && //\n                            Objects.equals(url, other.url) && //\n                            interactive == other.interactive && //\n                            internal == other.internal &&\n                            cached == other.cached &&\n                            compareContent(other);\n        }\n\n        private boolean compareContent(Key other) {\n            Object otherContent = other.content;\n            if (content == other.content) {\n                return true;\n            } else if (content instanceof CharSequence && otherContent instanceof CharSequence) {\n                return compareCharacters((CharSequence) content, (CharSequence) otherContent);\n            } else if (content instanceof ByteSequence && otherContent instanceof ByteSequence) {\n                return compareBytes((ByteSequence) content, (ByteSequence) otherContent);\n            } else {\n                return false;\n            }\n        }\n\n        private static boolean compareBytes(ByteSequence bytes, ByteSequence other) {\n            if (bytes == null || bytes.length() != other.length()) {\n                return false;\n            } else {\n                // trusted class\n                return bytes.equals(other);\n            }\n        }\n\n        private static boolean compareCharacters(CharSequence characters, CharSequence other) {\n            if (characters == null || characters.length() != other.length()) {\n                return false;\n            } else {\n                return Objects.equals(characters.toString(), other.toString());\n            }\n        }\n\n        SourceImpl toSourceInterned() {\n            assert cached;\n            return new SourceImpl(this);\n        }\n\n        SourceImpl toSourceNotInterned() {\n            assert !cached;\n            return new SourceImpl(this, this);\n        }\n\n    }\n\n}<fim_middle>// class below has no smell\n"}