{"text": "<fim_prefix>/**\n * Copyright (c) 2018 Contributors to the Eclipse Foundation\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * https://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.eclipse.vorto.repository.generation.impl;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Set;\nimport org.eclipse.vorto.model.ModelId;\nimport org.eclipse.vorto.model.ModelType;\nimport org.eclipse.vorto.repository.core.IModelRepository;\nimport org.eclipse.vorto.repository.core.ModelInfo;\nimport org.eclipse.vorto.repository.core.ModelNotFoundException;\nimport org.eclipse.vorto.repository.generation.GeneratedOutput;\nimport org.eclipse.vorto.repository.generation.GenerationException;\nimport org.eclipse.vorto.repository.generation.GeneratorInfo;\nimport org.eclipse.vorto.repository.generation.IGeneratorService;\nimport org.modeshape.common.collection.Collections;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.http.HttpEntity;\nimport org.springframework.http.HttpHeaders;\nimport org.springframework.http.HttpMethod;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.http.converter.ByteArrayHttpMessageConverter;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.security.oauth2.provider.OAuth2Authentication;\nimport org.springframework.security.oauth2.provider.authentication.OAuth2AuthenticationDetails;\nimport org.springframework.stereotype.Service;\nimport org.springframework.web.client.RestTemplate;\n/**\n * @author Alexander Edelmann - Robert Bosch (SEA) Pte. Ltd.\n */\n@Service\npublic class GenerationDelegateProxyService implements IGeneratorService {\n  @Autowired\n  private IGeneratorLookupRepository registeredGeneratorsRepository;\n  @Autowired\n  private IModelRepository modelRepositoryService;\n  private RestTemplate restTemplate;\n  private static final Logger LOGGER =\n      LoggerFactory.getLogger(GenerationDelegateProxyService.class);\n  public GenerationDelegateProxyService() {\n    this.restTemplate = new RestTemplate();\n  }\n  @Override\n  public void registerGenerator(String serviceKey, String baseUrl) {\n    Generator generator = this.getGenerator(serviceKey);\n    if (generator == null) {\n      this.registeredGeneratorsRepository.save(new Generator(serviceKey, baseUrl, \"platform\"));\n    } else {\n      generator.setBaseUrl(baseUrl);\n      generator.setClassifier(\"platform\");\n      this.registeredGeneratorsRepository.save(generator);\n    }\n  }\n  @Override\n  public void unregisterGenerator(String serviceKey) {\n    Generator generator = getGenerator(serviceKey);\n    if (generator != null) {\n      this.registeredGeneratorsRepository.delete(generator);\n    }\n  }\n  @Override\n  public Set<String> getRegisteredGeneratorServiceKeys() {\n    Set<String> serviceKeys = new HashSet<>();\n    for (Generator generator : this.registeredGeneratorsRepository.findByClassifier(\"platform\")) {\n      serviceKeys.add(generator.getKey());\n    }\n    return Collections.unmodifiableSet(serviceKeys);\n  }\n  @Override\n  public GeneratorInfo getGeneratorServiceInfo(String serviceKey, boolean includeConfigUI) {\n    Generator generatorEntity = getGenerator(serviceKey);\n    GeneratorInfo generatorInfo = restTemplate.getForObject(\n        generatorEntity.getGenerationInfoUrl() + \"?includeConfigUI={includeConfigUI}\",\n        GeneratorInfo.class, includeConfigUI);\n    generatorInfo.setInfoUrl(generatorEntity.getGenerationInfoUrl());\n    generatorInfo.performRating(generatorEntity.getInvocationCount());\n    return generatorInfo;\n  }\n  @Override\n  public GeneratedOutput generate(ModelId modelId, String serviceKey,\n      Map<String, String> requestParams) {\n    ModelInfo modelResource = modelRepositoryService.getById(modelId);\n    if (modelResource == null) {\n      throw new ModelNotFoundException(\"Model with the given ID does not exist\", null);\n    }\n    if (modelResource.getType() == ModelType.Datatype\n        || modelResource.getType() == ModelType.Mapping) {\n      throw new GenerationException(\n          \"Provided model is neither an information model nor a function block model!\");\n    }\n    restTemplate.getMessageConverters().add(new ByteArrayHttpMessageConverter());\n    Generator generatorEntity = getGenerator(serviceKey);\n    if (generatorEntity == null) {\n      throw new GenerationException(\n          \"Generator with key \" + serviceKey + \" is not a registered generator\");\n    }\n    generatorEntity.increaseInvocationCount();\n    this.registeredGeneratorsRepository.save(generatorEntity);\n    HttpEntity<String> entity = getUserToken().map(token -> {\n      HttpHeaders headers = new HttpHeaders();\n      headers.add(\"Authorization\", \"Bearer \" + token);\n      return new HttpEntity<String>(\"parameters\", headers);\n    }).orElse(null);\n    ResponseEntity<byte[]> response = restTemplate.exchange(\n        generatorEntity.getGenerationEndpointUrl() + attachRequestParams(requestParams),\n        HttpMethod.GET, entity, byte[].class, modelId.getNamespace(), modelId.getName(),\n        modelId.getVersion());\n    return new GeneratedOutput(response.getBody(), extractFileNameFromHeader(response),\n        response.getHeaders().getContentLength());\n  }\n  private Optional<String> getUserToken() {\n    Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\n    if (authentication != null && authentication instanceof OAuth2Authentication) {\n      if (authentication.getDetails() instanceof OAuth2AuthenticationDetails) {\n        OAuth2AuthenticationDetails details =\n            (OAuth2AuthenticationDetails) authentication.getDetails();\n        return Optional.ofNullable(details.getTokenValue());\n      }\n    }\n    return Optional.empty();\n  }\n  private String attachRequestParams(Map<String, String> requestParams) {\n    if (requestParams.isEmpty()) {\n      return \"\";\n    } else {\n      StringBuilder requestUrlParams = new StringBuilder(\"?\");\n      for (Iterator<String> iter = requestParams.keySet().iterator(); iter.hasNext();) {\n        String key = iter.next();\n        requestUrlParams.append(key);\n        requestUrlParams.append(\"=\");\n        requestUrlParams.append(requestParams.get(key));\n        if (iter.hasNext()) {\n          requestUrlParams.append(\"&\");\n        }\n      }\n      return requestUrlParams.toString();\n    }\n  }\n  private String extractFileNameFromHeader(ResponseEntity<byte[]> entity) {\n    List<String> values = entity.getHeaders().get(\"content-disposition\");\n    if (values.size() > 0) {\n      int indexOfFileNameStart = values.get(0).indexOf(\"=\");\n      return values.get(0).substring(indexOfFileNameStart + 1);\n    }\n    return \"generated.output\";\n  }\n<fim_suffix>  private Generator getGenerator(String serviceKey) {\n    List<Generator> generators = this.registeredGeneratorsRepository.findByGeneratorKey(serviceKey);\n    if (!generators.isEmpty()) {\n      return generators.get(0);\n    } else {\n      return null;\n    }\n  }\n  @Override\n  public Collection<GeneratorInfo> getMostlyUsedGenerators(int top) {\n    List<Generator> topResult = new ArrayList<Generator>();\n    for (Generator entity : this.registeredGeneratorsRepository.findByClassifier(\"platform\")) {\n      topResult.add(entity);\n    }\n    topResult.sort(new Comparator<Generator>() {\n      @Override\n      public int compare(Generator o1, Generator o2) {\n        if (o1.getInvocationCount() > o2.getInvocationCount()) {\n          return -1;\n        } else if (o1.getInvocationCount() < o2.getInvocationCount()) {\n          return +1;\n        } else {\n          return 0;\n        }\n      }\n    });\n    List<GeneratorInfo> result = new ArrayList<>(top);\n    int counter = 0;\n    for (Generator entity : topResult) {\n      if (counter < top) {\n        try {\n          result.add(getGeneratorServiceInfo(entity.getKey(), false));\n          counter++;\n        } catch (Throwable t) {\n          LOGGER.warn(\"Generator \" + entity.getKey()\n              + \" appears to be offline or not deployed. Skipping...\");\n        }\n      }\n    }\n    return result;\n  }\n  @Override\n  public GeneratedOutput generate(String serviceKey, Map<String, String> requestParams) {\n    restTemplate.getMessageConverters().add(new ByteArrayHttpMessageConverter());\n    Generator generatorEntity = getGenerator(serviceKey);\n    if (generatorEntity == null) {\n      throw new GenerationException(\n          \"Generator with key \" + serviceKey + \" is not a registered generator\");\n    }<fim_middle>// function below has no smell\n"}