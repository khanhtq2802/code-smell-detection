{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.kafka.streams.processor;\n\nimport org.apache.kafka.streams.errors.StreamsException;\n\n/**\n * A storage engine for managing state maintained by a stream processor.\n * <p>\n * If the store is implemented as a persistent store, it <em>must</em> use the store name as directory name and write\n * all data into this store directory.\n * The store directory must be created with the state directory.\n * The state directory can be obtained via {@link ProcessorContext#stateDir() #stateDir()} using the\n * {@link ProcessorContext} provided via {@link #init(ProcessorContext, StateStore) init(...)}.\n * <p>\n * Using nested store directories within the state directory isolates different state stores.\n * If a state store would write into the state directory directly, it might conflict with others state stores and thus,\n * data might get corrupted and/or Streams might fail with an error.\n * Furthermore, Kafka Streams relies on using the store name as store directory name to perform internal cleanup tasks.\n * <p>\n * This interface does not specify any query capabilities, which, of course,\n * would be query engine specific. Instead it just specifies the minimum\n * functionality required to reload a storage engine from its changelog as well\n * as basic lifecycle management.\n */\n<fim_suffix>public interface StateStore {\n\n    /**\n     * The name of this store.\n     * @return the storage name\n     */\n    String name();\n\n    /**\n     * Initializes this state store.\n     * <p>\n     * The implementation of this function must register the root store in the context via the\n     * {@link ProcessorContext#register(StateStore, StateRestoreCallback)} function, where the\n     * first {@link StateStore} parameter should always be the passed-in {@code root} object, and\n     * the second parameter should be an object of user's implementation\n     * of the {@link StateRestoreCallback} interface used for restoring the state store from the changelog.\n     * <p>\n     * Note that if the state store engine itself supports bulk writes, users can implement another\n     * interface {@link BatchingStateRestoreCallback} which extends {@link StateRestoreCallback} to\n     * let users implement bulk-load restoration logic instead of restoring one record at a time.\n     *\n     * @throws IllegalStateException If store gets registered after initialized is already finished\n     * @throws StreamsException if the store's change log does not contain the partition\n     */\n    void init(ProcessorContext context, StateStore root);\n\n    /**\n     * Flush any cached data\n     */\n    void flush();\n\n    /**\n     * Close the storage engine.\n     * Note that this function needs to be idempotent since it may be called\n     * several times on the same state store.\n     * <p>\n     * Users only need to implement this function but should NEVER need to call this api explicitly\n     * as it will be called by the library automatically when necessary\n     */\n    void close();\n\n    /**\n     * Return if the storage is persistent or not.\n     *\n     * @return  {@code true} if the storage is persistent&mdash;{@code false} otherwise\n     */\n    boolean persistent();\n\n    /**\n     * Is this store open for reading and writing\n     * @return {@code true} if the store is open\n     */\n    boolean isOpen();\n}<fim_middle>// class below has no smell\n"}