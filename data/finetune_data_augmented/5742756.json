{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.tajo.storage.thirdparty.orc;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.io.Text;\nimport org.apache.orc.OrcProto;\nimport org.apache.orc.impl.*;\nimport org.apache.tajo.catalog.Column;\nimport org.apache.tajo.catalog.TypeDesc;\nimport org.apache.tajo.datum.Datum;\nimport org.apache.tajo.datum.DatumFactory;\nimport org.apache.tajo.datum.NullDatum;\nimport org.apache.tajo.exception.TajoRuntimeException;\nimport org.apache.tajo.exception.UnsupportedException;\nimport org.apache.tajo.util.datetime.DateTimeConstants;\nimport org.apache.tajo.util.datetime.DateTimeUtil;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.TimeZone;\nimport static org.apache.tajo.storage.thirdparty.orc.WriterImpl.BASE_TIMESTAMP_STRING;\npublic class TreeReaderFactory {\n  private final static Log LOG = LogFactory.getLog(TreeReaderFactory.class);\n  public static class TreeReaderSchema {\n    /**\n     * The types in the ORC file.\n     */\n    List<OrcProto.Type> fileTypes;\n    /**\n     * The treeReaderSchema that the reader should read as.\n     */\n    List<OrcProto.Type> schemaTypes;\n    /**\n     * The subtype of the row STRUCT.  Different than 0 for ACID.\n     */\n    int innerStructSubtype;\n    public TreeReaderSchema() {\n      fileTypes = null;\n      schemaTypes = null;\n      innerStructSubtype = -1;\n    }\n    public TreeReaderSchema fileTypes(List<OrcProto.Type> fileTypes) {\n      this.fileTypes = fileTypes;\n      return this;\n    }\n    public TreeReaderSchema schemaTypes(List<OrcProto.Type> schemaTypes) {\n      this.schemaTypes = schemaTypes;\n      return this;\n    }\n    public TreeReaderSchema innerStructSubtype(int innerStructSubtype) {\n      this.innerStructSubtype = innerStructSubtype;\n      return this;\n    }\n    public List<OrcProto.Type> getFileTypes() {\n      return fileTypes;\n    }\n    public List<OrcProto.Type> getSchemaTypes() {\n      return schemaTypes;\n    }\n    public int getInnerStructSubtype() {\n      return innerStructSubtype;\n    }\n  }\n<fim_suffix>  public abstract static class TreeReader {\n    protected final int columnId;\n    protected BitFieldReader present = null;\n    protected boolean valuePresent = false;\n    TreeReader(int columnId) throws IOException {\n      this(columnId, null);\n    }\n    protected TreeReader(int columnId, InStream in) throws IOException {\n      this.columnId = columnId;\n      if (in == null) {\n        present = null;\n        valuePresent = true;\n      } else {\n        present = new BitFieldReader(in, 1);\n      }\n    }\n    void checkEncoding(OrcProto.ColumnEncoding encoding) throws IOException {\n      if (encoding.getKind() != OrcProto.ColumnEncoding.Kind.DIRECT) {\n        throw new IOException(\"Unknown encoding \" + encoding + \" in column \" +\n            columnId);\n      }\n    }\n    static IntegerReader createIntegerReader(OrcProto.ColumnEncoding.Kind kind,\n                                             InStream in,\n                                             boolean signed, boolean skipCorrupt) throws IOException {\n      switch (kind) {\n        case DIRECT_V2:\n        case DICTIONARY_V2:\n          return new RunLengthIntegerReaderV2(in, signed, skipCorrupt);\n        case DIRECT:\n        case DICTIONARY:\n          return new RunLengthIntegerReader(in, signed);\n        default:\n          throw new IllegalArgumentException(\"Unknown encoding \" + kind);\n      }\n    }\n    void startStripe(Map<org.apache.orc.impl.StreamName, InStream> streams,\n                     OrcProto.StripeFooter stripeFooter\n    ) throws IOException {\n      checkEncoding(stripeFooter.getColumnsList().get(columnId));\n      InStream in = streams.get(new org.apache.orc.impl.StreamName(columnId,\n          OrcProto.Stream.Kind.PRESENT));\n      if (in == null) {\n        present = null;\n        valuePresent = true;\n      } else {\n        present = new BitFieldReader(in, 1);\n      }\n    }\n    /**\n     * Seek to the given position.\n     *\n     * @param index the indexes loaded from the file\n     * @throws IOException\n     */\n    void seek(PositionProvider[] index) throws IOException {\n      seek(index[columnId]);\n    }\n    public void seek(PositionProvider index) throws IOException {\n      if (present != null) {\n        present.seek(index);\n      }\n    }\n    protected long countNonNulls(long rows) throws IOException {\n      if (present != null) {\n        long result = 0;\n        for (long c = 0; c < rows; ++c) {\n          if (present.next() == 1) {\n            result += 1;\n          }\n        }\n        return result;\n      } else {\n        return rows;\n      }\n    }\n    abstract void skipRows(long rows) throws IOException;\n    public BitFieldReader getPresent() {\n      return present;\n    }\n  }\n  public abstract static class DatumTreeReader extends TreeReader {\n    DatumTreeReader(int columnId) throws IOException {\n      super(columnId);\n    }\n    protected DatumTreeReader(int columnId, InStream in) throws IOException {\n      super(columnId, in);\n    }\n    Datum next() throws IOException {\n      if (present != null) {\n        valuePresent = present.next() == 1;\n      }\n      return NullDatum.get();\n    }\n  }\n  public abstract static class RawStringTreeReader extends TreeReader {\n    RawStringTreeReader(int columnId) throws IOException {\n      super(columnId);\n    }\n    protected RawStringTreeReader(int columnId, InStream in) throws IOException {\n      super(columnId, in);\n    }\n    byte[] next() throws IOException {\n      if (present != null) {\n        valuePresent = present.next() == 1;\n      }\n      return null;\n    }\n  }\n  public static class BooleanTreeReader extends DatumTreeReader {\n    protected BitFieldReader reader = null;\n    BooleanTreeReader(int columnId) throws IOException {\n      this(columnId, null, null);\n    }\n    protected BooleanTreeReader(int columnId, InStream present, InStream data) throws IOException {\n      super(columnId, present);\n      if (data != null) {\n        reader = new BitFieldReader(data, 1);\n      }\n    }\n    @Override\n    void startStripe(Map<org.apache.orc.impl.StreamName, InStream> streams,\n                     OrcProto.StripeFooter stripeFooter\n    ) throws IOException {\n      super.startStripe(streams, stripeFooter);\n      reader = new BitFieldReader(streams.get(new org.apache.orc.impl.StreamName(columnId,\n          OrcProto.Stream.Kind.DATA)), 1);\n    }\n    @Override\n    void seek(PositionProvider[] index) throws IOException {\n      seek(index[columnId]);\n    }\n    @Override\n    public void seek(PositionProvider index) throws IOException {\n      super.seek(index);\n      reader.seek(index);\n    }\n    @Override\n    void skipRows(long items) throws IOException {\n      reader.skip(countNonNulls(items));\n    }\n    @Override<fim_middle>// class below has no smell\n"}