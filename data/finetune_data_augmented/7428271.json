{"text": "<fim_prefix>                emitComparison(keyConstants[index]);\n                masm.jcc(intCond(condition), target);\n            }\n        }\n    }\n    public static final class TableSwitchOp extends AMD64BlockEndOp {\n        public static final LIRInstructionClass<TableSwitchOp> TYPE = LIRInstructionClass.create(TableSwitchOp.class);\n        private final int lowKey;\n        private final LabelRef defaultTarget;\n        private final LabelRef[] targets;\n        @Use protected Value index;\n        @Temp({REG, HINT}) protected Value idxScratch;\n        @Temp protected Value scratch;\n        public TableSwitchOp(final int lowKey, final LabelRef defaultTarget, final LabelRef[] targets, Value index, Variable scratch, Variable idxScratch) {\n            super(TYPE);\n            this.lowKey = lowKey;\n            this.defaultTarget = defaultTarget;\n            this.targets = targets;\n            this.index = index;\n            this.scratch = scratch;\n            this.idxScratch = idxScratch;\n        }\n        @Override\n        public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {\n            Register indexReg = asRegister(index, AMD64Kind.DWORD);\n            Register idxScratchReg = asRegister(idxScratch, AMD64Kind.DWORD);\n            Register scratchReg = asRegister(scratch, AMD64Kind.QWORD);\n            if (!indexReg.equals(idxScratchReg)) {\n                masm.movl(idxScratchReg, indexReg);\n            }\n            // Compare index against jump table bounds\n            int highKey = lowKey + targets.length - 1;\n            if (lowKey != 0) {\n                // subtract the low value from the switch value\n                masm.subl(idxScratchReg, lowKey);\n                masm.cmpl(idxScratchReg, highKey - lowKey);\n            } else {\n                masm.cmpl(idxScratchReg, highKey);\n            }\n            // Jump to default target if index is not within the jump table\n            if (defaultTarget != null) {\n                masm.jcc(ConditionFlag.Above, defaultTarget.label());\n            }\n            // Set scratch to address of jump table\n            masm.leaq(scratchReg, new AMD64Address(AMD64.rip, 0));\n            final int afterLea = masm.position();\n            // Load jump table entry into scratch and jump to it\n            masm.movslq(idxScratchReg, new AMD64Address(scratchReg, idxScratchReg, Scale.Times4, 0));\n            masm.addq(scratchReg, idxScratchReg);\n            masm.jmp(scratchReg);\n            // Inserting padding so that jump table address is 4-byte aligned\n            masm.align(4);\n            // Patch LEA instruction above now that we know the position of the jump table\n            // this is ugly but there is no better way to do this given the assembler API\n            final int jumpTablePos = masm.position();\n            final int leaDisplacementPosition = afterLea - 4;\n            masm.emitInt(jumpTablePos - afterLea, leaDisplacementPosition);\n            // Emit jump table entries\n            for (LabelRef target : targets) {\n                Label label = target.label();\n                int offsetToJumpTableBase = masm.position() - jumpTablePos;\n                if (label.isBound()) {\n                    int imm32 = label.position() - jumpTablePos;\n                    masm.emitInt(imm32);\n                } else {\n                    label.addPatchAt(masm.position());\n                    masm.emitByte(0); // pseudo-opcode for jump table entry\n                    masm.emitShort(offsetToJumpTableBase);\n                    masm.emitByte(0); // padding to make jump table entry 4 bytes wide\n                }\n            }\n            JumpTable jt = new JumpTable(jumpTablePos, lowKey, highKey, 4);\n            crb.compilationResult.addAnnotation(jt);\n        }\n    }\n    public static final class HashTableSwitchOp extends AMD64BlockEndOp {\n        public static final LIRInstructionClass<HashTableSwitchOp> TYPE = LIRInstructionClass.create(HashTableSwitchOp.class);\n        private final JavaConstant[] keys;\n        private final LabelRef defaultTarget;\n        private final LabelRef[] targets;\n        @Alive protected Value value;\n        @Alive protected Value hash;\n        @Temp({REG}) protected Value entryScratch;\n        @Temp({REG}) protected Value scratch;\n        public HashTableSwitchOp(final JavaConstant[] keys, final LabelRef defaultTarget, LabelRef[] targets, Value value, Value hash, Variable scratch, Variable entryScratch) {\n            super(TYPE);\n            this.keys = keys;\n            this.defaultTarget = defaultTarget;\n            this.targets = targets;\n            this.value = value;\n            this.hash = hash;\n            this.scratch = scratch;\n            this.entryScratch = entryScratch;\n        }\n        @Override\n        public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {\n            Register valueReg = asRegister(value, AMD64Kind.DWORD);\n            Register indexReg = asRegister(hash, AMD64Kind.DWORD);\n            Register scratchReg = asRegister(scratch, AMD64Kind.QWORD);\n            Register entryScratchReg = asRegister(entryScratch, AMD64Kind.QWORD);\n            // Set scratch to address of jump table\n            masm.leaq(scratchReg, new AMD64Address(AMD64.rip, 0));\n            final int afterLea = masm.position();\n            // When the default target is set, the jump table contains entries with two DWORDS:\n            // the original key before hashing and the label jump address\n            if (defaultTarget != null) {\n                // Move the table entry (two DWORDs) into a QWORD\n                masm.movq(entryScratchReg, new AMD64Address(scratchReg, indexReg, Scale.Times8, 0));\n                // Jump to the default target if the first DWORD (original key) doesn't match the\n                // current key. Accounts for hash collisions with unknown keys\n                masm.cmpl(entryScratchReg, valueReg);\n                masm.jcc(ConditionFlag.NotEqual, defaultTarget.label());\n                // Shift to the second DWORD\n                masm.sarq(entryScratchReg, 32);\n            } else {\n                // The jump table has a single DWORD with the label address if there's no\n                // default target\n                masm.movslq(entryScratchReg, new AMD64Address(scratchReg, indexReg, Scale.Times4, 0));\n            }\n            masm.addq(scratchReg, entryScratchReg);\n            masm.jmp(scratchReg);\n            // Inserting padding so that jump the table address is aligned\n            if (defaultTarget != null) {\n                masm.align(8);\n            } else {\n                masm.align(4);\n            }\n            // Patch LEA instruction above now that we know the position of the jump table\n            // this is ugly but there is no better way to do this given the assembler API\n            final int jumpTablePos = masm.position();\n            final int leaDisplacementPosition = afterLea - 4;\n            masm.emitInt(jumpTablePos - afterLea, leaDisplacementPosition);\n            // Emit jump table entries\n            for (int i = 0; i < targets.length; i++) {\n                Label label = targets[i].label();\n                if (defaultTarget != null) {\n                    masm.emitInt(keys[i].asInt());\n                }\n                if (label.isBound()) {\n                    int imm32 = label.position() - jumpTablePos;\n                    masm.emitInt(imm32);\n                } else {\n                    int offsetToJumpTableBase = masm.position() - jumpTablePos;\n                    label.addPatchAt(masm.position());\n                    masm.emitByte(0); // pseudo-opcode for jump table entry\n                    masm.emitShort(offsetToJumpTableBase);\n                    masm.emitByte(0); // padding to make jump table entry 4 bytes wide\n                }\n            }\n            JumpTable jt = new JumpTable(jumpTablePos, keys[0].asInt(), keys[keys.length - 1].asInt(), 4);\n            crb.compilationResult.addAnnotation(jt);\n        }\n    }\n<fim_suffix>    @Opcode(\"SETcc\")\n    public static final class CondSetOp extends AMD64LIRInstruction {\n        public static final LIRInstructionClass<CondSetOp> TYPE = LIRInstructionClass.create(CondSetOp.class);\n        @Def({REG, HINT}) protected Value result;\n        private final ConditionFlag condition;\n        public CondSetOp(Variable result, Condition condition) {\n            super(TYPE);\n            this.result = result;\n            this.condition = intCond(condition);\n        }\n        @Override\n        public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {\n            setcc(masm, result, condition);\n        }\n    }<fim_middle>// class below has no smell\n"}