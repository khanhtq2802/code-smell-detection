{"text": "<fim_prefix>            \trestoreStackSize(stackSize);\n        }\n        return ;\n    }\n    // $ANTLR end \"rulePreopExpression\"\n    // $ANTLR start \"entryRulePostopExpression\"\n    // InternalExBeeLangTestLanguageParser.g:980:1: entryRulePostopExpression : rulePostopExpression EOF ;\n    public final void entryRulePostopExpression() throws RecognitionException {\n        int entryRulePostopExpression_StartIndex = input.index();\n        try {\n            if ( state.backtracking>0 && alreadyParsedRule(input, 69) ) { return ; }\n            // InternalExBeeLangTestLanguageParser.g:981:1: ( rulePostopExpression EOF )\n            // InternalExBeeLangTestLanguageParser.g:982:1: rulePostopExpression EOF\n            {\n            if ( state.backtracking==0 ) {\n               before(grammarAccess.getPostopExpressionRule()); \n            }\n            pushFollow(FollowSets000.FOLLOW_1);\n            rulePostopExpression();\n            state._fsp--;\n            if (state.failed) return ;\n            if ( state.backtracking==0 ) {\n               after(grammarAccess.getPostopExpressionRule()); \n            }\n            match(input,EOF,FollowSets000.FOLLOW_2); if (state.failed) return ;\n            }\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n            if ( state.backtracking>0 ) { memoize(input, 69, entryRulePostopExpression_StartIndex); }\n        }\n        return ;\n    }\n    // $ANTLR end \"entryRulePostopExpression\"\n    // $ANTLR start \"rulePostopExpression\"\n    // InternalExBeeLangTestLanguageParser.g:989:1: rulePostopExpression : ( ( rule__PostopExpression__Group__0 ) ) ;\n    public final void rulePostopExpression() throws RecognitionException {\n        int rulePostopExpression_StartIndex = input.index();\n        \t\tint stackSize = keepStackSize();\n        try {\n            if ( state.backtracking>0 && alreadyParsedRule(input, 70) ) { return ; }\n            // InternalExBeeLangTestLanguageParser.g:993:2: ( ( ( rule__PostopExpression__Group__0 ) ) )\n            // InternalExBeeLangTestLanguageParser.g:994:2: ( ( rule__PostopExpression__Group__0 ) )\n            {\n            // InternalExBeeLangTestLanguageParser.g:994:2: ( ( rule__PostopExpression__Group__0 ) )\n            // InternalExBeeLangTestLanguageParser.g:995:3: ( rule__PostopExpression__Group__0 )\n            {\n            if ( state.backtracking==0 ) {\n               before(grammarAccess.getPostopExpressionAccess().getGroup()); \n            }\n            // InternalExBeeLangTestLanguageParser.g:996:3: ( rule__PostopExpression__Group__0 )\n            // InternalExBeeLangTestLanguageParser.g:996:4: rule__PostopExpression__Group__0\n            {\n            pushFollow(FollowSets000.FOLLOW_2);\n            rule__PostopExpression__Group__0();\n            state._fsp--;\n            if (state.failed) return ;\n            }\n            if ( state.backtracking==0 ) {\n               after(grammarAccess.getPostopExpressionAccess().getGroup()); \n            }\n            }\n            }\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n            if ( state.backtracking>0 ) { memoize(input, 70, rulePostopExpression_StartIndex); }\n            \trestoreStackSize(stackSize);\n        }\n        return ;\n    }\n    // $ANTLR end \"rulePostopExpression\"\n    // $ANTLR start \"entryRuleInfixExpression\"\n    // InternalExBeeLangTestLanguageParser.g:1005:1: entryRuleInfixExpression : ruleInfixExpression EOF ;\n    public final void entryRuleInfixExpression() throws RecognitionException {\n        int entryRuleInfixExpression_StartIndex = input.index();\n        try {\n            if ( state.backtracking>0 && alreadyParsedRule(input, 71) ) { return ; }\n            // InternalExBeeLangTestLanguageParser.g:1006:1: ( ruleInfixExpression EOF )\n            // InternalExBeeLangTestLanguageParser.g:1007:1: ruleInfixExpression EOF\n            {\n            if ( state.backtracking==0 ) {\n               before(grammarAccess.getInfixExpressionRule()); \n            }\n            pushFollow(FollowSets000.FOLLOW_1);\n            ruleInfixExpression();\n            state._fsp--;\n            if (state.failed) return ;\n            if ( state.backtracking==0 ) {\n               after(grammarAccess.getInfixExpressionRule()); \n            }\n            match(input,EOF,FollowSets000.FOLLOW_2); if (state.failed) return ;\n            }\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n            if ( state.backtracking>0 ) { memoize(input, 71, entryRuleInfixExpression_StartIndex); }\n        }\n        return ;\n    }\n    // $ANTLR end \"entryRuleInfixExpression\"\n    // $ANTLR start \"ruleInfixExpression\"\n    // InternalExBeeLangTestLanguageParser.g:1014:1: ruleInfixExpression : ( ( rule__InfixExpression__Group__0 ) ) ;\n    public final void ruleInfixExpression() throws RecognitionException {\n        int ruleInfixExpression_StartIndex = input.index();\n        \t\tint stackSize = keepStackSize();\n        try {\n            if ( state.backtracking>0 && alreadyParsedRule(input, 72) ) { return ; }\n            // InternalExBeeLangTestLanguageParser.g:1018:2: ( ( ( rule__InfixExpression__Group__0 ) ) )\n            // InternalExBeeLangTestLanguageParser.g:1019:2: ( ( rule__InfixExpression__Group__0 ) )\n            {\n            // InternalExBeeLangTestLanguageParser.g:1019:2: ( ( rule__InfixExpression__Group__0 ) )\n            // InternalExBeeLangTestLanguageParser.g:1020:3: ( rule__InfixExpression__Group__0 )\n            {\n            if ( state.backtracking==0 ) {\n               before(grammarAccess.getInfixExpressionAccess().getGroup()); \n            }\n            // InternalExBeeLangTestLanguageParser.g:1021:3: ( rule__InfixExpression__Group__0 )\n            // InternalExBeeLangTestLanguageParser.g:1021:4: rule__InfixExpression__Group__0\n            {\n            pushFollow(FollowSets000.FOLLOW_2);\n            rule__InfixExpression__Group__0();\n            state._fsp--;\n            if (state.failed) return ;\n            }\n            if ( state.backtracking==0 ) {\n               after(grammarAccess.getInfixExpressionAccess().getGroup()); \n            }\n            }\n            }\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n            if ( state.backtracking>0 ) { memoize(input, 72, ruleInfixExpression_StartIndex); }\n            \trestoreStackSize(stackSize);\n        }\n        return ;\n    }\n    // $ANTLR end \"ruleInfixExpression\"\n    // $ANTLR start \"entryRuleCallExpression\"\n    // InternalExBeeLangTestLanguageParser.g:1030:1: entryRuleCallExpression : ruleCallExpression EOF ;\n<fim_suffix>    public final void entryRuleCallExpression() throws RecognitionException {\n        int entryRuleCallExpression_StartIndex = input.index();\n        try {\n            if ( state.backtracking>0 && alreadyParsedRule(input, 73) ) { return ; }\n            // InternalExBeeLangTestLanguageParser.g:1031:1: ( ruleCallExpression EOF )\n            // InternalExBeeLangTestLanguageParser.g:1032:1: ruleCallExpression EOF\n            {\n            if ( state.backtracking==0 ) {\n               before(grammarAccess.getCallExpressionRule()); \n            }\n            pushFollow(FollowSets000.FOLLOW_1);\n            ruleCallExpression();\n            state._fsp--;\n            if (state.failed) return ;\n            if ( state.backtracking==0 ) {\n               after(grammarAccess.getCallExpressionRule()); \n            }\n            match(input,EOF,FollowSets000.FOLLOW_2); if (state.failed) return ;\n            }\n        }\n        catch (RecognitionException re) {\n            reportError(re);\n            recover(input,re);\n        }\n        finally {\n            if ( state.backtracking>0 ) { memoize(input, 73, entryRuleCallExpression_StartIndex); }\n        }\n        return ;\n    }<fim_middle>// function below is long method\n"}