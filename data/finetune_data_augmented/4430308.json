{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.eagle.log.entity.meta;\nimport org.apache.eagle.log.base.taggedlog.TaggedLogAPIEntity;\nimport org.apache.eagle.log.entity.GenericMetricEntity;\nimport org.apache.eagle.log.entity.GenericMetricShadowEntity;\nimport org.apache.hadoop.io.Writable;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport java.io.DataInput;\nimport java.io.DataOutput;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.HashMap;\nimport java.util.Map;\n/**\n * This object should be regarded as read-only metadata for an entity as it will be shared across all entity\n * object with the same entity name, so don't try to set different values for any of the fields, otherwise\n * it's not thread safe\n */\npublic class EntityDefinition implements Writable {\n    private static final Logger LOG = LoggerFactory.getLogger(EntityDefinition.class);\n    private Class<? extends TaggedLogAPIEntity> entityClass;\n    private String table;\n    private String columnFamily;\n    // TODO prefix be within search/get condition instead of entity definition. Topology entity should have\n    // pre-defined prefix.\n    private String prefix;\n    private String service;\n    private String serviceCreationPath;\n    private String serviceDeletionPath;\n    private String[] partitions;\n    private Map<String, Qualifier> displayNameMap = new HashMap<String, Qualifier>();\n    private Map<String, Qualifier> qualifierNameMap = new HashMap<String, Qualifier>();\n    private Map<String, Method> qualifierGetterMap = new HashMap<String, Method>();\n    private String[] tags;\n    private boolean isTimeSeries;\n    private MetricDefinition metricDefinition;\n    private IndexDefinition[] indexes;\n    public EntityDefinition() {\n    }\n    public MetricDefinition getMetricDefinition() {\n        return metricDefinition;\n    }\n    public void setMetricDefinition(MetricDefinition metricDefinition) {\n        this.metricDefinition = metricDefinition;\n    }\n    public boolean isTimeSeries() {\n        return isTimeSeries;\n    }\n    public void setTimeSeries(boolean isTimeSeries) {\n        this.isTimeSeries = isTimeSeries;\n    }\n    public String getColumnFamily() {\n        return columnFamily;\n    }\n    public void setColumnFamily(String columnFamily) {\n        this.columnFamily = columnFamily;\n    }\n    public Class<? extends TaggedLogAPIEntity> getEntityClass() {\n        return entityClass;\n    }\n    public void setEntityClass(Class<? extends TaggedLogAPIEntity> entityClass) {\n        this.entityClass = entityClass;\n    }\n    public String getTable() {\n        return table;\n    }\n    public void setTable(String table) {\n        this.table = table;\n    }\n    public Map<String, Qualifier> getDisplayNameMap() {\n        return displayNameMap;\n    }\n    public void setDisplayNameMap(Map<String, Qualifier> displayNameMap) {\n        this.displayNameMap = displayNameMap;\n    }\n    public Map<String, Qualifier> getQualifierNameMap() {\n        return qualifierNameMap;\n    }\n    public void setQualifierNameMap(Map<String, Qualifier> qualifierNameMap) {\n        this.qualifierNameMap = qualifierNameMap;\n    }\n    public String getPrefix() {\n        return prefix;\n    }\n    public void setPrefix(String prefix) {\n        this.prefix = prefix;\n    }\n    public String getService() {\n        return service;\n    }\n    public void setService(String service) {\n        this.service = service;\n    }\n    public String getServiceCreationPath() {\n        return serviceCreationPath;\n    }\n    public void setServiceCreationPath(String serviceCreationPath) {\n        this.serviceCreationPath = serviceCreationPath;\n    }\n    public String getServiceDeletionPath() {\n        return serviceDeletionPath;\n    }\n    public void setServiceDeletionPath(String serviceDeletionPath) {\n        this.serviceDeletionPath = serviceDeletionPath;\n    }\n    public String[] getPartitions() {\n        return partitions;\n    }\n    public void setPartitions(String[] partitions) {\n        this.partitions = partitions;\n    }\n<fim_suffix>    public IndexDefinition[] getIndexes() {\n        return indexes;\n    }\n    public void setIndexes(IndexDefinition[] indexes) {\n        this.indexes = indexes;\n    }\n    public Map<String, Method> getQualifierGetterMap() {\n        return qualifierGetterMap;\n    }\n    public void setQualifierGetterMap(Map<String, Method> qualifierGetterMap) {\n        this.qualifierGetterMap = qualifierGetterMap;\n    }\n    public String[] getTags() {\n        return tags;\n    }\n    public void setTags(String[] tags) {\n        this.tags = tags;\n    }\n    // public Map<String,String> getQualifierDisplayNameMap(){\n    // Map<String,String> qualifierDisplayNameMap = new HashMap<String, String>();\n    // for(Map.Entry<String,Qualifier> entry: qualifierNameMap.entrySet()){\n    // qualifierDisplayNameMap.put(entry.getKey(),entry.getValue().getDisplayName());\n    // }\n    // return qualifierDisplayNameMap;\n    // }\n    /**\n     * a filed is a tag when this field is neither in qualifierNameMap nor in displayNameMap\n     * \n     * @param field\n     * @return\n     */\n    public boolean isTag(String field) {\n        return (qualifierNameMap.get(field) == null && displayNameMap.get(field) == null);\n        // return (qualifierNameMap.get(field) == null);\n    }\n    /**\n     * Check if the specified field is a partition tag field\n     */\n    public boolean isPartitionTag(String field) {\n        if (partitions == null || (!isTag(field))) {\n            return false;\n        }\n        for (String partition : partitions) {\n            if (partition.equals(field)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    public Object getValue(TaggedLogAPIEntity entity, String field)\n        throws IllegalAccessException, IllegalArgumentException, InvocationTargetException {\n        if (!entityClass.equals(entity.getClass())) {\n            if ((entityClass.equals(GenericMetricEntity.class)\n                 && entity.getClass().equals(GenericMetricShadowEntity.class))) {\n                GenericMetricShadowEntity e = (GenericMetricShadowEntity)entity;\n                return e.getValue();\n            } else {\n                throw new IllegalArgumentException(\"Invalid entity type: \"\n                                                   + entity.getClass().getSimpleName());\n            }\n        }\n        final Method m = qualifierGetterMap.get(field);\n        if (m == null) {\n            // The field is a tag\n            if (entity.getTags() != null) {\n                return entity.getTags().get(field);\n            }\n        }\n        if (m != null) {\n            return m.invoke(entity);\n        }\n        return null;\n    }\n    @Override\n    public void write(DataOutput out) throws IOException {\n        out.writeUTF(entityClass.getName());\n        out.writeUTF(table);\n        out.writeUTF(columnFamily);\n        out.writeUTF(prefix);\n        out.writeUTF(service);\n        int partitionsLen = 0;\n        if (partitions != null) {\n            partitionsLen = partitions.length;\n        }\n        out.writeInt(partitionsLen);\n        for (int i = 0; i < partitionsLen; i++) {\n            out.writeUTF(partitions[i]);\n        }\n        int displayNameMapSize = displayNameMap.size();\n        out.writeInt(displayNameMapSize);\n        for (Map.Entry<String, Qualifier> entry : displayNameMap.entrySet()) {\n            out.writeUTF(entry.getKey());\n            entry.getValue().write(out);\n        }\n        int qualifierNameMapSize = qualifierNameMap.size();\n        out.writeInt(qualifierNameMapSize);\n        for (Map.Entry<String, Qualifier> entry : qualifierNameMap.entrySet()) {\n            out.writeUTF(entry.getKey());\n            entry.getValue().write(out);\n        }\n        // TODO: write qualifierGetterMap\n        out.writeBoolean(isTimeSeries);\n        boolean hasMetricDefinition = metricDefinition != null;\n        out.writeBoolean(hasMetricDefinition);\n        if (hasMetricDefinition) {\n            // write MetricDefinition\n            metricDefinition.write(out);\n        }\n        // TODO: write indexes\n    }\n    public void setEntityDefinition(EntityDefinition ed) {\n        this.entityClass = ed.getEntityClass();\n        this.table = ed.getTable();\n        this.columnFamily = ed.getColumnFamily();<fim_middle>// function below has no smell\n"}