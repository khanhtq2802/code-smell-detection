{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.ipc.impl;\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.ServerSocket;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.Channel;\nimport java.nio.channels.SelectableChannel;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.nio.channels.ServerSocketChannel;\nimport java.nio.channels.SocketChannel;\nimport java.util.ArrayList;\nimport java.util.BitSet;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.CompletableFuture;\nimport org.apache.hyracks.api.network.ISocketChannel;\nimport org.apache.hyracks.api.network.ISocketChannelFactory;\nimport org.apache.hyracks.util.ExitUtil;\nimport org.apache.hyracks.util.NetworkUtil;\nimport org.apache.logging.log4j.Level;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\npublic class IPCConnectionManager {\n    private static final Logger LOGGER = LogManager.getLogger();\n    // TODO(mblow): the next two could be config parameters\n    private static final int INITIAL_RETRY_DELAY_MILLIS = 100;\n    private static final int MAX_RETRY_DELAY_MILLIS = 15000;\n    private final IPCSystem system;\n    private final NetworkThread networkThread;\n    private final ServerSocketChannel serverSocketChannel;\n    private final Map<InetSocketAddress, IPCHandle> ipcHandleMap;\n    private final List<IPCHandle> pendingConnections;\n    private final List<IPCHandle> workingPendingConnections;\n    private final List<Message> sendList;\n    private final List<Message> workingSendList;\n    private final InetSocketAddress address;\n    private volatile boolean stopped;\n    private final ISocketChannelFactory socketChannelFactory;\n    IPCConnectionManager(IPCSystem system, InetSocketAddress socketAddress, ISocketChannelFactory socketChannelFactory)\n            throws IOException {\n        this.system = system;\n        this.socketChannelFactory = socketChannelFactory;\n        this.serverSocketChannel = ServerSocketChannel.open();\n        serverSocketChannel.socket().setReuseAddress(true);\n        serverSocketChannel.configureBlocking(false);\n        ServerSocket socket = serverSocketChannel.socket();\n        socket.bind(socketAddress);\n        address = new InetSocketAddress(socket.getInetAddress(), socket.getLocalPort());\n        networkThread = new NetworkThread();\n        networkThread.setPriority(Thread.MAX_PRIORITY);\n        ipcHandleMap = new HashMap<>();\n        pendingConnections = new ArrayList<>();\n        workingPendingConnections = new ArrayList<>();\n        sendList = new ArrayList<>();\n        workingSendList = new ArrayList<>();\n    }\n    InetSocketAddress getAddress() {\n        return address;\n    }\n    void start() {\n        stopped = false;\n        networkThread.start();\n    }\n    void stop() {\n        stopped = true;\n        NetworkUtil.closeQuietly(serverSocketChannel);\n        networkThread.selector.wakeup();\n    }\n    IPCHandle getIPCHandle(InetSocketAddress remoteAddress, int maxRetries) throws IOException, InterruptedException {\n        IPCHandle handle;\n        int retries = 0;\n        int delay = INITIAL_RETRY_DELAY_MILLIS;\n        while (true) {\n            synchronized (this) {\n                handle = ipcHandleMap.get(remoteAddress);\n                if (handle == null || !handle.isConnected()) {\n                    handle = new IPCHandle(system, remoteAddress);\n                    pendingConnections.add(handle);\n                    networkThread.selector.wakeup();\n                }\n            }\n            if (handle.waitTillConnected()) {\n                return handle;\n            }\n            if (maxRetries < 0 || retries++ < maxRetries) {\n                if (LOGGER.isWarnEnabled()) {\n                    LOGGER.warn(\"Connection to \" + remoteAddress + \" failed; retrying\" + (maxRetries <= 0 ? \"\"\n                            : \" (retry attempt \" + retries + \" of \" + maxRetries + \") after \" + delay + \"ms\"));\n                }\n                Thread.sleep(delay);\n                delay = Math.min(MAX_RETRY_DELAY_MILLIS, (int) (delay * 1.5));\n            } else {\n                throw new IOException(\"Connection failed to \" + remoteAddress);\n            }\n        }\n    }\n    synchronized void registerHandle(IPCHandle handle) {\n        ipcHandleMap.put(handle.getRemoteAddress(), handle);\n    }\n    synchronized void write(Message msg) {\n        if (LOGGER.isTraceEnabled()) {\n            LOGGER.trace(\"Enqueued message: \" + msg);\n        }\n        sendList.add(msg);\n        networkThread.selector.wakeup();\n    }\n    private Message createInitialAckMessage(IPCHandle handle, Message req) {\n        Message msg = new Message(handle);\n        msg.setMessageId(system.createMessageId());\n        msg.setRequestMessageId(req.getMessageId());\n        msg.setFlag(Message.INITIAL_ACK);\n        msg.setPayload(null);\n        return msg;\n    }\n    void ack(IPCHandle handle, Message req) {\n        write(createInitialAckMessage(handle, req));\n    }\n    private class NetworkThread extends Thread {\n        private final Selector selector;\n        private final Set<SocketChannel> openChannels = new HashSet<>();\n        private final BitSet unsentMessagesBitmap = new BitSet();\n        private final List<Message> tempUnsentMessages = new ArrayList<>();\n        NetworkThread() {\n            super(\"IPC Network Listener Thread [\" + address + \"]\");\n            setDaemon(true);\n            try {\n                selector = Selector.open();\n                serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n            } catch (IOException e) {\n                throw new IllegalStateException(e);\n            }\n        }\n        @Override\n        public void run() {\n            try {\n                doRun();\n            } finally {\n                cleanup();\n            }\n        }\n        private void doRun() {\n            while (!stopped) {\n                try {\n                    int n = selector.select();\n                    collectOutstandingWork();\n                    if (!workingPendingConnections.isEmpty()) {\n                        establishPendingConnections();\n                    }\n                    if (!workingSendList.isEmpty()) {\n                        sendPendingMessages();\n                    }\n                    if (n > 0) {\n                        processSelectedKeys();\n                    }\n                } catch (Exception e) {\n                    LOGGER.log(Level.ERROR, \"Exception processing message\", e);\n                }\n            }\n        }\n<fim_suffix>        private void processSelectedKeys() {\n            for (Iterator<SelectionKey> i = selector.selectedKeys().iterator(); i.hasNext();) {\n                SelectionKey key = i.next();\n                i.remove();\n                final SelectableChannel sc = key.channel();\n                // do not attempt to read/write until handle is set (e.g. after handshake is completed)\n                if (key.isReadable() && key.attachment() != null) {\n                    read(key);\n                } else if (key.isWritable() && key.attachment() != null) {\n                    write(key);\n                } else if (key.isAcceptable()) {\n                    assert sc == serverSocketChannel;\n                    accept();\n                } else if (key.isConnectable()) {\n                    finishConnect(key);\n                }\n            }\n        }\n        private void finishConnect(SelectionKey connectableKey) {\n            SocketChannel channel = (SocketChannel) connectableKey.channel();\n            IPCHandle handle = (IPCHandle) connectableKey.attachment();\n            boolean connected = false;\n            try {\n                connected = channel.finishConnect();\n                if (connected) {\n                    SelectionKey channelKey = channel.register(selector, SelectionKey.OP_READ);\n                    final ISocketChannel clientChannel = socketChannelFactory.createClientChannel(channel);\n                    if (clientChannel.requiresHandshake()) {\n                        asyncHandshake(clientChannel, handle, channelKey);\n                    } else {\n                        connectionEstablished(handle, channelKey, clientChannel);\n                    }\n                }\n            } catch (Exception e) {\n                LOGGER.warn(\"Exception finishing connect\", e);\n            } finally {\n                if (!connected) {\n                    LOGGER.warn(\"Failed to finish connect to {}\", handle.getRemoteAddress());\n                    close(connectableKey, channel);\n                }\n            }\n        }\n        private void accept() {\n            SocketChannel channel = null;\n            SelectionKey channelKey = null;\n            try {<fim_middle>// function below has no smell\n"}