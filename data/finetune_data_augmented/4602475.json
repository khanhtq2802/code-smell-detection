{"text": "<fim_prefix> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.giraph.worker;\nimport com.facebook.swift.codec.ThriftField;\nimport com.facebook.swift.codec.ThriftStruct;\nimport org.apache.giraph.utils.MemoryUtils;\nimport javax.annotation.concurrent.ThreadSafe;\n/**\n * Stores information about a worker's progress that is periodically written to\n * ZooKeeper with {@link WorkerProgressWriter}.\n */\n@ThreadSafe\n@ThriftStruct\npublic final class WorkerProgress extends WorkerProgressStats {\n  /** Singleton instance for everyone to use */\n  private static final WorkerProgress INSTANCE = new WorkerProgress();\n  /**\n   * Public constructor for thrift to create us.\n   * Please use WorkerProgress.get() to get the static instance.\n   */\n  public WorkerProgress() {\n  }\n  /**\n   * Get singleton instance of WorkerProgress.\n   *\n   * @return WorkerProgress singleton instance\n   */\n  public static WorkerProgress get() {\n    return INSTANCE;\n  }\n  /**\n   * Add number of vertices loaded\n   *\n   * @param verticesLoaded How many vertices were loaded since the last\n   *                       time this function was called\n   */\n  public synchronized void addVerticesLoaded(long verticesLoaded) {\n    this.verticesLoaded += verticesLoaded;\n  }\n  /**\n   * Increment number of vertex input splits which were loaded\n   */\n  public synchronized void incrementVertexInputSplitsLoaded() {\n    vertexInputSplitsLoaded++;\n  }\n  /**\n   * Notify this class that worker finished loading vertices\n   */\n  public synchronized void finishLoadingVertices() {\n    loadingVerticesDone = true;\n  }\n  /**\n   * Add number of edges loaded\n   *\n   * @param edgesLoaded How many edges were loaded since the last\n   *                    time this function was called\n   */\n  public synchronized void addEdgesLoaded(long edgesLoaded) {\n    this.edgesLoaded += edgesLoaded;\n  }\n  /**\n   * Increment number of edge input splits which were loaded\n   */\n  public synchronized void incrementEdgeInputSplitsLoaded() {\n    edgeInputSplitsLoaded++;\n  }\n  /**\n   * Notify this class that worker finished loading edges\n   */\n  public synchronized void finishLoadingEdges() {\n    loadingEdgesDone = true;\n  }\n  /**\n   * Notify this class that next computation superstep is starting\n   *\n   * @param superstep           Superstep which is starting\n   * @param verticesToCompute   How many vertices are there to compute\n   * @param partitionsToCompute How many partitions are there to compute\n   */\n  public synchronized void startSuperstep(long superstep,\n      long verticesToCompute, int partitionsToCompute) {\n    this.currentSuperstep = superstep;\n    this.verticesToCompute = verticesToCompute;\n    this.partitionsToCompute = partitionsToCompute;\n    verticesComputed = 0;\n    partitionsComputed = 0;\n  }\n  /**\n   * Add number of vertices computed\n   *\n   * @param verticesComputed How many vertices were computed since the last\n   *                         time this function was called\n   */\n  public synchronized void addVerticesComputed(long verticesComputed) {\n    this.verticesComputed += verticesComputed;\n  }\n  /**\n   * Increment number of partitions which were computed\n   */\n  public synchronized void incrementPartitionsComputed() {\n    partitionsComputed++;\n  }\n  /**\n   * Notify this class that worker is starting to store data\n   *\n   * @param verticesToStore   How many vertices should be stored\n   * @param partitionsToStore How many partitions should be stored\n   */\n  public synchronized void startStoring(long verticesToStore,\n      int partitionsToStore) {\n    computationDone = true;\n    verticesToCompute = 0;\n    verticesComputed = 0;\n    partitionsToCompute = 0;\n    partitionsComputed = 0;\n    currentSuperstep = Long.MAX_VALUE;\n    this.verticesToStore = verticesToStore;\n    this.partitionsToStore = partitionsToStore;\n  }\n  /**\n   * Add number of vertices stored\n   *\n   * @param verticesStored How many vertices were stored since the last time\n   *                       this function was called\n   */\n  public synchronized void addVerticesStored(long verticesStored) {\n    this.verticesStored += verticesStored;\n  }\n  /**\n   * Increment number of partitions which were stored\n   */\n  public synchronized void incrementPartitionsStored() {\n    partitionsStored++;\n  }\n  /**\n   * Notify this class that storing data is done\n   */\n  public synchronized void finishStoring() {\n    storingDone = true;\n  }\n  /**\n   * Update memory info\n   */\n  public synchronized void updateMemory() {\n    freeMemoryMB = MemoryUtils.freePlusUnallocatedMemoryMB();\n    freeMemoryFraction = MemoryUtils.freeMemoryFraction();\n  }\n  /**\n   * Update lowest percentage of graph which stayed in memory so far in the\n   * execution\n   *\n   * @param fraction the fraction of graph in memory so far in this superstep\n   */\n  public synchronized void updateLowestGraphPercentageInMemory(int fraction) {\n    lowestGraphPercentageInMemory =\n        Math.min(lowestGraphPercentageInMemory, fraction);\n  }\n  @ThriftField(1)\n  public synchronized long getCurrentSuperstep() {\n    return currentSuperstep;\n  }\n  @ThriftField(2)\n  public synchronized long getVerticesLoaded() {\n    return verticesLoaded;\n  }\n  @ThriftField(3)\n  public synchronized int getVertexInputSplitsLoaded() {\n    return vertexInputSplitsLoaded;\n  }\n  @ThriftField(4)\n  public synchronized boolean isLoadingVerticesDone() {\n    return loadingVerticesDone;\n  }\n  @ThriftField(5)\n  public synchronized long getEdgesLoaded() {\n    return edgesLoaded;\n  }\n  @ThriftField(6)\n  public synchronized int getEdgeInputSplitsLoaded() {\n    return edgeInputSplitsLoaded;\n  }\n  @ThriftField(7)\n  public synchronized boolean isLoadingEdgesDone() {\n    return loadingEdgesDone;\n  }\n  @ThriftField(8)\n  public synchronized long getVerticesToCompute() {\n    return verticesToCompute;\n  }\n  @ThriftField(9)\n  public synchronized long getVerticesComputed() {\n    return verticesComputed;\n  }\n  @ThriftField(10)\n  public synchronized int getPartitionsToCompute() {\n    return partitionsToCompute;\n  }\n  @ThriftField(11)\n  public synchronized int getPartitionsComputed() {\n    return partitionsComputed;\n  }\n  @ThriftField(12)\n  public synchronized boolean isComputationDone() {\n    return computationDone;\n  }\n  @ThriftField(13)\n  public synchronized long getVerticesToStore() {\n    return verticesToStore;\n  }\n  @ThriftField(14)\n  public synchronized long getVerticesStored() {\n    return verticesStored;\n  }\n  @ThriftField(15)\n  public synchronized int getPartitionsToStore() {\n    return partitionsToStore;\n  }\n  @ThriftField(16)\n  public synchronized int getPartitionsStored() {\n    return partitionsStored;\n  }\n  @ThriftField(17)\n  public synchronized boolean isStoringDone() {\n    return storingDone;\n  }\n  @ThriftField(18)\n  public synchronized int getTaskId() {\n    return taskId;\n  }\n  @ThriftField(19)\n  public synchronized double getFreeMemoryMB() {\n    return freeMemoryMB;\n  }\n  @ThriftField(20)\n  public synchronized double getFreeMemoryFraction() {\n    return freeMemoryFraction;\n  }\n  @ThriftField(21)\n  public synchronized int getLowestGraphPercentageInMemory() {\n    return lowestGraphPercentageInMemory;\n  }\n  public synchronized boolean isInputSuperstep() {\n    return currentSuperstep == -1;\n  }\n  public synchronized boolean isComputeSuperstep() {\n    return currentSuperstep >= 0 && currentSuperstep < Long.MAX_VALUE;\n  }\n  public synchronized boolean isOutputSuperstep() {\n    return currentSuperstep == Long.MAX_VALUE;\n  }\n  @ThriftField\n  public void setCurrentSuperstep(long currentSuperstep) {\n    this.currentSuperstep = currentSuperstep;\n  }\n  @ThriftField\n  public void setVerticesLoaded(long verticesLoaded) {\n    this.verticesLoaded = verticesLoaded;\n  }\n  @ThriftField\n  public void setVertexInputSplitsLoaded(int vertexInputSplitsLoaded) {\n    this.vertexInputSplitsLoaded = vertexInputSplitsLoaded;\n  }\n  @ThriftField\n  public void setLoadingVerticesDone(boolean loadingVerticesDone) {\n    this.loadingVerticesDone = loadingVerticesDone;\n  }\n  @ThriftField\n  public void setEdgesLoaded(long edgesLoaded) {\n    this.edgesLoaded = edgesLoaded;\n  }\n  @ThriftField\n  public void setEdgeInputSplitsLoaded(int edgeInputSplitsLoaded) {\n    this.edgeInputSplitsLoaded = edgeInputSplitsLoaded;\n  }\n  @ThriftField\n  public void setLoadingEdgesDone(boolean loadingEdgesDone) {\n    this.loadingEdgesDone = loadingEdgesDone;\n  }\n  @ThriftField\n  public void setVerticesToCompute(long verticesToCompute) {\n    this.verticesToCompute = verticesToCompute;\n  }\n  @ThriftField\n  public void setVerticesComputed(long verticesComputed) {\n    this.verticesComputed = verticesComputed;\n  }\n<fim_suffix>  @ThriftField\n  public void setPartitionsToCompute(int partitionsToCompute) {\n    this.partitionsToCompute = partitionsToCompute;\n  }<fim_middle>// function below has no smell\n"}