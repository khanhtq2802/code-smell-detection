{"text": "<fim_prefix>//\n//  ========================================================================\n//  Copyright (c) 1995-2019 Mort Bay Consulting Pty. Ltd.\n//  ------------------------------------------------------------------------\n//  All rights reserved. This program and the accompanying materials\n//  are made available under the terms of the Eclipse Public License v1.0\n//  and Apache License v2.0 which accompanies this distribution.\n//\n//      The Eclipse Public License is available at\n//      http://www.eclipse.org/legal/epl-v10.html\n//\n//      The Apache License v2.0 is available at\n//      http://www.opensource.org/licenses/apache2.0.php\n//\n//  You may elect to redistribute this code under either of these licenses.\n//  ========================================================================\n//\npackage org.eclipse.jetty.websocket.common.util;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.lang.reflect.TypeVariable;\npublic class ReflectUtils\n{\n    private static class GenericRef\n    {\n        // The base class reference lookup started from\n        private final Class<?> baseClass;\n        // The interface that we are interested in\n        private final Class<?> ifaceClass;\n        // The actual class generic interface was found on\n        Class<?> genericClass;\n        // The found genericType\n        public Type genericType;\n        private int genericIndex;\n        public GenericRef(final Class<?> baseClass, final Class<?> ifaceClass)\n        {\n            this.baseClass = baseClass;\n            this.ifaceClass = ifaceClass;\n        }\n        public boolean needsUnwrap()\n        {\n            return (genericClass == null) && (genericType != null) && (genericType instanceof TypeVariable<?>);\n        }\n        public void setGenericFromType(Type type, int index)\n        {\n            // debug(\"setGenericFromType(%s,%d)\",toShortName(type),index);\n            this.genericType = type;\n            this.genericIndex = index;\n            if (type instanceof Class)\n            {\n                this.genericClass = (Class<?>)type;\n            }\n        }\n        @Override\n        public String toString()\n        {\n            StringBuilder builder = new StringBuilder();\n            builder.append(\"GenericRef [baseClass=\");\n            builder.append(baseClass);\n            builder.append(\", ifaceClass=\");\n            builder.append(ifaceClass);\n            builder.append(\", genericType=\");\n            builder.append(genericType);\n            builder.append(\", genericClass=\");\n            builder.append(genericClass);\n            builder.append(\"]\");\n            return builder.toString();\n        }\n    }\n    private static StringBuilder appendTypeName(StringBuilder sb, Type type, boolean ellipses)\n    {\n        if (type instanceof Class<?>)\n        {\n            Class<?> ctype = (Class<?>)type;\n            if (ctype.isArray())\n            {\n                try\n                {\n                    int dimensions = 0;\n                    while (ctype.isArray())\n                    {\n                        dimensions++;\n                        ctype = ctype.getComponentType();\n                    }\n                    sb.append(ctype.getName());\n                    for (int i = 0; i < dimensions; i++)\n                    {\n                        if (ellipses)\n                        {\n                            sb.append(\"...\");\n                        }\n                        else\n                        {\n                            sb.append(\"[]\");\n                        }\n                    }\n                    return sb;\n                }\n                catch (Throwable ignore)\n                {\n                    // ignore\n                }\n            }\n            sb.append(ctype.getName());\n        }\n        else\n        {\n            sb.append(type.toString());\n        }\n        return sb;\n    }\n    /**\n     * Given a Base (concrete) Class, find the interface specified, and return its concrete Generic class declaration.\n     * \n     * @param baseClass\n     *            the base (concrete) class to look in\n     * @param ifaceClass\n     *            the interface of interest\n     * @return the (concrete) generic class that the interface exposes\n     */\n    public static Class<?> findGenericClassFor(Class<?> baseClass, Class<?> ifaceClass)\n    {\n        GenericRef ref = new GenericRef(baseClass,ifaceClass);\n        if (resolveGenericRef(ref,baseClass))\n        {\n            // debug(\"Generic Found: %s\",ref.genericClass);\n            return ref.genericClass;\n        }\n        // debug(\"Generic not found: %s\",ref);\n        return null;\n    }\n    private static int findTypeParameterIndex(Class<?> clazz, TypeVariable<?> needVar)\n    {\n        // debug(\"findTypeParameterIndex(%s, [%s])\",toShortName(clazz),toShortName(needVar));\n        TypeVariable<?> params[] = clazz.getTypeParameters();\n        for (int i = 0; i < params.length; i++)\n        {\n            if (params[i].getName().equals(needVar.getName()))\n            {\n                // debug(\"Type Parameter found at index: [%d]\",i);\n                return i;\n            }\n        }\n        // debug(\"Type Parameter NOT found\");\n        return -1;\n    }\n    public static boolean isDefaultConstructable(Class<?> clazz)\n    {\n        int mods = clazz.getModifiers();\n        if (Modifier.isAbstract(mods) || !Modifier.isPublic(mods))\n        {\n            // Needs to be public, non-abstract\n            return false;\n        }\n        Class<?>[] noargs = new Class<?>[0];\n        try\n        {\n            // Needs to have a no-args constructor\n            Constructor<?> constructor = clazz.getConstructor(noargs);\n            // Constructor needs to be public\n            return Modifier.isPublic(constructor.getModifiers());\n        }\n        catch (NoSuchMethodException | SecurityException e)\n        {\n            return false;\n        }\n    }\n<fim_suffix>    private static boolean resolveGenericRef(GenericRef ref, Class<?> clazz, Type type)\n    {\n        if (type instanceof Class)\n        {\n            if (type == ref.ifaceClass)\n            {\n                // is this a straight ref or a TypeVariable?\n                // debug(\"Found ref (as class): %s\",toShortName(type));\n                ref.setGenericFromType(type,0);\n                return true;\n            }\n            else\n            {\n                // Keep digging\n                return resolveGenericRef(ref,type);\n            }\n        }\n        if (type instanceof ParameterizedType)\n        {\n            ParameterizedType ptype = (ParameterizedType)type;\n            Type rawType = ptype.getRawType();\n            if (rawType == ref.ifaceClass)\n            {\n                // debug(\"Found ref on [%s] as ParameterizedType [%s]\",toShortName(clazz),toShortName(ptype));\n                // Always get the raw type parameter, let unwrap() solve for what it is\n                ref.setGenericFromType(ptype.getActualTypeArguments()[0],0);\n                return true;\n            }\n            else\n            {\n                // Keep digging\n                return resolveGenericRef(ref,rawType);\n            }\n        }\n        return false;\n    }\n    private static boolean resolveGenericRef(GenericRef ref, Type type)\n    {\n        if ((type == null) || (type == Object.class))\n        {\n            return false;\n        }\n        if (type instanceof Class)\n        {\n            Class<?> clazz = (Class<?>)type;\n            // prevent spinning off into Serialization and other parts of the\n            // standard tree that we could care less about\n            if (clazz.getName().matches(\"^javax*\\\\..*\"))\n            {\n                return false;\n            }\n            Type ifaces[] = clazz.getGenericInterfaces();\n            for (Type iface : ifaces)\n            {\n                // debug(\"resolve %s interface[]: %s\",toShortName(clazz),toShortName(iface));\n                if (resolveGenericRef(ref,clazz,iface))\n                {\n                    if (ref.needsUnwrap())\n                    {\n                        // debug(\"## Unwrap class %s::%s\",toShortName(clazz),toShortName(iface));\n                        TypeVariable<?> needVar = (TypeVariable<?>)ref.genericType;\n                        // debug(\"needs unwrap of type var [%s] - index [%d]\",toShortName(needVar),ref.genericIndex);\n                        // attempt to find typeParameter on class itself\n                        int typeParamIdx = findTypeParameterIndex(clazz,needVar);\n                        // debug(\"type param index for %s[%s] is [%d]\",toShortName(clazz),toShortName(needVar),typeParamIdx);\n                        if (typeParamIdx >= 0)\n                        {\n                            // found a type parameter, use it\n                            // debug(\"unwrap from class [%s] - typeParameters[%d]\",toShortName(clazz),typeParamIdx);\n                            TypeVariable<?> params[] = clazz.getTypeParameters();\n                            if (params.length >= typeParamIdx)\n                            {\n                                ref.setGenericFromType(params[typeParamIdx],typeParamIdx);\n                            }\n                        }\n                        else if (iface instanceof ParameterizedType)\n                        {\n                            // use actual args on interface\n                            Type arg = ((ParameterizedType)iface).getActualTypeArguments()[ref.genericIndex];\n                            ref.setGenericFromType(arg,ref.genericIndex);\n                        }\n                    }\n                    return true;\n                }\n            }\n            type = clazz.getGenericSuperclass();\n            return resolveGenericRef(ref,type);\n        }\n        if (type instanceof ParameterizedType)\n        {\n            ParameterizedType ptype = (ParameterizedType)type;\n            Class<?> rawClass = (Class<?>)ptype.getRawType();\n            if (resolveGenericRef(ref,rawClass))\n            {<fim_middle>// function below is feature envy and long method\n"}