{"text": "<fim_prefix>\n<fim_suffix>public class FFMPEGTranscoder implements TranscodeEngine\n{\n  private static final boolean XCODE_DEBUG = Sage.DBG && Sage.getBoolean(\"media_server/transcode_debug\", false);\n  static final String BITRATE_OPTIONS_SIZE_KEY = \"httpls_bandwidth/%s/video_size\";\n  public FFMPEGTranscoder()\n  {\n  }\n  public long getAvailableTranscodeBytes()\n  {\n    if (bufferOutput)\n      return Math.max(0, xcodeBufferVirtualSize - xcodeBufferVirtualReadPos);\n    else\n    {\n      if (xcodeDone)\n        return 0;\n      else\n        return 65536;\n    }\n  }\n  public long getVirtualReadPosition()\n  {\n    return xcodeBufferVirtualReadPos;\n  }\n  public long getVirtualTranscodeSize()\n  {\n    return xcodeBufferVirtualSize;\n  }\n  public boolean isTranscodeDone()\n  {\n    return xcodeDone;\n  }\n  public boolean didTranscodeCompleteOK()\n  {\n    if (!xcodeDone) return false;\n    if (xcodeProcess != null)\n    {\n      try\n      {\n        lastExitCode = xcodeProcess.exitValue();\n      }\n      catch (IllegalThreadStateException ise)\n      {\n        lastExitCode = -1;\n      }\n    }\n    return xcodeDone && lastExitCode == 0;\n  }\n  public void pauseTranscode()\n  {\n  }\n  public void readFullyTranscodedData(byte[] buf, int inOffset, int inLength) throws java.io.IOException\n  {\n    readFullyTranscodedData(null, buf, inOffset, inLength);\n  }\n  public void readFullyTranscodedData(java.nio.ByteBuffer buf) throws java.io.IOException\n  {\n    readFullyTranscodedData(buf, null, buf.position(), buf.remaining());\n  }\n  private void readFullyTranscodedData(java.nio.ByteBuffer bb, byte[] buf, int inOffset, int inLength) throws java.io.IOException\n  {\n    int leftToRead = inLength;\n    if (bufferOutput)\n    {\n      long overage = inLength - getAvailableTranscodeBytes();\n      int numTries = 50;\n      if (XCODE_DEBUG && overage > 0) System.out.println(\"Waiting for more data to appear in transcode buffer over=\" + overage +\n          \" xcodeDone=\" + xcodeDone);\n      while (overage > 0 && !xcodeDone && (numTries-- > 0))\n      {\n        try { Thread.sleep(200); } catch (Exception e){}\n        overage = inLength - getAvailableTranscodeBytes();\n      }\n      if (overage > 0)\n      {\n        if (overage > leftToRead)\n        {\n          leftToRead = 0;\n          overage = inLength;\n        }\n        else\n        {\n          leftToRead -= overage;\n        }\n      }\n      int buffNum = (int) (((xcodeBufferVirtualReadPos - xcodeBufferVirtualOffset) / xcodeBuffer[0].length) + xcodeBufferBaseNum) % xcodeBuffer.length;\n      int buffOffset = (int) (xcodeBufferVirtualReadPos - xcodeBufferVirtualOffset) % xcodeBuffer[0].length;\n      if (XCODE_DEBUG) System.out.println(\"Xcode readTranscodedData(\" + inLength + \") buffNum=\" + buffNum +\n          \" buffOffset=\" + buffOffset);\n      int tempOffset = inOffset;\n      while (leftToRead > 0)\n      {\n        int currRead = Math.min((int)leftToRead, xcodeBuffer[buffNum].length - buffOffset);\n        if (bb != null)\n          bb.put(xcodeBuffer[buffNum], buffOffset, currRead);\n        else\n          System.arraycopy(xcodeBuffer[buffNum], buffOffset, buf, tempOffset, currRead);\n        tempOffset += currRead;\n        leftToRead -= currRead;\n        buffNum = (buffNum + 1) % xcodeBuffer.length;\n        buffOffset = 0;\n      }\n      if (XCODE_DEBUG) System.out.println(\"Xcode transferData complete overage=\" + overage);\n      xcodeBufferVirtualReadPos += inLength;\n      synchronized (xcodeSyncLock)\n      {\n        while (xcodeBufferVirtualReadPos - xcodeBufferVirtualOffset >= xcodeBuffer[0].length)\n        {\n          // We're reading more than one buffer beyond our start so we can kill that first buffer now\n          xcodeBufferBaseNum = (xcodeBufferBaseNum + 1) % xcodeBuffer.length;\n          xcodeBufferVirtualOffset += xcodeBuffer[0].length;\n          numFilledXcodeBuffers--;\n          if (XCODE_DEBUG) System.out.println(\"Adjusted buffer nums xcodeBufferBaseNum=\" + xcodeBufferBaseNum +\n              \" xcodeBufferVirtualOffset=\" + xcodeBufferVirtualOffset + \" numFilledBuffers=\" + numFilledXcodeBuffers);\n          xcodeSyncLock.notifyAll();\n        }\n      }\n      if (overage > 0)\n      {\n        if (bb != null)\n        {\n          while (bb.remaining() > 0)\n            bb.put((byte) 0xFF);\n        }\n        else\n          java.util.Arrays.fill(buf, (int)(inOffset + inLength - overage), inOffset + inLength, (byte)0xFF);\n        if (XCODE_DEBUG) System.out.println(\"Xcoder Sending overage=\" + overage);\n      }\n    }\n    else\n    {\n      while (leftToRead > 0)\n      {\n        int numRead;\n        if (bb != null)\n        {\n          if (nioTmpBuf == null)\n            nioTmpBuf = new byte[4096];\n          numRead = xcodeStdout.read(nioTmpBuf, 0, Math.min(leftToRead, nioTmpBuf.length));\n          bb.put(nioTmpBuf, 0, numRead);\n        }\n        else\n          numRead = xcodeStdout.read(buf, inOffset, leftToRead);\n        if (XCODE_DEBUG) System.out.println(\"Xcoder readFully \" + numRead + \" bytes directly from transcoder and is pushing it out\");\n        if (numRead == -1)\n        {\n          // EOF, use the overage buffer for the rest but also push what we have in ours\n          if (XCODE_DEBUG) System.out.println(\"XCoder sending overage for incomplete buffer read\");\n          if (bb != null)\n          {\n            while (bb.remaining() > 0)\n              bb.put((byte) 0xFF);\n          }\n          else\n            java.util.Arrays.fill(buf, inOffset, inOffset + leftToRead, (byte)0xFF);\n          leftToRead = 0;\n          xcodeDone = true;\n        }\n        else\n        {\n          inOffset += numRead;\n          leftToRead -= numRead;\n        }\n      }\n      xcodeBufferVirtualReadPos = xcodeBufferVirtualOffset = xcodeBufferVirtualSize = xcodeBufferVirtualReadPos + inLength;\n    }\n  }\n  protected long estimateTranscodeSeekTimeFromOffset(long offset)\n  {\n    // This should return the time for the corresponding offset in the transcoded file. We estimate this\n    // by analyzing the output of the transcoder and tracking what time it thinks certain byte positions correspond to.\n    double streamRate = (lastXcodeStreamPosition / ((double)lastXcodeStreamTime));\n    long rv = Math.round(offset / streamRate);\n    if (XCODE_DEBUG) System.out.println(\"Xcode seeking estimRate=\" + streamRate + \" offset=\" + offset + \" time=\" + rv);\n    return rv;\n  }\n  public long getCurrentTranscodeStreamTime()\n  {\n    return lastXcodeStreamTime;\n  }\n  public void seekToPosition(long offset) throws java.io.IOException\n  {\n    if (!isTranscoding())\n    {\n      if (offset == 0)\n        startTranscode();\n      else\n        throw new java.io.IOException(\"Cannot do seekToPosition in transcoder because it hasn't been started yet!\");\n      return;\n    }\n    if ((!bufferOutput && offset != xcodeBufferVirtualOffset) || (bufferOutput && (offset < xcodeBufferVirtualOffset ||\n        offset >= xcodeBufferVirtualOffset + xcodeBuffer.length*xcodeBuffer[0].length)))\n    {\n      long seekTime = estimateTranscodeSeekTimeFromOffset(offset);\n      stopTranscode();\n      if (XCODE_DEBUG) System.out.println(\"Restarting transcode to perform seek so read can continue time=\" + seekTime);\n      xcodeBufferVirtualReadPos = xcodeBufferVirtualOffset = xcodeBufferVirtualSize = offset;\n      transcodeStartSeekTime = seekTime;\n      startTranscode();\n    }\n    else\n    {\n      xcodeBufferVirtualReadPos = offset;\n      synchronized (xcodeSyncLock)\n      {\n        while (offset - xcodeBufferVirtualOffset >= xcodeBuffer[0].length)\n        {\n          // We're reading more than one buffer beyond our start so we can kill that first buffer now\n          xcodeBufferBaseNum = (xcodeBufferBaseNum + 1) % xcodeBuffer.length;\n          xcodeBufferVirtualOffset += xcodeBuffer[0].length;<fim_middle>// class below is blob\n"}