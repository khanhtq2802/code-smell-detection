{"text": "<fim_prefix>    private void sendDeferedResponse() {\n      try {\n        connection.sendResponse(this);\n      } catch (Exception e) {\n        // For synchronous calls, application code is done once it's returned\n        // from a method. It does not expect to receive an error.\n        // This is equivalent to what happens in synchronous calls when the\n        // Responder is not able to send out the response.\n        LOG.error(\"Failed to send deferred response. ThreadName=\" + Thread\n            .currentThread().getName() + \", CallId=\"\n            + callId + \", hostname=\" + getHostAddress());\n      }\n    }\n    @Override\n    public void setDeferredResponse(Writable response) {\n      if (this.connection.getServer().running) {\n        try {\n          setupResponse(this, RpcStatusProto.SUCCESS, null, response,\n              null, null);\n        } catch (IOException e) {\n          // For synchronous calls, application code is done once it has\n          // returned from a method. It does not expect to receive an error.\n          // This is equivalent to what happens in synchronous calls when the\n          // response cannot be sent.\n          LOG.error(\n              \"Failed to setup deferred successful response. ThreadName=\" +\n                  Thread.currentThread().getName() + \", Call=\" + this);\n          return;\n        }\n        sendDeferedResponse();\n      }\n    }\n    @Override\n    public void setDeferredError(Throwable t) {\n      if (this.connection.getServer().running) {\n        if (t == null) {\n          t = new IOException(\n              \"User code indicated an error without an exception\");\n        }\n        try {\n          ResponseParams responseParams = new ResponseParams();\n          populateResponseParamsOnError(t, responseParams);\n          setupResponse(this, responseParams.returnStatus,\n              responseParams.detailedErr,\n              null, responseParams.errorClass, responseParams.error);\n        } catch (IOException e) {\n          // For synchronous calls, application code is done once it has\n          // returned from a method. It does not expect to receive an error.\n          // This is equivalent to what happens in synchronous calls when the\n          // response cannot be sent.\n          LOG.error(\n              \"Failed to setup deferred error response. ThreadName=\" +\n                  Thread.currentThread().getName() + \", Call=\" + this);\n        }\n        sendDeferedResponse();\n      }\n    }\n    /**\n     * Holds response parameters. Defaults set to work for successful\n     * invocations\n     */\n    private class ResponseParams {\n      String errorClass = null;\n      String error = null;\n      RpcErrorCodeProto detailedErr = null;\n      RpcStatusProto returnStatus = RpcStatusProto.SUCCESS;\n    }\n    @Override\n    public String toString() {\n      return super.toString() + \" \" + rpcRequest + \" from \" + connection;\n    }\n  }\n  /** Listens on the socket. Creates jobs for the handler threads*/\n  private class Listener extends Thread {\n    private ServerSocketChannel acceptChannel = null; //the accept channel\n    private Selector selector = null; //the selector that we use for the server\n    private Reader[] readers = null;\n    private int currentReader = 0;\n    private InetSocketAddress address; //the address we bind at\n    private int listenPort; //the port we bind at\n    private int backlogLength = conf.getInt(\n        CommonConfigurationKeysPublic.IPC_SERVER_LISTEN_QUEUE_SIZE_KEY,\n        CommonConfigurationKeysPublic.IPC_SERVER_LISTEN_QUEUE_SIZE_DEFAULT);\n    Listener(int port) throws IOException {\n      address = new InetSocketAddress(bindAddress, port);\n      // Create a new server socket and set to non blocking mode\n      acceptChannel = ServerSocketChannel.open();\n      acceptChannel.configureBlocking(false);\n      // Bind the server socket to the local host and port\n      bind(acceptChannel.socket(), address, backlogLength, conf, portRangeConfig);\n      //Could be an ephemeral port\n      this.listenPort = acceptChannel.socket().getLocalPort();\n      Thread.currentThread().setName(\"Listener at \" +\n          bindAddress + \"/\" + this.listenPort);\n      // create a selector;\n      selector= Selector.open();\n      readers = new Reader[readThreads];\n      for (int i = 0; i < readThreads; i++) {\n        Reader reader = new Reader(\n            \"Socket Reader #\" + (i + 1) + \" for port \" + port);\n        readers[i] = reader;\n        reader.start();\n      }\n      // Register accepts on the server socket with the selector.\n      acceptChannel.register(selector, SelectionKey.OP_ACCEPT);\n      this.setName(\"IPC Server listener on \" + port);\n      this.setDaemon(true);\n    }\n    private class Reader extends Thread {\n      final private BlockingQueue<Connection> pendingConnections;\n      private final Selector readSelector;\n      Reader(String name) throws IOException {\n        super(name);\n        this.pendingConnections =\n            new LinkedBlockingQueue<Connection>(readerPendingConnectionQueue);\n        this.readSelector = Selector.open();\n      }\n      @Override\n      public void run() {\n        LOG.info(\"Starting \" + Thread.currentThread().getName());\n        try {\n          doRunLoop();\n        } finally {\n          try {\n            readSelector.close();\n          } catch (IOException ioe) {\n            LOG.error(\"Error closing read selector in \" + Thread.currentThread().getName(), ioe);\n          }\n        }\n      }\n      private synchronized void doRunLoop() {\n        while (running) {\n          SelectionKey key = null;\n          try {\n            // consume as many connections as currently queued to avoid\n            // unbridled acceptance of connections that starves the select\n            int size = pendingConnections.size();\n            for (int i=size; i>0; i--) {\n              Connection conn = pendingConnections.take();\n              conn.channel.register(readSelector, SelectionKey.OP_READ, conn);\n            }\n            readSelector.select();\n            Iterator<SelectionKey> iter = readSelector.selectedKeys().iterator();\n            while (iter.hasNext()) {\n              key = iter.next();\n              iter.remove();\n              try {\n                if (key.isReadable()) {\n                  doRead(key);\n                }\n              } catch (CancelledKeyException cke) {\n                // something else closed the connection, ex. responder or\n                // the listener doing an idle scan.  ignore it and let them\n                // clean up.\n                LOG.info(Thread.currentThread().getName() +\n                    \": connection aborted from \" + key.attachment());\n              }\n              key = null;\n            }\n          } catch (InterruptedException e) {\n            if (running) {                      // unexpected -- log it\n              LOG.info(Thread.currentThread().getName() + \" unexpectedly interrupted\", e);\n            }\n          } catch (IOException ex) {\n            LOG.error(\"Error in Reader\", ex);\n          } catch (Throwable re) {\n            LOG.error(\"Bug in read selector!\", re);\n            ExitUtil.terminate(1, \"Bug in read selector!\");\n          }\n        }\n      }\n      /**\n       * Updating the readSelector while it's being used is not thread-safe,\n       * so the connection must be queued.  The reader will drain the queue\n       * and update its readSelector before performing the next select\n       */\n      public void addConnection(Connection conn) throws InterruptedException {\n        pendingConnections.put(conn);\n        readSelector.wakeup();\n      }\n      void shutdown() {\n        assert !running;\n        readSelector.wakeup();\n        try {\n          super.interrupt();\n          super.join();\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n        }\n      }\n    }\n    @Override\n    public void run() {\n      LOG.info(Thread.currentThread().getName() + \": starting\");\n      SERVER.set(Server.this);\n      connectionManager.startIdleScan();\n      while (running) {\n        SelectionKey key = null;\n        try {\n          getSelector().select();\n          Iterator<SelectionKey> iter = getSelector().selectedKeys().iterator();\n          while (iter.hasNext()) {\n            key = iter.next();\n            iter.remove();\n            try {\n              if (key.isValid()) {\n                if (key.isAcceptable())\n                  doAccept(key);\n              }\n            } catch (IOException e) {\n            }\n            key = null;\n          }\n        } catch (OutOfMemoryError e) {\n          // we can run out of memory if we have too many threads\n          // log the event and sleep for a minute and give \n          // some thread(s) a chance to finish\n          LOG.warn(\"Out of Memory in server select\", e);\n          closeCurrentConnection(key, e);\n          connectionManager.closeIdle(true);\n          try { Thread.sleep(60000); } catch (Exception ie) {}\n        } catch (Exception e) {\n          closeCurrentConnection(key, e);\n        }\n      }\n      LOG.info(\"Stopping \" + Thread.currentThread().getName());\n      synchronized (this) {\n        try {\n          acceptChannel.close();\n          selector.close();\n        } catch (IOException e) { }\n        selector= null;\n        acceptChannel= null;\n        // close all connections\n        connectionManager.stopIdleScan();\n        connectionManager.closeAll();\n      }\n    }\n    private void closeCurrentConnection(SelectionKey key, Throwable e) {\n      if (key != null) {\n        Connection c = (Connection)key.attachment();\n        if (c != null) {\n          closeConnection(c);\n          c = null;\n        }\n      }\n    }\n<fim_suffix>    InetSocketAddress getAddress() {\n      return (InetSocketAddress)acceptChannel.socket().getLocalSocketAddress();\n    }<fim_middle>// function below has no smell\n"}