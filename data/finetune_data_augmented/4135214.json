{"text": "<fim_prefix>            includeEqualityInference,\n            joinType == JoinRelType.RIGHT ? leftFieldsBitSet\n                : allFieldsBitSet);\n        break;\n      }\n      Mappings.TargetMapping rightMapping = Mappings.createShiftMapping(\n          nSysFields + nFieldsLeft + nFieldsRight,\n          0, nSysFields + nFieldsLeft, nFieldsRight);\n      final RexPermuteInputsShuttle rightPermute =\n          new RexPermuteInputsShuttle(rightMapping, joinRel);\n      Mappings.TargetMapping leftMapping = Mappings.createShiftMapping(\n          nSysFields + nFieldsLeft, 0, nSysFields, nFieldsLeft);\n      final RexPermuteInputsShuttle leftPermute =\n          new RexPermuteInputsShuttle(leftMapping, joinRel);\n      final List<RexNode> leftInferredPredicates = new ArrayList<>();\n      final List<RexNode> rightInferredPredicates = new ArrayList<>();\n      for (RexNode iP : inferredPredicates) {\n        ImmutableBitSet iPBitSet = RelOptUtil.InputFinder.bits(iP);\n        if (leftFieldsBitSet.contains(iPBitSet)) {\n          leftInferredPredicates.add(iP.accept(leftPermute));\n        } else if (rightFieldsBitSet.contains(iPBitSet)) {\n          rightInferredPredicates.add(iP.accept(rightPermute));\n        }\n      }\n      final RexBuilder rexBuilder = joinRel.getCluster().getRexBuilder();\n      switch (joinType) {\n      case INNER:\n        Iterable<RexNode> pulledUpPredicates;\n        if (isSemiJoin) {\n          pulledUpPredicates = Iterables.concat(\n                RelOptUtil.conjunctions(leftChildPredicates),\n                leftInferredPredicates);\n        } else {\n          pulledUpPredicates = Iterables.concat(\n                RelOptUtil.conjunctions(leftChildPredicates),\n                RelOptUtil.conjunctions(rightChildPredicates),\n                RexUtil.retainDeterministic(\n                  RelOptUtil.conjunctions(joinRel.getCondition())),\n                inferredPredicates);\n        }\n        return RelOptPredicateList.of(rexBuilder, pulledUpPredicates,\n          leftInferredPredicates, rightInferredPredicates);\n      case LEFT:\n        return RelOptPredicateList.of(rexBuilder,\n            RelOptUtil.conjunctions(leftChildPredicates),\n            leftInferredPredicates, rightInferredPredicates);\n      case RIGHT:\n        return RelOptPredicateList.of(rexBuilder,\n            RelOptUtil.conjunctions(rightChildPredicates),\n            inferredPredicates, EMPTY_LIST);\n      default:\n        assert inferredPredicates.size() == 0;\n        return RelOptPredicateList.EMPTY;\n      }\n    }\n    public RexNode left() {\n      return leftChildPredicates;\n    }\n    public RexNode right() {\n      return rightChildPredicates;\n    }\n    private void infer(RexNode predicates, Set<RexNode> allExprs,\n        List<RexNode> inferredPredicates, boolean includeEqualityInference,\n        ImmutableBitSet inferringFields) {\n      for (RexNode r : RelOptUtil.conjunctions(predicates)) {\n        if (!includeEqualityInference\n            && equalityPredicates.contains(r)) {\n          continue;\n        }\n        for (Mapping m : mappings(r)) {\n          RexNode tr = r.accept(\n              new RexPermuteInputsShuttle(m, joinRel.getInput(0),\n                  joinRel.getInput(1)));\n          // Filter predicates can be already simplified, so we should work with\n          // simplified RexNode versions as well. It also allows prevent of having\n          // some duplicates in in result pulledUpPredicates\n          RexNode simplifiedTarget =\n              simplify.simplifyFilterPredicates(RelOptUtil.conjunctions(tr));\n          if (checkTarget(inferringFields, allExprs, tr)\n              && checkTarget(inferringFields, allExprs, simplifiedTarget)) {\n            inferredPredicates.add(simplifiedTarget);\n            allExprs.add(simplifiedTarget);\n          }\n        }\n      }\n    }\n    Iterable<Mapping> mappings(final RexNode predicate) {\n      final ImmutableBitSet fields = exprFields.get(predicate);\n      if (fields.cardinality() == 0) {\n        return Collections.emptyList();\n      }\n      return () -> new ExprsItr(fields);\n    }\n    private boolean checkTarget(ImmutableBitSet inferringFields,\n        Set<RexNode> allExprs, RexNode tr) {\n      return inferringFields.contains(RelOptUtil.InputFinder.bits(tr))\n          && !allExprs.contains(tr)\n          && !isAlwaysTrue(tr);\n    }\n    private void markAsEquivalent(int p1, int p2) {\n      BitSet b = equivalence.get(p1);\n      b.set(p2);\n      b = equivalence.get(p2);\n      b.set(p1);\n    }\n    @Nonnull RexNode compose(RexBuilder rexBuilder, Iterable<RexNode> exprs) {\n      exprs = Linq4j.asEnumerable(exprs).where(Objects::nonNull);\n      return RexUtil.composeConjunction(rexBuilder, exprs);\n    }\n    /**\n     * Find expressions of the form 'col_x = col_y'.\n     */\n    class EquivalenceFinder extends RexVisitorImpl<Void> {\n      protected EquivalenceFinder() {\n        super(true);\n      }\n      @Override public Void visitCall(RexCall call) {\n        if (call.getOperator().getKind() == SqlKind.EQUALS) {\n          int lPos = pos(call.getOperands().get(0));\n          int rPos = pos(call.getOperands().get(1));\n          if (lPos != -1 && rPos != -1) {\n            markAsEquivalent(lPos, rPos);\n            equalityPredicates.add(call);\n          }\n        }\n        return null;\n      }\n    }\n    /**\n     * Given an expression returns all the possible substitutions.\n     *\n     * <p>For example, for an expression 'a + b + c' and the following\n     * equivalences: <pre>\n     * a : {a, b}\n     * b : {a, b}\n     * c : {c, e}\n     * </pre>\n     *\n     * <p>The following Mappings will be returned:\n     * <pre>\n     * {a &rarr; a, b &rarr; a, c &rarr; c}\n     * {a &rarr; a, b &rarr; a, c &rarr; e}\n     * {a &rarr; a, b &rarr; b, c &rarr; c}\n     * {a &rarr; a, b &rarr; b, c &rarr; e}\n     * {a &rarr; b, b &rarr; a, c &rarr; c}\n     * {a &rarr; b, b &rarr; a, c &rarr; e}\n     * {a &rarr; b, b &rarr; b, c &rarr; c}\n     * {a &rarr; b, b &rarr; b, c &rarr; e}\n     * </pre>\n     *\n     * <p>which imply the following inferences:\n     * <pre>\n     * a + a + c\n     * a + a + e\n     * a + b + c\n     * a + b + e\n     * b + a + c\n     * b + a + e\n     * b + b + c\n     * b + b + e\n     * </pre>\n     */\n    class ExprsItr implements Iterator<Mapping> {\n      final int[] columns;\n      final BitSet[] columnSets;\n      final int[] iterationIdx;\n      Mapping nextMapping;\n      boolean firstCall;\n      ExprsItr(ImmutableBitSet fields) {\n        nextMapping = null;\n        columns = new int[fields.cardinality()];\n        columnSets = new BitSet[fields.cardinality()];\n        iterationIdx = new int[fields.cardinality()];\n        for (int j = 0, i = fields.nextSetBit(0); i >= 0; i = fields\n            .nextSetBit(i + 1), j++) {\n          columns[j] = i;\n          columnSets[j] = equivalence.get(i);\n          iterationIdx[j] = 0;\n        }\n        firstCall = true;\n      }\n<fim_suffix>      public boolean hasNext() {\n        if (firstCall) {\n          initializeMapping();\n          firstCall = false;\n        } else {\n          computeNextMapping(iterationIdx.length - 1);\n        }\n        return nextMapping != null;\n      }<fim_middle>// function below has no smell\n"}