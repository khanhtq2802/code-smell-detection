{"text": "<fim_prefix>     * Note that by not specifying the timezone the GDate\n     * becomes partially unordered with respect to times that\n     * do have a specified timezone.\n     */\n    public GDate(\n            int year,\n            int month,\n            int day,\n            int hour,\n            int minute,\n            int second,\n            BigDecimal fraction)\n    {\n        _bits = HAS_YEAR | HAS_MONTH | HAS_DAY | HAS_TIME;\n        _CY = year;\n        _M = month;\n        _D = day;\n        _h = hour;\n        _m = minute;\n        _s = second;\n        _fs = fraction == null ? _zero : fraction;\n        if (!isValid())\n            throw new IllegalArgumentException();\n    }\n    /**\n     * Constructs an absolute GDate with the specified year,\n     * month, day, hours, minutes, seconds, and optional fractional\n     * seconds, and in the timezone specified.\n     * <p>\n     * If you wish to have a time or date that isn't in a specified timezone,\n     * then use the constructor that does not include the timezone arguments.\n     */\n    public GDate(\n            int year,\n            int month,\n            int day,\n            int hour,\n            int minute,\n            int second,\n            BigDecimal fraction,\n            int tzSign,\n            int tzHour,\n            int tzMinute)\n    {\n        _bits = HAS_TIMEZONE | HAS_YEAR | HAS_MONTH | HAS_DAY | HAS_TIME;\n        _CY = year;\n        _M = month;\n        _D = day;\n        _h = hour;\n        _m = minute;\n        _s = second;\n        _fs = fraction == null ? _zero : fraction;\n        _tzsign = tzSign;\n        _tzh = tzHour;\n        _tzm = tzMinute;\n        if (!isValid())\n            throw new IllegalArgumentException();\n    }\n    /**\n     * Constructs a GDate based on a java.util.Date.\n     * <p>\n     * The current offset of the default timezone is used as the timezone.\n     * <p>\n     * For example, if eastern daylight time is in effect at the given\n     * date, the timezone on the east coast of the united states\n     * translates to GMT-05:00 (EST) + 1:00 (DT offset) == GMT-04:00.\n     */\n    public GDate(Date date)\n    {\n        // requires some date math, so ctor lives on GDateBuilder\n        this(new GDateBuilder(date));\n    }\n    /**\n     * Constructs a GDate based on a java.util.Calendar.\n     * <p>\n     * If the calendar does not have some fields set, the same absence\n     * of information is reflected in the GDate.  Note that\n     * java.util.GregorianCalendar fills in all fields as soon as any\n     * are fetched, so constructing a GDate with the same calendar object\n     * twice may result in a different GDate because of a changed calendar.\n     * Note that org.apache.xmlbeans.XmlCalendar is stable if you re-get a set field,\n     * so it does not have the same problem.\n     */\n    public GDate(Calendar calendar)\n    {\n        // we must scrape the \"isSet\" information out before accessing anything\n        boolean isSetYear = calendar.isSet(Calendar.YEAR);\n        boolean isSetEra = calendar.isSet(Calendar.ERA);\n        boolean isSetMonth = calendar.isSet(Calendar.MONTH);\n        boolean isSetDay = calendar.isSet(Calendar.DAY_OF_MONTH);\n        boolean isSetHourOfDay = calendar.isSet(Calendar.HOUR_OF_DAY);\n        boolean isSetHour = calendar.isSet(Calendar.HOUR);\n        boolean isSetAmPm = calendar.isSet(Calendar.AM_PM);\n        boolean isSetMinute = calendar.isSet(Calendar.MINUTE);\n        boolean isSetSecond = calendar.isSet(Calendar.SECOND);\n        boolean isSetMillis = calendar.isSet(Calendar.MILLISECOND);\n        boolean isSetZone = calendar.isSet(Calendar.ZONE_OFFSET);\n        boolean isSetDst = calendar.isSet(Calendar.DST_OFFSET);\n        if (isSetYear)\n        {\n            int y = calendar.get(Calendar.YEAR);\n            if (isSetEra && calendar instanceof GregorianCalendar)\n                if (calendar.get(Calendar.ERA) == GregorianCalendar.BC)\n                    y = -y; //1 - y;\n            _bits |= HAS_YEAR;\n            _CY = y;\n        }\n        if (isSetMonth)\n        {\n            _bits |= HAS_MONTH;\n            _M = calendar.get(Calendar.MONTH) + 1; // !!note\n        }\n        if (isSetDay)\n        {\n            _bits |= HAS_DAY;\n            _D = calendar.get(Calendar.DAY_OF_MONTH);\n        }\n        boolean gotTime = false;\n        int h = 0;\n        int m = 0;\n        int s = 0;\n        BigDecimal fs = _zero;\n        if (isSetHourOfDay)\n        {\n            h = calendar.get(Calendar.HOUR_OF_DAY);\n            gotTime = true;\n        }\n        else if (isSetHour && isSetAmPm)\n        {\n            h = calendar.get(Calendar.HOUR) + calendar.get(Calendar.AM_PM) * 12;\n            gotTime = true;\n        }\n        if (isSetMinute)\n        {\n            m = calendar.get(Calendar.MINUTE);\n            gotTime = true;\n        }\n        if (isSetSecond)\n        {\n            s = calendar.get(Calendar.SECOND);\n            gotTime = true;\n        }\n        if (isSetMillis)\n        {\n            fs = BigDecimal.valueOf(calendar.get(Calendar.MILLISECOND), 3);\n            gotTime = true;\n        }\n        if (gotTime)\n        {\n            _bits |= HAS_TIME;\n            _h = h;\n            _m = m;\n            _s = s;\n            _fs = fs;\n        }\n        if (isSetZone)\n        {\n            int zoneOffsetInMilliseconds = calendar.get(Calendar.ZONE_OFFSET);\n            if (isSetDst)\n                zoneOffsetInMilliseconds += calendar.get(Calendar.DST_OFFSET);\n            _bits |= HAS_TIMEZONE;\n            if (zoneOffsetInMilliseconds == 0)\n            {\n                _tzsign = 0;\n                _tzh = 0;\n                _tzm = 0;\n                TimeZone zone = calendar.getTimeZone();\n                String id = zone.getID();\n                if (id != null && id.length() > 3) switch (id.charAt(3))\n                {\n                    case '+': _tzsign = 1; break;   // GMT+00:00\n                    case '-': _tzsign = -1; break;  // GMT-00:00\n                }\n            }\n            else\n            {\n                _tzsign = (zoneOffsetInMilliseconds < 0 ? -1 : +1);\n                zoneOffsetInMilliseconds = zoneOffsetInMilliseconds * _tzsign;\n                _tzh = zoneOffsetInMilliseconds / 3600000;\n                _tzm = (zoneOffsetInMilliseconds - _tzh * 3600000) / 60000;\n            }\n        }\n    }\n    /**\n     * Constructs a GDate based on another GDateSpecification.\n     */\n    public GDate(GDateSpecification gdate)\n    {\n        if (gdate.hasTimeZone())\n        {\n            _bits |= HAS_TIMEZONE;\n            _tzsign = gdate.getTimeZoneSign();\n            _tzh = gdate.getTimeZoneHour();\n            _tzm = gdate.getTimeZoneMinute();\n        }\n        if (gdate.hasTime())\n        {\n            _bits |= HAS_TIME;\n            _h = gdate.getHour();\n            _m = gdate.getMinute();\n            _s = gdate.getSecond();\n            _fs = gdate.getFraction();\n        }\n        if (gdate.hasDay())\n        {\n            _bits |= HAS_DAY;\n            _D = gdate.getDay();\n        }\n        if (gdate.hasMonth())\n        {\n            _bits |= HAS_MONTH;\n            _M = gdate.getMonth();\n        }\n        if (gdate.hasYear())\n        {\n            _bits |= HAS_YEAR;\n            _CY = gdate.getYear();\n        }\n    }\n    /* package */ static final boolean isDigit(char ch)\n    {\n        return ((char)(ch - '0') <= '9' - '0'); // char is unsigned\n    }\n    /* package */ static final boolean isSpace(char ch)\n    {\n        switch (ch)\n        {\n            case ' ':\n            case '\\t':\n            case '\\r':\n            case '\\n':\n                return true;\n            default:\n                return false;\n        }\n    }\n    /* package */ static final int digitVal(char ch)\n    {\n        return (ch - '0');\n    }\n<fim_suffix>    private static final int twoDigit(CharSequence str, int index)\n    {\n        char ch1 = str.charAt(index);\n        char ch2 = str.charAt(index + 1);\n        if (!isDigit(ch1) || !isDigit(ch2))\n            return 100; // not two digits\n        return digitVal(ch1) * 10 + digitVal(ch2);\n    }<fim_middle>// function below has no smell\n"}