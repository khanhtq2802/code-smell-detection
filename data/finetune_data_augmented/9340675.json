{"text": "<fim_prefix>/*\n * Copyright (c) 1998, 2017, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage com.sun.tools.jdi;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport com.sun.jdi.ClassNotLoadedException;\nimport com.sun.jdi.ClassType;\nimport com.sun.jdi.Field;\nimport com.sun.jdi.IncompatibleThreadStateException;\nimport com.sun.jdi.InterfaceType;\nimport com.sun.jdi.InternalException;\nimport com.sun.jdi.InvalidTypeException;\nimport com.sun.jdi.InvocationException;\nimport com.sun.jdi.Method;\nimport com.sun.jdi.ObjectReference;\nimport com.sun.jdi.ReferenceType;\nimport com.sun.jdi.ThreadReference;\nimport com.sun.jdi.Type;\nimport com.sun.jdi.Value;\nimport com.sun.jdi.VirtualMachine;\npublic class ObjectReferenceImpl extends ValueImpl\n             implements ObjectReference, VMListener\n{\n    protected long ref;\n    private ReferenceType type = null;\n    private int gcDisableCount = 0;\n    boolean addedListener = false;\n    // This is cached only while the VM is suspended\n    protected static class Cache {\n        JDWP.ObjectReference.MonitorInfo monitorInfo = null;\n    }\n    private static final Cache noInitCache = new Cache();\n    private static final Cache markerCache = new Cache();\n    private Cache cache = noInitCache;\n    private void disableCache() {\n        synchronized (vm.state()) {\n            cache = null;\n        }\n    }\n    private void enableCache() {\n        synchronized (vm.state()) {\n            cache = markerCache;\n        }\n    }\n    // Override in subclasses\n    protected Cache newCache() {\n        return new Cache();\n    }\n    protected Cache getCache() {\n        synchronized (vm.state()) {\n            if (cache == noInitCache) {\n                if (vm.state().isSuspended()) {\n                    // Set cache now, otherwise newly created objects are\n                    // not cached until resuspend\n                    enableCache();\n                } else {\n                    disableCache();\n                }\n            }\n            if (cache == markerCache) {\n                cache = newCache();\n            }\n            return cache;\n        }\n    }\n    // Return the ClassTypeImpl upon which to invoke a method.\n    // By default it is our very own referenceType() but subclasses\n    // can override.\n    protected ClassTypeImpl invokableReferenceType(Method method) {\n        return (ClassTypeImpl)referenceType();\n    }\n    ObjectReferenceImpl(VirtualMachine aVm,long aRef) {\n        super(aVm);\n        ref = aRef;\n    }\n    protected String description() {\n        return \"ObjectReference \" + uniqueID();\n    }\n    /*\n     * VMListener implementation\n     */\n    public boolean vmSuspended(VMAction action) {\n        enableCache();\n        return true;\n    }\n    public boolean vmNotSuspended(VMAction action) {\n        // make sure that cache and listener management are synchronized\n        synchronized (vm.state()) {\n            if (cache != null && (vm.traceFlags & VirtualMachine.TRACE_OBJREFS) != 0) {\n                vm.printTrace(\"Clearing temporary cache for \" + description());\n            }\n            disableCache();\n            if (addedListener) {\n                /*\n                 * If a listener was added (i.e. this is not a\n                 * ObjectReference that adds a listener on startup),\n                 * remove it here.\n                 */\n                addedListener = false;\n                return false;  // false says remove\n            } else {\n                return true;\n            }\n        }\n    }\n    public boolean equals(Object obj) {\n        if ((obj != null) && (obj instanceof ObjectReferenceImpl)) {\n            ObjectReferenceImpl other = (ObjectReferenceImpl)obj;\n            return (ref() == other.ref()) &&\n                   super.equals(obj);\n        } else {\n            return false;\n        }\n    }\n    public int hashCode() {\n        return(int)ref();\n    }\n    public Type type() {\n        return referenceType();\n    }\n<fim_suffix>    public ReferenceType referenceType() {\n        if (type == null) {\n            try {\n                JDWP.ObjectReference.ReferenceType rtinfo =\n                    JDWP.ObjectReference.ReferenceType.process(vm, this);\n                type = vm.referenceType(rtinfo.typeID,\n                                        rtinfo.refTypeTag);\n            } catch (JDWPException exc) {\n                throw exc.toJDIException();\n            }\n        }\n        return type;\n    }\n    public Value getValue(Field sig) {\n        List<Field> list = new ArrayList<>(1);\n        list.add(sig);\n        Map<Field, Value> map = getValues(list);\n        return map.get(sig);\n    }\n    public Map<Field,Value> getValues(List<? extends Field> theFields) {\n        validateMirrors(theFields);\n        List<Field> staticFields = new ArrayList<>(0);\n        int size = theFields.size();\n        List<Field> instanceFields = new ArrayList<>(size);\n        for (int i = 0; i < size; i++) {\n            Field field = theFields.get(i);\n            // Make sure the field is valid\n            ((ReferenceTypeImpl)referenceType()).validateFieldAccess(field);\n            // FIX ME! We need to do some sanity checking\n            // here; make sure the field belongs to this\n            // object.\n            if (field.isStatic())\n                staticFields.add(field);\n            else {\n                instanceFields.add(field);\n            }\n        }\n        Map<Field, Value> map;\n        if (staticFields.size() > 0) {\n            map = referenceType().getValues(staticFields);\n        } else {\n            map = new HashMap<Field, Value>(size);\n        }\n        size = instanceFields.size();\n        JDWP.ObjectReference.GetValues.Field[] queryFields =\n                         new JDWP.ObjectReference.GetValues.Field[size];\n        for (int i=0; i<size; i++) {\n            FieldImpl field = (FieldImpl)instanceFields.get(i);/* thanks OTI */\n            queryFields[i] = new JDWP.ObjectReference.GetValues.Field(\n                                         field.ref());\n        }\n        ValueImpl[] values;\n        try {\n            values = JDWP.ObjectReference.GetValues.\n                                     process(vm, this, queryFields).values;\n        } catch (JDWPException exc) {\n            throw exc.toJDIException();\n        }\n        if (size != values.length) {\n            throw new InternalException(\n                         \"Wrong number of values returned from target VM\");\n        }\n        for (int i=0; i<size; i++) {\n            FieldImpl field = (FieldImpl)instanceFields.get(i);\n            map.put(field, values[i]);\n        }\n        return map;\n    }\n    public void setValue(Field field, Value value)\n                   throws InvalidTypeException, ClassNotLoadedException {\n        validateMirror(field);\n        validateMirrorOrNull(value);\n        // Make sure the field is valid\n        ((ReferenceTypeImpl)referenceType()).validateFieldSet(field);\n        if (field.isStatic()) {\n            ReferenceType type = referenceType();\n            if (type instanceof ClassType) {\n                ((ClassType)type).setValue(field, value);\n                return;\n            } else {\n                throw new IllegalArgumentException(\n                                    \"Invalid type for static field set\");\n            }\n        }\n        try {\n            JDWP.ObjectReference.SetValues.FieldValue[] fvals =\n                      new JDWP.ObjectReference.SetValues.FieldValue[1];\n            fvals[0] = new JDWP.ObjectReference.SetValues.FieldValue(\n                           ((FieldImpl)field).ref(),\n                           // Validate and convert if necessary\n                           ValueImpl.prepareForAssignment(value,\n                                                          (FieldImpl)field));<fim_middle>// function below has no smell\n"}