{"text": "<fim_prefix> * limitations under the License.\n */\npackage org.apache.marmotta.kiwi.sail;\nimport com.google.common.base.Function;\nimport com.google.common.collect.Iterables;\nimport com.google.common.collect.Lists;\nimport info.aduna.iteration.*;\nimport org.apache.marmotta.commons.sesame.repository.ResourceConnection;\nimport org.apache.marmotta.kiwi.exception.ResultInterruptedException;\nimport org.apache.marmotta.kiwi.model.rdf.*;\nimport org.apache.marmotta.kiwi.persistence.KiWiConnection;\nimport org.openrdf.model.*;\nimport org.openrdf.query.BindingSet;\nimport org.openrdf.query.Dataset;\nimport org.openrdf.query.QueryEvaluationException;\nimport org.openrdf.query.QueryInterruptedException;\nimport org.openrdf.query.algebra.QueryRoot;\nimport org.openrdf.query.algebra.StatementPattern;\nimport org.openrdf.query.algebra.TupleExpr;\nimport org.openrdf.query.algebra.Var;\nimport org.openrdf.query.algebra.evaluation.EvaluationStrategy;\nimport org.openrdf.query.algebra.evaluation.TripleSource;\nimport org.openrdf.query.algebra.evaluation.impl.*;\nimport org.openrdf.query.impl.EmptyBindingSet;\nimport org.openrdf.repository.RepositoryException;\nimport org.openrdf.repository.RepositoryResult;\nimport org.openrdf.sail.Sail;\nimport org.openrdf.sail.SailChangedEvent;\nimport org.openrdf.sail.SailException;\nimport org.openrdf.sail.helpers.NotifyingSailConnectionBase;\nimport org.openrdf.sail.inferencer.InferencerConnection;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport java.io.IOException;\nimport java.nio.channels.ClosedByInterruptException;\nimport java.sql.SQLException;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\n/**\n * A sail connection wrapping a KiWi database connection. Mostly delegates method calls to the underlying connection.\n * <p/>\n * Author: Sebastian Schaffert\n */\npublic class KiWiSailConnection extends NotifyingSailConnectionBase implements InferencerConnection, ResourceConnection {\n    private static final Logger log = LoggerFactory.getLogger(KiWiSailConnection.class);\n    /**\n     * Internal JDBC connection to the database. Will be committed when the SailConnection commits.\n     */\n    protected KiWiConnection databaseConnection;\n    private String defaultContext;\n    private String inferredContext;\n    private KiWiValueFactory valueFactory;\n    private KiWiStore store;\n    private boolean triplesAdded, triplesRemoved;\n    public KiWiSailConnection(KiWiStore sailBase) throws SailException {\n        super(sailBase);\n        this.store = sailBase;\n        try {\n            this.databaseConnection = sailBase.getPersistence().getConnection();\n            this.defaultContext     = sailBase.getDefaultContext();\n            this.inferredContext    = sailBase.getInferredContext();\n            //this.valueFactory       = new KiWiValueFactory(sailBase,databaseConnection,defaultContext);\n            this.valueFactory       = (KiWiValueFactory) sailBase.getValueFactory();\n        } catch (SQLException e) {\n            throw new SailException(\"error establishing database connection\",e);\n        }\n    }\n    public KiWiConnection getDatabaseConnection() {\n        return databaseConnection;\n    }\n    @Override\n    protected void addStatementInternal(Resource subj, URI pred, Value obj, Resource... contexts) throws SailException {\n        addStatementInternal(subj,pred,obj,false,contexts);\n    }\n    /**\n     * Adds an inferred statement to a specific context.\n     *\n     * @param subj     The subject of the statement to add.\n     * @param pred     The predicate of the statement to add.\n     * @param obj      The object of the statement to add.\n     * @param contexts The context(s) to add the statement to. Note that this parameter is\n     *                 a vararg and as such is optional. If no contexts are supplied the\n     *                 method operates on the entire repository.\n     * @throws org.openrdf.sail.SailException If the statement could not be added.\n     * @throws IllegalStateException          If the connection has been closed.\n     */\n    @Override\n    public boolean addInferredStatement(Resource subj, URI pred, Value obj, Resource... contexts) throws SailException {\n        return addStatementInternal(subj,pred,obj,true,valueFactory.createURI(inferredContext)).size() > 0;\n    }\n    /**\n     * Used by the KiWi reasoner, returns the created inferred statement directly.\n     * @throws SailException\n     */\n    public KiWiTriple addInferredStatement(Resource subj, URI pred, Value obj) throws SailException {\n        return addStatementInternal(subj,pred,obj,true,valueFactory.createURI(inferredContext)).iterator().next();\n    }\n    public Set<KiWiTriple> addStatementInternal(Resource subj, URI pred, Value obj, boolean inferred, Resource... contexts) throws SailException {\n        try {\n            Set<Resource> contextSet = new HashSet<>();\n            for(Resource ctx : contexts) {\n                if(ctx != null) {\n                    contextSet.add(ctx);\n                }\n            }\n            if(contextSet.size() == 0) {\n                if(defaultContext != null) {\n                    contextSet.add(valueFactory.createURI(defaultContext));\n                } else {\n                    contextSet.add(null);\n                }\n            }\n            if(inferred && inferredContext != null) {\n                contextSet.add(valueFactory.createURI(inferredContext));\n            }\n            Set<KiWiTriple> added = new HashSet<>();\n            for(Resource context : contextSet) {\n                KiWiResource kcontext = valueFactory.convert(context);\n                KiWiTriple triple = (KiWiTriple)valueFactory.createStatement(subj,pred,obj,kcontext, databaseConnection);\n                triple.setInferred(inferred);\n                databaseConnection.storeTriple(triple);\n                if(triple.isNewTriple()) {\n                    triplesAdded = true;\n                    notifyStatementAdded(triple);\n                }\n                added.add(triple);\n            }\n            return added;\n        } catch(SQLException ex) {\n            log.error(String.format(\"Could not persist rdf-statement (%s %s %s)\", subj, pred, obj ), ex);\n            throw new SailException(\"database error while storing statement\",ex);\n        }\n    }\n    @Override\n    protected void closeInternal() throws SailException {\n        try {\n            databaseConnection.close();\n        } catch (SQLException e) {\n            throw new SailException(\"database error while closing connection\",e);\n        }\n    }\n    /**\n     * Implementation of SPARQL/SeRQL querying using an abstract query expression. This very basic implementation relies\n     * on the getStatements method to list triples and is not very efficient for complex queries. You might want to\n     * use the kiwi-sparql module to improve the query performance.\n     *\n     * @param tupleExpr\n     * @param dataset\n     * @param bindings\n     * @param includeInferred\n     * @return\n     * @throws SailException\n     */\n<fim_suffix>    @Override\n    protected CloseableIteration<? extends BindingSet, QueryEvaluationException> evaluateInternal(TupleExpr tupleExpr, Dataset dataset, BindingSet bindings, boolean includeInferred) throws SailException {\n        // Clone the tuple expression to allow for more aggressive optimizations\n        tupleExpr = tupleExpr.clone();\n        if (!(tupleExpr instanceof QueryRoot)) {\n            // Add a dummy root node to the tuple expressions to allow the\n            // optimizers to modify the actual root node\n            tupleExpr = new QueryRoot(tupleExpr);\n        }\n        try {\n            KiWiTripleSource tripleSource = new KiWiTripleSource(this,includeInferred);\n            EvaluationStrategy strategy = new EvaluationStrategyImpl(tripleSource, dataset);\n            new BindingAssigner().optimize(tupleExpr, dataset, bindings);\n            new ConstantOptimizer(strategy).optimize(tupleExpr, dataset, bindings);\n            new CompareOptimizer().optimize(tupleExpr, dataset, bindings);\n            new ConjunctiveConstraintSplitter().optimize(tupleExpr, dataset, bindings);\n            new DisjunctiveConstraintOptimizer().optimize(tupleExpr, dataset, bindings);\n            new SameTermFilterOptimizer().optimize(tupleExpr, dataset, bindings);\n            new QueryModelNormalizer().optimize(tupleExpr, dataset, bindings);\n            new QueryJoinOptimizer(new KiWiEvaluationStatistics()).optimize(tupleExpr, dataset, bindings);\n            new IterativeEvaluationOptimizer().optimize(tupleExpr, dataset, bindings);\n            new FilterOptimizer().optimize(tupleExpr, dataset, bindings);\n            new OrderLimitOptimizer().optimize(tupleExpr, dataset, bindings);\n            return strategy.evaluate(tupleExpr, EmptyBindingSet.getInstance());\n        } catch (QueryEvaluationException e) {\n            throw new SailException(e);\n        }\n    }<fim_middle>// function below has no smell\n"}