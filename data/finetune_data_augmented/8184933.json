{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.activemq.store.kahadb.disk.util;\nimport java.io.DataInput;\nimport java.io.DataOutput;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.NoSuchElementException;\n/**\n * Keeps track of a added long values. Collapses ranges of numbers using a\n * Sequence representation. Use to keep track of received message ids to find\n * out if a message is duplicate or if there are any missing messages.\n *\n * @author chirino\n */\npublic class SequenceSet extends LinkedNodeList<Sequence> implements Iterable<Long> {\n    public static class Marshaller implements org.apache.activemq.store.kahadb.disk.util.Marshaller<SequenceSet> {\n        public static final Marshaller INSTANCE = new Marshaller();\n        public SequenceSet readPayload(DataInput in) throws IOException {\n            SequenceSet value = new SequenceSet();\n            int count = in.readInt();\n            for (int i = 0; i < count; i++) {\n                if( in.readBoolean() ) {\n                    Sequence sequence = new Sequence(in.readLong(), in.readLong());\n                    value.addLast(sequence);\n                } else {\n                    Sequence sequence = new Sequence(in.readLong());\n                    value.addLast(sequence);\n                }\n            }\n            return value;\n        }\n        public void writePayload(SequenceSet value, DataOutput out) throws IOException {\n            out.writeInt(value.size());\n            Sequence sequence = value.getHead();\n            while (sequence != null ) {\n                if( sequence.range() > 1 ) {\n                    out.writeBoolean(true);\n                    out.writeLong(sequence.first);\n                    out.writeLong(sequence.last);\n                } else {\n                    out.writeBoolean(false);\n                    out.writeLong(sequence.first);\n                }\n                sequence = sequence.getNext();\n            }\n        }\n        public int getFixedSize() {\n            return -1;\n        }\n        public SequenceSet deepCopy(SequenceSet value) {\n            SequenceSet rc = new SequenceSet();\n            Sequence sequence = value.getHead();\n            while (sequence != null ) {\n                rc.add(new Sequence(sequence.first, sequence.last));\n                sequence = sequence.getNext();\n            }\n            return rc;\n        }\n        public boolean isDeepCopySupported() {\n            return true;\n        }\n    }\n<fim_suffix>    public void add(Sequence value) {\n        // TODO we can probably optimize this a bit\n        for(long i=value.first; i<value.last+1; i++) {\n            add(i);\n        }\n    }\n    public void merge(SequenceSet sequenceSet) {\n        Sequence node = sequenceSet.getHead();\n        while (node != null) {\n            add(node);\n            node = node.getNext();\n        }\n    }\n    public void remove(SequenceSet sequenceSet) {\n        Sequence node = sequenceSet.getHead();\n        while (node != null) {\n            remove(node);\n            node = node.getNext();\n        }\n    }\n    public void remove(Sequence value) {\n        for(long i=value.first; i<value.last+1; i++) {\n            remove(i);\n        }\n    }\n    /**\n     *\n     * @param value\n     *            the value to add to the list\n     * @return false if the value was a duplicate.\n     */\n    public boolean add(long value) {\n        if (isEmpty()) {\n            addFirst(new Sequence(value));\n            return true;\n        }\n        // check for append\n        Sequence sequence = getTail();\n        if (sequence.isAdjacentToLast(value)) {\n            sequence.last = value;\n            return true;\n        }\n        // check if the value is greater than the bigger sequence value and if it's not adjacent to it\n        // in this case, we are sure that the value should be add to the tail of the sequence.\n        if (sequence.isBiggerButNotAdjacentToLast(value)) {\n            addLast(new Sequence(value));\n            return true;\n        }\n        sequence = getHead();\n        while (sequence != null) {\n            if (sequence.isAdjacentToLast(value)) {\n                // grow the sequence...\n                sequence.last = value;\n                // it might connect us to the next sequence..\n                if (sequence.getNext() != null) {\n                    Sequence next = sequence.getNext();\n                    if (next.isAdjacentToFirst(value)) {\n                        // Yep the sequence connected.. so join them.\n                        sequence.last = next.last;\n                        next.unlink();\n                    }\n                }\n                return true;\n            }\n            if (sequence.isAdjacentToFirst(value)) {\n                // grow the sequence...\n                sequence.first = value;\n                // it might connect us to the previous\n                if (sequence.getPrevious() != null) {\n                    Sequence prev = sequence.getPrevious();\n                    if (prev.isAdjacentToLast(value)) {\n                        // Yep the sequence connected.. so join them.\n                        sequence.first = prev.first;\n                        prev.unlink();\n                    }\n                }\n                return true;\n            }\n            // Did that value land before this sequence?\n            if (value < sequence.first) {\n                // Then insert a new entry before this sequence item.\n                sequence.linkBefore(new Sequence(value));\n                return true;\n            }\n            // Did that value land within the sequence? The it's a duplicate.\n            if (sequence.contains(value)) {\n                return false;\n            }\n            sequence = sequence.getNext();\n        }\n        // Then the value is getting appended to the tail of the sequence.\n        addLast(new Sequence(value));\n        return true;\n    }\n    /**\n     * Removes the given value from the Sequence set, splitting a\n     * contained sequence if necessary.\n     *\n     * @param value\n     *          The value that should be removed from the SequenceSet.\n     *\n     * @return true if the value was removed from the set, false if there\n     *         was no sequence in the set that contained the given value.\n     */\n    public boolean remove(long value) {\n        Sequence sequence = getHead();\n        while (sequence != null ) {\n            if(sequence.contains(value)) {\n                if (sequence.range() == 1) {\n                    sequence.unlink();\n                    return true;\n                } else if (sequence.getFirst() == value) {\n                    sequence.setFirst(value+1);\n                    return true;\n                } else if (sequence.getLast() == value) {\n                    sequence.setLast(value-1);\n                    return true;\n                } else {\n                    sequence.linkBefore(new Sequence(sequence.first, value-1));\n                    sequence.linkAfter(new Sequence(value+1, sequence.last));\n                    sequence.unlink();\n                    return true;\n                }\n            }\n            sequence = sequence.getNext();\n        }\n        return false;\n    }\n    /**\n     * Removes and returns the first element from this list.\n     *\n     * @return the first element from this list.\n     * @throws NoSuchElementException if this list is empty.\n     */\n    public long removeFirst() {\n        if (isEmpty()) {\n            throw new NoSuchElementException();\n        }\n        Sequence rc = removeFirstSequence(1);\n        return rc.first;\n    }\n    /**\n     * Removes and returns the last sequence from this list.\n     *\n     * @return the last sequence from this list or null if the list is empty.\n     */\n    public Sequence removeLastSequence() {\n        if (isEmpty()) {\n            return null;\n        }\n        Sequence rc = getTail();\n        rc.unlink();\n        return rc;\n    }\n    /**\n     * Removes and returns the first sequence that is count range large.\n     *\n     * @return a sequence that is count range large, or null if no sequence is that large in the list.\n     */\n    public Sequence removeFirstSequence(long count) {\n        if (isEmpty()) {\n            return null;\n        }\n        Sequence sequence = getHead();\n        while (sequence != null ) {\n            if (sequence.range() == count ) {\n                sequence.unlink();\n                return sequence;\n            }\n            if (sequence.range() > count ) {\n                Sequence rc = new Sequence(sequence.first, sequence.first+count-1);\n                sequence.first+=count;\n                return rc;\n            }\n            sequence = sequence.getNext();\n        }\n        return null;\n    }\n    /**\n     * @return all the id Sequences that are missing from this set that are not\n     *         in between the range provided.\n     */\n    public List<Sequence> getMissing(long first, long last) {<fim_middle>// function below has no smell\n"}