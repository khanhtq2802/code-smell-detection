{"text": "<fim_prefix>/*\n * Copyright 2002-2013 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.springframework.security.oauth2.config.annotation.web.configuration;\n\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.springframework.aop.framework.Advised;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.core.Ordered;\nimport org.springframework.security.authentication.AnonymousAuthenticationProvider;\nimport org.springframework.security.authentication.AuthenticationEventPublisher;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.security.config.http.SessionCreationPolicy;\nimport org.springframework.security.oauth2.config.annotation.web.configurers.ResourceServerSecurityConfigurer;\nimport org.springframework.security.oauth2.provider.endpoint.FrameworkEndpointHandlerMapping;\nimport org.springframework.security.oauth2.provider.token.ResourceServerTokenServices;\nimport org.springframework.security.oauth2.provider.token.TokenStore;\nimport org.springframework.security.web.util.matcher.RequestMatcher;\nimport org.springframework.util.ReflectionUtils;\n\n/**\n * @author Dave Syer\n * \n */\n<fim_suffix>@Configuration\npublic class ResourceServerConfiguration extends WebSecurityConfigurerAdapter implements Ordered {\n\n\tprivate int order = 3;\n\n\t@Autowired(required = false)\n\tprivate TokenStore tokenStore;\n\n\t@Autowired(required = false)\n\tprivate AuthenticationEventPublisher eventPublisher;\n\n\t@Autowired(required = false)\n\tprivate Map<String, ResourceServerTokenServices> tokenServices;\n\n\t@Autowired\n\tprivate ApplicationContext context;\n\n\tprivate List<ResourceServerConfigurer> configurers = Collections.emptyList();\n\n\t@Autowired(required = false)\n\tprivate AuthorizationServerEndpointsConfiguration endpoints;\n\n\t@Override\n\tpublic int getOrder() {\n\t\treturn order;\n\t}\n\n\tpublic void setOrder(int order) {\n\t\tthis.order = order;\n\t}\n\n\t/**\n\t * @param configurers the configurers to set\n\t */\n\t@Autowired(required = false)\n\tpublic void setConfigurers(List<ResourceServerConfigurer> configurers) {\n\t\tthis.configurers = configurers;\n\t}\n\n\tprivate static class NotOAuthRequestMatcher implements RequestMatcher {\n\n\t\tprivate FrameworkEndpointHandlerMapping mapping;\n\n\t\tpublic NotOAuthRequestMatcher(FrameworkEndpointHandlerMapping mapping) {\n\t\t\tthis.mapping = mapping;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean matches(HttpServletRequest request) {\n\t\t\tString requestPath = getRequestPath(request);\n\t\t\tfor (String path : mapping.getPaths()) {\n\t\t\t\tif (requestPath.startsWith(mapping.getPath(path))) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate String getRequestPath(HttpServletRequest request) {\n\t\t\tString url = request.getServletPath();\n\n\t\t\tif (request.getPathInfo() != null) {\n\t\t\t\turl += request.getPathInfo();\n\t\t\t}\n\n\t\t\treturn url;\n\t\t}\n\n\t}\n\n\t@Override\n\tprotected void configure(HttpSecurity http) throws Exception {\n\t\tResourceServerSecurityConfigurer resources = new ResourceServerSecurityConfigurer();\n\t\tResourceServerTokenServices services = resolveTokenServices();\n\t\tif (services != null) {\n\t\t\tresources.tokenServices(services);\n\t\t}\n\t\telse {\n\t\t\tif (tokenStore != null) {\n\t\t\t\tresources.tokenStore(tokenStore);\n\t\t\t}\n\t\t\telse if (endpoints != null) {\n\t\t\t\tresources.tokenStore(endpoints.getEndpointsConfigurer().getTokenStore());\n\t\t\t}\n\t\t}\n\t\tif (eventPublisher != null) {\n\t\t\tresources.eventPublisher(eventPublisher);\n\t\t}\n\t\tfor (ResourceServerConfigurer configurer : configurers) {\n\t\t\tconfigurer.configure(resources);\n\t\t}\n\t\t// @formatter:off\n\t\thttp.authenticationProvider(new AnonymousAuthenticationProvider(\"default\"))\n\t\t// N.B. exceptionHandling is duplicated in resources.configure() so that\n\t\t// it works\n\t\t.exceptionHandling()\n\t\t\t\t.accessDeniedHandler(resources.getAccessDeniedHandler()).and()\n\t\t\t\t.sessionManagement()\n\t\t\t\t.sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()\n\t\t\t\t.csrf().disable();\n\t\t// @formatter:on\n\t\thttp.apply(resources);\n\t\tif (endpoints != null) {\n\t\t\t// Assume we are in an Authorization Server\n\t\t\thttp.requestMatcher(new NotOAuthRequestMatcher(endpoints.oauth2EndpointHandlerMapping()));\n\t\t}\n\t\tfor (ResourceServerConfigurer configurer : configurers) {\n\t\t\t// Delegates can add authorizeRequests() here\n\t\t\tconfigurer.configure(http);\n\t\t}\n\t\tif (configurers.isEmpty()) {\n\t\t\t// Add anyRequest() last as a fall back. Spring Security would\n\t\t\t// replace an existing anyRequest() matcher with this one, so to\n\t\t\t// avoid that we only add it if the user hasn't configured anything.\n\t\t\thttp.authorizeRequests().anyRequest().authenticated();\n\t\t}\n\t}\n\n\tprivate ResourceServerTokenServices resolveTokenServices() {\n\t\tif (tokenServices == null || tokenServices.size() == 0) {\n\t\t\treturn null;\n\t\t}\n\t\tif (tokenServices.size() == 1) {\n\t\t\treturn tokenServices.values().iterator().next();\n\t\t}\n\t\tif (tokenServices.size() == 2) {\n\t\t\t// Maybe they are the ones provided natively\n\t\t\tIterator<ResourceServerTokenServices> iter = tokenServices.values().iterator();\n\t\t\tResourceServerTokenServices one = iter.next();\n\t\t\tResourceServerTokenServices two = iter.next();\n\t\t\tif (elementsEqual(one, two)) {\n\t\t\t\treturn one;\n\t\t\t}\n\t\t}\n\t\treturn context.getBean(ResourceServerTokenServices.class);\n\t}\n\n\tprivate boolean elementsEqual(Object one, Object two) {\n\t\t// They might just be equal\n\t\tif (one == two) {\n\t\t\treturn true;\n\t\t}\n\t\tObject targetOne = findTarget(one);\n\t\tObject targetTwo = findTarget(two);\n\t\treturn targetOne == targetTwo;\n\t}\n\n\tprivate Object findTarget(Object item) {\n\t\tObject current = item;\n\t\twhile (current instanceof Advised) {\n\t\t\ttry {\n\t\t\t\tcurrent = ((Advised) current).getTargetSource().getTarget();\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tReflectionUtils.rethrowRuntimeException(e);\n\t\t\t}\n\t\t}\n\t\treturn current;\n\t}\n\n}<fim_middle>// class below has no smell\n"}