{"text": "<fim_prefix>     * The name is derived from {@code path}.\n     *\n     * @param fileManager the file manager creating this file object\n     * @param path the path referred to by this file object\n     * @return the file object\n     */\n    public static PathFileObject forJRTPath(BaseFileManager fileManager,\n            final Path path) {\n        return new JRTFileObject(fileManager, path);\n    }\n    private static class JRTFileObject extends PathFileObject {\n        // private final Path javaHome;\n        private JRTFileObject(BaseFileManager fileManager, Path path) {\n            super(fileManager, path);\n        }\n        @Override @DefinedBy(Api.COMPILER)\n        public String getName() {\n            return path.toString();\n        }\n        @Override\n        public String inferBinaryName(Iterable<? extends Path> paths) {\n            // use subpath to ignore the leading /modules/MODULE-NAME\n            return toBinaryName(path.subpath(2, path.getNameCount()));\n        }\n        @Override\n        public String toString() {\n            return \"JRTFileObject[\" + path + \"]\";\n        }\n        @Override\n        PathFileObject getSibling(String baseName) {\n            return new JRTFileObject(fileManager,\n                    path.resolveSibling(baseName)\n            );\n        }\n    }\n    /**\n     * Create a PathFileObject for a file whose binary name must be inferred\n     * from its position on a search path.\n     *\n     * The binary name is inferred by finding an enclosing directory in\n     * the sequence of paths associated with the location given to\n     * {@link JavaFileManager#inferBinaryName).\n     * The name is derived from {@code userPath}.\n     *\n     * @param fileManager the file manager creating this file object\n     * @param path the path referred to by this file object\n     * @param userPath the \"user-friendly\" name for this path.\n     */\n    static PathFileObject forSimplePath(BaseFileManager fileManager,\n            Path path, Path userPath) {\n        return new SimpleFileObject(fileManager, path, userPath);\n    }\n    private static class SimpleFileObject extends PathFileObject {\n        private final Path userPath;\n        private SimpleFileObject(BaseFileManager fileManager, Path path, Path userPath) {\n            super(fileManager, path);\n            this.userPath = userPath;\n        }\n        @Override @DefinedBy(Api.COMPILER)\n        public String getName() {\n            return userPath.toString();\n        }\n        @Override\n        public String inferBinaryName(Iterable<? extends Path> paths) {\n            Path absPath = path.toAbsolutePath();\n            for (Path p: paths) {\n                Path ap = p.toAbsolutePath();\n                if (absPath.startsWith(ap)) {\n                    try {\n                        Path rp = ap.relativize(absPath);\n                        if (rp != null) // maybe null if absPath same as ap\n                            return toBinaryName(rp);\n                    } catch (IllegalArgumentException e) {\n                        // ignore this p if cannot relativize path to p\n                    }\n                }\n            }\n            return null;\n        }\n        @Override @DefinedBy(Api.COMPILER)\n        public Kind getKind() {\n            return BaseFileManager.getKind(userPath);\n        }\n        @Override @DefinedBy(Api.COMPILER)\n        public boolean isNameCompatible(String simpleName, Kind kind) {\n            return isPathNameCompatible(userPath, simpleName, kind);\n        }\n        @Override\n        PathFileObject getSibling(String baseName) {\n            return new SimpleFileObject(fileManager,\n                    path.resolveSibling(baseName),\n                    userPath.resolveSibling(baseName)\n            );\n        }\n    }\n    /**\n     * Create a PathFileObject, for a specified path, in the context of\n     * a given file manager.\n     *\n     * In general, this path should be an\n     * {@link Path#toAbsolutePath absolute path}, if not a\n     * {@link Path#toRealPath} real path.\n     * It will be used as the basis of {@code equals}, {@code hashCode}\n     * and {@code isSameFile} methods on this file object.\n     *\n     * A PathFileObject should also have a \"friendly name\" per the\n     * specification for {@link FileObject#getName}. The friendly name\n     * is provided by the various subtypes of {@code PathFileObject}.\n     *\n     * @param fileManager the file manager creating this file object\n     * @param path the path contained in this file object.\n     */\n    protected PathFileObject(BaseFileManager fileManager, Path path) {\n        this.fileManager = Objects.requireNonNull(fileManager);\n        if (Files.isDirectory(path)) {\n            throw new IllegalArgumentException(\"directories not supported\");\n        }\n        this.path = path;\n    }\n    /**\n     * See {@link JavacFileManager#inferBinaryName}.\n     */\n    abstract String inferBinaryName(Iterable<? extends Path> paths);\n    /**\n     * Return the file object for a sibling file with a given file name.\n     * See {@link JavacFileManager#getFileForOutput} and\n     * {@link JavacFileManager#getJavaFileForOutput}.\n     */\n    abstract PathFileObject getSibling(String basename);\n    /**\n     * Return the Path for this object.\n     * @return the Path for this object.\n     * @see StandardJavaFileManager#asPath\n     */\n    public Path getPath() {\n        return path;\n    }\n    /**\n     * The short name is used when generating raw diagnostics.\n     * @return the last component of the path\n     */\n    public String getShortName() {\n        return path.getFileName().toString();\n    }\n    @Override @DefinedBy(Api.COMPILER)\n    public Kind getKind() {\n        return BaseFileManager.getKind(path);\n    }\n    @Override @DefinedBy(Api.COMPILER)\n    public boolean isNameCompatible(String simpleName, Kind kind) {\n        return isPathNameCompatible(path, simpleName, kind);\n    }\n    protected boolean isPathNameCompatible(Path p, String simpleName, Kind kind) {\n        Objects.requireNonNull(simpleName);\n        Objects.requireNonNull(kind);\n        if (kind == Kind.OTHER && BaseFileManager.getKind(p) != kind) {\n            return false;\n        }\n        String sn = simpleName + kind.extension;\n        String pn = p.getFileName().toString();\n        if (pn.equals(sn)) {\n            return true;\n        }\n        if (p.getFileSystem() == defaultFileSystem) {\n            if (isMacOS) {\n                if (Normalizer.isNormalized(pn, Normalizer.Form.NFD)\n                        && Normalizer.isNormalized(sn, Normalizer.Form.NFC)) {\n                    // On Mac OS X it is quite possible to have the file name and the\n                    // given simple name normalized in different ways.\n                    // In that case we have to normalize file name to the\n                    // Normal Form Composed (NFC).\n                    String normName = Normalizer.normalize(pn, Normalizer.Form.NFC);\n                    if (normName.equals(sn)) {\n                        return true;\n                    }\n                }\n            }\n            if (pn.equalsIgnoreCase(sn)) {\n                try {\n                    // allow for Windows\n                    return p.toRealPath(LinkOption.NOFOLLOW_LINKS).getFileName().toString().equals(sn);\n                } catch (IOException e) {\n                }\n            }\n        }\n        return false;\n    }\n    @Override @DefinedBy(Api.COMPILER)\n    public NestingKind getNestingKind() {\n        return null;\n    }\n    @Override @DefinedBy(Api.COMPILER)\n    public Modifier getAccessLevel() {\n        return null;\n    }\n    @Override @DefinedBy(Api.COMPILER)\n    public URI toUri() {\n        return path.toUri();\n    }\n    @Override @DefinedBy(Api.COMPILER)\n    public InputStream openInputStream() throws IOException {\n        fileManager.updateLastUsedTime();\n        return Files.newInputStream(path);\n    }\n    @Override @DefinedBy(Api.COMPILER)\n    public OutputStream openOutputStream() throws IOException {\n        fileManager.updateLastUsedTime();\n        fileManager.flushCache(this);\n        ensureParentDirectoriesExist();\n        return Files.newOutputStream(path);\n    }\n    @Override @DefinedBy(Api.COMPILER)\n    public Reader openReader(boolean ignoreEncodingErrors) throws IOException {\n        CharsetDecoder decoder = fileManager.getDecoder(fileManager.getEncodingName(), ignoreEncodingErrors);\n        return new InputStreamReader(openInputStream(), decoder);\n    }\n<fim_suffix>    @Override @DefinedBy(Api.COMPILER)\n    public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n        CharBuffer cb = fileManager.getCachedContent(this);\n        if (cb == null) {\n            try (InputStream in = openInputStream()) {\n                ByteBuffer bb = fileManager.makeByteBuffer(in);\n                JavaFileObject prev = fileManager.log.useSource(this);\n                try {\n                    cb = fileManager.decode(bb, ignoreEncodingErrors);\n                } finally {\n                    fileManager.log.useSource(prev);\n                }\n                fileManager.recycleByteBuffer(bb);\n                if (!ignoreEncodingErrors) {\n                    fileManager.cache(this, cb);\n                }\n            }\n        }\n        return cb;\n    }<fim_middle>// function below has no smell\n"}