{"text": "<fim_prefix>/*\n   Copyright (c) 2018 LinkedIn Corp.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n\npackage com.linkedin.restli.client;\n\nimport com.linkedin.common.callback.Callback;\nimport com.linkedin.common.util.None;\nimport com.linkedin.r2.message.RequestContext;\nimport com.linkedin.r2.message.rest.RestResponse;\nimport com.linkedin.restli.client.multiplexer.MultiplexedRequest;\nimport com.linkedin.restli.client.multiplexer.MultiplexedResponse;\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\n\n\n/**\n * The purpose of this class is to be used when transitioning from RestClient to Client. It can be difficult to change\n * long-standing code that uses RestClient all over its API or is no longer maintained. Using the ForwardingRestClient\n * allows users to get the same benefits as using a Client for the majority of methods.\n *\n * If you are considering using this class, strongly consider using {@link Client} instead. This class is a shim for\n * RestClient compatibility and is not intended for any new development.\n *\n * Forwards all calls from RestClient to a Client delegate. A RestClient delegate is also provided for cases where\n * RestClient-only methods are called. If a RestClient-only method is called, but the RestClient was not supplied, an\n * {@link UnsupportedOperationException} will be thrown. In future versions, RestClient will be changing its public API\n * to the same as Client and the fallback RestClient constructor will be removed.\n *\n * @author Gil Cottle\n */\npublic class ForwardingRestClient extends RestClient implements Client {\n\n  private final Client _client;\n  private final RestClient _restClient;\n\n  /**\n   * @param client delegate for all Client calls\n   */\n  public ForwardingRestClient(@Nonnull Client client) {\n    this(client, null);\n  }\n\n  /**\n   * Using this constructor is deprecated, but provided for the use-cases where callers still depend on deprecated\n   * RestClient-only API methods.\n   *\n   * @param client Client to delegate all overlapping Client calls\n   * @param restClientFallback RestClient to use for RestClient-only methods. See class description for details.\n   * @deprecated this constructor will be removed in the future after changing the RestClient API to match that of\n   * Client. Use {@link #ForwardingRestClient(Client)} if possible.\n   */\n  @Deprecated\n  public ForwardingRestClient(@Nonnull Client client, @Nullable RestClient restClientFallback) {\n    super(null, null);\n    _client = client;\n    _restClient = restClientFallback;\n  }\n\n  // RestClient only method\n  @Deprecated\n  @Override\n  public String getURIPrefix() {\n    if (_restClient == null) {\n      throw new UnsupportedOperationException(\"getURIPrefix is not supported by the ForwardingRestClient\");\n    }\n    return _restClient.getURIPrefix();\n  }\n\n  // RestClient only method\n<fim_suffix>  @Deprecated\n  @Override\n  public <T> void sendRestRequest(final Request<T> request, RequestContext requestContext,\n      Callback<RestResponse> callback) {\n    if (_restClient == null) {\n      throw new UnsupportedOperationException(\"sendRestRequest is not supported by the ForwardingRestClient\");\n    }\n    _restClient.sendRestRequest(request, requestContext, callback);\n  }\n\n  @Override\n  public void shutdown(Callback<None> callback) {\n    _client.shutdown(callback);\n  }\n\n  @Override\n  public <T> ResponseFuture<T> sendRequest(Request<T> request, RequestContext requestContext) {\n    return _client.sendRequest(request, requestContext);\n  }\n\n  @Override\n  public <T> ResponseFuture<T> sendRequest(Request<T> request, RequestContext requestContext,\n      ErrorHandlingBehavior errorHandlingBehavior) {\n    return _client.sendRequest(request, requestContext, errorHandlingBehavior);\n  }\n\n  @Override\n  public <T> ResponseFuture<T> sendRequest(RequestBuilder<? extends Request<T>> requestBuilder,\n      RequestContext requestContext) {\n    return _client.sendRequest(requestBuilder, requestContext);\n  }\n\n  @Override\n  public <T> ResponseFuture<T> sendRequest(RequestBuilder<? extends Request<T>> requestBuilder,\n      RequestContext requestContext, ErrorHandlingBehavior errorHandlingBehavior) {\n    return _client.sendRequest(requestBuilder, requestContext, errorHandlingBehavior);\n  }\n\n  @Override\n  public <T> void sendRequest(final Request<T> request, final RequestContext requestContext,\n      final Callback<Response<T>> callback) {\n    _client.sendRequest(request, requestContext, callback);\n  }\n\n  @Override\n  public <T> void sendRequest(final RequestBuilder<? extends Request<T>> requestBuilder, RequestContext requestContext,\n      Callback<Response<T>> callback) {\n    _client.sendRequest(requestBuilder, requestContext, callback);\n  }\n\n  @Override\n  public <T> ResponseFuture<T> sendRequest(Request<T> request) {\n    return _client.sendRequest(request);\n  }\n\n  @Override\n  public <T> ResponseFuture<T> sendRequest(Request<T> request, ErrorHandlingBehavior errorHandlingBehavior) {\n    return _client.sendRequest(request, errorHandlingBehavior);\n  }\n\n  @Override\n  public <T> ResponseFuture<T> sendRequest(RequestBuilder<? extends Request<T>> requestBuilder) {\n    return _client.sendRequest(requestBuilder);\n  }\n\n  @Override\n  public <T> ResponseFuture<T> sendRequest(RequestBuilder<? extends Request<T>> requestBuilder,\n      ErrorHandlingBehavior errorHandlingBehavior) {\n    return _client.sendRequest(requestBuilder, errorHandlingBehavior);\n  }\n\n  @Override\n  public <T> void sendRequest(final Request<T> request, Callback<Response<T>> callback) {\n    _client.sendRequest(request, callback);\n  }\n\n  @Override\n  public <T> void sendRequest(final RequestBuilder<? extends Request<T>> requestBuilder,\n      Callback<Response<T>> callback) {\n    _client.sendRequest(requestBuilder, callback);\n  }\n\n  @Override\n  public void sendRequest(MultiplexedRequest multiplexedRequest) {\n    _client.sendRequest(multiplexedRequest);\n  }\n\n  @Override\n  public void sendRequest(MultiplexedRequest multiplexedRequest, Callback<MultiplexedResponse> callback) {\n    _client.sendRequest(multiplexedRequest, callback);\n  }\n\n  @Override\n  public void sendRequest(MultiplexedRequest multiplexedRequest, RequestContext requestContext,\n      Callback<MultiplexedResponse> callback) {\n    _client.sendRequest(multiplexedRequest, requestContext, callback);\n  }\n}<fim_middle>// function below has no smell\n"}