{"text": "<fim_prefix>                    // others\n                case '-' : case '.' : case '_' : case '~' :  \n                    // sub-delims\n                case '!' : case '$' : case '&' : case '\\'' : \n                case '(' : case ')' : case '*' : case '+' : case ',' : \n                case ';' : case '=' :\n                    pos++;\n                    break;\n                // pct-encoded\n                case '%':\n                    if ( Chars.isHex( chars, pos + 1 ) && Chars.isHex( chars, pos + 2 ) )\n                    {\n                        pos += 3;\n                    }\n                    else\n                    {\n                        return -1;\n                    }\n                    break;\n                default:\n                    // Wrong char\n                    return -1;\n            }\n        }\n        host = new String( chars, start, pos - start );\n        hostType = HostTypeEnum.REGULAR_NAME;\n        return pos;\n    }\n    /**\n     * Parse these rules :\n     * <pre>\n     * IPv4address = dec-octet \".\" dec-octet \".\" dec-octet \".\" dec-octet\n     * dec-octet   = DIGIT | [1-9] DIGIT | \"1\" 2DIGIT | \"2\" [0-4] DIGIT | \"25\" [0-5]\n     * </pre>\n     * \n     * @param chars The buffer to parse\n     * @param pos The current position in the byte buffer\n     * \n     * @return The new position or -1 if this is not an IPV4 address\n     */\n    private int parseIPV4( char[] chars, int pos )\n    {\n        int[] ipElem = new int[4];\n        int ipPos = pos;\n        int start = pos;\n        for ( int i = 0; i < 3; i++ )\n        {\n            ipPos = parseDecOctet( chars, ipPos, ipElem, i );\n            if ( ipPos == -1 )\n            {\n                // Not an IPV4 address\n                return -1;\n            }\n            if ( chars[ipPos] != '.' )\n            {\n                // Not an IPV4 address\n                return -1;\n            }\n            else\n            {\n                ipPos++;\n            }\n        }\n        ipPos = parseDecOctet( chars, ipPos, ipElem, 3 );\n        if ( ipPos == -1 )\n        {\n            // Not an IPV4 address\n            return -1;\n        }\n        else\n        {\n            pos = ipPos;\n            host = new String( chars, start, pos - start );\n            hostType = HostTypeEnum.IPV4;\n            return pos;\n        }\n    }\n    /**\n     * Parse this rule :\n     * <pre>\n     * dec-octet   = DIGIT | [1-9] DIGIT | \"1\" 2DIGIT | \"2\" [0-4] DIGIT | \"25\" [0-5]\n     * </pre>\n     * \n     * @param chars The chars to parse \n     * @param pos The position in the chars\n     * @param ipElem The IP elements to update\n     * @param octetNb The IP octet being processed\n     * @return The new position, or -1 if the IP octet is invalid\n     */\n    private int parseDecOctet( char[] chars, int pos, int[] ipElem, int octetNb )\n    {\n        int ipElemValue = 0;\n        boolean ipElemSeen = false;\n        boolean hasHeadingZeroes = false;\n        while ( Chars.isDigit( chars, pos ) )\n        {\n            ipElemSeen = true;\n            if ( chars[pos] == '0' )\n            {\n                if ( hasHeadingZeroes )\n                {\n                    // Two 0 at the beginning : not allowed\n                    return -1;\n                }\n                if ( ipElemValue > 0 )\n                {\n                    ipElemValue = ipElemValue * 10;\n                }\n                else\n                { \n                    hasHeadingZeroes = true;\n                }\n            }\n            else\n            {\n                hasHeadingZeroes = false;\n                ipElemValue = ( ipElemValue * 10 ) + ( chars[pos] - '0' );\n            }\n            if ( ipElemValue > 255 )\n            {\n                return -1;\n            }\n            pos++;\n        }\n        if ( ipElemSeen )\n        {\n            ipElem[octetNb] = ipElemValue;\n            return pos;\n        }\n        else\n        {\n            return -1;\n        }\n    }\n    /**\n     * Parse this rule : <br>\n     * <pre>\n     * &lt;port&gt; ::= &lt;digit&gt;+\n     * &lt;digit&gt; ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9\n     * </pre>\n     * The port must be between 0 and 65535.\n     *\n     * @param chars The buffer to parse\n     * @param pos The current position in the byte buffer\n     * @return The new position in the byte buffer, or -1 if the rule does not\n     *         apply to the byte buffer\n     */\n    private int parsePort( char[] chars, int pos )\n    {\n        if ( !Chars.isDigit( chars, pos ) )\n        {\n            return -1;\n        }\n        port = chars[pos] - '0';\n        pos++;\n        while ( Chars.isDigit( chars, pos ) )\n        {\n            port = ( port * 10 ) + ( chars[pos] - '0' );\n            if ( port > 65535 )\n            {\n                return -1;\n            }\n            pos++;\n        }\n        return pos;\n    }\n    /**\n     * Parse this rule : <br>\n     * <pre>\n     *   &lt;hostport&gt; ::= &lt;host&gt; [':' &lt;port&gt;]\n     * </pre>\n     *\n     * @param chars The char array to parse\n     * @param pos The current position in the byte buffer\n     * @return The new position in the byte buffer, or -1 if the rule does not\n     *         apply to the byte buffer\n     */\n    private int parseHostPort( char[] chars, int pos )\n    {\n        int hostPos = pos;\n        pos = parseHost( chars, pos );\n        if ( pos == -1 )\n        {\n            return -1;\n        }\n        // We may have a port.\n        if ( Chars.isCharASCII( chars, pos, ':' ) )\n        {\n            if ( pos == hostPos )\n            {\n                // We should not have a port if we have no host\n                return -1;\n            }\n            pos++;\n        }\n        else\n        {\n            return pos;\n        }\n        // As we have a ':', we must have a valid port (between 0 and 65535).\n        pos = parsePort( chars, pos );\n        if ( pos == -1 )\n        {\n            return -1;\n        }\n        return pos;\n    }\n    /**\n     * Converts the specified string to byte array of ASCII characters.\n     *\n     * @param data the string to be encoded\n     * @return The string as a byte array.\n     */\n    private static byte[] getAsciiBytes( final String data )\n    {\n        if ( data == null )\n        {\n            throw new IllegalArgumentException( I18n.err( I18n.ERR_17028_PARAMETER_CANT_BE_NULL ) );\n        }\n        return Strings.getBytesUtf8( data );\n    }\n    /**\n     * From commons-codec. Decodes an array of URL safe 7-bit characters into an\n     * array of original bytes. Escaped characters are converted back to their\n     * original representation.\n     *\n     * @param bytes array of URL safe characters\n     * @return array of original bytes\n     * @throws UrlDecoderException Thrown if URL decoding is unsuccessful\n     */\n<fim_suffix>    private static byte[] decodeUrl( byte[] bytes ) throws UrlDecoderException\n    {\n        if ( bytes == null )\n        {\n            return Strings.EMPTY_BYTES;\n        }\n        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n        for ( int i = 0; i < bytes.length; i++ )\n        {\n            int b = bytes[i];\n            if ( b == '%' )\n            {\n                try\n                {\n                    int u = Character.digit( ( char ) bytes[++i], 16 );\n                    int l = Character.digit( ( char ) bytes[++i], 16 );\n                    if ( ( u == -1 ) || ( l == -1 ) )\n                    {\n                        throw new UrlDecoderException( I18n.err( I18n.ERR_13040_INVALID_URL_ENCODING ) );\n                    }\n                    buffer.write( ( char ) ( ( u << 4 ) + l ) );\n                }\n                catch ( ArrayIndexOutOfBoundsException aioobe )\n                {\n                    throw new UrlDecoderException( I18n.err( I18n.ERR_13040_INVALID_URL_ENCODING ), aioobe );\n                }\n            }\n            else\n            {\n                buffer.write( b );\n            }\n        }\n        return buffer.toByteArray();\n    }<fim_middle>// function below is long method\n"}