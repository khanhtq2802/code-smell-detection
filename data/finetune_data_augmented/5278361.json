{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.webbeans.service;\n\nimport org.apache.webbeans.util.ClassUtil;\n\nimport java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.lang.reflect.Constructor;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Enumeration;\nimport java.util.List;\n\n/**\n * Manual service loader as fallback for Java 1.5\n */\n<fim_suffix>class ManualImplementationLoaderService<T>\n{\n    private static final String SERVICE_CONFIG = \"META-INF/services/\";\n    private static final String FILE_ENCODING = \"UTF-8\";\n\n    protected List<Class<?>> foundServiceClasses = new ArrayList<>();\n    private Class<T> serviceType;\n    private ClassLoader currentClassLoader;\n\n    ManualImplementationLoaderService(Class<T> serviceType, ClassLoader currentClassLoader)\n    {\n        this.serviceType = serviceType;\n        this.currentClassLoader = currentClassLoader;\n    }\n\n    List<T> loadServiceImplementations()\n    {\n        List<Class<?>> result = resolveServiceImplementations();\n\n        if (result == null)\n        {\n            return Collections.emptyList();\n        }\n\n        List<T> foundServices = new ArrayList<>();\n\n        for (Class<?> serviceClass : result)\n        {\n            foundServices.add(createInstance(serviceClass));\n        }\n\n        return foundServices;\n    }\n\n    private List<Class<?>> resolveServiceImplementations()\n    {\n        for (URL configFile : getConfigFileList())\n        {\n            loadConfiguredServices(configFile);\n        }\n\n        return foundServiceClasses;\n    }\n\n    private List<URL> getConfigFileList()\n    {\n        List<URL> serviceFiles = new ArrayList<>();\n\n        try\n        {\n            Enumeration<URL> serviceFileEnumerator = currentClassLoader.getResources(getConfigFileLocation());\n\n            while (serviceFileEnumerator.hasMoreElements())\n            {\n                serviceFiles.add(serviceFileEnumerator.nextElement());\n            }\n        }\n        catch (Exception e)\n        {\n            throw new IllegalStateException(\n                    \"Failed to load \" + serviceType.getName() + \" configured in \" + getConfigFileLocation(), e);\n        }\n        return serviceFiles;\n    }\n\n    private String getConfigFileLocation()\n    {\n        return SERVICE_CONFIG + serviceType.getName();\n    }\n\n    private void loadConfiguredServices(URL serviceFile)\n    {\n        InputStream inputStream = null;\n\n        try\n        {\n            String serviceClassName;\n            inputStream = serviceFile.openStream();\n            BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream, FILE_ENCODING));\n\n            while ((serviceClassName = bufferedReader.readLine()) != null)\n            {\n                serviceClassName = extractConfiguredServiceClassName(serviceClassName);\n                if (!\"\".equals(serviceClassName))\n                {\n                    loadService(serviceClassName);\n                }\n            }\n        }\n        catch (Exception e)\n        {\n            throw new IllegalStateException(\"Failed to process service-config: \" + serviceFile, e);\n        }\n        finally\n        {\n            if (inputStream != null)\n            {\n                try\n                {\n                    inputStream.close();\n                }\n                catch (Exception e)\n                {\n                    throw new IllegalStateException(\"Failed to close \" + serviceFile, e);\n                }\n            }\n        }\n    }\n\n    private String extractConfiguredServiceClassName(String currentConfigLine)\n    {\n        int startOfComment = currentConfigLine.indexOf('#');\n\n        if (startOfComment > -1)\n        {\n            currentConfigLine = currentConfigLine.substring(0, startOfComment);\n        }\n        return currentConfigLine.trim();\n    }\n\n    private void loadService(String serviceClassName)\n    {\n        Class<T> serviceClass = (Class<T>) loadClass(serviceClassName);\n\n        if (serviceClass != null && !foundServiceClasses.contains(serviceClass))\n        {\n            foundServiceClasses.add(serviceClass);\n        }\n        else if (serviceClass == null)\n        {\n            throw new IllegalStateException(serviceClassName + \" couldn't be loaded. \" +\n                    \"Please ensure that this class is in the classpath or remove the entry from \"\n                    + getConfigFileLocation() + \".\");\n        }\n    }\n\n    private Class<? extends T> loadClass(String serviceClassName)\n    {\n        Class<?> targetClass = ClassUtil.getClassFromName(serviceClassName);\n\n        if (targetClass == null)\n        {\n            targetClass = loadClassForName(serviceClassName, currentClassLoader);\n\n            if (targetClass == null)\n            {\n                return null;\n            }\n        }\n\n        return targetClass.asSubclass(serviceType);\n    }\n\n    private static Class<?> loadClassForName(String serviceClassName, ClassLoader classLoader)\n    {\n        if (classLoader == null)\n        {\n            return null;\n        }\n\n        try\n        {\n            return classLoader.loadClass(serviceClassName);\n        }\n        catch (Exception e)\n        {\n            return loadClassForName(serviceClassName, classLoader.getParent());\n        }\n    }\n\n    private T createInstance(Class<?> serviceClass)\n    {\n        try\n        {\n            Constructor<?> constructor = serviceClass.getDeclaredConstructor();\n            constructor.setAccessible(true);\n            return (T) constructor.newInstance();\n        }\n        catch (Exception e)\n        {\n            return null;\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public String toString()\n    {\n        return \"Config file: \" + getConfigFileLocation();\n    }\n}<fim_middle>// class below is blob\n"}