{"text": "<fim_prefix>                  // of a treeNodeBody.\n                  dispatchContextMenuEvent(\n                      mouseEvt.getClientX(), mouseEvt.getClientY(), treeNodeBody, css);\n                }\n              },\n              false);\n      getElement()\n          .addEventListener(\n              Event.FOCUS,\n              new EventListener() {\n                @Override\n                public void handleEvent(Event event) {\n                  if (getDelegate() != null) {\n                    getDelegate().onFocus(event);\n                  }\n                }\n              },\n              false);\n      getElement()\n          .addEventListener(\n              Event.BLUR,\n              new EventListener() {\n                @Override\n                public void handleEvent(Event event) {\n                  if (getDelegate() != null) {\n                    getDelegate().onBlur(event);\n                  }\n                }\n              },\n              false);\n    }\n    private void dispatchContextMenuEvent(int mouseX, int mouseY, Element treeNodeBody, Css css) {\n      // We assume the click happened on a TreeNodeBody. We walk up one level\n      // to grab the treeNode element.\n      @SuppressWarnings(\"unchecked\")\n      TreeNodeElement<D> treeNode = (TreeNodeElement<D>) treeNodeBody.getParentElement();\n      assert (CssUtils.containsClassName(treeNode, css.treeNode()))\n          : \"Parent of an expandControl wasn't a TreeNode!\";\n      getDelegate().onNodeContextMenu(mouseX, mouseY, treeNode);\n    }\n    private void dispatchExpansionEvent(TreeNodeElement<D> treeNode, Css css) {\n      // Is the node opened or closed?\n      if (treeNode.isOpen()) {\n        getDelegate().onNodeClosed(treeNode);\n      } else {\n        // We might have set the CSS to say it is closed, but the animation\n        // takes a little while. As such, we check to make sure the children\n        // container is set to display:none before trying to dispatch an open.\n        // Otherwise we can get into an inconsistent state if we click really\n        // fast.\n        Element childrenContainer = treeNode.getChildrenContainer();\n        if (childrenContainer != null /*&& !CssUtils.isVisible(childrenContainer)*/) {\n          getDelegate().onNodeExpanded(treeNode);\n        }\n      }\n    }\n    private void dispatchNodeActionEvent(Element treeNodeBody, Css css) {\n      getDelegate().onNodeAction(getTreeNodeFromTreeNodeBody(treeNodeBody, css));\n    }\n    private void dispatchNodeSelectedEvent(Element treeNodeBody, SignalEvent evt, Css css) {\n      getDelegate().onNodeSelected(getTreeNodeFromTreeNodeBody(treeNodeBody, css), evt);\n    }\n    private void dispatchOnRootContextMenuEvent(int mouseX, int mouseY) {\n      getDelegate().onRootContextMenu(mouseX, mouseY);\n    }\n    private TreeNodeElement<D> getTreeNodeFromTreeNodeBody(Element treeNodeBody, Css css) {\n      TreeNodeElement<D> treeNode =\n          ((JsElement) treeNodeBody.getParentElement()).<TreeNodeElement<D>>cast();\n      assert (CssUtils.containsClassName(treeNode, css.treeNode()))\n          : \"Unexpected element when looking for tree node: \" + treeNode.toString();\n      return treeNode;\n    }\n  }\n  /**\n   * Logical events sourced by the Tree's View. Note that these events get dispatched synchronously\n   * in our DOM event handlers.\n   */\n  private interface ViewEvents<D> {\n    void onNodeAction(TreeNodeElement<D> node);\n    void onNodeClosed(TreeNodeElement<D> node);\n    void onNodeContextMenu(int mouseX, int mouseY, TreeNodeElement<D> node);\n    void onDragDropEvent(MouseEvent event);\n    void onNodeExpanded(TreeNodeElement<D> node);\n    void onNodeSelected(TreeNodeElement<D> node, SignalEvent event);\n    void onRootContextMenu(int mouseX, int mouseY);\n    void onRootDragDrop(MouseEvent event);\n    void onKeyBoard(KeyboardEvent event);\n    void onFocus(Event event);\n    void onBlur(Event event);\n  }\n  private class DragDropController {\n    private TreeNodeElement<D> targetNode;\n    private boolean hadDragEnterEvent;\n    private final ScheduledCommand hadDragEnterEventResetter =\n        new ScheduledCommand() {\n          @Override\n          public void execute() {\n            hadDragEnterEvent = false;\n          }\n        };\n    private final Timer hoverToExpandTimer =\n        new Timer() {\n          @Override\n          public void run() {\n            expandNode(targetNode, true, true);\n          }\n        };\n    void handleDragDropEvent(MouseEvent evt) {\n      final D rootData = getModel().root;\n      final NodeDataAdapter<D> dataAdapter = getModel().getDataAdapter();\n      final Css css = getModel().resources.treeCss();\n      @SuppressWarnings(\"unchecked\")\n      TreeNodeElement<D> node =\n          (TreeNodeElement<D>)\n              CssUtils.getAncestorOrSelfWithClassName((Element) evt.getTarget(), css.treeNode());\n      D newTargetData = node != null ? dataAdapter.getDragDropTarget(node.getData()) : rootData;\n      if (newTargetData == null) {\n        return;\n      }\n      TreeNodeElement<D> newTargetNode = dataAdapter.getRenderedTreeNode(newTargetData);\n      String type = evt.getType();\n      if (Event.DRAGSTART.equals(type)) {\n        if (getModel().externalEventDelegate != null) {\n          D sourceData = node != null ? node.getData() : rootData;\n          // TODO support multiple folder selection.\n          // We do not support dragging without any folder/file selection.\n          if (sourceData != rootData) {\n            TreeNodeElement<D> sourceNode = dataAdapter.getRenderedTreeNode(sourceData);\n            getModel().externalEventDelegate.onNodeDragStart(sourceNode, evt);\n          }\n        }\n        return;\n      }\n      if (Event.DROP.equals(type)) {\n        if (getModel().externalEventDelegate != null) {\n          if (newTargetData == rootData) {\n            getModel().externalEventDelegate.onRootDragDrop(evt);\n          } else {\n            getModel().externalEventDelegate.onNodeDragDrop(newTargetNode, evt);\n          }\n        }\n        clearDropTarget();\n      } else if (Event.DRAGOVER.equals(type)) {\n        if (newTargetNode != targetNode) {\n          clearDropTarget();\n          if (newTargetNode != null) {\n            // Highlight the node by setting its drop target property\n            targetNode = newTargetNode;\n            targetNode.setIsDropTarget(true, css);\n            if (dataAdapter.hasChildren(newTargetData) && !targetNode.isOpen()) {\n              hoverToExpandTimer.schedule(HOVER_TO_EXPAND_DELAY_MS);\n            }\n          }\n        }\n      } else if (Event.DRAGLEAVE.equals(type)) {\n        if (!hadDragEnterEvent) {\n          // This wasn't part of a DRAGENTER-DRAGLEAVE pair (see below)\n          clearDropTarget();\n        }\n      } else if (Event.DRAGENTER.equals(type)) {\n        /*\n         * DRAGENTER comes before DRAGLEAVE, and a deferred command scheduled\n         * here will execute after the DRAGLEAVE. We use hadDragEnter to track a\n         * paired DRAGENTER-DRAGLEAVE so that we can cleanup when we get an\n         * unpaired DRAGLEAVE.\n         */\n        hadDragEnterEvent = true;\n        Scheduler.get().scheduleDeferred(hadDragEnterEventResetter);\n      }\n      evt.preventDefault();\n      evt.stopPropagation();\n    }\n    private void clearDropTarget() {\n      hoverToExpandTimer.cancel();\n      if (targetNode != null) {\n        targetNode.setIsDropTarget(false, getModel().resources.treeCss());\n        targetNode = null;\n      }\n    }\n  }\n  private final DragDropController dragDropController = new DragDropController();\n  private HTML widget;\n  /** Handles logical events sourced by the View. */\n  private final ViewEvents<D> viewEventHandler =\n      new ViewEvents<D>() {\n        @Override\n        public void onNodeAction(final TreeNodeElement<D> node) {\n          selectSingleNode(node, true);\n        }\n        @Override\n        public void onNodeClosed(TreeNodeElement<D> node) {\n          closeNode(node, true);\n        }\n        @Override\n        public void onNodeContextMenu(int mouseX, int mouseY, TreeNodeElement<D> node) {\n          // Select the node the first\n          getModel().selectionModel.contextSelect(node.getData());\n          // Display context menu\n          if (getModel().externalEventDelegate != null) {\n            getModel().externalEventDelegate.onNodeContextMenu(mouseX, mouseY, node);\n          }\n        }\n        @Override\n        public void onDragDropEvent(MouseEvent event) {\n          dragDropController.handleDragDropEvent(event);\n        }\n        @Override\n        public void onNodeExpanded(TreeNodeElement<D> node) {\n          expandNode(node, true, true);\n        }\n<fim_suffix>        @Override\n        public void onNodeSelected(TreeNodeElement<D> node, SignalEvent event) {\n          getSelectionModel().setTreeActive(true);\n          selectNode(node.getData(), event, true);\n        }<fim_middle>// function below has no smell\n"}