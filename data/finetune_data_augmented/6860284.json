{"text": "<fim_prefix>/*\n * Copyright 2014 The Error Prone Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n * in compliance with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage com.google.errorprone.refaster;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.google.auto.value.AutoValue;\nimport com.google.common.base.Functions;\nimport com.google.common.base.MoreObjects;\nimport com.google.common.base.Optional;\nimport com.google.common.collect.Collections2;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableSet;\nimport com.sun.source.tree.IdentifierTree;\nimport com.sun.source.tree.Tree;\nimport com.sun.source.tree.TreeVisitor;\nimport com.sun.tools.javac.tree.JCTree;\nimport com.sun.tools.javac.tree.JCTree.JCExpression;\nimport com.sun.tools.javac.tree.JCTree.JCIdent;\nimport com.sun.tools.javac.tree.TreeCopier;\nimport com.sun.tools.javac.tree.TreeMaker;\nimport com.sun.tools.javac.util.Context;\nimport com.sun.tools.javac.util.List;\nimport com.sun.tools.javac.util.Names;\nimport java.util.Map;\n\n/**\n * {@code UTree} representation of an invocation of a placeholder method.\n *\n * @author lowasser@google.com (Louis Wasserman)\n */\n<fim_suffix>@AutoValue\npublic abstract class UPlaceholderExpression extends UExpression {\n\n  static UPlaceholderExpression create(\n      PlaceholderMethod placeholder, Iterable<? extends UExpression> arguments) {\n    ImmutableList<UVariableDecl> placeholderParams = placeholder.parameters().asList();\n    ImmutableList<UExpression> argumentsList = ImmutableList.copyOf(arguments);\n    ImmutableMap.Builder<UVariableDecl, UExpression> builder = ImmutableMap.builder();\n    for (int i = 0; i < placeholderParams.size(); i++) {\n      builder.put(placeholderParams.get(i), argumentsList.get(i));\n    }\n    return new AutoValue_UPlaceholderExpression(placeholder, builder.build());\n  }\n\n  abstract PlaceholderMethod placeholder();\n\n  abstract ImmutableMap<UVariableDecl, UExpression> arguments();\n\n  public static final class PlaceholderParamIdent extends JCIdent {\n    final UVariableDecl param;\n\n    PlaceholderParamIdent(UVariableDecl param, Context context) {\n      super(Names.instance(context).fromString(param.getName().contents()), null);\n      this.param = checkNotNull(param);\n    }\n  }\n\n  static class UncheckedCouldNotResolveImportException extends RuntimeException {\n    UncheckedCouldNotResolveImportException(CouldNotResolveImportException e) {\n      super(e);\n    }\n\n    @Override\n    public synchronized CouldNotResolveImportException getCause() {\n      return (CouldNotResolveImportException) super.getCause();\n    }\n  }\n\n  static TreeCopier<Inliner> copier(\n      final Map<UVariableDecl, UExpression> arguments, Inliner inliner) {\n    return new TreeCopier<Inliner>(inliner.maker()) {\n      @Override\n      public <T extends JCTree> T copy(T tree, Inliner inliner) {\n        if (tree == null) {\n          return null;\n        }\n        T result = super.copy(tree, inliner);\n        if (result.toString().equals(tree.toString())) {\n          return tree;\n        } else {\n          return result;\n        }\n      }\n\n      @Override\n      public JCTree visitIdentifier(IdentifierTree node, Inliner inliner) {\n        if (node instanceof PlaceholderParamIdent) {\n          try {\n            return arguments.get(((PlaceholderParamIdent) node).param).inline(inliner);\n          } catch (CouldNotResolveImportException e) {\n            throw new UncheckedCouldNotResolveImportException(e);\n          }\n        } else {\n          return super.visitIdentifier(node, inliner);\n        }\n      }\n    };\n  }\n\n  @Override\n  public JCExpression inline(Inliner inliner) throws CouldNotResolveImportException {\n    /*\n     * Copy the original source bound to the placeholder, except anywhere we matched a placeholder\n     * parameter, replace that with the corresponding expression in this invocation.\n     */\n    try {\n      return copier(arguments(), inliner)\n          .copy(inliner.getBinding(placeholder().exprKey()), inliner);\n    } catch (UncheckedCouldNotResolveImportException e) {\n      throw e.getCause();\n    }\n  }\n\n  @Override\n  public Kind getKind() {\n    return Kind.OTHER;\n  }\n\n  @Override\n  public <R, D> R accept(TreeVisitor<R, D> visitor, D data) {\n    return visitor.visitOther(this, data);\n  }\n\n  public boolean reverify(Unifier unifier) {\n    return MoreObjects.firstNonNull(\n        new PlaceholderVerificationVisitor(\n                Collections2.transform(\n                    placeholder().requiredParameters(), Functions.forMap(arguments())),\n                arguments().values())\n            .scan(unifier.getBinding(placeholder().exprKey()), unifier),\n        true);\n  }\n\n  @Override\n  protected Choice<Unifier> defaultAction(Tree node, Unifier unifier) {\n    // for now we only match JCExpressions\n    if (placeholder().returnType().equals(UPrimitiveType.VOID) || !(node instanceof JCExpression)) {\n      return Choice.none();\n    }\n    final JCExpression expr = (JCExpression) node;\n\n    PlaceholderVerificationVisitor verification =\n        new PlaceholderVerificationVisitor(\n            Collections2.transform(\n                placeholder().requiredParameters(), Functions.forMap(arguments())),\n            arguments().values());\n    if (!verification.scan(node, unifier) || !verification.allRequiredMatched()) {\n      return Choice.none();\n    }\n\n    /*\n     * We copy the tree with a TreeCopier, replacing matches for the parameters with\n     * PlaceholderParamIdents, and updating unifierHolder as we unify things, including forbidding\n     * references to local variables, etc.\n     */\n    Choice<? extends PlaceholderUnificationVisitor.State<? extends JCExpression>> states =\n        PlaceholderUnificationVisitor.create(TreeMaker.instance(unifier.getContext()), arguments())\n            .unifyExpression(\n                expr,\n                PlaceholderUnificationVisitor.State.create(\n                    List.<UVariableDecl>nil(), unifier, null));\n    return states.thenOption(\n        (PlaceholderUnificationVisitor.State<? extends JCExpression> state) -> {\n          if (ImmutableSet.copyOf(state.seenParameters())\n              .containsAll(placeholder().requiredParameters())) {\n            Unifier resultUnifier = state.unifier();\n            JCExpression prevBinding = resultUnifier.getBinding(placeholder().exprKey());\n            if (prevBinding != null) {\n              return prevBinding.toString().equals(state.result().toString())\n                  ? Optional.of(resultUnifier)\n                  : Optional.<Unifier>absent();\n            }\n            JCExpression result = state.result();\n            if (!placeholder()\n                .matcher()\n                .matches(result, UMatches.makeVisitorState(expr, resultUnifier))) {\n              return Optional.absent();\n            }\n            result.type = expr.type;\n            resultUnifier.putBinding(placeholder().exprKey(), result);\n            return Optional.of(resultUnifier);\n          } else {\n            return Optional.absent();\n          }\n        });\n  }\n}<fim_middle>// class below has no smell\n"}