{"text": "<fim_prefix>/*\n * Copyright 1999-2012 Alibaba Group.\n *  \n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *  \n *      http://www.apache.org/licenses/LICENSE-2.0\n *  \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.alibaba.cobar.net;\n\nimport java.io.IOException;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.Selector;\nimport java.util.Set;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingQueue;\n\nimport org.apache.log4j.Logger;\n\nimport com.alibaba.cobar.config.ErrorCode;\n\n/**\n * \u7f51\u7edc\u4e8b\u4ef6\u53cd\u5e94\u5668\n * \n * @author xianmao.hexm\n */\npublic final class NIOReactor {\n    private static final Logger LOGGER = Logger.getLogger(NIOReactor.class);\n\n    private final String name;\n    private final R reactorR;\n    private final W reactorW;\n\n    public NIOReactor(String name) throws IOException {\n        this.name = name;\n        this.reactorR = new R();\n        this.reactorW = new W();\n    }\n\n    final void startup() {\n        new Thread(reactorR, name + \"-R\").start();\n        new Thread(reactorW, name + \"-W\").start();\n    }\n\n    final void postRegister(NIOConnection c) {\n        reactorR.registerQueue.offer(c);\n        reactorR.selector.wakeup();\n    }\n\n    final BlockingQueue<NIOConnection> getRegisterQueue() {\n        return reactorR.registerQueue;\n    }\n\n    final long getReactCount() {\n        return reactorR.reactCount;\n    }\n\n    final void postWrite(NIOConnection c) {\n        reactorW.writeQueue.offer(c);\n    }\n\n    final BlockingQueue<NIOConnection> getWriteQueue() {\n        return reactorW.writeQueue;\n    }\n\n    private final class R implements Runnable {\n        private final Selector selector;\n        private final BlockingQueue<NIOConnection> registerQueue;\n        private long reactCount;\n\n        private R() throws IOException {\n            this.selector = Selector.open();\n            this.registerQueue = new LinkedBlockingQueue<NIOConnection>();\n        }\n\n        @Override\n        public void run() {\n            final Selector selector = this.selector;\n            for (;;) {\n                ++reactCount;\n                try {\n                    selector.select(1000L);\n                    register(selector);\n                    Set<SelectionKey> keys = selector.selectedKeys();\n                    try {\n                        for (SelectionKey key : keys) {\n                            Object att = key.attachment();\n                            if (att != null && key.isValid()) {\n                                int readyOps = key.readyOps();\n                                if ((readyOps & SelectionKey.OP_READ) != 0) {\n                                    read((NIOConnection) att);\n                                } else if ((readyOps & SelectionKey.OP_WRITE) != 0) {\n                                    write((NIOConnection) att);\n                                } else {\n                                    key.cancel();\n                                }\n                            } else {\n                                key.cancel();\n                            }\n                        }\n                    } finally {\n                        keys.clear();\n                    }\n                } catch (Throwable e) {\n                    LOGGER.warn(name, e);\n                }\n            }\n        }\n\n        private void register(Selector selector) {\n            NIOConnection c = null;\n            while ((c = registerQueue.poll()) != null) {\n                try {\n                    c.register(selector);\n                } catch (Throwable e) {\n                    c.error(ErrorCode.ERR_REGISTER, e);\n                }\n            }\n        }\n\n        private void read(NIOConnection c) {\n            try {\n                c.read();\n            } catch (Throwable e) {\n                c.error(ErrorCode.ERR_READ, e);\n            }\n        }\n\n        private void write(NIOConnection c) {\n            try {\n                c.writeByEvent();\n            } catch (Throwable e) {\n                c.error(ErrorCode.ERR_WRITE_BY_EVENT, e);\n            }\n        }\n    }\n\n    private final class W implements Runnable {\n        private final BlockingQueue<NIOConnection> writeQueue;\n\n        private W() {\n            this.writeQueue = new LinkedBlockingQueue<NIOConnection>();\n        }\n\n        @Override\n        public void run() {\n            NIOConnection c = null;\n            for (;;) {\n                try {\n                    if ((c = writeQueue.take()) != null) {\n                        write(c);\n                    }\n                } catch (Throwable e) {\n                    LOGGER.warn(name, e);\n                }\n            }\n        }\n\n<fim_suffix>        private void write(NIOConnection c) {\n            try {\n                c.writeByQueue();\n            } catch (Throwable e) {\n                c.error(ErrorCode.ERR_WRITE_BY_QUEUE, e);\n            }\n        }\n    }\n\n}<fim_middle>// function below has no smell\n"}