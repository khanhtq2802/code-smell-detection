{"text": "<fim_prefix> * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n /* This file copied from Hadoop's security branch,\n  * with the following changes:\n  * 1. package changed from org.apache.hadoop.security to\n  *    org.apache.zookeeper.server.auth.\n  * 2. Usage of Hadoop's Configuration class removed since\n  *    it is not available in Zookeeper: instead, system property\n  *    \"zookeeper.security.auth_to_local\" is used.\n  */\npackage org.apache.zookeeper.server.auth;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport org.apache.zookeeper.server.util.KerberosUtil;\n/**\n * This class implements parsing and handling of Kerberos principal names. In \n * particular, it splits them apart and translates them down into local\n * operating system names.\n */\npublic class KerberosName {\n  /** The first component of the name */\n  private final String serviceName;\n  /** The second component of the name. It may be null. */\n  private final String hostName;\n  /** The realm of the name. */\n  private final String realm;\n  /**\n   * A pattern that matches a Kerberos name with at most 2 components.\n   */\n  private static final Pattern nameParser = \n    Pattern.compile(\"([^/@]*)(/([^/@]*))?@([^/@]*)\");\n  /** \n   * A pattern that matches a string with out '$' and then a single\n   * parameter with $n.\n   */\n  private static Pattern parameterPattern = \n    Pattern.compile(\"([^$]*)(\\\\$(\\\\d*))?\");\n  /**\n   * A pattern for parsing a auth_to_local rule.\n   */\n  private static final Pattern ruleParser =\n    Pattern.compile(\"\\\\s*((DEFAULT)|(RULE:\\\\[(\\\\d*):([^\\\\]]*)](\\\\(([^)]*)\\\\))?\"+\n                    \"(s/([^/]*)/([^/]*)/(g)?)?))\");\n  /**\n   * A pattern that recognizes simple/non-simple names.\n   */\n  private static final Pattern nonSimplePattern = Pattern.compile(\"[/@]\");\n  /**\n   * The list of translation rules.\n   */\n  private static List<Rule> rules;\n  private static String defaultRealm;\n  static {\n    try {\n      defaultRealm = KerberosUtil.getDefaultRealm();\n    } catch (Exception ke) {\n      if ((System.getProperty(\"zookeeper.requireKerberosConfig\") != null) &&\n          (System.getProperty(\"zookeeper.requireKerberosConfig\").equals(\"true\"))) {\n        throw new IllegalArgumentException(\"Can't get Kerberos configuration\",ke);\n      }\n      else\n        defaultRealm=\"\";\n    }\n    try {\n      // setConfiguration() will work even if the above try() fails due\n      // to a missing Kerberos configuration (unless zookeeper.requireKerberosConfig\n      // is set to true, which would not allow execution to reach here due to the\n      // throwing of an IllegalArgumentException above).\n      setConfiguration();\n    }\n    catch (IOException e) {\n      throw new IllegalArgumentException(\"Could not configure Kerberos principal name mapping.\");\n    }\n  }\n  /**\n   * Create a name from the full Kerberos principal name.\n   * @param name\n   */\n  public KerberosName(String name) {\n    Matcher match = nameParser.matcher(name);\n    if (!match.matches()) {\n      if (name.contains(\"@\")) {\n        throw new IllegalArgumentException(\"Malformed Kerberos name: \" + name);\n      } else {\n        serviceName = name;\n        hostName = null;\n        realm = null;\n      }\n    } else {\n      serviceName = match.group(1);\n      hostName = match.group(3);\n      realm = match.group(4);\n    }\n  }\n  /**\n   * Get the configured default realm.\n   * @return the default realm from the krb5.conf\n   */\n  public String getDefaultRealm() {\n    return defaultRealm;\n  }\n  /**\n   * Put the name back together from the parts.\n   */\n  @Override\n  public String toString() {\n    StringBuilder result = new StringBuilder();\n    result.append(serviceName);\n    if (hostName != null) {\n      result.append('/');\n      result.append(hostName);\n    }\n    if (realm != null) {\n      result.append('@');\n      result.append(realm);\n    }\n    return result.toString();\n  }\n  /**\n   * Get the first component of the name.\n   * @return the first section of the Kerberos principal name\n   */\n  public String getServiceName() {\n    return serviceName;\n  }\n  /**\n   * Get the second component of the name.\n   * @return the second section of the Kerberos principal name, and may be null\n   */\n  public String getHostName() {\n    return hostName;\n  }\n  /**\n   * Get the realm of the name.\n   * @return the realm of the name, may be null\n   */\n  public String getRealm() {\n    return realm;\n  }\n  /**\n   * An encoding of a rule for translating kerberos names.\n   */\n  private static class Rule {\n    private final boolean isDefault;\n    private final int numOfComponents;\n    private final String format;\n    private final Pattern match;\n    private final Pattern fromPattern;\n    private final String toPattern;\n    private final boolean repeat;\n    Rule() {\n      isDefault = true;\n      numOfComponents = 0;\n      format = null;\n      match = null;\n      fromPattern = null;\n      toPattern = null;\n      repeat = false;\n    }\n    Rule(int numOfComponents, String format, String match, String fromPattern,\n         String toPattern, boolean repeat) {\n      isDefault = false;\n      this.numOfComponents = numOfComponents;\n      this.format = format;\n      this.match = match == null ? null : Pattern.compile(match);\n      this.fromPattern = \n        fromPattern == null ? null : Pattern.compile(fromPattern);\n      this.toPattern = toPattern;\n      this.repeat = repeat;\n    }\n    @Override\n    public String toString() {\n      StringBuilder buf = new StringBuilder();\n      if (isDefault) {\n        buf.append(\"DEFAULT\");\n      } else {\n        buf.append(\"RULE:[\");\n        buf.append(numOfComponents);\n        buf.append(':');\n        buf.append(format);\n        buf.append(']');\n        if (match != null) {\n          buf.append('(');\n          buf.append(match);\n          buf.append(')');\n        }\n        if (fromPattern != null) {\n          buf.append(\"s/\");\n          buf.append(fromPattern);\n          buf.append('/');\n          buf.append(toPattern);\n          buf.append('/');\n          if (repeat) {\n            buf.append('g');\n          }\n        }\n      }\n      return buf.toString();\n    }\n    /**\n     * Replace the numbered parameters of the form $n where n is from 1 to \n     * the length of params. Normal text is copied directly and $n is replaced\n     * by the corresponding parameter.\n     * @param format the string to replace parameters again\n     * @param params the list of parameters\n     * @return the generated string with the parameter references replaced.\n     * @throws BadFormatString\n     */\n    static String replaceParameters(String format, \n                                    String[] params) throws BadFormatString {\n      Matcher match = parameterPattern.matcher(format);\n      int start = 0;\n      StringBuilder result = new StringBuilder();\n      while (start < format.length() && match.find(start)) {\n        result.append(match.group(1));\n        String paramNum = match.group(3);\n        if (paramNum != null) {\n          try {\n            int num = Integer.parseInt(paramNum);\n            if (num < 0 || num > params.length) {\n              throw new BadFormatString(\"index \" + num + \" from \" + format +\n                                        \" is outside of the valid range 0 to \" +\n                                        (params.length - 1));\n            }\n            result.append(params[num]);\n          } catch (NumberFormatException nfe) {\n            throw new BadFormatString(\"bad format in username mapping in \" + \n                                      paramNum, nfe);\n          }\n        }\n        start = match.end();\n      }\n      return result.toString();\n    }\n    /**\n     * Replace the matches of the from pattern in the base string with the value\n     * of the to string.\n     * @param base the string to transform\n     * @param from the pattern to look for in the base string\n     * @param to the string to replace matches of the pattern with\n     * @param repeat whether the substitution should be repeated\n     * @return\n     */\n<fim_suffix>    static String replaceSubstitution(String base, Pattern from, String to, \n                                      boolean repeat) {\n      Matcher match = from.matcher(base);\n      if (repeat) {\n        return match.replaceAll(to);\n      } else {\n        return match.replaceFirst(to);\n      }\n    }<fim_middle>// function below is feature envy\n"}