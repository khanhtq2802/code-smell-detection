{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.hadoop.hdfs.tools;\nimport java.io.IOException;\nimport java.util.LinkedList;\nimport java.util.List;\nimport org.apache.hadoop.classification.InterfaceAudience;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.conf.Configured;\nimport org.apache.hadoop.fs.FileSystem;\nimport org.apache.hadoop.fs.Path;\nimport org.apache.hadoop.fs.RemoteIterator;\nimport org.apache.hadoop.hdfs.DistributedFileSystem;\nimport org.apache.hadoop.hdfs.protocol.EncryptionZone;\nimport org.apache.hadoop.tools.TableListing;\nimport org.apache.hadoop.util.StringUtils;\nimport org.apache.hadoop.util.Tool;\n/**\n * This class implements crypto command-line operations.\n */\n@InterfaceAudience.Private\npublic class CryptoAdmin extends Configured implements Tool {\n  /**\n   * Maximum length for printed lines\n   */\n  private static final int MAX_LINE_WIDTH = 80;\n  public CryptoAdmin() {\n    this(null);\n  }\n  public CryptoAdmin(Configuration conf) {\n    super(conf);\n  }\n<fim_suffix>  @Override\n  public int run(String[] args) throws IOException {\n    if (args.length == 0) {\n      printUsage(false);\n      return 1;\n    }\n    final Command command = determineCommand(args[0]);\n    if (command == null) {\n      System.err.println(\"Can't understand command '\" + args[0] + \"'\");\n      if (!args[0].startsWith(\"-\")) {\n        System.err.println(\"Command names must start with dashes.\");\n      }\n      printUsage(false);\n      return 1;\n    }\n    final List<String> argsList = new LinkedList<String>();\n    for (int j = 1; j < args.length; j++) {\n      argsList.add(args[j]);\n    }\n    try {\n      return command.run(getConf(), argsList);\n    } catch (IllegalArgumentException e) {\n      System.err.println(prettifyException(e));\n      return -1;\n    }\n  }\n  public static void main(String[] argsArray) throws IOException {\n    final CryptoAdmin cryptoAdmin = new CryptoAdmin(new Configuration());\n    System.exit(cryptoAdmin.run(argsArray));\n  }\n  private static DistributedFileSystem getDFS(Configuration conf)\n      throws IOException {\n    final FileSystem fs = FileSystem.get(conf);\n    if (!(fs instanceof DistributedFileSystem)) {\n      throw new IllegalArgumentException(\"FileSystem \" + fs.getUri() +\n      \" is not an HDFS file system\");\n    }\n    return (DistributedFileSystem) fs;\n  }\n  /**\n   * NN exceptions contain the stack trace as part of the exception message.\n   * When it's a known error, pretty-print the error and squish the stack trace.\n   */\n  private static String prettifyException(Exception e) {\n    return e.getClass().getSimpleName() + \": \" +\n      e.getLocalizedMessage().split(\"\\n\")[0];\n  }\n  private static TableListing getOptionDescriptionListing() {\n    final TableListing listing = new TableListing.Builder()\n      .addField(\"\").addField(\"\", true)\n      .wrapWidth(MAX_LINE_WIDTH).hideHeaders().build();\n    return listing;\n  }\n  interface Command {\n    String getName();\n    String getShortUsage();\n    String getLongUsage();\n    int run(Configuration conf, List<String> args) throws IOException;\n  }\n  private static class CreateZoneCommand implements Command {\n    @Override\n    public String getName() {\n      return \"-createZone\";\n    }\n    @Override\n    public String getShortUsage() {\n      return \"[\" + getName() + \" -keyName <keyName> -path <path>]\\n\";\n    }\n    @Override\n    public String getLongUsage() {\n      final TableListing listing = getOptionDescriptionListing();\n      listing.addRow(\"<path>\", \"The path of the encryption zone to create. \" +\n        \"It must be an empty directory.\");\n      listing.addRow(\"<keyName>\", \"Name of the key to use for the \" +\n          \"encryption zone.\");\n      return getShortUsage() + \"\\n\" +\n        \"Create a new encryption zone.\\n\\n\" +\n        listing.toString();\n    }\n    @Override\n    public int run(Configuration conf, List<String> args) throws IOException {\n      final String path = StringUtils.popOptionWithArgument(\"-path\", args);\n      if (path == null) {\n        System.err.println(\"You must specify a path with -path.\");\n        return 1;\n      }\n      final String keyName =\n          StringUtils.popOptionWithArgument(\"-keyName\", args);\n      if (keyName == null) {\n        System.err.println(\"You must specify a key name with -keyName.\");\n        return 1;\n      }\n      if (!args.isEmpty()) {\n        System.err.println(\"Can't understand argument: \" + args.get(0));\n        return 1;\n      }\n      final DistributedFileSystem dfs = getDFS(conf);\n      try {\n        dfs.createEncryptionZone(new Path(path), keyName);\n        System.out.println(\"Added encryption zone \" + path);\n      } catch (IOException e) {\n        System.err.println(prettifyException(e));\n        return 2;\n      }\n      return 0;\n    }\n  }\n  private static class ListZonesCommand implements Command {\n    @Override\n    public String getName() {\n      return \"-listZones\";\n    }\n    @Override\n    public String getShortUsage() {\n      return \"[\" + getName()+ \"]\\n\";\n    }\n    @Override\n    public String getLongUsage() {\n      return getShortUsage() + \"\\n\" +\n        \"List all encryption zones. Requires superuser permissions.\\n\\n\";\n    }\n    @Override\n    public int run(Configuration conf, List<String> args) throws IOException {\n      if (!args.isEmpty()) {\n        System.err.println(\"Can't understand argument: \" + args.get(0));\n        return 1;\n      }\n      final DistributedFileSystem dfs = getDFS(conf);\n      try {\n        final TableListing listing = new TableListing.Builder()\n          .addField(\"\").addField(\"\", true)\n          .wrapWidth(MAX_LINE_WIDTH).hideHeaders().build();\n        final RemoteIterator<EncryptionZone> it = dfs.listEncryptionZones();\n        while (it.hasNext()) {\n          EncryptionZone ez = it.next();\n          listing.addRow(ez.getPath(), ez.getKeyName());\n        }\n        System.out.println(listing.toString());\n      } catch (IOException e) {\n        System.err.println(prettifyException(e));\n        return 2;\n      }\n      return 0;\n    }\n  }\n  private static class HelpCommand implements Command {\n    @Override\n    public String getName() {\n      return \"-help\";\n    }\n    @Override\n    public String getShortUsage() {\n      return \"[-help <command-name>]\\n\";\n    }\n    @Override\n    public String getLongUsage() {\n      final TableListing listing = getOptionDescriptionListing();\n      listing.addRow(\"<command-name>\", \"The command for which to get \" +\n          \"detailed help. If no command is specified, print detailed help for \" +\n          \"all commands\");\n      return getShortUsage() + \"\\n\" +\n        \"Get detailed help about a command.\\n\\n\" +\n        listing.toString();\n    }\n    @Override\n    public int run(Configuration conf, List<String> args) throws IOException {\n      if (args.size() == 0) {\n        for (Command command : COMMANDS) {\n          System.err.println(command.getLongUsage());\n        }\n        return 0;\n      }\n      if (args.size() != 1) {\n        System.out.println(\"You must give exactly one argument to -help.\");\n        return 0;\n      }\n      final String commandName = args.get(0);\n      // prepend a dash to match against the command names\n      final Command command = determineCommand(\"-\"+commandName);\n      if (command == null) {\n        System.err.print(\"Sorry, I don't know the command '\" +\n          commandName + \"'.\\n\");\n        System.err.print(\"Valid help command names are:\\n\");\n        String separator = \"\";\n        for (Command c : COMMANDS) {\n          System.err.print(separator + c.getName().substring(1));\n          separator = \", \";\n        }\n        System.err.print(\"\\n\");\n        return 1;\n      }\n      System.err.print(command.getLongUsage());<fim_middle>// function below has no smell\n"}