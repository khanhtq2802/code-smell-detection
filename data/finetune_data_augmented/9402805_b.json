{"text": "<fim_prefix>\n<fim_suffix>public final class ZoneOffsetTransitionRule implements Serializable {\n    /**\n     * Serialization version.\n     */\n    private static final long serialVersionUID = 6889046316657758795L;\n    /**\n     * The month of the month-day of the first day of the cutover week.\n     * The actual date will be adjusted by the dowChange field.\n     */\n    private final Month month;\n    /**\n     * The day-of-month of the month-day of the cutover week.\n     * If positive, it is the start of the week where the cutover can occur.\n     * If negative, it represents the end of the week where cutover can occur.\n     * The value is the number of days from the end of the month, such that\n     * {@code -1} is the last day of the month, {@code -2} is the second\n     * to last day, and so on.\n     */\n    private final byte dom;\n    /**\n     * The cutover day-of-week, null to retain the day-of-month.\n     */\n    private final DayOfWeek dow;\n    /**\n     * The cutover time in the 'before' offset.\n     */\n    private final LocalTime time;\n    /**\n     * Whether the cutover time is midnight at the end of day.\n     */\n    private final boolean timeEndOfDay;\n    /**\n     * The definition of how the local time should be interpreted.\n     */\n    private final TimeDefinition timeDefinition;\n    /**\n     * The standard offset at the cutover.\n     */\n    private final ZoneOffset standardOffset;\n    /**\n     * The offset before the cutover.\n     */\n    private final ZoneOffset offsetBefore;\n    /**\n     * The offset after the cutover.\n     */\n    private final ZoneOffset offsetAfter;\n    /**\n     * Obtains an instance defining the yearly rule to create transitions between two offsets.\n     * <p>\n     * Applications should normally obtain an instance from {@link ZoneRules}.\n     * This factory is only intended for use when creating {@link ZoneRules}.\n     *\n     * @param month  the month of the month-day of the first day of the cutover week, not null\n     * @param dayOfMonthIndicator  the day of the month-day of the cutover week, positive if the week is that\n     *  day or later, negative if the week is that day or earlier, counting from the last day of the month,\n     *  from -28 to 31 excluding 0\n     * @param dayOfWeek  the required day-of-week, null if the month-day should not be changed\n     * @param time  the cutover time in the 'before' offset, not null\n     * @param timeEndOfDay  whether the time is midnight at the end of day\n     * @param timeDefnition  how to interpret the cutover\n     * @param standardOffset  the standard offset in force at the cutover, not null\n     * @param offsetBefore  the offset before the cutover, not null\n     * @param offsetAfter  the offset after the cutover, not null\n     * @return the rule, not null\n     * @throws IllegalArgumentException if the day of month indicator is invalid\n     * @throws IllegalArgumentException if the end of day flag is true when the time is not midnight\n     * @throws IllegalArgumentException if {@code time.getNano()} returns non-zero value\n     */\n    public static ZoneOffsetTransitionRule of(\n            Month month,\n            int dayOfMonthIndicator,\n            DayOfWeek dayOfWeek,\n            LocalTime time,\n            boolean timeEndOfDay,\n            TimeDefinition timeDefnition,\n            ZoneOffset standardOffset,\n            ZoneOffset offsetBefore,\n            ZoneOffset offsetAfter) {\n        Objects.requireNonNull(month, \"month\");\n        Objects.requireNonNull(time, \"time\");\n        Objects.requireNonNull(timeDefnition, \"timeDefnition\");\n        Objects.requireNonNull(standardOffset, \"standardOffset\");\n        Objects.requireNonNull(offsetBefore, \"offsetBefore\");\n        Objects.requireNonNull(offsetAfter, \"offsetAfter\");\n        if (dayOfMonthIndicator < -28 || dayOfMonthIndicator > 31 || dayOfMonthIndicator == 0) {\n            throw new IllegalArgumentException(\"Day of month indicator must be between -28 and 31 inclusive excluding zero\");\n        }\n        if (timeEndOfDay && time.equals(LocalTime.MIDNIGHT) == false) {\n            throw new IllegalArgumentException(\"Time must be midnight when end of day flag is true\");\n        }\n        if (time.getNano() != 0) {\n            throw new IllegalArgumentException(\"Time's nano-of-second must be zero\");\n        }\n        return new ZoneOffsetTransitionRule(month, dayOfMonthIndicator, dayOfWeek, time, timeEndOfDay, timeDefnition, standardOffset, offsetBefore, offsetAfter);\n    }\n    /**\n     * Creates an instance defining the yearly rule to create transitions between two offsets.\n     *\n     * @param month  the month of the month-day of the first day of the cutover week, not null\n     * @param dayOfMonthIndicator  the day of the month-day of the cutover week, positive if the week is that\n     *  day or later, negative if the week is that day or earlier, counting from the last day of the month,\n     *  from -28 to 31 excluding 0\n     * @param dayOfWeek  the required day-of-week, null if the month-day should not be changed\n     * @param time  the cutover time in the 'before' offset, not null\n     * @param timeEndOfDay  whether the time is midnight at the end of day\n     * @param timeDefnition  how to interpret the cutover\n     * @param standardOffset  the standard offset in force at the cutover, not null\n     * @param offsetBefore  the offset before the cutover, not null\n     * @param offsetAfter  the offset after the cutover, not null\n     * @throws IllegalArgumentException if the day of month indicator is invalid\n     * @throws IllegalArgumentException if the end of day flag is true when the time is not midnight\n     */\n    ZoneOffsetTransitionRule(\n            Month month,\n            int dayOfMonthIndicator,\n            DayOfWeek dayOfWeek,\n            LocalTime time,\n            boolean timeEndOfDay,\n            TimeDefinition timeDefnition,\n            ZoneOffset standardOffset,\n            ZoneOffset offsetBefore,\n            ZoneOffset offsetAfter) {\n        assert time.getNano() == 0;\n        this.month = month;\n        this.dom = (byte) dayOfMonthIndicator;\n        this.dow = dayOfWeek;\n        this.time = time;\n        this.timeEndOfDay = timeEndOfDay;\n        this.timeDefinition = timeDefnition;\n        this.standardOffset = standardOffset;\n        this.offsetBefore = offsetBefore;\n        this.offsetAfter = offsetAfter;\n    }\n    //-----------------------------------------------------------------------\n    /**\n     * Defend against malicious streams.\n     *\n     * @param s the stream to read\n     * @throws InvalidObjectException always\n     */\n    private void readObject(ObjectInputStream s) throws InvalidObjectException {\n        throw new InvalidObjectException(\"Deserialization via serialization delegate\");\n    }\n    /**\n     * Writes the object using a\n     * <a href=\"{@docRoot}/serialized-form.html#java.time.zone.Ser\">dedicated serialized form</a>.\n     * @serialData\n     * Refer to the serialized form of\n     * <a href=\"{@docRoot}/serialized-form.html#java.time.zone.ZoneRules\">ZoneRules.writeReplace</a>\n     * for the encoding of epoch seconds and offsets.\n     * <pre style=\"font-size:1.0em\">{@code\n     *\n     *      out.writeByte(3);                // identifies a ZoneOffsetTransition\n     *      final int timeSecs = (timeEndOfDay ? 86400 : time.toSecondOfDay());\n     *      final int stdOffset = standardOffset.getTotalSeconds();\n     *      final int beforeDiff = offsetBefore.getTotalSeconds() - stdOffset;\n     *      final int afterDiff = offsetAfter.getTotalSeconds() - stdOffset;\n     *      final int timeByte = (timeSecs % 3600 == 0 ? (timeEndOfDay ? 24 : time.getHour()) : 31);\n     *      final int stdOffsetByte = (stdOffset % 900 == 0 ? stdOffset / 900 + 128 : 255);\n     *      final int beforeByte = (beforeDiff == 0 || beforeDiff == 1800 || beforeDiff == 3600 ? beforeDiff / 1800 : 3);\n     *      final int afterByte = (afterDiff == 0 || afterDiff == 1800 || afterDiff == 3600 ? afterDiff / 1800 : 3);\n     *      final int dowByte = (dow == null ? 0 : dow.getValue());<fim_middle>// class below is data class and blob\n"}