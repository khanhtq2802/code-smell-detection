{"text": "<fim_prefix>import org.eclipse.orion.server.core.IOUtilities;\nimport org.eclipse.orion.server.core.OrionConfiguration;\nimport org.eclipse.osgi.util.NLS;\nimport org.json.JSONObject;\nimport org.json.JSONTokener;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n<fim_suffix>public class NodeJSDeploymentPlanner implements IDeploymentPlanner {\n\tprotected final Logger logger = LoggerFactory.getLogger(\"org.eclipse.orion.server.cf\"); //$NON-NLS-1$\n\tpublic static String TYPE = \"node.js\"; //$NON-NLS-1$\n\t@Override\n\tpublic String getId() {\n\t\treturn getClass().getCanonicalName();\n\t}\n\t@Override\n\tpublic String getWizardId() {\n\t\treturn \"org.eclipse.orion.client.cf.wizard.nodejs\"; //$NON-NLS-1$\n\t}\n\tprotected String getApplicationName(IFileStore contentLocation) throws UnsupportedEncodingException {\n\t\tIFileStore rootStore = OrionConfiguration.getRootLocation();\n\t\tPath relativePath = new Path(URLDecoder.decode(contentLocation.toURI().toString(), \"UTF8\").substring(rootStore.toURI().toString().length()));\n\t\tif (relativePath.segmentCount() < 4) {\n\t\t\t// not a change to a file in a project\n\t\t\treturn null;\n\t\t}\n\t\tString projectDirectory = relativePath.segment(3);\n\t\tprojectDirectory = projectDirectory.replaceFirst(\" \\\\| \", \" --- \");\n\t\tString[] folderNameParts = projectDirectory.split(\" --- \", 2);\n\t\tif (folderNameParts.length > 1)\n\t\t\treturn folderNameParts[1];\n\t\treturn folderNameParts[0];\n\t}\n\tprotected String getApplicationHost(IFileStore contentLocation) throws UnsupportedEncodingException {\n\t\tIFileStore rootStore = OrionConfiguration.getRootLocation();\n\t\tPath relativePath = new Path(URLDecoder.decode(contentLocation.toURI().toString(), \"UTF8\").substring(rootStore.toURI().toString().length()));\n\t\tif (relativePath.segmentCount() < 4) {\n\t\t\t// not a change to a file in a project\n\t\t\treturn null;\n\t\t}\n\t\tString folderName = relativePath.segment(3);\n\t\tfolderName = folderName.replaceFirst(\" \\\\| \", \" --- \");\n\t\treturn ManifestUtils.slugify(folderName);\n\t}\n\tprotected void set(ManifestParseTree application, String property, String defaultValue) {\n\t\tif (application.has(property))\n\t\t\treturn;\n\t\telse\n\t\t\tapplication.put(property, defaultValue);\n\t}\n\t/**\n\t * Looks for a Procfile and parses the web command.\n\t * @return <code>null</code> iff there is no Procfile present or it does not contain a web command.\n\t */\n\tprotected String getProcfileCommand(IFileStore contentLocation) {\n\t\tIFileStore procfileStore = contentLocation.getChild(ManifestConstants.PROCFILE);\n\t\tif (!procfileStore.fetchInfo().exists())\n\t\t\treturn null;\n\t\tInputStream is = null;\n\t\ttry {\n\t\t\tis = procfileStore.openInputStream(EFS.NONE, null);\n\t\t\tProcfile procfile = Procfile.load(is);\n\t\t\treturn procfile.get(ManifestConstants.WEB);\n\t\t} catch (Exception ex) {\n\t\t\t/* can't parse the file, fail */\n\t\t\treturn null;\n\t\t} finally {\n\t\t\tIOUtilities.safeClose(is);\n\t\t}\n\t}\n\t/**\n\t * Looks for the package.json and parses the start command.\n\t * @return <code>null</code> iff the package.json does not contain an explicit start command.\n\t */\n\tprotected String getPackageCommand(IFileStore contentLocation) {\n\t\tIFileStore packageStore = contentLocation.getChild(NodeJSConstants.PACKAGE_JSON);\n\t\tif (!packageStore.fetchInfo().exists())\n\t\t\treturn null;\n\t\tInputStream is = null;\n\t\ttry {\n\t\t\tis = packageStore.openInputStream(EFS.NONE, null);\n\t\t\tJSONObject packageJSON = new JSONObject(new JSONTokener(new InputStreamReader(is)));\n\t\t\tif (packageJSON.has(NodeJSConstants.SCRIPTS)) {\n\t\t\t\tJSONObject scripts = packageJSON.getJSONObject(NodeJSConstants.SCRIPTS);\n\t\t\t\tif (scripts.has(NodeJSConstants.START))\n\t\t\t\t\treturn scripts.getString(NodeJSConstants.START);\n\t\t\t}\n\t\t} catch (Exception ex) {\n\t\t\t/* can't parse the file, fail */\n\t\t\treturn null;\n\t\t} finally {\n\t\t\tIOUtilities.safeClose(is);\n\t\t}\n\t\treturn null;\n\t}\n\t/**\n\t * Looks for the app.js or server.js files and creates a start command.\n\t * @return <code>null</code> iff both app.js and server.js are absent.\n\t */\n\tprotected String getConventionCommand(IFileStore contentLocation) {\n\t\tIFileStore serverJS = contentLocation.getChild(NodeJSConstants.SERVER_JS);\n\t\tif (serverJS.fetchInfo().exists())\n\t\t\treturn NodeJSConstants.NODE_SERVER_JS;\n\t\tIFileStore appJS = contentLocation.getChild(NodeJSConstants.APP_JS);\n\t\tif (appJS.fetchInfo().exists())\n\t\t\treturn NodeJSConstants.NODE_APP_JS;\n\t\treturn null;\n\t}\n\t@Override\n\tpublic Plan getDeploymentPlan(IFileStore contentLocation, ManifestParseTree manifest, IFileStore manifestStore) {\n\t\tIFileStore appStore = contentLocation;\n\t\ttry {\n\t\t\tif (manifest != null) {\n\t\t\t\tManifestParseTree application = manifest.get(ManifestConstants.APPLICATIONS).get(0);\n\t\t\t\tif (application.has(ManifestConstants.PATH)) {\n\t\t\t\t\tappStore = contentLocation.getFileStore(new Path(application.get(ManifestConstants.PATH).getValue()));\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (InvalidAccessException e) {\n\t\t\tlogger.error(\"Problem while reading manifest\", e);\n\t\t}\n\t\t/* a present package.json file determines a node.js application */\n\t\tIFileStore packageStore = appStore.getChild(NodeJSConstants.PACKAGE_JSON);\n\t\tif (!packageStore.fetchInfo().exists())\n\t\t\treturn null;\n\t\t/* do not support multi-application manifests */\n\t\tif (manifest != null && ManifestUtils.hasMultipleApplications(manifest))\n\t\t\treturn null;\n\t\ttry {\n\t\t\tString manifestPath;\n\t\t\tif (manifest == null) {\n\t\t\t\tmanifest = ManifestUtils.createBoilerplate(getApplicationName(contentLocation));\n\t\t\t\tmanifestPath = null;\n\t\t\t} else {\n\t\t\t\tmanifestPath = contentLocation.toURI().relativize(manifestStore.toURI()).toString();\n\t\t\t}\n\t\t\tManifestParseTree application = manifest.get(ManifestConstants.APPLICATIONS).get(0);\n\t\t\tString defaultName = getApplicationName(contentLocation);\n\t\t\tset(application, ManifestConstants.NAME, defaultName);\n\t\t\tset(application, ManifestConstants.HOST, getApplicationHost(contentLocation));\n\t\t\tset(application, ManifestConstants.MEMORY, ManifestUtils.DEFAULT_MEMORY);\n\t\t\tset(application, ManifestConstants.INSTANCES, ManifestUtils.DEFAULT_INSTANCES);\n\t\t\tset(application, ManifestConstants.PATH, ManifestUtils.DEFAULT_PATH);\n\t\t\t/* node.js application require a start command */\n\t\t\tif (application.has(ManifestConstants.COMMAND))\n\t\t\t\treturn new Plan(getId(), getWizardId(), TYPE, manifest, manifestPath);\n\t\t\t/* look up Procfile */\n\t\t\tString command = getProcfileCommand(appStore);\n\t\t\tif (command != null) {\n\t\t\t\t/* Do not set the command, buildpack will handle it */\n\t\t\t\t// application.put(ManifestConstants.COMMAND, command);\n\t\t\t\treturn new Plan(getId(), getWizardId(), TYPE, manifest, manifestPath);\n\t\t\t}\n\t\t\t/* look up package.json */\n\t\t\tcommand = getPackageCommand(appStore);\n\t\t\tif (command != null) {\n\t\t\t\t/* Do not set the command, buildpack will handle it */\n\t\t\t\t// application.put(ManifestConstants.COMMAND, command);\n\t\t\t\treturn new Plan(getId(), getWizardId(), TYPE, manifest, manifestPath);\n\t\t\t}\n\t\t\tcommand = getConventionCommand(appStore);\n\t\t\tif (command != null) {\n\t\t\t\tapplication.put(ManifestConstants.COMMAND, command);\n\t\t\t\treturn new Plan(getId(), getWizardId(), TYPE, manifest, manifestPath);\n\t\t\t}\n\t\t\t/* could not deduce command, mark as required */\n\t\t\tPlan plan = new Plan(getId(), getWizardId(), TYPE, manifest, manifestPath);\n\t\t\tplan.addRequired(ManifestConstants.COMMAND);\n\t\t\treturn plan;\n\t\t} catch (Exception ex) {\n\t\t\tString msg = NLS.bind(\"Failed to handle generic deployment plan for {0}\", contentLocation.toString()); //$NON-NLS-1$\n\t\t\tlogger.error(msg, ex);\n\t\t\treturn null;\n\t\t}\n\t}\n}<fim_middle>// class below has no smell\n"}