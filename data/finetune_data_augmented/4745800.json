{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.netbeans.html.json.impl;\nimport java.lang.reflect.Array;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.NoSuchElementException;\npublic class SimpleList<E> implements List<E> {\n    private Object[] arr;\n    private int size;\n    public SimpleList() {\n    }\n    private SimpleList(Object[] data) {\n        arr = data.clone();\n        size = data.length;\n    }\n    public static <T> List<T> asList(T... arr) {\n        return new SimpleList<T>(arr);\n    }\n    @Override\n    public int size() {\n        return size;\n    }\n    @Override\n    public boolean isEmpty() {\n        return size == 0;\n    }\n    @Override\n    public boolean contains(Object o) {\n        return containsImpl(o, 0, size);\n    }\n    final boolean containsImpl(Object o, int from, int to) {\n        for (int i = from; i < to; i++) {\n            if (equals(o, arr[i])) {\n                return true;\n            }\n        }\n        return false;\n    }\n    @Override\n    public Iterator<E> iterator() {\n        return new LI(0, size);\n    }\n    @Override\n    public Object[] toArray() {\n        return toArrayImpl(0, size);\n    }\n    final Object[] toArrayImpl(int from, int to) {\n        Object[] ret = new Object[to - from];\n        for (int i = 0; i < ret.length; i++) {\n            ret[i] = arr[i + from];\n        }\n        return ret;\n    }\n    @Override\n    public <T> T[] toArray(T[] a) {\n        return toArrayImpl(a, 0, size);\n    }\n    final <T> T[] toArrayImpl(T[] a, int from, int to) {\n        if (a.length < to - from) {\n            a = newArr(a, to - from);\n        }\n        for (int i = from; i < to; i++) {\n            a[i - from] = (T) arr[i];\n        }\n        return a;\n    }\n    @Override\n    public boolean add(E e) {\n        return addImpl(e);\n    }\n    private boolean addImpl(E e) {\n        ensureAccess(size + 1);\n        arr[size++] = e;\n        return true;\n    }\n    @Override\n    public boolean remove(Object o) {\n        return removeImpl(o, 0, size);\n    }\n    private boolean removeImpl(Object o, int from, int to) {\n        boolean found = false;\n        for (int i = from; i < to; i++) {\n            if (found) {\n                arr[i - 1] = arr[i];\n            } else {\n                if (equals(o, arr[i])) {\n                    found = true;\n                }\n            }\n        }\n        if (found) {\n            arr[--size] = null;\n        }\n        return found;\n    }\n    @Override\n    public boolean containsAll(Collection<?> c) {\n        for (Object o : c) {\n            if (!contains(o)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    @Override\n    public boolean addAll(Collection<? extends E> c) {\n        ensureAccess(size + c.size());\n        for (E o : c) {\n            addImpl(o);\n        }\n        return !c.isEmpty();\n    }\n    @Override\n    public boolean addAll(int index, Collection<? extends E> c) {\n        return addImpl(index, c);\n    }\n    private boolean addImpl(int index, Collection<? extends E> c) {\n        final int toAdd = c.size();\n        if (toAdd == 0) {\n            return false;\n        }\n        int nowSize = size;\n        ensureAccess(nowSize + toAdd);\n        for (int i = nowSize - 1; i >= index; i--) {\n            arr[i + toAdd] = arr[i];\n        }\n        for (Object o : c) {\n            arr[index++] = o;\n        }\n        size += toAdd;\n        return true;\n    }\n    @Override\n    public boolean removeAll(Collection<?> c) {\n        int prev = size;\n        for (Object o : c) {\n            remove(o);\n        }\n        return prev != size;\n    }\n    @Override\n    public boolean retainAll(Collection<?> c) {\n        return retainImpl(this, c);\n    }\n    public void sort(Comparator<? super E> c) {\n        sortImpl(c, 0, size);\n    }\n    final void sortImpl(Comparator<? super E> c, int from, int to) {\n        for (int i = from; i < to; i++) {\n            Object min = arr[i];\n            int minIndex = i;\n            for (int j = i + 1; j < to; j++) {\n                final int compare;\n                if (c == null) {\n                    compare = ((Comparable<Object>)min).compareTo(arr[j]);\n                } else {\n                    compare = c.compare((E)min, (E)arr[j]);\n                }\n                if (compare > 0) {\n                    min = arr[j];\n                    minIndex = j;\n                }\n            }\n            if (i != minIndex) {\n                arr[minIndex] = arr[i];\n                arr[i] = min;\n            }\n        }\n    }\n    @Override\n    public void clear() {\n        size = 0;\n    }\n    void  clearImpl(int from, int to) {\n        for (int i = 0; i + from < size; i++) {\n            arr[from + i] = arr[to + i];\n        }\n        size += from;\n        size -= to;\n    }\n    @Override\n    public E get(int index) {\n        checkAccess(index);\n        return (E) arr[index];\n    }\n<fim_suffix>    private void checkAccess(int index) throws ArrayIndexOutOfBoundsException {\n        if (index < 0 || index >= size) {\n            throw new ArrayIndexOutOfBoundsException();\n        }\n    }\n    private int ensureAccess(int reqSize) {\n        if (reqSize < size) {\n            return size;\n        }\n        int newSize = arr == null ? 0 : arr.length;\n        if (newSize < 4) {\n            newSize = 4;\n        }\n        while (newSize < reqSize) {\n            newSize *= 2;\n        }\n        Object[] newArr = new Object[newSize];\n        for (int i = 0; i < size; i++) {\n            newArr[i] = arr[i];\n        }\n        arr = newArr;\n        return reqSize;\n    }\n    private void ensureSize(int newSize) {\n        this.size = ensureAccess(newSize);\n    }\n    @Override\n    public E set(int index, E element) {\n        checkAccess(index);\n        E prev = (E) arr[index];\n        arr[index] = element;\n        return prev;\n    }\n    @Override\n    public void add(int index, E element) {\n        addImpl(index, asList(element));\n    }\n    @Override\n    public E remove(int index) {\n        checkAccess(index);\n        E prev = (E) arr[index];\n        for (int i = index + 1; i < size; i++) {\n            arr[i - 1] = arr[i];\n        }\n        arr[--size] = null;\n        return prev;\n    }\n    @Override\n    public int indexOf(Object o) {\n        return indexOfImpl(o, 0, size);\n    }\n    final int indexOfImpl(Object o, int from, int to) {\n        for (int i = from; i < to; i++) {\n            if (equals(o, arr[i])) {\n                return i - from;\n            }\n        }\n        return -1;\n    }\n    @Override\n    public int lastIndexOf(Object o) {\n        return lastIndexOfImpl(o, 0, size);\n    }\n    public int lastIndexOfImpl(Object o, int from, int to) {\n        for (int i = to - 1; i >= from; i--) {\n            if (equals(o, arr[i])) {\n                return i - from;\n            }\n        }<fim_middle>// function below has no smell\n"}