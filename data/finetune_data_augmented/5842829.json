{"text": "<fim_prefix>        return this.closed;\n    }\n    // --------------------------------------------------------- Public Methods\n    /**\n     * Recycle the output buffer.\n     */\n    public void recycle() {\n        initial = true;\n        bytesWritten = 0;\n        charsWritten = 0;\n        clear(bb);\n        clear(cb);\n        closed = false;\n        suspended = false;\n        doFlush = false;\n        if (conv != null) {\n            conv.recycle();\n            conv = null;\n        }\n    }\n    /**\n     * Close the output buffer. This tries to calculate the response size if\n     * the response has not been committed yet.\n     *\n     * @throws IOException An underlying IOException occurred\n     */\n    @Override\n    public void close() throws IOException {\n        if (closed) {\n            return;\n        }\n        if (suspended) {\n            return;\n        }\n        // If there are chars, flush all of them to the byte buffer now as bytes are used to\n        // calculate the content-length (if everything fits into the byte buffer, of course).\n        if (cb.remaining() > 0) {\n            flushCharBuffer();\n        }\n        if ((!coyoteResponse.isCommitted()) && (coyoteResponse.getContentLengthLong() == -1)\n                && !coyoteResponse.getRequest().method().equals(\"HEAD\")) {\n            // If this didn't cause a commit of the response, the final content\n            // length can be calculated. Only do this if this is not a HEAD\n            // request since in that case no body should have been written and\n            // setting a value of zero here will result in an explicit content\n            // length of zero being set on the response.\n            if (!coyoteResponse.isCommitted()) {\n                coyoteResponse.setContentLength(bb.remaining());\n            }\n        }\n        if (coyoteResponse.getStatus() == HttpServletResponse.SC_SWITCHING_PROTOCOLS) {\n            doFlush(true);\n        } else {\n            doFlush(false);\n        }\n        closed = true;\n        // The request should have been completely read by the time the response\n        // is closed. Further reads of the input a) are pointless and b) really\n        // confuse AJP (bug 50189) so close the input buffer to prevent them.\n        Request req = (Request) coyoteResponse.getRequest().getNote(CoyoteAdapter.ADAPTER_NOTES);\n        req.inputBuffer.close();\n        coyoteResponse.action(ActionCode.CLOSE, null);\n    }\n    /**\n     * Flush bytes or chars contained in the buffer.\n     *\n     * @throws IOException An underlying IOException occurred\n     */\n    @Override\n    public void flush() throws IOException {\n        doFlush(true);\n    }\n    /**\n     * Flush bytes or chars contained in the buffer.\n     *\n     * @param realFlush <code>true</code> if this should also cause a real network flush\n     * @throws IOException An underlying IOException occurred\n     */\n    protected void doFlush(boolean realFlush) throws IOException {\n        if (suspended) {\n            return;\n        }\n        try {\n            doFlush = true;\n            if (initial) {\n                coyoteResponse.sendHeaders();\n                initial = false;\n            }\n            if (cb.remaining() > 0) {\n                flushCharBuffer();\n            }\n            if (bb.remaining() > 0) {\n                flushByteBuffer();\n            }\n        } finally {\n            doFlush = false;\n        }\n        if (realFlush) {\n            coyoteResponse.action(ActionCode.CLIENT_FLUSH, null);\n            // If some exception occurred earlier, or if some IOE occurred\n            // here, notify the servlet with an IOE\n            if (coyoteResponse.isExceptionPresent()) {\n                throw new ClientAbortException(coyoteResponse.getErrorException());\n            }\n        }\n    }\n    // ------------------------------------------------- Bytes Handling Methods\n    /**\n     * Sends the buffer data to the client output, checking the\n     * state of Response and calling the right interceptors.\n     *\n     * @param buf the ByteBuffer to be written to the response\n     *\n     * @throws IOException An underlying IOException occurred\n     */\n    public void realWriteBytes(ByteBuffer buf) throws IOException {\n        if (closed) {\n            return;\n        }\n        if (coyoteResponse == null) {\n            return;\n        }\n        // If we really have something to write\n        if (buf.remaining() > 0) {\n            // real write to the adapter\n            try {\n                coyoteResponse.doWrite(buf);\n            } catch (CloseNowException e) {\n                // Catch this sub-class as it requires specific handling.\n                // Examples where this exception is thrown:\n                // - HTTP/2 stream timeout\n                // Prevent further output for this response\n                closed = true;\n                throw e;\n            } catch (IOException e) {\n                // An IOException on a write is almost always due to\n                // the remote client aborting the request. Wrap this\n                // so that it can be handled better by the error dispatcher.\n                throw new ClientAbortException(e);\n            }\n        }\n    }\n    public void write(byte b[], int off, int len) throws IOException {\n        if (suspended) {\n            return;\n        }\n        writeBytes(b, off, len);\n    }\n    public void write(ByteBuffer from) throws IOException {\n        if (suspended) {\n            return;\n        }\n        writeBytes(from);\n    }\n    private void writeBytes(byte b[], int off, int len) throws IOException {\n        if (closed) {\n            return;\n        }\n        append(b, off, len);\n        bytesWritten += len;\n        // if called from within flush(), then immediately flush\n        // remaining bytes\n        if (doFlush) {\n            flushByteBuffer();\n        }\n    }\n    private void writeBytes(ByteBuffer from) throws IOException {\n        if (closed) {\n            return;\n        }\n        append(from);\n        bytesWritten += from.remaining();\n        // if called from within flush(), then immediately flush\n        // remaining bytes\n        if (doFlush) {\n            flushByteBuffer();\n        }\n    }\n    public void writeByte(int b) throws IOException {\n        if (suspended) {\n            return;\n        }\n        if (isFull(bb)) {\n            flushByteBuffer();\n        }\n        transfer((byte) b, bb);\n        bytesWritten++;\n    }\n    // ------------------------------------------------- Chars Handling Methods\n    /**\n     * Convert the chars to bytes, then send the data to the client.\n     *\n     * @param from Char buffer to be written to the response\n     *\n     * @throws IOException An underlying IOException occurred\n     */\n    public void realWriteChars(CharBuffer from) throws IOException {\n        while (from.remaining() > 0) {\n            conv.convert(from, bb);\n            if (bb.remaining() == 0) {\n                // Break out of the loop if more chars are needed to produce any output\n                break;\n            }\n            if (from.remaining() > 0) {\n                flushByteBuffer();\n            } else if (conv.isUndeflow() && bb.limit() > bb.capacity() - 4) {\n                // Handle an edge case. There are no more chars to write at the\n                // moment but there is a leftover character in the converter\n                // which must be part of a surrogate pair. The byte buffer does\n                // not have enough space left to output the bytes for this pair\n                // once it is complete )it will require 4 bytes) so flush now to\n                // prevent the bytes for the leftover char and the rest of the\n                // surrogate pair yet to be written from being lost.\n                // See TestOutputBuffer#testUtf8SurrogateBody()\n                flushByteBuffer();\n            }\n        }\n    }\n    @Override\n    public void write(int c) throws IOException {\n        if (suspended) {\n            return;\n        }\n        if (isFull(cb)) {\n            flushCharBuffer();\n        }\n        transfer((char) c, cb);\n        charsWritten++;\n    }\n    @Override\n    public void write(char c[]) throws IOException {\n        if (suspended) {\n            return;\n        }\n        write(c, 0, c.length);\n    }\n    @Override\n    public void write(char c[], int off, int len) throws IOException {\n        if (suspended) {\n            return;\n        }\n        append(c, off, len);\n        charsWritten += len;\n    }\n    /**\n     * Append a string to the buffer\n     */\n    @Override\n    public void write(String s, int off, int len) throws IOException {\n        if (suspended) {\n            return;\n        }\n        if (s == null) {\n            throw new NullPointerException(sm.getString(\"outputBuffer.writeNull\"));\n        }\n        int sOff = off;\n        int sEnd = off + len;\n        while (sOff < sEnd) {\n            int n = transfer(s, sOff, sEnd - sOff, cb);\n            sOff += n;\n            if (isFull(cb)) {\n                flushCharBuffer();\n            }\n        }\n        charsWritten += len;\n    }\n<fim_suffix>    @Override\n    public void write(String s) throws IOException {\n        if (suspended) {\n            return;\n        }\n        if (s == null) {\n            s = \"null\";\n        }\n        write(s, 0, s.length());\n    }<fim_middle>// function below has no smell\n"}