{"text": "<fim_prefix>\tprivate final Map<String, ValueExtractor> valueExtractors;\n\tprivate final Properties properties = new Properties();\n\tpublic AutoConfigureAnnotationProcessor() {\n\t\tMap<String, String> annotations = new LinkedHashMap<>();\n\t\taddAnnotations(annotations);\n\t\tthis.annotations = Collections.unmodifiableMap(annotations);\n\t\tMap<String, ValueExtractor> valueExtractors = new LinkedHashMap<>();\n\t\taddValueExtractors(valueExtractors);\n\t\tthis.valueExtractors = Collections.unmodifiableMap(valueExtractors);\n\t}\n\tprotected void addAnnotations(Map<String, String> annotations) {\n\t\tannotations.put(\"Configuration\",\n\t\t\t\t\"org.springframework.context.annotation.Configuration\");\n\t\tannotations.put(\"ConditionalOnClass\",\n\t\t\t\t\"org.springframework.boot.autoconfigure.condition.ConditionalOnClass\");\n\t\tannotations.put(\"ConditionalOnBean\",\n\t\t\t\t\"org.springframework.boot.autoconfigure.condition.ConditionalOnBean\");\n\t\tannotations.put(\"ConditionalOnSingleCandidate\",\n\t\t\t\t\"org.springframework.boot.autoconfigure.condition.ConditionalOnSingleCandidate\");\n\t\tannotations.put(\"ConditionalOnWebApplication\",\n\t\t\t\t\"org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication\");\n\t\tannotations.put(\"AutoConfigureBefore\",\n\t\t\t\t\"org.springframework.boot.autoconfigure.AutoConfigureBefore\");\n\t\tannotations.put(\"AutoConfigureAfter\",\n\t\t\t\t\"org.springframework.boot.autoconfigure.AutoConfigureAfter\");\n\t\tannotations.put(\"AutoConfigureOrder\",\n\t\t\t\t\"org.springframework.boot.autoconfigure.AutoConfigureOrder\");\n\t}\n\tprivate void addValueExtractors(Map<String, ValueExtractor> attributes) {\n\t\tattributes.put(\"Configuration\", ValueExtractor.allFrom(\"value\"));\n\t\tattributes.put(\"ConditionalOnClass\", new OnClassConditionValueExtractor());\n\t\tattributes.put(\"ConditionalOnBean\", new OnBeanConditionValueExtractor());\n\t\tattributes.put(\"ConditionalOnSingleCandidate\",\n\t\t\t\tnew OnBeanConditionValueExtractor());\n\t\tattributes.put(\"ConditionalOnWebApplication\", ValueExtractor.allFrom(\"type\"));\n\t\tattributes.put(\"AutoConfigureBefore\", ValueExtractor.allFrom(\"value\", \"name\"));\n\t\tattributes.put(\"AutoConfigureAfter\", ValueExtractor.allFrom(\"value\", \"name\"));\n\t\tattributes.put(\"AutoConfigureOrder\", ValueExtractor.allFrom(\"value\"));\n\t}\n\t@Override\n\tpublic SourceVersion getSupportedSourceVersion() {\n\t\treturn SourceVersion.latestSupported();\n\t}\n\t@Override\n\tpublic boolean process(Set<? extends TypeElement> annotations,\n\t\t\tRoundEnvironment roundEnv) {\n\t\tfor (Map.Entry<String, String> entry : this.annotations.entrySet()) {\n\t\t\tprocess(roundEnv, entry.getKey(), entry.getValue());\n\t\t}\n\t\tif (roundEnv.processingOver()) {\n\t\t\ttry {\n\t\t\t\twriteProperties();\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\tthrow new IllegalStateException(\"Failed to write metadata\", ex);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tprivate void process(RoundEnvironment roundEnv, String propertyKey,\n\t\t\tString annotationName) {\n\t\tTypeElement annotationType = this.processingEnv.getElementUtils()\n\t\t\t\t.getTypeElement(annotationName);\n\t\tif (annotationType != null) {\n\t\t\tfor (Element element : roundEnv.getElementsAnnotatedWith(annotationType)) {\n\t\t\t\tElement enclosingElement = element.getEnclosingElement();\n\t\t\t\tif (enclosingElement != null\n\t\t\t\t\t\t&& enclosingElement.getKind() == ElementKind.PACKAGE) {\n\t\t\t\t\tprocessElement(element, propertyKey, annotationName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprivate void processElement(Element element, String propertyKey,\n\t\t\tString annotationName) {\n\t\ttry {\n\t\t\tString qualifiedName = Elements.getQualifiedName(element);\n\t\t\tAnnotationMirror annotation = getAnnotation(element, annotationName);\n\t\t\tif (qualifiedName != null && annotation != null) {\n\t\t\t\tList<Object> values = getValues(propertyKey, annotation);\n\t\t\t\tthis.properties.put(qualifiedName + \".\" + propertyKey,\n\t\t\t\t\t\ttoCommaDelimitedString(values));\n\t\t\t\tthis.properties.put(qualifiedName, \"\");\n\t\t\t}\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"Error processing configuration meta-data on \" + element, ex);\n\t\t}\n\t}\n\tprivate AnnotationMirror getAnnotation(Element element, String type) {\n\t\tif (element != null) {\n\t\t\tfor (AnnotationMirror annotation : element.getAnnotationMirrors()) {\n\t\t\t\tif (type.equals(annotation.getAnnotationType().toString())) {\n\t\t\t\t\treturn annotation;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\tprivate String toCommaDelimitedString(List<Object> list) {\n\t\tStringBuilder result = new StringBuilder();\n\t\tfor (Object item : list) {\n\t\t\tresult.append((result.length() != 0) ? \",\" : \"\");\n\t\t\tresult.append(item);\n\t\t}\n\t\treturn result.toString();\n\t}\n\tprivate List<Object> getValues(String propertyKey, AnnotationMirror annotation) {\n\t\tValueExtractor extractor = this.valueExtractors.get(propertyKey);\n\t\tif (extractor == null) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t\treturn extractor.getValues(annotation);\n\t}\n\tprivate void writeProperties() throws IOException {\n\t\tif (!this.properties.isEmpty()) {\n\t\t\tFileObject file = this.processingEnv.getFiler()\n\t\t\t\t\t.createResource(StandardLocation.CLASS_OUTPUT, \"\", PROPERTIES_PATH);\n\t\t\ttry (OutputStream outputStream = file.openOutputStream()) {\n\t\t\t\tthis.properties.store(outputStream, null);\n\t\t\t}\n\t\t}\n\t}\n\t@FunctionalInterface\n\tprivate interface ValueExtractor {\n\t\tList<Object> getValues(AnnotationMirror annotation);\n\t\tstatic ValueExtractor allFrom(String... names) {\n\t\t\treturn new NamedValuesExtractor(names);\n\t\t}\n\t}\n\tprivate abstract static class AbstractValueExtractor implements ValueExtractor {\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tprotected Stream<Object> extractValues(AnnotationValue annotationValue) {\n\t\t\tif (annotationValue == null) {\n\t\t\t\treturn Stream.empty();\n\t\t\t}\n\t\t\tObject value = annotationValue.getValue();\n\t\t\tif (value instanceof List) {\n\t\t\t\treturn ((List<AnnotationValue>) value).stream()\n\t\t\t\t\t\t.map((annotation) -> extractValue(annotation.getValue()));\n\t\t\t}\n\t\t\treturn Stream.of(extractValue(value));\n\t\t}\n\t\tprivate Object extractValue(Object value) {\n\t\t\tif (value instanceof DeclaredType) {\n\t\t\t\treturn Elements.getQualifiedName(((DeclaredType) value).asElement());\n\t\t\t}\n\t\t\treturn value;\n\t\t}\n\t}\n\tprivate static class NamedValuesExtractor extends AbstractValueExtractor {\n\t\tprivate final Set<String> names;\n\t\tNamedValuesExtractor(String... names) {\n\t\t\tthis.names = new HashSet<>(Arrays.asList(names));\n\t\t}\n\t\t@Override\n\t\tpublic List<Object> getValues(AnnotationMirror annotation) {\n\t\t\tList<Object> result = new ArrayList<>();\n\t\t\tannotation.getElementValues().forEach((key, value) -> {\n\t\t\t\tif (this.names.contains(key.getSimpleName().toString())) {\n\t\t\t\t\textractValues(value).forEach(result::add);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn result;\n\t\t}\n\t}\n\tprivate static class OnBeanConditionValueExtractor extends AbstractValueExtractor {\n\t\t@Override\n\t\tpublic List<Object> getValues(AnnotationMirror annotation) {\n\t\t\tMap<String, AnnotationValue> attributes = new LinkedHashMap<>();\n\t\t\tannotation.getElementValues().forEach((key, value) -> attributes\n\t\t\t\t\t.put(key.getSimpleName().toString(), value));\n\t\t\tif (attributes.containsKey(\"name\")) {\n\t\t\t\treturn Collections.emptyList();\n\t\t\t}\n\t\t\tList<Object> result = new ArrayList<>();\n\t\t\textractValues(attributes.get(\"value\")).forEach(result::add);\n\t\t\textractValues(attributes.get(\"type\")).forEach(result::add);\n\t\t\treturn result;\n\t\t}\n\t}\n<fim_suffix>\tprivate static class OnClassConditionValueExtractor extends NamedValuesExtractor {\n\t\tOnClassConditionValueExtractor() {\n\t\t\tsuper(\"value\", \"name\");\n\t\t}\n\t\t@Override\n\t\tpublic List<Object> getValues(AnnotationMirror annotation) {\n\t\t\tList<Object> values = super.getValues(annotation);\n\t\t\tvalues.sort(this::compare);\n\t\t\treturn values;\n\t\t}\n\t\tprivate int compare(Object o1, Object o2) {\n\t\t\treturn Comparator.comparing(this::isSpringClass)\n\t\t\t\t\t.thenComparing(String.CASE_INSENSITIVE_ORDER)\n\t\t\t\t\t.compare(o1.toString(), o2.toString());\n\t\t}\n\t\tprivate boolean isSpringClass(String type) {\n\t\t\treturn type.startsWith(\"org.springframework\");\n\t\t}\n\t}<fim_middle>// class below has no smell\n"}