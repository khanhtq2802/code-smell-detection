{"text": "<fim_prefix>\n<fim_suffix>public class GenericsUtils {\n    public static final GenericsType[] EMPTY_GENERICS_ARRAY = GenericsType.EMPTY_ARRAY;\n    public static final String JAVA_LANG_OBJECT = \"java.lang.Object\";\n    /**\n     * Given a parameterized type and a generic type information, aligns actual type parameters. For example, if a\n     * class uses generic type <pre>&lt;T,U,V&gt;</pre> (redirectGenericTypes), is used with actual type parameters\n     * <pre>&lt;java.lang.String, U,V&gt;</pre>, then a class or interface using generic types <pre>&lt;T,V&gt;</pre>\n     * will be aligned to <pre>&lt;java.lang.String,V&gt;</pre>\n     *\n     * @param redirectGenericTypes the type arguments or the redirect class node\n     * @param parameterizedTypes   the actual type arguments used on this class node\n     * @param alignmentTarget      the generic type arguments to which we want to align to\n     * @return aligned type arguments\n     * @deprecated You shouldn't call this method because it is inherently unreliable\n     */\n    @Deprecated\n    public static GenericsType[] alignGenericTypes(final GenericsType[] redirectGenericTypes, final GenericsType[] parameterizedTypes, final GenericsType[] alignmentTarget) {\n        if (alignmentTarget == null) return EMPTY_GENERICS_ARRAY;\n        if (parameterizedTypes == null || parameterizedTypes.length == 0) return alignmentTarget;\n        GenericsType[] generics = new GenericsType[alignmentTarget.length];\n        for (int i = 0, scgtLength = alignmentTarget.length; i < scgtLength; i++) {\n            final GenericsType currentTarget = alignmentTarget[i];\n            GenericsType match = null;\n            if (redirectGenericTypes != null) {\n                for (int j = 0; j < redirectGenericTypes.length && match == null; j++) {\n                    GenericsType redirectGenericType = redirectGenericTypes[j];\n                    if (redirectGenericType.isCompatibleWith(currentTarget.getType())) {\n                        if (currentTarget.isPlaceholder() && redirectGenericType.isPlaceholder() && !currentTarget.getName().equals(redirectGenericType.getName())) {\n                            // check if there's a potential better match\n                            boolean skip = false;\n                            for (int k = j + 1; k < redirectGenericTypes.length && !skip; k++) {\n                                GenericsType ogt = redirectGenericTypes[k];\n                                if (ogt.isPlaceholder() && ogt.isCompatibleWith(currentTarget.getType()) && ogt.getName().equals(currentTarget.getName())) {\n                                    skip = true;\n                                }\n                            }\n                            if (skip) continue;\n                        }\n                        match = parameterizedTypes[j];\n                        if (currentTarget.isWildcard()) {\n                            // if alignment target is a wildcard type\n                            // then we must make best effort to return a parameterized\n                            // wildcard\n                            ClassNode lower = currentTarget.getLowerBound() != null ? match.getType() : null;\n                            ClassNode[] currentUpper = currentTarget.getUpperBounds();\n                            ClassNode[] upper = currentUpper != null ? new ClassNode[currentUpper.length] : null;\n                            if (upper != null) {\n                                for (int k = 0; k < upper.length; k++) {\n                                    upper[k] = currentUpper[k].isGenericsPlaceHolder() ? match.getType() : currentUpper[k];\n                                }\n                            }\n                            match = new GenericsType(ClassHelper.makeWithoutCaching(\"?\"), upper, lower);\n                            match.setWildcard(true);\n                        }\n                    }\n                }\n            }\n            if (match == null) {\n                match = currentTarget;\n            }\n            generics[i] = match;\n        }\n        return generics;\n    }\n    /**\n     * Generates a wildcard generic type in order to be used for checks against class nodes.\n     * See {@link GenericsType#isCompatibleWith(org.codehaus.groovy.ast.ClassNode)}.\n     *\n     * @param types the type to be used as the wildcard upper bound\n     * @return a wildcard generics type\n     */\n    public static GenericsType buildWildcardType(final ClassNode... types) {\n        ClassNode base = ClassHelper.makeWithoutCaching(\"?\");\n        GenericsType gt = new GenericsType(base, types, null);\n        gt.setWildcard(true);\n        return gt;\n    }\n    public static Map<GenericsTypeName, GenericsType> extractPlaceholders(ClassNode cn) {\n        Map<GenericsTypeName, GenericsType> ret = new HashMap<GenericsTypeName, GenericsType>();\n        extractPlaceholders(cn, ret);\n        return ret;\n    }\n    /**\n     * For a given classnode, fills in the supplied map with the parameterized\n     * types it defines.\n     *\n     * @param node the class node to check\n     * @param map the generics type information collector\n     */\n    public static void extractPlaceholders(ClassNode node, Map<GenericsTypeName, GenericsType> map) {\n        if (node == null) return;\n        if (node.isArray()) {\n            extractPlaceholders(node.getComponentType(), map);\n            return;\n        }\n        if (!node.isUsingGenerics() || !node.isRedirectNode()) return;\n        GenericsType[] parameterized = node.getGenericsTypes();\n        if (parameterized == null || parameterized.length == 0) return;\n        GenericsType[] redirectGenericsTypes = node.redirect().getGenericsTypes();\n        if (redirectGenericsTypes == null ||\n                (node.isGenericsPlaceHolder() && redirectGenericsTypes.length != parameterized.length) /* GROOVY-8609 */ ) {\n            redirectGenericsTypes = parameterized;\n        }\n        if (redirectGenericsTypes.length != parameterized.length) {\n            throw new GroovyBugError(\"Expected earlier checking to detect generics parameter arity mismatch\" +\n                    \"\\nExpected: \" + node.getName() + toGenericTypesString(redirectGenericsTypes) +\n                    \"\\nSupplied: \" + node.getName() + toGenericTypesString(parameterized));\n        }\n        List<GenericsType> valueList = new LinkedList<>();\n        for (int i = 0; i < redirectGenericsTypes.length; i++) {\n            GenericsType redirectType = redirectGenericsTypes[i];\n            if (redirectType.isPlaceholder()) {\n                GenericsTypeName name = new GenericsTypeName(redirectType.getName());\n                if (!map.containsKey(name)) {\n                    GenericsType value = parameterized[i];\n                    map.put(name, value);\n                    valueList.add(value);\n                }\n            }\n        }\n        for (GenericsType value : valueList) {\n            if (value.isWildcard()) {\n                ClassNode lowerBound = value.getLowerBound();\n                if (lowerBound != null) {\n                    extractPlaceholders(lowerBound, map);\n                }\n                ClassNode[] upperBounds = value.getUpperBounds();\n                if (upperBounds != null) {\n                    for (ClassNode upperBound : upperBounds) {\n                        extractPlaceholders(upperBound, map);\n                    }\n                }\n            } else if (!value.isPlaceholder()) {\n                extractPlaceholders(value.getType(), map);\n            }\n        }\n    }\n    public static String toGenericTypesString(GenericsType[] genericsTypes) {\n        if (genericsTypes == null) return \"\";\n        StringBuilder sb = new StringBuilder(\"<\");\n        for (int i = 0, n = genericsTypes.length; i < n; i++) {\n            sb.append(genericsTypes[i].toString());\n            if (i < n - 1) {\n                sb.append(\",\");\n            }\n        }\n        sb.append(\"> \");\n        return sb.toString();\n    }\n    /**\n     * Interface class nodes retrieved from {@link org.codehaus.groovy.ast.ClassNode#getInterfaces()}\n     * or {@link org.codehaus.groovy.ast.ClassNode#getAllInterfaces()} are returned with generic type\n     * arguments. This method allows returning a parameterized interface given the parameterized class\n     * node which implements this interface.\n     *\n     * @param hint   the class node where generics types are parameterized\n     * @param target the interface we want to parameterize generics types\n     * @return a parameterized interface class node\n     * @deprecated Use #parameterizeType instead\n     */\n    @Deprecated\n    public static ClassNode parameterizeInterfaceGenerics(final ClassNode hint, final ClassNode target) {\n        return parameterizeType(hint, target);\n    }\n    /**\n     * Interface class nodes retrieved from {@link org.codehaus.groovy.ast.ClassNode#getInterfaces()}\n     * or {@link org.codehaus.groovy.ast.ClassNode#getAllInterfaces()} are returned with generic type\n     * arguments. This method allows returning a parameterized interface given the parameterized class\n     * node which implements this interface.\n     *\n     * @param hint   the class node where generics types are parameterized\n     * @param target the interface we want to parameterize generics types<fim_middle>// class below is blob\n"}