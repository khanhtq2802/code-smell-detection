{"text": "<fim_prefix>     *  otherwise the default is false\n     */\n    static boolean notNull(PropertyDescriptor descriptor) {\n        return Boolean.TRUE.equals(descriptor.getValue(NOT_UNDEFINED));\n    }\n    /**\n     * Returns true if the property default value is not saved\n     * \n     * @param descriptor the property descriptor\n     * @return true if the attribute {@link #DEFAULT_NOT_SAVED} is defined and equal to Boolean.TRUE;\n     *  otherwise the default is false\n     */\n    static boolean noSaveDefault(PropertyDescriptor descriptor) {\n        return Boolean.TRUE.equals(descriptor.getValue(DEFAULT_NOT_SAVED));\n    }\n    /**\n     * Set the value of the i-th property, properly reporting a possible\n     * failure.\n     *\n     * @param i\n     *            the index of the property in the descriptors and editors\n     *            arrays\n     * @param value\n     *            the value to be stored in the editor\n     *\n     * @throws IllegalArgumentException\n     *             if the editor refuses the value\n     */\n    private void setEditorValue(int i, Object value) throws IllegalArgumentException {\n        editors[i].setValue(value);\n    }\n    /**\n     * {@inheritDoc}\n     * @param map must be an instance of Map&lt;String, Object&gt;\n     */\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public void setObject(Object map) {\n        propertyMap = (Map<String, Object>) map;\n        if (propertyMap.isEmpty()) {\n            // Uninitialized -- set it to the defaults:\n            for (PropertyDescriptor descriptor : descriptors) {\n                Object value = descriptor.getValue(DEFAULT);\n                String name = descriptor.getName();\n                if (value != null) {\n                    propertyMap.put(name, value);\n                    log.debug(\"Set {}={}\", name, value);\n                }\n                firePropertyChange(name, null, value);\n            }\n        }\n        // Now set the editors to the element's values:\n        for (int i = 0; i < editors.length; i++) {\n            if (editors[i] == null) {\n                continue;\n            }\n            try {\n                setEditorValue(i, propertyMap.get(descriptors[i].getName()));\n            } catch (IllegalArgumentException e) {\n                // I guess this can happen as a result of a bad\n                // file read? In this case, it would be better to replace the\n                // incorrect value with anything valid, e.g. the default value\n                // for the property.\n                // But for the time being, I just prefer to be aware of any\n                // problems occurring here, most likely programming errors,\n                // so I'll bail out.\n                // (MS Note) Can't bail out - newly create elements have blank\n                // values and must get the defaults.\n                // Also, when loading previous versions of JMeter test scripts,\n                // some values\n                // may not be right, and should get default values - MS\n                // TODO: review this and possibly change to:\n                setEditorValue(i, descriptors[i].getValue(DEFAULT));\n            }\n        }\n    }\n    /**\n     * Initialize the GUI.\n     */\n    private void init() { // WARNING: called from ctor so must not be overridden (i.e. must be private or final)\n        setLayout(new GridBagLayout());\n        GridBagConstraints cl = new GridBagConstraints(); // for labels\n        cl.gridx = 0;\n        cl.anchor = GridBagConstraints.EAST;\n        cl.insets = new Insets(0, 1, 0, 1);\n        GridBagConstraints ce = new GridBagConstraints(); // for editors\n        ce.fill = GridBagConstraints.BOTH;\n        ce.gridx = 1;\n        ce.weightx = 1.0;\n        ce.insets = new Insets(0, 1, 0, 1);\n        GridBagConstraints cp = new GridBagConstraints(); // for panels\n        cp.fill = GridBagConstraints.BOTH;\n        cp.gridx = 1;\n        cp.gridy = GridBagConstraints.RELATIVE;\n        cp.gridwidth = 2;\n        cp.weightx = 1.0;\n        JPanel currentPanel = this;\n        String currentGroup = DEFAULT_GROUP;\n        int y = 0;\n        for (int i = 0; i < editors.length; i++) {\n            if (editors[i] == null) {\n                continue;\n            }\n            if (log.isDebugEnabled()) {\n                log.debug(\"Laying property {}\", descriptors[i].getName());\n            }\n            String g = group(descriptors[i]);\n            if (!currentGroup.equals(g)) {\n                if (currentPanel != this) {\n                    add(currentPanel, cp);\n                }\n                currentGroup = g;\n                currentPanel = new JPanel(new GridBagLayout());\n                currentPanel.setBorder(BorderFactory.createTitledBorder(BorderFactory.createEtchedBorder(),\n                        groupDisplayName(g)));\n                cp.weighty = 0.0;\n                y = 0;\n            }\n            Component customEditor = editors[i].getCustomEditor();\n            boolean multiLineEditor = false;\n            if (customEditor.getPreferredSize().height > 50 || customEditor instanceof JScrollPane\n                    || descriptors[i].getValue(MULTILINE) != null) {\n                // TODO: the above works in the current situation, but it's\n                // just a hack. How to get each editor to report whether it\n                // wants to grow bigger? Whether the property label should\n                // be at the left or at the top of the editor? ...?\n                multiLineEditor = true;\n            }\n            JLabel label = createLabel(descriptors[i]);\n            label.setLabelFor(customEditor);\n            cl.gridy = y;\n            cl.gridwidth = multiLineEditor ? 2 : 1;\n            cl.anchor = multiLineEditor ? GridBagConstraints.CENTER : GridBagConstraints.EAST;\n            currentPanel.add(label, cl);\n            ce.gridx = multiLineEditor ? 0 : 1;\n            ce.gridy = multiLineEditor ? ++y : y;\n            ce.gridwidth = multiLineEditor ? 2 : 1;\n            ce.weighty = multiLineEditor ? 1.0 : 0.0;\n            cp.weighty += ce.weighty;\n            currentPanel.add(customEditor, ce);\n            y++;\n        }\n        if (currentPanel != this) {\n            add(currentPanel, cp);\n        }\n        // Add a 0-sized invisible component that will take all the vertical\n        // space that nobody wants:\n        cp.weighty = 0.0001;\n        add(Box.createHorizontalStrut(0), cp);\n    }\n    private JLabel createLabel(PropertyDescriptor desc) {\n        String text = desc.getDisplayName();\n        if (!\"\".equals(text)) {\n            text = propertyFieldLabelMessage.format(new Object[] { desc.getDisplayName() });\n        }\n        // if the displayName is the empty string, leave it like that.\n        JLabel label = new JLabel(text);\n        label.setHorizontalAlignment(SwingConstants.TRAILING);\n        label.setToolTipText(propertyToolTipMessage.format(new Object[] { desc.getShortDescription() }));\n        return label;\n    }\n    /**\n     * Obtain a property descriptor's group.\n     *\n     * @param descriptor\n     * @return the group String.\n     */\n    private static String group(PropertyDescriptor descriptor) {\n        String group = (String) descriptor.getValue(GROUP);\n        if (group == null){\n            group = DEFAULT_GROUP;\n        }\n        return group;\n    }\n    /**\n     * Obtain a group's display name\n     */\n    private String groupDisplayName(String group) {\n        ResourceBundle b = (ResourceBundle) beanInfo.getBeanDescriptor().getValue(RESOURCE_BUNDLE);\n        if (b == null) {\n            return group;\n        }\n        String key = group + \".displayName\";\n        if (b.containsKey(key)) {\n            return b.getString(key);\n        } else {\n            return group;\n        }\n    }\n    /**\n     * Comparator used to sort properties for presentation in the GUI.\n     */\n    private static class PropertyComparator implements Comparator<PropertyDescriptor>, Serializable {\n        private static final long serialVersionUID = 240L;\n        private final BeanInfo beanInfo;\n        public PropertyComparator(BeanInfo beanInfo) {\n            this.beanInfo = beanInfo;\n        }\n<fim_suffix>        @Override\n        public int compare(PropertyDescriptor d1, PropertyDescriptor d2) {\n            String g1 = group(d1);\n            String g2 = group(d2);\n            Integer go1 = groupOrder(g1);\n            Integer go2 = groupOrder(g2);\n            int result = go1.compareTo(go2);\n            if (result != 0) {\n                return result;\n            }\n            result = g1.compareTo(g2);\n            if (result != 0) {\n                return result;\n            }\n            Integer po1 = propertyOrder(d1);\n            Integer po2 = propertyOrder(d2);\n            result = po1.compareTo(po2);\n            if (result != 0) {\n                return result;\n            }\n            return d1.getName().compareTo(d2.getName());\n        }<fim_middle>// function below has no smell\n"}