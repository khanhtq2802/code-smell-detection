{"text": "<fim_prefix>            final StatementPattern pattern = it.next();\n            if (!pattern.getSubjectVar().equals(subject)) {\n                throw new IllegalStateException(\"At least one of the patterns has a different subject from the others. \"\n                        + \"All subjects must be the same.\");\n            }\n        }\n    }\n    /**\n     * Verifies all of the Statement Patterns have Constants for their\n     * predicates.\n     *\n     * @param patterns\n     *            - The patterns to check. (not null)\n     * @throws IllegalStateException\n     *             A pattern has a variable predicate.\n     */\n    private static void verifyAllPredicatesAreConstants(final Collection<StatementPattern> patterns)\n            throws IllegalStateException {\n        requireNonNull(patterns);\n        for (final StatementPattern pattern : patterns) {\n            if (!pattern.getPredicateVar().isConstant()) {\n                throw new IllegalStateException(\n                        \"The Predicate of a Statement Pattern must be constant. Pattern: \" + pattern);\n            }\n        }\n    }\n    /**\n     * Verifies StatementPatterns define a reified pattern with associated\n     * metadata properties.\n     *\n     * @param patterns\n     *            - The patterns to check. (not null)\n     * @throws IllegalStateException\n     *             No Type or the wrong Type is specified by the patterns.\n     */\n    public static boolean verifyHasCorrectTypePattern(final Collection<StatementPattern> patterns)\n            throws IllegalStateException {\n        requireNonNull(patterns);\n        boolean subjFound = false;\n        boolean objFound = false;\n        boolean predFound = false;\n        boolean statementFound = false;\n        boolean valid = true;\n        boolean contextSet = false;\n        Var context = null;\n        for (final StatementPattern pattern : patterns) {\n            final RyaIRI predicate = new RyaIRI(pattern.getPredicateVar().getValue().toString());\n            if (!contextSet) {\n                context = pattern.getContextVar();\n                contextSet = true;\n            } else {\n                if(context != null && !context.equals(pattern.getContextVar())) {\n                    return false;\n                }\n            }\n            if (predicate.equals(TYPE_ID_URI)) {\n                final RyaIRI statementID = new RyaIRI(pattern.getObjectVar().getValue().stringValue());\n                if (statementID.equals(STATEMENT_ID_URI)) {\n                    statementFound = true;\n                } else {\n                    // contains more than one Statement containing TYPE_ID_URI\n                    // as Predicate\n                    // and STATEMENT_ID_URI as Object\n                    valid = false;\n                }\n            }\n            if (predicate.equals(SUBJ_ID_URI)) {\n                if (!subjFound) {\n                    subjFound = true;\n                } else {\n                    // contains more than Subject SP\n                    valid = false;\n                }\n            }\n            if (predicate.equals(PRED_ID_URI)) {\n                if (!predFound) {\n                    predFound = true;\n                } else {\n                    // contains more than one Predicate SP\n                    valid = false;\n                }\n            }\n            if (predicate.equals(OBJ_ID_URI)) {\n                if (!objFound) {\n                    objFound = true;\n                } else {\n                    // contains more than one Object SP\n                    valid = false;\n                }\n            }\n        }\n        return valid && statementFound && subjFound && predFound && objFound;\n    }\n    /**\n     * Constructs a {@link StatementPattern} from the StatementPatterns\n     * representing a reified query. This StatementPattern has as a subject, the\n     * object of the StatementPattern containing the predicate\n     * {@link RDF#SUBJECT}. This StatementPattern has as predicate, the object\n     * of the StatementPattern containing the predicate {@link RDF#PREDICATE}.\n     * This StatementPattern has as an object, the object of the\n     * StatementPattern containing the predicate {@link RDF#OBJECT}. This method\n     * also builds a map between all predicates that are not of the above type\n     * and the object {@link Var}s they are associated with. This map contains\n     * the user specified metadata properties and is used for comparison with\n     * the metadata properties extracted from RyaStatements passed back by the\n     * {@link RyaQueryEngine}.\n     * \n     * @param patterns\n     *            - collection of patterns representing a reified query\n     */\n    private void setStatementPatternAndProperties(Collection<StatementPattern> patterns) {\n        StatementPattern sp = new StatementPattern();\n        Map<RyaIRI, Var> properties = new HashMap<>();\n        for (final StatementPattern pattern : patterns) {\n            final RyaIRI predicate = new RyaIRI(pattern.getPredicateVar().getValue().toString());\n            if (!uriList.contains(predicate)) {\n                Var objVar = pattern.getObjectVar();\n                properties.put(predicate, objVar);\n                continue;\n            }\n            if (predicate.equals(SUBJ_ID_URI)) {\n                sp.setContextVar(pattern.getContextVar());\n                sp.setSubjectVar(pattern.getObjectVar());\n            }\n            if (predicate.equals(PRED_ID_URI)) {\n                sp.setPredicateVar(pattern.getObjectVar());\n            }\n            if (predicate.equals(OBJ_ID_URI)) {\n                sp.setObjectVar(pattern.getObjectVar());\n            }\n        }\n        this.statement = sp;\n        this.properties = properties;\n    }\n    /**\n     * This method pairs each {@link BindingSet} in the specified collection\n     * with the StatementPattern constraints and issues a query to Rya using the\n     * {@link RyaQueryEngine}.\n     */\n    @Override\n    public CloseableIteration<BindingSet, QueryEvaluationException> evaluate(Collection<BindingSet> bindingset)\n            throws QueryEvaluationException {\n        if (bindingset.size() == 0) {\n            return new EmptyIteration<>();\n        }\n        queryEngine = RyaQueryEngineFactory.getQueryEngine(conf);\n        Set<Map.Entry<RyaStatement, BindingSet>> statements = new HashSet<>();\n        Iterator<BindingSet> iter = bindingset.iterator();\n        while (iter.hasNext()) {\n            BindingSet bs = iter.next();\n            statements.add(new RdfCloudTripleStoreUtils.CustomEntry<RyaStatement, BindingSet>(\n                    getRyaStatementFromBindings(bs), bs));\n        }\n        final CloseableIteration<? extends Entry<RyaStatement, BindingSet>, RyaDAOException> iteration;\n        try {\n            iteration = queryEngine.queryWithBindingSet(statements, conf);\n        } catch (RyaDAOException e) {\n            throw new RuntimeException(e);\n        }\n        return new PropertyFilterAndBindingSetJoinIteration(iteration, properties, statement);\n    }\n    /**\n     * Uses StatementPattern constraints to form a RyaStatement, and fills in\n     * any null values with {@link BindingSet} values corresponding to the\n     * variable for that position.\n     * \n     * @param bs\n     * @return RyaStatement whose values are determined by StatementPattern and\n     *         BindingSet constraints\n     */\n    private RyaStatement getRyaStatementFromBindings(BindingSet bs) {\n        Value subjValue = getVarValue(statement.getSubjectVar(), bs);\n        Value predValue = getVarValue(statement.getPredicateVar(), bs);\n        Value objValue = getVarValue(statement.getObjectVar(), bs);\n        Value contextValue = getVarValue(statement.getContextVar(), bs);\n        RyaIRI subj = null;\n        RyaIRI pred = null;\n        RyaType obj = null;\n        RyaIRI context = null;\n        if (subjValue != null) {\n            Preconditions.checkArgument(subjValue instanceof IRI);\n            subj = RdfToRyaConversions.convertIRI((IRI) subjValue);\n        }\n        if (predValue != null) {\n            Preconditions.checkArgument(predValue instanceof IRI);\n            pred = RdfToRyaConversions.convertIRI((IRI) predValue);\n        }\n        if (objValue != null) {\n            obj = RdfToRyaConversions.convertValue(objValue);\n        }\n        if(contextValue != null) {\n            context = RdfToRyaConversions.convertIRI((IRI) contextValue);\n        }\n        return new RyaStatement(subj, pred, obj, context);\n    }\n    /**\n     * Assigns BindingSet values for any {@link Var} whose {@link Value} is\n     * null. Returns the {@link Value} associated with Var (if it has one),\n     * otherwise returns the BindingSet Value corresponding to\n     * {@link Var#getName()}. If no such Binding exits, this method returns\n     * null.\n     * \n     * @param var\n     * @param bindings\n     * @return Value\n     */\n    private Value getVarValue(Var var, BindingSet bindings) {\n        if (var == null) {\n            return null;\n        } else if (var.hasValue()) {\n            return var.getValue();\n        } else {\n            return bindings.getValue(var.getName());\n        }\n    }\n<fim_suffix>    @Override\n    public CloseableIteration<BindingSet, QueryEvaluationException> evaluate(BindingSet bindings)\n            throws QueryEvaluationException {\n        return evaluate(Collections.singleton(bindings));\n    }<fim_middle>// function below has no smell\n"}