{"text": "<fim_prefix>     */\n    int remainingCACerts;\n    /* The list of user-defined checkers retrieved from the PKIXParameters\n     * instance */\n    ArrayList<PKIXCertPathChecker> userCheckers;\n    /* Flag indicating if state is initial (path is just starting) */\n    private boolean init = true;\n    /* the checker used for revocation status */\n    RevocationChecker revChecker;\n    /* the algorithm checker */\n    AlgorithmChecker algorithmChecker;\n    /* the untrusted certificates checker */\n    UntrustedChecker untrustedChecker;\n    /* the trust anchor used to validate the path */\n    TrustAnchor trustAnchor;\n    /* Flag indicating if current cert can vouch for the CRL for\n     * the next cert\n     */\n    boolean crlSign = true;\n    /**\n     * Returns a boolean flag indicating if the state is initial\n     * (just starting)\n     *\n     * @return boolean flag indicating if the state is initial (just starting)\n     */\n    @Override\n    public boolean isInitial() {\n        return init;\n    }\n    /**\n     * Display state for debugging purposes\n     */\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"State [\");\n        sb.append(\"\\n  subjectDN of last cert: \").append(subjectDN);\n        sb.append(\"\\n  subjectKeyIdentifier: \").append\n                 (String.valueOf(subjKeyId));\n        sb.append(\"\\n  nameConstraints: \").append(String.valueOf(nc));\n        sb.append(\"\\n  certIndex: \").append(certIndex);\n        sb.append(\"\\n  explicitPolicy: \").append(explicitPolicy);\n        sb.append(\"\\n  policyMapping:  \").append(policyMapping);\n        sb.append(\"\\n  inhibitAnyPolicy:  \").append(inhibitAnyPolicy);\n        sb.append(\"\\n  rootNode: \").append(rootNode);\n        sb.append(\"\\n  remainingCACerts: \").append(remainingCACerts);\n        sb.append(\"\\n  crlSign: \").append(crlSign);\n        sb.append(\"\\n  init: \").append(init);\n        sb.append(\"\\n]\\n\");\n        return sb.toString();\n    }\n    /**\n     * Initialize the state.\n     *\n     * @param buildParams builder parameters\n     */\n    public void initState(BuilderParams buildParams)\n        throws CertPathValidatorException\n    {\n        /*\n         * Initialize number of remainingCACerts.\n         * Note that -1 maxPathLen implies unlimited.\n         * 0 implies only an EE cert is acceptable.\n         */\n        int maxPathLen = buildParams.maxPathLength();\n        remainingCACerts = (maxPathLen == -1) ? Integer.MAX_VALUE\n                                              : maxPathLen;\n        /* Initialize explicit policy state variable */\n        if (buildParams.explicitPolicyRequired()) {\n            explicitPolicy = 0;\n        } else {\n            // unconstrained if maxPathLen is -1,\n            // otherwise, we want to initialize this to the value of the\n            // longest possible path + 1 (i.e. maxpathlen + finalcert + 1)\n            explicitPolicy = (maxPathLen == -1) ? maxPathLen : maxPathLen + 2;\n        }\n        /* Initialize policy mapping state variable */\n        if (buildParams.policyMappingInhibited()) {\n            policyMapping = 0;\n        } else {\n            policyMapping = (maxPathLen == -1) ? maxPathLen : maxPathLen + 2;\n        }\n        /* Initialize inhibit any policy state variable */\n        if (buildParams.anyPolicyInhibited()) {\n            inhibitAnyPolicy = 0;\n        } else {\n            inhibitAnyPolicy = (maxPathLen == -1) ? maxPathLen : maxPathLen + 2;\n        }\n        /* Initialize certIndex */\n        certIndex = 1;\n        /* Initialize policy tree */\n        Set<String> initExpPolSet = new HashSet<>(1);\n        initExpPolSet.add(PolicyChecker.ANY_POLICY);\n        rootNode = new PolicyNodeImpl(null, PolicyChecker.ANY_POLICY, null,\n                                      false, initExpPolSet, false);\n        /*\n         * Initialize each user-defined checker\n         * Shallow copy the checkers\n         */\n        userCheckers = new ArrayList<>(buildParams.certPathCheckers());\n        /* initialize each checker (just in case) */\n        for (PKIXCertPathChecker checker : userCheckers) {\n            checker.init(false);\n        }\n        /* Start by trusting the cert to sign CRLs */\n        crlSign = true;\n        init = true;\n    }\n    /**\n     * Update the state with the specified trust anchor.\n     *\n     * @param anchor the most-trusted CA\n     * @param buildParams builder parameters\n     */\n    public void updateState(TrustAnchor anchor, BuilderParams buildParams)\n        throws CertificateException, IOException, CertPathValidatorException\n    {\n        trustAnchor = anchor;\n        X509Certificate trustedCert = anchor.getTrustedCert();\n        if (trustedCert != null) {\n            updateState(trustedCert);\n        } else {\n            X500Principal caName = anchor.getCA();\n            updateState(anchor.getCAPublicKey(), caName);\n        }\n        // The user specified AlgorithmChecker and RevocationChecker may not be\n        // able to set the trust anchor until now.\n        boolean revCheckerAdded = false;\n        for (PKIXCertPathChecker checker : userCheckers) {\n            if (checker instanceof AlgorithmChecker) {\n                ((AlgorithmChecker)checker).trySetTrustAnchor(anchor);\n            } else if (checker instanceof PKIXRevocationChecker) {\n                if (revCheckerAdded) {\n                    throw new CertPathValidatorException(\n                        \"Only one PKIXRevocationChecker can be specified\");\n                }\n                // if it's our own, initialize it\n                if (checker instanceof RevocationChecker) {\n                    ((RevocationChecker)checker).init(anchor, buildParams);\n                }\n                ((PKIXRevocationChecker)checker).init(false);\n                revCheckerAdded = true;\n            }\n        }\n        // only create a RevocationChecker if revocation is enabled and\n        // a PKIXRevocationChecker has not already been added\n        if (buildParams.revocationEnabled() && !revCheckerAdded) {\n            revChecker = new RevocationChecker(anchor, buildParams);\n            revChecker.init(false);\n        }\n        init = false;\n    }\n    /**\n     * Update the state. This method is used when the most-trusted CA is\n     * a trusted public-key and caName, instead of a trusted cert.\n     *\n     * @param pubKey the public key of the trusted CA\n     * @param subjectDN the subject distinguished name of the trusted CA\n     */\n    private void updateState(PublicKey pubKey, X500Principal subjectDN) {\n        /* update subject DN */\n        this.subjectDN = subjectDN;\n        /* update subject public key */\n        this.pubKey = pubKey;\n    }\n    /**\n     * Update the state with the next certificate added to the path.\n     *\n     * @param cert the certificate which is used to update the state\n     */\n<fim_suffix>    public void updateState(X509Certificate cert)\n        throws CertificateException, IOException, CertPathValidatorException {\n        if (cert == null) {\n            return;\n        }\n        /* update subject DN */\n        subjectDN = cert.getSubjectX500Principal();\n        /* check for key needing to inherit alg parameters */\n        X509CertImpl icert = X509CertImpl.toImpl(cert);\n        PublicKey newKey = cert.getPublicKey();\n        if (PKIX.isDSAPublicKeyWithoutParams(newKey)) {\n            newKey = BasicChecker.makeInheritedParamsKey(newKey, pubKey);\n        }\n        /* update subject public key */\n        pubKey = newKey;\n        /*\n         * if this is a trusted cert (init == true), then we\n         * don't update any of the remaining fields\n         */\n        if (init) {\n            init = false;\n            return;\n        }\n        /* update subject key identifier */\n        subjKeyId = icert.getSubjectKeyIdentifierExtension();\n        /* update crlSign */\n        crlSign = RevocationChecker.certCanSignCrl(cert);\n        /* update current name constraints */\n        if (nc != null) {\n            nc.merge(icert.getNameConstraintsExtension());\n        } else {\n            nc = icert.getNameConstraintsExtension();\n            if (nc != null) {\n                // Make sure we do a clone here, because we're probably\n                // going to modify this object later and we don't want to\n                // be sharing it with a Certificate object!\n                nc = (NameConstraintsExtension) nc.clone();\n            }\n        }\n        /* update policy state variables */\n        explicitPolicy =\n            PolicyChecker.mergeExplicitPolicy(explicitPolicy, icert, false);\n        policyMapping =\n            PolicyChecker.mergePolicyMapping(policyMapping, icert);\n        inhibitAnyPolicy =\n            PolicyChecker.mergeInhibitAnyPolicy(inhibitAnyPolicy, icert);\n        certIndex++;\n        /*\n         * Update remaining CA certs\n         */\n        remainingCACerts =\n            ConstraintsChecker.mergeBasicConstraints(cert, remainingCACerts);\n        init = false;\n    }<fim_middle>// function below is long method and feature envy\n"}