{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.dubbo.remoting.p2p.support;\n\nimport org.apache.dubbo.common.URL;\nimport org.apache.dubbo.common.utils.StringUtils;\nimport org.apache.dubbo.remoting.ChannelHandler;\nimport org.apache.dubbo.remoting.RemotingException;\nimport org.apache.dubbo.remoting.p2p.Peer;\n\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.MulticastSocket;\n\n/**\n * MulticastGroup\n */\npublic class MulticastGroup extends AbstractGroup {\n\n    private static final String JOIN = \"join\";\n\n    private static final String LEAVE = \"leave\";\n\n    private InetAddress mutilcastAddress;\n\n    private MulticastSocket mutilcastSocket;\n\n    public MulticastGroup(URL url) {\n        super(url);\n        if (!isMulticastAddress(url.getHost())) {\n            throw new IllegalArgumentException(\"Invalid multicast address \" + url.getHost() + \", scope: 224.0.0.0 - 239.255.255.255\");\n        }\n        try {\n            mutilcastAddress = InetAddress.getByName(url.getHost());\n            mutilcastSocket = new MulticastSocket(url.getPort());\n            mutilcastSocket.setLoopbackMode(false);\n            mutilcastSocket.joinGroup(mutilcastAddress);\n            Thread thread = new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    byte[] buf = new byte[1024];\n                    DatagramPacket recv = new DatagramPacket(buf, buf.length);\n                    while (true) {\n                        try {\n                            mutilcastSocket.receive(recv);\n                            MulticastGroup.this.receive(new String(recv.getData()).trim(), (InetSocketAddress) recv.getSocketAddress());\n                        } catch (Exception e) {\n                            logger.error(e.getMessage(), e);\n                        }\n                    }\n                }\n            }, \"MulticastGroupReceiver\");\n            thread.setDaemon(true);\n            thread.start();\n        } catch (IOException e) {\n            throw new IllegalStateException(e.getMessage(), e);\n        }\n    }\n\n<fim_suffix>    private static boolean isMulticastAddress(String ip) {\n        int i = ip.indexOf('.');\n        if (i > 0) {\n            String prefix = ip.substring(0, i);\n            if (StringUtils.isInteger(prefix)) {\n                int p = Integer.parseInt(prefix);\n                return p >= 224 && p <= 239;\n            }\n        }\n        return false;\n    }\n\n    private void send(String msg) throws RemotingException {\n        DatagramPacket hi = new DatagramPacket(msg.getBytes(), msg.length(), mutilcastAddress, mutilcastSocket.getLocalPort());\n        try {\n            mutilcastSocket.send(hi);\n        } catch (IOException e) {\n            throw new IllegalStateException(e.getMessage(), e);\n        }\n    }\n\n    private void receive(String msg, InetSocketAddress remoteAddress) throws RemotingException {\n        if (msg.startsWith(JOIN)) {\n            String url = msg.substring(JOIN.length()).trim();\n            connect(URL.valueOf(url));\n        } else if (msg.startsWith(LEAVE)) {\n            String url = msg.substring(LEAVE.length()).trim();\n            disconnect(URL.valueOf(url));\n        }\n    }\n\n    @Override\n    public Peer join(URL url, ChannelHandler handler) throws RemotingException {\n        Peer peer = super.join(url, handler);\n        send(JOIN + \" \" + url.toFullString());\n        return peer;\n    }\n\n    @Override\n    public void leave(URL url) throws RemotingException {\n        super.leave(url);\n        send(LEAVE + \" \" + url.toFullString());\n    }\n\n}<fim_middle>// function below has no smell\n"}