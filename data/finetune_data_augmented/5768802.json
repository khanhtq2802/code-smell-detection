{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.syncope.core.persistence.jpa.dao;\n\nimport java.util.Date;\nimport java.util.List;\nimport javax.persistence.Query;\nimport javax.persistence.TypedQuery;\nimport org.apache.syncope.core.persistence.api.dao.ReportExecDAO;\nimport org.apache.syncope.core.persistence.api.dao.search.OrderByClause;\nimport org.apache.syncope.core.persistence.api.entity.Report;\nimport org.apache.syncope.core.persistence.api.entity.ReportExec;\nimport org.apache.syncope.core.persistence.jpa.entity.JPAReportExec;\nimport org.springframework.stereotype.Repository;\nimport org.springframework.transaction.annotation.Transactional;\nimport org.springframework.util.ReflectionUtils;\n\n@Repository\npublic class JPAReportExecDAO extends AbstractDAO<ReportExec> implements ReportExecDAO {\n\n    @Override\n    public ReportExec find(final String key) {\n        return entityManager().find(JPAReportExec.class, key);\n    }\n\n    @Override\n    public List<ReportExec> findRecent(final int max) {\n        TypedQuery<ReportExec> query = entityManager().createQuery(\n                \"SELECT e FROM \" + JPAReportExec.class.getSimpleName() + \" e \"\n                + \"WHERE e.end IS NOT NULL ORDER BY e.end DESC\", ReportExec.class);\n        query.setMaxResults(max);\n\n        return query.getResultList();\n    }\n\n    private ReportExec findLatest(final Report report, final String field) {\n        TypedQuery<ReportExec> query = entityManager().createQuery(\n                \"SELECT e FROM \" + JPAReportExec.class.getSimpleName() + \" e \"\n                + \"WHERE e.report=:report ORDER BY e.\" + field + \" DESC\", ReportExec.class);\n        query.setParameter(\"report\", report);\n        query.setMaxResults(1);\n\n        List<ReportExec> result = query.getResultList();\n        return result == null || result.isEmpty()\n                ? null\n                : result.iterator().next();\n    }\n\n    @Override\n    public ReportExec findLatestStarted(final Report report) {\n        return findLatest(report, \"start\");\n    }\n\n    @Override\n    public ReportExec findLatestEnded(final Report report) {\n        return findLatest(report, \"end\");\n    }\n\n    @Override\n    public int count(final String reportKey) {\n        Query countQuery = entityManager().createNativeQuery(\n                \"SELECT COUNT(e.id) FROM \" + JPAReportExec.TABLE + \" e WHERE e.report_id=?1\");\n        countQuery.setParameter(1, reportKey);\n\n        return ((Number) countQuery.getSingleResult()).intValue();\n    }\n\n    private String toOrderByStatement(final List<OrderByClause> orderByClauses) {\n        StringBuilder statement = new StringBuilder();\n\n        for (OrderByClause clause : orderByClauses) {\n            String field = clause.getField().trim();\n            if (ReflectionUtils.findField(JPAReportExec.class, field) != null) {\n                statement.append(\"e.\").append(field).append(' ').append(clause.getDirection().name());\n            }\n        }\n\n        if (statement.length() == 0) {\n            statement.append(\"ORDER BY e.id DESC\");\n        } else {\n            statement.insert(0, \"ORDER BY \");\n        }\n        return statement.toString();\n    }\n\n    @Override\n    public List<ReportExec> findAll(final Report report,\n            final int page, final int itemsPerPage, final List<OrderByClause> orderByClauses) {\n\n        String queryString =\n                \"SELECT e FROM \" + JPAReportExec.class.getSimpleName() + \" e WHERE e.report=:report \"\n                + toOrderByStatement(orderByClauses);\n\n        TypedQuery<ReportExec> query = entityManager().createQuery(queryString, ReportExec.class);\n        query.setParameter(\"report\", report);\n\n        // page starts from 1, while setFirtResult() starts from 0\n        query.setFirstResult(itemsPerPage * (page <= 0 ? 0 : page - 1));\n\n        if (itemsPerPage >= 0) {\n            query.setMaxResults(itemsPerPage);\n        }\n\n        return query.getResultList();\n    }\n\n    @Override\n    public List<ReportExec> findAll(\n            final Report report,\n            final Date startedBefore, final Date startedAfter, final Date endedBefore, final Date endedAfter) {\n\n        StringBuilder queryString = new StringBuilder(\"SELECT e FROM \").append(JPAReportExec.class.getSimpleName()).\n                append(\" e WHERE e.report=:report \");\n\n        if (startedBefore != null) {\n            queryString.append(\" AND e.start < :startedBefore\");\n        }\n        if (startedAfter != null) {\n            queryString.append(\" AND e.start > :startedAfter\");\n        }\n        if (endedBefore != null) {\n            queryString.append(\" AND e.end < :endedBefore\");\n        }\n        if (endedAfter != null) {\n            queryString.append(\" AND e.end > :endedAfter\");\n        }\n\n        TypedQuery<ReportExec> query = entityManager().createQuery(queryString.toString(), ReportExec.class);\n        query.setParameter(\"report\", report);\n        if (startedBefore != null) {\n            query.setParameter(\"startedBefore\", startedBefore);\n        }\n        if (startedAfter != null) {\n            query.setParameter(\"startedAfter\", startedAfter);\n        }\n        if (endedBefore != null) {\n            query.setParameter(\"endedBefore\", endedBefore);\n        }\n        if (endedAfter != null) {\n            query.setParameter(\"endedAfter\", endedAfter);\n        }\n\n        return query.getResultList();\n    }\n\n    @Transactional(rollbackFor = Throwable.class)\n    @Override\n    public ReportExec save(final ReportExec execution) {\n        return entityManager().merge(execution);\n    }\n\n<fim_suffix>    @Override\n    public void delete(final String key) {\n        ReportExec execution = find(key);\n        if (execution == null) {\n            return;\n        }\n\n        delete(execution);\n    }\n\n    @Override\n    public void delete(final ReportExec execution) {\n        if (execution.getReport() != null) {\n            execution.getReport().getExecs().remove(execution);\n        }\n\n        entityManager().remove(execution);\n    }\n}<fim_middle>// function below has no smell\n"}