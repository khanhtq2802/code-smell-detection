{"text": "<fim_prefix>import org.apache.flink.graph.Vertex;\nimport org.apache.flink.types.Either;\nimport org.apache.flink.types.NullValue;\nimport org.apache.flink.util.Collector;\n/**\n * The summarization algorithm computes a condensed version of the input graph\n * by grouping vertices and edges based on their values. By doing this, the\n * algorithm helps to uncover insights about patterns and distributions in the\n * graph.\n *\n * <p>In the resulting graph, each vertex represents a group of vertices that share the\n * same vertex value. An edge, that connects a vertex with itself, represents all edges\n * with the same edge value that connect vertices inside that group. An edge between\n * vertices in the output graph represents all edges with the same edge value between\n * members of those groups in the input graph.\n *\n * <p>Consider the following example:\n *\n * <p>Input graph:\n *\n * <pre>\n * Vertices (id, value):\n * (0, \"A\")\n * (1, \"A\")\n * (2, \"B\")\n * (3, \"B\")\n *\n * Edges (source, target, value):\n * (0,1, null)\n * (1,0, null)\n * (1,2, null)\n * (2,1, null)\n * (2,3, null)\n * (3,2, null)\n * </pre>\n *\n * <p>Output graph:\n *\n * <pre>Vertices (id, (value, count)):\n * (0, (\"A\", 2)) // 0 and 1\n * (2, (\"B\", 2)) // 2 and 3\n *\n * Edges (source, target, (value, count)):\n * (0, 0, (null, 2)) // (0,1) and (1,0)\n * (2, 2, (null, 2)) // (2,3) and (3,2)\n * (0, 2, (null, 1)) // (1,2)\n * (2, 0, (null, 1)) // (2,1)\n * </pre>\n *\n * <p>Note that this implementation is non-deterministic in the way that it assigns\n * identifiers to summarized vertices. However, it is guaranteed that the identifier\n * is one of the represented vertex identifiers.\n *\n * @param <K> \tvertex identifier type\n * @param <VV> \tvertex value type\n * @param <EV> \tedge value type\n */\npublic class Summarization<K, VV, EV>\n\t\timplements GraphAlgorithm<K, VV, EV,\n\t\tGraph<K, Summarization.VertexValue<VV>, Summarization.EdgeValue<EV>>> {\n\t@Override\n\tpublic Graph<K, VertexValue<VV>, EdgeValue<EV>> run(Graph<K, VV, EV> input) throws Exception {\n\t\t// -------------------------\n\t\t// build super vertices\n\t\t// -------------------------\n\t\t// group vertices by value and create vertex group items\n\t\tDataSet<VertexGroupItem<K, VV>> vertexGroupItems = input.getVertices()\n\t\t\t\t.groupBy(1)\n\t\t\t\t.reduceGroup(new VertexGroupReducer<>());\n\t\t// create super vertices\n\t\tDataSet<Vertex<K, VertexValue<VV>>> summarizedVertices = vertexGroupItems\n\t\t\t\t.filter(new VertexGroupItemToSummarizedVertexFilter<>())\n\t\t\t\t.map(new VertexGroupItemToSummarizedVertexMapper<>());\n\t\t// -------------------------\n\t\t// build super edges\n\t\t// -------------------------\n\t\t// create mapping between vertices and their representative\n\t\tDataSet<VertexWithRepresentative<K>> vertexToRepresentativeMap = vertexGroupItems\n\t\t\t.filter(new VertexGroupItemToRepresentativeFilter<>())\n\t\t\t.map(new VertexGroupItemToVertexWithRepresentativeMapper<>());\n\t\t// join edges with vertex representatives and update source and target identifiers\n\t\tDataSet<Edge<K, EV>> edgesForGrouping = input.getEdges()\n\t\t\t\t.join(vertexToRepresentativeMap)\n\t\t\t\t.where(0) \t// source vertex id\n\t\t\t\t.equalTo(0) // vertex id\n\t\t\t\t.with(new SourceVertexJoinFunction<>())\n\t\t\t\t.join(vertexToRepresentativeMap)\n\t\t\t\t.where(1) \t// target vertex id\n\t\t\t\t.equalTo(0) // vertex id\n\t\t\t\t.with(new TargetVertexJoinFunction<>());\n\t\t// create super edges\n\t\tDataSet<Edge<K, EdgeValue<EV>>> summarizedEdges = edgesForGrouping\n\t\t\t\t.groupBy(0, 1, 2) // group by source id (0), target id (1) and edge value (2)\n\t\t\t\t.reduceGroup(new EdgeGroupReducer<>());\n\t\treturn Graph.fromDataSet(summarizedVertices, summarizedEdges, input.getContext());\n\t}\n\t// --------------------------------------------------------------------------------------------\n\t//  Tuple Types\n\t// --------------------------------------------------------------------------------------------\n\t/**\n\t * Value that is stored at a summarized vertex.\n\t *\n\t * <pre>\n\t * f0: vertex group value\n\t * f1: vertex group count\n\t * </pre>\n\t *\n\t * @param <VV> vertex value type\n\t */\n\t@SuppressWarnings(\"serial\")\n\tpublic static final class VertexValue<VV> extends Tuple2<VV, Long> {\n\t\tpublic VV getVertexGroupValue() {\n\t\t\treturn f0;\n\t\t}\n\t\tpublic void setVertexGroupValue(VV vertexGroupValue) {\n\t\t\tf0 = vertexGroupValue;\n\t\t}\n\t\tpublic Long getVertexGroupCount() {\n\t\t\treturn f1;\n\t\t}\n\t\tpublic void setVertexGroupCount(Long vertexGroupCount) {\n\t\t\tf1 = vertexGroupCount;\n\t\t}\n\t}\n\t/**\n\t * Value that is stored at a summarized edge.\n\t *\n\t * <pre>\n\t * f0: edge group value\n\t * f1: edge group count\n\t * </pre>\n\t *\n\t * @param <EV> edge value type\n\t */\n\t@SuppressWarnings(\"serial\")\n\tpublic static final class EdgeValue<EV> extends Tuple2<EV, Long> {\n\t\tpublic EV getEdgeGroupValue() {\n\t\t\treturn f0;\n\t\t}\n\t\tpublic void setEdgeGroupValue(EV edgeGroupValue) {\n\t\t\tf0 = edgeGroupValue;\n\t\t}\n\t\tpublic Long getEdgeGroupCount() {\n\t\t\treturn f1;\n\t\t}\n\t\tpublic void setEdgeGroupCount(Long edgeGroupCount) {\n\t\t\tf1 = edgeGroupCount;\n\t\t}\n\t}\n\t/**\n\t * Represents a single vertex in a vertex group.\n\t *\n\t * <pre>\n\t * f0: vertex identifier\n\t * f1: vertex group representative identifier\n\t * f2: vertex group value\n\t * f3: vertex group count\n\t * </pre>\n\t *\n\t * @param <K> \tvertex identifier type\n\t * @param <VGV> vertex group value type\n\t */\n<fim_suffix>\t@SuppressWarnings(\"serial\")\n\tpublic static final class VertexGroupItem<K, VGV> extends Tuple4<K, K, Either<VGV, NullValue>, Long> {\n\t\tprivate final Either.Right<VGV, NullValue> nullValue = new Either.Right<>(NullValue.getInstance());\n\t\tpublic VertexGroupItem() {\n\t\t\treset();\n\t\t}\n\t\tpublic K getVertexId() {\n\t\t\treturn f0;\n\t\t}\n\t\tpublic void setVertexId(K vertexId) {\n\t\t\tf0 = vertexId;\n\t\t}\n\t\tpublic K getGroupRepresentativeId() {\n\t\t\treturn f1;\n\t\t}\n\t\tpublic void setGroupRepresentativeId(K groupRepresentativeId) {\n\t\t\tf1 = groupRepresentativeId;\n\t\t}\n\t\tpublic VGV getVertexGroupValue() {\n\t\t\treturn f2.isLeft() ? f2.left() : null;\n\t\t}\n\t\tpublic void setVertexGroupValue(VGV vertexGroupValue) {\n\t\t\tif (vertexGroupValue == null) {\n\t\t\t\tf2 = nullValue;\n\t\t\t} else {\n\t\t\t\tf2 = new Either.Left<>(vertexGroupValue);\n\t\t\t}\n\t\t}\n\t\tpublic Long getVertexGroupCount() {\n\t\t\treturn f3;\n\t\t}\n\t\tpublic void setVertexGroupCount(Long vertexGroupCount) {\n\t\t\tf3 = vertexGroupCount;\n\t\t}\n\t\t/**\n\t\t * Resets the fields to initial values. This is necessary if the tuples are reused and not all fields were modified.\n\t\t */\n\t\tpublic void reset() {\n\t\t\tf0 = null;\n\t\t\tf1 = null;\n\t\t\tf2 = nullValue;\n\t\t\tf3 = 0L;\n\t\t}\n\t}<fim_middle>// class below is data class\n"}