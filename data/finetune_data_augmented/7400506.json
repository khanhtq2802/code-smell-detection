{"text": "<fim_prefix>        CompilerAsserts.compilationConstant(states);\n        CompilerAsserts.compilationConstant(states.length);\n        if (!validArgs(frame)) {\n            CompilerDirectives.transferToInterpreter();\n            throw new IllegalArgumentException(String.format(\"Got illegal args! (fromIndex %d, initialIndex %d, maxIndex %d)\",\n                            getFromIndex(frame), getIndex(frame), getMaxIndex(frame)));\n        }\n        if (props.isTrackCaptureGroups()) {\n            createCGData(frame);\n            initResultOrder(frame);\n            setResultObject(frame, null);\n            setLastTransition(frame, (short) -1);\n        } else {\n            setResultInt(frame, TRegexDFAExecutorNode.NO_MATCH);\n        }\n        // check if input is long enough for a match\n        if (props.getMinResultLength() > 0 && (isForward() ? getMaxIndex(frame) - getIndex(frame) : getIndex(frame) - getMaxIndex(frame)) < props.getMinResultLength()) {\n            // no match possible, break immediately\n            return;\n        }\n        if (recordExecution()) {\n            debugRecorder.startRecording(frame, this);\n        }\n        if (isBackward() && getFromIndex(frame) - 1 > getMaxIndex(frame)) {\n            setCurMaxIndex(frame, getFromIndex(frame) - 1);\n        } else {\n            setCurMaxIndex(frame, getMaxIndex(frame));\n        }\n        int ip = 0;\n        outer: while (true) {\n            CompilerAsserts.partialEvaluationConstant(ip);\n            if (ip == -1) {\n                break;\n            }\n            final DFAAbstractStateNode curState = states[ip];\n            CompilerAsserts.partialEvaluationConstant(curState);\n            final short[] successors = curState.getSuccessors();\n            CompilerAsserts.partialEvaluationConstant(successors);\n            CompilerAsserts.partialEvaluationConstant(successors.length);\n            int prevIndex = getIndex(frame);\n            curState.executeFindSuccessor(frame, this, compactString);\n            if (recordExecution() && ip != 0) {\n                debugRecordTransition(frame, (DFAStateNode) curState, prevIndex);\n            }\n            for (int i = 0; i < successors.length; i++) {\n                if (i == getSuccessorIndex(frame)) {\n                    if (successors[i] != -1 && states[successors[i]] instanceof DFAStateNode) {\n                        ((DFAStateNode) states[successors[i]]).getStateReachedProfile().enter();\n                    }\n                    ip = successors[i];\n                    continue outer;\n                }\n            }\n            assert getSuccessorIndex(frame) == -1;\n            break;\n        }\n        if (recordExecution()) {\n            debugRecorder.finishRecording();\n        }\n    }\n    private void debugRecordTransition(VirtualFrame frame, DFAStateNode curState, int prevIndex) {\n        short ip = curState.getId();\n        boolean hasSuccessor = getSuccessorIndex(frame) != -1;\n        if (isForward()) {\n            for (int i = prevIndex; i < getIndex(frame) - (hasSuccessor ? 1 : 0); i++) {\n                if (curState.hasLoopToSelf()) {\n                    debugRecorder.recordTransition(i, ip, curState.getLoopToSelf());\n                }\n            }\n        } else {\n            for (int i = prevIndex; i > getIndex(frame) + (hasSuccessor ? 1 : 0); i--) {\n                if (curState.hasLoopToSelf()) {\n                    debugRecorder.recordTransition(i, ip, curState.getLoopToSelf());\n                }\n            }\n        }\n        if (hasSuccessor) {\n            debugRecorder.recordTransition(getIndex(frame) + (isForward() ? -1 : 1), ip, getSuccessorIndex(frame));\n        }\n    }\n    /**\n     * The index pointing into {@link #getInput(VirtualFrame)}.\n     *\n     * @param frame a virtual frame as described by {@link TRegexDFAExecutorProperties}.\n     * @return the current index of {@link #getInput(VirtualFrame)} that is being processed.\n     */\n    public int getIndex(VirtualFrame frame) {\n        return FrameUtil.getIntSafe(frame, props.getIndexFS());\n    }\n    public void setIndex(VirtualFrame frame, int i) {\n        frame.setInt(props.getIndexFS(), i);\n    }\n    /**\n     * The {@code fromIndex} argument given to\n     * {@link TRegexExecRootNode#execute(VirtualFrame, RegexObject, Object, int)}.\n     *\n     * @param frame a virtual frame as described by {@link TRegexDFAExecutorProperties}.\n     * @return the {@code fromIndex} argument given to\n     *         {@link TRegexExecRootNode#execute(VirtualFrame, RegexObject, Object, int)}.\n     */\n    public int getFromIndex(VirtualFrame frame) {\n        return FrameUtil.getIntSafe(frame, props.getFromIndexFS());\n    }\n    public void setFromIndex(VirtualFrame frame, int fromIndex) {\n        frame.setInt(props.getFromIndexFS(), fromIndex);\n    }\n    /**\n     * The maximum index as given by the parent {@link TRegexExecRootNode}.\n     *\n     * @param frame a virtual frame as described by {@link TRegexDFAExecutorProperties}.\n     * @return the maximum index as given by the parent {@link TRegexExecRootNode}.\n     */\n    public int getMaxIndex(VirtualFrame frame) {\n        return FrameUtil.getIntSafe(frame, props.getMaxIndexFS());\n    }\n    public void setMaxIndex(VirtualFrame frame, int maxIndex) {\n        frame.setInt(props.getMaxIndexFS(), maxIndex);\n    }\n    /**\n     * The maximum index as checked by {@link #hasNext(VirtualFrame)}. In most cases this value is\n     * equal to {@link #getMaxIndex(VirtualFrame)}, but backward matching nodes change this value\n     * while matching.\n     *\n     * @param frame a virtual frame as described by {@link TRegexDFAExecutorProperties}.\n     * @return the maximum index as checked by {@link #hasNext(VirtualFrame)}.\n     *\n     * @see BackwardDFAStateNode\n     */\n    public int getCurMaxIndex(VirtualFrame frame) {\n        return FrameUtil.getIntSafe(frame, props.getCurMaxIndexFS());\n    }\n    public void setCurMaxIndex(VirtualFrame frame, int value) {\n        frame.setInt(props.getCurMaxIndexFS(), value);\n    }\n    /**\n     * The {@code input} argument given to\n     * {@link TRegexExecRootNode#execute(VirtualFrame, RegexObject, Object, int)}.\n     *\n     * @param frame a virtual frame as described by {@link TRegexDFAExecutorProperties}.\n     * @return the {@code input} argument given to\n     *         {@link TRegexExecRootNode#execute(VirtualFrame, RegexObject, Object, int)}.\n     */\n    public Object getInput(VirtualFrame frame) {\n        return FrameUtil.getObjectSafe(frame, props.getInputFS());\n    }\n    public void setInput(VirtualFrame frame, Object input) {\n        frame.setObject(props.getInputFS(), input);\n    }\n    /**\n     * The length of the {@code input} argument given to\n     * {@link TRegexExecRootNode#execute(VirtualFrame, RegexObject, Object, int)}.\n     *\n     * @param frame a virtual frame as described by {@link TRegexDFAExecutorProperties}.\n     * @return the length of the {@code input} argument given to\n     *         {@link TRegexExecRootNode#execute(VirtualFrame, RegexObject, Object, int)}.\n     */\n    public int getInputLength(VirtualFrame frame) {\n        return lengthNode.execute(getInput(frame));\n    }\n    public char getChar(VirtualFrame frame) {\n        return charAtNode.execute(getInput(frame), getIndex(frame));\n    }\n    public void advance(VirtualFrame frame) {\n        setIndex(frame, props.isForward() ? getIndex(frame) + 1 : getIndex(frame) - 1);\n    }\n    public boolean hasNext(VirtualFrame frame) {\n        return props.isForward() ? Integer.compareUnsigned(getIndex(frame), getCurMaxIndex(frame)) < 0 : getIndex(frame) > getCurMaxIndex(frame);\n    }\n    public boolean atBegin(VirtualFrame frame) {\n        return getIndex(frame) == (props.isForward() ? 0 : getInputLength(frame) - 1);\n    }\n    public boolean atEnd(VirtualFrame frame) {\n        final int i = getIndex(frame);\n        if (props.isForward()) {\n            return i == getInputLength(frame);\n        } else {\n            return i < 0;\n        }\n    }\n<fim_suffix>    public int rewindUpTo(VirtualFrame frame, int length) {\n        if (props.isForward()) {\n            final int offset = Math.min(getIndex(frame), length);\n            setIndex(frame, getIndex(frame) - offset);\n            return offset;\n        } else {\n            assert length == 0;\n            return 0;\n        }\n    }<fim_middle>// function below has no smell\n"}