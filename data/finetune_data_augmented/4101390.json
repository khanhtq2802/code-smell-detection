{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.    \n */\npackage org.apache.bval.jsr;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.util.Set;\n\nimport javax.validation.ConstraintViolation;\nimport javax.validation.ValidationException;\nimport javax.validation.executable.ExecutableValidator;\nimport javax.validation.metadata.BeanDescriptor;\n\nimport org.apache.bval.jsr.job.ValidationJobFactory;\nimport org.apache.bval.util.Validate;\nimport org.apache.bval.util.reflection.Reflection;\n\npublic class ValidatorImpl implements CascadingPropertyValidator, ExecutableValidator {\n\n    private final ApacheFactoryContext validatorContext;\n    private final ValidationJobFactory validationJobFactory;\n\n    ValidatorImpl(ApacheFactoryContext validatorContext) {\n        super();\n        this.validatorContext = Validate.notNull(validatorContext, \"validatorContext\");\n        this.validationJobFactory = new ValidationJobFactory(validatorContext);\n    }\n\n    @Override\n    public BeanDescriptor getConstraintsForClass(Class<?> clazz) {\n        return validatorContext.getDescriptorManager().getBeanDescriptor(clazz);\n    }\n\n    @Override\n    public <T> Set<ConstraintViolation<T>> validate(T object, Class<?>... groups) {\n        return validationJobFactory.validateBean(object, groups).getResults();\n    }\n\n    @Override\n    public <T> Set<ConstraintViolation<T>> validateProperty(T object, String propertyName, boolean cascade,\n        Class<?>... groups) {\n        return validationJobFactory.validateProperty(object, propertyName, groups).cascade(cascade).getResults();\n    }\n\n    @Override\n    public <T> Set<ConstraintViolation<T>> validateValue(Class<T> beanType, String propertyName, Object value,\n        boolean cascade, Class<?>... groups) {\n        return validationJobFactory.validateValue(beanType, propertyName, value, groups).cascade(cascade).getResults();\n    }\n\n    @Override\n    public ExecutableValidator forExecutables() {\n        return this;\n    }\n\n<fim_suffix>    @Override\n    public <T> Set<ConstraintViolation<T>> validateParameters(T object, Method method, Object[] parameterValues,\n        Class<?>... groups) {\n        return validationJobFactory.validateParameters(object, method, parameterValues, groups).getResults();\n    }\n\n    @Override\n    public <T> Set<ConstraintViolation<T>> validateReturnValue(T object, Method method, Object returnValue,\n        Class<?>... groups) {\n        return validationJobFactory.validateReturnValue(object, method, returnValue, groups).getResults();\n    }\n\n    @Override\n    public <T> Set<ConstraintViolation<T>> validateConstructorParameters(Constructor<? extends T> constructor,\n        Object[] parameterValues, Class<?>... groups) {\n        return validationJobFactory.<T> validateConstructorParameters(constructor, parameterValues, groups)\n            .getResults();\n    }\n\n    @Override\n    public <T> Set<ConstraintViolation<T>> validateConstructorReturnValue(Constructor<? extends T> constructor,\n        T createdObject, Class<?>... groups) {\n        return validationJobFactory.<T> validateConstructorReturnValue(constructor, createdObject, groups).getResults();\n    }\n\n    @Override\n    public <T> T unwrap(Class<T> type) {\n        // FIXME 2011-03-27 jw:\n        // This code is unsecure.\n        // It should allow only a fixed set of classes.\n        // Can't fix this because don't know which classes this method should support.\n\n        if (type.isAssignableFrom(getClass())) {\n            @SuppressWarnings(\"unchecked\")\n            final T result = (T) this;\n            return result;\n        }\n        if (!(type.isInterface() || Modifier.isAbstract(type.getModifiers()))) {\n            return newInstance(type);\n        }\n        try {\n            final Class<?> cls = Reflection.toClass(type.getName() + \"Impl\");\n            if (type.isAssignableFrom(cls)) {\n                @SuppressWarnings(\"unchecked\")\n                final Class<? extends T> implClass = (Class<? extends T>) cls;\n                return newInstance(implClass);\n            }\n        } catch (ClassNotFoundException e) {\n        }\n        throw new ValidationException(\"Type \" + type + \" not supported\");\n    }\n\n    private <T> T newInstance(final Class<T> cls) {\n        final Constructor<T> cons = Reflection.getDeclaredConstructor(cls, ApacheFactoryContext.class);\n        if (cons == null) {\n            throw new ValidationException(\"Cannot instantiate \" + cls);\n        }\n        final boolean mustUnset = Reflection.setAccessible(cons, true);\n        try {\n            return cons.newInstance(validatorContext);\n        } catch (final Exception ex) {\n            throw new ValidationException(\"Cannot instantiate \" + cls, ex);\n        } finally {\n            if (mustUnset) {\n                Reflection.setAccessible(cons, false);\n            }\n        }\n    }\n}<fim_middle>// function below has no smell\n"}