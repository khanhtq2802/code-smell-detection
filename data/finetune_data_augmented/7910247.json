{"text": "<fim_prefix>/*\n * Copyright 2017-present Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License. You may obtain\n * a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\n\npackage com.facebook.buck.android.resources;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.ImmutableList;\nimport java.io.PrintStream;\nimport java.nio.ByteBuffer;\nimport java.util.List;\nimport java.util.Objects;\n\n/**\n * ResTableTypeSpec is a ResChunk specifying the flags for each resource of a given type. These\n * flags specify which types of configuration contain multiple values for a given resource. A\n * ResTableTypeSpec consists of: ResChunk_header u16 type u16 header_size u32 chunk_size u8 id u8\n * 0x00 u16 0x0000 u32 entry_count\n *\n * <p>This is then followed by entry_count u32s giving the flags for each resource of this type.\n *\n * <p>In practice, this is then followed by a ResTableType for each configuration that has resources\n * of this type. For convenience, those are considered to be part of the ResTableTypeSpec.\n */\npublic class ResTableTypeSpec extends ResChunk {\n  private static final int HEADER_SIZE = 16;\n\n  private final int id;\n  private final int entryCount;\n  private final List<ResTableType> configs;\n  private final int totalSize;\n  private final ByteBuffer entryFlags;\n\n  public static ResTableTypeSpec slice(ResTableTypeSpec spec, int count) {\n    ImmutableList<ResTableType> configs =\n        spec.getConfigs()\n            .stream()\n            .map(config -> ResTableType.slice(config, count))\n            .filter(Objects::nonNull)\n            .collect(ImmutableList.toImmutableList());\n\n    return new ResTableTypeSpec(\n        spec.id, count, copy(slice(spec.entryFlags, 0, 4 * count)), configs);\n  }\n\n  @Override\n  public void put(ByteBuffer output) {\n    Preconditions.checkState(output.remaining() >= totalSize);\n    int start = output.position();\n    putChunkHeader(output);\n    output.put((byte) (id + 1));\n    output.put((byte) 0);\n    output.putShort((short) 0);\n    output.putInt(entryCount);\n    output.put(slice(entryFlags, 0));\n    configs.forEach(c -> c.put(output));\n    Preconditions.checkState(output.position() == start + totalSize);\n  }\n\n  public static ResTableTypeSpec get(ByteBuffer buf) {\n    int type = buf.getShort();\n    int headerSize = buf.getShort();\n    int chunkSize = buf.getInt();\n    int id = (buf.get() & 0xFF) - 1;\n    buf.get();\n    buf.getShort();\n    int entryCount = buf.getInt();\n    // ignored u8\n    // ignored u16\n    Preconditions.checkState(type == CHUNK_RES_TABLE_TYPE_SPEC);\n    Preconditions.checkState(headerSize == HEADER_SIZE);\n    Preconditions.checkState(chunkSize == HEADER_SIZE + 4 * entryCount);\n\n    return new ResTableTypeSpec(\n        id,\n        entryCount,\n        slice(buf, HEADER_SIZE, 4 * entryCount),\n        getConfigsFromBuffer(slice(buf, chunkSize)));\n  }\n\n  private ResTableTypeSpec(\n      int id, int entryCount, ByteBuffer entryFlags, List<ResTableType> configs) {\n    super(CHUNK_RES_TABLE_TYPE_SPEC, HEADER_SIZE, HEADER_SIZE + 4 * entryCount);\n    this.id = id;\n    this.entryCount = entryCount;\n    this.entryFlags = entryFlags;\n    this.configs = configs;\n    int configsSize = 0;\n    for (ResTableType config : configs) {\n      Preconditions.checkState(getResourceType() == config.getResourceType());\n      configsSize += config.getChunkSize();\n    }\n    this.totalSize = getChunkSize() + configsSize;\n  }\n\n  private static List<ResTableType> getConfigsFromBuffer(ByteBuffer buf) {\n    ImmutableList.Builder<ResTableType> configs = ImmutableList.builder();\n    while (buf.position() < buf.limit() && buf.getShort(buf.position()) == 0x201) {\n      ResTableType config = ResTableType.get(slice(buf, buf.position()));\n      configs.add(config);\n      buf.position(buf.position() + config.getChunkSize());\n    }\n    return configs.build();\n  }\n\n  @Override\n  public int getTotalSize() {\n    return totalSize;\n  }\n\n  String getResourceName(ResTablePackage resPackage, int id) {\n    // We need to find an actual entry in one of the configs to find the name of this resource.\n    for (ResTableType t : configs) {\n      int refId = t.getResourceRef(id);\n      if (refId >= 0) {\n        return resPackage.getKeys().getString(refId);\n      }\n    }\n    throw new RuntimeException();\n  }\n\n  public String getResourceTypeName(ResTablePackage resPackage) {\n    return resPackage.getTypes().getString(id);\n  }\n\n  public void dump(StringPool strings, ResTablePackage resPackage, PrintStream out) {\n    if (entryCount == 0) {\n      return;\n    }\n    out.format(\"    type %d configCount=%d entryCount=%d\\n\", id, configs.size(), entryCount);\n    for (int i = 0; i < entryCount; i++) {\n      out.format(\n          \"      spec resource 0x7f%02x%04x %s:%s/%s: flags=0x%08x\\n\",\n          getResourceType(),\n          i,\n          resPackage.getPackageName(),\n          getResourceTypeName(resPackage),\n          getResourceName(resPackage, i),\n          entryFlags.getInt(i * 4));\n    }\n    for (ResTableType type : configs) {\n      type.dump(strings, resPackage, out);\n    }\n  }\n\n  public int getResourceType() {\n    return id + 1;\n  }\n\n  public List<ResTableType> getConfigs() {\n    return configs;\n  }\n\n<fim_suffix>  public void transformKeyReferences(RefTransformer visitor) {\n    configs.forEach(c -> c.transformKeyReferences(visitor));\n  }\n\n  public void visitKeyReferences(RefVisitor visitor) {\n    configs.forEach(c -> c.visitKeyReferences(visitor));\n  }\n\n  public void transformStringReferences(RefTransformer visitor) {\n    configs.forEach(c -> c.transformStringReferences(visitor));\n  }\n\n  public void visitStringReferences(RefVisitor visitor) {\n    configs.forEach(c -> c.visitStringReferences(visitor));\n  }\n\n  public void visitStringReferences(int[] ids, RefVisitor visitor) {\n    configs.forEach(c -> c.visitStringReferences(ids, visitor));\n  }\n\n  public void visitReferences(int[] ids, RefVisitor visitor) {\n    configs.forEach(c -> c.visitReferences(ids, visitor));\n  }\n\n  public void reassignIds(ReferenceMapper refMapping) {\n    refMapping.rewrite(getResourceType(), entryFlags.asIntBuffer());\n    configs.forEach(c -> c.reassignIds(refMapping));\n  }\n\n  public int getEntryCount() {\n    return entryCount;\n  }\n}<fim_middle>// function below has no smell\n"}