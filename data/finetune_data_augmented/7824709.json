{"text": "<fim_prefix>\n<fim_suffix>public class LuceneIndexForPartitionedRegion extends LuceneIndexImpl {\n  protected Region fileAndChunkRegion;\n  protected final FileSystemStats fileSystemStats;\n  public static final String FILES_REGION_SUFFIX = \".files\";\n  private final ExecutorService waitingThreadPoolFromDM;\n  public LuceneIndexForPartitionedRegion(String indexName, String regionPath, InternalCache cache) {\n    super(indexName, regionPath, cache);\n    this.waitingThreadPoolFromDM = cache.getDistributionManager().getWaitingThreadPool();\n    final String statsName = indexName + \"-\" + regionPath;\n    this.fileSystemStats = new FileSystemStats(cache.getDistributedSystem(), statsName);\n  }\n  @Override\n  protected RepositoryManager createRepositoryManager(LuceneSerializer luceneSerializer) {\n    LuceneSerializer mapper = luceneSerializer;\n    if (mapper == null) {\n      mapper = new HeterogeneousLuceneSerializer();\n    }\n    PartitionedRepositoryManager partitionedRepositoryManager =\n        new PartitionedRepositoryManager(this, mapper, this.waitingThreadPoolFromDM);\n    return partitionedRepositoryManager;\n  }\n  @Override\n  public boolean isIndexingInProgress() {\n    PartitionedRegion userRegion = (PartitionedRegion) cache.getRegion(this.getRegionPath());\n    Set<Integer> fileRegionPrimaryBucketIds =\n        this.getFileAndChunkRegion().getDataStore().getAllLocalPrimaryBucketIds();\n    for (Integer bucketId : fileRegionPrimaryBucketIds) {\n      BucketRegion userBucket = userRegion.getDataStore().getLocalBucketById(bucketId);\n      if (!userBucket.isEmpty() && !this.isIndexAvailable(bucketId)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  @Override\n  protected void createLuceneListenersAndFileChunkRegions(\n      PartitionedRepositoryManager partitionedRepositoryManager) {\n    partitionedRepositoryManager.setUserRegionForRepositoryManager((PartitionedRegion) dataRegion);\n    RegionShortcut regionShortCut;\n    final boolean withPersistence = withPersistence();\n    RegionAttributes regionAttributes = dataRegion.getAttributes();\n    final boolean withStorage = regionAttributes.getPartitionAttributes().getLocalMaxMemory() > 0;\n    // TODO: 1) dataRegion should be withStorage\n    // 2) Persistence to Persistence\n    // 3) Replicate to Replicate, Partition To Partition\n    // 4) Offheap to Offheap\n    if (!withStorage) {\n      regionShortCut = RegionShortcut.PARTITION_PROXY;\n    } else if (withPersistence) {\n      // TODO: add PartitionedRegionAttributes instead\n      regionShortCut = RegionShortcut.PARTITION_PERSISTENT;\n    } else {\n      regionShortCut = RegionShortcut.PARTITION;\n    }\n    // create PR fileAndChunkRegion, but not to create its buckets for now\n    final String fileRegionName = createFileRegionName();\n    PartitionAttributes partitionAttributes = dataRegion.getPartitionAttributes();\n    DistributionManager dm = this.cache.getInternalDistributedSystem().getDistributionManager();\n    LuceneBucketListener lucenePrimaryBucketListener =\n        new LuceneBucketListener(partitionedRepositoryManager, dm);\n    if (!fileRegionExists(fileRegionName)) {\n      fileAndChunkRegion = createRegion(fileRegionName, regionShortCut, this.regionPath,\n          partitionAttributes, regionAttributes, lucenePrimaryBucketListener);\n    }\n    fileSystemStats\n        .setBytesSupplier(() -> getFileAndChunkRegion().getPrStats().getDataStoreBytesInUse());\n  }\n  public PartitionedRegion getFileAndChunkRegion() {\n    return (PartitionedRegion) fileAndChunkRegion;\n  }\n  public FileSystemStats getFileSystemStats() {\n    return fileSystemStats;\n  }\n  boolean fileRegionExists(String fileRegionName) {\n    return cache.getRegion(fileRegionName) != null;\n  }\n  public String createFileRegionName() {\n    return LuceneServiceImpl.getUniqueIndexRegionName(indexName, regionPath, FILES_REGION_SUFFIX);\n  }\n  private PartitionAttributesFactory configureLuceneRegionAttributesFactory(\n      PartitionAttributesFactory attributesFactory,\n      PartitionAttributes<?, ?> dataRegionAttributes) {\n    attributesFactory.setTotalNumBuckets(dataRegionAttributes.getTotalNumBuckets());\n    attributesFactory.setRedundantCopies(dataRegionAttributes.getRedundantCopies());\n    attributesFactory.setPartitionResolver(getPartitionResolver(dataRegionAttributes));\n    attributesFactory.setRecoveryDelay(dataRegionAttributes.getRecoveryDelay());\n    attributesFactory.setStartupRecoveryDelay(dataRegionAttributes.getStartupRecoveryDelay());\n    return attributesFactory;\n  }\n  private PartitionResolver getPartitionResolver(PartitionAttributes dataRegionAttributes) {\n    if (dataRegionAttributes.getPartitionResolver() instanceof FixedPartitionResolver) {\n      return new BucketTargetingFixedResolver();\n    } else {\n      return new BucketTargetingResolver();\n    }\n  }\n  protected <K, V> Region<K, V> createRegion(final String regionName,\n      final RegionShortcut regionShortCut, final String colocatedWithRegionName,\n      final PartitionAttributes partitionAttributes, final RegionAttributes regionAttributes,\n      PartitionListener lucenePrimaryBucketListener) {\n    PartitionAttributesFactory partitionAttributesFactory = new PartitionAttributesFactory();\n    if (lucenePrimaryBucketListener != null) {\n      partitionAttributesFactory.addPartitionListener(lucenePrimaryBucketListener);\n    }\n    partitionAttributesFactory.setColocatedWith(colocatedWithRegionName);\n    configureLuceneRegionAttributesFactory(partitionAttributesFactory, partitionAttributes);\n    // Create AttributesFactory based on input RegionShortcut\n    RegionAttributes baseAttributes = this.cache.getRegionAttributes(regionShortCut.toString());\n    AttributesFactory factory = new AttributesFactory(baseAttributes);\n    factory.setPartitionAttributes(partitionAttributesFactory.create());\n    if (regionAttributes.getDataPolicy().withPersistence()) {\n      factory.setDiskStoreName(regionAttributes.getDiskStoreName());\n    }\n    RegionAttributes<K, V> attributes = factory.create();\n    return createRegion(regionName, attributes);\n  }\n  public void close() {}\n  @Override\n  public void dumpFiles(final String directory) {\n    ResultCollector results = FunctionService.onRegion(getDataRegion())\n        .setArguments(new String[] {directory, indexName}).execute(DumpDirectoryFiles.ID);\n    results.getResult();\n  }\n  @Override\n  public void destroy(boolean initiator) {\n    if (logger.isDebugEnabled()) {\n      logger.debug(\"Destroying index regionPath=\" + regionPath + \"; indexName=\" + indexName\n          + \"; initiator=\" + initiator);\n    }\n    // Invoke super destroy to remove the extension and async event queue\n    super.destroy(initiator);\n    // Destroy index on remote members if necessary\n    if (initiator) {\n      destroyOnRemoteMembers();\n    }\n    // Destroy the file region (colocated with the application region) if necessary\n    // localDestroyRegion can't be used because locally destroying regions is not supported on\n    // colocated regions\n    if (initiator) {\n      try {\n        fileAndChunkRegion.destroyRegion();\n        if (logger.isDebugEnabled()) {\n          logger.debug(\"Destroyed fileAndChunkRegion=\" + fileAndChunkRegion.getName());\n        }\n      } catch (RegionDestroyedException e) {\n        if (logger.isDebugEnabled()) {\n          logger.debug(\"Already destroyed fileAndChunkRegion=\" + fileAndChunkRegion.getName());\n        }\n      }\n    }\n    if (logger.isDebugEnabled()) {\n      logger.debug(\"Destroyed index regionPath=\" + regionPath + \"; indexName=\" + indexName\n          + \"; initiator=\" + initiator);\n    }\n  }\n  @Override\n  public boolean isIndexAvailable(int id) {\n    PartitionedRegion fileAndChunkRegion = getFileAndChunkRegion();\n    return (fileAndChunkRegion.get(IndexRepositoryFactory.APACHE_GEODE_INDEX_COMPLETE, id) != null\n        || !LuceneServiceImpl.LUCENE_REINDEX);\n  }\n  private void destroyOnRemoteMembers() {\n    DistributionManager dm = getDataRegion().getDistributionManager();\n    Set<InternalDistributedMember> recipients = dm.getOtherNormalDistributionManagerIds();\n    if (!recipients.isEmpty()) {\n      if (logger.isDebugEnabled()) {\n        logger.debug(\"LuceneIndexForPartitionedRegion: About to send destroy message recipients=\"\n            + recipients);\n      }\n      ReplyProcessor21 processor = new ReplyProcessor21(dm, recipients);\n      DestroyLuceneIndexMessage message = new DestroyLuceneIndexMessage(recipients,\n          processor.getProcessorId(), regionPath, indexName);\n      dm.putOutgoing(message);\n      if (logger.isDebugEnabled()) {\n        logger.debug(\"LuceneIndexForPartitionedRegion: Sent message recipients=\" + recipients);\n      }\n      try {\n        processor.waitForReplies();\n      } catch (ReplyException e) {\n        Throwable cause = e.getCause();\n        if (cause instanceof IllegalArgumentException) {\n          // If the IllegalArgumentException is index not found, then its ok; otherwise rethrow it.\n          String fullRegionPath =\n              regionPath.startsWith(Region.SEPARATOR) ? regionPath : Region.SEPARATOR + regionPath;\n          String indexNotFoundMessage = String.format(\"Lucene index %s was not found in region %s\",\n              indexName, fullRegionPath);\n          if (!cause.getLocalizedMessage().equals(indexNotFoundMessage)) {\n            throw e;\n          }\n        } else if (!(cause instanceof CancelException)) {\n          throw e;\n        }<fim_middle>// class below is blob\n"}