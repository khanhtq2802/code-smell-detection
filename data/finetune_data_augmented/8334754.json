{"text": "<fim_prefix>/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved. \n * This program and the accompanying materials are made available \n * under the terms of the Eclipse Public License v1.0 \n * which accompanies this distribution and is available at \n * http://www.eclipse.org/legal/epl-v10.html \n *  \n * Contributors: \n *     PARC     initial implementation \n * ******************************************************************/\n\npackage org.aspectj.weaver.patterns;\n\nimport java.io.IOException;\nimport java.util.Map;\n\nimport org.aspectj.weaver.CompressingDataOutputStream;\nimport org.aspectj.weaver.ISourceContext;\nimport org.aspectj.weaver.ResolvedType;\nimport org.aspectj.weaver.UnresolvedType;\nimport org.aspectj.weaver.VersionedDataInputStream;\nimport org.aspectj.weaver.World;\n\npublic class ThrowsPattern extends PatternNode {\n\tprivate TypePatternList required;\n\tprivate TypePatternList forbidden;\n\n\tpublic static final ThrowsPattern ANY = new ThrowsPattern(TypePatternList.EMPTY, TypePatternList.EMPTY);\n\n\tpublic ThrowsPattern(TypePatternList required, TypePatternList forbidden) {\n\t\tthis.required = required;\n\t\tthis.forbidden = forbidden;\n\t}\n\n\tpublic TypePatternList getRequired() {\n\t\treturn required;\n\t}\n\n\tpublic TypePatternList getForbidden() {\n\t\treturn forbidden;\n\t}\n\n\tpublic String toString() {\n\t\tif (this == ANY) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tString ret = \"throws \" + required.toString();\n\t\tif (forbidden.size() > 0) {\n\t\t\tret = ret + \" !(\" + forbidden.toString() + \")\";\n\t\t}\n\t\treturn ret;\n\t}\n\n<fim_suffix>\tpublic boolean equals(Object other) {\n\t\tif (!(other instanceof ThrowsPattern)) {\n\t\t\treturn false;\n\t\t}\n\t\tThrowsPattern o = (ThrowsPattern) other;\n\t\tboolean ret = o.required.equals(this.required) && o.forbidden.equals(this.forbidden);\n\t\treturn ret;\n\t}\n\n\tpublic int hashCode() {\n\t\tint result = 17;\n\t\tresult = 37 * result + required.hashCode();\n\t\tresult = 37 * result + forbidden.hashCode();\n\t\treturn result;\n\t}\n\n\tpublic ThrowsPattern resolveBindings(IScope scope, Bindings bindings) {\n\t\tif (this == ANY) {\n\t\t\treturn this;\n\t\t}\n\t\trequired = required.resolveBindings(scope, bindings, false, false);\n\t\tforbidden = forbidden.resolveBindings(scope, bindings, false, false);\n\t\treturn this;\n\t}\n\n\tpublic ThrowsPattern parameterizeWith(Map<String,UnresolvedType> typeVariableMap, World w) {\n\t\tThrowsPattern ret = new ThrowsPattern(required.parameterizeWith(typeVariableMap, w), forbidden.parameterizeWith(\n\t\t\t\ttypeVariableMap, w));\n\t\tret.copyLocationFrom(this);\n\t\treturn ret;\n\t}\n\n\tpublic boolean matches(UnresolvedType[] tys, World world) {\n\t\tif (this == ANY) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// System.out.println(\"matching: \" + this + \" with \" + Arrays.asList(tys));\n\n\t\tResolvedType[] types = world.resolve(tys);\n\t\t// int len = types.length;\n\t\tfor (int j = 0, lenj = required.size(); j < lenj; j++) {\n\t\t\tif (!matchesAny(required.get(j), types)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0, lenj = forbidden.size(); j < lenj; j++) {\n\t\t\tif (matchesAny(forbidden.get(j), types)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tprivate boolean matchesAny(TypePattern typePattern, ResolvedType[] types) {\n\t\tfor (int i = types.length - 1; i >= 0; i--) {\n\t\t\tif (typePattern.matchesStatically(types[i])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static ThrowsPattern read(VersionedDataInputStream s, ISourceContext context) throws IOException {\n\t\tTypePatternList required = TypePatternList.read(s, context);\n\t\tTypePatternList forbidden = TypePatternList.read(s, context);\n\t\tif (required.size() == 0 && forbidden.size() == 0) {\n\t\t\treturn ANY;\n\t\t}\n\t\tThrowsPattern ret = new ThrowsPattern(required, forbidden);\n\t\t// XXXret.readLocation(context, s);\n\t\treturn ret;\n\t}\n\n\tpublic void write(CompressingDataOutputStream s) throws IOException {\n\t\trequired.write(s);\n\t\tforbidden.write(s);\n\t\t// XXXwriteLocation(s);\n\t}\n\n\tpublic Object accept(PatternNodeVisitor visitor, Object data) {\n\t\treturn visitor.visit(this, data);\n\t}\n\n\tpublic Object traverse(PatternNodeVisitor visitor, Object data) {\n\t\tObject ret = accept(visitor, data);\n\t\tforbidden.traverse(visitor, data);\n\t\trequired.traverse(visitor, data);\n\t\treturn ret;\n\t}\n}<fim_middle>// function below has no smell\n"}