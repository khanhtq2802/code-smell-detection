{"text": "<fim_prefix>/*\n * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage org.graalvm.compiler.truffle.runtime;\n\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport org.graalvm.collections.EconomicMap;\nimport org.graalvm.collections.UnmodifiableEconomicMap;\nimport org.graalvm.compiler.truffle.common.TruffleCompilerRuntime;\nimport org.graalvm.compiler.truffle.common.SharedTruffleOptions;\nimport org.graalvm.options.OptionDescriptor;\nimport org.graalvm.options.OptionDescriptors;\nimport org.graalvm.options.OptionKey;\nimport org.graalvm.options.OptionValues;\n\nimport jdk.vm.ci.common.NativeImageReinitialize;\n\n/**\n * Helpers to read and overwrite values of Truffle runtime options. The options themselves are\n * declared in {@link SharedTruffleRuntimeOptions}.\n */\n@SharedTruffleOptions(name = \"SharedTruffleRuntimeOptions\", runtime = true)\npublic final class TruffleRuntimeOptions {\n\n    private TruffleRuntimeOptions() {\n        throw new IllegalStateException(\"No instance allowed.\");\n    }\n\n<fim_suffix>    static class Lazy {\n        static final ThreadLocal<TruffleRuntimeOptionsOverrideScope> overrideScope = new ThreadLocal<>();\n    }\n\n    @NativeImageReinitialize private static volatile OptionValuesImpl optionValues;\n\n    private static OptionValuesImpl getInitialOptions() {\n        OptionValuesImpl result = optionValues;\n        if (result == null) {\n            final EconomicMap<OptionKey<?>, Object> valuesMap = EconomicMap.create();\n            final OptionDescriptors descriptors = new SharedTruffleRuntimeOptionsOptionDescriptors();\n            for (Map.Entry<String, Object> e : TruffleCompilerRuntime.getRuntime().getOptions().entrySet()) {\n                final OptionDescriptor descriptor = descriptors.get(e.getKey());\n                final OptionKey<?> k = descriptor != null ? descriptor.getKey() : null;\n                if (k != null) {\n                    valuesMap.put(k, e.getValue());\n                }\n            }\n            result = new OptionValuesImpl(descriptors, valuesMap);\n            optionValues = result;\n        }\n        return result;\n    }\n\n    /**\n     * Gets the object holding the values of Truffle options, taking into account any active\n     * {@linkplain #overrideOptions(OptionKey, Object, Object...) overrides}.\n     */\n    public static OptionValues getOptions() {\n        TruffleRuntimeOptionsOverrideScope scope = Lazy.overrideScope.get();\n        return scope != null ? scope.options : getInitialOptions();\n    }\n\n    /**\n     * Gets the options defined in the current option\n     * {@linkplain #overrideOptions(OptionKey, Object, Object...) override} scope or {@code null} if\n     * there is no override scope active for the current thread.\n     */\n    public static OptionValues getCurrentOptionOverrides() {\n        TruffleRuntimeOptionsOverrideScope scope = Lazy.overrideScope.get();\n        return scope != null ? scope.options : null;\n    }\n\n    public static Map<String, Object> asMap(OptionValues values) {\n        if (values == null) {\n            return Collections.emptyMap();\n        }\n        final Map<String, Object> m = new HashMap<>();\n        for (OptionDescriptor desc : values.getDescriptors()) {\n            final OptionKey<?> key = desc.getKey();\n            if (values.hasBeenSet(key)) {\n                m.put(desc.getName(), values.get(key));\n            }\n        }\n        return m;\n    }\n\n    public static class TruffleRuntimeOptionsOverrideScope implements AutoCloseable {\n        private final TruffleRuntimeOptionsOverrideScope outer;\n        private final OptionValuesImpl options;\n\n        TruffleRuntimeOptionsOverrideScope(UnmodifiableEconomicMap<OptionKey<?>, Object> overrides) {\n            outer = Lazy.overrideScope.get();\n            options = new OptionValuesImpl(outer == null ? getInitialOptions() : outer.options, overrides);\n            Lazy.overrideScope.set(this);\n        }\n\n        @Override\n        public void close() {\n            Lazy.overrideScope.set(outer);\n        }\n    }\n\n    /**\n     * Gets the value of a given Truffle option key taking into account any active\n     * {@linkplain #overrideOptions overrides}.\n     */\n    public static <T> T getValue(OptionKey<T> key) {\n        return key.getValue(getOptions());\n    }\n\n    public static TruffleRuntimeOptionsOverrideScope overrideOptions(final OptionValues values) {\n        return new TruffleRuntimeOptionsOverrideScope(asEconomicMap(values));\n    }\n\n    public static TruffleRuntimeOptionsOverrideScope overrideOptions(OptionKey<?> key1, Object value1, Object... extraOverrides) {\n        final EconomicMap<OptionKey<?>, Object> map = EconomicMap.create();\n        map.put(key1, value1);\n        if ((extraOverrides.length & 1) == 1) {\n            throw new IllegalArgumentException(\"extraOverrides.length must be even: \" + extraOverrides.length);\n        }\n        for (int i = 0; i < extraOverrides.length; i += 2) {\n            map.put((OptionKey<?>) extraOverrides[i], extraOverrides[i + 1]);\n        }\n        return new TruffleRuntimeOptionsOverrideScope(map);\n    }\n\n    private static EconomicMap<OptionKey<?>, Object> asEconomicMap(final OptionValues values) {\n        final EconomicMap<OptionKey<?>, Object> map = EconomicMap.create();\n        for (OptionDescriptor desc : values.getDescriptors()) {\n            final OptionKey<?> key = desc.getKey();\n            if (optionValues.hasBeenSet(key)) {\n                map.put(key, optionValues.get(key));\n            }\n        }\n        return map;\n    }\n\n    /**\n     * Determines whether an exception during a Truffle compilation should result in calling\n     * {@link System#exit(int)}.\n     */\n    public static boolean areTruffleCompilationExceptionsFatal() {\n        /*\n         * Automatically enable TruffleCompilationExceptionsAreFatal when asserts are enabled but\n         * respect TruffleCompilationExceptionsAreFatal if it's been explicitly set.\n         */\n        boolean truffleCompilationExceptionsAreFatal = getValue(SharedTruffleRuntimeOptions.TruffleCompilationExceptionsAreFatal);\n        assert SharedTruffleRuntimeOptions.TruffleCompilationExceptionsAreFatal.hasBeenSet(TruffleRuntimeOptions.getOptions()) || (truffleCompilationExceptionsAreFatal = true) == true;\n        return truffleCompilationExceptionsAreFatal || TruffleRuntimeOptions.getValue(SharedTruffleRuntimeOptions.TrufflePerformanceWarningsAreFatal);\n    }\n}<fim_middle>// class below has no smell\n"}