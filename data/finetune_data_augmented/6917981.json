{"text": "<fim_prefix>// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\npackage com.google.gitiles;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Preconditions.checkState;\nimport static java.util.Comparator.comparing;\nimport static java.util.stream.Collectors.toList;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Iterables;\nimport com.google.common.collect.Sets;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport javax.annotation.Nullable;\nimport javax.servlet.http.HttpServletRequest;\nimport org.eclipse.jgit.diff.DiffEntry;\nimport org.eclipse.jgit.diff.DiffFormatter;\nimport org.eclipse.jgit.http.server.ServletUtils;\nimport org.eclipse.jgit.lib.AbbreviatedObjectId;\nimport org.eclipse.jgit.lib.AnyObjectId;\nimport org.eclipse.jgit.lib.Constants;\nimport org.eclipse.jgit.lib.ObjectId;\nimport org.eclipse.jgit.lib.ObjectReader;\nimport org.eclipse.jgit.lib.PersonIdent;\nimport org.eclipse.jgit.lib.Ref;\nimport org.eclipse.jgit.lib.Repository;\nimport org.eclipse.jgit.revwalk.RevCommit;\nimport org.eclipse.jgit.revwalk.RevWalk;\nimport org.eclipse.jgit.treewalk.AbstractTreeIterator;\nimport org.eclipse.jgit.treewalk.CanonicalTreeParser;\nimport org.eclipse.jgit.treewalk.EmptyTreeIterator;\nimport org.eclipse.jgit.util.io.NullOutputStream;\n/** Format-independent data about a single commit. */\nclass CommitData {\n  enum Field {\n    ABBREV_SHA,\n    ARCHIVE_TYPE,\n    ARCHIVE_URL,\n    AUTHOR,\n    BRANCHES,\n    COMMITTER,\n    DIFF_TREE,\n    LOG_URL,\n    MESSAGE,\n    PARENTS,\n    PARENT_BLAME_URL,\n    SHA,\n    SHORT_MESSAGE,\n    TAGS,\n    TREE,\n    TREE_URL,\n    URL;\n    static ImmutableSet<Field> setOf(Iterable<Field> base, Field... fields) {\n      return Sets.immutableEnumSet(Iterables.concat(base, Arrays.asList(fields)));\n    }\n  }\n  static class DiffList {\n    Revision revision;\n    Revision oldRevision;\n    List<DiffEntry> entries;\n  }\n  static class Builder {\n    private ArchiveFormat archiveFormat;\n    private Map<AnyObjectId, Set<Ref>> refsById;\n    Builder setArchiveFormat(@Nullable ArchiveFormat archiveFormat) {\n      this.archiveFormat = archiveFormat;\n      return this;\n    }\n    CommitData build(HttpServletRequest req, RevWalk walk, RevCommit c, Set<Field> fs)\n        throws IOException {\n      checkFields(fs);\n      checkNotNull(req, \"request\");\n      checkNotNull(walk, \"walk\");\n      Repository repo = ServletUtils.getRepository(req);\n      GitilesView view = ViewFilter.getView(req);\n      CommitData result = new CommitData();\n      if (fs.contains(Field.AUTHOR)) {\n        walk.parseBody(c);\n        result.author = c.getAuthorIdent();\n      }\n      if (fs.contains(Field.COMMITTER)) {\n        walk.parseBody(c);\n        result.committer = c.getCommitterIdent();\n      }\n      if (fs.contains(Field.SHA)) {\n        result.sha = c.copy();\n      }\n      if (fs.contains(Field.ABBREV_SHA)) {\n        try (ObjectReader reader = repo.getObjectDatabase().newReader()) {\n          result.abbrev = reader.abbreviate(c);\n        }\n      }\n      if (fs.contains(Field.URL)) {\n        result.url = GitilesView.revision().copyFrom(view).setRevision(c).toUrl();\n      }\n      if (fs.contains(Field.LOG_URL)) {\n        result.logUrl = urlFromView(view, c, GitilesView.log());\n      }\n      if (fs.contains(Field.ARCHIVE_URL)) {\n        result.archiveUrl =\n            urlFromView(\n                view, c, GitilesView.archive().setExtension(archiveFormat.getDefaultSuffix()));\n      }\n      if (fs.contains(Field.ARCHIVE_TYPE)) {\n        result.archiveType = archiveFormat;\n      }\n      if (fs.contains(Field.TREE)) {\n        result.tree = c.getTree().copy();\n      }\n      if (fs.contains(Field.TREE_URL)) {\n        // Tree always implies the root tree.\n        result.treeUrl = GitilesView.path().copyFrom(view).setPathPart(\"/\").toUrl();\n      }\n      if (fs.contains(Field.PARENTS)) {\n        result.parents = Arrays.asList(c.getParents());\n      }\n      if (fs.contains(Field.BRANCHES)) {\n        result.branches = getRefsById(repo, c, Constants.R_HEADS);\n      }\n      if (fs.contains(Field.TAGS)) {\n        result.tags = getRefsById(repo, c, Constants.R_TAGS);\n      }\n      if (fs.contains(Field.MESSAGE)) {\n        walk.parseBody(c);\n        result.message = c.getFullMessage();\n      }\n      if (fs.contains(Field.SHORT_MESSAGE)) {\n        walk.parseBody(c);\n        String msg = c.getShortMessage();\n        if (msg.length() > 80) {\n          String ft = result.message;\n          if (ft == null) {\n            ft = c.getFullMessage();\n          }\n          int lf = ft.indexOf('\\n');\n          if (lf > 0) {\n            msg = ft.substring(0, lf);\n          }\n        }\n        result.shortMessage = msg;\n      }\n      if (fs.contains(Field.DIFF_TREE)) {\n        result.diffEntries = computeDiffEntries(repo, view, walk, c);\n      }\n      return result;\n    }\n    private void checkFields(Set<Field> fs) {\n      if (fs.contains(Field.ARCHIVE_URL) || fs.contains(Field.ARCHIVE_TYPE)) {\n        checkState(archiveFormat != null, \"archive format required\");\n      }\n    }\n    private static String urlFromView(\n        GitilesView view, RevCommit commit, GitilesView.Builder builder) {\n      Revision rev = view.getRevision();\n      return builder\n          .copyFrom(view)\n          .setOldRevision(Revision.NULL)\n          .setRevision(rev.getId().equals(commit) ? rev.getName() : commit.name(), commit)\n          .setPathPart(view.getPathPart())\n          .toUrl();\n    }\n    private List<Ref> getRefsById(Repository repo, ObjectId id, String prefix) {\n      if (refsById == null) {\n        refsById = repo.getAllRefsByPeeledObjectId();\n      }\n      Set<Ref> refs = refsById.get(id);\n      if (refs == null) {\n        return ImmutableList.of();\n      }\n      return refs.stream()\n          .filter(r -> r.getName().startsWith(prefix))\n          .sorted(comparing(Ref::getName))\n          .collect(toList());\n    }\n    private AbstractTreeIterator getTreeIterator(RevWalk walk, RevCommit commit)\n        throws IOException {\n      CanonicalTreeParser p = new CanonicalTreeParser();\n      p.reset(walk.getObjectReader(), walk.parseTree(walk.parseCommit(commit).getTree()));\n      return p;\n    }\n<fim_suffix>    private DiffList computeDiffEntries(\n        Repository repo, GitilesView view, RevWalk walk, RevCommit commit) throws IOException {\n      DiffList result = new DiffList();\n      result.revision =\n          view.getRevision().matches(commit)\n              ? view.getRevision()\n              : Revision.peeled(commit.name(), commit);\n      AbstractTreeIterator oldTree;\n      switch (commit.getParentCount()) {\n        case 0:\n          result.oldRevision = Revision.NULL;\n          oldTree = new EmptyTreeIterator();\n          break;\n        case 1:\n          result.oldRevision =\n              Revision.peeled(result.revision.getName() + \"^\", commit.getParent(0));\n          oldTree = getTreeIterator(walk, commit.getParent(0));\n          break;\n        default:\n          // TODO(dborowitz): handle merges\n          return result;\n      }\n      AbstractTreeIterator newTree = getTreeIterator(walk, commit);\n      try (DiffFormatter diff = new DiffFormatter(NullOutputStream.INSTANCE)) {\n        diff.setRepository(repo);\n        diff.setDetectRenames(true);\n        result.entries = diff.scan(oldTree, newTree);\n        return result;\n      }\n    }<fim_middle>// function below has no smell\n"}