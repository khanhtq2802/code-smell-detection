{"text": "<fim_prefix>        tree.pos = pos;\n        return tree;\n    }\n    public JCPackageDecl PackageDecl(List<JCAnnotation> annotations,\n                                     JCExpression pid) {\n        Assert.checkNonNull(annotations);\n        Assert.checkNonNull(pid);\n        JCPackageDecl tree = new JCPackageDecl(annotations, pid);\n        tree.pos = pos;\n        return tree;\n    }\n    public JCImport Import(JCTree qualid, boolean importStatic) {\n        JCImport tree = new JCImport(qualid, importStatic);\n        tree.pos = pos;\n        return tree;\n    }\n    public JCClassDecl ClassDef(JCModifiers mods,\n                                Name name,\n                                List<JCTypeParameter> typarams,\n                                JCExpression extending,\n                                List<JCExpression> implementing,\n                                List<JCTree> defs)\n    {\n        JCClassDecl tree = new JCClassDecl(mods,\n                                     name,\n                                     typarams,\n                                     extending,\n                                     implementing,\n                                     defs,\n                                     null);\n        tree.pos = pos;\n        return tree;\n    }\n    public JCMethodDecl MethodDef(JCModifiers mods,\n                               Name name,\n                               JCExpression restype,\n                               List<JCTypeParameter> typarams,\n                               List<JCVariableDecl> params,\n                               List<JCExpression> thrown,\n                               JCBlock body,\n                               JCExpression defaultValue) {\n        return MethodDef(\n                mods, name, restype, typarams, null, params,\n                thrown, body, defaultValue);\n    }\n    public JCMethodDecl MethodDef(JCModifiers mods,\n                               Name name,\n                               JCExpression restype,\n                               List<JCTypeParameter> typarams,\n                               JCVariableDecl recvparam,\n                               List<JCVariableDecl> params,\n                               List<JCExpression> thrown,\n                               JCBlock body,\n                               JCExpression defaultValue)\n    {\n        JCMethodDecl tree = new JCMethodDecl(mods,\n                                       name,\n                                       restype,\n                                       typarams,\n                                       recvparam,\n                                       params,\n                                       thrown,\n                                       body,\n                                       defaultValue,\n                                       null);\n        tree.pos = pos;\n        return tree;\n    }\n    public JCVariableDecl VarDef(JCModifiers mods, Name name, JCExpression vartype, JCExpression init) {\n        JCVariableDecl tree = new JCVariableDecl(mods, name, vartype, init, null);\n        tree.pos = pos;\n        return tree;\n    }\n    public JCVariableDecl ReceiverVarDef(JCModifiers mods, JCExpression name, JCExpression vartype) {\n        JCVariableDecl tree = new JCVariableDecl(mods, name, vartype);\n        tree.pos = pos;\n        return tree;\n    }\n    public JCSkip Skip() {\n        JCSkip tree = new JCSkip();\n        tree.pos = pos;\n        return tree;\n    }\n    public JCBlock Block(long flags, List<JCStatement> stats) {\n        JCBlock tree = new JCBlock(flags, stats);\n        tree.pos = pos;\n        return tree;\n    }\n    public JCDoWhileLoop DoLoop(JCStatement body, JCExpression cond) {\n        JCDoWhileLoop tree = new JCDoWhileLoop(body, cond);\n        tree.pos = pos;\n        return tree;\n    }\n    public JCWhileLoop WhileLoop(JCExpression cond, JCStatement body) {\n        JCWhileLoop tree = new JCWhileLoop(cond, body);\n        tree.pos = pos;\n        return tree;\n    }\n    public JCForLoop ForLoop(List<JCStatement> init,\n                           JCExpression cond,\n                           List<JCExpressionStatement> step,\n                           JCStatement body)\n    {\n        JCForLoop tree = new JCForLoop(init, cond, step, body);\n        tree.pos = pos;\n        return tree;\n    }\n    public JCEnhancedForLoop ForeachLoop(JCVariableDecl var, JCExpression expr, JCStatement body) {\n        JCEnhancedForLoop tree = new JCEnhancedForLoop(var, expr, body);\n        tree.pos = pos;\n        return tree;\n    }\n    public JCLabeledStatement Labelled(Name label, JCStatement body) {\n        JCLabeledStatement tree = new JCLabeledStatement(label, body);\n        tree.pos = pos;\n        return tree;\n    }\n    public JCSwitch Switch(JCExpression selector, List<JCCase> cases) {\n        JCSwitch tree = new JCSwitch(selector, cases);\n        tree.pos = pos;\n        return tree;\n    }\n    public JCCase Case(@SuppressWarnings(\"removal\") CaseKind caseKind, List<JCExpression> pats,\n                       List<JCStatement> stats, JCTree body) {\n        JCCase tree = new JCCase(caseKind, pats, stats, body);\n        tree.pos = pos;\n        return tree;\n    }\n    public JCSwitchExpression SwitchExpression(JCExpression selector, List<JCCase> cases) {\n        JCSwitchExpression tree = new JCSwitchExpression(selector, cases);\n        tree.pos = pos;\n        return tree;\n    }\n    public JCSynchronized Synchronized(JCExpression lock, JCBlock body) {\n        JCSynchronized tree = new JCSynchronized(lock, body);\n        tree.pos = pos;\n        return tree;\n    }\n    public JCTry Try(JCBlock body, List<JCCatch> catchers, JCBlock finalizer) {\n        return Try(List.nil(), body, catchers, finalizer);\n    }\n    public JCTry Try(List<JCTree> resources,\n                     JCBlock body,\n                     List<JCCatch> catchers,\n                     JCBlock finalizer) {\n        JCTry tree = new JCTry(resources, body, catchers, finalizer);\n        tree.pos = pos;\n        return tree;\n    }\n    public JCCatch Catch(JCVariableDecl param, JCBlock body) {\n        JCCatch tree = new JCCatch(param, body);\n        tree.pos = pos;\n        return tree;\n    }\n    public JCConditional Conditional(JCExpression cond,\n                                   JCExpression thenpart,\n                                   JCExpression elsepart)\n    {\n        JCConditional tree = new JCConditional(cond, thenpart, elsepart);\n        tree.pos = pos;\n        return tree;\n    }\n    public JCIf If(JCExpression cond, JCStatement thenpart, JCStatement elsepart) {\n        JCIf tree = new JCIf(cond, thenpart, elsepart);\n        tree.pos = pos;\n        return tree;\n    }\n    public JCExpressionStatement Exec(JCExpression expr) {\n        JCExpressionStatement tree = new JCExpressionStatement(expr);\n        tree.pos = pos;\n        return tree;\n    }\n    public JCBreak Break(JCExpression label) {\n        JCBreak tree = new JCBreak(label, null);\n        tree.pos = pos;\n        return tree;\n    }\n    public JCContinue Continue(Name label) {\n        JCContinue tree = new JCContinue(label, null);\n        tree.pos = pos;\n        return tree;\n    }\n    public JCReturn Return(JCExpression expr) {\n        JCReturn tree = new JCReturn(expr);\n        tree.pos = pos;\n        return tree;\n    }\n    public JCThrow Throw(JCExpression expr) {\n        JCThrow tree = new JCThrow(expr);\n        tree.pos = pos;\n        return tree;\n    }\n    public JCAssert Assert(JCExpression cond, JCExpression detail) {\n        JCAssert tree = new JCAssert(cond, detail);\n        tree.pos = pos;\n        return tree;\n    }\n    public JCMethodInvocation Apply(List<JCExpression> typeargs,\n                       JCExpression fn,\n                       List<JCExpression> args)\n    {\n        JCMethodInvocation tree = new JCMethodInvocation(typeargs, fn, args);\n        tree.pos = pos;\n        return tree;\n    }\n    public JCNewClass NewClass(JCExpression encl,\n                             List<JCExpression> typeargs,\n                             JCExpression clazz,\n                             List<JCExpression> args,\n                             JCClassDecl def)\n    {\n        return SpeculativeNewClass(encl, typeargs, clazz, args, def, false);\n    }\n<fim_suffix>    public JCNewClass SpeculativeNewClass(JCExpression encl,\n                             List<JCExpression> typeargs,\n                             JCExpression clazz,\n                             List<JCExpression> args,\n                             JCClassDecl def,\n                             boolean classDefRemoved)\n    {\n        JCNewClass tree = classDefRemoved ?\n                new JCNewClass(encl, typeargs, clazz, args, def) {\n                    @Override\n                    public boolean classDeclRemoved() {\n                        return true;\n                    }\n                } :\n                new JCNewClass(encl, typeargs, clazz, args, def);\n        tree.pos = pos;\n        return tree;\n    }<fim_middle>// function below has no smell\n"}