{"text": "<fim_prefix>        for (Path partPath : partPaths) {\n          try {\n            wh.deleteDir(partPath, true, ifPurge, db);\n          } catch (Exception e) {\n            LOG.error(\"Failed to delete partition directory: \" + partPath +\n                \" \" + e.getMessage());\n          }\n        }\n      }\n    }\n    /**\n     * Deletes the partitions specified by catName, dbName, tableName. If checkLocation is true, for\n     * locations of partitions which may not be subdirectories of tablePath checks to make sure the\n     * locations are writable.\n     *\n     * Drops the metadata for each partition.\n     *\n     * Provides a list of locations of partitions which may not be subdirectories of tablePath.\n     *\n     * @param ms RawStore to use for metadata retrieval and delete\n     * @param catName The catName\n     * @param dbName The dbName\n     * @param tableName The tableName\n     * @param tablePath The tablePath of which subdirectories does not have to be checked\n     * @param checkLocation Should we check the locations at all\n     * @return The list of the Path objects to delete (only in case checkLocation is true)\n     * @throws MetaException\n     * @throws IOException\n     * @throws NoSuchObjectException\n     */\n    private List<Path> dropPartitionsAndGetLocations(RawStore ms, String catName, String dbName,\n        String tableName, Path tablePath, boolean checkLocation)\n        throws MetaException, IOException, NoSuchObjectException {\n      int batchSize = MetastoreConf.getIntVar(conf, ConfVars.BATCH_RETRIEVE_OBJECTS_MAX);\n      String tableDnsPath = null;\n      if (tablePath != null) {\n        tableDnsPath = wh.getDnsPath(tablePath).toString();\n      }\n      List<Path> partPaths = new ArrayList<>();\n      while (true) {\n        Map<String, String> partitionLocations = ms.getPartitionLocations(catName, dbName, tableName,\n            tableDnsPath, batchSize);\n        if (partitionLocations == null || partitionLocations.isEmpty()) {\n          // No more partitions left to drop. Return with the collected path list to delete.\n          return partPaths;\n        }\n        if (checkLocation) {\n          for (String partName : partitionLocations.keySet()) {\n            String pathString = partitionLocations.get(partName);\n            if (pathString != null) {\n              Path partPath = wh.getDnsPath(new Path(pathString));\n              // Double check here. Maybe Warehouse.getDnsPath revealed relationship between the\n              // path objects\n              if (tableDnsPath == null ||\n                      !FileUtils.isSubdirectory(tableDnsPath, partPath.toString())) {\n                if (!wh.isWritable(partPath.getParent())) {\n                  throw new MetaException(\"Table metadata not deleted since the partition \"\n                      + partName + \" has parent location \" + partPath.getParent()\n                      + \" which is not writable by \" + SecurityUtils.getUser());\n                }\n                partPaths.add(partPath);\n              }\n            }\n          }\n        }\n        for (MetaStoreEventListener listener : listeners) {\n          //No drop part listener events fired for public listeners historically, for drop table case.\n          //Limiting to internal listeners for now, to avoid unexpected calls for public listeners.\n          if (listener instanceof HMSMetricsListener) {\n            for (@SuppressWarnings(\"unused\") String partName : partitionLocations.keySet()) {\n              listener.onDropPartition(null);\n            }\n          }\n        }\n        ms.dropPartitions(catName, dbName, tableName, new ArrayList<>(partitionLocations.keySet()));\n      }\n    }\n    @Override\n    public void drop_table(final String dbname, final String name, final boolean deleteData)\n        throws NoSuchObjectException, MetaException {\n      drop_table_with_environment_context(dbname, name, deleteData, null);\n    }\n    @Override\n    public void drop_table_with_environment_context(final String dbname, final String name,\n        final boolean deleteData, final EnvironmentContext envContext)\n        throws NoSuchObjectException, MetaException {\n      String[] parsedDbName = parseDbName(dbname, conf);\n      startTableFunction(\"drop_table\", parsedDbName[CAT_NAME], parsedDbName[DB_NAME], name);\n      boolean success = false;\n      Exception ex = null;\n      try {\n        success = drop_table_core(getMS(), parsedDbName[CAT_NAME], parsedDbName[DB_NAME], name,\n            deleteData, envContext, null);\n      } catch (IOException e) {\n        ex = e;\n        throw new MetaException(e.getMessage());\n      } catch (Exception e) {\n        ex = e;\n        throwMetaException(e);\n      } finally {\n        endFunction(\"drop_table\", success, ex, name);\n      }\n    }\n    private void updateStatsForTruncate(Map<String,String> props, EnvironmentContext environmentContext) {\n      if (null == props) {\n        return;\n      }\n      for (String stat : StatsSetupConst.SUPPORTED_STATS) {\n        String statVal = props.get(stat);\n        if (statVal != null) {\n          //In the case of truncate table, we set the stats to be 0.\n          props.put(stat, \"0\");\n        }\n      }\n      //first set basic stats to true\n      StatsSetupConst.setBasicStatsState(props, StatsSetupConst.TRUE);\n      environmentContext.putToProperties(StatsSetupConst.STATS_GENERATED, StatsSetupConst.TASK);\n      //then invalidate column stats\n      StatsSetupConst.clearColumnStatsState(props);\n      return;\n    }\n    private void alterPartitionForTruncate(RawStore ms, String catName, String dbName, String tableName,\n        Table table, Partition partition, String validWriteIds, long writeId) throws Exception {\n      EnvironmentContext environmentContext = new EnvironmentContext();\n      updateStatsForTruncate(partition.getParameters(), environmentContext);\n      if (!transactionalListeners.isEmpty()) {\n        MetaStoreListenerNotifier.notifyEvent(transactionalListeners,\n                EventType.ALTER_PARTITION,\n                new AlterPartitionEvent(partition, partition, table, true, true,\n                        writeId, this));\n      }\n      if (!listeners.isEmpty()) {\n        MetaStoreListenerNotifier.notifyEvent(listeners,\n                EventType.ALTER_PARTITION,\n                new AlterPartitionEvent(partition, partition, table, true, true,\n                        writeId, this));\n      }\n      if (writeId > 0) {\n        partition.setWriteId(writeId);\n      }\n      alterHandler.alterPartition(ms, wh, catName, dbName, tableName, null, partition,\n          environmentContext, this, validWriteIds);\n    }\n<fim_suffix>    private void alterTableStatsForTruncate(RawStore ms, String catName, String dbName,\n        String tableName, Table table, List<String> partNames,\n        String validWriteIds, long writeId) throws Exception {\n      if (partNames == null) {\n        if (0 != table.getPartitionKeysSize()) {\n          for (Partition partition : ms.getPartitions(catName, dbName, tableName, Integer.MAX_VALUE)) {\n            alterPartitionForTruncate(ms, catName, dbName, tableName, table, partition,\n                validWriteIds, writeId);\n          }\n        } else {\n          EnvironmentContext environmentContext = new EnvironmentContext();\n          updateStatsForTruncate(table.getParameters(), environmentContext);\n          if (!transactionalListeners.isEmpty()) {\n            MetaStoreListenerNotifier.notifyEvent(transactionalListeners,\n                    EventType.ALTER_TABLE,\n                    new AlterTableEvent(table, table, true, true,\n                            writeId, this));\n          }\n          if (!listeners.isEmpty()) {\n            MetaStoreListenerNotifier.notifyEvent(listeners,\n                    EventType.ALTER_TABLE,\n                    new AlterTableEvent(table, table, true, true,\n                            writeId, this));\n          }\n          // TODO: this should actually pass thru and set writeId for txn stats.\n          if (writeId > 0) {\n            table.setWriteId(writeId);\n          }\n          alterHandler.alterTable(ms, wh, catName, dbName, tableName, table,\n              environmentContext, this, validWriteIds);\n        }\n      } else {\n        for (Partition partition : ms.getPartitionsByNames(catName, dbName, tableName, partNames)) {\n          alterPartitionForTruncate(ms, catName, dbName, tableName, table, partition,\n              validWriteIds, writeId);\n        }\n      }\n      return;\n    }<fim_middle>// function below is long method\n"}