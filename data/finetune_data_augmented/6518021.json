{"text": "<fim_prefix>        public static final String PROCESSING_STEPS_ELEMENT = \"processing\"; //$NON-NLS-1$\n        public static final String PROCESSING_STEP_ELEMENT = \"step\"; //$NON-NLS-1$\n        public static final String MAPPING_RULE_FILTER_ATTRIBUTE = \"filter\"; //$NON-NLS-1$\n        public static final String MAPPING_RULE_OUTPUT_ATTRIBUTE = \"output\"; //$NON-NLS-1$\n        public static final String ARTIFACT_CLASSIFIER_ATTRIBUTE = CLASSIFIER_ATTRIBUTE;\n        public static final String STEP_DATA_ATTRIBUTE = \"data\"; //$NON-NLS-1$\n        public static final String STEP_REQUIRED_ATTRIBUTE = \"required\"; //$NON-NLS-1$\n    }\n    // XML writer for a SimpleArtifactRepository\n    public static class Writer extends XMLWriter implements XMLConstants {\n        public Writer(OutputStream output) throws IOException {\n            super(output, PI_DEFAULTS);\n        }\n        /**\n         * Write the given artifact repository to the output stream.\n         */\n        public void write(SimpleArtifactRepository repository) {\n            start(REPOSITORY_ELEMENT);\n            attribute(NAME_ATTRIBUTE, repository.getName());\n            attribute(TYPE_ATTRIBUTE, repository.getType());\n            attribute(VERSION_ATTRIBUTE, repository.getVersion());\n            attributeOptional(PROVIDER_ATTRIBUTE, repository.getProvider());\n            attributeOptional(DESCRIPTION_ATTRIBUTE, repository.getDescription()); // TODO: could be cdata?\n            writeProperties(repository.getProperties());\n            writeMappingRules(repository.getRules());\n            writeArtifacts(repository.getDescriptors());\n            end(REPOSITORY_ELEMENT);\n            flush();\n        }\n        private void writeMappingRules(String[][] rules) {\n            if (rules.length > 0) {\n                start(MAPPING_RULES_ELEMENT);\n                attribute(COLLECTION_SIZE_ATTRIBUTE, rules.length);\n                for (int i = 0; i < rules.length; i++) {\n                    start(MAPPING_RULE_ELEMENT);\n                    attribute(MAPPING_RULE_FILTER_ATTRIBUTE, rules[i][0]);\n                    attribute(MAPPING_RULE_OUTPUT_ATTRIBUTE, rules[i][1]);\n                    end(MAPPING_RULE_ELEMENT);\n                }\n                end(MAPPING_RULES_ELEMENT);\n            }\n        }\n        protected void writeArtifacts(Set<? extends IArtifactDescriptor> artifactDescriptors) {\n            start(ARTIFACTS_ELEMENT);\n            attribute(COLLECTION_SIZE_ATTRIBUTE, artifactDescriptors.size());\n            for (IArtifactDescriptor descriptor : artifactDescriptors) {\n                IArtifactKey key = descriptor.getArtifactKey();\n                start(ARTIFACT_ELEMENT);\n                attribute(ARTIFACT_CLASSIFIER_ATTRIBUTE, key.getClassifier());\n                attribute(ID_ATTRIBUTE, key.getId());\n                attribute(VERSION_ATTRIBUTE, key.getVersion());\n                writeProcessingSteps(descriptor.getProcessingSteps());\n                writeProperties(descriptor.getProperties());\n                //writeProperties(REPOSITORY_PROPERTIES_ELEMENT, descriptor.getRepositoryProperties());\n                end(ARTIFACT_ELEMENT);\n            }\n            end(ARTIFACTS_ELEMENT);\n        }\n        private void writeProcessingSteps(IProcessingStepDescriptor[] processingSteps) {\n            if (processingSteps.length > 0) {\n                start(PROCESSING_STEPS_ELEMENT);\n                attribute(COLLECTION_SIZE_ATTRIBUTE, processingSteps.length);\n                for (int i = 0; i < processingSteps.length; i++) {\n                    start(PROCESSING_STEP_ELEMENT);\n                    attribute(ID_ATTRIBUTE, processingSteps[i].getProcessorId());\n                    attribute(STEP_DATA_ATTRIBUTE, processingSteps[i].getData());\n                    attribute(STEP_REQUIRED_ATTRIBUTE, processingSteps[i].isRequired());\n                    end(PROCESSING_STEP_ELEMENT);\n                }\n                end(PROCESSING_STEPS_ELEMENT);\n            }\n        }\n    }\n    /*\n     * Parser for the contents of a SimpleArtifactRepository, as written by the Writer class.\n     */\n    public static class Parser extends XMLParser implements XMLConstants {\n        private SimpleArtifactRepository theRepository = null;\n        public Parser(BundleContext context, String bundleId) {\n            super(context, bundleId);\n        }\n        public synchronized void parse(InputStream stream) throws IOException {\n            this.status = null;\n            try {\n                // TODO: currently not caching the parser since we make no assumptions\n                //\t\t or restrictions on concurrent parsing\n                getParser();\n                RepositoryHandler repositoryHandler = new RepositoryHandler();\n                xmlReader.setContentHandler(new RepositoryDocHandler(REPOSITORY_ELEMENT, repositoryHandler));\n                xmlReader.parse(new InputSource(stream));\n                if (isValidXML()) {\n                    theRepository = repositoryHandler.getRepository();\n                }\n            } catch (SAXException e) {\n                throw new IOException(e.getMessage());\n            } catch (ParserConfigurationException e) {\n                throw new IOException(e.getMessage());\n            } finally {\n                stream.close();\n            }\n        }\n        public SimpleArtifactRepository getRepository() {\n            return theRepository;\n        }\n        @Override\n        protected Object getRootObject() {\n            return theRepository;\n        }\n        protected final class RepositoryDocHandler extends DocHandler {\n            public RepositoryDocHandler(String rootName, RootHandler rootHandler) {\n                super(rootName, rootHandler);\n            }\n            @Override\n            public void processingInstruction(String target, String data) throws SAXException {\n                if (PI_REPOSITORY_TARGET.equals(target)) {\n                    // TODO: should the root handler be constructed based on class\n                    // \t\t via an extension registry mechanism?\n                    // String clazz = extractPIClass(data);\n                    // TODO: version tolerance by extension\n                    Version repositoryVersion = extractPIVersion(target, data);\n                    if (!XML_TOLERANCE.isIncluded(repositoryVersion)) {\n                        throw new SAXException(\n                                NLS.bind(Messages.io_incompatibleVersion, repositoryVersion, XML_TOLERANCE));\n                    }\n                }\n            }\n        }\n        private final class RepositoryHandler extends RootHandler {\n            private final String[] required = new String[] { NAME_ATTRIBUTE, TYPE_ATTRIBUTE, VERSION_ATTRIBUTE };\n            private final String[] optional = new String[] { DESCRIPTION_ATTRIBUTE, PROVIDER_ATTRIBUTE };\n            private String[] attrValues = new String[required.length + optional.length];\n            private MappingRulesHandler mappingRulesHandler = null;\n            private PropertiesHandler propertiesHandler = null;\n            private ArtifactsHandler artifactsHandler = null;\n            public RepositoryHandler() {\n                super();\n            }\n            public SimpleArtifactRepository getRepository() {\n                return null;\n            }\n            @Override\n            protected void handleRootAttributes(Attributes attributes) {\n                attrValues = parseAttributes(attributes, required, optional);\n                attrValues[2] = checkVersion(REPOSITORY_ELEMENT, VERSION_ATTRIBUTE, attrValues[2]).toString();\n            }\n            @Override\n            public void startElement(String name, Attributes attributes) {\n                if (MAPPING_RULES_ELEMENT.equals(name)) {\n                    if (mappingRulesHandler == null) {\n                        mappingRulesHandler = new MappingRulesHandler(this, attributes);\n                    } else {\n                        duplicateElement(this, name, attributes);\n                    }\n                } else if (ARTIFACTS_ELEMENT.equals(name)) {\n                    if (artifactsHandler == null) {\n                        artifactsHandler = new ArtifactsHandler(this, attributes);\n                    } else {\n                        duplicateElement(this, name, attributes);\n                    }\n                } else if (PROPERTIES_ELEMENT.equals(name)) {\n                    if (propertiesHandler == null) {\n                        propertiesHandler = new PropertiesHandler(this, attributes);\n                    } else {\n                        duplicateElement(this, name, attributes);\n                    }\n                } else {\n                    invalidElement(name, attributes);\n                }\n            }\n        }\n        protected class MappingRulesHandler extends AbstractHandler {\n            private List mappingRules;\n            public MappingRulesHandler(AbstractHandler parentHandler, Attributes attributes) {\n                super(parentHandler, MAPPING_RULES_ELEMENT);\n                String size = parseOptionalAttribute(attributes, COLLECTION_SIZE_ATTRIBUTE);\n                mappingRules = (size != null ? new ArrayList<>(Integer.parseInt(size)) : new ArrayList<>(4));\n            }\n            public String[][] getMappingRules() {\n                String[][] rules = new String[mappingRules.size()][2];\n                for (int index = 0; index < mappingRules.size(); index++) {\n                    String[] ruleAttributes = (String[]) mappingRules.get(index);\n                    rules[index] = ruleAttributes;\n                }\n                return rules;\n            }\n            @Override\n            public void startElement(String name, Attributes attributes) {\n                if (name.equals(MAPPING_RULE_ELEMENT)) {\n                    new MappingRuleHandler(this, attributes, mappingRules);\n                } else {\n                    invalidElement(name, attributes);\n                }\n            }\n        }\n<fim_suffix>        protected class MappingRuleHandler extends AbstractHandler {\n            private final String[] required = new String[] { MAPPING_RULE_FILTER_ATTRIBUTE,\n                    MAPPING_RULE_OUTPUT_ATTRIBUTE };\n            public MappingRuleHandler(AbstractHandler parentHandler, Attributes attributes, List mappingRules) {\n                super(parentHandler, MAPPING_RULE_ELEMENT);\n                mappingRules.add(parseRequiredAttributes(attributes, required));\n            }\n            @Override\n            public void startElement(String name, Attributes attributes) {\n                invalidElement(name, attributes);\n            }\n        }<fim_middle>// class below has no smell\n"}