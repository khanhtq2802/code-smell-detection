{"text": "<fim_prefix>/*\n * Copyright 2018-present Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License. You may obtain\n * a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\n\npackage com.facebook.buck.util.string;\n\nimport com.facebook.buck.util.types.Pair;\nimport com.google.common.base.Joiner;\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.io.CharSource;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Optional;\n\n<fim_suffix>public final class MoreStrings {\n\n  /** Utility class: do not instantiate. */\n  private MoreStrings() {}\n\n  /**\n   * Joins the les passed in with the platform line separator.\n   *\n   * @param lines the lines that need to be joined.\n   * @return String, containing the joined lines using the platform line separator as delimiter.\n   */\n  public static String linesToText(String... lines) {\n    return String.join(System.lineSeparator(), lines);\n  }\n\n  public static boolean isEmpty(CharSequence sequence) {\n    return sequence.length() == 0;\n  }\n\n  public static String withoutSuffix(String str, String suffix) {\n    Preconditions.checkArgument(str.endsWith(suffix), \"%s must end with %s\", str, suffix);\n    return str.substring(0, str.length() - suffix.length());\n  }\n\n  public static String capitalize(String str) {\n    if (!str.isEmpty()) {\n      return str.substring(0, 1).toUpperCase() + str.substring(1);\n    } else {\n      return \"\";\n    }\n  }\n\n  public static int getLevenshteinDistance(String str1, String str2) {\n    if (str1.length() < str2.length()) {\n      // ensure that str2 is always the smallest one to make space complexity O(min(|str1|, |str2|)\n      return getLevenshteinDistance(str2, str1);\n    }\n\n    // reduce memory usage by storing only the last 2 rows of the table\n    int previous = 0;\n    int[][] levenshteinDist = new int[2][str2.length() + 1];\n\n    for (int j = 0; j <= str2.length(); j++) {\n      levenshteinDist[previous][j] = j;\n    }\n\n    for (int i = 1; i <= str1.length(); i++, previous = 1 - previous) {\n      int current = 1 - previous;\n      levenshteinDist[current][0] = i;\n      for (int j = 1; j <= str2.length(); j++) {\n        if (str1.charAt(i - 1) == str2.charAt(j - 1)) {\n          levenshteinDist[current][j] = levenshteinDist[previous][j - 1];\n        } else {\n          levenshteinDist[current][j] =\n              Math.min(\n                      levenshteinDist[previous][j],\n                      Math.min(levenshteinDist[current][j - 1], levenshteinDist[previous][j - 1]))\n                  + 1;\n        }\n      }\n    }\n\n    return levenshteinDist[previous][str2.length()];\n  }\n\n  public static String regexPatternForAny(String... values) {\n    return regexPatternForAny(Arrays.asList(values));\n  }\n\n  public static String regexPatternForAny(Iterable<String> values) {\n    return \"((?:\" + Joiner.on(\")|(?:\").join(values) + \"))\";\n  }\n\n  public static boolean endsWithIgnoreCase(String str, String suffix) {\n    if (str.length() < suffix.length()) {\n      return false;\n    }\n\n    return str.substring(str.length() - suffix.length()).equalsIgnoreCase(suffix);\n  }\n\n  public static Optional<String> stripPrefix(String s, String prefix) {\n    return s.startsWith(prefix) ? Optional.of(s.substring(prefix.length())) : Optional.empty();\n  }\n\n  public static Optional<String> stripSuffix(String s, String suffix) {\n    return s.endsWith(suffix)\n        ? Optional.of(s.substring(0, s.length() - suffix.length()))\n        : Optional.empty();\n  }\n\n  public static String truncatePretty(String data) {\n    int keepFirstChars = 10000;\n    int keepLastChars = 10000;\n    String truncateMessage = \"...\\n<truncated>\\n...\";\n    return truncateMiddle(data, keepFirstChars, keepLastChars, truncateMessage);\n  }\n\n  public static String truncateMiddle(\n      String data, int keepFirstChars, int keepLastChars, String truncateMessage) {\n    if (data.length() <= keepFirstChars + keepLastChars + truncateMessage.length()) {\n      return data;\n    }\n    return data.substring(0, keepFirstChars)\n        + truncateMessage\n        + data.substring(data.length() - keepLastChars);\n  }\n\n  public static ImmutableList<String> lines(String data) throws IOException {\n    return CharSource.wrap(data).readLines();\n  }\n\n  /** Compare two strings lexicographically. */\n  public static int compareStrings(String a, String b) {\n    if (a == b) {\n      return 0;\n    }\n    return a.compareTo(b);\n  }\n\n  /**\n   * @return The spelling suggestion for the {@code input} based on its Levenstein distance from a\n   *     list of available {@code options}.\n   */\n  public static List<String> getSpellingSuggestions(\n      String input, Collection<String> options, int maxDistance) {\n    return options\n        .stream()\n        .map(option -> new Pair<>(option, MoreStrings.getLevenshteinDistance(input, option)))\n        .filter(pair -> pair.getSecond() <= maxDistance)\n        .sorted(Comparator.comparing(Pair::getSecond))\n        .map(Pair::getFirst)\n        .collect(ImmutableList.toImmutableList());\n  }\n\n  /** Removes carriage return characters from the string with preserving new line characters. */\n  public static String replaceCR(String text) {\n    return text.replace(\"\\r\\n\", \"\\n\").replace('\\r', '\\n');\n  }\n}<fim_middle>// class below has no smell\n"}