{"text": "<fim_prefix>/*\n * Copyright (c) 2016, 2018, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 3 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 3 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 3 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage com.oracle.truffle.r.nodes.builtin.base;\n\nimport static com.oracle.truffle.r.runtime.builtins.RBehavior.PURE;\nimport static com.oracle.truffle.r.runtime.builtins.RBuiltinKind.INTERNAL;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\n\nimport com.oracle.truffle.api.CompilerDirectives.TruffleBoundary;\nimport com.oracle.truffle.api.dsl.Fallback;\nimport com.oracle.truffle.api.dsl.Specialization;\nimport com.oracle.truffle.r.nodes.builtin.RBuiltinNode;\nimport com.oracle.truffle.r.runtime.RRuntime;\nimport com.oracle.truffle.r.runtime.builtins.RBuiltin;\nimport com.oracle.truffle.r.runtime.data.RDataFactory;\nimport com.oracle.truffle.r.runtime.data.RExpression;\nimport com.oracle.truffle.r.runtime.data.RPairList;\nimport com.oracle.truffle.r.runtime.data.RStringVector;\nimport com.oracle.truffle.r.runtime.data.RSymbol;\nimport com.oracle.truffle.r.runtime.nodes.RSyntaxCall;\nimport com.oracle.truffle.r.runtime.nodes.RSyntaxConstant;\nimport com.oracle.truffle.r.runtime.nodes.RSyntaxElement;\nimport com.oracle.truffle.r.runtime.nodes.RSyntaxFunction;\nimport com.oracle.truffle.r.runtime.nodes.RSyntaxLookup;\nimport com.oracle.truffle.r.runtime.nodes.RSyntaxNode;\nimport com.oracle.truffle.r.runtime.nodes.RSyntaxVisitor;\n\n@RBuiltin(name = \"all.names\", kind = INTERNAL, parameterNames = {\"expr\", \"functions\", \"max.names\", \"unique\"}, behavior = PURE)\npublic abstract class AllNames extends RBuiltinNode.Arg4 {\n\n    static {\n        Casts casts = new Casts(AllNames.class);\n        casts.arg(\"functions\").asLogicalVector().findFirst(RRuntime.LOGICAL_FALSE).replaceNA(RRuntime.LOGICAL_FALSE);\n        casts.arg(\"max.names\").asIntegerVector().findFirst(0).replaceNA(0);\n        casts.arg(\"unique\").asLogicalVector().findFirst(RRuntime.LOGICAL_TRUE).replaceNA(RRuntime.LOGICAL_TRUE);\n    }\n\n    @Specialization\n    @TruffleBoundary\n    protected Object doAllNames(RExpression exprs, byte functions, int maxNames, byte unique) {\n        AllNamesVisitor visitor = new AllNamesVisitor(functions == RRuntime.LOGICAL_TRUE, maxNames, unique == RRuntime.LOGICAL_TRUE);\n        for (int i = 0; i < exprs.getLength(); i++) {\n            Object expr = exprs.getDataAt(i);\n            if (expr instanceof RSymbol) {\n                visitor.accept(RSyntaxLookup.createDummyLookup(null, ((RSymbol) expr).getName(), false));\n            } else if ((expr instanceof RPairList && ((RPairList) expr).isLanguage())) {\n                RPairList lang = (RPairList) expr;\n                visitor.accept(lang.getSyntaxElement());\n            }\n        }\n        return visitor.getResult();\n    }\n\n    @Specialization(guards = \"expr.isLanguage()\")\n    @TruffleBoundary\n    protected Object doAllNames(RPairList expr, byte functions, int maxNames, byte unique) {\n        AllNamesVisitor visitor = new AllNamesVisitor(functions == RRuntime.LOGICAL_TRUE, maxNames, unique == RRuntime.LOGICAL_TRUE);\n        visitor.accept(expr.getSyntaxElement());\n        return visitor.getResult();\n    }\n\n    /**\n     * This visitor recursively traverses the syntax tree, collecting names according to the\n     * semantics of the all.names builtin.\n     */\n    private static final class AllNamesVisitor extends RSyntaxVisitor<Void> {\n\n        private final boolean functions;\n        private final int maxNames;\n        private final HashSet<String> unique;\n        private final ArrayList<String> result;\n\n<fim_suffix>        AllNamesVisitor(boolean functions, int maxNames, boolean unique) {\n            this.functions = functions;\n            this.maxNames = maxNames == -1 ? Integer.MAX_VALUE : maxNames;\n            this.unique = unique ? new HashSet<>() : null;\n            this.result = new ArrayList<>();\n        }\n\n        public RStringVector getResult() {\n            return RDataFactory.createStringVector(result.toArray(new String[result.size()]), true);\n        }\n\n        @Override\n        protected Void visit(RSyntaxCall element) {\n            accept(element.getSyntaxLHS());\n            for (RSyntaxElement arg : element.getSyntaxArguments()) {\n                // unmatched arguments may still be null\n                if (arg != null) {\n                    accept(arg);\n                }\n            }\n            return null;\n        }\n\n        @Override\n        protected Void visit(RSyntaxConstant element) {\n            return null;\n        }\n\n        @Override\n        protected Void visit(RSyntaxLookup element) {\n            if (functions || !element.isFunctionLookup()) {\n                if (result.size() < maxNames) {\n                    String identifier = element.getIdentifier();\n                    if (unique == null || unique.add(identifier)) {\n                        result.add(identifier);\n                    }\n                }\n            }\n            return null;\n        }\n\n        @Override\n        protected Void visit(RSyntaxFunction element) {\n            accept(RSyntaxLookup.createDummyLookup(RSyntaxNode.INTERNAL, \"function\", true));\n            accept(element.getSyntaxBody());\n            // functions do not recurse into the arguments\n            return null;\n        }\n    }\n\n    @Specialization\n    @TruffleBoundary\n    protected Object doAllNames(RSymbol symbol, @SuppressWarnings(\"unused\") byte functions, int maxNames, @SuppressWarnings(\"unused\") byte unique) {\n        if (maxNames > 0 || maxNames == -1) {\n            return RDataFactory.createStringVectorFromScalar(symbol.getName());\n        } else {\n            return RDataFactory.createEmptyStringVector();\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    @Fallback\n    protected Object doAllNames(Object expr, Object functions, Object maxNames, Object unique) {\n        return RDataFactory.createEmptyStringVector();\n    }\n}<fim_middle>// function below has no smell\n"}