{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\npackage org.apache.skywalking.oap.server.core.analysis.data;\n\nimport java.util.*;\nimport org.apache.skywalking.oap.server.core.storage.ComparableStorageData;\n\n<fim_suffix>public class LimitedSizeDataCollection<STORAGE_DATA extends ComparableStorageData> implements SWCollection<STORAGE_DATA> {\n\n    private final HashMap<STORAGE_DATA, LinkedList<STORAGE_DATA>> data;\n    private final int limitedSize;\n    private volatile boolean writing;\n    private volatile boolean reading;\n\n    LimitedSizeDataCollection(int limitedSize) {\n        this.data = new HashMap<>();\n        this.writing = false;\n        this.reading = false;\n        this.limitedSize = limitedSize;\n    }\n\n    public void finishWriting() {\n        writing = false;\n    }\n\n    @Override public void writing() {\n        writing = true;\n    }\n\n    @Override public boolean isWriting() {\n        return writing;\n    }\n\n    @Override public void finishReading() {\n        reading = false;\n    }\n\n    @Override public void reading() {\n        reading = true;\n    }\n\n    @Override public boolean isReading() {\n        return reading;\n    }\n\n    @Override public int size() {\n        return data.size();\n    }\n\n    @Override public void clear() {\n        data.clear();\n    }\n\n    @Override public boolean containsKey(STORAGE_DATA key) {\n        throw new UnsupportedOperationException(\"Limited size data collection doesn't support containsKey operation.\");\n    }\n\n    @Override public STORAGE_DATA get(STORAGE_DATA key) {\n        throw new UnsupportedOperationException(\"Limited size data collection doesn't support get operation.\");\n    }\n\n    @Override public void put(STORAGE_DATA value) {\n        LinkedList<STORAGE_DATA> storageDataList = this.data.get(value);\n        if (storageDataList == null) {\n            storageDataList = new LinkedList<>();\n            data.put(value, storageDataList);\n        }\n\n        if (storageDataList.size() < limitedSize) {\n            storageDataList.add(value);\n            return;\n        }\n\n        for (int i = 0; i < storageDataList.size(); i++) {\n            STORAGE_DATA storageData = storageDataList.get(i);\n            if (value.compareTo(storageData) <= 0) {\n                if (i == 0) {\n                    // input value is less than the smallest in top N list, ignore\n                } else {\n                    // Remove the smallest in top N list\n                    // add the current value into the right position\n                    storageDataList.add(i, value);\n                    storageDataList.removeFirst();\n                }\n                return;\n            }\n        }\n\n        // Add the value as biggest in top N list\n        storageDataList.addLast(value);\n        storageDataList.removeFirst();\n    }\n\n    @Override public Collection<STORAGE_DATA> collection() {\n        List<STORAGE_DATA> collection = new ArrayList<>();\n        data.values().forEach(e -> e.forEach(collection::add));\n        return collection;\n    }\n}<fim_middle>// class below is data class\n"}