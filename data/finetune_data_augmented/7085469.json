{"text": "<fim_prefix>     * }</pre>\n     *\n     * @implNote Implementations of this method need not\n     * create a separate {@code NavigableSet} object for each call.\n     *\n     * @param <E> type of elements, if there were any, in the set\n     * @return the empty navigable set\n     * @since 1.8\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <E> NavigableSet<E> emptyNavigableSet() {\n        return (NavigableSet<E>) UnmodifiableNavigableSet.EMPTY_NAVIGABLE_SET;\n    }\n    /**\n     * The empty list (immutable).  This list is serializable.\n     *\n     * @see #emptyList()\n     */\n    @SuppressWarnings(\"rawtypes\")\n    public static final List EMPTY_LIST = new EmptyList<>();\n    /**\n     * Returns an empty list (immutable).  This list is serializable.\n     *\n     * <p>This example illustrates the type-safe way to obtain an empty list:\n     * <pre>\n     *     List&lt;String&gt; s = Collections.emptyList();\n     * </pre>\n     *\n     * @implNote\n     * Implementations of this method need not create a separate <tt>List</tt>\n     * object for each call.   Using this method is likely to have comparable\n     * cost to using the like-named field.  (Unlike this method, the field does\n     * not provide type safety.)\n     *\n     * @param <T> type of elements, if there were any, in the list\n     * @return an empty immutable list\n     *\n     * @see #EMPTY_LIST\n     * @since 1.5\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static final <T> List<T> emptyList() {\n        return (List<T>) EMPTY_LIST;\n    }\n    /**\n     * @serial include\n     */\n    private static class EmptyList<E>\n        extends AbstractList<E>\n        implements RandomAccess, Serializable {\n        private static final long serialVersionUID = 8842843931221139166L;\n        public Iterator<E> iterator() {\n            return emptyIterator();\n        }\n        public ListIterator<E> listIterator() {\n            return emptyListIterator();\n        }\n        public int size() {return 0;}\n        public boolean isEmpty() {return true;}\n        public boolean contains(Object obj) {return false;}\n        public boolean containsAll(Collection<?> c) { return c.isEmpty(); }\n        public Object[] toArray() { return new Object[0]; }\n        public <T> T[] toArray(T[] a) {\n            if (a.length > 0)\n                a[0] = null;\n            return a;\n        }\n        public E get(int index) {\n            throw new IndexOutOfBoundsException(\"Index: \"+index);\n        }\n        public boolean equals(Object o) {\n            return (o instanceof List) && ((List<?>)o).isEmpty();\n        }\n        public int hashCode() { return 1; }\n        @Override\n        public boolean removeIf(Predicate<? super E> filter) {\n            Objects.requireNonNull(filter);\n            return false;\n        }\n        @Override\n        public void replaceAll(UnaryOperator<E> operator) {\n            Objects.requireNonNull(operator);\n        }\n        @Override\n        public void sort(Comparator<? super E> c) {\n        }\n        // Override default methods in Collection\n        @Override\n        public void forEach(Consumer<? super E> action) {\n            Objects.requireNonNull(action);\n        }\n        @Override\n        public Spliterator<E> spliterator() { return Spliterators.emptySpliterator(); }\n        // Preserves singleton property\n        private Object readResolve() {\n            return EMPTY_LIST;\n        }\n    }\n    /**\n     * The empty map (immutable).  This map is serializable.\n     *\n     * @see #emptyMap()\n     * @since 1.3\n     */\n    @SuppressWarnings(\"rawtypes\")\n    public static final Map EMPTY_MAP = new EmptyMap<>();\n    /**\n     * Returns an empty map (immutable).  This map is serializable.\n     *\n     * <p>This example illustrates the type-safe way to obtain an empty map:\n     * <pre>\n     *     Map&lt;String, Date&gt; s = Collections.emptyMap();\n     * </pre>\n     * @implNote Implementations of this method need not create a separate\n     * {@code Map} object for each call.  Using this method is likely to have\n     * comparable cost to using the like-named field.  (Unlike this method, the\n     * field does not provide type safety.)\n     *\n     * @param <K> the class of the map keys\n     * @param <V> the class of the map values\n     * @return an empty map\n     * @see #EMPTY_MAP\n     * @since 1.5\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static final <K,V> Map<K,V> emptyMap() {\n        return (Map<K,V>) EMPTY_MAP;\n    }\n    /**\n     * Returns an empty sorted map (immutable).  This map is serializable.\n     *\n     * <p>This example illustrates the type-safe way to obtain an empty map:\n     * <pre> {@code\n     *     SortedMap<String, Date> s = Collections.emptySortedMap();\n     * }</pre>\n     *\n     * @implNote Implementations of this method need not create a separate\n     * {@code SortedMap} object for each call.\n     *\n     * @param <K> the class of the map keys\n     * @param <V> the class of the map values\n     * @return an empty sorted map\n     * @since 1.8\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static final <K,V> SortedMap<K,V> emptySortedMap() {\n        return (SortedMap<K,V>) UnmodifiableNavigableMap.EMPTY_NAVIGABLE_MAP;\n    }\n    /**\n     * Returns an empty navigable map (immutable).  This map is serializable.\n     *\n     * <p>This example illustrates the type-safe way to obtain an empty map:\n     * <pre> {@code\n     *     NavigableMap<String, Date> s = Collections.emptyNavigableMap();\n     * }</pre>\n     *\n     * @implNote Implementations of this method need not create a separate\n     * {@code NavigableMap} object for each call.\n     *\n     * @param <K> the class of the map keys\n     * @param <V> the class of the map values\n     * @return an empty navigable map\n     * @since 1.8\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static final <K,V> NavigableMap<K,V> emptyNavigableMap() {\n        return (NavigableMap<K,V>) UnmodifiableNavigableMap.EMPTY_NAVIGABLE_MAP;\n    }\n    /**\n     * @serial include\n     */\n    private static class EmptyMap<K,V>\n        extends AbstractMap<K,V>\n        implements Serializable\n    {\n        private static final long serialVersionUID = 6428348081105594320L;\n        public int size()                          {return 0;}\n        public boolean isEmpty()                   {return true;}\n        public boolean containsKey(Object key)     {return false;}\n        public boolean containsValue(Object value) {return false;}\n        public V get(Object key)                   {return null;}\n        public Set<K> keySet()                     {return emptySet();}\n        public Collection<V> values()              {return emptySet();}\n        public Set<Map.Entry<K,V>> entrySet()      {return emptySet();}\n        public boolean equals(Object o) {\n            return (o instanceof Map) && ((Map<?,?>)o).isEmpty();\n        }\n        public int hashCode()                      {return 0;}\n        // Override default methods in Map\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public V getOrDefault(Object k, V defaultValue) {\n            return defaultValue;\n        }\n        @Override\n        public void forEach(BiConsumer<? super K, ? super V> action) {\n            Objects.requireNonNull(action);\n        }\n        @Override\n        public void replaceAll(BiFunction<? super K, ? super V, ? extends V> function) {\n            Objects.requireNonNull(function);\n        }\n        @Override\n        public V putIfAbsent(K key, V value) {\n            throw new UnsupportedOperationException();\n        }\n        @Override\n        public boolean remove(Object key, Object value) {\n            throw new UnsupportedOperationException();\n        }\n        @Override\n        public boolean replace(K key, V oldValue, V newValue) {\n            throw new UnsupportedOperationException();\n        }\n        @Override\n        public V replace(K key, V value) {\n            throw new UnsupportedOperationException();\n        }\n<fim_suffix>        @Override\n        public V computeIfAbsent(K key,\n                Function<? super K, ? extends V> mappingFunction) {\n            throw new UnsupportedOperationException();\n        }<fim_middle>// function below has no smell\n"}