{"text": "<fim_prefix>/*\n * Copyright 2006-2011 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations under the License.\n */\npackage org.springframework.security.jwt;\nimport static org.springframework.security.jwt.JwtAlgorithms.sigAlg;\nimport static org.springframework.security.jwt.codec.Codecs.b64UrlDecode;\nimport static org.springframework.security.jwt.codec.Codecs.b64UrlEncode;\nimport static org.springframework.security.jwt.codec.Codecs.concat;\nimport static org.springframework.security.jwt.codec.Codecs.utf8Decode;\nimport static org.springframework.security.jwt.codec.Codecs.utf8Encode;\nimport java.nio.CharBuffer;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport org.springframework.security.jwt.crypto.sign.SignatureVerifier;\nimport org.springframework.security.jwt.crypto.sign.Signer;\n/**\n * @author Luke Taylor\n * @author Dave Syer\n */\npublic class JwtHelper {\n\tstatic byte[] PERIOD = utf8Encode(\".\");\n\t/**\n\t * Creates a token from an encoded token string.\n\t *\n\t * @param token the (non-null) encoded token (three Base-64 encoded strings separated\n\t * by \".\" characters)\n\t */\n\tpublic static Jwt decode(String token) {\n\t\tint firstPeriod = token.indexOf('.');\n\t\tint lastPeriod = token.lastIndexOf('.');\n\t\tif (firstPeriod <= 0 || lastPeriod <= firstPeriod) {\n\t\t\tthrow new IllegalArgumentException(\"JWT must have 3 tokens\");\n\t\t}\n\t\tCharBuffer buffer = CharBuffer.wrap(token, 0, firstPeriod);\n\t\t// TODO: Use a Reader which supports CharBuffer\n\t\tJwtHeader header = JwtHeaderHelper.create(buffer.toString());\n\t\tbuffer.limit(lastPeriod).position(firstPeriod + 1);\n\t\tbyte[] claims = b64UrlDecode(buffer);\n\t\tboolean emptyCrypto = lastPeriod == token.length() - 1;\n\t\tbyte[] crypto;\n\t\tif (emptyCrypto) {\n\t\t\tif (!\"none\".equals(header.parameters.alg)) {\n\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\"Signed or encrypted token must have non-empty crypto segment\");\n\t\t\t}\n\t\t\tcrypto = new byte[0];\n\t\t}\n\t\telse {\n\t\t\tbuffer.limit(token.length()).position(lastPeriod + 1);\n\t\t\tcrypto = b64UrlDecode(buffer);\n\t\t}\n\t\treturn new JwtImpl(header, claims, crypto);\n\t}\n\tpublic static Jwt decodeAndVerify(String token, SignatureVerifier verifier) {\n\t\tJwt jwt = decode(token);\n\t\tjwt.verifySignature(verifier);\n\t\treturn jwt;\n\t}\n\tpublic static Map<String, String> headers(String token) {\n\t\tJwtImpl jwt = (JwtImpl) decode(token);\n\t\tMap<String, String> map = new LinkedHashMap<String, String>(jwt.header.parameters.map);\n\t\tmap.put(\"alg\", jwt.header.parameters.alg);\n\t\tif (jwt.header.parameters.typ!=null) {\n\t\t\tmap.put(\"typ\", jwt.header.parameters.typ);\n\t\t}\n\t\treturn map;\n\t}\n\tpublic static Jwt encode(CharSequence content, Signer signer) {\n\t\treturn encode(content, signer, Collections.<String, String>emptyMap());\n\t}\n\tpublic static Jwt encode(CharSequence content, Signer signer,\n\t\t\tMap<String, String> headers) {\n\t\tJwtHeader header = JwtHeaderHelper.create(signer, headers);\n\t\tbyte[] claims = utf8Encode(content);\n\t\tbyte[] crypto = signer\n\t\t\t\t.sign(concat(b64UrlEncode(header.bytes()), PERIOD, b64UrlEncode(claims)));\n\t\treturn new JwtImpl(header, claims, crypto);\n\t}\n}\n/**\n * Helper object for JwtHeader.\n *\n * Handles the JSON parsing and serialization.\n */\nclass JwtHeaderHelper {\n\tstatic JwtHeader create(String header) {\n\t\tbyte[] bytes = b64UrlDecode(header);\n\t\treturn new JwtHeader(bytes, parseParams(bytes));\n\t}\n<fim_suffix>\tstatic JwtHeader create(Signer signer, Map<String, String> params) {\n\t\tMap<String, String> map = new LinkedHashMap<String, String>(params);\n\t\tmap.put(\"alg\", sigAlg(signer.algorithm()));\n\t\tHeaderParameters p = new HeaderParameters(map);\n\t\treturn new JwtHeader(serializeParams(p), p);\n\t}\n\tstatic HeaderParameters parseParams(byte[] header) {\n\t\tMap<String, String> map = parseMap(utf8Decode(header));\n\t\treturn new HeaderParameters(map);\n\t}\n\tprivate static Map<String, String> parseMap(String json) {\n\t\tif (json != null) {\n\t\t\tjson = json.trim();\n\t\t\tif (json.startsWith(\"{\")) {\n\t\t\t\treturn parseMapInternal(json);\n\t\t\t}\n\t\t\telse if (json.equals(\"\")) {\n\t\t\t\treturn new LinkedHashMap<String, String>();\n\t\t\t}\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Invalid JSON (null)\");\n\t}\n\tprivate static Map<String, String> parseMapInternal(String json) {\n\t\tMap<String, String> map = new LinkedHashMap<String, String>();\n\t\tjson = trimLeadingCharacter(trimTrailingCharacter(json, '}'), '{');\n\t\tfor (String pair : json.split(\",\")) {\n\t\t\tString[] values = pair.split(\":\");\n\t\t\tString key = strip(values[0], '\"');\n\t\t\tString value = null;\n\t\t\tif (values.length > 0) {\n\t\t\t\tvalue = strip(values[1], '\"');\n\t\t\t}\n\t\t\tif (map.containsKey(key)) {\n\t\t\t\tthrow new IllegalArgumentException(\"Duplicate '\" + key + \"' field\");\n\t\t\t}\n\t\t\tmap.put(key, value);\n\t\t}\n\t\treturn map;\n\t}\n\tprivate static String strip(String string, char c) {\n\t\treturn trimLeadingCharacter(trimTrailingCharacter(string.trim(), c), c);\n\t}\n\tprivate static String trimTrailingCharacter(String string, char c) {\n\t\tif (string.length() >= 0 && string.charAt(string.length() - 1) == c) {\n\t\t\treturn string.substring(0, string.length() - 1);\n\t\t}\n\t\treturn string;\n\t}\n\tprivate static String trimLeadingCharacter(String string, char c) {\n\t\tif (string.length() >= 0 && string.charAt(0) == c) {\n\t\t\treturn string.substring(1);\n\t\t}\n\t\treturn string;\n\t}\n\tprivate static byte[] serializeParams(HeaderParameters params) {\n\t\tStringBuilder builder = new StringBuilder(\"{\");\n\t\tappendField(builder, \"alg\", params.alg);\n\t\tif (params.typ != null) {\n\t\t\tappendField(builder, \"typ\", params.typ);\n\t\t}\n\t\tfor (Entry<String, String> entry : params.map.entrySet()) {\n\t\t\tappendField(builder, entry.getKey(), entry.getValue());\n\t\t}\n\t\tbuilder.append(\"}\");\n\t\treturn utf8Encode(builder.toString());\n\t}\n\tprivate static void appendField(StringBuilder builder, String name, String value) {\n\t\tif (builder.length() > 1) {\n\t\t\tbuilder.append(\",\");\n\t\t}\n\t\tbuilder.append(\"\\\"\").append(name).append(\"\\\":\\\"\").append(value).append(\"\\\"\");\n\t}\n}\n/**\n * Header part of JWT\n *\n */\nclass JwtHeader implements BinaryFormat {\n\tprivate final byte[] bytes;\n\tfinal HeaderParameters parameters;\n\t/**\n\t * @param bytes the decoded header\n\t * @param parameters the parameter values contained in the header\n\t */\n\tJwtHeader(byte[] bytes, HeaderParameters parameters) {\n\t\tthis.bytes = bytes;\n\t\tthis.parameters = parameters;\n\t}\n\t@Override\n\tpublic byte[] bytes() {\n\t\treturn bytes;\n\t}\n\t@Override\n\tpublic String toString() {\n\t\treturn utf8Decode(bytes);\n\t}\n}\nclass HeaderParameters {\n\tfinal String alg;<fim_middle>// function below has no smell\n"}