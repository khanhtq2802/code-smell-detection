{"text": "<fim_prefix>      }\n      @Override\n      public void clear() {\n        throw new UnsupportedOperationException();\n      }\n      @Override\n      Iterator<E> elementIterator() {\n        final Iterator<Entry<E>> iterator1 = multiset1.entrySet().iterator();\n        return new AbstractIterator<E>() {\n          @Override\n          protected E computeNext() {\n            while (iterator1.hasNext()) {\n              Entry<E> entry1 = iterator1.next();\n              E element = entry1.getElement();\n              if (entry1.getCount() > multiset2.count(element)) {\n                return element;\n              }\n            }\n            return endOfData();\n          }\n        };\n      }\n      @Override\n      Iterator<Entry<E>> entryIterator() {\n        final Iterator<Entry<E>> iterator1 = multiset1.entrySet().iterator();\n        return new AbstractIterator<Entry<E>>() {\n          @Override\n          protected Entry<E> computeNext() {\n            while (iterator1.hasNext()) {\n              Entry<E> entry1 = iterator1.next();\n              E element = entry1.getElement();\n              int count = entry1.getCount() - multiset2.count(element);\n              if (count > 0) {\n                return immutableEntry(element, count);\n              }\n            }\n            return endOfData();\n          }\n        };\n      }\n      @Override\n      int distinctElements() {\n        return Iterators.size(entryIterator());\n      }\n    };\n  }\n  /**\n   * Returns {@code true} if {@code subMultiset.count(o) <= superMultiset.count(o)} for all {@code\n   * o}.\n   *\n   * @since 10.0\n   */\n  @CanIgnoreReturnValue\n  public static boolean containsOccurrences(Multiset<?> superMultiset, Multiset<?> subMultiset) {\n    checkNotNull(superMultiset);\n    checkNotNull(subMultiset);\n    for (Entry<?> entry : subMultiset.entrySet()) {\n      int superCount = superMultiset.count(entry.getElement());\n      if (superCount < entry.getCount()) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Modifies {@code multisetToModify} so that its count for an element {@code e} is at most {@code\n   * multisetToRetain.count(e)}.\n   *\n   * <p>To be precise, {@code multisetToModify.count(e)} is set to {@code\n   * Math.min(multisetToModify.count(e), multisetToRetain.count(e))}. This is similar to {@link\n   * #intersection(Multiset, Multiset) intersection} {@code (multisetToModify, multisetToRetain)},\n   * but mutates {@code multisetToModify} instead of returning a view.\n   *\n   * <p>In contrast, {@code multisetToModify.retainAll(multisetToRetain)} keeps all occurrences of\n   * elements that appear at all in {@code multisetToRetain}, and deletes all occurrences of all\n   * other elements.\n   *\n   * @return {@code true} if {@code multisetToModify} was changed as a result of this operation\n   * @since 10.0\n   */\n  @CanIgnoreReturnValue\n  public static boolean retainOccurrences(\n      Multiset<?> multisetToModify, Multiset<?> multisetToRetain) {\n    return retainOccurrencesImpl(multisetToModify, multisetToRetain);\n  }\n  /** Delegate implementation which cares about the element type. */\n  private static <E> boolean retainOccurrencesImpl(\n      Multiset<E> multisetToModify, Multiset<?> occurrencesToRetain) {\n    checkNotNull(multisetToModify);\n    checkNotNull(occurrencesToRetain);\n    // Avoiding ConcurrentModificationExceptions is tricky.\n    Iterator<Entry<E>> entryIterator = multisetToModify.entrySet().iterator();\n    boolean changed = false;\n    while (entryIterator.hasNext()) {\n      Entry<E> entry = entryIterator.next();\n      int retainCount = occurrencesToRetain.count(entry.getElement());\n      if (retainCount == 0) {\n        entryIterator.remove();\n        changed = true;\n      } else if (retainCount < entry.getCount()) {\n        multisetToModify.setCount(entry.getElement(), retainCount);\n        changed = true;\n      }\n    }\n    return changed;\n  }\n  /**\n   * For each occurrence of an element {@code e} in {@code occurrencesToRemove}, removes one\n   * occurrence of {@code e} in {@code multisetToModify}.\n   *\n   * <p>Equivalently, this method modifies {@code multisetToModify} so that {@code\n   * multisetToModify.count(e)} is set to {@code Math.max(0, multisetToModify.count(e) -\n   * Iterables.frequency(occurrencesToRemove, e))}.\n   *\n   * <p>This is <i>not</i> the same as {@code multisetToModify.} {@link Multiset#removeAll\n   * removeAll}{@code (occurrencesToRemove)}, which removes all occurrences of elements that appear\n   * in {@code occurrencesToRemove}. However, this operation <i>is</i> equivalent to, albeit\n   * sometimes more efficient than, the following:\n   *\n   * <pre>{@code\n   * for (E e : occurrencesToRemove) {\n   *   multisetToModify.remove(e);\n   * }\n   * }</pre>\n   *\n   * @return {@code true} if {@code multisetToModify} was changed as a result of this operation\n   * @since 18.0 (present in 10.0 with a requirement that the second parameter be a {@code\n   *     Multiset})\n   */\n  @CanIgnoreReturnValue\n  public static boolean removeOccurrences(\n      Multiset<?> multisetToModify, Iterable<?> occurrencesToRemove) {\n    if (occurrencesToRemove instanceof Multiset) {\n      return removeOccurrences(multisetToModify, (Multiset<?>) occurrencesToRemove);\n    } else {\n      checkNotNull(multisetToModify);\n      checkNotNull(occurrencesToRemove);\n      boolean changed = false;\n      for (Object o : occurrencesToRemove) {\n        changed |= multisetToModify.remove(o);\n      }\n      return changed;\n    }\n  }\n  /**\n   * For each occurrence of an element {@code e} in {@code occurrencesToRemove}, removes one\n   * occurrence of {@code e} in {@code multisetToModify}.\n   *\n   * <p>Equivalently, this method modifies {@code multisetToModify} so that {@code\n   * multisetToModify.count(e)} is set to {@code Math.max(0, multisetToModify.count(e) -\n   * occurrencesToRemove.count(e))}.\n   *\n   * <p>This is <i>not</i> the same as {@code multisetToModify.} {@link Multiset#removeAll\n   * removeAll}{@code (occurrencesToRemove)}, which removes all occurrences of elements that appear\n   * in {@code occurrencesToRemove}. However, this operation <i>is</i> equivalent to, albeit\n   * sometimes more efficient than, the following:\n   *\n   * <pre>{@code\n   * for (E e : occurrencesToRemove) {\n   *   multisetToModify.remove(e);\n   * }\n   * }</pre>\n   *\n   * @return {@code true} if {@code multisetToModify} was changed as a result of this operation\n   * @since 10.0 (missing in 18.0 when only the overload taking an {@code Iterable} was present)\n   */\n  @CanIgnoreReturnValue\n  public static boolean removeOccurrences(\n      Multiset<?> multisetToModify, Multiset<?> occurrencesToRemove) {\n    checkNotNull(multisetToModify);\n    checkNotNull(occurrencesToRemove);\n    boolean changed = false;\n    Iterator<? extends Entry<?>> entryIterator = multisetToModify.entrySet().iterator();\n    while (entryIterator.hasNext()) {\n      Entry<?> entry = entryIterator.next();\n      int removeCount = occurrencesToRemove.count(entry.getElement());\n      if (removeCount >= entry.getCount()) {\n        entryIterator.remove();\n        changed = true;\n      } else if (removeCount > 0) {\n        multisetToModify.remove(entry.getElement(), removeCount);\n        changed = true;\n      }\n    }\n    return changed;\n  }\n  /**\n   * Implementation of the {@code equals}, {@code hashCode}, and {@code toString} methods of {@link\n   * Multiset.Entry}.\n   */\n  abstract static class AbstractEntry<E> implements Multiset.Entry<E> {\n    /**\n     * Indicates whether an object equals this entry, following the behavior specified in {@link\n     * Multiset.Entry#equals}.\n     */\n<fim_suffix>    @Override\n    public boolean equals(@Nullable Object object) {\n      if (object instanceof Multiset.Entry) {\n        Multiset.Entry<?> that = (Multiset.Entry<?>) object;\n        return this.getCount() == that.getCount()\n            && Objects.equal(this.getElement(), that.getElement());\n      }\n      return false;\n    }<fim_middle>// function below has no smell\n"}