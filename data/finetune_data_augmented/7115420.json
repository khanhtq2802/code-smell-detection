{"text": "<fim_prefix>/*\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.devtools.j2objc.util;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.Iterables;\nimport com.google.common.collect.ListMultimap;\nimport com.google.common.collect.MultimapBuilder;\nimport com.google.devtools.j2objc.types.GeneratedVariableElement;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport javax.lang.model.element.Modifier;\nimport javax.lang.model.element.NestingKind;\nimport javax.lang.model.element.TypeElement;\nimport javax.lang.model.element.VariableElement;\nimport javax.lang.model.type.TypeMirror;\n/**\n * CaptureInfo encapsulates all the implicitly captured fields and constructor params of inner and\n * local classes.\n */\npublic class CaptureInfo {\n  // The implicit outer reference from a non-static inner class to its outer class.\n  private final Map<TypeElement, Capture> outerCaptures = new HashMap<>();\n  // The captured result of the receiver expression of a method reference. For example:\n  // Supplier<String> s = foo::toString;\n  // In this code, the expression \"foo\" must be captured by the generated lambda type.\n  private final Map<TypeElement, Capture> receiverCaptures = new HashMap<>();\n  // Captures for local variables that are referenced from within the local class or lambda.\n  private final ListMultimap<TypeElement, LocalCapture> localCaptures =\n      MultimapBuilder.hashKeys().arrayListValues().build();\n  private final List<VariableElement> implicitEnumParams;\n  private final TypeUtil typeUtil;\n  public CaptureInfo(TypeUtil typeUtil) {\n    implicitEnumParams = ImmutableList.of(\n        GeneratedVariableElement.newParameter(\n            \"__name\", typeUtil.getJavaString().asType(), null),\n        GeneratedVariableElement.newParameter(\"__ordinal\", typeUtil.getInt(), null));\n    this.typeUtil = typeUtil;\n  }\n  /**\n   * Contains the construction parameter and field associated with a captured value.\n   */\n  public static class Capture {\n    protected final VariableElement param;\n    protected VariableElement field;\n    private Capture(VariableElement param) {\n      this.param = param;\n    }\n    public VariableElement getParam() {\n      return param;\n    }\n    public boolean hasField() {\n      return field != null;\n    }\n    public VariableElement getField() {\n      return field;\n    }\n  }\n  private static class LocalCapture extends Capture {\n    private final VariableElement var;\n    private LocalCapture(VariableElement var, VariableElement param) {\n      super(param);\n      this.var = var;\n    }\n  }\n  public boolean needsOuterReference(TypeElement type) {\n    return getOuterField(type) != null;\n  }\n  public boolean needsOuterParam(TypeElement type) {\n    return outerCaptures.containsKey(type) || automaticOuterParam(type);\n  }\n  private Capture getOuterCapture(TypeElement type) {\n    return automaticOuterParam(type) ? getOrCreateOuterCapture(type) : outerCaptures.get(type);\n  }\n  public VariableElement getOuterField(TypeElement type) {\n    Capture outerCapture = outerCaptures.get(type);\n    return outerCapture != null ? outerCapture.field : null;\n  }\n  public VariableElement getReceiverField(TypeElement type) {\n    Capture capture = receiverCaptures.get(type);\n    return capture != null ? capture.field : null;\n  }\n  private <T> void maybeAdd(List<T> list, T elem) {\n    if (elem != null) {\n      list.add(elem);\n    }\n  }\n  public List<Capture> getCaptures(TypeElement type) {\n    List<Capture> captures = new ArrayList<>();\n    maybeAdd(captures, getOuterCapture(type));\n    maybeAdd(captures, receiverCaptures.get(type));\n    captures.addAll(localCaptures.get(type));\n    return captures;\n  }\n  public Iterable<VariableElement> getCaptureFields(TypeElement type) {\n    return Iterables.transform(\n        Iterables.filter(getCaptures(type), Capture::hasField), Capture::getField);\n  }\n  public Iterable<VariableElement> getCapturedVars(TypeElement type) {\n    return Iterables.transform(localCaptures.get(type), capture -> capture.var);\n  }\n  public Iterable<VariableElement> getLocalCaptureFields(TypeElement type) {\n    List<LocalCapture> captures = localCaptures.get(type);\n    return captures == null ? Collections.emptyList()\n        : Iterables.transform(Iterables.filter(captures, Capture::hasField), Capture::getField);\n  }\n  public List<VariableElement> getImplicitEnumParams() {\n    return implicitEnumParams;\n  }\n  /**\n   * Returns all the implicit params that come before explicit params in a constructor.\n   */\n  public Iterable<VariableElement> getImplicitPrefixParams(TypeElement type) {\n    return Iterables.transform(getCaptures(type), Capture::getParam);\n  }\n  /**\n   * returns all the implicit params that come after explicit params in a constructor.\n   */\n<fim_suffix>  public Iterable<VariableElement> getImplicitPostfixParams(TypeElement type) {\n    if (ElementUtil.isEnum(type)) {\n      return implicitEnumParams;\n    }\n    return Collections.emptyList();\n  }\n  public boolean isCapturing(TypeElement type) {\n    return !Iterables.isEmpty(Iterables.filter(getCaptures(type), Capture::hasField));\n  }\n  private static boolean automaticOuterParam(TypeElement type) {\n    return type.getNestingKind() == NestingKind.MEMBER && !ElementUtil.isStatic(type);\n  }\n  private static TypeMirror getDeclaringType(TypeElement type) {\n    TypeElement declaringClass = ElementUtil.getDeclaringClass(type);\n    assert declaringClass != null : \"Cannot find declaring class for \" + type;\n    return declaringClass.asType();\n  }\n  private String getOuterFieldName(TypeElement type) {\n    // Ensure that the new outer field does not conflict with a field in a superclass.\n    TypeElement typeElement = ElementUtil.getSuperclass(type);\n    int suffix = 0;\n    while (typeElement != null) {\n      if (ElementUtil.hasOuterContext(typeElement)) {\n        suffix++;\n      }\n      typeElement = ElementUtil.getSuperclass(typeElement);\n    }\n    return \"this$\" + suffix;\n  }\n  private String getCaptureFieldName(VariableElement var, TypeElement type) {\n    int suffix = 0;\n    while ((type = ElementUtil.getSuperclass(type)) != null && ElementUtil.isLocal(type)) {\n      suffix++;\n    }\n    return \"val\" + (suffix > 0 ? suffix : \"\") + \"$\" + var.getSimpleName().toString();\n  }\n  private Capture getOrCreateOuterCapture(TypeElement type) {\n    Capture capture = outerCaptures.get(type);\n    if (capture == null) {\n      capture = new Capture(\n          GeneratedVariableElement.newParameter(\"outer$\", getDeclaringType(type), type)\n          .setNonnull(true));\n      outerCaptures.put(type, capture);\n    }\n    return capture;\n  }\n  public VariableElement getOrCreateOuterParam(TypeElement type) {\n    return getOrCreateOuterCapture(type).param;\n  }\n  public VariableElement getOrCreateOuterField(TypeElement type) {\n    // Create the outer param since it is required to initialize the field.\n    Capture capture = getOrCreateOuterCapture(type);\n    if (capture.field == null) {\n      capture.field = GeneratedVariableElement.newField(\n          getOuterFieldName(type), getDeclaringType(type), type)\n          .addModifiers(Modifier.PRIVATE, Modifier.FINAL)\n          .setNonnull(true)\n          .setIsWeak(typeUtil.elementUtil().isWeakOuterType(type));\n    }\n    return capture.field;\n  }\n  private LocalCapture getOrCreateLocalCapture(VariableElement var, TypeElement declaringType) {\n    List<LocalCapture> capturesForType = localCaptures.get(declaringType);\n    for (LocalCapture localCapture : capturesForType) {\n      if (var.equals(localCapture.var)) {\n        return localCapture;\n      }\n    }\n    LocalCapture newCapture = new LocalCapture(var, GeneratedVariableElement.newParameter(\n        \"capture$\" + capturesForType.size(), var.asType(), declaringType));\n    capturesForType.add(newCapture);\n    return newCapture;\n  }\n  public VariableElement getOrCreateCaptureParam(VariableElement var, TypeElement declaringType) {<fim_middle>// function below has no smell\n"}