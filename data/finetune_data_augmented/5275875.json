{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.openjpa.util;\nimport java.io.ObjectStreamException;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport org.apache.openjpa.kernel.AutoDetach;\nimport org.apache.openjpa.kernel.Broker;\nimport org.apache.openjpa.kernel.BrokerFactory;\nimport org.apache.openjpa.kernel.DetachedStateManager;\nimport org.apache.openjpa.kernel.OpenJPAStateManager;\n/**\n * HashSet proxy with delay loading capability. Allows non-indexed add and\n * remove operations to occur on an unloaded collection. Operations that require\n * a load will trigger a load.\n */\n@SuppressWarnings({ \"rawtypes\", \"unchecked\" })\npublic class DelayedHashSetProxy extends HashSet implements DelayedProxy, ProxyCollection {\n    private transient OpenJPAStateManager sm;\n    private transient int field;\n    private transient CollectionChangeTracker changeTracker;\n    private transient Class<?> elementType;\n    private transient OpenJPAStateManager _ownerSm;\n    private transient boolean _directAccess = false;\n    private transient BrokerFactory _brokerFactory = null;\n    private transient Broker _broker = null;\n    private transient OpenJPAStateManager _delayedSm;\n    private transient int _delayedField;\n    private transient boolean _detached = false;\n    public DelayedHashSetProxy(Collection<?> paramCollection) {\n        super(paramCollection);\n    }\n    public DelayedHashSetProxy(int paramInt, float paramFloat) {\n        super(paramInt, paramFloat);\n    }\n    public DelayedHashSetProxy(int paramInt) {\n        super(paramInt);\n    }\n    public DelayedHashSetProxy() {\n    }\n    @Override\n    public void setOwner(OpenJPAStateManager paramOpenJPAStateManager,\n            int paramInt) {\n        // If clearing the owner of this proxy, store away what is necessary for\n        // delayed loading\n        if (sm != null && detaching(paramOpenJPAStateManager, paramInt)) {\n            _detached = true;\n            _delayedSm = sm;\n            _delayedField = field;\n        } else {\n            _detached = false;\n        }\n        this.sm = paramOpenJPAStateManager;\n        if (sm != null && sm.getPersistenceCapable() != null) {\n            _ownerSm = (OpenJPAStateManager) sm.getPersistenceCapable()\n                    .pcGetStateManager();\n        }\n        this.field = paramInt;\n        if (sm != null && sm.getContext() != null) {\n            _brokerFactory = sm.getContext().getBroker().getBrokerFactory();\n        }\n    }\n    private boolean detaching(OpenJPAStateManager paramOpenJPAStateManager,\n            int paramInt) {\n        if ((paramOpenJPAStateManager == null && paramInt == -1)\n                || (paramOpenJPAStateManager != null && paramOpenJPAStateManager instanceof DetachedStateManager)) {\n            return true;\n        }\n        return false;\n    }\n    @Override\n    public OpenJPAStateManager getOwner() {\n        return this.sm;\n    }\n    @Override\n    public int getOwnerField() {\n        return this.field;\n    }\n    @Override\n    public ChangeTracker getChangeTracker() {\n        return this.changeTracker;\n    }\n    protected void setChangeTracker(CollectionChangeTracker ct) {\n        changeTracker = ct;\n    }\n<fim_suffix>    @Override\n    public Object copy(Object paramObject) {\n        return new HashSet((Collection) paramObject);\n    }\n    @Override\n    public Class getElementType() {\n        return this.elementType;\n    }\n    protected void setElementType(Class<?> elemType) {\n        elementType = elemType;\n    }\n    @Override\n    public ProxyCollection newInstance(Class paramClass,\n            Comparator paramComparator, boolean paramBoolean1,\n            boolean paramBoolean2) {\n        DelayedHashSetProxy localproxy = new DelayedHashSetProxy();\n        localproxy.elementType = paramClass;\n        if (paramBoolean1)\n            localproxy.changeTracker = new DelayedCollectionChangeTrackerImpl(\n                    localproxy, false, false, paramBoolean2);\n        return localproxy;\n    }\n    @Override\n    public Object clone() {\n        if (isDirectAccess()) {\n            return super.clone();\n        }\n        if (isDelayLoad()) {\n            load();\n        }\n        Proxy localProxy = (Proxy) super.clone();\n        localProxy.setOwner(null, 0);\n        return localProxy;\n    }\n    @Override\n    public boolean add(Object paramObject) {\n        if (_directAccess) {\n            return super.add(paramObject);\n        }\n        ProxyCollections.beforeAdd(this, paramObject);\n        boolean bool = super.add(paramObject);\n        return ProxyCollections.afterAdd(this, paramObject, bool);\n    }\n    @Override\n    public void clear() {\n        if (!_directAccess) {\n            if (isDelayLoad()) {\n                load();\n            }\n            ProxyCollections.beforeClear(this);\n        }\n        super.clear();\n    }\n    @Override\n    public Iterator iterator() {\n        if (_directAccess) {\n            return super.iterator();\n        }\n        if (isDelayLoad()) {\n            load();\n        }\n        Iterator localIterator = super.iterator();\n        return ProxyCollections.afterIterator(this, localIterator);\n    }\n    @Override\n    public boolean remove(Object paramObject) {\n        if (_directAccess) {\n            return super.remove(paramObject);\n        }\n        ProxyCollections.beforeRemove(this, paramObject);\n        setDirectAccess(true);\n        boolean bool = super.remove(paramObject);\n        setDirectAccess(false);\n        return ProxyCollections.afterRemove(this, paramObject, bool);\n    }\n    @Override\n    public boolean removeAll(Collection paramCollection) {\n        if (_directAccess) {\n            return super.removeAll(paramCollection);\n        }\n        return ProxyCollections.removeAll(this, paramCollection);\n    }\n    @Override\n    public boolean addAll(Collection paramCollection) {\n        if (_directAccess) {\n            return super.addAll(paramCollection);\n        }\n        return ProxyCollections.addAll(this, paramCollection);\n    }\n    @Override\n    public boolean retainAll(Collection paramCollection) {\n        if (_directAccess) {\n            return super.retainAll(paramCollection);\n        }\n        if (isDelayLoad()) {\n            load();\n        }\n        return ProxyCollections.retainAll(this, paramCollection);\n    }\n    protected Object writeReplace() throws ObjectStreamException {\n        if (isDelayLoad()) {\n            load();\n        }\n        return Proxies.writeReplace(this, true);\n    }\n    @Override\n    public int size() {\n        if (!_directAccess && isDelayLoad()) {\n            load();\n        }\n        return super.size();\n    }\n    @Override\n    public boolean isEmpty() {\n        if (!_directAccess && isDelayLoad()) {\n            load();\n        }\n        return super.isEmpty();\n    }\n    @Override\n    public boolean contains(Object o) {\n        if (!_directAccess && isDelayLoad()) {\n            load();\n        }\n        return super.contains(o);\n    }\n    @Override\n    public Object[] toArray() {\n        if (!_directAccess && isDelayLoad()) {\n            load();\n        }\n        return super.toArray();\n    }\n    @Override\n    public Object[] toArray(Object[] a) {\n        if (!_directAccess && isDelayLoad()) {\n            load();\n        }\n        return super.toArray(a);\n    }\n    @Override\n    public boolean containsAll(Collection c) {\n        if (!_directAccess && isDelayLoad()) {\n            load();\n        }\n        return super.containsAll(c);\n    }\n    @Override\n    public String toString() {\n        if (!_directAccess && isDelayLoad()) {\n            load();\n        }\n        return super.toString();\n    }\n    @Override\n    public boolean equals(Object paramObject) {\n        if (!_directAccess && isDelayLoad()) {\n            load();\n        }\n        return super.equals(paramObject);\n    }\n    @Override\n    public int hashCode() {\n        if (!_directAccess && isDelayLoad()) {\n            load();\n        }\n        return super.hashCode();\n    }\n    // //////////////////////////////////////\n    // DelayedProxy methods\n    // //////////////////////////////////////\n    @Override\n    public int getDelayedField() {\n        if (field == -1 || _detached) {\n            return _delayedField;\n        }\n        return field;\n    }\n    @Override\n    public OpenJPAStateManager getDelayedOwner() {\n        if (sm == null || _detached) {\n            return _delayedSm;\n        }\n        return sm;\n    }\n    @Override\n    public boolean isDirectAccess() {\n        return _directAccess;<fim_middle>// function below has no smell\n"}