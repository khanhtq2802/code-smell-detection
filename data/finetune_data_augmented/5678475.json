{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.stanbol.commons.jobs.impl;\n\nimport java.io.UnsupportedEncodingException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\n\nimport org.apache.commons.codec.binary.Base64;\nimport org.apache.felix.scr.annotations.Component;\nimport org.apache.felix.scr.annotations.Service;\nimport org.apache.stanbol.commons.jobs.api.Job;\nimport org.apache.stanbol.commons.jobs.api.JobManager;\n/**\n * Implementation of the {@JobManager} interface.\n * \n * @author enridaga\n *\n */\n@Component(immediate = true)\n@Service(JobManager.class)\npublic class JobManagerImpl implements JobManager {\n    private ExecutorService pool;\n    private Map<String,Future<?>> taskMap;\n    private Map<String,String> locations;\n\n    public JobManagerImpl() {\n        this.pool = Executors.newCachedThreadPool();\n        this.taskMap = new HashMap<String,Future<?>>();\n        this.locations = new HashMap<String,String>();\n    }\n\n<fim_suffix>    @Override\n    public String execute(Job job) {\n        String id = JobManagerImpl.buildId(job);\n        Future<?> future = this.pool.submit(job);\n        synchronized (taskMap) {\n            taskMap.put(id, future);\n            locations.put(id, job.buildResultLocation(id));\n            return id;\n        }\n    }\n\n    @Override\n    public Future<?> ping(String id) {\n        synchronized (taskMap) {\n            return taskMap.get(id);            \n        }\n    }\n\n\n    @Override\n    public String getResultLocation(String id) {\n        synchronized (locations) {\n            return locations.get(id);            \n        }\n    }\n\n    @Override\n    public boolean hasJob(String id) {\n        synchronized (taskMap) {\n            return taskMap.containsKey(id);\n        }\n    }\n\n    @Override\n    public int size() {\n        synchronized (taskMap) {\n            return taskMap.size();\n        }\n    }\n\n    @Override\n    public void remove(String id) {\n        synchronized (taskMap) {\n            // If the job does not exists\n            Future<?> f = taskMap.get(id);\n            if(f==null) {\n                throw new IllegalArgumentException(\"Job does not exists\");\n            }\n            f.cancel(true);\n            taskMap.remove(id);\n            synchronized (locations) {\n                locations.remove(id);\n            }\n        }\n    }\n\n    /**\n     * To build a unique string identifier for a background process\n     * \n     * @param obj\n     * @return\n     */\n    public static String buildId(Object obj) {\n        String str = obj.toString();\n        byte[] thedigest = null;\n        try {\n            byte[] bytesOfMessage = str.getBytes(\"UTF-8\");\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            thedigest = md.digest(bytesOfMessage);\n        } catch (UnsupportedEncodingException e) {\n            // This should never happen\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            // This should never happen\n            e.printStackTrace();\n        }\n        return Base64.encodeBase64URLSafeString(thedigest);\n    }\n\n    /**\n     * Removes all jobs\n     */\n    @Override\n    public void removeAll() {\n        String[] ids;\n        synchronized (taskMap) {\n            ids =  taskMap.keySet().toArray(new String[taskMap.keySet().size()]);\n        }\n        for(String j : ids){\n            remove(j);\n        }\n    }\n\n}<fim_middle>// function below has no smell\n"}