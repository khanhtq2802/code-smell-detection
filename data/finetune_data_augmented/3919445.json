{"text": "<fim_prefix>    log.debug(String.format(\"Import Map Files     : %,10.2f secs %6.2f%s\",\n        timer.getSecs(Timers.IMPORT_MAP_FILES),\n        100.0 * timer.get(Timers.IMPORT_MAP_FILES) / timer.get(Timers.TOTAL), \"%\"));\n    log.debug(\n        String.format(\"Sleep                : %,10.2f secs %6.2f%s\", timer.getSecs(Timers.SLEEP),\n            100.0 * timer.get(Timers.SLEEP) / timer.get(Timers.TOTAL), \"%\"));\n    log.debug(String.format(\"Misc                 : %,10.2f secs %6.2f%s\",\n        (timer.get(Timers.TOTAL) - totalTime) / 1000.0,\n        100.0 * (timer.get(Timers.TOTAL) - totalTime) / timer.get(Timers.TOTAL), \"%\"));\n    log.debug(String.format(\"Total                : %,10.2f secs\", timer.getSecs(Timers.TOTAL)));\n  }\n  private Set<Path> processFailures(Map<Path,List<KeyExtent>> completeFailures) {\n    // we should check if map file was not assigned to any tablets, then we\n    // should just move it; not currently being done?\n    Set<Entry<Path,List<KeyExtent>>> es = completeFailures.entrySet();\n    if (completeFailures.size() == 0)\n      return Collections.emptySet();\n    log.debug(\"The following map files failed \");\n    for (Entry<Path,List<KeyExtent>> entry : es) {\n      List<KeyExtent> extents = entry.getValue();\n      for (KeyExtent keyExtent : extents)\n        log.debug(\"\\t{} -> {}\", entry.getKey(), keyExtent);\n    }\n    return Collections.emptySet();\n  }\n  private class AssignmentInfo {\n    public AssignmentInfo(KeyExtent keyExtent, Long estSize) {\n      this.ke = keyExtent;\n      this.estSize = estSize;\n    }\n    KeyExtent ke;\n    long estSize;\n  }\n  private static List<KeyExtent> extentsOf(List<TabletLocation> locations) {\n    List<KeyExtent> result = new ArrayList<>(locations.size());\n    for (TabletLocation tl : locations)\n      result.add(tl.tablet_extent);\n    return result;\n  }\n  private Map<Path,List<AssignmentInfo>> estimateSizes(final VolumeManager vm,\n      Map<Path,List<TabletLocation>> assignments, Collection<Path> paths, int numThreads) {\n    long t1 = System.currentTimeMillis();\n    final Map<Path,Long> mapFileSizes = new TreeMap<>();\n    try {\n      for (Path path : paths) {\n        FileSystem fs = vm.getVolumeByPath(path).getFileSystem();\n        mapFileSizes.put(path, fs.getContentSummary(path).getLength());\n      }\n    } catch (IOException e) {\n      log.error(\"Failed to get map files in for {}: {}\", paths, e.getMessage(), e);\n      throw new RuntimeException(e);\n    }\n    final Map<Path,List<AssignmentInfo>> ais = Collections.synchronizedMap(new TreeMap<>());\n    ExecutorService threadPool = Executors.newFixedThreadPool(numThreads,\n        new NamingThreadFactory(\"estimateSizes\"));\n    for (final Entry<Path,List<TabletLocation>> entry : assignments.entrySet()) {\n      if (entry.getValue().size() == 1) {\n        TabletLocation tabletLocation = entry.getValue().get(0);\n        // if the tablet completely contains the map file, there is no\n        // need to estimate its\n        // size\n        ais.put(entry.getKey(), Collections.singletonList(\n            new AssignmentInfo(tabletLocation.tablet_extent, mapFileSizes.get(entry.getKey()))));\n        continue;\n      }\n      Runnable estimationTask = new Runnable() {\n        @Override\n        public void run() {\n          Map<KeyExtent,Long> estimatedSizes = null;\n          try {\n            estimatedSizes = FileUtil.estimateSizes(context, entry.getKey(),\n                mapFileSizes.get(entry.getKey()), extentsOf(entry.getValue()));\n          } catch (IOException e) {\n            log.warn(\"Failed to estimate map file sizes {}\", e.getMessage());\n          }\n          if (estimatedSizes == null) {\n            // estimation failed, do a simple estimation\n            estimatedSizes = new TreeMap<>();\n            long estSize = (long) (mapFileSizes.get(entry.getKey())\n                / (double) entry.getValue().size());\n            for (TabletLocation tl : entry.getValue())\n              estimatedSizes.put(tl.tablet_extent, estSize);\n          }\n          List<AssignmentInfo> assignmentInfoList = new ArrayList<>(estimatedSizes.size());\n          for (Entry<KeyExtent,Long> entry2 : estimatedSizes.entrySet())\n            assignmentInfoList.add(new AssignmentInfo(entry2.getKey(), entry2.getValue()));\n          ais.put(entry.getKey(), assignmentInfoList);\n        }\n      };\n      threadPool.submit(new TraceRunnable(new LoggingRunnable(log, estimationTask)));\n    }\n    threadPool.shutdown();\n    while (!threadPool.isTerminated()) {\n      try {\n        threadPool.awaitTermination(60, TimeUnit.SECONDS);\n      } catch (InterruptedException e) {\n        log.error(\"Encountered InterruptedException while waiting for the threadPool to terminate.\",\n            e);\n        throw new RuntimeException(e);\n      }\n    }\n    long t2 = System.currentTimeMillis();\n    log.debug(String.format(\"Estimated map files sizes in %6.2f secs\", (t2 - t1) / 1000.0));\n    return ais;\n  }\n  private static Map<KeyExtent,String> locationsOf(Map<Path,List<TabletLocation>> assignments) {\n    Map<KeyExtent,String> result = new HashMap<>();\n    for (List<TabletLocation> entry : assignments.values()) {\n      for (TabletLocation tl : entry) {\n        result.put(tl.tablet_extent, tl.tablet_location);\n      }\n    }\n    return result;\n  }\n  private Map<Path,List<KeyExtent>> assignMapFiles(VolumeManager fs,\n      Map<Path,List<TabletLocation>> assignments, Collection<Path> paths, int numThreads,\n      int numMapThreads) {\n    timer.start(Timers.EXAMINE_MAP_FILES);\n    Map<Path,List<AssignmentInfo>> assignInfo = estimateSizes(fs, assignments, paths,\n        numMapThreads);\n    timer.stop(Timers.EXAMINE_MAP_FILES);\n    Map<Path,List<KeyExtent>> ret;\n    timer.start(Timers.IMPORT_MAP_FILES);\n    ret = assignMapFiles(assignInfo, locationsOf(assignments), numThreads);\n    timer.stop(Timers.IMPORT_MAP_FILES);\n    return ret;\n  }\n<fim_suffix>  private class AssignmentTask implements Runnable {\n    final Map<Path,List<KeyExtent>> assignmentFailures;\n    HostAndPort location;\n    private Map<KeyExtent,List<PathSize>> assignmentsPerTablet;\n    public AssignmentTask(Map<Path,List<KeyExtent>> assignmentFailures, String location,\n        Map<KeyExtent,List<PathSize>> assignmentsPerTablet) {\n      this.assignmentFailures = assignmentFailures;\n      this.location = HostAndPort.fromString(location);\n      this.assignmentsPerTablet = assignmentsPerTablet;\n    }\n    private void handleFailures(Collection<KeyExtent> failures, String message) {\n      for (KeyExtent ke : failures) {\n        List<PathSize> mapFiles = assignmentsPerTablet.get(ke);\n        synchronized (assignmentFailures) {\n          for (PathSize pathSize : mapFiles) {\n            List<KeyExtent> existingFailures = assignmentFailures.get(pathSize.path);\n            if (existingFailures == null) {\n              existingFailures = new ArrayList<>();\n              assignmentFailures.put(pathSize.path, existingFailures);\n            }\n            existingFailures.add(ke);\n          }\n        }\n        log.info(\"Could not assign {} map files to tablet {} because : {}.  Will retry ...\",\n            mapFiles.size(), ke, message);\n      }\n    }\n    @Override\n    public void run() {\n      HashSet<Path> uniqMapFiles = new HashSet<>();\n      for (List<PathSize> mapFiles : assignmentsPerTablet.values())\n        for (PathSize ps : mapFiles)\n          uniqMapFiles.add(ps.path);\n      log.debug(\"Assigning {} map files to {} tablets at {}\", uniqMapFiles.size(),\n          assignmentsPerTablet.size(), location);\n      try {\n        List<KeyExtent> failures = assignMapFiles(context, location, assignmentsPerTablet);\n        handleFailures(failures, \"Not Serving Tablet\");\n      } catch (AccumuloException | AccumuloSecurityException e) {\n        handleFailures(assignmentsPerTablet.keySet(), e.getMessage());\n      }\n    }\n  }<fim_middle>// class below has no smell\n"}