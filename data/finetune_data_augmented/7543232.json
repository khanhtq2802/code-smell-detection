{"text": "<fim_prefix>/*\n * Copyright 2002-2019 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.springframework.integration.router;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport org.springframework.integration.support.management.MappingMessageRouterManagement;\nimport org.springframework.jmx.export.annotation.ManagedAttribute;\nimport org.springframework.jmx.export.annotation.ManagedOperation;\nimport org.springframework.messaging.Message;\nimport org.springframework.messaging.MessageChannel;\nimport org.springframework.messaging.MessagingException;\nimport org.springframework.messaging.core.DestinationResolutionException;\nimport org.springframework.util.Assert;\nimport org.springframework.util.StringUtils;\n/**\n * Base class for all Message Routers that support mapping from arbitrary String values\n * to Message Channel names.\n *\n * @author Mark Fisher\n * @author Oleg Zhurakousky\n * @author Gunnar Hillert\n * @author Gary Russell\n * @author Artem Bilan\n * @since 2.1\n */\npublic abstract class AbstractMappingMessageRouter extends AbstractMessageRouter implements MappingMessageRouterManagement {\n\tprivate static final int DEFAULT_DYNAMIC_CHANNEL_LIMIT = 100;\n\tprivate int dynamicChannelLimit = DEFAULT_DYNAMIC_CHANNEL_LIMIT;\n\t@SuppressWarnings(\"serial\")\n\tprivate final Map<String, MessageChannel> dynamicChannels = Collections.<String, MessageChannel>synchronizedMap(\n\t\t\tnew LinkedHashMap<String, MessageChannel>(DEFAULT_DYNAMIC_CHANNEL_LIMIT, 0.75f, true) {\n\t\t\t\t@Override\n\t\t\t\tprotected boolean removeEldestEntry(Entry<String, MessageChannel> eldest) {\n\t\t\t\t\treturn this.size() > AbstractMappingMessageRouter.this.dynamicChannelLimit;\n\t\t\t\t}\n\t\t\t});\n\tprotected volatile Map<String, String> channelMappings = new ConcurrentHashMap<String, String>();\n\tprivate volatile String prefix;\n\tprivate volatile String suffix;\n\tprivate volatile boolean resolutionRequired = true;\n\t/**\n\t * Provide mappings from channel keys to channel names.\n\t * Channel names will be resolved by the\n\t * {@link org.springframework.messaging.core.DestinationResolver}.\n\t * @param channelMappings The channel mappings.\n\t */\n\t@Override\n\t@ManagedAttribute\n\tpublic void setChannelMappings(Map<String, String> channelMappings) {\n\t\tAssert.notNull(channelMappings, \"'channelMappings' must not be null\");\n\t\tMap<String, String> newChannelMappings = new ConcurrentHashMap<String, String>(channelMappings);\n\t\tdoSetChannelMappings(newChannelMappings);\n\t}\n\t/**\n\t * Specify a prefix to be added to each channel name prior to resolution.\n\t * @param prefix The prefix.\n\t */\n\tpublic void setPrefix(String prefix) {\n\t\tthis.prefix = prefix;\n\t}\n\t/**\n\t * Specify a suffix to be added to each channel name prior to resolution.\n\t * @param suffix The suffix.\n\t */\n\tpublic void setSuffix(String suffix) {\n\t\tthis.suffix = suffix;\n\t}\n\t/**\n\t * Specify whether this router should ignore any failure to resolve a channel name to\n\t * an actual MessageChannel instance when delegating to the ChannelResolver strategy.\n\t * @param resolutionRequired true if resolution is required.\n\t */\n\tpublic void setResolutionRequired(boolean resolutionRequired) {\n\t\tthis.resolutionRequired = resolutionRequired;\n\t}\n\t/**\n\t * Set a limit for how many dynamic channels are retained (for reporting purposes).\n\t * When the limit is exceeded, the oldest channel is discarded.\n\t * <p><b>NOTE: this does not affect routing, just the reporting which dynamically\n\t * resolved channels have been routed to.</b> Default {@code 100}.\n\t * @param dynamicChannelLimit the limit.\n\t * @see #getDynamicChannelNames()\n\t */\n\tpublic void setDynamicChannelLimit(int dynamicChannelLimit) {\n\t\tthis.dynamicChannelLimit = dynamicChannelLimit;\n\t}\n\t/**\n\t * Returns an unmodifiable version of the channel mappings.\n\t * This is intended for use by subclasses only.\n\t * @return The channel mappings.\n\t */\n\t@Override\n\t@ManagedAttribute\n\tpublic Map<String, String> getChannelMappings() {\n\t\treturn new HashMap<String, String>(this.channelMappings);\n\t}\n\t/**\n\t * Add a channel mapping from the provided key to channel name.\n\t * @param key The key.\n\t * @param channelName The channel name.\n\t */\n\t@Override\n\t@ManagedOperation\n\tpublic void setChannelMapping(String key, String channelName) {\n\t\tMap<String, String> newChannelMappings = new ConcurrentHashMap<String, String>(this.channelMappings);\n\t\tnewChannelMappings.put(key, channelName);\n\t\tthis.channelMappings = newChannelMappings;\n\t}\n\t/**\n\t * Remove a channel mapping for the given key if present.\n\t * @param key The key.\n\t */\n<fim_suffix>\t@Override\n\t@ManagedOperation\n\tpublic void removeChannelMapping(String key) {\n\t\tMap<String, String> newChannelMappings = new ConcurrentHashMap<String, String>(this.channelMappings);\n\t\tnewChannelMappings.remove(key);\n\t\tthis.channelMappings = newChannelMappings;\n\t}\n\t@Override\n\t@ManagedAttribute\n\tpublic Collection<String> getDynamicChannelNames() {\n\t\treturn Collections.unmodifiableSet(this.dynamicChannels.keySet());\n\t}\n\t/**\n\t * Subclasses must implement this method to return the channel keys.\n\t * A \"key\" might be present in this router's \"channelMappings\", or it\n\t * could be the channel's name or even the Message Channel instance itself.\n\t * @param message The message.\n\t * @return The channel keys.\n\t */\n\tprotected abstract List<Object> getChannelKeys(Message<?> message);\n\t@Override\n\tprotected Collection<MessageChannel> determineTargetChannels(Message<?> message) {\n\t\tCollection<MessageChannel> channels = new ArrayList<MessageChannel>();\n\t\tCollection<Object> channelKeys = this.getChannelKeys(message);\n\t\taddToCollection(channels, channelKeys, message);\n\t\treturn channels;\n\t}\n\t/**\n\t * Convenience method allowing conversion of a list\n\t * of mappings in a control-bus message.\n\t * <p>This is intended to be called via a control-bus; keys and values that are not\n\t * Strings will be ignored.\n\t * <p>Mappings must be delimited with newlines, for example:\n\t * <p>{@code \"@'myRouter.handler'.replaceChannelMappings('foo=qux \\n baz=bar')\"}.\n\t * @param channelMappings The channel mappings.\n\t * @since 4.0\n\t */\n\t@Override\n\t@ManagedOperation\n\tpublic void replaceChannelMappings(Properties channelMappings) {\n\t\tAssert.notNull(channelMappings, \"'channelMappings' must not be null\");\n\t\tMap<String, String> newChannelMappings = new ConcurrentHashMap<String, String>();\n\t\tSet<String> keys = channelMappings.stringPropertyNames();\n\t\tfor (String key : keys) {\n\t\t\tnewChannelMappings.put(key.trim(), channelMappings.getProperty(key).trim());\n\t\t}\n\t\tthis.doSetChannelMappings(newChannelMappings);\n\t}\n\tprivate void doSetChannelMappings(Map<String, String> newChannelMappings) {\n\t\tMap<String, String> oldChannelMappings = this.channelMappings;\n\t\tthis.channelMappings = newChannelMappings;\n\t\tif (logger.isDebugEnabled()) {\n\t\t\tlogger.debug(\"Channel mappings: \" + oldChannelMappings + \" replaced with: \" + newChannelMappings);\n\t\t}\n\t}\n\tprivate MessageChannel resolveChannelForName(String channelName, Message<?> message) {\n\t\tMessageChannel channel = null;\n\t\ttry {\n\t\t\tchannel = getChannelResolver().resolveDestination(channelName);\n\t\t}\n\t\tcatch (DestinationResolutionException e) {\n\t\t\tif (this.resolutionRequired) {\n\t\t\t\tthrow new MessagingException(message, \"failed to resolve channel name '\" + channelName + \"'\", e);\n\t\t\t}\n\t\t}<fim_middle>// function below has no smell\n"}