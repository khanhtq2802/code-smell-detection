{"text": "<fim_prefix>        appendPage.setFull();\n        initNewPage(logSize);\n    }\n    private void initNewPage(int logSize) {\n        boolean largePage = logSize > logPageSize;\n        // if a new large page will be allocated, we need to stash a normal sized page\n        // since our queues have fixed capacity\n        ensureAvailablePage(largePage);\n        if (largePage) {\n            // for now, alloc a new buffer for each large page\n            // TODO: pool large pages??\n            appendPage = new LogBuffer(txnSubsystem, logSize, flushLSN);\n        } else {\n            appendPage.reset();\n        }\n        appendPage.setFileChannel(appendChannel);\n        flushQ.add(appendPage);\n    }\n    private void ensureAvailablePage(boolean stash) {\n        final ILogBuffer currentPage = appendPage;\n        appendPage = null;\n        try {\n            appendPage = emptyQ.take();\n            if (stash) {\n                stashQ.add(appendPage);\n            }\n        } catch (InterruptedException e) {\n            appendPage = currentPage;\n            Thread.currentThread().interrupt();\n            throw new ACIDException(e);\n        }\n    }\n    private void prepareNextLogFile() {\n        final long nextFileBeginLsn = getNextFileFirstLsn();\n        try {\n            closeCurrentLogFile();\n            createNextLogFile();\n            InvokeUtil.doIoUninterruptibly(() -> setLogPosition(nextFileBeginLsn));\n            // move appendLSN and flushLSN to the first LSN of the next log file\n            // only after the file was created and the channel was positioned successfully\n            appendLSN.set(nextFileBeginLsn);\n            flushLSN.set(nextFileBeginLsn);\n            LOGGER.info(\"Created new txn log file with id({}) starting with LSN = {}\", currentLogFileId,\n                    nextFileBeginLsn);\n        } catch (IOException e) {\n            throw new ACIDException(e);\n        }\n    }\n    private long getNextFileFirstLsn() {\n        // add the remaining space in the current file\n        return appendLSN.get() + (logFileSize - getLogFileOffset(appendLSN.get()));\n    }\n    private void ensureLastPageFlushed() {\n        // Make sure to flush whatever left in the log tail.\n        appendPage.setFull();\n        synchronized (flushLSN) {\n            while (flushLSN.get() != appendLSN.get()) {\n                // notification will come from LogBuffer.internalFlush(.)\n                try {\n                    flushLSN.wait();\n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                    throw new ACIDException(e);\n                }\n            }\n        }\n    }\n    @Override\n    public ILogReader getLogReader(boolean isRecoveryMode) {\n        return new LogReader(this, logFileSize, logPageSize, flushLSN, isRecoveryMode);\n    }\n    public LogManagerProperties getLogManagerProperties() {\n        return logManagerProperties;\n    }\n    public ITransactionSubsystem getTransactionSubsystem() {\n        return txnSubsystem;\n    }\n    @Override\n    public long getAppendLSN() {\n        return appendLSN.get();\n    }\n    @Override\n    public void start() {\n        // no op\n    }\n    @Override\n    public void stop(boolean dumpState, OutputStream os) {\n        terminateLogFlusher();\n        closeCurrentLogFile();\n        if (dumpState) {\n            dumpState(os);\n        }\n    }\n    @Override\n    public void dumpState(OutputStream os) {\n        // #. dump Configurable Variables\n        dumpConfVars(os);\n        // #. dump LSNInfo\n        dumpLSNInfo(os);\n    }\n    private void dumpConfVars(OutputStream os) {\n        try {\n            StringBuilder sb = new StringBuilder();\n            sb.append(\"\\n>>dump_begin\\t>>----- [ConfVars] -----\");\n            sb.append(logManagerProperties.toString());\n            sb.append(\"\\n>>dump_end\\t>>----- [ConfVars] -----\\n\");\n            os.write(sb.toString().getBytes());\n        } catch (Exception e) {\n            // ignore exception and continue dumping as much as possible.\n            if (IS_DEBUG_MODE) {\n                e.printStackTrace();\n            }\n        }\n    }\n    private void dumpLSNInfo(OutputStream os) {\n        try {\n            StringBuilder sb = new StringBuilder();\n            sb.append(\"\\n>>dump_begin\\t>>----- [LSNInfo] -----\");\n            sb.append(\"\\nappendLsn: \" + appendLSN);\n            sb.append(\"\\nflushLsn: \" + flushLSN.get());\n            sb.append(\"\\n>>dump_end\\t>>----- [LSNInfo] -----\\n\");\n            os.write(sb.toString().getBytes());\n        } catch (Exception e) {\n            // ignore exception and continue dumping as much as possible.\n            if (IS_DEBUG_MODE) {\n                e.printStackTrace();\n            }\n        }\n    }\n    private long initializeLogAnchor(long fileId) {\n        final String logFilePath = getLogFilePath(fileId);\n        createFileIfNotExists(logFilePath);\n        final File logFile = new File(logFilePath);\n        long offset = logFile.length();\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(\"initializing log anchor with log file Id: {} at offset: {}\", fileId, offset);\n        }\n        return getLogFileFirstLsn(fileId) + offset;\n    }\n    @Override\n    public void renewLogFiles() {\n        terminateLogFlusher();\n        closeCurrentLogFile();\n        long nextLogFileId = getNextLogFileId();\n        createFileIfNotExists(getLogFilePath(nextLogFileId));\n        final long logFileFirstLsn = getLogFileFirstLsn(nextLogFileId);\n        deleteOldLogFiles(logFileFirstLsn);\n        initializeLogManager(nextLogFileId);\n    }\n    @Override\n    public void deleteOldLogFiles(long checkpointLSN) {\n        Long checkpointLSNLogFileID = getLogFileId(checkpointLSN);\n        List<Long> logFileIds = getOrderedLogFileIds();\n        if (!logFileIds.isEmpty()) {\n            //sort log files from oldest to newest\n            Collections.sort(logFileIds);\n            // remove the last one not to delete the current log file\n            logFileIds.remove(logFileIds.size() - 1);\n            /**\n             * At this point, any future LogReader should read from LSN >= checkpointLSN\n             */\n            for (Long id : logFileIds) {\n                /**\n                 * Stop deletion if:\n                 * The log file which contains the checkpointLSN has been reached.\n                 * The oldest log file being accessed by a LogReader has been reached.\n                 */\n                if (id >= checkpointLSNLogFileID) {\n                    break;\n                }\n                //delete old log file\n                File file = new File(getLogFilePath(id));\n                file.delete();\n                if (LOGGER.isInfoEnabled()) {\n                    LOGGER.info(\"Deleted log file \" + file.getAbsolutePath());\n                }\n            }\n        }\n    }\n    private void terminateLogFlusher() {\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(\"Terminating LogFlusher thread ...\");\n        }\n        logFlusher.terminate();\n        try {\n            futureLogFlusher.get();\n        } catch (ExecutionException | InterruptedException e) {\n            if (LOGGER.isInfoEnabled()) {\n                LOGGER.info(\"---------- warning(begin): LogFlusher thread is terminated abnormally --------\");\n                e.printStackTrace();\n                LOGGER.info(\"---------- warning(end)  : LogFlusher thread is terminated abnormally --------\");\n            }\n        }\n        if (LOGGER.isInfoEnabled()) {\n            LOGGER.info(\"LogFlusher thread is terminated.\");\n        }\n    }\n<fim_suffix>    public List<Long> getOrderedLogFileIds() {\n        File fileLogDir = new File(logDir);\n        String[] logFileNames = null;\n        List<Long> logFileIds = null;\n        if (!fileLogDir.exists()) {\n            LOGGER.log(Level.INFO, \"log dir \" + logDir + \" doesn't exist.  returning empty list\");\n            return Collections.emptyList();\n        }\n        if (!fileLogDir.isDirectory()) {\n            throw new IllegalStateException(\"log dir \" + logDir + \" exists but it is not a directory\");\n        }\n        logFileNames = fileLogDir.list((dir, name) -> name.startsWith(logFilePrefix));\n        if (logFileNames == null) {\n            throw new IllegalStateException(\"listing of log dir (\" + logDir + \") files returned null. \"\n                    + \"Either an IO error occurred or the dir was just deleted by another process/thread\");\n        }\n        if (logFileNames.length == 0) {\n            LOGGER.log(Level.INFO, \"the log dir (\" + logDir + \") is empty. returning empty list\");\n            return Collections.emptyList();\n        }\n        logFileIds = new ArrayList<>();\n        for (String fileName : logFileNames) {\n            logFileIds.add(Long.parseLong(fileName.substring(logFilePrefix.length() + 1)));\n        }\n        logFileIds.sort(Long::compareTo);\n        return logFileIds;\n    }<fim_middle>// function below is long method\n"}