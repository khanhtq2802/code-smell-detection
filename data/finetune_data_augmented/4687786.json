{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.hama.bsp;\n\nimport java.io.DataInput;\nimport java.io.DataOutput;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.apache.hadoop.io.Text;\nimport org.apache.hadoop.io.Writable;\nimport org.apache.hadoop.io.WritableFactories;\nimport org.apache.hadoop.io.WritableFactory;\n\n/**\n * A GroomServerStatus is a BSP primitive. Keeps info on a BSPMaster. The\n * BSPMaster maintains a set of the most recent GroomServerStatus objects for\n * each unique GroomServer it knows about.\n */\n<fim_suffix>public class GroomServerStatus implements Writable {\n  public static final Log LOG = LogFactory.getLog(GroomServerStatus.class);\n\n  static {\n    WritableFactories.setFactory(GroomServerStatus.class,\n        new WritableFactory() {\n          @Override\n          public Writable newInstance() {\n            return new GroomServerStatus();\n          }\n        });\n  }\n\n  String groomName;\n  String rpcServer;\n  String hostName;\n  int failures;\n  List<TaskStatus> taskReports;\n\n  volatile long lastSeen;\n  private int maxTasks;\n\n  public GroomServerStatus() {\n    // taskReports = new ArrayList<TaskStatus>();\n    taskReports = new CopyOnWriteArrayList<TaskStatus>();\n  }\n\n  public GroomServerStatus(String groomName, List<TaskStatus> taskReports,\n      int failures, int maxTasks) {\n    this(groomName, taskReports, failures, maxTasks, \"\", \"\");\n  }\n\n  public GroomServerStatus(String groomName, List<TaskStatus> taskReports,\n      int failures, int maxTasks, String rpc, String hostName) {\n    this.groomName = groomName;\n    this.taskReports = new ArrayList<TaskStatus>(taskReports);\n    this.failures = failures;\n    this.maxTasks = maxTasks;\n    this.rpcServer = rpc;\n    this.hostName = hostName;\n  }\n\n  public String getGroomName() {\n    return groomName;\n  }\n\n  public String getGroomHostName() {\n    return hostName;\n  }\n\n  public String getRpcServer() {\n    return rpcServer;\n  }\n\n  /**\n   * Get the current tasks at the GroomServer. Tasks are tracked by a\n   * {@link TaskStatus} object.\n   * \n   * @return a list of {@link TaskStatus} representing the current tasks at the\n   *         GroomServer.\n   */\n  public List<TaskStatus> getTaskReports() {\n    return taskReports;\n  }\n\n  public int getFailures() {\n    return failures;\n  }\n\n  public long getLastSeen() {\n    return lastSeen;\n  }\n\n  public void setLastSeen(long lastSeen) {\n    this.lastSeen = lastSeen;\n  }\n\n  public int getMaxTasks() {\n    return maxTasks;\n  }\n\n  /**\n   * Return the current BSP Task count\n   */\n  public int countTasks() {\n    int taskCount = 0;\n    for (TaskStatus ts : taskReports) {\n      TaskStatus.State state = ts.getRunState();\n      if (state == TaskStatus.State.RUNNING\n          || state == TaskStatus.State.UNASSIGNED) {\n        taskCount++;\n      }\n    }\n\n    return taskCount;\n  }\n\n  /**\n   * For BSPMaster to distinguish between different GroomServers, because\n   * BSPMaster stores using GroomServerStatus as key.\n   */\n  @Override\n  public int hashCode() {\n    int result = 17;\n    result = 37 * result + groomName.hashCode();\n    result = 37 * result + rpcServer.hashCode();\n    result = 37 * result + hostName.hashCode();\n    /*\n     * result = 37*result + (int)failures; result = 37*result +\n     * taskReports.hashCode(); result = 37*result +\n     * (int)(lastSeen^(lastSeen>>>32)); result = 37*result + (int)maxTasks;\n     */\n    return result;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (o == this)\n      return true;\n    if (null == o)\n      return false;\n    if (getClass() != o.getClass())\n      return false;\n\n    GroomServerStatus s = (GroomServerStatus) o;\n    if (!s.groomName.equals(groomName))\n      return false;\n    if (!s.rpcServer.equals(rpcServer))\n      return false;\n    /*\n     * if(s.failures != failures) return false; if(null == s.taskReports){\n     * if(null != s.taskReports) return false; }else\n     * if(!s.taskReports.equals(taskReports)){ return false; } if(s.lastSeen !=\n     * lastSeen) return false; if(s.maxTasks != maxTasks) return false;\n     */\n    return true;\n  }\n\n  /*\n   * (non-Javadoc)\n   * @see org.apache.hadoop.io.Writable#readFields(java.io.DataInput)\n   */\n  @Override\n  public void readFields(DataInput in) throws IOException {\n    this.groomName = Text.readString(in);\n    this.rpcServer = Text.readString(in);\n    this.hostName = Text.readString(in);\n\n    this.failures = in.readInt();\n    this.maxTasks = in.readInt();\n    taskReports.clear();\n    int numTasks = in.readInt();\n\n    TaskStatus status;\n    for (int i = 0; i < numTasks; i++) {\n      status = new TaskStatus();\n      status.readFields(in);\n      taskReports.add(status);\n    }\n  }\n\n  /*\n   * (non-Javadoc)\n   * @see org.apache.hadoop.io.Writable#write(java.io.DataOutput)\n   */\n  @Override\n  public void write(DataOutput out) throws IOException {\n    Text.writeString(out, groomName);\n    Text.writeString(out, rpcServer);\n    Text.writeString(out, hostName);\n\n    out.writeInt(failures);\n    out.writeInt(maxTasks);\n    out.writeInt(taskReports.size());\n    for (TaskStatus taskStatus : taskReports) {\n      taskStatus.write(out);\n    }\n  }\n\n  public Iterator<TaskStatus> taskReports() {\n    return taskReports.iterator();\n  }\n}<fim_middle>// class below is data class\n"}