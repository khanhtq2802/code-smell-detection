{"text": "<fim_prefix>        builder.addGraphNode(this.streamsGraphNode, printNode);\n    }\n    @Override\n    public <KR, VR> KStream<KR, VR> flatMap(final KeyValueMapper<? super K, ? super V, ? extends Iterable<? extends KeyValue<? extends KR, ? extends VR>>> mapper) {\n        Objects.requireNonNull(mapper, \"mapper can't be null\");\n        final String name = builder.newProcessorName(FLATMAP_NAME);\n        final ProcessorParameters<? super K, ? super V> processorParameters = new ProcessorParameters<>(new KStreamFlatMap<>(mapper), name);\n        final ProcessorGraphNode<? super K, ? super V> flatMapNode = new ProcessorGraphNode<>(name, processorParameters);\n        flatMapNode.keyChangingOperation(true);\n        builder.addGraphNode(this.streamsGraphNode, flatMapNode);\n        // key and value serde cannot be preserved\n        return new KStreamImpl<>(name,\n                                 null,\n                                 null,\n                                 sourceNodes,\n                                 true,\n                                 flatMapNode,\n                                 builder);\n    }\n    @Override\n    public <VR> KStream<K, VR> flatMapValues(final ValueMapper<? super V, ? extends Iterable<? extends VR>> mapper) {\n        return flatMapValues(withKey(mapper));\n    }\n    @Override\n    public <VR> KStream<K, VR> flatMapValues(final ValueMapperWithKey<? super K, ? super V, ? extends Iterable<? extends VR>> mapper) {\n        Objects.requireNonNull(mapper, \"mapper can't be null\");\n        final String name = builder.newProcessorName(FLATMAPVALUES_NAME);\n        final ProcessorParameters<? super K, ? super V> processorParameters = new ProcessorParameters<>(new KStreamFlatMapValues<>(mapper), name);\n        final ProcessorGraphNode<? super K, ? super V> flatMapValuesNode = new ProcessorGraphNode<>(name, processorParameters);\n        flatMapValuesNode.setValueChangingOperation(true);\n        builder.addGraphNode(this.streamsGraphNode, flatMapValuesNode);\n        // value serde cannot be preserved\n        return new KStreamImpl<>(name, keySerde, null, sourceNodes, this.repartitionRequired, flatMapValuesNode, builder);\n    }\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public KStream<K, V>[] branch(final Predicate<? super K, ? super V>... predicates) {\n        if (predicates.length == 0) {\n            throw new IllegalArgumentException(\"you must provide at least one predicate\");\n        }\n        for (final Predicate<? super K, ? super V> predicate : predicates) {\n            Objects.requireNonNull(predicate, \"predicates can't have null values\");\n        }\n        final String branchName = builder.newProcessorName(BRANCH_NAME);\n        final String[] childNames = new String[predicates.length];\n        for (int i = 0; i < predicates.length; i++) {\n            childNames[i] = builder.newProcessorName(BRANCHCHILD_NAME);\n        }\n        final ProcessorParameters processorParameters = new ProcessorParameters<>(new KStreamBranch(predicates.clone(), childNames), branchName);\n        final ProcessorGraphNode<K, V> branchNode = new ProcessorGraphNode<>(branchName, processorParameters);\n        builder.addGraphNode(this.streamsGraphNode, branchNode);\n        final KStream<K, V>[] branchChildren = (KStream<K, V>[]) Array.newInstance(KStream.class, predicates.length);\n        for (int i = 0; i < predicates.length; i++) {\n            final ProcessorParameters innerProcessorParameters = new ProcessorParameters<>(new KStreamPassThrough<K, V>(), childNames[i]);\n            final ProcessorGraphNode<K, V> branchChildNode = new ProcessorGraphNode<>(childNames[i], innerProcessorParameters);\n            builder.addGraphNode(branchNode, branchChildNode);\n            branchChildren[i] = new KStreamImpl<>(childNames[i], keySerde, valSerde, sourceNodes, repartitionRequired, branchChildNode, builder);\n        }\n        return branchChildren;\n    }\n    @Override\n    public KStream<K, V> merge(final KStream<K, V> stream) {\n        Objects.requireNonNull(stream);\n        return merge(builder, stream);\n    }\n    private KStream<K, V> merge(final InternalStreamsBuilder builder,\n                                final KStream<K, V> stream) {\n        final KStreamImpl<K, V> streamImpl = (KStreamImpl<K, V>) stream;\n        final String name = builder.newProcessorName(MERGE_NAME);\n        final Set<String> allSourceNodes = new HashSet<>();\n        final boolean requireRepartitioning = streamImpl.repartitionRequired || repartitionRequired;\n        allSourceNodes.addAll(sourceNodes);\n        allSourceNodes.addAll(streamImpl.sourceNodes);\n        final ProcessorParameters<? super K, ? super V> processorParameters = new ProcessorParameters<>(new KStreamPassThrough<>(), name);\n        final ProcessorGraphNode<? super K, ? super V> mergeNode = new ProcessorGraphNode<>(name, processorParameters);\n        mergeNode.setMergeNode(true);\n        builder.addGraphNode(Arrays.asList(this.streamsGraphNode, streamImpl.streamsGraphNode), mergeNode);\n        // drop the serde as we cannot safely use either one to represent both streams\n        return new KStreamImpl<>(name, null, null, allSourceNodes, requireRepartitioning, mergeNode, builder);\n    }\n    @Override\n    public void foreach(final ForeachAction<? super K, ? super V> action) {\n        Objects.requireNonNull(action, \"action can't be null\");\n        final String name = builder.newProcessorName(FOREACH_NAME);\n        final ProcessorParameters<? super K, ? super V> processorParameters = new ProcessorParameters<>(\n            new KStreamPeek<>(action, false),\n            name\n        );\n        final ProcessorGraphNode<? super K, ? super V> foreachNode = new ProcessorGraphNode<>(name, processorParameters);\n        builder.addGraphNode(this.streamsGraphNode, foreachNode);\n    }\n    @Override\n    public KStream<K, V> peek(final ForeachAction<? super K, ? super V> action) {\n        Objects.requireNonNull(action, \"action can't be null\");\n        final String name = builder.newProcessorName(PEEK_NAME);\n        final ProcessorParameters<? super K, ? super V> processorParameters = new ProcessorParameters<>(\n            new KStreamPeek<>(action, true),\n            name\n        );\n        final ProcessorGraphNode<? super K, ? super V> peekNode = new ProcessorGraphNode<>(name, processorParameters);\n        builder.addGraphNode(this.streamsGraphNode, peekNode);\n        return new KStreamImpl<>(name, keySerde, valSerde, sourceNodes, repartitionRequired, peekNode, builder);\n    }\n    @Override\n    public KStream<K, V> through(final String topic) {\n        return through(topic, Produced.with(null, null, null));\n    }\n    @Override\n    public KStream<K, V> through(final String topic, final Produced<K, V> produced) {\n        final ProducedInternal<K, V> producedInternal = new ProducedInternal<>(produced);\n        to(topic, producedInternal);\n        return builder.stream(\n            Collections.singleton(topic),\n            new ConsumedInternal<>(\n                producedInternal.keySerde() != null ? producedInternal.keySerde() : keySerde,\n                producedInternal.valueSerde() != null ? producedInternal.valueSerde() : valSerde,\n                new FailOnInvalidTimestamp(),\n                null\n            )\n        );\n    }\n    @Override\n    public void to(final String topic) {\n        to(topic, Produced.with(null, null, null));\n    }\n    @Override\n    public void to(final String topic, final Produced<K, V> produced) {\n        Objects.requireNonNull(topic, \"topic can't be null\");\n        Objects.requireNonNull(produced, \"Produced can't be null\");\n        to(new StaticTopicNameExtractor<>(topic), new ProducedInternal<>(produced));\n    }\n    @Override\n    public void to(final TopicNameExtractor<K, V> topicExtractor) {\n        to(topicExtractor, Produced.with(null, null, null));\n    }\n    @Override\n    public void to(final TopicNameExtractor<K, V> topicExtractor, final Produced<K, V> produced) {\n        Objects.requireNonNull(topicExtractor, \"topic extractor can't be null\");\n        Objects.requireNonNull(produced, \"Produced can't be null\");\n        to(topicExtractor, new ProducedInternal<>(produced));\n    }\n<fim_suffix>    private void to(final TopicNameExtractor<K, V> topicExtractor, final ProducedInternal<K, V> produced) {\n        final String name = builder.newProcessorName(SINK_NAME);\n        final StreamSinkNode<K, V> sinkNode = new StreamSinkNode<>(\n            name,\n            topicExtractor,\n            produced\n        );\n        builder.addGraphNode(this.streamsGraphNode, sinkNode);\n    }<fim_middle>// function below has no smell\n"}