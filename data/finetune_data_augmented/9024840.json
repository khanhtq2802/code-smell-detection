{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.solr.core;\n\nimport java.lang.invoke.MethodHandles;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Observer;\nimport java.util.Set;\n\nimport org.apache.solr.common.util.NamedList;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n<fim_suffix>public class TransientSolrCoreCacheDefault extends TransientSolrCoreCache {\n\n  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n\n  private int cacheSize = NodeConfig.NodeConfigBuilder.DEFAULT_TRANSIENT_CACHE_SIZE;\n\n  protected Observer observer;\n  protected CoreContainer coreContainer;\n\n  protected final Map<String, CoreDescriptor> transientDescriptors = new LinkedHashMap<>();\n\n  //WARNING! The _only_ place you put anything into the list of transient cores is with the putTransientCore method!\n  protected Map<String, SolrCore> transientCores = new LinkedHashMap<>(); // For \"lazily loaded\" cores\n\n  /**\n   * @param container The enclosing CoreContainer. It allows us to access everything we need.\n   */\n  public TransientSolrCoreCacheDefault(final CoreContainer container) {\n    this.coreContainer = container;\n    this.observer= coreContainer.solrCores;\n    \n    NodeConfig cfg = container.getNodeConfig();\n    if (cfg.getTransientCachePluginInfo() == null) {\n      // Still handle just having transientCacheSize defined in the body of solr.xml  not in a transient handler clause.\n      // deprecate this for 7.0?\n      this.cacheSize = cfg.getTransientCacheSize();\n    } else {\n      NamedList args = cfg.getTransientCachePluginInfo().initArgs;\n      Object obj = args.get(\"transientCacheSize\");\n      if (obj != null) {\n        this.cacheSize = (int) obj;\n      }\n    }\n    doInit();\n  }\n  // This just moves the \n  private void doInit() {\n    NodeConfig cfg = coreContainer.getNodeConfig();\n    if (cfg.getTransientCachePluginInfo() == null) {\n      // Still handle just having transientCacheSize defined in the body of solr.xml not in a transient handler clause.\n      this.cacheSize = cfg.getTransientCacheSize();\n    } else {\n      NamedList args = cfg.getTransientCachePluginInfo().initArgs;\n      Object obj = args.get(\"transientCacheSize\");\n      if (obj != null) {\n        this.cacheSize = (int) obj;\n      }\n    }\n\n    log.info(\"Allocating transient cache for {} transient cores\", cacheSize);\n    addObserver(this.observer);\n    // it's possible for cache\n    if (cacheSize < 0) { // Trap old flag\n      cacheSize = Integer.MAX_VALUE;\n    }\n    // Now don't allow ridiculous allocations here, if the size is > 1,000, we'll just deal with\n    // adding cores as they're opened. This blows up with the marker value of -1.\n    transientCores = new LinkedHashMap<String, SolrCore>(Math.min(cacheSize, 1000), 0.75f, true) {\n      @Override\n      protected boolean removeEldestEntry(Map.Entry<String, SolrCore> eldest) {\n        if (size() > cacheSize) {\n          SolrCore coreToClose = eldest.getValue();\n          setChanged();\n          notifyObservers(coreToClose);\n          log.info(\"Closing transient core [{}]\", coreToClose.getName());\n          return true;\n        }\n        return false;\n      }\n    };\n  }\n\n  \n  @Override\n  public Collection<SolrCore> prepareForShutdown() {\n    // Returna copy of the values\n    List<SolrCore> ret = new ArrayList(transientCores.values());\n    transientCores.clear();\n    return ret;\n  }\n\n  @Override\n  public CoreContainer getContainer() { return this.coreContainer; }\n\n  @Override\n  public SolrCore addCore(String name, SolrCore core) {\n    return transientCores.put(name, core);\n  }\n\n  @Override\n  public Set<String> getAllCoreNames() {\n    return transientDescriptors.keySet();\n  }\n  \n  @Override\n  public Set<String> getLoadedCoreNames() {\n    return transientCores.keySet();\n  }\n\n  // Remove a core from the internal structures, presumably it \n  // being closed. If the core is re-opened, it will be readded by CoreContainer.\n  @Override\n  public SolrCore removeCore(String name) {\n    return transientCores.remove(name);\n  }\n\n  // Get the core associated with the name. Return null if you don't want this core to be used.\n  @Override\n  public SolrCore getCore(String name) {\n    return transientCores.get(name);\n  }\n\n  @Override\n  public boolean containsCore(String name) {\n    return transientCores.containsKey(name);\n  }\n\n  // These methods allow the implementation to maintain control over the core descriptors.\n\n\n  // This method will only be called during core discovery at startup.\n  @Override\n  public void addTransientDescriptor(String rawName, CoreDescriptor cd) {\n    transientDescriptors.put(rawName, cd);\n  }\n\n  // This method is used when opening cores and the like. If you want to change a core's descriptor, override this\n  // method and return the current core descriptor.\n  @Override\n  public CoreDescriptor getTransientDescriptor(String name) {\n    return transientDescriptors.get(name);\n  }\n\n  @Override\n  public CoreDescriptor removeTransientDescriptor(String name) {\n    return transientDescriptors.remove(name);\n  }\n\n  @Override\n  public List<String> getNamesForCore(SolrCore core) {\n    List<String> ret = new ArrayList<>();\n    for (Map.Entry<String, SolrCore> entry : transientCores.entrySet()) {\n      if (core == entry.getValue()) {\n        ret.add(entry.getKey());\n      }\n    }\n    return ret;\n  }\n\n  /**\n   * Must be called in order to free resources!\n   */\n  @Override\n  public void close() {\n    deleteObserver(this.observer);\n  }\n\n\n  // For custom implementations to communicate arbitrary information as necessary.\n  @Override\n  public int getStatus(String coreName) { return 0; } //no_op for default handler.\n\n  @Override\n  public void setStatus(String coreName, int status) {} //no_op for default handler.\n\n}<fim_middle>// class below has no smell\n"}