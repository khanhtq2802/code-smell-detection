{"text": "<fim_prefix>import static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.COMPOSITE;\nimport static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.HINT;\nimport static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.REG;\nimport static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.STACK;\nimport static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.UNINITIALIZED;\nimport static org.graalvm.compiler.lir.LIRValueUtil.asJavaConstant;\nimport static org.graalvm.compiler.lir.LIRValueUtil.isJavaConstant;\nimport org.graalvm.compiler.asm.aarch64.AArch64Address;\nimport org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler;\nimport org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler.ScratchRegister;\nimport org.graalvm.compiler.core.common.LIRKind;\nimport org.graalvm.compiler.core.common.type.DataPointerConstant;\nimport org.graalvm.compiler.debug.GraalError;\nimport org.graalvm.compiler.lir.LIRFrameState;\nimport org.graalvm.compiler.lir.LIRInstructionClass;\nimport org.graalvm.compiler.lir.Opcode;\nimport org.graalvm.compiler.lir.StandardOp;\nimport org.graalvm.compiler.lir.StandardOp.LoadConstantOp;\nimport org.graalvm.compiler.lir.StandardOp.NullCheck;\nimport org.graalvm.compiler.lir.StandardOp.ValueMoveOp;\nimport org.graalvm.compiler.lir.VirtualStackSlot;\nimport org.graalvm.compiler.lir.asm.CompilationResultBuilder;\nimport jdk.vm.ci.aarch64.AArch64Kind;\nimport jdk.vm.ci.code.MemoryBarriers;\nimport jdk.vm.ci.code.Register;\nimport jdk.vm.ci.code.StackSlot;\nimport jdk.vm.ci.meta.AllocatableValue;\nimport jdk.vm.ci.meta.Constant;\nimport jdk.vm.ci.meta.JavaConstant;\nimport jdk.vm.ci.meta.PlatformKind;\nimport jdk.vm.ci.meta.Value;\npublic class AArch64Move {\n    public static class LoadInlineConstant extends AArch64LIRInstruction implements LoadConstantOp {\n        public static final LIRInstructionClass<LoadInlineConstant> TYPE = LIRInstructionClass.create(LoadInlineConstant.class);\n        private JavaConstant constant;\n        @Def({REG, STACK}) AllocatableValue result;\n        public LoadInlineConstant(JavaConstant constant, AllocatableValue result) {\n            super(TYPE);\n            this.constant = constant;\n            this.result = result;\n        }\n        @Override\n        public void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {\n            if (isRegister(result)) {\n                const2reg(crb, masm, result, constant);\n            } else if (isStackSlot(result)) {\n                StackSlot slot = asStackSlot(result);\n                const2stack(crb, masm, slot, constant);\n            }\n        }\n        @Override\n        public Constant getConstant() {\n            return constant;\n        }\n        @Override\n        public AllocatableValue getResult() {\n            return result;\n        }\n    }\n    @Opcode(\"MOVE\")\n    public static class Move extends AArch64LIRInstruction implements ValueMoveOp {\n        public static final LIRInstructionClass<Move> TYPE = LIRInstructionClass.create(Move.class);\n        @Def({REG, STACK, HINT}) protected AllocatableValue result;\n        @Use({REG, STACK}) protected AllocatableValue input;\n        public Move(AllocatableValue result, AllocatableValue input) {\n            super(TYPE);\n            this.result = result;\n            this.input = input;\n            assert !(isStackSlot(result) && isStackSlot(input));\n        }\n        @Override\n        public void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {\n            move(crb, masm, getResult(), getInput());\n        }\n        @Override\n        public AllocatableValue getInput() {\n            return input;\n        }\n        @Override\n        public AllocatableValue getResult() {\n            return result;\n        }\n    }\n    public static class LoadAddressOp extends AArch64LIRInstruction {\n        public static final LIRInstructionClass<LoadAddressOp> TYPE = LIRInstructionClass.create(LoadAddressOp.class);\n        @Def protected AllocatableValue result;\n        @Use(COMPOSITE) protected AArch64AddressValue address;\n        public LoadAddressOp(AllocatableValue result, AArch64AddressValue address) {\n            super(TYPE);\n            this.result = result;\n            this.address = address;\n        }\n        @Override\n        public void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {\n            Register dst = asRegister(result);\n            AArch64Address adr = address.toAddress();\n            masm.loadAddress(dst, adr, address.getScaleFactor());\n        }\n    }\n    public static class LoadDataOp extends AArch64LIRInstruction {\n        public static final LIRInstructionClass<LoadDataOp> TYPE = LIRInstructionClass.create(LoadDataOp.class);\n        @Def protected AllocatableValue result;\n        private final DataPointerConstant data;\n        public LoadDataOp(AllocatableValue result, DataPointerConstant data) {\n            super(TYPE);\n            this.result = result;\n            this.data = data;\n        }\n        @Override\n        public void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {\n            Register dst = asRegister(result);\n            if (crb.compilationResult.isImmutablePIC()) {\n                crb.recordDataReferenceInCode(data);\n                masm.addressOf(dst);\n            } else {\n                masm.loadAddress(dst, (AArch64Address) crb.recordDataReferenceInCode(data), data.getAlignment());\n            }\n        }\n    }\n    public static class StackLoadAddressOp extends AArch64LIRInstruction {\n        public static final LIRInstructionClass<StackLoadAddressOp> TYPE = LIRInstructionClass.create(StackLoadAddressOp.class);\n        @Def protected AllocatableValue result;\n        @Use({STACK, UNINITIALIZED}) protected AllocatableValue slot;\n        public StackLoadAddressOp(AllocatableValue result, AllocatableValue slot) {\n            super(TYPE);\n            assert slot instanceof VirtualStackSlot || slot instanceof StackSlot;\n            this.result = result;\n            this.slot = slot;\n        }\n        @Override\n        public void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {\n            try (ScratchRegister addrReg = masm.getScratchRegister()) {\n                AArch64Address address = loadStackSlotAddress(crb, masm, (StackSlot) slot, addrReg.getRegister());\n                PlatformKind kind = AArch64Kind.QWORD;\n                masm.loadAddress(asRegister(result, kind), address, kind.getSizeInBytes());\n            }\n        }\n    }\n<fim_suffix>    public static class MembarOp extends AArch64LIRInstruction {\n        public static final LIRInstructionClass<MembarOp> TYPE = LIRInstructionClass.create(MembarOp.class);\n        // For future use.\n        @SuppressWarnings(\"unused\") private final int barriers;\n        public MembarOp(int barriers) {\n            super(TYPE);\n            this.barriers = barriers;\n        }\n        @Override\n        // The odd-looking @SuppressWarnings(\"all\") is here because of\n        // a compiler bug which warns that crb is unused, and also\n        // warns that @SuppressWarnings(\"unused\") is unnecessary.\n        public void emitCode(@SuppressWarnings(\"all\") CompilationResultBuilder crb, AArch64MacroAssembler masm) {\n            assert barriers >= MemoryBarriers.LOAD_LOAD && barriers <= (MemoryBarriers.STORE_STORE | MemoryBarriers.STORE_LOAD | MemoryBarriers.LOAD_STORE | MemoryBarriers.LOAD_LOAD);\n            switch (barriers) {\n                case MemoryBarriers.STORE_STORE:\n                    masm.dmb(AArch64MacroAssembler.BarrierKind.STORE_STORE);\n                    break;\n                case MemoryBarriers.LOAD_LOAD:\n                case MemoryBarriers.LOAD_STORE:\n                case MemoryBarriers.LOAD_LOAD | MemoryBarriers.LOAD_STORE:\n                    masm.dmb(AArch64MacroAssembler.BarrierKind.LOAD_LOAD);\n                    break;\n                default:\n                    masm.dmb(AArch64MacroAssembler.BarrierKind.ANY_ANY);\n                    break;\n            }\n        }\n    }<fim_middle>// class below has no smell\n"}