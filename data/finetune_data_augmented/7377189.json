{"text": "<fim_prefix> * a package with a JSR-305 meta annotation such as Spring's {@link NonNullApi}. All types of the package inherit the\n * package rule. Subpackages do not inherit nullability rules and must be annotated themself.\n *\n * <pre class=\"code\">\n * &#64;org.springframework.lang.NonNullApi\n * package com.example;\n * </pre>\n *\n * {@link Nullable} selectively permits {@literal null} values for method return values or method parameters by\n * annotating the method respectively the parameters:\n *\n * <pre class=\"code\">\n * public class ExampleClass {\n *\n * \tString shouldNotReturnNull(@Nullable String acceptsNull, String doesNotAcceptNull) {\n * \t\t// \u2026\n * \t}\n *\n * \t&#64;Nullable\n * \tString nullableReturn(String parameter) {\n * \t\t// \u2026\n * \t}\n * }\n * </pre>\n * <p/>\n * {@link javax.annotation.Nonnull} is suitable for composition of meta-annotations and expresses via\n * {@link Nonnull#when()} in which cases non-nullability is applicable.\n *\n * @author Mark Paluch\n * @since 2.0\n * @see NonNullApi\n * @see Nullable\n * @see Nonnull\n */\n@UtilityClass\npublic class NullableUtils {\n\tprivate static final String NON_NULL_CLASS_NAME = \"javax.annotation.Nonnull\";\n\tprivate static final String TYPE_QUALIFIER_CLASS_NAME = \"javax.annotation.meta.TypeQualifierDefault\";\n\tprivate static final Optional<Class<Annotation>> NON_NULL_ANNOTATION_CLASS = findClass(NON_NULL_CLASS_NAME);\n\tprivate static final Set<Class<?>> NULLABLE_ANNOTATIONS = findClasses(Nullable.class.getName());\n\tprivate static final Set<Class<?>> NON_NULLABLE_ANNOTATIONS = findClasses(\"reactor.util.lang.NonNullApi\",\n\t\t\tNonNullApi.class.getName());\n\tprivate static final Set<String> WHEN_NULLABLE = new HashSet<>(Arrays.asList(\"UNKNOWN\", \"MAYBE\", \"NEVER\"));\n\tprivate static final Set<String> WHEN_NON_NULLABLE = new HashSet<>(Collections.singletonList(\"ALWAYS\"));\n\t/**\n\t * Determine whether {@link ElementType} in the scope of {@link Method} requires non-{@literal null} values.\n\t * Non-nullability rules are discovered from class and package annotations. Non-null is applied when\n\t * {@link javax.annotation.Nonnull} is set to {@link javax.annotation.meta.When#ALWAYS}.\n\t *\n\t * @param type the class to inspect.\n\t * @param elementType the element type.\n\t * @return {@literal true} if {@link ElementType} allows {@literal null} values by default.\n\t * @see #isNonNull(Annotation, ElementType)\n\t */\n\tpublic boolean isNonNull(Method method, ElementType elementType) {\n\t\treturn isNonNull(method.getDeclaringClass(), elementType) || isNonNull((AnnotatedElement) method, elementType);\n\t}\n\t/**\n\t * Determine whether {@link ElementType} in the scope of {@code type} requires non-{@literal null} values.\n\t * Non-nullability rules are discovered from class and package annotations. Non-null is applied when\n\t * {@link javax.annotation.Nonnull} is set to {@link javax.annotation.meta.When#ALWAYS}.\n\t *\n\t * @param type the class to inspect.\n\t * @param elementType the element type.\n\t * @return {@literal true} if {@link ElementType} allows {@literal null} values by default.\n\t * @see #isNonNull(Annotation, ElementType)\n\t */\n\tpublic boolean isNonNull(Class<?> type, ElementType elementType) {\n\t\treturn isNonNull(type.getPackage(), elementType) || isNonNull((AnnotatedElement) type, elementType);\n\t}\n\t/**\n\t * Determine whether {@link ElementType} in the scope of {@link AnnotatedElement} requires non-{@literal null} values.\n\t * This method determines default {@link javax.annotation.Nonnull nullability} rules from the annotated element\n\t *\n\t * @param element the scope of declaration, may be a {@link Package}, {@link Class}, or\n\t *          {@link java.lang.reflect.Method}.\n\t * @param elementType the element type.\n\t * @return {@literal true} if {@link ElementType} allows {@literal null} values by default.\n\t */\n\tpublic boolean isNonNull(AnnotatedElement element, ElementType elementType) {\n\t\tfor (Annotation annotation : element.getAnnotations()) {\n\t\t\tboolean isNonNull = NON_NULL_ANNOTATION_CLASS.isPresent() ? isNonNull(annotation, elementType)\n\t\t\t\t\t: NON_NULLABLE_ANNOTATIONS.contains(annotation.annotationType());\n\t\t\tif (isNonNull) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tprivate static boolean isNonNull(Annotation annotation, ElementType elementType) {\n\t\tif (!NON_NULL_ANNOTATION_CLASS.isPresent()) {\n\t\t\treturn false;\n\t\t}\n\t\tClass<Annotation> annotationClass = NON_NULL_ANNOTATION_CLASS.get();\n\t\tif (annotation.annotationType().equals(annotationClass)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!AnnotationUtils.isAnnotationMetaPresent(annotation.annotationType(), annotationClass)\n\t\t\t\t|| !isNonNull(annotation)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn test(annotation, TYPE_QUALIFIER_CLASS_NAME, \"value\",\n\t\t\t\t(ElementType[] o) -> Arrays.binarySearch(o, elementType) >= 0);\n\t}\n\t/**\n\t * Determine whether a {@link MethodParameter} is explicitly annotated to be considered nullable. Nullability rules\n\t * are discovered from method and parameter annotations. A {@link MethodParameter} is considered nullable when\n\t * {@link javax.annotation.Nonnull} is set to one of {@link javax.annotation.meta.When#UNKNOWN},\n\t * {@link javax.annotation.meta.When#NEVER}, or {@link javax.annotation.meta.When#MAYBE}.\n\t *\n\t * @param methodParameter the method parameter to inspect.\n\t * @return {@literal true} if the parameter is nullable, {@literal false} otherwise.\n\t */\n\tpublic static boolean isExplicitNullable(MethodParameter methodParameter) {\n\t\tif (methodParameter.getParameterIndex() == -1) {\n\t\t\treturn isExplicitNullable(methodParameter.getMethodAnnotations());\n\t\t}\n\t\treturn isExplicitNullable(methodParameter.getParameterAnnotations());\n\t}\n\tprivate static boolean isExplicitNullable(Annotation[] annotations) {\n\t\tfor (Annotation annotation : annotations) {\n\t\t\tboolean isNullable = NON_NULL_ANNOTATION_CLASS.isPresent() ? isNullable(annotation)\n\t\t\t\t\t: NULLABLE_ANNOTATIONS.contains(annotation.annotationType());\n\t\t\tif (isNullable) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t/**\n\t * Introspect {@link Annotation} for being either a meta-annotation composed from {@link Nonnull} or {@link Nonnull}\n\t * itself expressing non-nullability.\n\t *\n\t * @param annotation\n\t * @return {@literal true} if the annotation expresses non-nullability.\n\t */\n\tprivate static boolean isNonNull(Annotation annotation) {\n\t\treturn test(annotation, NON_NULL_CLASS_NAME, \"when\", o -> WHEN_NON_NULLABLE.contains(o.toString()));\n\t}\n\t/**\n\t * Introspect {@link Annotation} for being either a meta-annotation composed from {@link Nonnull} or {@link Nonnull}\n\t * itself expressing nullability.\n\t *\n\t * @param annotation\n\t * @return {@literal true} if the annotation expresses nullability.\n\t */\n\tprivate static boolean isNullable(Annotation annotation) {\n\t\treturn test(annotation, NON_NULL_CLASS_NAME, \"when\", o -> WHEN_NULLABLE.contains(o.toString()));\n\t}\n<fim_suffix>\t@SuppressWarnings(\"unchecked\")\n\tprivate static <T> boolean test(Annotation annotation, String metaAnnotationName, String attribute,\n\t\t\tPredicate<T> filter) {\n\t\tif (annotation.annotationType().getName().equals(metaAnnotationName)) {\n\t\t\tMap<String, Object> attributes = AnnotationUtils.getAnnotationAttributes(annotation);\n\t\t\treturn !attributes.isEmpty() && filter.test((T) attributes.get(attribute));\n\t\t}\n\t\tMultiValueMap<String, Object> attributes = AnnotatedElementUtils\n\t\t\t\t.getAllAnnotationAttributes(annotation.annotationType(), metaAnnotationName);\n\t\tif (attributes == null || attributes.isEmpty()) {\n\t\t\treturn false;\n\t\t}\n\t\tList<Object> elementTypes = attributes.get(attribute);\n\t\tfor (Object value : elementTypes) {\n\t\t\tif (filter.test((T) value)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}<fim_middle>// function below has no smell\n"}