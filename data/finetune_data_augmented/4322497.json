{"text": "<fim_prefix>/*\n Derby - Class org.apache.derbyTesting.system.nstest.tester.TesterObject\n Licensed to the Apache Software Foundation (ASF) under one or more\n contributor license agreements.  See the NOTICE file distributed with\n this work for additional information regarding copyright ownership.\n The ASF licenses this file to You under the Apache License, Version 2.0\n (the \"License\"); you may not use this file except in compliance with\n the License.  You may obtain a copy of the License at\n http://www.apache.org/licenses/LICENSE-2.0\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n */\npackage org.apache.derbyTesting.system.nstest.tester;\nimport java.sql.SQLException;\nimport java.sql.DriverManager;\nimport java.sql.Statement;\nimport java.sql.ResultSet;\nimport java.sql.Date;\nimport java.sql.Time;\nimport java.sql.Timestamp;\nimport java.sql.Connection;\nimport org.apache.derbyTesting.system.nstest.NsTest;\nimport org.apache.derbyTesting.system.nstest.utils.DbUtil;\n/**\n * TesterObject - The base tester class for all the testers\n */\npublic class TesterObject {\n\tprivate String thread_id;\n    private boolean _deadConnection = false;\n\tprotected Connection connex = null;\n\tprotected DbUtil dbutil;\n\t// *******************************************************************************\n\t//\n\t// Constructor. Get's the name of the thread running this for use in\n\t// messages\n\t//\n\t// *******************************************************************************\n\tpublic TesterObject(String name) {\n\t\tthis.thread_id = name;\n\t\tdbutil = new DbUtil(getThread_id());\n\t\tNsTest.logger.println(\"==========> \" + getThread_id()\n\t\t\t\t+ \" THREAD starting <======\");\n\t}\n\t// *******************************************************************************\n\t//\n\t// Gets the connection to the database. Implemented so that threads that\n\t// need to\n\t// frequently get a connection can just call this method instead.\n\t//\n\t// *******************************************************************************\n<fim_suffix>\tpublic Connection getConnection() {\n\t\tConnection conn = null;\n\t\tString jdbcurl = \"\";\n\t\ttry {\n\t\t\tNsTest.logger.println(getThread_id()\n\t\t\t\t\t+ \" is getting a connection to the database...\");\n\t\t\tif (NsTest.embeddedMode) {\n\t\t\t\tjdbcurl = NsTest.embedDbURL + \";\" + NsTest.bootPwd;\n\t\t\t} else {\n\t\t\t\tif (NsTest.driver_type.equalsIgnoreCase(\"DerbyClient\"))\n\t\t\t\t\tjdbcurl = NsTest.clientDbURL + \";\" + NsTest.bootPwd;\n\t\t\t}\n\t\t\tNsTest.logger.println(\"-->Thread \" + getThread_id()\n\t\t\t\t\t+ \" starting with url \" + jdbcurl + \" <--\");\n\t\t\tconn = DriverManager.getConnection(jdbcurl, NsTest.prop);\n\t\t} catch (Exception e) {\n            e.printStackTrace( NsTest.logger );\n\t\t\tNsTest.logger.println(\"FAIL: \" + getThread_id()\n\t\t\t\t\t+ \" could not get the database connection\");\n\t\t\tprintException(\"Failed getting database connection using \"\n\t\t\t\t\t+ jdbcurl, e);\n\t\t}\n\t\t// for statistical purposes, add one to the num of connections makde\n\t\tNsTest.addStats(NsTest.CONNECTIONS_MADE, 1);\n\t\tNsTest.logger.println(\"Connection number: \" + NsTest.numConnections);\n\t\treturn conn; // null if there was a problem, else a valid connection\n\t}\n    /** Get a new connection and raise an error if this can't be done */\n    public  Connection  getNewConnection()\n    {\n        Connection  conn = getConnection();\n        if ( conn == null )\n        {\n            throw new RuntimeException( \"Could not get a connection!\" );\n        }\n        return conn;\n    }\n\t// *******************************************************************************\n\t//\n\t// Sets the isolation level to that indicated.\n\t//\n\t// *******************************************************************************\n\tpublic void setIsolationLevel(int level) {\n\t\ttry {\n\t\t\tconnex.setTransactionIsolation(level);\n\t\t} catch (Exception e) {\n\t\t\tNsTest.logger.println(\"FAIL: \" + getThread_id()\n\t\t\t\t\t+ \" could not set isolation level\");\n\t\t\tprintException(\"setting transaction isolation\", e);\n\t\t}\n\t}\n\t// *******************************************************************************\n\t//\n\t// Closes the connection to the database. Implemented so that threads that\n\t// need to\n\t// frequently close their connection can just call this method instead.\n\t//\n\t// *******************************************************************************\n\tpublic void closeConnection() {\n\t\ttry {\n\t\t\tNsTest.logger.println(getThread_id()\n\t\t\t\t\t+ \" is closing its connection to the database...\");\n\t\t\tconnex.close();\n\t\t} catch (Exception e) {\n\t\t\tNsTest.logger.println(\"FAIL: \" + getThread_id()\n\t\t\t\t\t+ \" could not close the database connection\");\n\t\t\tprintException(\"closing database connection\", e);\n\t\t}\n\t}\n\t// ******************************************************************************************\n\t//\n\t// This method will do a basic Insert/Delete/Update operation. We randomly\n\t// decide whether\n\t// we want to do either an Insert, a delete or an update\n\t//\n\t//\n\t// *******************************************************************************************\n\tpublic void doIUDOperation() {\n\t\t// decide Insert, Update or Delete\n\t\tint decider = (int) (Math.random() * 100) % 3;\n        if ( connex == null ) { connex = getNewConnection(); }\n\t\tswitch (decider) {\n\t\tcase 0: // do an Insert\n\t\t\ttry {\n\t\t\t\tint numInsert = dbutil.add_one_row(connex, getThread_id());\n\t\t\t\tif (numInsert == 1)\n\t\t\t\t\tNsTest.addStats(NsTest.INSERT, 1);\n\t\t\t\telse\n\t\t\t\t\tNsTest.addStats(NsTest.FAILED_INSERT, 1);\n\t\t\t} catch (Exception e) {\n\t\t\t\tprintException(\"executing add_one_row()\", e);\n                if ( NsTest.deadConnection( e ) ) { markDeadConnection(); }\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1: // do an update\n\t\t\ttry {\n\t\t\t\tint numUpdate = dbutil.update_one_row(connex, getThread_id());\n\t\t\t\tif (numUpdate == 1)\n\t\t\t\t\tNsTest.addStats(NsTest.UPDATE, 1);\n\t\t\t\telse\n\t\t\t\t\tNsTest.addStats(NsTest.FAILED_UPDATE, 1);\n\t\t\t} catch (Exception e) {\n\t\t\t\tprintException(\"executing update_one_row\", e);\n                if ( NsTest.deadConnection( e ) ) { markDeadConnection(); }\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2: // do a delete\n\t\t\ttry {\n\t\t\t\tint numDelete = dbutil.delete_one_row(connex, getThread_id());\n\t\t\t\tif (numDelete == 1)\n\t\t\t\t\tNsTest.addStats(NsTest.DELETE, 1);\n\t\t\t\telse\n\t\t\t\t\tNsTest.addStats(NsTest.FAILED_DELETE, 1);\n\t\t\t} catch (Exception e) {\n\t\t\t\tprintException(\"executing delete_one_row()\", e);\n                if ( NsTest.deadConnection( e ) ) { markDeadConnection(); }\n\t\t\t}\n\t\t\tbreak;\n\t\t}// end of switch(decider)\n\t}// end of method doIUDOperation()\n\t// ******************************************************************************************\n\t//\n\t// This method will do a basic Select operation based on the following\n\t// criteria\n\t// The query should return approximately nstest.MAX_LOW_STRESS number of\n\t// rows that we loop through via a result set and perform operations \n\t// (getXX calls) in order to ensure that data flows properly. The method \n\t// will return the total number of rows selected. Note that we do not touch\n\t// rows with serialkey less than nstest.NUM_UNTOUCHED_ROWS, and the selects\n\t// will be based on the parameter passed in, viz numRowsToSelect which is\n\t// <= nstest.NUM_UNTOUCHED_ROWS\n\t//\n\t// *******************************************************************************************\n\tpublic int doSelectOperation(int numRowsToSelect) throws SQLException {\n\t\tint numRowsSelected = 0;\n\t\tResultSet rSet = null;\n\t\tStatement s = null;\n\t\tNsTest.logger.println(getThread_id() + \" is selecting \" + numRowsToSelect\n\t\t\t\t+ \" rows\");\n\t\ttry {\n\t\t\t// create the statement\n\t\t\ts = connex.createStatement();\n\t\t\t// Execute the query\n\t\t\trSet = s\n\t\t\t.executeQuery(\"select id, t_char,\"<fim_middle>// function below has no smell\n"}