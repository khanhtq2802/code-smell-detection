{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ignite.internal.processors.platform.messaging;\n\nimport org.apache.ignite.IgniteCheckedException;\nimport org.apache.ignite.IgniteMessaging;\nimport org.apache.ignite.internal.binary.BinaryRawReaderEx;\nimport org.apache.ignite.internal.binary.BinaryRawWriterEx;\nimport org.apache.ignite.internal.processors.platform.PlatformAbstractTarget;\nimport org.apache.ignite.internal.processors.platform.PlatformContext;\nimport org.apache.ignite.internal.processors.platform.PlatformTarget;\nimport org.apache.ignite.internal.processors.platform.message.PlatformMessageFilter;\nimport org.apache.ignite.internal.processors.platform.utils.PlatformUtils;\nimport org.apache.ignite.lang.IgniteFuture;\n\nimport java.util.UUID;\n\n/**\n * Interop messaging.\n */\npublic class PlatformMessaging extends PlatformAbstractTarget {\n    /** */\n    public static final int OP_LOC_LISTEN = 1;\n\n    /** */\n    public static final int OP_REMOTE_LISTEN = 2;\n\n    /** */\n    public static final int OP_SEND = 3;\n\n    /** */\n    public static final int OP_SEND_MULTI = 4;\n\n    /** */\n    public static final int OP_SEND_ORDERED = 5;\n\n    /** */\n    public static final int OP_STOP_LOC_LISTEN = 6;\n\n    /** */\n    public static final int OP_STOP_REMOTE_LISTEN = 7;\n\n    /** */\n    public static final int OP_WITH_ASYNC = 8;\n\n    /** */\n    public static final int OP_REMOTE_LISTEN_ASYNC = 9;\n\n    /** */\n    public static final int OP_STOP_REMOTE_LISTEN_ASYNC = 10;\n\n    /** */\n    private final IgniteMessaging messaging;\n\n    /**\n     * Ctor.\n     *\n     * @param platformCtx Context.\n     * @param messaging Ignite messaging.\n     */\n    public PlatformMessaging(PlatformContext platformCtx, IgniteMessaging messaging) {\n        super(platformCtx);\n\n        assert messaging != null;\n\n        this.messaging = messaging;\n    }\n\n    /** {@inheritDoc} */\n    @Override public long processInStreamOutLong(int type, BinaryRawReaderEx reader)\n        throws IgniteCheckedException {\n        switch (type) {\n            case OP_SEND:\n                messaging.send(reader.readObjectDetached(), reader.readObjectDetached());\n\n                return TRUE;\n\n            case OP_SEND_MULTI:\n                messaging.send(reader.readObjectDetached(), PlatformUtils.readCollection(reader));\n\n                return TRUE;\n\n            case OP_SEND_ORDERED:\n                messaging.sendOrdered(reader.readObjectDetached(), reader.readObjectDetached(), reader.readLong());\n\n                return TRUE;\n\n            case OP_LOC_LISTEN: {\n                PlatformMessageLocalFilter filter = new PlatformMessageLocalFilter(reader.readLong(), platformCtx);\n\n                Object topic = reader.readObjectDetached();\n\n                messaging.localListen(topic, filter);\n\n                return TRUE;\n            }\n\n            case OP_STOP_LOC_LISTEN: {\n                PlatformMessageLocalFilter filter = new PlatformMessageLocalFilter(reader.readLong(), platformCtx);\n\n                Object topic = reader.readObjectDetached();\n\n                messaging.stopLocalListen(topic, filter);\n\n                return TRUE;\n            }\n\n            case OP_STOP_REMOTE_LISTEN: {\n                messaging.stopRemoteListen(reader.readUuid());\n\n                return TRUE;\n            }\n\n            case OP_REMOTE_LISTEN_ASYNC: {\n                readAndListenFuture(reader, startRemoteListenAsync(reader, messaging));\n\n                return TRUE;\n            }\n\n            case OP_STOP_REMOTE_LISTEN_ASYNC: {\n                readAndListenFuture(reader, messaging.stopRemoteListenAsync(reader.readUuid()));\n\n                return TRUE;\n            }\n\n            default:\n                return super.processInStreamOutLong(type, reader);\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override public void processInStreamOutStream(int type, BinaryRawReaderEx reader, BinaryRawWriterEx writer)\n        throws IgniteCheckedException {\n        switch (type) {\n            case OP_REMOTE_LISTEN:{\n                writer.writeUuid(startRemoteListen(reader, messaging));\n\n                break;\n            }\n\n            default:\n                super.processInStreamOutStream(type, reader, writer);\n        }\n    }\n\n    /**\n     * Starts the remote listener.\n     * @param reader Reader.\n     * @param messaging Messaging.\n     * @return Listen id.\n     */\n    private UUID startRemoteListen(BinaryRawReaderEx reader, IgniteMessaging messaging) {\n        Object nativeFilter = reader.readObjectDetached();\n\n        long ptr = reader.readLong();  // interop pointer\n\n        Object topic = reader.readObjectDetached();\n\n        PlatformMessageFilter filter = platformCtx.createRemoteMessageFilter(nativeFilter, ptr);\n\n        return messaging.remoteListen(topic, filter);\n    }\n\n    /**\n     * Starts the remote listener.\n     * @param reader Reader.\n     * @param messaging Messaging.\n     * @return Future of the operation.\n     */\n<fim_suffix>    private IgniteFuture<UUID> startRemoteListenAsync(BinaryRawReaderEx reader, IgniteMessaging messaging) {\n        Object nativeFilter = reader.readObjectDetached();\n\n        long ptr = reader.readLong();  // interop pointer\n\n        Object topic = reader.readObjectDetached();\n\n        PlatformMessageFilter filter = platformCtx.createRemoteMessageFilter(nativeFilter, ptr);\n\n        return messaging.remoteListenAsync(topic, filter);\n    }\n\n    /** {@inheritDoc} */\n    @Override public PlatformTarget processOutObject(int type) throws IgniteCheckedException {\n        switch (type) {\n            case OP_WITH_ASYNC:\n                if (messaging.isAsync())\n                    return this;\n\n                return new PlatformMessaging (platformCtx, messaging.withAsync());\n        }\n\n        return super.processOutObject(type);\n    }\n}<fim_middle>// function below is feature envy\n"}