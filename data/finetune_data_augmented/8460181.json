{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.impl.health;\n\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.stream.Stream;\n\nimport org.apache.camel.CamelContext;\nimport org.apache.camel.CamelContextAware;\nimport org.apache.camel.DeferredContextBinding;\nimport org.apache.camel.Route;\nimport org.apache.camel.api.management.mbean.ManagedRouteMBean;\nimport org.apache.camel.health.HealthCheck;\nimport org.apache.camel.health.HealthCheckRepository;\n\n<fim_suffix>@DeferredContextBinding\npublic class RoutesHealthCheckRepository implements CamelContextAware, HealthCheckRepository {\n    private final ConcurrentMap<Route, HealthCheck> checks;\n    private Set<String> blacklist;\n    private List<PerformanceCounterEvaluator<ManagedRouteMBean>> evaluators;\n    private ConcurrentMap<String, Collection<PerformanceCounterEvaluator<ManagedRouteMBean>>> evaluatorMap;\n    private volatile CamelContext context;\n\n    public RoutesHealthCheckRepository() {\n        this.checks = new ConcurrentHashMap<>();\n    }\n\n    @Override\n    public void setCamelContext(CamelContext camelContext) {\n        this.context = camelContext;\n    }\n\n    @Override\n    public CamelContext getCamelContext() {\n        return context;\n    }\n\n    public void setBlacklistedRoutes(Collection<String> blacklistedRoutes) {\n        blacklistedRoutes.forEach(this::addBlacklistedRoute);\n    }\n\n    public void addBlacklistedRoute(String routeId) {\n        if (this.blacklist == null) {\n            this.blacklist = new HashSet<>();\n        }\n\n        this.blacklist.add(routeId);\n    }\n\n    public void setEvaluators(Collection<PerformanceCounterEvaluator<ManagedRouteMBean>> evaluators) {\n        evaluators.forEach(this::addEvaluator);\n    }\n\n    public void addEvaluator(PerformanceCounterEvaluator<ManagedRouteMBean> evaluator) {\n        if (this.evaluators == null) {\n            this.evaluators = new CopyOnWriteArrayList<>();\n        }\n\n        this.evaluators.add(evaluator);\n    }\n\n    public void setRoutesEvaluators(Map<String, Collection<PerformanceCounterEvaluator<ManagedRouteMBean>>> evaluators) {\n        evaluators.forEach(this::setRouteEvaluators);\n    }\n\n    public void setRouteEvaluators(String routeId, Collection<PerformanceCounterEvaluator<ManagedRouteMBean>> evaluators) {\n        evaluators.forEach(evaluator -> addRouteEvaluator(routeId, evaluator));\n    }\n\n    public void addRouteEvaluator(String routeId, PerformanceCounterEvaluator<ManagedRouteMBean> evaluator) {\n        if (this.evaluatorMap == null) {\n            this.evaluatorMap = new ConcurrentHashMap<>();\n        }\n\n        this.evaluatorMap.computeIfAbsent(routeId, id -> new CopyOnWriteArrayList<>()).add(evaluator);\n    }\n\n    public Stream<PerformanceCounterEvaluator<ManagedRouteMBean>> evaluators() {\n        return this.evaluators != null\n            ? this.evaluators.stream()\n            : Stream.empty();\n    }\n\n    public Stream<PerformanceCounterEvaluator<ManagedRouteMBean>> evaluators(String routeId) {\n        return this.evaluatorMap != null\n            ? evaluatorMap.getOrDefault(routeId, Collections.emptyList()).stream()\n            : Stream.empty();\n    }\n\n    @Override\n    public Stream<HealthCheck> stream() {\n        // This is not really efficient as getRoutes() creates a copy of the routes\n        // array for each invocation. It would be nice to have more stream oriented\n        // operation on CamelContext i.e.\n        //\n        // interface CamelContext {\n        //\n        //     Stream<Route> routes();\n        //\n        //     void forEachRoute(Consumer<Route> consumer);\n        // }\n        //\n        return this.context != null\n            ? this.context.getRoutes()\n                .stream()\n                .filter(route -> route.getId() != null)\n                .filter(route -> isNotBlacklisted(route))\n                .map(this::toRouteHealthCheck)\n            : Stream.empty();\n    }\n\n    // *****************************\n    // Helpers\n    // *****************************\n\n    private boolean isNotBlacklisted(Route route) {\n        return this.blacklist != null\n            ? !this.blacklist.contains(route.getId())\n            : true;\n    }\n\n    private HealthCheck toRouteHealthCheck(Route route) {\n        return checks.computeIfAbsent(\n            route,\n            r -> {\n                HealthCheck check = new RouteHealthCheck(\n                    route,\n                    evaluatorMap != null\n                        ? evaluatorMap.getOrDefault(r.getId(), evaluators)\n                        : evaluators\n                );\n\n                check.getConfiguration().setEnabled(true);\n\n                return check;\n            }\n        );\n    }\n}<fim_middle>// class below is data class\n"}