{"text": "<fim_prefix>                             .collect(toMap(mref -> mref.descriptor().name(),\n                                            Function.identity()));\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n        private ModuleReference toModuleReference(Path path) {\n            Path minfo = path.resolve(MODULE_INFO);\n            try (InputStream in = Files.newInputStream(minfo);\n                 BufferedInputStream bin = new BufferedInputStream(in)) {\n                ModuleDescriptor descriptor = dropHashes(ModuleDescriptor.read(bin));\n                String mn = descriptor.name();\n                URI uri = URI.create(\"jrt:/\" + path.getFileName().toString());\n                Supplier<ModuleReader> readerSupplier = () -> new ModuleReader() {\n                    @Override\n                    public Optional<URI> find(String name) throws IOException {\n                        return name.equals(mn)\n                            ? Optional.of(uri) : Optional.empty();\n                    }\n                    @Override\n                    public Stream<String> list() {\n                        return Stream.empty();\n                    }\n                    @Override\n                    public void close() {\n                    }\n                };\n                return new ModuleReference(descriptor, uri) {\n                    @Override\n                    public ModuleReader open() {\n                        return readerSupplier.get();\n                    }\n                };\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n        private ModuleDescriptor dropHashes(ModuleDescriptor md) {\n            ModuleDescriptor.Builder builder = ModuleDescriptor.newModule(md.name());\n            md.requires().forEach(builder::requires);\n            md.exports().forEach(builder::exports);\n            md.opens().forEach(builder::opens);\n            md.provides().stream().forEach(builder::provides);\n            md.uses().stream().forEach(builder::uses);\n            builder.packages(md.packages());\n            return builder.build();\n        }\n        @Override\n        public Set<ModuleReference> findAll() {\n            return systemModules.values().stream().collect(toSet());\n        }\n        @Override\n        public Optional<ModuleReference> find(String mn) {\n            return systemModules.containsKey(mn)\n                    ? Optional.of(systemModules.get(mn)) : Optional.empty();\n        }\n        public Stream<String> moduleNames() {\n            return systemModules.values().stream()\n                .map(mref -> mref.descriptor().name());\n        }\n        public ClassFileReader getClassReader(String modulename) throws IOException {\n            Path mp = root.resolve(modulename);\n            if (Files.exists(mp) && Files.isDirectory(mp)) {\n                return ClassFileReader.newInstance(fileSystem, mp);\n            } else {\n                throw new FileNotFoundException(mp.toString());\n            }\n        }\n        public Set<String> defaultSystemRoots() {\n            Set<String> roots = new HashSet<>();\n            boolean hasJava = false;\n            if (systemModules.containsKey(JAVA_SE)) {\n                // java.se is a system module\n                hasJava = true;\n                roots.add(JAVA_SE);\n            }\n            for (ModuleReference mref : systemModules.values()) {\n                String mn = mref.descriptor().name();\n                if (hasJava && mn.startsWith(\"java.\"))\n                    continue;\n                // add as root if observable and exports at least one package\n                ModuleDescriptor descriptor = mref.descriptor();\n                for (ModuleDescriptor.Exports e : descriptor.exports()) {\n                    if (!e.isQualified()) {\n                        roots.add(mn);\n                        break;\n                    }\n                }\n            }\n            return roots;\n        }\n    }\n<fim_suffix>    public static class Builder {\n        final SystemModuleFinder systemModulePath;\n        final Set<String> rootModules = new HashSet<>();\n        final List<Archive> initialArchives = new ArrayList<>();\n        final List<Path> paths = new ArrayList<>();\n        final List<Path> classPaths = new ArrayList<>();\n        ModuleFinder upgradeModulePath;\n        ModuleFinder appModulePath;\n        boolean addAllApplicationModules;\n        boolean addAllDefaultModules;\n        boolean addAllSystemModules;\n        boolean allModules;\n        Runtime.Version version;\n        public Builder() {\n            this.systemModulePath = new SystemModuleFinder();\n        }\n        public Builder(String javaHome) throws IOException {\n            this.systemModulePath = SystemModuleFinder.JAVA_HOME.equals(javaHome)\n                ? new SystemModuleFinder()\n                : new SystemModuleFinder(javaHome);\n        }\n        public Builder upgradeModulePath(String upgradeModulePath) {\n            this.upgradeModulePath = createModulePathFinder(upgradeModulePath);\n            return this;\n        }\n        public Builder appModulePath(String modulePath) {\n            this.appModulePath = createModulePathFinder(modulePath);\n            return this;\n        }\n        public Builder addmods(Set<String> addmods) {\n            for (String mn : addmods) {\n                switch (mn) {\n                    case ALL_MODULE_PATH:\n                        this.addAllApplicationModules = true;\n                        break;\n                    case ALL_DEFAULT:\n                        this.addAllDefaultModules = true;\n                        break;\n                    case ALL_SYSTEM:\n                        this.addAllSystemModules = true;\n                        break;\n                    default:\n                        this.rootModules.add(mn);\n                }\n            }\n            return this;\n        }\n        /*\n         * This method is for --check option to find all target modules specified\n         * in qualified exports.\n         *\n         * Include all system modules and modules found on modulepath\n         */\n        public Builder allModules() {\n            this.allModules = true;\n            return this;\n        }\n        public Builder multiRelease(Runtime.Version version) {\n            this.version = version;\n            return this;\n        }\n        public Builder addRoot(Path path) {\n            Archive archive = Archive.getInstance(path, version);\n            if (archive.contains(MODULE_INFO)) {\n                paths.add(path);\n            } else {\n                initialArchives.add(archive);\n            }\n            return this;\n        }\n        public Builder addClassPath(String classPath) {\n            this.classPaths.addAll(getClassPaths(classPath));\n            return this;\n        }\n        public JdepsConfiguration build() throws  IOException {\n            ModuleFinder finder = systemModulePath;\n            if (upgradeModulePath != null) {\n                finder = ModuleFinder.compose(upgradeModulePath, systemModulePath);\n            }\n            if (appModulePath != null) {\n                finder = ModuleFinder.compose(finder, appModulePath);\n            }\n            if (!paths.isEmpty()) {\n                ModuleFinder otherModulePath = ModuleFinder.of(paths.toArray(new Path[0]));\n                finder = ModuleFinder.compose(finder, otherModulePath);\n                // add modules specified on command-line (convenience) as root set\n                otherModulePath.findAll().stream()\n                        .map(mref -> mref.descriptor().name())\n                        .forEach(rootModules::add);\n            }\n            if ((addAllApplicationModules || allModules) && appModulePath != null) {\n                appModulePath.findAll().stream()\n                    .map(mref -> mref.descriptor().name())\n                    .forEach(rootModules::add);\n            }\n            // no archive is specified for analysis\n            // add all system modules as root if --add-modules ALL-SYSTEM is specified\n            if (addAllSystemModules && rootModules.isEmpty() &&\n                    initialArchives.isEmpty() && classPaths.isEmpty()) {\n                systemModulePath.findAll()\n                    .stream()\n                    .map(mref -> mref.descriptor().name())\n                    .forEach(rootModules::add);\n            }\n            return new JdepsConfiguration(systemModulePath,\n                                          finder,\n                                          rootModules,\n                                          classPaths,\n                                          initialArchives,\n                                          addAllDefaultModules,\n                                          allModules,\n                                          version);\n        }\n        private static ModuleFinder createModulePathFinder(String mpaths) {\n            if (mpaths == null) {\n                return null;\n            } else {\n                String[] dirs = mpaths.split(File.pathSeparator);\n                Path[] paths = new Path[dirs.length];\n                int i = 0;\n                for (String dir : dirs) {\n                    paths[i++] = Paths.get(dir);\n                }\n                return ModuleFinder.of(paths);\n            }\n        }\n        /*\n         * Returns the list of Archive specified in cpaths and not included\n         * initialArchives\n         */\n        private List<Path> getClassPaths(String cpaths) {\n            if (cpaths.isEmpty()) {\n                return Collections.emptyList();\n            }\n            List<Path> paths = new ArrayList<>();\n            for (String p : cpaths.split(File.pathSeparator)) {\n                if (p.length() > 0) {\n                    // wildcard to parse all JAR files e.g. -classpath dir/*\n                    int i = p.lastIndexOf(\".*\");\n                    if (i > 0) {\n                        Path dir = Paths.get(p.substring(0, i));\n                        try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir, \"*.jar\")) {\n                            for (Path entry : stream) {\n                                paths.add(entry);\n                            }\n                        } catch (IOException e) {\n                            throw new UncheckedIOException(e);\n                        }\n                    } else {\n                        paths.add(Paths.get(p));\n                    }\n                }\n            }\n            return paths;\n        }\n    }<fim_middle>// class below is blob\n"}