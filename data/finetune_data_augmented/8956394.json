{"text": "<fim_prefix>      case Null:\n        dataLossLogger.logDataLossMsg(hcatFS, pigObj, msg);\n        break;\n      default:\n        throw new BackendException(\"Unexpected \" + ON_OOR_VALUE_OPT + \" value: '\" + onOutOfRange + \"'\");\n    }\n  }\n  @Override\n  public String relToAbsPathForStoreLocation(String location, Path curDir) throws IOException {\n    // Need to necessarily override this method since default impl assumes HDFS\n    // based location string.\n    return location;\n  }\n  @Override\n  public void setStoreFuncUDFContextSignature(String signature) {\n    sign = signature;\n  }\n  protected void doSchemaValidations(Schema pigSchema, HCatSchema tblSchema) throws FrontendException, HCatException {\n    // Iterate through all the elements in Pig Schema and do validations as\n    // dictated by semantics, consult HCatSchema of table when need be.\n    int columnPos = 0;//helps with debug messages\n    for (FieldSchema pigField : pigSchema.getFields()) {\n      HCatFieldSchema hcatField = getColFromSchema(pigField.alias, tblSchema);\n      validateSchema(pigField, hcatField, pigSchema, tblSchema, columnPos++);\n    }\n    try {\n      PigHCatUtil.validateHCatTableSchemaFollowsPigRules(tblSchema);\n    } catch (IOException e) {\n      throw new FrontendException(\"HCatalog schema is not compatible with Pig: \" + e.getMessage(), PigHCatUtil.PIG_EXCEPTION_CODE, e);\n    }\n  }\n  /**\n   * This method encodes which Pig type can map (be stored in) to which HCat type.\n   * @throws HCatException\n   * @throws FrontendException\n   */\n  private void validateSchema(FieldSchema pigField, HCatFieldSchema hcatField, \n                              Schema topLevelPigSchema, HCatSchema topLevelHCatSchema, \n                              int columnPos)\n    throws HCatException, FrontendException {\n    validateAlias(pigField.alias);\n    byte type = pigField.type;\n    if (DataType.isComplex(type)) {\n      switch (type) {\n      case DataType.MAP:\n        if (hcatField != null) {\n          if (hcatField.getMapKeyType() != Type.STRING) {\n            throw new FrontendException(\"Key Type of map must be String \" + hcatField, PigHCatUtil.PIG_EXCEPTION_CODE);\n          }\n          // Map values can be primitive or complex\n        }\n        break;\n      case DataType.BAG:\n        HCatSchema arrayElementSchema = hcatField == null ? null : hcatField.getArrayElementSchema();\n        for (FieldSchema innerField : pigField.schema.getField(0).schema.getFields()) {\n          validateSchema(innerField, getColFromSchema(pigField.alias, arrayElementSchema), \n                  topLevelPigSchema, topLevelHCatSchema, columnPos);\n        }\n        break;\n      case DataType.TUPLE:\n        HCatSchema structSubSchema = hcatField == null ? null : hcatField.getStructSubSchema();\n        for (FieldSchema innerField : pigField.schema.getFields()) {\n          validateSchema(innerField, getColFromSchema(pigField.alias, structSubSchema),\n                  topLevelPigSchema, topLevelHCatSchema, columnPos);\n        }\n        break;\n      default:\n        throw new FrontendException(\"Internal Error.\", PigHCatUtil.PIG_EXCEPTION_CODE);\n      }\n    }\n    else if(hcatField != null) {\n      //there is no point trying to validate further if we have no type info about target field\n      switch (type) {\n        case DataType.BIGDECIMAL:\n          throwTypeMismatchException(type, Lists.newArrayList(Type.DECIMAL), hcatField, columnPos);\n          break;\n        case DataType.DATETIME:\n          throwTypeMismatchException(type, Lists.newArrayList(Type.TIMESTAMP, Type.DATE), hcatField, columnPos);\n          break;\n        case DataType.BYTEARRAY:\n          throwTypeMismatchException(type, Lists.newArrayList(Type.BINARY), hcatField, columnPos);\n          break;\n        case DataType.BIGINTEGER:\n          throwTypeMismatchException(type, Collections.<Type>emptyList(), hcatField, columnPos);\n          break;\n        case DataType.BOOLEAN:\n          throwTypeMismatchException(type, Lists.newArrayList(Type.BOOLEAN), hcatField, columnPos);\n          break;\n        case DataType.CHARARRAY:\n          throwTypeMismatchException(type, Lists.newArrayList(Type.STRING, Type.CHAR, Type.VARCHAR), \n                  hcatField, columnPos);\n          break;\n        case DataType.DOUBLE:\n          throwTypeMismatchException(type, Lists.newArrayList(Type.DOUBLE), hcatField, columnPos);\n          break;\n        case DataType.FLOAT:\n          throwTypeMismatchException(type, Lists.newArrayList(Type.FLOAT), hcatField, columnPos);\n          break;\n        case DataType.INTEGER:\n          throwTypeMismatchException(type, Lists.newArrayList(Type.INT, Type.BIGINT, \n                  Type.TINYINT, Type.SMALLINT), hcatField, columnPos);\n          break;\n        case DataType.LONG:\n          throwTypeMismatchException(type, Lists.newArrayList(Type.BIGINT), hcatField, columnPos);\n          break;\n        default:\n          throw new FrontendException(\"'\" + type + \n                  \"' Pig datatype in column \" + columnPos + \"(0-based) is not supported by HCat\", \n                  PigHCatUtil.PIG_EXCEPTION_CODE);\n      }\n    }\n    else {\n      if(false) {\n        //see HIVE-6194\n      throw new FrontendException(\"(pigSch,hcatSchema)=(\" + pigField + \",\" +\n              \"\" + hcatField + \") (topPig, topHcat)=(\" + topLevelPigSchema + \",\" +\n              \"\" + topLevelHCatSchema + \")\");\n      }\n    }\n  }\n  private static void throwTypeMismatchException(byte pigDataType,\n      List<Type> hcatRequiredType, HCatFieldSchema hcatActualField, \n      int columnPos) throws FrontendException {\n    if(!hcatRequiredType.contains(hcatActualField.getType())) {\n      throw new FrontendException( \n              \"Pig '\" + DataType.findTypeName(pigDataType) + \"' type in column \" + \n              columnPos + \"(0-based) cannot map to HCat '\" + \n              hcatActualField.getType() + \"'type.  Target filed must be of HCat type {\" +\n              StringUtils.join(hcatRequiredType, \" or \") + \"}\");\n    }\n  }\n  private void validateAlias(String alias) throws FrontendException {\n    if (alias == null) {\n      throw new FrontendException(\"Column name for a field is not specified. Please provide the full schema as an argument to HCatStorer.\", PigHCatUtil.PIG_EXCEPTION_CODE);\n    }\n    if (alias.matches(\".*[A-Z]+.*\")) {\n      throw new FrontendException(\"Column names should all be in lowercase. Invalid name found: \" + alias, PigHCatUtil.PIG_EXCEPTION_CODE);\n    }\n  }\n  // Finds column by name in HCatSchema, if not found returns null.\n  private HCatFieldSchema getColFromSchema(String alias, HCatSchema tblSchema) {\n    if (tblSchema != null) {\n      for (HCatFieldSchema hcatField : tblSchema.getFields()) {\n        if (hcatField != null && hcatField.getName() != null && hcatField.getName().equalsIgnoreCase(alias)) {\n          return hcatField;\n        }\n      }\n    }\n    // Its a new column\n    return null;\n  }\n  @Override\n  public void cleanupOnFailure(String location, Job job) throws IOException {\n    // No-op.\n  }\n  @Override\n  public void storeStatistics(ResourceStatistics stats, String arg1, Job job) throws IOException {\n  }\n  /**\n   * todo: when job is complete, should print the msgCount table to log \n   */\n<fim_suffix>  private static final class DataLossLogger {\n    private static final Map<String, Integer> msgCount = new HashMap<String, Integer>();\n    private static String getColumnTypeKey(HCatFieldSchema fieldSchema) {\n      return fieldSchema.getName() + \"_\" + (fieldSchema.getTypeInfo() == null ?\n        fieldSchema.getType() : fieldSchema.getTypeInfo());\n    }\n    private void logDataLossMsg(HCatFieldSchema fieldSchema, Object pigOjb, String msg) {\n      String key = getColumnTypeKey(fieldSchema);\n      if(!msgCount.containsKey(key)) {\n        msgCount.put(key, 0);\n        LOG.warn(msg + \" \" + \"Will write NULL instead.  Only 1 such message per type/column is emitted.\");\n      }\n      msgCount.put(key, msgCount.get(key) + 1);\n    }\n  }<fim_middle>// class below has no smell\n"}