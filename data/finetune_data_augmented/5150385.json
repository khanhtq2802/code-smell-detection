{"text": "<fim_prefix>                    {\n                        previousError = exception.getLocalizedMessage() + \"\\n\";\n                    }\n                    String error = previousError + EXECUTION_EXCEPTION + \" \" + realException.getLocalizedMessage();\n                    exception = new SurefireBooterForkException( error, realException );\n                }\n            }\n        }\n        if ( exception != null )\n        {\n            throw exception;\n        }\n        return globalResult;\n    }\n    @SuppressWarnings( \"checkstyle:magicnumber\" )\n    private void closeExecutor( ExecutorService executorService )\n        throws SurefireBooterForkException\n    {\n        executorService.shutdown();\n        try\n        {\n            // Should stop immediately, as we got all the results if we are here\n            executorService.awaitTermination( 60 * 60, SECONDS );\n        }\n        catch ( InterruptedException e )\n        {\n            currentThread().interrupt();\n            throw new SurefireBooterForkException( \"Interrupted\", e );\n        }\n    }\n    private RunResult fork( Object testSet, KeyValueSource providerProperties, ForkClient forkClient,\n                            SurefireProperties effectiveSystemProperties, int forkNumber,\n                            AbstractForkInputStream testProvidingInputStream, boolean readTestsFromInStream )\n        throws SurefireBooterForkException\n    {\n        final String tempDir;\n        final File surefireProperties;\n        final File systPropsFile;\n        try\n        {\n            tempDir = forkConfiguration.getTempDirectory().getCanonicalPath();\n            BooterSerializer booterSerializer = new BooterSerializer( forkConfiguration );\n            Long pluginPid = forkConfiguration.getPluginPlatform().getPluginPid();\n            surefireProperties = booterSerializer.serialize( providerProperties, providerConfiguration,\n                    startupConfiguration, testSet, readTestsFromInStream, pluginPid, forkNumber );\n            log.debug( \"Determined Maven Process ID \" + pluginPid );\n            if ( effectiveSystemProperties != null )\n            {\n                SurefireProperties filteredProperties =\n                    createCopyAndReplaceForkNumPlaceholder( effectiveSystemProperties, forkNumber );\n                systPropsFile = writePropertiesFile( filteredProperties, forkConfiguration.getTempDirectory(),\n                                                     \"surefire_\" + SYSTEM_PROPERTIES_FILE_COUNTER.getAndIncrement(),\n                                                     forkConfiguration.isDebug() );\n            }\n            else\n            {\n                systPropsFile = null;\n            }\n        }\n        catch ( IOException e )\n        {\n            throw new SurefireBooterForkException( \"Error creating properties files for forking\", e );\n        }\n        File dumpLogDir = replaceForkThreadsInPath( startupReportConfiguration.getReportsDirectory(), forkNumber );\n        OutputStreamFlushableCommandline cli =\n                forkConfiguration.createCommandLine( startupConfiguration, forkNumber, dumpLogDir );\n        if ( testProvidingInputStream != null )\n        {\n            testProvidingInputStream.setFlushReceiverProvider( cli );\n        }\n        cli.createArg().setValue( tempDir );\n        cli.createArg().setValue( DUMP_FILE_PREFIX + forkNumber );\n        cli.createArg().setValue( surefireProperties.getName() );\n        if ( systPropsFile != null )\n        {\n            cli.createArg().setValue( systPropsFile.getName() );\n        }\n        final ThreadedStreamConsumer threadedStreamConsumer = new ThreadedStreamConsumer( forkClient );\n        final CloseableCloser closer = new CloseableCloser( forkNumber, threadedStreamConsumer,\n                                                            requireNonNull( testProvidingInputStream, \"null param\" ) );\n        log.debug( \"Forking command line: \" + cli );\n        Integer result = null;\n        RunResult runResult = null;\n        SurefireBooterForkException booterForkException = null;\n        try\n        {\n            NativeStdErrStreamConsumer stdErrConsumer =\n                    new NativeStdErrStreamConsumer( forkClient.getDefaultReporterFactory() );\n            CommandLineCallable future =\n                    executeCommandLineAsCallable( cli, testProvidingInputStream, threadedStreamConsumer,\n                                                        stdErrConsumer, 0, closer, ISO_8859_1 );\n            currentForkClients.add( forkClient );\n            result = future.call();\n            if ( forkClient.hadTimeout() )\n            {\n                runResult = timeout( forkClient.getDefaultReporterFactory().getGlobalRunStatistics().getRunResult() );\n            }\n            else if ( result == null || result != SUCCESS )\n            {\n                booterForkException =\n                        new SurefireBooterForkException( \"Error occurred in starting fork, check output in log\" );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            runResult = failure( forkClient.getDefaultReporterFactory().getGlobalRunStatistics().getRunResult(), e );\n            String cliErr = e.getLocalizedMessage();\n            Throwable cause = e.getCause();\n            booterForkException =\n                    new SurefireBooterForkException( \"Error while executing forked tests.\", cliErr, cause, runResult );\n        }\n        finally\n        {\n            currentForkClients.remove( forkClient );\n            closer.close();\n            if ( runResult == null )\n            {\n                runResult = forkClient.getDefaultReporterFactory().getGlobalRunStatistics().getRunResult();\n            }\n            forkClient.close( runResult.isTimeout() );\n            if ( !runResult.isTimeout() )\n            {\n                Throwable cause = booterForkException == null ? null : booterForkException.getCause();\n                String detail = booterForkException == null ? \"\" : \"\\n\" + booterForkException.getMessage();\n                if ( forkClient.isErrorInFork() )\n                {\n                    StackTraceWriter errorInFork = forkClient.getErrorInFork();\n                    // noinspection ThrowFromFinallyBlock\n                    throw new SurefireBooterForkException( \"There was an error in the forked process\"\n                                                        + detail\n                                                        + '\\n'\n                                                        + errorInFork.getThrowable().getLocalizedMessage(), cause );\n                }\n                if ( !forkClient.isSaidGoodBye() )\n                {\n                    String errorCode = result == null ? \"\" : \"\\nProcess Exit Code: \" + result;\n                    String testsInProgress = forkClient.hasTestsInProgress() ? \"\\nCrashed tests:\" : \"\";\n                    for ( String test : forkClient.testsInProgress() )\n                    {\n                        testsInProgress += \"\\n\" + test;\n                    }\n                    // noinspection ThrowFromFinallyBlock\n                    throw new SurefireBooterForkException(\n                        \"The forked VM terminated without properly saying goodbye. VM crash or System.exit called?\"\n                            + \"\\nCommand was \" + cli.toString() + detail + errorCode + testsInProgress, cause );\n                }\n            }\n            if ( booterForkException != null )\n            {\n                // noinspection ThrowFromFinallyBlock\n                throw booterForkException;\n            }\n        }\n        return runResult;\n    }\n    private Iterable<Class<?>> getSuitesIterator()\n        throws SurefireBooterForkException\n    {\n        try\n        {\n            AbstractPathConfiguration classpathConfiguration = startupConfiguration.getClasspathConfiguration();\n            ClassLoader unifiedClassLoader = classpathConfiguration.createMergedClassLoader();\n            CommonReflector commonReflector = new CommonReflector( unifiedClassLoader );\n            Object reporterFactory = commonReflector.createReportingReporterFactory( startupReportConfiguration, log );\n            ProviderFactory providerFactory =\n                new ProviderFactory( startupConfiguration, providerConfiguration, unifiedClassLoader, reporterFactory );\n            SurefireProvider surefireProvider = providerFactory.createProvider( false );\n            return surefireProvider.getSuites();\n        }\n        catch ( SurefireExecutionException e )\n        {\n            throw new SurefireBooterForkException( \"Unable to create classloader to find test suites\", e );\n        }\n    }\n    private static Thread createImmediateShutdownHookThread( final TestLessInputStreamBuilder builder,\n                                                             final Shutdown shutdownType )\n    {\n        return SHUTDOWN_HOOK_THREAD_FACTORY.newThread( new Runnable()\n        {\n            @Override\n            public void run()\n            {\n                builder.getImmediateCommands().shutdown( shutdownType );\n            }\n        } );\n    }\n    private static Thread createCachableShutdownHookThread( final TestLessInputStreamBuilder builder,\n                                                            final Shutdown shutdownType )\n    {\n        return SHUTDOWN_HOOK_THREAD_FACTORY.newThread( new Runnable()\n        {\n            @Override\n            public void run()\n            {\n                builder.getCachableCommands().shutdown( shutdownType );\n            }\n        } );\n    }\n    private static Thread createShutdownHookThread( final Iterable<TestProvidingInputStream> streams,\n                                                    final Shutdown shutdownType )\n    {\n        return SHUTDOWN_HOOK_THREAD_FACTORY.newThread( new Runnable()\n        {\n            @Override\n            public void run()\n            {\n                for ( TestProvidingInputStream stream : streams )\n                {\n                    stream.shutdown( shutdownType );\n                }\n            }\n        } );\n    }\n    private static ScheduledExecutorService createPingScheduler()\n    {\n        ThreadFactory threadFactory = newDaemonThreadFactory( \"ping-timer-\" + PING_IN_SECONDS + \"s\" );\n        return newScheduledThreadPool( 1, threadFactory );\n    }\n<fim_suffix>    private static ScheduledExecutorService createTimeoutCheckScheduler()\n    {\n        ThreadFactory threadFactory = newDaemonThreadFactory( \"timeout-check-timer\" );\n        return newScheduledThreadPool( 1, threadFactory );\n    }<fim_middle>// function below has no smell\n"}