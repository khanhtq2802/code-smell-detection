{"text": "<fim_prefix> *   distributed under the License is distributed on an \"AS IS\" BASIS,\n *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *   See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.apache.xmlbeans.impl.validator;\nimport org.apache.xmlbeans.impl.common.XMLNameHelper;\nimport org.apache.xmlbeans.impl.common.GenericXmlInputStream;\nimport org.apache.xmlbeans.impl.common.ValidatorListener.Event;\nimport org.apache.xmlbeans.impl.common.ValidatorListener;\nimport org.apache.xmlbeans.impl.common.XmlWhitespace;\nimport org.apache.xmlbeans.impl.schema.BuiltinSchemaTypeSystem;\nimport org.apache.xmlbeans.SchemaType;\nimport org.apache.xmlbeans.SchemaTypeLoader;\nimport org.apache.xmlbeans.XmlCursor;\nimport org.apache.xmlbeans.XmlError;\nimport org.apache.xmlbeans.XmlOptions;\nimport org.apache.xmlbeans.XMLStreamValidationException;\nimport java.util.Map;\nimport java.util.AbstractCollection;\nimport java.util.Iterator;\nimport java.util.Collections;\nimport org.apache.xmlbeans.xml.stream.Attribute;\nimport org.apache.xmlbeans.xml.stream.AttributeIterator;\nimport org.apache.xmlbeans.xml.stream.CharacterData;\nimport org.apache.xmlbeans.xml.stream.StartElement;\nimport org.apache.xmlbeans.xml.stream.XMLEvent;\nimport org.apache.xmlbeans.xml.stream.XMLInputStream;\nimport org.apache.xmlbeans.xml.stream.XMLName;\nimport org.apache.xmlbeans.xml.stream.XMLStreamException;\nimport javax.xml.namespace.QName;\n/**\n * @deprecated XMLInputStream was deprecated by XMLStreamReader from STaX - jsr173 API.\n */\npublic final class ValidatingXMLInputStream\n    extends GenericXmlInputStream implements Event\n{\n    public ValidatingXMLInputStream (\n        XMLInputStream xis,\n        SchemaTypeLoader typeLoader, SchemaType sType, XmlOptions options )\n            throws XMLStreamException\n    {\n        _source = xis;\n        // Figure out the root type\n        options = XmlOptions.maskNull( options );\n        SchemaType type = (SchemaType) options.get( XmlOptions.DOCUMENT_TYPE );\n        if (type == null)\n            type = sType;\n        if (type == null)\n        {\n            type = BuiltinSchemaTypeSystem.ST_ANY_TYPE;\n            xis = xis.getSubStream();\n            if (xis.skip( XMLEvent.START_ELEMENT ))\n            {\n                SchemaType docType =\n                    typeLoader.findDocumentType(\n                        XMLNameHelper.getQName( xis.next().getName() ) );\n                if (docType != null)\n                    type = docType;\n            }\n            xis.close();\n        }\n        // Create the validator\n        _validator =\n            new Validator(\n                type, null, typeLoader, options, new ExceptionXmlErrorListener() );\n        nextEvent( ValidatorListener.BEGIN );\n    }\n    // TODO - this is the quick and dirty impl of streaming validation,\n    // may objects are created (like strings) which can be optimized\n    protected XMLEvent nextEvent ( ) throws XMLStreamException\n    {\n        XMLEvent e = _source.next();\n        if (e == null)\n        {\n            if (!_finished)\n            {\n                flushText();\n                nextEvent( ValidatorListener.END );\n                _finished = true;\n            }\n        }\n        else\n        {\n            switch ( e.getType() )\n            {\n            case XMLEvent.CHARACTER_DATA :\n            case XMLEvent.SPACE :\n            {\n                CharacterData cd = (CharacterData) e;\n                if (cd.hasContent())\n                    _text.append( cd.getContent() );\n                break;\n            }\n            case XMLEvent.START_ELEMENT :\n            {\n                StartElement se = (StartElement) e;\n                flushText();\n                // Used for prefix to namespace mapping\n                _startElement = se;\n                // Prepare the xsi:* values\n                AttributeIterator attrs = se.getAttributes();\n                while ( attrs.hasNext() )\n                {\n                    Attribute attr = attrs.next();\n                    XMLName attrName = attr.getName();\n                    if (\"http://www.w3.org/2001/XMLSchema-instance\".equals(\n                            attrName.getNamespaceUri() ))\n                    {\n                        String local = attrName.getLocalName();\n                        if (local.equals( \"type\" ))\n                            _xsiType = attr.getValue();\n                        else if (local.equals( \"nil\" ))\n                            _xsiNil = attr.getValue();\n                        else if (local.equals( \"schemaLocation\" ))\n                            _xsiLoc = attr.getValue();\n                        else if (local.equals( \"noNamespaceSchemaLocation\" ))\n                            _xsiNoLoc = attr.getValue();\n                    }\n                }\n                // Emit the START\n                // TODO - should delay the aquisition of the name\n                _name = e.getName();\n                nextEvent( ValidatorListener.BEGIN );\n                // Emit the attrs\n                attrs = se.getAttributes();\n                while ( attrs.hasNext() )\n                {\n                    Attribute attr = attrs.next();\n                    XMLName attrName = attr.getName();\n                    if (\"http://www.w3.org/2001/XMLSchema-instance\".equals(\n                            attrName.getNamespaceUri() ))\n                    {\n                        String local = attrName.getLocalName();\n                        if (local.equals( \"type\" ))\n                            continue;\n                        else if (local.equals( \"nil\" ))\n                            continue;\n                        else if (local.equals( \"schemaLocation\" ))\n                            continue;\n                        else if (local.equals( \"noNamespaceSchemaLocation\" ))\n                            continue;\n                    }\n                    // TODO - God, this is lame :-)\n                    _text.append( attr.getValue() );\n                    _name = attr.getName();\n                    nextEvent( ValidatorListener.ATTR );\n                }\n                clearText();\n                _startElement = null;\n                break;\n            }\n            case XMLEvent.END_ELEMENT :\n            {\n                flushText();\n                nextEvent( ValidatorListener.END );\n                break;\n            }\n            }\n        }\n        return e;\n    }\n    private void clearText ( )\n    {\n        _text.delete( 0, _text.length() );\n    }\n    private void flushText ( ) throws XMLStreamException\n    {\n        if (_text.length() > 0)\n        {\n            nextEvent( ValidatorListener.TEXT );\n            clearText();\n        }\n    }\n    public String getNamespaceForPrefix ( String prefix )\n    {\n        if (_startElement == null)\n            return null;\n        Map map = _startElement.getNamespaceMap();\n        if (map == null)\n            return null;\n        return (String) map.get( prefix );\n    }\n    public XmlCursor getLocationAsCursor ( )\n    {\n        return null;\n    }\n    public javax.xml.stream.Location getLocation()\n    {\n        try\n        {\n            final org.apache.xmlbeans.xml.stream.Location xeLoc = _source.peek().getLocation();\n            if (xeLoc==null)\n                return null;\n            javax.xml.stream.Location loc = new javax.xml.stream.Location()\n            {\n                public int getLineNumber()\n                { return xeLoc.getLineNumber(); }\n                public int getColumnNumber()\n                { return xeLoc.getColumnNumber(); }\n                public int getCharacterOffset()\n                { return -1;}\n                public String getPublicId()\n                { return xeLoc.getPublicId(); }\n                public String getSystemId()\n                { return xeLoc.getSystemId(); }\n            };\n            return loc;\n        }\n        catch (XMLStreamException e)\n        {\n            return null;\n        }\n    }\n    public String getXsiType ( )\n    {\n        return _xsiType;\n    }\n    public String getXsiNil ( )\n    {\n        return _xsiNil;\n    }\n    public String getXsiLoc ( )\n    {\n        return _xsiLoc;\n    }\n    public String getXsiNoLoc ( )\n    {\n        return _xsiNoLoc;\n    }\n    public QName getName ( )\n    {\n        return XMLNameHelper.getQName( _name );\n    }\n    public String getText ( )\n    {\n        return _text.toString();\n    }\n    public String getText ( int wsr )\n    {\n        return XmlWhitespace.collapse( _text.toString(), wsr );\n    }\n    public boolean textIsWhitespace ( )\n    {\n        for ( int i = 0 ; i < _text.length() ; i++ )\n        {\n            switch ( _text.charAt( i ) )\n            {\n                case ' ':\n                case '\\n':\n                case '\\r':\n                case '\\t':\n                    break;\n                default :\n                    return false;\n            }\n        }\n        return true;\n    }\n<fim_suffix>    private final class ExceptionXmlErrorListener extends AbstractCollection\n    {\n        public boolean add(Object o)\n        {\n            assert ValidatingXMLInputStream.this._exception == null;\n            ValidatingXMLInputStream.this._exception = \n                new XMLStreamValidationException( (XmlError)o );\n            return false;\n        }\n        public Iterator iterator()\n        {\n            return Collections.EMPTY_LIST.iterator();\n        }\n        public int size()\n        {\n            return 0;\n        }\n    }<fim_middle>// class below has no smell\n"}