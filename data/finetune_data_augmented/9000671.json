{"text": "<fim_prefix> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.lucene.codecs.blocktreeords;\n//import java.io.*;\n//import java.nio.charset.StandardCharsets;\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport org.apache.lucene.codecs.BlockTermState;\nimport org.apache.lucene.codecs.blocktreeords.FSTOrdsOutputs.Output;\nimport org.apache.lucene.index.BaseTermsEnum;\nimport org.apache.lucene.index.ImpactsEnum;\nimport org.apache.lucene.index.PostingsEnum;\nimport org.apache.lucene.index.TermState;\nimport org.apache.lucene.store.ByteArrayDataInput;\nimport org.apache.lucene.store.IndexInput;\nimport org.apache.lucene.util.ArrayUtil;\nimport org.apache.lucene.util.BytesRef;\nimport org.apache.lucene.util.BytesRefBuilder;\nimport org.apache.lucene.util.IntsRef;\nimport org.apache.lucene.util.IntsRefBuilder;\nimport org.apache.lucene.util.RamUsageEstimator;\nimport org.apache.lucene.util.fst.FST;\nimport org.apache.lucene.util.fst.Util;\n/** Iterates through terms in this field. */\npublic final class OrdsSegmentTermsEnum extends BaseTermsEnum {\n  // Lazy init:\n  IndexInput in;\n  // static boolean DEBUG = true;\n  private OrdsSegmentTermsEnumFrame[] stack;\n  private final OrdsSegmentTermsEnumFrame staticFrame;\n  OrdsSegmentTermsEnumFrame currentFrame;\n  boolean termExists;\n  final OrdsFieldReader fr;\n  private int targetBeforeCurrentLength;\n  private final ByteArrayDataInput scratchReader = new ByteArrayDataInput();\n  // What prefix of the current term was present in the index:\n  private int validIndexPrefix;\n  // assert only:\n  private boolean eof;\n  final BytesRefBuilder term = new BytesRefBuilder();\n  private final FST.BytesReader fstReader;\n  @SuppressWarnings({\"rawtypes\",\"unchecked\"}) private FST.Arc<Output>[] arcs =\n  new FST.Arc[1];\n  boolean positioned;\n  OrdsSegmentTermsEnum(OrdsFieldReader fr) throws IOException {\n    this.fr = fr;\n    //if (DEBUG) System.out.println(\"BTTR.init seg=\" + segment);\n    stack = new OrdsSegmentTermsEnumFrame[0];\n    // Used to hold seek by TermState, or cached seek\n    staticFrame = new OrdsSegmentTermsEnumFrame(this, -1);\n    if (fr.index == null) {\n      fstReader = null;\n    } else {\n      fstReader = fr.index.getBytesReader();\n    }\n    // Init w/ root block; don't use index since it may\n    // not (and need not) have been loaded\n    for(int arcIdx=0;arcIdx<arcs.length;arcIdx++) {\n      arcs[arcIdx] = new FST.Arc<>();\n    }\n    currentFrame = staticFrame;\n    final FST.Arc<Output> arc;\n    if (fr.index != null) {\n      arc = fr.index.getFirstArc(arcs[0]);\n      // Empty string prefix must have an output in the index!\n      assert arc.isFinal();\n    } else {\n      arc = null;\n    }\n    //currentFrame = pushFrame(arc, rootCode, 0);\n    //currentFrame.loadBlock();\n    validIndexPrefix = 0;\n    // if (DEBUG) {\n    //   System.out.println(\"init frame state \" + currentFrame.ord);\n    //   printSeekState();\n    // }\n    //System.out.println();\n    // computeBlockStats().print(System.out);\n  }\n  // Not private to avoid synthetic access$NNN methods\n  void initIndexInput() {\n    if (this.in == null) {\n      this.in = fr.parent.in.clone();\n    }\n  }\n  private OrdsSegmentTermsEnumFrame getFrame(int ord) throws IOException {\n    if (ord >= stack.length) {\n      final OrdsSegmentTermsEnumFrame[] next = new OrdsSegmentTermsEnumFrame[ArrayUtil.oversize(1+ord, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(stack, 0, next, 0, stack.length);\n      for(int stackOrd=stack.length;stackOrd<next.length;stackOrd++) {\n        next[stackOrd] = new OrdsSegmentTermsEnumFrame(this, stackOrd);\n      }\n      stack = next;\n    }\n    assert stack[ord].ord == ord;\n    return stack[ord];\n  }\n  private FST.Arc<Output> getArc(int ord) {\n    if (ord >= arcs.length) {\n      @SuppressWarnings({\"rawtypes\",\"unchecked\"}) final FST.Arc<Output>[] next =\n      new FST.Arc[ArrayUtil.oversize(1+ord, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];\n      System.arraycopy(arcs, 0, next, 0, arcs.length);\n      for(int arcOrd=arcs.length;arcOrd<next.length;arcOrd++) {\n        next[arcOrd] = new FST.Arc<>();\n      }\n      arcs = next;\n    }\n    return arcs[ord];\n  }\n  // Pushes a frame we seek'd to\n  OrdsSegmentTermsEnumFrame pushFrame(FST.Arc<Output> arc, Output frameData, int length) throws IOException {\n    scratchReader.reset(frameData.bytes.bytes, frameData.bytes.offset, frameData.bytes.length);\n    final long code = scratchReader.readVLong();\n    final long fpSeek = code >>> OrdsBlockTreeTermsWriter.OUTPUT_FLAGS_NUM_BITS;\n    // System.out.println(\"    fpSeek=\" + fpSeek);\n    final OrdsSegmentTermsEnumFrame f = getFrame(1+currentFrame.ord);\n    f.hasTerms = (code & OrdsBlockTreeTermsWriter.OUTPUT_FLAG_HAS_TERMS) != 0;\n    f.hasTermsOrig = f.hasTerms;\n    f.isFloor = (code & OrdsBlockTreeTermsWriter.OUTPUT_FLAG_IS_FLOOR) != 0;\n    // Must setFloorData before pushFrame in case pushFrame tries to rewind:\n    if (f.isFloor) {\n      f.termOrdOrig = frameData.startOrd;\n      f.setFloorData(scratchReader, frameData.bytes);\n    }\n    pushFrame(arc, fpSeek, length, frameData.startOrd);\n    return f;\n  }\n  // Pushes next'd frame or seek'd frame; we later\n  // lazy-load the frame only when needed\n<fim_suffix>  OrdsSegmentTermsEnumFrame pushFrame(FST.Arc<Output> arc, long fp, int length, long termOrd) throws IOException {\n    final OrdsSegmentTermsEnumFrame f = getFrame(1+currentFrame.ord);\n    f.arc = arc;\n    // System.out.println(\"pushFrame termOrd= \" + termOrd + \" fpOrig=\" + f.fpOrig + \" fp=\" + fp + \" nextEnt=\" + f.nextEnt);\n    if (f.fpOrig == fp && f.nextEnt != -1) {\n      //if (DEBUG) System.out.println(\"      push reused frame ord=\" + f.ord + \" fp=\" + f.fp + \" isFloor?=\" + f.isFloor + \" hasTerms=\" + f.hasTerms + \" pref=\" + term + \" nextEnt=\" + f.nextEnt + \" targetBeforeCurrentLength=\" + targetBeforeCurrentLength + \" term.length=\" + term.length + \" vs prefix=\" + f.prefix);\n      if (f.prefix > targetBeforeCurrentLength) {\n        // System.out.println(\"        do rewind!\");\n        f.rewind();\n      } else {\n        // if (DEBUG) {\n        // System.out.println(\"        skip rewind!\");\n        // }\n      }\n      assert length == f.prefix;\n      assert termOrd == f.termOrdOrig;\n    } else {\n      f.nextEnt = -1;\n      f.prefix = length;\n      f.state.termBlockOrd = 0;\n      f.termOrdOrig = termOrd;\n      // System.out.println(\"set termOrdOrig=\" + termOrd);\n      f.termOrd = termOrd;\n      f.fpOrig = f.fp = fp;\n      f.lastSubFP = -1;\n      // if (DEBUG) {\n      //   final int sav = term.length;\n      //   term.length = length;\n      //   System.out.println(\"      push new frame ord=\" + f.ord + \" fp=\" + f.fp + \" hasTerms=\" + f.hasTerms + \" isFloor=\" + f.isFloor + \" pref=\" + brToString(term));\n      //   term.length = sav;\n      // }\n    }\n    return f;\n  }<fim_middle>// function below is long method\n"}