{"text": "<fim_prefix>/**\n * Copyright (c) 2012, 2017 itemis AG (http://www.itemis.eu) and others.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n */\npackage org.eclipse.xtend.core.macro;\nimport com.google.inject.Inject;\nimport com.google.inject.Provider;\nimport com.google.inject.Singleton;\nimport java.util.List;\nimport java.util.concurrent.CancellationException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.RejectedExecutionException;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport org.apache.log4j.Logger;\nimport org.eclipse.xtend.core.macro.ActiveAnnotationContext;\nimport org.eclipse.xtend.core.macro.RegisterGlobalsContextImpl;\nimport org.eclipse.xtend.core.macro.TransformationContextImpl;\nimport org.eclipse.xtend.core.macro.ValidationContextImpl;\nimport org.eclipse.xtend.core.macro.declaration.CompilationUnitImpl;\nimport org.eclipse.xtend.core.xtend.XtendAnnotationTarget;\nimport org.eclipse.xtend.core.xtend.XtendMember;\nimport org.eclipse.xtend.core.xtend.XtendParameter;\nimport org.eclipse.xtend.lib.annotations.AccessorType;\nimport org.eclipse.xtend.lib.annotations.Accessors;\nimport org.eclipse.xtend.lib.macro.RegisterGlobalsParticipant;\nimport org.eclipse.xtend.lib.macro.TransformationParticipant;\nimport org.eclipse.xtend.lib.macro.ValidationParticipant;\nimport org.eclipse.xtend.lib.macro.declaration.Declaration;\nimport org.eclipse.xtend.lib.macro.declaration.Element;\nimport org.eclipse.xtend.lib.macro.declaration.MutableNamedElement;\nimport org.eclipse.xtend.lib.macro.declaration.NamedElement;\nimport org.eclipse.xtext.util.CancelIndicator;\nimport org.eclipse.xtext.util.internal.Stopwatches;\nimport org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor;\nimport org.eclipse.xtext.xbase.lib.Exceptions;\nimport org.eclipse.xtext.xbase.lib.Functions.Function0;\nimport org.eclipse.xtext.xbase.lib.Functions.Function1;\nimport org.eclipse.xtext.xbase.lib.ListExtensions;\nimport org.eclipse.xtext.xbase.lib.Pure;\n/**\n * It checks whether the files contain macro annotations and calls their register and processing functions.\n * \n * @author Sven Efftinge\n */\n@SuppressWarnings(\"all\")\npublic class AnnotationProcessor {\n  @Singleton\n  public static class CancellationObserver {\n    private static final Logger log = Logger.getLogger(AnnotationProcessor.CancellationObserver.class);\n    @Accessors(AccessorType.PROTECTED_GETTER)\n    private ExecutorService pool = this.initPool();\n    protected ExecutorService initPool() {\n      return Executors.newCachedThreadPool();\n    }\n    public void stop() {\n      this.pool.shutdown();\n    }\n<fim_suffix>    public Future<?> monitorUntil(final ActiveAnnotationContext ctx, final CancelIndicator cancelIndicator, final Function0<? extends Boolean> isFinished) {\n      Future<?> _xblockexpression = null;\n      {\n        final Runnable _function = () -> {\n          try {\n            while ((!(isFinished.apply()).booleanValue())) {\n              {\n                boolean _isCanceled = cancelIndicator.isCanceled();\n                if (_isCanceled) {\n                  CompilationUnitImpl _compilationUnit = ctx.getCompilationUnit();\n                  _compilationUnit.setCanceled(true);\n                  return;\n                }\n                Thread.sleep(100);\n              }\n            }\n          } catch (Throwable _e) {\n            throw Exceptions.sneakyThrow(_e);\n          }\n        };\n        final Runnable r = _function;\n        Future<?> _xtrycatchfinallyexpression = null;\n        try {\n          _xtrycatchfinallyexpression = this.pool.submit(r);\n        } catch (final Throwable _t) {\n          if (_t instanceof RejectedExecutionException) {\n            final RejectedExecutionException e = (RejectedExecutionException)_t;\n            AnnotationProcessor.CancellationObserver.log.debug(e.getMessage(), e);\n            new Thread(r).start();\n          } else {\n            throw Exceptions.sneakyThrow(_t);\n          }\n        }\n        _xblockexpression = _xtrycatchfinallyexpression;\n      }\n      return _xblockexpression;\n    }\n    @Pure\n    protected ExecutorService getPool() {\n      return this.pool;\n    }\n  }\n  @Inject\n  private Provider<TransformationContextImpl> modifyContextProvider;\n  @Inject\n  private Provider<RegisterGlobalsContextImpl> registerGlobalsContextProvider;\n  @Inject\n  private Provider<ValidationContextImpl> validationContextProvider;\n  @Inject\n  private AnnotationProcessor.CancellationObserver cancellationObserver;\n  /**\n   * gets called from Xtend compiler, during \"model inference\", i.e. translation of Xtend AST to Java AST\n   */\n  public Object indexingPhase(final ActiveAnnotationContext ctx, final IJvmDeclaredTypeAcceptor acceptor, final CancelIndicator monitor) {\n    Object _xblockexpression = null;\n    {\n      final Stopwatches.StoppedTask task = Stopwatches.forTask(\"[macros] indexingPhase (AnnotationProcessor.indexingPhase)\");\n      task.start();\n      Object _xtrycatchfinallyexpression = null;\n      try {\n        Object _switchResult = null;\n        Object _processorInstance = ctx.getProcessorInstance();\n        final Object processor = _processorInstance;\n        boolean _matched = false;\n        if (processor instanceof RegisterGlobalsParticipant) {\n          _matched=true;\n          Object _xblockexpression_1 = null;\n          {\n            final RegisterGlobalsContextImpl registerGlobalsCtx = this.registerGlobalsContextProvider.get();\n            registerGlobalsCtx.setAcceptor(acceptor);\n            registerGlobalsCtx.setCompilationUnit(ctx.getCompilationUnit());\n            final Runnable _function = () -> {\n              final Function1<XtendAnnotationTarget, Declaration> _function_1 = (XtendAnnotationTarget it) -> {\n                Declaration _switchResult_1 = null;\n                boolean _matched_1 = false;\n                if (it instanceof XtendMember) {\n                  _matched_1=true;\n                  _switchResult_1 = ctx.getCompilationUnit().toXtendMemberDeclaration(((XtendMember)it));\n                }\n                if (!_matched_1) {\n                  if (it instanceof XtendParameter) {\n                    _matched_1=true;\n                    _switchResult_1 = ctx.getCompilationUnit().toXtendParameterDeclaration(((XtendParameter)it));\n                  }\n                }\n                final Declaration xtendMember = _switchResult_1;\n                return xtendMember;\n              };\n              ((RegisterGlobalsParticipant<NamedElement>)processor).doRegisterGlobals(\n                ListExtensions.<XtendAnnotationTarget, Declaration>map(ctx.getAnnotatedSourceElements(), _function_1), registerGlobalsCtx);\n            };\n            _xblockexpression_1 = this.runWithCancelIndiciator(ctx, monitor, _function);\n          }\n          _switchResult = _xblockexpression_1;\n        }\n        _xtrycatchfinallyexpression = _switchResult;\n      } finally {\n        task.stop();\n      }\n      _xblockexpression = _xtrycatchfinallyexpression;\n    }\n    return _xblockexpression;\n  }\n  public Object inferencePhase(final ActiveAnnotationContext ctx, final CancelIndicator monitor) {\n    Object _xblockexpression = null;\n    {\n      final Stopwatches.StoppedTask task = Stopwatches.forTask(\"[macros] inferencePhase (AnnotationProcessor.inferencePhase)\");\n      task.start();\n      Object _xtrycatchfinallyexpression = null;\n      try {\n        Object _switchResult = null;\n        Object _processorInstance = ctx.getProcessorInstance();\n        final Object processor = _processorInstance;\n        boolean _matched = false;\n        if (processor instanceof TransformationParticipant) {\n          _matched=true;\n          Object _xblockexpression_1 = null;\n          {\n            final TransformationContextImpl modifyCtx = this.modifyContextProvider.get();\n            modifyCtx.setUnit(ctx.getCompilationUnit());\n            final Runnable _function = () -> {\n              final Function1<XtendAnnotationTarget, MutableNamedElement> _function_1 = (XtendAnnotationTarget it) -> {\n                Declaration _switchResult_1 = null;\n                boolean _matched_1 = false;\n                if (it instanceof XtendMember) {\n                  _matched_1=true;\n                  _switchResult_1 = ctx.getCompilationUnit().toXtendMemberDeclaration(((XtendMember)it));\n                }\n                if (!_matched_1) {\n                  if (it instanceof XtendParameter) {\n                    _matched_1=true;\n                    _switchResult_1 = ctx.getCompilationUnit().toXtendParameterDeclaration(((XtendParameter)it));\n                  }\n                }<fim_middle>// function below is long method\n"}