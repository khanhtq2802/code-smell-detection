{"text": "<fim_prefix>            from = getFromSelect(sel, false);\n        else\n            from = getFrom(sel, false);\n        SQLBuffer where = getWhere(sel, false);\n        // if no grouping and no range, we might be able to get by without\n        // a subselect\n        if (sel.getGrouping() == null && sel.getStartIndex() == 0\n            && sel.getEndIndex() == Long.MAX_VALUE) {\n            // if the select has no identifier cols, use COUNT(*)\n            List aliases = (!sel.isDistinct()) ? Collections.EMPTY_LIST\n                : sel.getIdentifierAliases();\n            if (useWildCardForCount || aliases.isEmpty()) {\n                selectSQL.append(\"COUNT(*)\");\n                return toSelect(selectSQL, null, from, where, null, null, null,\n                    false, false, 0, Long.MAX_VALUE);\n            }\n            // if there is a single distinct col, use COUNT(DISTINCT col)\n            if (aliases.size() == 1) {\n                selectSQL.append(\"COUNT(DISTINCT \").\n                    append(aliases.get(0).toString()).append(\")\");\n                return toSelect(selectSQL, null, from, where, null, null, null,\n                    false, false, 0, Long.MAX_VALUE);\n            }\n            // can we combine distinct cols?\n            if (distinctCountColumnSeparator != null) {\n                selectSQL.append(\"COUNT(DISTINCT \");\n                for (int i = 0; i < aliases.size(); i++) {\n                    if (i > 0) {\n                        selectSQL.append(\" \");\n                        selectSQL.append(distinctCountColumnSeparator);\n                        selectSQL.append(\" \");\n                    }\n                    selectSQL.append(aliases.get(i).toString());\n                }\n                selectSQL.append(\")\");\n                return toSelect(selectSQL, null, from, where, null, null, null,\n                    false, false, 0, Long.MAX_VALUE);\n            }\n        }\n        // since we can't combine distinct cols, we have to perform an outer\n        // COUNT(*) select using the original select as a subselect in the\n        // FROM clause\n        assertSupport(supportsSubselect, \"SupportsSubselect\");\n        SQLBuffer subSelect = getSelects(sel, true, false);\n        SQLBuffer subFrom = from;\n        from = new SQLBuffer(this);\n        from.append(\"(\");\n        from.append(toSelect(subSelect, null, subFrom, where,\n            sel.getGrouping(), sel.getHaving(), null, sel.isDistinct(),\n            false, sel.getStartIndex(), sel.getEndIndex(), true, sel));\n        from.append(\")\");\n        if (requiresAliasForSubselect)\n            from.append(\" \").append(Select.FROM_SELECT_ALIAS);\n        selectSQL.append(\"COUNT(*)\");\n        return toSelect(selectSQL, null, from, null, null, null, null,\n            false, false, 0, Long.MAX_VALUE);\n    }\n    /**\n     * Create a DELETE statement for the specified Select. If the\n     * database does not support the bulk delete statement (such as\n     * cases where a subselect is required and the database doesn't support\n     * subselects), this method should return null.\n     */\n    public SQLBuffer toDelete(ClassMapping mapping, Select sel,\n        Object[] params) {\n        return toBulkOperation(mapping, sel, null, params, null);\n    }\n    public SQLBuffer toUpdate(ClassMapping mapping, Select sel,\n        JDBCStore store, Object[] params, Map updates) {\n        return toBulkOperation(mapping, sel, store, params, updates);\n    }\n    /**\n     * Returns the SQL for a bulk operation, either a DELETE or an UPDATE.\n     *\n     * @param mapping the mapping against which we are operating\n     * @param sel the Select that will constitute the WHERE clause\n     * @param store the current store\n     * @param updateParams the Map that holds the update parameters; a null\n     * value indicates that this is a delete operation\n     * @return the SQLBuffer for the update, or <em>null</em> if it is not\n     * possible to perform the bulk update\n     */\n<fim_suffix>    protected SQLBuffer toBulkOperation(ClassMapping mapping, Select sel,\n        JDBCStore store, Object[] params, Map updateParams) {\n        SQLBuffer sql = new SQLBuffer(this);\n        if (updateParams == null) {\n          if (requiresTargetForDelete) {\n            sql.append(\"DELETE \");\n            SQLBuffer deleteTargets = getDeleteTargets(sel);\n            sql.append(deleteTargets);\n            sql.append(\" FROM \");\n          } else {\n            sql.append(\"DELETE FROM \");\n          }\n        }\n        else\n            sql.append(\"UPDATE \");\n        sel.addJoinClassConditions();\n        // if there is only a single table in the select, then we can\n        // just issue a single DELETE FROM TABLE WHERE <conditions>\n        // statement; otherwise, since SQL doesn't allow deleting\n        // from one of a multi-table select, we need to issue a subselect\n        // like DELETE FROM TABLE WHERE EXISTS\n        // (SELECT 1 FROM TABLE t0 WHERE t0.ID = TABLE.ID); also, some\n        // databases do not allow aliases in delete statements, which\n        // also causes us to use a subselect\n        Collection<String> selectedTables = getSelectTableAliases(sel);\n        if (selectedTables.size() == 1 && supportsSubselect\n            && allowsAliasInBulkClause) {\n            SQLBuffer from;\n            if (sel.getFromSelect() != null)\n                from = getFromSelect(sel, false);\n            else\n                from = getFrom(sel, false);\n            sql.append(from);\n            appendUpdates(sel, store, sql, params, updateParams,\n                allowsAliasInBulkClause);\n            SQLBuffer where = sel.getWhere();\n            if (where != null && !where.isEmpty()) {\n                sql.append(\" WHERE \");\n                sql.append(where);\n            }\n            return sql;\n        }\n        Table table = mapping.getTable();\n        String tableName = getFullName(table, false);\n        // only use a  subselect if the where is not empty; otherwise\n        // an unqualified delete or update will work\n        if (sel.getWhere() == null || sel.getWhere().isEmpty()) {\n            sql.append(tableName);\n            appendUpdates(sel, store, sql, params, updateParams, false);\n            return sql;\n        }\n        // we need to use a subselect if we are to bulk delete where\n        // the select includes multiple tables; if the database\n        // doesn't support it, then we need to signal this by returning null\n        if (!supportsSubselect || !supportsCorrelatedSubselect)\n            return null;\n        Column[] pks = mapping.getPrimaryKeyColumns();\n        sel.clearSelects();\n        sel.setDistinct(true);\n        // if we have only a single PK, we can use a non-correlated\n        // subquery (using an IN statement), which is much faster than\n        // a correlated subquery (since a correlated subquery needs\n        // to be executed once for each row in the table)\n        if (pks.length == 1) {\n            sel.select(pks[0]);\n            sql.append(tableName);\n            appendUpdates(sel, store, sql, params, updateParams, false);\n            sql.append(\" WHERE \").\n                append(pks[0]).append(\" IN (\").\n                append(sel.toSelect(false, null)).append(\")\");\n        } else {\n            sel.clearSelects();\n            sel.setDistinct(false);\n            // since the select is using a correlated subquery, we\n            // only need to select a bogus virtual column\n            sel.select(\"1\", null);\n            // add in the joins to the table\n            Column[] cols = table.getPrimaryKey().getColumns();\n            SQLBuffer buf = new SQLBuffer(this);\n            buf.append(\"(\");\n            for (int i = 0; i < cols.length; i++) {\n                if (i > 0)\n                    buf.append(\" AND \");\n                // add in \"t0.PK = MYTABLE.PK\"\n                buf.append(sel.getColumnAlias(cols[i])).append(\" = \").\n                    append(table).append(catalogSeparator).append(cols[i]);\n            }\n            buf.append(\")\");\n            sel.where(buf, null);\n            sql.append(tableName);\n            appendUpdates(sel, store, sql, params, updateParams, false);\n            sql.append(\" WHERE EXISTS (\").\n                append(sel.toSelect(false, null)).append(\")\");\n        }\n        return sql;\n    }<fim_middle>// function below is long method and feature envy\n"}