{"text": "<fim_prefix>        }\n    }\n    private static ArrayList<InstructionBlock>[] computePredecessors(List<InstructionBlock> blocks) {\n        @SuppressWarnings(\"unchecked\")\n        ArrayList<InstructionBlock>[] result = new ArrayList[blocks.size()];\n        for (int i = 0; i < blocks.size(); i++) {\n            result[i] = new ArrayList<>(2);\n        }\n        for (InstructionBlock block : blocks) {\n            TerminatingInstruction terminatingInstruction = block.getTerminatingInstruction();\n            for (int i = 0; i < terminatingInstruction.getSuccessorCount(); i++) {\n                result[terminatingInstruction.getSuccessor(i).getBlockIndex()].add(block);\n            }\n        }\n        return result;\n    }\n    private static void addBlockToWorkList(ArrayDeque<InstructionBlock> workList, BitSet blockOnWorkList, InstructionBlock predecessorBlock) {\n        boolean predecessorBlockIndex = blockOnWorkList.get(predecessorBlock.getBlockIndex());\n        if (!predecessorBlockIndex) {\n            workList.addLast(predecessorBlock);\n            blockOnWorkList.set(predecessorBlock.getBlockIndex());\n        }\n    }\n    private static InstructionBlock removeBlockFromWorkList(ArrayDeque<InstructionBlock> workList, BitSet blockOnWorkList) {\n        InstructionBlock block = workList.removeLast();\n        blockOnWorkList.clear(block.getBlockIndex());\n        return block;\n    }\n    private static boolean or(BitSet dest, BitSet source) {\n        assert dest.size() == source.size();\n        if (isChangeForOrNecessary(dest, source)) {\n            dest.or(source);\n            return true;\n        }\n        return false;\n    }\n    private static boolean isChangeForOrNecessary(BitSet dest, BitSet source) {\n        // this could be far faster if we had direct access to the words in the BitSet\n        int bitIndex = -1;\n        while ((bitIndex = source.nextSetBit(bitIndex + 1)) >= 0) {\n            if (!dest.get(bitIndex)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    private static void processReads(LLVMLivenessReadVisitor readVisitor, Instruction instruction) {\n        instruction.accept(readVisitor);\n    }\n    private void processWrite(SymbolImpl symbol, BlockInfo blockInfo) {\n        int frameSlotIndex = resolve(symbol);\n        if (frameSlotIndex >= 0) {\n            blockInfo.defs.set(frameSlotIndex);\n            if (!blockInfo.gen.get(frameSlotIndex)) {\n                blockInfo.kill.set(frameSlotIndex);\n            }\n        }\n    }\n    private void processRead(SymbolImpl symbol, BlockInfo blockInfo) {\n        int frameSlotIndex = resolve(symbol);\n        processRead(blockInfo, frameSlotIndex);\n    }\n    private static void processRead(BlockInfo blockInfo, int frameSlotIndex) {\n        if (frameSlotIndex >= 0) {\n            if (!blockInfo.kill.get(frameSlotIndex)) {\n                blockInfo.gen.set(frameSlotIndex);\n            }\n        }\n    }\n    private void processValueUsedInPhi(SymbolImpl symbol, BlockInfo blockInfo) {\n        int frameSlotIndex = resolve(symbol);\n        if (frameSlotIndex >= 0) {\n            blockInfo.phiUses.set(frameSlotIndex);\n        }\n    }\n    private void processPhiWrite(PhiInstruction phi, BlockInfo blockInfo) {\n        int frameSlotIndex = resolve(phi);\n        if (frameSlotIndex >= 0) {\n            blockInfo.phiDefs.set(frameSlotIndex);\n            blockInfo.defs.set(frameSlotIndex);\n        }\n    }\n    private int resolve(SymbolImpl symbol) {\n        if (symbol instanceof ValueSymbol && !(symbol instanceof GlobalValueSymbol || symbol instanceof FunctionDefinition || symbol instanceof FunctionDeclaration)) {\n            String name = ((ValueSymbol) symbol).getName();\n            assert name != null;\n            return getFrameSlotIndex(name);\n        }\n        return -1;\n    }\n    private void printIntermediateResult(LLVMContext context, List<InstructionBlock> blocks, BlockInfo[] blockInfos, int processedBlocks) {\n        StringBuilder builder = new StringBuilder();\n        builder.append(functionDefinition.getName());\n        builder.append(\" (processed \");\n        builder.append(processedBlocks);\n        builder.append(\" blocks - CFG has \");\n        builder.append(blocks.size());\n        builder.append(\" blocks)\\n\");\n        for (int i = 0; i < blockInfos.length; i++) {\n            BlockInfo blockInfo = blockInfos[i];\n            builder.append(\"Basic block \");\n            builder.append(i);\n            builder.append(\" (\");\n            builder.append(blocks.get(i).getName());\n            builder.append(\")\\n\");\n            builder.append(\"  In:      \");\n            builder.append(formatLocals(blockInfo.in));\n            builder.append(\"\\n\");\n            builder.append(\"  Gen:     \");\n            builder.append(formatLocals(blockInfo.gen));\n            builder.append(\"\\n\");\n            builder.append(\"  Kill:    \");\n            builder.append(formatLocals(blockInfo.kill));\n            builder.append(\"\\n\");\n            builder.append(\"  Def:     \");\n            builder.append(formatLocals(blockInfo.defs));\n            builder.append(\"\\n\");\n            builder.append(\"  PhiDefs: \");\n            builder.append(formatLocals(blockInfo.phiDefs));\n            builder.append(\"\\n\");\n            builder.append(\"  PhiUses: \");\n            builder.append(formatLocals(blockInfo.phiUses));\n            builder.append(\"\\n\");\n            builder.append(\"  Out:     \");\n            builder.append(formatLocals(blockInfo.out));\n            builder.append(\"\\n\");\n        }\n        SulongEngineOption.getStream(context.getEnv().getOptions().get(SulongEngineOption.PRINT_LIFE_TIME_ANALYSIS_STATS)).println(builder.toString());\n    }\n    private void printResult(LLVMContext context, List<InstructionBlock> blocks, LLVMLivenessAnalysisResult result) {\n        StringBuilder builder = new StringBuilder();\n        for (int i = 0; i < blocks.size(); i++) {\n            builder.append(\"Basic block \");\n            builder.append(i);\n            builder.append(\" (\");\n            builder.append(blocks.get(i).getName());\n            builder.append(\")\\n\");\n            builder.append(\"  NullableBefore: \");\n            builder.append(formatLocals(result.nullableBeforeBlock[i]));\n            builder.append(\"\\n\");\n            builder.append(\"  NullableWithin:  \");\n            builder.append(formatLocalNullers(result.nullableWithinBlock[i]));\n            builder.append(\"\\n\");\n            builder.append(\"  NullableAfter:  \");\n            builder.append(formatLocals(result.nullableAfterBlock[i]));\n            builder.append(\"\\n\");\n        }\n        SulongEngineOption.getStream(context.getEnv().getOptions().get(SulongEngineOption.PRINT_LIFE_TIME_ANALYSIS_STATS)).println(builder.toString());\n    }\n    private String formatLocals(BitSet bitSet) {\n        StringBuilder result = new StringBuilder();\n        int bitIndex = -1;\n        while ((bitIndex = bitSet.nextSetBit(bitIndex + 1)) >= 0) {\n            if (result.length() > 0) {\n                result.append(\", \");\n            }\n            result.append(frameSlots[bitIndex].getIdentifier());\n        }\n        return result.toString();\n    }\n    private static Object formatLocalNullers(ArrayList<NullerInformation> nullers) {\n        StringBuilder result = new StringBuilder();\n        for (NullerInformation nuller : nullers) {\n            if (result.length() > 0) {\n                result.append(\", \");\n            }\n            result.append(nuller.frameSlot.getIdentifier());\n        }\n        return result.toString();\n    }\n    private class LLVMLivenessReadVisitor extends LLVMLocalReadVisitor {\n        private final BlockInfo blockInfo;\n        LLVMLivenessReadVisitor(BlockInfo blockInfo) {\n            this.blockInfo = blockInfo;\n        }\n        @Override\n        public void visitLocalRead(SymbolImpl symbol) {\n            processRead(symbol, blockInfo);\n        }\n    }\n<fim_suffix>    private class LLVMNullerReadVisitor extends LLVMLocalReadVisitor {\n        private final int[] lastInstructionIndexTouchingLocal;\n        private int instructionIndex;\n        LLVMNullerReadVisitor(int[] lastInstructionIndexTouchingLocal) {\n            this.lastInstructionIndexTouchingLocal = lastInstructionIndexTouchingLocal;\n        }\n        public void setInstructionIndex(int instructionIndex) {\n            this.instructionIndex = instructionIndex;\n        }\n        @Override\n        public void visitLocalRead(SymbolImpl symbol) {\n            int frameSlotIndex = resolve(symbol);\n            if (frameSlotIndex >= 0) {\n                lastInstructionIndexTouchingLocal[frameSlotIndex] = instructionIndex;\n            }\n        }\n    }<fim_middle>// class below has no smell\n"}