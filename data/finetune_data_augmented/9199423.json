{"text": "<fim_prefix>\n<fim_suffix>public class BaseScriptEvalUtil\n{\t\n\tprivate static Logger logger = Logger.getLogger( BaseScriptEvalUtil.class.getName( ) );\n\t/**\n\t * No instance\n\t */\n\tprotected BaseScriptEvalUtil( )\n\t{\n\t}\n\t/**\n\t * @param exprText\n\t * @param value\n\t * @return an instance of ExprTextAndValue\n\t */\n\tpublic static ExprTextAndValue newExprInfo( Object value )\n\t{\n\t\treturn ExprTextAndValue.newInstance( value );\n\t}\n\t/**\n\t * Evaluates a conditional expression. A conditional expression comprises of\n\t * a Javascript expression, an operator, and up to 2 operands (which are\n\t * Javascript expressions themselves).<br>\n\t * Both op1 and op2 will be encapsulated to ExprTextAndValue type to show\n\t * specific message in case anything goes wrong, they are assumed not to be\n\t * null as well.\n\t * <p>\n\t * The basic rule for comparison: obj will always be considered as the\n\t * default data type,i.e. obj, op1 and op2 will be formatted to the superset\n\t * of obj (or Double if obj is numeric)on the condition they are comparable.<br>\n\t * e.g.<br>\n\t * obj: Integer=>obj, op1 and op2 will be formatted to Double.<br>\n\t * obj: Timestamp=>obj, op1 and op2 will be formatted to Date.<br>\n\t * obj: Boolean=>obj and op1 will be formatted to Boolean.<br>\n\t * obj: String=>obj, op1 and op2 will remain the same\n\t * \n\t * @param obj\n\t * @param operator\n\t * @param Op1\n\t * @param Op2\n\t * @return\n\t * @throws DataException\n\t */\n\tpublic static Object evalConditionalExpr( Object obj, int operator,\n\t\t\tObject Op1, Object Op2 ) throws DataException\n\t{\n\t\treturn evalConditionalExpr( obj, operator, Op1, Op2, null );\n\t}\n\t/**\n\t * \n\t * @param obj\n\t * @param operator\n\t * @param Op1\n\t * @param Op2\n\t * @param compareHints the hints for comparison\n\t * @return\n\t * @throws DataException\n\t */\n\tpublic static Object evalConditionalExpr( Object obj, int operator,\n\t\t\tObject Op1, Object Op2, BaseCompareHints compareHints )\n\t\t\tthrows DataException\n\t{\n\t\treturn evalConditionalExpr( obj, operator, new Object[]{\n\t\t\t\tOp1, Op2\n\t\t}, compareHints );\n\t}\n\t/**\n\t * \n\t * @param obj\n\t * @param operator\n\t * @param ops\n\t * @return\n\t * @throws DataException\n\t */\n\tpublic static Object evalConditionalExpr( Object obj, int operator,\n\t\t\tObject[] ops ) throws DataException\n\t{\n\t\treturn evalConditionalExpr( obj, operator, ops, null );\n\t}\n\t/**\n\t * \n\t * @param obj\n\t * @param operator\n\t * @param op1\n\t * @param op2\n\t * @return A Boolean result\n\t * @throws DataException\n\t */\n\tpublic static Object evalConditionalExpr( Object obj, int operator,\n\t\t\tObject[] ops, BaseCompareHints compareHints ) throws DataException\n\t{\n\t\tExprTextAndValue[] opTextAndValue = new ExprTextAndValue[ops.length];\n\t\tfor ( int i = 0; i < ops.length; i++ )\n\t\t{\n\t\t\topTextAndValue[i] = createExprTextAndValueInstance( ops[i] );\n\t\t}\n\t\tObject resultObject = obj;\n\t\tObject[] resultOp = new Object[ops.length];\n\t\tfor ( int i = 0; i < ops.length; i++ )\n\t\t{\n\t\t\tresultOp[i] = opTextAndValue[i].value;\n\t\t\tif ( operator != IConditionalExpression.OP_IN \n\t\t\t\t\t&& operator != IConditionalExpression.OP_NOT_IN )\n\t\t\t{\n\t\t\t\tif ( opTextAndValue[i].value != null \n\t\t\t\t\t\t&& opTextAndValue[i].value.getClass( ).isArray( ))\n\t\t\t\t{\n\t\t\t\t\t//For case multi-value type report parameter is involved in signle-value-required filters \n\t\t\t\t\t//more than 1 values are provided for multi-value parameter\n\t\t\t\t\tif ( Array.getLength( opTextAndValue[i].value ) > 1 )\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new DataException(\n\t\t\t\t\t\t\t\tResourceConstants.BAD_COMPARE_SINGLE_WITH_MULITI, toStringForMultiValues( opTextAndValue[i].value ) );\n\t\t\t\t\t}\n\t\t\t\t\t//no or only one value is provided for multi-value parameter\n\t\t\t\t\tif ( Array.getLength( opTextAndValue[i].value ) == 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tresultOp[i] = null;\n\t\t\t\t\t}\n\t\t\t\t\telse if ( Array.getLength( opTextAndValue[i].value ) == 1 )\n\t\t\t\t\t{\n\t\t\t\t\t\tresultOp[i] = Array.get( opTextAndValue[i].value, 0 );\n\t\t\t\t\t}\n\t\t\t\t\topTextAndValue[i].value = resultOp[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tObject[] obArray = MiscUtil.isComparable( obj, operator, opTextAndValue );\n\t\tif ( obArray != null )\n\t\t{\n\t\t\tresultObject = obArray[0];\n\t\t\tfor ( int i = 1; i < obArray.length; i++ )\n\t\t\t{\n\t\t\t\tresultOp[i - 1] = obArray[i];\n\t\t\t}\n\t\t}\n\t\tif ( logger.isLoggable( Level.FINER ) )\n\t\t{\n\t\t\tString logStr = \"\";\n\t\t\tfor ( int i = 0; i < ops.length; i++ )\n\t\t\t{\n\t\t\t\tlogStr += resultOp[i] == null\n\t\t\t\t\t\t? null\n\t\t\t\t\t\t: ( \", resultOp\" + i + \"=\" + BaseLogUtil.toString( resultOp[i] ) );\n\t\t\t}\n\t\t\tlogger.entering( BaseScriptEvalUtil.class.getName( ),\n\t\t\t\t\t\"evalConditionalExpr\",\n\t\t\t\t\t\"evalConditionalExpr() resultObject=\"\n\t\t\t\t\t\t\t+ BaseLogUtil.toString( resultObject ) + \", operator=\"\n\t\t\t\t\t\t\t+ operator + logStr );\n\t\t}\n\t\tboolean result = false;\n\t\tif ( compareHints != null\n\t\t\t\t&& IBaseDataSetDesign.NULLS_ORDERING_EXCLUDE_NULLS.equals( compareHints.getNullType( ) ) )\n\t\t{\n\t\t\tif ( resultObject == null )\n\t\t\t\treturn false;\n\t\t}\n\t\tswitch ( operator )\n\t\t{\n\t\t\tcase IConditionalExpression.OP_EQ :\n\t\t\t\tresult = compare( resultObject, resultOp[0], compareHints ) == 0;\n\t\t\t\tbreak;\n\t\t\tcase IConditionalExpression.OP_NE :\n\t\t\t\tresult = compare( resultObject, resultOp[0], compareHints ) != 0;\n\t\t\t\tbreak;\n\t\t\tcase IConditionalExpression.OP_LT :\n\t\t\t\tresult = compare( resultObject, resultOp[0], compareHints ) < 0;\n\t\t\t\tbreak;\n\t\t\tcase IConditionalExpression.OP_LE :\n\t\t\t\tresult = compare( resultObject, resultOp[0], compareHints ) <= 0;\n\t\t\t\tbreak;\n\t\t\tcase IConditionalExpression.OP_GE :\n\t\t\t\tresult = compare( resultObject, resultOp[0], compareHints ) >= 0;\n\t\t\t\tbreak;\n\t\t\tcase IConditionalExpression.OP_GT :\n\t\t\t\tresult = compare( resultObject, resultOp[0], compareHints ) > 0;\n\t\t\t\tbreak;\n\t\t\tcase IConditionalExpression.OP_BETWEEN :\n\t\t\t\tresult = between( resultObject,\n\t\t\t\t\t\tresultOp[0],\n\t\t\t\t\t\tresultOp[1],\n\t\t\t\t\t\tcompareHints );\n\t\t\t\tbreak;\n\t\t\tcase IConditionalExpression.OP_NOT_BETWEEN :\n\t\t\t\tresult = !( between( resultObject,\n\t\t\t\t\t\tresultOp[0],\n\t\t\t\t\t\tresultOp[1],\n\t\t\t\t\t\tcompareHints ) );\n\t\t\t\tbreak;\n\t\t\tcase IConditionalExpression.OP_NULL :\n\t\t\t\tresult = resultObject == null;\n\t\t\t\tbreak;\n\t\t\tcase IConditionalExpression.OP_NOT_NULL :\n\t\t\t\tresult = resultObject != null;\n\t\t\t\tbreak;\n\t\t\tcase IConditionalExpression.OP_TRUE :\n\t\t\t\tresult = isTrueOrFalse( resultObject, Boolean.TRUE );\n\t\t\t\tbreak;\n\t\t\tcase IConditionalExpression.OP_FALSE :\n\t\t\t\tresult = isTrueOrFalse( resultObject, Boolean.FALSE );\n\t\t\t\tbreak;\n\t\t\tcase IConditionalExpression.OP_LIKE :\n\t\t\t\tresult = like( resultObject, resultOp[0] );\n\t\t\t\tbreak;\n\t\t\tcase IConditionalExpression.OP_NOT_LIKE :\n\t\t\t\tresult = !like( resultObject, resultOp[0] );\n\t\t\t\tbreak;\n\t\t\tcase IConditionalExpression.OP_TOP_N :\n\t\t\tcase IConditionalExpression.OP_BOTTOM_N :\n\t\t\tcase IConditionalExpression.OP_TOP_PERCENT :<fim_middle>// class below is blob\n"}