{"text": "<fim_prefix>/*\n * Copyright (c) 2009, 2013, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage com.sun.tools.javap;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport com.sun.tools.classfile.AccessFlags;\nimport com.sun.tools.classfile.Attribute;\nimport com.sun.tools.classfile.Code_attribute;\nimport com.sun.tools.classfile.ConstantPool;\nimport com.sun.tools.classfile.ConstantPoolException;\nimport com.sun.tools.classfile.Descriptor;\nimport com.sun.tools.classfile.Descriptor.InvalidDescriptor;\nimport com.sun.tools.classfile.Instruction;\nimport com.sun.tools.classfile.Method;\nimport com.sun.tools.classfile.StackMapTable_attribute;\nimport com.sun.tools.classfile.StackMapTable_attribute.*;\nimport static com.sun.tools.classfile.StackMapTable_attribute.verification_type_info.*;\n/**\n * Annotate instructions with stack map.\n *\n *  <p><b>This is NOT part of any supported API.\n *  If you write code that depends on this, you do so at your own risk.\n *  This code and its internal interfaces are subject to change or\n *  deletion without notice.</b>\n */\npublic class StackMapWriter extends InstructionDetailWriter {\n    static StackMapWriter instance(Context context) {\n        StackMapWriter instance = context.get(StackMapWriter.class);\n        if (instance == null)\n            instance = new StackMapWriter(context);\n        return instance;\n    }\n    protected StackMapWriter(Context context) {\n        super(context);\n        context.put(StackMapWriter.class, this);\n        classWriter = ClassWriter.instance(context);\n    }\n    public void reset(Code_attribute attr) {\n        setStackMap((StackMapTable_attribute) attr.attributes.get(Attribute.StackMapTable));\n    }\n<fim_suffix>    void setStackMap(StackMapTable_attribute attr) {\n        if (attr == null) {\n            map = null;\n            return;\n        }\n        Method m = classWriter.getMethod();\n        Descriptor d = m.descriptor;\n        String[] args;\n        try {\n            ConstantPool cp = classWriter.getClassFile().constant_pool;\n            String argString = d.getParameterTypes(cp);\n            args = argString.substring(1, argString.length() - 1).split(\"[, ]+\");\n        } catch (ConstantPoolException | InvalidDescriptor e) {\n            return;\n        }\n        boolean isStatic = m.access_flags.is(AccessFlags.ACC_STATIC);\n        verification_type_info[] initialLocals = new verification_type_info[(isStatic ? 0 : 1) + args.length];\n        if (!isStatic)\n            initialLocals[0] = new CustomVerificationTypeInfo(\"this\");\n        for (int i = 0; i < args.length; i++) {\n            initialLocals[(isStatic ? 0 : 1) + i] =\n                    new CustomVerificationTypeInfo(args[i].replace(\".\", \"/\"));\n        }\n        map = new HashMap<>();\n        StackMapBuilder builder = new StackMapBuilder();\n        // using -1 as the pc for the initial frame effectively compensates for\n        // the difference in behavior for the first stack map frame (where the\n        // pc offset is just offset_delta) compared to subsequent frames (where\n        // the pc offset is always offset_delta+1).\n        int pc = -1;\n        map.put(pc, new StackMap(initialLocals, empty));\n        for (int i = 0; i < attr.entries.length; i++)\n            pc = attr.entries[i].accept(builder, pc);\n    }\n    public void writeInitialDetails() {\n        writeDetails(-1);\n    }\n    public void writeDetails(Instruction instr) {\n        writeDetails(instr.getPC());\n    }\n    private void writeDetails(int pc) {\n        if (map == null)\n            return;\n        StackMap m = map.get(pc);\n        if (m != null) {\n            print(\"StackMap locals: \", m.locals);\n            print(\"StackMap stack: \", m.stack);\n        }\n    }\n    void print(String label, verification_type_info[] entries) {\n        print(label);\n        for (int i = 0; i < entries.length; i++) {\n            print(\" \");\n            print(entries[i]);\n        }\n        println();\n    }\n    void print(verification_type_info entry) {\n        if (entry == null) {\n            print(\"ERROR\");\n            return;\n        }\n        switch (entry.tag) {\n            case -1:\n                print(((CustomVerificationTypeInfo) entry).text);\n                break;\n            case ITEM_Top:\n                print(\"top\");\n                break;\n            case ITEM_Integer:\n                print(\"int\");\n                break;\n            case ITEM_Float:\n                print(\"float\");\n                break;\n            case ITEM_Long:\n                print(\"long\");\n                break;\n            case ITEM_Double:\n                print(\"double\");\n                break;\n            case ITEM_Null:\n                print(\"null\");\n                break;\n            case ITEM_UninitializedThis:\n                print(\"uninit_this\");\n                break;\n            case ITEM_Object:\n                try {\n                    ConstantPool cp = classWriter.getClassFile().constant_pool;\n                    ConstantPool.CONSTANT_Class_info class_info = cp.getClassInfo(((Object_variable_info) entry).cpool_index);\n                    print(cp.getUTF8Value(class_info.name_index));\n                } catch (ConstantPoolException e) {\n                    print(\"??\");\n                }\n                break;\n            case ITEM_Uninitialized:\n                print(((Uninitialized_variable_info) entry).offset);\n                break;\n        }\n    }\n    private Map<Integer, StackMap> map;\n    private ClassWriter classWriter;\n    class StackMapBuilder\n            implements StackMapTable_attribute.stack_map_frame.Visitor<Integer, Integer> {\n        public Integer visit_same_frame(same_frame frame, Integer pc) {\n            int new_pc = pc + frame.getOffsetDelta() + 1;\n            StackMap m = map.get(pc);\n            assert (m != null);\n            map.put(new_pc, m);\n            return new_pc;\n        }\n        public Integer visit_same_locals_1_stack_item_frame(same_locals_1_stack_item_frame frame, Integer pc) {\n            int new_pc = pc + frame.getOffsetDelta() + 1;\n            StackMap prev = map.get(pc);\n            assert (prev != null);\n            StackMap m = new StackMap(prev.locals, frame.stack);\n            map.put(new_pc, m);\n            return new_pc;\n        }\n        public Integer visit_same_locals_1_stack_item_frame_extended(same_locals_1_stack_item_frame_extended frame, Integer pc) {\n            int new_pc = pc + frame.getOffsetDelta() + 1;\n            StackMap prev = map.get(pc);\n            assert (prev != null);\n            StackMap m = new StackMap(prev.locals, frame.stack);\n            map.put(new_pc, m);\n            return new_pc;\n        }\n        public Integer visit_chop_frame(chop_frame frame, Integer pc) {\n            int new_pc = pc + frame.getOffsetDelta() + 1;\n            StackMap prev = map.get(pc);\n            assert (prev != null);\n            int k = 251 - frame.frame_type;\n            verification_type_info[] new_locals = Arrays.copyOf(prev.locals, prev.locals.length - k);\n            StackMap m = new StackMap(new_locals, empty);<fim_middle>// function below is long method\n"}