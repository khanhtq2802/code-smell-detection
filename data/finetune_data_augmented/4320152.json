{"text": "<fim_prefix>     *      daemon automatically updating stats, {@code false} if not\n     * @param td current table descriptor being worked on, may be {@code null}\n     * @param t raised error, may be {@code null}\n     * @param msg the message to log\n     */\n    private void log(boolean asBackgroundTask, TableDescriptor td, Throwable t,\n            String msg) {\n        if (asBackgroundTask && (doLog || t != null)) {\n            logAlways(td, t, msg);\n        }\n    }\n    /**\n     * Logs the information given.\n     *\n     * @param td current table descriptor being worked on, may be {@code null}\n     * @param t raised error, may be {@code null}\n     * @param msg the message to log\n     */\n    private void logAlways(TableDescriptor td, Throwable t, String msg) {\n        PrintWriter pw;\n        String hdrMsg = \"{istat} \" +\n                (td == null ? \"\" : td.getQualifiedName() + \": \") + msg;\n        if (t != null) {\n            pw = new PrintWriter(logStream.getPrintWriter(), false);\n            pw.print(logStream.getHeader().getHeader());\n            pw.println(hdrMsg);\n            t.printStackTrace(pw);\n            pw.flush();\n        } else {\n            logStream.printlnWithHeader(hdrMsg);\n        }\n    }\n    // @GuardedBy(\"this\")\n    private final StringBuffer tsb = new StringBuffer();\n    private synchronized void trace(int indentLevel, String msg) {\n        if (doTrace) {\n            tsb.setLength(0);\n            tsb.append(\"{istat,trace@\").append(hashCode()).append(\"} \");\n            for (int i=0; i < indentLevel; i++) {\n                tsb.append(\"    \");\n            }\n            tsb.append(msg).append(' ');\n            if (indentLevel == 0) {\n                appendRunStats(tsb);\n            }\n            if (traceToDerbyLog && logStream != null) {\n                logStream.printlnWithHeader(tsb.toString());\n            }\n            if (traceToStdOut) {\n                System.out.println(tsb.toString());\n            }\n        }\n    }\n    /**\n     * Appends runtime statistics to the given string buffer.\n     *\n     * @param sb the string buffer to append to\n     */\n    // @GuardedBy(\"queue\")\n    private void appendRunStats(StringBuffer sb) {\n        // Print rather detailed and cryptic stats.\n        sb.append(\"[q/p/s=\").append(queue.size()). // current queue size\n                append('/').append(wuProcessed). // scheduled\n                append('/').append(wuScheduled). //processed\n                append(\",err:k/u/c=\").\n                append(errorsKnown). // known errors\n                append('/').append(errorsUnknown). // unexpected errors\n                append('/').append(errorsConsecutive). // consecutive errors\n                append(\",rej:f/d/o=\").\n                append(wuRejectedFQ). // rejected, full queue\n                append('/').append(wuRejectedDup). // rejected, duplicate\n                append('/').append(wuRejectedOther). // rejected, other\n                append(']');\n    }\n    /**\n     * Produces a textual representation of the cardinality numbers.\n     *\n     * @param cardinality index cardinality\n     * @return A string.\n     */\n    private static String cardToStr(long[] cardinality) {\n        if (cardinality.length == 1) {\n            return \"[\" + Long.toString(cardinality[0]) + \"]\";\n        } else {\n            StringBuffer sb = new StringBuffer(\"[\");\n            for (int i=0; i < cardinality.length; i++) {\n                sb.append(cardinality[i]).append(',');\n            }\n            sb.deleteCharAt(sb.length() -1).append(']');\n            return sb.toString();\n        }\n    }\n    /** Purely for debugging, to avoid printing too much info. */\n    private static String extractIstatInfo(Throwable t) {\n        String istatClass = IndexStatisticsDaemonImpl.class.getName();\n        StackTraceElement[] stack = t.getStackTrace();\n        String trace = \"<no stacktrace>\";\n        String sqlState = \"\";\n        for (int i=0; i < stack.length ; i++) {\n            StackTraceElement ste = stack[i];\n            if (ste.getClassName().startsWith(istatClass)) {\n                trace = ste.getMethodName() + \"#\" + ste.getLineNumber();\n                if (i > 0) {\n                    ste = stack[i -1];\n                    trace += \" -> \" + ste.getClassName() + \".\" +\n                            ste.getMethodName() + \"#\" + ste.getLineNumber();\n                }\n                break;\n            }\n        }\n        if (t instanceof StandardException) {\n            sqlState = \", SQLSTate=\" + ((StandardException)t).getSQLState();\n        }\n        return \"<\" + t.getClass() + \", msg=\" + t.getMessage() + sqlState +\n                \"> \" + trace;\n    }\n    /**\n     * Privileged lookup of the ContextService. Must be private so that user code\n     * can't call this entry point.\n     */\n    private  static  ContextService    getContextService()\n    {\n        if ( System.getSecurityManager() == null )\n        {\n            return ContextService.getFactory();\n        }\n        else\n        {\n            return AccessController.doPrivileged\n                (\n                 new PrivilegedAction<ContextService>()\n                 {\n                     public ContextService run()\n                     {\n                         return ContextService.getFactory();\n                     }\n                 }\n                 );\n        }\n    }    \n    /**\n     * Support class used to compare keys when scanning indexes.\n     */\n    //@NotThreadSafe\n<fim_suffix>    private static class KeyComparator {\n        /** Number of rows fetched per iteration. */\n        private static final int FETCH_SIZE = 16;\n        private final DataValueDescriptor[][] rowBufferArray;\n        private DataValueDescriptor[] lastUniqueKey;\n        private DataValueDescriptor[] curr;\n        private DataValueDescriptor[] prev;\n        private int rowsReadLastRead = -1;\n        private long numRows;\n        /**\n         * Creates a key comparator for the given index.\n         *\n         * @param ir index row (template)\n         */\n        public KeyComparator(ExecIndexRow ir) {\n            rowBufferArray = new DataValueDescriptor[FETCH_SIZE][];\n            rowBufferArray[0] = ir.getRowArray(); // 1 gets old objects.\n            lastUniqueKey = ir.getRowArrayClone();\n        }\n        /**\n         * Fetches rows from the scan controller.\n         *\n         * @param gsc the scan controller\n         * @return Number of rows fetched.\n         * @throws StandardException if fetching rows fails\n         */\n        public int fetchRows(GroupFetchScanController gsc)\n                throws StandardException {\n            // Save state (and optimize) for next read.\n            // Assumes that we always read as many rows as we can per iteration.\n            if (rowsReadLastRead == FETCH_SIZE) {\n                // Reuse curr to reference the current last unique key.\n                curr = rowBufferArray[FETCH_SIZE - 1];\n                // Reuse the old last unique row array for the coming fetch.\n                rowBufferArray[FETCH_SIZE - 1] = lastUniqueKey;\n                // Finally we update the pointer to the last unique key.\n                lastUniqueKey = curr;\n            }\n            rowsReadLastRead = gsc.fetchNextGroup(rowBufferArray, null);\n            return rowsReadLastRead;\n        }\n        /**\n         * Compares the key at the specified index with the previous key.\n         *\n         * @param index row index\n         * @return {@code -1} if the current and previous key are identical,\n         *      the index of the changed part of the key otherwise\n         *      ([0, key length&gt;)\n         * @throws StandardException if comparing the two keys fails\n         */\n        public int compareWithPrevKey(int index)\n                throws StandardException {\n            if (index > rowsReadLastRead) {\n                throw new IllegalStateException(\n                        \"invalid access, rowsReadLastRead=\" + rowsReadLastRead +\n                        \", index=\" + index + \", numRows=\" + numRows);\n            }\n            numRows++;\n            // First row ever is always a distinct key.\n            if (numRows == 1) {\n                return 0;\n            }\n            prev = (index == 0) ? lastUniqueKey\n                                : rowBufferArray[index - 1];\n            curr = rowBufferArray[index];\n            DataValueDescriptor dvd;\n            // no point trying to do rowlocation; hence - 1\n            for (int i = 0; i < (prev.length - 1); i++) {\n                dvd = (DataValueDescriptor)prev[i];\n                // NULLs are counted as unique values.\n                if (dvd.isNull() || prev[i].compare(curr[i]) != 0) {\n                  return i;\n                }\n            }\n            return -1;\n        }\n        /**\n         * Returns the number of rows fetched.\n         *\n         * @return Number of rows fetched.\n         */\n        public long getRowCount() {\n            return numRows;\n        }\n    }<fim_middle>// class below has no smell\n"}