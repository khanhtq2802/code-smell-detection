{"text": "<fim_prefix>    if (errorHandler != null) {\n      errorHandler.dispatchEvent(e);\n    }\n  }\n  void loadStyle(\n      ComponentContext c,\n      @AttrRes int defStyleAttr,\n      @StyleRes int defStyleRes) {\n    c.setDefStyle(defStyleAttr, defStyleRes);\n    onLoadStyle(c);\n    c.setDefStyle(0, 0);\n  }\n  void loadStyle(ComponentContext c) {\n    onLoadStyle(c);\n  }\n  /**\n   * Retrieves all of the tree props used by this Component from the TreeProps map\n   * and sets the tree props as fields on the ComponentImpl.\n   */\n  protected void populateTreeProps(TreeProps parentTreeProps) {\n  }\n  /**\n   * Updates the TreeProps map with outputs from all {@link OnCreateTreeProp} methods.\n   */\n  protected TreeProps getTreePropsForChildren(\n      ComponentContext c,\n      TreeProps previousTreeProps) {\n    return previousTreeProps;\n  }\n  /**\n   * Generate a tree of {@link ComponentLayout} representing the layout structure of the {@link\n   * Component} and its sub-components. You should use {@link ComponentContext#newLayoutBuilder} to\n   * build the layout tree.\n   *\n   * @param c The {@link ComponentContext} to build a {@link ComponentLayout} tree.\n   */\n  protected Component onCreateLayout(ComponentContext c) {\n    return Column.create(c).build();\n  }\n  protected Component onCreateLayoutWithSizeSpec(\n      ComponentContext c, int widthSpec, int heightSpec) {\n    return Column.create(c).build();\n  }\n  /** Resolves the {@link ComponentLayout} for the given {@link Component}. */\n  protected ComponentLayout resolve(ComponentContext c) {\n    return createLayout(c, false);\n  }\n  protected void onPrepare(ComponentContext c) {\n    // do nothing, by default\n  }\n  protected void onLoadStyle(ComponentContext c) {\n  }\n  /**\n   * Called after the layout calculation is finished and the given {@link ComponentLayout} has its\n   * bounds defined. You can use {@link ComponentLayout#getX()}, {@link ComponentLayout#getY()},\n   * {@link ComponentLayout#getWidth()}, and {@link ComponentLayout#getHeight()} to get the size and\n   * position of the component in the layout tree.\n   *\n   * @param c The {@link Context} used by this component.\n   * @param layout The {@link ComponentLayout} with defined position and size.\n   */\n  protected void onBoundsDefined(ComponentContext c, ComponentLayout layout) {}\n  /**\n   * Called during layout calculation to determine the baseline of a component.\n   *\n   * @param c The {@link Context} used by this component.\n   * @param width The width of this component.\n   * @param height The height of this component.\n   */\n  protected int onMeasureBaseline(ComponentContext c, int width, int height) {\n    return height;\n  }\n  /**\n   * Whether this {@link ComponentLifecycle} is able to measure itself according\n   * to specific size constraints.\n   */\n  protected boolean canMeasure() {\n    return false;\n  }\n  /**\n   * @return {@code true} iff the {@link LayoutSpec} implements {@link\n   *     OnShouldCreateLayoutWithNewSizeSpec} to {@code true}.\n   */\n  protected boolean isLayoutSpecWithSizeSpecCheck() {\n    return false;\n  }\n  protected void onMeasure(\n      ComponentContext c, ComponentLayout layout, int widthSpec, int heightSpec, Size size) {\n    throw new IllegalStateException(\n        \"You must override onMeasure() if you return true in canMeasure(), \"\n            + \"ComponentLifecycle is: \"\n            + this);\n  }\n  /**\n   * Whether this {@link ComponentLifecycle} mounts views that contain component-based content that\n   * can be incrementally mounted e.g. if the mounted view has a LithoView with incremental mount\n   * enabled.\n   */\n  protected boolean hasChildLithoViews() {\n    return false;\n  }\n  /**\n   * Whether this drawable mount spec should cache its drawing in a display list.\n   */\n  protected boolean shouldUseDisplayList() {\n    return false;\n  }\n  /**\n   * Create the object that will be mounted in the {@link LithoView}.\n   *\n   * @param context The {@link Context} to be used to create the content.\n   * @return an Object that can be mounted for this component.\n   */\n  protected Object onCreateMountContent(Context context) {\n    throw new RuntimeException(\n        \"Trying to mount a MountSpec that doesn't implement @OnCreateMountContent\");\n  }\n  /**\n   * @return the MountContentPool that should be used to recycle mount content for this mount spec.\n   */\n  protected MountContentPool onCreateMountContentPool() {\n    return new DefaultMountContentPool(getClass().getSimpleName(), poolSize(), true);\n  }\n  /**\n   * Deploy all UI elements representing the final bounds defined in the given {@link\n   * ComponentLayout}. Return either a {@link Drawable} or a {@link View} or {@code null} to be\n   * mounted.\n   *\n   * @param c The {@link ComponentContext} to mount the component into.\n   */\n  protected void onMount(ComponentContext c, Object convertContent) {\n    // Do nothing by default.\n  }\n  /**\n   * Unload UI elements associated with this component.\n   *\n   * @param c The {@link Context} for this mount operation.\n   * @param mountedContent The {@link Drawable} or {@link View} mounted by this component.\n   */\n  protected void onUnmount(ComponentContext c, Object mountedContent) {\n    // Do nothing by default.\n  }\n  protected void onBind(ComponentContext c, Object mountedContent) {\n    // Do nothing by default.\n  }\n  protected void onUnbind(ComponentContext c, Object mountedContent) {\n    // Do nothing by default.\n  }\n  /**\n   * This indicates the type of the {@link Object} that will be returned by {@link\n   * ComponentLifecycle#mount}.\n   *\n   * @return one of {@link ComponentLifecycle.MountType}\n   */\n  public MountType getMountType() {\n    return MountType.NONE;\n  }\n  /**\n   * Populate an accessibility node with information about the component.\n   *\n   * @param accessibilityNode node to populate\n   */\n  protected void onPopulateAccessibilityNode(\n      View host, AccessibilityNodeInfoCompat accessibilityNode) {}\n  /**\n   * Populate an extra accessibility node.\n   * @param accessibilityNode node to populate\n   * @param extraNodeIndex index of extra node\n   * @param componentBoundsX left bound of the mounted component\n   * @param componentBoundsY top bound of the mounted component\n   */\n  protected void onPopulateExtraAccessibilityNode(\n      AccessibilityNodeInfoCompat accessibilityNode,\n      int extraNodeIndex,\n      int componentBoundsX,\n      int componentBoundsY) {\n  }\n  /**\n   * Get extra accessibility node id at a given point within the component.\n   * @param x x co-ordinate within the mounted component\n   * @param y y co-ordinate within the mounted component\n   * @return the extra virtual view id if one is found, otherwise\n   *         {@code ExploreByTouchHelper#INVALID_ID}\n   */\n  protected int getExtraAccessibilityNodeAt(int x, int y) {\n    return ExploreByTouchHelper.INVALID_ID;\n  }\n  /**\n   * The number of extra accessibility nodes that this component wishes to provides to the\n   * accessibility system.\n   * @return the number of extra nodes\n   */\n  protected int getExtraAccessibilityNodesCount() {\n    return 0;\n  }\n  /**\n   * Whether this component will expose any virtual views to the accessibility framework\n   * @return true if the component exposes extra accessibility nodes\n   */\n  protected boolean implementsExtraAccessibilityNodes() {\n    return false;\n  }\n  /**\n   * Whether this component will populate any accessibility nodes or events that are passed to it.\n   * @return true if the component implements accessibility info\n   */\n  protected boolean implementsAccessibility() {\n    return false;\n  }\n  /**\n   * Call this to transfer the {@link com.facebook.litho.annotations.State} annotated values between\n   * two {@link Component} with the same global scope.\n   */\n  protected void transferState(\n      StateContainer previousStateContainer, StateContainer nextStateContainer) {}\n  protected void createInitialState(ComponentContext c) {\n  }\n  /**\n   * Called to provide a fallback if a supported lifecycle method throws an exception. It is\n   * possible to either recover from the error here or reraise the exception to catch it at a higher\n   * level or crash the application.\n   *\n   * @see com.facebook.litho.annotations.OnError\n   * @param c The {@link ComponentContext} the Component was constructed with.\n   * @param e The exception caught.\n   */\n  protected void onError(ComponentContext c, Exception e) {\n    throw new RuntimeException(e);\n  }\n<fim_suffix>  @Override\n  public @Nullable Object dispatchOnEvent(EventHandler eventHandler, Object eventState) {\n    if (ComponentsConfiguration.enableOnErrorHandling && eventHandler.id == ERROR_EVENT_HANDLER_ID) {\n      ((Component) this).getErrorHandler().dispatchEvent(((ErrorEvent) eventState));\n    }\n    // Don't do anything by default, unless we're handling an error.\n    return null;\n  }<fim_middle>// function below has no smell\n"}