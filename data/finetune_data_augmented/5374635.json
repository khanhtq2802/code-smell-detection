{"text": "<fim_prefix>        // 4 - spillableRegistered +4 instead of 1 to round it to eight\n        // 36 - mContents fixed\n        used += 84 + mFields_size;\n        // add up overhead for mSpillFiles ArrayList, Object[] inside ArrayList,\n        // object variable inside ArrayList and references to spill files\n        if (mSpillFiles != null) {\n            used += roundToEight(36 /* mSpillFiles fixed overhead*/ + mSpillFiles.size()*4);\n            if(mSpillFiles.size() > 0){\n                //a rough estimate of memory used by each file entry\n                // the auto generated files are likely to have same length\n                long approx_per_entry_size =\n                    roundToEight(mSpillFiles.get(0).toString().length() * 2 + 38);\n                used += mSpillFiles.size() * approx_per_entry_size;\n            }\n        }\n        return used;\n    }\n    /**\n     * Memory size of objects are rounded to multiple of 8 bytes\n     * @param i\n     * @return i rounded to a equal of higher multiple of 8\n     */\n    private long roundToEight(long i) {\n        return 8 * ((i+7)/8); // integer division rounds the result down\n    }\n    /**\n     * Clear out the contents of the bag, both on disk and in memory.\n     * Any attempts to read after this is called will produce undefined\n     * results.\n     */\n    @Override\n    public void clear() {\n        synchronized (mContents) {\n            mContents.clear();\n            if (mSpillFiles != null) {\n                for (int i = 0; i < mSpillFiles.size(); i++) {\n                    boolean res = mSpillFiles.get(i).delete();\n                    if (!res)\n                        warn (\"DefaultAbstractBag.clear: failed to delete \" + mSpillFiles.get(i), PigWarning.DELETE_FAILED, null);\n                }\n                mSpillFiles.clear();\n            }\n            mSize = 0;\n            aggSampleTupleSize = 0;\n            sampled = 0;\n            // not changing spillableRegistered -- clear doesn't change that.\n        }\n    }\n    /**\n     * This method is potentially very expensive since it may require a\n     * sort of the bag; don't call it unless you have to.\n     */\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public int compareTo(Object other) {\n        if (this == other)\n            return 0;\n        if (other instanceof DataBag) {\n            DataBag bOther = (DataBag) other;\n            if (this.size() != bOther.size()) {\n                if (this.size() > bOther.size()) return 1;\n                else return -1;\n            }\n            // Ugh, this is bogus.  But I have to know if two bags have the\n            // same tuples, regardless of order.  Hopefully most of the\n            // time the size check above will prevent this.\n            // If either bag isn't already sorted, create a sorted bag out\n            // of it so I can guarantee order.\n            DataBag thisClone;\n            DataBag otherClone;\n            BagFactory factory = BagFactory.getInstance();\n            if (this.isSorted() || this.isDistinct()) {\n                thisClone = this;\n            } else {\n                thisClone = factory.newSortedBag(null);\n                Iterator<Tuple> i = iterator();\n                while (i.hasNext()) thisClone.add(i.next());\n            }\n            if (((DataBag) other).isSorted() || ((DataBag)other).isDistinct()) {\n                otherClone = bOther;\n            } else {\n                otherClone = factory.newSortedBag(null);\n                Iterator<Tuple> i = bOther.iterator();\n                while (i.hasNext()) otherClone.add(i.next());\n            }\n            Iterator<Tuple> thisIt = thisClone.iterator();\n            Iterator<Tuple> otherIt = otherClone.iterator();\n            while (thisIt.hasNext() && otherIt.hasNext()) {\n                Tuple thisT = thisIt.next();\n                Tuple otherT = otherIt.next();\n                int c = thisT.compareTo(otherT);\n                if (c != 0) return c;\n            }\n            return 0;   // if we got this far, they must be equal\n        } else {\n            return DataType.compare(this, other);\n        }\n    }\n    @Override\n    public boolean equals(Object other) {\n        if( other == null ) {\n            return false;\n        }\n        return compareTo(other) == 0;\n    }\n    /**\n     * Write a bag's contents to disk.\n     * @param out DataOutput to write data to.\n     * @throws IOException (passes it on from underlying calls).\n     */\n    @Override\n    public void write(DataOutput out) throws IOException {\n        sedes.writeDatum(out, this);\n    }\n    /**\n     * Read a bag from disk.\n     * @param in DataInput to read data from.\n     * @throws IOException (passes it on from underlying calls).\n     */\n    @Override\n    public void readFields(DataInput in) throws IOException {\n        long size = in.readLong();\n        for (long i = 0; i < size; i++) {\n            try {\n                Object o = sedes.readDatum(in);\n                add((Tuple)o);\n            } catch (ExecException ee) {\n                throw ee;\n            }\n        }\n    }\n    /**\n     * This is used by FuncEvalSpec.FakeDataBag.\n     * @param stale Set stale state.\n     */\n    @Override\n    public void markStale(boolean stale)\n    {\n    }\n    /**\n     * Write the bag into a string. */\n    @Override\n    public String toString() {\n        return BagFormat.format(this);\n    }\n    @Override\n    public int hashCode() {\n        int hash = 0;\n        Iterator<Tuple> i = iterator();\n        while (i.hasNext()) {\n            hash += i.next().hashCode();\n        }\n        return hash;\n    }\n    /**\n     * Get a file to spill contents to.  The file will be registered in the\n     * mSpillFiles array.\n     * @return stream to write tuples to.\n     */\n    protected DataOutputStream getSpillFile() throws IOException {\n        if (mSpillFiles == null) {\n            // We want to keep the list as small as possible.\n            mSpillFiles = new FileList(1);\n        }\n        String tmpDirName= System.getProperties().getProperty(\"java.io.tmpdir\") ;\n        File tmpDir = new File(tmpDirName);\n        // if the directory does not exist, create it.\n        if (!tmpDir.exists()){\n            log.info(\"Temporary directory doesn't exists. Trying to create: \" + tmpDir.getAbsolutePath());\n          // Create the directory and see if it was successful\n          if (tmpDir.mkdir()){\n            log.info(\"Successfully created temporary directory: \" + tmpDir.getAbsolutePath());\n          } else {\n              // If execution reaches here, it means that we needed to create the directory but\n              // were not successful in doing so.\n              //\n              // If this directory is created recently then we can simply\n              // skip creation. This is to address a rare issue occuring in a cluster despite the\n              // the fact that spill() makes call to getSpillFile() in a synchronized\n              // block.\n              if (tmpDir.exists()) {\n                log.info(\"Temporary directory already exists: \" + tmpDir.getAbsolutePath());\n              } else {\n                int errCode = 2111;\n                String msg = \"Unable to create temporary directory: \" + tmpDir.getAbsolutePath();\n                throw new ExecException(msg, errCode, PigException.BUG);\n              }\n          }\n        }\n        File f = File.createTempFile(\"pigbag\", null);\n        f.deleteOnExit();\n        mSpillFiles.add(f);\n        return new DataOutputStream(new BufferedOutputStream(\n            new FileOutputStream(f)));\n    }\n    /**\n     * Report progress to HDFS.\n     */\n    protected void reportProgress() {\n        if (PhysicalOperator.getReporter() != null) {\n            PhysicalOperator.getReporter().progress();\n        }\n    }\n    @SuppressWarnings(\"rawtypes\")\n    protected void warn(String msg, Enum warningEnum, Throwable e) {\n        pigLogger = PhysicalOperator.getPigLogger();\n        if(pigLogger != null) {\n            pigLogger.warn(this, msg, warningEnum);\n        } else {\n            log.warn(msg, e);\n        }\n    }\n    @SuppressWarnings(\"rawtypes\")\n    protected void incSpillCount(Enum counter) {\n        incSpillCount(counter, 1);\n    }\n<fim_suffix>    @SuppressWarnings(\"rawtypes\")\n    protected void incSpillCount(Enum counter, long numRecsSpilled) {\n        PigStatusReporter reporter = PigStatusReporter.getInstance();\n        if (reporter != null && reporter.getCounter(counter)!=null) {\n            reporter.getCounter(counter).increment(numRecsSpilled);\n        } else {\n            PigHadoopLogger.getInstance().warn(mContents, \"Spill counter incremented\", counter);\n        }\n    }<fim_middle>// function below has no smell\n"}