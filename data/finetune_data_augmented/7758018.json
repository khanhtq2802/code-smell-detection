{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.druid.indexing.overlord;\n\nimport com.google.common.annotations.VisibleForTesting;\nimport org.apache.druid.java.util.common.ISE;\n\nimport java.io.IOException;\nimport java.net.ServerSocket;\nimport java.net.SocketException;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\n<fim_suffix>public class PortFinder\n{\n  private final Set<Integer> usedPorts = new HashSet<>();\n  private final int startPort;\n  private final int endPort;\n  private final List<Integer> candidatePorts;\n\n  public PortFinder(int startPort, int endPort, List<Integer> candidatePorts)\n  {\n    this.startPort = startPort;\n    this.endPort = endPort;\n    this.candidatePorts = candidatePorts;\n  }\n\n  @VisibleForTesting\n  boolean canBind(int portNum)\n  {\n    try {\n      new ServerSocket(portNum).close();\n      return true;\n    }\n    catch (SocketException se) {\n      return false;\n    }\n    catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  public synchronized int findUnusedPort()\n  {\n    if (candidatePorts != null && !candidatePorts.isEmpty()) {\n      int port = chooseFromCandidates();\n      usedPorts.add(port);\n      return port;\n    } else {\n      int port = chooseNext(startPort);\n      while (!canBind(port)) {\n        port = chooseNext(port + 1);\n      }\n      usedPorts.add(port);\n      return port;\n    }\n  }\n\n  public synchronized void markPortUnused(int port)\n  {\n    usedPorts.remove(port);\n  }\n\n  private int chooseFromCandidates()\n  {\n    for (int port : candidatePorts) {\n      if (!usedPorts.contains(port) && canBind(port)) {\n        return port;\n      }\n    }\n    throw new ISE(\"All ports are used...\");\n  }\n\n  private int chooseNext(int start)\n  {\n    // up to endPort (which default value is 65535)\n    for (int i = start; i <= endPort; i++) {\n      if (!usedPorts.contains(i)) {\n        return i;\n      }\n    }\n    throw new ISE(\"All ports are used...\");\n  }\n}\n<fim_middle>// class below has no smell\n"}