{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.hadoop.hive.druid.serde;\n\nimport java.io.IOException;\nimport java.util.Collections;\nimport java.util.Iterator;\n\nimport com.fasterxml.jackson.databind.JavaType;\nimport org.apache.hadoop.hive.druid.DruidStorageHandlerUtils;\nimport org.apache.hadoop.io.NullWritable;\n\nimport com.fasterxml.jackson.core.type.TypeReference;\n\nimport org.apache.druid.query.Result;\nimport org.apache.druid.query.topn.DimensionAndMetricValueExtractor;\nimport org.apache.druid.query.topn.TopNResultValue;\n\n/**\n * Record reader for results for Druid TopNQuery.\n */\npublic class DruidTopNQueryRecordReader extends DruidQueryRecordReader<Result<TopNResultValue>> {\n\n  private static final TypeReference<Result<TopNResultValue>>\n      TYPE_REFERENCE =\n      new TypeReference<Result<TopNResultValue>>() {\n      };\n\n  private Result<TopNResultValue> current;\n\n  private Iterator<DimensionAndMetricValueExtractor> values = Collections.emptyIterator();\n\n  @Override protected JavaType getResultTypeDef() {\n    return DruidStorageHandlerUtils.JSON_MAPPER.getTypeFactory().constructType(TYPE_REFERENCE);\n  }\n\n<fim_suffix>  @Override public boolean nextKeyValue() {\n    if (values.hasNext()) {\n      return true;\n    }\n    if (queryResultsIterator.hasNext()) {\n      current = queryResultsIterator.next();\n      values = current.getValue().getValue().iterator();\n      return nextKeyValue();\n    }\n    return false;\n  }\n\n  @Override public NullWritable getCurrentKey() throws IOException, InterruptedException {\n    return NullWritable.get();\n  }\n\n  @Override public DruidWritable getCurrentValue() throws IOException, InterruptedException {\n    // Create new value\n    DruidWritable value = new DruidWritable(false);\n    value.getValue().put(\"timestamp\", current.getTimestamp().getMillis());\n    if (values.hasNext()) {\n      value.getValue().putAll(values.next().getBaseObject());\n      return value;\n    }\n    return value;\n  }\n\n  @Override public boolean next(NullWritable key, DruidWritable value) {\n    if (nextKeyValue()) {\n      // Update value\n      value.getValue().clear();\n      value.getValue().put(\"timestamp\", current.getTimestamp().getMillis());\n      if (values.hasNext()) {\n        value.getValue().putAll(values.next().getBaseObject());\n      }\n      return true;\n    }\n    return false;\n  }\n\n  @Override public float getProgress() {\n    return queryResultsIterator.hasNext() || values.hasNext() ? 0 : 1;\n  }\n\n}<fim_middle>// function below has no smell\n"}