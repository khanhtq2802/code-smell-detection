{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.metrics2.filter;\n\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport com.google.common.collect.Maps;\nimport org.apache.commons.configuration.SubsetConfiguration;\n\nimport org.apache.hadoop.classification.InterfaceAudience;\nimport org.apache.hadoop.metrics2.MetricsException;\nimport org.apache.hadoop.metrics2.MetricsFilter;\nimport org.apache.hadoop.metrics2.MetricsTag;\n\n/**\n * Base class for pattern based filters\n */\n@InterfaceAudience.Private\npublic abstract class AbstractPatternFilter extends MetricsFilter {\n  protected static final String INCLUDE_KEY = \"include\";\n  protected static final String EXCLUDE_KEY = \"exclude\";\n  protected static final String INCLUDE_TAGS_KEY = \"include.tags\";\n  protected static final String EXCLUDE_TAGS_KEY = \"exclude.tags\";\n\n  private Pattern includePattern;\n  private Pattern excludePattern;\n  private final Map<String, Pattern> includeTagPatterns;\n  private final Map<String, Pattern> excludeTagPatterns;\n  private final Pattern tagPattern = Pattern.compile(\"^(\\\\w+):(.*)\");\n\n  AbstractPatternFilter() {\n    includeTagPatterns = Maps.newHashMap();\n    excludeTagPatterns = Maps.newHashMap();\n  }\n\n  @Override\n  public void init(SubsetConfiguration conf) {\n    String patternString = conf.getString(INCLUDE_KEY);\n    if (patternString != null && !patternString.isEmpty()) {\n      setIncludePattern(compile(patternString));\n    }\n    patternString = conf.getString(EXCLUDE_KEY);\n    if (patternString != null && !patternString.isEmpty()) {\n      setExcludePattern(compile(patternString));\n    }\n    String[] patternStrings = conf.getStringArray(INCLUDE_TAGS_KEY);\n    if (patternStrings != null && patternStrings.length != 0) {\n      for (String pstr : patternStrings) {\n        Matcher matcher = tagPattern.matcher(pstr);\n        if (!matcher.matches()) {\n          throw new MetricsException(\"Illegal tag pattern: \"+ pstr);\n        }\n        setIncludeTagPattern(matcher.group(1), compile(matcher.group(2)));\n      }\n    }\n    patternStrings = conf.getStringArray(EXCLUDE_TAGS_KEY);\n    if (patternStrings != null && patternStrings.length != 0) {\n      for (String pstr : patternStrings) {\n        Matcher matcher = tagPattern.matcher(pstr);\n        if (!matcher.matches()) {\n          throw new MetricsException(\"Illegal tag pattern: \"+ pstr);\n        }\n        setExcludeTagPattern(matcher.group(1), compile(matcher.group(2)));\n      }\n    }\n  }\n\n<fim_suffix>  void setIncludePattern(Pattern includePattern) {\n    this.includePattern = includePattern;\n  }\n\n  void setExcludePattern(Pattern excludePattern) {\n    this.excludePattern = excludePattern;\n  }\n\n  void setIncludeTagPattern(String name, Pattern pattern) {\n    includeTagPatterns.put(name, pattern);\n  }\n\n  void setExcludeTagPattern(String name, Pattern pattern) {\n    excludeTagPatterns.put(name, pattern);\n  }\n\n  @Override\n  public boolean accepts(MetricsTag tag) {\n    // Accept if whitelisted\n    Pattern ipat = includeTagPatterns.get(tag.name());\n    if (ipat != null && ipat.matcher(tag.value()).matches()) {\n      return true;\n    }\n    // Reject if blacklisted\n    Pattern epat = excludeTagPatterns.get(tag.name());\n    if (epat != null && epat.matcher(tag.value()).matches()) {\n      return false;\n    }\n    // Reject if no match in whitelist only mode\n    if (!includeTagPatterns.isEmpty() && excludeTagPatterns.isEmpty()) {\n      return false;\n    }\n    return true;\n  }\n\n  @Override\n  public boolean accepts(Iterable<MetricsTag> tags) {\n    // Accept if any include tag pattern matches\n    for (MetricsTag t : tags) {\n      Pattern pat = includeTagPatterns.get(t.name());\n      if (pat != null && pat.matcher(t.value()).matches()) {\n        return true;\n      }\n    }\n    // Reject if any exclude tag pattern matches\n    for (MetricsTag t : tags) {\n      Pattern pat = excludeTagPatterns.get(t.name());\n      if (pat != null && pat.matcher(t.value()).matches()) {\n        return false;\n      }\n    }\n    // Reject if no match in whitelist only mode\n    if (!includeTagPatterns.isEmpty() && excludeTagPatterns.isEmpty()) {\n      return false;\n    }\n    return true;\n  }\n\n  @Override\n  public boolean accepts(String name) {\n    // Accept if whitelisted\n    if (includePattern != null && includePattern.matcher(name).matches()) {\n      return true;\n    }\n    // Reject if blacklisted\n    if ((excludePattern != null && excludePattern.matcher(name).matches())) {\n      return false;\n    }\n    // Reject if no match in whitelist only mode\n    if (includePattern != null && excludePattern == null) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Compile a string pattern in to a pattern object\n   * @param s the string pattern to compile\n   * @return the compiled pattern object\n   */\n  protected abstract Pattern compile(String s);\n}<fim_middle>// function below has no smell\n"}