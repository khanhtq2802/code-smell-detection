{"text": "<fim_prefix>\n<fim_suffix>public class Annotate {\n    protected static final Context.Key<Annotate> annotateKey = new Context.Key<>();\n    public static Annotate instance(Context context) {\n        Annotate instance = context.get(annotateKey);\n        if (instance == null)\n            instance = new Annotate(context);\n        return instance;\n    }\n    private final Attr attr;\n    private final Check chk;\n    private final ConstFold cfolder;\n    private final DeferredLintHandler deferredLintHandler;\n    private final Enter enter;\n    private final Lint lint;\n    private final Log log;\n    private final Names names;\n    private final Resolve resolve;\n    private final TreeMaker make;\n    private final Symtab syms;\n    private final TypeEnvs typeEnvs;\n    private final Types types;\n    private final Attribute theUnfinishedDefaultValue;\n    private final boolean allowRepeatedAnnos;\n    private final String sourceName;\n    protected Annotate(Context context) {\n        context.put(annotateKey, this);\n        attr = Attr.instance(context);\n        chk = Check.instance(context);\n        cfolder = ConstFold.instance(context);\n        deferredLintHandler = DeferredLintHandler.instance(context);\n        enter = Enter.instance(context);\n        log = Log.instance(context);\n        lint = Lint.instance(context);\n        make = TreeMaker.instance(context);\n        names = Names.instance(context);\n        resolve = Resolve.instance(context);\n        syms = Symtab.instance(context);\n        typeEnvs = TypeEnvs.instance(context);\n        types = Types.instance(context);\n        theUnfinishedDefaultValue =  new Attribute.Error(syms.errType);\n        Source source = Source.instance(context);\n        allowRepeatedAnnos = Feature.REPEATED_ANNOTATIONS.allowedInSource(source);\n        sourceName = source.name;\n        blockCount = 1;\n    }\n    /** Semaphore to delay annotation processing */\n    private int blockCount = 0;\n    /** Called when annotations processing needs to be postponed. */\n    public void blockAnnotations() {\n        blockCount++;\n    }\n    /** Called when annotation processing can be resumed. */\n    public void unblockAnnotations() {\n        blockCount--;\n        if (blockCount == 0)\n            flush();\n    }\n    /** Variant which allows for a delayed flush of annotations.\n     * Needed by ClassReader */\n    public void unblockAnnotationsNoFlush() {\n        blockCount--;\n    }\n    /** are we blocking annotation processing? */\n    public boolean annotationsBlocked() {return blockCount > 0; }\n    public void enterDone() {\n        unblockAnnotations();\n    }\n    public List<TypeCompound> fromAnnotations(List<JCAnnotation> annotations) {\n        if (annotations.isEmpty()) {\n            return List.nil();\n        }\n        ListBuffer<TypeCompound> buf = new ListBuffer<>();\n        for (JCAnnotation anno : annotations) {\n            Assert.checkNonNull(anno.attribute);\n            buf.append((TypeCompound) anno.attribute);\n        }\n        return buf.toList();\n    }\n    /** Annotate (used for everything else) */\n    public void normal(Runnable r) {\n        q.append(r);\n    }\n    /** Validate, triggers after 'normal' */\n    public void validate(Runnable a) {\n        validateQ.append(a);\n    }\n    /** Flush all annotation queues */\n    public void flush() {\n        if (annotationsBlocked()) return;\n        if (isFlushing()) return;\n        startFlushing();\n        try {\n            while (q.nonEmpty()) {\n                q.next().run();\n            }\n            while (typesQ.nonEmpty()) {\n                typesQ.next().run();\n            }\n            while (afterTypesQ.nonEmpty()) {\n                afterTypesQ.next().run();\n            }\n            while (validateQ.nonEmpty()) {\n                validateQ.next().run();\n            }\n        } finally {\n            doneFlushing();\n        }\n    }\n    private ListBuffer<Runnable> q = new ListBuffer<>();\n    private ListBuffer<Runnable> validateQ = new ListBuffer<>();\n    private int flushCount = 0;\n    private boolean isFlushing() { return flushCount > 0; }\n    private void startFlushing() { flushCount++; }\n    private void doneFlushing() { flushCount--; }\n    ListBuffer<Runnable> typesQ = new ListBuffer<>();\n    ListBuffer<Runnable> afterTypesQ = new ListBuffer<>();\n    public void typeAnnotation(Runnable a) {\n        typesQ.append(a);\n    }\n    public void afterTypes(Runnable a) {\n        afterTypesQ.append(a);\n    }\n    /**\n     * Queue annotations for later attribution and entering. This is probably the method you are looking for.\n     *\n     * @param annotations the list of JCAnnotations to attribute and enter\n     * @param localEnv    the enclosing env\n     * @param s           ths Symbol on which to enter the annotations\n     * @param deferPos    report errors here\n     */\n    public void annotateLater(List<JCAnnotation> annotations, Env<AttrContext> localEnv,\n            Symbol s, DiagnosticPosition deferPos)\n    {\n        if (annotations.isEmpty()) {\n            return;\n        }\n        s.resetAnnotations(); // mark Annotations as incomplete for now\n        normal(() -> {\n            // Packages are unusual, in that they are the only type of declaration that can legally appear\n            // more than once in a compilation, and in all cases refer to the same underlying symbol.\n            // This means they are the only kind of declaration that syntactically may have multiple sets\n            // of annotations, each on a different package declaration, even though that is ultimately\n            // forbidden by JLS 8 section 7.4.\n            // The corollary here is that all of the annotations on a package symbol may have already\n            // been handled, meaning that the set of annotations pending completion is now empty.\n            Assert.check(s.kind == PCK || s.annotationsPendingCompletion());\n            JavaFileObject prev = log.useSource(localEnv.toplevel.sourcefile);\n            DiagnosticPosition prevLintPos =\n                    deferPos != null\n                            ? deferredLintHandler.setPos(deferPos)\n                            : deferredLintHandler.immediate();\n            Lint prevLint = deferPos != null ? null : chk.setLint(lint);\n            try {\n                if (s.hasAnnotations() && annotations.nonEmpty())\n                    log.error(annotations.head.pos, Errors.AlreadyAnnotated(Kinds.kindName(s), s));\n                Assert.checkNonNull(s, \"Symbol argument to actualEnterAnnotations is null\");\n                // false is passed as fifth parameter since annotateLater is\n                // never called for a type parameter\n                annotateNow(s, annotations, localEnv, false, false);\n            } finally {\n                if (prevLint != null)\n                    chk.setLint(prevLint);\n                deferredLintHandler.setPos(prevLintPos);\n                log.useSource(prev);\n            }\n        });\n        validate(() -> { //validate annotations\n            JavaFileObject prev = log.useSource(localEnv.toplevel.sourcefile);\n            try {\n                chk.validateAnnotations(annotations, s);\n            } finally {\n                log.useSource(prev);\n            }\n        });\n    }\n    /** Queue processing of an attribute default value. */\n    public void annotateDefaultValueLater(JCExpression defaultValue, Env<AttrContext> localEnv,\n            MethodSymbol m, DiagnosticPosition deferPos)\n    {\n        normal(() -> {\n            JavaFileObject prev = log.useSource(localEnv.toplevel.sourcefile);\n            DiagnosticPosition prevLintPos = deferredLintHandler.setPos(deferPos);\n            try {\n                enterDefaultValue(defaultValue, localEnv, m);\n            } finally {\n                deferredLintHandler.setPos(prevLintPos);\n                log.useSource(prev);\n            }\n        });\n        validate(() -> { //validate annotations\n            JavaFileObject prev = log.useSource(localEnv.toplevel.sourcefile);\n            try {\n                // if default value is an annotation, check it is a well-formed\n                // annotation value (e.g. no duplicate values, no missing values, etc.)\n                chk.validateAnnotationTree(defaultValue);\n            } finally {\n                log.useSource(prev);\n            }\n        });\n    }\n    /** Enter a default value for an annotation element. */\n    private void enterDefaultValue(JCExpression defaultValue,\n            Env<AttrContext> localEnv, MethodSymbol m) {\n        m.defaultValue = attributeAnnotationValue(m.type.getReturnType(), defaultValue, localEnv);\n    }\n    /**\n     * Gather up annotations into a map from type symbols to lists of Compound attributes,\n     * then continue on with repeating annotations processing.\n     */\n    private <T extends Attribute.Compound> void annotateNow(Symbol toAnnotate,\n            List<JCAnnotation> withAnnotations, Env<AttrContext> env, boolean typeAnnotations,\n            boolean isTypeParam)\n    {\n        Map<TypeSymbol, ListBuffer<T>> annotated = new LinkedHashMap<>();\n        Map<T, DiagnosticPosition> pos = new HashMap<>();\n        for (List<JCAnnotation> al = withAnnotations; !al.isEmpty(); al = al.tail) {\n            JCAnnotation a = al.head;\n            T c;<fim_middle>// class below is blob\n"}