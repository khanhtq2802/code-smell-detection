{"text": "<fim_prefix> * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.hadoop.mapred;\nimport java.io.DataInput;\nimport java.io.DataOutput;\nimport java.io.IOException;\nimport java.util.Iterator;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.apache.hadoop.io.Writable;\n/**\n * Keeps the Ranges sorted by startIndex.\n * The added ranges are always ensured to be non-overlapping.\n * Provides the SkipRangeIterator, which skips the Ranges \n * stored in this object.\n */\nclass SortedRanges implements Writable{\n  private static final Log LOG = \n    LogFactory.getLog(SortedRanges.class);\n  private TreeSet<Range> ranges = new TreeSet<Range>();\n  private long indicesCount;\n  /**\n   * Get Iterator which skips the stored ranges.\n   * The Iterator.next() call return the index starting from 0.\n   * @return SkipRangeIterator\n   */\n  synchronized SkipRangeIterator skipRangeIterator(){\n    return new SkipRangeIterator(ranges.iterator());\n  }\n  /**\n   * Get the no of indices stored in the ranges.\n   * @return indices count\n   */\n  synchronized long getIndicesCount() {\n    return indicesCount;\n  }\n  /**\n   * Get the sorted set of ranges.\n   * @return ranges\n   */\n  synchronized SortedSet<Range> getRanges() {\n  \treturn ranges;\n \t}\n  /**\n   * Add the range indices. It is ensured that the added range \n   * doesn't overlap the existing ranges. If it overlaps, the \n   * existing overlapping ranges are removed and a single range \n   * having the superset of all the removed ranges and this range \n   * is added. \n   * If the range is of 0 length, doesn't do anything.\n   * @param range Range to be added.\n   */\n  synchronized void add(Range range){\n    if(range.isEmpty()) {\n      return;\n    }\n    long startIndex = range.getStartIndex();\n    long endIndex = range.getEndIndex();\n    //make sure that there are no overlapping ranges\n    SortedSet<Range> headSet = ranges.headSet(range);\n    if(headSet.size()>0) {\n      Range previousRange = headSet.last();\n      LOG.debug(\"previousRange \"+previousRange);\n      if(startIndex<previousRange.getEndIndex()) {\n        //previousRange overlaps this range\n        //remove the previousRange\n        if(ranges.remove(previousRange)) {\n          indicesCount-=previousRange.getLength();\n        }\n        //expand this range\n        startIndex = previousRange.getStartIndex();\n        endIndex = endIndex>=previousRange.getEndIndex() ?\n                          endIndex : previousRange.getEndIndex();\n      }\n    }\n    Iterator<Range> tailSetIt = ranges.tailSet(range).iterator();\n    while(tailSetIt.hasNext()) {\n      Range nextRange = tailSetIt.next();\n      LOG.debug(\"nextRange \"+nextRange +\"   startIndex:\"+startIndex+\n          \"  endIndex:\"+endIndex);\n      if(endIndex>=nextRange.getStartIndex()) {\n        //nextRange overlaps this range\n        //remove the nextRange\n        tailSetIt.remove();\n        indicesCount-=nextRange.getLength();\n        if(endIndex<nextRange.getEndIndex()) {\n          //expand this range\n          endIndex = nextRange.getEndIndex();\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n    add(startIndex,endIndex);\n  }\n  /**\n   * Remove the range indices. If this range is  \n   * found in existing ranges, the existing ranges \n   * are shrunk.\n   * If range is of 0 length, doesn't do anything.\n   * @param range Range to be removed.\n   */\n  synchronized void remove(Range range) {\n    if(range.isEmpty()) {\n      return;\n    }\n    long startIndex = range.getStartIndex();\n    long endIndex = range.getEndIndex();\n    //make sure that there are no overlapping ranges\n    SortedSet<Range> headSet = ranges.headSet(range);\n    if(headSet.size()>0) {\n      Range previousRange = headSet.last();\n      LOG.debug(\"previousRange \"+previousRange);\n      if(startIndex<previousRange.getEndIndex()) {\n        //previousRange overlaps this range\n        //narrow down the previousRange\n        if(ranges.remove(previousRange)) {\n          indicesCount-=previousRange.getLength();\n          LOG.debug(\"removed previousRange \"+previousRange);\n        }\n        add(previousRange.getStartIndex(), startIndex);\n        if(endIndex<=previousRange.getEndIndex()) {\n          add(endIndex, previousRange.getEndIndex());\n        }\n      }\n    }\n    Iterator<Range> tailSetIt = ranges.tailSet(range).iterator();\n    while(tailSetIt.hasNext()) {\n      Range nextRange = tailSetIt.next();\n      LOG.debug(\"nextRange \"+nextRange +\"   startIndex:\"+startIndex+\n          \"  endIndex:\"+endIndex);\n      if(endIndex>nextRange.getStartIndex()) {\n        //nextRange overlaps this range\n        //narrow down the nextRange\n        tailSetIt.remove();\n        indicesCount-=nextRange.getLength();\n        if(endIndex<nextRange.getEndIndex()) {\n          add(endIndex, nextRange.getEndIndex());\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n  }\n  private void add(long start, long end) {\n    if(end>start) {\n      Range recRange = new Range(start, end-start);\n      ranges.add(recRange);\n      indicesCount+=recRange.getLength();\n      LOG.debug(\"added \"+recRange);\n    }\n  }\n  public synchronized void readFields(DataInput in) throws IOException {\n    indicesCount = in.readLong();\n    ranges = new TreeSet<Range>();\n    int size = in.readInt();\n    for(int i=0;i<size;i++) {\n      Range range = new Range();\n      range.readFields(in);\n      ranges.add(range);\n    }\n  }\n  public synchronized void write(DataOutput out) throws IOException {\n    out.writeLong(indicesCount);\n    out.writeInt(ranges.size());\n    Iterator<Range> it = ranges.iterator();\n    while(it.hasNext()) {\n      Range range = it.next();\n      range.write(out);\n    }\n  }\n  public String toString() {\n    StringBuffer sb = new StringBuffer();\n    Iterator<Range> it = ranges.iterator();\n    while(it.hasNext()) {\n      Range range = it.next();\n      sb.append(range.toString()+\"\\n\");\n    }\n    return sb.toString();\n  }\n  /**\n   * Index Range. Comprises of start index and length.\n   * A Range can be of 0 length also. The Range stores indices \n   * of type long.\n   */\n  static class Range implements Comparable<Range>, Writable{\n    private long startIndex;\n    private long length;\n    Range(long startIndex, long length) {\n      if(length<0) {\n        throw new RuntimeException(\"length can't be negative\");\n      }\n      this.startIndex = startIndex;\n      this.length = length;\n    }\n    Range() {\n      this(0,0);\n    }\n    /**\n     * Get the start index. Start index in inclusive.\n     * @return startIndex. \n     */\n    long getStartIndex() {\n      return startIndex;\n    }\n    /**\n     * Get the end index. End index is exclusive.\n     * @return endIndex.\n     */\n    long getEndIndex() {\n      return startIndex + length;\n    }\n   /**\n    * Get Length.\n    * @return length\n    */\n    long getLength() {\n      return length;\n    }\n    /**\n     * Range is empty if its length is zero.\n     * @return <code>true</code> if empty\n     *         <code>false</code> otherwise.\n     */\n    boolean isEmpty() {\n      return length==0;\n    }\n    public boolean equals(Object o) {\n      if (o instanceof Range) {\n        Range range = (Range)o;\n        return startIndex==range.startIndex &&\n        length==range.length;\n      }\n      return false;\n    }\n    public int hashCode() {\n      return Long.valueOf(startIndex).hashCode() +\n          Long.valueOf(length).hashCode();\n    }\n<fim_suffix>    public int compareTo(Range o) {\n      // Ensure sgn(x.compareTo(y) == -sgn(y.compareTo(x))\n      return this.startIndex < o.startIndex ? -1 :\n          (this.startIndex > o.startIndex ? 1 :\n          (this.length < o.length ? -1 :\n          (this.length > o.length ? 1 : 0)));\n    }<fim_middle>// function below has no smell\n"}