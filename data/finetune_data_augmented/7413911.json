{"text": "<fim_prefix>            final long targetOffset = managedPointer.getOffset();\n            if (targetOffset != 0L) {\n                targetString = String.format(\"%s + %d byte%s\", targetString, targetOffset, targetOffset == 1L ? \"\" : \"s\");\n            }\n            currentValue = targetString;\n        }\n        return Objects.toString(currentValue);\n    }\n    @Override\n    protected int getElementCountForDebugger() {\n        final String[] keys = getKeys();\n        return keys == null ? 0 : keys.length;\n    }\n    @Override\n    protected String[] getKeysForDebugger() {\n        final String[] keys = getKeys();\n        return keys != null ? keys : NO_KEYS;\n    }\n    @Override\n    protected Object getElementForDebugger(String key) {\n        return getMember(key);\n    }\n    private static final class Enum extends LLVMDebugObject {\n        Enum(LLVMDebugValue value, long offset, LLVMSourceType type, LLVMSourceLocation declaration) {\n            super(value, offset, type, declaration);\n        }\n        @Override\n        protected Object getValueSafe() {\n            final int size = (int) getType().getSize();\n            final Object idRead = value.readBigInteger(offset, size, false);\n            final BigInteger id;\n            if (idRead instanceof BigInteger) {\n                id = (BigInteger) idRead;\n            } else {\n                return value.describeValue(offset, size);\n            }\n            if (size >= Long.SIZE) {\n                return LLVMDebugValue.toHexString(id);\n            }\n            final Object enumVal = getType().getElementName(id.longValue());\n            return enumVal != null ? enumVal : LLVMDebugValue.toHexString(id);\n        }\n        @Override\n        public String[] getKeysSafe() {\n            return NO_KEYS;\n        }\n        @Override\n        public Object getMemberSafe(String identifier) {\n            return null;\n        }\n    }\n    private static final class Structured extends LLVMDebugObject {\n        private static final int STRING_MAX_LENGTH = 64;\n        // in the order of their actual declaration in the containing type\n        private final String[] memberIdentifiers;\n        Structured(LLVMDebugValue value, long offset, LLVMSourceType type, String[] memberIdentifiers, LLVMSourceLocation declaration) {\n            super(value, offset, type, declaration);\n            this.memberIdentifiers = memberIdentifiers;\n        }\n        @Override\n        public String[] getKeysSafe() {\n            return memberIdentifiers;\n        }\n        @Override\n        public Object getMemberSafe(String key) {\n            final LLVMSourceType elementType = getType().getElementType(key);\n            final long newOffset = this.offset + elementType.getOffset();\n            final LLVMSourceLocation declaration = getType().getElementDeclaration(key);\n            return instantiate(elementType, newOffset, value, declaration);\n        }\n        @Override\n        protected Object getValueSafe() {\n            Object o = value.computeAddress(offset);\n            final LLVMSourceType actualType = getType().getActualType();\n            if (actualType instanceof LLVMSourceArrayLikeType) {\n                final LLVMSourceType baseType = ((LLVMSourceArrayLikeType) actualType).getBaseType().getActualType();\n                if (baseType instanceof LLVMSourceBasicType) {\n                    switch (((LLVMSourceBasicType) baseType).getKind()) {\n                        case UNSIGNED_CHAR:\n                            o = appendString(o, false);\n                            break;\n                        case SIGNED_CHAR:\n                            o = appendString(o, true);\n                            break;\n                    }\n                }\n            }\n            return o;\n        }\n        private Object appendString(Object o, boolean signed) {\n            if (getType().getElementCount() <= 0) {\n                return o;\n            }\n            final StringBuilder sb = new StringBuilder();\n            sb.append(o).append(\" \\\"\");\n            final int numChars = Math.min(getType().getElementCount(), STRING_MAX_LENGTH);\n            for (int i = 0; i < numChars; i++) {\n                final LLVMSourceType elementType = getType().getElementType(i);\n                final long newOffset = offset + elementType.getOffset();\n                int size = (int) elementType.getSize();\n                if (!value.canRead(newOffset, size)) {\n                    sb.append(\"??\");\n                    continue;\n                }\n                final Object intRead = value.readBigInteger(newOffset, size, signed);\n                if (intRead instanceof BigInteger) {\n                    byte byteVal = ((BigInteger) intRead).byteValue();\n                    char ch = signed ? (char) byteVal : (char) Byte.toUnsignedInt(byteVal);\n                    if (ch == 0) {\n                        break;\n                    }\n                    sb.append(ch);\n                } else {\n                    sb.append(\"??\");\n                }\n            }\n            if (numChars < getType().getElementCount()) {\n                sb.append(\"... (+ \").append(getType().getElementCount() - numChars).append(\" characters)\");\n            }\n            sb.append(\"\\\"\");\n            return sb.toString();\n        }\n    }\n    private static final class Primitive extends LLVMDebugObject {\n        Primitive(LLVMDebugValue value, long offset, LLVMSourceType type, LLVMSourceLocation declaration) {\n            super(value, offset, type, declaration);\n        }\n        @Override\n        public String[] getKeysSafe() {\n            return NO_KEYS;\n        }\n        @Override\n        public Object getMemberSafe(String identifier) {\n            return null;\n        }\n        @Override\n        public Object getValueSafe() {\n            final int size = (int) getType().getSize();\n            LLVMSourceType actualType = getType().getActualType();\n            if (actualType instanceof LLVMSourceBasicType) {\n                switch (((LLVMSourceBasicType) actualType).getKind()) {\n                    case ADDRESS:\n                        return value.readAddress(offset);\n                    case BOOLEAN:\n                        return value.readBoolean(offset);\n                    case FLOATING:\n                        return readFloating();\n                    case SIGNED:\n                        return value.readBigInteger(offset, size, true);\n                    case SIGNED_CHAR: {\n                        final Object intRead = value.readBigInteger(offset, size, true);\n                        if (intRead instanceof BigInteger) {\n                            return (char) ((BigInteger) intRead).byteValue();\n                        } else {\n                            return intRead;\n                        }\n                    }\n                    case UNSIGNED:\n                        return value.readBigInteger(offset, size, false);\n                    case UNSIGNED_CHAR: {\n                        final Object intRead = value.readBigInteger(offset, size, false);\n                        if (intRead instanceof BigInteger) {\n                            return (char) Byte.toUnsignedInt(((BigInteger) intRead).byteValue());\n                        } else {\n                            return intRead;\n                        }\n                    }\n                }\n            }\n            return value.readUnknown(offset, size);\n        }\n        // clang uses the x86_fp80 datatype to represent the long double type which is indicated in\n        // metadata to have 128 bits\n        private static final int LONGDOUBLE_SIZE = 128;\n        private Object readFloating() {\n            final int size = (int) getType().getSize();\n            try {\n                switch (size) {\n                    case Float.SIZE:\n                        return value.readFloat(offset);\n                    case Double.SIZE:\n                        return value.readDouble(offset);\n                    case LLVM80BitFloat.BIT_WIDTH:\n                    case LONGDOUBLE_SIZE:\n                        return value.read80BitFloat(offset);\n                    default:\n                        return value.readUnknown(offset, size);\n                }\n            } catch (IllegalStateException e) {\n                CompilerDirectives.transferToInterpreter();\n                return e.getMessage();\n            }\n        }\n    }\n    private static final class Pointer extends LLVMDebugObject {\n        private final LLVMSourcePointerType pointerType;\n        Pointer(LLVMDebugValue value, long offset, LLVMSourceType type, LLVMSourceLocation declaration) {\n            super(value, offset, type, declaration);\n            LLVMSourceType actualType = getType().getActualType();\n            if (actualType instanceof LLVMSourcePointerType) {\n                this.pointerType = (LLVMSourcePointerType) actualType;\n            } else {\n                this.pointerType = null;\n            }\n        }\n        @Override\n        public String[] getKeysSafe() {\n            final LLVMDebugObject target = dereference();\n            return target == null ? NO_KEYS : target.getKeys();\n        }\n        @Override\n        public Object getMemberSafe(String identifier) {\n            final LLVMDebugObject target = dereference();\n            return target == null ? \"Cannot dereference pointer!\" : target.getMember(identifier);\n        }\n        @Override\n        protected Object getValueSafe() {\n            if (pointerType == null || !pointerType.isReference()) {\n                return value.readAddress(offset);\n            } else {\n                final LLVMDebugObject target = dereference();\n                return target == null ? value.readAddress(offset) : target.getValue();\n            }\n        }\n<fim_suffix>        private LLVMDebugObject dereference() {\n            // the pointer may change at runtime, so we cannot just cache the dereferenced object\n            if (pointerType == null || (!pointerType.isSafeToDereference() && !value.isAlwaysSafeToDereference(offset))) {\n                return null;\n            }\n            final LLVMDebugValue targetValue = value.dereferencePointer(offset);\n            if (targetValue == null) {\n                return null;\n            }\n            return instantiate(pointerType.getBaseType(), 0L, targetValue, null);\n        }<fim_middle>// function below has no smell\n"}