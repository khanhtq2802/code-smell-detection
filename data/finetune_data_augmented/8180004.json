{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.activemq.store.memory;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\nimport org.apache.activemq.broker.ConnectionContext;\nimport org.apache.activemq.broker.scheduler.JobSchedulerStore;\nimport org.apache.activemq.command.ActiveMQDestination;\nimport org.apache.activemq.command.ActiveMQQueue;\nimport org.apache.activemq.command.ActiveMQTopic;\nimport org.apache.activemq.command.ProducerId;\nimport org.apache.activemq.store.MessageStore;\nimport org.apache.activemq.store.NoLocalSubscriptionAware;\nimport org.apache.activemq.store.PersistenceAdapter;\nimport org.apache.activemq.store.ProxyMessageStore;\nimport org.apache.activemq.store.TopicMessageStore;\nimport org.apache.activemq.store.TransactionStore;\nimport org.apache.activemq.usage.SystemUsage;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * @org.apache.xbean.XBean\n */\npublic class MemoryPersistenceAdapter implements PersistenceAdapter, NoLocalSubscriptionAware {\n    private static final Logger LOG = LoggerFactory.getLogger(MemoryPersistenceAdapter.class);\n\n    MemoryTransactionStore transactionStore;\n    ConcurrentMap<ActiveMQDestination, TopicMessageStore> topics = new ConcurrentHashMap<ActiveMQDestination, TopicMessageStore>();\n    ConcurrentMap<ActiveMQDestination, MessageStore> queues = new ConcurrentHashMap<ActiveMQDestination, MessageStore>();\n    private boolean useExternalMessageReferences;\n\n    @Override\n    public Set<ActiveMQDestination> getDestinations() {\n        Set<ActiveMQDestination> rc = new HashSet<ActiveMQDestination>(queues.size() + topics.size());\n        for (Iterator<ActiveMQDestination> iter = queues.keySet().iterator(); iter.hasNext();) {\n            rc.add(iter.next());\n        }\n        for (Iterator<ActiveMQDestination> iter = topics.keySet().iterator(); iter.hasNext();) {\n            rc.add(iter.next());\n        }\n        return rc;\n    }\n\n    public static MemoryPersistenceAdapter newInstance(File file) {\n        return new MemoryPersistenceAdapter();\n    }\n\n    @Override\n    public MessageStore createQueueMessageStore(ActiveMQQueue destination) throws IOException {\n        MessageStore rc = queues.get(destination);\n        if (rc == null) {\n            rc = new MemoryMessageStore(destination);\n            if (transactionStore != null) {\n                rc = transactionStore.proxy(rc);\n            }\n            queues.put(destination, rc);\n        }\n        return rc;\n    }\n\n    @Override\n    public TopicMessageStore createTopicMessageStore(ActiveMQTopic destination) throws IOException {\n        TopicMessageStore rc = topics.get(destination);\n        if (rc == null) {\n            rc = new MemoryTopicMessageStore(destination);\n            if (transactionStore != null) {\n                rc = transactionStore.proxy(rc);\n            }\n            topics.put(destination, rc);\n        }\n        return rc;\n    }\n\n    /**\n     * Cleanup method to remove any state associated with the given destination\n     *\n     * @param destination\n     *        Destination to forget\n     */\n    @Override\n    public void removeQueueMessageStore(ActiveMQQueue destination) {\n        queues.remove(destination);\n    }\n\n    /**\n     * Cleanup method to remove any state associated with the given destination\n     *\n     * @param destination\n     *        Destination to forget\n     */\n    @Override\n    public void removeTopicMessageStore(ActiveMQTopic destination) {\n        topics.remove(destination);\n    }\n\n    @Override\n    public TransactionStore createTransactionStore() throws IOException {\n        if (transactionStore == null) {\n            transactionStore = new MemoryTransactionStore(this);\n        }\n        return transactionStore;\n    }\n\n    @Override\n    public void beginTransaction(ConnectionContext context) {\n    }\n\n    @Override\n    public void commitTransaction(ConnectionContext context) {\n    }\n\n    @Override\n    public void rollbackTransaction(ConnectionContext context) {\n    }\n\n    @Override\n    public void start() throws Exception {\n    }\n\n    @Override\n    public void stop() throws Exception {\n    }\n\n    @Override\n    public long getLastMessageBrokerSequenceId() throws IOException {\n        return 0;\n    }\n\n    @Override\n    public void deleteAllMessages() throws IOException {\n        for (Iterator<TopicMessageStore> iter = topics.values().iterator(); iter.hasNext();) {\n            MemoryMessageStore store = asMemoryMessageStore(iter.next());\n            if (store != null) {\n                store.delete();\n            }\n        }\n        for (Iterator<MessageStore> iter = queues.values().iterator(); iter.hasNext();) {\n            MemoryMessageStore store = asMemoryMessageStore(iter.next());\n            if (store != null) {\n                store.delete();\n            }\n        }\n\n        if (transactionStore != null) {\n            transactionStore.delete();\n        }\n    }\n\n    public boolean isUseExternalMessageReferences() {\n        return useExternalMessageReferences;\n    }\n\n    public void setUseExternalMessageReferences(boolean useExternalMessageReferences) {\n        this.useExternalMessageReferences = useExternalMessageReferences;\n    }\n\n    protected MemoryMessageStore asMemoryMessageStore(Object value) {\n        if (value instanceof MemoryMessageStore) {\n            return (MemoryMessageStore) value;\n        }\n        if (value instanceof ProxyMessageStore) {\n            MessageStore delegate = ((ProxyMessageStore) value).getDelegate();\n            if (delegate instanceof MemoryMessageStore) {\n                return (MemoryMessageStore) delegate;\n            }\n        }\n        LOG.warn(\"Expected an instance of MemoryMessageStore but was: \" + value);\n        return null;\n    }\n\n    /**\n     * @param usageManager\n     *        The UsageManager that is controlling the broker's memory usage.\n     */\n    @Override\n    public void setUsageManager(SystemUsage usageManager) {\n    }\n\n    @Override\n    public String toString() {\n        return \"MemoryPersistenceAdapter\";\n    }\n\n    @Override\n    public void setBrokerName(String brokerName) {\n    }\n\n    @Override\n    public void setDirectory(File dir) {\n    }\n\n    @Override\n    public File getDirectory() {\n        return null;\n    }\n\n    @Override\n    public void checkpoint(boolean sync) throws IOException {\n    }\n\n<fim_suffix>    @Override\n    public long size() {\n        return 0;\n    }\n\n    public void setCreateTransactionStore(boolean create) throws IOException {\n        if (create) {\n            createTransactionStore();\n        }\n    }\n\n    @Override\n    public long getLastProducerSequenceId(ProducerId id) {\n        // memory map does duplicate suppression\n        return -1;\n    }\n\n    @Override\n    public void allowIOResumption() {}\n\n    @Override\n    public JobSchedulerStore createJobSchedulerStore() throws IOException, UnsupportedOperationException {\n        // We could eventuall implement an in memory scheduler.\n        throw new UnsupportedOperationException();\n    }\n\n    /* (non-Javadoc)\n     * @see org.apache.activemq.store.NoLocalSubscriptionAware#isPersistNoLocal()\n     */\n    @Override\n    public boolean isPersistNoLocal() {\n        return true;\n    }\n}<fim_middle>// function below has no smell\n"}