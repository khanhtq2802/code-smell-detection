{"text": "<fim_prefix>  {\n    BoundStatement boundStatement = ps.bind();\n    Object pojoPayload = tuple.getPayload();\n    for (String cassandraColName : getters.keySet()) {\n      DataType dataType = columnDefinitions.get(cassandraColName);\n      CassandraPojoUtils.populateBoundStatementWithValue(boundStatement,getters,dataType,cassandraColName,\n          pojoPayload,setNulls,codecsForCassandraColumnNames);\n    }\n    return boundStatement;\n  }\n  /**\n   * Builds th map that manages the getters for a given cassandra column\n   * Aspects like case-insensitiveness , over-riding of column names to custom mappings\n   */\n  private void registerGettersForPayload()\n  {\n    Field[] classFields = tuplePayloadClass.getDeclaredFields();\n    Set<String> allColNames = new HashSet<>();\n    Map<String, DataType> dataTypeMap = new HashMap<>();\n    Map<String,String> overridingColnamesMap = getPojoFieldNameToCassandraColumnNameOverride();\n    if ( overridingColnamesMap == null) {\n      overridingColnamesMap = new HashMap<>();\n    }\n    allColNames.addAll(pkColumnNames);\n    allColNames.addAll(regularColumns);\n    Set<String> normalizedColNames = new HashSet<>();\n    Iterator<String> simpleColIterator = allColNames.iterator();\n    while (simpleColIterator.hasNext()) {\n      String aCol = simpleColIterator.next();\n      normalizedColNames.add(aCol.toLowerCase());\n      dataTypeMap.put(aCol.toLowerCase(), columnDefinitions.get(aCol));\n      colNamesMap.put(aCol.toLowerCase(), aCol);\n      codecsForCassandraColumnNames.put(aCol, complexTypeCodecs.get(aCol.toLowerCase()));\n    }\n    for (Field aField : classFields) {\n      String aFieldName = aField.getName();\n      if ( (normalizedColNames.contains(aFieldName.toLowerCase())) ||\n          (overridingColnamesMap.containsKey(aFieldName)) ) {\n        String getterExpr = aFieldName;\n        DataType returnDataTypeOfGetter = dataTypeMap.get(aFieldName.toLowerCase());\n        if (returnDataTypeOfGetter == null) {\n          returnDataTypeOfGetter = dataTypeMap.get(overridingColnamesMap.get(aFieldName));\n        }\n        Object getter = CassandraPojoUtils.resolveGetterForField(tuplePayloadClass,getterExpr,\n            returnDataTypeOfGetter,userDefinedTypesClass);\n        String resolvedColumnName = colNamesMap.get(aFieldName.toLowerCase());\n        if (overridingColnamesMap.containsKey(aFieldName)) {\n          resolvedColumnName = overridingColnamesMap.get(aFieldName);\n        }\n        getters.put(resolvedColumnName, getter);\n      }\n    }\n  }\n  private void registerCodecs()\n  {\n    complexTypeCodecs = getCodecsForUserDefinedTypes();\n    if (complexTypeCodecs != null) {\n      CodecRegistry registry = cluster.getConfiguration().getCodecRegistry();\n      if (cluster.getConfiguration().getProtocolOptions().getProtocolVersion().toInt() < 4) {\n        LOG.error(\"Custom codecs are not supported for protocol version < 4\");\n        throw new RuntimeException(\"Custom codecs are not supported for protocol version < 4\");\n      }\n      for (String typeCodecStr : complexTypeCodecs.keySet()) {\n        TypeCodec codec = complexTypeCodecs.get(typeCodecStr);\n        registry.register(codec);\n        userDefinedTypesClass.put(typeCodecStr, codec.getJavaType().getRawType());\n      }\n    } else {\n      complexTypeCodecs = new HashMap<>();\n    }\n  }\n  private void registerNonPKColumnDefinitions(final TableMetadata tableMetadata)\n  {\n    List<ColumnMetadata> colInfoForTable = tableMetadata.getColumns();\n    for (ColumnMetadata aColumnDefinition : colInfoForTable) {\n      if (aColumnDefinition.getType().isCollection()) {\n        collectionColumns.add(aColumnDefinition.getName());\n      }\n      if (!pkColumnNames.contains(aColumnDefinition.getName())) {\n        columnDefinitions.put(aColumnDefinition.getName(), aColumnDefinition.getType());\n        regularColumns.add(aColumnDefinition.getName());\n      }\n      parseForSpecialDataType(aColumnDefinition);\n    }\n  }\n  private void parseForSpecialDataType(final ColumnMetadata aColumnDefinition)\n  {\n    switch (aColumnDefinition.getType().getName()) {\n      case COUNTER:\n        counterColumns.add(aColumnDefinition.getName());\n        break;\n      case MAP:\n        mapColumns.add(aColumnDefinition.getName());\n        break;\n      case SET:\n        setColumns.add(aColumnDefinition.getName());\n        break;\n      case LIST:\n        listColumns.add(aColumnDefinition.getName());\n        break;\n      case UDT:\n        userDefinedTypeColumns.add(aColumnDefinition.getName());\n        break;\n      default:\n        break;\n    }\n  }\n  private void registerPrimaryKeyColumnDefinitions(final TableMetadata tableMetadata)\n  {\n    List<ColumnMetadata> primaryKeyColumns = tableMetadata.getPrimaryKey();\n    for (ColumnMetadata primaryColumn : primaryKeyColumns) {\n      columnDefinitions.put(primaryColumn.getName(), primaryColumn.getType());\n      pkColumnNames.add(primaryColumn.getName());\n      parseForSpecialDataType(primaryColumn);\n    }\n  }\n  private void generatePreparedStatements()\n  {\n    cassandraPreparedStatementGenerationUtil = new CassandraPreparedStatementGenerator(\n        pkColumnNames, counterColumns, listColumns,\n        mapColumns, setColumns, columnDefinitions);\n    cassandraPreparedStatementGenerationUtil.generatePreparedStatements(session, preparedStatementTypes,\n        connectionStateManager.getKeyspaceName(), connectionStateManager.getTableName());\n  }\n  public Map<String, DataType> getColumnDefinitions()\n  {\n    return columnDefinitions;\n  }\n  public void setColumnDefinitions(final Map<String, DataType> columnDefinitions)\n  {\n    this.columnDefinitions = columnDefinitions;\n  }\n  public Map<String, Class> getUserDefinedTypesClass()\n  {\n    return userDefinedTypesClass;\n  }\n  public void setUserDefinedTypesClass(final Map<String, Class> userDefinedTypesClass)\n  {\n    this.userDefinedTypesClass = userDefinedTypesClass;\n  }\n  public Set<String> getPkColumnNames()\n  {\n    return pkColumnNames;\n  }\n  public void setPkColumnNames(final Set<String> pkColumnNames)\n  {\n    this.pkColumnNames = pkColumnNames;\n  }\n  public Set<String> getCounterColumns()\n  {\n    return counterColumns;\n  }\n  public void setCounterColumns(final Set<String> counterColumns)\n  {\n    this.counterColumns = counterColumns;\n  }\n  public Set<String> getCollectionColumns()\n  {\n    return collectionColumns;\n  }\n  public void setCollectionColumns(final Set<String> collectionColumns)\n  {\n    this.collectionColumns = collectionColumns;\n  }\n  public Set<String> getListColumns()\n  {\n    return listColumns;\n  }\n  public void setListColumns(final Set<String> listColumns)\n  {\n    this.listColumns = listColumns;\n  }\n  public Set<String> getMapColumns()\n  {\n    return mapColumns;\n  }\n  public void setMapColumns(Set<String> mapColumns)\n  {\n    this.mapColumns = mapColumns;\n  }\n  public Set<String> getSetColumns()\n  {\n    return setColumns;\n  }\n  public void setSetColumns(Set<String> setColumns)\n  {\n    this.setColumns = setColumns;\n  }\n  public Set<String> getUserDefinedTypeColumns()\n  {\n    return userDefinedTypeColumns;\n  }\n  public void setUserDefinedTypeColumns(Set<String> userDefinedTypeColumns)\n  {\n    this.userDefinedTypeColumns = userDefinedTypeColumns;\n  }\n  public Set<String> getRegularColumns()\n  {\n    return regularColumns;\n  }\n  public void setRegularColumns(Set<String> regularColumns)\n  {\n    this.regularColumns = regularColumns;\n  }\n  public Map<Long, PreparedStatement> getPreparedStatementTypes()\n  {\n    return preparedStatementTypes;\n  }\n  public void setPreparedStatementTypes(Map<Long, PreparedStatement> preparedStatementTypes)\n  {\n    this.preparedStatementTypes = preparedStatementTypes;\n  }\n  public Map<String, Object> getGetters()\n  {\n    return getters;\n  }\n  public void setGetters(Map<String, Object> getters)\n  {\n    this.getters = getters;\n  }\n  public ConnectionStateManager getConnectionStateManager()\n  {\n    return connectionStateManager;\n  }\n  public void setConnectionStateManager(ConnectionStateManager connectionStateManager)\n  {\n    this.connectionStateManager = connectionStateManager;\n  }\n  public WindowDataManager getWindowDataManager()\n  {\n    return windowDataManager;\n  }\n<fim_suffix>  public void setWindowDataManager(WindowDataManager windowDataManager)\n  {\n    this.windowDataManager = windowDataManager;\n  }<fim_middle>// function below has no smell\n"}