{"text": "<fim_prefix>/*\n * Copyright 2012-2019 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.actuate.health;\n\nimport java.time.Duration;\nimport java.util.function.Function;\n\nimport reactor.core.publisher.Flux;\nimport reactor.core.publisher.Mono;\nimport reactor.util.function.Tuple2;\n\n/**\n * {@link ReactiveHealthIndicator} that returns health indications from all registered\n * delegates. Provides an alternative {@link Health} for a delegate that reaches a\n * configurable timeout.\n *\n * @author Stephane Nicoll\n * @since 2.0.0\n */\n<fim_suffix>public class CompositeReactiveHealthIndicator implements ReactiveHealthIndicator {\n\n\tprivate final ReactiveHealthIndicatorRegistry registry;\n\n\tprivate final HealthAggregator healthAggregator;\n\n\tprivate Long timeout;\n\n\tprivate Health timeoutHealth;\n\n\tprivate final Function<Mono<Health>, Mono<Health>> timeoutCompose;\n\n\t/**\n\t * Create a new {@link CompositeReactiveHealthIndicator} from the indicators in the\n\t * given {@code registry}.\n\t * @param healthAggregator the health aggregator\n\t * @param registry the registry of {@link ReactiveHealthIndicator HealthIndicators}.\n\t */\n\tpublic CompositeReactiveHealthIndicator(HealthAggregator healthAggregator,\n\t\t\tReactiveHealthIndicatorRegistry registry) {\n\t\tthis.registry = registry;\n\t\tthis.healthAggregator = healthAggregator;\n\t\tthis.timeoutCompose = (mono) -> (this.timeout != null) ? mono.timeout(\n\t\t\t\tDuration.ofMillis(this.timeout), Mono.just(this.timeoutHealth)) : mono;\n\t}\n\n\t/**\n\t * Specify an alternative timeout {@link Health} if a {@link HealthIndicator} failed\n\t * to reply after specified {@code timeout}.\n\t * @param timeout number of milliseconds to wait before using the\n\t * {@code timeoutHealth}\n\t * @param timeoutHealth the {@link Health} to use if an health indicator reached the\n\t * {@code timeout}\n\t * @return this instance\n\t */\n\tpublic CompositeReactiveHealthIndicator timeoutStrategy(long timeout,\n\t\t\tHealth timeoutHealth) {\n\t\tthis.timeout = timeout;\n\t\tthis.timeoutHealth = (timeoutHealth != null) ? timeoutHealth\n\t\t\t\t: Health.unknown().build();\n\t\treturn this;\n\t}\n\n\tReactiveHealthIndicatorRegistry getRegistry() {\n\t\treturn this.registry;\n\t}\n\n\t@Override\n\tpublic Mono<Health> health() {\n\t\treturn Flux.fromIterable(this.registry.getAll().entrySet())\n\t\t\t\t.flatMap((entry) -> Mono.zip(Mono.just(entry.getKey()),\n\t\t\t\t\t\tentry.getValue().health().compose(this.timeoutCompose)))\n\t\t\t\t.collectMap(Tuple2::getT1, Tuple2::getT2)\n\t\t\t\t.map(this.healthAggregator::aggregate);\n\t}\n\n}<fim_middle>// class below has no smell\n"}