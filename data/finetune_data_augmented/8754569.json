{"text": "<fim_prefix>* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*     http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\npackage org.apache.hadoop.yarn.server.resourcemanager.recovery;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport javax.crypto.SecretKey;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.apache.hadoop.classification.InterfaceAudience.Private;\nimport org.apache.hadoop.classification.InterfaceStability.Unstable;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.io.Text;\nimport org.apache.hadoop.security.Credentials;\nimport org.apache.hadoop.security.token.delegation.DelegationKey;\nimport org.apache.hadoop.service.AbstractService;\nimport org.apache.hadoop.yarn.api.records.ApplicationAttemptId;\nimport org.apache.hadoop.yarn.api.records.ApplicationId;\nimport org.apache.hadoop.yarn.api.records.ApplicationSubmissionContext;\nimport org.apache.hadoop.yarn.api.records.Container;\nimport org.apache.hadoop.yarn.api.records.ContainerExitStatus;\nimport org.apache.hadoop.yarn.api.records.FinalApplicationStatus;\nimport org.apache.hadoop.yarn.api.records.impl.pb.ApplicationSubmissionContextPBImpl;\nimport org.apache.hadoop.yarn.event.AsyncDispatcher;\nimport org.apache.hadoop.yarn.event.Dispatcher;\nimport org.apache.hadoop.yarn.event.EventHandler;\nimport org.apache.hadoop.yarn.security.client.RMDelegationTokenIdentifier;\nimport org.apache.hadoop.yarn.server.records.Version;\nimport org.apache.hadoop.yarn.server.resourcemanager.RMFatalEvent;\nimport org.apache.hadoop.yarn.server.resourcemanager.RMFatalEventType;\nimport org.apache.hadoop.yarn.server.resourcemanager.recovery.records.AMRMTokenSecretManagerState;\nimport org.apache.hadoop.yarn.server.resourcemanager.recovery.records.ApplicationAttemptStateData;\nimport org.apache.hadoop.yarn.server.resourcemanager.recovery.records.ApplicationStateData;\nimport org.apache.hadoop.yarn.server.resourcemanager.rmapp.RMApp;\nimport org.apache.hadoop.yarn.server.resourcemanager.rmapp.RMAppEvent;\nimport org.apache.hadoop.yarn.server.resourcemanager.rmapp.RMAppEventType;\nimport org.apache.hadoop.yarn.server.resourcemanager.rmapp.RMAppState;\nimport org.apache.hadoop.yarn.server.resourcemanager.rmapp.attempt.RMAppAttempt;\nimport org.apache.hadoop.yarn.server.resourcemanager.rmapp.attempt.RMAppAttemptEvent;\nimport org.apache.hadoop.yarn.server.resourcemanager.rmapp.attempt.RMAppAttemptEventType;\nimport org.apache.hadoop.yarn.server.resourcemanager.rmapp.attempt.RMAppAttemptState;\nimport org.apache.hadoop.yarn.state.InvalidStateTransitonException;\nimport org.apache.hadoop.yarn.state.SingleArcTransition;\nimport org.apache.hadoop.yarn.state.StateMachine;\nimport org.apache.hadoop.yarn.state.StateMachineFactory;\n@Private\n@Unstable\n/**\n * Base class to implement storage of ResourceManager state.\n * Takes care of asynchronous notifications and interfacing with YARN objects.\n * Real store implementations need to derive from it and implement blocking\n * store and load methods to actually store and load the state.\n */\npublic abstract class RMStateStore extends AbstractService {\n  // constants for RM App state and RMDTSecretManagerState.\n  protected static final String RM_APP_ROOT = \"RMAppRoot\";\n  protected static final String RM_DT_SECRET_MANAGER_ROOT = \"RMDTSecretManagerRoot\";\n  protected static final String DELEGATION_KEY_PREFIX = \"DelegationKey_\";\n  protected static final String DELEGATION_TOKEN_PREFIX = \"RMDelegationToken_\";\n  protected static final String DELEGATION_TOKEN_SEQUENCE_NUMBER_PREFIX =\n      \"RMDTSequenceNumber_\";\n  protected static final String AMRMTOKEN_SECRET_MANAGER_ROOT =\n      \"AMRMTokenSecretManagerRoot\";\n  protected static final String VERSION_NODE = \"RMVersionNode\";\n  protected static final String EPOCH_NODE = \"EpochNode\";\n  public static final Log LOG = LogFactory.getLog(RMStateStore.class);\n  private enum RMStateStoreState {\n    DEFAULT\n  };\n  private static final StateMachineFactory<RMStateStore,\n                                           RMStateStoreState,\n                                           RMStateStoreEventType, \n                                           RMStateStoreEvent>\n      stateMachineFactory = new StateMachineFactory<RMStateStore,\n                                                    RMStateStoreState,\n                                                    RMStateStoreEventType,\n                                                    RMStateStoreEvent>(\n      RMStateStoreState.DEFAULT)\n      .addTransition(RMStateStoreState.DEFAULT, RMStateStoreState.DEFAULT,\n          RMStateStoreEventType.STORE_APP, new StoreAppTransition())\n      .addTransition(RMStateStoreState.DEFAULT, RMStateStoreState.DEFAULT,\n          RMStateStoreEventType.UPDATE_APP, new UpdateAppTransition())\n      .addTransition(RMStateStoreState.DEFAULT, RMStateStoreState.DEFAULT,\n          RMStateStoreEventType.REMOVE_APP, new RemoveAppTransition())\n      .addTransition(RMStateStoreState.DEFAULT, RMStateStoreState.DEFAULT,\n          RMStateStoreEventType.STORE_APP_ATTEMPT, new StoreAppAttemptTransition())\n      .addTransition(RMStateStoreState.DEFAULT, RMStateStoreState.DEFAULT,\n          RMStateStoreEventType.UPDATE_APP_ATTEMPT, new UpdateAppAttemptTransition());\n  private final StateMachine<RMStateStoreState,\n                             RMStateStoreEventType,\n                             RMStateStoreEvent> stateMachine;\n  private static class StoreAppTransition\n      implements SingleArcTransition<RMStateStore, RMStateStoreEvent> {\n    @Override\n    public void transition(RMStateStore store, RMStateStoreEvent event) {\n      if (!(event instanceof RMStateStoreAppEvent)) {\n        // should never happen\n        LOG.error(\"Illegal event type: \" + event.getClass());\n        return;\n      }\n      ApplicationState appState = ((RMStateStoreAppEvent) event).getAppState();\n      ApplicationId appId = appState.getAppId();\n      ApplicationStateData appStateData = ApplicationStateData\n          .newInstance(appState);\n      LOG.info(\"Storing info for app: \" + appId);\n      try {\n        store.storeApplicationStateInternal(appId, appStateData);\n        store.notifyApplication(new RMAppEvent(appId,\n               RMAppEventType.APP_NEW_SAVED));\n      } catch (Exception e) {\n        LOG.error(\"Error storing app: \" + appId, e);\n        store.notifyStoreOperationFailed(e);\n      }\n    };\n  }\n  private static class UpdateAppTransition implements\n      SingleArcTransition<RMStateStore, RMStateStoreEvent> {\n    @Override\n    public void transition(RMStateStore store, RMStateStoreEvent event) {\n      if (!(event instanceof RMStateUpdateAppEvent)) {\n        // should never happen\n        LOG.error(\"Illegal event type: \" + event.getClass());\n        return;\n      }\n      ApplicationState appState = ((RMStateUpdateAppEvent) event).getAppState();\n      ApplicationId appId = appState.getAppId();\n      ApplicationStateData appStateData = ApplicationStateData\n          .newInstance(appState);\n      LOG.info(\"Updating info for app: \" + appId);\n      try {\n        store.updateApplicationStateInternal(appId, appStateData);\n        store.notifyApplication(new RMAppEvent(appId,\n               RMAppEventType.APP_UPDATE_SAVED));\n      } catch (Exception e) {\n        LOG.error(\"Error updating app: \" + appId, e);\n        store.notifyStoreOperationFailed(e);\n      }\n    };\n  }\n<fim_suffix>  private static class RemoveAppTransition implements\n      SingleArcTransition<RMStateStore, RMStateStoreEvent> {\n    @Override\n    public void transition(RMStateStore store, RMStateStoreEvent event) {\n      if (!(event instanceof RMStateStoreRemoveAppEvent)) {\n        // should never happen\n        LOG.error(\"Illegal event type: \" + event.getClass());\n        return;\n      }\n      ApplicationState appState = ((RMStateStoreRemoveAppEvent) event)\n          .getAppState();\n      ApplicationId appId = appState.getAppId();\n      LOG.info(\"Removing info for app: \" + appId);\n      try {\n        store.removeApplicationStateInternal(appState);\n      } catch (Exception e) {\n        LOG.error(\"Error removing app: \" + appId, e);\n        store.notifyStoreOperationFailed(e);\n      }\n    };\n  }<fim_middle>// class below has no smell\n"}