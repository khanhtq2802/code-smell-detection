{"text": "<fim_prefix>      taskReportServer = null;\n    }\n  }\n  public static Thread startGroomServer(final GroomServer hrs) {\n    return startGroomServer(hrs, \"regionserver\" + hrs.groomServerName);\n  }\n  public static Thread startGroomServer(final GroomServer hrs, final String name) {\n    Thread t = new Thread(hrs);\n    t.setName(name);\n    t.start();\n    return t;\n  }\n  // /////////////////////////////////////////////////////\n  // TaskInProgress maintains all the info for a Task that\n  // lives at this GroomServer. It maintains the Task object,\n  // its TaskStatus, and the BSPTaskRunner.\n  // /////////////////////////////////////////////////////\n  class TaskInProgress {\n    Task task;\n    BSPJob jobConf;\n    BSPJob localJobConf;\n    BSPTaskRunner runner;\n    volatile boolean done = false;\n    volatile boolean wasKilled = false;\n    private TaskStatus taskStatus;\n    private long startTime = 0L;\n    private volatile long lastPingedTimestamp = 0L;\n    private long startSuperstepCount = -1;\n    public TaskInProgress(Task task, BSPJob jobConf, String groomServer) {\n      this.task = task;\n      this.jobConf = jobConf;\n      this.localJobConf = null;\n      this.taskStatus = new TaskStatus(task.getJobID(), task.getTaskID(), 0,\n          TaskStatus.State.UNASSIGNED, \"init\", groomServer,\n          TaskStatus.Phase.STARTING, task.getCounters());\n    }\n    public void markAsRecoveryTask(long superstepNumber) {\n      if (this.taskStatus.getRunState() != TaskStatus.State.FAILED) {\n        this.taskStatus.setRunState(TaskStatus.State.RECOVERING);\n        this.taskStatus.setPhase(TaskStatus.Phase.RECOVERING);\n        this.taskStatus.setStateString(\"recovering\");\n      }\n      this.startSuperstepCount = superstepNumber;\n    }\n    private void localizeTask(Task task) throws IOException {\n      Path localJobFile = this.jobConf.getLocalPath(SUBDIR + \"/\"\n          + task.getTaskID() + \"/job.xml\");\n      Path localJarFile = this.jobConf.getLocalPath(SUBDIR + \"/\"\n          + task.getTaskID() + \"/job.jar\");\n      String jobFile = task.getJobFile();\n      FileSystem.get(conf).copyToLocalFile(new Path(jobFile), localJobFile);\n      task.setJobFile(localJobFile.toString());\n      localJobConf = new BSPJob(task.getJobID(), localJobFile.toString());\n      localJobConf.set(\"bsp.task.id\", task.getTaskID().toString());\n      String jarFile = localJobConf.getJar();\n      if (jarFile != null) {\n        FileSystem.get(conf).copyToLocalFile(new Path(jarFile), localJarFile);\n        localJobConf.setJar(localJarFile.toString());\n      }\n      task.setConf(localJobConf);\n    }\n    public synchronized void setJobConf(BSPJob jobConf) {\n      this.jobConf = jobConf;\n    }\n    public synchronized BSPJob getJobConf() {\n      return localJobConf;\n    }\n    public void launchTask() throws IOException {\n      localizeTask(task);\n      taskStatus.setRunState(TaskStatus.State.RUNNING);\n      this.runner = task.createRunner(GroomServer.this);\n      this.runner.start();\n      startTime = Calendar.getInstance().getTimeInMillis();\n      LOG.info(\"Task '\" + task.getTaskID().toString() + \"' has started.\");\n    }\n    /**\n     * Something went wrong and the task must be killed.\n     */\n    public synchronized void killAndCleanup(boolean wasFailure)\n        throws IOException {\n      if (wasFailure) {\n        failures += 1;\n        taskStatus.setRunState(TaskStatus.State.FAILED);\n      } else {\n        taskStatus.setRunState(TaskStatus.State.KILLED);\n      }\n      // runner could be null if task-cleanup attempt is not localized yet\n      if (runner != null) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Killing process for \" + this.task.getTaskID());\n        }\n        runner.killBsp();\n      }\n      runner = null;\n    }\n    public synchronized void killRunner() throws IOException {\n      if (runner != null) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Killing process for \" + this.task.getTaskID());\n        }\n        runner.killBsp();\n      }\n      runner = null;\n    }\n    /**\n     */\n    public Task getTask() {\n      return task;\n    }\n    /**\n     */\n    public synchronized TaskStatus getStatus() {\n      return taskStatus;\n    }\n    /**\n     */\n    public TaskStatus.State getRunState() {\n      return taskStatus.getRunState();\n    }\n    public boolean wasKilled() {\n      return wasKilled;\n    }\n    @Override\n    public boolean equals(Object obj) {\n      return (obj instanceof TaskInProgress)\n          && task.getTaskID().equals(\n              ((TaskInProgress) obj).getTask().getTaskID());\n    }\n    @Override\n    public int hashCode() {\n      return task.getTaskID().hashCode();\n    }\n    public void reportProgress(TaskStatus taskStatus) {\n      // LOG.info(task.getTaskID() + \" \" + taskStatus.getProgress() + \"% \"\n      // + taskStatus.getStateString());\n      if (this.done) {\n        LOG.info(task.getTaskID()\n            + \" Ignoring status-update since \"\n            + ((this.done) ? \"task is 'done'\" : (\"runState: \" + this.taskStatus\n                .getRunState())));\n        return;\n      }\n      this.taskStatus.statusUpdate(taskStatus);\n    }\n    public void reportDone() {\n      if (this.taskStatus.getRunState() != TaskStatus.State.FAILED) {\n        this.taskStatus.setRunState(TaskStatus.State.SUCCEEDED);\n      }\n      this.taskStatus.setFinishTime(System.currentTimeMillis());\n      this.done = true;\n      this.runner.killBsp();\n      LOG.info(\"Task \" + task.getTaskID() + \" is done.\");\n    }\n    public void jobHasFinished(boolean wasFailure) throws IOException {\n      // Kill the task if it is still running\n      synchronized (this) {\n        if (getRunState() == TaskStatus.State.RUNNING\n            || getRunState() == TaskStatus.State.UNASSIGNED\n            || getRunState() == TaskStatus.State.COMMIT_PENDING) {\n          killAndCleanup(wasFailure);\n        }\n      }\n    }\n    public synchronized void ping(long timestamp) {\n      this.lastPingedTimestamp = timestamp;\n    }\n  }\n  public boolean isRunning() {\n    return running;\n  }\n  public static GroomServer constructGroomServer(\n      Class<? extends GroomServer> groomServerClass, final Configuration conf2) {\n    try {\n      Constructor<? extends GroomServer> c = groomServerClass\n          .getConstructor(Configuration.class);\n      return c.newInstance(conf2);\n    } catch (Exception e) {\n      throw new RuntimeException(\"Failed construction of \" + \"Master: \"\n          + groomServerClass.toString(), e);\n    }\n  }\n  @Override\n  public long getProtocolVersion(String protocol, long clientVersion)\n      throws IOException {\n    if (protocol.equals(GroomProtocol.class.getName())) {\n      return HamaRPCProtocolVersion.versionID;\n    } else if (protocol.equals(BSPPeerProtocol.class.getName())) {\n      return HamaRPCProtocolVersion.versionID;\n    } else {\n      throw new IOException(\"Unknown protocol to GroomServer: \" + protocol);\n    }\n  }\n  /**\n   * Remove the tip and update all relevant state.\n   * \n   * @param tip {@link TaskInProgress} to be removed.\n   * @param wasFailure did the task fail or was it killed?\n   */\n  private void purgeTask(TaskInProgress tip, boolean wasFailure)\n      throws IOException {\n    if (tip != null) {\n      LOG.info(\"About to purge task: \" + tip.getTask().getTaskID());\n      // Remove the task from running jobs,\n      // removing the job if it's the last task\n      removeTaskFromJob(tip.getTask().getJobID(), tip);\n      tip.jobHasFinished(wasFailure);\n    }\n  }\n<fim_suffix>  private void removeTaskFromJob(BSPJobID jobId, TaskInProgress tip) {\n    synchronized (runningJobs) {\n      RunningJob rjob = runningJobs.get(jobId);\n      if (rjob == null) {\n        LOG.warn(\"Unknown job \" + jobId + \" being deleted.\");\n      } else {\n        synchronized (rjob) {\n          rjob.tasks.remove(tip);\n        }\n      }\n    }\n  }<fim_middle>// function below has no smell\n"}