{"text": "<fim_prefix>import org.apache.commons.configuration2.io.FileHandler;\nimport org.apache.commons.configuration2.reloading.ReloadingController;\nimport org.apache.commons.configuration2.reloading.ReloadingControllerSupport;\nimport org.apache.commons.configuration2.reloading.ReloadingDetector;\n/**\n * <p>\n * A specialized {@code ConfigurationBuilder} implementation which can handle\n * configurations read from a {@link FileHandler} and supports reloading.\n * </p>\n * <p>\n * This builder class exposes a {@link ReloadingController} object controlling\n * reload operations on the file-based configuration produced as result object.\n * For the {@code FileHandler} defining the location of the configuration a\n * configurable {@link ReloadingDetector} is created and associated with the\n * controller. So changes on the source file can be detected. When ever such a\n * change occurs, the result object of this builder is reset. This means that\n * the next time {@code getConfiguration()} is called a new\n * {@code Configuration} object is created which is loaded from the modified\n * file.\n * </p>\n * <p>\n * Client code interested in notifications can register a listener at this\n * builder to receive reset events. When such an event is received the new\n * result object can be requested. This way client applications can be sure to\n * work with an up-to-date configuration. It is also possible to register a\n * listener directly at the {@code ReloadingController}.\n * </p>\n * <p>\n * This builder does not actively trigger the {@code ReloadingController} to\n * perform a reload check. This has to be done by an external component, e.g. a\n * timer.\n * </p>\n *\n * @version $Id$\n * @since 2.0\n * @param <T> the concrete type of {@code Configuration} objects created by this\n *        builder\n */\n<fim_suffix>public class ReloadingFileBasedConfigurationBuilder<T extends FileBasedConfiguration>\n        extends FileBasedConfigurationBuilder<T> implements ReloadingControllerSupport\n{\n    /** The default factory for creating reloading detector objects. */\n    private static final ReloadingDetectorFactory DEFAULT_DETECTOR_FACTORY =\n            new DefaultReloadingDetectorFactory();\n    /** The reloading controller associated with this object. */\n    private final ReloadingController reloadingController;\n    /**\n     * The reloading detector which does the actual reload check for the current\n     * result object. A new instance is created whenever a new result object\n     * (and thus a new current file handler) becomes available. The field must\n     * be volatile because it is accessed by the reloading controller probably\n     * from within another thread.\n     */\n    private volatile ReloadingDetector resultReloadingDetector;\n    /**\n     * Creates a new instance of {@code ReloadingFileBasedConfigurationBuilder}\n     * which produces result objects of the specified class and sets\n     * initialization parameters.\n     *\n     * @param resCls the result class (must not be <b>null</b>\n     * @param params a map with initialization parameters\n     * @throws IllegalArgumentException if the result class is <b>null</b>\n     */\n    public ReloadingFileBasedConfigurationBuilder(final Class<? extends T> resCls,\n            final Map<String, Object> params)\n    {\n        super(resCls, params);\n        reloadingController = createReloadingController();\n    }\n    /**\n     * Creates a new instance of {@code ReloadingFileBasedConfigurationBuilder}\n     * which produces result objects of the specified class and sets\n     * initialization parameters and the <em>allowFailOnInit</em> flag.\n     *\n     * @param resCls the result class (must not be <b>null</b>\n     * @param params a map with initialization parameters\n     * @param allowFailOnInit the <em>allowFailOnInit</em> flag\n     * @throws IllegalArgumentException if the result class is <b>null</b>\n     */\n    public ReloadingFileBasedConfigurationBuilder(final Class<? extends T> resCls,\n            final Map<String, Object> params, final boolean allowFailOnInit)\n    {\n        super(resCls, params, allowFailOnInit);\n        reloadingController = createReloadingController();\n    }\n    /**\n     * Creates a new instance of {@code ReloadingFileBasedConfigurationBuilder}\n     * which produces result objects of the specified class.\n     *\n     * @param resCls the result class (must not be <b>null</b>\n     * @throws IllegalArgumentException if the result class is <b>null</b>\n     */\n    public ReloadingFileBasedConfigurationBuilder(final Class<? extends T> resCls)\n    {\n        super(resCls);\n        reloadingController = createReloadingController();\n    }\n    /**\n     * Returns the {@code ReloadingController} associated with this builder.\n     * This controller is directly created. However, it becomes active (i.e.\n     * associated with a meaningful reloading detector) not before a result\n     * object was created.\n     *\n     * @return the {@code ReloadingController}\n     */\n    @Override\n    public ReloadingController getReloadingController()\n    {\n        return reloadingController;\n    }\n    /**\n     * {@inheritDoc} This method is overridden here to change the result type.\n     */\n    @Override\n    public ReloadingFileBasedConfigurationBuilder<T> configure(\n            final BuilderParameters... params)\n    {\n        super.configure(params);\n        return this;\n    }\n    /**\n     * Creates a {@code ReloadingDetector} which monitors the passed in\n     * {@code FileHandler}. This method is called each time a new result object\n     * is created with the current {@code FileHandler}. This implementation\n     * checks whether a {@code ReloadingDetectorFactory} is specified in the\n     * current parameters. If this is the case, it is invoked. Otherwise, a\n     * default factory is used to create a {@code FileHandlerReloadingDetector}\n     * object. Note: This method is called from a synchronized block.\n     *\n     * @param handler the current {@code FileHandler}\n     * @param fbparams the object with parameters related to file-based builders\n     * @return a {@code ReloadingDetector} for this {@code FileHandler}\n     * @throws ConfigurationException if an error occurs\n     */\n    protected ReloadingDetector createReloadingDetector(final FileHandler handler,\n            final FileBasedBuilderParametersImpl fbparams)\n            throws ConfigurationException\n    {\n        return fetchDetectorFactory(fbparams).createReloadingDetector(handler,\n                fbparams);\n    }\n    /**\n     * {@inheritDoc} This implementation also takes care that a new\n     * {@code ReloadingDetector} for the new current {@code FileHandler} is\n     * created. Also, the reloading controller's reloading state has to be\n     * reset; after the creation of a new result object changes in the\n     * underlying configuration source have to be monitored again.\n     */\n    @Override\n    protected void initFileHandler(final FileHandler handler)\n            throws ConfigurationException\n    {\n        super.initFileHandler(handler);\n        resultReloadingDetector =\n                createReloadingDetector(handler,\n                        FileBasedBuilderParametersImpl.fromParameters(\n                                getParameters(), true));\n    }\n    /**\n     * Creates the {@code ReloadingController} associated with this object. The\n     * controller is assigned a specialized reloading detector which delegates\n     * to the detector for the current result object. (\n     * {@code FileHandlerReloadingDetector} does not support changing the file\n     * handler, and {@code ReloadingController} does not support changing the\n     * reloading detector; therefore, this level of indirection is needed to\n     * change the monitored file dynamically.)\n     *\n     * @return the new {@code ReloadingController}\n     */\n    private ReloadingController createReloadingController()\n    {\n        final ReloadingDetector ctrlDetector = createReloadingDetectorForController();\n        final ReloadingController ctrl = new ReloadingController(ctrlDetector);\n        connectToReloadingController(ctrl);\n        return ctrl;\n    }\n    /**\n     * Creates a {@code ReloadingDetector} wrapper to be passed to the\n     * associated {@code ReloadingController}. This detector wrapper simply\n     * delegates to the current {@code ReloadingDetector} if it is available.\n     *\n     * @return the wrapper {@code ReloadingDetector}\n     */\n    private ReloadingDetector createReloadingDetectorForController()\n    {\n        return new ReloadingDetector()\n        {\n            @Override\n            public void reloadingPerformed()\n            {\n                final ReloadingDetector detector = resultReloadingDetector;\n                if (detector != null)\n                {\n                    detector.reloadingPerformed();\n                }\n            }\n            @Override\n            public boolean isReloadingRequired()\n            {\n                final ReloadingDetector detector = resultReloadingDetector;\n                return (detector != null) && detector.isReloadingRequired();\n            }\n        };\n    }\n    /**\n     * Returns a {@code ReloadingDetectorFactory} either from the passed in\n     * parameters or a default factory.\n     *\n     * @param params the current parameters object\n     * @return the {@code ReloadingDetectorFactory} to be used\n     */\n    private static ReloadingDetectorFactory fetchDetectorFactory(\n            final FileBasedBuilderParametersImpl params)\n    {\n        final ReloadingDetectorFactory factory = params.getReloadingDetectorFactory();\n        return (factory != null) ? factory : DEFAULT_DETECTOR_FACTORY;\n    }\n}<fim_middle>// class below is blob and data class\n"}