{"text": "<fim_prefix>\n<fim_suffix>public class BridgeVifDriver extends VifDriverBase {\n    private static final Logger s_logger = Logger.getLogger(BridgeVifDriver.class);\n    private int _timeout;\n    private final Object _vnetBridgeMonitor = new Object();\n    private String _modifyVlanPath;\n    private String _modifyVxlanPath;\n    private String bridgeNameSchema;\n    private Long libvirtVersion;\n    @Override\n    public void configure(Map<String, Object> params) throws ConfigurationException {\n        super.configure(params);\n        getPifs();\n        // Set the domr scripts directory\n        params.put(\"domr.scripts.dir\", \"scripts/network/domr/kvm\");\n        String networkScriptsDir = (String)params.get(\"network.scripts.dir\");\n        if (networkScriptsDir == null) {\n            networkScriptsDir = \"scripts/vm/network/vnet\";\n        }\n        bridgeNameSchema = (String)params.get(\"network.bridge.name.schema\");\n        String value = (String)params.get(\"scripts.timeout\");\n        _timeout = NumbersUtil.parseInt(value, 30 * 60) * 1000;\n        _modifyVlanPath = Script.findScript(networkScriptsDir, \"modifyvlan.sh\");\n        if (_modifyVlanPath == null) {\n            throw new ConfigurationException(\"Unable to find modifyvlan.sh\");\n        }\n        _modifyVxlanPath = Script.findScript(networkScriptsDir, \"modifyvxlan.sh\");\n        if (_modifyVxlanPath == null) {\n            throw new ConfigurationException(\"Unable to find modifyvxlan.sh\");\n        }\n        libvirtVersion = (Long) params.get(\"libvirtVersion\");\n        if (libvirtVersion == null) {\n            libvirtVersion = 0L;\n        }\n    }\n    public void getPifs() {\n        final File dir = new File(\"/sys/devices/virtual/net\");\n        final File[] netdevs = dir.listFiles();\n        final List<String> bridges = new ArrayList<String>();\n        for (File netdev : netdevs) {\n            final File isbridge = new File(netdev.getAbsolutePath() + \"/bridge\");\n            final String netdevName = netdev.getName();\n            s_logger.debug(\"looking in file \" + netdev.getAbsolutePath() + \"/bridge\");\n            if (isbridge.exists()) {\n                s_logger.debug(\"Found bridge \" + netdevName);\n                bridges.add(netdevName);\n            }\n        }\n        String guestBridgeName = _libvirtComputingResource.getGuestBridgeName();\n        String publicBridgeName = _libvirtComputingResource.getPublicBridgeName();\n        for (final String bridge : bridges) {\n            s_logger.debug(\"looking for pif for bridge \" + bridge);\n            final String pif = getPif(bridge);\n            if (_libvirtComputingResource.isPublicBridge(bridge)) {\n                _pifs.put(\"public\", pif);\n            }\n            if (guestBridgeName != null && bridge.equals(guestBridgeName)) {\n                _pifs.put(\"private\", pif);\n            }\n            _pifs.put(bridge, pif);\n        }\n        // guest(private) creates bridges on a pif, if private bridge not found try pif direct\n        // This addresses the unnecessary requirement of someone to create an unused bridge just for traffic label\n        if (_pifs.get(\"private\") == null) {\n            s_logger.debug(\"guest(private) traffic label '\" + guestBridgeName + \"' not found as bridge, looking for physical interface\");\n            final File dev = new File(\"/sys/class/net/\" + guestBridgeName);\n            if (dev.exists()) {\n                s_logger.debug(\"guest(private) traffic label '\" + guestBridgeName + \"' found as a physical device\");\n                _pifs.put(\"private\", guestBridgeName);\n            }\n        }\n        // public creates bridges on a pif, if private bridge not found try pif direct\n        // This addresses the unnecessary requirement of someone to create an unused bridge just for traffic label\n        if (_pifs.get(\"public\") == null) {\n            s_logger.debug(\"public traffic label '\" + publicBridgeName+ \"' not found as bridge, looking for physical interface\");\n            final File dev = new File(\"/sys/class/net/\" + publicBridgeName);\n            if (dev.exists()) {\n                s_logger.debug(\"public traffic label '\" + publicBridgeName + \"' found as a physical device\");\n                _pifs.put(\"public\", publicBridgeName);\n            }\n        }\n        s_logger.debug(\"done looking for pifs, no more bridges\");\n    }\n    private String getPif(final String bridge) {\n        String pif = matchPifFileInDirectory(bridge);\n        final File vlanfile = new File(\"/proc/net/vlan/\" + pif);\n        if (vlanfile.isFile()) {\n            pif = Script.runSimpleBashScript(\"grep ^Device\\\\: /proc/net/vlan/\" + pif + \" | awk {'print $2'}\");\n        }\n        return pif;\n    }\n    private String matchPifFileInDirectory(final String bridgeName) {\n        final File brif = new File(\"/sys/devices/virtual/net/\" + bridgeName + \"/brif\");\n        if (!brif.isDirectory()) {\n            final File pif = new File(\"/sys/class/net/\" + bridgeName);\n            if (pif.isDirectory()) {\n                // if bridgeName already refers to a pif, return it as-is\n                return bridgeName;\n            }\n            s_logger.debug(\"failing to get physical interface from bridge \" + bridgeName + \", does \" + brif.getAbsolutePath() + \"exist?\");\n            return \"\";\n        }\n        final File[] interfaces = brif.listFiles();\n        for (File anInterface : interfaces) {\n            final String fname = anInterface.getName();\n            s_logger.debug(\"matchPifFileInDirectory: file name '\" + fname + \"'\");\n            if (LibvirtComputingResource.isInterface(fname)) {\n                return fname;\n            }\n        }\n        s_logger.debug(\"failing to get physical interface from bridge \" + bridgeName + \", did not find an eth*, bond*, team*, vlan*, em*, p*p*, ens*, eno*, enp*, or enx* in \" + brif.getAbsolutePath());\n        return \"\";\n    }\n    protected boolean isBroadcastTypeVlanOrVxlan(final NicTO nic) {\n        return nic != null && (nic.getBroadcastType() == Networks.BroadcastDomainType.Vlan\n                || nic.getBroadcastType() == Networks.BroadcastDomainType.Vxlan);\n    }\n    protected boolean isValidProtocolAndVnetId(final String vNetId, final String protocol) {\n        return vNetId != null && protocol != null && !vNetId.equalsIgnoreCase(\"untagged\");\n    }\n    @Override\n    public LibvirtVMDef.InterfaceDef plug(NicTO nic, String guestOsType, String nicAdapter, Map<String, String> extraConfig) throws InternalErrorException, LibvirtException {\n        if (s_logger.isDebugEnabled()) {\n            s_logger.debug(\"nic=\" + nic);\n            if (nicAdapter != null && !nicAdapter.isEmpty()) {\n                s_logger.debug(\"custom nic adapter=\" + nicAdapter);\n            }\n        }\n        LibvirtVMDef.InterfaceDef intf = new LibvirtVMDef.InterfaceDef();\n        String vNetId = null;\n        String protocol = null;\n        if (isBroadcastTypeVlanOrVxlan(nic)) {\n            vNetId = Networks.BroadcastDomainType.getValue(nic.getBroadcastUri());\n            protocol = Networks.BroadcastDomainType.getSchemeValue(nic.getBroadcastUri()).scheme();\n        } else if (nic.getBroadcastType() == Networks.BroadcastDomainType.Lswitch) {\n            throw new InternalErrorException(\"Nicira NVP Logicalswitches are not supported by the BridgeVifDriver\");\n        }\n        String trafficLabel = nic.getName();\n        Integer networkRateKBps = 0;\n        if (libvirtVersion > ((10 * 1000 + 10))) {\n            networkRateKBps = (nic.getNetworkRateMbps() != null && nic.getNetworkRateMbps().intValue() != -1) ? nic.getNetworkRateMbps().intValue() * 128 : 0;\n        }\n        if (nic.getType() == Networks.TrafficType.Guest) {\n            if (isBroadcastTypeVlanOrVxlan(nic) && isValidProtocolAndVnetId(vNetId, protocol)) {\n                    if (trafficLabel != null && !trafficLabel.isEmpty()) {\n                        s_logger.debug(\"creating a vNet dev and bridge for guest traffic per traffic label \" + trafficLabel);\n                        String brName = createVnetBr(vNetId, trafficLabel, protocol);\n                        intf.defBridgeNet(brName, null, nic.getMac(), getGuestNicModel(guestOsType, nicAdapter), networkRateKBps);\n                    } else {\n                        String brName = createVnetBr(vNetId, \"private\", protocol);<fim_middle>// class below is blob\n"}