{"text": "<fim_prefix>\n<fim_suffix>public class WantPropertyElement extends Frame implements WantsObjectFrameI,\n        HasSubjectFrameI {\n    int liCounter = 1;\n    ANode predicate;\n    ANode object;\n    ANode reify;\n    boolean objectIsBlank = false;\n    public WantPropertyElement(HasSubjectFrameI s, AbsXMLContext x) {\n        super(s, x);\n    }\n    // These three are used as bitfields\n    static final private int TYPEDLITERAL = 1;\n    static final private int EMPTYWITHOBJ = 2;\n    static final private int PARSETYPE = 4;\n    @Override\n    public FrameI startElement(String uri, String localName, String rawName,\n            Attributes atts) throws SAXParseException {\n        clearObject();\n        if (nonWhiteMsgGiven)\n            taint.isTainted();\n        nonWhiteMsgGiven = false;\n        if (uri==null || uri.equals(\"\")) {\n            warning(WARN_UNQUALIFIED_ELEMENT,\"Unqualified property elements are not allowed. Treated as a relative URI.\");\n        }\n        ElementLexer el = new ElementLexer(taint, this, uri, localName,\n                rawName, E_LI, CoreAndOldTerms | E_DESCRIPTION, false);\n        // if (el.badMatch)\n        // warning(ERR_SYNTAX_ERROR,\"bad use of \" + rawName);\n        predicate = el.goodMatch ? (AResourceInternal) rdf_n(liCounter++)\n                : URIReference.fromQName(this, uri, localName);\n        if (taint.isTainted())\n            predicate.taint();\n        taint = new TaintImpl();\n        AttributeLexer ap = new AttributeLexer(this,\n        // xml:\n                A_XMLLANG | A_XMLBASE | A_XML_OTHER\n                // legal rdf:\n                        | A_DATATYPE | A_ID | A_NODEID | A_PARSETYPE\n                        | A_RESOURCE | A_TYPE,\n                // bad rdf:\n                A_BADATTRS);\n        int cnt = ap.processSpecials(taint, atts);\n        // These three states are intended as mutually\n        // incompatible, but all three can occur\n        // together. Any two of the three, or all\n        // three is a syntax errror.\n        // Having none of these is legal.\n        final int nextStateCode = (ap.datatype == null ? 0 : TYPEDLITERAL)\n                | (ap.parseType == null ? 0 : PARSETYPE)\n                | (mustBeEmpty(ap, atts, cnt) ? EMPTYWITHOBJ : 0);\n        if (this.badStateCode(nextStateCode)) {\n            warning(errorNumber(nextStateCode), descriptionOfCases(ap,\n                    nextStateCode, propertyAttributeDescription(atts, ap, cnt)));\n        }\n        AbsXMLContext x = ap.xml(xml);\n        reify = ap.id == null ? null : URIReference.fromID(this, x, ap.id);\n        if (taint.isTainted())\n            predicate.taint();\n        if (mustBeEmpty(ap, atts, cnt)) {\n            if (ap.nodeID != null) {\n                object = new ARPResource(arp, ap.nodeID);\n                checkNodeID_XMLName(object, ap.nodeID);\n                objectIsBlank = true;\n            }\n            if (ap.resource != null) {\n                if (object != null) {\n                    if (!badStateCode(nextStateCode))\n                        // otherwise warning already given\n                        warning(ERR_SYNTAX_ERROR, \n                                \"On a property element, only one of the attributes rdf:nodeID or rdf:resource is permitted.\");\n                } else\n                    object = URIReference.resolve(this, x, ap.resource);\n            }\n            if (object == null) {\n                object = new ARPResource(arp);\n                objectIsBlank = true;\n            }\n            if (taint.isTainted())\n                object.taint();\n            processPropertyAttributes(ap, atts, x);\n        }\n        FrameI nextFrame = nextFrame(atts, ap, cnt, nextStateCode, x);\n        if (object != null) {\n            if (taint.isTainted())\n                object.taint();\n            theObject(object);\n        }\n        if (taint.isTainted())\n            predicate.taint();\n        return nextFrame;\n    }\n    private boolean mustBeEmpty(AttributeLexer ap, Attributes atts, int cnt) {\n        return cnt < atts.getLength() || ap.type != null || ap.nodeID != null\n                || ap.resource != null;\n    }\n    private FrameI nextFrame(Attributes atts, AttributeLexer ap, int cnt,\n            int nextStateCode, AbsXMLContext x) throws SAXParseException {\n        switch (nextStateCode) {\n        case 0:\n            return new WantLiteralValueOrDescription(this, x);\n        case PARSETYPE | TYPEDLITERAL:\n        case PARSETYPE | TYPEDLITERAL | EMPTYWITHOBJ:\n        case PARSETYPE | EMPTYWITHOBJ:\n        case PARSETYPE:\n            return withParsetype(ap.parseType, x);\n        case TYPEDLITERAL | EMPTYWITHOBJ:\n        case TYPEDLITERAL:\n            return new WantTypedLiteral(this, ap.datatype, x);\n        case EMPTYWITHOBJ:\n            return new WantEmpty(this, x);\n        }\n        throw new IllegalStateException(\"impossible\");\n    }\n    private FrameI withParsetype(String pt, AbsXMLContext x)\n            throws SAXParseException {\n        if (pt.equals(\"Collection\")) {\n            return new RDFCollection(this, x);\n        }\n        if (pt.equals(\"Resource\")) {\n            if (object == null) {\n                // in some error cases the object has already been set.\n                object = new ARPResource(arp);\n                objectIsBlank = true;\n            }\n            return new WantPropertyElement(this, x);\n        }\n        if (!pt.equals(\"Literal\")) {\n            warning(WARN_UNKNOWN_PARSETYPE, \"Unknown rdf:parseType: '\" + pt\n                    + \"' (treated as 'Literal'.\");\n        }\n        return new OuterXMLLiteral(this, x, pt);\n    }\n    @Override\n    String suggestParsetypeLiteral() {\n        return (getParent() instanceof WantTopLevelDescription) ? \"\" : super\n                .suggestParsetypeLiteral();\n    }\n    @Override\n    public void aPredAndObj(ANode p, ANode o) {\n        triple(object, p, o);\n    }\n    @Override\n    public void makeSubjectReificationWith(ANode r) {\n        triple(r, RDF_SUBJECT, object);\n    }\n    @Override\n    public void theObject(ANode o) {\n        HasSubjectFrameI p = (HasSubjectFrameI) getParent();\n        p.aPredAndObj(predicate, o);\n        if (reify != null) {\n            triple(reify, RDF_TYPE, RDF_STATEMENT);\n            triple(reify, RDF_OBJECT, o);\n            triple(reify, RDF_PREDICATE, predicate);\n            p.makeSubjectReificationWith(reify);\n        }\n    }\n    @Override\n    public void endElement() {\n        clearObject();\n    }\n    @Override\n    public void abort() {\n        clearObject();\n    }\n    private void clearObject() {\n        if (objectIsBlank)\n            arp.endLocalScope(object);\n        objectIsBlank = false;\n        object = null;\n    }\n    static private URIReference _rdf_n[] = new URIReference[0];\n    static private URIReference rdf_n(int i) {\n        if (i >= _rdf_n.length) {\n            int newLength = (i + 10) * 3 / 2;\n            URIReference new_rdf_n[] = new URIReference[newLength];\n            System.arraycopy(_rdf_n, 0, new_rdf_n, 0, _rdf_n.length);\n            for (int j = _rdf_n.length; j < newLength; j++) {\n                new_rdf_n[j] = URIReference.createNoChecks(rdfns + \"_\" + j);\n            }\n            _rdf_n = new_rdf_n;\n        }\n        return _rdf_n[i];\n    }\n    /***************************************************************************\n     * \n     * ERROR HANDLING CODE\n     * \n     **************************************************************************/\n    // Error detection\n    private boolean badStateCode(int nextStateCode) {\n        switch (nextStateCode) {\n        case PARSETYPE | TYPEDLITERAL:\n        case PARSETYPE | TYPEDLITERAL | EMPTYWITHOBJ:\n        case PARSETYPE | EMPTYWITHOBJ:\n        case TYPEDLITERAL | EMPTYWITHOBJ:\n            return true;\n        case 0:\n        case PARSETYPE:\n        case TYPEDLITERAL:\n        case EMPTYWITHOBJ:\n            return false;\n        }\n        throw new IllegalStateException(\"impossible\");\n    }\n    // Error classification\n    private int errorNumber(int nextStateCode) {\n        // TODO: not for 2.3. refine this error code.\n        return ERR_SYNTAX_ERROR;\n    }\n    /***************************************************************************\n     * \n     * ERROR MESSAGES\n     * \n     **************************************************************************/\n   private String descriptionOfCases(AttributeLexer ap, int nextStateCode,\n            String propAttrs) {<fim_middle>// class below is blob\n"}