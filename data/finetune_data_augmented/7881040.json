{"text": "<fim_prefix>/*\n * Copyright 2018-present Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License. You may obtain\n * a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage com.facebook.buck.core.sourcepath.resolver.impl;\nimport com.facebook.buck.core.exceptions.HumanReadableException;\nimport com.facebook.buck.core.model.BuildTarget;\nimport com.facebook.buck.core.sourcepath.ArchiveMemberSourcePath;\nimport com.facebook.buck.core.sourcepath.BuildTargetSourcePath;\nimport com.facebook.buck.core.sourcepath.DefaultBuildTargetSourcePath;\nimport com.facebook.buck.core.sourcepath.ExplicitBuildTargetSourcePath;\nimport com.facebook.buck.core.sourcepath.ForwardingBuildTargetSourcePath;\nimport com.facebook.buck.core.sourcepath.PathSourcePath;\nimport com.facebook.buck.core.sourcepath.SourcePath;\nimport com.facebook.buck.core.sourcepath.resolver.SourcePathResolver;\nimport com.facebook.buck.io.ArchiveMemberPath;\nimport com.facebook.buck.io.filesystem.ProjectFilesystem;\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.FluentIterable;\nimport com.google.common.collect.ImmutableCollection;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableSortedSet;\nimport com.google.common.collect.Ordering;\nimport java.nio.file.Path;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\n/**\n * Abstract implementation of SourcePathResolver.\n *\n * <p>Most of the SourcePathResolver interface can be implemented in terms of just a few functions (\n * the main requirement is resolving BuildTargetSourcePaths).\n */\npublic abstract class AbstractSourcePathResolver implements SourcePathResolver {\n  protected abstract SourcePath resolveDefaultBuildTargetSourcePath(\n      DefaultBuildTargetSourcePath targetSourcePath);\n  @Override\n  public abstract String getSourcePathName(BuildTarget target, SourcePath sourcePath);\n  protected abstract ProjectFilesystem getBuildTargetSourcePathFilesystem(\n      BuildTargetSourcePath sourcePath);\n  @Override\n  public <T> ImmutableMap<T, Path> getMappedPaths(Map<T, SourcePath> sourcePathMap) {\n    ImmutableMap.Builder<T, Path> paths = ImmutableMap.builder();\n    for (ImmutableMap.Entry<T, SourcePath> entry : sourcePathMap.entrySet()) {\n      paths.put(entry.getKey(), getAbsolutePath(entry.getValue()));\n    }\n    return paths.build();\n  }\n  /** @return the {@link ProjectFilesystem} associated with {@code sourcePath}. */\n  @Override\n  public ProjectFilesystem getFilesystem(SourcePath sourcePath) {\n    if (sourcePath instanceof PathSourcePath) {\n      return ((PathSourcePath) sourcePath).getFilesystem();\n    }\n    if (sourcePath instanceof BuildTargetSourcePath) {\n      return getBuildTargetSourcePathFilesystem((BuildTargetSourcePath) sourcePath);\n    }\n    if (sourcePath instanceof ArchiveMemberSourcePath) {\n      return getFilesystem(((ArchiveMemberSourcePath) sourcePath).getArchiveSourcePath());\n    }\n    throw new IllegalStateException();\n  }\n  /**\n   * @return the {@link Path} for this {@code sourcePath}, resolved using its associated {@link\n   *     ProjectFilesystem}.\n   */\n  @Override\n  public Path getAbsolutePath(SourcePath sourcePath) {\n    Path path = getPathPrivateImpl(sourcePath);\n    if (path.isAbsolute()) {\n      return path;\n    }\n    if (sourcePath instanceof BuildTargetSourcePath) {\n      return getBuildTargetSourcePathFilesystem((BuildTargetSourcePath) sourcePath).resolve(path);\n    } else if (sourcePath instanceof PathSourcePath) {\n      return ((PathSourcePath) sourcePath).getFilesystem().resolve(path);\n    } else {\n      throw new UnsupportedOperationException(sourcePath.getClass() + \" is not supported here!\");\n    }\n  }\n  @Override\n  public ArchiveMemberPath getAbsoluteArchiveMemberPath(SourcePath sourcePath) {\n    Preconditions.checkState(sourcePath instanceof ArchiveMemberSourcePath);\n    ArchiveMemberSourcePath archiveMemberSourcePath = (ArchiveMemberSourcePath) sourcePath;\n    Path archiveAbsolutePath = getAbsolutePath(archiveMemberSourcePath.getArchiveSourcePath());\n    return ArchiveMemberPath.of(archiveAbsolutePath, archiveMemberSourcePath.getMemberPath());\n  }\n<fim_suffix>  @Override\n  public ArchiveMemberPath getRelativeArchiveMemberPath(SourcePath sourcePath) {\n    Preconditions.checkState(sourcePath instanceof ArchiveMemberSourcePath);\n    ArchiveMemberSourcePath archiveMemberSourcePath = (ArchiveMemberSourcePath) sourcePath;\n    Path archiveRelativePath = getRelativePath(archiveMemberSourcePath.getArchiveSourcePath());\n    return ArchiveMemberPath.of(archiveRelativePath, archiveMemberSourcePath.getMemberPath());\n  }\n  @Override\n  public ImmutableSortedSet<Path> getAllAbsolutePaths(\n      Collection<? extends SourcePath> sourcePaths) {\n    return sourcePaths\n        .stream()\n        .map(this::getAbsolutePath)\n        .collect(ImmutableSortedSet.toImmutableSortedSet(Ordering.natural()));\n  }\n  /**\n   * @return The {@link Path} the {@code sourcePath} refers to, relative to its owning {@link\n   *     ProjectFilesystem}.\n   */\n  @Override\n  public Path getRelativePath(SourcePath sourcePath) {\n    Path toReturn = getPathPrivateImpl(sourcePath);\n    Preconditions.checkState(\n        !toReturn.isAbsolute(),\n        \"Expected path to be relative, not absolute: %s (from %s)\",\n        toReturn,\n        sourcePath);\n    return toReturn;\n  }\n  /**\n   * @return The {@link Path} the {@code sourcePath} refers to, ideally relative to its owning\n   *     {@link ProjectFilesystem}. Absolute path may get returned however!\n   *     <p>We should make sure that {@link #getPathPrivateImpl} always returns a relative path\n   *     after which we should simply call {@link #getRelativePath}. Until then we still need this\n   *     nonsense.\n   */\n  @Override\n  public Path getIdeallyRelativePath(SourcePath sourcePath) {\n    return getPathPrivateImpl(sourcePath);\n  }\n  /**\n   * @return the {@link SourcePath} as a {@link Path}, with no guarantee whether the return value is\n   *     absolute or relative. This should never be exposed to users.\n   */\n  private Path getPathPrivateImpl(SourcePath sourcePath) {\n    if (sourcePath instanceof PathSourcePath) {\n      return ((PathSourcePath) sourcePath).getRelativePath();\n    } else if (sourcePath instanceof ExplicitBuildTargetSourcePath) {\n      return ((ExplicitBuildTargetSourcePath) sourcePath).getResolvedPath();\n    } else if (sourcePath instanceof ForwardingBuildTargetSourcePath) {\n      return getPathPrivateImpl(((ForwardingBuildTargetSourcePath) sourcePath).getDelegate());\n    } else if (sourcePath instanceof DefaultBuildTargetSourcePath) {\n      DefaultBuildTargetSourcePath targetSourcePath = (DefaultBuildTargetSourcePath) sourcePath;\n      SourcePath path = resolveDefaultBuildTargetSourcePath(targetSourcePath);\n      return getPathPrivateImpl(path);\n    } else {\n      throw new UnsupportedOperationException(sourcePath.getClass() + \" is not supported here!\");\n    }\n  }\n  /**\n   * Resolved the logical names for a group of SourcePath objects into a map, throwing an error on\n   * duplicates.\n   */\n  @Override\n  public ImmutableMap<String, SourcePath> getSourcePathNames(\n      BuildTarget target, String parameter, Iterable<SourcePath> sourcePaths) {\n    return getSourcePathNames(target, parameter, sourcePaths, x -> true, x -> x);\n  }\n  /**\n   * Resolves the logical names for a group of objects that have a SourcePath into a map, throwing\n   * an error on duplicates.\n   */\n  @Override\n  public <T> ImmutableMap<String, T> getSourcePathNames(\n      BuildTarget target,\n      String parameter,\n      Iterable<T> objects,\n      Predicate<T> filter,\n      Function<T, SourcePath> objectSourcePathFunction) {\n    Map<String, T> resolved = new LinkedHashMap<>();\n    for (T object : objects) {\n      if (filter.test(object)) {\n        SourcePath path = objectSourcePathFunction.apply(object);\n        String name = getSourcePathName(target, path);\n        T old = resolved.put(name, object);\n        if (old != null) {\n          throw new HumanReadableException(\n              String.format(\n                  \"%s: parameter '%s': duplicate entries for '%s'\", target, parameter, name));\n        }\n      }\n    }<fim_middle>// function below has no smell\n"}