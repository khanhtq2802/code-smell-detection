{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.olingo.netty.server.core;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.Channel;\nimport java.nio.channels.Channels;\nimport java.nio.channels.ReadableByteChannel;\nimport java.nio.channels.WritableByteChannel;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport org.apache.olingo.commons.api.ex.ODataRuntimeException;\nimport org.apache.olingo.commons.api.http.HttpHeader;\nimport org.apache.olingo.commons.api.http.HttpMethod;\nimport org.apache.olingo.netty.server.api.ODataNettyHandler;\nimport org.apache.olingo.server.api.OData;\nimport org.apache.olingo.server.api.ODataContent;\nimport org.apache.olingo.server.api.ODataLibraryException;\nimport org.apache.olingo.server.api.ODataRequest;\nimport org.apache.olingo.server.api.ODataResponse;\nimport org.apache.olingo.server.api.ODataServerError;\nimport org.apache.olingo.server.api.ServiceMetadata;\nimport org.apache.olingo.server.api.processor.Processor;\nimport org.apache.olingo.server.core.ODataExceptionHelper;\nimport org.apache.olingo.server.core.ODataHandlerException;\nimport org.apache.olingo.server.core.ODataHandlerImpl;\nimport org.apache.olingo.server.core.debug.ServerCoreDebugger;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufInputStream;\nimport io.netty.buffer.ByteBufOutputStream;\nimport io.netty.handler.codec.http.HttpContent;\nimport io.netty.handler.codec.http.HttpMessage;\nimport io.netty.handler.codec.http.HttpRequest;\nimport io.netty.handler.codec.http.HttpResponse;\nimport io.netty.handler.codec.http.HttpResponseStatus;\npublic class ODataNettyHandlerImpl implements ODataNettyHandler {\n  public static final int COPY_BUFFER_SIZE = 8192;\n  private final ODataHandlerImpl handler;\n  private final ServerCoreDebugger debugger;\n  private static final String CONTEXT_PATH = \"contextPath\";\n  private static final String SPLIT = \"split\";\n  private int split = 0;\n  public ODataNettyHandlerImpl(final OData odata, final ServiceMetadata serviceMetadata) {\n    debugger = new ServerCoreDebugger(odata);\n    handler = new ODataHandlerImpl(odata, serviceMetadata, debugger);\n  }\n  private ODataResponse handleException(final ODataRequest odRequest, final Exception e) {\n    ODataResponse resp = new ODataResponse();\n    ODataServerError serverError;\n    if (e instanceof ODataHandlerException) {\n      serverError = ODataExceptionHelper.createServerErrorObject((ODataHandlerException) e, null);\n    } else if (e instanceof ODataLibraryException) {\n      serverError = ODataExceptionHelper.createServerErrorObject((ODataLibraryException) e, null);\n    } else {\n      serverError = ODataExceptionHelper.createServerErrorObject(e);\n    }\n    handler.handleException(odRequest, resp, serverError, e);\n    return resp;\n  }\n  /**\n   * Convert the OData Response to Netty Response\n   * @param response\n   * @param odResponse\n   */\n  static void convertToHttp(final HttpResponse response, final ODataResponse odResponse) {\n\t    response.setStatus(HttpResponseStatus.valueOf(odResponse.getStatusCode()));\n\t    for (Entry<String, List<String>> entry : odResponse.getAllHeaders().entrySet()) {\n\t      for (String headerValue : entry.getValue()) {\n\t        ((HttpMessage)response).headers().add(entry.getKey(), headerValue);\n\t      }\n\t    }\n\t    if (odResponse.getContent() != null) {\n\t      copyContent(odResponse.getContent(), response);\n\t    } else if (odResponse.getODataContent() != null) {\n\t      writeContent(odResponse, response);\n\t    }\n\t  }\n  /**\n   * Write the odata content to netty response content\n   * @param odataResponse\n   * @param response\n   */\n  static void writeContent(final ODataResponse odataResponse, final HttpResponse response) {\n    ODataContent res = odataResponse.getODataContent();\n    res.write(Channels.newChannel(new ByteBufOutputStream(((HttpContent)response).content())));\n  }\n  static void copyContent(final InputStream inputStream, final HttpResponse response) {\n\t    copyContent(Channels.newChannel(inputStream), response);\n\t  }\n  /** \n   * Copy OData content to netty content\n   * @param input\n   * @param response\n   */\n  static void copyContent(final ReadableByteChannel input, final HttpResponse response) {\n    WritableByteChannel output = null;\n    try {\n      ByteBuffer inBuffer = ByteBuffer.allocate(COPY_BUFFER_SIZE);\n      output = Channels.newChannel(new ByteBufOutputStream(((HttpContent)response).content()));\n      while (input.read(inBuffer) > 0) {\n        inBuffer.flip();\n        output.write(inBuffer);\n        inBuffer.clear();\n      }\n    } catch (IOException e) {\n      throw new ODataRuntimeException(\"Error on reading request content\", e);\n    } finally {\n      closeStream(input);\n      closeStream(output);\n    }\n  }\n<fim_suffix>  private static void closeStream(final Channel closeable) {\n    if (closeable != null) {\n      try {\n        closeable.close();\n      } catch (IOException e) {\n        // ignore\n      }\n    }\n  }\n  /**\n   * Extract the information part of Netty Request and fill OData Request\n   * @param odRequest\n   * @param httpRequest\n   * @param split\n   * @param contextPath\n   * @return\n   * @throws ODataLibraryException\n   */\n  private ODataRequest fillODataRequest(final ODataRequest odRequest, final HttpRequest httpRequest,\n\t      final int split, final String contextPath) throws ODataLibraryException {\n\t    final int requestHandle = debugger.startRuntimeMeasurement(\"ODataHttpHandlerImpl\", \"fillODataRequest\");\n\t    try {\n\t    \tByteBuf byteBuf = ((HttpContent)httpRequest).content();\n\t    \tByteBufInputStream inputStream = new ByteBufInputStream(byteBuf);\n\t      odRequest.setBody(inputStream);\n\t      odRequest.setProtocol(httpRequest.protocolVersion().text());\n\t      odRequest.setMethod(extractMethod(httpRequest));\n\t      int innerHandle = debugger.startRuntimeMeasurement(\"ODataNettyHandlerImpl\", \"copyHeaders\");\n\t      copyHeaders(odRequest, httpRequest);\n\t      debugger.stopRuntimeMeasurement(innerHandle);\n\t      innerHandle = debugger.startRuntimeMeasurement(\"ODataNettyHandlerImpl\", \"fillUriInformation\");\n\t      fillUriInformationFromHttpRequest(odRequest, httpRequest, split, contextPath);\n\t      debugger.stopRuntimeMeasurement(innerHandle);\n\t      return odRequest;\n\t    } finally {\n\t      debugger.stopRuntimeMeasurement(requestHandle);\n\t    }\n\t  }\n  static HttpMethod extractMethod(final HttpRequest httpRequest) throws ODataLibraryException {\n    final HttpMethod httpRequestMethod;\n    \ttry {\n    \t      httpRequestMethod = HttpMethod.valueOf(httpRequest.method().name());\n    \t    } catch (IllegalArgumentException e) {\n    \t      throw new ODataHandlerException(\"HTTP method not allowed\" + \n    \t    httpRequest.method().name(), e,\n    \t          ODataHandlerException.MessageKeys.HTTP_METHOD_NOT_ALLOWED, \n    \t          httpRequest.method().name());\n    \t    }\n    \ttry {\n  \t      if (httpRequestMethod == HttpMethod.POST) {\n  \t        String xHttpMethod = httpRequest.headers().\n  \t        \t\tget(HttpHeader.X_HTTP_METHOD);\n  \t        String xHttpMethodOverride = httpRequest.headers().\n  \t        \t\tget(HttpHeader.X_HTTP_METHOD_OVERRIDE);\n  \t        if (xHttpMethod == null && xHttpMethodOverride == null) {\n  \t          return httpRequestMethod;\n  \t        } else if (xHttpMethod == null) {\n  \t          return HttpMethod.valueOf(xHttpMethodOverride);\n  \t        } else if (xHttpMethodOverride == null) {\n  \t          return HttpMethod.valueOf(xHttpMethod);\n  \t        } else {\n  \t          if (!xHttpMethod.equalsIgnoreCase(xHttpMethodOverride)) {\n  \t            throw new ODataHandlerException(\"Ambiguous X-HTTP-Methods\",<fim_middle>// function below has no smell\n"}