{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with this\n * work for additional information regarding copyright ownership.  The ASF\n * licenses this file to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * <p>\n * http://www.apache.org/licenses/LICENSE-2.0\n * <p>\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n\npackage org.apache.hadoop.ozone.lease;\n\nimport org.apache.hadoop.util.Time;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.concurrent.Callable;\n\n/**\n * This class represents the lease created on a resource. Callback can be\n * registered on the lease which will be executed in case of timeout.\n *\n * @param <T> Resource type for which the lease can be associated\n */\n<fim_suffix>public class Lease<T> {\n\n  /**\n   * The resource for which this lease is created.\n   */\n  private final T resource;\n\n  private final long creationTime;\n\n  /**\n   * Lease lifetime in milliseconds.\n   */\n  private volatile long leaseTimeout;\n\n  private boolean expired;\n\n  /**\n   * Functions to be called in case of timeout.\n   */\n  private List<Callable<Void>> callbacks;\n\n\n  /**\n   * Creates a lease on the specified resource with given timeout.\n   *\n   * @param resource\n   *        Resource for which the lease has to be created\n   * @param timeout\n   *        Lease lifetime in milliseconds\n   */\n  public Lease(T resource, long timeout) {\n    this.resource = resource;\n    this.leaseTimeout = timeout;\n    this.callbacks = Collections.synchronizedList(new ArrayList<>());\n    this.creationTime = Time.monotonicNow();\n    this.expired = false;\n  }\n\n  /**\n   * Returns true if the lease has expired, else false.\n   *\n   * @return true if expired, else false\n   */\n  public boolean hasExpired() {\n    return expired;\n  }\n\n  /**\n   * Registers a callback which will be executed in case of timeout. Callbacks\n   * are executed in a separate Thread.\n   *\n   * @param callback\n   *        The Callable which has to be executed\n   * @throws LeaseExpiredException\n   *         If the lease has already timed out\n   */\n  public void registerCallBack(Callable<Void> callback)\n      throws LeaseExpiredException {\n    if(hasExpired()) {\n      throw new LeaseExpiredException(\"Resource: \" + resource);\n    }\n    callbacks.add(callback);\n  }\n\n  /**\n   * Returns the time elapsed since the creation of lease.\n   *\n   * @return elapsed time in milliseconds\n   * @throws LeaseExpiredException\n   *         If the lease has already timed out\n   */\n  public long getElapsedTime() throws LeaseExpiredException {\n    if(hasExpired()) {\n      throw new LeaseExpiredException(\"Resource: \" + resource);\n    }\n    return Time.monotonicNow() - creationTime;\n  }\n\n  /**\n   * Returns the time available before timeout.\n   *\n   * @return remaining time in milliseconds\n   * @throws LeaseExpiredException\n   *         If the lease has already timed out\n   */\n  public long getRemainingTime() throws LeaseExpiredException {\n    if(hasExpired()) {\n      throw new LeaseExpiredException(\"Resource: \" + resource);\n    }\n    return leaseTimeout - getElapsedTime();\n  }\n\n  /**\n   * Returns total lease lifetime.\n   *\n   * @return total lifetime of lease in milliseconds\n   * @throws LeaseExpiredException\n   *         If the lease has already timed out\n   */\n  public long getLeaseLifeTime() throws LeaseExpiredException {\n    if(hasExpired()) {\n      throw new LeaseExpiredException(\"Resource: \" + resource);\n    }\n    return leaseTimeout;\n  }\n\n  /**\n   * Renews the lease timeout period.\n   *\n   * @param timeout\n   *        Time to be added to the lease in milliseconds\n   * @throws LeaseExpiredException\n   *         If the lease has already timed out\n   */\n  public void renew(long timeout) throws LeaseExpiredException {\n    if(hasExpired()) {\n      throw new LeaseExpiredException(\"Resource: \" + resource);\n    }\n    leaseTimeout += timeout;\n  }\n\n  @Override\n  public int hashCode() {\n    return resource.hashCode();\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if(obj instanceof Lease) {\n      return resource.equals(((Lease) obj).resource);\n    }\n    return false;\n  }\n\n  @Override\n  public String toString() {\n    return \"Lease<\" + resource.toString() + \">\";\n  }\n\n  /**\n   * Returns the callbacks to be executed for the lease in case of timeout.\n   *\n   * @return callbacks to be executed\n   */\n  List<Callable<Void>> getCallbacks() {\n    return callbacks;\n  }\n\n  /**\n   * Expires/Invalidates the lease.\n   */\n  void invalidate() {\n    callbacks = null;\n    expired = true;\n  }\n\n}<fim_middle>// class below has no smell\n"}