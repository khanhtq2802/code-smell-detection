{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.activemq.artemis.core.protocol.stomp;\n\nimport java.nio.charset.StandardCharsets;\nimport java.util.Arrays;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\nimport org.apache.activemq.artemis.api.core.ActiveMQBuffer;\nimport org.apache.activemq.artemis.api.core.ActiveMQBuffers;\nimport org.apache.activemq.artemis.core.protocol.stomp.v10.StompFrameV10;\n\n/**\n * Represents all the data in a STOMP frame.\n */\npublic class StompFrame {\n\n   protected static final byte[] END_OF_FRAME = new byte[]{0, '\\n'};\n\n   protected final String command;\n\n   protected Map<String, String> headers;\n\n   private String body;\n\n   protected byte[] bytesBody;\n\n   protected ActiveMQBuffer buffer = null;\n\n   protected int size;\n\n   private boolean disconnect;\n\n   private boolean isPing;\n\n   public StompFrame(String command) {\n      this(command, false);\n   }\n\n   public StompFrame(String command, boolean disconnect) {\n      this.command = command;\n      this.headers = new LinkedHashMap<>();\n      this.disconnect = disconnect;\n   }\n\n   public StompFrame(String command, Map<String, String> headers, byte[] content) {\n      this.command = command;\n      this.headers = headers;\n      this.bytesBody = content;\n   }\n\n   public String getCommand() {\n      return command;\n   }\n\n   public int getEncodedSize() throws Exception {\n      if (buffer == null) {\n         buffer = toActiveMQBuffer();\n      }\n      return size;\n   }\n\n   @Override\n   public String toString() {\n      return new StringBuilder()\n         .append(\"StompFrame[command=\").append(command)\n         .append(\", headers=\").append(headers)\n         .append(\", content= \").append(this.body)\n         .append(\", bytes= \").append(Arrays.toString(bytesBody))\n         .toString();\n   }\n\n   public boolean isPing() {\n      return isPing;\n   }\n\n   public void setPing(boolean ping) {\n      isPing = ping;\n   }\n\n   public ActiveMQBuffer toActiveMQBuffer() throws Exception {\n      if (buffer == null) {\n         if (isPing()) {\n            buffer = ActiveMQBuffers.fixedBuffer(1);\n            buffer.writeByte((byte) 10);\n            size = buffer.writerIndex();\n            return buffer;\n         }\n\n         StringBuilder head = new StringBuilder(512);\n         head.append(command);\n         head.append(Stomp.NEWLINE);\n         // Output the headers.\n         encodeHeaders(head);\n         if (bytesBody != null && bytesBody.length > 0 && !hasHeader(Stomp.Headers.CONTENT_LENGTH) && !(this instanceof StompFrameV10)) {\n            head.append(Stomp.Headers.CONTENT_LENGTH);\n            head.append(Stomp.Headers.SEPARATOR);\n            head.append(bytesBody.length);\n            head.append(Stomp.NEWLINE);\n         }\n         // Add a newline to separate the headers from the content.\n         head.append(Stomp.NEWLINE);\n\n         byte[] headBytes = head.toString().getBytes(StandardCharsets.UTF_8);\n         int bodyLength = (bytesBody == null) ? 0 : bytesBody.length;\n\n         buffer = ActiveMQBuffers.fixedBuffer(headBytes.length + bodyLength + END_OF_FRAME.length);\n\n         buffer.writeBytes(headBytes);\n         if (bytesBody != null) {\n            buffer.writeBytes(bytesBody);\n         }\n         buffer.writeBytes(END_OF_FRAME);\n\n         size = buffer.writerIndex();\n      } else {\n         buffer.readerIndex(0);\n      }\n      return buffer;\n   }\n\n   protected void encodeHeaders(StringBuilder head) {\n      for (Map.Entry<String, String> header : headers.entrySet()) {\n         head.append(header.getKey());\n         head.append(Stomp.Headers.SEPARATOR);\n         head.append(header.getValue());\n         head.append(Stomp.NEWLINE);\n      }\n   }\n\n   public String getHeader(String key) {\n      return headers.get(key);\n   }\n\n   public void addHeader(String key, String val) {\n      headers.put(key, val);\n   }\n\n   public Map<String, String> getHeadersMap() {\n      return headers;\n   }\n\n<fim_suffix>   public class Header {\n\n      public String key;\n      public String val;\n\n      public Header(String key, String val) {\n         this.key = key;\n         this.val = val;\n      }\n\n      public String getEncodedKey() {\n         return encode(key);\n      }\n\n      public String getEncodedValue() {\n         return encode(val);\n      }\n   }\n\n   public String encode(String str) {\n      if (str == null) {\n         return \"\";\n      }\n\n      int len = str.length();\n\n      char[] buffer = new char[2 * len];\n      int iBuffer = 0;\n      for (int i = 0; i < len; i++) {\n         char c = str.charAt(i);\n\n         // \\n\n         if (c == (byte) 10) {\n            buffer[iBuffer] = (byte) 92;\n            buffer[++iBuffer] = (byte) 110;\n         } else if (c == (byte) 13) { // \\r\n            buffer[iBuffer] = (byte) 92;\n            buffer[++iBuffer] = (byte) 114;\n         } else if (c == (byte) 92) { // \\\n\n            buffer[iBuffer] = (byte) 92;\n            buffer[++iBuffer] = (byte) 92;\n         } else if (c == (byte) 58) { // :\n            buffer[iBuffer] = (byte) 92;\n            buffer[++iBuffer] = (byte) 99;\n         } else {\n            buffer[iBuffer] = c;\n         }\n         iBuffer++;\n      }\n\n      return new String(buffer, 0, iBuffer);\n   }\n\n   public void setBody(String body) {\n      this.body = body;\n      this.bytesBody = body.getBytes(StandardCharsets.UTF_8);\n   }\n\n   public boolean hasHeader(String key) {\n      return headers.containsKey(key);\n   }\n\n   public String getBody() {\n      if (body == null) {\n         if (bytesBody != null) {\n            body = new String(bytesBody, StandardCharsets.UTF_8);\n         }\n      }\n      return body;\n   }\n\n   //Since 1.1, there is a content-type header that needs to take care of\n   public byte[] getBodyAsBytes() {\n      return bytesBody;\n   }\n\n   public boolean needsDisconnect() {\n      return disconnect;\n   }\n\n   public void setByteBody(byte[] content) {\n      this.bytesBody = content;\n   }\n\n   public void setNeedsDisconnect(boolean b) {\n      disconnect = b;\n   }\n}<fim_middle>// class below is data class\n"}