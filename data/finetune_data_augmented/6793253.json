{"text": "<fim_prefix>      return new Iterator<Node>() {\n        @Override\n        public boolean hasNext() {\n          return cur != null;\n        }\n        @Override\n        public Node next() {\n          if (!hasNext()) {\n            throw new NoSuchElementException();\n          }\n          Node n = cur;\n          cur = cur.getParent();\n          return n;\n        }\n        @Override\n        public void remove() {\n          throw new UnsupportedOperationException();\n        }\n      };\n    }\n  }\n  /**\n   * Check for one child more efficiently than by iterating over all the\n   * children as is done with Node.getChildCount().\n   *\n   * @return Whether the node has exactly one child.\n   */\n  public final boolean hasOneChild() {\n    return first != null && first.next == null;\n  }\n  /**\n   * Check for two children more efficiently than {@code getChildCount() == 2}\n   *\n   * @return Whether the node has exactly two children.\n   */\n  public final boolean hasTwoChildren() {\n    return first != null && first.next != null && first.next == getLastChild();\n  }\n  /**\n   * Check for zero or one child more efficiently than by iterating over all the\n   * children as is done with Node.getChildCount().\n   *\n   * @return Whether the node has no children or exactly one child.\n   */\n  public final boolean hasZeroOrOneChild() {\n    return first == getLastChild();\n  }\n  /**\n   * Check for more than one child more efficiently than by iterating over all\n   * the children as is done with Node.getChildCount().\n   *\n   * @return Whether the node more than one child.\n   */\n  public final boolean hasMoreThanOneChild() {\n    return first != null && first.next != null;\n  }\n  /**\n   * Check for has exactly the number of specified children.\n   *\n   * @return Whether the node has exactly the number of children specified.\n   */\n  public final boolean hasXChildren(int x) {\n    int c = 0;\n    for (Node n = first; n != null && c <= x; n = n.next) {\n      c++;\n    }\n    return c == x;\n  }\n  public final int getChildCount() {\n    int c = 0;\n    for (Node n = first; n != null; n = n.next) {\n      c++;\n    }\n    return c;\n  }\n  // Intended for testing and verification only.\n  public final boolean hasChild(Node child) {\n    for (Node n = first; n != null; n = n.next) {\n      if (child == n) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /** Checks equivalence without going into child nodes */\n  public final boolean isEquivalentToShallow(Node node) {\n    return isEquivalentTo(node, false, false, false, false);\n  }\n  /** Returns true if this node is equivalent semantically to another including side effects. */\n  public final boolean isEquivalentWithSideEffectsTo(Node node) {\n    return isEquivalentTo(node, false, true, false, true);\n  }\n  /** Returns true if this node is equivalent semantically to another including side effects. */\n  public final boolean isEquivalentWithSideEffectsToShallow(Node node) {\n    return isEquivalentTo(node, false, false, false, true);\n  }\n  /**\n   * Returns true if this node is equivalent semantically to another and the types are equivalent.\n   */\n  public final boolean isEquivalentToTyped(Node node) {\n    return isEquivalentTo(node, true, true, true, false);\n  }\n  /** Returns true if this node is equivalent semantically to another */\n  public final boolean isEquivalentTo(Node node) {\n    return isEquivalentTo(node, false, true, false, false);\n  }\n  /**\n   * @param compareType Whether to compare the JSTypes of the nodes.\n   * @param recurse Whether to compare the children of the current node. If not, only the count of\n   *     the children are compared.\n   * @param jsDoc Whether to check that the JsDoc of the nodes are equivalent.\n   * @return Whether this node is equivalent semantically to the provided node.\n   */\n  final boolean isEquivalentTo(Node node, boolean compareType, boolean recurse, boolean jsDoc) {\n    return isEquivalentTo(node, compareType, recurse, jsDoc, false);\n  }\n  /**\n   * @param compareType Whether to compare the JSTypes of the nodes.\n   * @param recurse Whether to compare the children of the current node. If not, only the count\n   *     of the children are compared.\n   * @param jsDoc Whether to check that the JsDoc of the nodes are equivalent.\n   * @param sideEffect Whether to check that the side-effect flags of the nodes are equivalent.\n   * @return Whether this node is equivalent semantically to the provided node.\n   */\n  public boolean isEquivalentTo(\n      Node node, boolean compareType, boolean recurse, boolean jsDoc, boolean sideEffect) {\n    if (token != node.token\n        || getChildCount() != node.getChildCount()\n        || this.getClass() != node.getClass()) {\n      return false;\n    }\n    if (compareType && !JSType.isEquivalent(getJSType(), node.getJSType())) {\n      return false;\n    }\n    if (jsDoc && !JSDocInfo.areEquivalent(getJSDocInfo(), node.getJSDocInfo())) {\n      return false;\n    }\n    TypeDeclarationNode thisTDN = this.getDeclaredTypeExpression();\n    TypeDeclarationNode thatTDN = node.getDeclaredTypeExpression();\n    if ((thisTDN != null || thatTDN != null)\n        && (thisTDN == null\n            || thatTDN == null\n            || !thisTDN.isEquivalentTo(thatTDN, compareType, recurse, jsDoc))) {\n      return false;\n    }\n    if (token == Token.INC || token == Token.DEC) {\n      int post1 = this.getIntProp(Prop.INCRDECR);\n      int post2 = node.getIntProp(Prop.INCRDECR);\n      if (post1 != post2) {\n        return false;\n      }\n    } else if (token == Token.STRING || token == Token.STRING_KEY) {\n      if (token == Token.STRING_KEY) {\n        int quoted1 = this.getIntProp(Prop.QUOTED);\n        int quoted2 = node.getIntProp(Prop.QUOTED);\n        if (quoted1 != quoted2) {\n          return false;\n        }\n      }\n      int slashV1 = this.getIntProp(Prop.SLASH_V);\n      int slashV2 = node.getIntProp(Prop.SLASH_V);\n      if (slashV1 != slashV2) {\n        return false;\n      }\n    } else if (token == Token.CALL) {\n      if (this.getBooleanProp(Prop.FREE_CALL) != node.getBooleanProp(Prop.FREE_CALL)) {\n        return false;\n      }\n    } else if (token == Token.FUNCTION) {\n      // Must be the same kind of function to be equivalent\n      if (this.isArrowFunction() != node.isArrowFunction()) {\n        return false;\n      }\n      if (this.isGeneratorFunction() != node.isGeneratorFunction()) {\n        return false;\n      }\n      if (this.isAsyncFunction() != node.isAsyncFunction()) {\n        return false;\n      }\n    }\n    if (sideEffect) {\n      if (this.getSideEffectFlags() != node.getSideEffectFlags()) {\n        return false;\n      }\n      if (this.isUnusedParameter() != node.isUnusedParameter()) {\n        return false;\n      }\n    }\n    if (recurse) {\n      for (Node n = first, n2 = node.first;\n           n != null;\n           n = n.next, n2 = n2.next) {\n        if (!n.isEquivalentTo(n2, compareType, recurse, jsDoc, sideEffect)) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  /**\n   * This function takes a set of GETPROP nodes and produces a string that is each property\n   * separated by dots. If the node ultimately under the left sub-tree is not a simple name, this is\n   * not a valid qualified name.\n   *\n   * @return a null if this is not a qualified name, or a dot-separated string of the name and\n   *     properties.\n   */\n  @Nullable\n  public final String getQualifiedName() {\n    switch (token) {\n      case NAME:\n        String name = getString();\n        return name.isEmpty() ? null : name;\n      case GETPROP:\n        StringBuilder builder = getQualifiedNameForGetProp(0);\n        return builder != null ? builder.toString() : null;\n      case THIS:\n        return \"this\";\n      case SUPER:\n        return \"super\";\n      default:\n        return null;\n    }\n  }\n<fim_suffix>  @Nullable\n  public final QualifiedName getQualifiedNameObject() {\n    return isQualifiedName() ? new QualifiedName.NodeQname(this) : null;\n  }<fim_middle>// function below has no smell\n"}