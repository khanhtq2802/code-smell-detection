{"text": "<fim_prefix>/*******************************************************************************\n * Copyright (c) 2007 - 2013 Spring IDE Developers\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     Spring IDE Developers - initial API and implementation\n *******************************************************************************/\npackage org.springframework.ide.eclipse.core.java;\n\nimport java.io.IOException;\nimport java.lang.reflect.Method;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.eclipse.core.runtime.FileLocator;\nimport org.springframework.util.Assert;\nimport org.springframework.util.ReflectionUtils;\nimport org.springframework.util.StringUtils;\n\n/**\n * Utility class that provides several helper methods for working with java\n * reflect components.\n * @author Christian Dupuis\n * @author Leo Dos Santos\n * @since 2.0\n */\npublic class ClassUtils {\n\n\tpublic static final String CLASS_FILE_SUFFIX = \".class\";\n\n\tpublic static String getClassFileName(String className) {\n\t\tclassName = StringUtils.replace(className, \".\", \"/\");\n\t\treturn className + CLASS_FILE_SUFFIX;\n\t}\n\n\tpublic static String getClassLoaderHierachy(Class clazz) {\n\t\tClassLoader cls = clazz.getClassLoader();\n\t\tStringBuffer buf = new StringBuffer(cls.getClass().getName());\n\t\twhile (cls.getParent() != null) {\n\t\t\tcls = cls.getParent();\n\t\t\tbuf.append(\" -> \");\n\t\t\tbuf.append(cls.getClass().getName());\n\t\t}\n\t\treturn buf.toString();\n\t}\n\n\tpublic static String getClassLocation(Class clazz) {\n\t\tAssert.notNull(clazz);\n\t\tString resourceName = org.springframework.util.ClassUtils\n\t\t\t\t.getClassFileName(clazz);\n\t\tString location = null;\n\t\ttry {\n\t\t\tURL url = clazz.getResource(resourceName);\n\t\t\tif (url != null) {\n\t\t\t\tURL nativeUrl = FileLocator.resolve(url);\n\t\t\t\tif (nativeUrl != null) {\n\t\t\t\t\tlocation = nativeUrl.getFile();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IOException e) {\n\t\t}\n\n\t\tif (location != null) {\n\t\t\t// remove path behind jar file\n\t\t\tint ix = location.lastIndexOf('!');\n\t\t\tlocation = location.substring(0, ix);\n\t\t}\n\n\t\treturn location;\n\t}\n\n<fim_suffix>\tpublic static String getClassVersion(Class clazz) {\n\t\tString version = \"unkown\";\n\t\tif (clazz.getPackage().getImplementationVersion() != null) {\n\t\t\tversion = clazz.getPackage().getImplementationVersion();\n\t\t}\n\t\treturn version;\n\t}\n\n\tpublic static Object invokeMethod(Object target, String methodName,\n\t\t\tObject... parameters) throws Throwable {\n\n\t\tif (target == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (parameters != null && parameters.length > 0) {\n\t\t\tList<Object> parameterClasses = new ArrayList<Object>();\n\t\t\tfor (Object parameter : parameters) {\n\t\t\t\tparameterClasses.add(parameter.getClass());\n\t\t\t}\n\t\t\treturn invokeMethod(target, methodName, parameters, \n\t\t\t\t\tparameterClasses.toArray(new Class[parameterClasses.size()]));\n\t\t}\n\t\telse {\n\t\t\treturn invokeMethod(target, methodName, parameters, new Class[0]);\n\t\t}\n\t}\n\n\t/**\n\t * Invokes a target method identified by given <code>methodName</code>,\n\t * <code>parameters</code> and <code>parameterClasses</code>.\n\t * <p>\n\t * If the <code>target</code> is an instance of {@link Class} this method\n\t * assumes that the invocation should be made statically.\n\t * <p>\n\t * Note: This method - in contrast to the\n\t * {@link #invokeMethod(Object, String, Object...)} method - does support\n\t * primitive types as parameter types.\n\t * @since 2.0.1\n\t */\n\tpublic static Object invokeMethod(Object target, String methodName,\n\t\t\tObject[] parameters, Class[] parameterClasses) throws Throwable {\n\n\t\tif (target == null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tClass targetClass = target.getClass();\n\t\tif (target instanceof Class) {\n\t\t\ttargetClass = (Class) target;\n\t\t}\n\t\tMethod targetMethod = ReflectionUtils.findMethod(targetClass, \n\t\t\t\tmethodName, parameterClasses);\n\n\t\tif (targetMethod != null) {\n\t\t\tReflectionUtils.makeAccessible(targetMethod);\n\t\t\tif (target instanceof Class) {\n\t\t\t\treturn ReflectionUtils.invokeMethod(targetMethod, null, parameters);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn ReflectionUtils.invokeMethod(targetMethod, target, parameters);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\n\t}\n\n\tpublic static Class<?> loadClass(String className)\n\t\t\tthrows ClassNotFoundException {\n\t\tClassLoader loader = Thread.currentThread().getContextClassLoader();\n\t\treturn loadClass(className, loader);\n\t}\n\n\tpublic static Class<?> loadClass(Class clazz) throws ClassNotFoundException {\n\t\treturn loadClass(clazz.getName());\n\t}\n\t\n\tpublic static Class<?> loadClass(String className, ClassLoader loader) throws ClassNotFoundException {\n\t\ttry {\n\t\t\treturn loader.loadClass(className);\n\t\t}\n\t\tcatch (ClassNotFoundException ex) {\n\t\t\tint lastDotIndex = className.lastIndexOf('.');\n\t\t\tif (lastDotIndex != -1) {\n\t\t\t\tString innerClassName = className.substring(0, lastDotIndex) + '$' + className.substring(lastDotIndex + 1);\n\t\t\t\ttry {\n\t\t\t\t\treturn loader.loadClass(innerClassName);\n\t\t\t\t}\n\t\t\t\tcatch (ClassNotFoundException ex2) {\n\t\t\t\t\t// swallow - let original exception get through\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow ex;\n\t\t}\n\t}\n\t\n}<fim_middle>// function below has no smell\n"}