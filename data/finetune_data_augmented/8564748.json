{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.hadoop.hbase.client.coprocessor;\n\nimport com.google.protobuf.ByteString;\nimport com.google.protobuf.Message;\n\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\n\nimport org.apache.hadoop.hbase.HConstants;\nimport org.apache.hadoop.hbase.client.Scan;\nimport org.apache.hadoop.hbase.coprocessor.ColumnInterpreter;\nimport org.apache.hadoop.hbase.protobuf.ProtobufUtil;\nimport org.apache.hadoop.hbase.protobuf.generated.AggregateProtos.AggregateRequest;\nimport org.apache.hadoop.hbase.util.Bytes;\nimport org.apache.yetus.audience.InterfaceAudience;\n\n/**\n * Helper class for constructing aggregation request and response.\n */\n<fim_suffix>@InterfaceAudience.Private\npublic final class AggregationHelper {\n  private AggregationHelper() {}\n\n  /**\n   * @param scan the HBase scan object to use to read data from HBase\n   * @param canFamilyBeAbsent whether column family can be absent in familyMap of scan\n   */\n  private static void validateParameters(Scan scan, boolean canFamilyBeAbsent) throws IOException {\n    if (scan == null\n        || (Bytes.equals(scan.getStartRow(), scan.getStopRow())\n            && !Bytes.equals(scan.getStartRow(), HConstants.EMPTY_START_ROW))\n        || ((Bytes.compareTo(scan.getStartRow(), scan.getStopRow()) > 0)\n            && !Bytes.equals(scan.getStopRow(), HConstants.EMPTY_END_ROW))) {\n      throw new IOException(\"Agg client Exception: Startrow should be smaller than Stoprow\");\n    } else if (!canFamilyBeAbsent) {\n      if (scan.getFamilyMap().size() != 1) {\n        throw new IOException(\"There must be only one family.\");\n      }\n    }\n  }\n\n  static <R, S, P extends Message, Q extends Message, T extends Message> AggregateRequest\n      validateArgAndGetPB(Scan scan, ColumnInterpreter<R, S, P, Q, T> ci, boolean canFamilyBeAbsent)\n          throws IOException {\n    validateParameters(scan, canFamilyBeAbsent);\n    final AggregateRequest.Builder requestBuilder = AggregateRequest.newBuilder();\n    requestBuilder.setInterpreterClassName(ci.getClass().getCanonicalName());\n    P columnInterpreterSpecificData = ci.getRequestData();\n    if (columnInterpreterSpecificData != null) {\n      requestBuilder.setInterpreterSpecificBytes(columnInterpreterSpecificData.toByteString());\n    }\n    requestBuilder.setScan(ProtobufUtil.toScan(scan));\n    return requestBuilder.build();\n  }\n\n  /**\n   * Get an instance of the argument type declared in a class's signature. The argument type is\n   * assumed to be a PB Message subclass, and the instance is created using parseFrom method on the\n   * passed ByteString.\n   * @param runtimeClass the runtime type of the class\n   * @param position the position of the argument in the class declaration\n   * @param b the ByteString which should be parsed to get the instance created\n   * @return the instance\n   * @throws IOException Either we couldn't instantiate the method object, or \"parseFrom\" failed.\n   */\n  @SuppressWarnings(\"unchecked\")\n  // Used server-side too by Aggregation Coprocesor Endpoint. Undo this interdependence. TODO.\n  public static <T extends Message> T getParsedGenericInstance(Class<?> runtimeClass, int position,\n      ByteString b) throws IOException {\n    Type type = runtimeClass.getGenericSuperclass();\n    Type argType = ((ParameterizedType) type).getActualTypeArguments()[position];\n    Class<T> classType = (Class<T>) argType;\n    T inst;\n    try {\n      Method m = classType.getMethod(\"parseFrom\", ByteString.class);\n      inst = (T) m.invoke(null, b);\n      return inst;\n    } catch (SecurityException e) {\n      throw new IOException(e);\n    } catch (NoSuchMethodException e) {\n      throw new IOException(e);\n    } catch (IllegalArgumentException e) {\n      throw new IOException(e);\n    } catch (InvocationTargetException e) {\n      throw new IOException(e);\n    } catch (IllegalAccessException e) {\n      throw new IOException(e);\n    }\n  }\n}<fim_middle>// class below has no smell\n"}