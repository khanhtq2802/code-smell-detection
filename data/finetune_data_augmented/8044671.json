{"text": "<fim_prefix>/*******************************************************************************\n * Copyright (c) 2011 itemis AG (http://www.itemis.eu) and others.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *******************************************************************************/\npackage org.eclipse.xtext.common.types.xtext.ui;\n\nimport static com.google.common.collect.Sets.*;\n\nimport java.util.List;\nimport java.util.Set;\n\nimport org.eclipse.emf.ecore.EObject;\nimport org.eclipse.emf.ecore.EReference;\nimport org.eclipse.jdt.core.IJavaProject;\nimport org.eclipse.jdt.core.NamingConventions;\nimport org.eclipse.jdt.internal.ui.JavaPlugin;\nimport org.eclipse.jdt.internal.ui.JavaPluginImages;\nimport org.eclipse.jface.viewers.StyledString;\nimport org.eclipse.swt.graphics.Image;\nimport org.eclipse.xtext.common.types.access.jdt.IJavaProjectProvider;\nimport org.eclipse.xtext.nodemodel.INode;\nimport org.eclipse.xtext.nodemodel.util.NodeModelUtils;\n\nimport com.google.inject.Inject;\n\n/**\n * \n * Utilities and Facade to the {@link NamingConventions}.\n * It is not based on a parser (i.e. from XTypes) to allow languages with other syntaxes to use this.\n * \n * @author Sven Efftinge - Initial contribution and API\n * @since 2.1\n */\npublic class JdtVariableCompletions {\n\t\n\tpublic interface CompletionDataAcceptor {\n\t\tvoid accept(String replaceText, StyledString label, Image img);\n\t}\n\t\n\tpublic enum VariableType {\n\t\tINSTANCE_FIELD,\n\t\tPARAMETER,\n\t\tLOCAL_VAR,\n\t\tSTATIC_FIELD\n\t}\n\n\t@Inject\n\tprivate IJavaProjectProvider javaProjectProvider;\n\n\tpublic void getVariableProposals(EObject ctx, EReference refToTypeRef, VariableType varType, Set<String> notAllowedNames, CompletionDataAcceptor acceptor) {\n\t\tString typeName = getTextUnderReference(ctx, refToTypeRef);\n\t\tinternalGetVariableProposals(typeName, ctx, varType, notAllowedNames, acceptor);\n\t}\n\t/**\n\t * @since 2.3\n\t */\n\tpublic void getVariableProposals(String typeName, EObject ctx, VariableType varType,\n\t\t\tSet<String> notAllowedNames, CompletionDataAcceptor acceptor){\n\t\tinternalGetVariableProposals(typeName, ctx, varType, notAllowedNames, acceptor);\n\t}\n\n\tprotected void internalGetVariableProposals(String typeName, EObject ctx, VariableType varType,\n\t\t\tSet<String> notAllowedNames, CompletionDataAcceptor acceptor) {\n\t\tboolean isMany = false;\n\t\tString baseType = null;\n\t\tif (isCollectionType(typeName)) {\n\t\t\tbaseType = getFirstTypeArgumentSimpleName(typeName);\n\t\t\tisMany = true;\n\t\t} else if (isArray(typeName)) {\n\t\t\tbaseType = getArrayComponentTypeSimpleName(typeName);\n\t\t\tisMany = true;\n\t\t} else {\n\t\t\tbaseType = getRawTypeSimpleName(typeName);\n\t\t}\n\t\t\n\t\tfor (String string : getVariableProposals(baseType, isMany, ctx, varType, notAllowedNames)) {\n\t\t\tacceptor.accept(string,\n\t\t\t\t\tnew StyledString(string + \" : \" + typeName),\n\t\t\t\t\tgetImage(ctx));\n\t\t}\n\t}\n\t\n\tprotected boolean isCollectionType(String typeName) {\n\t\treturn getCollectionTypes().contains(getRawTypeSimpleName(typeName)) && getFirstTypeArgumentSimpleName(typeName) != null;\n\t}\n\t\n\tprotected boolean isArray(String typeName) {\n\t\treturn getArrayComponentTypeSimpleName(typeName) != null;\n\t}\n\t\n<fim_suffix>\tprotected String getArrayComponentTypeSimpleName(String typeName) {\n\t\tint idx = typeName.indexOf('[');\n\t\tif (idx != -1) {\n\t\t\treturn getSimpleName(typeName.substring(0, idx));\n\t\t}\n\t\treturn null;\n\t}\n\n\tprotected Image getImage(EObject context) {\n\t\treturn JavaPlugin.getImageDescriptorRegistry().get(JavaPluginImages.DESC_OBJS_LOCAL_VARIABLE);\n\t}\n\n\t/**\n\t * @return the simple name of the main type (raw type) of the given type name.\n\t */\n\tprotected String getRawTypeSimpleName(String typeName) {\n\t\tfinal int idxOfFirstBracket = typeName.indexOf('<');\n\t\tif (idxOfFirstBracket != -1) {\n\t\t\tString mainType = typeName.substring(0, idxOfFirstBracket);\n\t\t\treturn getSimpleName(mainType);\n\t\t}\n\t\treturn getSimpleName(typeName);\n\t}\n\n\t/**\n\t * @return the simple name of the first argument of a Java Type Reference or null if the given string\n\t *         doesn't have a first type argument.\n\t */\n\tprotected String getFirstTypeArgumentSimpleName(String typeName) {\n\t\tfinal int idxOfFirstBracket = typeName.indexOf(leftTypeArgParen());\n\t\tif (idxOfFirstBracket != -1) {\n\t\t\tfinal int afterFirstBracket = idxOfFirstBracket+1;\n\t\t\tint index = typeName.indexOf(rightTypeArgParen(), afterFirstBracket);\n\t\t\tif (index == -1)\n\t\t\t\treturn null;\n\t\t\tint idx1 = typeName.indexOf(typeArgSeparator(), afterFirstBracket);\n\t\t\tif (idx1 != -1 && idx1 < index) {\n\t\t\t\tindex = idx1;\n\t\t\t}\n\t\t\tint idx2 = typeName.indexOf(leftTypeArgParen(), afterFirstBracket);\n\t\t\tif (idx2 != -1 && idx2 < index) {\n\t\t\t\tindex = idx2;\n\t\t\t}\n\t\t\tfinal String substring = typeName.substring(afterFirstBracket, index);\n\t\t\tString firstInnerType = getSimpleName(substring);\n\t\t\treturn firstInnerType;\n\t\t}\n\t\treturn null;\n\t}\n\n\tprotected String typeArgSeparator() {\n\t\treturn \",\";\n\t}\n\n\tprotected String rightTypeArgParen() {\n\t\treturn \">\";\n\t}\n\n\tprotected String leftTypeArgParen() {\n\t\treturn \"<\";\n\t}\n\n\tprotected Set<String> getCollectionTypes() {\n\t\treturn newHashSet(\"Collection\", \"List\", \"Iterable\", \"Set\", \"Iterator\", \"HashSet\", \"LinkedHashSet\", \"ArrayList\",\n\t\t\t\t\"LinkedList\");\n\t}\n\n\tprotected String getSimpleName(String mainType) {\n\t\tif (mainType.indexOf('.') != -1) {\n\t\t\treturn mainType.substring(mainType.lastIndexOf('.') + 1);\n\t\t}\n\t\treturn mainType;\n\t}\n\n\tprotected String getTextUnderReference(EObject ctx, EReference refToTypeRef) {\n\t\tList<INode> nodes = NodeModelUtils.findNodesForFeature(ctx, refToTypeRef);\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (INode n : nodes) {\n\t\t\tsb.append(NodeModelUtils.getTokenText(n));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic String[] getVariableProposals(String simpleTypeName, boolean isPlural, EObject ctx, VariableType varType, Set<String> excludedNames) {\n\t\tif (!org.eclipse.xtext.util.Strings.isEmpty(simpleTypeName)) {\n\t\t\tIJavaProject javaProject = null;\n\t\t\tif (ctx != null && ctx.eResource() != null && ctx.eResource().getResourceSet() != null)\n\t\t\t\tjavaProject = javaProjectProvider.getJavaProject(ctx.eResource().getResourceSet());\n\t\t\treturn NamingConventions.suggestVariableNames(getVariableKind(varType),\n\t\t\t\t\tNamingConventions.BK_TYPE_NAME, simpleTypeName, javaProject, isPlural?1:0, excludedNames.toArray(new String[excludedNames.size()]), false);\n\t\t}\n\t\treturn new String[0];\n\t}\n\n\tprotected int getVariableKind(VariableType varType) {\n\t\tswitch (varType) {\n\t\t\tcase INSTANCE_FIELD :\n\t\t\t\treturn NamingConventions.VK_INSTANCE_FIELD;\n\t\t\tcase LOCAL_VAR :\n\t\t\t\treturn NamingConventions.VK_LOCAL;\n\t\t\tcase PARAMETER :\n\t\t\t\treturn NamingConventions.VK_PARAMETER;\n\t\t\tcase STATIC_FIELD:\n\t\t\t\treturn NamingConventions.VK_STATIC_FINAL_FIELD;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalStateException(\"unhandled enum const\"+varType);\n\t\t}\n\t}\n}<fim_middle>// function below has no smell\n"}