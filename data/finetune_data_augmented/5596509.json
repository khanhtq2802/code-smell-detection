{"text": "<fim_prefix>/*\n *\n *  Licensed to the Apache Software Foundation (ASF) under one or more\n *  contributor license agreements.  See the NOTICE file distributed with\n *  this work for additional information regarding copyright ownership.\n *  The ASF licenses this file to You under the Apache License, Version 2.0\n *  (the \"License\"); you may not use this file except in compliance with\n *  the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n */\npackage org.apache.royale.compiler.internal.codegen.js.amd;\nimport java.io.FilterWriter;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport org.apache.royale.compiler.codegen.js.amd.IJSAMDDocEmitter;\nimport org.apache.royale.compiler.codegen.js.amd.IJSAMDEmitter;\nimport org.apache.royale.compiler.definitions.IAccessorDefinition;\nimport org.apache.royale.compiler.definitions.IClassDefinition;\nimport org.apache.royale.compiler.definitions.IConstantDefinition;\nimport org.apache.royale.compiler.definitions.IDefinition;\nimport org.apache.royale.compiler.definitions.IFunctionDefinition;\nimport org.apache.royale.compiler.definitions.IInterfaceDefinition;\nimport org.apache.royale.compiler.definitions.IPackageDefinition;\nimport org.apache.royale.compiler.definitions.ITypeDefinition;\nimport org.apache.royale.compiler.definitions.IVariableDefinition;\nimport org.apache.royale.compiler.definitions.references.IReference;\nimport org.apache.royale.compiler.internal.codegen.as.ASEmitterTokens;\nimport org.apache.royale.compiler.internal.codegen.js.JSEmitter;\nimport org.apache.royale.compiler.internal.codegen.js.JSEmitterTokens;\nimport org.apache.royale.compiler.internal.codegen.js.utils.EmitterUtils;\nimport org.apache.royale.compiler.internal.definitions.ClassTraitsDefinition;\nimport org.apache.royale.compiler.internal.tree.as.FunctionCallNode;\nimport org.apache.royale.compiler.internal.tree.as.FunctionNode;\nimport org.apache.royale.compiler.internal.tree.as.IdentifierNode;\nimport org.apache.royale.compiler.problems.ICompilerProblem;\nimport org.apache.royale.compiler.projects.ICompilerProject;\nimport org.apache.royale.compiler.scopes.IASScope;\nimport org.apache.royale.compiler.tree.ASTNodeID;\nimport org.apache.royale.compiler.tree.as.IASNode;\nimport org.apache.royale.compiler.tree.as.IAccessorNode;\nimport org.apache.royale.compiler.tree.as.IBlockNode;\nimport org.apache.royale.compiler.tree.as.IClassNode;\nimport org.apache.royale.compiler.tree.as.IContainerNode;\nimport org.apache.royale.compiler.tree.as.IDefinitionNode;\nimport org.apache.royale.compiler.tree.as.IExpressionNode;\nimport org.apache.royale.compiler.tree.as.IFunctionCallNode;\nimport org.apache.royale.compiler.tree.as.IFunctionNode;\nimport org.apache.royale.compiler.tree.as.IGetterNode;\nimport org.apache.royale.compiler.tree.as.IIdentifierNode;\nimport org.apache.royale.compiler.tree.as.IInterfaceNode;\nimport org.apache.royale.compiler.tree.as.ILanguageIdentifierNode;\nimport org.apache.royale.compiler.tree.as.IMemberAccessExpressionNode;\nimport org.apache.royale.compiler.tree.as.IParameterNode;\nimport org.apache.royale.compiler.tree.as.ISetterNode;\nimport org.apache.royale.compiler.tree.as.ITypeNode;\nimport org.apache.royale.compiler.tree.as.IVariableNode;\nimport org.apache.royale.compiler.utils.NativeUtils;\n/**\n * Concrete implementation of the 'AMD' JavaScript production.\n * \n * @author Michael Schmalle\n */\npublic class JSAMDEmitter extends JSEmitter implements IJSAMDEmitter\n{\n    private Map<String, IDefinitionNode> foundAccessors = new HashMap<String, IDefinitionNode>();\n    private int inheritenceLevel = -1;\n    private ExportWriter exportWriter;\n    private boolean initializingFieldsInConstructor;\n    private List<IDefinition> baseClassCalls = new ArrayList<IDefinition>();\n    StringBuilder builder()\n    {\n        return getBuilder();\n    }\n    IJSAMDDocEmitter getDoc()\n    {\n        return (IJSAMDDocEmitter) getDocEmitter();\n    }\n    public JSAMDEmitter(FilterWriter out)\n    {\n        super(out);\n        exportWriter = new ExportWriter(this);\n    }\n    @Override\n    public void emitPackageHeader(IPackageDefinition definition)\n    {\n        // TODO (mschmalle|AMD) this is a hack but I know no other way to do replacements in a Writer\n        setBufferWrite(true);\n        write(JSAMDEmitterTokens.DEFINE);\n        write(ASEmitterTokens.PAREN_OPEN);\n        IASScope containedScope = definition.getContainedScope();\n        ITypeDefinition type = findType(containedScope.getAllLocalDefinitions());\n        if (type == null)\n            return;\n        exportWriter.addFrameworkDependencies();\n        exportWriter.addImports(type);\n        exportWriter.queueExports(type, true);\n        writeToken(ASEmitterTokens.COMMA);\n    }\n    @Override\n    public void emitPackageHeaderContents(IPackageDefinition definition)\n    {\n        // nothing\n    }\n<fim_suffix>    @Override\n    public void emitPackageContents(IPackageDefinition definition)\n    {\n        IASScope containedScope = definition.getContainedScope();\n        ITypeDefinition type = findType(containedScope.getAllLocalDefinitions());\n        if (type == null)\n            return;\n        write(\"function($exports\");\n        exportWriter.queueExports(type, false);\n        write(\") {\");\n        indentPush();\n        writeNewline();\n        write(\"\\\"use strict\\\"; \");\n        writeNewline();\n        ITypeNode tnode = findTypeNode(definition.getNode());\n        if (tnode != null)\n        {\n            getWalker().walk(tnode); // IClassNode | IInterfaceNode\n        }\n        indentPop();\n        writeNewline();\n        write(\"}\"); // end returned function\n    }\n    @Override\n    public void emitPackageFooter(IPackageDefinition definition)\n    {\n        IASScope containedScope = definition.getContainedScope();\n        ITypeDefinition type = findType(containedScope.getAllLocalDefinitions());\n        if (type == null)\n            return;\n        exportWriter.writeExports(type, true);\n        exportWriter.writeExports(type, false);\n        write(\");\"); // end define()\n        // flush the buffer, writes the builder to out\n        flushBuilder();\n    }\n    private void emitConstructor(IFunctionNode node)\n    {\n        FunctionNode fn = (FunctionNode) node;\n        fn.parseFunctionBody(getProblems());\n        //IFunctionDefinition definition = node.getDefinition();\n        write(\"function \");\n        write(node.getName());\n        emitParameters(node.getParametersContainerNode());\n        if (!isImplicit((IContainerNode) node.getScopedNode()))\n        {\n            emitMethodScope(node.getScopedNode());\n        }\n        else\n        {\n            // we have a synthesized constructor, implict\n        }\n    }\n    @Override\n    public void emitInterface(IInterfaceNode node)\n    {\n        final IInterfaceDefinition definition = node.getDefinition();\n        final String interfaceName = definition.getBaseName();\n        write(\"AS3.interface_($exports, {\");\n        indentPush();\n        writeNewline();\n        write(\"package_: \\\"\");\n        write(definition.getPackageName());\n        write(\"\\\",\");\n        writeNewline();\n        write(\"interface_: \\\"\");\n        write(interfaceName);\n        write(\"\\\"\");\n        IReference[] references = definition.getExtendedInterfaceReferences();\n        final int len = references.length;\n        if (len > 0)\n        {\n            writeNewline();\n            write(\"extends_: [\");\n            indentPush();\n            writeNewline();\n            int i = 0;\n            for (IReference reference : references)\n            {\n                write(reference.getName());\n                if (i < len - 1)\n                {\n                    write(\",\");\n                    writeNewline();\n                }<fim_middle>// function below has no smell\n"}