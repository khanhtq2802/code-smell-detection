{"text": "<fim_prefix>import java.nio.channels.ClosedChannelException;\nimport java.util.Arrays;\nimport org.apache.hadoop.classification.InterfaceAudience;\nimport org.apache.hadoop.classification.InterfaceStability;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.fs.permission.FsPermission;\nimport org.apache.hadoop.util.DataChecksum;\nimport org.apache.hadoop.util.Progressable;\n/****************************************************************\n * Abstract Checksumed FileSystem.\n * It provide a basic implementation of a Checksumed FileSystem,\n * which creates a checksum file for each raw file.\n * It generates & verifies checksums at the client side.\n *\n *****************************************************************/\n@InterfaceAudience.Public\n@InterfaceStability.Stable\npublic abstract class ChecksumFileSystem extends FilterFileSystem {\n  private static final byte[] CHECKSUM_VERSION = new byte[] {'c', 'r', 'c', 0};\n  private int bytesPerChecksum = 512;\n  private boolean verifyChecksum = true;\n  private boolean writeChecksum = true;\n  public static double getApproxChkSumLength(long size) {\n    return ChecksumFSOutputSummer.CHKSUM_AS_FRACTION * size;\n  }\n  public ChecksumFileSystem(FileSystem fs) {\n    super(fs);\n  }\n  @Override\n  public void setConf(Configuration conf) {\n    super.setConf(conf);\n    if (conf != null) {\n      bytesPerChecksum = conf.getInt(LocalFileSystemConfigKeys.LOCAL_FS_BYTES_PER_CHECKSUM_KEY,\n\t\t                     LocalFileSystemConfigKeys.LOCAL_FS_BYTES_PER_CHECKSUM_DEFAULT);\n    }\n  }\n  /**\n   * Set whether to verify checksum.\n   */\n  @Override\n  public void setVerifyChecksum(boolean verifyChecksum) {\n    this.verifyChecksum = verifyChecksum;\n  }\n  @Override\n  public void setWriteChecksum(boolean writeChecksum) {\n    this.writeChecksum = writeChecksum;\n  }\n  /** get the raw file system */\n  @Override\n  public FileSystem getRawFileSystem() {\n    return fs;\n  }\n  /** Return the name of the checksum file associated with a file.*/\n  public Path getChecksumFile(Path file) {\n    return new Path(file.getParent(), \".\" + file.getName() + \".crc\");\n  }\n  /** Return true iff file is a checksum file name.*/\n  public static boolean isChecksumFile(Path file) {\n    String name = file.getName();\n    return name.startsWith(\".\") && name.endsWith(\".crc\");\n  }\n  /** Return the length of the checksum file given the size of the \n   * actual file.\n   **/\n  public long getChecksumFileLength(Path file, long fileSize) {\n    return getChecksumLength(fileSize, getBytesPerSum());\n  }\n  /** Return the bytes Per Checksum */\n  public int getBytesPerSum() {\n    return bytesPerChecksum;\n  }\n  private int getSumBufferSize(int bytesPerSum, int bufferSize) {\n    int defaultBufferSize = getConf().getInt(\n                       LocalFileSystemConfigKeys.LOCAL_FS_STREAM_BUFFER_SIZE_KEY,\n                       LocalFileSystemConfigKeys.LOCAL_FS_STREAM_BUFFER_SIZE_DEFAULT);\n    int proportionalBufferSize = bufferSize / bytesPerSum;\n    return Math.max(bytesPerSum,\n                    Math.max(proportionalBufferSize, defaultBufferSize));\n  }\n  /*******************************************************\n   * For open()'s FSInputStream\n   * It verifies that data matches checksums.\n   *******************************************************/\n  private static class ChecksumFSInputChecker extends FSInputChecker {\n    private ChecksumFileSystem fs;\n    private FSDataInputStream datas;\n    private FSDataInputStream sums;\n    private static final int HEADER_LENGTH = 8;\n    private int bytesPerSum = 1;\n    public ChecksumFSInputChecker(ChecksumFileSystem fs, Path file)\n      throws IOException {\n      this(fs, file, fs.getConf().getInt(\n                       LocalFileSystemConfigKeys.LOCAL_FS_STREAM_BUFFER_SIZE_KEY, \n                       LocalFileSystemConfigKeys.LOCAL_FS_STREAM_BUFFER_SIZE_DEFAULT));\n    }\n    public ChecksumFSInputChecker(ChecksumFileSystem fs, Path file, int bufferSize)\n      throws IOException {\n      super( file, fs.getFileStatus(file).getReplication() );\n      this.datas = fs.getRawFileSystem().open(file, bufferSize);\n      this.fs = fs;\n      Path sumFile = fs.getChecksumFile(file);\n      try {\n        int sumBufferSize = fs.getSumBufferSize(fs.getBytesPerSum(), bufferSize);\n        sums = fs.getRawFileSystem().open(sumFile, sumBufferSize);\n        byte[] version = new byte[CHECKSUM_VERSION.length];\n        sums.readFully(version);\n        if (!Arrays.equals(version, CHECKSUM_VERSION))\n          throw new IOException(\"Not a checksum file: \"+sumFile);\n        this.bytesPerSum = sums.readInt();\n        set(fs.verifyChecksum, DataChecksum.newCrc32(), bytesPerSum, 4);\n      } catch (FileNotFoundException e) {         // quietly ignore\n        set(fs.verifyChecksum, null, 1, 0);\n      } catch (IOException e) {                   // loudly ignore\n        LOG.warn(\"Problem opening checksum file: \"+ file + \n                 \".  Ignoring exception: \" , e); \n        set(fs.verifyChecksum, null, 1, 0);\n      }\n    }\n    private long getChecksumFilePos( long dataPos ) {\n      return HEADER_LENGTH + 4*(dataPos/bytesPerSum);\n    }\n    @Override\n    protected long getChunkPosition( long dataPos ) {\n      return dataPos/bytesPerSum*bytesPerSum;\n    }\n    @Override\n    public int available() throws IOException {\n      return datas.available() + super.available();\n    }\n    @Override\n    public int read(long position, byte[] b, int off, int len)\n      throws IOException {\n      // parameter check\n      if ((off | len | (off + len) | (b.length - (off + len))) < 0) {\n        throw new IndexOutOfBoundsException();\n      } else if (len == 0) {\n        return 0;\n      }\n      if( position<0 ) {\n        throw new IllegalArgumentException(\n            \"Parameter position can not to be negative\");\n      }\n      ChecksumFSInputChecker checker = new ChecksumFSInputChecker(fs, file);\n      checker.seek(position);\n      int nread = checker.read(b, off, len);\n      checker.close();\n      return nread;\n    }\n    @Override\n    public void close() throws IOException {\n      datas.close();\n      if( sums != null ) {\n        sums.close();\n      }\n      set(fs.verifyChecksum, null, 1, 0);\n    }\n    @Override\n    public boolean seekToNewSource(long targetPos) throws IOException {\n      long sumsPos = getChecksumFilePos(targetPos);\n      fs.reportChecksumFailure(file, datas, targetPos, sums, sumsPos);\n      boolean newDataSource = datas.seekToNewSource(targetPos);\n      return sums.seekToNewSource(sumsPos) || newDataSource;\n    }\n    @Override\n    protected int readChunk(long pos, byte[] buf, int offset, int len,\n        byte[] checksum) throws IOException {\n      boolean eof = false;\n      if (needChecksum()) {\n        assert checksum != null; // we have a checksum buffer\n        assert checksum.length % CHECKSUM_SIZE == 0; // it is sane length\n        assert len >= bytesPerSum; // we must read at least one chunk\n        final int checksumsToRead = Math.min(\n          len/bytesPerSum, // number of checksums based on len to read\n          checksum.length / CHECKSUM_SIZE); // size of checksum buffer\n        long checksumPos = getChecksumFilePos(pos); \n        if(checksumPos != sums.getPos()) {\n          sums.seek(checksumPos);\n        }\n        int sumLenRead = sums.read(checksum, 0, CHECKSUM_SIZE * checksumsToRead);\n        if (sumLenRead >= 0 && sumLenRead % CHECKSUM_SIZE != 0) {\n          throw new ChecksumException(\n            \"Checksum file not a length multiple of checksum size \" +\n            \"in \" + file + \" at \" + pos + \" checksumpos: \" + checksumPos +\n            \" sumLenread: \" + sumLenRead,\n            pos);\n        }\n        if (sumLenRead <= 0) { // we're at the end of the file\n          eof = true;\n        } else {\n          // Adjust amount of data to read based on how many checksum chunks we read\n          len = Math.min(len, bytesPerSum * (sumLenRead / CHECKSUM_SIZE));\n        }\n      }\n      if(pos != datas.getPos()) {\n        datas.seek(pos);\n      }\n      int nread = readFully(datas, buf, offset, len);\n      if (eof && nread > 0) {\n        throw new ChecksumException(\"Checksum error: \"+file+\" at \"+pos, pos);\n      }\n      return nread;\n    }\n  }\n  private static class FSDataBoundedInputStream extends FSDataInputStream {\n    private FileSystem fs;\n    private Path file;\n    private long fileLen = -1L;\n<fim_suffix>    FSDataBoundedInputStream(FileSystem fs, Path file, InputStream in) {\n      super(in);\n      this.fs = fs;\n      this.file = file;\n    }<fim_middle>// function below has no smell\n"}