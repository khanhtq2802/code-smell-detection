{"text": "<fim_prefix>  private final long bits1;\n  public VMStatsDiskLRURegionEntryOffHeapStringKey1(final RegionEntryContext context,\n      final String key, @Retained final Object value, final boolean byteEncode) {\n    super(context, (value instanceof RecoveredEntry ? null : value));\n    // DO NOT modify this class. It was generated from LeafRegionEntry.cpp\n    initialize(context, value);\n    // caller has already confirmed that key.length <= MAX_INLINE_STRING_KEY\n    long tempBits1 = 0L;\n    if (byteEncode) {\n      for (int i = key.length() - 1; i >= 0; i--) {\n        // Note: we know each byte is <= 0x7f so the \"& 0xff\" is not needed. But I added it in to\n        // keep findbugs happy.\n        tempBits1 |= (byte) key.charAt(i) & 0xff;\n        tempBits1 <<= 8;\n      }\n      tempBits1 |= 1 << 6;\n    } else {\n      for (int i = key.length() - 1; i >= 0; i--) {\n        tempBits1 |= key.charAt(i);\n        tempBits1 <<= 16;\n      }\n    }\n    tempBits1 |= key.length();\n    this.bits1 = tempBits1;\n  }\n  // DO NOT modify this class. It was generated from LeafRegionEntry.cpp\n  @Override\n  public Token getValueAsToken() {\n    return OffHeapRegionEntryHelper.getValueAsToken(this);\n  }\n  @Override\n  protected Object getValueField() {\n    return OffHeapRegionEntryHelper._getValue(this);\n  }\n  // DO NOT modify this class. It was generated from LeafRegionEntry.cpp\n  @Override\n  @Unretained\n  protected void setValueField(@Unretained final Object value) {\n    OffHeapRegionEntryHelper.setValue(this, value);\n  }\n  @Override\n  @Retained\n  public Object getValueRetain(final RegionEntryContext context, final boolean decompress) {\n    return OffHeapRegionEntryHelper._getValueRetain(this, decompress, context);\n  }\n  @Override\n  public long getAddress() {\n    return OFF_HEAP_ADDRESS_UPDATER.get(this);\n  }\n  @Override\n  public boolean setAddress(final long expectedAddress, long newAddress) {\n    return OFF_HEAP_ADDRESS_UPDATER.compareAndSet(this, expectedAddress, newAddress);\n  }\n  @Override\n  @Released\n  public void release() {\n    OffHeapRegionEntryHelper.releaseEntry(this);\n  }\n  @Override\n  public void returnToPool() {\n    // never implemented\n  }\n  @Override\n  protected long getLastModifiedField() {\n    return LAST_MODIFIED_UPDATER.get(this);\n  }\n  @Override\n  protected boolean compareAndSetLastModifiedField(final long expectedValue, final long newValue) {\n    return LAST_MODIFIED_UPDATER.compareAndSet(this, expectedValue, newValue);\n  }\n  @Override\n  public int getEntryHash() {\n    return this.hash;\n  }\n  @Override\n  protected void setEntryHash(final int hash) {\n    this.hash = hash;\n  }\n  @Override\n  public HashEntry<Object, Object> getNextEntry() {\n    return this.nextEntry;\n  }\n  @Override\n  public void setNextEntry(final HashEntry<Object, Object> nextEntry) {\n    this.nextEntry = nextEntry;\n  }\n  // ----------------------------------------- disk code ------------------------------------------\n  // DO NOT modify this class. It was generated from LeafRegionEntry.cpp\n  protected void initialize(final RegionEntryContext context, final Object value) {\n    boolean isBackup;\n    if (context instanceof InternalRegion) {\n      isBackup = ((InternalRegion) context).getDiskRegion().isBackup();\n    } else if (context instanceof PlaceHolderDiskRegion) {\n      isBackup = true;\n    } else {\n      throw new IllegalArgumentException(\"expected a InternalRegion or PlaceHolderDiskRegion\");\n    }\n    // Delay the initialization of DiskID if overflow only\n    if (isBackup) {\n      diskInitialize(context, value);\n    }\n  }\n  @Override\n  public synchronized int updateAsyncEntrySize(final EvictionController evictionController) {\n    int oldSize = getEntrySize();\n    int newSize = evictionController.entrySize(getKeyForSizing(), null);\n    setEntrySize(newSize);\n    int delta = newSize - oldSize;\n    return delta;\n  }\n  // DO NOT modify this class. It was generated from LeafRegionEntry.cpp\n  @Override\n  public DiskId getDiskId() {\n    return this.id;\n  }\n  @Override\n  public void setDiskId(final RegionEntry oldEntry) {\n    this.id = ((DiskEntry) oldEntry).getDiskId();\n  }\n  private void diskInitialize(final RegionEntryContext context, final Object value) {\n    DiskRecoveryStore diskRecoveryStore = (DiskRecoveryStore) context;\n    DiskStoreImpl diskStore = diskRecoveryStore.getDiskStore();\n    long maxOplogSize = diskStore.getMaxOplogSize();\n    // get appropriate instance of DiskId implementation based on maxOplogSize\n    this.id = DiskId.createDiskId(maxOplogSize, true, diskStore.needsLinkedList());\n    Helper.initialize(this, diskRecoveryStore, value);\n  }\n  // --------------------------------------- eviction code ----------------------------------------\n  // DO NOT modify this class. It was generated from LeafRegionEntry.cpp\n  @Override\n  public void setDelayedDiskId(final DiskRecoveryStore diskRecoveryStore) {\n    DiskStoreImpl diskStore = diskRecoveryStore.getDiskStore();\n    long maxOplogSize = diskStore.getMaxOplogSize();\n    this.id = DiskId.createDiskId(maxOplogSize, false, diskStore.needsLinkedList());\n  }\n  @Override\n  public synchronized int updateEntrySize(final EvictionController evictionController) {\n    // OFFHEAP: getValue ok w/o incing refcount because we are synced and only getting the size\n    return updateEntrySize(evictionController, getValue());\n  }\n  // DO NOT modify this class. It was generated from LeafRegionEntry.cpp\n  @Override\n  public synchronized int updateEntrySize(final EvictionController evictionController,\n      final Object value) {\n    int oldSize = getEntrySize();\n    int newSize = evictionController.entrySize(getKeyForSizing(), value);\n    setEntrySize(newSize);\n    int delta = newSize - oldSize;\n    return delta;\n  }\n  @Override\n  public boolean isRecentlyUsed() {\n    return areAnyBitsSet(RECENTLY_USED);\n  }\n  @Override\n  public void setRecentlyUsed(RegionEntryContext context) {\n    if (!isRecentlyUsed()) {\n      setBits(RECENTLY_USED);\n      context.incRecentlyUsed();\n    }\n  }\n  @Override\n  public void unsetRecentlyUsed() {\n    clearBits(~RECENTLY_USED);\n  }\n  @Override\n  public boolean isEvicted() {\n    return areAnyBitsSet(EVICTED);\n  }\n  @Override\n  public void setEvicted() {\n    setBits(EVICTED);\n  }\n  @Override\n  public void unsetEvicted() {\n    clearBits(~EVICTED);\n  }\n  // DO NOT modify this class. It was generated from LeafRegionEntry.cpp\n  private EvictionNode nextEvictionNode;\n  private EvictionNode previousEvictionNode;\n  private int size;\n  @Override\n  public void setNext(final EvictionNode nextEvictionNode) {\n    this.nextEvictionNode = nextEvictionNode;\n  }\n  @Override\n  public EvictionNode next() {\n    return this.nextEvictionNode;\n  }\n  @Override\n  public void setPrevious(final EvictionNode previousEvictionNode) {\n    this.previousEvictionNode = previousEvictionNode;\n  }\n  @Override\n  public EvictionNode previous() {\n    return this.previousEvictionNode;\n  }\n  @Override\n  public int getEntrySize() {\n    return this.size;\n  }\n  protected void setEntrySize(final int size) {\n    this.size = size;\n  }\n  // DO NOT modify this class. It was generated from LeafRegionEntry.cpp\n  @Override\n  public Object getKeyForSizing() {\n    // inline keys always report null for sizing since the size comes from the entry size\n    return null;\n  }\n  // ---------------------------------------- stats code ------------------------------------------\n  // DO NOT modify this class. It was generated from LeafRegionEntry.cpp\n  @Override\n  public void updateStatsForGet(final boolean isHit, final long time) {\n    setLastAccessed(time);\n    if (isHit) {\n      incrementHitCount();\n    } else {\n      incrementMissCount();\n    }\n  }\n<fim_suffix>  @Override\n  protected void setLastModifiedAndAccessedTimes(final long lastModified, final long lastAccessed) {\n    _setLastModified(lastModified);\n    if (!DISABLE_ACCESS_TIME_UPDATE_ON_PUT) {\n      setLastAccessed(lastAccessed);\n    }\n  }<fim_middle>// function below has no smell\n"}