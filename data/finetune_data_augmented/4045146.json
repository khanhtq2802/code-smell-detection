{"text": "<fim_prefix>            // included in the merge operation\n            LSMBuddyBTreeMergeCursor buddyBtreeCursor = new LSMBuddyBTreeMergeCursor(opCtx);\n            search(opCtx, buddyBtreeCursor, btreeSearchPred);\n            long numElements = 0L;\n            for (int i = 0; i < mergeOp.getMergingComponents().size(); ++i) {\n                numElements += ((AbstractLSMWithBloomFilterDiskComponent) mergeOp.getMergingComponents().get(i))\n                        .getBloomFilter().getNumElements();\n            }\n            componentBulkLoader =\n                    mergedComponent.createBulkLoader(operation, 1.0f, false, numElements, false, false, false);\n            try {\n                while (buddyBtreeCursor.hasNext()) {\n                    buddyBtreeCursor.next();\n                    ITupleReference tuple = buddyBtreeCursor.getTuple();\n                    componentBulkLoader.delete(tuple);\n                }\n            } finally {\n                buddyBtreeCursor.close();\n            }\n        } else {\n            componentBulkLoader = mergedComponent.createBulkLoader(operation, 1.0f, false, 0L, false, false, false);\n        }\n        try {\n            while (cursor.hasNext()) {\n                cursor.next();\n                ITupleReference frameTuple = cursor.getTuple();\n                componentBulkLoader.add(frameTuple);\n            }\n        } finally {\n            cursor.close();\n        }\n        componentBulkLoader.end();\n        return mergedComponent;\n    }\n    @Override\n    public void getOperationalComponents(ILSMIndexOperationContext ctx) {\n        List<ILSMComponent> operationalComponents = ctx.getComponentHolder();\n        List<ILSMDiskComponent> immutableComponents;\n        // Identify current list in case of a merge\n        if (version == 0) {\n            immutableComponents = diskComponents;\n        } else {\n            immutableComponents = secondDiskComponents;\n        }\n        ExternalBTreeWithBuddyOpContext opCtx = (ExternalBTreeWithBuddyOpContext) ctx;\n        operationalComponents.clear();\n        switch (ctx.getOperation()) {\n            case SEARCH:\n                if (opCtx.getTargetIndexVersion() == 0) {\n                    operationalComponents.addAll(diskComponents);\n                } else {\n                    operationalComponents.addAll(secondDiskComponents);\n                }\n                break;\n            case MERGE:\n                operationalComponents.addAll(ctx.getComponentsToBeMerged());\n                break;\n            case FULL_MERGE:\n                operationalComponents.addAll(immutableComponents);\n            case REPLICATE:\n                operationalComponents.addAll(ctx.getComponentsToBeReplicated());\n                break;\n            case FLUSH:\n                // Do nothing. this is left here even though the index never\n                // performs flushes because a flush is triggered by\n                // dataset lifecycle manager when closing an index. Having no\n                // components is a no operation\n                break;\n            default:\n                throw new UnsupportedOperationException(\"Operation \" + ctx.getOperation() + \" not supported.\");\n        }\n    }\n    // This function is used when a new component is to be committed -- is\n    // called by the harness.\n    @Override\n    public void commitTransactionDiskComponent(ILSMDiskComponent newComponent) throws HyracksDataException {\n        // determine which list is the new one and flip the pointer\n        List<ILSMDiskComponent> newerList;\n        List<ILSMDiskComponent> olderList;\n        if (version == 0) {\n            newerList = diskComponents;\n            olderList = secondDiskComponents;\n            version = 1;\n        } else {\n            newerList = secondDiskComponents;\n            olderList = diskComponents;\n            version = 0;\n        }\n        // Remove components from list\n        olderList.clear();\n        // Add components\n        olderList.addAll(newerList);\n        if (newComponent != null) {\n            // Add it to the list\n            olderList.add(0, newComponent);\n        }\n    }\n    @Override\n    public void deactivate(boolean flushOnExit) throws HyracksDataException {\n        if (!isActive) {\n            throw new HyracksDataException(\"Failed to deactivate the index since it is already deactivated.\");\n        }\n        // Even though, we deactivate the index, we don't exit components or\n        // modify any of the lists to make sure they\n        // are there if the index was opened again\n        for (ILSMDiskComponent c : diskComponents) {\n            c.deactivateAndPurge();\n        }\n        for (ILSMDiskComponent c : secondDiskComponents) {\n            // Only deactivate non shared components\n            if (!diskComponents.contains(c)) {\n                c.deactivateAndPurge();\n            }\n        }\n        isActive = false;\n    }\n    @Override\n    public ITreeIndexFrameFactory getLeafFrameFactory() {\n        return btreeLeafFrameFactory;\n    }\n    @Override\n    public ITreeIndexFrameFactory getInteriorFrameFactory() {\n        return btreeInteriorFrameFactory;\n    }\n    @Override\n    public IMetadataPageManager getPageManager() {\n        // This method should never be called for disk only indexes\n        return null;\n    }\n    @Override\n    public int getFieldCount() {\n        return btreeCmpFactories.length;\n    }\n    @Override\n    public int getRootPageId() {\n        // This method should never be called for this index\n        return 0;\n    }\n    @Override\n    public int getFileId() {\n        // This method should never be called for this index\n        return 0;\n    }\n    @Override\n    public IBinaryComparatorFactory[] getComparatorFactories() {\n        return btreeCmpFactories;\n    }\n    // even though the index doesn't support record level modification, the\n    // accessor will try to do it\n    // we could throw the exception here but we don't. it will eventually be\n    // thrown by the index itself\n    // The bulk loader used for both initial loading and transaction\n    // modifications\n<fim_suffix>    public class LSMTwoPCBTreeWithBuddyBulkLoader implements IIndexBulkLoader, ITwoPCIndexBulkLoader {\n        private final ILSMDiskComponent component;\n        private final LoadOperation loadOp;\n        private final ILSMDiskComponentBulkLoader componentBulkLoader;\n        private final boolean isTransaction;\n        public LSMTwoPCBTreeWithBuddyBulkLoader(float fillFactor, boolean verifyInput, long numElementsHint,\n                boolean isTransaction, Map<String, Object> parameters) throws HyracksDataException {\n            this.isTransaction = isTransaction;\n            // Create the appropriate target\n            LSMComponentFileReferences componentFileRefs;\n            if (isTransaction) {\n                try {\n                    componentFileRefs = fileManager.getNewTransactionFileReference();\n                } catch (IOException e) {\n                    throw HyracksDataException.create(e);\n                }\n                component =\n                        createDiskComponent(bulkLoadComponentFactory, componentFileRefs.getInsertIndexFileReference(),\n                                componentFileRefs.getDeleteIndexFileReference(),\n                                componentFileRefs.getBloomFilterFileReference(), true);\n            } else {\n                componentFileRefs = fileManager.getRelFlushFileReference();\n                component =\n                        createDiskComponent(bulkLoadComponentFactory, componentFileRefs.getInsertIndexFileReference(),\n                                componentFileRefs.getDeleteIndexFileReference(),\n                                componentFileRefs.getBloomFilterFileReference(), true);\n            }\n            loadOp = new LoadOperation(componentFileRefs, ioOpCallback, getIndexIdentifier(), parameters);\n            loadOp.setNewComponent(component);\n            ioOpCallback.scheduled(loadOp);\n            ioOpCallback.beforeOperation(loadOp);\n            componentBulkLoader =\n                    component.createBulkLoader(loadOp, fillFactor, verifyInput, numElementsHint, false, true, false);\n        }\n        @Override\n        public void add(ITupleReference tuple) throws HyracksDataException {\n            componentBulkLoader.add(tuple);\n        }\n        @Override\n        public void end() throws HyracksDataException {\n            try {\n                ioOpCallback.afterOperation(loadOp);\n                componentBulkLoader.end();\n                if (component.getComponentSize() > 0) {\n                    if (isTransaction) {\n                        // Since this is a transaction component, validate and\n                        // deactivate. it could later be added or deleted\n                        try {\n                            component.markAsValid(durable, loadOp);\n                        } finally {\n                            ioOpCallback.afterFinalize(loadOp);\n                        }\n                        component.deactivate();\n                    } else {\n                        ioOpCallback.afterFinalize(loadOp);\n                        getHarness().addBulkLoadedComponent(loadOp);\n                    }\n                }\n            } finally {\n                ioOpCallback.completed(loadOp);\n            }\n        }\n        @Override\n        public void delete(ITupleReference tuple) throws HyracksDataException {\n            componentBulkLoader.delete(tuple);\n        }\n        @Override\n        public void abort() throws HyracksDataException {\n            try {\n                try {\n                    componentBulkLoader.abort();\n                } finally {\n                    ioOpCallback.afterFinalize(loadOp);\n                }\n            } finally {\n                ioOpCallback.completed(loadOp);\n            }\n        }\n        @Override\n        public void writeFailed(ICachedPage page, Throwable failure) {\n            throw new UnsupportedOperationException();\n        }\n        @Override\n        public boolean hasFailed() {\n            return componentBulkLoader.hasFailed();\n        }\n        @Override\n        public Throwable getFailure() {\n            return componentBulkLoader.getFailure();\n        }\n    }<fim_middle>// class below has no smell\n"}