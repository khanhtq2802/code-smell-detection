{"text": "<fim_prefix>/*\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n *\n * Copyright 2007-2010 Oracle and/or its affiliates. All rights reserved.\n *\n * Oracle and Java are registered trademarks of Oracle and/or its affiliates.\n * Other names may be trademarks of their respective owners.\n *\n * The contents of this file are subject to the terms of either the GNU\n * General Public License Version 2 only (\"GPL\") or the Common\n * Development and Distribution License(\"CDDL\") (collectively, the\n * \"License\"). You may not use this file except in compliance with the\n * License. You can obtain a copy of the License at\n * http://www.netbeans.org/cddl-gplv2.html\n * or nbbuild/licenses/CDDL-GPL-2-CP. See the License for the\n * specific language governing permissions and limitations under the\n * License.  When distributing the software, include this License Header\n * Notice in each file and include the License file at\n * nbbuild/licenses/CDDL-GPL-2-CP.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the GPL Version 2 section of the License file that\n * accompanied this code. If applicable, add the following below the\n * License Header, with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * Contributor(s):\n * The Original Software is NetBeans. The Initial Developer of the Original\n * Software is Sun Microsystems, Inc. Portions Copyright 1997-2006 Sun\n * Microsystems, Inc. All Rights Reserved.\n *\n * If you wish your version of this file to be governed by only the CDDL\n * or only the GPL Version 2, indicate your decision by adding\n * \"[Contributor] elects to include this software in this distribution\n * under the [CDDL or GPL Version 2] license.\" If you do not indicate a\n * single choice of license, a recipient has the option to distribute\n * your version of this file under either the CDDL, the GPL Version 2 or\n * to extend the choice of license to its licensees as provided above.\n * However, if you add GPL Version 2 code and therefore, elected the GPL\n * Version 2 license, then the option applies only if the new code is\n * made subject to such option by the copyright holder.\n */\npackage org.graalvm.visualvm.lib.profiler.snaptracer.impl.timeline;\nimport java.awt.Color;\nimport org.graalvm.visualvm.lib.charts.ItemSelection;\nimport java.awt.Graphics2D;\nimport java.awt.Rectangle;\nimport java.util.List;\nimport org.graalvm.visualvm.lib.charts.ChartContext;\nimport org.graalvm.visualvm.lib.charts.ChartItem;\nimport org.graalvm.visualvm.lib.charts.ChartItemChange;\nimport org.graalvm.visualvm.lib.charts.swing.LongRect;\nimport org.graalvm.visualvm.lib.charts.xy.XYItem;\nimport org.graalvm.visualvm.lib.charts.xy.XYItemChange;\nimport org.graalvm.visualvm.lib.charts.xy.XYItemPainter;\nimport org.graalvm.visualvm.lib.charts.xy.XYItemSelection;\nimport org.graalvm.visualvm.lib.charts.xy.synchronous.SynchronousXYChartContext;\nimport org.graalvm.visualvm.lib.charts.xy.synchronous.SynchronousXYItem;\n/**\n *\n * @author Jiri Sedlacek\n */\nabstract class TimelineXYPainter extends XYItemPainter.Abstract {\n    private final int viewExtent;\n    private final boolean bottomBased;\n    private boolean painting;\n    protected final double dataFactor;\n    // --- Constructor ---------------------------------------------------------\n    TimelineXYPainter(int viewExtent, boolean bottomBased, double dataFactor) {\n        this.viewExtent = viewExtent;\n        this.bottomBased = bottomBased;\n        this.dataFactor = dataFactor;\n        painting = true;\n    }\n    // --- Abstract interface --------------------------------------------------\n    protected abstract void paint(XYItem item, List<ItemSelection> highlighted,\n                                  List<ItemSelection> selected, Graphics2D g,\n                                  Rectangle dirtyArea, SynchronousXYChartContext\n                                  context);\n    protected abstract Color getDefiningColor();\n    // --- Public interface ----------------------------------------------------\n    void setPainting(boolean painting) {\n        this.painting = painting;\n    }\n    boolean isPainting() {\n        return painting;\n    }\n    // --- ItemPainter implementation ------------------------------------------\n    public LongRect getItemBounds(ChartItem item) {\n        XYItem xyItem = (XYItem)item;\n        return getDataBounds(xyItem.getBounds());\n    }\n    public LongRect getItemBounds(ChartItem item, ChartContext context) {\n        XYItem xyItem = (XYItem)item;\n        return getViewBounds(xyItem.getBounds(), context);\n    }\n    public boolean isBoundsChange(ChartItemChange itemChange) {\n        XYItemChange change = (XYItemChange)itemChange;\n        return !LongRect.equals(change.getOldValuesBounds(),\n                                change.getNewValuesBounds());\n    }\n    public boolean isAppearanceChange(ChartItemChange itemChange) {\n        XYItemChange change = (XYItemChange)itemChange;\n        LongRect dirtyBounds = change.getDirtyValuesBounds();\n        return dirtyBounds.width != 0 || dirtyBounds.height != 0;\n    }\n    public LongRect getDirtyBounds(ChartItemChange itemChange, ChartContext context) {\n        XYItemChange change = (XYItemChange)itemChange;\n        return getViewBounds(change.getDirtyValuesBounds(), context);\n    }\n    public boolean supportsHovering(ChartItem item) {\n        return true;\n    }\n    public boolean supportsSelecting(ChartItem item) {\n        return true;\n    }\n<fim_suffix>    public LongRect getSelectionBounds(ItemSelection selection, ChartContext context) {\n        XYItemSelection sel = (XYItemSelection)selection;\n        XYItem item  = sel.getItem();\n        int selectedValueIndex = sel.getValueIndex();\n        if (selectedValueIndex == -1 ||\n            selectedValueIndex >= item.getValuesCount())\n            // This happens on reset - bounds of the selection are unknown, let's clear whole area\n            return new LongRect(0, 0, context.getViewportWidth(),\n                                context.getViewportHeight());\n        else\n            return getViewBounds(item, selectedValueIndex, context);\n    }\n    public XYItemSelection getClosestSelection(ChartItem item, int viewX,\n                                               int viewY, ChartContext context) {\n        SynchronousXYChartContext contx = (SynchronousXYChartContext)context;\n        int nearestTimestampIndex = contx.getNearestTimestampIndex(viewX, viewY);\n        if (nearestTimestampIndex == -1) return null; // item not visible\n        SynchronousXYItem xyItem = (SynchronousXYItem)item;\n        return new XYItemSelection.Default(xyItem, nearestTimestampIndex,\n                                           ItemSelection.DISTANCE_UNKNOWN);\n    }\n    public final void paintItem(ChartItem item, List<ItemSelection> highlighted,\n                          List<ItemSelection> selected, Graphics2D g,\n                          Rectangle dirtyArea, ChartContext context) {\n        if (!painting) return;\n        XYItem it = (XYItem)item;\n        if (it.getValuesCount() < 1) return;\n        if (context.getViewWidth() == 0 || context.getViewHeight() == 0) return;\n        SynchronousXYChartContext ctx = (SynchronousXYChartContext)context;\n        paint((XYItem)item, highlighted, selected, g, dirtyArea, ctx);\n    }\n    // --- XYItemPainter implementation ----------------------------------------\n    public double getItemView(double dataY, XYItem item, ChartContext context) {\n        return context.getViewY(dataY * dataFactor);\n    }\n    public double getItemValue(double viewY, XYItem item, ChartContext context) {\n        return context.getDataY(viewY / dataFactor);\n    }\n    public double getItemValueScale(XYItem item, ChartContext context) {\n        double scale = context.getViewHeight(dataFactor);\n        if (scale <= 0) scale = -1;\n        return scale;\n    }\n    // --- Private implementation ----------------------------------------------\n    private LongRect getDataBounds(LongRect itemBounds) {\n        LongRect bounds = new LongRect(itemBounds);\n        bounds.y *= dataFactor;\n        bounds.height *= dataFactor;\n        if (bottomBased) {\n            bounds.height += bounds.y;\n            bounds.y = 0;\n        }\n        return bounds;\n    }\n    private LongRect getViewBounds(LongRect itemBounds, ChartContext context) {\n        LongRect dataBounds = getDataBounds(itemBounds);\n        LongRect viewBounds = context.getViewRect(dataBounds);\n        LongRect.addBorder(viewBounds, viewExtent);\n        return viewBounds;\n    }\n    private LongRect getViewBounds(XYItem item, int valueIndex, ChartContext context) {<fim_middle>// function below is feature envy\n"}