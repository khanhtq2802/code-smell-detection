{"text": "<fim_prefix>              + \"distribution directory}</value>\\n\")\n          .append(\"</property>\\n<property>\\n\")\n          .append(\"  <name>mapreduce.reduce.env</name>\\n\")\n          .append(\"  <value>HADOOP_MAPRED_HOME=${full path of your hadoop \"\n              + \"distribution directory}</value>\\n\")\n          .append(\"</property>\\n\");\n    }\n    return analysis.toString();\n  }\n  protected String getPidFileSubpath(String appIdStr, String containerIdStr) {\n    return getContainerPrivateDir(appIdStr, containerIdStr) + Path.SEPARATOR\n        + String.format(ContainerLaunch.PID_FILE_NAME_FMT, containerIdStr);\n  }\n  /**\n   * Send a signal to the container.\n   *\n   *\n   * @throws IOException\n   */\n  public void signalContainer(SignalContainerCommand command)\n      throws IOException {\n    ContainerId containerId =\n        container.getContainerTokenIdentifier().getContainerID();\n    String containerIdStr = containerId.toString();\n    String user = container.getUser();\n    Signal signal = translateCommandToSignal(command);\n    if (signal.equals(Signal.NULL)) {\n      LOG.info(\"ignore signal command \" + command);\n      return;\n    }\n    LOG.info(\"Sending signal \" + command + \" to container \" + containerIdStr);\n    boolean alreadyLaunched =\n        !containerAlreadyLaunched.compareAndSet(false, true);\n    if (!alreadyLaunched) {\n      LOG.info(\"Container \" + containerIdStr + \" not launched.\"\n          + \" Not sending the signal\");\n      return;\n    }\n    LOG.debug(\"Getting pid for container {} to send signal to from pid\"\n        + \" file {}\", containerIdStr,\n        (pidFilePath != null ? pidFilePath.toString() : \"null\"));\n    try {\n      // get process id from pid file if available\n      // else if shell is still active, get it from the shell\n      String processId = getContainerPid();\n      if (processId != null) {\n        LOG.debug(\"Sending signal to pid {} as user {} for container {}\",\n            processId, user, containerIdStr);\n        boolean result = exec.signalContainer(\n            new ContainerSignalContext.Builder()\n                .setContainer(container)\n                .setUser(user)\n                .setPid(processId)\n                .setSignal(signal)\n                .build());\n        String diagnostics = \"Sent signal \" + command\n            + \" (\" + signal + \") to pid \" + processId\n            + \" as user \" + user\n            + \" for container \" + containerIdStr\n            + \", result=\" + (result ? \"success\" : \"failed\");\n        LOG.info(diagnostics);\n        dispatcher.getEventHandler().handle(\n            new ContainerDiagnosticsUpdateEvent(containerId, diagnostics));\n      }\n    } catch (Exception e) {\n      String message =\n          \"Exception when sending signal to container \" + containerIdStr\n              + \": \" + StringUtils.stringifyException(e);\n      LOG.warn(message);\n    }\n  }\n  @VisibleForTesting\n  public static Signal translateCommandToSignal(\n      SignalContainerCommand command) {\n    Signal signal = Signal.NULL;\n    switch (command) {\n      case OUTPUT_THREAD_DUMP:\n        // TODO for windows support.\n        signal = Shell.WINDOWS ? Signal.NULL: Signal.QUIT;\n        break;\n      case GRACEFUL_SHUTDOWN:\n        signal = Signal.TERM;\n        break;\n      case FORCEFUL_SHUTDOWN:\n        signal = Signal.KILL;\n        break;\n    }\n    return signal;\n  }\n  /**\n   * Pause the container.\n   * Cancels the launch if the container isn't launched yet. Otherwise asks the\n   * executor to pause the container.\n   * @throws IOException in case of errors.\n   */\n  public void pauseContainer() throws IOException {\n    ContainerId containerId = container.getContainerId();\n    String containerIdStr = containerId.toString();\n    LOG.info(\"Pausing the container \" + containerIdStr);\n    // The pause event is only handled if the container is in the running state\n    // (the container state machine), so we don't check for\n    // shouldLaunchContainer over here\n    if (!shouldPauseContainer.compareAndSet(false, true)) {\n      LOG.info(\"Container \" + containerId + \" not paused as \"\n          + \"resume already called\");\n      return;\n    }\n    try {\n      // Pause the container\n      exec.pauseContainer(container);\n      // PauseContainer is a blocking call. We are here almost means the\n      // container is paused, so send out the event.\n      dispatcher.getEventHandler().handle(new ContainerEvent(\n          containerId,\n          ContainerEventType.CONTAINER_PAUSED));\n      try {\n        this.context.getNMStateStore().storeContainerPaused(\n            container.getContainerId());\n      } catch (IOException e) {\n        LOG.warn(\"Could not store container [\" + container.getContainerId()\n            + \"] state. The Container has been paused.\", e);\n      }\n    } catch (Exception e) {\n      String message =\n          \"Exception when trying to pause container \" + containerIdStr\n              + \": \" + StringUtils.stringifyException(e);\n      LOG.info(message);\n      container.handle(new ContainerKillEvent(container.getContainerId(),\n          ContainerExitStatus.PREEMPTED, \"Container preempted as there was \"\n          + \" an exception in pausing it.\"));\n    }\n  }\n  /**\n   * Resume the container.\n   * Cancels the launch if the container isn't launched yet. Otherwise asks the\n   * executor to pause the container.\n   * @throws IOException in case of error.\n   */\n  public void resumeContainer() throws IOException {\n    ContainerId containerId = container.getContainerId();\n    String containerIdStr = containerId.toString();\n    LOG.info(\"Resuming the container \" + containerIdStr);\n    // The resume event is only handled if the container is in a paused state\n    // so we don't check for the launched flag here.\n    // paused flag will be set to true if process already paused\n    boolean alreadyPaused = !shouldPauseContainer.compareAndSet(false, true);\n    if (!alreadyPaused) {\n      LOG.info(\"Container \" + containerIdStr + \" not paused.\"\n          + \" No resume necessary\");\n      return;\n    }\n    // If the container has already started\n    try {\n      exec.resumeContainer(container);\n      // ResumeContainer is a blocking call. We are here almost means the\n      // container is resumed, so send out the event.\n      dispatcher.getEventHandler().handle(new ContainerEvent(\n          containerId,\n          ContainerEventType.CONTAINER_RESUMED));\n      try {\n        this.context.getNMStateStore().removeContainerPaused(\n            container.getContainerId());\n      } catch (IOException e) {\n        LOG.warn(\"Could not store container [\" + container.getContainerId()\n            + \"] state. The Container has been resumed.\", e);\n      }\n    } catch (Exception e) {\n      String message =\n          \"Exception when trying to resume container \" + containerIdStr\n              + \": \" + StringUtils.stringifyException(e);\n      LOG.info(message);\n      container.handle(new ContainerKillEvent(container.getContainerId(),\n          ContainerExitStatus.PREEMPTED, \"Container preempted as there was \"\n          + \" an exception in pausing it.\"));\n    }\n  }\n  /**\n   * Loop through for a time-bounded interval waiting to\n   * read the process id from a file generated by a running process.\n   * @return Process ID; null when pidFilePath is null\n   * @throws Exception\n   */\n  String getContainerPid() throws Exception {\n    if (pidFilePath == null) {\n      return null;\n    }\n    String containerIdStr = \n        container.getContainerId().toString();\n    String processId;\n    LOG.debug(\"Accessing pid for container {} from pid file {}\",\n        containerIdStr, pidFilePath);\n    int sleepCounter = 0;\n    final int sleepInterval = 100;\n    // loop waiting for pid file to show up \n    // until our timer expires in which case we admit defeat\n    while (true) {\n      processId = ProcessIdFileReader.getProcessId(pidFilePath);\n      if (processId != null) {\n        LOG.debug(\"Got pid {} for container {}\", processId, containerIdStr);\n        break;\n      }\n      else if ((sleepCounter*sleepInterval) > maxKillWaitTime) {\n        LOG.info(\"Could not get pid for \" + containerIdStr\n        \t\t+ \". Waited for \" + maxKillWaitTime + \" ms.\");\n        break;\n      }\n      else {\n        ++sleepCounter;\n        Thread.sleep(sleepInterval);\n      }\n    }\n    return processId;\n  }\n  public static String getRelativeContainerLogDir(String appIdStr,\n      String containerIdStr) {\n    return appIdStr + Path.SEPARATOR + containerIdStr;\n  }\n<fim_suffix>  protected String getContainerPrivateDir(String appIdStr,\n      String containerIdStr) {\n    return getAppPrivateDir(appIdStr) + Path.SEPARATOR + containerIdStr\n        + Path.SEPARATOR;\n  }<fim_middle>// function below has no smell\n"}