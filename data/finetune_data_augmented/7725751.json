{"text": "<fim_prefix>public class ContainerHostUtil {\n    public static final String CONTAINER_HOST_TYPE_NOT_SUPPORTED_MESSAGE_FORMAT = \"Container \"\n            + \"host type '%s' is not supported\";\n    public static final String CONTAINER_HOST_TYPE_NOT_SUPPORTED_MESSAGE_CODE = \"compute.host.type.not.supported\";\n    public static final String VCH_VERSION_NOT_SUPPORTED_MESSAGE_FORMAT = \"VCH version (%s) is not supported.\";\n    public static final String VCH_VERSION_NOT_SUPPORTED_MESSAGE_CODE = \"compute.host.vch.version.not.supported\";\n    public static final String PROPERTY_NAME_DRIVER = \"__Driver\";\n    public static final String VMWARE_VIC_DRIVER1 = \"vmware\";\n    public static final String VMWARE_VIC_DRIVER2 = \"vsphere\";\n    public static final String PROPERTY_NAME_SERVER_VERSION = \"__ServerVersion\";\n    private static final String FEATURE_TOGGLE_HOST_PUBLIC_ADDRESS = \"allow.ft.hosts.public-address\";\n    private static final Logger logger = Logger.getLogger(ContainerHostUtil.class.getName());\n    /**\n     * Check if this host is a scheduler host (e.g. VIC, Kubernetes)\n     *\n     * @param computeState\n     * @return boolean value\n     */\n    public static boolean isSchedulerHost(ComputeState computeState) {\n        return ContainerHostUtil.isVicHost(computeState)\n                || ContainerHostUtil.isKubernetesHost(computeState);\n    }\n    /**\n     * Check if this host should be treated as scheduler host. Note that a host may be a scheduler\n     * (e.g. VIC, Kubernetes) but it may be declared as plain docker host and in this case the host\n     * should be treated as a plain docker host\n     *\n     * @param computeState\n     * @return boolean value\n     */\n    public static boolean isTreatedLikeSchedulerHost(ComputeState computeState) {\n        return getDeclaredContainerHostType(computeState) != ContainerHostType.DOCKER;\n    }\n    public static ContainerHostType getDeclaredContainerHostType(ComputeState computeState) {\n        AssertUtil.assertNotNull(computeState, \"computeState\");\n        if (computeState.customProperties == null) {\n            return ContainerHostType.getDefaultHostType();\n        }\n        String hostTypeRaw = computeState.customProperties\n                .get(ContainerHostService.CONTAINER_HOST_TYPE_PROP_NAME);\n        if (hostTypeRaw == null) {\n            return ContainerHostType.getDefaultHostType();\n        }\n        try {\n            return ContainerHostType.valueOf(hostTypeRaw);\n        } catch (IllegalArgumentException ex) {\n            String error = String.format(CONTAINER_HOST_TYPE_NOT_SUPPORTED_MESSAGE_FORMAT,\n                    hostTypeRaw);\n            throw new LocalizableValidationException(ex, error,\n                    CONTAINER_HOST_TYPE_NOT_SUPPORTED_MESSAGE_CODE, hostTypeRaw);\n        }\n    }\n    public static List<ContainerHostType> getContainerHostTypesForResourceType(\n            ResourceType resourceType) {\n        switch (resourceType) {\n        case KUBERNETES_GENERIC_TYPE:\n        case KUBERNETES_DEPLOYMENT_TYPE:\n        case KUBERNETES_POD_TYPE:\n        case KUBERNETES_REPLICATION_CONTROLLER_TYPE:\n        case KUBERNETES_SERVICE_TYPE:\n            return Collections.singletonList(ContainerHostType.KUBERNETES);\n        default:\n            return Arrays.asList(ContainerHostType.DOCKER, ContainerHostType.VCH);\n        }\n    }\n    /**\n     * Check if docker is running on VMware Integrated Container host.\n     *\n     * @param computeState\n     *            host to check\n     * @return boolean value\n     */\n    public static boolean isVicHost(ComputeState computeState) {\n        boolean vic = false;\n        String driver = getDriver(computeState);\n        driver = driver != null ? driver.toLowerCase().trim() : \"\";\n        vic = driver.startsWith(VMWARE_VIC_DRIVER1) || driver.startsWith(VMWARE_VIC_DRIVER2);\n        return vic;\n    }\n    /**\n     * Returns the server version that is reported on <code>docker info</code> command.\n     */\n    public static String getHostServerVersion(ComputeState computeState) {\n        if (computeState != null && computeState.customProperties != null) {\n            return computeState.customProperties.get(PROPERTY_NAME_SERVER_VERSION);\n        }\n        return null;\n    }\n    /**\n     * Fetches the minimum (inclusive) and maximum (exclusive) supported versions for VCH and checks\n     * whether the version provided is supported. If it is, the returned {@link DeferredResult} will\n     * be completed. Otherwise, it will be failed. Applies to embedded mode only. If Admiral is not\n     * run in embedded mode, every VCH version will be accepted.\n     */\n    public static DeferredResult<Void> verifyVchVersionIsSupported(ServiceHost serviceHost,\n            String vchVersion) {\n        if (!ConfigurationUtil.isEmbedded()) {\n            return DeferredResult.completed(null);\n        }\n        if (vchVersion == null || vchVersion.trim().isEmpty()) {\n            String error = String.format(VCH_VERSION_NOT_SUPPORTED_MESSAGE_FORMAT, \"unknown\");\n            return DeferredResult.failed(new LocalizableValidationException(error,\n                    VCH_VERSION_NOT_SUPPORTED_MESSAGE_CODE, \"unknown\"));\n        }\n        DeferredResult<Void> deferredResult = new DeferredResult<>();\n        ConfigurationUtil.getConfigProperty(serviceHost,\n                ConfigurationUtil.VCH_MIN_VERSION_INCLUSIVE_PROPERTY,\n                (minVersionInclusive) -> {\n                    ConfigurationUtil.getConfigProperty(serviceHost,\n                            ConfigurationUtil.VCH_MAX_VERSION_EXCLUSIVE_PROPERTY,\n                            (maxVersionExclusive) -> {\n                                if (isSupportedVchVersion(vchVersion, minVersionInclusive,\n                                        maxVersionExclusive)) {\n                                    deferredResult.complete(null);\n                                    return;\n                                }\n                                String error = String.format(\n                                        VCH_VERSION_NOT_SUPPORTED_MESSAGE_FORMAT, vchVersion);\n                                deferredResult.fail(new LocalizableValidationException(error,\n                                        VCH_VERSION_NOT_SUPPORTED_MESSAGE_CODE, vchVersion));\n                            });\n                });\n        return deferredResult;\n    }\n    protected static boolean isSupportedVchVersion(String vchVersion, String minVersionInclusive,\n            String maxVersionExclusive) {\n        try {\n            if (minVersionInclusive != null\n                    && !minVersionInclusive.isEmpty()\n                    && VersionUtil.compareRawVersions(vchVersion, minVersionInclusive) < 0) {\n                return false;\n            }\n        } catch (IllegalArgumentException ex) {\n            logger.log(Level.WARNING,\n                    String.format(\n                            \"Failed to compare VCH version [%s] with minimum supported version [%s (inclusive)]\",\n                            vchVersion, minVersionInclusive));\n            return false;\n        }\n        try {\n            if (maxVersionExclusive != null\n                    && !maxVersionExclusive.isEmpty()\n                    && VersionUtil.compareRawVersions(vchVersion, maxVersionExclusive) >= 0) {\n                return false;\n            }\n        } catch (IllegalArgumentException ex) {\n            logger.log(Level.WARNING,\n                    String.format(\n                            \"Failed to compare VCH version [%s] with maximum supported version [%s (exclusive)]\",\n                            vchVersion, maxVersionExclusive));\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Check if host is running Kubernetes.\n     *\n     * @param computeState\n     *            host to check\n     * @return boolean value\n     */\n    public static boolean isKubernetesHost(ComputeState computeState) {\n        if (computeState == null || computeState.customProperties == null) {\n            return false;\n        }\n        String hostType = computeState.customProperties.get(\n                ContainerHostService.CONTAINER_HOST_TYPE_PROP_NAME);\n        return (hostType != null && hostType.equals(ContainerHostType.KUBERNETES.name()));\n    }\n    /**\n     * Gets driver property value from host custom properties.\n     */\n    public static String getDriver(ComputeState computeState) {\n        if (computeState != null && computeState.customProperties != null) {\n            return computeState.customProperties.get(PROPERTY_NAME_DRIVER);\n        }\n        return null;\n    }\n    /**\n     * Gets trust alias property value from host custom properties.\n     */\n    public static String getTrustAlias(ComputeState computeState) {\n        if (computeState != null && computeState.customProperties != null) {\n            return computeState.customProperties\n                    .get(ContainerHostService.SSL_TRUST_ALIAS_PROP_NAME);\n        }\n        return null;\n    }\n    /**\n     * Returns whether the trust alias should be set and it is not (e.g. because the upgrade of an\n     * instance with hosts already configured)\n     */\n<fim_suffix>    public static boolean isTrustAliasMissing(ComputeState computeState) {\n        URI hostUri = ContainerDescription.getDockerHostUri(computeState);\n        return UriUtils.HTTPS_SCHEME.equalsIgnoreCase(hostUri.getScheme())\n                && (getTrustAlias(computeState) == null);\n    }<fim_middle>// function below has no smell\n"}