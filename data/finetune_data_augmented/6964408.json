{"text": "<fim_prefix>/*\n * Copyright (C) 2007 The Guava Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.common.collect;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport com.google.common.annotations.GwtCompatible;\nimport com.google.common.annotations.GwtIncompatible;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.j2objc.annotations.RetainedWith;\nimport java.io.IOException;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.NavigableMap;\nimport java.util.NavigableSet;\nimport java.util.Queue;\nimport java.util.RandomAccess;\nimport java.util.Set;\nimport java.util.SortedMap;\nimport java.util.SortedSet;\nimport java.util.Spliterator;\nimport java.util.function.BiConsumer;\nimport java.util.function.BiFunction;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.function.UnaryOperator;\nimport java.util.stream.Stream;\nimport org.checkerframework.checker.nullness.qual.MonotonicNonNull;\nimport org.checkerframework.checker.nullness.qual.Nullable;\n/**\n * Synchronized collection views. The returned synchronized collection views are serializable if the\n * backing collection and the mutex are serializable.\n *\n * <p>If {@code null} is passed as the {@code mutex} parameter to any of this class's top-level\n * methods or inner class constructors, the created object uses itself as the synchronization mutex.\n *\n * <p>This class should be used by other collection classes only.\n *\n * @author Mike Bostock\n * @author Jared Levy\n */\n@GwtCompatible(emulated = true)\nfinal class Synchronized {\n  private Synchronized() {}\n  static class SynchronizedObject implements Serializable {\n    final Object delegate;\n    final Object mutex;\n    SynchronizedObject(Object delegate, @Nullable Object mutex) {\n      this.delegate = checkNotNull(delegate);\n      this.mutex = (mutex == null) ? this : mutex;\n    }\n    Object delegate() {\n      return delegate;\n    }\n    // No equals and hashCode; see ForwardingObject for details.\n    @Override\n    public String toString() {\n      synchronized (mutex) {\n        return delegate.toString();\n      }\n    }\n    // Serialization invokes writeObject only when it's private.\n    // The SynchronizedObject subclasses don't need a writeObject method since\n    // they don't contain any non-transient member variables, while the\n    // following writeObject() handles the SynchronizedObject members.\n    @GwtIncompatible // java.io.ObjectOutputStream\n    private void writeObject(ObjectOutputStream stream) throws IOException {\n      synchronized (mutex) {\n        stream.defaultWriteObject();\n      }\n    }\n    @GwtIncompatible // not needed in emulated source\n    private static final long serialVersionUID = 0;\n  }\n  private static <E> Collection<E> collection(Collection<E> collection, @Nullable Object mutex) {\n    return new SynchronizedCollection<E>(collection, mutex);\n  }\n  @VisibleForTesting\n  static class SynchronizedCollection<E> extends SynchronizedObject implements Collection<E> {\n    private SynchronizedCollection(Collection<E> delegate, @Nullable Object mutex) {\n      super(delegate, mutex);\n    }\n    @SuppressWarnings(\"unchecked\")\n    @Override\n    Collection<E> delegate() {\n      return (Collection<E>) super.delegate();\n    }\n    @Override\n    public boolean add(E e) {\n      synchronized (mutex) {\n        return delegate().add(e);\n      }\n    }\n    @Override\n    public boolean addAll(Collection<? extends E> c) {\n      synchronized (mutex) {\n        return delegate().addAll(c);\n      }\n    }\n    @Override\n    public void clear() {\n      synchronized (mutex) {\n        delegate().clear();\n      }\n    }\n    @Override\n    public boolean contains(Object o) {\n      synchronized (mutex) {\n        return delegate().contains(o);\n      }\n    }\n    @Override\n    public boolean containsAll(Collection<?> c) {\n      synchronized (mutex) {\n        return delegate().containsAll(c);\n      }\n    }\n    @Override\n    public boolean isEmpty() {\n      synchronized (mutex) {\n        return delegate().isEmpty();\n      }\n    }\n    @Override\n    public Iterator<E> iterator() {\n      return delegate().iterator(); // manually synchronized\n    }\n    @Override\n    public Spliterator<E> spliterator() {\n      synchronized (mutex) {\n        return delegate().spliterator();\n      }\n    }\n    @Override\n    public Stream<E> stream() {\n      synchronized (mutex) {\n        return delegate().stream();\n      }\n    }\n    @Override\n    public Stream<E> parallelStream() {\n      synchronized (mutex) {\n        return delegate().parallelStream();\n      }\n    }\n<fim_suffix>    @Override\n    public void forEach(Consumer<? super E> action) {\n      synchronized (mutex) {\n        delegate().forEach(action);\n      }\n    }\n    @Override\n    public boolean remove(Object o) {\n      synchronized (mutex) {\n        return delegate().remove(o);\n      }\n    }\n    @Override\n    public boolean removeAll(Collection<?> c) {\n      synchronized (mutex) {\n        return delegate().removeAll(c);\n      }\n    }\n    @Override\n    public boolean retainAll(Collection<?> c) {\n      synchronized (mutex) {\n        return delegate().retainAll(c);\n      }\n    }\n    @Override\n    public boolean removeIf(Predicate<? super E> filter) {\n      synchronized (mutex) {\n        return delegate().removeIf(filter);\n      }\n    }\n    @Override\n    public int size() {\n      synchronized (mutex) {\n        return delegate().size();\n      }\n    }\n    @Override\n    public Object[] toArray() {\n      synchronized (mutex) {\n        return delegate().toArray();\n      }\n    }\n    @Override\n    public <T> T[] toArray(T[] a) {\n      synchronized (mutex) {\n        return delegate().toArray(a);\n      }\n    }\n    private static final long serialVersionUID = 0;\n  }\n  @VisibleForTesting\n  static <E> Set<E> set(Set<E> set, @Nullable Object mutex) {\n    return new SynchronizedSet<E>(set, mutex);\n  }\n  static class SynchronizedSet<E> extends SynchronizedCollection<E> implements Set<E> {\n    SynchronizedSet(Set<E> delegate, @Nullable Object mutex) {\n      super(delegate, mutex);\n    }\n    @Override\n    Set<E> delegate() {\n      return (Set<E>) super.delegate();\n    }\n    @Override\n    public boolean equals(Object o) {\n      if (o == this) {\n        return true;\n      }\n      synchronized (mutex) {\n        return delegate().equals(o);\n      }\n    }\n    @Override\n    public int hashCode() {\n      synchronized (mutex) {\n        return delegate().hashCode();\n      }\n    }\n    private static final long serialVersionUID = 0;\n  }\n  private static <E> SortedSet<E> sortedSet(SortedSet<E> set, @Nullable Object mutex) {\n    return new SynchronizedSortedSet<E>(set, mutex);\n  }\n  static class SynchronizedSortedSet<E> extends SynchronizedSet<E> implements SortedSet<E> {\n    SynchronizedSortedSet(SortedSet<E> delegate, @Nullable Object mutex) {\n      super(delegate, mutex);\n    }\n    @Override\n    SortedSet<E> delegate() {\n      return (SortedSet<E>) super.delegate();\n    }\n    @Override\n    public Comparator<? super E> comparator() {\n      synchronized (mutex) {\n        return delegate().comparator();\n      }\n    }\n    @Override\n    public SortedSet<E> subSet(E fromElement, E toElement) {\n      synchronized (mutex) {\n        return sortedSet(delegate().subSet(fromElement, toElement), mutex);\n      }\n    }\n    @Override\n    public SortedSet<E> headSet(E toElement) {\n      synchronized (mutex) {\n        return sortedSet(delegate().headSet(toElement), mutex);\n      }\n    }\n    @Override\n    public SortedSet<E> tailSet(E fromElement) {\n      synchronized (mutex) {\n        return sortedSet(delegate().tailSet(fromElement), mutex);\n      }\n    }\n    @Override<fim_middle>// function below has no smell\n"}