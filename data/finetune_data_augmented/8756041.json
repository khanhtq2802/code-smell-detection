{"text": "<fim_prefix>    this.context = context;\n    this.containersToBeAdded = new HashMap<ContainerId, ProcessTreeInfo>();\n    this.containersToBeRemoved = new ArrayList<ContainerId>();\n    this.monitoringThread = new MonitoringThread();\n  }\n  @Override\n  protected void serviceInit(Configuration conf) throws Exception {\n    this.monitoringInterval =\n        conf.getLong(YarnConfiguration.NM_CONTAINER_MON_INTERVAL_MS,\n            YarnConfiguration.DEFAULT_NM_CONTAINER_MON_INTERVAL_MS);\n    Class<? extends ResourceCalculatorPlugin> clazz =\n        conf.getClass(YarnConfiguration.NM_CONTAINER_MON_RESOURCE_CALCULATOR, null,\n            ResourceCalculatorPlugin.class);\n    this.resourceCalculatorPlugin =\n        ResourceCalculatorPlugin.getResourceCalculatorPlugin(clazz, conf);\n    LOG.info(\" Using ResourceCalculatorPlugin : \"\n        + this.resourceCalculatorPlugin);\n    processTreeClass = conf.getClass(YarnConfiguration.NM_CONTAINER_MON_PROCESS_TREE, null,\n            ResourceCalculatorProcessTree.class);\n    this.conf = conf;\n    LOG.info(\" Using ResourceCalculatorProcessTree : \"\n        + this.processTreeClass);\n    long configuredPMemForContainers = conf.getLong(\n        YarnConfiguration.NM_PMEM_MB,\n        YarnConfiguration.DEFAULT_NM_PMEM_MB) * 1024 * 1024l;\n    long configuredVCoresForContainers = conf.getLong(\n        YarnConfiguration.NM_VCORES,\n        YarnConfiguration.DEFAULT_NM_VCORES);\n    // Setting these irrespective of whether checks are enabled. Required in\n    // the UI.\n    // ///////// Physical memory configuration //////\n    this.maxPmemAllottedForContainers = configuredPMemForContainers;\n    this.maxVCoresAllottedForContainers = configuredVCoresForContainers;\n    // ///////// Virtual memory configuration //////\n    float vmemRatio = conf.getFloat(YarnConfiguration.NM_VMEM_PMEM_RATIO,\n        YarnConfiguration.DEFAULT_NM_VMEM_PMEM_RATIO);\n    Preconditions.checkArgument(vmemRatio > 0.99f,\n        YarnConfiguration.NM_VMEM_PMEM_RATIO + \" should be at least 1.0\");\n    this.maxVmemAllottedForContainers =\n        (long) (vmemRatio * configuredPMemForContainers);\n    pmemCheckEnabled = conf.getBoolean(YarnConfiguration.NM_PMEM_CHECK_ENABLED,\n        YarnConfiguration.DEFAULT_NM_PMEM_CHECK_ENABLED);\n    vmemCheckEnabled = conf.getBoolean(YarnConfiguration.NM_VMEM_CHECK_ENABLED,\n        YarnConfiguration.DEFAULT_NM_VMEM_CHECK_ENABLED);\n    LOG.info(\"Physical memory check enabled: \" + pmemCheckEnabled);\n    LOG.info(\"Virtual memory check enabled: \" + vmemCheckEnabled);\n    if (pmemCheckEnabled) {\n      // Logging if actual pmem cannot be determined.\n      long totalPhysicalMemoryOnNM = UNKNOWN_MEMORY_LIMIT;\n      if (this.resourceCalculatorPlugin != null) {\n        totalPhysicalMemoryOnNM = this.resourceCalculatorPlugin\n            .getPhysicalMemorySize();\n        if (totalPhysicalMemoryOnNM <= 0) {\n          LOG.warn(\"NodeManager's totalPmem could not be calculated. \"\n              + \"Setting it to \" + UNKNOWN_MEMORY_LIMIT);\n          totalPhysicalMemoryOnNM = UNKNOWN_MEMORY_LIMIT;\n        }\n      }\n      if (totalPhysicalMemoryOnNM != UNKNOWN_MEMORY_LIMIT &&\n          this.maxPmemAllottedForContainers > totalPhysicalMemoryOnNM * 0.80f) {\n        LOG.warn(\"NodeManager configured with \"\n            + TraditionalBinaryPrefix.long2String(maxPmemAllottedForContainers,\n                \"\", 1)\n            + \" physical memory allocated to containers, which is more than \"\n            + \"80% of the total physical memory available (\"\n            + TraditionalBinaryPrefix.long2String(totalPhysicalMemoryOnNM, \"\",\n                1) + \"). Thrashing might happen.\");\n      }\n    }\n    super.serviceInit(conf);\n  }\n  private boolean isEnabled() {\n    if (resourceCalculatorPlugin == null) {\n            LOG.info(\"ResourceCalculatorPlugin is unavailable on this system. \"\n                + this.getClass().getName() + \" is disabled.\");\n            return false;\n    }\n    if (ResourceCalculatorProcessTree.getResourceCalculatorProcessTree(\"0\", processTreeClass, conf) == null) {\n        LOG.info(\"ResourceCalculatorProcessTree is unavailable on this system. \"\n                + this.getClass().getName() + \" is disabled.\");\n            return false;\n    }\n    if (!(isPmemCheckEnabled() || isVmemCheckEnabled())) {\n      LOG.info(\"Neither virutal-memory nor physical-memory monitoring is \" +\n          \"needed. Not running the monitor-thread\");\n      return false;\n    }\n    return true;\n  }\n  @Override\n  protected void serviceStart() throws Exception {\n    if (this.isEnabled()) {\n      this.monitoringThread.start();\n    }\n    super.serviceStart();\n  }\n  @Override\n  protected void serviceStop() throws Exception {\n    if (this.isEnabled()) {\n      this.monitoringThread.interrupt();\n      try {\n        this.monitoringThread.join();\n      } catch (InterruptedException e) {\n        ;\n      }\n    }\n    super.serviceStop();\n  }\n  private static class ProcessTreeInfo {\n    private ContainerId containerId;\n    private String pid;\n    private ResourceCalculatorProcessTree pTree;\n    private long vmemLimit;\n    private long pmemLimit;\n    public ProcessTreeInfo(ContainerId containerId, String pid,\n        ResourceCalculatorProcessTree pTree, long vmemLimit, long pmemLimit) {\n      this.containerId = containerId;\n      this.pid = pid;\n      this.pTree = pTree;\n      this.vmemLimit = vmemLimit;\n      this.pmemLimit = pmemLimit;\n    }\n    public ContainerId getContainerId() {\n      return this.containerId;\n    }\n    public String getPID() {\n      return this.pid;\n    }\n    public void setPid(String pid) {\n      this.pid = pid;\n    }\n    public ResourceCalculatorProcessTree getProcessTree() {\n      return this.pTree;\n    }\n    public void setProcessTree(ResourceCalculatorProcessTree pTree) {\n      this.pTree = pTree;\n    }\n    public long getVmemLimit() {\n      return this.vmemLimit;\n    }\n    /**\n     * @return Physical memory limit for the process tree in bytes\n     */\n    public long getPmemLimit() {\n      return this.pmemLimit;\n    }\n  }\n  /**\n   * Check whether a container's process tree's current memory usage is over\n   * limit.\n   *\n   * When a java process exec's a program, it could momentarily account for\n   * double the size of it's memory, because the JVM does a fork()+exec()\n   * which at fork time creates a copy of the parent's memory. If the\n   * monitoring thread detects the memory used by the container tree at the\n   * same instance, it could assume it is over limit and kill the tree, for no\n   * fault of the process itself.\n   *\n   * We counter this problem by employing a heuristic check: - if a process\n   * tree exceeds the memory limit by more than twice, it is killed\n   * immediately - if a process tree has processes older than the monitoring\n   * interval exceeding the memory limit by even 1 time, it is killed. Else it\n   * is given the benefit of doubt to lie around for one more iteration.\n   *\n   * @param containerId\n   *          Container Id for the container tree\n   * @param currentMemUsage\n   *          Memory usage of a container tree\n   * @param curMemUsageOfAgedProcesses\n   *          Memory usage of processes older than an iteration in a container\n   *          tree\n   * @param vmemLimit\n   *          The limit specified for the container\n   * @return true if the memory usage is more than twice the specified limit,\n   *         or if processes in the tree, older than this thread's monitoring\n   *         interval, exceed the memory limit. False, otherwise.\n   */\n<fim_suffix>  boolean isProcessTreeOverLimit(String containerId,\n                                  long currentMemUsage,\n                                  long curMemUsageOfAgedProcesses,\n                                  long vmemLimit) {\n    boolean isOverLimit = false;\n    if (currentMemUsage > (2 * vmemLimit)) {\n      LOG.warn(\"Process tree for container: \" + containerId\n          + \" running over twice \" + \"the configured limit. Limit=\" + vmemLimit\n          + \", current usage = \" + currentMemUsage);\n      isOverLimit = true;\n    } else if (curMemUsageOfAgedProcesses > vmemLimit) {\n      LOG.warn(\"Process tree for container: \" + containerId\n          + \" has processes older than 1 \"\n          + \"iteration running over the configured limit. Limit=\" + vmemLimit\n          + \", current usage = \" + curMemUsageOfAgedProcesses);\n      isOverLimit = true;\n    }\n    return isOverLimit;\n  }<fim_middle>// function below has no smell\n"}