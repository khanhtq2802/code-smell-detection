{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.shardingsphere.shardingproxy.backend.schema;\n\nimport com.google.common.eventbus.Subscribe;\nimport lombok.Getter;\nimport org.apache.shardingsphere.api.config.sharding.ShardingRuleConfiguration;\nimport org.apache.shardingsphere.core.metadata.ShardingMetaData;\nimport org.apache.shardingsphere.core.metadata.datasource.ShardingDataSourceMetaData;\nimport org.apache.shardingsphere.core.metadata.table.ShardingTableMetaData;\nimport org.apache.shardingsphere.core.parse.antlr.sql.statement.ddl.AlterTableStatement;\nimport org.apache.shardingsphere.core.parse.antlr.sql.statement.ddl.CreateTableStatement;\nimport org.apache.shardingsphere.core.parse.antlr.sql.statement.ddl.DropTableStatement;\nimport org.apache.shardingsphere.core.parse.parser.sql.SQLStatement;\nimport org.apache.shardingsphere.core.rule.MasterSlaveRule;\nimport org.apache.shardingsphere.core.rule.ShardingRule;\nimport org.apache.shardingsphere.orchestration.internal.registry.config.event.ShardingRuleChangedEvent;\nimport org.apache.shardingsphere.orchestration.internal.registry.state.event.DisabledStateChangedEvent;\nimport org.apache.shardingsphere.orchestration.internal.registry.state.schema.OrchestrationShardingSchema;\nimport org.apache.shardingsphere.orchestration.internal.rule.OrchestrationMasterSlaveRule;\nimport org.apache.shardingsphere.orchestration.internal.rule.OrchestrationShardingRule;\nimport org.apache.shardingsphere.shardingproxy.config.yaml.YamlDataSourceParameter;\n\nimport java.util.Collection;\nimport java.util.Map;\n\n/**\n * Sharding schema.\n *\n * @author zhangliang\n * @author zhangyonglun\n * @author panjuan\n * @author zhaojun\n * @author wangkai\n */\n<fim_suffix>@Getter\npublic final class ShardingSchema extends LogicSchema {\n    \n    private ShardingRule shardingRule;\n    \n    private final ShardingMetaData metaData;\n    \n    public ShardingSchema(final String name, final Map<String, YamlDataSourceParameter> dataSources, final ShardingRuleConfiguration shardingRuleConfig, final boolean isUsingRegistry) {\n        super(name, dataSources);\n        shardingRule = createShardingRule(shardingRuleConfig, dataSources.keySet(), isUsingRegistry);\n        metaData = createShardingMetaData();\n    }\n    \n    private ShardingRule createShardingRule(final ShardingRuleConfiguration shardingRuleConfig, final Collection<String> dataSourceNames, final boolean isUsingRegistry) {\n        return isUsingRegistry ? new OrchestrationShardingRule(shardingRuleConfig, dataSourceNames) : new ShardingRule(shardingRuleConfig, dataSourceNames);\n    }\n    \n    private ShardingMetaData createShardingMetaData() {\n        ShardingDataSourceMetaData shardingDataSourceMetaData = new ShardingDataSourceMetaData(getDataSourceURLs(getDataSources()), shardingRule, LogicSchemas.getInstance().getDatabaseType());\n        ShardingTableMetaData shardingTableMetaData = new ShardingTableMetaData(getTableMetaDataInitializer(shardingDataSourceMetaData).load(shardingRule));\n        return new ShardingMetaData(shardingDataSourceMetaData, shardingTableMetaData);\n    }\n    \n    /**\n     * Renew sharding rule.\n     *\n     * @param shardingRuleChangedEvent sharding rule changed event.\n     */\n    @Subscribe\n    public synchronized void renew(final ShardingRuleChangedEvent shardingRuleChangedEvent) {\n        if (getName().equals(shardingRuleChangedEvent.getShardingSchemaName())) {\n            shardingRule = new OrchestrationShardingRule(shardingRuleChangedEvent.getShardingRuleConfiguration(), getDataSources().keySet());\n        }\n    }\n    \n    /**\n     * Renew disabled data source names.\n     *\n     * @param disabledStateChangedEvent disabled state changed event\n     */\n    @Subscribe\n    public synchronized void renew(final DisabledStateChangedEvent disabledStateChangedEvent) {\n        OrchestrationShardingSchema shardingSchema = disabledStateChangedEvent.getShardingSchema();\n        if (getName().equals(shardingSchema.getSchemaName())) {\n            for (MasterSlaveRule each : shardingRule.getMasterSlaveRules()) {\n                ((OrchestrationMasterSlaveRule) each).updateDisabledDataSourceNames(shardingSchema.getDataSourceName(), disabledStateChangedEvent.isDisabled());\n            }\n        }\n    }\n    \n    @Override\n    public void refreshTableMetaData(final SQLStatement sqlStatement) {\n        if (sqlStatement instanceof CreateTableStatement) {\n            refreshTableMetaData((CreateTableStatement) sqlStatement);\n        } else if (sqlStatement instanceof AlterTableStatement) {\n            refreshTableMetaData((AlterTableStatement) sqlStatement);\n        } else if (sqlStatement instanceof DropTableStatement) {\n            refreshTableMetaData((DropTableStatement) sqlStatement);\n        }\n    }\n    \n    private void refreshTableMetaData(final CreateTableStatement createTableStatement) {\n        String tableName = createTableStatement.getTables().getSingleTableName();\n        getMetaData().getTable().put(tableName, getTableMetaDataInitializer(metaData.getDataSource()).load(tableName, shardingRule));\n    }\n    \n    private void refreshTableMetaData(final AlterTableStatement alterTableStatement) {\n        String tableName = alterTableStatement.getTables().getSingleTableName();\n        getMetaData().getTable().put(tableName, getTableMetaDataInitializer(metaData.getDataSource()).load(tableName, shardingRule));\n    }\n    \n    private void refreshTableMetaData(final DropTableStatement dropTableStatement) {\n        for (String each : dropTableStatement.getTables().getTableNames()) {\n            getMetaData().getTable().remove(each);\n        }\n    }\n}<fim_middle>// class below has no smell\n"}