{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.deltaspike.core.impl.crypto;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\nimport java.util.Properties;\n\n\n/**\n * handle Encryption\n */\n<fim_suffix>public class DefaultCipherService\n{\n    private static final Charset UTF_8 = Charset.forName(\"UTF-8\");\n    private static final String HASH_ALGORITHM = \"SHA-256\";\n    private static final String CIPHER_ALGORITHM = \"AES\";\n\n    public String setMasterHash(String masterPassword, String masterSalt, boolean overwrite)\n        throws IOException\n    {\n        File masterFile = getMasterFile();\n        if (!masterFile.getParentFile().exists())\n        {\n            if (!masterFile.getParentFile().mkdirs())\n            {\n                throw new IOException(\"Can not create directory \" + masterFile.getParent());\n            }\n        }\n        String saltHash = byteToHex(secureHash(masterSalt));\n        String saltKey = byteToHex(secureHash(saltHash));\n\n        String encrypted = byteToHex(aesEncrypt(byteToHex(secureHash(masterPassword)), saltHash));\n\n\n        Properties keys = new Properties();\n        if (masterFile.exists())\n        {\n            keys = loadProperties(masterFile.toURI().toURL());\n        }\n\n        if (keys.get(saltKey) != null && !overwrite)\n        {\n            throw new IllegalStateException(\"MasterKey for hash \" + saltKey +\n                \" already exists. Forced overwrite option needed\");\n        }\n\n        keys.put(saltKey, encrypted);\n\n        keys.store(new FileOutputStream(masterFile), null);\n\n        return saltKey;\n    }\n\n    protected String getMasterKey(String masterSalt)\n    {\n        File masterFile = getMasterFile();\n        if (!masterFile.exists())\n        {\n            throw new IllegalStateException(\"Could not find master.hash file. Create a master password first!\");\n        }\n\n        try\n        {\n            String saltHash = byteToHex(secureHash(masterSalt));\n            String saltKey = byteToHex(secureHash(saltHash));\n\n            Properties keys = loadProperties(masterFile.toURI().toURL());\n\n            String encryptedMasterKey = (String) keys.get(saltKey);\n            if (encryptedMasterKey == null)\n            {\n                throw new IllegalStateException(\"Could not find master key for hash \" + saltKey +\n                    \". Create a master password first!\");\n            }\n\n            return aesDecrypt(hexToByte(encryptedMasterKey), saltHash);\n        }\n        catch (MalformedURLException e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public String encrypt(String cleartext, String masterSalt)\n    {\n        return byteToHex(aesEncrypt(cleartext, getMasterKey(masterSalt)));\n    }\n\n    public String decrypt(String encryptedValue, String masterSalt)\n    {\n        return aesDecrypt(hexToByte(encryptedValue), getMasterKey(masterSalt));\n    }\n\n    protected File getMasterFile()\n    {\n        String userHome = System.getProperty(\"user.home\");\n        if (userHome == null || userHome.isEmpty())\n        {\n            throw new IllegalStateException(\"Can not determine user home directory\");\n        }\n        return new File(userHome, \".deltaspike/master.hash\");\n    }\n\n\n    protected byte[] secureHash(String value)\n    {\n        try\n        {\n            MessageDigest md = MessageDigest.getInstance(HASH_ALGORITHM);\n            return md.digest(value.getBytes(UTF_8));\n        }\n        catch (NoSuchAlgorithmException e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n\n    /**\n     * performs an AES encryption of the given text with the given password key\n     */\n    public byte[] aesEncrypt(String valueToEncrypt, String key)\n    {\n        try\n        {\n            SecretKeySpec secretKeySpec = getSecretKeySpec(key);\n\n            Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);\n            cipher.init(Cipher.ENCRYPT_MODE, secretKeySpec);\n            return cipher.doFinal(valueToEncrypt.getBytes(UTF_8));\n        }\n        catch (Exception e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n\n    /**\n     * performs an AES decryption of the given text with the given key key\n     */\n    public String aesDecrypt(byte[] encryptedValue, String key)\n    {\n        try\n        {\n            SecretKeySpec secretKeySpec = getSecretKeySpec(key);\n\n            Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);\n            cipher.init(Cipher.DECRYPT_MODE, secretKeySpec);\n            return new String(cipher.doFinal(encryptedValue), UTF_8);\n        }\n        catch (Exception e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private SecretKeySpec getSecretKeySpec(String password)\n    {\n        byte[] pwdHash = secureHash(password);\n        byte[] key = Arrays.copyOf(pwdHash, 16); // use only first 128 bit\n\n        // Note: using 128 bit AES avoids requirement for \"Unlimited Crypto\" patch\n        return new SecretKeySpec(key, \"AES\");\n    }\n\n\n    protected String byteToHex(final byte[] hash)\n    {\n        StringBuilder sb = new StringBuilder(hash.length * 2);\n\n        for (byte b : hash)\n        {\n            sb.append(Character.forDigit(b >> 4 & 0x0f, 16));\n            sb.append(Character.forDigit(b & 0x0f, 16));\n        }\n\n        return sb.toString();\n    }\n\n    protected byte[] hexToByte(String hexString)\n    {\n        if (hexString == null || hexString.length() == 0)\n        {\n            return new byte[0];\n        }\n        hexString = hexString.trim();\n\n        if (hexString.length() % 2 != 0)\n        {\n            throw new IllegalArgumentException(\"not a valid hex string \" + hexString);\n        }\n\n        byte[] bytes = new byte[hexString.length() / 2];\n        for (int i = 0; i < hexString.length() / 2; i++)\n        {\n            int val = (Character.digit(hexString.charAt(i * 2), 16) << 4) +\n                      (Character.digit(hexString.charAt( (i * 2) + 1), 16));\n            bytes[i] = (byte) val;\n        }\n\n        return bytes;\n    }\n\n\n    /**\n     * Copied over from PropertyFileUtils to avoid the need for having the api\n     * on the classpath when using the password encode CLI\n     */\n    private Properties loadProperties(URL url)\n    {\n        Properties props = new Properties();\n\n        InputStream inputStream = null;\n        try\n        {\n            inputStream = url.openStream();\n\n            if (inputStream != null)\n            {\n                props.load(inputStream);\n            }\n        }\n        catch (IOException e)\n        {\n            throw new IllegalStateException(e);\n        }\n        finally\n        {\n            try\n            {\n                if (inputStream != null)\n                {\n                    inputStream.close();\n                }\n            }\n            catch (IOException e)\n            {\n                // no worries, means that the file is already closed\n            }\n        }\n\n        return props;\n    }\n\n\n}<fim_middle>// class below has no smell\n"}