{"text": "<fim_prefix>/*\n   Derby - Class org.apache.derby.impl.sql.compile.UnaryArithmeticOperatorNode\n   Licensed to the Apache Software Foundation (ASF) under one or more\n   contributor license agreements.  See the NOTICE file distributed with\n   this work for additional information regarding copyright ownership.\n   The ASF licenses this file to you under the Apache License, Version 2.0\n   (the \"License\"); you may not use this file except in compliance with\n   the License.  You may obtain a copy of the License at\n      http://www.apache.org/licenses/LICENSE-2.0\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n */\npackage\torg.apache.derby.impl.sql.compile;\nimport java.sql.Types;\nimport java.util.List;\nimport org.apache.derby.shared.common.error.StandardException;\nimport org.apache.derby.shared.common.reference.SQLState;\nimport org.apache.derby.iapi.services.compiler.MethodBuilder;\nimport org.apache.derby.iapi.services.context.ContextManager;\nimport org.apache.derby.iapi.types.DataTypeDescriptor;\nimport org.apache.derby.iapi.types.TypeId;\n/**\n * This node represents a unary arithmetic operator\n *\n */\nclass UnaryArithmeticOperatorNode extends UnaryOperatorNode\n{\n\tprivate final static String[] UNARY_OPERATORS = {\"+\",\"-\",\"SQRT\", \"ABS/ABSVAL\"};\n\tprivate final static String[] UNARY_METHODS = {\"plus\",\"minus\",\"sqrt\", \"absolute\"};\n    // Allowed kinds\n    final static int K_PLUS = 0;\n    final static int K_MINUS = 1;\n    final static int K_SQRT = 2;\n    final static int K_ABS = 3;\n    /**\n     * This class is used to hold logically different objects for\n     * space efficiency. {@code kind} represents the logical object\n     * type. See also {@link ValueNode#isSameNodeKind}.\n     */\n    final int kind;\n    /**\n     * @param operand The operand of the node\n     * @param kind unary operator identity\n     * @param cm context manager\n     * @throws StandardException\n     */\n    UnaryArithmeticOperatorNode(\n            ValueNode operand,\n            int kind,\n            ContextManager cm) throws StandardException {\n        super(operand,\n              UNARY_OPERATORS[kind],\n              UNARY_METHODS[kind],\n              cm);\n        this.kind = kind;\n    }\n    /**\n     * Unary + and - require their type to be set if\n     * they wrap another node (e.g. a parameter) that\n     * requires type from its context.\n     * @see ValueNode#requiresTypeFromContext\n     */\n    @Override\n    public boolean requiresTypeFromContext()\n    {\n        if (kind == K_PLUS ||\n            kind == K_MINUS) {\n            return operand.requiresTypeFromContext(); \n        }\n        return false;\n    }\n    /**\n     * A +? or a -? is considered a parameter.\n     */\n    @Override\n    public boolean isParameterNode()\n    {\n        if (kind == K_PLUS ||\n            kind == K_MINUS) {\n            return operand.isParameterNode(); \n        }\n        return false;\n    }\n\t/**\n     * For SQRT and ABS the parameter becomes a DOUBLE.\n     * For unary + and - no change is made to the\n     * underlying node. Once this node's type is set\n     * using setType, then the underlying node will have\n     * its type set.\n\t *\n\t * @exception StandardException\t\tThrown if ?  parameter doesn't\n\t *\t\t\t\t\t\t\t\t\thave a type bound to it yet.\n\t *\t\t\t\t\t\t\t\t\t? parameter where it isn't allowed.\n\t */\n    @Override\n\tvoid bindParameter() throws StandardException\n\t{\n       if (kind == K_SQRT ||\n            kind == K_ABS)\n\t\t{\n\t\t\toperand.setType(\n\t\t\t\tnew DataTypeDescriptor(TypeId.getBuiltInTypeId(Types.DOUBLE), true));\n            return;\n\t\t}\n\t\t//Derby-582 add support for dynamic parameter for unary plus and minus\n       if (kind == K_MINUS ||\n            kind == K_PLUS)\n\t\t\treturn;\n        // Not expected to get here since only the above types are supported\n        // but the super-class method will throw an exception\n        super.bindParameter();\n\t}\n\t/**\n\t * Bind this operator\n\t *\n\t * @param fromList\t\t\tThe query's FROM list\n\t * @param subqueryList\t\tThe subquery list being built as we find SubqueryNodes\n     * @param aggregates        The aggregate list being built as we find AggregateNodes\n\t *\n\t * @return\tThe new top of the expression tree.\n\t *\n\t * @exception StandardException\t\tThrown on error\n\t */\n    @Override\n    ValueNode bindExpression(\n        FromList fromList, SubqueryList subqueryList, List<AggregateNode> aggregates)\n\t\t\tthrows StandardException\n\t{\n\t\t//Return with no binding, if the type of unary minus/plus parameter is not set yet.\n       if (operand.requiresTypeFromContext() &&\n                ((kind == K_PLUS ||\n                  kind == K_MINUS))\n\t\t\t\t&& operand.getTypeServices() == null)\n\t\t\t\treturn this;\n        bindOperand(fromList, subqueryList, aggregates);\n       if (kind == K_SQRT ||\n            kind == K_ABS)\n\t\t{\n\t\t\tbindSQRTABS();\n\t\t}\n       else if (kind == K_PLUS ||\n                 kind == K_MINUS)\n\t\t{\n            checkOperandIsNumeric(operand.getTypeId());\n\t\t}\n\t\t/*\n\t\t** The result type of a +, -, SQRT, ABS is the same as its operand.\n\t\t*/\n\t\tsuper.setType(operand.getTypeServices());\n\t\treturn this;\n\t}\n    /**\n     * Only called for Unary +/-.\n     *\n     */\n\tprivate void checkOperandIsNumeric(TypeId operandType) throws StandardException\n\t{\n\t    if (!operandType.isNumericTypeId())\n\t    {\n\t        throw StandardException.newException(\n                    SQLState.LANG_UNARY_ARITHMETIC_BAD_TYPE, \n                   (kind == K_PLUS) ? \"+\" : \"-\",\n\t                        operandType.getSQLTypeName());\n\t    }\n\t}\n\t/**\n\t * Do code generation for this unary plus operator\n\t *\n\t * @param acb\tThe ExpressionClassBuilder for the class we're generating\n\t * @param mb\tThe method the expression will go into\n\t *\n\t * @exception StandardException\t\tThrown on error\n\t */\n    @Override\n    void generateExpression(ExpressionClassBuilder acb, MethodBuilder mb)\n\t\t\t\t\t\t\t\t\tthrows StandardException\n\t{\n\t\t/* Unary + doesn't do anything.  Just return the operand */\n       if (kind == K_PLUS)\n\t\t\toperand.generateExpression(acb, mb);\n\t\telse\n\t\t\tsuper.generateExpression(acb, mb);\n\t}\n\t/**\n\t * Bind SQRT or ABS\n\t *\n\t * @exception StandardException\t\tThrown on error\n\t */\n<fim_suffix>\tprivate void bindSQRTABS()\n\t\t\tthrows StandardException\n\t{\n\t\tTypeId\toperandType;\n\t\tint \tjdbcType;\n\t\t/*\n\t\t** Check the type of the operand \n\t\t*/\n\t\toperandType = operand.getTypeId();\n\t\t/*\n\t \t * If the operand is not a build-in type, generate a bound conversion\n\t\t * tree to build-in types.\n\t\t */\n\t\tif (operandType.userType() )\n\t\t{\n\t\t\toperand = operand.genSQLJavaSQLTree();\n\t\t}\n\t\t/* DB2 doesn't cast string types to numeric types for numeric functions  */\n\t\tjdbcType = operandType.getJDBCTypeId();\n\t\t/* Both SQRT and ABS are only allowed on numeric types */\n\t\tif (!operandType.isNumericTypeId())\n\t\t\tthrow StandardException.newException(\n\t\t\t\t\t\tSQLState.LANG_UNARY_FUNCTION_BAD_TYPE, \n\t\t\t\t\t\tgetOperatorString(), operandType.getSQLTypeName());\n\t\t/* For SQRT, if operand is not a DOUBLE, convert it to DOUBLE */\n       if (kind == K_SQRT &&\n            jdbcType != Types.DOUBLE)\n\t\t{\n            operand = new CastNode(\n\t\t\t\t\toperand,\n\t\t\t\t\tnew DataTypeDescriptor(TypeId.getBuiltInTypeId(Types.DOUBLE), true),\n\t\t\t\t\tgetContextManager());\n\t\t\t((CastNode) operand).bindCastNodeOnly();\n\t\t}\n\t}\n\t/** We are overwriting this method here because for -?/+?, we now know\n\tthe type of these dynamic parameters and hence we can do the parameter\n\tbinding. The setType method will call the binding code after setting\n\tthe type of the parameter*/\n    @Override\n    void setType(DataTypeDescriptor descriptor) throws StandardException\n\t{\n        if (operand.requiresTypeFromContext() && operand.getTypeServices() == null)\n        {\n            checkOperandIsNumeric(descriptor.getTypeId());\n\t\t    operand.setType(descriptor);\n        }\n\t\tsuper.setType(descriptor);\n\t}\n    @Override\n    boolean isSameNodeKind(ValueNode o) {<fim_middle>// function below has no smell\n"}