{"text": "<fim_prefix>/*\n * Copyright 2002-2017 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.springframework.security.context;\nimport java.util.Random;\nimport junit.framework.ComparisonFailure;\nimport junit.framework.TestCase;\nimport org.springframework.security.providers.UsernamePasswordAuthenticationToken;\n/**\n * Multi-threaded tests for SecurityContextHolder\n *\n * @author Ben Alex\n * @Author Luke Taylor\n */\npublic class SecurityContextHolderMTTests extends TestCase{\n\tprivate int errors = 0;\n\tprivate static final int NUM_OPS = 25;\n\tprivate static final int NUM_THREADS = 25;\n\tpublic final void setUp() throws Exception {\n\t\tSecurityContextHolder.setStrategyName(SecurityContextHolder.MODE_INHERITABLETHREADLOCAL);\n\t}\n\tpublic void testSynchronizationCustomStrategyLoading() {\n\t\tSecurityContextHolder.setStrategyName(InheritableThreadLocalSecurityContextHolderStrategy.class.getName());\n\t\tassertThat(new SecurityContextHolder().toString().isTrue()\n\t\t\t\t\t\t\t\t\t\t\t.lastIndexOf(\"SecurityContextHolder[strategy='org.springframework.security.context.InheritableThreadLocalSecurityContextHolderStrategy'\") != -1);\n\t\tloadStartAndWaitForThreads(true, \"Main_\", NUM_THREADS, false, true);\n\t\tassertThat(errors).as(\"Thread errors detected; review log output for details\").isZero();\n\t}\n<fim_suffix>\tpublic void testSynchronizationGlobal() throws Exception {\n\t\tSecurityContextHolder.clearContext();\n\t\tSecurityContextHolder.setStrategyName(SecurityContextHolder.MODE_GLOBAL);\n\t\tloadStartAndWaitForThreads(true, \"Main_\", NUM_THREADS, true, false);\n\t\tassertThat(errors).as(\"Thread errors detected; review log output for details\").isZero();\n\t}\n\tpublic void testSynchronizationInheritableThreadLocal()\n\t\tthrows Exception {\n\t\tSecurityContextHolder.clearContext();\n\t\tSecurityContextHolder.setStrategyName(SecurityContextHolder.MODE_INHERITABLETHREADLOCAL);\n\t\tloadStartAndWaitForThreads(true, \"Main_\", NUM_THREADS, false, true);\n\t\tassertThat(errors).as(\"Thread errors detected; review log output for details\").isZero();\n\t}\n\tpublic void testSynchronizationThreadLocal() throws Exception {\n\t\tSecurityContextHolder.clearContext();\n\t\tSecurityContextHolder.setStrategyName(SecurityContextHolder.MODE_THREADLOCAL);\n\t\tloadStartAndWaitForThreads(true, \"Main_\", NUM_THREADS, false, false);\n\t\tassertThat(errors).as(\"Thread errors detected; review log output for details\").isZero();\n\t}\n\tprivate void startAndRun(Thread[] threads) {\n\t\t// Start them up\n\t\tfor (int i = 0; i < threads.length; i++) {\n\t\t\tthreads[i].start();\n\t\t}\n\t\t// Wait for them to finish\n\t\twhile (stillRunning(threads)) {\n\t\t\ttry {\n\t\t\t\tThread.sleep(250);\n\t\t\t} catch (InterruptedException ignore) {}\n\t\t}\n\t}\n\tprivate boolean stillRunning(Thread[] threads) {\n\t\tfor (int i = 0; i < threads.length; i++) {\n\t\t\tif (threads[i].isAlive()) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tprivate void loadStartAndWaitForThreads(boolean topLevelThread, String prefix, int createThreads,\n\t\t\tboolean expectAllThreadsToUseIdenticalAuthentication, boolean expectChildrenToShareAuthenticationWithParent) {\n\t\tThread[] threads = new Thread[createThreads];\n\t\terrors = 0;\n\t\tif (topLevelThread) {\n\t\t\t// PARENT (TOP-LEVEL) THREAD CREATION\n\t\t\tif (expectChildrenToShareAuthenticationWithParent) {\n\t\t\t\t// An InheritableThreadLocal\n\t\t\t\tfor (int i = 0; i < threads.length; i++) {\n\t\t\t\t\tif ((i % 2) == 0) {\n\t\t\t\t\t\t// Don't inject auth into current thread; neither current thread or child will have authentication\n\t\t\t\t\t\tthreads[i] = makeThread(prefix + \"Unauth_Parent_\" + i, true, false, false, true, null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Inject auth into current thread, but not child; current thread will have auth, child will also have auth\n\t\t\t\t\t\tthreads[i] = makeThread(prefix + \"Auth_Parent_\" + i, true, true, false, true,\n\t\t\t\t\t\t\t\tprefix + \"Auth_Parent_\" + i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (expectAllThreadsToUseIdenticalAuthentication) {\n\t\t\t\t// A global\n\t\t\t\tSecurityContextHolder.getContext()\n\t\t\t\t\t\t\t\t\t.setAuthentication(new UsernamePasswordAuthenticationToken(\"GLOBAL_USERNAME\",\n\t\t\t\t\t\t\"pass\"));\n\t\t\t\tfor (int i = 0; i < threads.length; i++) {\n\t\t\t\t\tif ((i % 2) == 0) {\n\t\t\t\t\t\t// Don't inject auth into current thread;both current thread and child will have same authentication\n\t\t\t\t\t\tthreads[i] = makeThread(prefix + \"Unauth_Parent_\" + i, true, false, true, true,\n\t\t\t\t\t\t\t\t\"GLOBAL_USERNAME\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Inject auth into current thread; current thread will have auth, child will also have auth\n\t\t\t\t\t\tthreads[i] = makeThread(prefix + \"Auth_Parent_\" + i, true, true, true, true, \"GLOBAL_USERNAME\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// A standard ThreadLocal\n\t\t\t\tfor (int i = 0; i < threads.length; i++) {\n\t\t\t\t\tif ((i % 2) == 0) {\n\t\t\t\t\t\t// Don't inject auth into current thread; neither current thread or child will have authentication\n\t\t\t\t\t\tthreads[i] = makeThread(prefix + \"Unauth_Parent_\" + i, true, false, false, false, null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Inject auth into current thread, but not child; current thread will have auth, child will not have auth\n\t\t\t\t\t\tthreads[i] = makeThread(prefix + \"Auth_Parent_\" + i, true, true, false, false,\n\t\t\t\t\t\t\t\tprefix + \"Auth_Parent_\" + i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// CHILD THREAD CREATION\n\t\t\tif (expectChildrenToShareAuthenticationWithParent || expectAllThreadsToUseIdenticalAuthentication) {\n\t\t\t\t// The children being created are all expected to have security (ie an InheritableThreadLocal/global AND auth was injected into parent)\n\t\t\t\tfor (int i = 0; i < threads.length; i++) {\n\t\t\t\t\tString expectedUsername = prefix;\n\t\t\t\t\tif (expectAllThreadsToUseIdenticalAuthentication) {\n\t\t\t\t\t\texpectedUsername = \"GLOBAL_USERNAME\";\n\t\t\t\t\t}\n\t\t\t\t\t// Don't inject auth into current thread; the current thread will obtain auth from its parent\n\t\t\t\t\t// NB: As topLevelThread = true, no further child threads will be created\n\t\t\t\t\tthreads[i] = makeThread(prefix + \"->child->Inherited_Auth_Child_\" + i, false, false,\n\t\t\t\t\t\t\texpectAllThreadsToUseIdenticalAuthentication, false, expectedUsername);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// The children being created are NOT expected to have security (ie not an InheritableThreadLocal OR auth was not injected into parent)\n\t\t\t\tfor (int i = 0; i < threads.length; i++) {\n\t\t\t\t\t// Don't inject auth into current thread; neither current thread or child will have authentication\n\t\t\t\t\t// NB: As topLevelThread = true, no further child threads will be created\n\t\t\t\t\tthreads[i] = makeThread(prefix + \"->child->Unauth_Child_\" + i, false, false, false, false, null);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Start and execute the threads\n\t\tstartAndRun(threads);\n\t}\n\tprivate Thread makeThread(final String threadIdentifier, final boolean topLevelThread,\n\t\tfinal boolean injectAuthIntoCurrentThread, final boolean expectAllThreadsToUseIdenticalAuthentication,\n\t\tfinal boolean expectChildrenToShareAuthenticationWithParent, final String expectedUsername) {\n\t\tfinal Random rnd = new Random();\n\t\tThread t = new Thread(new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\t\tif (injectAuthIntoCurrentThread) {\n\t\t\t\t\t\t// Set authentication in this thread\n\t\t\t\t\t\tSecurityContextHolder.getContext().setAuthentication(new UsernamePasswordAuthenticationToken(\n\t\t\t\t\t\t\t\texpectedUsername, \"pass\"));\n\t\t\t\t\t\t//System.out.println(threadIdentifier + \" - set to \" + SecurityContextHolder.getContext().getAuthentication());\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//System.out.println(threadIdentifier + \" - not set (currently \" + SecurityContextHolder.getContext().getAuthentication() + \")\");\n\t\t\t\t\t}<fim_middle>// function below has no smell\n"}