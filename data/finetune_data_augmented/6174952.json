{"text": "<fim_prefix>/*\n * Copyright (c) 2012-2018 Red Hat, Inc.\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n *\n * Contributors:\n *   Red Hat, Inc. - initial API and implementation\n */\npackage org.eclipse.che.plugin.debugger.ide.configuration;\nimport static java.util.Collections.emptyList;\nimport com.google.common.base.Optional;\nimport com.google.inject.Inject;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport org.eclipse.che.api.promises.client.Operation;\nimport org.eclipse.che.api.promises.client.OperationException;\nimport org.eclipse.che.api.promises.client.PromiseError;\nimport org.eclipse.che.commons.annotation.Nullable;\nimport org.eclipse.che.ide.api.debug.DebugConfiguration;\nimport org.eclipse.che.ide.api.debug.DebugConfigurationType;\nimport org.eclipse.che.ide.api.debug.DebugConfigurationsManager;\nimport org.eclipse.che.ide.debug.Debugger;\nimport org.eclipse.che.ide.debug.DebuggerManager;\nimport org.eclipse.che.ide.dto.DtoFactory;\nimport org.eclipse.che.ide.macro.CurrentProjectPathMacro;\nimport org.eclipse.che.ide.ui.dialogs.DialogFactory;\nimport org.eclipse.che.ide.util.loging.Log;\nimport org.eclipse.che.ide.util.storage.LocalStorage;\nimport org.eclipse.che.ide.util.storage.LocalStorageProvider;\nimport org.eclipse.che.plugin.debugger.ide.DebuggerLocalizationConstant;\nimport org.eclipse.che.plugin.debugger.ide.configuration.dto.DebugConfigurationDto;\n/**\n * Implementation of {@link DebugConfigurationsManager}.\n *\n * @author Artem Zatsarynnyi\n */\npublic class DebugConfigurationsManagerImpl implements DebugConfigurationsManager {\n  private static final String LOCAL_STORAGE_DEBUG_CONF_KEY = \"che-debug-configurations\";\n  private final DtoFactory dtoFactory;\n  private final DebugConfigurationTypeRegistry configurationTypeRegistry;\n  private final Optional<LocalStorage> localStorageOptional;\n  private final Set<ConfigurationChangedListener> configurationChangedListeners;\n  private final List<DebugConfiguration> configurations;\n  private final DebuggerManager debuggerManager;\n  private final DialogFactory dialogFactory;\n  private final DebuggerLocalizationConstant localizationConstants;\n  private final CurrentProjectPathMacro currentProjectPathMacro;\n  private DebugConfiguration currentDebugConfiguration;\n  @Inject\n  public DebugConfigurationsManagerImpl(\n      LocalStorageProvider localStorageProvider,\n      DtoFactory dtoFactory,\n      DebugConfigurationTypeRegistry debugConfigurationTypeRegistry,\n      DebuggerManager debuggerManager,\n      DialogFactory dialogFactory,\n      DebuggerLocalizationConstant localizationConstants,\n      CurrentProjectPathMacro currentProjectPathMacro) {\n    this.dtoFactory = dtoFactory;\n    this.configurationTypeRegistry = debugConfigurationTypeRegistry;\n    this.debuggerManager = debuggerManager;\n    this.dialogFactory = dialogFactory;\n    this.localizationConstants = localizationConstants;\n    this.currentProjectPathMacro = currentProjectPathMacro;\n    localStorageOptional = Optional.fromNullable(localStorageProvider.get());\n    configurationChangedListeners = new HashSet<>();\n    configurations = new ArrayList<>();\n    loadConfigurations();\n  }\n  private void loadConfigurations() {\n    for (DebugConfigurationDto descriptor : retrieveConfigurations()) {\n      final DebugConfigurationType type =\n          configurationTypeRegistry.getConfigurationTypeById(descriptor.getType());\n      // skip configuration if it's type isn't registered\n      if (type != null) {\n        try {\n          configurations.add(\n              new DebugConfiguration(\n                  type,\n                  descriptor.getName(),\n                  descriptor.getHost(),\n                  descriptor.getPort(),\n                  descriptor.getConnectionProperties()));\n        } catch (IllegalArgumentException e) {\n          Log.warn(EditDebugConfigurationsPresenter.class, e.getMessage());\n        }\n      }\n    }\n  }\n  private List<DebugConfigurationDto> retrieveConfigurations() {\n    List<DebugConfigurationDto> configurationsList;\n    if (localStorageOptional.isPresent()) {\n      final LocalStorage localStorage = localStorageOptional.get();\n      final Optional<String> data =\n          Optional.fromNullable(localStorage.getItem(LOCAL_STORAGE_DEBUG_CONF_KEY));\n      if (data.isPresent() && !data.get().isEmpty()) {\n        configurationsList =\n            dtoFactory.createListDtoFromJson(data.get(), DebugConfigurationDto.class);\n      } else {\n        configurationsList = emptyList();\n      }\n    } else {\n      configurationsList = emptyList();\n    }\n    return configurationsList;\n  }\n  @Override\n  public Optional<DebugConfiguration> getCurrentDebugConfiguration() {\n    return Optional.fromNullable(currentDebugConfiguration);\n  }\n  @Override\n  public void setCurrentDebugConfiguration(@Nullable DebugConfiguration debugConfiguration) {\n    currentDebugConfiguration = debugConfiguration;\n  }\n  @Override\n  public List<DebugConfiguration> getConfigurations() {\n    return new ArrayList<>(configurations);\n  }\n<fim_suffix>  @Override\n  public DebugConfiguration createConfiguration(\n      String typeId, String name, String host, int port, Map<String, String> connectionProperties) {\n    final DebugConfigurationType configurationType =\n        configurationTypeRegistry.getConfigurationTypeById(typeId);\n    final DebugConfiguration configuration =\n        new DebugConfiguration(\n            configurationType,\n            generateUniqueConfigurationName(configurationType, name),\n            host,\n            port,\n            connectionProperties);\n    configurations.add(configuration);\n    saveConfigurations();\n    fireConfigurationAdded(configuration);\n    return configuration;\n  }\n  private String generateUniqueConfigurationName(\n      DebugConfigurationType configurationType, String customName) {\n    Set<String> configurationNames = new HashSet<>(configurations.size());\n    for (DebugConfiguration configuration : configurations) {\n      configurationNames.add(configuration.getName());\n    }\n    final String configurationName;\n    if (customName == null || customName.isEmpty()) {\n      configurationName = \"Remote \" + configurationType.getDisplayName();\n    } else {\n      if (!configurationNames.contains(customName)) {\n        return customName;\n      }\n      configurationName = customName + \" copy\";\n    }\n    if (!configurationNames.contains(configurationName)) {\n      return configurationName;\n    }\n    for (int count = 1; count < 1000; count++) {\n      if (!configurationNames.contains(configurationName + \"-\" + count)) {\n        return configurationName + \"-\" + count;\n      }\n    }\n    return configurationName;\n  }\n  @Override\n  public void removeConfiguration(DebugConfiguration configuration) {\n    if (getCurrentDebugConfiguration().isPresent()\n        && getCurrentDebugConfiguration().get().equals(configuration)) {\n      setCurrentDebugConfiguration(null);\n    }\n    configurations.remove(configuration);\n    saveConfigurations();\n    fireConfigurationRemoved(configuration);\n  }\n  private void saveConfigurations() {\n    if (localStorageOptional.isPresent()) {\n      List<DebugConfigurationDto> configurationDtos = new ArrayList<>();\n      for (DebugConfiguration configuration : configurations) {\n        configurationDtos.add(\n            dtoFactory\n                .createDto(DebugConfigurationDto.class)\n                .withType(configuration.getType().getId())\n                .withName(configuration.getName())\n                .withHost(configuration.getHost())\n                .withPort(configuration.getPort())\n                .withConnectionProperties(configuration.getConnectionProperties()));\n      }\n      localStorageOptional\n          .get()\n          .setItem(LOCAL_STORAGE_DEBUG_CONF_KEY, dtoFactory.toJson(configurationDtos));\n    }\n  }\n  @Override\n  public void addConfigurationsChangedListener(ConfigurationChangedListener listener) {\n    configurationChangedListeners.add(listener);\n  }\n  @Override\n  public void removeConfigurationsChangedListener(ConfigurationChangedListener listener) {\n    configurationChangedListeners.remove(listener);\n  }\n  @Override\n  public void apply(final DebugConfiguration debugConfiguration) {\n    if (debugConfiguration == null) {\n      return;\n    }\n    if (debuggerManager.getActiveDebugger() != null) {\n      dialogFactory\n          .createMessageDialog(\n              localizationConstants.connectToRemote(),\n              localizationConstants.debuggerAlreadyConnected(),\n              null)\n          .show();\n      return;\n    }\n    final Debugger debugger = debuggerManager.getDebugger(debugConfiguration.getType().getId());\n    if (debugger != null) {\n      debuggerManager.setActiveDebugger(debugger);\n      currentProjectPathMacro\n          .expand()\n          .then(\n              new Operation<String>() {\n                @Override\n                public void apply(String arg) throws OperationException {\n                  Map<String, String> connectionProperties =\n                      prepareConnectionProperties(debugConfiguration, arg);\n                  debugger\n                      .connect(connectionProperties)\n                      .catchError(\n                          new Operation<PromiseError>() {\n                            @Override\n                            public void apply(PromiseError arg) throws OperationException {\n                              debuggerManager.setActiveDebugger(null);\n                            }\n                          });\n                }\n              });\n    }\n  }\n  private Map<String, String> prepareConnectionProperties(\n      DebugConfiguration debugConfiguration, String currentProjectPath) {\n    Map<String, String> connectionProperties =\n        new HashMap<>(2 + debugConfiguration.getConnectionProperties().size());\n    connectionProperties.put(\"HOST\", debugConfiguration.getHost());<fim_middle>// function below has no smell\n"}