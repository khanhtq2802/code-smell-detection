{"text": "<fim_prefix>            .expressionLanguageSupported(ExpressionLanguageScope.VARIABLE_REGISTRY)\n            .build();\n    public static final PropertyDescriptor BASIC_USERNAME = new PropertyDescriptor\n            .Builder().name(\"Username\")\n            .description(\"The username to use when Solr is configured with basic authentication.\")\n            .required(false)\n            .addValidator(StandardValidators.NON_EMPTY_VALIDATOR)\n            .addValidator(StandardValidators.createAttributeExpressionLanguageValidator(AttributeExpression.ResultType.STRING))\n            .expressionLanguageSupported(ExpressionLanguageScope.VARIABLE_REGISTRY)\n            .build();\n    public static final PropertyDescriptor BASIC_PASSWORD = new PropertyDescriptor\n            .Builder().name(\"Password\")\n            .description(\"The password to use when Solr is configured with basic authentication.\")\n            .required(false)\n            .addValidator(StandardValidators.NON_EMPTY_VALIDATOR)\n            .addValidator(StandardValidators.createAttributeExpressionLanguageValidator(AttributeExpression.ResultType.STRING))\n            .expressionLanguageSupported(ExpressionLanguageScope.VARIABLE_REGISTRY)\n            .sensitive(true)\n            .build();\n    static final PropertyDescriptor KERBEROS_CREDENTIALS_SERVICE = new PropertyDescriptor.Builder()\n            .name(\"kerberos-credentials-service\")\n            .displayName(\"Kerberos Credentials Service\")\n            .description(\"Specifies the Kerberos Credentials Controller Service that should be used for authenticating with Kerberos\")\n            .identifiesControllerService(KerberosCredentialsService.class)\n            .required(false)\n            .build();\n    public static final PropertyDescriptor SSL_CONTEXT_SERVICE = new PropertyDescriptor.Builder()\n            .name(\"SSL Context Service\")\n            .description(\"The Controller Service to use in order to obtain an SSL Context. This property must be set when communicating with a Solr over https.\")\n            .required(false)\n            .identifiesControllerService(SSLContextService.class)\n            .build();\n    public static final PropertyDescriptor SOLR_SOCKET_TIMEOUT = new PropertyDescriptor\n            .Builder().name(\"Solr Socket Timeout\")\n            .description(\"The amount of time to wait for data on a socket connection to Solr. A value of 0 indicates an infinite timeout.\")\n            .required(true)\n            .addValidator(StandardValidators.TIME_PERIOD_VALIDATOR)\n            .defaultValue(\"10 seconds\")\n            .build();\n    public static final PropertyDescriptor SOLR_CONNECTION_TIMEOUT = new PropertyDescriptor\n            .Builder().name(\"Solr Connection Timeout\")\n            .description(\"The amount of time to wait when establishing a connection to Solr. A value of 0 indicates an infinite timeout.\")\n            .required(true)\n            .addValidator(StandardValidators.TIME_PERIOD_VALIDATOR)\n            .defaultValue(\"10 seconds\")\n            .build();\n    public static final PropertyDescriptor SOLR_MAX_CONNECTIONS = new PropertyDescriptor\n            .Builder().name(\"Solr Maximum Connections\")\n            .description(\"The maximum number of total connections allowed from the Solr client to Solr.\")\n            .required(true)\n            .addValidator(StandardValidators.POSITIVE_INTEGER_VALIDATOR)\n            .defaultValue(\"10\")\n            .build();\n    public static final PropertyDescriptor SOLR_MAX_CONNECTIONS_PER_HOST = new PropertyDescriptor\n            .Builder().name(\"Solr Maximum Connections Per Host\")\n            .description(\"The maximum number of connections allowed from the Solr client to a single Solr host.\")\n            .required(true)\n            .addValidator(StandardValidators.POSITIVE_INTEGER_VALIDATOR)\n            .defaultValue(\"5\")\n            .build();\n    public static final PropertyDescriptor ZK_CLIENT_TIMEOUT = new PropertyDescriptor\n            .Builder().name(\"ZooKeeper Client Timeout\")\n            .description(\"The amount of time to wait for data on a connection to ZooKeeper, only used with a Solr Type of Cloud.\")\n            .required(false)\n            .addValidator(StandardValidators.createTimePeriodValidator(1, TimeUnit.SECONDS, Integer.MAX_VALUE, TimeUnit.SECONDS))\n            .defaultValue(\"10 seconds\")\n            .build();\n    public static final PropertyDescriptor ZK_CONNECTION_TIMEOUT = new PropertyDescriptor\n            .Builder().name(\"ZooKeeper Connection Timeout\")\n            .description(\"The amount of time to wait when establishing a connection to ZooKeeper, only used with a Solr Type of Cloud.\")\n            .required(false)\n            .addValidator(StandardValidators.createTimePeriodValidator(1, TimeUnit.SECONDS, Integer.MAX_VALUE, TimeUnit.SECONDS))\n            .defaultValue(\"10 seconds\")\n            .build();\n    public static final String REPEATING_PARAM_PATTERN = \"[\\\\w\\\\.]+\\\\.\\\\d+$\";\n    public static SolrClient createSolrClient(final PropertyContext context, final String solrLocation) {\n        final Integer socketTimeout = context.getProperty(SOLR_SOCKET_TIMEOUT).asTimePeriod(TimeUnit.MILLISECONDS).intValue();\n        final Integer connectionTimeout = context.getProperty(SOLR_CONNECTION_TIMEOUT).asTimePeriod(TimeUnit.MILLISECONDS).intValue();\n        final Integer maxConnections = context.getProperty(SOLR_MAX_CONNECTIONS).asInteger();\n        final Integer maxConnectionsPerHost = context.getProperty(SOLR_MAX_CONNECTIONS_PER_HOST).asInteger();\n        final SSLContextService sslContextService = context.getProperty(SSL_CONTEXT_SERVICE).asControllerService(SSLContextService.class);\n        final KerberosCredentialsService kerberosCredentialsService = context.getProperty(KERBEROS_CREDENTIALS_SERVICE).asControllerService(KerberosCredentialsService.class);\n        final ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(HttpClientUtil.PROP_SO_TIMEOUT, socketTimeout);\n        params.set(HttpClientUtil.PROP_CONNECTION_TIMEOUT, connectionTimeout);\n        params.set(HttpClientUtil.PROP_MAX_CONNECTIONS, maxConnections);\n        params.set(HttpClientUtil.PROP_MAX_CONNECTIONS_PER_HOST, maxConnectionsPerHost);\n        // has to happen before the client is created below so that correct configurer would be set if needed\n        if (kerberosCredentialsService != null) {\n            HttpClientUtil.setConfigurer(new KerberosHttpClientConfigurer());\n        }\n        final HttpClient httpClient = HttpClientUtil.createClient(params);\n        if (sslContextService != null) {\n            final SSLContext sslContext = sslContextService.createSSLContext(SSLContextService.ClientAuth.REQUIRED);\n            final SSLSocketFactory sslSocketFactory = new SSLSocketFactory(sslContext);\n            final Scheme httpsScheme = new Scheme(\"https\", 443, sslSocketFactory);\n            httpClient.getConnectionManager().getSchemeRegistry().register(httpsScheme);\n        }\n        if (SOLR_TYPE_STANDARD.getValue().equals(context.getProperty(SOLR_TYPE).getValue())) {\n            return new HttpSolrClient(solrLocation, httpClient);\n        } else {\n            final String collection = context.getProperty(COLLECTION).evaluateAttributeExpressions().getValue();\n            final Integer zkClientTimeout = context.getProperty(ZK_CLIENT_TIMEOUT).asTimePeriod(TimeUnit.MILLISECONDS).intValue();\n            final Integer zkConnectionTimeout = context.getProperty(ZK_CONNECTION_TIMEOUT).asTimePeriod(TimeUnit.MILLISECONDS).intValue();\n            CloudSolrClient cloudSolrClient = new CloudSolrClient(solrLocation, httpClient);\n            cloudSolrClient.setDefaultCollection(collection);\n            cloudSolrClient.setZkClientTimeout(zkClientTimeout);\n            cloudSolrClient.setZkConnectTimeout(zkConnectionTimeout);\n            return cloudSolrClient;\n        }\n    }\n    /**\n     * Writes each SolrDocument to a record.\n     */\n    public static RecordSet solrDocumentsToRecordSet(final List<SolrDocument> docs, final RecordSchema schema) {\n        final List<Record> lr = new ArrayList<Record>();\n        for (SolrDocument doc : docs) {\n            final Map<String, Object> recordValues = new LinkedHashMap<>();\n            for (RecordField field : schema.getFields()){\n                final Object fieldValue = doc.getFieldValue(field.getFieldName());\n                if (fieldValue != null) {\n                    if (field.getDataType().getFieldType().equals(RecordFieldType.ARRAY)){\n                        recordValues.put(field.getFieldName(), ((List<Object>) fieldValue).toArray());\n                    } else {\n                        recordValues.put(field.getFieldName(), fieldValue);\n                    }\n                }\n            }\n            lr.add(new MapRecord(schema, recordValues));\n        }\n        return new ListRecordSet(schema, lr);\n    }\n    public static OutputStreamCallback getOutputStreamCallbackToTransformSolrResponseToXml(QueryResponse response) {\n        return new QueryResponseOutputStreamCallback(response);\n    }\n    /**\n     * Writes each SolrDocument in XML format to the OutputStream.\n     */\n    private static class QueryResponseOutputStreamCallback implements OutputStreamCallback {\n        private QueryResponse response;\n        public QueryResponseOutputStreamCallback(QueryResponse response) {\n            this.response = response;\n        }\n<fim_suffix>        @Override\n        public void process(OutputStream out) throws IOException {\n            IOUtils.write(\"<docs>\", out, StandardCharsets.UTF_8);\n            for (SolrDocument doc : response.getResults()) {\n                final String xml = ClientUtils.toXML(toSolrInputDocument(doc));\n                IOUtils.write(xml, out, StandardCharsets.UTF_8);\n            }\n            IOUtils.write(\"</docs>\", out, StandardCharsets.UTF_8);\n        }<fim_middle>// function below has no smell\n"}