{"text": "<fim_prefix>/*\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n *\n * Copyright 2007-2010 Oracle and/or its affiliates. All rights reserved.\n *\n * Oracle and Java are registered trademarks of Oracle and/or its affiliates.\n * Other names may be trademarks of their respective owners.\n *\n * The contents of this file are subject to the terms of either the GNU\n * General Public License Version 2 only (\"GPL\") or the Common\n * Development and Distribution License(\"CDDL\") (collectively, the\n * \"License\"). You may not use this file except in compliance with the\n * License. You can obtain a copy of the License at\n * http://www.netbeans.org/cddl-gplv2.html\n * or nbbuild/licenses/CDDL-GPL-2-CP. See the License for the\n * specific language governing permissions and limitations under the\n * License.  When distributing the software, include this License Header\n * Notice in each file and include the License file at\n * nbbuild/licenses/CDDL-GPL-2-CP.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the GPL Version 2 section of the License file that\n * accompanied this code. If applicable, add the following below the\n * License Header, with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * Contributor(s):\n * The Original Software is NetBeans. The Initial Developer of the Original\n * Software is Sun Microsystems, Inc. Portions Copyright 1997-2006 Sun\n * Microsystems, Inc. All Rights Reserved.\n *\n * If you wish your version of this file to be governed by only the CDDL\n * or only the GPL Version 2, indicate your decision by adding\n * \"[Contributor] elects to include this software in this distribution\n * under the [CDDL or GPL Version 2] license.\" If you do not indicate a\n * single choice of license, a recipient has the option to distribute\n * your version of this file under either the CDDL, the GPL Version 2 or\n * to extend the choice of license to its licensees as provided above.\n * However, if you add GPL Version 2 code and therefore, elected the GPL\n * Version 2 license, then the option applies only if the new code is\n * made subject to such option by the copyright holder.\n */\npackage org.graalvm.visualvm.lib.charts.canvas;\nimport java.awt.Component;\nimport java.awt.Container;\nimport java.awt.Graphics;\nimport java.awt.GraphicsConfiguration;\nimport java.awt.Image;\nimport java.awt.Insets;\nimport java.awt.Rectangle;\nimport java.awt.Window;\nimport java.awt.event.HierarchyEvent;\nimport java.awt.event.HierarchyListener;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.awt.image.VolatileImage;\nimport java.lang.ref.WeakReference;\nimport javax.swing.JComponent;\nimport javax.swing.RepaintManager;\nimport javax.swing.SwingUtilities;\nimport javax.swing.border.Border;\n/**\n * JComponent optionally using an offscreen buffer to store its appearance. The\n * component can paint its appearance either directly or into an offscreen buffer\n * which may be a BufferedImage or VolatileImage. The buffer type can be changed\n * anytime during the runtime.\n * \n * Setting a Border to BufferedComponent and its descendants isn't supported,\n * setBorder(Border) with a non-null value throws an IllegalArgumentException.\n * To define a border for BufferedComponent, create a container for the component\n * and assign it the Border.\n * \n * WARNING: Methods of this component must be strictly called in EDT unless\n * allowed otherwise for a particular method.\n *\n * @author Jiri Sedlacek\n */\npublic abstract class BufferedCanvasComponent extends JComponent {\n    // No offscreen buffer\n    public static final int BUFFER_NONE = 0;\n    // BufferedImage offscreen buffer\n    public static final int BUFFER_IMAGE = 1;\n    // VolatileImage offscreen buffer\n    public static final int BUFFER_VOLATILE_IMAGE = 2;\n    // Not a public API, for testing purposes only\n    private static final int DEFAULT_BUFFER =\n            Integer.getInteger(\"graphs.defaultBuffer\", BUFFER_VOLATILE_IMAGE); // NOI18N\n    // Not a public API, for testing purposes only\n//    private static final boolean ACCEL_DISABLED =\n//            Boolean.getBoolean(\"graphs.noAcceleration\"); // NOI18N\n    private static final boolean ACCEL_DISABLED = true;\n    private static final Insets ZERO_INSETS = new Insets(0, 0, 0, 0);\n    private int bufferType = -1; // Defined in constructor\n    private float accelerationPriority = .5f;\n    private Image offscreenImage = null;\n    private WeakReference<Image> offscreenImageReference = new WeakReference(offscreenImage);\n    private Rectangle invalidOffscreenArea = new Rectangle();\n    // --- Public constructors -------------------------------------------------\n    public BufferedCanvasComponent() {\n         this(DEFAULT_BUFFER);\n    }\n    public BufferedCanvasComponent(int bufferType) {\n        super();\n        setOpaque(true);\n        setBufferType(bufferType);\n        addHierarchyListener(new VisibilityHandler());\n    }\n    // --- Protected paintContents ---------------------------------------------\n    protected abstract void paintComponent(Graphics g, Rectangle invalidArea);\n    // --- Protected event handlers --------------------------------------------\n    /**\n     * Called when bounds of the component changed. Default implementation calls\n     * weaklyReleaseOffscreenImage() if the component has been resized.\n     * \n     * @param oldBounds old bounds of the component.\n     * @param newBounds new bounds of the component.\n     */\n    protected void reshaped(Rectangle oldBounds, Rectangle newBounds) {\n        if (!oldBounds.getSize().equals(newBounds.getSize()))\n            releaseOffscreenImage();\n        }\n    /**\n     * Called when the component has been shown. Default implementation does\n     * nothing.\n     */\n    protected void shown() {\n        invalidateImage();\n        repaintDirty();\n    }\n    /**\n     * Called when the component has been hidden. Default implementation calls\n     * weaklyReleaseOffscreenImage().\n     */\n    protected void hidden() {\n        weaklyReleaseOffscreenImage();\n    }\n    /**\n     * Called when the owner window becomes iconified (minimized). Default\n     * implementation calls hidden().\n     */\n    protected void windowIconified() {\n        hidden();\n    }\n    /**\n     * Called when the owner window becomes deiconified (restored). Default\n     * implementation calls shown().\n     */\n    protected void windowDeiconified() {\n        shown();\n    }\n    // --- Protected offscreen image access ------------------------------------\n<fim_suffix>    protected final void setBufferType(int bufferType) {\n        if (this.bufferType == bufferType) return;\n        if (bufferType == BUFFER_NONE ||\n            bufferType == BUFFER_IMAGE ||\n            bufferType == BUFFER_VOLATILE_IMAGE) {\n            this.bufferType = bufferType;\n            releaseOffscreenImage();\n            repaintImpl(0, 0, getWidth(), getHeight());\n        } else {\n            throw new IllegalArgumentException(\"Unknown buffer type: \" + bufferType); // NOI18N\n        }\n    }\n    protected final int getBufferType() {\n        return bufferType;\n    }\n    protected final boolean isBuffered() {\n        return bufferType != BUFFER_NONE;\n    }\n    protected final void setAccelerationPriority(float priority) {\n        accelerationPriority = priority;\n        Image image = offscreenImageReference.get();\n        if (image != null) image.setAccelerationPriority(accelerationPriority);\n    }\n    protected final float getAccelerationPriority() {\n        return accelerationPriority;\n    }\n    /**\n     * Releases reference to the offscreen image. The image will be re-created\n     * and its entire area painted on next paintComponent(Graphics) invocation.\n     */\n    protected final void releaseOffscreenImage() {\n        if (offscreenImage != null) offscreenImage.flush();\n        offscreenImage = null;\n        offscreenImageReference.clear();\n    }\n    /**\n     * Releases reference to the offscreen image but keeps a weak reference.\n     * The image will be reused on next paintComponent(Graphics) invocation if\n     * still referenced, otherwise it will be re-created.\n     * \n     * Note that invocation of this method doesn't invalidate the offscreen image,\n     * it will be eventually reused without updating. To be sure that reused image\n     * will be updated on next paintComponent(Graphics) invocation, invoke the\n     * invalidateOffscreenImage() or invalidateOffscreenImage(Rectangle) method\n     * after weakly releasing the offscreen image.\n     */\n    protected final void weaklyReleaseOffscreenImage() {\n        if (offscreenImage != null) offscreenImage.flush();\n        offscreenImage = null;\n    }\n    /**\n     * Marks the whole offscreen image as invalid. The image will be updated on\n     * next paintComponent(Graphics) invocation.\n     */\n    protected final void invalidateImage() {\n        invalidOffscreenArea.setBounds(0, 0, getWidth(), getHeight());\n    }\n    /**<fim_middle>// function below has no smell\n"}