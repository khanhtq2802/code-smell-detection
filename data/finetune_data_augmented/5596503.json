{"text": "<fim_prefix>\n<fim_suffix>public class JSAMDEmitter extends JSEmitter implements IJSAMDEmitter\n{\n    private Map<String, IDefinitionNode> foundAccessors = new HashMap<String, IDefinitionNode>();\n    private int inheritenceLevel = -1;\n    private ExportWriter exportWriter;\n    private boolean initializingFieldsInConstructor;\n    private List<IDefinition> baseClassCalls = new ArrayList<IDefinition>();\n    StringBuilder builder()\n    {\n        return getBuilder();\n    }\n    IJSAMDDocEmitter getDoc()\n    {\n        return (IJSAMDDocEmitter) getDocEmitter();\n    }\n    public JSAMDEmitter(FilterWriter out)\n    {\n        super(out);\n        exportWriter = new ExportWriter(this);\n    }\n    @Override\n    public void emitPackageHeader(IPackageDefinition definition)\n    {\n        // TODO (mschmalle|AMD) this is a hack but I know no other way to do replacements in a Writer\n        setBufferWrite(true);\n        write(JSAMDEmitterTokens.DEFINE);\n        write(ASEmitterTokens.PAREN_OPEN);\n        IASScope containedScope = definition.getContainedScope();\n        ITypeDefinition type = findType(containedScope.getAllLocalDefinitions());\n        if (type == null)\n            return;\n        exportWriter.addFrameworkDependencies();\n        exportWriter.addImports(type);\n        exportWriter.queueExports(type, true);\n        writeToken(ASEmitterTokens.COMMA);\n    }\n    @Override\n    public void emitPackageHeaderContents(IPackageDefinition definition)\n    {\n        // nothing\n    }\n    @Override\n    public void emitPackageContents(IPackageDefinition definition)\n    {\n        IASScope containedScope = definition.getContainedScope();\n        ITypeDefinition type = findType(containedScope.getAllLocalDefinitions());\n        if (type == null)\n            return;\n        write(\"function($exports\");\n        exportWriter.queueExports(type, false);\n        write(\") {\");\n        indentPush();\n        writeNewline();\n        write(\"\\\"use strict\\\"; \");\n        writeNewline();\n        ITypeNode tnode = findTypeNode(definition.getNode());\n        if (tnode != null)\n        {\n            getWalker().walk(tnode); // IClassNode | IInterfaceNode\n        }\n        indentPop();\n        writeNewline();\n        write(\"}\"); // end returned function\n    }\n    @Override\n    public void emitPackageFooter(IPackageDefinition definition)\n    {\n        IASScope containedScope = definition.getContainedScope();\n        ITypeDefinition type = findType(containedScope.getAllLocalDefinitions());\n        if (type == null)\n            return;\n        exportWriter.writeExports(type, true);\n        exportWriter.writeExports(type, false);\n        write(\");\"); // end define()\n        // flush the buffer, writes the builder to out\n        flushBuilder();\n    }\n    private void emitConstructor(IFunctionNode node)\n    {\n        FunctionNode fn = (FunctionNode) node;\n        fn.parseFunctionBody(getProblems());\n        //IFunctionDefinition definition = node.getDefinition();\n        write(\"function \");\n        write(node.getName());\n        emitParameters(node.getParametersContainerNode());\n        if (!isImplicit((IContainerNode) node.getScopedNode()))\n        {\n            emitMethodScope(node.getScopedNode());\n        }\n        else\n        {\n            // we have a synthesized constructor, implict\n        }\n    }\n    @Override\n    public void emitInterface(IInterfaceNode node)\n    {\n        final IInterfaceDefinition definition = node.getDefinition();\n        final String interfaceName = definition.getBaseName();\n        write(\"AS3.interface_($exports, {\");\n        indentPush();\n        writeNewline();\n        write(\"package_: \\\"\");\n        write(definition.getPackageName());\n        write(\"\\\",\");\n        writeNewline();\n        write(\"interface_: \\\"\");\n        write(interfaceName);\n        write(\"\\\"\");\n        IReference[] references = definition.getExtendedInterfaceReferences();\n        final int len = references.length;\n        if (len > 0)\n        {\n            writeNewline();\n            write(\"extends_: [\");\n            indentPush();\n            writeNewline();\n            int i = 0;\n            for (IReference reference : references)\n            {\n                write(reference.getName());\n                if (i < len - 1)\n                {\n                    write(\",\");\n                    writeNewline();\n                }\n                i++;\n            }\n            indentPop();\n            writeNewline();\n            write(\"]\");\n        }\n        indentPop();\n        writeNewline();\n        write(\"});\"); // end compilation unit\n    }\n    @Override\n    public void emitClass(IClassNode node)\n    {\n        //ICompilerProject project = getWalker().getProject();\n        IClassDefinition definition = node.getDefinition();\n        getModel().setCurrentClass(definition);\n        final String className = definition.getBaseName();\n        write(\"AS3.compilationUnit($exports, function($primaryDeclaration){\");\n        indentPush();\n        writeNewline();\n        // write constructor\n        emitConstructor((IFunctionNode) definition.getConstructor().getNode());\n        writeNewline();\n        // base class\n        IReference baseClassReference = definition.getBaseClassReference();\n        boolean hasSuper = baseClassReference != null\n                && !baseClassReference.getName().equals(\"Object\");\n        if (hasSuper)\n        {\n            String baseName = baseClassReference.getName();\n            write(\"var Super = (\" + baseName + \"._ || \" + baseName\n                    + \"._$get());\");\n            writeNewline();\n            write(\"var super$ = Super.prototype;\");\n            writeNewline();\n        }\n        write(\"$primaryDeclaration(AS3.class_({\");\n        indentPush();\n        writeNewline();\n        // write out package\n        write(\"package_: \\\"\" + definition.getPackageName() + \"\\\",\");\n        writeNewline();\n        // write class\n        write(\"class_: \\\"\" + definition.getBaseName() + \"\\\",\");\n        writeNewline();\n        if (hasSuper)\n        {\n            write(\"extends_: Super,\");\n            writeNewline();\n        }\n        IReference[] references = definition\n                .getImplementedInterfaceReferences();\n        int len = references.length;\n        // write implements\n        write(\"implements_:\");\n        write(\" [\");\n        if (len > 0)\n        {\n            indentPush();\n            writeNewline();\n        }\n        int i = 0;\n        for (IReference reference : references)\n        {\n            write(reference.getName());\n            exportWriter.addDependency(reference.getName(),\n                    reference.getDisplayString(), false, false);\n            if (i < len - 1)\n            {\n                write(\",\");\n                writeNewline();\n            }\n            i++;\n        }\n        if (len > 0)\n        {\n            indentPop();\n            writeNewline();\n        }\n        write(\"],\");\n        writeNewline();\n        // write members\n        final IDefinitionNode[] members = node.getAllMemberNodes();\n        write(\"members: {\");\n        indentPush();\n        writeNewline();\n        // constructor\n        write(\"constructor: \" + className);\n        if (members.length > 0)\n        {\n            write(\",\");\n            writeNewline();\n        }\n        List<IDefinitionNode> instanceMembers = new ArrayList<IDefinitionNode>();\n        List<IDefinitionNode> staticMembers = new ArrayList<IDefinitionNode>();\n        List<IASNode> staticStatements = new ArrayList<IASNode>();\n        TempTools.fillInstanceMembers(members, instanceMembers);\n        TempTools.fillStaticMembers(members, staticMembers, true, false);\n        TempTools.fillStaticStatements(node, staticStatements, false);\n        len = instanceMembers.size();\n        i = 0;\n        for (IDefinitionNode mnode : instanceMembers)\n        {\n            if (mnode instanceof IAccessorNode)\n            {\n                if (foundAccessors.containsKey(mnode.getName()))\n                {\n                    len--;\n                    continue;\n                }\n                getWalker().walk(mnode);\n            }\n            else if (mnode instanceof IFunctionNode)\n            {\n                getWalker().walk(mnode);\n            }\n            else if (mnode instanceof IVariableNode)\n            {\n                getWalker().walk(mnode);\n            }\n            else\n            {\n                write(mnode.getName());\n            }\n            if (i < len - 1)\n            {\n                write(\",\");\n                writeNewline();\n            }\n            i++;\n        }\n        // base class super calls\n        len = baseClassCalls.size();\n        i = 0;\n        if (len > 0)\n        {\n            write(\",\");\n            writeNewline();\n        }\n        for (IDefinition baseCall : baseClassCalls)\n        {\n            write(baseCall.getBaseName() + \"$\" + inheritenceLevel + \": super$.\"\n                    + baseCall.getBaseName());\n            if (i < len - 1)\n            {\n                write(\",\");\n                writeNewline();\n            }\n        }\n        // end members\n        indentPop();\n        writeNewline();\n        write(\"},\");\n        writeNewline();\n        len = staticMembers.size();\n        write(\"staticMembers: {\");\n        indentPush();\n        writeNewline();\n        i = 0;\n        for (IDefinitionNode mnode : staticMembers)\n        {\n            if (mnode instanceof IAccessorNode)\n            {<fim_middle>// class below is blob\n"}