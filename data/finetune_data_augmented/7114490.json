{"text": "<fim_prefix>       */\n      if ((source instanceof StreamSource && source.getSystemId()==null &&\n         ((StreamSource)source).getInputStream()==null &&\n         ((StreamSource)source).getReader()==null)||\n         (source instanceof SAXSource &&\n         ((SAXSource)source).getInputSource()==null &&\n         ((SAXSource)source).getXMLReader()==null )||\n         (source instanceof DOMSource && ((DOMSource)source).getNode()==null)){\n        try {\n          DocumentBuilderFactory builderF = \n                   DocumentBuilderFactory.newInstance();\n          DocumentBuilder builder = builderF.newDocumentBuilder();\n          String systemID = source.getSystemId();\n          source = new DOMSource(builder.newDocument());\n          // Copy system ID from original, empty Source to new Source\n          if (systemID != null) {\n            source.setSystemId(systemID);\n          }\n        } catch (ParserConfigurationException e) {\n          fatalError(e);\n        }           \n      }\n      DTM dtm = mgr.getDTM(source, false, this, true, true);\n      dtm.setDocumentBaseURI(base);\n      boolean hardDelete = true;  // %REVIEW% I have to think about this. -sb\n      try\n      {\n      \t// NOTE: This will work because this is _NOT_ a shared DTM, and thus has\n      \t// only a single Document node. If it could ever be an RTF or other\n      \t// shared DTM, look at dtm.getDocumentRoot(nodeHandle).\n        this.transformNode(dtm.getDocument());\n      }\n      finally\n      {\n        if (shouldRelease)\n          mgr.release(dtm, hardDelete);\n      }\n      // Kick off the parse.  When the ContentHandler gets \n      // the startDocument event, it will call transformNode( node ).\n      // reader.parse( xmlSource );\n      // This has to be done to catch exceptions thrown from \n      // the transform thread spawned by the STree handler.\n      Exception e = getExceptionThrown();\n      if (null != e)\n      {\n        if (e instanceof javax.xml.transform.TransformerException)\n        {\n          throw (javax.xml.transform.TransformerException) e;\n        }\n        else if (e instanceof org.apache.xml.utils.WrappedRuntimeException)\n        {\n          fatalError(\n              ((org.apache.xml.utils.WrappedRuntimeException) e).getException());\n        }\n        else\n        {\n          throw new javax.xml.transform.TransformerException(e);\n        }\n      }\n      else if (null != m_serializationHandler)\n      {\n        m_serializationHandler.endDocument();\n      }\n    }\n    catch (org.apache.xml.utils.WrappedRuntimeException wre)\n    {\n      Throwable throwable = wre.getException();\n      while (throwable\n             instanceof org.apache.xml.utils.WrappedRuntimeException)\n      {\n        throwable =\n          ((org.apache.xml.utils.WrappedRuntimeException) throwable).getException();\n      }\n      fatalError(throwable);\n    }\n    // Patch attributed to David Eisenberg <david@catcode.com>\n    catch (org.xml.sax.SAXParseException spe)\n    {\n      fatalError(spe);\n    }\n    catch (org.xml.sax.SAXException se)\n    {\n      m_errorHandler.fatalError(new TransformerException(se));\n    }\n    finally\n    {\n      m_hasTransformThreadErrorCatcher = false;\n      // This looks to be redundent to the one done in TransformNode.\n      reset();\n    }\n  }\n  private void fatalError(Throwable throwable) throws TransformerException\n  {\n    if (throwable instanceof org.xml.sax.SAXParseException)\n      m_errorHandler.fatalError(new TransformerException(throwable.getMessage(),new SAXSourceLocator((org.xml.sax.SAXParseException)throwable)));\n    else\n      m_errorHandler.fatalError(new TransformerException(throwable));\n  }\n  /**\n   * Get the base URL of the source.\n   *\n   *\n   * NEEDSDOC @param base\n   * @return The base URL of the source tree, or null.\n   */\n  public void setBaseURLOfSource(String base)\n  {\n    m_urlOfSource = base;\n  }\n  /**\n   * Get an output property that is in effect for the\n   * transformation.  The property specified may be a property\n   * that was set with setOutputProperty, or it may be a\n   * property specified in the stylesheet.\n   *\n   * NEEDSDOC @param qnameString\n   *\n   * @return The string value of the output property, or null\n   * if no property was found.\n   *\n   * @throws IllegalArgumentException If the property is not supported.\n   *\n   * @see javax.xml.transform.OutputKeys\n   */\n  public String getOutputProperty(String qnameString)\n          throws IllegalArgumentException\n  {\n    String value = null;\n    OutputProperties props = getOutputFormat();\n    value = props.getProperty(qnameString);\n    if (null == value)\n    {\n      if (!OutputProperties.isLegalPropertyKey(qnameString))\n        throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_OUTPUT_PROPERTY_NOT_RECOGNIZED, new Object[]{qnameString})); //\"output property not recognized: \"\n                                           //+ qnameString);\n    }\n    return value;\n  }\n  /**\n   * Get the value of a property, without using the default properties.  This\n   * can be used to test if a property has been explicitly set by the stylesheet\n   * or user.\n   *\n   * NEEDSDOC @param qnameString\n   *\n   * @return The value of the property, or null if not found.\n   *\n   * @throws IllegalArgumentException If the property is not supported,\n   * and is not namespaced.\n   */\n  public String getOutputPropertyNoDefault(String qnameString)\n          throws IllegalArgumentException\n  {\n    String value = null;\n    OutputProperties props = getOutputFormat();\n    value = (String) props.getProperties().get(qnameString);\n    if (null == value)\n    {\n      if (!OutputProperties.isLegalPropertyKey(qnameString))\n        throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_OUTPUT_PROPERTY_NOT_RECOGNIZED, new Object[]{qnameString})); //\"output property not recognized: \"\n                                          // + qnameString);\n    }\n    return value;\n  }\n  /**\n   * This method is used to set or override the value\n   * of the effective xsl:output attribute values\n   * specified in the stylesheet.\n   * <p>\n   * The recognized standard output properties are:\n   * <ul>\n   * <li>cdata-section-elements\n   * <li>doctype-system\n   * <li>doctype-public\n   * <li>indent\n   * <li>media-type\n   * <li>method\n   * <li>omit-xml-declaration\n   * <li>standalone\n   * <li>version\n   * </ul>\n   * <p>\n   * For example:\n   * <pre>\n   *   tran.setOutputProperty(\"standalone\", \"yes\");\n   * </pre>\n   * <p>\n   * In the case of the cdata-section-elements property,\n   * the value should be a whitespace separated list of\n   * element names.  The element name is the local name\n   * of the element, if it is in no namespace, or, the URI\n   * in braces followed immediately by the local name\n   * if the element is in that namespace. For example: \n   * <pre>\n   * tran.setOutputProperty(\n   *   \"cdata-section-elements\", \n   *   \"elem1 {http://example.uri}elem2 elem3\");\n   * </pre>\n   * <p>\n   * The recognized Xalan extension elements are: \n   * <ul>\n   * <li>content-handler\n   * <li>entities\n   * <li>indent-amount\n   * <li>line-separator\n   * <li>omit-meta-tag\n   * <li>use-url-escaping\n   * </ul>\n   * <p>\n   * These must be in the extension namespace of\n   * \"http://xml.apache.org/xalan\".  This is accomplished\n   * by putting the namespace URI in braces before the \n   * property name, for example:\n   * <pre>\n   *   tran.setOutputProperty(\n   *     \"{http://xml.apache.org/xalan}line-separator\" ,\n   *     \"\\n\");\n   * </pre> \n   *\n   * @param name The property name.\n   * @param value The requested value for the property.\n   * @throws IllegalArgumentException if the property name is not legal.\n   */\n<fim_suffix>  public void setOutputProperty(String name, String value)\n          throws IllegalArgumentException\n  {\n    synchronized (m_reentryGuard)\n    {\n      // Get the output format that was set by the user, otherwise get the \n      // output format from the stylesheet.\n      if (null == m_outputFormat)\n      {\n        m_outputFormat =\n          (OutputProperties) getStylesheet().getOutputComposed().clone();\n      }\n      if (!OutputProperties.isLegalPropertyKey(name))\n        throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_OUTPUT_PROPERTY_NOT_RECOGNIZED, new Object[]{name})); //\"output property not recognized: \"\n                                           //+ name);\n      m_outputFormat.setProperty(name, value);\n    }\n  }<fim_middle>// function below has no smell\n"}