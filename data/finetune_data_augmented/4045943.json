{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.beam.runners.direct;\n\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport org.apache.beam.runners.local.StructuralKey;\nimport org.apache.beam.sdk.coders.ByteArrayCoder;\nimport org.apache.beam.sdk.io.Read.Unbounded;\nimport org.apache.beam.sdk.transforms.PTransform;\nimport org.apache.beam.vendor.guava.v20_0.com.google.common.cache.CacheBuilder;\nimport org.apache.beam.vendor.guava.v20_0.com.google.common.cache.CacheLoader;\nimport org.apache.beam.vendor.guava.v20_0.com.google.common.cache.LoadingCache;\nimport org.joda.time.Duration;\n\n/**\n * Provides methods to determine if a record is a duplicate within the evaluation of a {@link\n * Unbounded} {@link PTransform}.\n */\ninterface UnboundedReadDeduplicator {\n  /**\n   * Returns true if the record with the provided ID should be output, and false if it should not be\n   * because it is a duplicate.\n   */\n  boolean shouldOutput(byte[] recordId);\n\n  /**\n   * An {@link UnboundedReadDeduplicator} that always returns true. For use with sources do not\n   * require deduplication.\n   */\n<fim_suffix>  class NeverDeduplicator implements UnboundedReadDeduplicator {\n    /** Create a new {@link NeverDeduplicator}. */\n    public static UnboundedReadDeduplicator create() {\n      return new NeverDeduplicator();\n    }\n\n    @Override\n    public boolean shouldOutput(byte[] recordId) {\n      return true;\n    }\n  }\n\n  /**\n   * An {@link UnboundedReadDeduplicator} that returns true if the record ID has not been seen\n   * within 10 minutes.\n   */\n  class CachedIdDeduplicator implements UnboundedReadDeduplicator {\n    private static final ByteArrayCoder RECORD_ID_CODER = ByteArrayCoder.of();\n    private static final long MAX_RETENTION_SINCE_ACCESS =\n        Duration.standardMinutes(10L).getMillis();\n\n    private final LoadingCache<StructuralKey<byte[]>, AtomicBoolean> ids;\n\n    /** Create a new {@link CachedIdDeduplicator}. */\n    public static UnboundedReadDeduplicator create() {\n      return new CachedIdDeduplicator();\n    }\n\n    private CachedIdDeduplicator() {\n      ids =\n          CacheBuilder.newBuilder()\n              .expireAfterAccess(MAX_RETENTION_SINCE_ACCESS, TimeUnit.MILLISECONDS)\n              .maximumSize(100_000L)\n              .build(new TrueBooleanLoader());\n    }\n\n    @Override\n    public boolean shouldOutput(byte[] recordId) {\n      return ids.getUnchecked(StructuralKey.of(recordId, RECORD_ID_CODER)).getAndSet(false);\n    }\n\n    private static class TrueBooleanLoader\n        extends CacheLoader<StructuralKey<byte[]>, AtomicBoolean> {\n      @Override\n      public AtomicBoolean load(StructuralKey<byte[]> key) throws Exception {\n        return new AtomicBoolean(true);\n      }\n    }\n  }\n}<fim_middle>// class below has no smell\n"}