{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.metron.enrichment.stellar;\n\nimport java.lang.invoke.MethodHandles;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport org.apache.metron.enrichment.adapters.maxmind.geo.GeoLiteCityDatabase;\nimport org.apache.metron.stellar.dsl.Context;\nimport org.apache.metron.stellar.dsl.ParseException;\nimport org.apache.metron.stellar.dsl.Stellar;\nimport org.apache.metron.stellar.dsl.StellarFunction;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class GeoEnrichmentFunctions {\n  private static final Logger LOG = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n\n  @Stellar(name=\"GET\"\n          ,namespace=\"GEO\"\n          ,description=\"Look up an IPV4 address and returns geographic information about it\"\n          ,params = {\n                      \"ip - The IPV4 address to lookup\",\n                      \"fields - Optional list of GeoIP fields to grab. Options are locID, country, city, postalCode, dmaCode, latitude, longitude, location_point\"\n                    }\n          ,returns = \"If a Single field is requested a string of the field, If multiple fields a map of string of the fields, and null otherwise\"\n  )\n  public static class GeoGet implements StellarFunction {\n    boolean initialized = false;\n\n<fim_suffix>    @Override\n    public Object apply(List<Object> args, Context context) throws ParseException {\n      if(!initialized) {\n        return null;\n      }\n      if(args.size() > 2) {\n        throw new IllegalArgumentException(\"GEO_GET received more arguments than expected: \" + args.size());\n      }\n\n      if(args.size() == 1 && args.get(0) instanceof String) {\n        // If no fields are provided, return everything\n        String ip = (String) args.get(0);\n        if(ip == null || ip.trim().isEmpty()) {\n          return null;\n        }\n\n        Optional<Map<String, String>> result = GeoLiteCityDatabase.INSTANCE.get(ip);\n        return result.orElse(Collections.emptyMap());\n      } else if (args.size() == 2 && args.get(1) instanceof List) {\n        // If fields are provided, return just those fields.\n        String ip = (String) args.get(0);\n        @SuppressWarnings(\"unchecked\")\n        List<String> fields = (List) args.get(1);\n        Optional<Map<String, String>> result = GeoLiteCityDatabase.INSTANCE.get(ip);\n\n        // If only one field is requested, just return it directly\n        if(fields.size() == 1 && result.isPresent()) {\n          return result.get().get(fields.get(0));\n        } else if (result.isPresent()) {\n          // If multiple fields are requested, return all of them\n          Map<String, String> filteredInfo = new HashMap<>();\n          for(String field : fields) {\n            Map<String, String> geoInfo = result.get();\n            filteredInfo.put(field, geoInfo.get(field));\n          }\n          return filteredInfo;\n        }\n      }\n\n      return null;\n    }\n\n    @Override\n    public void initialize(Context context) {\n        LOG.info(\"Initializing GeoEnrichmentFunctions\");\n        Map<String, Object> config = getConfig(context);\n        String hdfsDir = (String) config.get(GeoLiteCityDatabase.GEO_HDFS_FILE);\n        GeoLiteCityDatabase.INSTANCE.update(hdfsDir);\n        initialized = true;\n    }\n\n    private static Map<String, Object> getConfig(Context context) {\n      return (Map<String, Object>) context.getCapability(Context.Capabilities.GLOBAL_CONFIG, false).orElse(new HashMap<>());\n    }\n\n    @Override\n    public boolean isInitialized() {\n      return initialized;\n    }\n\n  }\n}<fim_middle>// function below has no smell\n"}