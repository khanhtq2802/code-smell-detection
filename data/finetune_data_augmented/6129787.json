{"text": "<fim_prefix>    }\n    @Override\n    public int size()\n    {\n        return 1;\n    }\n    @Override\n    public boolean isEmpty()\n    {\n        return false;\n    }\n    @Override\n    public boolean notEmpty()\n    {\n        return true;\n    }\n    @Override\n    public T getFirst()\n    {\n        return this.value;\n    }\n    @Override\n    public T getLast()\n    {\n        return this.value;\n    }\n    @Override\n    public T getOnly()\n    {\n        return this.value;\n    }\n    @Override\n    public boolean contains(Object object)\n    {\n        return Comparators.nullSafeEquals(this.value, object);\n    }\n    @Override\n    public boolean containsAllIterable(Iterable<?> source)\n    {\n        return Iterate.allSatisfy(source, Predicates.equal(this.value));\n    }\n    @Override\n    public boolean containsAllArguments(Object... elements)\n    {\n        return ArrayIterate.allSatisfy(elements, Predicates.equal(this.value));\n    }\n    @Override\n    public ImmutableBag<T> selectByOccurrences(IntPredicate predicate)\n    {\n        return predicate.accept(1)\n                ? this\n                : Bags.immutable.empty();\n    }\n    @Override\n    public ImmutableBag<T> select(Predicate<? super T> predicate)\n    {\n        return predicate.accept(this.value)\n                ? this\n                : Bags.immutable.empty();\n    }\n    @Override\n    public <R extends Collection<T>> R select(Predicate<? super T> predicate, R target)\n    {\n        if (predicate.accept(this.value))\n        {\n            target.add(this.value);\n        }\n        return target;\n    }\n    @Override\n    public <P, R extends Collection<T>> R selectWith(\n            Predicate2<? super T, ? super P> predicate,\n            P parameter,\n            R target)\n    {\n        if (predicate.accept(this.value, parameter))\n        {\n            target.add(this.value);\n        }\n        return target;\n    }\n    @Override\n    public ImmutableBag<T> reject(Predicate<? super T> predicate)\n    {\n        return predicate.accept(this.value)\n                ? Bags.immutable.empty()\n                : this;\n    }\n    @Override\n    public <R extends Collection<T>> R reject(Predicate<? super T> predicate, R target)\n    {\n        if (!predicate.accept(this.value))\n        {\n            target.add(this.value);\n        }\n        return target;\n    }\n    @Override\n    public <P, R extends Collection<T>> R rejectWith(\n            Predicate2<? super T, ? super P> predicate,\n            P parameter,\n            R target)\n    {\n        if (!predicate.accept(this.value, parameter))\n        {\n            target.add(this.value);\n        }\n        return target;\n    }\n    @Override\n    public <S> ImmutableBag<S> selectInstancesOf(Class<S> clazz)\n    {\n        return clazz.isInstance(this.value)\n                ? (ImmutableBag<S>) this\n                : Bags.immutable.empty();\n    }\n    @Override\n    public <V> ImmutableBag<V> collect(Function<? super T, ? extends V> function)\n    {\n        return Bags.immutable.with(function.valueOf(this.value));\n    }\n    @Override\n    public <V> ImmutableBag<V> collectIf(\n            Predicate<? super T> predicate,\n            Function<? super T, ? extends V> function)\n    {\n        return predicate.accept(this.value)\n                ? Bags.immutable.with(function.valueOf(this.value))\n                : Bags.immutable.empty();\n    }\n    @Override\n    public <V, R extends Collection<V>> R collectIf(\n            Predicate<? super T> predicate, Function<? super T, ? extends V> function, R target)\n    {\n        if (predicate.accept(this.value))\n        {\n            target.add(function.valueOf(this.value));\n        }\n        return target;\n    }\n    @Override\n    public <V> ImmutableBag<V> flatCollect(Function<? super T, ? extends Iterable<V>> function)\n    {\n        return this.flatCollect(function, HashBag.newBag()).toImmutable();\n    }\n    @Override\n    public <V, R extends Collection<V>> R flatCollect(\n            Function<? super T, ? extends Iterable<V>> function, R target)\n    {\n        Iterate.addAllTo(function.valueOf(this.value), target);\n        return target;\n    }\n    @Override\n    public T detect(Predicate<? super T> predicate)\n    {\n        return predicate.accept(this.value)\n                ? this.value\n                : null;\n    }\n    @Override\n    public Optional<T> detectOptional(Predicate<? super T> predicate)\n    {\n        return predicate.accept(this.value)\n                ? Optional.of(this.value)\n                : Optional.empty();\n    }\n    @Override\n    public T detectIfNone(Predicate<? super T> predicate, Function0<? extends T> function)\n    {\n        return predicate.accept(this.value)\n                ? this.value\n                : function.value();\n    }\n    @Override\n    public int count(Predicate<? super T> predicate)\n    {\n        return predicate.accept(this.value)\n                ? 1\n                : 0;\n    }\n    @Override\n    public boolean anySatisfy(Predicate<? super T> predicate)\n    {\n        return predicate.accept(this.value);\n    }\n    @Override\n    public <V> ImmutableBagMultimap<V, T> groupBy(Function<? super T, ? extends V> function)\n    {\n        return this.groupBy(function, HashBagMultimap.<V, T>newMultimap()).toImmutable();\n    }\n    @Override\n    public <V, R extends MutableMultimap<V, T>> R groupBy(Function<? super T, ? extends V> function, R target)\n    {\n        target.putAll(function.valueOf(this.value), this);\n        return target;\n    }\n    @Override\n    public <V> ImmutableBagMultimap<V, T> groupByEach(Function<? super T, ? extends Iterable<V>> function)\n    {\n        return this.groupByEach(function, HashBagMultimap.newMultimap()).toImmutable();\n    }\n    @Override\n    public <V, R extends MutableMultimap<V, T>> R groupByEach(Function<? super T, ? extends Iterable<V>> function, R target)\n    {\n        this.forEach(MultimapEachPutProcedure.on(target, function));\n        return target;\n    }\n    @Override\n    public int sizeDistinct()\n    {\n        return 1;\n    }\n    @Override\n    public int occurrencesOf(Object item)\n    {\n        return Comparators.nullSafeEquals(this.value, item) ? 1 : 0;\n    }\n    @Override\n    public void forEachWithOccurrences(ObjectIntProcedure<? super T> objectIntProcedure)\n    {\n        objectIntProcedure.value(this.value, 1);\n    }\n    @Override\n    public <V, R extends Collection<V>> R collectWithOccurrences(ObjectIntToObjectFunction<? super T, ? extends V> function, R target)\n    {\n        target.add(function.valueOf(this.value, 1));\n        return target;\n    }\n    @Override\n    public MutableMap<T, Integer> toMapOfItemToCount()\n    {\n        return UnifiedMap.newWithKeysValues(this.value, 1);\n    }\n    @Override\n    public ImmutableBag<T> toImmutable()\n    {\n        return this;\n    }\n    @Override\n    public void each(Procedure<? super T> procedure)\n    {\n        procedure.value(this.value);\n    }\n    @Override\n    public void forEachWithIndex(ObjectIntProcedure<? super T> objectIntProcedure)\n    {\n        objectIntProcedure.value(this.value, 0);\n    }\n    @Override\n    public <P> void forEachWith(Procedure2<? super T, ? super P> procedure, P parameter)\n    {\n        procedure.value(this.value, parameter);\n    }\n    /**\n     * @deprecated in 6.0. Use {@link OrderedIterable#zip(Iterable)} instead.\n     */\n    @Override\n    @Deprecated\n    public <S> ImmutableBag<Pair<T, S>> zip(Iterable<S> that)\n    {\n        Iterator<S> iterator = that.iterator();\n        if (!iterator.hasNext())\n        {\n            return Bags.immutable.empty();\n        }\n        return Bags.immutable.with(Tuples.pair(this.value, iterator.next()));\n    }\n    /**\n     * @deprecated in 6.0. Use {@link OrderedIterable#zipWithIndex()} instead.\n     */\n    @Override\n    @Deprecated\n    public ImmutableSet<Pair<T, Integer>> zipWithIndex()\n    {\n        return Sets.immutable.with(Tuples.pair(this.value, 0));\n    }\n    @Override\n    public Iterator<T> iterator()\n    {\n        return new SingletonIterator();\n    }\n    private class SingletonIterator\n            implements Iterator<T>\n    {\n        private boolean next = true;\n<fim_suffix>        @Override\n        public boolean hasNext()\n        {\n            return this.next;\n        }<fim_middle>// function below has no smell\n"}