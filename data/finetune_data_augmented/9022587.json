{"text": "<fim_prefix>      strategy.setEscape(escape.charAt(0));\n    } else {\n      if (encapsulator != null) {\n        strategy.setEncapsulator(encapsulator.charAt(0));\n      }\n      if (escape != null) {\n        char ch = escape.charAt(0);\n        strategy.setEscape(ch);\n        if (ch == '\\\\') {\n          // If the escape is the standard backslash, then also enable\n          // unicode escapes (it's harmless since 'u' would not otherwise\n          // be escaped.                    \n          strategy.setUnicodeEscapeInterpretation(true);\n        }\n      }\n    }\n    String fn = params.get(FIELDNAMES);\n    fieldnames = fn != null ? commaSplit.split(fn,-1) : null;\n    Boolean hasHeader = params.getBool(HEADER);\n    skipLines = params.getInt(SKIPLINES,0);\n    if (fieldnames==null) {\n      if (null == hasHeader) {\n        // assume the file has the headers if they aren't supplied in the args\n        hasHeader=true;\n      } else if (!hasHeader) {\n        throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"CSVLoader: must specify fieldnames=<fields>* or header=true\");\n      }\n    } else {\n      // if the fieldnames were supplied and the file has a header, we need to\n      // skip over that header.\n      if (hasHeader!=null && hasHeader) skipLines++;\n      prepareFields();\n    }\n  }\n  /** create the FieldAdders that control how each field  is indexed */\n  void prepareFields() {\n    // Possible future optimization: for really rapid incremental indexing\n    // from a POST, one could cache all of this setup info based on the params.\n    // The link from FieldAdder to this would need to be severed for that to happen.\n    adders = new CSVLoaderBase.FieldAdder[fieldnames.length];\n    String skipStr = params.get(SKIP);\n    List<String> skipFields = skipStr==null ? null : StrUtils.splitSmart(skipStr,',');\n    CSVLoaderBase.FieldAdder adder = new CSVLoaderBase.FieldAdder();\n    CSVLoaderBase.FieldAdder adderKeepEmpty = new CSVLoaderBase.FieldAdderEmpty();\n    for (int i=0; i<fieldnames.length; i++) {\n      String fname = fieldnames[i];\n      // to skip a field, leave the entries in fields and addrs null\n      if (fname.length()==0 || (skipFields!=null && skipFields.contains(fname))) continue;\n      boolean keepEmpty = params.getFieldBool(fname,EMPTY,false);\n      adders[i] = keepEmpty ? adderKeepEmpty : adder;\n      // Order that operations are applied: split -> trim -> map -> add\n      // so create in reverse order.\n      // Creation of FieldAdders could be optimized and shared among fields\n      String[] fmap = params.getFieldParams(fname,MAP);\n      if (fmap!=null) {\n        for (String mapRule : fmap) {\n          String[] mapArgs = colonSplit.split(mapRule,-1);\n          if (mapArgs.length!=2)\n            throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, \"Map rules must be of the form 'from:to' ,got '\"+mapRule+\"'\");\n          adders[i] = new CSVLoaderBase.FieldMapperSingle(mapArgs[0], mapArgs[1], adders[i]);\n        }\n      }\n      if (params.getFieldBool(fname,TRIM,false)) {\n        adders[i] = new CSVLoaderBase.FieldTrimmer(adders[i]);\n      }\n      if (params.getFieldBool(fname,SPLIT,false)) {\n        String sepStr = params.getFieldParam(fname,SEPARATOR);\n        char fsep = sepStr==null || sepStr.length()==0 ? ',' : sepStr.charAt(0);\n        String encStr = params.getFieldParam(fname,ENCAPSULATOR);\n        char fenc = encStr==null || encStr.length()==0 ? (char)-2 : encStr.charAt(0);\n        String escStr = params.getFieldParam(fname,ESCAPE);\n        char fesc = escStr==null || escStr.length()==0 ? CSVStrategy.ESCAPE_DISABLED : escStr.charAt(0);\n        CSVStrategy fstrat = new CSVStrategy\n            (fsep, fenc, CSVStrategy.COMMENTS_DISABLED, fesc, false, false, false, false, \"\\n\");\n        adders[i] = new CSVLoaderBase.FieldSplitter(fstrat, adders[i]);\n      }\n    }\n    // look for any literal fields - literal.foo=xyzzy\n    Iterator<String> paramNames = params.getParameterNamesIterator();\n    while (paramNames.hasNext()) {\n      String pname = paramNames.next();\n      if (!pname.startsWith(LITERALS_PREFIX)) continue;\n      String name = pname.substring(LITERALS_PREFIX.length());\n      literals.put(name, params.get(pname));\n    }\n  }\n  private void input_err(String msg, String[] line, int lineno) {\n    StringBuilder sb = new StringBuilder();\n    sb.append(errHeader).append(\", line=\").append(lineno).append(\",\").append(msg).append(\"\\n\\tvalues={\");\n    for (String val: line) {\n      sb.append(\"'\").append(val).append(\"',\"); }\n    sb.append('}');\n    throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,sb.toString());\n  }\n  private void input_err(String msg, String[] lines, int lineNo, Throwable e) {\n    StringBuilder sb = new StringBuilder();\n    sb.append(errHeader).append(\", line=\").append(lineNo).append(\",\").append(msg).append(\"\\n\\tvalues={\");\n    if (lines != null) {\n      for (String val : lines) {\n        sb.append(\"'\").append(val).append(\"',\");\n      }\n    } else {\n      sb.append(\"NO LINES AVAILABLE\");\n    }\n    sb.append('}');\n    throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,sb.toString(), e);\n  }\n  /** load the CSV input */\n  @Override\n  public void load(SolrQueryRequest req, SolrQueryResponse rsp, ContentStream stream, UpdateRequestProcessor processor) throws IOException {\n    errHeader = \"CSVLoader: input=\" + stream.getSourceInfo();\n    Reader reader = null;\n    try {\n      reader = stream.getReader();\n      if (skipLines>0) {\n        if (!(reader instanceof BufferedReader)) {\n          reader = new BufferedReader(reader);\n        }\n        BufferedReader r = (BufferedReader)reader;\n        for (int i=0; i<skipLines; i++) {\n          r.readLine();\n        }\n      }\n      CSVParser parser = new CSVParser(reader, strategy);\n      // parse the fieldnames from the header of the file\n      if (fieldnames==null) {\n        fieldnames = parser.getLine();\n        if (fieldnames==null) {\n          throw new SolrException( SolrException.ErrorCode.BAD_REQUEST,\"Expected fieldnames in CSV input\");\n        }\n        prepareFields();\n      }\n      // read the rest of the CSV file\n      for(;;) {\n        int line = parser.getLineNumber();  // for error reporting in MT mode\n        String[] vals = null;\n        try {\n          vals = parser.getLine();\n        } catch (IOException e) {\n          //Catch the exception and rethrow it with more line information\n         input_err(\"can't read line: \" + line, null, line, e);\n        }\n        if (vals==null) break;\n        if (vals.length != fieldnames.length) {\n          input_err(\"expected \"+fieldnames.length+\" values but got \"+vals.length, vals, line);\n        }\n        addDoc(line,vals);\n      }\n    } finally{\n      if (reader != null) {\n        IOUtils.closeQuietly(reader);\n      }\n    }\n  }\n  /** called for each line of values (document) */\n  abstract void addDoc(int line, String[] vals) throws IOException;\n  /** this must be MT safe... may be called concurrently from multiple threads. */\n<fim_suffix>  void doAdd(int line, String[] vals, SolrInputDocument doc, AddUpdateCommand template) throws IOException {\n    // the line number is passed for error reporting in MT mode as well as for optional rowId.\n    // first, create the lucene document\n    for (int i=0; i<vals.length; i++) {\n      if (adders[i]==null) continue;  // skip this field\n      String val = vals[i];\n      adders[i].add(doc, line, i, val);\n    }\n    // add any literals\n    for (String fname : literals.keySet()) {\n      String val = literals.get(fname);\n      doc.addField(fname, val);\n    }\n    if (rowId != null){\n      doc.addField(rowId, line + rowIdOffset);\n    }\n    template.solrDoc = doc;\n    processor.processAdd(template);\n  }<fim_middle>// function below has no smell\n"}