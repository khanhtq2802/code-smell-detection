{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.jackrabbit.oak.cache.impl;\n\nimport java.util.List;\nimport java.util.Map;\n\nimport com.codahale.metrics.Counter;\nimport com.codahale.metrics.Metric;\nimport com.codahale.metrics.MetricRegistry;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.Maps;\n\nimport org.apache.jackrabbit.oak.api.jmx.CacheStatsMBean;\nimport org.osgi.service.component.annotations.Component;\nimport org.osgi.service.component.annotations.Reference;\nimport org.osgi.service.component.annotations.ReferenceCardinality;\nimport org.osgi.service.component.annotations.ReferencePolicy;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * An OSGi component that binds to all {@link CacheStatsMBean} instances and\n * exposes their counters as {@link Metric}s.\n */\n@Component(immediate = true)\npublic class CacheStatsMetrics {\n\n    private static final Logger LOG = LoggerFactory.getLogger(CacheStatsMetrics.class);\n\n    static final String REQUEST = \"request\";\n    static final String HIT = \"hit\";\n    static final String MISS = \"miss\";\n    static final String EVICTION = \"eviction\";\n    static final String ELEMENT = \"element\";\n    static final String LOAD_TIME = \"loadTime\";\n\n    private static final List<String> TYPES = ImmutableList.of(\n            REQUEST, HIT, MISS, EVICTION, ELEMENT, LOAD_TIME);\n\n    private Map<String, CacheStatsMBean> cacheStatsMBeans = Maps.newHashMap();\n    private MetricRegistry registry = new MetricRegistry();\n\n    @Reference(\n            cardinality = ReferenceCardinality.AT_LEAST_ONE,\n            policy = ReferencePolicy.DYNAMIC\n    )\n    synchronized void addCacheStatsMBean(CacheStatsMBean stats) {\n        LOG.debug(\"addCacheStatsMBean({})\", stats.getName());\n        cacheStatsMBeans.put(stats.getName(), stats);\n        registerCacheStatsMBean(this.registry, stats);\n    }\n\n    synchronized void removeCacheStatsMBean(CacheStatsMBean stats) {\n        LOG.debug(\"removeCacheStatsMBean({})\", stats.getName());\n        cacheStatsMBeans.remove(stats.getName());\n        unregisterCacheStatsMBean(this.registry, stats);\n    }\n\n    @Reference(\n            target = \"(name=oak)\"\n    )\n    synchronized void setMetricRegistry(MetricRegistry registry) {\n        LOG.debug(\"setMetricRegistry({})\", registry);\n        for (CacheStatsMBean stats : cacheStatsMBeans.values()) {\n            unregisterCacheStatsMBean(this.registry, stats);\n            registerCacheStatsMBean(registry, stats);\n        }\n        this.registry = registry;\n    }\n\n    private static void registerCacheStatsMBean(MetricRegistry registry,\n                                                CacheStatsMBean stats) {\n        registerMetric(registry, new RequestCounter(stats));\n        registerMetric(registry, new HitCounter(stats));\n        registerMetric(registry, new MissCounter(stats));\n        registerMetric(registry, new EvictionCounter(stats));\n        registerMetric(registry, new ElementCounter(stats));\n        registerMetric(registry, new LoadTimeCounter(stats));\n    }\n\n    private static void registerMetric(MetricRegistry registry,\n                                       CacheStatsMBeanCounter metric) {\n        String name = metric.getName();\n        registry.remove(name);\n        registry.register(name, metric);\n    }\n\n    private static void unregisterCacheStatsMBean(MetricRegistry registry,\n                                                  CacheStatsMBean stats) {\n        String name = stats.getName();\n        for (String t : TYPES) {\n            registry.remove(metricName(name, t));\n        }\n    }\n\n    static String metricName(String cacheStatsName, String type) {\n        return \"CacheStats.\" + cacheStatsName + \".\" + type;\n    }\n\n    private abstract static class CacheStatsMBeanCounter\n            extends Counter {\n\n        protected CacheStatsMBean stats;\n        protected String type;\n\n        CacheStatsMBeanCounter(CacheStatsMBean stats, String type) {\n            this.stats = stats;\n            this.type = type;\n        }\n\n        String getName() {\n            return metricName(stats.getName(), type);\n        }\n    }\n\n<fim_suffix>    private static final class RequestCounter extends CacheStatsMBeanCounter {\n\n        RequestCounter(CacheStatsMBean stats) {\n            super(stats, REQUEST);\n        }\n\n        @Override\n        public long getCount() {\n            return stats.getRequestCount();\n        }\n    }\n\n    private static final class HitCounter extends CacheStatsMBeanCounter {\n\n        HitCounter(CacheStatsMBean stats) {\n            super(stats, HIT);\n        }\n\n        @Override\n        public long getCount() {\n            return stats.getHitCount();\n        }\n    }\n\n    private static final class MissCounter extends CacheStatsMBeanCounter {\n\n        MissCounter(CacheStatsMBean stats) {\n            super(stats, MISS);\n        }\n\n        @Override\n        public long getCount() {\n            return stats.getMissCount();\n        }\n    }\n\n    private static final class EvictionCounter extends CacheStatsMBeanCounter {\n\n        EvictionCounter(CacheStatsMBean stats) {\n            super(stats, EVICTION);\n        }\n\n        @Override\n        public long getCount() {\n            return stats.getEvictionCount();\n        }\n    }\n\n    private static final class ElementCounter extends CacheStatsMBeanCounter {\n\n        ElementCounter(CacheStatsMBean stats) {\n            super(stats, ELEMENT);\n        }\n\n        @Override\n        public long getCount() {\n            return stats.getElementCount();\n        }\n    }\n\n    private static final class LoadTimeCounter extends CacheStatsMBeanCounter {\n\n        LoadTimeCounter(CacheStatsMBean stats) {\n            super(stats, LOAD_TIME);\n        }\n\n        @Override\n        public long getCount() {\n            return stats.getTotalLoadTime();\n        }\n    }\n}<fim_middle>// class below has no smell\n"}