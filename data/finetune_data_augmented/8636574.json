{"text": "<fim_prefix>            return null;\n        }\n        List<T> list = new LinkedList<>();\n        for(T t : data){\n            list.add(t);\n        }\n        return list;\n    }\n    public static <T> List<T> toList(Collection<T> collection) {\n        if (collection == null) {\n            return null;\n        }\n        if (collection instanceof List<?>) {\n            return (List<T>) collection;\n        }\n        List<T> list = new LinkedList<>();\n        list.addAll(collection);\n        return list;\n    }\n    public static <T> List<T> toListArray(T[] data) {\n        if (data == null) {\n            return null;\n        }\n        List<T> list = new LinkedList<>();\n        for (T value: data) {\n            list.add(value);\n        }\n        return list;\n    }\n    public static <K, V> void addToListInMap(V element, Map<K, Object> theMap, K listKey) {\n        List<V> theList = UtilGenerics.checkList(theMap.get(listKey));\n        if (theList == null) {\n            theList = new LinkedList<>();\n            theMap.put(listKey, theList);\n        }\n        theList.add(element);\n    }\n    public static <K, V> void addToSetInMap(V element, Map<K, Set<V>> theMap, K setKey) {\n        Set<V> theSet = UtilGenerics.checkSet(theMap.get(setKey));\n        if (theSet == null) {\n            theSet = new LinkedHashSet<>();\n            theMap.put(setKey, theSet);\n        }\n        theSet.add(element);\n    }\n    public static <K, V> void addToSortedSetInMap(V element, Map<K, Set<V>> theMap, K setKey) {\n        Set<V> theSet = UtilGenerics.checkSet(theMap.get(setKey));\n        if (theSet == null) {\n            theSet = new TreeSet<>();\n            theMap.put(setKey, theSet);\n        }\n        theSet.add(element);\n    }\n    /** Converts an <code>Object</code> to a <code>double</code>. Returns\n     * zero if conversion is not possible.\n     * @param obj Object to convert\n     * @return double value\n     */\n    public static double toDouble(Object obj) {\n        Double result = toDoubleObject(obj);\n        return result == null ? 0.0 : result;\n    }\n    /** Converts an <code>Object</code> to a <code>Double</code>. Returns\n     * <code>null</code> if conversion is not possible.\n     * @param obj Object to convert\n     * @return Double\n     */\n    public static Double toDoubleObject(Object obj) {\n        if (obj == null) {\n            return null;\n        }\n        if (obj instanceof Double) {\n            return (Double) obj;\n        }\n        if (obj instanceof Number) {\n            return ((Number) obj).doubleValue();\n        }\n        Double result = null;\n        try {\n            result = Double.parseDouble(obj.toString());\n        } catch (Exception e) {}\n        return result;\n    }\n    /** Converts an <code>Object</code> to an <code>int</code>. Returns\n     * zero if conversion is not possible.\n     * @param obj Object to convert\n     * @return int value\n     */\n    public static int toInteger(Object obj) {\n        Integer result = toIntegerObject(obj);\n        return result == null ? 0 : result;\n    }\n    /** Converts an <code>Object</code> to an <code>Integer</code>. Returns\n     * <code>null</code> if conversion is not possible.\n     * @param obj Object to convert\n     * @return Integer\n     */\n    public static Integer toIntegerObject(Object obj) {\n        if (obj == null) {\n            return null;\n        }\n        if (obj instanceof Integer) {\n            return (Integer) obj;\n        }\n        if (obj instanceof Number) {\n            return ((Number)obj).intValue();\n        }\n        Integer result = null;\n        try {\n            result = Integer.parseInt(obj.toString());\n        } catch (Exception e) {}\n        return result;\n    }\n    /** Converts an <code>Object</code> to a <code>long</code>. Returns\n     * zero if conversion is not possible.\n     * @param obj Object to convert\n     * @return long value\n     */\n    public static long toLong(Object obj) {\n        Long result = toLongObject(obj);\n        return result == null ? 0 : result;\n    }\n    /** Converts an <code>Object</code> to a <code>Long</code>. Returns\n     * <code>null</code> if conversion is not possible.\n     * @param obj Object to convert\n     * @return Long\n     */\n    public static Long toLongObject(Object obj) {\n        if (obj == null) {\n            return null;\n        }\n        if (obj instanceof Long) {\n            return (Long) obj;\n        }\n        if (obj instanceof Number) {\n            return ((Number) obj).longValue();\n        }\n        Long result = null;\n        try {\n            result = Long.parseLong(obj.toString());\n        } catch (Exception e) {}\n        return result;\n    }\n    /**\n     * Adds value to the key entry in theMap, or creates a new one if not already there\n     * @param theMap\n     * @param key\n     * @param value\n     */\n    public static <K> void addToDoubleInMap(Map<K, Object> theMap, K key, Double value) {\n        Double curValue = (Double) theMap.get(key);\n        if (curValue != null) {\n            theMap.put(key, curValue + value);\n        } else {\n            theMap.put(key, value);\n        }\n    }\n    /**\n     * Parse a locale string Locale object\n     * @param localeString The locale string (en_US)\n     * @return Locale The new Locale object or null if no valid locale can be interpreted\n     */\n    public static Locale parseLocale(String localeString) {\n        if (UtilValidate.isEmpty(localeString)) {\n            return null;\n        }\n        Locale locale = null;\n        if (localeString.length() == 2) {\n            // two letter language code\n            locale = new Locale.Builder().setLanguage(localeString).build();\n        } else if (localeString.length() == 5) {\n            // positions 0-1 language, 3-4 are country\n            String language = localeString.substring(0, 2);\n            String country = localeString.substring(3, 5);\n            locale = new Locale.Builder().setLanguage(language).setRegion(country).build();\n        } else if (localeString.length() > 6) {\n            // positions 0-1 language, 3-4 are country, 6 and on are special extensions\n            String language = localeString.substring(0, 2);\n            String country = localeString.substring(3, 5);\n            String extension = localeString.substring(6);\n            locale = new Locale(language, country, extension);\n        } else {\n            Debug.logWarning(\"Do not know what to do with the localeString [\" + localeString + \"], should be length 2, 5, or greater than 6, returning null\", module);\n        }\n        return locale;\n    }\n    /** The input can be a String, Locale, or even null and a valid Locale will always be returned; if nothing else works, returns the default locale.\n     * @param localeObject An Object representing the locale\n     */\n    public static Locale ensureLocale(Object localeObject) {\n        if (localeObject instanceof String) {\n            Locale locale = parseLocale((String) localeObject);\n            if (locale != null)  {\n                return locale;\n            }\n        } else if (localeObject instanceof Locale) {\n            return (Locale) localeObject;\n        }\n        return Locale.getDefault();\n    }\n    // Private lazy-initializer class\n    private static class LocaleHolder {\n        private static final List<Locale> availableLocaleList = getAvailableLocaleList();\n<fim_suffix>        private static List<Locale> getAvailableLocaleList() {\n            TreeMap<String, Locale> localeMap = new TreeMap<>();\n            String localesString = UtilProperties.getPropertyValue(\"general\", \"locales.available\");\n            if (UtilValidate.isNotEmpty(localesString)) {\n                List<String> idList = StringUtil.split(localesString, \",\");\n                for (String id : idList) {\n                    Locale curLocale = parseLocale(id);\n                    localeMap.put(curLocale.getDisplayName(), curLocale);\n                }\n            } else {\n                Locale[] locales = Locale.getAvailableLocales();\n                for (int i = 0; i < locales.length && locales[i] != null; i++) {\n                    String displayName = locales[i].getDisplayName();\n                    if (!displayName.isEmpty()) {\n                        localeMap.put(displayName, locales[i]);\n                    }\n                }\n            }\n            return Collections.unmodifiableList(new ArrayList<>(localeMap.values()));\n        }<fim_middle>// function below has no smell\n"}