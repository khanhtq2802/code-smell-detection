{"text": "<fim_prefix>     * Get the ranges that these merkle trees covers.\n     *\n     * @return\n     */\n    public Collection<Range<Token>> ranges()\n    {\n        return merkleTrees.keySet();\n    }\n    /**\n     * Get the partitioner in use.\n     *\n     * @return\n     */\n    public IPartitioner partitioner()\n    {\n        return partitioner;\n    }\n    /**\n     * Add merkle tree's with the defined maxsize and ranges.\n     *\n     * @param maxsize\n     * @param ranges\n     */\n    public void addMerkleTrees(int maxsize, Collection<Range<Token>> ranges)\n    {\n        for (Range<Token> range : ranges)\n        {\n            addMerkleTree(maxsize, range);\n        }\n    }\n    /**\n     * Add a MerkleTree with the defined size and range.\n     *\n     * @param maxsize\n     * @param range\n     * @return The created merkle tree.\n     */\n    public MerkleTree addMerkleTree(int maxsize, Range<Token> range)\n    {\n        return addMerkleTree(maxsize, MerkleTree.RECOMMENDED_DEPTH, range);\n    }\n    @VisibleForTesting\n    public MerkleTree addMerkleTree(int maxsize, byte hashdepth, Range<Token> range)\n    {\n        MerkleTree tree = new MerkleTree(partitioner, range, hashdepth, maxsize);\n        addTree(tree);\n        return tree;\n    }\n    /**\n     * Get the MerkleTree.Range responsible for the given token.\n     *\n     * @param t\n     * @return\n     */\n    @VisibleForTesting\n    public MerkleTree.TreeRange get(Token t)\n    {\n        return getMerkleTree(t).get(t);\n    }\n    /**\n     * Init all MerkleTree's with an even tree distribution.\n     */\n    public void init()\n    {\n        for (Range<Token> range : merkleTrees.keySet())\n        {\n            init(range);\n        }\n    }\n    /**\n     * Init a selected MerkleTree with an even tree distribution.\n     *\n     * @param range\n     */\n    public void init(Range<Token> range)\n    {\n        merkleTrees.get(range).init();\n    }\n    /**\n     * Split the MerkleTree responsible for the given token.\n     *\n     * @param t\n     * @return\n     */\n    public boolean split(Token t)\n    {\n        return getMerkleTree(t).split(t);\n    }\n    /**\n     * Invalidate the MerkleTree responsible for the given token.\n     *\n     * @param t\n     */\n    @VisibleForTesting\n    public void invalidate(Token t)\n    {\n        getMerkleTree(t).invalidate(t);\n    }\n    /**\n     * Get the MerkleTree responsible for the given token range.\n     *\n     * @param range\n     * @return\n     */\n    public MerkleTree getMerkleTree(Range<Token> range)\n    {\n        return merkleTrees.get(range);\n    }\n    public long size()\n    {\n        long size = 0;\n        for (MerkleTree tree : merkleTrees.values())\n        {\n            size += tree.size();\n        }\n        return size;\n    }\n    @VisibleForTesting\n    public void maxsize(Range<Token> range, int maxsize)\n    {\n        getMerkleTree(range).maxsize(maxsize);\n    }\n    /**\n     * Get the MerkleTree responsible for the given token.\n     *\n     * @param t\n     * @return The given MerkleTree or null if none exist.\n     */\n    private MerkleTree getMerkleTree(Token t)\n    {\n        for (Range<Token> range : merkleTrees.keySet())\n        {\n            if (range.contains(t))\n                return merkleTrees.get(range);\n        }\n        throw new AssertionError(\"Expected tree for token \" + t);\n    }\n    private void addTrees(Collection<MerkleTree> trees)\n    {\n        for (MerkleTree tree : trees)\n        {\n            addTree(tree);\n        }\n    }\n    private void addTree(MerkleTree tree)\n    {\n        assert validateNonOverlapping(tree) : \"Range [\" + tree.fullRange + \"] is intersecting an existing range\";\n        merkleTrees.put(tree.fullRange, tree);\n    }\n    private boolean validateNonOverlapping(MerkleTree tree)\n    {\n        for (Range<Token> range : merkleTrees.keySet())\n        {\n            if (tree.fullRange.intersects(range))\n                return false;\n        }\n        return true;\n    }\n    /**\n     * Get an iterator for all the invalids generated by the MerkleTrees.\n     *\n     * @return\n     */\n    public TreeRangeIterator invalids()\n    {\n        return new TreeRangeIterator();\n    }\n    /**\n     * Log the row count per leaf for all MerkleTrees.\n     *\n     * @param logger\n     */\n    public void logRowCountPerLeaf(Logger logger)\n    {\n        for (MerkleTree tree : merkleTrees.values())\n        {\n            tree.histogramOfRowCountPerLeaf().log(logger);\n        }\n    }\n    /**\n     * Log the row size per leaf for all MerkleTrees.\n     *\n     * @param logger\n     */\n    public void logRowSizePerLeaf(Logger logger)\n    {\n        for (MerkleTree tree : merkleTrees.values())\n        {\n            tree.histogramOfRowSizePerLeaf().log(logger);\n        }\n    }\n    @VisibleForTesting\n    public byte[] hash(Range<Token> range)\n    {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        boolean hashed = false;\n        try\n        {\n            for (Range<Token> rt : merkleTrees.keySet())\n            {\n                if (rt.intersects(range))\n                {\n                    byte[] bytes = merkleTrees.get(rt).hash(range);\n                    if (bytes != null)\n                    {\n                        baos.write(bytes);\n                        hashed = true;\n                    }\n                }\n            }\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(\"Unable to append merkle tree hash to result\");\n        }\n        return hashed ? baos.toByteArray() : null;\n    }\n    /**\n     * Get an iterator of all ranges and their MerkleTrees.\n     */\n    public Iterator<Map.Entry<Range<Token>, MerkleTree>> iterator()\n    {\n        return merkleTrees.entrySet().iterator();\n    }\n    public long rowCount()\n    {\n        long totalCount = 0;\n        for (MerkleTree tree : merkleTrees.values())\n        {\n            totalCount += tree.rowCount();\n        }\n        return totalCount;\n    }\n    public class TreeRangeIterator extends AbstractIterator<MerkleTree.TreeRange> implements\n            Iterable<MerkleTree.TreeRange>,\n            PeekingIterator<MerkleTree.TreeRange>\n    {\n        private final Iterator<MerkleTree> it;\n        private MerkleTree.TreeRangeIterator current = null;\n        private TreeRangeIterator()\n        {\n            it = merkleTrees.values().iterator();\n        }\n        public MerkleTree.TreeRange computeNext()\n        {\n            if (current == null || !current.hasNext())\n                return nextIterator();\n            return current.next();\n        }\n        private MerkleTree.TreeRange nextIterator()\n        {\n            if (it.hasNext())\n            {\n                current = it.next().invalids();\n                return current.next();\n            }\n            return endOfData();\n        }\n        public Iterator<MerkleTree.TreeRange> iterator()\n        {\n            return this;\n        }\n    }\n    /**\n     * Get the differences between the two sets of MerkleTrees.\n     *\n     * @param ltree\n     * @param rtree\n     * @return\n     */\n    public static List<Range<Token>> difference(MerkleTrees ltree, MerkleTrees rtree)\n    {\n        List<Range<Token>> differences = new ArrayList<>();\n        for (MerkleTree tree : ltree.merkleTrees.values())\n        {\n            differences.addAll(MerkleTree.difference(tree, rtree.getMerkleTree(tree.fullRange)));\n        }\n        return differences;\n    }\n    public static class MerkleTreesSerializer implements IVersionedSerializer<MerkleTrees>\n    {\n        public void serialize(MerkleTrees trees, DataOutputPlus out, int version) throws IOException\n        {\n            out.writeInt(trees.merkleTrees.size());\n            for (MerkleTree tree : trees.merkleTrees.values())\n            {\n                MerkleTree.serializer.serialize(tree, out, version);\n            }\n        }\n<fim_suffix>        public MerkleTrees deserialize(DataInputPlus in, int version) throws IOException\n        {\n            IPartitioner partitioner = null;\n            int nTrees = in.readInt();\n            Collection<MerkleTree> trees = new ArrayList<>(nTrees);\n            if (nTrees > 0)\n            {\n                for (int i = 0; i < nTrees; i++)\n                {\n                    MerkleTree tree = MerkleTree.serializer.deserialize(in, version);\n                    trees.add(tree);\n                    if (partitioner == null)\n                        partitioner = tree.partitioner();\n                    else\n                        assert tree.partitioner() == partitioner;\n                }\n            }\n            return new MerkleTrees(partitioner, trees);\n        }<fim_middle>// function below has no smell\n"}