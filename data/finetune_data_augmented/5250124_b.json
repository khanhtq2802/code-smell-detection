{"text": "<fim_prefix>                updateJobSla(jobId);\n            }\n            catch (Exception e) {\n                setLogPrefix(jobId);\n                LOG.error(\"Exception in SLA processing for job [{0}]\", jobId, e);\n                LogUtils.clearLogPrefix();\n            }\n        }\n    }\n    /**\n     * Register a new job into the map for SLA tracking\n     * @return true if successful\n     */\n    @Override\n    public boolean addRegistration(String jobId, SLARegistrationBean reg) throws JPAExecutorException {\n        try {\n            if (slaMap.size() < capacity) {\n                SLACalcStatus slaCalc = new SLACalcStatus(reg);\n                slaCalc.setSLAStatus(SLAStatus.NOT_STARTED);\n                slaCalc.setJobStatus(getJobStatus(reg.getAppType()));\n                List<JsonBean> insertList = new ArrayList<JsonBean>();\n                final SLASummaryBean summaryBean = new SLASummaryBean(slaCalc);\n                final Timestamp currentTime = DateUtils.convertDateToTimestamp(new Date());\n                reg.setCreatedTimestamp(currentTime);\n                summaryBean.setCreatedTimestamp(currentTime);\n                insertList.add(reg);\n                insertList.add(summaryBean);\n                BatchQueryExecutor.getInstance().executeBatchInsertUpdateDelete(insertList, null, null);\n                putAndIncrement(jobId, slaCalc);\n                LOG.trace(\"SLA Registration Event - Job:\" + jobId);\n                return true;\n            }\n            else {\n                setLogPrefix(reg.getId());\n                LOG.error(\n                        \"SLACalculator memory capacity reached. Cannot add or update new SLA Registration entry for job [{0}]\",\n                        reg.getId());\n                LogUtils.clearLogPrefix();\n            }\n        }\n        catch (JPAExecutorException jpa) {\n            throw jpa;\n        }\n        return false;\n    }\n    private String getJobStatus(AppType appType) {\n        String status = null;\n        switch (appType) {\n            case COORDINATOR_ACTION:\n                status = CoordinatorAction.Status.WAITING.name();\n                break;\n            case WORKFLOW_ACTION:\n                status = WorkflowAction.Status.PREP.name();\n                break;\n            case WORKFLOW_JOB:\n                status = WorkflowJob.Status.PREP.name();\n                break;\n            default:\n                break;\n        }\n        return status;\n    }\n    /**\n     * Update job into the map for SLA tracking\n     */\n    @Override\n    public boolean updateRegistration(String jobId, SLARegistrationBean reg) throws JPAExecutorException {\n        try {\n            if (slaMap.size() < capacity) {\n                SLACalcStatus slaCalc = new SLACalcStatus(reg);\n                slaCalc.setSLAStatus(SLAStatus.NOT_STARTED);\n                slaCalc.setJobStatus(getJobStatus(reg.getAppType()));\n                @SuppressWarnings(\"rawtypes\")\n                List<UpdateEntry> updateList = new ArrayList<UpdateEntry>();\n                updateList.add(new UpdateEntry<SLARegQuery>(SLARegQuery.UPDATE_SLA_REG_ALL, reg));\n                updateList.add(new UpdateEntry<SLASummaryQuery>(SLASummaryQuery.UPDATE_SLA_SUMMARY_ALL,\n                        new SLASummaryBean(slaCalc)));\n                BatchQueryExecutor.getInstance().executeBatchInsertUpdateDelete(null, updateList, null);\n                putAndIncrement(jobId, slaCalc);\n                LOG.trace(\"SLA Registration Event - Job:\" + jobId);\n                return true;\n            }\n            else {\n                setLogPrefix(reg.getId());\n                LOG.error(\n                        \"SLACalculator memory capacity reached. Cannot add or update new SLA Registration entry for job [{0}]\",\n                        reg.getId());\n                LogUtils.clearLogPrefix();\n            }\n        }\n        catch (JPAExecutorException jpa) {\n            throw jpa;\n        }\n        return false;\n    }\n    /**\n     * Remove job from being tracked in map\n     */\n    @Override\n    public void removeRegistration(String jobId) {\n        if (!removeAndDecrement(jobId)) {\n            historySet.remove(jobId);\n        }\n    }\n    /**\n     * Triggered after receiving Job status change event, update SLA status\n     * accordingly\n     */\n    @Override\n    public boolean addJobStatus(String jobId, String jobStatus, JobEvent.EventStatus jobEventStatus, Date startTime,\n            Date endTime) throws JPAExecutorException, ServiceException {\n        LOG.debug(\n                \"Received addJobStatus request for job  [{0}] jobStatus = [{1}], jobEventStatus = [{2}], startTime = [{3}], \"\n                        + \"endTime = [{4}] \", jobId, jobStatus, jobEventStatus, startTime, endTime);\n        SLACalcStatus slaCalc = slaMap.get(jobId);\n        boolean firstCheckAfterRetstart = checkAndUpdateSLACalcAfterRestart(slaCalc);\n        if (slaCalc == null) {\n            SLARegistrationBean slaRegBean = SLARegistrationQueryExecutor.getInstance().get(\n                    SLARegQuery.GET_SLA_REG_ALL, jobId);\n            if (slaRegBean != null) { // filter out jobs picked by SLA job event listener\n                                      // but not actually configured for SLA\n                SLASummaryBean slaSummaryBean = SLASummaryQueryExecutor.getInstance().get(\n                        SLASummaryQuery.GET_SLA_SUMMARY, jobId);\n                slaCalc = new SLACalcStatus(slaSummaryBean, slaRegBean);\n                putAndIncrement(jobId, slaCalc);\n            }\n        }\n        else {\n            SLASummaryBean summaryBean = ((SLASummaryQueryExecutor) SLASummaryQueryExecutor.getInstance()).get(\n                    SLASummaryQuery.GET_SLA_SUMMARY_EVENTPROCESSED_LAST_MODIFIED, jobId);\n            byte eventProc = summaryBean.getEventProcessed();\n            if (!slaCalc.getLastModifiedTime().equals(summaryBean.getLastModifiedTime())) {\n                // Update last modified time.\n                slaCalc.setLastModifiedTime(summaryBean.getLastModifiedTime());\n                reloadExpectedTimeAndConfig(slaCalc);\n                LOG.debug(\"Last modified time has changed for job \" + jobId + \" reloading config from DB\");\n            }\n            slaCalc.setEventProcessed(eventProc);\n        }\n        if (slaCalc != null) {\n            try {\n                SLAXCommandFactory.getSLAEventXCommand(slaCalc,\n                        ConfigurationService.getLong(SLAService.CONF_SLA_CALC_LOCK_TIMEOUT, 20 * 1000)).call();\n                checkEventProc(slaCalc);\n            }\n            catch (XException e) {\n                if (firstCheckAfterRetstart) {\n                    slaCalc.setSLARegistrationBean(null);\n                }\n                LOG.error(e);\n                throw new ServiceException(e);\n            }\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    private void checkEventProc(SLACalcStatus slaCalc){\n        byte eventProc = slaCalc.getEventProcessed();\n        if (slaCalc.getEventProcessed() >= 8) {\n            removeAndDecrement(slaCalc.getId());\n            LOG.debug(\"Removed Job [{0}] from map after Event-processed=8\", slaCalc.getId());\n        }\n        if (eventProc == 7) {\n            historySet.add(slaCalc.getId());\n            removeAndDecrement(slaCalc.getId());\n            LOG.debug(\"Removed Job [{0}] from map after Event-processed=7\", slaCalc.getId());\n        }\n    }\n<fim_suffix>    public void reloadExpectedTimeAndConfig(SLACalcStatus slaCalc) throws JPAExecutorException {\n        SLARegistrationBean regBean = SLARegistrationQueryExecutor.getInstance().get(\n                SLARegQuery.GET_SLA_EXPECTED_VALUE_CONFIG, slaCalc.getId());\n        if (regBean.getExpectedDuration() > 0) {\n            slaCalc.getSLARegistrationBean().setExpectedDuration(regBean.getExpectedDuration());\n        }\n        if (regBean.getExpectedEnd() != null) {\n            slaCalc.getSLARegistrationBean().setExpectedEnd(regBean.getExpectedEnd());\n        }\n        if (regBean.getExpectedStart() != null) {\n            slaCalc.getSLARegistrationBean().setExpectedStart(regBean.getExpectedStart());\n        }\n        if (regBean.getSLAConfigMap().containsKey(OozieClient.SLA_DISABLE_ALERT)) {\n            slaCalc.getSLARegistrationBean().addToSLAConfigMap(OozieClient.SLA_DISABLE_ALERT,\n                    regBean.getSLAConfigMap().get(OozieClient.SLA_DISABLE_ALERT));\n        }\n        if (regBean.getNominalTime() != null) {\n            slaCalc.getSLARegistrationBean().setNominalTime(regBean.getNominalTime());\n        }\n    }<fim_middle>// function below is long method and feature envy\n"}