{"text": "<fim_prefix>    /*\n     * DnParser implements a recursive descent parser for a single DN.\n     */\n    static class DnParser {\n        private final String name;      // DN being parsed\n        private final char[] chars;     // characters in LDAP name being parsed\n        private final int len;          // length of \"chars\"\n        private int cur = 0;            // index of first unconsumed char in \"chars\"\n        private boolean valuesCaseSensitive;\n        /*\n         * Given an LDAP DN in string form, returns a parser for it.\n         */\n        DnParser(String name, boolean valuesCaseSensitive)\n            throws InvalidNameException {\n            this.name = name;\n            len = name.length();\n            chars = name.toCharArray();\n            this.valuesCaseSensitive = valuesCaseSensitive;\n        }\n        /*\n         * Parses the DN, returning a Vector of its RDNs.\n         */\n        Vector<Rdn> getDn() throws InvalidNameException {\n            cur = 0;\n            Vector<Rdn> rdns = new Vector<>(len / 3 + 10);  // leave room for growth\n            if (len == 0) {\n                return rdns;\n            }\n            rdns.addElement(parseRdn());\n            while (cur < len) {\n                if (chars[cur] == ',' || chars[cur] == ';') {\n                    ++cur;\n                    rdns.insertElementAt(parseRdn(), 0);\n                } else {\n                    throw new InvalidNameException(\"Invalid name: \" + name);\n                }\n            }\n            return rdns;\n        }\n        /*\n         * Parses the DN, if it is known to contain a single RDN.\n         */\n        Rdn getRdn() throws InvalidNameException {\n            Rdn rdn = parseRdn();\n            if (cur < len) {\n                throw new InvalidNameException(\"Invalid RDN: \" + name);\n            }\n            return rdn;\n        }\n        /*\n         * Parses the next RDN and returns it.  Throws an exception if\n         * none is found.  Leading and trailing whitespace is consumed.\n         */\n        private Rdn parseRdn() throws InvalidNameException {\n            Rdn rdn = new Rdn();\n            while (cur < len) {\n                consumeWhitespace();\n                String attrType = parseAttrType();\n                consumeWhitespace();\n                if (cur >= len || chars[cur] != '=') {\n                    throw new InvalidNameException(\"Invalid name: \" + name);\n                }\n                ++cur;          // consume '='\n                consumeWhitespace();\n                String value = parseAttrValue();\n                consumeWhitespace();\n                rdn.add(new TypeAndValue(attrType, value, valuesCaseSensitive));\n                if (cur >= len || chars[cur] != '+') {\n                    break;\n                }\n                ++cur;          // consume '+'\n            }\n            return rdn;\n        }\n        /*\n         * Returns the attribute type that begins at the next unconsumed\n         * char.  No leading whitespace is expected.\n         * This routine is more generous than RFC 2253.  It accepts\n         * attribute types composed of any nonempty combination of Unicode\n         * letters, Unicode digits, '.', '-', and internal space characters.\n         */\n        private String parseAttrType() throws InvalidNameException {\n            final int beg = cur;\n            while (cur < len) {\n                char c = chars[cur];\n                if (Character.isLetterOrDigit(c) ||\n                      c == '.' ||\n                      c == '-' ||\n                      c == ' ') {\n                    ++cur;\n                } else {\n                    break;\n                }\n            }\n            // Back out any trailing spaces.\n            while ((cur > beg) && (chars[cur - 1] == ' ')) {\n                --cur;\n            }\n            if (beg == cur) {\n                throw new InvalidNameException(\"Invalid name: \" + name);\n            }\n            return new String(chars, beg, cur - beg);\n        }\n        /*\n         * Returns the attribute value that begins at the next unconsumed\n         * char.  No leading whitespace is expected.\n         */\n        private String parseAttrValue() throws InvalidNameException {\n            if (cur < len && chars[cur] == '#') {\n                return parseBinaryAttrValue();\n            } else if (cur < len && chars[cur] == '\"') {\n                return parseQuotedAttrValue();\n            } else {\n                return parseStringAttrValue();\n            }\n        }\n        private String parseBinaryAttrValue() throws InvalidNameException {\n            final int beg = cur;\n            ++cur;                      // consume '#'\n            while (cur < len &&\n                   Character.isLetterOrDigit(chars[cur])) {\n                ++cur;\n            }\n            return new String(chars, beg, cur - beg);\n        }\n        private String parseQuotedAttrValue() throws InvalidNameException {\n            final int beg = cur;\n            ++cur;                      // consume '\"'\n            while ((cur < len) && chars[cur] != '\"') {\n                if (chars[cur] == '\\\\') {\n                    ++cur;              // consume backslash, then what follows\n                }\n                ++cur;\n            }\n            if (cur >= len) {   // no closing quote\n                throw new InvalidNameException(\"Invalid name: \" + name);\n            }\n            ++cur       ;       // consume closing quote\n            return new String(chars, beg, cur - beg);\n        }\n        private String parseStringAttrValue() throws InvalidNameException {\n            final int beg = cur;\n            int esc = -1;       // index of the most recently escaped character\n            while ((cur < len) && !atTerminator()) {\n                if (chars[cur] == '\\\\') {\n                    ++cur;              // consume backslash, then what follows\n                    esc = cur;\n                }\n                ++cur;\n            }\n            if (cur > len) {            // 'twas backslash followed by nothing\n                throw new InvalidNameException(\"Invalid name: \" + name);\n            }\n            // Trim off (unescaped) trailing whitespace.\n            int end;\n            for (end = cur; end > beg; end--) {\n                if (!isWhitespace(chars[end - 1]) || (esc == end - 1)) {\n                    break;\n                }\n            }\n            return new String(chars, beg, end - beg);\n        }\n        private void consumeWhitespace() {\n            while ((cur < len) && isWhitespace(chars[cur])) {\n                ++cur;\n            }\n        }\n        /*\n         * Returns true if next unconsumed character is one that terminates\n         * a string attribute value.\n         */\n        private boolean atTerminator() {\n            return (cur < len &&\n                    (chars[cur] == ',' ||\n                     chars[cur] == ';' ||\n                     chars[cur] == '+'));\n        }\n    }\n    /*\n     * Class Rdn represents a set of TypeAndValue.\n     */\n    static class Rdn {\n        /*\n         * A vector of the TypeAndValue elements of this Rdn.\n         * It is sorted to facilitate set operations.\n         */\n        private final Vector<TypeAndValue> tvs = new Vector<>();\n        void add(TypeAndValue tv) {\n            // Set i to index of first element greater than tv, or to\n            // tvs.size() if there is none.\n            int i;\n            for (i = 0; i < tvs.size(); i++) {\n                int diff = tv.compareTo(tvs.elementAt(i));\n                if (diff == 0) {\n                    return;             // tv is a duplicate:  ignore it\n                } else if (diff < 0) {\n                    break;\n                }\n            }\n            tvs.insertElementAt(tv, i);\n        }\n        public String toString() {\n            StringBuffer buf = new StringBuffer();\n            for (int i = 0; i < tvs.size(); i++) {\n                if (i > 0) {\n                    buf.append('+');\n                }\n                buf.append(tvs.elementAt(i));\n            }\n            return new String(buf);\n        }\n        public boolean equals(Object obj) {\n            return ((obj instanceof Rdn) &&\n                    (compareTo(obj) == 0));\n        }\n        // Compare TypeAndValue components one by one, lexicographically.\n        public int compareTo(Object obj) {\n            Rdn that = (Rdn)obj;\n            int minSize = Math.min(tvs.size(), that.tvs.size());\n            for (int i = 0; i < minSize; i++) {\n                // Compare a single pair of type/value pairs.\n                TypeAndValue tv = tvs.elementAt(i);\n                int diff = tv.compareTo(that.tvs.elementAt(i));\n                if (diff != 0) {\n                    return diff;\n                }\n            }\n            return (tvs.size() - that.tvs.size());      // longer RDN wins\n        }\n<fim_suffix>        public int hashCode() {\n            // Sum up the hash codes of the components.\n            int hash = 0;\n            // For each type/value pair...\n            for (int i = 0; i < tvs.size(); i++) {\n                hash += tvs.elementAt(i).hashCode();\n            }\n            return hash;\n        }<fim_middle>// function below has no smell\n"}