{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.cloudstack.api.command.admin.storage;\nimport static com.cloud.user.Account.ACCOUNT_ID_SYSTEM;\nimport static org.apache.cloudstack.api.ApiConstants.S3_ACCESS_KEY;\nimport static org.apache.cloudstack.api.ApiConstants.S3_BUCKET_NAME;\nimport static org.apache.cloudstack.api.ApiConstants.S3_CONNECTION_TIMEOUT;\nimport static org.apache.cloudstack.api.ApiConstants.S3_CONNECTION_TTL;\nimport static org.apache.cloudstack.api.ApiConstants.S3_END_POINT;\nimport static org.apache.cloudstack.api.ApiConstants.S3_HTTPS_FLAG;\nimport static org.apache.cloudstack.api.ApiConstants.S3_MAX_ERROR_RETRY;\nimport static org.apache.cloudstack.api.ApiConstants.S3_SIGNER;\nimport static org.apache.cloudstack.api.ApiConstants.S3_SECRET_KEY;\nimport static org.apache.cloudstack.api.ApiConstants.S3_SOCKET_TIMEOUT;\nimport static org.apache.cloudstack.api.ApiConstants.S3_USE_TCP_KEEPALIVE;\nimport static org.apache.cloudstack.api.BaseCmd.CommandType.BOOLEAN;\nimport static org.apache.cloudstack.api.BaseCmd.CommandType.INTEGER;\nimport static org.apache.cloudstack.api.BaseCmd.CommandType.STRING;\nimport java.util.HashMap;\nimport java.util.Map;\nimport com.cloud.utils.storage.S3.ClientOptions;\nimport org.apache.log4j.Logger;\nimport org.apache.cloudstack.api.APICommand;\nimport org.apache.cloudstack.api.ApiConstants;\nimport org.apache.cloudstack.api.ApiErrorCode;\nimport org.apache.cloudstack.api.BaseCmd;\nimport org.apache.cloudstack.api.Parameter;\nimport org.apache.cloudstack.api.ServerApiException;\nimport org.apache.cloudstack.api.response.ImageStoreResponse;\nimport com.cloud.exception.ConcurrentOperationException;\nimport com.cloud.exception.DiscoveryException;\nimport com.cloud.exception.InsufficientCapacityException;\nimport com.cloud.exception.NetworkRuleConflictException;\nimport com.cloud.exception.ResourceAllocationException;\nimport com.cloud.exception.ResourceUnavailableException;\nimport com.cloud.storage.ImageStore;\n@APICommand(name = \"addImageStoreS3\", description = \"Adds S3 Image Store\", responseObject = ImageStoreResponse.class, since = \"4.7.0\",\n        requestHasSensitiveInfo = true, responseHasSensitiveInfo = false)\npublic final class AddImageStoreS3CMD extends BaseCmd implements ClientOptions {\n    public static final Logger s_logger = Logger.getLogger(AddImageStoreS3CMD.class.getName());\n    private static final String s_name = \"addImageStoreS3Response\";\n    @Parameter(name = S3_ACCESS_KEY, type = STRING, required = true, description = \"S3 access key\")\n    private String accessKey;\n    @Parameter(name = S3_SECRET_KEY, type = STRING, required = true, description = \"S3 secret key\")\n    private String secretKey;\n    @Parameter(name = S3_END_POINT, type = STRING, required = true, description = \"S3 endpoint\")\n    private String endPoint;\n    @Parameter(name = S3_BUCKET_NAME, type = STRING, required = true, description = \"Name of the storage bucket\")\n    private String bucketName;\n    @Parameter(name = S3_SIGNER, type = STRING, required = false, description = \"Signer Algorithm to use, either S3SignerType or AWSS3V4SignerType\")\n    private String signer;\n    @Parameter(name = S3_HTTPS_FLAG, type = BOOLEAN, required = false, description = \"Use HTTPS instead of HTTP\")\n    private Boolean httpsFlag;\n    @Parameter(name = S3_CONNECTION_TIMEOUT, type = INTEGER, required = false, description = \"Connection timeout (milliseconds)\")\n    private Integer connectionTimeout;\n    @Parameter(name = S3_MAX_ERROR_RETRY, type = INTEGER, required = false, description = \"Maximum number of times to retry on error\")\n    private Integer maxErrorRetry;\n    @Parameter(name = S3_SOCKET_TIMEOUT, type = INTEGER, required = false, description = \"Socket timeout (milliseconds)\")\n    private Integer socketTimeout;\n    @Parameter(name = S3_CONNECTION_TTL, type = INTEGER, required = false, description = \"Connection TTL (milliseconds)\")\n    private Integer connectionTtl;\n    @Parameter(name = S3_USE_TCP_KEEPALIVE, type = BOOLEAN, required = false, description = \"Whether TCP keep-alive is used\")\n    private Boolean useTCPKeepAlive;\n<fim_suffix>    @Override\n    public void execute() throws ResourceUnavailableException, InsufficientCapacityException, ServerApiException, ConcurrentOperationException,\n        ResourceAllocationException, NetworkRuleConflictException {\n        Map<String, String> dm = new HashMap();\n        dm.put(ApiConstants.S3_ACCESS_KEY, getAccessKey());\n        dm.put(ApiConstants.S3_SECRET_KEY, getSecretKey());\n        dm.put(ApiConstants.S3_END_POINT, getEndPoint());\n        dm.put(ApiConstants.S3_BUCKET_NAME, getBucketName());\n        if (getSigner() != null && (getSigner().equals(ApiConstants.S3_V3_SIGNER) || getSigner().equals(ApiConstants.S3_V4_SIGNER))) {\n            dm.put(ApiConstants.S3_SIGNER, getSigner());\n        }\n        if (isHttps() != null) {\n            dm.put(ApiConstants.S3_HTTPS_FLAG, isHttps().toString());\n        }\n        if (getConnectionTimeout() != null) {\n            dm.put(ApiConstants.S3_CONNECTION_TIMEOUT, getConnectionTimeout().toString());\n        }\n        if (getMaxErrorRetry() != null) {\n            dm.put(ApiConstants.S3_MAX_ERROR_RETRY, getMaxErrorRetry().toString());\n        }\n        if (getSocketTimeout() != null) {\n            dm.put(ApiConstants.S3_SOCKET_TIMEOUT, getSocketTimeout().toString());\n        }\n        if (getConnectionTtl() != null) {\n            dm.put(ApiConstants.S3_CONNECTION_TTL, getConnectionTtl().toString());\n        }\n        if (getUseTCPKeepAlive() != null) {\n            dm.put(ApiConstants.S3_USE_TCP_KEEPALIVE, getUseTCPKeepAlive().toString());\n        }\n        try{\n            ImageStore result = _storageService.discoverImageStore(null, null, \"S3\", null, dm);\n            ImageStoreResponse storeResponse;\n            if (result != null) {\n                storeResponse = _responseGenerator.createImageStoreResponse(result);\n                storeResponse.setResponseName(getCommandName());\n                storeResponse.setObjectName(\"imagestore\");\n                setResponseObject(storeResponse);\n            } else {\n                throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, \"Failed to add S3 Image Store.\");\n            }\n        } catch (DiscoveryException ex) {\n            s_logger.warn(\"Exception: \", ex);\n            throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, ex.getMessage());\n        }\n    }\n    @Override\n    public String getCommandName() {\n        return s_name;\n    }\n    @Override\n    public long getEntityOwnerId() {\n        return ACCOUNT_ID_SYSTEM;\n    }\n    public String getAccessKey() {\n        return accessKey;\n    }\n    public String getSecretKey() {\n        return secretKey;\n    }\n    public String getEndPoint() {\n        return endPoint;\n    }\n    public String getBucketName() {\n        return bucketName;\n    }\n    public String getSigner() {\n        return signer;\n    }\n    public Boolean isHttps() {\n        return httpsFlag;\n    }\n    public Integer getConnectionTimeout() {\n        return connectionTimeout;\n    }\n    public Integer getMaxErrorRetry() {\n        return maxErrorRetry;\n    }\n    public Integer getSocketTimeout() {\n        return socketTimeout;\n    }\n    public Integer getConnectionTtl() {\n        return connectionTtl;\n    }\n    public Boolean getUseTCPKeepAlive() {<fim_middle>// function below is long method\n"}