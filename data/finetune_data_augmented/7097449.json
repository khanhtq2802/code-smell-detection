{"text": "<fim_prefix> * No <code>rehash</code> operations will <i>ever</i> occur if the initial\n * capacity is greater than the maximum number of entries the\n * <tt>Hashtable</tt> will contain divided by its load factor.  However,\n * setting the initial capacity too high can waste space.<p>\n *\n * If many entries are to be made into a <code>Hashtable</code>,\n * creating it with a sufficiently large capacity may allow the\n * entries to be inserted more efficiently than letting it perform\n * automatic rehashing as needed to grow the table. <p>\n *\n * This example creates a hashtable of numbers. It uses the names of\n * the numbers as keys:\n * <pre>   {@code\n *   Hashtable<String, Integer> numbers\n *     = new Hashtable<String, Integer>();\n *   numbers.put(\"one\", 1);\n *   numbers.put(\"two\", 2);\n *   numbers.put(\"three\", 3);}</pre>\n *\n * <p>To retrieve a number, use the following code:\n * <pre>   {@code\n *   Integer n = numbers.get(\"two\");\n *   if (n != null) {\n *     System.out.println(\"two = \" + n);\n *   }}</pre>\n *\n * <p>The iterators returned by the <tt>iterator</tt> method of the collections\n * returned by all of this class's \"collection view methods\" are\n * <em>fail-fast</em>: if the Hashtable is structurally modified at any time\n * after the iterator is created, in any way except through the iterator's own\n * <tt>remove</tt> method, the iterator will throw a {@link\n * ConcurrentModificationException}.  Thus, in the face of concurrent\n * modification, the iterator fails quickly and cleanly, rather than risking\n * arbitrary, non-deterministic behavior at an undetermined time in the future.\n * The Enumerations returned by Hashtable's keys and elements methods are\n * <em>not</em> fail-fast.\n *\n * <p>Note that the fail-fast behavior of an iterator cannot be guaranteed\n * as it is, generally speaking, impossible to make any hard guarantees in the\n * presence of unsynchronized concurrent modification.  Fail-fast iterators\n * throw <tt>ConcurrentModificationException</tt> on a best-effort basis.\n * Therefore, it would be wrong to write a program that depended on this\n * exception for its correctness: <i>the fail-fast behavior of iterators\n * should be used only to detect bugs.</i>\n *\n * <p>As of the Java 2 platform v1.2, this class was retrofitted to\n * implement the {@link Map} interface, making it a member of the\n * <a href=\"{@docRoot}/../technotes/guides/collections/index.html\">\n *\n * Java Collections Framework</a>.  Unlike the new collection\n * implementations, {@code Hashtable} is synchronized.  If a\n * thread-safe implementation is not needed, it is recommended to use\n * {@link HashMap} in place of {@code Hashtable}.  If a thread-safe\n * highly-concurrent implementation is desired, then it is recommended\n * to use {@link java.util.concurrent.ConcurrentHashMap} in place of\n * {@code Hashtable}.\n *\n * @author  Arthur van Hoff\n * @author  Josh Bloch\n * @author  Neal Gafter\n * @see     Object#equals(java.lang.Object)\n * @see     Object#hashCode()\n * @see     Hashtable#rehash()\n * @see     Collection\n * @see     Map\n * @see     HashMap\n * @see     TreeMap\n * @since JDK1.0\n */\npublic class Hashtable<K,V>\n    extends Dictionary<K,V>\n    implements Map<K,V>, Cloneable, java.io.Serializable {\n    /**\n     * The hash table data.\n     */\n    private transient HashtableEntry<K,V>[] table;\n    /**\n     * The total number of entries in the hash table.\n     */\n    private transient int count;\n    /**\n     * The table is rehashed when its size exceeds this threshold.  (The\n     * value of this field is (int)(capacity * loadFactor).)\n     *\n     * @serial\n     */\n    private int threshold;\n    /**\n     * The load factor for the hashtable.\n     *\n     * @serial\n     */\n    private float loadFactor;\n    /**\n     * The number of times this Hashtable has been structurally modified\n     * Structural modifications are those that change the number of entries in\n     * the Hashtable or otherwise modify its internal structure (e.g.,\n     * rehash).  This field is used to make iterators on Collection-views of\n     * the Hashtable fail-fast.  (See ConcurrentModificationException).\n     */\n    private transient int modCount = 0;\n    /** use serialVersionUID from JDK 1.0.2 for interoperability */\n    private static final long serialVersionUID = 1421746759512286392L;\n    private static int hash(Object k) {\n        return k.hashCode();\n    }\n    /**\n     * Constructs a new, empty hashtable with the specified initial\n     * capacity and the specified load factor.\n     *\n     * @param      initialCapacity   the initial capacity of the hashtable.\n     * @param      loadFactor        the load factor of the hashtable.\n     * @exception  IllegalArgumentException  if the initial capacity is less\n     *             than zero, or if the load factor is nonpositive.\n     */\n    public Hashtable(int initialCapacity, float loadFactor) {\n        if (initialCapacity < 0)\n            throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                               initialCapacity);\n        if (loadFactor <= 0 || Float.isNaN(loadFactor))\n            throw new IllegalArgumentException(\"Illegal Load: \"+loadFactor);\n        if (initialCapacity==0)\n            initialCapacity = 1;\n        this.loadFactor = loadFactor;\n        table = new HashtableEntry[initialCapacity];\n        threshold = (initialCapacity <= MAX_ARRAY_SIZE + 1) ? initialCapacity : MAX_ARRAY_SIZE + 1;\n    }\n    /**\n     * Constructs a new, empty hashtable with the specified initial capacity\n     * and default load factor (0.75).\n     *\n     * @param     initialCapacity   the initial capacity of the hashtable.\n     * @exception IllegalArgumentException if the initial capacity is less\n     *              than zero.\n     */\n    public Hashtable(int initialCapacity) {\n        this(initialCapacity, 0.75f);\n    }\n    /**\n     * Constructs a new, empty hashtable with a default initial capacity (11)\n     * and load factor (0.75).\n     */\n    public Hashtable() {\n        this(11, 0.75f);\n    }\n    /**\n     * Constructs a new hashtable with the same mappings as the given\n     * Map.  The hashtable is created with an initial capacity sufficient to\n     * hold the mappings in the given Map and a default load factor (0.75).\n     *\n     * @param t the map whose mappings are to be placed in this map.\n     * @throws NullPointerException if the specified map is null.\n     * @since   1.2\n     */\n    public Hashtable(Map<? extends K, ? extends V> t) {\n        this(Math.max(2*t.size(), 11), 0.75f);\n        putAll(t);\n    }\n    /**\n     * Returns the number of keys in this hashtable.\n     *\n     * @return  the number of keys in this hashtable.\n     */\n    public synchronized int size() {\n        return count;\n    }\n    /**\n     * Tests if this hashtable maps no keys to values.\n     *\n     * @return  <code>true</code> if this hashtable maps no keys to values;\n     *          <code>false</code> otherwise.\n     */\n    public synchronized boolean isEmpty() {\n        return count == 0;\n    }\n    /**\n     * Returns an enumeration of the keys in this hashtable.\n     *\n     * @return  an enumeration of the keys in this hashtable.\n     * @see     Enumeration\n     * @see     #elements()\n     * @see     #keySet()\n     * @see     Map\n     */\n    public synchronized Enumeration<K> keys() {\n        return this.<K>getEnumeration(KEYS);\n    }\n    /**\n     * Returns an enumeration of the values in this hashtable.\n     * Use the Enumeration methods on the returned object to fetch the elements\n     * sequentially.\n     *\n     * @return  an enumeration of the values in this hashtable.\n     * @see     java.util.Enumeration\n     * @see     #keys()\n     * @see     #values()\n     * @see     Map\n     */\n<fim_suffix>    public synchronized Enumeration<V> elements() {\n        return this.<V>getEnumeration(VALUES);\n    }<fim_middle>// function below has no smell\n"}