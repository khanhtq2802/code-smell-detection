{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.cocoon.acting;\n\nimport java.util.Collections;\nimport java.util.Dictionary;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.Hashtable;\nimport java.util.Map;\nimport java.util.Vector;\n\nimport org.apache.avalon.framework.configuration.Configuration;\nimport org.apache.avalon.framework.configuration.ConfigurationException;\nimport org.apache.avalon.framework.parameters.Parameters;\nimport org.apache.avalon.framework.thread.ThreadSafe;\n\nimport org.apache.cocoon.environment.ObjectModelHelper;\nimport org.apache.cocoon.environment.Redirector;\nimport org.apache.cocoon.environment.Request;\nimport org.apache.cocoon.environment.SourceResolver;\n\n/**\n *  An action designed to set any number of variables, based on the current site\n *  section. The action matches the request uri against a configurable set of\n *  regular expressions (note: currently not implemented. Checking the beggining\n *  of the URI). When an expression matches, the action will set the configured\n *  variable in the Map.\n *\n * @version $Id$\n */\n<fim_suffix>public class SectionCutterAction extends ConfigurableServiceableAction implements ThreadSafe {\n\n    Vector sections = new Vector();\n\n    /**\n     *  Description of the Method\n     *\n     * @param  conf                        Description of Parameter\n     * @exception  ConfigurationException  Description of Exception\n     */\n    public void configure(Configuration conf)\n        throws ConfigurationException {\n        try {\n            Configuration[] sectionConfigurations;\n            sectionConfigurations = conf.getChildren(\"section\");\n\n            for (int i = 0; i < sectionConfigurations.length; i++) {\n                try {\n                    if (getLogger().isDebugEnabled()) {\n                        getLogger().debug(\"Creating one section\");\n                    }\n                    sections.add(new Section(sectionConfigurations[i]));\n                } catch (Exception e) {\n                    getLogger().error(\"Failed configuring section\", e);\n                    if (getLogger().isDebugEnabled()) {\n                        // In production, try to continue. Assume that one rotten section config can't stop the whole app.\n                        // When debug is enabled, scream, screech and grind to a halt.\n                        throw (e);\n                    }\n                }\n            }\n        } catch (Exception e) {\n            throw new ConfigurationException(\"Cannot configure action\", e);\n        }\n    }\n\n    /**\n     *  A simple Action that logs if the <code>Session</code> object has been\n     *  created\n     *\n     * @param  redirector     Description of Parameter\n     * @param  resolver       Description of Parameter\n     * @param  objectModel    Description of Parameter\n     * @param  src            Description of Parameter\n     * @param  par            Description of Parameter\n     * @return                Description of the Returned Value\n     * @exception  Exception  Description of Exception\n     */\n    public Map act(Redirector redirector, SourceResolver resolver, Map objectModel, String src, Parameters par)\n        throws Exception {\n        Request request = ObjectModelHelper.getRequest(objectModel);\n        Map results = new HashMap();\n        if (request != null) {\n            boolean hasMatched = false;\n\n            if (getLogger().isDebugEnabled()) {\n                getLogger().debug(\"Matching against '\" + request.getSitemapURI() + \"'\");\n            }\n            for (Enumeration sectionsEnum = sections.elements(); sectionsEnum.hasMoreElements() && !hasMatched; ) {\n                Section section = (Section) sectionsEnum.nextElement();\n                if (section.matches(request.getSitemapURI())) {\n                    if (getLogger().isDebugEnabled()) {\n                        getLogger().debug(\"Matched '\" + section.matchExpression + \"'\");\n                    }\n\n                    section.fillMap(results);\n                    hasMatched = true;\n                }\n            }\n        } else {\n            getLogger().warn(\"Request was null\");\n        }\n\n        return Collections.unmodifiableMap(results);\n    }\n\n    /**\n     *  Description of the Class\n     *\n     */\n    static class Section extends Object {\n        String matchExpression;\n        Dictionary mapVars = new Hashtable();\n\n        /**\n         *  Constructor for the Section object\n         *\n         * @param  conf           Description of Parameter\n         * @exception  Exception  Description of Exception\n         */\n        public Section(Configuration conf)\n            throws Exception {\n            matchExpression = conf.getAttribute(\"pattern\");\n            Configuration[] variables;\n            variables = conf.getChildren(\"set-var\");\n\n            for (int i = 0; i < variables.length; i++) {\n                mapVars.put(variables[i].getAttribute(\"name\"), variables[i].getAttribute(\"value\"));\n            }\n        }\n\n        /**\n         *  Description of the Method\n         *\n         * @param  expression  Description of Parameter\n         * @return             Description of the Returned Value\n         */\n        public boolean matches(String expression) {\n            return expression.startsWith(matchExpression);\n        }\n\n        /**\n         *  Description of the Method\n         *\n         * @param  map  Description of Parameter\n         */\n        public void fillMap(Map map) {\n            for (Enumeration keys = mapVars.keys(); keys.hasMoreElements(); ) {\n                Object key = keys.nextElement();\n                Object value = mapVars.get(key);\n\n                map.put(key, value);\n            }\n        }\n    }\n}\n\n\n\n\n\n\n<fim_middle>// class below has no smell\n"}