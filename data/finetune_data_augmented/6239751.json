{"text": "<fim_prefix>/*******************************************************************************\n * Copyright (c) 2013, 2015 Kiel University and others.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     Kiel University - initial API and implementation\n *******************************************************************************/\npackage org.eclipse.elk.alg.mrtree.p2order;\n\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\n\nimport org.eclipse.elk.alg.mrtree.TreeLayoutPhases;\nimport org.eclipse.elk.alg.mrtree.graph.TEdge;\nimport org.eclipse.elk.alg.mrtree.graph.TGraph;\nimport org.eclipse.elk.alg.mrtree.graph.TNode;\nimport org.eclipse.elk.alg.mrtree.intermediate.IntermediateProcessorStrategy;\nimport org.eclipse.elk.alg.mrtree.options.InternalProperties;\nimport org.eclipse.elk.core.alg.ILayoutPhase;\nimport org.eclipse.elk.core.alg.LayoutProcessorConfiguration;\nimport org.eclipse.elk.core.util.IElkProgressMonitor;\nimport org.eclipse.elk.graph.properties.PropertyHolderComparator;\n\n/**\n * This phase orders the nodes of each level by separating the nodes into leaves and inner nodes.\n * It then fills whitespaces in the levels with corresponding leaves.\n * \n * @author sor\n * @author sgu\n */\n<fim_suffix>public class NodeOrderer implements ILayoutPhase<TreeLayoutPhases, TGraph> {\n\n    /** intermediate processing configuration. */\n    private static final LayoutProcessorConfiguration<TreeLayoutPhases, TGraph> INTERMEDIATE_PROCESSING_CONFIG =\n            LayoutProcessorConfiguration.<TreeLayoutPhases, TGraph>create()\n                    .before(TreeLayoutPhases.P2_NODE_ORDERING)\n                        .add(IntermediateProcessorStrategy.ROOT_PROC)\n                        .add(IntermediateProcessorStrategy.FAN_PROC);\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public LayoutProcessorConfiguration<TreeLayoutPhases, TGraph> getLayoutProcessorConfiguration(final TGraph graph) {\n        return INTERMEDIATE_PROCESSING_CONFIG;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void process(final TGraph tGraph, final IElkProgressMonitor progressMonitor) {\n\n        progressMonitor.begin(\"Processor arrange node\", 1);\n\n        // find the root of the component\n        // expected only one root exists\n        TNode root = null;\n        LinkedList<TNode> roots = new LinkedList<TNode>();\n        Iterator<TNode> it = tGraph.getNodes().iterator();\n        while (root == null && it.hasNext()) {\n            TNode tNode = it.next();\n            if (tNode.getProperty(InternalProperties.ROOT)) {\n                root = tNode;\n            }\n        }\n        // order each level\n        roots.add(root);\n        orderLevel(roots, progressMonitor.subTask(1.0f));\n\n        progressMonitor.done();\n\n    }\n\n    /**\n     * Order each level by separating the nodes into leaves and inner nodes. And then fill gaps with\n     * corresponding leaves.\n     * \n     * @param currentLevel\n     * @param progressMonitor\n     */\n    private void orderLevel(final LinkedList<TNode> currentLevel,\n            final IElkProgressMonitor progressMonitor) {\n\n        progressMonitor.begin(\"Processor arrange level\", 1);\n\n        int pos = 0;\n\n        // sort all nodes in this level by their fan out\n        // so the leaves are at the end of the list\n        Collections.sort(currentLevel, PropertyHolderComparator.with(InternalProperties.FAN));\n\n        // find the first occurence of a leave in the list\n        int firstOcc = currentLevel.size();\n        ListIterator<TNode> it = currentLevel.listIterator(currentLevel.size());\n        boolean notNull = true;\n        while (notNull && it.hasPrevious()) {\n            TNode tNode = (TNode) it.previous();\n            if ((tNode.getProperty(InternalProperties.FAN) == 0)) {\n                firstOcc--;\n            } else {\n                notNull = false;\n            }\n        }\n\n        // seperate the level into leaves and inner nodes\n        List<TNode> tmp = currentLevel.subList(0, firstOcc);\n        LinkedList<TNode> inners = new LinkedList<TNode>(tmp);\n        tmp = currentLevel.subList(firstOcc, currentLevel.size());\n        LinkedList<TNode> leaves = new LinkedList<TNode>(tmp);\n\n        // check if their are inner nodes left\n        if (inners.isEmpty()) {\n            // leave the leaves in their order\n            for (TNode tENode : leaves) {\n                tENode.setProperty(InternalProperties.POSITION, pos++);\n            }\n        } else {\n\n            // order each level of descendants of the inner nodes\n            int size = inners.size();\n            for (TNode tPNode : inners) {\n                tPNode.setProperty(InternalProperties.POSITION, pos++);\n\n                // set the position of the children and set them in order\n                LinkedList<TNode> children = tPNode.getChildrenCopy();\n                orderLevel(children, progressMonitor.subTask(1 / size));\n\n                // order the children by their reverse position\n                Collections.sort(children,\n                        Collections.reverseOrder(PropertyHolderComparator.with(InternalProperties.POSITION)));\n\n                // reset the list of children with the new order\n                List<TEdge> sortedOutEdges = new LinkedList<TEdge>();\n\n                for (TNode tNode : children) {\n                    for (TEdge tEdge : tPNode.getOutgoingEdges()) {\n                        if (tEdge.getTarget() == tNode) {\n                            sortedOutEdges.add(tEdge);\n                        }\n                    }\n                }\n                tPNode.getOutgoingEdges().clear();\n                tPNode.getOutgoingEdges().addAll(sortedOutEdges);\n\n                // fill gaps with leafs\n                it = leaves.listIterator(leaves.size());\n                int fillGap = tPNode.getOutgoingEdges().size();\n                notNull = true;\n                while ((0 < fillGap) && notNull && it.hasPrevious()) {\n                    TNode tNode = (TNode) it.previous();\n                    if ((tNode.getProperty(InternalProperties.FAN) == 0)) {\n                        tNode.setProperty(InternalProperties.POSITION, pos++);\n                        fillGap--;\n                        it.remove();\n                    } else {\n                        notNull = false;\n                    }\n                }\n            }\n        }\n        progressMonitor.done();\n    }\n}<fim_middle>// class below is blob\n"}