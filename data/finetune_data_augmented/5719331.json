{"text": "<fim_prefix>                if (\".;[/<>\".indexOf(name.charAt(i)) != -1) {\n                    throw new IllegalArgumentException(\"Invalid \" + msg\n                            + \" (must be a valid unqualified name): \" + name);\n                }\n            }\n            return;\n        }\n        if (!Character.isJavaIdentifierStart(name.charAt(0))) {\n            throw new IllegalArgumentException(\n                    \"Invalid \"\n                            + msg\n                            + \" (must be a '<init>', '<clinit>' or a valid Java identifier): \"\n                            + name);\n        }\n        for (int i = 1; i < name.length(); ++i) {\n            if (!Character.isJavaIdentifierPart(name.charAt(i))) {\n                throw new IllegalArgumentException(\n                        \"Invalid \"\n                                + msg\n                                + \" (must be '<init>' or '<clinit>' or a valid Java identifier): \"\n                                + name);\n            }\n        }\n    }\n    /**\n     * Checks that the given string is a valid internal class name.\n     * \n     * @param name\n     *            the string to be checked.\n     * @param msg\n     *            a message to be used in case of error.\n     */\n    static void checkInternalName(final String name, final String msg) {\n        if (name == null || name.length() == 0) {\n            throw new IllegalArgumentException(\"Invalid \" + msg\n                    + \" (must not be null or empty)\");\n        }\n        if (name.charAt(0) == '[') {\n            checkDesc(name, false);\n        } else {\n            checkInternalName(name, 0, -1, msg);\n        }\n    }\n    /**\n     * Checks that the given substring is a valid internal class name.\n     * \n     * @param name\n     *            the string to be checked.\n     * @param start\n     *            index of the first character of the identifier (inclusive).\n     * @param end\n     *            index of the last character of the identifier (exclusive). -1\n     *            is equivalent to <tt>name.length()</tt> if name is not\n     *            <tt>null</tt>.\n     * @param msg\n     *            a message to be used in case of error.\n     */\n    static void checkInternalName(final String name, final int start,\n            final int end, final String msg) {\n        int max = end == -1 ? name.length() : end;\n        try {\n            int begin = start;\n            int slash;\n            do {\n                slash = name.indexOf('/', begin + 1);\n                if (slash == -1 || slash > max) {\n                    slash = max;\n                }\n                checkIdentifier(name, begin, slash, null);\n                begin = slash + 1;\n            } while (slash != max);\n        } catch (IllegalArgumentException _) {\n            throw new IllegalArgumentException(\n                    \"Invalid \"\n                            + msg\n                            + \" (must be a fully qualified class name in internal form): \"\n                            + name);\n        }\n    }\n    /**\n     * Checks that the given string is a valid type descriptor.\n     * \n     * @param desc\n     *            the string to be checked.\n     * @param canBeVoid\n     *            <tt>true</tt> if <tt>V</tt> can be considered valid.\n     */\n    static void checkDesc(final String desc, final boolean canBeVoid) {\n        int end = checkDesc(desc, 0, canBeVoid);\n        if (end != desc.length()) {\n            throw new IllegalArgumentException(\"Invalid descriptor: \" + desc);\n        }\n    }\n    /**\n     * Checks that a the given substring is a valid type descriptor.\n     * \n     * @param desc\n     *            the string to be checked.\n     * @param start\n     *            index of the first character of the identifier (inclusive).\n     * @param canBeVoid\n     *            <tt>true</tt> if <tt>V</tt> can be considered valid.\n     * @return the index of the last character of the type decriptor, plus one.\n     */\n    static int checkDesc(final String desc, final int start,\n            final boolean canBeVoid) {\n        if (desc == null || start >= desc.length()) {\n            throw new IllegalArgumentException(\n                    \"Invalid type descriptor (must not be null or empty)\");\n        }\n        int index;\n        switch (desc.charAt(start)) {\n        case 'V':\n            if (canBeVoid) {\n                return start + 1;\n            } else {\n                throw new IllegalArgumentException(\"Invalid descriptor: \"\n                        + desc);\n            }\n        case 'Z':\n        case 'C':\n        case 'B':\n        case 'S':\n        case 'I':\n        case 'F':\n        case 'J':\n        case 'D':\n            return start + 1;\n        case '[':\n            index = start + 1;\n            while (index < desc.length() && desc.charAt(index) == '[') {\n                ++index;\n            }\n            if (index < desc.length()) {\n                return checkDesc(desc, index, false);\n            } else {\n                throw new IllegalArgumentException(\"Invalid descriptor: \"\n                        + desc);\n            }\n        case 'L':\n            index = desc.indexOf(';', start);\n            if (index == -1 || index - start < 2) {\n                throw new IllegalArgumentException(\"Invalid descriptor: \"\n                        + desc);\n            }\n            try {\n                checkInternalName(desc, start + 1, index, null);\n            } catch (IllegalArgumentException _) {\n                throw new IllegalArgumentException(\"Invalid descriptor: \"\n                        + desc);\n            }\n            return index + 1;\n        default:\n            throw new IllegalArgumentException(\"Invalid descriptor: \" + desc);\n        }\n    }\n    /**\n     * Checks that the given string is a valid method descriptor.\n     * \n     * @param desc\n     *            the string to be checked.\n     */\n    static void checkMethodDesc(final String desc) {\n        if (desc == null || desc.length() == 0) {\n            throw new IllegalArgumentException(\n                    \"Invalid method descriptor (must not be null or empty)\");\n        }\n        if (desc.charAt(0) != '(' || desc.length() < 3) {\n            throw new IllegalArgumentException(\"Invalid descriptor: \" + desc);\n        }\n        int start = 1;\n        if (desc.charAt(start) != ')') {\n            do {\n                if (desc.charAt(start) == 'V') {\n                    throw new IllegalArgumentException(\"Invalid descriptor: \"\n                            + desc);\n                }\n                start = checkDesc(desc, start, false);\n            } while (start < desc.length() && desc.charAt(start) != ')');\n        }\n        start = checkDesc(desc, start + 1, true);\n        if (start != desc.length()) {\n            throw new IllegalArgumentException(\"Invalid descriptor: \" + desc);\n        }\n    }\n    /**\n     * Checks that the given label is not null. This method can also check that\n     * the label has been visited.\n     * \n     * @param label\n     *            the label to be checked.\n     * @param checkVisited\n     *            <tt>true</tt> to check that the label has been visited.\n     * @param msg\n     *            a message to be used in case of error.\n     */\n    void checkLabel(final Label label, final boolean checkVisited,\n            final String msg) {\n        if (label == null) {\n            throw new IllegalArgumentException(\"Invalid \" + msg\n                    + \" (must not be null)\");\n        }\n        if (checkVisited && labels.get(label) == null) {\n            throw new IllegalArgumentException(\"Invalid \" + msg\n                    + \" (must be visited first)\");\n        }\n    }\n    /**\n     * Checks that the given label is not a label used only for debug purposes.\n     * \n     * @param label\n     *            the label to be checked.\n     */\n    private static void checkNonDebugLabel(final Label label) {\n        Field f = getLabelStatusField();\n        int status = 0;\n        try {\n            status = f == null ? 0 : ((Integer) f.get(label)).intValue();\n        } catch (IllegalAccessException e) {\n            throw new Error(\"Internal error\");\n        }\n        if ((status & 0x01) != 0) {\n            throw new IllegalArgumentException(\n                    \"Labels used for debug info cannot be reused for control flow\");\n        }\n    }\n    /**\n     * Returns the Field object corresponding to the Label.status field.\n     * \n     * @return the Field object corresponding to the Label.status field.\n     */\n    private static Field getLabelStatusField() {\n        if (labelStatusField == null) {\n            labelStatusField = getLabelField(\"a\");\n            if (labelStatusField == null) {\n                labelStatusField = getLabelField(\"status\");\n            }\n        }\n        return labelStatusField;\n    }\n    /**\n     * Returns the field of the Label class whose name is given.\n     * \n     * @param name\n     *            a field name.\n     * @return the field of the Label class whose name is given, or null.\n     */\n<fim_suffix>    private static Field getLabelField(final String name) {\n        try {\n            Field f = Label.class.getDeclaredField(name);\n            f.setAccessible(true);\n            return f;\n        } catch (NoSuchFieldException e) {\n            return null;\n        }\n    }<fim_middle>// function below has no smell\n"}