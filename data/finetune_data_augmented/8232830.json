{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.cocoon.generation;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Map;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.avalon.framework.parameters.Parameters;\nimport org.apache.avalon.framework.service.ServiceException;\nimport org.apache.avalon.framework.service.ServiceManager;\nimport org.apache.cocoon.ProcessingException;\nimport org.apache.cocoon.xml.XMLUtils;\nimport org.apache.cocoon.environment.SourceResolver;\nimport org.apache.cocoon.environment.http.HttpEnvironment;\nimport org.apache.cocoon.util.RequestForwardingHttpMethod;\nimport org.apache.commons.httpclient.Header;\nimport org.apache.commons.httpclient.HttpConnection;\nimport org.apache.commons.httpclient.HttpState;\nimport org.apache.commons.httpclient.HttpURL;\nimport org.apache.commons.httpclient.UsernamePasswordCredentials;\nimport org.apache.commons.httpclient.auth.AuthScope;\nimport org.apache.excalibur.xml.sax.SAXParser;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\n\n/**\n * This is a generic HTTP proxy, designed to handle any possible HTTP method,\n * but with a particular bias towards WebDAV. As of now it's pretty unstable, but\n * still it might be a good proof of concept towards a pure HTTP(++) proxy.\n *\n * <br>TODO: doesn't handle authentication properly\n * <br>TODO: doesn't handle (and doubt it'll ever will) HTTP/1.1 keep-alive\n *\n * @version $Id$\n */\n<fim_suffix>public class GenericProxyGenerator extends ServiceableGenerator {\n\n    /** The real URL to forward requests to */\n    HttpURL destination;\n    /** The current request */\n    HttpServletRequest request;\n    /** The current response */\n    HttpServletResponse  response;\n    /** The current request */\n    String path;\n    SAXParser parser;\n\n    /**\n     * Compose and get a SAX parser for further use.\n     *\n     * @see org.apache.avalon.framework.service.Serviceable#service(org.apache.avalon.framework.service.ServiceManager)\n     */\n    public void service(ServiceManager manager) throws ServiceException {\n        super.service(manager);\n        this.parser = (SAXParser)manager.lookup(SAXParser.ROLE);\n    }\n\n    /**\n     * Dispose\n     */\n    public void dispose() {\n        if ( this.manager != null ) {\n            this.manager.release( this.parser );\n            this.parser = null;\n        }\n        super.dispose();\n    }\n\n    /**\n     * Setup this component by getting the (required) \"url\" parameter and the\n     * (optional) \"path\" parameter.  If path is not specified, the request URI will\n     * be used and forwarded.\n     *\n     * TODO: handle query string\n     *\n     * @see org.apache.cocoon.sitemap.SitemapModelComponent#setup(org.apache.cocoon.environment.SourceResolver, java.util.Map, java.lang.String, org.apache.avalon.framework.parameters.Parameters)\n     */\n    public void setup(\n        SourceResolver resolver,\n        Map objectModel,\n        String src,\n        Parameters par)\n        throws ProcessingException, SAXException, IOException {\n            String url = par.getParameter(\"url\", null);\n            request = (HttpServletRequest)objectModel.get(HttpEnvironment.HTTP_REQUEST_OBJECT);\n            response = (HttpServletResponse)objectModel.get(HttpEnvironment.HTTP_RESPONSE_OBJECT);\n\n            if (url == null) {\n                throw new ProcessingException(\"Missing the \\\"url\\\" parameter\");\n            }\n            path =  par.getParameter(\"path\", null);\n            if (path == null)\n                path =  request.getRequestURI();\n            destination = new HttpURL(url);\n\n      }\n\n\n    /**\n     * Get the request data, pass them on to the forwarder and return the result.\n     *\n     * TODO: much better header handling\n     * TODO: handle non XML and bodyless responses (probably needs a smarter Serializer,\n     *            since some XML has to go through the pipeline anyway.\n     *\n     * @see org.apache.cocoon.generation.Generator#generate()\n     */\n    public void generate()\n        throws IOException, SAXException, ProcessingException {\n            RequestForwardingHttpMethod method =\n                new RequestForwardingHttpMethod(request, destination);\n\n            // Build the forwarded connection\n            HttpConnection conn = new HttpConnection(destination.getHost(), destination.getPort());\n            HttpState state = new HttpState();\n            AuthScope as = new AuthScope(destination.getHost(), destination.getPort());\n            state.setCredentials(as,\n                new UsernamePasswordCredentials(destination.getUser(), destination.getPassword()));\n            method.setPath(path);\n\n            // Execute the method\n            method.execute(state, conn);\n\n            // Send the output to the client: set the status code...\n            response.setStatus(method.getStatusCode());\n\n            // ... retrieve the headers from the origin server and pass them on\n            Header[] methodHeaders = method.getResponseHeaders();\n            for (int i = 0; i < methodHeaders.length; i++) {\n                // there is more than one DAV header\n                if (methodHeaders[i].getName().equals(\"DAV\")) {\n                    response.addHeader(methodHeaders[i].getName(), methodHeaders[i].getValue());\n                } else if (methodHeaders[i].getName().equals(\"Content-Length\")) {\n                    // drop the original Content-Length header. Don't ask me why but there\n                    // it's always one byte off\n                } else {\n                    response.setHeader(methodHeaders[i].getName(), methodHeaders[i].getValue());\n                }\n            }\n\n            // no HTTP keepalives here...\n            response.setHeader(\"Connection\", \"close\");\n\n            // Parse the XML, if any\n            if (method.getResponseHeader(\"Content-Type\").getValue().startsWith(\"text/xml\")) {\n                InputStream stream = method.getResponseBodyAsStream();\n                parser.parse(new InputSource(stream), this.contentHandler, this.lexicalHandler);\n            } else {\n                // Just send a dummy XML\n                this.contentHandler.startDocument();\n                this.contentHandler.startElement(\"\", \"no-xml-content\", \"no-xml-content\", XMLUtils.EMPTY_ATTRIBUTES);\n                this.contentHandler.endElement(\"\", \"no-xml-content\", \"no-xml-content\");\n                this.contentHandler.endDocument();\n            }\n\n            // again, no keepalive here.\n            conn.close();\n    }\n\n}<fim_middle>// class below has no smell\n"}