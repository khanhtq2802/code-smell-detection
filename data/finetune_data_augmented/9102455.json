{"text": "<fim_prefix>import com.oracle.truffle.r.nodes.builtin.RBuiltinNode;\nimport com.oracle.truffle.r.nodes.builtin.base.EnvFunctions;\nimport com.oracle.truffle.r.nodes.builtin.base.EnvFunctionsFactory.TopEnvNodeGen;\nimport com.oracle.truffle.r.nodes.builtin.base.FrameFunctions;\nimport com.oracle.truffle.r.nodes.builtin.base.FrameFunctionsFactory.ParentFrameNodeGen;\nimport com.oracle.truffle.r.nodes.builtin.base.GetFunctions;\nimport com.oracle.truffle.r.nodes.builtin.base.GetFunctionsFactory.GetNodeGen;\nimport com.oracle.truffle.r.nodes.builtin.base.TraceFunctions;\nimport com.oracle.truffle.r.nodes.builtin.base.TraceFunctionsFactory.PrimTraceNodeGen;\nimport com.oracle.truffle.r.nodes.builtin.base.TraceFunctionsFactory.PrimUnTraceNodeGen;\nimport com.oracle.truffle.r.nodes.builtin.helpers.TraceHandling;\nimport com.oracle.truffle.r.nodes.function.visibility.SetVisibilityNode;\nimport com.oracle.truffle.r.nodes.unary.CastLogicalNode;\nimport com.oracle.truffle.r.nodes.unary.CastLogicalNodeGen;\nimport com.oracle.truffle.r.runtime.ArgumentsSignature;\nimport com.oracle.truffle.r.runtime.RError;\nimport com.oracle.truffle.r.runtime.RRuntime;\nimport com.oracle.truffle.r.runtime.RType;\nimport com.oracle.truffle.r.runtime.Utils;\nimport com.oracle.truffle.r.runtime.builtins.RBuiltin;\nimport com.oracle.truffle.r.runtime.data.Closure;\nimport com.oracle.truffle.r.runtime.data.RDataFactory;\nimport com.oracle.truffle.r.runtime.data.RFunction;\nimport com.oracle.truffle.r.runtime.data.RPairList;\nimport com.oracle.truffle.r.runtime.data.RMissing;\nimport com.oracle.truffle.r.runtime.data.RNull;\nimport com.oracle.truffle.r.runtime.nodes.RBaseNode;\n/**\n * This a FastR-specific version of the standard {@code trace} function which uses the\n * instrumentation framework to implement the trace semantics instead of the standard (GnuR)\n * approach of creating a modified function.\n *\n * The only required argument is the function, either as a closure value or a string.\n */\n<fim_suffix>public class FastRTrace {\n    static final class Helper extends RBaseNode {\n        @Child private GetFunctions.Get getNode;\n        @Child private EnvFunctions.TopEnv topEnv;\n        @Child private FrameFunctions.ParentFrame parentFrame;\n        protected Object getWhere(VirtualFrame frame) {\n            if (topEnv == null) {\n                CompilerDirectives.transferToInterpreterAndInvalidate();\n                topEnv = insert(TopEnvNodeGen.create());\n            }\n            if (parentFrame == null) {\n                CompilerDirectives.transferToInterpreterAndInvalidate();\n                parentFrame = insert(ParentFrameNodeGen.create());\n            }\n            return topEnv.execute(frame, parentFrame.execute(frame, 1), RNull.instance);\n        }\n        protected Object getFunction(VirtualFrame frame, Object what, Object where) {\n            if (getNode == null) {\n                CompilerDirectives.transferToInterpreterAndInvalidate();\n                getNode = insert(GetNodeGen.create());\n            }\n            return getNode.execute(frame, what, where, RType.Function.getName(), true);\n        }\n        protected void checkWhat(Object what) {\n            if (what == RMissing.instance) {\n                throw error(RError.Message.ARGUMENT_MISSING, \"what\");\n            }\n        }\n        protected RFunction checkFunction(Object what) {\n            if (what instanceof RFunction) {\n                RFunction func = (RFunction) what;\n                if (func.isBuiltin()) {\n                    throw error(RError.Message.GENERIC, \"builtin functions cannot be traced\");\n                } else {\n                    return func;\n                }\n            } else {\n                throw error(RError.Message.ARG_MUST_BE_CLOSURE);\n            }\n        }\n    }\n    @RBuiltin(name = \".fastr.trace\", visibility = CUSTOM, kind = PRIMITIVE, parameterNames = {\"what\", \"tracer\", \"exit\", \"at\", \"print\", \"signature\", \"where\"}, behavior = COMPLEX)\n    public abstract static class Trace extends RBuiltinNode.Arg7 {\n        @Child private TraceFunctions.PrimTrace primTrace;\n        @Child private CastLogicalNode castLogical;\n        @Child private SetVisibilityNode visibility = SetVisibilityNode.create();\n        @Child private Helper helper = new Helper();\n        static {\n            Casts.noCasts(Trace.class);\n        }\n        @Specialization\n        protected Object trace(VirtualFrame frame, Object whatObj, Object tracer, Object exit, Object at, Object printObj, Object signature, Object whereObj) {\n            Object what = whatObj;\n            helper.checkWhat(what);\n            Object where = whereObj;\n            if (where == RMissing.instance) {\n                where = helper.getWhere(frame);\n            }\n            String funcName = RRuntime.asString(what);\n            if (funcName != null) {\n                what = helper.getFunction(frame, what, where);\n            }\n            RFunction func = helper.checkFunction(what);\n            if (tracer == RMissing.instance && exit == RMissing.instance && at == RMissing.instance && printObj == RMissing.instance && signature == RMissing.instance) {\n                // simple case, nargs() == 1, corresponds to .primTrace that has invisible output\n                if (primTrace == null) {\n                    CompilerDirectives.transferToInterpreterAndInvalidate();\n                    primTrace = insert(PrimTraceNodeGen.create());\n                }\n                Object result = primTrace.execute(frame, func);\n                visibility.execute(frame, false);\n                return result;\n            }\n            if (at != RMissing.instance) {\n                throw RError.nyi(this, \"'at'\");\n            }\n            boolean print = true;\n            if (printObj != RMissing.instance) {\n                if (castLogical == null) {\n                    CompilerDirectives.transferToInterpreterAndInvalidate();\n                    castLogical = insert(CastLogicalNodeGen.create(false, false, false));\n                }\n                print = RRuntime.fromLogical((byte) castLogical.doCast(printObj));\n            }\n            complexCase(func, tracer, exit, at, print, signature);\n            visibility.execute(frame, true);\n            return Utils.toString(func);\n        }\n        @TruffleBoundary\n        private void complexCase(RFunction func, Object tracerObj, @SuppressWarnings(\"unused\") Object exit, Object at, boolean print, @SuppressWarnings(\"unused\") Object signature) {\n            // the complex case\n            RPairList tracer;\n            if (tracerObj instanceof RFunction) {\n                Closure closure = Closure.createLanguageClosure(RASTUtils.createCall(tracerObj, false, ArgumentsSignature.empty(0)).asRNode());\n                tracer = RDataFactory.createLanguage(closure);\n            } else if ((tracerObj instanceof RPairList && ((RPairList) tracerObj).isLanguage())) {\n                tracer = (RPairList) tracerObj;\n            } else {\n                throw error(RError.Message.GENERIC, \"tracer is unexpected type\");\n            }\n            TraceHandling.enableStatementTrace(func, tracer, at, print);\n        }\n    }\n    @RBuiltin(name = \".fastr.untrace\", visibility = OFF, kind = PRIMITIVE, parameterNames = {\"what\", \"signature\", \"where\"}, behavior = COMPLEX)\n    public abstract static class Untrace extends RBuiltinNode.Arg3 {\n        @Child private TraceFunctions.PrimUnTrace primUnTrace;\n        @Child private Helper helper = new Helper();\n        static {\n            Casts.noCasts(Untrace.class);\n        }\n        @Specialization\n        protected Object untrace(VirtualFrame frame, Object whatObj, Object signature, Object whereObj) {\n            Object what = whatObj;\n            helper.checkWhat(what);\n            Object where = whereObj;\n            if (where == RMissing.instance) {\n                where = helper.getWhere(frame);\n            }\n            String funcName = RRuntime.asString(what);\n            if (funcName != null) {\n                what = helper.getFunction(frame, what, where);\n            }\n            RFunction func = helper.checkFunction(what);\n            if (signature == RMissing.instance) {\n                if (primUnTrace == null) {\n                    CompilerDirectives.transferToInterpreterAndInvalidate();\n                    primUnTrace = insert(PrimUnTraceNodeGen.create());\n                }\n                primUnTrace.execute(frame, func);\n            } else {\n                throw RError.nyi(this, \"method tracing\");\n            }\n            return Utils.toString(func);\n        }\n    }\n}<fim_middle>// class below has no smell\n"}