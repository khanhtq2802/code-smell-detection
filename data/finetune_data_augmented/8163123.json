{"text": "<fim_prefix>                    msg.getMessageId().setBrokerSequenceId(sequenceId);\n                    return listener.recoverMessage(msg);\n                }\n                @Override\n                public boolean recoverMessageReference(String reference) throws Exception {\n                    return listener.recoverMessageReference(new MessageId(reference));\n                }\n            });\n        } catch (SQLException e) {\n            JDBCPersistenceAdapter.log(\"JDBC Failure: \", e);\n            throw IOExceptionSupport.create(\"Failed to recover subscription: \" + clientId + \". Reason: \" + e, e);\n        } finally {\n            c.close();\n        }\n    }\n    private class LastRecovered implements Iterable<LastRecoveredEntry> {\n        LastRecoveredEntry[] perPriority = new LastRecoveredEntry[10];\n        LastRecovered() {\n            for (int i=0; i<perPriority.length; i++) {\n                perPriority[i] = new LastRecoveredEntry(i);\n            }\n        }\n        public void updateStored(long sequence, int priority) {\n            perPriority[priority].stored = sequence;\n        }\n        public LastRecoveredEntry defaultPriority() {\n            return perPriority[0];\n        }\n        @Override\n        public String toString() {\n            return Arrays.deepToString(perPriority);\n        }\n        @Override\n        public Iterator<LastRecoveredEntry> iterator() {\n            return new PriorityIterator();\n        }\n        class PriorityIterator implements Iterator<LastRecoveredEntry> {\n            int current = 9;\n            @Override\n            public boolean hasNext() {\n                for (int i=current; i>=0; i--) {\n                    if (perPriority[i].hasMessages()) {\n                        current = i;\n                        return true;\n                    }\n                }\n                return false;\n            }\n            @Override\n            public LastRecoveredEntry next() {\n                return perPriority[current];\n            }\n            @Override\n            public void remove() {\n                throw new RuntimeException(\"not implemented\");\n            }\n        }\n    }\n    private class LastRecoveredEntry {\n        final int priority;\n        long recovered = 0;\n        long stored = Integer.MAX_VALUE;\n        public LastRecoveredEntry(int priority) {\n            this.priority = priority;\n        }\n        @Override\n        public String toString() {\n            return priority + \"-\" + stored + \":\" + recovered;\n        }\n        public void exhausted() {\n            stored = recovered;\n        }\n        public boolean hasMessages() {\n            return stored > recovered;\n        }\n    }\n    class LastRecoveredAwareListener implements JDBCMessageRecoveryListener {\n        final MessageRecoveryListener delegate;\n        final int maxMessages;\n        LastRecoveredEntry lastRecovered;\n        int recoveredCount;\n        int recoveredMarker;\n        public LastRecoveredAwareListener(MessageRecoveryListener delegate, int maxMessages) {\n            this.delegate = delegate;\n            this.maxMessages = maxMessages;\n        }\n        @Override\n        public boolean recoverMessage(long sequenceId, byte[] data) throws Exception {\n            if (delegate.hasSpace() && recoveredCount < maxMessages) {\n                Message msg = (Message) wireFormat.unmarshal(new ByteSequence(data));\n                msg.getMessageId().setBrokerSequenceId(sequenceId);\n                lastRecovered.recovered = sequenceId;\n                if (delegate.recoverMessage(msg)) {\n                    recoveredCount++;\n                    return true;\n                }\n            }\n            return false;\n        }\n        @Override\n        public boolean recoverMessageReference(String reference) throws Exception {\n            return delegate.recoverMessageReference(new MessageId(reference));\n        }\n        public void setLastRecovered(LastRecoveredEntry lastRecovered) {\n            this.lastRecovered = lastRecovered;\n            recoveredMarker = recoveredCount;\n        }\n        public boolean complete() {\n            return  !delegate.hasSpace() || recoveredCount == maxMessages;\n        }\n        public boolean stalled() {\n            return recoveredMarker == recoveredCount;\n        }\n    }\n    @Override\n    public synchronized void recoverNextMessages(final String clientId, final String subscriptionName, final int maxReturned, final MessageRecoveryListener listener)\n            throws Exception {\n        //Duration duration = new Duration(\"recoverNextMessages\");\n        TransactionContext c = persistenceAdapter.getTransactionContext();\n        String key = getSubscriptionKey(clientId, subscriptionName);\n        if (!subscriberLastRecoveredMap.containsKey(key)) {\n           subscriberLastRecoveredMap.put(key, new LastRecovered());\n        }\n        final LastRecovered lastRecovered = subscriberLastRecoveredMap.get(key);\n        LastRecoveredAwareListener recoveredAwareListener = new LastRecoveredAwareListener(listener, maxReturned);\n        try {\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(this + \", \" + key + \" existing last recovered: \" + lastRecovered);\n            }\n            if (isPrioritizedMessages()) {\n                Iterator<LastRecoveredEntry> it = lastRecovered.iterator();\n                for ( ; it.hasNext() && !recoveredAwareListener.complete(); ) {\n                    LastRecoveredEntry entry = it.next();\n                    recoveredAwareListener.setLastRecovered(entry);\n                    //Duration microDuration = new Duration(\"recoverNextMessages:loop\");\n                    adapter.doRecoverNextMessagesWithPriority(c, destination, clientId, subscriptionName,\n                        entry.recovered, entry.priority, maxReturned, recoveredAwareListener);\n                    //microDuration.end(new String(entry + \" recoveredCount:\" + recoveredAwareListener.recoveredCount));\n                    if (recoveredAwareListener.stalled()) {\n                        if (recoveredAwareListener.complete()) {\n                            break;\n                        } else {\n                            entry.exhausted();\n                        }\n                    }\n                }\n            } else {\n                LastRecoveredEntry last = lastRecovered.defaultPriority();\n                recoveredAwareListener.setLastRecovered(last);\n                adapter.doRecoverNextMessages(c, destination, clientId, subscriptionName,\n                        last.recovered, 0, maxReturned, recoveredAwareListener);\n            }\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(key + \" last recovered: \" + lastRecovered);\n            }\n            //duration.end();\n        } catch (SQLException e) {\n            JDBCPersistenceAdapter.log(\"JDBC Failure: \", e);\n        } finally {\n            c.close();\n        }\n    }\n    @Override\n    public void resetBatching(String clientId, String subscriptionName) {\n        String key = getSubscriptionKey(clientId, subscriptionName);\n        if (!pendingCompletion.contains(key))  {\n            subscriberLastRecoveredMap.remove(key);\n        } else {\n            LOG.trace(this +  \", skip resetBatch during pending completion for: \" + key);\n        }\n    }\n    public void pendingCompletion(String clientId, String subscriptionName, long sequenceId, byte priority) {\n        final String key = getSubscriptionKey(clientId, subscriptionName);\n        LastRecovered recovered = new LastRecovered();\n        recovered.perPriority[priority].recovered = sequenceId;\n        subscriberLastRecoveredMap.put(key, recovered);\n        pendingCompletion.add(key);\n        LOG.trace(this + \", pending completion: \" + key + \", last: \" + recovered);\n    }\n    public void complete(String clientId, String subscriptionName) {\n        pendingCompletion.remove(getSubscriptionKey(clientId, subscriptionName));\n        LOG.trace(this + \", completion for: \" + getSubscriptionKey(clientId, subscriptionName));\n    }\n    @Override\n    protected void onAdd(Message message, long sequenceId, byte priority) {\n        // update last recovered state\n        for (LastRecovered last : subscriberLastRecoveredMap.values()) {\n            last.updateStored(sequenceId, priority);\n        }\n        sequenceIdCacheSizeLock.writeLock().lock();\n        try {\n            sequenceIdCache.put(message.getMessageId(), new long[]{sequenceId, priority});\n        } finally {\n            sequenceIdCacheSizeLock.writeLock().unlock();\n        }\n    }\n    @Override\n    public void addSubscription(SubscriptionInfo subscriptionInfo, boolean retroactive) throws IOException {\n        TransactionContext c = persistenceAdapter.getTransactionContext();\n        try {\n            c = persistenceAdapter.getTransactionContext();\n            adapter.doSetSubscriberEntry(c, subscriptionInfo, retroactive, isPrioritizedMessages());\n        } catch (SQLException e) {\n            JDBCPersistenceAdapter.log(\"JDBC Failure: \", e);\n            throw IOExceptionSupport.create(\"Failed to lookup subscription for info: \" + subscriptionInfo.getClientId() + \". Reason: \" + e, e);\n        } finally {\n            c.close();\n        }\n    }\n    /**\n     * @see org.apache.activemq.store.TopicMessageStore#lookupSubscription(String,\n     *      String)\n     */\n<fim_suffix>    @Override\n    public SubscriptionInfo lookupSubscription(String clientId, String subscriptionName) throws IOException {\n        TransactionContext c = persistenceAdapter.getTransactionContext();\n        try {\n            return adapter.doGetSubscriberEntry(c, destination, clientId, subscriptionName);\n        } catch (SQLException e) {\n            JDBCPersistenceAdapter.log(\"JDBC Failure: \", e);\n            throw IOExceptionSupport.create(\"Failed to lookup subscription for: \" + clientId + \". Reason: \" + e, e);\n        } finally {\n            c.close();\n        }\n    }<fim_middle>// function below has no smell\n"}