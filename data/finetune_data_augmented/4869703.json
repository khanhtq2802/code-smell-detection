{"text": "<fim_prefix> * (i.e. default SAX2 Namespace processing).\n */\n<fim_suffix>public class ImportHandler extends DefaultHandler {\n    private static Logger log = LoggerFactory.getLogger(ImportHandler.class);\n    private final Importer importer;\n    private final NamespaceRegistry nsReg;\n    private final NamespaceResolver nsResolver;\n    private final NameFactory nameFactory;\n    private ContentHandler targetHandler;\n    private boolean systemViewXML;\n    private boolean initialized;\n    private final NamespaceContext nsContext;\n    private final NamePathResolver resolver;\n    /**\n     * this flag is used to determine whether a namespace context needs to be\n     * started in the startElement event or if the namespace context has already\n     * been started in a preceding startPrefixMapping event;\n     * the flag is set per element in the first startPrefixMapping event and is\n     * cleared again in the following startElement event;\n     */\n    protected boolean nsContextStarted;\n    public ImportHandler(Importer importer, NamespaceResolver nsResolver,\n                         NamespaceRegistry nsReg, NameFactory nameFactory,\n                         PathFactory pathFactory) {\n        this.importer = importer;\n        this.nsResolver = nsResolver;\n        this.nsReg = nsReg;\n        this.nameFactory = nameFactory;\n        nsContext = new NamespaceContext();\n        NameResolver nr = new ParsingNameResolver(nameFactory, nsContext);\n        resolver = new DefaultNamePathResolver(nr, new ParsingPathResolver(pathFactory, nr));\n    }\n    //---------------------------------------------------------< ErrorHandler >\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void warning(SAXParseException e) throws SAXException {\n        // log exception and carry on...\n        log.warn(\"warning encountered at line: \" + e.getLineNumber()\n                + \", column: \" + e.getColumnNumber()\n                + \" while parsing XML stream\", e);\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void error(SAXParseException e) throws SAXException {\n        // log exception and carry on...\n        log.error(\"error encountered at line: \" + e.getLineNumber()\n                + \", column: \" + e.getColumnNumber()\n                + \" while parsing XML stream: \" + e.toString());\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void fatalError(SAXParseException e) throws SAXException {\n        // log and re-throw exception\n        log.error(\"fatal error encountered at line: \" + e.getLineNumber()\n                + \", column: \" + e.getColumnNumber()\n                + \" while parsing XML stream: \" + e.toString());\n        throw e;\n    }\n    //-------------------------------------------------------< ContentHandler >\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void startDocument() throws SAXException {\n        systemViewXML = false;\n        initialized = false;\n        targetHandler = null;\n        /**\n         * start initial context containing existing mappings reflected\n         * by nsResolver\n         */\n        nsContext.reset();\n        nsContext.pushContext();\n        try {\n            String[] uris = nsReg.getURIs();\n            for (int i = 0; i < uris.length; i++) {\n                nsContext.declarePrefix(nsResolver.getPrefix(uris[i]), uris[i]);\n            }\n        } catch (RepositoryException re) {\n            throw new SAXException(re);\n        }\n        // initialize flag\n        nsContextStarted = false;\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void endDocument() throws SAXException {\n        // delegate to target handler\n        targetHandler.endDocument();\n        // cleanup\n        nsContext.reset();\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void startPrefixMapping(String prefix, String uri)\n            throws SAXException {\n        // check if new context needs to be started\n        if (!nsContextStarted) {\n            // entering new namespace context\n            nsContext.pushContext();\n            nsContextStarted = true;\n        }\n        try {\n            // this will trigger NamespaceException if namespace is unknown\n            nsContext.getPrefix(uri);\n        } catch (NamespaceException nse) {\n            // namespace is not yet registered ...\n            try {\n                String newPrefix;\n                if (\"\".equals(prefix)) {\n                    /**\n                     * the xml document specifies a default namespace\n                     * (i.e. an empty prefix); we need to create a random\n                     * prefix as the empty prefix is reserved according\n                     * to the JCR spec.\n                     */\n                    newPrefix = getUniquePrefix(uri);\n                } else {\n                    newPrefix = prefix;\n                }\n                // register new namespace\n                nsReg.registerNamespace(newPrefix, uri);\n            } catch (RepositoryException re) {\n                throw new SAXException(re);\n            }\n        }\n        // map namespace in this context to given prefix\n        nsContext.declarePrefix(prefix, uri);\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void endPrefixMapping(String prefix) throws SAXException {\n        /**\n         * nothing to do here as namespace context has already been popped\n         * in endElement event\n         */\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void startElement(String namespaceURI, String localName, String qName,\n                             Attributes atts) throws SAXException {\n        // check if new context needs to be started\n        if (!nsContextStarted) {\n            // there hasn't been a proceeding startPrefixMapping event\n            // so enter new namespace context\n            nsContext.pushContext();\n        } else {\n            // reset flag\n            nsContextStarted = false;\n        }\n        if (!initialized) {\n            // the namespace of the first element determines the type of XML\n            // (system view/document view)\n            systemViewXML = Name.NS_SV_URI.equals(namespaceURI);\n            if (systemViewXML) {\n                targetHandler = new SysViewImportHandler(importer, resolver);\n            } else {\n                targetHandler = new DocViewImportHandler(importer, resolver, nameFactory);\n            }\n            targetHandler.startDocument();\n            initialized = true;\n        }\n        // delegate to target handler\n        targetHandler.startElement(namespaceURI, localName, qName, atts);\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void characters(char[] ch, int start, int length) throws SAXException {\n        // delegate to target handler\n        targetHandler.characters(ch, start, length);\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void endElement(String namespaceURI, String localName, String qName)\n            throws SAXException {\n        // leaving element, pop namespace context\n        nsContext.popContext();\n        // delegate to target handler\n        targetHandler.endElement(namespaceURI, localName, qName);\n    }\n    //--------------------------------------------------------< inner classes >\n    /**\n     * <code>NamespaceContext</code> supports scoped namespace declarations.\n     */\n    class NamespaceContext implements NamespaceResolver {\n        private final NamespaceSupport nsContext;\n        /**\n         * NamespaceSupport doesn't accept \"\" as default uri;\n         * internally we're using \" \" instead\n         */\n        private static final String DUMMY_DEFAULT_URI = \" \";\n        NamespaceContext() {\n            nsContext = new NamespaceSupport();\n        }\n        void popContext() {\n            nsContext.popContext();\n        }\n        void pushContext() {\n            nsContext.pushContext();\n        }\n        void reset() {\n            nsContext.reset();\n        }\n        boolean declarePrefix(String prefix, String uri) {\n            if (Name.NS_DEFAULT_URI.equals(uri)) {\n                uri = DUMMY_DEFAULT_URI;\n            }\n            return nsContext.declarePrefix(prefix, uri);\n        }\n        //------------------------------------------------< NamespaceResolver >\n        /**\n         * {@inheritDoc}\n         */\n        public String getURI(String prefix) throws NamespaceException {\n            String uri = nsContext.getURI(prefix);\n            if (uri == null) {\n                throw new NamespaceException(\"unknown prefix\");\n            } else if (DUMMY_DEFAULT_URI.equals(uri)) {\n                return Name.NS_DEFAULT_URI;\n            } else {\n                return uri;\n            }\n        }\n        /**\n         * {@inheritDoc}\n         */\n        public String getPrefix(String uri) throws NamespaceException {\n            if (Name.NS_DEFAULT_URI.equals(uri)) {\n                uri = DUMMY_DEFAULT_URI;\n            }\n            String prefix = nsContext.getPrefix(uri);\n            if (prefix == null) {\n                /**\n                 * NamespaceSupport#getPrefix will never return the empty\n                 * (default) prefix; we have to do a reverse-lookup to check\n                 * whether it's the current default namespace\n                 */\n                if (uri.equals(nsContext.getURI(Name.NS_EMPTY_PREFIX))) {\n                    return Name.NS_EMPTY_PREFIX;\n                }\n                throw new NamespaceException(\"unknown uri\");\n            }\n            return prefix;\n        }\n    }\n    /**\n     * Returns a prefix that is unique among the already registered prefixes.\n     *\n     * @param uriHint namespace uri that serves as hint for the prefix generation\n     * @return a unique prefix\n     */\n    public String getUniquePrefix(String uriHint) throws RepositoryException {\n        // TODO: smarter unique prefix generation\n        return \"_pre\" + (nsReg.getPrefixes().length + 1);\n    }\n}<fim_middle>// class below has no smell\n"}