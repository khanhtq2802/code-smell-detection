{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.flume.channel.file;\nimport com.google.common.base.Preconditions;\nimport com.google.protobuf.ByteString;\nimport com.google.protobuf.GeneratedMessage;\nimport org.apache.flume.annotations.InterfaceAudience;\nimport org.apache.flume.annotations.InterfaceStability;\nimport org.apache.flume.channel.file.encryption.CipherProvider;\nimport org.apache.flume.channel.file.encryption.CipherProviderFactory;\nimport org.apache.flume.channel.file.encryption.DecryptionFailureException;\nimport org.apache.flume.channel.file.encryption.KeyProvider;\nimport org.apache.flume.channel.file.proto.ProtosFactory;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport javax.annotation.Nullable;\nimport java.io.EOFException;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.security.Key;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.LinkedBlockingDeque;\n/**\n * Represents a single data file on disk. Has methods to write,\n * read sequentially (replay), and read randomly (channel takes).\n */\n@InterfaceAudience.Private\n@InterfaceStability.Unstable\npublic class LogFileV3 extends LogFile {\n  protected static final Logger LOGGER =\n      LoggerFactory.getLogger(LogFileV3.class);\n  private LogFileV3() {}\n  static class MetaDataWriter extends LogFile.MetaDataWriter {\n    private ProtosFactory.LogFileMetaData logFileMetaData;\n    private final File metaDataFile;\n    protected MetaDataWriter(File logFile, int logFileID) throws IOException {\n      super(logFile, logFileID);\n      metaDataFile = Serialization.getMetaDataFile(logFile);\n      MetaDataReader metaDataReader = new MetaDataReader(logFile, logFileID);\n      logFileMetaData = metaDataReader.read();\n      int version = logFileMetaData.getVersion();\n      if (version != getVersion()) {\n        throw new IOException(\"Version is \" + Integer.toHexString(version) +\n            \" expected \" + Integer.toHexString(getVersion())\n            + \" file: \" + logFile);\n      }\n      setLastCheckpointOffset(logFileMetaData.getCheckpointPosition());\n      setLastCheckpointWriteOrderID(logFileMetaData.getCheckpointWriteOrderID());\n    }\n    @Override\n    int getVersion() {\n      return Serialization.VERSION_3;\n    }\n    @Override\n    void markCheckpoint(long currentPosition, long logWriteOrderID)\n        throws IOException {\n      ProtosFactory.LogFileMetaData.Builder metaDataBuilder =\n          ProtosFactory.LogFileMetaData.newBuilder(logFileMetaData);\n      metaDataBuilder.setCheckpointPosition(currentPosition);\n      metaDataBuilder.setCheckpointWriteOrderID(logWriteOrderID);\n      /*\n       * Set the previous checkpoint position and write order id so that it\n       * would be possible to recover from a backup.\n       */\n      metaDataBuilder.setBackupCheckpointPosition(logFileMetaData\n          .getCheckpointPosition());\n      metaDataBuilder.setBackupCheckpointWriteOrderID(logFileMetaData\n          .getCheckpointWriteOrderID());\n      logFileMetaData = metaDataBuilder.build();\n      writeDelimitedTo(logFileMetaData, metaDataFile);\n    }\n  }\n  static class MetaDataReader {\n    private final File logFile;\n    private final File metaDataFile;\n    private final int logFileID;\n<fim_suffix>    protected MetaDataReader(File logFile, int logFileID) throws IOException {\n      this.logFile = logFile;\n      metaDataFile = Serialization.getMetaDataFile(logFile);\n      this.logFileID = logFileID;\n    }\n    ProtosFactory.LogFileMetaData read() throws IOException {\n      FileInputStream inputStream = new FileInputStream(metaDataFile);\n      try {\n        ProtosFactory.LogFileMetaData metaData = Preconditions.checkNotNull(\n            ProtosFactory.LogFileMetaData.parseDelimitedFrom(inputStream),\n            \"Metadata cannot be null\");\n        if (metaData.getLogFileID() != logFileID) {\n          throw new IOException(\"The file id of log file: \"\n              + logFile + \" is different from expected \"\n              + \" id: expected = \" + logFileID + \", found = \"\n              + metaData.getLogFileID());\n        }\n        return metaData;\n      } finally {\n        try {\n          inputStream.close();\n        } catch (IOException e) {\n          LOGGER.warn(\"Unable to close \" + metaDataFile, e);\n        }\n      }\n    }\n  }\n  /**\n   * Writes a GeneratedMessage to a temp file, synchronizes it to disk\n   * and then renames the file over file.\n   *\n   * @param msg  GeneratedMessage to write to the file\n   * @param file destination file\n   * @throws IOException if a write error occurs or the File.renameTo\n   *                     method returns false meaning the file could not be overwritten.\n   */\n  public static void writeDelimitedTo(GeneratedMessage msg, File file)\n      throws IOException {\n    File tmp = Serialization.getMetaDataTempFile(file);\n    FileOutputStream outputStream = new FileOutputStream(tmp);\n    boolean closed = false;\n    try {\n      msg.writeDelimitedTo(outputStream);\n      outputStream.getChannel().force(true);\n      outputStream.close();\n      closed = true;\n      if (!tmp.renameTo(file)) {\n        //Some platforms don't support moving over an existing file.\n        //So:\n        //log.meta -> log.meta.old\n        //log.meta.tmp -> log.meta\n        //delete log.meta.old\n        File oldFile = Serialization.getOldMetaDataFile(file);\n        if (!file.renameTo(oldFile)) {\n          throw new IOException(\"Unable to rename \" + file + \" to \" + oldFile);\n        }\n        if (!tmp.renameTo(file)) {\n          throw new IOException(\"Unable to rename \" + tmp + \" over \" + file);\n        }\n        oldFile.delete();\n      }\n    } finally {\n      if (!closed) {\n        try {\n          outputStream.close();\n        } catch (IOException e) {\n          LOGGER.warn(\"Unable to close \" + tmp, e);\n        }\n      }\n    }\n  }\n  static class Writer extends LogFile.Writer {\n    Writer(File file, int logFileID, long maxFileSize,\n           @Nullable Key encryptionKey,\n           @Nullable String encryptionKeyAlias,\n           @Nullable String encryptionCipherProvider,\n           long usableSpaceRefreshInterval, boolean fsyncPerTransaction,\n           int fsyncInterval) throws IOException {\n      super(file, logFileID, maxFileSize,\n            CipherProviderFactory.getEncrypter(encryptionCipherProvider, encryptionKey),\n            usableSpaceRefreshInterval, fsyncPerTransaction, fsyncInterval);\n      ProtosFactory.LogFileMetaData.Builder metaDataBuilder =\n          ProtosFactory.LogFileMetaData.newBuilder();\n      if (encryptionKey != null) {\n        Preconditions.checkNotNull(encryptionKeyAlias, \"encryptionKeyAlias\");\n        Preconditions.checkNotNull(encryptionCipherProvider,\n            \"encryptionCipherProvider\");\n        ProtosFactory.LogFileEncryption.Builder logFileEncryptionBuilder =\n            ProtosFactory.LogFileEncryption.newBuilder();\n        logFileEncryptionBuilder.setCipherProvider(encryptionCipherProvider);\n        logFileEncryptionBuilder.setKeyAlias(encryptionKeyAlias);\n        logFileEncryptionBuilder.setParameters(\n            ByteString.copyFrom(getEncryptor().getParameters()));\n        metaDataBuilder.setEncryption(logFileEncryptionBuilder);\n      }\n      metaDataBuilder.setVersion(getVersion());\n      metaDataBuilder.setLogFileID(logFileID);\n      metaDataBuilder.setCheckpointPosition(0L);\n      metaDataBuilder.setCheckpointWriteOrderID(0L);\n      metaDataBuilder.setBackupCheckpointPosition(0L);\n      metaDataBuilder.setBackupCheckpointWriteOrderID(0L);\n      File metaDataFile = Serialization.getMetaDataFile(file);\n      writeDelimitedTo(metaDataBuilder.build(), metaDataFile);\n    }\n    @Override\n    int getVersion() {\n      return Serialization.VERSION_3;\n    }\n  }\n  static class RandomReader extends LogFile.RandomReader {\n    private volatile boolean initialized;\n    private volatile boolean encryptionEnabled;\n    private volatile Key key;\n    private volatile String cipherProvider;\n    private volatile byte[] parameters;\n    private BlockingQueue<CipherProvider.Decryptor> decryptors =\n        new LinkedBlockingDeque<CipherProvider.Decryptor>();\n    RandomReader(File file, @Nullable KeyProvider encryptionKeyProvider,\n                 boolean fsyncPerTransaction) throws IOException {\n      super(file, encryptionKeyProvider, fsyncPerTransaction);\n    }<fim_middle>// function below has no smell\n"}