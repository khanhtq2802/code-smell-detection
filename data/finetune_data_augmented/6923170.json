{"text": "<fim_prefix>    Input.Token getToken() {\n      return token;\n    }\n    /**\n     * Is the token good? That is, does it match an {@link Input.Token}?\n     *\n     * @return whether the @code Token} is good\n     */\n    RealOrImaginary realOrImaginary() {\n      return realOrImaginary;\n    }\n    @Override\n    public void add(DocBuilder builder) {\n      builder.add(this);\n    }\n    @Override\n    float computeWidth() {\n      return token.getTok().length();\n    }\n    @Override\n    String computeFlat() {\n      return token.getTok().getOriginalText();\n    }\n    @Override\n    Range<Integer> computeRange() {\n      return Range.singleton(token.getTok().getIndex()).canonical(INTEGERS);\n    }\n    @Override\n    public State computeBreaks(CommentsHelper commentsHelper, int maxWidth, State state) {\n      String text = token.getTok().getOriginalText();\n      return state.withColumn(state.column + text.length());\n    }\n    @Override\n    public void write(Output output) {\n      String text = token.getTok().getOriginalText();\n      output.append(text, range());\n    }\n    @Override\n    public String toString() {\n      return MoreObjects.toStringHelper(this)\n          .add(\"token\", token)\n          .add(\"realOrImaginary\", realOrImaginary)\n          .add(\"plusIndentCommentsBefore\", plusIndentCommentsBefore)\n          .toString();\n    }\n  }\n  /** A Leaf node in a {@link Doc} for a non-breaking space. */\n  static final class Space extends Doc implements Op {\n    private static final Space SPACE = new Space();\n    private Space() {}\n    /**\n     * Factor method for {@code Space}.\n     *\n     * @return the new {@code Space}\n     */\n    static Space make() {\n      return SPACE;\n    }\n    @Override\n    public void add(DocBuilder builder) {\n      builder.add(this);\n    }\n    @Override\n    float computeWidth() {\n      return 1.0F;\n    }\n    @Override\n    String computeFlat() {\n      return \" \";\n    }\n    @Override\n    Range<Integer> computeRange() {\n      return EMPTY_RANGE;\n    }\n    @Override\n    public State computeBreaks(CommentsHelper commentsHelper, int maxWidth, State state) {\n      return state.withColumn(state.column + 1);\n    }\n    @Override\n    public void write(Output output) {\n      output.append(\" \", range());\n    }\n    @Override\n    public String toString() {\n      return MoreObjects.toStringHelper(this).toString();\n    }\n  }\n  /** A leaf node in a {@link Doc} for an optional break. */\n  public static final class Break extends Doc implements Op {\n    private final FillMode fillMode;\n    private final String flat;\n    private final Indent plusIndent;\n    private final Optional<BreakTag> optTag;\n    private Break(FillMode fillMode, String flat, Indent plusIndent, Optional<BreakTag> optTag) {\n      this.fillMode = fillMode;\n      this.flat = flat;\n      this.plusIndent = plusIndent;\n      this.optTag = optTag;\n    }\n    /**\n     * Make a {@code Break}.\n     *\n     * @param fillMode the {@link FillMode}\n     * @param flat the text when not broken\n     * @param plusIndent extra indent if taken\n     * @return the new {@code Break}\n     */\n    public static Break make(FillMode fillMode, String flat, Indent plusIndent) {\n      return new Break(fillMode, flat, plusIndent, /* optTag= */ Optional.empty());\n    }\n    /**\n     * Make a {@code Break}.\n     *\n     * @param fillMode the {@link FillMode}\n     * @param flat the text when not broken\n     * @param plusIndent extra indent if taken\n     * @param optTag an optional tag for remembering whether the break was taken\n     * @return the new {@code Break}\n     */\n    public static Break make(\n        FillMode fillMode, String flat, Indent plusIndent, Optional<BreakTag> optTag) {\n      return new Break(fillMode, flat, plusIndent, optTag);\n    }\n    /**\n     * Make a forced {@code Break}.\n     *\n     * @return the new forced {@code Break}\n     */\n    public static Break makeForced() {\n      return make(FillMode.FORCED, \"\", Indent.Const.ZERO);\n    }\n    /**\n     * Return the {@code Break}'s extra indent.\n     *\n     * @return the extra indent\n     */\n    int getPlusIndent() {\n      return plusIndent.eval();\n    }\n    /**\n     * Is the {@code Break} forced?\n     *\n     * @return whether the {@code Break} is forced\n     */\n    boolean isForced() {\n      return fillMode == FillMode.FORCED;\n    }\n    @Override\n    public void add(DocBuilder builder) {\n      builder.breakDoc(this);\n    }\n    @Override\n    float computeWidth() {\n      return isForced() ? Float.POSITIVE_INFINITY : (float) flat.length();\n    }\n    @Override\n    String computeFlat() {\n      return flat;\n    }\n    @Override\n    Range<Integer> computeRange() {\n      return EMPTY_RANGE;\n    }\n    /** Was this break taken? */\n    boolean broken;\n    /** New indent after this break. */\n    int newIndent;\n    public State computeBreaks(State state, int lastIndent, boolean broken) {\n      if (optTag.isPresent()) {\n        optTag.get().recordBroken(broken);\n      }\n      if (broken) {\n        this.broken = true;\n        this.newIndent = Math.max(lastIndent + plusIndent.eval(), 0);\n        return state.withColumn(newIndent);\n      } else {\n        this.broken = false;\n        this.newIndent = -1;\n        return state.withColumn(state.column + flat.length());\n      }\n    }\n    @Override\n    public State computeBreaks(CommentsHelper commentsHelper, int maxWidth, State state) {\n      // Updating the state for {@link Break}s requires deciding if the break\n      // should be taken.\n      // TODO(cushon): this hierarchy is wrong, create a separate interface\n      // for unbreakable Docs?\n      throw new UnsupportedOperationException(\"Did you mean computeBreaks(State, int, boolean)?\");\n    }\n    @Override\n    public void write(Output output) {\n      if (broken) {\n        output.append(\"\\n\", EMPTY_RANGE);\n        output.indent(newIndent);\n      } else {\n        output.append(flat, range());\n      }\n    }\n    @Override\n    public String toString() {\n      return MoreObjects.toStringHelper(this)\n          .add(\"fillMode\", fillMode)\n          .add(\"flat\", flat)\n          .add(\"plusIndent\", plusIndent)\n          .add(\"optTag\", optTag)\n          .toString();\n    }\n  }\n  /** A leaf node in a {@link Doc} for a non-token. */\n  static final class Tok extends Doc implements Op {\n    private final Input.Tok tok;\n    private Tok(Input.Tok tok) {\n      this.tok = tok;\n    }\n    /**\n     * Factory method for a {@code Tok}.\n     *\n     * @param tok the {@link Input.Tok} to wrap\n     * @return the new {@code Tok}\n     */\n    static Tok make(Input.Tok tok) {\n      return new Tok(tok);\n    }\n    @Override\n    public void add(DocBuilder builder) {\n      builder.add(this);\n    }\n    @Override\n    float computeWidth() {\n      int idx = Newlines.firstBreak(tok.getOriginalText());\n      // only count the first line of multi-line block comments\n      if (tok.isComment()) {\n        if (idx > 0) {\n          return idx;\n        } else if (tok.isSlashSlashComment() && !tok.getOriginalText().startsWith(\"// \")) {\n          // Account for line comments with missing spaces, see computeFlat.\n          return tok.length() + 1;\n        } else {\n          return tok.length();\n        }\n      }\n      return idx != -1 ? Float.POSITIVE_INFINITY : (float) tok.length();\n    }\n    @Override\n    String computeFlat() {\n      // TODO(cushon): commentsHelper.rewrite doesn't get called for spans that fit in a single\n      // line. That's fine for multi-line comment reflowing, but problematic for adding missing\n      // spaces in line comments.\n      if (tok.isSlashSlashComment() && !tok.getOriginalText().startsWith(\"// \")) {\n        return \"// \" + tok.getOriginalText().substring(\"//\".length());\n      }\n      return tok.getOriginalText();\n    }\n    @Override\n    Range<Integer> computeRange() {\n      return Range.singleton(tok.getIndex()).canonical(INTEGERS);\n    }\n    String text;\n<fim_suffix>    @Override\n    public State computeBreaks(CommentsHelper commentsHelper, int maxWidth, State state) {\n      text = commentsHelper.rewrite(tok, maxWidth, state.column);\n      int firstLineLength = text.length() - Iterators.getLast(Newlines.lineOffsetIterator(text));\n      return state.withColumn(state.column + firstLineLength);\n    }<fim_middle>// function below is feature envy\n"}