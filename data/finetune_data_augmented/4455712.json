{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.drill.exec.store.httpd;\nimport org.apache.drill.shaded.guava.com.google.common.base.Charsets;\nimport org.apache.drill.shaded.guava.com.google.common.collect.Maps;\nimport io.netty.buffer.DrillBuf;\nimport java.util.EnumSet;\nimport java.util.HashMap;\nimport java.util.Map;\nimport nl.basjes.parse.core.Casts;\nimport nl.basjes.parse.core.Parser;\nimport org.apache.drill.exec.vector.complex.writer.BaseWriter.MapWriter;\nimport org.apache.drill.exec.vector.complex.writer.BigIntWriter;\nimport org.apache.drill.exec.vector.complex.writer.Float8Writer;\nimport org.apache.drill.exec.vector.complex.writer.VarCharWriter;\nimport org.apache.drill.exec.vector.complex.writer.TimeStampWriter;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\npublic class HttpdLogRecord {\n  private static final Logger LOG = LoggerFactory.getLogger(HttpdLogRecord.class);\n  private final Map<String, VarCharWriter> strings = Maps.newHashMap();\n  private final Map<String, BigIntWriter> longs = Maps.newHashMap();\n  private final Map<String, Float8Writer> doubles = Maps.newHashMap();\n  private final Map<String, TimeStampWriter> times = new HashMap<>();\n  private final Map<String, MapWriter> wildcards = Maps.newHashMap();\n  private final Map<String, String> cleanExtensions = Maps.newHashMap();\n  private final Map<String, MapWriter> startedWildcards = Maps.newHashMap();\n  private final Map<String, MapWriter> wildcardWriters = Maps.newHashMap();\n  private final SimpleDateFormat dateFormatter;\n  private DrillBuf managedBuffer;\n  private String timeFormat;\n  public HttpdLogRecord(final DrillBuf managedBuffer, final String timeFormat) {\n    this.managedBuffer = managedBuffer;\n    this.timeFormat = timeFormat;\n    this.dateFormatter = new SimpleDateFormat(this.timeFormat);\n  }\n  /**\n   * Call this method after a record has been parsed. This finished the lifecycle of any maps that were written and\n   * removes all the entries for the next record to be able to work.\n   */\n  public void finishRecord() {\n    for (MapWriter writer : wildcardWriters.values()) {\n      writer.end();\n    }\n    wildcardWriters.clear();\n    startedWildcards.clear();\n  }\n  private DrillBuf buf(final int size) {\n    if (managedBuffer.capacity() < size) {\n      managedBuffer = managedBuffer.reallocIfNeeded(size);\n    }\n    return managedBuffer;\n  }\n  private void writeString(VarCharWriter writer, String value) {\n    final byte[] stringBytes = value.getBytes(Charsets.UTF_8);\n    final DrillBuf stringBuffer = buf(stringBytes.length);\n    stringBuffer.clear();\n    stringBuffer.writeBytes(stringBytes);\n    writer.writeVarChar(0, stringBytes.length, stringBuffer);\n  }\n  /**\n   * This method is referenced and called via reflection. This is added as a parsing target for the parser. It will get\n   * called when the value of a log field is a String data type.\n   *\n   * @param field name of field\n   * @param value value of field\n   */\n  @SuppressWarnings(\"unused\")\n  public void set(String field, String value) {\n    if (value != null) {\n      final VarCharWriter w = strings.get(field);\n      if (w != null) {\n        LOG.trace(\"Parsed field: {}, as string: {}\", field, value);\n        writeString(w, value);\n      } else {\n        LOG.warn(\"No 'string' writer found for field: {}\", field);\n      }\n    }\n  }\n  /**\n   * This method is referenced and called via reflection. This is added as a parsing target for the parser. It will get\n   * called when the value of a log field is a Long data type.\n   *\n   * @param field name of field\n   * @param value value of field\n   */\n  @SuppressWarnings(\"unused\")\n  public void set(String field, Long value) {\n    if (value != null) {\n      final BigIntWriter w = longs.get(field);\n      if (w != null) {\n        LOG.trace(\"Parsed field: {}, as long: {}\", field, value);\n        w.writeBigInt(value);\n      } else {\n        LOG.warn(\"No 'long' writer found for field: {}\", field);\n      }\n    }\n  }\n  /**\n   * This method is referenced and called via reflection. This is added as a parsing target for the parser. It will get\n   * called when the value of a log field is a timesstamp data type.\n   *\n   * @param field name of field\n   * @param value value of field\n   */\n<fim_suffix>  @SuppressWarnings(\"unused\")\n  public void setTimestamp(String field, String value) {\n    if (value != null) {\n      //Convert the date string into a long\n      long ts = 0;\n      try {\n        Date d = this.dateFormatter.parse(value);\n        ts = d.getTime();\n      } catch (Exception e) {\n        //If the date formatter does not successfully create a date, the timestamp will fall back to zero\n        //Do not throw exception\n      }\n      final TimeStampWriter tw = times.get(field);\n      if (tw != null) {\n        LOG.trace(\"Parsed field: {}, as time: {}\", field, value);\n        tw.writeTimeStamp(ts);\n      } else {\n        LOG.warn(\"No 'timestamp' writer found for field: {}\", field);\n      }\n    }\n  }\n  /**\n   * This method is referenced and called via reflection. This is added as a parsing target for the parser. It will get\n   * called when the value of a log field is a Double data type.\n   *\n   * @param field name of field\n   * @param value value of field\n   */\n  @SuppressWarnings(\"unused\")\n  public void set(String field, Double value) {\n    if (value != null) {\n      final Float8Writer w = doubles.get(field);\n      if (w != null) {\n        LOG.trace(\"Parsed field: {}, as double: {}\", field, value);\n        w.writeFloat8(value);\n      } else {\n        LOG.warn(\"No 'double' writer found for field: {}\", field);\n      }\n    }\n  }\n  /**\n   * This method is referenced and called via reflection. When the parser processes a field like:\n   * HTTP.URI:request.firstline.uri.query.* where star is an arbitrary field that the parser found this method will be\n   * invoked. <br>\n   *\n   * @param field name of field\n   * @param value value of field\n   */\n  @SuppressWarnings(\"unused\")\n  public void setWildcard(String field, String value) {\n    if (value != null) {\n      final MapWriter mapWriter = getWildcardWriter(field);\n      LOG.trace(\"Parsed wildcard field: {}, as string: {}\", field, value);\n      final VarCharWriter w = mapWriter.varChar(cleanExtensions.get(field));\n      writeString(w, value);\n    }\n  }\n  /**\n   * This method is referenced and called via reflection. When the parser processes a field like:\n   * HTTP.URI:request.firstline.uri.query.* where star is an arbitrary field that the parser found this method will be\n   * invoked. <br>\n   *\n   * @param field name of field\n   * @param value value of field\n   */\n  @SuppressWarnings(\"unused\")\n  public void setWildcard(String field, Long value) {\n    if (value != null) {\n      final MapWriter mapWriter = getWildcardWriter(field);\n      LOG.trace(\"Parsed wildcard field: {}, as long: {}\", field, value);\n      final BigIntWriter w = mapWriter.bigInt(cleanExtensions.get(field));\n      w.writeBigInt(value);\n    }\n  }\n  /**\n   * This method is referenced and called via reflection. When the parser processes a field like:\n   * HTTP.URI:request.firstline.uri.query.* where star is an arbitrary field that the parser found this method will be\n   * invoked. <br>\n   *<fim_middle>// function below has no smell\n"}