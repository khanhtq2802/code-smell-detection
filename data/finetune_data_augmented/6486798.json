{"text": "<fim_prefix>\t\tif ( allowThreeTierResolverString != null && allowThreeTierResolverString.toLowerCase().equals(\"true\") ) {\n\t\t\tALLOW_THREE_TIER_TABLE_RESOLVER = true;\n\t\t\tlogger.logp(FINE,\"MemoryRangeTable\",\"<clinit>\",\"ThreeTierResolver selection allowed.\");\n\t\t} else {\n\t\t\tlogger.logp(FINE,\"MemoryRangeTable\",\"<clinit>\",\"ThreeTierResolver selection NOT allowed.\");\n\t\t\tALLOW_THREE_TIER_TABLE_RESOLVER = false;\n\t\t}\n\t}\n\tprivate IAddressResolverStrategy addressResolver = null;\n\tprivate final List<IMemorySource> rawMemorySources = new ArrayList<IMemorySource>();\n\tprivate List<IMemorySource> memorySources;\n\tpublic final void addMemorySource(IMemorySource source)\n\t{\n\t\trawMemorySources.add(source);\n\t\taddressResolver = null;\n\t}\n\tpublic void removeMemorySource(IMemorySource source)\n\t{\n\t\trawMemorySources.remove(source);\n\t\taddressResolver = null;\n\t}\n\tpublic final List<IMemoryRange> getMemorySources() \n\t{\n\t\tmergeOverlappingRanges();\n\t\treturn new ArrayList<IMemoryRange>(memorySources);\n\t}\n\tpublic final IMemorySource getRangeForAddress(long address)\n\t{\n\t\tif (addressResolver == null) {\n\t\t\tpickAddressResolver();\n\t\t}\n\t\treturn addressResolver.getRangeForAddress(address);\n\t}\n\tprivate void pickAddressResolver()\n\t{\n\t\tmergeOverlappingRanges();\n\t\t//Need to figure out highest address and worst alignment\n\t\tlong highestAddress = 0;\n\t\tint worstAlignment = Integer.MAX_VALUE;\n\t\tlong smallestRange = Integer.MAX_VALUE;\n\t\tfor (IMemoryRange range : memorySources) {\n\t\t\tif ( Addresses.greaterThan(range.getTopAddress(), highestAddress) ) {\n\t\t\t\thighestAddress = range.getTopAddress();\n\t\t\t}\n\t\t\tint alignment = getAlignment(range.getBaseAddress());\n\t\t\tif (alignment < worstAlignment) {\n\t\t\t\tworstAlignment = alignment;\n\t\t\t}\n\t\t\tif (range.getSize() < smallestRange) {\n\t\t\t\tsmallestRange = range.getSize();\n\t\t\t}\n\t\t}\n\t\tlogger.logp(FINE,\"MemoryRangeTable\", \"pickAddressResolver\", \"Picking address resolver. Highest Address = 0x{0}, worst alignment = {1} bit.\",new Object[]{Long.toHexString(highestAddress),worstAlignment});\n\t\tif (FORCE_BINARY_CHOP_RESOLVER) {\n\t\t\tlogger.logp(FINE,\"MemoryRangeTable\", \"pickAddressResolver\", \"Selection overridden with {0}\",FORCE_BINARY_CHOP_RESOLVER_SYSTEM_PROPERTY);\n\t\t\taddressResolver = new BinaryChopAddressResolver(memorySources);\n\t\t} else {\n\t\t\tif (worstAlignment >= 12 && smallestRange >= 4096) {\n\t\t\t\tif (Addresses.lessThan(highestAddress,0x100000000L)) {\n\t\t\t\t\taddressResolver = new FlatPageTableAddressResolver(memorySources,highestAddress,worstAlignment);\n\t\t\t\t} else if( ALLOW_THREE_TIER_TABLE_RESOLVER ){\n\t\t\t\t\tlogger.logp(FINE,\"MemoryRangeTable\", \"pickAddressResolver\", \"Three tier table resolver selected, allowed by {0} setting\",ALLOW_THREE_TIER_TABLE_RESOLVER_PROPERTY);\n\t\t\t\t\taddressResolver = new ThreeTierPageTableAddressResolver(memorySources, highestAddress, worstAlignment);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* Can't use one of the clever resolvers. We will fall back to binary-chop. */\n\t\tif( addressResolver == null ) {\n\t\t\taddressResolver = new BinaryChopAddressResolver(memorySources);\n\t\t}\n\t\tlogger.logp(FINE,\"MemoryRangeTable\", \"pickAddressResolver\", \"Picked {0} as address resolver.\",addressResolver.getClass().getSimpleName());\n\t}\n\tprivate void mergeOverlappingRanges()\n\t{\n\t\tmemorySources = new ArrayList<IMemorySource>(rawMemorySources);\n\t\tCollections.sort(memorySources);\n\t\t//Resolve any overlapping ranges (seems to happen on AIX occasionally)\n\t\tif (memorySources.size() > 0) {\n\t\t\tListIterator<IMemorySource> rangeIt = memorySources.listIterator();\n\t\t\tIMemorySource previous = rangeIt.next();\n\t\t\twhile (rangeIt.hasNext()) {\n\t\t\t\tIMemorySource thisRange = rangeIt.next();\n\t\t\t\tif (thisRange.overlaps(previous)) {\n\t\t\t\t\tlogger.logp(FINE,\"MemoryRangeTable\",\"mergeOverlappingRanges\",\"Address range {0} overlaps with {1}\",new Object[]{thisRange,previous});\n\t\t\t\t\t//Either thisRange is a subrange of previous or we overlap partially\n\t\t\t\t\tif (previous.isSubRange(thisRange)) {\n\t\t\t\t\t\t//Remove thisRange\n\t\t\t\t\t\tlogger.logp(FINER,\"MemoryRangeTable\",\"mergeOverlappingRanges\",\"Removing {0}\",thisRange);\n\t\t\t\t\t\trangeIt.remove();\n\t\t\t\t\t\t//Leave previous as-is\n\t\t\t\t\t} else if (previous.isBacked() == thisRange.isBacked()) {\n\t\t\t\t\t\tlogger.logp(FINER,\"MemoryRangeTable\",\"mergeOverlappingRanges\",\"Merging {0} and {1}\", new Object[]{thisRange,previous});\n\t\t\t\t\t\t//Merge\n\t\t\t\t\t\trangeIt.remove();\n\t\t\t\t\t\trangeIt.previous();\n\t\t\t\t\t\trangeIt.remove();\n\t\t\t\t\t\tIMemorySource toAdd = new MergedMemoryRange(previous,thisRange);\n\t\t\t\t\t\trangeIt.add(toAdd);\n\t\t\t\t\t\tprevious = toAdd;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprevious = thisRange;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tprevious = thisRange;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstatic int getAlignment(long address)\n\t{\n\t\tint alignment = 0;\n\t\tfor (int i=0; i < 64; i++) {\n\t\t\tif ((address & 0x1) == 0) {\n\t\t\t\talignment++;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\taddress >>= 1;\n\t\t}\n\t\treturn alignment;\n\t}\n\t/**\n\t * Memory range used for merging overlapping memory ranges.\n\t * \n\t */\n\tprivate static class MergedMemoryRange extends BaseMemoryRange implements IMemorySource\n\t{\n\t\tprivate final IMemorySource lower;\n\t\tprivate final IMemorySource upper;\n\t\tpublic MergedMemoryRange(IMemorySource lower, IMemorySource upper)\n\t\t{\n\t\t\tsuper(lower.getBaseAddress(),upper.getTopAddress() - lower.getBaseAddress() + 1);\n\t\t\tthis.lower = lower;\n\t\t\tthis.upper = upper;\n\t\t\tif (lower.isBacked() != upper.isBacked()) {\n\t\t\t\tthrow new RuntimeException(\"Error: creating an instance of MergedMemoryRange where backed and unbacked memory sources are merged\");\n\t\t\t}\n\t\t}\n\t\tpublic int getAddressSpaceId()\n\t\t{\n\t\t\treturn lower.getAddressSpaceId();\n\t\t}\n\t\t@Override\n\t\tpublic boolean isBacked() {\n\t\t\treturn upper.isBacked();\n\t\t}\n\t\tpublic int getBytes(long address, byte[] buffer, int offset, int length)\n\t\t\t\tthrows MemoryFault\n\t\t{\n\t\t\tif (lower.contains(address) && lower.contains(address + length)) {\n\t\t\t\treturn lower.getBytes(address, buffer, offset, length);\n\t\t\t} else if (Addresses.greaterThan(address, lower.getTopAddress())) {\n\t\t\t\treturn upper.getBytes(address, buffer, offset, length);\n\t\t\t} else {\n\t\t\t\t//Span\n\t\t\t\tint sizeInLower = (int)(lower.getTopAddress() - address + 1);\n\t\t\t\tint read = lower.getBytes(address, buffer, offset, sizeInLower);\n\t\t\t\tif (read == sizeInLower) {\n\t\t\t\t\tread += upper.getBytes(address + sizeInLower, buffer, offset + sizeInLower, length - sizeInLower);\n\t\t\t\t}\n\t\t\t\treturn read;\n\t\t\t}\n\t\t}\n\t\tpublic boolean isExecutable()\n\t\t{\n\t\t\treturn lower.isExecutable() && upper.isExecutable();\n\t\t}\n\t\tpublic boolean isReadOnly()\n\t\t{\n\t\t\treturn lower.isExecutable() && upper.isExecutable();\n\t\t}\n\t\tpublic boolean isShared()\n\t\t{\n\t\t\treturn lower.isShared() && upper.isShared();\n\t\t}\n<fim_suffix>\t\tpublic String getName()\n\t\t{\n\t\t\tString lowerResult = lower.getName();\n\t\t\tString upperResult = upper.getName();\n\t\t\tif (lowerResult != null) {\n\t\t\t\tif (upperResult != null) {\n\t\t\t\t\treturn lowerResult + \" merged with \" + upperResult;\n\t\t\t\t} else {\n\t\t\t\t\treturn lowerResult;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (upperResult != null) {\n\t\t\t\t\treturn upperResult;\n\t\t\t\t} else {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t}<fim_middle>// function below has no smell\n"}