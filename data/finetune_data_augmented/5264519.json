{"text": "<fim_prefix>\n<fim_suffix>public class NERPhraseGeneralizer extends PhraseGeneralizer {\n\t/* alignment is based on NER values, not on POS now\n\t * \n\t */\n\t/**\n\t * key matching function which takes two phrases, aligns them and finds a set\n\t * of maximum common sub-phrase\n\t * \n\t * @param chunk1\n\t * @param chunk2\n\t * @return\n\t */\n\t@Override\n\tpublic List<ParseTreeChunk> generalize(\n\t\t\tObject chunk1o, Object chunk2o) {\n\t\tParseTreeChunk chunk1 = (ParseTreeChunk)chunk1o, chunk2 = (ParseTreeChunk)chunk2o;\n\t\tList<ParseTreeNode> results = new ArrayList<ParseTreeNode>();\n\t\tList<ParseTreeChunk> resultChunks = new ArrayList<ParseTreeChunk>();\n\t\tList<String> pos1 = chunk1.getPOSs();\n\t\tList<String> pos2 = chunk2.getPOSs();\n\t\tList<String> lem1 = chunk1.getLemmas();\n\t\tList<String> lem2 = chunk2.getLemmas();\n\t\tList<String> ner1 = new ArrayList<String>();\n\t\tList<String> ner2 = new ArrayList<String>();\n\t\tfor (ParseTreeNode node: chunk1.getParseTreeNodes()) {\n\t\t\tif (node.getNe()!=null && !node.getNe().equals(\"O\"))\n\t\t\t\tner1.add(node.getNe());\n\t\t}\n\t\tfor (ParseTreeNode node: chunk2.getParseTreeNodes()) {\n\t\t\tif (node.getNe()!=null && !node.getNe().equals(\"O\"))\n\t\t\t\tner2.add(node.getNe());\n\t\t}\n\t\tList<String> overlap = new ArrayList<String>(ner1);\n\t\toverlap.retainAll(ner2);\n\t\toverlap = new ArrayList<String>(new HashSet<String>(overlap));\n\t\tif (overlap == null || overlap.size() < 1)\n\t\t\treturn null;\n\t\tList<Integer> occur1 = new ArrayList<Integer>(), occur2 = new ArrayList<Integer>();\n\t\tfor (String word : overlap) {\n\t\t\tInteger i1 = ner1.indexOf(word);\n\t\t\tInteger i2 = ner2.indexOf(word);\n\t\t\toccur1.add(i1);\n\t\t\toccur2.add(i2);\n\t\t}\n\t\t// for verbs find alignment even if no same verb lemmas, just any pair of verbs. Usually should be 0,0\n\t\tif (chunk1.getMainPOS().startsWith(\"VP\") && chunk2.getMainPOS().startsWith(\"VP\")) {\n\t\t\tInteger i1 = null, i2 = null;\n\t\t\tfor(int i=0; i< pos1.size(); i++){\n\t\t\t\tif (pos1.get(i).startsWith(\"VB\")){\n\t\t\t\t\ti1 = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i< pos2.size(); i++){\n\t\t\t\tif (pos2.get(i).startsWith(\"VB\")){\n\t\t\t\t\ti2 = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\toccur1.add(i1);\n\t\t\toccur2.add(i2);\n\t\t}\n\t\t// now we search for plausible sublists of overlaps\n\t\t// if at some position correspondence is inverse (one of two position\n\t\t// decreases instead of increases)\n\t\t// then we terminate current alignment accum and start a new one\n\t\tList<List<int[]>> overlapsPlaus = new ArrayList<List<int[]>>();\n\t\t// starts from 1, not 0\n\t\tList<int[]> accum = new ArrayList<int[]>();\n\t\taccum.add(new int[] { occur1.get(0), occur2.get(0) });\n\t\tfor (int i = 1; i < occur1.size(); i++) {\n\t\t\tif (occur1.get(i) > occur1.get(i - 1)\n\t\t\t\t\t&& occur2.get(i) > occur2.get(i - 1))\n\t\t\t\taccum.add(new int[] { occur1.get(i), occur2.get(i) });\n\t\t\telse {\n\t\t\t\toverlapsPlaus.add(accum);\n\t\t\t\tif (occur1!=null && occur2!=null && i<occur1.size() &&  i<occur2.size() ){\n\t\t\t\t\taccum = new ArrayList<int[]>();\n\t\t\t\t\taccum.add(new int[] { occur1.get(i), occur2.get(i) });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (accum.size() > 0) {\n\t\t\toverlapsPlaus.add(accum);\n\t\t}\n\t\tfor (List<int[]> occur : overlapsPlaus) {\n\t\t\tList<Integer> occr1 = new ArrayList<Integer>(), occr2 = new ArrayList<Integer>();\n\t\t\tfor (int[] column : occur) {\n\t\t\t\toccr1.add(column[0]);\n\t\t\t\toccr2.add(column[1]);\n\t\t\t}\n\t\t\tint ov1 = 0, ov2 = 0; // iterators over common words;\n\t\t\tList<String> commonPOS = new ArrayList<String>(), commonLemmas = new ArrayList<String>();\n\t\t\t// we start two words before first word\n\t\t\tint k1 = occr1.get(ov1) - 2, k2 = occr2.get(ov2) - 2;\n\t\t\tBoolean bReachedCommonWord = false;\n\t\t\twhile (k1 < 0 || k2 < 0) {\n\t\t\t\tk1++;\n\t\t\t\tk2++;\n\t\t\t}\n\t\t\tint k1max = pos1.size() - 1, k2max = pos2.size() - 1;\n\t\t\twhile (k1 <= k1max && k2 <= k2max) {\n\t\t\t\t/*        // first check if the same POS\n        String sim = posManager.similarPOS(pos1.get(k1), pos2.get(k2));\n        String lemmaMatch = lemmaFormManager.matchLemmas(ps, lem1.get(k1),\n            lem2.get(k2), sim);\n\t\t\t\t */      \n\t\t\t\tString sim = null;\n\t\t\t\tList<String> sims = posManager.//similarPOS(pos1.get(k1), pos2.get(k2));\n\t\t\t\t\t\tgeneralize(pos1.get(k1), pos2.get(k2));\n\t\t\t\tif (!sims.isEmpty())\n\t\t\t\t\tsim = sims.get(0);\n\t\t\t\tString lemmaMatch = null;\t\t\n\t\t\t\tList<String> lemmaMatchs = lemmaFormManager.//matchLemmas(ps, \n\t\t\t\t\t\tgeneralize(lem1.get(k1),\n\t\t\t\t\t\t\t\tlem2.get(k2));\n\t\t\t\tif (!lemmaMatchs.isEmpty())\n\t\t\t\t\tlemmaMatch = lemmaMatchs.get(0);\n\t\t\t\tif ((sim != null)\n\t\t\t\t\t\t&& (lemmaMatch == null || (lemmaMatch != null && !lemmaMatch\n\t\t\t\t\t\t.equals(\"fail\")))) {\n\t\t\t\t\tcommonPOS.add(pos1.get(k1));\n\t\t\t\t\t// doing parse tree node generalization\n\t\t\t\t\tList<ParseTreeNode> genRes =  nodeGen.generalize(chunk1.getParseTreeNodes().get(k1), chunk2.getParseTreeNodes().get(k2)); \n\t\t\t\t\tif (genRes.size()==1)\n\t\t\t\t\t\tresults.add(genRes.get(0));\n\t\t\t\t\tif (lemmaMatch != null) {\n\t\t\t\t\t\tcommonLemmas.add(lemmaMatch);\n\t\t\t\t\t\t// System.out.println(\"Added \"+lemmaMatch);\n\t\t\t\t\t\tif (k1 == occr1.get(ov1) && k2 == occr2.get(ov2))\n\t\t\t\t\t\t\tbReachedCommonWord = true; // now we can have different increment\n\t\t\t\t\t\t// opera\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (occr1.size() > ov1 + 1 && occr2.size() > ov2 + 1\n\t\t\t\t\t\t\t\t\t&& k1 == occr1.get(ov1 + 1) && k2 == occr2.get(ov2 + 1)) {\n\t\t\t\t\t\t\t\tov1++;\n\t\t\t\t\t\t\t\tov2++;\n\t\t\t\t\t\t\t\tbReachedCommonWord = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// else\n\t\t\t\t\t\t\t\t// System.err.println(\"Next match reached '\"+lemmaMatch+\n\t\t\t\t\t\t\t// \"' | k1 - k2: \"+k1 + \" \"+k2 +\n\t\t\t\t\t\t\t// \"| occur index ov1-ov2 \"+\n\t\t\t\t\t\t\t// ov1+\" \"+ov2+\n\t\t\t\t\t\t\t// \"| identified positions of match: occr1.get(ov1) - occr2.get(ov1) \"\n\t\t\t\t\t\t\t// +\n\t\t\t\t\t\t\t// occr1.get(ov1) + \" \"+ occr2.get(ov1));\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcommonLemmas.add(\"*\");\n\t\t\t\t\t} // the same parts of speech, proceed to the next word in both\n\t\t\t\t\t// expressions\n\t\t\t\t\tk1++;<fim_middle>// class below has no smell\n"}