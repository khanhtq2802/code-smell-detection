{"text": "<fim_prefix>/*\n * Copyright (c) 2004, 2013, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\npackage sun.tools.jconsole;\n\nimport java.awt.event.KeyEvent;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Modifier;\nimport java.text.MessageFormat;\nimport java.util.Collections;\nimport java.util.IdentityHashMap;\nimport java.util.Map;\nimport java.util.MissingResourceException;\nimport java.util.ResourceBundle;\n\n/**\n * Toolkit that provides resource support for JConsole.\n */\npublic final class Resources {\n    private static Map<String, Integer> MNEMONIC_LOOKUP = Collections\n            .synchronizedMap(new IdentityHashMap<String, Integer>());\n\n    private Resources() {\n        throw new AssertionError();\n    }\n\n    /**\n     * Convenience method for {@link MessageFormat#format(String, Object...)}.\n     *\n     * @param pattern the pattern\n     * @param objects the arguments for the pattern\n     *\n     * @return a formatted string\n     */\n    public static String format(String pattern, Object... arguments) {\n            return MessageFormat.format(pattern, arguments);\n    }\n\n    /**\n     * Returns the mnemonic for a message.\n     *\n     * @param message the message\n     *\n     * @return the mnemonic <code>int</code>\n     */\n    public static int getMnemonicInt(String message) {\n        Integer integer = MNEMONIC_LOOKUP.get(message);\n        if (integer != null) {\n            return integer.intValue();\n        }\n        return 0;\n    }\n\n    /**\n     * Initializes all non-final public static fields in the given class with\n     * messages from a {@link ResourceBundle}.\n     *\n     * @param clazz the class containing the fields\n     */\n    public static void initializeMessages(Class<?> clazz, String rbName) {\n        ResourceBundle rb = null;\n        try {\n            rb = ResourceBundle.getBundle(rbName);\n        } catch (MissingResourceException mre) {\n            // fall through, handled later\n        }\n        for (Field field : clazz.getFields()) {\n            if (isWritableField(field)) {\n                String key = field.getName();\n                String message = getMessage(rb, key);\n                int mnemonicInt = findMnemonicInt(message);\n                message = removeMnemonicAmpersand(message);\n                message = replaceWithPlatformLineFeed(message);\n                setFieldValue(field, message);\n                MNEMONIC_LOOKUP.put(message, mnemonicInt);\n            }\n        }\n    }\n\n    private static boolean isWritableField(Field field) {\n        int modifiers = field.getModifiers();\n        return Modifier.isPublic(modifiers) && Modifier.isStatic(modifiers)\n                && !Modifier.isFinal(modifiers);\n    }\n\n    /**\n     * Returns the message corresponding to the key in the bundle or a text\n     * describing it's missing.\n     *\n     * @param rb the resource bundle\n     * @param key the key\n     *\n     * @return the message\n     */\n    private static String getMessage(ResourceBundle rb, String key) {\n        if (rb == null) {\n            return \"missing resource bundle\";\n        }\n        try {\n            return rb.getString(key);\n        } catch (MissingResourceException mre) {\n            return \"missing message for key = \\\"\" + key\n                    + \"\\\" in resource bundle \";\n        }\n    }\n\n<fim_suffix>    private static void setFieldValue(Field field, String value) {\n        try {\n            field.set(null, value);\n        } catch (IllegalArgumentException | IllegalAccessException e) {\n            throw new Error(\"Unable to access or set message for field \" + field.getName());\n        }\n    }\n\n    /**\n     * Returns a {@link String} where all <code>\\n</code> in the <text> have\n     * been replaced with the line separator for the platform.\n     *\n     * @param text the to be replaced\n     *\n     * @return the replaced text\n     */\n    private static String replaceWithPlatformLineFeed(String text) {\n        return text.replace(\"\\n\", System.getProperty(\"line.separator\"));\n    }\n\n    /**\n     * Removes the mnemonic identifier (<code>&</code>) from a string unless\n     * it's escaped by <code>&&</code> or placed at the end.\n     *\n     * @param message the message\n     *\n     * @return a message with the mnemonic identifier removed\n     */\n    private static String removeMnemonicAmpersand(String message) {\n        StringBuilder s = new StringBuilder();\n        for (int i = 0; i < message.length(); i++) {\n            char current = message.charAt(i);\n            if (current != '&' || i == message.length() - 1\n                    || message.charAt(i + 1) == '&') {\n                s.append(current);\n            }\n        }\n        return s.toString();\n    }\n\n    /**\n     * Finds the mnemonic character in a message.\n     *\n     * The mnemonic character is the first character followed by the first\n     * <code>&</code> that is not followed by another <code>&</code>.\n     *\n     * @return the mnemonic as an <code>int</code>, or <code>0</code> if it\n     *         can't be found.\n     */\n    private static int findMnemonicInt(String s) {\n        for (int i = 0; i < s.length() - 1; i++) {\n            if (s.charAt(i) == '&') {\n                if (s.charAt(i + 1) != '&') {\n                    return lookupMnemonicInt(s.substring(i + 1, i + 2));\n                } else {\n                    i++;\n                }\n            }\n        }\n        return 0;\n    }\n\n    /**\n     * Lookups the mnemonic for a key in the {@link KeyEvent} class.\n     *\n     * @param c the character to lookup\n     *\n     * @return the mnemonic as an <code>int</code>, or <code>0</code> if it\n     *         can't be found.\n     */\n    private static int lookupMnemonicInt(String c) {\n        try {\n            return KeyEvent.class.getDeclaredField(\"VK_\" + c.toUpperCase())\n                    .getInt(null);\n        } catch (IllegalArgumentException | IllegalAccessException\n                | NoSuchFieldException | SecurityException e) {\n            // Missing VK is okay\n            return 0;\n        }\n    }\n}<fim_middle>// function below has no smell\n"}