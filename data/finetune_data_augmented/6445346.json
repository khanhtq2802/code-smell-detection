{"text": "<fim_prefix>        this.yamlConstructors.put(Tag.INT, new ConstructYamlInt());\n        this.yamlConstructors.put(Tag.FLOAT, new ConstructYamlFloat());\n        this.yamlConstructors.put(Tag.BINARY, new ConstructYamlBinary());\n        this.yamlConstructors.put(Tag.TIMESTAMP, new ConstructYamlTimestamp());\n        this.yamlConstructors.put(Tag.OMAP, new ConstructYamlOmap());\n        this.yamlConstructors.put(Tag.PAIRS, new ConstructYamlPairs());\n        this.yamlConstructors.put(Tag.SET, new ConstructYamlSet());\n        this.yamlConstructors.put(Tag.STR, new ConstructYamlStr());\n        this.yamlConstructors.put(Tag.SEQ, new ConstructYamlSeq());\n        this.yamlConstructors.put(Tag.MAP, new ConstructYamlMap());\n        this.yamlConstructors.put(null, undefinedConstructor);\n        this.yamlClassConstructors.put(NodeId.scalar, undefinedConstructor);\n        this.yamlClassConstructors.put(NodeId.sequence, undefinedConstructor);\n        this.yamlClassConstructors.put(NodeId.mapping, undefinedConstructor);\n    }\n    protected void flattenMapping(MappingNode node) {\n        // perform merging only on nodes containing merge node(s)\n        if (node.isMerged()) {\n            node.setValue(mergeNode(node, true, new HashMap<Object, Integer>(),\n                    new ArrayList<NodeTuple>()));\n        }\n    }\n    /**\n     * Does merge for supplied mapping node.\n     * \n     * @param node\n     *            where to merge\n     * @param isPreffered\n     *            true if keys of node should take precedence over others...\n     * @param key2index\n     *            maps already merged keys to index from values\n     * @param values\n     *            collects merged NodeTuple\n     * @return list of the merged NodeTuple (to be set as value for the\n     *         MappingNode)\n     */\n    private List<NodeTuple> mergeNode(MappingNode node, boolean isPreffered,\n            Map<Object, Integer> key2index, List<NodeTuple> values) {\n        List<NodeTuple> nodeValue = node.getValue();\n        // reversed for http://code.google.com/p/snakeyaml/issues/detail?id=139\n        Collections.reverse(nodeValue);\n        for (Iterator<NodeTuple> iter = nodeValue.iterator(); iter.hasNext();) {\n            final NodeTuple nodeTuple = iter.next();\n            final Node keyNode = nodeTuple.getKeyNode();\n            final Node valueNode = nodeTuple.getValueNode();\n            if (keyNode.getTag().equals(Tag.MERGE)) {\n                iter.remove();\n                switch (valueNode.getNodeId()) {\n                case mapping:\n                    MappingNode mn = (MappingNode) valueNode;\n                    mergeNode(mn, false, key2index, values);\n                    break;\n                case sequence:\n                    SequenceNode sn = (SequenceNode) valueNode;\n                    List<Node> vals = sn.getValue();\n                    for (Node subnode : vals) {\n                        if (!(subnode instanceof MappingNode)) {\n                            throw new ConstructorException(\"while constructing a mapping\",\n                                    node.getStartMark(),\n                                    \"expected a mapping for merging, but found \"\n                                            + subnode.getNodeId(), subnode.getStartMark());\n                        }\n                        MappingNode mnode = (MappingNode) subnode;\n                        mergeNode(mnode, false, key2index, values);\n                    }\n                    break;\n                default:\n                    throw new ConstructorException(\"while constructing a mapping\",\n                            node.getStartMark(),\n                            \"expected a mapping or list of mappings for merging, but found \"\n                                    + valueNode.getNodeId(), valueNode.getStartMark());\n                }\n            } else {\n                // we need to construct keys to avoid duplications\n                Object key = constructObject(keyNode);\n                if (!key2index.containsKey(key)) { // 1st time merging key\n                    values.add(nodeTuple);\n                    // keep track where tuple for the key is\n                    key2index.put(key, values.size() - 1);\n                } else if (isPreffered) { // there is value for the key, but we\n                                          // need to override it\n                    // change value for the key using saved position\n                    values.set(key2index.get(key), nodeTuple);\n                }\n            }\n        }\n        return values;\n    }\n    protected void constructMapping2ndStep(MappingNode node, Map<Object, Object> mapping) {\n        flattenMapping(node);\n        super.constructMapping2ndStep(node, mapping);\n    }\n    @Override\n    protected void constructSet2ndStep(MappingNode node, java.util.Set<Object> set) {\n        flattenMapping(node);\n        super.constructSet2ndStep(node, set);\n    }\n    public class ConstructYamlNull extends AbstractConstruct {\n        public Object construct(Node node) {\n            constructScalar((ScalarNode) node);\n            return null;\n        }\n    }\n    private final static Map<String, Boolean> BOOL_VALUES = new HashMap<String, Boolean>();\n    static {\n        BOOL_VALUES.put(\"yes\", Boolean.TRUE);\n        BOOL_VALUES.put(\"no\", Boolean.FALSE);\n        BOOL_VALUES.put(\"true\", Boolean.TRUE);\n        BOOL_VALUES.put(\"false\", Boolean.FALSE);\n        BOOL_VALUES.put(\"on\", Boolean.TRUE);\n        BOOL_VALUES.put(\"off\", Boolean.FALSE);\n    }\n    public class ConstructYamlBool extends AbstractConstruct {\n        public Object construct(Node node) {\n            String val = (String) constructScalar((ScalarNode) node);\n            return BOOL_VALUES.get(val.toLowerCase());\n        }\n    }\n    public class ConstructYamlInt extends AbstractConstruct {\n        public Object construct(Node node) {\n            String value = constructScalar((ScalarNode) node).toString().replaceAll(\"_\", \"\");\n            int sign = +1;\n            char first = value.charAt(0);\n            if (first == '-') {\n                sign = -1;\n                value = value.substring(1);\n            } else if (first == '+') {\n                value = value.substring(1);\n            }\n            int base = 10;\n            if (\"0\".equals(value)) {\n                return Integer.valueOf(0);\n            } else if (value.startsWith(\"0b\")) {\n                value = value.substring(2);\n                base = 2;\n            } else if (value.startsWith(\"0x\")) {\n                value = value.substring(2);\n                base = 16;\n            } else if (value.startsWith(\"0\")) {\n                value = value.substring(1);\n                base = 8;\n            } else if (value.indexOf(':') != -1) {\n                String[] digits = value.split(\":\");\n                int bes = 1;\n                int val = 0;\n                for (int i = 0, j = digits.length; i < j; i++) {\n                    val += (Long.parseLong(digits[(j - i) - 1]) * bes);\n                    bes *= 60;\n                }\n                return createNumber(sign, String.valueOf(val), 10);\n            } else {\n                return createNumber(sign, value, 10);\n            }\n            return createNumber(sign, value, base);\n        }\n    }\n    private Number createNumber(int sign, String number, int radix) {\n        Number result;\n        if (sign < 0) {\n            number = \"-\" + number;\n        }\n        try {\n            result = Integer.valueOf(number, radix);\n        } catch (NumberFormatException e) {\n            try {\n                result = Long.valueOf(number, radix);\n            } catch (NumberFormatException e1) {\n                result = new BigInteger(number, radix);\n            }\n        }\n        return result;\n    }\n<fim_suffix>    public class ConstructYamlFloat extends AbstractConstruct {\n        public Object construct(Node node) {\n            String value = constructScalar((ScalarNode) node).toString().replaceAll(\"_\", \"\");\n            int sign = +1;\n            char first = value.charAt(0);\n            if (first == '-') {\n                sign = -1;\n                value = value.substring(1);\n            } else if (first == '+') {\n                value = value.substring(1);\n            }\n            String valLower = value.toLowerCase();\n            if (\".inf\".equals(valLower)) {\n                return new Double(sign == -1 ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n            } else if (\".nan\".equals(valLower)) {\n                return new Double(Double.NaN);\n            } else if (value.indexOf(':') != -1) {\n                String[] digits = value.split(\":\");\n                int bes = 1;\n                double val = 0.0;\n                for (int i = 0, j = digits.length; i < j; i++) {\n                    val += (Double.parseDouble(digits[(j - i) - 1]) * bes);\n                    bes *= 60;\n                }\n                return new Double(sign * val);\n            } else {\n                Double d = Double.valueOf(value);\n                return new Double(d.doubleValue() * sign);\n            }\n        }\n    }<fim_middle>// class below has no smell\n"}