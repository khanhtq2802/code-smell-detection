{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the  \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/*\n * $Id: IntStack.java 468655 2006-10-28 07:12:06Z minchau $\n */\npackage org.apache.xml.utils;\n\nimport java.util.EmptyStackException;\n\n/**\n * Implement a stack of simple integers.\n *\n * %OPT%\n * This is currently based on IntVector, which permits fast acess but pays a\n * heavy recopying penalty if/when its size is increased. If we expect deep\n * stacks, we should consider a version based on ChunkedIntVector.\n * @xsl.usage internal\n */\npublic class IntStack extends IntVector\n{\n\n  /**\n   * Default constructor.  Note that the default\n   * block size is very small, for small lists.\n   */\n  public IntStack()\n  {\n    super();\n  }\n\n  /**\n   * Construct a IntVector, using the given block size.\n   *\n   * @param blocksize Size of block to allocate\n   */\n  public IntStack(int blocksize)\n  {\n    super(blocksize);\n  }\n  \n  /**\n   * Copy constructor for IntStack\n   * \n   * @param v IntStack to copy\n   */\n  public IntStack (IntStack v)\n  {\n  \tsuper(v);\n  }\n\n  /**\n   * Pushes an item onto the top of this stack.\n   *\n   * @param   i   the int to be pushed onto this stack.\n   * @return  the <code>item</code> argument.\n   */\n  public int push(int i)\n  {\n\n    if ((m_firstFree + 1) >= m_mapSize)\n    {\n      m_mapSize += m_blocksize;\n\n      int newMap[] = new int[m_mapSize];\n\n      System.arraycopy(m_map, 0, newMap, 0, m_firstFree + 1);\n\n      m_map = newMap;\n    }\n\n    m_map[m_firstFree] = i;\n\n    m_firstFree++;\n\n    return i;\n  }\n\n  /**\n   * Removes the object at the top of this stack and returns that\n   * object as the value of this function.\n   *\n   * @return     The object at the top of this stack.\n   */\n  public final int pop()\n  {\n    return m_map[--m_firstFree];\n  }\n\n  /**\n   * Quickly pops a number of items from the stack.\n   */\n\n  public final void quickPop(int n)\n  {\n    m_firstFree -= n;\n  }\n\n  /**\n   * Looks at the object at the top of this stack without removing it\n   * from the stack.\n   *\n   * @return     the object at the top of this stack.\n   * @throws  EmptyStackException  if this stack is empty.\n   */\n  public final int peek()\n  {\n    try {\n      return m_map[m_firstFree - 1];\n    }\n    catch (ArrayIndexOutOfBoundsException e)\n    {\n      throw new EmptyStackException();\n    }\n  }\n\n  /**\n   * Looks at the object at the position the stack counting down n items.\n   *\n   * @param n The number of items down, indexed from zero.\n   * @return     the object at n items down.\n   * @throws  EmptyStackException  if this stack is empty.\n   */\n<fim_suffix>  public int peek(int n)\n  {\n    try {\n      return m_map[m_firstFree-(1+n)];\n    }\n    catch (ArrayIndexOutOfBoundsException e)\n    {\n      throw new EmptyStackException();\n    }\n  }\n\n  /**\n   * Sets an object at a the top of the statck\n   *\n   *\n   * @param val object to set at the top\n   * @throws  EmptyStackException  if this stack is empty.\n   */\n  public void setTop(int val)\n  {\n    try {\n      m_map[m_firstFree - 1] = val;\n    }\n    catch (ArrayIndexOutOfBoundsException e)\n    {\n      throw new EmptyStackException();\n    }\n  }\n\n  /**\n   * Tests if this stack is empty.\n   *\n   * @return  <code>true</code> if this stack is empty;\n   *          <code>false</code> otherwise.\n   * @since   JDK1.0\n   */\n  public boolean empty()\n  {\n    return m_firstFree == 0;\n  }\n\n  /**\n   * Returns where an object is on this stack.\n   *\n   * @param   o   the desired object.\n   * @return  the distance from the top of the stack where the object is]\n   *          located; the return value <code>-1</code> indicates that the\n   *          object is not on the stack.\n   * @since   JDK1.0\n   */\n  public int search(int o)\n  {\n\n    int i = lastIndexOf(o);\n\n    if (i >= 0)\n    {\n      return size() - i;\n    }\n\n    return -1;\n  }\n  \n  /**\n   * Returns clone of current IntStack\n   * \n   * @return clone of current IntStack\n   */\n  public Object clone()\n    throws CloneNotSupportedException\n  {\n  \treturn (IntStack) super.clone();\n  }\n}<fim_middle>// function below has no smell\n"}