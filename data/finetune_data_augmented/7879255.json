{"text": "<fim_prefix>/*\n * Copyright 2015-present Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License. You may obtain\n * a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\n\npackage com.facebook.buck.util.network;\n\nimport com.google.common.base.Objects;\nimport com.google.common.collect.ImmutableCollection;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.util.concurrent.Futures;\nimport com.google.common.util.concurrent.ListenableFuture;\nimport java.util.Optional;\n\n/** Common functionality for uploading log entries in batches. */\n<fim_suffix>public abstract class AbstractBatchingLogger implements BatchingLogger {\n\n  public static final int DEFAULT_MIN_BATCH_SIZE = 1024 * 128; // This is pretty arbitrary.\n\n  protected static class BatchEntry {\n    private final String line;\n\n    public BatchEntry(String line) {\n      this.line = line;\n    }\n\n    public String getLine() {\n      return line;\n    }\n\n    @Override\n    public boolean equals(Object other) {\n      if (!(other instanceof BatchEntry)) {\n        return false;\n      }\n\n      BatchEntry that = (BatchEntry) other;\n      return line.equals(that.line);\n    }\n\n    @Override\n    public int hashCode() {\n      return Objects.hashCode(line);\n    }\n\n    @Override\n    public String toString() {\n      return String.format(\"BatchEntry(%s)\", line);\n    }\n  }\n\n  private ImmutableList.Builder<BatchEntry> batch;\n  private int currentBatchSize;\n  private final int minBatchSize;\n\n  public AbstractBatchingLogger(int minBatchSize) {\n    this.batch = ImmutableList.builder();\n    this.currentBatchSize = 0;\n    this.minBatchSize = minBatchSize;\n  }\n\n  public AbstractBatchingLogger() {\n    this(DEFAULT_MIN_BATCH_SIZE);\n  }\n\n  @Override\n  public Optional<ListenableFuture<Void>> log(String logLine) {\n    batch.add(new BatchEntry(logLine));\n    currentBatchSize += logLine.length();\n    if (currentBatchSize >= minBatchSize) {\n      return Optional.of(sendBatch());\n    }\n    return Optional.empty();\n  }\n\n  @Override\n  public ListenableFuture<Void> forceFlush() {\n    return sendBatch();\n  }\n\n  private ListenableFuture<Void> sendBatch() {\n    ImmutableList<BatchEntry> toSend = batch.build();\n    batch = ImmutableList.builder();\n    currentBatchSize = 0;\n    if (toSend.isEmpty()) {\n      return Futures.immediateFuture(null);\n    } else {\n      return logMultiple(toSend);\n    }\n  }\n\n  protected abstract ListenableFuture<Void> logMultiple(ImmutableCollection<BatchEntry> data);\n}<fim_middle>// class below has no smell\n"}