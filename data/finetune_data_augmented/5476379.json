{"text": "<fim_prefix>/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n */\npackage org.apache.qpid.server.store;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.UUID;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\nimport org.apache.qpid.server.model.ConfiguredObject;\nimport org.apache.qpid.server.store.handler.ConfiguredObjectRecordHandler;\n\npublic abstract class AbstractMemoryStore implements DurableConfigurationStore, MessageStoreProvider\n{\n    private final MessageStore _messageStore = new MemoryMessageStore();\n    private final Class<? extends ConfiguredObject> _rootClass;\n\n    enum State { CLOSED, CONFIGURED, OPEN };\n\n    private State _state = State.CLOSED;\n    private final Object _lock = new Object();\n\n    private final ConcurrentMap<UUID, ConfiguredObjectRecord> _configuredObjectRecords = new ConcurrentHashMap<UUID, ConfiguredObjectRecord>();\n\n    protected AbstractMemoryStore(final Class<? extends ConfiguredObject> rootClass)\n    {\n        _rootClass = rootClass;\n    }\n\n    @Override\n    public void create(ConfiguredObjectRecord record)\n    {\n        assertState(State.OPEN);\n        if (_configuredObjectRecords.putIfAbsent(record.getId(), record) != null)\n        {\n            throw new StoreException(\"Record with id \" + record.getId() + \" is already present\");\n        }\n    }\n\n    @Override\n    public void update(boolean createIfNecessary, ConfiguredObjectRecord... records)\n    {\n        assertState(State.OPEN);\n        for (ConfiguredObjectRecord record : records)\n        {\n            if(createIfNecessary)\n            {\n                _configuredObjectRecords.put(record.getId(), record);\n            }\n            else\n            {\n                ConfiguredObjectRecord previousValue = _configuredObjectRecords.replace(record.getId(), record);\n                if (previousValue == null)\n                {\n                    throw new StoreException(\"Record with id \" + record.getId() + \" does not exist\");\n                }\n            }\n        }\n    }\n\n<fim_suffix>    @Override\n    public UUID[] remove(final ConfiguredObjectRecord... objects)\n    {\n        assertState(State.OPEN);\n        List<UUID> removed = new ArrayList<UUID>();\n        for (ConfiguredObjectRecord record : objects)\n        {\n            if (_configuredObjectRecords.remove(record.getId()) != null)\n            {\n                removed.add(record.getId());\n            }\n        }\n        return removed.toArray(new UUID[removed.size()]);\n    }\n\n    @Override\n    public void init(ConfiguredObject<?> parent)\n    {\n        changeState(State.CLOSED, State.CONFIGURED);\n    }\n\n    @Override\n    public void upgradeStoreStructure() throws StoreException\n    {\n\n    }\n\n    @Override\n    public void closeConfigurationStore()\n    {\n        synchronized (_lock)\n        {\n            _state = State.CLOSED;\n        }\n        _configuredObjectRecords.clear();\n    }\n\n\n    @Override\n    public boolean openConfigurationStore(ConfiguredObjectRecordHandler handler,\n                                          final ConfiguredObjectRecord... initialRecords) throws StoreException\n    {\n        changeState(State.CONFIGURED, State.OPEN);\n        boolean isNew = _configuredObjectRecords.isEmpty();\n        if(isNew)\n        {\n            for(ConfiguredObjectRecord record : initialRecords)\n            {\n                _configuredObjectRecords.put(record.getId(), record);\n            }\n        }\n        for (ConfiguredObjectRecord record : _configuredObjectRecords.values())\n        {\n            handler.handle(record);\n        }\n        return isNew;\n    }\n\n    @Override\n    public void reload(ConfiguredObjectRecordHandler handler) throws StoreException\n    {\n        assertState(State.OPEN);\n        for (ConfiguredObjectRecord record : _configuredObjectRecords.values())\n        {\n            handler.handle(record);\n        }\n    }\n\n\n    @Override\n    public MessageStore getMessageStore()\n    {\n        return _messageStore;\n    }\n\n    @Override\n    public void onDelete(ConfiguredObject<?> parent)\n    {\n    }\n\n    private void assertState(State state)\n    {\n        synchronized (_lock)\n        {\n            if(_state != state)\n            {\n                throw new IllegalStateException(\"The store must be in state \" + state + \" to perform this operation, but it is in state \" + _state + \" instead\");\n            }\n        }\n    }\n\n    private void changeState(State oldState, State newState)\n    {\n        synchronized (_lock)\n        {\n            assertState(oldState);\n            _state = newState;\n        }\n    }\n\n\n    public List<ConfiguredObjectRecord> getConfiguredObjectRecords()\n    {\n        return new ArrayList<>(_configuredObjectRecords.values());\n    }\n\n}<fim_middle>// function below has no smell\n"}