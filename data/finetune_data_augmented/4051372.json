{"text": "<fim_prefix>        if (grpcReadTransformId != null) {\n          // TODO: Handle the case of more than one input.\n          grpcReadTransformId = null;\n          grpcReadTransformOutputName = null;\n          break;\n        }\n        grpcReadTransformId = pTransform.getKey();\n        grpcReadTransformOutputName =\n            Iterables.getOnlyElement(pTransform.getValue().getOutputsMap().keySet());\n      }\n    }\n  }\n  /** Generates a dot description of the process bundle descriptor. */\n  private static String toDot(ProcessBundleDescriptor processBundleDescriptor) {\n    StringBuilder builder = new StringBuilder();\n    builder.append(\"digraph network {\\n\");\n    Map<String, String> nodeName = Maps.newHashMap();\n    processBundleDescriptor\n        .getPcollectionsMap()\n        .forEach((key, node) -> nodeName.put(\"pc \" + key, \"n\" + nodeName.size()));\n    processBundleDescriptor\n        .getTransformsMap()\n        .forEach((key, node) -> nodeName.put(\"pt \" + key, \"n\" + nodeName.size()));\n    for (Entry<String, RunnerApi.PCollection> nodeEntry :\n        processBundleDescriptor.getPcollectionsMap().entrySet()) {\n      builder.append(\n          String.format(\n              \"  %s [fontname=\\\"Courier New\\\" label=\\\"%s\\\"];%n\",\n              nodeName.get(\"pc \" + nodeEntry.getKey()),\n              escapeDot(nodeEntry.getKey() + \": \" + nodeEntry.getValue().getUniqueName())));\n    }\n    for (Entry<String, RunnerApi.PTransform> nodeEntry :\n        processBundleDescriptor.getTransformsMap().entrySet()) {\n      builder.append(\n          String.format(\n              \"  %s [fontname=\\\"Courier New\\\" label=\\\"%s\\\"];%n\",\n              nodeName.get(\"pt \" + nodeEntry.getKey()),\n              escapeDot(\n                  nodeEntry.getKey()\n                      + \": \"\n                      + nodeEntry.getValue().getSpec().getUrn()\n                      + \" \"\n                      + nodeEntry.getValue().getUniqueName())));\n      for (Entry<String, String> inputEntry : nodeEntry.getValue().getInputsMap().entrySet()) {\n        builder.append(\n            String.format(\n                \"  %s -> %s [fontname=\\\"Courier New\\\" label=\\\"%s\\\"];%n\",\n                nodeName.get(\"pc \" + inputEntry.getValue()),\n                nodeName.get(\"pt \" + nodeEntry.getKey()),\n                escapeDot(inputEntry.getKey())));\n      }\n      for (Entry<String, String> outputEntry : nodeEntry.getValue().getOutputsMap().entrySet()) {\n        builder.append(\n            String.format(\n                \"  %s -> %s [fontname=\\\"Courier New\\\" label=\\\"%s\\\"];%n\",\n                nodeName.get(\"pt \" + nodeEntry.getKey()),\n                nodeName.get(\"pc \" + outputEntry.getValue()),\n                escapeDot(outputEntry.getKey())));\n      }\n    }\n    builder.append(\"}\");\n    return builder.toString();\n  }\n  private static String escapeDot(String s) {\n    return s.replace(\"\\\\\", \"\\\\\\\\\")\n        .replace(\"\\\"\", \"\\\\\\\"\")\n        // http://www.graphviz.org/doc/info/attrs.html#k:escString\n        // The escape sequences \"\\n\", \"\\l\" and \"\\r\" divide the label into lines, centered,\n        // left-justified, and right-justified, respectively.\n        .replace(\"\\n\", \"\\\\l\");\n  }\n  /**\n   * Returns an id for the current bundle being processed.\n   *\n   * <p>Generates new id with idGenerator if no id is cached.\n   *\n   * <p><b>Note</b>: This operation could be used across multiple bundles, so a unique id is\n   * generated for every bundle. {@link Operation Operations} accessing the bundle id should only\n   * call this once per bundle and cache the id in the {@link Operation#start()} method and clear it\n   * in the {@link Operation#finish()} method.\n   */\n  public synchronized String getProcessBundleInstructionId() {\n    if (processBundleId == null) {\n      processBundleId = idGenerator.getId();\n    }\n    return processBundleId;\n  }\n  @Override\n  public void start() throws Exception {\n    try (Closeable scope = context.enterStart()) {\n      super.start();\n      // Only register once by using the presence of the future as a signal.\n      if (registerFuture == null) {\n        InstructionRequest request =\n            InstructionRequest.newBuilder()\n                .setInstructionId(idGenerator.getId())\n                .setRegister(registerRequest)\n                .build();\n        registerFuture = instructionRequestHandler.handle(request);\n        getRegisterResponse(registerFuture);\n      }\n      checkState(\n          registerRequest.getProcessBundleDescriptorCount() == 1,\n          \"Only one bundle registration at a time currently supported.\");\n      InstructionRequest processBundleRequest =\n          InstructionRequest.newBuilder()\n              .setInstructionId(getProcessBundleInstructionId())\n              .setProcessBundle(\n                  ProcessBundleRequest.newBuilder()\n                      .setProcessBundleDescriptorReference(\n                          registerRequest.getProcessBundleDescriptor(0).getId()))\n              .build();\n      deregisterStateHandler =\n          beamFnStateDelegator.registerForProcessBundleInstructionId(\n              getProcessBundleInstructionId(), this::delegateByStateKeyType);\n      processBundleResponse = instructionRequestHandler.handle(processBundleRequest);\n    }\n  }\n  @Override\n  public void finish() throws Exception {\n    // TODO: Once we have access to windowing strategy via the ParDoPayload, add support to garbage\n    // collect any user state set. Also add support for consuming those garbage collection timers.\n    try (Closeable scope = context.enterFinish()) {\n      // Await completion or failure\n      BeamFnApi.ProcessBundleResponse completedResponse =\n          MoreFutures.get(getProcessBundleResponse(processBundleResponse));\n      if (completedResponse.getResidualRootsCount() > 0) {\n        throw new IllegalStateException(\n            \"TODO: [BEAM-2939] residual roots in process bundle response not yet supported.\");\n      }\n      deregisterStateHandler.deregister();\n      userStateData.clear();\n      processBundleId = null;\n      super.finish();\n    }\n  }\n  @Override\n  public void abort() throws Exception {\n    try (Closeable scope = context.enterAbort()) {\n      deregisterStateHandler.abort();\n      cancelIfNotNull(registerFuture);\n      cancelIfNotNull(processBundleResponse);\n      super.abort();\n    }\n  }\n  public Map<String, DataflowStepContext> getPtransformIdToUserStepContext() {\n    return ptransformIdToUserStepContext;\n  }\n  /**\n   * Returns the compound metrics recorded, by issuing a request to the SDK harness.\n   *\n   * <p>This includes key progress indicators in {@link BeamFnApi.Metrics.PTransform.Measured} as\n   * well as user-defined metrics in {@link BeamFnApi.Metrics.User}.\n   *\n   * <p>Use {@link #getInputElementsConsumed(BeamFnApi.Metrics)} on the future value to extract the\n   * elements consumed from the upstream read operation.\n   *\n   * <p>May be called at any time, including before start() and after finish().\n   *\n   * @throws InterruptedException\n   * @throws ExecutionException\n   */\n  public CompletionStage<BeamFnApi.ProcessBundleProgressResponse> getProcessBundleProgress()\n      throws InterruptedException, ExecutionException {\n    // processBundleId may be reset if this bundle finishes asynchronously.\n    String processBundleId = this.processBundleId;\n    if (processBundleId == null) {\n      return CompletableFuture.completedFuture(\n          BeamFnApi.ProcessBundleProgressResponse.getDefaultInstance());\n    }\n    InstructionRequest processBundleRequest =\n        InstructionRequest.newBuilder()\n            .setInstructionId(idGenerator.getId())\n            .setProcessBundleProgress(\n                ProcessBundleProgressRequest.newBuilder().setInstructionReference(processBundleId))\n            .build();\n    return instructionRequestHandler\n        .handle(processBundleRequest)\n        .thenApply(\n            response -> {\n              if (!response.getError().isEmpty()) {\n                throw new IllegalStateException(response.getError());\n              }\n              return response.getProcessBundleProgress();\n            });\n  }\n  /** Returns the final metrics returned by the SDK harness when it completes the bundle. */\n  public CompletionStage<BeamFnApi.Metrics> getFinalMetrics() {\n    return getProcessBundleResponse(processBundleResponse)\n        .thenApply(response -> response.getMetrics());\n  }\n  public CompletionStage<List<MonitoringInfo>> getFinalMonitoringInfos() {\n    return getProcessBundleResponse(processBundleResponse)\n        .thenApply(response -> response.getMonitoringInfosList());\n  }\n<fim_suffix>  public boolean hasFailed() throws ExecutionException, InterruptedException {\n    if (processBundleResponse != null && processBundleResponse.toCompletableFuture().isDone()) {\n      return !processBundleResponse.toCompletableFuture().get().getError().isEmpty();\n    } else {\n      // At the very least, we don't know that this has failed yet.\n      return false;\n    }\n  }<fim_middle>// function below has no smell\n"}