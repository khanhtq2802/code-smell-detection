{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.avro.reflect;\nimport java.io.IOException;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.GenericArrayType;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.Parameter;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.IdentityHashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.WeakHashMap;\nimport java.util.concurrent.ConcurrentHashMap;\nimport org.apache.avro.AvroRemoteException;\nimport org.apache.avro.AvroRuntimeException;\nimport org.apache.avro.AvroTypeException;\nimport org.apache.avro.Conversion;\nimport org.apache.avro.JsonProperties;\nimport org.apache.avro.LogicalType;\nimport org.apache.avro.Protocol;\nimport org.apache.avro.Protocol.Message;\nimport org.apache.avro.Schema;\nimport org.apache.avro.generic.GenericContainer;\nimport org.apache.avro.generic.GenericData;\nimport org.apache.avro.generic.GenericFixed;\nimport org.apache.avro.generic.IndexedRecord;\nimport org.apache.avro.io.BinaryData;\nimport org.apache.avro.util.ClassUtils;\nimport org.apache.avro.io.DatumReader;\nimport org.apache.avro.io.DatumWriter;\nimport org.apache.avro.specific.FixedSize;\nimport org.apache.avro.specific.SpecificData;\nimport org.apache.avro.SchemaNormalization;\n/** Utilities to use existing Java classes and interfaces via reflection. */\npublic class ReflectData extends SpecificData {\n  @Override\n  public boolean useCustomCoders() { return false; }\n  /** {@link ReflectData} implementation that permits null field values.  The\n   * schema generated for each field is a union of its declared type and\n   * null. */\n  public static class AllowNull extends ReflectData {\n    private static final AllowNull INSTANCE = new AllowNull();\n    /** Return the singleton instance. */\n    public static AllowNull get() { return INSTANCE; }\n    @Override\n    protected Schema createFieldSchema(Field field, Map<String, Schema> names) {\n      Schema schema = super.createFieldSchema(field, names);\n      if (field.getType().isPrimitive()) {\n        // for primitive values, such as int, a null will result in a\n        // NullPointerException at read time\n        return schema;\n      }\n      return makeNullable(schema);\n    }\n  }\n  private static final ReflectData INSTANCE = new ReflectData();\n  /** For subclasses.  Applications normally use {@link ReflectData#get()}. */\n  public ReflectData() {}\n  /** Construct with a particular classloader. */\n  public ReflectData(ClassLoader classLoader) {\n    super(classLoader);\n  }\n  /** Return the singleton instance. */\n  public static ReflectData get() { return INSTANCE; }\n  /** Cause a class to be treated as though it had an {@link Stringable}\n   ** annotation. */\n  public ReflectData addStringable(Class c) {\n    stringableClasses.add(c);\n    return this;\n  }\n  @Override\n  public DatumReader createDatumReader(Schema schema) {\n    return new ReflectDatumReader(schema, schema, this);\n  }\n  @Override\n  public DatumReader createDatumReader(Schema writer, Schema reader) {\n    return new ReflectDatumReader(writer, reader, this);\n  }\n  @Override\n  public DatumWriter createDatumWriter(Schema schema) {\n    return new ReflectDatumWriter(schema, this);\n  }\n  @Override\n  public void setField(Object record, String name, int position, Object o) {\n    setField(record, name, position, o, null);\n  }\n  @Override\n  protected void setField(Object record, String name, int pos, Object o,\n    Object state) {\n    if (record instanceof IndexedRecord) {\n      super.setField(record, name, pos, o);\n      return;\n    }\n    try {\n      getAccessorForField(record, name, pos, state).set(record, o);\n    } catch (IllegalAccessException | IOException e) {\n      throw new AvroRuntimeException(e);\n    }\n  }\n  @Override\n  public Object getField(Object record, String name, int position) {\n    return getField(record, name, position, null);\n  }\n  @Override\n  protected Object getField(Object record, String name, int pos, Object state) {\n    if (record instanceof IndexedRecord) {\n      return super.getField(record, name, pos);\n    }\n    try {\n      return getAccessorForField(record, name, pos, state).get(record);\n    } catch (IllegalAccessException e) {\n      throw new AvroRuntimeException(e);\n    }\n  }\n  private FieldAccessor getAccessorForField(Object record, String name,\n      int pos, Object optionalState) {\n    if (optionalState != null) {\n      return ((FieldAccessor[])optionalState)[pos];\n    }\n    return getFieldAccessor(record.getClass(), name);\n  }\n  @Override\n  protected boolean isRecord(Object datum) {\n    if (datum == null) return false;\n    if (super.isRecord(datum)) return true;\n    if (datum instanceof Collection) return false;\n    if (datum instanceof Map) return false;\n    if (datum instanceof GenericFixed) return false;\n    return getSchema(datum.getClass()).getType() == Schema.Type.RECORD;\n  }\n  /**\n   * Returns true for arrays and false otherwise, with the following exceptions:\n   * <ul>\n   * <li><p>Returns true for non-string-keyed maps, which are written as an array of key/value pair records.</p></li>\n   * <li><p>Returns false for arrays of bytes, since those should be treated as byte data type instead.</p></li>\n   * </ul>\n   */\n  @Override\n  protected boolean isArray(Object datum) {\n    if (datum == null) return false;\n    Class c = datum.getClass();\n    return (datum instanceof Collection)\n      || (c.isArray() && c.getComponentType() != Byte.TYPE)\n      || isNonStringMap(datum);\n  }\n  @Override\n  protected Collection getArrayAsCollection(Object datum) {\n    return (datum instanceof Map) ? ((Map)datum).entrySet() : (Collection)datum;\n  }\n  @Override\n  protected boolean isBytes(Object datum) {\n    if (datum == null) return false;\n    if (super.isBytes(datum)) return true;\n    Class c = datum.getClass();\n    return c.isArray() && c.getComponentType() == Byte.TYPE;\n  }\n  @Override\n  protected Schema getRecordSchema(Object record) {\n    if (record instanceof GenericContainer)\n      return super.getRecordSchema(record);\n    return getSchema(record.getClass());\n  }\n<fim_suffix>  @Override\n  public boolean validate(Schema schema, Object datum) {\n    switch (schema.getType()) {\n    case ARRAY:\n      if (!datum.getClass().isArray())\n        return super.validate(schema, datum);\n      int length = java.lang.reflect.Array.getLength(datum);\n      for (int i = 0; i < length; i++)\n        if (!validate(schema.getElementType(),\n                      java.lang.reflect.Array.get(datum, i)))\n          return false;\n      return true;\n    default:\n      return super.validate(schema, datum);\n    }\n  }\n  static final ClassValue<ClassAccessorData>\n    ACCESSOR_CACHE = new ClassValue<ClassAccessorData>() {\n      @Override\n      protected ClassAccessorData computeValue(Class<?> c) {\n        if (!IndexedRecord.class.isAssignableFrom(c)){\n          return new ClassAccessorData(c);\n        }\n        return null;\n      }\n  };\n  static class ClassAccessorData {\n    private final Class<?> clazz;\n    private final Map<String, FieldAccessor> byName =\n        new HashMap<>();\n    //getAccessorsFor is already synchronized, no need to wrap<fim_middle>// function below has no smell\n"}