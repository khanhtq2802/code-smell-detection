{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.heron.scheduler.server;\n\nimport java.io.IOException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport com.sun.net.httpserver.HttpExchange;\nimport com.sun.net.httpserver.HttpHandler;\n\nimport org.apache.heron.proto.scheduler.Scheduler;\nimport org.apache.heron.scheduler.utils.Runtime;\nimport org.apache.heron.scheduler.utils.SchedulerUtils;\nimport org.apache.heron.spi.common.Config;\nimport org.apache.heron.spi.scheduler.IScheduler;\nimport org.apache.heron.spi.utils.NetworkUtils;\n\n/**\n * {@code HttpHandler} decorator that returns an OK response unless an exception is caught, in\n * which case a NOTOK response is returned. If the delegate throws a\n * {@code TerminateSchedulerException}, the scheduler will be terminated after the response is\n * handled.\n */\n<fim_suffix>class ExceptionalRequestHandler implements HttpHandler {\n  private static final Logger LOG = Logger.getLogger(ExceptionalRequestHandler.class.getName());\n  private HttpHandler delegate;\n  private Config runtime;\n  private IScheduler scheduler;\n\n  ExceptionalRequestHandler(HttpHandler delegate, Config runtime, IScheduler scheduler) {\n    this.delegate = delegate;\n    this.runtime = runtime;\n    this.scheduler = scheduler;\n  }\n\n  @SuppressWarnings(\"IllegalCatch\")\n  @Override\n  public void handle(HttpExchange exchange) throws IOException {\n\n    try {\n      delegate.handle(exchange);\n      sendResponse(exchange, true);\n    } catch (TerminateSchedulerException e) {\n      sendResponse(exchange, true);\n\n      // tell the scheduler to shutdown\n      LOG.info(\"Request handler issuing a terminate request to scheduler\");\n      try {\n        scheduler.close();\n      } finally {\n        Runtime.schedulerShutdown(runtime).terminate();\n      }\n    } catch (Exception e) {\n      handleFailure(exchange, e);\n    }\n  }\n\n  private static void handleFailure(HttpExchange exchange, Exception e) {\n    LOG.log(Level.SEVERE,\n        String.format(\"Failed to handle %s request\", exchange.getRequestURI()), e);\n    sendResponse(exchange, false);\n  }\n\n  private static void sendResponse(HttpExchange exchange, boolean success) {\n    Scheduler.SchedulerResponse response = SchedulerUtils.constructSchedulerResponse(success);\n    NetworkUtils.sendHttpResponse(exchange, response.toByteArray());\n  }\n}<fim_middle>// class below has no smell\n"}