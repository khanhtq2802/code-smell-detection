{"text": "<fim_prefix> * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.util;\nimport java.io.Closeable;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.StringReader;\nimport java.nio.CharBuffer;\nimport java.nio.channels.Channels;\nimport java.nio.channels.ReadableByteChannel;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetDecoder;\nimport java.nio.charset.IllegalCharsetNameException;\nimport java.nio.charset.UnsupportedCharsetException;\nimport java.util.InputMismatchException;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.NoSuchElementException;\nimport java.util.Objects;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n<fim_suffix>public final class Scanner implements Iterator<String>, Closeable {\n    private static final Map<String, Pattern> CACHE = new LinkedHashMap<String, Pattern>() {\n        @Override\n        protected boolean removeEldestEntry(Entry<String, Pattern> eldest) {\n            return size() >= 7;\n        }\n    };\n    private static final String WHITESPACE_PATTERN = \"\\\\s+\";\n    private static final String FIND_ANY_PATTERN = \"(?s).*\";\n    private static final int BUFFER_SIZE = 1024;\n    private Readable source;\n    private Pattern delimPattern;\n    private Matcher matcher;\n    private CharBuffer buf;\n    private int position;\n    private boolean inputExhausted;\n    private boolean needInput;\n    private boolean skipped;\n    private int savedPosition = -1;\n    private boolean closed;\n    private IOException lastIOException;\n    public Scanner(InputStream source, String charsetName, String pattern) {\n        this(new InputStreamReader(Objects.requireNonNull(source, \"source\"), toDecoder(charsetName)), cachePattern(pattern));\n    }\n    public Scanner(File source, String charsetName, String pattern) throws FileNotFoundException {\n        this(new FileInputStream(Objects.requireNonNull(source, \"source\")).getChannel(), charsetName, pattern);\n    }\n    public Scanner(String source, String pattern) {\n        this(new StringReader(Objects.requireNonNull(source, \"source\")), cachePattern(pattern));\n    }\n    public Scanner(ReadableByteChannel source, String charsetName, String pattern) {\n        this(Channels.newReader(Objects.requireNonNull(source, \"source\"), toDecoder(charsetName), -1), cachePattern(pattern));\n    }\n    public Scanner(Readable source, String pattern) {\n        this(Objects.requireNonNull(source, \"source\"), cachePattern(pattern));\n    }\n    private Scanner(Readable source, Pattern pattern) {\n        this.source = source;\n        delimPattern = pattern != null ? pattern : cachePattern(WHITESPACE_PATTERN);\n        buf = CharBuffer.allocate(BUFFER_SIZE);\n        buf.limit(0);\n        matcher = delimPattern.matcher(buf);\n        matcher.useTransparentBounds(true);\n        matcher.useAnchoringBounds(false);\n    }\n    private static CharsetDecoder toDecoder(String charsetName) {\n        try {\n            Charset cs = charsetName != null ? Charset.forName(charsetName) : Charset.defaultCharset();\n            return cs.newDecoder();\n        } catch (IllegalCharsetNameException | UnsupportedCharsetException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }\n    public boolean hasNext() {\n        checkClosed();\n        saveState();\n        while (!inputExhausted) {\n            if (hasTokenInBuffer()) {\n                revertState();\n                return true;\n            }\n            readMore();\n        }\n        boolean result = hasTokenInBuffer();\n        revertState();\n        return result;\n    }\n    public String next() {\n        checkClosed();\n        while (true) {\n            String token = getCompleteTokenInBuffer();\n            if (token != null) {\n                skipped = false;\n                return token;\n            }\n            if (needInput) {\n                readMore();\n            } else {\n                throwFor();\n            }\n        }\n    }\n    private void saveState() {\n        savedPosition = position;\n    }\n    private void revertState() {\n        position = savedPosition;\n        savedPosition = -1;\n        skipped = false;\n    }\n    private void readMore() {\n        if (buf.limit() == buf.capacity()) {\n            expandBuffer();\n        }\n        int p = buf.position();\n        buf.position(buf.limit());\n        buf.limit(buf.capacity());\n        int n;\n        try {\n            n = source.read(buf);\n        } catch (IOException ioe) {\n            lastIOException = ioe;\n            n = -1;\n        }\n        if (n == -1) {\n            inputExhausted = true;\n            needInput = false;\n        } else if (n > 0) {\n            needInput = false;\n        }\n        buf.limit(buf.position());\n        buf.position(p);\n    }\n    private void expandBuffer() {\n        int offset = savedPosition == -1 ? position : savedPosition;\n        buf.position(offset);\n        if (offset > 0) {\n            buf.compact();\n            translateSavedIndexes(offset);\n            position -= offset;\n            buf.flip();\n        } else {\n            int newSize = buf.capacity() * 2;\n            CharBuffer newBuf = CharBuffer.allocate(newSize);\n            newBuf.put(buf);\n            newBuf.flip();\n            translateSavedIndexes(offset);\n            position -= offset;\n            buf = newBuf;\n            matcher.reset(buf);\n        }\n    }\n    private void translateSavedIndexes(int offset) {\n        if (savedPosition != -1) {\n            savedPosition -= offset;\n        }\n    }\n    private void throwFor() {\n        skipped = false;\n        if (inputExhausted && position == buf.limit()) {\n            throw new NoSuchElementException();\n        } else {\n            throw new InputMismatchException();\n        }\n    }\n    private boolean hasTokenInBuffer() {\n        matcher.usePattern(delimPattern);\n        matcher.region(position, buf.limit());\n        if (matcher.lookingAt()) {\n            position = matcher.end();\n        }\n        return position != buf.limit();\n    }\n    private String getCompleteTokenInBuffer() {\n        matcher.usePattern(delimPattern);\n        if (!skipped) {\n            matcher.region(position, buf.limit());\n            if (matcher.lookingAt()) {\n                if (matcher.hitEnd() && !inputExhausted) {\n                    needInput = true;\n                    return null;\n                }\n                skipped = true;\n                position = matcher.end();\n            }\n        }\n        if (position == buf.limit()) {\n            if (inputExhausted) {\n                return null;\n            }\n            needInput = true;\n            return null;\n        }\n        matcher.region(position, buf.limit());\n        boolean foundNextDelim = matcher.find();\n        if (foundNextDelim && (matcher.end() == position)) {\n            foundNextDelim = matcher.find();\n        }\n        if (foundNextDelim) {\n            if (matcher.requireEnd() && !inputExhausted) {\n                needInput = true;\n                return null;\n            }\n            int tokenEnd = matcher.start();\n            matcher.usePattern(cachePattern(FIND_ANY_PATTERN));\n            matcher.region(position, tokenEnd);\n            if (matcher.matches()) {\n                String s = matcher.group();\n                position = matcher.end();\n                return s;\n            } else {\n                return null;\n            }\n        }\n        if (inputExhausted) {\n            matcher.usePattern(cachePattern(FIND_ANY_PATTERN));\n            matcher.region(position, buf.limit());\n            if (matcher.matches()) {\n                String s = matcher.group();\n                position = matcher.end();\n                return s;\n            }\n            return null;\n        }\n        needInput = true;\n        return null;\n    }\n    private void checkClosed() {\n        if (closed) {\n            throw new IllegalStateException();\n        }\n    }\n    public void close() throws IOException {\n        if (!closed) {\n            closed = true;\n            if (source instanceof Closeable) {\n                try {\n                    ((Closeable) source).close();\n                } catch (IOException e) {\n                    lastIOException = e;\n                }\n            }\n        }\n        if (lastIOException != null) {\n            throw lastIOException;\n        }\n    }\n    private static Pattern cachePattern(String pattern) {\n        if (pattern == null) {\n            return null;\n        }\n        return CACHE.computeIfAbsent(pattern, Pattern::compile);\n    }\n}<fim_middle>// class below has no smell\n"}