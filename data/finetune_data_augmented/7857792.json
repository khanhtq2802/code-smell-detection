{"text": "<fim_prefix>      AtomicLongFieldUpdater.newUpdater(VersionedStatsRegionEntryOffHeapIntKey.class,\n          \"lastModified\");\n  protected int hash;\n  private HashEntry<Object, Object> nextEntry;\n  @SuppressWarnings(\"unused\")\n  private volatile long lastModified;\n  // --------------------------------------- offheap fields ---------------------------------------\n  /**\n   * All access done using OFF_HEAP_ADDRESS_UPDATER so it is used even though the compiler can not\n   * tell it is.\n   */\n  @SuppressWarnings(\"unused\")\n  @Retained\n  @Released\n  private volatile long offHeapAddress;\n  /**\n   * I needed to add this because I wanted clear to call setValue which normally can only be called\n   * while the re is synced. But if I sync in that code it causes a lock ordering deadlock with the\n   * disk regions because they also get a rw lock in clear. Some hardware platforms do not support\n   * CAS on a long. If gemfire is run on one of those the AtomicLongFieldUpdater does a sync on the\n   * RegionEntry and we will once again be deadlocked. I don't know if we support any of the\n   * hardware platforms that do not have a 64bit CAS. If we do then we can expect deadlocks on disk\n   * regions.\n   */\n  private static final AtomicLongFieldUpdater<VersionedStatsRegionEntryOffHeapIntKey> OFF_HEAP_ADDRESS_UPDATER =\n      AtomicLongFieldUpdater.newUpdater(VersionedStatsRegionEntryOffHeapIntKey.class,\n          \"offHeapAddress\");\n  // --------------------------------------- stats fields -----------------------------------------\n  private volatile long lastAccessed;\n  private volatile int hitCount;\n  private volatile int missCount;\n  private static final AtomicIntegerFieldUpdater<VersionedStatsRegionEntryOffHeapIntKey> HIT_COUNT_UPDATER =\n      AtomicIntegerFieldUpdater.newUpdater(VersionedStatsRegionEntryOffHeapIntKey.class,\n          \"hitCount\");\n  private static final AtomicIntegerFieldUpdater<VersionedStatsRegionEntryOffHeapIntKey> MISS_COUNT_UPDATER =\n      AtomicIntegerFieldUpdater.newUpdater(VersionedStatsRegionEntryOffHeapIntKey.class,\n          \"missCount\");\n  // ------------------------------------- versioned fields ---------------------------------------\n  // DO NOT modify this class. It was generated from LeafRegionEntry.cpp\n  private VersionSource memberId;\n  private short entryVersionLowBytes;\n  private short regionVersionHighBytes;\n  private int regionVersionLowBytes;\n  private byte entryVersionHighByte;\n  private byte distributedSystemId;\n  // --------------------------------------- key fields -------------------------------------------\n  // DO NOT modify this class. It was generated from LeafRegionEntry.cpp\n  private final int key;\n  public VersionedStatsRegionEntryOffHeapIntKey(final RegionEntryContext context, final int key,\n      @Retained final Object value) {\n    super(context, value);\n    // DO NOT modify this class. It was generated from LeafRegionEntry.cpp\n    this.key = key;\n  }\n  // DO NOT modify this class. It was generated from LeafRegionEntry.cpp\n  @Override\n  public Token getValueAsToken() {\n    return OffHeapRegionEntryHelper.getValueAsToken(this);\n  }\n  @Override\n  protected Object getValueField() {\n    return OffHeapRegionEntryHelper._getValue(this);\n  }\n  // DO NOT modify this class. It was generated from LeafRegionEntry.cpp\n  @Override\n  @Unretained\n  protected void setValueField(@Unretained final Object value) {\n    OffHeapRegionEntryHelper.setValue(this, value);\n  }\n  @Override\n  @Retained\n  public Object getValueRetain(final RegionEntryContext context, final boolean decompress) {\n    return OffHeapRegionEntryHelper._getValueRetain(this, decompress, context);\n  }\n  @Override\n  public long getAddress() {\n    return OFF_HEAP_ADDRESS_UPDATER.get(this);\n  }\n  @Override\n  public boolean setAddress(final long expectedAddress, long newAddress) {\n    return OFF_HEAP_ADDRESS_UPDATER.compareAndSet(this, expectedAddress, newAddress);\n  }\n  @Override\n  @Released\n  public void release() {\n    OffHeapRegionEntryHelper.releaseEntry(this);\n  }\n  @Override\n  public void returnToPool() {\n    // never implemented\n  }\n  @Override\n  protected long getLastModifiedField() {\n    return LAST_MODIFIED_UPDATER.get(this);\n  }\n  @Override\n  protected boolean compareAndSetLastModifiedField(final long expectedValue, final long newValue) {\n    return LAST_MODIFIED_UPDATER.compareAndSet(this, expectedValue, newValue);\n  }\n  @Override\n  public int getEntryHash() {\n    return this.hash;\n  }\n  @Override\n  protected void setEntryHash(final int hash) {\n    this.hash = hash;\n  }\n  @Override\n  public HashEntry<Object, Object> getNextEntry() {\n    return this.nextEntry;\n  }\n  @Override\n  public void setNextEntry(final HashEntry<Object, Object> nextEntry) {\n    this.nextEntry = nextEntry;\n  }\n  // ---------------------------------------- stats code ------------------------------------------\n  // DO NOT modify this class. It was generated from LeafRegionEntry.cpp\n  @Override\n  public void updateStatsForGet(final boolean isHit, final long time) {\n    setLastAccessed(time);\n    if (isHit) {\n      incrementHitCount();\n    } else {\n      incrementMissCount();\n    }\n  }\n  @Override\n  protected void setLastModifiedAndAccessedTimes(final long lastModified, final long lastAccessed) {\n    _setLastModified(lastModified);\n    if (!DISABLE_ACCESS_TIME_UPDATE_ON_PUT) {\n      setLastAccessed(lastAccessed);\n    }\n  }\n  @Override\n  public long getLastAccessed() throws InternalStatisticsDisabledException {\n    return this.lastAccessed;\n  }\n  @Override\n  public void setLastAccessed(final long lastAccessed) {\n    this.lastAccessed = lastAccessed;\n  }\n  @Override\n  public long getHitCount() throws InternalStatisticsDisabledException {\n    return this.hitCount & 0xFFFFFFFFL;\n  }\n  @Override\n  public long getMissCount() throws InternalStatisticsDisabledException {\n    return this.missCount & 0xFFFFFFFFL;\n  }\n  private void incrementHitCount() {\n    HIT_COUNT_UPDATER.incrementAndGet(this);\n  }\n  private void incrementMissCount() {\n    MISS_COUNT_UPDATER.incrementAndGet(this);\n  }\n  @Override\n  public void resetCounts() throws InternalStatisticsDisabledException {\n    HIT_COUNT_UPDATER.set(this, 0);\n    MISS_COUNT_UPDATER.set(this, 0);\n  }\n  // DO NOT modify this class. It was generated from LeafRegionEntry.cpp\n  @Override\n  public void txDidDestroy(long timeStamp) {\n    setLastModified(timeStamp);\n    setLastAccessed(timeStamp);\n    this.hitCount = 0;\n    this.missCount = 0;\n  }\n  @Override\n  public boolean hasStats() {\n    return true;\n  }\n  // -------------------------------------- versioned code ----------------------------------------\n  // DO NOT modify this class. It was generated from LeafRegionEntry.cpp\n  @Override\n  public int getEntryVersion() {\n    return ((entryVersionHighByte << 16) & 0xFF0000) | (entryVersionLowBytes & 0xFFFF);\n  }\n  @Override\n  public long getRegionVersion() {\n    return (((long) regionVersionHighBytes) << 32) | (regionVersionLowBytes & 0x00000000FFFFFFFFL);\n  }\n  @Override\n  public long getVersionTimeStamp() {\n    return getLastModified();\n  }\n  @Override\n  public void setVersionTimeStamp(final long timeStamp) {\n    setLastModified(timeStamp);\n  }\n  @Override\n  public VersionSource getMemberID() {\n    return this.memberId;\n  }\n  @Override\n  public int getDistributedSystemId() {\n    return this.distributedSystemId;\n  }\n  // DO NOT modify this class. It was generated from LeafRegionEntry.cpp\n<fim_suffix>  @Override\n  public void setVersions(final VersionTag versionTag) {\n    this.memberId = versionTag.getMemberID();\n    int eVersion = versionTag.getEntryVersion();\n    this.entryVersionLowBytes = (short) (eVersion & 0xffff);\n    this.entryVersionHighByte = (byte) ((eVersion & 0xff0000) >> 16);\n    this.regionVersionHighBytes = versionTag.getRegionVersionHighBytes();\n    this.regionVersionLowBytes = versionTag.getRegionVersionLowBytes();\n    if (!versionTag.isGatewayTag()\n        && this.distributedSystemId == versionTag.getDistributedSystemId()) {\n      if (getVersionTimeStamp() <= versionTag.getVersionTimeStamp()) {\n        setVersionTimeStamp(versionTag.getVersionTimeStamp());\n      } else {\n        versionTag.setVersionTimeStamp(getVersionTimeStamp());\n      }\n    } else {\n      setVersionTimeStamp(versionTag.getVersionTimeStamp());\n    }\n    this.distributedSystemId = (byte) (versionTag.getDistributedSystemId() & 0xff);\n  }<fim_middle>// function below is long method\n"}