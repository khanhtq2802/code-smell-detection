{"text": "<fim_prefix>/*******************************************************************************\n * Copyright (c) 2015 Sebastien Arod and others.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *    Sebastien Arod - Initial implementation\n *******************************************************************************/\npackage org.eclipse.tycho.versions.bundle;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Enumeration;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.regex.Pattern;\n\nimport org.eclipse.osgi.util.ManifestElement;\nimport org.osgi.framework.BundleException;\nimport org.osgi.framework.Constants;\n\n/**\n * This class is similar to {@link ManifestElement} but supports changing value for attributes with\n * a single value.\n * \n */\n<fim_suffix>public class MutableManifestElement {\n\n    private enum ParameterType {\n        DIRECTIVE(\":=\"), ATTRIBUTE(\"=\");\n\n        public final String separator;\n\n        ParameterType(String separator) {\n            this.separator = separator;\n        }\n\n    }\n\n    /**\n     * See extended definition in osgi core spec at paragraph 1.3.2 General Syntax Definitions\n     */\n    private static final Pattern OSGI_EXTENDED_PATTERN = Pattern.compile(\"([a-zA-Z0-9_-]|\\\\+)+\");\n\n    private static final String DIRECTIVE_INDENT = \"  \";\n    private static final String VALUE_COMPONENT_INDENT = \"   \";\n\n    private static final int NO_WRAP = Integer.MAX_VALUE;\n\n    private static final String XFRIENDS_DIRECTIVE = \"x-friends\";\n\n    private static final int DEFAULT_WRAP_FOR_LONG_DIRECTIVES = 3;\n\n    private final String value;\n\n    // Use LinkedHashMap to preserve original order\n    private final LinkedHashMap<String, List<String>> directives;\n\n    // Use LinkedHashMap to preserve original order\n    private final LinkedHashMap<String, List<String>> attributes;\n\n    public MutableManifestElement(String value, Map<String, String> attributes, Map<String, String> directives) {\n        this.value = value;\n        this.attributes = toMapOfSingletonLists(attributes);\n        this.directives = toMapOfSingletonLists(directives);\n    }\n\n    private LinkedHashMap<String, List<String>> toMapOfSingletonLists(Map<String, String> params) {\n        LinkedHashMap<String, List<String>> withSingletonLists = new LinkedHashMap<>();\n        for (Map.Entry<String, String> param : params.entrySet()) {\n            withSingletonLists.put(param.getKey(), Collections.singletonList(param.getValue()));\n        }\n        return withSingletonLists;\n    }\n\n    private MutableManifestElement(ManifestElement manifestElement) {\n        // FIXME should we keep support for duplicate directives/attributes this does not seem to be valid OSGI and adds useless complexity.        \n        this.value = manifestElement.getValue();\n        this.attributes = new LinkedHashMap<>();\n        this.directives = new LinkedHashMap<>();\n\n        Enumeration<String> attrKeys = manifestElement.getKeys();\n        if (attrKeys != null) {\n            while (attrKeys.hasMoreElements()) {\n                String attrKey = attrKeys.nextElement();\n                this.attributes.put(attrKey, Arrays.asList(manifestElement.getAttributes(attrKey)));\n            }\n        }\n        Enumeration<String> directiveKeys = manifestElement.getDirectiveKeys();\n        if (directiveKeys != null) {\n            while (directiveKeys.hasMoreElements()) {\n                String directiveName = directiveKeys.nextElement();\n                this.directives.put(directiveName, Arrays.asList(manifestElement.getDirectives(directiveName)));\n            }\n        }\n    }\n\n    public static List<MutableManifestElement> parseHeader(String name, String value) throws BundleException {\n        ManifestElement[] manifestElements = ManifestElement.parseHeader(name, value);\n        if (manifestElements == null) {\n            return null;\n        }\n        List<MutableManifestElement> mutableManifestElements = new ArrayList<>();\n        for (ManifestElement manifestElement : manifestElements) {\n            mutableManifestElements.add(new MutableManifestElement(manifestElement));\n        }\n        return mutableManifestElements;\n    }\n\n    /**\n     * \n     * @return\n     * @see ManifestElement#getValue()\n     */\n    public String getValue() {\n        return value;\n    }\n\n    /**\n     * Set the value for the specified attribute. If previous values existed they are replaced.\n     * \n     * @param key\n     * @param value\n     * @return returns true if the manifest element changed due to this call. false if the value was\n     *         already the same.\n     */\n    public boolean setAttribute(String key, String value) {\n        if (value == null) {\n            if (attributes.containsKey(key)) {\n                attributes.remove(key);\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            List<String> newValue = Collections.singletonList(value);\n            if (!newValue.equals(attributes.get(key))) {\n                attributes.put(key, Collections.singletonList(value));\n                return true;\n            } else {\n                return false;\n            }\n        }\n    }\n\n    /**\n     * Returns the value for the specified attribute or <code>null</code> if it does not exist. If\n     * the attribute has multiple values specified then the last value specified is returned.\n     * \n     * @param key\n     * @return\n     * @see ManifestElement#getAttribute(String)\n     */\n    public String getAttribute(String key) {\n        List<String> values = attributes.get(key);\n        if (values != null && !values.isEmpty()) {\n            return values.get(values.size() - 1);\n        }\n        return null;\n    }\n\n    @Override\n    public String toString() {\n        return write();\n    }\n\n    public String write() {\n        if (directives.isEmpty() && attributes.isEmpty()) {\n            return value;\n        }\n        StringBuilder builder = new StringBuilder(value);\n\n        // Write attributes\n        for (Entry<String, List<String>> attribute : attributes.entrySet()) {\n            for (String attributeValue : attribute.getValue()) {\n                builder.append(writeParameter(attribute.getKey(), attributeValue, ParameterType.ATTRIBUTE, NO_WRAP));\n            }\n        }\n\n        // Write directives\n        // Follow the formatting of PDE for special directives \"uses\" and \"x-friends\" \n        // see org.eclipse.pde.internal.core.text.bundle.ExportPackageObject.appendValuesToBuffer(StringBuffer, TreeMap<String, Serializable>)\n        List<String> uses = directives.get(Constants.USES_DIRECTIVE);\n        List<String> xfriends = directives.get(XFRIENDS_DIRECTIVE);\n\n        for (Entry<String, List<String>> directive : directives.entrySet()) {\n            String directiveName = directive.getKey();\n            if (!directiveName.equals(Constants.USES_DIRECTIVE) && !directiveName.equals(XFRIENDS_DIRECTIVE)) {\n                for (String directiveValue : directive.getValue()) {\n                    builder.append(writeParameter(directiveName, directiveValue, ParameterType.DIRECTIVE, NO_WRAP));\n                }\n            }\n        }\n\n        int longDirectiveLimit = DEFAULT_WRAP_FOR_LONG_DIRECTIVES;\n        if (uses != null && xfriends != null) {\n            longDirectiveLimit = 1;\n        }\n\n        if (xfriends != null) {\n            for (String directiveValue : xfriends) {\n                builder.append(writeParameter(XFRIENDS_DIRECTIVE, directiveValue, ParameterType.DIRECTIVE,\n                        longDirectiveLimit));\n            }\n        }\n        if (uses != null) {\n            for (String directiveValue : uses) {\n                builder.append(writeParameter(Constants.USES_DIRECTIVE, directiveValue, ParameterType.DIRECTIVE,\n                        longDirectiveLimit));\n            }\n        }\n\n        return builder.toString();\n    }\n\n    private static String writeParameter(String paramName, String parameterValue, ParameterType paramType,\n            int valueComponentLimit) {\n        String[] valueComponents = ManifestElement.getArrayFromList(parameterValue, \",\");\n        boolean breakLines = valueComponents.length >= valueComponentLimit;\n        StringBuilder builder = new StringBuilder();\n        builder.append(\";\");\n        if (breakLines) {\n            builder.append(\"\\n\" + DIRECTIVE_INDENT);\n        }\n        builder.append(paramName);\n        builder.append(paramType.separator);\n        if (paramValueNeedsQuotes(parameterValue)) {\n            builder.append('\\\"');\n            for (int i = 0; i < valueComponents.length; i++) {\n                builder.append(valueComponents[i]);\n                if (i != valueComponents.length - 1) {\n                    builder.append(\",\");\n                    if (breakLines) {\n                        builder.append(\"\\n\" + VALUE_COMPONENT_INDENT);\n                    }\n                }\n            }\n            builder.append('\\\"');\n        } else {\n            builder.append(parameterValue);\n        }\n        return builder.toString();\n    }\n\n    private static boolean paramValueNeedsQuotes(String value) {\n        return !OSGI_EXTENDED_PATTERN.matcher(value).matches();\n    }\n\n}<fim_middle>// class below has no smell\n"}