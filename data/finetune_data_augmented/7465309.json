{"text": "<fim_prefix>/*\n * Copyright (c) 2007, 2017, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage com.oracle.svm.core.jdk;\nimport static com.oracle.svm.core.annotate.RecomputeFieldValue.Kind.Reset;\nimport static com.oracle.svm.core.snippets.KnownIntrinsics.readHub;\nimport static com.oracle.svm.core.snippets.KnownIntrinsics.unsafeCast;\nimport java.io.File;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.IdentityHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.locks.ReentrantLock;\nimport java.util.function.Predicate;\nimport org.graalvm.compiler.api.replacements.Fold;\nimport org.graalvm.compiler.core.common.SuppressFBWarnings;\nimport org.graalvm.compiler.serviceprovider.GraalUnsafeAccess;\nimport org.graalvm.compiler.word.ObjectAccess;\nimport org.graalvm.compiler.word.Word;\nimport org.graalvm.nativeimage.ImageSingletons;\nimport org.graalvm.nativeimage.Platform;\nimport org.graalvm.nativeimage.Platforms;\nimport org.graalvm.nativeimage.c.function.CFunction;\nimport org.graalvm.nativeimage.c.function.CLibrary;\nimport org.graalvm.nativeimage.c.function.CodePointer;\nimport org.graalvm.word.Pointer;\nimport org.graalvm.word.UnsignedWord;\nimport org.graalvm.word.WordFactory;\nimport com.oracle.svm.core.MonitorSupport;\nimport com.oracle.svm.core.SubstrateOptions;\nimport com.oracle.svm.core.annotate.Alias;\nimport com.oracle.svm.core.annotate.Delete;\nimport com.oracle.svm.core.annotate.KeepOriginal;\nimport com.oracle.svm.core.annotate.NeverInline;\nimport com.oracle.svm.core.annotate.RecomputeFieldValue;\nimport com.oracle.svm.core.annotate.RecomputeFieldValue.CustomFieldValueComputer;\nimport com.oracle.svm.core.annotate.Substitute;\nimport com.oracle.svm.core.annotate.TargetClass;\nimport com.oracle.svm.core.annotate.TargetElement;\nimport com.oracle.svm.core.hub.DynamicHub;\nimport com.oracle.svm.core.log.Log;\nimport com.oracle.svm.core.snippets.KnownIntrinsics;\nimport com.oracle.svm.core.stack.JavaStackWalker;\nimport com.oracle.svm.core.util.VMError;\nimport jdk.vm.ci.meta.MetaAccessProvider;\nimport jdk.vm.ci.meta.ResolvedJavaField;\n<fim_suffix>@TargetClass(java.lang.Object.class)\nfinal class Target_java_lang_Object {\n    @Substitute\n    @TargetElement(name = \"getClass\")\n    private Object getClassSubst() {\n        return readHub(this);\n    }\n    @Substitute\n    @TargetElement(name = \"hashCode\")\n    private int hashCodeSubst() {\n        return System.identityHashCode(this);\n    }\n    @Substitute\n    @TargetElement(name = \"toString\")\n    private String toStringSubst() {\n        return getClass().getName() + \"@\" + Long.toHexString(Word.objectToUntrackedPointer(this).rawValue());\n    }\n    @Substitute\n    @TargetElement(name = \"wait\")\n    private void waitSubst(long timeoutMillis) throws InterruptedException {\n        ImageSingletons.lookup(MonitorSupport.class).wait(this, timeoutMillis);\n    }\n    @Substitute\n    @TargetElement(name = \"notify\")\n    private void notifySubst() {\n        ImageSingletons.lookup(MonitorSupport.class).notify(this, false);\n    }\n    @Substitute\n    @TargetElement(name = \"notifyAll\")\n    private void notifyAllSubst() {\n        ImageSingletons.lookup(MonitorSupport.class).notify(this, true);\n    }\n}\n@TargetClass(className = \"java.lang.ClassLoaderHelper\")\nfinal class Target_java_lang_ClassLoaderHelper {\n    @Alias\n    static native File mapAlternativeName(File lib);\n}\n@TargetClass(java.lang.Enum.class)\nfinal class Target_java_lang_Enum {\n    @Substitute\n    private static Enum<?> valueOf(Class<Enum<?>> enumType, String name) {\n        /*\n         * The original implementation creates and caches a HashMap to make the lookup faster. For\n         * simplicity, we do a linear search for now.\n         */\n        for (Enum<?> e : unsafeCast(enumType, DynamicHub.class).getEnumConstantsShared()) {\n            if (e.name().equals(name)) {\n                return e;\n            }\n        }\n        if (name == null) {\n            throw new NullPointerException(\"Name is null\");\n        } else {\n            throw new IllegalArgumentException(\"No enum constant \" + enumType.getName() + \".\" + name);\n        }\n    }\n}\n@TargetClass(java.lang.String.class)\nfinal class Target_java_lang_String {\n    @Substitute\n    public String intern() {\n        String thisStr = unsafeCast(this, String.class);\n        return ImageSingletons.lookup(StringInternSupport.class).intern(thisStr);\n    }\n}\n@TargetClass(java.lang.Throwable.class)\n@SuppressWarnings({\"unused\"})\nfinal class Target_java_lang_Throwable {\n    @Alias @RecomputeFieldValue(kind = Reset)//\n    private Object backtrace;\n    @Alias @RecomputeFieldValue(kind = Reset)//\n    StackTraceElement[] stackTrace;\n    @Alias String detailMessage;\n    /*\n     * Suppressed exception handling is disabled for now.\n     */\n    @Substitute\n    private void addSuppressed(Throwable exception) {\n        /*\n         * This method is called frequently from try-with-resource blocks. The original\n         * implementation performs allocations, which are problematic when allocations are disabled.\n         * For now, we just do nothing until someone needs suppressed exception handling.\n         */\n    }\n    @Substitute\n    @NeverInline(\"Prevent inlining in Truffle compilations\")\n    private Object fillInStackTrace() {\n        Pointer sp = KnownIntrinsics.readCallerStackPointer();\n        CodePointer ip = KnownIntrinsics.readReturnAddress();\n        StackTraceBuilder stackTraceBuilder = new StackTraceBuilder(true);\n        JavaStackWalker.walkCurrentThread(sp, ip, stackTraceBuilder);\n        this.stackTrace = stackTraceBuilder.getTrace();\n        return this;\n    }\n    @Substitute\n    private StackTraceElement[] getOurStackTrace() {\n        if (stackTrace != null) {\n            return stackTrace;\n        } else {\n            return new StackTraceElement[0];\n        }\n    }\n    @Substitute\n    @TargetElement(onlyWith = JDK8OrEarlier.class)\n    int getStackTraceDepth() {\n        if (stackTrace != null) {\n            return stackTrace.length;\n        }\n        return 0;\n    }\n    @Substitute\n    @TargetElement(onlyWith = JDK8OrEarlier.class)\n    StackTraceElement getStackTraceElement(int index) {<fim_middle>// class below has no smell\n"}