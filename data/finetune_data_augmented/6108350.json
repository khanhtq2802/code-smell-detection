{"text": "<fim_prefix>    public MutableIntList toList()\n    {\n        IntArrayList list = new IntArrayList(this.adapted.length());\n        for (int i = 0; i < this.adapted.length(); )\n        {\n            int codePoint = this.adapted.codePointAt(i);\n            list.add(codePoint);\n            i += Character.charCount(codePoint);\n        }\n        return list;\n    }\n    @Override\n    public MutableIntSet toSet()\n    {\n        IntHashSet set = new IntHashSet(this.adapted.length());\n        for (int i = 0; i < this.adapted.length(); )\n        {\n            int codePoint = this.adapted.codePointAt(i);\n            set.add(codePoint);\n            i += Character.charCount(codePoint);\n        }\n        return set;\n    }\n    @Override\n    public MutableIntBag toBag()\n    {\n        IntHashBag bag = new IntHashBag(this.adapted.length());\n        for (int i = 0; i < this.adapted.length(); )\n        {\n            int codePoint = this.adapted.codePointAt(i);\n            bag.add(codePoint);\n            i += Character.charCount(codePoint);\n        }\n        return bag;\n    }\n    @Override\n    public <T> T injectInto(T injectedValue, ObjectIntToObjectFunction<? super T, ? extends T> function)\n    {\n        T result = injectedValue;\n        for (int i = 0; i < this.adapted.length(); )\n        {\n            int codePoint = this.adapted.codePointAt(i);\n            result = function.valueOf(result, codePoint);\n            i += Character.charCount(codePoint);\n        }\n        return result;\n    }\n    @Override\n    public RichIterable<IntIterable> chunk(int size)\n    {\n        if (size <= 0)\n        {\n            throw new IllegalArgumentException(\"Size for groups must be positive but was: \" + size);\n        }\n        MutableList<IntIterable> result = Lists.mutable.empty();\n        if (this.notEmpty())\n        {\n            if (this.size() <= size)\n            {\n                result.add(IntLists.immutable.withAll(this));\n            }\n            else\n            {\n                IntIterator iterator = this.intIterator();\n                while (iterator.hasNext())\n                {\n                    MutableIntList batch = IntLists.mutable.empty();\n                    for (int i = 0; i < size && iterator.hasNext(); i++)\n                    {\n                        batch.add(iterator.next());\n                    }\n                    result.add(CodePointList.from(batch));\n                }\n            }\n        }\n        return result.toImmutable();\n    }\n    @Override\n    public long sum()\n    {\n        long sum = 0;\n        for (int i = 0; i < this.adapted.length(); )\n        {\n            int codePoint = this.adapted.codePointAt(i);\n            sum += codePoint;\n            i += Character.charCount(codePoint);\n        }\n        return sum;\n    }\n    @Override\n    public int max()\n    {\n        if (this.isEmpty())\n        {\n            throw new NoSuchElementException();\n        }\n        int max = this.get(0);\n        for (int i = 0; i < this.adapted.length(); )\n        {\n            int codePoint = this.adapted.codePointAt(i);\n            if (max < codePoint)\n            {\n                max = codePoint;\n            }\n            i += Character.charCount(codePoint);\n        }\n        return max;\n    }\n    @Override\n    public int min()\n    {\n        if (this.isEmpty())\n        {\n            throw new NoSuchElementException();\n        }\n        int min = this.get(0);\n        for (int i = 0; i < this.adapted.length(); )\n        {\n            int codePoint = this.adapted.codePointAt(i);\n            if (codePoint < min)\n            {\n                min = codePoint;\n            }\n            i += Character.charCount(codePoint);\n        }\n        return min;\n    }\n    @Override\n    public int size()\n    {\n        int size = 0;\n        for (int i = 0; i < this.adapted.length(); )\n        {\n            int codePoint = this.adapted.codePointAt(i);\n            i += Character.charCount(codePoint);\n            size++;\n        }\n        return size;\n    }\n    @Override\n    public void appendString(Appendable appendable, String start, String separator, String end)\n    {\n        try\n        {\n            appendable.append(start);\n            for (int i = 0; i < this.adapted.length(); )\n            {\n                if (i > 0)\n                {\n                    appendable.append(separator);\n                }\n                int codePoint = this.adapted.codePointAt(i);\n                if (appendable instanceof StringBuilder)\n                {\n                    ((StringBuilder) appendable).appendCodePoint(codePoint);\n                }\n                else if (appendable instanceof StringBuffer)\n                {\n                    ((StringBuffer) appendable).appendCodePoint(codePoint);\n                }\n                else\n                {\n                    char[] chars = Character.toChars(codePoint);\n                    for (int j = 0; j < chars.length; j++)\n                    {\n                        appendable.append(chars[j]);\n                    }\n                }\n                i += Character.charCount(codePoint);\n            }\n            appendable.append(end);\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n    @Override\n    public boolean equals(Object otherList)\n    {\n        if (otherList == this)\n        {\n            return true;\n        }\n        if (otherList instanceof CodePointAdapter)\n        {\n            return this.equalsCodePointAdapter((CodePointAdapter) otherList);\n        }\n        if (otherList instanceof IntList)\n        {\n            return this.equalsIntList((IntList) otherList);\n        }\n        return false;\n    }\n    public boolean equalsIntList(IntList list)\n    {\n        int size = 0;\n        for (int i = 0; i < this.adapted.length(); )\n        {\n            size++;\n            int codePoint = this.adapted.codePointAt(i);\n            if (size > list.size() || codePoint != list.get(size - 1))\n            {\n                return false;\n            }\n            i += Character.charCount(codePoint);\n        }\n        if (size < list.size())\n        {\n            return false;\n        }\n        return true;\n    }\n    private boolean equalsCodePointAdapter(CodePointAdapter adapter)\n    {\n        if (this.adapted.length() != adapter.adapted.length())\n        {\n            return false;\n        }\n        for (int i = 0; i < this.adapted.length(); )\n        {\n            int codePoint = this.adapted.codePointAt(i);\n            if (codePoint != adapter.adapted.codePointAt(i))\n            {\n                return false;\n            }\n            i += Character.charCount(codePoint);\n        }\n        return true;\n    }\n    @Override\n    public int hashCode()\n    {\n        int hashCode = 1;\n        for (int i = 0; i < this.adapted.length(); )\n        {\n            int codePoint = this.adapted.codePointAt(i);\n            hashCode = 31 * hashCode + codePoint;\n            i += Character.charCount(codePoint);\n        }\n        return hashCode;\n    }\n    /**\n     * @since 9.1.\n     */\n    @Override\n    public ImmutableList<IntIntPair> zipInt(IntIterable iterable)\n    {\n        int size = this.size();\n        int othersize = iterable.size();\n        MutableList<IntIntPair> target = Lists.mutable.withInitialCapacity(Math.min(size, othersize));\n        IntIterator iterator = iterable.intIterator();\n        for (int i = 0; i < size && i < othersize; i++)\n        {\n            target.add(PrimitiveTuples.pair(this.get(i), iterator.next()));\n        }\n        return target.toImmutable();\n    }\n    /**\n     * @since 9.1.\n     */\n    @Override\n    public <T> ImmutableList<IntObjectPair<T>> zip(Iterable<T> iterable)\n    {\n        int size = this.size();\n        int othersize = Iterate.sizeOf(iterable);\n        MutableList<IntObjectPair<T>> target = Lists.mutable.withInitialCapacity(Math.min(size, othersize));\n        Iterator<T> iterator = iterable.iterator();\n        for (int i = 0; i < size && iterator.hasNext(); i++)\n        {\n            target.add(PrimitiveTuples.pair(this.get(i), iterator.next()));\n        }\n        return target.toImmutable();\n    }\n    private class InternalIntIterator implements IntIterator\n    {\n        /**\n         * Index of element to be returned by subsequent call to next.\n         */\n        private int currentIndex;\n<fim_suffix>        @Override\n        public boolean hasNext()\n        {\n            return this.currentIndex != CodePointAdapter.this.adapted.length();\n        }<fim_middle>// function below has no smell\n"}