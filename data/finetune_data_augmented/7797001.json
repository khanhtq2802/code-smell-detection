{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n * agreements. See the NOTICE file distributed with this work for additional information regarding\n * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n * copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\npackage org.apache.geode.internal.jndi;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.Vector;\nimport javax.naming.Binding;\nimport javax.naming.CompositeName;\nimport javax.naming.Context;\nimport javax.naming.ContextNotEmptyException;\nimport javax.naming.InvalidNameException;\nimport javax.naming.Name;\nimport javax.naming.NameAlreadyBoundException;\nimport javax.naming.NameNotFoundException;\nimport javax.naming.NameParser;\nimport javax.naming.NamingEnumeration;\nimport javax.naming.NamingException;\nimport javax.naming.NoPermissionException;\nimport javax.naming.NotContextException;\nimport javax.transaction.SystemException;\nimport org.apache.geode.LogWriter;\nimport org.apache.geode.annotations.Immutable;\nimport org.apache.geode.internal.jta.TransactionUtils;\nimport org.apache.geode.internal.jta.UserTransactionImpl;\n/**\n * Provides implementation of javax.naming.Context interface. A name in the ContextImpl namespace is\n * a sequence of one or more atomic names, relative to a root initial context. When a name consist\n * of more than one atomic names it is a CompoundName where atomic names are separated with\n * separator character - '/' or '.'. It is possible to use both separator characters in the same\n * name. In such cases any occurrences of '.' are replaced with '/' before parsing. This rule can be\n * altered/modified by making changes in NameParserImpl class.\n *\n */\npublic class ContextImpl implements Context {\n  private static final String ROOT_CONTEXT_NAME = \"ROOT\";\n  // Naming scheme for the ContextImpl.\n  @Immutable\n  private static final NameParser nameParser = new NameParserImpl();\n  /*\n   * Map of objects registered for this context representing the local context\n   */\n  private final Map ctxMaps = Collections.synchronizedMap(new HashMap());\n  // Name of this Context\n  private String ctxName;\n  // Parent Context of this Context\n  private ContextImpl parentCtx;\n  // Shows if this context has been destroyed\n  private boolean isDestroyed;\n  /*\n   * Creates new instance of ContextImpl. @param parentCtx parent context of this context. null if\n   * this is the root context. @param name atomic name for this context\n   */\n  private ContextImpl(ContextImpl parentCtx, String name) {\n    this.parentCtx = parentCtx;\n    this.ctxName = name;\n    this.isDestroyed = false;\n  }\n  /**\n   * Default constructor\n   */\n  public ContextImpl() {\n    // call the constructor with default setting\n    this(null, ROOT_CONTEXT_NAME);\n  }\n  /**\n   * Not implemented\n   *\n   */\n  @Override\n  public Object addToEnvironment(String key, Object value) throws NamingException {\n    throw new NamingException(\n        \"addToEnvironment(String key, Object value) is not implemented\");\n  }\n  /**\n   * Binds object to a name in this context. Intermediate contexts that do not exist will be\n   * created.\n   *\n   * @param name Name of the object to bind\n   * @param obj Object to bind. Can be null.\n   * @throws NoPermissionException if this context has been destroyed.\n   * @throws InvalidNameException if name is empty or is CompositeName that spans more than one\n   *         naming system.\n   * @throws NotContextException if name has more than one atomic name and intermediate atomic name\n   *         is bound to object that is not context.\n   */\n  @Override\n  public void bind(Name name, Object obj) throws NamingException {\n    checkIsDestroyed();\n    // Do not check for already bound name.\n    // Simply replace the existing value.\n    rebind(name, obj);\n  }\n  /**\n   * Binds object to name in this context.\n   *\n   * @param name * name of the object to add\n   * @param obj object to bind\n   * @throws NamingException if naming error occurs\n   *\n   */\n  @Override\n  public void bind(String name, Object obj) throws NamingException {\n    bind(nameParser.parse(name), obj);\n  }\n  /**\n   * Does nothing.\n   */\n  @Override\n  public void close() throws NamingException {}\n  /**\n   * Returns composition of prefix and name .\n   *\n   * @param name name relative to this context\n   * @param prefix name of this context Example: composeName(\"a\",\"b\") : b/a composeName(\"a\",\"\") : a\n   *\n   */\n  @Override\n  public Name composeName(Name name, Name prefix) throws NamingException {\n    checkIsDestroyed();\n    // We do not want to modify any of the parameters (JNDI requirement).\n    // Clone <code> prefix </code> to satisfy the requirement.\n    Name parsedPrefix = getParsedName((Name) prefix.clone());\n    Name parsedName = getParsedName(name);\n    return parsedPrefix.addAll(parsedName);\n  }\n  /**\n   * Returns composition of prefix and name .\n   *\n   * @param name name relative to this context\n   * @param prefix name of this context Example: composeName(\"a\",\"b\") : b/a composeName(\"a\",\"\") : a\n   *\n   */\n<fim_suffix>  @Override\n  public String composeName(String name, String prefix) throws NamingException {\n    checkIsDestroyed();\n    return composeName(nameParser.parse(name), nameParser.parse(prefix)).toString();\n  }\n  /**\n   * Creates subcontext with name, relative to this Context.\n   *\n   * @param name subcontext name.\n   * @return new subcontext named name relative to this context.\n   * @throws NoPermissionException if this context has been destroyed.\n   * @throws InvalidNameException if name is empty or is CompositeName that spans more than one\n   *         naming system.\n   * @throws NameAlreadyBoundException if name is already bound in this Context\n   * @throws NotContextException if any intermediate name from name is not bound to instance of\n   *         javax.naming.Context.\n   *\n   */\n  @Override\n  public Context createSubcontext(Name name) throws NamingException {\n    checkIsDestroyed();\n    Name parsedName = getParsedName(name);\n    if (parsedName.size() == 0 || parsedName.get(0).length() == 0) {\n      throw new InvalidNameException(\n          \"Name can not be empty!\");\n    }\n    String subContextName = parsedName.get(0);\n    Object boundObject = ctxMaps.get(parsedName.get(0));\n    if (parsedName.size() == 1) {\n      // Check if name is already in use\n      if (boundObject == null) {\n        Context subContext = new ContextImpl(this, subContextName);\n        ctxMaps.put(subContextName, subContext);\n        return subContext;\n      } else {\n        throw new NameAlreadyBoundException(\n            String.format(\"Name %s is already bound!\", subContextName));\n      }\n    } else {\n      if (boundObject instanceof Context) {\n        // Let the subcontext create new subcontext\n        // lets consider a scenerio a/b/c\n        // case a/b exists : c will be created\n        // case a exists : b/c will not be created\n        // an exception will be thrown in that case.\n        return ((Context) boundObject).createSubcontext(parsedName.getSuffix(1));\n      } else {\n        throw new NotContextException(String.format(\"Expected Context but found %s\",\n            boundObject));\n      }\n    }\n  }\n  /**\n   * Creates subcontext with name, relative to this Context.\n   *\n   * @param name subcontext name\n   * @return new subcontext named name relative to this context.\n   * @throws NamingException if naming error occurs.\n   *\n   */\n  @Override\n  public Context createSubcontext(String name) throws NamingException {\n    return createSubcontext(nameParser.parse(name));\n  }\n  /**\n   * Destroys subcontext with name name. The subcontext must be empty otherwise\n   * ContextNotEmptyException is thrown. Once a context is destroyed, the instance should not be\n   * used.\n   *\n   * @param name subcontext to destroy\n   * @throws NoPermissionException if this context has been destroyed.\n   * @throws InvalidNameException if name is empty or is CompositeName that spans more than one\n   *         naming system.<fim_middle>// function below has no smell\n"}