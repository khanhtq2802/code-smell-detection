{"text": "<fim_prefix>     * if they have the same arguments after renaming all type\n     * variables of one to corresponding type variables in the other,\n     * where correspondence is by position in the type parameter list.\n     */\n    public boolean hasSameArgs(Type t, Type s) {\n        return hasSameArgs(t, s, true);\n    }\n    public boolean hasSameArgs(Type t, Type s, boolean strict) {\n        return hasSameArgs(t, s, strict ? hasSameArgs_strict : hasSameArgs_nonstrict);\n    }\n    private boolean hasSameArgs(Type t, Type s, TypeRelation hasSameArgs) {\n        return hasSameArgs.visit(t, s);\n    }\n    // where\n        private class HasSameArgs extends TypeRelation {\n            boolean strict;\n            public HasSameArgs(boolean strict) {\n                this.strict = strict;\n            }\n            public Boolean visitType(Type t, Type s) {\n                throw new AssertionError();\n            }\n            @Override\n            public Boolean visitMethodType(MethodType t, Type s) {\n                return s.hasTag(METHOD)\n                    && containsTypeEquivalent(t.argtypes, s.getParameterTypes());\n            }\n            @Override\n            public Boolean visitForAll(ForAll t, Type s) {\n                if (!s.hasTag(FORALL))\n                    return strict ? false : visitMethodType(t.asMethodType(), s);\n                ForAll forAll = (ForAll)s;\n                return hasSameBounds(t, forAll)\n                    && visit(t.qtype, subst(forAll.qtype, forAll.tvars, t.tvars));\n            }\n            @Override\n            public Boolean visitErrorType(ErrorType t, Type s) {\n                return false;\n            }\n        }\n    TypeRelation hasSameArgs_strict = new HasSameArgs(true);\n        TypeRelation hasSameArgs_nonstrict = new HasSameArgs(false);\n    // </editor-fold>\n    // <editor-fold defaultstate=\"collapsed\" desc=\"subst\">\n    public List<Type> subst(List<Type> ts,\n                            List<Type> from,\n                            List<Type> to) {\n        return ts.map(new Subst(from, to));\n    }\n    /**\n     * Substitute all occurrences of a type in `from' with the\n     * corresponding type in `to' in 't'. Match lists `from' and `to'\n     * from the right: If lists have different length, discard leading\n     * elements of the longer list.\n     */\n    public Type subst(Type t, List<Type> from, List<Type> to) {\n        return t.map(new Subst(from, to));\n    }\n    private class Subst extends StructuralTypeMapping<Void> {\n        List<Type> from;\n        List<Type> to;\n        public Subst(List<Type> from, List<Type> to) {\n            int fromLength = from.length();\n            int toLength = to.length();\n            while (fromLength > toLength) {\n                fromLength--;\n                from = from.tail;\n            }\n            while (fromLength < toLength) {\n                toLength--;\n                to = to.tail;\n            }\n            this.from = from;\n            this.to = to;\n        }\n        @Override\n        public Type visitTypeVar(TypeVar t, Void ignored) {\n            for (List<Type> from = this.from, to = this.to;\n                 from.nonEmpty();\n                 from = from.tail, to = to.tail) {\n                if (t.equalsIgnoreMetadata(from.head)) {\n                    return to.head.withTypeVar(t);\n                }\n            }\n            return t;\n        }\n        @Override\n        public Type visitClassType(ClassType t, Void ignored) {\n            if (!t.isCompound()) {\n                return super.visitClassType(t, ignored);\n            } else {\n                Type st = visit(supertype(t));\n                List<Type> is = visit(interfaces(t), ignored);\n                if (st == supertype(t) && is == interfaces(t))\n                    return t;\n                else\n                    return makeIntersectionType(is.prepend(st));\n            }\n        }\n        @Override\n        public Type visitWildcardType(WildcardType t, Void ignored) {\n            WildcardType t2 = (WildcardType)super.visitWildcardType(t, ignored);\n            if (t2 != t && t.isExtendsBound() && t2.type.isExtendsBound()) {\n                t2.type = wildUpperBound(t2.type);\n            }\n            return t2;\n        }\n        @Override\n        public Type visitForAll(ForAll t, Void ignored) {\n            if (Type.containsAny(to, t.tvars)) {\n                //perform alpha-renaming of free-variables in 't'\n                //if 'to' types contain variables that are free in 't'\n                List<Type> freevars = newInstances(t.tvars);\n                t = new ForAll(freevars,\n                               Types.this.subst(t.qtype, t.tvars, freevars));\n            }\n            List<Type> tvars1 = substBounds(t.tvars, from, to);\n            Type qtype1 = visit(t.qtype);\n            if (tvars1 == t.tvars && qtype1 == t.qtype) {\n                return t;\n            } else if (tvars1 == t.tvars) {\n                return new ForAll(tvars1, qtype1) {\n                    @Override\n                    public boolean needsStripping() {\n                        return true;\n                    }\n                };\n            } else {\n                return new ForAll(tvars1, Types.this.subst(qtype1, t.tvars, tvars1)) {\n                    @Override\n                    public boolean needsStripping() {\n                        return true;\n                    }\n                };\n            }\n        }\n    }\n    public List<Type> substBounds(List<Type> tvars,\n                                  List<Type> from,\n                                  List<Type> to) {\n        if (tvars.isEmpty())\n            return tvars;\n        ListBuffer<Type> newBoundsBuf = new ListBuffer<>();\n        boolean changed = false;\n        // calculate new bounds\n        for (Type t : tvars) {\n            TypeVar tv = (TypeVar) t;\n            Type bound = subst(tv.bound, from, to);\n            if (bound != tv.bound)\n                changed = true;\n            newBoundsBuf.append(bound);\n        }\n        if (!changed)\n            return tvars;\n        ListBuffer<Type> newTvars = new ListBuffer<>();\n        // create new type variables without bounds\n        for (Type t : tvars) {\n            newTvars.append(new TypeVar(t.tsym, null, syms.botType,\n                                        t.getMetadata()));\n        }\n        // the new bounds should use the new type variables in place\n        // of the old\n        List<Type> newBounds = newBoundsBuf.toList();\n        from = tvars;\n        to = newTvars.toList();\n        for (; !newBounds.isEmpty(); newBounds = newBounds.tail) {\n            newBounds.head = subst(newBounds.head, from, to);\n        }\n        newBounds = newBoundsBuf.toList();\n        // set the bounds of new type variables to the new bounds\n        for (Type t : newTvars.toList()) {\n            TypeVar tv = (TypeVar) t;\n            tv.bound = newBounds.head;\n            newBounds = newBounds.tail;\n        }\n        return newTvars.toList();\n    }\n    public TypeVar substBound(TypeVar t, List<Type> from, List<Type> to) {\n        Type bound1 = subst(t.bound, from, to);\n        if (bound1 == t.bound)\n            return t;\n        else {\n            // create new type variable without bounds\n            TypeVar tv = new TypeVar(t.tsym, null, syms.botType,\n                                     t.getMetadata());\n            // the new bound should use the new type variable in place\n            // of the old\n            tv.bound = subst(bound1, List.of(t), List.of(tv));\n            return tv;\n        }\n    }\n    // </editor-fold>\n    // <editor-fold defaultstate=\"collapsed\" desc=\"hasSameBounds\">\n    /**\n     * Does t have the same bounds for quantified variables as s?\n     */\n<fim_suffix>    public boolean hasSameBounds(ForAll t, ForAll s) {\n        List<Type> l1 = t.tvars;\n        List<Type> l2 = s.tvars;\n        while (l1.nonEmpty() && l2.nonEmpty() &&\n               isSameType(l1.head.getUpperBound(),\n                          subst(l2.head.getUpperBound(),\n                                s.tvars,\n                                t.tvars))) {\n            l1 = l1.tail;\n            l2 = l2.tail;\n        }\n        return l1.isEmpty() && l2.isEmpty();\n    }<fim_middle>// function below has no smell\n"}