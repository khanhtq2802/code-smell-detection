{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.servicecomb.demo.edge.service.encrypt;\n\nimport java.util.Map;\nimport java.util.concurrent.CompletableFuture;\n\nimport org.apache.servicecomb.demo.edge.authentication.encrypt.Hcr;\nimport org.apache.servicecomb.edge.core.AbstractEdgeDispatcher;\nimport org.apache.servicecomb.edge.core.CompatiblePathVersionMapper;\nimport org.apache.servicecomb.provider.pojo.Invoker;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport io.vertx.core.http.HttpServerRequest;\nimport io.vertx.ext.web.Router;\nimport io.vertx.ext.web.RoutingContext;\nimport io.vertx.ext.web.handler.CookieHandler;\n\npublic class EncryptEdgeDispatcher extends AbstractEdgeDispatcher {\n  private static final Logger LOGGER = LoggerFactory.getLogger(EncryptEdgeDispatcher.class);\n\n  private CompatiblePathVersionMapper versionMapper = new CompatiblePathVersionMapper();\n\n  private Encrypt encrypt = Invoker.createProxy(\"auth\", \"encrypt\", Encrypt.class);\n\n  private String prefix = \"encryptApi\";\n\n  @Override\n  public int getOrder() {\n    return 10000;\n  }\n\n  @Override\n  public void init(Router router) {\n    {\n      String regex = \"/\" + prefix + \"/([^\\\\\\\\/]+)/([^\\\\\\\\/]+)/(.*)\";\n      router.routeWithRegex(regex).handler(CookieHandler.create());\n      router.routeWithRegex(regex).handler(createBodyHandler());\n      router.routeWithRegex(regex).failureHandler(this::onFailure).handler(this::onRequest);\n    }\n  }\n\n  protected void onRequest(RoutingContext context) {\n    HttpServerRequest httpServerRequest = context.request();\n\n    // queryUserId always success\n    CompletableFuture<String> userIdFuture = queryUserId(httpServerRequest);\n    queryHcr(httpServerRequest).thenCombine(userIdFuture, (hcr, userId) -> {\n      // hcr and userId all success\n      routeToBackend(context, hcr, userId);\n      return null;\n    }).whenComplete((v, e) -> {\n      // failed to query hcr\n      if (e != null) {\n        context.response().end(\"failed to query hcr: \" + e.getMessage());\n        return;\n      }\n    });\n  }\n\n  private CompletableFuture<String> queryUserId(HttpServerRequest httpServerRequest) {\n    String serviceToken = httpServerRequest.getParam(\"serviceToken\");\n    if (serviceToken == null) {\n      // no need to query userId\n      return CompletableFuture.completedFuture(null);\n    }\n\n    CompletableFuture<String> future = new CompletableFuture<>();\n    encrypt.queryUserId(serviceToken).whenComplete((userId, e) -> {\n      if (e != null) {\n        // treat as success, just userId is null\n        LOGGER.error(\"Failed to query userId, serviceToken={}.\", serviceToken, e);\n      }\n\n      future.complete(userId);\n    });\n\n    return future;\n  }\n\n  private CompletableFuture<Hcr> queryHcr(HttpServerRequest httpServerRequest) {\n    String hcrId = httpServerRequest.getParam(\"hcrId\");\n    return encrypt.queryHcr(hcrId);\n  }\n\n<fim_suffix>  private void routeToBackend(RoutingContext context, Hcr hcr, String userId) {\n    Map<String, String> pathParams = context.pathParams();\n    String microserviceName = pathParams.get(\"param0\");\n    String pathVersion = pathParams.get(\"param1\");\n    String path = context.request().path().substring(prefix.length() + 1);\n\n    EncryptEdgeInvocation edgeInvocation = new EncryptEdgeInvocation(new EncryptContext(hcr, userId));\n    edgeInvocation.setVersionRule(versionMapper.getOrCreate(pathVersion).getVersionRule());\n\n    edgeInvocation.init(microserviceName, context, path, httpServerFilters);\n    edgeInvocation.edgeInvoke();\n  }\n}<fim_middle>// function below has no smell\n"}