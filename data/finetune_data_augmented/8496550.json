{"text": "<fim_prefix>//\n// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n//\n\npackage com.cloud.utils.fsm;\n\nimport java.util.ArrayList;\nimport java.util.Formatter;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * Specifically, it implements the Moore machine.\n * so someone else can add/modify states easily without regression.\n * business logic anyways.\n *\n * @param <S> state\n * @param <E> event\n */\npublic class StateMachine<S, E> {\n    private final HashMap<S, StateEntry> _states = new HashMap<S, StateEntry>();\n    private final StateEntry _initialStateEntry;\n\n<fim_suffix>    public StateMachine() {\n        _initialStateEntry = new StateEntry(null);\n    }\n\n    public void addTransition(S currentState, E event, S toState) {\n        StateEntry entry = null;\n        if (currentState == null) {\n            entry = _initialStateEntry;\n        } else {\n            entry = _states.get(currentState);\n            if (entry == null) {\n                entry = new StateEntry(currentState);\n                _states.put(currentState, entry);\n            }\n        }\n\n        entry.addTransition(event, toState);\n\n        entry = _states.get(toState);\n        if (entry == null) {\n            entry = new StateEntry(toState);\n            _states.put(toState, entry);\n        }\n        entry.addFromTransition(event, currentState);\n    }\n\n    public Set<E> getPossibleEvents(S s) {\n        StateEntry entry = _states.get(s);\n        return entry.nextStates.keySet();\n    }\n\n    public S getNextState(S s, E e) {\n        StateEntry entry = null;\n        if (s == null) {\n            entry = _initialStateEntry;\n        } else {\n            entry = _states.get(s);\n            assert entry != null : \"Cannot retrieve transitions for state \" + s.toString();\n        }\n\n        return entry.nextStates.get(e);\n    }\n\n    public List<S> getFromStates(S s, E e) {\n        StateEntry entry = _states.get(s);\n        if (entry == null) {\n            return new ArrayList<S>();\n        }\n\n        return entry.prevStates.get(e);\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder str = new StringBuilder(1024);\n        _initialStateEntry.buildString(str);\n        for (StateEntry entry : _states.values()) {\n            entry.buildString(str);\n        }\n        return str.toString();\n    }\n\n    private class StateEntry {\n        public S state;\n        public HashMap<E, S> nextStates;\n        public HashMap<E, List<S>> prevStates;\n\n        public StateEntry(S state) {\n            this.state = state;\n            nextStates = new HashMap<E, S>();\n            prevStates = new HashMap<E, List<S>>();\n        }\n\n        public void addTransition(E e, S s) {\n            assert !nextStates.containsKey(e) : \"State \" + getStateStr() + \" already contains a transition to state \" + nextStates.get(e).toString() + \" via event \" +\n                e.toString() + \".  Please revisit the rule you're adding to state \" + s.toString();\n            nextStates.put(e, s);\n        }\n\n        public void addFromTransition(E e, S s) {\n            List<S> l = prevStates.get(e);\n            if (l == null) {\n                l = new ArrayList<S>();\n                prevStates.put(e, l);\n            }\n\n            assert !l.contains(s) : \"Already contains the from transition \" + e.toString() + \" from state \" + s.toString() + \" to \" + getStateStr();\n            l.add(s);\n        }\n\n        protected String getStateStr() {\n            return state == null ? \"Initial\" : state.toString();\n        }\n\n        public void buildString(StringBuilder str) {\n            str.append(\"State: \").append(getStateStr()).append(\"\\n\");\n            for (Map.Entry<E, S> nextState : nextStates.entrySet()) {\n                str.append(\"  --> Event: \");\n                Formatter format = new Formatter();\n                str.append(format.format(\"%-30s\", nextState.getKey().toString()));\n                str.append(\"----> State: \");\n                str.append(nextState.getValue().toString());\n                str.append(\"\\n\");\n            }\n        }\n    }\n}<fim_middle>// function below has no smell\n"}