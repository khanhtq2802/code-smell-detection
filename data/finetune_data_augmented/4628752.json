{"text": "<fim_prefix>\n<fim_suffix>@GroovyASTTransformation(phase = CompilePhase.CANONICALIZATION)\npublic class SortableASTTransformation extends AbstractASTTransformation {\n    private static final ClassNode MY_TYPE = make(Sortable.class);\n    private static final String MY_TYPE_NAME = \"@\" + MY_TYPE.getNameWithoutPackage();\n    private static final ClassNode COMPARABLE_TYPE = makeClassSafe(Comparable.class);\n    private static final ClassNode COMPARATOR_TYPE = makeClassSafe(Comparator.class);\n    private static final String VALUE = \"value\";\n    private static final String OTHER = \"other\";\n    private static final String THIS_HASH = \"thisHash\";\n    private static final String OTHER_HASH = \"otherHash\";\n    private static final String ARG0 = \"arg0\";\n    private static final String ARG1 = \"arg1\";\n    public void visit(ASTNode[] nodes, SourceUnit source) {\n        init(nodes, source);\n        AnnotationNode annotation = (AnnotationNode) nodes[0];\n        AnnotatedNode parent = (AnnotatedNode) nodes[1];\n        if (parent instanceof ClassNode) {\n            createSortable(annotation, (ClassNode) parent);\n        }\n    }\n    private void createSortable(AnnotationNode anno, ClassNode classNode) {\n        List<String> includes = getMemberStringList(anno, \"includes\");\n        List<String> excludes = getMemberStringList(anno, \"excludes\");\n        boolean reversed = memberHasValue(anno, \"reversed\", true);\n        boolean includeSuperProperties = memberHasValue(anno, \"includeSuperProperties\", true);\n        boolean allNames = memberHasValue(anno, \"allNames\", true);\n        boolean allProperties = !memberHasValue(anno, \"allProperties\", false);\n        if (!checkIncludeExcludeUndefinedAware(anno, excludes, includes, MY_TYPE_NAME)) return;\n        if (!checkPropertyList(classNode, includes, \"includes\", anno, MY_TYPE_NAME, false, includeSuperProperties, allProperties)) return;\n        if (!checkPropertyList(classNode, excludes, \"excludes\", anno, MY_TYPE_NAME, false, includeSuperProperties, allProperties)) return;\n        if (classNode.isInterface()) {\n            addError(MY_TYPE_NAME + \" cannot be applied to interface \" + classNode.getName(), anno);\n        }\n        List<PropertyNode> properties = findProperties(anno, classNode, includes, excludes, allProperties, includeSuperProperties, allNames);\n        implementComparable(classNode);\n        addGeneratedMethod(classNode,\n                \"compareTo\",\n                ACC_PUBLIC,\n                ClassHelper.int_TYPE,\n                params(param(newClass(classNode), OTHER)),\n                ClassNode.EMPTY_ARRAY,\n                createCompareToMethodBody(properties, reversed)\n        );\n        for (PropertyNode property : properties) {\n            createComparatorFor(classNode, property, reversed);\n        }\n        new VariableScopeVisitor(sourceUnit, true).visitClass(classNode);\n    }\n    private static void implementComparable(ClassNode classNode) {\n        if (!classNode.implementsInterface(COMPARABLE_TYPE)) {\n            classNode.addInterface(makeClassSafeWithGenerics(Comparable.class, classNode));\n        }\n    }\n    private static Statement createCompareToMethodBody(List<PropertyNode> properties, boolean reversed) {\n        List<Statement> statements = new ArrayList<Statement>();\n        // if (this.is(other)) return 0;\n        statements.add(ifS(callThisX(\"is\", args(OTHER)), returnS(constX(0))));\n        if (properties.isEmpty()) {\n            // perhaps overkill but let compareTo be based on hashes for commutativity\n            // return this.hashCode() <=> other.hashCode()\n            statements.add(declS(localVarX(THIS_HASH, ClassHelper.Integer_TYPE), callX(varX(\"this\"), \"hashCode\")));\n            statements.add(declS(localVarX(OTHER_HASH, ClassHelper.Integer_TYPE), callX(varX(OTHER), \"hashCode\")));\n            statements.add(returnS(compareExpr(varX(THIS_HASH), varX(OTHER_HASH), reversed)));\n        } else {\n            // int value = 0;\n            statements.add(declS(localVarX(VALUE, ClassHelper.int_TYPE), constX(0)));\n            for (PropertyNode property : properties) {\n                String propName = property.getName();\n                // value = this.prop <=> other.prop;\n                statements.add(assignS(varX(VALUE), compareExpr(propX(varX(\"this\"), propName), propX(varX(OTHER), propName), reversed)));\n                // if (value != 0) return value;\n                statements.add(ifS(neX(varX(VALUE), constX(0)), returnS(varX(VALUE))));\n            }\n            // objects are equal\n            statements.add(returnS(constX(0)));\n        }\n        final BlockStatement body = new BlockStatement();\n        body.addStatements(statements);\n        return body;\n    }\n    private static Statement createCompareMethodBody(PropertyNode property, boolean reversed) {\n        String propName = property.getName();\n        return block(\n                // if (arg0 == arg1) return 0;\n                ifS(eqX(varX(ARG0), varX(ARG1)), returnS(constX(0))),\n                // if (arg0 != null && arg1 == null) return -1;\n                ifS(andX(notNullX(varX(ARG0)), equalsNullX(varX(ARG1))), returnS(constX(-1))),\n                // if (arg0 == null && arg1 != null) return 1;\n                ifS(andX(equalsNullX(varX(ARG0)), notNullX(varX(ARG1))), returnS(constX(1))),\n                // return arg0.prop <=> arg1.prop;\n                returnS(compareExpr(propX(varX(ARG0), propName), propX(varX(ARG1), propName), reversed))\n        );\n    }\n    private static void createComparatorFor(ClassNode classNode, PropertyNode property, boolean reversed) {\n        String propName = StringGroovyMethods.capitalize((CharSequence) property.getName());\n        String className = classNode.getName() + \"$\" + propName + \"Comparator\";\n        ClassNode superClass = makeClassSafeWithGenerics(AbstractComparator.class, classNode);\n        InnerClassNode cmpClass = new InnerClassNode(classNode, className, ACC_PRIVATE | ACC_STATIC, superClass);\n        addGeneratedInnerClass(classNode, cmpClass);\n        addGeneratedMethod(cmpClass,\n                \"compare\",\n                ACC_PUBLIC,\n                ClassHelper.int_TYPE,\n                params(param(newClass(classNode), ARG0), param(newClass(classNode), ARG1)),\n                ClassNode.EMPTY_ARRAY,\n                createCompareMethodBody(property, reversed)\n        );\n        String fieldName = \"this$\" + propName + \"Comparator\";\n        // private final Comparator this$<property>Comparator = new <type>$<property>Comparator();\n        FieldNode cmpField = classNode.addField(\n                fieldName,\n                ACC_STATIC | ACC_FINAL | ACC_PRIVATE | ACC_SYNTHETIC,\n                COMPARATOR_TYPE,\n                ctorX(cmpClass));\n        addGeneratedMethod(classNode,\n                \"comparatorBy\" + propName,\n                ACC_PUBLIC | ACC_STATIC,\n                COMPARATOR_TYPE,\n                Parameter.EMPTY_ARRAY,\n                ClassNode.EMPTY_ARRAY,\n                returnS(fieldX(cmpField))\n        );\n    }\n    private List<PropertyNode> findProperties(AnnotationNode annotation, final ClassNode classNode, final List<String> includes,\n                                              final List<String> excludes, final boolean allProperties,\n                                              final boolean includeSuperProperties, final boolean allNames) {\n        Set<String> names = new HashSet<String>();\n        List<PropertyNode> props = getAllProperties(names, classNode, classNode, true, false, allProperties,\n                false, includeSuperProperties, false, false, allNames, false);\n        List<PropertyNode> properties = new ArrayList<PropertyNode>();\n        for (PropertyNode property : props) {\n            String propertyName = property.getName();\n            if ((excludes != null && excludes.contains(propertyName)) ||\n                    includes != null && !includes.contains(propertyName)) continue;\n            properties.add(property);\n        }\n        for (PropertyNode pNode : properties) {\n            checkComparable(pNode);\n        }\n        if (includes != null) {\n            Comparator<PropertyNode> includeComparator = new Comparator<PropertyNode>() {\n                public int compare(PropertyNode o1, PropertyNode o2) {\n                    return Integer.compare(includes.indexOf(o1.getName()), includes.indexOf(o2.getName()));\n                }\n            };\n            Collections.sort(properties, includeComparator);\n        }\n        return properties;\n    }\n    private void checkComparable(PropertyNode pNode) {<fim_middle>// class below is blob\n"}