{"text": "<fim_prefix>\n<fim_suffix>public class RegisterSetLatticeElement implements ILatticeElement<RegisterSetLatticeElement> {\n  /**\n   * The registers which have been newly tainted throughout a complete native instruction. Set on\n   * native instruction exit edge only.\n   */\n  private ImmutableSet<String> m_nativeNewlyTaintedRegs = ImmutableSet.<String>builder().build();\n  /**\n   * The registers which have been untainted throughout a complete native instruction. Set on native\n   * instruction exit edge only.\n   */\n  private ImmutableSet<String> m_nativeUntaintedRegs = ImmutableSet.<String>builder().build();\n  /**\n   * The registers which have been read throughout a complete native instruction. Set on native\n   * instruction exit edge only.\n   */\n  private ImmutableSet<String> m_nativeReadRegs = ImmutableSet.<String>builder().build();\n  /**\n   * The registers which have been updated throughout a complete native instruction. Set on native\n   * instruction exit edge only.\n   */\n  private ImmutableSet<String> m_nativeUpdatedRegs = ImmutableSet.<String>builder().build();\n  /**\n   * The currently tainted registers.\n   */\n  private final Set<String> m_taintedRegs;\n  /**\n   * The registers that have been added to the \"tainted\" set within this (native, not REIL)\n   * instruction\n   */\n  private final Set<String> m_newlyTaintedRegs;\n  /**\n   * The registers that have been removed from the \"tainted\" set within this (native, not REIL)\n   * instruction.\n   */\n  private final Set<String> m_untaintedRegs;\n  /**\n   * The (tainted) registers which are read in any way or form from this (native, not REIL)\n   * instruction.\n   */\n  private final Set<String> m_readRegs;\n  /**\n   * The (tainted) registers which are written from itself or another already tainted register.\n   */\n  private final Set<String> m_updatedRegs;\n  public RegisterSetLatticeElement() {\n    m_taintedRegs = new TreeSet<String>();\n    m_newlyTaintedRegs = new TreeSet<String>();\n    m_untaintedRegs = new TreeSet<String>();\n    m_readRegs = new TreeSet<String>();\n    m_updatedRegs = new TreeSet<String>();\n  }\n  public RegisterSetLatticeElement(final Set<String> taintedRegs,\n      final Set<String> newlyTaintedRegs, final Set<String> untaintedRegs,\n      final Set<String> readRegs, final Set<String> updatedRegs) {\n    Preconditions.checkNotNull(taintedRegs, \"Error: Tainted registers argument can not be null\");\n    Preconditions.checkNotNull(newlyTaintedRegs,\n        \"Error: Newly tainted registers argument can not be null\");\n    Preconditions\n        .checkNotNull(untaintedRegs, \"Error: Untainted registers argument can not be null\");\n    Preconditions.checkNotNull(readRegs, \"Error: Read registers argument can not be null\");\n    Preconditions.checkNotNull(updatedRegs, \"Error: Updated registers argument can not be null\");\n    m_taintedRegs = new TreeSet<String>(taintedRegs);\n    m_newlyTaintedRegs = new TreeSet<String>(newlyTaintedRegs);\n    m_untaintedRegs = new TreeSet<String>(untaintedRegs);\n    m_readRegs = new TreeSet<String>(readRegs);\n    m_updatedRegs = new TreeSet<String>(updatedRegs);\n  }\n  /**\n   * Initializing constructor to be used for generating the initial\n   * {@link RegisterSetLatticeElement}\n   * \n   * @param register The register which is initially tainted.\n   */\n  public RegisterSetLatticeElement(final String register) {\n    Preconditions.checkNotNull(register, \"Error: Register argument can not be null\");\n    (m_taintedRegs = new TreeSet<String>()).add(register);\n    (m_newlyTaintedRegs = new TreeSet<String>()).add(register);\n    m_untaintedRegs = new TreeSet<String>();\n    m_readRegs = new TreeSet<String>();\n    m_updatedRegs = new TreeSet<String>();\n  }\n  /**\n   * This function clears all REIL temporary registers from a Set of registers.\n   * \n   * @param registerSet The Set of registers where the REIL temporary registers are cleared from.\n   */\n  private static void clearTemporaryRegisters(final Set<String> registerSet) {\n    Sets.filter(registerSet, new Predicate<String>() {\n      @Override\n      public boolean apply(final String register) {\n        return ReilHelpers.isTemporaryRegister(register);\n      }\n    }).clear();\n  }\n  /**\n   * This function copies the state from the input states into the current lattice element.\n   * \n   * @param inputState The Collection of input state to copy the information from.\n   */\n  public void addAll(final Collection<RegisterSetLatticeElement> inputState) {\n    Preconditions.checkNotNull(inputState, \"Error: Input state argument can not be null\");\n    final Set<String> tempNativeNewlyTaintedRegisters = Sets.newHashSet();\n    final Set<String> tempNativeUntaintedRegisters = Sets.newHashSet();\n    final Set<String> tempNativeReadRegisters = Sets.newHashSet();\n    final Set<String> tempNativeUpdatedRegisters = Sets.newHashSet();\n    for (final RegisterSetLatticeElement element : inputState) {\n      tempNativeNewlyTaintedRegisters.addAll(element.m_nativeNewlyTaintedRegs);\n      tempNativeUntaintedRegisters.addAll(element.m_nativeUntaintedRegs);\n      tempNativeReadRegisters.addAll(element.m_nativeReadRegs);\n      tempNativeUpdatedRegisters.addAll(element.m_nativeUpdatedRegs);\n      m_taintedRegs.addAll(element.m_taintedRegs);\n      m_newlyTaintedRegs.addAll(element.m_newlyTaintedRegs);\n      m_untaintedRegs.addAll(element.m_untaintedRegs);\n      m_readRegs.addAll(element.m_readRegs);\n      m_updatedRegs.addAll(element.m_updatedRegs);\n    }\n    m_nativeNewlyTaintedRegs = ImmutableSet.copyOf(tempNativeNewlyTaintedRegisters);\n    m_nativeUntaintedRegs = ImmutableSet.copyOf(tempNativeUntaintedRegisters);\n    m_nativeReadRegs = ImmutableSet.copyOf(tempNativeReadRegisters);\n    m_nativeUpdatedRegs = ImmutableSet.copyOf(tempNativeUpdatedRegisters);\n  }\n  /**\n   * This function adds a register to the set of read registers.\n   * \n   * @param reg The register to be added to the read register set.\n   */\n  public void addReadReg(final String reg) {\n    m_readRegs.add(Preconditions.checkNotNull(reg, \"Error: Register argument can not be null\"));\n  }\n  @Override\n  public RegisterSetLatticeElement copy() {\n    return new RegisterSetLatticeElement(m_taintedRegs, m_newlyTaintedRegs, m_untaintedRegs,\n        m_readRegs, m_updatedRegs);\n  }\n  public Collection<String> getNewlyTaintedRegisters() {\n    return Collections.unmodifiableCollection(m_nativeNewlyTaintedRegs);\n  }\n  public Collection<String> getReadRegisters() {\n    return Collections.unmodifiableCollection(m_nativeReadRegs);\n  }\n  public Collection<String> getTaintedRegisters() {\n    return Collections.unmodifiableCollection(m_taintedRegs);\n  }\n  public Collection<String> getUntaintedRegisters() {\n    return Collections.unmodifiableCollection(m_nativeUntaintedRegs);\n  }\n  public Collection<String> getUpdatedRegisters() {\n    return Collections.unmodifiableCollection(m_nativeUpdatedRegs);\n  }\n  public boolean isSmallerEqual(final RegisterSetLatticeElement other) {\n    Preconditions.checkNotNull(other, \"Error: Other argument can not be null\");\n    final boolean result =\n        other.m_taintedRegs.containsAll(m_taintedRegs)\n            && other.m_newlyTaintedRegs.containsAll(m_newlyTaintedRegs)\n            && other.m_untaintedRegs.containsAll(m_untaintedRegs)\n            && other.m_readRegs.containsAll(m_readRegs)\n            && other.m_updatedRegs.containsAll(m_updatedRegs)\n            && other.m_nativeNewlyTaintedRegs.containsAll(m_nativeNewlyTaintedRegs)\n            && other.m_nativeReadRegs.containsAll(m_nativeReadRegs)\n            && other.m_nativeUntaintedRegs.containsAll(m_nativeUntaintedRegs)\n            && other.m_nativeUpdatedRegs.containsAll(m_nativeUpdatedRegs);\n    return result;\n  }\n  /**\n   * Function to check if any of the registers in a collection is in the current taint set.\n   * \n   * @param registers {@link Collection} of register strings to be checked.\n   * <fim_middle>// class below has no smell\n"}