{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.jackrabbit.core.query.lucene;\n\nimport org.apache.lucene.index.IndexReader;\nimport org.apache.lucene.index.Term;\nimport org.apache.lucene.search.Explanation;\nimport org.apache.lucene.search.Query;\nimport org.apache.lucene.search.Scorer;\nimport org.apache.lucene.search.Searcher;\nimport org.apache.lucene.search.Similarity;\nimport org.apache.lucene.search.Weight;\n\nimport java.io.IOException;\nimport java.util.Set;\n\n/**\n * Implements a query that negates documents of a context query. Documents\n * that matched the context query will not match the <code>NotQuery</code> and\n * Documents that did not match the context query will be selected by this\n * <code>NotQuery</code>.\n */\n@SuppressWarnings(\"serial\")\nclass NotQuery extends Query {\n\n    /**\n     * The context query to invert.\n     */\n    private final Query context;\n\n    /**\n     * The context scorer to invert.\n     */\n    private Scorer contextScorer;\n\n    /**\n     * Creates a new <code>NotQuery</code>.\n     * @param context the context query.\n     */\n    NotQuery(Query context) {\n        this.context = context;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Weight createWeight(Searcher searcher) {\n        return new NotQueryWeight(searcher);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public String toString(String field) {\n        return \"NotQuery\";\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void extractTerms(Set<Term> terms) {\n        context.extractTerms(terms);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Query rewrite(IndexReader reader) throws IOException {\n        Query cQuery = context.rewrite(reader);\n        if (cQuery == context) {\n            return this;\n        } else {\n            return new NotQuery(cQuery);\n        }\n    }\n\n    /**\n     * Implements a weight for this <code>NotQuery</code>.\n     */\n    private class NotQueryWeight extends Weight {\n\n        /**\n         * The searcher to access the index.\n         */\n        private final Searcher searcher;\n\n        /**\n         * Creates a new NotQueryWeight with a searcher.\n         * @param searcher the searcher.\n         */\n        NotQueryWeight(Searcher searcher) {\n            this.searcher = searcher;\n        }\n\n        /**\n         * @inheritDoc\n         */\n        public Query getQuery() {\n            return NotQuery.this;\n        }\n\n        /**\n         * @inheritDoc\n         */\n        public float getValue() {\n            return 1.0f;\n        }\n\n        /**\n         * @inheritDoc\n         */\n        public float sumOfSquaredWeights() throws IOException {\n            return 1.0f;\n        }\n\n        /**\n         * @inheritDoc\n         */\n        public void normalize(float norm) {\n        }\n\n        /**\n         * @inheritDoc\n         */\n        public Scorer scorer(IndexReader reader, boolean scoreDocsInOrder,\n                boolean topScorer) throws IOException {\n            contextScorer = context.weight(searcher).scorer(reader, scoreDocsInOrder, topScorer);\n            if (contextScorer == null) {\n                // context query does not match any node\n                // the inverse is to match all nodes\n                return new MatchAllDocsQuery().createWeight(searcher).scorer(\n                        reader, scoreDocsInOrder, false);\n            }\n            return new NotQueryScorer(reader);\n        }\n\n        /**\n         * @throws UnsupportedOperationException always\n         */\n        public Explanation explain(IndexReader reader, int doc) throws IOException {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    /**\n     * Implements a scorer that inverts the document matches of the context\n     * scorer.\n     */\n    private class NotQueryScorer extends Scorer {\n\n        /**\n         * The index reader.\n         */\n        private final IndexReader reader;\n\n        /**\n         * Current document number.\n         */\n        private int docNo = -1;\n\n        /**\n         * Current document number of the context scorer;\n         */\n        private int contextNo = -1;\n\n        private boolean firstTime = true;\n\n        /**\n         * Creates a new scorer\n         * @param reader\n         */\n        NotQueryScorer(IndexReader reader) {\n            super(Similarity.getDefault());\n            this.reader = reader;\n        }\n\n<fim_suffix>        @Override\n        public int nextDoc() throws IOException {\n            if (docNo == NO_MORE_DOCS) {\n                return docNo;\n            }\n\n            if (firstTime) {\n                firstTime = false;\n                // get first doc of context scorer\n                int docId = contextScorer.nextDoc();\n                if (docId != NO_MORE_DOCS) {\n                    contextNo = docId;\n                }\n            }\n            // move to next candidate\n            do {\n                docNo++;\n            } while (reader.isDeleted(docNo) && docNo < reader.maxDoc());\n\n            // check with contextScorer\n            while (contextNo != -1 && contextNo == docNo) {\n                docNo++;\n                int docId = contextScorer.nextDoc();\n                contextNo = docId == NO_MORE_DOCS ? -1 : docId;\n            }\n            if (docNo >= reader.maxDoc()) {\n                docNo = NO_MORE_DOCS;\n            }\n            return docNo;\n        }\n\n        @Override\n        public int docID() {\n            return docNo;\n        }\n\n        @Override\n        public float score() throws IOException {\n            return 1.0f;\n        }\n\n        @Override\n        public int advance(int target) throws IOException {\n            if (docNo == NO_MORE_DOCS) {\n                return docNo;\n            }\n\n            // optimize in the case of an advance to finish.\n            // see https://issues.apache.org/jira/browse/JCR-3091\n            if (target == NO_MORE_DOCS) {\n                contextScorer.advance(target);\n                docNo = NO_MORE_DOCS;\n                return docNo;\n            }\n\n            if (contextNo != -1 && contextNo < target) {\n                int docId = contextScorer.advance(target);\n                contextNo = docId == NO_MORE_DOCS ? -1 : docId;\n            }\n            docNo = target - 1;\n            return nextDoc();\n        }\n\n    }\n}<fim_middle>// function below has no smell\n"}