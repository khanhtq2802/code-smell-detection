{"text": "<fim_prefix>import org.apache.beam.runners.core.construction.ForwardingPTransform;\nimport org.apache.beam.runners.core.construction.PTransformReplacements;\nimport org.apache.beam.runners.core.construction.PTransformTranslation;\nimport org.apache.beam.runners.core.construction.ParDoTranslation;\nimport org.apache.beam.runners.core.construction.SdkComponents;\nimport org.apache.beam.runners.core.construction.SingleInputOutputOverrideFactory;\nimport org.apache.beam.runners.core.construction.TransformPayloadTranslatorRegistrar;\nimport org.apache.beam.sdk.coders.Coder;\nimport org.apache.beam.sdk.runners.AppliedPTransform;\nimport org.apache.beam.sdk.runners.PTransformOverrideFactory;\nimport org.apache.beam.sdk.transforms.DoFn;\nimport org.apache.beam.sdk.transforms.DoFnSchemaInformation;\nimport org.apache.beam.sdk.transforms.PTransform;\nimport org.apache.beam.sdk.transforms.ParDo;\nimport org.apache.beam.sdk.transforms.ParDo.SingleOutput;\nimport org.apache.beam.sdk.transforms.reflect.DoFnSignature;\nimport org.apache.beam.sdk.transforms.reflect.DoFnSignatures;\nimport org.apache.beam.sdk.values.PCollection;\nimport org.apache.beam.sdk.values.PCollectionView;\nimport org.apache.beam.sdk.values.PCollectionViews;\nimport org.apache.beam.sdk.values.PValue;\nimport org.apache.beam.sdk.values.TupleTag;\nimport org.apache.beam.vendor.guava.v20_0.com.google.common.collect.Iterables;\nimport org.apache.beam.vendor.guava.v20_0.com.google.common.collect.Sets;\n/**\n * A {@link PTransformOverrideFactory} that produces {@link ParDoSingle} instances from {@link\n * ParDo.SingleOutput} instances. {@link ParDoSingle} is a primitive {@link PTransform}, to ensure\n * that {@link DisplayData} appears on all {@link ParDo ParDos} in the {@link DataflowRunner}.\n */\npublic class PrimitiveParDoSingleFactory<InputT, OutputT>\n    extends SingleInputOutputOverrideFactory<\n        PCollection<? extends InputT>, PCollection<OutputT>, ParDo.SingleOutput<InputT, OutputT>> {\n  @Override\n  public PTransformReplacement<PCollection<? extends InputT>, PCollection<OutputT>>\n      getReplacementTransform(\n          AppliedPTransform<\n                  PCollection<? extends InputT>,\n                  PCollection<OutputT>,\n                  SingleOutput<InputT, OutputT>>\n              transform) {\n    return PTransformReplacement.of(\n        PTransformReplacements.getSingletonMainInput(transform),\n        new ParDoSingle<>(\n            transform.getTransform(),\n            Iterables.getOnlyElement(transform.getOutputs().keySet()),\n            PTransformReplacements.getSingletonMainOutput(transform).getCoder()));\n  }\n  /** A single-output primitive {@link ParDo}. */\n  public static class ParDoSingle<InputT, OutputT>\n      extends ForwardingPTransform<PCollection<? extends InputT>, PCollection<OutputT>> {\n    private final ParDo.SingleOutput<InputT, OutputT> original;\n    private final TupleTag<?> onlyOutputTag;\n    private final Coder<OutputT> outputCoder;\n    private ParDoSingle(\n        SingleOutput<InputT, OutputT> original,\n        TupleTag<?> onlyOutputTag,\n        Coder<OutputT> outputCoder) {\n      this.original = original;\n      this.onlyOutputTag = onlyOutputTag;\n      this.outputCoder = outputCoder;\n    }\n    @Override\n    public PCollection<OutputT> expand(PCollection<? extends InputT> input) {\n      return PCollection.createPrimitiveOutputInternal(\n          input.getPipeline(),\n          input.getWindowingStrategy(),\n          input.isBounded(),\n          outputCoder,\n          onlyOutputTag);\n    }\n    public DoFn<InputT, OutputT> getFn() {\n      return original.getFn();\n    }\n    public TupleTag<?> getMainOutputTag() {\n      return onlyOutputTag;\n    }\n    public List<PCollectionView<?>> getSideInputs() {\n      return original.getSideInputs();\n    }\n    @Override\n    public Map<TupleTag<?>, PValue> getAdditionalInputs() {\n      return PCollectionViews.toAdditionalInputs(getSideInputs());\n    }\n    @Override\n    protected PTransform<PCollection<? extends InputT>, PCollection<OutputT>> delegate() {\n      return original;\n    }\n  }\n  /** A translator for {@link ParDoSingle}. */\n<fim_suffix>  public static class PayloadTranslator\n      implements PTransformTranslation.TransformPayloadTranslator<ParDoSingle<?, ?>> {\n    public static PTransformTranslation.TransformPayloadTranslator create() {\n      return new PayloadTranslator();\n    }\n    private PayloadTranslator() {}\n    @Override\n    public String getUrn(ParDoSingle<?, ?> transform) {\n      return PAR_DO_TRANSFORM_URN;\n    }\n    @Override\n    public RunnerApi.FunctionSpec translate(\n        AppliedPTransform<?, ?, ParDoSingle<?, ?>> transform, SdkComponents components)\n        throws IOException {\n      RunnerApi.ParDoPayload payload = payloadForParDoSingle(transform, components);\n      return RunnerApi.FunctionSpec.newBuilder()\n          .setUrn(PAR_DO_TRANSFORM_URN)\n          .setPayload(payload.toByteString())\n          .build();\n    }\n    private static RunnerApi.ParDoPayload payloadForParDoSingle(\n        final AppliedPTransform<?, ?, ParDoSingle<?, ?>> transform, SdkComponents components)\n        throws IOException {\n      final ParDoSingle<?, ?> parDo = transform.getTransform();\n      final DoFn<?, ?> doFn = parDo.getFn();\n      final DoFnSignature signature = DoFnSignatures.getSignature(doFn.getClass());\n      checkArgument(\n          !signature.processElement().isSplittable(),\n          String.format(\n              \"Not expecting a splittable %s: should have been overridden\",\n              ParDoSingle.class.getSimpleName()));\n      // TODO: Is there a better way to do this?\n      Set<String> allInputs =\n          transform.getInputs().keySet().stream().map(TupleTag::getId).collect(Collectors.toSet());\n      Set<String> sideInputs =\n          parDo.getSideInputs().stream()\n              .map(s -> s.getTagInternal().getId())\n              .collect(Collectors.toSet());\n      Set<String> timerInputs = signature.timerDeclarations().keySet();\n      String mainInputName =\n          Iterables.getOnlyElement(Sets.difference(allInputs, Sets.union(sideInputs, timerInputs)));\n      PCollection<?> mainInput =\n          (PCollection<?>) transform.getInputs().get(new TupleTag<>(mainInputName));\n      final DoFnSchemaInformation doFnSchemaInformation =\n          ParDo.getDoFnSchemaInformation(doFn, mainInput);\n      return ParDoTranslation.payloadForParDoLike(\n          new ParDoTranslation.ParDoLike() {\n            @Override\n            public RunnerApi.SdkFunctionSpec translateDoFn(SdkComponents newComponents) {\n              return ParDoTranslation.translateDoFn(\n                  parDo.getFn(), parDo.getMainOutputTag(), doFnSchemaInformation, newComponents);\n            }\n            @Override\n            public List<RunnerApi.Parameter> translateParameters() {\n              return ParDoTranslation.translateParameters(\n                  signature.processElement().extraParameters());\n            }\n            @Override\n            public Map<String, RunnerApi.SideInput> translateSideInputs(SdkComponents components) {\n              return ParDoTranslation.translateSideInputs(parDo.getSideInputs(), components);\n            }\n            @Override\n            public Map<String, RunnerApi.StateSpec> translateStateSpecs(SdkComponents components)\n                throws IOException {\n              Map<String, RunnerApi.StateSpec> stateSpecs = new HashMap<>();\n              for (Map.Entry<String, DoFnSignature.StateDeclaration> state :\n                  signature.stateDeclarations().entrySet()) {\n                RunnerApi.StateSpec spec =\n                    ParDoTranslation.translateStateSpec(\n                        getStateSpecOrThrow(state.getValue(), doFn), components);\n                stateSpecs.put(state.getKey(), spec);\n              }\n              return stateSpecs;\n            }\n            @Override\n            public Map<String, RunnerApi.TimerSpec> translateTimerSpecs(\n                SdkComponents newComponents) {\n              Map<String, RunnerApi.TimerSpec> timerSpecs = new HashMap<>();\n              for (Map.Entry<String, DoFnSignature.TimerDeclaration> timer :\n                  signature.timerDeclarations().entrySet()) {\n                RunnerApi.TimerSpec spec =\n                    translateTimerSpec(getTimerSpecOrThrow(timer.getValue(), doFn), newComponents);\n                timerSpecs.put(timer.getKey(), spec);\n              }\n              return timerSpecs;\n            }\n            @Override\n            public boolean isSplittable() {\n              return false;\n            }\n            @Override\n            public String translateRestrictionCoderId(SdkComponents newComponents) {\n              return \"\";\n            }\n          },\n          components);\n    }\n  }<fim_middle>// class below has no smell\n"}