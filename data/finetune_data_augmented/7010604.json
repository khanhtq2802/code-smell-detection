{"text": "<fim_prefix>\n<fim_suffix>public class DnsMetrics {\n  /** Disposition of a publish request. */\n  public enum PublishStatus { ACCEPTED, REJECTED }\n  /** Disposition of writer.commit(). */\n  public enum CommitStatus { SUCCESS, FAILURE }\n  /** Disposition of the publish action. */\n  public enum ActionStatus { SUCCESS, COMMIT_FAILURE, LOCK_FAILURE, BAD_WRITER, BAD_LOCK_INDEX }\n  private static final ImmutableSet<LabelDescriptor> LABEL_DESCRIPTORS_FOR_PUBLISH_REQUESTS =\n      ImmutableSet.of(\n          LabelDescriptor.create(\"tld\", \"TLD\"),\n          LabelDescriptor.create(\n              \"status\", \"Whether the publish request was accepted or rejected.\"));\n  private static final ImmutableSet<LabelDescriptor> LABEL_DESCRIPTORS_FOR_COMMIT =\n      ImmutableSet.of(\n          LabelDescriptor.create(\"tld\", \"TLD\"),\n          LabelDescriptor.create(\"status\", \"Whether writer.commit() succeeded or failed.\"),\n          LabelDescriptor.create(\"dnsWriter\", \"The DnsWriter used.\"));\n  private static final ImmutableSet<LabelDescriptor> LABEL_DESCRIPTORS_FOR_LATENCY =\n      ImmutableSet.of(\n          LabelDescriptor.create(\"tld\", \"TLD\"),\n          LabelDescriptor.create(\"status\", \"Whether the publish succeeded, or why it failed.\"),\n          LabelDescriptor.create(\"dnsWriter\", \"The DnsWriter used.\"));\n  // Finer-grained fitter than the DEFAULT_FITTER, allows values between 100 ms and just over 29\n  // hours.\n  private static final DistributionFitter EXPONENTIAL_FITTER =\n      ExponentialFitter.create(20, 2.0, 100.0);\n  // Fibonacci fitter more suitible for integer-type values. Allows values between 0 and 10946,\n  // which is the 21th Fibonacci number.\n  private static final DistributionFitter FIBONACCI_FITTER =\n      FibonacciFitter.create(10946);\n  private static final IncrementableMetric publishDomainRequests =\n      MetricRegistryImpl.getDefault()\n          .newIncrementableMetric(\n              \"/dns/publish_domain_requests\",\n              \"count of publishDomain requests\",\n              \"count\",\n              LABEL_DESCRIPTORS_FOR_PUBLISH_REQUESTS);\n  private static final IncrementableMetric publishHostRequests =\n      MetricRegistryImpl.getDefault()\n          .newIncrementableMetric(\n              \"/dns/publish_host_requests\",\n              \"count of publishHost requests\",\n              \"count\",\n              LABEL_DESCRIPTORS_FOR_PUBLISH_REQUESTS);\n  private static final IncrementableMetric commitCount =\n      MetricRegistryImpl.getDefault()\n          .newIncrementableMetric(\n              \"/dns/commit_requests\",\n              \"Count of writer.commit() calls\",\n              \"count\",\n              LABEL_DESCRIPTORS_FOR_COMMIT);\n  private static final IncrementableMetric domainsCommittedCount =\n      MetricRegistryImpl.getDefault()\n          .newIncrementableMetric(\n              \"/dns/domains_committed\",\n              \"Count of domains committed\",\n              \"count\",\n              LABEL_DESCRIPTORS_FOR_COMMIT);\n  private static final IncrementableMetric hostsCommittedCount =\n      MetricRegistryImpl.getDefault()\n          .newIncrementableMetric(\n              \"/dns/hosts_committed\",\n              \"Count of hosts committed\",\n              \"count\",\n              LABEL_DESCRIPTORS_FOR_COMMIT);\n  private static final EventMetric processingTimePerCommitDist =\n      MetricRegistryImpl.getDefault()\n          .newEventMetric(\n              \"/dns/per_batch/processing_time\",\n              \"publishDnsUpdates Processing Time\",\n              \"milliseconds\",\n              LABEL_DESCRIPTORS_FOR_COMMIT,\n              EXPONENTIAL_FITTER);\n  private static final EventMetric normalizedProcessingTimePerCommitDist =\n      MetricRegistryImpl.getDefault()\n          .newEventMetric(\n              \"/dns/per_batch/processing_time_per_dns_update\",\n              \"publishDnsUpdates Processing Time, divided by the batch size\",\n              \"milliseconds\",\n              LABEL_DESCRIPTORS_FOR_COMMIT,\n              EXPONENTIAL_FITTER);\n  private static final EventMetric totalBatchSizePerCommitDist =\n      MetricRegistryImpl.getDefault()\n          .newEventMetric(\n              \"/dns/per_batch/batch_size\",\n              \"Number of hosts and domains committed in each publishDnsUpdates\",\n              \"count\",\n              LABEL_DESCRIPTORS_FOR_COMMIT,\n              FIBONACCI_FITTER);\n  private static final EventMetric processingTimePerItemDist =\n      MetricRegistryImpl.getDefault()\n          .newEventMetric(\n              \"/dns/per_item/processing_time\",\n              \"publishDnsUpdates Processing Time\",\n              \"milliseconds\",\n              LABEL_DESCRIPTORS_FOR_COMMIT,\n              EXPONENTIAL_FITTER);\n  private static final EventMetric normalizedProcessingTimePerItemDist =\n      MetricRegistryImpl.getDefault()\n          .newEventMetric(\n              \"/dns/per_item/processing_time_per_dns_update\",\n              \"publishDnsUpdates Processing Time, divided by the batch size\",\n              \"milliseconds\",\n              LABEL_DESCRIPTORS_FOR_COMMIT,\n              EXPONENTIAL_FITTER);\n  private static final EventMetric totalBatchSizePerItemDist =\n      MetricRegistryImpl.getDefault()\n          .newEventMetric(\n              \"/dns/per_item/batch_size\",\n              \"Batch sizes for hosts and domains\",\n              \"count\",\n              LABEL_DESCRIPTORS_FOR_COMMIT,\n              FIBONACCI_FITTER);\n  private static final EventMetric updateRequestLatency =\n      MetricRegistryImpl.getDefault()\n          .newEventMetric(\n              \"/dns/update_latency\",\n              \"Time elapsed since refresh request was created until it was published\",\n              \"milliseconds\",\n              LABEL_DESCRIPTORS_FOR_LATENCY,\n              EXPONENTIAL_FITTER);\n  private static final EventMetric publishQueueDelay =\n      MetricRegistryImpl.getDefault()\n          .newEventMetric(\n              \"/dns/publish_queue_delay\",\n              \"Time elapsed since the publishDnsUpdates action was created until it was executed\",\n              \"milliseconds\",\n              LABEL_DESCRIPTORS_FOR_LATENCY,\n              EXPONENTIAL_FITTER);\n  @Inject RegistryEnvironment registryEnvironment;\n  @Inject\n  DnsMetrics() {}\n  /**\n   * Increment a monotonic counter that tracks calls to {@link\n   * google.registry.dns.writer.DnsWriter#publishDomain(String)}, per TLD.\n   */\n  public void incrementPublishDomainRequests(String tld, long numRequests, PublishStatus status) {\n    if (numRequests > 0) {\n      publishDomainRequests.incrementBy(numRequests, tld, status.name());\n    }\n  }\n  /**\n   * Increment a monotonic counter that tracks calls to {@link\n   * google.registry.dns.writer.DnsWriter#publishHost(String)}, per TLD.\n   */\n  public void incrementPublishHostRequests(String tld, long numRequests, PublishStatus status) {\n    if (numRequests > 0) {\n      publishHostRequests.incrementBy(numRequests, tld, status.name());\n    }\n  }\n  /**\n   * Measures information about the entire batched commit, per TLD.\n   *\n   * <p>The information includes running times (per item and per commit), and batch sizes (per item\n   * and per commit)\n   *\n   * <p>This is to be used for load testing the system, and will not measure anything in prod.\n   */\n  void recordCommit(\n      String tld,\n      String dnsWriter,\n      CommitStatus status,\n      Duration processingDuration,\n      int numberOfDomains,\n      int numberOfHosts) {\n    // We don't want to record all these metrics in production, as they are quite expensive\n    if (registryEnvironment == RegistryEnvironment.PRODUCTION) {\n      return;\n    }\n    int batchSize = numberOfDomains + numberOfHosts;\n    processingTimePerCommitDist.record(\n        processingDuration.getMillis(), tld, status.name(), dnsWriter);\n    processingTimePerItemDist.record(\n        processingDuration.getMillis(), batchSize, tld, status.name(), dnsWriter);\n    if (batchSize > 0) {\n      normalizedProcessingTimePerCommitDist.record(\n          (double) processingDuration.getMillis() / batchSize,\n          tld, status.name(), dnsWriter);\n      normalizedProcessingTimePerItemDist.record(\n          (double) processingDuration.getMillis() / batchSize,\n          batchSize,\n          tld, status.name(), dnsWriter);\n    }\n    totalBatchSizePerCommitDist.record(batchSize, tld, status.name(), dnsWriter);\n    totalBatchSizePerItemDist.record(batchSize, batchSize, tld, status.name(), dnsWriter);\n    commitCount.increment(tld, status.name(), dnsWriter);\n    domainsCommittedCount.incrementBy(numberOfDomains, tld, status.name(), dnsWriter);\n    hostsCommittedCount.incrementBy(numberOfHosts, tld, status.name(), dnsWriter);\n  }\n  void recordActionResult(\n      String tld,\n      String dnsWriter,\n      ActionStatus status,\n      int numberOfItems,\n      Duration timeSinceUpdateRequest,\n      Duration timeSinceActionEnqueued) {\n    updateRequestLatency.record(\n        timeSinceUpdateRequest.getMillis(), numberOfItems, tld, status.name(), dnsWriter);<fim_middle>// class below has no smell\n"}