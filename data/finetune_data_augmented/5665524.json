{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.sis.internal.netcdf.ucar;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.HashMap;\nimport java.io.IOException;\nimport ucar.nc2.Dimension;\nimport ucar.nc2.VariableIF;\nimport ucar.nc2.constants.AxisType;\nimport ucar.nc2.dataset.CoordinateAxis;\nimport ucar.nc2.dataset.CoordinateAxis2D;\nimport ucar.nc2.dataset.CoordinateSystem;\nimport org.apache.sis.internal.netcdf.Axis;\nimport org.apache.sis.internal.netcdf.Grid;\nimport org.apache.sis.internal.netcdf.Decoder;\nimport org.apache.sis.internal.util.UnmodifiableArrayList;\nimport org.apache.sis.storage.DataStoreException;\nimport org.apache.sis.util.ArraysExt;\n/**\n * Information about netCDF coordinate system, which include information about grid geometries.\n * In OGC/ISO specifications, the coordinate system and the grid geometries are distinct entities.\n * However the UCAR model takes a different point of view where the coordinate system holds some\n * of the grid geometry information.\n *\n * @author  Martin Desruisseaux (Geomatys)\n * @version 1.0\n * @since   0.3\n * @module\n */\nfinal class GridWrapper extends Grid {\n    /**\n     * The netCDF coordinate system to wrap.\n     */\n    private final CoordinateSystem netcdfCS;\n    /**\n     * Dimensions of the grid in netCDF order (reverse of \"natural\" order).\n     * This is the same content than {@code netcdfCS.getDomain()} but potentially in a different order.\n     * Reordering is needed when the order of dimensions in a variable does not match the order of dimensions in the grid.\n     * There is no such mismatch with Apache SIS implementation of netCDF reader, but those mismatches sometime happen with\n     * the wrappers around UCAR library where the following methods may return lists with elements in different order:\n     *\n     * <ul>\n     *   <li>{@link ucar.nc2.Variable#getDimensions()}</li>\n     *   <li>{@link ucar.nc2.dataset.CoordinateSystem#getDomain()}</li>\n     * </ul>\n     *\n     * @see #getDimensions()\n     */\n    private final List<Dimension> domain;\n    /**\n     * Other {@code GridWrapper} using the same UCAR coordinate systems but with {@link #domain} dimensions in a different order.\n     * We keep previously created {@code GridWrapper} instances in order to keep the cached value in {@link #geometry} field,\n     * since its computation may be costly.\n     */\n    private final Map<List<Dimension>, GridWrapper> reordered;\n    /**\n     * Creates a new grid geometry for the given netCDF coordinate system.\n     *\n     * @param  cs  the netCDF coordinate system.\n     */\n    GridWrapper(final CoordinateSystem cs) {\n        netcdfCS  = cs;\n        domain    = cs.getDomain();\n        reordered = new HashMap<>();\n    }\n    /**\n     * Creates a new grid geometry with the same coordinate system than the given parent.\n     */\n    private GridWrapper(final GridWrapper parent, final List<Dimension> dimensions) {\n        netcdfCS  = parent.netcdfCS;\n        domain    = dimensions;\n        reordered = parent.reordered;\n        assert netcdfCS.getDomain().containsAll(dimensions);\n    }\n    /**\n     * Returns a localization grid having the same dimensions than this grid but in a different order.\n     * This method is invoked by {@link VariableWrapper#getGrid()} when the localization grids created\n     * by {@link Decoder} subclasses are not sufficient and must be tailored for a particular variable.\n     * Returns {@code null} the the given dimensions are not members of this grid.\n     */\n    @Override\n    protected Grid derive(final org.apache.sis.internal.netcdf.Dimension[] dimensions) {\n        return derive(UnmodifiableArrayList.wrap(DimensionWrapper.unwrap(dimensions)));\n    }\n    /**\n     * Returns a localization grid wrapping the same coordinate system than this grid but with dimensions in different order.\n     * This is the implementation of {@link #derive(org.apache.sis.internal.netcdf.Dimension[])} after the Apache SIS objects\n     * have been unwrapped into UCAR objects. Returns {@code null} the the given dimensions are not members of this grid.\n     *\n     * @param  dimensions  the dimensions of this grid but potentially in a different order.\n     * @return localization grid with given dimension order (may be {@code this}), or {@code null}.\n     */\n    private GridWrapper derive(final List<Dimension> dimensions) {\n        if (domain.equals(dimensions)) {\n            return this;\n        }\n        return reordered.computeIfAbsent(dimensions, k -> {\n            // Want same set of dimensions in different order.\n            if (domain.size() == k.size() && domain.containsAll(k)) {\n                return new GridWrapper(this, k);\n            }\n            return null;\n        });\n    }\n    /**\n     * Returns the grid to use for the given variable. This method is needed because the order of dimensions declared\n     * in the {@link CoordinateSystem} may not be the same order than the dimensions of the given variable.\n     *\n     * @param  variable  the variable for which to get its grid.\n     * @param  systems   the coordinate systems of the given variable.\n     * @return grid for the given variable, or {@code null} if none.\n     */\n    final GridWrapper forVariable(final VariableIF variable, final List<CoordinateSystem> systems, final String[] axisNames) {\n        if (systems.contains(netcdfCS) && containsAllNamedAxes(axisNames)) {\n            return derive(variable.getDimensions());\n        }\n        return null;\n    }\n    /**\n     * Returns a name for this grid geometry, for information purpose only.\n     */\n    @Override\n    public String getName() {\n        return netcdfCS.getName();\n    }\n    /**\n     * Returns the number of dimensions of source coordinates in the <cite>\"grid to CRS\"</cite> conversion.\n     * This is the number of dimensions of the <em>grid</em>.\n     */\n    @Override\n    public int getSourceDimensions() {\n        return netcdfCS.getRankDomain();\n    }\n    /**\n     * Returns the number of dimensions of target coordinates in the <cite>\"grid to CRS\"</cite> conversion.\n     * This is the number of dimensions of the <em>coordinate reference system</em>.\n     * It should be equal to the size of the array returned by {@link #getAxes(Decoder)},\n     * but caller should be robust to inconsistencies.\n     */\n    @Override\n    public int getTargetDimensions() {\n        return netcdfCS.getRankRange();\n    }\n    /**\n     * Returns the dimensions of this grid, in netCDF (reverse of \"natural\") order.\n     */\n    @Override\n    protected List<org.apache.sis.internal.netcdf.Dimension> getDimensions() {\n        return DimensionWrapper.wrap(domain);\n    }\n    /**\n     * Returns {@code true} if this grid contains all axes of the specified names, ignoring case.\n     * If the given array is null, then no filtering is applied and this method returns {@code true}.\n     * If the grid contains more axes than the named ones, then the additional axes are ignored.\n     */\n<fim_suffix>    @Override\n    protected boolean containsAllNamedAxes(final String[] axisNames) {\n        if (axisNames != null) {\nnext:       for (final String name : axisNames) {\n                for (final CoordinateAxis axis : netcdfCS.getCoordinateAxes()) {\n                    if (name.equalsIgnoreCase(axis.getShortName())) {\n                        continue next;\n                    }\n                }\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Returns all axes of the netCDF coordinate system, together with the grid dimension to which the axis\n     * is associated.\n     *\n     * <p>In this method, the words \"domain\" and \"range\" are used in the netCDF sense: they are the input\n     * (domain) and output (range) of the function that convert grid indices to geodetic coordinates.</p>\n     *\n     * <p>The domain of all axes (or the {@linkplain CoordinateSystem#getDomain() coordinate system domain})\n     * is often the same than the domain of the variable, but not necessarily.<fim_middle>// function below has no smell\n"}