{"text": "<fim_prefix>/*******************************************************************************\n * Copyright (c) 2014, 2016 IBH SYSTEMS GmbH.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     IBH SYSTEMS GmbH - initial API and implementation\n *******************************************************************************/\npackage org.eclipse.packagedrone.repo.utils.osgi.bundle;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.jar.Attributes;\nimport java.util.jar.JarFile;\nimport java.util.jar.Manifest;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipFile;\nimport org.eclipse.packagedrone.repo.utils.osgi.ParserHelper;\nimport org.eclipse.packagedrone.repo.utils.osgi.bundle.BundleInformation.BundleRequirement;\nimport org.eclipse.packagedrone.repo.utils.osgi.bundle.BundleInformation.CapabilityValue;\nimport org.eclipse.packagedrone.repo.utils.osgi.bundle.BundleInformation.PackageExport;\nimport org.eclipse.packagedrone.repo.utils.osgi.bundle.BundleInformation.PackageImport;\nimport org.eclipse.packagedrone.repo.utils.osgi.bundle.BundleInformation.ProvideCapability;\nimport org.eclipse.packagedrone.repo.utils.osgi.bundle.BundleInformation.RequireCapability;\nimport org.eclipse.packagedrone.repo.utils.osgi.bundle.BundleInformation.VersionRangedName;\nimport org.eclipse.packagedrone.utils.AttributedValue;\nimport org.eclipse.packagedrone.utils.Headers;\nimport org.osgi.framework.Constants;\nimport org.osgi.framework.Version;\nimport org.osgi.framework.VersionRange;\npublic class BundleInformationParser\n{\n    private final ZipFile file;\n    private final Manifest manifest;\n    public BundleInformationParser ( final ZipFile file )\n    {\n        this.file = file;\n        this.manifest = null;\n    }\n    public BundleInformationParser ( final ZipFile file, final Manifest manifest )\n    {\n        this.file = file;\n        this.manifest = manifest;\n    }\n    @SuppressWarnings ( \"deprecation\" )\n    public BundleInformation parse () throws IOException\n    {\n        final BundleInformation result = new BundleInformation ();\n        Manifest m = null;\n        if ( this.manifest != null )\n        {\n            m = this.manifest;\n        }\n        else if ( this.file != null )\n        {\n            m = getManifest ( this.file );\n        }\n        if ( m == null )\n        {\n            return null;\n        }\n        final Attributes ma = m.getMainAttributes ();\n        final AttributedValue id = Headers.parse ( ma.getValue ( Constants.BUNDLE_SYMBOLICNAME ) );\n        final AttributedValue version = Headers.parse ( ma.getValue ( Constants.BUNDLE_VERSION ) );\n        if ( id == null || version == null )\n        {\n            return null;\n        }\n        final AttributedValue fragmentHost = Headers.parse ( ma.getValue ( Constants.FRAGMENT_HOST ) );\n        if ( fragmentHost != null )\n        {\n            final String bundleSymbolicName = fragmentHost.getValue ();\n            final String rangeStr = fragmentHost.getAttributes ().get ( Constants.BUNDLE_VERSION_ATTRIBUTE );\n            final VersionRange versionRange = rangeStr != null ? new VersionRange ( rangeStr ) : null;\n            result.setFragmentHost ( new VersionRangedName ( bundleSymbolicName, versionRange ) );\n        }\n        result.setId ( id.getValue () );\n        result.setSingleton ( Boolean.parseBoolean ( id.getAttributes ().get ( Constants.SINGLETON_DIRECTIVE ) ) );\n        try\n        {\n            result.setVersion ( new Version ( version.getValue () ) );\n        }\n        catch ( final Exception e )\n        {\n            throw new IllegalArgumentException ( String.format ( \"Illegal OSGi version: %s\", version.getValue () ) );\n        }\n        result.setName ( ma.getValue ( Constants.BUNDLE_NAME ) );\n        result.setVendor ( ma.getValue ( Constants.BUNDLE_VENDOR ) );\n        result.setDocUrl ( ma.getValue ( Constants.BUNDLE_DOCURL ) );\n        result.setLicense ( makeLicense ( ma.getValue ( Constants.BUNDLE_LICENSE ) ) );\n        result.setDescription ( ma.getValue ( Constants.BUNDLE_DESCRIPTION ) );\n        result.setEclipseBundleShape ( ma.getValue ( \"Eclipse-BundleShape\" ) );\n        result.setRequiredExecutionEnvironments ( Headers.parseStringList ( ma.getValue ( Constants.BUNDLE_REQUIREDEXECUTIONENVIRONMENT ) ) );\n        result.setEclipsePlatformFilter ( ma.getValue ( \"Eclipse-PlatformFilter\" ) );\n        result.setSourceBunde ( ma.getValue ( \"Eclipse-SourceBundle\" ) != null );\n        processImportPackage ( result, ma );\n        processExportPackage ( result, ma );\n        processImportBundle ( result, ma );\n        processCapabilities ( result, ma );\n        attachLocalization ( result, ma );\n        return result;\n    }\n    private String makeLicense ( final String value )\n    {\n        final AttributedValue license = Headers.parse ( value );\n        if ( license == null )\n        {\n            return null;\n        }\n        return license.getValue ();\n    }\n<fim_suffix>    private void processImportBundle ( final BundleInformation result, final Attributes ma )\n    {\n        for ( final AttributedValue av : emptyNull ( Headers.parseList ( ma.getValue ( Constants.REQUIRE_BUNDLE ) ) ) )\n        {\n            final String name = av.getValue ();\n            final String vs = av.getAttributes ().get ( \"bundle-version\" );\n            VersionRange vr = null;\n            if ( vs != null )\n            {\n                vr = new VersionRange ( vs );\n            }\n            final boolean optional = \"optional\".equals ( av.getAttributes ().get ( \"resolution\" ) );\n            final boolean reexport = \"reexport\".equals ( av.getAttributes ().get ( \"visibility\" ) );\n            result.getBundleRequirements ().add ( new BundleRequirement ( name, vr, optional, reexport ) );\n        }\n    }\n    private void processImportPackage ( final BundleInformation result, final Attributes ma )\n    {\n        for ( final AttributedValue av : emptyNull ( Headers.parseList ( ma.getValue ( Constants.IMPORT_PACKAGE ) ) ) )\n        {\n            final String name = av.getValue ();\n            final String vs = av.getAttributes ().get ( \"version\" );\n            VersionRange vr = null;\n            if ( vs != null )\n            {\n                vr = new VersionRange ( vs );\n            }\n            final boolean optional = \"optional\".equals ( av.getAttributes ().get ( \"resolution\" ) );\n            result.getPackageImports ().add ( new PackageImport ( name, vr, optional ) );\n        }\n    }\n    private void processExportPackage ( final BundleInformation result, final Attributes ma )\n    {\n        for ( final AttributedValue av : emptyNull ( Headers.parseList ( ma.getValue ( Constants.EXPORT_PACKAGE ) ) ) )\n        {\n            final String name = av.getValue ();\n            final String vs = av.getAttributes ().get ( \"version\" );\n            Version v = null;\n            if ( vs != null )\n            {\n                v = new Version ( vs );\n            }\n            final String uses = av.getAttributes ().get ( \"uses\" );\n            result.getPackageExports ().add ( new PackageExport ( name, v, uses ) );\n        }\n    }\n    private void processCapabilities ( final BundleInformation result, final Attributes ma )\n    {\n        for ( final AttributedValue av : emptyNull ( Headers.parseList ( ma.getValue ( Constants.PROVIDE_CAPABILITY ) ) ) )\n        {\n            final String namespace = av.getValue ();\n            final Map<String, CapabilityValue> values = new HashMap<> ();\n            for ( final Map.Entry<String, String> entry : av.getAttributes ().entrySet () )\n            {\n                final String keyType = entry.getKey ();\n                final String value = entry.getValue ();\n                final String[] key = keyType.split ( \":\", 2 );\n                if ( key.length == 1 )\n                {\n                    values.put ( key[0], new CapabilityValue ( \"String\", value ) );\n                }\n                else\n                {\n                    values.put ( key[0], new CapabilityValue ( key[1], value ) );\n                }\n            }\n            final ProvideCapability pc = new ProvideCapability ( namespace, values );\n            result.getProvidedCapabilities ().add ( pc );\n        }\n        for ( final AttributedValue av : emptyNull ( Headers.parseList ( ma.getValue ( Constants.REQUIRE_CAPABILITY ) ) ) )\n        {\n            final String namespace = av.getValue ();\n            final String filter = av.getAttributes ().get ( \"filter\" );\n            final String effective = av.getAttributes ().get ( \"effective\" );\n            final RequireCapability rc = new RequireCapability ( namespace, filter, effective );\n            result.getRequiredCapabilities ().add ( rc );\n        }\n    }\n    private <T> Collection<T> emptyNull ( final Collection<T> list )\n    {<fim_middle>// function below has no smell\n"}