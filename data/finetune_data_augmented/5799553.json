{"text": "<fim_prefix>// Copyright 2011 The Apache Software Foundation\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage org.apache.tapestry5.internal.plastic;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport java.util.Map;\n\n@SuppressWarnings(\n{ \"rawtypes\", \"unchecked\" })\npublic class AnnotationBuilder extends AbstractAnnotationBuilder\n{\n    private static final class AnnotationValueHandler implements InvocationHandler\n    {\n        private final Class annotationType;\n\n        private final Map<String, Object> attributes;\n\n        public AnnotationValueHandler(final Class annotationType, Map<String, Object> attributes)\n        {\n            this.annotationType = annotationType;\n            this.attributes = attributes;\n        }\n\n<fim_suffix>        @Override\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable\n        {\n            // args is null for no-arguments methods\n            if (args == null)\n            {\n                String attributeName = method.getName();\n\n                if (attributes.containsKey(attributeName)) { return attributes.get(attributeName); }\n            }\n\n            // TODO: Handling of equals() and hashCode() and toString(), plus other methods\n            // inherited from Object\n\n            throw new RuntimeException(String.format(\"Annotation proxy for class %s does not handle method %s.\",\n                    annotationType.getName(), method));\n        }\n    }\n\n    private final Class annotationType;\n\n    final Map<String, Object> attributes = PlasticInternalUtils.newMap();\n\n    public AnnotationBuilder(Class annotationType, PlasticClassPool pool)\n    {\n        super(pool);\n\n        this.annotationType = annotationType;\n\n        attributes.put(\"annotationType\", annotationType);\n\n        // Annotation attributes are represented as methods, and for each method there may be a\n        // default value. Preload the default values, which may be overwritten by explicit\n        // values.\n\n        for (Method m : annotationType.getMethods())\n        {\n            Object defaultValue = m.getDefaultValue();\n\n            if (defaultValue != null)\n            {\n                attributes.put(m.getName(), defaultValue);\n            }\n        }\n\n        if (!attributes.containsKey(\"toString\"))\n        {\n            attributes.put(\"toString\", \"@\" + annotationType.getName());\n        }\n\n    }\n\n    @Override\n    protected void store(String name, Object value)\n    {\n        attributes.put(name, value);\n    }\n\n    @Override\n    protected Class elementTypeForArrayAttribute(String name)\n    {\n        try\n        {\n            return annotationType.getMethod(name).getReturnType().getComponentType();\n        }\n        catch (Exception ex)\n        {\n            throw new RuntimeException(String.format(\n                    \"Unable to determine element type for attribute '%s' of annotation %s: %s\", name,\n                    annotationType.getName(), PlasticInternalUtils.toMessage(ex)), ex);\n        }\n    }\n\n    public Object createAnnotation()\n    {\n        // Use a static inner class to keep the AnnotationBuilder from being retained\n\n        InvocationHandler handler = new AnnotationValueHandler(annotationType, attributes);\n\n        try\n        {\n            return Proxy.newProxyInstance(pool.loader, new Class[]\n            { annotationType }, handler);\n        }\n        catch (IllegalArgumentException ex)\n        {\n            throw new IllegalArgumentException(String.format(\"Unable to create instance of annotation type %s: %s\",\n                    annotationType.getName(), PlasticInternalUtils.toMessage(ex)), ex);\n        }\n    }\n\n}<fim_middle>// function below has no smell\n"}