{"text": "<fim_prefix>\n<fim_suffix>public class TopicSubscription extends AbstractSubscription {\n    private static final Logger LOG = LoggerFactory.getLogger(TopicSubscription.class);\n    private static final AtomicLong CURSOR_NAME_COUNTER = new AtomicLong(0);\n    protected PendingMessageCursor matched;\n    protected final SystemUsage usageManager;\n    boolean singleDestination = true;\n    Destination destination;\n    private final Scheduler scheduler;\n    private int maximumPendingMessages = -1;\n    private MessageEvictionStrategy messageEvictionStrategy = new OldestMessageEvictionStrategy();\n    private int discarded;\n    private final Object matchedListMutex = new Object();\n    private int memoryUsageHighWaterMark = 95;\n    // allow duplicate suppression in a ring network of brokers\n    protected int maxProducersToAudit = 1024;\n    protected int maxAuditDepth = 1000;\n    protected boolean enableAudit = false;\n    protected ActiveMQMessageAudit audit;\n    protected boolean active = false;\n    protected boolean discarding = false;\n    private boolean useTopicSubscriptionInflightStats = true;\n    //Used for inflight message size calculations\n    protected final Object dispatchLock = new Object();\n    protected final List<DispatchedNode> dispatched = new ArrayList<>();\n    public TopicSubscription(Broker broker,ConnectionContext context, ConsumerInfo info, SystemUsage usageManager) throws Exception {\n        super(broker, context, info);\n        this.usageManager = usageManager;\n        String matchedName = \"TopicSubscription:\" + CURSOR_NAME_COUNTER.getAndIncrement() + \"[\" + info.getConsumerId().toString() + \"]\";\n        if (info.getDestination().isTemporary() || broker.getTempDataStore()==null ) {\n            this.matched = new VMPendingMessageCursor(false);\n        } else {\n            this.matched = new FilePendingMessageCursor(broker,matchedName,false);\n        }\n        this.scheduler = broker.getScheduler();\n    }\n    public void init() throws Exception {\n        this.matched.setSystemUsage(usageManager);\n        this.matched.setMemoryUsageHighWaterMark(getCursorMemoryHighWaterMark());\n        this.matched.start();\n        if (enableAudit) {\n            audit= new ActiveMQMessageAudit(maxAuditDepth, maxProducersToAudit);\n        }\n        this.active=true;\n    }\n    @Override\n    public void add(MessageReference node) throws Exception {\n        if (isDuplicate(node)) {\n            return;\n        }\n        // Lets use an indirect reference so that we can associate a unique\n        // locator /w the message.\n        node = new IndirectMessageReference(node.getMessage());\n        getSubscriptionStatistics().getEnqueues().increment();\n        synchronized (matchedListMutex) {\n            // if this subscriber is already discarding a message, we don't want to add\n            // any more messages to it as those messages can only be advisories generated in the process,\n            // which can trigger the recursive call loop\n            if (discarding) return;\n            if (!isFull() && matched.isEmpty()) {\n                // if maximumPendingMessages is set we will only discard messages which\n                // have not been dispatched (i.e. we allow the prefetch buffer to be filled)\n                dispatch(node);\n                setSlowConsumer(false);\n            } else {\n                if (info.getPrefetchSize() > 1 && matched.size() > info.getPrefetchSize()) {\n                    // Slow consumers should log and set their state as such.\n                    if (!isSlowConsumer()) {\n                        LOG.warn(\"{}: has twice its prefetch limit pending, without an ack; it appears to be slow\", toString());\n                        setSlowConsumer(true);\n                        for (Destination dest: destinations) {\n                            dest.slowConsumer(getContext(), this);\n                        }\n                    }\n                }\n                if (maximumPendingMessages != 0) {\n                    boolean warnedAboutWait = false;\n                    while (active) {\n                        while (matched.isFull()) {\n                            if (getContext().getStopping().get()) {\n                                LOG.warn(\"{}: stopped waiting for space in pendingMessage cursor for: {}\", toString(), node.getMessageId());\n                                getSubscriptionStatistics().getEnqueues().decrement();\n                                return;\n                            }\n                            if (!warnedAboutWait) {\n                                LOG.info(\"{}: Pending message cursor [{}] is full, temp usag ({}%) or memory usage ({}%) limit reached, blocking message add() pending the release of resources.\",\n                                        new Object[]{\n                                                toString(),\n                                                matched,\n                                                matched.getSystemUsage().getTempUsage().getPercentUsage(),\n                                                matched.getSystemUsage().getMemoryUsage().getPercentUsage()\n                                        });\n                                warnedAboutWait = true;\n                            }\n                            matchedListMutex.wait(20);\n                        }\n                        // Temporary storage could be full - so just try to add the message\n                        // see https://issues.apache.org/activemq/browse/AMQ-2475\n                        if (matched.tryAddMessageLast(node, 10)) {\n                            break;\n                        }\n                    }\n                    if (maximumPendingMessages > 0) {\n                        // calculate the high water mark from which point we\n                        // will eagerly evict expired messages\n                        int max = messageEvictionStrategy.getEvictExpiredMessagesHighWatermark();\n                        if (maximumPendingMessages > 0 && maximumPendingMessages < max) {\n                            max = maximumPendingMessages;\n                        }\n                        if (!matched.isEmpty() && matched.size() > max) {\n                            removeExpiredMessages();\n                        }\n                        // lets discard old messages as we are a slow consumer\n                        while (!matched.isEmpty() && matched.size() > maximumPendingMessages) {\n                            int pageInSize = matched.size() - maximumPendingMessages;\n                            // only page in a 1000 at a time - else we could blow the memory\n                            pageInSize = Math.max(1000, pageInSize);\n                            LinkedList<MessageReference> list = null;\n                            MessageReference[] oldMessages=null;\n                            synchronized(matched){\n                                list = matched.pageInList(pageInSize);\n                                oldMessages = messageEvictionStrategy.evictMessages(list);\n                                for (MessageReference ref : list) {\n                                    ref.decrementReferenceCount();\n                                }\n                            }\n                            int messagesToEvict = 0;\n                            if (oldMessages != null){\n                                messagesToEvict = oldMessages.length;\n                                for (int i = 0; i < messagesToEvict; i++) {\n                                    MessageReference oldMessage = oldMessages[i];\n                                    discard(oldMessage);\n                                }\n                            }\n                            // lets avoid an infinite loop if we are given a bad eviction strategy\n                            // for a bad strategy lets just not evict\n                            if (messagesToEvict == 0) {\n                                LOG.warn(\"No messages to evict returned for {} from eviction strategy: {} out of {} candidates\", new Object[]{\n                                        destination, messageEvictionStrategy, list.size()\n                                });\n                                break;\n                            }\n                        }\n                    }\n                    dispatchMatched();\n                }\n            }\n        }\n    }\n    private boolean isDuplicate(MessageReference node) {\n        boolean duplicate = false;\n        if (enableAudit && audit != null) {\n            duplicate = audit.isDuplicate(node);\n            if (LOG.isDebugEnabled()) {\n                if (duplicate) {\n                    LOG.debug(\"{}, ignoring duplicate add: {}\", this, node.getMessageId());\n                }\n            }\n        }\n        return duplicate;\n    }\n    /**\n     * Discard any expired messages from the matched list. Called from a\n     * synchronized block.\n     *\n     * @throws IOException\n     */\n    protected void removeExpiredMessages() throws IOException {\n        try {\n            matched.reset();\n            while (matched.hasNext()) {\n                MessageReference node = matched.next();\n                node.decrementReferenceCount();\n                if (node.isExpired()) {\n                    matched.remove();\n                    node.decrementReferenceCount();\n                    if (broker.isExpired(node)) {\n                        ((Destination) node.getRegionDestination()).getDestinationStatistics().getExpired().increment();\n                        broker.messageExpired(getContext(), node, this);\n                    }\n                    break;\n                }\n            }\n        } finally {\n            matched.release();\n        }\n    }\n    @Override\n    public void processMessageDispatchNotification(MessageDispatchNotification mdn) {\n        synchronized (matchedListMutex) {\n            try {\n                matched.reset();\n                while (matched.hasNext()) {\n                    MessageReference node = matched.next();\n                    node.decrementReferenceCount();\n                    if (node.getMessageId().equals(mdn.getMessageId())) {\n                        synchronized(dispatchLock) {\n                            matched.remove();\n                            getSubscriptionStatistics().getDispatched().increment();\n                            if (isUseTopicSubscriptionInflightStats()) {\n                                dispatched.add(new DispatchedNode(node));\n                                getSubscriptionStatistics().getInflightMessageSize().addSize(node.getSize());\n                            }\n                            node.decrementReferenceCount();\n                        }\n                        break;\n                    }\n                }\n            } finally {\n                matched.release();\n            }\n        }\n    }\n    @Override\n    public synchronized void acknowledge(final ConnectionContext context, final MessageAck ack) throws Exception {\n        super.acknowledge(context, ack);\n        if (ack.isStandardAck()) {\n            updateStatsOnAck(context, ack);\n        } else if (ack.isPoisonAck()) {\n            if (ack.isInTransaction()) {\n                throw new JMSException(\"Poison ack cannot be transacted: \" + ack);\n            }<fim_middle>// class below is blob\n"}