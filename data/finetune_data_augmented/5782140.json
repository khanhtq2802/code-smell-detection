{"text": "<fim_prefix>        }\n      }\n    } finally {\n      readLock.unlock();\n    }\n    for(Vertex vertex : getInputVertices().keySet()) {\n      /**\n       * It is possible that setParallelism is in the middle of processing in target vertex with\n       * its write lock. So we need to get inputspec by acquiring read lock in target vertex to\n       * get consistent view.\n       * Refer TEZ-2251\n       */\n      InputSpec inputSpec = ((VertexImpl) vertex).getDestinationSpecFor(this, taskIndex);\n      // TODO DAGAM This should be based on the edge type.\n      inputSpecList.add(inputSpec);\n    }\n    return inputSpecList;\n  }\n  @Override\n  public List<OutputSpec> getOutputSpecList(int taskIndex) throws AMUserCodeException {\n    /**\n     * Ref: TEZ-3297\n     * Locking entire method could introduce a nested lock and\n     * could lead to deadlock in corner cases. Example of deadlock with nested lock here:\n     * 1. In thread#1, Downstream vertex is in the middle of processing setParallelism and gets\n     * writeLock.\n     * 2. In thread#2, currentVertex acquires read lock\n     * 3. In thread#3, central dispatcher tries to process an event for current vertex,\n     * so tries to acquire write lock.\n     *\n     * In further processing,\n     * 4. In thread#1, it tries to acquire readLock on current vertex for setting edges. But\n     * this would be blocked as #3 already requested for write lock\n     * 5. In thread#2, getting readLock on downstream vertex would be blocked as writeLock\n     * is held by thread#1.\n     * 6. thread#3 is anyways blocked due to thread#2's read lock on current vertex.\n     */\n    List<OutputSpec> outputSpecList = null;\n    readLock.lock();\n    try {\n      outputSpecList = new ArrayList<OutputSpec>(this.getOutputVerticesCount()\n          + this.additionalOutputSpecs.size());\n      outputSpecList.addAll(additionalOutputSpecs);\n    } finally {\n      readLock.unlock();\n    }\n    for(Vertex vertex : targetVertices.keySet()) {\n      /**\n       * It is possible that setParallelism (which could change numTasks) is in the middle of\n       * processing in target vertex with its write lock. So we need to get outputspec by\n       * acquiring read lock in target vertex to get consistent view.\n       * Refer TEZ-2251\n       */\n      OutputSpec outputSpec = ((VertexImpl) vertex).getSourceSpecFor(this, taskIndex);\n      outputSpecList.add(outputSpec);\n    }\n    return outputSpecList;\n  }\n  private OutputSpec getSourceSpecFor(VertexImpl vertex, int taskIndex) throws\n      AMUserCodeException {\n    readLock.lock();\n    try {\n      Edge edge = sourceVertices.get(vertex);\n      Preconditions.checkState(edge != null, getLogIdentifier());\n      return edge.getSourceSpec(taskIndex);\n    } finally {\n      readLock.unlock();\n    }\n  }\n  private InputSpec getDestinationSpecFor(VertexImpl vertex, int taskIndex) throws\n      AMUserCodeException {\n    readLock.lock();\n    try {\n      Edge edge = targetVertices.get(vertex);\n      Preconditions.checkState(edge != null, getLogIdentifier());\n      return edge.getDestinationSpec(taskIndex);\n    } finally {\n      readLock.unlock();\n    }\n  }\n  @Override\n  public List<GroupInputSpec> getGroupInputSpecList() {\n    readLock.lock();\n    try {\n      return groupInputSpecList;\n    } finally {\n      readLock.unlock();\n    }\n  }\n  @Override\n  public synchronized void addSharedOutputs(Set<String> outputs) {\n    this.sharedOutputs.addAll(outputs);\n  }\n  @Override\n  public synchronized Set<String> getSharedOutputs() {\n    return this.sharedOutputs;\n  }\n  @VisibleForTesting\n  VertexManager getVertexManager() {\n    return this.vertexManager;\n  }\n  private static void logLocationHints(String vertexName,\n      VertexLocationHint locationHint) {\n    if (locationHint == null) {\n      LOG.debug(\"No Vertex LocationHint specified for vertex=\" + vertexName);\n      return;\n    }\n    Multiset<String> hosts = HashMultiset.create();\n    Multiset<String> racks = HashMultiset.create();\n    int counter = 0;\n    for (TaskLocationHint taskLocationHint : locationHint\n        .getTaskLocationHints()) {\n      StringBuilder sb = new StringBuilder();\n      if (taskLocationHint.getHosts() == null) {\n        sb.append(\"No Hosts\");\n      } else {\n        sb.append(\"Hosts: \");\n        for (String host : taskLocationHint.getHosts()) {\n          hosts.add(host);\n          sb.append(host).append(\", \");\n        }\n      }\n      if (taskLocationHint.getRacks() == null) {\n        sb.append(\"No Racks\");\n      } else {\n        sb.append(\"Racks: \");\n        for (String rack : taskLocationHint.getRacks()) {\n          racks.add(rack);\n          sb.append(rack).append(\", \");\n        }\n      }\n      LOG.debug(\"Vertex: \" + vertexName + \", Location: \"\n          + counter + \" : \" + sb.toString());\n      counter++;\n    }\n    LOG.debug(\"Vertex: \" + vertexName + \", Host Counts\");\n    for (Multiset.Entry<String> host : hosts.entrySet()) {\n      LOG.debug(\"Vertex: \" + vertexName + \", host: \" + host.toString());\n    }\n    LOG.debug(\"Vertex: \" + vertexName + \", Rack Counts\");\n    for (Multiset.Entry<String> rack : racks.entrySet()) {\n      LOG.debug(\"Vertex: \" + vertexName + \", rack: \" + rack.toString());\n    }\n  }\n  /**\n   * This is for recovery when VertexReconfigureDoneEvent is seen. \n   */\n  public static class NoOpVertexManager extends VertexManagerPlugin {\n    private VertexConfigurationDoneEvent configurationDoneEvent;\n    private boolean setParallelismInInitializing = false;\n    public NoOpVertexManager(VertexManagerPluginContext context) {\n      super(context);\n    }\n    @Override\n    public void initialize() throws Exception {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"initialize NoOpVertexManager\");\n      }\n      configurationDoneEvent = new VertexConfigurationDoneEvent();\n      configurationDoneEvent.fromProtoStream(CodedInputStream.newInstance(getContext().getUserPayload().deepCopyAsArray()));\n      String vertexName = getContext().getVertexName();\n      if (getContext().getVertexNumTasks(vertexName) == -1) {\n        Preconditions.checkArgument(configurationDoneEvent.isSetParallelismCalled(), \"SetParallelism must be called \"\n            + \"when numTasks is -1\");\n        setParallelismInInitializing = true;\n        getContext().registerForVertexStateUpdates(vertexName,\n            Sets.newHashSet(org.apache.tez.dag.api.event.VertexState.INITIALIZING));\n      }\n      getContext().vertexReconfigurationPlanned();\n    }\n    @Override\n    public void onVertexStarted(List<TaskAttemptIdentifier> completions)\n        throws Exception {\n      // apply the ReconfigureDoneEvent and then schedule all the tasks.\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"onVertexStarted is invoked in NoOpVertexManager, vertex=\" + getContext().getVertexName());\n      }\n      if (!setParallelismInInitializing && configurationDoneEvent.isSetParallelismCalled()) {\n        reconfigureVertex();\n      }\n      getContext().doneReconfiguringVertex();\n      int numTasks = getContext().getVertexNumTasks(getContext().getVertexName());\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Schedule all the tasks, numTask=\" + numTasks);\n      }\n      List<ScheduleTaskRequest> tasks = new ArrayList<ScheduleTaskRequest>();\n      for (int i=0;i<numTasks;++i) {\n        tasks.add(ScheduleTaskRequest.create(i, null));\n      }\n      getContext().scheduleTasks(tasks);\n    }\n    @Override\n    public void onSourceTaskCompleted(TaskAttemptIdentifier attempt)\n        throws Exception {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"onSourceTaskCompleted is invoked in NoOpVertexManager, vertex=\" + getContext().getVertexName());\n      }\n    }\n<fim_suffix>    @Override\n    public void onVertexManagerEventReceived(VertexManagerEvent vmEvent)\n        throws Exception {\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"onVertexManagerEventReceived is invoked in NoOpVertexManager, vertex=\" + getContext().getVertexName());\n      }\n    }<fim_middle>// function below has no smell\n"}