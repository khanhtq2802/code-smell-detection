{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.drill.exec.physical.impl.statistics;\n\n// Library implementing HLL algorithm to derive approximate #distinct values(NDV). Please refer:\n// 'HyperLogLog: the analysis of a near-optimal cardinality estimation algorithm.' Flajolet et. al.\nimport com.clearspring.analytics.stream.cardinality.HyperLogLog;\nimport java.io.ByteArrayInputStream;\nimport java.io.DataInputStream;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.apache.drill.common.types.TypeProtos;\nimport org.apache.drill.exec.ExecConstants;\nimport org.apache.drill.exec.server.options.OptionManager;\nimport org.apache.drill.exec.vector.NullableVarBinaryVector;\nimport org.apache.drill.exec.vector.ValueVector;\nimport org.apache.drill.exec.vector.complex.MapVector;\n\npublic class HLLMergedStatistic extends AbstractMergedStatistic {\n  private Map<String, HyperLogLog> hllHolder;\n  private long accuracy;\n\n  public HLLMergedStatistic () {\n    this.hllHolder = new HashMap<>();\n    state = State.INIT;\n  }\n\n  @Override\n  public void initialize(String inputName, double samplePercent) {\n    super.initialize(Statistic.HLL_MERGE, inputName, samplePercent);\n    state = State.CONFIG;\n  }\n\n  @Override\n  public String getName() {\n    return name;\n  }\n\n  @Override\n  public String getInput() {\n    return inputName;\n  }\n\n  @Override\n  public void merge(MapVector input) {\n    // Check the input is a Map Vector\n    assert (input.getField().getType().getMinorType() == TypeProtos.MinorType.MAP);\n    for (ValueVector vv : input) {\n      String colName = vv.getField().getName();\n      HyperLogLog colHLLHolder = null;\n      if (hllHolder.get(colName) != null) {\n        colHLLHolder = hllHolder.get(colName);\n      }\n      NullableVarBinaryVector hllVector = (NullableVarBinaryVector) vv;\n      NullableVarBinaryVector.Accessor accessor = hllVector.getAccessor();\n\n      try {\n        if (!accessor.isNull(0)) {\n          ByteArrayInputStream bais = new ByteArrayInputStream(accessor.get(0), 0, vv.getBufferSize());\n          HyperLogLog other = HyperLogLog.Builder.build(new DataInputStream(bais));\n          if (colHLLHolder != null) {\n            colHLLHolder.addAll(other);\n            hllHolder.put(colName, colHLLHolder);\n          } else {\n            hllHolder.put(colName, other);\n          }\n        }\n      } catch (Exception ex) {\n        //TODO: Catch IOException/CardinalityMergeException\n        //TODO: logger\n      }\n    }\n  }\n\n  public HyperLogLog getStat(String colName) {\n    if (state != State.COMPLETE) {\n      throw new IllegalStateException(String.format(\"Statistic `%s` has not completed merging statistics\",\n          name));\n    }\n    return hllHolder.get(colName);\n  }\n\n  @Override\n  public void setOutput(MapVector output) {\n    // Check the input is a Map Vector\n    assert (output.getField().getType().getMinorType() == TypeProtos.MinorType.MAP);\n    // Dependencies have been configured correctly\n    assert (state == State.MERGE);\n    for (ValueVector outMapCol : output) {\n      String colName = outMapCol.getField().getName();\n      HyperLogLog colHLLHolder = hllHolder.get(colName);\n      NullableVarBinaryVector vv = (NullableVarBinaryVector) outMapCol;\n      vv.allocateNewSafe();\n      try {\n        if (colHLLHolder != null) {\n          vv.getMutator().setSafe(0, colHLLHolder.getBytes(),\n              0, colHLLHolder.getBytes().length);\n        } else {\n          vv.getMutator().setNull(0);\n        }\n      } catch (IOException ex) {\n        // TODO: logger\n      }\n    }\n    state = State.COMPLETE;\n  }\n\n<fim_suffix>  public void configure(OptionManager optionsManager) {\n    assert (state == State.CONFIG);\n    accuracy = optionsManager.getLong(ExecConstants.HLL_ACCURACY);\n    // Now config complete - moving to MERGE state\n    state = State.MERGE;\n  }\n}<fim_middle>// function below has no smell\n"}