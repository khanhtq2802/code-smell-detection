{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.crunch.io.text;\n\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\nimport org.apache.crunch.MapFn;\nimport org.apache.crunch.Pair;\nimport org.apache.crunch.fn.CompositeMapFn;\nimport org.apache.crunch.fn.IdentityFn;\nimport org.apache.crunch.types.PTableType;\nimport org.apache.crunch.types.PType;\n\nimport com.google.common.base.Splitter;\nimport com.google.common.collect.ImmutableList;\n\n/**\n * An abstraction for parsing the lines of a text file using a {@code PType<T>} to\n * convert the lines of text into a given data type. \n *\n * @param <T> The type returned by the text parsing\n */\n<fim_suffix>abstract class LineParser<T> {\n\n  public static <S> LineParser<S> forType(PType<S> ptype) {\n    return new SimpleLineParser<S>(ptype);\n  }\n  \n  public static <K, V> LineParser<Pair<K, V>> forTableType(PTableType<K, V> ptt, String sep) {\n    return new KeyValueLineParser<K, V>(ptt, sep); \n  }\n  \n  private MapFn<String, T> mapFn;\n  \n  public void initialize() {\n    mapFn = getMapFn();\n    mapFn.initialize();\n  }\n    \n  public T parse(String line) {\n    return mapFn.map(line);\n  }\n  \n  protected abstract MapFn<String, T> getMapFn();\n  \n  private static <T> MapFn<String, T> getMapFnForPType(PType<T> ptype) {\n    MapFn ret = null;\n    if (String.class.equals(ptype.getTypeClass())) {\n      ret = (MapFn) IdentityFn.getInstance();\n    } else {\n      // Check for a composite MapFn for the PType.\n      // Note that this won't work for Avro-- need to solve that.\n      ret = ptype.getInputMapFn();\n      if (ret instanceof CompositeMapFn) {\n        ret = ((CompositeMapFn) ret).getSecond();\n      }\n    }\n    return ret;\n  }\n  \n  private static class SimpleLineParser<S> extends LineParser<S> {\n\n    private final PType<S> ptype;\n    \n    public SimpleLineParser(PType<S> ptype) {\n      this.ptype = ptype;\n    }\n\n    @Override\n    protected MapFn<String, S> getMapFn() {\n      return getMapFnForPType(ptype);\n    }\n  }\n  \n  private static class KeyValueLineParser<K, V> extends LineParser<Pair<K, V>> {\n\n    private final PTableType<K, V> ptt;\n    private final String sep;\n    \n    public KeyValueLineParser(PTableType<K, V> ptt, String sep) {\n      this.ptt = ptt;\n      this.sep = sep;\n    }\n\n    @Override\n    protected MapFn<String, Pair<K, V>> getMapFn() {\n      final MapFn<String, K> keyMapFn = getMapFnForPType(ptt.getKeyType());\n      final MapFn<String, V> valueMapFn = getMapFnForPType(ptt.getValueType());\n      \n      return new MapFn<String, Pair<K, V>>() {\n        @Override\n        public void initialize() {\n          keyMapFn.initialize();\n          valueMapFn.initialize();\n        }\n        \n        @Override\n        public Pair<K, V> map(String input) {\n          List<String> kv = ImmutableList.copyOf(Splitter.on(sep).limit(1).split(input));\n          if (kv.size() != 2) {\n            throw new RuntimeException(\"Invalid input string: \" + input);\n          }\n          return Pair.of(keyMapFn.map(kv.get(0)), valueMapFn.map(kv.get(1)));\n        }\n      };\n    }\n  }\n}<fim_middle>// class below has no smell\n"}