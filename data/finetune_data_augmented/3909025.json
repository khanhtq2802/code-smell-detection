{"text": "<fim_prefix>                    tOut.setLongFileMode(TarOutputStream.LONGFILE_POSIX);\n                } else {\n                    // warn or GNU\n                    tOut.setLongFileMode(TarOutputStream.LONGFILE_GNU);\n                }\n                longWarningGiven = false;\n                for (final TarFileSet tfs : filesets) {\n                    tar(tfs, tOut);\n                }\n                for (final ResourceCollection rcol : resourceCollections) {\n                    tar(rcol, tOut);\n                }\n            } catch (final IOException ioe) {\n                final String msg = \"Problem creating TAR: \" + ioe.getMessage();\n                throw new BuildException(msg, ioe, getLocation());\n            }\n        } finally {\n            filesets = savedFileSets;\n        }\n    }\n    /**\n     * tar a file\n     * @param file the file to tar\n     * @param tOut the output stream\n     * @param vPath the path name of the file to tar\n     * @param tarFileSet the fileset that the file came from.\n     * @throws IOException on error\n     */\n    protected void tarFile(final File file, final TarOutputStream tOut, final String vPath,\n                           final TarFileSet tarFileSet)\n        throws IOException {\n        if (file.equals(tarFile)) {\n            // If the archive is built for the first time and it is\n            // matched by a resource collection, then it hasn't been\n            // found in check (it hasn't been there) but will be\n            // included now.\n            //\n            // for some strange reason the old code would simply skip\n            // the entry and not fail, do the same now for backwards\n            // compatibility reasons.  Without this, the which4j build\n            // fails in Gump\n            return;\n        }\n        tarResource(new FileResource(file), tOut, vPath, tarFileSet);\n    }\n    /**\n     * tar a resource\n     * @param r the resource to tar\n     * @param tOut the output stream\n     * @param vPath the path name of the file to tar\n     * @param tarFileSet the fileset that the file came from, may be null.\n     * @throws IOException on error\n     * @since Ant 1.7\n     */\n    protected void tarResource(final Resource r, final TarOutputStream tOut, String vPath,\n                               final TarFileSet tarFileSet)\n        throws IOException {\n        if (!r.isExists()) {\n            return;\n        }\n        boolean preserveLeadingSlashes = false;\n        if (tarFileSet != null) {\n            final String fullpath = tarFileSet.getFullpath(this.getProject());\n            if (fullpath.isEmpty()) {\n                // don't add \"\" to the archive\n                if (vPath.isEmpty()) {\n                    return;\n                }\n                String prefix = tarFileSet.getPrefix(this.getProject());\n                // '/' is appended for compatibility with the zip task.\n                if (!prefix.isEmpty() && !prefix.endsWith(\"/\")) {\n                    prefix += \"/\";\n                }\n                vPath = prefix + vPath;\n            } else {\n                vPath = fullpath;\n            }\n            preserveLeadingSlashes = tarFileSet.getPreserveLeadingSlashes();\n            if (vPath.startsWith(\"/\") && !preserveLeadingSlashes) {\n                final int l = vPath.length();\n                if (l <= 1) {\n                    // we would end up adding \"\" to the archive\n                    return;\n                }\n                vPath = vPath.substring(1, l);\n            }\n        }\n        if (r.isDirectory() && !vPath.endsWith(\"/\")) {\n            vPath += \"/\";\n        }\n        if (vPath.length() >= TarConstants.NAMELEN) {\n            if (longFileMode.isOmitMode()) {\n                log(\"Omitting: \" + vPath, Project.MSG_INFO);\n                return;\n            } else if (longFileMode.isWarnMode()) {\n                log(\"Entry: \" + vPath + \" longer than \"\n                    + TarConstants.NAMELEN + \" characters.\",\n                    Project.MSG_WARN);\n                if (!longWarningGiven) {\n                    log(\"Resulting tar file can only be processed \"\n                        + \"successfully by GNU compatible tar commands\",\n                        Project.MSG_WARN);\n                    longWarningGiven = true;\n                }\n            } else if (longFileMode.isFailMode()) {\n                throw new BuildException(\"Entry: \" + vPath\n                        + \" longer than \" + TarConstants.NAMELEN\n                        + \"characters.\", getLocation());\n            }\n        }\n        final TarEntry te = new TarEntry(vPath, preserveLeadingSlashes);\n        te.setModTime(r.getLastModified());\n        // preserve permissions\n        if (r instanceof ArchiveResource) {\n            final ArchiveResource ar = (ArchiveResource) r;\n            te.setMode(ar.getMode());\n            if (r instanceof TarResource) {\n                final TarResource tr = (TarResource) r;\n                te.setUserName(tr.getUserName());\n                te.setUserId(tr.getLongUid());\n                te.setGroupName(tr.getGroup());\n                te.setGroupId(tr.getLongGid());\n            }\n        }\n        if (!r.isDirectory()) {\n            if (r.size() > TarConstants.MAXSIZE) {\n                throw new BuildException(\n                    \"Resource: \" + r + \" larger than \"\n                    + TarConstants.MAXSIZE + \" bytes.\");\n            }\n            te.setSize(r.getSize());\n            // override permissions if set explicitly\n            if (tarFileSet != null && tarFileSet.hasFileModeBeenSet()) {\n                te.setMode(tarFileSet.getMode());\n            }\n        } else if (tarFileSet != null && tarFileSet.hasDirModeBeenSet()) {\n            // override permissions if set explicitly\n            te.setMode(tarFileSet.getDirMode(this.getProject()));\n        }\n        if (tarFileSet != null) {\n            // only override permissions if set explicitly\n            if (tarFileSet.hasUserNameBeenSet()) {\n                te.setUserName(tarFileSet.getUserName());\n            }\n            if (tarFileSet.hasGroupBeenSet()) {\n                te.setGroupName(tarFileSet.getGroup());\n            }\n            if (tarFileSet.hasUserIdBeenSet()) {\n                te.setUserId(tarFileSet.getUid());\n            }\n            if (tarFileSet.hasGroupIdBeenSet()) {\n                te.setGroupId(tarFileSet.getGid());\n            }\n        }\n        InputStream in = null;\n        try {\n            tOut.putNextEntry(te);\n            if (!r.isDirectory()) {\n                in = r.getInputStream();\n                final byte[] buffer = new byte[BUFFER_SIZE];\n                int count = 0;\n                do {\n                    tOut.write(buffer, 0, count);\n                    count = in.read(buffer, 0, buffer.length);\n                } while (count != -1);\n            }\n            tOut.closeEntry();\n        } finally {\n            FileUtils.close(in);\n        }\n    }\n    /**\n     * Is the archive up to date in relationship to a list of files.\n     * @param files the files to check\n     * @return true if the archive is up to date.\n     * @deprecated since 1.5.x.\n     *             use the two-arg version instead.\n     */\n    @Deprecated\n    protected boolean archiveIsUpToDate(final String[] files) {\n        return archiveIsUpToDate(files, baseDir);\n    }\n    /**\n     * Is the archive up to date in relationship to a list of files.\n     * @param files the files to check\n     * @param dir   the base directory for the files.\n     * @return true if the archive is up to date.\n     * @since Ant 1.5.2\n     */\n    protected boolean archiveIsUpToDate(final String[] files, final File dir) {\n        final SourceFileScanner sfs = new SourceFileScanner(this);\n        final MergingMapper mm = new MergingMapper();\n        mm.setTo(tarFile.getAbsolutePath());\n        return sfs.restrict(files, dir, null, mm).length == 0;\n    }\n    /**\n     * Is the archive up to date in relationship to a list of files.\n     * @param r the files to check\n     * @return true if the archive is up to date.\n     * @since Ant 1.7\n     */\n    protected boolean archiveIsUpToDate(final Resource r) {\n        return SelectorUtils.isOutOfDate(new FileResource(tarFile), r,\n                                         FileUtils.getFileUtils()\n                                         .getFileTimestampGranularity());\n    }\n    /**\n     * Whether this task can deal with non-file resources.\n     *\n     * <p>This implementation returns true only if this task is\n     * &lt;tar&gt;.  Any subclass of this class that also wants to\n     * support non-file resources needs to override this method.  We\n     * need to do so for backwards compatibility reasons since we\n     * can't expect subclasses to support resources.</p>\n     * @return true for this task.\n     * @since Ant 1.7\n     */\n<fim_suffix>    protected boolean supportsNonFileResources() {\n        return getClass().equals(Tar.class);\n    }<fim_middle>// function below has no smell\n"}