{"text": "<fim_prefix>    // Namespace related stuff\n    private Map<Integer, Integer> _nsIndex = new HashMap<>();\n    // The initial size of the text buffer\n    private int _size = 0;\n    // Tracks which textnodes are not escaped\n    private BitArray  _dontEscape = null;\n    // The URI to this document\n    // private String _documentURI = null;\n    static private int _documentURIIndex = 0;\n    // The owner Document when the input source is DOMSource.\n    private Document _document;\n    // The Map for org.w3c.dom.Node to node id mapping.\n    // This is only used when the input is a DOMSource and the\n    // buildIdIndex flag is true.\n    private Map<Node, Integer> _node2Ids = null;\n    // True if the input source is a DOMSource.\n    private boolean _hasDOMSource = false;\n    // The DTMManager\n    private XSLTCDTMManager _dtmManager;\n    // Support for access/navigation through org.w3c.dom API\n    private Node[] _nodes;\n    private NodeList[] _nodeLists;\n    // private final static String XML_LANG_ATTRIBUTE = \"http://www.w3.org/XML/1998/namespace:@lang\";\n    /**\n     * Define the origin of the document from which the tree was built\n     */\n    public void setDocumentURI(String uri) {\n        if (uri != null) {\n            setDocumentBaseURI(SystemIDResolver.getAbsoluteURI(uri));\n        }\n    }\n    /**\n     * Returns the origin of the document from which the tree was built\n     */\n    public String getDocumentURI() {\n        String baseURI = getDocumentBaseURI();\n        return (baseURI != null) ? baseURI : \"rtf\" + _documentURIIndex++;\n    }\n    public String getDocumentURI(int node) {\n        return getDocumentURI();\n    }\n    public void setupMapping(String[] names, String[] urisArray,\n                             int[] typesArray, String[] namespaces) {\n        // This method only has a function in DOM adapters\n    }\n    /**\n     * Lookup a namespace URI from a prefix starting at node. This method\n     * is used in the execution of xsl:element when the prefix is not known\n     * at compile time.\n     */\n    public String lookupNamespace(int node, String prefix)\n        throws TransletException\n    {\n        int anode, nsnode;\n        final AncestorIterator ancestors = new AncestorIterator();\n        if (isElement(node)) {\n            ancestors.includeSelf();\n        }\n        ancestors.setStartNode(node);\n        while ((anode = ancestors.next()) != DTM.NULL) {\n            final NamespaceIterator namespaces = new NamespaceIterator();\n            namespaces.setStartNode(anode);\n            while ((nsnode = namespaces.next()) != DTM.NULL) {\n                if (getLocalName(nsnode).equals(prefix)) {\n                    return getNodeValue(nsnode);\n                }\n            }\n        }\n        BasisLibrary.runTimeError(BasisLibrary.NAMESPACE_PREFIX_ERR, prefix);\n        return null;\n    }\n    /**\n     * Returns 'true' if a specific node is an element (of any type)\n     */\n    public boolean isElement(final int node) {\n        return getNodeType(node) == DTM.ELEMENT_NODE;\n    }\n    /**\n     * Returns 'true' if a specific node is an attribute (of any type)\n     */\n    public boolean isAttribute(final int node) {\n        return getNodeType(node) == DTM.ATTRIBUTE_NODE;\n    }\n    /**\n     * Returns the number of nodes in the tree (used for indexing)\n     */\n    public int getSize() {\n        return getNumberOfNodes();\n    }\n    /**\n     * Part of the DOM interface - no function here.\n     */\n    public void setFilter(StripFilter filter) {\n    }\n    /**\n     * Returns true if node1 comes before node2 in document order\n     */\n    public boolean lessThan(int node1, int node2) {\n        if (node1 == DTM.NULL) {\n            return false;\n        }\n        if (node2 == DTM.NULL) {\n            return true;\n        }\n        return (node1 < node2);\n    }\n    /**\n     * Create an org.w3c.dom.Node from a node in the tree\n     */\n    public Node makeNode(int index) {\n        if (_nodes == null) {\n            _nodes = new Node[_namesSize];\n        }\n        int nodeID = makeNodeIdentity(index);\n        if (nodeID < 0) {\n            return null;\n        }\n        else if (nodeID < _nodes.length) {\n            return (_nodes[nodeID] != null) ? _nodes[nodeID]\n                : (_nodes[nodeID] = new DTMNodeProxy((DTM)this, index));\n        }\n        else {\n            return new DTMNodeProxy((DTM)this, index);\n        }\n    }\n    /**\n     * Create an org.w3c.dom.Node from a node in an iterator\n     * The iterator most be started before this method is called\n     */\n    public Node makeNode(DTMAxisIterator iter) {\n        return makeNode(iter.next());\n    }\n    /**\n     * Create an org.w3c.dom.NodeList from a node in the tree\n     */\n    public NodeList makeNodeList(int index) {\n        if (_nodeLists == null) {\n            _nodeLists = new NodeList[_namesSize];\n        }\n        int nodeID = makeNodeIdentity(index);\n        if (nodeID < 0) {\n            return null;\n        }\n        else if (nodeID < _nodeLists.length) {\n            return (_nodeLists[nodeID] != null) ? _nodeLists[nodeID]\n                   : (_nodeLists[nodeID] = new DTMAxisIterNodeList(this,\n                                                 new SingletonIterator(index)));\n    }\n        else {\n            return new DTMAxisIterNodeList(this, new SingletonIterator(index));\n        }\n    }\n    /**\n     * Create an org.w3c.dom.NodeList from a node iterator\n     * The iterator most be started before this method is called\n     */\n    public NodeList makeNodeList(DTMAxisIterator iter) {\n        return new DTMAxisIterNodeList(this, iter);\n    }\n    /**\n     * Iterator that returns the namespace nodes as defined by the XPath data\n     * model for a given node, filtered by extended type ID.\n     */\n    public class TypedNamespaceIterator extends NamespaceIterator {\n        private  String _nsPrefix;\n        /**\n         * Constructor TypedChildrenIterator\n         *\n         *\n         * @param nodeType The extended type ID being requested.\n         */\n        public TypedNamespaceIterator(int nodeType) {\n            super();\n            if(m_expandedNameTable != null){\n                _nsPrefix = m_expandedNameTable.getLocalName(nodeType);\n            }\n        }\n       /**\n        * Get the next node in the iteration.\n        *\n        * @return The next node handle in the iteration, or END.\n        */\n        public int next() {\n            if ((_nsPrefix == null) ||(_nsPrefix.length() == 0) ){\n                return (END);\n            }\n            int node = END;\n            for (node = super.next(); node != END; node = super.next()) {\n                if (_nsPrefix.compareTo(getLocalName(node))== 0) {\n                    return returnNode(node);\n                }\n            }\n            return (END);\n        }\n    }  // end of TypedNamespaceIterator\n    /**************************************************************\n     * This is a specialised iterator for predicates comparing node or\n     * attribute values to variable or parameter values.\n     */\n    private final class NodeValueIterator extends InternalAxisIteratorBase\n    {\n        private DTMAxisIterator _source;\n        private String _value;\n        private boolean _op;\n        private final boolean _isReverse;\n        private int _returnType = RETURN_PARENT;\n        public NodeValueIterator(DTMAxisIterator source, int returnType,\n                                 String value, boolean op)\n        {\n            _source = source;\n            _returnType = returnType;\n            _value = value;\n            _op = op;\n            _isReverse = source.isReverse();\n        }\n        public boolean isReverse()\n        {\n            return _isReverse;\n        }\n        public DTMAxisIterator cloneIterator()\n        {\n            try {\n                NodeValueIterator clone = (NodeValueIterator)super.clone();\n                clone._isRestartable = false;\n                clone._source = _source.cloneIterator();\n                clone._value = _value;\n                clone._op = _op;\n                return clone.reset();\n            }\n            catch (CloneNotSupportedException e) {\n                BasisLibrary.runTimeError(BasisLibrary.ITERATOR_CLONE_ERR,\n                                          e.toString());\n                return null;\n            }\n        }\n        public void setRestartable(boolean isRestartable)\n        {\n            _isRestartable = isRestartable;\n            _source.setRestartable(isRestartable);\n        }\n<fim_suffix>        public DTMAxisIterator reset()\n        {\n            _source.reset();\n            return resetPosition();\n        }<fim_middle>// function below has no smell\n"}