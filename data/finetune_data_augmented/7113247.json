{"text": "<fim_prefix>         */\n        public PasswordProtection(char[] password) {\n            this.password = (password == null) ? null : password.clone();\n        }\n        /**\n         * Gets the password.\n         *\n         * <p>Note that this method returns a reference to the password.\n         * If a clone of the array is created it is the caller's\n         * responsibility to zero out the password information\n         * after it is no longer needed.\n         *\n         * @see #destroy()\n         * @return the password, which may be <code>null</code>\n         * @exception IllegalStateException if the password has\n         *              been cleared (destroyed)\n         */\n        public synchronized char[] getPassword() {\n            if (destroyed) {\n                throw new IllegalStateException(\"password has been cleared\");\n            }\n            return password;\n        }\n        /**\n         * Clears the password.\n         *\n         * @exception DestroyFailedException if this method was unable\n         *      to clear the password\n         */\n        public synchronized void destroy()\n                throws javax.security.auth.DestroyFailedException {\n            destroyed = true;\n            if (password != null) {\n                Arrays.fill(password, ' ');\n            }\n        }\n        /**\n         * Determines if password has been cleared.\n         *\n         * @return true if the password has been cleared, false otherwise\n         */\n        public synchronized boolean isDestroyed() {\n            return destroyed;\n        }\n    }\n    /**\n     * A ProtectionParameter encapsulating a CallbackHandler.\n     *\n     * @since 1.5\n     */\n    public static class CallbackHandlerProtection\n            implements ProtectionParameter {\n        private final CallbackHandler handler;\n        /**\n         * Constructs a new CallbackHandlerProtection from a\n         * CallbackHandler.\n         *\n         * @param handler the CallbackHandler\n         * @exception NullPointerException if handler is null\n         */\n        public CallbackHandlerProtection(CallbackHandler handler) {\n            if (handler == null) {\n                throw new NullPointerException(\"handler must not be null\");\n            }\n            this.handler = handler;\n        }\n        /**\n         * Returns the CallbackHandler.\n         *\n         * @return the CallbackHandler.\n         */\n        public CallbackHandler getCallbackHandler() {\n            return handler;\n        }\n    }\n    /**\n     * A marker interface for <code>KeyStore</code> entry types.\n     *\n     * @since 1.5\n     */\n    public static interface Entry { }\n    /**\n     * A <code>KeyStore</code> entry that holds a <code>PrivateKey</code>\n     * and corresponding certificate chain.\n     *\n     * @since 1.5\n     */\n    public static final class PrivateKeyEntry implements Entry {\n        private final PrivateKey privKey;\n        private final Certificate[] chain;\n        /**\n         * Constructs a <code>PrivateKeyEntry</code> with a\n         * <code>PrivateKey</code> and corresponding certificate chain.\n         *\n         * <p> The specified <code>chain</code> is cloned before it is stored\n         * in the new <code>PrivateKeyEntry</code> object.\n         *\n         * @param privateKey the <code>PrivateKey</code>\n         * @param chain an array of <code>Certificate</code>s\n         *      representing the certificate chain.\n         *      The chain must be ordered and contain a\n         *      <code>Certificate</code> at index 0\n         *      corresponding to the private key.\n         *\n         * @exception NullPointerException if\n         *      <code>privateKey</code> or <code>chain</code>\n         *      is <code>null</code>\n         * @exception IllegalArgumentException if the specified chain has a\n         *      length of 0, if the specified chain does not contain\n         *      <code>Certificate</code>s of the same type,\n         *      or if the <code>PrivateKey</code> algorithm\n         *      does not match the algorithm of the <code>PublicKey</code>\n         *      in the end entity <code>Certificate</code> (at index 0)\n         */\n        public PrivateKeyEntry(PrivateKey privateKey, Certificate[] chain) {\n            if (privateKey == null || chain == null) {\n                throw new NullPointerException(\"invalid null input\");\n            }\n            if (chain.length == 0) {\n                throw new IllegalArgumentException\n                                (\"invalid zero-length input chain\");\n            }\n            Certificate[] clonedChain = chain.clone();\n            String certType = clonedChain[0].getType();\n            for (int i = 1; i < clonedChain.length; i++) {\n                if (!certType.equals(clonedChain[i].getType())) {\n                    throw new IllegalArgumentException\n                                (\"chain does not contain certificates \" +\n                                \"of the same type\");\n                }\n            }\n            if (!privateKey.getAlgorithm().equals\n                        (clonedChain[0].getPublicKey().getAlgorithm())) {\n                throw new IllegalArgumentException\n                                (\"private key algorithm does not match \" +\n                                \"algorithm of public key in end entity \" +\n                                \"certificate (at index 0)\");\n            }\n            this.privKey = privateKey;\n            if (clonedChain[0] instanceof X509Certificate &&\n                !(clonedChain instanceof X509Certificate[])) {\n                this.chain = new X509Certificate[clonedChain.length];\n                System.arraycopy(clonedChain, 0,\n                                this.chain, 0, clonedChain.length);\n            } else {\n                this.chain = clonedChain;\n            }\n        }\n        /**\n         * Gets the <code>PrivateKey</code> from this entry.\n         *\n         * @return the <code>PrivateKey</code> from this entry\n         */\n        public PrivateKey getPrivateKey() {\n            return privKey;\n        }\n        /**\n         * Gets the <code>Certificate</code> chain from this entry.\n         *\n         * <p> The stored chain is cloned before being returned.\n         *\n         * @return an array of <code>Certificate</code>s corresponding\n         *      to the certificate chain for the public key.\n         *      If the certificates are of type X.509,\n         *      the runtime type of the returned array is\n         *      <code>X509Certificate[]</code>.\n         */\n        public Certificate[] getCertificateChain() {\n            return chain.clone();\n        }\n        /**\n         * Gets the end entity <code>Certificate</code>\n         * from the certificate chain in this entry.\n         *\n         * @return the end entity <code>Certificate</code> (at index 0)\n         *      from the certificate chain in this entry.\n         *      If the certificate is of type X.509,\n         *      the runtime type of the returned certificate is\n         *      <code>X509Certificate</code>.\n         */\n        public Certificate getCertificate() {\n            return chain[0];\n        }\n        /**\n         * Returns a string representation of this PrivateKeyEntry.\n         * @return a string representation of this PrivateKeyEntry.\n         */\n        public String toString() {\n            StringBuilder sb = new StringBuilder();\n            sb.append(\"Private key entry and certificate chain with \"\n                + chain.length + \" elements:\\r\\n\");\n            for (Certificate cert : chain) {\n                sb.append(cert);\n                sb.append(\"\\r\\n\");\n            }\n            return sb.toString();\n        }\n    }\n    /**\n     * A <code>KeyStore</code> entry that holds a <code>SecretKey</code>.\n     *\n     * @since 1.5\n     */\n<fim_suffix>    public static final class SecretKeyEntry implements Entry {\n        private final SecretKey sKey;\n        /**\n         * Constructs a <code>SecretKeyEntry</code> with a\n         * <code>SecretKey</code>.\n         *\n         * @param secretKey the <code>SecretKey</code>\n         *\n         * @exception NullPointerException if <code>secretKey</code>\n         *      is <code>null</code>\n         */\n        public SecretKeyEntry(SecretKey secretKey) {\n            if (secretKey == null) {\n                throw new NullPointerException(\"invalid null input\");\n            }\n            this.sKey = secretKey;\n        }\n        /**\n         * Gets the <code>SecretKey</code> from this entry.\n         *\n         * @return the <code>SecretKey</code> from this entry\n         */\n        public SecretKey getSecretKey() {\n            return sKey;\n        }\n        /**\n         * Returns a string representation of this SecretKeyEntry.\n         * @return a string representation of this SecretKeyEntry.\n         */\n        public String toString() {\n            return \"Secret key entry with algorithm \" + sKey.getAlgorithm();\n        }\n    }<fim_middle>// class below is data class\n"}