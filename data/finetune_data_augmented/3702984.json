{"text": "<fim_prefix>\n<fim_suffix>public class PhTypeUtil {\n    public static byte[] toBytes(Object v, PhType phType) {\n        if (v == null) return null;\n        byte[] b = null;\n        if (phType == PhType.DEFAULT) {\n            PhType phType1 = PhType.getType(v.getClass());\n            if (phType1 != null && phType1 != PhType.DEFAULT) {\n                toBytes(v, phType1);\n            }\n        } else if (phType == PhType.INTEGER) {\n            b = new byte[Bytes.SIZEOF_INT];\n            encodeInt(((Number) v).intValue(), b, 0);\n        } else if (phType == PhType.UNSIGNED_INT) {\n            b = new byte[Bytes.SIZEOF_INT];\n            encodeUnsignedInt(((Number) v).intValue(), b, 0);\n        } else if (phType == PhType.BIGINT) {\n            b = new byte[Bytes.SIZEOF_LONG];\n            encodeLong(((Number) v).longValue(), b, 0);\n        } else if (phType == PhType.UNSIGNED_LONG) {\n            b = new byte[Bytes.SIZEOF_LONG];\n            encodeUnsignedLong(((Number) v).longValue(), b, 0);\n        } else if (phType == PhType.SMALLINT) {\n            b = new byte[Bytes.SIZEOF_SHORT];\n            encodeShort(((Number) v).shortValue(), b, 0);\n        } else if (phType == PhType.UNSIGNED_SMALLINT) {\n            b = new byte[Bytes.SIZEOF_SHORT];\n            encodeUnsignedShort(((Number) v).shortValue(), b, 0);\n        } else if (phType == PhType.TINYINT) {\n            b = new byte[Bytes.SIZEOF_BYTE];\n            encodeByte(((Number) v).byteValue(), b, 0);\n        } else if (phType == PhType.UNSIGNED_TINYINT) {\n            b = new byte[Bytes.SIZEOF_BYTE];\n            encodeUnsignedByte(((Number) v).byteValue(), b, 0);\n        } else if (phType == PhType.FLOAT) {\n            b = new byte[Bytes.SIZEOF_FLOAT];\n            encodeFloat(((Number) v).floatValue(), b, 0);\n        } else if (phType == PhType.UNSIGNED_FLOAT) {\n            b = new byte[Bytes.SIZEOF_FLOAT];\n            encodeUnsignedFloat(((Number) v).floatValue(), b, 0);\n        } else if (phType == PhType.DOUBLE) {\n            b = new byte[Bytes.SIZEOF_DOUBLE];\n            encodeDouble(((Number) v).doubleValue(), b, 0);\n        } else if (phType == PhType.UNSIGNED_DOUBLE) {\n            b = new byte[Bytes.SIZEOF_DOUBLE];\n            encodeUnsignedDouble(((Number) v).doubleValue(), b, 0);\n        } else if (phType == PhType.BOOLEAN) {\n            if ((Boolean) v) {\n                b = new byte[] { 1 };\n            } else {\n                b = new byte[] { 0 };\n            }\n        } else if (phType == PhType.TIME || phType == PhType.DATE) {\n            b = new byte[Bytes.SIZEOF_LONG];\n            encodeDate(v, b, 0);\n        } else if (phType == PhType.TIMESTAMP) {\n            b = new byte[Bytes.SIZEOF_LONG + Bytes.SIZEOF_INT];\n            encodeTimestamp(v, b, 0);\n        } else if (phType == PhType.UNSIGNED_TIME || phType == PhType.UNSIGNED_DATE) {\n            b = new byte[Bytes.SIZEOF_LONG];\n            encodeUnsignedDate(v, b, 0);\n        } else if (phType == PhType.UNSIGNED_TIMESTAMP) {\n            b = new byte[Bytes.SIZEOF_LONG + Bytes.SIZEOF_INT];\n            encodeUnsignedTimestamp(v, b, 0);\n        } else if (phType == PhType.VARBINARY) {\n            b = (byte[]) v;\n        } else if (phType == PhType.VARCHAR) {\n            b = Bytes.toBytes(v.toString());\n        } else if (phType == PhType.DECIMAL) {\n            if (v instanceof BigDecimal) {\n                b = encodeDecimal(v);\n            } else if (v instanceof Number) {\n                b = encodeDecimal(new BigDecimal(v.toString()));\n            }\n        }\n        return b;\n    }\n    public static Object toObject(byte[] b, PhType phType) {\n        if (b == null) return null;\n        Object v = null;\n        if (phType == PhType.INTEGER) {\n            v = decodeInt(b, 0);\n        } else if (phType == PhType.UNSIGNED_INT) {\n            v = decodeUnsignedInt(b, 0);\n        } else if (phType == PhType.BIGINT) {\n            v = decodeLong(b, 0);\n        } else if (phType == PhType.UNSIGNED_LONG) {\n            v = decodeUnsignedLong(b, 0);\n        } else if (phType == PhType.SMALLINT) {\n            v = decodeShort(b, 0);\n        } else if (phType == PhType.UNSIGNED_SMALLINT) {\n            v = decodeUnsignedShort(b, 0);\n        } else if (phType == PhType.TINYINT) {\n            v = decodeByte(b, 0);\n        } else if (phType == PhType.UNSIGNED_TINYINT) {\n            v = decodeUnsignedByte(b, 0);\n        } else if (phType == PhType.FLOAT) {\n            v = decodeFloat(b, 0);\n        } else if (phType == PhType.UNSIGNED_FLOAT) {\n            v = decodeUnsignedFloat(b, 0);\n        } else if (phType == PhType.DOUBLE) {\n            v = decodeDouble(b, 0);\n        } else if (phType == PhType.UNSIGNED_DOUBLE) {\n            v = decodeUnsignedDouble(b, 0);\n        } else if (phType == PhType.BOOLEAN) {\n            checkForSufficientLength(b, 0, Bytes.SIZEOF_BOOLEAN);\n            if (b[0] == 1) {\n                v = true;\n            } else if (b[0] == 0) {\n                v = false;\n            }\n        } else if (phType == PhType.DATE) {\n            v = new java.sql.Date(decodeLong(b, 0));\n        } else if (phType == PhType.TIME) {\n            v = new java.sql.Time(decodeLong(b, 0));\n        } else if (phType == PhType.TIMESTAMP) {\n            long millisDeserialized = decodeLong(b, 0);\n            Timestamp ts = new Timestamp(millisDeserialized);\n            int nanosDeserialized = decodeUnsignedInt(b, Bytes.SIZEOF_LONG);\n            ts.setNanos(nanosDeserialized < 1000000 ? ts.getNanos() + nanosDeserialized : nanosDeserialized);\n            v = ts;\n        } else if (phType == PhType.UNSIGNED_TIME || phType == PhType.UNSIGNED_DATE) {\n            v = new Date(decodeUnsignedLong(b, 0));\n        } else if (phType == PhType.UNSIGNED_TIMESTAMP) {\n            long millisDeserialized = decodeUnsignedLong(b, 0);\n            Timestamp ts = new Timestamp(millisDeserialized);\n            int nanosDeserialized = decodeUnsignedInt(b, Bytes.SIZEOF_LONG);\n            ts.setNanos(nanosDeserialized < 1000000 ? ts.getNanos() + nanosDeserialized : nanosDeserialized);\n            v = ts;\n        } else if (phType == PhType.VARBINARY) {\n            v = b;\n        } else if (phType == PhType.VARCHAR || phType == PhType.DEFAULT) {\n            v = Bytes.toString(b);\n        } else if (phType == PhType.DECIMAL) {\n            v = decodeDecimal(b, 0, b.length);\n        }\n        return v;\n    }\n    private static int decodeInt(byte[] bytes, int o) {\n        checkForSufficientLength(bytes, o, Bytes.SIZEOF_INT);\n        int v;\n        v = bytes[o] ^ 0x80; // Flip sign bit back\n        for (int i = 1; i < Bytes.SIZEOF_INT; i++) {\n            v = (v << 8) + (bytes[o + i] & 0xff);\n        }\n        return v;\n    }\n    private static int encodeInt(int v, byte[] b, int o) {\n        checkForSufficientLength(b, o, Bytes.SIZEOF_INT);\n        b[o + 0] = (byte) ((v >> 24) ^ 0x80); // Flip sign bit so that INTEGER\n                                              // is binary comparable\n        b[o + 1] = (byte) (v >> 16);<fim_middle>// class below is blob\n"}