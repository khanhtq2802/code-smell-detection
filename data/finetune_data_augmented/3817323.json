{"text": "<fim_prefix>        throw new RuntimeException(e);\n      }\n    }\n    private synchronized CompletableFuture<ProcessedFiles> updateFuture() {\n      if (future.isDone()) {\n        if (!future.isCancelled() && !future.isCompletedExceptionally()) {\n          ProcessedFiles pf = _get();\n          if (pf.failedFiles.size() > 0) {\n            initiateProcessing(pf);\n          }\n        }\n      }\n      return future;\n    }\n    synchronized void initiateProcessing() {\n      Preconditions.checkState(future == null);\n      initiateProcessing(null);\n    }\n    @Override\n    public synchronized boolean cancel(boolean mayInterruptIfRunning) {\n      boolean canceled = future.cancel(mayInterruptIfRunning);\n      if (canceled) {\n        cancelFlag.set(true);\n      }\n      return canceled;\n    }\n    @Override\n    public synchronized boolean isCancelled() {\n      return future.isCancelled();\n    }\n    @Override\n    public synchronized boolean isDone() {\n      updateFuture();\n      if (future.isDone()) {\n        if (future.isCancelled() || future.isCompletedExceptionally()) {\n          return true;\n        }\n        ProcessedFiles pf = _get();\n        if (pf.failedFiles.size() == 0) {\n          return true;\n        } else {\n          updateFuture();\n        }\n      }\n      return false;\n    }\n    @Override\n    public SummaryCollection get() throws InterruptedException, ExecutionException {\n      CompletableFuture<ProcessedFiles> futureRef = updateFuture();\n      ProcessedFiles processedFiles = futureRef.get();\n      while (processedFiles.failedFiles.size() > 0) {\n        futureRef = updateFuture();\n        processedFiles = futureRef.get();\n      }\n      return processedFiles.summaries;\n    }\n    @Override\n    public SummaryCollection get(long timeout, TimeUnit unit)\n        throws InterruptedException, ExecutionException, TimeoutException {\n      long nanosLeft = unit.toNanos(timeout);\n      long t1, t2;\n      CompletableFuture<ProcessedFiles> futureRef = updateFuture();\n      t1 = System.nanoTime();\n      ProcessedFiles processedFiles = futureRef.get(Long.max(1, nanosLeft), TimeUnit.NANOSECONDS);\n      t2 = System.nanoTime();\n      nanosLeft -= (t2 - t1);\n      while (processedFiles.failedFiles.size() > 0) {\n        futureRef = updateFuture();\n        t1 = System.nanoTime();\n        processedFiles = futureRef.get(Long.max(1, nanosLeft), TimeUnit.NANOSECONDS);\n        t2 = System.nanoTime();\n        nanosLeft -= (t2 - t1);\n      }\n      return processedFiles.summaries;\n    }\n  }\n  /**\n   * This methods reads a subset of file paths into memory and groups them by location. Then it\n   * request summaries for files from each location/tablet server.\n   */\n  public Future<SummaryCollection> processPartition(ExecutorService execSrv, int modulus,\n      int remainder) {\n    PartitionFuture future = new PartitionFuture(TraceUtil.traceInfo(), execSrv, modulus,\n        remainder);\n    future.initiateProcessing();\n    return future;\n  }\n  public interface FileSystemResolver {\n    FileSystem get(Path file);\n  }\n  /**\n   * This method will read summaries from a set of files.\n   */\n  public Future<SummaryCollection> processFiles(FileSystemResolver volMgr,\n      Map<String,List<TRowRange>> files, BlockCache summaryCache, BlockCache indexCache,\n      Cache<String,Long> fileLenCache, ExecutorService srp) {\n    List<CompletableFuture<SummaryCollection>> futures = new ArrayList<>();\n    for (Entry<String,List<TRowRange>> entry : files.entrySet()) {\n      futures.add(CompletableFuture.supplyAsync(() -> {\n        List<RowRange> rrl = Lists.transform(entry.getValue(), RowRange::new);\n        return getSummaries(volMgr, entry.getKey(), rrl, summaryCache, indexCache, fileLenCache);\n      }, srp));\n    }\n    return CompletableFutureUtil.merge(futures,\n        (sc1, sc2) -> SummaryCollection.merge(sc1, sc2, factory), SummaryCollection::new);\n  }\n  private int countFiles() {\n    // TODO use a batch scanner + iterator to parallelize counting files\n    return TabletsMetadata.builder().forTable(tableId).overlapping(startRow, endRow).fetchFiles()\n        .fetchPrev().build(ctx).stream().mapToInt(tm -> tm.getFiles().size()).sum();\n  }\n  private class GatherRequest implements Supplier<SummaryCollection> {\n    private int remainder;\n    private int modulus;\n    private TInfo tinfo;\n    private AtomicBoolean cancelFlag;\n    GatherRequest(TInfo tinfo, int remainder, int modulus, AtomicBoolean cancelFlag) {\n      this.remainder = remainder;\n      this.modulus = modulus;\n      this.tinfo = tinfo;\n      this.cancelFlag = cancelFlag;\n    }\n    @Override\n    public SummaryCollection get() {\n      TSummaryRequest req = getRequest();\n      TSummaries tSums;\n      try {\n        tSums = ServerClient.execute(ctx, new TabletClientService.Client.Factory(), client -> {\n          TSummaries tsr = client.startGetSummariesForPartition(tinfo, ctx.rpcCreds(), req, modulus,\n              remainder);\n          while (!tsr.finished && !cancelFlag.get()) {\n            tsr = client.contiuneGetSummaries(tinfo, tsr.sessionId);\n          }\n          return tsr;\n        });\n      } catch (AccumuloException | AccumuloSecurityException e) {\n        throw new RuntimeException(e);\n      }\n      if (cancelFlag.get()) {\n        throw new RuntimeException(\"Operation canceled\");\n      }\n      return new SummaryCollection(tSums);\n    }\n  }\n  public Future<SummaryCollection> gather(ExecutorService es) {\n    int numFiles = countFiles();\n    log.debug(\"Gathering summaries from {} files\", numFiles);\n    if (numFiles == 0) {\n      return CompletableFuture.completedFuture(new SummaryCollection());\n    }\n    // have each tablet server process ~100K files\n    int numRequest = Math.max(numFiles / 100_000, 1);\n    List<CompletableFuture<SummaryCollection>> futures = new ArrayList<>();\n    AtomicBoolean cancelFlag = new AtomicBoolean(false);\n    TInfo tinfo = TraceUtil.traceInfo();\n    for (int i = 0; i < numRequest; i++) {\n      futures.add(\n          CompletableFuture.supplyAsync(new GatherRequest(tinfo, i, numRequest, cancelFlag), es));\n    }\n    Future<SummaryCollection> future = CompletableFutureUtil.merge(futures,\n        (sc1, sc2) -> SummaryCollection.merge(sc1, sc2, factory), SummaryCollection::new);\n    return new CancelFlagFuture<>(future, cancelFlag);\n  }\n  private static Text removeTrailingZeroFromRow(Key k) {\n    if (k != null) {\n      Text t = new Text();\n      ByteSequence row = k.getRowData();\n      Preconditions.checkArgument(row.length() >= 1 && row.byteAt(row.length() - 1) == 0);\n      t.set(row.getBackingArray(), row.offset(), row.length() - 1);\n      return t;\n    } else {\n      return null;\n    }\n  }\n  private RowRange toClippedExtent(Range r) {\n    r = clipRange.clip(r);\n    Text startRow = removeTrailingZeroFromRow(r.getStartKey());\n    Text endRow = removeTrailingZeroFromRow(r.getEndKey());\n    return new RowRange(startRow, endRow);\n  }\n<fim_suffix>  public static class RowRange {\n    private Text startRow;\n    private Text endRow;\n    public RowRange(KeyExtent ke) {\n      this.startRow = ke.getPrevEndRow();\n      this.endRow = ke.getEndRow();\n    }\n    public RowRange(TRowRange trr) {\n      this.startRow = ByteBufferUtil.toText(trr.startRow);\n      this.endRow = ByteBufferUtil.toText(trr.endRow);\n    }\n    public RowRange(Text startRow, Text endRow) {\n      this.startRow = startRow;\n      this.endRow = endRow;\n    }\n    public Range toRange() {\n      return new Range(startRow, false, endRow, true);\n    }\n    public TRowRange toThrift() {\n      return new TRowRange(TextUtil.getByteBuffer(startRow), TextUtil.getByteBuffer(endRow));\n    }\n    public Text getStartRow() {\n      return startRow;\n    }\n    public Text getEndRow() {\n      return endRow;\n    }\n    @Override\n    public String toString() {\n      return startRow + \" \" + endRow;\n    }\n  }<fim_middle>// class below is data class\n"}