{"text": "<fim_prefix>/**\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n *\n */\npackage org.apache.kerby.kerberos.kerb.identity;\n\nimport org.apache.kerby.config.Config;\nimport org.apache.kerby.config.Configured;\nimport org.apache.kerby.kerberos.kerb.KrbException;\nimport org.apache.kerby.kerberos.kerb.request.KdcClientRequest;\nimport org.apache.kerby.kerberos.kerb.request.KrbIdentity;\nimport org.apache.kerby.kerberos.kerb.type.ad.AuthorizationData;\nimport org.apache.kerby.kerberos.kerb.type.ticket.EncTicketPart;\n\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * A cacheable identity backend that provides a cache with FIFO and size limit.\n * Note only limited recently active identities are kept in the cache, and other\n * identities are meant to be loaded from the underlying backend like memory,\n * file, SQL DB, LDAP, and etc.\n */\npublic class CacheableIdentityService\n        extends Configured implements IdentityService {\n\n    private static final int DEFAULT_CACHE_SIZE = 1000;\n\n    private Map<String, KrbIdentity> idCache;\n    private int cacheSize = DEFAULT_CACHE_SIZE;\n\n    private IdentityService underlying;\n\n    public CacheableIdentityService(Config config, IdentityService underlying) {\n        super(config);\n        this.underlying = underlying;\n\n        init();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean supportBatchTrans() {\n        return false;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public BatchTrans startBatchTrans() throws KrbException {\n        throw new KrbException(\"Transaction isn't supported\");\n    }\n\n    private void init() {\n        Map<String, KrbIdentity> tmpMap =\n            new LinkedHashMap<String, KrbIdentity>(cacheSize) {\n                private static final long serialVersionUID = -6911200685333503214L;\n\n                @Override\n                protected boolean removeEldestEntry(Map.Entry<String, KrbIdentity> eldest) {\n                    return size() > cacheSize;\n                }\n            };\n\n        idCache = new ConcurrentHashMap<>(tmpMap);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Iterable<String> getIdentities() throws KrbException {\n        return underlying.getIdentities();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n<fim_suffix>    @Override\n    public KrbIdentity getIdentity(String principalName) throws KrbException {\n        if (idCache.containsKey(principalName)) {\n            return idCache.get(principalName);\n        }\n\n        KrbIdentity identity = underlying.getIdentity(principalName);\n        if (identity != null) {\n            idCache.put(principalName, identity);\n        }\n\n        return identity;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public KrbIdentity addIdentity(KrbIdentity identity) throws KrbException {\n        KrbIdentity added = underlying.addIdentity(identity);\n        if (added != null) {\n            idCache.put(added.getPrincipalName(), added);\n        }\n\n        return added;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public KrbIdentity updateIdentity(KrbIdentity identity) throws KrbException {\n        KrbIdentity updated = underlying.updateIdentity(identity);\n        if (updated != null) {\n            idCache.put(updated.getPrincipalName(), updated);\n        }\n\n        return updated;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void deleteIdentity(String principalName) throws KrbException {\n        if (idCache.containsKey(principalName)) {\n            idCache.remove(principalName);\n        }\n\n        underlying.deleteIdentity(principalName);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public AuthorizationData getIdentityAuthorizationData(KdcClientRequest kdcClientRequest,\n            EncTicketPart encTicketPart) throws KrbException {\n\n        return underlying.getIdentityAuthorizationData(kdcClientRequest,\n                encTicketPart);\n    }\n}<fim_middle>// function below has no smell\n"}