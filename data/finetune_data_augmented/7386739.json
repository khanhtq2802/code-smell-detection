{"text": "<fim_prefix>/*\n * Copyright 2012-2018 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.springframework.boot.context.properties.bind;\nimport java.beans.Introspector;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.function.BiConsumer;\nimport java.util.function.Supplier;\nimport org.springframework.beans.BeanUtils;\nimport org.springframework.boot.context.properties.bind.Binder.Context;\nimport org.springframework.boot.context.properties.source.ConfigurationPropertyName;\nimport org.springframework.boot.context.properties.source.ConfigurationPropertySource;\nimport org.springframework.boot.context.properties.source.ConfigurationPropertyState;\nimport org.springframework.core.MethodParameter;\nimport org.springframework.core.ResolvableType;\n/**\n * {@link BeanBinder} for mutable Java Beans.\n *\n * @author Phillip Webb\n * @author Madhura Bhave\n */\nclass JavaBeanBinder implements BeanBinder {\n\t@Override\n\tpublic <T> T bind(ConfigurationPropertyName name, Bindable<T> target, Context context,\n\t\t\tBeanPropertyBinder propertyBinder) {\n\t\tboolean hasKnownBindableProperties = hasKnownBindableProperties(name, context);\n\t\tBean<T> bean = Bean.get(target, hasKnownBindableProperties);\n\t\tif (bean == null) {\n\t\t\treturn null;\n\t\t}\n\t\tBeanSupplier<T> beanSupplier = bean.getSupplier(target);\n\t\tboolean bound = bind(propertyBinder, bean, beanSupplier);\n\t\treturn (bound ? beanSupplier.get() : null);\n\t}\n\tprivate boolean hasKnownBindableProperties(ConfigurationPropertyName name,\n\t\t\tContext context) {\n\t\tfor (ConfigurationPropertySource source : context.getSources()) {\n\t\t\tif (source.containsDescendantOf(name) == ConfigurationPropertyState.PRESENT) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tprivate <T> boolean bind(BeanPropertyBinder propertyBinder, Bean<T> bean,\n\t\t\tBeanSupplier<T> beanSupplier) {\n\t\tboolean bound = false;\n\t\tfor (BeanProperty beanProperty : bean.getProperties().values()) {\n\t\t\tbound |= bind(beanSupplier, propertyBinder, beanProperty);\n\t\t}\n\t\treturn bound;\n\t}\n\tprivate <T> boolean bind(BeanSupplier<T> beanSupplier,\n\t\t\tBeanPropertyBinder propertyBinder, BeanProperty property) {\n\t\tString propertyName = property.getName();\n\t\tResolvableType type = property.getType();\n\t\tSupplier<Object> value = property.getValue(beanSupplier);\n\t\tAnnotation[] annotations = property.getAnnotations();\n\t\tObject bound = propertyBinder.bindProperty(propertyName,\n\t\t\t\tBindable.of(type).withSuppliedValue(value).withAnnotations(annotations));\n\t\tif (bound == null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (property.isSettable()) {\n\t\t\tproperty.setValue(beanSupplier, bound);\n\t\t}\n\t\telse if (value == null || !bound.equals(value.get())) {\n\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\"No setter found for property: \" + property.getName());\n\t\t}\n\t\treturn true;\n\t}\n\t/**\n\t * The bean being bound.\n\t */\n\tprivate static class Bean<T> {\n\t\tprivate static Bean<?> cached;\n\t\tprivate final Class<?> type;\n\t\tprivate final ResolvableType resolvableType;\n\t\tprivate final Map<String, BeanProperty> properties = new LinkedHashMap<>();\n\t\tBean(ResolvableType resolvableType, Class<?> type) {\n\t\t\tthis.resolvableType = resolvableType;\n\t\t\tthis.type = type;\n\t\t\tputProperties(type);\n\t\t}\n\t\tprivate void putProperties(Class<?> type) {\n\t\t\twhile (type != null && !Object.class.equals(type)) {\n\t\t\t\tfor (Method method : type.getDeclaredMethods()) {\n\t\t\t\t\tif (isCandidate(method)) {\n\t\t\t\t\t\taddMethod(method);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (Field field : type.getDeclaredFields()) {\n\t\t\t\t\taddField(field);\n\t\t\t\t}\n\t\t\t\ttype = type.getSuperclass();\n\t\t\t}\n\t\t}\n\t\tprivate boolean isCandidate(Method method) {\n\t\t\tint modifiers = method.getModifiers();\n\t\t\treturn Modifier.isPublic(modifiers) && !Modifier.isAbstract(modifiers)\n\t\t\t\t\t&& !Modifier.isStatic(modifiers)\n\t\t\t\t\t&& !Object.class.equals(method.getDeclaringClass())\n\t\t\t\t\t&& !Class.class.equals(method.getDeclaringClass());\n\t\t}\n<fim_suffix>\t\tprivate void addMethod(Method method) {\n\t\t\taddMethodIfPossible(method, \"get\", 0, BeanProperty::addGetter);\n\t\t\taddMethodIfPossible(method, \"is\", 0, BeanProperty::addGetter);\n\t\t\taddMethodIfPossible(method, \"set\", 1, BeanProperty::addSetter);\n\t\t}\n\t\tprivate void addMethodIfPossible(Method method, String prefix, int parameterCount,\n\t\t\t\tBiConsumer<BeanProperty, Method> consumer) {\n\t\t\tif (method.getParameterCount() == parameterCount\n\t\t\t\t\t&& method.getName().startsWith(prefix)\n\t\t\t\t\t&& method.getName().length() > prefix.length()) {\n\t\t\t\tString propertyName = Introspector\n\t\t\t\t\t\t.decapitalize(method.getName().substring(prefix.length()));\n\t\t\t\tconsumer.accept(this.properties.computeIfAbsent(propertyName,\n\t\t\t\t\t\tthis::getBeanProperty), method);\n\t\t\t}\n\t\t}\n\t\tprivate BeanProperty getBeanProperty(String name) {\n\t\t\treturn new BeanProperty(name, this.resolvableType);\n\t\t}\n\t\tprivate void addField(Field field) {\n\t\t\tBeanProperty property = this.properties.get(field.getName());\n\t\t\tif (property != null) {\n\t\t\t\tproperty.addField(field);\n\t\t\t}\n\t\t}\n\t\tpublic Class<?> getType() {\n\t\t\treturn this.type;\n\t\t}\n\t\tpublic Map<String, BeanProperty> getProperties() {\n\t\t\treturn this.properties;\n\t\t}\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic BeanSupplier<T> getSupplier(Bindable<T> target) {\n\t\t\treturn new BeanSupplier<>(() -> {\n\t\t\t\tT instance = null;\n\t\t\t\tif (target.getValue() != null) {\n\t\t\t\t\tinstance = target.getValue().get();\n\t\t\t\t}\n\t\t\t\tif (instance == null) {\n\t\t\t\t\tinstance = (T) BeanUtils.instantiateClass(this.type);\n\t\t\t\t}\n\t\t\t\treturn instance;\n\t\t\t});\n\t\t}\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic static <T> Bean<T> get(Bindable<T> bindable, boolean canCallGetValue) {\n\t\t\tClass<?> type = bindable.getType().resolve(Object.class);\n\t\t\tSupplier<T> value = bindable.getValue();\n\t\t\tT instance = null;\n\t\t\tif (canCallGetValue && value != null) {\n\t\t\t\tinstance = value.get();\n\t\t\t\ttype = (instance != null) ? instance.getClass() : type;\n\t\t\t}\n\t\t\tif (instance == null && !isInstantiable(type)) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tBean<?> bean = Bean.cached;\n\t\t\tif (bean == null || !type.equals(bean.getType())) {\n\t\t\t\tbean = new Bean<>(bindable.getType(), type);\n\t\t\t\tcached = bean;\n\t\t\t}\n\t\t\treturn (Bean<T>) bean;\n\t\t}\n\t\tprivate static boolean isInstantiable(Class<?> type) {\n\t\t\tif (type.isInterface()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\ttype.getDeclaredConstructor();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\tprivate static class BeanSupplier<T> implements Supplier<T> {\n\t\tprivate final Supplier<T> factory;\n\t\tprivate T instance;\n\t\tBeanSupplier(Supplier<T> factory) {\n\t\t\tthis.factory = factory;\n\t\t}\n\t\t@Override\n\t\tpublic T get() {\n\t\t\tif (this.instance == null) {\n\t\t\t\tthis.instance = this.factory.get();\n\t\t\t}\n\t\t\treturn this.instance;\n\t\t}\n\t}\n\t/**<fim_middle>// function below has no smell\n"}