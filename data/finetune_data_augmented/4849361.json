{"text": "<fim_prefix>/****************************************************************\n * Licensed to the Apache Software Foundation (ASF) under one   *\n * or more contributor license agreements.  See the NOTICE file *\n * distributed with this work for additional information        *\n * regarding copyright ownership.  The ASF licenses this file   *\n * to you under the Apache License, Version 2.0 (the            *\n * \"License\"); you may not use this file except in compliance   *\n * with the License.  You may obtain a copy of the License at   *\n *                                                              *\n *   http://www.apache.org/licenses/LICENSE-2.0                 *\n *                                                              *\n * Unless required by applicable law or agreed to in writing,   *\n * software distributed under the License is distributed on an  *\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *\n * KIND, either express or implied.  See the License for the    *\n * specific language governing permissions and limitations      *\n * under the License.                                           *\n ****************************************************************/\npackage org.apache.james.mime4j.field.address;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.apache.james.mime4j.codec.DecodeMonitor;\nimport org.apache.james.mime4j.codec.DecoderUtil;\nimport org.apache.james.mime4j.dom.address.Address;\nimport org.apache.james.mime4j.dom.address.AddressList;\nimport org.apache.james.mime4j.dom.address.DomainList;\nimport org.apache.james.mime4j.dom.address.Group;\nimport org.apache.james.mime4j.dom.address.Mailbox;\nimport org.apache.james.mime4j.dom.address.MailboxList;\n/**\n * Transforms the JJTree-generated abstract syntax tree into a graph of\n * org.apache.james.mime4j.dom.address objects.\n */\nclass Builder {\n    private static final Builder singleton = new Builder();\n    public static Builder getInstance() {\n        return singleton;\n    }\n    public AddressList buildAddressList(ASTaddress_list node, DecodeMonitor monitor) throws ParseException {\n        List<Address> list = new ArrayList<Address>();\n        for (int i = 0; i < node.jjtGetNumChildren(); i++) {\n            ASTaddress childNode = (ASTaddress) node.jjtGetChild(i);\n            Address address = buildAddress(childNode, monitor);\n            list.add(address);\n        }\n        return new AddressList(list, true);\n    }\n<fim_suffix>    public Address buildAddress(ASTaddress node, DecodeMonitor monitor) throws ParseException {\n        ChildNodeIterator it = new ChildNodeIterator(node);\n        Node n = it.next();\n        if (n instanceof ASTaddr_spec) {\n            return buildAddrSpec((ASTaddr_spec) n);\n        } else if (n instanceof ASTangle_addr) {\n            return buildAngleAddr((ASTangle_addr) n);\n        } else if (n instanceof ASTphrase) {\n            String name = buildString((ASTphrase) n, false);\n            Node n2 = it.next();\n            if (n2 instanceof ASTgroup_body) {\n                return new Group(name, buildGroupBody((ASTgroup_body) n2, monitor));\n            } else if (n2 instanceof ASTangle_addr) {\n                try {\n                    name = DecoderUtil.decodeEncodedWords(name, monitor);\n                } catch (IllegalArgumentException e) {\n                    throw new ParseException(e);\n                }\n                Mailbox mb = buildAngleAddr((ASTangle_addr) n2);\n                return new Mailbox(name, mb.getRoute(), mb.getLocalPart(),\n                        mb.getDomain());\n            } else {\n                throw new ParseException(\"Address \\\"group_body\\\" or \\\"angle_addr\\\" is expected but got \\\"\" + n + \"\\\"\");\n            }\n        } else {\n            throw new ParseException(\"Address \\\"phrase\\\" is expected but got \\\"\" + n + \"\\\"\");\n        }\n    }\n    private MailboxList buildGroupBody(ASTgroup_body node, DecodeMonitor monitor) throws ParseException {\n        List<Mailbox> results = new ArrayList<Mailbox>();\n        ChildNodeIterator it = new ChildNodeIterator(node);\n        while (it.hasNext()) {\n            Node n = it.next();\n            if (n instanceof ASTmailbox)\n                results.add(buildMailbox((ASTmailbox) n, monitor));\n            else\n                throw new ParseException(\"Address \\\"mailbox\\\" is expected but got \\\"\" + n + \"\\\"\");\n        }\n        return new MailboxList(results, true);\n    }\n    public Mailbox buildMailbox(ASTmailbox node, DecodeMonitor monitor) throws ParseException {\n        ChildNodeIterator it = new ChildNodeIterator(node);\n        Node n = it.next();\n        if (n instanceof ASTaddr_spec) {\n            return buildAddrSpec((ASTaddr_spec) n);\n        } else if (n instanceof ASTangle_addr) {\n            return buildAngleAddr((ASTangle_addr) n);\n        } else if (n instanceof ASTname_addr) {\n            return buildNameAddr((ASTname_addr) n, monitor);\n        } else {\n            throw new ParseException(\"Address \\\"addr_spec\\\" or \\\"angle_addr\\\" or \\\"name_addr\\\" is expected but got \\\"\" + n + \"\\\"\");\n        }\n    }\n    private Mailbox buildNameAddr(ASTname_addr node, DecodeMonitor monitor) throws ParseException {\n        ChildNodeIterator it = new ChildNodeIterator(node);\n        Node n = it.next();\n        String name;\n        if (n instanceof ASTphrase) {\n            name = buildString((ASTphrase) n, false);\n        } else {\n            throw new ParseException(\"Address \\\"phrase\\\" is expected but got \\\"\" + n + \"\\\"\");\n        }\n        n = it.next();\n        if (n instanceof ASTangle_addr) {\n            try {\n                name = DecoderUtil.decodeEncodedWords(name, monitor);\n            } catch (IllegalArgumentException e) {\n                throw new ParseException(e);\n            }\n            Mailbox mb = buildAngleAddr((ASTangle_addr) n);\n            return new Mailbox(name, mb.getRoute(), mb.getLocalPart(),\n                    mb.getDomain());\n        } else {\n            throw new ParseException(\"Address \\\"angle_addr\\\" is expected but got \\\"\" + n + \"\\\"\");\n        }\n    }\n    private Mailbox buildAngleAddr(ASTangle_addr node) throws ParseException {\n        ChildNodeIterator it = new ChildNodeIterator(node);\n        DomainList route = null;\n        Node n = it.next();\n        if (n instanceof ASTroute) {\n            route = buildRoute((ASTroute) n);\n            n = it.next();\n        } else if (n instanceof ASTaddr_spec) {\n            // do nothing\n        }\n        else\n            throw new ParseException(\"Address \\\"route\\\" or \\\"addr_spec\\\" is expected but got \\\"\" + n + \"\\\"\");\n        if (n instanceof ASTaddr_spec)\n            return buildAddrSpec(route, (ASTaddr_spec) n);\n        else\n            throw new ParseException(\"Address \\\"addr_spec\\\" is expected but got \\\"\" + n + \"\\\"\");\n    }\n    private DomainList buildRoute(ASTroute node) throws ParseException {\n        List<String> results = new ArrayList<String>(node.jjtGetNumChildren());\n        ChildNodeIterator it = new ChildNodeIterator(node);\n        while (it.hasNext()) {\n            Node n = it.next();\n            if (n instanceof ASTdomain)\n                results.add(buildString((ASTdomain) n, true));\n            else\n                throw new ParseException(\"Address \\\"domain\\\" is expected but got \\\"\" + n + \"\\\"\");\n        }\n        return new DomainList(results);\n    }\n    private Mailbox buildAddrSpec(ASTaddr_spec node) {\n        return buildAddrSpec(null, node);\n    }\n    private Mailbox buildAddrSpec(DomainList route, ASTaddr_spec node) {\n        ChildNodeIterator it = new ChildNodeIterator(node);\n        String localPart = buildString((ASTlocal_part) it.next(), true);\n        String domain = buildString((ASTdomain) it.next(), true);\n        return new Mailbox(route, localPart, domain);\n    }\n    private String buildString(SimpleNode node, boolean stripSpaces) {\n        Token head = node.firstToken;\n        Token tail = node.lastToken;\n        StringBuilder out = new StringBuilder();\n        while (head != tail) {\n            out.append(head.image);\n            head = head.next;\n            if (!stripSpaces)\n                addSpecials(out, head.specialToken);\n        }\n        out.append(tail.image);\n        return out.toString();\n    }\n    private void addSpecials(StringBuilder out, Token specialToken) {\n        if (specialToken != null) {\n            addSpecials(out, specialToken.specialToken);\n            out.append(specialToken.image);\n        }\n    }\n    private static class ChildNodeIterator implements Iterator<Node> {\n        private final SimpleNode simpleNode;\n        private int index;\n        private final int len;\n        public ChildNodeIterator(SimpleNode simpleNode) {\n            this.simpleNode = simpleNode;\n            this.len = simpleNode.jjtGetNumChildren();\n            this.index = 0;\n        }\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n        public boolean hasNext() {\n            return index < len;<fim_middle>// function below has no smell\n"}