{"text": "<fim_prefix>/*\n * Copyright (C) 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.caliper.runner.target;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport com.google.caliper.runner.config.CaliperConfig;\nimport com.google.caliper.runner.config.DeviceConfig;\nimport com.google.caliper.runner.config.VmConfig;\nimport com.google.caliper.runner.config.VmType;\nimport com.google.caliper.runner.options.CaliperOptions;\nimport com.google.caliper.runner.options.ParsedOptions;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.base.Joiner;\nimport com.google.common.base.Optional;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport java.io.File;\nimport java.io.InputStream;\nimport java.util.Map;\nimport javax.inject.Inject;\nimport javax.inject.Singleton;\n/** {@link Device} for the local machine. */\n@Singleton\npublic final class LocalDevice extends Device {\n  /**\n   * Returns whether or not we're currently running on an Android device.\n   *\n   * <p>This is temporary until we stop supporting running Caliper directly on Android devices.\n   */\n  private static boolean isAndroidDevice() {\n    return System.getProperty(\"java.vendor\").toLowerCase().contains(\"android\");\n  }\n  private static final Joiner ARG_JOINER = Joiner.on(' ');\n  private final CaliperConfig caliperConfig; // for legacy options\n  private final boolean redirectErrorStream;\n  private final Helper helper;\n  @Inject\n  LocalDevice(\n      DeviceConfig config,\n      CaliperConfig caliperConfig,\n      CaliperOptions caliperOptions,\n      ShutdownHookRegistrar shutdownHookRegistrar) {\n    this(config, caliperConfig, caliperOptions, shutdownHookRegistrar, false);\n  }\n  private LocalDevice(\n      DeviceConfig config,\n      CaliperConfig caliperConfig,\n      CaliperOptions caliperOptions,\n      ShutdownHookRegistrar shutdownHookRegistrar,\n      boolean redirectErrorStream) {\n    super(config, shutdownHookRegistrar);\n    this.caliperConfig = caliperConfig;\n    this.redirectErrorStream = redirectErrorStream;\n    this.helper =\n        isAndroidDevice()\n            ? new AndroidDeviceHelper(caliperOptions)\n            : new NonAndroidDeviceHelper(caliperOptions);\n  }\n  @Override\n  protected void startUp() {\n    helper.setUp();\n  }\n  @Override\n  protected void shutDown() {}\n  @Override\n  public VmType defaultVmType() {\n    Optional<String> type = config().option(\"defaultVmType\");\n    return type.isPresent() ? VmType.of(type.get()) : helper.defaultVmType();\n  }\n  @Override\n  public VmConfig defaultVmConfig() {\n    VmConfig.Builder builder = VmConfig.builder().name(\"default\").type(helper.defaultVmType());\n    helper.configureDefaultVm(builder);\n    return builder.addAllArgs(caliperConfig.getVmArgs()).build();\n  }\n  private static final ImmutableList<String> EXECUTABLE_DIRS = ImmutableList.of(\"bin/\", \"\");\n  private static final ImmutableList<String> EXECUTABLE_EXTENSIONS = ImmutableList.of(\"\", \".exe\");\n<fim_suffix>  @Override\n  public String vmExecutablePath(Vm vm) {\n    File homeDir = vmHomeDir(vm);\n    for (String extension : EXECUTABLE_EXTENSIONS) {\n      for (String dir : EXECUTABLE_DIRS) {\n        File file = new File(homeDir, dir + vm.executable() + extension);\n        if (file.isFile()) {\n          return file.getAbsolutePath();\n        }\n      }\n    }\n    throw new VirtualMachineException(\n        String.format(\n            \"VM executable %s for VM %s not found under home dir %s\",\n            vm.executable(), vm, homeDir));\n  }\n  @Override\n  public String workerClasspath(VmType type) {\n    return helper.getWorkerClasspath(type);\n  }\n  private File vmHomeDir(Vm vm) {\n    if (!vm.home().isPresent()) {\n      File homeDir = helper.getHomeDir(vm, vmBaseDirectory(vm));\n      checkConfiguration(homeDir.isDirectory(), \"%s is not a directory\", homeDir);\n      return homeDir;\n    }\n    String homeDirPath = vm.home().get();\n    File potentialHomeDir = new File(homeDirPath);\n    if (potentialHomeDir.isAbsolute()) {\n      checkConfiguration(potentialHomeDir.isDirectory(), \"%s is not a directory\", potentialHomeDir);\n      return potentialHomeDir;\n    }\n    File homeDir = new File(vmBaseDirectory(vm), homeDirPath);\n    checkConfiguration(homeDir.isDirectory(), \"%s is not a directory\", potentialHomeDir);\n    return homeDir;\n  }\n  private volatile Optional<File> vmBaseDirectory = null;\n  private File vmBaseDirectory(Vm vm) {\n    if (vmBaseDirectory == null) {\n      vmBaseDirectory = getVmBaseDirectory();\n    }\n    if (!vmBaseDirectory.isPresent()) {\n      throw new VirtualMachineException(\n          \"must set either a home directory or a base directory: config = \" + vm.config());\n    }\n    return vmBaseDirectory.get();\n  }\n  private Optional<File> getVmBaseDirectory() {\n    Optional<String> baseDirectoryPath =\n        config()\n            .option(\"vmBaseDirectory\")\n            .or(Optional.fromNullable(caliperConfig.properties().get(\"vm.baseDirectory\")));\n    if (!baseDirectoryPath.isPresent()) {\n      return Optional.absent();\n    }\n    File result = new File(baseDirectoryPath.get());\n    checkConfiguration(result.isAbsolute(), \"VM base directory cannot be a relative path\");\n    checkConfiguration(result.isDirectory(), \"VM base directory must be a directory\");\n    return Optional.of(result);\n  }\n  private static void checkConfiguration(boolean check, String message) {\n    if (!check) {\n      throw new VirtualMachineException(message);\n    }\n  }\n  private static void checkConfiguration(boolean check, String messageFormat, Object... args) {\n    if (!check) {\n      throw new VirtualMachineException(String.format(messageFormat, args));\n    }\n  }\n  @Override\n  public VmProcess doStartVm(VmProcess.Spec spec, VmProcess.Logger logger) throws Exception {\n    ProcessBuilder builder = new ProcessBuilder().redirectErrorStream(redirectErrorStream);\n    helper.addToWorkerProcessEnvironment(builder.environment());\n    ImmutableList<String> command = createCommand(spec);\n    logger.log(\"Command: \" + ARG_JOINER.join(command) + \"\\n\");\n    builder.command(command);\n    return new LocalProcess(builder.start());\n  }\n  @VisibleForTesting\n  ImmutableList<String> createCommand(VmProcess.Spec spec) {\n    return new ImmutableList.Builder<String>()\n        .add(spec.target().vmExecutablePath())\n        .addAll(spec.vmOptions())\n        .add(spec.mainClass())\n        .addAll(spec.mainArgs())\n        .build();\n  }\n  /** Helper to be implemented for each type of device the Caliper runner itself may be run on. */\n  interface Helper {\n    /** Do anything that may be needed when starting up the device service. */\n    void setUp();\n    /** Returns the default VM type for this device. */\n    VmType defaultVmType();\n    /**\n     * Sets some configuration options for the default VM config for the device on the given\n     * builder.\n     */\n    void configureDefaultVm(VmConfig.Builder builder);\n    /** Gets the home directory to use for the given VM. */\n    File getHomeDir(Vm vm, File baseDirectory);\n    /** Gets the classpath to use for a worker of the given type. */\n    String getWorkerClasspath(VmType type);\n    /** May add mappings to the environment for worker processes. */\n    void addToWorkerProcessEnvironment(Map<String, String> env);\n  }\n  /** A worker process running on the local machine. */\n  private static final class LocalProcess extends VmProcess {\n    private final Process process;\n    LocalProcess(Process process) {\n      this.process = process;\n    }\n    @Override\n    public InputStream stdout() {\n      return process.getInputStream();\n    }\n    @Override\n    public InputStream stderr() {\n      return process.getErrorStream();\n    }\n    @Override\n    public int doAwaitExit() throws InterruptedException {\n      return process.waitFor();\n    }\n    @Override\n    public void doKill() {\n      process.destroy();\n    }\n  }\n  /** Creates a new {@link LocalDevice} builder. */\n  @VisibleForTesting\n  public static Builder builder() {\n    return new Builder();\n  }\n  /** Builder for {@link LocalDevice} instances. */<fim_middle>// function below has no smell\n"}