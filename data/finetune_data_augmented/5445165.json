{"text": "<fim_prefix>            // We cannot redeliver single messages if subscription type is not Shared\n            redeliverUnacknowledgedMessages();\n            return;\n        }\n        ClientCnx cnx = cnx();\n        if (isConnected() && cnx.getRemoteEndpointProtocolVersion() >= ProtocolVersion.v2.getNumber()) {\n            int messagesFromQueue = removeExpiredMessagesFromQueue(messageIds);\n            Iterable<List<MessageIdImpl>> batches = Iterables.partition(\n                messageIds.stream()\n                    .map(messageId -> (MessageIdImpl)messageId)\n                    .collect(Collectors.toSet()), MAX_REDELIVER_UNACKNOWLEDGED);\n            MessageIdData.Builder builder = MessageIdData.newBuilder();\n            batches.forEach(ids -> {\n                List<MessageIdData> messageIdDatas = ids.stream().map(messageId -> {\n                    // process message possible to dead letter topic\n                    processPossibleToDLQ(messageId);\n                    // attempt to remove message from batchMessageAckTracker\n                    builder.setPartition(messageId.getPartitionIndex());\n                    builder.setLedgerId(messageId.getLedgerId());\n                    builder.setEntryId(messageId.getEntryId());\n                    return builder.build();\n                }).collect(Collectors.toList());\n                ByteBuf cmd = Commands.newRedeliverUnacknowledgedMessages(consumerId, messageIdDatas);\n                cnx.ctx().writeAndFlush(cmd, cnx.ctx().voidPromise());\n                messageIdDatas.forEach(MessageIdData::recycle);\n            });\n            if (messagesFromQueue > 0) {\n                increaseAvailablePermits(cnx, messagesFromQueue);\n            }\n            builder.recycle();\n            if (log.isDebugEnabled()) {\n                log.debug(\"[{}] [{}] [{}] Redeliver unacked messages and increase {} permits\", subscription, topic,\n                        consumerName, messagesFromQueue);\n            }\n            return;\n        }\n        if (cnx == null || (getState() == State.Connecting)) {\n            log.warn(\"[{}] Client Connection needs to be established for redelivery of unacknowledged messages\", this);\n        } else {\n            log.warn(\"[{}] Reconnecting the client to redeliver the messages.\", this);\n            cnx.ctx().close();\n        }\n    }\n    private void processPossibleToDLQ(MessageIdImpl messageId) {\n        List<MessageImpl<T>> deadLetterMessages = null;\n        if (possibleSendToDeadLetterTopicMessages != null) {\n            if (messageId instanceof BatchMessageIdImpl) {\n                deadLetterMessages = possibleSendToDeadLetterTopicMessages.get(new MessageIdImpl(messageId.getLedgerId(), messageId.getEntryId(),\n                        getPartitionIndex()));\n            } else {\n                deadLetterMessages = possibleSendToDeadLetterTopicMessages.get(messageId);\n            }\n        }\n        if (deadLetterMessages != null) {\n            if (deadLetterProducer == null) {\n                try {\n                    deadLetterProducer = client.newProducer(schema)\n                            .topic(this.deadLetterPolicy.getDeadLetterTopic())\n                            .blockIfQueueFull(false)\n                            .create();\n                } catch (Exception e) {\n                    log.error(\"Create dead letter producer exception with topic: {}\", deadLetterPolicy.getDeadLetterTopic(), e);\n                }\n            }\n            if (deadLetterProducer != null) {\n                try {\n                    for (MessageImpl<T> message : deadLetterMessages) {\n                        deadLetterProducer.newMessage()\n                                .value(message.getValue())\n                                .properties(message.getProperties())\n                                .send();\n                    }\n                    acknowledge(messageId);\n                } catch (Exception e) {\n                    log.error(\"Send to dead letter topic exception with topic: {}, messageId: {}\", deadLetterProducer.getTopic(), messageId, e);\n                }\n            }\n        }\n    }\n    @Override\n    public void seek(MessageId messageId) throws PulsarClientException {\n        try {\n            seekAsync(messageId).get();\n        } catch (ExecutionException | InterruptedException e) {\n            throw new PulsarClientException(e);\n        }\n    }\n    @Override\n    public void seek(long timestamp) throws PulsarClientException {\n        try {\n            seekAsync(timestamp).get();\n        } catch (ExecutionException | InterruptedException e) {\n            throw new PulsarClientException(e);\n        }\n    }\n    @Override\n    public CompletableFuture<Void> seekAsync(long timestamp) {\n        if (getState() == State.Closing || getState() == State.Closed) {\n            return FutureUtil\n                    .failedFuture(new PulsarClientException.AlreadyClosedException(\"Consumer was already closed\"));\n        }\n        if (!isConnected()) {\n            return FutureUtil.failedFuture(new PulsarClientException(\"Not connected to broker\"));\n        }\n        final CompletableFuture<Void> seekFuture = new CompletableFuture<>();\n        long requestId = client.newRequestId();\n        ByteBuf seek = Commands.newSeek(consumerId, requestId, timestamp);\n        ClientCnx cnx = cnx();\n        log.info(\"[{}][{}] Seek subscription to publish time {}\", topic, subscription, timestamp);\n        cnx.sendRequestWithId(seek, requestId).thenRun(() -> {\n            log.info(\"[{}][{}] Successfully reset subscription to publish time {}\", topic, subscription, timestamp);\n            seekFuture.complete(null);\n        }).exceptionally(e -> {\n            log.error(\"[{}][{}] Failed to reset subscription: {}\", topic, subscription, e.getCause().getMessage());\n            seekFuture.completeExceptionally(e.getCause());\n            return null;\n        });\n        return seekFuture;\n    }\n    @Override\n    public CompletableFuture<Void> seekAsync(MessageId messageId) {\n        if (getState() == State.Closing || getState() == State.Closed) {\n            return FutureUtil\n                    .failedFuture(new PulsarClientException.AlreadyClosedException(\"Consumer was already closed\"));\n        }\n        if (!isConnected()) {\n            return FutureUtil.failedFuture(new PulsarClientException(\"Not connected to broker\"));\n        }\n        final CompletableFuture<Void> seekFuture = new CompletableFuture<>();\n        long requestId = client.newRequestId();\n        MessageIdImpl msgId = (MessageIdImpl) messageId;\n        ByteBuf seek = Commands.newSeek(consumerId, requestId, msgId.getLedgerId(), msgId.getEntryId());\n        ClientCnx cnx = cnx();\n        log.info(\"[{}][{}] Seek subscription to message id {}\", topic, subscription, messageId);\n        cnx.sendRequestWithId(seek, requestId).thenRun(() -> {\n            log.info(\"[{}][{}] Successfully reset subscription to message id {}\", topic, subscription, messageId);\n            seekFuture.complete(null);\n        }).exceptionally(e -> {\n            log.error(\"[{}][{}] Failed to reset subscription: {}\", topic, subscription, e.getCause().getMessage());\n            seekFuture.completeExceptionally(e.getCause());\n            return null;\n        });\n        return seekFuture;\n    }\n    public boolean hasMessageAvailable() throws PulsarClientException {\n        try {\n            if (hasMoreMessages(lastMessageIdInBroker, lastDequeuedMessage)) {\n                return true;\n            }\n            return hasMessageAvailableAsync().get();\n        } catch (ExecutionException | InterruptedException e) {\n            throw new PulsarClientException(e);\n        }\n    }\n    public CompletableFuture<Boolean> hasMessageAvailableAsync() {\n        final CompletableFuture<Boolean> booleanFuture = new CompletableFuture<>();\n        if (hasMoreMessages(lastMessageIdInBroker, lastDequeuedMessage)) {\n            booleanFuture.complete(true);\n        } else {\n            getLastMessageIdAsync().thenAccept(messageId -> {\n                lastMessageIdInBroker = messageId;\n                if (hasMoreMessages(lastMessageIdInBroker, lastDequeuedMessage)) {\n                    booleanFuture.complete(true);\n                } else {\n                    booleanFuture.complete(false);\n                }\n            }).exceptionally(e -> {\n                log.error(\"[{}][{}] Failed getLastMessageId command\", topic, subscription);\n                booleanFuture.completeExceptionally(e.getCause());\n                return null;\n            });\n        }\n        return booleanFuture;\n    }\n    private boolean hasMoreMessages(MessageId lastMessageIdInBroker, MessageId lastDequeuedMessage) {\n        if (lastMessageIdInBroker.compareTo(lastDequeuedMessage) > 0 &&\n                ((MessageIdImpl)lastMessageIdInBroker).getEntryId() != -1) {\n            return true;\n        } else {\n            // Make sure batching message can be read completely.\n            return lastMessageIdInBroker.compareTo(lastDequeuedMessage) == 0\n                && incomingMessages.size() > 0;\n        }\n    }\n<fim_suffix>    CompletableFuture<MessageId> getLastMessageIdAsync() {\n        if (getState() == State.Closing || getState() == State.Closed) {\n            return FutureUtil\n                .failedFuture(new PulsarClientException.AlreadyClosedException(\"Consumer was already closed\"));\n        }\n        AtomicLong opTimeoutMs = new AtomicLong(client.getConfiguration().getOperationTimeoutMs());\n        Backoff backoff = new Backoff(100, TimeUnit.MILLISECONDS,\n            opTimeoutMs.get() * 2, TimeUnit.MILLISECONDS,\n            0 , TimeUnit.MILLISECONDS);\n        CompletableFuture<MessageId> getLastMessageIdFuture = new CompletableFuture<>();\n        internalGetLastMessageIdAsync(backoff, opTimeoutMs, getLastMessageIdFuture);\n        return getLastMessageIdFuture;\n    }<fim_middle>// function below is feature envy\n"}