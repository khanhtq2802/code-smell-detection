{"text": "<fim_prefix> * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.druid.sql.calcite.filtration;\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Range;\nimport com.google.common.collect.RangeSet;\nimport org.apache.druid.java.util.common.ISE;\nimport org.apache.druid.query.filter.AndDimFilter;\nimport org.apache.druid.query.filter.BoundDimFilter;\nimport org.apache.druid.query.filter.DimFilter;\nimport org.apache.druid.query.filter.NotDimFilter;\nimport org.apache.druid.query.filter.OrDimFilter;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\npublic class CombineAndSimplifyBounds extends BottomUpTransform\n{\n  private static final CombineAndSimplifyBounds INSTANCE = new CombineAndSimplifyBounds();\n  private CombineAndSimplifyBounds()\n  {\n  }\n  public static CombineAndSimplifyBounds instance()\n  {\n    return INSTANCE;\n  }\n  @Override\n  public DimFilter process(DimFilter filter)\n  {\n    if (filter instanceof AndDimFilter) {\n      final List<DimFilter> children = getAndFilterChildren((AndDimFilter) filter);\n      final DimFilter one = doSimplifyAnd(children);\n      final DimFilter two = negate(doSimplifyOr(negateAll(children)));\n      return computeCost(one) <= computeCost(two) ? one : two;\n    } else if (filter instanceof OrDimFilter) {\n      final List<DimFilter> children = getOrFilterChildren((OrDimFilter) filter);\n      final DimFilter one = doSimplifyOr(children);\n      final DimFilter two = negate(doSimplifyAnd(negateAll(children)));\n      return computeCost(one) <= computeCost(two) ? one : two;\n    } else if (filter instanceof NotDimFilter) {\n      final DimFilter field = ((NotDimFilter) filter).getField();\n      final DimFilter candidate;\n      if (field instanceof OrDimFilter) {\n        candidate = doSimplifyAnd(negateAll(getOrFilterChildren((OrDimFilter) field)));\n      } else if (field instanceof AndDimFilter) {\n        candidate = doSimplifyOr(negateAll(getAndFilterChildren((AndDimFilter) field)));\n      } else {\n        candidate = negate(field);\n      }\n      return computeCost(filter) <= computeCost(candidate) ? filter : candidate;\n    } else {\n      return filter;\n    }\n  }\n  private List<DimFilter> getAndFilterChildren(final AndDimFilter filter)\n  {\n    final List<DimFilter> children = new ArrayList<>();\n    for (final DimFilter field : filter.getFields()) {\n      if (field instanceof AndDimFilter) {\n        children.addAll(getAndFilterChildren((AndDimFilter) field));\n      } else {\n        children.add(field);\n      }\n    }\n    return children;\n  }\n  private List<DimFilter> getOrFilterChildren(final OrDimFilter filter)\n  {\n    final List<DimFilter> children = new ArrayList<>();\n    for (final DimFilter field : filter.getFields()) {\n      if (field instanceof OrDimFilter) {\n        children.addAll(getOrFilterChildren((OrDimFilter) field));\n      } else {\n        children.add(field);\n      }\n    }\n    return children;\n  }\n  private static DimFilter doSimplifyAnd(final List<DimFilter> children)\n  {\n    return doSimplify(children, false);\n  }\n  private static DimFilter doSimplifyOr(final List<DimFilter> children)\n  {\n    return doSimplify(children, true);\n  }\n  /**\n   * Simplify BoundDimFilters that are children of an OR or an AND.\n   *\n   * @param children    the filters\n   * @param disjunction true for disjunction, false for conjunction\n   *\n   * @return simplified filters\n   */\n  private static DimFilter doSimplify(final List<DimFilter> children, boolean disjunction)\n  {\n    // Copy children list\n    final List<DimFilter> newChildren = Lists.newArrayList(children);\n    // Group Bound filters by dimension, extractionFn, and comparator and compute a RangeSet for each one.\n    final Map<BoundRefKey, List<BoundDimFilter>> bounds = new HashMap<>();\n    final Iterator<DimFilter> iterator = newChildren.iterator();\n    while (iterator.hasNext()) {\n      final DimFilter child = iterator.next();\n      if (child.equals(Filtration.matchNothing())) {\n        // Child matches nothing, equivalent to FALSE\n        // OR with FALSE => ignore\n        // AND with FALSE => always false, short circuit\n        if (disjunction) {\n          iterator.remove();\n        } else {\n          return Filtration.matchNothing();\n        }\n      } else if (child.equals(Filtration.matchEverything())) {\n        // Child matches everything, equivalent to TRUE\n        // OR with TRUE => always true, short circuit\n        // AND with TRUE => ignore\n        if (disjunction) {\n          return Filtration.matchEverything();\n        } else {\n          iterator.remove();\n        }\n      } else if (child instanceof BoundDimFilter) {\n        final BoundDimFilter bound = (BoundDimFilter) child;\n        final BoundRefKey boundRefKey = BoundRefKey.from(bound);\n        List<BoundDimFilter> filterList = bounds.get(boundRefKey);\n        if (filterList == null) {\n          filterList = new ArrayList<>();\n          bounds.put(boundRefKey, filterList);\n        }\n        filterList.add(bound);\n      }\n    }\n    // Try to simplify filters within each group.\n    for (Map.Entry<BoundRefKey, List<BoundDimFilter>> entry : bounds.entrySet()) {\n      final BoundRefKey boundRefKey = entry.getKey();\n      final List<BoundDimFilter> filterList = entry.getValue();\n      // Create a RangeSet for this group.\n      final RangeSet<BoundValue> rangeSet = disjunction\n                                            ? RangeSets.unionRanges(Bounds.toRanges(filterList))\n                                            : RangeSets.intersectRanges(Bounds.toRanges(filterList));\n      if (rangeSet.asRanges().size() < filterList.size()) {\n        // We found a simplification. Remove the old filters and add new ones.\n        for (final BoundDimFilter bound : filterList) {\n          if (!newChildren.remove(bound)) {\n            throw new ISE(\"WTF?! Tried to remove bound but couldn't?\");\n          }\n        }\n        if (rangeSet.asRanges().isEmpty()) {\n          // range set matches nothing, equivalent to FALSE\n          // OR with FALSE => ignore\n          // AND with FALSE => always false, short circuit\n          if (disjunction) {\n            newChildren.add(Filtration.matchNothing());\n          } else {\n            return Filtration.matchNothing();\n          }\n        }\n        for (final Range<BoundValue> range : rangeSet.asRanges()) {\n          if (!range.hasLowerBound() && !range.hasUpperBound()) {\n            // range matches all, equivalent to TRUE\n            // AND with TRUE => ignore\n            // OR with TRUE => always true; short circuit\n            if (disjunction) {\n              return Filtration.matchEverything();\n            } else {\n              newChildren.add(Filtration.matchEverything());\n            }\n          } else {\n            newChildren.add(Bounds.toFilter(boundRefKey, range));\n          }\n        }\n      }\n    }\n    Preconditions.checkState(newChildren.size() > 0, \"newChildren.size > 0\");\n    if (newChildren.size() == 1) {\n      return newChildren.get(0);\n    } else {\n      return disjunction ? new OrDimFilter(newChildren) : new AndDimFilter(newChildren);\n    }\n  }\n<fim_suffix>  private static DimFilter negate(final DimFilter filter)\n  {\n    if (Filtration.matchEverything().equals(filter)) {\n      return Filtration.matchNothing();\n    } else if (Filtration.matchNothing().equals(filter)) {\n      return Filtration.matchEverything();\n    } else if (filter instanceof NotDimFilter) {\n      return ((NotDimFilter) filter).getField();\n    } else if (filter instanceof BoundDimFilter) {\n      final BoundDimFilter negated = Bounds.not((BoundDimFilter) filter);\n      return negated != null ? negated : new NotDimFilter(filter);\n    } else {\n      return new NotDimFilter(filter);\n    }\n  }<fim_middle>// function below is long method\n"}