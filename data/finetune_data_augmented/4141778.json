{"text": "<fim_prefix>    }\n    /** Creates a JdbcUnionRule. */\n    public JdbcUnionRule(JdbcConvention out,\n        RelBuilderFactory relBuilderFactory) {\n      super(Union.class, (Predicate<RelNode>) r -> true, Convention.NONE, out,\n          relBuilderFactory, \"JdbcUnionRule\");\n    }\n    public RelNode convert(RelNode rel) {\n      final Union union = (Union) rel;\n      final RelTraitSet traitSet =\n          union.getTraitSet().replace(out);\n      return new JdbcUnion(rel.getCluster(), traitSet,\n          convertList(union.getInputs(), out), union.all);\n    }\n  }\n  /** Union operator implemented in JDBC convention. */\n  public static class JdbcUnion extends Union implements JdbcRel {\n    public JdbcUnion(\n        RelOptCluster cluster,\n        RelTraitSet traitSet,\n        List<RelNode> inputs,\n        boolean all) {\n      super(cluster, traitSet, inputs, all);\n    }\n    public JdbcUnion copy(\n        RelTraitSet traitSet, List<RelNode> inputs, boolean all) {\n      return new JdbcUnion(getCluster(), traitSet, inputs, all);\n    }\n    @Override public RelOptCost computeSelfCost(RelOptPlanner planner,\n        RelMetadataQuery mq) {\n      return super.computeSelfCost(planner, mq).multiplyBy(.1);\n    }\n    public JdbcImplementor.Result implement(JdbcImplementor implementor) {\n      return implementor.implement(this);\n    }\n  }\n  /**\n   * Rule to convert a {@link org.apache.calcite.rel.core.Intersect}\n   * to a {@link org.apache.calcite.adapter.jdbc.JdbcRules.JdbcIntersect}.\n   */\n  public static class JdbcIntersectRule extends JdbcConverterRule {\n    /** Creates a JdbcIntersectRule. */\n    private JdbcIntersectRule(JdbcConvention out,\n        RelBuilderFactory relBuilderFactory) {\n      super(Intersect.class, (Predicate<RelNode>) r -> true, Convention.NONE,\n          out, relBuilderFactory, \"JdbcIntersectRule\");\n    }\n    public RelNode convert(RelNode rel) {\n      final Intersect intersect = (Intersect) rel;\n      if (intersect.all) {\n        return null; // INTERSECT ALL not implemented\n      }\n      final RelTraitSet traitSet =\n          intersect.getTraitSet().replace(out);\n      return new JdbcIntersect(rel.getCluster(), traitSet,\n          convertList(intersect.getInputs(), out), false);\n    }\n  }\n  /** Intersect operator implemented in JDBC convention. */\n  public static class JdbcIntersect\n      extends Intersect\n      implements JdbcRel {\n    public JdbcIntersect(\n        RelOptCluster cluster,\n        RelTraitSet traitSet,\n        List<RelNode> inputs,\n        boolean all) {\n      super(cluster, traitSet, inputs, all);\n      assert !all;\n    }\n    public JdbcIntersect copy(\n        RelTraitSet traitSet, List<RelNode> inputs, boolean all) {\n      return new JdbcIntersect(getCluster(), traitSet, inputs, all);\n    }\n    public JdbcImplementor.Result implement(JdbcImplementor implementor) {\n      return implementor.implement(this);\n    }\n  }\n  /**\n   * Rule to convert a {@link org.apache.calcite.rel.core.Minus} to a\n   * {@link org.apache.calcite.adapter.jdbc.JdbcRules.JdbcMinus}.\n   */\n  public static class JdbcMinusRule extends JdbcConverterRule {\n    /** Creates a JdbcMinusRule. */\n    private JdbcMinusRule(JdbcConvention out,\n        RelBuilderFactory relBuilderFactory) {\n      super(Minus.class, (Predicate<RelNode>) r -> true, Convention.NONE, out,\n          relBuilderFactory, \"JdbcMinusRule\");\n    }\n    public RelNode convert(RelNode rel) {\n      final Minus minus = (Minus) rel;\n      if (minus.all) {\n        return null; // EXCEPT ALL not implemented\n      }\n      final RelTraitSet traitSet =\n          rel.getTraitSet().replace(out);\n      return new JdbcMinus(rel.getCluster(), traitSet,\n          convertList(minus.getInputs(), out), false);\n    }\n  }\n  /** Minus operator implemented in JDBC convention. */\n  public static class JdbcMinus extends Minus implements JdbcRel {\n    public JdbcMinus(RelOptCluster cluster, RelTraitSet traitSet,\n        List<RelNode> inputs, boolean all) {\n      super(cluster, traitSet, inputs, all);\n      assert !all;\n    }\n    public JdbcMinus copy(RelTraitSet traitSet, List<RelNode> inputs,\n        boolean all) {\n      return new JdbcMinus(getCluster(), traitSet, inputs, all);\n    }\n    public JdbcImplementor.Result implement(JdbcImplementor implementor) {\n      return implementor.implement(this);\n    }\n  }\n  /** Rule that converts a table-modification to JDBC. */\n  public static class JdbcTableModificationRule extends JdbcConverterRule {\n    /** Creates a JdbcTableModificationRule. */\n    private JdbcTableModificationRule(JdbcConvention out,\n        RelBuilderFactory relBuilderFactory) {\n      super(TableModify.class, (Predicate<RelNode>) r -> true,\n          Convention.NONE, out, relBuilderFactory, \"JdbcTableModificationRule\");\n    }\n    @Override public RelNode convert(RelNode rel) {\n      final TableModify modify =\n          (TableModify) rel;\n      final ModifiableTable modifiableTable =\n          modify.getTable().unwrap(ModifiableTable.class);\n      if (modifiableTable == null) {\n        return null;\n      }\n      final RelTraitSet traitSet =\n          modify.getTraitSet().replace(out);\n      return new JdbcTableModify(\n          modify.getCluster(), traitSet,\n          modify.getTable(),\n          modify.getCatalogReader(),\n          convert(modify.getInput(), traitSet),\n          modify.getOperation(),\n          modify.getUpdateColumnList(),\n          modify.getSourceExpressionList(),\n          modify.isFlattened());\n    }\n  }\n  /** Table-modification operator implemented in JDBC convention. */\n  public static class JdbcTableModify extends TableModify implements JdbcRel {\n    private final Expression expression;\n    public JdbcTableModify(RelOptCluster cluster,\n        RelTraitSet traitSet,\n        RelOptTable table,\n        Prepare.CatalogReader catalogReader,\n        RelNode input,\n        Operation operation,\n        List<String> updateColumnList,\n        List<RexNode> sourceExpressionList,\n        boolean flattened) {\n      super(cluster, traitSet, table, catalogReader, input, operation,\n          updateColumnList, sourceExpressionList, flattened);\n      assert input.getConvention() instanceof JdbcConvention;\n      assert getConvention() instanceof JdbcConvention;\n      final ModifiableTable modifiableTable =\n          table.unwrap(ModifiableTable.class);\n      if (modifiableTable == null) {\n        throw new AssertionError(); // TODO: user error in validator\n      }\n      this.expression = table.getExpression(Queryable.class);\n      if (expression == null) {\n        throw new AssertionError(); // TODO: user error in validator\n      }\n    }\n    @Override public RelOptCost computeSelfCost(RelOptPlanner planner,\n        RelMetadataQuery mq) {\n      return super.computeSelfCost(planner, mq).multiplyBy(.1);\n    }\n    @Override public RelNode copy(RelTraitSet traitSet, List<RelNode> inputs) {\n      return new JdbcTableModify(\n          getCluster(), traitSet, getTable(), getCatalogReader(),\n          sole(inputs), getOperation(), getUpdateColumnList(),\n          getSourceExpressionList(), isFlattened());\n    }\n    public JdbcImplementor.Result implement(JdbcImplementor implementor) {\n      return implementor.implement(this);\n    }\n  }\n  /** Rule that converts a values operator to JDBC. */\n  public static class JdbcValuesRule extends JdbcConverterRule {\n    /** Creates a JdbcValuesRule. */\n    private JdbcValuesRule(JdbcConvention out,\n        RelBuilderFactory relBuilderFactory) {\n      super(Values.class, (Predicate<RelNode>) r -> true, Convention.NONE,\n          out, relBuilderFactory, \"JdbcValuesRule\");\n    }\n    @Override public RelNode convert(RelNode rel) {\n      Values values = (Values) rel;\n      return new JdbcValues(values.getCluster(), values.getRowType(),\n          values.getTuples(), values.getTraitSet().replace(out));\n    }\n  }\n  /** Values operator implemented in JDBC convention. */\n<fim_suffix>  public static class JdbcValues extends Values implements JdbcRel {\n    JdbcValues(RelOptCluster cluster, RelDataType rowType,\n        ImmutableList<ImmutableList<RexLiteral>> tuples, RelTraitSet traitSet) {\n      super(cluster, rowType, tuples, traitSet);\n    }\n    @Override public RelNode copy(RelTraitSet traitSet, List<RelNode> inputs) {\n      assert inputs.isEmpty();\n      return new JdbcValues(getCluster(), rowType, tuples, traitSet);\n    }\n    public JdbcImplementor.Result implement(JdbcImplementor implementor) {\n      return implementor.implement(this);\n    }\n  }<fim_middle>// class below has no smell\n"}