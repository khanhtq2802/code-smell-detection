{"text": "<fim_prefix>//\n//  ========================================================================\n//  Copyright (c) 1995-2019 Mort Bay Consulting Pty. Ltd.\n//  ------------------------------------------------------------------------\n//  All rights reserved. This program and the accompanying materials\n//  are made available under the terms of the Eclipse Public License v1.0\n//  and Apache License v2.0 which accompanies this distribution.\n//\n//      The Eclipse Public License is available at\n//      http://www.eclipse.org/legal/epl-v10.html\n//\n//      The Apache License v2.0 is available at\n//      http://www.opensource.org/licenses/apache2.0.php\n//\n//  You may elect to redistribute this code under either of these licenses.\n//  ========================================================================\n//\n\npackage org.eclipse.jetty.util;\n\nimport java.util.concurrent.CompletableFuture;\n\nimport org.eclipse.jetty.util.thread.Invocable;\n\n/**\n * <p>A callback abstraction that handles completed/failed events of asynchronous operations.</p>\n *\n * <p>Semantically this is equivalent to an optimise Promise&lt;Void&gt;, but callback is a more meaningful\n * name than EmptyPromise</p>\n */\npublic interface Callback extends Invocable\n{\n    /**\n     * Instance of Adapter that can be used when the callback methods need an empty\n     * implementation without incurring in the cost of allocating a new Adapter object.\n     */\n    static Callback NOOP = new Callback()\n    {\n        @Override\n        public InvocationType getInvocationType()\n        {\n            return InvocationType.NON_BLOCKING;\n        }\n    };\n\n    /**\n     * <p>Callback invoked when the operation completes.</p>\n     *\n     * @see #failed(Throwable)\n     */\n    default void succeeded()\n    {\n    }\n\n    /**\n     * <p>Callback invoked when the operation fails.</p>\n     * @param x the reason for the operation failure\n     */\n    default void failed(Throwable x)\n    {\n    }\n\n    /**\n     * <p>Creates a non-blocking callback from the given incomplete CompletableFuture.</p>\n     * <p>When the callback completes, either succeeding or failing, the\n     * CompletableFuture is also completed, respectively via\n     * {@link CompletableFuture#complete(Object)} or\n     * {@link CompletableFuture#completeExceptionally(Throwable)}.</p>\n     *\n     * @param completable the CompletableFuture to convert into a callback\n     * @return a callback that when completed, completes the given CompletableFuture\n     */\n    static Callback from(CompletableFuture<?> completable)\n    {\n        return from(completable, InvocationType.NON_BLOCKING);\n    }\n\n    /**\n     * <p>Creates a callback from the given incomplete CompletableFuture,\n     * with the given {@code blocking} characteristic.</p>\n     *\n     * @param completable the CompletableFuture to convert into a callback\n     * @param invocation whether the callback is blocking\n     * @return a callback that when completed, completes the given CompletableFuture\n     */\n    static Callback from(CompletableFuture<?> completable, InvocationType invocation)\n    {\n        if (completable instanceof Callback)\n            return (Callback)completable;\n\n        return new Callback()\n        {\n            @Override\n            public void succeeded()\n            {\n                completable.complete(null);\n            }\n\n            @Override\n            public void failed(Throwable x)\n            {\n                completable.completeExceptionally(x);\n            }\n\n            @Override\n            public InvocationType getInvocationType()\n            {\n                return invocation;\n            }\n        };\n    }\n\n    class Nested implements Callback\n    {\n        private final Callback callback;\n\n        public Nested(Callback callback)\n        {\n            this.callback = callback;\n        }\n\n        public Nested(Nested nested)\n        {\n            this.callback = nested.callback;\n        }\n\n        public Callback getCallback()\n        {\n            return callback;\n        }\n\n        @Override\n        public void succeeded()\n        {\n            callback.succeeded();\n        }\n\n        @Override\n        public void failed(Throwable x)\n        {\n            callback.failed(x);\n        }\n\n        @Override\n        public InvocationType getInvocationType()\n        {\n            return callback.getInvocationType();\n        }\n    }\n    /**\n     * <p>A CompletableFuture that is also a Callback.</p>\n     */\n    class Completable extends CompletableFuture<Void> implements Callback\n    {\n        private final InvocationType invocation;\n\n        public Completable()\n        {\n            this(Invocable.InvocationType.NON_BLOCKING);\n        }\n\n        public Completable(InvocationType invocation)\n        {\n            this.invocation = invocation;\n        }\n\n        @Override\n        public void succeeded()\n        {\n            complete(null);\n        }\n\n<fim_suffix>        @Override\n        public void failed(Throwable x)\n        {\n            completeExceptionally(x);\n        }\n\n        @Override\n        public InvocationType getInvocationType()\n        {\n            return invocation;\n        }\n    }\n}<fim_middle>// function below has no smell\n"}