{"text": "<fim_prefix>/* *******************************************************************\n * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).\n * All rights reserved. \n * This program and the accompanying materials are made available \n * under the terms of the Eclipse Public License v1.0 \n * which accompanies this distribution and is available at \n * http://www.eclipse.org/legal/epl-v10.html \n *  \n * Contributors: \n *     PARC     initial implementation \n * ******************************************************************/\npackage org.aspectj.weaver.patterns;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport org.aspectj.bridge.IMessage;\nimport org.aspectj.bridge.MessageUtil;\nimport org.aspectj.util.FuzzyBoolean;\nimport org.aspectj.weaver.CompressingDataOutputStream;\nimport org.aspectj.weaver.ISourceContext;\nimport org.aspectj.weaver.IntMap;\nimport org.aspectj.weaver.ResolvedType;\nimport org.aspectj.weaver.Shadow;\nimport org.aspectj.weaver.UnresolvedType;\nimport org.aspectj.weaver.VersionedDataInputStream;\nimport org.aspectj.weaver.WeaverMessages;\nimport org.aspectj.weaver.World;\nimport org.aspectj.weaver.ast.Literal;\nimport org.aspectj.weaver.ast.Test;\nimport org.aspectj.weaver.ast.Var;\n/**\n * Corresponds to target or this pcd.\n * \n * <p>\n * type is initially a WildTypePattern. If it stays that way, it's a this(Foo) type deal. however, the resolveBindings method may\n * convert it to a BindingTypePattern, in which case, it's a this(foo) type deal.\n * \n * @author Erik Hilsdale\n * @author Jim Hugunin\n */\npublic class ThisOrTargetPointcut extends NameBindingPointcut {\n\tprivate boolean isThis;\n\tprivate TypePattern typePattern;\n\tprivate String declarationText;\n\tprivate static final int thisKindSet;\n\tprivate static final int targetKindSet;\n\tstatic {\n\t\tint thisFlags = Shadow.ALL_SHADOW_KINDS_BITS;\n\t\tint targFlags = Shadow.ALL_SHADOW_KINDS_BITS;\n\t\tfor (int i = 0; i < Shadow.SHADOW_KINDS.length; i++) {\n\t\t\tShadow.Kind kind = Shadow.SHADOW_KINDS[i];\n\t\t\tif (kind.neverHasThis()) {\n\t\t\t\tthisFlags -= kind.bit;\n\t\t\t}\n\t\t\tif (kind.neverHasTarget()) {\n\t\t\t\ttargFlags -= kind.bit;\n\t\t\t}\n\t\t}\n\t\tthisKindSet = thisFlags;\n\t\ttargetKindSet = targFlags;\n\t}\n\tpublic boolean isBinding() {\n\t\treturn (typePattern instanceof BindingTypePattern);\n\t}\n\tpublic ThisOrTargetPointcut(boolean isThis, TypePattern type) {\n\t\tthis.isThis = isThis;\n\t\tthis.typePattern = type;\n\t\tthis.pointcutKind = THIS_OR_TARGET;\n\t\tthis.declarationText = (isThis ? \"this(\" : \"target(\") + type + \")\";\n\t}\n\tpublic TypePattern getType() {\n\t\treturn typePattern;\n\t}\n\tpublic boolean isThis() {\n\t\treturn isThis;\n\t}\n\t@Override\n\tpublic Pointcut parameterizeWith(Map<String,UnresolvedType> typeVariableMap, World w) {\n\t\tThisOrTargetPointcut ret = new ThisOrTargetPointcut(isThis, typePattern.parameterizeWith(typeVariableMap, w));\n\t\tret.copyLocationFrom(this);\n\t\treturn ret;\n\t}\n\t@Override\n\tpublic int couldMatchKinds() {\n\t\treturn isThis ? thisKindSet : targetKindSet;\n\t}\n\t@Override\n\tpublic FuzzyBoolean fastMatch(FastMatchInfo type) {\n\t\treturn FuzzyBoolean.MAYBE;\n\t}\n\tprivate boolean couldMatch(Shadow shadow) {\n\t\treturn isThis ? shadow.hasThis() : shadow.hasTarget();\n\t}\n\t@Override\n\tprotected FuzzyBoolean matchInternal(Shadow shadow) {\n\t\tif (!couldMatch(shadow)) {\n\t\t\treturn FuzzyBoolean.NO;\n\t\t}\n\t\tUnresolvedType typeToMatch = isThis ? shadow.getThisType() : shadow.getTargetType();\n\t\t// optimization for case of this(Object) or target(Object)\n\t\t// works for an ExactTypePattern (and we know there are no annotations to match here of course)\n\t\tif (typePattern.getExactType().equals(ResolvedType.OBJECT)) {\n\t\t\treturn FuzzyBoolean.YES;\n\t\t}\n\t\treturn typePattern.matches(typeToMatch.resolve(shadow.getIWorld()), TypePattern.DYNAMIC);\n\t}\n\t@Override\n\tpublic void write(CompressingDataOutputStream s) throws IOException {\n\t\ts.writeByte(Pointcut.THIS_OR_TARGET);\n\t\ts.writeBoolean(isThis);\n\t\ttypePattern.write(s);\n\t\twriteLocation(s);\n\t}\n\tpublic static Pointcut read(VersionedDataInputStream s, ISourceContext context) throws IOException {\n\t\tboolean isThis = s.readBoolean();\n\t\tTypePattern type = TypePattern.read(s, context);\n\t\tThisOrTargetPointcut ret = new ThisOrTargetPointcut(isThis, type);\n\t\tret.readLocation(context, s);\n\t\treturn ret;\n\t}\n\t@Override\n\tpublic void resolveBindings(IScope scope, Bindings bindings) {\n\t\ttypePattern = typePattern.resolveBindings(scope, bindings, true, true);\n\t\t// look for parameterized type patterns which are not supported...\n\t\tHasThisTypePatternTriedToSneakInSomeGenericOrParameterizedTypePatternMatchingStuffAnywhereVisitor visitor = new HasThisTypePatternTriedToSneakInSomeGenericOrParameterizedTypePatternMatchingStuffAnywhereVisitor();\n\t\ttypePattern.traverse(visitor, null);\n\t\tif (visitor.wellHasItThen/* ? */()) {\n\t\t\tscope.message(MessageUtil.error(WeaverMessages.format(WeaverMessages.THIS_AND_TARGET_DONT_SUPPORT_PARAMETERS),\n\t\t\t\t\tgetSourceLocation()));\n\t\t}\n\t\t// ??? handle non-formal\n\t}\n<fim_suffix>\t@Override\n\tpublic void postRead(ResolvedType enclosingType) {\n\t\ttypePattern.postRead(enclosingType);\n\t}\n\t@Override\n\tpublic List<BindingPattern> getBindingAnnotationTypePatterns() {\n\t\treturn Collections.emptyList();\n\t}\n\t@Override\n\tpublic List<BindingTypePattern> getBindingTypePatterns() {\n\t\tif (typePattern instanceof BindingTypePattern) {\n\t\t\tList<BindingTypePattern> l = new ArrayList<BindingTypePattern>();\n\t\t\tl.add((BindingTypePattern)typePattern);\n\t\t\treturn l;\n\t\t} else {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t}\n\t@Override\n\tpublic boolean equals(Object other) {\n\t\tif (!(other instanceof ThisOrTargetPointcut)) {\n\t\t\treturn false;\n\t\t}\n\t\tThisOrTargetPointcut o = (ThisOrTargetPointcut) other;\n\t\treturn o.isThis == this.isThis && o.typePattern.equals(this.typePattern);\n\t}\n\t@Override\n\tpublic int hashCode() {\n\t\tint result = 17;\n\t\tresult = 37 * result + (isThis ? 0 : 1);\n\t\tresult = 37 * result + typePattern.hashCode();\n\t\treturn result;\n\t}\n\t@Override\n\tpublic String toString() {\n\t\treturn declarationText;\n\t}\n\t/**\n\t * Residue is the remainder of the pointcut match that couldn't be performed with the purely static information at compile time\n\t * and this method returns the residue of a pointcut at a particular shadow.\n\t */\n\t@Override\n\tprotected Test findResidueInternal(Shadow shadow, ExposedState state) {\n\t\tif (!couldMatch(shadow)) {\n\t\t\treturn Literal.FALSE;\n\t\t}\n\t\t// if no preference is specified, just say TRUE which means no residue\n\t\tif (typePattern == TypePattern.ANY) {\n\t\t\treturn Literal.TRUE;\n\t\t}\n\t\tVar var = isThis ? shadow.getThisVar() : shadow.getTargetVar();\n\t\treturn exposeStateForVar(var, typePattern, state, shadow.getIWorld());\n\t}\n\t@Override\n\tpublic Pointcut concretize1(ResolvedType inAspect, ResolvedType declaringType, IntMap bindings) {\n\t\tif (isDeclare(bindings.getEnclosingAdvice())) {\n\t\t\t// Enforce rule about which designators are supported in declare<fim_middle>// function below has no smell\n"}