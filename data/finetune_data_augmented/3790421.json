{"text": "<fim_prefix>   *     single item for repeating and shuffling.\n   * @param shuffleOrder A shuffle order of child timelines. The number of child timelines must\n   *     match the number of elements in the shuffle order.\n   */\n  public AbstractConcatenatedTimeline(boolean isAtomic, ShuffleOrder shuffleOrder) {\n    this.isAtomic = isAtomic;\n    this.shuffleOrder = shuffleOrder;\n    this.childCount = shuffleOrder.getLength();\n  }\n  @Override\n  public int getNextWindowIndex(int windowIndex, @Player.RepeatMode int repeatMode,\n      boolean shuffleModeEnabled) {\n    if (isAtomic) {\n      // Adapt repeat and shuffle mode to atomic concatenation.\n      repeatMode = repeatMode == Player.REPEAT_MODE_ONE ? Player.REPEAT_MODE_ALL : repeatMode;\n      shuffleModeEnabled = false;\n    }\n    // Find next window within current child.\n    int childIndex = getChildIndexByWindowIndex(windowIndex);\n    int firstWindowIndexInChild = getFirstWindowIndexByChildIndex(childIndex);\n    int nextWindowIndexInChild = getTimelineByChildIndex(childIndex).getNextWindowIndex(\n        windowIndex - firstWindowIndexInChild,\n        repeatMode == Player.REPEAT_MODE_ALL ? Player.REPEAT_MODE_OFF : repeatMode,\n        shuffleModeEnabled);\n    if (nextWindowIndexInChild != C.INDEX_UNSET) {\n      return firstWindowIndexInChild + nextWindowIndexInChild;\n    }\n    // If not found, find first window of next non-empty child.\n    int nextChildIndex = getNextChildIndex(childIndex, shuffleModeEnabled);\n    while (nextChildIndex != C.INDEX_UNSET && getTimelineByChildIndex(nextChildIndex).isEmpty()) {\n      nextChildIndex = getNextChildIndex(nextChildIndex, shuffleModeEnabled);\n    }\n    if (nextChildIndex != C.INDEX_UNSET) {\n      return getFirstWindowIndexByChildIndex(nextChildIndex)\n          + getTimelineByChildIndex(nextChildIndex).getFirstWindowIndex(shuffleModeEnabled);\n    }\n    // If not found, this is the last window.\n    if (repeatMode == Player.REPEAT_MODE_ALL) {\n      return getFirstWindowIndex(shuffleModeEnabled);\n    }\n    return C.INDEX_UNSET;\n  }\n  @Override\n  public int getPreviousWindowIndex(int windowIndex, @Player.RepeatMode int repeatMode,\n      boolean shuffleModeEnabled) {\n    if (isAtomic) {\n      // Adapt repeat and shuffle mode to atomic concatenation.\n      repeatMode = repeatMode == Player.REPEAT_MODE_ONE ? Player.REPEAT_MODE_ALL : repeatMode;\n      shuffleModeEnabled = false;\n    }\n    // Find previous window within current child.\n    int childIndex = getChildIndexByWindowIndex(windowIndex);\n    int firstWindowIndexInChild = getFirstWindowIndexByChildIndex(childIndex);\n    int previousWindowIndexInChild = getTimelineByChildIndex(childIndex).getPreviousWindowIndex(\n        windowIndex - firstWindowIndexInChild,\n        repeatMode == Player.REPEAT_MODE_ALL ? Player.REPEAT_MODE_OFF : repeatMode,\n        shuffleModeEnabled);\n    if (previousWindowIndexInChild != C.INDEX_UNSET) {\n      return firstWindowIndexInChild + previousWindowIndexInChild;\n    }\n    // If not found, find last window of previous non-empty child.\n    int previousChildIndex = getPreviousChildIndex(childIndex, shuffleModeEnabled);\n    while (previousChildIndex != C.INDEX_UNSET\n        && getTimelineByChildIndex(previousChildIndex).isEmpty()) {\n      previousChildIndex = getPreviousChildIndex(previousChildIndex, shuffleModeEnabled);\n    }\n    if (previousChildIndex != C.INDEX_UNSET) {\n      return getFirstWindowIndexByChildIndex(previousChildIndex)\n          + getTimelineByChildIndex(previousChildIndex).getLastWindowIndex(shuffleModeEnabled);\n    }\n    // If not found, this is the first window.\n    if (repeatMode == Player.REPEAT_MODE_ALL) {\n      return getLastWindowIndex(shuffleModeEnabled);\n    }\n    return C.INDEX_UNSET;\n  }\n  @Override\n  public int getLastWindowIndex(boolean shuffleModeEnabled) {\n    if (childCount == 0) {\n      return C.INDEX_UNSET;\n    }\n    if (isAtomic) {\n      shuffleModeEnabled = false;\n    }\n    // Find last non-empty child.\n    int lastChildIndex = shuffleModeEnabled ? shuffleOrder.getLastIndex() : childCount - 1;\n    while (getTimelineByChildIndex(lastChildIndex).isEmpty()) {\n      lastChildIndex = getPreviousChildIndex(lastChildIndex, shuffleModeEnabled);\n      if (lastChildIndex == C.INDEX_UNSET) {\n        // All children are empty.\n        return C.INDEX_UNSET;\n      }\n    }\n    return getFirstWindowIndexByChildIndex(lastChildIndex)\n        + getTimelineByChildIndex(lastChildIndex).getLastWindowIndex(shuffleModeEnabled);\n  }\n  @Override\n  public int getFirstWindowIndex(boolean shuffleModeEnabled) {\n    if (childCount == 0) {\n      return C.INDEX_UNSET;\n    }\n    if (isAtomic) {\n      shuffleModeEnabled = false;\n    }\n    // Find first non-empty child.\n    int firstChildIndex = shuffleModeEnabled ? shuffleOrder.getFirstIndex() : 0;\n    while (getTimelineByChildIndex(firstChildIndex).isEmpty()) {\n      firstChildIndex = getNextChildIndex(firstChildIndex, shuffleModeEnabled);\n      if (firstChildIndex == C.INDEX_UNSET) {\n        // All children are empty.\n        return C.INDEX_UNSET;\n      }\n    }\n    return getFirstWindowIndexByChildIndex(firstChildIndex)\n        + getTimelineByChildIndex(firstChildIndex).getFirstWindowIndex(shuffleModeEnabled);\n  }\n  @Override\n  public final Window getWindow(\n      int windowIndex, Window window, boolean setTag, long defaultPositionProjectionUs) {\n    int childIndex = getChildIndexByWindowIndex(windowIndex);\n    int firstWindowIndexInChild = getFirstWindowIndexByChildIndex(childIndex);\n    int firstPeriodIndexInChild = getFirstPeriodIndexByChildIndex(childIndex);\n    getTimelineByChildIndex(childIndex)\n        .getWindow(\n            windowIndex - firstWindowIndexInChild, window, setTag, defaultPositionProjectionUs);\n    window.firstPeriodIndex += firstPeriodIndexInChild;\n    window.lastPeriodIndex += firstPeriodIndexInChild;\n    return window;\n  }\n  @Override\n  public final Period getPeriodByUid(Object uid, Period period) {\n    Object childUid = getChildTimelineUidFromConcatenatedUid(uid);\n    Object periodUid = getChildPeriodUidFromConcatenatedUid(uid);\n    int childIndex = getChildIndexByChildUid(childUid);\n    int firstWindowIndexInChild = getFirstWindowIndexByChildIndex(childIndex);\n    getTimelineByChildIndex(childIndex).getPeriodByUid(periodUid, period);\n    period.windowIndex += firstWindowIndexInChild;\n    period.uid = uid;\n    return period;\n  }\n  @Override\n  public final Period getPeriod(int periodIndex, Period period, boolean setIds) {\n    int childIndex = getChildIndexByPeriodIndex(periodIndex);\n    int firstWindowIndexInChild = getFirstWindowIndexByChildIndex(childIndex);\n    int firstPeriodIndexInChild = getFirstPeriodIndexByChildIndex(childIndex);\n    getTimelineByChildIndex(childIndex).getPeriod(periodIndex - firstPeriodIndexInChild, period,\n        setIds);\n    period.windowIndex += firstWindowIndexInChild;\n    if (setIds) {\n      period.uid = getConcatenatedUid(getChildUidByChildIndex(childIndex), period.uid);\n    }\n    return period;\n  }\n  @Override\n  public final int getIndexOfPeriod(Object uid) {\n    if (!(uid instanceof Pair)) {\n      return C.INDEX_UNSET;\n    }\n    Object childUid = getChildTimelineUidFromConcatenatedUid(uid);\n    Object periodUid = getChildPeriodUidFromConcatenatedUid(uid);\n    int childIndex = getChildIndexByChildUid(childUid);\n    if (childIndex == C.INDEX_UNSET) {\n      return C.INDEX_UNSET;\n    }\n    int periodIndexInChild = getTimelineByChildIndex(childIndex).getIndexOfPeriod(periodUid);\n    return periodIndexInChild == C.INDEX_UNSET ? C.INDEX_UNSET\n        : getFirstPeriodIndexByChildIndex(childIndex) + periodIndexInChild;\n  }\n<fim_suffix>  @Override\n  public final Object getUidOfPeriod(int periodIndex) {\n    int childIndex = getChildIndexByPeriodIndex(periodIndex);\n    int firstPeriodIndexInChild = getFirstPeriodIndexByChildIndex(childIndex);\n    Object periodUidInChild =\n        getTimelineByChildIndex(childIndex).getUidOfPeriod(periodIndex - firstPeriodIndexInChild);\n    return getConcatenatedUid(getChildUidByChildIndex(childIndex), periodUidInChild);\n  }<fim_middle>// function below has no smell\n"}