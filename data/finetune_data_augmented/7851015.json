{"text": "<fim_prefix>   */\n  void recoverRegionId(long drId) {\n    long newVal = drId + 1;\n    if (this.regionIdCtr.get() < newVal) { // fixes bug 41421\n      this.regionIdCtr.set(newVal);\n    }\n  }\n  /**\n   * Called when creating a new disk region (not a recovered one).\n   */\n  long generateRegionId() {\n    long result;\n    do {\n      result = this.regionIdCtr.getAndIncrement();\n    } while (result <= MAX_RESERVED_DRID && result >= MIN_RESERVED_DRID);\n    return result;\n  }\n  /**\n   * Returns a set of the disk regions that are using this disk store. Note that this set is read\n   * only and live (its contents may change if the regions using this disk store changes).\n   */\n  Collection<DiskRegion> getDiskRegions() {\n    return Collections.unmodifiableCollection(this.drMap.values());\n  }\n  /**\n   * This method is slow and should be optimized if used for anything important. At this time it was\n   * added to do some internal assertions that have since been removed.\n   */\n  DiskRegion getByName(String name) {\n    for (DiskRegion dr : getDiskRegions()) {\n      if (dr.getName().equals(name)) {\n        return dr;\n      }\n    }\n    return null;\n  }\n  void addDiskRegion(DiskRegion dr) {\n    if (dr.isBackup()) {\n      PersistentOplogSet oplogSet = getPersistentOplogSet(dr);\n      if (!isOffline()) {\n        oplogSet.initChild();\n      }\n      DiskRegion old = this.drMap.putIfAbsent(dr.getId(), dr);\n      if (old != null) {\n        throw new IllegalStateException(\n            \"DiskRegion already exists with id \" + dr.getId() + \" and name \" + old.getName());\n      }\n      getDiskInitFile().createRegion(dr);\n    } else {\n      this.overflowMap.add(dr);\n    }\n    if (getOwnedByRegion()) {\n      this.ownCount.incrementAndGet();\n    }\n  }\n  void addPersistentPR(String name, PRPersistentConfig config) {\n    getDiskInitFile().createPersistentPR(name, config);\n  }\n  void removePersistentPR(String name) {\n    if (isClosed() && getOwnedByRegion()) {\n      // A region owned disk store will destroy\n      // itself when all buckets are removed, resulting\n      // in an exception when this method is called.\n      // Do nothing if the disk store is already\n      // closed\n      return;\n    }\n    getDiskInitFile().destroyPersistentPR(name);\n  }\n  PRPersistentConfig getPersistentPRConfig(String name) {\n    return getDiskInitFile().getPersistentPR(name);\n  }\n  Map<String, PRPersistentConfig> getAllPRs() {\n    return getDiskInitFile().getAllPRs();\n  }\n  DiskRegion getById(long regionId) {\n    return this.drMap.get(regionId);\n  }\n  void rmById(long regionId) {\n    this.drMap.remove(regionId);\n  }\n  void handleDiskAccessException(final DiskAccessException dae) {\n    boolean causedByRDE = LocalRegion.causedByRDE(dae);\n    // @todo is it ok for flusher and compactor to call this method if RDE?\n    // I think they need to keep working (for other regions) in this case.\n    if (causedByRDE) {\n      return;\n    }\n    // If another thread has already hit a DAE and is cleaning up, do nothing\n    if (!diskException.compareAndSet(null, dae)) {\n      return;\n    }\n    // log the error\n    final String message = String.format(\n        \"A DiskAccessException has occurred while writing to the disk for disk store %s. The cache will be closed.\",\n        getName());\n    logger.error(message, dae);\n    Thread thread = new LoggingThread(\"Disk store exception handler\", false, () -> {\n      try {\n        // now close the cache\n        getCache().close(message, dae);\n        _testHandleDiskAccessException.countDown();\n      } catch (Exception e) {\n        logger.error(\"An Exception occurred while closing the cache.\", e);\n      }\n    });\n    thread.start();\n  }\n  private final String name;\n  private final boolean autoCompact;\n  private final boolean allowForceCompaction;\n  private final long maxOplogSizeInBytes;\n  private final long timeInterval;\n  private final int queueSize;\n  private final int writeBufferSize;\n  private final File[] diskDirs;\n  private final int[] diskDirSizes;\n  private volatile float warningPercent;\n  private volatile float criticalPercent;\n  // DiskStore interface methods\n  @Override\n  public String getName() {\n    return this.name;\n  }\n  @Override\n  public boolean getAutoCompact() {\n    return this.autoCompact;\n  }\n  @Override\n  public boolean getAllowForceCompaction() {\n    return this.allowForceCompaction;\n  }\n  @Override\n  public long getMaxOplogSize() {\n    return this.maxOplogSizeInBytes / (1024 * 1024);\n  }\n  public long getMaxOplogSizeInBytes() {\n    return this.maxOplogSizeInBytes;\n  }\n  @Override\n  public long getTimeInterval() {\n    return this.timeInterval;\n  }\n  @Override\n  public int getQueueSize() {\n    return this.queueSize;\n  }\n  @Override\n  public int getWriteBufferSize() {\n    return this.writeBufferSize;\n  }\n  @Override\n  public File[] getDiskDirs() {\n    return this.diskDirs;\n  }\n  @Override\n  public int[] getDiskDirSizes() {\n    return this.diskDirSizes;\n  }\n  @Override\n  public float getDiskUsageWarningPercentage() {\n    return warningPercent;\n  }\n  @Override\n  public float getDiskUsageCriticalPercentage() {\n    return criticalPercent;\n  }\n  @Override\n  public void setDiskUsageWarningPercentage(float warningPercent) {\n    DiskStoreMonitor.checkWarning(warningPercent);\n    this.warningPercent = warningPercent;\n  }\n  @Override\n  public void setDiskUsageCriticalPercentage(float criticalPercent) {\n    DiskStoreMonitor.checkCritical(criticalPercent);\n    this.criticalPercent = criticalPercent;\n  }\n  public static class AsyncDiskEntry {\n    public final InternalRegion region;\n    public final DiskEntry de;\n    public final boolean versionOnly;\n    public final VersionTag tag;\n    public AsyncDiskEntry(InternalRegion region, DiskEntry de, VersionTag tag) {\n      this.region = region;\n      this.de = de;\n      this.tag = tag;\n      this.versionOnly = false;\n    }\n    public AsyncDiskEntry(InternalRegion region, VersionTag tag) {\n      this.region = region;\n      this.de = null;\n      this.tag = tag;\n      this.versionOnly = true;\n      // if versionOnly, only de.getDiskId() is used for synchronize\n    }\n    @Override\n    public String toString() {\n      StringBuilder sb = new StringBuilder();\n      sb.append(\"dr=\").append(region.getDiskRegion().getId());\n      sb.append(\" versionOnly=\").append(this.versionOnly);\n      if (this.versionOnly) {\n        sb.append(\" versionTag=\").append(this.tag);\n      }\n      if (de != null) {\n        sb.append(\" key=\").append(de.getKey());\n      } else {\n        sb.append(\" <END CLEAR>\");\n      }\n      return sb.toString();\n    }\n  }\n  /**\n   * Set of OplogEntryIds (longs). Memory is optimized by using an int[] for ids in the unsigned int\n   * range.\n   */\n<fim_suffix>  static class OplogEntryIdSet {\n    private final IntOpenHashSet ints = new IntOpenHashSet((int) INVALID_ID);\n    private final LongOpenHashSet longs = new LongOpenHashSet((int) INVALID_ID);\n    public void add(long id) {\n      if (id == 0) {\n        throw new IllegalArgumentException();\n      } else if (id > 0 && id <= 0x00000000FFFFFFFFL) {\n        this.ints.add((int) id);\n      } else {\n        this.longs.add(id);\n      }\n    }\n    public boolean contains(long id) {\n      if (id >= 0 && id <= 0x00000000FFFFFFFFL) {\n        return this.ints.contains((int) id);\n      } else {\n        return this.longs.contains(id);\n      }\n    }\n    public int size() {\n      return this.ints.size() + this.longs.size();\n    }\n  }<fim_middle>// class below has no smell\n"}