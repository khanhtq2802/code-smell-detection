{"text": "<fim_prefix>/*\n * Copyright (c) 2003, 2015, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\npackage sun.management;\n\nimport java.util.regex.*;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.Iterator;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.util.TreeMap;\nimport sun.management.counter.*;\n\n/**\n * Implementation class of HotspotCompilationMBean interface.\n *\n * Internal, uncommitted management interface for Hotspot compilation\n * system.\n *\n */\nclass HotspotCompilation\n    implements HotspotCompilationMBean {\n\n    private VMManagement jvm;\n\n    /**\n     * Constructor of HotspotRuntime class.\n     */\n    HotspotCompilation(VMManagement vm) {\n        jvm = vm;\n        initCompilerCounters();\n    }\n\n    // Performance counter support\n    private static final String JAVA_CI    = \"java.ci.\";\n    private static final String COM_SUN_CI = \"com.sun.ci.\";\n    private static final String SUN_CI     = \"sun.ci.\";\n    private static final String CI_COUNTER_NAME_PATTERN =\n        JAVA_CI + \"|\" + COM_SUN_CI + \"|\" + SUN_CI;\n\n    private LongCounter compilerThreads;\n    private LongCounter totalCompiles;\n    private LongCounter totalBailouts;\n    private LongCounter totalInvalidates;\n    private LongCounter nmethodCodeSize;\n    private LongCounter nmethodSize;\n    private StringCounter lastMethod;\n    private LongCounter lastSize;\n    private LongCounter lastType;\n    private StringCounter lastFailedMethod;\n    private LongCounter lastFailedType;\n    private StringCounter lastInvalidatedMethod;\n    private LongCounter lastInvalidatedType;\n\n    private class CompilerThreadInfo {\n        String name;\n        StringCounter method;\n        LongCounter type;\n        LongCounter compiles;\n        LongCounter time;\n        CompilerThreadInfo(String bname, int index) {\n            String basename = bname + \".\" + index + \".\";\n            this.name = bname + \"-\" + index;\n            this.method = (StringCounter) lookup(basename + \"method\");\n            this.type = (LongCounter) lookup(basename + \"type\");\n            this.compiles = (LongCounter) lookup(basename + \"compiles\");\n            this.time = (LongCounter) lookup(basename + \"time\");\n        }\n\n        @SuppressWarnings(\"deprecation\")\n        CompilerThreadStat getCompilerThreadStat() {\n            MethodInfo minfo = new MethodInfo(method.stringValue(),\n                                              (int) type.longValue(),\n                                              -1);\n            return new CompilerThreadStat(name,\n                                          compiles.longValue(),\n                                          time.longValue(),\n                                          minfo);\n        }\n    }\n    private List<CompilerThreadInfo> threads;\n    private int numActiveThreads; // number of active compiler threads\n\n    private Map<String, Counter> counters;\n    private Counter lookup(String name) {\n        Counter c = null;\n\n        // Only one counter exists with the specified name in the\n        // current implementation.  We first look up in the SUN_CI namespace\n        // since most counters are in SUN_CI namespace.\n\n        if ((c = counters.get(SUN_CI + name)) != null) {\n            return c;\n        }\n        if ((c = counters.get(COM_SUN_CI + name)) != null) {\n            return c;\n        }\n        if ((c = counters.get(JAVA_CI + name)) != null) {\n            return c;\n        }\n\n        // FIXME: should tolerate if counter doesn't exist\n        throw new AssertionError(\"Counter \" + name + \" does not exist\");\n    }\n\n    private void initCompilerCounters() {\n        // Build a tree map of the current list of performance counters\n        counters = new TreeMap<>();\n        for (Counter c: getInternalCompilerCounters()) {\n            counters.put(c.getName(), c);\n        }\n\n        compilerThreads = (LongCounter) lookup(\"threads\");\n        totalCompiles = (LongCounter) lookup(\"totalCompiles\");\n        totalBailouts = (LongCounter) lookup(\"totalBailouts\");\n        totalInvalidates = (LongCounter) lookup(\"totalInvalidates\");\n        nmethodCodeSize = (LongCounter) lookup(\"nmethodCodeSize\");\n        nmethodSize = (LongCounter) lookup(\"nmethodSize\");\n        lastMethod = (StringCounter) lookup(\"lastMethod\");\n        lastSize = (LongCounter) lookup(\"lastSize\");\n        lastType = (LongCounter) lookup(\"lastType\");\n        lastFailedMethod = (StringCounter) lookup(\"lastFailedMethod\");\n        lastFailedType = (LongCounter) lookup(\"lastFailedType\");\n        lastInvalidatedMethod = (StringCounter) lookup(\"lastInvalidatedMethod\");\n        lastInvalidatedType = (LongCounter) lookup(\"lastInvalidatedType\");\n\n        numActiveThreads = (int) compilerThreads.longValue();\n\n        // Allocate CompilerThreadInfo for compilerThread and adaptorThread\n        threads = new ArrayList<CompilerThreadInfo>();\n\n        for (int i = 0; i < numActiveThreads; i++) {\n            if (counters.containsKey(SUN_CI + \"compilerThread.\" + i + \".method\")) {\n                threads.add(new CompilerThreadInfo(\"compilerThread\", i));\n            }\n        }\n    }\n\n    public int getCompilerThreadCount() {\n        return numActiveThreads;\n    }\n\n    public long getTotalCompileCount() {\n        return totalCompiles.longValue();\n    }\n\n    public long getBailoutCompileCount() {\n        return totalBailouts.longValue();\n    }\n\n    public long getInvalidatedCompileCount() {\n        return totalInvalidates.longValue();\n    }\n\n    public long getCompiledMethodCodeSize() {\n        return nmethodCodeSize.longValue();\n    }\n\n    public long getCompiledMethodSize() {\n        return nmethodSize.longValue();\n    }\n\n    @Deprecated\n    public List<CompilerThreadStat> getCompilerThreadStats() {\n        List<CompilerThreadStat> list = new ArrayList<>(threads.size());\n        for (CompilerThreadInfo info : threads) {\n            list.add(info.getCompilerThreadStat());\n        }\n        return list;\n    }\n\n    public MethodInfo getLastCompile() {\n        return new MethodInfo(lastMethod.stringValue(),\n                              (int) lastType.longValue(),\n                              (int) lastSize.longValue());\n    }\n\n<fim_suffix>    public MethodInfo getFailedCompile() {\n        return new MethodInfo(lastFailedMethod.stringValue(),\n                              (int) lastFailedType.longValue(),\n                              -1);\n    }\n\n    public MethodInfo getInvalidatedCompile() {\n        return new MethodInfo(lastInvalidatedMethod.stringValue(),\n                              (int) lastInvalidatedType.longValue(),\n                              -1);\n    }\n\n    public java.util.List<Counter> getInternalCompilerCounters() {\n        return jvm.getInternalCounters(CI_COUNTER_NAME_PATTERN);\n    }\n}<fim_middle>// function below has no smell\n"}