{"text": "<fim_prefix>package com.microsoft.Malmo.Utils;\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.SocketException;\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\nimport java.nio.channels.AsynchronousSocketChannel;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.logging.Level;\n\n<fim_suffix>public class TCPSocketChannel\n{\n    private AsynchronousSocketChannel channel;\n    private String address;\n    private int port;\n    private String logname;\n\n    /**\n     * Create a TCPSocketChannel that is blocking but times out connects and writes.\n     * @param address The address to connect to.\n     * @param port The port to connect to. 0 value means don't open.\n     * @param logname A name to use for logging.\n     */\n    public TCPSocketChannel(String address, int port, String logname) {\n        this.address = address;\n        this.port = port;\n        this.logname = logname;\n\n        try {\n            connectWithTimeout();\n        } catch (IOException e) {\n            Log(Level.SEVERE, \"Failed to connectWithTimeout AsynchronousSocketChannel: \" + e);\n        } catch (ExecutionException e) {\n            Log(Level.SEVERE, \"Failed to connectWithTimeout AsynchronousSocketChannel: \" + e);\n        } catch (InterruptedException e) {\n            Log(Level.SEVERE, \"Failed to connectWithTimeout AsynchronousSocketChannel: \" + e);\n        } catch (TimeoutException e) {\n            Log(Level.SEVERE, \"AsynchronousSocketChannel connectWithTimeout timed out: \" + e);\n        }\n    }\n\n    public int getPort() { return port; }\n\n    public String getAddress() { return address; }\n\n    public boolean isValid() { return channel != null; }\n\n    public boolean isOpen() { return channel.isOpen(); }\n\n    private void Log(Level level, String message)\n    {\n        TCPUtils.Log(level, \"<-\" + this.logname + \"(\" + this.address + \":\" + this.port + \") \" + message);\n    }\n\n    private void SysLog(Level level, String message)\n    {\n        TCPUtils.SysLog(level, \"<-\" + this.logname + \"(\" + this.address + \":\" + this.port + \") \" + message);\n    }\n\n    private void connectWithTimeout() throws  IOException, ExecutionException, InterruptedException, TimeoutException {\n        if (port == 0)\n            return;\n        InetSocketAddress inetSocketAddress = new InetSocketAddress(address, port);\n        Log(Level.INFO, \"Attempting to open SocketChannel with InetSocketAddress: \" + inetSocketAddress);\n        this.channel = AsynchronousSocketChannel.open();\n        Future<Void> connected = this.channel.connect(inetSocketAddress);\n        connected.get(TCPUtils.DEFAULT_SOCKET_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n    }\n\n    public void close()\n    {\n        Log(Level.INFO, \"Attempting to close channel.\");\n        if (this.channel != null)\n        {\n            try\n            {\n                this.channel.close();\n            }\n            catch (IOException e)\n            {\n                SysLog(Level.SEVERE, \"Failed to close channel: \" + e);\n            }\n        }\n    }\n\n    /**\n     * Send string over TCP to the specified address via the specified port, including a header.\n     *\n     * @param message string to be sent over TCP\n     * @return true if message was successfully sent\n     */\n    public boolean sendTCPString(String message)\n    {\n        return sendTCPString(message, 0);\n    }\n\n    /**\n     * Send string over TCP to the specified address via the specified port, including a header.\n     *\n     * @param message string to be sent over TCP\n     * @param retries number of times to retry in event of failure\n     * @return true if message was successfully sent\n     */\n    public boolean sendTCPString(String message, int retries)\n    {\n        Log(Level.FINE, \"About to send: \" + message);\n        byte[] bytes = message.getBytes();\n        return sendTCPBytes(bytes, retries);\n    }\n\n    /**\n     * Send byte buffer over TCP, including a length header.\n     *\n     * @param buffer the bytes to send\n     * @return true if the message was sent successfully\n     */\n    public boolean sendTCPBytes(byte[] buffer)\n    {\n        return sendTCPBytes(buffer, 0);\n    }\n\n    /**\n     * Send byte buffer over TCP, including a length header.\n     *\n     * @param bytes the bytes to send\n     * @param retries number of times to retry in event of failure\n     * @return true if the message was sent successfully\n     */\n    public boolean sendTCPBytes(byte[] bytes, int retries) {\n        try {\n            ByteBuffer header = createHeader(bytes.length);\n\n            safeWrite(header);\n\n            ByteBuffer buffer = ByteBuffer.wrap(bytes);\n\n            safeWrite(buffer);\n\n        } catch (Exception e) {\n            SysLog(Level.SEVERE, \"Failed to send TCP bytes\" + (retries > 0 ? \" -- retrying \" : \"\") + \": \" + e);\n\n            try {\n                channel.close();\n            } catch (IOException ioe) {\n            }\n\n            if (retries > 0) {\n                try {\n                    connectWithTimeout();\n                } catch (Exception connectException) {\n                    SysLog(Level.SEVERE, \"Failed to reconnect: \" + connectException);\n                    return false;\n                }\n                return sendTCPBytes(bytes, retries - 1);\n            }\n\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Send byte buffer over TCP, including a length header.\n     * \n     * @param srcbuffers the bytes to send\n     * @return true if the message was sent successfully\n     */\n    public boolean sendTCPBytes(ByteBuffer[] srcbuffers, int length)\n    {\n        boolean success = false;\n        try\n        {\n            ByteBuffer header = createHeader(length);\n            ByteBuffer[] buffers = new ByteBuffer[1 + srcbuffers.length];\n            buffers[0] = header;\n            for (int i = 0; i < srcbuffers.length; i++)\n                buffers[i + 1] = srcbuffers[i];\n            if (TCPUtils.isLogging())\n            {\n                long t1 = System.nanoTime();\n                long bytesWritten = write(buffers);\n                long t2 = System.nanoTime();\n                double rate = 1000.0 * 1000.0 * 1000.0 * (double) (bytesWritten) / (1024.0 * (double) (t2 - t1));\n                Log(Level.INFO, \"Sent \" + bytesWritten + \" bytes at \" + rate + \" Kb/s\");\n            }\n            else\n            {\n                write(buffers);\n            }\n            success = true;\n        }\n        catch (Exception e)\n        {\n            SysLog(Level.SEVERE, \"Failed to send TCP bytes: \" + e);\n            try { channel.close(); } catch (IOException ioe) {}\n        }\n        return success;\n    }\n\n    private ByteBuffer createHeader(int length) {\n        ByteBuffer header = ByteBuffer.allocate(4).order(ByteOrder.BIG_ENDIAN).putInt(length);\n        header.flip();\n        return header;\n    }\n\n    private void safeWrite(ByteBuffer buffer) throws InterruptedException, TimeoutException, ExecutionException, IOException {\n        while (buffer.remaining() > 0) {\n            Future<Integer>  future = this.channel.write(buffer);\n            int bytesWritten = future.get(TCPUtils.DEFAULT_SOCKET_TIMEOUT_MS, TimeUnit.MILLISECONDS);\n            if (bytesWritten == 0) {\n                throw new IOException(\"async write failed to send any bytes.\");\n            }\n        }\n    }\n\n    private long write(ByteBuffer[] buffers) throws InterruptedException, TimeoutException, ExecutionException, IOException {\n        long bytesWritten = 0;\n        for (ByteBuffer b : buffers) {\n            bytesWritten += b.remaining();\n            safeWrite(b);\n        }\n        return bytesWritten;\n    }\n}<fim_middle>// class below has no smell\n"}