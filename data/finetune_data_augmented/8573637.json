{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.hadoop.hbase.master.procedure;\n\nimport java.io.IOException;\n\nimport org.apache.hadoop.hbase.ServerName;\nimport org.apache.hadoop.hbase.procedure2.FailedRemoteDispatchException;\nimport org.apache.hadoop.hbase.procedure2.Procedure;\nimport org.apache.hadoop.hbase.procedure2.ProcedureEvent;\nimport org.apache.hadoop.hbase.procedure2.ProcedureSuspendedException;\nimport org.apache.hadoop.hbase.procedure2.ProcedureYieldException;\nimport org.apache.hadoop.hbase.procedure2.RemoteProcedureDispatcher;\nimport org.apache.hadoop.hbase.procedure2.RemoteProcedureException;\nimport org.apache.yetus.audience.InterfaceAudience;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n@InterfaceAudience.Private\n/**\n * This extract the common used methods of procedures which are send to remote servers. Developers\n * who extends this class only need to override remoteCallBuild() and complete(). This procedure\n * will help add the operation to {@link RSProcedureDispatcher}\n *\n * If adding the operation to dispatcher failed, addOperationToNode will throw\n * FailedRemoteDispatchException, and this procedure will return null which procedure Executor will\n * mark this procedure as complete. Thus the upper layer of this procedure must have a way to\n * check if this procedure really succeed and how to deal with it.\n *\n * If sending the operation to remote RS failed, dispatcher will call remoteCallFailed() to\n * handle this, which actually call remoteOperationDone with the exception.\n * If the targetServer crashed but this procedure has no response, than dispatcher will call\n * remoteOperationFailed() to handle this, which also calls remoteOperationDone with the exception.\n * If the operation is successful, then remoteOperationCompleted will be called and actually calls\n * the remoteOperationDone without exception.\n *\n * In remoteOperationDone, we'll check if the procedure is already get wake up by others. Then\n * developer could implement complete() based on their own purpose.\n *\n * But basic logic is that if operation succeed, set succ to true and do the clean work.\n *\n * If operation failed and require to resend it to the same server, leave the succ as false.\n *\n * If operation failed and require to resend it to another server, set succ to true and upper layer\n * should be able to find out this operation not work and send a operation to another server.\n */\npublic abstract class ServerRemoteProcedure extends Procedure<MasterProcedureEnv>\n    implements RemoteProcedureDispatcher.RemoteProcedure<MasterProcedureEnv, ServerName> {\n  protected static final Logger LOG = LoggerFactory.getLogger(ServerRemoteProcedure.class);\n  protected ProcedureEvent<?> event;\n  protected ServerName targetServer;\n  protected boolean dispatched;\n  protected boolean succ;\n\n  protected abstract void complete(MasterProcedureEnv env, Throwable error);\n\n  @Override\n  protected synchronized Procedure<MasterProcedureEnv>[] execute(MasterProcedureEnv env)\n      throws ProcedureYieldException, ProcedureSuspendedException, InterruptedException {\n    if (dispatched) {\n      if (succ) {\n        return null;\n      }\n      dispatched = false;\n    }\n    try {\n      env.getRemoteDispatcher().addOperationToNode(targetServer, this);\n    } catch (FailedRemoteDispatchException frde) {\n      LOG.warn(\"Can not send remote operation {} to {}, this operation will \"\n          + \"be retried to send to another server\",\n        this.getProcId(), targetServer);\n      return null;\n    }\n    dispatched = true;\n    event = new ProcedureEvent<>(this);\n    event.suspendIfNotReady(this);\n    throw new ProcedureSuspendedException();\n  }\n\n  @Override\n  protected synchronized void completionCleanup(MasterProcedureEnv env) {\n    env.getRemoteDispatcher().removeCompletedOperation(targetServer, this);\n  }\n\n  @Override\n  public synchronized void remoteCallFailed(MasterProcedureEnv env, ServerName serverName,\n      IOException exception) {\n    remoteOperationDone(env, exception);\n  }\n\n  @Override\n  public synchronized void remoteOperationCompleted(MasterProcedureEnv env) {\n    remoteOperationDone(env, null);\n  }\n\n  @Override\n  public synchronized void remoteOperationFailed(MasterProcedureEnv env,\n      RemoteProcedureException error) {\n    remoteOperationDone(env, error);\n  }\n\n<fim_suffix>  synchronized void remoteOperationDone(MasterProcedureEnv env, Throwable error) {\n    if (this.isFinished()) {\n      LOG.info(\"This procedure {} is already finished, skip the rest processes\", this.getProcId());\n      return;\n    }\n    if (event == null) {\n      LOG.warn(\"procedure event for {} is null, maybe the procedure is created when recovery\",\n          getProcId());\n      return;\n    }\n    complete(env, error);\n    event.wake(env.getProcedureScheduler());\n    event = null;\n  }\n}<fim_middle>// function below has no smell\n"}