{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.giraph.ooc.persistence;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Index chain used in out-of-core data accessor object (DAO) to access\n * serialized data.\n */\n<fim_suffix>public class DataIndex {\n  /** Chain of data indices */\n  private final List<DataIndexEntry> indexList = new ArrayList<>(5);\n\n  /**\n   * Add an index to the index chain\n   *\n   * @param entry the entry to add to the chain\n   * @return the index chain itself\n   */\n  public DataIndex addIndex(DataIndexEntry entry) {\n    indexList.add(entry);\n    return this;\n  }\n\n  /**\n   * Remove/Pop the last index in the index chain\n   *\n   * @return the index chain itself\n   */\n  public DataIndex removeLastIndex() {\n    indexList.remove(indexList.size() - 1);\n    return this;\n  }\n\n  /**\n   * Create a copy of the existing DataIndex\n   *\n   * @return a copy of the existing index chain\n   */\n  public DataIndex copy() {\n    DataIndex index = new DataIndex();\n    for (DataIndexEntry entry : indexList) {\n      index.indexList.add(entry);\n    }\n    return index;\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (!(obj instanceof DataIndex)) {\n      return false;\n    }\n    DataIndex dataIndex = (DataIndex) obj;\n    return indexList.equals(dataIndex.indexList);\n  }\n\n  @Override\n  public int hashCode() {\n    return indexList.hashCode();\n  }\n\n  @Override\n  public String toString() {\n    StringBuffer sb = new StringBuffer();\n    for (DataIndexEntry entry : indexList) {\n      sb.append(entry);\n    }\n    return sb.toString();\n  }\n\n  /** Interface to unify different types of entries used as index chain */\n  public interface DataIndexEntry { }\n\n  /**\n   * Different static types of index chain entry\n   */\n  public enum TypeIndexEntry implements DataIndexEntry {\n    /** The whole partition */\n    PARTITION(\"_partition\"),\n    /** Partition vertices */\n    PARTITION_VERTICES(\"_vertices\"),\n    /** Partition edges */\n    PARTITION_EDGES(\"_edges\"),\n    /** Partition messages */\n    MESSAGE(\"_messages\"),\n    /** Edges stored in edge store for a partition */\n    EDGE_STORE(\"_edge_store\"),\n    /** Raw data buffer (refer to DiskBackedDataStore) */\n    BUFFER(\"_buffer\");\n\n    /** String realization of entry type */\n    private final String name;\n\n    /**\n     * Constructor\n     *\n     * @param name name of the type\n     */\n    TypeIndexEntry(String name) {\n      this.name = name;\n    }\n\n    public String getName() {\n      return name;\n    }\n\n    @Override\n    public String toString() {\n      return name;\n    }\n  }\n\n  /**\n   * Class representing any index chain that depends on something with id.\n   * Generally this is used for identifying indices in two types:\n   *  - Index entry based on superstep id ('S' and the superstep number)\n   *  - Index entry based on partition id ('P' and the partition id)\n   */\n  public static final class NumericIndexEntry implements DataIndexEntry {\n    /** Type of index */\n    private final char type;\n    /** Id of the index associated with the specified type */\n    private final long id;\n\n    /**\n     * Constructor\n     *\n     * @param type type of index (for now 'S' for superstep, or 'P' for\n     *             partition)\n     * @param id id of the index associated with the given type\n     */\n    private NumericIndexEntry(char type, long id) {\n      this.type = type;\n      this.id = id;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n      if (!(obj instanceof NumericIndexEntry)) {\n        return false;\n      }\n      NumericIndexEntry index = (NumericIndexEntry) obj;\n      return index.type == type && index.id == id;\n    }\n\n    @Override\n    public int hashCode() {\n      int result = 17;\n      result = result * 37 + type;\n      result = result * 37 + (int) id;\n      result = result * 37 + (int) (id >> 32);\n      return result;\n    }\n\n    @Override\n    public String toString() {\n      return String.format(\"_%c%d\", type, id);\n    }\n\n    /**\n     * Create a data index entry for a given partition\n     *\n     * @param partitionId id of the partition\n     * @return data index entry for a given partition\n     */\n    public static NumericIndexEntry createPartitionEntry(int partitionId) {\n      return new NumericIndexEntry('P', partitionId);\n    }\n\n    /**\n     * Create a data index entry for a given superstep\n     *\n     * @param superstep the superstep number\n     * @return data index entry for a given superstep\n     */\n    public static NumericIndexEntry createSuperstepEntry(long superstep) {\n      return new NumericIndexEntry('S', superstep);\n    }\n  }\n}<fim_middle>// class below has no smell\n"}