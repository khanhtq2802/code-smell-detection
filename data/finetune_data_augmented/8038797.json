{"text": "<fim_prefix>\t\tif (externalForm == null)\n\t\t\treturn null;\n\t\tList<String> split = Strings.split(externalForm, delim);\n\t\tif (split.size() != 3) {\n\t\t\tURI uri = URI.createURI(externalForm);\n\t\t\tURI packURI = uri.trimFragment();\n\t\t\tEPackage ePackage = registry.getEPackage(packURI.toString());\n\t\t\tif (ePackage == null)\n\t\t\t\treturn null;\n\t\t\tEReference result = (EReference) ePackage.eResource().getEObject(uri.fragment());\n\t\t\treturn result;\n\t\t}\n\t\tEPackage ePackage = registry.getEPackage(split.get(0));\n\t\tif (ePackage == null)\n\t\t\treturn null;\n\t\tEClass clazz = (EClass) ePackage.getEClassifier(split.get(1));\n\t\tif (clazz == null)\n\t\t\treturn null;\n\t\treturn (EReference) clazz.getEStructuralFeature(Integer.valueOf(split.get(2)));\n\t}\n\tpublic static boolean hasSameURI(EObject o0, EObject o1) {\n\t\treturn EcoreUtil.getURI(o0).equals(EcoreUtil.getURI(o1));\n\t}\n\tpublic static URI getNormalizedResourceURI(EObject eObject) {\n\t\tif(eObject.eResource() != null)\n\t\t\treturn getNormalizedURI(eObject.eResource());\n\t\treturn URIConverter.INSTANCE.normalize(EcoreUtil.getURI(eObject).trimFragment());\n\t}\n\tpublic static URI getNormalizedURI(EObject eObject) {\n\t\tURI rawURI = EcoreUtil.getURI(eObject);\n\t\tResource resource = eObject.eResource();\n\t\tif(resource != null && resource.getResourceSet() != null) {\n\t\t\treturn resource.getResourceSet().getURIConverter().normalize(rawURI);\n\t\t} else {\n\t\t\treturn URIConverter.INSTANCE.normalize(rawURI);\n\t\t}\n\t}\n\tpublic static URI getNormalizedURI(Resource resource) {\n\t\tif(resource.getResourceSet() != null) {\n\t\t\treturn resource.getResourceSet().getURIConverter().normalize(resource.getURI());\n\t\t} else {\n\t\t\treturn URIConverter.INSTANCE.normalize(resource.getURI());\n\t\t}\n\t}\n\t/**\n\t * @return the eobject's URI in the normalized form or as is if it is a platform:/resource URI.\n\t * @since 2.4\n\t */\n\tpublic static URI getPlatformResourceOrNormalizedURI(EObject eObject) {\n\t\tURI rawURI = EcoreUtil.getURI(eObject);\n\t\tif (rawURI.isPlatformResource()) {\n\t\t\treturn rawURI;\n\t\t}\n\t\tResource resource = eObject.eResource();\n\t\tif(resource != null && resource.getResourceSet() != null) {\n\t\t\treturn resource.getResourceSet().getURIConverter().normalize(rawURI);\n\t\t} else {\n\t\t\treturn URIConverter.INSTANCE.normalize(rawURI);\n\t\t}\n\t}\n\t/**\n\t * @return the resources uri in the normalized form or as is if it is a platform:/resource URI.\n\t * @since 2.4\n\t */\n\tpublic static URI getPlatformResourceOrNormalizedURI(Resource resource) {\n\t\tURI rawURI = resource.getURI();\n\t\tif (rawURI.isPlatformResource()) {\n\t\t\treturn rawURI;\n\t\t}\n\t\tif(resource.getResourceSet() != null) {\n\t\t\treturn resource.getResourceSet().getURIConverter().normalize(rawURI);\n\t\t} else {\n\t\t\treturn URIConverter.INSTANCE.normalize(rawURI);\n\t\t}\n\t}\n\t/**\n\t * A better performing alternative to the {@link org.eclipse.emf.ecore.util.EcoreUtil.CrossReferencer}.\n\t * \n\t * @since 2.4\n\t */\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void findCrossReferences(EObject rootElement, Set<? extends EObject> targets, ElementReferenceAcceptor acceptor) {\n\t\tfor(EReference ref: rootElement.eClass().getEAllReferences()) {\n\t\t\tif(rootElement.eIsSet(ref)) {\n\t\t\t\tif(ref.isContainment()) {\n\t\t\t\t\tObject content = rootElement.eGet(ref, false);\n\t\t\t\t\tif(ref.isMany()) {\n\t\t\t\t\t\tInternalEList<EObject> contentList = (InternalEList<EObject>) content;\n\t\t\t\t\t\tfor(int i=0; i<contentList.size(); ++i) {\n\t\t\t\t\t\t\tEObject childElement = contentList.basicGet(i);\n\t\t\t\t\t\t\tif(!childElement.eIsProxy())\n\t\t\t\t\t\t\t\tfindCrossReferences(childElement, targets, acceptor);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tEObject childElement = (EObject) content;\n\t\t\t\t\t\tif(!childElement.eIsProxy())\n\t\t\t\t\t\t\tfindCrossReferences(childElement, targets, acceptor);\n\t\t\t\t\t}\n\t\t\t\t} else if (!ref.isContainer()) {\n\t\t\t\t\tObject value = rootElement.eGet(ref, false);\n\t\t\t\t\tif(ref.isMany()) {\n\t\t\t\t\t\tInternalEList<EObject> values = (InternalEList<EObject>) value;\n\t\t\t\t\t\tfor(int i=0; i< values.size(); ++i) {\n\t\t\t\t\t\t\tEObject refElement = values.get(i);\n\t\t\t\t\t\t\tif(targets.contains(refElement)) {\n\t\t\t\t\t\t\t\tacceptor.accept(rootElement, refElement, ref, i);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tEObject refElement = (EObject) value;\n\t\t\t\t\t\tif(targets.contains(refElement)) {\n\t\t\t\t\t\t\tacceptor.accept(rootElement, refElement, ref, -1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * @since 2.4\n\t */\n\tpublic static interface ElementReferenceAcceptor {\n\t\tvoid accept(EObject referrer, EObject referenced, EReference reference, int index);\n\t}\n\t/**\n\t * @since 2.6\n\t */\n\tpublic static TreeIterator<EObject> getAllNonDerivedContents(EObject root, boolean includeRoot) {\n\t\t/*\n\t\t * We cannot simply use root.eAllContents here since the iterator\n\t\t * will probe for #hasNext on each invocation of #next. This is usually\n\t\t * not a problem but with derived containment, it becomes an issue.\n\t\t * For example, the accessor of XAbstractFeatureCall#getImplicitReceiver uses #getFeature\n\t\t * to initialize itself. This will cause the potential proxy feature\n\t\t * to be resolved which in turn tries to access the mapped proxy URI fragments\n\t\t * in the resource. Now these fragments are currently in the process of being\n\t\t * updated, e.g. there may not even be enough entries. Thus #getFeature\n\t\t * shall not be called here. Long story short, this iterator filters\n\t\t * derived containment features.\n\t\t */\n\t\treturn new AbstractTreeIterator<EObject>(root, includeRoot) {\n\t\t\tprivate static final long serialVersionUID = 1L;\n\t\t\t@Override\n\t\t\tpublic Iterator<EObject> getChildren(Object object) {\n\t\t\t\tEObject eObject = (EObject) object;\n\t\t\t\treturn getNonDerivedContents(eObject);\n\t\t\t}\n\t\t};\n\t}\n\t/**\n\t * Same as {@link #getAllNonDerivedContents(EObject, boolean) getAllNonDerivedContents(root, false)}. \n\t * @since 2.6\n\t */\n\tpublic static TreeIterator<EObject> getAllNonDerivedContents(EObject root) {\n\t\treturn getAllNonDerivedContents(root, false);\n\t}\n\t/**\n\t * @since 2.6\n\t */\n<fim_suffix>\tpublic static Iterator<EObject> getNonDerivedContents(EObject eObject) {\n\t\tEClassImpl.FeatureSubsetSupplier featureSupplier = (EClassImpl.FeatureSubsetSupplier) eObject.eClass().getEAllStructuralFeatures();\n\t\tEStructuralFeature[] eStructuralFeatures = featureSupplier.containments();\n\t\treturn (eStructuralFeatures == null \n\t\t\t\t? EContentsEList.<EObject> emptyContentsEList()\n\t\t\t\t: new EContentsEList<EObject>(eObject, eStructuralFeatures) {\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected ListIterator<EObject> newResolvingListIterator() {\n\t\t\t\t\t\treturn new ResolvingFeatureIteratorImpl<EObject>(eObject, eStructuralFeatures) {\n\t\t\t\t\t\t\t@Override\n\t\t\t\t\t\t\tprotected boolean isIncluded(EStructuralFeature eStructuralFeature) {\n\t\t\t\t\t\t\t\treturn !eStructuralFeature.isDerived();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}).iterator();\n\t}<fim_middle>// function below has no smell\n"}