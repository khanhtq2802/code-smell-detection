{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.hadoop.hive.ql.optimizer.calcite.translator;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.apache.calcite.rel.RelCollations;\nimport org.apache.calcite.rel.RelNode;\nimport org.apache.calcite.rel.core.Project;\nimport org.apache.calcite.rel.core.Sort;\nimport org.apache.calcite.rel.type.RelDataType;\nimport org.apache.calcite.rex.RexCall;\nimport org.apache.calcite.rex.RexInputRef;\nimport org.apache.calcite.rex.RexNode;\nimport org.apache.calcite.util.Pair;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.apache.hadoop.hive.metastore.api.FieldSchema;\nimport org.apache.hadoop.hive.ql.optimizer.calcite.CalciteSemanticException;\nimport org.apache.hadoop.hive.ql.optimizer.calcite.HiveCalciteUtil;\nimport org.apache.hadoop.hive.ql.optimizer.calcite.reloperators.HiveProject;\nimport org.apache.hadoop.hive.ql.optimizer.calcite.reloperators.HiveSortLimit;\n\nimport com.google.common.collect.ImmutableMap;\n\n<fim_suffix>public class PlanModifierUtil {\n\n  private static final Logger LOG = LoggerFactory.getLogger(PlanModifierUtil.class);\n\n\n  protected static void fixTopOBSchema(final RelNode rootRel,\n      Pair<RelNode, RelNode> topSelparentPair, List<FieldSchema> resultSchema,\n      boolean replaceProject) throws CalciteSemanticException {\n    if (!(topSelparentPair.getKey() instanceof Sort)\n        || !HiveCalciteUtil.orderRelNode(topSelparentPair.getKey())) {\n      return;\n    }\n    HiveSortLimit obRel = (HiveSortLimit) topSelparentPair.getKey();\n    Project obChild = (Project) topSelparentPair.getValue();\n    if (obChild.getRowType().getFieldCount() <= resultSchema.size()) {\n      return;\n    }\n\n    RelDataType rt = obChild.getRowType();\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    Set<Integer> collationInputRefs = new HashSet(\n        RelCollations.ordinals(obRel.getCollation()));\n    ImmutableMap.Builder<Integer, RexNode> inputRefToCallMapBldr = ImmutableMap.builder();\n    for (int i = resultSchema.size(); i < rt.getFieldCount(); i++) {\n      if (collationInputRefs.contains(i)) {\n        RexNode obyExpr = obChild.getChildExps().get(i);\n        if (obyExpr instanceof RexCall) {\n          LOG.debug(\"Old RexCall : \" + obyExpr);\n          obyExpr = adjustOBSchema((RexCall) obyExpr, obChild, resultSchema);\n          LOG.debug(\"New RexCall : \" + obyExpr);\n        }\n        inputRefToCallMapBldr.put(i, obyExpr);\n      }\n    }\n    ImmutableMap<Integer, RexNode> inputRefToCallMap = inputRefToCallMapBldr.build();\n\n    if ((obChild.getRowType().getFieldCount() - inputRefToCallMap.size()) != resultSchema.size()) {\n      LOG.error(generateInvalidSchemaMessage(obChild, resultSchema, inputRefToCallMap.size()));\n      throw new CalciteSemanticException(\"Result Schema didn't match Optimized Op Tree Schema\");\n    }\n\n    if (replaceProject) {\n      // This removes order-by only expressions from the projections.\n      HiveProject replacementProjectRel = HiveProject.create(obChild.getInput(), obChild\n          .getChildExps().subList(0, resultSchema.size()), obChild.getRowType().getFieldNames()\n          .subList(0, resultSchema.size()));\n      obRel.replaceInput(0, replacementProjectRel);\n    }\n    obRel.setInputRefToCallMap(inputRefToCallMap);\n  }\n\n  private static RexCall adjustOBSchema(RexCall obyExpr, Project obChild,\n          List<FieldSchema> resultSchema) {\n    int a = -1;\n    List<RexNode> operands = new ArrayList<>();\n    for (int k = 0; k < obyExpr.operands.size(); k++) {\n      RexNode rn = obyExpr.operands.get(k);\n      for (int j = 0; j < resultSchema.size(); j++) {\n        if( obChild.getChildExps().get(j).toString().equals(rn.toString())) {\n          a = j;\n          break;\n        }\n      }\n      if (a != -1) {\n        operands.add(new RexInputRef(a, rn.getType()));\n      } else {\n        if (rn instanceof RexCall) {\n          operands.add(adjustOBSchema((RexCall)rn, obChild, resultSchema));\n        } else {\n          operands.add(rn);\n        }\n      }\n      a = -1;\n    }\n    return (RexCall) obChild.getCluster().getRexBuilder().makeCall(\n            obyExpr.getType(), obyExpr.getOperator(), operands);\n  }\n\n  protected static String generateInvalidSchemaMessage(Project topLevelProj,\n      List<FieldSchema> resultSchema, int fieldsForOB) {\n    String errorDesc = \"Result Schema didn't match Calcite Optimized Op Tree; schema: \";\n    for (FieldSchema fs : resultSchema) {\n      errorDesc += \"[\" + fs.getName() + \":\" + fs.getType() + \"], \";\n    }\n    errorDesc += \" projection fields: \";\n    for (RexNode exp : topLevelProj.getChildExps()) {\n      errorDesc += \"[\" + exp.toString() + \":\" + exp.getType() + \"], \";\n    }\n    if (fieldsForOB != 0) {\n      errorDesc += fieldsForOB + \" fields removed due to ORDER BY  \";\n    }\n    return errorDesc.substring(0, errorDesc.length() - 2);\n  }\n\n}<fim_middle>// class below is blob\n"}