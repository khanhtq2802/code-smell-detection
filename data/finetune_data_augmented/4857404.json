{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.jackrabbit.oak.segment.tool;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.collect.Lists.reverse;\nimport static org.apache.jackrabbit.oak.commons.PathUtils.elements;\nimport static org.apache.jackrabbit.oak.segment.RecordId.fromString;\nimport static org.apache.jackrabbit.oak.segment.file.FileStoreBuilder.fileStoreBuilder;\nimport static org.apache.jackrabbit.oak.segment.tool.Utils.newBasicReadOnlyBlobStore;\nimport static org.apache.jackrabbit.oak.segment.tool.Utils.readRevisions;\nimport java.io.File;\nimport java.io.PrintWriter;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.apache.jackrabbit.oak.segment.RecordId;\nimport org.apache.jackrabbit.oak.segment.SegmentIdProvider;\nimport org.apache.jackrabbit.oak.segment.SegmentNotFoundException;\nimport org.apache.jackrabbit.oak.segment.file.ReadOnlyFileStore;\nimport org.apache.jackrabbit.oak.spi.state.NodeState;\n/**\n * Shows the differences between two head states.\n */\npublic class Diff {\n    /**\n     * Create a builder for the {@link Diff} command.\n     *\n     * @return an instance of {@link Builder}.\n     */\n    public static Builder builder() {\n        return new Builder();\n    }\n    /**\n     * Collect options for the {@link Diff} command.\n     */\n<fim_suffix>    public static class Builder {\n        private File path;\n        private String interval;\n        private boolean incremental;\n        private File out;\n        private String filter;\n        private boolean ignoreMissingSegments;\n        private Builder() {\n            // Prevent external instantiation.\n        }\n        /**\n         * The path to an existing segment store. This parameter is required.\n         *\n         * @param path the path to an existing segment store.\n         * @return this builder.\n         */\n        public Builder withPath(File path) {\n            this.path = checkNotNull(path);\n            return this;\n        }\n        /**\n         * The two node records to diff specified as a record ID interval. This\n         * parameter is required.\n         * <p>\n         * The interval is specified as two record IDs separated by two full\n         * stops ({@code ..}). In example, {@code 333dc24d-438f-4cca-8b21-3ebf67c05856:12345..46116fda-7a72-4dbc-af88-a09322a7753a:67890}.\n         * Instead of using a full record ID, it is possible to use the special\n         * placeholder {@code head}. This placeholder is translated to the\n         * record ID of the most recent head state.\n         *\n         * @param interval an interval between two node record IDs.\n         * @return this builder.\n         */\n        public Builder withInterval(String interval) {\n            this.interval = checkNotNull(interval);\n            return this;\n        }\n        /**\n         * Set whether or not to perform an incremental diff of the specified\n         * interval. An incremental diff shows every change between the two\n         * records at every revision available to the segment store. This\n         * parameter is not mandatory and defaults to {@code false}.\n         *\n         * @param incremental {@code true} to perform an incremental diff,\n         *                    {@code false} otherwise.\n         * @return this builder.\n         */\n        public Builder withIncremental(boolean incremental) {\n            this.incremental = incremental;\n            return this;\n        }\n        /**\n         * The file where the output of this command is stored. this parameter\n         * is mandatory.\n         *\n         * @param file the output file.\n         * @return this builder.\n         */\n        public Builder withOutput(File file) {\n            this.out = checkNotNull(file);\n            return this;\n        }\n        /**\n         * The path to a subtree. If specified, this parameter allows to\n         * restrict the diff to the specified subtree. This parameter is not\n         * mandatory and defaults to the entire tree.\n         *\n         * @param filter a path used as as filter for the resulting diff.\n         * @return this builder.\n         */\n        public Builder withFilter(String filter) {\n            this.filter = checkNotNull(filter);\n            return this;\n        }\n        /**\n         * Whether to ignore exceptions caused by missing segments in the\n         * segment store. This parameter is not mandatory and defaults to {@code\n         * false}.\n         *\n         * @param ignoreMissingSegments {@code true} to ignore exceptions caused\n         *                              by missing segments, {@code false}\n         *                              otherwise.\n         * @return this builder.\n         */\n        public Builder withIgnoreMissingSegments(boolean ignoreMissingSegments) {\n            this.ignoreMissingSegments = ignoreMissingSegments;\n            return this;\n        }\n        /**\n         * Create an executable version of the {@link Diff} command.\n         *\n         * @return an instance of {@link Runnable}.\n         */\n        public Diff build() {\n            checkNotNull(path);\n            checkNotNull(interval);\n            checkNotNull(out);\n            checkNotNull(filter);\n            return new Diff(this);\n        }\n    }\n    private final File path;\n    private final String interval;\n    private final boolean incremental;\n    private final File out;\n    private final String filter;\n    private final boolean ignoreMissingSegments;\n    private Diff(Builder builder) {\n        this.path = builder.path;\n        this.interval = builder.interval;\n        this.incremental = builder.incremental;\n        this.out = builder.out;\n        this.filter = builder.filter;\n        this.ignoreMissingSegments = builder.ignoreMissingSegments;\n    }\n    public int run() {\n        try {\n            diff();\n            return 0;\n        } catch (Exception e) {\n            e.printStackTrace(System.err);\n            return 1;\n        }\n    }\n    private void diff() throws Exception {\n        System.out.println(\"Store \" + path);\n        System.out.println(\"Writing diff to \" + out);\n        String[] tokens = interval.trim().split(\"\\\\.\\\\.\");\n        if (tokens.length != 2) {\n            System.out.println(\"Error parsing revision interval '\" + interval + \"'.\");\n            return;\n        }\n        try (ReadOnlyFileStore store = fileStoreBuilder(path).withBlobStore(newBasicReadOnlyBlobStore()).buildReadOnly()) {\n            SegmentIdProvider idProvider = store.getSegmentIdProvider();\n            RecordId idL;\n            try {\n                if (tokens[0].equalsIgnoreCase(\"head\")) {\n                    idL = store.getRevisions().getHead();\n                } else {\n                    idL = fromString(idProvider, tokens[0]);\n                }\n            } catch (IllegalArgumentException e) {\n                System.out.println(\"Invalid left endpoint for interval \" + interval);\n                return;\n            }\n            RecordId idR;\n            try {\n                if (tokens[1].equalsIgnoreCase(\"head\")) {\n                    idR = store.getRevisions().getHead();\n                } else {\n                    idR = fromString(idProvider, tokens[1]);\n                }\n            } catch (IllegalArgumentException e) {\n                System.out.println(\"Invalid left endpoint for interval \" + interval);\n                return;\n            }\n            long start = System.currentTimeMillis();\n            try (PrintWriter pw = new PrintWriter(out)) {\n                if (incremental) {\n                    List<String> revs = readRevisions(path);\n                    System.out.println(\"Generating diff between \" + idL + \" and \" + idR + \" incrementally. Found \" + revs.size() + \" revisions.\");\n                    int s = revs.indexOf(idL.toString10());\n                    int e = revs.indexOf(idR.toString10());\n                    if (s == -1 || e == -1) {\n                        System.out.println(\"Unable to match input revisions with FileStore.\");\n                        return;\n                    }\n                    List<String> revDiffs = revs.subList(Math.min(s, e), Math.max(s, e) + 1);\n                    if (s > e) {\n                        // reverse list\n                        revDiffs = reverse(revDiffs);\n                    }\n                    if (revDiffs.size() < 2) {\n                        System.out.println(\"Nothing to diff: \" + revDiffs);\n                        return;\n                    }\n                    Iterator<String> revDiffsIt = revDiffs.iterator();<fim_middle>// class below is data class\n"}