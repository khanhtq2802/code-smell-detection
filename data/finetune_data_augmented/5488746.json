{"text": "<fim_prefix>        private DeleteDeleteTask _deleteTask;\n        public ClearOwnerAction(final Deletable<? extends Deletable> lifetimeObject)\n        {\n            _lifetimeObject = lifetimeObject;\n        }\n        @Override\n        public void performAction(final Deletable object)\n        {\n            if(AbstractQueue.this._exclusiveOwner == _lifetimeObject)\n            {\n                AbstractQueue.this._exclusiveOwner = null;\n            }\n            if(_deleteTask != null)\n            {\n                removeDeleteTask(_deleteTask);\n            }\n        }\n        public void setDeleteTask(final DeleteDeleteTask deleteTask)\n        {\n            _deleteTask = deleteTask;\n        }\n    }\n    //=============\n    @StateTransition(currentState = {State.UNINITIALIZED,State.ERRORED}, desiredState = State.ACTIVE)\n    private ListenableFuture<Void> activate()\n    {\n        _virtualHost.scheduleHouseKeepingTask(_virtualHost.getHousekeepingCheckPeriod(), _queueHouseKeepingTask);\n        setState(State.ACTIVE);\n        return Futures.immediateFuture(null);\n    }\n    @Override\n    protected ListenableFuture<Void> onDelete()\n    {\n        return Futures.transform(performDelete(), i -> null, getTaskExecutor());\n    }\n    @Override\n    public ExclusivityPolicy getExclusive()\n    {\n        return _exclusive;\n    }\n    @Override\n    public OverflowPolicy getOverflowPolicy()\n    {\n        return _overflowPolicy;\n    }\n    @Override\n    public boolean isNoLocal()\n    {\n        return _noLocal;\n    }\n    @Override\n    public String getMessageGroupKeyOverride()\n    {\n        return _messageGroupKeyOverride;\n    }\n    @Override\n    public MessageGroupType getMessageGroupType()\n    {\n        return _messageGroupType;\n    }\n    @Override\n    public String getMessageGroupDefaultGroup()\n    {\n        return _messageGroupDefaultGroup;\n    }\n    @Override\n    public int getMaximumDistinctGroups()\n    {\n        return _maximumDistinctGroups;\n    }\n    @Override\n    public boolean isQueueFlowStopped()\n    {\n        if (_postEnqueueOverflowPolicyHandler instanceof ProducerFlowControlOverflowPolicyHandler)\n        {\n            return ((ProducerFlowControlOverflowPolicyHandler) _postEnqueueOverflowPolicyHandler).isQueueFlowStopped();\n        }\n        return false;\n    }\n    @Override\n    public <C extends ConfiguredObject> Collection<C> getChildren(final Class<C> clazz)\n    {\n        if(clazz == org.apache.qpid.server.model.Consumer.class)\n        {\n            return _queueConsumerManager == null\n                    ? Collections.<C>emptySet()\n                    : (Collection<C>) Lists.newArrayList(_queueConsumerManager.getAllIterator());\n        }\n        else return Collections.emptySet();\n    }\n    @Override\n    protected void changeAttributes(final Map<String, Object> attributes)\n    {\n        final OverflowPolicy existingOverflowPolicy = getOverflowPolicy();\n        final ExclusivityPolicy existingExclusivePolicy = getExclusive();\n        super.changeAttributes(attributes);\n        // Overflow policies depend on queue depth attributes.\n        // Thus, we need to create and invoke  overflow policy handler\n        // after all required attributes are changed.\n        if (attributes.containsKey(OVERFLOW_POLICY) && existingOverflowPolicy != _overflowPolicy)\n        {\n            if (existingOverflowPolicy == OverflowPolicy.REJECT)\n            {\n                _rejectPolicyHandler = null;\n            }\n            createOverflowPolicyHandlers(_overflowPolicy);\n            _postEnqueueOverflowPolicyHandler.checkOverflow(null);\n        }\n        if (attributes.containsKey(EXCLUSIVE) && existingExclusivePolicy != _exclusive)\n        {\n            ExclusivityPolicy newPolicy = _exclusive;\n            try\n            {\n                _exclusive = existingExclusivePolicy;\n                updateExclusivityPolicy(newPolicy);\n            }\n            catch (ExistingConsumerPreventsExclusive existingConsumerPreventsExclusive)\n            {\n                throw new IllegalArgumentException(\"Unable to set exclusivity policy to \" + newPolicy + \" as an existing combinations of consumers prevents this\");\n            }\n        }\n    }\n    private static final String[] NON_NEGATIVE_NUMBERS = {\n        ALERT_REPEAT_GAP,\n        ALERT_THRESHOLD_MESSAGE_AGE,\n        ALERT_THRESHOLD_MESSAGE_SIZE,\n        ALERT_THRESHOLD_QUEUE_DEPTH_MESSAGES,\n        ALERT_THRESHOLD_QUEUE_DEPTH_BYTES,\n        MAXIMUM_DELIVERY_ATTEMPTS\n    };\n    @Override\n    protected void validateChange(final ConfiguredObject<?> proxyForValidation, final Set<String> changedAttributes)\n    {\n        super.validateChange(proxyForValidation, changedAttributes);\n        Queue<?> queue = (Queue) proxyForValidation;\n        for (String attrName : NON_NEGATIVE_NUMBERS)\n        {\n            if (changedAttributes.contains(attrName))\n            {\n                Object value = queue.getAttribute(attrName);\n                if (!(value instanceof Number) || ((Number) value).longValue() < 0)\n                {\n                    throw new IllegalConfigurationException(\n                            \"Only positive integer value can be specified for the attribute \"\n                            + attrName);\n                }\n            }\n        }\n        if (changedAttributes.contains(ALTERNATE_BINDING))\n        {\n            validateOrCreateAlternateBinding(queue, false);\n        }\n        if (changedAttributes.contains(ConfiguredObject.DESIRED_STATE) && proxyForValidation.getDesiredState() == State.DELETED)\n        {\n            if(hasReferrers())\n            {\n                throw new MessageDestinationIsAlternateException(getName());\n            }\n        }\n    }\n    @Override\n    public NamedAddressSpace getAddressSpace()\n    {\n        return _virtualHost;\n    }\n    @Override\n    public void authorisePublish(final SecurityToken token, final Map<String, Object> arguments)\n            throws AccessControlException\n    {\n        authorise(token, PUBLISH_ACTION, arguments);\n    }\n    @Override\n    protected void logOperation(final String operation)\n    {\n        getEventLogger().message(QueueMessages.OPERATION(operation));\n    }\n    private class DeletedChildListener extends AbstractConfigurationChangeListener\n    {\n        @Override\n        public void stateChanged(final ConfiguredObject object, final State oldState, final State newState)\n        {\n            if(newState == State.DELETED)\n            {\n                AbstractQueue.this.childRemoved(object);\n            }\n        }\n    }\n    private static class EnqueueRequest\n    {\n        private final MessageReference<?> _message;\n        private final Action<? super MessageInstance> _action;\n        private final MessageEnqueueRecord _enqueueRecord;\n        public EnqueueRequest(final ServerMessage message,\n                              final Action<? super MessageInstance> action,\n                              final MessageEnqueueRecord enqueueRecord)\n        {\n            _enqueueRecord = enqueueRecord;\n            _message = message.newReference();\n            _action = action;\n        }\n        public MessageReference<?> getMessage()\n        {\n            return _message;\n        }\n        public Action<? super MessageInstance> getAction()\n        {\n            return _action;\n        }\n        public MessageEnqueueRecord getEnqueueRecord()\n        {\n            return _enqueueRecord;\n        }\n    }\n    @Override\n    public List<Long> moveMessages(Queue<?> destination, List<Long> messageIds, final String selector, final int limit)\n    {\n        MoveMessagesTransaction transaction = new MoveMessagesTransaction(this,\n                                                                          messageIds,\n                                                                          destination,\n                                                                          parseSelector(selector),\n                                                                          limit);\n        _virtualHost.executeTransaction(transaction);\n        return transaction.getModifiedMessageIds();\n    }\n    @Override\n    public List<Long> copyMessages(Queue<?> destination, List<Long> messageIds, final String selector, int limit)\n    {\n        CopyMessagesTransaction transaction = new CopyMessagesTransaction(this,\n                                                                          messageIds,\n                                                                          destination,\n                                                                          parseSelector(selector),\n                                                                          limit);\n        _virtualHost.executeTransaction(transaction);\n        return transaction.getModifiedMessageIds();\n    }\n    @Override\n    public List<Long> deleteMessages(final List<Long> messageIds, final String selector, int limit)\n    {\n        DeleteMessagesTransaction transaction = new DeleteMessagesTransaction(this,\n                                                                              messageIds,\n                                                                              parseSelector(selector),\n                                                                              limit);\n        _virtualHost.executeTransaction(transaction);\n        return transaction.getModifiedMessageIds();\n    }\n    private JMSSelectorFilter parseSelector(final String selector)\n    {\n        try\n        {\n            return selector == null ? null : new JMSSelectorFilter(selector);\n        }\n        catch (ParseException | SelectorParsingException | TokenMgrError e)\n        {\n            throw new IllegalArgumentException(\"Cannot parse JMS selector \\\"\" + selector + \"\\\"\", e);\n        }\n    }\n<fim_suffix>    @Override\n    public Content getMessageContent(final long messageId, final long limit, boolean returnJson, boolean decompressBeforeLimiting)\n    {\n        final MessageContentFinder messageFinder = new MessageContentFinder(messageId);\n        visit(messageFinder);\n        if (messageFinder.isFound())\n        {\n            return createMessageContent(messageFinder.getMessageReference(), returnJson, limit, decompressBeforeLimiting);\n        }\n        else\n        {\n            return null;\n        }\n    }<fim_middle>// function below has no smell\n"}