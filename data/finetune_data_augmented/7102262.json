{"text": "<fim_prefix>        map.put(VERSION, Integer.valueOf(ATTR_VERSION));\n        map.put(SERIAL_NUMBER, Integer.valueOf(ATTR_SERIAL));\n        map.put(ALGORITHM_ID, Integer.valueOf(ATTR_ALGORITHM));\n        map.put(ISSUER, Integer.valueOf(ATTR_ISSUER));\n        map.put(VALIDITY, Integer.valueOf(ATTR_VALIDITY));\n        map.put(SUBJECT, Integer.valueOf(ATTR_SUBJECT));\n        map.put(KEY, Integer.valueOf(ATTR_KEY));\n        map.put(ISSUER_ID, Integer.valueOf(ATTR_ISSUER_ID));\n        map.put(SUBJECT_ID, Integer.valueOf(ATTR_SUBJECT_ID));\n        map.put(EXTENSIONS, Integer.valueOf(ATTR_EXTENSIONS));\n    }\n    /**\n     * Construct an uninitialized X509CertInfo on which <a href=\"#decode\">\n     * decode</a> must later be called (or which may be deserialized).\n     */\n    public X509CertInfo() { }\n    /**\n     * Unmarshals a certificate from its encoded form, parsing the\n     * encoded bytes.  This form of constructor is used by agents which\n     * need to examine and use certificate contents.  That is, this is\n     * one of the more commonly used constructors.  Note that the buffer\n     * must include only a certificate, and no \"garbage\" may be left at\n     * the end.  If you need to ignore data at the end of a certificate,\n     * use another constructor.\n     *\n     * @param cert the encoded bytes, with no trailing data.\n     * @exception CertificateParsingException on parsing errors.\n     */\n    public X509CertInfo(byte[] cert) throws CertificateParsingException {\n        try {\n            DerValue    in = new DerValue(cert);\n            parse(in);\n        } catch (IOException e) {\n            throw new CertificateParsingException(e);\n        }\n    }\n    /**\n     * Unmarshal a certificate from its encoded form, parsing a DER value.\n     * This form of constructor is used by agents which need to examine\n     * and use certificate contents.\n     *\n     * @param derVal the der value containing the encoded cert.\n     * @exception CertificateParsingException on parsing errors.\n     */\n    public X509CertInfo(DerValue derVal) throws CertificateParsingException {\n        try {\n            parse(derVal);\n        } catch (IOException e) {\n            throw new CertificateParsingException(e);\n        }\n    }\n    /**\n     * Appends the certificate to an output stream.\n     *\n     * @param out an output stream to which the certificate is appended.\n     * @exception CertificateException on encoding errors.\n     * @exception IOException on other errors.\n     */\n    public void encode(OutputStream out)\n    throws CertificateException, IOException {\n        if (rawCertInfo == null) {\n            DerOutputStream tmp = new DerOutputStream();\n            emit(tmp);\n            rawCertInfo = tmp.toByteArray();\n        }\n        out.write(rawCertInfo.clone());\n    }\n    /**\n     * Return an enumeration of names of attributes existing within this\n     * attribute.\n     */\n    public Enumeration<String> getElements() {\n        AttributeNameEnumeration elements = new AttributeNameEnumeration();\n        elements.addElement(VERSION);\n        elements.addElement(SERIAL_NUMBER);\n        elements.addElement(ALGORITHM_ID);\n        elements.addElement(ISSUER);\n        elements.addElement(VALIDITY);\n        elements.addElement(SUBJECT);\n        elements.addElement(KEY);\n        elements.addElement(ISSUER_ID);\n        elements.addElement(SUBJECT_ID);\n        elements.addElement(EXTENSIONS);\n        return elements.elements();\n    }\n    /**\n     * Return the name of this attribute.\n     */\n    public String getName() {\n        return(NAME);\n    }\n    /**\n     * Returns the encoded certificate info.\n     *\n     * @exception CertificateEncodingException on encoding information errors.\n     */\n    public byte[] getEncodedInfo() throws CertificateEncodingException {\n        try {\n            if (rawCertInfo == null) {\n                DerOutputStream tmp = new DerOutputStream();\n                emit(tmp);\n                rawCertInfo = tmp.toByteArray();\n            }\n            return rawCertInfo.clone();\n        } catch (IOException e) {\n            throw new CertificateEncodingException(e.toString());\n        } catch (CertificateException e) {\n            throw new CertificateEncodingException(e.toString());\n        }\n    }\n    /**\n     * Compares two X509CertInfo objects.  This is false if the\n     * certificates are not both X.509 certs, otherwise it\n     * compares them as binary data.\n     *\n     * @param other the object being compared with this one\n     * @return true iff the certificates are equivalent\n     */\n    public boolean equals(Object other) {\n        if (other instanceof X509CertInfo) {\n            return equals((X509CertInfo) other);\n        } else {\n            return false;\n        }\n    }\n    /**\n     * Compares two certificates, returning false if any data\n     * differs between the two.\n     *\n     * @param other the object being compared with this one\n     * @return true iff the certificates are equivalent\n     */\n    public boolean equals(X509CertInfo other) {\n        if (this == other) {\n            return(true);\n        } else if (rawCertInfo == null || other.rawCertInfo == null) {\n            return(false);\n        } else if (rawCertInfo.length != other.rawCertInfo.length) {\n            return(false);\n        }\n        for (int i = 0; i < rawCertInfo.length; i++) {\n            if (rawCertInfo[i] != other.rawCertInfo[i]) {\n                return(false);\n            }\n        }\n        return(true);\n    }\n    /**\n     * Calculates a hash code value for the object.  Objects\n     * which are equal will also have the same hashcode.\n     */\n    public int hashCode() {\n        int     retval = 0;\n        for (int i = 1; i < rawCertInfo.length; i++) {\n            retval += rawCertInfo[i] * i;\n        }\n        return(retval);\n    }\n    /**\n     * Returns a printable representation of the certificate.\n     */\n<fim_suffix>    public String toString() {\n        if (subject == null || pubKey == null || interval == null\n            || issuer == null || algId == null || serialNum == null) {\n                throw new NullPointerException(\"X.509 cert is incomplete\");\n        }\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[\\n\");\n        sb.append(\"  \" + version.toString() + \"\\n\");\n        sb.append(\"  Subject: \" + subject.toString() + \"\\n\");\n        sb.append(\"  Signature Algorithm: \" + algId.toString() + \"\\n\");\n        sb.append(\"  Key:  \" + pubKey.toString() + \"\\n\");\n        sb.append(\"  \" + interval.toString() + \"\\n\");\n        sb.append(\"  Issuer: \" + issuer.toString() + \"\\n\");\n        sb.append(\"  \" + serialNum.toString() + \"\\n\");\n        // optional v2, v3 extras\n        if (issuerUniqueId != null) {\n            sb.append(\"  Issuer Id:\\n\" + issuerUniqueId.toString() + \"\\n\");\n        }\n        if (subjectUniqueId != null) {\n            sb.append(\"  Subject Id:\\n\" + subjectUniqueId.toString() + \"\\n\");\n        }\n        if (extensions != null) {\n            Collection<Extension> allExts = extensions.getAllExtensions();\n            Extension[] exts = allExts.toArray(new Extension[0]);\n            sb.append(\"\\nCertificate Extensions: \" + exts.length);\n            for (int i = 0; i < exts.length; i++) {\n                sb.append(\"\\n[\" + (i+1) + \"]: \");\n                Extension ext = exts[i];\n                try {\n                    if (OIDMap.getClass(ext.getExtensionId()) == null) {\n                        sb.append(ext.toString());\n                        byte[] extValue = ext.getExtensionValue();\n                        if (extValue != null) {\n                            DerOutputStream out = new DerOutputStream();\n                            out.putOctetString(extValue);\n                            extValue = out.toByteArray();\n                            HexDumpEncoder enc = new HexDumpEncoder();\n                            sb.append(\"Extension unknown: \"\n                                      + \"DER encoded OCTET string =\\n\"\n                                      + enc.encodeBuffer(extValue) + \"\\n\");\n                        }\n                    } else\n                        sb.append(ext.toString()); //sub-class exists\n                } catch (Exception e) {\n                    sb.append(\", Error parsing this extension\");\n                }\n            }\n            Map<String,Extension> invalid = extensions.getUnparseableExtensions();\n            if (invalid.isEmpty() == false) {\n                sb.append(\"\\nUnparseable certificate extensions: \" + invalid.size());\n                int i = 1;\n                for (Extension ext : invalid.values()) {\n                    sb.append(\"\\n[\" + (i++) + \"]: \");\n                    sb.append(ext);\n                }\n            }\n        }\n        sb.append(\"\\n]\");\n        return sb.toString();\n    }<fim_middle>// function below is long method\n"}