{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\nimport org.apache.hadoop.hive.ql.exec.vector.expressions.VectorExpression;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\n/**\n * Compute IF(expr1, expr2, expr3) for 3 input column expressions.\n * The first is always a boolean (LongColumnVector).\n * The second and third are string columns or string expression results.\n */\npublic class IfExprStringGroupColumnStringGroupColumn extends VectorExpression {\n  private static final long serialVersionUID = 1L;\n  private final int arg1Column;\n  private final int arg2Column;\n  private final int arg3Column;\n  public IfExprStringGroupColumnStringGroupColumn(int arg1Column, int arg2Column, int arg3Column,\n      int outputColumnNum) {\n    super(outputColumnNum);\n    this.arg1Column = arg1Column;\n    this.arg2Column = arg2Column;\n    this.arg3Column = arg3Column;\n  }\n<fim_suffix>  public IfExprStringGroupColumnStringGroupColumn() {\n    super();\n    // Dummy final assignments.\n    arg1Column = -1;\n    arg2Column = -1;\n    arg3Column = -1;\n  }\n  @Override\n  public void evaluate(VectorizedRowBatch batch) throws HiveException {\n    if (childExpressions != null) {\n      super.evaluateChildren(batch);\n    }\n    LongColumnVector arg1ColVector = (LongColumnVector) batch.cols[arg1Column];\n    BytesColumnVector arg2ColVector = (BytesColumnVector) batch.cols[arg2Column];\n    BytesColumnVector arg3ColVector = (BytesColumnVector) batch.cols[arg3Column];\n    BytesColumnVector outputColVector = (BytesColumnVector) batch.cols[outputColumnNum];\n    int[] sel = batch.selected;\n    boolean[] outputIsNull = outputColVector.isNull;\n    // We do not need to do a column reset since we are carefully changing the output.\n    outputColVector.isRepeating = false;\n    int n = batch.size;\n    long[] vector1 = arg1ColVector.vector;\n    // return immediately if batch is empty\n    if (n == 0) {\n      return;\n    }\n    outputColVector.initBuffer();\n    /* All the code paths below propagate nulls even if neither arg2 nor arg3\n     * have nulls. This is to reduce the number of code paths and shorten the\n     * code, at the expense of maybe doing unnecessary work if neither input\n     * has nulls. This could be improved in the future by expanding the number\n     * of code paths.\n     */\n    if (arg1ColVector.isRepeating) {\n      if ((arg1ColVector.noNulls || !arg1ColVector.isNull[0]) && vector1[0] == 1) {\n        arg2ColVector.copySelected(batch.selectedInUse, sel, n, outputColVector);\n      } else {\n        arg3ColVector.copySelected(batch.selectedInUse, sel, n, outputColVector);\n      }\n      return;\n    }\n    // extend any repeating values and noNulls indicator in the inputs\n    arg2ColVector.flatten(batch.selectedInUse, sel, n);\n    arg3ColVector.flatten(batch.selectedInUse, sel, n);\n    /*\n     * Do careful maintenance of NULLs.\n     */\n    outputColVector.noNulls = false;\n    if (arg1ColVector.noNulls) {\n      if (batch.selectedInUse) {\n        for(int j = 0; j != n; j++) {\n          int i = sel[j];\n          if (vector1[i] == 1) {\n            if (!arg2ColVector.isNull[i]) {\n              outputColVector.setVal(\n                i, arg2ColVector.vector[i], arg2ColVector.start[i], arg2ColVector.length[i]);\n            }\n          } else {\n            if (!arg3ColVector.isNull[i]) {\n              outputColVector.setVal(\n                i, arg3ColVector.vector[i], arg3ColVector.start[i], arg3ColVector.length[i]);\n            }\n          }\n          outputIsNull[i] = (vector1[i] == 1 ?\n              arg2ColVector.isNull[i] : arg3ColVector.isNull[i]);\n        }\n      } else {\n        for(int i = 0; i != n; i++) {\n          if (vector1[i] == 1) {\n            if (!arg2ColVector.isNull[i]) {\n              outputColVector.setVal(\n                  i, arg2ColVector.vector[i], arg2ColVector.start[i], arg2ColVector.length[i]);\n            }\n          } else {\n            if (!arg3ColVector.isNull[i]) {\n              outputColVector.setVal(\n                  i, arg3ColVector.vector[i], arg3ColVector.start[i], arg3ColVector.length[i]);\n            }\n          }\n          outputIsNull[i] = (vector1[i] == 1 ?\n              arg2ColVector.isNull[i] : arg3ColVector.isNull[i]);\n        }\n      }\n    } else /* there are nulls */ {\n      if (batch.selectedInUse) {\n        for(int j = 0; j != n; j++) {\n          int i = sel[j];\n          if (!arg1ColVector.isNull[i] && vector1[i] == 1) {\n            if (!arg2ColVector.isNull[i]) {\n              outputColVector.setVal(\n                  i, arg2ColVector.vector[i], arg2ColVector.start[i], arg2ColVector.length[i]);\n            }\n          } else {\n            if (!arg3ColVector.isNull[i]) {\n              outputColVector.setVal(\n                  i, arg3ColVector.vector[i], arg3ColVector.start[i], arg3ColVector.length[i]);\n            }\n          }\n          outputIsNull[i] = (!arg1ColVector.isNull[i] && vector1[i] == 1 ?\n              arg2ColVector.isNull[i] : arg3ColVector.isNull[i]);\n        }\n      } else {\n        for(int i = 0; i != n; i++) {\n          if (!arg1ColVector.isNull[i] && vector1[i] == 1) {\n            if (!arg2ColVector.isNull[i]) {\n              outputColVector.setVal(\n                  i, arg2ColVector.vector[i], arg2ColVector.start[i], arg2ColVector.length[i]);\n            }\n          } else {\n            if (!arg3ColVector.isNull[i]) {\n              outputColVector.setVal(\n                  i, arg3ColVector.vector[i], arg3ColVector.start[i], arg3ColVector.length[i]);\n            }\n          }\n          outputIsNull[i] = (!arg1ColVector.isNull[i] && vector1[i] == 1 ?\n              arg2ColVector.isNull[i] : arg3ColVector.isNull[i]);\n        }\n      }\n    }\n    arg2ColVector.unFlatten();\n    arg3ColVector.unFlatten();\n  }\n  @Override\n  public String vectorExpressionParameters() {\n    return getColumnParamString(0, arg1Column) + \", \" + getColumnParamString(1, arg2Column) +\n         \", \" + getColumnParamString(2, arg2Column);\n  }\n  @Override\n  public VectorExpressionDescriptor.Descriptor getDescriptor() {\n    return (new VectorExpressionDescriptor.Builder())\n        .setMode(\n            VectorExpressionDescriptor.Mode.PROJECTION)\n        .setNumArguments(3)\n        .setArgumentTypes(\n            VectorExpressionDescriptor.ArgumentType.INT_FAMILY,\n            VectorExpressionDescriptor.ArgumentType.STRING_FAMILY_BINARY,\n            VectorExpressionDescriptor.ArgumentType.STRING_FAMILY_BINARY)\n        .setInputExpressionTypes(<fim_middle>// function below has no smell\n"}