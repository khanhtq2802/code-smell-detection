{"text": "<fim_prefix>    AvroSerdeUtils.SCHEMA_NAMESPACE, AvroSerdeUtils.SCHEMA_NAME, AvroSerdeUtils.SCHEMA_DOC})\npublic class AvroSerDe extends AbstractSerDe {\n  private static final Logger LOG = LoggerFactory.getLogger(AvroSerDe.class);\n  public static final String TABLE_NAME = \"name\";\n  public static final String TABLE_COMMENT = \"comment\";\n  public static final String LIST_COLUMN_COMMENTS = \"columns.comments\";\n  public static final String DECIMAL_TYPE_NAME = \"decimal\";\n  public static final String CHAR_TYPE_NAME = \"char\";\n  public static final String VARCHAR_TYPE_NAME = \"varchar\";\n  public static final String DATE_TYPE_NAME = \"date\";\n  public static final String TIMESTAMP_TYPE_NAME = \"timestamp-millis\";\n  public static final String AVRO_PROP_LOGICAL_TYPE = \"logicalType\";\n  public static final String AVRO_PROP_PRECISION = \"precision\";\n  public static final String AVRO_PROP_SCALE = \"scale\";\n  public static final String AVRO_PROP_MAX_LENGTH = \"maxLength\";\n  public static final String AVRO_STRING_TYPE_NAME = \"string\";\n  public static final String AVRO_INT_TYPE_NAME = \"int\";\n  public static final String AVRO_LONG_TYPE_NAME = \"long\";\n  private ObjectInspector oi;\n  private List<String> columnNames;\n  private List<TypeInfo> columnTypes;\n  private Schema schema;\n  private AvroDeserializer avroDeserializer = null;\n  private AvroSerializer avroSerializer = null;\n  private boolean badSchema = false;\n  @Override\n  public void initialize(Configuration configuration, Properties tableProperties,\n                         Properties partitionProperties) throws SerDeException {\n    // Avro should always use the table properties for initialization (see HIVE-6835).\n    initialize(configuration, tableProperties);\n  }\n  @Override\n  public void initialize(Configuration configuration, Properties properties) throws SerDeException {\n    // Reset member variables so we don't get in a half-constructed state\n    if (schema != null) {\n      LOG.debug(\"Resetting already initialized AvroSerDe\");\n    }\n    LOG.info(\"AvroSerde::initialize(): Preset value of avro.schema.literal == \"\n        + properties.get(AvroSerdeUtils.AvroTableProperties.SCHEMA_LITERAL.getPropName()));\n    schema = null;\n    oi = null;\n    columnNames = null;\n    columnTypes = null;\n    final String columnNameProperty = properties.getProperty(serdeConstants.LIST_COLUMNS);\n    final String columnTypeProperty = properties.getProperty(serdeConstants.LIST_COLUMN_TYPES);\n    final String columnCommentProperty = properties.getProperty(LIST_COLUMN_COMMENTS,\"\");\n    final String columnNameDelimiter = properties.containsKey(serdeConstants.COLUMN_NAME_DELIMITER) ? properties\n        .getProperty(serdeConstants.COLUMN_NAME_DELIMITER) : String.valueOf(SerDeUtils.COMMA);\n    if (hasExternalSchema(properties)\n        || columnNameProperty == null || columnNameProperty.isEmpty()\n        || columnTypeProperty == null || columnTypeProperty.isEmpty()) {\n      schema = determineSchemaOrReturnErrorSchema(configuration, properties);\n    } else {\n      // Get column names and sort order\n      columnNames = StringInternUtils.internStringsInList(\n          Arrays.asList(columnNameProperty.split(columnNameDelimiter)));\n      columnTypes = TypeInfoUtils.getTypeInfosFromTypeString(columnTypeProperty);\n      schema = getSchemaFromCols(properties, columnNames, columnTypes, columnCommentProperty);\n    }\n    properties.setProperty(AvroSerdeUtils.AvroTableProperties.SCHEMA_LITERAL.getPropName(), schema.toString());\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Avro schema is \" + schema);\n    }\n    if (configuration == null) {\n      LOG.debug(\"Configuration null, not inserting schema\");\n    } else {\n      configuration.set(\n          AvroSerdeUtils.AvroTableProperties.AVRO_SERDE_SCHEMA.getPropName(), schema.toString(false));\n    }\n    badSchema = schema.equals(SchemaResolutionProblem.SIGNAL_BAD_SCHEMA);\n    AvroObjectInspectorGenerator aoig = new AvroObjectInspectorGenerator(schema);\n    this.columnNames = StringInternUtils.internStringsInList(aoig.getColumnNames());\n    this.columnTypes = aoig.getColumnTypes();\n    this.oi = aoig.getObjectInspector();\n    if(!badSchema) {\n      this.avroSerializer = new AvroSerializer();\n      this.avroDeserializer = new AvroDeserializer();\n    }\n  }\n  private boolean hasExternalSchema(Properties properties) {\n    return properties.getProperty(AvroSerdeUtils.AvroTableProperties.SCHEMA_LITERAL.getPropName()) != null\n        || properties.getProperty(AvroSerdeUtils.AvroTableProperties.SCHEMA_URL.getPropName()) != null;\n  }\n  private boolean hasExternalSchema(Map<String, String> tableParams) {\n    return tableParams.containsKey(AvroSerdeUtils.AvroTableProperties.SCHEMA_LITERAL.getPropName())\n        || tableParams.containsKey(AvroSerdeUtils.AvroTableProperties.SCHEMA_URL.getPropName());\n  }\n  public static Schema getSchemaFromCols(Properties properties,\n          List<String> columnNames, List<TypeInfo> columnTypes, String columnCommentProperty) {\n    List<String> columnComments;\n    if (columnCommentProperty == null || columnCommentProperty.isEmpty()) {\n      columnComments = new ArrayList<String>();\n    } else {\n      //Comments are separated by \"\\0\" in columnCommentProperty, see method getSchema\n      //in MetaStoreUtils where this string columns.comments is generated\n      columnComments = Arrays.asList(columnCommentProperty.split(\"\\0\"));\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"columnComments is \" + columnCommentProperty);\n      }\n    }\n    if (columnNames.size() != columnTypes.size()) {\n      throw new IllegalArgumentException(\"AvroSerde initialization failed. Number of column \" +\n          \"name and column type differs. columnNames = \" + columnNames + \", columnTypes = \" +\n          columnTypes);\n    }\n    final String tableName = properties.getProperty(TABLE_NAME);\n    final String tableComment = properties.getProperty(TABLE_COMMENT);\n    TypeInfoToSchema typeInfoToSchema = new TypeInfoToSchema();\n    return typeInfoToSchema.convert(columnNames, columnTypes, columnComments,\n        properties.getProperty(AvroSerdeUtils.AvroTableProperties.SCHEMA_NAMESPACE.getPropName()),\n        properties.getProperty(AvroSerdeUtils.AvroTableProperties.SCHEMA_NAME.getPropName(), tableName),\n        properties.getProperty(AvroSerdeUtils.AvroTableProperties.SCHEMA_DOC.getPropName(), tableComment));\n  }\n  /**\n   * Attempt to determine the schema via the usual means, but do not throw\n   * an exception if we fail.  Instead, signal failure via a special\n   * schema.  This is used because Hive calls init on the serde during\n   * any call, including calls to update the serde properties, meaning\n   * if the serde is in a bad state, there is no way to update that state.\n   */\n  public Schema determineSchemaOrReturnErrorSchema(Configuration conf, Properties props) {\n    try {\n      configErrors = \"\";\n      return AvroSerdeUtils.determineSchemaOrThrowException(conf, props);\n    } catch(AvroSerdeException he) {\n      LOG.warn(\"Encountered AvroSerdeException determining schema. Returning \" +\n              \"signal schema to indicate problem\", he);\n      configErrors = new String(\"Encountered AvroSerdeException determining schema. Returning \" +\n              \"signal schema to indicate problem: \" + he.getMessage());\n      return schema = SchemaResolutionProblem.SIGNAL_BAD_SCHEMA;\n    } catch (Exception e) {\n      LOG.warn(\"Encountered exception determining schema. Returning signal \" +\n              \"schema to indicate problem\", e);\n      configErrors = new String(\"Encountered exception determining schema. Returning signal \" +\n              \"schema to indicate problem: \" + e.getMessage());\n      return SchemaResolutionProblem.SIGNAL_BAD_SCHEMA;\n    }\n  }\n  @Override\n  public Class<? extends Writable> getSerializedClass() {\n    return AvroGenericRecordWritable.class;\n  }\n  @Override\n  public Writable serialize(Object o, ObjectInspector objectInspector) throws SerDeException {\n    if(badSchema) {\n      throw new BadSchemaException();\n    }\n    return avroSerializer.serialize(o, objectInspector, columnNames, columnTypes, schema);\n  }\n  @Override\n  public Object deserialize(Writable writable) throws SerDeException {\n    if(badSchema) {\n      throw new BadSchemaException();\n    }\n    return avroDeserializer.deserialize(columnNames, columnTypes, writable, schema);\n  }\n  @Override\n  public ObjectInspector getObjectInspector() throws SerDeException {\n    return oi;\n  }\n<fim_suffix>  @Override\n  public SerDeStats getSerDeStats() {\n    // No support for statistics. That seems to be a popular answer.\n    return null;\n  }<fim_middle>// function below has no smell\n"}