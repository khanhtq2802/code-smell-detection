{"text": "<fim_prefix>/*\n * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 3 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 3 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 3 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage com.oracle.truffle.r.runtime.ffi;\n\nimport com.oracle.truffle.r.runtime.FastRConfig;\nimport com.oracle.truffle.r.runtime.RSuicide;\nimport com.oracle.truffle.r.runtime.context.RContext;\nimport com.oracle.truffle.r.runtime.context.RContext.ContextState;\n\n/**\n * Factory class for the different possible implementations of the {@link RFFI} interface.\n *\n * Initialization of factory state that is dependent on the system being properly initialized\n * <b>must</b> be done in the {@link ContextState#initialize} method and not in the constructor or\n * {@link #createRFFIContext()} method as they are invoked in the static block and the system is not\n * typically initialized at that point.\n */\npublic abstract class RFFIFactory {\n    public enum Type {\n        LLVM(\"com.oracle.truffle.r.ffi.impl.mixed.TruffleMixed_RFFIFactory\"),\n        MANAGED(\"com.oracle.truffle.r.ffi.impl.managed.Managed_RFFIFactory\"),\n        NFI(\"com.oracle.truffle.r.ffi.impl.nfi.TruffleNFI_RFFIFactory\"),\n        // used internally in installation scripts only (\"nfi-only\")\n        NFI_ONLY(\"com.oracle.truffle.r.ffi.impl.nfi.TruffleNFI_RFFIFactory\");\n\n        private final String klassName;\n\n        Type(String klassName) {\n            this.klassName = klassName;\n        }\n    }\n\n    private static final String FACTORY_TYPE_PROPERTY = \"fastr.rffi.factory.type\";\n    private static final String FACTORY_CLASS_ENV = \"FASTR_RFFI\";\n    private static final Type DEFAULT_FACTORY = Type.NFI;\n\n    private static Type type;\n    private static RFFIFactory rffiFactory;\n\n    static {\n        String property = System.getProperty(FACTORY_TYPE_PROPERTY);\n        String env = System.getenv(FACTORY_CLASS_ENV);\n        if (property != null) {\n            type = checkFactoryName(property);\n        } else if (env != null) {\n            type = checkFactoryName(env);\n        } else if (FastRConfig.ManagedMode) {\n            type = Type.MANAGED;\n        } else {\n            type = DEFAULT_FACTORY;\n        }\n        String klassName = getFactoryType().klassName;\n        try {\n            rffiFactory = (RFFIFactory) Class.forName(klassName).newInstance();\n        } catch (Exception ex) {\n            throw RSuicide.rSuicide(\"Failed to instantiate class: \" + klassName + \": \" + ex);\n        }\n    }\n\n    public static Type getFactoryType() {\n        return type;\n    }\n\n    private static Type checkFactoryName(String prop) {\n        try {\n            return Type.valueOf(prop.toUpperCase().replace('-', '_'));\n        } catch (IllegalArgumentException ex) {\n            throw RSuicide.rSuicide(\"No RFFI factory: \" + prop);\n        }\n    }\n\n    private static RFFI getRFFI() {\n        return RContext.getInstance().getStateRFFI();\n    }\n\n    /*\n     * Some shortcuts to the specific RFFI interfaces:\n     */\n\n    public static BaseRFFI getBaseRFFI() {\n        return getRFFI().baseRFFI;\n    }\n\n    public static LapackRFFI getLapackRFFI() {\n        return getRFFI().lapackRFFI;\n    }\n\n    public static StatsRFFI getStatsRFFI() {\n        return getRFFI().statsRFFI;\n    }\n\n<fim_suffix>    public static ToolsRFFI getToolsRFFI() {\n        return getRFFI().toolsRFFI;\n    }\n\n    public static CRFFI getCRFFI() {\n        return getRFFI().cRFFI;\n    }\n\n    public static CallRFFI getCallRFFI() {\n        return getRFFI().callRFFI;\n    }\n\n    public static UserRngRFFI getUserRngRFFI() {\n        return getRFFI().userRngRFFI;\n    }\n\n    public static PCRERFFI getPCRERFFI() {\n        return getRFFI().pcreRFFI;\n    }\n\n    public static ZipRFFI getZipRFFI() {\n        return getRFFI().zipRFFI;\n    }\n\n    public static DLLRFFI getDLLRFFI() {\n        return getRFFI().dllRFFI;\n    }\n\n    public static REmbedRFFI getREmbedRFFI() {\n        return getRFFI().embedRFFI;\n    }\n\n    public static MiscRFFI getMiscRFFI() {\n        return getRFFI().miscRFFI;\n    }\n\n    /**\n     * Subclass implements this method to actually create the concrete {@link RFFIContext} instance.\n     */\n    protected abstract RFFIContext createRFFIContext();\n\n    public static RFFIContext create() {\n        return rffiFactory.createRFFIContext();\n    }\n}<fim_middle>// function below has no smell\n"}