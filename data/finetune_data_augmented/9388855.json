{"text": "<fim_prefix> * questions.\n */\npackage sun.security.ssl;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.security.PrivateKey;\nimport java.security.cert.X509Certificate;\nimport java.text.MessageFormat;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Locale;\nimport javax.net.ssl.SSLEngine;\nimport javax.net.ssl.SSLSocket;\nimport javax.net.ssl.X509ExtendedKeyManager;\nimport javax.security.auth.x500.X500Principal;\nimport sun.security.ssl.CipherSuite.KeyExchange;\nimport sun.security.ssl.SSLHandshake.HandshakeMessage;\nimport sun.security.ssl.X509Authentication.X509Possession;\n/**\n * Pack of the CertificateRequest handshake message.\n */\nfinal class CertificateRequest {\n    static final SSLConsumer t10HandshakeConsumer =\n        new T10CertificateRequestConsumer();\n    static final HandshakeProducer t10HandshakeProducer =\n        new T10CertificateRequestProducer();\n    static final SSLConsumer t12HandshakeConsumer =\n        new T12CertificateRequestConsumer();\n    static final HandshakeProducer t12HandshakeProducer =\n        new T12CertificateRequestProducer();\n    static final SSLConsumer t13HandshakeConsumer =\n        new T13CertificateRequestConsumer();\n    static final HandshakeProducer t13HandshakeProducer =\n        new T13CertificateRequestProducer();\n    // TLS 1.2 and prior versions\n    private static enum ClientCertificateType {\n        // RFC 2246\n        RSA_SIGN            ((byte)0x01, \"rsa_sign\", \"RSA\", true),\n        DSS_SIGN            ((byte)0x02, \"dss_sign\", \"DSA\", true),\n        RSA_FIXED_DH        ((byte)0x03, \"rsa_fixed_dh\"),\n        DSS_FIXED_DH        ((byte)0x04, \"dss_fixed_dh\"),\n        // RFC 4346\n        RSA_EPHEMERAL_DH    ((byte)0x05, \"rsa_ephemeral_dh\"),\n        DSS_EPHEMERAL_DH    ((byte)0x06, \"dss_ephemeral_dh\"),\n        FORTEZZA_DMS        ((byte)0x14, \"fortezza_dms\"),\n        // RFC 4492\n        ECDSA_SIGN          ((byte)0x40, \"ecdsa_sign\",\n                                             \"EC\", JsseJce.isEcAvailable()),\n        RSA_FIXED_ECDH      ((byte)0x41, \"rsa_fixed_ecdh\"),\n        ECDSA_FIXED_ECDH    ((byte)0x42, \"ecdsa_fixed_ecdh\");\n        private static final byte[] CERT_TYPES =\n                JsseJce.isEcAvailable() ? new byte[] {\n                        ECDSA_SIGN.id,\n                        RSA_SIGN.id,\n                        DSS_SIGN.id\n                    } :  new byte[] {\n                        RSA_SIGN.id,\n                        DSS_SIGN.id\n                    };\n        final byte id;\n        final String name;\n        final String keyAlgorithm;\n        final boolean isAvailable;\n        private ClientCertificateType(byte id, String name) {\n            this(id, name, null, false);\n        }\n        private ClientCertificateType(byte id, String name,\n                String keyAlgorithm, boolean isAvailable) {\n            this.id = id;\n            this.name = name;\n            this.keyAlgorithm = keyAlgorithm;\n            this.isAvailable = isAvailable;\n        }\n        private static String nameOf(byte id) {\n            for (ClientCertificateType cct : ClientCertificateType.values()) {\n                if (cct.id == id) {\n                    return cct.name;\n                }\n            }\n            return \"UNDEFINED-CLIENT-CERTIFICATE-TYPE(\" + (int)id + \")\";\n        }\n        private static ClientCertificateType valueOf(byte id) {\n            for (ClientCertificateType cct : ClientCertificateType.values()) {\n                if (cct.id == id) {\n                    return cct;\n                }\n            }\n            return null;\n        }\n        private static String[] getKeyTypes(byte[] ids) {\n            ArrayList<String> keyTypes = new ArrayList<>(3);\n            for (byte id : ids) {\n                ClientCertificateType cct = ClientCertificateType.valueOf(id);\n                if (cct.isAvailable) {\n                    keyTypes.add(cct.keyAlgorithm);\n                }\n            }\n            return keyTypes.toArray(new String[0]);\n        }\n    }\n    /**\n     * The \"CertificateRequest\" handshake message for SSL 3.0 and TLS 1.0/1.1.\n     */\n<fim_suffix>    static final class T10CertificateRequestMessage extends HandshakeMessage {\n        final byte[] types;                 // certificate types\n        final List<byte[]> authorities;     // certificate authorities\n        T10CertificateRequestMessage(HandshakeContext handshakeContext,\n                X509Certificate[] trustedCerts, KeyExchange keyExchange) {\n            super(handshakeContext);\n            this.authorities = new ArrayList<>(trustedCerts.length);\n            for (X509Certificate cert : trustedCerts) {\n                X500Principal x500Principal = cert.getSubjectX500Principal();\n                authorities.add(x500Principal.getEncoded());\n            }\n            this.types = ClientCertificateType.CERT_TYPES;\n        }\n        T10CertificateRequestMessage(HandshakeContext handshakeContext,\n                ByteBuffer m) throws IOException {\n            super(handshakeContext);\n            // struct {\n            //     ClientCertificateType certificate_types<1..2^8-1>;\n            //     DistinguishedName certificate_authorities<0..2^16-1>;\n            // } CertificateRequest;\n            if (m.remaining() < 4) {\n                throw handshakeContext.conContext.fatal(Alert.ILLEGAL_PARAMETER,\n                    \"Incorrect CertificateRequest message: no sufficient data\");\n            }\n            this.types = Record.getBytes8(m);\n            int listLen = Record.getInt16(m);\n            if (listLen > m.remaining()) {\n                throw handshakeContext.conContext.fatal(Alert.ILLEGAL_PARAMETER,\n                    \"Incorrect CertificateRequest message:no sufficient data\");\n            }\n            if (listLen > 0) {\n                this.authorities = new LinkedList<>();\n                while (listLen > 0) {\n                    // opaque DistinguishedName<1..2^16-1>;\n                    byte[] encoded = Record.getBytes16(m);\n                    listLen -= (2 + encoded.length);\n                    authorities.add(encoded);\n                }\n            } else {\n                this.authorities = Collections.emptyList();\n            }\n        }\n        String[] getKeyTypes() {\n            return  ClientCertificateType.getKeyTypes(types);\n        }\n        X500Principal[] getAuthorities() {\n            List<X500Principal> principals =\n                    new ArrayList<>(authorities.size());\n            for (byte[] encoded : authorities) {\n                X500Principal principal = new X500Principal(encoded);\n                principals.add(principal);\n            }\n            return principals.toArray(new X500Principal[0]);\n        }\n        @Override\n        public SSLHandshake handshakeType() {\n            return SSLHandshake.CERTIFICATE_REQUEST;\n        }\n        @Override\n        public int messageLength() {\n            int len = 1 + types.length + 2;\n            for (byte[] encoded : authorities) {\n                len += encoded.length + 2;\n            }\n            return len;\n        }\n        @Override\n        public void send(HandshakeOutStream hos) throws IOException {\n            hos.putBytes8(types);\n            int listLen = 0;\n            for (byte[] encoded : authorities) {\n                listLen += encoded.length + 2;\n            }\n            hos.putInt16(listLen);\n            for (byte[] encoded : authorities) {\n                hos.putBytes16(encoded);\n            }\n        }\n        @Override\n        public String toString() {\n            MessageFormat messageFormat = new MessageFormat(\n                    \"\\\"CertificateRequest\\\": '{'\\n\" +\n                    \"  \\\"certificate types\\\": {0}\\n\" +\n                    \"  \\\"certificate authorities\\\": {1}\\n\" +\n                    \"'}'\",\n                    Locale.ENGLISH);\n            List<String> typeNames = new ArrayList<>(types.length);\n            for (byte type : types) {\n                typeNames.add(ClientCertificateType.nameOf(type));\n            }\n            List<String> authorityNames = new ArrayList<>(authorities.size());\n            for (byte[] encoded : authorities) {\n                X500Principal principal = new X500Principal(encoded);\n                authorityNames.add(principal.toString());\n            }\n            Object[] messageFields = {\n                typeNames,\n                authorityNames\n            };\n            return messageFormat.format(messageFields);\n        }\n    }<fim_middle>// class below has no smell\n"}