{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage datafu.hourglass.schemas;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\n\nimport org.apache.avro.Schema;\nimport org.apache.avro.Schema.Field;\nimport org.apache.avro.Schema.Type;\nimport org.apache.avro.mapred.Pair;\nimport org.apache.commons.lang.NullArgumentException;\n\n/**\n * Generates the Avro schemas used by {@link datafu.hourglass.jobs.AbstractPartitionCollapsingIncrementalJob} and its derivations.\n * \n */\n<fim_suffix>public class PartitionCollapsingSchemas implements Serializable\n{  \n  private static String DATED_INTERMEDIATE_VALUE_SCHEMA_NAME = \"DatedMapValue\";\n  private static String KEY_SCHEMA = \"key.schema\";\n  private static String INTERMEDIATE_VALUE_SCHEMA = \"intermediate.value.schema\";\n  private static String OUTPUT_VALUE_SCHEMA = \"output.value.schema\";\n  \n  private final String _outputSchemaName;\n  private final String _outputSchemaNamespace;\n  private transient Schema _keySchema;\n  private transient Schema _intermediateValueSchema;\n  private transient Schema _outputValueSchema;\n  \n  // generated schemas\n  private transient Schema _mapOutputSchema;\n  private transient Schema _dateIntermediateValueSchema;\n  private transient Schema _mapOutputValueSchema;\n  private transient Schema _reduceOutputSchema;\n  private transient Map<String,Schema> _mapInputSchemas;\n  \n  //schemas are stored here so the object can be serialized\n  private Map<String,String> conf;\n\n  private Map<String,String> _inputSchemas;\n  \n  public PartitionCollapsingSchemas(TaskSchemas schemas, Map<String,Schema> inputSchemas, String outputSchemaName, String outputSchemaNamespace)\n  {\n    if (schemas == null)\n    {\n      throw new NullArgumentException(\"schemas\");\n    }\n    if (inputSchemas == null)\n    {\n      throw new NullArgumentException(\"inputSchema\");\n    }\n    if (outputSchemaName == null)\n    {\n      throw new NullArgumentException(\"outputSchemaName\");\n    }\n    if (outputSchemaName == outputSchemaNamespace)\n    {\n      throw new NullArgumentException(\"outputSchemaNamespace\");\n    }\n    _outputSchemaName = outputSchemaName;\n    _outputSchemaNamespace = outputSchemaNamespace;\n    \n    conf = new HashMap<String,String>();\n    conf.put(KEY_SCHEMA, schemas.getKeySchema().toString());\n    conf.put(INTERMEDIATE_VALUE_SCHEMA, schemas.getIntermediateValueSchema().toString());\n    conf.put(OUTPUT_VALUE_SCHEMA, schemas.getOutputValueSchema().toString());\n    \n    _inputSchemas = new HashMap<String,String>();\n    for (Entry<String,Schema> schema : inputSchemas.entrySet())\n    {\n      _inputSchemas.put(schema.getKey(), schema.getValue().toString());\n    }\n  }\n    \n  public Map<String,Schema> getMapInputSchemas()\n  {    \n    if (_mapInputSchemas == null)\n    {\n      _mapInputSchemas = new HashMap<String,Schema>();\n      \n      for (Entry<String,String> schemaPair : _inputSchemas.entrySet())\n      {\n        Schema schema = new Schema.Parser().parse(schemaPair.getValue());\n        \n        List<Schema> mapInputSchemas = new ArrayList<Schema>();\n        \n        if (schema.getType() == Type.UNION)\n        {\n          mapInputSchemas.addAll(schema.getTypes());\n        }\n        else\n        {\n          mapInputSchemas.add(schema);\n        }\n        \n        // feedback from output (optional)\n        mapInputSchemas.add(getReduceOutputSchema());\n        \n        _mapInputSchemas.put(schemaPair.getKey(), Schema.createUnion(mapInputSchemas));\n      }\n      \n      \n    }\n    return Collections.unmodifiableMap(_mapInputSchemas);\n  }\n    \n  public Schema getMapOutputSchema()\n  {\n    if (_mapOutputSchema == null)\n    {\n      _mapOutputSchema = Pair.getPairSchema(getMapOutputKeySchema(), \n                                            getMapOutputValueSchema());\n    }\n    return _mapOutputSchema;\n  }\n  \n  public Schema getKeySchema()\n  {\n    if (_keySchema == null)\n    {\n      _keySchema = new Schema.Parser().parse(conf.get(KEY_SCHEMA));\n    }\n    return _keySchema;\n  }\n      \n  public Schema getMapOutputKeySchema()\n  {\n    return getKeySchema();\n  }  \n  \n  public Schema getReduceOutputSchema()\n  {\n    if (_reduceOutputSchema == null)\n    {\n      _reduceOutputSchema = Schema.createRecord(_outputSchemaName, null, _outputSchemaNamespace, false);            \n      List<Field> fields = Arrays.asList(new Field(\"key\",getKeySchema(), null, null),\n                                         new Field(\"value\", getOutputValueSchema(), null, null));    \n      _reduceOutputSchema.setFields(fields);\n    }\n    return _reduceOutputSchema;\n  }\n    \n  public Schema getDatedIntermediateValueSchema()\n  {\n    if (_dateIntermediateValueSchema == null)\n    {\n      _dateIntermediateValueSchema = Schema.createRecord(DATED_INTERMEDIATE_VALUE_SCHEMA_NAME, null, _outputSchemaNamespace, false);\n      List<Field> intermediateValueFields = Arrays.asList(new Field(\"value\", getIntermediateValueSchema(), null, null),\n                                                         new Field(\"time\", Schema.create(Type.LONG), null, null));\n      _dateIntermediateValueSchema.setFields(intermediateValueFields);\n    }\n    return _dateIntermediateValueSchema;\n  }\n  \n  public Schema getOutputValueSchema()\n  {\n    if (_outputValueSchema == null)\n    {\n      _outputValueSchema = new Schema.Parser().parse(conf.get(OUTPUT_VALUE_SCHEMA));\n    }\n    return _outputValueSchema;\n  }\n  \n  public Schema getIntermediateValueSchema()\n  {\n    if (_intermediateValueSchema == null)\n    {\n      _intermediateValueSchema = new Schema.Parser().parse(conf.get(INTERMEDIATE_VALUE_SCHEMA));\n    }\n    return _intermediateValueSchema;\n  }\n    \n  public Schema getMapOutputValueSchema()\n  {    \n    if (_mapOutputValueSchema == null)\n    {\n      List<Schema> unionSchemas = new ArrayList<Schema>();\n      \n      unionSchemas.add(getIntermediateValueSchema());\n      \n      // intermediate values tagged with the date\n      unionSchemas.add(getDatedIntermediateValueSchema());\n      \n      // feedback from output of second pass\n      if (!unionSchemas.contains(getOutputValueSchema()))\n      {\n        unionSchemas.add(getOutputValueSchema());\n      }\n      \n      _mapOutputValueSchema = Schema.createUnion(unionSchemas);\n    }\n    return _mapOutputValueSchema;\n  }\n}<fim_middle>// class below has no smell\n"}