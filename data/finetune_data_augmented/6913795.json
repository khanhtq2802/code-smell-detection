{"text": "<fim_prefix>     *     be discarded to speed up the switch. This is the minimum duration of media that must be\n     *     retained at the lower quality.\n     * @param bandwidthFraction The fraction of the available bandwidth that the selection should\n     *     consider available for use. Setting to a value less than 1 is recommended to account for\n     *     inaccuracies in the bandwidth estimator.\n     * @param bufferedFractionToLiveEdgeForQualityIncrease For live streaming, the fraction of the\n     *     duration from current playback position to the live edge that has to be buffered before\n     *     the selected track can be switched to one of higher quality. This parameter is only\n     *     applied when the playback position is closer to the live edge than {@code\n     *     minDurationForQualityIncreaseMs}, which would otherwise prevent switching to a higher\n     *     quality from happening.\n     * @param minTimeBetweenBufferReevaluationMs The track selection may periodically reevaluate its\n     *     buffer and discard some chunks of lower quality to improve the playback quality if\n     *     network conditions have changed. This is the minimum duration between 2 consecutive\n     *     buffer reevaluation calls.\n     * @param clock A {@link Clock}.\n     */\n    @SuppressWarnings(\"deprecation\")\n    public Factory(\n        int minDurationForQualityIncreaseMs,\n        int maxDurationForQualityDecreaseMs,\n        int minDurationToRetainAfterDiscardMs,\n        float bandwidthFraction,\n        float bufferedFractionToLiveEdgeForQualityIncrease,\n        long minTimeBetweenBufferReevaluationMs,\n        Clock clock) {\n      this(\n          /* bandwidthMeter= */ null,\n          minDurationForQualityIncreaseMs,\n          maxDurationForQualityDecreaseMs,\n          minDurationToRetainAfterDiscardMs,\n          bandwidthFraction,\n          bufferedFractionToLiveEdgeForQualityIncrease,\n          minTimeBetweenBufferReevaluationMs,\n          clock);\n    }\n    /**\n     * @deprecated Use {@link #Factory(int, int, int, float, float, long, Clock)} instead. Custom\n     *     bandwidth meter should be directly passed to the player in {@link ExoPlayerFactory}.\n     */\n    @Deprecated\n    public Factory(\n        @Nullable BandwidthMeter bandwidthMeter,\n        int minDurationForQualityIncreaseMs,\n        int maxDurationForQualityDecreaseMs,\n        int minDurationToRetainAfterDiscardMs,\n        float bandwidthFraction,\n        float bufferedFractionToLiveEdgeForQualityIncrease,\n        long minTimeBetweenBufferReevaluationMs,\n        Clock clock) {\n      this.bandwidthMeter = bandwidthMeter;\n      this.minDurationForQualityIncreaseMs = minDurationForQualityIncreaseMs;\n      this.maxDurationForQualityDecreaseMs = maxDurationForQualityDecreaseMs;\n      this.minDurationToRetainAfterDiscardMs = minDurationToRetainAfterDiscardMs;\n      this.bandwidthFraction = bandwidthFraction;\n      this.bufferedFractionToLiveEdgeForQualityIncrease =\n          bufferedFractionToLiveEdgeForQualityIncrease;\n      this.minTimeBetweenBufferReevaluationMs = minTimeBetweenBufferReevaluationMs;\n      this.clock = clock;\n    }\n    @Override\n    public AdaptiveTrackSelection createTrackSelection(\n        TrackGroup group, BandwidthMeter bandwidthMeter, int... tracks) {\n      if (this.bandwidthMeter != null) {\n        bandwidthMeter = this.bandwidthMeter;\n      }\n      return new AdaptiveTrackSelection(\n          group,\n          tracks,\n          bandwidthMeter,\n          minDurationForQualityIncreaseMs,\n          maxDurationForQualityDecreaseMs,\n          minDurationToRetainAfterDiscardMs,\n          bandwidthFraction,\n          bufferedFractionToLiveEdgeForQualityIncrease,\n          minTimeBetweenBufferReevaluationMs,\n          clock);\n    }\n  }\n  public static final int DEFAULT_MIN_DURATION_FOR_QUALITY_INCREASE_MS = 10000;\n  public static final int DEFAULT_MAX_DURATION_FOR_QUALITY_DECREASE_MS = 25000;\n  public static final int DEFAULT_MIN_DURATION_TO_RETAIN_AFTER_DISCARD_MS = 25000;\n  public static final float DEFAULT_BANDWIDTH_FRACTION = 0.75f;\n  public static final float DEFAULT_BUFFERED_FRACTION_TO_LIVE_EDGE_FOR_QUALITY_INCREASE = 0.75f;\n  public static final long DEFAULT_MIN_TIME_BETWEEN_BUFFER_REEVALUTATION_MS = 2000;\n  private final BandwidthMeter bandwidthMeter;\n  private final long minDurationForQualityIncreaseUs;\n  private final long maxDurationForQualityDecreaseUs;\n  private final long minDurationToRetainAfterDiscardUs;\n  private final float bandwidthFraction;\n  private final float bufferedFractionToLiveEdgeForQualityIncrease;\n  private final long minTimeBetweenBufferReevaluationMs;\n  private final Clock clock;\n  private float playbackSpeed;\n  private int selectedIndex;\n  private int reason;\n  private long lastBufferEvaluationMs;\n  /**\n   * @param group The {@link TrackGroup}.\n   * @param tracks The indices of the selected tracks within the {@link TrackGroup}. Must not be\n   *     empty. May be in any order.\n   * @param bandwidthMeter Provides an estimate of the currently available bandwidth.\n   */\n  public AdaptiveTrackSelection(TrackGroup group, int[] tracks,\n      BandwidthMeter bandwidthMeter) {\n    this(\n        group,\n        tracks,\n        bandwidthMeter,\n        DEFAULT_MIN_DURATION_FOR_QUALITY_INCREASE_MS,\n        DEFAULT_MAX_DURATION_FOR_QUALITY_DECREASE_MS,\n        DEFAULT_MIN_DURATION_TO_RETAIN_AFTER_DISCARD_MS,\n        DEFAULT_BANDWIDTH_FRACTION,\n        DEFAULT_BUFFERED_FRACTION_TO_LIVE_EDGE_FOR_QUALITY_INCREASE,\n        DEFAULT_MIN_TIME_BETWEEN_BUFFER_REEVALUTATION_MS,\n        Clock.DEFAULT);\n  }\n  /**\n   * @param group The {@link TrackGroup}.\n   * @param tracks The indices of the selected tracks within the {@link TrackGroup}. Must not be\n   *     empty. May be in any order.\n   * @param bandwidthMeter Provides an estimate of the currently available bandwidth.\n   * @param minDurationForQualityIncreaseMs The minimum duration of buffered data required for the\n   *     selected track to switch to one of higher quality.\n   * @param maxDurationForQualityDecreaseMs The maximum duration of buffered data required for the\n   *     selected track to switch to one of lower quality.\n   * @param minDurationToRetainAfterDiscardMs When switching to a track of significantly higher\n   *     quality, the selection may indicate that media already buffered at the lower quality can be\n   *     discarded to speed up the switch. This is the minimum duration of media that must be\n   *     retained at the lower quality.\n   * @param bandwidthFraction The fraction of the available bandwidth that the selection should\n   *     consider available for use. Setting to a value less than 1 is recommended to account for\n   *     inaccuracies in the bandwidth estimator.\n   * @param bufferedFractionToLiveEdgeForQualityIncrease For live streaming, the fraction of the\n   *     duration from current playback position to the live edge that has to be buffered before the\n   *     selected track can be switched to one of higher quality. This parameter is only applied\n   *     when the playback position is closer to the live edge than {@code\n   *     minDurationForQualityIncreaseMs}, which would otherwise prevent switching to a higher\n   *     quality from happening.\n   * @param minTimeBetweenBufferReevaluationMs The track selection may periodically reevaluate its\n   *     buffer and discard some chunks of lower quality to improve the playback quality if network\n   *     condition has changed. This is the minimum duration between 2 consecutive buffer\n   *     reevaluation calls.\n   */\n  public AdaptiveTrackSelection(\n      TrackGroup group,\n      int[] tracks,\n      BandwidthMeter bandwidthMeter,\n      long minDurationForQualityIncreaseMs,\n      long maxDurationForQualityDecreaseMs,\n      long minDurationToRetainAfterDiscardMs,\n      float bandwidthFraction,\n      float bufferedFractionToLiveEdgeForQualityIncrease,\n      long minTimeBetweenBufferReevaluationMs,\n      Clock clock) {\n    super(group, tracks);\n    this.bandwidthMeter = bandwidthMeter;\n    this.minDurationForQualityIncreaseUs = minDurationForQualityIncreaseMs * 1000L;\n    this.maxDurationForQualityDecreaseUs = maxDurationForQualityDecreaseMs * 1000L;\n    this.minDurationToRetainAfterDiscardUs = minDurationToRetainAfterDiscardMs * 1000L;\n    this.bandwidthFraction = bandwidthFraction;\n    this.bufferedFractionToLiveEdgeForQualityIncrease =\n        bufferedFractionToLiveEdgeForQualityIncrease;\n    this.minTimeBetweenBufferReevaluationMs = minTimeBetweenBufferReevaluationMs;\n    this.clock = clock;\n    playbackSpeed = 1f;\n    reason = C.SELECTION_REASON_INITIAL;\n    lastBufferEvaluationMs = C.TIME_UNSET;\n    @SuppressWarnings(\"nullness:method.invocation.invalid\")\n    int selectedIndex = determineIdealSelectedIndex(Long.MIN_VALUE);\n    this.selectedIndex = selectedIndex;\n  }\n<fim_suffix>  @Override\n  public void enable() {\n    lastBufferEvaluationMs = C.TIME_UNSET;\n  }<fim_middle>// function below has no smell\n"}