{"text": "<fim_prefix>/*\n * Copyright 2010-2014 Pivotal Software, Inc. and contributors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.springsource.loaded;\nimport java.lang.reflect.Method;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport org.objectweb.asm.ClassReader;\nimport org.objectweb.asm.ClassVisitor;\nimport org.objectweb.asm.ClassWriter;\nimport org.objectweb.asm.FieldVisitor;\nimport org.objectweb.asm.Label;\nimport org.objectweb.asm.MethodVisitor;\nimport org.objectweb.asm.Opcodes;\n/**\n * This is a special rewriter that should be used on system classes that are using reflection. These classes are loader\n * above the agent code and so cannot use the agent code directly (they can't see the classes). In these situations we\n * will do some rewriting that will only use other system types. How can that work? Well the affected types are modified\n * to expose a static field (per reflective API used), these static fields are set by springloaded during later startup\n * and then are available for access from the rewritten system class code.\n * <p>\n * There is a null check in the injected method for cases where everything runs even sooner than can be plugged by\n * SpringLoaded.\n * <p>\n * The following are implemented so far:\n * \n * <p>\n * Due to ReflectionNavigator:\n * <ul>\n * <li>getDeclaredFields\n * <li>getDeclaredField\n * <li>getField\n * <li>getModifiers\n * <li>getDeclaredConstructor\n * <li>getDeclaredMethods\n * <li>getDeclaredMethod</li>\n * </ul>\n * <p>\n * Due to ProxyGenerator\n * <ul>\n * <li>getMethods\n * </ul>\n * Due to ObjectStream (added in SL 1.2.0)\n * <ul>\n * <li>Class.getDeclaredConstructors\n * <li>Field.get\n * <li>Field.getLong\n * <li>Method.invoke\n * </ul>\n * The method hasStaticInitializer(Class) in ObjectStream needs special handling.\n * \n * <p>\n * This class modifies the calls to the reflective APIs, adds the fields and helper methods. The wiring of the\n * SpringLoaded reflectiveinterceptor into types affected by this rewriter is currently done in\n * SpringLoadedPreProcessor.\n * \n * @author Andy Clement\n * @since 0.7.3\n */\npublic class SystemClassReflectionRewriter {\n\tprivate static Logger log = Logger.getLogger(SystemClassReflectionRewriter.class.getName());\n\tpublic static RewriteResult rewrite(String slashedClassName, byte[] bytes) {\n\t\tif (GlobalConfiguration.isRuntimeLogging && log.isLoggable(Level.INFO)) {\n\t\t\tlog.info(\"SystemClassReflectionRewriter running for \" + slashedClassName);\n\t\t}\n\t\tClassReader fileReader = new ClassReader(bytes);\n\t\tboolean is_jlObjectStream = slashedClassName.equals(\"java/io/ObjectStreamClass\");\n\t\tRewriteClassAdaptor classAdaptor = new RewriteClassAdaptor(is_jlObjectStream);\n\t\t// TODO always skip frames? or just for javassist things?\n\t\tfileReader.accept(classAdaptor, ClassReader.SKIP_FRAMES);\n\t\treturn new RewriteResult(classAdaptor.getBytes(), classAdaptor.getBits());\n\t}\n<fim_suffix>\tpublic static class RewriteResult implements Constants {\n\t\tpublic final byte[] bytes;\n\t\t// These bits describe which kinds of reflective things were done in the \n\t\t// type - and so which fields (of the __sl variety) need filling in.  For example,\n\t\t// if the JLC_GETDECLAREDFIELDS bit is set, the field __sljlcgdfs must be set\n\t\tpublic final int bits;\n\t\tpublic RewriteResult(byte[] bytes, int bits) {\n\t\t\tthis.bytes = bytes;\n\t\t\tthis.bits = bits;\n\t\t}\n\t\tpublic String summarize() {\n\t\t\tStringBuilder s = new StringBuilder();\n\t\t\ts.append((bits & JLC_GETDECLAREDCONSTRUCTORS) != 0 ? \"Class.getDeclaredConstructors()\" : \"\");\n\t\t\ts.append((bits & JLC_GETDECLAREDCONSTRUCTOR) != 0 ? \"Class.getDeclaredConstructor()\" : \"\");\n\t\t\ts.append((bits & JLC_GETCONSTRUCTOR) != 0 ? \"Class.getConstructor()\" : \"\");\n\t\t\ts.append((bits & JLC_GETMODIFIERS) != 0 ? \"Class.getModifiers()\" : \"\");\n\t\t\ts.append((bits & JLC_GETDECLAREDFIELDS) != 0 ? \"Class.getDeclaredFields() \" : \"\");\n\t\t\ts.append((bits & JLC_GETDECLAREDFIELD) != 0 ? \"Class.getDeclaredField() \" : \"\");\n\t\t\ts.append((bits & JLC_GETFIELD) != 0 ? \"Class.getField() \" : \"\");\n\t\t\ts.append((bits & JLC_GETDECLAREDMETHODS) != 0 ? \"Class.getDeclaredMethods() \" : \"\");\n\t\t\ts.append((bits & JLC_GETDECLAREDMETHOD) != 0 ? \"Class.getDeclaredMethod() \" : \"\");\n\t\t\ts.append((bits & JLC_GETMETHOD) != 0 ? \"Class.getMethod() \" : \"\");\n\t\t\ts.append((bits & JLC_GETMETHODS) != 0 ? \"Class.getMethods() \" : \"\");\n\t\t\ts.append((bits & JLRM_INVOKE) != 0 ? \"Method.invoke() \" : \"\");\n\t\t\ts.append((bits & JLRF_GET) != 0 ? \"Field.get() \" : \"\");\n\t\t\ts.append((bits & JLRF_GETLONG) != 0 ? \"Field.getLong() \" : \"\");\n\t\t\ts.append((bits & JLOS_HASSTATICINITIALIZER) != 0 ? \"jlObjectStream.hasStaticInitializer() \" : \"\");\n\t\t\treturn s.toString().trim();\n\t\t}\n\t}\n\tstatic class RewriteClassAdaptor extends ClassVisitor implements Constants {\n\t\tprivate ClassWriter cw;\n\t\tint bits = 0x0000;\n\t\tprivate String classname;\n\t\tprivate boolean is_jlObjectStream;\n\t\t//\t\tenum SpecialRewrite { NotSpecial, java_io_ObjectStreamClass_2 };\n\t\t//\t\tprivate SpecialRewrite special = SpecialRewrite.NotSpecial;\n\t\t// TODO [perf] lookup like this really the fastest way?\n\t\tprivate static boolean isInterceptable(String owner, String methodName) {\n\t\t\tString s = new StringBuilder(owner).append(\".\").append(methodName).toString();\n\t\t\treturn MethodInvokerRewriter.RewriteClassAdaptor.intercepted.contains(s);\n\t\t}\n\t\tpublic RewriteClassAdaptor(boolean is_jlObjectStream) {\n\t\t\tsuper(ASM5, new ClassWriter(ClassWriter.COMPUTE_MAXS));\n\t\t\tcw = (ClassWriter) cv;\n\t\t\tthis.is_jlObjectStream = is_jlObjectStream;\n\t\t\tif (this.is_jlObjectStream) {\n\t\t\t\tbits |= JLOS_HASSTATICINITIALIZER;\n\t\t\t}\n\t\t}\n\t\tpublic byte[] getBytes() {\n\t\t\tbyte[] bytes = cw.toByteArray();\n\t\t\treturn bytes;\n\t\t}\n\t\tpublic int getBits() {\n\t\t\treturn bits;\n\t\t}\n\t\t@Override\n\t\tpublic void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n\t\t\tsuper.visit(version, access, name, signature, superName, interfaces);\n\t\t\tthis.classname = name;<fim_middle>// class below has no smell\n"}