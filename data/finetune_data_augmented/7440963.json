{"text": "<fim_prefix>import com.oracle.truffle.llvm.runtime.memory.LLVMMemoryOpNode;\nimport com.oracle.truffle.llvm.runtime.memory.LLVMStack;\nimport com.oracle.truffle.llvm.runtime.memory.LLVMStack.StackPointer;\nimport com.oracle.truffle.llvm.runtime.memory.LLVMThreadingStack;\nimport com.oracle.truffle.llvm.runtime.nodes.api.LLVMStatementNode;\nimport com.oracle.truffle.llvm.runtime.options.SulongEngineOption;\nimport com.oracle.truffle.llvm.runtime.pointer.LLVMManagedPointer;\nimport com.oracle.truffle.llvm.runtime.pointer.LLVMNativePointer;\nimport com.oracle.truffle.llvm.runtime.pointer.LLVMPointer;\nimport com.oracle.truffle.llvm.runtime.types.AggregateType;\nimport com.oracle.truffle.llvm.runtime.types.FunctionType;\nimport com.oracle.truffle.llvm.runtime.types.Type;\npublic final class LLVMContext {\n    private final List<Path> libraryPaths = new ArrayList<>();\n    private final List<ExternalLibrary> externalLibraries = new ArrayList<>();\n    // map that contains all non-native globals, needed for pointer->global lookups\n    private final HashMap<LLVMPointer, LLVMGlobal> globalsReverseMap = new HashMap<>();\n    // allocations used to store non-pointer globals (need to be freed when context is disposed)\n    private final ArrayList<LLVMPointer> globalsNonPointerStore = new ArrayList<>();\n    private final ArrayList<LLVMPointer> globalsReadOnlyStore = new ArrayList<>();\n    private DataLayout dataLayout;\n    private final List<LLVMThread> runningThreads = new ArrayList<>();\n    @CompilationFinal private LLVMThreadingStack threadingStack;\n    private final Object[] mainArguments;\n    private final Map<String, String> environment;\n    private final LinkedList<LLVMNativePointer> caughtExceptionStack = new LinkedList<>();\n    private final HashMap<String, Integer> nativeCallStatistics;\n    private static final class Handle {\n        private int refcnt;\n        private final LLVMNativePointer pointer;\n        private final TruffleObject managed;\n        private Handle(LLVMNativePointer pointer, TruffleObject managed) {\n            this.refcnt = 0;\n            this.pointer = pointer;\n            this.managed = managed;\n        }\n    }\n    private final Object handlesLock;\n    private final EconomicMap<TruffleObject, Handle> handleFromManaged;\n    private final EconomicMap<LLVMNativePointer, Handle> handleFromPointer;\n    private final LLVMSourceContext sourceContext;\n    private final LLVMLanguage language;\n    private final Env env;\n    private final Configuration activeConfiguration;\n    private final LLVMScope globalScope;\n    private final DynamicLinkChain dynamicLinkChain;\n    private final List<RootCallTarget> destructorFunctions;\n    private final LLVMFunctionPointerRegistry functionPointerRegistry;\n    private final LLVMInteropType.InteropTypeRegistry interopTypeRegistry;\n    private final List<ContextExtension> contextExtensions;\n    // we are not able to clean up ThreadLocals properly, so we are using maps instead\n    private final Map<Thread, Object> tls = new HashMap<>();\n    private final Map<Thread, LLVMPointer> clearChildTid = new HashMap<>();\n    // signals\n    private final LLVMNativePointer sigDfl;\n    private final LLVMNativePointer sigIgn;\n    private final LLVMNativePointer sigErr;\n    private boolean initialized;\n    private boolean cleanupNecessary;\n    private final NodeFactory nodeFactory;\n    private final LLVMTracerInstrument tracer;\n    private final class LLVMFunctionPointerRegistry {\n        private int currentFunctionIndex = 1;\n        private final HashMap<LLVMNativePointer, LLVMFunctionDescriptor> functionDescriptors = new HashMap<>();\n        synchronized LLVMFunctionDescriptor getDescriptor(LLVMNativePointer pointer) {\n            return functionDescriptors.get(pointer);\n        }\n        synchronized void register(LLVMNativePointer pointer, LLVMFunctionDescriptor desc) {\n            functionDescriptors.put(pointer, desc);\n        }\n        synchronized LLVMFunctionDescriptor create(String name, FunctionType type) {\n            return LLVMFunctionDescriptor.createDescriptor(LLVMContext.this, name, type, currentFunctionIndex++);\n        }\n    }\n    public LLVMContext(LLVMLanguage language, Env env, Configuration activeConfiguration, String languageHome) {\n        this.language = language;\n        this.env = env;\n        this.activeConfiguration = activeConfiguration;\n        this.nodeFactory = activeConfiguration.createNodeFactory(this);\n        this.contextExtensions = activeConfiguration.createContextExtensions(this);\n        this.initialized = false;\n        this.cleanupNecessary = false;\n        this.dataLayout = new DataLayout();\n        this.destructorFunctions = new ArrayList<>();\n        this.nativeCallStatistics = SulongEngineOption.isTrue(env.getOptions().get(SulongEngineOption.NATIVE_CALL_STATS)) ? new HashMap<>() : null;\n        this.sigDfl = LLVMNativePointer.create(0);\n        this.sigIgn = LLVMNativePointer.create(1);\n        this.sigErr = LLVMNativePointer.create(-1);\n        this.handleFromManaged = EconomicMap.create();\n        this.handleFromPointer = EconomicMap.create();\n        this.handlesLock = new Object();\n        this.functionPointerRegistry = new LLVMFunctionPointerRegistry();\n        this.interopTypeRegistry = new LLVMInteropType.InteropTypeRegistry();\n        this.sourceContext = new LLVMSourceContext();\n        this.globalScope = new LLVMScope();\n        this.dynamicLinkChain = new DynamicLinkChain();\n        Object mainArgs = env.getConfig().get(LLVMLanguage.MAIN_ARGS_KEY);\n        this.mainArguments = mainArgs == null ? env.getApplicationArguments() : (Object[]) mainArgs;\n        this.environment = System.getenv();\n        addLibraryPaths(SulongEngineOption.getPolyglotOptionSearchPaths(env));\n        if (languageHome != null) {\n            addLibraryPath(languageHome);\n        }\n        final String traceOption = env.getOptions().get(SulongEngineOption.TRACE_IR);\n        if (!\"\".equalsIgnoreCase(traceOption)) {\n            if (!env.getOptions().get(SulongEngineOption.LL_DEBUG)) {\n                throw new IllegalStateException(\"\\'--llvm.traceIR\\' requires \\'--llvm.llDebug=true\\'\");\n            }\n            tracer = new LLVMTracerInstrument();\n            tracer.initialize(env, traceOption);\n        } else {\n            tracer = null;\n        }\n    }\n    private static final class InitializeContextNode extends LLVMStatementNode {\n        private final ContextReference<LLVMContext> ctxRef;\n        private final FrameSlot stackPointer;\n        @Child DirectCallNode initContext;\n        InitializeContextNode(LLVMContext ctx, FrameDescriptor rootFrame) {\n            this.ctxRef = ctx.getLanguage().getContextReference();\n            this.stackPointer = rootFrame.findFrameSlot(LLVMStack.FRAME_ID);\n            LLVMFunctionDescriptor initContextDescriptor = ctx.globalScope.getFunction(\"@__sulong_init_context\");\n            RootCallTarget initContextFunction = initContextDescriptor.getLLVMIRFunction();\n            this.initContext = DirectCallNode.create(initContextFunction);\n        }\n        @Override\n        public void execute(VirtualFrame frame) {\n            LLVMContext ctx = ctxRef.get();\n            if (!ctx.initialized) {\n                assert !ctx.cleanupNecessary;\n                ctx.initialized = true;\n                ctx.cleanupNecessary = true;\n                try (StackPointer sp = ((StackPointer) FrameUtil.getObjectSafe(frame, stackPointer)).newFrame()) {\n                    Object[] args = new Object[]{sp, ctx.getApplicationArguments(), ctx.getEnvironmentVariables(), ctx.getRandomValues()};\n                    initContext.call(args);\n                }\n            }\n        }\n    }\n    public void initialize() {\n        assert this.threadingStack == null;\n        this.threadingStack = new LLVMThreadingStack(Thread.currentThread(), env.getOptions().get(SulongEngineOption.STACK_SIZE_KB));\n        for (ContextExtension ext : contextExtensions) {\n            ext.initialize();\n        }\n    }\n    public boolean isInitialized() {\n        return threadingStack != null;\n    }\n    public LLVMStatementNode createInitializeContextNode(FrameDescriptor rootFrame) {\n        // we can't do the initialization in the LLVMContext constructor nor in\n        // Sulong.createContext() because Truffle is not properly initialized there. So, we need to\n        // do it in a delayed way.\n        return new InitializeContextNode(this, rootFrame);\n    }\n<fim_suffix>    @TruffleBoundary\n    private LLVMManagedPointer getApplicationArguments() {\n        String[] result;\n        if (mainArguments == null) {\n            result = new String[]{\"\"};\n        } else {\n            result = new String[mainArguments.length + 1];\n            // we don't have an application path at this point in time. it will be overwritten when\n            // _start is called\n            result[0] = \"\";\n            for (int i = 1; i < result.length; i++) {\n                result[i] = mainArguments[i - 1].toString();\n            }\n        }\n        return toTruffleObjects(result);\n    }<fim_middle>// function below has no smell\n"}