{"text": "<fim_prefix>import org.apache.beam.sdk.testing.TestStream.Event;\nimport org.apache.beam.sdk.testing.TestStream.EventType;\nimport org.apache.beam.sdk.testing.TestStream.ProcessingTimeEvent;\nimport org.apache.beam.sdk.testing.TestStream.WatermarkEvent;\nimport org.apache.beam.sdk.transforms.PTransform;\nimport org.apache.beam.sdk.transforms.windowing.BoundedWindow;\nimport org.apache.beam.sdk.util.WindowedValue;\nimport org.apache.beam.sdk.values.PBegin;\nimport org.apache.beam.sdk.values.PCollection;\nimport org.apache.beam.sdk.values.PCollection.IsBounded;\nimport org.apache.beam.sdk.values.PValue;\nimport org.apache.beam.sdk.values.TimestampedValue;\nimport org.apache.beam.sdk.values.TupleTag;\nimport org.apache.beam.sdk.values.WindowingStrategy;\nimport org.apache.beam.vendor.guava.v20_0.com.google.common.annotations.VisibleForTesting;\nimport org.apache.beam.vendor.guava.v20_0.com.google.common.base.Supplier;\nimport org.apache.beam.vendor.guava.v20_0.com.google.common.collect.Iterables;\nimport org.joda.time.Duration;\nimport org.joda.time.Instant;\n/** The {@link TransformEvaluatorFactory} for the {@link TestStream} primitive. */\n<fim_suffix>class TestStreamEvaluatorFactory implements TransformEvaluatorFactory {\n  private final EvaluationContext evaluationContext;\n  TestStreamEvaluatorFactory(EvaluationContext evaluationContext) {\n    this.evaluationContext = evaluationContext;\n  }\n  @Nullable\n  @Override\n  public <InputT> TransformEvaluator<InputT> forApplication(\n      AppliedPTransform<?, ?, ?> application, CommittedBundle<?> inputBundle) {\n    return createEvaluator((AppliedPTransform) application);\n  }\n  @Override\n  public void cleanup() throws Exception {}\n  /**\n   * Returns the evaluator for the provided application of {@link TestStream}, or null if it is\n   * already in use.\n   *\n   * <p>The documented behavior of {@link TestStream} requires the output of one event to travel\n   * completely through the pipeline before any additional event, so additional instances that have\n   * a separate collection of events cannot be created.\n   */\n  private <InputT, OutputT> TransformEvaluator<? super InputT> createEvaluator(\n      AppliedPTransform<PBegin, PCollection<OutputT>, TestStream<OutputT>> application) {\n    return (TransformEvaluator<InputT>) new Evaluator<>(application, evaluationContext);\n  }\n  private static class Evaluator<T> implements TransformEvaluator<TestStreamIndex<T>> {\n    private final AppliedPTransform<PBegin, PCollection<T>, TestStream<T>> application;\n    private final EvaluationContext context;\n    private final StepTransformResult.Builder resultBuilder;\n    private Evaluator(\n        AppliedPTransform<PBegin, PCollection<T>, TestStream<T>> application,\n        EvaluationContext context) {\n      this.application = application;\n      this.context = context;\n      this.resultBuilder = StepTransformResult.withoutHold(application);\n    }\n    @Override\n    public void processElement(WindowedValue<TestStreamIndex<T>> element) throws Exception {\n      TestStreamIndex<T> streamIndex = element.getValue();\n      List<Event<T>> events = streamIndex.getTestStream().getEvents();\n      int index = streamIndex.getIndex();\n      Instant watermark = element.getTimestamp();\n      Event<T> event = events.get(index);\n      if (event.getType().equals(EventType.ELEMENT)) {\n        UncommittedBundle<T> bundle =\n            context.createBundle(\n                (PCollection<T>) Iterables.getOnlyElement(application.getOutputs().values()));\n        for (TimestampedValue<T> elem : ((ElementEvent<T>) event).getElements()) {\n          bundle.add(\n              WindowedValue.timestampedValueInGlobalWindow(elem.getValue(), elem.getTimestamp()));\n        }\n        resultBuilder.addOutput(bundle);\n      }\n      if (event.getType().equals(EventType.WATERMARK)) {\n        watermark = ((WatermarkEvent<T>) event).getWatermark();\n      }\n      if (event.getType().equals(EventType.PROCESSING_TIME)) {\n        ((TestClock) context.getClock())\n            .advance(((ProcessingTimeEvent<T>) event).getProcessingTimeAdvance());\n      }\n      TestStreamIndex<T> next = streamIndex.next();\n      if (next.getIndex() < events.size()) {\n        resultBuilder.addUnprocessedElements(\n            Collections.singleton(WindowedValue.timestampedValueInGlobalWindow(next, watermark)));\n      }\n    }\n    @Override\n    public TransformResult<TestStreamIndex<T>> finishBundle() throws Exception {\n      return resultBuilder.build();\n    }\n  }\n  @VisibleForTesting\n  static class TestClock implements Clock {\n    private final AtomicReference<Instant> currentTime =\n        new AtomicReference<>(BoundedWindow.TIMESTAMP_MIN_VALUE);\n    public void advance(Duration amount) {\n      Instant now = currentTime.get();\n      currentTime.compareAndSet(now, now.plus(amount));\n    }\n    @Override\n    public Instant now() {\n      return currentTime.get();\n    }\n  }\n  private static class TestClockSupplier implements Supplier<Clock> {\n    @Override\n    public Clock get() {\n      return new TestClock();\n    }\n  }\n  static class DirectTestStreamFactory<T>\n      implements PTransformOverrideFactory<\n          PBegin, PCollection<T>, PTransform<PBegin, PCollection<T>>> {\n    private final DirectRunner runner;\n    DirectTestStreamFactory(DirectRunner runner) {\n      this.runner = runner;\n    }\n    @Override\n    public PTransformReplacement<PBegin, PCollection<T>> getReplacementTransform(\n        AppliedPTransform<PBegin, PCollection<T>, PTransform<PBegin, PCollection<T>>> transform) {\n      try {\n        return PTransformReplacement.of(\n            transform.getPipeline().begin(),\n            new DirectTestStream<>(runner, TestStreamTranslation.getTestStream(transform)));\n      } catch (IOException exc) {\n        throw new RuntimeException(\n            String.format(\n                \"Transform could not be converted to %s\", TestStream.class.getSimpleName()),\n            exc);\n      }\n    }\n    @Override\n    public Map<PValue, ReplacementOutput> mapOutputs(\n        Map<TupleTag<?>, PValue> outputs, PCollection<T> newOutput) {\n      return ReplacementOutputs.singleton(outputs, newOutput);\n    }\n    static final String DIRECT_TEST_STREAM_URN = \"urn:beam:directrunner:transforms:test_stream:v1\";\n    static class DirectTestStream<T> extends PTransform<PBegin, PCollection<T>> {\n      private final transient DirectRunner runner;\n      private final TestStream<T> original;\n      @VisibleForTesting\n      DirectTestStream(DirectRunner runner, TestStream<T> transform) {\n        this.runner = runner;\n        this.original = transform;\n      }\n      @Override\n      public PCollection<T> expand(PBegin input) {\n        runner.setClockSupplier(new TestClockSupplier());\n        return PCollection.createPrimitiveOutputInternal(\n            input.getPipeline(),\n            WindowingStrategy.globalDefault(),\n            IsBounded.UNBOUNDED,\n            original.getValueCoder());\n      }\n    }\n  }\n  static class InputProvider<T> implements RootInputProvider<T, TestStreamIndex<T>, PBegin> {\n    private final EvaluationContext evaluationContext;\n    InputProvider(EvaluationContext evaluationContext) {\n      this.evaluationContext = evaluationContext;\n    }\n    @Override\n    public Collection<CommittedBundle<TestStreamIndex<T>>> getInitialInputs(\n        AppliedPTransform<PBegin, PCollection<T>, PTransform<PBegin, PCollection<T>>> transform,\n        int targetParallelism) {\n      // This will always be run on an execution-time transform, so it can be downcast\n      DirectTestStreamFactory.DirectTestStream<T> testStream =\n          (DirectTestStreamFactory.DirectTestStream<T>) transform.getTransform();\n      CommittedBundle<TestStreamIndex<T>> initialBundle =\n          evaluationContext\n              .<TestStreamIndex<T>>createRootBundle()\n              .add(WindowedValue.valueInGlobalWindow(TestStreamIndex.of(testStream.original)))\n              .commit(BoundedWindow.TIMESTAMP_MAX_VALUE);\n      return Collections.singleton(initialBundle);\n    }\n  }\n  @AutoValue\n  abstract static class TestStreamIndex<T> {\n    static <T> TestStreamIndex<T> of(TestStream<T> stream) {\n      return new AutoValue_TestStreamEvaluatorFactory_TestStreamIndex<>(stream, 0);\n    }\n    abstract TestStream<T> getTestStream();\n    abstract int getIndex();\n    TestStreamIndex<T> next() {\n      return new AutoValue_TestStreamEvaluatorFactory_TestStreamIndex<>(\n          getTestStream(), getIndex() + 1);\n    }\n  }\n}<fim_middle>// class below has no smell\n"}