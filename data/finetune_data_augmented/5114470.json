{"text": "<fim_prefix>/* $Id$ */\n/**\n* Licensed to the Apache Software Foundation (ASF) under one or more\n* contributor license agreements. See the NOTICE file distributed with\n* this work for additional information regarding copyright ownership.\n* The ASF licenses this file to You under the Apache License, Version 2.0\n* (the \"License\"); you may not use this file except in compliance with\n* the License. You may obtain a copy of the License at\n*\n* http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\npackage org.apache.manifoldcf.crawler.jobs;\nimport java.util.*;\nimport java.io.*;\nimport org.apache.manifoldcf.crawler.system.Logging;\n/** Debugging class to keep track of recent modifications to the jobqueue table,\n* along with context as to where it occurred.  If a jobqueue state error occurs,\n* we can then print out all of the pertinent history and find the culprit.\n*/\npublic class TrackerClass\n{\n  // The goal of this class is to keep track of at least some of the history\n  // potentially affecting each record.\n  protected final static long HISTORY_LENGTH = 60000L * 15;     // 15 minutes\n  // Active transaction\n  protected final static Map<String,TransactionData> transactionData = new HashMap<String,TransactionData>();\n  // Modification history\n  protected final static List<HistoryRecord> history = new ArrayList<HistoryRecord>();\n  // Place where we keep track of individual modifications\n  private TrackerClass()\n  {\n  }\n  /** Add a single record event, as yet uncommitted */\n  public static void noteRecordChange(Long recordID, int newStatus, String description)\n  {\n    if (Logging.diagnostics.isDebugEnabled())\n      addChange(new RecordChange(recordID, newStatus, description));\n  }\n  /** Add a global event, as yet uncommitted, which has the potential\n  * to affect any record's state in a given job.\n  */\n  public static void noteJobChange(Long jobID, String description)\n  {\n    if (Logging.diagnostics.isDebugEnabled())\n      addChange(new JobChange(jobID, description));\n  }\n  /** Add a global event, as yet uncommitted, which has the potential\n  * to affect the state of any record.\n  */\n  public static void noteGlobalChange(String description)\n  {\n    if (Logging.diagnostics.isDebugEnabled())\n      addChange(new GlobalChange(description));\n  }\n  protected static void addChange(DataChange dc)\n  {\n    String threadName = Thread.currentThread().getName();\n    TransactionData td;\n    synchronized (transactionData)\n    {\n      td = transactionData.get(threadName);\n      if (td == null)\n      {\n        td = new TransactionData();\n        transactionData.put(threadName,td);\n      }\n    }\n    td.addChange(dc);\n  }\n  /** Note that we are about to commit.\n  */\n  public static void notePrecommit()\n  {\n    if (!Logging.diagnostics.isDebugEnabled())\n      return;\n    long currentTime = System.currentTimeMillis();\n    String threadName = Thread.currentThread().getName();\n    TransactionData td;\n    synchronized (transactionData)\n    {\n      td = transactionData.get(threadName);\n    }\n    if (td == null)\n      return;\n    HistoryRecord hr = new PrecommitEvent(new Exception(\"Precommit stack trace\"),currentTime,threadName,td);\n    synchronized (history)\n    {\n      history.add(hr);\n    }\n  }\n  /** Note a read status operation.\n  */\n  public static void noteRead(Long recordID)\n  {\n    if (!Logging.diagnostics.isDebugEnabled())\n      return;\n    long currentTime = System.currentTimeMillis();\n    String threadName = Thread.currentThread().getName();\n    HistoryRecord hr = new ReadEvent(new Exception(\"Read stack trace\"),currentTime,threadName,recordID);\n    synchronized (history)\n    {\n      history.add(hr);\n    }\n  }\n  /** Note about to read status operation.\n  */\n  public static void notePreread(Long recordID)\n  {\n    if (!Logging.diagnostics.isDebugEnabled())\n      return;\n    long currentTime = System.currentTimeMillis();\n    String threadName = Thread.currentThread().getName();\n    HistoryRecord hr = new PrereadEvent(new Exception(\"Pre-read stack trace\"),currentTime,threadName,recordID);\n    synchronized (history)\n    {\n      history.add(hr);\n    }\n  }\n  /** Note a commit operation.\n  */\n  public static void noteCommit()\n  {\n    if (!Logging.diagnostics.isDebugEnabled())\n      return;\n    long currentTime = System.currentTimeMillis();\n    String threadName = Thread.currentThread().getName();\n    TransactionData td;\n    synchronized (transactionData)\n    {\n      td = transactionData.get(threadName);\n      transactionData.remove(threadName);\n    }\n    if (td == null)\n      return;\n    HistoryRecord hr = new CommitEvent(new Exception(\"Commit stack trace\"),currentTime,threadName,td);\n    // Only keep stuff around for an hour\n    long removalCutoff = currentTime - HISTORY_LENGTH;\n    synchronized (history)\n    {\n      history.add(hr);\n      // Clean out older records\n      // MHL - this logic is wrong\n      while (history.size() > 0)\n      {\n        HistoryRecord oldRecord = history.get(0);\n        if (oldRecord.isFlushable(removalCutoff))\n          history.remove(0);\n        else\n          break;\n      }\n    }\n  }\n  /** Note a rollback operation.\n  */\n  public static void noteRollback()\n  {\n    if (!Logging.diagnostics.isDebugEnabled())\n      return;\n    String threadName = Thread.currentThread().getName();\n    synchronized (transactionData)\n    {\n      transactionData.remove(threadName);\n    }\n  }\n  public static void printForensics(Long recordID, int existingStatus)\n  {\n    if (Logging.diagnostics.isDebugEnabled())\n    {\n      synchronized (transactionData)\n      {\n        synchronized (history)\n        {\n          Logging.diagnostics.debug(\"==== Forensics for record \"+recordID+\", current status: \"+existingStatus+\" ====\");\n          Logging.diagnostics.debug(\"=== Current stack trace ===\",new Exception(\"Forensics stack trace\"));\n          Logging.diagnostics.debug(\"=== Active transactions ===\");\n          for (String threadName : transactionData.keySet())\n          {\n            for (DataChange dc : transactionData.get(threadName).getChanges())\n            {\n              if (dc.applies(recordID))\n              {\n                Logging.diagnostics.debug(\"Thread '\"+threadName+\"' was doing things to this record: \" + dc.getDescription());\n              }\n            }\n          }\n          Logging.diagnostics.debug(\"=== Pertinent History ===\");\n          for (HistoryRecord hr : history)\n          {\n            if (hr.applies(recordID))\n            {\n              hr.print();\n            }\n          }\n        }\n      }\n    }\n  }\n  protected static class TransactionData\n  {\n    protected final List<DataChange> changes = new ArrayList<DataChange>();\n    public TransactionData()\n    {\n    }\n    public void addChange(DataChange change)\n    {\n      changes.add(change);\n    }\n    public List<DataChange> getChanges()\n    {\n      return changes;\n    }\n    public boolean applies(Long recordID)\n    {\n      for (DataChange dc : changes)\n      {\n        if (dc.applies(recordID))\n          return true;\n      }\n      return false;\n    }\n  }\n  protected abstract static class DataChange\n  {\n    protected final String description;\n    public DataChange(String description)\n    {\n      this.description = description;\n    }\n    public String getDescription()\n    {\n      return description;\n    }\n    public abstract boolean applies(Long recordID);\n  }\n<fim_suffix>  protected abstract static class HistoryRecord\n  {\n    protected final long timestamp;\n    protected final Exception trace;\n    protected final String threadName;\n    public HistoryRecord(Exception trace, long timestamp, String threadName)\n    {\n      this.trace = trace;\n      this.timestamp = timestamp;\n      this.threadName = threadName;\n    }\n    public void print(String description)\n    {\n      Logging.diagnostics.debug(\"== \"+description+\" by '\"+threadName+\"' at \"+new Long(timestamp)+\" ==\",trace);\n    }\n    public boolean isFlushable(long timestamp)\n    {\n      return this.timestamp < timestamp;\n    }\n    public abstract boolean applies(Long recordID);\n    public abstract void print();\n  }\n  protected static class CommitEvent extends HistoryRecord\n  {\n    protected final TransactionData transactionData;\n    public CommitEvent(Exception trace, long timestamp, String threadName, TransactionData transactionData)\n    {\n      super(trace,timestamp,threadName);\n      this.transactionData = transactionData;\n    }\n    @Override\n    public void print()\n    {\n      super.print(\"Commit transaction\");\n      Logging.diagnostics.debug(\"    Transaction includes:\");\n      for (DataChange dc : transactionData.getChanges())\n      {\n        Logging.diagnostics.debug(\"      \"+dc.getDescription());\n      }\n    }\n    @Override\n    public boolean applies(Long recordID)\n    {\n      return transactionData.applies(recordID);\n    }\n  }<fim_middle>// class below has no smell\n"}