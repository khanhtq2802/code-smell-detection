{"text": "<fim_prefix>\t\t\treturn requirerWiring;\n\t\t}\n\t\tpublic BundleRevision getProvider() {\n\t\t\treturn capability.getResource();\n\t\t}\n\t\tpublic BundleRevision getRequirer() {\n\t\t\treturn requirement.getResource();\n\t\t}\n\t}\n\tstatic class ConciergeWiring implements Wiring {\n\t\tprivate final Resource resource;\n\t\tprivate final MultiMap<String, Capability> capabilities = new MultiMap<String, Capability>();\n\t\tprivate final MultiMap<String, Requirement> requirements = new MultiMap<String, Requirement>();\n\t\tprivate final MultiMap<String, Wire> providedWires = new MultiMap<String, Wire>();\n\t\tprivate final MultiMap<String, Wire> requiredWires = new MultiMap<String, Wire>();\n\t\tConciergeWiring(final Resource resource, final List<Wire> wires) {\n\t\t\tthis.resource = resource;\n\t\t\tfor (final Wire wire : wires) {\n\t\t\t\taddWire(wire);\n\t\t\t}\n\t\t}\n\t\tprivate void addWire(final Wire wire) {\n\t\t\tif (wire.getProvider() == resource) {\n\t\t\t\tfinal Capability cap = wire.getCapability();\n\t\t\t\tcapabilities.insertUnique(cap.getNamespace(), cap);\n\t\t\t\tprovidedWires.insert(cap.getNamespace(), wire);\n\t\t\t} else {\n\t\t\t\tfinal Requirement req = wire.getRequirement();\n\t\t\t\trequirements.insertUnique(req.getNamespace(), req);\n\t\t\t\trequiredWires.insert(req.getNamespace(), wire);\n\t\t\t}\n\t\t}\n\t\tpublic List<Capability> getResourceCapabilities(final String namespace) {\n\t\t\treturn namespace == null ? capabilities.getAllValues()\n\t\t\t\t\t: capabilities.lookup(namespace);\n\t\t}\n\t\tpublic List<Requirement> getResourceRequirements(final String namespace) {\n\t\t\treturn namespace == null ? requirements.getAllValues()\n\t\t\t\t\t: requirements.lookup(namespace);\n\t\t}\n\t\tpublic List<Wire> getProvidedResourceWires(final String namespace) {\n\t\t\treturn namespace == null ? providedWires.getAllValues()\n\t\t\t\t\t: providedWires.lookup(namespace);\n\t\t}\n\t\tpublic List<Wire> getRequiredResourceWires(final String namespace) {\n\t\t\treturn namespace == null ? requiredWires.getAllValues()\n\t\t\t\t\t: requiredWires.lookup(namespace);\n\t\t}\n\t\tpublic Resource getResource() {\n\t\t\treturn resource;\n\t\t}\n\t}\n\tstatic class ConciergeBundleWiring implements BundleWiring {\n\t\tprotected final BundleRevision revision;\n\t\tprivate final MultiMap<String, BundleCapability> capabilities = new MultiMap<String, BundleCapability>();\n\t\tprivate final MultiMap<String, BundleRequirement> requirements = new MultiMap<String, BundleRequirement>();\n\t\tprivate final Comparator<BundleWire> provComp = new Comparator<BundleWire>() {\n\t\t\tpublic int compare(final BundleWire w1, final BundleWire w2) {\n\t\t\t\tfinal BundleCapability cap1 = w1.getCapability();\n\t\t\t\tfinal BundleCapability cap2 = w2.getCapability();\n\t\t\t\tassert cap1.getNamespace().equals(cap2.getNamespace());\n\t\t\t\tfinal List<Capability> caps = revision.getCapabilities(cap1\n\t\t\t\t\t\t.getNamespace());\n\t\t\t\treturn caps.indexOf(cap1) - caps.indexOf(cap2);\n\t\t\t}\n\t\t};\n\t\tprivate final Comparator<BundleWire> reqComp = new Comparator<BundleWire>() {\n\t\t\tpublic int compare(final BundleWire w1, final BundleWire w2) {\n\t\t\t\tfinal BundleRequirement req1 = w1.getRequirement();\n\t\t\t\tfinal BundleRequirement req2 = w2.getRequirement();\n\t\t\t\tassert req1.getNamespace().equals(req2.getNamespace());\n\t\t\t\tfinal List<Requirement> reqs = revision.getRequirements(req1\n\t\t\t\t\t\t.getNamespace());\n\t\t\t\treturn reqs.indexOf(req1) - reqs.indexOf(req2);\n\t\t\t}\n\t\t};\n\t\tprivate final MultiMap<String, BundleWire> providedWires = new MultiMap<String, BundleWire>(\n\t\t\t\tprovComp);\n\t\tprivate final MultiMap<String, BundleWire> requiredWires = new MultiMap<String, BundleWire>(\n\t\t\t\treqComp);\n\t\tfinal HashSet<BundleRevision> inUseSet = new HashSet<BundleRevision>();\n\t\tConciergeBundleWiring(final BundleRevision revision,\n\t\t\t\tfinal List<Wire> wires) {\n\t\t\tthis.revision = revision;\n\t\t\tfinal HashSet<Requirement> reqCache = new HashSet<Requirement>();\n\t\t\tif (wires != null) {\n\t\t\t\tfor (final Wire wire : wires) {\n\t\t\t\t\taddWire((BundleWire) wire);\n\t\t\t\t\tif (wire.getRequirer() == revision) {\n\t\t\t\t\t\treqCache.add(wire.getRequirement());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (final BundleCapability cap : revision\n\t\t\t\t\t.getDeclaredCapabilities(null)) {\n\t\t\t\tfinal String effective = cap.getDirectives().get(\n\t\t\t\t\t\tNamespace.CAPABILITY_EFFECTIVE_DIRECTIVE);\n\t\t\t\tif (effective == null\n\t\t\t\t\t\t|| Namespace.EFFECTIVE_RESOLVE.equals(effective)) {\n\t\t\t\t\tcapabilities.insert(cap.getNamespace(), cap);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (revision.getTypes() == BundleRevision.TYPE_FRAGMENT) {\n\t\t\t\tcapabilities.remove(IdentityNamespace.IDENTITY_NAMESPACE);\n\t\t\t}\n\t\t\tfor (final BundleRequirement req : revision\n\t\t\t\t\t.getDeclaredRequirements(null)) {\n\t\t\t\tfinal String effective = req.getDirectives().get(\n\t\t\t\t\t\tNamespace.REQUIREMENT_EFFECTIVE_DIRECTIVE);\n\t\t\t\tfinal boolean optional = Namespace.RESOLUTION_OPTIONAL\n\t\t\t\t\t\t.equals(req.getDirectives().get(\n\t\t\t\t\t\t\t\tNamespace.REQUIREMENT_RESOLUTION_DIRECTIVE));\n\t\t\t\tif (effective == null\n\t\t\t\t\t\t|| Namespace.EFFECTIVE_RESOLVE.equals(effective)\n\t\t\t\t\t\t|| PackageNamespace.RESOLUTION_DYNAMIC\n\t\t\t\t\t\t\t\t.equals(req\n\t\t\t\t\t\t\t\t\t\t.getDirectives()\n\t\t\t\t\t\t\t\t\t\t.get(Namespace.REQUIREMENT_RESOLUTION_DIRECTIVE))) {\n\t\t\t\t\tif (!optional || reqCache.contains(req)) {\n\t\t\t\t\t\trequirements.insert(req.getNamespace(), req);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvoid addWire(final BundleWire wire) {\n\t\t\tfinal Capability cap = wire.getCapability();\n\t\t\tfinal Requirement req = wire.getRequirement();\n\t\t\tif (wire.getProvider() == revision) {\n\t\t\t\tprovidedWires.insert(cap.getNamespace(), wire);\n\t\t\t\tinUseSet.add(wire.getRequirer());\n\t\t\t\t((ConciergeBundleWire) wire).providerWiring = this;\n\t\t\t} else {\n\t\t\t\trequiredWires.insert(req.getNamespace(), wire);\n\t\t\t\tif (HostNamespace.HOST_NAMESPACE.equals(wire.getRequirement()\n\t\t\t\t\t\t.getNamespace())) {\n\t\t\t\t\tinUseSet.add(wire.getProvider());\n\t\t\t\t}\n\t\t\t\t((ConciergeBundleWire) wire).requirerWiring = this;\n\t\t\t}\n\t\t}\n\t\tHashMap<String, BundleWire> getPackageImportWires() {\n\t\t\tfinal List<BundleWire> list = getRequiredWires(PackageNamespace.PACKAGE_NAMESPACE);\n\t\t\tfinal HashMap<String, BundleWire> result = new HashMap<String, BundleWire>();\n\t\t\tif (list != null) {\n\t\t\t\tfor (final BundleWire wire : list) {\n\t\t\t\t\tresult.put((String) wire.getCapability().getAttributes()\n\t\t\t\t\t\t\t.get(PackageNamespace.PACKAGE_NAMESPACE), wire);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\tList<BundleWire> getRequireBundleWires() {\n\t\t\treturn getRequiredWires(BundleNamespace.BUNDLE_NAMESPACE);\n\t\t}\n\t\tpublic Bundle getBundle() {\n\t\t\treturn revision.getBundle();\n\t\t}\n\t\t/**\n\t\t * @see org.osgi.framework.wiring.BundleWiring#isCurrent()\n\t\t */\n\t\tpublic boolean isCurrent() {\n\t\t\t// always current if it is the system bundle\n\t\t\tif (revision.getBundle().getBundleId() == 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn ((AbstractBundle) revision.getBundle()).currentRevision == revision\n\t\t\t\t\t&& revision.getWiring() == this;\n\t\t}\n<fim_suffix>\t\tvoid cleanup() {\n\t\t\tfor (final BundleWire requiredWire : requiredWires.getAllValues()) {\n\t\t\t\tfinal ConciergeBundleWiring bw = ((ConciergeBundleWire) requiredWire).providerWiring;\n\t\t\t\tif (bw != null) {\n\t\t\t\t\tbw.inUseSet.remove(revision);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (final BundleWire hostWire : providedWires\n\t\t\t\t\t.lookup(HostNamespace.HOST_NAMESPACE)) {\n\t\t\t\tfinal ConciergeBundleWiring bw = ((ConciergeBundleWire) hostWire).requirerWiring;\n\t\t\t\tif (bw != null) {\n\t\t\t\t\tbw.inUseSet.remove(revision);\n\t\t\t\t}\n\t\t\t}\n\t\t}<fim_middle>// function below is feature envy\n"}