{"text": "<fim_prefix>/*\n * Copyright 2012-2018 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.springframework.boot.context.properties.bind;\nimport java.beans.PropertyEditor;\nimport java.lang.annotation.Annotation;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.function.Consumer;\nimport org.springframework.beans.BeanUtils;\nimport org.springframework.beans.PropertyEditorRegistry;\nimport org.springframework.beans.SimpleTypeConverter;\nimport org.springframework.beans.propertyeditors.FileEditor;\nimport org.springframework.boot.convert.ApplicationConversionService;\nimport org.springframework.core.ResolvableType;\nimport org.springframework.core.convert.ConversionException;\nimport org.springframework.core.convert.ConversionService;\nimport org.springframework.core.convert.TypeDescriptor;\nimport org.springframework.core.convert.converter.ConditionalGenericConverter;\nimport org.springframework.core.convert.support.GenericConversionService;\nimport org.springframework.util.Assert;\n/**\n * Utility to handle any conversion needed during binding. This class is not thread-safe\n * and so a new instance is created for each top-level bind.\n *\n * @author Phillip Webb\n * @author Andy Wilkinson\n */\nfinal class BindConverter {\n\tprivate static final Set<Class<?>> EXCLUDED_EDITORS;\n\tstatic {\n\t\tSet<Class<?>> excluded = new HashSet<>();\n\t\texcluded.add(FileEditor.class); // gh-12163\n\t\tEXCLUDED_EDITORS = Collections.unmodifiableSet(excluded);\n\t}\n\tprivate static BindConverter sharedInstance;\n\tprivate final ConversionService conversionService;\n\tprivate BindConverter(ConversionService conversionService,\n\t\t\tConsumer<PropertyEditorRegistry> propertyEditorInitializer) {\n\t\tAssert.notNull(conversionService, \"ConversionService must not be null\");\n\t\tList<ConversionService> conversionServices = getConversionServices(\n\t\t\t\tconversionService, propertyEditorInitializer);\n\t\tthis.conversionService = new CompositeConversionService(conversionServices);\n\t}\n\tprivate List<ConversionService> getConversionServices(\n\t\t\tConversionService conversionService,\n\t\t\tConsumer<PropertyEditorRegistry> propertyEditorInitializer) {\n\t\tList<ConversionService> services = new ArrayList<>();\n\t\tservices.add(new TypeConverterConversionService(propertyEditorInitializer));\n\t\tservices.add(conversionService);\n\t\tif (!(conversionService instanceof ApplicationConversionService)) {\n\t\t\tservices.add(ApplicationConversionService.getSharedInstance());\n\t\t}\n\t\treturn services;\n\t}\n\tpublic boolean canConvert(Object value, ResolvableType type,\n\t\t\tAnnotation... annotations) {\n\t\treturn this.conversionService.canConvert(TypeDescriptor.forObject(value),\n\t\t\t\tnew ResolvableTypeDescriptor(type, annotations));\n\t}\n\tpublic <T> T convert(Object result, Bindable<T> target) {\n\t\treturn convert(result, target.getType(), target.getAnnotations());\n\t}\n\t@SuppressWarnings(\"unchecked\")\n\tpublic <T> T convert(Object value, ResolvableType type, Annotation... annotations) {\n\t\tif (value == null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn (T) this.conversionService.convert(value, TypeDescriptor.forObject(value),\n\t\t\t\tnew ResolvableTypeDescriptor(type, annotations));\n\t}\n\tstatic BindConverter get(ConversionService conversionService,\n\t\t\tConsumer<PropertyEditorRegistry> propertyEditorInitializer) {\n\t\tif (conversionService == ApplicationConversionService.getSharedInstance()\n\t\t\t\t&& propertyEditorInitializer == null) {\n\t\t\tif (sharedInstance == null) {\n\t\t\t\tsharedInstance = new BindConverter(conversionService,\n\t\t\t\t\t\tpropertyEditorInitializer);\n\t\t\t}\n\t\t\treturn sharedInstance;\n\t\t}\n\t\treturn new BindConverter(conversionService, propertyEditorInitializer);\n\t}\n\t/**\n\t * A {@link TypeDescriptor} backed by a {@link ResolvableType}.\n\t */\n\tprivate static class ResolvableTypeDescriptor extends TypeDescriptor {\n\t\tResolvableTypeDescriptor(ResolvableType resolvableType,\n\t\t\t\tAnnotation[] annotations) {\n\t\t\tsuper(resolvableType, null, annotations);\n\t\t}\n\t}\n\t/**\n\t * Composite {@link ConversionService} used to call multiple services.\n\t */\n<fim_suffix>\tstatic class CompositeConversionService implements ConversionService {\n\t\tprivate final List<ConversionService> delegates;\n\t\tCompositeConversionService(List<ConversionService> delegates) {\n\t\t\tthis.delegates = delegates;\n\t\t}\n\t\t@Override\n\t\tpublic boolean canConvert(Class<?> sourceType, Class<?> targetType) {\n\t\t\tAssert.notNull(targetType, \"Target type to convert to cannot be null\");\n\t\t\treturn canConvert(\n\t\t\t\t\t(sourceType != null) ? TypeDescriptor.valueOf(sourceType) : null,\n\t\t\t\t\tTypeDescriptor.valueOf(targetType));\n\t\t}\n\t\t@Override\n\t\tpublic boolean canConvert(TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\t\tfor (ConversionService service : this.delegates) {\n\t\t\t\tif (service.canConvert(sourceType, targetType)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t@Override\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic <T> T convert(Object source, Class<T> targetType) {\n\t\t\tAssert.notNull(targetType, \"Target type to convert to cannot be null\");\n\t\t\treturn (T) convert(source, TypeDescriptor.forObject(source),\n\t\t\t\t\tTypeDescriptor.valueOf(targetType));\n\t\t}\n\t\t@Override\n\t\tpublic Object convert(Object source, TypeDescriptor sourceType,\n\t\t\t\tTypeDescriptor targetType) {\n\t\t\tfor (int i = 0; i < this.delegates.size() - 1; i++) {\n\t\t\t\ttry {\n\t\t\t\t\tConversionService delegate = this.delegates.get(i);\n\t\t\t\t\tif (delegate.canConvert(sourceType, targetType)) {\n\t\t\t\t\t\treturn delegate.convert(source, sourceType, targetType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcatch (ConversionException ex) {\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.delegates.get(this.delegates.size() - 1).convert(source,\n\t\t\t\t\tsourceType, targetType);\n\t\t}\n\t}\n\t/**\n\t * A {@link ConversionService} implementation that delegates to a\n\t * {@link SimpleTypeConverter}. Allows {@link PropertyEditor} based conversion for\n\t * simple types, arrays and collections.\n\t */\n\tprivate static class TypeConverterConversionService extends GenericConversionService {\n\t\tTypeConverterConversionService(Consumer<PropertyEditorRegistry> initializer) {\n\t\t\taddConverter(new TypeConverterConverter(createTypeConverter(initializer)));\n\t\t\tApplicationConversionService.addDelimitedStringConverters(this);\n\t\t}\n\t\tprivate SimpleTypeConverter createTypeConverter(\n\t\t\t\tConsumer<PropertyEditorRegistry> initializer) {\n\t\t\tSimpleTypeConverter typeConverter = new SimpleTypeConverter();\n\t\t\tif (initializer != null) {\n\t\t\t\tinitializer.accept(typeConverter);\n\t\t\t}\n\t\t\treturn typeConverter;\n\t\t}\n\t\t@Override\n\t\tpublic boolean canConvert(TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\t\t// Prefer conversion service to handle things like String to char[].\n\t\t\tif (targetType.isArray()\n\t\t\t\t\t&& targetType.getElementTypeDescriptor().isPrimitive()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn super.canConvert(sourceType, targetType);\n\t\t}\n\t}\n\t/**\n\t * {@link ConditionalGenericConverter} that delegates to {@link SimpleTypeConverter}.\n\t */\n\tprivate static class TypeConverterConverter implements ConditionalGenericConverter {\n\t\tprivate final SimpleTypeConverter typeConverter;\n\t\tTypeConverterConverter(SimpleTypeConverter typeConverter) {\n\t\t\tthis.typeConverter = typeConverter;\n\t\t}\n\t\t@Override\n\t\tpublic Set<ConvertiblePair> getConvertibleTypes() {\n\t\t\treturn Collections.singleton(new ConvertiblePair(String.class, Object.class));\n\t\t}\n\t\t@Override\n\t\tpublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\t\treturn getPropertyEditor(targetType.getType()) != null;\n\t\t}\n\t\t@Override\n\t\tpublic Object convert(Object source, TypeDescriptor sourceType,\n\t\t\t\tTypeDescriptor targetType) {\n\t\t\tSimpleTypeConverter typeConverter = this.typeConverter;\n\t\t\treturn typeConverter.convertIfNecessary(source, targetType.getType());\n\t\t}<fim_middle>// class below has no smell\n"}