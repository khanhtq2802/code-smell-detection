{"text": "<fim_prefix>/*\n * Copyright 2015 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.springframework.xd.dirt.job.dsl;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.Stack;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport org.w3c.dom.DOMImplementation;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NodeList;\nimport org.springframework.xd.dirt.stream.JobDefinitionRepository;\nimport org.springframework.xml.transform.StringResult;\n/**\n * The root AST node for any AST parsed from a job specification.\n *\n * Andy Clement\n */\npublic class JobSpecification extends AstNode {\n\t/**\n\t * The DSL text that was parsed to create this JobSpec.\n\t */\n\tprivate String jobDefinitionText;\n\t/**\n\t * The top level JobNode within this JobSpec.\n\t */\n\tprivate JobNode jobNode;\n\t/**\n\t * A list of jobs that were defined inline in the DSL text that was parsed\n\t * to create this Ast. Computed on first reference.\n\t */\n\tprivate List<JobDefinition> jobDefinitions;\n\t/**\n\t * Any arguments specified at the end of the DSL, e.g. --timeout\n\t */\n\tprivate ArgumentNode[] globalOptions;\n\tpublic JobSpecification(String jobDefinitionText, JobNode jobNode, ArgumentNode[] globalOptions) {\n\t\tsuper(jobNode == null ? 0 : jobNode.getStartPos(), jobNode == null ? 0 : jobNode.getEndPos());\n\t\tthis.jobDefinitionText = jobDefinitionText;\n\t\tthis.jobNode = jobNode;\n\t\tthis.globalOptions = globalOptions;\n\t}\n\tpublic Map<String, String> getGlobalOptionsMap() {\n\t\tif (globalOptions == null) {\n\t\t\treturn Collections.<String, String> emptyMap();\n\t\t}\n\t\tMap<String, String> optionsMap = new LinkedHashMap<String, String>();\n\t\tfor (ArgumentNode option : globalOptions) {\n\t\t\toptionsMap.put(option.getName(), option.getValue());\n\t\t}\n\t\treturn optionsMap;\n\t}\n\t@Override\n\tpublic String stringify(boolean includePositionInfo) {\n\t\tStringBuilder s = new StringBuilder();\n\t\ts.append(jobNode.stringify(includePositionInfo));\n\t\tif (globalOptions != null) {\n\t\t\tfor (ArgumentNode option : globalOptions) {\n\t\t\t\ts.append(\" \");\n\t\t\t\ts.append(option.stringify(includePositionInfo));\n\t\t\t}\n\t\t}\n\t\treturn s.toString();\n\t}\n\tpublic String getJobDefinitionText() {\n\t\treturn jobDefinitionText;\n\t}\n\tpublic JobNode getJobNode() {\n\t\treturn this.jobNode;\n\t}\n\t/**\n\t * A shortcut (avoiding traversing the tree) that returns the list\n\t * of all job definitions inlined somewhere in this AST. Computed\n\t * on demand.\n\t *\n\t * @return a list of inlined job definitions defined in this AST\n\t */\n\tpublic List<JobDefinition> getJobDefinitions() {\n\t\tif (jobDefinitions != null) {\n\t\t\treturn jobDefinitions;\n\t\t}\n\t\tJobDefinitionLocator jdl = new JobDefinitionLocator();\n\t\tjdl.accept(this);\n\t\tjobDefinitions = jdl.getJobDefinitions();\n\t\treturn jobDefinitions;\n\t}\n\t/**\n\t * A shortcut (avoiding traversing the tree) that returns the list\n\t * of all job references somewhere in this AST (references in\n\t * transitions do not count).\n\t *\n\t * @return a list of job references in this AST\n\t */\n\tpublic List<JobReference> getJobReferences() {\n\t\tJobReferenceLocator jrl = new JobReferenceLocator();\n\t\tjrl.accept(this);\n\t\treturn jrl.getJobReferences();\n\t}\n\t/**\n\t * Performs validation of the AST. Where the initial parse is about\n\t * checking the syntactic structure, validation is about checking more\n\t * semantic elements:<ul>\n\t * <li>Do the inline job definitions refer to valid job modules?\n\t * <li>Do the inline job definitions supply correct arguments?\n\t * <li>Do the job references point to valid job definitions?\n\t * </ul>\n\t * @param jobDefinitionRepository a repository to check job definitions against\n\t * @throws JobSpecificationException if validation fails\n\t */\n\tpublic void validate(JobDefinitionRepository jobDefinitionRepository) {\n\t\t// TODO validate the job references (this will be done at deploy time but we could do it earlier)\n\t}\n\t/**\n\t * @return this AST converted to a Graph form for display by Flo\n\t */\n\tpublic Graph toGraph() {\n\t\tGraphGeneratorVisitor ggv = new GraphGeneratorVisitor();\n\t\tggv.accept(this);\n\t\treturn ggv.getGraph();\n\t}\n\t/**\n\t * @param batchJobId the id that will be inserted into the XML document for the batch:job element\n\t * @return this AST converted to an XML form\n\t */\n\tpublic String toXML(String batchJobId) {\n\t\treturn toXML(batchJobId, false);\n\t}\n\t/**\n\t * @param batchJobId the id that will be inserted into the XML document for the batch:job element\n\t * @param prettyPrint determine if the XML should be human readable.\n\t * @return this AST converted to an XML form\n\t */\n\tpublic String toXML(String batchJobId, boolean prettyPrint) {\n\t\tXMLGeneratorVisitor xgv = new XMLGeneratorVisitor(batchJobId, prettyPrint);\n\t\txgv.accept(this);\n\t\treturn xgv.getXmlString();\n\t}\n\t/**\n\t * Basic visitor that simply collects up any inlined job definitions.\n\t */\n<fim_suffix>\tstatic class JobDefinitionLocator extends JobSpecificationVisitor<Object> {\n\t\tList<JobDefinition> jobDefinitions = new ArrayList<JobDefinition>();\n\t\tpublic List<JobDefinition> getJobDefinitions() {\n\t\t\treturn jobDefinitions;\n\t\t}\n\t\t@Override\n\t\tpublic Object walk(Object context, Flow sjs) {\n\t\t\tfor (JobNode jobNode : sjs.getSeries()) {\n\t\t\t\twalk(context, jobNode);\n\t\t\t}\n\t\t\treturn context;\n\t\t}\n\t\t@Override\n\t\tpublic Object walk(Object context, JobDefinition jd) {\n\t\t\tjobDefinitions.add(jd);\n\t\t\treturn context;\n\t\t}\n\t\t@Override\n\t\tpublic Object walk(Object context, JobReference jr) {\n\t\t\treturn context;\n\t\t}\n\t\t@Override\n\t\tpublic Object walk(Object context, Split pjs) {\n\t\t\tfor (JobNode jobNode : pjs.getSeries()) {\n\t\t\t\twalk(context, jobNode);\n\t\t\t}\n\t\t\treturn context;\n\t\t}\n\t}\n\t/**\n\t * Basic visitor that simply collects up any job references (*not* those named in transitions)\n\t */\n\tstatic class JobReferenceLocator extends JobSpecificationVisitor<Object> {\n\t\tList<JobReference> jobReferences = new ArrayList<JobReference>();\n\t\tpublic List<JobReference> getJobReferences() {\n\t\t\treturn jobReferences;\n\t\t}\n\t\t@Override\n\t\tpublic Object walk(Object context, Flow sjs) {\n\t\t\tfor (JobNode jobNode : sjs.getSeries()) {\n\t\t\t\twalk(context, jobNode);\n\t\t\t}\n\t\t\treturn context;\n\t\t}\n\t\t@Override\n\t\tpublic Object walk(Object context, JobDefinition jd) {\n\t\t\treturn context;\n\t\t}\n\t\t@Override\n\t\tpublic Object walk(Object context, JobReference jr) {\n\t\t\tjobReferences.add(jr);\n\t\t\treturn context;\n\t\t}\n\t\t@Override\n\t\tpublic Object walk(Object context, Split pjs) {\n\t\t\tfor (JobNode jobNode : pjs.getSeries()) {\n\t\t\t\twalk(context, jobNode);\n\t\t\t}\n\t\t\treturn context;\n\t\t}\n\t}\n\t/**<fim_middle>// class below is data class\n"}