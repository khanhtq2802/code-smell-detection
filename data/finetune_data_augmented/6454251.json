{"text": "<fim_prefix>\n<fim_suffix>public class SeekableXZInputStream extends SeekableInputStream {\n    /**\n     * Cache for big arrays.\n     */\n    private final ArrayCache arrayCache;\n    /**\n     * The input stream containing XZ compressed data.\n     */\n    private SeekableInputStream in;\n    /**\n     * Memory usage limit after the memory usage of the IndexDecoders have\n     * been substracted.\n     */\n    private final int memoryLimit;\n    /**\n     * Memory usage of the IndexDecoders.\n     * <code>memoryLimit + indexMemoryUsage</code> equals the original\n     * memory usage limit that was passed to the constructor.\n     */\n    private int indexMemoryUsage = 0;\n    /**\n     * List of IndexDecoders, one for each Stream in the file.\n     * The list is in reverse order: The first element is\n     * the last Stream in the file.\n     */\n    private final ArrayList<IndexDecoder> streams\n            = new ArrayList<IndexDecoder>();\n    /**\n     * Bitmask of all Check IDs seen.\n     */\n    private int checkTypes = 0;\n    /**\n     * Uncompressed size of the file (all Streams).\n     */\n    private long uncompressedSize = 0;\n    /**\n     * Uncompressed size of the largest XZ Block in the file.\n     */\n    private long largestBlockSize = 0;\n    /**\n     * Number of XZ Blocks in the file.\n     */\n    private int blockCount = 0;\n    /**\n     * Size and position information about the current Block.\n     * If there are no Blocks, all values will be <code>-1</code>.\n     */\n    private final BlockInfo curBlockInfo;\n    /**\n     * Temporary (and cached) information about the Block whose information\n     * is queried via <code>getBlockPos</code> and related functions.\n     */\n    private final BlockInfo queriedBlockInfo;\n    /**\n     * Integrity Check in the current XZ Stream. The constructor leaves\n     * this to point to the Check of the first Stream.\n     */\n    private Check check;\n    /**\n     * Flag indicating if the integrity checks will be verified.\n     */\n    private final boolean verifyCheck;\n    /**\n     * Decoder of the current XZ Block, if any.\n     */\n    private BlockInputStream blockDecoder = null;\n    /**\n     * Current uncompressed position.\n     */\n    private long curPos = 0;\n    /**\n     * Target position for seeking.\n     */\n    private long seekPos;\n    /**\n     * True when <code>seek(long)</code> has been called but the actual\n     * seeking hasn't been done yet.\n     */\n    private boolean seekNeeded = false;\n    /**\n     * True when end of the file was reached. This can be cleared by\n     * calling <code>seek(long)</code>.\n     */\n    private boolean endReached = false;\n    /**\n     * Pending exception from an earlier error.\n     */\n    private IOException exception = null;\n    /**\n     * Temporary buffer for read(). This avoids reallocating memory\n     * on every read() call.\n     */\n    private final byte[] tempBuf = new byte[1];\n    /**\n     * Creates a new seekable XZ decompressor without a memory usage limit.\n     *\n     * @param       in          seekable input stream containing one or more\n     *                          XZ Streams; the whole input stream is used\n     *\n     * @throws      XZFormatException\n     *                          input is not in the XZ format\n     *\n     * @throws      CorruptedInputException\n     *                          XZ data is corrupt or truncated\n     *\n     * @throws      UnsupportedOptionsException\n     *                          XZ headers seem valid but they specify\n     *                          options not supported by this implementation\n     *\n     * @throws      EOFException\n     *                          less than 6 bytes of input was available\n     *                          from <code>in</code>, or (unlikely) the size\n     *                          of the underlying stream got smaller while\n     *                          this was reading from it\n     *\n     * @throws      IOException may be thrown by <code>in</code>\n     */\n    public SeekableXZInputStream(SeekableInputStream in)\n            throws IOException {\n        this(in, -1);\n    }\n    /**\n     * Creates a new seekable XZ decompressor without a memory usage limit.\n     * <p>\n     * This is identical to\n     * <code>SeekableXZInputStream(SeekableInputStream)</code> except that\n     * this also takes the <code>arrayCache</code> argument.\n     *\n     * @param       in          seekable input stream containing one or more\n     *                          XZ Streams; the whole input stream is used\n     *\n     * @param       arrayCache  cache to be used for allocating large arrays\n     *\n     * @throws      XZFormatException\n     *                          input is not in the XZ format\n     *\n     * @throws      CorruptedInputException\n     *                          XZ data is corrupt or truncated\n     *\n     * @throws      UnsupportedOptionsException\n     *                          XZ headers seem valid but they specify\n     *                          options not supported by this implementation\n     *\n     * @throws      EOFException\n     *                          less than 6 bytes of input was available\n     *                          from <code>in</code>, or (unlikely) the size\n     *                          of the underlying stream got smaller while\n     *                          this was reading from it\n     *\n     * @throws      IOException may be thrown by <code>in</code>\n     *\n     * @since 1.7\n     */\n    public SeekableXZInputStream(SeekableInputStream in, ArrayCache arrayCache)\n            throws IOException {\n        this(in, -1, arrayCache);\n    }\n    /**\n     * Creates a new seekable XZ decomporessor with an optional\n     * memory usage limit.\n     *\n     * @param       in          seekable input stream containing one or more\n     *                          XZ Streams; the whole input stream is used\n     *\n     * @param       memoryLimit memory usage limit in kibibytes (KiB)\n     *                          or <code>-1</code> to impose no\n     *                          memory usage limit\n     *\n     * @throws      XZFormatException\n     *                          input is not in the XZ format\n     *\n     * @throws      CorruptedInputException\n     *                          XZ data is corrupt or truncated\n     *\n     * @throws      UnsupportedOptionsException\n     *                          XZ headers seem valid but they specify\n     *                          options not supported by this implementation\n     *\n     * @throws      MemoryLimitException\n     *                          decoded XZ Indexes would need more memory\n     *                          than allowed by the memory usage limit\n     *\n     * @throws      EOFException\n     *                          less than 6 bytes of input was available\n     *                          from <code>in</code>, or (unlikely) the size\n     *                          of the underlying stream got smaller while\n     *                          this was reading from it\n     *\n     * @throws      IOException may be thrown by <code>in</code>\n     */\n    public SeekableXZInputStream(SeekableInputStream in, int memoryLimit)\n            throws IOException {\n        this(in, memoryLimit, true);\n    }\n    /**\n     * Creates a new seekable XZ decomporessor with an optional\n     * memory usage limit.\n     * <p>\n     * This is identical to\n     * <code>SeekableXZInputStream(SeekableInputStream,int)</code>\n     * except that this also takes the <code>arrayCache</code> argument.\n     *\n     * @param       in          seekable input stream containing one or more\n     *                          XZ Streams; the whole input stream is used\n     *\n     * @param       memoryLimit memory usage limit in kibibytes (KiB)\n     *                          or <code>-1</code> to impose no\n     *                          memory usage limit\n     *\n     * @param       arrayCache  cache to be used for allocating large arrays\n     *\n     * @throws      XZFormatException\n     *                          input is not in the XZ format\n     *\n     * @throws      CorruptedInputException\n     *                          XZ data is corrupt or truncated\n     *\n     * @throws      UnsupportedOptionsException\n     *                          XZ headers seem valid but they specify\n     *                          options not supported by this implementation\n     *\n     * @throws      MemoryLimitException\n     *                          decoded XZ Indexes would need more memory\n     *                          than allowed by the memory usage limit\n     *\n     * @throws      EOFException\n     *                          less than 6 bytes of input was available\n     *                          from <code>in</code>, or (unlikely) the size\n     *                          of the underlying stream got smaller while\n     *                          this was reading from it\n     *\n     * @throws      IOException may be thrown by <code>in</code>\n     *\n     * @since 1.7\n     */\n    public SeekableXZInputStream(SeekableInputStream in, int memoryLimit,\n                                 ArrayCache arrayCache)\n            throws IOException {\n        this(in, memoryLimit, true, arrayCache);\n    }\n    /**\n     * Creates a new seekable XZ decomporessor with an optional\n     * memory usage limit and ability to disable verification\n     * of integrity checks.\n     * <p>\n     * Note that integrity check verification should almost never be disabled.\n     * Possible reasons to disable integrity check verification:\n     * <ul><fim_middle>// class below is blob\n"}