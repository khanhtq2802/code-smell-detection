{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.jackrabbit.oak.plugins.observation.filter;\n\nimport static org.apache.jackrabbit.oak.commons.PathUtils.elements;\n\nimport java.util.List;\n\nimport com.google.common.collect.Lists;\n\n<fim_suffix>public class GlobbingPathHelper {\n\n    /**\n     * Converts the provided path containing glob characters <code>*</code> \n     * and <code>**</code> into a regular expression. The definition matches \n     * that of the GlobbingPathFilter with the addition that this conversion\n     * also supports sub-paths which do not start with a <code>/</code>.\n     * <p>\n     * The rules are:\n     * <ul>\n     * <li>leading <code>**</code> matches <code>/foo</code> and <code>bar</code></li>\n     * <li>leading <code>/**</code> matches <code>/foo</code> but not <code>bar</code></li>\n     * <li>intermittent <code>**</code> matches zero or any number of path elements </li>\n     * <li>trailing <code>**</code> matches anything not ending with a <code>/</code></li>\n     * <li>single <code>*</code> matches anything except <code>/</code></li>\n     * <li><code>?</code> is not a special character</li>\n     * <li>anything not a star is wrapped into <code>\\Q...\\E</code> pairs</li>\n     * </ul>\n     * @param pathWithGlobs path that can contain * and **\n     * @return a regular expression\n     * @see GlobbingPathFilter\n     */\n    public static String globPathAsRegex(String pathWithGlobs) {\n        if (pathWithGlobs == null) {\n            return null;\n        } else if (!pathWithGlobs.contains(\"*\")) {\n            return pathWithGlobs;\n        }\n        List<String> elements = Lists.newLinkedList(elements(pathWithGlobs));\n        StringBuffer sb = new StringBuffer();\n        sb.append(\"\\\\Q\");\n        if (pathWithGlobs.startsWith(\"/\")) {\n            sb.append(\"/\");\n        }\n        if (elements.get(0).equals(\"**\")) {\n            sb.append(\"\\\\E[^/]*(/[^/]*)*\\\\Q\");\n            elements.remove(0);\n        }\n        int size = elements.size();\n        boolean endsWithStarStar = size == 0 ? false : elements.get(size - 1).equals(\"**\");\n        if (endsWithStarStar) {\n            elements.remove(size - 1);\n        }\n        boolean addSlash = false;\n        for(int i=0; i<elements.size(); i++) {\n            String pathElem = elements.get(i);\n            if (addSlash) {\n                sb.append(\"/\");\n            }\n            if (pathElem.equals(\"**\")) {\n                addSlash = false;\n                sb.append(\"\\\\E([^/]*/)*\\\\Q\");\n            } else {\n                sb.append(pathElem.replace(\"*\", \"\\\\E[^/]*\\\\Q\"));\n                addSlash = true;\n            }\n        }\n        if (endsWithStarStar) {\n            sb.append(\"\\\\E(/[^/]*)*\");\n        } else if (pathWithGlobs.endsWith(\"/\")) {\n            sb.append(\"/\\\\E\");\n        } else {\n            sb.append(\"\\\\E\");\n        }\n        return sb.toString();\n    }\n\n}<fim_middle>// class below is blob\n"}