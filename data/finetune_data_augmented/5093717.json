{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.mahout.math.set;\nimport java.nio.ByteBuffer;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Set;\nimport org.apache.mahout.math.MurmurHash;\nimport org.apache.mahout.math.function.ObjectProcedure;\nimport org.apache.mahout.math.map.PrimeFinder;\n/**\n  * Open hashing alternative to java.util.HashSet.\n **/\npublic class OpenHashSet<T> extends AbstractSet implements Set<T>  {\n  protected static final byte FREE = 0;\n  protected static final byte FULL = 1;\n  protected static final byte REMOVED = 2;\n  protected static final char NO_KEY_VALUE = 0;\n  /** The hash table keys. */\n  private Object[] table;\n  /** The state of each hash table entry (FREE, FULL, REMOVED). */\n  private byte[] state;\n  /** The number of table entries in state==FREE. */\n  private int freeEntries;\n  /** Constructs an empty map with default capacity and default load factors. */\n  public OpenHashSet() {\n    this(DEFAULT_CAPACITY);\n  }\n  /**\n   * Constructs an empty map with the specified initial capacity and default load factors.\n   *\n   * @param initialCapacity the initial capacity of the map.\n   * @throws IllegalArgumentException if the initial capacity is less than zero.\n   */\n  public OpenHashSet(int initialCapacity) {\n    this(initialCapacity, DEFAULT_MIN_LOAD_FACTOR, DEFAULT_MAX_LOAD_FACTOR);\n  }\n  /**\n   * Constructs an empty map with the specified initial capacity and the specified minimum and maximum load factor.\n   *\n   * @param initialCapacity the initial capacity.\n   * @param minLoadFactor   the minimum load factor.\n   * @param maxLoadFactor   the maximum load factor.\n   * @throws IllegalArgumentException if <tt>initialCapacity < 0 || (minLoadFactor < 0.0 || minLoadFactor >= 1.0) ||\n   *                                  (maxLoadFactor <= 0.0 || maxLoadFactor >= 1.0) || (minLoadFactor >=\n   *                                  maxLoadFactor)</tt>.\n   */\n  public OpenHashSet(int initialCapacity, double minLoadFactor, double maxLoadFactor) {\n    setUp(initialCapacity, minLoadFactor, maxLoadFactor);\n  }\n  /** Removes all values associations from the receiver. Implicitly calls <tt>trimToSize()</tt>. */\n<fim_suffix>  @Override\n  public void clear() {\n    Arrays.fill(this.state, 0, state.length - 1, FREE);\n    distinct = 0;\n    freeEntries = table.length; // delta\n    trimToSize();\n  }\n  /**\n   * Returns a deep copy of the receiver.\n   *\n   * @return a deep copy of the receiver.\n   */\n  @SuppressWarnings(\"unchecked\")\n  @Override\n  public Object clone() {\n    OpenHashSet<T> copy = (OpenHashSet<T>) super.clone();\n    copy.table = copy.table.clone();\n    copy.state = copy.state.clone();\n    return copy;\n  }\n  /**\n   * Returns <tt>true</tt> if the receiver contains the specified key.\n   *\n   * @return <tt>true</tt> if the receiver contains the specified key.\n   */\n  @Override\n  @SuppressWarnings(\"unchecked\")\n  public boolean contains(Object key) {\n    return indexOfKey((T)key) >= 0;\n  }\n  /**\n   * Ensures that the receiver can hold at least the specified number of associations without needing to allocate new\n   * internal memory. If necessary, allocates new internal memory and increases the capacity of the receiver. <p> This\n   * method never need be called; it is for performance tuning only. Calling this method before <tt>add()</tt>ing a\n   * large number of associations boosts performance, because the receiver will grow only once instead of potentially\n   * many times and hash collisions get less probable.\n   *\n   * @param minCapacity the desired minimum capacity.\n   */\n  @Override\n  public void ensureCapacity(int minCapacity) {\n    if (table.length < minCapacity) {\n      int newCapacity = nextPrime(minCapacity);\n      rehash(newCapacity);\n    }\n  }\n  /**\n   * Applies a procedure to each key of the receiver, if any. Note: Iterates over the keys in no particular order.\n   * Subclasses can define a particular order, for example, \"sorted by key\". All methods which <i>can</i> be expressed\n   * in terms of this method (most methods can) <i>must guarantee</i> to use the <i>same</i> order defined by this\n   * method, even if it is no particular order. This is necessary so that, for example, methods <tt>keys</tt> and\n   * <tt>values</tt> will yield association pairs, not two uncorrelated lists.\n   *\n   * @param procedure the procedure to be applied. Stops iteration if the procedure returns <tt>false</tt>, otherwise\n   *                  continues.\n   * @return <tt>false</tt> if the procedure stopped before all keys where iterated over, <tt>true</tt> otherwise.\n   */\n  @SuppressWarnings(\"unchecked\")\n  public boolean forEachKey(ObjectProcedure<T> procedure) {\n    for (int i = table.length; i-- > 0;) {\n      if (state[i] == FULL) {\n        if (!procedure.apply((T)table[i])) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n  /**\n   * @param key the key to be added to the receiver.\n   * @return the index where the key would need to be inserted, if it is not already contained. Returns -index-1 if the\n   *         key is already contained at slot index. Therefore, if the returned index < 0, then it is already contained\n   *         at slot -index-1. If the returned index >= 0, then it is NOT already contained and should be inserted at\n   *         slot index.\n   */\n  protected int indexOfInsertion(T key) {\n    Object[] tab = table;\n    byte[] stat = state;\n    int length = tab.length;\n    int hash = key.hashCode() & 0x7FFFFFFF;\n    int i = hash % length;\n    int decrement = hash % (length - 2); // double hashing, see http://www.eece.unm.edu/faculty/heileman/hash/node4.html\n    //int decrement = (hash / length) % length;\n    if (decrement == 0) {\n      decrement = 1;\n    }\n    // stop if we find a removed or free slot, or if we find the key itself\n    // do NOT skip over removed slots (yes, open addressing is like that...)\n    while (stat[i] == FULL && tab[i] != key) {\n      i -= decrement;\n      //hashCollisions++;\n      if (i < 0) {\n        i += length;\n      }\n    }\n    if (stat[i] == REMOVED) {\n      // stop if we find a free slot, or if we find the key itself.\n      // do skip over removed slots (yes, open addressing is like that...)\n      // assertion: there is at least one FREE slot.\n      int j = i;\n      while (stat[i] != FREE && (stat[i] == REMOVED || tab[i] != key)) {\n        i -= decrement;\n        //hashCollisions++;\n        if (i < 0) {\n          i += length;\n        }\n      }\n      if (stat[i] == FREE) {\n        i = j;\n      }\n    }\n    if (stat[i] == FULL) {\n      // key already contained at slot i.\n      // return a negative number identifying the slot.\n      return -i - 1;\n    }\n    // not already contained, should be inserted at slot i.\n    // return a number >= 0 identifying the slot.\n    return i;\n  }\n  /**\n   * @param key the key to be searched in the receiver.\n   * @return the index where the key is contained in the receiver, returns -1 if the key was not found.\n   */\n  protected int indexOfKey(T key) {\n    Object[] tab = table;\n    byte[] stat = state;\n    int length = tab.length;<fim_middle>// function below has no smell\n"}