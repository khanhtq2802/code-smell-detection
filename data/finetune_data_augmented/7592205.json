{"text": "<fim_prefix>package org.springframework.roo.metadata;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport org.apache.commons.lang3.ObjectUtils;\nimport org.apache.commons.lang3.Validate;\nimport org.apache.commons.lang3.builder.ToStringBuilder;\nimport org.apache.felix.scr.annotations.Component;\nimport org.apache.felix.scr.annotations.Reference;\nimport org.apache.felix.scr.annotations.ReferenceCardinality;\nimport org.apache.felix.scr.annotations.ReferencePolicy;\nimport org.apache.felix.scr.annotations.ReferenceStrategy;\nimport org.apache.felix.scr.annotations.Service;\nimport org.osgi.service.component.ComponentContext;\nimport org.springframework.roo.metadata.internal.AbstractMetadataCache;\nimport org.springframework.roo.metadata.internal.MetadataDependencyRegistryTracker;\n/**\n * Default implementation of {@link MetadataService}.\n * <p>\n * This implementation is not thread safe. It should only be accessed by a\n * single thread at a time. This is enforced by the process manager semantics,\n * so we avoid the cost of re-synchronization here.\n *\n * @author Ben Alex\n * @author Enrique Ruiz at DISID Corporation S.L.\n * @since 1.0\n */\n@Component\n@Service\n@Reference(name = \"metadataProvider\", strategy = ReferenceStrategy.EVENT,\n    policy = ReferencePolicy.DYNAMIC, referenceInterface = MetadataProvider.class,\n    cardinality = ReferenceCardinality.OPTIONAL_MULTIPLE)\npublic class DefaultMetadataService extends AbstractMetadataCache implements MetadataService {\n  @Reference\n  private MetadataLogger metadataLogger;\n  // Request control\n  // List to assist output \"stacks\"which show the order of requests\n  private final List<String> activeRequests = new ArrayList<String>();\n  private int cacheEvictions = 0;\n  private int cacheHits = 0;\n  private int cacheMisses = 0;\n  private int cachePuts = 0;\n  // List to help us verify correct operation through logs (predictable\n  // ordering)\n  private final List<String> keysToRetry = new ArrayList<String>();\n  // Mutex\n  private final Object lock = new Object();\n  private final Map<String, MetadataProvider> providerMap = new HashMap<String, MetadataProvider>();\n  private final Set<MetadataProvider> providers = new HashSet<MetadataProvider>();\n  private int recursiveGets = 0;\n  private int validGets = 0;\n  protected MetadataDependencyRegistryTracker registryTracker = null;\n  /**\n   * This service is being activated so setup it:\n   * <ul>\n   * <li>Create and open the {@link MetadataDependencyRegistryTracker}.</li>\n   * </ul>\n   */\n  protected void activate(final ComponentContext context) {\n    this.registryTracker = new MetadataDependencyRegistryTracker(context.getBundleContext(), this);\n    this.registryTracker.open();\n  }\n  /**\n   * This service is being deactivated so unregister upstream-downstream\n   * dependencies, triggers, matchers and listeners.\n   *\n   * @param context\n   */\n  protected void deactivate(final ComponentContext context) {\n    MetadataDependencyRegistry registry = this.registryTracker.getService();\n    registry.removeNotificationListener(this);\n    this.registryTracker.close();\n  }\n<fim_suffix>  protected void bindMetadataProvider(final MetadataProvider mp) {\n    synchronized (lock) {\n      Validate.notNull(mp, \"Metadata provider required\");\n      final String mid = mp.getProvidesType();\n      Validate.isTrue(MetadataIdentificationUtils.isIdentifyingClass(mid),\n          \"Metadata provider '%s' violated interface contract by returning '%s'\", mp, mid);\n      Validate.isTrue(!providerMap.containsKey(mid),\n          \"Metadata provider '%s' already is providing metadata for '%s'\", providerMap.get(mid),\n          mid);\n      providers.add(mp);\n      providerMap.put(mid, mp);\n    }\n  }\n  @Override\n  public void evict(final String metadataIdentificationString) {\n    synchronized (lock) {\n      // Clear my own cache (which also verifies the argument is valid at\n      // the same time)\n      super.evict(metadataIdentificationString);\n      // Finally, evict downstream dependencies (ie metadata that\n      // previously depended on this now-evicted metadata)\n      MetadataDependencyRegistry registry = this.registryTracker.getService();\n      for (final String downstream : registry.getDownstream(metadataIdentificationString)) {\n        // We only need to evict if it is an instance, as only an\n        // instance will ever go into the cache\n        if (MetadataIdentificationUtils.isIdentifyingInstance(downstream)) {\n          evict(downstream);\n        }\n      }\n    }\n  }\n  @Override\n  public void evictAll() {\n    synchronized (lock) {\n      // Clear my own cache\n      super.evictAll();\n      // Clear the caches of any metadata providers which support the\n      // interface\n      for (final MetadataProvider p : providers) {\n        if (p instanceof MetadataCache) {\n          ((MetadataCache) p).evictAll();\n        }\n      }\n    }\n  }\n  @SuppressWarnings(\"unchecked\")\n  public <T extends MetadataItem> T evictAndGet(final String metadataIdentificationString) {\n    return (T) getInternal(metadataIdentificationString, true, false);\n  }\n  @SuppressWarnings(\"unchecked\")\n  public <T extends MetadataItem> T get(final String metadataIdentificationString) {\n    return (T) get(metadataIdentificationString, false);\n  }\n  public MetadataItem get(final String metadataIdentificationString, final boolean evictCache) {\n    return getInternal(metadataIdentificationString, evictCache, true);\n  }\n  private MetadataItem getInternal(final String metadataIdentificationString,\n      final boolean evictCache, final boolean cacheRetrievalAllowed) {\n    Validate.isTrue(\n        MetadataIdentificationUtils.isIdentifyingInstance(metadataIdentificationString),\n        \"Metadata identification string '%s' does not identify a metadata instance\",\n        metadataIdentificationString);\n    synchronized (lock) {\n      validGets++;\n      try {\n        metadataLogger.startEvent();\n        // Do some cache eviction if the caller requested it\n        if (evictCache) {\n          evict(metadataIdentificationString);\n          if (metadataLogger.getTraceLevel() > 0) {\n            metadataLogger.log(\"Evicting \" + metadataIdentificationString);\n          }\n          cacheEvictions++;\n        }\n        // We can use the cache even for a recursive get (unless of\n        // course the caller has prevented it)\n        if (cacheRetrievalAllowed) {\n          // Try the cache first\n          final MetadataItem result = getFromCache(metadataIdentificationString);\n          if (result != null) {\n            cacheHits++;\n            if (metadataLogger.getTraceLevel() > 0) {\n              metadataLogger.log(\"Cache hit \" + metadataIdentificationString);\n            }\n            return result;\n          }\n        }\n        if (metadataLogger.getTraceLevel() > 0) {\n          metadataLogger.log(\"Cache miss \" + metadataIdentificationString);\n        }\n        cacheMisses++;\n        // Determine if this MID was already requested earlier. We need\n        // to stop these infinite requests from occurring.\n        if (activeRequests.contains(metadataIdentificationString)) {\n          recursiveGets++;\n          if (!keysToRetry.contains(metadataIdentificationString)) {\n            if (metadataLogger.getTraceLevel() > 0) {\n              metadataLogger.log(\"Blocked recursive request for \" + metadataIdentificationString);\n            }\n            keysToRetry.add(metadataIdentificationString);\n          }\n          return null;\n        }\n        // Get the destination\n        final String mdClassId =\n            MetadataIdentificationUtils.getMetadataClassId(metadataIdentificationString);\n        final MetadataProvider p = providerMap.get(mdClassId);\n        Validate\n            .notNull(\n                p,\n                \"No metadata provider is currently registered to provide metadata for identifier '%s' (class '%s')\",\n                metadataIdentificationString, mdClassId);\n        // Infinite loop management\n        activeRequests.add(metadataIdentificationString);\n        // Obtain the item\n        if (metadataLogger.getTraceLevel() > 0) {\n          metadataLogger.log(\"Get \" + metadataIdentificationString + \" from \"\n              + p.getClass().getName());\n        }\n        MetadataItem result = null;\n        try {\n          metadataLogger.startTimer(p.getClass().getName());\n          result = p.get(metadataIdentificationString);\n        } finally {\n          metadataLogger.stopTimer();\n        }\n        // If the item isn't available, evict it from the cache (unless\n        // we did so at the start of the method already)\n        if (result == null && !evictCache) {\n          if (metadataLogger.getTraceLevel() > 0) {\n            metadataLogger.log(\"Evicting unavailable item \" + metadataIdentificationString);\n          }\n          evict(metadataIdentificationString);\n          cacheEvictions++;\n        }\n        // Put into the cache, provided it isn't null\n        if (result != null) {\n          if (metadataLogger.getTraceLevel() > 0) {\n            metadataLogger.log(\"Caching \" + metadataIdentificationString);\n          }\n          super.put(result);\n          cachePuts++;\n        }\n        activeRequests.remove(metadataIdentificationString);<fim_middle>// function below has no smell\n"}