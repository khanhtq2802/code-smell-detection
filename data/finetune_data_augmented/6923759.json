{"text": "<fim_prefix>/* Copyright (c) 2008 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.gdata.util.common.base;\nimport java.io.BufferedReader;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.StringWriter;\nimport java.io.UnsupportedEncodingException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n/**\n * Some common string manipulation utilities.\n */\npublic class StringUtil {\n  public static final String EMPTY_STRING = \"\";\n  // \\u3000 is the double-byte space character in UTF-8\n  // \\u00A0 is the non-breaking space character (&nbsp;)\n  // \\u2007 is the figure space character (&#8199;)\n  // \\u202F is the narrow non-breaking space character (&#8239;)\n  public static final String WHITE_SPACES = \" \\r\\n\\t\\u3000\\u00A0\\u2007\\u202F\";\n  public static final String LINE_BREAKS = \"\\r\\n\";\n  private static final Pattern htmlTagPattern =\n    Pattern.compile(\"</?[a-zA-Z][^>]*>\");\n  private static final Pattern characterReferencePattern =\n    Pattern.compile(\"&#?[a-zA-Z0-9]{1,8};\");\n  private static final Pattern dbSpecPattern =\n    Pattern.compile(\"(.*)\\\\{(\\\\d+),(\\\\d+)\\\\}(.*)\");\n  // This class should not be instantiated, hence the private constructor\n  private StringUtil() {}\n  /** Split \"str\" by run of delimiters and return. */\n  public static String[] split(String str, String delims) {\n    return split(str, delims, false);\n  }\n  /**\n   * Split \"str\" into tokens by delimiters and optionally remove white spaces\n   * from the splitted tokens.\n   *\n   * @param trimTokens if true, then trim the tokens\n   */\n  public static String[] split(String str, String delims, boolean trimTokens) {\n    StringTokenizer tokenizer = new StringTokenizer(str, delims);\n    int n = tokenizer.countTokens();\n    String[] list = new String[n];\n    for (int i = 0; i < n; i++) {\n      if (trimTokens) {\n        list[i] = tokenizer.nextToken().trim();\n      } else {\n        list[i] = tokenizer.nextToken();\n      }\n    }\n    return list;\n  }\n  /**\n   * Short hand for <code>split(str, delims, true)</code>\n   */\n  public static String[] splitAndTrim(String str, String delims) {\n    return split(str, delims, true);\n  }\n  /** Parse comma-separated list of ints and return as array. */\n  public static int[] splitInts(String str) throws IllegalArgumentException {\n    StringTokenizer tokenizer = new StringTokenizer(str, \",\");\n    int n = tokenizer.countTokens();\n    int[] list = new int[n];\n    for (int i = 0; i < n; i++) {\n      String token = tokenizer.nextToken();\n      list[i] = Integer.parseInt(token);\n    }\n    return list;\n  }\n  /** Parse comma-separated list of longs and return as array. */\n  public static long[] splitLongs(String str) throws IllegalArgumentException {\n    StringTokenizer tokenizer = new StringTokenizer(str, \",\");\n    int n = tokenizer.countTokens();\n    long[] list = new long[n];\n    for (int i = 0; i < n; i++) {\n      String token = tokenizer.nextToken();\n      list[i] = Long.parseLong(token);\n    }\n    return list;\n  }\n  /**\n   * Concatenates the given int[] array into one String, inserting a delimiter\n   * between each pair of elements.\n   */\n  public static String joinInts(int[] tokens, String delimiter) {\n    if (tokens == null) return \"\";\n    StringBuilder result = new StringBuilder();\n    for (int i = 0; i < tokens.length; i++) {\n      if (i > 0 && delimiter != null) {\n        result.append(delimiter);\n      }\n      result.append(String.valueOf(tokens[i]));\n    }\n    return result.toString();\n  }\n  /**\n   * Concatenates the given long[] array into one String, inserting a delimiter\n   * between each pair of elements.\n   */\n<fim_suffix>  public static String joinLongs(long[] tokens, String delimiter) {\n    if (tokens == null) return \"\";\n    StringBuilder result = new StringBuilder();\n    for (int i = 0; i < tokens.length; i++) {\n      if (i > 0 && delimiter != null) {\n        result.append(delimiter);\n      }\n      result.append(String.valueOf(tokens[i]));\n    }\n    return result.toString();\n  }\n  /**\n   * Concatenates the String representations of the elements of a\n   * String[] array into one String, and inserts a delimiter between\n   * each pair of elements.\n   * <p>\n   * This includes the String[] case, because if s is a String, then\n   * s.toString() returns s.\n   *\n   * @deprecated Please use\n   *     But note that {@code Join} does not consider null elements to be\n   *     equivalent to the empty string, as this method does.\n   */\n  @Deprecated public static String join(Object[] tokens, String delimiter) {\n    if (tokens == null || tokens.length == 0) return \"\";\n    StringBuilder result = new StringBuilder();\n    for (int i = 0; i < tokens.length; i++) {\n      if (i > 0 && delimiter != null)\n        result.append(delimiter);\n      if (tokens[i] != null)\n        result.append(tokens[i].toString());\n      }\n    return result.toString();\n  }\n  /**\n   * Same as {@link #join(Object[],String)}, but takes a {@link Collection}\n   * instead.\n   *\n   * @deprecated Please use\n   *     But note that {@code Join} does not consider null elements to be\n   *     equivalent to the empty string, as this method does.\n   */\n  @Deprecated public static String join(Collection tokens, String delimiter) {\n    return join(tokens.toArray(), delimiter);\n  }\n  /** This replaces the occurances of 'what' in 'str' with 'with'\n   * @param str - the string o process\n   * @param what - to replace\n   * @param with - replace with this\n   * @return String str whete 'what' was repalced with 'with'\n   *\n   * @deprecated Please use {@link String#replace(CharSequence, CharSequence)}.\n   */\n  @Deprecated\n  public static String replace(String str, String what, String with) {\n    // Have to check this argument, for compatibility with the old impl.\n    // For the record, String.replace() is capable of handling an empty target\n    // string... but it does something kind of weird in that case.\n    assert(what.length() > 0);\n    return str.replace(what, with);\n  }\n  /**\n   * Reformats the given string to a fixed width by inserting\n   * carriage returns and trimming unnecessary whitespace.\n   *\n   * @param str the string to format\n   * @param width the fixed width (in characters)\n   */\n  public static String fixedWidth(String str, int width) {\n    String[] lines = split(str, \"\\n\");\n    return fixedWidth(lines, width);\n  }\n  /**\n   * Reformats the given array of lines to a fixed width by inserting\n   * carriage returns and trimming unnecessary whitespace.\n   *\n   * @param lines - array of lines to format\n   * @param width - the fixed width (in characters)\n   */\n  public static String fixedWidth(String[] lines, int width) {\n    StringBuilder formatStr = new StringBuilder();\n    for (int i = 0; i < lines.length; i++) {\n      int curWidth = 0;\n      if (i != 0) {<fim_middle>// function below has no smell\n"}