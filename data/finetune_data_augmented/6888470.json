{"text": "<fim_prefix>/*\n * Copyright (c) 2001, 2016, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage jdk.javadoc.internal.doclets.toolkit.util;\nimport java.util.*;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.PackageElement;\nimport javax.lang.model.element.TypeElement;\nimport jdk.javadoc.internal.doclets.toolkit.Configuration;\n/**\n * This class acts as an artificial container for classes specified on the command line when\n * running Javadoc. For example, if you specify several classes from package java.lang, this class\n * will catalog those classes so that we can retrieve all of the classes from a particular package\n * later.\n *\n * <p>\n * <b>This is NOT part of any supported API. If you write code that depends on this, you do so at\n * your own risk. This code and its internal interfaces are subject to change or deletion without\n * notice.</b>\n *\n * @author Jamie Ho\n */\npublic class TypeElementCatalog {\n    /**\n     * Stores the set of packages that the classes specified on the command line belong to. Note\n     * that the default package is \"\".\n     */\n    private final SortedSet<PackageElement> packageSet;\n    /**\n     * Stores all classes for each package\n     */\n    private final Map<PackageElement, SortedSet<TypeElement>> allClasses;\n    /**\n     * Stores ordinary classes (excluding Exceptions and Errors) for each package\n     */\n    private final Map<PackageElement, SortedSet<TypeElement>> ordinaryClasses;\n    /**\n     * Stores exceptions for each package\n     */\n    private final Map<PackageElement, SortedSet<TypeElement>> exceptions;\n    /**\n     * Stores enums for each package.\n     */\n    private final Map<PackageElement, SortedSet<TypeElement>> enums;\n    /**\n     * Stores annotation types for each package.\n     */\n    private final Map<PackageElement, SortedSet<TypeElement>> annotationTypes;\n    /**\n     * Stores errors for each package\n     */\n    private final Map<PackageElement, SortedSet<TypeElement>> errors;\n    /**\n     * Stores interfaces for each package\n     */\n    private final Map<PackageElement, SortedSet<TypeElement>> interfaces;\n    private final Configuration configuration;\n    private final Utils utils;\n    private final Comparator<Element> comparator;\n    /**\n     * Construct a new TypeElementCatalog.\n     *\n     * @param typeElements the array of TypeElements to catalog\n     */\n<fim_suffix>    public TypeElementCatalog(Iterable<TypeElement> typeElements, Configuration config) {\n        this(config);\n        for (TypeElement typeElement : typeElements) {\n            addTypeElement(typeElement);\n        }\n    }\n    /**\n     * Construct a new TypeElementCatalog.\n     *\n     */\n    public TypeElementCatalog(Configuration config) {\n        this.configuration = config;\n        this.utils = config.utils;\n        comparator = utils.makeGeneralPurposeComparator();\n        allClasses = new HashMap<>();\n        ordinaryClasses = new HashMap<>();\n        exceptions = new HashMap<>();\n        enums = new HashMap<>();\n        annotationTypes = new HashMap<>();\n        errors = new HashMap<>();\n        interfaces = new HashMap<>();\n        packageSet = new TreeSet<>(comparator);\n    }\n    /**\n     * Add the given class to the catalog.\n     *\n     * @param typeElement the TypeElement to add to the catalog.\n     */\n    public final void addTypeElement(TypeElement typeElement) {\n        if (typeElement == null) {\n            return;\n        }\n        addTypeElement(typeElement, allClasses);\n        if (utils.isOrdinaryClass(typeElement)) {\n            addTypeElement(typeElement, ordinaryClasses);\n        } else if (utils.isException(typeElement)) {\n            addTypeElement(typeElement, exceptions);\n        } else if (utils.isEnum(typeElement)) {\n            addTypeElement(typeElement, enums);\n        } else if (utils.isAnnotationType(typeElement)) {\n            addTypeElement(typeElement, annotationTypes);\n        } else if (utils.isError(typeElement)) {\n            addTypeElement(typeElement, errors);\n        } else if (utils.isInterface(typeElement)) {\n            addTypeElement(typeElement, interfaces);\n        }\n    }\n    /**\n     * Add the given class to the given map.\n     *\n     * @param typeElement the class to add to the catalog.\n     * @param map the Map to add the TypeElement to.\n     */\n    private void addTypeElement(TypeElement typeElement, Map<PackageElement, SortedSet<TypeElement>> map) {\n        PackageElement pkg = utils.containingPackage(typeElement);\n        if (utils.isSpecified(pkg) || configuration.nodeprecated && utils.isDeprecated(pkg)) {\n            // No need to catalog this class if it's package is\n            // specified on the command line or if -nodeprecated option is set\n            return;\n        }\n        SortedSet<TypeElement> s = map.get(pkg);\n        if (s == null) {\n            packageSet.add(pkg);\n            s = new TreeSet<>(comparator);\n        }\n        s.add(typeElement);\n        map.put(pkg, s);\n    }\n    private SortedSet<TypeElement> getSet(Map<PackageElement, SortedSet<TypeElement>> m, PackageElement key) {\n        SortedSet<TypeElement> s = m.get(key);\n        if (s != null) {\n            return s;\n        }\n        return new TreeSet<>(comparator);\n    }\n    /**\n     * Return all of the classes specified on the command-line that belong to the given package.\n     *\n     * @param packageElement the package to return the classes for.\n     */\n    public SortedSet<TypeElement> allClasses(PackageElement packageElement) {\n        return utils.isSpecified(packageElement)\n                ? utils.getTypeElementsAsSortedSet(utils.getEnclosedTypeElements(packageElement))\n                : getSet(allClasses, packageElement);\n    }\n    /**\n     * Return all of the classes specified on the command-line that belong to the given package.\n     *\n     * @param packageName the name of the package specified on the command-line.\n     */\n    public SortedSet<TypeElement> allUnnamedClasses() {\n        for (PackageElement pkg : allClasses.keySet()) {\n            if (pkg.isUnnamed()) {\n                return allClasses.get(pkg);\n            }\n        }\n        return new TreeSet<>(comparator);\n    }\n    /**\n     * Return a SortedSet of packages that this catalog stores.\n     */\n    public SortedSet<PackageElement> packages() {\n         return packageSet;\n    }\n    /**\n     * Return all of the errors specified on the command-line that belong to the given package.\n     *\n     * @param packageName the name of the package specified on the command-line.\n     */\n    public SortedSet<TypeElement> errors(PackageElement pkg) {\n        return getSet(errors, pkg);\n    }\n    /**\n     * Return all of the exceptions specified on the command-line that belong to the given package.\n     *\n     * @param packageName the name of the package specified on the command-line.\n     */\n    public SortedSet<TypeElement> exceptions(PackageElement pkg) {\n        return getSet(exceptions, pkg);\n    }\n    /**\n     * Return all of the enums specified on the command-line that belong to the given package.\n     *\n     * @param packageName the name of the package specified on the command-line.\n     */\n    public SortedSet<TypeElement> enums(PackageElement pkg) {\n        return getSet(enums, pkg);\n    }\n    /**\n     * Return all of the annotation types specified on the command-line that belong to the given\n     * package.\n     *\n     * @param packageName the name of the package specified on the command-line.\n     */\n    public SortedSet<TypeElement> annotationTypes(PackageElement pkg) {\n        return getSet(annotationTypes, pkg);\n    }\n    /**\n     * Return all of the interfaces specified on the command-line that belong to the given package.\n     *\n     * @param packageName the name of the package specified on the command-line.\n     */<fim_middle>// function below has no smell\n"}