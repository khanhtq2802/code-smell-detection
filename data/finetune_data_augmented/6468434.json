{"text": "<fim_prefix>\t\t\tthrow propagateIOException(\"Could not create a valid ImageFactory\"); //$NON-NLS-1$\n\t\t}\n\t\treturn factory.getImage(imageFile);\n\t}\n\t/**\n\t * Output any exception messages encountered during processing and the full exception to the\n\t * logger\n\t */\n\tprivate void printExceptions() {\n\t\tif (0 == exceptions.size()) {\n\t\t\treturn; //nothing went wrong\n\t\t}\n\t\tlog.fine(\"Warning : errors encountered whilst creating ImageFactory\"); //$NON-NLS-1$\n\t\tfor (int i = 0; i < exceptions.size(); i++) {\n\t\t\tObject obj = exceptions.get(i);\n\t\t\tif (obj instanceof Exception) {\n\t\t\t\tException e = (Exception) obj;\n\t\t\t\tlog.log(Level.FINE, e.getMessage(), e); //write to log if turned on\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * Throw an IOException unless we have already hit one and only one while\n\t * trying to open a dump in which case throw that to give the caller a\n\t * bit more information.\n\t * \n\t * This method will always throw an IOException and never returns normally.\n\t * \n\t * @param newExceptionMessage\n\t * @throws IOException\n\t */\n\tprivate IOException propagateIOException(String newExceptionMessage) throws IOException {\n\t\tif (exceptions.size() == 1 && exceptions.get(0) instanceof IOException) {\n\t\t\tthrow (IOException) exceptions.get(0);\n\t\t} else {\n\t\t\tthrow new IOException(newExceptionMessage);\n\t\t}\n\t}\n\t/**\n\t * Attempt to create an image and check for the presence of a Java runtime\n\t * @param imageFile\n\t * @param metadata\n\t * @return true if this image should be used as a return value\n\t */\n\tprivate boolean foundImage(String className, ImageReference imageReference, File imageFile, File metadata) {\n\t\ttry {\n\t\t\tcom.ibm.dtfj.image.ImageFactory _factory = createImageFactory(className);\n\t\t\tif (null == _factory) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\timageReference.image = (metadata == null) ? _factory.getImage(imageFile) : _factory.getImage(imageFile,\n\t\t\t\t\tmetadata);\n\t\t\tboolean foundRuntime = hasJavaRuntime(imageReference);\n\t\t\tif (!foundRuntime && (imageReference.image != null)) {\n\t\t\t\t//close and release resources used whilst detecting the image\n\t\t\t\timageReference.image.close();\n\t\t\t}\n\t\t\treturn foundRuntime;\n\t\t} catch (Exception e) {\n\t\t\texceptions.add(e); //log the exception\n\t\t}\n\t\treturn false; //return unable to create image\n\t}\n\t/**\n\t * Attempt to create an image and check for the presence of a Java runtime\n\t * @param imageFile\n\t * @param metadata\n\t * @return true if this image should be used as a return value\n\t */\n\tprivate boolean foundRuntimeInImage(String className, ImageReference imageReference, URI source, ImageInputStream in, ImageInputStream metadata) {\n\t\ttry {\n\t\t\tcom.ibm.dtfj.image.ImageFactory _factory = createImageFactory(className);\n\t\t\tif (null == _factory) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\timageReference.image = (metadata == null) ? _factory.getImage(in, source) : _factory.getImage(in, metadata, source);\n\t\t\treturn hasJavaRuntime(imageReference);\n\t\t} catch (Exception e) {\n\t\t\texceptions.add(e); //log the exception\n\t\t}\n\t\treturn false; //return unable to create image\n\t}\n\tprivate com.ibm.dtfj.image.ImageFactory createImageFactory(String className) {\n\t\tif (imageFactoryClassLoader == null) {\n\t\t\tinitClassLoader();\n\t\t}\n\t\ttry {\n\t\t\tClass<?> clazz = Class.forName(className, true, imageFactoryClassLoader);\n\t\t\tObject obj = clazz.newInstance();\n\t\t\tif (obj instanceof com.ibm.dtfj.image.ImageFactory) {\n\t\t\t\treturn (com.ibm.dtfj.image.ImageFactory) obj;\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\texceptions.add(e);\n\t\t}\n\t\treturn null;\n\t}\n\t/**\n\t * Checks to see if the supplied image has an available DTFJ Java Runtime. This is to force the parsing of the jextract XML\n\t * for legacy DTFJ and blob parsing for DDR. It does not make any guarantees about the quality and availability of the \n\t * run time data.\n\t * @return true if a non-corrupt runtime is returned\n\t */\n\tprivate static boolean hasJavaRuntime(ImageReference imageReference) {\n\t\tif (null == imageReference || null == imageReference.image) {\n\t\t\treturn false;\n\t\t}\n\t\tIterator<?> spaces = imageReference.image.getAddressSpaces();\n\t\twhile ((null != spaces) && spaces.hasNext()) { //search address spaces\n\t\t\tObject obj = spaces.next();\n\t\t\tif ((null != obj) && (obj instanceof ImageAddressSpace)) {\n\t\t\t\tImageAddressSpace space = (ImageAddressSpace) obj;\n\t\t\t\tIterator<?> procs = space.getProcesses();\n\t\t\t\twhile ((null != procs) && procs.hasNext()) { //search processes\n\t\t\t\t\tObject procobj = procs.next();\n\t\t\t\t\tif ((null != procobj) && (procobj instanceof ImageProcess)) {\n\t\t\t\t\t\tImageProcess proc = (ImageProcess) procobj;\n\t\t\t\t\t\tIterator<?> runtimes = proc.getRuntimes();\n\t\t\t\t\t\twhile ((null != runtimes) && runtimes.hasNext()) {\n\t\t\t\t\t\t\tObject rtobj = runtimes.next();\n\t\t\t\t\t\t\tif ((null != rtobj) && (rtobj instanceof JavaRuntime)) {\n\t\t\t\t\t\t\t\treturn true; //found a non-corrupt java runtime\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t/* (non-Javadoc)\n\t * @see com.ibm.dtfj.image.ImageFactory#getDTFJMajorVersion()\n\t */\n\t@Override\n\tpublic int getDTFJMajorVersion() {\n\t\treturn DTFJ_MAJOR_VERSION;\n\t}\n\t/* (non-Javadoc)\n\t * @see com.ibm.dtfj.image.ImageFactory#getDTFJMinorVersion()\n\t */\n\t@Override\n\tpublic int getDTFJMinorVersion() {\n\t\treturn DTFJ_MINOR_VERSION;\n\t}\n\t/* (non-Javadoc)\n\t * @see com.ibm.dtfj.image.ImageFactory#getDTFJModificationLevel()\n\t */\n\t@Override\n\tpublic int getDTFJModificationLevel() {\n\t\t// modification level is VM stream plus historically the tag from RAS_Auto-Build/projects.psf - now just a number\n\t\treturn 29003;\n\t}\n\tprivate void initClassLoader() {\n\t\t// add all JAR files in the DDR directory to class path\n\t\t// use property com.ibm.java.diagnostics.ddr.home if set, otherwise {java.home}/lib/ddr\n\t\tFile ddrDir = null;\n\t\tString ddrHome = System.getProperty(\"com.ibm.java.diagnostics.ddr.home\"); //$NON-NLS-1$\n\t\tif (ddrHome != null) {\n\t\t\tddrDir = new File(ddrHome);\n\t\t} else {\n\t\t\tddrDir = new File(System.getProperty(\"java.home\", \"\"), \"lib/ddr\"); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$\n\t\t}\n\t\tif (ddrDir.isDirectory()) {\n\t\t\tFile[] jarFiles = null;\n\t\t\tFilenameFilter jarFilter = new JarFilter();\n\t\t\tjarFiles = ddrDir.listFiles(jarFilter);\n\t\t\tURL[] urls = new URL[jarFiles.length];\n\t\t\tfor (int i = 0; i < jarFiles.length; i++) {\n\t\t\t\ttry {\n\t\t\t\t\turls[i] = jarFiles[i].toURI().toURL();\n\t\t\t\t} catch (MalformedURLException e) {\n\t\t\t\t\texceptions.add(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\timageFactoryClassLoader = new URLClassLoader(urls, getClass().getClassLoader());\n\t\t} else {\n\t\t\t// Don't leave this as null as null is the bootstrap class loader.\n\t\t\timageFactoryClassLoader = getClass().getClassLoader();\n\t\t}\n\t}\n<fim_suffix>\tprivate static final class JarFilter implements FilenameFilter {\n\t\tJarFilter() {\n\t\t\tsuper();\n\t\t}\n\t\t@Override\n\t\tpublic boolean accept(File dir, String name) {\n\t\t\t// accept JAR files *.jar only\n\t\t\treturn name.regionMatches(true, name.length() - 4, \".jar\", 0, 4); //$NON-NLS-1$\n\t\t}\n\t}<fim_middle>// class below has no smell\n"}