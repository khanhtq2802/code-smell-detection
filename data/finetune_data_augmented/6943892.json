{"text": "<fim_prefix>/*\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *\u00a0 \u00a0 http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage io.mattcarroll.hover;\nimport android.content.Context;\nimport android.content.SharedPreferences;\nimport android.content.res.TypedArray;\nimport android.os.Parcel;\nimport android.os.Parcelable;\nimport android.support.annotation.NonNull;\nimport android.support.annotation.Nullable;\nimport android.util.AttributeSet;\nimport android.util.Log;\nimport android.view.KeyEvent;\nimport android.view.ViewConfiguration;\nimport android.widget.RelativeLayout;\nimport java.util.Set;\nimport java.util.concurrent.CopyOnWriteArraySet;\nimport io.mattcarroll.hover.view.InViewDragger;\nimport io.mattcarroll.hover.window.InWindowDragger;\nimport io.mattcarroll.hover.window.WindowViewController;\nimport static io.mattcarroll.hover.SideDock.SidePosition.LEFT;\n/**\n * {@code HoverMenuView} is a floating menu implementation. This implementation displays tabs along\n * the top of its display, from right to left. Below the tabs, filling the remainder of the display\n * is a content region that displays the content for a selected tab.  The content region includes\n * a visual indicator showing which tab is currently selected.  Each tab's content includes a title\n * and a visual area.  The visual area can display any {@link Content}.\n */\npublic class HoverView extends RelativeLayout {\n    private static final String TAG = \"HoverView\";\n    private static final String PREFS_FILE = \"hover\";\n    private static final String SAVED_STATE_DOCK_POSITION = \"_dock_position\";\n    private static final String SAVED_STATE_DOCKS_SIDE = \"_dock_side\";\n    private static final String SAVED_STATE_SELECTED_SECTION = \"_selected_section\";\n    @NonNull\n    public static HoverView createForWindow(@NonNull Context context,\n                                            @NonNull WindowViewController windowViewController) {\n        return createForWindow(context, windowViewController, null);\n    }\n    @NonNull\n    public static HoverView createForWindow(@NonNull Context context,\n                                            @NonNull WindowViewController windowViewController,\n                                            @Nullable SideDock.SidePosition initialDockPosition) {\n        Dragger dragger = createWindowDragger(context, windowViewController);\n        return new HoverView(context, dragger, windowViewController, initialDockPosition);\n    }\n    @NonNull\n    private static Dragger createWindowDragger(@NonNull Context context,\n                                               @NonNull WindowViewController windowViewController) {\n        int touchDiameter = context.getResources().getDimensionPixelSize(R.dimen.hover_exit_radius);\n        int slop = ViewConfiguration.get(context).getScaledTouchSlop();\n        return new InWindowDragger(\n                context,\n                windowViewController,\n                touchDiameter,\n                slop\n        );\n    }\n    @NonNull\n    public static HoverView createForView(@NonNull Context context) {\n        return new HoverView(context, null);\n    }\n    final HoverViewState mClosed = new HoverViewStateClosed();\n    final HoverViewState mCollapsed = new HoverViewStateCollapsed();\n    final HoverViewState mExpanded = new HoverViewStateExpanded();\n    final WindowViewController mWindowViewController;\n    final Dragger mDragger;\n    final Screen mScreen;\n    HoverViewState mState;\n    HoverMenu mMenu;\n    HoverMenu.SectionId mSelectedSectionId;\n    SideDock mCollapsedDock;\n    boolean mIsAddedToWindow;\n    boolean mIsTouchableInWindow;\n    boolean mIsDebugMode = false;\n    int mTabSize;\n    OnExitListener mOnExitListener;\n    final Set<Listener> mListeners = new CopyOnWriteArraySet<>();\n    // Public for use with XML inflation. Clients should use static methods for construction.\n    public HoverView(@NonNull Context context, @Nullable AttributeSet attrs) {\n        super(context, attrs);\n        mDragger = createInViewDragger(context);\n        mScreen = new Screen(this);\n        mWindowViewController = null;\n        init();\n        if (null != attrs) {\n            applyAttributes(attrs);\n        }\n    }\n    @NonNull\n    private Dragger createInViewDragger(@NonNull Context context) {\n        int touchDiameter = context.getResources().getDimensionPixelSize(R.dimen.hover_exit_radius);\n        int slop = ViewConfiguration.get(context).getScaledTouchSlop();\n        return new InViewDragger(\n                this,\n                touchDiameter,\n                slop\n        );\n    }\n    private HoverView(@NonNull Context context,\n                      @NonNull Dragger dragger,\n                      @Nullable WindowViewController windowViewController,\n                      @Nullable SideDock.SidePosition initialDockPosition) {\n        super(context);\n        mDragger = dragger;\n        mScreen = new Screen(this);\n        mWindowViewController = windowViewController;\n        init();\n        if (null != initialDockPosition) {\n            mCollapsedDock = new SideDock(\n                    this,\n                    mTabSize,\n                    initialDockPosition\n            );\n        }\n    }\n<fim_suffix>    private void applyAttributes(@NonNull AttributeSet attrs) {\n        TypedArray a = getContext().obtainStyledAttributes(attrs, R.styleable.HoverView);\n        try {\n            createCollapsedDockFromAttrs(a);\n        } finally {\n            a.recycle();\n        }\n    }\n    private void createCollapsedDockFromAttrs(@NonNull TypedArray a) {\n        int tabSize = getResources().getDimensionPixelSize(R.dimen.hover_tab_size);\n        @SideDock.SidePosition.Side\n        int dockSide = a.getInt(R.styleable.HoverView_dockSide, LEFT);\n        float dockPosition = a.getFraction(R.styleable.HoverView_dockPosition, 1, 1, 0.5f);\n        SideDock.SidePosition sidePosition = new SideDock.SidePosition(dockSide, dockPosition);\n        mCollapsedDock = new SideDock(\n                this,\n                tabSize,\n                sidePosition\n        );\n    }\n    private void init() {\n        mTabSize = getResources().getDimensionPixelSize(R.dimen.hover_tab_size);\n        restoreVisualState();\n        setFocusableInTouchMode(true); // For handling hardware back button presses.\n        setState(new HoverViewStateClosed());\n    }\n    @Override\n    public boolean dispatchKeyEventPreIme(KeyEvent event) {\n        // Intercept the hardware back button press if needed. When it's pressed, we'll collapse.\n        if (mState.respondsToBackButton() && KeyEvent.KEYCODE_BACK == event.getKeyCode()) {\n            KeyEvent.DispatcherState state = getKeyDispatcherState();\n            if (state != null) {\n                if (KeyEvent.ACTION_DOWN == event.getAction()) {\n                    state.startTracking(event, this);\n                    return true;\n                } else if (KeyEvent.ACTION_UP == event.getAction()) {\n                    onBackPressed();\n                    return true;\n                }\n            }\n        }\n        return super.dispatchKeyEventPreIme(event);\n    }\n    @Override\n    protected Parcelable onSaveInstanceState() {\n        Parcelable superState = super.onSaveInstanceState();\n        VisualState visualState = new VisualState(superState);\n        visualState.save(this);\n        return visualState;\n    }\n    @Override\n    protected void onRestoreInstanceState(Parcelable state) {\n        VisualState visualState = (VisualState) state;\n        super.onRestoreInstanceState(visualState.getSuperState());\n        visualState.restore(this);\n    }\n    public void saveVisualState() {\n        if (null == mMenu) {\n            // Nothing to save.\n            return;\n        }\n        SharedPreferences prefs = getContext().getSharedPreferences(PREFS_FILE, Context.MODE_PRIVATE);\n        PersistentState persistentState = new PersistentState(prefs);\n        persistentState.save(mMenu, mCollapsedDock.sidePosition(), mSelectedSectionId);\n    }\n    void restoreVisualState() {\n        if (null == mMenu) {\n            Log.d(TAG, \"Tried to restore visual state but no menu set.\");\n            return;\n        }\n        SharedPreferences prefs = getContext().getSharedPreferences(PREFS_FILE, Context.MODE_PRIVATE);\n        PersistentState persistentState = new PersistentState(prefs);\n        persistentState.restore(this, mMenu);\n    }\n    // TODO: when to call this?\n    public void release() {\n        Log.d(TAG, \"Released.\");\n        mDragger.deactivate();\n        // TODO: should we also release the screen?\n    }\n    public void enableDebugMode(boolean debugMode) {\n        mIsDebugMode = debugMode;\n        mDragger.enableDebugMode(debugMode);\n        mScreen.enableDrugMode(debugMode);\n    }\n    void setState(@NonNull HoverViewState state) {<fim_middle>// function below has no smell\n"}