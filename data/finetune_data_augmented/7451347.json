{"text": "<fim_prefix>/*\n * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage com.oracle.svm.core.jdk;\nimport java.net.URL;\nimport java.security.AccessControlContext;\nimport java.security.AccessControlException;\nimport java.security.DomainCombiner;\nimport java.security.Permission;\nimport java.security.PrivilegedAction;\nimport java.security.PrivilegedExceptionAction;\nimport java.security.ProtectionDomain;\nimport java.security.SecureRandom;\nimport java.util.List;\nimport java.util.function.BooleanSupplier;\nimport java.util.function.Predicate;\nimport com.oracle.svm.core.SubstrateOptions;\nimport com.oracle.svm.core.annotate.Alias;\nimport com.oracle.svm.core.annotate.InjectAccessors;\nimport com.oracle.svm.core.annotate.Substitute;\nimport com.oracle.svm.core.annotate.TargetClass;\nimport com.oracle.svm.core.annotate.TargetElement;\nimport com.oracle.svm.core.log.Log;\nimport com.oracle.svm.core.option.SubstrateOptionsParser;\nimport com.oracle.svm.core.snippets.KnownIntrinsics;\nimport com.oracle.svm.core.util.VMError;\n// Checkstyle: allow reflection\n/*\n * All security checks are disabled.\n */\n@TargetClass(java.security.AccessController.class)\n@SuppressWarnings({\"unused\"})\nfinal class Target_java_security_AccessController {\n    @Substitute\n    private static <T> T doPrivileged(PrivilegedAction<T> action) {\n        return action.run();\n    }\n    @Substitute\n    private static <T> T doPrivilegedWithCombiner(PrivilegedAction<T> action) {\n        return action.run();\n    }\n    @Substitute\n    private static <T> T doPrivileged(PrivilegedAction<T> action, AccessControlContext context) {\n        return action.run();\n    }\n    @Substitute\n    private static <T> T doPrivileged(PrivilegedAction<T> action, AccessControlContext context, Permission... perms) {\n        return action.run();\n    }\n    @Substitute\n    private static <T> T doPrivileged(PrivilegedExceptionAction<T> action) throws Exception {\n        return action.run();\n    }\n    @Substitute\n    private static <T> T doPrivilegedWithCombiner(PrivilegedExceptionAction<T> action) throws Exception {\n        return action.run();\n    }\n    @Substitute\n    private static <T> T doPrivilegedWithCombiner(PrivilegedExceptionAction<T> action, AccessControlContext context, Permission... perms) throws Exception {\n        return action.run();\n    }\n    @Substitute\n    private static <T> T doPrivileged(PrivilegedExceptionAction<T> action, AccessControlContext context) throws Exception {\n        return action.run();\n    }\n    @Substitute\n    private static void checkPermission(Permission perm) throws AccessControlException {\n    }\n    @Substitute\n    private static AccessControlContext getContext() {\n        AccessControlContext result = new AccessControlContext(new ProtectionDomain[0]);\n        KnownIntrinsics.unsafeCast(result, Target_java_security_AccessControlContext.class).isPrivileged = true;\n        return result;\n    }\n    @Substitute\n    private static AccessControlContext createWrapper(DomainCombiner combiner, Class<?> caller,\n                    AccessControlContext parent, AccessControlContext context, Permission[] perms) {\n        /* Avoid allocating ProtectionDomain objects. Should go away when GR-11112 is fixed. */\n        AccessControlContext result = new AccessControlContext(new ProtectionDomain[0]);\n        KnownIntrinsics.unsafeCast(result, Target_java_security_AccessControlContext.class).isPrivileged = true;\n        return result;\n    }\n}\n@TargetClass(java.security.AccessControlContext.class)\nfinal class Target_java_security_AccessControlContext {\n    @Alias protected boolean isPrivileged;\n}\n@TargetClass(className = \"javax.crypto.JceSecurityManager\")\n@SuppressWarnings({\"static-method\", \"unused\"})\nfinal class Target_javax_crypto_JceSecurityManager {\n    @Substitute\n    Object getCryptoPermission(String var1) {\n        return Target_javax_crypto_CryptoAllPermission.INSTANCE;\n    }\n}\n@TargetClass(className = \"javax.crypto.CryptoAllPermission\")\nfinal class Target_javax_crypto_CryptoAllPermission {\n    @Alias //\n    static Target_javax_crypto_CryptoAllPermission INSTANCE;\n}\nfinal class EnableAllSecurityServicesIsSet implements BooleanSupplier {\n    @Override\n    public boolean getAsBoolean() {\n        return SubstrateOptions.EnableAllSecurityServices.getValue();\n    }\n}\n/**\n * This substitution is enabled only when EnableAllSecurityServices is set since the functionality\n * that it currently provides, i.e., loading security native libraries, is not needed by default.\n */\n@TargetClass(value = java.security.Provider.class, onlyWith = EnableAllSecurityServicesIsSet.class)\nfinal class Target_java_security_Provider {\n    @Alias //\n    private transient boolean initialized;\n    @Alias//\n    private String name;\n    /*\n     * Provider.checkInitialized() is called from the other Provider API methods, before any\n     * computation, thus is a convenient location to do our own initialization, i.e., make sure that\n     * the required libraries are loaded.\n     */\n    @Substitute\n    private void checkInitialized() {\n        if (this.name.equals(\"SunEC\")) {\n            ProviderUtil.initSunEC();\n        }\n        if (!initialized) {\n            throw new IllegalStateException();\n        }\n    }\n}\n<fim_suffix>final class ProviderUtil {\n    private static volatile boolean initialized = false;\n    static void initSunEC() {\n        if (initialized) {\n            return;\n        }\n        /* Lazy initialization. */\n        initOnce();\n    }\n    // Checkstyle: stop\n    private static synchronized void initOnce() {\n        // Checkstyle: resume\n        if (!initialized) {\n            try {\n                System.loadLibrary(\"sunec\");\n            } catch (UnsatisfiedLinkError e) {\n                /*\n                 * SunEC has a mode where it can function without the full ECC implementation when\n                 * native library is absent, however, then fewer EC algorithms are available). If\n                 * those algorithms are actually used an java.lang.UnsatisfiedLinkError will be\n                 * thrown. Just warn the user that the library could not be loaded.\n                 */\n                Log.log().string(\"WARNING: The sunec native library, required by the SunEC provider, could not be loaded. \" +\n                                \"This library is usually shipped as part of the JDK and can be found under <JAVA_HOME>/jre/lib/<platform>/libsunec.so. \" +\n                                \"It is loaded at run time via System.loadLibrary(\\\"sunec\\\"), the first time services from SunEC are accessed. \" +\n                                \"To use this provider's services the java.library.path system property needs to be set accordingly \" +\n                                \"to point to a location that contains libsunec.so. \" +\n                                \"Note that if java.library.path is not set it defaults to the current working directory.\").newline();\n            }\n            initialized = true;\n        }\n    }\n}\n@TargetClass(className = \"javax.crypto.JceSecurity\")\n@SuppressWarnings({\"unused\"})\nfinal class Target_javax_crypto_JceSecurity {\n    /*\n     * Lazily recompute the RANDOM field at runtime. We cannot push the entire static initialization\n     * of JceSecurity to run time because we want the JceSecurity.verificationResults initialized at\n     * image build time.\n     */\n    @Alias @InjectAccessors(JceSecurityAccessor.class) //<fim_middle>// class below has no smell\n"}