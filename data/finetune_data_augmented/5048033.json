{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.jena.tdb.solver;\n\n\nimport static org.apache.jena.atlas.lib.tuple.TupleFactory.* ;\n\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\n\nimport org.apache.jena.atlas.iterator.Iter ;\nimport org.apache.jena.atlas.iterator.RepeatApplyIterator ;\nimport org.apache.jena.atlas.lib.tuple.Tuple ;\nimport org.apache.jena.atlas.lib.tuple.TupleFactory ;\nimport org.apache.jena.graph.Node ;\nimport org.apache.jena.sparql.core.Var ;\nimport org.apache.jena.sparql.engine.ExecutionContext ;\nimport org.apache.jena.tdb.store.NodeId ;\nimport org.apache.jena.tdb.store.nodetable.NodeTable ;\nimport org.apache.jena.tdb.store.nodetupletable.NodeTupleTable ;\n\npublic class StageMatchTuple extends RepeatApplyIterator<BindingNodeId>\n{\n    private final NodeTupleTable nodeTupleTable ;\n    private final Tuple<Node> patternTuple ;\n\n    private final ExecutionContext execCxt ;\n    private boolean anyGraphs ;\n    private Predicate<Tuple<NodeId>> filter ;\n\n    public StageMatchTuple(NodeTupleTable nodeTupleTable, Iterator<BindingNodeId> input, \n                            Tuple<Node> tuple, boolean anyGraphs, \n                            Predicate<Tuple<NodeId>> filter, \n                            ExecutionContext execCxt)\n    {\n        super(input) ;\n        this.filter = filter ;\n        this.nodeTupleTable = nodeTupleTable ; \n        this.patternTuple = tuple ;\n        this.execCxt = execCxt ;\n        this.anyGraphs = anyGraphs ; \n    }\n\n    /** Prepare a pattern (tuple of nodes), and an existing binding of NodeId, into NodeIds and Variables. \n     *  A variable in the pattern is replaced by its binding or null in the Nodeids.\n     *  A variable that is not bound by the binding is placed in the var array.\n     *  Return false if preparation detects the pattern can not match. \n     */\n    public static boolean prepare(NodeTable nodeTable, Tuple<Node> patternTuple, BindingNodeId input, NodeId ids[], Var[] var)\n    {\n        // Process the Node to NodeId conversion ourselves because\n        // we wish to abort if an unknown node is seen.\n        for ( int i = 0 ; i < patternTuple.len() ; i++ )\n        {\n            Node n = patternTuple.get(i) ;\n            // Substitution and turning into NodeIds\n            // Variables unsubstituted are null NodeIds\n            NodeId nId = idFor(nodeTable, input, n) ;\n            if ( NodeId.isDoesNotExist(nId) )\n                return false ;\n            ids[i] = nId ;\n            if ( nId == null )\n                var[i] = asVar(n) ;\n        }\n        return true ;\n    }\n    \n    @Override\n    protected Iterator<BindingNodeId> makeNextStage(final BindingNodeId input)\n    {\n        // ---- Convert to NodeIds \n        NodeId ids[] = new NodeId[patternTuple.len()] ;\n        // Variables for this tuple after subsitution\n        final Var[] var = new Var[patternTuple.len()] ;\n\n        boolean b = prepare(nodeTupleTable.getNodeTable(), patternTuple, input, ids, var) ;\n        if ( !b ) \n            return Iter.nullIterator() ;\n        \n        Iterator<Tuple<NodeId>> iterMatches = nodeTupleTable.find(asTuple(ids)) ;  \n        \n        // ** Allow a triple or quad filter here.\n        if ( filter != null )\n            iterMatches = Iter.filter(iterMatches, filter) ;\n        \n        // If we want to reduce to RDF semantics over quads,\n        // we need to reduce the quads to unique triples. \n        // We do that by having the graph slot as \"any\", then running\n        // through a distinct-ifier. \n        // Assumes quads are GSPO - zaps the first slot.\n        // Assumes that tuples are not shared.\n        if ( anyGraphs )\n        {\n            iterMatches = Iter.map(iterMatches, quadsToAnyTriples) ;\n            //Guaranteed \n            //iterMatches = Iter.distinct(iterMatches) ;\n            \n            // This depends on the way indexes are chosen and\n            // the indexing pattern. It assumes that the index \n            // chosen ends in G so same triples are adjacent \n            // in a union query.\n            // \n            // If any slot is defined, then the index will be X??G.\n            // If no slot is defined, then the index will be ???G.\n            // But the  TupleTable\n            //  See TupleTable.scanAllIndex that ensures the latter.\n            //  No G part way through.\n            iterMatches = Iter.distinctAdjacent(iterMatches) ;\n        }\n        \n        // Map Tuple<NodeId> to BindingNodeId\n        Function<Tuple<NodeId>, BindingNodeId> binder = tuple -> \n            {\n                BindingNodeId output = new BindingNodeId(input) ;\n                for ( int i = 0 ; i < var.length ; i++ )\n                {\n                    Var v = var[i] ;\n                    if ( v == null )\n                        continue ;\n                    NodeId id = tuple.get(i) ;\n                    if ( reject(output, v, id) )\n                        return null ;\n                    output.put(v, id) ;\n                }\n                return output ;\n        } ;\n        \n        return Iter.iter(iterMatches).map(binder).removeNulls() ;\n    }\n    \n    private static Iterator<Tuple<NodeId>> print(Iterator<Tuple<NodeId>> iter)\n    {\n        if ( ! iter.hasNext() )\n            System.err.println(\"<empty>\") ;\n        else\n        {\n            List<Tuple<NodeId>> r = Iter.toList(iter) ;\n            String str = Iter.asString(r, \"\\n\") ;\n            System.err.println(str) ;\n            // Reset iter\n            iter = Iter.iter(r) ;\n        }\n        return iter ;\n    }\n    \n    private static boolean reject(BindingNodeId output , Var var, NodeId value)\n    {\n        if ( ! output.containsKey(var) )\n            return false ;\n        \n        if ( output.get(var).equals(value) )\n            return false ;\n\n        return true ;\n    }\n    \n<fim_suffix>    private static Var asVar(Node node)\n    {\n        if ( Var.isVar(node) )\n            return Var.alloc(node) ;\n        return null ;\n    }\n\n    /** Return null for variables, and for nodes, the node id or NodeDoesNotExist */\n    private static NodeId idFor(NodeTable nodeTable, BindingNodeId input, Node node)\n    {\n        if ( Var.isVar(node) )\n        {\n            NodeId n = input.get((Var.alloc(node))) ;\n            // Bound to NodeId or null. \n            return n ;\n        } \n        // May return NodeId.NodeDoesNotExist which must not be null. \n        return nodeTable.getNodeIdForNode(node) ;\n    }\n    \n    private static Function<Tuple<NodeId>, Tuple<NodeId>> quadsToAnyTriples = item -> {\n        return TupleFactory.create4(NodeId.NodeIdAny, item.get(1), item.get(2), item.get(3) ) ;\n    } ;\n}<fim_middle>// function below has no smell\n"}