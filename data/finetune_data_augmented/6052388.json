{"text": "<fim_prefix>\t\tfinal Dataset xy = Maths.multiply(x, y);\n\t\tMatrix S1 = new Matrix(3, 3);\n\t\tS1.set(0, 0, LinearAlgebra.dotProduct(xx, xx).getDouble());\n\t\tS1.set(0, 1, LinearAlgebra.dotProduct(xxx, y).getDouble());\n\t\tS1.set(0, 2, LinearAlgebra.dotProduct(xx, yy).getDouble());\n\t\tS1.set(1, 0, S1.get(0, 1));\n\t\tS1.set(1, 1, S1.get(0, 2));\n\t\tS1.set(1, 2, LinearAlgebra.dotProduct(x, yyy).getDouble());\n\t\tS1.set(2, 0, S1.get(0, 2));\n\t\tS1.set(2, 1, S1.get(1, 2));\n\t\tS1.set(2, 2, LinearAlgebra.dotProduct(yy, yy).getDouble());\n\t\tMatrix S2 = new Matrix(3, 3);\n\t\tS2.set(0, 0, ((Number) xxx.sum()).doubleValue());\n\t\tS2.set(0, 1, LinearAlgebra.dotProduct(xx, y).getDouble());\n\t\tS2.set(0, 2, ((Number) xx.sum()).doubleValue());\n\t\tS2.set(1, 0, S2.get(0, 1));\n\t\tS2.set(1, 1, LinearAlgebra.dotProduct(x, yy).getDouble());\n\t\tS2.set(1, 2, ((Number) xy.sum()).doubleValue());\n\t\tS2.set(2, 0, S2.get(1, 1));\n\t\tS2.set(2, 1, ((Number) yyy.sum()).doubleValue());\n\t\tS2.set(2, 2, ((Number) yy.sum()).doubleValue());\n\t\tMatrix S3 = new Matrix(3, 3);\n\t\tS3.set(0, 0, S2.get(0, 2));\n\t\tS3.set(0, 1, S2.get(1, 2));\n\t\tS3.set(0, 2, ((Number) x.sum()).doubleValue());\n\t\tS3.set(1, 0, S3.get(0, 1));\n\t\tS3.set(1, 1, S2.get(2, 2));\n\t\tS3.set(1, 2, ((Number) y.sum()).doubleValue());\n\t\tS3.set(2, 0, S3.get(0, 2));\n\t\tS3.set(2, 1, S3.get(1, 2));\n\t\tS3.set(2, 2, x.getSize());\n\t\tMatrix T = S3.solve(S2.transpose()).uminus();\n\t\tMatrix M = S1.plus(S2.times(T));\n\t\tMatrix Cinv = new Matrix(new double[] {0,0,0.5,0,-1.0,0,0.5,0,0}, 3);\n\t\tMatrix Mp = Cinv.times(M);\n//\t\tSystem.err.println(\"M \" + Arrays.toString(Mp.getRowPackedCopy()));\n\t\tMatrix V = Mp.eig().getV();\n//\t\tSystem.err.println(\"V \" + Arrays.toString(V.getRowPackedCopy()));\n\t\tdouble[][] mv = V.getArray();\n\t\tArrayRealVector v1 = new ArrayRealVector(mv[0]);\n\t\tArrayRealVector v2 = new ArrayRealVector(mv[1]);\n\t\tArrayRealVector v3 = new ArrayRealVector(mv[2]);\n\t\tv1.mapMultiplyToSelf(4);\n\t\tArrayRealVector v = v1.ebeMultiply(v3).subtract(v2.ebeMultiply(v2));\n\t\tdouble[] varray = v.getDataRef();\n\t\tint i = 0;\n\t\tfor (; i < 3; i++) {\n\t\t\tif (varray[i] > 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i == 3) {\n\t\t\tthrow new IllegalArgumentException(\"Could not find solution that satifies constraint\");\n\t\t}\n\t\tv = new ArrayRealVector(new double[] {mv[0][i], mv[1][i], mv[2][i]});\n\t\tvarray = v.getDataRef();\n\t\tfinal double ca = varray[0];\n\t\tfinal double cb = varray[1];\n\t\tfinal double cc = varray[2];\n\t\tArray2DRowRealMatrix mt = new Array2DRowRealMatrix(T.getArray(), false);\n\t\tvarray = mt.operate(varray);\n\t\tfinal double cd = varray[0];\n\t\tfinal double ce = varray[1];\n\t\tfinal double cf = varray[2];\n//\t\tSystem.err.println(String.format(\"Algebraic: %g, %g, %g, %g, %g, %g\", ca, cb, cc, cd, ce, cf));\n\t\tfinal double disc = cb*cb - 4.*ca*cc;\n\t\tif (disc >= 0) {\n\t\t\tthrow new IllegalArgumentException(\"Solution is not an ellipse\");\n\t\t}\n\t\tif (cb == 0) {\n\t\t\tthrow new IllegalArgumentException(\"Solution is a circle\");\n\t\t}\n\t\tdouble[] qparameters = new double[PARAMETERS];\n\t\tqparameters[3] = (2.*cc*cd - cb*ce)/disc;\n\t\tqparameters[4] = (2.*ca*ce - cb*cd)/disc;\n\t\tfinal double sqrt = Math.sqrt((ca-cc)*(ca-cc) + cb*cb);\n\t\tqparameters[0] = -2.*(ca*ce*ce + cc*cd*cd + cf*cb*cb - cb*cd*ce - 4.*ca*cc*cf)/disc;\n\t\tqparameters[1] = qparameters[0]/(ca + cc + sqrt);\n\t\tqparameters[0] /= (ca + cc - sqrt);\n\t\tqparameters[0] = Math.sqrt(qparameters[0]);\n\t\tqparameters[1] = Math.sqrt(qparameters[1]);\n\t\tif (cb == 0) {\n\t\t\tqparameters[2] = 0.;\n\t\t} else {\n\t\t\tqparameters[2] = 0.5*Math.atan2(cb, ca - cc);\n\t\t}\n\t\tif (qparameters[0] < qparameters[1]) {\n\t\t\tfinal double t = qparameters[0];\n\t\t\tqparameters[0] = qparameters[1];\n\t\t\tqparameters[1] = t;\n\t\t} else {\n\t\t\tqparameters[2] += Math.PI*0.5;\n\t\t}\n\t\treturn qparameters;\n\t}\n\t/**\n\t * Compute coordinates from an array of angles\n\t * @param angles\n\t * @param geometricParameters\n\t * @return x and y datasets\n\t */\n<fim_suffix>\tpublic static Dataset[] generateCoordinates(Dataset angles, final double[] geometricParameters) {\n\t\tif (geometricParameters.length != PARAMETERS)\n\t\t\tthrow new IllegalArgumentException(\"Need \" + PARAMETERS + \" parameters\");\n\t\tDataset[] coords = new Dataset[2];\n\t\tDoubleDataset x = DatasetFactory.zeros(DoubleDataset.class, angles.getShape());\n\t\tDoubleDataset y = DatasetFactory.zeros(DoubleDataset.class, angles.getShape());\n\t\tcoords[0] = x;\n\t\tcoords[1] = y;\n\t\tfinal double ca = Math.cos(geometricParameters[2]);\n\t\tfinal double sa = Math.sin(geometricParameters[2]);\n\t\tfinal IndexIterator it = angles.getIterator();\n\t\tint i = 0;\n\t\twhile (it.hasNext()) {\n\t\t\tfinal double t = angles.getElementDoubleAbs(it.index);\n\t\t\tfinal double ct = Math.cos(t);\n\t\t\tfinal double st = Math.sin(t);\n\t\t\tx.setAbs(i, geometricParameters[3] + geometricParameters[0]*ca*ct - geometricParameters[1]*sa*st);\n\t\t\ty.setAbs(i, geometricParameters[4] + geometricParameters[0]*sa*ct + geometricParameters[1]*ca*st);\n\t\t\ti++;\n\t\t}\n\t\treturn coords;\n\t}<fim_middle>// function below is feature envy\n"}