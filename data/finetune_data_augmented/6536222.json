{"text": "<fim_prefix>/**\n * Copyright (c) 2014,2019 Contributors to the Eclipse Foundation\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.eclipse.smarthome.model.lsp.internal;\n\nimport java.io.File;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URLDecoder;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.FileSystemNotFoundException;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\n\nimport org.eclipse.emf.common.util.URI;\nimport org.eclipse.xtext.ide.server.UriExtensions;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * {@link UriExtensions} implementation.\n *\n * It takes into account the fact that although language server and client both operate on the same set of files, their\n * file system location might be different due to remote access via SMB, SSH and the like.\n *\n * @author Simon Kaufmann - initial contribution and API.\n *\n */\npublic class MappingUriExtensions extends UriExtensions {\n\n    private static final Charset PATH_ENCODING = StandardCharsets.UTF_8;\n\n    private final Logger logger = LoggerFactory.getLogger(MappingUriExtensions.class);\n\n    private final String serverLocation;\n    private String clientLocation = null;\n    private final String rawConfigFolder;\n\n    public MappingUriExtensions(String configFolder) {\n        this.rawConfigFolder = configFolder;\n        serverLocation = calcServerLocation(configFolder);\n        logger.debug(\"The language server is using '{}' as its workspace\", serverLocation);\n    }\n\n    protected String calcServerLocation(String configFolder) {\n        Path configPath = Paths.get(configFolder);\n        Path absoluteConfigPath = configPath.toAbsolutePath();\n        java.net.URI configPathURI = absoluteConfigPath.toUri();\n        return removeTrailingSlash(configPathURI.toString());\n    }\n\n    @Override\n    public String toPath(URI uri) {\n        return toPath(java.net.URI.create(uri.toString()));\n    }\n\n    @Override\n    public String toPath(java.net.URI uri) {\n        java.net.URI ret = uri;\n        try {\n            ret = Paths.get(uri).toUri();\n        } catch (FileSystemNotFoundException e) {\n            // fall-back to the argument\n        }\n        String clientPath = removeTrailingSlash(ret.toASCIIString());\n        if (clientLocation != null) {\n            clientPath = clientPath.replace(serverLocation, clientLocation);\n        }\n        return clientPath;\n    }\n\n    @Override\n    public URI toUri(String pathWithScheme) {\n        try {\n            String decodedPathWithScheme = URLDecoder.decode(pathWithScheme, PATH_ENCODING.toString());\n\n            if (clientLocation != null && decodedPathWithScheme.startsWith(clientLocation)) {\n                return map(decodedPathWithScheme);\n            }\n\n            clientLocation = guessClientPath(decodedPathWithScheme);\n            if (clientLocation != null) {\n                logger.debug(\"Identified client workspace as '{}'\", clientLocation);\n                return map(decodedPathWithScheme);\n            }\n\n            clientLocation = pathWithScheme;\n        } catch (UnsupportedEncodingException e) {\n            logger.error(\"Charset {} is not supported. You're seriously in trouble.\", PATH_ENCODING);\n        }\n        logger.debug(\"Path mapping could not be done for '{}', leaving it untouched\", pathWithScheme);\n        java.net.URI javaNetUri = java.net.URI.create(pathWithScheme);\n        return URI.createURI(toPathAsInXtext212(javaNetUri));\n    }\n\n    @Override\n    public String toUriString(URI uri) {\n        if (clientLocation == null) {\n            return uri.toString();\n        }\n        return mapToClientPath(uri.toString());\n    }\n\n    @Override\n    public String toUriString(java.net.URI uri) {\n        return toUriString(URI.createURI(uri.toString()));\n    }\n\n    private String mapToClientPath(String pathWithScheme) {\n        String clientPath = toPathAsInXtext212(\n                java.net.URI.create(pathWithScheme.replace(serverLocation, clientLocation)));\n        logger.trace(\"Mapping server path {} to client path {}\", pathWithScheme, clientPath);\n        return clientPath;\n    }\n\n    protected final String removeTrailingSlash(String path) {\n        if (path.endsWith(\"/\")) {\n            return path.substring(0, path.length() - 1);\n        } else {\n            return path;\n        }\n    }\n\n    /**\n     * Guess the client path.\n     *\n     * It works as follows: It starts with replacing the full clients path with the path of the config folder.\n     * In the next iteration it shortens the path to be replaced by one subfolder.\n     * It repeats that until the resulting filename exists.\n     *\n     * @param pathWithScheme the filename as coming from the client\n     * @return the substring which needs to be replaced with the runtime's config folder path\n     */\n    protected String guessClientPath(String pathWithScheme) {\n        if (isPointingToConfigFolder(pathWithScheme)) {\n            return removeTrailingSlash(pathWithScheme);\n        } else if (isFolder(pathWithScheme)) {\n            return removeTrailingSlash(pathWithScheme);\n        }\n\n        String currentPath = pathWithScheme;\n        int nextIndex = getLastPathSegmentIndex(currentPath);\n        while (nextIndex > -1) {\n            currentPath = currentPath.substring(0, nextIndex);\n            java.net.URI uri = toURI(pathWithScheme, currentPath);\n            File realFile = new File(uri);\n            if (realFile.exists()) {\n                return currentPath;\n            }\n\n            nextIndex = getLastPathSegmentIndex(currentPath);\n        }\n\n        return null;\n    }\n\n    private boolean isFolder(String currentPath) {\n        return !currentPath.substring(getLastPathSegmentIndex(currentPath)).contains(\".\");\n    }\n\n    private boolean isPointingToConfigFolder(String currentPath) {\n        return currentPath.endsWith(\"/\" + rawConfigFolder);\n    }\n\n    private int getLastPathSegmentIndex(String currentPath) {\n        return removeTrailingSlash(currentPath).lastIndexOf(\"/\");\n    }\n\n<fim_suffix>    private URI map(String pathWithScheme) {\n        java.net.URI javaNetUri = toURI(pathWithScheme, clientLocation);\n        logger.trace(\"Going to map path {}\", javaNetUri);\n        URI ret = URI.createURI(toPathAsInXtext212(javaNetUri));\n        logger.trace(\"Mapped path {} to {}\", pathWithScheme, ret);\n        return ret;\n    }\n\n    private java.net.URI toURI(String pathWithScheme, String currentPath) {\n        return java.net.URI.create(pathWithScheme.replace(currentPath, serverLocation));\n    }\n\n    private String toPathAsInXtext212(java.net.URI uri) {\n        // org.eclipse.xtext.ide.server.UriExtensions:\n        // In Xtext 2.14 the method \"String toPath(java.netURI)\" has been deprecated but still exist.\n        // It delegate the logic internally to the new method \"String toUriString(java.net.URI uri)\".\n        // That new method seems to return a different result for folder / directories with respect to\n        // the present / absent of a trailing slash.\n\n        // The old logic removes trailing slashes if it has been present in the input.\n        // The new logic keeps trailing slashes if it has been present in the input.\n\n        // input: file:///d/\n        // output old: file:///d\n        // output new: file:///d\n\n        // input: file:///d/\n        // output old: file:///d\n        // output new: file:///d/\n\n        // We use this method now to keep the old behavior.\n        return Paths.get(uri).toUri().toString();\n    }\n\n}<fim_middle>// function below has no smell\n"}