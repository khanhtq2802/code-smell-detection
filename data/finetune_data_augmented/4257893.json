{"text": "<fim_prefix>     */\n    public int getN() {\n        return n;\n    }\n    /**\n     * Gets the number of elements in each combination.\n     *\n     * @return the size of the subsets to be enumerated.\n     */\n    public int getK() {\n        return k;\n    }\n    /** {@inheritDoc} */\n    @Override\n    public Iterator<int[]> iterator() {\n        if (k == 0 ||\n            k == n) {\n            return new SingletonIterator(k);\n        }\n        switch (iterationOrder) {\n        case LEXICOGRAPHIC:\n            return new LexicographicIterator(n, k);\n        default:\n            // Should never happen.\n            throw new UnsupportedOperationException(\"Please file a bug report\");\n        }\n    }\n    /**\n     * Lexicographic combinations iterator.\n     * <p>\n     * Implementation follows Algorithm T in <i>The Art of Computer Programming</i>\n     * Internet Draft (PRE-FASCICLE 3A), \"A Draft of Section 7.2.1.3 Generating All\n     * Combinations</a>, D. Knuth, 2004.</p>\n     * <p>\n     * The degenerate cases {@code k == 0} and {@code k == n} are NOT handled by this\n     * implementation.  If constructor arguments satisfy {@code k == 0}\n     * or {@code k >= n}, no exception is generated, but the iterator is empty.\n     * </p>\n     *\n     */\n    private static class LexicographicIterator implements Iterator<int[]> {\n        /** Size of subsets returned by the iterator. */\n        private final int k;\n        /**\n         * c[1], ..., c[k] stores the next combination; c[k + 1], c[k + 2] are\n         * sentinels.\n         * <p>\n         * Note that c[0] is \"wasted\" but this makes it a little easier to\n         * follow the code.\n         * </p>\n         */\n        private final int[] c;\n        /** Return value for {@link #hasNext()} */\n        private boolean more = true;\n        /** Marker: smallest index such that {@code c[j + 1] > j}. */\n        private int j;\n        /**\n         * Construct a CombinationIterator to enumerate {@code k}-sets from a set\n         * of size {@code n}.\n         * <p>\n         * NOTE: If {@code k === 0} or {@code k >= n}, the Iterator will be empty\n         * (that is, {@link #hasNext()} will return {@code false} immediately.\n         * </p>\n         *\n         * @param n Size of the set from which subsets are enumerated.\n         * @param k Size of the subsets to enumerate.\n         */\n        LexicographicIterator(int n, int k) {\n            this.k = k;\n            c = new int[k + 3];\n            if (k == 0 || k >= n) {\n                more = false;\n                return;\n            }\n            // Initialize c to start with lexicographically first k-set\n            for (int i = 1; i <= k; i++) {\n                c[i] = i - 1;\n            }\n            // Initialize sentinels\n            c[k + 1] = n;\n            c[k + 2] = 0;\n            j = k; // Set up invariant: j is smallest index such that c[j + 1] > j\n        }\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean hasNext() {\n            return more;\n        }\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public int[] next() {\n            if (!more) {\n                throw new NoSuchElementException();\n            }\n            // Copy return value (prepared by last activation)\n            final int[] ret = new int[k];\n            System.arraycopy(c, 1, ret, 0, k);\n            // Prepare next iteration\n            // T2 and T6 loop\n            int x = 0;\n            if (j > 0) {\n                x = j;\n                c[j] = x;\n                j--;\n                return ret;\n            }\n            // T3\n            if (c[1] + 1 < c[2]) {\n                c[1]++;\n                return ret;\n            } else {\n                j = 2;\n            }\n            // T4\n            boolean stepDone = false;\n            while (!stepDone) {\n                c[j - 1] = j - 2;\n                x = c[j] + 1;\n                if (x == c[j + 1]) {\n                    j++;\n                } else {\n                    stepDone = true;\n                }\n            }\n            // T5\n            if (j > k) {\n                more = false;\n                return ret;\n            }\n            // T6\n            c[j] = x;\n            j--;\n            return ret;\n        }\n        /**\n         * Not supported.\n         */\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    }\n    /**\n     * Iterator with just one element to handle degenerate cases (full array,\n     * empty array) for combination iterator.\n     */\n    private static class SingletonIterator implements Iterator<int[]> {\n        /** Number of elements of the singleton array. */\n        private final int n;\n        /** True on initialization, false after first call to next */\n        private boolean more = true;\n        /**\n         * Create a singleton iterator providing the given array.\n         *\n         * @param n Size of the singleton array returned by the iterator.\n         */\n        SingletonIterator(final int n) {\n            this.n = n;\n        }\n        /**\n         * @return {@code true} until next is called the first time,\n         * then {@code false}.\n         **/\n        @Override\n        public boolean hasNext() {\n            return more;\n        }\n        /**\n         * @return the singleton at the first activation.\n         * @throws NoSuchElementException after the first activation.\n         */\n        @Override\n        public int[] next() {\n            if (more) {\n                more = false;\n                // Create singleton.\n                final int[] s = new int[n];\n                for (int i = 0; i < n; i++) {\n                    s[i] = i;\n                }\n                return s;\n            } else {\n                throw new NoSuchElementException();\n            }\n        }\n        /**\n         * Unsupported.\n         *\n         * @throws UnsupportedOperationException\n         */\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    }\n    /**\n     * Defines a lexicographic ordering of the combinations.\n     *\n     * The comparison is based on the value (in base 10) represented\n     * by the digit (interpreted in base {@code n}) in the input array,\n     * in reverse order.\n     * For example if {@code c} is {@code {3, 2, 1}}, and {@code n}\n     * is 3, the method will return 18.\n     */\n    public static class LexicographicComparator\n        implements Comparator<int[]>,\n                   Serializable {\n        /** Serializable version identifier. */\n        private static final long serialVersionUID = 20170520L;\n        /** Size of the set from which combinations are drawn. */\n        private final int n;\n        /** Number of elements in each combination. */\n        private final int k;\n        /**\n         * @param n Size of the set from which subsets are selected.\n         * @param k Size of the subsets to be enumerated.\n         */\n        public LexicographicComparator(int n,\n                                       int k) {\n            this.n = n;\n            this.k = k;\n        }\n        /**\n         * Gets the size of the set from which combinations are drawn.\n         *\n         * @return the size of the universe.\n         */\n        public int getN() {\n            return n;\n        }\n        /**\n         * Gets the number of elements in each combination.\n         *\n         * @return the size of the subsets.\n         */\n        public int getK() {\n            return k;\n        }\n        /**\n         * {@inheritDoc}\n         *\n         * @throws IllegalArgumentException if the array lengths are not\n         * equal to {@code k}.\n         * @throws IllegalArgumentException if an element of the array is not\n         * within the interval [0, {@code n}).\n         */\n<fim_suffix>        @Override\n        public int compare(int[] c1,\n                           int[] c2) {\n            if (c1.length != k) {\n                throw new CombinatoricsException(CombinatoricsException.MISMATCH, c1.length, k);\n            }\n            if (c2.length != k) {\n                throw new CombinatoricsException(CombinatoricsException.MISMATCH, c2.length, k);\n            }\n            // Method \"lexNorm\" works with ordered arrays.\n            final int[] c1s = Arrays.copyOf(c1, k);\n            final int[] c2s = Arrays.copyOf(c2, k);\n            Arrays.sort(c1s);\n            Arrays.sort(c2s);\n            final long v1 = lexNorm(c1s);\n            final long v2 = lexNorm(c2s);\n            if (v1 < v2) {\n                return -1;\n            } else if (v1 > v2) {\n                return 1;\n            } else {\n                return 0;\n            }\n        }<fim_middle>// function below has no smell\n"}