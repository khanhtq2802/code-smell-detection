{"text": "<fim_prefix> *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage javax.swing;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.concurrent.locks.*;\nimport java.util.concurrent.atomic.AtomicLong;\nimport sun.awt.AppContext;\n/**\n * Internal class to manage all Timers using one thread.\n * TimerQueue manages a queue of Timers. The Timers are chained\n * together in a linked list sorted by the order in which they will expire.\n *\n * @author Dave Moore\n * @author Igor Kushnirskiy\n */\nclass TimerQueue implements Runnable\n{\n    private static final Object sharedInstanceKey =\n        new StringBuffer(\"TimerQueue.sharedInstanceKey\");\n    private static final Object expiredTimersKey =\n        new StringBuffer(\"TimerQueue.expiredTimersKey\");\n    private final DelayQueue<DelayedTimer> queue;\n    private volatile boolean running;\n    private final Lock runningLock;\n    /* Lock object used in place of class object for synchronization.\n     * (4187686)\n     */\n    private static final Object classLock = new Object();\n    /** Base of nanosecond timings, to avoid wrapping */\n    private static final long NANO_ORIGIN = System.nanoTime();\n    /**\n     * Constructor for TimerQueue.\n     */\n    public TimerQueue() {\n        super();\n        queue = new DelayQueue<DelayedTimer>();\n        // Now start the TimerQueue thread.\n        runningLock = new ReentrantLock();\n        startIfNeeded();\n    }\n    public static TimerQueue sharedInstance() {\n        synchronized (classLock) {\n            TimerQueue sharedInst = (TimerQueue)\n                                    SwingUtilities.appContextGet(\n                                                        sharedInstanceKey);\n            if (sharedInst == null) {\n                sharedInst = new TimerQueue();\n                SwingUtilities.appContextPut(sharedInstanceKey, sharedInst);\n            }\n            return sharedInst;\n        }\n    }\n    void startIfNeeded() {\n        if (! running) {\n            runningLock.lock();\n            if (running) {\n                return;\n            }\n            try {\n                final ThreadGroup threadGroup = AppContext.getAppContext().getThreadGroup();\n                AccessController.doPrivileged((PrivilegedAction<Object>) () -> {\n                    String name = \"TimerQueue\";\n                    Thread timerThread =\n                        new Thread(threadGroup, this, name, 0, false);\n                    timerThread.setDaemon(true);\n                    timerThread.setPriority(Thread.NORM_PRIORITY);\n                    timerThread.start();\n                    return null;\n                });\n                running = true;\n            } finally {\n                runningLock.unlock();\n            }\n        }\n    }\n    void addTimer(Timer timer, long delayMillis) {\n        timer.getLock().lock();\n        try {\n            // If the Timer is already in the queue, then ignore the add.\n            if (! containsTimer(timer)) {\n                addTimer(new DelayedTimer(timer,\n                                      TimeUnit.MILLISECONDS.toNanos(delayMillis)\n                                      + now()));\n            }\n        } finally {\n            timer.getLock().unlock();\n        }\n    }\n    private void addTimer(DelayedTimer delayedTimer) {\n        assert delayedTimer != null && ! containsTimer(delayedTimer.getTimer());\n        Timer timer = delayedTimer.getTimer();\n        timer.getLock().lock();\n        try {\n            timer.delayedTimer = delayedTimer;\n            queue.add(delayedTimer);\n        } finally {\n            timer.getLock().unlock();\n        }\n    }\n    void removeTimer(Timer timer) {\n        timer.getLock().lock();\n        try {\n            if (timer.delayedTimer != null) {\n                queue.remove(timer.delayedTimer);\n                timer.delayedTimer = null;\n            }\n        } finally {\n            timer.getLock().unlock();\n        }\n    }\n    boolean containsTimer(Timer timer) {\n        timer.getLock().lock();\n        try {\n            return timer.delayedTimer != null;\n        } finally {\n            timer.getLock().unlock();\n        }\n    }\n    public void run() {\n        runningLock.lock();\n        try {\n            while (running) {\n                try {\n                    DelayedTimer runningTimer = queue.take();\n                    Timer timer = runningTimer.getTimer();\n                    timer.getLock().lock();\n                    try {\n                        DelayedTimer delayedTimer = timer.delayedTimer;\n                        if (delayedTimer == runningTimer) {\n                            /*\n                             * Timer is not removed (delayedTimer != null)\n                             * or not removed and added (runningTimer == delayedTimer)\n                             * after we get it from the queue and before the\n                             * lock on the timer is acquired\n                             */\n                            timer.post(); // have timer post an event\n                            timer.delayedTimer = null;\n                            if (timer.isRepeats()) {\n                                delayedTimer.setTime(now()\n                                    + TimeUnit.MILLISECONDS.toNanos(\n                                          timer.getDelay()));\n                                addTimer(delayedTimer);\n                            }\n                        }\n                        // Allow run other threads on systems without kernel threads\n                        timer.getLock().newCondition().awaitNanos(1);\n                    } catch (SecurityException ignore) {\n                    } finally {\n                        timer.getLock().unlock();\n                    }\n                } catch (InterruptedException ie) {\n                    // Shouldn't ignore InterruptedExceptions here, so AppContext\n                    // is disposed gracefully, see 6799345 for details\n                    if (AppContext.getAppContext().isDisposed()) {\n                        break;\n                    }\n                }\n            }\n        }\n        catch (ThreadDeath td) {\n            // Mark all the timers we contain as not being queued.\n            for (DelayedTimer delayedTimer : queue) {\n                delayedTimer.getTimer().cancelEvent();\n            }\n            throw td;\n        } finally {\n            running = false;\n            runningLock.unlock();\n        }\n    }\n    public String toString() {\n        StringBuilder buf = new StringBuilder();\n        buf.append(\"TimerQueue (\");\n        boolean isFirst = true;\n        for (DelayedTimer delayedTimer : queue) {\n            if (! isFirst) {\n                buf.append(\", \");\n            }\n            buf.append(delayedTimer.getTimer().toString());\n            isFirst = false;\n        }\n        buf.append(\")\");\n        return buf.toString();\n    }\n    /**\n     * Returns nanosecond time offset by origin\n     */\n    private static long now() {\n        return System.nanoTime() - NANO_ORIGIN;\n    }\n<fim_suffix>    static class DelayedTimer implements Delayed {\n        // most of it copied from\n        // java.util.concurrent.ScheduledThreadPoolExecutor\n        /**\n         * Sequence number to break scheduling ties, and in turn to\n         * guarantee FIFO order among tied entries.\n         */\n        private static final AtomicLong sequencer = new AtomicLong(0);\n        /** Sequence number to break ties FIFO */\n        private final long sequenceNumber;\n        /** The time the task is enabled to execute in nanoTime units */\n        private volatile long time;\n        private final Timer timer;\n        DelayedTimer(Timer timer, long nanos) {\n            this.timer = timer;\n            time = nanos;\n            sequenceNumber = sequencer.getAndIncrement();\n        }\n        public final long getDelay(TimeUnit unit) {\n            return  unit.convert(time - now(), TimeUnit.NANOSECONDS);\n        }\n        final void setTime(long nanos) {\n            time = nanos;\n        }\n        final Timer getTimer() {\n            return timer;\n        }\n        public int compareTo(Delayed other) {\n            if (other == this) { // compare zero ONLY if same object\n                return 0;\n            }\n            if (other instanceof DelayedTimer) {\n                DelayedTimer x = (DelayedTimer)other;\n                long diff = time - x.time;\n                if (diff < 0) {\n                    return -1;\n                } else if (diff > 0) {\n                    return 1;\n                } else if (sequenceNumber < x.sequenceNumber) {\n                    return -1;\n                }  else {\n                    return 1;\n                }\n            }\n            long d = (getDelay(TimeUnit.NANOSECONDS) -\n                      other.getDelay(TimeUnit.NANOSECONDS));\n            return (d == 0) ? 0 : ((d < 0) ? -1 : 1);\n        }\n    }<fim_middle>// class below has no smell\n"}