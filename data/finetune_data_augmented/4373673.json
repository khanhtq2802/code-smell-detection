{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.cxf.rs.security.jose.jws;\n\nimport java.util.Collections;\nimport java.util.logging.Logger;\n\nimport org.apache.cxf.common.logging.LogUtils;\nimport org.apache.cxf.common.util.Base64UrlUtility;\nimport org.apache.cxf.common.util.StringUtils;\nimport org.apache.cxf.jaxrs.json.basic.JsonMapObjectReaderWriter;\nimport org.apache.cxf.jaxrs.json.basic.JsonObject;\nimport org.apache.cxf.rs.security.jose.common.JoseConstants;\nimport org.apache.cxf.rs.security.jose.common.JoseUtils;\nimport org.apache.cxf.rs.security.jose.jwk.JsonWebKey;\n\n\n<fim_suffix>public class JwsJsonSignatureEntry implements JsonObject {\n    protected static final Logger LOG = LogUtils.getL7dLogger(JwsJsonSignatureEntry.class);\n    private String jwsPayload;\n    private String encodedProtectedHeader;\n    private String encodedSignature;\n    private JwsHeaders protectedHeader;\n    private JwsHeaders unprotectedHeader;\n    private JwsHeaders unionHeaders;\n    private JsonMapObjectReaderWriter writer = new JsonMapObjectReaderWriter();\n\n    public JwsJsonSignatureEntry(String jwsPayload,\n                                 String encodedProtectedHeader,\n                                 String encodedSignature,\n                                 JwsHeaders unprotectedHeader) {\n        if (encodedProtectedHeader == null && unprotectedHeader == null || encodedSignature == null) {\n            LOG.warning(\"Invalid Signature entry\");\n            throw new JwsException(JwsException.Error.INVALID_JSON_JWS);\n        }\n\n        this.jwsPayload = jwsPayload;\n        this.encodedProtectedHeader = encodedProtectedHeader;\n        this.encodedSignature = encodedSignature;\n        this.unprotectedHeader = unprotectedHeader;\n        if (encodedProtectedHeader != null) {\n            this.protectedHeader = new JwsHeaders(writer.fromJson(JoseUtils.decodeToString(encodedProtectedHeader)));\n        }\n        prepare();\n    }\n    private void prepare() {\n        unionHeaders = new JwsHeaders();\n\n        if (protectedHeader != null) {\n            unionHeaders.asMap().putAll(protectedHeader.asMap());\n        }\n        if (unprotectedHeader != null) {\n            if (!Collections.disjoint(unionHeaders.asMap().keySet(),\n                                     unprotectedHeader.asMap().keySet())) {\n                LOG.warning(\"Protected and unprotected headers have duplicate values\");\n                throw new JwsException(JwsException.Error.INVALID_JSON_JWS);\n            }\n            unionHeaders.asMap().putAll(unprotectedHeader.asMap());\n        }\n    }\n    public String getJwsPayload() {\n        return jwsPayload;\n    }\n    public String getDecodedJwsPayload() {\n        if (protectedHeader == null || !JwsUtils.isPayloadUnencoded(protectedHeader)) {\n            return JoseUtils.decodeToString(jwsPayload);\n        }\n        return jwsPayload;\n    }\n    public byte[] getDecodedJwsPayloadBytes() {\n        return StringUtils.toBytesUTF8(getDecodedJwsPayload());\n    }\n    public String getEncodedProtectedHeader() {\n        return encodedProtectedHeader;\n    }\n    public JwsHeaders getProtectedHeader() {\n        return protectedHeader;\n    }\n    public JwsHeaders getUnprotectedHeader() {\n        return unprotectedHeader;\n    }\n    public JwsHeaders getUnionHeader() {\n        return unionHeaders;\n    }\n    public String getEncodedSignature() {\n        return encodedSignature;\n    }\n    public byte[] getDecodedSignature() {\n        return JoseUtils.decode(getEncodedSignature());\n    }\n    public String getUnsignedSequence() {\n        if (getEncodedProtectedHeader() != null) {\n            return getEncodedProtectedHeader() + \".\" + getJwsPayload();\n        }\n        return \".\" + getJwsPayload();\n    }\n    public String getKeyId() {\n        return getUnionHeader().getKeyId();\n    }\n    public boolean verifySignatureWith(JwsSignatureVerifier validator) {\n        try {\n            if (validator.verify(getUnionHeader(),\n                                 getUnsignedSequence(),\n                                 getDecodedSignature())) {\n                return true;\n            }\n        } catch (JwsException ex) {\n            // ignore\n        }\n        LOG.warning(\"Invalid Signature Entry\");\n        return false;\n    }\n    public boolean verifySignatureWith(JsonWebKey key) {\n        return verifySignatureWith(JwsUtils.getSignatureVerifier(key));\n    }\n    public boolean validateCriticalHeaders() {\n        if (this.getUnprotectedHeader().getHeader(JoseConstants.HEADER_CRITICAL) != null) {\n            return false;\n        }\n        return JwsUtils.validateCriticalHeaders(getUnionHeader());\n    }\n    public String toJson() {\n        return toJson(false);\n    }\n    public String toJson(boolean flattenedMode) {\n        StringBuilder sb = new StringBuilder();\n        if (!flattenedMode) {\n            sb.append('{');\n        }\n        if (protectedHeader != null) {\n            sb.append(\"\\\"protected\\\":\\\"\").append(Base64UrlUtility.encode(writer.toJson(protectedHeader))).append('\"');\n        }\n        if (unprotectedHeader != null) {\n            if (protectedHeader != null) {\n                sb.append(',');\n            }\n            sb.append(\"\\\"header\\\":\").append(writer.toJson(unprotectedHeader));\n        }\n        sb.append(',');\n        sb.append(\"\\\"signature\\\":\\\"\").append(encodedSignature).append('\"');\n        if (!flattenedMode) {\n            sb.append('}');\n        }\n        return sb.toString();\n    }\n}<fim_middle>// class below has no smell\n"}