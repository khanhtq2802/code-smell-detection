{"text": "<fim_prefix>/*\n * Copyright (c) 2017-2018 Bosch Software Innovations GmbH.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v2.0\n * which accompanies this distribution, and is available at\n * https://www.eclipse.org/org/documents/epl-2.0/index.php\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.eclipse.ditto.services.connectivity.messaging.validation;\n\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\n\nimport javax.annotation.concurrent.Immutable;\n\nimport org.eclipse.ditto.model.base.exceptions.DittoRuntimeException;\nimport org.eclipse.ditto.model.base.headers.DittoHeaders;\nimport org.eclipse.ditto.model.connectivity.Connection;\nimport org.eclipse.ditto.model.connectivity.ConnectionConfigurationInvalidException;\nimport org.eclipse.ditto.model.connectivity.ConnectionType;\nimport org.eclipse.ditto.model.connectivity.credentials.ClientCertificateCredentials;\nimport org.eclipse.ditto.model.connectivity.credentials.Credentials;\nimport org.eclipse.ditto.model.query.criteria.CriteriaFactory;\nimport org.eclipse.ditto.model.query.criteria.CriteriaFactoryImpl;\nimport org.eclipse.ditto.model.query.expression.ThingsFieldExpressionFactory;\nimport org.eclipse.ditto.model.query.filter.QueryFilterCriteriaFactory;\nimport org.eclipse.ditto.model.query.things.ModelBasedThingsFieldExpressionFactory;\nimport org.eclipse.ditto.services.connectivity.messaging.internal.SSLContextCreator;\n\n/**\n * Validate a connection according to its type.\n */\n<fim_suffix>@Immutable\npublic final class ConnectionValidator {\n\n    private final Map<ConnectionType, AbstractProtocolValidator> specMap;\n    private final QueryFilterCriteriaFactory queryFilterCriteriaFactory;\n\n    private ConnectionValidator(final AbstractProtocolValidator... connectionSpecs) {\n        final Map<ConnectionType, AbstractProtocolValidator> specMap = Arrays.stream(connectionSpecs)\n                .collect(Collectors.toMap(AbstractProtocolValidator::type, Function.identity()));\n        this.specMap = Collections.unmodifiableMap(specMap);\n\n        final CriteriaFactory criteriaFactory = new CriteriaFactoryImpl();\n        final ThingsFieldExpressionFactory fieldExpressionFactory =\n                new ModelBasedThingsFieldExpressionFactory();\n        queryFilterCriteriaFactory = new QueryFilterCriteriaFactory(criteriaFactory, fieldExpressionFactory);\n    }\n\n    /**\n     * Create a connection validator from connection specs.\n     *\n     * @param connectionSpecs specs of supported connection types.\n     * @return a connection validator.\n     */\n    public static ConnectionValidator of(final AbstractProtocolValidator... connectionSpecs) {\n        return new ConnectionValidator(connectionSpecs);\n    }\n\n    /**\n     * Check a connection for errors and throw them.\n     *\n     * @param connection the connection to validate.\n     * @param dittoHeaders headers of the command that triggered the connection validation.\n     * @throws org.eclipse.ditto.model.base.exceptions.DittoRuntimeException if the connection has errors.\n     * @throws java.lang.IllegalStateException if the connection type is not known.\n     */\n    void validate(final Connection connection, final DittoHeaders dittoHeaders) {\n        final AbstractProtocolValidator spec = specMap.get(connection.getConnectionType());\n        validateSourceAndTargetAddressesAreNonempty(connection, dittoHeaders);\n        validateFormatOfCertificates(connection, dittoHeaders);\n        if (spec != null) {\n            // throw error at validation site for clarity of stack trace\n            spec.validate(connection, dittoHeaders);\n        } else {\n            throw new IllegalStateException(\"Unknown connection type: \" + connection);\n        }\n    }\n\n    private void validateSourceAndTargetAddressesAreNonempty(final Connection connection,\n            final DittoHeaders dittoHeaders) {\n\n        connection.getSources().forEach(source -> {\n            if (source.getAddresses().isEmpty() || source.getAddresses().contains(\"\")) {\n                final String location =\n                        String.format(\"Source %d of connection <%s>\", source.getIndex(), connection.getId());\n                throw emptyAddressesError(location, dittoHeaders);\n            }\n        });\n\n        connection.getTargets().forEach(target -> {\n            if (target.getAddress().isEmpty()) {\n                final String location = String.format(\"Targets of connection <%s>\", connection.getId());\n                throw emptyAddressesError(location, dittoHeaders);\n            }\n            target.getTopics().forEach(topic -> topic.getFilter().ifPresent(filter -> {\n                // will throw an InvalidRqlExpressionException if the RQL expression was not valid:\n                queryFilterCriteriaFactory.filterCriteria(filter, dittoHeaders);\n            }));\n        });\n    }\n\n    private static void validateFormatOfCertificates(final Connection connection, final DittoHeaders dittoHeaders) {\n        final Optional<String> trustedCertificates = connection.getTrustedCertificates();\n        final Optional<Credentials> credentials = connection.getCredentials();\n        // check if there are certificates to check\n        if (trustedCertificates.isPresent() || credentials.isPresent()) {\n            credentials.orElseGet(ClientCertificateCredentials::empty)\n                    .accept(SSLContextCreator.fromConnection(connection, dittoHeaders));\n        }\n    }\n\n    private static DittoRuntimeException emptyAddressesError(final String location, final DittoHeaders dittoHeaders) {\n        final String message = location + \": addresses may not be empty.\";\n        return ConnectionConfigurationInvalidException.newBuilder(message)\n                .dittoHeaders(dittoHeaders)\n                .build();\n    }\n}<fim_middle>// class below has no smell\n"}