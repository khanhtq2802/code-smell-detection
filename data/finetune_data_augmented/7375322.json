{"text": "<fim_prefix>import org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.boot.context.properties.PropertyMapper;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Import;\n/**\n * {@link EnableAutoConfiguration Auto-configuration} for {@link RabbitTemplate}.\n * <p>\n * This configuration class is active only when the RabbitMQ and Spring AMQP client\n * libraries are on the classpath.\n * <P>\n * Registers the following beans:\n * <ul>\n * <li>{@link org.springframework.amqp.rabbit.core.RabbitTemplate RabbitTemplate} if there\n * is no other bean of the same type in the context.</li>\n * <li>{@link org.springframework.amqp.rabbit.connection.CachingConnectionFactory\n * CachingConnectionFactory} instance if there is no other bean of the same type in the\n * context.</li>\n * <li>{@link org.springframework.amqp.core.AmqpAdmin } instance as long as\n * {@literal spring.rabbitmq.dynamic=true}.</li>\n * </ul>\n * <p>\n * The {@link org.springframework.amqp.rabbit.connection.CachingConnectionFactory} honors\n * the following properties:\n * <ul>\n * <li>{@literal spring.rabbitmq.port} is used to specify the port to which the client\n * should connect, and defaults to 5672.</li>\n * <li>{@literal spring.rabbitmq.username} is used to specify the (optional) username.\n * </li>\n * <li>{@literal spring.rabbitmq.password} is used to specify the (optional) password.\n * </li>\n * <li>{@literal spring.rabbitmq.host} is used to specify the host, and defaults to\n * {@literal localhost}.</li>\n * <li>{@literal spring.rabbitmq.virtualHost} is used to specify the (optional) virtual\n * host to which the client should connect.</li>\n * </ul>\n *\n * @author Greg Turnquist\n * @author Josh Long\n * @author Stephane Nicoll\n * @author Gary Russell\n * @author Phillip Webb\n * @author Artsiom Yudovin\n */\n@Configuration(proxyBeanMethods = false)\n@ConditionalOnClass({ RabbitTemplate.class, Channel.class })\n@EnableConfigurationProperties(RabbitProperties.class)\n@Import(RabbitAnnotationDrivenConfiguration.class)\npublic class RabbitAutoConfiguration {\n\t@Configuration(proxyBeanMethods = false)\n\t@ConditionalOnMissingBean(ConnectionFactory.class)\n\tprotected static class RabbitConnectionFactoryCreator {\n\t\t@Bean\n\t\tpublic CachingConnectionFactory rabbitConnectionFactory(\n\t\t\t\tRabbitProperties properties,\n\t\t\t\tObjectProvider<ConnectionNameStrategy> connectionNameStrategy)\n\t\t\t\tthrows Exception {\n\t\t\tPropertyMapper map = PropertyMapper.get();\n\t\t\tCachingConnectionFactory factory = new CachingConnectionFactory(\n\t\t\t\t\tgetRabbitConnectionFactoryBean(properties).getObject());\n\t\t\tmap.from(properties::determineAddresses).to(factory::setAddresses);\n\t\t\tmap.from(properties::isPublisherConfirms).to(factory::setPublisherConfirms);\n\t\t\tmap.from(properties::isPublisherReturns).to(factory::setPublisherReturns);\n\t\t\tRabbitProperties.Cache.Channel channel = properties.getCache().getChannel();\n\t\t\tmap.from(channel::getSize).whenNonNull().to(factory::setChannelCacheSize);\n\t\t\tmap.from(channel::getCheckoutTimeout).whenNonNull().as(Duration::toMillis)\n\t\t\t\t\t.to(factory::setChannelCheckoutTimeout);\n\t\t\tRabbitProperties.Cache.Connection connection = properties.getCache()\n\t\t\t\t\t.getConnection();\n\t\t\tmap.from(connection::getMode).whenNonNull().to(factory::setCacheMode);\n\t\t\tmap.from(connection::getSize).whenNonNull()\n\t\t\t\t\t.to(factory::setConnectionCacheSize);\n\t\t\tmap.from(connectionNameStrategy::getIfUnique).whenNonNull()\n\t\t\t\t\t.to(factory::setConnectionNameStrategy);\n\t\t\treturn factory;\n\t\t}\n\t\tprivate RabbitConnectionFactoryBean getRabbitConnectionFactoryBean(\n\t\t\t\tRabbitProperties properties) throws Exception {\n\t\t\tPropertyMapper map = PropertyMapper.get();\n\t\t\tRabbitConnectionFactoryBean factory = new RabbitConnectionFactoryBean();\n\t\t\tmap.from(properties::determineHost).whenNonNull().to(factory::setHost);\n\t\t\tmap.from(properties::determinePort).to(factory::setPort);\n\t\t\tmap.from(properties::determineUsername).whenNonNull()\n\t\t\t\t\t.to(factory::setUsername);\n\t\t\tmap.from(properties::determinePassword).whenNonNull()\n\t\t\t\t\t.to(factory::setPassword);\n\t\t\tmap.from(properties::determineVirtualHost).whenNonNull()\n\t\t\t\t\t.to(factory::setVirtualHost);\n\t\t\tmap.from(properties::getRequestedHeartbeat).whenNonNull()\n\t\t\t\t\t.asInt(Duration::getSeconds).to(factory::setRequestedHeartbeat);\n\t\t\tRabbitProperties.Ssl ssl = properties.getSsl();\n\t\t\tif (ssl.isEnabled()) {\n\t\t\t\tfactory.setUseSSL(true);\n\t\t\t\tmap.from(ssl::getAlgorithm).whenNonNull().to(factory::setSslAlgorithm);\n\t\t\t\tmap.from(ssl::getKeyStoreType).to(factory::setKeyStoreType);\n\t\t\t\tmap.from(ssl::getKeyStore).to(factory::setKeyStore);\n\t\t\t\tmap.from(ssl::getKeyStorePassword).to(factory::setKeyStorePassphrase);\n\t\t\t\tmap.from(ssl::getTrustStoreType).to(factory::setTrustStoreType);\n\t\t\t\tmap.from(ssl::getTrustStore).to(factory::setTrustStore);\n\t\t\t\tmap.from(ssl::getTrustStorePassword).to(factory::setTrustStorePassphrase);\n\t\t\t\tmap.from(ssl::isValidateServerCertificate).to((validate) -> factory\n\t\t\t\t\t\t.setSkipServerCertificateValidation(!validate));\n\t\t\t\tmap.from(ssl::getVerifyHostname)\n\t\t\t\t\t\t.to(factory::setEnableHostnameVerification);\n\t\t\t}\n\t\t\tmap.from(properties::getConnectionTimeout).whenNonNull()\n\t\t\t\t\t.asInt(Duration::toMillis).to(factory::setConnectionTimeout);\n\t\t\tfactory.afterPropertiesSet();\n\t\t\treturn factory;\n\t\t}\n\t}\n\t@Configuration(proxyBeanMethods = false)\n\t@Import(RabbitConnectionFactoryCreator.class)\n\tprotected static class RabbitTemplateConfiguration {\n\t\t@Bean\n\t\t@ConditionalOnSingleCandidate(ConnectionFactory.class)\n\t\t@ConditionalOnMissingBean\n\t\tpublic RabbitTemplate rabbitTemplate(RabbitProperties properties,\n\t\t\t\tObjectProvider<MessageConverter> messageConverter,\n\t\t\t\tObjectProvider<RabbitRetryTemplateCustomizer> retryTemplateCustomizers,\n\t\t\t\tConnectionFactory connectionFactory) {\n\t\t\tPropertyMapper map = PropertyMapper.get();\n\t\t\tRabbitTemplate template = new RabbitTemplate(connectionFactory);\n\t\t\tmessageConverter.ifUnique(template::setMessageConverter);\n\t\t\ttemplate.setMandatory(determineMandatoryFlag(properties));\n\t\t\tRabbitProperties.Template templateProperties = properties.getTemplate();\n\t\t\tif (templateProperties.getRetry().isEnabled()) {\n\t\t\t\ttemplate.setRetryTemplate(\n\t\t\t\t\t\tnew RetryTemplateFactory(retryTemplateCustomizers.orderedStream()\n\t\t\t\t\t\t\t\t.collect(Collectors.toList())).createRetryTemplate(\n\t\t\t\t\t\t\t\t\t\ttemplateProperties.getRetry(),\n\t\t\t\t\t\t\t\t\t\tRabbitRetryTemplateCustomizer.Target.SENDER));\n\t\t\t}\n\t\t\tmap.from(templateProperties::getReceiveTimeout).whenNonNull()\n\t\t\t\t\t.as(Duration::toMillis).to(template::setReceiveTimeout);\n\t\t\tmap.from(templateProperties::getReplyTimeout).whenNonNull()\n\t\t\t\t\t.as(Duration::toMillis).to(template::setReplyTimeout);\n\t\t\tmap.from(templateProperties::getExchange).to(template::setExchange);\n\t\t\tmap.from(templateProperties::getRoutingKey).to(template::setRoutingKey);\n\t\t\tmap.from(templateProperties::getDefaultReceiveQueue).whenNonNull()\n\t\t\t\t\t.to(template::setDefaultReceiveQueue);\n\t\t\treturn template;\n\t\t}\n\t\tprivate boolean determineMandatoryFlag(RabbitProperties properties) {\n\t\t\tBoolean mandatory = properties.getTemplate().getMandatory();\n\t\t\treturn (mandatory != null) ? mandatory : properties.isPublisherReturns();\n\t\t}\n\t\t@Bean\n\t\t@ConditionalOnSingleCandidate(ConnectionFactory.class)\n\t\t@ConditionalOnProperty(prefix = \"spring.rabbitmq\", name = \"dynamic\", matchIfMissing = true)\n\t\t@ConditionalOnMissingBean\n\t\tpublic AmqpAdmin amqpAdmin(ConnectionFactory connectionFactory) {\n\t\t\treturn new RabbitAdmin(connectionFactory);\n\t\t}\n\t}\n\t@Configuration(proxyBeanMethods = false)\n\t@ConditionalOnClass(RabbitMessagingTemplate.class)\n\t@ConditionalOnMissingBean(RabbitMessagingTemplate.class)\n\t@Import(RabbitTemplateConfiguration.class)\n\tprotected static class MessagingTemplateConfiguration {\n<fim_suffix>\t\t@Bean\n\t\t@ConditionalOnSingleCandidate(RabbitTemplate.class)\n\t\tpublic RabbitMessagingTemplate rabbitMessagingTemplate(\n\t\t\t\tRabbitTemplate rabbitTemplate) {\n\t\t\treturn new RabbitMessagingTemplate(rabbitTemplate);\n\t\t}<fim_middle>// function below has no smell\n"}