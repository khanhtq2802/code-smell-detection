{"text": "<fim_prefix>/**\n * Copyright (c) 2018 Contributors to the Eclipse Foundation\n *\n * See the NOTICE file(s) distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License 2.0 which is available at\n * https://www.eclipse.org/legal/epl-2.0\n *\n * SPDX-License-Identifier: EPL-2.0\n */\npackage org.eclipse.vorto.codegen.testutils;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.Predicate;\nimport java.util.stream.Collectors;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\npublic class ZipDiff {\n\n  private static Collection<String> zipFileExtensions =\n      Arrays.asList(\".zip\", \".ear\", \".war\", \".rar\", \".jar\");\n\n  public Result diff(ZipInputStream baselineZip, ZipInputStream newZip) {\n    try {\n      Map<String, ZipEntry> baseline = getZipEntries(\"\", baselineZip);\n      \n      Map<String, ZipEntry> compare = getZipEntries(\"\", newZip);\n\n      Collection<String> added = compare.entrySet().stream().filter(notIn(baseline))\n          .map(entry -> entry.getKey()).collect(Collectors.toList());\n\n      Collection<String> removed = baseline.entrySet().stream().filter(notIn(compare))\n          .map(entry -> entry.getKey()).collect(Collectors.toList());\n\n      Collection<String> unchanged = baseline.entrySet().stream().filter(in(compare))\n          .map(entry -> entry.getKey()).collect(Collectors.toList());\n\n      Collection<String> changed = baseline.entrySet().stream().filter(changedIn(compare))\n          .map(entry -> entry.getKey()).collect(Collectors.toList());\n      \n      return new Result(added, removed, changed, unchanged);\n    } catch (IOException e) {\n      throw new ZipDiffException(\"Exception while taking a diff of two zip files.\", e);\n    }\n  }\n\n  private Predicate<Map.Entry<String, ZipEntry>> notIn(Map<String, ZipEntry> items) {\n    return (item) -> {\n      ZipEntry entry = items.get(item.getKey());\n      if ((entry == null || (entry.isDirectory() != item.getValue().isDirectory())) && !item.getValue().isDirectory()) {\n        return true;\n      }\n      return false;\n    };\n  }\n\n  private Predicate<Map.Entry<String, ZipEntry>> changedIn(Map<String, ZipEntry> items) {\n    return (item) -> {\n      ZipEntry entry = items.get(item.getKey());\n      if (entry != null && entry.isDirectory() == item.getValue().isDirectory()\n          && entry.getCrc() != item.getValue().getCrc()) {\n        return true;\n      }\n\n      return false;\n    };\n  }\n  \n  private Predicate<Map.Entry<String, ZipEntry>> in(Map<String, ZipEntry> items) {\n    return (item) -> {\n      ZipEntry entry = items.get(item.getKey());\n      if (entry != null && entry.isDirectory() == item.getValue().isDirectory()\n          && entry.getCrc() == item.getValue().getCrc()) {\n        return true;\n      }\n\n      return false;\n    };\n  }\n\n  private Map<String, ZipEntry> getZipEntries(String prefix, ZipInputStream zip)\n      throws IOException {\n    Map<String, ZipEntry> zipEntries = new HashMap<String, ZipEntry>();\n    ZipEntry entry = zip.getNextEntry();\n    while (entry != null) {\n      if (isZipFile(entry)) {\n        zipEntries\n            .putAll(getZipEntries(prefix + entry.getName() + \"/\", getZipInputStream(zip, entry)));\n      } else {\n        zipEntries.put(prefix + entry.getName(), entry);\n      }\n      zip.closeEntry();\n      entry = zip.getNextEntry();\n    }\n    return zipEntries;\n  }\n\n  private boolean isZipFile(ZipEntry entry) {\n    if (entry == null || entry.getName() == null) {\n      return false;\n    }\n\n    return zipFileExtensions.stream().anyMatch(extension -> entry.getName().endsWith(extension));\n  }\n\n  private ZipInputStream getZipInputStream(ZipInputStream zip, ZipEntry entry) throws IOException {\n    byte[] zipContents = new byte[(int) entry.getSize()];\n    for(int i=0 ; i < entry.getSize(); i++) {\n      zipContents[i] = (byte) zip.read();\n    }\n    return new ZipInputStream(new ByteArrayInputStream(zipContents));\n  }\n\n  public class Result {\n    private Collection<String> added;\n    private Collection<String> removed;\n    private Collection<String> changed;\n    private Collection<String> unchanged;\n\n    public Result(Collection<String> added, Collection<String> removed, Collection<String> changed,\n        Collection<String> unchanged) {\n      this.added = added;\n      this.removed = removed;\n      this.changed = changed;\n      this.unchanged = unchanged;\n    }\n\n<fim_suffix>    public Collection<String> getAdded() {\n      return added;\n    }\n\n    public void setAdded(Collection<String> added) {\n      this.added = added;\n    }\n\n    public Collection<String> getRemoved() {\n      return removed;\n    }\n\n    public void setRemoved(Collection<String> removed) {\n      this.removed = removed;\n    }\n\n    public Collection<String> getChanged() {\n      return changed;\n    }\n\n    public void setChanged(Collection<String> changed) {\n      this.changed = changed;\n    }\n\n    public Collection<String> getUnchanged() {\n      return unchanged;\n    }\n\n    public void setUnchanged(Collection<String> unchanged) {\n      this.unchanged = unchanged;\n    }\n  }\n}<fim_middle>// function below has no smell\n"}