{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.text.similarity;\nimport java.util.Arrays;\n/**\n * An algorithm for measuring the difference between two character sequences.\n *\n * <p>\n * This is the number of changes needed to change one sequence into another,\n * where each change is a single character modification (deletion, insertion\n * or substitution).\n * </p>\n *\n * <p>\n * This code has been adapted from Apache Commons Lang 3.3.\n * </p>\n *\n * @since 1.0\n */\npublic class LevenshteinDistance implements EditDistance<Integer> {\n    /**\n     * Default instance.\n     */\n    private static final LevenshteinDistance DEFAULT_INSTANCE = new LevenshteinDistance();\n    /**\n     * Threshold.\n     */\n    private final Integer threshold;\n    /**\n     * <p>\n     * This returns the default instance that uses a version\n     * of the algorithm that does not use a threshold parameter.\n     * </p>\n     *\n     * @see LevenshteinDistance#getDefaultInstance()\n     */\n    public LevenshteinDistance() {\n        this(null);\n    }\n    /**\n     * <p>\n     * If the threshold is not null, distance calculations will be limited to a maximum length.\n     * If the threshold is null, the unlimited version of the algorithm will be used.\n     * </p>\n     *\n     * @param threshold\n     *        If this is null then distances calculations will not be limited.\n     *        This may not be negative.\n     */\n    public LevenshteinDistance(final Integer threshold) {\n        if (threshold != null && threshold < 0) {\n            throw new IllegalArgumentException(\"Threshold must not be negative\");\n        }\n        this.threshold = threshold;\n    }\n    /**\n     * <p>Find the Levenshtein distance between two Strings.</p>\n     *\n     * <p>A higher score indicates a greater distance.</p>\n     *\n     * <p>The previous implementation of the Levenshtein distance algorithm\n     * was from <a href=\"http://www.merriampark.com/ld.htm\">http://www.merriampark.com/ld.htm</a></p>\n     *\n     * <p>Chas Emerick has written an implementation in Java, which avoids an OutOfMemoryError\n     * which can occur when my Java implementation is used with very large strings.<br>\n     * This implementation of the Levenshtein distance algorithm\n     * is from <a href=\"http://www.merriampark.com/ldjava.htm\">http://www.merriampark.com/ldjava.htm</a></p>\n     *\n     * <pre>\n     * distance.apply(null, *)             = IllegalArgumentException\n     * distance.apply(*, null)             = IllegalArgumentException\n     * distance.apply(\"\",\"\")               = 0\n     * distance.apply(\"\",\"a\")              = 1\n     * distance.apply(\"aaapppp\", \"\")       = 7\n     * distance.apply(\"frog\", \"fog\")       = 1\n     * distance.apply(\"fly\", \"ant\")        = 3\n     * distance.apply(\"elephant\", \"hippo\") = 7\n     * distance.apply(\"hippo\", \"elephant\") = 7\n     * distance.apply(\"hippo\", \"zzzzzzzz\") = 8\n     * distance.apply(\"hello\", \"hallo\")    = 1\n     * </pre>\n     *\n     * @param left the first string, must not be null\n     * @param right the second string, must not be null\n     * @return result distance, or -1\n     * @throws IllegalArgumentException if either String input {@code null}\n     */\n    @Override\n    public Integer apply(final CharSequence left, final CharSequence right) {\n        if (threshold != null) {\n            return limitedCompare(left, right, threshold);\n        }\n        return unlimitedCompare(left, right);\n    }\n    /**\n     * Gets the default instance.\n     *\n     * @return the default instance\n     */\n    public static LevenshteinDistance getDefaultInstance() {\n        return DEFAULT_INSTANCE;\n    }\n    /**\n     * Gets the distance threshold.\n     *\n     * @return the distance threshold\n     */\n<fim_suffix>    public Integer getThreshold() {\n        return threshold;\n    }\n    /**\n     * Find the Levenshtein distance between two CharSequences if it's less than or\n     * equal to a given threshold.\n     *\n     * <p>\n     * This implementation follows from Algorithms on Strings, Trees and\n     * Sequences by Dan Gusfield and Chas Emerick's implementation of the\n     * Levenshtein distance algorithm from <a\n     * href=\"http://www.merriampark.com/ld.htm\"\n     * >http://www.merriampark.com/ld.htm</a>\n     * </p>\n     *\n     * <pre>\n     * limitedCompare(null, *, *)             = IllegalArgumentException\n     * limitedCompare(*, null, *)             = IllegalArgumentException\n     * limitedCompare(*, *, -1)               = IllegalArgumentException\n     * limitedCompare(\"\",\"\", 0)               = 0\n     * limitedCompare(\"aaapppp\", \"\", 8)       = 7\n     * limitedCompare(\"aaapppp\", \"\", 7)       = 7\n     * limitedCompare(\"aaapppp\", \"\", 6))      = -1\n     * limitedCompare(\"elephant\", \"hippo\", 7) = 7\n     * limitedCompare(\"elephant\", \"hippo\", 6) = -1\n     * limitedCompare(\"hippo\", \"elephant\", 7) = 7\n     * limitedCompare(\"hippo\", \"elephant\", 6) = -1\n     * </pre>\n     *\n     * @param left the first CharSequence, must not be null\n     * @param right the second CharSequence, must not be null\n     * @param threshold the target threshold, must not be negative\n     * @return result distance, or -1\n     */\n    private static int limitedCompare(CharSequence left, CharSequence right, final int threshold) { // NOPMD\n        if (left == null || right == null) {\n            throw new IllegalArgumentException(\"CharSequences must not be null\");\n        }\n        if (threshold < 0) {\n            throw new IllegalArgumentException(\"Threshold must not be negative\");\n        }\n        /*\n         * This implementation only computes the distance if it's less than or\n         * equal to the threshold value, returning -1 if it's greater. The\n         * advantage is performance: unbounded distance is O(nm), but a bound of\n         * k allows us to reduce it to O(km) time by only computing a diagonal\n         * stripe of width 2k + 1 of the cost table. It is also possible to use\n         * this to compute the unbounded Levenshtein distance by starting the\n         * threshold at 1 and doubling each time until the distance is found;\n         * this is O(dm), where d is the distance.\n         *\n         * One subtlety comes from needing to ignore entries on the border of\n         * our stripe eg. p[] = |#|#|#|* d[] = *|#|#|#| We must ignore the entry\n         * to the left of the leftmost member We must ignore the entry above the\n         * rightmost member\n         *\n         * Another subtlety comes from our stripe running off the matrix if the\n         * strings aren't of the same size. Since string s is always swapped to\n         * be the shorter of the two, the stripe will always run off to the\n         * upper right instead of the lower left of the matrix.\n         *\n         * As a concrete example, suppose s is of length 5, t is of length 7,\n         * and our threshold is 1. In this case we're going to walk a stripe of\n         * length 3. The matrix would look like so:\n         *\n         * <pre>\n         *    1 2 3 4 5\n         * 1 |#|#| | | |\n         * 2 |#|#|#| | |\n         * 3 | |#|#|#| |\n         * 4 | | |#|#|#|\n         * 5 | | | |#|#|\n         * 6 | | | | |#|\n         * 7 | | | | | |\n         * </pre>\n         *\n         * Note how the stripe leads off the table as there is no possible way<fim_middle>// function below has no smell\n"}