{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.lucene.document;\n\n\nimport java.io.IOException;\n\nimport org.apache.lucene.index.DocValues;\nimport org.apache.lucene.index.DocValuesType;\nimport org.apache.lucene.index.LeafReader;\nimport org.apache.lucene.index.SortedSetDocValues;\nimport org.apache.lucene.search.IndexOrDocValuesQuery;\nimport org.apache.lucene.search.Query;\nimport org.apache.lucene.util.BytesRef;\n\n/**\n * <p>\n * Field that stores\n * a per-document {@link BytesRef} value, indexed for\n * sorting.  Here's an example usage:\n * \n * <pre class=\"prettyprint\">\n *   document.add(new SortedDocValuesField(name, new BytesRef(\"hello\")));\n * </pre>\n * \n * <p>\n * If you also need to store the value, you should add a\n * separate {@link StoredField} instance.\n *\n * <p>\n * This value can be at most 32766 bytes long.\n * */\n\n<fim_suffix>public class SortedDocValuesField extends Field {\n\n  /**\n   * Type for sorted bytes DocValues\n   */\n  public static final FieldType TYPE = new FieldType();\n  static {\n    TYPE.setDocValuesType(DocValuesType.SORTED);\n    TYPE.freeze();\n  }\n\n  /**\n   * Create a new sorted DocValues field.\n   * @param name field name\n   * @param bytes binary content\n   * @throws IllegalArgumentException if the field name is null\n   */\n  public SortedDocValuesField(String name, BytesRef bytes) {\n    super(name, TYPE);\n    fieldsData = bytes;\n  }\n\n  /**\n   * Create a range query that matches all documents whose value is between\n   * {@code lowerValue} and {@code upperValue} included.\n   * <p>\n   * You can have half-open ranges by setting {@code lowerValue = null}\n   * or {@code upperValue = null}.\n   * <p><b>NOTE</b>: Such queries cannot efficiently advance to the next match,\n   * which makes them slow if they are not ANDed with a selective query. As a\n   * consequence, they are best used wrapped in an {@link IndexOrDocValuesQuery},\n   * alongside a range query that executes on points, such as\n   * {@link BinaryPoint#newRangeQuery}.\n   */\n  public static Query newSlowRangeQuery(String field,\n      BytesRef lowerValue, BytesRef upperValue,\n      boolean lowerInclusive, boolean upperInclusive) {\n    return new SortedSetDocValuesRangeQuery(field, lowerValue, upperValue, lowerInclusive, upperInclusive) {\n      @Override\n      SortedSetDocValues getValues(LeafReader reader, String field) throws IOException {\n        return DocValues.singleton(DocValues.getSorted(reader, field));\n      }\n    };\n  }\n\n  /** \n   * Create a query for matching an exact {@link BytesRef} value.\n   * <p><b>NOTE</b>: Such queries cannot efficiently advance to the next match,\n   * which makes them slow if they are not ANDed with a selective query. As a\n   * consequence, they are best used wrapped in an {@link IndexOrDocValuesQuery},\n   * alongside a range query that executes on points, such as\n   * {@link BinaryPoint#newExactQuery}.\n   */\n  public static Query newSlowExactQuery(String field, BytesRef value) {\n    return newSlowRangeQuery(field, value, value, true, true);\n  }\n}<fim_middle>// class below has no smell\n"}