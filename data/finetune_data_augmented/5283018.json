{"text": "<fim_prefix>        if (exps.grouping.length == 0 && exps.isAggregate()) {\n            Object[] projection = project(matches, exps, true, ctx, params);\n            return Arrays.asList(new Object[]{ projection });\n        }\n        // evaluate each candidate\n        List projected = new ArrayList(matches.size());\n        for (Iterator itr = matches.iterator(); itr.hasNext();)\n            projected.add(project(itr.next(), exps, exps.grouping.length > 0,\n                ctx, params));\n        return projected;\n    }\n    /**\n     * Generate a projection on the given candidate.\n     */\n    private Object[] project(Object candidate, QueryExpressions exps,\n        boolean agg, StoreContext ctx, Object[] params) {\n        Object[] projection = new Object[exps.projections.length\n            + exps.ordering.length];\n        // calcualte result values\n        Object result = null;\n        for (int i = 0; i < exps.projections.length; i++) {\n            if (agg)\n                result = ((Val) exps.projections[i]).evaluate((Collection)\n                    candidate, null, ctx, params);\n            else\n                result = ((Val) exps.projections[i]).evaluate(candidate,\n                    candidate, ctx, params);\n            projection[i] = result;\n        }\n        // tack on ordering values\n        boolean repeat;\n        for (int i = 0; i < exps.ordering.length; i++) {\n            // already selected as a result?\n            repeat = false;\n            for (int j = 0; !repeat && j < exps.projections.length; j++) {\n                if (exps.orderingClauses[i].equals(exps.projectionClauses[j])) {\n                    result = projection[j];\n                    repeat = true;\n                }\n            }\n            // not selected as result; calculate value\n            if (!repeat) {\n                if (agg)\n                    result = ((Val) exps.ordering[i]).evaluate((Collection)\n                        candidate, null, ctx, params);\n                else\n                    result = ((Val) exps.ordering[i]).evaluate(candidate,\n                        candidate, ctx, params);\n            }\n            projection[i + exps.projections.length] = result;\n        }\n        return projection;\n    }\n    /**\n     * Order the given list of matches on the given value.\n     */\n    public List order(QueryExpressions exps, List matches,\n        StoreContext ctx, Object[] params) {\n        return order(exps, exps.ordering, true, matches, ctx, params);\n    }\n    /**\n     * Order the given list of matches on the given value.\n     *\n     * @param projected whether projections have been applied to the matches yet\n     */\n    private List order(QueryExpressions exps, Value[] orderValues,\n        boolean projected, List matches, StoreContext ctx, Object[] params) {\n        if (matches == null || matches.isEmpty()\n            || orderValues == null || orderValues.length == 0)\n            return matches;\n        int results = (projected) ? exps.projections.length : 0;\n        boolean[] asc = (projected) ? exps.ascending : null;\n        int idx;\n        for (int i = orderValues.length - 1; i >= 0; i--) {\n            // if this is a projection, then in project() we must have selected\n            // the ordering value already after the projection values\n            idx = (results > 0) ? results + i : -1;\n            Collections.sort(matches,\n                new OrderValueComparator((Val) orderValues[i],\n                    asc == null || asc[i], idx, ctx, params));\n        }\n        return matches;\n    }\n    /**\n     * Filter the given list of matches, removing duplicate entries.\n     */\n    public List distinct(QueryExpressions exps, boolean fromExtent,\n        List matches) {\n        if (matches == null || matches.isEmpty())\n            return matches;\n        // no need to do distinct if not instructed to, or if these are\n        // candidate objects from an extent\n        int len = exps.projections.length;\n        if ((exps.distinct & QueryExpressions.DISTINCT_TRUE) == 0\n            || (fromExtent && len == 0))\n            return matches;\n        Set seen = new HashSet(matches.size());\n        List distinct = null;\n        Object cur;\n        Object key;\n        for (ListIterator li = matches.listIterator(); li.hasNext();) {\n            cur = li.next();\n            key = (len > 0 && cur != null) ? new ArrayKey((Object[]) cur) : cur;\n            if (seen.add(key)) {\n                // key hasn't been seen before; if we've created a distinct\n                // list, keep adding to it\n                if (distinct != null)\n                    distinct.add(cur);\n            } else if (distinct == null) {\n                // we need to copy the matches list because the distinct list\n                // will be different (we've come across a non-unique key); add\n                // all the elements we've skipped over so far\n                distinct = new ArrayList(matches.size());\n                distinct.addAll(matches.subList(0, li.previousIndex()));\n            }\n        }\n        return (distinct == null) ? matches : distinct;\n    }\n    @Override\n    public Expression emptyExpression() {\n        return new Exp();\n    }\n    @Override\n    public Expression asExpression(Value v) {\n        return new ValExpression((Val) v);\n    }\n    @Override\n    public Expression equal(Value v1, Value v2) {\n        return new EqualExpression((Val) v1, (Val) v2);\n    }\n    @Override\n    public Expression notEqual(Value v1, Value v2) {\n        return new NotEqualExpression((Val) v1, (Val) v2);\n    }\n    @Override\n    public Expression lessThan(Value v1, Value v2) {\n        return new LessThanExpression((Val) v1, (Val) v2);\n    }\n    @Override\n    public Expression greaterThan(Value v1, Value v2) {\n        return new GreaterThanExpression((Val) v1, (Val) v2);\n    }\n    @Override\n    public Expression lessThanEqual(Value v1, Value v2) {\n        return new LessThanEqualExpression((Val) v1, (Val) v2);\n    }\n    @Override\n    public Expression greaterThanEqual(Value v1, Value v2) {\n        return new GreaterThanEqualExpression((Val) v1, (Val) v2);\n    }\n    @Override\n    public Expression isEmpty(Value v1) {\n        return new IsEmptyExpression((Val) v1);\n    }\n    @Override\n    public Expression isNotEmpty(Value v1) {\n        return not(isEmpty(v1));\n    }\n    @Override\n    public Expression contains(Value v1, Value v2) {\n        return new ContainsExpression((Val) v1, (Val) v2);\n    }\n    @Override\n    public Expression containsKey(Value v1, Value v2) {\n        return new ContainsKeyExpression((Val) v1, (Val) v2);\n    }\n    @Override\n    public Expression containsValue(Value v1, Value v2) {\n        return new ContainsValueExpression((Val) v1, (Val) v2);\n    }\n    @Override\n    public Value getMapValue(Value map, Value arg) {\n        return new GetMapValue((Val) map, (Val) arg);\n    }\n    @Override\n    public Expression isInstance(Value v1, Class c) {\n        return new InstanceofExpression((Val) v1, c);\n    }\n    @Override\n    public Expression and(Expression exp1, Expression exp2) {\n        if (exp1 instanceof BindVariableExpression)\n            return new BindVariableAndExpression((BindVariableExpression) exp1,\n                (Exp) exp2);\n        return new AndExpression((Exp) exp1, (Exp) exp2);\n    }\n    @Override\n    public Expression or(Expression exp1, Expression exp2) {\n        return new OrExpression((Exp) exp1, (Exp) exp2);\n    }\n    @Override\n    public Expression not(Expression exp) {\n        return new NotExpression((Exp) exp);\n    }\n    @Override\n    public Expression bindVariable(Value var, Value val) {\n        return new BindVariableExpression((BoundVariable) var, (Val) val);\n    }\n    @Override\n    public Expression bindKeyVariable(Value var, Value val) {\n        return new BindKeyVariableExpression((BoundVariable) var, (Val) val);\n    }\n    @Override\n    public Expression bindValueVariable(Value var, Value val) {\n        return new BindValueVariableExpression((BoundVariable) var, (Val) val);\n    }\n    @Override\n    public Expression endsWith(Value v1, Value v2) {\n        return new EndsWithExpression((Val) v1, (Val) v2);\n    }\n<fim_suffix>    @Override\n    public Expression matches(Value v1, Value v2,\n        String single, String multi, String esc) {\n        return new MatchesExpression((Val) v1, (Val) v2, single, multi, esc,\n            true);\n    }<fim_middle>// function below has no smell\n"}