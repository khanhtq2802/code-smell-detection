{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.hadoop.hbase.snapshot;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InterruptedIOException;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorCompletionService;\nimport java.util.concurrent.ExecutorService;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.fs.FileStatus;\nimport org.apache.hadoop.fs.FileSystem;\nimport org.apache.hadoop.fs.Path;\nimport org.apache.hadoop.hbase.TableName;\nimport org.apache.hadoop.hbase.client.RegionInfo;\nimport org.apache.hadoop.hbase.io.HFileLink;\nimport org.apache.hadoop.hbase.mob.MobUtils;\nimport org.apache.hadoop.hbase.regionserver.StoreFileInfo;\nimport org.apache.hadoop.hbase.util.HFileArchiveUtil;\nimport org.apache.yetus.audience.InterfaceAudience;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.apache.hadoop.hbase.shaded.protobuf.ProtobufUtil;\nimport org.apache.hadoop.hbase.shaded.protobuf.generated.SnapshotProtos.SnapshotDescription;\nimport org.apache.hadoop.hbase.shaded.protobuf.generated.SnapshotProtos.SnapshotRegionManifest;\n/**\n * Utility methods for interacting with the snapshot referenced files.\n */\n@InterfaceAudience.Private\npublic final class SnapshotReferenceUtil {\n  private static final Logger LOG = LoggerFactory.getLogger(SnapshotReferenceUtil.class);\n  public interface StoreFileVisitor {\n    void storeFile(final RegionInfo regionInfo, final String familyName,\n       final SnapshotRegionManifest.StoreFile storeFile) throws IOException;\n  }\n  public interface SnapshotVisitor extends StoreFileVisitor {\n  }\n  private SnapshotReferenceUtil() {\n    // private constructor for utility class\n  }\n  /**\n   * Iterate over the snapshot store files\n   *\n   * @param conf The current {@link Configuration} instance.\n   * @param fs {@link FileSystem}\n   * @param snapshotDir {@link Path} to the Snapshot directory\n   * @param visitor callback object to get the referenced files\n   * @throws IOException if an error occurred while scanning the directory\n   */\n  public static void visitReferencedFiles(final Configuration conf, final FileSystem fs,\n      final Path snapshotDir, final SnapshotVisitor visitor)\n      throws IOException {\n    SnapshotDescription desc = SnapshotDescriptionUtils.readSnapshotInfo(fs, snapshotDir);\n    visitReferencedFiles(conf, fs, snapshotDir, desc, visitor);\n  }\n  /**\n   * Iterate over the snapshot store files, restored.edits and logs\n   *\n   * @param conf The current {@link Configuration} instance.\n   * @param fs {@link FileSystem}\n   * @param snapshotDir {@link Path} to the Snapshot directory\n   * @param desc the {@link SnapshotDescription} of the snapshot to verify\n   * @param visitor callback object to get the referenced files\n   * @throws IOException if an error occurred while scanning the directory\n   */\n  public static void visitReferencedFiles(final Configuration conf, final FileSystem fs,\n      final Path snapshotDir, final SnapshotDescription desc, final SnapshotVisitor visitor)\n      throws IOException {\n    visitTableStoreFiles(conf, fs, snapshotDir, desc, visitor);\n  }\n  /**\u00a9\n   * Iterate over the snapshot store files\n   *\n   * @param conf The current {@link Configuration} instance.\n   * @param fs {@link FileSystem}\n   * @param snapshotDir {@link Path} to the Snapshot directory\n   * @param desc the {@link SnapshotDescription} of the snapshot to verify\n   * @param visitor callback object to get the store files\n   * @throws IOException if an error occurred while scanning the directory\n   */\n  static void visitTableStoreFiles(final Configuration conf, final FileSystem fs,\n      final Path snapshotDir, final SnapshotDescription desc, final StoreFileVisitor visitor)\n      throws IOException {\n    SnapshotManifest manifest = SnapshotManifest.open(conf, fs, snapshotDir, desc);\n    List<SnapshotRegionManifest> regionManifests = manifest.getRegionManifests();\n    if (regionManifests == null || regionManifests.isEmpty()) {\n      LOG.debug(\"No manifest files present: \" + snapshotDir);\n      return;\n    }\n    for (SnapshotRegionManifest regionManifest: regionManifests) {\n      visitRegionStoreFiles(regionManifest, visitor);\n    }\n  }\n  /**\n   * Iterate over the snapshot store files in the specified region\n   *\n   * @param manifest snapshot manifest to inspect\n   * @param visitor callback object to get the store files\n   * @throws IOException if an error occurred while scanning the directory\n   */\n  static void visitRegionStoreFiles(final SnapshotRegionManifest manifest,\n      final StoreFileVisitor visitor) throws IOException {\n    RegionInfo regionInfo = ProtobufUtil.toRegionInfo(manifest.getRegionInfo());\n    for (SnapshotRegionManifest.FamilyFiles familyFiles: manifest.getFamilyFilesList()) {\n      String familyName = familyFiles.getFamilyName().toStringUtf8();\n      for (SnapshotRegionManifest.StoreFile storeFile: familyFiles.getStoreFilesList()) {\n        visitor.storeFile(regionInfo, familyName, storeFile);\n      }\n    }\n  }\n  /**\n   * Verify the validity of the snapshot\n   *\n   * @param conf The current {@link Configuration} instance.\n   * @param fs {@link FileSystem}\n   * @param snapshotDir {@link Path} to the Snapshot directory of the snapshot to verify\n   * @param snapshotDesc the {@link SnapshotDescription} of the snapshot to verify\n   * @throws CorruptedSnapshotException if the snapshot is corrupted\n   * @throws IOException if an error occurred while scanning the directory\n   */\n  public static void verifySnapshot(final Configuration conf, final FileSystem fs,\n      final Path snapshotDir, final SnapshotDescription snapshotDesc) throws IOException {\n    SnapshotManifest manifest = SnapshotManifest.open(conf, fs, snapshotDir, snapshotDesc);\n    verifySnapshot(conf, fs, manifest);\n  }\n  /**\n   * Verify the validity of the snapshot\n   *\n   * @param conf The current {@link Configuration} instance.\n   * @param fs {@link FileSystem}\n   * @param manifest snapshot manifest to inspect\n   * @throws CorruptedSnapshotException if the snapshot is corrupted\n   * @throws IOException if an error occurred while scanning the directory\n   */\n  public static void verifySnapshot(final Configuration conf, final FileSystem fs,\n      final SnapshotManifest manifest) throws IOException {\n    final SnapshotDescription snapshotDesc = manifest.getSnapshotDescription();\n    final Path snapshotDir = manifest.getSnapshotDir();\n    concurrentVisitReferencedFiles(conf, fs, manifest, \"VerifySnapshot\", new StoreFileVisitor() {\n      @Override\n      public void storeFile(final RegionInfo regionInfo, final String family,\n          final SnapshotRegionManifest.StoreFile storeFile) throws IOException {\n        verifyStoreFile(conf, fs, snapshotDir, snapshotDesc, regionInfo, family, storeFile);\n      }\n    });\n  }\n<fim_suffix>  public static void concurrentVisitReferencedFiles(final Configuration conf, final FileSystem fs,\n      final SnapshotManifest manifest, final String desc, final StoreFileVisitor visitor)\n      throws IOException {\n    final Path snapshotDir = manifest.getSnapshotDir();\n    List<SnapshotRegionManifest> regionManifests = manifest.getRegionManifests();\n    if (regionManifests == null || regionManifests.isEmpty()) {\n      LOG.debug(\"No manifest files present: \" + snapshotDir);\n      return;\n    }\n    ExecutorService exec = SnapshotManifest.createExecutor(conf, desc);\n    try {\n      concurrentVisitReferencedFiles(conf, fs, manifest, exec, visitor);\n    } finally {\n      exec.shutdown();\n    }\n  }\n  public static void concurrentVisitReferencedFiles(final Configuration conf, final FileSystem fs,\n      final SnapshotManifest manifest, final ExecutorService exec, final StoreFileVisitor visitor)\n      throws IOException {\n    final SnapshotDescription snapshotDesc = manifest.getSnapshotDescription();\n    final Path snapshotDir = manifest.getSnapshotDir();\n    List<SnapshotRegionManifest> regionManifests = manifest.getRegionManifests();\n    if (regionManifests == null || regionManifests.isEmpty()) {\n      LOG.debug(\"No manifest files present: \" + snapshotDir);\n      return;\n    }\n    final ExecutorCompletionService<Void> completionService = new ExecutorCompletionService<>(exec);\n    for (final SnapshotRegionManifest regionManifest : regionManifests) {\n      completionService.submit(new Callable<Void>() {\n        @Override public Void call() throws IOException {<fim_middle>// function below has no smell\n"}