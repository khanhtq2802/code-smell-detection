{"text": "<fim_prefix>        FastMathCalc.printarray(out, \"EXP_FRAC_TABLE_A\", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_A);\n        FastMathCalc.printarray(out, \"EXP_FRAC_TABLE_B\", EXP_FRAC_TABLE_LEN, ExpFracTable.EXP_FRAC_TABLE_B);\n        FastMathCalc.printarray(out, \"LN_MANT\",LN_MANT_LEN, lnMant.LN_MANT);\n        FastMathCalc.printarray(out, \"SINE_TABLE_A\", SINE_TABLE_LEN, SINE_TABLE_A);\n        FastMathCalc.printarray(out, \"SINE_TABLE_B\", SINE_TABLE_LEN, SINE_TABLE_B);\n        FastMathCalc.printarray(out, \"COSINE_TABLE_A\", SINE_TABLE_LEN, COSINE_TABLE_A);\n        FastMathCalc.printarray(out, \"COSINE_TABLE_B\", SINE_TABLE_LEN, COSINE_TABLE_B);\n        FastMathCalc.printarray(out, \"TANGENT_TABLE_A\", SINE_TABLE_LEN, TANGENT_TABLE_A);\n        FastMathCalc.printarray(out, \"TANGENT_TABLE_B\", SINE_TABLE_LEN, TANGENT_TABLE_B);\n    }\n    /** Enclose large data table in nested static class so it's only loaded on first access. */\n    private static class ExpIntTable {\n        /** Exponential evaluated at integer values,\n         * exp(x) =  expIntTableA[x + EXP_INT_TABLE_MAX_INDEX] + expIntTableB[x+EXP_INT_TABLE_MAX_INDEX].\n         */\n        private static final double[] EXP_INT_TABLE_A;\n        /** Exponential evaluated at integer values,\n         * exp(x) =  expIntTableA[x + EXP_INT_TABLE_MAX_INDEX] + expIntTableB[x+EXP_INT_TABLE_MAX_INDEX]\n         */\n        private static final double[] EXP_INT_TABLE_B;\n        static {\n            if (RECOMPUTE_TABLES_AT_RUNTIME) {\n                EXP_INT_TABLE_A = new double[FastMath.EXP_INT_TABLE_LEN];\n                EXP_INT_TABLE_B = new double[FastMath.EXP_INT_TABLE_LEN];\n                final double tmp[] = new double[2];\n                final double recip[] = new double[2];\n                // Populate expIntTable\n                for (int i = 0; i < FastMath.EXP_INT_TABLE_MAX_INDEX; i++) {\n                    FastMathCalc.expint(i, tmp);\n                    EXP_INT_TABLE_A[i + FastMath.EXP_INT_TABLE_MAX_INDEX] = tmp[0];\n                    EXP_INT_TABLE_B[i + FastMath.EXP_INT_TABLE_MAX_INDEX] = tmp[1];\n                    if (i != 0) {\n                        // Negative integer powers\n                        FastMathCalc.splitReciprocal(tmp, recip);\n                        EXP_INT_TABLE_A[FastMath.EXP_INT_TABLE_MAX_INDEX - i] = recip[0];\n                        EXP_INT_TABLE_B[FastMath.EXP_INT_TABLE_MAX_INDEX - i] = recip[1];\n                    }\n                }\n            } else {\n                EXP_INT_TABLE_A = FastMathLiteralArrays.loadExpIntA();\n                EXP_INT_TABLE_B = FastMathLiteralArrays.loadExpIntB();\n            }\n        }\n    }\n    /** Enclose large data table in nested static class so it's only loaded on first access. */\n    private static class ExpFracTable {\n        /** Exponential over the range of 0 - 1 in increments of 2^-10\n         * exp(x/1024) =  expFracTableA[x] + expFracTableB[x].\n         * 1024 = 2^10\n         */\n        private static final double[] EXP_FRAC_TABLE_A;\n        /** Exponential over the range of 0 - 1 in increments of 2^-10\n         * exp(x/1024) =  expFracTableA[x] + expFracTableB[x].\n         */\n        private static final double[] EXP_FRAC_TABLE_B;\n        static {\n            if (RECOMPUTE_TABLES_AT_RUNTIME) {\n                EXP_FRAC_TABLE_A = new double[FastMath.EXP_FRAC_TABLE_LEN];\n                EXP_FRAC_TABLE_B = new double[FastMath.EXP_FRAC_TABLE_LEN];\n                final double tmp[] = new double[2];\n                // Populate expFracTable\n                final double factor = 1d / (EXP_FRAC_TABLE_LEN - 1);\n                for (int i = 0; i < EXP_FRAC_TABLE_A.length; i++) {\n                    FastMathCalc.slowexp(i * factor, tmp);\n                    EXP_FRAC_TABLE_A[i] = tmp[0];\n                    EXP_FRAC_TABLE_B[i] = tmp[1];\n                }\n            } else {\n                EXP_FRAC_TABLE_A = FastMathLiteralArrays.loadExpFracA();\n                EXP_FRAC_TABLE_B = FastMathLiteralArrays.loadExpFracB();\n            }\n        }\n    }\n    /** Enclose large data table in nested static class so it's only loaded on first access. */\n    private static class lnMant {\n        /** Extended precision logarithm table over the range 1 - 2 in increments of 2^-10. */\n        private static final double[][] LN_MANT;\n        static {\n            if (RECOMPUTE_TABLES_AT_RUNTIME) {\n                LN_MANT = new double[FastMath.LN_MANT_LEN][];\n                // Populate lnMant table\n                for (int i = 0; i < LN_MANT.length; i++) {\n                    final double d = Double.longBitsToDouble( (((long) i) << 42) | 0x3ff0000000000000L );\n                    LN_MANT[i] = FastMathCalc.slowLog(d);\n                }\n            } else {\n                LN_MANT = FastMathLiteralArrays.loadLnMant();\n            }\n        }\n    }\n    /** Enclose the Cody/Waite reduction (used in \"sin\", \"cos\" and \"tan\"). */\n    private static class CodyWaite {\n        /** k */\n        private final int finalK;\n        /** remA */\n        private final double finalRemA;\n        /** remB */\n        private final double finalRemB;\n        /**\n         * @param xa Argument.\n         */\n        CodyWaite(double xa) {\n            // Estimate k.\n            //k = (int)(xa / 1.5707963267948966);\n            int k = (int)(xa * 0.6366197723675814);\n            // Compute remainder.\n            double remA;\n            double remB;\n            while (true) {\n                double a = -k * 1.570796251296997;\n                remA = xa + a;\n                remB = -(remA - xa - a);\n                a = -k * 7.549789948768648E-8;\n                double b = remA;\n                remA = a + b;\n                remB += -(remA - b - a);\n                a = -k * 6.123233995736766E-17;\n                b = remA;\n                remA = a + b;\n                remB += -(remA - b - a);\n                if (remA > 0) {\n                    break;\n                }\n                // Remainder is negative, so decrement k and try again.\n                // This should only happen if the input is very close\n                // to an even multiple of pi/2.\n                --k;\n            }\n            this.finalK = k;\n            this.finalRemA = remA;\n            this.finalRemB = remB;\n        }\n        /**\n         * @return k\n         */\n        int getK() {\n            return finalK;\n        }\n        /**\n         * @return remA\n         */\n        double getRemA() {\n            return finalRemA;\n        }\n        /**\n         * @return remB\n         */\n<fim_suffix>        double getRemB() {\n            return finalRemB;\n        }<fim_middle>// function below has no smell\n"}