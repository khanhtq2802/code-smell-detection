{"text": "<fim_prefix> * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.olingo.server.tecsvc.async;\nimport org.apache.olingo.commons.api.ex.ODataRuntimeException;\nimport org.apache.olingo.commons.api.format.ContentType;\nimport org.apache.olingo.commons.api.format.PreferenceName;\nimport org.apache.olingo.commons.api.http.HttpHeader;\nimport org.apache.olingo.commons.api.http.HttpStatusCode;\nimport org.apache.olingo.server.api.OData;\nimport org.apache.olingo.server.api.ODataApplicationException;\nimport org.apache.olingo.server.api.ODataLibraryException;\nimport org.apache.olingo.server.api.ODataRequest;\nimport org.apache.olingo.server.api.ODataResponse;\nimport org.apache.olingo.server.api.processor.Processor;\nimport org.apache.olingo.server.api.serializer.SerializerException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.reflect.InvocationTargetException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.Channels;\nimport java.nio.channels.ReadableByteChannel;\nimport java.nio.channels.WritableByteChannel;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n/**\n * The TechnicalAsyncService provides asynchronous support for any Processor.\n * To use it following steps are necessary:\n * <ul>\n *   <li>Get the instance</li>\n *   <li>Create an instance of the Processor which should be wrapped for asynchronous support\n *   (do not forget to call the <code>init(...)</code> method on the processor)</li>\n *   <li>register the Processor instance via the <code>register(...)</code> method</li>\n *   <li>prepare the corresponding method with the request parameters via the\n *   <code>prepareFor()</code> method at the AsyncProcessor</li>\n *   <li>start the async processing via the <code>processAsync()</code> methods</li>\n * </ul>\n * A short code snippet is shown below:\n * <pre>\n * <code>\n * TechnicalAsyncService asyncService = TechnicalAsyncService.getInstance();\n * TechnicalEntityProcessor processor = new TechnicalEntityProcessor(dataProvider, serviceMetadata);\n * processor.init(odata, serviceMetadata);\n * AsyncProcessor<EntityProcessor> asyncProcessor = asyncService.register(processor, EntityProcessor.class);\n * asyncProcessor.prepareFor().readEntity(request, response, uriInfo, requestedFormat);\n * String location = asyncProcessor.processAsync();\n * </code>\n * </pre>\n */\npublic class TechnicalAsyncService {\n  public static final String TEC_ASYNC_SLEEP = \"tec.sleep\";\n  public static final String STATUS_MONITOR_TOKEN = \"status\";\n  private static final Map<String, AsyncRunner> LOCATION_2_ASYNC_RUNNER =\n      Collections.synchronizedMap(new HashMap<String, AsyncRunner>());\n  private static final ExecutorService ASYNC_REQUEST_EXECUTOR = Executors.newFixedThreadPool(10);\n  private static final AtomicInteger ID_GENERATOR = new AtomicInteger();\n  public <T extends Processor> AsyncProcessor<T> register(T processor, Class<T> processorInterface) {\n    return new AsyncProcessor<T>(processor, processorInterface, this);\n  }\n  public static void updateHeader(ODataResponse response, HttpStatusCode status, String location) {\n    response.setStatusCode(status.getStatusCode());\n    response.setHeader(HttpHeader.LOCATION, location);\n    response.setHeader(HttpHeader.PREFERENCE_APPLIED, PreferenceName.RESPOND_ASYNC.toString());\n  }\n  public static void acceptedResponse(ODataResponse response, String location) {\n    updateHeader(response, HttpStatusCode.ACCEPTED, location);\n  }\n  private static final class AsyncProcessorHolder {\n    private static final TechnicalAsyncService INSTANCE = new TechnicalAsyncService();\n  }\n  public static TechnicalAsyncService getInstance() {\n    return AsyncProcessorHolder.INSTANCE;\n  }\n  public void shutdownThreadPool() {\n    ASYNC_REQUEST_EXECUTOR.shutdown();\n  }\n  public boolean isStatusMonitorResource(HttpServletRequest request) {\n    return request.getRequestURL() != null && request.getRequestURL().toString().contains(STATUS_MONITOR_TOKEN);\n  }\n  String processAsynchronous(AsyncProcessor<?> dispatchedProcessor)\n      throws ODataApplicationException, ODataLibraryException {\n    // use executor thread pool\n    String location = createNewAsyncLocation(dispatchedProcessor.getRequest());\n    dispatchedProcessor.setLocation(location);\n    AsyncRunner run = new AsyncRunner(dispatchedProcessor);\n    LOCATION_2_ASYNC_RUNNER.put(location, run);\n    ASYNC_REQUEST_EXECUTOR.execute(run);\n    //\n    return location;\n  }\n  public void handle(HttpServletRequest request, HttpServletResponse response) throws SerializerException, IOException {\n    String location = getAsyncLocation(request);\n    AsyncRunner runner = LOCATION_2_ASYNC_RUNNER.get(location);\n    if (runner == null) {\n      response.setStatus(HttpStatusCode.NOT_FOUND.getStatusCode());\n    } else {\n      if (runner.isFinished()) {\n        ODataResponse wrapResult = runner.getDispatched().getProcessResponse();\n        wrapToAsyncHttpResponse(wrapResult, response);\n        LOCATION_2_ASYNC_RUNNER.remove(location);\n      } else {\n        response.setStatus(HttpStatusCode.ACCEPTED.getStatusCode());\n        response.setHeader(HttpHeader.LOCATION, location);\n      }\n    }\n  }\n  public void listQueue(HttpServletResponse response) {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"<html><header/><body><h1>Queued requests</h1><ul>\");\n    for (Map.Entry<String, AsyncRunner> entry : LOCATION_2_ASYNC_RUNNER.entrySet()) {\n      AsyncProcessor<?> asyncProcessor = entry.getValue().getDispatched();\n      sb.append(\"<li><b>ID: </b>\").append(entry.getKey()).append(\"<br/>\")\n          .append(\"<b>Location: </b><a href=\\\"\")\n          .append(asyncProcessor.getLocation()).append(\"\\\">\")\n          .append(asyncProcessor.getLocation()).append(\"</a><br/>\")\n          .append(\"<b>Processor: </b>\").append(asyncProcessor.getProcessorClass().getSimpleName()).append(\"<br/>\")\n          .append(\"<b>Finished: </b>\").append(entry.getValue().isFinished()).append(\"<br/>\")\n          .append(\"</li>\");\n    }\n    sb.append(\"</ul></body></html>\");\n    writeToResponse(response, sb.toString());\n  }\n  private static void writeToResponse(HttpServletResponse response, InputStream input) throws IOException {\n    copy(input, response.getOutputStream());\n  }\n  private void writeToResponse(HttpServletResponse response, String content) {\n    writeToResponse(response, content.getBytes());\n  }\n  private static void writeToResponse(HttpServletResponse response, byte[] content) {\n    OutputStream output = null;\n    try {\n      output = response.getOutputStream();\n      output.write(content);\n    } catch (IOException e) {\n      throw new ODataRuntimeException(e);\n    } finally {\n      closeStream(output);\n    }\n  }\n  static void wrapToAsyncHttpResponse(final ODataResponse odResponse, final HttpServletResponse response)\n      throws SerializerException, IOException {\n    OData odata = OData.newInstance();\n    InputStream odResponseStream = odata.createFixedFormatSerializer().asyncResponse(odResponse);\n    response.setHeader(HttpHeader.CONTENT_TYPE, ContentType.APPLICATION_HTTP.toContentTypeString());\n    response.setHeader(HttpHeader.CONTENT_ENCODING, \"binary\");\n    response.setStatus(HttpStatusCode.OK.getStatusCode());\n    writeToResponse(response, odResponseStream);\n  }\n<fim_suffix>  static void copy(final InputStream input, final OutputStream output) {\n    if (output == null || input == null) {\n      return;\n    }\n    try {\n      ByteBuffer inBuffer = ByteBuffer.allocate(8192);\n      ReadableByteChannel ic = Channels.newChannel(input);\n      WritableByteChannel oc = Channels.newChannel(output);\n      while (ic.read(inBuffer) > 0) {\n        inBuffer.flip();\n        oc.write(inBuffer);\n        inBuffer.rewind();\n      }\n    } catch (IOException e) {\n      throw new ODataRuntimeException(\"Error on reading request content\");\n    } finally {\n      closeStream(input);\n      closeStream(output);\n    }\n  }<fim_middle>// function below has no smell\n"}