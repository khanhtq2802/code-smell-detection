{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.beam.sdk.io.aws.sqs;\n\nimport static org.apache.beam.vendor.guava.v20_0.com.google.common.base.Preconditions.checkArgument;\n\nimport com.amazonaws.services.sqs.AmazonSQS;\nimport com.amazonaws.services.sqs.AmazonSQSClientBuilder;\nimport com.amazonaws.services.sqs.model.Message;\nimport com.amazonaws.services.sqs.model.SendMessageRequest;\nimport com.google.auto.value.AutoValue;\nimport javax.annotation.Nullable;\nimport org.apache.beam.sdk.annotations.Experimental;\nimport org.apache.beam.sdk.io.aws.options.AwsOptions;\nimport org.apache.beam.sdk.transforms.DoFn;\nimport org.apache.beam.sdk.transforms.PTransform;\nimport org.apache.beam.sdk.transforms.ParDo;\nimport org.apache.beam.sdk.values.PBegin;\nimport org.apache.beam.sdk.values.PCollection;\nimport org.apache.beam.sdk.values.PDone;\nimport org.joda.time.Duration;\n\n/**\n * An unbounded source for Amazon Simple Queue Service (SQS).\n *\n * <h3>Reading from an SQS queue</h3>\n *\n * <p>The {@link SqsIO} {@link Read} returns an unbounded {@link PCollection} of {@link\n * com.amazonaws.services.sqs.model.Message} containing the received messages. Note: This source\n * does not currently advance the watermark when no new messages are received.\n *\n * <p>To configure an SQS source, you have to provide the queueUrl to connect to. The following\n * example illustrates how to configure the source:\n *\n * <pre>{@code\n * pipeline.apply(SqsIO.read().withQueueUrl(queueUrl))\n * }</pre>\n *\n * <h3>Writing to an SQS queue</h3>\n *\n * <p>The following example illustrates how to use the sink:\n *\n * <pre>{@code\n * pipeline\n *   .apply(...) // returns PCollection<SendMessageRequest>\n *   .apply(SqsIO.write())\n * }</pre>\n *\n * <h3>Additional Configuration</h3>\n *\n * <p>Additional configuration can be provided via {@link AwsOptions} from command line args or in\n * code. For example, if you wanted to provide a secret access key via code:\n *\n * <pre>{@code\n * PipelineOptions pipelineOptions = PipelineOptionsFactory.fromArgs(args).withValidation().create();\n * AwsOptions awsOptions = pipelineOptions.as(AwsOptions.class);\n * BasicAWSCredentials awsCreds = new BasicAWSCredentials(\"accesskey\", \"secretkey\");\n * awsOptions.setAwsCredentialsProvider(new AWSStaticCredentialsProvider(awsCreds));\n * Pipeline pipeline = Pipeline.create(options);\n * }</pre>\n *\n * <p>For more information on the available options see {@link AwsOptions}.\n */\n@Experimental(Experimental.Kind.SOURCE_SINK)\npublic class SqsIO {\n\n  public static Read read() {\n    return new AutoValue_SqsIO_Read.Builder().setMaxNumRecords(Long.MAX_VALUE).build();\n  }\n\n  public static Write write() {\n    return new AutoValue_SqsIO_Write.Builder().build();\n  }\n\n  private SqsIO() {}\n\n  /**\n   * A {@link PTransform} to read/receive messages from SQS. See {@link SqsIO} for more information\n   * on usage and configuration.\n   */\n  @AutoValue\n  public abstract static class Read extends PTransform<PBegin, PCollection<Message>> {\n\n    @Nullable\n    abstract String queueUrl();\n\n    abstract long maxNumRecords();\n\n    @Nullable\n    abstract Duration maxReadTime();\n\n    abstract Builder toBuilder();\n\n    @AutoValue.Builder\n    abstract static class Builder {\n      abstract Builder setQueueUrl(String queueUrl);\n\n      abstract Builder setMaxNumRecords(long maxNumRecords);\n\n      abstract Builder setMaxReadTime(Duration maxReadTime);\n\n      abstract Read build();\n    }\n\n    /**\n     * Define the max number of records received by the {@link Read}. When the max number of records\n     * is lower than {@code Long.MAX_VALUE}, the {@link Read} will provide a bounded {@link\n     * PCollection}.\n     */\n    public Read withMaxNumRecords(long maxNumRecords) {\n      return toBuilder().setMaxNumRecords(maxNumRecords).build();\n    }\n\n    /**\n     * Define the max read time (duration) while the {@link Read} will receive messages. When this\n     * max read time is not null, the {@link Read} will provide a bounded {@link PCollection}.\n     */\n    public Read withMaxReadTime(Duration maxReadTime) {\n      return toBuilder().setMaxReadTime(maxReadTime).build();\n    }\n\n    /** Define the queueUrl used by the {@link Read} to receive messages from SQS. */\n    public Read withQueueUrl(String queueUrl) {\n      checkArgument(queueUrl != null, \"queueUrl can not be null\");\n      checkArgument(!queueUrl.isEmpty(), \"queueUrl can not be empty\");\n      return toBuilder().setQueueUrl(queueUrl).build();\n    }\n\n<fim_suffix>    @Override\n    public PCollection<Message> expand(PBegin input) {\n\n      org.apache.beam.sdk.io.Read.Unbounded<Message> unbounded =\n          org.apache.beam.sdk.io.Read.from(\n              new SqsUnboundedSource(\n                  this,\n                  new SqsConfiguration(input.getPipeline().getOptions().as(AwsOptions.class))));\n\n      PTransform<PBegin, PCollection<Message>> transform = unbounded;\n\n      if (maxNumRecords() < Long.MAX_VALUE || maxReadTime() != null) {\n        transform = unbounded.withMaxReadTime(maxReadTime()).withMaxNumRecords(maxNumRecords());\n      }\n\n      return input.getPipeline().apply(transform);\n    }\n  }\n\n  /**\n   * A {@link PTransform} to send messages to SQS. See {@link SqsIO} for more information on usage\n   * and configuration.\n   */\n  @AutoValue\n  public abstract static class Write extends PTransform<PCollection<SendMessageRequest>, PDone> {\n    abstract Builder toBuilder();\n\n    @AutoValue.Builder\n    abstract static class Builder {\n      abstract Write build();\n    }\n\n    @Override\n    public PDone expand(PCollection<SendMessageRequest> input) {\n      input.apply(\n          ParDo.of(\n              new SqsWriteFn(\n                  new SqsConfiguration(input.getPipeline().getOptions().as(AwsOptions.class)))));\n      return PDone.in(input.getPipeline());\n    }\n  }\n\n  private static class SqsWriteFn extends DoFn<SendMessageRequest, Void> {\n    private final SqsConfiguration sqsConfiguration;\n    private transient AmazonSQS sqs;\n\n    SqsWriteFn(SqsConfiguration sqsConfiguration) {\n      this.sqsConfiguration = sqsConfiguration;\n    }\n\n    @Setup\n    public void setup() {\n      sqs =\n          AmazonSQSClientBuilder.standard()\n              .withClientConfiguration(sqsConfiguration.getClientConfiguration())\n              .withCredentials(sqsConfiguration.getAwsCredentialsProvider())\n              .withRegion(sqsConfiguration.getAwsRegion())\n              .build();\n    }\n\n    @ProcessElement\n    public void processElement(ProcessContext processContext) throws Exception {\n      sqs.sendMessage(processContext.element());\n    }\n\n    @Teardown\n    public void teardown() throws Exception {\n      if (sqs != null) {\n        sqs.shutdown();\n      }\n    }\n  }\n}<fim_middle>// function below has no smell\n"}