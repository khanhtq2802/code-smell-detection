{"text": "<fim_prefix>        case Character.OTHER_NUMBER:\n            return IS_WORD_CHAR_TRUE;\n        case Character.OTHER_PUNCTUATION:\n            if (inputChar == '\\'') {\n                return IS_WORD_CHAR_MAYBE; //ASCII apostrophe\n            }\n            return IS_WORD_CHAR_FALSE;\n        case Character.OTHER_SYMBOL:\n            return IS_WORD_CHAR_TRUE;\n        case Character.PARAGRAPH_SEPARATOR:\n            return IS_WORD_CHAR_FALSE;\n        case Character.PRIVATE_USE:\n            return IS_WORD_CHAR_FALSE;\n        case Character.SPACE_SEPARATOR:\n            return IS_WORD_CHAR_FALSE;\n        case Character.START_PUNCTUATION:\n            return IS_WORD_CHAR_FALSE;\n        case Character.SURROGATE:\n            return IS_WORD_CHAR_FALSE;\n        case Character.TITLECASE_LETTER:\n            return IS_WORD_CHAR_TRUE;\n        case Character.UNASSIGNED:\n            return IS_WORD_CHAR_FALSE;\n        case Character.UPPERCASE_LETTER:\n            return IS_WORD_CHAR_TRUE;\n        default:\n            return IS_WORD_CHAR_FALSE;\n        }\n    }\n    private class TextCharIterator extends CharIterator {\n        private int currentPosition;\n        private boolean canRemove;\n        private boolean canReplace;\n        public TextCharIterator() {\n        }\n        /** {@inheritDoc} */\n        public boolean hasNext() {\n           return (this.currentPosition < charBuffer.limit());\n        }\n        /** {@inheritDoc} */\n        public char nextChar() {\n            if (this.currentPosition < charBuffer.limit()) {\n                this.canRemove = true;\n                this.canReplace = true;\n                return charBuffer.get(currentPosition++);\n            } else {\n                throw new NoSuchElementException();\n            }\n        }\n        /** {@inheritDoc} */\n        public void remove() {\n            if (this.canRemove) {\n                charBuffer.position(currentPosition);\n                // Slice the buffer at the current position\n                CharBuffer tmp = charBuffer.slice();\n                // Reset position to before current character\n                charBuffer.position(--currentPosition);\n                if (tmp.hasRemaining()) {\n                    // Transfer any remaining characters\n                    charBuffer.mark();\n                    charBuffer.put(tmp);\n                    charBuffer.reset();\n                }\n                // Decrease limit\n                charBuffer.limit(charBuffer.limit() - 1);\n                // Make sure following calls fail, unless nextChar() was called\n                this.canRemove = false;\n            } else {\n                throw new IllegalStateException();\n            }\n        }\n        /** {@inheritDoc} */\n        public void replaceChar(char c) {\n            if (this.canReplace) {\n                charBuffer.put(currentPosition - 1, c);\n            } else {\n                throw new IllegalStateException();\n            }\n        }\n    }\n    /**\n     * @return the Common Font Properties.\n     */\n    public CommonFont getCommonFont() {\n        return commonFont;\n    }\n    /**\n     * @return the Common Hyphenation Properties.\n     */\n    public CommonHyphenation getCommonHyphenation() {\n        return commonHyphenation;\n    }\n    /**\n     * @return the \"color\" trait.\n     */\n    public Color getColor() {\n        return color;\n    }\n    /**\n     * @return the \"keep-together\" trait.\n     */\n    public KeepProperty getKeepTogether() {\n        return keepTogether;\n    }\n    /**\n     * @return the \"letter-spacing\" trait.\n     */\n    public Property getLetterSpacing() {\n        return letterSpacing;\n    }\n    /**\n     * @return the \"line-height\" trait.\n     */\n    public SpaceProperty getLineHeight() {\n        return lineHeight;\n    }\n    /**\n     * @return the \"white-space-treatment\" trait\n     */\n    public int getWhitespaceTreatment() {\n        return whiteSpaceTreatment;\n    }\n    /**\n     * @return the \"word-spacing\" trait.\n     */\n    public Property getWordSpacing() {\n        return wordSpacing;\n    }\n    /**\n     * @return the \"wrap-option\" trait.\n     */\n    public int getWrapOption() {\n        return wrapOption;\n    }\n    /** @return the \"text-decoration\" trait. */\n    public CommonTextDecoration getTextDecoration() {\n        return textDecoration;\n    }\n    /** @return the baseline-shift trait */\n    public Length getBaseLineShift() {\n        return baselineShift;\n    }\n    /** @return the country trait */\n    public String getCountry() {\n        return country;\n    }\n    @Override\n    public synchronized CharacterIterator getIterator() {\n        if (charIterator != null) {\n            charIterator = new StringCharacterIterator(toString());\n        }\n        return charIterator;\n    }\n    @Override\n    public int getBeginIndex() {\n        return 0;\n    }\n    @Override\n    public int getEndIndex() {\n        return length();\n    }\n    @Override\n    public String getLanguage() {\n        return language;\n    }\n    @Override\n    public String getScript() {\n        return script;\n    }\n    @Override\n    public int getBidiLevel() {\n        return length() > 0 ? bidiLevelAt(0) : -1;\n    }\n    /** {@inheritDoc} */\n    public String toString() {\n        if (charBuffer == null) {\n            return \"\";\n        } else {\n            CharBuffer cb = charBuffer.duplicate();\n            cb.rewind();\n            return cb.toString();\n        }\n    }\n    /** {@inheritDoc} */\n    public String getLocalName() {\n        return \"#PCDATA\";\n    }\n    /** {@inheritDoc} */\n    public String getNormalNamespacePrefix() {\n        return null;\n    }\n    /** {@inheritDoc} */\n    protected String gatherContextInfo() {\n        if (this.locator != null) {\n            return super.gatherContextInfo();\n        } else {\n            return this.toString();\n        }\n    }\n    /** {@inheritDoc} */\n    public char charAt(int position) {\n        return charBuffer.get(position);\n    }\n    /** {@inheritDoc} */\n    public CharSequence subSequence(int start, int end) {\n        return charBuffer.subSequence(start, end);\n    }\n    /** {@inheritDoc} */\n    public int length() {\n        return charBuffer.limit();\n    }\n    /**\n     * Resets the backing <code>java.nio.CharBuffer</code>\n     */\n    public void resetBuffer() {\n        if (charBuffer != null) {\n            charBuffer.rewind();\n        }\n    }\n    @Override\n    public boolean isDelimitedTextRangeBoundary(int boundary) {\n        return false;\n    }\n    @Override\n    public void setStructureTreeElement(StructureTreeElement structureTreeElement) {\n        this.structureTreeElement = structureTreeElement;\n    }\n    @Override\n    public StructureTreeElement getStructureTreeElement() {\n        return structureTreeElement;\n    }\n    /**\n     * Set bidirectional level over interval [start,end).\n     * @param level the resolved level\n     * @param start the starting index of interval\n     * @param end the ending index of interval\n     */\n    public void setBidiLevel(int level, int start, int end) {\n        if (start < end) {\n            if (bidiLevels == null) {\n                bidiLevels = new int [ length() ];\n            }\n            for (int i = start, n = end; i < n; i++) {\n                bidiLevels [ i ] = level;\n            }\n            if (parent != null) {\n                ((FObj) parent).setBidiLevel(level);\n            }\n        } else {\n            assert start < end;\n        }\n    }\n    /**\n     * Obtain bidirectional level of each character\n     * represented by this FOText.\n     * @return a (possibly empty) array of bidi levels or null\n     * in case no bidi levels have been assigned\n     */\n    public int[] getBidiLevels() {\n        return bidiLevels;\n    }\n    /**\n     * Obtain bidirectional level of each character over\n     * interval [start,end).\n     * @param start the starting index of interval\n     * @param end the ending index of interval\n     * @return a (possibly empty) array of bidi levels or null\n     * in case no bidi levels have been assigned\n     */\n    public int[] getBidiLevels(int start, int end) {\n        if (this.bidiLevels != null) {\n            assert start <= end;\n            int n = end - start;\n            int[] bidiLevels = new int [ n ];\n            System.arraycopy(this.bidiLevels, start + 0, bidiLevels, 0, n);\n            return bidiLevels;\n        } else {\n            return null;\n        }\n    }\n    /**\n     * Obtain bidirectional level of character at\n     * specified position, which must be a non-negative integer\n     * less than the length of this FO.\n     * @param position an offset position into FO's characters\n     * @return a resolved bidi level or -1 if default\n     * @throws IndexOutOfBoundsException if position is not non-negative integer\n     * or is greater than or equal to length\n     */\n<fim_suffix>    public int bidiLevelAt(int position) throws IndexOutOfBoundsException {\n        if ((position < 0) || (position >= length())) {\n            throw new IndexOutOfBoundsException();\n        } else if (bidiLevels != null) {\n            return bidiLevels [ position ];\n        } else {\n            return -1;\n        }\n    }<fim_middle>// function below has no smell\n"}