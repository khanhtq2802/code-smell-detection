{"text": "<fim_prefix>        public static final LIRInstructionClass<LoadDataAddressOp> TYPE = LIRInstructionClass.create(LoadDataAddressOp.class);\n        @Def({REG}) protected AllocatableValue result;\n        private final DataPointerConstant data;\n        public LoadDataAddressOp(AllocatableValue result, DataPointerConstant data) {\n            super(TYPE);\n            this.result = result;\n            this.data = data;\n        }\n        @Override\n        public void emitCode(CompilationResultBuilder crb, SPARCMacroAssembler masm) {\n            // HotSpot for SPARC requires at least word alignment\n            SPARCAddress addr = (SPARCAddress) crb.recordDataReferenceInCode(data, max(SPARCKind.WORD.getSizeInBytes(), data.getAlignment()));\n            assert addr == masm.getPlaceholder(-1);\n            final boolean forceRelocatable = true;\n            Register dstReg = asRegister(result);\n            masm.setx(0, dstReg, forceRelocatable);\n        }\n        @Override\n        public SizeEstimate estimateSize() {\n            return SizeEstimate.create(8, data.getSerializedSize());\n        }\n    }\n    public static final class MembarOp extends SPARCLIRInstruction implements SPARCTailDelayedLIRInstruction {\n        public static final LIRInstructionClass<MembarOp> TYPE = LIRInstructionClass.create(MembarOp.class);\n        public static final SizeEstimate SIZE = SizeEstimate.create(1);\n        private final int barriers;\n        public MembarOp(final int barriers) {\n            super(TYPE, SIZE);\n            this.barriers = barriers;\n        }\n        @Override\n        public void emitCode(CompilationResultBuilder crb, SPARCMacroAssembler masm) {\n            getDelayedControlTransfer().emitControlTransfer(crb, masm);\n            masm.membar(MEMBAR_STORE_LOAD);\n        }\n        @Override\n        public void verify() {\n            assert barriers == STORE_LOAD : String.format(\"Got barriers 0x%x; On SPARC only STORE_LOAD barriers are accepted; all other barriers are not neccessary due to TSO\", barriers);\n        }\n    }\n    public static final class NullCheckOp extends SPARCLIRInstruction implements NullCheck, SPARCTailDelayedLIRInstruction {\n        public static final LIRInstructionClass<NullCheckOp> TYPE = LIRInstructionClass.create(NullCheckOp.class);\n        public static final SizeEstimate SIZE = SizeEstimate.create(1);\n        @Use({COMPOSITE}) protected SPARCAddressValue input;\n        @State protected LIRFrameState state;\n        public NullCheckOp(SPARCAddressValue input, LIRFrameState state) {\n            super(TYPE, SIZE);\n            this.input = input;\n            this.state = state;\n        }\n        @Override\n        public void emitCode(CompilationResultBuilder crb, SPARCMacroAssembler masm) {\n            getDelayedControlTransfer().emitControlTransfer(crb, masm);\n            SPARCAddress addr = input.toAddress();\n            crb.recordImplicitException(masm.position(), state);\n            // Just need to check whether this is a valid address or not; alignment is not\n            // checked\n            masm.ldub(addr, g0);\n        }\n        @Override\n        public Value getCheckedValue() {\n            return input;\n        }\n        @Override\n        public LIRFrameState getState() {\n            return state;\n        }\n    }\n    @Opcode(\"CAS\")\n    public static final class CompareAndSwapOp extends SPARCLIRInstruction implements SPARCTailDelayedLIRInstruction {\n        public static final LIRInstructionClass<CompareAndSwapOp> TYPE = LIRInstructionClass.create(CompareAndSwapOp.class);\n        public static final SizeEstimate SIZE = SizeEstimate.create(2);\n        @Def({REG, HINT}) protected AllocatableValue result;\n        @Alive({REG}) protected AllocatableValue address;\n        @Alive({REG}) protected AllocatableValue cmpValue;\n        @Use({REG}) protected AllocatableValue newValue;\n        public CompareAndSwapOp(AllocatableValue result, AllocatableValue address, AllocatableValue cmpValue, AllocatableValue newValue) {\n            super(TYPE, SIZE);\n            this.result = result;\n            this.address = address;\n            this.cmpValue = cmpValue;\n            this.newValue = newValue;\n        }\n        @Override\n        public void emitCode(CompilationResultBuilder crb, SPARCMacroAssembler masm) {\n            move(crb, masm, result, newValue, SPARCDelayedControlTransfer.DUMMY);\n            compareAndSwap(crb, masm, address, cmpValue, result, getDelayedControlTransfer());\n        }\n    }\n    public static final class StackLoadAddressOp extends SPARCLIRInstruction implements SPARCTailDelayedLIRInstruction {\n        public static final LIRInstructionClass<StackLoadAddressOp> TYPE = LIRInstructionClass.create(StackLoadAddressOp.class);\n        public static final SizeEstimate SIZE = SizeEstimate.create(2);\n        @Def({REG}) protected AllocatableValue result;\n        @Use({STACK, UNINITIALIZED}) protected AllocatableValue slot;\n        public StackLoadAddressOp(AllocatableValue result, AllocatableValue slot) {\n            super(TYPE, SIZE);\n            this.result = result;\n            this.slot = slot;\n            assert slot instanceof VirtualStackSlot || slot instanceof StackSlot;\n        }\n        @Override\n        public void emitCode(CompilationResultBuilder crb, SPARCMacroAssembler masm) {\n            SPARCAddress address = (SPARCAddress) crb.asAddress(slot);\n            loadEffectiveAddress(crb, masm, address, asRegister(result, XWORD), getDelayedControlTransfer());\n        }\n    }\n    private static void loadEffectiveAddress(CompilationResultBuilder crb, SPARCMacroAssembler masm, SPARCAddress address, Register result, SPARCDelayedControlTransfer delaySlotHolder) {\n        if (address.getIndex().equals(Register.None)) {\n            if (isSimm13(address.getDisplacement())) {\n                delaySlotHolder.emitControlTransfer(crb, masm);\n                masm.add(address.getBase(), address.getDisplacement(), result);\n            } else {\n                assert result.encoding() != address.getBase().encoding();\n                masm.setx(address.getDisplacement(), result, false);\n                // No relocation, therefore, the add can be delayed as well\n                delaySlotHolder.emitControlTransfer(crb, masm);\n                masm.add(address.getBase(), result, result);\n            }\n        } else {\n            delaySlotHolder.emitControlTransfer(crb, masm);\n            masm.add(address.getBase(), address.getIndex(), result);\n        }\n    }\n    public static class StoreOp extends MemOp implements SPARCTailDelayedLIRInstruction {\n        public static final LIRInstructionClass<StoreOp> TYPE = LIRInstructionClass.create(StoreOp.class);\n        public static final SizeEstimate SIZE = SizeEstimate.create(1);\n        @Use({REG}) protected AllocatableValue input;\n        public StoreOp(PlatformKind kind, SPARCAddressValue address, AllocatableValue input, LIRFrameState state) {\n            super(TYPE, SIZE, kind, address, state);\n            this.input = input;\n        }\n        @Override\n        public void emitMemAccess(CompilationResultBuilder crb, SPARCMacroAssembler masm) {\n            emitStore(input, address.toAddress(), kind, getDelayedControlTransfer(), state, crb, masm);\n        }\n    }\n<fim_suffix>    public static final class StoreConstantOp extends MemOp implements SPARCTailDelayedLIRInstruction {\n        public static final LIRInstructionClass<StoreConstantOp> TYPE = LIRInstructionClass.create(StoreConstantOp.class);\n        public static final SizeEstimate SIZE = SizeEstimate.create(2);\n        protected final JavaConstant input;\n        public StoreConstantOp(PlatformKind kind, SPARCAddressValue address, JavaConstant input, LIRFrameState state) {\n            super(TYPE, SIZE, kind, address, state);\n            this.input = input;\n            if (!input.isDefaultForKind()) {\n                throw GraalError.shouldNotReachHere(\"Can only store null constants to memory\");\n            }\n        }\n        @Override\n        public void emitMemAccess(CompilationResultBuilder crb, SPARCMacroAssembler masm) {\n            try (ScratchRegister sc = masm.getScratchRegister()) {\n                Register scratch = sc.getRegister();\n                SPARCAddress addr = generateSimm13OffsetLoad(address.toAddress(), masm, scratch);\n                getDelayedControlTransfer().emitControlTransfer(crb, masm);\n                if (state != null) {\n                    crb.recordImplicitException(masm.position(), state);\n                }\n                int byteCount = kind.getSizeInBytes();\n                masm.st(g0, addr, byteCount);\n            }\n        }\n    }<fim_middle>// class below has no smell\n"}