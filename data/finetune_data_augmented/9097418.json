{"text": "<fim_prefix>/*\n * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 3 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 3 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 3 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage com.oracle.truffle.r.ffi.impl.nfi;\n\nimport com.oracle.truffle.api.CompilerDirectives;\nimport com.oracle.truffle.api.CompilerDirectives.TruffleBoundary;\nimport com.oracle.truffle.api.TruffleLanguage.Env;\nimport com.oracle.truffle.api.interop.ForeignAccess;\nimport com.oracle.truffle.api.interop.InteropException;\nimport com.oracle.truffle.api.interop.Message;\nimport com.oracle.truffle.api.interop.TruffleObject;\nimport com.oracle.truffle.api.interop.UnknownIdentifierException;\nimport com.oracle.truffle.api.nodes.Node;\nimport com.oracle.truffle.api.source.Source;\nimport com.oracle.truffle.r.ffi.impl.common.LibPaths;\nimport com.oracle.truffle.r.runtime.RInternalError;\nimport com.oracle.truffle.r.runtime.context.RContext;\nimport com.oracle.truffle.r.runtime.ffi.DLL;\nimport com.oracle.truffle.r.runtime.ffi.DLL.SymbolHandle;\nimport com.oracle.truffle.r.runtime.ffi.DLLRFFI;\nimport com.oracle.truffle.r.runtime.ffi.RFFIFactory;\nimport com.oracle.truffle.r.runtime.ffi.RFFIFactory.Type;\n\n<fim_suffix>public class TruffleNFI_DLL implements DLLRFFI {\n\n    public static final class NFIHandle implements LibHandle {\n        @SuppressWarnings(\"unused\") private final String libName;\n        final TruffleObject libHandle;\n\n        NFIHandle(String libName, TruffleObject libHandle) {\n            this.libName = libName;\n            this.libHandle = libHandle;\n        }\n\n        @Override\n        public Type getRFFIType() {\n            return RFFIFactory.Type.NFI;\n        }\n    }\n\n    private static final class TruffleNFI_DLOpenNode extends Node implements DLLRFFI.DLOpenNode {\n\n        @Override\n        @TruffleBoundary\n        public LibHandle execute(String path, boolean local, boolean now) {\n            String librffiPath = LibPaths.getBuiltinLibPath(\"R\");\n            // Do not call before/afterDowncall when loading libR to prevent the pushing/popping of\n            // the callback array, which requires that the libR have already been loaded\n            boolean notifyStateRFFI = !librffiPath.equals(path);\n            long before = notifyStateRFFI ? RContext.getInstance().getStateRFFI().beforeDowncall(RFFIFactory.Type.NFI) : 0;\n            try {\n                String libName = DLL.libName(path);\n                Env env = RContext.getInstance().getEnv();\n                TruffleObject libHandle = (TruffleObject) env.parse(Source.newBuilder(\"nfi\", prepareLibraryOpen(path, local, now), path).build()).call();\n                return new NFIHandle(libName, libHandle);\n            } finally {\n                if (notifyStateRFFI) {\n                    RContext.getInstance().getStateRFFI().afterDowncall(before, RFFIFactory.Type.NFI);\n                }\n            }\n        }\n    }\n\n    @TruffleBoundary\n    private static String prepareLibraryOpen(String path, boolean local, boolean now) {\n        StringBuilder sb = new StringBuilder(\"load\");\n        sb.append(\"(\");\n        sb.append(local ? \"RTLD_LOCAL\" : \"RTLD_GLOBAL\");\n        sb.append('|');\n        sb.append(now ? \"RTLD_NOW\" : \"RTLD_LAZY\");\n        sb.append(\") \\\"\");\n        sb.append(path);\n        sb.append('\"');\n        return sb.toString();\n    }\n\n    private static class TruffleNFI_DLSymNode extends Node implements DLLRFFI.DLSymNode {\n\n        @Child private Node lookupSymbol;\n\n        @Override\n        @TruffleBoundary\n        public SymbolHandle execute(Object handle, String symbol) {\n            assert handle instanceof NFIHandle;\n            NFIHandle nfiHandle = (NFIHandle) handle;\n            if (lookupSymbol == null) {\n                CompilerDirectives.transferToInterpreterAndInvalidate();\n                lookupSymbol = insert(Message.READ.createNode());\n            }\n            try {\n                TruffleObject result = (TruffleObject) ForeignAccess.sendRead(lookupSymbol, nfiHandle.libHandle, symbol);\n                return new SymbolHandle(result);\n            } catch (UnknownIdentifierException e) {\n                throw new UnsatisfiedLinkError();\n            } catch (InteropException e) {\n                throw RInternalError.shouldNotReachHere();\n            }\n        }\n    }\n\n    private static class TruffleNFI_DLCloseNode extends Node implements DLLRFFI.DLCloseNode {\n\n        @Override\n        public int execute(Object handle) {\n            assert handle instanceof NFIHandle;\n            // TODO\n            return 0;\n        }\n    }\n\n    @Override\n    public DLOpenNode createDLOpenNode() {\n        return new TruffleNFI_DLOpenNode();\n    }\n\n    @Override\n    public DLSymNode createDLSymNode() {\n        return new TruffleNFI_DLSymNode();\n    }\n\n    @Override\n    public DLCloseNode createDLCloseNode() {\n        return new TruffleNFI_DLCloseNode();\n    }\n}<fim_middle>// class below has no smell\n"}