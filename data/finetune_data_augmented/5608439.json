{"text": "<fim_prefix>import javax.xml.transform.stream.StreamResult;\nimport javax.xml.validation.Schema;\nimport javax.xml.validation.SchemaFactory;\nimport javax.xml.validation.Validator;\nimport org.apache.poi.ss.usermodel.CellType;\nimport org.apache.poi.ss.usermodel.DateUtil;\nimport org.apache.poi.ooxml.util.DocumentHelper;\nimport org.apache.poi.util.LocaleUtil;\nimport org.apache.poi.util.POILogFactory;\nimport org.apache.poi.util.POILogger;\nimport org.apache.poi.xssf.usermodel.XSSFCell;\nimport org.apache.poi.xssf.usermodel.XSSFMap;\nimport org.apache.poi.xssf.usermodel.XSSFRow;\nimport org.apache.poi.xssf.usermodel.XSSFSheet;\nimport org.apache.poi.xssf.usermodel.XSSFTable;\nimport org.apache.poi.xssf.usermodel.XSSFTableColumn;\nimport org.apache.poi.xssf.usermodel.helpers.XSSFSingleXmlCell;\nimport org.apache.poi.xssf.usermodel.helpers.XSSFXmlColumnPr;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.SAXException;\n/**\n *\n * Maps an XLSX to an XML according to one of the mapping defined.\n *\n *\n * The output XML Schema must respect this limitations:\n *\n * <ul>\n * <li> all mandatory elements and attributes must be mapped (enable validation to check this)</li>\n *\n * <li> no &lt;any&gt; in complex type/element declaration </li>\n * <li> no &lt;anyAttribute&gt; attributes declaration </li>\n * <li> no recursive structures: recursive structures can't be nested more than one level </li>\n * <li> no abstract elements: abstract complex types can be declared but must not be used in elements. </li>\n * <li> no mixed content: an element can't contain simple text and child element(s) together </li>\n * <li> no &lt;substitutionGroup&gt; in complex type/element declaration </li>\n * </ul>\n */\npublic class XSSFExportToXml implements Comparator<String>{\n    private static final POILogger LOG = POILogFactory.getLogger(XSSFExportToXml.class);\n    private XSSFMap map;\n    private final HashMap<String, Integer> indexMap = new HashMap<>();\n    /**\n     * Creates a new exporter and sets the mapping to be used when generating the XML output document\n     *\n     * @param map the mapping rule to be used\n     */\n    public XSSFExportToXml(XSSFMap map) {\n        this.map = map;\n    }\n    /**\n     *\n     * Exports the data in an XML stream\n     *\n     * @param os OutputStream in which will contain the output XML\n     * @param validate if true, validates the XML against the XML Schema\n     * @throws SAXException If validating the document fails\n     * @throws TransformerException If transforming the document fails\n     */\n    public void exportToXML(OutputStream os, boolean validate) throws SAXException, TransformerException {\n        exportToXML(os, \"UTF-8\", validate);\n    }\n    /**\n     * Exports the data in an XML stream\n     *\n     * @param os OutputStream in which will contain the output XML\n     * @param encoding the output charset encoding\n     * @param validate if true, validates the XML against the XML Schema\n     * @throws SAXException If validating the document fails\n     * @throws TransformerException If transforming the document fails\n     */\n    public void exportToXML(OutputStream os, String encoding, boolean validate) throws SAXException, TransformerException{\n        List<XSSFSingleXmlCell> singleXMLCells = map.getRelatedSingleXMLCell();\n        List<XSSFTable> tables = map.getRelatedTables();\n        String rootElement = map.getCtMap().getRootElement();\n        Document doc = DocumentHelper.createDocument();\n        final Element root;\n        if (isNamespaceDeclared()) {\n            root = doc.createElementNS(getNamespace(),rootElement);\n        } else {\n            root = doc.createElementNS(\"\", rootElement);\n        }\n        doc.appendChild(root);\n        List<String> xpaths = new Vector<>();\n        Map<String,XSSFSingleXmlCell> singleXmlCellsMappings = new HashMap<>();\n        Map<String,XSSFTable> tableMappings = new HashMap<>();\n        for(XSSFSingleXmlCell simpleXmlCell : singleXMLCells) {\n            xpaths.add(simpleXmlCell.getXpath());\n            singleXmlCellsMappings.put(simpleXmlCell.getXpath(), simpleXmlCell);\n        }\n        for(XSSFTable table : tables) {\n            String commonXPath = table.getCommonXpath();\n            xpaths.add(commonXPath);\n            tableMappings.put(commonXPath, table);\n        }\n        indexMap.clear();\n        xpaths.sort(this);\n        indexMap.clear();\n        for(String xpath : xpaths) {\n            XSSFSingleXmlCell simpleXmlCell = singleXmlCellsMappings.get(xpath);\n            XSSFTable table = tableMappings.get(xpath);\n            if (!xpath.matches(\".*\\\\[.*\")) {\n                // Exports elements and attributes mapped with simpleXmlCell\n                if (simpleXmlCell!=null) {\n                    XSSFCell cell = simpleXmlCell.getReferencedCell();\n                    if (cell!=null) {\n                        Node currentNode = getNodeByXPath(xpath,doc.getFirstChild(),doc,false);\n                        mapCellOnNode(cell,currentNode);\n                        //remove nodes which are empty in order to keep the output xml valid\n                        // FIXME: what should be done if currentNode.getTextContent() is null?\n                        if (\"\".equals(currentNode.getTextContent()) && currentNode.getParentNode() != null) {\n                            currentNode.getParentNode().removeChild(currentNode);\n                        }\n                    }\n                }\n                // Exports elements and attributes mapped with tables\n                if (table!=null) {\n                    List<XSSFTableColumn> tableColumns = table.getColumns();\n                    XSSFSheet sheet = table.getXSSFSheet();\n                    int startRow = table.getStartCellReference().getRow() + table.getHeaderRowCount();\n                    int endRow = table.getEndCellReference().getRow();\n                    for(int i = startRow; i<= endRow; i++) {\n                        XSSFRow row = sheet.getRow(i);\n                        Node tableRootNode = getNodeByXPath(table.getCommonXpath(), doc.getFirstChild(), doc, true);\n                        short startColumnIndex = table.getStartCellReference().getCol();\n                        for (XSSFTableColumn tableColumn : tableColumns) {\n                            XSSFCell cell = row.getCell(startColumnIndex + tableColumn.getColumnIndex());\n                            if (cell != null) {\n                                XSSFXmlColumnPr xmlColumnPr = tableColumn.getXmlColumnPr();\n                                if (xmlColumnPr != null) {\n                                    String localXPath = xmlColumnPr.getLocalXPath();\n                                    Node currentNode = getNodeByXPath(localXPath,tableRootNode,doc,false);\n                                    mapCellOnNode(cell, currentNode);\n                                }\n                            }\n                        }\n                    }\n                }\n            } /*else {\n                // TODO:  implement filtering management in xpath\n            }*/\n        }\n        boolean isValid = true;\n        if (validate) {\n            isValid =isValid(doc);\n        }\n        if (isValid) {\n            /////////////////\n            //Output the XML\n            //set up a transformer\n            TransformerFactory transfac = TransformerFactory.newInstance();\n            Transformer trans = transfac.newTransformer();\n            trans.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, \"yes\");\n            trans.setOutputProperty(OutputKeys.INDENT, \"yes\");\n            trans.setOutputProperty(OutputKeys.ENCODING, encoding);\n            //create string from xml tree\n            StreamResult result = new StreamResult(os);\n            DOMSource source = new DOMSource(doc);\n            trans.transform(source, result);\n        }\n    }\n    /**\n     * Validate the generated XML against the XML Schema associated with the XSSFMap\n     *\n     * @param xml the XML to validate\n     * @return true, if document is valid\n     * @throws SAXException If validating the document fails\n     */\n<fim_suffix>    private boolean isValid(Document xml) throws SAXException{\n        try{\n            String language = \"http://www.w3.org/2001/XMLSchema\";\n            SchemaFactory factory = SchemaFactory.newInstance(language);\n            Source source = new DOMSource(map.getSchema());\n            Schema schema = factory.newSchema(source);\n            Validator validator = schema.newValidator();\n            validator.validate(new DOMSource(xml));\n            //if no exceptions where raised, the document is valid\n            return true;\n        } catch(IOException e) {\n            LOG.log(POILogger.ERROR, \"document is not valid\", e);\n        }\n        return false;\n    }<fim_middle>// function below has no smell\n"}