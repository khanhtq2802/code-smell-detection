{"text": "<fim_prefix>        {\n          sb.append(BigBrother.getTimeslotString(slotType, timeslots[i]));\n          sb.append(' ');\n        }\n      }\n    }\n    if (chanName.length() > 0)\n    {\n      sb.append(chanName);\n    }\n    return sb.toString().trim();\n  }\n  public boolean isNegativeNelly()\n  {\n    return negator;\n  }\n  public String getRecordingQuality()\n  {\n    return quality;\n  }\n  public void setRecordingQuality(String quality)\n  {\n    if (this.quality == quality || this.quality.equals(quality)) return;\n    try {\n      wiz.acquireWriteLock(Wizard.AGENT_CODE);\n      this.quality = quality;\n      wiz.logUpdate(this, Wizard.AGENT_CODE);\n    } finally {\n      wiz.releaseWriteLock(Wizard.AGENT_CODE);\n    }\n  }\n  public String getAutoConvertFormat()\n  {\n    return autoConvertFormat;\n  }\n  public void setAutoConvertFormat(String format)\n  {\n    if (format == null) format = \"\";\n    if (format.equals(autoConvertFormat)) return;\n    try {\n      wiz.acquireWriteLock(Wizard.AGENT_CODE);\n      autoConvertFormat = format;\n      wiz.logUpdate(this, Wizard.AGENT_CODE);\n    } finally {\n      wiz.releaseWriteLock(Wizard.AGENT_CODE);\n    }\n  }\n  public File getAutoConvertDest()\n  {\n    return autoConvertDest;\n  }\n  public void setAutoConvertDest(File f)\n  {\n    if (f == autoConvertDest || (f != null && f.equals(autoConvertDest))) return;\n    try {\n      wiz.acquireWriteLock(Wizard.AGENT_CODE);\n      autoConvertDest = f;\n      wiz.logUpdate(this, Wizard.AGENT_CODE);\n    } finally {\n      wiz.releaseWriteLock(Wizard.AGENT_CODE);\n    }\n  }\n  public long getStartPadding()\n  {\n    return startPad;\n  }\n  public void setStartPadding(long newPad)\n  {\n    if (startPad != newPad)\n    {\n      try {\n        wiz.acquireWriteLock(Wizard.AGENT_CODE);\n        startPad = newPad;\n        wiz.logUpdate(this, Wizard.AGENT_CODE);\n      } finally {\n        wiz.releaseWriteLock(Wizard.AGENT_CODE);\n      }\n    }\n  }\n  public long getStopPadding()\n  {\n    return stopPad;\n  }\n  public void setStopPadding(long newPad)\n  {\n    if (stopPad != newPad)\n    {\n      try {\n        wiz.acquireWriteLock(Wizard.AGENT_CODE);\n        stopPad = newPad;\n        wiz.logUpdate(this, Wizard.AGENT_CODE);\n      } finally {\n        wiz.releaseWriteLock(Wizard.AGENT_CODE);\n      }\n    }\n  }\n  public int getUID()\n  {\n    return id;\n  }\n  public int getAgentMask() { return agentMask; }\n  public boolean isFavorite() { return (agentMask & LOVE_MASK) == LOVE_MASK; }\n  public boolean testAgentFlag(int maskTest)\n  {\n    return (agentFlags & maskTest) == maskTest;\n  }\n  public int getAgentFlag(int whichFlag)\n  {\n    if (whichFlag == DONT_AUTODELETE_FLAG)\n      return agentFlags & DONT_AUTODELETE_FLAG;\n    else if (whichFlag == KEEP_AT_MOST_MASK)\n      return (agentFlags & KEEP_AT_MOST_MASK) >> 1;\n    else if (whichFlag == DELETE_AFTER_CONVERT_FLAG)\n      return agentFlags & DELETE_AFTER_CONVERT_FLAG;\n    else if (whichFlag == DISABLED_FLAG)\n      return agentFlags & DISABLED_FLAG;\n    else\n      return 0;\n  }\n  void setAgentFlags(int maskBits, int values)\n  {\n    if (maskBits == KEEP_AT_MOST_MASK)\n      values = values << 1;\n    if ((agentFlags & maskBits) == values) return;\n    try {\n      wiz.acquireWriteLock(Wizard.AGENT_CODE);\n      agentFlags = (agentFlags & (~maskBits)) | (maskBits & values);\n      wiz.logUpdate(this, Wizard.AGENT_CODE);\n    } finally {\n      wiz.releaseWriteLock(Wizard.AGENT_CODE);\n    }\n  }\n  private boolean chanNameMatches(String name)\n  {\n    if (chanNames == null) return false;\n    for (int i = 0; i < chanNames.length; i++)\n      if (chanNames[i].equals(name))\n        return true;\n    return false;\n  }\n  public String getProperty(String name)\n  {\n    if (favProps == null)\n      return \"\";\n    String rv = favProps.getProperty(name);\n    return (rv == null) ? \"\" : rv;\n  }\n  public void setProperty(String name, String value)\n  {\n    if (value == null && (favProps == null || !favProps.containsKey(name)))\n      return;\n    if (value != null && favProps != null && value.equals(favProps.getProperty(name)))\n      return;\n    try {\n      wiz.acquireWriteLock(Wizard.AGENT_CODE);\n      if (value == null)\n      {\n        favProps.remove(name);\n      }\n      else\n      {\n        if (favProps == null)\n          favProps = new Properties();\n        favProps.setProperty(name, value);\n      }\n      wiz.logUpdate(this, Wizard.AGENT_CODE);\n    } finally {\n      wiz.releaseWriteLock(Wizard.AGENT_CODE);\n    }\n  }\n  public Properties getProperties()\n  {\n    if (favProps == null)\n      return new Properties();\n    return (Properties) favProps.clone();\n  }\n  // This helps us not create any more Integer objects than we need to.\n  private void addHash(int intHash, List<Integer> list, int bitShift)\n  {\n    int hash = intHash >>> bitShift;\n    int low = 0;\n    int high = list.size() - 1;\n    while (low <= high)\n    {\n      int mid = (low + high) >>> 1;\n      int midVal = list.get(mid);\n      if (midVal < hash)\n        low = mid + 1;\n      else if (midVal > hash)\n        high = mid - 1;\n      else\n        return;\n    }\n    list.add(low, hash);\n  }\n  // 05/03/2017 JS: I changed this from caching this value to just re-creating it every time. The\n  // performance is break even since we only use these hashes once per cycle and it doesn't appear\n  // to be worth the memory usage. Since we aren't caching, we also use Integer since we will be\n  // using this against a HashMap and this will keep us from autoboxing in the process.\n<fim_suffix>  void getHashes(List<Integer> searchHashes, int bitShift)\n  {\n    // We don't need to include 0 because that's always assumed in look ups. If we do return 0, that\n    // means this agent isn't sure what it needs, but the inverse is acceptable because that just\n    // means the airing doesn't know what it matches and it will be tested on all of the agents.\n    searchHashes.clear();\n    if (title != null)\n    {\n      searchHashes.add((title.ignoreCaseHash >>> bitShift));\n    }\n    if (person != null)\n    {\n      addHash(person.ignoreCaseHash, searchHashes, bitShift);\n    }\n    if (category != null)\n    {\n      addHash(category.ignoreCaseHash, searchHashes, bitShift);\n    }\n    if (subCategory != null)\n    {\n      addHash(subCategory.ignoreCaseHash, searchHashes, bitShift);\n    }\n    if (chanName.length() > 0)\n    {\n      addHash(chanName.hashCode(), searchHashes, bitShift);\n    }\n    if (chanNames != null && chanNames.length > 0)\n    {\n      for (String chanName : chanNames)\n      {\n        addHash(chanName.hashCode(), searchHashes, bitShift);\n      }\n    }\n    if (network != null)\n    {\n      addHash(network.ignoreCaseHash, searchHashes, bitShift);\n    }\n    if (rated != null)\n    {\n      addHash(rated.ignoreCaseHash, searchHashes, bitShift);\n    }\n    if (year != null)\n    {\n      addHash(year.ignoreCaseHash, searchHashes, bitShift);\n    }\n    if (pr != null)\n    {\n      addHash(pr.ignoreCaseHash, searchHashes, bitShift);\n    }\n    // This will ensure that we do a full search since 0 means at least one of our items doesn't\n    // have a \"valid\" hash.\n    if (searchHashes.contains(0))\n      searchHashes.clear();\n  }<fim_middle>// function below is long method\n"}