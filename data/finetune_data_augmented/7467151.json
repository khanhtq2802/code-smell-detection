{"text": "<fim_prefix> * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * The Universal Permissive License (UPL), Version 1.0\n *\n * Subject to the condition set forth below, permission is hereby granted to any\n * person obtaining a copy of this software, associated documentation and/or\n * data (collectively the \"Software\"), free of charge and under any and all\n * copyright rights in the Software, and any and all patent rights owned or\n * freely licensable by each licensor hereunder covering either (i) the\n * unmodified Software as contributed to or provided by such licensor, or (ii)\n * the Larger Works (as defined below), to deal in both\n *\n * (a) the Software, and\n *\n * (b) any piece of software and/or hardware listed in the lrgrwrks.txt file if\n * one is included with the Software each a \"Larger Work\" to which the Software\n * is contributed by such licensors),\n *\n * without restriction, including without limitation the rights to copy, create\n * derivative works of, display, perform, and distribute the Software and make,\n * use, sell, offer for sale, import, export, have made, and have sold the\n * Software and the Larger Work(s), and to sublicense the foregoing rights on\n * either these or other terms.\n *\n * This license is subject to the following condition:\n *\n * The above copyright notice and either this complete permission notice or at a\n * minimum a reference to the UPL must be included in all copies or substantial\n * portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\npackage com.oracle.truffle.dsl.processor.parser;\nimport static com.oracle.truffle.dsl.processor.java.ElementUtils.hasError;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport javax.lang.model.element.AnnotationMirror;\nimport javax.lang.model.element.ExecutableElement;\nimport javax.lang.model.element.VariableElement;\nimport javax.lang.model.type.ArrayType;\nimport javax.lang.model.type.TypeKind;\nimport javax.lang.model.type.TypeMirror;\nimport com.oracle.truffle.dsl.processor.java.ElementUtils;\nimport com.oracle.truffle.dsl.processor.java.model.CodeVariableElement;\nimport com.oracle.truffle.dsl.processor.model.MethodSpec;\nimport com.oracle.truffle.dsl.processor.model.Parameter;\nimport com.oracle.truffle.dsl.processor.model.ParameterSpec;\nimport com.oracle.truffle.dsl.processor.model.Template;\nimport com.oracle.truffle.dsl.processor.model.TemplateMethod;\npublic final class MethodSpecParser {\n    private boolean emitErrors = true;\n    private boolean useVarArgs = false;\n    private final Template template;\n    public MethodSpecParser(Template template) {\n        this.template = template;\n    }\n    public Template getTemplate() {\n        return template;\n    }\n    public boolean isEmitErrors() {\n        return emitErrors;\n    }\n    public boolean isUseVarArgs() {\n        return useVarArgs;\n    }\n    public void setEmitErrors(boolean emitErrors) {\n        this.emitErrors = emitErrors;\n    }\n    public void setUseVarArgs(boolean useVarArgs) {\n        this.useVarArgs = useVarArgs;\n    }\n    public TemplateMethod parse(MethodSpec methodSpecification, ExecutableElement method, AnnotationMirror annotation, int naturalOrder) {\n        if (methodSpecification == null) {\n            return null;\n        }\n        methodSpecification.applyTypeDefinitions(\"types\");\n        String id = method.getSimpleName().toString();\n        TypeMirror returnType = method.getReturnType();\n        return parseImpl(methodSpecification, naturalOrder, id, method, annotation, returnType, method.getParameters());\n    }\n    public TemplateMethod parseImpl(MethodSpec methodSpecification, int naturalOrder, String id, ExecutableElement method, AnnotationMirror annotation, TypeMirror returnType,\n                    List<? extends VariableElement> parameterTypes) {\n        ParameterSpec returnTypeSpec = methodSpecification.getReturnType();\n        Parameter returnTypeMirror = matchParameter(returnTypeSpec, new CodeVariableElement(returnType, \"returnType\"), -1, -1);\n        if (returnTypeMirror == null) {\n            if (isEmitErrors() && method != null) {\n                TemplateMethod invalidMethod = new TemplateMethod(id, naturalOrder, template, methodSpecification, method, annotation, returnTypeMirror, Collections.<Parameter> emptyList());\n                String expectedReturnType = returnTypeSpec.toSignatureString(true);\n                String actualReturnType = ElementUtils.getSimpleName(returnType);\n                String message = String.format(\"The provided return type \\\"%s\\\" does not match expected return type \\\"%s\\\".%nExpected signature: %n %s\", actualReturnType, expectedReturnType,\n                                methodSpecification.toSignatureString(method.getSimpleName().toString()));\n                invalidMethod.addError(message);\n                return invalidMethod;\n            } else {\n                return null;\n            }\n        }\n        List<Parameter> parameters = parseParameters(methodSpecification, parameterTypes, isUseVarArgs() && method != null ? method.isVarArgs() : false);\n        if (parameters == null) {\n            if (isEmitErrors() && method != null) {\n                TemplateMethod invalidMethod = new TemplateMethod(id, naturalOrder, template, methodSpecification, method, annotation, returnTypeMirror, Collections.<Parameter> emptyList());\n                String message = String.format(\"Method signature %s does not match to the expected signature: %n%s\", createActualSignature(method),\n                                methodSpecification.toSignatureString(method.getSimpleName().toString()));\n                invalidMethod.addError(message);\n                return invalidMethod;\n            } else {\n                return null;\n            }\n        }\n        return new TemplateMethod(id, naturalOrder, template, methodSpecification, method, annotation, returnTypeMirror, parameters);\n    }\n    private static String createActualSignature(ExecutableElement method) {\n        StringBuilder b = new StringBuilder(\"(\");\n        String sep = \"\";\n        if (method != null) {\n            for (VariableElement var : method.getParameters()) {\n                b.append(sep);\n                b.append(ElementUtils.getSimpleName(var.asType()));\n                sep = \", \";\n            }\n        }\n        b.append(\")\");\n        return b.toString();\n    }\n    /*\n     * Parameter parsing tries to parse required arguments starting from offset 0 with increasing\n     * offset until it finds a signature end that matches the required specification. If there is no\n     * end matching the required arguments, parsing fails. Parameters prior to the parsed required\n     * ones are cut and used to parse the optional parameters.\n     */\n    private static List<Parameter> parseParameters(MethodSpec spec, List<? extends VariableElement> parameterTypes, boolean varArgs) {\n        List<Parameter> parsedRequired = null;\n        int offset = 0;\n        for (; offset <= parameterTypes.size(); offset++) {\n            List<VariableElement> parameters = new ArrayList<>();\n            parameters.addAll(parameterTypes.subList(offset, parameterTypes.size()));\n            parsedRequired = parseParametersRequired(spec, parameters, varArgs);\n            if (parsedRequired != null) {\n                break;\n            }\n        }\n        if (parsedRequired == null) {\n            return null;\n        }\n        if (parsedRequired.isEmpty() && offset == 0) {\n            offset = parameterTypes.size();\n        }\n        List<? extends VariableElement> potentialOptionals = parameterTypes.subList(0, offset);\n        List<Parameter> parsedOptionals = parseParametersOptional(spec, potentialOptionals);\n        if (parsedOptionals == null) {\n            return null;\n        }\n        List<Parameter> finalParameters = new ArrayList<>();\n        finalParameters.addAll(parsedOptionals);\n        finalParameters.addAll(parsedRequired);\n        return finalParameters;\n    }\n<fim_suffix>    private static List<Parameter> parseParametersOptional(MethodSpec spec, List<? extends VariableElement> types) {\n        List<Parameter> parsedParams = new ArrayList<>();\n        int typeStartIndex = 0;\n        List<ParameterSpec> specifications = spec.getOptional();\n        outer: for (int specIndex = 0; specIndex < specifications.size(); specIndex++) {\n            ParameterSpec specification = specifications.get(specIndex);\n            for (int typeIndex = typeStartIndex; typeIndex < types.size(); typeIndex++) {\n                VariableElement variable = types.get(typeIndex);\n                Parameter optionalParam = matchParameter(specification, variable, -1, -1);\n                if (optionalParam != null) {\n                    parsedParams.add(optionalParam);\n                    typeStartIndex = typeIndex + 1;\n                    continue outer;\n                }\n            }\n        }\n        if (typeStartIndex < types.size()) {\n            // not enough types found\n            return null;\n        }\n        return parsedParams;\n    }<fim_middle>// function below has no smell\n"}