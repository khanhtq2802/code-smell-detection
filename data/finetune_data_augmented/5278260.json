{"text": "<fim_prefix>            if (orig != null) {\n                // if already embedded, nothing to do\n                if (orig.getOwner() == owner && orig.getMetaData().\n                    getEmbeddingMetaData() == ownerMeta)\n                    return orig;\n                // otherwise make sure pc is fully loaded for when we copy its\n                // data below\n                orig.load(_fc, StateManagerImpl.LOAD_ALL, null, null, false);\n            }\n            // create new state manager with embedded metadata\n            ClassMetaData meta = ownerMeta.getEmbeddedMetaData();\n            if (meta == null)\n                throw new InternalException(_loc.get(\"bad-embed\", ownerMeta));\n            if (id == null)\n                id = StateManagerId.newInstance(this);\n            StateManagerImpl sm = newStateManagerImpl(id, meta);\n            sm.setOwner((StateManagerImpl) owner, ownerMeta);\n            PersistenceCapable copy;\n            PCState state;\n            Class<?> type = meta.getDescribedType();\n            if (obj != null) {\n                // give copy and the original instance the same state manager\n                // so that we can copy fields from one to the other\n                StateManagerImpl copySM;\n                PersistenceCapable pc;\n                if (orig == null) {\n                    copySM = sm;\n                    pc = assertPersistenceCapable(obj);\n                    pc.pcReplaceStateManager(sm);\n                } else {\n                    copySM = orig;\n                    pc = orig.getPersistenceCapable();\n                }\n                try {\n                    // copy the instance.  we do this even if it doesn't already\n                    // have a state manager in case it is later assigned to a\n                    // PC field; at that point it's too late to copy\n                    copy = PCRegistry.newInstance(type, copySM, false);\n                    int[] fields = new int[meta.getFields().length];\n                    for (int i = 0; i < fields.length; i++)\n                        fields[i] = i;\n                    copy.pcCopyFields(pc, fields);\n                    state = PCState.ECOPY;\n                    copy.pcReplaceStateManager(null);\n                } finally {\n                    // if the instance didn't have a state manager to start,\n                    // revert it to being transient\n                    if (orig == null)\n                        pc.pcReplaceStateManager(null);\n                }\n            } else {\n                copy = PCRegistry.newInstance(type, sm, false);\n                if ((_flags & FLAG_ACTIVE) != 0 && !_optimistic)\n                    state = PCState.ECLEAN;\n                else\n                    state = PCState.ENONTRANS;\n            }\n            sm.initialize(copy, state);\n            return sm;\n        } catch (OpenJPAException ke) {\n            throw ke;\n        } catch (RuntimeException re) {\n            throw new GeneralException(re);\n        } finally {\n            endOperation();\n        }\n    }\n    /**\n     * If not already cached, create an empty copy of the given state\n     * manager in the given state.\n     */\n    OpenJPAStateManager copy(OpenJPAStateManager copy, PCState state) {\n        beginOperation(true);\n        try {\n            assertOpen();\n            Object oid = copy.fetchObjectId();\n            Class<?> type = copy.getManagedInstance().getClass();\n            if (oid == null)\n                throw new InternalException();\n            // cached instance?\n            StateManagerImpl sm = null;\n            if (!copy.isEmbedded())\n                sm = getStateManagerImplById(oid, true);\n            if (sm == null) {\n                MetaDataRepository repos = _conf.\n                    getMetaDataRepositoryInstance();\n                ClassMetaData meta = repos.getMetaData(type, _loader, true);\n                // construct a new state manager with all info known\n                sm = newStateManagerImpl(oid, meta);\n                sm.setObjectId(oid);\n                sm.initialize(sm.getMetaData().getDescribedType(), state);\n            }\n            return sm;\n        } finally {\n            endOperation();\n        }\n    }\n    @Override\n    public void refreshAll(Collection objs, OpCallbacks call) {\n        if (objs == null || objs.isEmpty())\n            return;\n        beginOperation(true);\n        try {\n            assertNontransactionalRead();\n            for (Iterator<?> itr = objs.iterator(); itr.hasNext();)\n                gatherCascadeRefresh(itr.next(), call);\n            if (_operating.isEmpty())\n            \treturn;\n            if (_operating.size() == 1)\n            \trefreshInternal(_operating.iterator().next(), call);\n            else\n            \trefreshInternal(_operating, call);\n        } finally {\n            endOperation();\n        }\n    }\n    @Override\n    public void refresh(Object obj, OpCallbacks call) {\n        if (obj == null)\n            return;\n        beginOperation(true);\n        try {\n            assertNontransactionalRead();\n            gatherCascadeRefresh(obj, call);\n            if (_operating.isEmpty())\n            \treturn;\n            if (_operating.size() == 1)\n            \trefreshInternal(_operating.iterator().next(), call);\n            else\n            \trefreshInternal(_operating, call);\n        } finally {\n            endOperation();\n        }\n    }\n    /**\n     * Gathers all objects reachable through cascade-refresh relations\n     * into the operating set.\n     */\n    void gatherCascadeRefresh(Object obj, OpCallbacks call) {\n        if (obj == null)\n            return;\n        if (!operatingAdd(obj))\n            return;\n        StateManagerImpl sm = getStateManagerImpl(obj, false);\n        int action = processArgument(OpCallbacks.OP_REFRESH, obj, sm, call);\n        if ((action & OpCallbacks.ACT_CASCADE) == 0)\n            return;\n        if (sm != null)\n            sm.gatherCascadeRefresh(call);\n        else\n            cascadeTransient(OpCallbacks.OP_REFRESH, obj, call, \"refresh\");\n    }\n    /**\n     * This method is called with the full set of objects reachable via\n     * cascade-refresh relations from the user-given instances.\n     */\n<fim_suffix>    protected void refreshInternal(Collection objs, OpCallbacks call) {\n    \tif (objs == null || objs.isEmpty())\n    \t\treturn;\n        List<Exception> exceps = null;\n        try {\n            // collect instances that need a refresh\n            Collection<OpenJPAStateManager> load = null;\n            StateManagerImpl sm;\n            Object obj;\n            for (Iterator<?> itr = objs.iterator(); itr.hasNext();) {\n                obj = itr.next();\n                if (obj == null)\n                    continue;\n                try {\n                    sm = getStateManagerImpl(obj, true);\n                    if ((processArgument(OpCallbacks.OP_REFRESH, obj, sm, call)\n                        & OpCallbacks.ACT_RUN) == 0)\n                        continue;\n                    if (sm != null) {\n                        if (sm.isDetached())\n                            throw newDetachedException(obj, \"refresh\");\n                        else if (sm.beforeRefresh(true)) {\n                        \tif (load == null)\n                        \t\tload = new ArrayList<>(objs.size());\n                            load.add(sm);\n                        }\n                        int level = _fc.getReadLockLevel();\n                        int timeout = _fc.getLockTimeout();\n                        _lm.refreshLock(sm, level, timeout, null);\n                        sm.readLocked(level, level);\n                    } else if (assertPersistenceCapable(obj).pcIsDetached()\n                        == Boolean.TRUE)\n                        throw newDetachedException(obj, \"refresh\");\n                } catch (OpenJPAException ke) {\n                    exceps = add(exceps, ke);\n                }\n            }\n            // refresh all\n            if (load != null) {\n                Collection<Object> failed = _store.loadAll(load, null,\n                    StoreManager.FORCE_LOAD_REFRESH, _fc, null);\n                if (failed != null && !failed.isEmpty())\n                    exceps = add(exceps, newObjectNotFoundException(failed));\n                // perform post-refresh transitions and make sure all fetch\n                // group fields are loaded\n                for (Iterator<OpenJPAStateManager> itr = load.iterator(); itr.hasNext();) {\n                    sm = (StateManagerImpl) itr.next();\n                    if (failed != null && failed.contains(sm.getId()))\n                        continue;\n                    try {\n                        sm.afterRefresh();\n                        sm.load(_fc, StateManagerImpl.LOAD_FGS, null, null,\n                            false);\n                    } catch (OpenJPAException ke) {\n                        exceps = add(exceps, ke);\n                    }\n                }\n            }\n            // now invoke postRefresh on all the instances\n            for (Iterator<?> itr = objs.iterator(); itr.hasNext();) {\n                try {\n                    sm = getStateManagerImpl(itr.next(), true);\n                    if (sm != null && !sm.isDetached())\n                        fireLifecycleEvent(sm.getManagedInstance(), null,\n                            sm.getMetaData(), LifecycleEvent.AFTER_REFRESH);\n                } catch (OpenJPAException ke) {\n                    exceps = add(exceps, ke);\n                }\n            }\n        } catch (OpenJPAException ke) {\n            throw ke;\n        } catch (RuntimeException re) {\n            throw new GeneralException(re);\n        }\n        throwNestedExceptions(exceps, false);\n    }<fim_middle>// function below is long method\n"}