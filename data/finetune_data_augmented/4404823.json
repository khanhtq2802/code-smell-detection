{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.cxf.tracing.brave;\n\nimport java.net.URI;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.logging.Logger;\n\nimport brave.Span;\nimport brave.Tracer.SpanInScope;\nimport brave.http.HttpClientAdapter;\nimport brave.http.HttpClientHandler;\nimport brave.http.HttpTracing;\nimport brave.propagation.Propagation.Setter;\nimport org.apache.cxf.common.logging.LogUtils;\nimport org.apache.cxf.phase.PhaseInterceptorChain;\nimport org.apache.cxf.tracing.AbstractTracingProvider;\nimport org.apache.cxf.tracing.brave.internal.HttpAdapterFactory;\nimport org.apache.cxf.tracing.brave.internal.HttpAdapterFactory.Request;\nimport org.apache.cxf.tracing.brave.internal.HttpAdapterFactory.Response;\nimport org.apache.cxf.tracing.brave.internal.HttpClientAdapterFactory;\n\n<fim_suffix>public abstract class AbstractBraveClientProvider extends AbstractTracingProvider {\n    protected static final Logger LOG = LogUtils.getL7dLogger(AbstractBraveClientProvider.class);\n    protected static final String TRACE_SPAN = \"org.apache.cxf.tracing.client.brave.span\";\n\n    private final HttpTracing brave;\n\n    public AbstractBraveClientProvider(final HttpTracing brave) {\n        this.brave = brave;\n    }\n\n    protected TraceScopeHolder<TraceScope> startTraceSpan(final Map<String, List<String>> requestHeaders,\n            URI uri, String method) {\n\n        final Request request = HttpAdapterFactory.request(requestHeaders, uri, method);\n        final HttpClientAdapter<Request, ?> adapter = HttpClientAdapterFactory.create(request);\n        \n        final HttpClientHandler<Request, ?> handler = HttpClientHandler.create(brave, adapter);\n        final Span span = handler.handleSend(\n            brave\n                .tracing()\n                .propagation()\n                .injector(inject(requestHeaders)), \n            request);\n\n        // In case of asynchronous client invocation, the span should be detached as JAX-RS\n        // client request / response filters are going to be executed in different threads.\n        SpanInScope scope = null;\n        if (!isAsyncInvocation() && span != null) {\n            scope = brave.tracing().tracer().withSpanInScope(span);\n        }\n\n        return new TraceScopeHolder<TraceScope>(new TraceScope(span, scope), scope == null /* detached */);\n    }\n    \n    private <C> Setter<C, String> inject(final Map<String, List<String>> requestHeaders) {\n        return (carrier, key, value) -> {\n            if (!requestHeaders.containsKey(key)) {\n                requestHeaders.put(key, Collections.singletonList(value));\n            }\n        };\n    }\n\n    private boolean isAsyncInvocation() {\n        return !PhaseInterceptorChain.getCurrentMessage().getExchange().isSynchronous();\n    }\n\n    protected void stopTraceSpan(final TraceScopeHolder<TraceScope> holder, final int responseStatus) {\n        if (holder == null) {\n            return;\n        }\n\n        final TraceScope scope = holder.getScope();\n        if (scope != null) {\n            try {\n                // If the client invocation was asynchronous , the trace span has been created\n                // in another thread and should be re-attached to the current one.\n                if (holder.isDetached()) {\n                    brave.tracing().tracer().joinSpan(scope.getSpan().context());\n                }\n    \n                final Response response = HttpAdapterFactory.response(responseStatus);\n                final HttpClientAdapter<?, Response> adapter = HttpClientAdapterFactory.create(response);\n                \n                final HttpClientHandler<?, Response> handler = HttpClientHandler.create(brave, adapter);\n                handler.handleReceive(response, null, scope.getSpan());\n            } finally {\n                scope.close();\n            }\n        }\n    }\n}<fim_middle>// class below has no smell\n"}