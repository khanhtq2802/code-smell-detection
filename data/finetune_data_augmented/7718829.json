{"text": "<fim_prefix>        if (customProperties != null) {\n            return customProperties.containsKey(\"container_request_id\");\n        }\n        return false;\n    }\n    private static String extractVolumeName(String volume) {\n        String hostPart = volume.split(\":/\")[0];\n        // a mount point starts with either / | ~ | . | ..\n        if (!hostPart.isEmpty() &&  !hostPart.matches(\"^(/|~|\\\\.|\\\\.\\\\.).*$\")) {\n            return hostPart;\n        }\n        return null;\n    }\n    private static void discoverVmdkDatastoreForHost(ServiceHost serviceHost, String hostLink,\n            BiConsumer<String, Throwable> consumer) {\n        fetchVmdkDatastoreForHost(serviceHost, hostLink, (datastore, err) -> {\n            if (err != null) {\n                consumer.accept(null, err);\n                return;\n            }\n            if (datastore != null) {\n                consumer.accept(datastore, null);\n                return;\n            }\n            performVmdkDatastoreDiscovery(serviceHost, hostLink, (discoveredDatastore, t) -> {\n                if (t != null) {\n                    consumer.accept(null, t);\n                    return;\n                }\n                consumer.accept(discoveredDatastore, null);\n            });\n        });\n    }\n    private static void fetchVmdkDatastoreForHost(ServiceHost serviceHost, String hostLink,\n            BiConsumer<String, Throwable> consumer) {\n        Operation getHostOp = Operation.createGet(serviceHost, hostLink)\n                .setReferer(serviceHost.getUri())\n                .setCompletion((o, e) -> {\n                    if (e != null) {\n                        consumer.accept(null, e);\n                        return;\n                    }\n                    ComputeState host = o.getBody(ComputeState.class);\n                    String datastore = null;\n                    if (host.customProperties != null) {\n                        datastore = host.customProperties.get(DEFAULT_VMDK_DATASTORE_PROP_NAME);\n                    }\n                    consumer.accept(datastore, null);\n                });\n        serviceHost.sendRequest(getHostOp);\n    }\n    private static void performVmdkDatastoreDiscovery(ServiceHost serviceHost, String hostLink,\n            BiConsumer<String, Throwable> consumer) {\n        // adapter result handler\n        BiConsumer<CallbackServiceHandlerState, ServiceErrorResponse> actualCallback = (o, e) -> {\n            if (e != null) {\n                consumer.accept(null, new Exception(e.message));\n                return;\n            }\n            fetchVmdkDatastoreForHost(serviceHost, hostLink, (datastore, err) -> {\n                if (err != null) {\n                    consumer.accept(null, err);\n                    return;\n                }\n                if (datastore == null) {\n                    String errMsg = String.format(\n                            \"Could not fetch datastore name for host [%s]\"\n                                    + \" after performing datastore discovery.\",\n                            hostLink);\n                    consumer.accept(null, new IllegalStateException(errMsg));\n                    return;\n                }\n                consumer.accept(datastore, null);\n            });\n        };\n        startAndCreateCallbackHandlerService(serviceHost, actualCallback, (taskCallback) -> {\n            AdapterRequest volumeRequest = new AdapterRequest();\n            volumeRequest.resourceReference = UriUtils.buildUri(serviceHost, hostLink);\n            volumeRequest.serviceTaskCallback = taskCallback;\n            volumeRequest.operationTypeId = VolumeOperationType.DISCOVER_VMDK_DATASTORE.id;\n            Operation adapterRequest = Operation\n                    .createPatch(serviceHost, ManagementUriParts.ADAPTER_DOCKER_VOLUME)\n                    .setReferer(serviceHost.getUri())\n                    .setBody(volumeRequest)\n                    .setCompletion((o, e) -> {\n                        if (e != null) {\n                            consumer.accept(null, e);\n                            return;\n                        }\n                    });\n            serviceHost.sendRequest(adapterRequest);\n        });\n    }\n    private static void addAffinity(String affinityTo, ContainerDescription cd) {\n        if (cd.affinity != null) {\n            boolean alreadyIn = Arrays.stream(cd.affinity).anyMatch(af -> affinityTo.equals(af));\n            if (!alreadyIn) {\n                int newSize = cd.affinity.length + 1;\n                cd.affinity = Arrays.copyOf(cd.affinity, newSize);\n                cd.affinity[newSize - 1] = affinityTo;\n            }\n        } else {\n            cd.affinity = new String[] { affinityTo };\n        }\n    }\n    private static Set<String> filterByVolume(String volumeName,\n            Collection<ContainerDescription> descs) {\n        Predicate<ContainerDescription> hasVolume = cd -> {\n            if (cd.volumes != null) {\n                return Arrays.stream(cd.volumes).anyMatch(v -> v.startsWith(volumeName));\n            }\n            return false;\n        };\n        return descs.stream()\n                .filter(hasVolume)\n                .map(cd -> cd.name)\n                .collect(Collectors.toSet());\n    }\n    private static List<ContainerVolumeDescription> filterVolumes(ContainerDescription cd,\n            Collection<ContainerVolumeDescription> volumes) {\n        if (cd.volumes == null) {\n            return Collections.emptyList();\n        }\n        Predicate<ContainerVolumeDescription> hasVolume = vd -> Arrays.stream(cd.volumes)\n                .anyMatch(v -> v.startsWith(vd.name));\n        return volumes.stream()\n                .filter(hasVolume)\n                .collect(Collectors.toList());\n    }\n    private static <T extends ResourceState> Map<String, T> filterDescriptions(\n            Class<T> clazz, Collection<ComponentDescription> componentDescriptions) {\n        return componentDescriptions.stream()\n                .filter(cd -> clazz.isInstance(cd.getServiceDocument()))\n                .map(cd -> clazz.cast(cd.getServiceDocument()))\n                .collect(Collectors.toMap(c -> c.name, c -> c));\n    }\n    private static List<Set<String>> mergeSets(List<Set<String>> list) {\n        if (list.size() < 2) {\n            return list;\n        }\n        for (int i = 0; i < list.size() - 1; i++) {\n            Set<String> current = list.get(i);\n            Set<String> next = list.get(i + 1);\n            if (!disjoint(current, next)) {\n                list.remove(current);\n                list.remove(next);\n                current.addAll(next);\n                list.add(current);\n                list = mergeSets(list);\n                break;\n            }\n        }\n        return list;\n    }\n    private static void startAndCreateCallbackHandlerService(ServiceHost serviceHost,\n            BiConsumer<CallbackServiceHandlerState, ServiceErrorResponse> actualCallback,\n            Consumer<ServiceTaskCallback> caller) {\n        if (actualCallback == null) {\n            caller.accept(ServiceTaskCallback.createEmpty());\n            return;\n        }\n        CallbackServiceHandlerState body = new CallbackServiceHandlerState();\n        String callbackLink = ManagementUriParts.REQUEST_CALLBACK_HANDLER_TASKS\n                + UUID.randomUUID().toString();\n        body.documentSelfLink = callbackLink;\n        URI callbackUri = UriUtils.buildUri(serviceHost, callbackLink);\n        Operation startPost = Operation\n                .createPost(callbackUri)\n                .setBody(body)\n                .setCompletion((o, e) -> {\n                    if (e != null) {\n                        serviceHost.log(Level.WARNING,\n                                \"Failure creating callback handler. Error %s\",\n                                Utils.toString(e));\n                        return;\n                    }\n                    serviceHost.log(Level.FINE,\n                            \"Callback task created with uri: %s, %s\",\n                            callbackUri, o.getUri());\n                    caller.accept(ServiceTaskCallback.create(callbackUri.toString()));\n                });\n        VmdkDatastoreDiscoveredCallbackHandler service = new VmdkDatastoreDiscoveredCallbackHandler(\n                actualCallback);\n        service.setCompletionCallback(() -> serviceHost.stopService(service));\n        serviceHost.startService(startPost, service);\n    }\n<fim_suffix>    private static class VmdkDatastoreDiscoveredCallbackHandler extends\n            AbstractCallbackServiceHandler {\n        private final BiConsumer<CallbackServiceHandlerState, ServiceErrorResponse> consumer;\n        public VmdkDatastoreDiscoveredCallbackHandler(\n                BiConsumer<CallbackServiceHandlerState, ServiceErrorResponse> consumer) {\n            this.consumer = consumer;\n        }\n        @Override\n        protected void handleFailedStagePatch(CallbackServiceHandlerState state) {\n            ServiceErrorResponse err = state.taskInfo.failure;\n            logWarning(\"Failed updating host info\");\n            if (err != null && err.stackTrace != null) {\n                logFine(\"Task failure stack trace: %s\", err.stackTrace);\n                logWarning(\"Task failure error message: %s\", err.message);\n                consumer.accept(state, err);\n                if (completionCallback != null) {\n                    completionCallback.run();\n                }\n            }\n        }\n        @Override\n        protected void handleFinishedStagePatch(CallbackServiceHandlerState state) {\n            consumer.accept(state, null);\n            if (completionCallback != null) {\n                completionCallback.run();\n            }\n        }\n    }<fim_middle>// class below has no smell\n"}