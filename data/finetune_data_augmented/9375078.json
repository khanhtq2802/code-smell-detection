{"text": "<fim_prefix>                failed = t;\n                try {\n                    close();\n                } catch (IOException x) {\n                    // OK\n                } finally {\n                    onError(t);\n                }\n            }\n        }\n        @Override\n        public void onNext(List<ByteBuffer> t) {\n            Objects.requireNonNull(t);\n            try {\n                if (debug.on()) debug.log(\"next item received\");\n                if (!buffers.offer(t)) {\n                    throw new IllegalStateException(\"queue is full\");\n                }\n                if (debug.on()) debug.log(\"item offered\");\n            } catch (Throwable ex) {\n                failed = ex;\n                try {\n                    close();\n                } catch (IOException ex1) {\n                    // OK\n                } finally {\n                    onError(ex);\n                }\n            }\n        }\n        @Override\n        public void onError(Throwable thrwbl) {\n            subscription = null;\n            failed = Objects.requireNonNull(thrwbl);\n            // The client process that reads the input stream might\n            // be blocked in queue.take().\n            // Tries to offer LAST_LIST to the queue. If the queue is\n            // full we don't care if we can't insert this buffer, as\n            // the client can't be blocked in queue.take() in that case.\n            // Adding LAST_LIST to the queue is harmless, as the client\n            // should find failed != null before handling LAST_LIST.\n            buffers.offer(LAST_LIST);\n        }\n        @Override\n        public void onComplete() {\n            subscription = null;\n            onNext(LAST_LIST);\n        }\n        @Override\n        public void close() throws IOException {\n            Flow.Subscription s;\n            synchronized (this) {\n                if (closed) return;\n                closed = true;\n                s = subscription;\n                subscription = null;\n            }\n            // s will be null if already completed\n            try {\n                if (s != null) {\n                    s.cancel();\n                }\n            } finally {\n                buffers.offer(LAST_LIST);\n                super.close();\n            }\n        }\n    }\n    public static BodySubscriber<Stream<String>> createLineStream() {\n        return createLineStream(UTF_8);\n    }\n    public static BodySubscriber<Stream<String>> createLineStream(Charset charset) {\n        Objects.requireNonNull(charset);\n        BodySubscriber<InputStream> s = new HttpResponseInputStream();\n        // Creates a MappingSubscriber with a trusted finisher that is\n        // trusted not to block.\n        return new MappingSubscriber<InputStream,Stream<String>>(s,\n            (InputStream stream) -> {\n                return new BufferedReader(new InputStreamReader(stream, charset))\n                            .lines().onClose(() -> Utils.close(stream));\n            }, true);\n    }\n    /**\n     * Currently this consumes all of the data and ignores it\n     */\n    public static class NullSubscriber<T> implements TrustedSubscriber<T> {\n        private final CompletableFuture<T> cf = new MinimalFuture<>();\n        private final Optional<T> result;\n        private final AtomicBoolean subscribed = new AtomicBoolean();\n        public NullSubscriber(Optional<T> result) {\n            this.result = result;\n        }\n        @Override\n        public void onSubscribe(Flow.Subscription subscription) {\n            if (!subscribed.compareAndSet(false, true)) {\n                subscription.cancel();\n            } else {\n                subscription.request(Long.MAX_VALUE);\n            }\n        }\n        @Override\n        public void onNext(List<ByteBuffer> items) {\n            Objects.requireNonNull(items);\n        }\n        @Override\n        public void onError(Throwable throwable) {\n            cf.completeExceptionally(throwable);\n        }\n        @Override\n        public void onComplete() {\n            if (result.isPresent()) {\n                cf.complete(result.get());\n            } else {\n                cf.complete(null);\n            }\n        }\n        @Override\n        public CompletionStage<T> getBody() {\n            return cf;\n        }\n    }\n    /** An adapter between {@code BodySubscriber} and {@code Flow.Subscriber}. */\n    public static final class SubscriberAdapter<S extends Subscriber<? super List<ByteBuffer>>,R>\n        implements TrustedSubscriber<R>\n    {\n        private final CompletableFuture<R> cf = new MinimalFuture<>();\n        private final S subscriber;\n        private final Function<? super S,? extends R> finisher;\n        private volatile Subscription subscription;\n        // The finisher isn't called until all bytes have been received,\n        // and so shouldn't need an executor. No need to override\n        // TrustedSubscriber::needsExecutor\n        public SubscriberAdapter(S subscriber, Function<? super S,? extends R> finisher) {\n            this.subscriber = Objects.requireNonNull(subscriber);\n            this.finisher = Objects.requireNonNull(finisher);\n        }\n        @Override\n        public void onSubscribe(Subscription subscription) {\n            Objects.requireNonNull(subscription);\n            if (this.subscription != null) {\n                subscription.cancel();\n            } else {\n                this.subscription = subscription;\n                subscriber.onSubscribe(subscription);\n            }\n        }\n        @Override\n        public void onNext(List<ByteBuffer> item) {\n            Objects.requireNonNull(item);\n            try {\n                subscriber.onNext(item);\n            } catch (Throwable throwable) {\n                subscription.cancel();\n                onError(throwable);\n            }\n        }\n        @Override\n        public void onError(Throwable throwable) {\n            Objects.requireNonNull(throwable);\n            try {\n                subscriber.onError(throwable);\n            } finally {\n                cf.completeExceptionally(throwable);\n            }\n        }\n        @Override\n        public void onComplete() {\n            try {\n                subscriber.onComplete();\n            } finally {\n                try {\n                    cf.complete(finisher.apply(subscriber));\n                } catch (Throwable throwable) {\n                    cf.completeExceptionally(throwable);\n                }\n            }\n        }\n        @Override\n        public CompletionStage<R> getBody() {\n            return cf;\n        }\n    }\n    /**\n     * A body subscriber which receives input from an upstream subscriber\n     * and maps that subscriber's body type to a new type. The upstream subscriber\n     * delegates all flow operations directly to this object. The\n     * {@link CompletionStage} returned by {@link #getBody()}} takes the output\n     * of the upstream {@code getBody()} and applies the mapper function to\n     * obtain the new {@code CompletionStage} type.\n     *\n     * @param <T> the upstream body type\n     * @param <U> this subscriber's body type\n     */\n    public static class MappingSubscriber<T,U> implements TrustedSubscriber<U> {\n        private final BodySubscriber<T> upstream;\n        private final Function<? super T,? extends U> mapper;\n        private final boolean trusted;\n        public MappingSubscriber(BodySubscriber<T> upstream,\n                                 Function<? super T,? extends U> mapper) {\n            this(upstream, mapper, false);\n        }\n        // creates a MappingSubscriber with a mapper that is trusted\n        // to not block when called.\n        MappingSubscriber(BodySubscriber<T> upstream,\n                          Function<? super T,? extends U> mapper,\n                          boolean trusted) {\n            this.upstream = Objects.requireNonNull(upstream);\n            this.mapper = Objects.requireNonNull(mapper);\n            this.trusted = trusted;\n        }\n        // There is no way to know whether a custom mapper function\n        // might block or not - so we should return true unless the\n        // mapper is implemented and trusted by our own code not to\n        // block.\n        @Override\n        public boolean needsExecutor() {\n            return !trusted || TrustedSubscriber.needsExecutor(upstream);\n        }\n        // If upstream.getBody() is already completed (case of InputStream),\n        // then calling upstream.getBody().thenApply(mapper) might block\n        // if the mapper blocks. We should probably add a variant of\n        // MappingSubscriber that calls thenApplyAsync instead, but this\n        // needs a new public API point. See needsExecutor() above.\n        @Override\n        public CompletionStage<U> getBody() {\n            return upstream.getBody().thenApply(mapper);\n        }\n        @Override\n        public void onSubscribe(Flow.Subscription subscription) {\n            upstream.onSubscribe(subscription);\n        }\n        @Override\n        public void onNext(List<ByteBuffer> item) {\n            upstream.onNext(item);\n        }\n        @Override\n        public void onError(Throwable throwable) {\n            upstream.onError(throwable);\n        }\n        @Override\n        public void onComplete() {\n            upstream.onComplete();\n        }\n    }\n    // A BodySubscriber that returns a Publisher<List<ByteBuffer>>\n    static class PublishingBodySubscriber\n            implements TrustedSubscriber<Flow.Publisher<List<ByteBuffer>>> {\n        private final MinimalFuture<Flow.Subscription>\n                subscriptionCF = new MinimalFuture<>();\n        private final MinimalFuture<SubscriberRef>\n                subscribedCF = new MinimalFuture<>();\n        private AtomicReference<SubscriberRef>\n                subscriberRef = new AtomicReference<>();\n        private final CompletionStage<Flow.Publisher<List<ByteBuffer>>> body =\n                subscriptionCF.thenCompose(\n                        (s) -> MinimalFuture.completedFuture(this::subscribe));\n        // We use the completionCF to ensure that only one of\n        // onError or onComplete is ever called.\n        private final MinimalFuture<Void> completionCF;\n<fim_suffix>        private PublishingBodySubscriber() {\n            completionCF = new MinimalFuture<>();\n            completionCF.whenComplete(\n                    (r,t) -> subscribedCF.thenAccept( s -> complete(s, t)));\n        }<fim_middle>// function below has no smell\n"}