{"text": "<fim_prefix>/*\n * Copyright (c) 2012, 2018, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n\npackage org.graalvm.compiler.loop;\n\nimport static org.graalvm.compiler.loop.MathUtil.add;\nimport static org.graalvm.compiler.loop.MathUtil.mul;\nimport static org.graalvm.compiler.loop.MathUtil.sub;\n\nimport org.graalvm.compiler.core.common.type.IntegerStamp;\nimport org.graalvm.compiler.core.common.type.Stamp;\nimport org.graalvm.compiler.core.common.util.UnsignedLong;\nimport org.graalvm.compiler.debug.GraalError;\nimport org.graalvm.compiler.nodes.ConstantNode;\nimport org.graalvm.compiler.nodes.NodeView;\nimport org.graalvm.compiler.nodes.StructuredGraph;\nimport org.graalvm.compiler.nodes.ValueNode;\nimport org.graalvm.compiler.nodes.ValuePhiNode;\nimport org.graalvm.compiler.nodes.calc.AddNode;\nimport org.graalvm.compiler.nodes.calc.BinaryArithmeticNode;\nimport org.graalvm.compiler.nodes.calc.IntegerConvertNode;\nimport org.graalvm.compiler.nodes.calc.NegateNode;\nimport org.graalvm.compiler.nodes.calc.SubNode;\n\n<fim_suffix>public class BasicInductionVariable extends InductionVariable {\n\n    private final ValuePhiNode phi;\n    private final ValueNode init;\n    private ValueNode rawStride;\n    private BinaryArithmeticNode<?> op;\n\n    public BasicInductionVariable(LoopEx loop, ValuePhiNode phi, ValueNode init, ValueNode rawStride, BinaryArithmeticNode<?> op) {\n        super(loop);\n        this.phi = phi;\n        this.init = init;\n        this.rawStride = rawStride;\n        this.op = op;\n    }\n\n    @Override\n    public StructuredGraph graph() {\n        return phi.graph();\n    }\n\n    public BinaryArithmeticNode<?> getOp() {\n        return op;\n    }\n\n    public void setOP(BinaryArithmeticNode<?> newOp) {\n        rawStride = newOp.getY();\n        op = newOp;\n    }\n\n    @Override\n    public Direction direction() {\n        Stamp stamp = rawStride.stamp(NodeView.DEFAULT);\n        if (stamp instanceof IntegerStamp) {\n            IntegerStamp integerStamp = (IntegerStamp) stamp;\n            Direction dir = null;\n            if (integerStamp.isStrictlyPositive()) {\n                dir = Direction.Up;\n            } else if (integerStamp.isStrictlyNegative()) {\n                dir = Direction.Down;\n            }\n            if (dir != null) {\n                if (op instanceof AddNode) {\n                    return dir;\n                } else {\n                    assert op instanceof SubNode;\n                    return dir.opposite();\n                }\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public ValuePhiNode valueNode() {\n        return phi;\n    }\n\n    @Override\n    public ValueNode initNode() {\n        return init;\n    }\n\n    @Override\n    public ValueNode strideNode() {\n        if (op instanceof AddNode) {\n            return rawStride;\n        }\n        if (op instanceof SubNode) {\n            return graph().unique(new NegateNode(rawStride));\n        }\n        throw GraalError.shouldNotReachHere();\n    }\n\n    @Override\n    public boolean isConstantInit() {\n        return init.isConstant();\n    }\n\n    @Override\n    public boolean isConstantStride() {\n        return rawStride.isConstant();\n    }\n\n    @Override\n    public long constantInit() {\n        return init.asJavaConstant().asLong();\n    }\n\n    @Override\n    public long constantStride() {\n        if (op instanceof AddNode) {\n            return rawStride.asJavaConstant().asLong();\n        }\n        if (op instanceof SubNode) {\n            return -rawStride.asJavaConstant().asLong();\n        }\n        throw GraalError.shouldNotReachHere();\n    }\n\n    @Override\n    public ValueNode extremumNode(boolean assumeLoopEntered, Stamp stamp) {\n        Stamp fromStamp = phi.stamp(NodeView.DEFAULT);\n        StructuredGraph graph = graph();\n        ValueNode stride = strideNode();\n        ValueNode initNode = this.initNode();\n        if (!fromStamp.isCompatible(stamp)) {\n            stride = IntegerConvertNode.convert(stride, stamp, graph(), NodeView.DEFAULT);\n            initNode = IntegerConvertNode.convert(initNode, stamp, graph(), NodeView.DEFAULT);\n        }\n        ValueNode maxTripCount = loop.counted().maxTripCountNode(assumeLoopEntered);\n        if (!maxTripCount.stamp(NodeView.DEFAULT).isCompatible(stamp)) {\n            maxTripCount = IntegerConvertNode.convert(maxTripCount, stamp, graph(), NodeView.DEFAULT);\n        }\n        return add(graph, mul(graph, stride, sub(graph, maxTripCount, ConstantNode.forIntegerStamp(stamp, 1, graph))), initNode);\n    }\n\n    @Override\n    public ValueNode exitValueNode() {\n        Stamp stamp = phi.stamp(NodeView.DEFAULT);\n        ValueNode maxTripCount = loop.counted().maxTripCountNode();\n        if (!maxTripCount.stamp(NodeView.DEFAULT).isCompatible(stamp)) {\n            maxTripCount = IntegerConvertNode.convert(maxTripCount, stamp, graph(), NodeView.DEFAULT);\n        }\n        return add(graph(), mul(graph(), strideNode(), maxTripCount), initNode());\n    }\n\n    @Override\n    public boolean isConstantExtremum() {\n        return isConstantInit() && isConstantStride() && loop.counted().isConstantMaxTripCount();\n    }\n\n    @Override\n    public long constantExtremum() {\n        UnsignedLong tripCount = loop.counted().constantMaxTripCount();\n        if (tripCount.isLessThan(1)) {\n            return constantInit();\n        }\n        return tripCount.minus(1).wrappingTimes(constantStride()).wrappingPlus(constantInit()).asLong();\n    }\n\n    @Override\n    public void deleteUnusedNodes() {\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"BasicInductionVariable %s %s %s %s\", initNode(), phi, op.getNodeClass().shortName(), strideNode());\n    }\n}<fim_middle>// class below has no smell\n"}