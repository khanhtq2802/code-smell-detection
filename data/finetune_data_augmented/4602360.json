{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.giraph.comm.requests;\n\nimport org.apache.giraph.comm.ServerData;\nimport org.apache.giraph.graph.VertexMutations;\nimport org.apache.giraph.metrics.GiraphMetrics;\nimport org.apache.giraph.metrics.MetricNames;\nimport org.apache.hadoop.io.Writable;\nimport org.apache.hadoop.io.WritableComparable;\nimport org.apache.log4j.Logger;\n\nimport com.google.common.collect.Maps;\nimport com.yammer.metrics.core.Histogram;\n\nimport java.io.DataInput;\nimport java.io.DataOutput;\nimport java.io.IOException;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\n/**\n * Send a collection of vertex mutations for a partition. This type of request\n * is used for two purposes: 1) sending mutation requests generated due to user\n * compute function in the middle of the execution of a superstep, and\n * 2) sending mutation requests due to partition migration.\n *\n * @param <I> Vertex id\n * @param <V> Vertex data\n * @param <E> Edge data\n */\n@SuppressWarnings(\"rawtypes\")\npublic class SendPartitionMutationsRequest<I extends WritableComparable,\n    V extends Writable, E extends Writable> extends\n    WritableRequest<I, V, E> implements WorkerRequest<I, V, E> {\n  /** Class logger */\n  private static final Logger LOG =\n      Logger.getLogger(SendPartitionMutationsRequest.class);\n  /** Partition id */\n  private int partitionId;\n  /** Mutations sent for a partition */\n  private Map<I, VertexMutations<I, V, E>> vertexIdMutations;\n\n  /**\n   * Constructor used for reflection only\n   */\n  public SendPartitionMutationsRequest() { }\n\n  /**\n   * Constructor used to send request.\n   *\n   * @param partitionId Partition to send the request to\n   * @param vertexIdMutations Map of mutations to send\n   */\n  public SendPartitionMutationsRequest(\n      int partitionId,\n      Map<I, VertexMutations<I, V, E>> vertexIdMutations) {\n    this.partitionId = partitionId;\n    this.vertexIdMutations = vertexIdMutations;\n  }\n\n  @Override\n  public void readFieldsRequest(DataInput input) throws IOException {\n    partitionId = input.readInt();\n    int vertexIdMutationsSize = input.readInt();\n    // The request is going to be served by adding/merging it with the current\n    // mutations stored in ServerData. Since the mutations stored in ServerData\n    // is in the form of a ConcurrentMap, the data here is being read in this\n    // form, so it would be more efficient to merge/add the mutations in this\n    // request with/to mutations stored in SeverData.\n    vertexIdMutations = Maps.newConcurrentMap();\n    for (int i = 0; i < vertexIdMutationsSize; ++i) {\n      I vertexId = getConf().createVertexId();\n      vertexId.readFields(input);\n      VertexMutations<I, V, E> vertexMutations =\n          new VertexMutations<I, V, E>();\n      vertexMutations.setConf(getConf());\n      vertexMutations.readFields(input);\n      if (vertexIdMutations.put(vertexId, vertexMutations) != null) {\n        throw new IllegalStateException(\n            \"readFields: Already has vertex id \" + vertexId);\n      }\n    }\n  }\n\n<fim_suffix>  @Override\n  public void writeRequest(DataOutput output) throws IOException {\n    output.writeInt(partitionId);\n    output.writeInt(vertexIdMutations.size());\n    for (Entry<I, VertexMutations<I, V, E>> entry :\n        vertexIdMutations.entrySet()) {\n      entry.getKey().write(output);\n      entry.getValue().write(output);\n    }\n  }\n\n  @Override\n  public RequestType getType() {\n    return RequestType.SEND_PARTITION_MUTATIONS_REQUEST;\n  }\n\n  @Override\n  public void doRequest(ServerData<I, V, E> serverData) {\n    ConcurrentMap<Integer, ConcurrentMap<I, VertexMutations<I, V, E>>>\n        partitionMutations = serverData.getPartitionMutations();\n    Histogram verticesInMutationHist = GiraphMetrics.get().perSuperstep()\n        .getUniformHistogram(MetricNames.VERTICES_IN_MUTATION_REQUEST);\n    int mutationSize = 0;\n    for (Map<I, VertexMutations<I, V, E>> map : partitionMutations.values()) {\n      mutationSize += map.size();\n    }\n    verticesInMutationHist.update(mutationSize);\n    // If the request is a result of sending mutations in the middle of the\n    // superstep to local partitions, the request is \"short-circuit\"ed and\n    // vertexIdMutations is coming from an instance of SendMutationsCache.\n    // Since the vertex mutations are created locally, they are not stored in\n    // a ConcurrentMap. So, we first need to transform the data structure\n    // for more efficiently merge/add process.\n    if (!(vertexIdMutations instanceof ConcurrentMap)) {\n      vertexIdMutations = new ConcurrentHashMap<>(vertexIdMutations);\n    }\n\n    ConcurrentMap<I, VertexMutations<I, V, E>> currentVertexIdMutations =\n        partitionMutations.putIfAbsent(partitionId,\n            (ConcurrentMap<I, VertexMutations<I, V, E>>) vertexIdMutations);\n\n    if (currentVertexIdMutations != null) {\n      for (Entry<I, VertexMutations<I, V, E>> entry : vertexIdMutations\n          .entrySet()) {\n        VertexMutations<I, V, E> mutations = currentVertexIdMutations\n            .putIfAbsent(entry.getKey(), entry.getValue());\n        if (mutations != null) {\n          synchronized (mutations) {\n            mutations.addVertexMutations(entry.getValue());\n          }\n        }\n      }\n    }\n  }\n\n  @Override\n  public int getSerializedSize() {\n    return WritableRequest.UNKNOWN_SIZE;\n  }\n}<fim_middle>// function below has no smell\n"}