{"text": "<fim_prefix>   * @param blobId the {@link BlobId} to operate on.\n   * @param getOption the {@link GetOption} to send with the {@link GetRequest}.\n   * @param clusterMap the {@link ClusterMap} to use.\n   * @return the {@link ServerErrorCode} and {@link BlobProperties} of {@code blobId}.\n   * @throws Exception\n   */\n  public Pair<ServerErrorCode, BlobProperties> getBlobProperties(DataNodeId dataNodeId, BlobId blobId,\n      GetOption getOption, ClusterMap clusterMap) throws Exception {\n    Pair<ServerErrorCode, InputStream> response =\n        getGetResponse(dataNodeId, blobId, MessageFormatFlags.BlobProperties, getOption, clusterMap);\n    InputStream stream = response.getSecond();\n    BlobProperties blobProperties = stream != null ? MessageFormatRecord.deserializeBlobProperties(stream) : null;\n    return new Pair<>(response.getFirst(), blobProperties);\n  }\n  /**\n   * Gets user metadata for {@code blobId}.\n   * @param dataNodeId the {@link DataNodeId} to contact.\n   * @param blobId the {@link BlobId} to operate on.\n   * @param getOption the {@link GetOption} to send with the {@link GetRequest}.\n   * @param clusterMap the {@link ClusterMap} to use.\n   * @return the {@link ServerErrorCode} and user metadata as a {@link ByteBuffer} for {@code blobId}\n   * @throws Exception\n   */\n  public Pair<ServerErrorCode, ByteBuffer> getUserMetadata(DataNodeId dataNodeId, BlobId blobId, GetOption getOption,\n      ClusterMap clusterMap) throws Exception {\n    Pair<ServerErrorCode, InputStream> response =\n        getGetResponse(dataNodeId, blobId, MessageFormatFlags.BlobUserMetadata, getOption, clusterMap);\n    InputStream stream = response.getSecond();\n    ByteBuffer userMetadata = stream != null ? MessageFormatRecord.deserializeUserMetadata(stream) : null;\n    return new Pair<>(response.getFirst(), userMetadata);\n  }\n  /**\n   * Gets blob data for {@code blobId}.\n   * @param dataNodeId the {@link DataNodeId} to contact.\n   * @param blobId the {@link BlobId} to operate on.\n   * @param getOption the {@link GetOption} to send with the {@link GetRequest}.\n   * @param clusterMap the {@link ClusterMap} to use.\n   * @return the {@link ServerErrorCode} and {@link BlobData} for {@code blobId}\n   * @throws Exception\n   */\n  public Pair<ServerErrorCode, BlobData> getBlob(DataNodeId dataNodeId, BlobId blobId, GetOption getOption,\n      ClusterMap clusterMap) throws Exception {\n    Pair<ServerErrorCode, InputStream> response =\n        getGetResponse(dataNodeId, blobId, MessageFormatFlags.Blob, getOption, clusterMap);\n    InputStream stream = response.getSecond();\n    BlobData blobData = stream != null ? MessageFormatRecord.deserializeBlob(stream) : null;\n    return new Pair<>(response.getFirst(), blobData);\n  }\n  /**\n   * Gets all data for {@code blobId}.\n   * @param dataNodeId the {@link DataNodeId} to contact.\n   * @param blobId the {@link BlobId} to operate on.\n   * @param getOption the {@link GetOption} to send with the {@link GetRequest}.\n   * @param clusterMap the {@link ClusterMap} to use.\n   * @param storeKeyFactory the {@link StoreKeyFactory} to use.\n   * @return the {@link ServerErrorCode} and {@link BlobAll} for {@code blobId}\n   * @throws Exception\n   */\n  public Pair<ServerErrorCode, BlobAll> getAll(DataNodeId dataNodeId, BlobId blobId, GetOption getOption,\n      ClusterMap clusterMap, StoreKeyFactory storeKeyFactory) throws Exception {\n    Pair<ServerErrorCode, InputStream> response =\n        getGetResponse(dataNodeId, blobId, MessageFormatFlags.All, getOption, clusterMap);\n    InputStream stream = response.getSecond();\n    BlobAll blobAll = stream != null ? MessageFormatRecord.deserializeBlobAll(stream, storeKeyFactory) : null;\n    return new Pair<>(response.getFirst(), blobAll);\n  }\n  /**\n   * Triggers compaction on {@code dataNodeId} for the partition defined in {@code partitionIdStr}.\n   * @param dataNodeId the {@link DataNodeId} to contact.\n   * @param partitionId the {@link PartitionId} to compact.\n   * @return the {@link ServerErrorCode} that is returned.\n   * @throws IOException\n   * @throws TimeoutException\n   */\n  public ServerErrorCode triggerCompaction(DataNodeId dataNodeId, PartitionId partitionId)\n      throws IOException, TimeoutException {\n    AdminRequest adminRequest =\n        new AdminRequest(AdminRequestOrResponseType.TriggerCompaction, partitionId, correlationId.incrementAndGet(),\n            CLIENT_ID);\n    ByteBuffer responseBytes = sendRequestGetResponse(dataNodeId, adminRequest);\n    AdminResponse adminResponse = AdminResponse.readFrom(new DataInputStream(new ByteBufferInputStream(responseBytes)));\n    return adminResponse.getError();\n  }\n  /**\n   * Sends a {@link RequestControlAdminRequest} to set the enable state of {@code toControl} on {@code partitionIdStr}\n   * to {@code enable} in {@code dataNodeId}.\n   * @param dataNodeId the {@link DataNodeId} to contact.\n   * @param partitionId the {@link PartitionId} to control requests to. Can be {@code null}.\n   * @param toControl the {@link RequestOrResponseType} to control.\n   * @param enable the enable (or disable) status required for {@code toControl}.\n   * @return the {@link ServerErrorCode} that is returned.\n   * @throws IOException\n   * @throws TimeoutException\n   */\n  public ServerErrorCode controlRequest(DataNodeId dataNodeId, PartitionId partitionId, RequestOrResponseType toControl,\n      boolean enable) throws IOException, TimeoutException {\n    AdminRequest adminRequest =\n        new AdminRequest(AdminRequestOrResponseType.RequestControl, partitionId, correlationId.incrementAndGet(),\n            CLIENT_ID);\n    RequestControlAdminRequest controlRequest = new RequestControlAdminRequest(toControl, enable, adminRequest);\n    ByteBuffer responseBytes = sendRequestGetResponse(dataNodeId, controlRequest);\n    AdminResponse adminResponse = AdminResponse.readFrom(new DataInputStream(new ByteBufferInputStream(responseBytes)));\n    return adminResponse.getError();\n  }\n  /**\n   * Sends a {@link ReplicationControlAdminRequest} to enable/disable replication from {@code origins} for\n   * {@code partitionIdStr} in {@code dataNodeId}.\n   * @param dataNodeId the {@link DataNodeId} to contact.\n   * @param partitionId the {@link PartitionId} to control replication for. Can be {@code null}.\n   * @param origins the names of the datacenters from which replication should be controlled.\n   * @param enable the enable (or disable) status required for replication from {@code origins}.\n   * @return the {@link ServerErrorCode} that is returned.\n   * @throws IOException\n   * @throws TimeoutException\n   */\n  public ServerErrorCode controlReplication(DataNodeId dataNodeId, PartitionId partitionId, List<String> origins,\n      boolean enable) throws IOException, TimeoutException {\n    AdminRequest adminRequest =\n        new AdminRequest(AdminRequestOrResponseType.ReplicationControl, partitionId, correlationId.incrementAndGet(),\n            CLIENT_ID);\n    ReplicationControlAdminRequest controlRequest = new ReplicationControlAdminRequest(origins, enable, adminRequest);\n    ByteBuffer responseBytes = sendRequestGetResponse(dataNodeId, controlRequest);\n    AdminResponse adminResponse = AdminResponse.readFrom(new DataInputStream(new ByteBufferInputStream(responseBytes)));\n    return adminResponse.getError();\n  }\n  /**\n   * Sends a {@link BlobStoreControlAdminRequest} to start or stop a store associated with {@code partitionId}\n   * on {@code dataNodeId}.\n   * @param dataNodeId the {@link DataNodeId} to contact.\n   * @param partitionId the {@link PartitionId} to start or stop.\n   * @param numReplicasCaughtUpPerPartition the minimum number of peers should catch up with partition if the store is\n   *                                        being stopped\n   * @param enable the enable (or disable) status required for BlobStore control.\n   * @return the {@link ServerErrorCode} that is returned.\n   * @throws IOException\n   * @throws TimeoutException\n   */\n<fim_suffix>  private ServerErrorCode controlBlobStore(DataNodeId dataNodeId, PartitionId partitionId,\n      short numReplicasCaughtUpPerPartition, boolean enable) throws IOException, TimeoutException {\n    AdminRequest adminRequest =\n        new AdminRequest(AdminRequestOrResponseType.BlobStoreControl, partitionId, correlationId.incrementAndGet(),\n            CLIENT_ID);\n    BlobStoreControlAdminRequest controlRequest =\n        new BlobStoreControlAdminRequest(numReplicasCaughtUpPerPartition, enable, adminRequest);\n    ByteBuffer responseBytes = sendRequestGetResponse(dataNodeId, controlRequest);\n    AdminResponse adminResponse = AdminResponse.readFrom(new DataInputStream(new ByteBufferInputStream(responseBytes)));\n    return adminResponse.getError();\n  }<fim_middle>// function below has no smell\n"}