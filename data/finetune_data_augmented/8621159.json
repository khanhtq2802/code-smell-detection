{"text": "<fim_prefix>            List<ClusterNode> subgrid,\n            @Nullable Object arg\n        ) throws IgniteException {\n            Map<ComputeJob, ClusterNode> jobs = new HashMap();\n            for (ClusterNode node : subgrid)\n                jobs.put(new PartitionSizeLongJob(cacheName, topVer, peekModes, partition), node);\n            return jobs;\n        }\n        /** {@inheritDoc} */\n        @Override public ComputeJobResultPolicy result(ComputeJobResult res, List<ComputeJobResult> rcvd) {\n            IgniteException e = res.getException();\n            if (e != null) {\n                if (e instanceof ClusterTopologyException)\n                    return ComputeJobResultPolicy.WAIT;\n                throw new IgniteException(\"Remote job threw exception.\", e);\n            }\n            return ComputeJobResultPolicy.WAIT;\n        }\n        /** {@inheritDoc} */\n        @Nullable @Override public Long reduce(List<ComputeJobResult> results) throws IgniteException {\n            long size = 0;\n            for (ComputeJobResult res : results) {\n                if (res != null) {\n                    if (res.getException() == null)\n                        size += res.<Long>getData();\n                    else\n                        throw res.getException();\n                }\n            }\n            return size;\n        }\n    }\n    /**\n     * Clear task.\n     */\n    @GridInternal\n    private static class ClearTask<K> extends ComputeTaskAdapter<Object, Object> {\n        /** */\n        private static final long serialVersionUID = 0L;\n        /** Cache name. */\n        private final String cacheName;\n        /** Affinity topology version. */\n        private final AffinityTopologyVersion topVer;\n        /** Keys to clear. */\n        private final Set<? extends K> keys;\n        /** Near cache flag. */\n        private final boolean near;\n        /**\n         * @param cacheName Cache name.\n         * @param topVer Affinity topology version.\n         * @param keys Keys to clear.\n         * @param near Near cache flag.\n         */\n        public ClearTask(String cacheName, AffinityTopologyVersion topVer, Set<? extends K> keys, boolean near) {\n            this.cacheName = cacheName;\n            this.topVer = topVer;\n            this.keys = keys;\n            this.near = near;\n        }\n        /** {@inheritDoc} */\n        @Nullable @Override public Map<? extends ComputeJob, ClusterNode> map(List<ClusterNode> subgrid,\n            @Nullable Object arg) throws IgniteException {\n            Map<ComputeJob, ClusterNode> jobs = new HashMap<>();\n            for (ClusterNode node : subgrid) {\n                ComputeJob job;\n                if (near) {\n                    job = keys == null ? new GlobalClearAllNearJob(cacheName, topVer) :\n                        new GlobalClearKeySetNearJob<>(cacheName, topVer, keys);\n                }\n                else {\n                    job = keys == null ? new GlobalClearAllJob(cacheName, topVer) :\n                        new GlobalClearKeySetJob<>(cacheName, topVer, keys);\n                }\n                jobs.put(job, node);\n            }\n            return jobs;\n        }\n        /** {@inheritDoc} */\n        @Override public ComputeJobResultPolicy result(ComputeJobResult res, List<ComputeJobResult> rcvd) {\n            IgniteException e = res.getException();\n            if (e != null) {\n                if (e instanceof ClusterTopologyException)\n                    return ComputeJobResultPolicy.WAIT;\n                throw new IgniteException(\"Remote job threw exception.\", e);\n            }\n            return ComputeJobResultPolicy.WAIT;\n        }\n        /** {@inheritDoc} */\n        @Nullable @Override public Object reduce(List<ComputeJobResult> results) throws IgniteException {\n            return null;\n        }\n    }\n    /**\n     * Partition preload job.\n     */\n    @GridInternal\n    private static class PartitionPreloadJob implements IgniteRunnable {\n        /** */\n        private static final long serialVersionUID = 0L;\n        /** */\n        @IgniteInstanceResource\n        private IgniteEx ignite;\n        /** */\n        @LoggerResource\n        private IgniteLogger log;\n        /** */\n        private final String name;\n        /** Cache name. */\n        private final int part;\n        /**\n         * @param name Name.\n         * @param part Partition.\n         */\n        public PartitionPreloadJob(String name, int part) {\n            this.name = name;\n            this.part = part;\n        }\n        /** {@inheritDoc} */\n        @Override public void run() {\n            IgniteInternalCache cache = ignite.context().cache().cache(name);\n            try {\n                cache.context().offheap().preloadPartition(part);\n            }\n            catch (IgniteCheckedException e) {\n                log.error(\"Failed to preload the partition [cache=\" + name + \", partition=\" + part + ']', e);\n                throw new IgniteException(e);\n            }\n        }\n    }\n    /**\n     * Iterator implementation for KeySet.\n     */\n    private final class KeySetIterator implements Iterator<K> {\n        /** Internal map entry iterator. */\n        private final Iterator<GridCacheMapEntry> internalIterator;\n        /** Keep binary flag. */\n        private final boolean keepBinary;\n        /** Current entry. */\n        private GridCacheMapEntry current;\n        /**\n         * Constructor.\n         *\n         * @param internalIterator Internal iterator.\n         * @param keepBinary Keep binary flag.\n         */\n        private KeySetIterator(Iterator<GridCacheMapEntry> internalIterator, boolean keepBinary) {\n            this.internalIterator = internalIterator;\n            this.keepBinary = keepBinary;\n        }\n        /** {@inheritDoc} */\n        @Override public boolean hasNext() {\n            return internalIterator.hasNext();\n        }\n        /** {@inheritDoc} */\n        @Override public K next() {\n            current = internalIterator.next();\n            return (K)ctx.unwrapBinaryIfNeeded(current.key(), keepBinary, true);\n        }\n        /** {@inheritDoc} */\n        @Override public void remove() {\n            if (current == null)\n                throw new IllegalStateException();\n            try {\n                getAndRemove((K)current.key());\n            }\n            catch (IgniteCheckedException e) {\n                throw new IgniteException(e);\n            }\n            current = null;\n        }\n    }\n    /**\n     * A wrapper over internal map that provides set semantics and constant-time contains() check.\n     */\n    private final class KeySet extends AbstractSet<K> {\n        /** Internal entry set. */\n        private final Set<GridCacheMapEntry> internalSet;\n        /** Keep binary flag. */\n        private final boolean keepBinary;\n        /**\n         * Constructor\n         *\n         * @param internalSet Internal set.\n         */\n        private KeySet(Set<GridCacheMapEntry> internalSet) {\n            this.internalSet = internalSet;\n            CacheOperationContext opCtx = ctx.operationContextPerCall();\n            keepBinary = opCtx != null && opCtx.isKeepBinary();\n        }\n        /** {@inheritDoc} */\n        @Override public Iterator<K> iterator() {\n            return new KeySetIterator(internalSet.iterator(), keepBinary);\n        }\n        /** {@inheritDoc} */\n        @Override public int size() {\n            return F.size(iterator());\n        }\n        /** {@inheritDoc} */\n        @Override public boolean contains(Object o) {\n            GridCacheMapEntry entry = map.getEntry(ctx, ctx.toCacheKeyObject(o));\n            return entry != null && internalSet.contains(entry);\n        }\n    }\n    /**\n     * Iterator implementation for EntrySet.\n     */\n<fim_suffix>    private final class EntryIterator implements Iterator<Cache.Entry<K, V>> {\n        /** Internal iterator. */\n        private final Iterator<GridCacheMapEntry> internalIterator;\n        /** Current entry. */\n        private GridCacheMapEntry current;\n        /** Keep binary flag. */\n        private final boolean keepBinary;\n        /**\n         * Constructor.\n         *\n         * @param internalIterator Internal iterator.\n         * @param keepBinary Keep binary.\n         */\n        private EntryIterator(Iterator<GridCacheMapEntry> internalIterator, boolean keepBinary) {\n            this.internalIterator = internalIterator;\n            this.keepBinary = keepBinary;\n        }\n        /** {@inheritDoc} */\n        @Override public boolean hasNext() {\n            return internalIterator.hasNext();\n        }\n        /** {@inheritDoc} */\n        @Override public Cache.Entry<K, V> next() {\n            current = internalIterator.next();\n            return current.wrapLazyValue(keepBinary);\n        }\n        /** {@inheritDoc} */\n        @Override public void remove() {\n            if (current == null)\n                throw new IllegalStateException();\n            try {\n                getAndRemove((K)current.wrapLazyValue(keepBinary).getKey());\n            }\n            catch (IgniteCheckedException e) {\n                throw new IgniteException(e);\n            }\n            current = null;\n        }\n    }<fim_middle>// class below has no smell\n"}