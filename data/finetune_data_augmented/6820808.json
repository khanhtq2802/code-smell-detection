{"text": "<fim_prefix>  }\n  private Statement visitChildrenInNewScope(BlockNode node) {\n    Scope prev = currentScope;\n    currentScope = variables.enterScope();\n    List<Statement> children = visitChildren(node);\n    Statement leave = currentScope.exitScope();\n    children.add(leave);\n    currentScope = prev;\n    return Statement.concat(children);\n  }\n  @Override\n  protected Statement visitIfNode(IfNode node) {\n    List<IfBlock> ifs = new ArrayList<>();\n    Optional<Statement> elseBlock = Optional.absent();\n    for (SoyNode child : node.getChildren()) {\n      if (child instanceof IfCondNode) {\n        IfCondNode icn = (IfCondNode) child;\n        SoyExpression cond = exprCompiler.compile(icn.getExpr()).coerceToBoolean();\n        Statement block = visitChildrenInNewScope(icn);\n        ifs.add(IfBlock.create(cond, block));\n      } else {\n        IfElseNode ien = (IfElseNode) child;\n        elseBlock = Optional.of(visitChildrenInNewScope(ien));\n      }\n    }\n    return ControlFlow.ifElseChain(ifs, elseBlock);\n  }\n  @Override\n  protected Statement visitSwitchNode(SwitchNode node) {\n    // A few special cases:\n    // 1. only a {default} block.  In this case we can skip all the switch logic and temporaries\n    // 2. no children.  Just return the empty statement\n    // Note that in both of these cases we do not evalutate (or generate code) for the switch\n    // expression.\n    List<BlockNode> children = node.getChildren();\n    if (children.isEmpty()) {\n      return Statement.NULL_STATEMENT;\n    }\n    if (children.size() == 1 && children.get(0) instanceof SwitchDefaultNode) {\n      return visitChildrenInNewScope(children.get(0));\n    }\n    // otherwise we need to evaluate the switch variable and generate dispatching logic.\n    SoyExpression switchVar = exprCompiler.compile(node.getExpr());\n    Scope scope = variables.enterScope();\n    Variable variable = scope.createSynthetic(SyntheticVarName.forSwitch(node), switchVar, STORE);\n    Statement initializer = variable.initializer();\n    switchVar = switchVar.withSource(variable.local());\n    List<IfBlock> cases = new ArrayList<>();\n    Optional<Statement> defaultBlock = Optional.absent();\n    for (SoyNode child : children) {\n      if (child instanceof SwitchCaseNode) {\n        SwitchCaseNode caseNode = (SwitchCaseNode) child;\n        Label reattachPoint = new Label();\n        List<Expression> comparisons = new ArrayList<>();\n        for (ExprRootNode caseExpr : caseNode.getExprList()) {\n          comparisons.add(\n              compareSoyEquals(switchVar, exprCompiler.compile(caseExpr, reattachPoint)));\n        }\n        Expression condition = BytecodeUtils.logicalOr(comparisons).labelStart(reattachPoint);\n        Statement block = visitChildrenInNewScope(caseNode);\n        cases.add(IfBlock.create(condition, block));\n      } else {\n        SwitchDefaultNode defaultNode = (SwitchDefaultNode) child;\n        defaultBlock = Optional.of(visitChildrenInNewScope(defaultNode));\n      }\n    }\n    Statement exitScope = scope.exitScope();\n    // Soy allows arbitrary expressions to appear in {case} statements within a {switch}.\n    // Java/C, by contrast, only allow some constant expressions in cases.\n    // TODO(lukes): in practice the case statements are often constant strings/ints.  If everything\n    // is typed to int/string we should consider implementing via the tableswitch/lookupswitch\n    // instruction which would be way way way faster.  cglib has some helpers for string switch\n    // generation that we could maybe use\n    return Statement.concat(initializer, ControlFlow.ifElseChain(cases, defaultBlock), exitScope);\n  }\n  @Override\n  protected Statement visitForNode(ForNode node) {\n    ForNonemptyNode nonEmptyNode = (ForNonemptyNode) node.getChild(0);\n    Optional<RangeArgs> exprAsRangeArgs = RangeArgs.createFromNode(node);\n    Scope scope = variables.enterScope();\n    final Variable indexVar;\n    final List<Statement> initializers = new ArrayList<>();\n    final Variable sizeVar;\n    final Variable itemVar;\n    if (exprAsRangeArgs.isPresent()) {\n      final CompiledForeachRangeArgs compiledArgs = calculateRangeArgs(node, scope);\n      initializers.addAll(compiledArgs.initStatements());\n      // The size is just the number of items in the range.  The logic is a little tricky so we\n      // implement it in a runtime function: JbcsrcRuntime.rangeLoopLength\n      sizeVar =\n          scope.createSynthetic(\n              SyntheticVarName.foreachLoopLength(nonEmptyNode),\n              MethodRef.RUNTIME_RANGE_LOOP_LENGTH.invoke(\n                  compiledArgs.start(), compiledArgs.end(), compiledArgs.step()),\n              DERIVED);\n      indexVar =\n          scope.createSynthetic(\n              SyntheticVarName.foreachLoopIndex(nonEmptyNode), constant(0), STORE);\n      itemVar =\n          scope.create(\n              nonEmptyNode.getVarName(),\n              new Expression(Type.LONG_TYPE, Feature.CHEAP) {\n                @Override\n                protected void doGen(CodeBuilder adapter) {\n                  // executes ((long) start + index * step)\n                  compiledArgs.start().gen(adapter);\n                  compiledArgs.step().gen(adapter);\n                  indexVar.local().gen(adapter);\n                  adapter.visitInsn(Opcodes.IMUL);\n                  adapter.visitInsn(Opcodes.IADD);\n                  adapter.cast(Type.INT_TYPE, Type.LONG_TYPE);\n                }\n              },\n              DERIVED);\n    } else {\n      SoyExpression expr = exprCompiler.compile(node.getExpr()).unboxAsList();\n      Variable listVar =\n          scope.createSynthetic(SyntheticVarName.foreachLoopList(nonEmptyNode), expr, STORE);\n      initializers.add(listVar.initializer());\n      sizeVar =\n          scope.createSynthetic(\n              SyntheticVarName.foreachLoopLength(nonEmptyNode),\n              MethodRef.LIST_SIZE.invoke(listVar.local()),\n              DERIVED);\n      indexVar =\n          scope.createSynthetic(\n              SyntheticVarName.foreachLoopIndex(nonEmptyNode), constant(0), STORE);\n      itemVar =\n          scope.create(\n              nonEmptyNode.getVarName(),\n              MethodRef.LIST_GET\n                  .invoke(listVar.local(), indexVar.local())\n                  .checkedCast(SOY_VALUE_PROVIDER_TYPE),\n              DERIVED);\n    }\n    initializers.add(sizeVar.initializer());\n    final Statement loopBody = visitChildrenInNewScope(nonEmptyNode);\n    final Statement exitScope = scope.exitScope();\n    // it important for this to be generated after exitScope is called (or before enterScope)\n    final Statement emptyBlock =\n        node.numChildren() == 2 ? visitChildrenInNewScope(node.getChild(1)) : null;\n    return new Statement() {\n      @Override\n      protected void doGen(CodeBuilder adapter) {\n        for (Statement initializer : initializers) {\n          initializer.gen(adapter);\n        }\n        sizeVar.local().gen(adapter);\n        Label emptyListLabel = new Label();\n        adapter.ifZCmp(Opcodes.IFEQ, emptyListLabel);\n        indexVar.initializer().gen(adapter);\n        Label loopStart = adapter.mark();\n        itemVar.initializer().gen(adapter);\n        loopBody.gen(adapter);\n        adapter.iinc(indexVar.local().index(), 1); // index++\n        indexVar.local().gen(adapter);\n        sizeVar.local().gen(adapter);\n        adapter.ifICmp(Opcodes.IFLT, loopStart); // if index < list.size(), goto loopstart\n        // exit the loop\n        exitScope.gen(adapter);\n        if (emptyBlock != null) {\n          Label skipIfEmptyBlock = new Label();\n          adapter.goTo(skipIfEmptyBlock);\n          adapter.mark(emptyListLabel);\n          emptyBlock.gen(adapter);\n          adapter.mark(skipIfEmptyBlock);\n        } else {\n          adapter.mark(emptyListLabel);\n        }\n      }\n    };\n  }\n<fim_suffix>  @AutoValue\n  abstract static class CompiledForeachRangeArgs {\n    /** Current loop index. */\n    abstract Expression start();\n    /** Where to end loop iteration, defaults to {@code 0}. */\n    abstract Expression end();\n    /** This statement will increment the index by the loop stride. */\n    abstract Expression step();\n    /** Statements that must have been run prior to using any of the above expressions. */\n    abstract ImmutableList<Statement> initStatements();\n  }<fim_middle>// class below has no smell\n"}