{"text": "<fim_prefix>\n<fim_suffix>public class FsShellWritingMessageHandler extends\n\t\tAbstractReplyProducingMessageHandler {\n\tprivate volatile FileExistsMode fileExistsMode = FileExistsMode.REPLACE;\n\tprivate static final Log log = LogFactory\n\t\t\t.getLog(FsShellWritingMessageHandler.class);\n\tprivate volatile FileNameGenerator fileNameGenerator = new DefaultFileNameGenerator();\n\tprivate final StandardEvaluationContext evaluationContext = new StandardEvaluationContext();\n\tprivate final Expression destinationDirectoryExpression;\n\tprivate volatile boolean autoCreateDirectory = true;\n\tprivate volatile boolean deleteSourceFiles;\n\tprivate volatile boolean expectReply = false;\n\tprivate Configuration configuration;\n\tprivate FsShell fsShell;\n\tprivate volatile boolean generateDestinationDirectory = true;\n\tprivate volatile String destinationDirectoryFormat = \"%1$tY/%1$tm/%1$td/%1$tH/%1$tM/%1$tS\";\n\t/**\n\t * Constructor which sets the {@link #destinationDirectoryExpression} using\n\t * a {@link LiteralExpression}.\n\t * \n\t * @param destinationDirectory\n\t *            Must not be null\n\t * @see #FsShellWritingMessageHandler(Expression)\n\t */\n\tpublic FsShellWritingMessageHandler(String destinationDirectory,\n\t\t\tConfiguration configuration) {\n\t\tAssert.notNull(destinationDirectory,\n\t\t\t\t\"Destination directory must not be null.\");\t\t\n\t\tthis.destinationDirectoryExpression = new LiteralExpression(\n\t\t\t\tdestinationDirectory);\n\t\tcreateFsShell(configuration);\n\t}\n\t/**\n\t * Constructor which sets the {@link #destinationDirectoryExpression}.\n\t * \n\t * @param destinationDirectoryExpression\n\t *            Must not be null\n\t * @see #FileWritingMessageHandler(String)\n\t */\n\tpublic FsShellWritingMessageHandler(\n\t\t\tExpression destinationDirectoryExpression) {\n\t\tAssert.notNull(destinationDirectoryExpression,\n\t\t\t\t\"Destination directory expression must not be null.\");\n\t\tthis.destinationDirectoryExpression = destinationDirectoryExpression;\n\t\tcreateFsShell(configuration);\n\t}\n\tprivate void createFsShell(Configuration configuration) {\n\t\tAssert.notNull(configuration, \"Hadoop Configuration must not be null.\");\n\t\tthis.configuration = configuration;\n\t\tfsShell = new FsShell(configuration);\n\t}\n\t/**\n\t * Provide the {@link FileNameGenerator} strategy to use when generating the\n\t * destination file's name.\n\t */\n\tpublic void setFileNameGenerator(FileNameGenerator fileNameGenerator) {\n\t\tAssert.notNull(fileNameGenerator, \"FileNameGenerator must not be null\");\n\t\tthis.fileNameGenerator = fileNameGenerator;\n\t}\n\t/**\n\t * Specify whether to delete source Files after writing to the destination\n\t * directory. The default is <em>false</em>. When set to <em>true</em>, it\n\t * will only have an effect if the inbound Message has a File payload or a\n\t * {@link FileHeaders#ORIGINAL_FILE} header value containing either a File\n\t * instance or a String representing the original file path.\n\t */\n\tpublic void setDeleteSourceFiles(boolean deleteSourceFiles) {\n\t\tthis.deleteSourceFiles = deleteSourceFiles;\n\t}\n\t/**\n\t * Will set the {@link FileExistsMode} that specifies what will happen in\n\t * case the destination exists. For example {@link FileExistsMode#APPEND}\n\t * instructs this handler to append data to the existing file rather then\n\t * creating a new file for each {@link Message}.\n\t * \n\t * If set to {@link FileExistsMode#APPEND}, the adapter will also create a\n\t * real instance of the {@link LockRegistry} to ensure that there is no\n\t * collisions when multiple threads are writing to the same file.\n\t * \n\t * Otherwise the LockRegistry is set to {@link PassThruLockRegistry} which\n\t * has no effect.\n\t * \n\t * @param fileExistsMode\n\t *            Must not be null\n\t */\n\tpublic void setFileExistsMode(FileExistsMode fileExistsMode) {\n\t\tAssert.notNull(fileExistsMode, \"'fileExistsMode' must not be null.\");\n\t\tthis.fileExistsMode = fileExistsMode;\n\t}\n\t/**\n\t * Specify whether a reply Message is expected. If not, this handler will\n\t * simply return null for a successful response or throw an Exception for a\n\t * non-successful response. The default is true.\n\t */\n\tpublic void setExpectReply(boolean expectReply) {\n\t\tthis.expectReply = expectReply;\n\t}\n\tpublic void setGenerateDestinationDirectory(boolean generateDestinationDirectory) {\n\t\tthis.generateDestinationDirectory = generateDestinationDirectory;\n\t}\n\tpublic void setDestinationDirectoryFormat(String destinationDirectoryFormat) {\n\t\tthis.destinationDirectoryFormat = destinationDirectoryFormat;\n\t}\n\t@Override\n\tpublic final void onInit() {\n\t\tAssert.notNull(configuration, \"Hadoop configuration must not be null\");\n\t\tfsShell = new FsShell(configuration);\n\t\tthis.evaluationContext.addPropertyAccessor(new MapAccessor());\n\t\tfinal BeanFactory beanFactory = this.getBeanFactory();\n\t\tif (beanFactory != null) {\n\t\t\tthis.evaluationContext.setBeanResolver(new BeanFactoryResolver(\n\t\t\t\t\tbeanFactory));\n\t\t}\n\t\tif (this.destinationDirectoryExpression instanceof LiteralExpression) {\n\t\t\tfinal Path directory = new Path(\n\t\t\t\t\tthis.destinationDirectoryExpression.getValue(\n\t\t\t\t\t\t\tthis.evaluationContext, null, String.class));\n\t\t\tvalidateDestinationDirectory(directory, this.autoCreateDirectory);\n\t\t}\n\t}\n\tprivate void validateDestinationDirectory(Path destinationDirectory,\n\t\t\tboolean autoCreateDirectory) {\n\t\t// TODO\n\t}\n\t@Override\n\tprotected Object handleRequestMessage(Message<?> requestMessage) {\n\t\tAssert.notNull(requestMessage, \"message must not be null\");\n\t\tObject payload = requestMessage.getPayload();\n\t\tAssert.notNull(payload, \"message payload must not be null\");\n\t\tString generatedFileName = this.fileNameGenerator\n\t\t\t\t.generateFileName(requestMessage);\n\t\tFile originalFileFromHeader = this\n\t\t\t\t.retrieveOriginalFileFromHeader(requestMessage);\n\t\tfinal Path destinationDirectoryToUse = evaluateDestinationDirectoryExpression(requestMessage);\n\t\tPath resultFile = new Path(destinationDirectoryToUse, generatedFileName);\n\t\tboolean resultFileExists = fsShell.test(resultFile.toUri().toString());\n\t\tif (FileExistsMode.FAIL.equals(this.fileExistsMode) && resultFileExists) {\n\t\t\tthrow new MessageHandlingException(requestMessage,\n\t\t\t\t\t\"The destination file already exists at '\"\n\t\t\t\t\t\t\t+ resultFile.toString() + \"'.\");\n\t\t}\n\t\tfinal boolean ignore = FileExistsMode.IGNORE\n\t\t\t\t.equals(this.fileExistsMode) && resultFileExists;\n\t\tif (!ignore) {\n\t\t\ttry {\n\t\t\t\tif (payload instanceof File) {\n\t\t\t\t\tresultFile = this.handleFileMessage((File) payload,\n\t\t\t\t\t\t\tresultFile, resultFileExists);\n\t\t\t\t} else {\n\t\t\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\t\t\"unsupported Message payload type [\"\n\t\t\t\t\t\t\t\t\t+ payload.getClass().getName() + \"]\");\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\tthrow new MessageHandlingException(requestMessage,\n\t\t\t\t\t\t\"failed to write Message payload to file\", e);\n\t\t\t}\n\t\t}\n\t\tif (!this.expectReply) {\n\t\t\treturn null;\n\t\t}\n\t\tif (resultFile != null) {\n\t\t\tif (originalFileFromHeader == null && payload instanceof File) {\n\t\t\t\treturn MessageBuilder.withPayload(resultFile).setHeader(\n\t\t\t\t\t\tFileHeaders.ORIGINAL_FILE, payload);\n\t\t\t}\n\t\t}\n\t\treturn resultFile;\n\t}\n\t/**\n\t * Retrieves the File instance from the {@link FileHeaders#ORIGINAL_FILE}\n\t * header if available. If the value is not a File instance or a String\n\t * representation of a file path, this will return <code>null</code>.\n\t */\n\tprivate File retrieveOriginalFileFromHeader(Message<?> message) {\n\t\tObject value = message.getHeaders().get(FileHeaders.ORIGINAL_FILE);\n\t\tif (value instanceof File) {\n\t\t\treturn (File) value;\n\t\t}\n\t\tif (value instanceof String) {\n\t\t\treturn new File((String) value);\n\t\t}\n\t\treturn null;\n\t}\n\tprivate Path handleFileMessage(final File sourceFile, Path resultFile,\n\t\t\tboolean resultFileExists) {\n\t\tif (FileExistsMode.REPLACE.equals(this.fileExistsMode)\n\t\t\t\t&& resultFileExists) {\n\t\t\tfsShell.rm(resultFile.toString());\n\t\t}\n\t\tlog.info(\"sourceFile = \" + sourceFile.getAbsolutePath());\n\t\tlog.info(\"resultFile = \" + resultFile.toString());\n\t\tfsShell.copyFromLocal(sourceFile.getAbsolutePath(),\n\t\t\t\tresultFile.toString());\n\t\tcleanUpAfterCopy(sourceFile);\n\t\treturn resultFile;\n\t}\n\tprivate void cleanUpAfterCopy(File originalFile) {\n\t\tif (this.deleteSourceFiles && originalFile != null) {\n\t\t\toriginalFile.delete();\n\t\t}\n\t}\n\tprivate Path evaluateDestinationDirectoryExpression(Message<?> message) {\n\t\tfinal Path destinationDirectory;\n\t\tfinal Object destinationDirectoryToUse = this.destinationDirectoryExpression\n\t\t\t\t.getValue(this.evaluationContext, message);\n\t\tif (destinationDirectoryToUse == null) {<fim_middle>// class below is blob\n"}