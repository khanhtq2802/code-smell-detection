{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.crypto.key;\n\nimport java.io.IOException;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.List;\n\n/**\n * This is a utility class used to extend the functionality of KeyProvider, that\n * takes a KeyProvider and an Extension. It implements all the required methods\n * of the KeyProvider by delegating it to the provided KeyProvider.\n */\n<fim_suffix>public abstract class KeyProviderExtension\n<E extends KeyProviderExtension.Extension> extends KeyProvider {\n\n  /**\n   * A marker interface for the KeyProviderExtension subclass implement.\n   */\n  public static interface Extension {\n  }\n\n  private KeyProvider keyProvider;\n  private E extension;\n\n  public KeyProviderExtension(KeyProvider keyProvider, E extensions) {\n    super(keyProvider.getConf());\n    this.keyProvider = keyProvider;\n    this.extension = extensions;\n  }\n  \n  protected E getExtension() {\n    return extension;\n  }\n  \n  protected KeyProvider getKeyProvider() {\n    return keyProvider;\n  }\n\n  @Override\n  public boolean isTransient() {\n    return keyProvider.isTransient();\n  }\n\n  @Override\n  public Metadata[] getKeysMetadata(String... names) throws IOException {\n    return keyProvider.getKeysMetadata(names);\n  }\n\n  @Override\n  public KeyVersion getCurrentKey(String name) throws IOException {\n    return keyProvider.getCurrentKey(name);\n  }\n\n  @Override\n  public KeyVersion createKey(String name, Options options)\n      throws NoSuchAlgorithmException, IOException {\n    return keyProvider.createKey(name, options);\n  }\n\n  @Override\n  public KeyVersion rollNewVersion(String name)\n      throws NoSuchAlgorithmException, IOException {\n    return keyProvider.rollNewVersion(name);\n  }\n\n  @Override\n  public KeyVersion getKeyVersion(String versionName) throws IOException {\n    return keyProvider.getKeyVersion(versionName);\n  }\n\n  @Override\n  public List<String> getKeys() throws IOException {\n    return keyProvider.getKeys();\n  }\n\n  @Override\n  public List<KeyVersion> getKeyVersions(String name) throws IOException {\n    return keyProvider.getKeyVersions(name);\n  }\n\n  @Override\n  public Metadata getMetadata(String name) throws IOException {\n    return keyProvider.getMetadata(name);\n  }\n\n  @Override\n  public KeyVersion createKey(String name, byte[] material, Options options)\n      throws IOException {\n    return keyProvider.createKey(name, material, options);\n  }\n\n  @Override\n  public void deleteKey(String name) throws IOException {\n    keyProvider.deleteKey(name);\n  }\n\n  @Override\n  public KeyVersion rollNewVersion(String name, byte[] material)\n      throws IOException {\n    return keyProvider.rollNewVersion(name, material);\n  }\n\n  @Override\n  public void invalidateCache(String name) throws IOException {\n    keyProvider.invalidateCache(name);\n  }\n\n  @Override\n  public void flush() throws IOException {\n    keyProvider.flush();\n  }\n\n  @Override\n  public String toString() {\n    return getClass().getSimpleName() + \": \" + keyProvider.toString();\n  }\n}<fim_middle>// class below has no smell\n"}