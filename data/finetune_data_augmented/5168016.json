{"text": "<fim_prefix> *\n * @author Benjamin Bentmann\n */\npublic class LegacyLocalRepositoryManager\n    implements LocalRepositoryManager\n{\n    private final ArtifactRepository delegate;\n    private final LocalRepository repo;\n    private final boolean realLocalRepo;\n    public static RepositorySystemSession overlay( ArtifactRepository repository, RepositorySystemSession session,\n                                                   RepositorySystem system )\n    {\n        if ( repository == null || repository.getBasedir() == null )\n        {\n            return session;\n        }\n        if ( session != null )\n        {\n            LocalRepositoryManager lrm = session.getLocalRepositoryManager();\n            if ( lrm != null && lrm.getRepository().getBasedir().equals( new File( repository.getBasedir() ) ) )\n            {\n                return session;\n            }\n        }\n        else\n        {\n            session = new DefaultRepositorySystemSession();\n        }\n        final LocalRepositoryManager llrm = new LegacyLocalRepositoryManager( repository );\n        return new DefaultRepositorySystemSession( session ).setLocalRepositoryManager( llrm );\n    }\n    private LegacyLocalRepositoryManager( ArtifactRepository delegate )\n    {\n        this.delegate = Objects.requireNonNull( delegate, \"delegate cannot be null\" );\n        ArtifactRepositoryLayout layout = delegate.getLayout();\n        repo =\n            new LocalRepository( new File( delegate.getBasedir() ),\n                                 ( layout != null ) ? layout.getClass().getSimpleName() : \"legacy\" );\n        /*\n         * NOTE: \"invoker:install\" vs \"appassembler:assemble\": Both mojos use the artifact installer to put an artifact\n         * into a repository. In the first case, the result needs to be a proper local repository that one can use for\n         * local artifact resolution. In the second case, the result needs to precisely obey the path information of the\n         * repository's layout to allow pointing at artifacts within the repository. Unfortunately,\n         * DefaultRepositoryLayout does not correctly describe the layout of a local repository which unlike a remote\n         * repository never uses timestamps in the filename of a snapshot artifact. The discrepancy gets notable when a\n         * remotely resolved snapshot artifact gets passed into pathOf(). So producing a proper local artifact path\n         * using DefaultRepositoryLayout requires us to enforce usage of the artifact's base version. This\n         * transformation however contradicts the other use case of precisely obeying the repository's layout. The below\n         * flag tries to detect which use case applies to make both plugins happy.\n         */\n        realLocalRepo = ( layout instanceof DefaultRepositoryLayout ) && \"local\".equals( delegate.getId() );\n    }\n    public LocalRepository getRepository()\n    {\n        return repo;\n    }\n    public String getPathForLocalArtifact( Artifact artifact )\n    {\n        if ( realLocalRepo )\n        {\n            return delegate.pathOf( RepositoryUtils.toArtifact( artifact.setVersion( artifact.getBaseVersion() ) ) );\n        }\n        return delegate.pathOf( RepositoryUtils.toArtifact( artifact ) );\n    }\n    public String getPathForRemoteArtifact( Artifact artifact, RemoteRepository repository, String context )\n    {\n        return delegate.pathOf( RepositoryUtils.toArtifact( artifact ) );\n    }\n    public String getPathForLocalMetadata( Metadata metadata )\n    {\n        return delegate.pathOfLocalRepositoryMetadata( new ArtifactMetadataAdapter( metadata ), delegate );\n    }\n    public String getPathForRemoteMetadata( Metadata metadata, RemoteRepository repository, String context )\n    {\n        return delegate.pathOfLocalRepositoryMetadata( new ArtifactMetadataAdapter( metadata ),\n                                                       new ArtifactRepositoryAdapter( repository ) );\n    }\n    public LocalArtifactResult find( RepositorySystemSession session, LocalArtifactRequest request )\n    {\n        String path = getPathForLocalArtifact( request.getArtifact() );\n        File file = new File( getRepository().getBasedir(), path );\n        LocalArtifactResult result = new LocalArtifactResult( request );\n        if ( file.isFile() )\n        {\n            result.setFile( file );\n            result.setAvailable( true );\n        }\n        return result;\n    }\n    public LocalMetadataResult find( RepositorySystemSession session, LocalMetadataRequest request )\n    {\n        Metadata metadata = request.getMetadata();\n        String path;\n        if ( request.getRepository() == null )\n        {\n            path = getPathForLocalMetadata( metadata );\n        }\n        else\n        {\n            path = getPathForRemoteMetadata( metadata, request.getRepository(), request.getContext() );\n        }\n        File file = new File( getRepository().getBasedir(), path );\n        LocalMetadataResult result = new LocalMetadataResult( request );\n        if ( file.isFile() )\n        {\n            result.setFile( file );\n        }\n        return result;\n    }\n    public void add( RepositorySystemSession session, LocalArtifactRegistration request )\n    {\n        // noop\n    }\n    public void add( RepositorySystemSession session, LocalMetadataRegistration request )\n    {\n        // noop\n    }\n    static class ArtifactMetadataAdapter\n        implements ArtifactMetadata\n    {\n        private final Metadata metadata;\n        ArtifactMetadataAdapter( Metadata metadata )\n        {\n            this.metadata = metadata;\n        }\n        public boolean storedInArtifactVersionDirectory()\n        {\n            return metadata.getVersion().length() > 0;\n        }\n        public boolean storedInGroupDirectory()\n        {\n            return metadata.getArtifactId().length() <= 0;\n        }\n        public String getGroupId()\n        {\n            return nullify( metadata.getGroupId() );\n        }\n        public String getArtifactId()\n        {\n            return nullify( metadata.getArtifactId() );\n        }\n        public String getBaseVersion()\n        {\n            return nullify( metadata.getVersion() );\n        }\n        private String nullify( String str )\n        {\n            return ( str == null || str.length() <= 0 ) ? null : str;\n        }\n        public Object getKey()\n        {\n            return metadata.toString();\n        }\n        public String getRemoteFilename()\n        {\n            return metadata.getType();\n        }\n        public String getLocalFilename( ArtifactRepository repository )\n        {\n            return insertRepositoryKey( getRemoteFilename(), repository.getKey() );\n        }\n        private String insertRepositoryKey( String filename, String repositoryKey )\n        {\n            String result;\n            int idx = filename.indexOf( '.' );\n            if ( idx < 0 )\n            {\n                result = filename + '-' + repositoryKey;\n            }\n            else\n            {\n                result = filename.substring( 0, idx ) + '-' + repositoryKey + filename.substring( idx );\n            }\n            return result;\n        }\n        public void merge( org.apache.maven.repository.legacy.metadata.ArtifactMetadata metadata )\n        {\n            // not used\n        }\n        public void merge( ArtifactMetadata metadata )\n        {\n            // not used\n        }\n        public void storeInLocalRepository( ArtifactRepository localRepository, ArtifactRepository remoteRepository )\n            throws RepositoryMetadataStoreException\n        {\n            // not used\n        }\n        public String extendedToString()\n        {\n            return metadata.toString();\n        }\n    }\n<fim_suffix>    static class ArtifactRepositoryAdapter\n        implements ArtifactRepository\n    {\n        private final RemoteRepository repository;\n        ArtifactRepositoryAdapter( RemoteRepository repository )\n        {\n            this.repository = repository;\n        }\n        public String pathOf( org.apache.maven.artifact.Artifact artifact )\n        {\n            return null;\n        }\n        public String pathOfRemoteRepositoryMetadata( ArtifactMetadata artifactMetadata )\n        {\n            return null;\n        }\n        public String pathOfLocalRepositoryMetadata( ArtifactMetadata metadata, ArtifactRepository repository )\n        {\n            return null;\n        }\n        public String getUrl()\n        {\n            return repository.getUrl();\n        }\n        public void setUrl( String url )\n        {\n        }\n        public String getBasedir()\n        {\n            return null;\n        }\n        public String getProtocol()\n        {\n            return repository.getProtocol();\n        }\n        public String getId()\n        {\n            return repository.getId();\n        }\n        public void setId( String id )\n        {\n        }\n        public ArtifactRepositoryPolicy getSnapshots()\n        {\n            return null;\n        }\n        public void setSnapshotUpdatePolicy( ArtifactRepositoryPolicy policy )\n        {\n        }\n        public ArtifactRepositoryPolicy getReleases()\n        {\n            return null;\n        }\n        public void setReleaseUpdatePolicy( ArtifactRepositoryPolicy policy )\n        {\n        }\n        public ArtifactRepositoryLayout getLayout()\n        {\n            return null;\n        }\n        public void setLayout( ArtifactRepositoryLayout layout )\n        {\n        }\n        public String getKey()\n        {\n            return getId();\n        }\n        public boolean isUniqueVersion()\n        {\n            return true;\n        }\n        public boolean isBlacklisted()\n        {\n            return false;\n        }\n        public void setBlacklisted( boolean blackListed )\n        {\n        }\n        public org.apache.maven.artifact.Artifact find( org.apache.maven.artifact.Artifact artifact )\n        {\n            return null;\n        }\n        public List<String> findVersions( org.apache.maven.artifact.Artifact artifact )\n        {\n            return Collections.emptyList();\n        }\n        public boolean isProjectAware()\n        {\n            return false;\n        }\n        public void setAuthentication( Authentication authentication )\n        {\n        }\n        public Authentication getAuthentication()\n        {\n            return null;\n        }\n        public void setProxy( Proxy proxy )\n        {\n        }\n        public Proxy getProxy()\n        {\n            return null;\n        }\n        public List<ArtifactRepository> getMirroredRepositories()\n        {\n            return Collections.emptyList();\n        }\n        public void setMirroredRepositories( List<ArtifactRepository> mirroredRepositories )\n        {\n        }\n    }<fim_middle>// class below has no smell\n"}