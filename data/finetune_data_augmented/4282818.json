{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.crunch.impl.mr.run;\n\nimport java.io.IOException;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.crunch.io.CrunchInputs;\nimport org.apache.crunch.io.FormatBundle;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.fs.Path;\nimport org.apache.hadoop.mapreduce.InputFormat;\nimport org.apache.hadoop.mapreduce.InputSplit;\nimport org.apache.hadoop.mapreduce.Job;\nimport org.apache.hadoop.mapreduce.JobContext;\nimport org.apache.hadoop.mapreduce.RecordReader;\nimport org.apache.hadoop.mapreduce.TaskAttemptContext;\nimport org.apache.hadoop.mapreduce.lib.input.FileInputFormat;\nimport org.apache.hadoop.util.ReflectionUtils;\n\nimport com.google.common.collect.Lists;\n\n<fim_suffix>public class CrunchInputFormat<K, V> extends InputFormat<K, V> {\n\n  @Override\n  public List<InputSplit> getSplits(JobContext job) throws IOException, InterruptedException {\n    List<InputSplit> splits = Lists.newArrayList();\n    Configuration base = job.getConfiguration();\n    Map<FormatBundle, Map<Integer, List<Path>>> formatNodeMap = CrunchInputs.getFormatNodeMap(job);\n\n    // First, build a map of InputFormats to Paths\n    for (Map.Entry<FormatBundle, Map<Integer, List<Path>>> entry : formatNodeMap.entrySet()) {\n      FormatBundle inputBundle = entry.getKey();\n      Configuration conf = new Configuration(base);\n      inputBundle.configure(conf);\n      Job jobCopy = new Job(conf);\n      InputFormat<?, ?> format = (InputFormat<?, ?>) ReflectionUtils.newInstance(inputBundle.getFormatClass(),\n          jobCopy.getConfiguration());\n      if (format instanceof FileInputFormat && !conf.getBoolean(RuntimeParameters.DISABLE_COMBINE_FILE, true)) {\n        format = new CrunchCombineFileInputFormat<Object, Object>(jobCopy);\n      }\n      for (Map.Entry<Integer, List<Path>> nodeEntry : entry.getValue().entrySet()) {\n        Integer nodeIndex = nodeEntry.getKey();\n        List<Path> paths = nodeEntry.getValue();\n        FileInputFormat.setInputPaths(jobCopy, paths.toArray(new Path[paths.size()]));\n\n        // Get splits for each input path and tag with InputFormat\n        // and Mapper types by wrapping in a TaggedInputSplit.\n        List<InputSplit> pathSplits = format.getSplits(jobCopy);\n        for (InputSplit pathSplit : pathSplits) {\n          splits.add(new CrunchInputSplit(pathSplit, inputBundle, nodeIndex, jobCopy.getConfiguration()));\n        }\n      }\n    }\n    return splits;\n  }\n\n  @Override\n  public RecordReader<K, V> createRecordReader(InputSplit inputSplit, TaskAttemptContext context) throws IOException,\n      InterruptedException {\n    return new CrunchRecordReader<K, V>(inputSplit, context);\n  }\n}<fim_middle>// class below has no smell\n"}