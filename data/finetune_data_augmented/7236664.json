{"text": "<fim_prefix>package org.robolectric.internal.bytecode;\n\nimport com.google.common.collect.ImmutableMap;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport org.robolectric.annotation.Implements;\nimport org.robolectric.internal.ShadowProvider;\nimport org.robolectric.shadow.api.ShadowPicker;\n\n/**\n * Maps from instrumented class to shadow class.\n *\n * We deal with class names rather than actual classes here, since a ShadowMap is built outside of\n * any sandboxes, but instrumented and shadowed classes must be loaded through a\n * {@link SandboxClassLoader}. We don't want to try to resolve those classes outside of a sandbox.\n *\n * Once constructed, instances are immutable.\n */\n@SuppressWarnings(\"NewApi\")\npublic class ShadowMap {\n\n  static final ShadowMap EMPTY = new ShadowMap(ImmutableMap.of(), ImmutableMap.of());\n\n  private final ImmutableMap<String, String> defaultShadows;\n  private final ImmutableMap<String, ShadowInfo> overriddenShadows;\n  private final ImmutableMap<String, String> shadowPickers;\n\n  @SuppressWarnings(\"AndroidJdkLibsChecker\")\n  public static ShadowMap createFromShadowProviders(List<ShadowProvider> sortedProviders) {\n    final Map<String, String> shadowMap = new HashMap<>();\n    final Map<String, String> shadowPickerMap = new HashMap<>();\n\n    for (ShadowProvider provider : sortedProviders) {\n       shadowMap.putAll(provider.getShadowMap());\n       shadowPickerMap.putAll(provider.getShadowPickerMap());\n    }\n    return new ShadowMap(ImmutableMap.copyOf(shadowMap), Collections.emptyMap(),\n        ImmutableMap.copyOf(shadowPickerMap));\n  }\n\n  ShadowMap(\n      ImmutableMap<String, String> defaultShadows,\n      Map<String, ShadowInfo> overriddenShadows) {\n    this(defaultShadows, overriddenShadows, Collections.emptyMap());\n  }\n\n  private ShadowMap(ImmutableMap<String, String> defaultShadows,\n      Map<String, ShadowInfo> overriddenShadows,\n      Map<String, String> shadowPickers) {\n    this.defaultShadows = defaultShadows;\n    this.overriddenShadows = ImmutableMap.copyOf(overriddenShadows);\n    this.shadowPickers = ImmutableMap.copyOf(shadowPickers);\n  }\n\n  public ShadowInfo getShadowInfo(Class<?> clazz, int apiLevel) {\n    String instrumentedClassName = clazz.getName();\n\n    ShadowInfo shadowInfo = overriddenShadows.get(instrumentedClassName);\n    if (shadowInfo == null) {\n      shadowInfo = checkShadowPickers(instrumentedClassName, clazz);\n    }\n\n    if (shadowInfo == null && clazz.getClassLoader() != null) {\n      try {\n        final String shadowName = defaultShadows.get(clazz.getCanonicalName());\n        if (shadowName != null) {\n          Class<?> shadowClass = clazz.getClassLoader().loadClass(shadowName);\n          shadowInfo = obtainShadowInfo(shadowClass);\n          if (!shadowInfo.shadowedClassName.equals(instrumentedClassName)) {\n            // somehow we got the wrong shadow class?\n            shadowInfo = null;\n          }\n        }\n      } catch (ClassNotFoundException | IncompatibleClassChangeError e) {\n        return null;\n      }\n    }\n\n    if (shadowInfo != null && !shadowInfo.supportsSdk(apiLevel)) {\n      return null;\n    }\n\n    return shadowInfo;\n  }\n\n  // todo: some caching would probably be nice here...\n<fim_suffix>  private ShadowInfo checkShadowPickers(String instrumentedClassName, Class<?> clazz) {\n    String shadowPickerClassName = shadowPickers.get(instrumentedClassName);\n    if (shadowPickerClassName == null) {\n      return null;\n    }\n\n    ClassLoader classLoader = clazz.getClassLoader();\n    try {\n      Class<? extends ShadowPicker<?>> shadowPickerClass =\n          (Class<? extends ShadowPicker<?>>) classLoader.loadClass(shadowPickerClassName);\n      ShadowPicker<?> shadowPicker = shadowPickerClass.getDeclaredConstructor().newInstance();\n      Class<?> selectedShadowClass = shadowPicker.pickShadowClass();\n      if (selectedShadowClass == null) {\n        return obtainShadowInfo(Object.class, true);\n      }\n      ShadowInfo shadowInfo = obtainShadowInfo(selectedShadowClass);\n\n      if (!shadowInfo.shadowedClassName.equals(instrumentedClassName)) {\n        throw new IllegalArgumentException(\"Implemented class for \"\n            + selectedShadowClass.getName() + \" (\" + shadowInfo.shadowedClassName + \") != \"\n            + instrumentedClassName);\n      }\n\n      return shadowInfo;\n    } catch (ClassNotFoundException | NoSuchMethodException | InvocationTargetException\n        | IllegalAccessException | InstantiationException e) {\n      throw new RuntimeException(\"Failed to resolve shadow picker for \" + instrumentedClassName,\n          e);\n    }\n  }\n\n  public static ShadowInfo obtainShadowInfo(Class<?> clazz) {\n    return obtainShadowInfo(clazz, false);\n  }\n\n  static ShadowInfo obtainShadowInfo(Class<?> clazz, boolean mayBeNonShadow) {\n    Implements annotation = clazz.getAnnotation(Implements.class);\n    if (annotation == null) {\n      if (mayBeNonShadow) {\n        return null;\n      } else {\n        throw new IllegalArgumentException(clazz + \" is not annotated with @Implements\");\n      }\n    }\n\n    String className = annotation.className();\n    if (className.isEmpty()) {\n      className = annotation.value().getName();\n    }\n    return new ShadowInfo(className, clazz.getName(), annotation);\n  }\n\n  @SuppressWarnings(\"ReferenceEquality\")\n  public Set<String> getInvalidatedClasses(ShadowMap previous) {\n    if (this == previous && shadowPickers.isEmpty()) return Collections.emptySet();\n\n    Map<String, ShadowInfo> invalidated = new HashMap<>(overriddenShadows);\n\n    for (Map.Entry<String, ShadowInfo> entry : previous.overriddenShadows.entrySet()) {\n      String className = entry.getKey();\n      ShadowInfo previousConfig = entry.getValue();\n      ShadowInfo currentConfig = invalidated.get(className);\n      if (currentConfig == null) {\n        invalidated.put(className, previousConfig);\n      } else if (previousConfig.equals(currentConfig)) {\n        invalidated.remove(className);\n      }\n    }\n\n    return invalidated.keySet();\n  }\n\n  /**\n   * @deprecated do not use\n   */\n  @Deprecated\n  public static String convertToShadowName(String className) {\n    String shadowClassName =\n        \"org.robolectric.shadows.Shadow\" + className.substring(className.lastIndexOf(\".\") + 1);\n    shadowClassName = shadowClassName.replaceAll(\"\\\\$\", \"\\\\$Shadow\");\n    return shadowClassName;\n  }\n\n  public Builder newBuilder() {\n    return new Builder(this);\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (!(o instanceof ShadowMap)) return false;\n\n    ShadowMap shadowMap = (ShadowMap) o;\n\n    if (!overriddenShadows.equals(shadowMap.overriddenShadows)) return false;\n\n    return true;\n  }\n\n  @Override\n  public int hashCode() {\n    return overriddenShadows.hashCode();\n  }\n\n  public static class Builder {\n    private final ImmutableMap<String, String> defaultShadows;\n    private final Map<String, ShadowInfo> overriddenShadows;\n    private final Map<String, String> shadowPickers;\n\n    public Builder () {\n      defaultShadows = ImmutableMap.of();\n      overriddenShadows = new HashMap<>();\n      shadowPickers = new HashMap<>();\n    }\n\n    public Builder(ShadowMap shadowMap) {\n      this.defaultShadows = shadowMap.defaultShadows;\n      this.overriddenShadows = new HashMap<>(shadowMap.overriddenShadows);\n      this.shadowPickers = new HashMap<>(shadowMap.shadowPickers);\n    }\n\n    public Builder addShadowClasses(Class<?>... shadowClasses) {\n      for (Class<?> shadowClass : shadowClasses) {\n        addShadowClass(shadowClass);\n      }\n      return this;\n    }\n\n    Builder addShadowClass(Class<?> shadowClass) {\n      addShadowInfo(obtainShadowInfo(shadowClass));\n      return this;\n    }\n\n    Builder addShadowClass(\n        String realClassName,\n        String shadowClassName,\n        boolean callThroughByDefault,\n        boolean looseSignatures) {\n      addShadowInfo(\n          new ShadowInfo(\n              realClassName, shadowClassName, callThroughByDefault, looseSignatures, -1, -1, null));\n      return this;\n    }\n\n    private void addShadowInfo(ShadowInfo shadowInfo) {\n      overriddenShadows.put(shadowInfo.shadowedClassName, shadowInfo);\n      if (shadowInfo.hasShadowPicker()) {\n        shadowPickers\n            .put(shadowInfo.shadowedClassName, shadowInfo.getShadowPickerClass().getName());\n      }\n    }\n\n    public ShadowMap build() {\n      return new ShadowMap(defaultShadows, overriddenShadows, shadowPickers);\n    }\n  }\n}<fim_middle>// function below has no smell\n"}