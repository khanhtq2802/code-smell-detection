{"text": "<fim_prefix>/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n */\npackage org.codehaus.groovy.classgen;\nimport org.codehaus.groovy.GroovyBugError;\nimport org.codehaus.groovy.ast.ASTNode;\nimport org.codehaus.groovy.ast.AnnotatedNode;\nimport org.codehaus.groovy.ast.AnnotationNode;\nimport org.codehaus.groovy.ast.ClassCodeVisitorSupport;\nimport org.codehaus.groovy.ast.ClassHelper;\nimport org.codehaus.groovy.ast.ClassNode;\nimport org.codehaus.groovy.ast.DynamicVariable;\nimport org.codehaus.groovy.ast.FieldNode;\nimport org.codehaus.groovy.ast.InnerClassNode;\nimport org.codehaus.groovy.ast.MethodNode;\nimport org.codehaus.groovy.ast.Parameter;\nimport org.codehaus.groovy.ast.PropertyNode;\nimport org.codehaus.groovy.ast.Variable;\nimport org.codehaus.groovy.ast.VariableScope;\nimport org.codehaus.groovy.ast.expr.BinaryExpression;\nimport org.codehaus.groovy.ast.expr.ClosureExpression;\nimport org.codehaus.groovy.ast.expr.ConstantExpression;\nimport org.codehaus.groovy.ast.expr.ConstructorCallExpression;\nimport org.codehaus.groovy.ast.expr.DeclarationExpression;\nimport org.codehaus.groovy.ast.expr.Expression;\nimport org.codehaus.groovy.ast.expr.FieldExpression;\nimport org.codehaus.groovy.ast.expr.MethodCallExpression;\nimport org.codehaus.groovy.ast.expr.PropertyExpression;\nimport org.codehaus.groovy.ast.expr.TupleExpression;\nimport org.codehaus.groovy.ast.expr.VariableExpression;\nimport org.codehaus.groovy.ast.stmt.BlockStatement;\nimport org.codehaus.groovy.ast.stmt.CatchStatement;\nimport org.codehaus.groovy.ast.stmt.ForStatement;\nimport org.codehaus.groovy.ast.stmt.IfStatement;\nimport org.codehaus.groovy.ast.stmt.Statement;\nimport org.codehaus.groovy.control.SourceUnit;\nimport org.codehaus.groovy.syntax.Types;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport static java.lang.reflect.Modifier.isFinal;\nimport static org.apache.groovy.ast.tools.MethodNodeUtils.getPropertyName;\n/**\n * goes through an AST and initializes the scopes\n */\npublic class VariableScopeVisitor extends ClassCodeVisitorSupport {\n    private VariableScope currentScope = null;\n    private final VariableScope headScope = new VariableScope();\n    private ClassNode currentClass = null;\n    private final SourceUnit source;\n    private boolean isSpecialConstructorCall = false;\n    private boolean inConstructor = false;\n    private final boolean recurseInnerClasses;\n    private final LinkedList stateStack = new LinkedList();\n<fim_suffix>    private class StateStackElement {\n        final VariableScope scope;\n        final ClassNode clazz;\n        final boolean inConstructor;\n        StateStackElement() {\n            scope = VariableScopeVisitor.this.currentScope;\n            clazz = VariableScopeVisitor.this.currentClass;\n            inConstructor = VariableScopeVisitor.this.inConstructor;\n        }\n    }\n    public VariableScopeVisitor(SourceUnit source, boolean recurseInnerClasses) {\n        this.source = source;\n        currentScope = headScope;\n        this.recurseInnerClasses = recurseInnerClasses;\n    }\n    public VariableScopeVisitor(SourceUnit source) {\n        this(source, false);\n    }\n    // ------------------------------\n    // helper methods\n    //------------------------------\n    private void pushState(boolean isStatic) {\n        stateStack.add(new StateStackElement());\n        currentScope = new VariableScope(currentScope);\n        currentScope.setInStaticContext(isStatic);\n    }\n    private void pushState() {\n        pushState(currentScope.isInStaticContext());\n    }\n    private void popState() {\n        StateStackElement element = (StateStackElement) stateStack.removeLast();\n        currentScope = element.scope;\n        currentClass = element.clazz;\n        inConstructor = element.inConstructor;\n    }\n    private void declare(Parameter[] parameters, ASTNode node) {\n        for (Parameter parameter : parameters) {\n            if (parameter.hasInitialExpression()) {\n                parameter.getInitialExpression().visit(this);\n            }\n            declare(parameter, node);\n        }\n    }\n    private void declare(VariableExpression vex) {\n        vex.setInStaticContext(currentScope.isInStaticContext());\n        declare(vex, vex);\n        vex.setAccessedVariable(vex);\n    }\n    private void declare(Variable var, ASTNode expr) {\n        String scopeType = \"scope\";\n        String variableType = \"variable\";\n        if (expr.getClass() == FieldNode.class) {\n            scopeType = \"class\";\n            variableType = \"field\";\n        } else if (expr.getClass() == PropertyNode.class) {\n            scopeType = \"class\";\n            variableType = \"property\";\n        }\n        StringBuilder msg = new StringBuilder();\n        msg.append(\"The current \").append(scopeType);\n        msg.append(\" already contains a \").append(variableType);\n        msg.append(\" of the name \").append(var.getName());\n        if (currentScope.getDeclaredVariable(var.getName()) != null) {\n            addError(msg.toString(), expr);\n            return;\n        }\n        for (VariableScope scope = currentScope.getParent(); scope != null; scope = scope.getParent()) {\n            // if we are in a class and no variable is declared until\n            // now, then we can break the loop, because we are allowed\n            // to declare a variable of the same name as a class member\n            if (scope.getClassScope() != null) break;\n            if (scope.getDeclaredVariable(var.getName()) != null) {\n                // variable already declared\n                addError(msg.toString(), expr);\n                break;\n            }\n        }\n        // declare the variable even if there was an error to allow more checks\n        currentScope.putDeclaredVariable(var);\n    }\n    protected SourceUnit getSourceUnit() {\n        return source;\n    }\n    private Variable findClassMember(ClassNode cn, String name) {\n        if (cn == null) return null;\n        if (cn.isScript()) {\n            return new DynamicVariable(name, false);\n        }\n        for (FieldNode fn : cn.getFields()) {\n            if (fn.getName().equals(name)) return fn;\n        }\n        for (MethodNode mn : cn.getMethods()) {\n            String pName = getPropertyName(mn);\n            if (name.equals(pName)) {\n                PropertyNode property = new PropertyNode(name, mn.getModifiers(), ClassHelper.OBJECT_TYPE, cn, null, null, null);\n                property.getField().setHasNoRealSourcePosition(true);\n                property.getField().setSynthetic(true);\n                property.getField().setDeclaringClass(cn);\n                property.setDeclaringClass(cn);\n                return property;\n            }\n        }\n        for (PropertyNode pn : cn.getProperties()) {\n            if (pn.getName().equals(name)) return pn;\n        }\n        Variable ret = findClassMember(cn.getSuperClass(), name);\n        if (ret != null) return ret;\n        return findClassMember(cn.getOuterClass(), name);\n    }\n    // -------------------------------\n    // different Variable based checks\n    // -------------------------------\n    private Variable checkVariableNameForDeclaration(String name, Expression expression) {\n        if (\"super\".equals(name) || \"this\".equals(name)) return null;\n        VariableScope scope = currentScope;\n        Variable var = new DynamicVariable(name, currentScope.isInStaticContext());\n        Variable orig = var;\n        // try to find a declaration of a variable\n        boolean crossingStaticContext = false;\n        while (true) {\n            crossingStaticContext = crossingStaticContext || scope.isInStaticContext();\n            Variable var1;\n            var1 = scope.getDeclaredVariable(var.getName());\n            if (var1 != null) {\n                var = var1;\n                break;\n            }\n            var1 = scope.getReferencedLocalVariable(var.getName());\n            if (var1 != null) {\n                var = var1;\n                break;\n            }\n            var1 = scope.getReferencedClassVariable(var.getName());\n            if (var1 != null) {\n                var = var1;\n                break;\n            }<fim_middle>// class below has no smell\n"}