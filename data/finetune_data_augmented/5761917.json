{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n * \n *   http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.sysml.runtime.compress.cocode;\n\nimport java.util.Arrays;\n\nimport org.apache.sysml.runtime.compress.cocode.PlanningCoCoder.GroupableColInfo;\nimport org.apache.sysml.runtime.compress.estim.CompressedSizeEstimator;\nimport org.apache.sysml.runtime.compress.estim.CompressedSizeInfo;\n\n/** \n * Class to represent information about co-coding a group of columns. \n * \n */\npublic class PlanningCoCodingGroup \n{\n\tprivate int[] _colIndexes;\n\tprivate PlanningCoCodingGroup _leftGrp;\n\tprivate PlanningCoCodingGroup _rightGrp;\n\t\n\tprivate long _estSize;\n\tprivate double _cardRatio;\n\t\n\t\n\t/**\n\t * Constructor for a one-column group; i.e. do not co-code a given column.\n\t * \n\t * @param col column\n\t * @param info groupable column info\n\t */\n\tpublic PlanningCoCodingGroup(int col, GroupableColInfo info) {\n\t\t_colIndexes = new int[]{col};\n\t\t_estSize = info.size;\n\t\t_cardRatio = info.cardRatio;\n\t}\n\n\t/**\n\t * Constructor for merging two disjoint groups of columns\n\t * \n\t * @param grp1   first column group to merge\n\t * @param grp2   second column group to merge\n\t * @param estim  bitmap size estimator\n\t * @param numRows number of rows\n\t */\n\tpublic PlanningCoCodingGroup(PlanningCoCodingGroup grp1, PlanningCoCodingGroup grp2,\n\t\t\tCompressedSizeEstimator estim, int numRows) \n\t{\n\t\t_colIndexes = getMergedIndexes(grp1._colIndexes, grp2._colIndexes);\n\t\t\n\t\t// estimating size info\n\t\tCompressedSizeInfo groupSizeInfo = estim\n\t\t\t\t.estimateCompressedColGroupSize(_colIndexes);\n\t\t_estSize = groupSizeInfo.getMinSize();\n\t\t_cardRatio = groupSizeInfo.getEstCard() / numRows;\n\t\t\n\t\t_leftGrp = grp1;\n\t\t_rightGrp = grp2;\n\t}\n\n\tpublic int[] getColIndices() {\n\t\treturn _colIndexes;\n\t}\n\n\t/**\n\t * Obtain estimated compressed size of the grouped columns.\n\t * \n\t * @return estimated compressed size of the grouped columns\n\t */\n\tpublic long getEstSize() {\n\t\treturn _estSize;\n\t}\n\t\n\tpublic double getChangeInSize() {\n\t\tif( _leftGrp == null || _rightGrp == null )\n\t\t\treturn 0;\n\t\t\n\t\treturn getEstSize() \n\t\t\t- _leftGrp.getEstSize() \n\t\t\t- _rightGrp.getEstSize();\n\t}\n\n\tpublic double getCardinalityRatio() {\n\t\treturn _cardRatio;\n\t}\n\t\n\tpublic PlanningCoCodingGroup getLeftGroup() {\n\t\treturn _leftGrp;\n\t}\n\t\n\tpublic PlanningCoCodingGroup getRightGroup() {\n\t\treturn _rightGrp;\n\t}\n\t\n\t@Override \n\tpublic int hashCode() {\n\t\treturn Arrays.hashCode(_colIndexes);\n\t}\n\t\n<fim_suffix>\t@Override \n\tpublic boolean equals(Object that) {\n\t\tif( !(that instanceof PlanningCoCodingGroup) )\n\t\t\treturn false;\n\t\t\n\t\tPlanningCoCodingGroup thatgrp = (PlanningCoCodingGroup) that;\n\t\treturn Arrays.equals(_colIndexes, thatgrp._colIndexes);\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn Arrays.toString(_colIndexes);\n\t}\n\t\n\tpublic static int[] getMergedIndexes(int[] indexes1, int[] indexes2) {\n\t\t// merge sorted non-empty arrays\n\t\tint[] ret = new int[indexes1.length + indexes2.length];\t\t\n\t\tint grp1Ptr = 0, grp2Ptr = 0;\n\t\tfor (int mergedIx = 0; mergedIx < ret.length; mergedIx++) {\n\t\t\tif (indexes1[grp1Ptr] < indexes2[grp2Ptr]) {\n\t\t\t\tret[mergedIx] = indexes1[grp1Ptr++];\n\t\t\t\tif (grp1Ptr == indexes1.length) {\n\t\t\t\t\tSystem.arraycopy(indexes2, grp2Ptr, ret, mergedIx + 1, indexes2.length - grp2Ptr);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} \n\t\t\telse {\n\t\t\t\tret[mergedIx] = indexes2[grp2Ptr++];\n\t\t\t\tif (grp2Ptr == indexes2.length) {\n\t\t\t\t\tSystem.arraycopy(indexes1, grp1Ptr, ret, mergedIx + 1, indexes1.length - grp1Ptr);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\t\n\tpublic static class ColIndexes {\n\t\tfinal int[] _colIndexes;\n\t\t\n\t\tpublic ColIndexes(int[] colIndexes) {\n\t\t\t_colIndexes = colIndexes;\n\t\t}\n\t\n\t\t@Override \n\t\tpublic int hashCode() {\n\t\t\treturn Arrays.hashCode(_colIndexes);\n\t\t}\n\t\t\n\t\t@Override \n\t\tpublic boolean equals(Object that) {\n\t\t\tif( !(that instanceof ColIndexes) )\n\t\t\t\treturn false;\n\t\t\t\n\t\t\tColIndexes thatgrp = (ColIndexes) that;\n\t\t\treturn Arrays.equals(_colIndexes, thatgrp._colIndexes);\n\t\t}\n\t}\n}<fim_middle>// function below has no smell\n"}