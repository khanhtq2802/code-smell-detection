{"text": "<fim_prefix>/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n */\npackage org.apache.qpid.server.protocol.v1_0;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.apache.qpid.server.model.NamedAddressSpace;\nimport org.apache.qpid.server.plugin.QpidServiceLoader;\nimport org.apache.qpid.server.protocol.v1_0.store.LinkStore;\nimport org.apache.qpid.server.protocol.v1_0.store.LinkStoreFactory;\nimport org.apache.qpid.server.protocol.v1_0.store.LinkStoreUpdaterImpl;\nimport org.apache.qpid.server.protocol.v1_0.type.BaseSource;\nimport org.apache.qpid.server.protocol.v1_0.type.BaseTarget;\nimport org.apache.qpid.server.protocol.v1_0.type.messaging.Source;\nimport org.apache.qpid.server.protocol.v1_0.type.messaging.Target;\nimport org.apache.qpid.server.protocol.v1_0.type.messaging.TerminusDurability;\nimport org.apache.qpid.server.protocol.v1_0.type.transport.Role;\nimport org.apache.qpid.server.util.ServerScopedRuntimeException;\npublic class LinkRegistryImpl<S extends BaseSource, T extends BaseTarget> implements LinkRegistry<S, T>\n{\n    private static final Logger LOGGER = LoggerFactory.getLogger(LinkRegistryImpl.class);\n    private final ConcurrentMap<LinkKey, Link_1_0<S, T>> _sendingLinkRegistry = new ConcurrentHashMap<>();\n    private final ConcurrentMap<LinkKey, Link_1_0<S, T>> _receivingLinkRegistry = new ConcurrentHashMap<>();\n    private final LinkStore _linkStore;\n    LinkRegistryImpl(final NamedAddressSpace addressSpace)\n    {\n        LinkStoreFactory storeFactory = null;\n        Iterable<LinkStoreFactory> linkStoreFactories = new QpidServiceLoader().instancesOf(LinkStoreFactory.class);\n        for (LinkStoreFactory linkStoreFactory : linkStoreFactories)\n        {\n            if (linkStoreFactory.supports(addressSpace)\n                && (storeFactory == null || storeFactory.getPriority() < linkStoreFactory.getPriority()))\n            {\n                storeFactory = linkStoreFactory;\n            }\n        }\n        if (storeFactory == null)\n        {\n            throw new ServerScopedRuntimeException(\"Cannot find suitable link store\");\n        }\n        _linkStore = storeFactory.create(addressSpace);\n    }\n    @Override\n    public Link_1_0<S, T> getSendingLink(final String remoteContainerId, final String linkName)\n    {\n        return getLinkFromRegistry(remoteContainerId, linkName, _sendingLinkRegistry, Role.SENDER);\n    }\n    @Override\n    public Link_1_0<S, T> getReceivingLink(final String remoteContainerId, final String linkName)\n    {\n        return getLinkFromRegistry(remoteContainerId, linkName, _receivingLinkRegistry, Role.RECEIVER);\n    }\n    @Override\n    public void linkClosed(final Link_1_0<S, T> link)\n    {\n        ConcurrentMap<LinkKey, Link_1_0<S, T>> linkRegistry = getLinkRegistry(link.getRole());\n        linkRegistry.remove(new LinkKey(link));\n        if (isDurableLink(link))\n        {\n            _linkStore.deleteLink((Link_1_0<Source, Target>) link);\n        }\n    }\n    @Override\n    public void linkChanged(final Link_1_0<S,T> link)\n    {\n        getLinkRegistry(link.getRole()).putIfAbsent(new LinkKey(link), link);\n        if (isDurableLink(link))\n        {\n            _linkStore.saveLink((Link_1_0<Source, Target>) link);\n        }\n    }\n    @Override\n    public TerminusDurability getHighestSupportedTerminusDurability()\n    {\n        TerminusDurability supportedTerminusDurability = _linkStore.getHighestSupportedTerminusDurability();\n        return supportedTerminusDurability == TerminusDurability.UNSETTLED_STATE ? TerminusDurability.CONFIGURATION : supportedTerminusDurability;\n    }\n    @Override\n    public Collection<Link_1_0<S,T>> findSendingLinks(final Pattern containerIdPattern,\n                                                                                             final Pattern linkNamePattern)\n    {\n        return _sendingLinkRegistry.entrySet()\n                                   .stream()\n                                   .filter(e -> containerIdPattern.matcher(e.getKey().getRemoteContainerId()).matches()\n                                                && linkNamePattern.matcher(e.getKey().getLinkName()).matches())\n                                   .map(Map.Entry::getValue)\n                                   .collect(Collectors.toList());\n    }\n    @Override\n    public void visitSendingLinks(final LinkVisitor<Link_1_0<S,T>> visitor)\n    {\n        visitLinks(_sendingLinkRegistry.values(), visitor);\n    }\n    private void visitLinks(final Collection<Link_1_0<S, T>> links,\n                            final LinkVisitor<Link_1_0<S, T>> visitor)\n    {\n        for (Link_1_0<S, T> link : links)\n        {\n            if (visitor.visit(link))\n            {\n                break;\n            }\n        }\n    }\n    @Override\n    public void purgeSendingLinks(final Pattern containerIdPattern, final Pattern linkNamePattern)\n    {\n        purgeLinks(_sendingLinkRegistry, containerIdPattern, linkNamePattern);\n    }\n    @Override\n    public void purgeReceivingLinks(final Pattern containerIdPattern, final Pattern linkNamePattern)\n    {\n        purgeLinks(_receivingLinkRegistry, containerIdPattern, linkNamePattern);\n    }\n<fim_suffix>    @Override\n    public void open()\n    {\n        Collection<LinkDefinition<Source, Target>> links = _linkStore.openAndLoad(new LinkStoreUpdaterImpl());\n        for(LinkDefinition<Source, Target> link: links)\n        {\n            ConcurrentMap<LinkKey, Link_1_0<S,T>> linkRegistry = getLinkRegistry(link.getRole());\n            LinkDefinition<S, T> definition = (LinkDefinition<S, T>) link;\n            linkRegistry.put(new LinkKey(link), new LinkImpl<>(definition, this));\n        }\n    }\n    @Override\n    public void close()\n    {\n        _linkStore.close();\n    }\n    @Override\n    public void delete()\n    {\n        _linkStore.delete();\n    }\n    private boolean isDurableLink(final Link_1_0<? extends BaseSource, ? extends BaseTarget> link)\n    {\n        return (link.getRole() == Role.SENDER && link.getSource() instanceof Source\n                && ((Source) link.getSource()).getDurable() != TerminusDurability.NONE)\n               || (link.getRole() == Role.RECEIVER && link.getTarget() instanceof Target\n                   && ((Target) link.getTarget()).getDurable() != TerminusDurability.NONE);\n    }\n    private Link_1_0<S, T> getLinkFromRegistry(final String remoteContainerId,\n                                               final String linkName,\n                                               final ConcurrentMap<LinkKey, Link_1_0<S, T>> linkRegistry,\n                                               final Role role)\n    {\n        LinkKey linkKey = new LinkKey(remoteContainerId, linkName, role);\n        Link_1_0<S, T> newLink = new LinkImpl<>(remoteContainerId, linkName, role, this);\n        Link_1_0<S, T> link = linkRegistry.putIfAbsent(linkKey, newLink);\n        if (link == null)\n        {\n            link = newLink;\n        }\n        return link;\n    }\n    private void purgeLinks(final ConcurrentMap<LinkKey, Link_1_0<S,T>> linkRegistry,\n                            final Pattern containerIdPattern, final Pattern linkNamePattern)\n    {\n        linkRegistry.entrySet()\n                    .stream()<fim_middle>// function below has no smell\n"}