{"text": "<fim_prefix>import com.datatorrent.stram.plan.logical.LogicalPlan.ModuleMeta;\nimport com.datatorrent.stram.plan.logical.LogicalPlan.OperatorMeta;\nimport com.datatorrent.stram.plan.logical.LogicalPlan.OutputPortMeta;\nimport com.datatorrent.stram.plan.logical.LogicalPlan.StreamMeta;\nimport com.datatorrent.stram.util.ObjectMapperFactory;\nimport static org.apache.apex.api.plugin.DAGSetupEvent.Type.POST_CONFIGURE_DAG;\nimport static org.apache.apex.api.plugin.DAGSetupEvent.Type.POST_POPULATE_DAG;\nimport static org.apache.apex.api.plugin.DAGSetupEvent.Type.POST_VALIDATE_DAG;\nimport static org.apache.apex.api.plugin.DAGSetupEvent.Type.PRE_CONFIGURE_DAG;\nimport static org.apache.apex.api.plugin.DAGSetupEvent.Type.PRE_POPULATE_DAG;\nimport static org.apache.apex.api.plugin.DAGSetupEvent.Type.PRE_VALIDATE_DAG;\n/**\n *\n * Builder for the DAG logical representation of operators and streams from properties.<p>\n * <br>\n * Supports reading as name-value pairs from Hadoop {@link Configuration} or opProps file.\n * <br>\n *\n * @since 0.3.2\n */\npublic class LogicalPlanConfiguration\n{\n  private static final Logger LOG = LoggerFactory.getLogger(LogicalPlanConfiguration.class);\n  public static final String GATEWAY_PREFIX = StreamingApplication.DT_PREFIX + \"gateway.\";\n  public static final String GATEWAY_LISTEN_ADDRESS = GATEWAY_PREFIX + \"listenAddress\";\n  public static final String STREAM_PREFIX = StreamingApplication.APEX_PREFIX + \"stream.\";\n  public static final String STREAM_SOURCE = \"source\";\n  public static final String STREAM_SINKS = \"sinks\";\n  public static final String STREAM_TEMPLATE = \"template\";\n  public static final String STREAM_LOCALITY = \"locality\";\n  public static final String STREAM_SCHEMA = \"schema\";\n  public static final String OPERATOR_PREFIX = StreamingApplication.APEX_PREFIX + \"operator.\";\n  public static final String OPERATOR_CLASSNAME = \"classname\";\n  public static final String OPERATOR_TEMPLATE = \"template\";\n  public static final String TEMPLATE_idRegExp = \"matchIdRegExp\";\n  public static final String TEMPLATE_appNameRegExp = \"matchAppNameRegExp\";\n  public static final String TEMPLATE_classNameRegExp = \"matchClassNameRegExp\";\n  public static final String CLASS = \"class\";\n  public static final String KEY_SEPARATOR = \".\";\n  public static final String KEY_SEPARATOR_SPLIT_REGEX = \"\\\\.\";\n  private static final String CLASS_SUFFIX = \".\" + CLASS;\n  private static final String WILDCARD = \"*\";\n  private static final String WILDCARD_PATTERN = \".*\";\n  /**\n   * This is done to initialize the serial id of these interfaces.\n   */\n  static {\n    Object[] serial = new Object[]{Context.DAGContext.serialVersionUID, OperatorContext.serialVersionUID, PortContext.serialVersionUID};\n    LOG.debug(\"Initialized attributes {}\", serial);\n  }\n  public static final String KEY_APPLICATION_NAME = keyAndDeprecation(Context.DAGContext.APPLICATION_NAME);\n  public static final String KEY_GATEWAY_CONNECT_ADDRESS = keyAndDeprecation(Context.DAGContext.GATEWAY_CONNECT_ADDRESS);\n  public static final String KEY_GATEWAY_USE_SSL = keyAndDeprecation(Context.DAGContext.GATEWAY_USE_SSL);\n  public static final String KEY_GATEWAY_USER_NAME = keyAndDeprecation(Context.DAGContext.GATEWAY_USER_NAME);\n  public static final String KEY_GATEWAY_PASSWORD = keyAndDeprecation(Context.DAGContext.GATEWAY_PASSWORD);\n  private static String keyAndDeprecation(Attribute<?> attr)\n  {\n    String key = StreamingApplication.APEX_PREFIX + attr.getName();\n    Configuration.addDeprecation(StreamingApplication.DT_PREFIX + attr.getName(), key);\n    return key;\n  }\n  private final DAGSetupPluginManager pluginManager;\n  /**\n   * This represents an element that can be referenced in a DT property.\n   */\n  protected enum StramElement\n  {\n    APPLICATION(\"application\"), GATEWAY(\"gateway\"), TEMPLATE(\"template\"), OPERATOR(\"operator\"), STREAM(\"stream\"),\n    PORT(\"port\"), INPUT_PORT(\"inputport\"), OUTPUT_PORT(\"outputport\"),\n    ATTR(\"attr\"), PROP(\"prop\"), CLASS(\"class\"), PATH(\"path\"), UNIFIER(\"unifier\");\n    private final String value;\n    /**\n     * Creates a {@link StramElement} with the corresponding name.\n     *\n     * @param value The name of the {@link StramElement}.\n     */\n    StramElement(String value)\n    {\n      this.value = value;\n    }\n    /**\n     * Gets the name of the {@link StramElement}.\n     *\n     * @return The name of the {@link StramElement}.\n     */\n    public String getValue()\n    {\n      return value;\n    }\n    /**\n     * Gets the {@link StramElement} corresponding to the given name.\n     *\n     * @param value The name for which a {@link StramElement} is desired.\n     * @return The {@link StramElement} corresponding to the given name.\n     */\n    public static StramElement fromValue(String value)\n    {\n      StramElement velement = null;\n      for (StramElement element : StramElement.values()) {\n        if (element.getValue().equals(value)) {\n          velement = element;\n          break;\n        }\n      }\n      return velement;\n    }\n  }\n  /**\n   * This is an enum which represents a type of configuration.\n   */\n  protected enum ConfElement\n  {\n    STRAM(null, null, null, null),\n    APPLICATION(StramElement.APPLICATION, STRAM, null, DAGContext.class),\n    TEMPLATE(StramElement.TEMPLATE, STRAM, null, null),\n    GATEWAY(StramElement.GATEWAY, ConfElement.APPLICATION, null, null),\n    OPERATOR(StramElement.OPERATOR, ConfElement.APPLICATION, null, OperatorContext.class),\n    STREAM(StramElement.STREAM, ConfElement.APPLICATION, null, null),\n    PORT(StramElement.PORT, ConfElement.OPERATOR, EnumSet.of(StramElement.INPUT_PORT, StramElement.OUTPUT_PORT), PortContext.class),\n    UNIFIER(StramElement.UNIFIER, ConfElement.PORT, null, null);\n    protected static final Map<StramElement, ConfElement> STRAM_ELEMENT_TO_CONF_ELEMENT = Maps.newHashMap();\n    protected static final Map<Class<? extends Context>, ConfElement> CONTEXT_TO_CONF_ELEMENT = Maps.newHashMap();\n    static {\n      initialize();\n    }\n<fim_suffix>    protected static void initialize()\n    {\n      STRAM.setChildren(Sets.newHashSet(APPLICATION, TEMPLATE));\n      APPLICATION.setChildren(Sets.newHashSet(GATEWAY, OPERATOR, STREAM));\n      OPERATOR.setChildren(Sets.newHashSet(PORT));\n      PORT.setChildren(Sets.newHashSet(UNIFIER));\n      STRAM_ELEMENT_TO_CONF_ELEMENT.clear();\n      //Initialize StramElement to ConfElement\n      for (ConfElement confElement: ConfElement.values()) {\n        STRAM_ELEMENT_TO_CONF_ELEMENT.put(confElement.getStramElement(), confElement);\n        for (StramElement sElement: confElement.getAllRelatedElements()) {\n          STRAM_ELEMENT_TO_CONF_ELEMENT.put(sElement, confElement);\n        }\n      }\n      //Initialize attributes\n      for (ConfElement confElement: ConfElement.values()) {\n        if (confElement.getParent() == null) {\n          continue;\n        }\n        setAmbiguousAttributes(confElement);\n      }\n      // build context to conf element map\n      CONTEXT_TO_CONF_ELEMENT.clear();\n      for (ConfElement confElement: ConfElement.values()) {\n        CONTEXT_TO_CONF_ELEMENT.put(confElement.getContextClass(), confElement);\n      }\n      //Check if all the context classes are accounted for\n      Set<Class<? extends Context>> confElementContextClasses = Sets.newHashSet();\n      for (ConfElement confElement: ConfElement.values()) {\n        if (confElement.getContextClass() == null) {\n          continue;\n        }\n        confElementContextClasses.add(confElement.getContextClass());\n      }\n      if (!ContextUtils.CONTEXT_CLASSES.equals(confElementContextClasses)) {\n        throw new IllegalStateException(\"All the context classes \" + ContextUtils.CONTEXT_CLASSES + \" found in \"\n                                        + Context.class + \" are not used by ConfElements \" + confElementContextClasses);\n      }\n    }<fim_middle>// function below is long method\n"}