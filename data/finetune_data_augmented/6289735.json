{"text": "<fim_prefix>//\n//  ========================================================================\n//  Copyright (c) 1995-2019 Mort Bay Consulting Pty. Ltd.\n//  ------------------------------------------------------------------------\n//  All rights reserved. This program and the accompanying materials\n//  are made available under the terms of the Eclipse Public License v1.0\n//  and Apache License v2.0 which accompanies this distribution.\n//\n//      The Eclipse Public License is available at\n//      http://www.eclipse.org/legal/epl-v10.html\n//\n//      The Apache License v2.0 is available at\n//      http://www.opensource.org/licenses/apache2.0.php\n//\n//  You may elect to redistribute this code under either of these licenses.\n//  ========================================================================\n//\npackage org.eclipse.jetty.util.thread;\nimport java.util.concurrent.ConcurrentLinkedDeque;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.RejectedExecutionException;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.locks.Condition;\nimport org.eclipse.jetty.util.ProcessorUtils;\nimport org.eclipse.jetty.util.annotation.ManagedAttribute;\nimport org.eclipse.jetty.util.annotation.ManagedObject;\nimport org.eclipse.jetty.util.component.AbstractLifeCycle;\nimport org.eclipse.jetty.util.log.Log;\nimport org.eclipse.jetty.util.log.Logger;\n/**\n * An Executor using preallocated/reserved Threads from a wrapped Executor.\n * <p>Calls to {@link #execute(Runnable)} on a {@link ReservedThreadExecutor} will either succeed\n * with a Thread immediately being assigned the Runnable task, or fail if no Thread is\n * available.\n * <p>Threads are reserved lazily, with a new reserved thread being allocated from a\n * wrapped {@link Executor} when an execution fails.  If the {@link #setIdleTimeout(long, TimeUnit)}\n * is set to non zero (default 1 minute), then the reserved thread pool will shrink by 1 thread\n * whenever it has been idle for that period.\n */\n@ManagedObject(\"A pool for reserved threads\")\npublic class ReservedThreadExecutor extends AbstractLifeCycle implements TryExecutor\n{\n    private static final Logger LOG = Log.getLogger(ReservedThreadExecutor.class);\n    private static final Runnable STOP = new Runnable()\n    {\n        @Override\n        public void run()\n        {\n        }\n        @Override\n        public String toString()\n        {\n            return \"STOP!\";\n        }\n    };\n    private final Executor _executor;\n    private final int _capacity;\n    private final ConcurrentLinkedDeque<ReservedThread> _stack;\n    private final AtomicInteger _size = new AtomicInteger();\n    private final AtomicInteger _pending = new AtomicInteger();\n    private ThreadPoolBudget.Lease _lease;\n    private long _idleTime = 1L;\n    private TimeUnit _idleTimeUnit = TimeUnit.MINUTES;\n    /**\n     * @param executor The executor to use to obtain threads\n     * @param capacity The number of threads to preallocate. If less than 0 then capacity\n     *                 is calculated based on a heuristic from the number of available processors and\n     *                 thread pool size.\n     */\n    public ReservedThreadExecutor(Executor executor,int capacity)\n    {\n        _executor = executor;\n        _capacity = reservedThreads(executor,capacity);\n        _stack = new ConcurrentLinkedDeque<>();\n        LOG.debug(\"{}\",this);\n    }\n    /**\n     * @param executor The executor to use to obtain threads\n     * @param capacity The number of threads to preallocate, If less than 0 then capacity\n     * is calculated based on a heuristic from the number of available processors and\n     * thread pool size.\n     * @return the number of reserved threads that would be used by a ReservedThreadExecutor\n     * constructed with these arguments.\n     */\n    private static int reservedThreads(Executor executor,int capacity)\n    {\n        if (capacity>=0)\n            return capacity;\n        int cpus = ProcessorUtils.availableProcessors();\n        if (executor instanceof ThreadPool.SizedThreadPool)\n        {\n            int threads = ((ThreadPool.SizedThreadPool)executor).getMaxThreads();\n            return Math.max(1, Math.min(cpus, threads / 10));\n        }\n        return cpus;\n    }\n    public Executor getExecutor()\n    {\n        return _executor;\n    }\n    @ManagedAttribute(value = \"max number of reserved threads\", readonly = true)\n    public int getCapacity()\n    {\n        return _capacity;\n    }\n    @ManagedAttribute(value = \"available reserved threads\", readonly = true)\n    public int getAvailable()\n    {\n        return _stack.size();\n    }\n    @ManagedAttribute(value = \"pending reserved threads\", readonly = true)\n    public int getPending()\n    {\n        return _pending.get();\n    }\n<fim_suffix>    @ManagedAttribute(value = \"idletimeout in MS\", readonly = true)\n    public long getIdleTimeoutMs()\n    {\n        if(_idleTimeUnit==null)\n            return 0;\n        return _idleTimeUnit.toMillis(_idleTime);\n    }\n    /**\n     * Set the idle timeout for shrinking the reserved thread pool\n     * @param idleTime Time to wait before shrinking, or 0 for no timeout.\n     * @param idleTimeUnit Time units for idle timeout\n     */\n    public void setIdleTimeout(long idleTime, TimeUnit idleTimeUnit)\n    {\n        if (isRunning())\n            throw new IllegalStateException();\n        _idleTime = idleTime;\n        _idleTimeUnit = idleTimeUnit;\n    }\n    @Override\n    public void doStart() throws Exception\n    {\n        _lease = ThreadPoolBudget.leaseFrom(getExecutor(),this,_capacity);\n        super.doStart();\n    }\n    @Override\n    public void doStop() throws Exception\n    {\n        if (_lease!=null)\n            _lease.close();\n        while(true)\n        {\n            ReservedThread thread = _stack.pollFirst();\n            if (thread == null)\n                break;\n            _size.decrementAndGet();\n            thread.stop();\n        }\n        super.doStop();\n    }\n    @Override\n    public void execute(Runnable task) throws RejectedExecutionException\n    {\n        _executor.execute(task);\n    }\n    /**\n     * @param task The task to run\n     * @return True iff a reserved thread was available and has been assigned the task to run.\n     */\n    @Override\n    public boolean tryExecute(Runnable task)\n    {\n        if (LOG.isDebugEnabled())\n            LOG.debug(\"{} tryExecute {}\",this ,task);\n        if (task==null)\n            return false;\n        ReservedThread thread = _stack.pollFirst();\n        if (thread==null)\n        {\n            if (task!=STOP)\n                startReservedThread();\n            return false;\n        }\n        int size = _size.decrementAndGet();\n        thread.offer(task);\n        if (size==0 && task!=STOP)\n            startReservedThread();\n        return true;\n    }\n    private void startReservedThread()\n    {\n        try\n        {\n            while (true)\n            {\n                // Not atomic, but there is a re-check in ReservedThread.run().\n                int pending = _pending.get();\n                int size = _size.get();\n                if (pending + size >= _capacity)\n                    return;\n                if (_pending.compareAndSet(pending, pending + 1))\n                {\n                    if (LOG.isDebugEnabled())\n                        LOG.debug(\"{} startReservedThread p={}\", this, pending + 1);\n                    _executor.execute(new ReservedThread());\n                    return;\n                }\n            }\n        }\n        catch(RejectedExecutionException e)\n        {\n            LOG.ignore(e);\n        }\n    }\n    @Override\n    public String toString()\n    {\n        return String.format(\"%s@%x{s=%d/%d,p=%d}\",\n                getClass().getSimpleName(),\n                hashCode(),\n                _size.get(),\n                _capacity,\n                _pending.get());\n    }\n    private class ReservedThread implements Runnable\n    {\n        private final Locker _locker = new Locker();\n        private final Condition _wakeup = _locker.newCondition();\n        private boolean _starting = true;\n        private Runnable _task = null;\n        public void offer(Runnable task)\n        {\n            if (LOG.isDebugEnabled())\n                LOG.debug(\"{} offer {}\", this, task);\n            try (Locker.Lock lock = _locker.lock())\n            {\n                _task = task;\n                _wakeup.signal();\n            }\n        }\n        public void stop()\n        {\n            offer(STOP);\n        }\n        private Runnable reservedWait()\n        {\n            if (LOG.isDebugEnabled())\n                LOG.debug(\"{} waiting\", this);\n            Runnable task = null;\n            while (task==null)\n            {\n                boolean idle = false;\n                try (Locker.Lock lock = _locker.lock())\n                {\n                    if (_task == null)\n                    {\n                        try\n                        {\n                            if (_idleTime == 0)\n                                _wakeup.await();\n                            else\n                                idle = !_wakeup.await(_idleTime, _idleTimeUnit);\n                        }\n                        catch (InterruptedException e)\n                        {\n                            LOG.ignore(e);\n                        }\n                    }\n                    task = _task;\n                    _task = null;\n                }\n                if (idle)\n                {\n                    // Because threads are held in a stack, excess threads will be\n                    // idle.  However, we cannot remove threads from the bottom of\n                    // the stack, so we submit a poison pill job to stop the thread<fim_middle>// function below has no smell\n"}