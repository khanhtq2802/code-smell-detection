{"text": "<fim_prefix>/*******************************************************************************\n * Copyright (c) 2013 itemis AG (http://www.itemis.eu) and others.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *******************************************************************************/\npackage org.eclipse.xtext.xbase.typesystem.internal;\n\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.eclipse.emf.ecore.EObject;\nimport org.eclipse.emf.ecore.InternalEObject;\nimport org.eclipse.emf.ecore.resource.Resource;\nimport org.eclipse.xtext.common.types.JvmAnnotationType;\nimport org.eclipse.xtext.common.types.JvmConstructor;\nimport org.eclipse.xtext.common.types.JvmEnumerationType;\nimport org.eclipse.xtext.common.types.JvmGenericType;\nimport org.eclipse.xtext.common.types.JvmIdentifiableElement;\nimport org.eclipse.xtext.common.types.JvmPrimitiveType;\nimport org.eclipse.xtext.common.types.JvmType;\nimport org.eclipse.xtext.common.types.JvmTypeParameter;\nimport org.eclipse.xtext.common.types.JvmTypeParameterDeclarator;\nimport org.eclipse.xtext.common.types.JvmTypeReference;\nimport org.eclipse.xtext.common.types.JvmVoid;\nimport org.eclipse.xtext.diagnostics.AbstractDiagnostic;\nimport org.eclipse.xtext.diagnostics.Severity;\nimport org.eclipse.xtext.linking.lazy.LazyLinkingResource;\nimport org.eclipse.xtext.util.IAcceptor;\nimport org.eclipse.xtext.validation.EObjectDiagnosticImpl;\nimport org.eclipse.xtext.xbase.XConstructorCall;\nimport org.eclipse.xtext.xbase.XExpression;\nimport org.eclipse.xtext.xbase.XbasePackage;\nimport org.eclipse.xtext.xbase.scoping.batch.IIdentifiableElementDescription;\nimport org.eclipse.xtext.xbase.typesystem.IResolvedTypes;\nimport org.eclipse.xtext.xbase.typesystem.computation.IConstructorLinkingCandidate;\nimport org.eclipse.xtext.xbase.typesystem.references.ITypeReferenceOwner;\nimport org.eclipse.xtext.xbase.typesystem.references.LightweightMergedBoundTypeArgument;\nimport org.eclipse.xtext.xbase.typesystem.references.LightweightTypeReference;\nimport org.eclipse.xtext.xbase.typesystem.references.ParameterizedTypeReference;\nimport org.eclipse.xtext.xbase.typesystem.util.TypeParameterByConstraintSubstitutor;\nimport org.eclipse.xtext.xbase.validation.IssueCodes;\n\nimport com.google.common.collect.Lists;\n\n/**\n * @author Sebastian Zarnekow - Initial contribution and API\n */\npublic class TypeInsteadOfConstructorLinkingCandidate extends AbstractUnresolvableReference implements IConstructorLinkingCandidate {\n\n\tprivate final IIdentifiableElementDescription description;\n\n\tpublic TypeInsteadOfConstructorLinkingCandidate(XConstructorCall constructorCall, IIdentifiableElementDescription description, ExpressionTypeComputationState state) {\n\t\tsuper(constructorCall, state);\n\t\tthis.description = description;\n\t}\n\n\t/* @Nullable */\n\t@Override\n\tpublic JvmConstructor getConstructor() {\n\t\treturn null;\n\t}\n\t\n\t@Override\n\tpublic boolean isAnonymousClassConstructorCall() {\n\t\treturn false;\n\t}\n\t\n\t@Override\n\tprotected void applyType() {\n\t\tJvmType type = (JvmType) getFeature();\n\t\tif (type == null || type.eIsProxy()) {\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\t\tITypeReferenceOwner referenceOwner = getResolvedTypes().getReferenceOwner();\n\t\tParameterizedTypeReference result = referenceOwner.newParameterizedTypeReference(type);\n\t\tfor(LightweightTypeReference typeArgument: getTypeArguments()) {\n\t\t\tresult.addTypeArgument(typeArgument);\n\t\t}\n\t\tgetState().acceptActualType(result);\n\t}\n\t\n\t@Override\n\tpublic XConstructorCall getConstructorCall() {\n\t\treturn (XConstructorCall) getExpression();\n\t}\n\n\t@Override\n\tprotected List<XExpression> getArguments() {\n\t\treturn getConstructorCall().getArguments();\n\t}\n\t\n<fim_suffix>\t@Override\n\t/* @Nullable */\n\tpublic JvmIdentifiableElement getFeature() {\n\t\treturn description.getElementOrProxy();\n\t}\n\t\n\t@Override\n\tpublic boolean validate(IAcceptor<? super AbstractDiagnostic> result) {\n\t\tJvmType type = (JvmType) description.getElementOrProxy();\n\t\tString typeKind = \"\";\n\t\tif (type instanceof JvmPrimitiveType || type instanceof JvmVoid) {\n\t\t\ttypeKind = \"primitive type\";\n\t\t} else if (type instanceof JvmAnnotationType) {\n\t\t\ttypeKind = \"annotation type\";\n\t\t} else if (type instanceof JvmEnumerationType) {\n\t\t\ttypeKind = \"enum type\";\n\t\t} else if (type instanceof JvmGenericType && ((JvmGenericType) type).isInterface()) {\n\t\t\ttypeKind = \"interface type\";\n\t\t} else if (type instanceof JvmTypeParameter) {\n\t\t\ttypeKind = \"type parameter\";\n\t\t}\n\t\tString message = String.format(\"Cannot instantiate the %s %s\", typeKind, type.getSimpleName());\n\t\tAbstractDiagnostic diagnostic = new EObjectDiagnosticImpl(Severity.ERROR,\n\t\t\t\tIssueCodes.ILLEGAL_CLASS_INSTANTIATION, message, getExpression(),\n\t\t\t\tXbasePackage.Literals.XCONSTRUCTOR_CALL__CONSTRUCTOR, -1, null);\n\t\tresult.accept(diagnostic);\n\t\treturn false;\n\t}\n\t\n\t@Override\n\tpublic List<LightweightTypeReference> getTypeArguments() {\n\t\tJvmType type = (JvmType) getFeature();\n\t\tif (type == null || type.eIsProxy()) {\n\t\t\tthrow new IllegalStateException();\n\t\t}\n\t\tITypeReferenceOwner referenceOwner = getResolvedTypes().getReferenceOwner();\n\t\tif (type instanceof JvmTypeParameterDeclarator) {\n\t\t\tList<JvmTypeParameter> typeParameters = ((JvmTypeParameterDeclarator) type).getTypeParameters();\n\t\t\tif (!typeParameters.isEmpty()) {\n\t\t\t\tList<LightweightTypeReference> result = Lists.newArrayList();\n\t\t\t\tList<LightweightTypeReference> typeArguments = getSyntacticTypeArguments();\n\t\t\t\tint max = Math.min(typeParameters.size(), typeArguments.size());\n\t\t\t\tfor(int i = 0; i < max; i++) {\n\t\t\t\t\tresult.add(typeArguments.get(i));\n\t\t\t\t}\n\t\t\t\tif (max < typeParameters.size()) {\n\t\t\t\t\tTypeParameterByConstraintSubstitutor substitutor = new TypeParameterByConstraintSubstitutor(\n\t\t\t\t\t\t\tCollections.<JvmTypeParameter, LightweightMergedBoundTypeArgument> emptyMap(), referenceOwner);\n\t\t\t\t\tfor(int i = max; i < typeParameters.size(); i++) {\n\t\t\t\t\t\tJvmTypeParameter typeParameter = typeParameters.get(i);\n\t\t\t\t\t\tresult.add(substitutor.substitute(typeParameter));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\treturn Collections.emptyList();\n\t}\n\t\n\tpublic List<LightweightTypeReference> getSyntacticTypeArguments() {\n\t\tXConstructorCall constructorCall = getConstructorCall();\n\t\tList<JvmTypeReference> typeArguments = constructorCall.getTypeArguments();\n\t\tif (typeArguments.isEmpty())\n\t\t\treturn Collections.emptyList();\n\t\tList<LightweightTypeReference> result = Lists.newArrayList();\n\t\tfor(JvmTypeReference typeArgument: typeArguments) {\n\t\t\tresult.add(getState().getReferenceOwner().toLightweightTypeReference(typeArgument));\n\t\t}\n\t\treturn result;\n\t}\n\t\n\t@Override\n\tpublic void applyToModel(IResolvedTypes resolvedTypes) {\n\t\tResource resource = getExpression().eResource();\n\t\tif (resource instanceof LazyLinkingResource) {\n\t\t\tLazyLinkingResource lazyLinkingResource = (LazyLinkingResource) resource;\n\t\t\tEObject referenced = (InternalEObject) getExpression().eGet(XbasePackage.Literals.XCONSTRUCTOR_CALL__CONSTRUCTOR, false);\n\t\t\tlazyLinkingResource.markUnresolvable(referenced);\n\t\t}\n\t}\n\t\n}<fim_middle>// function below has no smell\n"}