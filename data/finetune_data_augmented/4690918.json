{"text": "<fim_prefix>\n<fim_suffix>public class AsyncRcvdMsgCheckpointImpl<M extends Writable> implements\n    BSPFaultTolerantService<M> {\n  private static final Log LOG = LogFactory\n      .getLog(AsyncRcvdMsgCheckpointImpl.class);\n  /**\n   * It is responsible to find the smallest superstep for which the\n   * checkpointing is done and then restart all the peers from that superstep.\n   */\n  private static class CheckpointMasterService implements\n      FaultTolerantMasterService {\n    private Configuration conf;\n    private TaskInProgress tasks[];\n    private BSPJobID jobId;\n    private int maxTaskAttempts;\n    private int currentAttemptId;\n    private MasterSyncClient masterSyncClient;\n    private TaskAllocationStrategy allocationStrategy;\n    /**\n     * Initializes the fault tolerance service at BSPMasters\n     * \n     * @param jobId The identifier of the job.\n     * @param maxTaskAttempts Number of attempts allowed for recovering from\n     *          failure.\n     * @param tasks The list of tasks in the job.\n     * @param conf The job configuration object.\n     * @param masterClient The synchronization client used by BSPMaster.\n     * @param allocationStrategy The task allocation strategy of the job.\n     */\n    public void initialize(BSPJobID jobId, int maxTaskAttempts,\n        TaskInProgress[] tasks, Configuration conf,\n        MasterSyncClient masterClient, TaskAllocationStrategy allocationStrategy) {\n      this.tasks = tasks;\n      this.jobId = jobId;\n      this.conf = conf;\n      this.maxTaskAttempts = maxTaskAttempts;\n      this.currentAttemptId = 0;\n      this.masterSyncClient = masterClient;\n      this.allocationStrategy = allocationStrategy;\n    }\n    @Override\n    public boolean isRecoveryPossible(TaskInProgress tip) {\n      return currentAttemptId < maxTaskAttempts;\n    }\n    @Override\n    public boolean isAlreadyRecovered(TaskInProgress tip) {\n      return currentAttemptId < tip.getCurrentTaskAttemptId().getId();\n    }\n    @Override\n    public void recoverTasks(JobInProgress jip,\n        Map<String, GroomServerStatus> groomStatuses,\n        TaskInProgress[] failedTasksInProgress,\n        TaskInProgress[] allTasksInProgress,\n        Map<GroomServerStatus, Integer> taskCountInGroomMap,\n        Map<GroomServerStatus, List<GroomServerAction>> actionMap)\n        throws IOException {\n      Map<TaskID, TaskInProgress> recoverySet = new HashMap<TaskID, TaskInProgress>(\n          2 * failedTasksInProgress.length);\n      for (TaskInProgress failedTasksInProgres : failedTasksInProgress) {\n        recoverySet.put(failedTasksInProgres.getTaskId(), failedTasksInProgres);\n      }\n      long lowestSuperstepNumber = Long.MAX_VALUE;\n      String[] taskProgress = this.masterSyncClient.getChildKeySet(\n          this.masterSyncClient.constructKey(jobId, \"checkpoint\"), null);\n      if (LOG.isDebugEnabled()) {\n        StringBuffer list = new StringBuffer(25 * taskProgress.length);\n        list.append(\"got child key set\").append(taskProgress.length)\n            .append(\"/\").append(tasks.length).append(\" \");\n        for (String entry : taskProgress) {\n          list.append(entry).append(\",\");\n        }\n        LOG.debug(list);\n      }\n      if (taskProgress.length == this.tasks.length) {\n        for (String taskProgres : taskProgress) {\n          ArrayWritable progressInformation = new ArrayWritable(\n              LongWritable.class);\n          boolean result = this.masterSyncClient.getInformation(\n              this.masterSyncClient.constructKey(jobId, \"checkpoint\",\n                  taskProgres), progressInformation);\n          if (!result) {\n            lowestSuperstepNumber = -1L;\n            break;\n          }\n          Writable[] progressArr = progressInformation.get();\n          LongWritable superstepProgress = (LongWritable) progressArr[0];\n          if (superstepProgress != null) {\n            if (superstepProgress.get() < lowestSuperstepNumber) {\n              lowestSuperstepNumber = superstepProgress.get();\n              if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Got superstep number \" + lowestSuperstepNumber\n                    + \" from \" + taskProgres);\n              }\n            }\n          }\n        }\n        clearClientForSuperstep(lowestSuperstepNumber);\n        restartJob(lowestSuperstepNumber, groomStatuses, recoverySet,\n            allTasksInProgress, taskCountInGroomMap, actionMap);\n      } else {\n        restartJob(-1, groomStatuses, recoverySet, allTasksInProgress,\n            taskCountInGroomMap, actionMap);\n      }\n      ++currentAttemptId;\n    }\n    private void clearClientForSuperstep(long superstep) {\n      this.masterSyncClient.remove(\n          masterSyncClient.constructKey(jobId, \"sync\"), null);\n    }\n    private void populateAction(Task task, long superstep,\n        GroomServerStatus groomStatus,\n        Map<GroomServerStatus, List<GroomServerAction>> actionMap) {\n      List<GroomServerAction> list = actionMap.get(groomStatus);\n      if (!actionMap.containsKey(groomStatus)) {\n        list = new ArrayList<GroomServerAction>();\n        actionMap.put(groomStatus, list);\n      }\n      list.add(new RecoverTaskAction(task, superstep));\n    }\n    private void restartTask(TaskInProgress tip, long superstep,\n        Map<String, GroomServerStatus> groomStatuses,\n        Map<GroomServerStatus, List<GroomServerAction>> actionMap) {\n      GroomServerStatus serverStatus = tip.getGroomServerStatus();\n      Task task = tip.constructTask(serverStatus);\n      populateAction(task, superstep, serverStatus, actionMap);\n    }\n    private void restartJob(long superstep,\n        Map<String, GroomServerStatus> groomStatuses,\n        Map<TaskID, TaskInProgress> recoveryMap, TaskInProgress[] allTasks,\n        Map<GroomServerStatus, Integer> taskCountInGroomMap,\n        Map<GroomServerStatus, List<GroomServerAction>> actionMap)\n        throws IOException {\n      String path = conf.get(\"bsp.checkpoint.prefix_path\", \"/checkpoint/\");\n      if (superstep >= 0) {\n        FileSystem fileSystem = FileSystem.get(conf);\n        for (TaskInProgress allTask : allTasks) {\n          String[] hosts = null;\n          if (recoveryMap.containsKey(allTask.getTaskId())) {\n            // Update task count in map.\n            // TODO: This should be a responsibility of GroomServerStatus\n            Integer count = taskCountInGroomMap.get(allTask\n                .getGroomServerStatus());\n            if (count != null) {\n              count = count.intValue() - 1;\n              taskCountInGroomMap.put(allTask.getGroomServerStatus(), count);\n            }\n            StringBuffer ckptPath = new StringBuffer(path);\n            ckptPath.append(this.jobId.toString());\n            ckptPath.append(\"/\").append(superstep).append(\"/\")\n                .append(allTask.getTaskId().getId());\n            Path checkpointPath = new Path(ckptPath.toString());\n            if (fileSystem.exists(checkpointPath)) {\n              FileStatus fileStatus = fileSystem.getFileStatus(checkpointPath);\n              BlockLocation[] blocks = fileSystem.getFileBlockLocations(\n                  fileStatus, 0, fileStatus.getLen());\n              hosts = blocks[0].getHosts();\n            } else {\n              hosts = new String[groomStatuses.keySet().size()];\n              groomStatuses.keySet().toArray(hosts);\n            }\n            GroomServerStatus serverStatus = this.allocationStrategy\n                .getGroomToAllocate(groomStatuses, hosts, taskCountInGroomMap,\n                    new BSPResource[0], allTask);\n            Task task = allTask.constructTask(serverStatus);\n            populateAction(task, superstep, serverStatus, actionMap);\n          } else {\n            restartTask(allTask, superstep, groomStatuses, actionMap);\n          }\n        }\n      } else {\n        // Start the task from the beginning.\n        for (TaskInProgress allTask : allTasks) {\n          if (recoveryMap.containsKey(allTask.getTaskId())) {\n            this.allocationStrategy.getGroomToAllocate(groomStatuses,\n                this.allocationStrategy.selectGrooms(groomStatuses,\n                    taskCountInGroomMap, new BSPResource[0], allTask),\n                taskCountInGroomMap, new BSPResource[0], allTask);\n          } else {\n            restartTask(allTask, superstep, groomStatuses, actionMap);\n          }\n        }\n      }\n    }\n  }// end of CheckpointMasterService\n  @Override\n  public FaultTolerantPeerService<M> constructPeerFaultTolerance(BSPJob job,\n      @SuppressWarnings(\"rawtypes\") BSPPeer bspPeer, PeerSyncClient syncClient,\n      InetSocketAddress peerAddress, TaskAttemptID taskAttemptId,\n      long superstep, Configuration conf, MessageManager<M> messenger)\n      throws Exception {\n    CheckpointPeerService<M> service = new CheckpointPeerService<M>();<fim_middle>// class below is blob\n"}