{"text": "<fim_prefix>        }\n        private final int pos;\n    }\n    public enum DiagnosticFlag {\n        MANDATORY,\n        RESOLVE_ERROR,\n        SYNTAX,\n        RECOVERABLE,\n        NON_DEFERRABLE,\n        COMPRESSED,\n        /** Print multiple errors for same source locations.\n         */\n        MULTIPLE,\n        /** Flag for not-supported-in-source-X errors.\n         */\n        SOURCE_LEVEL;\n    }\n    private final DiagnosticSource source;\n    private final DiagnosticPosition position;\n    private final DiagnosticInfo diagnosticInfo;\n    private final Set<DiagnosticFlag> flags;\n    private final LintCategory lintCategory;\n    /** source line position (set lazily) */\n    private SourcePosition sourcePosition;\n    /**\n     * This class is used to defer the line/column position fetch logic after diagnostic construction.\n     */\n    class SourcePosition {\n        private final int line;\n        private final int column;\n        SourcePosition() {\n            int n = (position == null ? Position.NOPOS : position.getPreferredPosition());\n            if (n == Position.NOPOS || source == null)\n                line = column = -1;\n            else {\n                line = source.getLineNumber(n);\n                column = source.getColumnNumber(n, true);\n            }\n        }\n        public int getLineNumber() {\n            return line;\n        }\n        public int getColumnNumber() {\n            return column;\n        }\n    }\n    /**\n     * A diagnostic key object encapsulates basic properties of a diagnostic, such as the resource key,\n     * the arguments and the kind associated with the diagnostic object. Diagnostic keys can be either\n     * created programmatically (by using the supplied factory method) or obtained through build-time\n     * generated factory methods.\n     */\n    public static abstract class DiagnosticInfo {\n        /** The diagnostic kind (i.e. error). */\n        DiagnosticType type;\n        /** The diagnostic prefix (i.e. 'javac'); used to compute full resource key. */\n        String prefix;\n        /** The diagnostic code (i.e. 'cannot.resolve.sym'); together with {@code prefix} it forms\n         * the full resource key. */\n        String code;\n        /** The diagnostic arguments. */\n        Object[] args;\n        private DiagnosticInfo(DiagnosticType type, String prefix, String code, Object... args) {\n            this.type = type;\n            this.prefix = prefix;\n            this.code = code;\n            this.args = args;\n        }\n        /**\n         * Compute the resource key.\n         */\n        public String key() {\n            return prefix + \".\" + type.key + \".\" + code;\n        }\n        /**\n         * Static factory method; build a custom diagnostic key using given kind, prefix, code and args.\n         */\n        public static DiagnosticInfo of(DiagnosticType type, String prefix, String code, Object... args) {\n            switch (type) {\n                case ERROR:\n                    return new Error(prefix, code, args);\n                case WARNING:\n                    return new Warning(prefix, code, args);\n                case NOTE:\n                    return new Note(prefix, code, args);\n                case FRAGMENT:\n                    return new Fragment(prefix, code, args);\n                default:\n                    Assert.error(\"Wrong diagnostic type: \" + type);\n                    return null;\n            }\n        }\n    }\n    /**\n     * Class representing error diagnostic keys.\n     */\n    public static final class Error extends DiagnosticInfo {\n        public Error(String prefix, String key, Object... args) {\n            super(DiagnosticType.ERROR, prefix, key, args);\n        }\n    }\n    /**\n     * Class representing warning diagnostic keys.\n     */\n    public static final class Warning extends DiagnosticInfo {\n        public Warning(String prefix, String key, Object... args) {\n            super(DiagnosticType.WARNING, prefix, key, args);\n        }\n    }\n    /**\n     * Class representing note diagnostic keys.\n     */\n    public static final class Note extends DiagnosticInfo {\n        public Note(String prefix, String key, Object... args) {\n            super(DiagnosticType.NOTE, prefix, key, args);\n        }\n    }\n    /**\n     * Class representing fragment diagnostic keys.\n     */\n    public static final class Fragment extends DiagnosticInfo {\n        public Fragment(String prefix, String key, Object... args) {\n            super(DiagnosticType.FRAGMENT, prefix, key, args);\n        }\n    }\n    /**\n     * Create a diagnostic object.\n     * @param formatter the formatter to use for the diagnostic\n     * @param diagnosticInfo the diagnostic key\n     * @param lc     the lint category for the diagnostic\n     * @param source the name of the source file, or null if none.\n     * @param pos the character offset within the source file, if given.\n     */\n    protected JCDiagnostic(DiagnosticFormatter<JCDiagnostic> formatter,\n                       DiagnosticInfo diagnosticInfo,\n                       LintCategory lc,\n                       Set<DiagnosticFlag> flags,\n                       DiagnosticSource source,\n                       DiagnosticPosition pos) {\n        if (source == null && pos != null && pos.getPreferredPosition() != Position.NOPOS)\n            throw new IllegalArgumentException();\n        this.defaultFormatter = formatter;\n        this.diagnosticInfo = diagnosticInfo;\n        this.lintCategory = lc;\n        this.flags = flags;\n        this.source = source;\n        this.position = pos;\n    }\n    /**\n     * Get the type of this diagnostic.\n     * @return the type of this diagnostic\n     */\n    public DiagnosticType getType() {\n        return diagnosticInfo.type;\n    }\n    /**\n     * Get the subdiagnostic list\n     * @return subdiagnostic list\n     */\n    public List<JCDiagnostic> getSubdiagnostics() {\n        return List.nil();\n    }\n    public boolean isMultiline() {\n        return false;\n    }\n    /**\n     * Check whether or not this diagnostic is required to be shown.\n     * @return true if this diagnostic is required to be shown.\n     */\n    public boolean isMandatory() {\n        return flags.contains(DiagnosticFlag.MANDATORY);\n    }\n    /**\n     * Check whether this diagnostic has an associated lint category.\n     */\n    public boolean hasLintCategory() {\n        return (lintCategory != null);\n    }\n    /**\n     * Get the associated lint category, or null if none.\n     */\n    public LintCategory getLintCategory() {\n        return lintCategory;\n    }\n    /**\n     * Get the name of the source file referred to by this diagnostic.\n     * @return the name of the source referred to with this diagnostic, or null if none\n     */\n    @DefinedBy(Api.COMPILER)\n    public JavaFileObject getSource() {\n        if (source == null)\n            return null;\n        else\n            return source.getFile();\n    }\n    /**\n     * Get the source referred to by this diagnostic.\n     * @return the source referred to with this diagnostic, or null if none\n     */\n    public DiagnosticSource getDiagnosticSource() {\n        return source;\n    }\n    protected int getIntStartPosition() {\n        return (position == null ? Position.NOPOS : position.getStartPosition());\n    }\n    protected int getIntPosition() {\n        return (position == null ? Position.NOPOS : position.getPreferredPosition());\n    }\n    protected int getIntEndPosition() {\n        return (position == null ? Position.NOPOS : position.getEndPosition(source.getEndPosTable()));\n    }\n    @DefinedBy(Api.COMPILER)\n    public long getStartPosition() {\n        return getIntStartPosition();\n    }\n    @DefinedBy(Api.COMPILER)\n    public long getPosition() {\n        return getIntPosition();\n    }\n    @DefinedBy(Api.COMPILER)\n    public long getEndPosition() {\n        return getIntEndPosition();\n    }\n    public DiagnosticPosition getDiagnosticPosition() {\n        return position;\n    }\n    /**\n     * Get the line number within the source referred to by this diagnostic.\n     * @return  the line number within the source referred to by this diagnostic\n     */\n    @DefinedBy(Api.COMPILER)\n    public long getLineNumber() {\n        if (sourcePosition == null) {\n            sourcePosition = new SourcePosition();\n        }\n        return sourcePosition.getLineNumber();\n    }\n    /**\n     * Get the column number within the line of source referred to by this diagnostic.\n     * @return  the column number within the line of source referred to by this diagnostic\n     */\n    @DefinedBy(Api.COMPILER)\n    public long getColumnNumber() {\n        if (sourcePosition == null) {\n            sourcePosition = new SourcePosition();\n        }\n        return sourcePosition.getColumnNumber();\n    }\n    /**\n     * Get the arguments to be included in the text of the diagnostic.\n     * @return  the arguments to be included in the text of the diagnostic\n     */\n    public Object[] getArgs() {\n        return diagnosticInfo.args;\n    }\n    /**\n     * Get the prefix string associated with this type of diagnostic.\n     * @return the prefix string associated with this type of diagnostic\n     */\n    public String getPrefix() {\n        return getPrefix(diagnosticInfo.type);\n    }\n    /**\n     * Get the prefix string associated with a particular type of diagnostic.\n     * @return the prefix string associated with a particular type of diagnostic\n     */\n    public String getPrefix(DiagnosticType dt) {\n        return defaultFormatter.formatKind(this, Locale.getDefault());\n    }\n    /**\n     * Return the standard presentation of this diagnostic.\n     */\n<fim_suffix>    @Override\n    public String toString() {\n        return defaultFormatter.format(this, Locale.getDefault());\n    }<fim_middle>// function below has no smell\n"}