{"text": "<fim_prefix>/*\n * Copyright 2013-2014 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.xd.dirt.plugins.job;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport org.springframework.batch.core.Job;\nimport org.springframework.batch.core.JobExecutionListener;\nimport org.springframework.batch.core.StepListener;\nimport org.springframework.batch.core.configuration.JobRegistry;\nimport org.springframework.batch.core.configuration.support.JobRegistryBeanPostProcessor;\nimport org.springframework.batch.core.configuration.xml.JobParserJobFactoryBean;\nimport org.springframework.batch.core.configuration.xml.StepParserStepFactoryBean;\nimport org.springframework.batch.core.job.AbstractJob;\nimport org.springframework.beans.BeansException;\nimport org.springframework.beans.factory.BeanFactory;\nimport org.springframework.beans.factory.BeanFactoryAware;\nimport org.springframework.beans.factory.support.DefaultListableBeanFactory;\nimport org.springframework.util.Assert;\nimport org.springframework.xd.dirt.plugins.job.support.listener.XDJobListenerConstants;\n\n\n/**\n * JobRegistryBeanPostProcessor that processes batch job from the job module.\n *\n * @author Ilayaperumal Gopinathan\n * @author Michael Minella\n */\npublic class BatchJobRegistryBeanPostProcessor extends JobRegistryBeanPostProcessor implements BeanFactoryAware,\n\t\tXDJobListenerConstants {\n\n\tprivate static final Logger logger = LoggerFactory.getLogger(BatchJobRegistryBeanPostProcessor.class);\n\n\tpublic static final String JOB = \"job\";\n\n\tprivate JobRegistry jobRegistry;\n\n\tprivate DefaultListableBeanFactory beanFactory;\n\n\tprivate DistributedJobLocator jobLocator;\n\n\tprivate String groupName;\n\n\tprivate List<JobExecutionListener> jobExecutionListeners = new ArrayList<JobExecutionListener>();\n\n\tprivate List<StepListener> stepListeners = new ArrayList<StepListener>();\n\n\t@Override\n\tpublic void setJobRegistry(JobRegistry jobRegistry) {\n\t\tthis.jobRegistry = jobRegistry;\n\t\tsuper.setJobRegistry(jobRegistry);\n\t}\n\n\t@Override\n\tpublic void setBeanFactory(BeanFactory beanFactory) throws BeansException {\n\t\tif (beanFactory instanceof DefaultListableBeanFactory) {\n\t\t\tthis.beanFactory = (DefaultListableBeanFactory) beanFactory;\n\t\t}\n\t\tsuper.setBeanFactory(beanFactory);\n\t}\n\n\tpublic void setJobLocator(DistributedJobLocator jobLocator) {\n\t\tthis.jobLocator = jobLocator;\n\t}\n\n\t@Override\n\tpublic void setGroupName(String groupName) {\n\t\tthis.groupName = groupName;\n\t}\n\n\t@Override\n\tpublic Object postProcessAfterInitialization(Object bean, String beanName) {\n\t\tif (bean instanceof StepParserStepFactoryBean<?, ?>) {\n\t\t\taddStepListeners();\n\t\t\tif (!stepListeners.isEmpty()) {\n\t\t\t\t// Add the step listeners to the step parser factory bean\n\t\t\t\t((StepParserStepFactoryBean) bean).setListeners(this.stepListeners.toArray(new StepListener[this\n\t\t\t\t\t\t.stepListeners.size()]));\n\t\t\t}\n\t\t}\n\t\telse if (bean instanceof Job) {\n\t\t\tif (!jobRegistry.getJobNames().contains(groupName)) {\n\t\t\t\tString[] beansOfType = beanFactory.getBeanNamesForType(Job.class);\n\n\t\t\t\tif (beansOfType.length > 1) {\n\t\t\t\t\tif (beanName.equalsIgnoreCase(JOB)) {\n\t\t\t\t\t\tpostProcessJob(bean, beanName);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tlogger.debug(beanName + \" was not registered as a job since the context has more than one job \" +\n\t\t\t\t\t\t\t\t\"defined and it's id is not 'job'\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpostProcessJob(bean, beanName);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (jobRegistry.getJobNames().contains(groupName)) {\n\t\t\t\tthrow new BatchJobAlreadyExistsInRegistryException(groupName);\n\t\t\t}\n\t\t}\n\t\treturn bean;\n\t}\n\n\tprivate void postProcessJob(Object bean, String beanName) {\n\t\tAbstractJob job = (AbstractJob) bean;\n\t\tjob.setName(this.groupName);\n\t\taddJobExecutionListener();\n\t\tif (!this.jobExecutionListeners.isEmpty()) {\n\t\t\t// Add the job execution listeners to the job parser factory bean\n\t\t\tjob.setJobExecutionListeners(this.jobExecutionListeners.toArray(new\n\t\t\t\t\tJobExecutionListener[this.jobExecutionListeners.size()]));\n\t\t}\n\t\t// Add the job name, job parameters incrementer and job restartable flag to {@link DistributedJobLocator}\n\t\t// Since, the Spring batch doesn't have persistent JobRegistry, the {@link DistributedJobLocator}\n\t\t// acts as the store to have jobName , job parameter incrementer and restartable flag to be\n\t\t// used by {@link DistributedJobService}\n\t\tjobLocator.addJob(this.groupName, (job.getJobParametersIncrementer() != null) ? true : false,\n\t\t\t\tjob.isRestartable());\n\t\tjobLocator.addStepNames(this.groupName, job.getStepNames());\n\t\tsuper.postProcessAfterInitialization(bean, beanName);\n\t}\n\n<fim_suffix>\tprivate void addJobExecutionListener() {\n\t\t// Add all job execution listeners available in the bean factory\n\t\t// We won't have multiple batch job definitions on a given job module; hence all the job execution listeners\n\t\t// available in the bean factory correspond to the job module's batch job.\n\t\tMap<String, JobExecutionListener> listeners = this.beanFactory.getBeansOfType(JobExecutionListener.class);\n\t\tthis.jobExecutionListeners.addAll(listeners.values());\n\t}\n\n\tprivate void addStepListeners() {\n\t\tif (this.beanFactory.containsBean(XD_STEP_EXECUTION_LISTENER_BEAN)) {\n\t\t\tthis.stepListeners.add((StepListener) this.beanFactory.getBean(XD_STEP_EXECUTION_LISTENER_BEAN));\n\t\t}\n\t\tif (this.beanFactory.containsBean(XD_CHUNK_LISTENER_BEAN)) {\n\t\t\tthis.stepListeners.add((StepListener) this.beanFactory.getBean(XD_CHUNK_LISTENER_BEAN));\n\t\t}\n\t\tif (this.beanFactory.containsBean(XD_ITEM_LISTENER_BEAN)) {\n\t\t\tthis.stepListeners.add((StepListener) this.beanFactory.getBean(XD_ITEM_LISTENER_BEAN));\n\t\t}\n\t\tif (this.beanFactory.containsBean(XD_SKIP_LISTENER_BEAN)) {\n\t\t\tthis.stepListeners.add((StepListener) this.beanFactory.getBean(XD_SKIP_LISTENER_BEAN));\n\t\t}\n\t}\n\n\t@Override\n\tpublic void destroy() throws Exception {\n\t\tAssert.notNull(groupName, \"JobName should not be null\");\n\t\tjobLocator.deleteJobRegistry(groupName);\n\t\tsuper.destroy();\n\t}\n}<fim_middle>// function below has no smell\n"}