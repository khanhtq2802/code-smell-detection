{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.bookkeeper.statelib.impl.rocksdb.checkpoint;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Sets;\nimport com.google.common.io.Files;\nimport com.google.common.io.MoreFiles;\nimport com.google.common.io.RecursiveDeleteOption;\nimport com.google.protobuf.UnsafeByteOperations;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.nio.file.Paths;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.UUID;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.bookkeeper.statelib.api.checkpoint.CheckpointStore;\nimport org.apache.bookkeeper.statelib.api.exceptions.StateStoreException;\nimport org.apache.bookkeeper.statelib.impl.rocksdb.RocksUtils;\nimport org.apache.bookkeeper.stream.proto.kv.store.CheckpointMetadata;\nimport org.rocksdb.Checkpoint;\nimport org.rocksdb.RocksDBException;\n/**\n * A task that periodically checkpoints rocksdb instance.\n */\n@Slf4j\npublic class RocksdbCheckpointTask {\n    private final String dbName;\n    private final Checkpoint checkpoint;\n    private final File checkpointDir;\n    private final CheckpointStore checkpointStore;\n    private final String dbPrefix;\n    private final boolean removeLocalCheckpointAfterSuccessfulCheckpoint;\n    private final boolean removeRemoteCheckpointsAfterSuccessfulCheckpoint;\n    public RocksdbCheckpointTask(String dbName,\n                                 Checkpoint checkpoint,\n                                 File checkpointDir,\n                                 CheckpointStore checkpointStore,\n                                 boolean removeLocalCheckpoint,\n                                 boolean removeRemoteCheckpoints) {\n        this.dbName = dbName;\n        this.checkpoint = checkpoint;\n        this.checkpointDir = checkpointDir;\n        this.checkpointStore = checkpointStore;\n        this.dbPrefix = String.format(\"%s\", dbName);\n        this.removeLocalCheckpointAfterSuccessfulCheckpoint = removeLocalCheckpoint;\n        this.removeRemoteCheckpointsAfterSuccessfulCheckpoint = removeRemoteCheckpoints;\n    }\n    public String checkpoint(byte[] txid) throws StateStoreException {\n        String checkpointId = UUID.randomUUID().toString();\n        File tempDir = new File(checkpointDir, checkpointId);\n        log.info(\"Create a local checkpoint of state store {} at {}\",\n            dbName, tempDir);\n        try {\n            try {\n                checkpoint.createCheckpoint(tempDir.getAbsolutePath());\n            } catch (RocksDBException e) {\n                throw new StateStoreException(\"Failed to create a checkpoint at \" + tempDir, e);\n            }\n            String remoteCheckpointPath = RocksUtils.getDestCheckpointPath(dbPrefix, checkpointId);\n            if (!checkpointStore.fileExists(remoteCheckpointPath)) {\n                checkpointStore.createDirectories(remoteCheckpointPath);\n            }\n            String sstsPath = RocksUtils.getDestSstsPath(dbPrefix);\n            if (!checkpointStore.fileExists(sstsPath)) {\n                checkpointStore.createDirectories(sstsPath);\n            }\n            // get the files to copy\n            List<File> filesToCopy = getFilesToCopy(tempDir);\n            // copy the files\n            copyFilesToDest(checkpointId, filesToCopy);\n            // finalize copy files\n            finalizeCopyFiles(checkpointId, filesToCopy);\n            // dump the file list to checkpoint file\n            finalizeCheckpoint(checkpointId, tempDir, txid);\n            // clean up the remote checkpoints\n            if (removeRemoteCheckpointsAfterSuccessfulCheckpoint) {\n                cleanupRemoteCheckpoints(tempDir, checkpointId);\n            }\n            return checkpointId;\n        } catch (IOException ioe) {\n            log.error(\"Failed to checkpoint db {} to dir {}\", new Object[] { dbName, tempDir, ioe });\n            throw new StateStoreException(\n                \"Failed to checkpoint db \" + dbName + \" to dir \" + tempDir,\n                ioe);\n        } finally {\n            if (removeLocalCheckpointAfterSuccessfulCheckpoint && tempDir.exists()) {\n                try {\n                    MoreFiles.deleteRecursively(\n                        Paths.get(tempDir.getAbsolutePath()),\n                        RecursiveDeleteOption.ALLOW_INSECURE);\n                } catch (IOException ioe) {\n                    log.warn(\"Failed to remove temporary checkpoint dir {}\", tempDir, ioe);\n                }\n            }\n        }\n    }\n    private List<File> getFilesToCopy(File checkpointedDir) throws IOException {\n        File[] files = checkpointedDir.listFiles();\n        List<File> fileToCopy = Lists.newArrayListWithExpectedSize(files.length);\n        for (File file : files) {\n            if (RocksUtils.isSstFile(file)) {\n                // sst files\n                String destSstPath = RocksUtils.getDestSstPath(dbPrefix, file);\n                // TODO: do more validation on the file\n                if (!checkpointStore.fileExists(destSstPath)) {\n                    fileToCopy.add(file);\n                }\n            } else {\n                fileToCopy.add(file);\n            }\n        }\n        return fileToCopy;\n    }\n    private void copyFilesToDest(String checkpointId, List<File> files) throws IOException {\n        for (File file : files) {\n            copyFileToDest(checkpointId, file);\n        }\n    }\n    /**\n     * All sst files are copied to checkpoint location first.\n     */\n    private void copyFileToDest(String checkpointId, File file) throws IOException {\n        String destPath = RocksUtils.getDestPath(dbPrefix, checkpointId, file);\n        try (OutputStream os = checkpointStore.openOutputStream(destPath)) {\n            Files.copy(file, os);\n        }\n    }\n    /**\n     * Move the sst files to a common location.\n     */\n    private void finalizeCopyFiles(String checkpointId, List<File> files) throws IOException {\n        for (File file : files) {\n            if (RocksUtils.isSstFile(file)) {\n                String destSstTempPath = RocksUtils.getDestTempSstPath(\n                    dbPrefix, checkpointId, file);\n                String destSstPath = RocksUtils.getDestSstPath(dbPrefix, file);\n                checkpointStore.rename(destSstTempPath, destSstPath);\n            }\n        }\n    }\n<fim_suffix>    private void finalizeCheckpoint(String checkpointId,\n                                    File checkpointedDir,\n                                    byte[] txid) throws IOException {\n        File[] files = checkpointedDir.listFiles();\n        CheckpointMetadata.Builder metadataBuilder = CheckpointMetadata.newBuilder();\n        for (File file : files) {\n            metadataBuilder.addFiles(file.getName());\n        }\n        if (null != txid) {\n            metadataBuilder.setTxid(UnsafeByteOperations.unsafeWrap(txid));\n        }\n        metadataBuilder.setCreatedAt(System.currentTimeMillis());\n        String destCheckpointPath = RocksUtils.getDestCheckpointMetadataPath(dbPrefix, checkpointId);\n        try (OutputStream os = checkpointStore.openOutputStream(destCheckpointPath)) {\n            os.write(metadataBuilder.build().toByteArray());\n        }\n    }\n    /**\n     * Cleanup.\n     *\n     * <p>1) remove unneeded checkpoints\n     * 2) remove unreferenced sst files.\n     */\n    private void cleanupRemoteCheckpoints(File checkpointedDir, String checkpointToExclude) throws IOException {\n        String checkpointsPath = RocksUtils.getDestCheckpointsPath(dbPrefix);\n        List<String> checkpoints = checkpointStore.listFiles(checkpointsPath);\n        // delete checkpoints\n        for (String checkpoint : checkpoints) {\n            if (checkpoint.equals(checkpointToExclude)) {\n                continue;\n            }\n            String remoteCheckpointPath = RocksUtils.getDestCheckpointPath(dbPrefix, checkpoint);\n            checkpointStore.deleteRecursively(\n                remoteCheckpointPath);\n            log.info(\"Delete remote checkpoint {} from checkpoint store at {}\",\n                checkpoint, remoteCheckpointPath);\n        }\n        // delete unused ssts\n        Set<String> checkpointedFileSet = Sets.newHashSet();\n        String[] checkpointedFiles = checkpointedDir.list();\n        for (String file : checkpointedFiles) {\n            checkpointedFileSet.add(file);\n        }\n        List<String> allSsts = checkpointStore.listFiles(RocksUtils.getDestSstsPath(dbPrefix));\n        for (String sst : allSsts) {\n            if (checkpointedFileSet.contains(sst)) {\n                continue;\n            }<fim_middle>// function below has no smell\n"}