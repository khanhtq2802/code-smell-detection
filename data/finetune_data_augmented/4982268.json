{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.kafka.common.protocol.types;\n\nimport java.nio.ByteBuffer;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Objects;\n\n/**\n * The schema for a compound record definition\n */\n<fim_suffix>public class Schema extends Type {\n\n    private final BoundField[] fields;\n    private final Map<String, BoundField> fieldsByName;\n\n    /**\n     * Construct the schema with a given list of its field values\n     *\n     * @throws SchemaException If the given list have duplicate fields\n     */\n    public Schema(Field... fs) {\n        this.fields = new BoundField[fs.length];\n        this.fieldsByName = new HashMap<>();\n        for (int i = 0; i < this.fields.length; i++) {\n            Field def = fs[i];\n            if (fieldsByName.containsKey(def.name))\n                throw new SchemaException(\"Schema contains a duplicate field: \" + def.name);\n            this.fields[i] = new BoundField(def, this, i);\n            this.fieldsByName.put(def.name, this.fields[i]);\n        }\n    }\n\n    /**\n     * Write a struct to the buffer\n     */\n    @Override\n    public void write(ByteBuffer buffer, Object o) {\n        Struct r = (Struct) o;\n        for (BoundField field : fields) {\n            try {\n                Object value = field.def.type.validate(r.get(field));\n                field.def.type.write(buffer, value);\n            } catch (Exception e) {\n                throw new SchemaException(\"Error writing field '\" + field.def.name + \"': \" +\n                                          (e.getMessage() == null ? e.getClass().getName() : e.getMessage()));\n            }\n        }\n    }\n\n    /**\n     * Read a struct from the buffer\n     */\n    @Override\n    public Struct read(ByteBuffer buffer) {\n        Object[] objects = new Object[fields.length];\n        for (int i = 0; i < fields.length; i++) {\n            try {\n                objects[i] = fields[i].def.type.read(buffer);\n            } catch (Exception e) {\n                throw new SchemaException(\"Error reading field '\" + fields[i].def.name + \"': \" +\n                                          (e.getMessage() == null ? e.getClass().getName() : e.getMessage()));\n            }\n        }\n        return new Struct(this, objects);\n    }\n\n    /**\n     * The size of the given record\n     */\n    @Override\n    public int sizeOf(Object o) {\n        int size = 0;\n        Struct r = (Struct) o;\n        for (BoundField field : fields) {\n            try {\n                size += field.def.type.sizeOf(r.get(field));\n            } catch (Exception e) {\n                throw new SchemaException(\"Error computing size for field '\" + field.def.name + \"': \" +\n                        (e.getMessage() == null ? e.getClass().getName() : e.getMessage()));\n            }\n        }\n        return size;\n    }\n\n    /**\n     * The number of fields in this schema\n     */\n    public int numFields() {\n        return this.fields.length;\n    }\n\n    /**\n     * Get a field by its slot in the record array\n     * \n     * @param slot The slot at which this field sits\n     * @return The field\n     */\n    public BoundField get(int slot) {\n        return this.fields[slot];\n    }\n\n    /**\n     * Get a field by its name\n     * \n     * @param name The name of the field\n     * @return The field\n     */\n    public BoundField get(String name) {\n        return this.fieldsByName.get(name);\n    }\n\n    /**\n     * Get all the fields in this schema\n     */\n    public BoundField[] fields() {\n        return this.fields;\n    }\n\n    /**\n     * Display a string representation of the schema\n     */\n    @Override\n    public String toString() {\n        StringBuilder b = new StringBuilder();\n        b.append('{');\n        for (int i = 0; i < this.fields.length; i++) {\n            b.append(this.fields[i].toString());\n            if (i < this.fields.length - 1)\n                b.append(',');\n        }\n        b.append(\"}\");\n        return b.toString();\n    }\n\n    @Override\n    public Struct validate(Object item) {\n        try {\n            Struct struct = (Struct) item;\n            for (BoundField field : fields) {\n                try {\n                    field.def.type.validate(struct.get(field));\n                } catch (SchemaException e) {\n                    throw new SchemaException(\"Invalid value for field '\" + field.def.name + \"': \" + e.getMessage());\n                }\n            }\n            return struct;\n        } catch (ClassCastException e) {\n            throw new SchemaException(\"Not a Struct.\");\n        }\n    }\n\n    public void walk(Visitor visitor) {\n        Objects.requireNonNull(visitor, \"visitor must be non-null\");\n        handleNode(this, visitor);\n    }\n\n    private static void handleNode(Type node, Visitor visitor) {\n        if (node instanceof Schema) {\n            Schema schema = (Schema) node;\n            visitor.visit(schema);\n            for (BoundField f : schema.fields())\n                handleNode(f.def.type, visitor);\n        } else if (node instanceof ArrayOf) {\n            ArrayOf array = (ArrayOf) node;\n            visitor.visit(array);\n            handleNode(array.type(), visitor);\n        } else {\n            visitor.visit(node);\n        }\n    }\n\n    /**\n     * Override one or more of the visit methods with the desired logic.\n     */\n    public static abstract class Visitor {\n        public void visit(Schema schema) {}\n        public void visit(ArrayOf array) {}\n        public void visit(Type field) {}\n    }\n}<fim_middle>// class below has no smell\n"}