{"text": "<fim_prefix>            ((FieldNode) node).isStatic() && \n            ((FieldNode) node).getName().equals(\"mapping\");\n    }\n    public boolean isConstraintsField(AnnotatedNode node) {\n        if (node instanceof PropertyNode) {\n            node = ((PropertyNode) node).getField();\n        }\n        return node instanceof FieldNode && \n        ((FieldNode) node).isStatic() && \n        ((FieldNode) node).getName().equals(\"constraints\");\n    }\n    // this method is called if the target CU is a domain class\n    public void initializeTypeLookup(VariableScope scope) {\n        ClassNode node = getGroovyClass();\n        if (node == null) return;\n        populateInjectedServices(scope);\n        FieldNode field = scope.getEnclosingFieldDeclaration();\n        if (field != null) {\n            if (isMappingField(field)) {\n                for (String fieldName : MAPPINGS_FIELDS) {\n                    scope.addVariable(fieldName, VariableScope.VOID_CLASS_NODE, node);\n                }\n            }\n        }\n    }\n    // this method is called whenever the current type is a domain class\n    public TypeAndDeclaration lookupTypeAndDeclaration(ClassNode declaringType,\n            String name, VariableScope scope) {\n        // first check to see if we've already come across this name \n        // before in the current Domain class\n        TypeAndDeclaration typeAndDeclaration = findCached(name);\n        if (typeAndDeclaration != null) {\n            return typeAndDeclaration;\n        }\n        // static members\n        Map<String, ClassNode[]> staticDomainMembers = memberCache.getStaticDomainMembers();\n        // must check for containsKey since some of the values are purposely null\n        if (staticDomainMembers.containsKey(name)) {\n            ClassNode[] staticDomainTypes = staticDomainMembers.get(name);\n            ClassNode retType;\n            ClassNode inferredDeclingType;\n            if (staticDomainTypes[0] == null) {\n                retType = declaringType;\n            } else if (staticDomainTypes[0].redirect() == VariableScope.LIST_CLASS_NODE) {\n                retType = VariableScope.clone(staticDomainTypes[0]);\n                GenericsType genericsType = retType.getGenericsTypes()[0];\n                genericsType.setType(declaringType);\n                genericsType.setName(declaringType.getName());\n                genericsType.setUpperBounds(null);\n                genericsType.setLowerBound(null);\n            } else {\n                retType = staticDomainTypes[0];\n            }\n            if (staticDomainTypes[1] == null) {\n                inferredDeclingType = declaringType;\n            } else {\n                inferredDeclingType = staticDomainTypes[1];\n            }\n            FieldNode cached = new FieldNode(name, Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC, retType, inferredDeclingType, null);\n            cached.setDeclaringClass(inferredDeclingType);\n            cacheGeneratedMember(cached);\n            return new TypeAndDeclaration(retType, cached, inferredDeclingType);\n        }\n        // dynamic finder prefixes\n        // must do a containsKey() first because some of the values are null\n        Map<String, ClassNode> dynamicDomainMembers = memberCache.getDynamicDomainMembers();\n        if (dynamicDomainMembers.containsKey(name)) {\n            ClassNode dynamicDomainType = dynamicDomainMembers.get(name);\n            if (dynamicDomainType == null) {\n                dynamicDomainType = declaringType;\n            } else if (dynamicDomainType.redirect() == VariableScope.LIST_CLASS_NODE) {\n                dynamicDomainType = VariableScope.clone(dynamicDomainType);\n                GenericsType genericsType = dynamicDomainType.getGenericsTypes()[0];\n                genericsType.setType(declaringType);\n                genericsType.setName(declaringType.getName());\n                genericsType.setUpperBounds(null);\n                genericsType.setLowerBound(null);\n            }\n            FieldNode cached = new FieldNode(name, Opcodes.ACC_PUBLIC, dynamicDomainType, declaringType, null);\n            cached.setDeclaringClass(declaringType);\n            cacheGeneratedMember(cached);\n            return new TypeAndDeclaration(dynamicDomainType, cached);\n        }\n        // non-static members\n        Map<String, ClassNode> nonstaticDomainMembers = memberCache.getNonstaticDomainMembers();\n        ClassNode nonStaticType = nonstaticDomainMembers.get(name);\n        if (nonStaticType != null) {\n            FieldNode cached = new FieldNode(name, Opcodes.ACC_PUBLIC, nonStaticType, declaringType, null);\n            cached.setDeclaringClass(declaringType);\n            cacheGeneratedMember(cached);\n            return new TypeAndDeclaration(nonStaticType, cached);\n        }\n        // look for dynamic finders\n        DynamicFinderValidator internalFinderValidator = getFinderValidator();\n        if (internalFinderValidator.isValidFinderName(name)) {\n            FieldNode field = internalFinderValidator.createFieldDeclaration(name);\n            cacheGeneratedMember(field);\n            return new TypeAndDeclaration(field.getType(), field, declaringType, \"Dynamic finder\");\n        }\n        // look for namedQueries\n        for (String namedQuery : getNamedQueries()) {\n            if (name.equals(namedQuery)) {\n                FieldNode criteria = createNamedCriteria(declaringType, namedQuery);\n                return new TypeAndDeclaration(criteria.getType(), criteria, declaringType, \"Named Query\");\n            }\n        }\n        // now look at properties and methods contributed by plugins\n        Map<String, ContributedProperty> contributedProperties = pluginCache.getAllDomainProperties();\n        if (contributedProperties.containsKey(name)) {\n            ClassNode type = contributedProperties.get(name).getType();\n            return new TypeAndDeclaration(type == null ? declaringType : type, declaringType);\n        }\n        Map<String, Set<ContributedMethod>> contributedMethods = pluginCache.getAllDomainMethods();\n        if (contributedMethods.containsKey(name)) {\n            ClassNode returnType = contributedMethods.get(name).iterator().next().getReturnType();\n            return new TypeAndDeclaration(returnType == null ? declaringType : returnType, declaringType);\n        }\n        // now check to see if we are in the constraints field\n        if (isConstraintsField(scope.getEnclosingFieldDeclaration())) {\n            for (PropertyNode domainProp : getDomainProperties()) {\n                if (domainProp.getName().equals(name)) {\n                    return new TypeAndDeclaration(VariableScope.VOID_CLASS_NODE, domainProp, declaringType, \"Constraints property\");\n                }\n            }\n        }\n        return null;\n    }\n    public TypeAndDeclaration findCached(String name) {\n        TypeAndDeclaration typeAndDeclaration = null;\n        AnnotatedNode cached = getCachedMember(name);\n        if (cached != null) {\n            ClassNode type;\n            ClassNode inferredDeclaringType = cached.getDeclaringClass();\n            if (cached instanceof FieldNode) {\n                type = ((FieldNode) cached).getType();\n            } else if (cached instanceof MethodNode) {\n                type = ((MethodNode) cached).getReturnType();\n            } else {\n                type = getGroovyClass();\n            }\n            typeAndDeclaration = new TypeAndDeclaration(type, cached, inferredDeclaringType);\n        }\n        return typeAndDeclaration;\n    }\n    public FieldNode createNamedCriteria(ClassNode declaringType,\n            String namedQuery) {\n        ClassNode criteriaType = getNamedQueryProxyType(namedQuery);\n        FieldNode criteria = new FieldNode(namedQuery, Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC, criteriaType, declaringType, null);\n        criteria.setDeclaringClass(declaringType);\n        cacheGeneratedMember(criteria);\n        return criteria;\n    }\n    private ClassNode getNamedQueryProxyType(String namedQuery) {\n        return new NamedQueryClassNode();\n    }\n    public Map<String, Set<ContributedMethod>> getAllContributedMethods() {\n       return pluginCache.getAllDomainMethods(); \n    }\n    public Map<String, ContributedProperty> getAllContributedProperties() {\n        return pluginCache.getAllDomainProperties(); \n    }\n    public Map<String, ClassNode[]> getStaticMembers() {\n        return memberCache.getStaticDomainMembers();\n    }\n    public Map<String, ClassNode> getDynamicFinderMembers() {\n        return memberCache.getDynamicDomainMembers();\n    }\n    public Map<String, ClassNode> getNonstaticMembers() {\n        return memberCache.getNonstaticDomainMembers();\n    }\n    public static boolean isFieldReference(String name) {\n        return name.equals(\"contraints\") ||\n               name.equals(\"properties\") ||\n               name.equals(\"errors\") ||\n               name.equals(\"id\");\n    }\n    public IFolder getGSPFolder() {\n        // project name/grails-app/views/domainClassName/elementName.gsp\n        StringBuilder sb = new StringBuilder();\n        sb.append(unit.getJavaProject().getElementName()).append(\"/grails-app/views/\");\n        sb.append(gspFolderName());\n        IFolder folder = ResourcesPlugin.getWorkspace().getRoot().getFolder(new Path(sb.toString()));\n        return folder;\n    }\n<fim_suffix>    private String gspFolderName() {\n        String name = unit.getElementName();\n        int dotIndex = name.indexOf(\".\");\n        if (dotIndex > 0) {\n            name = Character.toLowerCase(name.charAt(0)) + name.substring(1, dotIndex);\n            return name;\n        } else {\n            return name;\n        }\n    }<fim_middle>// function below has no smell\n"}