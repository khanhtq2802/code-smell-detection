{"text": "<fim_prefix>            }\n        }\n    }\n    /**\n     *\n     */\n    private class ZkWatcher extends ZkAbstractWatcher implements ZkRuntimeState.ZkWatcher {\n        /**\n         * @param rtState Runtime state.\n         */\n        ZkWatcher(ZkRuntimeState rtState) {\n            super(rtState, ZookeeperDiscoveryImpl.this);\n        }\n        /** {@inheritDoc} */\n        @Override public void process0(WatchedEvent evt) {\n            if (evt.getType() == Event.EventType.NodeDataChanged) {\n                if (evt.getPath().equals(zkPaths.evtsPath)) {\n                    if (!rtState.crd)\n                        rtState.zkClient.getDataAsync(evt.getPath(), this, this);\n                }\n                else\n                    U.warn(log, \"Received NodeDataChanged for unexpected path: \" + evt.getPath());\n            }\n            else if (evt.getType() == Event.EventType.NodeChildrenChanged) {\n                if (evt.getPath().equals(zkPaths.aliveNodesDir))\n                    rtState.zkClient.getChildrenAsync(evt.getPath(), this, this);\n                else if (evt.getPath().equals(zkPaths.customEvtsDir))\n                    rtState.zkClient.getChildrenAsync(evt.getPath(), this, this);\n                else\n                    U.warn(log, \"Received NodeChildrenChanged for unexpected path: \" + evt.getPath());\n            }\n        }\n        /** {@inheritDoc} */\n        @Override public void processResult(int rc, String path, Object ctx, List<String> children, Stat stat) {\n            if (!onProcessStart())\n                return;\n            try {\n                assert rc == 0 : KeeperException.Code.get(rc);\n                if (path.equals(zkPaths.aliveNodesDir))\n                    generateTopologyEvents(children);\n                else if (path.equals(zkPaths.customEvtsDir))\n                    generateCustomEvents(children);\n                else\n                    U.warn(log, \"Children callback for unexpected path: \" + path);\n                onProcessEnd();\n            }\n            catch (Throwable e) {\n                onProcessError(e);\n            }\n        }\n        /** {@inheritDoc} */\n        @Override public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {\n            if (!onProcessStart())\n                return;\n            try {\n                assert rc == 0 : KeeperException.Code.get(rc);\n                if (path.equals(zkPaths.evtsPath)) {\n                    if (!rtState.crd)\n                        processNewEvents(data);\n                }\n                else\n                    U.warn(log, \"Data callback for unknown path: \" + path);\n                onProcessEnd();\n            }\n            catch (Throwable e) {\n                onProcessError(e);\n            }\n        }\n    }\n    /**\n     *\n     */\n    private class AliveNodeDataWatcher extends ZkAbstractWatcher implements ZkRuntimeState.ZkAliveNodeDataWatcher {\n        /**\n         * @param rtState Runtime state.\n         */\n        AliveNodeDataWatcher(ZkRuntimeState rtState) {\n            super(rtState, ZookeeperDiscoveryImpl.this);\n        }\n        /** {@inheritDoc} */\n        @Override public void process0(WatchedEvent evt) {\n            if (evt.getType() == Event.EventType.NodeDataChanged)\n                rtState.zkClient.getDataAsync(evt.getPath(), this, this);\n        }\n        /** {@inheritDoc} */\n        @Override public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) {\n            if (!onProcessStart())\n                return;\n            try {\n                assert rtState.crd;\n                processResult0(rc, path, data);\n                onProcessEnd();\n            }\n            catch (Throwable e) {\n                onProcessError(e);\n            }\n        }\n        /**\n         * @param rc Result code.\n         * @param path Path.\n         * @param data Data.\n         * @throws Exception If failed.\n         */\n        private void processResult0(int rc, String path, byte[] data) throws Exception {\n            if (rc == KeeperException.Code.NONODE.intValue()) {\n                if (log.isDebugEnabled())\n                    log.debug(\"Alive node callaback, no node: \" + path);\n                return;\n            }\n            assert rc == 0 : KeeperException.Code.get(rc);\n            if (data.length > 0) {\n                ZkAliveNodeData nodeData = unmarshalZip(data);\n                Long nodeInternalId = ZkIgnitePaths.aliveInternalId(path);\n                Iterator<ZkDiscoveryEventData> it = rtState.evtsData.evts.values().iterator();\n                boolean processed = false;\n                while (it.hasNext()) {\n                    ZkDiscoveryEventData evtData = it.next();\n                    if (evtData.onAckReceived(nodeInternalId, nodeData.lastProcEvt))\n                        processed = true;\n                }\n                if (processed)\n                    handleProcessedEvents(\"ack-\" + nodeInternalId);\n            }\n        }\n    }\n    /**\n     *\n     */\n    private abstract class PreviousNodeWatcher extends ZkAbstractWatcher implements AsyncCallback.StatCallback {\n        /**\n         * @param rtState Runtime state.\n         */\n        PreviousNodeWatcher(ZkRuntimeState rtState) {\n            super(rtState, ZookeeperDiscoveryImpl.this);\n        }\n        /** {@inheritDoc} */\n        @Override public void process0(WatchedEvent evt) {\n            if (evt.getType() == Event.EventType.NodeDeleted)\n                onPreviousNodeFail();\n            else {\n                if (evt.getType() != Event.EventType.None)\n                    rtState.zkClient.existsAsync(evt.getPath(), this, this);\n            }\n        }\n        /** {@inheritDoc} */\n        @Override public void processResult(int rc, String path, Object ctx, Stat stat) {\n            if (!onProcessStart())\n                return;\n            try {\n                assert rc == 0 || rc == KeeperException.Code.NONODE.intValue() : KeeperException.Code.get(rc);\n                if (rc == KeeperException.Code.NONODE.intValue() || stat == null)\n                    onPreviousNodeFail();\n                onProcessEnd();\n            }\n            catch (Throwable e) {\n                onProcessError(e);\n            }\n        }\n        /**\n         *\n         */\n        abstract void onPreviousNodeFail();\n    }\n    /**\n     *\n     */\n    private class ServerPreviousNodeWatcher extends PreviousNodeWatcher {\n        /**\n         * @param rtState Runtime state.\n         */\n        ServerPreviousNodeWatcher(ZkRuntimeState rtState) {\n            super(rtState);\n            assert !locNode.isClient() : locNode;\n        }\n        /** {@inheritDoc} */\n        @Override void onPreviousNodeFail() {\n            if (log.isInfoEnabled())\n                log.info(\"Previous server node failed, check is node new coordinator [locId=\" + locNode.id() + ']');\n            rtState.zkClient.getChildrenAsync(zkPaths.aliveNodesDir, null, new CheckCoordinatorCallback(rtState));\n        }\n    }\n    /**\n     *\n     */\n    private class ClientPreviousNodeWatcher extends PreviousNodeWatcher {\n        /**\n         * @param rtState Runtime state.\n         */\n        ClientPreviousNodeWatcher(ZkRuntimeState rtState) {\n            super(rtState);\n            assert locNode.isClient() : locNode;\n        }\n        /** {@inheritDoc} */\n        @Override void onPreviousNodeFail() {\n            if (log.isInfoEnabled())\n                log.info(\"Watched node failed, check if there are alive servers [locId=\" + locNode.id() + ']');\n            rtState.zkClient.getChildrenAsync(zkPaths.aliveNodesDir, null, new CheckClientsStatusCallback(rtState));\n        }\n    }\n    /**\n     * Watcher for the local node. The local node can be deleted in case of cluster restarts.\n     * See {@link #cleanupPreviousClusterData}.\n     */\n<fim_suffix>    private class ClientLocalNodeWatcher extends PreviousNodeWatcher {\n        final CheckJoinErrorWatcher joinErrorWatcher;\n        /**\n         * @param rtState Runtime state.\n         */\n        ClientLocalNodeWatcher(ZkRuntimeState rtState, CheckJoinErrorWatcher joinErrorWatcher) {\n            super(rtState);\n            assert locNode.isClient() : locNode;\n            this.joinErrorWatcher = joinErrorWatcher;\n        }\n        /** {@inheritDoc} */\n        @Override void onPreviousNodeFail() {\n            // Check that there are no errors in join data.\n            joinErrorWatcher.checkJoinError();\n            if (rtState.errForClose != null || rtState.joined)\n                return;\n            synchronized (stateMux) {\n                if (connState != ConnectionState.STARTED)\n                    return;\n            }\n            if (log.isInfoEnabled())\n                log.info(\"Watched local node failed [locId=\" + locNode.id() + ']');\n            localNodeFail(\"Local node was forced to stop.\", true);\n        }\n    }<fim_middle>// class below has no smell\n"}