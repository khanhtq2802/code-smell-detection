{"text": "<fim_prefix>\n<fim_suffix>final class SearchFirstStringNode extends Node {\n    private static final int[] UNINTIALIZED_CACHED_INDICES = new int[0];\n    private final VectorLengthProfile targetLengthProfile = VectorLengthProfile.create();\n    private final VectorLengthProfile elementsLengthProfile = VectorLengthProfile.create();\n    private final ValueProfile targetClassProfile = ValueProfile.createClassProfile();\n    private final ValueProfile elementsClassProfile = ValueProfile.createClassProfile();\n    @Child private StringEqualsNode stringEquals = CompareStringNode.createEquals();\n    @Child private CompareStringNode stringStartsWith;\n    @Child private StringEqualsNode equalsDuplicate;\n    private final NACheck elementsNACheck = NACheck.create();\n    private final NACheck targetNACheck = NACheck.create();\n    private final BranchProfile everFoundDuplicate = BranchProfile.create();\n    private final BranchProfile seenInvalid = BranchProfile.create();\n    /** Instead of using the notFoundStartIndex we use NA. */\n    private final boolean useNAForNotFound;\n    private final boolean exactMatch;\n    @CompilationFinal(dimensions = 1) private int[] cachedIndices;\n    private SearchFirstStringNode(boolean exactMatch, boolean useNAForNotFound) {\n        this.exactMatch = exactMatch;\n        this.useNAForNotFound = useNAForNotFound;\n        if (!exactMatch) {\n            stringStartsWith = CompareStringNode.createStartsWith();\n        }\n    }\n    public RAbstractIntVector apply(RAbstractStringVector target, RAbstractStringVector elements, int notFoundStartIndex, RStringVector names) {\n        RAbstractStringVector targetProfiled = targetClassProfile.profile(target);\n        RAbstractStringVector elementsProfiled = elementsClassProfile.profile(elements);\n        int targetLength = targetLengthProfile.profile(targetProfiled.getLength());\n        int elementsLength = elementsLengthProfile.profile(elementsProfiled.getLength());\n        targetNACheck.enable(target);\n        elementsNACheck.enable(elements);\n        if (cachedIndices == UNINTIALIZED_CACHED_INDICES) {\n            CompilerDirectives.transferToInterpreterAndInvalidate();\n            cachedIndices = searchCached(targetProfiled, targetLength, elementsProfiled, elementsLength, names);\n        }\n        if (cachedIndices != null) {\n            if (!isCacheValid(targetProfiled, targetLength, elementsProfiled, elementsLength, cachedIndices)) {\n                CompilerDirectives.transferToInterpreterAndInvalidate();\n                cachedIndices = null; // set to generic\n                // fallthrough to generic\n            } else {\n                assert sameVector(searchCached(target, targetLength, elements, elementsLength, names), cachedIndices);\n                return RDataFactory.createIntVector(cachedIndices, true, names);\n            }\n        }\n        return searchGeneric(targetProfiled, targetLength, elementsProfiled, elementsLength, notFoundStartIndex, false, names);\n    }\n    public static SearchFirstStringNode createNode(boolean exactMatch, boolean useNAForNotFound) {\n        return new SearchFirstStringNode(exactMatch, useNAForNotFound);\n    }\n    private int[] searchCached(RAbstractStringVector target, int targetLength, RAbstractStringVector elements, int elementsLength, RStringVector names) {\n        if (exactMatch) {\n            RAbstractIntVector genericResult = searchGeneric(target, targetLength, elements, elementsLength, -1, true, names);\n            if (genericResult != null) {\n                return genericResult.materialize().getReadonlyData();\n            }\n        }\n        return null;\n    }\n    private boolean isCacheValid(RAbstractStringVector target, int targetLength,\n                    RAbstractStringVector elements, int elementsLength, int[] cached) {\n        int cachedLength = cached.length;\n        if (elementsLength != cachedLength) {\n            seenInvalid.enter();\n            return false;\n        }\n        for (int i = 0; i < cachedLength; i++) {\n            int cachedIndex = cached[i];\n            String cachedElement = elements.getDataAt(i);\n            int cachedElementHash = cachedElement.hashCode();\n            assert !elementsNACheck.check(cachedElement) && cachedElement.length() > 0;\n            int cachedTranslatedIndex = cachedIndex - 1;\n            for (int j = 0; j < cachedTranslatedIndex; j++) {\n                String targetString = target.getDataAt(j);\n                if (!targetNACheck.check(targetString) && stringEquals.executeCompare(cachedElement, cachedElementHash, targetString)) {\n                    seenInvalid.enter();\n                    return false;\n                }\n            }\n            if (cachedTranslatedIndex < targetLength) {\n                String targetString = target.getDataAt(cachedTranslatedIndex);\n                if (!targetNACheck.check(targetString) && !stringEquals.executeCompare(cachedElement, cachedElementHash, targetString)) {\n                    seenInvalid.enter();\n                    return false;\n                }\n            } else {\n                seenInvalid.enter();\n                return false;\n            }\n        }\n        return true;\n    }\n    private static boolean sameVector(int[] a, int[] b) {\n        if (a == null) {\n            return false;\n        }\n        if (a.length != b.length) {\n            return false;\n        }\n        for (int i = 0; i < a.length; i++) {\n            if (a[i] != b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private final BranchProfile notFoundProfile = BranchProfile.create();\n    private final ConditionProfile hashingProfile = ConditionProfile.createBinaryProfile();\n    private RAbstractIntVector searchGeneric(RAbstractStringVector target, int targetLength, RAbstractStringVector elements, int elementsLength, int notFoundStartIndex, boolean nullOnNotFound,\n                    RStringVector names) {\n        int[] indices = new int[elementsLength];\n        boolean resultComplete = true;\n        long hashingCost = targetLength * 10L + 10 /* constant overhead */;\n        long lookupCost = elementsLength * 2L;\n        long nestedLoopCost = targetLength * (long) elementsLength;\n        NonRecursiveHashMapCharacter map;\n        if (hashingProfile.profile(nestedLoopCost > hashingCost + lookupCost)) {\n            map = new NonRecursiveHashMapCharacter(targetLength);\n            for (int i = 0; i < targetLength; i++) {\n                String name = target.getDataAt(i);\n                if (!targetNACheck.check(name)) {\n                    map.put(name, i);\n                }\n            }\n        } else {\n            map = null;\n        }\n        int notFoundIndex = notFoundStartIndex;\n        for (int i = 0; i < elementsLength; i++) {\n            String element = elements.getDataAt(i);\n            boolean isElementNA = elementsNACheck.check(element) || element.length() == 0;\n            if (!isElementNA) {\n                int index;\n                if (map != null) {\n                    index = map.get(element);\n                    if (!exactMatch && index < 0) {\n                        // the map is only good for exact matches\n                        index = findNonExactIndex(target, targetLength, element);\n                    }\n                } else {\n                    index = findIndex(target, targetLength, element);\n                }\n                if (index >= 0) {\n                    indices[i] = index + 1;\n                    continue;\n                }\n            }\n            notFoundProfile.enter();\n            if (nullOnNotFound) {\n                return null;\n            } else {\n                int prevDuplicateIndex = -1;\n                if (!isElementNA) {\n                    prevDuplicateIndex = findFirstDuplicate(elements, element, i);\n                }\n                int nextIndex;\n                if (prevDuplicateIndex == -1) {\n                    if (useNAForNotFound) {\n                        resultComplete = false;\n                        nextIndex = RRuntime.INT_NA;\n                    } else {\n                        nextIndex = ++notFoundIndex;\n                    }\n                } else {\n                    nextIndex = indices[prevDuplicateIndex];\n                }\n                indices[i] = nextIndex;\n            }\n        }\n        return RDataFactory.createIntVector(indices, resultComplete && elements.isComplete(), names);\n    }\n    private int findNonExactIndex(RAbstractStringVector target, int targetLength, String element) {\n        assert !exactMatch;\n        int nonExactIndex = -1;\n        for (int j = 0; j < targetLength; j++) {\n            String targetValue = target.getDataAt(j);\n            if (!targetNACheck.check(targetValue)) {\n                if (stringStartsWith.executeCompare(targetValue, element)) {\n                    if (nonExactIndex == -1) {\n                        nonExactIndex = j;\n                    } else {\n                        return -1;\n                    }\n                }\n            }\n        }\n        return nonExactIndex;\n    }\n    private int findIndex(RAbstractStringVector target, int targetLength, String element) {\n        int nonExactIndex = -1;\n        int elementHash = element.hashCode();\n        for (int j = 0; j < targetLength; j++) {\n            String targetValue = target.getDataAt(j);\n            if (!targetNACheck.check(targetValue)) {\n                if (stringEquals.executeCompare(element, elementHash, targetValue)) {\n                    return j;\n                }\n                if (!exactMatch) {<fim_middle>// class below is blob\n"}