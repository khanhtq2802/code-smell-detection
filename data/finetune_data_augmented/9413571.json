{"text": "<fim_prefix>/*\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n/*\n *\n *  (C) Copyright IBM Corp. 1999 All Rights Reserved.\n *  Copyright 1997 The Open Group Research Institute.  All rights reserved.\n */\npackage sun.security.krb5.internal.ccache;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport sun.security.krb5.*;\nimport sun.security.krb5.internal.*;\nimport sun.security.krb5.internal.util.KrbDataInputStream;\nimport sun.security.util.IOUtils;\n/**\n * This class extends KrbDataInputStream. It is used for parsing FCC-format\n * data from file to memory.\n *\n * @author Yanni Zhang\n *\n */\npublic class CCacheInputStream extends KrbDataInputStream implements FileCCacheConstants {\n    /*\n     * FCC version 2 contains type information for principals.  FCC\n     * version 1 does not.\n     *\n     * FCC version 3 contains keyblock encryption type information, and is\n     * architecture independent.  Previous versions are not.\n     *\n     * The code will accept version 1, 2, and 3 ccaches, and depending\n     * what KRB5_FCC_DEFAULT_FVNO is set to, it will create version 1, 2,\n     * or 3 FCC caches.\n     *\n     * The default credentials cache should be type 3 for now (see\n     * init_ctx.c).\n     */\n    /* V4 of the credentials cache format allows for header tags */\n    private static boolean DEBUG = Krb5.DEBUG;\n    public CCacheInputStream(InputStream is){\n        super(is);\n    }\n    /* Read tag field introduced in KRB5_FCC_FVNO_4 */\n    // this needs to be public for Kinit.\n    public Tag readTag() throws IOException {\n        char[] buf = new char[1024];\n        int len;\n        int tag = -1;\n        int taglen;\n        Integer time_offset = null;\n        Integer usec_offset = null;\n        len = read(2);\n        if (len < 0) {\n            throw new IOException(\"stop.\");\n        }\n        if (len > buf.length) {\n            throw new IOException(\"Invalid tag length.\");\n        }\n        while (len > 0) {\n            tag    = read(2);\n            taglen = read(2);\n            switch (tag) {\n            case FCC_TAG_DELTATIME:\n                time_offset = read(4);\n                usec_offset = read(4);\n                break;\n            default:\n            }\n            len = len - (4 + taglen);\n        }\n        return new Tag(len, tag, time_offset, usec_offset);\n    }\n    /*\n     * In file-based credential cache, the realm name is stored as part of\n     * principal name at the first place.\n     */\n    // made public for KinitOptions to call directly\n    public PrincipalName readPrincipal(int version) throws IOException, RealmException {\n        int type, length, namelength, kret;\n        String[] pname = null;\n        String realm;\n        /* Read principal type */\n        if (version == KRB5_FCC_FVNO_1) {\n            type = KRB5_NT_UNKNOWN;\n        } else {\n            type = read(4);\n        }\n        length = readLength4();\n        List<String> result = new ArrayList<String>();\n        /*\n         * DCE includes the principal's realm in the count; the new format\n         * does not.\n         */\n        if (version == KRB5_FCC_FVNO_1)\n            length--;\n        for (int i = 0; i <= length; i++) {\n            namelength = readLength4();\n            byte[] bytes = IOUtils.readFully(this, namelength, true);\n            result.add(new String(bytes));\n        }\n        if (result.isEmpty()) {\n            throw new IOException(\"No realm or principal\");\n        }\n        if (isRealm(result.get(0))) {\n            realm = result.remove(0);\n            if (result.isEmpty()) {\n                throw new IOException(\"No principal name components\");\n            }\n            return new PrincipalName(\n                    type,\n                    result.toArray(new String[result.size()]),\n                    new Realm(realm));\n        }\n        try {\n            return new PrincipalName(\n                    type,\n                    result.toArray(new String[result.size()]),\n                    Realm.getDefault());\n        } catch (RealmException re) {\n            return null;\n        }\n    }\n    /*\n     * In practice, a realm is named by uppercasing the DNS domain name. we currently\n     * rely on this to determine if the string within the principal identifier is realm\n     * name.\n     *\n     */\n    boolean isRealm(String str) {\n        try {\n            Realm r = new Realm(str);\n        }\n        catch (Exception e) {\n            return false;\n        }\n        StringTokenizer st = new StringTokenizer(str, \".\");\n        String s;\n        while (st.hasMoreTokens()) {\n            s = st.nextToken();\n            for (int i = 0; i < s.length(); i++) {\n                if (s.charAt(i) >= 141) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    EncryptionKey readKey(int version) throws IOException {\n        int keyType, keyLen;\n        keyType = read(2);\n        if (version == KRB5_FCC_FVNO_3)\n            read(2); /* keytype recorded twice in fvno 3 */\n        keyLen = readLength4();\n        byte[] bytes = IOUtils.readFully(this, keyLen, true);\n        return new EncryptionKey(bytes, keyType, version);\n    }\n    long[] readTimes() throws IOException {\n        long[] times = new long[4];\n        times[0] = (long)read(4) * 1000;\n        times[1] = (long)read(4) * 1000;\n        times[2] = (long)read(4) * 1000;\n        times[3] = (long)read(4) * 1000;\n        return times;\n    }\n    boolean readskey() throws IOException {\n        if (read() == 0) {\n            return false;\n        }\n        else return true;\n    }\n<fim_suffix>    HostAddress[] readAddr() throws IOException, KrbApErrException {\n        int numAddrs, addrType, addrLength;\n        numAddrs = readLength4();\n        if (numAddrs > 0) {\n            List<HostAddress> addrs = new ArrayList<>();\n            for (int i = 0; i < numAddrs; i++) {\n                addrType = read(2);\n                addrLength = readLength4();\n                if (!(addrLength == 4 || addrLength == 16)) {\n                    if (DEBUG) {\n                        System.out.println(\"Incorrect address format.\");\n                    }\n                    return null;\n                }\n                byte[] result = new byte[addrLength];\n                for (int j = 0; j < addrLength; j++)\n                    result[j] = (byte)read(1);\n                addrs.add(new HostAddress(addrType, result));\n            }\n            return addrs.toArray(new HostAddress[addrs.size()]);\n        }\n        return null;\n    }\n    AuthorizationDataEntry[] readAuth() throws IOException {\n        int num, adtype, adlength;\n        num = readLength4();\n        if (num > 0) {\n            List<AuthorizationDataEntry> auData = new ArrayList<>();\n            byte[] data = null;\n            for (int i = 0; i < num; i++) {\n                adtype = read(2);\n                adlength = readLength4();\n                data = IOUtils.readFully(this, adlength, true);<fim_middle>// function below has no smell\n"}