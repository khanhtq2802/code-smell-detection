{"text": "<fim_prefix>    }\n    @Override\n    Iterable<DocFile> list(Location location, DocPath path) {\n        Location l = ((location == StandardLocation.SOURCE_PATH)\n                && !fileManager.hasLocation(StandardLocation.SOURCE_PATH))\n                ? StandardLocation.CLASS_PATH\n                : location;\n        Set<DocFile> files = new LinkedHashSet<>();\n        for (Path f: fileManager.getLocationAsPaths(l)) {\n            if (Files.isDirectory(f)) {\n                f = f.resolve(path.getPath());\n                if (Files.exists(f))\n                    files.add(new StandardDocFile(f));\n            }\n        }\n        return files;\n    }\n    private static Path newFile(Path dir, String path) {\n        return (dir == null) ? Paths.get(path) : dir.resolve(path);\n    }\n<fim_suffix>    class StandardDocFile extends DocFile {\n        private final Path file;\n        /** Create a StandardDocFile for a given file. */\n        private StandardDocFile(Path file) {\n            this.file = file;\n        }\n        /** Create a StandardDocFile for a given location and relative path. */\n        private StandardDocFile(Location location, DocPath path) {\n            super(location, path);\n            Assert.check(location == DocumentationTool.Location.DOCUMENTATION_OUTPUT);\n            this.file = newFile(getDestDir(), path.getPath());\n        }\n        @Override\n        public FileObject getFileObject()  {\n            return getJavaFileObjectForInput(file);\n        }\n        /**\n         * Open an input stream for the file.\n         *\n         * @throws DocFileIOException if there is a problem while opening stream\n         */\n        @Override\n        public InputStream openInputStream() throws DocFileIOException {\n            try {\n                JavaFileObject fo = getJavaFileObjectForInput(file);\n                return new BufferedInputStream(fo.openInputStream());\n            } catch (IOException e) {\n                throw new DocFileIOException(this, DocFileIOException.Mode.READ, e);\n            }\n        }\n        /**\n         * Open an output stream for the file.\n         * The file must have been created with a location of\n         * {@link DocumentationTool.Location#DOCUMENTATION_OUTPUT} and a corresponding relative path.\n         *\n         * @throws DocFileIOException if there is a problem while opening stream\n         */\n        @Override\n        public OutputStream openOutputStream() throws DocFileIOException {\n            if (location != DocumentationTool.Location.DOCUMENTATION_OUTPUT)\n                throw new IllegalStateException();\n            try {\n                OutputStream out = getFileObjectForOutput(path).openOutputStream();\n                return new BufferedOutputStream(out);\n            } catch (IOException e) {\n                throw new DocFileIOException(this, DocFileIOException.Mode.WRITE, e);\n            }\n        }\n        /**\n         * Open an writer for the file, using the encoding (if any) given in the\n         * doclet configuration.\n         * The file must have been created with a location of\n         * {@link DocumentationTool.Location#DOCUMENTATION_OUTPUT} and a corresponding relative path.\n         *\n         * @throws DocFileIOException if there is a problem while opening stream\n         * @throws UnsupportedEncodingException if the configured encoding is not supported\n         */\n        @Override\n        public Writer openWriter() throws DocFileIOException, UnsupportedEncodingException {\n            if (location != DocumentationTool.Location.DOCUMENTATION_OUTPUT)\n                throw new IllegalStateException();\n            try {\n                OutputStream out = getFileObjectForOutput(path).openOutputStream();\n                return new BufferedWriter(new OutputStreamWriter(out, configuration.docencoding));\n            } catch (IOException e) {\n                throw new DocFileIOException(this, DocFileIOException.Mode.WRITE, e);\n            }\n        }\n        /** Return true if the file can be read. */\n        @Override\n        public boolean canRead() {\n            return Files.isReadable(file);\n        }\n        /** Return true if the file can be written. */\n        @Override\n        public boolean canWrite() {\n            return Files.isWritable(file);\n        }\n        /** Return true if the file exists. */\n        @Override\n        public boolean exists() {\n            return Files.exists(file);\n        }\n        /** Return the base name (last component) of the file name. */\n        @Override\n        public String getName() {\n            return file.getFileName().toString();\n        }\n        /** Return the file system path for this file. */\n        @Override\n        public String getPath() {\n            return file.toString();\n        }\n        /** Return true is file has an absolute path name. */\n        @Override\n        public boolean isAbsolute() {\n            return file.isAbsolute();\n        }\n        /** Return true is file identifies a directory. */\n        @Override\n        public boolean isDirectory() {\n            return Files.isDirectory(file);\n        }\n        /** Return true is file identifies a file. */\n        @Override\n        public boolean isFile() {\n            return Files.isRegularFile(file);\n        }\n        /** Return true if this file is the same as another. */\n        @Override\n        public boolean isSameFile(DocFile other) {\n            if (!(other instanceof StandardDocFile))\n                return false;\n            try {\n                return Files.isSameFile(file, ((StandardDocFile) other).file);\n            } catch (IOException e) {\n                return false;\n            }\n        }\n        /** If the file is a directory, list its contents. */\n        @Override\n        public Iterable<DocFile> list() throws DocFileIOException {\n            List<DocFile> files = new ArrayList<>();\n            try (DirectoryStream<Path> ds = Files.newDirectoryStream(file)) {\n                for (Path f: ds) {\n                    files.add(new StandardDocFile(f));\n                }\n            } catch (IOException e) {\n                throw new DocFileIOException(this, DocFileIOException.Mode.READ, e);\n            }\n            return files;\n        }\n        /** Create the file as a directory, including any parent directories. */\n        @Override\n        public boolean mkdirs() {\n            try {\n                Files.createDirectories(file);\n                return true;\n            } catch (IOException e) {\n                return false;\n            }\n        }\n        /**\n         * Derive a new file by resolving a relative path against this file.\n         * The new file will inherit the configuration and location of this file\n         * If this file has a path set, the new file will have a corresponding\n         * new path.\n         */\n        @Override\n        public DocFile resolve(DocPath p) {\n            return resolve(p.getPath());\n        }\n        /**\n         * Derive a new file by resolving a relative path against this file.\n         * The new file will inherit the configuration and location of this file\n         * If this file has a path set, the new file will have a corresponding\n         * new path.\n         */\n        @Override\n        public DocFile resolve(String p) {\n            if (location == null && path == null) {\n                return new StandardDocFile(file.resolve(p));\n            } else {\n                return new StandardDocFile(location, path.resolve(p));\n            }\n        }\n        /**\n         * Resolve a relative file against the given output location.\n         * @param locn Currently, only\n         * {@link DocumentationTool.Location.DOCUMENTATION_OUTPUT} is supported.\n         */\n        @Override\n        public DocFile resolveAgainst(Location locn) {\n            if (locn != DocumentationTool.Location.DOCUMENTATION_OUTPUT)\n                throw new IllegalArgumentException();\n            return new StandardDocFile(getDestDir().resolve(file));\n        }\n        /** Return a string to identify the contents of this object,\n         * for debugging purposes.\n         */\n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder();\n            sb.append(\"StandardDocFile[\");\n            if (location != null)\n                sb.append(\"locn:\").append(location).append(\",\");\n            if (path != null)\n                sb.append(\"path:\").append(path.getPath()).append(\",\");\n            sb.append(\"file:\").append(file);\n            sb.append(\"]\");\n            return sb.toString();\n        }\n        private JavaFileObject getJavaFileObjectForInput(Path file) {\n            return fileManager.getJavaFileObjects(file).iterator().next();\n        }\n        private FileObject getFileObjectForOutput(DocPath path) throws IOException {\n            // break the path into a package-part and the rest, by finding\n            // the position of the last '/' before an invalid character for a\n            // package name, such as the \".\" before an extension or the \"-\"\n            // in filenames like package-summary.html, doc-files or src-html.\n            String p = path.getPath();\n            int lastSep = -1;\n            for (int i = 0; i < p.length(); i++) {\n                char ch = p.charAt(i);\n                if (ch == '/') {\n                    lastSep = i;\n                } else if (i == lastSep + 1 && !Character.isJavaIdentifierStart(ch)\n                        || !Character.isJavaIdentifierPart(ch)) {\n                    break;\n                }\n            }\n            String pkg = (lastSep == -1) ? \"\" : p.substring(0, lastSep);\n            String rest = p.substring(lastSep + 1);\n            return fileManager.getFileForOutput(location, pkg, rest, null);\n        }\n    }<fim_middle>// class below has no smell\n"}