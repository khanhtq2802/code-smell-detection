{"text": "<fim_prefix>package org.eclipse.aether.internal.impl;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n * \n *  http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport java.util.Calendar;\n\nimport javax.inject.Named;\n\nimport org.eclipse.aether.RepositorySystemSession;\nimport org.eclipse.aether.impl.UpdatePolicyAnalyzer;\nimport org.eclipse.aether.repository.RepositoryPolicy;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n */\n<fim_suffix>@Named\npublic class DefaultUpdatePolicyAnalyzer\n    implements UpdatePolicyAnalyzer\n{\n\n    private static final Logger LOGGER = LoggerFactory.getLogger( DefaultUpdatePolicyAnalyzer.class );\n\n    public DefaultUpdatePolicyAnalyzer()\n    {\n        // enables default constructor\n    }\n\n    public String getEffectiveUpdatePolicy( RepositorySystemSession session, String policy1, String policy2 )\n    {\n        return ordinalOfUpdatePolicy( policy1 ) < ordinalOfUpdatePolicy( policy2 ) ? policy1 : policy2;\n    }\n\n    private int ordinalOfUpdatePolicy( String policy )\n    {\n        if ( RepositoryPolicy.UPDATE_POLICY_DAILY.equals( policy ) )\n        {\n            return 1440;\n        }\n        else if ( RepositoryPolicy.UPDATE_POLICY_ALWAYS.equals( policy ) )\n        {\n            return 0;\n        }\n        else if ( policy != null && policy.startsWith( RepositoryPolicy.UPDATE_POLICY_INTERVAL ) )\n        {\n            return getMinutes( policy );\n        }\n        else\n        {\n            // assume \"never\"\n            return Integer.MAX_VALUE;\n        }\n    }\n\n    public boolean isUpdatedRequired( RepositorySystemSession session, long lastModified, String policy )\n    {\n        boolean checkForUpdates;\n\n        if ( policy == null )\n        {\n            policy = \"\";\n        }\n\n        if ( RepositoryPolicy.UPDATE_POLICY_ALWAYS.equals( policy ) )\n        {\n            checkForUpdates = true;\n        }\n        else if ( RepositoryPolicy.UPDATE_POLICY_DAILY.equals( policy ) )\n        {\n            Calendar cal = Calendar.getInstance();\n            cal.set( Calendar.HOUR_OF_DAY, 0 );\n            cal.set( Calendar.MINUTE, 0 );\n            cal.set( Calendar.SECOND, 0 );\n            cal.set( Calendar.MILLISECOND, 0 );\n\n            checkForUpdates = cal.getTimeInMillis() > lastModified;\n        }\n        else if ( policy.startsWith( RepositoryPolicy.UPDATE_POLICY_INTERVAL ) )\n        {\n            int minutes = getMinutes( policy );\n\n            Calendar cal = Calendar.getInstance();\n            cal.add( Calendar.MINUTE, -minutes );\n\n            checkForUpdates = cal.getTimeInMillis() > lastModified;\n        }\n        else\n        {\n            // assume \"never\"\n            checkForUpdates = false;\n\n            if ( !RepositoryPolicy.UPDATE_POLICY_NEVER.equals( policy ) )\n            {\n                LOGGER.warn( \"Unknown repository update policy '{}', assuming '{}'\",\n                        policy, RepositoryPolicy.UPDATE_POLICY_NEVER );\n            }\n        }\n\n        return checkForUpdates;\n    }\n\n    private int getMinutes( String policy )\n    {\n        int minutes;\n        try\n        {\n            String s = policy.substring( RepositoryPolicy.UPDATE_POLICY_INTERVAL.length() + 1 );\n            minutes = Integer.valueOf( s );\n        }\n        catch ( RuntimeException e )\n        {\n            minutes = 24 * 60;\n\n            LOGGER.warn( \"Non-parseable repository update policy '{}', assuming '{}:1440'\",\n                    policy, RepositoryPolicy.UPDATE_POLICY_INTERVAL );\n        }\n        return minutes;\n    }\n\n}<fim_middle>// class below has no smell\n"}