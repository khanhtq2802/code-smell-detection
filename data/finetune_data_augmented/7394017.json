{"text": "<fim_prefix>import org.graalvm.nativeimage.c.type.WordPointer;\nimport org.graalvm.word.Pointer;\nimport org.graalvm.word.PointerBase;\nimport org.graalvm.word.UnsignedWord;\nimport org.graalvm.word.WordFactory;\nimport com.oracle.svm.core.Isolates;\nimport com.oracle.svm.core.SubstrateOptions;\nimport com.oracle.svm.core.annotate.AutomaticFeature;\nimport com.oracle.svm.core.annotate.Uninterruptible;\nimport com.oracle.svm.core.c.function.CEntryPointCreateIsolateParameters;\nimport com.oracle.svm.core.c.function.CEntryPointErrors;\nimport com.oracle.svm.core.c.function.CEntryPointSetup;\nimport com.oracle.svm.core.code.CodeInfoTable;\nimport com.oracle.svm.core.heap.Heap;\nimport com.oracle.svm.core.log.Log;\nimport com.oracle.svm.core.os.VirtualMemoryProvider.Access;\nimport com.oracle.svm.core.util.PointerUtils;\nimport com.oracle.svm.core.util.UnsignedUtils;\n@AutomaticFeature\nclass OSCommittedMemoryProviderFeature implements Feature {\n    @Override\n    public void beforeAnalysis(BeforeAnalysisAccess access) {\n        if (!ImageSingletons.contains(CommittedMemoryProvider.class)) {\n            ImageSingletons.add(CommittedMemoryProvider.class, new OSCommittedMemoryProvider());\n        }\n    }\n}\npublic class OSCommittedMemoryProvider implements CommittedMemoryProvider {\n    @Override\n    @Uninterruptible(reason = \"Still being initialized.\")\n    public int initialize(WordPointer isolatePointer, CEntryPointCreateIsolateParameters parameters) {\n        if (!SubstrateOptions.SpawnIsolates.getValue()) {\n            isolatePointer.write(CEntryPointSetup.SINGLE_ISOLATE_SENTINEL);\n            return CEntryPointErrors.NO_ERROR;\n        }\n        return ImageHeapProvider.get().initialize(nullPointer(), zero(), isolatePointer, nullPointer());\n    }\n    @Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    protected static void tearDownVirtualMemoryConsumers() {\n        CodeInfoTable.getRuntimeCodeCache().tearDown();\n        Heap.getHeap().tearDown();\n    }\n    @Override\n    @Uninterruptible(reason = \"Tear-down in progress.\")\n    public int tearDown() {\n        if (!SubstrateOptions.SpawnIsolates.getValue()) {\n            return CEntryPointErrors.NO_ERROR;\n        }\n        tearDownVirtualMemoryConsumers();\n        PointerBase heapBase = Isolates.getHeapBase(CurrentIsolate.getIsolate());\n        return ImageHeapProvider.get().tearDown(heapBase);\n    }\n    /**\n     * Allocate the requested amount of virtual memory at the requested alignment.\n     *\n     * @return A Pointer to the aligned memory, or a null Pointer.\n     */\n    @Override\n    public Pointer allocate(UnsignedWord size, UnsignedWord alignment, boolean executable) {\n        final int access = Access.READ | Access.WRITE | (executable ? Access.EXECUTE : 0);\n        if (alignment.equal(UNALIGNED)) {\n            Pointer start = VirtualMemoryProvider.get().commit(nullPointer(), size, access);\n            if (start.isNonNull()) {\n                trackVirtualMemory(size);\n            }\n            return start;\n        }\n        // This happens in stages:\n        // (1) Reserve a container that is large enough for the requested size *and* the alignment.\n        // (2) Locate the result at the requested alignment within the container.\n        // (3) Clean up any over-allocated prefix and suffix pages.\n        // All communication with mmap and munmap happen in terms of page_sized objects.\n        final UnsignedWord pageSize = getGranularity();\n        // (1) Reserve a container that is large enough for the requested size *and* the alignment.\n        // - The container occupies the open-right interval [containerStart .. containerEnd).\n        // - This will be too big, but I'll give back the extra later.\n        final UnsignedWord containerSize = alignment.add(size);\n        final UnsignedWord pagedContainerSize = UnsignedUtils.roundUp(containerSize, pageSize);\n        final Pointer containerStart = VirtualMemoryProvider.get().commit(nullPointer(), pagedContainerSize, access);\n        if (containerStart.isNull()) {\n            // No exception is needed: this is just a failure to reserve the virtual address space.\n            return nullPointer();\n        }\n        trackVirtualMemory(pagedContainerSize);\n        final Pointer containerEnd = containerStart.add(pagedContainerSize);\n        // (2) Locate the result at the requested alignment within the container.\n        // - The result occupies [start .. end).\n        final Pointer start = PointerUtils.roundUp(containerStart, alignment);\n        final Pointer end = start.add(size);\n        if (virtualMemoryVerboseDebugging) {\n            Log.log().string(\"allocate(size: \").unsigned(size).string(\" \").hex(size).string(\", alignment: \").unsigned(alignment).string(\" \").hex(alignment).string(\")\").newline();\n            Log.log().string(\"  container:   [\").hex(containerStart).string(\" .. \").hex(containerEnd).string(\")\").newline();\n            Log.log().string(\"  result:      [\").hex(start).string(\" .. \").hex(end).string(\")\").newline();\n        }\n        // (3) Clean up any over-allocated prefix and suffix pages.\n        // - The prefix occupies [containerStart .. pagedStart).\n        final Pointer pagedStart = PointerUtils.roundDown(start, pageSize);\n        final Pointer prefixStart = containerStart;\n        final Pointer prefixEnd = pagedStart;\n        final UnsignedWord prefixSize = prefixEnd.subtract(prefixStart);\n        if (prefixSize.aboveOrEqual(pageSize)) {\n            if (virtualMemoryVerboseDebugging) {\n                Log.log().string(\"  prefix:      [\").hex(prefixStart).string(\" .. \").hex(prefixEnd).string(\")\").newline();\n            }\n            if (!free(prefixStart, prefixSize)) {\n                free(containerStart, pagedContainerSize);\n                return nullPointer();\n            }\n        }\n        // - The suffix occupies [pagedEnd .. containerEnd).\n        final Pointer pagedEnd = PointerUtils.roundUp(end, pageSize);\n        final Pointer suffixStart = pagedEnd;\n        final Pointer suffixEnd = containerEnd;\n        final UnsignedWord suffixSize = suffixEnd.subtract(suffixStart);\n        if (suffixSize.aboveOrEqual(pageSize)) {\n            if (virtualMemoryVerboseDebugging) {\n                Log.log().string(\"  suffix:      [\").hex(suffixStart).string(\" .. \").hex(suffixEnd).string(\")\").newline();\n            }\n            if (!free(suffixStart, suffixSize)) {\n                free(pagedStart, containerEnd.subtract(pagedStart));\n                return nullPointer();\n            }\n        }\n        return start;\n    }\n    @Override\n    @Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    public boolean free(PointerBase start, UnsignedWord nbytes, UnsignedWord alignment, boolean executable) {\n        final UnsignedWord pageSize = getGranularity();\n        // Re-discover the paged-aligned ends of the memory region.\n        final Pointer end = ((Pointer) start).add(nbytes);\n        final Pointer pagedStart = PointerUtils.roundDown(start, pageSize);\n        final Pointer pagedEnd = PointerUtils.roundUp(end, pageSize);\n        final UnsignedWord pagedSize = pagedEnd.subtract(pagedStart);\n        // Return that virtual address space to the operating system.\n        return free(pagedStart, pagedSize);\n    }\n    @Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    private boolean free(Pointer start, UnsignedWord size) {\n        boolean success = (VirtualMemoryProvider.get().free(start, size) == 0);\n        if (success) {\n            untrackVirtualMemory(size);\n        }\n        return success;\n    }\n    private void trackVirtualMemory(UnsignedWord size) {\n        tracker.track(size);\n    }\n    @Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n    private void untrackVirtualMemory(UnsignedWord size) {\n        tracker.untrack(size);\n    }\n    // Verbose debugging.\n    private static final boolean virtualMemoryVerboseDebugging = false;\n    private final VirtualMemoryTracker tracker = new VirtualMemoryTracker();\n<fim_suffix>    protected static class VirtualMemoryTracker {\n        private UnsignedWord totalAllocated;\n        protected VirtualMemoryTracker() {\n            this.totalAllocated = WordFactory.zero();\n        }\n        public void track(UnsignedWord size) {\n            totalAllocated = totalAllocated.add(size);\n        }\n        @Uninterruptible(reason = \"Called from uninterruptible code.\", mayBeInlined = true)\n        public void untrack(UnsignedWord size) {\n            totalAllocated = totalAllocated.subtract(size);\n        }\n    }<fim_middle>// class below has no smell\n"}