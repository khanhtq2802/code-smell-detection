{"text": "<fim_prefix>import static org.apache.hadoop.hdfs.server.namenode.FSImageFormatPBINode.XATTR_NAMESPACE_EXT_MASK;\nimport static org.apache.hadoop.hdfs.tools.offlineImageViewer.PBImageXmlWriter.*;\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.nio.ByteBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.security.DigestOutputStream;\nimport java.security.MessageDigest;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport com.google.common.io.CountingOutputStream;\nimport com.google.common.primitives.Ints;\nimport com.google.protobuf.ByteString;\nimport com.google.protobuf.TextFormat;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.apache.hadoop.classification.InterfaceAudience;\nimport org.apache.hadoop.classification.InterfaceStability;\nimport org.apache.hadoop.fs.permission.AclEntry;\nimport org.apache.hadoop.fs.permission.FsPermission;\nimport org.apache.hadoop.hdfs.protocol.proto.HdfsProtos;\nimport org.apache.hadoop.hdfs.protocol.proto.HdfsProtos.ECSchemaProto;\nimport org.apache.hadoop.hdfs.protocol.proto.HdfsProtos.ErasureCodingPolicyProto;\nimport org.apache.hadoop.hdfs.protocol.proto.ClientNamenodeProtocolProtos.CacheDirectiveInfoExpirationProto;\nimport org.apache.hadoop.hdfs.protocol.proto.ClientNamenodeProtocolProtos.CacheDirectiveInfoProto;\nimport org.apache.hadoop.hdfs.protocol.proto.ClientNamenodeProtocolProtos.CachePoolInfoProto;\nimport org.apache.hadoop.hdfs.protocol.proto.XAttrProtos;\nimport org.apache.hadoop.hdfs.server.namenode.FSImageFormatProtobuf.SectionName;\nimport org.apache.hadoop.hdfs.server.namenode.FSImageUtil;\nimport org.apache.hadoop.hdfs.server.namenode.FsImageProto;\nimport org.apache.hadoop.hdfs.server.namenode.FsImageProto.CacheManagerSection;\nimport org.apache.hadoop.hdfs.server.namenode.FsImageProto.ErasureCodingSection;\nimport org.apache.hadoop.hdfs.server.namenode.FsImageProto.FileSummary;\nimport org.apache.hadoop.hdfs.server.namenode.FsImageProto.FilesUnderConstructionSection.FileUnderConstructionEntry;\nimport org.apache.hadoop.hdfs.server.namenode.FsImageProto.INodeSection;\nimport org.apache.hadoop.hdfs.server.namenode.FsImageProto.INodeSection.AclFeatureProto;\nimport org.apache.hadoop.hdfs.server.namenode.FsImageProto.NameSystemSection;\nimport org.apache.hadoop.hdfs.server.namenode.FsImageProto.SecretManagerSection;\nimport org.apache.hadoop.hdfs.server.namenode.FsImageProto.SnapshotDiffSection.DiffEntry;\nimport org.apache.hadoop.hdfs.server.namenode.NameNodeLayoutVersion;\nimport org.apache.hadoop.hdfs.util.MD5FileUtils;\nimport org.apache.hadoop.hdfs.util.XMLUtils;\nimport org.apache.hadoop.io.IOUtils;\nimport org.apache.hadoop.io.MD5Hash;\nimport org.apache.hadoop.util.StringUtils;\nimport javax.xml.bind.annotation.adapters.HexBinaryAdapter;\nimport javax.xml.stream.XMLEventReader;\nimport javax.xml.stream.XMLInputFactory;\nimport javax.xml.stream.XMLStreamConstants;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.stream.events.XMLEvent;\n@InterfaceAudience.Private\n@InterfaceStability.Unstable\nclass OfflineImageReconstructor {\n  public static final Logger LOG =\n      LoggerFactory.getLogger(OfflineImageReconstructor.class);\n  /**\n   * The output stream.\n   */\n  private final CountingOutputStream out;\n  /**\n   * A source of XML events based on the input file.\n   */\n  private final XMLEventReader events;\n  /**\n   * A map of section names to section handler objects.\n   */\n  private final HashMap<String, SectionProcessor> sections;\n  /**\n   * The offset of the start of the current section.\n   */\n  private long sectionStartOffset;\n  /**\n   * The FileSummary builder, where we gather information about each section\n   * we wrote.\n   */\n  private final FileSummary.Builder fileSummaryBld =\n      FileSummary.newBuilder();\n  /**\n   * The string table.  See registerStringId for details.\n   */\n  private final HashMap<String, Integer> stringTable = new HashMap<>();\n  /**\n   * The date formatter to use with fsimage XML files.\n   */\n  private final SimpleDateFormat isoDateFormat;\n  /**\n   * The latest string ID.  See registerStringId for details.\n   */\n  private int latestStringId = 0;\n  private static final String EMPTY_STRING = \"\";\n  private OfflineImageReconstructor(CountingOutputStream out,\n      InputStreamReader reader) throws XMLStreamException {\n    this.out = out;\n    XMLInputFactory factory = XMLInputFactory.newInstance();\n    this.events = factory.createXMLEventReader(reader);\n    this.sections = new HashMap<>();\n    this.sections.put(NameSectionProcessor.NAME, new NameSectionProcessor());\n    this.sections.put(ErasureCodingSectionProcessor.NAME,\n        new ErasureCodingSectionProcessor());\n    this.sections.put(INodeSectionProcessor.NAME, new INodeSectionProcessor());\n    this.sections.put(SecretManagerSectionProcessor.NAME,\n        new SecretManagerSectionProcessor());\n    this.sections.put(CacheManagerSectionProcessor.NAME,\n        new CacheManagerSectionProcessor());\n    this.sections.put(SnapshotDiffSectionProcessor.NAME,\n        new SnapshotDiffSectionProcessor());\n    this.sections.put(INodeReferenceSectionProcessor.NAME,\n        new INodeReferenceSectionProcessor());\n    this.sections.put(INodeDirectorySectionProcessor.NAME,\n        new INodeDirectorySectionProcessor());\n    this.sections.put(FilesUnderConstructionSectionProcessor.NAME,\n        new FilesUnderConstructionSectionProcessor());\n    this.sections.put(SnapshotSectionProcessor.NAME,\n        new SnapshotSectionProcessor());\n    this.isoDateFormat = PBImageXmlWriter.createSimpleDateFormat();\n  }\n  /**\n   * Read the next tag start or end event.\n   *\n   * @param expected     The name of the next tag we expect.\n   *                     We will validate that the tag has this name,\n   *                     unless this string is enclosed in braces.\n   * @param allowEnd     If true, we will also end events.\n   *                     If false, end events cause an exception.\n   *\n   * @return             The next tag start or end event.\n   */\n<fim_suffix>  private XMLEvent expectTag(String expected, boolean allowEnd)\n      throws IOException {\n    XMLEvent ev = null;\n    while (true) {\n      try {\n        ev = events.nextEvent();\n      } catch (XMLStreamException e) {\n        throw new IOException(\"Expecting \" + expected +\n            \", but got XMLStreamException\", e);\n      }\n      switch (ev.getEventType()) {\n      case XMLEvent.ATTRIBUTE:\n        throw new IOException(\"Got unexpected attribute: \" + ev);\n      case XMLEvent.CHARACTERS:\n        if (!ev.asCharacters().isWhiteSpace()) {\n          throw new IOException(\"Got unxpected characters while \" +\n              \"looking for \" + expected + \": \" +\n              ev.asCharacters().getData());\n        }\n        break;\n      case XMLEvent.END_ELEMENT:\n        if (!allowEnd) {\n          throw new IOException(\"Got unexpected end event \" +\n              \"while looking for \" + expected);\n        }\n        return ev;\n      case XMLEvent.START_ELEMENT:\n        if (!expected.startsWith(\"[\")) {\n          if (!ev.asStartElement().getName().getLocalPart().\n                equals(expected)) {\n            throw new IOException(\"Failed to find <\" + expected + \">; \" +\n                \"got \" + ev.asStartElement().getName().getLocalPart() +\n                \" instead.\");\n          }\n        }\n        return ev;\n      default:\n        // Ignore other event types like comment, etc.\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(\"Skipping XMLEvent of type \" +\n              ev.getEventType() + \"(\" +  ev + \")\");\n        }\n        break;\n      }\n    }\n  }<fim_middle>// function below is feature envy and long method\n"}