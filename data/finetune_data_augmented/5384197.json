{"text": "<fim_prefix>        }\n    }\n    private boolean needCombiner(List<MapReduceOper> mapReducers) {\n        boolean needCombiner = false;\n        for (MapReduceOper mrOp : mapReducers) {\n            if (!mrOp.combinePlan.isEmpty()) {\n                needCombiner = true;\n                break;\n            }\n        }\n        return needCombiner;\n    }\n    private PhysicalPlan createDemuxPlan(boolean sameKeyType, boolean isCombiner)\n        throws VisitorException {\n        PODemux demux = getDemux(isCombiner);\n        POPackage pkg = getMultiQueryPackage(sameKeyType, isCombiner);\n        PhysicalPlan pl = new PhysicalPlan();\n        pl.add(pkg);\n        try {\n            pl.addAsLeaf(demux);\n        } catch (PlanException e) {\n            int errCode = 2137;\n            String msg = \"Internal Error. Unable to add demux to the plan as leaf for optimization.\";\n            throw new OptimizerException(msg, errCode, PigException.BUG, e);\n        }\n        return pl;\n    }\n    private void mergeAllMapReduceSplittees(List<MapReduceOper> mergeList,\n            MapReduceOper splitter, POSplit splitOp) throws VisitorException {\n        boolean sameKeyType = hasSameMapKeyType(mergeList);\n        log.debug(\"Splittees have the same key type: \" + sameKeyType);\n        // create a new reduce plan that will be the container\n        // for the multiple reducer plans of the MROpers in the mergeList\n        PhysicalPlan redPl = createDemuxPlan(sameKeyType, false);\n        // create a new combine plan that will be the container\n        // for the multiple combiner plans of the MROpers in the mergeList\n        PhysicalPlan comPl = needCombiner(mergeList) ?\n                createDemuxPlan(sameKeyType, true) : null;\n        log.debug(\"Splittees have combiner: \" + (comPl != null));\n        int index = 0;\n        for (MapReduceOper mrOp : mergeList) {\n            // merge the map plan - this will recursively\n            // set index on all POLocalRearranges encountered\n            // including ones in inner plans of any POSplit\n            // operators. Hence the index returned could be\n            // > index + 1\n            int incIndex = mergeOneMapPlanWithIndex(\n                    mrOp.mapPlan, splitOp, index, sameKeyType);\n            // merge the combiner plan\n            if (comPl != null) {\n                if (!mrOp.combinePlan.isEmpty()) {\n                    mergeOneCombinePlanWithIndex(\n                            mrOp.combinePlan, comPl, index, incIndex, mrOp.mapKeyType);\n                } else {\n                    int errCode = 2141;\n                    String msg = \"Internal Error. Cannot merge non-combiner with combiners for optimization.\";\n                    throw new OptimizerException(msg, errCode, PigException.BUG);\n                }\n            }\n            // merge the reducer plan\n            mergeOneReducePlanWithIndex(\n                    mrOp.reducePlan, redPl, index, incIndex, mrOp.mapKeyType);\n            index = incIndex;\n            log.info(\"Merged MR job \" + mrOp.getOperatorKey().getId()\n                    + \" into MR job \" + splitter.getOperatorKey().getId());\n        }\n        PhysicalPlan splitterPl = splitter.mapPlan;\n        PhysicalOperator leaf = splitterPl.getLeaves().get(0);\n        PhysicalOperator storeOp = splitterPl.getLeaves().get(0);\n        List<PhysicalOperator> storePreds = splitterPl.getPredecessors(storeOp);\n        // replace store operator in the splitter with split operator\n        if (leaf instanceof POStore) {\n            splitOp.setInputs(storePreds);\n            try {\n                splitterPl.replace(storeOp, splitOp);;\n            } catch (PlanException e) {\n                int errCode = 2132;\n                String msg = \"Internal Error. Unable to replace store with split operator for optimization.\";\n                throw new OptimizerException(msg, errCode, PigException.BUG, e);\n            }\n        }\n        splitter.setMapDone(true);\n        splitter.reducePlan = redPl;\n        splitter.setReduceDone(true);\n        if (comPl != null) {\n            splitter.combinePlan = comPl;\n        }\n        for (MapReduceOper mrOp : mergeList) {\n            removeAndReconnect(mrOp, splitter);\n        }\n        splitter.mapKeyType = sameKeyType ?\n                mergeList.get(0).mapKeyType : DataType.TUPLE;\n        setMapKeyTypeForSplitter(splitter,mergeList);\n        log.info(\"Requested parallelism of splitter: \"\n                + splitter.getRequestedParallelism());\n    }\n    private void setMapKeyTypeForSplitter(MapReduceOper splitter, List<MapReduceOper> mergeList) {\n        splitter.mapKeyTypeOfSplittees = new byte[mergeList.size()];\n        for (int i = 0; i < mergeList.size(); i++) {\n            splitter.mapKeyTypeOfSplittees[i] = mergeList.get(i).mapKeyType;\n        }\n    }\n    private void mergeSingleMapReduceSplittee(MapReduceOper mapReduce,\n            MapReduceOper splitter, POSplit splitOp) throws VisitorException {\n        PhysicalPlan splitterPl = splitter.mapPlan;\n        PhysicalOperator leaf = splitterPl.getLeaves().get(0);\n        PhysicalOperator storeOp = splitterPl.getLeaves().get(0);\n        List<PhysicalOperator> storePreds = splitterPl.getPredecessors(storeOp);\n        PhysicalPlan pl = mapReduce.mapPlan;\n        PhysicalOperator load = pl.getRoots().get(0);\n        pl.remove(load);\n        splitOp.addPlan(pl);\n        splitter.setMapDone(true);\n        splitter.reducePlan = mapReduce.reducePlan;\n        splitter.setReduceDone(true);\n        splitter.combinePlan = mapReduce.combinePlan;\n        splitter.customPartitioner = mapReduce.customPartitioner;\n        // replace store operator in the splitter with split operator\n        if (leaf instanceof POStore) {\n            splitOp.setInputs(storePreds);\n            try {\n                splitterPl.replace(storeOp, splitOp);;\n            } catch (PlanException e) {\n                int errCode = 2132;\n                String msg = \"Internal Error. Unable to replace store with split operator for optimization.\";\n                throw new OptimizerException(msg, errCode, PigException.BUG, e);\n            }\n        }\n        removeAndReconnect(mapReduce, splitter);\n    }\n    /**\n     * Removes the specified MR operator from the plan after the merge.\n     * Connects its predecessors and successors to the merged MR operator\n     *\n     * @param mr the MR operator to remove\n     * @param newMR the MR operator to be connected to the predecessors and\n     *              the successors of the removed operator\n     * @throws VisitorException if connect operation fails\n     */\n<fim_suffix>    private void removeAndReconnect(MapReduceOper mr, MapReduceOper newMR) throws VisitorException {\n        List<MapReduceOper> mapperSuccs = getPlan().getSuccessors(mr);\n        List<MapReduceOper> mapperPreds = getPlan().getPredecessors(mr);\n        // make a copy before removing operator\n        ArrayList<MapReduceOper> succsCopy = null;\n        ArrayList<MapReduceOper> predsCopy = null;\n        if (mapperSuccs != null) {\n            succsCopy = new ArrayList<MapReduceOper>(mapperSuccs);\n        }\n        if (mapperPreds != null) {\n            predsCopy = new ArrayList<MapReduceOper>(mapperPreds);\n        }\n        getPlan().remove(mr);\n        // reconnect the mapper's successors\n        if (succsCopy != null) {\n            for (MapReduceOper succ : succsCopy) {\n                try {\n                    getPlan().connect(newMR, succ);\n                } catch (PlanException e) {\n                    int errCode = 2133;\n                    String msg = \"Internal Error. Unable to connect map plan with successors for optimization.\";\n                    throw new OptimizerException(msg, errCode, PigException.BUG, e);\n                }\n            }\n        }\n        // reconnect the mapper's predecessors\n        if (predsCopy != null) {\n            for (MapReduceOper pred : predsCopy) {\n                if (newMR.getOperatorKey().equals(pred.getOperatorKey())) {\n                    continue;\n                }\n                try {\n                    getPlan().connect(pred, newMR);\n                } catch (PlanException e) {\n                    int errCode = 2134;\n                    String msg = \"Internal Error. Unable to connect map plan with predecessors for optimization.\";\n                    throw new OptimizerException(msg, errCode, PigException.BUG, e);\n                }\n            }\n        }\n        mergeMROperProperties(mr, newMR);\n    }<fim_middle>// function below is long method\n"}