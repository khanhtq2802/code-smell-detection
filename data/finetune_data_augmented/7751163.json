{"text": "<fim_prefix> *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.brooklyn.core.mgmt.persist.jclouds;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport java.util.List;\nimport javax.annotation.Nullable;\nimport org.apache.brooklyn.api.mgmt.ManagementContext;\nimport org.apache.brooklyn.api.mgmt.ha.HighAvailabilityMode;\nimport org.apache.brooklyn.core.location.LocationConfigKeys;\nimport org.apache.brooklyn.core.location.cloud.CloudLocationConfig;\nimport org.apache.brooklyn.core.mgmt.persist.PersistMode;\nimport org.apache.brooklyn.core.mgmt.persist.PersistenceObjectStore;\nimport org.apache.brooklyn.core.server.BrooklynServerConfig;\nimport org.jclouds.blobstore.BlobStoreContext;\nimport org.jclouds.blobstore.domain.StorageMetadata;\nimport org.jclouds.blobstore.options.ListContainerOptions;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.apache.brooklyn.location.jclouds.JcloudsLocation;\nimport org.apache.brooklyn.location.jclouds.JcloudsUtil;\nimport org.apache.brooklyn.util.exceptions.FatalConfigurationRuntimeException;\nimport org.apache.brooklyn.util.text.Strings;\nimport com.google.common.base.Function;\nimport com.google.common.base.Objects;\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.FluentIterable;\n/**\n * @author Andrea Turli\n */\n<fim_suffix>public class JcloudsBlobStoreBasedObjectStore implements PersistenceObjectStore {\n    private static final Logger log = LoggerFactory.getLogger(JcloudsBlobStoreBasedObjectStore.class);\n    private final String containerNameFirstPart;\n    private final String containerSubPath;\n    private String locationSpec;\n    private JcloudsLocation location;\n    private BlobStoreContext context;\n    private ManagementContext mgmt;\n    public JcloudsBlobStoreBasedObjectStore(String locationSpec, String containerName) {\n        this.locationSpec = locationSpec;\n        String[] segments = splitOnce(containerName);\n        this.containerNameFirstPart = segments[0];\n        this.containerSubPath = segments[1];\n    }\n    private String[] splitOnce(String path) {\n        String separator = subPathSeparator();\n        int index = path.indexOf(separator);\n        if (index<0) return new String[] { path, \"\" };\n        return new String[] { path.substring(0, index), path.substring(index+separator.length()) };\n    }\n    public JcloudsBlobStoreBasedObjectStore(JcloudsLocation location, String containerName) {\n        this.location = location;\n        String[] segments = splitOnce(containerName);\n        this.containerNameFirstPart = segments[0];\n        this.containerSubPath = segments[1];\n        getBlobStoreContext();\n    }\n    public String getSummaryName() {\n        return (locationSpec!=null ? locationSpec : location)+\":\"+getContainerNameFull();\n    }\n    public synchronized BlobStoreContext getBlobStoreContext() {\n        if (context==null) {\n            if (location==null) {\n                Preconditions.checkNotNull(locationSpec, \"locationSpec required for remote object store when location is null\");\n                Preconditions.checkNotNull(mgmt, \"mgmt not injected / object store not prepared\");\n                location = (JcloudsLocation) mgmt.getLocationRegistry().resolve(locationSpec);\n            }\n            String identity = checkNotNull(location.getConfig(LocationConfigKeys.ACCESS_IDENTITY), \"identity must not be null\");\n            String credential = checkNotNull(location.getConfig(LocationConfigKeys.ACCESS_CREDENTIAL), \"credential must not be null\");\n            String provider = checkNotNull(location.getConfig(LocationConfigKeys.CLOUD_PROVIDER), \"provider must not be null\");\n            String endpoint = location.getConfig(CloudLocationConfig.CLOUD_ENDPOINT);\n            context = JcloudsUtil.newBlobstoreContext(provider, endpoint, identity, credential);\n            // TODO do we need to get location from region? can't see the jclouds API.\n            // doesn't matter in some places because it's already in the endpoint\n//            String region = location.getConfig(CloudLocationConfig.CLOUD_REGION_ID);\n            context.getBlobStore().createContainerInLocation(null, getContainerNameFirstPart());\n        }\n        return context;\n    }\n    @Override\n    public void prepareForMasterUse() {\n        // backups not supported here, that is all which is needed for master use\n        // that's now normally done *prior* to calling in to here for writes\n        // (and we have already thrown in prepareForSharedUse if legacy backups have been specified as required)\n    }\n    public String getContainerName() {\n        return getContainerNameFull();\n    }\n    protected String getContainerNameFull() {\n        return mergePaths(containerNameFirstPart, containerSubPath);\n    }\n    protected String getContainerNameFirstPart() {\n        return containerNameFirstPart;\n    }\n    protected String getItemInContainerSubPath(String path) {\n        if (Strings.isBlank(containerSubPath)) return path;\n        return mergePaths(containerSubPath, path);\n    }\n    @Override\n    public void createSubPath(String subPath) {\n        // not needed - subpaths are created on demant\n        // (and buggy on softlayer w swift w jclouds 1.7.2:\n        // throws a \"not found\" if we're creating an empty directory from scratch)\n//        context.getBlobStore().createDirectory(getContainerName(), subPath);\n    }\n    protected void checkPrepared() {\n        if (context==null)\n            throw new IllegalStateException(\"object store not prepared\");\n    }\n    @Override\n    public StoreObjectAccessor newAccessor(String path) {\n        checkPrepared();\n        return new JcloudsStoreObjectAccessor(context.getBlobStore(), getContainerNameFirstPart(), getItemInContainerSubPath(path));\n    }\n    protected String mergePaths(String basePath, String ...subPaths) {\n        StringBuilder result = new StringBuilder(basePath);\n        for (String subPath: subPaths) {\n            if (result.length()>0 && subPath.length()>0) {\n                result.append(subPathSeparator());\n                result.append(subPath);\n            }\n        }\n        return result.toString();\n    }\n    protected String subPathSeparator() {\n        // in case some object stores don't allow / for paths\n        return \"/\";\n    }\n    @Override\n    public List<String> listContentsWithSubPath(final String parentSubPath) {\n        checkPrepared();\n        return FluentIterable.from(context.getBlobStore().list(getContainerNameFirstPart(), \n            ListContainerOptions.Builder.inDirectory(getItemInContainerSubPath(parentSubPath))))\n                .transform(new Function<StorageMetadata, String>() {\n                    @Override\n                    public String apply(@javax.annotation.Nullable StorageMetadata input) {\n                        String result = input.getName();\n                        result = Strings.removeFromStart(result, containerSubPath);\n                        result = Strings.removeFromStart(result, \"/\");\n                        return result;\n                    }\n                }).toList();\n    }\n    @Override\n    public void close() {\n        if (context!=null)\n            context.close();\n    }\n    @Override\n    public String toString() {\n        return Objects.toStringHelper(this)\n                .add(\"blobStoreContext\", context)\n                .add(\"basedir\", containerNameFirstPart)\n                .toString();\n    }\n    @Override\n    public void injectManagementContext(ManagementContext mgmt) {\n        if (this.mgmt!=null && !this.mgmt.equals(mgmt))\n            throw new IllegalStateException(\"Cannot change mgmt context of \"+this);\n        this.mgmt = mgmt;\n    }\n    @SuppressWarnings(\"deprecation\")\n    @Override\n    public void prepareForSharedUse(@Nullable PersistMode persistMode, HighAvailabilityMode haMode) {\n        if (mgmt==null) throw new NullPointerException(\"Must inject ManagementContext before preparing \"+this);\n        getBlobStoreContext();\n        if (persistMode==null || persistMode==PersistMode.DISABLED) {\n            log.warn(\"Should not be using \"+this+\" when persistMode is \"+persistMode);\n            return;\n        }\n        Boolean backups = mgmt.getConfig().getConfig(BrooklynServerConfig.PERSISTENCE_BACKUPS_REQUIRED);\n        if (Boolean.TRUE.equals(backups)) {\n            log.warn(\"Using legacy backup for \"+this+\"; functionality will be removed in future versions, in favor of promotion/demotion-specific backups to a configurable backup location.\");\n            throw new FatalConfigurationRuntimeException(\"Backups not supported for object store (\"+this+\")\");\n        }\n    }\n    @Override\n    public void deleteCompletely() {\n        if (Strings.isBlank(containerSubPath))\n            getBlobStoreContext().getBlobStore().deleteContainer(containerNameFirstPart);\n        else\n            newAccessor(containerSubPath).delete();\n    }\n}<fim_middle>// class below has no smell\n"}