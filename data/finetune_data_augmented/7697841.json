{"text": "<fim_prefix>/*\n * Tencent is pleased to support the open source community by making Tinker available.\n *\n * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.\n *\n * Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in\n * compliance with the License. You may obtain a copy of the License at\n *\n * https://opensource.org/licenses/BSD-3-Clause\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License is\n * distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n * either express or implied. See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.tencent.tinker.loader.shareutil;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.charset.Charset;\n\n/**\n * Created by tangyinsheng on 2017/3/14.\n */\n\npublic final class ShareOatUtil {\n    private static final String TAG = \"Tinker.OatUtil\";\n\n    private ShareOatUtil() {\n        throw new UnsupportedOperationException();\n    }\n\n    /**\n     * Get instruction set used to generate {@code oatFile}.\n     *\n     * @param oatFile\n     *  the oat file.\n     * @return\n     *  the instruction used to generate this oat file, if the oat file does not\n     *  contain this value, an empty string will be returned.\n     *\n     * @throws IOException\n     *  If anything wrong when parsing the elf format or locating target field in oat header.\n     */\n<fim_suffix>    public static String getOatFileInstructionSet(File oatFile) throws Throwable {\n        ShareElfFile elfFile = null;\n        String result = \"\";\n        try {\n            elfFile = new ShareElfFile(oatFile);\n            final ShareElfFile.SectionHeader roDataHdr = elfFile.getSectionHeaderByName(\".rodata\");\n            if (roDataHdr == null) {\n                throw new IOException(\"Unable to find .rodata section.\");\n            }\n\n            final FileChannel channel = elfFile.getChannel();\n            channel.position(roDataHdr.shOffset);\n\n            final byte[] oatMagicAndVersion = new byte[8];\n            ShareElfFile.readUntilLimit(channel, ByteBuffer.wrap(oatMagicAndVersion), \"Failed to read oat magic and version.\");\n\n            if (oatMagicAndVersion[0] != 'o'\n                    || oatMagicAndVersion[1] != 'a'\n                    || oatMagicAndVersion[2] != 't'\n                    || oatMagicAndVersion[3] != '\\n') {\n                throw new IOException(\n                        String.format(\"Bad oat magic: %x %x %x %x\",\n                                oatMagicAndVersion[0],\n                                oatMagicAndVersion[1],\n                                oatMagicAndVersion[2],\n                                oatMagicAndVersion[3])\n                );\n            }\n\n            final int versionOffsetFromOatBegin = 4;\n            final int versionBytes = 3;\n\n            final String oatVersion = new String(oatMagicAndVersion,\n                    versionOffsetFromOatBegin, versionBytes, Charset.forName(\"ASCII\"));\n            try {\n                Integer.parseInt(oatVersion);\n            } catch (NumberFormatException e) {\n                throw new IOException(\"Bad oat version: \" + oatVersion);\n            }\n\n            ByteBuffer buffer = ByteBuffer.allocate(128);\n            buffer.order(elfFile.getDataOrder());\n            // TODO This is a risk point, since each oat version may use a different offset.\n            // So far it's ok. Perhaps we should use oatVersionNum to judge the right offset in\n            // the future.\n            final int isaNumOffsetFromOatBegin = 12;\n            channel.position(roDataHdr.shOffset + isaNumOffsetFromOatBegin);\n            buffer.limit(4);\n            ShareElfFile.readUntilLimit(channel, buffer, \"Failed to read isa num.\");\n\n            int isaNum = buffer.getInt();\n            if (isaNum < 0 || isaNum >= InstructionSet.values().length) {\n                throw new IOException(\"Bad isa num: \" + isaNum);\n            }\n\n            switch (InstructionSet.values()[isaNum]) {\n                case kArm:\n                case kThumb2:\n                    result = \"arm\";\n                    break;\n                case kArm64:\n                    result = \"arm64\";\n                    break;\n                case kX86:\n                    result = \"x86\";\n                    break;\n                case kX86_64:\n                    result = \"x86_64\";\n                    break;\n                case kMips:\n                    result = \"mips\";\n                    break;\n                case kMips64:\n                    result = \"mips64\";\n                    break;\n                case kNone:\n                    result = \"none\";\n                    break;\n                default:\n                    throw new IOException(\"Should not reach here.\");\n            }\n        } finally {\n            if (elfFile != null) {\n                try {\n                    elfFile.close();\n                } catch (Exception ignored) {\n                    // Ignored.\n                }\n            }\n        }\n        return result;\n    }\n\n    private enum InstructionSet {\n        kNone,\n        kArm,\n        kArm64,\n        kThumb2,\n        kX86,\n        kX86_64,\n        kMips,\n        kMips64\n    }\n}<fim_middle>// function below is long method\n"}