{"text": "<fim_prefix>/*\n * Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n *\n */\n\npackage sun.jvm.hotspot.oops;\n\nimport java.io.*;\nimport java.util.*;\nimport sun.jvm.hotspot.debugger.*;\nimport sun.jvm.hotspot.runtime.*;\nimport sun.jvm.hotspot.types.*;\nimport sun.jvm.hotspot.utilities.*;\n\n// A Symbol is a canonicalized string.\n// All Symbols reside in global symbolTable.\n\npublic class Symbol extends VMObject {\n  static {\n    VM.registerVMInitializedObserver(new Observer() {\n        public void update(Observable o, Object data) {\n          initialize(VM.getVM().getTypeDataBase());\n        }\n      });\n  }\n\n  private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n    Type type  = db.lookupType(\"Symbol\");\n    lengthAndRefcount = type.getCIntegerField(\"_length_and_refcount\");\n    baseOffset = type.getField(\"_body\").getOffset();\n    idHash = type.getCIntegerField(\"_identity_hash\");\n  }\n\n  public static Symbol create(Address addr) {\n    if (addr == null) {\n      return null;\n    }\n    return new Symbol(addr);\n  }\n\n  Symbol(Address addr) {\n    super(addr);\n  }\n\n  public boolean isSymbol()            { return true; }\n\n  private static long baseOffset; // tells where the array part starts\n\n  // Fields\n  private static CIntegerField lengthAndRefcount;\n\n  // Accessors for declared fields\n  public long getLength() {\n    long i = lengthAndRefcount.getValue(this.addr);\n    return (i >> 16) & 0xffff;\n  }\n\n<fim_suffix>  public byte getByteAt(long index) {\n    return addr.getJByteAt(baseOffset + index);\n  }\n  // _identity_hash is a short\n  private static CIntegerField idHash;\n\n  public long identityHash() {\n    long addr_value = getAddress().asLongValue();\n    long addr_bits =\n      (addr_value >> (VM.getVM().getLogMinObjAlignmentInBytes() + 3)) & 0xffffffffL;\n    int  length = (int)getLength();\n    int  byte0 = getByteAt(0);\n    int  byte1 = getByteAt(1);\n    long id_hash = 0xffffL & (long)idHash.getValue(this.addr);\n    return (id_hash |\n      ((addr_bits ^ (length << 8) ^ ((byte0 << 8) | byte1)) << 16)) & 0xffffffffL;\n  }\n\n  public boolean equals(byte[] modUTF8Chars) {\n    int l = (int) getLength();\n    if (l != modUTF8Chars.length) return false;\n    while (l-- > 0) {\n      if (modUTF8Chars[l] != getByteAt(l)) return false;\n    }\n    if (Assert.ASSERTS_ENABLED) {\n      Assert.that(l == -1, \"we should be at the beginning\");\n    }\n    return true;\n  }\n\n  public boolean equals(String string) {\n    return asString().equals(string);\n  }\n\n  public byte[] asByteArray() {\n    int length = (int) getLength();\n    byte [] result = new byte [length];\n    for (int index = 0; index < length; index++) {\n      result[index] = getByteAt(index);\n    }\n    return result;\n  }\n\n  public String asString() {\n    // Decode the byte array and return the string.\n    try {\n      return readModifiedUTF8(asByteArray());\n    } catch(Exception e) {\n      System.err.println(addr);\n      e.printStackTrace();\n      return null;\n    }\n  }\n\n  public boolean startsWith(String str) {\n    return asString().startsWith(str);\n  }\n\n  public void printValueOn(PrintStream tty) {\n    tty.print(\"#\" + asString());\n  }\n\n  /** Note: this comparison is used for vtable sorting only; it\n      doesn't matter what order it defines, as long as it is a total,\n      time-invariant order Since Symbol* are in C_HEAP, their\n      relative order in memory never changes, so use address\n      comparison for speed. */\n  public long fastCompare(Symbol other) {\n    return addr.minus(other.addr);\n  }\n\n  private static String readModifiedUTF8(byte[] buf) throws IOException {\n    final int len = buf.length;\n    byte[] tmp = new byte[len + 2];\n    // write modified UTF-8 length as short in big endian\n    tmp[0] = (byte) ((len >>> 8) & 0xFF);\n    tmp[1] = (byte) ((len >>> 0) & 0xFF);\n    // copy the data\n    System.arraycopy(buf, 0, tmp, 2, len);\n    DataInputStream dis = new DataInputStream(new ByteArrayInputStream(tmp));\n    return dis.readUTF();\n  }\n}<fim_middle>// function below has no smell\n"}