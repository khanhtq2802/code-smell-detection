{"text": "<fim_prefix>// --------------------------------------------------------------------------------------------------\n//  Copyright (c) 2016 Microsoft Corporation\n//  \n//  Permission is hereby granted, free of charge, to any person obtaining a copy of this software and\n//  associated documentation files (the \"Software\"), to deal in the Software without restriction,\n//  including without limitation the rights to use, copy, modify, merge, publish, distribute,\n//  sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is\n//  furnished to do so, subject to the following conditions:\n//  \n//  The above copyright notice and this permission notice shall be included in all copies or\n//  substantial portions of the Software.\n//  \n//  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT\n//  NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n//  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n//  DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// --------------------------------------------------------------------------------------------------\n\npackage com.microsoft.Malmo.MissionHandlers;\n\nimport static org.lwjgl.opengl.GL11.GL_DEPTH_COMPONENT;\nimport static org.lwjgl.opengl.GL11.GL_FLOAT;\nimport static org.lwjgl.opengl.GL11.GL_RGB;\nimport static org.lwjgl.opengl.GL11.GL_RGBA;\nimport static org.lwjgl.opengl.GL11.GL_UNSIGNED_BYTE;\nimport static org.lwjgl.opengl.GL11.glReadPixels;\n\nimport java.nio.ByteBuffer;\nimport java.nio.FloatBuffer;\n\nimport net.minecraft.client.Minecraft;\nimport net.minecraft.client.renderer.GlStateManager;\nimport net.minecraft.client.shader.Framebuffer;\n\nimport org.lwjgl.BufferUtils;\nimport org.lwjgl.opengl.GL11;\nimport org.lwjgl.opengl.GL30;\n\nimport com.microsoft.Malmo.MissionHandlerInterfaces.IVideoProducer;\nimport com.microsoft.Malmo.Schemas.MissionInit;\nimport com.microsoft.Malmo.Schemas.VideoProducer;\n\n<fim_suffix>public class VideoProducerImplementation extends HandlerBase implements IVideoProducer\n{\n    private VideoProducer videoParams;\n    private Framebuffer fbo;\n    private FloatBuffer depthBuffer;\n\n    @Override\n    public boolean parseParameters(Object params)\n    {\n        if (params == null || !(params instanceof VideoProducer))\n            return false;\n        this.videoParams = (VideoProducer) params;\n\n        return true;\n    }\n\n    @Override\n    public VideoType getVideoType()\n    {\n        return VideoType.VIDEO;\n    }\n\n    @Override\n    public void getFrame(MissionInit missionInit, ByteBuffer buffer)\n    {\n        if (!this.videoParams.isWantDepth())\n        {\n            getRGBFrame(buffer); // Just return the simple RGB, 3bpp image.\n            return;\n        }\n\n        // Otherwise, do the work of extracting the depth map:\n        final int width = this.videoParams.getWidth();\n        final int height = this.videoParams.getHeight();\n\n        GL30.glBindFramebuffer(GL30.GL_READ_FRAMEBUFFER, Minecraft.getMinecraft().getFramebuffer().framebufferObject);\n        GL30.glBindFramebuffer(GL30.GL_DRAW_FRAMEBUFFER, this.fbo.framebufferObject);\n        GL30.glBlitFramebuffer(0, 0, Minecraft.getMinecraft().getFramebuffer().framebufferWidth, Minecraft.getMinecraft().getFramebuffer().framebufferHeight, 0, 0, width, height, GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT, GL11.GL_NEAREST);\n\n        this.fbo.bindFramebuffer(true);\n        glReadPixels(0, 0, width, height, GL_RGBA, GL_UNSIGNED_BYTE, buffer);\n        glReadPixels(0, 0, width, height, GL_DEPTH_COMPONENT, GL_FLOAT, this.depthBuffer);\n        this.fbo.unbindFramebuffer();\n\n        // Now convert the depth buffer into values from 0-255 and copy it over\n        // the alpha channel.\n        // We either use the min and max values supplied in order to scale it,\n        // or we scale it according\n        // to the dynamic content:\n        float minval, maxval;\n\n        // The scaling section is optional (since the depthmap is optional) - so\n        // if there is no depthScaling object,\n        // go with the default of autoscale.\n        if (this.videoParams.getDepthScaling() == null || this.videoParams.getDepthScaling().isAutoscale())\n        {\n            minval = 1;\n            maxval = 0;\n            for (int i = 0; i < width * height; i++)\n            {\n                float f = this.depthBuffer.get(i);\n                if (f < minval)\n                    minval = f;\n                if (f > maxval)\n                    maxval = f;\n            }\n        }\n        else\n        {\n            minval = this.videoParams.getDepthScaling().getMin().floatValue();\n            maxval = this.videoParams.getDepthScaling().getMax().floatValue();\n            if (minval > maxval)\n            {\n                // You can't trust users.\n                float t = minval;\n                minval = maxval;\n                maxval = t;\n            }\n        }\n        float range = maxval - minval;\n        if (range < 0.000001)\n            range = 0.000001f; // To avoid divide by zero errors in cases where\n                               // there is no depth variance\n        float scale = 255 / range;\n        for (int i = 0; i < width * height; i++)\n        {\n            float f = this.depthBuffer.get(i);\n            f = (f < minval ? minval : (f > maxval ? maxval : f));\n            f -= minval;\n            f *= scale;\n            buffer.put(i * 4 + 3, (byte) f);\n        }\n        // Reset depth buffer ready for next read:\n        this.depthBuffer.clear();\n    }\n\n    @Override\n    public int getWidth()\n    {\n        return this.videoParams.getWidth();\n    }\n\n    @Override\n    public int getHeight()\n    {\n        return this.videoParams.getHeight();\n    }\n\n    public int getRequiredBufferSize()\n    {\n        return this.videoParams.getWidth() * this.videoParams.getHeight() * (this.videoParams.isWantDepth() ? 4 : 3);\n    }\n\n    private void getRGBFrame(ByteBuffer buffer)\n    {\n        final int format = GL_RGB;\n        final int width = this.videoParams.getWidth();\n        final int height = this.videoParams.getHeight();\n\n        // Render the Minecraft frame into our own FBO, at the desired size:\n        this.fbo.bindFramebuffer(true);\n        Minecraft.getMinecraft().getFramebuffer().framebufferRenderExt(width, height, true);\n        // Now read the pixels out from that:\n        // glReadPixels appears to be faster than doing:\n        // GlStateManager.bindTexture(this.fbo.framebufferTexture);\n        // GL11.glGetTexImage(GL11.GL_TEXTURE_2D, 0, format, GL_UNSIGNED_BYTE,\n        // buffer);\n        glReadPixels(0, 0, width, height, format, GL_UNSIGNED_BYTE, buffer);\n        this.fbo.unbindFramebuffer();\n        GlStateManager.enableDepth();\n        Minecraft.getMinecraft().getFramebuffer().bindFramebuffer(true);\n    }\n\n    @Override\n    public void prepare(MissionInit missionInit)\n    {\n        this.fbo = new Framebuffer(this.videoParams.getWidth(), this.videoParams.getHeight(), true);\n        // Create a buffer for retrieving the depth map, if requested:\n        if (this.videoParams.isWantDepth())\n            this.depthBuffer = BufferUtils.createFloatBuffer(this.videoParams.getWidth() * this.videoParams.getHeight());\n        // Set the requested camera position\n        Minecraft.getMinecraft().gameSettings.thirdPersonView = this.videoParams.getViewpoint();\n    }\n\n    @Override\n    public void cleanup()\n    {\n        this.fbo.deleteFramebuffer(); // Must do this or we leak resources.\n    }\n}<fim_middle>// class below is blob\n"}