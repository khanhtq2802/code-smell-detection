{"text": "<fim_prefix>\t// StringCompressionFlag class has not been initialized and patches the code to bring back\n\t// the null check if a non-compressed String is constructed.\n\tprivate static StringCompressionFlag compressionFlag;\n\t// Represents the bit in count field to test for whether this String backing array is not compressed\n\t// under String compression mode. This bit is not used when String compression is disabled.\n\tprivate static final int uncompressedBit = 0x80000000;\n\tprivate static String[] stringArray;\n\tprivate static final int stringArraySize = 10;\n\tprivate static class UnsafeHelpers {\n\t\tpublic final static long valueFieldOffset = getValueFieldOffset();\n\t\tstatic long getValueFieldOffset() {\n\t\t\ttry {\n\t\t\t\treturn Unsafe.getUnsafe().objectFieldOffset(String.class.getDeclaredField(\"value\")); //$NON-NLS-1$\n\t\t\t} catch (NoSuchFieldException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * This is a System property to enable sharing of the underlying value array in {@link #String.substring(int)} and \n\t * {@link #String.substring(int, int)} if the offset is zero.\n\t */\n\tstatic boolean enableSharingInSubstringWhenOffsetIsZero;\n\tprivate final char[] value;\n\tprivate final int count;\n\tprivate int hashCode;\n\tstatic {\n\t\tstringArray = new String[stringArraySize];\n\t\tcompressedAsciiTable = new char[256][];\n\t\tfor (int i = 0; i < compressedAsciiTable.length; ++i) {\n\t\t\tchar[] asciiValue = new char[1];\n\t\t\thelpers.putByteInArrayByIndex(asciiValue, 0, (byte) i);\n\t\t\tcompressedAsciiTable[i] = asciiValue;\n\t\t}\n\t\tdecompressedAsciiTable = new char[256][];\n\t\tfor (int i = 0; i < decompressedAsciiTable.length; ++i) {\n\t\t\tchar[] asciiValue = new char[1];\n\t\t\thelpers.putCharInArrayByIndex(asciiValue, 0, (char) i);\n\t\t\tdecompressedAsciiTable[i] = asciiValue;\n\t\t}\n\t}\n\tstatic void initCompressionFlag() {\n\t\tif (compressionFlag == null) {\n\t\t\tcompressionFlag = new StringCompressionFlag();\n\t\t}\n\t}\n\tstatic boolean compressible(char[] c, int start, int length) {\n\t\tfor (int i = start; i < length; ++i) {\n\t\t\tif (c[i] > 255) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tstatic void compress(byte[] array1, int start1, byte[] array2, int start2, int length) {\n\t\tfor (int i = 0; i < length; ++i) {\n\t\t\thelpers.putByteInArrayByIndex(array2, start2 + i, (byte) helpers.getCharFromArrayByIndex(array1, start1 + i));\n\t\t}\n\t}\n\tstatic void compress(char[] array1, int start1, byte[] array2, int start2, int length) {\n\t\tfor (int i = 0; i < length; ++i) {\n\t\t\thelpers.putByteInArrayByIndex(array2, start2 + i, (byte) helpers.getCharFromArrayByIndex(array1, start1 + i));\n\t\t}\n\t}\n\tstatic void compress(byte[] array1, int start1, char[] array2, int start2, int length) {\n\t\tfor (int i = 0; i < length; ++i) {\n\t\t\thelpers.putByteInArrayByIndex(array2, start2 + i, (byte) helpers.getCharFromArrayByIndex(array1, start1 + i));\n\t\t}\n\t}\n\tstatic void compress(char[] array1, int start1, char[] array2, int start2, int length) {\n\t\tfor (int i = 0; i < length; ++i) {\n\t\t\thelpers.putByteInArrayByIndex(array2, start2 + i, (byte) helpers.getCharFromArrayByIndex(array1, start1 + i));\n\t\t}\n\t}\n\tstatic void decompress(byte[] array1, int start1, byte[] array2, int start2, int length) {\n\t\tfor (int i = 0; i < length; ++i) {\n\t\t\thelpers.putCharInArrayByIndex(array2, start2 + i, helpers.byteToCharUnsigned(helpers.getByteFromArrayByIndex(array1, start1 + i)));\n\t\t}\n\t}\n\tstatic void decompress(char[] array1, int start1, byte[] array2, int start2, int length) {\n\t\tfor (int i = 0; i < length; ++i) {\n\t\t\thelpers.putCharInArrayByIndex(array2, start2 + i, helpers.byteToCharUnsigned(helpers.getByteFromArrayByIndex(array1, start1 + i)));\n\t\t}\n\t}\n\tstatic void decompress(byte[] array1, int start1, char[] array2, int start2, int length) {\n\t\tfor (int i = 0; i < length; ++i) {\n\t\t\thelpers.putCharInArrayByIndex(array2, start2 + i, helpers.byteToCharUnsigned(helpers.getByteFromArrayByIndex(array1, start1 + i)));\n\t\t}\n\t}\n<fim_suffix>\tstatic void decompress(char[] array1, int start1, char[] array2, int start2, int length) {\n\t\tfor (int i = 0; i < length; ++i) {\n\t\t\thelpers.putCharInArrayByIndex(array2, start2 + i, helpers.byteToCharUnsigned(helpers.getByteFromArrayByIndex(array1, start1 + i)));\n\t\t}\n\t}<fim_middle>// function below has no smell\n"}