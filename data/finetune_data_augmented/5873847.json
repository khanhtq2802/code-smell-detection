{"text": "<fim_prefix>/*\n *\n *  *\n *  * Licensed to the Apache Software Foundation (ASF) under one\n *  * or more contributor license agreements.  See the NOTICE file\n *  * distributed with this work for additional information\n *  * regarding copyright ownership.  The ASF licenses this file\n *  * to you under the Apache License, Version 2.0 (the\n *  * \"License\"); you may not use this file except in compliance\n *  * with the License.  You may obtain a copy of the License at\n *  *\n *  *    http://www.apache.org/licenses/LICENSE-2.0\n *  *\n *  * Unless required by applicable law or agreed to in writing,\n *  * software distributed under the License is distributed on an\n *  * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  * KIND, either express or implied.  See the License for the\n *  * specific language governing permissions and limitations\n *  * under the License.\n *  *\n *\n */\n\npackage org.apache.usergrid.persistence.core.migration.data;\n\n\nimport java.util.Set;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n\n/**\n * Standard implementation logic for plugins to extend\n * @param <T>\n */\npublic abstract class AbstractMigrationPlugin implements MigrationPlugin {\n\n\n\n    private static final Logger logger = LoggerFactory.getLogger( AbstractMigrationPlugin.class );\n\n\n    private final Set<DataMigration> entityDataMigrations;\n    private final MigrationInfoSerialization migrationInfoSerialization;\n\n\n    protected AbstractMigrationPlugin( final Set<DataMigration>entityDataMigrations,\n                                       final MigrationInfoSerialization migrationInfoSerialization ) {\n        this.entityDataMigrations = entityDataMigrations;\n        this.migrationInfoSerialization = migrationInfoSerialization;\n    }\n\n\n    @Override\n    public void run( final ProgressObserver observer ) {\n\n        //run until complete\n        while(runMigration( observer )){\n         logger.info( \"Migration complete, checking for next run\" );\n        }\n\n    }\n\n\n<fim_suffix>    @Override\n    public int getMaxVersion() {\n\n        int max = 0;\n\n        for(DataMigration entityMigration: entityDataMigrations){\n            max = Math.max( max, entityMigration.getMaxVersion() );\n        }\n\n        return max;\n    }\n\n\n    /**\n     * Try to run the migration\n     *\n     * @return True if we ran a migration\n     */\n    private boolean runMigration( final ProgressObserver po ) {\n        DataMigration migrationToExecute = null;\n\n\n        final int version = migrationInfoSerialization.getVersion( getName() );\n\n        for ( DataMigration entityMigration : entityDataMigrations ) {\n            if ( entityMigration.supports( version ) ) {\n                if ( migrationToExecute != null ) {\n                    throw new DataMigrationException(\n                            \"Two migrations attempted to migration the same version, this is not allowed.  Class '\"\n                                    + migrationToExecute.getClass().getName() + \"' and class '\" + entityMigration\n                                    .getClass().getName()\n                                    + \"' both support this version. This means something is wired incorrectly\" );\n                }\n\n                migrationToExecute = entityMigration;\n            }\n        }\n\n        if(migrationToExecute == null){\n            logger.info( \"No migrations found to execute\" );\n            return false;\n        }\n\n        po.start();\n\n\n        //run the migration\n        final int newSystemVersion = migrationToExecute.migrate( version, po );\n\n        //write the version\n        migrationInfoSerialization.setVersion( getName(), newSystemVersion );\n\n        po.complete();\n\n        //signal we've run a migration and return\n        return true;\n\n\n    }\n}<fim_middle>// function below has no smell\n"}