{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.ode.bpel.engine.migration;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.Callable;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.apache.ode.bpel.engine.BpelProcess;\nimport org.apache.ode.bpel.engine.Contexts;\n\n/**\n * Checks database schema versions and migrates when necessary.\n */\npublic class MigrationHandler {\n    private static final Logger __log = LoggerFactory.getLogger(MigrationHandler.class);\n\n    public static final int CURRENT_SCHEMA_VERSION = 7;\n\n\n    private Contexts _contexts;\n    private List<MigrationLink> migrationLinks = new ArrayList<MigrationLink>() {{\n        add(new MigrationLink(1, 2, new Migration[] { new CorrelatorsMigration(),\n                                                        new CorrelationKeyMigration() } ));\n        add(new MigrationLink(2, 3, new Migration[] { new CorrelationKeySetMigration() } ));\n        add(new MigrationLink(4, 3, new Migration[] { new CorrelationKeySetMigration() } ));\n        add(new MigrationLink(3, 5, new Migration[] { new CorrelationKeySetDataMigration() } ));\n        add(new MigrationLink(5, 6, new Migration[] { new OutstandingRequestsMigration() } ));\n        add(new MigrationLink(6, 7, new Migration[] { new IMAManagerMigration() } ));\n    }};\n\n\n    public MigrationHandler(Contexts _contexts) {\n        this._contexts = _contexts;\n    }\n\n    public boolean migrate(final Set<BpelProcess> registeredProcesses, int migrationTransactionTimeout) {\n        if (_contexts.dao.getDataSource() == null) {\n            __log.debug(\"No datasource available, stopping migration. Probably running fully in-memory.\");\n            return true;\n        }\n\n        final int version;\n        try {\n            version = getDbVersion();\n        } catch (Throwable e) {\n            __log.info(\"The ODE_SCHEMA_VERSION database table doesn't exist. Unless you need to migrate your data\" +\n                    \"from a past version, this message can be safely ignored.\");\n            return false;\n        }\n        if (version == -1) {\n            __log.info(\"No schema version available from the database, migrations will be skipped.\");\n            return true;\n        }\n        if (version == CURRENT_SCHEMA_VERSION) return true;\n\n        try {\n            boolean success = _contexts.scheduler.execTransaction(new Callable<Boolean>() {\n                public Boolean call() throws Exception {\n                    ArrayList<Migration> migrations = new ArrayList<Migration>();\n                    findMigrations(version, CURRENT_SCHEMA_VERSION, migrations);\n                    if (migrations.size() == 0) {\n                        __log.error(\"Don't know how to migrate from \" + version + \" to \" + CURRENT_SCHEMA_VERSION + \", aborting\");\n                        return false;\n                    } else {\n                        boolean success = true;\n                        for (Migration mig : migrations) {\n                            __log.debug(\"Running migration \" + mig);\n                            success = mig.migrate(registeredProcesses, _contexts.dao.getConnection()) && success;\n                        }\n\n                        if (!success) _contexts.scheduler.setRollbackOnly();\n                        else setDbVersion(CURRENT_SCHEMA_VERSION);\n                        return success;\n                    }\n                }\n            }, migrationTransactionTimeout);\n            return success;\n        } catch (Exception e) {\n            __log.error(\"An error occured while migrating your database to a newer version of ODE, changes have \" +\n                    \"been aborted\", e);\n            throw new RuntimeException(e);\n        }\n    }\n\n<fim_suffix>    private static class MigrationLink {\n        int source;\n        int target;\n        Migration[] migrations;\n        public MigrationLink(int source, int target, Migration[] migrations) {\n            this.source = source;\n            this.target = target;\n            this.migrations = migrations;\n        }\n    }\n\n    /**\n     * Attempts to find a way from a source to a target and collects the migrations found along. Assumes\n     * a directed graph with no loops. Guarantees that migrations are collected in the proper start-to-end\n     * order.\n     */\n    private boolean findMigrations(int source, int target, List<Migration> ms) {\n        List<MigrationLink> l = findLinksTo(target);\n        for (MigrationLink link : l) {\n            if (link.source == source || findMigrations(source, link.source, ms)) {\n                ms.addAll(Arrays.asList(link.migrations));\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Finds all the links with a given target.\n     */\n    private List<MigrationLink> findLinksTo(int target) {\n        ArrayList<MigrationLink> mls = new ArrayList<MigrationLink>();\n        for (MigrationLink ml : migrationLinks) {\n            if (ml.target == target) mls.add(ml);\n        }\n        return mls;\n    }\n\n    private int getDbVersion() {\n        int version = -1;\n        Connection conn = null;\n        PreparedStatement stmt = null;\n        ResultSet rs = null;\n        try {\n            conn = _contexts.dao.getDataSource().getConnection();\n            stmt = conn.prepareStatement(\"SELECT VERSION FROM ODE_SCHEMA_VERSION\");\n            rs = stmt.executeQuery();\n            if (rs.next()) version = rs.getInt(\"VERSION\");\n        } catch (Exception e) {\n            // Swallow, we'll just abort based on the version number\n        } finally {\n            try {\n                if (rs != null) rs.close();\n                if (stmt != null) stmt.close();\n                if (conn != null) conn.close();\n            } catch (SQLException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return version;\n    }\n\n    private void setDbVersion(int version) {\n        Connection conn = null;\n        Statement stmt = null;\n        try {\n            conn = _contexts.dao.getDataSource().getConnection();\n            stmt = conn.createStatement();\n            int res = stmt.executeUpdate(\"UPDATE ODE_SCHEMA_VERSION SET VERSION = \" + version);\n            // This should never happen but who knows?\n            if (res == 0) throw new RuntimeException(\"Couldn't update schema version.\");\n        } catch (Exception e) {\n            // Swallow, we'll just abort based on the version number\n        } finally {\n            try {\n                if (stmt != null) stmt.close();\n                if (conn != null) conn.close();\n            } catch (SQLException e) {\n                throw new RuntimeException(e);\n            }\n        }\n    }\n}<fim_middle>// class below has no smell\n"}