{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage freemarker.template.utility;\n\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\n/**\n * Number- and math-related utilities.\n * \n * @since 2.3.20\n */\npublic class NumberUtil {\n\n    private static final BigDecimal BIG_DECIMAL_INT_MIN = BigDecimal.valueOf(Integer.MIN_VALUE);\n    private static final BigDecimal BIG_DECIMAL_INT_MAX = BigDecimal.valueOf(Integer.MAX_VALUE);\n    private static final BigInteger BIG_INTEGER_INT_MIN = BIG_DECIMAL_INT_MIN.toBigInteger();\n    private static final BigInteger BIG_INTEGER_INT_MAX = BIG_DECIMAL_INT_MAX.toBigInteger();\n\n    private NumberUtil() { }\n    \n<fim_suffix>    public static boolean isInfinite(Number num) {\n        if (num instanceof Double) {\n            return ((Double) num).isInfinite();\n        } else if (num instanceof Float) {\n            return ((Float) num).isInfinite();\n        } else if (hasTypeThatIsKnownToNotSupportInfiniteAndNaN(num)) {\n            return false;\n        } else {\n            throw new UnsupportedNumberClassException(num.getClass());\n        }           \n    }\n\n    public static boolean isNaN(Number num) {\n        if (num instanceof Double) {\n            return ((Double) num).isNaN();\n        } else if (num instanceof Float) {\n            return ((Float) num).isNaN();\n        } else if (hasTypeThatIsKnownToNotSupportInfiniteAndNaN(num)) {\n            return false;\n        } else {\n            throw new UnsupportedNumberClassException(num.getClass());\n        }           \n    }\n\n    /**\n     * @return -1 for negative, 0 for zero, 1 for positive.\n     * @throws ArithmeticException if the number is NaN\n     */\n    public static int getSignum(Number num) throws ArithmeticException {\n        if (num instanceof Integer) {\n            int n = ((Integer) num).intValue();\n            return n > 0 ? 1 : (n == 0 ? 0 : -1);\n        } else if (num instanceof BigDecimal) {\n            BigDecimal n = (BigDecimal) num;\n            return n.signum();\n        } else if (num instanceof Double) {\n            double n = ((Double) num).doubleValue();\n            if (n > 0) return 1;\n            else if (n == 0) return 0;\n            else if (n < 0) return -1;\n            else throw new ArithmeticException(\"The signum of \" + n + \" is not defined.\");  // NaN\n        } else if (num instanceof Float) {\n            float n = ((Float) num).floatValue();\n            if (n > 0) return 1;\n            else if (n == 0) return 0;\n            else if (n < 0) return -1;\n            else throw new ArithmeticException(\"The signum of \" + n + \" is not defined.\");  // NaN\n        } else if (num instanceof Long) {\n            long n = ((Long) num).longValue();\n            return n > 0 ? 1 : (n == 0 ? 0 : -1);\n        } else if (num instanceof Short) {\n            short n = ((Short) num).shortValue();\n            return n > 0 ? 1 : (n == 0 ? 0 : -1);\n        } else if (num instanceof Byte) {\n            byte n = ((Byte) num).byteValue();\n            return n > 0 ? 1 : (n == 0 ? 0 : -1);\n        } else if (num instanceof BigInteger) {\n            BigInteger n = (BigInteger) num;\n            return n.signum();\n        } else {\n            throw new UnsupportedNumberClassException(num.getClass());\n        }\n    }\n    \n    /**\n     * Tells if a {@link BigDecimal} stores a whole number. For example, it returns {@code true} for {@code 1.0000},\n     * but {@code false} for {@code 1.0001}.\n     * \n     * @since 2.3.21\n     */\n    static public boolean isIntegerBigDecimal(BigDecimal bd) {\n        // [Java 1.5] Try to utilize BigDecimal.toXxxExact methods\n        return bd.scale() <= 0  // A fast check that whole numbers usually (not always) match\n               || bd.setScale(0, BigDecimal.ROUND_DOWN).compareTo(bd) == 0;  // This is rather slow\n        // Note that `bd.signum() == 0 || bd.stripTrailingZeros().scale() <= 0` was also tried for the last\n        // condition, but stripTrailingZeros was slower than setScale + compareTo.\n    }\n    \n    /**\n     * Tells if the type of the parameter number is known to not be able to represent infinite (positive or negative)\n     * and NaN. If this returns {@code false}, that doesn't mean that it can do that, because it's maybe just that this\n     * utility doesn't know that type.\n     * \n     * @since 2.3.28\n     */\n    public static boolean hasTypeThatIsKnownToNotSupportInfiniteAndNaN(Number num) {\n        return num instanceof Integer || num instanceof BigDecimal || num instanceof Long\n                || num instanceof Short || num instanceof Byte || num instanceof BigInteger;\n    }\n\n    /**\n     * Converts a {@link Number} to {@code int} whose mathematical value is exactly the same as of the original number.\n     * \n     * @throws ArithmeticException\n     *             if the conversion to {@code int} is not possible without losing precision or overflow/underflow.\n     * \n     * @since 2.3.22\n     */\n    public static int toIntExact(Number num) {\n        if (num instanceof Integer || num instanceof Short || num instanceof Byte) {\n            return num.intValue();\n        } else if (num instanceof Long) {\n            final long n = num.longValue();\n            final int result = (int) n;\n            if (n != result) {\n                throw newLossyConverionException(num, Integer.class);\n            }\n            return result;\n        } else if (num instanceof Double || num instanceof Float) {\n            final double n = num.doubleValue();\n            if (n % 1 != 0 || n < Integer.MIN_VALUE || n > Integer.MAX_VALUE) {\n                throw newLossyConverionException(num, Integer.class);\n            }\n            return (int) n;\n        } else if (num instanceof BigDecimal) {\n            // [Java 1.5] Use BigDecimal.toIntegerExact()\n            BigDecimal n = (BigDecimal) num;\n            if (!isIntegerBigDecimal(n)\n                    || n.compareTo(BIG_DECIMAL_INT_MAX) > 0 || n.compareTo(BIG_DECIMAL_INT_MIN) < 0) {\n                throw newLossyConverionException(num, Integer.class);\n            }\n            return n.intValue();\n        } else if (num instanceof BigInteger) {\n            BigInteger n = (BigInteger) num;\n            if (n.compareTo(BIG_INTEGER_INT_MAX) > 0 || n.compareTo(BIG_INTEGER_INT_MIN) < 0) {\n                throw newLossyConverionException(num, Integer.class);\n            }\n            return n.intValue();\n        } else {\n            throw new UnsupportedNumberClassException(num.getClass());\n        }\n    }\n\n    private static ArithmeticException newLossyConverionException(Number fromValue, Class/*<Number>*/ toType) {\n        return new ArithmeticException(\n                \"Can't convert \" + fromValue + \" to type \" + ClassUtil.getShortClassName(toType) + \" without loss.\");\n    }\n    \n}<fim_middle>// function below has no smell\n"}