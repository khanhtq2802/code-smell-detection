{"text": "<fim_prefix>    public String toString() {\n      return token + \";exp=\" + expirationDate;\n    }\n    @Override\n    public boolean equals(Object obj) {\n      return obj instanceof DelegationTokenToRenew &&\n        token.equals(((DelegationTokenToRenew)obj).token);\n    }\n    @Override\n    public int hashCode() {\n      return token.hashCode();\n    }\n  }\n  private static class DelegationTokenCancelThread extends Thread {\n    private static class TokenWithConf {\n      Token<?> token;\n      Configuration conf;\n      TokenWithConf(Token<?> token, Configuration conf) {\n        this.token = token;\n        this.conf = conf;\n      }\n    }\n    private LinkedBlockingQueue<TokenWithConf> queue =  \n      new LinkedBlockingQueue<TokenWithConf>();\n    public DelegationTokenCancelThread() {\n      super(\"Delegation Token Canceler\");\n      setDaemon(true);\n    }\n    public void cancelToken(Token<?> token,  \n        Configuration conf) {\n      TokenWithConf tokenWithConf = new TokenWithConf(token, conf);\n      while (!queue.offer(tokenWithConf)) {\n        LOG.warn(\"Unable to add token \" + token + \" for cancellation. \" +\n        \t\t \"Will retry..\");\n        try {\n          Thread.sleep(100);\n        } catch (InterruptedException e) {\n          throw new RuntimeException(e);\n        }\n      }\n    }\n    public void run() {\n      TokenWithConf tokenWithConf = null;\n      while (true) {\n        try {\n          tokenWithConf = queue.take();\n          final TokenWithConf current = tokenWithConf;\n          if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Canceling token \" + tokenWithConf.token.getService());\n          }\n          // need to use doAs so that http can find the kerberos tgt\n          UserGroupInformation.getLoginUser()\n            .doAs(new PrivilegedExceptionAction<Void>(){\n              @Override\n              public Void run() throws Exception {\n                current.token.cancel(current.conf);\n                return null;\n              }\n            });\n        } catch (IOException e) {\n          LOG.warn(\"Failed to cancel token \" + tokenWithConf.token + \" \" +  \n              StringUtils.stringifyException(e));\n        } catch (RuntimeException e) {\n          LOG.warn(\"Failed to cancel token \" + tokenWithConf.token + \" \" +  \n              StringUtils.stringifyException(e));\n        } catch (InterruptedException ie) {\n          return;\n        } catch (Throwable t) {\n          LOG.warn(\"Got exception \" + StringUtils.stringifyException(t) + \n                   \". Exiting..\");\n          System.exit(-1);\n        }\n      }\n    }\n  }\n  //adding token\n  private void addTokenToList(DelegationTokenToRenew t) {\n    delegationTokens.add(t);\n  }\n  @VisibleForTesting\n  public Set<Token<?>> getDelegationTokens() {\n    Set<Token<?>> tokens = new HashSet<Token<?>>();\n    for(DelegationTokenToRenew delegationToken : delegationTokens) {\n      tokens.add(delegationToken.token);\n    }\n    return tokens;\n  }\n  /**\n   * Asynchronously add application tokens for renewal.\n   * @param applicationId added application\n   * @param ts tokens\n   * @param shouldCancelAtEnd true if tokens should be canceled when the app is\n   * done else false. \n   * @throws IOException\n   */\n  public void addApplicationAsync(ApplicationId applicationId, Credentials ts,\n      boolean shouldCancelAtEnd) {\n    processDelegationTokenRenewerEvent(new DelegationTokenRenewerAppSubmitEvent(\n      applicationId, ts, shouldCancelAtEnd));\n  }\n  /**\n   * Synchronously renew delegation tokens.\n   */\n  public void addApplicationSync(ApplicationId applicationId, Credentials ts,\n      boolean shouldCancelAtEnd) throws IOException{\n    handleAppSubmitEvent(new DelegationTokenRenewerAppSubmitEvent(\n      applicationId, ts, shouldCancelAtEnd));\n  }\n  private void handleAppSubmitEvent(DelegationTokenRenewerAppSubmitEvent evt)\n      throws IOException {\n    ApplicationId applicationId = evt.getApplicationId();\n    Credentials ts = evt.getCredentials();\n    boolean shouldCancelAtEnd = evt.shouldCancelAtEnd();\n    if (ts == null) {\n      return; // nothing to add\n    }\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Registering tokens for renewal for:\" +\n          \" appId = \" + applicationId);\n    }\n    Collection<Token<?>> tokens = ts.getAllTokens();\n    long now = System.currentTimeMillis();\n    // find tokens for renewal, but don't add timers until we know\n    // all renewable tokens are valid\n    // At RM restart it is safe to assume that all the previously added tokens\n    // are valid\n    List<DelegationTokenToRenew> tokenList =\n        new ArrayList<DelegationTokenRenewer.DelegationTokenToRenew>();\n    for (Token<?> token : tokens) {\n      if (token.isManaged()) {\n        tokenList.add(new DelegationTokenToRenew(applicationId,\n            token, getConfig(), now, shouldCancelAtEnd));\n      }\n    }\n    if (!tokenList.isEmpty()) {\n      // Renewing token and adding it to timer calls are separated purposefully\n      // If user provides incorrect token then it should not be added for\n      // renewal.\n      for (DelegationTokenToRenew dtr : tokenList) {\n        try {\n          renewToken(dtr);\n        } catch (IOException ioe) {\n          throw new IOException(\"Failed to renew token: \" + dtr.token, ioe);\n        }\n      }\n      for (DelegationTokenToRenew dtr : tokenList) {\n        addTokenToList(dtr);\n        setTimerForTokenRenewal(dtr);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Registering token for renewal for:\" + \" service = \"\n              + dtr.token.getService() + \" for appId = \" + dtr.applicationId);\n        }\n      }\n    }\n  }\n  /**\n   * Task - to renew a token\n   *\n   */\n  private class RenewalTimerTask extends TimerTask {\n    private DelegationTokenToRenew dttr;\n    private boolean cancelled = false;\n    RenewalTimerTask(DelegationTokenToRenew t) {  \n      dttr = t;  \n    }\n    @Override\n    public synchronized void run() {\n      if (cancelled) {\n        return;\n      }\n      Token<?> token = dttr.token;\n      try {\n        renewToken(dttr);\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Renewing delegation-token for:\" + token.getService() + \n              \"; new expiration;\" + dttr.expirationDate);\n        }\n        setTimerForTokenRenewal(dttr);// set the next one\n      } catch (Exception e) {\n        LOG.error(\"Exception renewing token\" + token + \". Not rescheduled\", e);\n        removeFailedDelegationToken(dttr);\n      }\n    }\n    @Override\n    public synchronized boolean cancel() {\n      cancelled = true;\n      return super.cancel();\n    }\n  }\n  /**\n   * set task to renew the token\n   */\n  @VisibleForTesting\n  protected void setTimerForTokenRenewal(DelegationTokenToRenew token)\n      throws IOException {\n    // calculate timer time\n    long expiresIn = token.expirationDate - System.currentTimeMillis();\n    long renewIn = token.expirationDate - expiresIn/10; // little bit before the expiration\n    // need to create new task every time\n    TimerTask tTask = new RenewalTimerTask(token);\n    token.setTimerTask(tTask); // keep reference to the timer\n    renewalTimer.schedule(token.timerTask, new Date(renewIn));\n  }\n  // renew a token\n  @VisibleForTesting\n  protected void renewToken(final DelegationTokenToRenew dttr)\n      throws IOException {\n    // need to use doAs so that http can find the kerberos tgt\n    // NOTE: token renewers should be responsible for the correct UGI!\n    try {\n      dttr.expirationDate = UserGroupInformation.getLoginUser().doAs(\n          new PrivilegedExceptionAction<Long>(){          \n            @Override\n            public Long run() throws Exception {\n              return dttr.token.renew(dttr.conf);\n            }\n          });\n    } catch (InterruptedException e) {\n      throw new IOException(e);\n    }\n  }\n  // cancel a token\n  private void cancelToken(DelegationTokenToRenew t) {\n    if(t.shouldCancelAtEnd) {\n      dtCancelThread.cancelToken(t.token, t.conf);\n    } else {\n      LOG.info(\"Did not cancel \"+t);\n    }\n  }\n  /**\n   * removing failed DT\n   * @param applicationId\n   */\n  private void removeFailedDelegationToken(DelegationTokenToRenew t) {\n    ApplicationId applicationId = t.applicationId;\n    if (LOG.isDebugEnabled())\n      LOG.debug(\"removing failed delegation token for appid=\" + applicationId + \n          \";t=\" + t.token.getService());\n    delegationTokens.remove(t);\n    // cancel the timer\n    if(t.timerTask!=null)\n      t.timerTask.cancel();\n  }\n  /**\n   * Removing delegation token for completed applications.\n   * @param applicationId completed application\n   */\n<fim_suffix>  public void applicationFinished(ApplicationId applicationId) {\n    processDelegationTokenRenewerEvent(new DelegationTokenRenewerEvent(\n        applicationId,\n        DelegationTokenRenewerEventType.FINISH_APPLICATION));\n  }<fim_middle>// function below has no smell\n"}