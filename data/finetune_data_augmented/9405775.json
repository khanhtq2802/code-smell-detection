{"text": "<fim_prefix>     *     {@code KEY_PRESSED}\n     *   <tr>\n     *     <th scope=\"row\">{@code KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS}\n     *     <td>Normal reverse keyboard traversal\n     *     <td>{@code SHIFT-TAB} on {@code KEY_PRESSED}, {@code CTRL-SHIFT-TAB}\n     *     on {@code KEY_PRESSED}\n     *   <tr>\n     *     <th scope=\"row\">{@code KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS}\n     *     <td>Go up one focus traversal cycle\n     *     <td>none\n     *   <tr>\n     *     <th scope=\"row\">{@code KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS}\n     *     <td>Go down one focus traversal cycle\n     *     <td>none\n     * </tbody>\n     * </table>\n     *\n     * To disable a traversal key, use an empty {@code Set};\n     * {@code Collections.EMPTY_SET} is recommended.\n     * <p>\n     * Using the {@code AWTKeyStroke} API, client code can\n     * specify on which of two\n     * specific {@code KeyEvent}s, {@code KEY_PRESSED} or\n     * {@code KEY_RELEASED}, the focus traversal operation will\n     * occur. Regardless of which {@code KeyEvent} is specified,\n     * however, all {@code KeyEvent}s related to the focus\n     * traversal key, including the associated {@code KEY_TYPED}\n     * event, will be consumed, and will not be dispatched\n     * to any {@code Component}. It is a runtime error to\n     * specify a {@code KEY_TYPED} event as\n     * mapping to a focus traversal operation, or to map the same event to\n     * multiple default focus traversal operations.\n     * <p>\n     * This method may throw a {@code ClassCastException} if any {@code Object}\n     * in {@code keystrokes} is not an {@code AWTKeyStroke}.\n     *\n     * @param id one of\n     *        {@code KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS},\n     *        {@code KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS},\n     *        {@code KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS}, or\n     *        {@code KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS}\n     * @param keystrokes the Set of {@code AWTKeyStroke}s for the\n     *        specified operation\n     * @see #getDefaultFocusTraversalKeys\n     * @see Component#setFocusTraversalKeys\n     * @see Component#getFocusTraversalKeys\n     * @throws IllegalArgumentException if id is not one of\n     *         {@code KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS},\n     *         {@code KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS},\n     *         {@code KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS}, or\n     *         {@code KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS},\n     *         or if keystrokes is {@code null},\n     *         or if keystrokes contains {@code null},\n     *         or if any keystroke\n     *         represents a {@code KEY_TYPED} event,\n     *         or if any keystroke already maps\n     *         to another default focus traversal operation\n     */\n    public void\n        setDefaultFocusTraversalKeys(int id,\n                                     Set<? extends AWTKeyStroke> keystrokes)\n    {\n        if (id < 0 || id >= TRAVERSAL_KEY_LENGTH) {\n            throw new IllegalArgumentException(\"invalid focus traversal key identifier\");\n        }\n        if (keystrokes == null) {\n            throw new IllegalArgumentException(\"cannot set null Set of default focus traversal keys\");\n        }\n        Set<AWTKeyStroke> oldKeys;\n        synchronized (this) {\n            for (AWTKeyStroke keystroke : keystrokes) {\n                if (keystroke == null) {\n                    throw new IllegalArgumentException(\"cannot set null focus traversal key\");\n                }\n                if (keystroke.getKeyChar() != KeyEvent.CHAR_UNDEFINED) {\n                    throw new IllegalArgumentException(\"focus traversal keys cannot map to KEY_TYPED events\");\n                }\n                // Check to see if key already maps to another traversal\n                // operation\n                for (int i = 0; i < TRAVERSAL_KEY_LENGTH; i++) {\n                    if (i == id) {\n                        continue;\n                    }\n                    if (defaultFocusTraversalKeys[i].contains(keystroke)) {\n                        throw new IllegalArgumentException(\"focus traversal keys must be unique for a Component\");\n                    }\n                }\n            }\n            oldKeys = defaultFocusTraversalKeys[id];\n            defaultFocusTraversalKeys[id] =\n                Collections.unmodifiableSet(new HashSet<>(keystrokes));\n        }\n        firePropertyChange(defaultFocusTraversalKeyPropertyNames[id],\n                           oldKeys, keystrokes);\n    }\n    /**\n     * Returns a Set of default focus traversal keys for a given traversal\n     * operation. This traversal key Set will be in effect on all Windows that\n     * have no such Set of their own explicitly defined. This Set will also be\n     * inherited, recursively, by any child Component of those Windows that has\n     * no such Set of its own explicitly defined. (See\n     * {@code setDefaultFocusTraversalKeys} for a full description of each\n     * operation.)\n     *\n     * @param id one of KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,\n     *        KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,\n     *        KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or\n     *        KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS\n     * @return the {@code Set} of {@code AWTKeyStroke}s\n     *         for the specified operation; the {@code Set}\n     *         will be unmodifiable, and may be empty; {@code null}\n     *         will never be returned\n     * @see #setDefaultFocusTraversalKeys\n     * @see Component#setFocusTraversalKeys\n     * @see Component#getFocusTraversalKeys\n     * @throws IllegalArgumentException if id is not one of\n     *         KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,\n     *         KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,\n     *         KeyboardFocusManager.UP_CYCLE_TRAVERSAL_KEYS, or\n     *         KeyboardFocusManager.DOWN_CYCLE_TRAVERSAL_KEYS\n     */\n    public Set<AWTKeyStroke> getDefaultFocusTraversalKeys(int id) {\n        if (id < 0 || id >= TRAVERSAL_KEY_LENGTH) {\n            throw new IllegalArgumentException(\"invalid focus traversal key identifier\");\n        }\n        // Okay to return Set directly because it is an unmodifiable view\n        return defaultFocusTraversalKeys[id];\n    }\n    /**\n     * Returns the current focus cycle root, if the current focus cycle root is\n     * in the same context as the calling thread. If the focus owner is itself\n     * a focus cycle root, then it may be ambiguous as to which Components\n     * represent the next and previous Components to focus during normal focus\n     * traversal. In that case, the current focus cycle root is used to\n     * differentiate among the possibilities.\n     * <p>\n     * This method is intended to be used only by KeyboardFocusManagers and\n     * focus implementations. It is not for general client use.\n     *\n     * @return the current focus cycle root, or null if the current focus cycle\n     *         root is not a member of the calling thread's context\n     * @see #getGlobalCurrentFocusCycleRoot\n     * @see #setGlobalCurrentFocusCycleRoot\n     */\n    public Container getCurrentFocusCycleRoot() {\n        synchronized (KeyboardFocusManager.class) {\n            if (currentFocusCycleRoot == null) {\n                return null;\n            }\n            return (currentFocusCycleRoot.appContext ==\n                    AppContext.getAppContext())\n                ? currentFocusCycleRoot\n                : null;\n        }\n    }\n    /**\n     * Returns the current focus cycle root, even if the calling thread is in a\n     * different context than the current focus cycle root. If the focus owner\n     * is itself a focus cycle root, then it may be ambiguous as to which\n     * Components represent the next and previous Components to focus during\n     * normal focus traversal. In that case, the current focus cycle root is\n     * used to differentiate among the possibilities.\n     *\n     * @return the current focus cycle root, or null if the current focus cycle\n     *         root is not a member of the calling thread's context\n     * @see #getCurrentFocusCycleRoot\n     * @see #setGlobalCurrentFocusCycleRoot\n     * @throws SecurityException if this KeyboardFocusManager is not the\n     *         current KeyboardFocusManager for the calling thread's context\n     *         and if the calling thread does not have \"replaceKeyboardFocusManager\"\n     *         permission\n     */\n<fim_suffix>    protected Container getGlobalCurrentFocusCycleRoot()\n        throws SecurityException\n    {\n        synchronized (KeyboardFocusManager.class) {\n            checkKFMSecurity();\n            return currentFocusCycleRoot;\n        }\n    }<fim_middle>// function below has no smell\n"}