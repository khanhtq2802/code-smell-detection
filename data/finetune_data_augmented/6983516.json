{"text": "<fim_prefix>/*\n * Copyright 2015 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage com.google.j2cl.common;\n\nimport static com.google.common.base.Preconditions.checkArgument;\n\nimport com.google.common.collect.LinkedHashMultimap;\nimport com.google.common.collect.Multimap;\nimport java.io.PrintStream;\nimport java.io.PrintWriter;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.EnumSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\n\n/** An error logger class that records the number of errors and provides error print methods. */\n<fim_suffix>public class Problems {\n\n  /** Represents compiler fatal errors. */\n  public enum FatalError {\n    FILE_NOT_FOUND(\"File '%s' not found.\", 1),\n    UNKNOWN_INPUT_TYPE(\"Cannot recognize input type for file '%s'.\", 1),\n    OUTPUT_LOCATION(\"Output location '%s' must be a directory or .zip file.\", 1),\n    CANNOT_EXTRACT_ZIP(\"Cannot extract zip '%s'.\", 1),\n    CANNOT_CREATE_ZIP(\"Cannot create zip '%s': %s.\", 2),\n    CANNOT_CLOSE_ZIP(\"Cannot close zip: %s.\", 1),\n    CANNOT_CREATE_TEMP_DIR(\"Cannot create temporary directory: %s.\", 1),\n    CANNOT_OPEN_FILE(\"Cannot open file: %s.\", 1),\n    CANNOT_WRITE_FILE(\"Cannot write file: %s.\", 1),\n    CANNOT_COPY_FILE(\"Cannot copy file: %s.\", 1),\n    PACKAGE_INFO_PARSE(\"Resource '%s' was found but it failed to parse.\", 1),\n    CLASS_PATH_URL(\"Class path entry '%s' is not a valid url.\", 1),\n    GWT_INCOMPATIBLE_FOUND_IN_COMPILE(\n        \"@GwtIncompatible annotations found in %s \"\n            + \"Please run this library through the @GwtIncompatible stripper tool.\",\n        1),\n    ;\n\n    // used for customized message.\n    private final String message;\n    // number of arguments the message takes.\n    private final int numberOfArguments;\n\n    FatalError(String message, int numberOfArguments) {\n      this.message = message;\n      this.numberOfArguments = numberOfArguments;\n    }\n\n    public String getMessage() {\n      return message;\n    }\n\n    private int getNumberOfArguments() {\n      return numberOfArguments;\n    }\n  }\n\n  /** Represents the severity of the problem */\n  public enum Severity {\n    ERROR(\"Error\"),\n    WARNING(\"Warning\"),\n    INFO(\"Info\");\n\n    Severity(String messagePrefix) {\n      this.messagePrefix = messagePrefix;\n    }\n\n    private final String messagePrefix;\n\n    public String getMessagePrefix() {\n      return messagePrefix;\n    }\n  }\n\n  private final Multimap<Severity, String> problemsBySeverity = LinkedHashMultimap.create();\n\n  public void fatal(FatalError fatalError, Object... args) {\n    checkArgument(fatalError.getNumberOfArguments() == args.length);\n    problemsBySeverity.put(\n        Severity.ERROR, \"Error: \" + String.format(fatalError.getMessage(), args));\n    abort();\n  }\n\n  public void error(SourcePosition sourcePosition, String detailMessage, Object... args) {\n    problem(Severity.ERROR, sourcePosition, detailMessage, args);\n  }\n\n  public void error(int lineNumber, String filePath, String detailMessage, Object... args) {\n    problem(Severity.ERROR, lineNumber, filePath, detailMessage, args);\n  }\n\n  public void warning(SourcePosition sourcePosition, String detailMessage, Object... args) {\n    problem(Severity.WARNING, sourcePosition, detailMessage, args);\n  }\n\n  private void problem(\n      Severity severity, SourcePosition sourcePosition, String detailMessage, Object... args) {\n    problem(\n        severity,\n        // SourcePosition lines are 0 based.\n        sourcePosition.getStartFilePosition().getLine() + 1,\n        sourcePosition.getFilePath(),\n        detailMessage,\n        args);\n  }\n\n  private void problem(\n      Severity severity, int lineNumber, String filePath, String detailMessage, Object... args) {\n    String message = args.length == 0 ? detailMessage : String.format(detailMessage, args);\n    problemsBySeverity.put(\n        severity,\n        String.format(\n            \"%s:%s:%s: %s\",\n            severity.getMessagePrefix(),\n            filePath.substring(filePath.lastIndexOf('/') + 1),\n            lineNumber,\n            message));\n  }\n\n  public void error(String detailMessage, Object... args) {\n    problemsBySeverity.put(Severity.ERROR, \"Error: \" + String.format(detailMessage, args));\n  }\n\n  public void warning(String detailMessage, Object... args) {\n    problemsBySeverity.put(Severity.WARNING, String.format(detailMessage, args));\n  }\n\n  public void info(String detailMessage, Object... args) {\n    problemsBySeverity.put(Severity.INFO, String.format(detailMessage, args));\n  }\n\n  /** Prints all problems to provided output and returns the exit code. */\n  public int reportAndGetExitCode(PrintStream output) {\n    return reportAndGetExitCode(new PrintWriter(output, true));\n  }\n\n  /** Prints all problems to provided output and returns the exit code. */\n  public int reportAndGetExitCode(PrintWriter output) {\n    for (Map.Entry<Severity, String> severityMessagePair : problemsBySeverity.entries()) {\n      output.println(severityMessagePair.getValue());\n    }\n    if (hasErrors() || hasWarnings()) {\n      output.printf(\n          \"%d error(s), %d warning(s).\\n\",\n          problemsBySeverity.get(Severity.ERROR).size(),\n          problemsBySeverity.get(Severity.WARNING).size());\n    }\n\n    return hasErrors() ? 1 : 0;\n  }\n\n  public boolean hasWarnings() {\n    return problemsBySeverity.containsKey(Severity.WARNING);\n  }\n\n  public boolean hasErrors() {\n    return problemsBySeverity.containsKey(Severity.ERROR);\n  }\n\n  public boolean hasProblems() {\n    return !problemsBySeverity.isEmpty();\n  }\n\n  public void abortIfHasErrors() {\n    if (hasErrors()) {\n      abort();\n    }\n  }\n\n  public void abort() {\n    throw new Exit(this);\n  }\n\n  public List<String> getErrors() {\n    return getMessages(Severity.ERROR);\n  }\n\n  public List<String> getWarnings() {\n    return getMessages(Severity.WARNING);\n  }\n\n  public List<String> getInfoMessages() {\n    return getMessages(Severity.INFO);\n  }\n\n  public List<String> getMessages() {\n    return getMessages(EnumSet.allOf(Severity.class));\n  }\n\n  private List<String> getMessages(Severity severity) {\n    return getMessages(Collections.singleton(severity));\n  }\n\n  private List<String> getMessages(Collection<Severity> severities) {\n    return problemsBySeverity\n        .entries()\n        .stream()\n        .filter(e -> severities.contains(e.getKey()))\n        .map(Map.Entry::getValue)\n        .collect(Collectors.toList());\n  }\n\n  /**\n   * Exit is thrown to signal that a System.exit should be performed at a higher level.\n   *\n   * <p>Note: It should never be caught except on the top level.\n   */\n  public static class Exit extends java.lang.Error {\n    private final Problems problems;\n\n    private Exit(Problems problems) {\n      this.problems = problems;\n    }\n\n    public Problems getProblems() {\n      return problems;\n    }\n  }\n}<fim_middle>// class below is blob\n"}