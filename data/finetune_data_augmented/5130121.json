{"text": "<fim_prefix>            if ( !specialFiles.isEmpty() )\n            {\n                addCommandLineArgFile( cmd, javadocOutputDirectory, specialFiles );\n            }\n        }\n        else\n        {\n            // ----------------------------------------------------------------------\n            // Write argfile file and include it in the command line\n            // ----------------------------------------------------------------------\n            List<String> allFiles = new ArrayList<>();\n            for ( Map.Entry<Path, Collection<String>> filesEntry : files.entrySet() )\n            {\n                for ( String file : filesEntry.getValue() )\n                {\n                    allFiles.add( filesEntry.getKey().resolve( file ).toString() );\n                }\n            }\n            if ( !files.isEmpty() )\n            {\n                addCommandLineArgFile( cmd, javadocOutputDirectory, allFiles );\n            }\n        }\n        // ----------------------------------------------------------------------\n        // Execute command line\n        // ----------------------------------------------------------------------\n        executeJavadocCommandLine( cmd, javadocOutputDirectory );\n        // delete generated javadoc files only if no error and no debug mode\n        // [MJAVADOC-336] Use File.delete() instead of File.deleteOnExit() to\n        // prevent these files from making their way into archives.\n        if ( !debug )\n        {\n            for ( int i = 0; i < cmd.getArguments().length; i++ )\n            {\n                String arg = cmd.getArguments()[i].trim();\n                if ( !arg.startsWith( \"@\" ) )\n                {\n                    continue;\n                }\n                File argFile = new File( javadocOutputDirectory, arg.substring( 1 ) );\n                if ( argFile.exists() )\n                {\n                    argFile.delete();\n                }\n            }\n            File scriptFile = new File( javadocOutputDirectory, DEBUG_JAVADOC_SCRIPT_NAME );\n            if ( scriptFile.exists() )\n            {\n                scriptFile.delete();\n            }\n        }\n        if ( applyJavadocSecurityFix )\n        {\n            // finally, patch the Javadoc vulnerability in older Javadoc tools (CVE-2013-1571):\n            try\n            {\n                final int patched = fixFrameInjectionBug( javadocOutputDirectory, getDocencoding() );\n                if ( patched > 0 )\n                {\n                    getLog().info(\n                        String.format( \"Fixed Javadoc frame injection vulnerability (CVE-2013-1571) in %d files.\",\n                                       patched ) );\n                }\n            }\n            catch ( IOException e )\n            {\n                throw new MavenReportException( \"Failed to patch javadocs vulnerability: \" + e.getMessage(), e );\n            }\n        }\n        else\n        {\n          getLog().info( \"applying javadoc security fix has been disabled\" );\n        }\n    }\n    protected final <T> Collection<T> collect( Collection<Collection<T>> sourcePaths )\n    {\n        Collection<T> collectedSourcePaths = new LinkedHashSet<>();\n        for ( Collection<T> sp : sourcePaths )\n        {\n            collectedSourcePaths.addAll( sp );\n        }\n        return collectedSourcePaths;\n    }\n    /**\n     * Method to get the files on the specified source paths\n     *\n     * @param sourcePaths a Collection that contains the paths to the source files\n     * @return a List that contains the specific path for every source file\n     * @throws MavenReportException {@link MavenReportException}\n     */\n    protected Map<Path, Collection<String>> getFiles( Collection<Path> sourcePaths )\n        throws MavenReportException\n    {\n        Map<Path, Collection<String>> mappedFiles = new LinkedHashMap<>( sourcePaths.size() );\n        if ( StringUtils.isEmpty( subpackages ) )\n        {\n            Collection<String> excludedPackages = getExcludedPackages();\n            for ( Path sourcePath : sourcePaths )\n            {\n                List<String> files = new ArrayList<>();\n                File sourceDirectory = sourcePath.toFile();\n                files.addAll( JavadocUtil.getFilesFromSource( sourceDirectory, sourceFileIncludes, sourceFileExcludes,\n                                                              excludedPackages ) );\n                if ( source != null && JavaVersion.parse( source ).isBefore( \"9\" )\n                    && files.remove( \"module-info.java\" ) )\n                {\n                    getLog().debug( \"Auto exclude module-info.java due to source value\" );\n                }\n                mappedFiles.put( sourcePath, files );\n            }\n        }\n        return mappedFiles;\n    }\n    /**\n     * Method to get the source paths per reactorProject. If no source path is specified in the parameter, the compile\n     * source roots of the project will be used.\n     *\n     * @return a Map of the project absolute source paths per projects key (G:A)\n     * @throws MavenReportException {@link MavenReportException}\n     * @see JavadocUtil#pruneDirs(MavenProject, Collection)\n     */\n    protected Map<String, Collection<Path>> getSourcePaths()\n        throws MavenReportException\n    {\n        Map<String, Collection<Path>> mappedSourcePaths = new LinkedHashMap<>();\n        if ( StringUtils.isEmpty( sourcepath ) )\n        {\n            if ( !\"pom\".equals( project.getPackaging()  ) )\n            {\n                Set<Path> sourcePaths =\n                    new LinkedHashSet<>( JavadocUtil.pruneDirs( project, getProjectSourceRoots( project ) ) );\n                if ( project.getExecutionProject() != null )\n                {\n                    sourcePaths.addAll( JavadocUtil.pruneDirs( project, getExecutionProjectSourceRoots( project ) ) );\n                }\n                /*\n                 * Should be after the source path (i.e. -sourcepath '.../src/main/java;.../src/main/javadoc') and *not*\n                 * the opposite. If not, the javadoc tool always copies doc files, even if -docfilessubdirs is not\n                 * setted.\n                 */\n                if ( getJavadocDirectory() != null )\n                {\n                    File javadocDir = getJavadocDirectory();\n                    if ( javadocDir.exists() && javadocDir.isDirectory() )\n                    {\n                        Collection<Path> l =\n                            JavadocUtil.pruneDirs( project,\n                                               Collections.singletonList( getJavadocDirectory().getAbsolutePath() ) );\n                        sourcePaths.addAll( l );\n                    }\n                }\n                if ( !sourcePaths.isEmpty() )\n                {\n                    mappedSourcePaths.put( ArtifactUtils.versionlessKey( project.getGroupId(),\n                                                                         project.getArtifactId() ),\n                                           sourcePaths );\n                }\n            }\n            if ( includeDependencySources )\n            {\n                mappedSourcePaths.putAll( getDependencySourcePaths() );\n            }\n            if ( isAggregator() )\n            {\n                for ( MavenProject subProject : getAggregatedProjects() )\n                {\n                    if ( subProject != project )\n                    {\n                        Collection<Path> additionalSourcePaths = new ArrayList<>();\n                        List<String> sourceRoots = getProjectSourceRoots( subProject );\n                        if ( subProject.getExecutionProject() != null )\n                        {\n                            sourceRoots.addAll( getExecutionProjectSourceRoots( subProject ) );\n                        }\n                        ArtifactHandler artifactHandler = subProject.getArtifact().getArtifactHandler();\n                        if ( \"java\".equals( artifactHandler.getLanguage() ) )\n                        {\n                            additionalSourcePaths.addAll( JavadocUtil.pruneDirs( subProject, sourceRoots ) );\n                        }\n                        if ( getJavadocDirectory() != null )\n                        {\n                            String javadocDirRelative =\n                                PathUtils.toRelative( project.getBasedir(),\n                                                      getJavadocDirectory().getAbsolutePath() );\n                            File javadocDir = new File( subProject.getBasedir(), javadocDirRelative );\n                            if ( javadocDir.exists() && javadocDir.isDirectory() )\n                            {\n                                Collection<Path> l = JavadocUtil.pruneDirs( subProject, Collections.singletonList(\n                                        javadocDir.getAbsolutePath() ) );\n                                additionalSourcePaths.addAll( l );\n                            }\n                        }\n                        mappedSourcePaths.put( ArtifactUtils.versionlessKey( subProject.getGroupId(),\n                                                                             subProject.getArtifactId() ),\n                                               additionalSourcePaths );\n                    }\n                }\n            }\n        }\n        else\n        {\n            Collection<Path> sourcePaths =\n                JavadocUtil.pruneDirs( project,\n                                       new ArrayList<>( Arrays.asList( JavadocUtil.splitPath( sourcepath ) ) ) );\n            if ( getJavadocDirectory() != null )\n            {\n                Collection<Path> l = JavadocUtil.pruneDirs( project, Collections.singletonList(\n                    getJavadocDirectory().getAbsolutePath() ) );\n                sourcePaths.addAll( l );\n            }\n            mappedSourcePaths.put( ArtifactUtils.versionlessKey( project.getGroupId(), project.getArtifactId() ),\n                                   sourcePaths );\n        }\n        return mappedSourcePaths;\n    }\n<fim_suffix>    private Collection<MavenProject> getAggregatedProjects()\n    {\n        Map<Path, MavenProject> reactorProjectsMap = new HashMap<>();\n        for ( MavenProject reactorProject : this.reactorProjects )\n        {\n            reactorProjectsMap.put( reactorProject.getBasedir().toPath(), reactorProject );\n        }\n        return modulesForAggregatedProject( project, reactorProjectsMap );\n    }<fim_middle>// function below is feature envy\n"}