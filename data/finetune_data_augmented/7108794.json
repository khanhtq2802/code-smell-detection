{"text": "<fim_prefix>                if (compareAndSetTail(oldTail, node)) {\n                    oldTail.next = node;\n                    return node;\n                }\n            } else {\n                initializeSyncQueue();\n            }\n        }\n    }\n    /**\n     * Sets head of queue to be node, thus dequeuing. Called only by\n     * acquire methods.  Also nulls out unused fields for sake of GC\n     * and to suppress unnecessary signals and traversals.\n     *\n     * @param node the node\n     */\n    private void setHead(Node node) {\n        head = node;\n        node.thread = null;\n        node.prev = null;\n    }\n    /**\n     * Wakes up node's successor, if one exists.\n     *\n     * @param node the node\n     */\n    private void unparkSuccessor(Node node) {\n        /*\n         * If status is negative (i.e., possibly needing signal) try\n         * to clear in anticipation of signalling.  It is OK if this\n         * fails or if status is changed by waiting thread.\n         */\n        int ws = node.waitStatus;\n        if (ws < 0)\n            node.compareAndSetWaitStatus(ws, 0);\n        /*\n         * Thread to unpark is held in successor, which is normally\n         * just the next node.  But if cancelled or apparently null,\n         * traverse backwards from tail to find the actual\n         * non-cancelled successor.\n         */\n        Node s = node.next;\n        if (s == null || s.waitStatus > 0) {\n            s = null;\n            for (Node p = tail; p != node && p != null; p = p.prev)\n                if (p.waitStatus <= 0)\n                    s = p;\n        }\n        if (s != null)\n            LockSupport.unpark(s.thread);\n    }\n    /**\n     * Release action for shared mode -- signals successor and ensures\n     * propagation. (Note: For exclusive mode, release just amounts\n     * to calling unparkSuccessor of head if it needs signal.)\n     */\n    private void doReleaseShared() {\n        /*\n         * Ensure that a release propagates, even if there are other\n         * in-progress acquires/releases.  This proceeds in the usual\n         * way of trying to unparkSuccessor of head if it needs\n         * signal. But if it does not, status is set to PROPAGATE to\n         * ensure that upon release, propagation continues.\n         * Additionally, we must loop in case a new node is added\n         * while we are doing this. Also, unlike other uses of\n         * unparkSuccessor, we need to know if CAS to reset status\n         * fails, if so rechecking.\n         */\n        for (;;) {\n            Node h = head;\n            if (h != null && h != tail) {\n                int ws = h.waitStatus;\n                if (ws == Node.SIGNAL) {\n                    if (!h.compareAndSetWaitStatus(Node.SIGNAL, 0))\n                        continue;            // loop to recheck cases\n                    unparkSuccessor(h);\n                }\n                else if (ws == 0 &&\n                         !h.compareAndSetWaitStatus(0, Node.PROPAGATE))\n                    continue;                // loop on failed CAS\n            }\n            if (h == head)                   // loop if head changed\n                break;\n        }\n    }\n    /**\n     * Sets head of queue, and checks if successor may be waiting\n     * in shared mode, if so propagating if either propagate > 0 or\n     * PROPAGATE status was set.\n     *\n     * @param node the node\n     * @param propagate the return value from a tryAcquireShared\n     */\n    private void setHeadAndPropagate(Node node, int propagate) {\n        Node h = head; // Record old head for check below\n        setHead(node);\n        /*\n         * Try to signal next queued node if:\n         *   Propagation was indicated by caller,\n         *     or was recorded (as h.waitStatus either before\n         *     or after setHead) by a previous operation\n         *     (note: this uses sign-check of waitStatus because\n         *      PROPAGATE status may transition to SIGNAL.)\n         * and\n         *   The next node is waiting in shared mode,\n         *     or we don't know, because it appears null\n         *\n         * The conservatism in both of these checks may cause\n         * unnecessary wake-ups, but only when there are multiple\n         * racing acquires/releases, so most need signals now or soon\n         * anyway.\n         */\n        if (propagate > 0 || h == null || h.waitStatus < 0 ||\n            (h = head) == null || h.waitStatus < 0) {\n            Node s = node.next;\n            if (s == null || s.isShared())\n                doReleaseShared();\n        }\n    }\n    // Utilities for various versions of acquire\n    /**\n     * Cancels an ongoing attempt to acquire.\n     *\n     * @param node the node\n     */\n    private void cancelAcquire(Node node) {\n        // Ignore if node doesn't exist\n        if (node == null)\n            return;\n        node.thread = null;\n        // Skip cancelled predecessors\n        Node pred = node.prev;\n        while (pred.waitStatus > 0)\n            node.prev = pred = pred.prev;\n        // predNext is the apparent node to unsplice. CASes below will\n        // fail if not, in which case, we lost race vs another cancel\n        // or signal, so no further action is necessary.\n        Node predNext = pred.next;\n        // Can use unconditional write instead of CAS here.\n        // After this atomic step, other Nodes can skip past us.\n        // Before, we are free of interference from other threads.\n        node.waitStatus = Node.CANCELLED;\n        // If we are the tail, remove ourselves.\n        if (node == tail && compareAndSetTail(node, pred)) {\n            pred.compareAndSetNext(predNext, null);\n        } else {\n            // If successor needs signal, try to set pred's next-link\n            // so it will get one. Otherwise wake it up to propagate.\n            int ws;\n            if (pred != head &&\n                ((ws = pred.waitStatus) == Node.SIGNAL ||\n                 (ws <= 0 && pred.compareAndSetWaitStatus(ws, Node.SIGNAL))) &&\n                pred.thread != null) {\n                Node next = node.next;\n                if (next != null && next.waitStatus <= 0)\n                    pred.compareAndSetNext(predNext, next);\n            } else {\n                unparkSuccessor(node);\n            }\n            node.next = node; // help GC\n        }\n    }\n    /**\n     * Checks and updates status for a node that failed to acquire.\n     * Returns true if thread should block. This is the main signal\n     * control in all acquire loops.  Requires that pred == node.prev.\n     *\n     * @param pred node's predecessor holding status\n     * @param node the node\n     * @return {@code true} if thread should block\n     */\n<fim_suffix>    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n        int ws = pred.waitStatus;\n        if (ws == Node.SIGNAL)\n            /*\n             * This node has already set status asking a release\n             * to signal it, so it can safely park.\n             */\n            return true;\n        if (ws > 0) {\n            /*\n             * Predecessor was cancelled. Skip over predecessors and\n             * indicate retry.\n             */\n            do {\n                node.prev = pred = pred.prev;\n            } while (pred.waitStatus > 0);\n            pred.next = node;\n        } else {\n            /*\n             * waitStatus must be 0 or PROPAGATE.  Indicate that we\n             * need a signal, but don't park yet.  Caller will need to\n             * retry to make sure it cannot acquire before parking.\n             */\n            pred.compareAndSetWaitStatus(ws, Node.SIGNAL);\n        }\n        return false;\n    }<fim_middle>// function below has no smell\n"}