{"text": "<fim_prefix>\n<fim_suffix>public class BuckAddDependencyIntention extends BaseIntentionAction {\n  private static Logger LOGGER = Logger.getInstance(BuckAddDependencyIntention.class);\n  /**\n   * Creates an {@link com.intellij.codeInsight.intention.IntentionAction} that will create an\n   * dependency edge in both the Buck target graph and IntelliJ module graph from the nodes for the\n   * given reference element to those of the given psiClass.\n   *\n   * <p>Note that this intention can fail to be created if either side of the edge cannot be\n   * resolved to a buck file in a buck cell, in which case this method returns null. Also, invoking\n   * this intention may fail to create edges in either the Buck target graph or the IntelliJ module\n   * graph (or both).\n   */\n  @Nullable\n  public static BuckAddDependencyIntention create(\n      PsiJavaCodeReferenceElement referenceElement, PsiClass psiClass) {\n    VirtualFile editSourceFile = referenceElement.getContainingFile().getVirtualFile();\n    if (editSourceFile == null) {\n      return null;\n    }\n    Project project = referenceElement.getProject();\n    BuckTargetLocator buckTargetLocator = BuckTargetLocator.getInstance(project);\n    VirtualFile editBuildFile =\n        buckTargetLocator.findBuckFileForVirtualFile(editSourceFile).orElse(null);\n    if (editBuildFile == null) {\n      return null;\n    }\n    VirtualFile importSourceFile = psiClass.getContainingFile().getVirtualFile();\n    if (importSourceFile == null) {\n      return null;\n    }\n    VirtualFile importBuildFile =\n        buckTargetLocator.findBuckFileForVirtualFile(importSourceFile).orElse(null);\n    if (importBuildFile == null) {\n      return null;\n    }\n    if (importBuildFile.equals(editBuildFile)) {\n      return null;\n    }\n    ProjectFileIndex projectFileIndex = ProjectFileIndex.getInstance(project);\n    Module editModule = projectFileIndex.getModuleForFile(editSourceFile);\n    if (editModule == null) {\n      return null;\n    }\n    Module importModule = projectFileIndex.getModuleForFile(importSourceFile);\n    if (importModule == null) {\n      return null;\n    }\n    BuckTarget editSourceTarget =\n        buckTargetLocator\n            .findTargetPatternForVirtualFile(editSourceFile)\n            .flatMap(BuckTargetPattern::asBuckTarget)\n            .orElse(null);\n    if (editSourceTarget == null) {\n      return null;\n    }\n    BuckTarget importSourceTarget =\n        buckTargetLocator\n            .findTargetPatternForVirtualFile(importSourceFile)\n            .flatMap(BuckTargetPattern::asBuckTarget)\n            .orElse(null);\n    if (importSourceTarget == null) {\n      return null;\n    }\n    return new BuckAddDependencyIntention(\n        project,\n        referenceElement,\n        editBuildFile,\n        editSourceFile,\n        editSourceTarget,\n        editModule,\n        psiClass,\n        importBuildFile,\n        importSourceFile,\n        importSourceTarget,\n        importModule);\n  }\n  private Project project;\n  // Fields pertaining to the element in the file being edited\n  private PsiJavaCodeReferenceElement referenceElement;\n  private VirtualFile editBuildFile;\n  private VirtualFile editSourceFile;\n  private BuckTarget editSourceTarget;\n  private BuckTarget editTarget;\n  private Module editModule;\n  // Fields pertaining to the dependency that should be resolved/imported\n  private PsiClass psiClass;\n  private VirtualFile importBuildFile;\n  private VirtualFile importSourceFile;\n  private BuckTarget importSourceTarget;\n  private BuckTarget importTarget;\n  private Module importModule;\n  BuckAddDependencyIntention(\n      Project project,\n      PsiJavaCodeReferenceElement referenceElement,\n      VirtualFile editBuildFile,\n      VirtualFile editSourceFile,\n      BuckTarget editSourceTarget,\n      Module editModule,\n      PsiClass psiClass,\n      VirtualFile importBuildFile,\n      VirtualFile importSourceFile,\n      BuckTarget importSourceTarget,\n      Module importModule) {\n    this.project = project;\n    this.referenceElement = referenceElement;\n    this.editBuildFile = editBuildFile;\n    this.editSourceFile = editSourceFile;\n    this.editSourceTarget = editSourceTarget;\n    this.editModule = editModule;\n    this.psiClass = psiClass;\n    this.importBuildFile = importBuildFile;\n    this.importSourceFile = importSourceFile;\n    this.importSourceTarget = importSourceTarget;\n    this.importModule = importModule;\n    String message = \"Add BUCK dependency on owner(\" + importSourceTarget + \")\";\n    setText(message);\n  }\n  @Nls(capitalization = Capitalization.Sentence)\n  @NotNull\n  @Override\n  public String getFamilyName() {\n    return this.getClass().getSimpleName();\n  }\n  @Override\n  public boolean isAvailable(@NotNull Project project, Editor editor, PsiFile psiFile) {\n    return true;\n  }\n  @Override\n  public void invoke(@NotNull Project project, Editor editor, PsiFile psiFile)\n      throws IncorrectOperationException {\n    String msg = \"Invoked for project \" + project.getName() + \" and file \" + psiFile.getName();\n    LOGGER.info(msg);\n    queryBuckForTargets(editor);\n  }\n  /** Helper class to handle deserialization of buck query. */\n  static class TargetMetadata {\n    public BuckTarget target;\n    public @Nullable List<BuckTarget> deps;\n    public @Nullable List<BuckTargetPattern> visibility; // null means PUBLIC\n    public @Nullable List<String> srcs;\n    public @Nullable List<String> resources;\n    static TargetMetadata from(\n        BuckTargetLocator buckTargetLocator, BuckTarget target, JsonObject payload) {\n      TargetMetadata targetMetadata = new TargetMetadata();\n      targetMetadata.target = target;\n      targetMetadata.srcs = stringListOrNull(payload.get(\"srcs\"));\n      targetMetadata.resources = stringListOrNull(payload.get(\"resources\"));\n      // Deps are a list of BuckTargets\n      targetMetadata.deps =\n          Optional.ofNullable(stringListOrNull(payload.get(\"deps\")))\n              .map(\n                  deps ->\n                      deps.stream()\n                          .map(\n                              s -> BuckTarget.parse(s).map(buckTargetLocator::resolve).orElse(null))\n                          .collect(Collectors.toList()))\n              .orElse(null);\n      // Visibilility falls in one of three cases:\n      //   (1) if unspecified => means visibility is limited to the current package\n      //   (2) contains \"PUBLIC\" => available everywhere\n      //   (3) otherwise is a list of buck target patterns where it is visible\n      List<String> optionalVisibility = stringListOrNull(payload.get(\"visibility\"));\n      if (optionalVisibility == null) {\n        targetMetadata.visibility =\n            Collections.singletonList(target.asPattern().asPackageMatchingPattern());\n      } else if (optionalVisibility.contains(\"PUBLIC\")) {\n        targetMetadata.visibility = null; //\n      } else {\n        targetMetadata.visibility =\n            optionalVisibility\n                .stream()\n                .map(p -> BuckTargetPattern.parse(p).map(buckTargetLocator::resolve).orElse(null))\n                .collect(Collectors.toList());\n      }\n      return targetMetadata;\n    }\n    static @Nullable List<String> stringListOrNull(@Nullable JsonElement jsonElement) {\n      if (jsonElement == null) {\n        return null;\n      }\n      return new Gson().fromJson(jsonElement, new TypeToken<List<String>>() {}.getType());\n    }\n    boolean isVisibleTo(BuckTarget target) {\n      if (visibility == null) {\n        return true;\n      }\n      return visibility.stream().anyMatch(pattern -> pattern.matches(target));\n    }\n    boolean hasDependencyOn(BuckTarget target) {\n      return deps.stream().anyMatch(dep -> dep.equals(target));\n    }\n    boolean contains(BuckTarget targetFile) {\n      if (!target.asPattern().asPackageMatchingPattern().matches(targetFile)) {\n        return false;\n      }\n      String relativeToBuildFile = targetFile.getRuleName();\n      return srcs.contains(relativeToBuildFile) || resources.contains(relativeToBuildFile);\n    }\n  }\n  /** Queries buck for targets that own the editSourceFile and the importSourceFile. */\n  private void queryBuckForTargets(Editor editor) {\n    BuckTargetLocator buckTargetLocator = BuckTargetLocator.getInstance(project);\n    String editPath = editSourceFile.getPath();\n    String importPath = importSourceFile.getPath();\n    BuckJsonCommandHandler<List<TargetMetadata>> handler =\n        new BuckJsonCommandHandler<>(\n            project,\n            BuckCommand.QUERY,\n            new Callback<List<TargetMetadata>>() {\n              @Override\n              public List<TargetMetadata> deserialize(JsonElement jsonElement) throws IOException {\n                Type type = new TypeToken<Map<String, JsonObject>>() {}.getType();\n                Map<String, JsonObject> raw = new Gson().fromJson(jsonElement, type);\n                List<TargetMetadata> results = new ArrayList<>();\n                for (Entry<String, JsonObject> entry : raw.entrySet()) {<fim_middle>// class below is blob\n"}