{"text": "<fim_prefix>  {\n        return dtm.getStringValue(node).toString();\n  }\n  /**\n   *\n   * @param nodeValue\n   *\n   * @throws DOMException\n   * @see org.w3c.dom.Node -- DTMNodeProxy is read-only\n   */\n  @Override\n  public final void setNodeValue(String nodeValue) throws DOMException\n  {\n    throw new DTMDOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR);\n  }\n  /**\n   *\n   *\n   * @see org.w3c.dom.Node\n   */\n  @Override\n  public final short getNodeType()\n  {\n    return dtm.getNodeType(node);\n  }\n  /**\n   *\n   *\n   * @see org.w3c.dom.Node\n   */\n  @Override\n  public final Node getParentNode()\n  {\n    if (getNodeType() == Node.ATTRIBUTE_NODE)\n      return null;\n    int newnode = dtm.getParent(node);\n    return (newnode == DTM.NULL) ? null : dtm.getNode(newnode);\n  }\n  /**\n   *\n   *\n   * @see org.w3c.dom.Node\n   */\n  public final Node getOwnerNode()\n  {\n    int newnode = dtm.getParent(node);\n    return (newnode == DTM.NULL) ? null : dtm.getNode(newnode);\n  }\n  /**\n   *\n   *\n   * @see org.w3c.dom.Node\n   */\n  @Override\n  public final NodeList getChildNodes()\n  {\n    // Annoyingly, AxisIterators do not currently implement DTMIterator, so\n    // we can't just wap DTMNodeList around an Axis.CHILD iterator.\n    // Instead, we've created a special-case operating mode for that object.\n    return new DTMChildIterNodeList(dtm,node);\n    // throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);\n  }\n  /**\n   *\n   *\n   * @see org.w3c.dom.Node\n   */\n  @Override\n  public final Node getFirstChild()\n  {\n    int newnode = dtm.getFirstChild(node);\n    return (newnode == DTM.NULL) ? null : dtm.getNode(newnode);\n  }\n  /**\n   *\n   *\n   * @see org.w3c.dom.Node\n   */\n  @Override\n  public final Node getLastChild()\n  {\n    int newnode = dtm.getLastChild(node);\n    return (newnode == DTM.NULL) ? null : dtm.getNode(newnode);\n  }\n  /**\n   *\n   *\n   * @see org.w3c.dom.Node\n   */\n  @Override\n  public final Node getPreviousSibling()\n  {\n    int newnode = dtm.getPreviousSibling(node);\n    return (newnode == DTM.NULL) ? null : dtm.getNode(newnode);\n  }\n  /**\n   *\n   *\n   * @see org.w3c.dom.Node\n   */\n  @Override\n  public final Node getNextSibling()\n  {\n    // Attr's Next is defined at DTM level, but not at DOM level.\n    if (dtm.getNodeType(node) == Node.ATTRIBUTE_NODE)\n      return null;\n    int newnode = dtm.getNextSibling(node);\n    return (newnode == DTM.NULL) ? null : dtm.getNode(newnode);\n  }\n  // DTMNamedNodeMap m_attrs;\n  /**\n   *\n   *\n   * @see org.w3c.dom.Node\n   */\n  @Override\n  public final NamedNodeMap getAttributes()\n  {\n    return new DTMNamedNodeMap(dtm, node);\n  }\n  /**\n   * Method hasAttribute\n   *\n   *\n   * @param name\n   *\n   */\n  @Override\n  public boolean hasAttribute(String name)\n  {\n    return DTM.NULL != dtm.getAttributeNode(node,null,name);\n  }\n  /**\n   * Method hasAttributeNS\n   *\n   *\n   * @param namespaceURI\n   * @param localName\n   *\n   *\n   */\n  @Override\n  public boolean hasAttributeNS(String namespaceURI, String localName)\n  {\n    return DTM.NULL != dtm.getAttributeNode(node,namespaceURI,localName);\n  }\n  /**\n   *\n   *\n   * @see org.w3c.dom.Node\n   */\n  @Override\n  public final Document getOwnerDocument()\n  {\n        // Note that this uses the DOM-compatable version of the call\n        return (Document)(dtm.getNode(dtm.getOwnerDocument(node)));\n  }\n  /**\n   *\n   * @param newChild\n   * @param refChild\n   *\n   *\n   *\n   * @throws DOMException\n   * @see org.w3c.dom.Node -- DTMNodeProxy is read-only\n   */\n  @Override\n  public final Node insertBefore(Node newChild, Node refChild)\n    throws DOMException\n  {\n    throw new DTMDOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR);\n  }\n  /**\n   *\n   * @param newChild\n   * @param oldChild\n   *\n   *\n   *\n   * @throws DOMException\n   * @see org.w3c.dom.Node -- DTMNodeProxy is read-only\n   */\n  @Override\n  public final Node replaceChild(Node newChild, Node oldChild)\n    throws DOMException\n  {\n    throw new DTMDOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR);\n  }\n  /**\n   *\n   * @param oldChild\n   *\n   *\n   *\n   * @throws DOMException\n   * @see org.w3c.dom.Node -- DTMNodeProxy is read-only\n   */\n  @Override\n  public final Node removeChild(Node oldChild) throws DOMException\n  {\n    throw new DTMDOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR);\n  }\n  /**\n   *\n   * @param newChild\n   *\n   *\n   *\n   * @throws DOMException\n   * @see org.w3c.dom.Node -- DTMNodeProxy is read-only\n   */\n  @Override\n  public final Node appendChild(Node newChild) throws DOMException\n  {\n    throw new DTMDOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR);\n  }\n  /**\n   *\n   *\n   * @see org.w3c.dom.Node\n   */\n  @Override\n  public final boolean hasChildNodes()\n  {\n    return (DTM.NULL != dtm.getFirstChild(node));\n  }\n  /**\n   *\n   * @param deep\n   *\n   *\n   * @see org.w3c.dom.Node -- DTMNodeProxy is read-only\n   */\n  @Override\n  public final Node cloneNode(boolean deep)\n  {\n    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);\n  }\n  /**\n   *\n   *\n   * @see org.w3c.dom.Document\n   */\n  @Override\n  public final DocumentType getDoctype()\n  {\n    return null;\n  }\n  /**\n   *\n   *\n   * @see org.w3c.dom.Document\n   */\n  @Override\n  public final DOMImplementation getImplementation()\n  {\n    return implementation;\n  }\n  /** This is a bit of a problem in DTM, since a DTM may be a Document\n   * Fragment and hence not have a clear-cut Document Element. We can\n   * make it work in the well-formed cases but would that be confusing for others?\n   *\n   *\n   * @see org.w3c.dom.Document\n   */\n<fim_suffix>  @Override\n  public final Element getDocumentElement()\n  {\n                int dochandle=dtm.getDocument();\n                int elementhandle=DTM.NULL;\n                for(int kidhandle=dtm.getFirstChild(dochandle);\n                                kidhandle!=DTM.NULL;\n                                kidhandle=dtm.getNextSibling(kidhandle))\n                {\n                        switch(dtm.getNodeType(kidhandle))\n                        {\n                        case Node.ELEMENT_NODE:\n                                if(elementhandle!=DTM.NULL)\n                                {\n                                        elementhandle=DTM.NULL; // More than one; ill-formed.\n                                        kidhandle=dtm.getLastChild(dochandle); // End loop\n                                }\n                                else\n                                        elementhandle=kidhandle;\n                                break;\n                        // These are harmless; document is still wellformed\n                        case Node.COMMENT_NODE:\n                        case Node.PROCESSING_INSTRUCTION_NODE:\n                        case Node.DOCUMENT_TYPE_NODE:\n                                break;\n                        default:\n                                elementhandle=DTM.NULL; // ill-formed\n                                kidhandle=dtm.getLastChild(dochandle); // End loop\n                                break;\n                        }\n                }\n                if(elementhandle==DTM.NULL)\n                        throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);\n                else\n                        return (Element)(dtm.getNode(elementhandle));\n  }<fim_middle>// function below is long method\n"}