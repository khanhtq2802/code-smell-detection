{"text": "<fim_prefix>/*\n * Copyright 2014-2017 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.springframework.hateoas;\n\nimport static org.springframework.hateoas.TemplateVariable.VariableType.*;\n\nimport lombok.EqualsAndHashCode;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\nimport org.springframework.hateoas.TemplateVariable.VariableType;\nimport org.springframework.util.Assert;\n\n/**\n * Wrapper type for a collection of {@link TemplateVariable}.\n *\n * @author Oliver Gierke\n */\n@EqualsAndHashCode\npublic final class TemplateVariables implements Iterable<TemplateVariable>, Serializable {\n\n\tpublic static final TemplateVariables NONE = new TemplateVariables();\n\tprivate static final long serialVersionUID = -7736592281223783079L;\n\n\tprivate final List<TemplateVariable> variables;\n\n\t/**\n\t * Creates a new {@link TemplateVariables} for the given {@link TemplateVariable}s.\n\t *\n\t * @param variables must not be {@literal null}.\n\t */\n\tpublic TemplateVariables(TemplateVariable... variables) {\n\t\tthis(Arrays.asList(variables));\n\t}\n\n\t/**\n\t * Creates a new {@link TemplateVariables} for the given {@link TemplateVariable}s.\n\t *\n\t * @param variables must not be {@literal null}.\n\t */\n\tpublic TemplateVariables(List<TemplateVariable> variables) {\n\n\t\tAssert.notNull(variables, \"Template variables must not be null!\");\n\t\tAssert.noNullElements(variables.toArray(), \"Variables must not contain null values!\");\n\n\t\tthis.variables = Collections.unmodifiableList(variables);\n\t}\n\n\t/**\n\t * Concatenates the given {@link TemplateVariable}s to the current one.\n\t *\n\t * @param variables must not be {@literal null}.\n\t * @return\n\t */\n\tpublic TemplateVariables concat(TemplateVariable... variables) {\n\t\treturn concat(Arrays.asList(variables));\n\t}\n\n\t/**\n\t * Concatenates the given {@link TemplateVariable}s to the current one.\n\t *\n\t * @param variables must not be {@literal null}.\n\t * @return\n\t */\n\tpublic TemplateVariables concat(Collection<TemplateVariable> variables) {\n\n\t\tList<TemplateVariable> result = new ArrayList<>(this.variables.size() + variables.size());\n\t\tresult.addAll(this.variables);\n\n\t\tList<TemplateVariable> filtered = variables.stream() //\n\t\t\t\t.filter(variable -> !containsEquivalentFor(variable)).collect(Collectors.toList());\n\n\t\tresult.addAll(filtered);\n\n\t\treturn new TemplateVariables(result);\n\t}\n\n\t/**\n\t * Concatenates the given {@link TemplateVariables} to the current one.\n\t *\n\t * @param variables must not be {@literal null}.\n\t * @return\n\t */\n\tpublic TemplateVariables concat(TemplateVariables variables) {\n\t\treturn concat(variables.variables);\n\t}\n\n\t/**\n\t * Returns the contained {@link TemplateVariable}s as {@link List}.\n\t *\n\t * @return\n\t */\n\tpublic List<TemplateVariable> asList() {\n\t\treturn this.variables;\n\t}\n\n\tprivate boolean containsEquivalentFor(TemplateVariable candidate) {\n\n\t\treturn this.variables.stream() //\n\t\t\t\t.anyMatch(variable -> variable.isEquivalent(candidate));\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * @see java.lang.Iterable#iterator()\n\t */\n\t@Override\n\tpublic Iterator<TemplateVariable> iterator() {\n\t\treturn this.variables.iterator();\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * @see java.lang.Object#toString()\n\t */\n\t@Override\n\tpublic String toString() {\n\t\treturn toString(false);\n\t}\n\n\t/**\n\t * Returns the string representation of the template but forcing a continued style of expressing request parameters.\n\t *\n\t * @param appended\n\t * @return\n\t */\n<fim_suffix>\tString toString(boolean appended) {\n\n\t\tif (variables.isEmpty()) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tStringBuilder builder = new StringBuilder();\n\t\tTemplateVariable previous = null;\n\n\t\tfor (TemplateVariable variable : variables) {\n\n\t\t\tVariableType type = variable.getType();\n\t\t\ttype = appended && type.equals(REQUEST_PARAM) ? REQUEST_PARAM_CONTINUED : type;\n\n\t\t\tif (previous == null) {\n\t\t\t\tbuilder.append(\"{\").append(type.toString());\n\t\t\t} else if (!previous.isCombinable(variable)) {\n\t\t\t\tbuilder.append(\"}{\").append(type.toString());\n\t\t\t} else {\n\t\t\t\tbuilder.append(\",\");\n\t\t\t}\n\n\t\t\tprevious = variable;\n\t\t\tbuilder.append(variable.getName());\n\t\t}\n\n\t\treturn builder.append(\"}\").toString();\n\t}\n}<fim_middle>// function below has no smell\n"}