{"text": "<fim_prefix>        GregorianCalendar time = new GregorianCalendar(zone);\n        time.set(year, month, date, hourOfDay, minute, second);\n        time.set(Calendar.MILLISECOND, millis);\n        return time.getTimeInMillis();\n    }\n    public static long roundFromMillis(long millis, TimeUnit units) {\n        if (units.compareTo(TimeUnit.MILLISECONDS) > 0) {\n            double result = ((double)millis) / units.toMillis(1);\n            return Math.round(result);\n        } else {\n            return units.convert(millis, TimeUnit.MILLISECONDS);\n        }\n    }\n    public static long roundFromMillis(long millis, long millisPerUnit) {\n        double result = ((double)millis) / millisPerUnit;\n        return Math.round(result);\n    }\n    /**\n     * Calculates how long until maxTime has passed since the given startTime. \n     * However, maxTime==0 is a special case (e.g. could mean wait forever), so the result is guaranteed\n     * to be only 0 if maxTime was 0; otherwise -1 will be returned.\n     */\n    public static long timeRemaining(long startTime, long maxTime) {\n        if (maxTime == 0) {\n            return 0;\n        }\n        long result = (startTime+maxTime) - System.currentTimeMillis();\n        return (result == 0) ? -1 : result;\n    }\n    /** Convenience for {@link Duration#parse(String)}. */\n    public static Duration parseDuration(@Nullable String timeString) {\n        return Duration.parse(timeString);\n    }\n    /** \n     * As {@link #parseElapsedTimeAsDouble(String)}. Consider using {@link #parseDuration(String)} for a more usable return type.\n     * \n     * @throws NumberFormatException if cannot be parsed (or if null)\n     */\n    public static long parseElapsedTime(String timeString) {\n        return (long) parseElapsedTimeAsDouble(timeString);\n    }\n    /** \n     * Parses a string eg '5s' or '20m 22.123ms', returning the number of milliseconds it represents; \n     * -1 on blank or never or off or false.\n     * Assumes unit is millisections if no unit is specified.\n     * \n     * @throws NullPointerException if arg is null\n     * @throws NumberFormatException if cannot be parsed\n     */\n    public static double parseElapsedTimeAsDouble(final String timeStringOrig) {\n        String timeString = timeStringOrig;\n        if (timeString==null)\n            throw new NullPointerException(\"GeneralHelper.parseTimeString cannot parse a null string\");\n        try {\n            double d = Double.parseDouble(timeString);\n            return d;\n        } catch (NumberFormatException e) {\n            try {\n                //look for a type marker\n                timeString = timeString.trim();\n                String s = Strings.getLastWord(timeString).toLowerCase();\n                timeString = timeString.substring(0, timeString.length()-s.length()).trim();\n                int i=0;\n                while (s.length()>i) {\n                    char c = s.charAt(i);\n                    if (c=='.' || Character.isDigit(c)) i++;\n                    else break;\n                }\n                String num = s.substring(0, i);\n                if (i==0) {\n                    if (Strings.isNonBlank(timeString)) {\n                        num = Strings.getLastWord(timeString).toLowerCase();\n                        timeString = timeString.substring(0, timeString.length()-num.length()).trim();\n                    }\n                } else {\n                    s = s.substring(i);\n                }\n                long multiplier = 0;\n                if (num.length()==0) {\n                    //must be never or something\n                    // TODO does 'never' work?\n                    if (s.equalsIgnoreCase(\"never\") || s.equalsIgnoreCase(\"off\") || s.equalsIgnoreCase(\"false\"))\n                        return -1;\n                    throw new NumberFormatException(\"unrecognised word  '\"+s+\"' in time string\");\n                }\n                if (s.equalsIgnoreCase(\"ms\") || s.equalsIgnoreCase(\"milli\") || s.equalsIgnoreCase(\"millis\")\n                    || s.equalsIgnoreCase(\"millisec\") || s.equalsIgnoreCase(\"millisecs\")\n                    || s.equalsIgnoreCase(\"millisecond\") || s.equalsIgnoreCase(\"milliseconds\"))\n                    multiplier = 1;\n                else if (s.equalsIgnoreCase(\"s\") || s.equalsIgnoreCase(\"sec\") || s.equalsIgnoreCase(\"secs\")\n                    || s.equalsIgnoreCase(\"second\") || s.equalsIgnoreCase(\"seconds\"))\n                    multiplier = 1000;\n                else if (s.equalsIgnoreCase(\"m\") || s.equalsIgnoreCase(\"min\") || s.equalsIgnoreCase(\"mins\")\n                    || s.equalsIgnoreCase(\"minute\") || s.equalsIgnoreCase(\"minutes\"))\n                    multiplier = 60*1000;\n                else if (s.equalsIgnoreCase(\"h\") || s.equalsIgnoreCase(\"hr\") || s.equalsIgnoreCase(\"hrs\")\n                    || s.equalsIgnoreCase(\"hour\") || s.equalsIgnoreCase(\"hours\"))\n                    multiplier = 60*60*1000;\n                else if (s.equalsIgnoreCase(\"d\") || s.equalsIgnoreCase(\"day\") || s.equalsIgnoreCase(\"days\"))\n                    multiplier = 24*60*60*1000;\n                else\n                    throw new NumberFormatException(\"Unknown unit '\"+s+\"' in time string '\"+timeStringOrig+\"'\");\n                double d = Double.parseDouble(num);\n                double dd = 0;\n                if (timeString.length()>0) {\n                    dd = parseElapsedTimeAsDouble(timeString);\n                    if (dd==-1) {\n                        throw new NumberFormatException(\"Cannot combine '\"+timeString+\"' with '\"+num+\" \"+s+\"'\");\n                    }\n                }\n                return d*multiplier + dd;\n            } catch (Exception ex) {\n                if (ex instanceof NumberFormatException) throw (NumberFormatException)ex;\n                log.trace(\"Details of parse failure:\", ex);\n                throw new NumberFormatException(\"Cannot parse time string '\"+timeStringOrig+\"'\");\n            }\n        }\n    }\n    public static Calendar newCalendarFromMillisSinceEpochUtc(long timestamp) {\n        GregorianCalendar cal = new GregorianCalendar();\n        cal.setTimeInMillis(timestamp);\n        return cal;\n    }\n    public static Calendar newCalendarFromDate(Date date) {\n        return newCalendarFromMillisSinceEpochUtc(date.getTime());\n    }\n    /** As {@link #parseCalendar(String)} but returning a {@link Date},\n     * (i.e. a record where the time zone has been applied and forgotten). */\n    public static Date parseDate(@Nullable String input) {\n        if (input==null) return null;\n        return parseCalendarMaybe(input).get().getTime();\n    }\n    /** Parses dates from string, accepting many formats including ISO-8601 and http://yaml.org/type/timestamp.html, \n     * e.g. 2015-06-15 16:00:00 +0000.\n     * <p>\n     * Millis since epoch (1970) is also supported to represent the epoch (0) or dates in this millenium,\n     * but to prevent ambiguity of e.g. \"20150615\", any other dates prior to the year 2001 are not accepted.\n     * (However if a type Long is supplied, e.g. from a YAML parse, it will always be treated as millis since epoch.) \n     * <p>\n     * Other formats including locale-specific variants, e.g. recognising month names,\n     * are supported but this may vary from platform to platform and may change between versions. */\n    public static Calendar parseCalendar(@Nullable String input) {\n        if (input==null) return null;\n        return parseCalendarMaybe(input).get();\n    }\n    /** as {@link #parseCalendar(String)} but returning a {@link Maybe} rather than throwing or returning null */\n    public static Maybe<Calendar> parseCalendarMaybe(@Nullable String input) {\n        if (input==null) return Maybe.absent(\"value is null\");\n        input = input.trim();\n        Maybe<Calendar> result;\n        result = parseCalendarUtc(input);\n        if (result.isPresent()) return result;\n        result = parseCalendarSimpleFlexibleFormatParser(input);\n        if (result.isPresent()) return result;\n        // return the error from this method\n        Maybe<Calendar> returnResult = result;\n        result = parseCalendarFormat(input, new SimpleDateFormat(DATE_FORMAT_OF_DATE_TOSTRING, Locale.ROOT));\n        if (result.isPresent()) return result;\n        result = parseCalendarDefaultParse(input);\n        if (result.isPresent()) return result;\n        return returnResult;\n    }\n<fim_suffix>    @SuppressWarnings(\"deprecation\")\n    private static Maybe<Calendar> parseCalendarDefaultParse(String input) {\n        try {\n            long ms = Date.parse(input);\n            if (ms>=new Date(1999, 12, 25).getTime() && ms <= new Date(2200, 1, 2).getTime()) {\n                // accept default date parse for this century and next\n                GregorianCalendar c = new GregorianCalendar();\n                c.setTimeInMillis(ms);\n                return Maybe.of((Calendar)c);\n            }\n        } catch (Exception e) {\n            Exceptions.propagateIfFatal(e);\n        }\n        return Maybe.absent();\n    }<fim_middle>// function below has no smell\n"}