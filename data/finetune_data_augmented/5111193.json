{"text": "<fim_prefix>  * form is \"editjob\".\n  *@param out is the output to which any HTML should be sent.\n  *@param locale is the preferred local of the output.\n  *@param os is the current pipeline specification for this job.\n  *@param connectionSequenceNumber is the unique number of this connection within the job.\n  *@param actualSequenceNumber is the connection within the job that has currently been selected.\n  *@param tabName is the current tab name.\n  */\n  @Override\n  public void outputSpecificationBody(IHTTPOutput out, Locale locale, Specification os,\n    int connectionSequenceNumber, int actualSequenceNumber, String tabName)\n    throws ManifoldCFException, IOException {\n    super.outputSpecificationBody(out, locale, os, connectionSequenceNumber, actualSequenceNumber, tabName);\n    HDFSOutputSpecs specs = getSpecParameters(os);\n    outputResource(EDIT_SPECIFICATION_HTML, out, locale, specs, tabName, new Integer(connectionSequenceNumber), new Integer(actualSequenceNumber));\n  }\n  /** Process a specification post.\n  * This method is called at the start of job's edit or view page, whenever there is a possibility that form data for a connection has been\n  * posted.  Its purpose is to gather form information and modify the transformation specification accordingly.\n  * The name of the posted form is \"editjob\".\n  *@param variableContext contains the post data, including binary file-upload information.\n  *@param locale is the preferred local of the output.\n  *@param os is the current pipeline specification for this job.\n  *@param connectionSequenceNumber is the unique number of this connection within the job.\n  *@return null if all is well, or a string error message if there is an error that should prevent saving of the job (and cause a redirection to an error page).\n  */\n  @Override\n  public String processSpecificationPost(IPostParameters variableContext, Locale locale, Specification os,\n    int connectionSequenceNumber)\n    throws ManifoldCFException {\n    ConfigurationNode specNode = getSpecNode(os);\n    boolean bAdd = (specNode == null);\n    if (bAdd) {\n      specNode = new SpecificationNode(ParameterEnum.rootpath.name());\n    }\n    HDFSOutputSpecs.contextToSpecNode(variableContext, specNode, connectionSequenceNumber);\n    if (bAdd) {\n      os.addChild(os.getChildCount(), specNode);\n    }\n    return null;\n  }\n  /** View specification.\n  * This method is called in the body section of a job's view page.  Its purpose is to present the pipeline specification information to the user.\n  * The coder can presume that the HTML that is output from this configuration will be within appropriate <html> and <body> tags.\n  *@param out is the output to which any HTML should be sent.\n  *@param locale is the preferred local of the output.\n  *@param connectionSequenceNumber is the unique number of this connection within the job.\n  *@param os is the current pipeline specification for this job.\n  */\n  @Override\n  public void viewSpecification(IHTTPOutput out, Locale locale, Specification os,\n    int connectionSequenceNumber)\n    throws ManifoldCFException, IOException {\n    outputResource(VIEW_SPECIFICATION_HTML, out, locale, getSpecParameters(os), null, new Integer(connectionSequenceNumber), null);\n  }\n  /**\n   * @param os\n   * @return\n   */\n  final private SpecificationNode getSpecNode(Specification os)\n  {\n    int l = os.getChildCount();\n    for (int i = 0; i < l; i++) {\n      SpecificationNode node = os.getChild(i);\n      if (node.getType().equals(ParameterEnum.rootpath.name())) {\n        return node;\n      }\n    }\n    return null;\n  }\n  /**\n   * @param os\n   * @return\n   * @throws ManifoldCFException\n   */\n  final private HDFSOutputSpecs getSpecParameters(Specification os) throws ManifoldCFException {\n    return new HDFSOutputSpecs(getSpecNode(os));\n  }\n  /**\n   * @param configParams\n   * @return\n   */\n  final private HDFSOutputConfig getConfigParameters(ConfigParams configParams) {\n    if (configParams == null)\n      configParams = getConfiguration();\n    return new HDFSOutputConfig(configParams);\n  }\n  /** Read the content of a resource, replace the variable ${PARAMNAME} with the\n   * value and copy it to the out.\n   * \n   * @param resName\n   * @param out\n   * @throws ManifoldCFException */\n  private static void outputResource(String resName, IHTTPOutput out, Locale locale, HDFSOutputParam params, String tabName, Integer sequenceNumber, Integer actualSequenceNumber) throws ManifoldCFException {\n    Map<String,String> paramMap = null;\n    if (params != null) {\n      paramMap = params.buildMap();\n      if (tabName != null) {\n        paramMap.put(\"TabName\", tabName);\n      }\n      if (actualSequenceNumber != null)\n        paramMap.put(\"SelectedNum\",actualSequenceNumber.toString());\n    }\n    else\n    {\n      paramMap = new HashMap<String,String>();\n    }\n    if (sequenceNumber != null)\n      paramMap.put(\"SeqNum\",sequenceNumber.toString());\n    Messages.outputResourceWithVelocity(out, locale, resName, paramMap, true);\n  }\n  /**\n   * @param documentURI\n   * @return\n   * @throws URISyntaxException\n   */\n  final private String documentURItoFilePath(String documentURI) throws URISyntaxException {\n    StringBuffer path = new StringBuffer();\n    URI uri = null;\n    uri = new URI(documentURI);\n    if (uri.getScheme() != null) {\n      path.append(uri.getScheme());\n      path.append(\"/\");\n    }\n    if (uri.getHost() != null) {\n      path.append(uri.getHost());\n      if (uri.getPort() != -1) {\n        path.append(\":\");\n        path.append(Integer.toString(uri.getPort()));\n      }\n      if (uri.getRawPath() != null) {\n        if (uri.getRawPath().length() == 0) {\n          path.append(\"/\");\n        } else if (uri.getRawPath().equals(\"/\")) {\n          path.append(uri.getRawPath());\n        } else {\n          for (String name : uri.getRawPath().split(\"/\")) {\n            if (name != null && name.length() > 0) {\n              path.append(\"/\");\n              path.append(name);\n            }\n          }\n        }\n      }\n      if (uri.getRawQuery() != null) {\n        path.append(\"?\");\n        path.append(uri.getRawQuery());\n      }\n    } else {\n      if (uri.getRawSchemeSpecificPart() != null) {\n        for (String name : uri.getRawSchemeSpecificPart().split(\"/\")) {\n          if (name != null && name.length() > 0) {\n            path.append(\"/\");\n            path.append(name);\n          }\n        }\n      }\n    }\n    if (path.toString().endsWith(\"/\")) {\n      path.append(\".content\");\n    }\n    return path.toString();\n  }\n  /** Handle URISyntaxException */\n  protected static void handleURISyntaxException(URISyntaxException e)\n    throws ManifoldCFException, ServiceInterruption\n  {\n    Logging.agents.error(\"Namenode URI is malformed: \"+e.getMessage(),e);\n    throw new ManifoldCFException(\"Namenode URI is malformed: \"+e.getMessage(),e);\n  }\n  /** Handle IOException */\n  protected static void handleIOException(IOException e)\n    throws ManifoldCFException, ServiceInterruption\n  {\n    if (!(e instanceof java.net.SocketTimeoutException) && (e instanceof InterruptedIOException)) {\n      throw new ManifoldCFException(\"Interrupted: \" + e.getMessage(), e, ManifoldCFException.INTERRUPTED);\n    }\n    long currentTime = System.currentTimeMillis();\n    Logging.agents.warn(\"HDFS output connection: IO exception: \"+e.getMessage(),e);\n    throw new ServiceInterruption(\"IO exception: \"+e.getMessage(), e, currentTime + 300000L, currentTime + 3 * 60 * 60000L,-1,false);\n  }\n<fim_suffix>  protected static class CreateFileThread extends Thread {\n    protected final HDFSSession session;\n    protected final Path path;\n    protected final InputStream input;\n    protected Throwable exception = null;\n    public CreateFileThread(HDFSSession session, Path path, InputStream input) {\n      super();\n      this.session = session;\n      this.path = path;\n      this.input = input;\n      setDaemon(true);\n    }\n    public void run() {\n      try {\n        session.createFile(path,input);\n      } catch (Throwable e) {\n        this.exception = e;\n      }\n    }\n    public void finishUp() throws InterruptedException, IOException {\n      join();\n      Throwable thr = exception;\n      if (thr != null) {\n        if (thr instanceof IOException) {\n          throw (IOException) thr;\n        } else if (thr instanceof RuntimeException) {\n          throw (RuntimeException) thr;\n        } else {\n          throw (Error) thr;\n        }\n      }\n    }\n  }<fim_middle>// class below has no smell\n"}