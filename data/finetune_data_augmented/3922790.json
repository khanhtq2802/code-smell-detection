{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.accumulo.tserver.replication;\n\nimport java.io.DataInputStream;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\n\nimport org.apache.accumulo.core.client.BatchWriter;\nimport org.apache.accumulo.core.client.BatchWriterConfig;\nimport org.apache.accumulo.core.client.MutationsRejectedException;\nimport org.apache.accumulo.core.client.TableNotFoundException;\nimport org.apache.accumulo.core.clientImpl.ClientContext;\nimport org.apache.accumulo.core.conf.Property;\nimport org.apache.accumulo.core.data.ColumnUpdate;\nimport org.apache.accumulo.core.data.Mutation;\nimport org.apache.accumulo.core.replication.AccumuloReplicationReplayer;\nimport org.apache.accumulo.core.replication.thrift.RemoteReplicationErrorCode;\nimport org.apache.accumulo.core.replication.thrift.RemoteReplicationException;\nimport org.apache.accumulo.core.replication.thrift.WalEdits;\nimport org.apache.accumulo.core.security.ColumnVisibility;\nimport org.apache.accumulo.core.util.ByteBufferUtil;\nimport org.apache.accumulo.server.data.ServerMutation;\nimport org.apache.accumulo.tserver.logger.LogFileKey;\nimport org.apache.accumulo.tserver.logger.LogFileValue;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Use a BatchWriter to replay WAL entries to an Accumulo table. This assumes that all WAL entries\n * are for this table. Pruning out undesired entries is expected to be done by the sender.\n */\n<fim_suffix>public class BatchWriterReplicationReplayer implements AccumuloReplicationReplayer {\n  private static final Logger log = LoggerFactory.getLogger(BatchWriterReplicationReplayer.class);\n\n  @Override\n  public long replicateLog(ClientContext context, String tableName, WalEdits data)\n      throws RemoteReplicationException {\n    final LogFileKey key = new LogFileKey();\n    final LogFileValue value = new LogFileValue();\n    final long memoryInBytes = context.getConfiguration()\n        .getAsBytes(Property.TSERV_REPLICATION_BW_REPLAYER_MEMORY);\n\n    BatchWriter bw = null;\n    long mutationsApplied = 0L;\n    try {\n      for (ByteBuffer edit : data.getEdits()) {\n        DataInputStream dis = new DataInputStream(ByteBufferUtil.toByteArrayInputStream(edit));\n        try {\n          key.readFields(dis);\n          // TODO this is brittle because AccumuloReplicaSystem isn't actually calling\n          // LogFileValue.write, but we're expecting\n          // what we receive to be readable by the LogFileValue.\n          value.readFields(dis);\n        } catch (IOException e) {\n          log.error(\"Could not deserialize edit from stream\", e);\n          throw new RemoteReplicationException(RemoteReplicationErrorCode.COULD_NOT_DESERIALIZE,\n              \"Could not deserialize edit from stream\");\n        }\n\n        // Create the batchScanner if we don't already have one.\n        if (bw == null) {\n          BatchWriterConfig bwConfig = new BatchWriterConfig();\n          bwConfig.setMaxMemory(memoryInBytes);\n          try {\n            bw = context.createBatchWriter(tableName, bwConfig);\n          } catch (TableNotFoundException e) {\n            throw new RemoteReplicationException(RemoteReplicationErrorCode.TABLE_DOES_NOT_EXIST,\n                \"Table \" + tableName + \" does not exist\");\n          }\n        }\n\n        log.info(\"Applying {} mutations to table {} as part of batch\", value.mutations.size(),\n            tableName);\n\n        // If we got a ServerMutation, we have to make sure that we preserve the systemTimestamp\n        // otherwise\n        // the local system will assign a new timestamp.\n        List<Mutation> mutationsCopy = new ArrayList<>(value.mutations.size());\n        long mutationsCopied = 0L;\n        for (Mutation orig : value.mutations) {\n          if (orig instanceof ServerMutation) {\n            mutationsCopied++;\n\n            ServerMutation origServer = (ServerMutation) orig;\n            Mutation copy = new Mutation(orig.getRow());\n            for (ColumnUpdate update : orig.getUpdates()) {\n              long timestamp;\n\n              // If the update doesn't have a timestamp, pull it from the ServerMutation\n              if (!update.hasTimestamp()) {\n                timestamp = origServer.getSystemTimestamp();\n              } else {\n                timestamp = update.getTimestamp();\n              }\n\n              // TODO ACCUMULO-2937 cache the CVs\n              if (update.isDeleted()) {\n                copy.putDelete(update.getColumnFamily(), update.getColumnQualifier(),\n                    new ColumnVisibility(update.getColumnVisibility()), timestamp);\n              } else {\n                copy.put(update.getColumnFamily(), update.getColumnQualifier(),\n                    new ColumnVisibility(update.getColumnVisibility()), timestamp,\n                    update.getValue());\n              }\n            }\n\n            // We also need to preserve the replicationSource information to prevent cycles\n            Set<String> replicationSources = orig.getReplicationSources();\n            if (replicationSources != null && !replicationSources.isEmpty()) {\n              for (String replicationSource : replicationSources) {\n                copy.addReplicationSource(replicationSource);\n              }\n            }\n\n            mutationsCopy.add(copy);\n          } else {\n            mutationsCopy.add(orig);\n          }\n        }\n\n        log.debug(\"Copied {} mutations to ensure server-assigned timestamps are propagated\",\n            mutationsCopied);\n\n        try {\n          bw.addMutations(mutationsCopy);\n        } catch (MutationsRejectedException e) {\n          log.error(\"Could not apply mutations to {}\", tableName);\n          throw new RemoteReplicationException(RemoteReplicationErrorCode.COULD_NOT_APPLY,\n              \"Could not apply mutations to \" + tableName);\n        }\n\n        log.debug(\"{} mutations added to the BatchScanner\", mutationsCopy.size());\n\n        mutationsApplied += mutationsCopy.size();\n      }\n    } finally {\n      if (bw != null) {\n        try {\n          bw.close();\n        } catch (MutationsRejectedException e) {\n          log.error(\"Could not apply mutations to {}\", tableName);\n          throw new RemoteReplicationException(RemoteReplicationErrorCode.COULD_NOT_APPLY,\n              \"Could not apply mutations to \" + tableName);\n        }\n      }\n    }\n\n    log.info(\"Applied {} mutations in total to {}\", mutationsApplied, tableName);\n\n    return mutationsApplied;\n  }\n\n}<fim_middle>// class below is blob\n"}