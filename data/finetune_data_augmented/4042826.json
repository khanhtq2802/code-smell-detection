{"text": "<fim_prefix> * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.external.input.record.reader.hdfs;\nimport java.io.IOException;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.fs.FSDataInputStream;\nimport org.apache.hadoop.io.Text;\n<fim_suffix>public class HDFSTextLineReader {\n    private static final int DEFAULT_BUFFER_SIZE = 32 * 1024;\n    private int bufferSize = DEFAULT_BUFFER_SIZE;\n    private FSDataInputStream reader;\n    private byte[] buffer;\n    // the number of bytes of real data in the buffer\n    private int bufferLength = 0;\n    // the current position in the buffer\n    private int bufferPosn = 0;\n    private long currentFilePos = 0L;\n    private static final byte CR = '\\r';\n    private static final byte LF = '\\n';\n    public static final String KEY_BUFFER_SIZE = \"io.file.buffer.size\";\n    /**\n     * Create a line reader that reads from the given stream using the\n     * default buffer-size (32k).\n     *\n     * @param in\n     *            The input stream\n     * @throws IOException\n     */\n    public HDFSTextLineReader(FSDataInputStream in) throws IOException {\n        this(in, DEFAULT_BUFFER_SIZE);\n    }\n    /**\n     * Create a line reader that reads from the given stream using the\n     * given buffer-size.\n     *\n     * @param in\n     *            The input stream\n     * @param bufferSize\n     *            Size of the read buffer\n     * @throws IOException\n     */\n    public HDFSTextLineReader(FSDataInputStream in, int bufferSize) throws IOException {\n        this.reader = in;\n        this.bufferSize = bufferSize;\n        this.buffer = new byte[this.bufferSize];\n        currentFilePos = in.getPos();\n    }\n    public HDFSTextLineReader() throws IOException {\n        this.bufferSize = DEFAULT_BUFFER_SIZE;\n        this.buffer = new byte[this.bufferSize];\n    }\n    /**\n     * Create a line reader that reads from the given stream using the <code>io.file.buffer.size</code> specified in the given <code>Configuration</code>.\n     *\n     * @param in\n     *            input stream\n     * @param conf\n     *            configuration\n     * @throws IOException\n     */\n    public HDFSTextLineReader(FSDataInputStream in, Configuration conf) throws IOException {\n        this(in, conf.getInt(KEY_BUFFER_SIZE, DEFAULT_BUFFER_SIZE));\n    }\n    /**\n     * Read one line from the InputStream into the given Text. A line\n     * can be terminated by one of the following: '\\n' (LF) , '\\r' (CR),\n     * or '\\r\\n' (CR+LF). EOF also terminates an otherwise unterminated\n     * line.\n     *\n     * @param str\n     *            the object to store the given line (without newline)\n     * @param maxLineLength\n     *            the maximum number of bytes to store into str;\n     *            the rest of the line is silently discarded.\n     * @param maxBytesToConsume\n     *            the maximum number of bytes to consume\n     *            in this call. This is only a hint, because if the line cross\n     *            this threshold, we allow it to happen. It can overshoot\n     *            potentially by as much as one buffer length.\n     * @return the number of bytes read including the (longest) newline\n     *         found.\n     * @throws IOException\n     *             if the underlying stream throws\n     */\n    public int readLine(Text str, int maxLineLength, int maxBytesToConsume) throws IOException {\n        /* We're reading data from in, but the head of the stream may be\n         * already buffered in buffer, so we have several cases:\n         * 1. No newline characters are in the buffer, so we need to copy\n         *    everything and read another buffer from the stream.\n         * 2. An unambiguously terminated line is in buffer, so we just\n         *    copy to str.\n         * 3. Ambiguously terminated line is in buffer, i.e. buffer ends\n         *    in CR.  In this case we copy everything up to CR to str, but\n         *    we also need to see what follows CR: if it's LF, then we\n         *    need consume LF as well, so next call to readLine will read\n         *    from after that.\n         * We use a flag prevCharCR to signal if previous character was CR\n         * and, if it happens to be at the end of the buffer, delay\n         * consuming it until we have a chance to look at the char that\n         * follows.\n         */\n        str.clear();\n        int txtLength = 0; //tracks str.getLength(), as an optimization\n        int newlineLength = 0; //length of terminating newline\n        boolean prevCharCR = false; //true of prev char was CR\n        long bytesConsumed = 0;\n        do {\n            int startPosn = bufferPosn; //starting from where we left off the last time\n            if (bufferPosn >= bufferLength) {\n                startPosn = bufferPosn = 0;\n                if (prevCharCR)\n                    ++bytesConsumed; //account for CR from previous read\n                bufferLength = reader.read(buffer);\n                if (bufferLength <= 0)\n                    break; // EOF\n            }\n            for (; bufferPosn < bufferLength; ++bufferPosn) { //search for newline\n                if (buffer[bufferPosn] == LF) {\n                    newlineLength = (prevCharCR) ? 2 : 1;\n                    ++bufferPosn; // at next invocation proceed from following byte\n                    break;\n                }\n                if (prevCharCR) { //CR + notLF, we are at notLF\n                    newlineLength = 1;\n                    break;\n                }\n                prevCharCR = (buffer[bufferPosn] == CR);\n            }\n            int readLength = bufferPosn - startPosn;\n            if (prevCharCR && newlineLength == 0)\n                --readLength; //CR at the end of the buffer\n            bytesConsumed += readLength;\n            int appendLength = readLength - newlineLength;\n            if (appendLength > maxLineLength - txtLength) {\n                appendLength = maxLineLength - txtLength;\n            }\n            if (appendLength > 0) {\n                str.append(buffer, startPosn, appendLength);\n                txtLength += appendLength;\n            }\n        } while (newlineLength == 0 && bytesConsumed < maxBytesToConsume);\n        if (bytesConsumed > Integer.MAX_VALUE)\n            throw new IOException(\"Too many bytes before newline: \" + bytesConsumed);\n        currentFilePos = reader.getPos() - bufferLength + bufferPosn;\n        return (int) bytesConsumed;\n    }\n    /**\n     * Read from the InputStream into the given Text.\n     *\n     * @param str\n     *            the object to store the given line\n     * @param maxLineLength\n     *            the maximum number of bytes to store into str.\n     * @return the number of bytes read including the newline\n     * @throws IOException\n     *             if the underlying stream throws\n     */\n    public int readLine(Text str, int maxLineLength) throws IOException {\n        return readLine(str, maxLineLength, Integer.MAX_VALUE);\n    }\n    /**\n     * Read from the InputStream into the given Text.\n     *\n     * @param str\n     *            the object to store the given line\n     * @return the number of bytes read including the newline\n     * @throws IOException\n     *             if the underlying stream throws\n     */\n    public int readLine(Text str) throws IOException {\n        return readLine(str, Integer.MAX_VALUE, Integer.MAX_VALUE);\n    }\n    public void seek(long desired) throws IOException {\n        if (reader.getPos() <= desired || currentFilePos > desired) {\n            // desired position is ahead of stream or before the current position, seek to position\n            reader.seek(desired);\n            bufferLength = 0;\n            bufferPosn = 0;\n            currentFilePos = desired;\n        } else if (currentFilePos < desired) {\n            // desired position is in the buffer\n            int difference = (int) (desired - currentFilePos);\n            bufferPosn += difference;\n            currentFilePos = desired;\n        }\n    }\n    public FSDataInputStream getReader() {\n        return reader;\n    }\n    public void resetReader(FSDataInputStream reader) throws IOException {\n        this.reader = reader;\n        bufferLength = 0;\n        bufferPosn = 0;\n        currentFilePos = reader.getPos();\n    }\n    public void close() throws IOException {\n        reader.close();\n    }\n}<fim_middle>// class below has no smell\n"}