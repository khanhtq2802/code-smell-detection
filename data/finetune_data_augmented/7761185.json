{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.druid.query.aggregation.datasketches.theta;\n\nimport com.fasterxml.jackson.annotation.JsonCreator;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.Ordering;\nimport com.google.common.primitives.Doubles;\nimport org.apache.druid.query.aggregation.AggregatorFactory;\nimport org.apache.druid.query.aggregation.PostAggregator;\nimport org.apache.druid.query.aggregation.post.PostAggregatorIds;\nimport org.apache.druid.query.cache.CacheKeyBuilder;\n\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class SketchEstimatePostAggregator implements PostAggregator\n{\n\n  private final String name;\n  private final PostAggregator field;\n  private final Integer errorBoundsStdDev;\n\n  @JsonCreator\n  public SketchEstimatePostAggregator(\n      @JsonProperty(\"name\") String name,\n      @JsonProperty(\"field\") PostAggregator field,\n      @JsonProperty(\"errorBoundsStdDev\") Integer errorBoundsStdDev\n  )\n  {\n    this.name = Preconditions.checkNotNull(name, \"name is null\");\n    this.field = Preconditions.checkNotNull(field, \"field is null\");\n    this.errorBoundsStdDev = errorBoundsStdDev;\n  }\n\n  @Override\n  public Set<String> getDependentFields()\n  {\n    Set<String> dependentFields = new HashSet<>();\n    dependentFields.addAll(field.getDependentFields());\n    return dependentFields;\n  }\n\n  @Override\n  public Comparator getComparator()\n  {\n    if (errorBoundsStdDev == null) {\n      return Ordering.natural();\n    } else {\n      return new Comparator()\n      {\n        @Override\n        public int compare(Object o1, Object o2)\n        {\n          return Doubles.compare(\n              ((SketchEstimateWithErrorBounds) o1).getEstimate(),\n              ((SketchEstimateWithErrorBounds) o2).getEstimate()\n          );\n        }\n      };\n    }\n  }\n\n  @Override\n  public Object compute(Map<String, Object> combinedAggregators)\n  {\n    SketchHolder holder = (SketchHolder) field.compute(combinedAggregators);\n    if (errorBoundsStdDev != null) {\n      return holder.getEstimateWithErrorBounds(errorBoundsStdDev);\n    } else {\n      return holder.getEstimate();\n    }\n  }\n\n  @Override\n  @JsonProperty\n  public String getName()\n  {\n    return name;\n  }\n\n  @Override\n  public PostAggregator decorate(Map<String, AggregatorFactory> aggregators)\n  {\n    return this;\n  }\n\n  @JsonProperty\n  public PostAggregator getField()\n  {\n    return field;\n  }\n\n  @JsonProperty\n  public Integer getErrorBoundsStdDev()\n  {\n    return errorBoundsStdDev;\n  }\n\n  @Override\n  public String toString()\n  {\n    return \"SketchEstimatePostAggregator{\" +\n        \"name='\" + name + '\\'' +\n        \", field=\" + field +\n        \", errorBoundsStdDev=\" + errorBoundsStdDev +\n        \"}\";\n  }\n\n  @Override\n  public boolean equals(Object o)\n  {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n\n    SketchEstimatePostAggregator that = (SketchEstimatePostAggregator) o;\n\n    if (!name.equals(that.name)) {\n      return false;\n    }\n    \n    if (errorBoundsStdDev == null ^ that.errorBoundsStdDev == null) {\n      // one of the two stddevs (not both) are null\n      return false;\n    }\n    \n    if (errorBoundsStdDev != null && that.errorBoundsStdDev != null && \n        errorBoundsStdDev.intValue() != that.errorBoundsStdDev.intValue()) {\n      // neither stddevs are null, Integer values don't match\n      return false;\n    }\n\n    return field.equals(that.field);\n\n  }\n\n<fim_suffix>  @Override\n  public int hashCode()\n  {\n    int result = name.hashCode();\n    result = 31 * result + field.hashCode();\n    result = 31 * result + (errorBoundsStdDev != null ? errorBoundsStdDev.hashCode() : 0);\n    return result;\n  }\n\n  @Override\n  public byte[] getCacheKey()\n  {\n    final CacheKeyBuilder builder = new CacheKeyBuilder(PostAggregatorIds.DATA_SKETCHES_SKETCH_ESTIMATE)\n        .appendCacheable(field);\n    return errorBoundsStdDev == null ? builder.build() : builder.appendInt(errorBoundsStdDev).build();\n  }\n}<fim_middle>// function below has no smell\n"}