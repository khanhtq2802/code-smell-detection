{"text": "<fim_prefix> * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage java.io;\nimport java.io.InputStream;\nimport java.util.Enumeration;\nimport java.util.Vector;\n/**\n * A <code>SequenceInputStream</code> represents\n * the logical concatenation of other input\n * streams. It starts out with an ordered\n * collection of input streams and reads from\n * the first one until end of file is reached,\n * whereupon it reads from the second one,\n * and so on, until end of file is reached\n * on the last of the contained input streams.\n *\n * @author  Author van Hoff\n * @since   JDK1.0\n */\n<fim_suffix>public\nclass SequenceInputStream extends InputStream {\n    Enumeration<? extends InputStream> e;\n    InputStream in;\n    /**\n     * Initializes a newly created <code>SequenceInputStream</code>\n     * by remembering the argument, which must\n     * be an <code>Enumeration</code>  that produces\n     * objects whose run-time type is <code>InputStream</code>.\n     * The input streams that are  produced by\n     * the enumeration will be read, in order,\n     * to provide the bytes to be read  from this\n     * <code>SequenceInputStream</code>. After\n     * each input stream from the enumeration\n     * is exhausted, it is closed by calling its\n     * <code>close</code> method.\n     *\n     * @param   e   an enumeration of input streams.\n     * @see     java.util.Enumeration\n     */\n    public SequenceInputStream(Enumeration<? extends InputStream> e) {\n        this.e = e;\n        try {\n            nextStream();\n        } catch (IOException ex) {\n            // This should never happen\n            throw new Error(\"panic\");\n        }\n    }\n    /**\n     * Initializes a newly\n     * created <code>SequenceInputStream</code>\n     * by remembering the two arguments, which\n     * will be read in order, first <code>s1</code>\n     * and then <code>s2</code>, to provide the\n     * bytes to be read from this <code>SequenceInputStream</code>.\n     *\n     * @param   s1   the first input stream to read.\n     * @param   s2   the second input stream to read.\n     */\n    public SequenceInputStream(InputStream s1, InputStream s2) {\n        Vector<InputStream> v = new Vector<>(2);\n        v.addElement(s1);\n        v.addElement(s2);\n        e = v.elements();\n        try {\n            nextStream();\n        } catch (IOException ex) {\n            // This should never happen\n            throw new Error(\"panic\");\n        }\n    }\n    /**\n     *  Continues reading in the next stream if an EOF is reached.\n     */\n    final void nextStream() throws IOException {\n        if (in != null) {\n            in.close();\n        }\n        if (e.hasMoreElements()) {\n            in = (InputStream) e.nextElement();\n            if (in == null)\n                throw new NullPointerException();\n        }\n        else in = null;\n    }\n    /**\n     * Returns an estimate of the number of bytes that can be read (or\n     * skipped over) from the current underlying input stream without\n     * blocking by the next invocation of a method for the current\n     * underlying input stream. The next invocation might be\n     * the same thread or another thread.  A single read or skip of this\n     * many bytes will not block, but may read or skip fewer bytes.\n     * <p>\n     * This method simply calls {@code available} of the current underlying\n     * input stream and returns the result.\n     *\n     * @return an estimate of the number of bytes that can be read (or\n     *         skipped over) from the current underlying input stream\n     *         without blocking or {@code 0} if this input stream\n     *         has been closed by invoking its {@link #close()} method\n     * @exception  IOException  if an I/O error occurs.\n     *\n     * @since   JDK1.1\n     */\n    public int available() throws IOException {\n        if (in == null) {\n            return 0; // no way to signal EOF from available()\n        }\n        return in.available();\n    }\n    /**\n     * Reads the next byte of data from this input stream. The byte is\n     * returned as an <code>int</code> in the range <code>0</code> to\n     * <code>255</code>. If no byte is available because the end of the\n     * stream has been reached, the value <code>-1</code> is returned.\n     * This method blocks until input data is available, the end of the\n     * stream is detected, or an exception is thrown.\n     * <p>\n     * This method\n     * tries to read one character from the current substream. If it\n     * reaches the end of the stream, it calls the <code>close</code>\n     * method of the current substream and begins reading from the next\n     * substream.\n     *\n     * @return     the next byte of data, or <code>-1</code> if the end of the\n     *             stream is reached.\n     * @exception  IOException  if an I/O error occurs.\n     */\n    public int read() throws IOException {\n        while (in != null) {\n            int c = in.read();\n            if (c != -1) {\n                return c;\n            }\n            nextStream();\n        }\n        return -1;\n    }\n    /**\n     * Reads up to <code>len</code> bytes of data from this input stream\n     * into an array of bytes.  If <code>len</code> is not zero, the method\n     * blocks until at least 1 byte of input is available; otherwise, no\n     * bytes are read and <code>0</code> is returned.\n     * <p>\n     * The <code>read</code> method of <code>SequenceInputStream</code>\n     * tries to read the data from the current substream. If it fails to\n     * read any characters because the substream has reached the end of\n     * the stream, it calls the <code>close</code> method of the current\n     * substream and begins reading from the next substream.\n     *\n     * @param      b     the buffer into which the data is read.\n     * @param      off   the start offset in array <code>b</code>\n     *                   at which the data is written.\n     * @param      len   the maximum number of bytes read.\n     * @return     int   the number of bytes read.\n     * @exception  NullPointerException If <code>b</code> is <code>null</code>.\n     * @exception  IndexOutOfBoundsException If <code>off</code> is negative,\n     * <code>len</code> is negative, or <code>len</code> is greater than\n     * <code>b.length - off</code>\n     * @exception  IOException  if an I/O error occurs.\n     */\n    public int read(byte b[], int off, int len) throws IOException {\n        if (in == null) {\n            return -1;\n        } else if (b == null) {\n            throw new NullPointerException();\n        } else if (off < 0 || len < 0 || len > b.length - off) {\n            throw new IndexOutOfBoundsException();\n        } else if (len == 0) {\n            return 0;\n        }\n        do {\n            int n = in.read(b, off, len);\n            if (n > 0) {\n                return n;\n            }\n            nextStream();\n        } while (in != null);\n        return -1;\n    }\n    /**\n     * Closes this input stream and releases any system resources\n     * associated with the stream.\n     * A closed <code>SequenceInputStream</code>\n     * cannot  perform input operations and cannot\n     * be reopened.\n     * <p>\n     * If this stream was created\n     * from an enumeration, all remaining elements\n     * are requested from the enumeration and closed\n     * before the <code>close</code> method returns.\n     *\n     * @exception  IOException  if an I/O error occurs.\n     */\n    public void close() throws IOException {\n        do {\n            nextStream();\n        } while (in != null);\n    }\n}<fim_middle>// class below has no smell\n"}