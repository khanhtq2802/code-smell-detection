{"text": "<fim_prefix>/**\n *  Licensed to the Apache Software Foundation (ASF) under one or more\n *  contributor license agreements.  See the NOTICE file distributed with\n *  this work for additional information regarding copyright ownership.\n *  The ASF licenses this file to You under the Apache License, Version 2.0\n *  (the \"License\"); you may not use this file except in compliance with\n *  the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.apache.aries.unittest.fixture;\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.jar.Attributes;\nimport java.util.jar.JarOutputStream;\nimport java.util.jar.Manifest;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipOutputStream;\nimport org.osgi.framework.Constants;\n/**\n * Utility class for creating archive-based fixtures such as EBA archives, jar files etc.\n * This class provides a flow based api for defining such fixtures. For example, a simple EBA archive could \n * be defined as such:\n * \n * <code>\n * ArchiveFixtures.ZipFixture zip = ArchiveFixtures.newZip()\n *   .jar(\"test.jar\")\n *     .manifest()\n *       .symbolicName(\"com.ibm.test\")\n *       .version(\"2.0.0\")\n *     .end()\n *     .file(\"random.txt\", \"Some text\")\n *   .end();\n * </code>\n * \n * This defines a zip archive containing a single jar file (hence no application manifest). The jar file itself has\n * a manifest and a text file.\n * \n * To actually create the physical archive use the <code>writeOut</code> method on the archive fixture.\n */\npublic class ArchiveFixture\n{\n  /**\n   * Create a new zip file fixture\n   * @return\n   */\n  public static ZipFixture newZip() {\n    return new ZipFixture(null);\n  }\n  /**\n   * Create a new jar file fixture\n   * @return\n   */\n  public static JarFixture newJar() {\n    return new JarFixture(null);\n  }\n  /**\n   * Utility to copy an InputStream into an OutputStream. Closes the InputStream afterwards.\n   * @param in\n   * @param out\n   * @throws IOException\n   */\n  private static void copy(InputStream in, OutputStream out) throws IOException\n  {\n    try {\n      int len;\n      byte[] b = new byte[1024];\n      while ((len = in.read(b)) != -1)\n        out.write(b,0,len);\n    }\n    finally {\n      in.close();\n    }\n  }\n  /**\n   * Base interface for every fixture.\n   */\n  public interface Fixture {\n    /**\n     * Write the physical representation of the fixture to the given OutputStream\n     * @param out\n     * @throws IOException\n     */\n    void writeOut(OutputStream out) throws IOException;\n  }\n  /**\n   * Abstract base class for fixtures. Archive fixtures are by nature hierarchical.\n   */\n<fim_suffix>  public static abstract class AbstractFixture implements Fixture {\n    private ZipFixture parent;\n    protected AbstractFixture(ZipFixture parent) {\n      this.parent = parent;\n    }\n    /**\n     * Ends the current flow target and returns the parent flow target. For example, in the\n     * following code snippet the <code>end</code> after <code>.version(\"2.0.0\")</code> marks\n     * the end of the manifest. Commands after that relate to the parent jar file of the manifest.\n     * \n     * <code>\n     * ArchiveFixtures.ZipFixture zip = ArchiveFixtures.newZip()\n     *   .jar(\"test.jar\")\n     *     .manifest()\n     *       .symbolicName(\"com.ibm.test\")\n     *       .version(\"2.0.0\")\n     *     .end()\n     *     .file(\"random.txt\", \"Some text\")\n     *   .end();\n     * </code>\n     * @return\n     */\n    public ZipFixture end() {\n      return (parent == null) ? (ZipFixture) this : parent;\n    }\n  }\n  /**\n   * Simple fixture for text files.\n   */\n  public static class FileFixture extends AbstractFixture {\n    private StringBuffer text = new StringBuffer();\n    protected FileFixture(ZipFixture parent) {\n      super(parent);\n    }\n    /**\n     * Add a line to the file fixture. The EOL character is added automatically.\n     * @param line\n     * @return\n     */\n    public FileFixture line(String line) {\n      text.append(line);\n      text.append(\"\\n\");\n      return this;\n    }\n    public void writeOut(OutputStream out) throws IOException {\n      out.write(text.toString().getBytes());\n    }\n  }\n  public static class IStreamFixture extends AbstractFixture {\n    private byte[] bytes;\n    protected IStreamFixture(ZipFixture parent, InputStream input) throws IOException {\n      super(parent);\n      ByteArrayOutputStream output = new ByteArrayOutputStream();\n      try {\n        copy(input, output);\n      } finally {\n        output.close();\n      }\n      bytes = output.toByteArray();\n    }\n    public void writeOut(OutputStream out) throws IOException {\n      copy(new ByteArrayInputStream(bytes), out);\n    }\n  }\n  /**\n   * Fixture for (bundle) manifests. By default, they contain the lines\n   * \n   * <code>\n   * Manifest-Version: 1\n   * Bundle-ManifestVersion: 2\n   * </code>\n   */\n  public static class ManifestFixture extends AbstractFixture {\n    private Manifest mf;\n    protected Manifest getManifest()\n    {\n      return mf;\n    }\n    protected ManifestFixture(ZipFixture parent) {\n      super(parent);\n      mf = new Manifest();\n      mf.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION, \"1\");\n      mf.getMainAttributes().putValue(Constants.BUNDLE_MANIFESTVERSION, \"2\");\n    }\n    /**\n     * Set the symbolic name of the bundle\n     * @param name\n     * @return\n     */\n    public ManifestFixture symbolicName(String name)\n    {\n      mf.getMainAttributes().putValue(Constants.BUNDLE_SYMBOLICNAME, name);\n      return this;\n    }\n    /**\n     * Set the version of the bundle\n     * @param version\n     * @return\n     */\n    public ManifestFixture version(String version)\n    {\n      mf.getMainAttributes().putValue(Constants.BUNDLE_VERSION, version);\n      return this;\n    }\n    /**\n     * Add a custom attribute to the manifest. Use the more specific methods for symbolic name and version.\n     * @param name\n     * @param value\n     * @return\n     */\n    public ManifestFixture attribute(String name, String value)\n    {\n      mf.getMainAttributes().putValue(name, value);\n      return this;\n    }\n    public void writeOut(OutputStream out) throws IOException\n    {\n      mf.write(out);\n    }\n  }\n  /**\n   * Fixture for a jar archive. It offers the same functionality as zip fixtures.\n   * The main difference is that in a jar archive the manifest will be output as the first file,\n   * regardless of when it is added.\n   */\n  public static class JarFixture extends ZipFixture {\n    private ManifestFixture mfFixture;\n    protected JarFixture(ZipFixture parent) {\n      super(parent);\n    }\n    @Override\n    public ManifestFixture manifest()\n    {\n      if (mfFixture != null)\n        throw new IllegalStateException(\"Only one manifest allowed, you dummy ;)\");\n      mfFixture = new ManifestFixture(this);\n      return mfFixture;\n    }\n    @Override\n    public InputStream getInputStream() throws IOException\n    {\n      if (bytes == null) {\n        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n        JarOutputStream jout;\n        if (mfFixture != null)\n          jout = new JarOutputStream(bout, mfFixture.getManifest());\n        else\n          jout = new JarOutputStream(bout);\n        try {\n          writeAllEntries(jout);\n        } finally {\n          jout.close();\n        }\n        bytes = bout.toByteArray();\n      }\n      return new ByteArrayInputStream(bytes);\n    }\n  }\n  /**\n   * Base fixture for any kind of zip archive. Zip archives can contain any number of child archives \n   * given by an archive type and a path. The order in which these child archives are added is important\n   * because it will be the order in which they are added to the zip.\n   */\n  public static class ZipFixture extends AbstractFixture {\n    protected static class ChildFixture {\n      public String path;\n      public Fixture fixture;\n      public ChildFixture(String path, Fixture fixture)\n      {\n        this.path = path;\n        this.fixture = fixture;\n      }\n    }<fim_middle>// class below has no smell\n"}