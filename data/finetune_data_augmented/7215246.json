{"text": "<fim_prefix>     * @param frame the incoming frame\n     * @throws IOException if an error is encountered\n     */\n    void handleFrame(Frame frame) throws IOException {\n        AMQCommand command = _command;\n        if (command.handleFrame(frame)) { // a complete command has rolled off the assembly line\n            _command = new AMQCommand(); // prepare for the next one\n            handleCompleteInboundCommand(command);\n        }\n    }\n    /**\n     * Placeholder until we address bug 15786 (implementing a proper exception hierarchy).\n     * In the meantime, this at least won't throw away any information from the wrapped exception.\n     * @param ex the exception to wrap\n     * @return the wrapped exception\n     */\n    public static IOException wrap(ShutdownSignalException ex) {\n        return wrap(ex, null);\n    }\n    public static IOException wrap(ShutdownSignalException ex, String message) {\n        return new IOException(message, ex);\n    }\n    /**\n     * Placeholder until we address bug 15786 (implementing a proper exception hierarchy).\n     */\n    public AMQCommand exnWrappingRpc(Method m)\n        throws IOException\n    {\n        try {\n            return privateRpc(m);\n        } catch (AlreadyClosedException ace) {\n            // Do not wrap it since it means that connection/channel\n            // was closed in some action in the past\n            throw ace;\n        } catch (ShutdownSignalException ex) {\n            throw wrap(ex);\n        }\n    }\n    CompletableFuture<Command> exnWrappingAsyncRpc(Method m)\n        throws IOException\n    {\n        try {\n            return privateAsyncRpc(m);\n        } catch (AlreadyClosedException ace) {\n            // Do not wrap it since it means that connection/channel\n            // was closed in some action in the past\n            throw ace;\n        } catch (ShutdownSignalException ex) {\n            throw wrap(ex);\n        }\n    }\n    /**\n     * Private API - handle a command which has been assembled\n     * @throws IOException if there's any problem\n     *\n     * @param command the incoming command\n     * @throws IOException when operation is interrupted by an I/O exception\n     */\n    public void handleCompleteInboundCommand(AMQCommand command) throws IOException {\n        // First, offer the command to the asynchronous-command\n        // handling mechanism, which gets to act as a filter on the\n        // incoming command stream.  If processAsync() returns true,\n        // the command has been dealt with by the filter and so should\n        // not be processed further.  It will return true for\n        // asynchronous commands (deliveries/returns/other events),\n        // and false for commands that should be passed on to some\n        // waiting RPC continuation.\n        this._trafficListener.read(command);\n        if (!processAsync(command)) {\n            // The filter decided not to handle/consume the command,\n            // so it must be a response to an earlier RPC.\n            if (_checkRpcResponseType) {\n                synchronized (_channelMutex) {\n                    // check if this reply command is intended for the current waiting request before calling nextOutstandingRpc()\n                    if (_activeRpc != null && !_activeRpc.canHandleReply(command)) {\n                        // this reply command is not intended for the current waiting request\n                        // most likely a previous request timed out and this command is the reply for that.\n                        // Throw this reply command away so we don't stop the current request from waiting for its reply\n                        return;\n                    }\n                }\n            }\n            final RpcWrapper nextOutstandingRpc = nextOutstandingRpc();\n            // the outstanding RPC can be null when calling Channel#asyncRpc\n            if(nextOutstandingRpc != null) {\n                nextOutstandingRpc.complete(command);\n                markRpcFinished();\n            }\n        }\n    }\n    public void enqueueRpc(RpcContinuation k)\n    {\n        doEnqueueRpc(() -> new RpcContinuationRpcWrapper(k));\n    }\n    private void enqueueAsyncRpc(Method method, CompletableFuture<Command> future) {\n        doEnqueueRpc(() -> new CompletableFutureRpcWrapper(method, future));\n    }\n    private void doEnqueueRpc(Supplier<RpcWrapper> rpcWrapperSupplier) {\n        synchronized (_channelMutex) {\n            boolean waitClearedInterruptStatus = false;\n            while (_activeRpc != null) {\n                try {\n                    _channelMutex.wait();\n                } catch (InterruptedException e) { //NOSONAR\n                    waitClearedInterruptStatus = true;\n                    // No Sonar: we re-interrupt the thread later\n                }\n            }\n            if (waitClearedInterruptStatus) {\n                Thread.currentThread().interrupt();\n            }\n            _activeRpc = rpcWrapperSupplier.get();\n        }\n    }\n    boolean isOutstandingRpc()\n    {\n        synchronized (_channelMutex) {\n            return (_activeRpc != null);\n        }\n    }\n    public RpcWrapper nextOutstandingRpc()\n    {\n        synchronized (_channelMutex) {\n            RpcWrapper result = _activeRpc;\n            _activeRpc = null;\n            _channelMutex.notifyAll();\n            return result;\n        }\n    }\n    protected void markRpcFinished() {\n        // no-op\n    }\n    private void ensureIsOpen()\n        throws AlreadyClosedException\n    {\n        if (!isOpen()) {\n            throw new AlreadyClosedException(getCloseReason());\n        }\n    }\n    /**\n     * Protected API - sends a {@link Method} to the broker and waits for the\n     * next in-bound Command from the broker: only for use from\n     * non-connection-MainLoop threads!\n     */\n    public AMQCommand rpc(Method m)\n        throws IOException, ShutdownSignalException\n    {\n        return privateRpc(m);\n    }\n    public AMQCommand rpc(Method m, int timeout)\n            throws IOException, ShutdownSignalException, TimeoutException {\n        return privateRpc(m, timeout);\n    }\n    private AMQCommand privateRpc(Method m)\n        throws IOException, ShutdownSignalException\n    {\n        SimpleBlockingRpcContinuation k = new SimpleBlockingRpcContinuation(m);\n        rpc(m, k);\n        // At this point, the request method has been sent, and we\n        // should wait for the reply to arrive.\n        //\n        // Calling getReply() on the continuation puts us to sleep\n        // until the connection's reader-thread throws the reply over\n        // the fence or the RPC times out (if enabled)\n        if(_rpcTimeout == NO_RPC_TIMEOUT) {\n            return k.getReply();\n        } else {\n            try {\n                return k.getReply(_rpcTimeout);\n            } catch (TimeoutException e) {\n                throw wrapTimeoutException(m, e);\n            }\n        }\n    }\n    private void cleanRpcChannelState() {\n        try {\n            // clean RPC channel state\n            nextOutstandingRpc();\n            markRpcFinished();\n        } catch (Exception ex) {\n            LOGGER.warn(\"Error while cleaning timed out channel RPC: {}\", ex.getMessage());\n        }\n    }\n    /** Cleans RPC channel state after a timeout and wraps the TimeoutException in a ChannelContinuationTimeoutException */\n    ChannelContinuationTimeoutException wrapTimeoutException(final Method m, final TimeoutException e)  {\n        cleanRpcChannelState();\n        return new ChannelContinuationTimeoutException(e, this, this._channelNumber, m);\n    }\n    private CompletableFuture<Command> privateAsyncRpc(Method m)\n        throws IOException, ShutdownSignalException\n    {\n        CompletableFuture<Command> future = new CompletableFuture<>();\n        asyncRpc(m, future);\n        return future;\n    }\n    private AMQCommand privateRpc(Method m, int timeout)\n            throws IOException, ShutdownSignalException, TimeoutException {\n        SimpleBlockingRpcContinuation k = new SimpleBlockingRpcContinuation(m);\n        rpc(m, k);\n        try {\n            return k.getReply(timeout);\n        } catch (TimeoutException e) {\n            cleanRpcChannelState();\n            throw e;\n        }\n    }\n    public void rpc(Method m, RpcContinuation k)\n        throws IOException\n    {\n        synchronized (_channelMutex) {\n            ensureIsOpen();\n            quiescingRpc(m, k);\n        }\n    }\n    void quiescingRpc(Method m, RpcContinuation k)\n        throws IOException\n    {\n        synchronized (_channelMutex) {\n            enqueueRpc(k);\n            quiescingTransmit(m);\n        }\n    }\n    private void asyncRpc(Method m, CompletableFuture<Command> future)\n        throws IOException\n    {\n        synchronized (_channelMutex) {\n            ensureIsOpen();\n            quiescingAsyncRpc(m, future);\n        }\n    }\n    private void quiescingAsyncRpc(Method m, CompletableFuture<Command> future)\n        throws IOException\n    {\n        synchronized (_channelMutex) {\n            enqueueAsyncRpc(m, future);\n            quiescingTransmit(m);\n        }\n    }\n    /**\n     * Protected API - called by nextCommand to check possibly handle an incoming Command before it is returned to the caller of nextCommand. If this method\n     * returns true, the command is considered handled and is not passed back to nextCommand's caller; if it returns false, nextCommand returns the command as\n     * usual. This is used in subclasses to implement handling of Basic.Return and Basic.Deliver messages, as well as Channel.Close and Connection.Close.\n     * @param command the command to handle asynchronously\n     * @return true if we handled the command; otherwise the caller should consider it \"unhandled\"\n     */\n    public abstract boolean processAsync(Command command) throws IOException;\n<fim_suffix>    @Override public String toString() {\n        return \"AMQChannel(\" + _connection + \",\" + _channelNumber + \")\";\n    }<fim_middle>// function below has no smell\n"}