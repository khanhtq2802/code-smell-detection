{"text": "<fim_prefix>import org.eclipse.jdt.core.search.SearchMatch;\nimport org.eclipse.jdt.core.search.SearchParticipant;\nimport org.eclipse.jdt.core.search.SearchPattern;\nimport org.eclipse.jdt.core.search.SearchRequestor;\nimport org.eclipse.jdt.launching.IRuntimeClasspathEntry;\nimport org.eclipse.jdt.launching.JavaRuntime;\nimport com.microsoft.java.debug.core.Configuration;\n<fim_suffix>public class ResolveClasspathsHandler {\n    private static final Logger logger = Logger.getLogger(Configuration.LOGGER_NAME);\n    /**\n     * Resolves class path for a java project.\n     * @param arguments a list contains the main class name and  project name\n     * @return the class paths entries\n     * @throws Exception when there are any errors during resolving class path\n     */\n    public String[][] resolveClasspaths(List<Object> arguments) throws Exception {\n        try {\n            return computeClassPath((String) arguments.get(0), (String) arguments.get(1));\n        } catch (CoreException e) {\n            logger.log(Level.SEVERE, \"Failed to resolve classpath: \" + e.getMessage(), e);\n            throw new Exception(\"Failed to resolve classpath: \" + e.getMessage(), e);\n        }\n    }\n    /**\n     * Get java project from name.\n     *\n     * @param projectName\n     *            project name\n     * @return java project\n     * @throws CoreException\n     *             CoreException\n     */\n    private static IJavaProject getJavaProjectFromName(String projectName) throws CoreException {\n        IJavaProject javaProject = JdtUtils.getJavaProject(projectName);\n        if (javaProject == null) {\n            throw new CoreException(new Status(IStatus.ERROR, JavaDebuggerServerPlugin.PLUGIN_ID,\n                    String.format(\"The project '%s' is not a valid java project.\", projectName)));\n        }\n        return javaProject;\n    }\n    /**\n     * Get java project from type.\n     *\n     * @param fullyQualifiedTypeName\n     *            fully qualified name of type\n     * @return java project\n     * @throws CoreException\n     *             CoreException\n     */\n    public static List<IJavaProject> getJavaProjectFromType(String fullyQualifiedTypeName) throws CoreException {\n        // If only one Java project exists in the whole workspace, return the project directly.\n        List<IJavaProject> javaProjects = JdtUtils.listJavaProjects(ResourcesPlugin.getWorkspace().getRoot());\n        if (javaProjects.size() <= 1) {\n            return javaProjects;\n        }\n        String[] splitItems = fullyQualifiedTypeName.split(\"/\");\n        // If the main class name contains the module name, should trim the module info.\n        if (splitItems.length == 2) {\n            fullyQualifiedTypeName = splitItems[1];\n        }\n        final String moduleName = splitItems.length == 2 ? splitItems[0] : null;\n        final String className = fullyQualifiedTypeName;\n        SearchPattern pattern = SearchPattern.createPattern(\n                fullyQualifiedTypeName,\n                IJavaSearchConstants.TYPE,\n                IJavaSearchConstants.DECLARATIONS,\n                SearchPattern.R_EXACT_MATCH);\n        IJavaSearchScope scope = SearchEngine.createWorkspaceScope();\n        ArrayList<IJavaProject> projects = new ArrayList<>();\n        SearchRequestor requestor = new SearchRequestor() {\n            @Override\n            public void acceptSearchMatch(SearchMatch match) {\n                Object element = match.getElement();\n                if (element instanceof IType) {\n                    IType type = (IType) element;\n                    IJavaProject project = type.getJavaProject();\n                    if (className.equals(type.getFullyQualifiedName())\n                            && (moduleName == null || moduleName.equals(JdtUtils.getModuleName(project)))) {\n                        projects.add(project);\n                    }\n                }\n            }\n        };\n        SearchEngine searchEngine = new SearchEngine();\n        searchEngine.search(pattern, new SearchParticipant[] {\n            SearchEngine.getDefaultSearchParticipant() }, scope,\n            requestor, null /* progress monitor */);\n        return projects.stream().distinct().collect(Collectors.toList());\n    }\n    /**\n     * Accord to the project name and the main class, compute runtime classpath.\n     *\n     * @param mainClass\n     *            fully qualified class name\n     * @param projectName\n     *            project name\n     * @return class path\n     * @throws CoreException\n     *             CoreException\n     */\n    private static String[][] computeClassPath(String mainClass, String projectName) throws CoreException {\n        IJavaProject project = null;\n        // if type exists in multiple projects, debug configuration need provide\n        // project name.\n        if (StringUtils.isNotBlank(projectName)) {\n            project = getJavaProjectFromName(projectName);\n        } else {\n            List<IJavaProject> projects = getJavaProjectFromType(mainClass);\n            if (projects.size() == 0) {\n                throw new CoreException(new Status(IStatus.ERROR, JavaDebuggerServerPlugin.PLUGIN_ID,\n                        String.format(\"Main class '%s' doesn't exist in the workspace.\", mainClass)));\n            }\n            if (projects.size() > 1) {\n                throw new CoreException(new Status(IStatus.ERROR, JavaDebuggerServerPlugin.PLUGIN_ID,\n                        String.format(\n                                \"Main class '%s' isn't unique in the workspace, please pass in specified projectname.\",\n                                mainClass)));\n            }\n            project = projects.get(0);\n        }\n        return computeClassPath(project, isMainClassInTestFolder(project, mainClass));\n    }\n    /**\n     * Compute runtime classpath of a java project.\n     *\n     * @param javaProject\n     *            java project\n     * @return class path\n     * @throws CoreException\n     *             CoreException\n     */\n    private static String[][] computeClassPath(IJavaProject javaProject, boolean includeTestScope)\n            throws CoreException {\n        if (javaProject == null) {\n            throw new IllegalArgumentException(\"javaProject is null\");\n        }\n        String[][] result = new String[2][];\n        if (JavaRuntime.isModularProject(javaProject)) {\n            result[0] = computeDefaultRuntimeClassPath(javaProject, includeTestScope);\n            result[1] = new String[0];\n        } else {\n            result[0] = new String[0];\n            result[1] = computeDefaultRuntimeClassPath(javaProject, includeTestScope);\n        }\n        return result;\n    }\n    private static String[] computeDefaultRuntimeClassPath(IJavaProject jproject, boolean includeTestScope)\n            throws CoreException {\n        IRuntimeClasspathEntry[] unresolved = JavaRuntime.computeUnresolvedRuntimeClasspath(jproject);\n        Set<String> resolved = new LinkedHashSet<String>();\n        for (int i = 0; i < unresolved.length; i++) {\n            IRuntimeClasspathEntry entry = unresolved[i];\n            if (entry.getClasspathProperty() == IRuntimeClasspathEntry.USER_CLASSES) {\n                IRuntimeClasspathEntry[] entries = JavaRuntime.resolveRuntimeClasspathEntry(entry, jproject,\n                        !includeTestScope);\n                for (int j = 0; j < entries.length; j++) {\n                    if (!includeTestScope && JdtUtils.isTest(entries[j].getClasspathEntry())) {\n                        continue;\n                    }\n                    String location = entries[j].getLocation();\n                    if (location != null) {\n                        // remove duplicate classpath\n                        resolved.add(location);\n                    }\n                }\n            }\n        }\n        return resolved.toArray(new String[resolved.size()]);\n    }\n    /**\n     * Test whether the main class is located in test folders.\n     * @param project the java project containing the main class\n     * @param mainClass the main class name\n     * @return whether the main class is located in test folders\n     */\n    private static boolean isMainClassInTestFolder(IJavaProject project, String mainClass) {\n        // get a list of test folders and check whether main class is here\n        int constraints = IJavaSearchScope.SOURCES;\n        IJavaElement[] testFolders = JdtUtils.getTestPackageFragmentRoots(project);\n        if (testFolders.length > 0) {\n            try {\n                List<Object> mainClassesInTestFolder = new ArrayList<>();\n                SearchPattern pattern = SearchPattern.createPattern(mainClass, IJavaSearchConstants.CLASS,\n                        IJavaSearchConstants.DECLARATIONS,\n                        SearchPattern.R_CASE_SENSITIVE | SearchPattern.R_EXACT_MATCH);\n                SearchEngine searchEngine = new SearchEngine();\n                IJavaSearchScope scope = SearchEngine.createJavaSearchScope(testFolders, constraints);\n                SearchRequestor requestor = new SearchRequestor() {\n                    @Override\n                    public void acceptSearchMatch(SearchMatch match) {\n                        Object element = match.getElement();\n                        if (element instanceof IJavaElement) {\n                            mainClassesInTestFolder.add(element);\n                        }\n                    }\n                };\n                searchEngine.search(pattern, new SearchParticipant[] {\n                            SearchEngine.getDefaultSearchParticipant()\n                    }, scope, requestor, null /* progress monitor */);\n                return !mainClassesInTestFolder.isEmpty();\n            } catch (Exception e) {\n                logger.log(Level.SEVERE, String.format(\"Searching the main class failure: %s\", e.toString()), e);\n            }\n        }\n        return false;\n    }\n}<fim_middle>// class below has no smell\n"}