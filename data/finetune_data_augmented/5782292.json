{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.tez.runtime.library.common.security;\n\n\nimport java.io.IOException;\nimport java.net.URL;\n\nimport javax.crypto.SecretKey;\n\nimport com.google.common.base.Charsets;\nimport org.apache.commons.codec.binary.Base64;\nimport org.apache.hadoop.classification.InterfaceAudience;\nimport org.apache.hadoop.classification.InterfaceStability;\nimport org.apache.hadoop.io.WritableComparator;\nimport org.apache.tez.common.security.JobTokenSecretManager;\n\n/**\n * \n * utilities for generating kyes, hashes and verifying them for shuffle\n *\n */\n@InterfaceAudience.Private\n@InterfaceStability.Unstable\npublic class SecureShuffleUtils {\n  public static final String HTTP_HEADER_URL_HASH = \"UrlHash\";\n  public static final String HTTP_HEADER_REPLY_URL_HASH = \"ReplyHash\";\n  \n  /**\n   * Base64 encoded hash of msg\n   * @param msg\n   */\n  public static String generateHash(byte[] msg, SecretKey key) {\n    return new String(Base64.encodeBase64(generateByteHash(msg, key)), Charsets.UTF_8);\n  }\n\n  /**\n   * calculate hash of msg\n   * @param msg\n   * @return byte array containing computed hash of message\n   */\n  private static byte[] generateByteHash(byte[] msg, SecretKey key) {\n    return JobTokenSecretManager.computeHash(msg, key);\n  }\n\n  /**\n   * Verify the message matches the provided hash using the specified key. </p>\n   * This is only meant to be used when a process needs to verify against multiple different keys\n   * (ShuffleHandler for instance)\n   *\n   * @param hash\n   * @param msg\n   * @param key\n   * @return true when hashes match; false otherwise\n   */\n  private static boolean verifyHash(byte[] hash, byte[] msg, SecretKey key) {\n    byte[] msg_hash = generateByteHash(msg, key);\n    return WritableComparator.compareBytes(msg_hash, 0, msg_hash.length, hash, 0, hash.length) == 0;\n  }\n\n  /**\n   * verify that hash equals to HMacHash(msg)\n   * @param hash\n   * @param msg\n   * @param mgr JobTokenSecretManager\n   * @return true when hashes match; false otherwise\n   */\n  private static boolean verifyHash(byte[] hash, byte[] msg, JobTokenSecretManager mgr) {\n    byte[] msg_hash = mgr.computeHash(msg);\n    return WritableComparator.compareBytes(msg_hash, 0, msg_hash.length, hash, 0, hash.length) == 0;\n  }\n\n  /**\n   * Aux util to calculate hash of a String\n   * @param enc_str\n   * @param mgr JobTokenSecretManager\n   * @return Base64 encodedHash\n   * @throws IOException\n   */\n  public static String hashFromString(String enc_str, JobTokenSecretManager mgr)\n      throws IOException {\n    return new String(Base64.encodeBase64(mgr.computeHash(enc_str.getBytes(Charsets.UTF_8))), Charsets.UTF_8);\n  }\n\n  /**\n   * Verify that the base64 encoded hash matches the hash generated by making use of the provided\n   * key on the specified message. </p>\n   * * This is only meant to be used when a process needs to verify against multiple different keys\n   * (ShuffleHandler for instance)\n   *\n   * @param base64Hash base64 encoded hash\n   * @param msg        the message\n   * @param key        the key to use to generate the hash from the message\n   * @throws IOException\n   */\n<fim_suffix>  public static void verifyReply(String base64Hash, String msg, SecretKey key) throws IOException {\n    byte[] hash = Base64.decodeBase64(base64Hash.getBytes(Charsets.UTF_8));\n    boolean res = verifyHash(hash, msg.getBytes(Charsets.UTF_8), key);\n\n    if(res != true) {\n      throw new IOException(\"Verification of the hashReply failed\");\n    }\n  }\n\n  /**\n   * verify that base64Hash is same as HMacHash(msg)\n   * @param base64Hash (Base64 encoded hash)\n   * @param msg\n   * @throws IOException if not the same\n   */\n  public static void verifyReply(String base64Hash, String msg, JobTokenSecretManager mgr)\n      throws IOException {\n    byte[] hash = Base64.decodeBase64(base64Hash.getBytes(Charsets.UTF_8));\n\n    boolean res = verifyHash(hash, msg.getBytes(Charsets.UTF_8), mgr);\n\n    if(res != true) {\n      throw new IOException(\"Verification of the hashReply failed\");\n    }\n  }\n  \n  /**\n   * Shuffle specific utils - build string for encoding from URL\n   * @param url\n   * @return string for encoding\n   */\n  public static String buildMsgFrom(URL url) {\n    return buildMsgFrom(url.getPath(), url.getQuery(), url.getPort());\n  }\n\n  /**\n   * Shuffle specific utils - build string for encoding from URL\n   * @param uri_path\n   * @param uri_query\n   * @return string for encoding\n   */\n  private static String buildMsgFrom(String uri_path, String uri_query, int port) {\n    return String.valueOf(port) + uri_path + \"?\" + uri_query;\n  }\n}<fim_middle>// function below has no smell\n"}