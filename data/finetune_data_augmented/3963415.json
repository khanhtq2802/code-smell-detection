{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage com.datatorrent.apps.logstream.PropertyRegistry;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\n\nimport org.slf4j.LoggerFactory;\n\n/**\n * Logstream implementation of property registry\n * Properties are added to the registry during dag setup and are accessible to all operators.\n *\n * @since 0.9.4\n */\npublic class LogstreamPropertyRegistry implements PropertyRegistry<String>\n{\n  private static final org.slf4j.Logger logger = LoggerFactory.getLogger(LogstreamPropertyRegistry.class);\n  private static PropertyRegistry<String> instance;\n  private HashMap<Integer, ArrayList<String>> valueList = new HashMap<Integer, ArrayList<String>>();\n  private ArrayList<String> nameList = new ArrayList<String>();\n  private HashMap<String, Integer> indexMap = new HashMap<String, Integer>();\n\n  @Override\n  public synchronized int bind(String name, String value)\n  {\n    ArrayList<String> values = null;\n    int nameIndex = nameList.indexOf(name);\n    int valueIndex;\n\n    if (nameIndex < 0) {\n      nameList.add(name);\n      nameIndex = nameList.indexOf(name);\n\n      values = new ArrayList<String>();\n      values.add(value);\n      valueList.put(nameIndex, values);\n\n      valueIndex = values.indexOf(value);\n    }\n    else {\n      values = valueList.get(nameIndex);\n      valueIndex = values.indexOf(value);\n      if (valueIndex < 0) {\n        values.add(value);\n        valueIndex = values.indexOf(value);\n      }\n    }\n\n    // first 16 characters represent the name, last 16 characters represent the value\n    // there can be total of 2 ^ 16 names and 2 ^ 16 values for each name\n    int index = nameIndex << 16 | valueIndex;\n\n    indexMap.put(name + \"_\" + value, index);\n    logger.debug(\"name = {} value = {} name index = {} value index = {} pair index = {}\", name, value, nameIndex, valueIndex, index);\n\n    return index;\n  }\n\n  @Override\n  public String lookupValue(int index)\n  {\n    int nameIndex = index >> 16; // moves first 16 bits to last 16 bits\n    int valueIndex = 0xffff & index; // clears out first 16 bits\n    ArrayList<String> values = valueList.get(nameIndex);\n    String value = values.get(valueIndex);\n\n    return value;\n  }\n\n  @Override\n  public String[] list(String name)\n  {\n    int nameIndex = nameList.indexOf(name);\n\n    if (nameIndex < 0) {\n      return new String[0];\n    }\n\n    ArrayList<String> values = valueList.get(nameIndex);\n\n    return values.toArray(new String[values.size()]);\n  }\n\n  @Override\n  public String lookupName(int index)\n  {\n    int nameIndex = index >> 16;\n    String name = nameList.get(nameIndex);\n\n    return name;\n  }\n\n  @Override\n  public int getIndex(String name, String value)\n  {\n    Integer index = indexMap.get(name + \"_\" + value);\n    if (index == null) {\n      return -1;\n    }\n    else {\n      return index;\n    }\n  }\n\n<fim_suffix>  @Override\n  public String toString()\n  {\n    return indexMap.toString();\n  }\n\n  public static PropertyRegistry<String> getInstance()\n  {\n    if (instance == null) {\n      logger.error(\"registry instance is null\");\n    }\n    return instance;\n  }\n\n  public static void setInstance(PropertyRegistry<String> registry)\n  {\n    instance = registry;\n  }\n\n}<fim_middle>// function below has no smell\n"}