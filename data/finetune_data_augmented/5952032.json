{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.openejb.core.interceptor;\nimport org.apache.openejb.core.Operation;\nimport org.apache.openejb.util.Classes;\nimport javax.interceptor.InvocationContext;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.TreeMap;\n/**\n * @version $Rev$ $Date$\n */\npublic class ReflectionInvocationContext implements InvocationContext {\n    private final Iterator<Interceptor> interceptors;\n    private final Object target;\n    private final Method method;\n    private final Object[] parameters;\n    private final Map<String, Object> contextData = new TreeMap<>();\n    private final Class<?>[] parameterTypes;\n    private final Operation operation;\n    public ReflectionInvocationContext(final Operation operation, final List<Interceptor> interceptors, final Object target, final Method method, final Object... parameters) {\n        if (operation == null) {\n            throw new NullPointerException(\"operation is null\");\n        }\n        if (interceptors == null) {\n            throw new NullPointerException(\"interceptors is null\");\n        }\n        if (target == null) {\n            throw new NullPointerException(\"target is null\");\n        }\n        this.operation = operation;\n        this.interceptors = interceptors.iterator();\n        this.target = target;\n        this.method = method;\n        this.parameters = parameters;\n        if (method == null) {\n            parameterTypes = new Class[0];\n        } else {\n            parameterTypes = method.getParameterTypes();\n        }\n    }\n    @Override\n    public Object getTimer() {\n        if (operation.equals(Operation.TIMEOUT)) {\n            return parameters[0];\n        }\n        return null;\n    }\n    @Override\n    public Object getTarget() {\n        return target;\n    }\n    @Override\n    public Method getMethod() {\n        return method;\n    }\n    @Override\n    public Constructor<?> getConstructor() {\n        throw new IllegalStateException(); // TODO\n    }\n    @Override\n    public Object[] getParameters() {\n        //TODO Need to figure out what is going on with afterCompletion call back here ?\n        if (Operation.POST_CONSTRUCT.equals(operation) || Operation.PRE_DESTROY.equals(operation)) {\n            //if (operation.isCallback() && !operation.equals(Operation.AFTER_COMPLETION) && !operation.equals(Operation.TIMEOUT)) {\n            throw new IllegalStateException(getIllegalParameterAccessMessage());\n        }\n        return this.parameters;\n    }\n    private String getIllegalParameterAccessMessage() {\n        String m = \"Callback methods cannot access parameters.\";\n        m += \"  Callback Type: \" + operation;\n        if (method != null) {\n            m += \", Target Method: \" + method.getName();\n        }\n        if (target != null) {\n            m += \", Target Bean: \" + target.getClass().getName();\n        }\n        return m;\n    }\n    @Override\n    public void setParameters(final Object[] parameters) {\n        if (operation.isCallback() && !operation.equals(Operation.TIMEOUT)) {\n            throw new IllegalStateException(getIllegalParameterAccessMessage());\n        }\n        if (parameters == null) {\n            throw new IllegalArgumentException(\"parameters is null\");\n        }\n        if (parameters.length != this.parameters.length) {\n            throw new IllegalArgumentException(\"Expected \" + this.parameters.length + \" parameters, but only got \" + parameters.length + \" parameters\");\n        }\n        for (int i = 0; i < parameters.length; i++) {\n            final Object parameter = parameters[i];\n            final Class<?> parameterType = parameterTypes[i];\n            if (parameter == null) {\n                if (parameterType.isPrimitive()) {\n                    throw new IllegalArgumentException(\"Expected parameter \" + i + \" to be primitive type \" + parameterType.getName() +\n                        \", but got a parameter that is null\");\n                }\n            } else {\n                //check that types are applicable\n                final Class<?> actual = Classes.deprimitivize(parameterType);\n                final Class<?> given = Classes.deprimitivize(parameter.getClass());\n                if (!actual.isAssignableFrom(given)) {\n                    throw new IllegalArgumentException(\"Expected parameter \" + i + \" to be of type \" + parameterType.getName() +\n                        \", but got a parameter of type \" + parameter.getClass().getName());\n                }\n            }\n        }\n        System.arraycopy(parameters, 0, this.parameters, 0, parameters.length);\n    }\n    @Override\n    public Map<String, Object> getContextData() {\n        return contextData;\n    }\n<fim_suffix>    private Invocation next() {\n        if (interceptors.hasNext()) {\n            final Interceptor interceptor = interceptors.next();\n            final Object nextInstance = interceptor.getInstance();\n            final Method nextMethod = interceptor.getMethod();\n            if (nextMethod.getParameterTypes().length == 1 && nextMethod.getParameterTypes()[0] == InvocationContext.class) {\n                return new InterceptorInvocation(nextInstance, nextMethod, this);\n            } else {\n                return new LifecycleInvocation(nextInstance, nextMethod, this, parameters);\n            }\n        } else if (method != null) {\n            //EJB 3.1, it is allowed that timeout method does not have parameter Timer.class,\n            //However, while invoking the timeout method, the timer value is passed, as it is also required by InnvocationContext.getTimer() method\n            final Object[] methodParameters;\n            if (operation.equals(Operation.TIMEOUT) && method.getParameterTypes().length == 0) {\n                methodParameters = new Object[0];\n            } else {\n                methodParameters = parameters;\n            }\n            return new BeanInvocation(target, method, methodParameters);\n        } else {\n            return new NoOpInvocation();\n        }\n    }\n    @Override\n    public Object proceed() throws Exception {\n        // The bulk of the logic of this method has intentionally been moved\n        // out so stepping through a large stack in a debugger can be done quickly.\n        // Simply put one break point on 'next.invoke()' or one inside that method.\n        try {\n            final Invocation next = next();\n            return next.invoke();\n        } catch (final InvocationTargetException e) {\n            throw unwrapInvocationTargetException(e);\n        }\n    }\n    private abstract static class Invocation {\n        private final Method method;\n        private final Object[] args;\n        private final Object target;\n        public Invocation(final Object target, final Method method, final Object[] args) {\n            this.target = target;\n            this.method = method;\n            this.args = args;\n        }\n        public Object invoke() throws Exception {\n            final Object value = method.invoke(target, args);\n            return value;\n        }\n        public String toString() {\n            return method.getDeclaringClass().getName() + \".\" + method.getName();\n        }\n    }\n    private static class BeanInvocation extends Invocation {\n        public BeanInvocation(final Object target, final Method method, final Object[] args) {\n            super(target, method, args);\n        }\n    }\n    private static class InterceptorInvocation extends Invocation {\n        public InterceptorInvocation(final Object target, final Method method, final InvocationContext invocationContext) {\n            super(target, method, new Object[]{invocationContext});\n        }\n    }\n    private static class LifecycleInvocation extends Invocation {\n        private final InvocationContext invocationContext;\n        public LifecycleInvocation(final Object target, final Method method, final InvocationContext invocationContext, final Object[] args) {\n            super(target, method, args);\n            this.invocationContext = invocationContext;\n        }\n        public Object invoke() throws Exception {\n            // invoke the callback\n            super.invoke();\n            // we need to call proceed so callbacks in subclasses get invoked\n            final Object value = invocationContext.proceed();\n            return value;\n        }\n    }\n    private static class NoOpInvocation extends Invocation {\n        public NoOpInvocation() {\n            super(null, null, null);\n        }\n        public Object invoke() throws IllegalAccessException, InvocationTargetException {\n            return null;\n        }\n    }\n    // todo verify excpetion types\n    /**\n     * Business method interceptors can only throw exception allowed by the target business method.\n     * Lifecycle interceptors can only throw RuntimeException.\n     *\n     * @param e the invocation target exception of a reflection method invoke\n     * @return the cause of the exception\n     * @throws AssertionError if the cause is not an Exception or Error.\n     */\n    private Exception unwrapInvocationTargetException(final InvocationTargetException e) {\n        final Throwable cause = e.getCause();\n        if (cause == null) {\n            return e;\n        } else if (cause instanceof Exception) {<fim_middle>// function below is long method\n"}