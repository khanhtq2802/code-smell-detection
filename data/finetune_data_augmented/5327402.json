{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.nifi.provenance.lucene;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.List;\n\nimport org.apache.lucene.index.IndexWriter;\nimport org.apache.lucene.index.Term;\nimport org.apache.nifi.provenance.IndexConfiguration;\nimport org.apache.nifi.provenance.PersistentProvenanceRepository;\nimport org.apache.nifi.provenance.expiration.ExpirationAction;\nimport org.apache.nifi.provenance.index.EventIndexWriter;\nimport org.apache.nifi.provenance.serialization.RecordReader;\nimport org.apache.nifi.provenance.serialization.RecordReaders;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n<fim_suffix>public class DeleteIndexAction implements ExpirationAction {\n\n    private static final Logger logger = LoggerFactory.getLogger(DeleteIndexAction.class);\n    private final PersistentProvenanceRepository repository;\n    private final IndexConfiguration indexConfiguration;\n    private final IndexManager indexManager;\n\n    public DeleteIndexAction(final PersistentProvenanceRepository repo, final IndexConfiguration indexConfiguration, final IndexManager indexManager) {\n        this.repository = repo;\n        this.indexConfiguration = indexConfiguration;\n        this.indexManager = indexManager;\n    }\n\n    @Override\n    public File execute(final File expiredFile) throws IOException {\n        // count the number of records and determine the max event id that we are deleting.\n        final long numDeleted = 0;\n        long maxEventId = -1L;\n        try (final RecordReader reader = RecordReaders.newRecordReader(expiredFile, repository.getAllLogFiles(), Integer.MAX_VALUE)) {\n            maxEventId = reader.getMaxEventId();\n        } catch (final IOException ioe) {\n            logger.warn(\"Failed to obtain max ID present in journal file {}\", expiredFile.getAbsolutePath());\n        }\n\n        // remove the records from the index\n        final List<File> indexDirs = indexConfiguration.getIndexDirectories(expiredFile);\n        for (final File indexingDirectory : indexDirs) {\n            final Term term = new Term(FieldNames.STORAGE_FILENAME, LuceneUtil.substringBefore(expiredFile.getName(), \".\"));\n\n            boolean deleteDir = false;\n            final EventIndexWriter writer = indexManager.borrowIndexWriter(indexingDirectory);\n            try {\n                final IndexWriter indexWriter = writer.getIndexWriter();\n                indexWriter.deleteDocuments(term);\n                indexWriter.commit();\n                final int docsLeft = indexWriter.numDocs();\n                deleteDir = docsLeft <= 0;\n                logger.debug(\"After expiring {}, there are {} docs left for index {}\", expiredFile, docsLeft, indexingDirectory);\n            } finally {\n                indexManager.returnIndexWriter(writer);\n            }\n\n            // we've confirmed that all documents have been removed. Delete the index directory.\n            if (deleteDir) {\n                indexManager.removeIndex(indexingDirectory);\n                indexConfiguration.removeIndexDirectory(indexingDirectory);\n\n                deleteDirectory(indexingDirectory);\n                logger.info(\"Removed empty index directory {}\", indexingDirectory);\n            }\n        }\n\n        // Update the minimum index to 1 more than the max Event ID in this file.\n        if (maxEventId > -1L) {\n            indexConfiguration.setMinIdIndexed(maxEventId + 1L);\n        }\n\n        logger.info(\"Deleted Indices for Expired Provenance File {} from {} index files; {} documents removed\", expiredFile, indexDirs.size(), numDeleted);\n        return expiredFile;\n    }\n\n    private void deleteDirectory(final File dir) {\n        if (dir == null || !dir.exists()) {\n            return;\n        }\n\n        final File[] children = dir.listFiles();\n        if (children == null) {\n            return;\n        }\n\n        for (final File child : children) {\n            if (child.isDirectory()) {\n                deleteDirectory(child);\n            } else if (!child.delete()) {\n                logger.warn(\"Unable to remove index directory {}; this directory should be cleaned up manually\", child.getAbsolutePath());\n            }\n        }\n\n        if (!dir.delete()) {\n            logger.warn(\"Unable to remove index directory {}; this directory should be cleaned up manually\", dir);\n        }\n    }\n\n    @Override\n    public boolean hasBeenPerformed(final File expiredFile) throws IOException {\n        return false;\n    }\n}<fim_middle>// class below is blob\n"}