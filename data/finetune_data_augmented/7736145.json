{"text": "<fim_prefix>\n<fim_suffix>public class HttpTool {\n    private static final Logger LOG = LoggerFactory.getLogger(HttpTool.class);\n    static final ExecutorService executor = Executors.newCachedThreadPool();\n    /**\n     * Connects to the given url and returns the connection.\n     * Caller should {@code connection.getInputStream().close()} the result of this\n     * (especially if they are making heavy use of this method).\n     */\n    public static URLConnection connectToUrl(String u) throws Exception {\n        final URL url = new URL(u);\n        final AtomicReference<Exception> exception = new AtomicReference<Exception>();\n        // sometimes openConnection hangs, so run in background\n        Future<URLConnection> f = executor.submit(new Callable<URLConnection>() {\n            public URLConnection call() {\n                try {\n                    HttpsURLConnection.setDefaultHostnameVerifier(new HostnameVerifier() {\n                        @Override\n                        public boolean verify(String s, SSLSession sslSession) {\n                            return true;\n                        }\n                    });\n                    URLConnection connection = url.openConnection();\n                    TrustingSslSocketFactory.configure(connection);\n                    connection.connect();\n                    connection.getContentLength(); // Make sure the connection is made.\n                    return connection;\n                } catch (Exception e) {\n                    exception.set(e);\n                    LOG.debug(\"Error connecting to url \"+url+\" (propagating): \"+e, e);\n                }\n                return null;\n            }\n        });\n        try {\n            URLConnection result = null;\n            try {\n                result = f.get(60, TimeUnit.SECONDS);\n            } catch (InterruptedException e) {\n                throw e;\n            } catch (Exception e) {\n                LOG.debug(\"Error connecting to url \"+url+\", probably timed out (rethrowing): \"+e);\n                throw new IllegalStateException(\"Connect to URL not complete within 60 seconds, for url \"+url+\": \"+e);\n            }\n            if (exception.get() != null) {\n                LOG.debug(\"Error connecting to url \"+url+\", thread caller of \"+exception, new Throwable(\"source of rethrown error \"+exception));\n                throw exception.get();\n            } else {\n                return result;\n            }\n        } finally {\n            f.cancel(true);\n        }\n    }\n    public static int getHttpStatusCode(String url) throws Exception {\n        URLConnection connection = connectToUrl(url);\n        long startTime = System.currentTimeMillis();\n        int status = ((HttpURLConnection) connection).getResponseCode();\n        // read fully if possible, then close everything, trying to prevent cached threads at server\n        consumeAndCloseQuietly((HttpURLConnection) connection);\n        if (LOG.isDebugEnabled())\n            LOG.debug(\"connection to {} ({}ms) gives {}\", new Object[] { url, (System.currentTimeMillis()-startTime), status });\n        return status;\n    }\n    public static String getContent(String url) {\n        try {\n            return Streams.readFullyString(SslTrustUtils.trustAll(new URL(url).openConnection()).getInputStream());\n        } catch (Exception e) {\n            throw Throwables.propagate(e);\n        }\n    }\n    public static String getErrorContent(String url) {\n        try {\n            HttpURLConnection connection = (HttpURLConnection) connectToUrl(url);\n            long startTime = System.currentTimeMillis();\n            String err;\n            int status;\n            try {\n                InputStream errStream = connection.getErrorStream();\n                err = Streams.readFullyString(errStream);\n                status = connection.getResponseCode();\n            } finally {\n                closeQuietly(connection);\n            }\n            if (LOG.isDebugEnabled())\n                LOG.debug(\"read of err {} ({}ms) complete; http code {}\", new Object[] { url, Time.makeTimeStringRounded(System.currentTimeMillis() - startTime), status});\n            return err;\n        } catch (Exception e) {\n            throw Exceptions.propagate(e);\n        }\n    }\n    /**\n     * Consumes the input stream entirely and then cleanly closes the connection.\n     * Ignores all exceptions completely, not even logging them!\n     *\n     * Consuming the stream fully is useful for preventing idle TCP connections.\n     * @see <a href=\"http://docs.oracle.com/javase/8/docs/technotes/guides/net/http-keepalive.html\">Persistent Connections</a>\n     */\n    public static void consumeAndCloseQuietly(HttpURLConnection connection) {\n        try { Streams.readFully(connection.getInputStream()); } catch (Exception e) {}\n        closeQuietly(connection);\n    }\n    /**\n     * Closes all streams of the connection, and disconnects it. Ignores all exceptions completely,\n     * not even logging them!\n     */\n    public static void closeQuietly(HttpURLConnection connection) {\n        try { connection.disconnect(); } catch (Exception e) {}\n        try { connection.getInputStream().close(); } catch (Exception e) {}\n        try { connection.getOutputStream().close(); } catch (Exception e) {}\n        try { connection.getErrorStream().close(); } catch (Exception e) {}\n    }\n    /** Apache HTTP commons utility for trusting all.\n     * <p>\n     * For generic java HTTP usage, see {@link SslTrustUtils#trustAll(java.net.URLConnection)} \n     * and static constants in the same class. */\n    public static class TrustAllStrategy implements TrustStrategy {\n        @Override\n        public boolean isTrusted(X509Certificate[] chain, String authType) throws CertificateException {\n            return true;\n        }\n    }\n    public static HttpClientBuilder httpClientBuilder() {\n        return new HttpClientBuilder();\n    }\n    public static class HttpClientBuilder {\n        private ClientConnectionManager clientConnectionManager;\n        private HttpParams httpParams;\n        private URI uri;\n        private Integer port;\n        private Credentials credentials;\n        private boolean laxRedirect;\n        private Boolean https;\n        private SchemeSocketFactory socketFactory;\n        private ConnectionReuseStrategy reuseStrategy;\n        private boolean trustAll;\n        private boolean trustSelfSigned;\n        public HttpClientBuilder clientConnectionManager(ClientConnectionManager val) {\n            this.clientConnectionManager = checkNotNull(val, \"clientConnectionManager\");\n            return this;\n        }\n        public HttpClientBuilder httpParams(HttpParams val) {\n            checkState(httpParams == null, \"Must not call httpParams multiple times, or after other methods like connectionTimeout\");\n            this.httpParams = checkNotNull(val, \"httpParams\");\n            return this;\n        }\n        public HttpClientBuilder connectionTimeout(Duration val) {\n            if (httpParams == null) httpParams = new BasicHttpParams();\n            long millis = checkNotNull(val, \"connectionTimeout\").toMilliseconds();\n            if (millis > Integer.MAX_VALUE) throw new IllegalStateException(\"HttpClient only accepts upto max-int millis for connectionTimeout, but given \"+val);\n            HttpConnectionParams.setConnectionTimeout(httpParams, (int) millis);\n            return this;\n        }\n        public HttpClientBuilder socketTimeout(Duration val) {\n            if (httpParams == null) httpParams = new BasicHttpParams();\n            long millis = checkNotNull(val, \"socketTimeout\").toMilliseconds();\n            if (millis > Integer.MAX_VALUE) throw new IllegalStateException(\"HttpClient only accepts upto max-int millis for socketTimeout, but given \"+val);\n            HttpConnectionParams.setSoTimeout(httpParams, (int) millis);\n            return this;\n        }\n        public HttpClientBuilder reuseStrategy(ConnectionReuseStrategy val) {\n            this.reuseStrategy = checkNotNull(val, \"reuseStrategy\");\n            return this;\n        }\n        public HttpClientBuilder uri(String val) {\n            return uri(URI.create(checkNotNull(val, \"uri\")));\n        }\n        public HttpClientBuilder uri(URI val) {\n            this.uri = checkNotNull(val, \"uri\");\n            if (https == null) https = (\"https\".equalsIgnoreCase(uri.getScheme()));\n            return this;\n        }\n        public HttpClientBuilder port(int val) {\n            this.port = val;\n            return this;\n        }\n        public HttpClientBuilder credentials(Credentials val) {\n            this.credentials = checkNotNull(val, \"credentials\");\n            return this;\n        }\n        public void credential(Optional<Credentials> val) {\n            if (val.isPresent()) credentials = val.get();\n        }\n        /** similar to curl --post301 -L` */\n        public HttpClientBuilder laxRedirect(boolean val) {\n            this.laxRedirect = val;\n            return this;\n        }\n        public HttpClientBuilder https(boolean val) {\n            this.https = val;\n            return this;\n        }\n        public HttpClientBuilder socketFactory(SchemeSocketFactory val) {\n            this.socketFactory = checkNotNull(val, \"socketFactory\");\n            return this;\n        }\n        public HttpClientBuilder trustAll() {\n            this.trustAll = true;\n            return this;\n        }\n        public HttpClientBuilder trustSelfSigned() {\n            this.trustSelfSigned = true;\n            return this;\n        }\n        public HttpClient build() {\n            final DefaultHttpClient httpClient = new DefaultHttpClient(clientConnectionManager);\n            httpClient.setParams(httpParams);\n            // support redirects for POST (similar to `curl --post301 -L`)\n            // http://stackoverflow.com/questions/3658721/httpclient-4-error-302-how-to-redirect\n            if (laxRedirect) {<fim_middle>// class below has no smell\n"}