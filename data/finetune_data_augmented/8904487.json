{"text": "<fim_prefix>   * yes, convert it to a map-side join.\n   *\n   * @param pactx\n   *          current parse context\n   */\n  @Override\n  public ParseContext transform(ParseContext pactx) throws SemanticException {\n    List<MapJoinOperator> listMapJoinOps = new ArrayList<MapJoinOperator>();\n    // traverse all the joins and convert them if necessary\n    if (pactx.getJoinOps() != null) {\n      Set<JoinOperator> joinMap = new HashSet<JoinOperator>();\n      Set<MapJoinOperator> mapJoinMap = pactx.getMapJoinOps();\n      if (mapJoinMap == null) {\n        mapJoinMap = new HashSet<MapJoinOperator>();\n        pactx.setMapJoinOps(mapJoinMap);\n      }\n      Iterator<JoinOperator> joinCtxIter = pactx.getJoinOps().iterator();\n      while (joinCtxIter.hasNext()) {\n        JoinOperator joinOp = joinCtxIter.next();\n        int mapJoinPos = mapSideJoin(joinOp);\n        if (mapJoinPos >= 0) {\n          MapJoinOperator mapJoinOp = generateMapJoinOperator(pactx, joinOp, mapJoinPos);\n          listMapJoinOps.add(mapJoinOp);\n          mapJoinOp.getConf().setQBJoinTreeProps(joinOp.getConf());\n          mapJoinMap.add(mapJoinOp);\n        } else {\n          joinOp.getConf().setQBJoinTreeProps(joinOp.getConf());\n          joinMap.add(joinOp);\n        }\n      }\n      // store the new joinContext\n      pactx.setJoinOps(joinMap);\n    }\n    // Go over the list and find if a reducer is not needed\n    List<AbstractMapJoinOperator<? extends MapJoinDesc>> listMapJoinOpsNoRed = new ArrayList<AbstractMapJoinOperator<? extends MapJoinDesc>>();\n    // create a walker which walks the tree in a DFS manner while maintaining\n    // the operator stack.\n    // The dispatcher generates the plan from the operator tree\n    Map<Rule, NodeProcessor> opRules = new LinkedHashMap<Rule, NodeProcessor>();\n    opRules.put(new RuleRegExp(\"R0\",\n      MapJoinOperator.getOperatorName() + \"%\"),\n      getCurrentMapJoin());\n    opRules.put(new RuleRegExp(\"R1\",\n      MapJoinOperator.getOperatorName() + \"%.*\" + FileSinkOperator.getOperatorName() + \"%\"),\n      getMapJoinFS());\n    opRules.put(new RuleRegExp(\"R2\",\n      MapJoinOperator.getOperatorName() + \"%.*\" + ReduceSinkOperator.getOperatorName() + \"%\"),\n      getMapJoinDefault());\n    opRules.put(new RuleRegExp(\"R4\",\n      MapJoinOperator.getOperatorName() + \"%.*\" + UnionOperator.getOperatorName() + \"%\"),\n      getMapJoinDefault());\n    // The dispatcher fires the processor corresponding to the closest matching\n    // rule and passes the context along\n    Dispatcher disp = new DefaultRuleDispatcher(getDefault(), opRules, new MapJoinWalkerCtx(\n        listMapJoinOpsNoRed, pactx));\n    GraphWalker ogw = new GenMapRedWalker(disp);\n    ArrayList<Node> topNodes = new ArrayList<Node>();\n    topNodes.addAll(listMapJoinOps);\n    ogw.startWalking(topNodes, null);\n    pactx.setListMapJoinOpsNoReducer(listMapJoinOpsNoRed);\n    return pactx;\n  }\n  /**\n   * CurrentMapJoin.\n   *\n   */\n  public static class CurrentMapJoin implements NodeProcessor {\n    /**\n     * Store the current mapjoin in the context.\n     */\n    @Override\n    public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx procCtx,\n        Object... nodeOutputs) throws SemanticException {\n      MapJoinWalkerCtx ctx = (MapJoinWalkerCtx) procCtx;\n      MapJoinOperator mapJoin = (MapJoinOperator) nd;\n      if (ctx.getListRejectedMapJoins() != null && !ctx.getListRejectedMapJoins().contains(mapJoin)) {\n        // for rule: MapJoin%.*MapJoin\n        // have a child mapjoin. if the the current mapjoin is on a local work,\n        // will put the current mapjoin in the rejected list.\n        Boolean bigBranch = findGrandChildSubqueryMapjoin(ctx, mapJoin);\n        if (bigBranch == null) { // no child map join\n          ctx.setCurrMapJoinOp(mapJoin);\n          return null;\n        }\n        if (bigBranch) {\n          addNoReducerMapJoinToCtx(ctx, mapJoin);\n        } else {\n          addRejectMapJoinToCtx(ctx, mapJoin);\n        }\n      } else {\n        ctx.setCurrMapJoinOp(mapJoin);\n      }\n      return null;\n    }\n    private Boolean findGrandChildSubqueryMapjoin(MapJoinWalkerCtx ctx, MapJoinOperator mapJoin) {\n      Operator<? extends OperatorDesc> parent = mapJoin;\n      while (true) {\n        if (parent.getChildOperators() == null || parent.getChildOperators().size() != 1) {\n          return null;\n        }\n        Operator<? extends OperatorDesc> ch = parent.getChildOperators().get(0);\n        if (ch instanceof MapJoinOperator) {\n          if (!nonSubqueryMapJoin((MapJoinOperator) ch, mapJoin)) {\n            if (ch.getParentOperators().indexOf(parent) == ((MapJoinOperator) ch).getConf()\n                .getPosBigTable()) {\n              // not come from the local branch\n              return true;\n            }\n          }\n          return false; // not from a sub-query.\n        }\n        if ((ch instanceof JoinOperator) || (ch instanceof UnionOperator)\n            || (ch instanceof ReduceSinkOperator) || (ch instanceof LateralViewJoinOperator)\n            || (ch instanceof GroupByOperator) || (ch instanceof ScriptOperator)) {\n          return null;\n        }\n        parent = ch;\n      }\n    }\n    private boolean nonSubqueryMapJoin(MapJoinOperator mapJoin, MapJoinOperator parentMapJoin) {\n      if (mapJoin.getParentOperators().contains(parentMapJoin)) {\n        return true;\n      }\n      return false;\n    }\n  }\n  private static void addNoReducerMapJoinToCtx(MapJoinWalkerCtx ctx,\n      AbstractMapJoinOperator<? extends MapJoinDesc> mapJoin) {\n    if (ctx.getListRejectedMapJoins() != null && ctx.getListRejectedMapJoins().contains(mapJoin)) {\n      return;\n    }\n    List<AbstractMapJoinOperator<? extends MapJoinDesc>> listMapJoinsNoRed = ctx\n        .getListMapJoinsNoRed();\n    if (listMapJoinsNoRed == null) {\n      listMapJoinsNoRed = new ArrayList<AbstractMapJoinOperator<? extends MapJoinDesc>>();\n    }\n    if (!listMapJoinsNoRed.contains(mapJoin)) {\n      listMapJoinsNoRed.add(mapJoin);\n    }\n    ctx.setListMapJoins(listMapJoinsNoRed);\n  }\n  private static void addRejectMapJoinToCtx(MapJoinWalkerCtx ctx,\n      AbstractMapJoinOperator<? extends MapJoinDesc> mapjoin) {\n    // current map join is null means it has been handled by CurrentMapJoin\n    // process.\n    if (mapjoin == null) {\n      return;\n    }\n    List<AbstractMapJoinOperator<? extends MapJoinDesc>> listRejectedMapJoins = ctx\n        .getListRejectedMapJoins();\n    if (listRejectedMapJoins == null) {\n      listRejectedMapJoins = new ArrayList<AbstractMapJoinOperator<? extends MapJoinDesc>>();\n    }\n    if (!listRejectedMapJoins.contains(mapjoin)) {\n      listRejectedMapJoins.add(mapjoin);\n    }\n    if (ctx.getListMapJoinsNoRed() != null && ctx.getListMapJoinsNoRed().contains(mapjoin)) {\n      ctx.getListMapJoinsNoRed().remove(mapjoin);\n    }\n    ctx.setListRejectedMapJoins(listRejectedMapJoins);\n  }\n  /**\n   * MapJoinFS.\n   *\n   */\n  public static class MapJoinFS implements NodeProcessor {\n    /**\n     * Store the current mapjoin in a list of mapjoins followed by a filesink.\n     */\n<fim_suffix>    @Override\n    public Object process(Node nd, Stack<Node> stack, NodeProcessorCtx procCtx,\n        Object... nodeOutputs) throws SemanticException {\n      MapJoinWalkerCtx ctx = (MapJoinWalkerCtx) procCtx;\n      AbstractMapJoinOperator<? extends MapJoinDesc> mapJoin = ctx.getCurrMapJoinOp();\n      List<AbstractMapJoinOperator<? extends MapJoinDesc>> listRejectedMapJoins = ctx\n          .getListRejectedMapJoins();\n      // the mapjoin has already been handled\n      if ((listRejectedMapJoins != null) && (listRejectedMapJoins.contains(mapJoin))) {\n        return null;\n      }\n      addNoReducerMapJoinToCtx(ctx, mapJoin);\n      return null;\n    }<fim_middle>// function below has no smell\n"}