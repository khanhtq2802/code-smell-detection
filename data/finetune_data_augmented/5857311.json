{"text": "<fim_prefix>        }\n        tableModel.addRow(new Object[] { featName, strVal });\n      } else if (CAS.TYPE_NAME_INTEGER.equals(rangeTypeName)) {\n        int intVal = aAnnotation.getIntValue(feat);\n        tableModel.addRow(new Object[] { featName, new Integer(intVal) });\n      } else if (CAS.TYPE_NAME_FLOAT.equals(rangeTypeName)) {\n        float floatVal = aAnnotation.getFloatValue(feat);\n        tableModel.addRow(new Object[] { featName, new Float(floatVal) });\n      } else if (CAS.TYPE_NAME_STRING_ARRAY.equals(rangeTypeName)) {\n        StringArrayFS arrayFS = (StringArrayFS) aAnnotation.getFeatureValue(feat);\n        StringBuffer displayVal = new StringBuffer();\n        if (arrayFS == null) {\n          displayVal.append(\"null\");\n        } else {\n          displayVal.append('[');\n          String[] vals = arrayFS.toArray();\n          for (int i = 0; i < vals.length - 1; i++) {\n            displayVal.append(vals[i]);\n            displayVal.append(',');\n          }\n          if (vals.length > 0) {\n            displayVal.append(vals[vals.length - 1]);\n          }\n          displayVal.append(']');\n        }\n        tableModel.addRow(new Object[] { featName, displayVal });\n      } else if (CAS.TYPE_NAME_INTEGER_ARRAY.equals(rangeTypeName)) {\n        IntArrayFS arrayFS = (IntArrayFS) aAnnotation.getFeatureValue(feat);\n        StringBuffer displayVal = new StringBuffer();\n        if (arrayFS == null) {\n          displayVal.append(\"null\");\n        } else {\n          displayVal.append('[');\n          int[] vals = arrayFS.toArray();\n          for (int i = 0; i < vals.length - 1; i++) {\n            displayVal.append(vals[i]);\n            displayVal.append(',');\n          }\n          if (vals.length > 0) {\n            displayVal.append(vals[vals.length - 1]);\n          }\n          displayVal.append(']');\n        }\n        tableModel.addRow(new Object[] { featName, displayVal });\n      } else if (CAS.TYPE_NAME_FLOAT_ARRAY.equals(rangeTypeName)) {\n        FloatArrayFS arrayFS = (FloatArrayFS) aAnnotation.getFeatureValue(feat);\n        StringBuffer displayVal = new StringBuffer();\n        if (arrayFS == null) {\n          displayVal.append(\"null\");\n        } else {\n          displayVal.append('[');\n          float[] vals = arrayFS.toArray();\n          for (int i = 0; i < vals.length - 1; i++) {\n            displayVal.append(vals[i]);\n            displayVal.append(',');\n          }\n          if (vals.length > 0) {\n            displayVal.append(vals[vals.length - 1]);\n          }\n          displayVal.append(']');\n        }\n        tableModel.addRow(new Object[] { featName, displayVal });\n      }\n    }\n  }\n  /**\n   * Builds a tree from a CAS.\n   * \n   * @param aRootNode\n   *          an existing root node for the tree\n   * @param aCAS\n   *          CAS from which annotations will be extracted\n   */\n  private TreeNode buildTree(CAS aCAS) throws CASException {\n    // get iterator over all annotations\n    FSIterator iterator = aCAS.getAnnotationIndex().iterator();\n    // create artifical root node encompassing entire document\n    DefaultMutableTreeNode root = new DefaultMutableTreeNode(\"Document\");\n    // add children to this node\n    _buildTree(root, iterator, 0, aCAS.getDocumentText().length());\n    return root;\n  }\n  /**\n   * Recursive method called by {@link buildTree(DefaultMutableTreeNode,FSIterator)}.\n   * \n   * @param aParentNode\n   *          root node of tree to be built\n   * @param aIterator\n   *          iterator over all annotation in CAS\n   * @param aStartPos\n   *          text position at which to begin processing\n   * @param aEndPos\n   *          text position at which to end processing\n   */\n  private void _buildTree(DefaultMutableTreeNode aParentNode, FSIterator aIterator, int aStartPos,\n          int aEndPos) {\n    while (aIterator.isValid()) {\n      AnnotationFS curAnnot = (AnnotationFS) aIterator.get();\n      int curAnnotStart = curAnnot.getBegin();\n      int curAnnotEnd = curAnnot.getEnd();\n      if (curAnnotEnd <= aEndPos) {\n        // move iterator to next annotation\n        aIterator.moveToNext();\n        if (curAnnotStart < curAnnotEnd) // account for bug in JTalent\n        {\n          // add this annotation as a child of aParentNode\n          DefaultMutableTreeNode newNode = new DefaultMutableTreeNode(new AnnotationTreeNodeObject(\n                  curAnnot));\n          aParentNode.add(newNode);\n          // recursively add children to this node\n          _buildTree(newNode, aIterator, curAnnotStart, curAnnotEnd);\n        }\n      } else\n        break;\n    }\n  }\n  /**\n   * Main program. Runs a TAE and displays the resulting annotations in the tree viewer.\n   * \n   * @param args\n   *          Command-line arguments - two are reguired: the path to the TAE descriptor and a file\n   *          to be analyzed.\n   */\n  public static void main(String[] args) {\n    AnalysisEngine ae = null;\n    try {\n      File taeDescriptor = null;\n      File inputFile = null;\n      // Read and validate command line arguments\n      boolean validArgs = false;\n      if (args.length == 2) {\n        taeDescriptor = new File(args[0]);\n        inputFile = new File(args[1]);\n        validArgs = taeDescriptor.exists() && !taeDescriptor.isDirectory() && inputFile.exists()\n                && !inputFile.isDirectory();\n      }\n      if (!validArgs) {\n        printUsageMessage();\n      } else {\n        // get Resource Specifier from XML file or TEAR\n        XMLInputSource in = new XMLInputSource(taeDescriptor);\n        ResourceSpecifier specifier = UIMAFramework.getXMLParser().parseResourceSpecifier(in);\n        // create Text Analysis Engine and CAS here\n        ae = UIMAFramework.produceAnalysisEngine(specifier);\n        CAS CAS = ae.newCAS();\n        // read document from file\n        String document = FileUtils.file2String(inputFile);\n        CAS.setDocumentText(getText(document).trim());\n        // analyze\n        ae.process(CAS);\n        // set GUI look and feel\n        try {\n          UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());\n        } catch (Exception e) {\n          // I don't think this should ever happen, but if it does just print error and continue\n          // with defalt look and feel\n          System.err.println(\"Could not set look and feel: \" + e.getMessage());\n        }\n        // create Frame for standlone app\n        JFrame frame = new JFrame();\n        frame.setTitle(\"Annotation Tree Viewer\");\n        // Set frame icon image\n        try {\n          frame.setIconImage(Images.getImage(Images.MICROSCOPE));\n        } catch (IOException e) {\n          System.err.println(\"Image could not be loaded: \" + e.getMessage());\n        }\n        frame.getContentPane().setBackground(Color.WHITE);\n        frame.getContentPane().setLayout(new BorderLayout());\n        // add banner\n        JLabel banner = new JLabel(Images.getImageIcon(Images.BANNER));\n        frame.getContentPane().add(banner, BorderLayout.NORTH);\n        // create tree viewer component and add to Frame\n        CasTreeViewer treeViewer = new CasTreeViewer(CAS);\n        frame.getContentPane().add(treeViewer, BorderLayout.CENTER);\n        // show Frame\n        frame.setSize(800, 600);\n        frame.pack();\n        frame.show();\n        frame.addWindowListener(new WindowAdapter() {\n          public void windowClosing(WindowEvent e) {\n            System.exit(0);\n          }\n        });\n      }\n    } catch (Exception e) {\n      e.printStackTrace();\n      System.exit(0);\n    }\n  }\n  /**\n   * Gets text to be processed by the TAE. If the document contains XML tags named TEXT like this:\n   * <code>&lt;TEXT%gt;Process this text.&lt;/TEXT%gt;</code>, then only the text within those\n   * tags is returned. Otherwise the whole document is returned.\n   * \n   * @param aFile\n   *          file to process\n   * @param aTAE\n   *          Text Analysis Engine that will process the file\n   */\n<fim_suffix>  static private String getText(String text) {\n    int start = text.indexOf(\"<TEXT>\");\n    int end = text.indexOf(\"</TEXT>\");\n    if (start != -1 && end != -1) {\n      return text.substring(start + 6, end);\n    } else {\n      return text;\n    }\n  }<fim_middle>// function below has no smell\n"}