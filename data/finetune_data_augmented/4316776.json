{"text": "<fim_prefix>/*\n\n   Derby - Class org.apache.derby.impl.sql.execute.AutoincrementCounter\n\n   Licensed to the Apache Software Foundation (ASF) under one or more\n   contributor license agreements.  See the NOTICE file distributed with\n   this work for additional information regarding copyright ownership.\n   The ASF licenses this file to you under the Apache License, Version 2.0\n   (the \"License\"); you may not use this file except in compliance with\n   the License.  You may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n */\n\npackage org.apache.derby.impl.sql.execute;\nimport org.apache.derby.shared.common.sanity.SanityManager;\nimport\torg.apache.derby.iapi.sql.dictionary.TableDescriptor;\nimport org.apache.derby.iapi.sql.dictionary.ColumnDescriptor;\nimport org.apache.derby.iapi.sql.dictionary.DataDictionary;\nimport org.apache.derby.iapi.store.access.TransactionController;\nimport org.apache.derby.shared.common.error.StandardException;\nimport org.apache.derby.catalog.UUID;\nimport org.apache.derby.shared.common.reference.SQLState;\n\n\n/**\n * AutoincrementCounter is a not so general counter for the specific purposes\n * of autoincrement columns. It can be thought of as an in-memory autoincrement\n * column.\n * The counting or incrementing is done in fashion identical to the\n * AUTOINCREMENTVALUE in SYSCOLUMNS.\n * <p>\n * To create a counter, the user must call the constructor with a start value,\n * increment and optionally a final value. In addition the caller must specify\n * the schema name, table name and column name uniquely identifying the\n * counter. \n * <p>\n * When a counter is created it is in an invalid state-- to initialize it, the\n * user must call either  <i>update</i> or <i>reset(false)</i>. The value of a\n * counter can be changed by either calling reset or update. \n\n */\npublic class AutoincrementCounter \n{\n\n\tprivate Long start;\n\tprivate long increment;\n\tprivate String identity;\n\tprivate long finalValue;\n\tprivate String schemaName;\n\tprivate String tableName;\n\tprivate String columnName;\n\t// maintains state.\n\tprivate long counter;\n\tprivate int columnPosition;\n\tprivate boolean initialized = false;\n\n\t/**\n\t * constructor \n\t * @param \tstart\t\tThe start value of the counter; is a java object as\n\t * \t\t\tit can also be null.\n\t * @param   increment\thow much to increment the counter by.\n\t * @param\tfinalValue\tthe finalvalue of the counter. used by reset\n\t * @param \ts\n\t * @param   t\n\t * @param\tc\n\t */\n\tpublic AutoincrementCounter(Long start, long increment, long finalValue,\n\t\t\t\t\t\t\t\tString s, String t, String c, int position)\n\t{\n\t\tthis.increment = increment;\n\t\tthis.start = start;\n\t\tthis.initialized = false;\n\t\tthis.identity = makeIdentity(s,t,c);\n\t\tthis.finalValue = finalValue;\n\t\tthis.schemaName = s;\n\t\tthis.tableName = t;\n\t\tthis.columnName = c;\n\t\tthis.columnPosition = position;\n\t\t//\t\tSystem.out.println(\"aic created with \" + this);\n\t}\n\n\t/**\n\t * make a unique key for the counter.\n\t */\n\tpublic static String makeIdentity(String s, String t, String c)\n\t{\n\t\treturn s + \".\" + t + \".\" + c;\n\t}\n\n\t/**\n\t * make a unique key for the counter.\n\t */\n\tpublic static String makeIdentity(TableDescriptor td, ColumnDescriptor cd)\n\t{\n\t\treturn td.getSchemaName() + \".\" + td.getName() + \n\t\t\t\t\".\" + cd.getColumnName();\n\t}\n\n\t/**\n\t * reset to the counter to the beginning or the end.\n\t * \n\t * @param \tbegin\tif TRUE reset to beginning and mark it uninitialized.\n\t */\n\tpublic void reset(boolean begin)\n\t{\n\t\tif (begin == true)\n\t\t\tinitialized = false;\n\t\telse\n\t\t{\n\t\t\tcounter = finalValue;\n\t\t\tinitialized = true;\n\t\t}\n\t\t//\t\tSystem.out.println(\"counter reset to \" + this);\n\n\t}\n\n\t/**\n\t * update the counter.\n\t * \n\t * @param \tt\t\tupdate the counter to this value.\n\t */\n<fim_suffix>\tpublic long update(long t)\n\t{\n\t\tcounter = t;\n\t\t//\t\tSystem.out.println(\"counter updated to \" + this);\n\t\tinitialized = true;\n\t\treturn counter;\n\t}\n\n\t/**\n\t * update the counter to its next value.\n\t * \n\t * @exception\tStandardException\tif the counter has not yet been\n\t * initialized and the Start value is NULL.\n\t */\n\tpublic long update() throws StandardException\n\t{\n\t\tlong counterVal;\n\n\t\tif (initialized == false)\n\t\t{\n\t\t\t// The first time around, counter simply gets the start\n\t\t\t// value. \n\t\t\tinitialized = true;\n\t\t\t\n\t\t\tif (start == null)\n\t\t\t{\n\t\t\t\tthrow StandardException.newException(\n\t\t\t\t\t\t\t\t\t\t\tSQLState.LANG_AI_COUNTER_ERROR);\n\t\t\t}\n\t\t\tcounter = start.longValue();\t\t\t\n\t\t}\t\n\t\telse\n\t\t{\n\t\t\tcounter = counter + increment;\n\t\t}\n\t\t//\t\tSystem.out.println(\"counter updated to \" + this);\n\t\treturn counter;\n\t}\n\n\t/**\n\t * get the current value of the counter. An uninitialized counter means the\n\t * current value is NULL.\n\t */\n\tpublic Long getCurrentValue()\n\t{\n\t\tif (initialized == false)\n\t\t\treturn null;\n\t\treturn counter;\n\t}\n\t\n\t/**\n\t * return the identity of the counter.\n\t */\n\tpublic String getIdentity()\n\t{\n\t\treturn identity;\n\t}\n\n\t/**\n\t * flush a counter to disk; i.e write the current value of the counter into\n\t * the row in SYSCOLUMNS.\n\t * \n\t * @param\ttc\t\t\tTransactionController to use\n\t * @param\tdd\t\t\tDataDictionary to use.\n\t * @param\ttableUUID\tI might have the table name but I need more\n\t * information \n\t * @exception\tStandardException standard Derby exception.\n\t */\n\tpublic void flushToDisk(TransactionController tc, DataDictionary dd,\n\t\t\t\t\t\t\tUUID tableUUID)\n\t       throws StandardException\n\t{\n\t\tdd.setAutoincrementValue(tc, tableUUID, columnName, counter, true);\n\t}\n\n\t/**\n\t * get the column position in the table for which this counter has been\n\t * created. \n\t * @return the position of the corresponding column in the table (1-based)\n\t */\n\tpublic int getColumnPosition()\n\t{\n\t\treturn columnPosition;\n\t}\n\n\t/**\n\t * get the start value\n\t * @return the initial value of the counter\n\t */\n\tpublic Long getStartValue()\n\t{\n\t\treturn start;\n\t}\n\n\tpublic String toString()\n\t{\n\t\treturn \"counter: \" + identity + \" current: \" + counter \n\t\t\t+ \" start: \" + start + \n\t\t\t\" increment: \" + increment + \" final: \" + finalValue;\n\t}\t\n}\t\n\n<fim_middle>// function below has no smell\n"}