{"text": "<fim_prefix> * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n * <p>\n * http://www.apache.org/licenses/LICENSE-2.0\n * <p>\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.storm.utils;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.locks.LockSupport;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n/**\n * This class implements time simulation support. When time simulation is enabled,\n * methods on this class will use fixed time. When time simulation is disabled,\n * methods will pass through to relevant java.lang.System/java.lang.Thread calls.\n * Methods using units higher than nanoseconds will pass through to System.currentTimeMillis().\n * Methods supporting nanoseconds will pass through to System.nanoTime().\n */\n<fim_suffix>public final class Time {\n  private static final Logger LOG = Logger.getLogger(Time.class.getName());\n  private static final AtomicBoolean SIMULATING = new AtomicBoolean(false);\n  private static final AtomicLong AUTO_ADVANCE_NANOS_ON_SLEEP = new AtomicLong(0);\n  private static final Map<Thread, AtomicLong> THREAD_SLEEP_TIMES_NANOS = new ConcurrentHashMap<>();\n  private static final Object SLEEP_TIMES_LOCK = new Object();\n  private static final AtomicLong SIMULATED_CURR_TIME_NANOS = new AtomicLong(0);\n  private Time() {\n  }\n  public static boolean isSimulating() {\n    return SIMULATING.get();\n  }\n  public static void sleepUntil(long targetTimeMs) throws InterruptedException {\n    if (SIMULATING.get()) {\n      simulatedSleepUntilNanos(millisToNanos(targetTimeMs));\n    } else {\n      long sleepTimeMs = targetTimeMs - currentTimeMillis();\n      if (sleepTimeMs > 0) {\n        Thread.sleep(sleepTimeMs);\n      }\n    }\n  }\n  public static void sleepUntilNanos(long targetTimeNanos) throws InterruptedException {\n    if (SIMULATING.get()) {\n      simulatedSleepUntilNanos(targetTimeNanos);\n    } else {\n      long sleepTimeNanos = targetTimeNanos - nanoTime();\n      long sleepTimeMs = nanosToMillis(sleepTimeNanos);\n      int sleepTimeNanosSansMs = (int) (sleepTimeNanos % 1_000_000);\n      if (sleepTimeNanos > 0) {\n        Thread.sleep(sleepTimeMs, sleepTimeNanosSansMs);\n      }\n    }\n  }\n  private static void simulatedSleepUntilNanos(long targetTimeNanos) throws InterruptedException {\n    try {\n      synchronized (SLEEP_TIMES_LOCK) {\n        if (!SIMULATING.get()) {\n          LOG.log(Level.FINER, Thread.currentThread()\n                  + \" is still sleeping after simulated time disabled.\",\n              new RuntimeException(\"STACK TRACE\"));\n          throw new InterruptedException();\n        }\n        THREAD_SLEEP_TIMES_NANOS.put(Thread.currentThread(), new AtomicLong(targetTimeNanos));\n      }\n      while (SIMULATED_CURR_TIME_NANOS.get() < targetTimeNanos) {\n        synchronized (SLEEP_TIMES_LOCK) {\n          if (!SIMULATING.get()) {\n            LOG.log(Level.FINER, Thread.currentThread()\n                    + \" is still sleeping after simulated time disabled.\",\n                new RuntimeException(\"STACK TRACE\"));\n            throw new InterruptedException();\n          }\n          long autoAdvance = AUTO_ADVANCE_NANOS_ON_SLEEP.get();\n          if (autoAdvance > 0) {\n            advanceTimeNanos(autoAdvance);\n          }\n        }\n        Thread.sleep(10);\n      }\n    } finally {\n      THREAD_SLEEP_TIMES_NANOS.remove(Thread.currentThread());\n    }\n  }\n  public static void sleep(long ms) throws InterruptedException {\n    if (ms > 0) {\n      if (SIMULATING.get()) {\n        simulatedSleepUntilNanos(millisToNanos(currentTimeMillis() + ms));\n      } else {\n        Thread.sleep(ms);\n      }\n    }\n  }\n  public static void parkNanos(long nanos) throws InterruptedException {\n    if (nanos > 0) {\n      if (SIMULATING.get()) {\n        simulatedSleepUntilNanos(nanoTime() + nanos);\n      } else {\n        LockSupport.parkNanos(nanos);\n      }\n    }\n  }\n  public static void sleepSecs(long secs) throws InterruptedException {\n    if (secs > 0) {\n      sleep(secs * 1000);\n    }\n  }\n  public static long nanoTime() {\n    if (SIMULATING.get()) {\n      return SIMULATED_CURR_TIME_NANOS.get();\n    } else {\n      return System.nanoTime();\n    }\n  }\n  public static long currentTimeMillis() {\n    if (SIMULATING.get()) {\n      return nanosToMillis(SIMULATED_CURR_TIME_NANOS.get());\n    } else {\n      return System.currentTimeMillis();\n    }\n  }\n  public static long nanosToMillis(long nanos) {\n    return nanos / 1_000_000;\n  }\n  public static long millisToNanos(long millis) {\n    return millis * 1_000_000;\n  }\n  public static long secsToMillis(int secs) {\n    return 1000 * (long) secs;\n  }\n  public static long secsToMillisLong(double secs) {\n    return (long) (1000 * secs);\n  }\n  public static int currentTimeSecs() {\n    return (int) (currentTimeMillis() / 1000);\n  }\n  public static int deltaSecs(int timeInSeconds) {\n    return Time.currentTimeSecs() - timeInSeconds;\n  }\n  public static long deltaMs(long timeInMilliseconds) {\n    return Time.currentTimeMillis() - timeInMilliseconds;\n  }\n  public static void advanceTime(long ms) {\n    advanceTimeNanos(millisToNanos(ms));\n  }\n  public static void advanceTimeNanos(long nanos) {\n    if (!SIMULATING.get()) {\n      throw new IllegalStateException(\"Cannot simulate time unless in simulation mode\");\n    }\n    if (nanos < 0) {\n      throw new IllegalArgumentException(\"advanceTime only accepts positive time as an argument\");\n    }\n    synchronized (SLEEP_TIMES_LOCK) {\n      long newTime = SIMULATED_CURR_TIME_NANOS.addAndGet(nanos);\n      Iterator<AtomicLong> sleepTimesIter = THREAD_SLEEP_TIMES_NANOS.values().iterator();\n      while (sleepTimesIter.hasNext()) {\n        AtomicLong curr = sleepTimesIter.next();\n        if (SIMULATED_CURR_TIME_NANOS.get() >= curr.get()) {\n          sleepTimesIter.remove();\n        }\n      }\n      LOG.log(Level.FINER, \"Advanced simulated time to \" + newTime);\n    }\n  }\n  public static void advanceTimeSecs(long secs) {\n    advanceTime(secs * 1_000);\n  }\n  public static boolean isThreadWaiting(Thread t) {\n    if (!SIMULATING.get()) {\n      throw new IllegalStateException(\"Must be in simulation mode\");\n    }\n    AtomicLong time = THREAD_SLEEP_TIMES_NANOS.get(t);\n    return !t.isAlive() || time != null && nanoTime() < time.longValue();\n  }\n  public static class SimulatedTime implements AutoCloseable {\n    public SimulatedTime() {\n      this(null);\n    }\n    public SimulatedTime(Number advanceTimeMs) {\n      synchronized (Time.SLEEP_TIMES_LOCK) {\n        Time.SIMULATING.set(true);\n        Time.SIMULATED_CURR_TIME_NANOS.set(0);\n        Time.THREAD_SLEEP_TIMES_NANOS.clear();\n        if (advanceTimeMs != null) {\n          Time.AUTO_ADVANCE_NANOS_ON_SLEEP.set(millisToNanos(advanceTimeMs.longValue()));\n        } else {\n          Time.AUTO_ADVANCE_NANOS_ON_SLEEP.set(0);\n        }\n        LOG.warning(\"AutoCloseable Simulated Time Starting...\");\n      }\n    }\n    @Override\n    public void close() {\n      synchronized (Time.SLEEP_TIMES_LOCK) {\n        Time.SIMULATING.set(false);\n        LOG.warning(\"AutoCloseable Simulated Time Ending...\");\n      }\n    }\n  }\n}<fim_middle>// class below has no smell\n"}