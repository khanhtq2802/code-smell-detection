{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.jackrabbit.oak.plugins.blob.migration;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport org.apache.commons.codec.digest.DigestUtils;\nimport org.apache.jackrabbit.oak.api.Blob;\nimport org.apache.jackrabbit.oak.api.CommitFailedException;\nimport org.apache.jackrabbit.oak.api.PropertyState;\nimport org.apache.jackrabbit.oak.api.Type;\nimport org.apache.jackrabbit.oak.plugins.blob.BlobStoreBlob;\nimport org.apache.jackrabbit.oak.plugins.memory.PropertyBuilder;\nimport org.apache.jackrabbit.oak.spi.blob.split.SplitBlobStore;\nimport org.apache.jackrabbit.oak.spi.commit.CommitInfo;\nimport org.apache.jackrabbit.oak.spi.commit.EmptyHook;\nimport org.apache.jackrabbit.oak.spi.state.ChildNodeEntry;\nimport org.apache.jackrabbit.oak.spi.state.NodeBuilder;\nimport org.apache.jackrabbit.oak.spi.state.NodeState;\nimport org.apache.jackrabbit.oak.spi.state.NodeStore;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class BlobMigrator {\n\n    private static final Logger log = LoggerFactory.getLogger(BlobMigrator.class);\n\n    private static final int MERGE_LIMIT = 100;\n\n    private static final int MERGE_TIMEOUT = 30;\n\n    private final SplitBlobStore blobStore;\n\n    private final NodeStore nodeStore;\n\n    private final AtomicBoolean stopMigration = new AtomicBoolean(false);\n\n    private DepthFirstNodeIterator nodeIterator;\n\n    private NodeBuilder rootBuilder;\n\n    private long lastCommit;\n\n    private int migratedNodes;\n\n    private volatile String lastPath;\n\n    private volatile int totalMigratedNodes;\n\n    public BlobMigrator(SplitBlobStore blobStore, NodeStore nodeStore) {\n        this.blobStore = blobStore;\n        this.nodeStore = nodeStore;\n    }\n\n    public boolean start() throws IOException {\n        totalMigratedNodes = 0;\n        refreshAndReset(nodeStore.getRoot());\n        return migrate();\n    }\n\n    public boolean migrate() throws IOException {\n        if (nodeIterator == null) {\n            refreshAndReset(nodeStore.getRoot());\n        }\n\n        do {\n            while (nodeIterator.hasNext()) {\n                lastPath = nodeIterator.getPath();\n                if (stopMigration.getAndSet(false)) {\n                    if (migratedNodes > 0) {\n                        tryCommit();\n                    }\n                    return false;\n                }\n                migrateNode(rootBuilder, nodeIterator);\n                if (timeToCommit()) {\n                    tryCommit();\n                }\n            }\n            // at this point we iterated over the whole repository\n            // the last thing to do is to check if we don't have\n            // any nodes waiting to be migrated. if the operation\n            // fails we have to start from the beginning\n        } while (migratedNodes > 0 && !tryCommit());\n        return true;\n    }\n\n<fim_suffix>    private boolean tryCommit() {\n        try {\n            NodeState newRoot = nodeStore.merge(rootBuilder, EmptyHook.INSTANCE, CommitInfo.EMPTY);\n            totalMigratedNodes += migratedNodes;\n            log.info(\"{} nodes merged succesfully. Nodes migrated in this session: {}\", migratedNodes, totalMigratedNodes);\n            lastCommit = System.currentTimeMillis();\n            migratedNodes = 0;\n\n            rootBuilder = newRoot.builder();\n            nodeIterator = nodeIterator.switchRoot(newRoot);\n\n            return true;\n        } catch (CommitFailedException e) {\n            log.error(\"Can't commit. Resetting the migrator\", e);\n            refreshAndReset(nodeStore.getRoot());\n            return false;\n        }\n    }\n\n    private boolean timeToCommit() {\n        long changesMerged = (System.currentTimeMillis() - lastCommit) / 1000;\n        if (migratedNodes >= MERGE_LIMIT) {\n            log.info(\"Migrated nodes count: {}. Merging changes.\", migratedNodes);\n            return true;\n        } else if (migratedNodes > 0 && changesMerged >= MERGE_TIMEOUT) {\n            log.info(\"Changes have been merged {}s ago. Merging {} nodes.\", changesMerged, migratedNodes);\n            return true;\n        }\n        return false;\n    }\n\n    public void stop() {\n        stopMigration.set(true);\n    }\n\n    public String getLastProcessedPath() {\n        return lastPath;\n    }\n\n    public int getTotalMigratedNodes() {\n        return totalMigratedNodes;\n    }\n\n    private void refreshAndReset(NodeState rootState) {\n        rootBuilder = rootState.builder();\n        nodeIterator = new DepthFirstNodeIterator(rootState);\n        lastPath = null;\n        lastCommit = System.currentTimeMillis();\n        migratedNodes = 0;\n    }\n\n    private void migrateNode(NodeBuilder rootBuilder, DepthFirstNodeIterator iterator) throws IOException {\n        ChildNodeEntry node = iterator.next();\n        NodeState state = node.getNodeState();\n        for (PropertyState property : state.getProperties()) {\n            PropertyState newProperty;\n            if (property.getType() == Type.BINARY) {\n                newProperty = migrateProperty(property);\n            } else if (property.getType() == Type.BINARIES) {\n                newProperty = migrateMultiProperty(property);\n            } else {\n                newProperty = null;\n            }\n            if (newProperty != null) {\n                NodeBuilder builder = iterator.getBuilder(rootBuilder);\n                if (builder.exists()) {\n                    builder.setProperty(newProperty);\n                    migratedNodes++;\n                    log.debug(\"Migrated property {}/{}\", lastPath, property.getName());\n                } else {\n                    log.warn(\"Can't migrate blobs for a non-existing node: {}\", lastPath);\n                }\n            }\n        }\n    }\n\n    private PropertyState migrateProperty(PropertyState propertyState) throws IOException {\n        Blob oldBlob = propertyState.getValue(Type.BINARY);\n        String blobId = getIdentity(oldBlob);\n        if (blobStore.isMigrated(blobId)) {\n            return null;\n        }\n\n        String newBlobId = blobStore.writeBlob(oldBlob.getNewStream());\n        Blob newBlob = new BlobStoreBlob(blobStore, newBlobId);\n        PropertyBuilder<Blob> builder = new PropertyBuilder<Blob>(Type.BINARY);\n        builder.assignFrom(propertyState);\n        builder.setValue(newBlob);\n        return builder.getPropertyState();\n    }\n\n    private PropertyState migrateMultiProperty(PropertyState propertyState) throws IOException {\n        Iterable<Blob> oldBlobs = propertyState.getValue(Type.BINARIES);\n        List<Blob> newBlobs = new ArrayList<Blob>();\n        PropertyBuilder<Blob> builder = new PropertyBuilder<Blob>(Type.BINARY);\n        builder.assignFrom(propertyState);\n        boolean blobUpdated = false;\n        for (Blob oldBlob : oldBlobs) {\n            String blobId = getIdentity(oldBlob);\n            if (blobStore.isMigrated(blobId)) {\n                newBlobs.add(new BlobStoreBlob(blobStore, blobId));\n            } else {\n                String newBlobId = blobStore.writeBlob(oldBlob.getNewStream());\n                Blob newBlob = new BlobStoreBlob(blobStore, newBlobId);\n                newBlobs.add(newBlob);\n                blobUpdated = true;\n            }\n        }\n        if (blobUpdated) {\n            builder.setValues(newBlobs);\n            return builder.getPropertyState();\n        } else {\n            return null;\n        }\n    }\n\n    private String getIdentity(Blob blob) throws IOException {\n        String id = blob.getContentIdentity();\n        if (id == null) {\n            id = DigestUtils.shaHex(blob.getNewStream());\n        }\n        return id;\n    }\n}<fim_middle>// function below has no smell\n"}