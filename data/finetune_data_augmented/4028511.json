{"text": "<fim_prefix>import net.bytebuddy.implementation.bytecode.assign.TypeCasting;\nimport net.bytebuddy.implementation.bytecode.collection.ArrayAccess;\nimport net.bytebuddy.implementation.bytecode.collection.ArrayFactory;\nimport net.bytebuddy.implementation.bytecode.constant.IntegerConstant;\nimport net.bytebuddy.implementation.bytecode.member.MethodInvocation;\nimport net.bytebuddy.implementation.bytecode.member.MethodReturn;\nimport net.bytebuddy.implementation.bytecode.member.MethodVariableAccess;\nimport net.bytebuddy.matcher.ElementMatchers;\nimport net.bytebuddy.utility.RandomString;\nimport org.apache.avro.generic.GenericFixed;\nimport org.apache.beam.sdk.schemas.FieldValueGetter;\nimport org.apache.beam.sdk.schemas.FieldValueSetter;\nimport org.apache.beam.sdk.schemas.FieldValueTypeInformation;\nimport org.apache.beam.sdk.values.TypeDescriptor;\nimport org.apache.beam.sdk.values.TypeParameter;\nimport org.apache.beam.vendor.guava.v20_0.com.google.common.collect.Lists;\nimport org.apache.beam.vendor.guava.v20_0.com.google.common.collect.Maps;\nimport org.apache.commons.lang3.ArrayUtils;\nimport org.apache.commons.lang3.ClassUtils;\nimport org.joda.time.Instant;\nimport org.joda.time.ReadableInstant;\nclass ByteBuddyUtils {\n  private static final ForLoadedType ARRAYS_TYPE = new ForLoadedType(Arrays.class);\n  private static final ForLoadedType ARRAY_UTILS_TYPE = new ForLoadedType(ArrayUtils.class);\n  private static final ForLoadedType BYTE_ARRAY_TYPE = new ForLoadedType(byte[].class);\n  private static final ForLoadedType BYTE_BUFFER_TYPE = new ForLoadedType(ByteBuffer.class);\n  private static final ForLoadedType CHAR_SEQUENCE_TYPE = new ForLoadedType(CharSequence.class);\n  private static final ForLoadedType INSTANT_TYPE = new ForLoadedType(Instant.class);\n  private static final ForLoadedType LIST_TYPE = new ForLoadedType(List.class);\n  private static final ForLoadedType READABLE_INSTANT_TYPE =\n      new ForLoadedType(ReadableInstant.class);\n  /**\n   * A naming strategy for ByteBuddy classes.\n   *\n   * <p>We always inject the generator classes in the same same package as the user's target class.\n   * This way, if the class fields or methods are package private, our generated class can still\n   * access them.\n   */\n  static class InjectPackageStrategy extends NamingStrategy.AbstractBase {\n    /** A resolver for the base name for naming the unnamed type. */\n    private static final BaseNameResolver baseNameResolver =\n        BaseNameResolver.ForUnnamedType.INSTANCE;\n    private static final String SUFFIX = \"SchemaCodeGen\";\n    private final RandomString randomString;\n    private final String targetPackage;\n    public InjectPackageStrategy(Class<?> baseType) {\n      randomString = new RandomString();\n      this.targetPackage = baseType.getPackage().getName();\n    }\n    @Override\n    protected String name(TypeDescription superClass) {\n      String baseName = baseNameResolver.resolve(superClass);\n      int lastDot = baseName.lastIndexOf('.');\n      String className = baseName.substring(lastDot, baseName.length());\n      return targetPackage + className + \"$\" + SUFFIX + \"$\" + randomString.nextString();\n    }\n  };\n  // Create a new FieldValueGetter subclass.\n  @SuppressWarnings(\"unchecked\")\n  static DynamicType.Builder<FieldValueGetter> subclassGetterInterface(\n      ByteBuddy byteBuddy, Type objectType, Type fieldType) {\n    TypeDescription.Generic getterGenericType =\n        TypeDescription.Generic.Builder.parameterizedType(\n                FieldValueGetter.class, objectType, fieldType)\n            .build();\n    return (DynamicType.Builder<FieldValueGetter>)\n        byteBuddy.with(new InjectPackageStrategy((Class) objectType)).subclass(getterGenericType);\n  }\n  // Create a new FieldValueSetter subclass.\n  @SuppressWarnings(\"unchecked\")\n  static DynamicType.Builder<FieldValueSetter> subclassSetterInterface(\n      ByteBuddy byteBuddy, Type objectType, Type fieldType) {\n    TypeDescription.Generic setterGenericType =\n        TypeDescription.Generic.Builder.parameterizedType(\n                FieldValueSetter.class, objectType, fieldType)\n            .build();\n    return (DynamicType.Builder<FieldValueSetter>)\n        byteBuddy.with(new InjectPackageStrategy((Class) objectType)).subclass(setterGenericType);\n  }\n  // Base class used below to convert types.\n  @SuppressWarnings(\"unchecked\")\n  abstract static class TypeConversion<T> {\n    public T convert(TypeDescriptor typeDescriptor) {\n      if (typeDescriptor.isArray()\n          && !typeDescriptor.getComponentType().getRawType().equals(byte.class)) {\n        // Byte arrays are special, so leave those alone.\n        return convertArray(typeDescriptor);\n      } else if (typeDescriptor.isSubtypeOf(TypeDescriptor.of(Collection.class))) {\n        return convertCollection(typeDescriptor);\n      } else if (typeDescriptor.isSubtypeOf(TypeDescriptor.of(Map.class))) {\n        return convertMap(typeDescriptor);\n      } else if (typeDescriptor.isSubtypeOf(TypeDescriptor.of(ReadableInstant.class))) {\n        return convertDateTime(typeDescriptor);\n      } else if (typeDescriptor.isSubtypeOf(TypeDescriptor.of(ByteBuffer.class))) {\n        return convertByteBuffer(typeDescriptor);\n      } else if (typeDescriptor.isSubtypeOf(TypeDescriptor.of(GenericFixed.class))) {\n        // TODO: Refactor AVRO-specific check into separate class.\n        return convertGenericFixed(typeDescriptor);\n      } else if (typeDescriptor.isSubtypeOf(TypeDescriptor.of(CharSequence.class))) {\n        return convertCharSequence(typeDescriptor);\n      } else if (typeDescriptor.getRawType().isPrimitive()) {\n        return convertPrimitive(typeDescriptor);\n      } else {\n        return convertDefault(typeDescriptor);\n      }\n    }\n    protected abstract T convertArray(TypeDescriptor<?> type);\n    protected abstract T convertCollection(TypeDescriptor<?> type);\n    protected abstract T convertMap(TypeDescriptor<?> type);\n    protected abstract T convertDateTime(TypeDescriptor<?> type);\n    protected abstract T convertByteBuffer(TypeDescriptor<?> type);\n    protected abstract T convertGenericFixed(TypeDescriptor<?> type);\n    protected abstract T convertCharSequence(TypeDescriptor<?> type);\n    protected abstract T convertPrimitive(TypeDescriptor<?> type);\n    protected abstract T convertDefault(TypeDescriptor<?> type);\n  }\n  /**\n   * Give a Java type, returns the Java type expected for use with Row. For example, both {@link\n   * StringBuffer} and {@link String} are represented as a {@link String} in Row. This determines\n   * what the return type of the getter will be. For instance, the following POJO class:\n   *\n   * <pre><code>\n   * class POJO {\n   *   StringBuffer str;\n   *   int[] array;\n   * }\n   * </code></pre>\n   *\n   * Generates the following getters:\n   *\n   * <pre><code>{@literal FieldValueGetter<POJO, String>}</code></pre>\n   *\n   * <pre><code>{@literal FieldValueGetter<POJO, List<Integer>>}</code></pre>\n   */\n<fim_suffix>  static class ConvertType extends TypeConversion<Type> {\n    private boolean returnRawTypes;\n    public ConvertType(boolean returnRawTypes) {\n      this.returnRawTypes = returnRawTypes;\n    }\n    @Override\n    protected Type convertArray(TypeDescriptor<?> type) {\n      TypeDescriptor ret = createListType(type);\n      return returnRawTypes ? ret.getRawType() : ret.getType();\n    }\n    @Override\n    protected Type convertCollection(TypeDescriptor<?> type) {\n      return Collection.class;\n    }\n    @Override\n    protected Type convertMap(TypeDescriptor<?> type) {\n      return Map.class;\n    }\n    @Override\n    protected Type convertDateTime(TypeDescriptor<?> type) {\n      return Instant.class;\n    }\n    @Override\n    protected Type convertByteBuffer(TypeDescriptor<?> type) {\n      return byte[].class;\n    }\n    @Override\n    protected Type convertGenericFixed(TypeDescriptor<?> type) {\n      return byte[].class;\n    }\n    @Override\n    protected Type convertCharSequence(TypeDescriptor<?> type) {\n      return String.class;\n    }\n    @Override\n    protected Type convertPrimitive(TypeDescriptor<?> type) {\n      return ClassUtils.primitiveToWrapper(type.getRawType());\n    }\n    @Override\n    protected Type convertDefault(TypeDescriptor<?> type) {\n      return returnRawTypes ? type.getRawType() : type.getType();\n    }\n    @SuppressWarnings(\"unchecked\")\n    private <ElementT> TypeDescriptor<List<ElementT>> createListType(TypeDescriptor<?> type) {\n      TypeDescriptor componentType =\n          TypeDescriptor.of(ClassUtils.primitiveToWrapper(type.getComponentType().getRawType()));\n      return new TypeDescriptor<List<ElementT>>() {}.where(\n          new TypeParameter<ElementT>() {}, componentType);\n    }\n  }<fim_middle>// class below has no smell\n"}