{"text": "<fim_prefix>/*\n * reserved comment block\n * DO NOT REMOVE OR ALTER!\n */\n/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.sun.org.apache.xerces.internal.impl.xpath.regex;\nimport java.util.ArrayList;\n/**\n * @xerces.internal\n *\n */\nclass Op {\n    static final int DOT = 0;\n    static final int CHAR = 1;                  // Single character\n    static final int RANGE = 3;                 // [a-zA-Z]\n    static final int NRANGE = 4;                // [^a-zA-Z]\n    static final int ANCHOR = 5;                // ^ $ ...\n    static final int STRING = 6;                // literal String\n    static final int CLOSURE = 7;               // X*\n    static final int NONGREEDYCLOSURE = 8;      // X*?\n    static final int QUESTION = 9;              // X?\n    static final int NONGREEDYQUESTION = 10;    // X??\n    static final int UNION = 11;                // X|Y\n    static final int CAPTURE = 15;              // ( and )\n    static final int BACKREFERENCE = 16;        // \\1 \\2 ...\n    static final int LOOKAHEAD = 20;            // (?=...)\n    static final int NEGATIVELOOKAHEAD = 21;    // (?!...)\n    static final int LOOKBEHIND = 22;           // (?<=...)\n    static final int NEGATIVELOOKBEHIND = 23;   // (?<!...)\n    static final int INDEPENDENT = 24;          // (?>...)\n    static final int MODIFIER = 25;             // (?ims-ims:...)\n    static final int CONDITION = 26;            // (?(..)yes|no)\n    static int nofinstances = 0;\n    static final boolean COUNT = false;\n    static Op createDot() {\n        if (Op.COUNT)  Op.nofinstances ++;\n        return new Op(Op.DOT);\n    }\n    static CharOp createChar(int data) {\n        if (Op.COUNT)  Op.nofinstances ++;\n        return new CharOp(Op.CHAR, data);\n    }\n    static CharOp createAnchor(int data) {\n        if (Op.COUNT)  Op.nofinstances ++;\n        return new CharOp(Op.ANCHOR, data);\n    }\n    static CharOp createCapture(int number, Op next) {\n        if (Op.COUNT)  Op.nofinstances ++;\n        CharOp op = new CharOp(Op.CAPTURE, number);\n        op.next = next;\n        return op;\n    }\n    static UnionOp createUnion(int size) {\n        if (Op.COUNT)  Op.nofinstances ++;\n        //System.err.println(\"Creates UnionOp\");\n        return new UnionOp(Op.UNION, size);\n    }\n    static ChildOp createClosure(int id) {\n        if (Op.COUNT)  Op.nofinstances ++;\n        return new ModifierOp(Op.CLOSURE, id, -1);\n    }\n    static ChildOp createNonGreedyClosure() {\n        if (Op.COUNT)  Op.nofinstances ++;\n        return new ChildOp(Op.NONGREEDYCLOSURE);\n    }\n    static ChildOp createQuestion(boolean nongreedy) {\n        if (Op.COUNT)  Op.nofinstances ++;\n        return new ChildOp(nongreedy ? Op.NONGREEDYQUESTION : Op.QUESTION);\n    }\n    static RangeOp createRange(Token tok) {\n        if (Op.COUNT)  Op.nofinstances ++;\n        return new RangeOp(Op.RANGE, tok);\n    }\n    static ChildOp createLook(int type, Op next, Op branch) {\n        if (Op.COUNT)  Op.nofinstances ++;\n        ChildOp op = new ChildOp(type);\n        op.setChild(branch);\n        op.next = next;\n        return op;\n    }\n    static CharOp createBackReference(int refno) {\n        if (Op.COUNT)  Op.nofinstances ++;\n        return new CharOp(Op.BACKREFERENCE, refno);\n    }\n    static StringOp createString(String literal) {\n        if (Op.COUNT)  Op.nofinstances ++;\n        return new StringOp(Op.STRING, literal);\n    }\n    static ChildOp createIndependent(Op next, Op branch) {\n        if (Op.COUNT)  Op.nofinstances ++;\n        ChildOp op = new ChildOp(Op.INDEPENDENT);\n        op.setChild(branch);\n        op.next = next;\n        return op;\n    }\n    static ModifierOp createModifier(Op next, Op branch, int add, int mask) {\n        if (Op.COUNT)  Op.nofinstances ++;\n        ModifierOp op = new ModifierOp(Op.MODIFIER, add, mask);\n        op.setChild(branch);\n        op.next = next;\n        return op;\n    }\n    static ConditionOp createCondition(Op next, int ref, Op conditionflow, Op yesflow, Op noflow) {\n        if (Op.COUNT)  Op.nofinstances ++;\n        ConditionOp op = new ConditionOp(Op.CONDITION, ref, conditionflow, yesflow, noflow);\n        op.next = next;\n        return op;\n    }\n    final int type;\n    Op next = null;\n    protected Op(int type) {\n        this.type = type;\n    }\n    int size() {                                // for UNION\n        return 0;\n    }\n    Op elementAt(int index) {                   // for UNIoN\n        throw new RuntimeException(\"Internal Error: type=\"+this.type);\n    }\n    Op getChild() {                             // for CLOSURE, QUESTION\n        throw new RuntimeException(\"Internal Error: type=\"+this.type);\n    }\n                                                // ModifierOp\n    int getData() {                             // CharOp  for CHAR, BACKREFERENCE, CAPTURE, ANCHOR,\n        throw new RuntimeException(\"Internal Error: type=\"+this.type);\n    }\n    int getData2() {                            // ModifierOp\n        throw new RuntimeException(\"Internal Error: type=\"+this.type);\n    }\n    RangeToken getToken() {                     // RANGE, NRANGE\n        throw new RuntimeException(\"Internal Error: type=\"+this.type);\n    }\n    String getString() {                        // STRING\n        throw new RuntimeException(\"Internal Error: type=\"+this.type);\n    }\n    // ================================================================\n    static class CharOp extends Op {\n        final int charData;\n        CharOp(int type, int data) {\n            super(type);\n            this.charData = data;\n        }\n        int getData() {\n            return this.charData;\n        }\n    }\n    // ================================================================\n    static class UnionOp extends Op {\n        final ArrayList<Op> branches;\n        UnionOp(int type, int size) {\n            super(type);\n            this.branches = new ArrayList<>(size);\n        }\n        void addElement(Op op) {\n            this.branches.add(op);\n        }\n        int size() {\n            return this.branches.size();\n        }\n        Op elementAt(int index) {\n            return this.branches.get(index);\n        }\n    }\n    // ================================================================\n    static class ChildOp extends Op {\n        Op child;\n        ChildOp(int type) {\n            super(type);\n        }\n        void setChild(Op child) {\n            this.child = child;\n        }\n        Op getChild() {\n            return this.child;\n        }\n    }\n    // ================================================================\n<fim_suffix>    static class ModifierOp extends ChildOp {\n        final int v1;\n        final int v2;\n        ModifierOp(int type, int v1, int v2) {\n            super(type);\n            this.v1 = v1;\n            this.v2 = v2;\n        }\n        int getData() {\n            return this.v1;\n        }\n        int getData2() {\n            return this.v2;\n        }\n    }\n    // ================================================================\n    static class RangeOp extends Op {\n        final Token tok;\n        RangeOp(int type, Token tok) {\n            super(type);\n            this.tok = tok;\n        }\n        RangeToken getToken() {\n            return (RangeToken)this.tok;\n        }\n    }\n    // ================================================================\n    static class StringOp extends Op {\n        final String string;\n        StringOp(int type, String literal) {\n            super(type);\n            this.string = literal;\n        }\n        String getString() {\n            return this.string;\n        }\n    }\n    // ================================================================<fim_middle>// class below is data class\n"}