{"text": "<fim_prefix>\n<fim_suffix>@SuppressWarnings(\"deprecation\")\npublic class MRBaseForCommonInstructions extends MapReduceBase\n{\n\t//indicate whether the matrix value in this mapper is a matrix cell or a matrix block\n\tprotected Class<? extends MatrixValue> valueClass;\n\t//a cache to hold the intermediate results\n\tprotected CachedValueMap cachedValues=new CachedValueMap();\n\t//distributed cache data handling\n\tpublic static boolean isJobLocal = false; //set from MapperBase\n\tpublic static HashMap<Byte, DistributedCacheInput> dcValues = new HashMap<>();\n\tprotected HashMap<Byte, MatrixCharacteristics> dimensions=new HashMap<>();\n\t//temporary variables\n\tprotected IndexedMatrixValue tempValue=null;\n\tprotected IndexedMatrixValue zeroInput=null;\t\n\t@Override\n\tpublic void configure(JobConf job)\n\t{\t\n\t\t//whether to use the cell representation or the block representation\n\t\tvalueClass=MRJobConfiguration.getMatrixValueClass(job);\n\t\t//allocate space for temporary variables\n\t\ttempValue=new IndexedMatrixValue(valueClass);\n\t\tzeroInput=new IndexedMatrixValue(valueClass);\n\t\t//matrix characteristics inputs/outputs\n\t\tbyte[] inputIX = MRJobConfiguration.getInputIndexesInMapper(job);\n\t\tfor( byte ix : inputIX )\n\t\t\tdimensions.put(ix, MRJobConfiguration.getMatrixCharacteristicsForInput(job, ix));\t\n\t\tbyte[] mapOutputIX = MRJobConfiguration.getOutputIndexesInMapper(job);\n\t\tfor(byte ix : mapOutputIX)\n\t\t\tdimensions.put(ix, MRJobConfiguration.getMatrixCharacteristicsForMapOutput(job, ix));\n\t\tbyte[] outputIX = MRJobConfiguration.getResultIndexes(job);\n\t\tfor( byte ix : outputIX )\n\t\t\tdimensions.put(ix, MRJobConfiguration.getMatrixCharacteristicsForOutput(job, ix));\t\n\t\t//matrix characteristics intermediates\n\t\tbyte[] immediateIndexes=MRJobConfiguration.getIntermediateMatrixIndexes(job);\n\t\tif(immediateIndexes!=null)\n\t\t{\n\t\t\tfor(byte index: immediateIndexes)\n\t\t\t\tdimensions.put(index, MRJobConfiguration.getIntermediateMatrixCharactristics(job, index));\t\t\t\n\t\t}\n\t}\n\tprotected void collectOutput_N_Increase_Counter(MatrixIndexes indexes, MatrixValue value, \n\t\t\tint i, Reporter reporter, CollectMultipleConvertedOutputs collectFinalMultipleOutputs, \n\t\t\tbyte[] resultDimsUnknown, long[] resultsNonZeros, long[] resultsMaxRowDims, \n\t\t\tlong[] resultsMaxColDims) throws IOException\n\t{\n \t\tcollectFinalMultipleOutputs.collectOutput(indexes, value, i, reporter);\n\t\tresultsNonZeros[i]+=value.getNonZeros();\n\t\tif ( resultDimsUnknown[i] == (byte) 1 ) \n\t\t{\n\t\t\t// compute dimensions for the resulting matrix\n\t\t\t// find the maximum row index and column index encountered in current output block/cell \n\t\t\tlong maxrow = getMaxDimension(indexes, value, true);\n\t\t\tlong maxcol = getMaxDimension(indexes, value, false);\n\t\t\tif ( maxrow > resultsMaxRowDims[i] )\n\t\t\t\tresultsMaxRowDims[i] = maxrow;\n\t\t\tif ( maxcol > resultsMaxColDims[i] )\n\t\t\t\tresultsMaxColDims[i] = maxcol;\n\t\t}\n\t\telse if(resultDimsUnknown[i] == (byte) 2)\n\t\t{\n\t\t\tif ( indexes.getRowIndex() > resultsMaxRowDims[i] )\n\t\t\t\tresultsMaxRowDims[i] = indexes.getRowIndex();\n\t\t\tif ( indexes.getColumnIndex() > resultsMaxColDims[i] )\n\t\t\t\tresultsMaxColDims[i] = indexes.getColumnIndex();\n\t\t}\n\t}\n\tprotected void processMixedInstructions(ArrayList<MRInstruction> mixed_instructions) {\n\t\tif( mixed_instructions != null )\n\t\t\tfor( MRInstruction ins : mixed_instructions )\n\t\t\t\tprocessOneInstruction(ins, valueClass, cachedValues, tempValue, zeroInput);\n\t}\n\tprotected void processOneInstruction(MRInstruction ins, Class<? extends MatrixValue> valueClass,\n\t\t\tCachedValueMap cachedValues, IndexedMatrixValue tempValue, IndexedMatrixValue zeroInput) {\n\t\t//Timing time = new Timing(true);\n\t\tif ( ins instanceof AggregateBinaryInstruction ) {\n\t\t\tbyte input = ((AggregateBinaryInstruction)ins).input1;\n\t\t\tMatrixCharacteristics dim=dimensions.get(input);\n\t\t\tif(dim==null)\n\t\t\t\tthrow new DMLRuntimeException(\"dimension for instruction \"+ins+\"  is unset!!!\");\n\t\t\tins.processInstruction(valueClass, cachedValues, tempValue, zeroInput, dim.getRowsPerBlock(), dim.getColsPerBlock());\n\t\t}\n\t\telse if(ins instanceof ZeroOutInstruction || ins instanceof AggregateUnaryInstruction \n\t\t\t\t|| ins instanceof RangeBasedReIndexInstruction || ins instanceof CumulativeSplitInstruction)\n\t\t{\n\t\t\tbyte input=((UnaryMRInstructionBase) ins).input;\n\t\t\tMatrixCharacteristics dim=dimensions.get(input);\n\t\t\tif(dim==null)\n\t\t\t\tthrow new DMLRuntimeException(\"dimension for instruction \"+ins+\"  is unset!!!\");\n\t\t\tif( ins instanceof CumulativeAggregateInstruction )\n\t\t\t\t((CumulativeAggregateInstruction)ins).setMatrixCharacteristics(dim);\n\t\t\tif( ins instanceof CumulativeSplitInstruction )\n\t\t\t\t((CumulativeSplitInstruction)ins).setMatrixCharacteristics(dim);\n\t\t\tins.processInstruction(valueClass, cachedValues, tempValue, zeroInput, dim.getRowsPerBlock(), dim.getColsPerBlock());\n\t\t}\n\t\telse if( ins instanceof ReorgInstruction )\n\t\t{\n\t\t\tReorgInstruction rinst = (ReorgInstruction) ins;\n\t\t\tbyte input = rinst.input;\n\t\t\tMatrixCharacteristics dim = dimensions.get(input);\n\t\t\tif(dim==null)\n\t\t\t\tthrow new DMLRuntimeException(\"dimension for instruction \"+ins+\"  is unset!!!\");\n\t\t\trinst.setInputMatrixCharacteristics(dim);\n\t\t\trinst.setOutputEmptyBlocks(!(this instanceof MMCJMRMapper)); //MMCJMRMapper does not output empty blocks, no need to generate\n\t\t\tins.processInstruction(valueClass, cachedValues, tempValue, zeroInput, dim.getRowsPerBlock(), dim.getColsPerBlock());\n\t\t}\n\t\telse if( ins instanceof MatrixReshapeMRInstruction )\n\t\t{\n\t\t\tMatrixReshapeMRInstruction mrins = (MatrixReshapeMRInstruction) ins;\n\t\t\tbyte input = mrins.input;\n\t\t\tbyte output = mrins.output; \n\t\t\tMatrixCharacteristics dimIn=dimensions.get(input);\n\t\t\tMatrixCharacteristics dimOut=dimensions.get(output);\n\t\t\tif(dimIn==null || dimOut==null)\n\t\t\t\tthrow new DMLRuntimeException(\"dimension for instruction \"+ins+\"  is unset!!!\");\n\t\t\tmrins.setMatrixCharacteristics(dimIn, dimOut);\n\t\t\tmrins.processInstruction(valueClass, cachedValues, tempValue, zeroInput, dimIn.getRowsPerBlock(), dimIn.getColsPerBlock());\n\t\t}\n\t\telse if(ins instanceof AppendMInstruction)\n\t\t{\n\t\t\tbyte input=((AppendMInstruction) ins).input1;\n\t\t\tMatrixCharacteristics dim=dimensions.get(input);\n\t\t\tif(dim==null)\n\t\t\t\tthrow new DMLRuntimeException(\"dimension for instruction \"+ins+\"  is unset!!!\");\n\t\t\tins.processInstruction(valueClass, cachedValues, tempValue, zeroInput, dim.getRowsPerBlock(), dim.getColsPerBlock());\n\t\t}\n\t\telse if(ins instanceof BinaryMInstruction || ins instanceof RemoveEmptyMRInstruction )\n\t\t{\n\t\t\tbyte input=((BinaryMRInstructionBase) ins).input1;\n\t\t\tMatrixCharacteristics dim=dimensions.get(input);\n\t\t\tif(dim==null)\n\t\t\t\tthrow new DMLRuntimeException(\"dimension for instruction \"+ins+\"  is unset!!!\");\n\t\t\tins.processInstruction(valueClass, cachedValues, tempValue, zeroInput, dim.getRowsPerBlock(), dim.getColsPerBlock());\n\t\t}\n\t\telse if(ins instanceof AppendGInstruction)\n\t\t{\n\t\t\tAppendGInstruction arinst = ((AppendGInstruction) ins);\n\t\t\tbyte input = arinst.input1;\n\t\t\tMatrixCharacteristics dimIn=dimensions.get(input);\n\t\t\tif( dimIn==null )\n\t\t\t\tthrow new DMLRuntimeException(\"Dimensions for instruction \"+arinst+\"  is unset!!!\");\n\t\t\tarinst.processInstruction(valueClass, cachedValues, tempValue, zeroInput, dimIn.getRowsPerBlock(), dimIn.getColsPerBlock());\n\t\t}\n\t\telse if(ins instanceof UnaryMRInstructionBase)\n\t\t{\n\t\t\tUnaryMRInstructionBase rinst = (UnaryMRInstructionBase) ins;\n\t\t\tMatrixCharacteristics dimIn=dimensions.get(rinst.input);\n\t\t\tif( dimIn==null )\n\t\t\t\tthrow new DMLRuntimeException(\"Dimensions for instruction \"+rinst+\"  is unset!!!\");\n\t\t\trinst.processInstruction(valueClass, cachedValues, tempValue, zeroInput, dimIn.getRowsPerBlock(), dimIn.getColsPerBlock());<fim_middle>// class below is blob\n"}