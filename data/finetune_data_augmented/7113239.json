{"text": "<fim_prefix>    final class KeySet extends AbstractSet<K> {\n        public final int size()                 { return size; }\n        public final void clear()               { HashMap.this.clear(); }\n        public final Iterator<K> iterator()     { return new KeyIterator(); }\n        public final boolean contains(Object o) { return containsKey(o); }\n        public final boolean remove(Object key) {\n            return removeNode(hash(key), key, null, false, true) != null;\n        }\n        public final Spliterator<K> spliterator() {\n            return new KeySpliterator<>(HashMap.this, 0, -1, 0, 0);\n        }\n        public final void forEach(Consumer<? super K> action) {\n            Node<K,V>[] tab;\n            if (action == null)\n                throw new NullPointerException();\n            if (size > 0 && (tab = table) != null) {\n                int mc = modCount;\n                // Android-changed: Detect changes to modCount early.\n                for (int i = 0; (i < tab.length && modCount == mc); ++i) {\n                    for (Node<K,V> e = tab[i]; e != null; e = e.next)\n                        action.accept(e.key);\n                }\n                if (modCount != mc)\n                    throw new ConcurrentModificationException();\n            }\n        }\n        /*-[\n        - (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state\n                                          objects:(__unsafe_unretained id *)stackbuf\n                                            count:(NSUInteger)len {\n          NSUInteger objCount =\n              [this$0_ enumerateEntriesWithState:state objects:stackbuf count:len];\n          for (id *e = state->itemsPtr, *end = e + objCount; e < end; e++) {\n            *e = ((JavaUtilHashMap_Node *) *e)->key_;\n          }\n          return objCount;\n        }\n        RETAINED_WITH_CHILD(this$0_)\n        ]-*/\n    }\n    /**\n     * Returns a {@link Collection} view of the values contained in this map.\n     * The collection is backed by the map, so changes to the map are\n     * reflected in the collection, and vice-versa.  If the map is\n     * modified while an iteration over the collection is in progress\n     * (except through the iterator's own <tt>remove</tt> operation),\n     * the results of the iteration are undefined.  The collection\n     * supports element removal, which removes the corresponding\n     * mapping from the map, via the <tt>Iterator.remove</tt>,\n     * <tt>Collection.remove</tt>, <tt>removeAll</tt>,\n     * <tt>retainAll</tt> and <tt>clear</tt> operations.  It does not\n     * support the <tt>add</tt> or <tt>addAll</tt> operations.\n     *\n     * @return a view of the values contained in this map\n     */\n    public Collection<V> values() {\n        Collection<V> vs = values;\n        if (vs == null) {\n            vs = new Values();\n            values = vs;\n        }\n        return vs;\n    }\n    @WeakOuter\n    final class Values extends AbstractCollection<V> {\n        public final int size()                 { return size; }\n        public final void clear()               { HashMap.this.clear(); }\n        public final Iterator<V> iterator()     { return new ValueIterator(); }\n        public final boolean contains(Object o) { return containsValue(o); }\n        public final Spliterator<V> spliterator() {\n            return new ValueSpliterator<>(HashMap.this, 0, -1, 0, 0);\n        }\n        public final void forEach(Consumer<? super V> action) {\n            Node<K,V>[] tab;\n            if (action == null)\n                throw new NullPointerException();\n            if (size > 0 && (tab = table) != null) {\n                int mc = modCount;\n                // Android-changed: Detect changes to modCount early.\n                for (int i = 0; (i < tab.length && modCount == mc); ++i) {\n                    for (Node<K,V> e = tab[i]; e != null; e = e.next)\n                        action.accept(e.value);\n                }\n                if (modCount != mc)\n                    throw new ConcurrentModificationException();\n            }\n        }\n        /*-[\n        - (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state\n                                          objects:(__unsafe_unretained id *)stackbuf\n                                            count:(NSUInteger)len {\n          NSUInteger objCount =\n              [this$0_ enumerateEntriesWithState:state objects:stackbuf count:len];\n          for (id *e = state->itemsPtr, *end = e + objCount; e < end; e++) {\n            *e = ((JavaUtilHashMap_Node *) *e)->value_;\n          }\n          return objCount;\n        }\n        RETAINED_WITH_CHILD(this$0_)\n        ]-*/\n    }\n    /**\n     * Returns a {@link Set} view of the mappings contained in this map.\n     * The set is backed by the map, so changes to the map are\n     * reflected in the set, and vice-versa.  If the map is modified\n     * while an iteration over the set is in progress (except through\n     * the iterator's own <tt>remove</tt> operation, or through the\n     * <tt>setValue</tt> operation on a map entry returned by the\n     * iterator) the results of the iteration are undefined.  The set\n     * supports element removal, which removes the corresponding\n     * mapping from the map, via the <tt>Iterator.remove</tt>,\n     * <tt>Set.remove</tt>, <tt>removeAll</tt>, <tt>retainAll</tt> and\n     * <tt>clear</tt> operations.  It does not support the\n     * <tt>add</tt> or <tt>addAll</tt> operations.\n     *\n     * @return a set view of the mappings contained in this map\n     */\n    public Set<Map.Entry<K,V>> entrySet() {\n        Set<Map.Entry<K,V>> es;\n        return (es = entrySet) == null ? (entrySet = new EntrySet()) : es;\n    }\n<fim_suffix>    @WeakOuter\n    final class EntrySet extends AbstractSet<Map.Entry<K,V>> {\n        public final int size()                 { return size; }\n        public final void clear()               { HashMap.this.clear(); }\n        public final Iterator<Map.Entry<K,V>> iterator() {\n            return new EntryIterator();\n        }\n        public final boolean contains(Object o) {\n            if (!(o instanceof Map.Entry))\n                return false;\n            Map.Entry<?,?> e = (Map.Entry<?,?>) o;\n            Object key = e.getKey();\n            Node<K,V> candidate = getNode(hash(key), key);\n            return candidate != null && candidate.equals(e);\n        }\n        public final boolean remove(Object o) {\n            if (o instanceof Map.Entry) {\n                Map.Entry<?,?> e = (Map.Entry<?,?>) o;\n                Object key = e.getKey();\n                Object value = e.getValue();\n                return removeNode(hash(key), key, value, true, true) != null;\n            }\n            return false;\n        }\n        public final Spliterator<Map.Entry<K,V>> spliterator() {\n            return new EntrySpliterator<>(HashMap.this, 0, -1, 0, 0);\n        }\n        public final void forEach(Consumer<? super Map.Entry<K,V>> action) {\n            Node<K,V>[] tab;\n            if (action == null)\n                throw new NullPointerException();\n            if (size > 0 && (tab = table) != null) {\n                int mc = modCount;\n                // Android-changed: Detect changes to modCount early.\n                for (int i = 0; (i < tab.length && modCount == mc); ++i) {\n                    for (Node<K,V> e = tab[i]; e != null; e = e.next)\n                        action.accept(e);\n                }\n                if (modCount != mc)\n                    throw new ConcurrentModificationException();\n            }\n        }\n        /*-[\n        - (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state\n                                          objects:(__unsafe_unretained id *)stackbuf\n                                            count:(NSUInteger)len {\n          return [this$0_ enumerateEntriesWithState:state objects:stackbuf count:len];\n        }\n        RETAINED_WITH_CHILD(this$0_)\n        ]-*/\n    }<fim_middle>// class below has no smell\n"}