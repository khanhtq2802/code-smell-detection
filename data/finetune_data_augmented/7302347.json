{"text": "<fim_prefix>     * @param buttonId\n     * @param buttonLabel\n     * @param isDefaultButton\n     */\n    protected void addButtonDescription(final int buttonId, final String buttonLabel, final boolean isDefaultButton) {\n        buttonDescriptions.add(new ButtonDescription(buttonId, buttonLabel, isDefaultButton));\n    }\n    /**\n     * Set the resizability behavior of this dialog.\n     *\n     * <p>\n     * By default, the dialog will be resizable. Subclasses can call this method\n     * to change the default behavior.\n     *\n     * <p>\n     * The recommended place to call this method is from the subclass\n     * constructor.\n     *\n     * @param resizable\n     *        true if the dialog should be resizeable (default true)\n     */\n    protected void setOptionResizable(final boolean resizable) {\n        /*\n         * Just store the resizable option. We tweak the Shell style bits in the\n         * getShellStyle override.\n         */\n        this.resizable = resizable;\n    }\n    /**\n     * Set the minimum size behavior of this dialog.\n     *\n     * <p>\n     * By default, the dialog enforces a minimum size - it will not allow the\n     * user to resize it smaller than the minimum size. Subclasses can call this\n     * method to change the default behavior.\n     *\n     * <p>\n     * The recommended place to call this method is from the subclass\n     * constructor.\n     *\n     * @param enforceMinimumSize\n     *        true to enforce min size for the dialog (default true)\n     */\n    protected void setOptionEnforceMinimumSize(final boolean enforceMinimumSize) {\n        /*\n         * Store the option. We use it in the override of initializeBounds().\n         */\n        this.enforceMinimumSize = enforceMinimumSize;\n    }\n    /**\n     * Set the behavior of this dialog with regard to the default buttons (the\n     * standard OK and Cancel buttons provided by the base JFace dialog class).\n     *\n     * <p>\n     * By default, these standard buttons are included in the button bar.\n     * Subclasses can call this method to change the default behavior.\n     *\n     * <p>\n     * The recommended place to call this method is from the subclass\n     * constructor.\n     *\n     * @param includeDefaultButtons\n     *        true to include the default OK and cancel buttons (default true)\n     */\n    protected void setOptionIncludeDefaultButtons(final boolean includeDefaultButtons) {\n        this.includeDefaultButtons = includeDefaultButtons;\n    }\n    /**\n     * Set the dialog settings key for this dialog. The dialog settings key is\n     * used to match persisted settings like size and location to this dialog.\n     *\n     * <p>\n     * The default is to use the dialog's fully qualified class name as the\n     * settings key. However, if the same dialog class is used differently in\n     * different situations, it may be desirable to use a different settings key\n     * in each situation. Subclasses can call this method to set a new dialog\n     * settings key.\n     *\n     * <p>\n     * The recommended place to call this method is from the subclass\n     * constructor.\n     *\n     * @param dialogSettingsKey\n     *        the settings key for this dialog\n     */\n    protected void setOptionDialogSettingsKey(final String dialogSettingsKey) {\n        this.dialogSettingsKey = dialogSettingsKey;\n    }\n    /**\n     * Set the behavior of this dialog with regard to the persistent size and\n     * location. If this is true, we save the size and position of this dialog\n     * each time it's raised, and restore the size and position when we open a\n     * new dialog of this type. Thus, if a user resizes a dialog, this will open\n     * at their \"preferred\" size.\n     *\n     * <p>\n     * It is recommended that you disable persistentGeometry if you have a\n     * dialog which changes its content (and thus its size) frequently, and just\n     * use the defaults, which are computed by content size.\n     *\n     * <p>\n     * The recommended place to call this method is from the subclass\n     * constructor.\n     *\n     * @param persistGeometry\n     *        persistGeometry true to reuse the size and location of this dialog\n     *        the last time it was raised. (default true)\n     */\n    protected void setOptionPersistGeometry(final boolean persistGeometry) {\n        this.persistGeometry = persistGeometry;\n    }\n    /**\n     * Sets the maximum size of the dialog. You may pass a Point with two int\n     * values and the size of the dialog will be constrained to exactly <x, y>,\n     * or you may pass a Point with either x or y values set to SWT.DEFAULT and\n     * the size of the dialog will be constrained width-wise or height-wise,\n     * respectively.\n     * <p>\n     * The recommended place to call this method is from the subclass\n     * constructor.\n     *\n     * @param constrainedSize\n     *        a Point representing the maximum size of the dialog (either x or y\n     *        may be SWT.DEFAULT)\n     */\n    protected void setOptionConstrainSize(final Point constrainedSize) {\n        this.constrainedSize = constrainedSize;\n    }\n    protected void setOptionResizableDirections(final int directions) {\n        resizableDirections = (directions & (SWT.HORIZONTAL | SWT.VERTICAL));\n    }\n    /**\n     * Subclasses must implement this method to provide a title for the dialog.\n     *\n     * <p>\n     * The title must be localized by the subclass (localization is not built\n     * into this base dialog class).\n     *\n     * <p>\n     * This method will be called by the base class from configureShell(), which\n     * means that the dialog area contents will not yet have been created.\n     *\n     * @return the title to use for this Dialog\n     */\n    protected abstract String provideDialogTitle();\n    /*\n     * GEOMETRY HELPER METHODS\n     *\n     * These methods exist to aide in cross-platform layout. These all provide\n     * the standard spacing and margin sizes for the running platform. It is\n     * strongly recommended that you use these methods instead of hardcoding\n     * non-portable pixel sizes.\n     */\n    /**\n     * This method will provide the horizontal spacing (in pixels) for controls\n     * on this platform.\n     *\n     * @return Horizontal spacing of controls (in pixels)\n     */\n    public int getHorizontalSpacing() {\n        return convertHorizontalDLUsToPixels(IDialogConstants.HORIZONTAL_SPACING);\n    }\n    /**\n     * This method will provide the vertical spacing (in pixels) for controls on\n     * this platform.\n     *\n     * @return Vertical spacing of controls (in pixels)\n     */\n    public int getVerticalSpacing() {\n        return convertHorizontalDLUsToPixels(IDialogConstants.VERTICAL_SPACING);\n    }\n    /**\n     * This method will provide the default control spacing (in pixels) for\n     * controls on this platform. It is the maximum of horizontal and vertical\n     * spacing. (Same on most platforms.)\n     *\n     * @return Spacing of controls (in pixels)\n     */\n    public int getSpacing() {\n        return Math.max(getHorizontalSpacing(), getVerticalSpacing());\n    }\n    /**\n     * This method will return the margin width or \"gutter\" (in pixels) for\n     * dialogs on this platform.\n     *\n     * @return Width of the margin around dialogs and controls (in pixels)\n     */\n    public int getHorizontalMargin() {\n        return convertHorizontalDLUsToPixels(IDialogConstants.HORIZONTAL_MARGIN);\n    }\n    /**\n     * This method will return the margin height (in pixels) for dialogs on this\n     * platform.\n     *\n     * @return Height of the margin around dialogs and controls\n     */\n    public int getVerticalMargin() {\n        return convertVerticalDLUsToPixels(IDialogConstants.VERTICAL_MARGIN);\n    }\n    /**\n     * This method will return the \"minimum message area width\" (in pixels) for\n     * dialogs on this platform. This number is typically better used as a\n     * default width for shells.\n     *\n     * @return Width of the minimum message area in a shell\n     */\n    public int getMinimumMessageAreaWidth() {\n        return convertHorizontalDLUsToPixels(IDialogConstants.MINIMUM_MESSAGE_AREA_WIDTH);\n    }\n    /*\n     * Used internally only - do not expose to subclasses or as public API\n     * Stores button data so that we can create a button widget when needed\n     */\n    static class ButtonDescription {\n        int buttonId;\n        String buttonLabel;\n        boolean isDefault;\n        public ButtonDescription(final int buttonId, final String buttonLabel, final boolean isDefault) {\n            this.buttonId = buttonId;\n            this.buttonLabel = buttonLabel;\n            this.isDefault = isDefault;\n        }\n    }\n    /*\n     * Used internally only. Catches the first paint event and calls\n     * hookDialogIsOpen().\n     */\n<fim_suffix>    private class FirstPaintListener implements PaintListener {\n        @Override\n        public void paintControl(final PaintEvent e) {\n            ((Composite) e.widget).removePaintListener(this);\n            hookDialogIsOpen();\n        }\n    }<fim_middle>// class below has no smell\n"}