{"text": "<fim_prefix>/*\n * Copyright 2014-present Facebook, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License. You may obtain\n * a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\n\npackage com.facebook.buck.core.model.impl;\n\nimport com.facebook.buck.core.model.BuildFileTree;\nimport com.facebook.buck.core.model.BuildTarget;\nimport com.facebook.buck.io.file.MorePaths;\nimport com.google.common.annotations.VisibleForTesting;\nimport com.google.common.collect.ComparisonChain;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.Sets;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.TreeSet;\nimport java.util.stream.StreamSupport;\nimport javax.annotation.Nullable;\n\n/**\n * A tree of build files that reflects their tree structure in the filesystem. This makes it\n * possible to see which build files are \"under\" other build files.\n */\npublic class InMemoryBuildFileTree implements BuildFileTree {\n\n  private static final Comparator<Path> PATH_COMPARATOR =\n      (a, b) ->\n          ComparisonChain.start()\n              .compare(a.getNameCount(), b.getNameCount())\n              .compare(a.toString(), b.toString())\n              .result();\n\n  private final Map<Path, Node> basePathToNodeIndex;\n\n  /**\n   * Creates an InMemoryBuildFileTree from the base paths in the given BuildTargetPaths.\n   *\n   * @param targets BuildTargetPaths to get base paths from.\n   */\n  public InMemoryBuildFileTree(Iterable<BuildTarget> targets) {\n    this(collectBasePaths(targets));\n  }\n\n  /**\n   * Returns the base paths for zero or more targets.\n   *\n   * @param targets targets to return base paths for\n   * @return base paths for targets\n   */\n<fim_suffix>  private static Collection<Path> collectBasePaths(Iterable<? extends BuildTarget> targets) {\n    return StreamSupport.stream(targets.spliterator(), false)\n        .map(BuildTarget::getBasePath)\n        .collect(ImmutableSet.toImmutableSet());\n  }\n\n  public InMemoryBuildFileTree(Collection<Path> basePaths) {\n    TreeSet<Path> sortedBasePaths = Sets.newTreeSet(PATH_COMPARATOR);\n    sortedBasePaths.addAll(basePaths);\n\n    // Initialize basePathToNodeIndex with a Node that corresponds to the empty string. This ensures\n    // that findParent() will always return a non-null Node because the empty string is a prefix of\n    // all base paths.\n    basePathToNodeIndex = new HashMap<>();\n    Node root = new Node(Paths.get(\"\"));\n    basePathToNodeIndex.put(Paths.get(\"\"), root);\n\n    // Build up basePathToNodeIndex in a breadth-first manner.\n    for (Path basePath : sortedBasePaths) {\n      if (basePath.equals(Paths.get(\"\"))) {\n        continue;\n      }\n\n      Node child = new Node(basePath);\n      Node parent = findParent(child, basePathToNodeIndex);\n      Objects.requireNonNull(parent).addChild(child);\n      basePathToNodeIndex.put(basePath, child);\n    }\n  }\n\n  @Override\n  public Optional<Path> getBasePathOfAncestorTarget(Path filePath) {\n    Node node = new Node(filePath);\n    Node parent = findParent(node, basePathToNodeIndex);\n    if (parent != null) {\n      return Optional.of(parent.basePath);\n    } else {\n      return Optional.empty();\n    }\n  }\n\n  /**\n   * @return Iterable of relative paths to the BuildTarget's directory that contain their own build\n   *     files. No element in the Iterable is a prefix of any other element in the Iterable.\n   */\n  @Override\n  public Collection<Path> getChildPaths(BuildTarget buildTarget) {\n    return getChildPaths(buildTarget.getBasePath());\n  }\n\n  @VisibleForTesting\n  Collection<Path> getChildPaths(Path path) {\n    Node node = Objects.requireNonNull(basePathToNodeIndex.get(path));\n    if (node.children == null) {\n      return ImmutableList.of();\n    } else {\n      return node.children\n          .stream()\n          .map(child -> MorePaths.relativize(path, child.basePath))\n          .collect(ImmutableList.toImmutableList());\n    }\n  }\n\n  /**\n   * Finds the parent Node of the specified child Node.\n   *\n   * @param child whose parent is sought in {@code basePathToNodeIndex}.\n   * @param basePathToNodeIndex Map that must contain a Node with a basePath that is a prefix of\n   *     {@code child}'s basePath.\n   * @return the Node in {@code basePathToNodeIndex} with the longest basePath that is a prefix of\n   *     {@code child}'s basePath.\n   */\n  @Nullable\n  private static Node findParent(Node child, Map<Path, Node> basePathToNodeIndex) {\n    Path current = child.basePath;\n    while (current != null) {\n      Node candidate = basePathToNodeIndex.get(current);\n      if (candidate != null) {\n        return candidate;\n      }\n      current = current.getParent();\n    }\n    return basePathToNodeIndex.get(Paths.get(\"\"));\n  }\n\n  /** Represents a build file in the project directory. */\n  private static class Node {\n\n    /** Result of {@link BuildTarget#getBasePath()}. */\n    private final Path basePath;\n\n    /** List of child nodes: created lazily to save memory. */\n    @Nullable private List<Node> children;\n\n    Node(Path basePath) {\n      this.basePath = basePath;\n    }\n\n    void addChild(Node node) {\n      if (children == null) {\n        children = new ArrayList<>();\n      }\n      children.add(node);\n    }\n  }\n}<fim_middle>// function below has no smell\n"}