{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.nifi.util;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport org.apache.commons.compress.archivers.tar.TarArchiveEntry;\nimport org.apache.commons.compress.archivers.tar.TarArchiveInputStream;\n\n<fim_suffix>public class FlowFileUnpackagerV1 implements FlowFileUnpackager {\n\n    private int flowFilesRead = 0;\n\n    @Override\n    public Map<String, String> unpackageFlowFile(final InputStream in, final OutputStream out) throws IOException {\n        flowFilesRead++;\n        final TarArchiveInputStream tarIn = new TarArchiveInputStream(in);\n        final TarArchiveEntry attribEntry = tarIn.getNextTarEntry();\n        if (attribEntry == null) {\n            return null;\n        }\n\n        final Map<String, String> attributes;\n        if (attribEntry.getName().equals(FlowFilePackagerV1.FILENAME_ATTRIBUTES)) {\n            attributes = getAttributes(tarIn);\n        } else {\n            throw new IOException(\"Expected two tar entries: \"\n                    + FlowFilePackagerV1.FILENAME_CONTENT + \" and \"\n                    + FlowFilePackagerV1.FILENAME_ATTRIBUTES);\n        }\n\n        final TarArchiveEntry contentEntry = tarIn.getNextTarEntry();\n\n        if (contentEntry != null && contentEntry.getName().equals(FlowFilePackagerV1.FILENAME_CONTENT)) {\n            final byte[] buffer = new byte[512 << 10];//512KB\n            int bytesRead = 0;\n            while ((bytesRead = tarIn.read(buffer)) != -1) { //still more data to read\n                if (bytesRead > 0) {\n                    out.write(buffer, 0, bytesRead);\n                }\n            }\n            out.flush();\n        } else {\n            throw new IOException(\"Expected two tar entries: \"\n                    + FlowFilePackagerV1.FILENAME_CONTENT + \" and \"\n                    + FlowFilePackagerV1.FILENAME_ATTRIBUTES);\n        }\n\n        return attributes;\n    }\n\n    protected Map<String, String> getAttributes(final TarArchiveInputStream stream) throws IOException {\n\n        final Properties props = new Properties();\n        props.loadFromXML(new NonCloseableInputStream(stream));\n\n        final Map<String, String> result = new HashMap<>();\n        for (final Entry<Object, Object> entry : props.entrySet()) {\n            final Object keyObject = entry.getKey();\n            final Object valueObject = entry.getValue();\n            if (!(keyObject instanceof String)) {\n                throw new IOException(\"Flow file attributes object contains key of type \"\n                        + keyObject.getClass().getCanonicalName()\n                        + \" but expected java.lang.String\");\n            } else if (!(keyObject instanceof String)) {\n                throw new IOException(\"Flow file attributes object contains value of type \"\n                        + keyObject.getClass().getCanonicalName()\n                        + \" but expected java.lang.String\");\n            }\n\n            final String key = (String) keyObject;\n            final String value = (String) valueObject;\n            result.put(key, value);\n        }\n\n        return result;\n    }\n\n    @Override\n    public boolean hasMoreData() throws IOException {\n        return flowFilesRead == 0;\n    }\n\n    public static final class NonCloseableInputStream extends InputStream {\n\n        final InputStream stream;\n\n        public NonCloseableInputStream(final InputStream stream) {\n            this.stream = stream;\n        }\n\n        @Override\n        public void close() {\n        }\n\n        @Override\n        public int read() throws IOException {\n            return stream.read();\n        }\n\n        @Override\n        public int available() throws IOException {\n            return stream.available();\n        }\n\n        @Override\n        public synchronized void mark(int readlimit) {\n            stream.mark(readlimit);\n        }\n\n        @Override\n        public synchronized void reset() throws IOException {\n            stream.reset();\n        }\n\n        @Override\n        public boolean markSupported() {\n            return stream.markSupported();\n        }\n\n        @Override\n        public long skip(long n) throws IOException {\n            return stream.skip(n);\n        }\n\n        @Override\n        public int read(byte b[], int off, int len) throws IOException {\n            return stream.read(b, off, len);\n        }\n\n        @Override\n        public int read(byte b[]) throws IOException {\n            return stream.read(b);\n        }\n    }\n}<fim_middle>// class below is blob\n"}