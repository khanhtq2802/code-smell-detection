{"text": "<fim_prefix>            readUnlock();\n        }\n    }\n    /**\n     * Locks the given key and its value into the map. Objects pinned into\n     * the map are not counted towards the maximum cache size, and are never\n     * evicted implicitly. You may pin keys for which no value is in the map.\n     *\n     * @return true if the givne key's value was pinned; false if no value\n     * for the given key is cached\n     */\n    public boolean pin(Object key) {\n        writeLock();\n        try {\n            // if we don't have a pinned map we need to create one; else if the\n            // pinned map already contains the key, nothing to do\n            if (pinnedMap.containsKey(key))\n                return pinnedMap.get(key) != null;\n            // check other maps for key\n            Object val = remove(cacheMap, key);\n            if (val == null)\n                val = remove(softMap, key);\n            // pin key\n            put(pinnedMap, key, val);\n            if (val != null) {\n                _pinnedSize++;\n                return true;\n            }\n            return false;\n        } finally {\n            writeUnlock();\n        }\n    }\n    /**\n     * Undo a pinning.\n     */\n    public boolean unpin(Object key) {\n        writeLock();\n        try {\n            Object val = remove(pinnedMap, key);\n            if (val != null) {\n                // put back into unpinned cache\n                put(key, val);\n                _pinnedSize--;\n                return true;\n            }\n            return false;\n        } finally {\n            writeUnlock();\n        }\n    }\n    /**\n     * Invoked when a key-value pair is evicted from this data\n     * structure. This is invoked with <code>expired</code> set to\n     * <code>true</code> when an object is dropped because of space\n     * requirements or through garbage collection of soft references.\n     * It is invoked with <code>expired</code> set to <code>false</code>\n     * when an object is explicitly removed via the {@link #remove} or\n     * {@link #clear} methods. This may be invoked more than once for a\n     * given entry.\n     *\n     * @param value may be null if the value was a soft reference that has\n     * been GCd\n     * @since 0.2.5.0\n     */\n    protected void entryRemoved(Object key, Object value, boolean expired) {\n    }\n    /**\n     * Invoked when an entry is added to the cache. This may be invoked\n     * more than once for an entry.\n     */\n    protected void entryAdded(Object key, Object value) {\n    }\n    @Override\n    public Object get(Object key) {\n        boolean putcache = false;\n        Object val = null;\n        readLock();\n        try {\n            val = softMap.get(key);\n            if (val == null) {\n                val = cacheMap.get(key);\n                if (val == null) {\n                    val = pinnedMap.get(key);\n                }\n            } else {\n                putcache = true;\n            }\n            return val;\n        } finally {\n            readUnlock();\n            //cannot obtain a write lock while holding a read lock\n            //doing it this way prevents a deadlock\n            if (putcache)\n                put(key, val);\n        }\n    }\n    @Override\n    public Object put(Object key, Object value) {\n        writeLock();\n        try {\n            // if the key is pinned, just interact directly with the pinned map\n            Object val;\n            if (pinnedMap.containsKey(key)) {\n                val = put(pinnedMap, key, value);\n                if (val == null) {\n                    _pinnedSize++;\n                    entryAdded(key, value);\n                } else {\n                    entryRemoved(key, val, false);\n                    entryAdded(key, value);\n                }\n                return val;\n            }\n            // if no hard refs, don't put anything\n            if (cacheMap.getMaxSize() == 0)\n                return null;\n            // otherwise, put the value into the map and clear it from the\n            // soft map\n            val = put(cacheMap, key, value);\n            if (val == null) {\n                val = remove(softMap, key);\n                if (val == null)\n                    entryAdded(key, value);\n                else {\n                    entryRemoved(key, val, false);\n                    entryAdded(key, value);\n                }\n            } else {\n                entryRemoved(key, val, false);\n                entryAdded(key, value);\n            }\n            return val;\n        } finally {\n            writeUnlock();\n        }\n    }\n    @Override\n    public void putAll(Map map) {\n        putAll(map, true);\n    }\n    public void putAll(Map map, boolean replaceExisting) {\n        Map.Entry entry;\n        for (Iterator itr = map.entrySet().iterator(); itr.hasNext();) {\n            entry = (Map.Entry) itr.next();\n            if(replaceExisting || !containsKey(entry.getKey())) {\n                put(entry.getKey(), entry.getValue());\n            }\n        }\n    }\n    /**\n     * If <code>key</code> is pinned into the cache, the pin is\n     * cleared and the object is removed.\n     */\n    @Override\n    public Object remove(Object key) {\n        writeLock();\n        try {\n            // if the key is pinned, just interact directly with the\n            // pinned map\n            Object val;\n            if (pinnedMap.containsKey(key)) {\n                // re-put with null value; we still want key pinned\n                val = put(pinnedMap, key, null);\n                if (val != null) {\n                    _pinnedSize--;\n                    entryRemoved(key, val, false);\n                }\n                return val;\n            }\n            val = remove(cacheMap, key);\n            if (val == null)\n                val = softMap.remove(key);\n            if (val != null)\n                entryRemoved(key, val, false);\n            return val;\n        } finally {\n            writeUnlock();\n        }\n    }\n    /**\n     * Removes pinned objects as well as unpinned ones.\n     */\n    @Override\n    public void clear() {\n        writeLock();\n        try {\n            notifyEntryRemovals(pinnedMap.entrySet());\n            pinnedMap.clear();\n            _pinnedSize = 0;\n            notifyEntryRemovals(cacheMap.entrySet());\n            cacheMap.clear();\n            notifyEntryRemovals(softMap.entrySet());\n            softMap.clear();\n        } finally {\n            writeUnlock();\n        }\n    }\n    private void notifyEntryRemovals(Set set) {\n        Map.Entry entry;\n        for (Iterator itr = set.iterator(); itr.hasNext();) {\n            entry = (Map.Entry) itr.next();\n            if (entry.getValue() != null)\n                entryRemoved(entry.getKey(), entry.getValue(), false);\n        }\n    }\n    @Override\n    public int size() {\n        readLock();\n        try {\n            return _pinnedSize + cacheMap.size() + softMap.size();\n        } finally {\n            readUnlock();\n        }\n    }\n    @Override\n    public boolean isEmpty() {\n        return size() == 0;\n    }\n    @Override\n    public boolean containsKey(Object key) {\n        readLock();\n        try {\n            return cacheMap.containsKey(key) || pinnedMap.get(key) != null || softMap.containsKey(key);\n        } finally {\n            readUnlock();\n        }\n    }\n    @Override\n    public boolean containsValue(Object val) {\n        readLock();\n        try {\n            return cacheMap.containsValue(val) || pinnedMap.containsValue(val) || softMap.containsValue(val);\n        } finally {\n            readUnlock();\n        }\n    }\n    @Override\n    public Set keySet() {\n        return new KeySet();\n    }\n    @Override\n    public Collection values() {\n        return new ValueCollection();\n    }\n    @Override\n    public Set entrySet() {\n        return new EntrySet();\n    }\n    @Override\n    public String toString() {\n        readLock();\n        try {\n            return \"CacheMap:\" + cacheMap.toString() + \"::\" + softMap.toString();\n        } finally {\n            readUnlock();\n        }\n    }\n    /**\n     * View of the entry set.\n     */\n    private class EntrySet\n        extends AbstractSet {\n        @Override\n        public int size() {\n            return CacheMap.this.size();\n        }\n        @Override\n        public boolean add(Object o) {\n            Map.Entry entry = (Map.Entry) o;\n            put(entry.getKey(), entry.getValue());\n            return true;\n        }\n        @Override\n        public Iterator iterator() {\n            return new EntryIterator(EntryIterator.ENTRY);\n        }\n    }\n    /**\n     * View of the key set.\n     */\n    private class KeySet\n        extends AbstractSet {\n        @Override\n        public int size() {\n            return CacheMap.this.size();\n        }\n        @Override\n        public Iterator iterator() {\n            return new EntryIterator(EntryIterator.KEY);\n        }\n    }\n    /**\n     * View of the value collection.\n     */\n<fim_suffix>    private class ValueCollection\n        extends AbstractCollection {\n        @Override\n        public int size() {\n            return CacheMap.this.size();\n        }\n        @Override\n        public Iterator iterator() {\n            return new EntryIterator(EntryIterator.VALUE);\n        }\n    }<fim_middle>// class below has no smell\n"}