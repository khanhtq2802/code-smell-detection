{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.ignite.internal.processors.hadoop.shuffle;\nimport java.io.IOException;\nimport java.io.ObjectInput;\nimport java.io.ObjectOutput;\nimport java.nio.ByteBuffer;\nimport java.util.concurrent.atomic.AtomicLong;\nimport org.apache.ignite.IgniteCheckedException;\nimport org.apache.ignite.internal.IgniteCodeGeneratingFail;\nimport org.apache.ignite.internal.processors.hadoop.HadoopJobId;\nimport org.apache.ignite.internal.processors.hadoop.message.HadoopMessage;\nimport org.apache.ignite.internal.util.GridUnsafe;\nimport org.apache.ignite.internal.util.tostring.GridToStringInclude;\nimport org.apache.ignite.internal.util.typedef.internal.S;\nimport org.apache.ignite.internal.util.typedef.internal.U;\nimport org.apache.ignite.plugin.extensions.communication.Message;\nimport org.apache.ignite.plugin.extensions.communication.MessageReader;\nimport org.apache.ignite.plugin.extensions.communication.MessageWriter;\n/**\n * Shuffle message.\n */\n@IgniteCodeGeneratingFail\npublic class HadoopShuffleMessage implements Message, HadoopMessage {\n    /** */\n    private static final long serialVersionUID = 0L;\n    /** */\n    private static final AtomicLong ids = new AtomicLong();\n    /** */\n    private static final byte MARKER_KEY = (byte)17;\n    /** */\n    private static final byte MARKER_VALUE = (byte)31;\n    /** */\n    @GridToStringInclude\n    private long msgId;\n    /** */\n    @GridToStringInclude\n    private HadoopJobId jobId;\n    /** */\n    @GridToStringInclude\n    private int reducer;\n    /** */\n    private byte[] buf;\n    /** */\n    @GridToStringInclude\n    private int off;\n    /**\n     *\n     */\n    public HadoopShuffleMessage() {\n        // No-op.\n    }\n    /**\n     * @param size Size.\n     */\n    public HadoopShuffleMessage(HadoopJobId jobId, int reducer, int size) {\n        assert jobId != null;\n        buf = new byte[size];\n        this.jobId = jobId;\n        this.reducer = reducer;\n        msgId = ids.incrementAndGet();\n    }\n    /**\n     * @return Message ID.\n     */\n    public long id() {\n        return msgId;\n    }\n    /**\n     * @return Job ID.\n     */\n    public HadoopJobId jobId() {\n        return jobId;\n    }\n    /**\n     * @return Reducer.\n     */\n    public int reducer() {\n        return reducer;\n    }\n    /**\n     * @return Buffer.\n     */\n    public byte[] buffer() {\n        return buf;\n    }\n    /**\n     * @return Offset.\n     */\n    public int offset() {\n        return off;\n    }\n    /**\n     * @param size Size.\n     * @param valOnly Only value wll be added.\n     * @return {@code true} If this message can fit additional data of this size\n     */\n    public boolean available(int size, boolean valOnly) {\n        size += valOnly ? 5 : 10;\n        if (off + size > buf.length) {\n            if (off == 0) { // Resize if requested size is too big.\n                buf = new byte[size];\n                return true;\n            }\n            return false;\n        }\n        return true;\n    }\n    /**\n     * @param keyPtr Key pointer.\n     * @param keySize Key size.\n     */\n    public void addKey(long keyPtr, int keySize) {\n        add(MARKER_KEY, keyPtr, keySize);\n    }\n    /**\n     * @param valPtr Value pointer.\n     * @param valSize Value size.\n     */\n    public void addValue(long valPtr, int valSize) {\n        add(MARKER_VALUE, valPtr, valSize);\n    }\n    /**\n     * @param marker Marker.\n     * @param ptr Pointer.\n     * @param size Size.\n     */\n    private void add(byte marker, long ptr, int size) {\n        buf[off++] = marker;\n        GridUnsafe.putInt(buf, GridUnsafe.BYTE_ARR_OFF + off, size);\n        off += 4;\n        GridUnsafe.copyOffheapHeap(ptr, buf, GridUnsafe.BYTE_ARR_OFF + off, size);\n        off += size;\n    }\n    /**\n     * @param v Visitor.\n     */\n    public void visit(Visitor v) throws IgniteCheckedException {\n        for (int i = 0; i < off;) {\n            byte marker = buf[i++];\n            int size = GridUnsafe.getInt(buf, GridUnsafe.BYTE_ARR_OFF + i);\n            i += 4;\n            if (marker == MARKER_VALUE)\n                v.onValue(buf, i, size);\n            else if (marker == MARKER_KEY)\n                v.onKey(buf, i, size);\n            else\n                throw new IllegalStateException();\n            i += size;\n        }\n    }\n    /** {@inheritDoc} */\n    @Override public boolean writeTo(ByteBuffer buf, MessageWriter writer) {\n        writer.setBuffer(buf);\n        if (!writer.isHeaderWritten()) {\n            if (!writer.writeHeader(directType(), fieldsCount()))\n                return false;\n            writer.onHeaderWritten();\n        }\n        switch (writer.state()) {\n            case 0:\n                if (!writer.writeByteArray(\"buf\", this.buf))\n                    return false;\n                writer.incrementState();\n            case 1:\n                if (!writer.writeMessage(\"jobId\", jobId))\n                    return false;\n                writer.incrementState();\n            case 2:\n                if (!writer.writeLong(\"msgId\", msgId))\n                    return false;\n                writer.incrementState();\n            case 3:\n                if (!writer.writeInt(\"off\", off))\n                    return false;\n                writer.incrementState();\n            case 4:\n                if (!writer.writeInt(\"reducer\", reducer))\n                    return false;\n                writer.incrementState();\n        }\n        return true;\n    }\n    /** {@inheritDoc} */\n    @Override public boolean readFrom(ByteBuffer buf, MessageReader reader) {\n        reader.setBuffer(buf);\n        if (!reader.beforeMessageRead())\n            return false;\n        switch (reader.state()) {\n            case 0:\n                this.buf = reader.readByteArray(\"buf\");\n                if (!reader.isLastRead())\n                    return false;\n                reader.incrementState();\n            case 1:\n                jobId = reader.readMessage(\"jobId\");\n                if (!reader.isLastRead())\n                    return false;\n                reader.incrementState();\n            case 2:\n                msgId = reader.readLong(\"msgId\");\n                if (!reader.isLastRead())\n                    return false;\n                reader.incrementState();\n            case 3:\n                off = reader.readInt(\"off\");\n                if (!reader.isLastRead())\n                    return false;\n                reader.incrementState();\n            case 4:\n                reducer = reader.readInt(\"reducer\");\n                if (!reader.isLastRead())\n                    return false;\n                reader.incrementState();\n        }\n        return reader.afterMessageRead(HadoopShuffleMessage.class);\n    }\n    /** {@inheritDoc} */\n    @Override public short directType() {\n        return -37;\n    }\n    /** {@inheritDoc} */\n    @Override public byte fieldsCount() {\n        return 5;\n    }\n    /** {@inheritDoc} */\n    @Override public void onAckReceived() {\n        // No-op.\n    }\n    /** {@inheritDoc} */\n<fim_suffix>    @Override public void writeExternal(ObjectOutput out) throws IOException {\n        jobId.writeExternal(out);\n        out.writeLong(msgId);\n        out.writeInt(reducer);\n        out.writeInt(off);\n        U.writeByteArray(out, buf);\n    }\n    /** {@inheritDoc} */\n    @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n        jobId = new HadoopJobId();\n        jobId.readExternal(in);\n        msgId = in.readLong();\n        reducer = in.readInt();\n        off = in.readInt();\n        buf = U.readByteArray(in);\n    }\n    /** {@inheritDoc} */\n    @Override public String toString() {\n        return S.toString(HadoopShuffleMessage.class, this);\n    }\n    /**\n     * Visitor.\n     */\n    public static interface Visitor {\n        /**\n         * @param buf Buffer.\n         * @param off Offset.\n         * @param len Length.\n         */<fim_middle>// function below has no smell\n"}