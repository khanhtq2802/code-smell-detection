{"text": "<fim_prefix>    /**\n     * Writes the &quot;ZIP64 End of central dir record&quot; and\n     * &quot;ZIP64 End of central dir locator&quot;.\n     * @throws IOException on error\n     * @since 1.3\n     */\n    protected void writeZip64CentralDirectory() throws IOException {\n        if (zip64Mode == Zip64Mode.Never) {\n            return;\n        }\n        if (!hasUsedZip64\n            && (cdOffset >= ZIP64_MAGIC || cdLength >= ZIP64_MAGIC\n                || entries.size() >= ZIP64_MAGIC_SHORT)) {\n            // actually \"will use\"\n            hasUsedZip64 = true;\n        }\n        if (!hasUsedZip64) {\n            return;\n        }\n        final long offset = streamCompressor.getTotalBytesWritten();\n        writeOut(ZIP64_EOCD_SIG);\n        // size, we don't have any variable length as we don't support\n        // the extensible data sector, yet\n        writeOut(ZipEightByteInteger\n                 .getBytes(SHORT   /* version made by */\n                           + SHORT /* version needed to extract */\n                           + WORD  /* disk number */\n                           + WORD  /* disk with central directory */\n                           + DWORD /* number of entries in CD on this disk */\n                           + DWORD /* total number of entries */\n                           + DWORD /* size of CD */\n                           + (long) DWORD /* offset of CD */\n                           ));\n        // version made by and version needed to extract\n        writeOut(ZipShort.getBytes(ZIP64_MIN_VERSION));\n        writeOut(ZipShort.getBytes(ZIP64_MIN_VERSION));\n        // disk numbers - four bytes this time\n        writeOut(LZERO);\n        writeOut(LZERO);\n        // number of entries\n        final byte[] num = ZipEightByteInteger.getBytes(entries.size());\n        writeOut(num);\n        writeOut(num);\n        // length and location of CD\n        writeOut(ZipEightByteInteger.getBytes(cdLength));\n        writeOut(ZipEightByteInteger.getBytes(cdOffset));\n        // no \"zip64 extensible data sector\" for now\n        // and now the \"ZIP64 end of central directory locator\"\n        writeOut(ZIP64_EOCD_LOC_SIG);\n        // disk number holding the ZIP64 EOCD record\n        writeOut(LZERO);\n        // relative offset of ZIP64 EOCD record\n        writeOut(ZipEightByteInteger.getBytes(offset));\n        // total number of disks\n        writeOut(ONE);\n    }\n    /**\n     * Write bytes to output or random access file.\n     * @param data the byte array to write\n     * @throws IOException on error\n     */\n    protected final void writeOut(final byte[] data) throws IOException {\n        streamCompressor.writeOut(data, 0, data.length);\n    }\n    /**\n     * Write bytes to output or random access file.\n     * @param data the byte array to write\n     * @param offset the start position to write from\n     * @param length the number of bytes to write\n     * @throws IOException on error\n     */\n    protected final void writeOut(final byte[] data, final int offset, final int length)\n            throws IOException {\n        streamCompressor.writeOut(data, offset, length);\n    }\n    private GeneralPurposeBit getGeneralPurposeBits(final boolean utfFallback, boolean usesDataDescriptor) {\n        final GeneralPurposeBit b = new GeneralPurposeBit();\n        b.useUTF8ForNames(useUTF8Flag || utfFallback);\n        if (usesDataDescriptor) {\n            b.useDataDescriptor(true);\n        }\n        return b;\n    }\n    private int versionNeededToExtract(final int zipMethod, final boolean zip64, final boolean usedDataDescriptor) {\n        if (zip64) {\n            return ZIP64_MIN_VERSION;\n        }\n        if (usedDataDescriptor) {\n            return DATA_DESCRIPTOR_MIN_VERSION;\n        }\n        return versionNeededToExtractMethod(zipMethod);\n    }\n    private boolean usesDataDescriptor(final int zipMethod, boolean phased) {\n        return !phased && zipMethod == DEFLATED && channel == null;\n    }\n    private int versionNeededToExtractMethod(int zipMethod) {\n        return zipMethod == DEFLATED ? DEFLATE_MIN_VERSION : INITIAL_VERSION;\n    }\n    /**\n     * Creates a new zip entry taking some information from the given\n     * file and using the provided name.\n     *\n     * <p>The name will be adjusted to end with a forward slash \"/\" if\n     * the file is a directory.  If the file is not a directory a\n     * potential trailing forward slash will be stripped from the\n     * entry name.</p>\n     *\n     * <p>Must not be used if the stream has already been closed.</p>\n     */\n    @Override\n    public ArchiveEntry createArchiveEntry(final File inputFile, final String entryName)\n        throws IOException {\n        if (finished) {\n            throw new IOException(\"Stream has already been finished\");\n        }\n        return new ZipArchiveEntry(inputFile, entryName);\n    }\n    /**\n     * Get the existing ZIP64 extended information extra field or\n     * create a new one and add it to the entry.\n     *\n     * @since 1.3\n     */\n    private Zip64ExtendedInformationExtraField\n        getZip64Extra(final ZipArchiveEntry ze) {\n        if (entry != null) {\n            entry.causedUseOfZip64 = !hasUsedZip64;\n        }\n        hasUsedZip64 = true;\n        Zip64ExtendedInformationExtraField z64 =\n            (Zip64ExtendedInformationExtraField)\n            ze.getExtraField(Zip64ExtendedInformationExtraField\n                             .HEADER_ID);\n        if (z64 == null) {\n            /*\n              System.err.println(\"Adding z64 for \" + ze.getName()\n              + \", method: \" + ze.getMethod()\n              + \" (\" + (ze.getMethod() == STORED) + \")\"\n              + \", channel: \" + (channel != null));\n            */\n            z64 = new Zip64ExtendedInformationExtraField();\n        }\n        // even if the field is there already, make sure it is the first one\n        ze.addAsFirstExtraField(z64);\n        return z64;\n    }\n    /**\n     * Is there a ZIP64 extended information extra field for the\n     * entry?\n     *\n     * @since 1.3\n     */\n    private boolean hasZip64Extra(final ZipArchiveEntry ze) {\n        return ze.getExtraField(Zip64ExtendedInformationExtraField\n                                .HEADER_ID)\n            != null;\n    }\n    /**\n     * If the mode is AsNeeded and the entry is a compressed entry of\n     * unknown size that gets written to a non-seekable stream then\n     * change the default to Never.\n     *\n     * @since 1.3\n     */\n    private Zip64Mode getEffectiveZip64Mode(final ZipArchiveEntry ze) {\n        if (zip64Mode != Zip64Mode.AsNeeded\n            || channel != null\n            || ze.getMethod() != DEFLATED\n            || ze.getSize() != ArchiveEntry.SIZE_UNKNOWN) {\n            return zip64Mode;\n        }\n        return Zip64Mode.Never;\n    }\n    private ZipEncoding getEntryEncoding(final ZipArchiveEntry ze) {\n        final boolean encodable = zipEncoding.canEncode(ze.getName());\n        return !encodable && fallbackToUTF8\n            ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n    }\n    private ByteBuffer getName(final ZipArchiveEntry ze) throws IOException {\n        return getEntryEncoding(ze).encode(ze.getName());\n    }\n    /**\n     * Closes the underlying stream/file without finishing the\n     * archive, the result will likely be a corrupt archive.\n     *\n     * <p>This method only exists to support tests that generate\n     * corrupt archives so they can clean up any temporary files.</p>\n     */\n    void destroy() throws IOException {\n        try {\n            if (channel != null) {\n                channel.close();\n            }\n        } finally {\n            if (out != null) {\n                out.close();\n            }\n        }\n    }\n    /**\n     * enum that represents the possible policies for creating Unicode\n     * extra fields.\n     */\n<fim_suffix>    public static final class UnicodeExtraFieldPolicy {\n        /**\n         * Always create Unicode extra fields.\n         */\n        public static final UnicodeExtraFieldPolicy ALWAYS = new UnicodeExtraFieldPolicy(\"always\");\n        /**\n         * Never create Unicode extra fields.\n         */\n        public static final UnicodeExtraFieldPolicy NEVER = new UnicodeExtraFieldPolicy(\"never\");\n        /**\n         * Create Unicode extra fields for filenames that cannot be\n         * encoded using the specified encoding.\n         */\n        public static final UnicodeExtraFieldPolicy NOT_ENCODEABLE =\n            new UnicodeExtraFieldPolicy(\"not encodeable\");\n        private final String name;\n        private UnicodeExtraFieldPolicy(final String n) {\n            name = n;\n        }\n        @Override\n        public String toString() {\n            return name;\n        }\n    }<fim_middle>// class below has no smell\n"}