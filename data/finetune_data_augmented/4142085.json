{"text": "<fim_prefix>      writer.endList(offsetFrame);\n    }\n  }\n  /**\n   * Returns whether the dialect supports nested aggregations, for instance\n   * {@code SELECT SUM(SUM(1)) }.\n   */\n  public boolean supportsNestedAggregations() {\n    return true;\n  }\n  /** Returns how NULL values are sorted if an ORDER BY item does not contain\n   * NULLS ASCENDING or NULLS DESCENDING. */\n  public NullCollation getNullCollation() {\n    return nullCollation;\n  }\n  /** Returns whether NULL values are sorted first or last, in this dialect,\n   * in an ORDER BY item of a given direction. */\n  public RelFieldCollation.NullDirection defaultNullDirection(\n      RelFieldCollation.Direction direction) {\n    switch (direction) {\n    case ASCENDING:\n    case STRICTLY_ASCENDING:\n      return getNullCollation().last(false)\n          ? RelFieldCollation.NullDirection.LAST\n          : RelFieldCollation.NullDirection.FIRST;\n    case DESCENDING:\n    case STRICTLY_DESCENDING:\n      return getNullCollation().last(true)\n          ? RelFieldCollation.NullDirection.LAST\n          : RelFieldCollation.NullDirection.FIRST;\n    default:\n      return RelFieldCollation.NullDirection.UNSPECIFIED;\n    }\n  }\n  /**\n   * Returns whether the dialect supports VALUES in a sub-query with\n   * and an \"AS t(column, ...)\" values to define column names.\n   *\n   * <p>Currently, only Oracle does not. For this, we generate \"SELECT v0 AS c0,\n   * v1 AS c1 ... UNION ALL ...\". We may need to refactor this method when we\n   * support VALUES for other dialects. */\n  @Experimental\n  public boolean supportsAliasedValues() {\n    return true;\n  }\n  /**\n   * A few utility functions copied from org.apache.calcite.util.Util. We have\n   * copied them because we wish to keep SqlDialect's dependencies to a\n   * minimum.\n   */\n  public static class FakeUtil {\n    public static Error newInternal(Throwable e, String s) {\n      String message = \"Internal error: \\u0000\" + s;\n      AssertionError ae = new AssertionError(message);\n      ae.initCause(e);\n      return ae;\n    }\n    /**\n     * Replaces every occurrence of <code>find</code> in <code>s</code> with\n     * <code>replace</code>.\n     */\n    public static String replace(\n        String s,\n        String find,\n        String replace) {\n      // let's be optimistic\n      int found = s.indexOf(find);\n      if (found == -1) {\n        return s;\n      }\n      StringBuilder sb = new StringBuilder(s.length());\n      int start = 0;\n      for (;;) {\n        for (; start < found; start++) {\n          sb.append(s.charAt(start));\n        }\n        if (found == s.length()) {\n          break;\n        }\n        sb.append(replace);\n        start += find.length();\n        found = s.indexOf(find, start);\n        if (found == -1) {\n          found = s.length();\n        }\n      }\n      return sb.toString();\n    }\n  }\n  /** Whether this JDBC driver needs you to pass a Calendar object to methods\n   * such as {@link ResultSet#getTimestamp(int, java.util.Calendar)}. */\n  public enum CalendarPolicy {\n    NONE,\n    NULL,\n    LOCAL,\n    DIRECT,\n    SHIFT;\n  }\n  /**\n   * Rough list of flavors of database.\n   *\n   * <p>These values cannot help you distinguish between features that exist\n   * in different versions or ports of a database, but they are sufficient\n   * to drive a {@code switch} statement if behavior is broadly different\n   * between say, MySQL and Oracle.\n   *\n   * <p>If possible, you should not refer to particular database at all; write\n   * extend the dialect to describe the particular capability, for example,\n   * whether the database allows expressions to appear in the GROUP BY clause.\n   */\n  public enum DatabaseProduct {\n    ACCESS(\"Access\", \"\\\"\", NullCollation.HIGH),\n    BIG_QUERY(\"Google BigQuery\", \"`\", NullCollation.LOW),\n    CALCITE(\"Apache Calcite\", \"\\\"\", NullCollation.HIGH),\n    MSSQL(\"Microsoft SQL Server\", \"[\", NullCollation.HIGH),\n    MYSQL(\"MySQL\", \"`\", NullCollation.LOW),\n    ORACLE(\"Oracle\", \"\\\"\", NullCollation.HIGH),\n    DERBY(\"Apache Derby\", null, NullCollation.HIGH),\n    DB2(\"IBM DB2\", null, NullCollation.HIGH),\n    FIREBIRD(\"Firebird\", null, NullCollation.HIGH),\n    H2(\"H2\", \"\\\"\", NullCollation.HIGH),\n    HIVE(\"Apache Hive\", null, NullCollation.LOW),\n    INFORMIX(\"Informix\", null, NullCollation.HIGH),\n    INGRES(\"Ingres\", null, NullCollation.HIGH),\n    JETHRO(\"JethroData\", \"\\\"\", NullCollation.LOW),\n    LUCIDDB(\"LucidDB\", \"\\\"\", NullCollation.HIGH),\n    INTERBASE(\"Interbase\", null, NullCollation.HIGH),\n    PHOENIX(\"Phoenix\", \"\\\"\", NullCollation.HIGH),\n    POSTGRESQL(\"PostgreSQL\", \"\\\"\", NullCollation.HIGH),\n    NETEZZA(\"Netezza\", \"\\\"\", NullCollation.HIGH),\n    INFOBRIGHT(\"Infobright\", \"`\", NullCollation.HIGH),\n    NEOVIEW(\"Neoview\", null, NullCollation.HIGH),\n    SYBASE(\"Sybase\", null, NullCollation.HIGH),\n    TERADATA(\"Teradata\", \"\\\"\", NullCollation.HIGH),\n    HSQLDB(\"Hsqldb\", null, NullCollation.HIGH),\n    VERTICA(\"Vertica\", \"\\\"\", NullCollation.HIGH),\n    SQLSTREAM(\"SQLstream\", \"\\\"\", NullCollation.HIGH),\n    SPARK(\"Spark\", null, NullCollation.LOW),\n    /** Paraccel, now called Actian Matrix. Redshift is based on this, so\n     * presumably the dialect capabilities are similar. */\n    PARACCEL(\"Paraccel\", \"\\\"\", NullCollation.HIGH),\n    REDSHIFT(\"Redshift\", \"\\\"\", NullCollation.HIGH),\n    /**\n     * Placeholder for the unknown database.\n     *\n     * <p>Its dialect is useful for generating generic SQL. If you need to\n     * do something database-specific like quoting identifiers, don't rely\n     * on this dialect to do what you want.\n     */\n    UNKNOWN(\"Unknown\", \"`\", NullCollation.HIGH);\n    private final Supplier<SqlDialect> dialect;\n    DatabaseProduct(String databaseProductName, String quoteString,\n        NullCollation nullCollation) {\n      Objects.requireNonNull(databaseProductName);\n      Objects.requireNonNull(nullCollation);\n      dialect = Suppliers.memoize(() -> {\n        final SqlDialect dialect =\n            SqlDialectFactoryImpl.simple(DatabaseProduct.this);\n        if (dialect != null) {\n          return dialect;\n        }\n        return new SqlDialect(SqlDialect.EMPTY_CONTEXT\n            .withDatabaseProduct(DatabaseProduct.this)\n            .withDatabaseProductName(databaseProductName)\n            .withIdentifierQuoteString(quoteString)\n            .withNullCollation(nullCollation));\n      })::get;\n    }\n    /**\n     * Returns a dummy dialect for this database.\n     *\n     * <p>Since databases have many versions and flavors, this dummy dialect\n     * is at best an approximation. If you want exact information, better to\n     * use a dialect created from an actual connection's metadata\n     * (see {@link SqlDialectFactory#create(java.sql.DatabaseMetaData)}).\n     *\n     * @return Dialect representing lowest-common-denominator behavior for\n     * all versions of this database\n     */\n    public SqlDialect getDialect() {\n      return dialect.get();\n    }\n  }\n  /** Information for creating a dialect.\n   *\n   * <p>It is immutable; to \"set\" a property, call one of the \"with\" methods,\n   * which returns a new context with the desired property value. */\n<fim_suffix>  public interface Context {\n    @Nonnull DatabaseProduct databaseProduct();\n    Context withDatabaseProduct(@Nonnull DatabaseProduct databaseProduct);\n    String databaseProductName();\n    Context withDatabaseProductName(String databaseProductName);\n    String databaseVersion();\n    Context withDatabaseVersion(String databaseVersion);\n    int databaseMajorVersion();\n    Context withDatabaseMajorVersion(int databaseMajorVersion);\n    int databaseMinorVersion();\n    Context withDatabaseMinorVersion(int databaseMinorVersion);\n    String identifierQuoteString();\n    Context withIdentifierQuoteString(String identifierQuoteString);\n    @Nonnull NullCollation nullCollation();\n    Context withNullCollation(@Nonnull NullCollation nullCollation);\n    @Nonnull RelDataTypeSystem dataTypeSystem();\n    Context withDataTypeSystem(@Nonnull RelDataTypeSystem dataTypeSystem);\n    JethroDataSqlDialect.JethroInfo jethroInfo();\n    Context withJethroInfo(JethroDataSqlDialect.JethroInfo jethroInfo);\n  }<fim_middle>// class below has no smell\n"}