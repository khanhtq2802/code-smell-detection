{"text": "<fim_prefix>\n<fim_suffix>public class MetadataProvider {\n  private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(MetadataProvider.class);\n  private static final String IN_FUNCTION = \"in\";\n  private static final String LIKE_FUNCTION = \"like\";\n  private static final String AND_FUNCTION = \"booleanand\";\n  private static final String OR_FUNCTION = \"booleanor\";\n  /**\n   * @return Runnable that fetches the catalog metadata for given {@link GetCatalogsReq} and sends response at the end.\n   */\n  public static Runnable catalogs(final UserSession session, final DrillbitContext dContext,\n      final GetCatalogsReq req, final ResponseSender responseSender) {\n    return new CatalogsProvider(session, dContext, req, responseSender);\n  }\n  /**\n   * @return Runnable that fetches the schema metadata for given {@link GetSchemasReq} and sends response at the end.\n   */\n  public static Runnable schemas(final UserSession session, final DrillbitContext dContext,\n      final GetSchemasReq req, final ResponseSender responseSender) {\n    return new SchemasProvider(session, dContext, req, responseSender);\n  }\n  /**\n   * @return Runnable that fetches the table metadata for given {@link GetTablesReq} and sends response at the end.\n   */\n  public static Runnable tables(final UserSession session, final DrillbitContext dContext,\n      final GetTablesReq req, final ResponseSender responseSender) {\n    return new TablesProvider(session, dContext, req, responseSender);\n  }\n  /**\n   * @return Runnable that fetches the column metadata for given {@link GetColumnsReq} and sends response at the end.\n   */\n  public static Runnable columns(final UserSession session, final DrillbitContext dContext,\n      final GetColumnsReq req, final ResponseSender responseSender) {\n    return new ColumnsProvider(session, dContext, req, responseSender);\n  }\n  /**\n   * Super class for all metadata provider runnable classes.\n   */\n  private abstract static class MetadataRunnable implements Runnable {\n    protected final UserSession session;\n    private final ResponseSender responseSender;\n    private final DrillbitContext dContext;\n    private MetadataRunnable(final UserSession session, final DrillbitContext dContext,\n        final ResponseSender responseSender) {\n      this.session = Preconditions.checkNotNull(session);\n      this.dContext = Preconditions.checkNotNull(dContext);\n      this.responseSender = Preconditions.checkNotNull(responseSender);\n    }\n    @Override\n    public void run() {\n      try(SchemaTreeProvider schemaTreeProvider = new SchemaTreeProvider(dContext)) {\n        responseSender.send(runInternal(session, schemaTreeProvider));\n      } catch (final Throwable error) {\n        logger.error(\"Unhandled metadata provider error\", error);\n      }\n    }\n    /**\n     * @return A {@link Response} message. Response must be returned in any case.\n     */\n    protected abstract Response runInternal(UserSession session, SchemaTreeProvider schemaProvider);\n    public DrillConfig getConfig() {\n      return dContext.getConfig();\n    }\n  }\n  /**\n   * Runnable that fetches the catalog metadata for given {@link GetCatalogsReq} and sends response at the end.\n   */\n  private static class CatalogsProvider extends MetadataRunnable {\n    private static final Ordering<CatalogMetadata> CATALOGS_ORDERING = new Ordering<CatalogMetadata>() {\n      @Override\n      public int compare(CatalogMetadata left, CatalogMetadata right) {\n        return Ordering.natural().compare(left.getCatalogName(), right.getCatalogName());\n      }\n    };\n    private final GetCatalogsReq req;\n    public CatalogsProvider(final UserSession session, final DrillbitContext dContext,\n        final GetCatalogsReq req, final ResponseSender responseSender) {\n      super(session, dContext, responseSender);\n      this.req = Preconditions.checkNotNull(req);\n    }\n    @Override\n    protected Response runInternal(final UserSession session, final SchemaTreeProvider schemaProvider) {\n      final GetCatalogsResp.Builder respBuilder = GetCatalogsResp.newBuilder();\n      final InfoSchemaFilter filter = createInfoSchemaFilter(\n          req.hasCatalogNameFilter() ? req.getCatalogNameFilter() : null, null, null, null, null);\n      try {\n        final PojoRecordReader<Catalog> records =\n            getPojoRecordReader(CATALOGS, filter, getConfig(), schemaProvider, session);\n        List<CatalogMetadata> metadata = new ArrayList<>();\n        for(Catalog c : records) {\n          final CatalogMetadata.Builder catBuilder = CatalogMetadata.newBuilder();\n          catBuilder.setCatalogName(c.CATALOG_NAME);\n          catBuilder.setDescription(c.CATALOG_DESCRIPTION);\n          catBuilder.setConnect(c.CATALOG_CONNECT);\n          metadata.add(catBuilder.build());\n        }\n        // Reorder results according to JDBC spec\n        Collections.sort(metadata, CATALOGS_ORDERING);\n        respBuilder.addAllCatalogs(metadata);\n        respBuilder.setStatus(RequestStatus.OK);\n      } catch (Throwable e) {\n        respBuilder.setStatus(RequestStatus.FAILED);\n        respBuilder.setError(createPBError(\"get catalogs\", e));\n      } finally {\n        return new Response(RpcType.CATALOGS, respBuilder.build());\n      }\n    }\n  }\n  private static class SchemasProvider extends MetadataRunnable {\n    private static final Ordering<SchemaMetadata> SCHEMAS_ORDERING = new Ordering<SchemaMetadata>() {\n      @Override\n      public int compare(SchemaMetadata left, SchemaMetadata right) {\n        return ComparisonChain.start()\n            .compare(left.getCatalogName(), right.getCatalogName())\n            .compare(left.getSchemaName(), right.getSchemaName())\n            .result();\n      };\n    };\n    private final GetSchemasReq req;\n    private SchemasProvider(final UserSession session, final DrillbitContext dContext,\n        final GetSchemasReq req, final ResponseSender responseSender) {\n      super(session, dContext, responseSender);\n      this.req = Preconditions.checkNotNull(req);\n    }\n    @Override\n    protected Response runInternal(final UserSession session, final SchemaTreeProvider schemaProvider) {\n      final GetSchemasResp.Builder respBuilder = GetSchemasResp.newBuilder();\n      final InfoSchemaFilter filter = createInfoSchemaFilter(\n          req.hasCatalogNameFilter() ? req.getCatalogNameFilter() : null,\n          req.hasSchemaNameFilter() ? req.getSchemaNameFilter() : null,\n          null, null, null);\n      try {\n        final PojoRecordReader<Schema> records =\n            getPojoRecordReader(SCHEMATA, filter, getConfig(), schemaProvider, session);\n        List<SchemaMetadata> metadata = new ArrayList<>();\n        for(Schema s : records) {\n          final SchemaMetadata.Builder schemaBuilder = SchemaMetadata.newBuilder();\n          schemaBuilder.setCatalogName(s.CATALOG_NAME);\n          schemaBuilder.setSchemaName(s.SCHEMA_NAME);\n          schemaBuilder.setOwner(s.SCHEMA_OWNER);\n          schemaBuilder.setType(s.TYPE);\n          schemaBuilder.setMutable(s.IS_MUTABLE);\n          metadata.add(schemaBuilder.build());\n        }\n        // Reorder results according to JDBC spec\n        Collections.sort(metadata, SCHEMAS_ORDERING);\n        respBuilder.addAllSchemas(metadata);\n        respBuilder.setStatus(RequestStatus.OK);\n      } catch (Throwable e) {\n        respBuilder.setStatus(RequestStatus.FAILED);\n        respBuilder.setError(createPBError(\"get schemas\", e));\n      } finally {\n        return new Response(RpcType.SCHEMAS, respBuilder.build());\n      }\n    }\n  }\n  private static class TablesProvider extends MetadataRunnable {\n    private static final Ordering<TableMetadata> TABLES_ORDERING = new Ordering<TableMetadata>() {\n      @Override\n      public int compare(TableMetadata left, TableMetadata right) {\n        return ComparisonChain.start()\n            .compare(left.getType(), right.getType())\n            .compare(left.getCatalogName(), right.getCatalogName())\n            .compare(left.getSchemaName(), right.getSchemaName())\n            .compare(left.getTableName(), right.getTableName())\n            .result();\n      }\n    };\n    private final GetTablesReq req;\n    private TablesProvider(final UserSession session, final DrillbitContext dContext,\n        final GetTablesReq req, final ResponseSender responseSender) {\n      super(session, dContext, responseSender);\n      this.req = Preconditions.checkNotNull(req);\n    }\n    @Override\n    protected Response runInternal(final UserSession session, final SchemaTreeProvider schemaProvider) {\n      final GetTablesResp.Builder respBuilder = GetTablesResp.newBuilder();\n      final InfoSchemaFilter filter = createInfoSchemaFilter(\n          req.hasCatalogNameFilter() ? req.getCatalogNameFilter() : null,\n          req.hasSchemaNameFilter() ? req.getSchemaNameFilter() : null,\n          req.hasTableNameFilter() ? req.getTableNameFilter() : null,\n          req.getTableTypeFilterCount() != 0 ? req.getTableTypeFilterList() : null,\n          null);<fim_middle>// class below is blob\n"}