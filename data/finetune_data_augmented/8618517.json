{"text": "<fim_prefix> * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.ignite.internal.processors.cache.transactions;\nimport java.nio.ByteBuffer;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\nimport org.apache.ignite.IgniteCheckedException;\nimport org.apache.ignite.internal.GridDirectTransient;\nimport org.apache.ignite.internal.processors.cache.GridCacheMessage;\nimport org.apache.ignite.internal.processors.cache.GridCacheSharedContext;\nimport org.apache.ignite.internal.util.tostring.GridToStringExclude;\nimport org.apache.ignite.internal.util.tostring.GridToStringInclude;\nimport org.apache.ignite.internal.util.typedef.internal.S;\nimport org.apache.ignite.internal.util.typedef.internal.U;\nimport org.apache.ignite.plugin.extensions.communication.MessageCollectionItemType;\nimport org.apache.ignite.plugin.extensions.communication.MessageReader;\nimport org.apache.ignite.plugin.extensions.communication.MessageWriter;\n/**\n * Transactions lock list response.\n */\npublic class TxLocksResponse extends GridCacheMessage {\n    /** Serial version UID. */\n    private static final long serialVersionUID = 0L;\n    /** Future ID. */\n    private long futId;\n    /** Locks for near txKeys of near transactions. */\n    @GridToStringInclude\n    @GridDirectTransient\n    private Map<IgniteTxKey, TxLockList> nearTxKeyLocks = new HashMap<>();\n    /** Remote keys involved into transactions. Doesn't include near keys. */\n    @GridToStringInclude\n    @GridDirectTransient\n    private Set<IgniteTxKey> txKeys;\n    /** Array of txKeys from {@link #nearTxKeyLocks}. Used during marshalling and unmarshalling. */\n    @GridToStringExclude\n    private IgniteTxKey[] nearTxKeysArr;\n    /** Array of txKeys from {@link #txKeys}. Used during marshalling and unmarshalling. */\n    @GridToStringExclude\n    private IgniteTxKey[] txKeysArr;\n    /** Array of locksArr from {@link #nearTxKeyLocks}. Used during marshalling and unmarshalling. */\n    @GridToStringExclude\n    private TxLockList[] locksArr;\n    /**\n     * Default constructor.\n     */\n    public TxLocksResponse() {\n        // No-op.\n    }\n    /** {@inheritDoc} */\n    @Override public int handlerId() {\n        return 0;\n    }\n    /** {@inheritDoc} */\n    @Override public boolean cacheGroupMessage() {\n        return false;\n    }\n    /**\n     * @return Future ID.\n     */\n    public long futureId() {\n        return futId;\n    }\n    /**\n     * @param futId Future ID.\n     */\n    public void futureId(long futId) {\n        this.futId = futId;\n    }\n    /**\n     * @return Lock lists for all tx nearTxKeysArr.\n     */\n    public Map<IgniteTxKey, TxLockList> txLocks() {\n        return nearTxKeyLocks;\n    }\n    /**\n     * @param txKey Tx key.\n     * @return Lock list for given tx key.\n     */\n    public TxLockList txLocks(IgniteTxKey txKey) {\n        return nearTxKeyLocks.get(txKey);\n    }\n    /**\n     * @param txKey Tx key.\n     * @param txLock Tx lock.\n     */\n    public void addTxLock(IgniteTxKey txKey, TxLock txLock) {\n        TxLockList lockList = nearTxKeyLocks.get(txKey);\n        if (lockList == null)\n            nearTxKeyLocks.put(txKey, lockList = new TxLockList());\n        lockList.add(txLock);\n    }\n    /**\n     * @return Remote txKeys involved into tx.\n     */\n    public Set<IgniteTxKey> keys() {\n        return txKeys;\n    }\n    /**\n     * @param key Key.\n     */\n    public void addKey(IgniteTxKey key) {\n        if (txKeys == null)\n            txKeys = new HashSet<>();\n        txKeys.add(key);\n    }\n    /** {@inheritDoc} */\n    @Override public boolean addDeploymentInfo() {\n        return addDepInfo;\n    }\n    /** {@inheritDoc} */\n    @Override public String toString() {\n        return S.toString(TxLocksResponse.class, this);\n    }\n    /** {@inheritDoc} */\n    @Override public void prepareMarshal(GridCacheSharedContext ctx) throws IgniteCheckedException {\n        super.prepareMarshal(ctx);\n        if (nearTxKeyLocks != null && !nearTxKeyLocks.isEmpty()) {\n            int len = nearTxKeyLocks.size();\n            nearTxKeysArr = new IgniteTxKey[len];\n            locksArr = new TxLockList[len];\n            int i = 0;\n            for (Map.Entry<IgniteTxKey, TxLockList> entry : nearTxKeyLocks.entrySet()) {\n                IgniteTxKey key = entry.getKey();\n                key.prepareMarshal(ctx.cacheContext(key.cacheId()));\n                nearTxKeysArr[i] = key;\n                locksArr[i] = entry.getValue();\n                i++;\n            }\n        }\n        if (txKeys != null && !txKeys.isEmpty()) {\n            txKeysArr = new IgniteTxKey[txKeys.size()];\n            int i = 0;\n            for (IgniteTxKey key : txKeys) {\n                key.prepareMarshal(ctx.cacheContext(key.cacheId()));\n                txKeysArr[i++] = key;\n            }\n        }\n    }\n    /** {@inheritDoc} */\n    @Override public void finishUnmarshal(GridCacheSharedContext ctx, ClassLoader ldr) throws IgniteCheckedException {\n        try {\n            super.finishUnmarshal(ctx, ldr);\n            if (nearTxKeysArr != null) {\n                for (int i = 0; i < nearTxKeysArr.length; i++) {\n                    IgniteTxKey txKey = nearTxKeysArr[i];\n                    txKey.key().finishUnmarshal(ctx.cacheObjectContext(txKey.cacheId()), ldr);\n                    txLocks().put(txKey, locksArr[i]);\n                }\n                nearTxKeysArr = null;\n                locksArr = null;\n            }\n            if (txKeysArr != null) {\n                txKeys = U.newHashSet(txKeysArr.length);\n                for (IgniteTxKey txKey : txKeysArr) {\n                    txKey.key().finishUnmarshal(ctx.cacheObjectContext(txKey.cacheId()), ldr);\n                    txKeys.add(txKey);\n                }\n                txKeysArr = null;\n            }\n        }\n        catch (Exception e) {\n            throw new IgniteCheckedException(e);\n        }\n    }\n    /** {@inheritDoc} */\n    @Override public boolean writeTo(ByteBuffer buf, MessageWriter writer) {\n        writer.setBuffer(buf);\n        if (!super.writeTo(buf, writer))\n            return false;\n        if (!writer.isHeaderWritten()) {\n            if (!writer.writeHeader(directType(), fieldsCount()))\n                return false;\n            writer.onHeaderWritten();\n        }\n        switch (writer.state()) {\n            case 3:\n                if (!writer.writeLong(\"futId\", futId))\n                    return false;\n                writer.incrementState();\n            case 4:\n                if (!writer.writeObjectArray(\"locksArr\", locksArr, MessageCollectionItemType.MSG))\n                    return false;\n                writer.incrementState();\n            case 5:\n                if (!writer.writeObjectArray(\"nearTxKeysArr\", nearTxKeysArr, MessageCollectionItemType.MSG))\n                    return false;\n                writer.incrementState();\n            case 6:\n                if (!writer.writeObjectArray(\"txKeysArr\", txKeysArr, MessageCollectionItemType.MSG))\n                    return false;\n                writer.incrementState();\n        }\n        return true;\n    }\n    /** {@inheritDoc} */\n<fim_suffix>    @Override public boolean readFrom(ByteBuffer buf, MessageReader reader) {\n        reader.setBuffer(buf);\n        if (!reader.beforeMessageRead())\n            return false;\n        if (!super.readFrom(buf, reader))\n            return false;\n        switch (reader.state()) {\n            case 3:\n                futId = reader.readLong(\"futId\");\n                if (!reader.isLastRead())\n                    return false;\n                reader.incrementState();\n            case 4:\n                locksArr = reader.readObjectArray(\"locksArr\", MessageCollectionItemType.MSG, TxLockList.class);\n                if (!reader.isLastRead())\n                    return false;\n                reader.incrementState();\n            case 5:\n                nearTxKeysArr = reader.readObjectArray(\"nearTxKeysArr\", MessageCollectionItemType.MSG, IgniteTxKey.class);\n                if (!reader.isLastRead())\n                    return false;\n                reader.incrementState();\n            case 6:\n                txKeysArr = reader.readObjectArray(\"txKeysArr\", MessageCollectionItemType.MSG, IgniteTxKey.class);\n                if (!reader.isLastRead())\n                    return false;\n                reader.incrementState();\n        }\n        return reader.afterMessageRead(TxLocksResponse.class);\n    }<fim_middle>// function below is long method\n"}