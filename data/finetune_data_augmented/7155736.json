{"text": "<fim_prefix>            this.sslHandshakeOutputStream = sslHandshakeOutputStream;\n            this.logger = tdsChannel.getLogger();\n            this.logContext = tdsChannel.toString() + \" (SSLHandshakeInputStream):\";\n        }\n        /**\n         * If there is no handshake response data available to be read from existing packets then this method ensures\n         * that the SSL handshake output stream has been flushed to the server, and reads another packet (starting the\n         * next TDS response message).\n         *\n         * Note that simply using TDSReader.ensurePayload isn't sufficient as it does not automatically start the new\n         * response message.\n         */\n        private void ensureSSLPayload() throws IOException {\n            if (0 == tdsReader.available()) {\n                if (logger.isLoggable(Level.FINEST))\n                    logger.finest(logContext\n                            + \" No handshake response bytes available. Flushing SSL handshake output stream.\");\n                try {\n                    sslHandshakeOutputStream.endMessage();\n                } catch (SQLServerException e) {\n                    logger.finer(logContext + \" Ending TDS message threw exception:\" + e.getMessage());\n                    throw new IOException(e.getMessage());\n                }\n                if (logger.isLoggable(Level.FINEST))\n                    logger.finest(logContext + \" Reading first packet of SSL handshake response\");\n                try {\n                    tdsReader.readPacket();\n                } catch (SQLServerException e) {\n                    logger.finer(logContext + \" Reading response packet threw exception:\" + e.getMessage());\n                    throw new IOException(e.getMessage());\n                }\n            }\n        }\n        public long skip(long n) throws IOException {\n            if (logger.isLoggable(Level.FINEST))\n                logger.finest(logContext + \" Skipping \" + n + \" bytes...\");\n            if (n <= 0)\n                return 0;\n            if (n > Integer.MAX_VALUE)\n                n = Integer.MAX_VALUE;\n            ensureSSLPayload();\n            try {\n                tdsReader.skip((int) n);\n            } catch (SQLServerException e) {\n                logger.finer(logContext + \" Skipping bytes threw exception:\" + e.getMessage());\n                throw new IOException(e.getMessage());\n            }\n            return n;\n        }\n        private final byte oneByte[] = new byte[1];\n        public int read() throws IOException {\n            int bytesRead;\n            while (0 == (bytesRead = readInternal(oneByte, 0, oneByte.length)));\n            assert 1 == bytesRead || -1 == bytesRead;\n            return 1 == bytesRead ? oneByte[0] : -1;\n        }\n        public int read(byte[] b) throws IOException {\n            return readInternal(b, 0, b.length);\n        }\n        public int read(byte b[], int offset, int maxBytes) throws IOException {\n            return readInternal(b, offset, maxBytes);\n        }\n        private int readInternal(byte b[], int offset, int maxBytes) throws IOException {\n            if (logger.isLoggable(Level.FINEST))\n                logger.finest(logContext + \" Reading \" + maxBytes + \" bytes...\");\n            ensureSSLPayload();\n            try {\n                tdsReader.readBytes(b, offset, maxBytes);\n            } catch (SQLServerException e) {\n                logger.finer(logContext + \" Reading bytes threw exception:\" + e.getMessage());\n                throw new IOException(e.getMessage());\n            }\n            return maxBytes;\n        }\n    }\n    /**\n     * Used during SSL handshake, this class implements an OutputStream that writes SSL handshake request data (framed\n     * in TDS messages) to the TDS channel.\n     */\n    private class SSLHandshakeOutputStream extends OutputStream {\n        private final TDSWriter tdsWriter;\n        /** Flag indicating when it is necessary to start a new prelogin TDS message */\n        private boolean messageStarted;\n        private final Logger logger;\n        private final String logContext;\n        SSLHandshakeOutputStream(TDSChannel tdsChannel) {\n            this.tdsWriter = tdsChannel.getWriter();\n            this.messageStarted = false;\n            this.logger = tdsChannel.getLogger();\n            this.logContext = tdsChannel.toString() + \" (SSLHandshakeOutputStream):\";\n        }\n        public void flush() throws IOException {\n            // It seems that the security provider implementation in some JVMs\n            // (notably SunJSSE in the 6.0 JVM) likes to add spurious calls to\n            // flush the SSL handshake output stream during SSL handshaking.\n            // We need to ignore these calls because the SSL handshake payload\n            // needs to be completely encapsulated in TDS. The SSL handshake\n            // input stream always ensures that this output stream has been flushed\n            // before trying to read the response.\n            if (logger.isLoggable(Level.FINEST))\n                logger.finest(logContext + \" Ignored a request to flush the stream\");\n        }\n        void endMessage() throws SQLServerException {\n            // We should only be asked to end the message if we have started one\n            assert messageStarted;\n            if (logger.isLoggable(Level.FINEST))\n                logger.finest(logContext + \" Finishing TDS message\");\n            // Flush any remaining bytes through the writer. Since there may be fewer bytes\n            // ready to send than a full TDS packet, we end the message here and start a new\n            // one later if additional handshake data needs to be sent.\n            tdsWriter.endMessage();\n            messageStarted = false;\n        }\n        private final byte singleByte[] = new byte[1];\n        public void write(int b) throws IOException {\n            singleByte[0] = (byte) (b & 0xFF);\n            writeInternal(singleByte, 0, singleByte.length);\n        }\n        public void write(byte[] b) throws IOException {\n            writeInternal(b, 0, b.length);\n        }\n        public void write(byte[] b, int off, int len) throws IOException {\n            writeInternal(b, off, len);\n        }\n        private void writeInternal(byte[] b, int off, int len) throws IOException {\n            try {\n                // Start out the handshake request in a new prelogin message. Subsequent\n                // writes just add handshake data to the request until flushed.\n                if (!messageStarted) {\n                    if (logger.isLoggable(Level.FINEST))\n                        logger.finest(logContext + \" Starting new TDS packet...\");\n                    tdsWriter.startMessage(null, TDS.PKT_PRELOGIN);\n                    messageStarted = true;\n                }\n                if (logger.isLoggable(Level.FINEST))\n                    logger.finest(logContext + \" Writing \" + len + \" bytes...\");\n                tdsWriter.writeBytes(b, off, len);\n            } catch (SQLServerException e) {\n                logger.finer(logContext + \" Writing bytes threw exception:\" + e.getMessage());\n                throw new IOException(e.getMessage());\n            }\n        }\n    }\n    /**\n     * This class implements an InputStream that just forwards all of its methods to an underlying InputStream.\n     *\n     * It is more predictable than FilteredInputStream which forwards some of its read methods directly to the\n     * underlying stream, but not others.\n     */\n    private final class ProxyInputStream extends InputStream {\n        private InputStream filteredStream;\n        ProxyInputStream(InputStream is) {\n            filteredStream = is;\n        }\n        final void setFilteredStream(InputStream is) {\n            filteredStream = is;\n        }\n        public long skip(long n) throws IOException {\n            long bytesSkipped;\n            if (logger.isLoggable(Level.FINEST))\n                logger.finest(toString() + \" Skipping \" + n + \" bytes\");\n            bytesSkipped = filteredStream.skip(n);\n            if (logger.isLoggable(Level.FINEST))\n                logger.finest(toString() + \" Skipped \" + n + \" bytes\");\n            return bytesSkipped;\n        }\n        public int available() throws IOException {\n            int bytesAvailable = filteredStream.available();\n            if (logger.isLoggable(Level.FINEST))\n                logger.finest(toString() + \" \" + bytesAvailable + \" bytes available\");\n            return bytesAvailable;\n        }\n        private final byte oneByte[] = new byte[1];\n        public int read() throws IOException {\n            int bytesRead;\n            while (0 == (bytesRead = readInternal(oneByte, 0, oneByte.length)));\n            assert 1 == bytesRead || -1 == bytesRead;\n            return 1 == bytesRead ? oneByte[0] : -1;\n        }\n<fim_suffix>        public int read(byte[] b) throws IOException {\n            return readInternal(b, 0, b.length);\n        }<fim_middle>// function below has no smell\n"}