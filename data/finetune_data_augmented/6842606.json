{"text": "<fim_prefix>// Copyright (C) 2005 Google Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\npackage com.google.caja.util;\n\nimport java.io.Serializable;\nimport java.util.AbstractMap;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * A set of attributes attached to a parse tree node that have been inferred by\n * the parser.\n *\n * @author mikesamuel@gmail.com\n */\npublic final class SyntheticAttributes\n    extends AbstractMap<SyntheticAttributeKey<?>, Object>\n    implements Serializable {\n  private static final long serialVersionUID = 1124793823020078634L;\n  /**\n   * True iff this has its own copy without clobbering another maps attributes.\n   * The copy constructor below does copy-on-write of the underlying map.\n   */\n  private boolean hasOwnCopy;\n  private Map<SyntheticAttributeKey<?>, Object> attributes;\n  private boolean immutable = false;\n\n  public SyntheticAttributes() {\n    clear();\n  }\n\n  public SyntheticAttributes(SyntheticAttributes sa) {\n    attributes = sa.attributes;\n    immutable = sa.immutable;\n    sa.hasOwnCopy = false;\n  }\n\n  public void makeImmutable() {\n    if (immutable) { return; }\n    requireOwnCopy();\n    immutable = true;\n  }\n\n  public boolean isImmutable() {\n    return immutable;\n  }\n\n  @Override\n  public void clear() {\n    if (immutable) {\n      throw new UnsupportedOperationException();\n    }\n    attributes = Collections.emptyMap();\n    hasOwnCopy = false;\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  public <T> T get(SyntheticAttributeKey<T> k) {\n    return (T) attributes.get(k);\n  }\n\n  @Override\n  public Object get(Object k) {\n    return attributes.get(k);\n  }\n\n  /**\n   * associate the value v with the key k.\n   * @param k non null.\n   * @param v non null.\n   * @return the old value associated with k or null if none.\n   */\n  @SuppressWarnings(\"unchecked\")\n  public <T> T set(SyntheticAttributeKey<T> k, T v) {\n    if (immutable) {\n      throw new UnsupportedOperationException();\n    }\n    if (!(null == v || k.getType().isInstance(v))) {\n      throw new ClassCastException(v + \" to \" + k.getType());\n    }\n    requireOwnCopy();\n    return (T) attributes.put(k, v);\n  }\n\n  @Deprecated\n  @Override\n  public Object put(SyntheticAttributeKey<?> k, Object v) {\n    if (immutable) {\n      throw new UnsupportedOperationException();\n    }\n    if (!(null == v || k.getType().isInstance(v))) {\n      throw new ClassCastException(v + \" to \" + k.getType());\n    }\n    requireOwnCopy();\n    return attributes.put(k, v);\n  }\n\n  /**\n   * @return true iff the value associated with the given key is\n   * {@link Boolean#TRUE}.\n   */\n  public boolean is(SyntheticAttributeKey<Boolean> k) {\n    return Boolean.TRUE.equals(attributes.get(k));\n  }\n\n  /**\n   * @see #remove(Object)\n   */\n<fim_suffix>  @SuppressWarnings(\"unchecked\")\n  public <T> T remove(SyntheticAttributeKey<T> k) {\n    if (immutable) {\n      throw new UnsupportedOperationException();\n    }\n    return (T) remove((Object) k);\n  }\n\n  @Override\n  public Object remove(Object k) {\n    if (immutable) {\n      throw new UnsupportedOperationException();\n    }\n    if (!hasOwnCopy) {\n      if (attributes.isEmpty()) { return null; }\n      requireOwnCopy();\n    }\n    return attributes.remove(k);\n  }\n\n  private void requireOwnCopy() {\n    if (!hasOwnCopy) {\n      attributes = new HashMap<SyntheticAttributeKey<?>, Object>(attributes);\n      hasOwnCopy = true;\n    }\n  }\n\n  @Override\n  public int size() { return attributes.size(); }\n\n  @Override\n  public boolean containsKey(Object k) { return attributes.containsKey(k); }\n\n  @Override\n  public boolean containsValue(Object v) { return attributes.containsValue(v); }\n\n  /**\n   * @return an immutable entry set to force proper type checking of keys\n   *     and values.  Mutability could be implemented, but it's not currently\n   *     used.\n   */\n  @Override\n  public Set<Map.Entry<SyntheticAttributeKey<?>, Object>> entrySet() {\n    return Collections.unmodifiableMap(attributes).entrySet();\n  }\n}<fim_middle>// function below has no smell\n"}