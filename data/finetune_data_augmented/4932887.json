{"text": "<fim_prefix>        }\n        IOUtils.closeQuietly( is );\n        return name;\n    }\n    /**\n     *  Attempts to find a resource from the given template, and if it's not found\n     *  attempts to locate it from the default template.\n     * @param sContext\n     * @param template\n     * @param name\n     * @return the Resource for the given template and name.\n     */\n    private static String findResource( ServletContext sContext, String template, String name )\n    {\n        if( name.charAt(0) == '/' )\n        {\n            // This is already a full path\n            return findResource( sContext, name );\n        }\n        String fullname = makeFullJSPName( template, name );\n        return findResource( sContext, fullname );\n    }\n    /**\n     *  An utility method for finding a JSP page.  It searches only under\n     *  either current context or by the absolute name.\n     *\n     *  @param pageContext the JSP PageContext\n     *  @param name The name of the JSP page to look for (e.g \"Wiki.jsp\")\n     *  @return The context path to the resource\n     */\n    public String findJSP( PageContext pageContext, String name )\n    {\n        ServletContext sContext = pageContext.getServletContext();\n        return findResource( sContext, name );\n    }\n    /**\n     *  Removes the template part of a name.\n     */\n    private static String removeTemplatePart( String name )\n    {\n        int idx = 0;\n        if( name.startsWith( \"/\" ) ) idx = 1;\n        idx = name.indexOf('/', idx);\n        if( idx != -1 )\n        {\n            idx = name.indexOf('/', idx+1); // Find second \"/\"\n            if( idx != -1 )\n            {\n                name = name.substring( idx+1 );\n            }\n        }\n        if( log.isDebugEnabled() ) log.debug( \"Final name = \"+name );\n        return name;\n    }\n    /**\n     *  Returns the full name (/templates/foo/bar) for name=bar, template=foo.\n     *\n     * @param template The name of the template.\n     * @param name The name of the resource.\n     * @return The full name for a template.\n     */\n    private static String makeFullJSPName( String template, String name )\n    {\n        return \"/\"+DIRECTORY+\"/\"+template+\"/\"+name;\n    }\n    /**\n     *  Attempts to locate a resource under the given template.  If that template\n     *  does not exist, or the page does not exist under that template, will\n     *  attempt to locate a similarly named file under the default template.\n     *  <p>\n     *  Even though the name suggests only JSP files can be located, but in fact\n     *  this method can find also other resources than JSP files.\n     *\n     *  @param pageContext The JSP PageContext\n     *  @param template From which template we should seek initially?\n     *  @param name Which resource are we looking for (e.g. \"ViewTemplate.jsp\")\n     *  @return path to the JSP page; null, if it was not found.\n     */\n    public String findJSP( PageContext pageContext, String template, String name )\n    {\n        if( name == null || template == null )\n        {\n            log.fatal(\"findJSP() was asked to find a null template or name (\"+template+\",\"+name+\").\"+\n                      \" JSP page '\"+\n                      ((HttpServletRequest)pageContext.getRequest()).getRequestURI()+\"'\");\n            throw new InternalWikiException(\"Illegal arguments to findJSP(); please check logs.\");\n        }\n        return findResource( pageContext.getServletContext(), template, name );\n    }\n    /**\n     *  Attempts to locate a resource under the given template.  This matches the\n     *  functionality findJSP(), but uses the WikiContext as the argument.  If there\n     *  is no servlet context (i.e. this is embedded), will just simply return\n     *  a best-guess.\n     *  <p>\n     *  This method is typically used to locate any resource, including JSP pages, images,\n     *  scripts, etc.\n     *\n     *  @since 2.6\n     *  @param ctx the wiki context\n     *  @param template the name of the template to use\n     *  @param name the name of the resource to fine\n     *  @return the path to the resource\n     */\n    public String findResource( WikiContext ctx, String template, String name )\n    {\n        if( m_engine.getServletContext() != null )\n        {\n            return findResource( m_engine.getServletContext(), template, name );\n        }\n        return getPath(template)+\"/\"+name;\n    }\n    /**\n     *  Returns a property, as defined in the template.  The evaluation\n     *  is lazy, i.e. the properties are not loaded until the template is\n     *  actually used for the first time.\n     */\n    /*\n    public String getTemplateProperty( WikiContext context, String key )\n    {\n        String template = context.getTemplate();\n        try\n        {\n            Properties props = (Properties)m_propertyCache.getFromCache( template, -1 );\n            if( props == null )\n            {\n                try\n                {\n                    props = getTemplateProperties( template );\n                    m_propertyCache.putInCache( template, props );\n                }\n                catch( IOException e )\n                {\n                    log.warn(\"IO Exception while reading template properties\",e);\n                    return null;\n                }\n            }\n            return props.getProperty( key );\n        }\n        catch( NeedsRefreshException ex )\n        {\n            // FIXME\n            return null;\n        }\n    }\n*/\n    /**\n     *  Returns an absolute path to a given template.\n     */\n    private static String getPath( String template )\n    {\n        return \"/\"+DIRECTORY+\"/\"+template+\"/\";\n    }\n    /**\n     *   Lists the skins available under this template.  Returns an\n     *   empty Set, if there are no extra skins available.  Note that\n     *   this method does not check whether there is anything actually\n     *   in the directories, it just lists them.  This may change\n     *   in the future.\n     *\n     *   @param pageContext the JSP PageContext\n     *   @param template The template to search\n     *   @return Set of Strings with the skin names.\n     *   @since 2.3.26\n     */\n    public Set< String > listSkins( PageContext pageContext, String template )\n    {\n        String place = makeFullJSPName( template, SKIN_DIRECTORY );\n        ServletContext sContext = pageContext.getServletContext();\n        Set<String> skinSet = sContext.getResourcePaths( place );\n        TreeSet<String> resultSet = new TreeSet<>();\n        if( log.isDebugEnabled() ) log.debug( \"Listings skins from \"+place );\n        if( skinSet != null )\n        {\n            String[] skins = {};\n            skins = skinSet.toArray(skins);\n            for (int i = 0; i < skins.length; i++)\n            {\n                String[] s = StringUtils.split(skins[i], \"/\");\n                if (s.length > 2 && skins[i].endsWith(\"/\"))\n                {\n                    String skinName = s[s.length - 1];\n                    resultSet.add(skinName);\n                    if (log.isDebugEnabled())\n                        log.debug(\"...adding skin '\" + skinName + \"'\");\n                }\n            }\n        }\n        return resultSet;\n    }\n    /**\n     * List all installed i18n language properties by classpath searching for files like :\n     *    templates/default_*.properties\n     *    templates/default.properties\n     *\n     * @param pageContext\n     * @return map of installed Languages\n     * @since 2.7.x\n     */\n<fim_suffix>    public Map< String, String > listLanguages(PageContext pageContext)\n    {\n        Map< String, String > resultMap = new LinkedHashMap<>();\n        String clientLanguage = ((HttpServletRequest) pageContext.getRequest()).getLocale().toString();\n        List< String > entries = ClassUtil.classpathEntriesUnder( DIRECTORY );\n        for( String name : entries ) {\n            if ( name.equals( I18NRESOURCE_EN ) ||\n                    (name.startsWith( I18NRESOURCE_PREFIX ) && name.endsWith( I18NRESOURCE_SUFFIX ) ) )\n            {\n                if (name.equals( I18NRESOURCE_EN )) {\n                    name = I18NRESOURCE_EN_ID;\n                }    else {\n                    name = name.substring(I18NRESOURCE_PREFIX.length(), name.lastIndexOf(I18NRESOURCE_SUFFIX));\n                }\n                Locale locale = new Locale(name.substring(0, 2), ((name.indexOf(\"_\") == -1) ? \"\" : name.substring(3, 5)));\n                String defaultLanguage = \"\";\n                if (clientLanguage.startsWith(name))\n                {\n                    defaultLanguage = LocaleSupport.getLocalizedMessage(pageContext, I18NDEFAULT_LOCALE);\n                }\n                resultMap.put(name, locale.getDisplayName(locale) + \" \" + defaultLanguage);\n            }\n        }\n        return resultMap;\n    }<fim_middle>// function below is long method\n"}