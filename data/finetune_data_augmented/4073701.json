{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.asterix.external.parser;\nimport java.io.DataOutput;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.BitSet;\nimport java.util.List;\nimport org.apache.asterix.builders.AbvsBuilderFactory;\nimport org.apache.asterix.builders.IARecordBuilder;\nimport org.apache.asterix.builders.IAsterixListBuilder;\nimport org.apache.asterix.builders.ListBuilderFactory;\nimport org.apache.asterix.builders.OrderedListBuilder;\nimport org.apache.asterix.builders.RecordBuilderFactory;\nimport org.apache.asterix.builders.UnorderedListBuilder;\nimport org.apache.asterix.common.exceptions.ErrorCode;\nimport org.apache.asterix.dataflow.data.nontagged.serde.APolygonSerializerDeserializer;\nimport org.apache.asterix.external.api.IRawRecord;\nimport org.apache.asterix.external.api.IRecordDataParser;\nimport org.apache.asterix.external.api.IStreamDataParser;\nimport org.apache.asterix.om.base.ABoolean;\nimport org.apache.asterix.om.base.ANull;\nimport org.apache.asterix.om.base.temporal.GregorianCalendarSystem;\nimport org.apache.asterix.om.types.AOrderedListType;\nimport org.apache.asterix.om.types.ARecordType;\nimport org.apache.asterix.om.types.ATypeTag;\nimport org.apache.asterix.om.types.AUnionType;\nimport org.apache.asterix.om.types.AUnorderedListType;\nimport org.apache.asterix.om.types.IAType;\nimport org.apache.asterix.om.types.hierachy.ATypeHierarchy;\nimport org.apache.asterix.om.types.hierachy.ITypeConvertComputer;\nimport org.apache.asterix.om.util.container.IObjectPool;\nimport org.apache.asterix.om.util.container.ListObjectPool;\nimport org.apache.asterix.runtime.operators.file.adm.AdmLexer;\nimport org.apache.asterix.runtime.operators.file.adm.AdmLexer.TokenImage;\nimport org.apache.hyracks.api.exceptions.HyracksDataException;\nimport org.apache.hyracks.data.std.api.IMutableValueStorage;\nimport org.apache.hyracks.data.std.util.ArrayBackedValueStorage;\n/**\n * Parser for ADM formatted data.\n */\npublic class ADMDataParser extends AbstractDataParser implements IStreamDataParser, IRecordDataParser<char[]> {\n    private AdmLexer admLexer;\n    private final ARecordType recordType;\n    private final ArrayBackedValueStorage castBuffer = new ArrayBackedValueStorage();\n    private final IObjectPool<IARecordBuilder, ATypeTag> recordBuilderPool =\n            new ListObjectPool<IARecordBuilder, ATypeTag>(new RecordBuilderFactory());\n    private final IObjectPool<IAsterixListBuilder, ATypeTag> listBuilderPool =\n            new ListObjectPool<IAsterixListBuilder, ATypeTag>(new ListBuilderFactory());\n    private final IObjectPool<IMutableValueStorage, ATypeTag> abvsBuilderPool =\n            new ListObjectPool<IMutableValueStorage, ATypeTag>(new AbvsBuilderFactory());\n    private final TokenImage tmpTokenImage = new TokenImage();\n    private final String mismatchErrorMessage = \"Mismatch Type, expecting a value of type \";\n    private final String mismatchErrorMessage2 = \" got a value of type \";\n    public ADMDataParser(ARecordType recordType, boolean isStream) {\n        this(null, recordType, isStream);\n    }\n    public ADMDataParser(String filename, ARecordType recordType, boolean isStream) {\n        this.filename = filename;\n        this.recordType = recordType;\n        if (!isStream) {\n            this.admLexer = new AdmLexer();\n        }\n    }\n<fim_suffix>    @Override\n    public boolean parse(DataOutput out) throws HyracksDataException {\n        try {\n            resetPools();\n            return parseAdmInstance(recordType, out);\n        } catch (ParseException e) {\n            e.setLocation(filename, admLexer.getLine(), admLexer.getColumn());\n            throw e;\n        } catch (IOException e) {\n            throw new ParseException(e, filename, admLexer.getLine(), admLexer.getColumn());\n        }\n    }\n    @Override\n    public void parse(IRawRecord<? extends char[]> record, DataOutput out) throws HyracksDataException {\n        try {\n            resetPools();\n            admLexer.setBuffer(record.get());\n            parseAdmInstance(recordType, out);\n        } catch (ParseException e) {\n            e.setLocation(filename, admLexer.getLine(), admLexer.getColumn());\n            throw e;\n        } catch (IOException e) {\n            throw new ParseException(e, filename, admLexer.getLine(), admLexer.getColumn());\n        }\n    }\n    @Override\n    public void setInputStream(InputStream in) throws IOException {\n        admLexer = new AdmLexer(new java.io.InputStreamReader(in));\n    }\n    protected boolean parseAdmInstance(IAType objectType, DataOutput out) throws IOException {\n        int token = admLexer.next();\n        if (token == AdmLexer.TOKEN_EOF) {\n            return false;\n        } else {\n            admFromLexerStream(token, objectType, out);\n            return true;\n        }\n    }\n    private void admFromLexerStream(int token, IAType objectType, DataOutput out) throws IOException {\n        switch (token) {\n            case AdmLexer.TOKEN_NULL_LITERAL:\n                if (checkType(ATypeTag.NULL, objectType)) {\n                    nullSerde.serialize(ANull.NULL, out);\n                } else {\n                    throw new ParseException(ErrorCode.PARSER_ADM_DATA_PARSER_FIELD_NOT_NULL, \"\");\n                }\n                break;\n            case AdmLexer.TOKEN_TRUE_LITERAL:\n                if (checkType(ATypeTag.BOOLEAN, objectType)) {\n                    booleanSerde.serialize(ABoolean.TRUE, out);\n                } else {\n                    throw new ParseException(ErrorCode.PARSER_ADM_DATA_PARSER_TYPE_MISMATCH, objectType.getTypeName());\n                }\n                break;\n            case AdmLexer.TOKEN_BOOLEAN_CONS:\n                parseConstructor(ATypeTag.BOOLEAN, objectType, out);\n                break;\n            case AdmLexer.TOKEN_FALSE_LITERAL:\n                if (checkType(ATypeTag.BOOLEAN, objectType)) {\n                    booleanSerde.serialize(ABoolean.FALSE, out);\n                } else {\n                    throw new ParseException(ErrorCode.PARSER_ADM_DATA_PARSER_TYPE_MISMATCH, objectType.getTypeName());\n                }\n                break;\n            case AdmLexer.TOKEN_DOUBLE_LITERAL:\n                parseToNumericTarget(ATypeTag.DOUBLE, objectType, out);\n                break;\n            case AdmLexer.TOKEN_DOUBLE_CONS:\n                parseConstructor(ATypeTag.DOUBLE, objectType, out);\n                break;\n            case AdmLexer.TOKEN_FLOAT_LITERAL:\n                parseToNumericTarget(ATypeTag.FLOAT, objectType, out);\n                break;\n            case AdmLexer.TOKEN_FLOAT_CONS:\n                parseConstructor(ATypeTag.FLOAT, objectType, out);\n                break;\n            case AdmLexer.TOKEN_INT8_LITERAL:\n                parseAndCastNumeric(ATypeTag.TINYINT, objectType, out);\n                break;\n            case AdmLexer.TOKEN_INT8_CONS:\n                parseConstructor(ATypeTag.TINYINT, objectType, out);\n                break;\n            case AdmLexer.TOKEN_INT16_LITERAL:\n                parseAndCastNumeric(ATypeTag.SMALLINT, objectType, out);\n                break;\n            case AdmLexer.TOKEN_INT16_CONS:\n                parseConstructor(ATypeTag.SMALLINT, objectType, out);\n                break;\n            case AdmLexer.TOKEN_INT_LITERAL:\n                // For an INT value without any suffix, we return it as BIGINT type value since it is\n                // the default integer type.<fim_middle>// function below has no smell\n"}