{"text": "<fim_prefix>/*\n *  Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing,\n *  software distributed under the License is distributed on an\n *  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n *  KIND, either express or implied.  See the License for the\n *  specific language governing permissions and limitations\n *  under the License.\n */\npackage org.codehaus.groovy.classgen.asm.indy;\nimport org.codehaus.groovy.ast.ClassHelper;\nimport org.codehaus.groovy.ast.ClassNode;\nimport org.codehaus.groovy.ast.expr.ArgumentListExpression;\nimport org.codehaus.groovy.ast.expr.CastExpression;\nimport org.codehaus.groovy.ast.expr.ClassExpression;\nimport org.codehaus.groovy.ast.expr.ConstantExpression;\nimport org.codehaus.groovy.ast.expr.ConstructorCallExpression;\nimport org.codehaus.groovy.ast.expr.EmptyExpression;\nimport org.codehaus.groovy.ast.expr.Expression;\nimport org.codehaus.groovy.ast.tools.WideningCategories;\nimport org.codehaus.groovy.classgen.AsmClassGenerator;\nimport org.codehaus.groovy.classgen.asm.BytecodeHelper;\nimport org.codehaus.groovy.classgen.asm.CompileStack;\nimport org.codehaus.groovy.classgen.asm.InvocationWriter;\nimport org.codehaus.groovy.classgen.asm.MethodCallerMultiAdapter;\nimport org.codehaus.groovy.classgen.asm.OperandStack;\nimport org.codehaus.groovy.classgen.asm.WriterController;\nimport org.codehaus.groovy.runtime.wrappers.Wrapper;\nimport org.codehaus.groovy.vmplugin.v7.IndyInterface;\nimport org.objectweb.asm.Handle;\nimport java.lang.invoke.CallSite;\nimport java.lang.invoke.MethodHandles.Lookup;\nimport java.lang.invoke.MethodType;\nimport static org.codehaus.groovy.classgen.asm.BytecodeHelper.getTypeDescription;\nimport static org.codehaus.groovy.vmplugin.v7.IndyInterface.CALL_TYPES.CAST;\nimport static org.codehaus.groovy.vmplugin.v7.IndyInterface.CALL_TYPES.GET;\nimport static org.codehaus.groovy.vmplugin.v7.IndyInterface.CALL_TYPES.INIT;\nimport static org.codehaus.groovy.vmplugin.v7.IndyInterface.CALL_TYPES.METHOD;\nimport static org.codehaus.groovy.vmplugin.v7.IndyInterface.GROOVY_OBJECT;\nimport static org.codehaus.groovy.vmplugin.v7.IndyInterface.IMPLICIT_THIS;\nimport static org.codehaus.groovy.vmplugin.v7.IndyInterface.SAFE_NAVIGATION;\nimport static org.codehaus.groovy.vmplugin.v7.IndyInterface.SPREAD_CALL;\nimport static org.codehaus.groovy.vmplugin.v7.IndyInterface.THIS_CALL;\nimport static org.objectweb.asm.Opcodes.H_INVOKESTATIC;\n/**\n * This Writer is used to generate the call invocation byte codes\n * for usage by invokedynamic.\n */\npublic class InvokeDynamicWriter extends InvocationWriter {\n    private static final String INDY_INTERFACE_NAME = IndyInterface.class.getName().replace('.', '/');\n    private static final String BSM_METHOD_TYPE_DESCRIPTOR = \n        MethodType.methodType(\n                CallSite.class, Lookup.class, String.class, MethodType.class,\n                String.class, int.class\n        ).toMethodDescriptorString();\n    private static final Handle BSM = \n        new Handle(\n                H_INVOKESTATIC,\n                INDY_INTERFACE_NAME,\n                \"bootstrap\",\n                BSM_METHOD_TYPE_DESCRIPTOR);\n    private final WriterController controller;\n    public InvokeDynamicWriter(WriterController wc) {\n        super(wc);\n        this.controller = wc;\n    }\n    @Override\n    protected boolean makeCachedCall(Expression origin, ClassExpression sender,\n            Expression receiver, Expression message, Expression arguments,\n            MethodCallerMultiAdapter adapter, boolean safe, boolean spreadSafe,\n            boolean implicitThis, boolean containsSpreadExpression\n    ) {\n        // fixed number of arguments && name is a real String and no GString\n        if ((adapter == null || adapter == invokeMethod || adapter == invokeMethodOnCurrent || adapter == invokeStaticMethod) && !spreadSafe) {\n            String methodName = getMethodName(message);\n            if (methodName != null) {\n                makeIndyCall(adapter, receiver, implicitThis, safe, methodName, arguments);\n                return true;\n            }\n        }\n        return false;\n    }\n    private String prepareIndyCall(Expression receiver, boolean implicitThis) {\n        CompileStack compileStack = controller.getCompileStack();\n        OperandStack operandStack = controller.getOperandStack();\n        compileStack.pushLHS(false);\n        // load normal receiver as first argument\n        compileStack.pushImplicitThis(implicitThis);\n        receiver.visit(controller.getAcg());\n        compileStack.popImplicitThis();\n        return \"(\"+getTypeDescription(operandStack.getTopOperand());\n    }\n<fim_suffix>    private void finishIndyCall(Handle bsmHandle, String methodName, String sig, int numberOfArguments, Object... bsmArgs) {\n        CompileStack compileStack = controller.getCompileStack();\n        OperandStack operandStack = controller.getOperandStack();\n        controller.getMethodVisitor().visitInvokeDynamicInsn(methodName, sig, bsmHandle, bsmArgs);\n        operandStack.replace(ClassHelper.OBJECT_TYPE, numberOfArguments);\n        compileStack.popLHS();\n    }\n    private void makeIndyCall(MethodCallerMultiAdapter adapter, Expression receiver, boolean implicitThis, boolean safe, String methodName, Expression arguments) {\n        OperandStack operandStack = controller.getOperandStack();\n        StringBuilder sig = new StringBuilder(prepareIndyCall(receiver, implicitThis));\n        // load arguments\n        int numberOfArguments = 1;\n        ArgumentListExpression ae = makeArgumentList(arguments);\n        boolean containsSpreadExpression = AsmClassGenerator.containsSpreadExpression(arguments);\n        if (containsSpreadExpression) {\n            controller.getAcg().despreadList(ae.getExpressions(), true);\n            sig.append(getTypeDescription(Object[].class));\n        } else {\n            for (Expression arg : ae.getExpressions()) {\n                arg.visit(controller.getAcg());\n                if (arg instanceof CastExpression) {\n                    operandStack.box();\n                    controller.getAcg().loadWrapper(arg);\n                    sig.append(getTypeDescription(Wrapper.class));\n                } else {\n                    sig.append(getTypeDescription(operandStack.getTopOperand()));\n                }\n                numberOfArguments++;\n            }\n        }\n        sig.append(\")Ljava/lang/Object;\");\n        String callSiteName = METHOD.getCallSiteName();\n        if (adapter==null) callSiteName = INIT.getCallSiteName();\n        int flags = getMethodCallFlags(adapter, safe, containsSpreadExpression);\n        finishIndyCall(BSM, callSiteName, sig.toString(), numberOfArguments, methodName, flags);\n    }\n    private static int getMethodCallFlags(MethodCallerMultiAdapter adapter, boolean safe, boolean spread) {\n        int ret = 0;\n        if (safe)                           ret |= SAFE_NAVIGATION;\n        if (adapter==invokeMethodOnCurrent) ret |= THIS_CALL;\n        if (spread)                         ret |= SPREAD_CALL;\n        return ret;\n    }\n    @Override\n    public void makeSingleArgumentCall(Expression receiver, String message, Expression arguments, boolean safe) {\n        makeIndyCall(invokeMethod, receiver, false, safe, message, arguments);\n    }\n    private static int getPropertyFlags(boolean safe, boolean implicitThis, boolean groovyObject) {\n        int flags = 0;\n        if (implicitThis)   flags |= IMPLICIT_THIS;\n        if (groovyObject)   flags |= GROOVY_OBJECT;\n        if (safe)           flags |= SAFE_NAVIGATION;\n        return flags;\n    }\n    protected void writeGetProperty(Expression receiver, String propertyName, boolean safe, boolean implicitThis, boolean groovyObject) {\n        String sig = prepareIndyCall(receiver, implicitThis);\n        sig += \")Ljava/lang/Object;\";\n        int flags = getPropertyFlags(safe,implicitThis,groovyObject);\n        finishIndyCall(BSM, GET.getCallSiteName(), sig, 1, propertyName, flags);\n    }\n    @Override\n    protected void writeNormalConstructorCall(ConstructorCallExpression call) {\n        makeCall(call, new ClassExpression(call.getType()), new ConstantExpression(\"<init>\"), call.getArguments(), null, false, false, false);\n    }\n    @Override<fim_middle>// function below has no smell\n"}