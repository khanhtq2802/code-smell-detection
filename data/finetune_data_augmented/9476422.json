{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n * <p>\n * http://www.apache.org/licenses/LICENSE-2.0\n * <p>\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.hadoop.ozone.container.replication;\n\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentHashMap.KeySetView;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\nimport com.google.common.util.concurrent.ThreadFactoryBuilder;\nimport org.apache.hadoop.ozone.container.common.impl.ContainerSet;\nimport org.apache.hadoop.ozone.container.replication.ReplicationTask.Status;\n\nimport com.google.common.annotations.VisibleForTesting;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Single point to schedule the downloading tasks based on priorities.\n */\n<fim_suffix>public class ReplicationSupervisor {\n\n  private static final Logger LOG =\n      LoggerFactory.getLogger(ReplicationSupervisor.class);\n\n  private final ContainerSet containerSet;\n  private final ContainerReplicator replicator;\n  private final ThreadPoolExecutor executor;\n\n  /**\n   * A set of container IDs that are currently being downloaded\n   * or queued for download. Tracked so we don't schedule > 1\n   * concurrent download for the same container.\n   */\n  private final KeySetView<Object, Boolean> containersInFlight;\n\n  public ReplicationSupervisor(\n      ContainerSet containerSet,\n      ContainerReplicator replicator, int poolSize) {\n    this.containerSet = containerSet;\n    this.replicator = replicator;\n    this.containersInFlight = ConcurrentHashMap.newKeySet();\n    this.executor = new ThreadPoolExecutor(\n        0, poolSize, 60, TimeUnit.SECONDS,\n        new LinkedBlockingQueue<>(),\n        new ThreadFactoryBuilder().setDaemon(true)\n            .setNameFormat(\"ContainerReplicationThread-%d\")\n            .build());\n  }\n\n  /**\n   * Queue an asynchronous download of the given container.\n   */\n  public void addTask(ReplicationTask task) {\n    if (containersInFlight.add(task.getContainerId())) {\n      executor.submit(new TaskRunner(task));\n    }\n  }\n\n  public void stop() {\n    try {\n      executor.shutdown();\n      if (!executor.awaitTermination(3, TimeUnit.SECONDS)) {\n        executor.shutdownNow();\n      }\n    } catch (InterruptedException ie) {\n      // Ignore, we don't really care about the failure.\n      Thread.currentThread().interrupt();\n    }\n  }\n\n  /**\n   * Get the number of containers currently being downloaded\n   * or scheduled for download.\n   * @return Count of in-flight replications.\n   */\n  @VisibleForTesting\n  public int getInFlightReplications() {\n    return containersInFlight.size();\n  }\n\n  private final class TaskRunner implements Runnable {\n    private final ReplicationTask task;\n\n    private TaskRunner(ReplicationTask task) {\n      this.task = task;\n    }\n\n    @Override\n    public void run() {\n      try {\n        if (containerSet.getContainer(task.getContainerId()) != null) {\n          LOG.debug(\"Container {} has already been downloaded.\",\n              task.getContainerId());\n          return;\n        }\n\n        task.setStatus(Status.DOWNLOADING);\n        replicator.replicate(task);\n\n        if (task.getStatus() == Status.FAILED) {\n          LOG.error(\n              \"Container {} can't be downloaded from any of the datanodes.\",\n              task.getContainerId());\n        } else if (task.getStatus() == Status.DONE) {\n          LOG.info(\"Container {} is replicated.\", task.getContainerId());\n        }\n      } finally {\n        containersInFlight.remove(task.getContainerId());\n      }\n    }\n  }\n}<fim_middle>// class below has no smell\n"}