{"text": "<fim_prefix>            long totalSpan = 0;\n            diffs = new int[n];\n            for (int i = 0; i < n; i++) {\n                View v = getView(i);\n                int tmp;\n                if (desiredAdjustment < 0) {\n                    tmp = (int)v.getMinimumSpan(axis);\n                    diffs[i] = spans[i] - tmp;\n                } else {\n                    tmp = (int)v.getMaximumSpan(axis);\n                    diffs[i] = tmp - spans[i];\n                }\n                totalSpan += tmp;\n            }\n            float maximumAdjustment = Math.abs(totalSpan - preferred);\n                adjustmentFactor = desiredAdjustment / maximumAdjustment;\n                adjustmentFactor = Math.min(adjustmentFactor, 1.0f);\n                adjustmentFactor = Math.max(adjustmentFactor, -1.0f);\n            }\n        // make the adjustments\n        int totalOffset = 0;\n        for (int i = 0; i < n; i++) {\n            offsets[i] = totalOffset;\n            if (desiredAdjustment != 0) {\n                float adjF = adjustmentFactor * diffs[i];\n                spans[i] += Math.round(adjF);\n            }\n            totalOffset = (int) Math.min((long) totalOffset + (long) spans[i], Integer.MAX_VALUE);\n        }\n    }\n    /**\n     * Performs layout for the minor axis of the box (i.e. the\n     * axis orthogonal to the axis that it represents). The results\n     * of the layout (the offset and span for each children) are\n     * placed in the given arrays which represent the allocations to\n     * the children along the minor axis.\n     *\n     * @param targetSpan the total span given to the view, which\n     *  would be used to layout the children\n     * @param axis the axis being layed out\n     * @param offsets the offsets from the origin of the view for\n     *  each of the child views; this is a return value and is\n     *  filled in by the implementation of this method\n     * @param spans the span of each child view; this is a return\n     *  value and is filled in by the implementation of this method\n     */\n    protected void layoutMinorAxis(int targetSpan, int axis, int[] offsets, int[] spans) {\n        int n = getViewCount();\n        for (int i = 0; i < n; i++) {\n            View v = getView(i);\n            int max = (int) v.getMaximumSpan(axis);\n            if (max < targetSpan) {\n                // can't make the child this wide, align it\n                float align = v.getAlignment(axis);\n                offsets[i] = (int) ((targetSpan - max) * align);\n                spans[i] = max;\n            } else {\n                // make it the target width, or as small as it can get.\n                int min = (int)v.getMinimumSpan(axis);\n                offsets[i] = 0;\n                spans[i] = Math.max(min, targetSpan);\n            }\n        }\n    }\n    /**\n     * Calculates the size requirements for the major axis\n     * <code>axis</code>.\n     *\n     * @param axis the axis being studied\n     * @param r the <code>SizeRequirements</code> object;\n     *          if <code>null</code> one will be created\n     * @return the newly initialized <code>SizeRequirements</code> object\n     * @see javax.swing.SizeRequirements\n     */\n    protected SizeRequirements calculateMajorAxisRequirements(int axis, SizeRequirements r) {\n        // calculate tiled request\n        float min = 0;\n        float pref = 0;\n        float max = 0;\n        int n = getViewCount();\n        for (int i = 0; i < n; i++) {\n            View v = getView(i);\n            min += v.getMinimumSpan(axis);\n            pref += v.getPreferredSpan(axis);\n            max += v.getMaximumSpan(axis);\n        }\n        if (r == null) {\n            r = new SizeRequirements();\n        }\n        r.alignment = 0.5f;\n        r.minimum = (int) min;\n        r.preferred = (int) pref;\n        r.maximum = (int) max;\n        return r;\n    }\n    /**\n     * Calculates the size requirements for the minor axis\n     * <code>axis</code>.\n     *\n     * @param axis the axis being studied\n     * @param r the <code>SizeRequirements</code> object;\n     *          if <code>null</code> one will be created\n     * @return the newly initialized <code>SizeRequirements</code> object\n     * @see javax.swing.SizeRequirements\n     */\n    protected SizeRequirements calculateMinorAxisRequirements(int axis, SizeRequirements r) {\n        int min = 0;\n        long pref = 0;\n        int max = Integer.MAX_VALUE;\n        int n = getViewCount();\n        for (int i = 0; i < n; i++) {\n            View v = getView(i);\n            min = Math.max((int) v.getMinimumSpan(axis), min);\n            pref = Math.max((int) v.getPreferredSpan(axis), pref);\n            max = Math.max((int) v.getMaximumSpan(axis), max);\n        }\n        if (r == null) {\n            r = new SizeRequirements();\n            r.alignment = 0.5f;\n        }\n        r.preferred = (int) pref;\n        r.minimum = min;\n        r.maximum = max;\n        return r;\n    }\n    /**\n     * Checks the request cache and update if needed.\n     * @param axis the axis being studied\n     * @exception IllegalArgumentException if <code>axis</code> is\n     *  neither <code>View.X_AXIS</code> nor <code>View.Y_AXIS</code>\n     */\n    void checkRequests(int axis) {\n        if ((axis != X_AXIS) && (axis != Y_AXIS)) {\n            throw new IllegalArgumentException(\"Invalid axis: \" + axis);\n        }\n        if (axis == majorAxis) {\n            if (!majorReqValid) {\n                majorRequest = calculateMajorAxisRequirements(axis,\n                                                              majorRequest);\n                majorReqValid = true;\n            }\n        } else if (! minorReqValid) {\n            minorRequest = calculateMinorAxisRequirements(axis, minorRequest);\n            minorReqValid = true;\n        }\n    }\n    /**\n     * Computes the location and extent of each child view\n     * in this <code>BoxView</code> given the <code>targetSpan</code>,\n     * which is the width (or height) of the region we have to\n     * work with.\n     *\n     * @param targetSpan the total span given to the view, which\n     *  would be used to layout the children\n     * @param axis the axis being studied, either\n     *          <code>View.X_AXIS</code> or <code>View.Y_AXIS</code>\n     * @param offsets an empty array filled by this method with\n     *          values specifying the location  of each child view\n     * @param spans  an empty array filled by this method with\n     *          values specifying the extent of each child view\n     */\n<fim_suffix>    protected void baselineLayout(int targetSpan, int axis, int[] offsets, int[] spans) {\n        int totalAscent = (int)(targetSpan * getAlignment(axis));\n        int totalDescent = targetSpan - totalAscent;\n        int n = getViewCount();\n        for (int i = 0; i < n; i++) {\n            View v = getView(i);\n            float align = v.getAlignment(axis);\n            float viewSpan;\n            if (v.getResizeWeight(axis) > 0) {\n                // if resizable then resize to the best fit\n                // the smallest span possible\n                float minSpan = v.getMinimumSpan(axis);\n                // the largest span possible\n                float maxSpan = v.getMaximumSpan(axis);\n                if (align == 0.0f) {\n                    // if the alignment is 0 then we need to fit into the descent\n                    viewSpan = Math.max(Math.min(maxSpan, totalDescent), minSpan);\n                } else if (align == 1.0f) {\n                    // if the alignment is 1 then we need to fit into the ascent\n                    viewSpan = Math.max(Math.min(maxSpan, totalAscent), minSpan);\n                } else {\n                    // figure out the span that we must fit into\n                    float fitSpan = Math.min(totalAscent / align,\n                                             totalDescent / (1.0f - align));\n                    // fit into the calculated span\n                    viewSpan = Math.max(Math.min(maxSpan, fitSpan), minSpan);\n                }\n            } else {\n                // otherwise use the preferred spans\n                viewSpan = v.getPreferredSpan(axis);\n            }\n            offsets[i] = totalAscent - (int)(viewSpan * align);\n            spans[i] = (int)viewSpan;\n        }\n    }<fim_middle>// function below is long method\n"}