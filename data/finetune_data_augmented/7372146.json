{"text": "<fim_prefix>\t\tAssert.isTrue(image.exists(), \"Image must exist\");\n\t\tthis.image = image;\n\t}\n\t@Override\n\tpublic void printBanner(Environment environment, Class<?> sourceClass,\n\t\t\tPrintStream out) {\n\t\tString headless = System.getProperty(\"java.awt.headless\");\n\t\ttry {\n\t\t\tSystem.setProperty(\"java.awt.headless\", \"true\");\n\t\t\tprintBanner(environment, out);\n\t\t}\n\t\tcatch (Throwable ex) {\n\t\t\tlogger.warn(\"Image banner not printable: \" + this.image + \" (\" + ex.getClass()\n\t\t\t\t\t+ \": '\" + ex.getMessage() + \"')\");\n\t\t\tlogger.debug(\"Image banner printing failure\", ex);\n\t\t}\n\t\tfinally {\n\t\t\tif (headless == null) {\n\t\t\t\tSystem.clearProperty(\"java.awt.headless\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.setProperty(\"java.awt.headless\", headless);\n\t\t\t}\n\t\t}\n\t}\n\tprivate void printBanner(Environment environment, PrintStream out)\n\t\t\tthrows IOException {\n\t\tint width = getProperty(environment, \"width\", Integer.class, 76);\n\t\tint height = getProperty(environment, \"height\", Integer.class, 0);\n\t\tint margin = getProperty(environment, \"margin\", Integer.class, 2);\n\t\tboolean invert = getProperty(environment, \"invert\", Boolean.class, false);\n\t\tFrame[] frames = readFrames(width, height);\n\t\tfor (int i = 0; i < frames.length; i++) {\n\t\t\tif (i > 0) {\n\t\t\t\tresetCursor(frames[i - 1].getImage(), out);\n\t\t\t}\n\t\t\tprintBanner(frames[i].getImage(), margin, invert, out);\n\t\t\tsleep(frames[i].getDelayTime());\n\t\t}\n\t}\n\tprivate <T> T getProperty(Environment environment, String name, Class<T> targetType,\n\t\t\tT defaultValue) {\n\t\treturn environment.getProperty(PROPERTY_PREFIX + name, targetType, defaultValue);\n\t}\n\tprivate Frame[] readFrames(int width, int height) throws IOException {\n\t\ttry (InputStream inputStream = this.image.getInputStream()) {\n\t\t\ttry (ImageInputStream imageStream = ImageIO\n\t\t\t\t\t.createImageInputStream(inputStream)) {\n\t\t\t\treturn readFrames(width, height, imageStream);\n\t\t\t}\n\t\t}\n\t}\n\tprivate Frame[] readFrames(int width, int height, ImageInputStream stream)\n\t\t\tthrows IOException {\n\t\tIterator<ImageReader> readers = ImageIO.getImageReaders(stream);\n\t\tAssert.state(readers.hasNext(), \"Unable to read image banner source\");\n\t\tImageReader reader = readers.next();\n\t\ttry {\n\t\t\tImageReadParam readParam = reader.getDefaultReadParam();\n\t\t\treader.setInput(stream);\n\t\t\tint frameCount = reader.getNumImages(true);\n\t\t\tFrame[] frames = new Frame[frameCount];\n\t\t\tfor (int i = 0; i < frameCount; i++) {\n\t\t\t\tframes[i] = readFrame(width, height, reader, i, readParam);\n\t\t\t}\n\t\t\treturn frames;\n\t\t}\n\t\tfinally {\n\t\t\treader.dispose();\n\t\t}\n\t}\n\tprivate Frame readFrame(int width, int height, ImageReader reader, int imageIndex,\n\t\t\tImageReadParam readParam) throws IOException {\n\t\tBufferedImage image = reader.read(imageIndex, readParam);\n\t\tBufferedImage resized = resizeImage(image, width, height);\n\t\tint delayTime = getDelayTime(reader, imageIndex);\n\t\treturn new Frame(resized, delayTime);\n\t}\n\tprivate int getDelayTime(ImageReader reader, int imageIndex) throws IOException {\n\t\tIIOMetadata metadata = reader.getImageMetadata(imageIndex);\n\t\tIIOMetadataNode root = (IIOMetadataNode) metadata\n\t\t\t\t.getAsTree(metadata.getNativeMetadataFormatName());\n\t\tIIOMetadataNode extension = findNode(root, \"GraphicControlExtension\");\n\t\tString attribute = (extension != null) ? extension.getAttribute(\"delayTime\")\n\t\t\t\t: null;\n\t\treturn (attribute != null) ? Integer.parseInt(attribute) * 10 : 0;\n\t}\n\tprivate static IIOMetadataNode findNode(IIOMetadataNode rootNode, String nodeName) {\n\t\tif (rootNode == null) {\n\t\t\treturn null;\n\t\t}\n\t\tfor (int i = 0; i < rootNode.getLength(); i++) {\n\t\t\tif (rootNode.item(i).getNodeName().equalsIgnoreCase(nodeName)) {\n\t\t\t\treturn ((IIOMetadataNode) rootNode.item(i));\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\tprivate BufferedImage resizeImage(BufferedImage image, int width, int height) {\n\t\tif (width < 1) {\n\t\t\twidth = 1;\n\t\t}\n\t\tif (height <= 0) {\n\t\t\tdouble aspectRatio = (double) width / image.getWidth() * 0.5;\n\t\t\theight = (int) Math.ceil(image.getHeight() * aspectRatio);\n\t\t}\n\t\tBufferedImage resized = new BufferedImage(width, height,\n\t\t\t\tBufferedImage.TYPE_INT_RGB);\n\t\tImage scaled = image.getScaledInstance(width, height, Image.SCALE_DEFAULT);\n\t\tresized.getGraphics().drawImage(scaled, 0, 0, null);\n\t\treturn resized;\n\t}\n\tprivate void resetCursor(BufferedImage image, PrintStream out) {\n\t\tint lines = image.getHeight() + 3;\n\t\tout.print(\"\\033[\" + lines + \"A\\r\");\n\t}\n\tprivate void printBanner(BufferedImage image, int margin, boolean invert,\n\t\t\tPrintStream out) {\n\t\tAnsiElement background = invert ? AnsiBackground.BLACK : AnsiBackground.DEFAULT;\n\t\tout.print(AnsiOutput.encode(AnsiColor.DEFAULT));\n\t\tout.print(AnsiOutput.encode(background));\n\t\tout.println();\n\t\tout.println();\n\t\tAnsiColor lastColor = AnsiColor.DEFAULT;\n\t\tfor (int y = 0; y < image.getHeight(); y++) {\n\t\t\tfor (int i = 0; i < margin; i++) {\n\t\t\t\tout.print(\" \");\n\t\t\t}\n\t\t\tfor (int x = 0; x < image.getWidth(); x++) {\n\t\t\t\tColor color = new Color(image.getRGB(x, y), false);\n\t\t\t\tAnsiColor ansiColor = AnsiColors.getClosest(color);\n\t\t\t\tif (ansiColor != lastColor) {\n\t\t\t\t\tout.print(AnsiOutput.encode(ansiColor));\n\t\t\t\t\tlastColor = ansiColor;\n\t\t\t\t}\n\t\t\t\tout.print(getAsciiPixel(color, invert));\n\t\t\t}\n\t\t\tout.println();\n\t\t}\n\t\tout.print(AnsiOutput.encode(AnsiColor.DEFAULT));\n\t\tout.print(AnsiOutput.encode(AnsiBackground.DEFAULT));\n\t\tout.println();\n\t}\n\tprivate char getAsciiPixel(Color color, boolean dark) {\n\t\tdouble luminance = getLuminance(color, dark);\n\t\tfor (int i = 0; i < PIXEL.length; i++) {\n\t\t\tif (luminance >= (LUMINANCE_START - (i * LUMINANCE_INCREMENT))) {\n\t\t\t\treturn PIXEL[i];\n\t\t\t}\n\t\t}\n\t\treturn PIXEL[PIXEL.length - 1];\n\t}\n\tprivate int getLuminance(Color color, boolean inverse) {\n\t\tdouble luminance = 0.0;\n\t\tluminance += getLuminance(color.getRed(), inverse, RGB_WEIGHT[0]);\n\t\tluminance += getLuminance(color.getGreen(), inverse, RGB_WEIGHT[1]);\n\t\tluminance += getLuminance(color.getBlue(), inverse, RGB_WEIGHT[2]);\n\t\treturn (int) Math.ceil((luminance / 0xFF) * 100);\n\t}\n\tprivate double getLuminance(int component, boolean inverse, double weight) {\n\t\treturn (inverse ? 0xFF - component : component) * weight;\n\t}\n\tprivate void sleep(int delay) {\n\t\ttry {\n\t\t\tThread.sleep(delay);\n\t\t}\n\t\tcatch (InterruptedException ex) {\n\t\t\tThread.currentThread().interrupt();\n\t\t}\n\t}\n<fim_suffix>\tprivate static class Frame {\n\t\tprivate final BufferedImage image;\n\t\tprivate final int delayTime;\n\t\tFrame(BufferedImage image, int delayTime) {\n\t\t\tthis.image = image;\n\t\t\tthis.delayTime = delayTime;\n\t\t}\n\t\tpublic BufferedImage getImage() {\n\t\t\treturn this.image;\n\t\t}\n\t\tpublic int getDelayTime() {\n\t\t\treturn this.delayTime;\n\t\t}\n\t}<fim_middle>// class below has no smell\n"}