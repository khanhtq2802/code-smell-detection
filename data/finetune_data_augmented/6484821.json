{"text": "<fim_prefix>/*******************************************************************************\n * Copyright (c) 2001, 2014 IBM Corp. and others\n *\n * This program and the accompanying materials are made available under\n * the terms of the Eclipse Public License 2.0 which accompanies this\n * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n * or the Apache License, Version 2.0 which accompanies this distribution and\n * is available at https://www.apache.org/licenses/LICENSE-2.0.\n *\n * This Source Code may also be made available under the following\n * Secondary Licenses when the conditions for such availability set\n * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n * General Public License, version 2 with the GNU Classpath\n * Exception [1] and GNU General Public License, version 2 with the\n * OpenJDK Assembly Exception [2].\n *\n * [1] https://www.gnu.org/software/classpath/license.html\n * [2] http://openjdk.java.net/legal/assembly-exception.html\n *\n * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n *******************************************************************************/\npackage com.ibm.j9ddr.vm29.j9;\n\nimport static com.ibm.j9ddr.vm29.structure.J9Consts.J9_STACKWALK_ITERATE_O_SLOTS;\nimport static com.ibm.j9ddr.vm29.structure.J9Consts.J9_STACKWALK_SKIP_INLINES;\nimport static com.ibm.j9ddr.vm29.structure.J9Consts.J9_STACKWALK_ITERATE_METHOD_CLASS_SLOTS;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\nimport com.ibm.j9ddr.CorruptDataException;\nimport com.ibm.j9ddr.vm29.j9.gc.GCIterator;\nimport com.ibm.j9ddr.vm29.j9.gc.GCVMThreadListIterator;\nimport com.ibm.j9ddr.vm29.j9.stackwalker.FrameCallbackResult;\nimport com.ibm.j9ddr.vm29.j9.stackwalker.StackWalkResult;\nimport com.ibm.j9ddr.vm29.j9.stackwalker.StackWalker;\nimport com.ibm.j9ddr.vm29.j9.stackwalker.WalkState;\nimport com.ibm.j9ddr.vm29.pointer.ObjectReferencePointer;\nimport com.ibm.j9ddr.vm29.pointer.PointerPointer;\nimport com.ibm.j9ddr.vm29.pointer.VoidPointer;\nimport com.ibm.j9ddr.vm29.pointer.generated.J9ObjectPointer;\nimport com.ibm.j9ddr.vm29.pointer.generated.J9VMThreadPointer;\nimport com.ibm.j9ddr.vm29.j9.stackwalker.IStackWalkerCallbacks;\n\n<fim_suffix>public class StackRoots \n{\n\n\tprivate ArrayList<J9ObjectPointer> _allStackRoots = new ArrayList<J9ObjectPointer>();\n\tprivate ArrayList<VoidPointer> _allAddresses = new ArrayList<VoidPointer>();\n\tprivate static StackRoots _singleton;\n\n\tprivate class StackWalkerCallbacks implements IStackWalkerCallbacks\n\t{\n\t\tpublic FrameCallbackResult frameWalkFunction(J9VMThreadPointer walkThread, WalkState walkState)\n\t\t{\n\t\t\treturn FrameCallbackResult.KEEP_ITERATING;\n\t\t}\n\t\n\t\tpublic void objectSlotWalkFunction(J9VMThreadPointer walkThread, WalkState walkState, PointerPointer objectSlot, VoidPointer stackAddress)\n\t\t{\n\t\t\tif (walkState.method.isNull()){\n\t\t\t\t/* adding an object slot iterator causes us to be called for\n\t\t\t\t * xxx methods. These were previously ignored, since the frame\n\t\t\t\t *does not have a valid method. We should continue to do so now.\n\t\t\t\t */\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\ttry {\n\t\t\t\tJ9ObjectPointer object = J9ObjectPointer.cast(objectSlot.at(0));\n\t\t\t\tif (object.notNull()) {\n\t\t\t\t\t_allStackRoots.add(object);\n\t\t\t\t\t_allAddresses.add(VoidPointer.cast(objectSlot));\n\t\t\t\t}\n\t\t\t} catch (CorruptDataException e) {\n\t\t\t\tthrow new UnsupportedOperationException(\"Corrupt objectSlot detected\");\n\t\t\t}\n\t\t}\n\t\t\n\t\n\t\tpublic void fieldSlotWalkFunction(J9VMThreadPointer walkThread,\n\t\t\t\tWalkState walkState, ObjectReferencePointer objectSlot,\n\t\t\t\tVoidPointer stackLocation)\n\t\t{\n\t\t\tif (walkState.method.isNull()){\n\t\t\t\t/* adding an object slot iterator causes us to be called for\n\t\t\t\t * xxx methods. These were previously ignored, since the frame\n\t\t\t\t *does not have a valid method. We should continue to do so now.\n\t\t\t\t */\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\ttry {\n\t\t\t\tJ9ObjectPointer object = objectSlot.at(0);\n\t\t\t\tif (object.notNull()) {\n\t\t\t\t\t_allStackRoots.add(object);\n\t\t\t\t\t_allAddresses.add(VoidPointer.cast(objectSlot));\n\t\t\t\t}\n\t\t\t} catch (CorruptDataException e) {\n\t\t\t\tthrow new UnsupportedOperationException(\"Corrupt objectSlot detected\");\n\t\t\t}\n\t\n\t\t}\n\t\n\t}\n\t\n\tprivate StackRoots() throws CorruptDataException\n\t{\n\t\t_allStackRoots = new ArrayList<J9ObjectPointer>();\n\t\t_allAddresses = new ArrayList<VoidPointer>();\n\t\twalkStacks();\n\t}\n\t\n\tpublic static StackRoots from() throws CorruptDataException \n\t{\n\t\tif (null != _singleton) {\n\t\t\treturn _singleton;\n\t\t}\n\n\t\t_singleton = new StackRoots();\n\t\treturn _singleton;\n\t}\n\n\t\n\tprivate void walkStacks() throws CorruptDataException\n\t{\t\t\n\t\tGCVMThreadListIterator threadIterator = GCVMThreadListIterator.from();\n\n\t\twhile (threadIterator.hasNext()) {\n\t\t\tJ9VMThreadPointer next = threadIterator.next();\n\t\t\t\n\t\t\tWalkState walkState = new WalkState();\n\t\t\twalkState.walkThread = next;\n\t\t\twalkState.flags = J9_STACKWALK_SKIP_INLINES | J9_STACKWALK_ITERATE_O_SLOTS | J9_STACKWALK_ITERATE_METHOD_CLASS_SLOTS;\n\t\t\t\n\n\t\t\twalkState.callBacks = new StackWalkerCallbacks(); \t\t\n\t\t\tStackWalkResult result = StackWalkResult.STACK_CORRUPT;\n\t\t\tresult = StackWalker.walkStackFrames(walkState);\n\t\t\t\n\t\t\tif (StackWalkResult.NONE != result) {\n\t\t\t\tthrow new UnsupportedOperationException(\"Failed to walk stack\");\n\t\t\t}\t\t\t\t\t\t\n\t\t}\n\t}\n\t\n\tpublic static ArrayList<J9ObjectPointer> allRoots() throws CorruptDataException\t\n\t{\n\t\tStackRoots stackRoots= new StackRoots();\n\t\treturn stackRoots._allStackRoots;\n\t}\n\t\n\tpublic static GCIterator stackRootIterator() throws CorruptDataException\n\t{\n\t\tfinal StackRoots stackRootSet = StackRoots.from();\n\t\tfinal Iterator<J9ObjectPointer> rootSetIterator = stackRootSet._allStackRoots.iterator();\n\t\tfinal Iterator<VoidPointer> rootSetAddressIterator = stackRootSet._allAddresses.iterator();\n\t\t\n\t\treturn new GCIterator() {\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn rootSetIterator.hasNext();\n\t\t\t}\n\n\t\t\tpublic VoidPointer nextAddress() {\n\t\t\t\trootSetIterator.next();\n\t\t\t\treturn rootSetAddressIterator.next();\n\t\t\t}\n\n\t\t\tpublic Object next() {\n\t\t\t\trootSetAddressIterator.next();\n\t\t\t\treturn rootSetIterator.next(); \n\t\t\t}\n\t\t};\n\t\t\n\t}\n\t\n}<fim_middle>// class below has no smell\n"}