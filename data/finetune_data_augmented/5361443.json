{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.apache.openejb.client;\nimport java.lang.reflect.Constructor;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.EnumSet;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\n/**\n * The purpose of this class is to provide a more strongly typed version of a\n * java.util.Properties object. So far it is a read only view of the properties\n * and does not set data into the underlying Properties instance.\n * <p/>\n * Similar to java.util.Properties it will delegate to a \"parent\" instance when\n * a property is not found.  If a property is found but its value cannot be parsed\n * as the desired data type, the parent's value is used.\n * <p/>\n * By default this object will log nothing, but if a Log implementation is set the\n * Options class will log three kinds of statements:\n * <p/>\n * - When a property is not found: the property name and default value in use along\n * with all possible values (enums only). Debug level.\n * - When a property is found: the property name and value.  Info level.\n * - When a property value cannot be parsed: the property name and invalid value. Warn level.\n * <p/>\n * Logging the user supplied values onto INFO is really nice as it shows up in the standard\n * log output and allows us to easily see which values the user has changed from the default.\n * It's rather impossible to diagnose issues without this information.\n * <p/>\n * ENUM SETS:\n * <p/>\n * Properties that accept a Set of enum values automatically accept ALL and NONE in\n * addition to the explicitly created enum items.\n * <p/>\n * Using ALL. This allows users to have an easy way to imply \"all\" without having to\n * hardcode an the entire list of enum items and protects against the case where that\n * list may grow in the future.\n * <p/>\n * Using NONE.  This allows users an alternative to using an empty string when explicitly\n * specifying that none of the options should be used.\n * <p/>\n * In the internal code, this allows us to have these concepts in all enum options\n * without us having to add NONE or ALL enum items explicitly which leads to strange code.\n * <p/>\n * Additionally TRUE is an alias for ALL and FALSE an alias for NONE.  This allows options\n * that used to support only true/false values to be further defined in the future without\n * breaking compatibility.\n *\n * @version $Rev$ $Date$\n */\npublic class Options {\n    private final Options parent;\n    private final Properties properties;\n    public Options(final Properties properties) {\n        this(properties, new NullOptions());\n    }\n    public Options(final Properties properties, final Options parent) {\n        this.parent = parent;\n        this.properties = properties;\n    }\n    public Properties getProperties() {\n        return properties;\n    }\n    public void setLogger(final Log logger) {\n        parent.setLogger(logger);\n    }\n    public Log getLogger() {\n        return parent.getLogger();\n    }\n    public boolean has(final String property) {\n        return properties.containsKey(property) || parent.has(property);\n    }\n    public String get(final String property, final String defaultValue) {\n        final String value = properties.getProperty(property);\n        return value != null ? log(property, value) : parent.get(property, defaultValue);\n    }\n    @SuppressWarnings(\"unchecked\")\n    public <T> T get(final String property, final T defaultValue) {\n        if (defaultValue == null)\n            throw new NullPointerException(\"defaultValue\");\n        final String value = properties.getProperty(property);\n        if (value == null || value.equals(\"\"))\n            return parent.get(property, defaultValue);\n        try {\n            final Class<?> type = defaultValue.getClass();\n            final Constructor<?> constructor = type.getConstructor(String.class);\n            final T t = (T) constructor.newInstance(value);\n            return log(property, t);\n        } catch (Exception e) {\n            e.printStackTrace();\n            warn(property, value, e);\n            return parent.get(property, defaultValue);\n        }\n    }\n    public int get(final String property, final int defaultValue) {\n        final String value = properties.getProperty(property);\n        if (value == null || value.equals(\"\"))\n            return parent.get(property, defaultValue);\n        try {\n            return log(property, Integer.parseInt(value));\n        } catch (NumberFormatException e) {\n            warn(property, value, e);\n            return parent.get(property, defaultValue);\n        }\n    }\n    public long get(final String property, final long defaultValue) {\n        final String value = properties.getProperty(property);\n        if (value == null || value.equals(\"\"))\n            return parent.get(property, defaultValue);\n        try {\n            return log(property, Long.parseLong(value));\n        } catch (NumberFormatException e) {\n            warn(property, value, e);\n            return parent.get(property, defaultValue);\n        }\n    }\n    public boolean get(final String property, final boolean defaultValue) {\n        final String value = properties.getProperty(property);\n        if (value == null || value.equals(\"\"))\n            return parent.get(property, defaultValue);\n        try {\n            return log(property, Boolean.parseBoolean(value));\n        } catch (NumberFormatException e) {\n            warn(property, value, e);\n            return parent.get(property, defaultValue);\n        }\n    }\n    public Class get(final String property, final Class defaultValue) {\n        final String className = properties.getProperty(property);\n        if (className == null)\n            return parent.get(property, defaultValue);\n        final ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n        try {\n            return log(property, classLoader.loadClass(className));\n        } catch (Exception e) {\n            getLogger().warning(\"Could not load \" + property + \" : \" + className, e);\n            return parent.get(property, defaultValue);\n        }\n    }\n<fim_suffix>    @SuppressWarnings(\"unchecked\")\n    public <T extends Enum<T>> T get(final String property, final T defaultValue) {\n        final String value = properties.getProperty(property);\n        if (value == null || value.equals(\"\"))\n            return parent.get(property, defaultValue);\n        if (defaultValue == null)\n            throw new IllegalArgumentException(\"Must supply a default for property \" + property);\n        final Class<T> enumType = (Class<T>) defaultValue.getClass();\n        try {\n            return log(property, valueOf(enumType, value.toUpperCase()));\n        } catch (IllegalArgumentException e) {\n            warn(property, value);\n            return parent.get(property, defaultValue);\n        }\n    }\n    public <T extends Enum<T>> Set<T> getAll(final String property, final T... defaultValue) {\n        final EnumSet<T> defaults = EnumSet.copyOf(Arrays.asList(defaultValue));\n        return getAll(property, defaults);\n    }\n    @SuppressWarnings(\"unchecked\")\n    public <T extends Enum<T>> Set<T> getAll(final String property, final Set<T> defaultValue) {\n        final Class<T> enumType;\n        try {\n            final T t = defaultValue.iterator().next();\n            enumType = (Class<T>) t.getClass();\n        } catch (Exception e) {\n            throw new IllegalArgumentException(\"Must supply a default for property \" + property);\n        }\n        return getAll(property, defaultValue, enumType);\n    }\n    @SuppressWarnings(\"unchecked\")\n    public <T extends Enum<T>> Set<T> getAll(final String property, final Class<T> enumType) {\n        return getAll(property, Collections.EMPTY_SET, enumType);\n    }\n    protected <T extends Enum<T>> Set<T> getAll(final String property, final Set<T> defaultValue, final Class<T> enumType) {\n        final String value = properties.getProperty(property);\n        if (value == null || value.equals(\"\"))\n            return parent.getAll(property, defaultValue, enumType);\n        // Shorthand for specifying ALL or NONE for any option\n        // that allows for multiple values of the enum\n        if (\"all\".equalsIgnoreCase(value) || \"true\".equalsIgnoreCase(value)) {\n            log(property, value);\n            return EnumSet.allOf(enumType);<fim_middle>// function below has no smell\n"}