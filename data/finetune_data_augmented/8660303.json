{"text": "<fim_prefix> * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.ignite.internal.cluster;\nimport java.io.Externalizable;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.ObjectInput;\nimport java.io.ObjectOutput;\nimport java.io.ObjectStreamException;\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport org.apache.ignite.IgniteCheckedException;\nimport org.apache.ignite.IgniteCluster;\nimport org.apache.ignite.IgniteException;\nimport org.apache.ignite.cluster.BaselineNode;\nimport org.apache.ignite.cluster.ClusterGroup;\nimport org.apache.ignite.cluster.ClusterGroupEmptyException;\nimport org.apache.ignite.cluster.ClusterNode;\nimport org.apache.ignite.cluster.ClusterStartNodeResult;\nimport org.apache.ignite.configuration.IgniteConfiguration;\nimport org.apache.ignite.internal.GridKernalContext;\nimport org.apache.ignite.internal.IgniteComponentType;\nimport org.apache.ignite.internal.IgniteInternalFuture;\nimport org.apache.ignite.internal.managers.discovery.DiscoCache;\nimport org.apache.ignite.internal.processors.cluster.BaselineTopology;\nimport org.apache.ignite.internal.util.future.GridCompoundFuture;\nimport org.apache.ignite.internal.util.future.GridFinishedFuture;\nimport org.apache.ignite.internal.util.future.GridFutureAdapter;\nimport org.apache.ignite.internal.util.future.IgniteFutureImpl;\nimport org.apache.ignite.internal.util.nodestart.IgniteRemoteStartSpecification;\nimport org.apache.ignite.internal.util.nodestart.IgniteSshHelper;\nimport org.apache.ignite.internal.util.nodestart.StartNodeCallable;\nimport org.apache.ignite.internal.util.tostring.GridToStringExclude;\nimport org.apache.ignite.internal.util.typedef.CI1;\nimport org.apache.ignite.internal.util.typedef.F;\nimport org.apache.ignite.internal.util.typedef.internal.A;\nimport org.apache.ignite.internal.util.typedef.internal.CU;\nimport org.apache.ignite.internal.util.typedef.internal.SB;\nimport org.apache.ignite.internal.util.typedef.internal.U;\nimport org.apache.ignite.lang.IgniteBiTuple;\nimport org.apache.ignite.lang.IgniteFuture;\nimport org.apache.ignite.lang.IgnitePredicate;\nimport org.apache.ignite.lang.IgniteProductVersion;\nimport org.jetbrains.annotations.Nullable;\nimport static org.apache.ignite.internal.IgniteNodeAttributes.ATTR_IPS;\nimport static org.apache.ignite.internal.IgniteNodeAttributes.ATTR_MACS;\nimport static org.apache.ignite.internal.util.nodestart.IgniteNodeStartUtils.parseFile;\nimport static org.apache.ignite.internal.util.nodestart.IgniteNodeStartUtils.specifications;\n/**\n *\n */\npublic class IgniteClusterImpl extends ClusterGroupAdapter implements IgniteClusterEx, Externalizable {\n    /** */\n    private static final long serialVersionUID = 0L;\n    /** */\n    private IgniteConfiguration cfg;\n    /** Node local store. */\n    @GridToStringExclude\n    private ConcurrentMap nodeLoc;\n    /** Client reconnect future. */\n    private IgniteFuture<?> reconnecFut;\n    /** Minimal IgniteProductVersion supporting BaselineTopology */\n    private static final IgniteProductVersion MIN_BLT_SUPPORTING_VER = IgniteProductVersion.fromString(\"2.4.0\");\n    /** Distributed baseline configuration. */\n    private DistributedBaselineConfiguration distributedBaselineConfiguration;\n    /**\n     * Required by {@link Externalizable}.\n     */\n    public IgniteClusterImpl() {\n        // No-op.\n    }\n    /**\n     * @param ctx Kernal context.\n     */\n    public IgniteClusterImpl(GridKernalContext ctx) {\n        super(ctx, null, (IgnitePredicate<ClusterNode>)null);\n        cfg = ctx.config();\n        nodeLoc = new ClusterNodeLocalMapImpl(ctx);\n        distributedBaselineConfiguration = new DistributedBaselineConfiguration(\n            cfg, ctx.internalSubscriptionProcessor(), ctx.log(DistributedBaselineConfiguration.class)\n        );\n    }\n    /** {@inheritDoc} */\n    @Override public ClusterGroup forLocal() {\n        guard();\n        try {\n            return new ClusterGroupAdapter(ctx, null, Collections.singleton(cfg.getNodeId()));\n        }\n        finally {\n            unguard();\n        }\n    }\n    /** {@inheritDoc} */\n    @Override public ClusterNode localNode() {\n        guard();\n        try {\n            ClusterNode node = ctx.discovery().localNode();\n            assert node != null;\n            return node;\n        }\n        finally {\n            unguard();\n        }\n    }\n    /** {@inheritDoc} */\n    @SuppressWarnings(\"unchecked\")\n    @Override public <K, V> ConcurrentMap<K, V> nodeLocalMap() {\n        return nodeLoc;\n    }\n    /** {@inheritDoc} */\n    @Override public boolean pingNode(UUID nodeId) {\n        A.notNull(nodeId, \"nodeId\");\n        guard();\n        try {\n            return ctx.discovery().pingNode(nodeId);\n        }\n        catch (IgniteCheckedException e) {\n            throw U.convertException(e);\n        }\n        finally {\n            unguard();\n        }\n    }\n    /** {@inheritDoc} */\n    @Override public long topologyVersion() {\n        guard();\n        try {\n            return ctx.discovery().topologyVersion();\n        }\n        finally {\n            unguard();\n        }\n    }\n    /** {@inheritDoc} */\n    @Override public Collection<ClusterNode> topology(long topVer) throws UnsupportedOperationException {\n        guard();\n        try {\n            return ctx.discovery().topology(topVer);\n        }\n        finally {\n            unguard();\n        }\n    }\n    /** {@inheritDoc} */\n    @Override public Collection<ClusterStartNodeResult> startNodes(File file,\n        boolean restart,\n        int timeout,\n        int maxConn)\n        throws IgniteException {\n        try {\n            return startNodesAsync0(file, restart, timeout, maxConn).get();\n        }\n        catch (IgniteCheckedException e) {\n            throw U.convertException(e);\n        }\n    }\n    /** {@inheritDoc} */\n    @Override public IgniteFuture<Collection<ClusterStartNodeResult>> startNodesAsync(File file, boolean restart,\n        int timeout, int maxConn) throws IgniteException {\n        return new IgniteFutureImpl<>(startNodesAsync0(file, restart, timeout, maxConn));\n    }\n    /** {@inheritDoc} */\n    @Override public Collection<ClusterStartNodeResult> startNodes(Collection<Map<String, Object>> hosts,\n        @Nullable Map<String, Object> dflts,\n        boolean restart,\n        int timeout,\n        int maxConn)\n        throws IgniteException {\n        try {\n            return startNodesAsync0(hosts, dflts, restart, timeout, maxConn).get();\n        }\n        catch (IgniteCheckedException e) {\n            throw U.convertException(e);\n        }\n    }\n    /** {@inheritDoc} */\n    @Override public IgniteFuture<Collection<ClusterStartNodeResult>> startNodesAsync(\n        Collection<Map<String, Object>> hosts, @Nullable Map<String, Object> dflts,\n        boolean restart, int timeout, int maxConn) throws IgniteException {\n        return new IgniteFutureImpl<>(startNodesAsync0(hosts, dflts, restart, timeout, maxConn));\n    }\n    /** {@inheritDoc} */\n    @Override public void stopNodes() throws IgniteException {\n        guard();\n        try {\n            compute().execute(IgniteKillTask.class, false);\n        }\n        finally {\n            unguard();\n        }\n    }\n    /** {@inheritDoc} */\n    @Override public void stopNodes(Collection<UUID> ids) throws IgniteException {\n        guard();\n        try {\n            ctx.grid().compute(forNodeIds(ids)).execute(IgniteKillTask.class, false);\n        }\n        finally {\n            unguard();\n        }\n    }\n    /** {@inheritDoc} */\n    @Override public void restartNodes() throws IgniteException {\n        guard();\n        try {\n            compute().execute(IgniteKillTask.class, true);\n        }\n        finally {\n            unguard();\n        }\n    }\n    /** {@inheritDoc} */\n<fim_suffix>    @Override public void restartNodes(Collection<UUID> ids) throws IgniteException {\n        guard();\n        try {\n            ctx.grid().compute(forNodeIds(ids)).execute(IgniteKillTask.class, true);\n        }\n        finally {\n            unguard();\n        }\n    }<fim_middle>// function below has no smell\n"}