{"text": "<fim_prefix>        }\n        for (String anEventNamesSVG11 : eventNamesSVG11) {\n            animationEventNames11.add(anEventNamesSVG11);\n        }\n        for (String anEventNamesSVG12 : eventNamesSVG12) {\n            animationEventNames12.add(anEventNamesSVG12);\n        }\n    }\n    /**\n     * Creates a new SVGAnimationEngine.\n     */\n    public SVGAnimationEngine(Document doc, BridgeContext ctx) {\n        super(doc);\n        this.ctx = ctx;\n        SVGOMDocument d = (SVGOMDocument) doc;\n        cssEngine = d.getCSSEngine();\n        dummyStyleMap = new StyleMap(cssEngine.getNumberOfProperties());\n        isSVG12 = d.isSVG12();\n    }\n    /**\n     * Disposes this animation engine.\n     */\n    public void dispose() {\n        synchronized (this) {\n            pause();\n            super.dispose();\n        }\n    }\n    /**\n     * Adds an animation element bridge to the list of bridges that\n     * require initializing when the document is started.\n     */\n    public void addInitialBridge(SVGAnimationElementBridge b) {\n        if (initialBridges != null) {\n            initialBridges.add(b);\n        }\n    }\n    /**\n     * Returns whether animation processing has begun.\n     */\n    public boolean hasStarted() {\n        return started;\n    }\n    /**\n     * Parses an AnimatableValue.\n     */\n    public AnimatableValue parseAnimatableValue(Element animElt,\n                                                AnimationTarget target,\n                                                String ns, String ln,\n                                                boolean isCSS,\n                                                String s) {\n        SVGOMElement elt = (SVGOMElement) target.getElement();\n        int type;\n        if (isCSS) {\n            type = elt.getPropertyType(ln);\n        } else {\n            type = elt.getAttributeType(ns, ln);\n        }\n        Factory factory = factories[type];\n        if (factory == null) {\n            String an = ns == null ? ln : '{' + ns + '}' + ln;\n            throw new BridgeException\n                (ctx, animElt, \"attribute.not.animatable\",\n                 new Object[] { target.getElement().getNodeName(), an });\n        }\n        return factories[type].createValue(target, ns, ln, isCSS, s);\n    }\n    /**\n     * Returns an AnimatableValue for the underlying value of a CSS property.\n     */\n    public AnimatableValue getUnderlyingCSSValue(Element animElt,\n                                                 AnimationTarget target,\n                                                 String pn) {\n        ValueManager[] vms = cssEngine.getValueManagers();\n        int idx = cssEngine.getPropertyIndex(pn);\n        if (idx != -1) {\n            int type = vms[idx].getPropertyType();\n            Factory factory = factories[type];\n            if (factory == null) {\n                throw new BridgeException\n                    (ctx, animElt, \"attribute.not.animatable\",\n                     new Object[] { target.getElement().getNodeName(), pn });\n            }\n            SVGStylableElement e = (SVGStylableElement) target.getElement();\n            CSSStyleDeclaration over = e.getOverrideStyle();\n            String oldValue = over.getPropertyValue(pn);\n            if (oldValue != null) {\n                over.removeProperty(pn);\n            }\n            Value v = cssEngine.getComputedStyle(e, null, idx);\n            if (oldValue != null && !oldValue.equals(\"\")) {\n                over.setProperty(pn, oldValue, null);\n            }\n            return factories[type].createValue(target, pn, v);\n        }\n        // XXX Doesn't handle shorthands.\n        return null;\n    }\n    /**\n     * Pauses the animations.\n     */\n    public void pause() {\n        super.pause();\n        UpdateManager um = ctx.getUpdateManager();\n        if (um != null) {\n            um.getUpdateRunnableQueue().setIdleRunnable(null);\n        }\n    }\n    /**\n     * Pauses the animations.\n     */\n    public void unpause() {\n        super.unpause();\n        UpdateManager um = ctx.getUpdateManager();\n        if (um != null) {\n            um.getUpdateRunnableQueue().setIdleRunnable(animationTickRunnable);\n        }\n    }\n    /**\n     * Returns the current document time.\n     */\n    public float getCurrentTime() {\n        boolean p = pauseTime != 0;\n        unpause();\n        float t = timedDocumentRoot.getCurrentTime();\n        if (p) {\n            pause();\n        }\n        return Float.isNaN(t) ? 0 : t;\n    }\n    /**\n     * Sets the current document time.\n     */\n    public float setCurrentTime(float t) {\n        if (started) {\n            float ret = super.setCurrentTime(t);\n            if (animationTickRunnable != null) {\n                animationTickRunnable.resume();\n            }\n            return ret;\n        } else {\n            initialStartTime = t;\n            return 0;\n        }\n    }\n    /**\n     * Creates a new returns a new TimedDocumentRoot object for the document.\n     */\n    protected TimedDocumentRoot createDocumentRoot() {\n        return new AnimationRoot();\n    }\n    /**\n     * Starts the animation engine.\n     */\n    public void start(long documentStartTime) {\n        if (started) {\n            return;\n        }\n        started = true;\n        try {\n            try {\n                Calendar cal = Calendar.getInstance();\n                cal.setTime(new Date(documentStartTime));\n                timedDocumentRoot.resetDocument(cal);\n                Object[] bridges = initialBridges.toArray();\n                initialBridges = null;\n                for (Object bridge2 : bridges) {\n                    SVGAnimationElementBridge bridge =\n                            (SVGAnimationElementBridge) bridge2;\n                    bridge.initializeAnimation();\n                }\n                for (Object bridge1 : bridges) {\n                    SVGAnimationElementBridge bridge =\n                            (SVGAnimationElementBridge) bridge1;\n                    bridge.initializeTimedElement();\n                }\n                // tick(0, false);\n                // animationThread = new AnimationThread();\n                // animationThread.start();\n                UpdateManager um = ctx.getUpdateManager();\n                if (um != null) {\n                    RunnableQueue q = um.getUpdateRunnableQueue();\n                    animationTickRunnable = new AnimationTickRunnable(q, this);\n                    q.setIdleRunnable(animationTickRunnable);\n                    if (initialStartTime != 0) {\n                        setCurrentTime(initialStartTime);\n                    }\n                }\n            } catch (AnimationException ex) {\n                throw new BridgeException(ctx, ex.getElement().getElement(),\n                                          ex.getMessage());\n            }\n        } catch (Exception ex) {\n            if (ctx.getUserAgent() == null) {\n                ex.printStackTrace();\n            } else {\n                ctx.getUserAgent().displayError(ex);\n            }\n        }\n    }\n    /**\n     * Sets the animation limiting mode to \"none\".\n     */\n    public void setAnimationLimitingNone() {\n        animationLimitingMode = 0;\n    }\n    /**\n     * Sets the animation limiting mode to a percentage of CPU.\n     * @param pc the maximum percentage of CPU to use (0 &lt; pc \u2264 1)\n     */\n    public void setAnimationLimitingCPU(float pc) {\n        animationLimitingMode = 1;\n        animationLimitingAmount = pc;\n    }\n    /**\n     * Sets the animation limiting mode to a number of frames per second.\n     * @param fps the maximum number of frames per second (fps &gt; 0)\n     */\n    public void setAnimationLimitingFPS(float fps) {\n        animationLimitingMode = 2;\n        animationLimitingAmount = fps;\n    }\n    /**\n     * A class for the root time container.\n     */\n    protected class AnimationRoot extends TimedDocumentRoot {\n        /**\n         * Creates a new AnimationRoot object.\n         */\n        public AnimationRoot() {\n            super(!isSVG12, isSVG12);\n        }\n        /**\n         * Returns the namespace URI of the event that corresponds to the given\n         * animation event name.\n         */\n        protected String getEventNamespaceURI(String eventName) {\n            if (!isSVG12) {\n                return null;\n            }\n            if (eventName.equals(\"focusin\")\n                    || eventName.equals(\"focusout\")\n                    || eventName.equals(\"activate\")\n                    || animationEventNames12.contains(eventName)) {\n                return XMLConstants.XML_EVENTS_NAMESPACE_URI;\n            }\n            return null;\n        }\n        /**\n         * Returns the type of the event that corresponds to the given\n         * animation event name.\n         */\n<fim_suffix>        protected String getEventType(String eventName) {\n            if (eventName.equals(\"focusin\")) {\n                return \"DOMFocusIn\";\n            } else if (eventName.equals(\"focusout\")) {\n                return \"DOMFocusOut\";\n            } else if (eventName.equals(\"activate\")) {\n                return \"DOMActivate\";\n            }\n            if (isSVG12) {\n                if (animationEventNames12.contains(eventName)) {\n                    return eventName;\n                }\n            } else {\n                if (animationEventNames11.contains(eventName)) {\n                    return eventName;\n                }\n            }\n            return null;\n        }<fim_middle>// function below has no smell\n"}