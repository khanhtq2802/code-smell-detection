{"text": "<fim_prefix>/*\n * Copyright 2010-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\").\n * You may not use this file except in compliance with the License.\n * A copy of the License is located at\n *\n *  http://aws.amazon.com/apache2.0\n *\n * or in the \"license\" file accompanying this file. This file is distributed\n * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n * express or implied. See the License for the specific language governing\n * permissions and limitations under the License.\n */\npackage com.ibm.cloud.objectstorage.services.s3.internal;\n\nimport com.ibm.cloud.objectstorage.AmazonServiceException;\nimport com.ibm.cloud.objectstorage.http.HttpMethodName;\nimport com.ibm.cloud.objectstorage.http.HttpResponse;\nimport com.ibm.cloud.objectstorage.http.HttpResponseHandler;\nimport com.ibm.cloud.objectstorage.services.s3.Headers;\nimport com.ibm.cloud.objectstorage.services.s3.model.AmazonS3Exception;\nimport com.ibm.cloud.objectstorage.util.IOUtils;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n\nimport static com.ibm.cloud.objectstorage.util.StringUtils.UTF8;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Map;\n\nimport javax.xml.stream.XMLInputFactory;\nimport javax.xml.stream.XMLStreamConstants;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.stream.XMLStreamReader;\n\n/**\n * Response handler for S3 error responses. S3 error responses are different\n * from other AWS error responses in a few ways. Most error responses will\n * contain an XML body, but not all (ex: error responses to HEAD requests will\n * not), so this error handler has to account for that. The actual XML error\n * response body is slightly different than other services like SimpleDB or EC2\n * and some information isn't explicitly represented in the XML error response\n * body (ex: error type/fault information) so it has to be inferred from other\n * parts of the error response.\n */\npublic class S3ErrorResponseHandler implements\n        HttpResponseHandler<AmazonServiceException> {\n    /** Shared logger for profiling information */\n    private static final Log log = LogFactory\n            .getLog(S3ErrorResponseHandler.class);\n\n    /** Shared factory for creating XML event readers */\n    private static final XMLInputFactory xmlInputFactory = XMLInputFactory\n            .newInstance();\n\n    private static enum S3ErrorTags {\n        Error, Message, Code, RequestId, HostId\n    };\n\n    @Override\n    public AmazonServiceException handle(HttpResponse httpResponse)\n            throws XMLStreamException {\n        final AmazonServiceException exception = createException(httpResponse);\n        exception.setHttpHeaders(httpResponse.getHeaders());\n        return exception;\n    }\n\n    private AmazonServiceException createException(HttpResponse httpResponse) throws\n                                                                              XMLStreamException {\n        final InputStream is = httpResponse.getContent();\n        String xmlContent = null;\n        /*\n         * We don't always get an error response body back from S3. When we send\n         * a HEAD request, we don't receive a body, so we'll have to just return\n         * what we can.\n         */\n        if (is == null\n                || httpResponse.getRequest().getHttpMethod() == HttpMethodName.HEAD) {\n            return createExceptionFromHeaders(httpResponse, null);\n        }\n\n        String content = null;\n        try {\n            content = IOUtils.toString(is);\n        } catch (IOException ioe) {\n            if (log.isDebugEnabled())\n                log.debug(\"Failed in parsing the error response : \", ioe);\n            return createExceptionFromHeaders(httpResponse, null);\n        }\n\n        /*\n         * XMLInputFactory is not thread safe and hence it is synchronized.\n         * Reference :\n         * http://itdoc.hitachi.co.jp/manuals/3020/30203Y2210e/EY220140.HTM\n         */\n        XMLStreamReader reader;\n        synchronized (xmlInputFactory) {\n            reader = xmlInputFactory\n                    .createXMLStreamReader(new ByteArrayInputStream(content\n                            .getBytes(UTF8)));\n\t\t\txmlInputFactory.setProperty(XMLInputFactory.IS_COALESCING,\n        \t        Boolean.TRUE);\n        }\n\n        try {\n            /*\n             * target depth is to determine if the XML Error response from the\n             * server has any element inside <Error> tag have child tags.\n             * Parsing such tags is not supported now. target depth is\n             * incremented for every start tag and decremented after every end\n             * tag is encountered.\n             */\n            int targetDepth = 0;\n            final AmazonS3ExceptionBuilder exceptionBuilder = new AmazonS3ExceptionBuilder();\n            exceptionBuilder.setErrorResponseXml(content);\n            exceptionBuilder.setStatusCode(httpResponse.getStatusCode());\n            exceptionBuilder.setCloudFrontId(httpResponse.getHeaders().get(Headers.CLOUD_FRONT_ID));\n            String bucketRegion = httpResponse.getHeader(Headers.S3_BUCKET_REGION);\n            if (bucketRegion != null) {\n                exceptionBuilder.addAdditionalDetail(Headers.S3_BUCKET_REGION, bucketRegion);\n            }\n\n            boolean hasErrorTagVisited = false;\n            while (reader.hasNext()) {\n                int event = reader.next();\n\n                switch (event) {\n                case XMLStreamConstants.START_ELEMENT:\n                    targetDepth++;\n                    String tagName = reader.getLocalName();\n                    if (targetDepth == 1\n                            && !S3ErrorTags.Error.toString().equals(tagName))\n                        return createExceptionFromHeaders(httpResponse,\n                                \"Unable to parse error response. Error XML Not in proper format.\"\n                                        + content);\n                    if (S3ErrorTags.Error.toString().equals(tagName)) {\n                        hasErrorTagVisited = true;\n                    }\n                    continue;\n                case XMLStreamConstants.CHARACTERS:\n                    xmlContent = reader.getText();\n                    if (xmlContent != null)\n                        xmlContent = xmlContent.trim();\n                    continue;\n                case XMLStreamConstants.END_ELEMENT:\n                    tagName = reader.getLocalName();\n                    targetDepth--;\n                    if (!(hasErrorTagVisited) || targetDepth > 1) {\n                        return createExceptionFromHeaders(httpResponse,\n                                \"Unable to parse error response. Error XML Not in proper format.\"\n                                        + content);\n                    }\n                    if (S3ErrorTags.Message.toString().equals(tagName)) {\n                        exceptionBuilder.setErrorMessage(xmlContent);\n                    } else if (S3ErrorTags.Code.toString().equals(tagName)) {\n                        exceptionBuilder.setErrorCode(xmlContent);\n                    } else if (S3ErrorTags.RequestId.toString().equals(tagName)) {\n                        exceptionBuilder.setRequestId(xmlContent);\n                    } else if (S3ErrorTags.HostId.toString().equals(tagName)) {\n                        exceptionBuilder.setExtendedRequestId(xmlContent);\n                    } else {\n                        exceptionBuilder.addAdditionalDetail(tagName, xmlContent);\n                    }\n                    continue;\n                case XMLStreamConstants.END_DOCUMENT:\n                    return exceptionBuilder.build();\n                }\n            }\n        } catch (Exception e) {\n            if (log.isDebugEnabled())\n                log.debug(\"Failed in parsing the error response : \" + content,\n                        e);\n        }\n        return createExceptionFromHeaders(httpResponse, content);\n    }\n\n    private AmazonS3Exception createExceptionFromHeaders(\n            HttpResponse errorResponse, String errorResponseXml) {\n        final Map<String, String> headers = errorResponse.getHeaders();\n        final int statusCode = errorResponse.getStatusCode();\n        final AmazonS3ExceptionBuilder exceptionBuilder = new AmazonS3ExceptionBuilder();\n        exceptionBuilder.setErrorMessage(errorResponse.getStatusText());\n        exceptionBuilder.setErrorResponseXml(errorResponseXml);\n        exceptionBuilder.setStatusCode(statusCode);\n        exceptionBuilder\n                .setExtendedRequestId(headers.get(Headers.EXTENDED_REQUEST_ID));\n        exceptionBuilder.setRequestId(headers.get(Headers.REQUEST_ID));\n        exceptionBuilder.setCloudFrontId(headers.get(Headers.CLOUD_FRONT_ID));\n        exceptionBuilder\n                .setErrorCode(statusCode + \" \" + errorResponse.getStatusText());\n        exceptionBuilder.addAdditionalDetail(Headers.S3_BUCKET_REGION,\n                errorResponse.getHeaders().get(Headers.S3_BUCKET_REGION));\n        return exceptionBuilder.build();\n    }\n\n    /**\n     * Since this response handler completely consumes all the data from the\n     * underlying HTTP connection during the handle method, we don't need to\n     * keep the HTTP connection open.\n     *\n     * @see com.ibm.cloud.objectstorage.http.HttpResponseHandler#needsConnectionLeftOpen()\n     */\n<fim_suffix>    public boolean needsConnectionLeftOpen() {\n        return false;\n    }\n}<fim_middle>// function below has no smell\n"}