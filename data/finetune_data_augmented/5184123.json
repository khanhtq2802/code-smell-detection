{"text": "<fim_prefix>import org.apache.metron.indexing.dao.search.SearchRequest;\nimport org.apache.metron.indexing.dao.search.SearchResponse;\nimport org.apache.metron.indexing.dao.update.CommentAddRemoveRequest;\nimport org.apache.metron.indexing.dao.update.Document;\n/**\n * The HBaseDao is an index dao which only supports the following actions:\n * * Update\n * * Get document\n *\n * The mechanism here is that updates to documents will be added to a HBase Table as a write-ahead log.\n * The Key for a row supporting a given document will be the GUID plus the sensor type, which should be sufficiently distributed.\n * Every new update will have a column added (column qualifier will be the timestamp of the update).\n * Upon retrieval, the most recent column will be returned.\n *\n */\npublic class HBaseDao implements IndexDao {\n  public static String HBASE_TABLE = \"update.hbase.table\";\n  public static String HBASE_CF = \"update.hbase.cf\";\n  private HTableInterface tableInterface;\n  private byte[] cf;\n  private AccessConfig config;\n  /**\n   * Implements the HBaseDao row key and exposes convenience methods for serializing/deserializing the row key.\n   * The row key is made of a GUID and sensor type along with a prefix to ensure data is distributed evenly.\n   */\n  public static class Key {\n    private String guid;\n    private String sensorType;\n    public Key(String guid, String sensorType) {\n      this.guid = guid;\n      this.sensorType = sensorType;\n    }\n    public String getGuid() {\n      return guid;\n    }\n    public String getSensorType() {\n      return sensorType;\n    }\n    public static Key fromBytes(byte[] buffer) throws IOException {\n      ByteArrayInputStream baos = new ByteArrayInputStream(buffer);\n      DataInputStream w = new DataInputStream(baos);\n      baos.skip(KeyUtil.HASH_PREFIX_SIZE);\n      return new Key(w.readUTF(), w.readUTF());\n    }\n    public byte[] toBytes() throws IOException {\n      ByteArrayOutputStream baos = new ByteArrayOutputStream();\n      if(getGuid() == null || getSensorType() == null) {\n        throw new IllegalStateException(\"Guid and sensor type must not be null: guid = \" + getGuid() + \", sensorType = \" + getSensorType());\n      }\n      DataOutputStream w = new DataOutputStream(baos);\n      w.writeUTF(getGuid());\n      w.writeUTF(getSensorType());\n      w.flush();\n      byte[] key = baos.toByteArray();\n      byte[] prefix = KeyUtil.INSTANCE.getPrefix(key);\n      return KeyUtil.INSTANCE.merge(prefix, key);\n    }\n    public static byte[] toBytes(Key k) throws IOException {\n      return k.toBytes();\n    }\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) return true;\n      if (o == null || getClass() != o.getClass()) return false;\n      Key key = (Key) o;\n      if (getGuid() != null ? !getGuid().equals(key.getGuid()) : key.getGuid() != null) return false;\n      return getSensorType() != null ? getSensorType().equals(key.getSensorType()) : key.getSensorType() == null;\n    }\n    @Override\n    public int hashCode() {\n      int result = getGuid() != null ? getGuid().hashCode() : 0;\n      result = 31 * result + (getSensorType() != null ? getSensorType().hashCode() : 0);\n      return result;\n    }\n  }\n  public HBaseDao() {\n  }\n  @Override\n  public synchronized SearchResponse search(SearchRequest searchRequest) throws InvalidSearchException {\n    return null;\n  }\n  @Override\n  public GroupResponse group(GroupRequest groupRequest) throws InvalidSearchException {\n    return null;\n  }\n  @Override\n  public synchronized void init(AccessConfig config) {\n    if(this.tableInterface == null) {\n      this.config = config;\n      Map<String, Object> globalConfig = config.getGlobalConfigSupplier().get();\n      if(globalConfig == null) {\n        throw new IllegalStateException(\"Cannot find the global config.\");\n      }\n      String table = (String)globalConfig.get(HBASE_TABLE);\n      String cf = (String) config.getGlobalConfigSupplier().get().get(HBASE_CF);\n      if(table == null || cf == null) {\n        throw new IllegalStateException(\"You must configure \" + HBASE_TABLE + \" and \" + HBASE_CF + \" in the global config.\");\n      }\n      try {\n        tableInterface = config.getTableProvider().getTable(HBaseConfiguration.create(), table);\n        this.cf = cf.getBytes();\n      } catch (IOException e) {\n        throw new IllegalStateException(\"Unable to initialize HBaseDao: \" + e.getMessage(), e);\n      }\n    }\n  }\n  public HTableInterface getTableInterface() {\n    if(tableInterface == null) {\n      init(config);\n    }\n    return tableInterface;\n  }\n  @Override\n  public synchronized Document getLatest(String guid, String sensorType) throws IOException {\n    Key k = new Key(guid, sensorType);\n    Get get = new Get(Key.toBytes(k));\n    get.addFamily(cf);\n    Result result = getTableInterface().get(get);\n    return getDocumentFromResult(result);\n  }\n  @Override\n  public Iterable<Document> getAllLatest(\n      List<GetRequest> getRequests) throws IOException {\n    List<Get> gets = new ArrayList<>();\n    for (GetRequest getRequest: getRequests) {\n      gets.add(buildGet(getRequest));\n    }\n    Result[] results = getTableInterface().get(gets);\n    List<Document> allLatest = new ArrayList<>();\n    for (Result result: results) {\n      Document d = getDocumentFromResult(result);\n      if (d != null) {\n        allLatest.add(d);\n      }\n    }\n    return allLatest;\n  }\n  private Document getDocumentFromResult(Result result) throws IOException {\n    NavigableMap<byte[], byte[]> columns = result.getFamilyMap( cf);\n    if(columns == null || columns.size() == 0) {\n      return null;\n    }\n    Map.Entry<byte[], byte[]> entry= columns.lastEntry();\n    Long ts = Bytes.toLong(entry.getKey());\n    if(entry.getValue()!= null) {\n      Map<String, Object> json = JSONUtils.INSTANCE.load(new String(entry.getValue()),\n          JSONUtils.MAP_SUPPLIER);\n      // Make sure comments are in the proper format\n      @SuppressWarnings(\"unchecked\")\n      List<Map<String, Object>> commentsMap = (List<Map<String, Object>>) json.get(COMMENTS_FIELD);\n      try {\n        if (commentsMap != null) {\n          List<AlertComment> comments = new ArrayList<>();\n          for (Map<String, Object> commentMap : commentsMap) {\n            comments.add(new AlertComment(commentMap));\n          }\n          if (comments.size() > 0) {\n            json.put(COMMENTS_FIELD,\n                comments.stream().map(AlertComment::asMap).collect(Collectors.toList()));\n          }\n        }\n        Key k = Key.fromBytes(result.getRow());\n        return new Document(json, k.getGuid(), k.getSensorType(), ts);\n      } catch (IOException e) {\n        throw new RuntimeException(\"Unable to convert row key to a document\", e);\n      }\n    }\n    else {\n      return null;\n    }\n  }\n  @Override\n  public synchronized Document update(Document update, Optional<String> index) throws IOException {\n    Put put = buildPut(update);\n    getTableInterface().put(put);\n    return update;\n  }\n  @Override\n  public Map<Document, Optional<String>> batchUpdate(Map<Document, Optional<String>> updates) throws IOException {\n    List<Put> puts = new ArrayList<>();\n    for (Map.Entry<Document, Optional<String>> updateEntry : updates.entrySet()) {\n      Document update = updateEntry.getKey();\n      Put put = buildPut(update);\n      puts.add(put);\n    }\n    getTableInterface().put(puts);\n    return updates;\n  }\n  protected Get buildGet(GetRequest getRequest) throws IOException {\n    Key k = new Key(getRequest.getGuid(), getRequest.getSensorType());\n    Get get = new Get(Key.toBytes(k));\n    get.addFamily(cf);\n    return get;\n  }\n<fim_suffix>  protected Put buildPut(Document update) throws IOException {\n    Key k = new Key(update.getGuid(), update.getSensorType());\n    Put put = new Put(Key.toBytes(k));\n    long ts = update.getTimestamp() == null || update.getTimestamp() == 0 ? System.currentTimeMillis() : update.getTimestamp();\n    byte[] columnQualifier = Bytes.toBytes(ts);\n    byte[] doc = JSONUtils.INSTANCE.toJSONPretty(update.getDocument());\n    put.addColumn(cf, columnQualifier, doc);\n    return put;\n  }<fim_middle>// function below has no smell\n"}