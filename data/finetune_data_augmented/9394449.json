{"text": "<fim_prefix>\n<fim_suffix>abstract class RTFParser extends AbstractFilter\n{\n  /** The current RTF group nesting level. */\n  public int level;\n  private int state;\n  private StringBuffer currentCharacters;\n  private String pendingKeyword;                // where keywords go while we\n                                                // read their parameters\n  private int pendingCharacter;                 // for the \\'xx construct\n  private long binaryBytesLeft;                  // in a \\bin blob?\n  ByteArrayOutputStream binaryBuf;\n  private boolean[] savedSpecials;\n  /** A stream to which to write warnings and debugging information\n   *  while parsing. This is set to <code>System.out</code> to log\n   *  any anomalous information to stdout. */\n  protected PrintStream warnings;\n  // value for the 'state' variable\n  private final int S_text = 0;          // reading random text\n  private final int S_backslashed = 1;   // read a backslash, waiting for next\n  private final int S_token = 2;         // reading a multicharacter token\n  private final int S_parameter = 3;     // reading a token's parameter\n  private final int S_aftertick = 4;     // after reading \\'\n  private final int S_aftertickc = 5;    // after reading \\'x\n  private final int S_inblob = 6;        // in a \\bin blob\n  /** Implemented by subclasses to interpret a parameter-less RTF keyword.\n   *  The keyword is passed without the leading '/' or any delimiting\n   *  whitespace. */\n  public abstract boolean handleKeyword(String keyword);\n  /** Implemented by subclasses to interpret a keyword with a parameter.\n   *  @param keyword   The keyword, as with <code>handleKeyword(String)</code>.\n   *  @param parameter The parameter following the keyword. */\n  public abstract boolean handleKeyword(String keyword, int parameter);\n  /** Implemented by subclasses to interpret text from the RTF stream. */\n  public abstract void handleText(String text);\n  public void handleText(char ch)\n  { handleText(String.valueOf(ch)); }\n  /** Implemented by subclasses to handle the contents of the \\bin keyword. */\n  public abstract void handleBinaryBlob(byte[] data);\n  /** Implemented by subclasses to react to an increase\n   *  in the nesting level. */\n  public abstract void begingroup();\n  /** Implemented by subclasses to react to the end of a group. */\n  public abstract void endgroup();\n  // table of non-text characters in rtf\n  static final boolean[] rtfSpecialsTable;\n  static {\n    rtfSpecialsTable = noSpecialsTable.clone();\n    rtfSpecialsTable['\\n'] = true;\n    rtfSpecialsTable['\\r'] = true;\n    rtfSpecialsTable['{'] = true;\n    rtfSpecialsTable['}'] = true;\n    rtfSpecialsTable['\\\\'] = true;\n  }\n  public RTFParser()\n  {\n    currentCharacters = new StringBuffer();\n    state = S_text;\n    pendingKeyword = null;\n    level = 0;\n    //warnings = System.out;\n    specialsTable = rtfSpecialsTable;\n  }\n  // TODO: Handle wrapup at end of file correctly.\n  public void writeSpecial(int b)\n    throws IOException\n  {\n    write((char)b);\n  }\n    protected void warning(String s) {\n        if (warnings != null) {\n            warnings.println(s);\n        }\n    }\n  public void write(String s)\n    throws IOException\n  {\n    if (state != S_text) {\n      int index = 0;\n      int length = s.length();\n      while(index < length && state != S_text) {\n        write(s.charAt(index));\n        index ++;\n      }\n      if(index >= length)\n        return;\n      s = s.substring(index);\n    }\n    if (currentCharacters.length() > 0)\n      currentCharacters.append(s);\n    else\n      handleText(s);\n  }\n  @SuppressWarnings(\"fallthrough\")\n  public void write(char ch)\n    throws IOException\n  {\n    boolean ok;\n    switch (state)\n    {\n      case S_text:\n        if (ch == '\\n' || ch == '\\r') {\n          break;  // unadorned newlines are ignored\n        } else if (ch == '{') {\n          if (currentCharacters.length() > 0) {\n            handleText(currentCharacters.toString());\n            currentCharacters = new StringBuffer();\n          }\n          level ++;\n          begingroup();\n        } else if(ch == '}') {\n          if (currentCharacters.length() > 0) {\n            handleText(currentCharacters.toString());\n            currentCharacters = new StringBuffer();\n          }\n          if (level == 0)\n            throw new IOException(\"Too many close-groups in RTF text\");\n          endgroup();\n          level --;\n        } else if(ch == '\\\\') {\n          if (currentCharacters.length() > 0) {\n            handleText(currentCharacters.toString());\n            currentCharacters = new StringBuffer();\n          }\n          state = S_backslashed;\n        } else {\n          currentCharacters.append(ch);\n        }\n        break;\n      case S_backslashed:\n        if (ch == '\\'') {\n          state = S_aftertick;\n          break;\n        }\n        if (!Character.isLetter(ch)) {\n          char[] newstring = new char[1];\n          newstring[0] = ch;\n          if (!handleKeyword(new String(newstring))) {\n            warning(\"Unknown keyword: \" + newstring + \" (\" + (byte)ch + \")\");\n          }\n          state = S_text;\n          pendingKeyword = null;\n          /* currentCharacters is already an empty stringBuffer */\n          break;\n        }\n        state = S_token;\n        /* FALL THROUGH */\n      case S_token:\n        if (Character.isLetter(ch)) {\n          currentCharacters.append(ch);\n        } else {\n          pendingKeyword = currentCharacters.toString();\n          currentCharacters = new StringBuffer();\n          // Parameter following?\n          if (Character.isDigit(ch) || (ch == '-')) {\n            state = S_parameter;\n            currentCharacters.append(ch);\n          } else {\n            ok = handleKeyword(pendingKeyword);\n            if (!ok)\n              warning(\"Unknown keyword: \" + pendingKeyword);\n            pendingKeyword = null;\n            state = S_text;\n            // Non-space delimiters get included in the text\n            if (!Character.isWhitespace(ch))\n              write(ch);\n          }\n        }\n        break;\n      case S_parameter:\n        if (Character.isDigit(ch)) {\n          currentCharacters.append(ch);\n        } else {\n          /* TODO: Test correct behavior of \\bin keyword */\n          if (pendingKeyword.equals(\"bin\")) {  /* magic layer-breaking kwd */\n            long parameter = Long.parseLong(currentCharacters.toString());\n            pendingKeyword = null;\n            state = S_inblob;\n            binaryBytesLeft = parameter;\n            if (binaryBytesLeft > Integer.MAX_VALUE)\n                binaryBuf = new ByteArrayOutputStream(Integer.MAX_VALUE);\n            else\n                binaryBuf = new ByteArrayOutputStream((int)binaryBytesLeft);\n            savedSpecials = specialsTable;\n            specialsTable = allSpecialsTable;\n            break;\n          }\n          int parameter = Integer.parseInt(currentCharacters.toString());\n          ok = handleKeyword(pendingKeyword, parameter);\n          if (!ok)\n            warning(\"Unknown keyword: \" + pendingKeyword +\n                    \" (param \" + currentCharacters + \")\");\n          pendingKeyword = null;\n          currentCharacters = new StringBuffer();\n          state = S_text;\n          // Delimiters here are interpreted as text too\n          if (!Character.isWhitespace(ch))\n            write(ch);\n        }\n        break;\n      case S_aftertick:\n        if (Character.digit(ch, 16) == -1)\n          state = S_text;\n        else {\n          pendingCharacter = Character.digit(ch, 16);\n          state = S_aftertickc;\n        }\n        break;\n      case S_aftertickc:\n        state = S_text;\n        if (Character.digit(ch, 16) != -1)\n        {\n          pendingCharacter = pendingCharacter * 16 + Character.digit(ch, 16);\n          ch = translationTable[pendingCharacter];\n          if (ch != 0)\n              handleText(ch);\n        }\n        break;\n      case S_inblob:\n        binaryBuf.write(ch);\n        binaryBytesLeft --;\n        if (binaryBytesLeft == 0) {\n            state = S_text;\n            specialsTable = savedSpecials;\n            savedSpecials = null;\n            handleBinaryBlob(binaryBuf.toByteArray());\n            binaryBuf = null;\n        }\n      }\n  }\n  /** Flushes any buffered but not yet written characters.\n   *  Subclasses which override this method should call this\n   *  method <em>before</em> flushing\n   *  any of their own buffers. */\n  public void flush()\n    throws IOException\n  {\n    super.flush();\n    if (state == S_text && currentCharacters.length() > 0) {\n      handleText(currentCharacters.toString());\n      currentCharacters = new StringBuffer();\n    }\n  }<fim_middle>// class below has no smell\n"}