{"text": "<fim_prefix> *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.springframework.boot.autoconfigure;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport org.springframework.core.type.AnnotationMetadata;\nimport org.springframework.core.type.classreading.MetadataReader;\nimport org.springframework.core.type.classreading.MetadataReaderFactory;\nimport org.springframework.util.Assert;\n/**\n * Sort {@link EnableAutoConfiguration auto-configuration} classes into priority order by\n * reading {@link AutoConfigureOrder}, {@link AutoConfigureBefore} and\n * {@link AutoConfigureAfter} annotations (without loading classes).\n *\n * @author Phillip Webb\n */\nclass AutoConfigurationSorter {\n\tprivate final MetadataReaderFactory metadataReaderFactory;\n\tprivate final AutoConfigurationMetadata autoConfigurationMetadata;\n\tAutoConfigurationSorter(MetadataReaderFactory metadataReaderFactory,\n\t\t\tAutoConfigurationMetadata autoConfigurationMetadata) {\n\t\tAssert.notNull(metadataReaderFactory, \"MetadataReaderFactory must not be null\");\n\t\tthis.metadataReaderFactory = metadataReaderFactory;\n\t\tthis.autoConfigurationMetadata = autoConfigurationMetadata;\n\t}\n\tpublic List<String> getInPriorityOrder(Collection<String> classNames) {\n\t\tAutoConfigurationClasses classes = new AutoConfigurationClasses(\n\t\t\t\tthis.metadataReaderFactory, this.autoConfigurationMetadata, classNames);\n\t\tList<String> orderedClassNames = new ArrayList<>(classNames);\n\t\t// Initially sort alphabetically\n\t\tCollections.sort(orderedClassNames);\n\t\t// Then sort by order\n\t\torderedClassNames.sort((o1, o2) -> {\n\t\t\tint i1 = classes.get(o1).getOrder();\n\t\t\tint i2 = classes.get(o2).getOrder();\n\t\t\treturn Integer.compare(i1, i2);\n\t\t});\n\t\t// Then respect @AutoConfigureBefore @AutoConfigureAfter\n\t\torderedClassNames = sortByAnnotation(classes, orderedClassNames);\n\t\treturn orderedClassNames;\n\t}\n\tprivate List<String> sortByAnnotation(AutoConfigurationClasses classes,\n\t\t\tList<String> classNames) {\n\t\tList<String> toSort = new ArrayList<>(classNames);\n\t\ttoSort.addAll(classes.getAllNames());\n\t\tSet<String> sorted = new LinkedHashSet<>();\n\t\tSet<String> processing = new LinkedHashSet<>();\n\t\twhile (!toSort.isEmpty()) {\n\t\t\tdoSortByAfterAnnotation(classes, toSort, sorted, processing, null);\n\t\t}\n\t\tsorted.retainAll(classNames);\n\t\treturn new ArrayList<>(sorted);\n\t}\n\tprivate void doSortByAfterAnnotation(AutoConfigurationClasses classes,\n\t\t\tList<String> toSort, Set<String> sorted, Set<String> processing,\n\t\t\tString current) {\n\t\tif (current == null) {\n\t\t\tcurrent = toSort.remove(0);\n\t\t}\n\t\tprocessing.add(current);\n\t\tfor (String after : classes.getClassesRequestedAfter(current)) {\n\t\t\tAssert.state(!processing.contains(after),\n\t\t\t\t\t\"AutoConfigure cycle detected between \" + current + \" and \" + after);\n\t\t\tif (!sorted.contains(after) && toSort.contains(after)) {\n\t\t\t\tdoSortByAfterAnnotation(classes, toSort, sorted, processing, after);\n\t\t\t}\n\t\t}\n\t\tprocessing.remove(current);\n\t\tsorted.add(current);\n\t}\n\tprivate static class AutoConfigurationClasses {\n\t\tprivate final Map<String, AutoConfigurationClass> classes = new HashMap<>();\n\t\tAutoConfigurationClasses(MetadataReaderFactory metadataReaderFactory,\n\t\t\t\tAutoConfigurationMetadata autoConfigurationMetadata,\n\t\t\t\tCollection<String> classNames) {\n\t\t\taddToClasses(metadataReaderFactory, autoConfigurationMetadata, classNames,\n\t\t\t\t\ttrue);\n\t\t}\n\t\tpublic Set<String> getAllNames() {\n\t\t\treturn this.classes.keySet();\n\t\t}\n\t\tprivate void addToClasses(MetadataReaderFactory metadataReaderFactory,\n\t\t\t\tAutoConfigurationMetadata autoConfigurationMetadata,\n\t\t\t\tCollection<String> classNames, boolean required) {\n\t\t\tfor (String className : classNames) {\n\t\t\t\tif (!this.classes.containsKey(className)) {\n\t\t\t\t\tAutoConfigurationClass autoConfigurationClass = new AutoConfigurationClass(\n\t\t\t\t\t\t\tclassName, metadataReaderFactory, autoConfigurationMetadata);\n\t\t\t\t\tboolean available = autoConfigurationClass.isAvailable();\n\t\t\t\t\tif (required || available) {\n\t\t\t\t\t\tthis.classes.put(className, autoConfigurationClass);\n\t\t\t\t\t}\n\t\t\t\t\tif (available) {\n\t\t\t\t\t\taddToClasses(metadataReaderFactory, autoConfigurationMetadata,\n\t\t\t\t\t\t\t\tautoConfigurationClass.getBefore(), false);\n\t\t\t\t\t\taddToClasses(metadataReaderFactory, autoConfigurationMetadata,\n\t\t\t\t\t\t\t\tautoConfigurationClass.getAfter(), false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpublic AutoConfigurationClass get(String className) {\n\t\t\treturn this.classes.get(className);\n\t\t}\n\t\tpublic Set<String> getClassesRequestedAfter(String className) {\n\t\t\tSet<String> classesRequestedAfter = new LinkedHashSet<>();\n\t\t\tclassesRequestedAfter.addAll(get(className).getAfter());\n\t\t\tthis.classes.forEach((name, autoConfigurationClass) -> {\n\t\t\t\tif (autoConfigurationClass.getBefore().contains(className)) {\n\t\t\t\t\tclassesRequestedAfter.add(name);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn classesRequestedAfter;\n\t\t}\n\t}\n\tprivate static class AutoConfigurationClass {\n\t\tprivate final String className;\n\t\tprivate final MetadataReaderFactory metadataReaderFactory;\n\t\tprivate final AutoConfigurationMetadata autoConfigurationMetadata;\n\t\tprivate volatile AnnotationMetadata annotationMetadata;\n\t\tprivate volatile Set<String> before;\n\t\tprivate volatile Set<String> after;\n\t\tAutoConfigurationClass(String className,\n\t\t\t\tMetadataReaderFactory metadataReaderFactory,\n\t\t\t\tAutoConfigurationMetadata autoConfigurationMetadata) {\n\t\t\tthis.className = className;\n\t\t\tthis.metadataReaderFactory = metadataReaderFactory;\n\t\t\tthis.autoConfigurationMetadata = autoConfigurationMetadata;\n\t\t}\n\t\tpublic boolean isAvailable() {\n\t\t\ttry {\n\t\t\t\tif (!wasProcessed()) {\n\t\t\t\t\tgetAnnotationMetadata();\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcatch (Exception ex) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tpublic Set<String> getBefore() {\n\t\t\tif (this.before == null) {\n\t\t\t\tthis.before = (wasProcessed()\n\t\t\t\t\t\t? this.autoConfigurationMetadata.getSet(this.className,\n\t\t\t\t\t\t\t\t\"AutoConfigureBefore\", Collections.emptySet())\n\t\t\t\t\t\t: getAnnotationValue(AutoConfigureBefore.class));\n\t\t\t}\n\t\t\treturn this.before;\n\t\t}\n\t\tpublic Set<String> getAfter() {\n\t\t\tif (this.after == null) {\n\t\t\t\tthis.after = (wasProcessed()\n\t\t\t\t\t\t? this.autoConfigurationMetadata.getSet(this.className,\n\t\t\t\t\t\t\t\t\"AutoConfigureAfter\", Collections.emptySet())\n\t\t\t\t\t\t: getAnnotationValue(AutoConfigureAfter.class));\n\t\t\t}\n\t\t\treturn this.after;\n\t\t}\n\t\tprivate int getOrder() {\n\t\t\tif (wasProcessed()) {\n\t\t\t\treturn this.autoConfigurationMetadata.getInteger(this.className,\n\t\t\t\t\t\t\"AutoConfigureOrder\", AutoConfigureOrder.DEFAULT_ORDER);\n\t\t\t}\n\t\t\tMap<String, Object> attributes = getAnnotationMetadata()\n\t\t\t\t\t.getAnnotationAttributes(AutoConfigureOrder.class.getName());\n\t\t\treturn (attributes != null) ? (Integer) attributes.get(\"value\")\n\t\t\t\t\t: AutoConfigureOrder.DEFAULT_ORDER;\n\t\t}\n\t\tprivate boolean wasProcessed() {\n\t\t\treturn (this.autoConfigurationMetadata != null\n\t\t\t\t\t&& this.autoConfigurationMetadata.wasProcessed(this.className));\n\t\t}\n\t\tprivate Set<String> getAnnotationValue(Class<?> annotation) {\n\t\t\tMap<String, Object> attributes = getAnnotationMetadata()\n\t\t\t\t\t.getAnnotationAttributes(annotation.getName(), true);\n\t\t\tif (attributes == null) {\n\t\t\t\treturn Collections.emptySet();\n\t\t\t}\n\t\t\tSet<String> value = new LinkedHashSet<>();\n\t\t\tCollections.addAll(value, (String[]) attributes.get(\"value\"));\n\t\t\tCollections.addAll(value, (String[]) attributes.get(\"name\"));\n\t\t\treturn value;\n\t\t}\n<fim_suffix>\t\tprivate AnnotationMetadata getAnnotationMetadata() {\n\t\t\tif (this.annotationMetadata == null) {\n\t\t\t\ttry {\n\t\t\t\t\tMetadataReader metadataReader = this.metadataReaderFactory\n\t\t\t\t\t\t\t.getMetadataReader(this.className);\n\t\t\t\t\tthis.annotationMetadata = metadataReader.getAnnotationMetadata();\n\t\t\t\t}\n\t\t\t\tcatch (IOException ex) {\n\t\t\t\t\tthrow new IllegalStateException(\n\t\t\t\t\t\t\t\"Unable to read meta-data for class \" + this.className, ex);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.annotationMetadata;\n\t\t}<fim_middle>// function below has no smell\n"}