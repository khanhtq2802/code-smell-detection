{"text": "<fim_prefix>\t}\n\t//XTryCatchFinallyExpression XExpression:\n\t//\t{XTryCatchFinallyExpression}\n\t//\t'try'\n\t//\texpression=XExpression (catchClauses+=XCatchClause+ (=> 'finally' finallyExpression=XExpression)?\n\t//\t| 'finally' finallyExpression=XExpression);\n\tpublic XbaseGrammarAccess.XTryCatchFinallyExpressionElements getXTryCatchFinallyExpressionAccess() {\n\t\treturn gaXbase.getXTryCatchFinallyExpressionAccess();\n\t}\n\tpublic ParserRule getXTryCatchFinallyExpressionRule() {\n\t\treturn getXTryCatchFinallyExpressionAccess().getRule();\n\t}\n\t//XSynchronizedExpression XExpression:\n\t//\t=> ({XSynchronizedExpression}\n\t//\t'synchronized' '(') param=XExpression ')' expression=XExpression;\n\tpublic XbaseGrammarAccess.XSynchronizedExpressionElements getXSynchronizedExpressionAccess() {\n\t\treturn gaXbase.getXSynchronizedExpressionAccess();\n\t}\n\tpublic ParserRule getXSynchronizedExpressionRule() {\n\t\treturn getXSynchronizedExpressionAccess().getRule();\n\t}\n\t//XCatchClause:\n\t//\t=> 'catch' '(' declaredParam=super::FullJvmFormalParameter ')' expression=XExpression;\n\tpublic XbaseGrammarAccess.XCatchClauseElements getXCatchClauseAccess() {\n\t\treturn gaXbase.getXCatchClauseAccess();\n\t}\n\tpublic ParserRule getXCatchClauseRule() {\n\t\treturn getXCatchClauseAccess().getRule();\n\t}\n\t//@Override\n\t//QualifiedName:\n\t//\tsuper::ValidID (=> '.' super::ValidID)*;\n\tpublic XbaseGrammarAccess.QualifiedNameElements getQualifiedNameAccess() {\n\t\treturn gaXbase.getQualifiedNameAccess();\n\t}\n\tpublic ParserRule getQualifiedNameRule() {\n\t\treturn getQualifiedNameAccess().getRule();\n\t}\n\t//Number hidden():\n\t//\tHEX | (INT | DECIMAL) ('.' (INT | DECIMAL))?;\n\tpublic XbaseGrammarAccess.NumberElements getNumberAccess() {\n\t\treturn gaXbase.getNumberAccess();\n\t}\n\tpublic ParserRule getNumberRule() {\n\t\treturn getNumberAccess().getRule();\n\t}\n\t///**\n\t// * Dummy rule, for \"better\" downwards compatibility, since GrammarAccess generates non-static inner classes,\n\t// * which makes downstream grammars break on classloading, when a rule is removed.\n\t// */ StaticQualifier:\n\t//\t(super::ValidID '::')+;\n\tpublic XbaseGrammarAccess.StaticQualifierElements getStaticQualifierAccess() {\n\t\treturn gaXbase.getStaticQualifierAccess();\n\t}\n\tpublic ParserRule getStaticQualifierRule() {\n\t\treturn getStaticQualifierAccess().getRule();\n\t}\n\t//terminal HEX:\n\t//\t('0x' | '0X') ('0'..'9' | 'a'..'f' | 'A'..'F' | '_')+ ('#' (('b' | 'B') ('i' | 'I') | ('l' | 'L')))?;\n\tpublic TerminalRule getHEXRule() {\n\t\treturn gaXbase.getHEXRule();\n\t}\n\t//terminal INT returns ecore::EInt:\n\t//\t'0'..'9' ('0'..'9' | '_')*;\n\tpublic TerminalRule getINTRule() {\n\t\treturn gaXbase.getINTRule();\n\t}\n\t//terminal DECIMAL:\n\t//\tINT (('e' | 'E') ('+' | '-')? INT)? (('b' | 'B') ('i' | 'I' | 'd' | 'D') | ('l' | 'L' | 'd' | 'D' | 'f' | 'F'))?;\n\tpublic TerminalRule getDECIMALRule() {\n\t\treturn gaXbase.getDECIMALRule();\n\t}\n\t//JvmTypeReference:\n\t//\tJvmParameterizedTypeReference => ({JvmGenericArrayTypeReference.componentType=current} ArrayBrackets)*\n\t//\t| XFunctionTypeRef;\n\tpublic XtypeGrammarAccess.JvmTypeReferenceElements getJvmTypeReferenceAccess() {\n\t\treturn gaXtype.getJvmTypeReferenceAccess();\n\t}\n\tpublic ParserRule getJvmTypeReferenceRule() {\n\t\treturn getJvmTypeReferenceAccess().getRule();\n\t}\n\t//ArrayBrackets:\n\t//\t'[' ']';\n\tpublic XtypeGrammarAccess.ArrayBracketsElements getArrayBracketsAccess() {\n\t\treturn gaXtype.getArrayBracketsAccess();\n\t}\n\tpublic ParserRule getArrayBracketsRule() {\n\t\treturn getArrayBracketsAccess().getRule();\n\t}\n\t//XFunctionTypeRef:\n\t//\t('(' (paramTypes+=JvmTypeReference (',' paramTypes+=JvmTypeReference)*)? ')')? '=>' returnType=JvmTypeReference;\n\tpublic XtypeGrammarAccess.XFunctionTypeRefElements getXFunctionTypeRefAccess() {\n\t\treturn gaXtype.getXFunctionTypeRefAccess();\n\t}\n\tpublic ParserRule getXFunctionTypeRefRule() {\n\t\treturn getXFunctionTypeRefAccess().getRule();\n\t}\n\t//JvmParameterizedTypeReference:\n\t//\ttype=[JvmType|super::QualifiedName] (=> '<' arguments+=JvmArgumentTypeReference (','\n\t//\targuments+=JvmArgumentTypeReference)* '>' (=> ({JvmInnerTypeReference.outer=current} '.')\n\t//\ttype=[JvmType|super::ValidID] (=> '<' arguments+=JvmArgumentTypeReference (',' arguments+=JvmArgumentTypeReference)*\n\t//\t'>')?)*)?;\n\tpublic XtypeGrammarAccess.JvmParameterizedTypeReferenceElements getJvmParameterizedTypeReferenceAccess() {\n\t\treturn gaXtype.getJvmParameterizedTypeReferenceAccess();\n\t}\n\tpublic ParserRule getJvmParameterizedTypeReferenceRule() {\n\t\treturn getJvmParameterizedTypeReferenceAccess().getRule();\n\t}\n\t//JvmArgumentTypeReference JvmTypeReference:\n\t//\tJvmTypeReference | JvmWildcardTypeReference;\n\tpublic XtypeGrammarAccess.JvmArgumentTypeReferenceElements getJvmArgumentTypeReferenceAccess() {\n\t\treturn gaXtype.getJvmArgumentTypeReferenceAccess();\n\t}\n\tpublic ParserRule getJvmArgumentTypeReferenceRule() {\n\t\treturn getJvmArgumentTypeReferenceAccess().getRule();\n\t}\n\t//JvmWildcardTypeReference:\n\t//\t{JvmWildcardTypeReference} '?' (constraints+=JvmUpperBound constraints+=JvmUpperBoundAnded*\n\t//\t| constraints+=JvmLowerBound constraints+=JvmLowerBoundAnded*)?;\n\tpublic XtypeGrammarAccess.JvmWildcardTypeReferenceElements getJvmWildcardTypeReferenceAccess() {\n\t\treturn gaXtype.getJvmWildcardTypeReferenceAccess();\n\t}\n\tpublic ParserRule getJvmWildcardTypeReferenceRule() {\n\t\treturn getJvmWildcardTypeReferenceAccess().getRule();\n\t}\n\t//JvmUpperBound:\n\t//\t'extends' typeReference=JvmTypeReference;\n\tpublic XtypeGrammarAccess.JvmUpperBoundElements getJvmUpperBoundAccess() {\n\t\treturn gaXtype.getJvmUpperBoundAccess();\n\t}\n\tpublic ParserRule getJvmUpperBoundRule() {\n\t\treturn getJvmUpperBoundAccess().getRule();\n\t}\n\t//JvmUpperBoundAnded JvmUpperBound:\n\t//\t'&' typeReference=JvmTypeReference;\n\tpublic XtypeGrammarAccess.JvmUpperBoundAndedElements getJvmUpperBoundAndedAccess() {\n\t\treturn gaXtype.getJvmUpperBoundAndedAccess();\n\t}\n<fim_suffix>\tpublic ParserRule getJvmUpperBoundAndedRule() {\n\t\treturn getJvmUpperBoundAndedAccess().getRule();\n\t}<fim_middle>// function below has no smell\n"}