{"text": "<fim_prefix>\n<fim_suffix>public class PolylineConnection extends Polyline implements Connection,\n\t\tAnchorListener {\n\tprivate ConnectionAnchor startAnchor, endAnchor;\n\tprivate ConnectionRouter connectionRouter = ConnectionRouter.NULL;\n\tprivate RotatableDecoration startArrow, endArrow;\n\t{\n\t\tsetLayoutManager(new DelegatingLayout());\n\t\taddPoint(new Point(0, 0));\n\t\taddPoint(new Point(100, 100));\n\t}\n\t/**\n\t * Hooks the source and target anchors.\n\t * \n\t * @see Figure#addNotify()\n\t */\n\tpublic void addNotify() {\n\t\tsuper.addNotify();\n\t\thookSourceAnchor();\n\t\thookTargetAnchor();\n\t}\n\t/**\n\t * Appends the given routing listener to the list of listeners.\n\t * \n\t * @param listener\n\t *            the routing listener\n\t * @since 3.2\n\t */\n\tpublic void addRoutingListener(RoutingListener listener) {\n\t\tif (connectionRouter instanceof RoutingNotifier) {\n\t\t\tRoutingNotifier notifier = (RoutingNotifier) connectionRouter;\n\t\t\tnotifier.listeners.add(listener);\n\t\t} else\n\t\t\tconnectionRouter = new RoutingNotifier(connectionRouter, listener);\n\t}\n\t/**\n\t * Called by the anchors of this connection when they have moved,\n\t * revalidating this polyline connection.\n\t * \n\t * @param anchor\n\t *            the anchor that moved\n\t */\n\tpublic void anchorMoved(ConnectionAnchor anchor) {\n\t\trevalidate();\n\t}\n\t/**\n\t * Returns the bounds which holds all the points in this polyline\n\t * connection. Returns any previously existing bounds, else calculates by\n\t * unioning all the children's dimensions.\n\t * \n\t * @return the bounds\n\t */\n\tpublic Rectangle getBounds() {\n\t\tif (bounds == null) {\n\t\t\tsuper.getBounds();\n\t\t\tfor (int i = 0; i < getChildren().size(); i++) {\n\t\t\t\tIFigure child = (IFigure) getChildren().get(i);\n\t\t\t\tbounds.union(child.getBounds());\n\t\t\t}\n\t\t}\n\t\treturn bounds;\n\t}\n\t/**\n\t * Returns the <code>ConnectionRouter</code> used to layout this connection.\n\t * Will not return <code>null</code>.\n\t * \n\t * @return this connection's router\n\t */\n\tpublic ConnectionRouter getConnectionRouter() {\n\t\tif (connectionRouter instanceof RoutingNotifier)\n\t\t\treturn ((RoutingNotifier) connectionRouter).realRouter;\n\t\treturn connectionRouter;\n\t}\n\t/**\n\t * Returns this connection's routing constraint from its connection router.\n\t * May return <code>null</code>.\n\t * \n\t * @return the connection's routing constraint\n\t */\n\tpublic Object getRoutingConstraint() {\n\t\tif (getConnectionRouter() != null)\n\t\t\treturn getConnectionRouter().getConstraint(this);\n\t\telse\n\t\t\treturn null;\n\t}\n\t/**\n\t * @return the anchor at the start of this polyline connection (may be null)\n\t */\n\tpublic ConnectionAnchor getSourceAnchor() {\n\t\treturn startAnchor;\n\t}\n\t/**\n\t * @return the source decoration (may be null)\n\t */\n\tprotected RotatableDecoration getSourceDecoration() {\n\t\treturn startArrow;\n\t}\n\t/**\n\t * @return the anchor at the end of this polyline connection (may be null)\n\t */\n\tpublic ConnectionAnchor getTargetAnchor() {\n\t\treturn endAnchor;\n\t}\n\t/**\n\t * @return the target decoration (may be null)\n\t * \n\t * @since 2.0\n\t */\n\tprotected RotatableDecoration getTargetDecoration() {\n\t\treturn endArrow;\n\t}\n\tprivate void hookSourceAnchor() {\n\t\tif (getSourceAnchor() != null)\n\t\t\tgetSourceAnchor().addAnchorListener(this);\n\t}\n\tprivate void hookTargetAnchor() {\n\t\tif (getTargetAnchor() != null)\n\t\t\tgetTargetAnchor().addAnchorListener(this);\n\t}\n\t/**\n\t * Layouts this polyline. If the start and end anchors are present, the\n\t * connection router is used to route this, after which it is laid out. It\n\t * also fires a moved method.\n\t */\n\tpublic void layout() {\n\t\tif (getSourceAnchor() != null && getTargetAnchor() != null)\n\t\t\tconnectionRouter.route(this);\n\t\tRectangle oldBounds = bounds;\n\t\tsuper.layout();\n\t\tbounds = null;\n\t\tif (!getBounds().contains(oldBounds)) {\n\t\t\tgetParent().translateToParent(oldBounds);\n\t\t\tgetUpdateManager().addDirtyRegion(getParent(), oldBounds);\n\t\t}\n\t\trepaint();\n\t\tfireFigureMoved();\n\t}\n\t/**\n\t * Called just before the receiver is being removed from its parent. Results\n\t * in removing itself from the connection router.\n\t * \n\t * @since 2.0\n\t */\n\tpublic void removeNotify() {\n\t\tunhookSourceAnchor();\n\t\tunhookTargetAnchor();\n\t\tconnectionRouter.remove(this);\n\t\tsuper.removeNotify();\n\t}\n\t/**\n\t * Removes the first occurence of the given listener.\n\t * \n\t * @param listener\n\t *            the listener being removed\n\t * @since 3.2\n\t */\n\tpublic void removeRoutingListener(RoutingListener listener) {\n\t\tif (connectionRouter instanceof RoutingNotifier) {\n\t\t\tRoutingNotifier notifier = (RoutingNotifier) connectionRouter;\n\t\t\tnotifier.listeners.remove(listener);\n\t\t\tif (notifier.listeners.isEmpty())\n\t\t\t\tconnectionRouter = notifier.realRouter;\n\t\t}\n\t}\n\t/**\n\t * @see IFigure#revalidate()\n\t */\n\tpublic void revalidate() {\n\t\tsuper.revalidate();\n\t\tconnectionRouter.invalidate(this);\n\t}\n\t/**\n\t * Sets the connection router which handles the layout of this polyline.\n\t * Generally set by the parent handling the polyline connection.\n\t * \n\t * @param cr\n\t *            the connection router\n\t */\n\tpublic void setConnectionRouter(ConnectionRouter cr) {\n\t\tif (cr == null)\n\t\t\tcr = ConnectionRouter.NULL;\n\t\tConnectionRouter oldRouter = getConnectionRouter();\n\t\tif (oldRouter != cr) {\n\t\t\tconnectionRouter.remove(this);\n\t\t\tif (connectionRouter instanceof RoutingNotifier)\n\t\t\t\t((RoutingNotifier) connectionRouter).realRouter = cr;\n\t\t\telse\n\t\t\t\tconnectionRouter = cr;\n\t\t\tfirePropertyChange(Connection.PROPERTY_CONNECTION_ROUTER,\n\t\t\t\t\toldRouter, cr);\n\t\t\trevalidate();\n\t\t}\n\t}\n\t/**\n\t * Sets the routing constraint for this connection.\n\t * \n\t * @param cons\n\t *            the constraint\n\t */\n\tpublic void setRoutingConstraint(Object cons) {\n\t\tif (connectionRouter != null)\n\t\t\tconnectionRouter.setConstraint(this, cons);\n\t\trevalidate();\n\t}\n\t/**\n\t * Sets the anchor to be used at the start of this polyline connection.\n\t * \n\t * @param anchor\n\t *            the new source anchor\n\t */\n\tpublic void setSourceAnchor(ConnectionAnchor anchor) {\n\t\tif (anchor == startAnchor)\n\t\t\treturn;\n\t\tunhookSourceAnchor();\n\t\t// No longer needed, revalidate does this.\n\t\t// getConnectionRouter().invalidate(this);\n\t\tstartAnchor = anchor;\n\t\tif (getParent() != null)\n\t\t\thookSourceAnchor();\n\t\trevalidate();\n\t}\n\t/**\n\t * Sets the decoration to be used at the start of the {@link Connection}.\n\t * \n\t * @param dec\n\t *            the new source decoration\n\t * @since 2.0\n\t */\n\tpublic void setSourceDecoration(RotatableDecoration dec) {\n\t\tif (startArrow == dec)\n\t\t\treturn;\n\t\tif (startArrow != null)\n\t\t\tremove(startArrow);\n\t\tstartArrow = dec;\n\t\tif (startArrow != null)\n\t\t\tadd(startArrow, new ArrowLocator(this, ConnectionLocator.SOURCE));\n\t}\n\t/**\n\t * Sets the anchor to be used at the end of the polyline connection. Removes\n\t * this listener from the old anchor and adds it to the new anchor.\n\t * \n\t * @param anchor\n\t *            the new target anchor\n\t */\n\tpublic void setTargetAnchor(ConnectionAnchor anchor) {\n\t\tif (anchor == endAnchor)\n\t\t\treturn;\n\t\tunhookTargetAnchor();\n\t\t// No longer needed, revalidate does this.\n\t\t// getConnectionRouter().invalidate(this);\n\t\tendAnchor = anchor;\n\t\tif (getParent() != null)\n\t\t\thookTargetAnchor();\n\t\trevalidate();\n\t}\n\t/**\n\t * Sets the decoration to be used at the end of the {@link Connection}.\n\t * \n\t * @param dec\n\t *            the new target decoration\n\t */\n\tpublic void setTargetDecoration(RotatableDecoration dec) {\n\t\tif (endArrow == dec)\n\t\t\treturn;\n\t\tif (endArrow != null)\n\t\t\tremove(endArrow);\n\t\tendArrow = dec;\n\t\tif (endArrow != null)<fim_middle>// class below is blob and data class\n"}