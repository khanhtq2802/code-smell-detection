{"text": "<fim_prefix>    byte[] d = curatorFramework.getData().storingStatIn(stat).forPath(maxTsPath);\n    // TODO check that d is expected\n    // TODO check that still server when setting\n    // TODO make num allocated variable... when a server first starts allocate a small amount... the\n    // longer it runs and the busier it is, allocate bigger blocks\n    long newMax = Long.parseLong(new String(d)) + 1000;\n    curatorFramework.setData().withVersion(stat.getVersion()).forPath(maxTsPath,\n        LongUtil.toByteArray(newMax));\n    maxTs = newMax;\n    if (!isLeader) {\n      throw new IllegalStateException();\n    }\n  }\n  @Override\n  public Stamps getTimestamps(String id, int num) throws TException {\n    long start = getTimestampsImpl(id, num);\n    // do this outside of sync\n    stampsHistogram.update(num);\n    return new Stamps(start, gcTsTracker.advertisedGcTimetamp);\n  }\n  private synchronized long getTimestampsImpl(String id, int num) throws TException {\n    if (!started) {\n      throw new IllegalStateException(\"Received timestamp request but Oracle has not started\");\n    }\n    if (!id.equals(env.getFluoApplicationID())) {\n      throw new IllegalArgumentException(\"Received timestamp request with a Fluo application ID [\"\n          + id + \"] that does not match the application ID [\" + env.getFluoApplicationID()\n          + \"] of the Oracle\");\n    }\n    if (!isLeader) {\n      throw new IllegalStateException(\"Received timestamp request but Oracle is not leader\");\n    }\n    try {\n      while (num + currentTs >= maxTs) {\n        allocateTimestamp();\n      }\n      long tmp = currentTs;\n      currentTs += num;\n      return tmp;\n    } catch (Exception e) {\n      throw new TException(e);\n    }\n  }\n  @Override\n  public boolean isLeader() {\n    return isLeader;\n  }\n  private boolean isLeader(Participant participant) {\n    return participant != null && participant.isLeader();\n  }\n  @VisibleForTesting\n  public int getPort() {\n    return port;\n  }\n  @VisibleForTesting\n  public boolean isConnected() {\n    return (started && cnxnListener.isConnected());\n  }\n  private InetSocketAddress startServer() throws TTransportException {\n    Preconditions.checkState(\n        curatorFramework != null && curatorFramework.getState() == CuratorFrameworkState.STARTED);\n    if (env.getConfiguration().containsKey(FluoConfigurationImpl.ORACLE_PORT_PROP)) {\n      port = env.getConfiguration().getInt(FluoConfigurationImpl.ORACLE_PORT_PROP);\n      Preconditions.checkArgument(port >= 1 && port <= 65535,\n          FluoConfigurationImpl.ORACLE_PORT_PROP + \" must be valid port (1-65535)\");\n    } else {\n      port = PortUtils.getRandomFreePort();\n    }\n    InetSocketAddress addr = new InetSocketAddress(port);\n    TNonblockingServerSocket socket = new TNonblockingServerSocket(addr);\n    THsHaServer.Args serverArgs = new THsHaServer.Args(socket);\n    TProcessor processor = new OracleService.Processor<OracleService.Iface>(this);\n    serverArgs.processor(processor);\n    serverArgs.maxReadBufferBytes = ORACLE_MAX_READ_BUFFER_BYTES;\n    serverArgs.inputProtocolFactory(new TCompactProtocol.Factory());\n    serverArgs.outputProtocolFactory(new TCompactProtocol.Factory());\n    server = new THsHaServer(serverArgs);\n    serverThread = new Thread(server::serve);\n    serverThread.setDaemon(true);\n    serverThread.start();\n    return addr;\n  }\n  public synchronized void start() throws Exception {\n    if (started) {\n      throw new IllegalStateException();\n    }\n    curatorFramework = CuratorUtil.newAppCurator(env.getConfiguration());\n    curatorFramework.getConnectionStateListenable().addListener(cnxnListener);\n    curatorFramework.start();\n    while (!cnxnListener.isConnected()) {\n      Thread.sleep(200);\n    }\n    final InetSocketAddress addr = startServer();\n    String leaderId = HostUtil.getHostName() + \":\" + addr.getPort();\n    leaderLatch = new LeaderLatch(curatorFramework, ZookeeperPath.ORACLE_SERVER, leaderId);\n    log.info(\"Leader ID = \" + leaderId);\n    execService = Executors.newSingleThreadExecutor(new FluoThreadFactory(\"Oracle Server Worker\"));\n    leaderLatch.addListener(new LeaderLatchListener() {\n      @Override\n      public void notLeader() {\n        isLeader = false;\n        if (started) {\n          // if we stopped the server manually, we shouldn't halt\n          Halt.halt(\"Oracle has lost leadership unexpectedly and is now halting.\");\n        }\n      }\n      @Override\n      public void isLeader() {\n        assumeLeadership();\n      }\n    }, execService);\n    leaderLatch.start();\n    pathChildrenCache = new PathChildrenCache(curatorFramework, oraclePath, true);\n    pathChildrenCache.getListenable().addListener(this);\n    pathChildrenCache.start();\n    while (!cnxnListener.isConnected()) {\n      Thread.sleep(200);\n    }\n    log.info(\"Listening \" + addr);\n    started = true;\n  }\n  private void assumeLeadership() {\n    Preconditions.checkState(!isLeader);\n    // sanity check- make sure previous oracle is no longer listening for connections\n    if (currentLeader != null) {\n      String[] address = currentLeader.getId().split(\":\");\n      String host = address[0];\n      int port = Integer.parseInt(address[1]);\n      OracleService.Client client = getOracleClient(host, port);\n      if (client != null) {\n        try {\n          while (client.isLeader()) {\n            Thread.sleep(500);\n          }\n        } catch (Exception e) {\n          log.debug(\"Exception thrown in takeLeadership()\", e);\n        }\n      }\n    }\n    try {\n      synchronized (this) {\n        byte[] d = curatorFramework.getData().forPath(maxTsPath);\n        currentTs = maxTs = LongUtil.fromByteArray(d);\n      }\n      gcTsTracker = new GcTimestampTracker();\n      gcTsTracker.start();\n      isLeader = true;\n      log.info(\"Assumed leadership \" + leaderLatch.getId());\n    } catch (Exception e) {\n      log.warn(\"Failed to become leader \", e);\n    }\n  }\n  public synchronized void stop() throws Exception {\n    if (started) {\n      isLeader = false;\n      server.stop();\n      serverThread.join();\n      if (gcTsTracker != null) {\n        gcTsTracker.stop();\n      }\n      started = false;\n      currentLeader = null;\n      if (curatorFramework.getState().equals(CuratorFrameworkState.STARTED)) {\n        pathChildrenCache.getListenable().removeListener(this);\n        pathChildrenCache.close();\n        leaderLatch.close();\n        execService.shutdown();\n        execService.awaitTermination(10, TimeUnit.SECONDS);\n        curatorFramework.getConnectionStateListenable().removeListener(cnxnListener);\n        // leaderLatch.close() schedules a background delete, give it a chance to process before\n        // closing curator... this is done to avoid spurious exceptions, see CURATOR-467\n        Uninterruptibles.sleepUninterruptibly(250, TimeUnit.MILLISECONDS);\n        curatorFramework.close();\n      }\n      log.info(\"Oracle server has been stopped.\");\n    }\n  }\n  private OracleService.Client getOracleClient(String host, int port) {\n    try {\n      TTransport transport = new TFastFramedTransport(new TSocket(host, port));\n      transport.open();\n      TProtocol protocol = new TCompactProtocol(transport);\n      log.info(\"Former leader was reachable at \" + host + \":\" + port);\n      return new OracleService.Client(protocol);\n    } catch (TTransportException e) {\n      log.debug(\"Exception thrown in getOracleClient()\", e);\n    } catch (Exception e) {\n      throw new RuntimeException(e);\n    }\n    return null;\n  }\n<fim_suffix>  @Override\n  public void childEvent(CuratorFramework curatorFramework, PathChildrenCacheEvent event)\n      throws Exception {\n    try {\n      if (isConnected() && (event.getType().equals(PathChildrenCacheEvent.Type.CHILD_ADDED)\n          || event.getType().equals(PathChildrenCacheEvent.Type.CHILD_REMOVED)\n          || event.getType().equals(PathChildrenCacheEvent.Type.CHILD_UPDATED))) {\n        synchronized (this) {\n          Participant participant = leaderLatch.getLeader();\n          if (isLeader(participant) && !leaderLatch.hasLeadership()) {\n            // in case current instance becomes leader, we want to know who came before it.\n            currentLeader = participant;\n          }\n        }\n      }\n    } catch (InterruptedException e) {\n      log.warn(\"Oracle leadership watcher has been interrupted unexpectedly\");\n    }\n  }<fim_middle>// function below has no smell\n"}