{"text": "<fim_prefix>      this(protocol, Client.ConnectionId.getConnectionId(\n          addr, protocol, ticket, rpcTimeout, connectionRetryPolicy, conf),\n          conf, factory);\n      this.fallbackToSimpleAuth = fallbackToSimpleAuth;\n    }\n    /**\n     * This constructor takes a connectionId, instead of creating a new one.\n     */\n    private Invoker(Class<?> protocol, Client.ConnectionId connId,\n        Configuration conf, SocketFactory factory) {\n      this.remoteId = connId;\n      this.client = CLIENTS.getClient(conf, factory, RpcResponseWrapper.class);\n      this.protocolName = RPC.getProtocolName(protocol);\n      this.clientProtocolVersion = RPC\n          .getProtocolVersion(protocol);\n    }\n    private RequestHeaderProto constructRpcRequestHeader(Method method) {\n      RequestHeaderProto.Builder builder = RequestHeaderProto\n          .newBuilder();\n      builder.setMethodName(method.getName());\n      // For protobuf, {@code protocol} used when creating client side proxy is\n      // the interface extending BlockingInterface, which has the annotations\n      // such as ProtocolName etc.\n      //\n      // Using Method.getDeclaringClass(), as in WritableEngine to get at\n      // the protocol interface will return BlockingInterface, from where\n      // the annotation ProtocolName and Version cannot be\n      // obtained.\n      //\n      // Hence we simply use the protocol class used to create the proxy.\n      // For PB this may limit the use of mixins on client side.\n      builder.setDeclaringClassProtocolName(protocolName);\n      builder.setClientProtocolVersion(clientProtocolVersion);\n      return builder.build();\n    }\n    /**\n     * This is the client side invoker of RPC method. It only throws\n     * ServiceException, since the invocation proxy expects only\n     * ServiceException to be thrown by the method in case protobuf service.\n     *\n     * ServiceException has the following causes:\n     * <ol>\n     * <li>Exceptions encountered on the client side in this method are\n     * set as cause in ServiceException as is.</li>\n     * <li>Exceptions from the server are wrapped in RemoteException and are\n     * set as cause in ServiceException</li>\n     * </ol>\n     *\n     * Note that the client calling protobuf RPC methods, must handle\n     * ServiceException by getting the cause from the ServiceException. If the\n     * cause is RemoteException, then unwrap it to get the exception thrown by\n     * the server.\n     */\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args)\n        throws ServiceException {\n      long startTime = 0;\n      if (LOG.isDebugEnabled()) {\n        startTime = Time.now();\n      }\n      if (args.length != 2) { // RpcController + Message\n        throw new ServiceException(\"Too many parameters for request. Method: [\"\n            + method.getName() + \"]\" + \", Expected: 2, Actual: \"\n            + args.length);\n      }\n      if (args[1] == null) {\n        throw new ServiceException(\"null param while calling Method: [\"\n            + method.getName() + \"]\");\n      }\n      RequestHeaderProto rpcRequestHeader = constructRpcRequestHeader(method);\n      if (LOG.isTraceEnabled()) {\n        LOG.trace(Thread.currentThread().getId() + \": Call -> \" +\n            remoteId + \": \" + method.getName() +\n            \" {\" + TextFormat.shortDebugString((Message) args[1]) + \"}\");\n      }\n      Message theRequest = (Message) args[1];\n      final RpcResponseWrapper val;\n      try {\n        val = (RpcResponseWrapper) client.call(RPC.RpcKind.RPC_PROTOCOL_BUFFER,\n            new RpcRequestWrapper(rpcRequestHeader, theRequest), remoteId,\n            fallbackToSimpleAuth);\n      } catch (Throwable e) {\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Exception <- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + e + \"}\");\n        }\n        throw new ServiceException(e);\n      }\n      if (LOG.isDebugEnabled()) {\n        long callTime = Time.now() - startTime;\n        LOG.debug(\"Call: \" + method.getName() + \" took \" + callTime + \"ms\");\n      }\n      Message prototype = null;\n      try {\n        prototype = getReturnProtoType(method);\n      } catch (Exception e) {\n        throw new ServiceException(e);\n      }\n      Message returnMessage;\n      try {\n        returnMessage = prototype.newBuilderForType()\n            .mergeFrom(val.theResponseRead).build();\n        if (LOG.isTraceEnabled()) {\n          LOG.trace(Thread.currentThread().getId() + \": Response <- \" +\n              remoteId + \": \" + method.getName() +\n                \" {\" + TextFormat.shortDebugString(returnMessage) + \"}\");\n        }\n      } catch (Throwable e) {\n        throw new ServiceException(e);\n      }\n      return returnMessage;\n    }\n    @Override\n    public void close() throws IOException {\n      if (!isClosed) {\n        isClosed = true;\n        CLIENTS.stopClient(client);\n      }\n    }\n    private Message getReturnProtoType(Method method) throws Exception {\n      if (returnTypes.containsKey(method.getName())) {\n        return returnTypes.get(method.getName());\n      }\n      Class<?> returnType = method.getReturnType();\n      Method newInstMethod = returnType.getMethod(\"getDefaultInstance\");\n      newInstMethod.setAccessible(true);\n      Message prototype = (Message) newInstMethod.invoke(null, (Object[]) null);\n      returnTypes.put(method.getName(), prototype);\n      return prototype;\n    }\n    @Override //RpcInvocationHandler\n    public ConnectionId getConnectionId() {\n      return remoteId;\n    }\n  }\n  interface RpcWrapper extends Writable {\n    int getLength();\n  }\n  /**\n   * Wrapper for Protocol Buffer Requests\n   *\n   * Note while this wrapper is writable, the request on the wire is in\n   * Protobuf. Several methods on {@link org.apache.hadoop.ipc.Server and RPC}\n   * use type Writable as a wrapper to work across multiple RpcEngine kinds.\n   */\n  private static abstract class RpcMessageWithHeader<T extends GeneratedMessage>\n    implements RpcWrapper {\n    T requestHeader;\n    Message theRequest; // for clientSide, the request is here\n    byte[] theRequestRead; // for server side, the request is here\n    public RpcMessageWithHeader() {\n    }\n    public RpcMessageWithHeader(T requestHeader, Message theRequest) {\n      this.requestHeader = requestHeader;\n      this.theRequest = theRequest;\n    }\n    @Override\n    public void write(DataOutput out) throws IOException {\n      OutputStream os = DataOutputOutputStream.constructOutputStream(out);\n      ((Message)requestHeader).writeDelimitedTo(os);\n      theRequest.writeDelimitedTo(os);\n    }\n    @Override\n    public void readFields(DataInput in) throws IOException {\n      requestHeader = parseHeaderFrom(readVarintBytes(in));\n      theRequestRead = readMessageRequest(in);\n    }\n    abstract T parseHeaderFrom(byte[] bytes) throws IOException;\n    byte[] readMessageRequest(DataInput in) throws IOException {\n      return readVarintBytes(in);\n    }\n    private static byte[] readVarintBytes(DataInput in) throws IOException {\n      final int length = ProtoUtil.readRawVarint32(in);\n      final byte[] bytes = new byte[length];\n      in.readFully(bytes);\n      return bytes;\n    }\n    public T getMessageHeader() {\n      return requestHeader;\n    }\n    public byte[] getMessageBytes() {\n      return theRequestRead;\n    }\n    @Override\n    public int getLength() {\n      int headerLen = requestHeader.getSerializedSize();\n      int reqLen;\n      if (theRequest != null) {\n        reqLen = theRequest.getSerializedSize();\n      } else if (theRequestRead != null ) {\n        reqLen = theRequestRead.length;\n      } else {\n        throw new IllegalArgumentException(\n            \"getLength on uninitialized RpcWrapper\");\n      }\n      return CodedOutputStream.computeUInt32SizeNoTag(headerLen) +  headerLen\n          + CodedOutputStream.computeUInt32SizeNoTag(reqLen) + reqLen;\n    }\n  }\n  private static class RpcRequestWrapper\n  extends RpcMessageWithHeader<RequestHeaderProto> {\n    @SuppressWarnings(\"unused\")\n    public RpcRequestWrapper() {}\n    public RpcRequestWrapper(\n        RequestHeaderProto requestHeader, Message theRequest) {\n      super(requestHeader, theRequest);\n    }\n    @Override\n    RequestHeaderProto parseHeaderFrom(byte[] bytes) throws IOException {\n      return RequestHeaderProto.parseFrom(bytes);\n    }\n    @Override\n    public String toString() {\n      return requestHeader.getDeclaringClassProtocolName() + \".\" +\n          requestHeader.getMethodName();\n    }\n  }\n  @InterfaceAudience.LimitedPrivate({\"RPC\"})\n  public static class RpcRequestMessageWrapper\n  extends RpcMessageWithHeader<RpcRequestHeaderProto> {\n    public RpcRequestMessageWrapper() {}\n<fim_suffix>    public RpcRequestMessageWrapper(\n        RpcRequestHeaderProto requestHeader, Message theRequest) {\n      super(requestHeader, theRequest);\n    }<fim_middle>// function below has no smell\n"}