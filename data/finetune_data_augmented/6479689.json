{"text": "<fim_prefix>/*******************************************************************************\n * Copyright (c) 2009, 2018 IBM Corp.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * and Eclipse Distribution License v1.0 which accompany this distribution. \n *\n * The Eclipse Public License is available at \n *    http://www.eclipse.org/legal/epl-v10.html\n * and the Eclipse Distribution License is available at \n *   http://www.eclipse.org/org/documents/edl-v10.php.\n *\n * Contributors:\n *    Dave Locke - initial API and implementation and/or initial documentation\n */\npackage org.eclipse.paho.client.mqttv3.internal;\nimport java.util.Enumeration;\nimport java.util.Hashtable;\nimport java.util.Vector;\nimport org.eclipse.paho.client.mqttv3.MqttDeliveryToken;\nimport org.eclipse.paho.client.mqttv3.MqttException;\nimport org.eclipse.paho.client.mqttv3.MqttToken;\nimport org.eclipse.paho.client.mqttv3.internal.wire.MqttPublish;\nimport org.eclipse.paho.client.mqttv3.internal.wire.MqttWireMessage;\nimport org.eclipse.paho.client.mqttv3.logging.Logger;\nimport org.eclipse.paho.client.mqttv3.logging.LoggerFactory;\n/**\n * Provides a \"token\" based system for storing and tracking actions across \n * multiple threads. \n * When a message is sent, a token is associated with the message\n * and saved using the {@link CommsTokenStore#saveToken(MqttToken, MqttWireMessage)} method. Anyone interested\n * in tacking the state can call one of the wait methods on the token or using \n * the asynchronous listener callback method on the operation. \n * The {@link CommsReceiver} class, on another thread, reads responses back from \n * the network. It uses the response to find the relevant token, which it can then \n * notify. \n * \n * Note:\n *   Ping, connect and disconnect do not have a unique message id as\n *   only one outstanding request of each type is allowed to be outstanding\n */\npublic class CommsTokenStore {\n\tprivate static final String CLASS_NAME = CommsTokenStore.class.getName();\n\tprivate Logger log = LoggerFactory.getLogger(LoggerFactory.MQTT_CLIENT_MSG_CAT, CLASS_NAME);\n\t// Maps message-specific data (usually message IDs) to tokens\n\tprivate Hashtable tokens;\n\tprivate String logContext;\n\tprivate MqttException closedResponse = null;\n\tpublic CommsTokenStore(String logContext) {\n\t\tfinal String methodName = \"<Init>\";\n\t\tlog.setResourceName(logContext);\n\t\tthis.tokens = new Hashtable();\n\t\tthis.logContext = logContext;\n\t\t//@TRACE 308=<>\n\t\tlog.fine(CLASS_NAME,methodName,\"308\");//,new Object[]{message});\n\t}\n\t/**\n\t * Based on the message type that has just been received return the associated\n\t * token from the token store or null if one does not exist.\n\t * @param message whose token is to be returned \n\t * @return token for the requested message\n\t */\n\tpublic MqttToken getToken(MqttWireMessage message) {\n\t\tString key = message.getKey(); \n\t\treturn (MqttToken)tokens.get(key);\n\t}\n\tpublic MqttToken getToken(String key) {\n\t\treturn (MqttToken)tokens.get(key);\n\t}\n\tpublic MqttToken removeToken(MqttWireMessage message) {\n\t\tif (message != null) {\n\t\t\treturn removeToken(message.getKey());\n\t\t}\n\t\treturn null;\n\t}\n\tpublic MqttToken removeToken(String key) {\n\t\tfinal String methodName = \"removeToken\";\n\t\t//@TRACE 306=key={0}\n\t\tlog.fine(CLASS_NAME,methodName,\"306\",new Object[]{key});\n\t\tif ( null != key ){\n\t\t    return (MqttToken) tokens.remove(key);\n\t\t}\n\t\treturn null;\n\t}\n\t/**\n\t * Restores a token after a client restart.  This method could be called\n\t * for a SEND of CONFIRM, but either way, the original SEND is what's \n\t * needed to re-build the token.\n\t * @param message The {@link MqttPublish} message to restore\n\t * @return {@link MqttDeliveryToken}\n\t */\n<fim_suffix>\tprotected MqttDeliveryToken restoreToken(MqttPublish message) {\n\t\tfinal String methodName = \"restoreToken\";\n\t\tMqttDeliveryToken token;\n\t\tsynchronized(tokens) {\n\t\t\tString key = Integer.toString(message.getMessageId());\n\t\t\tif (this.tokens.containsKey(key)) {\n\t\t\t\ttoken = (MqttDeliveryToken)this.tokens.get(key);\n\t\t\t\t//@TRACE 302=existing key={0} message={1} token={2}\n\t\t\t\tlog.fine(CLASS_NAME,methodName, \"302\",new Object[]{key, message,token});\n\t\t\t} else {\n\t\t\t\ttoken = new MqttDeliveryToken(logContext);\n\t\t\t\ttoken.internalTok.setKey(key);\n\t\t\t\tthis.tokens.put(key, token);\n\t\t\t\t//@TRACE 303=creating new token key={0} message={1} token={2}\n\t\t\t\tlog.fine(CLASS_NAME,methodName,\"303\",new Object[]{key, message, token});\n\t\t\t}\n\t\t}\n\t\treturn token;\n\t}\n\t// For outbound messages store the token in the token store \n\t// For pubrel use the existing publish token \n\tprotected void saveToken(MqttToken token, MqttWireMessage message) throws MqttException {\n\t\tfinal String methodName = \"saveToken\";\n\t\tsynchronized(tokens) {\n\t\t\tif (closedResponse == null) {\n\t\t\t\tString key = message.getKey();\n\t\t\t\t//@TRACE 300=key={0} message={1}\n\t\t\t\tlog.fine(CLASS_NAME,methodName,\"300\",new Object[]{key, message});\n\t\t\t\tsaveToken(token,key);\n\t\t\t} else {\n\t\t\t\tthrow closedResponse;\n\t\t\t}\n\t\t}\n\t}\n\tprotected void saveToken(MqttToken token, String key) {\n\t\tfinal String methodName = \"saveToken\";\n\t\tsynchronized(tokens) {\n\t\t\t//@TRACE 307=key={0} token={1}\n\t\t\tlog.fine(CLASS_NAME,methodName,\"307\",new Object[]{key,token.toString()});\n\t\t\ttoken.internalTok.setKey(key);\n\t\t\tthis.tokens.put(key, token);\n\t\t}\n\t}\n\tprotected void quiesce(MqttException quiesceResponse) {\n\t\tfinal String methodName = \"quiesce\";\n\t\tsynchronized(tokens) {\n\t\t\t//@TRACE 309=resp={0}\n\t\t\tlog.fine(CLASS_NAME,methodName,\"309\",new Object[]{quiesceResponse});\n\t\t\tclosedResponse = quiesceResponse;\n\t\t}\n\t}\n\tpublic void open() {\n\t\tfinal String methodName = \"open\";\n\t\tsynchronized(tokens) {\n\t\t\t//@TRACE 310=>\n\t\t\tlog.fine(CLASS_NAME,methodName,\"310\");\n\t\t\tclosedResponse = null;\n\t\t}\n\t}\n\tpublic MqttDeliveryToken[] getOutstandingDelTokens() {\n\t\tfinal String methodName = \"getOutstandingDelTokens\";\n\t\tsynchronized(tokens) {\n\t\t\t//@TRACE 311=>\n\t\t\tlog.fine(CLASS_NAME,methodName,\"311\");\n\t\t\tVector list = new Vector();\n\t\t\tEnumeration enumeration = tokens.elements();\n\t\t\tMqttToken token;\n\t\t\twhile(enumeration.hasMoreElements()) {\n\t\t\t\ttoken = (MqttToken)enumeration.nextElement();\n\t\t\t\tif (token != null \n\t\t\t\t\t&& token instanceof MqttDeliveryToken \n\t\t\t\t\t&& !token.internalTok.isNotified()) {\n\t\t\t\t\tlist.addElement(token);\n\t\t\t\t}\n\t\t\t}\n\t\t\tMqttDeliveryToken[] result = new MqttDeliveryToken[list.size()];\n\t\t\treturn (MqttDeliveryToken[]) list.toArray(result);\n\t\t}\n\t}\n\tpublic Vector getOutstandingTokens() {\n\t\tfinal String methodName = \"getOutstandingTokens\";\n\t\tsynchronized(tokens) {\n\t\t\t//@TRACE 312=>\n\t\t\tlog.fine(CLASS_NAME,methodName,\"312\");\n\t\t\tVector list = new Vector();\n\t\t\tEnumeration enumeration = tokens.elements();\n\t\t\tMqttToken token;\n\t\t\twhile(enumeration.hasMoreElements()) {\n\t\t\t\ttoken = (MqttToken)enumeration.nextElement();\n\t\t\t\tif (token != null) {\n\t\t\t\t\t\tlist.addElement(token);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn list;\n\t\t}\n\t}\n\t/**\n\t * Empties the token store without notifying any of the tokens.\n\t */\n\tpublic void clear() {\n\t\tfinal String methodName = \"clear\";\n\t\t//@TRACE 305=> {0} tokens<fim_middle>// function below has no smell\n"}