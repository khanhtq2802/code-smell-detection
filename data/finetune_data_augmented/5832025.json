{"text": "<fim_prefix>\n<fim_suffix>public class Socket {\n    /* Standard socket defines */\n    public static final int SOCK_STREAM = 0;\n    public static final int SOCK_DGRAM  = 1;\n    /*\n     * apr_sockopt Socket option definitions\n     */\n    public static final int APR_SO_LINGER       = 1;    /** Linger */\n    public static final int APR_SO_KEEPALIVE    = 2;    /** Keepalive */\n    public static final int APR_SO_DEBUG        = 4;    /** Debug */\n    public static final int APR_SO_NONBLOCK     = 8;    /** Non-blocking IO */\n    public static final int APR_SO_REUSEADDR    = 16;   /** Reuse addresses */\n    public static final int APR_SO_SNDBUF       = 64;   /** Send buffer */\n    public static final int APR_SO_RCVBUF       = 128;  /** Receive buffer */\n    public static final int APR_SO_DISCONNECTED = 256;  /** Disconnected */\n    /** For SCTP sockets, this is mapped to STCP_NODELAY internally. */\n    public static final int APR_TCP_NODELAY     = 512;\n    public static final int APR_TCP_NOPUSH      = 1024; /** No push */\n    /** This flag is ONLY set internally when we set APR_TCP_NOPUSH with\n     * APR_TCP_NODELAY set to tell us that APR_TCP_NODELAY should be turned on\n     * again when NOPUSH is turned off\n     */\n    public static final int APR_RESET_NODELAY   = 2048;\n    /** Set on non-blocking sockets (timeout != 0) on which the\n     * previous read() did not fill a buffer completely.  the next\n     * apr_socket_recv()  will first call select()/poll() rather than\n     * going straight into read().  (Can also be set by an application to\n     * force a select()/poll() call before the next read, in cases where\n     * the app expects that an immediate read would fail.)\n     */\n    public static final int APR_INCOMPLETE_READ = 4096;\n    /** like APR_INCOMPLETE_READ, but for write\n     */\n    public static final int APR_INCOMPLETE_WRITE = 8192;\n    /** Don't accept IPv4 connections on an IPv6 listening socket.\n     */\n    public static final int APR_IPV6_V6ONLY      = 16384;\n    /** Delay accepting of new connections until data is available.\n     */\n    public static final int APR_TCP_DEFER_ACCEPT = 32768;\n    /** Define what type of socket shutdown should occur.\n     * apr_shutdown_how_e enum\n     */\n    public static final int APR_SHUTDOWN_READ      = 0; /** no longer allow read request */\n    public static final int APR_SHUTDOWN_WRITE     = 1; /** no longer allow write requests */\n    public static final int APR_SHUTDOWN_READWRITE = 2; /** no longer allow read or write requests */\n    public static final int APR_IPV4_ADDR_OK = 0x01;\n    public static final int APR_IPV6_ADDR_OK = 0x02;\n    public static final int APR_UNSPEC = 0;\n    public static final int APR_INET   = 1;\n    public static final int APR_INET6  = 2;\n    public static final int APR_PROTO_TCP  =   6; /** TCP  */\n    public static final int APR_PROTO_UDP  =  17; /** UDP  */\n    public static final int APR_PROTO_SCTP = 132; /** SCTP */\n    /**\n     * Enum to tell us if we're interested in remote or local socket\n     * apr_interface_e\n     */\n    public static final int APR_LOCAL  = 0;\n    public static final int APR_REMOTE = 1;\n    /* Socket.get types */\n    public static final int SOCKET_GET_POOL = 0;\n    public static final int SOCKET_GET_IMPL = 1;\n    public static final int SOCKET_GET_APRS = 2;\n    public static final int SOCKET_GET_TYPE = 3;\n    /**\n     * Create a socket.\n     * @param family The address family of the socket (e.g., APR_INET).\n     * @param type The type of the socket (e.g., SOCK_STREAM).\n     * @param protocol The protocol of the socket (e.g., APR_PROTO_TCP).\n     * @param cont The parent pool to use\n     * @return The new socket that has been set up.\n     * @throws Exception Error creating socket\n     */\n    public static native long create(int family, int type,\n                                     int protocol, long cont)\n        throws Exception;\n    /**\n     * Shutdown either reading, writing, or both sides of a socket.\n     * <br>\n     * This does not actually close the socket descriptor, it just\n     *      controls which calls are still valid on the socket.\n     * @param thesocket The socket to close\n     * @param how How to shutdown the socket.  One of:\n     * <PRE>\n     * APR_SHUTDOWN_READ         no longer allow read requests\n     * APR_SHUTDOWN_WRITE        no longer allow write requests\n     * APR_SHUTDOWN_READWRITE    no longer allow read or write requests\n     * </PRE>\n     * @return the operation status\n     */\n    public static native int shutdown(long thesocket, int how);\n    /**\n     * Close a socket.\n     * @param thesocket The socket to close\n     * @return the operation status\n     */\n    public static native int close(long thesocket);\n    /**\n     * Destroy a pool associated with socket\n     * @param thesocket The destroy\n     */\n    public static native void destroy(long thesocket);\n    /**\n     * Bind the socket to its associated port\n     * @param sock The socket to bind\n     * @param sa The socket address to bind to\n     * This may be where we will find out if there is any other process\n     *      using the selected port.\n     * @return the operation status\n     */\n    public static native int bind(long sock, long sa);\n    /**\n     * Listen to a bound socket for connections.\n     * @param sock The socket to listen on\n     * @param backlog The number of outstanding connections allowed in the sockets\n     *                listen queue.  If this value is less than zero, the listen\n     *                queue size is set to zero.\n     * @return the operation status\n     */\n    public static native int listen(long sock, int backlog);\n    /**\n     * Accept a new connection request\n     * @param sock The socket we are listening on.\n     * @param pool The pool for the new socket.\n     * @return  A copy of the socket that is connected to the socket that\n     *          made the connection request.  This is the socket which should\n     *          be used for all future communication.\n     * @throws Exception Socket accept error\n     */\n    public static native long acceptx(long sock, long pool)\n        throws Exception;\n    /**\n     * Accept a new connection request\n     * @param sock The socket we are listening on.\n     * @return  A copy of the socket that is connected to the socket that\n     *          made the connection request.  This is the socket which should\n     *          be used for all future communication.\n     * @throws Exception Socket accept error\n     */\n    public static native long accept(long sock)\n        throws Exception;\n    /**\n     * Set an OS level accept filter.\n     * @param sock The socket to put the accept filter on.\n     * @param name The accept filter\n     * @param args Any extra args to the accept filter.  Passing NULL here removes\n     *             the accept filter.\n     * @return the operation status\n     */\n    public static native int acceptfilter(long sock, String name, String args);\n    /**\n     * Query the specified socket if at the OOB/Urgent data mark\n     * @param sock The socket to query\n     * @return <code>true</code> if socket is at the OOB/urgent mark,\n     *         otherwise <code>false</code>.\n     */\n    public static native boolean atmark(long sock);\n    /**\n     * Issue a connection request to a socket either on the same machine\n     * or a different one.\n     * @param sock The socket we wish to use for our side of the connection\n     * @param sa The address of the machine we wish to connect to.\n     * @return the operation status\n     */\n    public static native int connect(long sock, long sa);\n    /**\n     * Send data over a network.\n     * <PRE>\n     * This functions acts like a blocking write by default.  To change\n     * this behavior, use apr_socket_timeout_set() or the APR_SO_NONBLOCK\n     * socket option.\n     *\n     * It is possible for both bytes to be sent and an error to be returned.\n     *\n     * APR_EINTR is never returned.\n     * </PRE>\n     * @param sock The socket to send the data over.\n     * @param buf The buffer which contains the data to be sent.\n     * @param offset Offset in the byte buffer.<fim_middle>// class below is data class\n"}