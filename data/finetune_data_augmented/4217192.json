{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.chain2.web.servlet;\n\nimport org.apache.commons.chain2.Catalog;\nimport org.apache.commons.chain2.Command;\nimport org.apache.commons.chain2.Context;\nimport org.apache.commons.chain2.base.LookupCommand;\n\nimport javax.servlet.http.HttpServletRequest;\n\n/**\n * <p>{@link Command} that uses the \"servlet path\" component of the request URI\n * to select a {@link Command} from the appropriate {@link Catalog}, and\n * execute it.  To use this command, you would typically map an instance\n * of {@link ChainProcessor} to an extension pattern like \"*.execute\" and\n * then arrange that this is the default command to be executed.  In such\n * an environment, a request for a context relative URI of \"/foo.execute\"\n * would cause the \"/foo.execute\" command to be loaded and executed.</p>\n *\n * @version $Id$\n */\npublic class ServletPathMapper extends LookupCommand<String, Object, ServletWebContext<String, Object>> {\n\n    // --------------------------------------------------------- Command Methods\n\n    /**\n     * <p>Look up the servlet path information for this request, and use it to\n     * select an appropriate {@link Command} to be executed.\n     *\n     * @param swcontext Context for the current request\n     * @return The name of the {@link Command} instance\n     *\n     * @since Chain 1.2\n     */\n    @Override\n    protected String getCommandName(ServletWebContext<String, Object> swcontext) {\n        // Look up the servlet path for this request\n        HttpServletRequest request = swcontext.getRequest();\n        String servletPath = (String)\n            request.getAttribute(\"javax.servlet.include.servlet_path\");\n        if (servletPath == null) {\n            servletPath = request.getServletPath();\n        }\n\n        return servletPath;\n    }\n\n    /**\n     * <p>Return the {@link Catalog} to look up the {@link Command} in.</p>\n     *\n     * @param context {@link Context} for this request\n     * @return The catalog.\n     * @throws IllegalArgumentException if no {@link Catalog}\n     *  can be found\n     *\n     * @since Chain 1.2\n     */\n<fim_suffix>    @Override\n    protected Catalog<String, Object, ServletWebContext<String, Object>>\n            getCatalog(ServletWebContext<String, Object> context) {\n        /* If the object returned from the passed context is not a valid catalog\n         * then we use the super class's catalog extraction logic to pull it\n         * or to error gracefully.\n         */\n        Object testCatalog = context.get(getCatalogName());\n\n        /* Assume that the underlying implementation is following convention and\n         * returning a catalog with the current context.\n         */\n        @SuppressWarnings(\"unchecked\")\n        Catalog<String, Object, ServletWebContext<String, Object>> catalog =\n                testCatalog != null && testCatalog instanceof Catalog ?\n                    (Catalog<String, Object, ServletWebContext<String, Object>>) testCatalog :\n                    super.getCatalog(context);\n\n        return catalog;\n    }\n\n}<fim_middle>// function below has no smell\n"}