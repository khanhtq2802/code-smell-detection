{"text": "<fim_prefix>package org.apache.archiva.consumers.metadata;\n\n/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.archiva.common.utils.VersionUtil;\nimport org.apache.archiva.configuration.ArchivaConfiguration;\nimport org.apache.archiva.configuration.ConfigurationNames;\nimport org.apache.archiva.configuration.FileTypes;\nimport org.apache.archiva.consumers.AbstractMonitoredConsumer;\nimport org.apache.archiva.consumers.ConsumerException;\nimport org.apache.archiva.consumers.KnownRepositoryContentConsumer;\nimport org.apache.archiva.metadata.model.ArtifactMetadata;\nimport org.apache.archiva.metadata.model.ProjectMetadata;\nimport org.apache.archiva.metadata.model.ProjectVersionMetadata;\nimport org.apache.archiva.metadata.repository.MetadataRepository;\nimport org.apache.archiva.metadata.repository.MetadataRepositoryException;\nimport org.apache.archiva.metadata.repository.RepositorySession;\nimport org.apache.archiva.metadata.repository.RepositorySessionFactory;\nimport org.apache.archiva.metadata.repository.storage.ReadMetadataRequest;\nimport org.apache.archiva.metadata.repository.storage.RepositoryStorage;\nimport org.apache.archiva.metadata.repository.storage.RepositoryStorageMetadataInvalidException;\nimport org.apache.archiva.metadata.repository.storage.RepositoryStorageMetadataNotFoundException;\nimport org.apache.archiva.metadata.repository.storage.RepositoryStorageRuntimeException;\nimport org.apache.archiva.redback.components.registry.Registry;\nimport org.apache.archiva.redback.components.registry.RegistryListener;\nimport org.apache.archiva.repository.ManagedRepository;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.context.annotation.Scope;\nimport org.springframework.stereotype.Service;\n\nimport javax.annotation.PostConstruct;\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\n\n/**\n * Take an artifact off of disk and put it into the metadata repository.\n */\n<fim_suffix>@Service (\"knownRepositoryContentConsumer#create-archiva-metadata\")\n@Scope (\"prototype\")\npublic class ArchivaMetadataCreationConsumer\n    extends AbstractMonitoredConsumer\n    implements KnownRepositoryContentConsumer, RegistryListener\n{\n    private String id = \"create-archiva-metadata\";\n\n    private String description = \"Create basic metadata for Archiva to be able to reference the artifact\";\n\n    @Inject\n    private ArchivaConfiguration configuration;\n\n    @Inject\n    private FileTypes filetypes;\n\n    private Date whenGathered;\n\n    private List<String> includes = new ArrayList<>( 0 );\n\n    /**\n     * FIXME: this could be multiple implementations and needs to be configured.\n     */\n    @Inject\n    private RepositorySessionFactory repositorySessionFactory;\n\n    /**\n     * FIXME: this needs to be configurable based on storage type - and could also be instantiated per repo. Change to a\n     * factory.\n     */\n    @Inject\n    @Named (value = \"repositoryStorage#maven2\")\n    private RepositoryStorage repositoryStorage;\n\n    private static final Logger log = LoggerFactory.getLogger( ArchivaMetadataCreationConsumer.class );\n\n    private String repoId;\n\n    @Override\n    public String getId()\n    {\n        return this.id;\n    }\n\n    @Override\n    public String getDescription()\n    {\n        return this.description;\n    }\n\n    @Override\n    public List<String> getExcludes()\n    {\n        return getDefaultArtifactExclusions();\n    }\n\n    @Override\n    public List<String> getIncludes()\n    {\n        return this.includes;\n    }\n\n    @Override\n    public void beginScan( ManagedRepository repo, Date whenGathered )\n        throws ConsumerException\n    {\n        repoId = repo.getId();\n        this.whenGathered = whenGathered;\n    }\n\n    @Override\n    public void beginScan( ManagedRepository repository, Date whenGathered, boolean executeOnEntireRepo )\n        throws ConsumerException\n    {\n        beginScan( repository, whenGathered );\n    }\n\n    @Override\n    public void processFile( String path )\n        throws ConsumerException\n    {\n\n        RepositorySession repositorySession = repositorySessionFactory.createSession();\n        try\n        {\n            // note that we do minimal processing including checksums and POM information for performance of\n            // the initial scan. Any request for this information will be intercepted and populated on-demand\n            // or picked up by subsequent scans\n\n            ArtifactMetadata artifact = repositoryStorage.readArtifactMetadataFromPath( repoId, path );\n\n            ProjectMetadata project = new ProjectMetadata();\n            project.setNamespace( artifact.getNamespace() );\n            project.setId( artifact.getProject() );\n\n            String projectVersion = VersionUtil.getBaseVersion( artifact.getVersion() );\n\n            MetadataRepository metadataRepository = repositorySession.getRepository();\n\n            boolean createVersionMetadata = false;\n\n            // FIXME: maybe not too efficient since it may have already been read and stored for this artifact\n            ProjectVersionMetadata versionMetadata = null;\n            try\n            {\n                ReadMetadataRequest readMetadataRequest =\n                    new ReadMetadataRequest().repositoryId( repoId ).namespace( artifact.getNamespace() ).projectId(\n                        artifact.getProject() ).projectVersion( projectVersion );\n                versionMetadata = repositoryStorage.readProjectVersionMetadata( readMetadataRequest );\n                createVersionMetadata = true;\n            }\n            catch ( RepositoryStorageMetadataNotFoundException e )\n            {\n                log.warn( \"Missing or invalid POM for artifact:{} (repository:{}); creating empty metadata\", path,\n                          repoId );\n\n                versionMetadata = new ProjectVersionMetadata();\n                versionMetadata.setId( projectVersion );\n                versionMetadata.setIncomplete( true );\n                createVersionMetadata = true;\n            }\n            catch ( RepositoryStorageMetadataInvalidException e )\n            {\n                log.warn( \"Error occurred resolving POM for artifact:{} (repository:{}); message: {}\",\n                          new Object[]{ path, repoId, e.getMessage() } );\n            }\n\n            // read the metadata and update it if it is newer or doesn't exist\n            artifact.setWhenGathered( whenGathered );\n            metadataRepository.updateArtifact( repoId, project.getNamespace(), project.getId(), projectVersion,\n                                               artifact );\n            if ( createVersionMetadata )\n            {\n                metadataRepository.updateProjectVersion( repoId, project.getNamespace(), project.getId(),\n                                                         versionMetadata );\n            }\n            metadataRepository.updateProject( repoId, project );\n            repositorySession.save();\n        }\n        catch ( MetadataRepositoryException e )\n        {\n            log.warn(\n                \"Error occurred persisting metadata for artifact:{} (repository:{}); message: {}\" ,\n                path, repoId, e.getMessage(), e );\n            repositorySession.revert();\n        }\n        catch ( RepositoryStorageRuntimeException e )\n        {\n            log.warn(\n                \"Error occurred persisting metadata for artifact:{} (repository:{}); message: {}\",\n                path, repoId, e.getMessage(), e );\n            repositorySession.revert();\n        }\n        finally\n        {\n            repositorySession.close();\n        }\n    }\n\n    @Override\n    public void processFile( String path, boolean executeOnEntireRepo )\n        throws ConsumerException\n    {\n        processFile( path );\n    }\n\n    @Override\n    public void completeScan()\n    {\n        /* do nothing */\n    }\n\n    @Override\n    public void completeScan( boolean executeOnEntireRepo )\n    {\n        completeScan();\n    }\n\n    @Override\n    public void afterConfigurationChange( Registry registry, String propertyName, Object propertyValue )\n    {\n        if ( ConfigurationNames.isRepositoryScanning( propertyName ) )\n        {\n            initIncludes();\n        }\n    }\n\n    @Override\n    public void beforeConfigurationChange( Registry registry, String propertyName, Object propertyValue )\n    {\n        /* do nothing */\n    }\n\n    private void initIncludes()\n    {\n        includes = new ArrayList<String>( filetypes.getFileTypePatterns( FileTypes.ARTIFACTS ) );\n    }\n\n    @PostConstruct\n    public void initialize()\n    {\n        configuration.addChangeListener( this );\n\n        initIncludes();\n    }\n}<fim_middle>// class below is blob\n"}