{"text": "<fim_prefix>/*\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.\n *\n * Copyright 1997-2010 Oracle and/or its affiliates. All rights reserved.\n *\n * Oracle and Java are registered trademarks of Oracle and/or its affiliates.\n * Other names may be trademarks of their respective owners.\n *\n * The contents of this file are subject to the terms of either the GNU\n * General Public License Version 2 only (\"GPL\") or the Common\n * Development and Distribution License(\"CDDL\") (collectively, the\n * \"License\"). You may not use this file except in compliance with the\n * License. You can obtain a copy of the License at\n * http://www.netbeans.org/cddl-gplv2.html\n * or nbbuild/licenses/CDDL-GPL-2-CP. See the License for the\n * specific language governing permissions and limitations under the\n * License.  When distributing the software, include this License Header\n * Notice in each file and include the License file at\n * nbbuild/licenses/CDDL-GPL-2-CP.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the GPL Version 2 section of the License file that\n * accompanied this code. If applicable, add the following below the\n * License Header, with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * Contributor(s):\n * The Original Software is NetBeans. The Initial Developer of the Original\n * Software is Sun Microsystems, Inc. Portions Copyright 1997-2006 Sun\n * Microsystems, Inc. All Rights Reserved.\n *\n * If you wish your version of this file to be governed by only the CDDL\n * or only the GPL Version 2, indicate your decision by adding\n * \"[Contributor] elects to include this software in this distribution\n * under the [CDDL or GPL Version 2] license.\" If you do not indicate a\n * single choice of license, a recipient has the option to distribute\n * your version of this file under either the CDDL, the GPL Version 2 or\n * to extend the choice of license to its licensees as provided above.\n * However, if you add GPL Version 2 code and therefore, elected the GPL\n * Version 2 license, then the option applies only if the new code is\n * made subject to such option by the copyright holder.\n */\n\npackage org.graalvm.visualvm.lib.profiler.heapwalk.memorylint.rules;\n\nimport org.graalvm.visualvm.lib.jfluid.heap.Heap;\nimport org.graalvm.visualvm.lib.jfluid.heap.Instance;\nimport org.graalvm.visualvm.lib.jfluid.heap.JavaClass;\nimport org.graalvm.visualvm.lib.jfluid.heap.ObjectArrayInstance;\nimport org.graalvm.visualvm.lib.profiler.heapwalk.memorylint.*;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport org.openide.util.NbBundle;\n\n\n//@org.openide.util.lookup.ServiceProvider(service=org.graalvm.visualvm.lib.profiler.heapwalk.memorylint.Rule.class)\n<fim_suffix>public class WrongWeakHashMap extends IteratingRule {\n    //~ Inner Classes ------------------------------------------------------------------------------------------------------------\n\n    private class WHMRecord {\n        //~ Instance fields ------------------------------------------------------------------------------------------------------\n\n        private Instance hm;\n        private Instance key;\n        private Instance value;\n\n        //~ Constructors ---------------------------------------------------------------------------------------------------------\n\n        WHMRecord(Instance hm, Instance key, Instance value) {\n            this.hm = hm;\n            this.key = key;\n            this.value = value;\n        }\n\n        //~ Methods --------------------------------------------------------------------------------------------------------------\n\n        @Override\n        public String toString() {\n            return NbBundle.getMessage(WrongWeakHashMap.class, \"FMT_WWHM_Entry\",\n                    new Object[] {\n                        Utils.printClass(getContext(), getContext().getRootIncommingString(hm)),\n                        Utils.printInstance(hm),\n                        Utils.printInstance(key),\n                        Utils.printInstance(value)\n                    }\n            );\n        }\n    }\n\n    //~ Instance fields ----------------------------------------------------------------------------------------------------------\n\n    private FieldAccess fldHMEKey;\n    private FieldAccess fldHMENext;\n    private FieldAccess fldHMEValue;\n    private FieldAccess fldHMTable;\n    private JavaClass clsHM;\n    private JavaClass clsHME;\n    private Set<WHMRecord> poorWHM = new HashSet<WHMRecord>();\n\n    //~ Constructors -------------------------------------------------------------------------------------------------------------\n\n    public WrongWeakHashMap() {\n        super(NbBundle.getMessage(WrongWeakHashMap.class, \"LBL_WWHM_Name\"),\n                NbBundle.getMessage(WrongWeakHashMap.class, \"LBL_WWHM_Desc\"),\n                \"java.util.WeakHashMap\");\n        \n    }\n\n    //~ Methods ------------------------------------------------------------------------------------------------------------------\n    \n    @Override\n    public String getHTMLDescription() {\n        return NbBundle.getMessage(WrongWeakHashMap.class, \"LBL_WWHM_LongDesc\");\n    }\n\n    protected void perform(Instance hm) {\n        scanWeakHashmap(hm);\n    }\n\n    @Override\n    protected void prepareRule(MemoryLint context) {\n        // TODO WeakHashMap might not be present in the dump\n        Heap heap = context.getHeap();\n        clsHM = heap.getJavaClassByName(\"java.util.WeakHashMap\"); // NOI18N\n        clsHME = heap.getJavaClassByName(\"java.util.WeakHashMap$Entry\"); // NOI18N\n        fldHMTable = new FieldAccess(clsHM, \"table\"); // NOI18N\n\n        JavaClass ref = heap.getJavaClassByName(\"java.lang.ref.Reference\"); // NOI18N\n        fldHMEKey = new FieldAccess(ref, \"referent\"); // NOI18N\n        fldHMEValue = new FieldAccess(clsHME, \"value\"); // NOI18N\n        fldHMENext = new FieldAccess(clsHME, \"next\"); // NOI18N\n    }\n\n    @Override\n    protected void summary() {\n        for (WHMRecord whm : poorWHM) {\n            getContext().appendResults(whm.toString());\n        }\n    }\n\n    private void scanWeakHashmap(Instance hm) {\n        ObjectArrayInstance table = (ObjectArrayInstance) fldHMTable.getRefValue(hm);\n\n        if (table == null) { // ? \n\n            return;\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        List<Instance> tval = table.getValues();\n\n        for (Instance entry : tval) {\n            while (entry != null) {\n                Instance key = fldHMEKey.getRefValue(entry);\n\n                if (key != null) { // XXX can also scan for weak HM pending cleanup\n\n                    Instance value = fldHMEValue.getRefValue(entry);\n\n                    if (Utils.isReachableFrom(value, key)) {\n                        poorWHM.add(new WHMRecord(hm, key, value));\n\n                        return;\n                    }\n                }\n\n                entry = fldHMENext.getRefValue(entry);\n            }\n        }\n\n        return;\n    }\n}<fim_middle>// class below has no smell\n"}