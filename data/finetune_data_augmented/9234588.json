{"text": "<fim_prefix>            // performed during key exchanging in a handshake.\n            return !hasFFDHEGroups && type == NamedGroupType.NAMED_GROUP_FFDHE;\n        }\n        // Is the named group permitted by the constraints?\n        static boolean isActivatable(\n                AlgorithmConstraints constraints, NamedGroup namedGroup) {\n            if (!isSupported(namedGroup)) {\n                return false;\n            }\n            return constraints.permits(\n                            EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),\n                            namedGroup.algorithm,\n                            namedGroupParams.get(namedGroup));\n        }\n        // Is the named group supported?\n        static boolean isSupported(NamedGroup namedGroup) {\n            for (NamedGroup group : supportedNamedGroups) {\n                if (namedGroup.id == group.id) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        static NamedGroup getPreferredGroup(\n                ProtocolVersion negotiatedProtocol,\n                AlgorithmConstraints constraints, NamedGroupType type,\n                List<NamedGroup> requestedNamedGroups) {\n            for (NamedGroup namedGroup : requestedNamedGroups) {\n                if ((namedGroup.type == type) &&\n                        namedGroup.isAvailable(negotiatedProtocol) &&\n                        isSupported(namedGroup) &&\n                        constraints.permits(\n                                EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),\n                                namedGroup.algorithm,\n                                namedGroupParams.get(namedGroup))) {\n                    return namedGroup;\n                }\n            }\n            return null;\n        }\n        static NamedGroup getPreferredGroup(\n                ProtocolVersion negotiatedProtocol,\n                AlgorithmConstraints constraints, NamedGroupType type) {\n            for (NamedGroup namedGroup : supportedNamedGroups) {\n                if ((namedGroup.type == type) &&\n                        namedGroup.isAvailable(negotiatedProtocol) &&\n                        constraints.permits(\n                                EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),\n                                namedGroup.algorithm,\n                                namedGroupParams.get(namedGroup))) {\n                    return namedGroup;\n                }\n            }\n            return null;\n        }\n    }\n    /**\n     * Network data producer of a \"supported_groups\" extension in\n     * the ClientHello handshake message.\n     */\n    private static final class CHSupportedGroupsProducer\n            extends SupportedGroups implements HandshakeProducer {\n        // Prevent instantiation of this class.\n        private CHSupportedGroupsProducer() {\n            // blank\n        }\n        @Override\n        public byte[] produce(ConnectionContext context,\n                HandshakeMessage message) throws IOException {\n            // The producing happens in client side only.\n            ClientHandshakeContext chc = (ClientHandshakeContext)context;\n            // Is it a supported and enabled extension?\n            if (!chc.sslConfig.isAvailable(CH_SUPPORTED_GROUPS)) {\n                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n                    SSLLogger.fine(\n                        \"Ignore unavailable supported_groups extension\");\n                }\n                return null;\n            }\n            // Produce the extension.\n            ArrayList<NamedGroup> namedGroups =\n                new ArrayList<>(SupportedGroups.supportedNamedGroups.length);\n            for (NamedGroup ng : SupportedGroups.supportedNamedGroups) {\n                if ((!SupportedGroups.enableFFDHE) &&\n                    (ng.type == NamedGroupType.NAMED_GROUP_FFDHE)) {\n                    continue;\n                }\n                if (ng.isAvailable(chc.activeProtocols) &&\n                        ng.isSupported(chc.activeCipherSuites) &&\n                        chc.algorithmConstraints.permits(\n                            EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),\n                            ng.algorithm, namedGroupParams.get(ng))) {\n                    namedGroups.add(ng);\n                } else if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n                    SSLLogger.fine(\n                        \"Ignore inactive or disabled named group: \" + ng.name);\n                }\n            }\n            if (namedGroups.isEmpty()) {\n                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n                    SSLLogger.warning(\"no available named group\");\n                }\n                return null;\n            }\n            int vectorLen = namedGroups.size() << 1;\n            byte[] extData = new byte[vectorLen + 2];\n            ByteBuffer m = ByteBuffer.wrap(extData);\n            Record.putInt16(m, vectorLen);\n            for (NamedGroup namedGroup : namedGroups) {\n                    Record.putInt16(m, namedGroup.id);\n            }\n            // Update the context.\n            chc.clientRequestedNamedGroups =\n                    Collections.<NamedGroup>unmodifiableList(namedGroups);\n            chc.handshakeExtensions.put(CH_SUPPORTED_GROUPS,\n                    new SupportedGroupsSpec(namedGroups));\n            return extData;\n        }\n    }\n    /**\n     * Network data producer of a \"supported_groups\" extension in\n     * the ClientHello handshake message.\n     */\n    private static final\n            class CHSupportedGroupsConsumer implements ExtensionConsumer {\n        // Prevent instantiation of this class.\n        private CHSupportedGroupsConsumer() {\n            // blank\n        }\n        @Override\n        public void consume(ConnectionContext context,\n            HandshakeMessage message, ByteBuffer buffer) throws IOException {\n            // The consuming happens in server side only.\n            ServerHandshakeContext shc = (ServerHandshakeContext)context;\n            // Is it a supported and enabled extension?\n            if (!shc.sslConfig.isAvailable(CH_SUPPORTED_GROUPS)) {\n                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n                    SSLLogger.fine(\n                        \"Ignore unavailable supported_groups extension\");\n                }\n                return;     // ignore the extension\n            }\n            // Parse the extension.\n            SupportedGroupsSpec spec;\n            try {\n                spec = new SupportedGroupsSpec(buffer);\n            } catch (IOException ioe) {\n                throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);\n            }\n            // Update the context.\n            List<NamedGroup> knownNamedGroups = new LinkedList<>();\n            for (int id : spec.namedGroupsIds) {\n                NamedGroup ng = NamedGroup.valueOf(id);\n                if (ng != null) {\n                    knownNamedGroups.add(ng);\n                }\n            }\n            shc.clientRequestedNamedGroups = knownNamedGroups;\n            shc.handshakeExtensions.put(CH_SUPPORTED_GROUPS, spec);\n            // No impact on session resumption.\n        }\n    }\n    /**\n     * Network data producer of a \"supported_groups\" extension in\n     * the EncryptedExtensions handshake message.\n     */\n<fim_suffix>    private static final class EESupportedGroupsProducer\n            extends SupportedGroups implements HandshakeProducer {\n        // Prevent instantiation of this class.\n        private EESupportedGroupsProducer() {\n            // blank\n        }\n        @Override\n        public byte[] produce(ConnectionContext context,\n                HandshakeMessage message) throws IOException {\n            // The producing happens in server side only.\n            ServerHandshakeContext shc = (ServerHandshakeContext)context;\n            // Is it a supported and enabled extension?\n            if (!shc.sslConfig.isAvailable(EE_SUPPORTED_GROUPS)) {\n                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n                    SSLLogger.fine(\n                        \"Ignore unavailable supported_groups extension\");\n                }\n                return null;\n            }\n            // Produce the extension.\n            //\n            // Contains all groups the server supports, regardless of whether\n            // they are currently supported by the client.\n            ArrayList<NamedGroup> namedGroups = new ArrayList<>(\n                    SupportedGroups.supportedNamedGroups.length);\n            for (NamedGroup ng : SupportedGroups.supportedNamedGroups) {\n                if ((!SupportedGroups.enableFFDHE) &&\n                    (ng.type == NamedGroupType.NAMED_GROUP_FFDHE)) {\n                    continue;\n                }\n                if (ng.isAvailable(shc.activeProtocols) &&\n                        ng.isSupported(shc.activeCipherSuites) &&\n                        shc.algorithmConstraints.permits(\n                            EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),\n                            ng.algorithm, namedGroupParams.get(ng))) {\n                    namedGroups.add(ng);\n                } else if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n                    SSLLogger.fine(\n                        \"Ignore inactive or disabled named group: \" + ng.name);\n                }\n            }\n            if (namedGroups.isEmpty()) {\n                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n                    SSLLogger.warning(\"no available named group\");\n                }\n                return null;\n            }\n            int vectorLen = namedGroups.size() << 1;\n            byte[] extData = new byte[vectorLen + 2];\n            ByteBuffer m = ByteBuffer.wrap(extData);\n            Record.putInt16(m, vectorLen);\n            for (NamedGroup namedGroup : namedGroups) {\n                    Record.putInt16(m, namedGroup.id);\n            }\n            // Update the context.\n            shc.conContext.serverRequestedNamedGroups =\n                    Collections.<NamedGroup>unmodifiableList(namedGroups);\n            SupportedGroupsSpec spec = new SupportedGroupsSpec(namedGroups);\n            shc.handshakeExtensions.put(EE_SUPPORTED_GROUPS, spec);\n            return extData;\n        }\n    }<fim_middle>// class below has no smell\n"}