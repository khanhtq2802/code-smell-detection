{"text": "<fim_prefix>/*******************************************************************************\n * Copyright (c) 2008, 2016 IBM Corporation and others.\n * \n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n * \n * Contributors:\n *    Alexander Shatalin (Borland) - initial API and implementation\n *    Alexander Nyssen (itemis AG) - contribution for Bugzilla #162082\n *    Matthias Wienand (itemis AG) - contribution for Bugzilla #355997\n *    \n *******************************************************************************/\npackage org.eclipse.gef.geometry.tests;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\nimport org.eclipse.gef.geometry.euclidean.Angle;\nimport org.eclipse.gef.geometry.internal.utils.PrecisionUtils;\nimport org.eclipse.gef.geometry.planar.Ellipse;\nimport org.eclipse.gef.geometry.planar.Line;\nimport org.eclipse.gef.geometry.planar.Point;\nimport org.eclipse.gef.geometry.planar.Polygon;\nimport org.eclipse.gef.geometry.planar.Polyline;\nimport org.eclipse.gef.geometry.planar.Rectangle;\nimport org.junit.Test;\n/**\n * Unit tests for {@link Polygon}.\n * \n * @author ahunter\n * @author anyssen\n * @author mwienand\n * \n */\npublic class PolygonTests {\n\tprivate static final Polygon CONCAVE_OCTAGON = new Polygon(new Point(0, 0),\n\t\t\tnew Point(0, 4), new Point(2, 4), new Point(2, 2), new Point(4, 2),\n\t\t\tnew Point(4, 4), new Point(6, 4), new Point(6, 0));\n\tprivate static final Polygon CONCAVE_PENTAGON = new Polygon(new Point(0, 0),\n\t\t\tnew Point(0, 8), new Point(4, 4), new Point(8, 8), new Point(8, 0));\n\tprivate static final double PRECISION_FRACTION = TestUtils\n\t\t\t.getPrecisionFraction();\n\tprivate static final double RECOGNIZABLE_FRACTION = PRECISION_FRACTION\n\t\t\t+ PRECISION_FRACTION / 10;\n\tprivate static final Polygon RECTANGLE = new Polygon(new Point(0, 0),\n\t\t\tnew Point(0, 2), new Point(2, 2), new Point(2, 0));\n\tprivate static final Polygon RHOMB = new Polygon(new Point(0, 2),\n\t\t\tnew Point(2, 0), new Point(4, 2), new Point(2, 4));\n\tprivate static final double UNRECOGNIZABLE_FRACTION = PRECISION_FRACTION\n\t\t\t- PRECISION_FRACTION / 10;\n\t@Test\n\tpublic void test_constructors() {\n\t\tassertEquals(RHOMB, new Polygon(new Point(2, 0), new Point(4, 2),\n\t\t\t\tnew Point(2, 4), new Point(0, 2)));\n\t\tassertEquals(RHOMB, new Polygon(new Point[] { new Point(2, 0),\n\t\t\t\tnew Point(4, 2), new Point(2, 4), new Point(0, 2) }));\n\t\tassertEquals(RHOMB, new Polygon(2, 0, 4, 2, 2, 4, 0, 2));\n\t\tassertEquals(RHOMB,\n\t\t\t\tnew Polygon(new double[] { 2, 0, 4, 2, 2, 4, 0, 2 }));\n\t}\n\t@Test\n\tpublic void test_contains_Ellipse() {\n\t\tassertTrue(RHOMB.contains(new Ellipse(1, 1, 2, 2)));\n\t\tassertFalse(RHOMB.contains(new Ellipse(0, 0, 4, 4)));\n\t}\n\t@Test\n\tpublic void test_contains_imprecision() {\n\t\tPolygon poly = new Polygon(\n\t\t\t\tnew Point(0.16384889386958243, 0.5199137157713366),\n\t\t\t\tnew Point(0.16388083282075672, 0.5199518598437528),\n\t\t\t\tnew Point(0.1639056804775328, 0.5199687901987595),\n\t\t\t\tnew Point(0.16381011945655763, 0.5198551130149273));\n\t\tPoint p = new Point(0.16383865075635337, 0.5198962222767928);\n\t\tassertTrue(poly.contains(p));\n\t}\n\t@Test\n\tpublic void test_contains_Line() {\n\t\tassertFalse(RHOMB.contains(new Line(-1, 1, 1, -1)));\n\t\tassertFalse(RHOMB.contains(new Line(-1, 2, 2, 2)));\n\t\tassertFalse(RHOMB.contains(new Line(2, 2, 5, 2)));\n\t\tassertTrue(RHOMB.contains(new Line(0, 2, 2, 0)));\n\t\tassertTrue(RHOMB.contains(new Line(0, 2, 2, 4)));\n\t\tassertTrue(RHOMB.contains(new Line(0, 2, 2, 2)));\n\t\tassertTrue(RHOMB.contains(new Line(1, 2, 3, 2)));\n\t\tassertTrue(new Polygon(new Point(), new Point(0, 5), new Point(5, 5),\n\t\t\t\tnew Point(5, 0), new Point(2.5, 2.5))\n\t\t\t\t\t\t.contains(new Line(1, 2.5, 4, 2.5)));\n\t\tassertFalse(new Polygon(new Point(), new Point(0, 5), new Point(5, 5),\n\t\t\t\tnew Point(5, 0), new Point(2.5, 2.5))\n\t\t\t\t\t\t.contains(new Line(1, 2, 4, 2)));\n\t\tPolygon mouth = new Polygon(new Point(0, 5), new Point(2, 1),\n\t\t\t\tnew Point(4, 1), new Point(6, 5), new Point(4, 6),\n\t\t\t\tnew Point(6, 7), new Point(4, 10), new Point(2, 10));\n\t\tassertFalse(mouth.contains(new Line(6, 5, 6, 7)));\n\t}\n\t/**\n\t * Testing points inside/outside the pentagon located on bottom concave\n\t * tangent. Excluding points of CONCAVE_PENTAGON border - separate test\n\t * present for it\n\t */\n<fim_suffix>\t@Test\n\tpublic void test_contains_Point_BottomConcavePentagonTangentPoints() {\n\t\tassertFalse(\"This point is outside the pentagon\",\n\t\t\t\tCONCAVE_PENTAGON.contains(new Point(-1, 4)));\n\t\tassertTrue(\"This point is inside the pentagon\",\n\t\t\t\tCONCAVE_PENTAGON.contains(new Point(1, 4)));\n\t\tassertTrue(\"This point is inside the pentagon\",\n\t\t\t\tCONCAVE_PENTAGON.contains(new Point(5, 4)));\n\t\tassertFalse(\"This point is outside the pentagon\",\n\t\t\t\tCONCAVE_PENTAGON.contains(new Point(9, 4)));\n\t}\n\t/**\n\t * Testing points inside/outside the rhomb located in bottop half. Excluding\n\t * points of RHOMB border - separate test present for it\n\t */\n\t@Test<fim_middle>// function below has no smell\n"}