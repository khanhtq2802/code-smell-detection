{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n * <p/>\n * http://www.apache.org/licenses/LICENSE-2.0\n * <p/>\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.bigtop.itest.junit;\n\nimport org.junit.runner.Runner;\nimport org.junit.runner.notification.RunNotifier;\nimport org.junit.runners.BlockJUnit4ClassRunner;\nimport org.junit.runners.Parameterized;\nimport org.junit.runners.Suite;\nimport org.junit.runners.model.FrameworkMethod;\nimport org.junit.runners.model.InitializationError;\nimport org.junit.runners.model.Statement;\nimport org.junit.runners.model.TestClass;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.lang.reflect.Modifier;\nimport java.util.*;\n\n/**\n * This is a modification of a Parameterized JUnit runner (which has been relicensed\n * under APL for this very hack BIGTOP-18) that takes care of two things:\n * 1. it lets arrange individual tests into ordered sequence of run stages via adding a\n * a &#064;RunStage(level=X) annotation to the desired testcases (default run stage\n * is 0). Later on run stages are executed according to the order of their levels\n * and testcases within the same run stage have no guaranteed order of execution.\n * 2. it lets give names to the parameterized testcases via making the factory method\n * &#064;Parameters return a Map (mapping names to testcases) instead of a List.\n * <p>\n * Here's how to use it:\n * <pre>\n * public class Example {\n *    <b>&#064;RunStage(level=-1)</b>\n *    <b>&#064;Test</b>\n *    public void earlyTest() {\n *    }\n *\n *    <b>&#064;RunStage(level=1)</b>\n *    <b>&#064;Test</b>\n *    public void lateTest() {\n *    }\n *\n *    <b>&#064;Test</b>\n *    public void defaultTest() {\n *      // this test will be executed at run stage 0 (default of level)\n *    }\n *\n *    &#064;Parameters\n *    public static Map&lt;String, Object[]&gt; generateTests() {\n *      HashMap&lt;String, Object[]&gt; res = new HashMap();\n *      res.put(\"test name\", new Object[] {1, 2});\n * return res;\n *    }\n * }\n * </pre>\n */\npublic class OrderedParameterized extends Suite {\n  /**\n   * Annotation for a method which provides parameters to be injected into the\n   * test class constructor by <code>Parameterized</code>\n   */\n  @Retention(RetentionPolicy.RUNTIME)\n  @Target(ElementType.METHOD)\n  public @interface RunStage {\n    int level() default 0;\n  }\n\n  ;\n\n  private class TestClassRunnerForParameters extends\n      BlockJUnit4ClassRunner {\n    private final String fParameterSetNumber;\n\n    private final Map<String, Object[]> fParameterList;\n\n    TestClassRunnerForParameters(Class<?> type,\n                                 Map<String, Object[]> parameterList, String i) throws InitializationError {\n      super(type);\n      fParameterList = parameterList;\n      fParameterSetNumber = i;\n    }\n\n    @Override\n    public Object createTest() throws Exception {\n      return getTestClass().getOnlyConstructor().newInstance(\n          computeParams());\n    }\n\n    private Object[] computeParams() throws Exception {\n      try {\n        return fParameterList.get(fParameterSetNumber);\n      } catch (ClassCastException e) {\n        throw new Exception(String.format(\n            \"%s.%s() must return a Map from Strings to arrays.\",\n            getTestClass().getName(), getParametersMethod(\n            getTestClass()).getName()));\n      }\n    }\n\n    @Override\n    protected List<FrameworkMethod> getChildren() {\n      List<FrameworkMethod> c = super.getChildren();\n      Collections.sort(c, new Comparator<FrameworkMethod>() {\n        public int compare(FrameworkMethod m1, FrameworkMethod m2) {\n          RunStage r1 = m1.getAnnotation(RunStage.class);\n          RunStage r2 = m2.getAnnotation(RunStage.class);\n          return ((r1 != null) ? r1.level() : 0) -\n              ((r2 != null) ? r2.level() : 0);\n        }\n      });\n      return c;\n    }\n\n    @Override\n    protected String getName() {\n      return String.format(\"[%s]\", fParameterSetNumber);\n    }\n\n    @Override\n    protected String testName(final FrameworkMethod method) {\n      return String.format(\"%s[%s]\", method.getName(),\n          fParameterSetNumber);\n    }\n\n    @Override\n    protected void validateConstructor(List<Throwable> errors) {\n      validateOnlyOneConstructor(errors);\n    }\n\n    @Override\n    protected Statement classBlock(RunNotifier notifier) {\n      return childrenInvoker(notifier);\n    }\n  }\n\n<fim_suffix>  private FrameworkMethod getParametersMethod(TestClass testClass)\n      throws Exception {\n    List<FrameworkMethod> methods = testClass\n        .getAnnotatedMethods(Parameterized.Parameters.class);\n    for (FrameworkMethod each : methods) {\n      int modifiers = each.getMethod().getModifiers();\n      if (Modifier.isStatic(modifiers) && Modifier.isPublic(modifiers))\n        return each;\n    }\n\n    throw new Exception(\"No public static parameters method on class \"\n        + testClass.getName());\n  }\n\n  private final ArrayList<Runner> runners = new ArrayList<Runner>();\n\n  @Override\n  protected List<Runner> getChildren() {\n    return runners;\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  private Map<String, Object[]> getParametersList(TestClass klass) throws Throwable {\n    return (Map<String, Object[]>) getParametersMethod(klass).invokeExplosively(null);\n  }\n\n  public OrderedParameterized(Class<?> klass) throws Throwable {\n    super(klass, Collections.<Runner>emptyList());\n    Map<String, Object[]> parametersMap = getParametersList(getTestClass());\n    for (Map.Entry<String, Object[]> entry : parametersMap.entrySet())\n      runners.add(new TestClassRunnerForParameters(getTestClass().getJavaClass(),\n          parametersMap, entry.getKey()));\n  }\n}<fim_middle>// function below has no smell\n"}