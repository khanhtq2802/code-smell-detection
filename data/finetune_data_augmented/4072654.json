{"text": "<fim_prefix>import com.coreos.jetcd.data.ByteSequence;\nimport com.coreos.jetcd.internal.impl.EtcdConnectionManager;\nimport com.coreos.jetcd.options.WatchOption;\nimport com.coreos.jetcd.watch.WatchResponseWithError;\nimport com.google.common.base.Strings;\nimport com.google.protobuf.ByteString;\nimport com.google.protobuf.UnsafeByteOperations;\nimport io.grpc.Status;\nimport io.grpc.Status.Code;\nimport io.grpc.stub.StreamObserver;\nimport java.util.LinkedList;\nimport java.util.Optional;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\nimport java.util.function.BiConsumer;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.bookkeeper.common.concurrent.FutureUtils;\nimport org.apache.bookkeeper.common.util.OrderedScheduler;\nimport org.apache.bookkeeper.util.collections.ConcurrentLongHashMap;\nimport org.apache.bookkeeper.util.collections.ConcurrentLongHashSet;\n/**\n * An async watch implementation.\n */\n@Slf4j\npublic class EtcdWatchClient implements AutoCloseable {\n    private final EtcdConnectionManager connMgr;\n    private final WatchGrpc.WatchStub stub;\n    private volatile StreamObserver<WatchRequest> grpcWatchStreamObserver;\n    // watchers stores a mapping between watchID -> EtcdWatcher.\n    private final ConcurrentLongHashMap<EtcdWatcher> watchers =\n        new ConcurrentLongHashMap<>();\n    private final LinkedList<EtcdWatcher> pendingWatchers = new LinkedList<>();\n    private final ConcurrentLongHashSet cancelSet = new ConcurrentLongHashSet();\n    // scheduler\n    private final OrderedScheduler scheduler;\n    private final ScheduledExecutorService watchExecutor;\n    // close state\n    private CompletableFuture<Void> closeFuture = null;\n    public EtcdWatchClient(Client client) {\n        this.connMgr = new EtcdConnectionManager(client);\n        this.stub = connMgr.newWatchStub();\n        this.scheduler = OrderedScheduler.newSchedulerBuilder()\n            .name(\"etcd-watcher-scheduler\")\n            .numThreads(Runtime.getRuntime().availableProcessors())\n            .build();\n        this.watchExecutor = this.scheduler.chooseThread();\n    }\n    public synchronized boolean isClosed() {\n        return closeFuture != null;\n    }\n    public CompletableFuture<EtcdWatcher> watch(ByteSequence key,\n                                                BiConsumer<com.coreos.jetcd.watch.WatchResponse, Throwable> consumer) {\n        return watch(key, WatchOption.DEFAULT, consumer);\n    }\n    public CompletableFuture<EtcdWatcher> watch(ByteSequence key,\n                                                WatchOption watchOption,\n                                                BiConsumer<com.coreos.jetcd.watch.WatchResponse, Throwable> consumer) {\n        return CompletableFuture.supplyAsync(() -> {\n            if (isClosed()) {\n                throw EtcdExceptionFactory.newClosedWatchClientException();\n            }\n            EtcdWatcher watcher = new EtcdWatcher(key, watchOption, scheduler.chooseThread(), this);\n            watcher.addConsumer(consumer);\n            pendingWatchers.add(watcher);\n            if (pendingWatchers.size() == 1) {\n                WatchRequest request = toWatchCreateRequest(watcher);\n                getGrpcWatchStreamObserver().onNext(request);\n            }\n            return watcher;\n        }, watchExecutor);\n    }\n    // notifies all watchers about a exception. it doesn't close watchers.\n    // it is the responsibility of user to close watchers.\n    private void notifyWatchers(EtcdException e) {\n        WatchResponseWithError wre = new WatchResponseWithError(e);\n        this.pendingWatchers.forEach(watcher -> watcher.notifyWatchResponse(wre));\n        this.pendingWatchers.clear();\n        this.watchers.values().forEach(watcher -> watcher.notifyWatchResponse(wre));\n        this.watchers.clear();\n    }\n    public CompletableFuture<Void> unwatch(EtcdWatcher watcher) {\n        return CompletableFuture.runAsync(() -> cancelWatcher(watcher.getWatchID()), watchExecutor);\n    }\n    private void cancelWatcher(long watchID) {\n        if (isClosed()) {\n            return;\n        }\n        if (cancelSet.contains(watchID)) {\n            return;\n        }\n        watchers.remove(watchID);\n        cancelSet.add(watchID);\n        WatchCancelRequest watchCancelRequest = WatchCancelRequest.newBuilder()\n            .setWatchId(watchID)\n            .build();\n        WatchRequest cancelRequest = WatchRequest.newBuilder()\n            .setCancelRequest(watchCancelRequest)\n            .build();\n        getGrpcWatchStreamObserver().onNext(cancelRequest);\n    }\n    public CompletableFuture<Void> closeAsync() {\n        CompletableFuture<Void> future;\n        synchronized (this) {\n            if (null == closeFuture) {\n                log.info(\"Closing watch client\");\n                closeFuture = CompletableFuture.runAsync(() -> {\n                    notifyWatchers(newClosedWatchClientException());\n                    closeGrpcWatchStreamObserver();\n                }, watchExecutor);\n            }\n            future = closeFuture;\n        }\n        return future.whenComplete((ignored, cause) -> {\n            this.scheduler.shutdown();\n        });\n    }\n    @Override\n    public void close() {\n        try {\n            FutureUtils.result(closeAsync());\n        } catch (Exception e) {\n            log.warn(\"Encountered exceptions on closing watch client\", e);\n        }\n        this.scheduler.forceShutdown(10, TimeUnit.SECONDS);\n    }\n    private StreamObserver<WatchResponse> createWatchStreamObserver() {\n        return new StreamObserver<WatchResponse>() {\n            @Override\n            public void onNext(WatchResponse watchResponse) {\n                if (isClosed()) {\n                    return;\n                }\n                watchExecutor.submit(() -> processWatchResponse(watchResponse));\n            }\n            @Override\n            public void onError(Throwable t) {\n                if (isClosed()) {\n                    return;\n                }\n                watchExecutor.submit(() -> processError(t));\n            }\n            @Override\n            public void onCompleted() {\n            }\n        };\n    }\n    private void processWatchResponse(WatchResponse watchResponse) {\n        // prevents grpc on sending watchResponse to a closed watch client.\n        if (isClosed()) {\n            return;\n        }\n        if (watchResponse.getCreated()) {\n            processCreate(watchResponse);\n        } else if (watchResponse.getCanceled()) {\n            processCanceled(watchResponse);\n        } else {\n            processEvents(watchResponse);\n        }\n    }\n    private void processError(Throwable t) {\n        // prevents grpc on sending error to a closed watch client.\n        if (this.isClosed()) {\n            return;\n        }\n        Status status = Status.fromThrowable(t);\n        if (this.isHaltError(status) || this.isNoLeaderError(status)) {\n            this.notifyWatchers(toEtcdException(status));\n            this.closeGrpcWatchStreamObserver();\n            this.cancelSet.clear();\n            return;\n        }\n        // resume with a delay; avoiding immediate retry on a long connection downtime.\n        scheduler.schedule(this::resume, 500, TimeUnit.MILLISECONDS);\n    }\n    private void resume() {\n        this.closeGrpcWatchStreamObserver();\n        this.cancelSet.clear();\n        this.resumeWatchers();\n    }\n    private synchronized StreamObserver<WatchRequest> getGrpcWatchStreamObserver() {\n        if (this.grpcWatchStreamObserver == null) {\n            this.grpcWatchStreamObserver = this.stub.watch(this.createWatchStreamObserver());\n        }\n        return this.grpcWatchStreamObserver;\n    }\n    // closeGrpcWatchStreamObserver closes the underlying grpc watch stream.\n    private void closeGrpcWatchStreamObserver() {\n        if (this.grpcWatchStreamObserver == null) {\n            return;\n        }\n        this.grpcWatchStreamObserver.onCompleted();\n        this.grpcWatchStreamObserver = null;\n    }\n    private void processCreate(WatchResponse response) {\n        EtcdWatcher watcher = this.pendingWatchers.poll();\n        this.sendNextWatchCreateRequest();\n        if (watcher == null) {\n            // shouldn't happen\n            // may happen due to duplicate watch create responses.\n            log.warn(\"Watch client receives watch create response but find no corresponding watcher\");\n            return;\n        }\n        if (watcher.isClosed()) {\n            return;\n        }\n        if (response.getWatchId() == -1) {\n            watcher.notifyWatchResponse(new WatchResponseWithError(\n                newEtcdException(ErrorCode.INTERNAL, \"etcd server failed to create watch id\")));\n            return;\n        }\n        if (watcher.getRevision() == 0) {\n            watcher.setRevision(response.getHeader().getRevision());\n        }\n        watcher.setWatchID(response.getWatchId());\n        this.watchers.put(watcher.getWatchID(), watcher);\n    }\n    /**\n     * chooses the next resuming watcher to register with the grpc stream.\n     */\n<fim_suffix>    private Optional<WatchRequest> nextResume() {\n        EtcdWatcher pendingWatcher = this.pendingWatchers.peek();\n        if (pendingWatcher != null) {\n            return Optional.of(this.toWatchCreateRequest(pendingWatcher));\n        }\n        return Optional.empty();\n    }<fim_middle>// function below has no smell\n"}