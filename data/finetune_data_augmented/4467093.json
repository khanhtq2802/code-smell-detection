{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.drill.jdbc.impl;\n\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.SQLFeatureNotSupportedException;\nimport java.sql.SQLType;\n\nimport org.apache.calcite.avatica.AvaticaParameter;\nimport org.apache.calcite.avatica.AvaticaPreparedStatement;\nimport org.apache.calcite.avatica.Meta;\nimport org.apache.calcite.avatica.Meta.StatementHandle;\nimport org.apache.drill.exec.proto.UserProtos.PreparedStatement;\nimport org.apache.drill.jdbc.AlreadyClosedSqlException;\nimport org.apache.drill.jdbc.DrillPreparedStatement;\n\n/**\n * Implementation of {@link java.sql.PreparedStatement} for Drill.\n *\n * <p>\n * This class has sub-classes which implement JDBC 3.0 and JDBC 4.0 APIs; it is\n * instantiated using\n * {@link org.apache.calcite.avatica.AvaticaFactory#newPreparedStatement}.\n * </p>\n */\nabstract class DrillPreparedStatementImpl extends AvaticaPreparedStatement\n    implements DrillPreparedStatement,\n               DrillRemoteStatement {\n\n  private final PreparedStatement preparedStatementHandle;\n\n  protected DrillPreparedStatementImpl(DrillConnectionImpl connection,\n                                       StatementHandle h,\n                                       Meta.Signature signature,\n                                       PreparedStatement preparedStatementHandle,\n                                       int resultSetType,\n                                       int resultSetConcurrency,\n                                       int resultSetHoldability) throws SQLException {\n    super(connection, h, signature,\n          resultSetType, resultSetConcurrency, resultSetHoldability);\n    connection.openStatementsRegistry.addStatement(this);\n    this.preparedStatementHandle = preparedStatementHandle;\n    if (preparedStatementHandle != null) {\n      ((DrillColumnMetaDataList) signature.columns).updateColumnMetaData(preparedStatementHandle.getColumnsList());\n    }\n  }\n\n  /**\n   * Throws AlreadyClosedSqlException <i>iff</i> this PreparedStatement is closed.\n   *\n   * @throws  AlreadyClosedSqlException  if PreparedStatement is closed\n   */\n  @Override\n  protected void checkOpen() throws SQLException {\n    if (isClosed()) {\n      throw new AlreadyClosedSqlException(\"PreparedStatement is already closed.\");\n    }\n  }\n\n\n  // Note:  Using dynamic proxies would reduce the quantity (450?) of method\n  // overrides by eliminating those that exist solely to check whether the\n  // object is closed.\n\n  PreparedStatement getPreparedStatementHandle() {\n    return preparedStatementHandle;\n  }\n\n  @Override\n  protected AvaticaParameter getParameter(int param) throws SQLException {\n    checkOpen();\n    throw new SQLFeatureNotSupportedException(\n        \"Prepared-statement dynamic parameters are not supported.\");\n  }\n\n<fim_suffix>  @Override\n  public void cleanUp() {\n    final DrillConnectionImpl connection1 = (DrillConnectionImpl) connection;\n    connection1.openStatementsRegistry.removeStatement(this);\n  }\n\n  // Note:  Methods are in same order as in java.sql.PreparedStatement.\n\n  // No isWrapperFor(Class<?>) (it doesn't throw SQLException if already closed).\n  // No unwrap(Class<T>) (it doesn't throw SQLException if already closed).\n\n  // No close() (it doesn't throw SQLException if already closed).\n\n  @Override\n  public void setEscapeProcessing(boolean enable) throws SQLException {\n    checkOpen();\n    try {\n      super.setEscapeProcessing(enable);\n    } catch (UnsupportedOperationException e) {\n      throw new SQLFeatureNotSupportedException(e.getMessage(), e);\n    }\n  }\n\n  @Override\n  public void setCursorName(String name) throws SQLException {\n    checkOpen();\n    try {\n      super.setCursorName(name);\n    } catch (UnsupportedOperationException e) {\n      throw new SQLFeatureNotSupportedException(e.getMessage(), e);\n    }\n  }\n\n  @Override\n  public boolean getMoreResults() throws SQLException {\n    try {\n      return super.getMoreResults();\n    } catch (UnsupportedOperationException e) {\n      throw new SQLFeatureNotSupportedException(e.getMessage(), e);\n    }\n  }\n\n  @Override\n  public boolean getMoreResults(int current) throws SQLException {\n    try {\n      return super.getMoreResults(current);\n    } catch (UnsupportedOperationException e) {\n      throw new SQLFeatureNotSupportedException(e.getMessage(), e);\n    }\n  }\n\n  @Override\n  public ResultSet getGeneratedKeys() throws SQLException {\n    checkOpen();\n    try {\n      return super.getGeneratedKeys();\n    } catch (UnsupportedOperationException e) {\n      throw new SQLFeatureNotSupportedException(e.getMessage(), e);\n    }\n  }\n\n  @Override\n  public long executeLargeUpdate(String sql, int autoGeneratedKeys) throws SQLException {\n    checkOpen();\n    return super.executeLargeUpdate(sql, autoGeneratedKeys);\n  }\n\n  @Override\n  public long executeLargeUpdate(String sql, int[] columnIndexes) throws SQLException {\n    checkOpen();\n    return super.executeLargeUpdate(sql, columnIndexes);\n  }\n\n  @Override\n  public long executeLargeUpdate(String sql, String[] columnNames) throws SQLException {\n    checkOpen();\n    return super.executeLargeUpdate(sql, columnNames);\n  }\n\n  @Override\n  public int executeUpdate(String sql, int autoGeneratedKeys) throws SQLException {\n    checkOpen();\n    try {\n      return super.executeUpdate(sql, autoGeneratedKeys);\n    } catch (UnsupportedOperationException e) {\n      throw new SQLFeatureNotSupportedException(e.getMessage(), e);\n    }\n  }\n\n  @Override\n  public int executeUpdate(String sql, int columnIndexes[]) throws SQLException {\n    checkOpen();\n    try {\n      return super.executeUpdate(sql, columnIndexes);\n    } catch (UnsupportedOperationException e) {\n      throw new SQLFeatureNotSupportedException(e.getMessage(), e);\n    }\n  }\n\n  @Override\n  public int executeUpdate(String sql, String columnNames[]) throws SQLException {\n    checkOpen();\n    try {\n      return super.executeUpdate(sql, columnNames);\n    } catch (UnsupportedOperationException e) {\n      throw new SQLFeatureNotSupportedException(e.getMessage(), e);\n    }\n  }\n\n  @Override\n  public boolean execute(String sql, int autoGeneratedKeys) throws SQLException {\n    checkOpen();\n    try {\n      return super.execute(sql, autoGeneratedKeys);\n    } catch (UnsupportedOperationException e) {\n      throw new SQLFeatureNotSupportedException(e.getMessage(), e);\n    }\n  }\n\n  @Override\n  public boolean execute(String sql, int columnIndexes[]) throws SQLException {\n    checkOpen();\n    try {\n      return super.execute(sql, columnIndexes);\n    } catch (UnsupportedOperationException e) {\n      throw new SQLFeatureNotSupportedException(e.getMessage(), e);\n    }\n  }\n\n  @Override\n  public boolean execute(String sql, String columnNames[]) throws SQLException {\n    checkOpen();\n    try {\n      return super.execute(sql, columnNames);\n    } catch (UnsupportedOperationException e) {\n      throw new SQLFeatureNotSupportedException(e.getMessage(), e);\n    }\n  }\n\n  @Override\n  public boolean isClosed() {\n    try {\n      return super.isClosed();\n    } catch (SQLException e) {\n      throw new RuntimeException(\n          \"Unexpected \" + e + \" from AvaticaPreparedStatement.isClosed\");\n    }\n  }\n\n  @Override\n  public void setPoolable(boolean poolable) throws SQLException {\n    checkOpen();\n    try {\n      super.setPoolable(poolable);\n    } catch (UnsupportedOperationException e) {\n      throw new SQLFeatureNotSupportedException(e.getMessage(), e);\n    }\n  }\n\n  @Override\n  public void setObject(int parameterIndex, Object x, SQLType targetSqlType, int scaleOrLength) throws SQLException {\n    checkOpen();\n    super.setObject(parameterIndex, x, targetSqlType, scaleOrLength);\n  }\n\n  @Override\n  public void setObject(int parameterIndex, Object x, SQLType targetSqlType) throws SQLException {\n    checkOpen();\n    super.setObject(parameterIndex, x, targetSqlType);\n  }\n}<fim_middle>// function below has no smell\n"}