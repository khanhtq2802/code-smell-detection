{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.zookeeper.graph;\nimport org.json.simple.JSONArray;\nimport org.json.simple.JSONObject;\nimport org.json.simple.JSONValue;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.IOException;\nimport java.util.regex.Pattern;\nimport java.util.regex.Matcher;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.Set;\npublic class JsonGenerator {\n    private JSONObject root;\n    private Set<Integer> servers;\n    private class Message {\n\tprivate int from;\n\tprivate int to;\n\tprivate long zxid;\n\tpublic Message(int from, int to, long zxid) {\n\t    this.from = from;\n\t    this.to = to;\n\t    this.zxid = zxid;\n\t}\n\tpublic boolean equals(Message m) {\n\t    return (m.from == this.from \n\t\t    && m.to == this.to\n\t\t    && m.zxid == this.zxid);\n\t}\n    };\n    public JSONObject txnEntry(TransactionEntry e) {\n\tJSONObject event = new JSONObject();\n\tevent.put(\"time\", Long.toString(e.getTimestamp()));\n\tevent.put(\"client\", Long.toHexString(e.getClientId()));\n\tevent.put(\"cxid\", Long.toHexString(e.getCxid()));\n\tevent.put(\"zxid\", Long.toHexString(e.getZxid()));\n\tevent.put(\"op\", e.getOp());\n\tevent.put(\"extra\", e.getExtra());\n\tevent.put(\"type\", \"transaction\");\n\treturn event;\n    }\n    /**\n       Assumes entries are sorted by timestamp.\n     */\n<fim_suffix>    public JsonGenerator(LogIterator iter) {\n\tservers = new HashSet<Integer>();\n\tPattern stateChangeP = Pattern.compile(\"- (LOOKING|FOLLOWING|LEADING)\");\n\tPattern newElectionP = Pattern.compile(\"New election. My id =  (\\\\d+), Proposed zxid = (\\\\d+)\");\n\tPattern receivedProposalP = Pattern.compile(\"Notification: (\\\\d+) \\\\(n.leader\\\\), (\\\\d+) \\\\(n.zxid\\\\), (\\\\d+) \\\\(n.round\\\\), .+ \\\\(n.state\\\\), (\\\\d+) \\\\(n.sid\\\\), .+ \\\\(my state\\\\)\");\n\tPattern exceptionP = Pattern.compile(\"xception\");\n\troot = new JSONObject();\n\tMatcher m = null;\n\tJSONArray events = new JSONArray();\n\troot.put(\"events\", events);\n\tlong starttime = Long.MAX_VALUE;\n\tlong endtime = 0;\n\tint leader = 0;\n\tlong curEpoch = 0;\n\tboolean newEpoch = false;\n\twhile (iter.hasNext()) {\n\t    LogEntry ent = iter.next();\n\t    if (ent.getTimestamp() < starttime) {\n\t\tstarttime = ent.getTimestamp();\n\t    }\n\t    if (ent.getTimestamp() > endtime) {\n\t\tendtime = ent.getTimestamp();\n\t    }\n\t    if (ent.getType() == LogEntry.Type.TXN) {\n\t\tevents.add(txnEntry((TransactionEntry)ent));\n\t    } else {\n\t\tLog4JEntry e = (Log4JEntry)ent;\n\t\tservers.add(e.getNode());\n\t\tif ((m = stateChangeP.matcher(e.getEntry())).find()) {\n\t\t    JSONObject stateChange = new JSONObject();\n\t\t    stateChange.put(\"type\", \"stateChange\");\n\t\t    stateChange.put(\"time\", e.getTimestamp());\n\t\t    stateChange.put(\"server\", e.getNode());\n\t\t    stateChange.put(\"state\", m.group(1));\n\t\t    events.add(stateChange);\n\t\t    if (m.group(1).equals(\"LEADING\")) {\n\t\t\tleader = e.getNode();\n\t\t    }\n\t\t} else if ((m = newElectionP.matcher(e.getEntry())).find()) {\n\t\t    Iterator<Integer> iterator = servers.iterator();\n\t\t    long zxid = Long.valueOf(m.group(2));\n\t\t    int count = (int)zxid;// & 0xFFFFFFFFL;\n\t\t    int epoch = (int)Long.rotateRight(zxid, 32);// >> 32;\n\t\t    if (leader != 0 && epoch > curEpoch) {\n\t\t\tJSONObject stateChange = new JSONObject();\n\t\t\tstateChange.put(\"type\", \"stateChange\");\n\t\t\tstateChange.put(\"time\", e.getTimestamp());\n\t\t\tstateChange.put(\"server\", leader);\n\t\t\tstateChange.put(\"state\", \"INIT\");\n\t\t\tevents.add(stateChange);\n\t\t\tleader = 0;\n\t\t    }\n\t\t    while (iterator.hasNext()) {\n\t\t\tint dst = iterator.next();\n\t\t\tif (dst != e.getNode()) {\n\t\t\t    JSONObject msg = new JSONObject();\n\t\t\t    msg.put(\"type\", \"postmessage\");\n\t\t\t    msg.put(\"src\", e.getNode());\n\t\t\t    msg.put(\"dst\", dst);\n\t\t\t    msg.put(\"time\", e.getTimestamp());\n\t\t\t    msg.put(\"zxid\", m.group(2));\n\t\t\t    msg.put(\"count\", count);\n\t\t\t    msg.put(\"epoch\", epoch);\n\t\t\t    events.add(msg);\n\t\t\t}\n\t\t    }\n\t\t} else if ((m = receivedProposalP.matcher(e.getEntry())).find()) {\n\t\t    // Pattern.compile(\"Notification: \\\\d+, (\\\\d+), (\\\\d+), \\\\d+, [^,]*, [^,]*, (\\\\d+)\");//, LOOKING, LOOKING, 2\n\t\t    int src = Integer.valueOf(m.group(4));\n\t\t    long zxid = Long.valueOf(m.group(2));\n\t\t    int dst = e.getNode();\n\t\t    long epoch2 = Long.valueOf(m.group(3));\n\t\t    int count = (int)zxid;// & 0xFFFFFFFFL;\n\t\t    int epoch = (int)Long.rotateRight(zxid, 32);// >> 32;\n\t\t    if (leader != 0 && epoch > curEpoch) {\n\t\t\tJSONObject stateChange = new JSONObject();\n\t\t\tstateChange.put(\"type\", \"stateChange\");\n\t\t\tstateChange.put(\"time\", e.getTimestamp());\n\t\t\tstateChange.put(\"server\", leader);\n\t\t\tstateChange.put(\"state\", \"INIT\");\n\t\t\tevents.add(stateChange);\n\t\t\tleader = 0;\n\t\t    }\n\t\t    if (src != dst) {\n\t\t\tJSONObject msg = new JSONObject();\n\t\t\tmsg.put(\"type\", \"delivermessage\");\n\t\t\tmsg.put(\"src\", src);\n\t\t\tmsg.put(\"dst\", dst);\n\t\t\tmsg.put(\"time\", e.getTimestamp());\n\t\t\tmsg.put(\"zxid\", zxid);\n\t\t\tmsg.put(\"epoch\", epoch);\n\t\t\tmsg.put(\"count\", count);\n\t\t\tmsg.put(\"epoch2\", epoch2);\n\t\t\tevents.add(msg);\n\t\t    }\n\t\t} else if ((m = exceptionP.matcher(e.getEntry())).find()) {\n\t\t    JSONObject ex = new JSONObject();\n\t\t    ex.put(\"type\", \"exception\");\n\t\t    ex.put(\"server\", e.getNode());\n\t\t    ex.put(\"time\", e.getTimestamp());\n\t\t    ex.put(\"text\", e.getEntry());\n\t\t    events.add(ex);\n\t\t} \n\t    }\n\t    JSONObject ex = new JSONObject();\n\t    ex.put(\"type\", \"text\");\n\t    ex.put(\"time\", ent.getTimestamp());\n\t    String txt = ent.toString();\n\t    ex.put(\"text\", txt);\n\t    events.add(ex);\n\t}\n\t//\tSystem.out.println(\"pending messages: \"+pendingMessages.size());\n\troot.put(\"starttime\", starttime);\n\troot.put(\"endtime\", endtime);\n\tJSONArray serversarray = new JSONArray();\n\troot.put(\"servers\", serversarray);\n\tIterator<Integer> iterator = servers.iterator();\n\twhile (iterator.hasNext()) {\n\t    serversarray.add(iterator.next());\n\t}\n    }\n    public String toString() {\n\treturn JSONValue.toJSONString(root);\n    }\n    public static void main(String[] args) throws Exception {\n\tMergedLogSource src = new MergedLogSource(args);\n\tLogIterator iter = src.iterator();<fim_middle>// function below is feature envy and long method\n"}