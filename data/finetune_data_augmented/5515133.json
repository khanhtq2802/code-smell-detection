{"text": "<fim_prefix>        JobDriver.this.jobMessageObserver.sendMessageToClient(JVM_CODEC.encode(result));\n        if (JobDriver.this.handlerManager.getCompletedTaskHandler() == 0) {\n          LOG.log(Level.INFO, \"No CLR handler bound to handle completed task.\");\n        } else {\n          LOG.log(Level.INFO, \"CLR CompletedTaskHandler handler set, handling things with CLR handler.\");\n          final CompletedTaskBridge completedTaskBridge = new CompletedTaskBridge(task, activeContextBridgeFactory);\n          NativeInterop.clrSystemCompletedTaskHandlerOnNext(JobDriver.this.handlerManager.getCompletedTaskHandler(),\n              completedTaskBridge, JobDriver.this.interopLogger);\n        }\n      }\n    }\n  }\n  /**\n   * Receive notification that the entire Evaluator had failed.\n   */\n  public final class FailedEvaluatorHandler implements EventHandler<FailedEvaluator> {\n    @Override\n    public void onNext(final FailedEvaluator eval) {\n      JobDriver.this.handleFailedEvaluator(eval, false);\n      allocatedEvaluatorBridges.remove(eval.getId());\n    }\n  }\n  /**\n   * Receive notification that the entire Evaluator had failed on Driver Restart.\n   */\n  public final class DriverRestartFailedEvaluatorHandler implements EventHandler<FailedEvaluator> {\n    @Override\n    public void onNext(final FailedEvaluator eval) {\n      JobDriver.this.handleFailedEvaluator(eval, true);\n    }\n  }\n  final class HttpServerBridgeEventHandler implements HttpHandler {\n    private String uriSpecification;\n    /**\n     * returns URI specification for the handler.\n     */\n    @Override\n    public String getUriSpecification() {\n      return uriSpecification;\n    }\n    public void setUriSpecification(final String s) {\n      uriSpecification = s;\n    }\n    /**\n     * process http request.\n     */\n    @Override\n    public void onHttpRequest(final ParsedHttpRequest parsedHttpRequest, final HttpServletResponse response)\n        throws IOException, ServletException {\n      LOG.log(Level.INFO, \"HttpServerBridgeEventHandler onHttpRequest: {0}\", parsedHttpRequest.getRequestUri());\n      try (final LoggingScope ls = loggingScopeFactory.httpRequest(parsedHttpRequest.getRequestUri())) {\n        final AvroHttpSerializer httpSerializer = new AvroHttpSerializer();\n        final AvroHttpRequest avroHttpRequest = httpSerializer.toAvro(parsedHttpRequest);\n        final String requestString = httpSerializer.toString(avroHttpRequest);\n        final byte[] requestBytes = requestString.getBytes(Charset.forName(AvroHttpSerializer.JSON_CHARSET));\n        try {\n          final HttpServerEventBridge httpServerEventBridge = new HttpServerEventBridge(requestBytes);\n          NativeInterop.clrSystemHttpServerHandlerOnNext(JobDriver.this.handlerManager.getHttpServerEventHandler(),\n              httpServerEventBridge, JobDriver.this.interopLogger);\n          final String responseBody = new String(httpServerEventBridge.getQueryResponseData(), \"UTF-8\");\n          response.getWriter().println(responseBody);\n          LOG.log(Level.INFO, \"HttpServerBridgeEventHandler onHttpRequest received response: {0}\", responseBody);\n        } catch (final Exception ex) {\n          LOG.log(Level.SEVERE, \"Fail to invoke CLR Http Server handler\", ex);\n          throw new RuntimeException(ex);\n        }\n      }\n    }\n  }\n  /**\n   * Handle failed task.\n   */\n  public final class FailedTaskHandler implements EventHandler<FailedTask> {\n    @Override\n    public void onNext(final FailedTask task) throws RuntimeException {\n      LOG.log(Level.SEVERE, \"FailedTask received, will be handle in CLR handler, if set.\");\n      if (JobDriver.this.handlerManager.getFailedTaskHandler() == 0) {\n        LOG.log(Level.SEVERE, \"Failed Task Handler not initialized by CLR, fail for real.\");\n        throw new RuntimeException(\"Failed Task Handler not initialized by CLR.\");\n      }\n      try {\n        final FailedTaskBridge failedTaskBridge = new FailedTaskBridge(task, activeContextBridgeFactory);\n        NativeInterop.clrSystemFailedTaskHandlerOnNext(JobDriver.this.handlerManager.getFailedTaskHandler(),\n            failedTaskBridge, JobDriver.this.interopLogger);\n      } catch (final Exception ex) {\n        LOG.log(Level.SEVERE, \"Fail to invoke CLR failed task handler\");\n        throw new RuntimeException(ex);\n      }\n    }\n  }\n  /**\n   * Receive notification that the Task is running.\n   */\n  public final class RunningTaskHandler implements EventHandler<RunningTask> {\n    @Override\n    public void onNext(final RunningTask task) {\n      try (final LoggingScope ls = loggingScopeFactory.taskRunning(task.getId())) {\n        if (JobDriver.this.handlerManager.getRunningTaskHandler() == 0) {\n          LOG.log(Level.INFO, \"RunningTask event received but no CLR handler was bound. Exiting handler.\");\n        } else {\n          LOG.log(Level.INFO, \"RunningTask will be handled by CLR handler. Task Id: {0}\", task.getId());\n          try {\n            final RunningTaskBridge runningTaskBridge = new RunningTaskBridge(task, activeContextBridgeFactory);\n            NativeInterop.clrSystemRunningTaskHandlerOnNext(JobDriver.this.handlerManager.getRunningTaskHandler(),\n                runningTaskBridge, JobDriver.this.interopLogger);\n          } catch (final Exception ex) {\n            LOG.log(Level.WARNING, \"Fail to invoke CLR running task handler\");\n            throw new RuntimeException(ex);\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Receive notification that the Task is running when driver restarted.\n   */\n  public final class DriverRestartRunningTaskHandler implements EventHandler<RunningTask> {\n    @Override\n    public void onNext(final RunningTask task) {\n      try (final LoggingScope ls = loggingScopeFactory.driverRestartRunningTask(task.getId())) {\n        clock.scheduleAlarm(0, new EventHandler<Alarm>() {\n          @Override\n          public void onNext(final Alarm time) {\n            if (JobDriver.this.handlerManager != null) {\n              if (JobDriver.this.handlerManager.getDriverRestartRunningTaskHandler() != 0) {\n                LOG.log(Level.INFO, \"CLR driver restart RunningTask handler implemented, now handle it in CLR.\");\n                NativeInterop.clrSystemDriverRestartRunningTaskHandlerOnNext(\n                    JobDriver.this.handlerManager.getDriverRestartRunningTaskHandler(),\n                    new RunningTaskBridge(task, activeContextBridgeFactory));\n              } else {\n                LOG.log(Level.WARNING, \"No CLR driver restart RunningTask handler implemented, \" +\n                    \"done with DriverRestartRunningTaskHandler.\");\n              }\n            } else {\n              LOG.log(Level.INFO, \"Waiting for driver to complete restart process \" +\n                  \"before checking out CLR driver restart RunningTaskHandler...\");\n              clock.scheduleAlarm(2000, this);\n            }\n          }\n        });\n      }\n    }\n  }\n  /**\n   * Receive notification that an context is active on Evaluator when the driver restarted.\n   */\n  public final class DriverRestartActiveContextHandler implements EventHandler<ActiveContext> {\n    @Override\n    public void onNext(final ActiveContext context) {\n      try (final LoggingScope ls = loggingScopeFactory.driverRestartActiveContextReceived(context.getId())) {\n        JobDriver.this.contexts.put(context.getId(), context);\n        LOG.log(Level.INFO, \"DriverRestartActiveContextHandler event received: \" + context.getId());\n        clock.scheduleAlarm(0, new EventHandler<Alarm>() {\n          @Override\n          public void onNext(final Alarm time) {\n            if (JobDriver.this.handlerManager != null) {\n              if (JobDriver.this.handlerManager.getDriverRestartActiveContextHandler() != 0) {\n                LOG.log(Level.INFO, \"CLR driver restart ActiveContext handler implemented, now handle it in CLR.\");\n                NativeInterop.clrSystemDriverRestartActiveContextHandlerOnNext(\n                    JobDriver.this.handlerManager.getDriverRestartActiveContextHandler(),\n                    activeContextBridgeFactory.getActiveContextBridge(context));\n              } else {\n                LOG.log(Level.WARNING, \"No CLR driver restart ActiveContext handler implemented, \" +\n                    \"done with DriverRestartActiveContextHandler.\");\n              }\n            } else {\n              LOG.log(Level.INFO, \"Waiting for driver to complete restart process \" +\n                  \"before checking out CLR driver restart DriverRestartActiveContextHandler...\");\n              clock.scheduleAlarm(2000, this);\n            }\n          }\n        });\n      }\n    }\n  }\n  /**\n   * Job Driver is ready and the clock is set up: request the evaluators.\n   */\n<fim_suffix>  public final class StartHandler implements EventHandler<StartTime> {\n    @Override\n    public void onNext(final StartTime startTime) {\n      try (final LoggingScope ls = loggingScopeFactory.driverStart(startTime)) {\n        // CLR bridge setup must be done before other event handlers try to access the CLR bridge\n        // thus we grab a lock on this instance\n        synchronized (JobDriver.this) {\n          setupBridge();\n          LOG.log(Level.INFO, \"Finished CLR bridge setup for {0}\", startTime);\n        }\n        NativeInterop.callClrSystemOnStartHandler();\n        LOG.log(Level.INFO, \"Driver Started\");\n      }\n    }\n  }<fim_middle>// class below has no smell\n"}