{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.  The ASF licenses this file to you under the Apache License, Version\n * 2.0 (the \"License\"); you may not use this file except in compliance with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\n\npackage org.apache.storm.messaging.netty;\n\nimport java.io.IOException;\nimport java.util.Map;\nimport org.apache.storm.shade.io.netty.channel.Channel;\nimport org.apache.storm.shade.io.netty.channel.ChannelHandlerContext;\nimport org.apache.storm.shade.io.netty.channel.ChannelInboundHandlerAdapter;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class KerberosSaslClientHandler extends ChannelInboundHandlerAdapter {\n\n    private static final Logger LOG = LoggerFactory\n        .getLogger(KerberosSaslClientHandler.class);\n    private final long start_time;\n    private final ISaslClient client;\n    /**\n     * Used for client or server's token to send or receive from each other.\n     */\n    private final Map<String, Object> topoConf;\n    private final String jaas_section;\n    private final String host;\n\n    public KerberosSaslClientHandler(ISaslClient client, Map<String, Object> topoConf, String jaas_section, String host) throws\n        IOException {\n        this.client = client;\n        this.topoConf = topoConf;\n        this.jaas_section = jaas_section;\n        this.host = host;\n        start_time = System.currentTimeMillis();\n    }\n\n    @Override\n    public void channelActive(ChannelHandlerContext ctx) {\n        // register the newly established channel\n        Channel channel = ctx.channel();\n\n        LOG.info(\"Connection established from {} to {}\",\n                 channel.localAddress(), channel.remoteAddress());\n\n        try {\n            KerberosSaslNettyClient saslNettyClient = channel.attr(KerberosSaslNettyClientState.KERBEROS_SASL_NETTY_CLIENT).get();\n\n            if (saslNettyClient == null) {\n                LOG.debug(\"Creating saslNettyClient now for channel: {}\",\n                          channel);\n                saslNettyClient = new KerberosSaslNettyClient(topoConf, jaas_section, host);\n                channel.attr(KerberosSaslNettyClientState.KERBEROS_SASL_NETTY_CLIENT).set(saslNettyClient);\n            }\n            LOG.debug(\"Going to initiate Kerberos negotiations.\");\n            byte[] initialChallenge = saslNettyClient.saslResponse(new SaslMessageToken(new byte[0]));\n            LOG.debug(\"Sending initial challenge: {}\", initialChallenge);\n            channel.writeAndFlush(new SaslMessageToken(initialChallenge), channel.voidPromise());\n        } catch (Exception e) {\n            LOG.error(\"Failed to authenticate with server due to error: \",\n                      e);\n        }\n    }\n\n    @Override\n    public void channelRead(ChannelHandlerContext ctx, Object message) throws Exception {\n        LOG.debug(\"send/recv time (ms): {}\", (System.currentTimeMillis() - start_time));\n\n        // examine the response message from server\n        if (message instanceof ControlMessage) {\n            handleControlMessage(ctx, (ControlMessage) message);\n        } else if (message instanceof SaslMessageToken) {\n            handleSaslMessageToken(ctx, (SaslMessageToken) message);\n        } else {\n            LOG.error(\"Unexpected message from server: {}\", message);\n        }\n    }\n\n    private KerberosSaslNettyClient getChannelSaslClient(Channel channel) throws Exception {\n        // Generate SASL response to server using Channel-local SASL client.\n        KerberosSaslNettyClient saslNettyClient = channel.attr(KerberosSaslNettyClientState.KERBEROS_SASL_NETTY_CLIENT).get();\n        if (saslNettyClient == null) {\n            throw new Exception(\"saslNettyClient was unexpectedly null for channel:\" + channel);\n        }\n        return saslNettyClient;\n    }\n\n<fim_suffix>    private void handleControlMessage(ChannelHandlerContext ctx, ControlMessage controlMessage) throws Exception {\n        Channel channel = ctx.channel();\n        KerberosSaslNettyClient saslNettyClient = getChannelSaslClient(channel);\n        if (controlMessage == ControlMessage.SASL_COMPLETE_REQUEST) {\n            LOG.debug(\"Server has sent us the SaslComplete message. Allowing normal work to proceed.\");\n\n            if (!saslNettyClient.isComplete()) {\n                String errorMessage =\n                    \"Server returned a Sasl-complete message, but as far as we can tell, we are not authenticated yet.\";\n                LOG.error(errorMessage);\n                throw new Exception(errorMessage);\n            }\n            ctx.pipeline().remove(this);\n            this.client.channelReady(channel);\n\n            // We call fireChannelRead since the client is allowed to\n            // perform this request. The client's request will now proceed\n            // to the next pipeline component namely StormClientHandler.\n            ctx.fireChannelRead(controlMessage);\n        } else {\n            LOG.warn(\"Unexpected control message: {}\", controlMessage);\n        }\n    }\n\n    private void handleSaslMessageToken(ChannelHandlerContext ctx, SaslMessageToken saslMessageToken) throws Exception {\n        Channel channel = ctx.channel();\n        KerberosSaslNettyClient saslNettyClient = getChannelSaslClient(channel);\n        LOG.debug(\"Responding to server's token of length: {}\", saslMessageToken.getSaslToken().length);\n\n        // Generate SASL response (but we only actually send the response if\n        // it's non-null.\n        byte[] responseToServer = saslNettyClient.saslResponse(saslMessageToken);\n        if (responseToServer == null) {\n            // If we generate a null response, then authentication has completed\n            // (if not, warn), and return without sending a response back to the\n            // server.\n            LOG.debug(\"Response to server is null: authentication should now be complete.\");\n            if (!saslNettyClient.isComplete()) {\n                LOG.warn(\"Generated a null response, but authentication is not complete.\");\n                throw new Exception(\"Our reponse to the server is null, but as far as we can tell, we are not authenticated yet.\");\n            }\n            this.client.channelReady(channel);\n        } else {\n            LOG.debug(\"Response to server token has length: {}\",\n                      responseToServer.length);\n            // Construct a message containing the SASL response and send it to the server.\n            SaslMessageToken saslResponse = new SaslMessageToken(responseToServer);\n            channel.writeAndFlush(saslResponse, channel.voidPromise());\n        }\n    }\n\n    @Override\n    public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n        super.channelRegistered(ctx);\n        LOG.debug(\"channelRegistered {}\", ctx);\n    }\n\n    @Override\n    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n        super.channelUnregistered(ctx);\n        LOG.debug(\"channelUnregistered {}\", ctx);\n\n    }\n\n    @Override\n    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n        LOG.warn(\"{} exceptionCaught\", ctx, cause);\n        super.exceptionCaught(ctx, cause);\n    }\n}<fim_middle>// function below has no smell\n"}