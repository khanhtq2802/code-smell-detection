{"text": "<fim_prefix>// Copyright (c) Microsoft. All rights reserved.\n// Licensed under the MIT license. See License.txt in the repository root.\n\npackage com.microsoft.tfs.client.eclipse.ui.connectionconflict;\n\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.jface.dialogs.MessageDialog;\nimport org.eclipse.swt.widgets.Shell;\n\nimport com.microsoft.tfs.client.common.repository.RepositoryManager;\nimport com.microsoft.tfs.client.common.server.ServerManager;\nimport com.microsoft.tfs.client.common.ui.framework.helper.ShellUtils;\nimport com.microsoft.tfs.client.common.ui.framework.helper.UIHelpers;\nimport com.microsoft.tfs.client.common.ui.helpers.EditorHelper;\nimport com.microsoft.tfs.client.common.ui.helpers.TFSEditorSaveableFilter;\nimport com.microsoft.tfs.client.common.ui.helpers.TFSEditorSaveableFilter.TFSEditorSaveableType;\nimport com.microsoft.tfs.client.eclipse.TFSEclipseClientPlugin;\nimport com.microsoft.tfs.client.eclipse.connectionconflict.EclipseConnectionConflictHandler;\nimport com.microsoft.tfs.client.eclipse.project.ProjectRepositoryManager;\nimport com.microsoft.tfs.client.eclipse.project.ProjectRepositoryStatus;\nimport com.microsoft.tfs.client.eclipse.ui.Messages;\nimport com.microsoft.tfs.client.eclipse.ui.TFSEclipseClientUIPlugin;\n\n/**\n * A connection conflict handler for the Eclipse Plug-in. Allows users to turn\n * {@link IProject}s offline to connect to a different server / workspace.\n *\n * @threadsafety unknown\n */\npublic class EclipseUIConnectionConflictHandler extends EclipseConnectionConflictHandler {\n    /**\n     * Allows the user to resolve a server conflict, caused by trying to connect\n     * to a server that is not the currently-connected (default) server.\n     *\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean resolveServerConflict() {\n        final ProjectRepositoryManager projectManager = TFSEclipseClientPlugin.getDefault().getProjectManager();\n\n        /*\n         * If no projects are currently managed by TFS, allow this connection to\n         * proceed. (Examine all non-connecting projects -- we may be called\n         * during a connection and want to ignore ourselves.)\n         */\n        final IProject[] projects = projectManager.getProjectsOfStatus(ProjectRepositoryStatus.ONLINE);\n\n        if (projects.length == 0) {\n            if (promptForSave() == false) {\n                return false;\n            }\n\n            disconnectDefaultServer();\n            return true;\n        }\n\n        /*\n         * There are managed projects, we need to prompt to disconnect them.\n         */\n\n        if (promptForDisconnect() == false) {\n            return false;\n        }\n\n        /* Prompt to save dirty editors */\n        if (promptForSave() == false) {\n            return false;\n        }\n\n        /*\n         * Disconnect these projects from their repository - this will bring the\n         * projects offline (but will not persist offline state.) This is done\n         * so that we can close the repository gracefully, then close the\n         * projects in the background. If the project close fails, the projects\n         * will still be in a sane (disconnected) state.\n         */\n\n        TFSEclipseClientPlugin.getDefault().getProjectManager().disconnect(projects, false);\n\n        disconnectDefaultServer();\n\n        return true;\n    }\n\n    /**\n     * Allows the user to resolve a repository conflict, caused by trying to\n     * connect to a repository that is not the currently-connected (default)\n     * repository.\n     *\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean resolveRepositoryConflict() {\n        final ProjectRepositoryManager projectManager = TFSEclipseClientPlugin.getDefault().getProjectManager();\n\n        /*\n         * If no projects are currently managed by TFS, allow this connection to\n         * proceed. (Examine all non-connecting projects -- we may be called\n         * during a connection and want to ignore ourselves.)\n         */\n        final IProject[] projects = projectManager.getProjectsOfStatus(ProjectRepositoryStatus.ONLINE);\n\n        if (projects.length == 0) {\n            if (promptForSave() == false) {\n                return false;\n            }\n\n            disconnectDefaultRepository();\n            return true;\n        }\n\n        /*\n         * There are managed projects, we need to prompt to disconnect them.\n         */\n\n        if (promptForDisconnect() == false) {\n            return false;\n        }\n\n        /* Prompt to save dirty editors */\n        if (promptForSave() == false) {\n            return false;\n        }\n\n        /*\n         * Disconnect these projects from their repository - this will bring the\n         * projects offline (but will not persist offline state.) This is done\n         * so that we can close the repository gracefully, then close the\n         * projects in the background. If the project close fails, the projects\n         * will still be in a sane (disconnected) state.\n         *\n         * Do not disconnect the server with the repositories.\n         */\n        TFSEclipseClientPlugin.getDefault().getProjectManager().disconnect(projects, false);\n\n        disconnectDefaultRepository();\n\n        return true;\n    }\n\n    private boolean promptForSave() {\n        /* Synchronize for visibility */\n        final Object cancelLock = new Object();\n        final boolean[] cancel = new boolean[1];\n\n        UIHelpers.runOnUIThread(false, new Runnable() {\n            @Override\n            public void run() {\n                synchronized (cancelLock) {\n                    cancel[0] =\n                        EditorHelper.saveAllDirtyEditors(new TFSEditorSaveableFilter(TFSEditorSaveableType.ALL));\n                }\n            }\n        });\n\n        synchronized (cancelLock) {\n            return cancel[0];\n        }\n    }\n\n    private boolean promptForDisconnect() {\n        final Shell parentShell = ShellUtils.getWorkbenchShell();\n\n        /* Synchronize for visibility */\n        final Object retryLock = new Object();\n        final boolean[] retry = new boolean[1];\n\n        UIHelpers.runOnUIThread(false, new Runnable() {\n            @Override\n            public void run() {\n                synchronized (retryLock) {\n                    retry[0] = MessageDialog.openQuestion(\n                        parentShell,\n                        Messages.getString(\"EclipseUIConnectionConflictHandler.DisconnectProjectsPromptTitle\"), //$NON-NLS-1$\n                        Messages.getString(\"EclipseUIConnectionConflictHandler.DisconnectProjectsPromptMessage\")); //$NON-NLS-1$\n                }\n            }\n        });\n\n        synchronized (retryLock) {\n            return retry[0];\n        }\n    }\n\n    private void disconnectDefaultServer() {\n        final ServerManager serverManager = TFSEclipseClientUIPlugin.getDefault().getServerManager();\n        final RepositoryManager repositoryManager = TFSEclipseClientUIPlugin.getDefault().getRepositoryManager();\n\n        /* Remove the current repository and server from the manager. */\n        if (repositoryManager.getDefaultRepository() != null) {\n            repositoryManager.getDefaultRepository().close();\n            repositoryManager.removeRepository(repositoryManager.getDefaultRepository());\n        }\n\n        if (serverManager.getDefaultServer() != null) {\n            serverManager.getDefaultServer().close();\n            serverManager.removeServer(serverManager.getDefaultServer());\n        }\n    }\n\n    private void disconnectDefaultRepository() {\n        final RepositoryManager repositoryManager = TFSEclipseClientUIPlugin.getDefault().getRepositoryManager();\n\n        /* Remove the current repository and server from the manager. */\n        if (repositoryManager.getDefaultRepository() != null) {\n            repositoryManager.getDefaultRepository().close();\n            repositoryManager.removeRepository(repositoryManager.getDefaultRepository());\n        }\n    }\n\n    /**\n     * Notifies the user that he/she is trying to connect to a server that is\n     * not the currently-connected (default) server.\n     */\n    @Override\n    public void notifyServerConflict() {\n        notifyConflict();\n    }\n\n    /**\n     * Notifies the user that he/she is trying to connect to a repository that\n     * is not the currently-connected (default) repository.\n     */\n    @Override\n    public void notifyRepositoryConflict() {\n        notifyConflict();\n    }\n\n<fim_suffix>    private void notifyConflict() {\n        final Shell parentShell = ShellUtils.getWorkbenchShell();\n\n        UIHelpers.runOnUIThread(true, new Runnable() {\n            @Override\n            public void run() {\n                MessageDialog.openWarning(\n                    parentShell,\n                    Messages.getString(\"EclipseConnectionConflictHandler.ConnectionExistsDialogTitle\"), //$NON-NLS-1$\n                    Messages.getString(\"EclipseConnectionConflictHandler.ConnectionExistsDialogText\")); //$NON-NLS-1$\n            }\n        });\n    }\n}<fim_middle>// function below has no smell\n"}