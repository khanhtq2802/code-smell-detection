{"text": "<fim_prefix>/*\n * Copyright (c) 2013, 2018, Oracle and/or its affiliates. All rights reserved.\n * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage org.graalvm.compiler.lir.aarch64;\nimport static jdk.vm.ci.aarch64.AArch64.sp;\nimport static jdk.vm.ci.aarch64.AArch64.zr;\nimport static jdk.vm.ci.code.ValueUtil.asAllocatableValue;\nimport static jdk.vm.ci.code.ValueUtil.asRegister;\nimport static jdk.vm.ci.code.ValueUtil.asStackSlot;\nimport static jdk.vm.ci.code.ValueUtil.isRegister;\nimport static jdk.vm.ci.code.ValueUtil.isStackSlot;\nimport static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.COMPOSITE;\nimport static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.HINT;\nimport static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.REG;\nimport static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.STACK;\nimport static org.graalvm.compiler.lir.LIRInstruction.OperandFlag.UNINITIALIZED;\nimport static org.graalvm.compiler.lir.LIRValueUtil.asJavaConstant;\nimport static org.graalvm.compiler.lir.LIRValueUtil.isJavaConstant;\nimport org.graalvm.compiler.asm.aarch64.AArch64Address;\nimport org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler;\nimport org.graalvm.compiler.asm.aarch64.AArch64MacroAssembler.ScratchRegister;\nimport org.graalvm.compiler.core.common.LIRKind;\nimport org.graalvm.compiler.core.common.type.DataPointerConstant;\nimport org.graalvm.compiler.debug.GraalError;\nimport org.graalvm.compiler.lir.LIRFrameState;\nimport org.graalvm.compiler.lir.LIRInstructionClass;\nimport org.graalvm.compiler.lir.Opcode;\nimport org.graalvm.compiler.lir.StandardOp;\nimport org.graalvm.compiler.lir.StandardOp.LoadConstantOp;\nimport org.graalvm.compiler.lir.StandardOp.NullCheck;\nimport org.graalvm.compiler.lir.StandardOp.ValueMoveOp;\nimport org.graalvm.compiler.lir.VirtualStackSlot;\nimport org.graalvm.compiler.lir.asm.CompilationResultBuilder;\nimport jdk.vm.ci.aarch64.AArch64Kind;\nimport jdk.vm.ci.code.MemoryBarriers;\nimport jdk.vm.ci.code.Register;\nimport jdk.vm.ci.code.StackSlot;\nimport jdk.vm.ci.meta.AllocatableValue;\nimport jdk.vm.ci.meta.Constant;\nimport jdk.vm.ci.meta.JavaConstant;\nimport jdk.vm.ci.meta.PlatformKind;\nimport jdk.vm.ci.meta.Value;\npublic class AArch64Move {\n    public static class LoadInlineConstant extends AArch64LIRInstruction implements LoadConstantOp {\n        public static final LIRInstructionClass<LoadInlineConstant> TYPE = LIRInstructionClass.create(LoadInlineConstant.class);\n        private JavaConstant constant;\n        @Def({REG, STACK}) AllocatableValue result;\n        public LoadInlineConstant(JavaConstant constant, AllocatableValue result) {\n            super(TYPE);\n            this.constant = constant;\n            this.result = result;\n        }\n        @Override\n        public void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {\n            if (isRegister(result)) {\n                const2reg(crb, masm, result, constant);\n            } else if (isStackSlot(result)) {\n                StackSlot slot = asStackSlot(result);\n                const2stack(crb, masm, slot, constant);\n            }\n        }\n        @Override\n        public Constant getConstant() {\n            return constant;\n        }\n        @Override\n        public AllocatableValue getResult() {\n            return result;\n        }\n    }\n    @Opcode(\"MOVE\")\n    public static class Move extends AArch64LIRInstruction implements ValueMoveOp {\n        public static final LIRInstructionClass<Move> TYPE = LIRInstructionClass.create(Move.class);\n        @Def({REG, STACK, HINT}) protected AllocatableValue result;\n        @Use({REG, STACK}) protected AllocatableValue input;\n        public Move(AllocatableValue result, AllocatableValue input) {\n            super(TYPE);\n            this.result = result;\n            this.input = input;\n            assert !(isStackSlot(result) && isStackSlot(input));\n        }\n        @Override\n        public void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {\n            move(crb, masm, getResult(), getInput());\n        }\n        @Override\n        public AllocatableValue getInput() {\n            return input;\n        }\n        @Override\n        public AllocatableValue getResult() {\n            return result;\n        }\n    }\n    public static class LoadAddressOp extends AArch64LIRInstruction {\n        public static final LIRInstructionClass<LoadAddressOp> TYPE = LIRInstructionClass.create(LoadAddressOp.class);\n        @Def protected AllocatableValue result;\n        @Use(COMPOSITE) protected AArch64AddressValue address;\n        public LoadAddressOp(AllocatableValue result, AArch64AddressValue address) {\n            super(TYPE);\n            this.result = result;\n            this.address = address;\n        }\n        @Override\n        public void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {\n            Register dst = asRegister(result);\n            AArch64Address adr = address.toAddress();\n            masm.loadAddress(dst, adr, address.getScaleFactor());\n        }\n    }\n    public static class LoadDataOp extends AArch64LIRInstruction {\n        public static final LIRInstructionClass<LoadDataOp> TYPE = LIRInstructionClass.create(LoadDataOp.class);\n        @Def protected AllocatableValue result;\n        private final DataPointerConstant data;\n<fim_suffix>        public LoadDataOp(AllocatableValue result, DataPointerConstant data) {\n            super(TYPE);\n            this.result = result;\n            this.data = data;\n        }\n        @Override\n        public void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {\n            Register dst = asRegister(result);\n            if (crb.compilationResult.isImmutablePIC()) {\n                crb.recordDataReferenceInCode(data);\n                masm.addressOf(dst);\n            } else {\n                masm.loadAddress(dst, (AArch64Address) crb.recordDataReferenceInCode(data), data.getAlignment());\n            }\n        }\n    }\n    public static class StackLoadAddressOp extends AArch64LIRInstruction {\n        public static final LIRInstructionClass<StackLoadAddressOp> TYPE = LIRInstructionClass.create(StackLoadAddressOp.class);\n        @Def protected AllocatableValue result;\n        @Use({STACK, UNINITIALIZED}) protected AllocatableValue slot;\n        public StackLoadAddressOp(AllocatableValue result, AllocatableValue slot) {\n            super(TYPE);\n            assert slot instanceof VirtualStackSlot || slot instanceof StackSlot;\n            this.result = result;\n            this.slot = slot;\n        }\n        @Override\n        public void emitCode(CompilationResultBuilder crb, AArch64MacroAssembler masm) {<fim_middle>// function below has no smell\n"}