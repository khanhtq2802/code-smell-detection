{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.brooklyn.entity.proxy;\n\nimport java.io.Serializable;\nimport java.util.Map;\n\nimport org.apache.brooklyn.util.core.flags.FlagUtils;\nimport org.apache.brooklyn.util.core.flags.SetFromFlag;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.google.common.base.Objects;\n\npublic class ProxySslConfig implements Serializable {\n\n    private static final long serialVersionUID = -2692754611458939617L;\n\n    private static final Logger log = LoggerFactory.getLogger(ProxySslConfig.class);\n    \n    public static Builder builder() {\n        return new Builder();\n    }\n\n    public static class Builder {\n        @SetFromFlag protected String certificateSourceUrl;\n        @SetFromFlag protected String keySourceUrl;\n        @SetFromFlag protected String certificateDestination;\n        @SetFromFlag protected String keyDestination;\n        @SetFromFlag protected boolean targetIsSsl = false;\n        @SetFromFlag protected boolean reuseSessions = false;\n\n        public Builder certificateSourceUrl(String val) {\n            certificateSourceUrl = val; return this;\n        }\n        public Builder keySourceUrl(String val) {\n            keySourceUrl = val; return this;\n        }\n        public Builder certificateDestination(String val) {\n            certificateDestination = val; return this;\n        }\n        public Builder keyDestination(String val) {\n            keyDestination = val; return this;\n        }\n        public Builder targetIsSsl(boolean val) {\n            targetIsSsl = val; return this;\n        }\n        public Builder reuseSessions(boolean val) {\n            reuseSessions = val; return this;\n        }\n        public ProxySslConfig build() {\n            ProxySslConfig result = new ProxySslConfig(this);\n            return result;\n        }\n    }\n    \n    public static ProxySslConfig fromMap(Map<?,?> map) {\n        Builder b = new Builder();\n        Map<?, ?> unused = FlagUtils.setFieldsFromFlags(map, b);\n        if (!unused.isEmpty()) log.warn(\"Unused flags when populating \"+b+\" (ignoring): \"+unused);\n        return b.build();\n    }\n\n    private String certificateSourceUrl;\n    private String keySourceUrl;\n    private String certificateDestination;\n    private String keyDestination;\n    private boolean targetIsSsl = false;\n    private boolean reuseSessions = false;\n\n    public ProxySslConfig() { }\n\n    protected ProxySslConfig(Builder builder) {\n        certificateSourceUrl = builder.certificateSourceUrl;\n        keySourceUrl = builder.keySourceUrl;\n        certificateDestination = builder.certificateDestination;\n        keyDestination = builder.keyDestination;\n        targetIsSsl = builder.targetIsSsl;\n        reuseSessions = builder.reuseSessions;\n    }\n\n    /**\n     * URL for the SSL certificates required at the server.\n     * <p>\n     * Corresponding nginx settings:\n     * <pre>\n     *     ssl                  on;\n     *     ssl_certificate      www.example.com.crt;\n     *     ssl_certificate_key  www.example.com.key;\n     * </pre>\n     * Okay (in nginx) for key to be null if certificate contains both as per setup at\n     * http://nginx.org/en/docs/http/configuring_https_servers.html\n     * <p>\n     * Proxy object can be set on nginx instance to apply site-wide,\n     * and to put multiple servers in the certificate file\n     * <p>\n     * The brooklyn entity will install the certificate/key(s) on the server.\n     * (however it will not currently merge multiple certificates.\n     * if conflicting certificates are attempted to be installed nginx will complain.)\n     */\n    public String getCertificateSourceUrl() {\n        return certificateSourceUrl;\n    }\n\n    public void setCertificateSourceUrl(String certificateSourceUrl) {\n        this.certificateSourceUrl = certificateSourceUrl;\n    }\n\n    /** @see #getCertificateSourceUrl()} */\n    public String getKeySourceUrl() {\n        return keySourceUrl;\n    }\n\n    public void setKeySourceUrl(String keySourceUrl) {\n        this.keySourceUrl = keySourceUrl;\n    }\n\n    /**\n     * Sets the {@code ssl_certificate_path} to be used within the generated\n     * {@link LoadBalancer} configuration.\n     * <p>\n     * If set to null, Brooklyn will use an auto generated path.\n     * <p>\n     * If {@link #getCertificateSourceUrl() certificateSourceUrl} is set     *\n     * then Brooklyn will copy the certificate the destination.\n     * <p>\n     * Setting this field is useful if there is a {@code certificate} on the\n     * nginx machine you want to make use of.\n     */\n    public String getCertificateDestination() {\n        return certificateDestination;\n    }\n\n    public void setCertificateDestination(String certificateDestination) {\n        this.certificateDestination = certificateDestination;\n    }\n\n    /**\n     * Sets the {@code ssl_certificate_key} path to be used within the generated\n     * {@link LoadBalancer} configuration.\n     * <p>\n     * If set to null, Brooklyn will use an auto generated path.\n     * <p>\n     * If {@link #getKeySourceUrl() keySourceUrl} is set then Brooklyn will copy the\n     * certificate to the destination.\n     * <p>\n     * Setting this field is useful if there is a {@code certificate_key} on the\n     * nginx machine you want to make use of.\n     */\n    public String getKeyDestination() {\n        return keyDestination;\n    }\n\n    public void setKeyDestination(String keyDestination) {\n        this.keyDestination = keyDestination;\n    }\n\n    /**\n     * Whether the downstream server (if mapping) also expects https; default false.\n     */\n    public boolean getTargetIsSsl() {\n        return targetIsSsl;\n    }\n\n    public void setTargetIsSsl(boolean targetIsSsl) {\n        this.targetIsSsl = targetIsSsl;\n    }\n\n    /**\n     * Whether to reuse SSL validation in the server (performance).\n     * <p>\n     * Corresponds to nginx setting {@code proxy_ssl_session_reuse on|off}.\n     */\n    public boolean getReuseSessions() {\n        return reuseSessions;\n    }\n\n<fim_suffix>    public void setReuseSessions(boolean reuseSessions) {\n        this.reuseSessions = reuseSessions;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hashCode(certificateSourceUrl, keySourceUrl, certificateDestination, keyDestination, reuseSessions, targetIsSsl);\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (obj == null)\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        ProxySslConfig other = (ProxySslConfig) obj;\n\n        return Objects.equal(certificateSourceUrl, other.certificateSourceUrl) &&\n                Objects.equal(certificateDestination, other.certificateDestination) &&\n                Objects.equal(keyDestination, other.keyDestination) &&\n                Objects.equal(keySourceUrl, other.keySourceUrl) &&\n                Objects.equal(reuseSessions, other.reuseSessions) &&\n                Objects.equal(targetIsSsl, other.targetIsSsl);\n    }\n}<fim_middle>// function below has no smell\n"}