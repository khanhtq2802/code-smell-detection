{"text": "<fim_prefix>//\n//  ========================================================================\n//  Copyright (c) 1995-2019 Mort Bay Consulting Pty. Ltd.\n//  ------------------------------------------------------------------------\n//  All rights reserved. This program and the accompanying materials\n//  are made available under the terms of the Eclipse Public License v1.0\n//  and Apache License v2.0 which accompanies this distribution.\n//\n//      The Eclipse Public License is available at\n//      http://www.eclipse.org/legal/epl-v10.html\n//\n//      The Apache License v2.0 is available at\n//      http://www.opensource.org/licenses/apache2.0.php\n//\n//  You may elect to redistribute this code under either of these licenses.\n//  ========================================================================\n//\n\npackage org.eclipse.jetty.server;\n\n\nimport javax.servlet.AsyncContext;\nimport javax.servlet.AsyncEvent;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletContext;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\n\nimport org.eclipse.jetty.server.handler.ContextHandler.Context;\nimport org.eclipse.jetty.util.thread.Scheduler;\n\npublic class AsyncContextEvent extends AsyncEvent implements Runnable\n{\n    final private Context _context;\n    final private AsyncContextState _asyncContext;\n    private volatile HttpChannelState _state;\n    private ServletContext _dispatchContext;\n    private String _dispatchPath;\n    private volatile Scheduler.Task _timeoutTask;\n    private Throwable _throwable;\n\n<fim_suffix>    public AsyncContextEvent(Context context,AsyncContextState asyncContext, HttpChannelState state, Request baseRequest, ServletRequest request, ServletResponse response)\n    {\n        super(null,request,response,null);\n        _context=context;\n        _asyncContext=asyncContext;\n        _state=state;\n\n        // If we haven't been async dispatched before\n        if (baseRequest.getAttribute(AsyncContext.ASYNC_REQUEST_URI)==null)\n        {\n            // We are setting these attributes during startAsync, when the spec implies that\n            // they are only available after a call to AsyncContext.dispatch(...);\n\n            // have we been forwarded before?\n            String uri=(String)baseRequest.getAttribute(RequestDispatcher.FORWARD_REQUEST_URI);\n            if (uri!=null)\n            {\n                baseRequest.setAttribute(AsyncContext.ASYNC_REQUEST_URI,uri);\n                baseRequest.setAttribute(AsyncContext.ASYNC_CONTEXT_PATH,baseRequest.getAttribute(RequestDispatcher.FORWARD_CONTEXT_PATH));\n                baseRequest.setAttribute(AsyncContext.ASYNC_SERVLET_PATH,baseRequest.getAttribute(RequestDispatcher.FORWARD_SERVLET_PATH));\n                baseRequest.setAttribute(AsyncContext.ASYNC_PATH_INFO,baseRequest.getAttribute(RequestDispatcher.FORWARD_PATH_INFO));\n                baseRequest.setAttribute(AsyncContext.ASYNC_QUERY_STRING,baseRequest.getAttribute(RequestDispatcher.FORWARD_QUERY_STRING));\n            }\n            else\n            {\n                baseRequest.setAttribute(AsyncContext.ASYNC_REQUEST_URI,baseRequest.getRequestURI());\n                baseRequest.setAttribute(AsyncContext.ASYNC_CONTEXT_PATH,baseRequest.getContextPath());\n                baseRequest.setAttribute(AsyncContext.ASYNC_SERVLET_PATH,baseRequest.getServletPath());\n                baseRequest.setAttribute(AsyncContext.ASYNC_PATH_INFO,baseRequest.getPathInfo());\n                baseRequest.setAttribute(AsyncContext.ASYNC_QUERY_STRING,baseRequest.getQueryString());\n            }\n        }\n    }\n\n    public ServletContext getSuspendedContext()\n    {\n        return _context;\n    }\n\n    public Context getContext()\n    {\n        return _context;\n    }\n\n    public ServletContext getDispatchContext()\n    {\n        return _dispatchContext;\n    }\n\n    public ServletContext getServletContext()\n    {\n        return _dispatchContext==null?_context:_dispatchContext;\n    }\n\n    /**\n     * @return The path in the context (encoded with possible query string)\n     */\n    public String getPath()\n    {\n        return _dispatchPath;\n    }\n\n    public void setTimeoutTask(Scheduler.Task task)\n    {\n        _timeoutTask = task;\n    }\n\n    public boolean hasTimeoutTask()\n    {\n        return _timeoutTask!=null;\n    }\n    \n    public void cancelTimeoutTask()\n    {\n        Scheduler.Task task=_timeoutTask;\n        _timeoutTask=null;\n        if (task!=null)\n            task.cancel();\n    }\n\n    @Override\n    public AsyncContext getAsyncContext()\n    {\n        return _asyncContext;\n    }\n\n    @Override\n    public Throwable getThrowable()\n    {\n        return _throwable;\n    }\n\n    public void setDispatchContext(ServletContext context)\n    {\n        _dispatchContext=context;\n    }\n\n    /**\n     * @param path encoded URI\n     */\n    public void setDispatchPath(String path)\n    {\n        _dispatchPath=path;\n    }\n\n    public void completed()\n    {\n        _timeoutTask=null;\n        _asyncContext.reset();\n    }\n\n    public HttpChannelState getHttpChannelState()\n    {\n        return _state;\n    }\n\n    @Override\n    public void run()\n    {\n        Scheduler.Task task=_timeoutTask;\n        _timeoutTask=null;\n        if (task!=null)\n            _state.getHttpChannel().execute(() -> _state.onTimeout());\n    }\n\n    public void addThrowable(Throwable e)\n    {\n        if (_throwable==null)\n            _throwable=e;\n        else if (e != _throwable)\n            _throwable.addSuppressed(e);\n    }\n}<fim_middle>// function below is long method\n"}