{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.activemq.artemis.core.messagecounter;\nimport java.text.DateFormat;\nimport java.util.ArrayList;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.List;\nimport org.apache.activemq.artemis.core.server.Queue;\nimport org.apache.activemq.artemis.utils.JsonLoader;\nimport static org.apache.activemq.artemis.api.core.JsonUtil.nullSafe;\n/**\n * This class stores message count informations for a given queue\n *\n * At intervals this class samples the queue for message count data\n *\n * Note that the underlying queue *does not* update statistics every time a message\n * is added since that would reall slow things down, instead we *sample* the queues at\n * regular intervals - this means we are less intrusive on the queue\n */\npublic class MessageCounter {\n   // Constants -----------------------------------------------------\n   // Attributes ----------------------------------------------------\n   // destination related information\n   private final String destName;\n   private final String destSubscription;\n   private final boolean destTopic;\n   private final boolean destDurable;\n   private final Queue serverQueue;\n   // counter\n   private long countTotal;\n   private long countTotalLast;\n   private long depthLast;\n   private long timeLastUpdate;\n   private long timeLastAdd;\n   // per hour day counter history\n   private int dayCounterMax;\n   private final List<DayCounter> dayCounters;\n   private long lastMessagesAdded;\n   // Static --------------------------------------------------------\n   // Constructors --------------------------------------------------\n   /**\n    * Constructor\n    *\n    * @param name         destination name\n    * @param subscription subscription name\n    * @param serverQueue  internal queue object\n    * @param topic        topic destination flag\n    * @param durable      durable subscription flag\n    * @param daycountmax  max message history day count\n    */\n   public MessageCounter(final String name,\n                         final String subscription,\n                         final Queue serverQueue,\n                         final boolean topic,\n                         final boolean durable,\n                         final int daycountmax) {\n      // store destination related information\n      destName = name;\n      destSubscription = subscription;\n      destTopic = topic;\n      destDurable = durable;\n      this.serverQueue = serverQueue;\n      // initialize counter\n      resetCounter();\n      // initialize message history\n      dayCounters = new ArrayList<>();\n      setHistoryLimit(daycountmax);\n   }\n   private final Runnable onTimeExecutor = new Runnable() {\n      @Override\n      public void run() {\n         long latestMessagesAdded = serverQueue.getMessagesAdded();\n         long newMessagesAdded = latestMessagesAdded - lastMessagesAdded;\n         countTotal += newMessagesAdded;\n         lastMessagesAdded = latestMessagesAdded;\n         if (newMessagesAdded > 0) {\n            timeLastAdd = System.currentTimeMillis();\n         }\n         // update timestamp\n         timeLastUpdate = System.currentTimeMillis();\n         // update message history\n         updateHistory(newMessagesAdded);\n      }\n   };\n   // Public --------------------------------------------------------\n   /*\n    * This method is called periodically to update statistics from the queue\n    */\n   public synchronized void onTimer() {\n      // Actor approach here: Instead of having the Counter locking the queue, we will use the Queue's executor\n      // instead of possibly making a lock on the queue.\n      // This way the scheduled Threads will be free to keep doing their pings in case the server is busy with paging or\n      // any other deliveries\n      serverQueue.getExecutor().execute(onTimeExecutor);\n   }\n   public String getDestinationName() {\n      return destName;\n   }\n   public String getDestinationSubscription() {\n      return destSubscription;\n   }\n   public boolean isDestinationTopic() {\n      return destTopic;\n   }\n   public boolean isDestinationDurable() {\n      return destDurable;\n   }\n   /**\n    * Gets the total message count since startup or\n    * last counter reset\n    */\n   public long getCount() {\n      return countTotal;\n   }\n   /**\n    * Gets the message count delta since last method call\n    */\n   public long getCountDelta() {\n      long delta = countTotal - countTotalLast;\n      countTotalLast = countTotal;\n      return delta;\n   }\n   /**\n    * Gets the current message count of pending messages\n    * within the destination waiting for dispatch\n    */\n   public long getMessageCount() {\n      return serverQueue.getMessageCount();\n   }\n   /**\n    * Gets the message count delta of pending messages\n    * since last method call.\n    */\n   public long getMessageCountDelta() {\n      long current = serverQueue.getMessageCount();\n      int delta = (int) (current - depthLast);\n      depthLast = current;\n      return delta;\n   }\n   public long getLastUpdate() {\n      return timeLastUpdate;\n   }\n   public long getLastAddedMessageTime() {\n      return timeLastAdd;\n   }\n   public void resetCounter() {\n      countTotal = 0;\n      countTotalLast = 0;\n      depthLast = 0;\n      timeLastUpdate = 0;\n      timeLastAdd = 0;\n   }\n   private void setHistoryLimit(final int daycountmax) {\n      boolean bInitialize = false;\n      // store new maximum day count\n      dayCounterMax = daycountmax;\n      // update day counter array\n      synchronized (dayCounters) {\n         if (dayCounterMax > 0) {\n            // limit day history to specified day count\n            int delta = dayCounters.size() - dayCounterMax;\n            for (int i = 0; i < delta; i++) {\n               // reduce array size to requested size by dropping\n               // oldest day counters\n               dayCounters.remove(0);\n            }\n            // create initial day counter when empty\n            bInitialize = dayCounters.isEmpty();\n         } else if (dayCounterMax == 0) {\n            // disable history\n            dayCounters.clear();\n         } else {\n            // unlimited day history\n            // create initial day counter when empty\n            bInitialize = dayCounters.isEmpty();\n         }\n         // optionally initialize first day counter entry\n         if (bInitialize) {\n            dayCounters.add(new DayCounter(new GregorianCalendar(), true));\n         }\n      }\n   }\n<fim_suffix>   public void resetHistory() {\n      int max = dayCounterMax;\n      setHistoryLimit(0);\n      setHistoryLimit(max);\n   }\n   public List<DayCounter> getHistory() {\n      updateHistory(0);\n      return new ArrayList<>(dayCounters);\n   }\n   /**\n    * Get message counter history data as string in format\n    *\n    * \"day count\\n\n    * Date 1, hour counter 0, hour counter 1, ..., hour counter 23\\n\n    * Date 2, hour counter 0, hour counter 1, ..., hour counter 23\\n\n    * .....\n    * .....\n    * Date n, hour counter 0, hour counter 1, ..., hour counter 23\\n\"\n    *\n    * @return String   message history data string\n    */\n   public String getHistoryAsString() {\n      StringBuilder ret = new StringBuilder();\n      // ensure history counters are up to date\n      updateHistory(0);\n      // compile string\n      synchronized (dayCounters) {\n         // first line: history day count\n         ret.append(dayCounters.size() + \"\\n\");\n         // following lines: day counter data\n         for (DayCounter counter : dayCounters) {\n            ret.append(counter.getDayCounterAsString() + \"\\n\");\n         }\n      }\n      return ret.toString();\n   }\n   @Override\n   public String toString() {\n      return \"MessageCounter[destName\" + destName +\n         \", destSubscription=\" +\n         destSubscription +\n         \", destTopic=\" +\n         destTopic +\n         \", destDurable=\" +\n         destDurable +\n         \", serverQueue =\" +\n         serverQueue +\n         \"]\";\n   }\n   /**\n    * Returns a JSON String serialization of a {@link MessageCounter} object.\n    *\n    * @return\n    */\n   public String toJSon() {\n      DateFormat dateFormat = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.MEDIUM);\n      String lastAddTimestamp = dateFormat.format(new Date(this.getLastAddedMessageTime()));\n      String updateTimestamp = dateFormat.format(new Date(this.getLastUpdate()));\n      return JsonLoader\n         .createObjectBuilder()\n         .add(\"destinationName\", nullSafe(this.getDestinationName()))\n         .add(\"destinationSubscription\", nullSafe(this.getDestinationSubscription()))\n         .add(\"destinationDurable\", this.isDestinationDurable())\n         .add(\"count\", this.getCount())\n         .add(\"countDelta\", this.getCountDelta())\n         .add(\"messageCount\", this.getMessageCount())<fim_middle>// function below has no smell\n"}