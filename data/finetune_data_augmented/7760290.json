{"text": "<fim_prefix>   *\n   * @return a FileCopyResult of the files which were written to disk\n   *\n   * @throws IOException\n   */\n  public static FileUtils.FileCopyResult unzip(final File pulledFile, final File outDir) throws IOException\n  {\n    if (!(outDir.exists() && outDir.isDirectory())) {\n      throw new ISE(\"outDir[%s] must exist and be a directory\", outDir);\n    }\n    log.info(\"Unzipping file[%s] to [%s]\", pulledFile, outDir);\n    final FileUtils.FileCopyResult result = new FileUtils.FileCopyResult();\n    try (final ZipFile zipFile = new ZipFile(pulledFile)) {\n      final Enumeration<? extends ZipEntry> enumeration = zipFile.entries();\n      while (enumeration.hasMoreElements()) {\n        final ZipEntry entry = enumeration.nextElement();\n        final File outFile = new File(outDir, entry.getName());\n        validateZipOutputFile(pulledFile.getCanonicalPath(), outFile, outDir);\n        result.addFiles(\n            FileUtils.retryCopy(\n                new ByteSource()\n                {\n                  @Override\n                  public InputStream openStream() throws IOException\n                  {\n                    return new BufferedInputStream(zipFile.getInputStream(entry));\n                  }\n                },\n                outFile,\n                FileUtils.IS_EXCEPTION,\n                DEFAULT_RETRY_COUNT\n            ).getFiles()\n        );\n      }\n    }\n    return result;\n  }\n  public static void validateZipOutputFile(\n      String sourceFilename,\n      final File outFile,\n      final File outDir\n  ) throws IOException\n  {\n    // check for evil zip exploit that allows writing output to arbitrary directories\n    final File canonicalOutFile = outFile.getCanonicalFile();\n    final String canonicalOutDir = outDir.getCanonicalPath();\n    if (!canonicalOutFile.toPath().startsWith(canonicalOutDir)) {\n      throw new ISE(\n          \"Unzipped output path[%s] of sourceFile[%s] does not start with outDir[%s].\",\n          canonicalOutFile,\n          sourceFilename,\n          canonicalOutDir\n      );\n    }\n  }\n  /**\n   * Unzip from the input stream to the output directory, using the entry's file name as the file name in the output directory.\n   * The behavior of directories in the input stream's zip is undefined.\n   * If possible, it is recommended to use unzip(ByteStream, File) instead\n   *\n   * @param in     The input stream of the zip data. This stream is closed\n   * @param outDir The directory to copy the unzipped data to\n   *\n   * @return The FileUtils.FileCopyResult containing information on all the files which were written\n   *\n   * @throws IOException\n   */\n  public static FileUtils.FileCopyResult unzip(InputStream in, File outDir) throws IOException\n  {\n    try (final ZipInputStream zipIn = new ZipInputStream(in)) {\n      final FileUtils.FileCopyResult result = new FileUtils.FileCopyResult();\n      ZipEntry entry;\n      while ((entry = zipIn.getNextEntry()) != null) {\n        final File file = new File(outDir, entry.getName());\n        validateZipOutputFile(\"\", file, outDir);\n        NativeIO.chunkedCopy(zipIn, file);\n        result.addFile(file);\n        zipIn.closeEntry();\n      }\n      return result;\n    }\n  }\n  /**\n   * gunzip the file to the output file.\n   *\n   * @param pulledFile The source of the gz data\n   * @param outFile    A target file to put the contents\n   *\n   * @return The result of the file copy\n   *\n   * @throws IOException\n   */\n  public static FileUtils.FileCopyResult gunzip(final File pulledFile, File outFile)\n  {\n    return gunzip(Files.asByteSource(pulledFile), outFile);\n  }\n  /**\n   * Unzips the input stream via a gzip filter. use gunzip(ByteSource, File, Predicate) if possible\n   *\n   * @param in      The input stream to run through the gunzip filter. This stream is closed\n   * @param outFile The file to output to\n   *\n   * @throws IOException\n   */\n  public static FileUtils.FileCopyResult gunzip(InputStream in, File outFile) throws IOException\n  {\n    try (GZIPInputStream gzipInputStream = gzipInputStream(in)) {\n      NativeIO.chunkedCopy(gzipInputStream, outFile);\n      return new FileUtils.FileCopyResult(outFile);\n    }\n  }\n  /**\n   * Fixes java bug 7036144 http://bugs.java.com/bugdatabase/view_bug.do?bug_id=7036144 which affects concatenated GZip\n   *\n   * @param in The raw input stream\n   *\n   * @return A GZIPInputStream that can handle concatenated gzip streams in the input\n   *\n   * @see #decompress(InputStream, String) which should be used instead for streams coming from files\n   */\n  public static GZIPInputStream gzipInputStream(final InputStream in) throws IOException\n  {\n    return new GZIPInputStream(\n        new FilterInputStream(in)\n        {\n          @Override\n          public int available() throws IOException\n          {\n            final int otherAvailable = super.available();\n            // Hack. Docs say available() should return an estimate,\n            // so we estimate about 1KB to work around available == 0 bug in GZIPInputStream\n            return otherAvailable == 0 ? 1 << 10 : otherAvailable;\n          }\n        }\n    );\n  }\n  /**\n   * gunzip from the source stream to the destination stream.\n   *\n   * @param in  The input stream which is to be decompressed. This stream is closed.\n   * @param out The output stream to write to. This stream is closed\n   *\n   * @return The number of bytes written to the output stream.\n   *\n   * @throws IOException\n   */\n  public static long gunzip(InputStream in, OutputStream out) throws IOException\n  {\n    try (GZIPInputStream gzipInputStream = gzipInputStream(in)) {\n      final long result = ByteStreams.copy(gzipInputStream, out);\n      out.flush();\n      return result;\n    }\n    finally {\n      out.close();\n    }\n  }\n  /**\n   * A gunzip function to store locally\n   *\n   * @param in          The factory to produce input streams\n   * @param outFile     The file to store the result into\n   * @param shouldRetry A predicate to indicate if the Throwable is recoverable\n   *\n   * @return The count of bytes written to outFile\n   */\n  public static FileUtils.FileCopyResult gunzip(\n      final ByteSource in,\n      final File outFile,\n      Predicate<Throwable> shouldRetry\n  )\n  {\n    return FileUtils.retryCopy(\n        new ByteSource()\n        {\n          @Override\n          public InputStream openStream() throws IOException\n          {\n            return gzipInputStream(in.openStream());\n          }\n        },\n        outFile,\n        shouldRetry,\n        DEFAULT_RETRY_COUNT\n    );\n  }\n  /**\n   * Gunzip from the input stream to the output file\n   *\n   * @param in      The compressed input stream to read from\n   * @param outFile The file to write the uncompressed results to\n   *\n   * @return A FileCopyResult of the file written\n   */\n  public static FileUtils.FileCopyResult gunzip(final ByteSource in, File outFile)\n  {\n    return gunzip(in, outFile, FileUtils.IS_EXCEPTION);\n  }\n  /**\n   * Copy inputStream to out while wrapping out in a GZIPOutputStream\n   * Closes both input and output\n   *\n   * @param inputStream The input stream to copy data from. This stream is closed\n   * @param out         The output stream to wrap in a GZIPOutputStream before copying. This stream is closed\n   *\n   * @return The size of the data copied\n   *\n   * @throws IOException\n   */\n  public static long gzip(InputStream inputStream, OutputStream out) throws IOException\n  {\n    try (GZIPOutputStream outputStream = new GZIPOutputStream(out)) {\n      final long result = ByteStreams.copy(inputStream, outputStream);\n      out.flush();\n      return result;\n    }\n    finally {\n      inputStream.close();\n    }\n  }\n  /**\n   * Gzips the input file to the output\n   *\n   * @param inFile      The file to gzip\n   * @param outFile     A target file to copy the uncompressed contents of inFile to\n   * @param shouldRetry Predicate on a potential throwable to determine if the copy should be attempted again.\n   *\n   * @return The result of the file copy\n   *\n   * @throws IOException\n   */\n  public static FileUtils.FileCopyResult gzip(final File inFile, final File outFile, Predicate<Throwable> shouldRetry)\n  {\n    gzip(Files.asByteSource(inFile), Files.asByteSink(outFile), shouldRetry);\n    return new FileUtils.FileCopyResult(outFile);\n  }\n<fim_suffix>  public static long gzip(final ByteSource in, final ByteSink out, Predicate<Throwable> shouldRetry)\n  {\n    return StreamUtils.retryCopy(\n        in,\n        new ByteSink()\n        {\n          @Override\n          public OutputStream openStream() throws IOException\n          {\n            return new GZIPOutputStream(out.openStream());\n          }\n        },\n        shouldRetry,\n        DEFAULT_RETRY_COUNT\n    );\n  }<fim_middle>// function below has no smell\n"}