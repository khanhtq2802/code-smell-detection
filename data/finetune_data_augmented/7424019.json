{"text": "<fim_prefix>                if (input.isNull()) {\n                    return true;\n                } else {\n                    return false;\n                }\n            default:\n                return false;\n        }\n        return true;\n    }\n    public static void const2stack(CompilationResultBuilder crb, AMD64MacroAssembler masm, Value result, JavaConstant input) {\n        AMD64Address dest = (AMD64Address) crb.asAddress(result);\n        final long imm;\n        switch (input.getJavaKind().getStackKind()) {\n            case Int:\n                imm = input.asInt();\n                break;\n            case Long:\n                imm = input.asLong();\n                break;\n            case Float:\n                imm = floatToRawIntBits(input.asFloat());\n                break;\n            case Double:\n                imm = doubleToRawLongBits(input.asDouble());\n                break;\n            case Object:\n                if (input.isNull()) {\n                    if (crb.mustReplaceWithNullRegister(input)) {\n                        masm.movq(dest, crb.nullRegister);\n                        return;\n                    }\n                    imm = 0;\n                } else {\n                    throw GraalError.shouldNotReachHere(\"Non-null object constants must be in register\");\n                }\n                break;\n            default:\n                throw GraalError.shouldNotReachHere();\n        }\n        switch ((AMD64Kind) result.getPlatformKind()) {\n            case BYTE:\n                assert NumUtil.isByte(imm) : \"Is not in byte range: \" + imm;\n                AMD64MIOp.MOVB.emit(masm, OperandSize.BYTE, dest, (int) imm);\n                break;\n            case WORD:\n                assert NumUtil.isShort(imm) : \"Is not in short range: \" + imm;\n                AMD64MIOp.MOV.emit(masm, OperandSize.WORD, dest, (int) imm);\n                break;\n            case DWORD:\n            case SINGLE:\n                assert NumUtil.isInt(imm) : \"Is not in int range: \" + imm;\n                masm.movl(dest, (int) imm);\n                break;\n            case QWORD:\n            case DOUBLE:\n                masm.movlong(dest, imm);\n                break;\n            default:\n                throw GraalError.shouldNotReachHere(\"Unknown result Kind: \" + result.getPlatformKind());\n        }\n    }\n    public abstract static class PointerCompressionOp extends AMD64LIRInstruction {\n        protected final LIRKindTool lirKindTool;\n        protected final CompressEncoding encoding;\n        protected final boolean nonNull;\n        @Def({REG, HINT}) private AllocatableValue result;\n        @Use({REG, CONST}) private Value input;\n        @Alive({REG, ILLEGAL, UNINITIALIZED}) private AllocatableValue baseRegister;\n        protected PointerCompressionOp(LIRInstructionClass<? extends PointerCompressionOp> type, AllocatableValue result, Value input,\n                        AllocatableValue baseRegister, CompressEncoding encoding, boolean nonNull, LIRKindTool lirKindTool) {\n            super(type);\n            this.result = result;\n            this.input = input;\n            this.baseRegister = baseRegister;\n            this.encoding = encoding;\n            this.nonNull = nonNull;\n            this.lirKindTool = lirKindTool;\n        }\n        public static boolean hasBase(OptionValues options, CompressEncoding encoding) {\n            return GeneratePIC.getValue(options) || encoding.hasBase();\n        }\n        public final Value getInput() {\n            return input;\n        }\n        public final AllocatableValue getResult() {\n            return result;\n        }\n        protected final Register getResultRegister() {\n            return asRegister(result);\n        }\n        protected final Register getBaseRegister(CompilationResultBuilder crb) {\n            return hasBase(crb.getOptions(), encoding) ? asRegister(baseRegister) : Register.None;\n        }\n        protected final int getShift() {\n            return encoding.getShift();\n        }\n        protected final void move(LIRKind kind, CompilationResultBuilder crb, AMD64MacroAssembler masm) {\n            AMD64Move.move((AMD64Kind) kind.getPlatformKind(), crb, masm, result, input);\n        }\n    }\n    public static class CompressPointerOp extends PointerCompressionOp {\n        public static final LIRInstructionClass<CompressPointerOp> TYPE = LIRInstructionClass.create(CompressPointerOp.class);\n        public CompressPointerOp(AllocatableValue result, Value input, AllocatableValue baseRegister, CompressEncoding encoding, boolean nonNull, LIRKindTool lirKindTool) {\n            this(TYPE, result, input, baseRegister, encoding, nonNull, lirKindTool);\n        }\n        private CompressPointerOp(LIRInstructionClass<? extends PointerCompressionOp> type, AllocatableValue result, Value input,\n                        AllocatableValue baseRegister, CompressEncoding encoding, boolean nonNull, LIRKindTool lirKindTool) {\n            super(type, result, input, baseRegister, encoding, nonNull, lirKindTool);\n        }\n        @Override\n        public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {\n            move(lirKindTool.getObjectKind(), crb, masm);\n            final Register resReg = getResultRegister();\n            final Register baseReg = getBaseRegister(crb);\n            if (!baseReg.equals(Register.None)) {\n                if (!nonNull) {\n                    masm.testq(resReg, resReg);\n                    masm.cmovq(Equal, resReg, baseReg);\n                }\n                masm.subq(resReg, baseReg);\n            }\n            int shift = getShift();\n            if (shift != 0) {\n                masm.shrq(resReg, shift);\n            }\n        }\n    }\n    public static class UncompressPointerOp extends PointerCompressionOp {\n        public static final LIRInstructionClass<UncompressPointerOp> TYPE = LIRInstructionClass.create(UncompressPointerOp.class);\n        public UncompressPointerOp(AllocatableValue result, Value input, AllocatableValue baseRegister, CompressEncoding encoding, boolean nonNull, LIRKindTool lirKindTool) {\n            this(TYPE, result, input, baseRegister, encoding, nonNull, lirKindTool);\n        }\n        private UncompressPointerOp(LIRInstructionClass<? extends PointerCompressionOp> type, AllocatableValue result, Value input,\n                        AllocatableValue baseRegister, CompressEncoding encoding, boolean nonNull, LIRKindTool lirKindTool) {\n            super(type, result, input, baseRegister, encoding, nonNull, lirKindTool);\n        }\n        @Override\n        public void emitCode(CompilationResultBuilder crb, AMD64MacroAssembler masm) {\n            Register baseReg = getBaseRegister(crb);\n            if (nonNull && !baseReg.equals(Register.None) && getInput() instanceof RegisterValue) {\n                Register inputReg = ((RegisterValue) getInput()).getRegister();\n                if (!inputReg.equals(getResultRegister())) {\n                    masm.leaq(getResultRegister(), new AMD64Address(baseReg, inputReg, AMD64Address.Scale.fromShift(getShift())));\n                    return;\n                }\n            }\n            move(lirKindTool.getNarrowOopKind(), crb, masm);\n            emitUncompressCode(masm, getResultRegister(), getShift(), baseReg, nonNull);\n        }\n        public static void emitUncompressCode(AMD64MacroAssembler masm, Register resReg, int shift, Register baseReg, boolean nonNull) {\n            if (nonNull) {\n                if (!baseReg.equals(Register.None)) {\n                    if (shift != 0) {\n                        masm.leaq(resReg, new AMD64Address(baseReg, resReg, AMD64Address.Scale.fromShift(shift)));\n                    } else {\n                        masm.addq(resReg, baseReg);\n                    }\n                } else if (shift != 0) {\n                    masm.shlq(resReg, shift);\n                }\n            } else {\n                if (shift != 0) {\n                    masm.shlq(resReg, shift);\n                }\n                if (!baseReg.equals(Register.None)) {\n                    if (shift == 0) {\n                        // if encoding.shift != 0, the flags are already set by the shlq\n                        masm.testq(resReg, resReg);\n                    }\n                    Label done = new Label();\n                    masm.jccb(Equal, done);\n                    masm.addq(resReg, baseReg);\n                    masm.bind(done);\n                }\n            }\n        }\n    }\n    private abstract static class ZeroNullConversionOp extends AMD64LIRInstruction {\n        @Def({REG, HINT}) protected AllocatableValue result;\n        @Use({REG}) protected AllocatableValue input;\n<fim_suffix>        protected ZeroNullConversionOp(LIRInstructionClass<? extends ZeroNullConversionOp> type, AllocatableValue result, AllocatableValue input) {\n            super(type);\n            this.result = result;\n            this.input = input;\n        }<fim_middle>// function below has no smell\n"}