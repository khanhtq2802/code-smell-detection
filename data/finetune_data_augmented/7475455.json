{"text": "<fim_prefix>        throw GraalError.unimplemented();\n    }\n    @Override\n    public void emitCCall(long address, CallingConvention nativeCallingConvention, Value[] args) {\n        Value[] argLocations = new Value[args.length];\n        getResult().getFrameMapBuilder().callsMethod(nativeCallingConvention);\n        for (int i = 0; i < args.length; i++) {\n            Value arg = args[i];\n            AllocatableValue loc = nativeCallingConvention.getArgument(i);\n            emitMove(loc, arg);\n            argLocations[i] = loc;\n        }\n        Value ptr = emitLoadConstant(LIRKind.value(AArch64Kind.QWORD), JavaConstant.forLong(address));\n        append(new AArch64CCall(nativeCallingConvention.getReturn(), ptr, argLocations));\n    }\n    /**\n     * @param savedRegisters the registers saved by this operation which may be subject to pruning\n     * @param savedRegisterLocations the slots to which the registers are saved\n     * @param supportsRemove determines if registers can be pruned\n     */\n    protected AArch64SaveRegistersOp emitSaveRegisters(Register[] savedRegisters, AllocatableValue[] savedRegisterLocations, boolean supportsRemove) {\n        AArch64SaveRegistersOp save = new AArch64SaveRegistersOp(savedRegisters, savedRegisterLocations, supportsRemove);\n        append(save);\n        return save;\n    }\n    /**\n     * Allocate a stack slot for saving a register.\n     */\n    protected VirtualStackSlot allocateSaveRegisterLocation(Register register) {\n        PlatformKind kind = target().arch.getLargestStorableKind(register.getRegisterCategory());\n        if (kind.getVectorLength() > 1) {\n            // we don't use vector registers, so there is no need to save them\n            kind = AArch64Kind.QWORD;\n        }\n        return getResult().getFrameMapBuilder().allocateSpillSlot(LIRKind.value(kind));\n    }\n    /**\n     * Adds a node to the graph that saves all allocatable registers to the stack.\n     *\n     * @param supportsRemove determines if registers can be pruned\n     * @return the register save node\n     */\n    private AArch64SaveRegistersOp emitSaveAllRegisters(Register[] savedRegisters, boolean supportsRemove) {\n        AllocatableValue[] savedRegisterLocations = new AllocatableValue[savedRegisters.length];\n        for (int i = 0; i < savedRegisters.length; i++) {\n            savedRegisterLocations[i] = allocateSaveRegisterLocation(savedRegisters[i]);\n        }\n        return emitSaveRegisters(savedRegisters, savedRegisterLocations, supportsRemove);\n    }\n    protected void emitRestoreRegisters(AArch64SaveRegistersOp save) {\n        append(new AArch64RestoreRegistersOp(save.getSlots().clone(), save));\n    }\n    @Override\n    public VirtualStackSlot getLockSlot(int lockDepth) {\n        return getLockStack().makeLockSlot(lockDepth);\n    }\n    private HotSpotLockStack getLockStack() {\n        assert debugInfoBuilder != null && debugInfoBuilder.lockStack() != null;\n        return debugInfoBuilder.lockStack();\n    }\n    @Override\n    public void emitCompareBranch(PlatformKind cmpKind, Value x, Value y, Condition cond, boolean unorderedIsTrue, LabelRef trueDestination, LabelRef falseDestination,\n                    double trueDestinationProbability) {\n        Value localX = x;\n        Value localY = y;\n        if (localX instanceof HotSpotObjectConstant) {\n            localX = load(localX);\n        }\n        if (localY instanceof HotSpotObjectConstant) {\n            localY = load(localY);\n        }\n        super.emitCompareBranch(cmpKind, localX, localY, cond, unorderedIsTrue, trueDestination, falseDestination, trueDestinationProbability);\n    }\n    @Override\n    protected boolean emitCompare(PlatformKind cmpKind, Value a, Value b, Condition condition, boolean unorderedIsTrue) {\n        Value localA = a;\n        Value localB = b;\n        if (isConstantValue(a)) {\n            Constant c = asConstant(a);\n            if (HotSpotCompressedNullConstant.COMPRESSED_NULL.equals(c)) {\n                localA = AArch64.zr.asValue(LIRKind.value(AArch64Kind.DWORD));\n            } else if (c instanceof HotSpotObjectConstant) {\n                localA = load(localA);\n            }\n        }\n        if (isConstantValue(b)) {\n            Constant c = asConstant(b);\n            if (HotSpotCompressedNullConstant.COMPRESSED_NULL.equals(c)) {\n                localB = AArch64.zr.asValue(LIRKind.value(AArch64Kind.DWORD));\n            } else if (c instanceof HotSpotObjectConstant) {\n                localB = load(localB);\n            }\n        }\n        return super.emitCompare(cmpKind, localA, localB, condition, unorderedIsTrue);\n    }\n    @Override\n    public Value emitCompress(Value pointer, CompressEncoding encoding, boolean nonNull) {\n        LIRKind inputKind = pointer.getValueKind(LIRKind.class);\n        LIRKindTool lirKindTool = getLIRKindTool();\n        assert inputKind.getPlatformKind() == AArch64Kind.QWORD;\n        if (inputKind.isReference(0)) {\n            // oop\n            Variable result = newVariable(LIRKind.compressedReference(AArch64Kind.DWORD));\n            append(new AArch64HotSpotMove.CompressPointer(result, asAllocatable(pointer), getProviders().getRegisters().getHeapBaseRegister().asValue(), encoding, nonNull));\n            return result;\n        } else {\n            // metaspace pointer\n            Variable result = newVariable(LIRKind.value(AArch64Kind.DWORD));\n            AllocatableValue base = Value.ILLEGAL;\n            OptionValues options = getResult().getLIR().getOptions();\n            if (encoding.hasBase() || GeneratePIC.getValue(options)) {\n                if (GeneratePIC.getValue(options)) {\n                    Variable baseAddress = newVariable(lirKindTool.getWordKind());\n                    AArch64HotSpotMove.BaseMove move = new AArch64HotSpotMove.BaseMove(baseAddress, config);\n                    append(move);\n                    base = baseAddress;\n                } else {\n                    base = emitLoadConstant(LIRKind.value(AArch64Kind.QWORD), JavaConstant.forLong(encoding.getBase()));\n                }\n            }\n            append(new AArch64HotSpotMove.CompressPointer(result, asAllocatable(pointer), base, encoding, nonNull));\n            return result;\n        }\n    }\n    @Override\n    public Value emitUncompress(Value pointer, CompressEncoding encoding, boolean nonNull) {\n        LIRKind inputKind = pointer.getValueKind(LIRKind.class);\n        assert inputKind.getPlatformKind() == AArch64Kind.DWORD;\n        if (inputKind.isReference(0)) {\n            // oop\n            Variable result = newVariable(LIRKind.reference(AArch64Kind.QWORD));\n            append(new AArch64HotSpotMove.UncompressPointer(result, asAllocatable(pointer), getProviders().getRegisters().getHeapBaseRegister().asValue(), encoding, nonNull));\n            return result;\n        } else {\n            // metaspace pointer\n            Variable result = newVariable(LIRKind.value(AArch64Kind.QWORD));\n            AllocatableValue base = Value.ILLEGAL;\n            OptionValues options = getResult().getLIR().getOptions();\n            if (encoding.hasBase() || GeneratePIC.getValue(options)) {\n                if (GeneratePIC.getValue(options)) {\n                    Variable baseAddress = newVariable(LIRKind.value(AArch64Kind.QWORD));\n                    AArch64HotSpotMove.BaseMove move = new AArch64HotSpotMove.BaseMove(baseAddress, config);\n                    append(move);\n                    base = baseAddress;\n                } else {\n                    base = emitLoadConstant(LIRKind.value(AArch64Kind.QWORD), JavaConstant.forLong(encoding.getBase()));\n                }\n            }\n            append(new AArch64HotSpotMove.UncompressPointer(result, asAllocatable(pointer), base, encoding, nonNull));\n            return result;\n        }\n    }\n<fim_suffix>    @Override\n    public void emitNullCheck(Value address, LIRFrameState state) {\n        if (address.getValueKind().getPlatformKind() == AArch64Kind.DWORD) {\n            CompressEncoding encoding = config.getOopEncoding();\n            Value uncompressed = emitUncompress(address, encoding, false);\n            append(new AArch64Move.NullCheckOp(asAddressValue(uncompressed), state));\n        } else {\n            super.emitNullCheck(address, state);\n        }\n    }<fim_middle>// function below has no smell\n"}