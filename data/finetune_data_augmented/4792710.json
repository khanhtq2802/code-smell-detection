{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.shardingsphere.core.util;\n\nimport com.google.common.base.Function;\nimport com.google.common.base.Joiner;\nimport com.google.common.collect.Collections2;\nimport com.google.common.collect.Sets;\nimport groovy.lang.Closure;\nimport groovy.lang.GString;\nimport groovy.lang.GroovyShell;\nimport groovy.lang.Script;\nimport lombok.RequiredArgsConstructor;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * Inline expression parser.\n * \n * @author gaohongtao\n * @author zhangliang\n */\n<fim_suffix>@RequiredArgsConstructor\npublic final class InlineExpressionParser {\n    \n    private static final char SPLITTER = ',';\n    \n    private static final Map<String, Script> SCRIPTS = new HashMap<>();\n    \n    private static final GroovyShell SHELL = new GroovyShell();\n    \n    private final String inlineExpression;\n    \n    /**\n     * Replace all inline expression placeholders.\n     * \n     * @param inlineExpression inline expression with {@code $->}\n     * @return result inline expression with {@code $}\n     */\n    public static String handlePlaceHolder(final String inlineExpression) {\n        return inlineExpression.contains(\"$->{\") ? inlineExpression.replaceAll(\"\\\\$->\\\\{\", \"\\\\$\\\\{\") : inlineExpression;\n    }\n    \n    /**\n     * Split and evaluate inline expression.\n     *\n     * @return result list\n     */\n    public List<String> splitAndEvaluate() {\n        if (null == inlineExpression) {\n            return Collections.emptyList();\n        }\n        return flatten(evaluate(split()));\n    }\n    \n    /**\n     * Evaluate closure.\n     *\n     * @return closure\n     */\n    public Closure<?> evaluateClosure() {\n        return (Closure) evaluate(Joiner.on(\"\").join(\"{it -> \\\"\", inlineExpression, \"\\\"}\"));\n    }\n    \n    private List<Object> evaluate(final List<String> inlineExpressions) {\n        List<Object> result = new ArrayList<>(inlineExpressions.size());\n        for (String each : inlineExpressions) {\n            StringBuilder expression = new StringBuilder(handlePlaceHolder(each));\n            if (!each.startsWith(\"\\\"\")) {\n                expression.insert(0, \"\\\"\");\n            }\n            if (!each.endsWith(\"\\\"\")) {\n                expression.append(\"\\\"\");\n            }\n            result.add(evaluate(expression.toString()));\n        }\n        return result;\n    }\n    \n    private Object evaluate(final String expression) {\n        Script script;\n        if (SCRIPTS.containsKey(expression)) {\n            script = SCRIPTS.get(expression);\n        } else {\n            script = SHELL.parse(expression);\n            SCRIPTS.put(expression, script);\n        }\n        return script.run();\n    }\n    \n    private List<String> split() {\n        List<String> result = new ArrayList<>();\n        StringBuilder segment = new StringBuilder();\n        int bracketsDepth = 0;\n        for (int i = 0; i < inlineExpression.length(); i++) {\n            char each = inlineExpression.charAt(i);\n            switch (each) {\n                case SPLITTER:\n                    if (bracketsDepth > 0) {\n                        segment.append(each);\n                    } else {\n                        result.add(segment.toString().trim());\n                        segment.setLength(0);\n                    }\n                    break;\n                case '$':\n                    if ('{' == inlineExpression.charAt(i + 1)) {\n                        bracketsDepth++;\n                    }\n                    if (\"->{\".equals(inlineExpression.substring(i + 1, i + 4))) {\n                        bracketsDepth++;\n                    }\n                    segment.append(each);\n                    break;\n                case '}':\n                    if (bracketsDepth > 0) {\n                        bracketsDepth--;\n                    }\n                    segment.append(each);\n                    break;\n                default:\n                    segment.append(each);\n                    break;\n            }\n        }\n        if (segment.length() > 0) {\n            result.add(segment.toString().trim());\n        }\n        return result;\n    }\n    \n    private List<String> flatten(final List<Object> segments) {\n        List<String> result = new ArrayList<>();\n        for (Object each : segments) {\n            if (each instanceof GString) {\n                result.addAll(assemblyCartesianSegments((GString) each));\n            } else {\n                result.add(each.toString());\n            }\n        }\n        return result;\n    }\n    \n    private List<String> assemblyCartesianSegments(final GString segment) {\n        Set<List<String>> cartesianValues = getCartesianValues(segment);\n        List<String> result = new ArrayList<>(cartesianValues.size());\n        for (List<String> each : cartesianValues) {\n            result.add(assemblySegment(each, segment));\n        }\n        return result;\n    }\n    \n    @SuppressWarnings(\"unchecked\")\n    private Set<List<String>> getCartesianValues(final GString segment) {\n        List<Set<String>> result = new ArrayList<>(segment.getValues().length);\n        for (Object each : segment.getValues()) {\n            if (null == each) {\n                continue;\n            }\n            if (each instanceof Collection) {\n                result.add(Sets.newLinkedHashSet(Collections2.transform((Collection<Object>) each, new Function<Object, String>() {\n                    \n                    @Override\n                    public String apply(final Object input) {\n                        return input.toString();\n                    }\n                })));\n            } else {\n                result.add(Sets.newHashSet(each.toString()));\n            }\n        }\n        return Sets.cartesianProduct(result);\n    }\n    \n    private String assemblySegment(final List<String> cartesianValue, final GString segment) {\n        StringBuilder result = new StringBuilder();\n        for (int i = 0; i < segment.getStrings().length; i++) {\n            result.append(segment.getStrings()[i]);\n            if (i < cartesianValue.size()) {\n                result.append(cartesianValue.get(i));\n            }\n        }\n        return result.toString();\n    }\n}<fim_middle>// class below has no smell\n"}