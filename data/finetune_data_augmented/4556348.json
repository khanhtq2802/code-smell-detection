{"text": "<fim_prefix>\n<fim_suffix>final class DynamicKeyName extends Expression {\n    private final Expression keyExpression;\n    private final Expression target;\n    DynamicKeyName(Expression target, Expression keyExpression) {\n        this.target = target; \n        this.keyExpression = keyExpression;\n    }\n    @Override\n    TemplateModel _eval(Environment env) throws TemplateException {\n        TemplateModel targetModel = target.eval(env);\n        if (targetModel == null) {\n            if (env.isClassicCompatible()) {\n                return null;\n            } else {\n                throw InvalidReferenceException.getInstance(target, env);\n            }\n        }\n        TemplateModel keyModel = keyExpression.eval(env);\n        if (keyModel == null) {\n            if (env.isClassicCompatible()) {\n                keyModel = TemplateScalarModel.EMPTY_STRING;\n            } else {\n                keyExpression.assertNonNull(null, env);\n            }\n        }\n        if (keyModel instanceof TemplateNumberModel) {\n            int index = keyExpression.modelToNumber(keyModel, env).intValue();\n            return dealWithNumericalKey(targetModel, index, env);\n        }\n        if (keyModel instanceof TemplateScalarModel) {\n            String key = EvalUtil.modelToString((TemplateScalarModel) keyModel, keyExpression, env);\n            return dealWithStringKey(targetModel, key, env);\n        }\n        if (keyModel instanceof RangeModel) {\n            return dealWithRangeKey(targetModel, (RangeModel) keyModel, env);\n        }\n        throw new UnexpectedTypeException(keyExpression, keyModel, \"number, range, or string\",\n                new Class[] { TemplateNumberModel.class, TemplateScalarModel.class, Range.class }, env);\n    }\n    static private Class[] NUMERICAL_KEY_LHO_EXPECTED_TYPES;\n    static {\n        NUMERICAL_KEY_LHO_EXPECTED_TYPES = new Class[1 + NonStringException.STRING_COERCABLE_TYPES.length];\n        NUMERICAL_KEY_LHO_EXPECTED_TYPES[0] = TemplateSequenceModel.class;\n        for (int i = 0; i < NonStringException.STRING_COERCABLE_TYPES.length; i++) {\n            NUMERICAL_KEY_LHO_EXPECTED_TYPES[i + 1] = NonStringException.STRING_COERCABLE_TYPES[i];\n        }\n    }\n    private TemplateModel dealWithNumericalKey(TemplateModel targetModel, \n                                               int index, \n                                               Environment env)\n        throws TemplateException {\n        if (targetModel instanceof TemplateSequenceModel) {\n            TemplateSequenceModel tsm = (TemplateSequenceModel) targetModel;\n            int size;\n            try {\n                size = tsm.size();\n            } catch (Exception e) {\n                size = Integer.MAX_VALUE;\n            }\n            return index < size ? tsm.get(index) : null;\n        } \n        try {\n            String s = target.evalAndCoerceToPlainText(env);\n            try {\n                return new SimpleScalar(s.substring(index, index + 1));\n            } catch (IndexOutOfBoundsException e) {\n                if (index < 0) {\n                    throw new _MiscTemplateException(\"Negative index not allowed: \", Integer.valueOf(index));\n                }\n                if (index >= s.length()) {\n                    throw new _MiscTemplateException(\n                            \"String index out of range: The index was \", Integer.valueOf(index),\n                            \" (0-based), but the length of the string is only \", Integer.valueOf(s.length()) , \".\");\n                }\n                throw new RuntimeException(\"Can't explain exception\", e);\n            }\n        } catch (NonStringException e) {\n            throw new UnexpectedTypeException(\n                    target, targetModel,\n                    \"sequence or \" + NonStringException.STRING_COERCABLE_TYPES_DESC,\n                    NUMERICAL_KEY_LHO_EXPECTED_TYPES,\n                    (targetModel instanceof TemplateHashModel\n                            ? \"You had a numberical value inside the []. Currently that's only supported for \"\n                                    + \"sequences (lists) and strings. To get a Map item with a non-string key, \"\n                                    + \"use myMap?api.get(myKey).\"\n                            : null),\n                    env);\n        }\n    }\n    private TemplateModel dealWithStringKey(TemplateModel targetModel, String key, Environment env)\n        throws TemplateException {\n        if (targetModel instanceof TemplateHashModel) {\n            return((TemplateHashModel) targetModel).get(key);\n        }\n        throw new NonHashException(target, targetModel, env);\n    }\n    private TemplateModel dealWithRangeKey(TemplateModel targetModel, RangeModel range, Environment env)\n    throws UnexpectedTypeException, InvalidReferenceException, TemplateException {\n        final TemplateSequenceModel targetSeq;\n        final String targetStr;\n        if (targetModel instanceof TemplateSequenceModel) {\n            targetSeq = (TemplateSequenceModel) targetModel;\n            targetStr = null;\n        } else {\n            targetSeq = null;\n            try {\n                targetStr = target.evalAndCoerceToPlainText(env);\n            } catch (NonStringException e) {\n                throw new UnexpectedTypeException(\n                        target, target.eval(env),\n                        \"sequence or \" + NonStringException.STRING_COERCABLE_TYPES_DESC,\n                        NUMERICAL_KEY_LHO_EXPECTED_TYPES, env);\n            }\n        }\n        final int size = range.size();\n        final boolean rightUnbounded = range.isRightUnbounded();\n        final boolean rightAdaptive = range.isRightAdaptive();\n        // Right bounded empty ranges are accepted even if the begin index is out of bounds. That's because a such range\n        // produces an empty sequence, which thus doesn't contain any illegal indexes.\n        if (!rightUnbounded && size == 0) {\n            return emptyResult(targetSeq != null);\n        }\n        final int firstIdx = range.getBegining();\n        if (firstIdx < 0) {\n            throw new _MiscTemplateException(keyExpression,\n                    \"Negative range start index (\", Integer.valueOf(firstIdx),\n                    \") isn't allowed for a range used for slicing.\");\n        }\n        final int targetSize = targetStr != null ? targetStr.length() : targetSeq.size();\n        final int step = range.getStep();\n        // Right-adaptive increasing ranges can start 1 after the last element of the target, because they are like\n        // ranges with exclusive end index of at most targetSize. Thence a such range is just an empty list of indexes,\n        // and thus it isn't out-of-bounds.\n        // Right-adaptive decreasing ranges has exclusive end -1, so it can't help on a  to high firstIndex. \n        // Right-bounded ranges at this point aren't empty, so the right index surely can't reach targetSize. \n        if (rightAdaptive && step == 1 ? firstIdx > targetSize : firstIdx >= targetSize) {\n            throw new _MiscTemplateException(keyExpression,\n                    \"Range start index \", Integer.valueOf(firstIdx), \" is out of bounds, because the sliced \",\n                    (targetStr != null ? \"string\" : \"sequence\"),\n                    \" has only \", Integer.valueOf(targetSize), \" \", (targetStr != null ? \"character(s)\" : \"element(s)\"),\n                    \". \", \"(Note that indices are 0-based).\");\n        }\n        final int resultSize;\n        if (!rightUnbounded) {\n            final int lastIdx = firstIdx + (size - 1) * step;\n            if (lastIdx < 0) {\n                if (!rightAdaptive) {\n                    throw new _MiscTemplateException(keyExpression,\n                            \"Negative range end index (\", Integer.valueOf(lastIdx),\n                            \") isn't allowed for a range used for slicing.\");\n                } else {\n                    resultSize = firstIdx + 1;\n                }\n            } else if (lastIdx >= targetSize) {\n                if (!rightAdaptive) {\n                    throw new _MiscTemplateException(keyExpression,\n                            \"Range end index \", Integer.valueOf(lastIdx), \" is out of bounds, because the sliced \",\n                            (targetStr != null ? \"string\" : \"sequence\"),\n                            \" has only \", Integer.valueOf(targetSize), \" \", (targetStr != null ? \"character(s)\" : \"element(s)\"),\n                            \". (Note that indices are 0-based).\");\n                } else {\n                    resultSize = Math.abs(targetSize - firstIdx);\n                }\n            } else {\n                resultSize = size;\n            }\n        } else {\n            resultSize = targetSize - firstIdx;\n        }\n        if (resultSize == 0) {\n            return emptyResult(targetSeq != null);\n        }\n        if (targetSeq != null) {\n            ArrayList/*<TemplateModel>*/ list = new ArrayList(resultSize);\n            int srcIdx = firstIdx;\n            for (int i = 0; i < resultSize; i++) {\n                list.add(targetSeq.get(srcIdx));\n                srcIdx += step;\n            }\n            // List items are already wrapped, so the wrapper will be null:\n            return new SimpleSequence(list, null);\n        } else {\n            final int exclEndIdx;\n            if (step < 0 && resultSize > 1) {\n                if (!(range.isAffactedByStringSlicingBug() && resultSize == 2)) {\n                    throw new _MiscTemplateException(keyExpression,<fim_middle>// class below has no smell\n"}