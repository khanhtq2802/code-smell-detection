{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n * agreements. See the NOTICE file distributed with this work for additional information regarding\n * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n * copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\npackage org.apache.geode.internal;\nimport java.lang.ref.WeakReference;\n/**\n * An <code>ObjIdMap</code> maps GemFire object ids to an <code>Object</code>. This is an\n * optimization because using a {@link java.util.HashMap} for this purposed proved to be too slow\n * because of all of the {@link Integer}s that had to be created.\n */\npublic class ObjIdMap {\n  /** The contents of the map */\n  protected Entry[] table;\n  /** The total number of mappings in the map */\n  private int count;\n  /**\n   * Once the number of mappings in the map exceeds the threshold, the map is rehashed. The\n   * threshold is the (capacity * loadFactor). capacity is table.length\n   */\n  private int threshold;\n  /** The load factor of the map */\n  private float loadFactor;\n  public final Object rehashLock = new Object();\n  //////////////////// Constructors ////////////////////\n  /**\n   * Creates a new, empty map with the given initial capacity (number of buckets) and load factor.\n   */\n  public ObjIdMap(int initialCapacity, float loadFactor) {\n    if (initialCapacity < 0) {\n      throw new IllegalArgumentException(String.format(\"Illegal Initial Capacity: %s\",\n          Integer.valueOf(initialCapacity)));\n    }\n    if (loadFactor <= 0 || Float.isNaN(loadFactor)) {\n      throw new IllegalArgumentException(\n          String.format(\"Illegal Load factor: %s\", new Float(loadFactor)));\n    }\n    if (initialCapacity == 0) {\n      initialCapacity = 1;\n    }\n    this.loadFactor = loadFactor;\n    table = new Entry[initialCapacity];\n    threshold = (int) (initialCapacity * loadFactor);\n  }\n  /**\n   * Creates a new, empty map with the default initial capacity (11 buckets) and load factor (0.75).\n   */\n  public ObjIdMap() {\n    this(11, 0.75f);\n  }\n  /**\n   * Create a new map which will contain all the contents of the oldMap and then add the specified\n   * key and value.\n   */\n  public ObjIdMap(ObjIdMap oldMap, int addKey, Object addValue) {\n    this.loadFactor = oldMap.loadFactor;\n    // we do a +2 to make enough room for one more entry\n    // since we think the loadFactory is 0.5\n    rehash(oldMap.table, oldMap.count, oldMap.count + 2);\n    put(addKey, addValue);\n  }\n  /**\n   * Create a new map which will contain all the contents of the oldMap.\n   */\n  public ObjIdMap(ObjIdMap oldMap) {\n    this.table = new Entry[oldMap.table.length];\n    System.arraycopy(oldMap.table, 0, this.table, 0, this.table.length);\n    this.count = oldMap.count;\n    this.threshold = oldMap.threshold;\n    this.loadFactor = oldMap.loadFactor;\n  }\n  //////////////////// Instance Methods ////////////////////\n  /**\n   * Returns the number of mappings in this map\n   */\n  public int size() {\n    return this.count;\n  }\n  /**\n   * Returns <code>true</code> if this map contains a mapping for the given key.\n   *\n   * @throws IllegalArgumentException <code>key</code> is less than zero\n   */\n  public boolean containsKey(int key) {\n    Entry[] table = this.table;\n    int bucket = Math.abs(key) % table.length;\n    for (Entry e = table[bucket]; e != null; e = e.next) {\n      if (e.key == key) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Returns the object to which the given key is mapped. If no object is mapped to the given key,\n   * <code>null</code> is returned.\n   *\n   * @throws IllegalArgumentException <code>key</code> is less than zero\n   */\n  public Object get(int key) {\n    Entry[] table = this.table;\n    int bucket = Math.abs(key) % table.length;\n    for (Entry e = table[bucket]; e != null; e = e.next) {\n      if (e.key == key) {\n        return e.value;\n      }\n    }\n    return null;\n  }\n  /**\n   * Rehashes this map into a new map with a large number of buckets. It is called when the number\n   * of entries in the map exceeds the capacity and load factor.\n   */\n  private void rehash() {\n    rehash(this.table, this.count, this.count * 2 + 1);\n  }\n<fim_suffix>  private void rehash(Entry[] oldMap, int newCount, int newCapacity) {\n    int oldCapacity = oldMap.length;\n    Entry newMap[] = new Entry[newCapacity];\n    synchronized (rehashLock) {\n      for (int i = oldCapacity; i-- > 0;) {\n        for (Entry old = oldMap[i]; old != null;) {\n          Entry e = old;\n          old = old.next;\n          if (e.value != null && e.value instanceof WeakReference) {\n            WeakReference r = (WeakReference) e.value;\n            if (r.get() == null) {\n              // don't copy this one into the new table since its value was gc'd\n              newCount--;\n              continue;\n            }\n          }\n          int index = Math.abs(e.key) % newCapacity;\n          e.next = newMap[index];\n          newMap[index] = e;\n        }\n      }\n      threshold = (int) (newCapacity * loadFactor);\n      count = newCount;\n      table = newMap;\n    }\n  }\n  /**\n   * Creates a mapping between the given key (object id) and an object. Returns the previous value,\n   * or <code>null</code> if there was none.\n   *\n   * @throws IllegalArgumentException <code>key</code> is less than zero\n   */\n  public Object put(int key, Object value) {\n    // Is the key already in the table?\n    int bucket = Math.abs(key) % table.length;\n    for (Entry e = table[bucket]; e != null; e = e.next) {\n      if (e.key == key) {\n        Object old = e.value;\n        e.value = value;\n        return old;\n      }\n    }\n    // Adjust the table, if necessary\n    if (this.count >= this.threshold) {\n      rehash();\n      // table = this.table; assignment has no effect\n      bucket = Math.abs(key) % table.length;\n    }\n    Entry e = new Entry();\n    e.key = key;\n    e.value = value;\n    e.next = table[bucket];\n    table[bucket] = e;\n    count++;\n    return null;\n  }\n  /**\n   * Removes the mapping for the given key. Returns the object to which the key was mapped, or\n   * <code>null</code> otherwise.\n   */\n  public Object remove(int key) {\n    Entry[] table = this.table;\n    int bucket = Math.abs(key) % table.length;\n    for (Entry e = table[bucket], prev = null; e != null; prev = e, e = e.next) {\n      if (key == e.key) {\n        if (prev != null)\n          prev.next = e.next;\n        else\n          table[bucket] = e.next;\n        count--;\n        Object oldValue = e.value;\n        e.value = null;\n        return oldValue;\n      }\n    }\n    return null;\n  }\n  /**\n   * Returns all of the objects in the map\n   */\n  public Object[] values() {\n    Object[] values = new Object[this.size()];\n    Entry[] table = this.table;\n    int i = 0;\n    for (int bucket = 0; bucket < table.length; bucket++) {\n      for (Entry e = table[bucket]; e != null; e = e.next) {\n        values[i++] = e.value;\n      }\n    }\n    return values;\n  }\n  /**\n   * Returns an iterator over the {@link Entry}s of this map. Note that this iterator is <b>not</b>\n   * fail-fast. That is, it is the user's responsibility to ensure that the map does not change<fim_middle>// function below has no smell\n"}