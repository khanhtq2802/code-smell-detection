{"text": "<fim_prefix>/*******************************************************************************\n * Copyright (c) 2012-2016 Diamond Light Source Ltd.,\n *                         Kichwa Coders & iSencia Belgium NV.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *    DLS, Kichwa Coders - initial API and implementation and/or initial documentation\n *    Erwin De Ley - extraction from DAWN to ease reuse in other contexts\n *******************************************************************************/\n\npackage org.eclipse.triquetrum.scisoft.analysis.rpc;\n\n/**\n * Exceptions generated from Remote side are stored in this class. It allows some extra convenience on formatting exception messages. In particular if the\n * remote side supports text snippets for each line of stack trace they can be used.\n */\npublic class AnalysisRpcRemoteException extends AnalysisRpcException {\n  private static final long serialVersionUID = -7729269172566951025L;\n  private String[] texts;\n\n  public AnalysisRpcRemoteException() {\n    super();\n  }\n\n  public AnalysisRpcRemoteException(String s) {\n    super(s);\n  }\n\n  public AnalysisRpcRemoteException(String message, Throwable cause) {\n    super(message, cause);\n  }\n\n  public AnalysisRpcRemoteException(Throwable cause) {\n    super(cause);\n  }\n\n  /**\n   * Set a list of text fragments corresponding to the stack trace of the exception. The stack trace and the texts should have the same number of elements.\n   *\n   * @param texts\n   *          The texts. The array is copied.\n   */\n<fim_suffix>  public void setStackTraceTexts(String[] texts) {\n    if (texts == null) {\n      this.texts = null;\n    } else {\n      this.texts = texts.clone();\n    }\n  }\n\n  /**\n   * Retrieve a copy of the array of texts corresponding to the stack trace.\n   *\n   * @return array of texts or <code>null</code> if there are no texts associated or the associated texts are mismatched to the stack trace.\n   */\n  public String[] getStackTraceTexts() {\n    if (texts == null)\n      return null;\n    if (texts.length != getStackTrace().length)\n      return null;\n    return texts.clone();\n  }\n\n  /**\n   * Return the stack trace formatted in the standard Python way. The aim is to replicate what traceback.format_exception() does.\n   * <p>\n   * Use this method to generate prettier error messages when the remote is Python. If {@link #getStackTraceTexts()} returns the same number of elements as\n   * {@link #getStackTrace()} then the text snippets will be included in the trace.\n   * <p>\n   * The stack trace is formatted in Python convention which is newest frames last. In addition, this formatting matches the console line tracker that PyDev\n   * uses to make links back to Python files.\n   *\n   * @param limitStackTraceFileName\n   *          If non-<code>null</code> will be used to limit the stack trace to frames called after code in this function. The parameter is checked against the\n   *          end of the filename in the stack trace element {@link StackTraceElement#getFileName()}. If no frames or the last frame match then all the frames\n   *          are included.\n   * @return representation of error\n   */\n  public String getPythonFormattedStackTrace(String limitStackTraceFileName) {\n    StringBuilder msg = new StringBuilder(\"Traceback (most recent call last):\\n\");\n\n    // get and normalise stack traces\n    StackTraceElement[] trace = getStackTrace();\n    String[] texts = getStackTraceTexts();\n    if (texts == null || texts.length != trace.length) {\n      texts = null;\n    }\n\n    // search for starting point\n    int start = trace.length - 1;\n    if (limitStackTraceFileName != null) {\n      for (int i = 0; i < trace.length; i++) {\n        StackTraceElement elem = trace[i];\n        if (elem.getFileName().endsWith(limitStackTraceFileName)) {\n          start = i - 1;\n        }\n      }\n      if (start < 0) {\n        start = trace.length - 1;\n      }\n    }\n\n    // format individual lines\n    for (int i = start; i >= 0; i--) {\n      StackTraceElement elem = trace[i];\n      msg.append(String.format(\"  File \\\"%s\\\", line %d, in %s\\n\", elem.getFileName(), elem.getLineNumber(), elem.getMethodName()));\n      if (texts != null) {\n        String text = texts[i].trim();\n        if (text.length() > 0) {\n          msg.append(\"    \");\n          msg.append(text);\n          msg.append(\"\\n\");\n        }\n      }\n    }\n\n    // add in the exception type and message\n    msg.append(getMessage());\n    msg.append(\"\\n\");\n    return msg.toString();\n  }\n}<fim_middle>// function below has no smell\n"}