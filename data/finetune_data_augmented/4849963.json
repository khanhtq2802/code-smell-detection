{"text": "<fim_prefix>/****************************************************************\n * Licensed to the Apache Software Foundation (ASF) under one   *\n * or more contributor license agreements.  See the NOTICE file *\n * distributed with this work for additional information        *\n * regarding copyright ownership.  The ASF licenses this file   *\n * to you under the Apache License, Version 2.0 (the            *\n * \"License\"); you may not use this file except in compliance   *\n * with the License.  You may obtain a copy of the License at   *\n *                                                              *\n *   http://www.apache.org/licenses/LICENSE-2.0                 *\n *                                                              *\n * Unless required by applicable law or agreed to in writing,   *\n * software distributed under the License is distributed on an  *\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY       *\n * KIND, either express or implied.  See the License for the    *\n * specific language governing permissions and limitations      *\n * under the License.                                           *\n ****************************************************************/\n\npackage org.apache.james.mime4j.storage;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.security.GeneralSecurityException;\nimport java.security.NoSuchAlgorithmException;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.CipherInputStream;\nimport javax.crypto.CipherOutputStream;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.spec.SecretKeySpec;\n\n/**\n * A {@link StorageProvider} that transparently scrambles and unscrambles the\n * data stored by another <code>StorageProvider</code>.\n *\n * <p>\n * Example usage:\n *\n * <pre>\n * StorageProvider mistrusted = new TempFileStorageProvider();\n * StorageProvider enciphered = new CipherStorageProvider(mistrusted);\n * StorageProvider provider = new ThresholdStorageProvider(enciphered);\n * DefaultStorageProvider.setInstance(provider);\n * </pre>\n */\npublic class CipherStorageProvider extends AbstractStorageProvider {\n\n    private final StorageProvider backend;\n    private final String algorithm;\n    private final KeyGenerator keygen;\n\n    /**\n     * Creates a new <code>CipherStorageProvider</code> for the given back-end\n     * using the Blowfish cipher algorithm.\n     *\n     * @param backend\n     *            back-end storage strategy to encrypt.\n     */\n    public CipherStorageProvider(StorageProvider backend) {\n        this(backend, \"Blowfish\");\n    }\n\n    /**\n     * Creates a new <code>CipherStorageProvider</code> for the given back-end\n     * and cipher algorithm.\n     *\n     * @param backend\n     *            back-end storage strategy to encrypt.\n     * @param algorithm\n     *            the name of the symmetric block cipher algorithm such as\n     *            \"Blowfish\", \"AES\" or \"RC2\".\n     */\n    public CipherStorageProvider(StorageProvider backend, String algorithm) {\n        if (backend == null)\n            throw new IllegalArgumentException();\n\n        try {\n            this.backend = backend;\n            this.algorithm = algorithm;\n            this.keygen = KeyGenerator.getInstance(algorithm);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }\n\n    public StorageOutputStream createStorageOutputStream() throws IOException {\n        SecretKeySpec skeySpec = getSecretKeySpec();\n\n        return new CipherStorageOutputStream(backend\n                .createStorageOutputStream(), algorithm, skeySpec);\n    }\n\n    private SecretKeySpec getSecretKeySpec() {\n        byte[] raw = keygen.generateKey().getEncoded();\n        return new SecretKeySpec(raw, algorithm);\n    }\n\n<fim_suffix>    private static final class CipherStorageOutputStream extends\n            StorageOutputStream {\n        private final StorageOutputStream storageOut;\n        private final String algorithm;\n        private final SecretKeySpec skeySpec;\n        private final CipherOutputStream cipherOut;\n\n        public CipherStorageOutputStream(StorageOutputStream out,\n                String algorithm, SecretKeySpec skeySpec) throws IOException {\n            try {\n                this.storageOut = out;\n                this.algorithm = algorithm;\n                this.skeySpec = skeySpec;\n\n                Cipher cipher = Cipher.getInstance(algorithm);\n                cipher.init(Cipher.ENCRYPT_MODE, skeySpec);\n\n                this.cipherOut = new CipherOutputStream(out, cipher);\n            } catch (GeneralSecurityException e) {\n                throw (IOException) new IOException().initCause(e);\n            }\n        }\n\n        @Override\n        public void close() throws IOException {\n            super.close();\n            cipherOut.close();\n        }\n\n        @Override\n        protected void write0(byte[] buffer, int offset, int length)\n                throws IOException {\n            cipherOut.write(buffer, offset, length);\n        }\n\n        @Override\n        protected Storage toStorage0() throws IOException {\n            // cipherOut has already been closed because toStorage calls close\n            Storage encrypted = storageOut.toStorage();\n            return new CipherStorage(encrypted, algorithm, skeySpec);\n        }\n    }\n\n    private static final class CipherStorage implements Storage {\n        private Storage encrypted;\n        private final String algorithm;\n        private final SecretKeySpec skeySpec;\n\n        public CipherStorage(Storage encrypted, String algorithm,\n                SecretKeySpec skeySpec) {\n            this.encrypted = encrypted;\n            this.algorithm = algorithm;\n            this.skeySpec = skeySpec;\n        }\n\n        public void delete() {\n            if (encrypted != null) {\n                encrypted.delete();\n                encrypted = null;\n            }\n        }\n\n        public InputStream getInputStream() throws IOException {\n            if (encrypted == null)\n                throw new IllegalStateException(\"storage has been deleted\");\n\n            try {\n                Cipher cipher = Cipher.getInstance(algorithm);\n                cipher.init(Cipher.DECRYPT_MODE, skeySpec);\n\n                InputStream in = encrypted.getInputStream();\n                return new CipherInputStream(in, cipher);\n            } catch (GeneralSecurityException e) {\n                throw (IOException) new IOException().initCause(e);\n            }\n        }\n    }\n\n}<fim_middle>// class below has no smell\n"}