{"text": "<fim_prefix>/*\n * ******************************************************************************\n *  * Copyright (c) 2016, 2018 Contributors to the Eclipse Foundation\n *  *\n *  * See the NOTICE file(s) distributed with this work for additional\n *  * information regarding copyright ownership.\n *  *\n *  * This program and the accompanying materials are made available under the\n *  * terms of the Eclipse Public License 2.0 which is available at\n *  * http://www.eclipse.org/legal/epl-2.0\n *  *\n *  * SPDX-License-Identifier: EPL-2.0\n *  ******************************************************************************\n *\n */\n\npackage org.eclipse.hono.cli;\n\nimport javax.annotation.PostConstruct;\n\nimport io.vertx.core.AsyncResult;\nimport io.vertx.core.Future;\nimport io.vertx.core.WorkerExecutor;\nimport io.vertx.core.buffer.Buffer;\nimport org.eclipse.hono.client.CommandClient;\nimport org.eclipse.hono.client.HonoClient;\nimport org.eclipse.hono.util.BufferResult;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.annotation.Profile;\nimport org.springframework.stereotype.Component;\n\nimport java.util.Optional;\nimport java.util.Scanner;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * A command line client for sending <em>commands</em> to devices connected to Hono.\n * <p>\n * The client connects to Hono and reads commands from System.in.\n */\n<fim_suffix>@Component\n@Profile(\"command\")\npublic class Commander extends AbstractClient {\n\n    private final Scanner scanner = new Scanner(System.in);\n    @Value(value = \"${command.timeoutInSeconds}\")\n    private int requestTimeoutInSecs;\n    private WorkerExecutor workerExecutor;\n\n    /**\n     * Starts this component.\n     *\n     */\n    @PostConstruct\n    void start() {\n        workerExecutor = vertx.createSharedWorkerExecutor(\"user-input-pool\", 3, TimeUnit.HOURS.toNanos(1));\n        startCommandClient(client.connect(x -> onDisconnect()));\n    }\n\n    private void startCommandClient(final Future<HonoClient> clientFuture) {\n        clientFuture\n                .setHandler(this::handleClientConnectionStatus)\n                .compose(x -> getCommandFromUser())\n                .compose(this::processCommand)\n                .setHandler(x -> startCommandClient(clientFuture));\n    }\n\n    private Future<Void> processCommand(final Command command) {\n\n        LOG.info(\"Command sent to device... [request will timeout in {} seconds]\", requestTimeoutInSecs);\n\n        final Future<CommandClient> commandClient = client.getOrCreateCommandClient(tenantId, deviceId);\n        return commandClient\n                .map(this::setRequestTimeOut)\n                .compose(c -> {\n                    if (command.isOneWay()) {\n                        return c\n                                .sendOneWayCommand(command.getName(), command.getContentType(), Buffer.buffer(command.getPayload()), null)\n                                .map(ok -> c);\n                    } else {\n                        return c\n                                .sendCommand(command.getName(), command.getContentType(), Buffer.buffer(command.getPayload()), null)\n                                .map(this::printResponse)\n                                .map(ok -> c);\n                    }\n                })\n                .map(this::closeCommandClient)\n                .otherwise(error -> {\n                    LOG.error(\"Error sending command: {}\", error.getMessage());\n                    if (commandClient.succeeded()) {\n                        return closeCommandClient(commandClient.result());\n                    } else {\n                        return null;\n                    }\n                });\n    }\n\n    private CommandClient setRequestTimeOut(final CommandClient commandClient) {\n        commandClient.setRequestTimeout(TimeUnit.SECONDS.toMillis(requestTimeoutInSecs));\n        return commandClient;\n    }\n\n    private Void closeCommandClient(final CommandClient commandClient) {\n        LOG.trace(\"Close command client to device [{}:{}]\", tenantId, deviceId);\n        commandClient.close(closeHandler -> {\n        });\n        return null;\n    }\n\n    private Void printResponse(final BufferResult result) {\n        LOG.info(\"Received Command response : {}\",\n                Optional.ofNullable(result.getPayload()).orElse(Buffer.buffer()).toString());\n        return null;\n    }\n\n    private Future<Command> getCommandFromUser() {\n        final Future<Command> commandFuture = Future.future();\n        workerExecutor.executeBlocking(userInputFuture -> {\n            System.out.println();\n            System.out.println();\n            System.out.printf(\">>>>>>>>> Enter name of command for device [%s:%s] (prefix with 'ow:' to send one-way command):\",\n                    tenantId, deviceId);\n            System.out.println();\n            final String honoCmd = scanner.nextLine();\n            System.out.println(\">>>>>>>>> Enter command payload:\");\n            final String honoPayload = scanner.nextLine();\n            System.out.println(\">>>>>>>>> Enter content type:\");\n            final String honoContentType = scanner.nextLine();\n            System.out.println();\n            userInputFuture.complete(new Command(honoCmd, honoPayload, honoContentType));\n        }, commandFuture);\n        return commandFuture;\n    }\n\n    private void onDisconnect() {\n        LOG.info(\"Connecting client...\");\n        vertx.setTimer(connectionRetryInterval, reconnect -> {\n            LOG.info(\"attempting to re-connect to Hono ...\");\n            client.connect(con -> onDisconnect());\n        });\n    }\n\n    private void handleClientConnectionStatus(final AsyncResult<HonoClient> result) {\n        if (result.failed()) {\n            workerExecutor.close();\n            vertx.close();\n            LOG.error(\"Error: {}\", result.cause().getMessage());\n            throw new RuntimeException(\"Error connecting hono client\", result.cause());\n        }\n    }\n\n    /**\n     * Command class that encapsulates hono command and payload.\n     */\n    private static class Command {\n\n        private final String name;\n        private final String payload;\n        private final String contentType;\n        private final boolean oneWay;\n\n        Command(final String command, final String payload, final String contentType) {\n\n            oneWay = command.startsWith(\"ow:\");\n            if (oneWay) {\n                name = command.substring(3);\n            } else {\n                name = command;\n            }\n            this.payload = payload;\n            this.contentType = contentType;\n        }\n\n        private boolean isOneWay() {\n            return oneWay;\n        }\n\n        private String getName() {\n            return name;\n        }\n\n        private String getPayload() {\n            return payload;\n        }\n\n        private String getContentType() {\n            return contentType;\n        }\n    }\n}<fim_middle>// class below has no smell\n"}