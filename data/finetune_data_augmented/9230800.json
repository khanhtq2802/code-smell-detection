{"text": "<fim_prefix> *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage jdk.jshell.execution;\nimport java.io.IOException;\nimport java.io.ObjectInput;\nimport java.io.ObjectOutput;\nimport jdk.jshell.spi.ExecutionControl;\nimport jdk.jshell.spi.ExecutionControl.ClassBytecodes;\nimport jdk.jshell.spi.ExecutionControl.ClassInstallException;\nimport jdk.jshell.spi.ExecutionControl.EngineTerminationException;\nimport jdk.jshell.spi.ExecutionControl.InternalException;\nimport jdk.jshell.spi.ExecutionControl.NotImplementedException;\nimport jdk.jshell.spi.ExecutionControl.ResolutionException;\nimport jdk.jshell.spi.ExecutionControl.StoppedException;\nimport jdk.jshell.spi.ExecutionControl.UserException;\nimport static jdk.jshell.execution.RemoteCodes.*;\n/**\n * Forwards commands from the input to the specified {@link ExecutionControl}\n * instance, then responses back on the output.\n */\nclass ExecutionControlForwarder {\n    /**\n     * Represent null in a streamed UTF string. Vanishingly improbable string to\n     * occur in a user string.\n     */\n    static final String NULL_MARKER = \"\\u0002*\\u03C0*NULL*\\u03C0*\\u0003\";\n    /**\n     * Maximum number of characters for writeUTF().  Byte maximum is 65535, at\n     * maximum three bytes per character that is 65535 / 3 == 21845.  Minus one\n     * for safety.\n     */\n    private static final int MAX_UTF_CHARS = 21844;\n    private final ExecutionControl ec;\n    private final ObjectInput in;\n    private final ObjectOutput out;\n    ExecutionControlForwarder(ExecutionControl ec, ObjectInput in, ObjectOutput out) {\n        this.ec = ec;\n        this.in = in;\n        this.out = out;\n    }\n    private boolean writeSuccess() throws IOException {\n        writeStatus(RESULT_SUCCESS);\n        flush();\n        return true;\n    }\n    private boolean writeSuccessAndResult(String result) throws IOException {\n        writeStatus(RESULT_SUCCESS);\n        writeUTF(result);\n        flush();\n        return true;\n    }\n    private boolean writeSuccessAndResult(Object result) throws IOException {\n        writeStatus(RESULT_SUCCESS);\n        writeObject(result);\n        flush();\n        return true;\n    }\n    private void writeStatus(int status) throws IOException {\n        out.writeInt(status);\n    }\n    private void writeObject(Object o) throws IOException {\n        out.writeObject(o);\n    }\n    private void writeInt(int i) throws IOException {\n        out.writeInt(i);\n    }\n    private void writeNullOrUTF(String s) throws IOException {\n        writeUTF(s == null ? NULL_MARKER : s);\n    }\n    private void writeUTF(String s) throws IOException {\n        if (s == null) {\n            s = \"\";\n        } else if (s.length() > MAX_UTF_CHARS) {\n            // Truncate extremely long strings to prevent writeUTF from crashing the VM\n            s = s.substring(0, MAX_UTF_CHARS);\n        }\n        out.writeUTF(s);\n    }\n    private void flush() throws IOException {\n        out.flush();\n    }\n    private boolean processCommand() throws IOException {\n        try {\n            int prefix = in.readInt();\n            if (prefix != COMMAND_PREFIX) {\n                throw new EngineTerminationException(\"Invalid command prefix: \" + prefix);\n            }\n            String cmd = in.readUTF();\n            switch (cmd) {\n                case CMD_LOAD: {\n                    // Load a generated class file over the wire\n                    ClassBytecodes[] cbcs = (ClassBytecodes[]) in.readObject();\n                    ec.load(cbcs);\n                    return writeSuccess();\n                }\n                case CMD_REDEFINE: {\n                    // Load a generated class file over the wire\n                    ClassBytecodes[] cbcs = (ClassBytecodes[]) in.readObject();\n                    ec.redefine(cbcs);\n                    return writeSuccess();\n                }\n                case CMD_INVOKE: {\n                    // Invoke executable entry point in loaded code\n                    String className = in.readUTF();\n                    String methodName = in.readUTF();\n                    String res = ec.invoke(className, methodName);\n                    return writeSuccessAndResult(res);\n                }\n                case CMD_VAR_VALUE: {\n                    // Retrieve a variable value\n                    String className = in.readUTF();\n                    String varName = in.readUTF();\n                    String res = ec.varValue(className, varName);\n                    return writeSuccessAndResult(res);\n                }\n                case CMD_ADD_CLASSPATH: {\n                    // Append to the claspath\n                    String cp = in.readUTF();\n                    ec.addToClasspath(cp);\n                    return writeSuccess();\n                }\n                case CMD_STOP: {\n                    // Stop the current execution\n                    try {\n                        ec.stop();\n                    } catch (Throwable ex) {\n                        // JShell-core not waiting for a result, ignore\n                    }\n                    return true;\n                }\n                case CMD_CLOSE: {\n                    // Terminate this process\n                    try {\n                        ec.close();\n                    } catch (Throwable ex) {\n                        // JShell-core not waiting for a result, ignore\n                    }\n                    return true;\n                }\n                default: {\n                    Object arg = in.readObject();\n                    Object res = ec.extensionCommand(cmd, arg);\n                    return writeSuccessAndResult(res);\n                }\n            }\n        } catch (IOException ex) {\n            // handled by the outer level\n            throw ex;\n        } catch (EngineTerminationException ex) {\n            writeStatus(RESULT_TERMINATED);\n            writeUTF(ex.getMessage());\n            flush();\n            return false;\n        } catch (NotImplementedException ex) {\n            writeStatus(RESULT_NOT_IMPLEMENTED);\n            writeUTF(ex.getMessage());\n            flush();\n            return true;\n        } catch (InternalException ex) {\n            writeInternalException(ex);\n            flush();\n            return true;\n        } catch (ClassInstallException ex) {\n            writeStatus(RESULT_CLASS_INSTALL_EXCEPTION);\n            writeUTF(ex.getMessage());\n            writeObject(ex.installed());\n            flush();\n            return true;\n        } catch (UserException ex) {\n            writeStatus(RESULT_USER_EXCEPTION_CHAINED);\n            for (Throwable e = ex; e != null; ) {\n                if (e instanceof UserException) {\n                    writeUserException((UserException) e);\n                    e = e.getCause();\n                } else if (e instanceof ResolutionException) {\n                    writeResolutionException((ResolutionException) e);\n                    e = null;\n                } else {\n                    writeInternalException(e);\n                    e = null;\n                }\n            }\n            writeStatus(RESULT_SUCCESS);\n            flush();\n            return true;\n        } catch (ResolutionException ex) {\n            writeResolutionException(ex);\n            flush();\n            return true;\n        } catch (StoppedException ex) {\n            writeStatus(RESULT_STOPPED);\n            flush();\n            return true;\n        } catch (Throwable ex) {\n            // Unexpected exception, have something in the message\n            writeStatus(RESULT_TERMINATED);\n            String msg = ex.getMessage();\n            writeUTF(msg == null? ex.toString() : msg);\n            flush();\n            return false;\n        }\n    }\n    void writeInternalException(Throwable ex) throws IOException {\n        writeStatus(RESULT_INTERNAL_PROBLEM);\n        writeUTF(ex.getMessage());\n    }\n    void writeUserException(UserException ex) throws IOException {\n        writeStatus(RESULT_USER_EXCEPTION);\n        writeNullOrUTF(ex.getMessage());\n        writeUTF(ex.causeExceptionClass());\n        writeObject(ex.getStackTrace());\n    }\n    void writeResolutionException(ResolutionException ex) throws IOException {\n        writeStatus(RESULT_CORRALLED);\n        writeInt(ex.id());\n        writeObject(ex.getStackTrace());\n    }\n<fim_suffix>    void commandLoop() {\n        try {\n            while (processCommand()) {\n                // condition is loop action\n            }\n        } catch (IOException ex) {\n            // drop out of loop\n        }\n    }<fim_middle>// function below has no smell\n"}