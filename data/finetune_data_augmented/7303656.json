{"text": "<fim_prefix>// Copyright (c) Microsoft. All rights reserved.\n// Licensed under the MIT license. See License.txt in the repository root.\n\npackage com.microsoft.tfs.core.clients.versioncontrol;\n\nimport com.microsoft.tfs.core.clients.versioncontrol.soapextensions.PropertyValue;\nimport com.microsoft.tfs.core.util.FileEncoding;\nimport com.microsoft.tfs.util.Check;\nimport com.microsoft.tfs.util.TypesafeEnum;\n\n/**\n * Contains options that affect conflict resolution.\n *\n * @since TEE-SDK-10.1\n * @threadsafety thread-compatible\n */\n<fim_suffix>public final class ResolutionOptions {\n    public static class EncodingStrategy extends TypesafeEnum {\n        private EncodingStrategy(final int value) {\n            super(value);\n        }\n\n        /**\n         * When this strategy is chosen, the file's existing encoding is used.\n         */\n        public final static EncodingStrategy DEFAULT = new EncodingStrategy(0);\n        /**\n         * When this strategy is chosen, the all files involved in the merge\n         * will have their encodings treated like the given encoding. No file\n         * conversion is done.\n         */\n        public final static EncodingStrategy OVERRIDE_EXPLICIT = new EncodingStrategy(1);\n        /**\n         * When this strategy is chosen, the all files involved in the merge\n         * will be converted into the explicitly named encoding.\n         */\n        public final static EncodingStrategy CONVERT_EXPLICIT = new EncodingStrategy(2);\n    }\n\n    /**\n     * How to go about resolving encoding conflicts.\n     */\n    private EncodingStrategy encodingStrategy = EncodingStrategy.DEFAULT;\n\n    /**\n     * Only used when _encodingStrategy is not default.\n     */\n    private FileEncoding explicitEncoding = FileEncoding.AUTOMATICALLY_DETECT;\n\n    private boolean useInternalEngine = true;\n\n    private FileEncoding acceptMergeEncoding = null;\n\n    private String newPath = null;\n\n    private boolean acceptMergeWithConflicts = false;\n\n    private PropertyValue[] acceptMergeProperties;\n\n    /**\n     * Creates a {@link ResolutionOptions} with the default options set.\n     */\n    public ResolutionOptions() {\n        super();\n    }\n\n    /**\n     * Sets the strategy for resolving encoding conflicts. If the strategy is\n     * EncodingStrategy.DEFAULT, explicitEncoding must be null. If the strategy\n     * is some other value, explicitEncoding must be non-null, and represents\n     * the overriding encoding, or conversion encoding, or whatever that\n     * strategy's comment says it represents.\n     *\n     * @param strategy\n     *        the strategy to take for resolving encoding conflicts.\n     * @param explicitEncoding\n     *        the encoding to use for resolving conflicts (null if the strategy\n     *        is EncodingStrategy.DEFAULT).\n     */\n    public void setEncodingStrategy(final EncodingStrategy strategy, final FileEncoding explicitEncoding) {\n        Check.isTrue(\n            (strategy == EncodingStrategy.DEFAULT && explicitEncoding == null || explicitEncoding != null),\n            \"explicitEncoding must be null if strategy is EncodingStrategy.DEFAULT\"); //$NON-NLS-1$\n\n        encodingStrategy = strategy;\n        this.explicitEncoding = explicitEncoding;\n    }\n\n    /**\n     * Gets the encoding resolution strategy. If the returned strategy is not\n     * EncodingStrategy.DEFAULT, call getExplicitEncoding() to get the encoding\n     * to be used for the strategy.\n     *\n     * @return the encoding resolution strategy.\n     */\n    public EncodingStrategy getEncodingStrategy() {\n        return encodingStrategy;\n    }\n\n    /**\n     * Gets the explicit encoding set previously as part of setting an encoding\n     * strategy.\n     *\n     * @return the encoding to use as part of the encoding resolution strategy,\n     *         null if not set or if the strategy was EncodingStrategy.DEFAULT.\n     */\n    public FileEncoding getExplicitEncoding() {\n        return explicitEncoding;\n    }\n\n    public void setUseInternalEngine(final boolean useInternalEngine) {\n        this.useInternalEngine = useInternalEngine;\n    }\n\n    public boolean useInternalEngine() {\n        return useInternalEngine;\n    }\n\n    /**\n     * When a conflict is to be resolved with the AcceptMerge resolution and\n     * there is a conflicting pending encoding change, the given encoding will\n     * be used (no file conversion is done). If the given encoding is null, the\n     * conflict will not be resolved.\n     *\n     * @param encoding\n     *        the encoding to use when an automatic merge is desired and there\n     *        is a conflicting pending change.\n     */\n    public void setAcceptMergeEncoding(final FileEncoding encoding) {\n        acceptMergeEncoding = encoding;\n    }\n\n    /**\n     * Gets the encoding to use when an AcceptMerge resolution is desired but\n     * there is a conflicting pending encoding change. If null is returned, the\n     * encoding should be unchanged.\n     *\n     * @return the encoding to use to resolve the case where AcceptMerge must\n     *         operate on a file with a conflicting pending encoding change,\n     *         null if the encoding should be unchanged.\n     */\n    public FileEncoding getAcceptMergeEncoding() {\n        return acceptMergeEncoding;\n    }\n\n    /**\n     * When a conflict is to be resolved with the AcceptMerge resolution and\n     * there is a conflicting pending property change, this property contains\n     * the desired properties. If this property is left as null, the conflict\n     * will not be resolved.\n     */\n    public PropertyValue[] getAcceptMergeProperties() {\n        return acceptMergeProperties;\n    }\n\n    public void setAcceptMergeProperties(final PropertyValue[] acceptMergeProperties) {\n        this.acceptMergeProperties = acceptMergeProperties;\n    }\n\n    /**\n     * Sets the new path for a conflicted item or the item in its way when it\n     * needs needs to move to a new location. This may happen in cases like\n     * these:\n     *\n     * Merge conflict with AcceptMerge chosen, and there's a conflicting pending\n     * rename: set the desired name. If null, the conflict will not be resolved.\n     *\n     * Namespace conflict with AcceptTheirs: set the path that would describe\n     * their item.\n     *\n     * Namespace conflict with AcceptYours: set to the path of the local item\n     * that was in the way of the server item.\n     *\n     * @param newPath\n     *        the path to use for this conflict resolution, null to defer the\n     *        resolution in the cases documented above.\n     */\n    public void setNewPath(final String newPath) {\n        this.newPath = newPath;\n    }\n\n    /**\n     * Gets the new path to use for this resolution. See setNewPath() comments\n     * for details.\n     *\n     * @return the new path, null if not set.\n     */\n    public String getNewPath() {\n        return newPath;\n    }\n\n    /**\n     * @return true if a merge should be resolved when conflicts remain in the\n     *         file, false if the merge should not be resolved when conflicts\n     *         remain\n     */\n    public boolean isAcceptMergeWithConflicts() {\n        return acceptMergeWithConflicts;\n    }\n\n    /**\n     * Sets the option to accept (resolve a conflict) when the merge resulted in\n     * conflicts.\n     *\n     * @param mergeWithConflicts\n     *        true if a merge should be resolved when conflicts remain in the\n     *        file, false if the merge should not be resolved when conflicts\n     *        remain\n     */\n    public void setAcceptMergeWithConflicts(final boolean mergeWithConflicts) {\n        acceptMergeWithConflicts = mergeWithConflicts;\n    }\n}<fim_middle>// class below is data class\n"}