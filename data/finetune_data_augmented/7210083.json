{"text": "<fim_prefix>// Copyright 2017, 2019, Oracle Corporation and/or its affiliates.  All rights reserved.\n// Licensed under the Universal Permissive License v 1.0 as shown at\n// http://oss.oracle.com/licenses/upl.\npackage oracle.kubernetes.operator.helpers;\nimport static java.net.HttpURLConnection.HTTP_CONFLICT;\nimport com.squareup.okhttp.Call;\nimport io.kubernetes.client.ApiCallback;\nimport io.kubernetes.client.ApiClient;\nimport io.kubernetes.client.ApiException;\nimport io.kubernetes.client.apis.ApiextensionsV1beta1Api;\nimport io.kubernetes.client.apis.AuthenticationV1Api;\nimport io.kubernetes.client.apis.AuthorizationV1Api;\nimport io.kubernetes.client.apis.BatchV1Api;\nimport io.kubernetes.client.apis.CoreV1Api;\nimport io.kubernetes.client.apis.VersionApi;\nimport io.kubernetes.client.models.V1ConfigMap;\nimport io.kubernetes.client.models.V1DeleteOptions;\nimport io.kubernetes.client.models.V1EventList;\nimport io.kubernetes.client.models.V1Job;\nimport io.kubernetes.client.models.V1Namespace;\nimport io.kubernetes.client.models.V1PersistentVolume;\nimport io.kubernetes.client.models.V1PersistentVolumeClaim;\nimport io.kubernetes.client.models.V1PersistentVolumeClaimList;\nimport io.kubernetes.client.models.V1PersistentVolumeList;\nimport io.kubernetes.client.models.V1Pod;\nimport io.kubernetes.client.models.V1PodList;\nimport io.kubernetes.client.models.V1Secret;\nimport io.kubernetes.client.models.V1SelfSubjectAccessReview;\nimport io.kubernetes.client.models.V1SelfSubjectRulesReview;\nimport io.kubernetes.client.models.V1Service;\nimport io.kubernetes.client.models.V1ServiceList;\nimport io.kubernetes.client.models.V1Status;\nimport io.kubernetes.client.models.V1SubjectAccessReview;\nimport io.kubernetes.client.models.V1TokenReview;\nimport io.kubernetes.client.models.V1beta1CustomResourceDefinition;\nimport io.kubernetes.client.models.VersionInfo;\nimport java.util.Optional;\nimport java.util.function.Consumer;\nimport javax.json.JsonPatch;\nimport oracle.kubernetes.operator.TuningParameters;\nimport oracle.kubernetes.operator.TuningParameters.CallBuilderTuning;\nimport oracle.kubernetes.operator.calls.AsyncRequestStep;\nimport oracle.kubernetes.operator.calls.CallFactory;\nimport oracle.kubernetes.operator.calls.CallWrapper;\nimport oracle.kubernetes.operator.calls.CancellableCall;\nimport oracle.kubernetes.operator.calls.RequestParams;\nimport oracle.kubernetes.operator.calls.SynchronousCallDispatcher;\nimport oracle.kubernetes.operator.calls.SynchronousCallFactory;\nimport oracle.kubernetes.operator.logging.LoggingFacade;\nimport oracle.kubernetes.operator.logging.LoggingFactory;\nimport oracle.kubernetes.operator.logging.MessageKeys;\nimport oracle.kubernetes.operator.utils.PatchUtils;\nimport oracle.kubernetes.operator.work.Step;\nimport oracle.kubernetes.weblogic.domain.v2.Domain;\nimport oracle.kubernetes.weblogic.domain.v2.DomainList;\nimport oracle.kubernetes.weblogic.domain.v2.api.WeblogicApi;\n/** Simplifies synchronous and asynchronous call patterns to the Kubernetes API Server. */\n@SuppressWarnings({\"WeakerAccess\", \"UnusedReturnValue\"})\npublic class CallBuilder {\n  /** HTTP status code for \"Not Found\". */\n  public static final int NOT_FOUND = 404;\n  private static final LoggingFacade LOGGER = LoggingFactory.getLogger(\"Operator\", \"Operator\");\n  private static SynchronousCallDispatcher DISPATCHER =\n      new SynchronousCallDispatcher() {\n        @Override\n        public <T> T execute(\n            SynchronousCallFactory<T> factory, RequestParams params, Pool<ApiClient> pool)\n            throws ApiException {\n          ApiClient client = pool.take();\n          try {\n            return factory.execute(client, params);\n          } finally {\n            pool.recycle(client);\n          }\n        }\n      };\n  private String pretty = \"false\";\n  private String fieldSelector;\n  private Boolean includeUninitialized = Boolean.FALSE;\n  private String labelSelector;\n  private Integer limit = 500;\n  private String resourceVersion = \"\";\n  private Integer timeoutSeconds = 5;\n  private Integer maxRetryCount = 10;\n  private Boolean watch = Boolean.FALSE;\n  private Boolean exact = Boolean.FALSE;\n  private Boolean export = Boolean.FALSE;\n  private Integer gracePeriodSeconds = null;\n  private Boolean orphanDependents = null;\n  private String propagationPolicy = null;\n  private final ClientPool helper;\n  public CallBuilder() {\n    this(getCallBuilderTuning(), ClientPool.getInstance());\n  }\n  private static CallBuilderTuning getCallBuilderTuning() {\n    return Optional.ofNullable(TuningParameters.getInstance())\n        .map(TuningParameters::getCallBuilderTuning)\n        .orElse(null);\n  }\n  private CallBuilder(CallBuilderTuning tuning, ClientPool helper) {\n    if (tuning != null) {\n      tuning(tuning.callRequestLimit, tuning.callTimeoutSeconds, tuning.callMaxRetryCount);\n    }\n    this.helper = helper;\n  }\n  public CallBuilder withLabelSelectors(String... selectors) {\n    this.labelSelector = String.join(\",\", selectors);\n    return this;\n  }\n  public CallBuilder withFieldSelector(String fieldSelector) {\n    this.fieldSelector = fieldSelector;\n    return this;\n  }\n  private void tuning(int limit, int timeoutSeconds, int maxRetryCount) {\n    this.limit = limit;\n    this.timeoutSeconds = timeoutSeconds;\n    this.maxRetryCount = maxRetryCount;\n  }\n  /**\n   * Creates instance that will acquire clients as needed from the {@link ClientPool} instance.\n   *\n   * @param tuning Tuning parameters\n   * @return Call builder\n   */\n  static CallBuilder create(CallBuilderTuning tuning) {\n    return new CallBuilder(tuning, ClientPool.getInstance());\n  }\n  /**\n   * Consumer for lambda-based builder pattern.\n   *\n   * @param builderFunction Builder lambda function\n   * @return this CallBuilder\n   */\n  public CallBuilder with(Consumer<CallBuilder> builderFunction) {\n    builderFunction.accept(this);\n    return this;\n  }\n  /* Version */\n  /**\n   * Read Kubernetes version code.\n   *\n   * @return Version code\n   * @throws ApiException API Exception\n   */\n  public VersionInfo readVersionCode() throws ApiException {\n    RequestParams requestParams = new RequestParams(\"getVersion\", null, null, null);\n    return executeSynchronousCall(\n        requestParams, ((client, params) -> new VersionApi(client).getCode()));\n  }\n  /**\n   * Class extended by callers to {@link\n   * #executeSynchronousCallWithConflictRetry(RequestParamsBuilder, SynchronousCallFactory,\n   * ConflictRetry)} for building the RequestParams to be passed to {@link\n   * #executeSynchronousCall(RequestParams, SynchronousCallFactory)}.\n   *\n   * @param <T> Type of kubernetes object to be passed to the API\n   */\n<fim_suffix>  abstract static class RequestParamsBuilder<T> {\n    T body;\n    public RequestParamsBuilder(T body) {\n      this.body = body;\n    }\n    abstract RequestParams buildRequestParams();\n    void setBody(T body) {\n      this.body = body;\n    }\n  }\n  private <T> T executeSynchronousCallWithConflictRetry(\n      RequestParamsBuilder requestParamsBuilder,\n      SynchronousCallFactory<T> factory,\n      ConflictRetry<T> conflictRetry)\n      throws ApiException {\n    int retryCount = 0;\n    while (retryCount == 0 || retryCount < maxRetryCount) {\n      retryCount++;\n      RequestParams requestParams = requestParamsBuilder.buildRequestParams();\n      try {\n        return executeSynchronousCall(requestParams, factory);\n      } catch (ApiException apiException) {\n        boolean retry = false;\n        if (apiException.getCode() == HTTP_CONFLICT\n            && conflictRetry != null\n            && retryCount < maxRetryCount) {\n          T body = conflictRetry.getUpdatedObject();\n          if (body != null) {\n            requestParamsBuilder.setBody(body);\n            retry = true;\n            LOGGER.fine(\n                MessageKeys.SYNC_RETRY,\n                requestParams.call,\n                apiException.getCode(),\n                apiException.getMessage(),\n                retryCount,\n                maxRetryCount);\n          }\n        }\n        if (!retry) {\n          throw apiException;\n        }\n      }\n    }\n    return null;\n  }\n  private <T> T executeSynchronousCall(\n      RequestParams requestParams, SynchronousCallFactory<T> factory) throws ApiException {\n    return DISPATCHER.execute(factory, requestParams, helper);\n  }\n  /* Namespaces */\n  /**\n   * Read namespace.\n   *\n   * @param name Name\n   * @return Read service\n   * @throws ApiException API Exception\n   */<fim_middle>// class below is data class\n"}