{"text": "<fim_prefix>        throws IOException {\n      this.readerIterators = readerIterators;\n      this.numberOfRecordsPerReaderIterator =\n          new ArrayList<>(getListIndexFromReaderIterators(readerIterators));\n      this.valueTypeToOutputType = valueTypeToOutputType;\n    }\n    // TODO: Support greater than Integer.MAX_VALUE values for iteration/lookup and size.\n    @Override\n    public V get(int index) {\n      return getUsingLong(index);\n    }\n    @Override\n    public int size() {\n      return Ints.checkedCast(longSize());\n    }\n    @Override\n    public Iterator<V> iterator() {\n      return listIterator();\n    }\n    @Override\n    public ListIterator<V> listIterator() {\n      return new ListIteratorOverReaderIterators();\n    }\n    /** Returns the value at the specified position. */\n    private V getUsingLong(long index) {\n      try {\n        if (index < 0) {\n          throw new IndexOutOfBoundsException(\"Index out of range: \" + index);\n        }\n        // We locate which reader iterator contains the requested index\n        // by using the number of records contained within each reader iterator\n        // as a way to compute the local offset. Once we find a local offset\n        // which is within the bounds of the reader iterator, we use that local\n        // offset to find the requested record.\n        long localOffset = index;\n        int readerIteratorIndex;\n        for (readerIteratorIndex = 0;\n            readerIteratorIndex < numberOfRecordsPerReaderIterator.size();\n            ++readerIteratorIndex) {\n          if (localOffset < numberOfRecordsPerReaderIterator.get(readerIteratorIndex)) {\n            WindowedValue<IsmRecord<T>> rval =\n                readerIterators.get(readerIteratorIndex).get(ImmutableList.of(localOffset));\n            checkState(\n                rval != null,\n                \"Expected to have found index %s, local offset %s within file.\",\n                index,\n                localOffset);\n            return valueTypeToOutputType.apply(rval.getValue().getValue());\n          }\n          localOffset -= numberOfRecordsPerReaderIterator.get(readerIteratorIndex);\n        }\n        // If we went past the last file then we seeked past the end and are out of bounds.\n        throw new IndexOutOfBoundsException(\"Index out of range: \" + index);\n      } catch (IOException e) {\n        throw new IllegalStateException(e);\n      }\n    }\n    private long longSize() {\n      long total = 0;\n      for (Long numRecords : numberOfRecordsPerReaderIterator) {\n        total += numRecords;\n      }\n      return total;\n    }\n    /** An immutable list iterator that uses a long as its position. */\n    private class ListIteratorOverReaderIterators implements ListIterator<V> {\n      private long position;\n      @Override\n      public boolean hasNext() {\n        return position < longSize();\n      }\n      @Override\n      public V next() {\n        if (!hasNext()) {\n          throw new NoSuchElementException();\n        }\n        V rval = getUsingLong(position);\n        position += 1;\n        return rval;\n      }\n      @Override\n      public boolean hasPrevious() {\n        return position > 0;\n      }\n      @Override\n      public V previous() {\n        if (!hasPrevious()) {\n          throw new NoSuchElementException();\n        }\n        position -= 1;\n        return getUsingLong(position);\n      }\n      @Override\n      public int nextIndex() {\n        return Ints.checkedCast(position);\n      }\n      @Override\n      public int previousIndex() {\n        return Ints.checkedCast(position - 1);\n      }\n      @Override\n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n      @Override\n      public void set(V e) {\n        throw new UnsupportedOperationException();\n      }\n      @Override\n      public void add(V e) {\n        throw new UnsupportedOperationException();\n      }\n    }\n  }\n  /**\n   * A map that fronts a set of readers. This map assumes that the readers have records using the\n   * user key followed by window.\n   */\n  private class MapOverReaders<K, V1, V2, W extends BoundedWindow> extends AbstractMap<K, V2> {\n    private final W window;\n    private final Function<KV<K, IsmReader<WindowedValue<V1>>.IsmPrefixReaderIterator>, V2>\n        transform;\n    private final List<IsmReader<WindowedValue<V1>>> readers;\n    private final Coder<K> keyCoder;\n    private final long size;\n    private MapOverReaders(\n        W window,\n        Function<KV<K, IsmReader<WindowedValue<V1>>.IsmPrefixReaderIterator>, V2> transform,\n        List<IsmReader<WindowedValue<V1>>> readers,\n        Coder<K> keyCoder,\n        long size) {\n      this.window = window;\n      this.transform = transform;\n      this.readers = readers;\n      this.keyCoder = keyCoder;\n      this.size = size;\n    }\n    @Override\n    public boolean containsKey(Object key) {\n      try {\n        return !findAndStartReaders(readers, ImmutableList.of(key, window)).isEmpty();\n      } catch (IOException e) {\n        throw new IllegalStateException(e);\n      }\n    }\n    @Override\n    public V2 get(Object objectKey) {\n      @SuppressWarnings(\"unchecked\")\n      K key = (K) objectKey;\n      try {\n        // We find the reader iterator which contains the key/window prefix.\n        // For maps, this yields only one record. For multimaps, this is a valid\n        // prefix reader iterator.\n        List<IsmReader<WindowedValue<V1>>.IsmPrefixReaderIterator> readerIterators =\n            findAndStartReaders(readers, ImmutableList.of(key, window));\n        if (readerIterators.isEmpty()) {\n          return null;\n        }\n        // Only one such reader iterator is expected.\n        IsmReader<WindowedValue<V1>>.IsmPrefixReaderIterator readerIterator =\n            Iterables.getOnlyElement(readerIterators);\n        return transform.apply(KV.of(key, readerIterator));\n      } catch (IOException e) {\n        throw new IllegalStateException(e);\n      }\n    }\n    @Override\n    public int size() {\n      return Ints.checkedCast(size);\n    }\n    @Override\n    public Set<Entry<K, V2>> entrySet() {\n      return new EntrySet();\n    }\n    /** An entry set that is fronted by this map. */\n    private class EntrySet extends AbstractSet<Entry<K, V2>> {\n      @Override\n      public boolean contains(Object o) {\n        if (!(o instanceof Entry)) {\n          return false;\n        }\n        @SuppressWarnings(\"unchecked\")\n        Entry<K, ?> entry = (Entry<K, ?>) o;\n        try {\n          // We find the reader iterator which contains the key/window prefix.\n          // For maps, this yields only one record. For multimaps, this is a valid\n          // prefix reader iterator.\n          List<IsmReader<WindowedValue<V1>>.IsmPrefixReaderIterator> readerIterators =\n              findAndStartReaders(readers, ImmutableList.of(entry.getKey(), window));\n          if (readerIterators.isEmpty()) {\n            return false;\n          }\n          // Only one such reader iterator is expected.\n          IsmReader<WindowedValue<V1>>.IsmPrefixReaderIterator readerIterator =\n              Iterables.getOnlyElement(readerIterators);\n          return Objects.equal(\n              entry.getValue(), transform.apply(KV.of(entry.getKey(), readerIterator)));\n        } catch (IOException e) {\n          throw new IllegalStateException(e);\n        }\n      }\n      @Override\n      public Iterator<Entry<K, V2>> iterator() {\n        return new EntrySetIterator();\n      }\n      @Override\n      public int size() {\n        return Ints.checkedCast(size);\n      }\n    }\n    /**\n     * An entry set iterator that backs this map which utilizes the [META, Window, Index] records to\n     * locate subsequent keys.\n     */\n<fim_suffix>    private class EntrySetIterator implements Iterator<Entry<K, V2>> {\n      long position = 0;\n      @Override\n      public boolean hasNext() {\n        return position < size;\n      }\n      @Override\n      public Entry<K, V2> next() {\n        if (!hasNext()) {\n          throw new NoSuchElementException();\n        }\n        final K key;\n        final V2 value;\n        try {\n          key =\n              findMetadata(\n                  readers,\n                  ImmutableList.of(IsmFormat.getMetadataKey(), window, position + 1),\n                  keyCoder);\n          value = get(key);\n        } catch (IOException e) {\n          throw new IllegalStateException(e);\n        }\n        // Once we have fetched the key and value we can increment the position knowing that\n        // an exception won't be thrown, thus allowing retries.\n        position += 1;\n        return new StructuralMapEntry<>(keyCoder, key, value);\n      }\n      @Override\n      public void remove() {\n        throw new UnsupportedOperationException();\n      }\n    }<fim_middle>// class below has no smell\n"}