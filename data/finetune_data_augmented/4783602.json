{"text": "<fim_prefix>import org.eclipse.rdf4j.query.BindingSet;\nimport org.eclipse.rdf4j.query.MalformedQueryException;\nimport org.eclipse.rdf4j.query.QueryEvaluationException;\nimport org.eclipse.rdf4j.query.QueryLanguage;\nimport org.eclipse.rdf4j.query.TupleQuery;\nimport org.eclipse.rdf4j.query.TupleQueryResultHandlerException;\nimport org.eclipse.rdf4j.query.algebra.Extension;\nimport org.eclipse.rdf4j.query.algebra.Join;\nimport org.eclipse.rdf4j.query.algebra.QueryModelNode;\nimport org.eclipse.rdf4j.query.algebra.SingletonSet;\nimport org.eclipse.rdf4j.query.algebra.StatementPattern;\nimport org.eclipse.rdf4j.query.algebra.TupleExpr;\nimport org.eclipse.rdf4j.query.algebra.UnaryTupleOperator;\nimport org.eclipse.rdf4j.query.algebra.ValueExpr;\nimport org.eclipse.rdf4j.query.algebra.Var;\nimport org.eclipse.rdf4j.query.algebra.helpers.AbstractQueryModelVisitor;\nimport org.eclipse.rdf4j.query.parser.ParsedGraphQuery;\nimport org.eclipse.rdf4j.query.parser.ParsedQuery;\nimport org.eclipse.rdf4j.query.parser.sparql.SPARQLParser;\nimport org.eclipse.rdf4j.repository.RepositoryException;\nimport org.eclipse.rdf4j.repository.sail.SailRepository;\nimport org.eclipse.rdf4j.repository.sail.SailRepositoryConnection;\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.Sets;\n/**\n * Represents a SPIN Construct rule extracted from the data store, providing\n * access to its associated query tree and providing methods to apply the rule.\n */\npublic class SpinConstructRule extends AbstractConstructRule {\n    private static Logger logger = Logger.getLogger(SpinConstructRule.class);\n    private final Resource ruleId;\n    private final ParsedGraphQuery graphQuery;\n    private Set<StatementPattern> antecedentStatementPatterns = null;\n    private Set<StatementPattern> consequentStatementPatterns = null;\n    /**\n     * Instantiate a SPIN construct rule given its associated type, IRI or bnode\n     * identifier, and construct query tree. Modifies the query tree to\n     * incorporate the fact that ?this must belong to the associated type, and\n     * traverses the modified tree to find antecedent and consequent triple\n     * patterns.\n     * @param type This rule applies to objects of this type. Should not be\n     *  null. If the type is owl:Thing or rdfs:Resource, it will be applied to\n     *  any objects. Otherwise, a statement pattern will be added that\n     *  effectively binds ?this to members of the type. Therefore, passing\n     *  owl:Thing or rdfs:Resource yields the intended behavior of\n     *  sp:thisUnbound.\n     * @param ruleId The Resource representing this rule in the RDF data;\n     *  should not be null.\n     * @param graphQuery The query tree corresponding to the \"construct\" text;\n     *  should not be null.\n     */\n    public SpinConstructRule(Resource type, Resource ruleId,\n            ParsedGraphQuery graphQuery) {\n        Preconditions.checkNotNull(type);\n        Preconditions.checkNotNull(ruleId);\n        Preconditions.checkNotNull(graphQuery);\n        this.ruleId = ruleId;\n        this.graphQuery = graphQuery;\n        // Add the type requirement: ?this must belong to the type\n        graphQuery.getTupleExpr().visit(new TypeRequirementVisitor(\"this\", type));\n        // Find all statement patterns that could trigger this rule\n        AntecedentVisitor aVisitor = new AntecedentVisitor();\n        graphQuery.getTupleExpr().visit(aVisitor);\n        antecedentStatementPatterns = aVisitor.getAntecedents();\n        // Construct statement patterns for all possible conclusions of this rule\n        ConstructConsequentVisitor cVisitor = new ConstructConsequentVisitor();\n        graphQuery.getTupleExpr().visit(cVisitor);\n        consequentStatementPatterns = cVisitor.getConsequents();\n    }\n    /**\n     * Get the IRI or bnode associated with this rule in the data.\n     * @return The rule's identifier.\n     */\n    public Resource getId() {\n        return ruleId;\n    }\n    @Override\n    public String toString() {\n        return \"SpinConstructRule{\" + ruleId.stringValue() + \"}\";\n    }\n    @Override\n    public ParsedGraphQuery getQuery() {\n        return graphQuery;\n    }\n    @Override\n    public boolean canConclude(StatementPattern sp) {\n        Preconditions.checkNotNull(sp);\n        Value s1 = getVarValue(sp.getSubjectVar());\n        Value p1 = getVarValue(sp.getPredicateVar());\n        Value o1 = getVarValue(sp.getObjectVar());\n        Value c1 = getVarValue(sp.getContextVar());\n        for (StatementPattern consequent : consequentStatementPatterns) {\n            Value s2 = getVarValue(consequent.getSubjectVar());\n            Value p2 = getVarValue(consequent.getPredicateVar());\n            Value o2 = getVarValue(consequent.getObjectVar());\n            Value c2 = getVarValue(consequent.getContextVar());\n            if ((s1 == null || s2 == null || s1.equals(s2))\n                    && (p1 == null || p2 == null || p1.equals(p2))\n                    && (o1 == null || o2 == null || o1.equals(o2))\n                    && (c1 == null || c2 == null || c1.equals(c2))) {\n                return true;\n            }\n        }\n        return false;\n    }\n    @Override\n    public Collection<StatementPattern> getAntecedentPatterns() {\n        return antecedentStatementPatterns;\n    }\n    @Override\n    public Collection<StatementPattern> getConsequentPatterns() {\n        return consequentStatementPatterns;\n    }\n    @Override\n    public long execute(AbstractRuleExecutionStrategy strategy,\n            StatementMetadata metadata) throws ForwardChainException {\n        metadata.addMetadata(ForwardChainConstants.RYA_DERIVATION_RULE,\n                RdfToRyaConversions.convertResource(ruleId));\n        return super.execute(strategy, metadata);\n    }\n    private static Value getVarValue(Var var) {\n        return var == null ? null : var.getValue();\n    }\n<fim_suffix>    private static class TypeRequirementVisitor extends AbstractQueryModelVisitor<RuntimeException> {\n        private static final Var RDF_TYPE_VAR = VarNameUtils.createUniqueConstVar(RDF.TYPE);\n        private static final Set<Resource> BASE_TYPES = Sets.newHashSet(RDFS.RESOURCE, OWL.THING);\n        static {\n            RDF_TYPE_VAR.setConstant(true);\n        }\n        private final String varName;\n        private final StatementPattern typeRequirement;\n        public TypeRequirementVisitor(String varName, Resource requiredType) {\n            final Var typeVar = VarNameUtils.createUniqueConstVar(requiredType);\n            typeVar.setConstant(true);\n            this.varName = varName;\n            if (BASE_TYPES.contains(requiredType)) {\n                this.typeRequirement = null;\n            }\n            else {\n                this.typeRequirement = new StatementPattern(new Var(varName), RDF_TYPE_VAR, typeVar);\n            }\n        }\n        @Override\n        public void meet(SingletonSet node) {\n            if (typeRequirement != null) {\n                node.replaceWith(typeRequirement);\n            }\n        }\n        @Override\n        public void meet(Extension node) {\n            Set<String> argBindings = node.getArg().getBindingNames();\n            if (typeRequirement != null) {\n                node.getElements().removeIf(elem -> {\n                    if (varName.equals(elem.getName())) {\n                        ValueExpr expr = elem.getExpr();\n                        if (expr == null) {\n                            return true;\n                        }\n                        else if (expr instanceof Var) {\n                            String fromName = ((Var) expr).getName();\n                            if (getVarValue((Var) expr) == null && !argBindings.contains(fromName)) {\n                                return true;\n                            }\n                        }\n                    }\n                    return false;\n                });\n                meetUnaryTupleOperator(node);\n            }\n        }\n        @Override\n        public void meetNode(QueryModelNode node) {\n            if (typeRequirement != null) {\n                if (node instanceof TupleExpr && ((TupleExpr) node).getBindingNames().contains(varName)) {\n                    final Join withType = new Join((TupleExpr) node.clone(), typeRequirement);\n                    node.replaceWith(withType);\n                }\n                else {\n                    node.visitChildren(this);\n                }\n            }\n        }\n        @Override\n        public void meetUnaryTupleOperator(UnaryTupleOperator node) {\n            if (typeRequirement != null) {\n                if (node.getArg().getBindingNames().contains(varName)) {\n                    node.visitChildren(this);\n                }\n                else {\n                    meetNode(node);\n                }\n            }\n        }\n    }<fim_middle>// class below has no smell\n"}