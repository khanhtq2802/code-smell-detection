{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.reef.io.data.loading.api;\nimport org.apache.commons.lang.Validate;\nimport org.apache.reef.annotations.audience.DriverSide;\nimport org.apache.reef.driver.context.ContextConfiguration;\nimport org.apache.reef.driver.evaluator.AllocatedEvaluator;\nimport org.apache.reef.driver.evaluator.EvaluatorRequest;\nimport org.apache.reef.driver.evaluator.EvaluatorRequestor;\nimport org.apache.reef.driver.evaluator.FailedEvaluator;\nimport org.apache.reef.io.data.loading.impl.AvroEvaluatorRequestSerializer;\nimport org.apache.reef.io.network.util.Pair;\nimport org.apache.reef.tang.Configuration;\nimport org.apache.reef.tang.annotations.Parameter;\nimport org.apache.reef.tang.annotations.Unit;\nimport org.apache.reef.tang.exceptions.BindException;\nimport org.apache.reef.wake.EventHandler;\nimport org.apache.reef.wake.impl.SingleThreadStage;\nimport org.apache.reef.wake.time.Clock;\nimport org.apache.reef.wake.time.event.Alarm;\nimport org.apache.reef.wake.time.event.StartTime;\nimport javax.inject.Inject;\nimport java.util.Set;\nimport java.util.concurrent.BlockingQueue;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n/**\n * The driver component for the DataLoadingService\n * Also acts as the central point for resource requests\n * All the allocated evaluators pass through this and\n * the ones that need data loading have a context stacked\n * that enables a task to get access to Data via the\n * {@link DataSet}.\n * <p>\n * TODO: Add timeouts\n */\n@DriverSide\n@Unit\npublic class DataLoader {\n  private static final Logger LOG = Logger.getLogger(DataLoader.class.getName());\n  private final ConcurrentMap<String, Pair<Configuration, Configuration>> submittedDataEvalConfigs =\n      new ConcurrentHashMap<>();\n  private final ConcurrentMap<String, Configuration> submittedComputeEvalConfigs = new ConcurrentHashMap<>();\n  private final BlockingQueue<Configuration> failedComputeEvalConfigs = new LinkedBlockingQueue<>();\n  private final BlockingQueue<Pair<Configuration, Configuration>> failedDataEvalConfigs = new LinkedBlockingQueue<>();\n  private final AtomicInteger numComputeRequestsToSubmit = new AtomicInteger(0);\n  private final AtomicInteger numDataRequestsToSubmit = new AtomicInteger(0);\n  private final DataLoadingService dataLoadingService;\n  private int dataEvalMemoryMB;\n  private int dataEvalCore;\n  private final SingleThreadStage<EvaluatorRequest> resourceRequestStage;\n  private final ResourceRequestHandler resourceRequestHandler;\n  private int computeEvalMemoryMB;\n  private int computeEvalCore;\n  private final EvaluatorRequestor requestor;\n  /**\n   * Allows to specify compute and data evaluator requests in particular\n   * locations.\n   *\n   * @param clock\n   *          the clock\n   * @param requestor\n   *          the evaluator requestor\n   * @param dataLoadingService\n   *          the data loading service\n   * @param serializedComputeRequests\n   *          serialized compute requests (evaluators that will not load data)\n   * @param serializedDataRequests\n   *          serialized data requests (evaluators that will load data). It\n   *          cannot be empty (to maintain previous functionality)\n   */\n  @Inject\n  public DataLoader(\n      final Clock clock,\n      final EvaluatorRequestor requestor,\n      final DataLoadingService dataLoadingService,\n      @Parameter(DataLoadingRequestBuilder.DataLoadingComputeRequests.class)\n      final Set<String> serializedComputeRequests,\n      @Parameter(DataLoadingRequestBuilder.DataLoadingDataRequests.class) final Set<String> serializedDataRequests) {\n    // data requests should not be empty. This maintains previous functionality\n    Validate.notEmpty(serializedDataRequests, \"Should contain a data request object\");\n    // FIXME: Issue #855: We need this alarm to look busy for REEF.\n    clock.scheduleAlarm(30000, new EventHandler<Alarm>() {\n      @Override\n      public void onNext(final Alarm time) {\n        LOG.log(Level.FINE, \"Received Alarm: {0}\", time);\n      }\n    });\n    this.requestor = requestor;\n    this.dataLoadingService = dataLoadingService;\n    this.resourceRequestHandler = new ResourceRequestHandler(requestor);\n    // the resource request queue will have as many requests as compute and data requests.\n    this.resourceRequestStage = new SingleThreadStage<>(\n        this.resourceRequestHandler, serializedComputeRequests.size()\n            + serializedDataRequests.size());\n    if (serializedComputeRequests.isEmpty()) {\n      this.computeEvalMemoryMB = -1;\n      this.computeEvalCore = 1;\n    } else {\n      // Deserialize each compute request.\n      // Keep the maximum number of cores and memory requested, in case some\n      // evaluator fails, we will try to reallocate based on that.\n      for (final String serializedComputeRequest : serializedComputeRequests) {\n        final EvaluatorRequest computeRequest = AvroEvaluatorRequestSerializer.fromString(serializedComputeRequest);\n        this.numComputeRequestsToSubmit.addAndGet(computeRequest.getNumber());\n        this.computeEvalMemoryMB = Math.max(this.computeEvalMemoryMB, computeRequest.getMegaBytes());\n        this.computeEvalCore = Math.max(this.computeEvalCore, computeRequest.getNumberOfCores());\n        this.resourceRequestStage.onNext(computeRequest);\n      }\n    }\n    // Deserialize each data requests.\n    // We distribute the partitions evenly across the DCs.\n    // The number of partitions extracted from the dataLoadingService override\n    // the number of evaluators requested (this preserves previous functionality)\n    final int dcs = serializedDataRequests.size();\n    final int partitionsPerDataCenter = this.dataLoadingService.getNumberOfPartitions() / dcs;\n    int missing = this.dataLoadingService.getNumberOfPartitions() % dcs;\n    for (final String serializedDataRequest : serializedDataRequests) {\n      EvaluatorRequest dataRequest = AvroEvaluatorRequestSerializer.fromString(serializedDataRequest);\n      this.dataEvalMemoryMB = Math.max(this.dataEvalMemoryMB, dataRequest.getMegaBytes());\n      this.dataEvalCore = Math.max(this.dataEvalCore, dataRequest.getNumberOfCores());\n      // clone the request but update the number of evaluators based on the number of partitions\n      int number = partitionsPerDataCenter;\n      if (missing > 0) {\n        number++;\n        missing--;\n      }\n      dataRequest = EvaluatorRequest.newBuilder(dataRequest).setNumber(number).build();\n      this.numDataRequestsToSubmit.addAndGet(number);\n      this.resourceRequestStage.onNext(dataRequest);\n    }\n  }\n<fim_suffix>  public class StartHandler implements EventHandler<StartTime> {\n    @Override\n    public void onNext(final StartTime startTime) {\n      LOG.log(Level.INFO, \"StartTime: {0}\", startTime);\n      resourceRequestHandler.releaseResourceRequestGate();\n    }\n  }\n  public class EvaluatorAllocatedHandler implements EventHandler<AllocatedEvaluator> {\n    @Override\n    public void onNext(final AllocatedEvaluator allocatedEvaluator) {\n      final String evalId = allocatedEvaluator.getId();\n      LOG.log(Level.FINEST, \"Allocated evaluator: {0}\", evalId);\n      if (!failedComputeEvalConfigs.isEmpty()) {\n        LOG.log(Level.FINE, \"Failed Compute requests need to be satisfied for {0}\", evalId);\n        final Configuration conf = failedComputeEvalConfigs.poll();\n        if (conf != null) {\n          LOG.log(Level.FINE, \"Satisfying failed configuration for {0}\", evalId);\n          allocatedEvaluator.submitContext(conf);\n          submittedComputeEvalConfigs.put(evalId, conf);\n          return;\n        }\n      }\n      if (!failedDataEvalConfigs.isEmpty()) {\n        LOG.log(Level.FINE, \"Failed Data requests need to be satisfied for {0}\", evalId);\n        final Pair<Configuration, Configuration> confPair = failedDataEvalConfigs.poll();\n        if (confPair != null) {<fim_middle>// class below has no smell\n"}