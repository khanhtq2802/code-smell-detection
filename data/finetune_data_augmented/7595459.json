{"text": "<fim_prefix>/*\n * Copyright 2006-2011 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations under the License.\n */\n\npackage org.springframework.security.oauth2.provider.expression;\n\nimport java.util.Arrays;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\n\nimport org.springframework.security.access.AccessDeniedException;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.oauth2.common.exceptions.InsufficientScopeException;\n\n/**\n * A convenience object for security expressions in OAuth2 protected resources, providing public methods that act on the\n * current authentication.\n * \n * @author Dave Syer\n * @author Rob Winch\n * @author Radek Ostrowski\n * \n */\npublic class OAuth2SecurityExpressionMethods {\n\n\tprivate final Authentication authentication;\n\n\tprivate Set<String> missingScopes = new LinkedHashSet<String>();\n\n\tpublic OAuth2SecurityExpressionMethods(Authentication authentication) {\n\t\tthis.authentication = authentication;\n\t}\n\n\t/**\n\t * Check if any scope decisions have been denied in the current context and throw an exception if so. This method\n\t * automatically wraps any expressions when using {@link OAuth2MethodSecurityExpressionHandler} or\n\t * {@link OAuth2WebSecurityExpressionHandler}.\n\t * \n\t * OAuth2Example usage:\n\t * \n\t * <pre>\n\t * access = &quot;#oauth2.hasScope('read') or (#oauth2.hasScope('other') and hasRole('ROLE_USER'))&quot;\n\t * </pre>\n\t * \n\t * Will automatically be wrapped to ensure that explicit errors are propagated rather than a generic error when\n\t * returning false:\n\t * \n\t * <pre>\n\t * access = &quot;#oauth2.throwOnError(#oauth2.hasScope('read') or (#oauth2.hasScope('other') and hasRole('ROLE_USER'))&quot;\n\t * </pre>\n\t * \n\t * N.B. normally this method will be automatically wrapped around all your access expressions. You could use it\n\t * explicitly to get more control, or if you have registered your own <code>ExpressionParser</code> you might need\n\t * it.\n\t * \n\t * @param decision the existing access decision\n\t * @return true if the OAuth2 token has one of these scopes\n\t * @throws InsufficientScopeException if the scope is invalid and we the flag is set to throw the exception\n\t */\n\tpublic boolean throwOnError(boolean decision) {\n\t\tif (!decision && !missingScopes.isEmpty()) {\n\t\t\tThrowable failure = new InsufficientScopeException(\"Insufficient scope for this resource\", missingScopes);\n\t\t\tthrow new AccessDeniedException(failure.getMessage(), failure);\n\t\t}\n\t\treturn decision;\n\t}\n\n\t/**\n\t * Check if the OAuth2 client (not the user) has the role specified. To check the user's roles see\n\t * {@link #clientHasRole(String)}.\n\t * \n\t * @param role the role to check\n\t * @return true if the OAuth2 client has this role\n\t */\n\tpublic boolean clientHasRole(String role) {\n\t\treturn clientHasAnyRole(role);\n\t}\n\n\t/**\n\t * Check if the OAuth2 client (not the user) has one of the roles specified. To check the user's roles see\n\t * {@link #clientHasAnyRole(String...)}.\n\t * \n\t * @param roles the roles to check\n\t * @return true if the OAuth2 client has one of these roles\n\t */\n\tpublic boolean clientHasAnyRole(String... roles) {\n\t\treturn OAuth2ExpressionUtils.clientHasAnyRole(authentication, roles);\n\t}\n\n\t/**\n\t * Check if the current OAuth2 authentication has the scope specified.\n\t * \n\t * @param scope the scope to check\n\t * @return true if the OAuth2 authentication has the required scope\n\t */\n\tpublic boolean hasScope(String scope) {\n\t\treturn hasAnyScope(scope);\n\t}\n\n\t/**\n\t * Check if the current OAuth2 authentication has one of the scopes specified.\n\t * \n\t * @param scopes the scopes to check\n\t * @return true if the OAuth2 token has one of these scopes\n\t * @throws AccessDeniedException if the scope is invalid and we the flag is set to throw the exception\n\t */\n<fim_suffix>\tpublic boolean hasAnyScope(String... scopes) {\n\t\tboolean result = OAuth2ExpressionUtils.hasAnyScope(authentication, scopes);\n\t\tif (!result) {\n\t\t\tmissingScopes.addAll(Arrays.asList(scopes));\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Check if the current OAuth2 authentication has one of the scopes matching a specified regex expression.\n\t * \n\t * <pre>\n\t * access = &quot;#oauth2.hasScopeMatching('.*_admin:manage_scopes')))&quot;\n\t * </pre>\n\t * \n\t * @param scopeRegex the scope regex to match\n\t * @return true if the OAuth2 authentication has the required scope\n\t */\n\tpublic boolean hasScopeMatching(String scopeRegex) {\n\t\treturn hasAnyScopeMatching(scopeRegex);\n\t}\n\n\t/**\n\t * Check if the current OAuth2 authentication has one of the scopes matching a specified regex expression.\n\t * \n\t * <pre>\n\t * access = &quot;#oauth2.hasAnyScopeMatching('admin:manage_scopes','.*_admin:manage_scopes','.*_admin:read_scopes')))&quot;\n\t * </pre>\n\t * \n\t * @param scopesRegex the scopes regex to match\n\t * @return true if the OAuth2 token has one of these scopes\n\t * @throws AccessDeniedException if the scope is invalid and we the flag is set to throw the exception\n\t */\n\tpublic boolean hasAnyScopeMatching(String... scopesRegex) {\n\n\t\tboolean result = OAuth2ExpressionUtils.hasAnyScopeMatching(authentication, scopesRegex);\n\t\tif (!result) {\n\t\t\tmissingScopes.addAll(Arrays.asList(scopesRegex));\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Deny access to oauth requests, so used for example to only allow web UI users to access a resource.\n\t * \n\t * @return true if the current authentication is not an OAuth2 type\n\t */\n\tpublic boolean denyOAuthClient() {\n\t\treturn !OAuth2ExpressionUtils.isOAuth(authentication);\n\t}\n\n\t/**\n\t * Permit access to oauth requests, so used for example to only allow machine clients to access a resource.\n\t * \n\t * @return true if the current authentication is not an OAuth2 type\n\t */\n\tpublic boolean isOAuth() {\n\t\treturn OAuth2ExpressionUtils.isOAuth(authentication);\n\t}\n\n\t/**\n\t * Check if the current authentication is acting on behalf of an authenticated user.\n\t * \n\t * @return true if the current authentication represents a user\n\t */\n\tpublic boolean isUser() {\n\t\treturn OAuth2ExpressionUtils.isOAuthUserAuth(authentication);\n\t}\n\n\t/**\n\t * Check if the current authentication is acting as an authenticated client application not on behalf of a user.\n\t * \n\t * @return true if the current authentication represents a client application\n\t */\n\tpublic boolean isClient() {\n\t\treturn OAuth2ExpressionUtils.isOAuthClientAuth(authentication);\n\t}\n}<fim_middle>// function below has no smell\n"}