{"text": "<fim_prefix>     */\n    private transient boolean isPrimarySession = true;\n    /**\n     * The delta request contains all the action info\n     *\n     */\n    private transient DeltaRequest deltaRequest = null;\n    /**\n     * Last time the session was replicated, used for distributed expiring of\n     * session\n     */\n    private transient long lastTimeReplicated = System.currentTimeMillis();\n    protected final Lock diffLock = new ReentrantReadWriteLock().writeLock();\n    private long version;\n    // ----------------------------------------------------------- Constructors\n    public DeltaSession() {\n        this(null);\n    }\n    /**\n     * Construct a new Session associated with the specified Manager.\n     *\n     * @param manager\n     *            The manager with which this Session is associated\n     */\n    public DeltaSession(Manager manager) {\n        super(manager);\n        this.resetDeltaRequest();\n    }\n    // ----------------------------------------------------- ReplicatedMapEntry\n    /**\n     * Has the object changed since last replication\n     * and is not in a locked state\n     * @return boolean\n     */\n    @Override\n    public boolean isDirty() {\n        return getDeltaRequest().getSize()>0;\n    }\n    /**\n     * If this returns true, the map will extract the diff using getDiff()\n     * Otherwise it will serialize the entire object.\n     * @return boolean\n     */\n    @Override\n    public boolean isDiffable() {\n        return true;\n    }\n    /**\n     * Returns a diff and sets the dirty map to false\n     * @return a serialized view of the difference\n     * @throws IOException IO error serializing\n     */\n    @Override\n    public byte[] getDiff() throws IOException {\n        lock();\n        try {\n            return getDeltaRequest().serialize();\n        } finally{\n            unlock();\n        }\n    }\n    public ClassLoader[] getClassLoaders() {\n        if (manager instanceof ClusterManagerBase) {\n            return ((ClusterManagerBase)manager).getClassLoaders();\n        } else if (manager instanceof ManagerBase) {\n            ManagerBase mb = (ManagerBase)manager;\n            return ClusterManagerBase.getClassLoaders(mb.getContext());\n        }\n        return null;\n    }\n    /**\n     * Applies a diff to an existing object.\n     * @param diff Serialized diff data\n     * @param offset Array offset\n     * @param length Array length\n     * @throws IOException IO error deserializing\n     */\n    @Override\n    public void applyDiff(byte[] diff, int offset, int length) throws IOException, ClassNotFoundException {\n        lock();\n        try (ObjectInputStream stream = ((ClusterManager) getManager()).getReplicationStream(diff, offset, length)) {\n            ClassLoader contextLoader = Thread.currentThread().getContextClassLoader();\n            try {\n                ClassLoader[] loaders = getClassLoaders();\n                if (loaders != null && loaders.length > 0)\n                    Thread.currentThread().setContextClassLoader(loaders[0]);\n                getDeltaRequest().readExternal(stream);\n                getDeltaRequest().execute(this, ((ClusterManager)getManager()).isNotifyListenersOnReplication());\n            } finally {\n                Thread.currentThread().setContextClassLoader(contextLoader);\n            }\n        } finally {\n            unlock();\n        }\n    }\n    /**\n     * Resets the current diff state and resets the dirty flag\n     */\n    @Override\n    public void resetDiff() {\n        resetDeltaRequest();\n    }\n    /**\n     * Lock during serialization\n     */\n    @Override\n    public void lock() {\n        diffLock.lock();\n    }\n    /**\n     * Unlock after serialization\n     */\n    @Override\n    public void unlock() {\n        diffLock.unlock();\n    }\n    @Override\n    public void setOwner(Object owner) {\n        if ( owner instanceof ClusterManager && getManager()==null) {\n            ClusterManager cm = (ClusterManager)owner;\n            this.setManager(cm);\n            this.setValid(true);\n            this.setPrimarySession(false);\n            this.access();\n            this.resetDeltaRequest();\n            this.endAccess();\n        }\n    }\n    /**\n     * If this returns true, to replicate that an object has been accessed\n     * @return boolean\n     */\n    @Override\n    public boolean isAccessReplicate() {\n        long replDelta = System.currentTimeMillis() - getLastTimeReplicated();\n        if (maxInactiveInterval >=0 && replDelta > (maxInactiveInterval * 1000L)) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Access to an existing object.\n     */\n    @Override\n    public void accessEntry() {\n        this.access();\n        this.setPrimarySession(false);\n        this.endAccess();\n    }\n    // ----------------------------------------------------- Session Properties\n    /**\n     * returns true if this session is the primary session, if that is the case,\n     * the manager can expire it upon timeout.\n     */\n    @Override\n    public boolean isPrimarySession() {\n        return isPrimarySession;\n    }\n    /**\n     * Sets whether this is the primary session or not.\n     *\n     * @param primarySession\n     *            Flag value\n     */\n    @Override\n    public void setPrimarySession(boolean primarySession) {\n        this.isPrimarySession = primarySession;\n    }\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void setId(String id, boolean notify) {\n        super.setId(id, notify);\n        resetDeltaRequest();\n    }\n    /**\n     * Set the session identifier for this session.\n     *\n     * @param id\n     *            The new session identifier\n     */\n    @Override\n    public void setId(String id) {\n        super.setId(id, true);\n        resetDeltaRequest();\n    }\n    @Override\n    public void setMaxInactiveInterval(int interval) {\n        this.setMaxInactiveInterval(interval,true);\n    }\n    public void setMaxInactiveInterval(int interval, boolean addDeltaRequest) {\n        super.maxInactiveInterval = interval;\n        if (addDeltaRequest && (deltaRequest != null)) {\n            lock();\n            try {\n                deltaRequest.setMaxInactiveInterval(interval);\n            } finally{\n                unlock();\n            }\n        }\n    }\n    /**\n     * Set the <code>isNew</code> flag for this session.\n     *\n     * @param isNew\n     *            The new value for the <code>isNew</code> flag\n     */\n    @Override\n    public void setNew(boolean isNew) {\n        setNew(isNew, true);\n    }\n    public void setNew(boolean isNew, boolean addDeltaRequest) {\n        super.setNew(isNew);\n        if (addDeltaRequest && (deltaRequest != null)){\n            lock();\n            try {\n                deltaRequest.setNew(isNew);\n            } finally{\n                unlock();\n            }\n        }\n    }\n    /**\n     * Set the authenticated Principal that is associated with this Session.\n     * This provides an <code>Authenticator</code> with a means to cache a\n     * previously authenticated Principal, and avoid potentially expensive\n     * <code>Realm.authenticate()</code> calls on every request.\n     *\n     * @param principal\n     *            The new Principal, or <code>null</code> if none\n     */\n    @Override\n    public void setPrincipal(Principal principal) {\n        setPrincipal(principal, true);\n    }\n    public void setPrincipal(Principal principal, boolean addDeltaRequest) {\n        lock();\n        try {\n            super.setPrincipal(principal);\n            if (addDeltaRequest && (deltaRequest != null))\n                deltaRequest.setPrincipal(principal);\n        } finally {\n            unlock();\n        }\n    }\n    /**\n     * Set the authentication type used to authenticate our cached\n     * Principal, if any.\n     *\n     * @param authType The new cached authentication type\n     */\n    @Override\n    public void setAuthType(String authType) {\n        setAuthType(authType, true);\n    }\n    public void setAuthType(String authType, boolean addDeltaRequest) {\n        lock();\n        try {\n            super.setAuthType(authType);\n            if (addDeltaRequest && (deltaRequest != null))\n                deltaRequest.setAuthType(authType);\n        } finally {\n            unlock();\n        }\n    }\n    /**\n     * Return the <code>isValid</code> flag for this session.\n     */\n    @Override\n    public boolean isValid() {\n        if (!this.isValid) {\n            return false;\n        }\n        if (this.expiring) {\n            return true;\n        }\n        if (ACTIVITY_CHECK && accessCount.get() > 0) {\n            return true;\n        }\n        if (maxInactiveInterval > 0) {\n            int timeIdle = (int) (getIdleTimeInternal() / 1000L);\n            if (isPrimarySession()) {\n                if (timeIdle >= maxInactiveInterval) {\n                    expire(true);\n                }\n            } else {\n                if (timeIdle >= (2 * maxInactiveInterval)) {\n                    //if the session has been idle twice as long as allowed,\n                    //the primary session has probably crashed, and no other\n                    //requests are coming in. that is why we do this. otherwise\n                    //we would have a memory leak\n                    expire(true, false);\n                }\n            }\n        }\n        return this.isValid;\n    }\n    /**\n     * End the access and register to ReplicationValve (crossContext support)\n     */\n<fim_suffix>    @Override\n    public void endAccess() {\n        super.endAccess() ;\n        if(manager instanceof ClusterManagerBase) {\n            ((ClusterManagerBase)manager).registerSessionAtReplicationValve(this);\n        }\n    }<fim_middle>// function below is feature envy\n"}