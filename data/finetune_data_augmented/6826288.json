{"text": "<fim_prefix>/*\n * Copyright (C) 2010 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.conscrypt.javax.net.ssl;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\n\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport javax.net.ssl.SSLEngine;\nimport javax.net.ssl.SSLEngineResult;\nimport javax.net.ssl.SSLEngineResult.HandshakeStatus;\nimport javax.net.ssl.SSLException;\nimport javax.net.ssl.SSLSession;\n\n/**\n * TestSSLEnginePair is a convenience class for other tests that want\n * a pair of connected and handshaked client and server SSLEngines for\n * testing.\n */\npublic final class TestSSLEnginePair implements Closeable {\n    public final TestSSLContext c;\n    public final SSLEngine server;\n    public final SSLEngine client;\n\n    private TestSSLEnginePair(TestSSLContext c,\n            SSLEngine server,\n            SSLEngine client) {\n        this.c = c;\n        this.server = server;\n        this.client = client;\n    }\n\n    public static TestSSLEnginePair create() throws IOException {\n        return create((Hooks) null);\n    }\n\n    public static TestSSLEnginePair create(TestSSLContext c) throws IOException {\n        return create(c, null);\n    }\n\n    public static TestSSLEnginePair create(Hooks hooks) throws IOException {\n        return create(TestSSLContext.create(), hooks);\n    }\n\n    public static TestSSLEnginePair create(TestSSLContext c, Hooks hooks) throws IOException {\n        return create(c, hooks, null);\n    }\n\n    public static TestSSLEnginePair create(TestSSLContext c, Hooks hooks, boolean[] finished)\n            throws IOException {\n        SSLEngine[] engines = connect(c, hooks, finished);\n        return new TestSSLEnginePair(c, engines[0], engines[1]);\n    }\n\n    public static SSLEngine[] connect(TestSSLContext c, Hooks hooks) throws IOException {\n        return connect(c, hooks, null);\n    }\n\n    /**\n     * Create a new connected server/client engine pair within a\n     * existing SSLContext. Optionally specify clientCipherSuites to\n     * allow forcing new SSLSession to test SSLSessionContext\n     * caching. Optionally specify serverCipherSuites for testing\n     * cipher suite negotiation.\n     */\n    public static SSLEngine[] connect(final TestSSLContext c,\n            Hooks hooks,\n            boolean finished[]) throws IOException {\n        if (hooks == null) {\n            hooks = new Hooks();\n        }\n\n        // FINISHED state should be returned only once.\n        boolean[] clientFinished = new boolean[1];\n        boolean[] serverFinished = new boolean[1];\n\n        SSLSession session = c.clientContext.createSSLEngine().getSession();\n\n        int packetBufferSize = session.getPacketBufferSize();\n        ByteBuffer clientToServer = ByteBuffer.allocate(packetBufferSize);\n        ByteBuffer serverToClient = ByteBuffer.allocate(packetBufferSize);\n\n        int applicationBufferSize = session.getApplicationBufferSize();\n        ByteBuffer scratch = ByteBuffer.allocate(applicationBufferSize);\n\n        SSLEngine client = c.clientContext.createSSLEngine(c.host.getHostName(), c.port);\n        SSLEngine server = c.serverContext.createSSLEngine();\n        client.setUseClientMode(true);\n        server.setUseClientMode(false);\n        hooks.beforeBeginHandshake(client, server);\n        client.beginHandshake();\n        server.beginHandshake();\n\n        while (true) {\n            boolean clientDone = client.getHandshakeStatus() == HandshakeStatus.NOT_HANDSHAKING;\n            boolean serverDone = server.getHandshakeStatus() == HandshakeStatus.NOT_HANDSHAKING;\n            if (clientDone && serverDone) {\n                break;\n            }\n\n            boolean progress = handshakeCompleted(client,\n                    clientToServer,\n                    serverToClient,\n                    scratch,\n                    clientFinished);\n            progress |= handshakeCompleted(server,\n                    serverToClient,\n                    clientToServer,\n                    scratch,\n                    serverFinished);\n            if (!progress) {\n                break;\n            }\n        }\n\n        if (finished != null) {\n            assertEquals(2, finished.length);\n            finished[0] = clientFinished[0];\n            finished[1] = serverFinished[0];\n        }\n        return new SSLEngine[] { server, client };\n    }\n\n    public static class Hooks {\n        void beforeBeginHandshake(SSLEngine client, SSLEngine server) {}\n    }\n\n    @Override\n    public void close() throws SSLException {\n        close(new SSLEngine[] { client, server });\n    }\n\n    public static void close(SSLEngine[] engines) {\n        try {\n            for (SSLEngine engine : engines) {\n                if (engine != null) {\n                    engine.closeInbound();\n                    engine.closeOutbound();\n                }\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private static boolean handshakeCompleted(SSLEngine engine,\n            ByteBuffer output,\n            ByteBuffer input,\n            ByteBuffer scratch,\n            boolean[] finished) throws IOException {\n        try {\n            // make the other side's output into our input\n            input.flip();\n\n            HandshakeStatus status = engine.getHandshakeStatus();\n            switch (status) {\n\n                case NEED_TASK: {\n                    boolean progress = false;\n                    while (true) {\n                        Runnable runnable = engine.getDelegatedTask();\n                        if (runnable == null) {\n                            return progress;\n                        }\n                        runnable.run();\n                        progress = true;\n                    }\n                }\n\n                case NOT_HANDSHAKING:\n                    // If we're not handshaking, our peer might still be.  Check if there's\n                    // any input for us to consume.\n                case NEED_UNWRAP: {\n                    // avoid underflow\n                    if (input.remaining() == 0) {\n                        return false;\n                    }\n                    int inputPositionBefore = input.position();\n                    SSLEngineResult unwrapResult = engine.unwrap(input, scratch);\n                    assertEquals(SSLEngineResult.Status.OK, unwrapResult.getStatus());\n                    assertEquals(0, scratch.position());\n                    assertEquals(0, unwrapResult.bytesProduced());\n                    assertEquals(input.position() - inputPositionBefore, unwrapResult.bytesConsumed());\n                    assertFinishedOnce(finished, unwrapResult);\n                    return true;\n                }\n\n                case NEED_WRAP: {\n                    // avoid possible overflow\n                    if (output.remaining() != output.capacity()) {\n                        return false;\n                    }\n                    ByteBuffer emptyByteBuffer = ByteBuffer.allocate(0);\n                    int inputPositionBefore = emptyByteBuffer.position();\n                    int outputPositionBefore = output.position();\n                    SSLEngineResult wrapResult = engine.wrap(emptyByteBuffer, output);\n                    assertEquals(SSLEngineResult.Status.OK, wrapResult.getStatus());\n                    assertEquals(0, wrapResult.bytesConsumed());\n                    assertEquals(inputPositionBefore, emptyByteBuffer.position());\n                    assertEquals(output.position() - outputPositionBefore,\n                            wrapResult.bytesProduced());\n                    assertFinishedOnce(finished, wrapResult);\n                    return true;\n                }\n\n                case FINISHED:\n                    // only returned by wrap/unrap status, not getHandshakeStatus\n                    throw new IllegalStateException(\"Unexpected HandshakeStatus = \" + status);\n                default:\n                    throw new IllegalStateException(\"Unknown HandshakeStatus = \" + status);\n            }\n        } finally {\n            // shift consumed input, restore to output mode\n            input.compact();\n        }\n    }\n\n<fim_suffix>    private static void assertFinishedOnce(boolean[] finishedOut, SSLEngineResult result) {\n        if (result.getHandshakeStatus() == HandshakeStatus.FINISHED) {\n            assertFalse(\"should only return FINISHED once\", finishedOut[0]);\n            finishedOut[0] = true;\n        }\n    }\n}<fim_middle>// function below has no smell\n"}