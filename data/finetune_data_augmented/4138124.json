{"text": "<fim_prefix>    }\n    public SqlInsert getNode() {\n      return node;\n    }\n  }\n  /**\n   * Namespace for an UPDATE statement.\n   */\n  private static class UpdateNamespace extends DmlNamespace {\n    private final SqlUpdate node;\n    UpdateNamespace(SqlValidatorImpl validator, SqlUpdate node,\n        SqlNode enclosingNode, SqlValidatorScope parentScope) {\n      super(validator, node.getTargetTable(), enclosingNode, parentScope);\n      this.node = Objects.requireNonNull(node);\n    }\n    public SqlUpdate getNode() {\n      return node;\n    }\n  }\n  /**\n   * Namespace for a DELETE statement.\n   */\n  private static class DeleteNamespace extends DmlNamespace {\n    private final SqlDelete node;\n    DeleteNamespace(SqlValidatorImpl validator, SqlDelete node,\n        SqlNode enclosingNode, SqlValidatorScope parentScope) {\n      super(validator, node.getTargetTable(), enclosingNode, parentScope);\n      this.node = Objects.requireNonNull(node);\n    }\n    public SqlDelete getNode() {\n      return node;\n    }\n  }\n  /**\n   * Namespace for a MERGE statement.\n   */\n  private static class MergeNamespace extends DmlNamespace {\n    private final SqlMerge node;\n    MergeNamespace(SqlValidatorImpl validator, SqlMerge node,\n        SqlNode enclosingNode, SqlValidatorScope parentScope) {\n      super(validator, node.getTargetTable(), enclosingNode, parentScope);\n      this.node = Objects.requireNonNull(node);\n    }\n    public SqlMerge getNode() {\n      return node;\n    }\n  }\n  /**\n   * retrieve pattern variables defined\n   */\n  private class PatternVarVisitor implements SqlVisitor<Void> {\n    private MatchRecognizeScope scope;\n    PatternVarVisitor(MatchRecognizeScope scope) {\n      this.scope = scope;\n    }\n    @Override public Void visit(SqlLiteral literal) {\n      return null;\n    }\n    @Override public Void visit(SqlCall call) {\n      for (int i = 0; i < call.getOperandList().size(); i++) {\n        call.getOperandList().get(i).accept(this);\n      }\n      return null;\n    }\n    @Override public Void visit(SqlNodeList nodeList) {\n      throw Util.needToImplement(nodeList);\n    }\n    @Override public Void visit(SqlIdentifier id) {\n      Preconditions.checkArgument(id.isSimple());\n      scope.addPatternVar(id.getSimple());\n      return null;\n    }\n    @Override public Void visit(SqlDataTypeSpec type) {\n      throw Util.needToImplement(type);\n    }\n    @Override public Void visit(SqlDynamicParam param) {\n      throw Util.needToImplement(param);\n    }\n    @Override public Void visit(SqlIntervalQualifier intervalQualifier) {\n      throw Util.needToImplement(intervalQualifier);\n    }\n  }\n  /**\n   * Visitor which derives the type of a given {@link SqlNode}.\n   *\n   * <p>Each method must return the derived type. This visitor is basically a\n   * single-use dispatcher; the visit is never recursive.\n   */\n  private class DeriveTypeVisitor implements SqlVisitor<RelDataType> {\n    private final SqlValidatorScope scope;\n    DeriveTypeVisitor(SqlValidatorScope scope) {\n      this.scope = scope;\n    }\n    public RelDataType visit(SqlLiteral literal) {\n      return literal.createSqlType(typeFactory);\n    }\n    public RelDataType visit(SqlCall call) {\n      final SqlOperator operator = call.getOperator();\n      return operator.deriveType(SqlValidatorImpl.this, scope, call);\n    }\n    public RelDataType visit(SqlNodeList nodeList) {\n      // Operand is of a type that we can't derive a type for. If the\n      // operand is of a peculiar type, such as a SqlNodeList, then you\n      // should override the operator's validateCall() method so that it\n      // doesn't try to validate that operand as an expression.\n      throw Util.needToImplement(nodeList);\n    }\n    public RelDataType visit(SqlIdentifier id) {\n      // First check for builtin functions which don't have parentheses,\n      // like \"LOCALTIME\".\n      SqlCall call = SqlUtil.makeCall(opTab, id);\n      if (call != null) {\n        return call.getOperator().validateOperands(\n            SqlValidatorImpl.this,\n            scope,\n            call);\n      }\n      RelDataType type = null;\n      if (!(scope instanceof EmptyScope)) {\n        id = scope.fullyQualify(id).identifier;\n      }\n      // Resolve the longest prefix of id that we can\n      int i;\n      for (i = id.names.size() - 1; i > 0; i--) {\n        // REVIEW jvs 9-June-2005: The name resolution rules used\n        // here are supposed to match SQL:2003 Part 2 Section 6.6\n        // (identifier chain), but we don't currently have enough\n        // information to get everything right.  In particular,\n        // routine parameters are currently looked up via resolve;\n        // we could do a better job if they were looked up via\n        // resolveColumn.\n        final SqlNameMatcher nameMatcher = catalogReader.nameMatcher();\n        final SqlValidatorScope.ResolvedImpl resolved =\n            new SqlValidatorScope.ResolvedImpl();\n        scope.resolve(id.names.subList(0, i), nameMatcher, false, resolved);\n        if (resolved.count() == 1) {\n          // There's a namespace with the name we seek.\n          final SqlValidatorScope.Resolve resolve = resolved.only();\n          type = resolve.rowType();\n          for (SqlValidatorScope.Step p : Util.skip(resolve.path.steps())) {\n            type = type.getFieldList().get(p.i).getType();\n          }\n          break;\n        }\n      }\n      // Give precedence to namespace found, unless there\n      // are no more identifier components.\n      if (type == null || id.names.size() == 1) {\n        // See if there's a column with the name we seek in\n        // precisely one of the namespaces in this scope.\n        RelDataType colType = scope.resolveColumn(id.names.get(0), id);\n        if (colType != null) {\n          type = colType;\n        }\n        ++i;\n      }\n      if (type == null) {\n        final SqlIdentifier last = id.getComponent(i - 1, i);\n        throw newValidationError(last,\n            RESOURCE.unknownIdentifier(last.toString()));\n      }\n      // Resolve rest of identifier\n      for (; i < id.names.size(); i++) {\n        String name = id.names.get(i);\n        final RelDataTypeField field;\n        if (name.equals(\"\")) {\n          // The wildcard \"*\" is represented as an empty name. It never\n          // resolves to a field.\n          name = \"*\";\n          field = null;\n        } else {\n          final SqlNameMatcher nameMatcher = catalogReader.nameMatcher();\n          field = nameMatcher.field(type, name);\n        }\n        if (field == null) {\n          throw newValidationError(id.getComponent(i),\n              RESOURCE.unknownField(name));\n        }\n        type = field.getType();\n      }\n      type =\n          SqlTypeUtil.addCharsetAndCollation(\n              type,\n              getTypeFactory());\n      return type;\n    }\n    public RelDataType visit(SqlDataTypeSpec dataType) {\n      // Q. How can a data type have a type?\n      // A. When it appears in an expression. (Say as the 2nd arg to the\n      //    CAST operator.)\n      validateDataType(dataType);\n      return dataType.deriveType(SqlValidatorImpl.this);\n    }\n    public RelDataType visit(SqlDynamicParam param) {\n      return unknownType;\n    }\n    public RelDataType visit(SqlIntervalQualifier intervalQualifier) {\n      return typeFactory.createSqlIntervalType(intervalQualifier);\n    }\n  }\n  /**\n   * Converts an expression into canonical form by fully-qualifying any\n   * identifiers.\n   */\n  private static class Expander extends SqlScopedShuttle {\n    protected final SqlValidatorImpl validator;\n    Expander(SqlValidatorImpl validator, SqlValidatorScope scope) {\n      super(scope);\n      this.validator = validator;\n    }\n<fim_suffix>    @Override public SqlNode visit(SqlIdentifier id) {\n      // First check for builtin functions which don't have\n      // parentheses, like \"LOCALTIME\".\n      SqlCall call =\n          SqlUtil.makeCall(\n              validator.getOperatorTable(),\n              id);\n      if (call != null) {\n        return call.accept(this);\n      }\n      final SqlIdentifier fqId = getScope().fullyQualify(id).identifier;\n      SqlNode expandedExpr = expandDynamicStar(id, fqId);\n      validator.setOriginal(expandedExpr, id);\n      return expandedExpr;\n    }<fim_middle>// function below has no smell\n"}