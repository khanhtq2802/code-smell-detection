{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.mapreduce.lib.output;\n\nimport java.io.IOException;\n\nimport org.apache.hadoop.classification.InterfaceAudience;\nimport org.apache.hadoop.classification.InterfaceStability;\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.mapreduce.Job;\nimport org.apache.hadoop.mapreduce.JobContext;\nimport org.apache.hadoop.mapreduce.OutputCommitter;\nimport org.apache.hadoop.mapreduce.OutputFormat;\nimport org.apache.hadoop.mapreduce.RecordWriter;\nimport org.apache.hadoop.mapreduce.TaskAttemptContext;\nimport org.apache.hadoop.util.ReflectionUtils;\n\n/**\n * A Convenience class that creates output lazily.\n * Use in conjuction with org.apache.hadoop.mapreduce.lib.output.MultipleOutputs to recreate the\n * behaviour of org.apache.hadoop.mapred.lib.MultipleTextOutputFormat (etc) of the old Hadoop API.\n * See {@link MultipleOutputs} documentation for more information.\n */\n<fim_suffix>@InterfaceAudience.Public\n@InterfaceStability.Stable\npublic class LazyOutputFormat <K,V> extends FilterOutputFormat<K, V> {\n  public static String OUTPUT_FORMAT = \n    \"mapreduce.output.lazyoutputformat.outputformat\";\n  /**\n   * Set the underlying output format for LazyOutputFormat.\n   * @param job the {@link Job} to modify\n   * @param theClass the underlying class\n   */\n  @SuppressWarnings(\"unchecked\")\n  public static void  setOutputFormatClass(Job job, \n                                     Class<? extends OutputFormat> theClass) {\n      job.setOutputFormatClass(LazyOutputFormat.class);\n      job.getConfiguration().setClass(OUTPUT_FORMAT, \n          theClass, OutputFormat.class);\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  private void getBaseOutputFormat(Configuration conf) \n  throws IOException {\n    baseOut =  ((OutputFormat<K, V>) ReflectionUtils.newInstance(\n      conf.getClass(OUTPUT_FORMAT, null), conf));\n    if (baseOut == null) {\n      throw new IOException(\"Output Format not set for LazyOutputFormat\");\n    }\n  }\n\n  @Override\n  public RecordWriter<K, V> getRecordWriter(TaskAttemptContext context)\n  throws IOException, InterruptedException {\n    if (baseOut == null) {\n      getBaseOutputFormat(context.getConfiguration());\n    }\n    return new LazyRecordWriter<K, V>(baseOut, context);\n  }\n  \n  @Override\n  public void checkOutputSpecs(JobContext context) \n  throws IOException, InterruptedException {\n    if (baseOut == null) {\n      getBaseOutputFormat(context.getConfiguration());\n    }\n   super.checkOutputSpecs(context);\n  }\n  \n  @Override\n  public OutputCommitter getOutputCommitter(TaskAttemptContext context) \n  throws IOException, InterruptedException {\n    if (baseOut == null) {\n      getBaseOutputFormat(context.getConfiguration());\n    }\n    return super.getOutputCommitter(context);\n  }\n  \n  /**\n   * A convenience class to be used with LazyOutputFormat\n   */\n  private static class LazyRecordWriter<K,V> extends FilterRecordWriter<K,V> {\n\n    final OutputFormat<K,V> outputFormat;\n    final TaskAttemptContext taskContext;\n\n    public LazyRecordWriter(OutputFormat<K,V> out, \n                            TaskAttemptContext taskContext)\n    throws IOException, InterruptedException {\n      this.outputFormat = out;\n      this.taskContext = taskContext;\n    }\n\n    @Override\n    public void write(K key, V value) throws IOException, InterruptedException {\n      if (rawWriter == null) {\n        rawWriter = outputFormat.getRecordWriter(taskContext);\n      }\n      rawWriter.write(key, value);\n    }\n\n    @Override\n    public void close(TaskAttemptContext context) \n    throws IOException, InterruptedException {\n      if (rawWriter != null) {\n        rawWriter.close(context);\n      }\n    }\n\n  }\n}<fim_middle>// class below has no smell\n"}