{"text": "<fim_prefix>\n<fim_suffix>final class ConnectionPool {\n    static final long KEEP_ALIVE = Utils.getIntegerNetProperty(\n            \"jdk.httpclient.keepalive.timeout\", 1200); // seconds\n    static final long MAX_POOL_SIZE = Utils.getIntegerNetProperty(\n            \"jdk.httpclient.connectionPoolSize\", 0); // unbounded\n    final Logger debug = Utils.getDebugLogger(this::dbgString, Utils.DEBUG);\n    // Pools of idle connections\n    private final HashMap<CacheKey,LinkedList<HttpConnection>> plainPool;\n    private final HashMap<CacheKey,LinkedList<HttpConnection>> sslPool;\n    private final ExpiryList expiryList;\n    private final String dbgTag; // used for debug\n    boolean stopped;\n    /**\n     * Entries in connection pool are keyed by destination address and/or\n     * proxy address:\n     * case 1: plain TCP not via proxy (destination only)\n     * case 2: plain TCP via proxy (proxy only)\n     * case 3: SSL not via proxy (destination only)\n     * case 4: SSL over tunnel (destination and proxy)\n     */\n    static class CacheKey {\n        final InetSocketAddress proxy;\n        final InetSocketAddress destination;\n        CacheKey(InetSocketAddress destination, InetSocketAddress proxy) {\n            this.proxy = proxy;\n            this.destination = destination;\n        }\n        @Override\n        public boolean equals(Object obj) {\n            if (obj == null) {\n                return false;\n            }\n            if (getClass() != obj.getClass()) {\n                return false;\n            }\n            final CacheKey other = (CacheKey) obj;\n            if (!Objects.equals(this.proxy, other.proxy)) {\n                return false;\n            }\n            if (!Objects.equals(this.destination, other.destination)) {\n                return false;\n            }\n            return true;\n        }\n        @Override\n        public int hashCode() {\n            return Objects.hash(proxy, destination);\n        }\n    }\n    ConnectionPool(long clientId) {\n        this(\"ConnectionPool(\"+clientId+\")\");\n    }\n    /**\n     * There should be one of these per HttpClient.\n     */\n    private ConnectionPool(String tag) {\n        dbgTag = tag;\n        plainPool = new HashMap<>();\n        sslPool = new HashMap<>();\n        expiryList = new ExpiryList();\n    }\n    final String dbgString() {\n        return dbgTag;\n    }\n    synchronized void start() {\n        assert !stopped : \"Already stopped\";\n    }\n    static CacheKey cacheKey(InetSocketAddress destination,\n                             InetSocketAddress proxy)\n    {\n        return new CacheKey(destination, proxy);\n    }\n    synchronized HttpConnection getConnection(boolean secure,\n                                              InetSocketAddress addr,\n                                              InetSocketAddress proxy) {\n        if (stopped) return null;\n        CacheKey key = new CacheKey(addr, proxy);\n        HttpConnection c = secure ? findConnection(key, sslPool)\n                                  : findConnection(key, plainPool);\n        //System.out.println (\"getConnection returning: \" + c);\n        return c;\n    }\n    /**\n     * Returns the connection to the pool.\n     */\n    void returnToPool(HttpConnection conn) {\n        returnToPool(conn, Instant.now(), KEEP_ALIVE);\n    }\n    // Called also by whitebox tests\n    void returnToPool(HttpConnection conn, Instant now, long keepAlive) {\n        // Don't call registerCleanupTrigger while holding a lock,\n        // but register it before the connection is added to the pool,\n        // since we don't want to trigger the cleanup if the connection\n        // is not in the pool.\n        CleanupTrigger cleanup = registerCleanupTrigger(conn);\n        // it's possible that cleanup may have been called.\n        HttpConnection toClose = null;\n        synchronized(this) {\n            if (cleanup.isDone()) {\n                return;\n            } else if (stopped) {\n                conn.close();\n                return;\n            }\n            if (MAX_POOL_SIZE > 0 && expiryList.size() >= MAX_POOL_SIZE) {\n                toClose = expiryList.removeOldest();\n                if (toClose != null) removeFromPool(toClose);\n            }\n            if (conn instanceof PlainHttpConnection) {\n                putConnection(conn, plainPool);\n            } else {\n                assert conn.isSecure();\n                putConnection(conn, sslPool);\n            }\n            expiryList.add(conn, now, keepAlive);\n        }\n        if (toClose != null) {\n            if (debug.on()) {\n                debug.log(\"Maximum pool size reached: removing oldest connection %s\",\n                          toClose.dbgString());\n            }\n            close(toClose);\n        }\n        //System.out.println(\"Return to pool: \" + conn);\n    }\n    private CleanupTrigger registerCleanupTrigger(HttpConnection conn) {\n        // Connect the connection flow to a pub/sub pair that will take the\n        // connection out of the pool and close it if anything happens\n        // while the connection is sitting in the pool.\n        CleanupTrigger cleanup = new CleanupTrigger(conn);\n        FlowTube flow = conn.getConnectionFlow();\n        if (debug.on()) debug.log(\"registering %s\", cleanup);\n        flow.connectFlows(cleanup, cleanup);\n        return cleanup;\n    }\n    private HttpConnection\n    findConnection(CacheKey key,\n                   HashMap<CacheKey,LinkedList<HttpConnection>> pool) {\n        LinkedList<HttpConnection> l = pool.get(key);\n        if (l == null || l.isEmpty()) {\n            return null;\n        } else {\n            HttpConnection c = l.removeFirst();\n            expiryList.remove(c);\n            return c;\n        }\n    }\n    /* called from cache cleaner only  */\n    private boolean\n    removeFromPool(HttpConnection c,\n                   HashMap<CacheKey,LinkedList<HttpConnection>> pool) {\n        //System.out.println(\"cacheCleaner removing: \" + c);\n        assert Thread.holdsLock(this);\n        CacheKey k = c.cacheKey();\n        List<HttpConnection> l = pool.get(k);\n        if (l == null || l.isEmpty()) {\n            pool.remove(k);\n            return false;\n        }\n        return l.remove(c);\n    }\n    private void\n    putConnection(HttpConnection c,\n                  HashMap<CacheKey,LinkedList<HttpConnection>> pool) {\n        CacheKey key = c.cacheKey();\n        LinkedList<HttpConnection> l = pool.get(key);\n        if (l == null) {\n            l = new LinkedList<>();\n            pool.put(key, l);\n        }\n        l.add(c);\n    }\n    /**\n     * Purge expired connection and return the number of milliseconds\n     * in which the next connection is scheduled to expire.\n     * If no connections are scheduled to be purged return 0.\n     * @return the delay in milliseconds in which the next connection will\n     *         expire.\n     */\n    long purgeExpiredConnectionsAndReturnNextDeadline() {\n        if (!expiryList.purgeMaybeRequired()) return 0;\n        return purgeExpiredConnectionsAndReturnNextDeadline(Instant.now());\n    }\n    // Used for whitebox testing\n    long purgeExpiredConnectionsAndReturnNextDeadline(Instant now) {\n        long nextPurge = 0;\n        // We may be in the process of adding new elements\n        // to the expiry list - but those elements will not\n        // have outlast their keep alive timer yet since we're\n        // just adding them.\n        if (!expiryList.purgeMaybeRequired()) return nextPurge;\n        List<HttpConnection> closelist;\n        synchronized (this) {\n            closelist = expiryList.purgeUntil(now);\n            for (HttpConnection c : closelist) {\n                if (c instanceof PlainHttpConnection) {\n                    boolean wasPresent = removeFromPool(c, plainPool);\n                    assert wasPresent;\n                } else {\n                    boolean wasPresent = removeFromPool(c, sslPool);\n                    assert wasPresent;\n                }\n            }\n            nextPurge = now.until(\n                    expiryList.nextExpiryDeadline().orElse(now),\n                    ChronoUnit.MILLIS);\n        }\n        closelist.forEach(this::close);\n        return nextPurge;\n    }\n    private void close(HttpConnection c) {\n        try {\n            c.close();\n        } catch (Throwable e) {} // ignore\n    }\n    void stop() {\n        List<HttpConnection> closelist = Collections.emptyList();\n        try {\n            synchronized (this) {\n                stopped = true;\n                closelist = expiryList.stream()\n                    .map(e -> e.connection)\n                    .collect(Collectors.toList());\n                expiryList.clear();\n                plainPool.clear();\n                sslPool.clear();\n            }\n        } finally {\n            closelist.forEach(this::close);\n        }\n    }\n    static final class ExpiryEntry {\n        final HttpConnection connection;\n        final Instant expiry; // absolute time in seconds of expiry time\n        ExpiryEntry(HttpConnection connection, Instant expiry) {\n            this.connection = connection;\n            this.expiry = expiry;\n        }\n    }\n    /**\n     * Manages a LinkedList of sorted ExpiryEntry. The entry with the closer\n     * deadline is at the tail of the list, and the entry with the farther\n     * deadline is at the head. In the most common situation, new elements\n     * will need to be added at the head (or close to it), and expired elements<fim_middle>// class below has no smell\n"}