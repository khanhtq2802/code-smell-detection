{"text": "<fim_prefix>package org.springframework.roo.project;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Collection;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.commons.lang3.Validate;\nimport org.apache.felix.scr.annotations.Component;\nimport org.apache.felix.scr.annotations.Reference;\nimport org.apache.felix.scr.annotations.Service;\nimport org.springframework.roo.file.monitor.event.FileDetails;\nimport org.springframework.roo.model.JavaType;\nimport org.springframework.roo.project.maven.Pom;\nimport org.springframework.roo.support.util.FileUtils;\n\n@Component\n@Service\npublic class MavenPathResolvingStrategy extends AbstractPathResolvingStrategy {\n\n  @Reference\n  protected PomManagementService pomManagementService;\n\n  /**\n   * Locates the first {@link PhysicalPath} which can be construed as a parent\n   * of the presented identifier.\n   *\n   * @param identifier to locate the parent of (required)\n   * @return the first matching parent, or null if not found\n   */\n  @Override\n  protected PhysicalPath getApplicablePhysicalPath(final String identifier) {\n    Validate.notNull(identifier, \"Identifier required\");\n    PhysicalPath physicalPath = null;\n    int longest = 0;\n    for (final Pom pom : pomManagementService.getPoms()) {\n      if (removeTrailingSeparator(identifier).startsWith(removeTrailingSeparator(pom.getRoot()))\n          && removeTrailingSeparator(pom.getRoot()).length() > longest) {\n        longest = removeTrailingSeparator(pom.getRoot()).length();\n        int nextLongest = 0;\n        for (final PhysicalPath thisPhysicalPath : pom.getPhysicalPaths()) {\n          String possibleParent =\n              new FileDetails(thisPhysicalPath.getLocation(), null).getCanonicalPath();\n          if (!possibleParent.endsWith(File.separator)) {\n            possibleParent = possibleParent.concat(File.separator);\n          }\n          if (removeTrailingSeparator(identifier).startsWith(possibleParent)\n              && possibleParent.length() > nextLongest) {\n            nextLongest = possibleParent.length();\n            physicalPath = thisPhysicalPath;\n          }\n        }\n      }\n    }\n    return physicalPath;\n  }\n\n  public String getCanonicalPath(final LogicalPath path, final JavaType javaType) {\n    return getIdentifier(path, javaType.getRelativeFileName());\n  }\n\n  public String getCanonicalPath(final String moduleName, final Path path, final JavaType javaType) {\n    Validate.notNull(moduleName, \"Module name is null\");\n    return getCanonicalPath(path.getModulePathId(moduleName), javaType);\n  }\n\n  public String getFocusedCanonicalPath(final Path path, final JavaType javaType) {\n    return getCanonicalPath(pomManagementService.getFocusedModuleName(), path, javaType);\n  }\n\n  public String getFocusedIdentifier(final Path path, final String relativePath) {\n    return getIdentifier(\n        LogicalPath.getInstance(path, pomManagementService.getFocusedModuleName()), relativePath);\n  }\n\n  public LogicalPath getFocusedPath(final Path path) {\n    final PhysicalPath physicalPath = pomManagementService.getFocusedModule().getPhysicalPath(path);\n    Validate.notNull(physicalPath, \"Physical path for '%s' not found\", path.name());\n    return physicalPath.getLogicalPath();\n  }\n\n  public String getFocusedRoot(final Path path) {\n    return pomManagementService.getFocusedModule().getPathLocation(path);\n  }\n\n  public String getIdentifier(final LogicalPath logicalPath, final String relativePath) {\n    Validate.notNull(logicalPath, \"Path required\");\n    Validate.notNull(relativePath, \"Relative path cannot be null, although it can be empty\");\n\n    String initialPath = FileUtils.getCanonicalPath(getPath(logicalPath));\n    initialPath = FileUtils.ensureTrailingSeparator(initialPath);\n    return initialPath + StringUtils.strip(relativePath, File.separator);\n  }\n\n  public String getIdentifier(final String moduleName, final Path path, final String relativePath) {\n    return getIdentifier(LogicalPath.getInstance(path, moduleName), relativePath);\n  }\n\n  private File getModuleRoot(final String module, final Pom pom) {\n    if (pom == null) {\n      // No POM exists for this module; we must be creating it\n      return new File(pomManagementService.getFocusedModule().getRoot(), module);\n    }\n    // This is a known module; use its known root path\n    return new File(pom.getRoot());\n  }\n\n  public LogicalPath getPath(final String moduleName, final Path path) {\n    Validate.notNull(moduleName, \"ModuleName required\");\n\n    final PhysicalPath physicalPath =\n        pomManagementService.getPomFromModuleName(moduleName).getPhysicalPath(path);\n    Validate.notNull(physicalPath, \"Physical path for '%s' not found\", path.name());\n    return physicalPath.getLogicalPath();\n  }\n\n\n<fim_suffix>  private File getPath(final LogicalPath logicalPath) {\n    final Pom pom = pomManagementService.getPomFromModuleName(logicalPath.getModule());\n    final File moduleRoot = getModuleRoot(logicalPath.getModule(), pom);\n    final String pathRelativeToPom = logicalPath.getPathRelativeToPom(pom);\n    return new File(moduleRoot, pathRelativeToPom);\n  }\n\n  @Override\n  protected Collection<LogicalPath> getPaths(final boolean sourceOnly) {\n    final Collection<LogicalPath> pathIds = new ArrayList<LogicalPath>();\n    for (final Pom pom : pomManagementService.getPoms()) {\n      for (final PhysicalPath modulePath : pom.getPhysicalPaths()) {\n        if (!sourceOnly || modulePath.isSource()) {\n          pathIds.add(modulePath.getLogicalPath());\n        }\n      }\n    }\n    return pathIds;\n  }\n\n  public String getRoot(final LogicalPath modulePathId) {\n    final Pom pom = pomManagementService.getPomFromModuleName(modulePathId.getModule());\n    return pom.getPhysicalPath(modulePathId.getPath()).getLocationPath();\n  }\n\n  public boolean isActive() {\n    return pomManagementService.getRootPom() != null;\n  }\n\n  private String removeTrailingSeparator(final String pomPath) {\n    if (pomPath.endsWith(File.separator)) {\n      return pomPath.substring(0, pomPath.length() - 1);\n    }\n    return pomPath + File.separator;\n  }\n}<fim_middle>// function below has no smell\n"}