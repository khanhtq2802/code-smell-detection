{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.ambari.server.controller.metrics.timeline.cache;\n\nimport org.apache.ambari.server.configuration.Configuration;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.google.inject.Inject;\nimport com.google.inject.Singleton;\n\nimport net.sf.ehcache.Cache;\nimport net.sf.ehcache.CacheManager;\nimport net.sf.ehcache.config.CacheConfiguration;\nimport net.sf.ehcache.config.PersistenceConfiguration;\nimport net.sf.ehcache.config.PersistenceConfiguration.Strategy;\nimport net.sf.ehcache.config.SizeOfPolicyConfiguration;\nimport net.sf.ehcache.config.SizeOfPolicyConfiguration.MaxDepthExceededBehavior;\nimport net.sf.ehcache.store.MemoryStoreEvictionPolicy;\n\n/**\n * Cache implementation that provides ability to perform incremental reads\n * from Metrics backend and reduce the amount of calls between Ambari and the\n * Metrics backend.\n */\n<fim_suffix>@Singleton\npublic class TimelineMetricCacheProvider {\n  private TimelineMetricCache timelineMetricsCache;\n  private volatile boolean isCacheInitialized = false;\n  public static final String TIMELINE_METRIC_CACHE_MANAGER_NAME = \"timelineMetricCacheManager\";\n  public static final String TIMELINE_METRIC_CACHE_INSTANCE_NAME = \"timelineMetricCache\";\n\n  Configuration configuration;\n  TimelineMetricCacheEntryFactory cacheEntryFactory;\n\n  private final static Logger LOG = LoggerFactory.getLogger(TimelineMetricCacheProvider.class);\n\n  @Inject\n  public TimelineMetricCacheProvider(Configuration configuration,\n                                     TimelineMetricCacheEntryFactory cacheEntryFactory) {\n    this.configuration = configuration;\n    this.cacheEntryFactory = cacheEntryFactory;\n  }\n\n  private synchronized void initializeCache() {\n    // Check in case of contention to avoid ObjectExistsException\n    if (isCacheInitialized) {\n      return;\n    }\n\n    System.setProperty(\"net.sf.ehcache.skipUpdateCheck\", \"true\");\n    if (configuration.useMetricsCacheCustomSizingEngine()) {\n      // Use custom sizing engine to speed cache sizing calculations\n      System.setProperty(\"net.sf.ehcache.sizeofengine.\" + TIMELINE_METRIC_CACHE_MANAGER_NAME,\n        \"org.apache.ambari.server.controller.metrics.timeline.cache.TimelineMetricsCacheSizeOfEngine\");\n    }\n\n    net.sf.ehcache.config.Configuration managerConfig =\n      new net.sf.ehcache.config.Configuration();\n    managerConfig.setName(TIMELINE_METRIC_CACHE_MANAGER_NAME);\n\n    // Set max heap available to the cache manager\n    managerConfig.setMaxBytesLocalHeap(configuration.getMetricsCacheManagerHeapPercent());\n\n    //Create a singleton CacheManager using defaults\n    CacheManager manager = CacheManager.create(managerConfig);\n\n    LOG.info(\"Creating Metrics Cache with timeouts => ttl = \" +\n      configuration.getMetricCacheTTLSeconds() + \", idle = \" +\n      configuration.getMetricCacheIdleSeconds());\n\n    // Create a Cache specifying its configuration.\n    CacheConfiguration cacheConfiguration = createCacheConfiguration();\n    Cache cache = new Cache(cacheConfiguration);\n\n    // Decorate with UpdatingSelfPopulatingCache\n    timelineMetricsCache = new TimelineMetricCache(cache, cacheEntryFactory);\n\n    LOG.info(\"Registering metrics cache with provider: name = \" +\n      cache.getName() + \", guid: \" + cache.getGuid());\n\n    manager.addCache(timelineMetricsCache);\n\n    isCacheInitialized = true;\n  }\n\n  // Having this as a separate public method for testing/mocking purposes\n  public CacheConfiguration createCacheConfiguration() {\n\n    CacheConfiguration cacheConfiguration = new CacheConfiguration()\n      .name(TIMELINE_METRIC_CACHE_INSTANCE_NAME)\n      .timeToLiveSeconds(configuration.getMetricCacheTTLSeconds()) // 1 hour\n      .timeToIdleSeconds(configuration.getMetricCacheIdleSeconds()) // 5 minutes\n      .memoryStoreEvictionPolicy(MemoryStoreEvictionPolicy.LRU)\n      .sizeOfPolicy(new SizeOfPolicyConfiguration() // Set sizeOf policy to continue on max depth reached - avoid OOM\n        .maxDepth(10000)\n        .maxDepthExceededBehavior(MaxDepthExceededBehavior.CONTINUE))\n      .eternal(false)\n      .persistence(new PersistenceConfiguration()\n        .strategy(Strategy.NONE.name()));\n\n    return cacheConfiguration;\n  }\n\n  /**\n   * Return an instance of a Ehcache\n   * @return @TimelineMetricCache or null if caching is disabled through config.\n   */\n  public TimelineMetricCache getTimelineMetricsCache() {\n    if (configuration.isMetricsCacheDisabled()) {\n      return null;\n    }\n\n    if (!isCacheInitialized) {\n      initializeCache();\n    }\n    return timelineMetricsCache;\n  }\n\n}<fim_middle>// class below has no smell\n"}