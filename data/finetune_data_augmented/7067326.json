{"text": "<fim_prefix>/*\n * Copyright (C) 2014 Square, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage okio;\n\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.nio.charset.Charset;\n\n<fim_suffix>final class RealBufferedSink implements BufferedSink {\n  public final Buffer buffer;\n  public final Sink sink;\n  private boolean closed;\n\n  public RealBufferedSink(Sink sink, Buffer buffer) {\n    if (sink == null) throw new IllegalArgumentException(\"sink == null\");\n    this.buffer = buffer;\n    this.sink = sink;\n  }\n\n  public RealBufferedSink(Sink sink) {\n    this(sink, new Buffer());\n  }\n\n  @Override public Buffer buffer() {\n    return buffer;\n  }\n\n  @Override public void write(Buffer source, long byteCount)\n      throws IOException {\n    if (closed) throw new IllegalStateException(\"closed\");\n    buffer.write(source, byteCount);\n    emitCompleteSegments();\n  }\n\n  @Override public BufferedSink write(ByteString byteString) throws IOException {\n    if (closed) throw new IllegalStateException(\"closed\");\n    buffer.write(byteString);\n    return emitCompleteSegments();\n  }\n\n  @Override public BufferedSink writeUtf8(String string) throws IOException {\n    if (closed) throw new IllegalStateException(\"closed\");\n    buffer.writeUtf8(string);\n    return emitCompleteSegments();\n  }\n\n  @Override public BufferedSink writeUtf8(String string, int beginIndex, int endIndex)\n      throws IOException {\n    if (closed) throw new IllegalStateException(\"closed\");\n    buffer.writeUtf8(string, beginIndex, endIndex);\n    return emitCompleteSegments();\n  }\n\n  @Override public BufferedSink writeUtf8CodePoint(int codePoint) throws IOException {\n    if (closed) throw new IllegalStateException(\"closed\");\n    buffer.writeUtf8CodePoint(codePoint);\n    return emitCompleteSegments();\n  }\n\n  @Override public BufferedSink writeString(String string, Charset charset) throws IOException {\n    if (closed) throw new IllegalStateException(\"closed\");\n    buffer.writeString(string, charset);\n    return emitCompleteSegments();\n  }\n\n  @Override public BufferedSink writeString(String string, int beginIndex, int endIndex,\n      Charset charset) throws IOException {\n    if (closed) throw new IllegalStateException(\"closed\");\n    buffer.writeString(string, beginIndex, endIndex, charset);\n    return emitCompleteSegments();\n  }\n\n  @Override public BufferedSink write(byte[] source) throws IOException {\n    if (closed) throw new IllegalStateException(\"closed\");\n    buffer.write(source);\n    return emitCompleteSegments();\n  }\n\n  @Override public BufferedSink write(byte[] source, int offset, int byteCount) throws IOException {\n    if (closed) throw new IllegalStateException(\"closed\");\n    buffer.write(source, offset, byteCount);\n    return emitCompleteSegments();\n  }\n\n  @Override public long writeAll(Source source) throws IOException {\n    if (source == null) throw new IllegalArgumentException(\"source == null\");\n    long totalBytesRead = 0;\n    for (long readCount; (readCount = source.read(buffer, Segment.SIZE)) != -1; ) {\n      totalBytesRead += readCount;\n      emitCompleteSegments();\n    }\n    return totalBytesRead;\n  }\n\n  @Override public BufferedSink write(Source source, long byteCount) throws IOException {\n    while (byteCount > 0) {\n      long read = source.read(buffer, byteCount);\n      if (read == -1) throw new EOFException();\n      byteCount -= read;\n      emitCompleteSegments();\n    }\n    return this;\n  }\n\n  @Override public BufferedSink writeByte(int b) throws IOException {\n    if (closed) throw new IllegalStateException(\"closed\");\n    buffer.writeByte(b);\n    return emitCompleteSegments();\n  }\n\n  @Override public BufferedSink writeShort(int s) throws IOException {\n    if (closed) throw new IllegalStateException(\"closed\");\n    buffer.writeShort(s);\n    return emitCompleteSegments();\n  }\n\n  @Override public BufferedSink writeShortLe(int s) throws IOException {\n    if (closed) throw new IllegalStateException(\"closed\");\n    buffer.writeShortLe(s);\n    return emitCompleteSegments();\n  }\n\n  @Override public BufferedSink writeInt(int i) throws IOException {\n    if (closed) throw new IllegalStateException(\"closed\");\n    buffer.writeInt(i);\n    return emitCompleteSegments();\n  }\n\n  @Override public BufferedSink writeIntLe(int i) throws IOException {\n    if (closed) throw new IllegalStateException(\"closed\");\n    buffer.writeIntLe(i);\n    return emitCompleteSegments();\n  }\n\n  @Override public BufferedSink writeLong(long v) throws IOException {\n    if (closed) throw new IllegalStateException(\"closed\");\n    buffer.writeLong(v);\n    return emitCompleteSegments();\n  }\n\n  @Override public BufferedSink writeLongLe(long v) throws IOException {\n    if (closed) throw new IllegalStateException(\"closed\");\n    buffer.writeLongLe(v);\n    return emitCompleteSegments();\n  }\n\n  @Override public BufferedSink writeDecimalLong(long v) throws IOException {\n    if (closed) throw new IllegalStateException(\"closed\");\n    buffer.writeDecimalLong(v);\n    return emitCompleteSegments();\n  }\n\n  @Override public BufferedSink writeHexadecimalUnsignedLong(long v) throws IOException {\n    if (closed) throw new IllegalStateException(\"closed\");\n    buffer.writeHexadecimalUnsignedLong(v);\n    return emitCompleteSegments();\n  }\n\n  @Override public BufferedSink emitCompleteSegments() throws IOException {\n    if (closed) throw new IllegalStateException(\"closed\");\n    long byteCount = buffer.completeSegmentByteCount();\n    if (byteCount > 0) sink.write(buffer, byteCount);\n    return this;\n  }\n\n  @Override public BufferedSink emit() throws IOException {\n    if (closed) throw new IllegalStateException(\"closed\");\n    long byteCount = buffer.size();\n    if (byteCount > 0) sink.write(buffer, byteCount);\n    return this;\n  }\n\n  @Override public OutputStream outputStream() {\n    return new OutputStream() {\n      @Override public void write(int b) throws IOException {\n        if (closed) throw new IOException(\"closed\");\n        buffer.writeByte((byte) b);\n        emitCompleteSegments();\n      }\n\n      @Override public void write(byte[] data, int offset, int byteCount) throws IOException {\n        if (closed) throw new IOException(\"closed\");\n        buffer.write(data, offset, byteCount);\n        emitCompleteSegments();\n      }\n\n      @Override public void flush() throws IOException {\n        // For backwards compatibility, a flush() on a closed stream is a no-op.\n        if (!closed) {\n          RealBufferedSink.this.flush();\n        }\n      }\n\n      @Override public void close() throws IOException {\n        RealBufferedSink.this.close();\n      }\n\n      @Override public String toString() {\n        return RealBufferedSink.this + \".outputStream()\";\n      }\n    };\n  }\n\n  @Override public void flush() throws IOException {\n    if (closed) throw new IllegalStateException(\"closed\");\n    if (buffer.size > 0) {\n      sink.write(buffer, buffer.size);\n    }\n    sink.flush();\n  }\n\n  @Override public void close() throws IOException {\n    if (closed) return;\n\n    // Emit buffered data to the underlying sink. If this fails, we still need\n    // to close the sink; otherwise we risk leaking resources.\n    Throwable thrown = null;\n    try {\n      if (buffer.size > 0) {\n        sink.write(buffer, buffer.size);\n      }\n    } catch (Throwable e) {\n      thrown = e;\n    }\n\n    try {\n      sink.close();\n    } catch (Throwable e) {\n      if (thrown == null) thrown = e;\n    }\n    closed = true;\n\n    if (thrown != null) Util.sneakyRethrow(thrown);\n  }\n\n  @Override public Timeout timeout() {\n    return sink.timeout();\n  }\n\n  @Override public String toString() {\n    return \"buffer(\" + sink + \")\";\n  }\n}<fim_middle>// class below has no smell\n"}