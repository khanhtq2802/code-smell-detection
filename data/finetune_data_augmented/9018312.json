{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.solr.search.facet;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.function.IntFunction;\nimport org.apache.lucene.index.LeafReaderContext;\nimport org.apache.lucene.index.MultiDocValues;\nimport org.apache.lucene.index.OrdinalMap;\nimport org.apache.lucene.index.SortedDocValues;\nimport org.apache.lucene.queries.function.ValueSource;\nimport org.apache.lucene.util.BytesRef;\nimport org.apache.lucene.util.FixedBitSet;\nimport org.apache.lucene.util.LongValues;\nimport org.apache.solr.common.SolrException;\nimport org.apache.solr.schema.SchemaField;\nimport org.apache.solr.schema.StrFieldSource;\nimport org.apache.solr.search.function.FieldNameValueSource;\npublic class MinMaxAgg extends SimpleAggValueSource {\n  final int minmax; // a multiplier to reverse the normal order of compare if this is max instead of min (i.e. max will be -1)\n  public MinMaxAgg(String minOrMax, ValueSource vs) {\n    super(minOrMax, vs);\n    minmax = \"min\".equals(name) ? 1 : -1;\n  }\n  @Override\n  public SlotAcc createSlotAcc(FacetContext fcontext, int numDocs, int numSlots) throws IOException {\n    ValueSource vs = getArg();\n    SchemaField sf = null;\n    if (vs instanceof FieldNameValueSource) {\n      String field = ((FieldNameValueSource)vs).getFieldName();\n      sf = fcontext.qcontext.searcher().getSchema().getField(field);\n      if (sf.multiValued() || sf.getType().multiValuedFieldCache()) {\n        vs = null;\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"min/max aggregations can't be used on multi-valued field \" + field);\n      } else {\n        vs = sf.getType().getValueSource(sf, null);\n      }\n    }\n    if (vs instanceof StrFieldSource) {\n      return new SingleValuedOrdAcc(fcontext, sf, numSlots);\n    }\n    // Since functions don't currently have types, we rely on the type of the field\n    if (sf != null && sf.getType().getNumberType() != null) {\n      switch (sf.getType().getNumberType()) {\n        case FLOAT:\n        case DOUBLE:\n          return new DFuncAcc(vs, fcontext, numSlots);\n        case INTEGER:\n        case LONG:\n          return new LFuncAcc(vs, fcontext, numSlots);\n        case DATE:\n          return new DateFuncAcc(vs, fcontext, numSlots);\n      }\n    }\n    // numeric functions\n    return new DFuncAcc(vs, fcontext, numSlots);\n  }\n  @Override\n  public FacetMerger createFacetMerger(Object prototype) {\n    if (prototype instanceof Double)\n      return new NumericMerger(); // still use NumericMerger to handle NaN?\n    else if (prototype instanceof Comparable) {\n      return new ComparableMerger();\n    } else {\n      throw new UnsupportedOperationException(\"min/max merge of \" + prototype);\n    }\n  }\n  // TODO: can this be replaced by ComparableMerger?\n  private class NumericMerger extends FacetDoubleMerger {\n    double val = Double.NaN;\n    @Override\n    public void merge(Object facetResult, Context mcontext) {\n      double result = ((Number)facetResult).doubleValue();\n      if (Double.compare(result, val)*minmax < 0 || Double.isNaN(val)) {\n        val = result;\n      }\n    }\n    @Override\n    protected double getDouble() {\n      return val;\n    }\n  }\n<fim_suffix>  private class ComparableMerger extends FacetSortableMerger {\n    Comparable val;\n    @Override\n    public void merge(Object facetResult, Context mcontext) {\n      Comparable other = (Comparable)facetResult;\n      if (val == null) {\n        val = other;\n      } else {\n        if ( other.compareTo(val) * minmax < 0 ) {\n          val = other;\n        }\n      }\n    }\n    @Override\n    public Object getMergedResult() {\n      return val;\n    }\n    @Override\n    public int compareTo(FacetSortableMerger other, FacetRequest.SortDirection direction) {\n      // NOTE: we don't use the minmax multiplier here because we still want natural ordering between slots (i.e. min(field) asc and max(field) asc) both sort \"A\" before \"Z\")\n      return this.val.compareTo(((ComparableMerger)other).val);\n    }\n  }\n  class DFuncAcc extends DoubleFuncSlotAcc {\n    public DFuncAcc(ValueSource values, FacetContext fcontext, int numSlots) {\n      super(values, fcontext, numSlots, Double.NaN);\n    }\n    @Override\n    public void collect(int doc, int slotNum, IntFunction<SlotContext> slotContext) throws IOException {\n      double val = values.doubleVal(doc);\n      if (val == 0 && !values.exists(doc)) return; // depend on fact that non existing values return 0 for func query\n      double currVal = result[slotNum];\n      if (Double.compare(val, currVal) * minmax < 0 || Double.isNaN(currVal)) {\n        result[slotNum] = val;\n      }\n    }\n    @Override\n    public Object getValue(int slot) {\n      double val = result[slot];\n      if (Double.isNaN(val)) {\n        return null;\n      } else {\n        return val;\n      }\n    }\n  }\n  class LFuncAcc extends LongFuncSlotAcc {\n    FixedBitSet exists;\n    public LFuncAcc(ValueSource values, FacetContext fcontext, int numSlots) {\n      super(values, fcontext, numSlots, 0);\n      exists = new FixedBitSet(numSlots);\n    }\n    @Override\n    public void collect(int doc, int slotNum, IntFunction<SlotContext> slotContext) throws IOException {\n      long val = values.longVal(doc);\n      if (val == 0 && !values.exists(doc)) return; // depend on fact that non existing values return 0 for func query\n      long currVal = result[slotNum];\n      if (currVal == 0 && !exists.get(slotNum)) {\n        exists.set(slotNum);\n        result[slotNum] = val;\n      } else if (Long.compare(val, currVal) * minmax < 0) {\n        result[slotNum] =  val;\n      }\n    }\n    @Override\n    public Object getValue(int slot) {\n      long val = result[slot];\n      if (val == 0 && !exists.get(slot)) {\n        return null;\n      } else {\n        return val;\n      }\n    }\n    @Override\n    public void resize(Resizer resizer) {\n      super.resize(resizer);\n      exists = resizer.resize(exists);\n    }\n    @Override\n    public int compare(int slotA, int slotB) {\n      long a = result[slotA];\n      long b = result[slotB];\n      boolean ea = a != 0 || exists.get(slotA);\n      boolean eb = b != 0 || exists.get(slotB);\n      if (ea != eb) {\n        if (ea) return 1;  // a exists and b doesn't TODO: we need context to be able to sort missing last!  SOLR-10618\n        if (eb) return -1; // b exists and a is missing\n      }\n      return Long.compare(a, b);\n    }\n    @Override\n    public void reset() {\n      super.reset();\n      exists.clear(0, exists.length());\n    }\n  }\n  class DateFuncAcc extends LongFuncSlotAcc {\n    private static final long MISSING = Long.MIN_VALUE;\n    public DateFuncAcc(ValueSource values, FacetContext fcontext, int numSlots) {\n      super(values, fcontext, numSlots, MISSING);\n    }\n    @Override\n    public void collect(int doc, int slotNum, IntFunction<SlotContext> slotContext) throws IOException {\n      long val = values.longVal(doc);\n      if (val == 0 && !values.exists(doc)) return; // depend on fact that non existing values return 0 for func query<fim_middle>// class below has no smell\n"}