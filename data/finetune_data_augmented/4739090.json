{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage hivemall.utils.lang;\nimport hivemall.math.random.PRNG;\nimport java.lang.reflect.Array;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Random;\nimport javax.annotation.Nonnegative;\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\nimport org.apache.commons.math3.distribution.GammaDistribution;\npublic final class ArrayUtils {\n    /**\n     * The index value when an element is not found in a list or array: <code>-1</code>. This value\n     * is returned by methods in this class and can also be used in comparisons with values returned\n     * by various method from {@link java.util.List}.\n     */\n    public static final int INDEX_NOT_FOUND = -1;\n    private ArrayUtils() {}\n<fim_suffix>    @Nonnull\n    public static double[] set(@Nonnull double[] src, final int index, final double value) {\n        if (index >= src.length) {\n            src = Arrays.copyOf(src, src.length * 2);\n        }\n        src[index] = value;\n        return src;\n    }\n    @Nonnull\n    public static <T> T[] set(@Nonnull T[] src, final int index, final T value) {\n        if (index >= src.length) {\n            src = Arrays.copyOf(src, src.length * 2);\n        }\n        src[index] = value;\n        return src;\n    }\n    @Nonnull\n    public static float[] toArray(@Nonnull final List<Float> lst) {\n        final int ndim = lst.size();\n        final float[] ary = new float[ndim];\n        int i = 0;\n        for (float f : lst) {\n            ary[i++] = f;\n        }\n        return ary;\n    }\n    @Nonnull\n    public static Integer[] toObject(@Nonnull final int[] array) {\n        final Integer[] result = new Integer[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i];\n        }\n        return result;\n    }\n    @Nonnull\n    public static List<Integer> toList(@Nonnull final int[] array) {\n        Integer[] v = toObject(array);\n        return Arrays.asList(v);\n    }\n    @Nonnull\n    public static Long[] toObject(@Nonnull final long[] array) {\n        final Long[] result = new Long[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i];\n        }\n        return result;\n    }\n    @Nonnull\n    public static List<Long> toList(@Nonnull final long[] array) {\n        Long[] v = toObject(array);\n        return Arrays.asList(v);\n    }\n    @Nonnull\n    public static Float[] toObject(@Nonnull final float[] array) {\n        final Float[] result = new Float[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i];\n        }\n        return result;\n    }\n    @Nonnull\n    public static List<Float> toList(@Nonnull final float[] array) {\n        Float[] v = toObject(array);\n        return Arrays.asList(v);\n    }\n    @Nonnull\n    public static Double[] toObject(@Nonnull final double[] array) {\n        final Double[] result = new Double[array.length];\n        for (int i = 0; i < array.length; i++) {\n            result[i] = array[i];\n        }\n        return result;\n    }\n    @Nonnull\n    public static List<Double> toList(@Nonnull final double[] array) {\n        Double[] v = toObject(array);\n        return Arrays.asList(v);\n    }\n    public static <T> void shuffle(@Nonnull final T[] array) {\n        shuffle(array, array.length);\n    }\n    public static <T> void shuffle(@Nonnull final T[] array, final Random rnd) {\n        shuffle(array, array.length, rnd);\n    }\n    public static <T> void shuffle(@Nonnull final T[] array, final int size) {\n        Random rnd = new Random();\n        shuffle(array, size, rnd);\n    }\n    /**\n     * Fisher\u2013Yates shuffle\n     * \n     * @link http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle\n     */\n    public static <T> void shuffle(@Nonnull final T[] array, final int size,\n            @Nonnull final Random rnd) {\n        for (int i = size; i > 1; i--) {\n            int randomPosition = rnd.nextInt(i);\n            swap(array, i - 1, randomPosition);\n        }\n    }\n    public static void shuffle(@Nonnull final int[] array, @Nonnull final Random rnd) {\n        for (int i = array.length; i > 1; i--) {\n            int randomPosition = rnd.nextInt(i);\n            swap(array, i - 1, randomPosition);\n        }\n    }\n    public static void swap(@Nonnull final Object[] arr, final int i, final int j) {\n        Object tmp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = tmp;\n    }\n    public static void swap(@Nonnull final int[] arr, final int i, final int j) {\n        int tmp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = tmp;\n    }\n    public static void swap(@Nonnull final long[] arr, final int i, final int j) {\n        long tmp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = tmp;\n    }\n    public static void swap(@Nonnull final float[] arr, final int i, final int j) {\n        float tmp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = tmp;\n    }\n    public static void swap(@Nonnull final double[] arr, final int i, final int j) {\n        double tmp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = tmp;\n    }\n    @Nullable\n    public static Object[] subarray(@Nullable final Object[] array, int startIndexInclusive,\n            int endIndexExclusive) {\n        if (array == null) {\n            return null;\n        }\n        if (startIndexInclusive < 0) {\n            startIndexInclusive = 0;\n        }\n        if (endIndexExclusive > array.length) {\n            endIndexExclusive = array.length;\n        }\n        int newSize = endIndexExclusive - startIndexInclusive;\n        Class<?> type = array.getClass().getComponentType();\n        if (newSize <= 0) {\n            return (Object[]) Array.newInstance(type, 0);\n        }\n        Object[] subarray = (Object[]) Array.newInstance(type, newSize);\n        System.arraycopy(array, startIndexInclusive, subarray, 0, newSize);\n        return subarray;\n    }\n    public static void fill(@Nonnull final float[] a, @Nonnull final Random rand) {\n        for (int i = 0, len = a.length; i < len; i++) {\n            a[i] = rand.nextFloat();\n        }\n    }\n    public static int indexOf(@Nullable final int[] array, final int valueToFind,\n            final int startIndex, final int endIndex) {\n        if (array == null) {\n            return INDEX_NOT_FOUND;\n        }\n        final int til = Math.min(endIndex, array.length);\n        if (startIndex < 0 || startIndex > til) {\n            throw new IllegalArgumentException(\"Illegal startIndex: \" + startIndex);\n        }\n        for (int i = startIndex; i < til; i++) {\n            if (valueToFind == array[i]) {\n                return i;\n            }\n        }\n        return INDEX_NOT_FOUND;\n    }\n    public static int lastIndexOf(@Nullable final int[] array, final int valueToFind,\n            int startIndex) {\n        if (array == null) {\n            return INDEX_NOT_FOUND;\n        }\n        return lastIndexOf(array, valueToFind, startIndex, array.length);\n    }\n    /**\n     * @param startIndex inclusive start index\n     * @param endIndex exclusive end index\n     */\n    public static int lastIndexOf(@Nullable final int[] array, final int valueToFind,\n            int startIndex, int endIndex) {<fim_middle>// function below has no smell\n"}