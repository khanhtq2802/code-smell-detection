{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache license, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the license for the specific language governing permissions and\n * limitations under the license.\n */\npackage org.apache.logging.log4j.message;\n\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.util.Arrays;\nimport java.util.IllegalFormatException;\nimport java.util.Locale;\n\nimport org.apache.logging.log4j.Logger;\nimport org.apache.logging.log4j.status.StatusLogger;\n\n/**\n * Handles messages that consist of a format string conforming to {@link java.util.Formatter}.\n * \n * <h4>Note to implementors</h4>\n * <p>\n * This class implements the unrolled args API even though StringFormattedMessage does not. This leaves the room for\n * StringFormattedMessage to unroll itself later.\n * </p>\n */\npublic class StringFormattedMessage implements Message {\n\n    private static final Logger LOGGER = StatusLogger.getLogger();\n\n    private static final long serialVersionUID = -665975803997290697L;\n\n    private static final int HASHVAL = 31;\n\n    private String messagePattern;\n    private transient Object[] argArray;\n    private String[] stringArgs;\n    private transient String formattedMessage;\n    private transient Throwable throwable;\n    private final Locale locale;\n    \n   /**\n    * Constructs a message.\n    * \n    * @param locale the locale for this message format\n    * @param messagePattern the pattern for this message format\n    * @param arguments The objects to format\n    * @since 2.6\n    */\n<fim_suffix>    public StringFormattedMessage(final Locale locale, final String messagePattern, final Object... arguments) {\n        this.locale = locale;\n        this.messagePattern = messagePattern;\n        this.argArray = arguments;\n        if (arguments != null && arguments.length > 0 && arguments[arguments.length - 1] instanceof Throwable) {\n            this.throwable = (Throwable) arguments[arguments.length - 1];\n        }\n    }\n\n    /**\n     * Constructs a message.\n     * \n     * @param messagePattern the pattern for this message format\n     * @param arguments The objects to format\n     * @since 2.6\n     */\n    public StringFormattedMessage(final String messagePattern, final Object... arguments) {\n        this(Locale.getDefault(Locale.Category.FORMAT), messagePattern, arguments);\n    }\n\n    /**\n     * Returns the formatted message.\n     * @return the formatted message.\n     */\n    @Override\n    public String getFormattedMessage() {\n        if (formattedMessage == null) {\n            formattedMessage = formatMessage(messagePattern, argArray);\n        }\n        return formattedMessage;\n    }\n\n    /**\n     * Returns the message pattern.\n     * @return the message pattern.\n     */\n    @Override\n    public String getFormat() {\n        return messagePattern;\n    }\n\n    /**\n     * Returns the message parameters.\n     * @return the message parameters.\n     */\n    @Override\n    public Object[] getParameters() {\n        if (argArray != null) {\n            return argArray;\n        }\n        return stringArgs;\n    }\n\n    protected String formatMessage(final String msgPattern, final Object... args) {\n        try {\n            return String.format(locale, msgPattern, args);\n        } catch (final IllegalFormatException ife) {\n            LOGGER.error(\"Unable to format msg: \" + msgPattern, ife);\n            return msgPattern;\n        }\n    }\n\n    @Override\n    public boolean equals(final Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n\n        final StringFormattedMessage that = (StringFormattedMessage) o;\n\n        if (messagePattern != null ? !messagePattern.equals(that.messagePattern) : that.messagePattern != null) {\n            return false;\n        }\n\n        return Arrays.equals(stringArgs, that.stringArgs);\n    }\n\n    @Override\n    public int hashCode() {\n        int result = messagePattern != null ? messagePattern.hashCode() : 0;\n        result = HASHVAL * result + (stringArgs != null ? Arrays.hashCode(stringArgs) : 0);\n        return result;\n    }\n\n\n    @Override\n    public String toString() {\n        return getFormattedMessage();\n    }\n\n    private void writeObject(final ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        getFormattedMessage();\n        out.writeUTF(formattedMessage);\n        out.writeUTF(messagePattern);\n        out.writeInt(argArray.length);\n        stringArgs = new String[argArray.length];\n        int i = 0;\n        for (final Object obj : argArray) {\n            final String string = String.valueOf(obj);\n            stringArgs[i] = string;\n            out.writeUTF(string);\n            ++i;\n        }\n    }\n\n    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        formattedMessage = in.readUTF();\n        messagePattern = in.readUTF();\n        final int length = in.readInt();\n        stringArgs = new String[length];\n        for (int i = 0; i < length; ++i) {\n            stringArgs[i] = in.readUTF();\n        }\n    }\n\n    /**\n     * Return the throwable passed to the Message.\n     *\n     * @return the Throwable.\n     */\n    @Override\n    public Throwable getThrowable() {\n        return throwable;\n    }\n}<fim_middle>// function below has no smell\n"}