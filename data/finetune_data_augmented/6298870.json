{"text": "<fim_prefix>    public void send(MetaData.Response info, boolean head, ByteBuffer content, boolean lastContent, Callback callback)\n    {\n        if (info == null)\n        {\n            if (!lastContent && BufferUtil.isEmpty(content))\n            {\n                callback.succeeded();\n                return;\n            }\n        }\n        else\n        {\n            // If we are still expecting a 100 continues when we commit\n            if (_channel.isExpecting100Continue())\n                // then we can't be persistent\n                _generator.setPersistent(false);\n        }\n        if(_sendCallback.reset(info,head,content,lastContent,callback))\n        {\n            _sendCallback.iterate();\n        }\n    }\n    HttpInput.Content newContent(ByteBuffer c)\n    {\n        return new Content(c);\n    }\n    @Override\n    public void abort(Throwable failure)\n    {\n        if (LOG.isDebugEnabled())\n            LOG.debug(\"abort {} {}\",this,failure);\n        // Do a direct close of the output, as this may indicate to a client that the\n        // response is bad either with RST or by abnormal completion of chunked response.\n        getEndPoint().close();\n    }\n    @Override\n    public boolean isPushSupported()\n    {\n        return false;\n    }\n    @Override\n    public void push(org.eclipse.jetty.http.MetaData.Request request)\n    {\n        LOG.debug(\"ignore push in {}\",this);\n    }\n    public void asyncReadFillInterested()\n    {\n        getEndPoint().fillInterested(_asyncReadCallback);\n    }\n    public void blockingReadFillInterested()\n    {\n        // We try fillInterested here because of SSL and \n        // spurious wakeups.  With  blocking reads, we read in a loop\n        // that tries to read/parse content and blocks waiting if there is\n        // none available.  The loop can be woken up by incoming encrypted \n        // bytes, which due to SSL might not produce any decrypted bytes.\n        // Thus the loop needs to register fill interest again.  However if \n        // the loop is woken up spuriously, then the register interest again\n        // can result in a pending read exception, unless we use tryFillInterested.\n        getEndPoint().tryFillInterested(_blockingReadCallback);\n    }\n    public void blockingReadFailure(Throwable e)\n    {\n        _blockingReadCallback.failed(e);\n    }\n    @Override\n    public long getBytesIn()\n    {\n        return bytesIn.longValue();\n    }\n    @Override\n    public long getBytesOut()\n    {\n        return bytesOut.longValue();\n    }\n    @Override\n    public String toConnectionString()\n    {\n        return String.format(\"%s@%x[p=%s,g=%s]=>%s\",\n                getClass().getSimpleName(),\n                hashCode(),\n                _parser,\n                _generator,\n                _channel);\n    }\n    private class Content extends HttpInput.Content\n    {\n        public Content(ByteBuffer content)\n        {\n            super(content);\n            _contentBufferReferences.incrementAndGet();\n        }\n        @Override\n        public void succeeded()\n        {\n            if (_contentBufferReferences.decrementAndGet()==0)\n                releaseRequestBuffer();\n        }\n        @Override\n        public void failed(Throwable x)\n        {\n            succeeded();\n        }\n    }\n    private class BlockingReadCallback implements Callback\n    {\n        @Override\n        public void succeeded()\n        {\n            _input.unblock();\n        }\n        @Override\n        public void failed(Throwable x)\n        {\n            _input.failed(x);\n        }\n        @Override\n        public InvocationType getInvocationType()\n        {\n            // This callback does not block, rather it wakes up the\n            // thread that is blocked waiting on the read.\n            return InvocationType.NON_BLOCKING;\n        }\n    }\n    private class AsyncReadCallback implements Callback\n    {\n        @Override\n        public void succeeded()\n        {\n            if (_channel.getState().onReadPossible())\n                _channel.handle();\n        }\n        @Override\n        public void failed(Throwable x)\n        {\n            if (_input.failed(x))\n                _channel.handle();\n        }\n    }\n    private class SendCallback extends IteratingCallback\n    {\n        private MetaData.Response _info;\n        private boolean _head;\n        private ByteBuffer _content;\n        private boolean _lastContent;\n        private Callback _callback;\n        private ByteBuffer _header;\n        private boolean _shutdownOut;\n        private SendCallback()\n        {\n            super(true);\n        }\n        @Override\n        public InvocationType getInvocationType()\n        {\n            return _callback.getInvocationType();\n        }\n        private boolean reset(MetaData.Response info, boolean head, ByteBuffer content, boolean last, Callback callback)\n        {\n            if (reset())\n            {\n                _info = info;\n                _head = head;\n                _content = content;\n                _lastContent = last;\n                _callback = callback;\n                _header = null;\n                _shutdownOut = false;\n                if (getConnector().isShutdown())\n                    _generator.setPersistent(false);\n                return true;\n            }\n            if (isClosed())\n                callback.failed(new EofException());\n            else\n                callback.failed(new WritePendingException());\n            return false;\n        }\n        @Override\n        public Action process() throws Exception\n        {\n            if (_callback==null)\n                throw new IllegalStateException();\n            ByteBuffer chunk = _chunk;\n            while (true)\n            {\n                HttpGenerator.Result result = _generator.generateResponse(_info, _head, _header, chunk, _content, _lastContent);\n                if (LOG.isDebugEnabled())\n                    LOG.debug(\"{} generate: {} ({},{},{})@{}\",\n                        this,\n                        result,\n                        BufferUtil.toSummaryString(_header),\n                        BufferUtil.toSummaryString(_content),\n                        _lastContent,\n                        _generator.getState());\n                switch (result)\n                {\n                    case NEED_INFO:\n                        throw new EofException(\"request lifecycle violation\");\n                    case NEED_HEADER:\n                    {\n                        _header = _bufferPool.acquire(_config.getResponseHeaderSize(), HEADER_BUFFER_DIRECT);\n                        continue;\n                    }\n                    case NEED_CHUNK:\n                    {\n                        chunk = _chunk = _bufferPool.acquire(HttpGenerator.CHUNK_SIZE, CHUNK_BUFFER_DIRECT);\n                        continue;\n                    }\n                    case NEED_CHUNK_TRAILER:\n                    {\n                        if (_chunk!=null)\n                            _bufferPool.release(_chunk);\n                        chunk = _chunk = _bufferPool.acquire(_config.getResponseHeaderSize(), CHUNK_BUFFER_DIRECT);\n                        continue;\n                    }\n                    case FLUSH:\n                    {\n                        // Don't write the chunk or the content if this is a HEAD response, or any other type of response that should have no content\n                        if (_head || _generator.isNoContent())\n                        {\n                            BufferUtil.clear(chunk);\n                            BufferUtil.clear(_content);\n                        }\n                        byte gather_write = 0;\n                        long bytes = 0;\n                        if (BufferUtil.hasContent(_header))\n                        {\n                            gather_write += 4;\n                            bytes += _header.remaining();\n                        }\n                        if (BufferUtil.hasContent(chunk))\n                        {\n                            gather_write += 2;\n                            bytes += chunk.remaining();\n                        }\n                        if (BufferUtil.hasContent(_content))\n                        {\n                            gather_write += 1;\n                            bytes += _content.remaining();\n                        }\n                        HttpConnection.this.bytesOut.add(bytes);\n                        switch(gather_write)\n                        {\n                            case 7:\n                                getEndPoint().write(this, _header, chunk, _content);\n                                break;\n                            case 6:\n                                getEndPoint().write(this, _header, chunk);\n                                break;\n                            case 5:\n                                getEndPoint().write(this, _header, _content);\n                                break;\n                            case 4:\n                                getEndPoint().write(this, _header);\n                                break;\n                            case 3:\n                                getEndPoint().write(this, chunk, _content);\n                                break;\n                            case 2:\n                                getEndPoint().write(this, chunk);\n                                break;\n                            case 1:\n                                getEndPoint().write(this, _content);\n                                break;\n                            default:\n                                succeeded();        \n                        }\n                        return Action.SCHEDULED;\n                    }\n                    case SHUTDOWN_OUT:\n                    {\n                        _shutdownOut=true;\n                        continue;\n                    }\n                    case DONE:\n                    {   \n                        // If shutdown after commit, we can still close here.\n                        if (getConnector().isShutdown())\n                            _shutdownOut=true;\n                        return Action.SUCCEEDED;\n                    }\n                    case CONTINUE:\n                    {\n                        break;\n                    }\n                    default:\n                    {\n                        throw new IllegalStateException(\"generateResponse=\"+result);\n                    }\n                }\n            }\n        }\n        private void releaseHeader()\n        {\n            ByteBuffer h=_header;\n            _header=null;\n            if (h!=null)\n                _bufferPool.release(h);\n        }\n        @Override\n        protected void onCompleteSuccess()\n        {\n            releaseHeader();\n            _callback.succeeded();\n            if (_shutdownOut)\n                getEndPoint().shutdownOutput();\n        }\n        @Override\n        public void onCompleteFailure(final Throwable x)\n        {\n            releaseHeader();\n            failedCallback(_callback,x);\n            if (_shutdownOut)\n                getEndPoint().shutdownOutput();\n        }\n<fim_suffix>        @Override\n        public String toString()\n        {\n            return String.format(\"%s[i=%s,cb=%s]\",super.toString(),_info,_callback);\n        }<fim_middle>// function below has no smell\n"}