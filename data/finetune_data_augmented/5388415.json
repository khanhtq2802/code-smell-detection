{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.phoenix.schema.stats;\n\nimport java.util.Collections;\nimport java.util.Set;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\n\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.hbase.client.RegionInfo;\nimport org.apache.phoenix.query.QueryServices;\nimport org.apache.phoenix.query.QueryServicesOptions;\nimport org.apache.phoenix.util.ByteUtil;\n\nimport com.google.common.util.concurrent.ThreadFactoryBuilder;\n\n/**\n * Singleton that is used to track state associated with regions undergoing stats collection at the\n * region server's JVM level.\n */\npublic class StatisticsCollectionRunTracker {\n    private static volatile StatisticsCollectionRunTracker INSTANCE;\n    private final Set<ColumnFamilyRegionInfo> updateStatsRegions = Collections\n            .newSetFromMap(new ConcurrentHashMap<ColumnFamilyRegionInfo, Boolean>());\n    private final Set<RegionInfo> compactingRegions = Collections\n            .newSetFromMap(new ConcurrentHashMap<RegionInfo, Boolean>());\n    private final ExecutorService executor;\n    \n    // Constants added for testing purposes\n    public static final long CONCURRENT_UPDATE_STATS_ROW_COUNT = -100l;\n    public static final long COMPACTION_UPDATE_STATS_ROW_COUNT = -200l;\n    \n    public static StatisticsCollectionRunTracker getInstance(Configuration config) {\n        StatisticsCollectionRunTracker result = INSTANCE;\n        if (result == null) {\n            synchronized (StatisticsCollectionRunTracker.class) {\n                result = INSTANCE;\n                if (result == null) {\n                    INSTANCE = result = new StatisticsCollectionRunTracker(config);\n                }\n            }\n        }\n        return result;\n    }\n\n    private StatisticsCollectionRunTracker(Configuration config) {\n        int poolSize =\n                config.getInt(QueryServices.STATS_SERVER_POOL_SIZE,\n                    QueryServicesOptions.DEFAULT_STATS_POOL_SIZE);\n        ThreadFactoryBuilder builder =\n                new ThreadFactoryBuilder().setDaemon(true).setNameFormat(\n                    \"phoenix-update-statistics-%s\");\n        executor = Executors.newFixedThreadPool(poolSize, builder.build());\n    }\n\n    /**\n     * @param regionInfo for the region that should be marked as undergoing stats collection via\n     *            major compaction.\n     * @return true if the region wasn't already marked for stats collection via compaction, false\n     *         otherwise.\n     */\n    public boolean addCompactingRegion(RegionInfo regionInfo) {\n        return compactingRegions.add(regionInfo);\n    }\n\n    /**\n     * @param regionInfo for the region that should be unmarked as undergoing stats collection via\n     *            major compaction.\n     * @return true if the region was marked for stats collection via compaction, false otherwise.\n     */\n    public boolean removeCompactingRegion(RegionInfo regionInfo) {\n        return compactingRegions.remove(regionInfo);\n    }\n\n    /**\n     * @param regionInfo for the region to check for.\n     * @return true if stats are being collected for the region via major compaction, false\n     *         otherwise.\n     */\n    public boolean areStatsBeingCollectedOnCompaction(RegionInfo regionInfo) {\n        return compactingRegions.contains(regionInfo);\n    }\n\n    /**\n     * @param regionInfo for the region to run UPDATE STATISTICS command on.\n     * @param familySet \n     * @return true if UPDATE STATISTICS wasn't already running on the region, false otherwise.\n     */\n    public boolean addUpdateStatsCommandRegion(RegionInfo regionInfo, Set<byte[]> familySet) {\n        return updateStatsRegions.add(new ColumnFamilyRegionInfo(regionInfo,familySet));\n    }\n\n    /**\n     * @param regionInfo for the region to mark as not running UPDATE STATISTICS command on.\n     * @return true if UPDATE STATISTICS was running on the region, false otherwise.\n     */\n    public boolean removeUpdateStatsCommandRegion(RegionInfo regionInfo, Set<byte[]> familySet) {\n        return updateStatsRegions.remove(new ColumnFamilyRegionInfo(regionInfo,familySet));\n    }\n\n    /**\n     * Enqueues the task for execution.\n     * @param <T>\n     * @param c task to execute\n     */\n    public <T> Future<T> runTask(Callable<T> c) {\n        return executor.submit(c);\n    }\n\n<fim_suffix>    class ColumnFamilyRegionInfo {\n        private RegionInfo regionInfo;\n        private Set<byte[]> familySet;\n\n        public ColumnFamilyRegionInfo(RegionInfo regionInfo, Set<byte[]> familySet) {\n            this.regionInfo = regionInfo;\n            this.familySet = familySet;\n        }\n\n        public RegionInfo getRegionInfo() {\n            return regionInfo;\n        }\n\n        public Set<byte[]> getFamilySet() {\n            return familySet;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (obj == this) { return true; }\n            if (!(obj instanceof ColumnFamilyRegionInfo)) { return false; }\n\n            ColumnFamilyRegionInfo c = (ColumnFamilyRegionInfo)obj;\n            return c.getRegionInfo().equals(this.regionInfo) && ByteUtil.match(this.familySet, c.getFamilySet());\n        }\n\n        @Override\n        public int hashCode() {\n            return this.getRegionInfo().hashCode();\n        }\n    }\n\n}<fim_middle>// class below is data class\n"}