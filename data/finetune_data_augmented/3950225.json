{"text": "<fim_prefix>\n<fim_suffix>@Service\npublic class EntityLineageService implements AtlasLineageService {\n    private static final Logger LOG = LoggerFactory.getLogger(EntityLineageService.class);\n    private static final String PROCESS_INPUTS_EDGE  = \"__Process.inputs\";\n    private static final String PROCESS_OUTPUTS_EDGE = \"__Process.outputs\";\n    private static final String COLUMNS              = \"columns\";\n    private final AtlasGraph                graph;\n    private final AtlasGremlinQueryProvider gremlinQueryProvider;\n    private final EntityGraphRetriever      entityRetriever;\n    private final AtlasTypeRegistry         atlasTypeRegistry;\n    @Inject\n    EntityLineageService(AtlasTypeRegistry typeRegistry, AtlasGraph atlasGraph) {\n        this.graph = atlasGraph;\n        this.gremlinQueryProvider = AtlasGremlinQueryProvider.INSTANCE;\n        this.entityRetriever = new EntityGraphRetriever(typeRegistry);\n        this.atlasTypeRegistry = typeRegistry;\n    }\n    @Override\n    @GraphTransaction\n    public AtlasLineageInfo getAtlasLineageInfo(String guid, LineageDirection direction, int depth) throws AtlasBaseException {\n        AtlasLineageInfo ret;\n        AtlasEntityHeader entity = entityRetriever.toAtlasEntityHeaderWithClassifications(guid);\n        AtlasAuthorizationUtils.verifyAccess(new AtlasEntityAccessRequest(atlasTypeRegistry, AtlasPrivilege.ENTITY_READ, entity), \"read entity lineage: guid=\", guid);\n        AtlasEntityType entityType = atlasTypeRegistry.getEntityTypeByName(entity.getTypeName());\n        if (entityType == null) {\n            throw new AtlasBaseException(AtlasErrorCode.TYPE_NAME_NOT_FOUND, entity.getTypeName());\n        }\n        boolean isDataSet = entityType.getTypeAndAllSuperTypes().contains(DATA_SET_SUPER_TYPE);\n        if (!isDataSet) {\n            boolean isProcess = entityType.getTypeAndAllSuperTypes().contains(PROCESS_SUPER_TYPE);\n            if (!isProcess) {\n                throw new AtlasBaseException(AtlasErrorCode.INVALID_LINEAGE_ENTITY_TYPE, guid, entity.getTypeName());\n            }\n        }\n        if (direction != null) {\n            if (direction.equals(INPUT)) {\n                ret = getLineageInfo(guid, INPUT, depth, isDataSet);\n            } else if (direction.equals(OUTPUT)) {\n                ret = getLineageInfo(guid, OUTPUT, depth, isDataSet);\n            } else if (direction.equals(BOTH)) {\n                ret = getBothLineageInfo(guid, depth, isDataSet);\n            } else {\n                throw new AtlasBaseException(AtlasErrorCode.INSTANCE_LINEAGE_INVALID_PARAMS, \"direction\", direction.toString());\n            }\n        } else {\n            throw new AtlasBaseException(AtlasErrorCode.INSTANCE_LINEAGE_INVALID_PARAMS, \"direction\", null);\n        }\n        return ret;\n    }\n    @Override\n    @GraphTransaction\n    public SchemaDetails getSchemaForHiveTableByName(final String datasetName) throws AtlasBaseException {\n        if (StringUtils.isEmpty(datasetName)) {\n            // TODO: Complete error handling here\n            throw new AtlasBaseException(AtlasErrorCode.BAD_REQUEST);\n        }\n        AtlasEntityType hive_table = atlasTypeRegistry.getEntityTypeByName(\"hive_table\");\n        Map<String, Object> lookupAttributes = new HashMap<>();\n        lookupAttributes.put(\"qualifiedName\", datasetName);\n        String guid = AtlasGraphUtilsV2.getGuidByUniqueAttributes(hive_table, lookupAttributes);\n        return getSchemaForHiveTableByGuid(guid);\n    }\n    @Override\n    @GraphTransaction\n    public SchemaDetails getSchemaForHiveTableByGuid(final String guid) throws AtlasBaseException {\n        if (StringUtils.isEmpty(guid)) {\n            throw new AtlasBaseException(AtlasErrorCode.BAD_REQUEST);\n        }\n        SchemaDetails ret = new SchemaDetails();\n        AtlasEntityType hive_column = atlasTypeRegistry.getEntityTypeByName(\"hive_column\");\n        ret.setDataType(AtlasTypeUtil.toClassTypeDefinition(hive_column));\n        AtlasEntityWithExtInfo entityWithExtInfo = entityRetriever.toAtlasEntityWithExtInfo(guid);\n        AtlasEntity            entity            = entityWithExtInfo.getEntity();\n        AtlasAuthorizationUtils.verifyAccess(new AtlasEntityAccessRequest(atlasTypeRegistry, AtlasPrivilege.ENTITY_READ, new AtlasEntityHeader(entity)),\n                                             \"read entity schema: guid=\", guid);\n        Map<String, AtlasEntity> referredEntities = entityWithExtInfo.getReferredEntities();\n        List<String>             columnIds        = getColumnIds(entity);\n        if (MapUtils.isNotEmpty(referredEntities)) {\n            List<Map<String, Object>> rows = referredEntities.entrySet()\n                                                             .stream()\n                                                             .filter(e -> isColumn(columnIds, e))\n                                                             .map(e -> AtlasTypeUtil.toMap(e.getValue()))\n                                                             .collect(Collectors.toList());\n            ret.setRows(rows);\n        }\n        return ret;\n    }\n    private List<String> getColumnIds(AtlasEntity entity) {\n        List<String> ret        = new ArrayList<>();\n        Object       columnObjs = entity.getAttribute(COLUMNS);\n        if (columnObjs instanceof List) {\n            for (Object pkObj : (List) columnObjs) {\n                if (pkObj instanceof AtlasObjectId) {\n                    ret.add(((AtlasObjectId) pkObj).getGuid());\n                }\n            }\n        }\n        return ret;\n    }\n    private boolean isColumn(List<String> columnIds, Map.Entry<String, AtlasEntity> e) {\n        return columnIds.contains(e.getValue().getGuid());\n    }\n    private AtlasLineageInfo getLineageInfo(String guid, LineageDirection direction, int depth, boolean isDataSet) throws AtlasBaseException {\n        final Map<String, Object>      bindings     = new HashMap<>();\n        String                         lineageQuery = getLineageQuery(guid, direction, depth, isDataSet, bindings);\n        List                           results      = executeGremlinScript(bindings, lineageQuery);\n        Map<String, AtlasEntityHeader> entities     = new HashMap<>();\n        Set<LineageRelation>           relations    = new HashSet<>();\n        if (CollectionUtils.isNotEmpty(results)) {\n            for (Object result : results) {\n                if (result instanceof Map) {\n                    for (final Object o : ((Map) result).entrySet()) {\n                        final Map.Entry entry = (Map.Entry) o;\n                        Object          value = entry.getValue();\n                        if (value instanceof List) {\n                            for (Object elem : (List) value) {\n                                if (elem instanceof AtlasEdge) {\n                                    processEdge((AtlasEdge) elem, entities, relations);\n                                } else {\n                                    LOG.warn(\"Invalid value of type {} found, ignoring\", (elem != null ? elem.getClass().getSimpleName() : \"null\"));\n                                }\n                            }\n                        } else if (value instanceof AtlasEdge) {\n                            processEdge((AtlasEdge) value, entities, relations);\n                        } else {\n                            LOG.warn(\"Invalid value of type {} found, ignoring\", (value != null ? value.getClass().getSimpleName() : \"null\"));\n                        }\n                    }\n                } else if (result instanceof AtlasEdge) {\n                    processEdge((AtlasEdge) result, entities, relations);\n                }\n            }\n        }\n        return new AtlasLineageInfo(guid, entities, relations, direction, depth);\n    }\n    private List executeGremlinScript(Map<String, Object> bindings, String lineageQuery) throws AtlasBaseException {\n        List         ret;\n        ScriptEngine engine = graph.getGremlinScriptEngine();\n        try {\n            ret = (List) graph.executeGremlinScript(engine, bindings, lineageQuery, false);\n        } catch (ScriptException e) {\n            throw new AtlasBaseException(INSTANCE_LINEAGE_QUERY_FAILED, lineageQuery);\n        } finally {\n            graph.releaseGremlinScriptEngine(engine);\n        }\n        return ret;\n    }\n    private void processEdge(final AtlasEdge edge, final Map<String, AtlasEntityHeader> entities, final Set<LineageRelation> relations) throws AtlasBaseException {\n        AtlasVertex inVertex     = edge.getInVertex();\n        AtlasVertex outVertex    = edge.getOutVertex();\n        String      inGuid       = AtlasGraphUtilsV2.getIdFromVertex(inVertex);\n        String      outGuid      = AtlasGraphUtilsV2.getIdFromVertex(outVertex);\n        String      relationGuid = AtlasGraphUtilsV2.getEncodedProperty(edge, RELATIONSHIP_GUID_PROPERTY_KEY, String.class);\n        boolean     isInputEdge  = edge.getLabel().equalsIgnoreCase(PROCESS_INPUTS_EDGE);\n        if (!entities.containsKey(inGuid)) {\n            AtlasEntityHeader entityHeader = entityRetriever.toAtlasEntityHeader(inVertex);\n            entities.put(inGuid, entityHeader);\n        }\n        if (!entities.containsKey(outGuid)) {\n            AtlasEntityHeader entityHeader = entityRetriever.toAtlasEntityHeader(outVertex);\n            entities.put(outGuid, entityHeader);\n        }\n        if (isInputEdge) {\n            relations.add(new LineageRelation(inGuid, outGuid, relationGuid));\n        } else {<fim_middle>// class below has no smell\n"}