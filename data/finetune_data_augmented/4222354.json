{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.cassandra.schema;\n\nimport java.nio.ByteBuffer;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.function.Predicate;\n\nimport javax.annotation.Nullable;\n\nimport com.google.common.collect.*;\n\nimport org.apache.cassandra.db.marshal.UserType;\nimport org.apache.cassandra.index.internal.CassandraIndex;\n\nimport static com.google.common.collect.Iterables.any;\nimport static com.google.common.collect.Iterables.transform;\n\n/**\n * An immutable container for a keyspace's Tables.\n */\npublic final class Tables implements Iterable<TableMetadata>\n{\n    private static final Tables NONE = builder().build();\n\n    private final ImmutableMap<String, TableMetadata> tables;\n    private final ImmutableMap<TableId, TableMetadata> tablesById;\n    private final ImmutableMap<String, TableMetadata> indexTables;\n\n    private Tables(Builder builder)\n    {\n        tables = builder.tables.build();\n        tablesById = builder.tablesById.build();\n        indexTables = builder.indexTables.build();\n    }\n\n    public static Builder builder()\n    {\n        return new Builder();\n    }\n\n    public static Tables none()\n    {\n        return NONE;\n    }\n\n    public static Tables of(TableMetadata... tables)\n    {\n        return builder().add(tables).build();\n    }\n\n    public static Tables of(Iterable<TableMetadata> tables)\n    {\n        return builder().add(tables).build();\n    }\n\n    public Iterator<TableMetadata> iterator()\n    {\n        return tables.values().iterator();\n    }\n\n    public Iterable<TableMetadata> referencingUserType(ByteBuffer name)\n    {\n        return Iterables.filter(tables.values(), t -> t.referencesUserType(name));\n    }\n\n    ImmutableMap<String, TableMetadata> indexTables()\n    {\n        return indexTables;\n    }\n\n    public int size()\n    {\n        return tables.size();\n    }\n\n    /**\n     * Get the table with the specified name\n     *\n     * @param name a non-qualified table name\n     * @return an empty {@link Optional} if the table name is not found; a non-empty optional of {@link TableMetadataRef} otherwise\n     */\n    public Optional<TableMetadata> get(String name)\n    {\n        return Optional.ofNullable(tables.get(name));\n    }\n\n    /**\n     * Get the table with the specified name\n     *\n     * @param name a non-qualified table name\n     * @return null if the table name is not found; the found {@link TableMetadataRef} otherwise\n     */\n    @Nullable\n    public TableMetadata getNullable(String name)\n    {\n        return tables.get(name);\n    }\n\n    @Nullable\n    TableMetadata getNullable(TableId id)\n    {\n        return tablesById.get(id);\n    }\n\n    boolean containsTable(TableId id)\n    {\n        return tablesById.containsKey(id);\n    }\n\n    public Tables filter(Predicate<TableMetadata> predicate)\n    {\n        Builder builder = builder();\n        tables.values().stream().filter(predicate).forEach(builder::add);\n        return builder.build();\n    }\n\n    /**\n     * Create a Tables instance with the provided table added\n     */\n    public Tables with(TableMetadata table)\n    {\n        if (get(table.name).isPresent())\n            throw new IllegalStateException(String.format(\"Table %s already exists\", table.name));\n\n        return builder().add(this).add(table).build();\n    }\n\n    public Tables withSwapped(TableMetadata table)\n    {\n        return without(table.name).with(table);\n    }\n\n    /**\n     * Creates a Tables instance with the table with the provided name removed\n     */\n    public Tables without(String name)\n    {\n        TableMetadata table =\n            get(name).orElseThrow(() -> new IllegalStateException(String.format(\"Table %s doesn't exists\", name)));\n\n        return without(table);\n    }\n\n    public Tables without(TableMetadata table)\n    {\n        return filter(t -> t != table);\n    }\n\n    public Tables withUpdatedUserType(UserType udt)\n    {\n        return any(this, t -> t.referencesUserType(udt.name))\n             ? builder().add(transform(this, t -> t.withUpdatedUserType(udt))).build()\n             : this;\n    }\n\n    MapDifference<String, TableMetadata> indexesDiff(Tables other)\n    {\n        Map<String, TableMetadata> thisIndexTables = new HashMap<>();\n        this.indexTables.values().forEach(t -> thisIndexTables.put(t.indexName().get(), t));\n\n        Map<String, TableMetadata> otherIndexTables = new HashMap<>();\n        other.indexTables.values().forEach(t -> otherIndexTables.put(t.indexName().get(), t));\n\n        return Maps.difference(thisIndexTables, otherIndexTables);\n    }\n\n    @Override\n    public boolean equals(Object o)\n    {\n        return this == o || (o instanceof Tables && tables.equals(((Tables) o).tables));\n    }\n\n    @Override\n    public int hashCode()\n    {\n        return tables.hashCode();\n    }\n\n    @Override\n    public String toString()\n    {\n        return tables.values().toString();\n    }\n\n    public static final class Builder\n    {\n        final ImmutableMap.Builder<String, TableMetadata> tables = new ImmutableMap.Builder<>();\n        final ImmutableMap.Builder<TableId, TableMetadata> tablesById = new ImmutableMap.Builder<>();\n        final ImmutableMap.Builder<String, TableMetadata> indexTables = new ImmutableMap.Builder<>();\n\n        private Builder()\n        {\n        }\n\n        public Tables build()\n        {\n            return new Tables(this);\n        }\n\n<fim_suffix>        public Builder add(TableMetadata table)\n        {\n            tables.put(table.name, table);\n\n            tablesById.put(table.id, table);\n\n            table.indexes\n                 .stream()\n                 .filter(i -> !i.isCustom())\n                 .map(i -> CassandraIndex.indexCfsMetadata(table, i))\n                 .forEach(i -> indexTables.put(i.indexName().get(), i));\n\n            return this;\n        }\n\n        public Builder add(TableMetadata... tables)\n        {\n            for (TableMetadata table : tables)\n                add(table);\n            return this;\n        }\n\n        public Builder add(Iterable<TableMetadata> tables)\n        {\n            tables.forEach(this::add);\n            return this;\n        }\n    }\n\n    static TablesDiff diff(Tables before, Tables after)\n    {\n        return TablesDiff.diff(before, after);\n    }\n\n    public static final class TablesDiff extends Diff<Tables, TableMetadata>\n    {\n        private final static TablesDiff NONE = new TablesDiff(Tables.none(), Tables.none(), ImmutableList.of());\n\n        private TablesDiff(Tables created, Tables dropped, ImmutableCollection<Altered<TableMetadata>> altered)\n        {\n            super(created, dropped, altered);\n        }\n\n        private static TablesDiff diff(Tables before, Tables after)\n        {\n            if (before == after)\n                return NONE;\n\n            Tables created = after.filter(t -> !before.containsTable(t.id));\n            Tables dropped = before.filter(t -> !after.containsTable(t.id));\n\n            ImmutableList.Builder<Altered<TableMetadata>> altered = ImmutableList.builder();\n            before.forEach(tableBefore ->\n            {\n                TableMetadata tableAfter = after.getNullable(tableBefore.id);\n                if (null != tableAfter)\n                    tableBefore.compare(tableAfter).ifPresent(kind -> altered.add(new Altered<>(tableBefore, tableAfter, kind)));\n            });\n\n            return new TablesDiff(created, dropped, altered.build());\n        }\n    }\n}<fim_middle>// function below has no smell\n"}