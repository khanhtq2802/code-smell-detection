{"text": "<fim_prefix>\t\t}\n\t\t/**\n\t\t * Applies the {@literal recordIds}. Constructs a new command instance with all previously configured properties.\n\t\t *\n\t\t * @param recordIds must not be {@literal null}.\n\t\t * @return a new {@link AcknowledgeCommand} with {@literal recordIds} applied.\n\t\t */\n\t\tpublic AcknowledgeCommand forRecords(String... recordIds) {\n\t\t\tAssert.notNull(recordIds, \"recordIds must not be null!\");\n\t\t\treturn forRecords(Arrays.stream(recordIds).map(RecordId::of).toArray(RecordId[]::new));\n\t\t}\n\t\t/**\n\t\t * Applies the {@literal recordIds}. Constructs a new command instance with all previously configured properties.\n\t\t *\n\t\t * @param recordIds must not be {@literal null}.\n\t\t * @return a new {@link AcknowledgeCommand} with {@literal recordIds} applied.\n\t\t */\n\t\tpublic AcknowledgeCommand forRecords(RecordId... recordIds) {\n\t\t\tAssert.notNull(recordIds, \"recordIds must not be null!\");\n\t\t\tList<RecordId> newrecordIds = new ArrayList<>(getRecordIds().size() + recordIds.length);\n\t\t\tnewrecordIds.addAll(getRecordIds());\n\t\t\tnewrecordIds.addAll(Arrays.asList(recordIds));\n\t\t\treturn new AcknowledgeCommand(getKey(), getGroup(), newrecordIds);\n\t\t}\n\t\t/**\n\t\t * Applies the {@literal group}. Constructs a new command instance with all previously configured properties.\n\t\t *\n\t\t * @param group must not be {@literal null}.\n\t\t * @return a new {@link AcknowledgeCommand} with {@literal group} applied.\n\t\t */\n\t\tpublic AcknowledgeCommand inGroup(String group) {\n\t\t\tAssert.notNull(group, \"Group must not be null!\");\n\t\t\treturn new AcknowledgeCommand(getKey(), group, getRecordIds());\n\t\t}\n\t\t@Nullable\n\t\tpublic String getGroup() {\n\t\t\treturn group;\n\t\t}\n\t\tpublic List<RecordId> getRecordIds() {\n\t\t\treturn recordIds;\n\t\t}\n\t}\n\t/**\n\t * Acknowledge one or more records as processed.\n\t *\n\t * @param key the stream key.\n\t * @param group name of the consumer group.\n\t * @param recordIds record Id's to acknowledge.\n\t * @return {@link Mono} emitting the nr of acknowledged messages.\n\t * @see <a href=\"https://redis.io/commands/xadd\">Redis Documentation: XADD</a>\n\t */\n\tdefault Mono<Long> xAck(ByteBuffer key, String group, String... recordIds) {\n\t\tAssert.notNull(key, \"Key must not be null!\");\n\t\tAssert.notNull(recordIds, \"recordIds must not be null!\");\n\t\treturn xAck(Mono.just(AcknowledgeCommand.stream(key).inGroup(group).forRecords(recordIds))).next()\n\t\t\t\t.map(NumericResponse::getOutput);\n\t}\n\t/**\n\t * Acknowledge one or more records as processed.\n\t *\n\t * @param key the stream key.\n\t * @param group name of the consumer group.\n\t * @param recordIds record Id's to acknowledge.\n\t * @return {@link Mono} emitting the nr of acknowledged messages.\n\t * @see <a href=\"https://redis.io/commands/xadd\">Redis Documentation: XADD</a>\n\t */\n\tdefault Mono<Long> xAck(ByteBuffer key, String group, RecordId... recordIds) {\n\t\tAssert.notNull(key, \"Key must not be null!\");\n\t\tAssert.notNull(recordIds, \"recordIds must not be null!\");\n\t\treturn xAck(Mono.just(AcknowledgeCommand.stream(key).inGroup(group).forRecords(recordIds))).next()\n\t\t\t\t.map(NumericResponse::getOutput);\n\t}\n\t/**\n\t * Acknowledge one or more records as processed.\n\t *\n\t * @param commands must not be {@literal null}.\n\t * @return {@link Flux} emitting the nr of acknowledged messages per {@link AcknowledgeCommand}.\n\t * @see <a href=\"https://redis.io/commands/xack\">Redis Documentation: XACK</a>\n\t */\n\tFlux<NumericResponse<AcknowledgeCommand, Long>> xAck(Publisher<AcknowledgeCommand> commands);\n\t/**\n\t * {@code XADD} command parameters.\n\t *\n\t * @see <a href=\"https://redis.io/commands/xadd\">Redis Documentation: XADD</a>\n\t */\n\tclass AddStreamRecord extends KeyCommand {\n\t\tprivate final ByteBufferRecord record;\n\t\tprivate AddStreamRecord(ByteBufferRecord record) {\n\t\t\tsuper(record.getStream());\n\t\t\tthis.record = record;\n\t\t}\n\t\t/**\n\t\t * Creates a new {@link AddStreamRecord} given {@link Map body}.\n\t\t *\n\t\t * @param record must not be {@literal null}.\n\t\t * @return a new {@link AddStreamRecord}.\n\t\t */\n\t\tpublic static AddStreamRecord of(ByteBufferRecord record) {\n\t\t\tAssert.notNull(record, \"Record must not be null!\");\n\t\t\treturn new AddStreamRecord(record);\n\t\t}\n\t\t/**\n\t\t * Creates a new {@link AddStreamRecord} given {@link Map body}.\n\t\t *\n\t\t * @param body must not be {@literal null}.\n\t\t * @return a new {@link AddStreamRecord} for {@link Map}.\n\t\t */\n\t\tpublic static AddStreamRecord body(Map<ByteBuffer, ByteBuffer> body) {\n\t\t\tAssert.notNull(body, \"Body must not be null!\");\n\t\t\treturn new AddStreamRecord(StreamRecords.rawBuffer(body));\n\t\t}\n\t\t/**\n\t\t * Applies the Geo set {@literal key}. Constructs a new command instance with all previously configured properties.\n\t\t *\n\t\t * @param key must not be {@literal null}.\n\t\t * @return a new {@link ReactiveGeoCommands.GeoAddCommand} with {@literal key} applied.\n\t\t */\n\t\tpublic AddStreamRecord to(ByteBuffer key) {\n\t\t\treturn new AddStreamRecord(record.withStreamKey(key));\n\t\t}\n\t\t/**\n\t\t * @return the actual {@link ByteBufferRecord#getValue()}\n\t\t */\n\t\tpublic Map<ByteBuffer, ByteBuffer> getBody() {\n\t\t\treturn record.getValue();\n\t\t}\n\t\tpublic ByteBufferRecord getRecord() {\n\t\t\treturn record;\n\t\t}\n\t}\n\t/**\n\t * Add stream record with given {@literal body} to {@literal key}.\n\t *\n\t * @param key must not be {@literal null}.\n\t * @param body must not be {@literal null}.\n\t * @return {@link Mono} emitting the server generated {@link RecordId id}.\n\t * @see <a href=\"https://redis.io/commands/xadd\">Redis Documentation: XADD</a>\n\t */\n\tdefault Mono<RecordId> xAdd(ByteBuffer key, Map<ByteBuffer, ByteBuffer> body) {\n\t\tAssert.notNull(key, \"Key must not be null!\");\n\t\tAssert.notNull(body, \"Body must not be null!\");\n\t\treturn xAdd(StreamRecords.newRecord().in(key).ofBuffer(body));\n\t}\n\t/**\n\t * Add stream record with given {@literal body} to {@literal key}.\n\t *\n\t * @param record must not be {@literal null}.\n\t * @return {@link Mono} the {@link RecordId id}.\n\t * @see <a href=\"https://redis.io/commands/xadd\">Redis Documentation: XADD</a>\n\t */\n\tdefault Mono<RecordId> xAdd(ByteBufferRecord record) {\n\t\tAssert.notNull(record, \"Record must not be null!\");\n\t\treturn xAdd(Mono.just(AddStreamRecord.of(record))).next().map(CommandResponse::getOutput);\n\t}\n\t/**\n\t * Add stream record with given {@literal body} to {@literal key}.\n\t *\n\t * @param commands must not be {@literal null}.\n\t * @return {@link Flux} emitting the {@link RecordId} on by for for the given {@link AddStreamRecord} commands.\n\t * @see <a href=\"https://redis.io/commands/xadd\">Redis Documentation: XADD</a>\n\t */\n\tFlux<CommandResponse<AddStreamRecord, RecordId>> xAdd(Publisher<AddStreamRecord> commands);\n\t/**\n\t * {@code XDEL} command parameters.\n\t *\n\t * @see <a href=\"https://redis.io/commands/xdel\">Redis Documentation: XDEL</a>\n\t */\n\tclass DeleteCommand extends KeyCommand {\n\t\tprivate final List<RecordId> recordIds;\n<fim_suffix>\t\tprivate DeleteCommand(@Nullable ByteBuffer key, List<RecordId> recordIds) {\n\t\t\tsuper(key);\n\t\t\tthis.recordIds = recordIds;\n\t\t}<fim_middle>// function below has no smell\n"}