{"text": "<fim_prefix>\n<fim_suffix>@InterfaceAudience.Public\n@InterfaceStability.Evolving\npublic class Cluster {\n  @InterfaceStability.Evolving\n  public static enum JobTrackerStatus {INITIALIZING, RUNNING};\n  private ClientProtocolProvider clientProtocolProvider;\n  private ClientProtocol client;\n  private UserGroupInformation ugi;\n  private Configuration conf;\n  private FileSystem fs = null;\n  private Path sysDir = null;\n  private Path stagingAreaDir = null;\n  private Path jobHistoryDir = null;\n  private static final Log LOG = LogFactory.getLog(Cluster.class);\n  private static ServiceLoader<ClientProtocolProvider> frameworkLoader =\n      ServiceLoader.load(ClientProtocolProvider.class);\n  static {\n    ConfigUtil.loadResources();\n  }\n  public Cluster(Configuration conf) throws IOException {\n    this(null, conf);\n  }\n  public Cluster(InetSocketAddress jobTrackAddr, Configuration conf) \n      throws IOException {\n    this.conf = conf;\n    this.ugi = UserGroupInformation.getCurrentUser();\n    initialize(jobTrackAddr, conf);\n  }\n  private void initialize(InetSocketAddress jobTrackAddr, Configuration conf)\n      throws IOException {\n    synchronized (frameworkLoader) {\n      for (ClientProtocolProvider provider : frameworkLoader) {\n        LOG.debug(\"Trying ClientProtocolProvider : \"\n            + provider.getClass().getName());\n        ClientProtocol clientProtocol = null; \n        try {\n          if (jobTrackAddr == null) {\n            clientProtocol = provider.create(conf);\n          } else {\n            clientProtocol = provider.create(jobTrackAddr, conf);\n          }\n          if (clientProtocol != null) {\n            clientProtocolProvider = provider;\n            client = clientProtocol;\n            LOG.debug(\"Picked \" + provider.getClass().getName()\n                + \" as the ClientProtocolProvider\");\n            break;\n          }\n          else {\n            LOG.debug(\"Cannot pick \" + provider.getClass().getName()\n                + \" as the ClientProtocolProvider - returned null protocol\");\n          }\n        } \n        catch (Exception e) {\n          LOG.info(\"Failed to use \" + provider.getClass().getName()\n              + \" due to error: \" + e.getMessage());\n        }\n      }\n    }\n    if (null == clientProtocolProvider || null == client) {\n      throw new IOException(\n          \"Cannot initialize Cluster. Please check your configuration for \"\n              + MRConfig.FRAMEWORK_NAME\n              + \" and the correspond server addresses.\");\n    }\n  }\n  ClientProtocol getClient() {\n    return client;\n  }\n  Configuration getConf() {\n    return conf;\n  }\n  /**\n   * Close the <code>Cluster</code>.\n   */\n  public synchronized void close() throws IOException {\n    clientProtocolProvider.close(client);\n  }\n  private Job[] getJobs(JobStatus[] stats) throws IOException {\n    List<Job> jobs = new ArrayList<Job>();\n    for (JobStatus stat : stats) {\n      jobs.add(Job.getInstance(this, stat, new JobConf(stat.getJobFile())));\n    }\n    return jobs.toArray(new Job[0]);\n  }\n  /**\n   * Get the file system where job-specific files are stored\n   * \n   * @return object of FileSystem\n   * @throws IOException\n   * @throws InterruptedException\n   */\n  public synchronized FileSystem getFileSystem() \n      throws IOException, InterruptedException {\n    if (this.fs == null) {\n      try {\n        this.fs = ugi.doAs(new PrivilegedExceptionAction<FileSystem>() {\n          public FileSystem run() throws IOException, InterruptedException {\n            final Path sysDir = new Path(client.getSystemDir());\n            return sysDir.getFileSystem(getConf());\n          }\n        });\n      } catch (InterruptedException e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return fs;\n  }\n  /**\n   * Get job corresponding to jobid.\n   * \n   * @param jobId\n   * @return object of {@link Job}\n   * @throws IOException\n   * @throws InterruptedException\n   */\n  public Job getJob(JobID jobId) throws IOException, InterruptedException {\n    JobStatus status = client.getJobStatus(jobId);\n    if (status != null) {\n      JobConf conf;\n      try {\n        conf = new JobConf(status.getJobFile());\n      } catch (RuntimeException ex) {\n        // If job file doesn't exist it means we can't find the job\n        if (ex.getCause() instanceof FileNotFoundException) {\n          return null;\n        } else {\n          throw ex;\n        }\n      }\n      return Job.getInstance(this, status, conf);\n    }\n    return null;\n  }\n  /**\n   * Get all the queues in cluster.\n   * \n   * @return array of {@link QueueInfo}\n   * @throws IOException\n   * @throws InterruptedException\n   */\n  public QueueInfo[] getQueues() throws IOException, InterruptedException {\n    return client.getQueues();\n  }\n  /**\n   * Get queue information for the specified name.\n   * \n   * @param name queuename\n   * @return object of {@link QueueInfo}\n   * @throws IOException\n   * @throws InterruptedException\n   */\n  public QueueInfo getQueue(String name) \n      throws IOException, InterruptedException {\n    return client.getQueue(name);\n  }\n  /**\n   * Get log parameters for the specified jobID or taskAttemptID\n   * @param jobID the job id.\n   * @param taskAttemptID the task attempt id. Optional.\n   * @return the LogParams\n   * @throws IOException\n   * @throws InterruptedException\n   */\n  public LogParams getLogParams(JobID jobID, TaskAttemptID taskAttemptID)\n      throws IOException, InterruptedException {\n    return client.getLogFileParams(jobID, taskAttemptID);\n  }\n  /**\n   * Get current cluster status.\n   * \n   * @return object of {@link ClusterMetrics}\n   * @throws IOException\n   * @throws InterruptedException\n   */\n  public ClusterMetrics getClusterStatus() throws IOException, InterruptedException {\n    return client.getClusterMetrics();\n  }\n  /**\n   * Get all active trackers in the cluster.\n   * \n   * @return array of {@link TaskTrackerInfo}\n   * @throws IOException\n   * @throws InterruptedException\n   */\n  public TaskTrackerInfo[] getActiveTaskTrackers() \n      throws IOException, InterruptedException  {\n    return client.getActiveTrackers();\n  }\n  /**\n   * Get blacklisted trackers.\n   * \n   * @return array of {@link TaskTrackerInfo}\n   * @throws IOException\n   * @throws InterruptedException\n   */\n  public TaskTrackerInfo[] getBlackListedTaskTrackers() \n      throws IOException, InterruptedException  {\n    return client.getBlacklistedTrackers();\n  }\n  /**\n   * Get all the jobs in cluster.\n   * \n   * @return array of {@link Job}\n   * @throws IOException\n   * @throws InterruptedException\n   * @deprecated Use {@link #getAllJobStatuses()} instead.\n   */\n  @Deprecated\n  public Job[] getAllJobs() throws IOException, InterruptedException {\n    return getJobs(client.getAllJobs());\n  }\n  /**\n   * Get job status for all jobs in the cluster.\n   * @return job status for all jobs in cluster\n   * @throws IOException\n   * @throws InterruptedException\n   */\n  public JobStatus[] getAllJobStatuses() throws IOException, InterruptedException {\n    return client.getAllJobs();\n  }\n  /**\n   * Grab the jobtracker system directory path where \n   * job-specific files will  be placed.\n   * \n   * @return the system directory where job-specific files are to be placed.\n   */\n  public Path getSystemDir() throws IOException, InterruptedException {\n    if (sysDir == null) {\n      sysDir = new Path(client.getSystemDir());\n    }\n    return sysDir;\n  }\n  /**\n   * Grab the jobtracker's view of the staging directory path where \n   * job-specific files will  be placed.\n   * \n   * @return the staging directory where job-specific files are to be placed.\n   */\n  public Path getStagingAreaDir() throws IOException, InterruptedException {\n    if (stagingAreaDir == null) {\n      stagingAreaDir = new Path(client.getStagingAreaDir());\n    }\n    return stagingAreaDir;\n  }\n  /**\n   * Get the job history file path for a given job id. The job history file at \n   * this path may or may not be existing depending on the job completion state.\n   * The file is present only for the completed jobs.\n   * @param jobId the JobID of the job submitted by the current user.\n   * @return the file path of the job history file\n   * @throws IOException\n   * @throws InterruptedException\n   */\n  public String getJobHistoryUrl(JobID jobId) throws IOException, \n    InterruptedException {\n    if (jobHistoryDir == null) {\n      jobHistoryDir = new Path(client.getJobHistoryDir());\n    }\n    return new Path(jobHistoryDir, jobId.toString() + \"_\"\n                    + ugi.getShortUserName()).toString();\n  }\n  /**\n   * Gets the Queue ACLs for current user\n   * @return array of QueueAclsInfo object for current user.\n   * @throws IOException\n   */\n  public QueueAclsInfo[] getQueueAclsForCurrentUser() \n      throws IOException, InterruptedException  {\n    return client.getQueueAclsForCurrentUser();\n  }\n  /**\n   * Gets the root level queues.\n   * @return array of JobQueueInfo object.\n   * @throws IOException\n   */\n  public QueueInfo[] getRootQueues() throws IOException, InterruptedException {\n    return client.getRootQueues();\n  }\n  /**\n   * Returns immediate children of queueName.<fim_middle>// class below is blob and data class\n"}