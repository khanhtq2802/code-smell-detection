{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.hadoop.hdfs.server.namenode;\n\nimport java.io.DataInput;\nimport java.io.DataOutput;\nimport java.io.IOException;\n\nimport org.apache.hadoop.classification.InterfaceAudience;\nimport org.apache.hadoop.hdfs.server.common.StorageInfo;\nimport org.apache.hadoop.hdfs.server.namenode.FSImage;\nimport org.apache.hadoop.io.MD5Hash;\nimport org.apache.hadoop.io.WritableComparable;\nimport org.apache.hadoop.io.WritableUtils;\n\n/**\n * A unique signature intended to identify checkpoint transactions.\n */\n@InterfaceAudience.Private\npublic class CheckpointSignature extends StorageInfo \n                      implements WritableComparable<CheckpointSignature> {\n  private static final String FIELD_SEPARATOR = \":\";\n  long editsTime = -1L;\n  long checkpointTime = -1L;\n  MD5Hash imageDigest = null;\n  String blockpoolID = \"\";\n\n  public CheckpointSignature() {}\n\n  CheckpointSignature(FSImage fsImage) {\n    super(fsImage.getStorage());\n    blockpoolID = fsImage.getBlockPoolID();\n    editsTime = fsImage.getEditLog().getFsEditTime();\n    checkpointTime = fsImage.getStorage().getCheckpointTime();\n    imageDigest = fsImage.getStorage().getImageDigest();\n    checkpointTime = fsImage.getStorage().getCheckpointTime();\n  }\n\n  CheckpointSignature(String str) {\n    String[] fields = str.split(FIELD_SEPARATOR);\n    assert fields.length == 8 : \"Must be 8 fields in CheckpointSignature\";\n    layoutVersion = Integer.valueOf(fields[0]);\n    namespaceID = Integer.valueOf(fields[1]);\n    cTime = Long.valueOf(fields[2]);\n    editsTime = Long.valueOf(fields[3]);\n    checkpointTime = Long.valueOf(fields[4]);\n    imageDigest = new MD5Hash(fields[5]);\n    clusterID = fields[6];\n    blockpoolID = fields[7];\n  }\n\n  /**\n   * Get the MD5 image digest\n   * @return the MD5 image digest\n   */\n  MD5Hash getImageDigest() {\n    return imageDigest;\n  }\n\n  /**\n   * Get the cluster id from CheckpointSignature\n   * @return the cluster id\n   */\n  public String getClusterID() {\n    return clusterID;\n  }\n\n  /**\n   * Get the block pool id from CheckpointSignature\n   * @return the block pool id\n   */\n  public String getBlockpoolID() {\n    return blockpoolID;\n  }\n\n  /**\n   * Set the block pool id of CheckpointSignature.\n   * \n   * @param blockpoolID the new blockpool id\n   */\n  public void setBlockpoolID(String blockpoolID) {\n    this.blockpoolID = blockpoolID;\n  }\n  \n<fim_suffix>  public String toString() {\n    return String.valueOf(layoutVersion) + FIELD_SEPARATOR\n         + String.valueOf(namespaceID) + FIELD_SEPARATOR\n         + String.valueOf(cTime) + FIELD_SEPARATOR\n         + String.valueOf(editsTime) + FIELD_SEPARATOR\n         + String.valueOf(checkpointTime) + FIELD_SEPARATOR\n         + imageDigest.toString() + FIELD_SEPARATOR\n         + clusterID + FIELD_SEPARATOR\n         + blockpoolID ;\n  }\n\n  void validateStorageInfo(FSImage si) throws IOException {\n    if(layoutVersion != si.getLayoutVersion()\n        || namespaceID != si.getNamespaceID() \n        || cTime != si.getStorage().cTime\n        || checkpointTime != si.getStorage().getCheckpointTime() \n        || !imageDigest.equals(si.getStorage().imageDigest)\n        || !clusterID.equals(si.getClusterID())\n        || !blockpoolID.equals(si.getBlockPoolID())) {\n      // checkpointTime can change when the image is saved - do not compare\n      throw new IOException(\"Inconsistent checkpoint fields.\\n\"\n          + \"LV = \" + layoutVersion + \" namespaceID = \" + namespaceID\n          + \" cTime = \" + cTime + \"; checkpointTime = \" + checkpointTime\n          + \" ; imageDigest = \" + imageDigest\n          + \" ; clusterId = \" + clusterID\n          + \" ; blockpoolId = \" + blockpoolID\n          + \".\\nExpecting respectively: \"\n          + si.getLayoutVersion() + \"; \" \n          + si.getNamespaceID() + \"; \" + si.getStorage().cTime\n          + \"; \" + si.getStorage().getCheckpointTime() + \"; \" \n          + si.getStorage().imageDigest\n          + \"; \" + si.getClusterID() + \"; \" \n          + si.getBlockPoolID() + \".\");\n    }\n  }\n\n  //\n  // Comparable interface\n  //\n  public int compareTo(CheckpointSignature o) {\n    return \n      (layoutVersion < o.layoutVersion) ? -1 : \n                  (layoutVersion > o.layoutVersion) ? 1 :\n      (namespaceID < o.namespaceID) ? -1 : (namespaceID > o.namespaceID) ? 1 :\n      (cTime < o.cTime) ? -1 : (cTime > o.cTime) ? 1 :\n      (editsTime < o.editsTime) ? -1 : (editsTime > o.editsTime) ? 1 :\n      (checkpointTime < o.checkpointTime) ? -1 : \n                  (checkpointTime > o.checkpointTime) ? 1 :\n      (clusterID.compareTo(o.clusterID) < 0) ? -1 : \n                  (clusterID.compareTo(o.clusterID) > 0) ? 1 :\n      (blockpoolID.compareTo(o.blockpoolID) < 0) ? -1 : \n                  (blockpoolID.compareTo(o.blockpoolID) > 0) ? 1 :\n                    imageDigest.compareTo(o.imageDigest);\n  }\n\n  public boolean equals(Object o) {\n    if (!(o instanceof CheckpointSignature)) {\n      return false;\n    }\n    return compareTo((CheckpointSignature)o) == 0;\n  }\n\n  public int hashCode() {\n    return layoutVersion ^ namespaceID ^\n            (int)(cTime ^ editsTime ^ checkpointTime) ^\n            imageDigest.hashCode() ^ clusterID.hashCode()\n            ^ blockpoolID.hashCode();\n  }\n\n  /////////////////////////////////////////////////\n  // Writable\n  /////////////////////////////////////////////////\n  public void write(DataOutput out) throws IOException {\n    super.write(out);\n    WritableUtils.writeString(out, blockpoolID);\n    out.writeLong(editsTime);\n    out.writeLong(checkpointTime);\n    imageDigest.write(out);\n  }\n\n  public void readFields(DataInput in) throws IOException {\n    super.readFields(in);\n    blockpoolID = WritableUtils.readString(in);\n    editsTime = in.readLong();\n    checkpointTime = in.readLong();\n    imageDigest = new MD5Hash();\n    imageDigest.readFields(in);\n  }\n}<fim_middle>// function below has no smell\n"}