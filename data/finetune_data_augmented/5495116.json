{"text": "<fim_prefix>/*\n *\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n *\n */\n\npackage org.apache.qpid.server.protocol.v0_10.transport;\n\n\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\nimport org.apache.qpid.server.bytebuffer.QpidByteBuffer;\n\n\n<fim_suffix>public final class MessageTransfer extends Method {\n\n    public static final int TYPE = 1025;\n    private int _bodySize;\n\n    @Override\n    public final int getStructType() {\n        return TYPE;\n    }\n\n    @Override\n    public final int getSizeWidth() {\n        return 0;\n    }\n\n    @Override\n    public final int getPackWidth() {\n        return 2;\n    }\n\n    @Override\n    public final boolean hasPayload() {\n        return true;\n    }\n\n    @Override\n    public final byte getEncodedTrack() {\n        return Frame.L4;\n    }\n\n    @Override\n    public final boolean isConnectionControl()\n    {\n        return false;\n    }\n\n    private short packing_flags = 0;\n    private String destination;\n    private MessageAcceptMode acceptMode;\n    private MessageAcquireMode acquireMode;\n    private Header header;\n    private QpidByteBuffer _body;\n\n\n    public MessageTransfer() {}\n\n    public MessageTransfer(String destination, MessageAcceptMode acceptMode, MessageAcquireMode acquireMode, Header header, java.nio.ByteBuffer body, Option ... options)\n    {\n        this(destination,\n             acceptMode,\n             acquireMode,\n             header,\n             QpidByteBuffer.wrap(body),\n             options);\n    }\n\n    public MessageTransfer(String destination, MessageAcceptMode acceptMode, MessageAcquireMode acquireMode, Header header, QpidByteBuffer body, Option ... _options) {\n        if(destination != null) {\n            setDestination(destination);\n        }\n        if(acceptMode != null) {\n            setAcceptMode(acceptMode);\n        }\n        if(acquireMode != null) {\n            setAcquireMode(acquireMode);\n        }\n        setHeader(header);\n        setBody(body);\n\n        for (int i=0; i < _options.length; i++) {\n            switch (_options[i]) {\n            case SYNC: this.setSync(true); break;\n            case BATCH: this.setBatch(true); break;\n            case UNRELIABLE: this.setUnreliable(true); break;\n            case NONE: break;\n            default: throw new IllegalArgumentException(\"invalid option: \" + _options[i]);\n            }\n        }\n\n    }\n\n    @Override\n    public <C> void dispatch(C context, MethodDelegate<C> delegate) {\n        delegate.messageTransfer(context, this);\n    }\n\n\n    public final boolean hasDestination() {\n        return (packing_flags & 256) != 0;\n    }\n\n    public final MessageTransfer clearDestination() {\n        packing_flags &= ~256;\n        this.destination = null;\n        setDirty(true);\n        return this;\n    }\n\n    public final String getDestination() {\n        return destination;\n    }\n\n    public final MessageTransfer setDestination(String value) {\n        this.destination = value;\n        packing_flags |= 256;\n        setDirty(true);\n        return this;\n    }\n\n    public final MessageTransfer destination(String value) {\n        return setDestination(value);\n    }\n\n    public final boolean hasAcceptMode() {\n        return (packing_flags & 512) != 0;\n    }\n\n    public final MessageTransfer clearAcceptMode() {\n        packing_flags &= ~512;\n        this.acceptMode = null;\n        setDirty(true);\n        return this;\n    }\n\n    public final MessageAcceptMode getAcceptMode() {\n        return acceptMode;\n    }\n\n    public final MessageTransfer setAcceptMode(MessageAcceptMode value) {\n        this.acceptMode = value;\n        packing_flags |= 512;\n        setDirty(true);\n        return this;\n    }\n\n    public final MessageTransfer acceptMode(MessageAcceptMode value) {\n        return setAcceptMode(value);\n    }\n\n    public final boolean hasAcquireMode() {\n        return (packing_flags & 1024) != 0;\n    }\n\n    public final MessageTransfer clearAcquireMode() {\n        packing_flags &= ~1024;\n        this.acquireMode = null;\n        setDirty(true);\n        return this;\n    }\n\n    public final MessageAcquireMode getAcquireMode() {\n        return acquireMode;\n    }\n\n    public final MessageTransfer setAcquireMode(MessageAcquireMode value) {\n        this.acquireMode = value;\n        packing_flags |= 1024;\n        setDirty(true);\n        return this;\n    }\n\n    public final MessageTransfer acquireMode(MessageAcquireMode value) {\n        return setAcquireMode(value);\n    }\n\n\n    @Override\n    public final Header getHeader() {\n        return this.header;\n    }\n\n    @Override\n    public final void setHeader(Header header) {\n        this.header = header;\n    }\n\n    public final MessageTransfer header(Header header)\n    {\n        setHeader(header);\n        return this;\n    }\n\n    @Override\n    public final QpidByteBuffer getBody()\n    {\n        return _body;\n    }\n\n    @Override\n    public final void setBody(QpidByteBuffer body)\n    {\n        if (body == null)\n        {\n            _bodySize = 0;\n            if (_body != null)\n            {\n                _body.dispose();\n            }\n            _body = null;\n        }\n        else\n        {\n            _body = body.duplicate();\n            _bodySize = _body.remaining();\n        }\n    }\n\n    @Override\n    public int getBodySize()\n    {\n        return _bodySize;\n    }\n\n    @Override\n    public void write(Encoder enc)\n    {\n        enc.writeUint16(packing_flags);\n        if ((packing_flags & 256) != 0)\n        {\n            enc.writeStr8(this.destination);\n        }\n        if ((packing_flags & 512) != 0)\n        {\n            enc.writeUint8(this.acceptMode.getValue());\n        }\n        if ((packing_flags & 1024) != 0)\n        {\n            enc.writeUint8(this.acquireMode.getValue());\n        }\n\n    }\n\n    @Override\n    public void read(Decoder dec)\n    {\n        packing_flags = (short) dec.readUint16();\n        if ((packing_flags & 256) != 0)\n        {\n            this.destination = dec.readStr8();\n        }\n        if ((packing_flags & 512) != 0)\n        {\n            this.acceptMode = MessageAcceptMode.get(dec.readUint8());\n        }\n        if ((packing_flags & 1024) != 0)\n        {\n            this.acquireMode = MessageAcquireMode.get(dec.readUint8());\n        }\n\n    }\n\n    @Override\n    public Map<String,Object> getFields()\n    {\n        Map<String,Object> result = new LinkedHashMap<String,Object>();\n\n        if ((packing_flags & 256) != 0)\n        {\n            result.put(\"destination\", getDestination());\n        }\n        if ((packing_flags & 512) != 0)\n        {\n            result.put(\"acceptMode\", getAcceptMode());\n        }\n        if ((packing_flags & 1024) != 0)\n        {\n            result.put(\"acquireMode\", getAcquireMode());\n        }\n\n\n        return result;\n    }\n\n    public void dispose()\n    {\n        if (_body != null)\n        {\n            _body.dispose();\n            _body = null;\n        }\n    }\n}<fim_middle>// class below is data class\n"}