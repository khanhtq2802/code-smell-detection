{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n *  or more contributor license agreements.  See the NOTICE file\n *  distributed with this work for additional information\n *  regarding copyright ownership.  The ASF licenses this file\n *  to you under the Apache License, Version 2.0 (the\n *  \"License\"); you may not use this file except in compliance\n *  with the License.  You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n\npackage org.apache.hadoop.fs.swift.http;\n\nimport org.apache.hadoop.fs.swift.exceptions.SwiftConnectionClosedException;\nimport org.apache.hadoop.fs.swift.util.SwiftUtils;\nimport org.apache.http.HttpResponse;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URI;\n\n/**\n * This replaces the input stream release class from JetS3t and AWS;\n * # Failures in the constructor are relayed up instead of simply logged.\n * # it is set up to be more robust at teardown\n * # release logic is thread safe\n * Note that the thread safety of the inner stream contains no thread\n * safety guarantees -this stream is not to be read across streams.\n * The thread safety logic here is to ensure that even if somebody ignores\n * that rule, the release code does not get entered twice -and that\n * any release in one thread is picked up by read operations in all others.\n */\npublic class HttpInputStreamWithRelease extends InputStream {\n\n  private static final Logger LOG =\n      LoggerFactory.getLogger(HttpInputStreamWithRelease.class);\n  private final URI uri;\n  private HttpRequestBase req;\n  private HttpResponse resp;\n  //flag to say the stream is released -volatile so that read operations\n  //pick it up even while unsynchronized.\n  private volatile boolean released;\n  //volatile flag to verify that data is consumed.\n  private volatile boolean dataConsumed;\n  private InputStream inStream;\n  /**\n   * In debug builds, this is filled in with the construction-time\n   * stack, which is then included in logs from the finalize(), method.\n   */\n  private final Exception constructionStack;\n\n  /**\n   * Why the stream is closed\n   */\n  private String reasonClosed = \"unopened\";\n\n<fim_suffix>  public HttpInputStreamWithRelease(URI uri, HttpRequestBase req,\n      HttpResponse resp) throws IOException {\n    this.uri = uri;\n    this.req = req;\n    this.resp = resp;\n    constructionStack = LOG.isDebugEnabled() ? new Exception(\"stack\") : null;\n    if (req == null) {\n      throw new IllegalArgumentException(\"Null 'request' parameter \");\n    }\n    try {\n      inStream = resp.getEntity().getContent();\n    } catch (IOException e) {\n      inStream = new ByteArrayInputStream(new byte[]{});\n      throw releaseAndRethrow(\"getResponseBodyAsStream() in constructor -\" + e, e);\n    }\n  }\n\n  @Override\n  public void close() throws IOException {\n    release(\"close()\", null);\n  }\n\n  /**\n   * Release logic\n   * @param reason reason for release (used in debug messages)\n   * @param ex exception that is a cause -null for non-exceptional releases\n   * @return true if the release took place here\n   * @throws IOException if the abort or close operations failed.\n   */\n  private synchronized boolean release(String reason, Exception ex) throws\n                                                                   IOException {\n    if (!released) {\n      reasonClosed = reason;\n      try {\n        LOG.debug(\"Releasing connection to {}:  {}\", uri, reason, ex);\n        if (req != null) {\n          if (!dataConsumed) {\n            req.abort();\n          }\n          req.releaseConnection();\n        }\n        if (inStream != null) {\n          //this guard may seem un-needed, but a stack trace seen\n          //on the JetS3t predecessor implied that it\n          //is useful\n          inStream.close();\n        }\n        return true;\n      } finally {\n        //if something went wrong here, we do not want the release() operation\n        //to try and do anything in advance.\n        released = true;\n        dataConsumed = true;\n      }\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Release the method, using the exception as a cause\n   * @param operation operation that failed\n   * @param ex the exception which triggered it.\n   * @return the exception to throw\n   */\n  private IOException releaseAndRethrow(String operation, IOException ex) {\n    try {\n      release(operation, ex);\n    } catch (IOException ioe) {\n      LOG.debug(\"Exception during release: {}\", operation, ioe);\n      //make this the exception if there was none before\n      if (ex == null) {\n        ex = ioe;\n      }\n    }\n    return ex;\n  }\n\n  /**\n   * Assume that the connection is not released: throws an exception if it is\n   * @throws SwiftConnectionClosedException\n   */\n  private synchronized void assumeNotReleased() throws SwiftConnectionClosedException {\n    if (released || inStream == null) {\n      throw new SwiftConnectionClosedException(reasonClosed);\n    }\n  }\n\n  @Override\n  public int available() throws IOException {\n    assumeNotReleased();\n    try {\n      return inStream.available();\n    } catch (IOException e) {\n      throw releaseAndRethrow(\"available() failed -\" + e, e);\n    }\n  }\n\n  @Override\n  public int read() throws IOException {\n    assumeNotReleased();\n    int read = 0;\n    try {\n      read = inStream.read();\n    } catch (EOFException e) {\n      LOG.debug(\"EOF exception\", e);\n      read = -1;\n    } catch (IOException e) {\n      throw releaseAndRethrow(\"read()\", e);\n    }\n    if (read < 0) {\n      dataConsumed = true;\n      release(\"read() -all data consumed\", null);\n    }\n    return read;\n  }\n\n  @Override\n  public int read(byte[] b, int off, int len) throws IOException {\n    SwiftUtils.validateReadArgs(b, off, len);\n    if (len == 0) {\n      return 0;\n    }\n    //if the stream is already closed, then report an exception.\n    assumeNotReleased();\n    //now read in a buffer, reacting differently to different operations\n    int read;\n    try {\n      read = inStream.read(b, off, len);\n    } catch (EOFException e) {\n      LOG.debug(\"EOF exception\", e);\n      read = -1;\n    } catch (IOException e) {\n      throw releaseAndRethrow(\"read(b, off, \" + len + \")\", e);\n    }\n    if (read < 0) {\n      dataConsumed = true;\n      release(\"read() -all data consumed\", null);\n    }\n    return read;\n  }\n\n  /**\n   * Finalizer does release the stream, but also logs at WARN level\n   * including the URI at fault\n   */\n  @Override\n  protected void finalize() {\n    try {\n      if (release(\"finalize()\", constructionStack)) {\n        LOG.warn(\"input stream of {}\" +\n                 \" not closed properly -cleaned up in finalize()\", uri);\n      }\n    } catch (Exception e) {\n      //swallow anything that failed here\n      LOG.warn(\"Exception while releasing {} in finalizer\", uri, e);\n    }\n  }\n\n  @Override\n  public String toString() {\n    return \"HttpInputStreamWithRelease working with \" + uri\n      +\" released=\" + released\n      +\" dataConsumed=\" + dataConsumed;\n  }\n}<fim_middle>// function below has no smell\n"}