{"text": "<fim_prefix> * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.brooklyn.util.collections;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport javax.annotation.Nullable;\nimport org.apache.brooklyn.util.collections.QuorumCheck.QuorumChecks;\nimport com.google.common.base.Function;\nimport com.google.common.base.Functions;\nimport com.google.common.base.Preconditions;\nimport com.google.common.base.Predicate;\nimport com.google.common.base.Predicates;\nimport com.google.common.base.Supplier;\nimport com.google.common.collect.Iterables;\nimport com.google.common.collect.Sets;\n/** things which it seems should be in guava, but i can't find \n * @author alex */\n<fim_suffix>public class CollectionFunctionals {\n    private static final class EqualsSetPredicate implements Predicate<Iterable<?>> {\n        private final Iterable<?> target;\n        private EqualsSetPredicate(Iterable<?> target) {\n            this.target = target;\n        }\n        @Override\n        public boolean apply(@Nullable Iterable<?> input) {\n            if (input==null) return false;\n            return Sets.newHashSet(target).equals(Sets.newHashSet(input));\n        }\n    }\n    private static final class KeysOfMapFunction<K> implements Function<Map<K, ?>, Set<K>> {\n        @Override\n        public Set<K> apply(Map<K, ?> input) {\n            if (input==null) return null;\n            return input.keySet();\n        }\n        @Override public String toString() { return \"keys\"; }\n    }\n    private static final class SizeSupplier implements Supplier<Integer> {\n        private final Iterable<?> collection;\n        private SizeSupplier(Iterable<?> collection) {\n            this.collection = collection;\n        }\n        @Override\n        public Integer get() {\n            return Iterables.size(collection);\n        }\n        @Override public String toString() { return \"sizeSupplier(\"+collection+\")\"; }\n    }\n    public static final class SizeFunction implements Function<Iterable<?>, Integer> {\n        private final Integer valueIfInputNull;\n        private SizeFunction(Integer valueIfInputNull) {\n            this.valueIfInputNull = valueIfInputNull;\n        }\n        @Override\n        public Integer apply(Iterable<?> input) {\n            if (input==null) return valueIfInputNull;\n            return Iterables.size(input);\n        }\n        @Override public String toString() { return \"sizeFunction\"; }\n    }\n    public static Supplier<Integer> sizeSupplier(final Iterable<?> collection) {\n        return new SizeSupplier(collection);\n    }\n    public static Function<Iterable<?>, Integer> sizeFunction() { return sizeFunction(null); }\n    public static Function<Iterable<?>, Integer> sizeFunction(final Integer valueIfInputNull) {\n        return new SizeFunction(valueIfInputNull);\n    }\n    public static final class FirstElementFunction<T> implements Function<Iterable<? extends T>, T> {\n        public FirstElementFunction() {\n        }\n        @Override\n        public T apply(Iterable<? extends T> input) {\n            if (input==null || Iterables.isEmpty(input)) return null;\n            return Iterables.get(input, 0);\n        }\n        @Override public String toString() { return \"firstElementFunction\"; }\n    }\n    public static <T> Function<Iterable<? extends T>, T> firstElement() {\n        return new FirstElementFunction<T>();\n    }\n    public static <K> Function<Map<K,?>,Set<K>> keys() {\n        return new KeysOfMapFunction<K>();\n    }\n    public static <K> Function<Map<K, ?>, Integer> mapSize() {\n        return mapSize(null);\n    }\n    public static <K> Function<Map<K, ?>, Integer> mapSize(Integer valueIfNull) {\n        return Functions.compose(CollectionFunctionals.sizeFunction(valueIfNull), CollectionFunctionals.<K>keys());\n    }\n    /** default guava Equals predicate will reflect order of target, and will fail when matching against a list;\n     * this treats them both as sets */\n    public static Predicate<Iterable<?>> equalsSetOf(Object... target) {\n        return equalsSet(Arrays.asList(target));\n    }\n    public static Predicate<Iterable<?>> equalsSet(final Iterable<?> target) {\n        return new EqualsSetPredicate(target);\n    }\n    public static Predicate<Iterable<?>> sizeEquals(int targetSize) {\n        return Predicates.compose(Predicates.equalTo(targetSize), CollectionFunctionals.sizeFunction());\n    }\n    public static Predicate<Iterable<?>> empty() {\n        return sizeEquals(0);\n    }\n    public static Predicate<Iterable<?>> notEmpty() {\n        return Predicates.not(empty());\n    }\n    public static <K> Predicate<Map<K,?>> mapSizeEquals(int targetSize) {\n        return Predicates.compose(Predicates.equalTo(targetSize), CollectionFunctionals.<K>mapSize());\n    }\n    public static <T,I extends Iterable<T>> Function<I, List<T>> limit(final int max) {\n        return new LimitFunction<T,I>(max);\n    }\n    private static final class LimitFunction<T, I extends Iterable<T>> implements Function<I, List<T>> {\n        private final int max;\n        private LimitFunction(int max) {\n            this.max = max;\n        }\n        @Override\n        public List<T> apply(I input) {\n            if (input==null) return null;\n            MutableList<T> result = MutableList.of();\n            for (T i: input) {\n                result.add(i);\n                if (result.size()>=max)\n                    return result;\n            }\n            return result;\n        }\n    }\n    // ---------\n    public static <I,T extends Collection<I>> Predicate<T> contains(I item) {\n        return new CollectionContains<I,T>(item);\n    }\n    private static final class CollectionContains<I,T extends Collection<I>> implements Predicate<T> {\n        private final I item;\n        private CollectionContains(I item) {\n            this.item = item;\n        }\n        @Override\n        public boolean apply(T input) {\n            if (input==null) return false;\n            return input.contains(item);\n        }\n        @Override\n        public String toString() {\n            return \"contains(\"+item+\")\";\n        }\n    }\n    // ---------\n    /** \n     * Returns a predicate for a collection which is true if \n     * all elements in the collection given to the predicate\n     * which satisfies the predicate given here.\n     * <p>\n     * This will return true for the empty set.\n     * To require additionally that there is at least one\n     * use {@link #quorum(QuorumCheck, Predicate)} with\n     * {@link QuorumChecks#allAndAtLeastOne()}. */\n    public static <T,TT extends Iterable<T>> Predicate<TT> all(Predicate<T> attributeSatisfies) {\n        return quorum(QuorumChecks.all(), attributeSatisfies);\n    }\n    /** Returns a predicate for a collection which is true if \n     * there is at least one element in the collection given to the predicate\n     * which satisfies the predicate given here. \n     */\n    public static <T,TT extends Iterable<T>> Predicate<TT> any(Predicate<T> attributeSatisfies) {\n        // implementation could be more efficient -- ie succeed fast\n        return quorum(QuorumChecks.atLeastOne(), attributeSatisfies);\n    }\n    /** Returns a predicate for a collection which is true if \n     * the number of elements in the collection satisfying the predicate given here\n     * passes the {@link QuorumCheck} given here.\n     */\n    public static <T,TT extends Iterable<T>> Predicate<TT> quorum(QuorumCheck quorumCheck, Predicate<T> attributeSatisfies) {\n        return new QuorumSatisfies<T, TT>(quorumCheck, attributeSatisfies);\n    }\n    private static final class QuorumSatisfies<I,T extends Iterable<I>> implements Predicate<T> {\n        private final Predicate<I> itemCheck;\n        private final QuorumCheck quorumCheck;\n        private QuorumSatisfies(QuorumCheck quorumCheck, Predicate<I> itemCheck) {\n            this.itemCheck = Preconditions.checkNotNull(itemCheck, \"itemCheck\");\n            this.quorumCheck = Preconditions.checkNotNull(quorumCheck, \"quorumCheck\");\n        }\n        @Override\n        public boolean apply(T input) {\n            if (input==null) return false;\n            int sizeHealthy = 0, totalSize = 0;\n            for (I item: input) {\n                totalSize++;\n                if (itemCheck.apply(item)) sizeHealthy++;\n            }\n            return quorumCheck.isQuorate(sizeHealthy, totalSize);\n        }\n        @Override\n        public String toString() {\n            return quorumCheck.toString()+\"(\"+itemCheck+\")\";\n        }\n    }\n}<fim_middle>// class below has no smell\n"}