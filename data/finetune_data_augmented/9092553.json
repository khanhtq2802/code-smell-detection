{"text": "<fim_prefix>                    }\n                    case LANGSXP:\n                    case LISTSXP:\n                    case BCREPDEF:\n                    case BCREPREF:\n                    case ATTRLANGSXP:\n                    case ATTRLISTSXP: {\n                        Object c = readBCLang(type, reps);\n                        ans[i] = c;\n                        break;\n                    }\n                    default:\n                        ans[i] = readItem();\n                }\n            }\n            return RDataFactory.createList(ans);\n        }\n        private Object readBCLang(final SEXPTYPE typeArg, Object[] reps) throws IOException {\n            SEXPTYPE type = typeArg;\n            switch (type) {\n                case BCREPREF:\n                    return reps[stream.readInt()];\n                case BCREPDEF:\n                case LANGSXP:\n                case LISTSXP:\n                case ATTRLANGSXP:\n                case ATTRLISTSXP: {\n                    int pos = -1;\n                    boolean hasattr = false;\n                    if (type == SEXPTYPE.BCREPDEF) {\n                        pos = stream.readInt();\n                        type = SEXPTYPE.mapInt(stream.readInt());\n                    }\n                    switch (type) {\n                        case ATTRLANGSXP:\n                            type = SEXPTYPE.LANGSXP;\n                            hasattr = true;\n                            break;\n                        case ATTRLISTSXP:\n                            type = SEXPTYPE.LISTSXP;\n                            hasattr = true;\n                            break;\n                    }\n                    if (hasattr) {\n                        readItem();\n                        // TODO: why \"assert false;\"???\n                    }\n                    Object tag = readItem();\n                    Object car = readBCLang(SEXPTYPE.mapInt(stream.readInt()), reps);\n                    Object cdr = readBCLang(SEXPTYPE.mapInt(stream.readInt()), reps);\n                    Object ans = RDataFactory.createPairList(car, cdr, tag, type);\n                    if (pos >= 0) {\n                        reps[pos] = ans;\n                    }\n                    return ans;\n                }\n                default: {\n                    Object ans = readItem();\n                    return ans;\n                }\n            }\n        }\n    }\n    private abstract static class PInputStream {\n        protected InputStream is;\n        PInputStream(InputStream is) {\n            this.is = is;\n        }\n        abstract int readInt() throws IOException;\n        abstract String readString(int len) throws IOException;\n        abstract double readDouble() throws IOException;\n        abstract void readRaw(byte[] data) throws IOException;\n    }\n    @SuppressWarnings(\"unused\")\n    private abstract static class AsciiInputFormat extends PInputStream {\n        AsciiInputFormat(InputStream is) {\n            super(is);\n        }\n    }\n    @SuppressWarnings(\"unused\")\n    private abstract static class BinaryInputFormat extends PInputStream {\n        BinaryInputFormat(InputStream is) {\n            super(is);\n        }\n    }\n<fim_suffix>    private static final class XdrInputFormat extends PInputStream {\n        private static final int READ_BUFFER_SIZE = 32 * 1024;\n        private final class Buffer {\n            private final byte[] buf;\n            private int size;\n            private int offset;\n            Buffer(byte[] buf) {\n                this.buf = buf;\n            }\n            int readInt() {\n                return ((buf[offset++] & 0xff) << 24 | (buf[offset++] & 0xff) << 16 | (buf[offset++] & 0xff) << 8 | (buf[offset++] & 0xff));\n            }\n            double readDouble() {\n                long val = ((long) (buf[offset++] & 0xff) << 56 | (long) (buf[offset++] & 0xff) << 48 | (long) (buf[offset++] & 0xff) << 40 | (long) (buf[offset++] & 0xff) << 32 |\n                                (long) (buf[offset++] & 0xff) << 24 | (long) (buf[offset++] & 0xff) << 16 | (long) (buf[offset++] & 0xff) << 8 | buf[offset++] & 0xff);\n                return Double.longBitsToDouble(val);\n            }\n            @SuppressWarnings(\"deprecation\")\n            String readString(int len) {\n                /*\n                 * This fast path uses a cheaper String constructor if all incoming bytes are in the\n                 * 0-127 range.\n                 */\n                boolean fastEncode = true;\n                for (int i = 0; i < len; i++) {\n                    byte b = buf[offset + i];\n                    if (b < 0) {\n                        fastEncode = false;\n                        break;\n                    }\n                }\n                String result;\n                if (fastEncode) {\n                    result = new String(buf, 0, offset, len);\n                } else {\n                    result = new String(buf, offset, len, StandardCharsets.UTF_8);\n                }\n                offset += len;\n                WeakReference<String> entry;\n                if ((entry = strings.get(result)) != null) {\n                    String string = entry.get();\n                    if (string != null) {\n                        return string;\n                    }\n                }\n                strings.put(result, new WeakReference<>(result));\n                return result;\n            }\n            void readRaw(byte[] data) {\n                System.arraycopy(buf, offset, data, 0, data.length);\n                offset += data.length;\n            }\n            void readData(int n) throws IOException {\n                if (offset + n > size) {\n                    if (offset != size) {\n                        // copy end piece to beginning\n                        System.arraycopy(buf, offset, buf, 0, size - offset);\n                    }\n                    size -= offset;\n                    offset = 0;\n                    while (size < n) {\n                        // read some more data\n                        int nread = is.read(buf, size, buf.length - size);\n                        if (nread <= 0) {\n                            throw RInternalError.unimplemented(\"handle unexpected eof\");\n                        }\n                        size += nread;\n                    }\n                }\n            }\n        }\n        /**\n         * This buffer is used under normal circumstances, i.e. when the read data blocks are\n         * smaller than the initial buffer. The ensureData method creates a special buffer for\n         * reading big chunks of data exceeding the default buffer.\n         */\n        private final Buffer defaultBuffer;\n        private final WeakHashMap<String, WeakReference<String>> strings = RContext.getInstance().stringMap;\n        XdrInputFormat(InputStream is) {\n            super(is);\n            if (is instanceof PByteArrayInputStream) {\n                // we already have the data and we have read the beginning\n                PByteArrayInputStream pbis = (PByteArrayInputStream) is;\n                defaultBuffer = new Buffer(pbis.getData());\n                defaultBuffer.size = pbis.getData().length;\n                defaultBuffer.offset = pbis.pos();\n            } else {\n                defaultBuffer = new Buffer(new byte[READ_BUFFER_SIZE]);\n                defaultBuffer.size = 0;\n                defaultBuffer.offset = 0;\n            }\n        }\n        @Override\n        int readInt() throws IOException {\n            return ensureData(4).readInt();\n        }\n        @Override\n        double readDouble() throws IOException {\n            return ensureData(8).readDouble();\n        }\n        @Override\n        String readString(int len) throws IOException {\n            return ensureData(len).readString(len);\n        }\n        @Override\n        void readRaw(byte[] data) throws IOException {\n            ensureData(data.length).readRaw(data);\n        }\n        private Buffer ensureData(int n) throws IOException {\n            Buffer usedBuffer;\n            if (n > defaultBuffer.buf.length) {\n                if (is instanceof PByteArrayInputStream) {\n                    // If the input stream is instance of PByteArrayInputStream, the buffer is\n                    // preloaded and thus no more data can be read beyond the current buffer.\n                    throw new IOException(\"Premature EOF\");\n                }\n                // create an enlarged copy of the default buffer\n                byte[] enlargedBuf = new byte[n];\n                System.arraycopy(defaultBuffer.buf, defaultBuffer.offset, enlargedBuf, defaultBuffer.offset, defaultBuffer.size - defaultBuffer.offset);\n                usedBuffer = new Buffer(enlargedBuf);\n                usedBuffer.offset = defaultBuffer.offset;\n                usedBuffer.size = defaultBuffer.size;\n                // reset the default buffer\n                defaultBuffer.offset = defaultBuffer.size = 0;\n                usedBuffer.readData(n);\n                // The previous statement should entirely fill the temporary buffer.\n                // It is assumed that the caller will read n bytes, making the temporary buffer\n                // disposable. Next time, the default buffer will be used again, unless\n                // n > defaultBuffer.buf.length.\n                assert usedBuffer.size == n;\n            } else {\n                usedBuffer = defaultBuffer;\n                usedBuffer.readData(n);\n            }\n            return usedBuffer;\n        }\n    }<fim_middle>// class below has no smell\n"}