{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.jackrabbit.core.fs.mem;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.FilterOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.apache.jackrabbit.core.fs.FileSystem;\nimport org.apache.jackrabbit.core.fs.FileSystemException;\n\n/**\n * An in-memory file system implementation.\n */\n<fim_suffix>public class MemoryFileSystem implements FileSystem {\n\n    private Map<String, MemoryFileSystemEntry> entries = new HashMap<String, MemoryFileSystemEntry>();\n\n    public void close() {\n    }\n\n    private MemoryFile getFile(String filePath) throws FileSystemException {\n        MemoryFileSystemEntry entry = getEntry(filePath);\n        assertIsFile(filePath);\n        return (MemoryFile) entry;\n    }\n\n    public void createFolder(String folderPath) throws FileSystemException {\n        if (exists(folderPath)) {\n            throw new FileSystemException(\"Folder or file \" + folderPath\n                    + \" already exists\");\n        }\n        if (!exists(FileSystem.SEPARATOR)) {\n            createFolderInternal(\"/\");\n        }\n        String relativePath = folderPath.substring(1);\n        String[] pathElements = relativePath.split(FileSystem.SEPARATOR);\n        String currentFolderPath = \"\";\n        for (int i = 0; i < pathElements.length; i++) {\n            String pathElement = pathElements[i];\n            currentFolderPath += \"/\" + pathElement;\n            createFolderInternal(currentFolderPath);\n        }\n    }\n\n    private void createFolderInternal(String folderPath) {\n        MemoryFolder folder = new MemoryFolder();\n        entries.put(folderPath, folder);\n    }\n\n    public void deleteFile(String filePath) throws FileSystemException {\n        assertExistence(filePath);\n        entries.remove(filePath);\n    }\n\n    public void deleteFolder(String folderPath) throws FileSystemException {\n        assertIsFolder(folderPath);\n        Set<String> selectedNames = new HashSet<String>();\n        for (String name : entries.keySet()) {\n            if (name.equals(folderPath) || name.startsWith(folderPath + SEPARATOR)) {\n                selectedNames.add(name);\n            }\n        }\n        for (String name : selectedNames) {\n            entries.remove(name);\n        }\n    }\n\n    public boolean exists(String path) throws FileSystemException {\n        return entries.containsKey(path);\n    }\n\n    public InputStream getInputStream(String filePath)\n            throws FileSystemException {\n        assertExistence(filePath);\n        assertIsFile(filePath);\n\n        MemoryFile file = getFile(filePath);\n        return new ByteArrayInputStream(file.getData());\n    }\n\n    private void assertIsFolder(String folderPath) throws FileSystemException {\n        assertExistence(folderPath);\n        if (!getEntry(folderPath).isFolder()) {\n            throw new FileSystemException(\"Folder \" + folderPath\n                    + \" does not exist\");\n        }\n    }\n\n    private void assertIsFile(String filePath) throws FileSystemException {\n        if (!isFile(filePath)) {\n            throw new FileSystemException(filePath + \" is a folder\");\n        }\n    }\n\n    public OutputStream getOutputStream(String filePath)\n            throws FileSystemException {\n        if (isFolder(filePath)) {\n            throw new FileSystemException(\"path denotes folder: \" + filePath);\n        }\n\n        String folderPath = filePath;\n        if (filePath.lastIndexOf(FileSystem.SEPARATOR) > 0) {\n            folderPath = filePath.substring(0, filePath.lastIndexOf(\"/\"));\n        } else {\n            folderPath = \"/\";\n        }\n        assertIsFolder(folderPath);\n\n        final MemoryFile file = new MemoryFile();\n        entries.put(filePath, file);\n        return new FilterOutputStream(new ByteArrayOutputStream()) {\n            public void write(byte[] bytes, int off, int len) throws IOException {\n                out.write(bytes, off, len);\n            }\n\n            public void close() throws IOException {\n                out.close();\n                file.setData(((ByteArrayOutputStream) out).toByteArray());\n            }\n        };\n    }\n\n    public boolean hasChildren(String path) throws FileSystemException {\n        assertIsFolder(path);\n        return list(path).length > 0;\n    }\n\n    public void init() {\n        createFolderInternal(\"/\");\n    }\n\n    public boolean isFile(String path) throws FileSystemException {\n        return exists(path) && !getEntry(path).isFolder();\n    }\n\n    private MemoryFileSystemEntry getEntry(String path) {\n        return entries.get(path);\n    }\n\n    private void assertExistence(String path) throws FileSystemException {\n        if (!exists(path)) {\n            throw new FileSystemException(\"no such file \" + path);\n        }\n    }\n\n    public boolean isFolder(String path) throws FileSystemException {\n        if (path.equals(\"/\")) {\n            return true;\n        } else {\n            return exists(path) && getEntry(path).isFolder();\n        }\n    }\n\n    public long lastModified(String path) throws FileSystemException {\n        assertExistence(path);\n        return getEntry(path).getLastModified();\n    }\n\n    public long length(String filePath) throws FileSystemException {\n        assertIsFile(filePath);\n        return getFile(filePath).getData().length;\n    }\n\n    public String[] list(String folderPath) {\n        if (folderPath.equals(\"/\")) {\n            folderPath = \"\";\n        }\n        Set<String> selectedNames = new HashSet<String>();\n        for (String name : entries.keySet()) {\n            if (name.matches(folderPath + \"/[^/]*\") && !name.equals(\"/\")) {\n                selectedNames.add(name.substring(folderPath.length() + 1));\n            }\n        }\n        return selectedNames.toArray(new String[selectedNames.size()]);\n    }\n\n    public String[] listFiles(String folderPath) {\n        return listInternal(folderPath, false);\n    }\n\n    public String[] listFolders(String folderPath) {\n        return listInternal(folderPath, true);\n    }\n\n    private String[] listInternal(String folderPath, boolean isFolder) {\n        String[] names = list(folderPath);\n        if (folderPath.equals(\"/\")) {\n            folderPath = \"\";\n        }\n        Set<String> result = new HashSet<String>();\n        for (String n : names) {\n            if (getEntry(folderPath + \"/\" + n).isFolder() == isFolder) {\n                result.add(n);\n            }\n        }\n        return result.toArray(new String[result.size()]);\n    }\n\n}<fim_middle>// class below has no smell\n"}