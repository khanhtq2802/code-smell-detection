{"text": "<fim_prefix>          // the stack of iterators and start iterating through the current\n          // directory.\n          if (isUnboundedDepth || maxListingDepth > listingDepth) {\n            // Push the current directory on the stack and increment the listing\n            // depth.\n            dirIteratorStack.push(blobItemIterator);\n            ++listingDepth;\n            // The current blob item represents the new directory. Get\n            // an iterator for this directory and continue by iterating through\n            // this directory.\n            blobItems = directory.listBlobs(null, false,\n                EnumSet.noneOf(BlobListingDetails.class), null,\n                getInstrumentedContext());\n            blobItemIterator = blobItems.iterator();\n          } else {\n            // Determine format of directory name depending on whether an\n            // absolute path is being used or not.\n            String dirKey = normalizeKey(directory);\n            if (getDirectoryInList(aFileMetadataList, dirKey) == null) {\n              // Reached the targeted listing depth. Return metadata for the\n              // directory using default permissions.\n              //\n              // Note: Something smarter should be done about permissions. Maybe\n              // inherit the permissions of the first non-directory blob.\n              // Also, getting a proper value for last-modified is tricky.\n              FileMetadata directoryMetadata = new FileMetadata(dirKey, 0,\n                  defaultPermissionNoBlobMetadata(),\n                  BlobMaterialization.Implicit);\n              // Add the directory metadata to the list.\n              aFileMetadataList.add(directoryMetadata);\n            }\n          }\n        }\n      }\n      // Traversal of directory tree\n      // Check if the iterator stack is empty. If it is set the next blob\n      // iterator to null. This will act as a terminator for the for-loop.\n      // Otherwise pop the next iterator from the stack and continue looping.\n      //\n      if (dirIteratorStack.isEmpty()) {\n        blobItemIterator = null;\n      } else {\n        // Pop the next directory item from the stack and decrement the\n        // depth.\n        blobItemIterator = dirIteratorStack.pop();\n        --listingDepth;\n        // Assertion: Listing depth should not be less than zero.\n        if (listingDepth < 0) {\n          throw new AssertionError(\"Non-negative listing depth expected\");\n        }\n      }\n    }\n  }\n  /**\n   * Deletes the given blob, taking special care that if we get a blob-not-found\n   * exception upon retrying the operation, we just swallow the error since what\n   * most probably happened is that the first operation succeeded on the server.\n   * \n   * @param blob\n   *          The blob to delete.\n   * @throws StorageException\n   */\n  private void safeDelete(CloudBlockBlobWrapper blob) throws StorageException {\n    OperationContext operationContext = getInstrumentedContext();\n    try {\n      blob.delete(operationContext);\n    } catch (StorageException e) {\n      // On exception, check that if:\n      // 1. It's a BlobNotFound exception AND\n      // 2. It got there after one-or-more retries THEN\n      // we swallow the exception.\n      if (e.getErrorCode() != null && e.getErrorCode().equals(\"BlobNotFound\")\n          && operationContext.getRequestResults().size() > 1\n          && operationContext.getRequestResults().get(0).getException() != null) {\n        if (LOG.isDebugEnabled()) {\n          LOG.debug(\"Swallowing delete exception on retry: \" + e.getMessage());\n        }\n        return;\n      } else {\n        throw e;\n      }\n    }\n  }\n  @Override\n  public void delete(String key) throws IOException {\n    try {\n      if (checkContainer(ContainerAccessType.ReadThenWrite) == ContainerState.DoesntExist) {\n        // Container doesn't exist, no need to do anything\n        return;\n      }\n      // Get the blob reference an delete it.\n      CloudBlockBlobWrapper blob = getBlobReference(key);\n      if (blob.exists(getInstrumentedContext())) {\n        safeDelete(blob);\n      }\n    } catch (Exception e) {\n      // Re-throw as an Azure storage exception.\n      throw new AzureException(e);\n    }\n  }\n  @Override\n  public void rename(String srcKey, String dstKey) throws IOException {\n    if (LOG.isDebugEnabled()) {\n      LOG.debug(\"Moving \" + srcKey + \" to \" + dstKey);\n    }\n    try {\n      // Attempts rename may occur before opening any streams so first,\n      // check if a session exists, if not create a session with the Azure\n      // storage server.\n      if (null == storageInteractionLayer) {\n        final String errMsg = String.format(\n            \"Storage session expected for URI '%s' but does not exist.\",\n            sessionUri);\n        throw new AssertionError(errMsg);\n      }\n      checkContainer(ContainerAccessType.ReadThenWrite);\n      // Get the source blob and assert its existence. If the source key\n      // needs to be normalized then normalize it.\n      CloudBlockBlobWrapper srcBlob = getBlobReference(srcKey);\n      if (!srcBlob.exists(getInstrumentedContext())) {\n        throw new AzureException(\"Source blob \" + srcKey + \" does not exist.\");\n      }\n      // Get the destination blob. The destination key always needs to be\n      // normalized.\n      CloudBlockBlobWrapper dstBlob = getBlobReference(dstKey);\n      // Rename the source blob to the destination blob by copying it to\n      // the destination blob then deleting it.\n      //\n      dstBlob.startCopyFromBlob(srcBlob, getInstrumentedContext());\n      waitForCopyToComplete(dstBlob, getInstrumentedContext());\n      safeDelete(srcBlob);\n    } catch (Exception e) {\n      // Re-throw exception as an Azure storage exception.\n      throw new AzureException(e);\n    }\n  }\n  private void waitForCopyToComplete(CloudBlockBlobWrapper blob,\n      OperationContext opContext) throws AzureException {\n    boolean copyInProgress = true;\n    int exceptionCount = 0;\n    while (copyInProgress) {\n      try {\n        blob.downloadAttributes(opContext);\n      } catch (StorageException se) {\n        exceptionCount++;\n        if(exceptionCount > 10){\n          throw new AzureException(\"Too many storage exceptions during waitForCopyToComplete\", se);\n        }\n      }\n      // test for null because mocked filesystem doesn't know about copystates\n      // yet.\n      copyInProgress = (blob.getCopyState() != null && blob.getCopyState()\n          .getStatus() == CopyStatus.PENDING);\n      if (copyInProgress) {\n        try {\n          Thread.sleep(1000);\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n        }\n      }\n    }\n  }\n  /**\n   * Changes the permission status on the given key.\n   */\n  @Override\n  public void changePermissionStatus(String key, PermissionStatus newPermission)\n      throws AzureException {\n    try {\n      checkContainer(ContainerAccessType.ReadThenWrite);\n      CloudBlockBlobWrapper blob = getBlobReference(key);\n      blob.downloadAttributes(getInstrumentedContext());\n      storePermissionStatus(blob, newPermission);\n      blob.uploadMetadata(getInstrumentedContext());\n    } catch (Exception e) {\n      throw new AzureException(e);\n    }\n  }\n  @Override\n  public void purge(String prefix) throws IOException {\n    try {\n      // Attempts to purge may occur before opening any streams so first,\n      // check if a session exists, if not create a session with the Azure\n      // storage server.\n      if (null == storageInteractionLayer) {\n        final String errMsg = String.format(\n            \"Storage session expected for URI '%s' but does not exist.\",\n            sessionUri);\n        throw new AssertionError(errMsg);\n      }\n      if (checkContainer(ContainerAccessType.ReadThenWrite) == ContainerState.DoesntExist) {\n        // Container doesn't exist, no need to do anything.\n        return;\n      }\n      // Get all blob items with the given prefix from the container and delete\n      // them.\n      Iterable<ListBlobItem> objects = listRootBlobs(prefix, false);\n      for (ListBlobItem blobItem : objects) {\n        ((CloudBlob) blobItem).delete(DeleteSnapshotsOption.NONE, null, null,\n            getInstrumentedContext());\n      }\n    } catch (Exception e) {\n      // Re-throw as an Azure storage exception.\n      //\n      throw new AzureException(e);\n    }\n  }\n  @Override\n  public void updateFolderLastModifiedTime(String key, Date lastModified)\n      throws AzureException {\n    try {\n      checkContainer(ContainerAccessType.ReadThenWrite);\n      CloudBlockBlobWrapper blob = getBlobReference(key);\n      blob.getProperties().setLastModified(lastModified);\n      blob.uploadProperties(getInstrumentedContext());\n    } catch (Exception e) {\n      // Caught exception while attempting update the properties. Re-throw as an\n      // Azure storage exception.\n      throw new AzureException(e);\n    }\n  }\n  @Override\n  public void updateFolderLastModifiedTime(String key) throws AzureException {\n    final Calendar lastModifiedCalendar = Calendar\n        .getInstance(Utility.LOCALE_US);\n    lastModifiedCalendar.setTimeZone(Utility.UTC_ZONE);\n    Date lastModified = lastModifiedCalendar.getTime();\n    updateFolderLastModifiedTime(key, lastModified);\n  }\n  @Override\n  public void dump() throws IOException {\n  }\n<fim_suffix>  @Override\n  public void close() {\n    bandwidthGaugeUpdater.close();\n  }<fim_middle>// function below has no smell\n"}