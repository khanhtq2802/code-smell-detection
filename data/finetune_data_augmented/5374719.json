{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.pig.backend.hadoop.executionengine.spark.converter;\n\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.apache.pig.backend.hadoop.executionengine.spark.PairFlatMapFunctionAdapter;\nimport org.apache.pig.backend.hadoop.executionengine.spark.SparkShims;\nimport org.apache.pig.backend.hadoop.executionengine.spark.SparkUtil;\nimport org.apache.spark.api.java.function.Function2;\nimport scala.Tuple2;\nimport scala.runtime.AbstractFunction1;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.apache.pig.backend.hadoop.executionengine.spark.operator.POSampleSortSpark;\nimport org.apache.pig.data.BagFactory;\nimport org.apache.pig.data.DataBag;\nimport org.apache.pig.data.DefaultBagFactory;\nimport org.apache.pig.data.Tuple;\nimport org.apache.pig.data.TupleFactory;\nimport org.apache.spark.api.java.JavaPairRDD;\nimport org.apache.spark.api.java.JavaRDD;\nimport org.apache.spark.api.java.function.Function;\nimport org.apache.spark.rdd.RDD;\n\n/*\n sort the sample data and convert the sample data to the format (all,{(sampleEle1),(sampleEle2),...})\n */\n@SuppressWarnings(\"serial\")\npublic class SparkSampleSortConverter implements RDDConverter<Tuple, Tuple, POSampleSortSpark> {\n    private static final Log LOG = LogFactory.getLog(SparkSampleSortConverter.class);\n    private static TupleFactory tf = TupleFactory.getInstance();\n    private static BagFactory bf = DefaultBagFactory.getInstance();\n\n    @Override\n    public RDD<Tuple> convert(List<RDD<Tuple>> predecessors, POSampleSortSpark sortOperator)\n            throws IOException {\n        SparkUtil.assertPredecessorSize(predecessors, sortOperator, 1);\n        RDD<Tuple> rdd = predecessors.get(0);\n        RDD<Tuple2<Tuple, Object>> rddPair = rdd.map(new ToKeyValueFunction(),\n                SparkUtil.<Tuple, Object> getTuple2Manifest());\n\n        JavaPairRDD<Tuple, Object> r = new JavaPairRDD<Tuple, Object>(rddPair,\n                SparkUtil.getManifest(Tuple.class),\n                SparkUtil.getManifest(Object.class));\n         //sort sample data\n        JavaPairRDD<Tuple, Object> sorted = r.sortByKey(true);\n         //convert every element in sample data from element to (all, element) format\n        JavaPairRDD<String, Tuple> mapped = sorted.mapPartitionsToPair(SparkShims.getInstance().pairFlatMapFunction(new AggregateFunction()));\n        //use groupByKey to aggregate all values( the format will be ((all),{(sampleEle1),(sampleEle2),...} )\n        JavaRDD<Tuple> groupByKey= mapped.groupByKey().map(new ToValueFunction());\n        return  groupByKey.rdd();\n    }\n\n\n    private static class MergeFunction implements Function2<Tuple, Tuple, Tuple>\n            , Serializable {\n\n        @Override\n        public Tuple call(Tuple v1, Tuple v2) {\n                Tuple res = tf.newTuple();\n                res.append(v1);\n                res.append(v2);\n                LOG.info(\"MergeFunction out:\"+res);\n                return res;\n        }\n    }\n\n    // input: Tuple2<Tuple,Object>\n    // output: Tuple2(\"all\", Tuple)\n    private static class AggregateFunction implements\n            PairFlatMapFunctionAdapter<Iterator<Tuple2<Tuple, Object>>, String,Tuple>, Serializable {\n\n        private class Tuple2TransformIterable implements Iterable<Tuple2<String,Tuple>> {\n\n            Iterator<Tuple2<Tuple, Object>> in;\n\n            Tuple2TransformIterable(Iterator<Tuple2<Tuple, Object>> input) {\n                in = input;\n            }\n\n            public Iterator<Tuple2<String,Tuple>> iterator() {\n                return new IteratorTransform<Tuple2<Tuple, Object>, Tuple2<String,Tuple>>(in) {\n                    @Override\n                    protected Tuple2<String,Tuple> transform(Tuple2<Tuple, Object> next) {\n                        LOG.info(\"AggregateFunction in:\"+ next._1()) ;\n                        return new Tuple2<String,Tuple>(\"all\",next._1());\n                    }\n                };\n            }\n        }\n\n        @Override\n        public Iterator<Tuple2<String, Tuple>> call(Iterator<Tuple2<Tuple, Object>> input) throws Exception {\n            return new Tuple2TransformIterable(input).iterator();\n        }\n\n    }\n\n<fim_suffix>    private static class ToValueFunction implements Function<Tuple2<String, Iterable<Tuple>>, Tuple> {\n        @Override\n        public Tuple call(Tuple2<String, Iterable<Tuple>> next) throws Exception {\n            Tuple res = tf.newTuple();\n            res.append(next._1());\n            Iterator<Tuple> iter = next._2().iterator();\n            DataBag bag = bf.newDefaultBag();\n            while(iter.hasNext()) {\n                bag.add(iter.next());\n            }\n            res.append(bag);\n            LOG.info(\"ToValueFunction1 out:\" + res);\n            return res;\n        }\n    }\n\n    private static class ToKeyValueFunction extends\n            AbstractFunction1<Tuple, Tuple2<Tuple, Object>> implements\n            Serializable {\n\n        @Override\n        public Tuple2<Tuple, Object> apply(Tuple t) {\n            if (LOG.isDebugEnabled()) {\n                LOG.info(\"Sort ToKeyValueFunction in \" + t);\n            }\n            Tuple key = t;\n            Object value = null;\n            // (key, value)\n            Tuple2<Tuple, Object> out = new Tuple2<Tuple, Object>(key, value);\n            if (LOG.isDebugEnabled()) {\n                LOG.info(\"Sort ToKeyValueFunction out \" + out);\n            }\n            return out;\n        }\n    }\n}<fim_middle>// class below has no smell\n"}