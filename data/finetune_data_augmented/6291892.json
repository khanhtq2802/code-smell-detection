{"text": "<fim_prefix>//\n//  ========================================================================\n//  Copyright (c) 1995-2019 Mort Bay Consulting Pty. Ltd.\n//  ------------------------------------------------------------------------\n//  All rights reserved. This program and the accompanying materials\n//  are made available under the terms of the Eclipse Public License v1.0\n//  and Apache License v2.0 which accompanies this distribution.\n//\n//      The Eclipse Public License is available at\n//      http://www.eclipse.org/legal/epl-v10.html\n//\n//      The Apache License v2.0 is available at\n//      http://www.opensource.org/licenses/apache2.0.php\n//\n//  You may elect to redistribute this code under either of these licenses.\n//  ========================================================================\n//\npackage org.eclipse.jetty.fcgi.parser;\nimport java.io.EOFException;\nimport java.nio.ByteBuffer;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport org.eclipse.jetty.fcgi.FCGI;\nimport org.eclipse.jetty.http.BadMessageException;\nimport org.eclipse.jetty.http.HttpField;\nimport org.eclipse.jetty.http.HttpFields;\nimport org.eclipse.jetty.http.HttpHeader;\nimport org.eclipse.jetty.http.HttpParser;\nimport org.eclipse.jetty.http.HttpStatus;\nimport org.eclipse.jetty.http.HttpVersion;\nimport org.eclipse.jetty.util.log.Log;\nimport org.eclipse.jetty.util.log.Logger;\n/**\n * <p>The parser for STDOUT type frame bodies.</p>\n * <p>STDOUT frame bodies contain both the HTTP headers (but not the response line)\n * and the HTTP content (either Content-Length delimited or chunked).</p>\n * <p>For this reason, a special HTTP parser is used to parse the frames body.\n * This special HTTP parser is configured to skip the response line, and to\n * parse HTTP headers and HTTP content.</p>\n */\npublic class ResponseContentParser extends StreamContentParser\n{\n    private static final Logger LOG = Log.getLogger(ResponseContentParser.class);\n    private final Map<Integer, ResponseParser> parsers = new ConcurrentHashMap<>();\n    private final ClientParser.Listener listener;\n    public ResponseContentParser(HeaderParser headerParser, ClientParser.Listener listener)\n    {\n        super(headerParser, FCGI.StreamType.STD_OUT, listener);\n        this.listener = listener;\n    }\n    @Override\n    public void noContent()\n    {\n        // Does nothing, since for responses the end of content is signaled via a FCGI_END_REQUEST frame\n    }\n    @Override\n    protected boolean onContent(ByteBuffer buffer)\n    {\n        int request = getRequest();\n        ResponseParser parser = parsers.get(request);\n        if (parser == null)\n        {\n            parser = new ResponseParser(listener, request);\n            parsers.put(request, parser);\n        }\n        return parser.parse(buffer);\n    }\n    @Override\n    protected void end(int request)\n    {\n        super.end(request);\n        parsers.remove(request);\n    }\n    private class ResponseParser implements HttpParser.ResponseHandler\n    {\n        private final HttpFields fields = new HttpFields();\n        private ClientParser.Listener listener;\n        private final int request;\n        private final FCGIHttpParser httpParser;\n        private State state = State.HEADERS;\n        private boolean seenResponseCode;\n        private ResponseParser(ClientParser.Listener listener, int request)\n        {\n            this.listener = listener;\n            this.request = request;\n            this.httpParser = new FCGIHttpParser(this);\n        }\n        public boolean parse(ByteBuffer buffer)\n        {\n            int remaining = buffer.remaining();\n            while (remaining > 0)\n            {\n                if (LOG.isDebugEnabled())\n                    LOG.debug(\"Response {} {}, state {} {}\", request, FCGI.StreamType.STD_OUT, state, buffer);\n                switch (state)\n                {\n                    case HEADERS:\n                    {\n                        if (httpParser.parseNext(buffer))\n                            state = State.CONTENT_MODE;\n                        remaining = buffer.remaining();\n                        break;\n                    }\n                    case CONTENT_MODE:\n                    {\n                        // If we have no indication of the content, then\n                        // the HTTP parser will assume there is no content\n                        // and will not parse it even if it is provided,\n                        // so we have to parse it raw ourselves here.\n                        boolean rawContent = fields.size() == 0 ||\n                                (fields.get(HttpHeader.CONTENT_LENGTH) == null &&\n                                        fields.get(HttpHeader.TRANSFER_ENCODING) == null);\n                        state = rawContent ? State.RAW_CONTENT : State.HTTP_CONTENT;\n                        break;\n                    }\n                    case RAW_CONTENT:\n                    {\n                        if (notifyContent(buffer))\n                            return true;\n                        remaining = 0;\n                        break;\n                    }\n                    case HTTP_CONTENT:\n                    {\n                        if (httpParser.parseNext(buffer))\n                            return true;\n                        remaining = buffer.remaining();\n                        break;\n                    }\n                    default:\n                    {\n                        throw new IllegalStateException();\n                    }\n                }\n            }\n            return false;\n        }\n        @Override\n        public int getHeaderCacheSize()\n        {\n            // TODO: configure this\n            return 4096;\n        }\n        @Override\n        public boolean startResponse(HttpVersion version, int status, String reason)\n        {\n            // The HTTP request line does not exist in FCGI responses\n            throw new IllegalStateException();\n        }\n        @Override\n        public void parsedHeader(HttpField httpField)\n        {\n            try\n            {\n                String name = httpField.getName();\n                if (\"Status\".equalsIgnoreCase(name))\n                {\n                    if (!seenResponseCode)\n                    {\n                        seenResponseCode = true;\n                        // Need to set the response status so the\n                        // HttpParser can handle the content properly.\n                        String value = httpField.getValue();\n                        String[] parts = value.split(\" \");\n                        String status = parts[0];\n                        int code = Integer.parseInt(status);\n                        httpParser.setResponseStatus(code);\n                        String reason = parts.length > 1 ? value.substring(status.length()) : HttpStatus.getMessage(code);\n                        notifyBegin(code, reason.trim());\n                        notifyHeaders(fields);\n                    }\n                }\n                else\n                {\n                    fields.add(httpField);\n                    if (seenResponseCode)\n                        notifyHeader(httpField);\n                }\n            }\n            catch (Throwable x)\n            {\n                if (LOG.isDebugEnabled())\n                    LOG.debug(\"Exception while invoking listener \" + listener, x);\n            }\n        }\n        private void notifyBegin(int code, String reason)\n        {\n            try\n            {\n                listener.onBegin(request, code, reason);\n            }\n            catch (Throwable x)\n            {\n                if (LOG.isDebugEnabled())\n                    LOG.debug(\"Exception while invoking listener \" + listener, x);\n            }\n        }\n        private void notifyHeader(HttpField httpField)\n        {\n            try\n            {\n                listener.onHeader(request, httpField);\n            }\n            catch (Throwable x)\n            {\n                if (LOG.isDebugEnabled())\n                    LOG.debug(\"Exception while invoking listener \" + listener, x);\n            }\n        }\n        private void notifyHeaders(HttpFields fields)\n        {\n            if (fields != null)\n            {\n                for (HttpField field : fields)\n                    notifyHeader(field);\n            }\n        }\n        private void notifyHeaders()\n        {\n            try\n            {\n                listener.onHeaders(request);\n            }\n            catch (Throwable x)\n            {\n                if (LOG.isDebugEnabled())\n                    LOG.debug(\"Exception while invoking listener \" + listener, x);\n            }\n        }\n        @Override\n        public boolean headerComplete()\n        {\n            if (!seenResponseCode)\n            {\n                // No Status header but we have other headers, assume 200 OK.\n                notifyBegin(200, \"OK\");\n                notifyHeaders(fields);\n            }\n            notifyHeaders();\n            // Return from HTTP parsing so that we can parse the content.\n            return true;\n        }\n        @Override\n        public boolean content(ByteBuffer buffer)\n        {\n            return notifyContent(buffer);\n        }\n<fim_suffix>        private boolean notifyContent(ByteBuffer buffer)\n        {\n            try\n            {\n                return listener.onContent(request, FCGI.StreamType.STD_OUT, buffer);\n            }\n            catch (Throwable x)\n            {\n                if (LOG.isDebugEnabled())\n                    LOG.debug(\"Exception while invoking listener \" + listener, x);\n                return false;\n            }\n        }\n        @Override\n        public boolean contentComplete()\n        {\n            return false;\n        }\n        @Override\n        public boolean messageComplete()\n        {\n            // No need to notify the end of the response to the\n            // listener because it will be done by FCGI_END_REQUEST.\n            return false;\n        }\n        @Override\n        public void earlyEOF()\n        {\n            fail(new EOFException());\n        }\n        @Override\n        public void badMessage(BadMessageException failure)\n        {\n            fail(failure);\n        }\n        protected void fail(Throwable failure)\n        {\n            try\n            {\n                listener.onFailure(request, failure);\n            }\n            catch (Throwable x)\n            {\n                if (LOG.isDebugEnabled())\n                    LOG.debug(\"Exception while invoking listener \" + listener, x);\n            }\n        }\n    }\n    // Methods overridden to make them visible here<fim_middle>// function below has no smell\n"}