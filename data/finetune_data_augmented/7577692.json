{"text": "<fim_prefix>\t\tMetadataReader reader = this.metadataReaderFactory.getMetadataReader(className);\n\t\tprocessConfigurationClass(new ConfigurationClass(reader, beanName));\n\t}\n\tprotected final void parse(Class<?> clazz, String beanName) throws IOException {\n\t\tprocessConfigurationClass(new ConfigurationClass(clazz, beanName));\n\t}\n\tprotected final void parse(AnnotationMetadata metadata, String beanName) throws IOException {\n\t\tprocessConfigurationClass(new ConfigurationClass(metadata, beanName));\n\t}\n\t/**\n\t * Validate each {@link ConfigurationClass} object.\n\t * @see ConfigurationClass#validate\n\t */\n\tpublic void validate() {\n\t\tfor (ConfigurationClass configClass : this.configurationClasses.keySet()) {\n\t\t\tconfigClass.validate(this.problemReporter);\n\t\t}\n\t}\n\tpublic Set<ConfigurationClass> getConfigurationClasses() {\n\t\treturn this.configurationClasses.keySet();\n\t}\n\tprotected void processConfigurationClass(ConfigurationClass configClass) throws IOException {\n\t\tif (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) {\n\t\t\treturn;\n\t\t}\n\t\tConfigurationClass existingClass = this.configurationClasses.get(configClass);\n\t\tif (existingClass != null) {\n\t\t\tif (configClass.isImported()) {\n\t\t\t\tif (existingClass.isImported()) {\n\t\t\t\t\texistingClass.mergeImportedBy(configClass);\n\t\t\t\t}\n\t\t\t\t// Otherwise ignore new imported config class; existing non-imported class overrides it.\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Explicit bean definition found, probably replacing an import.\n\t\t\t\t// Let's remove the old one and go with the new one.\n\t\t\t\tthis.configurationClasses.remove(configClass);\n\t\t\t\tthis.knownSuperclasses.values().removeIf(configClass::equals);\n\t\t\t}\n\t\t}\n\t\t// Recursively process the configuration class and its superclass hierarchy.\n\t\tSourceClass sourceClass = asSourceClass(configClass);\n\t\tdo {\n\t\t\tsourceClass = doProcessConfigurationClass(configClass, sourceClass);\n\t\t}\n\t\twhile (sourceClass != null);\n\t\tthis.configurationClasses.put(configClass, configClass);\n\t}\n\t/**\n\t * Apply processing and build a complete {@link ConfigurationClass} by reading the\n\t * annotations, members and methods from the source class. This method can be called\n\t * multiple times as relevant sources are discovered.\n\t * @param configClass the configuration class being build\n\t * @param sourceClass a source class\n\t * @return the superclass, or {@code null} if none found or previously processed\n\t */\n\t@Nullable\n\tprotected final SourceClass doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)\n\t\t\tthrows IOException {\n\t\tif (configClass.getMetadata().isAnnotated(Component.class.getName())) {\n\t\t\t// Recursively process any member (nested) classes first\n\t\t\tprocessMemberClasses(configClass, sourceClass);\n\t\t}\n\t\t// Process any @PropertySource annotations\n\t\tfor (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(\n\t\t\t\tsourceClass.getMetadata(), PropertySources.class,\n\t\t\t\torg.springframework.context.annotation.PropertySource.class)) {\n\t\t\tif (this.environment instanceof ConfigurableEnvironment) {\n\t\t\t\tprocessPropertySource(propertySource);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlogger.info(\"Ignoring @PropertySource annotation on [\" + sourceClass.getMetadata().getClassName() +\n\t\t\t\t\t\t\"]. Reason: Environment must implement ConfigurableEnvironment\");\n\t\t\t}\n\t\t}\n\t\t// Process any @ComponentScan annotations\n\t\tSet<AnnotationAttributes> componentScans = AnnotationConfigUtils.attributesForRepeatable(\n\t\t\t\tsourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);\n\t\tif (!componentScans.isEmpty() &&\n\t\t\t\t!this.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) {\n\t\t\tfor (AnnotationAttributes componentScan : componentScans) {\n\t\t\t\t// The config class is annotated with @ComponentScan -> perform the scan immediately\n\t\t\t\tSet<BeanDefinitionHolder> scannedBeanDefinitions =\n\t\t\t\t\t\tthis.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());\n\t\t\t\t// Check the set of scanned definitions for any further config classes and parse recursively if needed\n\t\t\t\tfor (BeanDefinitionHolder holder : scannedBeanDefinitions) {\n\t\t\t\t\tBeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();\n\t\t\t\t\tif (bdCand == null) {\n\t\t\t\t\t\tbdCand = holder.getBeanDefinition();\n\t\t\t\t\t}\n\t\t\t\t\tif (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, this.metadataReaderFactory)) {\n\t\t\t\t\t\tparse(bdCand.getBeanClassName(), holder.getBeanName());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Process any @Import annotations\n\t\tprocessImports(configClass, sourceClass, getImports(sourceClass), true);\n\t\t// Process any @ImportResource annotations\n\t\tAnnotationAttributes importResource =\n\t\t\t\tAnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);\n\t\tif (importResource != null) {\n\t\t\tString[] resources = importResource.getStringArray(\"locations\");\n\t\t\tClass<? extends BeanDefinitionReader> readerClass = importResource.getClass(\"reader\");\n\t\t\tfor (String resource : resources) {\n\t\t\t\tString resolvedResource = this.environment.resolveRequiredPlaceholders(resource);\n\t\t\t\tconfigClass.addImportedResource(resolvedResource, readerClass);\n\t\t\t}\n\t\t}\n\t\t// Process individual @Bean methods\n\t\tSet<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(sourceClass);\n\t\tfor (MethodMetadata methodMetadata : beanMethods) {\n\t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n\t\t}\n\t\t// Process default methods on interfaces\n\t\tprocessInterfaces(configClass, sourceClass);\n\t\t// Process superclass, if any\n\t\tif (sourceClass.getMetadata().hasSuperClass()) {\n\t\t\tString superclass = sourceClass.getMetadata().getSuperClassName();\n\t\t\tif (superclass != null && !superclass.startsWith(\"java\") &&\n\t\t\t\t\t!this.knownSuperclasses.containsKey(superclass)) {\n\t\t\t\tthis.knownSuperclasses.put(superclass, configClass);\n\t\t\t\t// Superclass found, return its annotation metadata and recurse\n\t\t\t\treturn sourceClass.getSuperClass();\n\t\t\t}\n\t\t}\n\t\t// No superclass -> processing is complete\n\t\treturn null;\n\t}\n\t/**\n\t * Register member (nested) classes that happen to be configuration classes themselves.\n\t */\n\tprivate void processMemberClasses(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n\t\tCollection<SourceClass> memberClasses = sourceClass.getMemberClasses();\n\t\tif (!memberClasses.isEmpty()) {\n\t\t\tList<SourceClass> candidates = new ArrayList<>(memberClasses.size());\n\t\t\tfor (SourceClass memberClass : memberClasses) {\n\t\t\t\tif (ConfigurationClassUtils.isConfigurationCandidate(memberClass.getMetadata()) &&\n\t\t\t\t\t\t!memberClass.getMetadata().getClassName().equals(configClass.getMetadata().getClassName())) {\n\t\t\t\t\tcandidates.add(memberClass);\n\t\t\t\t}\n\t\t\t}\n\t\t\tOrderComparator.sort(candidates);\n\t\t\tfor (SourceClass candidate : candidates) {\n\t\t\t\tif (this.importStack.contains(configClass)) {\n\t\t\t\t\tthis.problemReporter.error(new CircularImportProblem(configClass, this.importStack));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.importStack.push(configClass);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tprocessConfigurationClass(candidate.asConfigClass(configClass));\n\t\t\t\t\t}\n\t\t\t\t\tfinally {\n\t\t\t\t\t\tthis.importStack.pop();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * Register default methods on interfaces implemented by the configuration class.\n\t */\n<fim_suffix>\tprivate void processInterfaces(ConfigurationClass configClass, SourceClass sourceClass) throws IOException {\n\t\tfor (SourceClass ifc : sourceClass.getInterfaces()) {\n\t\t\tSet<MethodMetadata> beanMethods = retrieveBeanMethodMetadata(ifc);\n\t\t\tfor (MethodMetadata methodMetadata : beanMethods) {\n\t\t\t\tif (!methodMetadata.isAbstract()) {\n\t\t\t\t\t// A default method or other concrete method on a Java 8+ interface...\n\t\t\t\t\tconfigClass.addBeanMethod(new BeanMethod(methodMetadata, configClass));\n\t\t\t\t}\n\t\t\t}\n\t\t\tprocessInterfaces(configClass, ifc);\n\t\t}\n\t}<fim_middle>// function below has no smell\n"}