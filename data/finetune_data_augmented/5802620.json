{"text": "<fim_prefix>// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\npackage org.apache.tapestry5.internal.structure;\nimport org.apache.tapestry5.*;\nimport org.apache.tapestry5.annotations.*;\nimport org.apache.tapestry5.dom.Element;\nimport org.apache.tapestry5.internal.AbstractEventContext;\nimport org.apache.tapestry5.internal.InternalComponentResources;\nimport org.apache.tapestry5.internal.InternalConstants;\nimport org.apache.tapestry5.internal.services.ComponentEventImpl;\nimport org.apache.tapestry5.internal.services.Instantiator;\nimport org.apache.tapestry5.internal.util.NamedSet;\nimport org.apache.tapestry5.internal.util.NotificationEventCallback;\nimport org.apache.tapestry5.ioc.BaseLocatable;\nimport org.apache.tapestry5.ioc.Invokable;\nimport org.apache.tapestry5.ioc.Location;\nimport org.apache.tapestry5.ioc.internal.util.CollectionFactory;\nimport org.apache.tapestry5.ioc.internal.util.InternalUtils;\nimport org.apache.tapestry5.ioc.internal.util.Orderer;\nimport org.apache.tapestry5.ioc.internal.util.TapestryException;\nimport org.apache.tapestry5.ioc.services.PerThreadValue;\nimport org.apache.tapestry5.ioc.util.AvailableValues;\nimport org.apache.tapestry5.ioc.util.UnknownValueException;\nimport org.apache.tapestry5.model.ComponentModel;\nimport org.apache.tapestry5.model.ParameterModel;\nimport org.apache.tapestry5.runtime.Component;\nimport org.apache.tapestry5.runtime.*;\nimport org.apache.tapestry5.services.pageload.ComponentResourceSelector;\nimport org.slf4j.Logger;\nimport java.util.*;\n/**\n * Implements {@link RenderCommand} and represents a component within an overall page. Much of a\n * component page\n * element's behavior is delegated to user code, via a {@link org.apache.tapestry5.runtime.Component} instance.\n *\n * Once instantiated, a ComponentPageElement should be registered as a\n * {@linkplain org.apache.tapestry5.internal.structure.Page#addLifecycleListener(org.apache.tapestry5.runtime.PageLifecycleListener)\n * lifecycle listener}. This could be done inside the constructors, but that tends to complicate unit tests, so its done\n * by {@link org.apache.tapestry5.internal.services.PageElementFactoryImpl}. There's still a bit of refactoring in this\n * class (and its many inner classes) that can improve overall efficiency.\n *\n * Modified for Tapestry 5.2 to adjust for the no-pooling approach (shared instances with externalized mutable state).\n */\npublic class ComponentPageElementImpl extends BaseLocatable implements ComponentPageElement\n{\n    /**\n     * Placeholder for the body used when the component has no real content.\n     */\n    private static class PlaceholderBlock implements Block, Renderable, RenderCommand\n    {\n        public void render(MarkupWriter writer)\n        {\n        }\n        public void render(MarkupWriter writer, RenderQueue queue)\n        {\n        }\n        @Override\n        public String toString()\n        {\n            return \"<PlaceholderBlock>\";\n        }\n    }\n    private static final Block PLACEHOLDER_BLOCK = new PlaceholderBlock();\n    private static final ComponentCallback POST_RENDER_CLEANUP = new LifecycleNotificationComponentCallback()\n    {\n        public void run(Component component)\n        {\n            component.postRenderCleanup();\n        }\n    };\n    // For the moment, every component will have a template, even if it consists of\n    // just a page element to queue up a BeforeRenderBody phase.\n    private static void pushElements(RenderQueue queue, List<RenderCommand> list)\n    {\n        int count = size(list);\n        for (int i = count - 1; i >= 0; i--)\n            queue.push(list.get(i));\n    }\n    private static int size(List<?> list)\n    {\n        return list == null ? 0 : list.size();\n    }\n    private abstract class AbstractPhase implements RenderCommand\n    {\n        private final String name;\n        private final boolean reverse;\n        AbstractPhase(String name)\n        {\n            this(name, false);\n        }\n        AbstractPhase(String name, boolean reverse)\n        {\n            this.name = name;\n            this.reverse = reverse;\n        }\n        @Override\n        public String toString()\n        {\n            return phaseToString(name);\n        }\n        void invoke(MarkupWriter writer, Event event)\n        {\n            try\n            {\n                if (components == null)\n                {\n                    invokeComponent(coreComponent, writer, event);\n                    return;\n                }\n                // Multiple components (i.e., some mixins).\n                Iterator<Component> i = reverse ? InternalUtils.reverseIterator(components) : components.iterator();\n                while (i.hasNext())\n                {\n                    invokeComponent(i.next(), writer, event);\n                    if (event.isAborted())\n                        break;\n                }\n            }\n            // This used to be RuntimeException, but with TAP5-1508 changes to RenderPhaseMethodWorker, we now\n            // let ordinary exceptions bubble up as well.\n            catch (Exception ex)\n            {\n                throw new TapestryException(ex.getMessage(), getLocation(), ex);\n            }\n        }\n        /**\n         * Each concrete class implements this method to branch to the corresponding method\n         * of {@link Component}.\n         */\n        protected abstract void invokeComponent(Component component, MarkupWriter writer, Event event);\n    }\n    private class SetupRenderPhase extends AbstractPhase\n    {\n        public SetupRenderPhase()\n        {\n            super(\"SetupRender\");\n        }\n        protected void invokeComponent(Component component, MarkupWriter writer, Event event)\n        {\n            component.setupRender(writer, event);\n        }\n        public void render(MarkupWriter writer, RenderQueue queue)\n        {\n            RenderPhaseEvent event = createRenderEvent(queue);\n            invoke(writer, event);\n            push(queue, event.getResult(), beginRenderPhase, cleanupRenderPhase);\n            event.enqueueSavedRenderCommands();\n        }\n    }\n<fim_suffix>    private class BeginRenderPhase extends AbstractPhase\n    {\n        private BeginRenderPhase()\n        {\n            super(\"BeginRender\");\n        }\n        protected void invokeComponent(Component component, MarkupWriter writer, Event event)\n        {\n            if (isRenderTracingEnabled())\n                writer.comment(\"BEGIN \" + component.getComponentResources().getCompleteId() + \" (\" + getLocation()\n                        + \")\");\n            component.beginRender(writer, event);\n        }\n        public void render(final MarkupWriter writer, final RenderQueue queue)\n        {\n            RenderPhaseEvent event = createRenderEvent(queue);\n            invoke(writer, event);\n            push(queue, afterRenderPhase);\n            push(queue, event.getResult(), beforeRenderTemplatePhase, null);\n            event.enqueueSavedRenderCommands();\n        }\n    }\n    /**\n     * Replaces {@link org.apache.tapestry5.internal.structure.ComponentPageElementImpl.BeginRenderPhase} when there is\n     * a handler for AfterRender but not BeginRender.\n     */\n    private class OptimizedBeginRenderPhase implements RenderCommand\n    {\n        public void render(MarkupWriter writer, RenderQueue queue)\n        {\n            push(queue, afterRenderPhase);\n            push(queue, beforeRenderTemplatePhase);\n        }\n        @Override\n        public String toString()\n        {\n            return phaseToString(\"OptimizedBeginRenderPhase\");\n        }\n    }\n    /**\n     * Reponsible for rendering the component's template. Even a component that doesn't have a\n     * template goes through\n     * this phase, as a synthetic template (used to trigger the rendering of the component's body)\n     * will be supplied.\n     */\n    private class BeforeRenderTemplatePhase extends AbstractPhase\n    {\n        private BeforeRenderTemplatePhase()\n        {\n            super(\"BeforeRenderTemplate\");\n        }\n        protected void invokeComponent(Component component, MarkupWriter writer, Event event)\n        {\n            component.beforeRenderTemplate(writer, event);\n        }\n        public void render(final MarkupWriter writer, final RenderQueue queue)\n        {\n            RenderPhaseEvent event = createRenderEvent(queue);\n            invoke(writer, event);\n            push(queue, afterRenderTemplatePhase);\n            if (event.getResult())\n                pushElements(queue, template);\n            event.enqueueSavedRenderCommands();\n        }\n    }\n    /**\n     * Alternative version of BeforeRenderTemplatePhase used when the BeforeRenderTemplate render\n     * phase is not handled.\n     */\n    private class RenderTemplatePhase implements RenderCommand\n    {\n        public void render(MarkupWriter writer, RenderQueue queue)\n        {<fim_middle>// class below has no smell\n"}