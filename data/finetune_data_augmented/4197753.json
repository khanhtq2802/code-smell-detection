{"text": "<fim_prefix>        Pair<CommitLogPosition, Long> record = getTruncationRecord(id);\n        return record == null ? Long.MIN_VALUE : record.right;\n    }\n    private static synchronized Pair<CommitLogPosition, Long> getTruncationRecord(TableId id)\n    {\n        if (truncationRecords == null)\n            truncationRecords = readTruncationRecords();\n        return truncationRecords.get(id);\n    }\n    private static Map<TableId, Pair<CommitLogPosition, Long>> readTruncationRecords()\n    {\n        UntypedResultSet rows = executeInternal(format(\"SELECT truncated_at FROM system.%s WHERE key = '%s'\", LOCAL, LOCAL));\n        Map<TableId, Pair<CommitLogPosition, Long>> records = new HashMap<>();\n        if (!rows.isEmpty() && rows.one().has(\"truncated_at\"))\n        {\n            Map<UUID, ByteBuffer> map = rows.one().getMap(\"truncated_at\", UUIDType.instance, BytesType.instance);\n            for (Map.Entry<UUID, ByteBuffer> entry : map.entrySet())\n                records.put(TableId.fromUUID(entry.getKey()), truncationRecordFromBlob(entry.getValue()));\n        }\n        return records;\n    }\n    private static Pair<CommitLogPosition, Long> truncationRecordFromBlob(ByteBuffer bytes)\n    {\n        try (RebufferingInputStream in = new DataInputBuffer(bytes, true))\n        {\n            return Pair.create(CommitLogPosition.serializer.deserialize(in), in.available() > 0 ? in.readLong() : Long.MIN_VALUE);\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(e);\n        }\n    }\n    /**\n     * Record tokens being used by another node\n     */\n    public static synchronized void updateTokens(InetAddressAndPort ep, Collection<Token> tokens)\n    {\n        if (ep.equals(FBUtilities.getBroadcastAddressAndPort()))\n            return;\n        String req = \"INSERT INTO system.%s (peer, tokens) VALUES (?, ?)\";\n        executeInternal(String.format(req, LEGACY_PEERS), ep.address, tokensAsSet(tokens));\n        req = \"INSERT INTO system.%s (peer, peer_port, tokens) VALUES (?, ?, ?)\";\n        executeInternal(String.format(req, PEERS_V2), ep.address, ep.port, tokensAsSet(tokens));\n    }\n    public static synchronized void updatePreferredIP(InetAddressAndPort ep, InetAddressAndPort preferred_ip)\n    {\n        if (getPreferredIP(ep) == preferred_ip)\n            return;\n        String req = \"INSERT INTO system.%s (peer, preferred_ip) VALUES (?, ?)\";\n        executeInternal(String.format(req, LEGACY_PEERS), ep.address, preferred_ip.address);\n        req = \"INSERT INTO system.%s (peer, peer_port, preferred_ip, preferred_port) VALUES (?, ?, ?, ?)\";\n        executeInternal(String.format(req, PEERS_V2), ep.address, ep.port, preferred_ip.address, preferred_ip.port);\n        forceBlockingFlush(LEGACY_PEERS, PEERS_V2);\n    }\n    public static synchronized void updatePeerInfo(InetAddressAndPort ep, String columnName, Object value)\n    {\n        if (ep.equals(FBUtilities.getBroadcastAddressAndPort()))\n            return;\n        String req = \"INSERT INTO system.%s (peer, %s) VALUES (?, ?)\";\n        executeInternal(String.format(req, LEGACY_PEERS, columnName), ep.address, value);\n        //This column doesn't match across the two tables\n        if (columnName.equals(\"rpc_address\"))\n        {\n            columnName = \"native_address\";\n        }\n        req = \"INSERT INTO system.%s (peer, peer_port, %s) VALUES (?, ?, ?)\";\n        executeInternal(String.format(req, PEERS_V2, columnName), ep.address, ep.port, value);\n    }\n    public static synchronized void updatePeerNativeAddress(InetAddressAndPort ep, InetAddressAndPort address)\n    {\n        if (ep.equals(FBUtilities.getBroadcastAddressAndPort()))\n            return;\n        String req = \"INSERT INTO system.%s (peer, rpc_address) VALUES (?, ?)\";\n        executeInternal(String.format(req, LEGACY_PEERS), ep.address, address.address);\n        req = \"INSERT INTO system.%s (peer, peer_port, native_address, native_port) VALUES (?, ?, ?, ?)\";\n        executeInternal(String.format(req, PEERS_V2), ep.address, ep.port, address.address, address.port);\n    }\n    public static synchronized void updateHintsDropped(InetAddressAndPort ep, UUID timePeriod, int value)\n    {\n        // with 30 day TTL\n        String req = \"UPDATE system.%s USING TTL 2592000 SET hints_dropped[ ? ] = ? WHERE peer = ?\";\n        executeInternal(String.format(req, LEGACY_PEER_EVENTS), timePeriod, value, ep.address);\n        req = \"UPDATE system.%s USING TTL 2592000 SET hints_dropped[ ? ] = ? WHERE peer = ? AND peer_port = ?\";\n        executeInternal(String.format(req, PEER_EVENTS_V2), timePeriod, value, ep.address, ep.port);\n    }\n    public static synchronized void updateSchemaVersion(UUID version)\n    {\n        String req = \"INSERT INTO system.%s (key, schema_version) VALUES ('%s', ?)\";\n        executeInternal(format(req, LOCAL, LOCAL), version);\n    }\n    private static Set<String> tokensAsSet(Collection<Token> tokens)\n    {\n        if (tokens.isEmpty())\n            return Collections.emptySet();\n        Token.TokenFactory factory = StorageService.instance.getTokenFactory();\n        Set<String> s = new HashSet<>(tokens.size());\n        for (Token tk : tokens)\n            s.add(factory.toString(tk));\n        return s;\n    }\n    private static Collection<Token> deserializeTokens(Collection<String> tokensStrings)\n    {\n        Token.TokenFactory factory = StorageService.instance.getTokenFactory();\n        List<Token> tokens = new ArrayList<>(tokensStrings.size());\n        for (String tk : tokensStrings)\n            tokens.add(factory.fromString(tk));\n        return tokens;\n    }\n    /**\n     * Remove stored tokens being used by another node\n     */\n    public static synchronized void removeEndpoint(InetAddressAndPort ep)\n    {\n        String req = \"DELETE FROM system.%s WHERE peer = ?\";\n        executeInternal(String.format(req, LEGACY_PEERS), ep.address);\n        req = String.format(\"DELETE FROM system.%s WHERE peer = ? AND peer_port = ?\", PEERS_V2);\n        executeInternal(req, ep.address, ep.port);\n        forceBlockingFlush(LEGACY_PEERS, PEERS_V2);\n    }\n    /**\n     * This method is used to update the System Keyspace with the new tokens for this node\n     */\n    public static synchronized void updateTokens(Collection<Token> tokens)\n    {\n        assert !tokens.isEmpty() : \"removeEndpoint should be used instead\";\n        Collection<Token> savedTokens = getSavedTokens();\n        if (tokens.containsAll(savedTokens) && tokens.size() == savedTokens.size())\n            return;\n        String req = \"INSERT INTO system.%s (key, tokens) VALUES ('%s', ?)\";\n        executeInternal(format(req, LOCAL, LOCAL), tokensAsSet(tokens));\n        forceBlockingFlush(LOCAL);\n    }\n    public static void forceBlockingFlush(String ...cfnames)\n    {\n        if (!DatabaseDescriptor.isUnsafeSystem())\n        {\n            List<ListenableFuture<CommitLogPosition>> futures = new ArrayList<>();\n            for (String cfname : cfnames)\n            {\n                futures.add(Keyspace.open(SchemaConstants.SYSTEM_KEYSPACE_NAME).getColumnFamilyStore(cfname).forceFlush());\n            }\n            FBUtilities.waitOnFutures(futures);\n        }\n    }\n    /**\n     * Return a map of stored tokens to IP addresses\n     *\n     */\n<fim_suffix>    public static SetMultimap<InetAddressAndPort, Token> loadTokens()\n    {\n        SetMultimap<InetAddressAndPort, Token> tokenMap = HashMultimap.create();\n        for (UntypedResultSet.Row row : executeInternal(\"SELECT peer, peer_port, tokens FROM system.\" + PEERS_V2))\n        {\n            InetAddress address = row.getInetAddress(\"peer\");\n            Integer port = row.getInt(\"peer_port\");\n            InetAddressAndPort peer = InetAddressAndPort.getByAddressOverrideDefaults(address, port);\n            if (row.has(\"tokens\"))\n                tokenMap.putAll(peer, deserializeTokens(row.getSet(\"tokens\", UTF8Type.instance)));\n        }\n        return tokenMap;\n    }<fim_middle>// function below has no smell\n"}