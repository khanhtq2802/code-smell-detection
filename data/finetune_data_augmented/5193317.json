{"text": "<fim_prefix>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.sshd.common.channel;\n\nimport java.io.IOException;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Objects;\n\nimport org.apache.sshd.client.future.OpenFuture;\nimport org.apache.sshd.common.AttributeRepository;\nimport org.apache.sshd.common.AttributeStore;\nimport org.apache.sshd.common.Closeable;\nimport org.apache.sshd.common.PropertyResolver;\nimport org.apache.sshd.common.channel.throttle.ChannelStreamPacketWriterResolverManager;\nimport org.apache.sshd.common.io.PacketWriter;\nimport org.apache.sshd.common.session.ConnectionService;\nimport org.apache.sshd.common.session.Session;\nimport org.apache.sshd.common.util.GenericUtils;\nimport org.apache.sshd.common.util.buffer.Buffer;\n\n/**\n * Represents a channel opened over an SSH session - holds information that is\n * common both to server and client channels.\n *\n * @author <a href=\"mailto:dev@mina.apache.org\">Apache MINA SSHD Project</a>\n */\n<fim_suffix>public interface Channel\n        extends ChannelListenerManager,\n                PropertyResolver,\n                AttributeStore,\n                PacketWriter,\n                ChannelStreamPacketWriterResolverManager,\n                Closeable {\n    // Known types of channels\n    String CHANNEL_EXEC = \"exec\";\n    String CHANNEL_SHELL = \"shell\";\n    String CHANNEL_SUBSYSTEM = \"subsystem\";\n\n    /**\n     * @return Local channel identifier\n     */\n    int getId();\n\n    /**\n     * @return Remote channel identifier\n     */\n    int getRecipient();\n\n    /**\n     * @return The channel's underlying {@link Session}\n     */\n    Session getSession();\n\n    Window getLocalWindow();\n\n    Window getRemoteWindow();\n\n    List<RequestHandler<Channel>> getRequestHandlers();\n\n    void addRequestHandler(RequestHandler<Channel> handler);\n\n    default void addRequestHandlers(Collection<? extends RequestHandler<Channel>> handlers) {\n        GenericUtils.forEach(handlers, this::addRequestHandler);\n    }\n\n    void removeRequestHandler(RequestHandler<Channel> handler);\n\n    default void removeRequestHandlers(Collection<? extends RequestHandler<Channel>> handlers) {\n        GenericUtils.forEach(handlers, this::removeRequestHandler);\n    }\n\n    /**\n     * Invoked when <code>SSH_MSG_CHANNEL_CLOSE</code> received\n     *\n     * @throws IOException If failed to handle the message\n     */\n    void handleClose() throws IOException;\n\n    /**\n     * Invoked when <code>SSH_MSG_CHANNEL_WINDOW_ADJUST</code> received\n     *\n     * @param buffer The rest of the message data {@link Buffer} after\n     * decoding the channel identifiers\n     * @throws IOException If failed to handle the message\n     */\n    void handleWindowAdjust(Buffer buffer) throws IOException;\n\n    /**\n     * Invoked when <code>SSH_MSG_CHANNEL_REQUEST</code> received\n     *\n     * @param buffer The rest of the message data {@link Buffer} after\n     * decoding the channel identifiers\n     * @throws IOException If failed to handle the message\n     */\n    void handleRequest(Buffer buffer) throws IOException;\n\n    /**\n     * Invoked when <code>SSH_MSG_CHANNEL_DATA</code> received\n     *\n     * @param buffer The rest of the message data {@link Buffer} after\n     * decoding the channel identifiers\n     * @throws IOException If failed to handle the message\n     */\n    void handleData(Buffer buffer) throws IOException;\n\n    /**\n     * Invoked when <code>SSH_MSG_CHANNEL_EXTENDED_DATA</code> received\n     *\n     * @param buffer The rest of the message data {@link Buffer} after\n     * decoding the channel identifiers\n     * @throws IOException If failed to handle the message\n     */\n    void handleExtendedData(Buffer buffer) throws IOException;\n\n    /**\n     * Invoked when <code>SSH_MSG_CHANNEL_EOF</code> received\n     *\n     * @throws IOException If failed to handle the message\n     */\n    void handleEof() throws IOException;\n\n    /**\n     * Invoked when <code>SSH_MSG_CHANNEL_SUCCESS</code> received\n     *\n     * @throws IOException If failed to handle the message\n     */\n    void handleSuccess() throws IOException;\n\n    /**\n     * Invoked when <code>SSH_MSG_CHANNEL_FAILURE</code> received\n     *\n     * @throws IOException If failed to handle the message\n     */\n    void handleFailure() throws IOException;\n\n    /**\n     * Invoked when the local channel is initial created\n     *\n     * @param service The {@link ConnectionService} through which the channel is initialized\n     * @param session The {@link Session} associated with the channel\n     * @param id The locally assigned channel identifier\n     * @throws IOException If failed to process the initialization\n     */\n    void init(ConnectionService service, Session session, int id) throws IOException;\n\n    /**\n     * @return {@code true} if call to {@link #init(ConnectionService, Session, int)} was\n     * successfully completed\n     */\n    boolean isInitialized();\n\n    /**\n     * @return {@code true} if the peer signaled that it will not send any\n     * more data\n     * @see <A HREF=\"https://tools.ietf.org/html/rfc4254#section-5.3\">RFC 4254 - section 5.3 - SSH_MSG_CHANNEL_EOF</A>\n     */\n    boolean isEofSignalled();\n\n    /**\n     * For a server channel, this method will actually open the channel\n     *\n     * @param recipient  Recipient identifier\n     * @param rwSize     Read/Write window size ({@code uint32})\n     * @param packetSize Preferred maximum packet size ({@code uint32})\n     * @param buffer     Incoming {@link Buffer} that triggered the call.\n     *                   <B>Note:</B> the buffer's read position is exactly\n     *                   <U>after</U> the information that read to this call\n     *                   was decoded\n     * @return An {@link OpenFuture} for the channel open request\n     */\n    OpenFuture open(int recipient, long rwSize, long packetSize, Buffer buffer);\n\n    /**\n     * For a client channel, this method will be called internally by the\n     * session when the confirmation has been received.\n     *\n     * @param recipient  Recipient identifier\n     * @param rwSize     Read/Write window size ({@code uint32})\n     * @param packetSize Preferred maximum packet size ({@code uint32})\n     * @param buffer     Incoming {@link Buffer} that triggered the call.\n     *                   <B>Note:</B> the buffer's read position is exactly\n     *                   <U>after</U> the information that read to this call\n     *                   was decoded\n     * @throws IOException If failed to handle the success\n     */\n    void handleOpenSuccess(int recipient, long rwSize, long packetSize, Buffer buffer) throws IOException;\n\n    /**\n     * For a client channel, this method will be called internally by the\n     * session when the server has rejected this channel opening.\n     *\n     * @param buffer     Incoming {@link Buffer} that triggered the call.\n     *                   <B>Note:</B> the buffer's read position is exactly\n     *                   <U>after</U> the information that read to this call\n     *                   was decoded\n     * @throws IOException If failed to handle the success\n     */\n    void handleOpenFailure(Buffer buffer) throws IOException;\n\n    @Override\n    default <T> T resolveAttribute(AttributeRepository.AttributeKey<T> key) {\n        return resolveAttribute(this, key);\n    }\n\n    /**\n     * Attempts to use the channel attribute, if not found then tries the session\n     *\n     * @param <T> The generic attribute type\n     * @param channel The {@link Channel} - ignored if {@code null}\n     * @param key The attribute key - never {@code null}\n     * @return Associated value - {@code null} if not found\n     * @see #getSession()\n     * @see Session#resolveAttribute(Session, AttributeRepository.AttributeKey)\n     */\n    static <T> T resolveAttribute(Channel channel, AttributeRepository.AttributeKey<T> key) {\n        Objects.requireNonNull(key, \"No key\");\n        if (channel == null) {\n            return null;\n        }\n\n        T value = channel.getAttribute(key);\n        return (value != null) ? value : Session.resolveAttribute(channel.getSession(), key);\n    }\n}<fim_middle>// class below has no smell\n"}