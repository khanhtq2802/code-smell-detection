{"text": "<fim_prefix>    }\n    mergeBatchRowCount = rowsPerBatch(mergeBatchSize.dataSize);\n    mergeMemoryLimit = Math.max(2 * spillBatchSize.expectedBufferSize, memoryLimit - mergeBatchSize.maxBufferSize);\n  }\n  /**\n   * Log the calculated values. Turn this on if things seem amiss.\n   * Message will appear only when the values change.\n   */\n  private void logSettings(int actualRecordCount) {\n    logger.debug(\"Input Batch Estimates: record size = {} bytes; net = {} bytes, gross = {}, records = {}\",\n                 estimatedRowWidth, inputBatchSize.dataSize,\n                 inputBatchSize.expectedBufferSize, actualRecordCount);\n    logger.debug(\"Spill batch size: net = {} bytes, gross = {} bytes, records = {}; spill file = {} bytes\",\n                 spillBatchSize.dataSize, spillBatchSize.expectedBufferSize,\n                 spillBatchRowCount, config.spillFileSize());\n    logger.debug(\"Output batch size: net = {} bytes, gross = {} bytes, records = {}\",\n                 mergeBatchSize.dataSize, mergeBatchSize.expectedBufferSize,\n                 mergeBatchRowCount);\n    logger.debug(\"Available memory: {}, buffer memory = {}, merge memory = {}\",\n                 memoryLimit, bufferMemoryLimit, mergeMemoryLimit);\n    // Performance warnings due to low row counts per batch.\n    // Low row counts cause excessive per-batch overhead and hurt\n    // performance.\n    if (spillBatchRowCount < MIN_ROWS_PER_SORT_BATCH) {\n      logger.warn(\"Potential performance degredation due to low memory or large input row. \" +\n                  \"Preferred spill batch row count: {}, actual: {}\",\n                  MIN_ROWS_PER_SORT_BATCH, spillBatchRowCount);\n      performanceWarning = true;\n    }\n    if (mergeBatchRowCount < MIN_ROWS_PER_SORT_BATCH) {\n      logger.warn(\"Potential performance degredation due to low memory or large input row. \" +\n                  \"Preferred merge batch row count: {}, actual: {}\",\n                  MIN_ROWS_PER_SORT_BATCH, mergeBatchRowCount);\n      performanceWarning = true;\n    }\n  }\n  public enum MergeAction { SPILL, MERGE, NONE }\n  public static class MergeTask {\n    public MergeAction action;\n    public int count;\n    public MergeTask(MergeAction action, int count) {\n      this.action = action;\n      this.count = count;\n    }\n  }\n  /**\n   * Choose a consolidation option during the merge phase depending on memory\n   * available. Preference is given to moving directly onto merging (with no\n   * additional spilling) when possible. But, if memory pressures don't allow\n   * this, we must spill batches and/or merge on-disk spilled runs, to reduce\n   * the final set of runs to something that can be merged in the available\n   * memory.\n   * <p>\n   * Logic is here (returning an enum) rather than in the merge code to allow\n   * unit testing without actually needing batches in memory.\n   *\n   * @param allocMemory\n   *          amount of memory currently allocated (this class knows the total\n   *          memory available)\n   * @param inMemCount\n   *          number of incoming batches in memory (the number is important, not\n   *          the in-memory size; we get the memory size from\n   *          <tt>allocMemory</tt>)\n   * @param spilledRunsCount\n   *          the number of runs sitting on disk to be merged\n   * @return whether to <tt>SPILL</tt> in-memory batches, whether to\n   *         <tt>MERGE<tt> on-disk batches to create a new, larger run, or whether\n   *         to do nothing (<tt>NONE</tt>) and instead advance to the final merge\n   */\n  public MergeTask consolidateBatches(long allocMemory, int inMemCount, int spilledRunsCount) {\n    assert allocMemory == 0 || inMemCount > 0;\n    assert inMemCount + spilledRunsCount > 0;\n    // If only one spilled run, then merging is not productive regardless\n    // of memory limits.\n    if (inMemCount == 0 && spilledRunsCount <= 1) {\n      return new MergeTask(MergeAction.NONE, 0);\n    }\n    // If memory is above the merge memory limit, then must spill\n    // merge to create room for a merge batch.\n    if (allocMemory > mergeMemoryLimit) {\n      return new MergeTask(MergeAction.SPILL, 0);\n    }\n    // Determine additional memory needed to hold one batch from each\n    // spilled run.\n    // Maximum spill batches that fit into available memory.\n    // Use the maximum buffer size since spill batches seem to\n    // be read with almost 50% internal fragmentation.\n    int memMergeLimit = (int) ((mergeMemoryLimit - allocMemory) /\n                                spillBatchSize.maxBufferSize);\n    memMergeLimit = Math.max(0, memMergeLimit);\n    // If batches are in memory, and final merge count will exceed\n    // merge limit or we need more memory to merge them all than is\n    // actually available, then spill some in-memory batches.\n    if (inMemCount > 0  &&  ((inMemCount + spilledRunsCount) > config.mergeLimit() || memMergeLimit < spilledRunsCount)) {\n      return new MergeTask(MergeAction.SPILL, 0);\n    }\n    // If all batches fit in memory, then no need for a second-generation\n    // merge/spill.\n    memMergeLimit = Math.min(memMergeLimit, config.mergeLimit());\n    int mergeRunCount = spilledRunsCount - memMergeLimit;\n    if (mergeRunCount <= 0) {\n      return new MergeTask(MergeAction.NONE, 0);\n    }\n    // We need a second generation load-merge-spill cycle\n    // to reduce the number of spilled runs to a smaller set\n    // that will fit in memory.\n    // Merging creates another batch. Include one more run\n    // in the merge to create space for the new run.\n    mergeRunCount += 1;\n    // Merge only as many batches as fit in memory.\n    // Use all memory for this process; no need to reserve space for a\n    // merge output batch. Assume worst case since we are forced to\n    // accept spilled batches blind: we can't limit reading based on memory\n    // limits. Subtract one to allow for the output spill batch.\n    memMergeLimit = (int)(memoryLimit / spillBatchSize.maxBufferSize) - 1;\n    mergeRunCount = Math.min(mergeRunCount, memMergeLimit);\n    // Must merge at least 2 batches to make progress.\n    // We know we have at least two because of the check done above.\n    mergeRunCount = Math.max(mergeRunCount, 2);\n    // Can't merge more than the merge limit.\n    mergeRunCount = Math.min(mergeRunCount, config.mergeLimit());\n    return new MergeTask(MergeAction.MERGE, mergeRunCount);\n  }\n  /**\n   * Compute the number of rows that fit into a given batch data size.\n   *\n   * @param batchSize expected batch size, including internal fragmentation\n   * @return number of rows that fit into the batch\n   */\n  private int rowsPerBatch(int batchSize) {\n    int rowCount = batchSize / estimatedRowWidth;\n    return Math.max(1, Math.min(rowCount, Character.MAX_VALUE));\n  }\n  public static int multiply(int byteSize, double multiplier) {\n    return (int) Math.floor(byteSize * multiplier);\n  }\n  // Must spill if we are below the spill point (the amount of memory\n  // needed to do the minimal spill.)\n  public boolean isSpillNeeded(long allocatedBytes, long incomingSize) {\n    return allocatedBytes + incomingSize >= bufferMemoryLimit;\n  }\n  public boolean hasMemoryMergeCapacity(long allocatedBytes, long neededForInMemorySort) {\n    return (freeMemory(allocatedBytes) >= neededForInMemorySort);\n  }\n  public long freeMemory(long allocatedBytes) {\n    return memoryLimit - allocatedBytes;\n  }\n  public long getMergeMemoryLimit() { return mergeMemoryLimit; }\n  public int getSpillBatchRowCount() { return spillBatchRowCount; }\n  public int getMergeBatchRowCount() { return mergeBatchRowCount; }\n  // Primarily for testing\n  @VisibleForTesting\n  public long getMemoryLimit() { return memoryLimit; }\n  @VisibleForTesting\n  public int getRowWidth() { return estimatedRowWidth; }\n  @VisibleForTesting\n  public BatchSizeEstimate getInputBatchSize() { return inputBatchSize; }\n  @VisibleForTesting\n  public int getPreferredSpillBatchSize() { return preferredSpillBatchSize; }\n<fim_suffix>  @VisibleForTesting\n  public int getPreferredMergeBatchSize() { return preferredMergeBatchSize; }<fim_middle>// function below has no smell\n"}