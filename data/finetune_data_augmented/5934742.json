{"text": "<fim_prefix>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.zookeeper.server;\n\n\n\nimport org.apache.zookeeper.common.Time;\nimport org.apache.zookeeper.server.metric.AvgMinMaxCounter;\nimport org.apache.zookeeper.server.quorum.BufferStats;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.concurrent.atomic.AtomicLong;\n\n/**\n * Basic Server Statistics\n */\npublic class ServerStats {\n    private static final Logger LOG = LoggerFactory.getLogger(ServerStats.class);\n\n    private final AtomicLong packetsSent = new AtomicLong();\n    private final AtomicLong packetsReceived = new AtomicLong();\n\n    private final AvgMinMaxCounter requestLatency = new AvgMinMaxCounter(\"request_latency\");\n\n    private AtomicLong fsyncThresholdExceedCount = new AtomicLong(0);\n\n    private final BufferStats clientResponseStats = new BufferStats();\n\n    private final Provider provider;\n    private final long startTime = Time.currentElapsedTime();\n\n    public interface Provider {\n        public long getOutstandingRequests();\n        public long getLastProcessedZxid();\n        public String getState();\n        public int getNumAliveConnections();\n        public long getDataDirSize();\n        public long getLogDirSize();\n    }\n    \n    public ServerStats(Provider provider) {\n        this.provider = provider;\n    }\n    \n    // getters\n    public long getMinLatency() {\n        return requestLatency.getMin();\n    }\n\n    public double getAvgLatency() {\n        return requestLatency.getAvg();\n    }\n\n    public long getMaxLatency() {\n        return requestLatency.getMax();\n    }\n\n    public long getOutstandingRequests() {\n        return provider.getOutstandingRequests();\n    }\n    \n<fim_suffix>    public long getLastProcessedZxid(){\n        return provider.getLastProcessedZxid();\n    }\n\n    public long getDataDirSize() {\n        return provider.getDataDirSize();\n    }\n\n    public long getLogDirSize() {\n        return provider.getLogDirSize();\n    }\n    \n    public long getPacketsReceived() {\n        return packetsReceived.get();\n    }\n\n    public long getPacketsSent() {\n        return packetsSent.get();\n    }\n\n    public String getServerState() {\n        return provider.getState();\n    }\n    \n    /** The number of client connections alive to this server */\n    public int getNumAliveClientConnections() {\n    \treturn provider.getNumAliveConnections();\n    }\n\n    public long getUptime() {\n        return Time.currentElapsedTime() - startTime;\n    }\n\n    public boolean isProviderNull() {\n        return provider == null;\n    }\n\n    @Override\n    public String toString(){\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"Latency min/avg/max: \" + getMinLatency() + \"/\"\n                + getAvgLatency() + \"/\" + getMaxLatency() + \"\\n\");\n        sb.append(\"Received: \" + getPacketsReceived() + \"\\n\");\n        sb.append(\"Sent: \" + getPacketsSent() + \"\\n\");\n        sb.append(\"Connections: \" + getNumAliveClientConnections() + \"\\n\");\n\n        if (provider != null) {\n            sb.append(\"Outstanding: \" + getOutstandingRequests() + \"\\n\");\n            sb.append(\"Zxid: 0x\"+ Long.toHexString(getLastProcessedZxid())+ \"\\n\");\n        }\n        sb.append(\"Mode: \" + getServerState() + \"\\n\");\n        return sb.toString();\n    }\n\n    /**\n     * Update request statistic. This should only be called from a request\n     * that originated from that machine.\n     */\n    public void updateLatency(Request request, long currentTime) {\n        long latency = currentTime - request.createTime;\n        if (latency < 0) {\n            return;\n        }\n        requestLatency.addDataPoint(latency);\n        if (request.getHdr() != null) {\n            // Only quorum request should have header\n            ServerMetrics.UPDATE_LATENCY.add(latency);\n        } else {\n            // All read request should goes here\n            ServerMetrics.READ_LATENCY.add(latency);\n        }\n    }\n\n    public void resetLatency() {\n        requestLatency.reset();\n    }\n\n    public void resetMaxLatency() {\n        requestLatency.resetMax();\n    }\n\n    public void incrementPacketsReceived() {\n        packetsReceived.incrementAndGet();\n    }\n\n    public void incrementPacketsSent() {\n        packetsSent.incrementAndGet();\n    }\n\n    public void resetRequestCounters(){\n        packetsReceived.set(0);\n        packetsSent.set(0);\n    }\n\n    public long getFsyncThresholdExceedCount() {\n        return fsyncThresholdExceedCount.get();\n    }\n\n    public void incrementFsyncThresholdExceedCount() {\n        fsyncThresholdExceedCount.incrementAndGet();\n    }\n\n    public void resetFsyncThresholdExceedCount() {\n        fsyncThresholdExceedCount.set(0);\n    }\n\n    public void reset() {\n        resetLatency();\n        resetRequestCounters();\n        clientResponseStats.reset();\n        ServerMetrics.resetAll();\n    }\n\n    public void updateClientResponseSize(int size) {\n        clientResponseStats.setLastBufferSize(size);\n    }\n\n    public BufferStats getClientResponseStats() {\n        return clientResponseStats;\n    }\n}<fim_middle>// function below has no smell\n"}