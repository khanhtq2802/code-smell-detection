{"text": "<fim_prefix>    parent.unlink(entry.name());\n    parent.updateModifiedTime();\n    file.deleted();\n  }\n  /**\n   * Mode for deleting. Determines what types of files can be deleted.\n   */\n  public enum DeleteMode {\n    /**\n     * Delete any file.\n     */\n    ANY,\n    /**\n     * Only delete non-directory files.\n     */\n    NON_DIRECTORY_ONLY,\n    /**\n     * Only delete directory files.\n     */\n    DIRECTORY_ONLY\n  }\n  /**\n   * Checks that the given file can be deleted, throwing an exception if it can't.\n   */\n  private void checkDeletable(File file, DeleteMode mode, Path path) throws IOException {\n    if (file.isRootDirectory()) {\n      throw new FileSystemException(path.toString(), null, \"can't delete root directory\");\n    }\n    if (file.isDirectory()) {\n      if (mode == DeleteMode.NON_DIRECTORY_ONLY) {\n        throw new FileSystemException(path.toString(), null, \"can't delete: is a directory\");\n      }\n      checkEmpty(((Directory) file), path);\n    } else if (mode == DeleteMode.DIRECTORY_ONLY) {\n      throw new FileSystemException(path.toString(), null, \"can't delete: is not a directory\");\n    }\n    if (file == workingDirectory && !path.isAbsolute()) {\n      // this is weird, but on Unix at least, the file system seems to be happy to delete the\n      // working directory if you give the absolute path to it but fail if you use a relative path\n      // that resolves to the working directory (e.g. \"\" or \".\")\n      throw new FileSystemException(path.toString(), null, \"invalid argument\");\n    }\n  }\n  /**\n   * Checks that given directory is empty, throwing {@link DirectoryNotEmptyException} if not.\n   */\n  private void checkEmpty(Directory dir, Path pathForException) throws FileSystemException {\n    if (!dir.isEmpty()) {\n      throw new DirectoryNotEmptyException(pathForException.toString());\n    }\n  }\n  /**\n   * Copies or moves the file at the given source path to the given dest path.\n   */\n  public void copy(\n      JimfsPath source,\n      FileSystemView destView,\n      JimfsPath dest,\n      Set<CopyOption> options,\n      boolean move)\n      throws IOException {\n    checkNotNull(source);\n    checkNotNull(destView);\n    checkNotNull(dest);\n    checkNotNull(options);\n    boolean sameFileSystem = isSameFileSystem(destView);\n    File sourceFile;\n    File copyFile = null; // non-null after block completes iff source file was copied\n    lockBoth(store.writeLock(), destView.store.writeLock());\n    try {\n      DirectoryEntry sourceEntry = lookUp(source, options).requireExists(source);\n      DirectoryEntry destEntry = destView.lookUp(dest, Options.NOFOLLOW_LINKS);\n      Directory sourceParent = sourceEntry.directory();\n      sourceFile = sourceEntry.file();\n      Directory destParent = destEntry.directory();\n      if (move && sourceFile.isDirectory()) {\n        if (sameFileSystem) {\n          checkMovable(sourceFile, source);\n          checkNotAncestor(sourceFile, destParent, destView);\n        } else {\n          // move to another file system is accomplished by copy-then-delete, so the source file\n          // must be deletable to be moved\n          checkDeletable(sourceFile, DeleteMode.ANY, source);\n        }\n      }\n      if (destEntry.exists()) {\n        if (destEntry.file().equals(sourceFile)) {\n          return;\n        } else if (options.contains(REPLACE_EXISTING)) {\n          destView.delete(destEntry, DeleteMode.ANY, dest);\n        } else {\n          throw new FileAlreadyExistsException(dest.toString());\n        }\n      }\n      if (move && sameFileSystem) {\n        // Real move on the same file system.\n        sourceParent.unlink(source.name());\n        sourceParent.updateModifiedTime();\n        destParent.link(dest.name(), sourceFile);\n        destParent.updateModifiedTime();\n      } else {\n        // Doing a copy OR a move to a different file system, which must be implemented by copy and\n        // delete.\n        // By default, don't copy attributes.\n        AttributeCopyOption attributeCopyOption = AttributeCopyOption.NONE;\n        if (move) {\n          // Copy only the basic attributes of the file to the other file system, as it may not\n          // support all the attribute views that this file system does. This also matches the\n          // behavior of moving a file to a foreign file system with a different\n          // FileSystemProvider.\n          attributeCopyOption = AttributeCopyOption.BASIC;\n        } else if (options.contains(COPY_ATTRIBUTES)) {\n          // As with move, if we're copying the file to a different file system, only copy its\n          // basic attributes.\n          attributeCopyOption =\n              sameFileSystem ? AttributeCopyOption.ALL : AttributeCopyOption.BASIC;\n        }\n        // Copy the file, but don't copy its content while we're holding the file store locks.\n        copyFile = destView.store.copyWithoutContent(sourceFile, attributeCopyOption);\n        destParent.link(dest.name(), copyFile);\n        destParent.updateModifiedTime();\n        // In order for the copy to be atomic (not strictly necessary, but seems preferable since\n        // we can) lock both source and copy files before leaving the file store locks. This\n        // ensures that users cannot observe the copy's content until the content has been copied.\n        // This also marks the source file as opened, preventing its content from being deleted\n        // until after it's copied if the source file itself is deleted in the next step.\n        lockSourceAndCopy(sourceFile, copyFile);\n        if (move) {\n          // It should not be possible for delete to throw an exception here, because we already\n          // checked that the file was deletable above.\n          delete(sourceEntry, DeleteMode.ANY, source);\n        }\n      }\n    } finally {\n      destView.store.writeLock().unlock();\n      store.writeLock().unlock();\n    }\n    if (copyFile != null) {\n      // Copy the content. This is done outside the above block to minimize the time spent holding\n      // file store locks, since copying the content of a regular file could take a (relatively)\n      // long time. If done inside the above block, copying using Files.copy can be slower than\n      // copying with an InputStream and an OutputStream if many files are being copied on\n      // different threads.\n      try {\n        sourceFile.copyContentTo(copyFile);\n      } finally {\n        // Unlock the files, allowing the content of the copy to be observed by the user. This also\n        // closes the source file, allowing its content to be deleted if it was deleted.\n        unlockSourceAndCopy(sourceFile, copyFile);\n      }\n    }\n  }\n  private void checkMovable(File file, JimfsPath path) throws FileSystemException {\n    if (file.isRootDirectory()) {\n      throw new FileSystemException(path.toString(), null, \"can't move root directory\");\n    }\n  }\n  /**\n   * Acquires both write locks in a way that attempts to avoid the possibility of deadlock. Note\n   * that typically (when only one file system instance is involved), both locks will be the same\n   * lock and there will be no issue at all.\n   */\n  private static void lockBoth(Lock sourceWriteLock, Lock destWriteLock) {\n    while (true) {\n      sourceWriteLock.lock();\n      if (destWriteLock.tryLock()) {\n        return;\n      } else {\n        sourceWriteLock.unlock();\n      }\n      destWriteLock.lock();\n      if (sourceWriteLock.tryLock()) {\n        return;\n      } else {\n        destWriteLock.unlock();\n      }\n    }\n  }\n  /**\n   * Checks that source is not an ancestor of dest, throwing an exception if it is.\n   */\n  private void checkNotAncestor(File source, Directory destParent, FileSystemView destView)\n      throws IOException {\n    // if dest is not in the same file system, it couldn't be in source's subdirectories\n    if (!isSameFileSystem(destView)) {\n      return;\n    }\n    Directory current = destParent;\n    while (true) {\n      if (current.equals(source)) {\n        throw new IOException(\n            \"invalid argument: can't move directory into a subdirectory of itself\");\n      }\n      if (current.isRootDirectory()) {\n        return;\n      } else {\n        current = current.parent();\n      }\n    }\n  }\n  /**\n   * Locks source and copy files before copying content. Also marks the source file as opened so\n   * that its content won't be deleted until after the copy if it is deleted.\n   */\n<fim_suffix>  private void lockSourceAndCopy(File sourceFile, File copyFile) {\n    sourceFile.opened();\n    ReadWriteLock sourceLock = sourceFile.contentLock();\n    if (sourceLock != null) {\n      sourceLock.readLock().lock();\n    }\n    ReadWriteLock copyLock = copyFile.contentLock();\n    if (copyLock != null) {\n      copyLock.writeLock().lock();\n    }\n  }<fim_middle>// function below has no smell\n"}