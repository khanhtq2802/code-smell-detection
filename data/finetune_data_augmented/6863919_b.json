{"text": "<fim_prefix>/*\n * Copyright 2018 The Error Prone Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.errorprone.bugpatterns.inject;\n\nimport static com.google.common.collect.ImmutableList.toImmutableList;\nimport static com.google.common.collect.Iterables.getOnlyElement;\nimport static com.google.errorprone.BugPattern.SeverityLevel.ERROR;\nimport static com.google.errorprone.matchers.ChildMultiMatcher.MatchType.AT_LEAST_ONE;\nimport static com.google.errorprone.matchers.InjectMatchers.hasInjectAnnotation;\nimport static com.google.errorprone.matchers.Matchers.allOf;\nimport static com.google.errorprone.matchers.Matchers.constructor;\nimport static com.google.errorprone.matchers.Matchers.isField;\n\nimport com.google.errorprone.BugPattern;\nimport com.google.errorprone.BugPattern.ProvidesFix;\nimport com.google.errorprone.VisitorState;\nimport com.google.errorprone.bugpatterns.BugChecker;\nimport com.google.errorprone.bugpatterns.BugChecker.ClassTreeMatcher;\nimport com.google.errorprone.fixes.SuggestedFix;\nimport com.google.errorprone.matchers.Description;\nimport com.google.errorprone.matchers.InjectMatchers;\nimport com.google.errorprone.matchers.Matcher;\nimport com.google.errorprone.util.ASTHelpers;\nimport com.sun.source.tree.AnnotationTree;\nimport com.sun.source.tree.AssignmentTree;\nimport com.sun.source.tree.ClassTree;\nimport com.sun.source.tree.MethodTree;\nimport com.sun.source.tree.Tree;\nimport com.sun.source.tree.VariableTree;\nimport com.sun.source.util.TreeScanner;\nimport com.sun.tools.javac.code.Symbol;\nimport com.sun.tools.javac.tree.JCTree;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.Set;\nimport javax.lang.model.element.ElementKind;\n\n/**\n * Checks if class constructor and members are both annotated as @Inject.\n *\n * @author bhagwani@google.com (Sumit Bhagwani)\n */\n@BugPattern(\n    name = \"InjectOnMemberAndConstructor\",\n    summary =\n        \"Members shouldn't be annotated with @Inject if constructor is already annotated @Inject\",\n    severity = ERROR,\n    providesFix = ProvidesFix.REQUIRES_HUMAN_ATTENTION)\npublic class InjectOnMemberAndConstructor extends BugChecker implements ClassTreeMatcher {\n\n  private static final Matcher<ClassTree> HAS_CONSTRUCTORS_WITH_INJECT =\n      constructor(AT_LEAST_ONE, hasInjectAnnotation());\n\n  private static final Matcher<VariableTree> INSTANCE_FIELD_WITH_INJECT =\n      allOf(isField(), hasInjectAnnotation());\n\n<fim_suffix>  @Override\n  public final Description matchClass(ClassTree classTree, VisitorState state) {\n    if (!HAS_CONSTRUCTORS_WITH_INJECT.matches(classTree, state)) {\n      return Description.NO_MATCH;\n    }\n\n    List<MethodTree> ctors = ASTHelpers.getConstructors(classTree);\n    List<MethodTree> ctorsWithInject =\n        ctors.stream()\n            .filter(c -> hasInjectAnnotation().matches(c, state))\n            .collect(toImmutableList());\n\n    if (ctorsWithInject.size() != 1) {\n      // Injection frameworks don't support multiple @Inject ctors.\n      // There is already an ERROR check for it.\n      // http://errorprone.info/bugpattern/MoreThanOneInjectableConstructor\n      return Description.NO_MATCH;\n    }\n\n    // collect the assignments in ctor\n    Set<Symbol> variablesAssigned = new HashSet<>();\n    new TreeScanner<Void, Void>() {\n      @Override\n      public Void visitAssignment(AssignmentTree tree, Void unused) {\n        Symbol symbol = ASTHelpers.getSymbol(tree.getVariable());\n        // check if it is instance field.\n        if (symbol != null && symbol.getKind() == ElementKind.FIELD && !symbol.isStatic()) {\n          variablesAssigned.add(symbol);\n        }\n        return super.visitAssignment(tree, null);\n      }\n    }.scan((JCTree) getOnlyElement(ctorsWithInject), null);\n\n    SuggestedFix.Builder fix = SuggestedFix.builder();\n    VariableTree variableTreeFirstMatch = null;\n    for (Tree member : classTree.getMembers()) {\n      if (!(member instanceof VariableTree)) {\n        continue;\n      }\n      VariableTree variableTree = (VariableTree) member;\n      if (!INSTANCE_FIELD_WITH_INJECT.matches(variableTree, state)) {\n        continue;\n      }\n      if (!variablesAssigned.contains(ASTHelpers.getSymbol(variableTree))) {\n        continue;\n      }\n      variableTreeFirstMatch = variableTree;\n      removeInjectAnnotationFromVariable(variableTree, state).ifPresent(fix::merge);\n    }\n    if (variableTreeFirstMatch == null) {\n      return Description.NO_MATCH;\n    }\n    if (fix.isEmpty()) {\n      return describeMatch(variableTreeFirstMatch);\n    }\n    return describeMatch(variableTreeFirstMatch, fix.build());\n  }\n\n  private static Optional<SuggestedFix> removeInjectAnnotationFromVariable(\n      VariableTree variableTree, VisitorState state) {\n    for (AnnotationTree annotation : variableTree.getModifiers().getAnnotations()) {\n      if (InjectMatchers.IS_APPLICATION_OF_AT_INJECT.matches(annotation, state)) {\n        return Optional.of(SuggestedFix.replace(annotation, \"\"));\n      }\n    }\n    return Optional.empty();\n  }\n}<fim_middle>// function below is long method and feature envy\n"}