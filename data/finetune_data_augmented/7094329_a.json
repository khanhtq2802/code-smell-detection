{"text": "<fim_prefix>        if (untilTime != MAX_TIME) {\n            appendUNTIL(writer, getDateTimeString(untilTime + fromOffset));\n        }\n        writer.write(NEWLINE);\n        endZoneProps(writer, isDst);\n    }\n    /*\n     * Write start times defined by a DOW_GEQ_DOM rule using VTIMEZONE RRULE\n     */\n    private static void writeZonePropsByDOW_GEQ_DOM(Writer writer, boolean isDst, String tzname, int fromOffset, int toOffset,\n            int month, int dayOfMonth, int dayOfWeek, long startTime, long untilTime) throws IOException {\n        // Check if this rule can be converted to DOW rule\n        if (dayOfMonth%7 == 1) {\n            // Can be represented by DOW rule\n            writeZonePropsByDOW(writer, isDst, tzname, fromOffset, toOffset,\n                    month, (dayOfMonth + 6)/7, dayOfWeek, startTime, untilTime);\n        } else if (month != Calendar.FEBRUARY && (MONTHLENGTH[month] - dayOfMonth)%7 == 6) {\n            // Can be represented by DOW rule with negative week number\n            writeZonePropsByDOW(writer, isDst, tzname, fromOffset, toOffset,\n                    month, -1*((MONTHLENGTH[month] - dayOfMonth + 1)/7), dayOfWeek, startTime, untilTime);\n        } else {\n            // Otherwise, use BYMONTHDAY to include all possible dates\n            beginZoneProps(writer, isDst, tzname, fromOffset, toOffset, startTime);\n            // Check if all days are in the same month\n            int startDay = dayOfMonth;\n            int currentMonthDays = 7;\n            if (dayOfMonth <= 0) {\n                // The start day is in previous month\n                int prevMonthDays = 1 - dayOfMonth;\n                currentMonthDays -= prevMonthDays;\n                int prevMonth = (month - 1) < 0 ? 11 : month - 1;\n                // Note: When a rule is separated into two, UNTIL attribute needs to be\n                // calculated for each of them.  For now, we skip this, because we basically use this method\n                // only for final rules, which does not have the UNTIL attribute\n                writeZonePropsByDOW_GEQ_DOM_sub(writer, prevMonth, -prevMonthDays, dayOfWeek, prevMonthDays, MAX_TIME /* Do not use UNTIL */, fromOffset);\n                // Start from 1 for the rest\n                startDay = 1;\n            } else if (dayOfMonth + 6 > MONTHLENGTH[month]) {\n                // Note: This code does not actually work well in February.  For now, days in month in\n                // non-leap year.\n                int nextMonthDays = dayOfMonth + 6 - MONTHLENGTH[month];\n                currentMonthDays -= nextMonthDays;\n                int nextMonth = (month + 1) > 11 ? 0 : month + 1;\n                writeZonePropsByDOW_GEQ_DOM_sub(writer, nextMonth, 1, dayOfWeek, nextMonthDays, MAX_TIME /* Do not use UNTIL */, fromOffset);\n            }\n            writeZonePropsByDOW_GEQ_DOM_sub(writer, month, startDay, dayOfWeek, currentMonthDays, untilTime, fromOffset);\n            endZoneProps(writer, isDst);\n        }\n    }\n    /*\n     * Called from writeZonePropsByDOW_GEQ_DOM\n     */\n    private static void writeZonePropsByDOW_GEQ_DOM_sub(Writer writer, int month,\n            int dayOfMonth, int dayOfWeek, int numDays, long untilTime, int fromOffset) throws IOException {\n        int startDayNum = dayOfMonth;\n        boolean isFeb = (month == Calendar.FEBRUARY);\n        if (dayOfMonth < 0 && !isFeb) {\n            // Use positive number if possible\n            startDayNum = MONTHLENGTH[month] + dayOfMonth + 1;\n        }\n        beginRRULE(writer, month);\n        writer.write(ICAL_BYDAY);\n        writer.write(EQUALS_SIGN);\n        writer.write(ICAL_DOW_NAMES[dayOfWeek - 1]);    // SU, MO, TU...\n        writer.write(SEMICOLON);\n        writer.write(ICAL_BYMONTHDAY);\n        writer.write(EQUALS_SIGN);\n        writer.write(Integer.toString(startDayNum));\n        for (int i = 1; i < numDays; i++) {\n            writer.write(COMMA);\n            writer.write(Integer.toString(startDayNum + i));\n        }\n        if (untilTime != MAX_TIME) {\n            appendUNTIL(writer, getDateTimeString(untilTime + fromOffset));\n        }\n        writer.write(NEWLINE);\n    }\n    /*\n     * Write start times defined by a DOW_LEQ_DOM rule using VTIMEZONE RRULE\n     */\n    private static void writeZonePropsByDOW_LEQ_DOM(Writer writer, boolean isDst, String tzname, int fromOffset, int toOffset,\n            int month, int dayOfMonth, int dayOfWeek, long startTime, long untilTime) throws IOException {\n        // Check if this rule can be converted to DOW rule\n        if (dayOfMonth%7 == 0) {\n            // Can be represented by DOW rule\n            writeZonePropsByDOW(writer, isDst, tzname, fromOffset, toOffset,\n                    month, dayOfMonth/7, dayOfWeek, startTime, untilTime);\n        } else if (month != Calendar.FEBRUARY && (MONTHLENGTH[month] - dayOfMonth)%7 == 0){\n            // Can be represented by DOW rule with negative week number\n            writeZonePropsByDOW(writer, isDst, tzname, fromOffset, toOffset,\n                    month, -1*((MONTHLENGTH[month] - dayOfMonth)/7 + 1), dayOfWeek, startTime, untilTime);\n        } else if (month == Calendar.FEBRUARY && dayOfMonth == 29) {\n            // Specical case for February\n            writeZonePropsByDOW(writer, isDst, tzname, fromOffset, toOffset,\n                    Calendar.FEBRUARY, -1, dayOfWeek, startTime, untilTime);\n        } else {\n            // Otherwise, convert this to DOW_GEQ_DOM rule\n            writeZonePropsByDOW_GEQ_DOM(writer, isDst, tzname, fromOffset, toOffset,\n                    month, dayOfMonth - 6, dayOfWeek, startTime, untilTime);\n        }\n    }\n    /*\n     * Write the final time zone rule using RRULE, with no UNTIL attribute\n     */\n<fim_suffix>    private static void writeFinalRule(Writer writer, boolean isDst, AnnualTimeZoneRule rule,\n            int fromRawOffset, int fromDSTSavings, long startTime) throws IOException{\n        DateTimeRule dtrule = toWallTimeRule(rule.getRule(), fromRawOffset, fromDSTSavings);\n        // If the rule's mills in a day is out of range, adjust start time.\n        // Olson tzdata supports 24:00 of a day, but VTIMEZONE does not.\n        // See ticket#7008/#7518\n        int timeInDay = dtrule.getRuleMillisInDay();\n        if (timeInDay < 0) {\n            startTime = startTime + (0 - timeInDay);\n        } else if (timeInDay >= Grego.MILLIS_PER_DAY) {\n            startTime = startTime - (timeInDay - (Grego.MILLIS_PER_DAY - 1));\n        }\n        int toOffset = rule.getRawOffset() + rule.getDSTSavings();\n        switch (dtrule.getDateRuleType()) {\n        case DateTimeRule.DOM:\n            writeZonePropsByDOM(writer, isDst, rule.getName(), fromRawOffset + fromDSTSavings, toOffset,\n                    dtrule.getRuleMonth(), dtrule.getRuleDayOfMonth(), startTime, MAX_TIME);\n            break;\n        case DateTimeRule.DOW:\n            writeZonePropsByDOW(writer, isDst, rule.getName(), fromRawOffset + fromDSTSavings, toOffset,\n                    dtrule.getRuleMonth(), dtrule.getRuleWeekInMonth(), dtrule.getRuleDayOfWeek(), startTime, MAX_TIME);\n            break;\n        case DateTimeRule.DOW_GEQ_DOM:\n            writeZonePropsByDOW_GEQ_DOM(writer, isDst, rule.getName(), fromRawOffset + fromDSTSavings, toOffset,\n                    dtrule.getRuleMonth(), dtrule.getRuleDayOfMonth(), dtrule.getRuleDayOfWeek(), startTime, MAX_TIME);\n            break;\n        case DateTimeRule.DOW_LEQ_DOM:\n            writeZonePropsByDOW_LEQ_DOM(writer, isDst, rule.getName(), fromRawOffset + fromDSTSavings, toOffset,\n                    dtrule.getRuleMonth(), dtrule.getRuleDayOfMonth(), dtrule.getRuleDayOfWeek(), startTime, MAX_TIME);\n            break;\n        }\n    }<fim_middle>// function below is feature envy and long method\n"}