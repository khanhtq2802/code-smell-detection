{"text": "<fim_prefix>    }\n    public static boolean isMetaTable(String schemaName, String tableName) {\n        return PhoenixDatabaseMetaData.SYSTEM_CATALOG_SCHEMA.equals(schemaName) && PhoenixDatabaseMetaData.SYSTEM_CATALOG_TABLE.equals(tableName);\n    }\n    public static boolean isSystemTable(byte[] fullTableName) {\n        String schemaName = SchemaUtil.getSchemaNameFromFullName(fullTableName);\n        if (QueryConstants.SYSTEM_SCHEMA_NAME.equals(schemaName)) return true;\n        return false;\n    }\n    // Given the splits and the rowKeySchema, find out the keys that \n    public static byte[][] processSplits(byte[][] splits, LinkedHashSet<PColumn> pkColumns, Integer saltBucketNum, boolean defaultRowKeyOrder) throws SQLException {\n        // FIXME: shouldn't this return if splits.length == 0?\n        if (splits == null) return null;\n        // We do not accept user specified splits if the table is salted and we specify defaultRowKeyOrder. In this case,\n        // throw an exception.\n        if (splits.length > 0 && saltBucketNum != null && defaultRowKeyOrder) {\n            throw new SQLExceptionInfo.Builder(SQLExceptionCode.NO_SPLITS_ON_SALTED_TABLE).build().buildException();\n        }\n        // If the splits are not specified and table is salted, pre-split the table. \n        if (splits.length == 0 && saltBucketNum != null) {\n            splits = SaltingUtil.getSalteByteSplitPoints(saltBucketNum);\n        }\n        byte[][] newSplits = new byte[splits.length][];\n        for (int i=0; i<splits.length; i++) {\n            newSplits[i] = processSplit(splits[i], pkColumns); \n        }\n        return newSplits;\n    }\n    // Go through each slot in the schema and try match it with the split byte array. If the split\n    // does not confer to the schema, extends its length to match the schema.\n    private static byte[] processSplit(byte[] split, LinkedHashSet<PColumn> pkColumns) {\n        int pos = 0, offset = 0, maxOffset = split.length;\n        Iterator<PColumn> iterator = pkColumns.iterator();\n        while (pos < pkColumns.size()) {\n            PColumn column = iterator.next();\n            if (column.getDataType().isFixedWidth()) { // Fixed width\n                int length = SchemaUtil.getFixedByteSize(column);\n                if (maxOffset - offset < length) {\n                    // The split truncates the field. Fill in the rest of the part and any fields that\n                    // are missing after this field.\n                    int fillInLength = length - (maxOffset - offset);\n                    fillInLength += estimatePartLength(pos + 1, iterator);\n                    return ByteUtil.fillKey(split, split.length + fillInLength);\n                }\n                // Account for this field, move to next position;\n                offset += length;\n                pos++;\n            } else { // Variable length\n                // If we are the last slot, then we are done. Nothing needs to be filled in.\n                if (pos == pkColumns.size() - 1) {\n                    break;\n                }\n                while (offset < maxOffset && split[offset] != SEPARATOR_BYTE) {\n                    offset++;\n                }\n                if (offset == maxOffset) {\n                    // The var-length field does not end with a separator and it's not the last field.\n                    int fillInLength = 1; // SEPARATOR byte for the current var-length slot.\n                    fillInLength += estimatePartLength(pos + 1, iterator);\n                    return ByteUtil.fillKey(split, split.length + fillInLength);\n                }\n                // Move to the next position;\n                offset += 1; // skip separator;\n                pos++;\n            }\n        }\n        return split;\n    }\n    // Estimate the key length after pos slot for schema.\n    private static int estimatePartLength(int pos, Iterator<PColumn> iterator) {\n        int length = 0;\n        while (iterator.hasNext()) {\n            PColumn column = iterator.next();\n            if (column.getDataType().isFixedWidth()) {\n                length += SchemaUtil.getFixedByteSize(column);\n            } else {\n                length += 1; // SEPARATOR byte.\n            }\n        }\n        return length;\n    }\n    public static String getEscapedTableName(String schemaName, String tableName) {\n        if (schemaName == null || schemaName.length() == 0) {\n            return \"\\\"\" + tableName + \"\\\"\";\n        }\n        return \"\\\"\" + schemaName + \"\\\".\" + \"\\\"\" + tableName + \"\\\"\";\n    }\n    protected static PhoenixConnection addMetaDataColumn(PhoenixConnection conn, long scn, String columnDef) throws SQLException {\n        PhoenixConnection metaConnection = null;\n        Statement stmt = null;\n        try {\n            metaConnection = new PhoenixConnection(conn, scn);\n            try {\n                stmt = metaConnection.createStatement();\n                stmt.executeUpdate(\"ALTER TABLE SYSTEM.\\\"TABLE\\\" ADD IF NOT EXISTS \" + columnDef);\n                return metaConnection;\n            } finally {\n                if(stmt != null) {\n                    stmt.close();\n                }\n            }\n        } finally {\n            if(metaConnection != null) {\n                metaConnection.close();\n            }\n        }\n    }\n    public static boolean columnExists(PTable table, String columnName) {\n        try {\n            table.getColumnForColumnName(columnName);\n            return true;\n        } catch (ColumnNotFoundException e) {\n            return false;\n        } catch (AmbiguousColumnException e) {\n            return true;\n        }\n    }\n    public static String getSchemaNameFromFullName(String tableName) {\n        if (isExistingTableMappedToPhoenixName(tableName)) { return StringUtil.EMPTY_STRING; }\n        if (tableName.contains(QueryConstants.NAMESPACE_SEPARATOR)) { return getSchemaNameFromFullName(tableName,\n                QueryConstants.NAMESPACE_SEPARATOR); }\n        return getSchemaNameFromFullName(tableName, QueryConstants.NAME_SEPARATOR);\n    }\n    public static String getSchemaNameFromFullName(String tableName, String separator) {\n        int index = tableName.indexOf(separator);\n        if (index < 0) {\n            return StringUtil.EMPTY_STRING; \n        }\n        return tableName.substring(0, index);\n    }\n    private static int indexOf (byte[] bytes, byte b) {\n        for (int i = 0; i < bytes.length; i++) {\n            if (bytes[i] == b) {\n                return i;\n            }\n        }\n        return -1;\n    }\n    public static String getSchemaNameFromFullName(byte[] tableName) {\n        if (tableName == null) {\n            return null;\n        }\n        if (isExistingTableMappedToPhoenixName(Bytes.toString(tableName))) { return StringUtil.EMPTY_STRING; }\n        int index = indexOf(tableName, QueryConstants.NAME_SEPARATOR_BYTE);\n        if (index < 0) {\n            index = indexOf(tableName, QueryConstants.NAMESPACE_SEPARATOR_BYTE);\n            if (index < 0) { return StringUtil.EMPTY_STRING; }\n        }\n        return Bytes.toString(tableName, 0, index);\n    }\n    public static String getTableNameFromFullName(byte[] tableName) {\n        if (tableName == null) {\n            return null;\n        }\n        if (isExistingTableMappedToPhoenixName(Bytes.toString(tableName))) { return Bytes.toString(tableName); }\n        int index = indexOf(tableName, QueryConstants.NAME_SEPARATOR_BYTE);\n        if (index < 0) {\n            index = indexOf(tableName, QueryConstants.NAMESPACE_SEPARATOR_BYTE);\n            if (index < 0) { return Bytes.toString(tableName); }\n        }\n        return Bytes.toString(tableName, index+1, tableName.length - index - 1);\n    }\n    public static String getTableNameFromFullName(String tableName) {\n        if (isExistingTableMappedToPhoenixName(tableName)) { return tableName; }\n        if (tableName.contains(QueryConstants.NAMESPACE_SEPARATOR)) { return getTableNameFromFullName(tableName,\n                QueryConstants.NAMESPACE_SEPARATOR); }\n        return getTableNameFromFullName(tableName, QueryConstants.NAME_SEPARATOR);\n    }\n    public static String getTableNameFromFullName(String tableName, String separator) {\n        int index = tableName.indexOf(separator);\n        if (index < 0) {\n            return tableName; \n        }\n        return tableName.substring(index+1, tableName.length());\n    }\n<fim_suffix>    public static byte[] getTableKeyFromFullName(String fullTableName) {\n        int index = fullTableName.indexOf(QueryConstants.NAME_SEPARATOR);\n        if (index < 0) {\n            index = fullTableName.indexOf(QueryConstants.NAMESPACE_SEPARATOR);\n            if (index < 0) { return getTableKey(null, null, fullTableName); }\n        }\n        String schemaName = fullTableName.substring(0, index);\n        String tableName = fullTableName.substring(index+1);\n        return getTableKey(null, schemaName, tableName); \n    }<fim_middle>// function below has no smell\n"}