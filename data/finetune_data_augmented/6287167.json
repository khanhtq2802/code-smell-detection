{"text": "<fim_prefix>        }\n        if (StringUtil.isBlank(toUri.getScheme()))\n        {\n            throw new IllegalArgumentException(\"WebSocket URI must include a scheme\");\n        }\n        String scheme = toUri.getScheme().toLowerCase(Locale.ENGLISH);\n        if ((\"ws\".equals(scheme) == false) && (\"wss\".equals(scheme) == false))\n        {\n            throw new IllegalArgumentException(\"WebSocket URI scheme only supports [ws] and [wss], not [\" + scheme + \"]\");\n        }\n        if (\"wss\".equals(scheme))\n        {\n            // test for ssl context\n            if (httpClient.getSslContextFactory() == null)\n            {\n                throw new IllegalStateException(\"HttpClient has no SslContextFactory, wss:// URI's are not supported in this configuration\");\n            }\n        }\n        request.setRequestURI(toUri);\n        request.setLocalEndpoint(websocket);\n        // Validate Requested Extensions\n        for (ExtensionConfig reqExt : request.getExtensions())\n        {\n            if (!extensionRegistry.isAvailable(reqExt.getName()))\n            {\n                throw new IllegalArgumentException(\"Requested extension [\" + reqExt.getName() + \"] is not installed\");\n            }\n        }\n        if (LOG.isDebugEnabled())\n            LOG.debug(\"connect websocket {} to {}\",websocket,toUri);\n        init();\n        WebSocketUpgradeRequest wsReq = new WebSocketUpgradeRequest(this,httpClient,request);\n        wsReq.setUpgradeListener(upgradeListener);\n        return wsReq.sendAsync();\n    }\n    @Override\n    protected void doStart() throws Exception\n    {\n        Objects.requireNonNull(httpClient, \"Provided HttpClient is null\");\n        super.doStart();\n        if (!httpClient.isRunning())\n            throw new IllegalStateException(\"HttpClient is not running (did you forget to start it?): \" + httpClient);\n    }\n    @Override\n    protected void doStop() throws Exception\n    {\n        if (LOG.isDebugEnabled())\n            LOG.debug(\"Stopping {}\",this);\n        ShutdownThread.deregister(this);\n        super.doStop();\n        if (LOG.isDebugEnabled())\n            LOG.debug(\"Stopped {}\",this);\n    }\n    @Deprecated\n    public boolean isDispatchIO()\n    {\n        return httpClient.isDispatchIO();\n    }\n    /**\n     * Return the number of milliseconds for a timeout of an attempted write operation.\n     *\n     * @return number of milliseconds for timeout of an attempted write operation\n     */\n    public long getAsyncWriteTimeout()\n    {\n        return getPolicy().getAsyncWriteTimeout();\n    }\n    public SocketAddress getBindAddress()\n    {\n        return httpClient.getBindAddress();\n    }\n    @Override\n    public ByteBufferPool getBufferPool()\n    {\n        return httpClient.getByteBufferPool();\n    }\n    @Deprecated\n    public ConnectionManager getConnectionManager()\n    {\n        throw new UnsupportedOperationException(\"ConnectionManager is no longer supported\");\n    }\n    public long getConnectTimeout()\n    {\n        return httpClient.getConnectTimeout();\n    }\n    public CookieStore getCookieStore()\n    {\n        return httpClient.getCookieStore();\n    }\n    public EventDriverFactory getEventDriverFactory()\n    {\n        return eventDriverFactory;\n    }\n    @Override\n    public Executor getExecutor()\n    {\n        return httpClient.getExecutor();\n    }\n    public ExtensionFactory getExtensionFactory()\n    {\n        return extensionRegistry;\n    }\n    /**\n     * @deprecated not used, no replacement\n     * @return a {@link RandomMasker} instance\n     */\n    @Deprecated\n    public Masker getMasker()\n    {\n        return new RandomMasker();\n    }\n    /**\n     * Get the maximum size for buffering of a binary message.\n     *\n     * @return the maximum size of a binary message buffer.\n     */\n    public int getMaxBinaryMessageBufferSize()\n    {\n        return getPolicy().getMaxBinaryMessageBufferSize();\n    }\n    /**\n     * Get the maximum size for a binary message.\n     *\n     * @return the maximum size of a binary message.\n     */\n    public long getMaxBinaryMessageSize()\n    {\n        return getPolicy().getMaxBinaryMessageSize();\n    }\n    /**\n     * Get the max idle timeout for new connections.\n     *\n     * @return the max idle timeout in milliseconds for new connections.\n     */\n    public long getMaxIdleTimeout()\n    {\n        return getPolicy().getIdleTimeout();\n    }\n    /**\n     * Get the maximum size for buffering of a text message.\n     *\n     * @return the maximum size of a text message buffer.\n     */\n    public int getMaxTextMessageBufferSize()\n    {\n        return getPolicy().getMaxTextMessageBufferSize();\n    }\n    /**\n     * Get the maximum size for a text message.\n     *\n     * @return the maximum size of a text message.\n     */\n    public long getMaxTextMessageSize()\n    {\n        return getPolicy().getMaxTextMessageSize();\n    }\n    @Override\n    public DecoratedObjectFactory getObjectFactory()\n    {\n        return this.objectFactorySupplier.get();\n    }\n    public Set<WebSocketSession> getOpenSessions()\n    {\n        return Collections.unmodifiableSet(new HashSet<>(getBeans(WebSocketSession.class)));\n    }\n    @Override\n    public WebSocketPolicy getPolicy()\n    {\n        return this.policy;\n    }\n    public Scheduler getScheduler()\n    {\n        return httpClient.getScheduler();\n    }\n    public SessionFactory getSessionFactory()\n    {\n        return sessionFactory;\n    }\n    /**\n     * @return the {@link SslContextFactory} that manages TLS encryption\n     * @see #WebSocketClient(SslContextFactory)\n     */\n    @Override\n    public SslContextFactory getSslContextFactory()\n    {\n        return httpClient.getSslContextFactory();\n    }\n    @Override\n    public void addSessionListener(WebSocketSessionListener listener)\n    {\n        this.sessionListeners.add(listener);\n    }\n    @Override\n    public void removeSessionListener(WebSocketSessionListener listener)\n    {\n        this.sessionListeners.remove(listener);\n    }\n    @Override\n    public Collection<WebSocketSessionListener> getSessionListeners()\n    {\n        return this.sessionListeners;\n    }\n    private synchronized void init()\n    {\n        if (isStopAtShutdown() && !ShutdownThread.isRegistered(this))\n        {\n            ShutdownThread.register(this);\n        }\n    }\n    /**\n     * Factory method for new ConnectionManager\n     *\n     * @return the ConnectionManager instance to use\n     * @deprecated use HttpClient instead\n     */\n    @Deprecated\n    protected ConnectionManager newConnectionManager()\n    {\n        throw new UnsupportedOperationException(\"ConnectionManager is no longer supported\");\n    }\n    @Override\n    public void onSessionClosed(WebSocketSession session)\n    {\n        if (LOG.isDebugEnabled())\n            LOG.debug(\"Session Closed: {}\",session);\n        removeBean(session);\n    }\n    @Override\n    public void onSessionOpened(WebSocketSession session)\n    {\n        if (LOG.isDebugEnabled())\n            LOG.debug(\"Session Opened: {}\",session);\n        addManaged(session);\n    }\n    public void setAsyncWriteTimeout(long ms)\n    {\n        getPolicy().setAsyncWriteTimeout(ms);\n    }\n    /**\n     * @param bindAddress the address to bind to\n     * @deprecated (this is a bad bad bad typo) use {@link HttpClient#setBindAddress(SocketAddress)}\n     * on instance passed to {@link #WebSocketClient(HttpClient)}\n     */\n    @Deprecated\n    public void setBindAdddress(SocketAddress bindAddress)\n    {\n        setBindAddress(bindAddress);\n    }\n    /**\n     * @param bindAddress the address to bind to\n     * @deprecated Use {@link HttpClient#setBindAddress(SocketAddress)}\n     * on instance passed to {@link #WebSocketClient(HttpClient)}\n     */\n    @Deprecated\n    public void setBindAddress(SocketAddress bindAddress)\n    {\n        this.httpClient.setBindAddress(bindAddress);\n    }\n    /**\n     * @param bufferPool The buffer pool\n     * @deprecated Use {@link HttpClient#setByteBufferPool(ByteBufferPool)}\n     * on the instance passed to {@link #WebSocketClient(HttpClient)}\n     */\n    public void setBufferPool(ByteBufferPool bufferPool)\n    {\n        this.httpClient.setByteBufferPool(bufferPool);\n    }\n    /**\n     * Set the timeout for connecting to the remote server.\n     * @param ms the timeout in millisecondspool\n     * @deprecated Use {@link HttpClient#setConnectTimeout(long)}\n     * on the instance passed to {@link #WebSocketClient(HttpClient)}\n     */\n    public void setConnectTimeout(long ms)\n    {\n        this.httpClient.setConnectTimeout(ms);\n    }\n    /**\n     * @param cookieStore The cookie store\n     * @deprecated Use {@link HttpClient#setCookieStore(CookieStore)} on the HttpClient instance passed\n     * to {@link #WebSocketClient(HttpClient)}\n     */\n    @Deprecated\n    public void setCookieStore(CookieStore cookieStore)\n    {\n        this.httpClient.setCookieStore(cookieStore);\n    }\n    /**\n     * @deprecated not used, configure threading in HttpClient instead\n     * @param daemon do nothing\n     */\n    @Deprecated\n    public void setDaemon(boolean daemon)\n    {\n        // do nothing\n    }\n    @Deprecated\n    public void setDispatchIO(boolean dispatchIO)\n    {\n        this.httpClient.setDispatchIO(dispatchIO);\n    }\n    /**\n     * @param executor The executor to use\n     * @deprecated Use {@link HttpClient#setExecutor(Executor)}\n     * on the instance passed to {@link #WebSocketClient(HttpClient)}\n     */\n<fim_suffix>    @Deprecated\n    public void setExecutor(Executor executor)\n    {\n        this.httpClient.setExecutor(executor);\n    }<fim_middle>// function below has no smell\n"}