{"text": "<fim_prefix>/*\n * Copyright (C) 2011 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.taobao.android.dx.merge;\nimport com.taobao.android.dex.*;\nimport com.taobao.android.dex.EncodedValueReader;\nimport com.taobao.android.dex.util.ByteOutput;\nimport com.taobao.android.dx.util.ByteArrayAnnotatedOutput;\nimport java.util.HashMap;\nimport static com.taobao.android.dex.EncodedValueReader.*;\n/**\n * Maps the index offsets from one dex file to those in another. For example, if\n * you have string #5 in the old dex file, its position in the new dex file is\n * {@code strings[5]}.\n */\npublic final class IndexMap {\n    private final Dex target;\n    public final int[] stringIds;\n    public final short[] typeIds;\n    public final short[] protoIds;\n    public final short[] fieldIds;\n    public final short[] methodIds;\n    private final HashMap<Integer, Integer> typeListOffsets;\n    private final HashMap<Integer, Integer> annotationOffsets;\n    private final HashMap<Integer, Integer> annotationSetOffsets;\n    private final HashMap<Integer, Integer> annotationSetRefListOffsets;\n    private final HashMap<Integer, Integer> annotationDirectoryOffsets;\n    private final HashMap<Integer, Integer> staticValuesOffsets;\n    public IndexMap(Dex target, TableOfContents tableOfContents) {\n        this.target = target;\n        this.stringIds = new int[tableOfContents.stringIds.size];\n        this.typeIds = new short[tableOfContents.typeIds.size];\n        this.protoIds = new short[tableOfContents.protoIds.size];\n        this.fieldIds = new short[tableOfContents.fieldIds.size];\n        this.methodIds = new short[tableOfContents.methodIds.size];\n        this.typeListOffsets = new HashMap<Integer, Integer>();\n        this.annotationOffsets = new HashMap<Integer, Integer>();\n        this.annotationSetOffsets = new HashMap<Integer, Integer>();\n        this.annotationSetRefListOffsets = new HashMap<Integer, Integer>();\n        this.annotationDirectoryOffsets = new HashMap<Integer, Integer>();\n        this.staticValuesOffsets = new HashMap<Integer, Integer>();\n        /*\n         * A type list, annotation set, annotation directory, or static value at\n         * offset 0 is always empty. Always map offset 0 to 0.\n         */\n        this.typeListOffsets.put(0, 0);\n        this.annotationSetOffsets.put(0, 0);\n        this.annotationDirectoryOffsets.put(0, 0);\n        this.staticValuesOffsets.put(0, 0);\n    }\n    public void putTypeListOffset(int oldOffset, int newOffset) {\n        if (oldOffset <= 0 || newOffset <= 0) {\n            throw new IllegalArgumentException();\n        }\n        typeListOffsets.put(oldOffset, newOffset);\n    }\n    public void putAnnotationOffset(int oldOffset, int newOffset) {\n        if (oldOffset <= 0 || newOffset <= 0) {\n            throw new IllegalArgumentException();\n        }\n        annotationOffsets.put(oldOffset, newOffset);\n    }\n    public void putAnnotationSetOffset(int oldOffset, int newOffset) {\n        if (oldOffset <= 0 || newOffset <= 0) {\n            throw new IllegalArgumentException();\n        }\n        annotationSetOffsets.put(oldOffset, newOffset);\n    }\n    public void putAnnotationSetRefListOffset(int oldOffset, int newOffset) {\n        if (oldOffset <= 0 || newOffset <= 0) {\n            throw new IllegalArgumentException();\n        }\n        annotationSetRefListOffsets.put(oldOffset, newOffset);\n    }\n    public void putAnnotationDirectoryOffset(int oldOffset, int newOffset) {\n        if (oldOffset <= 0 || newOffset <= 0) {\n            throw new IllegalArgumentException();\n        }\n        annotationDirectoryOffsets.put(oldOffset, newOffset);\n    }\n    public void putStaticValuesOffset(int oldOffset, int newOffset) {\n        if (oldOffset <= 0 || newOffset <= 0) {\n            throw new IllegalArgumentException();\n        }\n        staticValuesOffsets.put(oldOffset, newOffset);\n    }\n    public int adjustString(int stringIndex) {\n        return stringIndex == ClassDef.NO_INDEX ? ClassDef.NO_INDEX : stringIds[stringIndex];\n    }\n    public int adjustType(int typeIndex) {\n        return (typeIndex == ClassDef.NO_INDEX) ? ClassDef.NO_INDEX : (typeIds[typeIndex] & 0xffff);\n    }\n    public TypeList adjustTypeList(TypeList typeList) {\n        if (typeList == TypeList.EMPTY) {\n            return typeList;\n        }\n        short[] types = typeList.getTypes().clone();\n        for (int i = 0; i < types.length; i++) {\n            types[i] = (short) adjustType(types[i]);\n        }\n        return new TypeList(target, types);\n    }\n    public int adjustProto(int protoIndex) {\n        return protoIds[protoIndex] & 0xffff;\n    }\n    public int adjustField(int fieldIndex) {\n        return fieldIds[fieldIndex] & 0xffff;\n    }\n    public int adjustMethod(int methodIndex) {\n        return methodIds[methodIndex] & 0xffff;\n    }\n    public int adjustTypeListOffset(int typeListOffset) {\n        return typeListOffsets.get(typeListOffset);\n    }\n    public int adjustAnnotation(int annotationOffset) {\n        return annotationOffsets.get(annotationOffset);\n    }\n    public int adjustAnnotationSet(int annotationSetOffset) {\n        return annotationSetOffsets.get(annotationSetOffset);\n    }\n    public int adjustAnnotationSetRefList(int annotationSetRefListOffset) {\n        return annotationSetRefListOffsets.get(annotationSetRefListOffset);\n    }\n<fim_suffix>    public int adjustAnnotationDirectory(int annotationDirectoryOffset) {\n        return annotationDirectoryOffsets.get(annotationDirectoryOffset);\n    }\n    public int adjustStaticValues(int staticValuesOffset) {\n        return staticValuesOffsets.get(staticValuesOffset);\n    }\n    public MethodId adjust(MethodId methodId) {\n        return new MethodId(target,\n                adjustType(methodId.getDeclaringClassIndex()),\n                adjustProto(methodId.getProtoIndex()),\n                adjustString(methodId.getNameIndex()));\n    }\n    public FieldId adjust(FieldId fieldId) {\n        return new FieldId(target,\n                adjustType(fieldId.getDeclaringClassIndex()),\n                adjustType(fieldId.getTypeIndex()),\n                adjustString(fieldId.getNameIndex()));\n    }\n    public ProtoId adjust(ProtoId protoId) {\n        return new ProtoId(target,\n                adjustString(protoId.getShortyIndex()),\n                adjustType(protoId.getReturnTypeIndex()),\n                adjustTypeListOffset(protoId.getParametersOffset()));\n    }\n    public ClassDef adjust(ClassDef classDef) {\n        return new ClassDef(target, classDef.getOffset(), adjustType(classDef.getTypeIndex()),\n                classDef.getAccessFlags(), adjustType(classDef.getSupertypeIndex()),\n                adjustTypeListOffset(classDef.getInterfacesOffset()), classDef.getSourceFileIndex(),\n                classDef.getAnnotationsOffset(), classDef.getClassDataOffset(),\n                classDef.getStaticValuesOffset());\n    }\n    public SortableType adjust(SortableType sortableType) {\n        return new SortableType(sortableType.getDex(),\n                sortableType.getIndexMap(), adjust(sortableType.getClassDef()));\n    }\n    public EncodedValue adjustEncodedValue(EncodedValue encodedValue) {\n        ByteArrayAnnotatedOutput out = new ByteArrayAnnotatedOutput(32);\n        new EncodedValueTransformer(out).transform(new EncodedValueReader(encodedValue));\n        return new EncodedValue(out.toByteArray());\n    }\n    public EncodedValue adjustEncodedArray(EncodedValue encodedArray) {\n        ByteArrayAnnotatedOutput out = new ByteArrayAnnotatedOutput(32);\n        new EncodedValueTransformer(out).transformArray(\n                new EncodedValueReader(encodedArray, ENCODED_ARRAY));\n        return new EncodedValue(out.toByteArray());\n    }\n    public Annotation adjust(Annotation annotation) {\n        ByteArrayAnnotatedOutput out = new ByteArrayAnnotatedOutput(32);\n        new EncodedValueTransformer(out).transformAnnotation(\n                annotation.getReader());\n        return new Annotation(target, annotation.getVisibility(),\n                new EncodedValue(out.toByteArray()));\n    }\n    /**\n     * Adjust an encoded value or array.\n     */\n    private final class EncodedValueTransformer {\n        private final ByteOutput out;\n        public EncodedValueTransformer(ByteOutput out) {<fim_middle>// function below has no smell\n"}