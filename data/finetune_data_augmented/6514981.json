{"text": "<fim_prefix>import org.eclipse.equinox.spi.p2.publisher.PublisherHelper;\nimport org.eclipse.tycho.artifacts.TargetPlatformFilter;\nimport org.eclipse.tycho.artifacts.TargetPlatformFilter.CapabilityPattern;\nimport org.eclipse.tycho.artifacts.TargetPlatformFilter.CapabilityType;\nimport org.eclipse.tycho.artifacts.TargetPlatformFilterSyntaxException;\nimport org.eclipse.tycho.core.shared.MavenLogger;\n@SuppressWarnings(\"restriction\")\npublic class TargetPlatformFilterEvaluator {\n    private final List<TargetPlatformFilter> filters;\n    final MavenLogger logger;\n    private final FilterLogger filterLogger;\n    public TargetPlatformFilterEvaluator(List<TargetPlatformFilter> filters, MavenLogger logger) {\n        this.filters = Collections.unmodifiableList(new ArrayList<>(filters));\n        this.logger = logger;\n        // TODO 372035 enable debug logging; currently the filtering is done repeatedly on subsets of the target platform, leading to excessive amount of debug output\n//        if (this.logger.isDebugEnabled())\n//            this.filterLogger = new DebugFilterLogger();\n//        else\n        this.filterLogger = new FilterLogger();\n    }\n    /**\n     * Applies the filters to the given set. Prints out log messages.\n     * \n     * TODO \"filter\" usually returns filtered results, consider different name\n     * \n     * @param targetPlatformUnits\n     *            The set of units to be filtered. Collection is modified by the method.\n     */\n    public void filterUnits(Collection<IInstallableUnit> targetPlatformUnits)\n            throws TargetPlatformFilterSyntaxException {\n        for (TargetPlatformFilter filter : filters) {\n            applyFilter(filter, targetPlatformUnits);\n        }\n    }\n    // TODO change filter strategy so that a stream of units can be filtered\n    private void applyFilter(TargetPlatformFilter filter, Collection<IInstallableUnit> targetPlatformUnits) {\n        switch (filter.getAction()) {\n        case REMOVE_ALL:\n            applyRemoveAllFilter(filter, targetPlatformUnits);\n            return;\n        case RESTRICT:\n            applyRestrictionFilter(filter, targetPlatformUnits);\n            return;\n        }\n    }\n    private void applyRemoveAllFilter(TargetPlatformFilter filter, Collection<IInstallableUnit> targetPlatformUnits) {\n        ParsedCapabilityPattern scopePattern = parsePattern(filter.getScopePattern(), null);\n        // TODO implement debug logging\n        for (Iterator<IInstallableUnit> unitIterator = targetPlatformUnits.iterator(); unitIterator.hasNext();) {\n            IInstallableUnit unit = unitIterator.next();\n            if (matches(unit, scopePattern)) {\n                unitIterator.remove();\n            }\n        }\n    }\n    private void applyRestrictionFilter(TargetPlatformFilter filter, Collection<IInstallableUnit> targetPlatformUnits) {\n        ParsedCapabilityPattern scopePattern = parsePattern(filter.getScopePattern(), null);\n        ParsedCapabilityPattern restrictionPattern = parsePattern(filter.getActionPattern(), scopePattern);\n        filterLogger.beginEvaluation(filter);\n        for (Iterator<IInstallableUnit> unitIterator = targetPlatformUnits.iterator(); unitIterator.hasNext();) {\n            IInstallableUnit unit = unitIterator.next();\n            if (matches(unit, scopePattern)) {\n                if (!matches(unit, restrictionPattern)) {\n                    unitIterator.remove();\n                    filterLogger.unitRemoved(unit);\n                } else {\n                    filterLogger.unitKept(unit);\n                }\n            }\n        }\n        filterLogger.endEvaluation();\n    }\n    private boolean matches(IInstallableUnit unit, ParsedCapabilityPattern pattern) {\n        switch (pattern.getType()) {\n        case P2_INSTALLABLE_UNIT:\n            return pattern.matchesId(unit.getId()) && pattern.matchesVersion(unit.getVersion());\n        case OSGI_BUNDLE:\n            IProvidedCapability bundle = getBundleCapability(unit);\n            if (bundle == null)\n                return false;\n            return pattern.matchesId(bundle.getName()) && pattern.matchesVersion(bundle.getVersion());\n        case JAVA_PACKAGE:\n            for (IProvidedCapability exportedPackage : getPackageCapabilities(unit)) {\n                if (pattern.matchesId(exportedPackage.getName())\n                        && pattern.matchesVersion(exportedPackage.getVersion())) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        return false;\n    }\n    private IProvidedCapability getBundleCapability(IInstallableUnit unit) {\n        for (IProvidedCapability capability : unit.getProvidedCapabilities()) {\n            if (BundlesAction.CAPABILITY_NS_OSGI_BUNDLE.equals(capability.getNamespace())) {\n                return capability;\n            }\n        }\n        return null;\n    }\n    private List<IProvidedCapability> getPackageCapabilities(IInstallableUnit unit) {\n        Collection<IProvidedCapability> allCapabilities = unit.getProvidedCapabilities();\n        List<IProvidedCapability> packageCapabilities = new ArrayList<>(allCapabilities.size());\n        for (IProvidedCapability capability : allCapabilities) {\n            if (PublisherHelper.CAPABILITY_NS_JAVA_PACKAGE.equals(capability.getNamespace())) {\n                packageCapabilities.add(capability);\n            }\n        }\n        return packageCapabilities;\n    }\n    /**\n     * Wraps the given {@link CapabilityPattern} in a new instance with default values filled in and\n     * typed version/version range attributes.\n     * \n     * @param pattern\n     *            The pattern to be wrapped.\n     * @param defaultValues\n     *            Values to substitute for the type and id attributes in case of <code>null</code>.\n     *            Background: The action filter can inherit values from the scope filter to allow\n     *            shorter notations.\n     */\n    private static ParsedCapabilityPattern parsePattern(CapabilityPattern pattern, ParsedCapabilityPattern defaultValues) {\n        return new ParsedCapabilityPattern(pattern, defaultValues);\n    }\n    private static Version parseVersion(String version) {\n        if (version == null) {\n            return null;\n        }\n        try {\n            return Version.parseVersion(version);\n        } catch (IllegalArgumentException e) {\n            throw new TargetPlatformFilterSyntaxException(\"Failed to parse version: \" + version, e);\n        }\n    }\n    private static VersionRange parseVersionRange(String versionRange) {\n        if (versionRange == null) {\n            return null;\n        }\n        try {\n            return new VersionRange(versionRange);\n        } catch (IllegalArgumentException e) {\n            throw new TargetPlatformFilterSyntaxException(\"Failed to parse version range: \" + versionRange, e);\n        }\n    }\n    static class ParsedCapabilityPattern {\n        private CapabilityType type;\n        private String idRequirement;\n        private Version versionReq;\n        private VersionRange versionRangeReq;\n        ParsedCapabilityPattern(CapabilityPattern pattern, ParsedCapabilityPattern defaultValues) {\n            this.type = pattern.getType();\n            this.idRequirement = pattern.getId();\n            this.versionReq = parseVersion(pattern.getVersion());\n            this.versionRangeReq = parseVersionRange(pattern.getVersionRange());\n            if (defaultValues != null) {\n                // apply default values in order [type, id] until the first explicit value is set\n                if (this.type == null) {\n                    this.type = defaultValues.type;\n                    if (this.idRequirement == null) {\n                        this.idRequirement = defaultValues.idRequirement;\n                        // no need to inherit version requirements because these would always match: the action pattern only tests units which already matched the scope pattern\n                    }\n                }\n            }\n        }\n        CapabilityType getType() {\n            return type;\n        }\n        boolean matchesId(String id) {\n            if (idRequirement == null)\n                return true;\n            return idRequirement.equals(id);\n        }\n        boolean matchesVersion(Version version) {\n            return exactVersionPatternMatches(version) && versionRangePatternMatches(version);\n        }\n        private boolean exactVersionPatternMatches(Version version) {\n            if (versionReq == null)\n                return true;\n            return versionReq.equals(version);\n        }\n        private boolean versionRangePatternMatches(Version version) {\n            if (versionRangeReq == null)\n                return true;\n            return versionRangeReq.isIncluded(version);\n        }\n    }\n    private class FilterLogger {\n        TargetPlatformFilter currentFilter;\n        int unitsKept;\n        int unitsRemoved;\n        public void beginEvaluation(TargetPlatformFilter filter) {\n            currentFilter = filter;\n            unitsKept = 0;\n            unitsRemoved = 0;\n        }\n        public void unitKept(IInstallableUnit unit) {\n            ++unitsKept;\n        }\n        public void unitRemoved(IInstallableUnit unit) {\n            ++unitsRemoved;\n        }\n        public void endEvaluation() {\n            if (unitsRemoved > 0 && unitsKept == 0) {\n                logger.warn(\"Removed all units from the target platform matching {\"\n                        + currentFilter.getScopePattern().printMembers()\n                        + \"} because none of the units passed the restriction filter {\"\n                        + currentFilter.getActionPattern().printMembers() + \"}\");\n            }\n        }\n    }\n    private class DebugFilterLogger extends FilterLogger {\n        @Override\n        public void beginEvaluation(TargetPlatformFilter filter) {\n            super.beginEvaluation(filter);\n            logger.debug(\"Applying \" + filter);\n        }\n<fim_suffix>        @Override\n        public void unitKept(IInstallableUnit unit) {\n            super.unitKept(unit);\n            logger.debug(\"  Keeping unit \" + unit.getId() + \"/\" + unit.getVersion());\n        }<fim_middle>// function below has no smell\n"}