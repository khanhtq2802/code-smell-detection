{"text": "<fim_prefix>     * <pre class=\"groovyTestCase\">assert [4,5] == [1,2,3,4,5].intersect([4,5,6,7,8])</pre>\n     * By default, Groovy uses a {@link NumberAwareComparator} when determining if an\n     * element exists in both collections.\n     *\n     * @param left  a List\n     * @param right an Iterable\n     * @return a List as an intersection of a List and an Iterable\n     * @see #intersect(List, Iterable, Comparator)\n     * @since 2.4.0\n     */\n    public static <T> List<T> intersect(List<T> left, Iterable<T> right) {\n        return (List<T>) intersect((Collection<T>) left, asCollection(right));\n    }\n    /**\n     * Create a List composed of the intersection of a List and an Iterable.  Any\n     * elements that exist in both iterables are added to the resultant collection.\n     * <pre class=\"groovyTestCase\">assert [3,4] == [1,2,3,4].intersect([3,4,5,6])</pre>\n     *\n     * @param left  a List\n     * @param right an Iterable\n     * @param comparator a Comparator\n     * @return a List as an intersection of a List and an Iterable\n     * @since 2.5.0\n     */\n    public static <T> List<T> intersect(List<T> left, Iterable<T> right, Comparator<T> comparator) {\n        return (List<T>) intersect((Collection<T>) left, asCollection(right), comparator);\n    }\n    /**\n     * Create a Set composed of the intersection of a Set and an Iterable.  Any\n     * elements that exist in both iterables are added to the resultant collection.\n     * <pre class=\"groovyTestCase\">assert [4,5] as Set == ([1,2,3,4,5] as Set).intersect([4,5,6,7,8])</pre>\n     * By default, Groovy uses a {@link NumberAwareComparator} when determining if an\n     * element exists in both collections.\n     *\n     * @param left  a Set\n     * @param right an Iterable\n     * @return a Set as an intersection of a Set and an Iterable\n     * @see #intersect(Set, Iterable, Comparator)\n     * @since 2.4.0\n     */\n    public static <T> Set<T> intersect(Set<T> left, Iterable<T> right) {\n        return (Set<T>) intersect((Collection<T>) left, asCollection(right));\n    }\n    /**\n     * Create a Set composed of the intersection of a Set and an Iterable.  Any\n     * elements that exist in both iterables are added to the resultant collection.\n     * <pre class=\"groovyTestCase\">assert [3,4] as Set == ([1,2,3,4] as Set).intersect([3,4,5,6], Comparator.naturalOrder())</pre>\n     *\n     * @param left  a Set\n     * @param right an Iterable\n     * @param comparator a Comparator\n     * @return a Set as an intersection of a Set and an Iterable\n     * @since 2.5.0\n     */\n    public static <T> Set<T> intersect(Set<T> left, Iterable<T> right, Comparator<T> comparator) {\n        return (Set<T>) intersect((Collection<T>) left, asCollection(right), comparator);\n    }\n    /**\n     * Create a SortedSet composed of the intersection of a SortedSet and an Iterable.  Any\n     * elements that exist in both iterables are added to the resultant collection.\n     * <pre class=\"groovyTestCase\">assert [4,5] as SortedSet == ([1,2,3,4,5] as SortedSet).intersect([4,5,6,7,8])</pre>\n     * By default, Groovy uses a {@link NumberAwareComparator} when determining if an\n     * element exists in both collections.\n     *\n     * @param left  a SortedSet\n     * @param right an Iterable\n     * @return a Set as an intersection of a SortedSet and an Iterable\n     * @see #intersect(SortedSet, Iterable, Comparator)\n     * @since 2.4.0\n     */\n    public static <T> SortedSet<T> intersect(SortedSet<T> left, Iterable<T> right) {\n        return (SortedSet<T>) intersect((Collection<T>) left, asCollection(right));\n    }\n    /**\n     * Create a SortedSet composed of the intersection of a SortedSet and an Iterable.  Any\n     * elements that exist in both iterables are added to the resultant collection.\n     * <pre class=\"groovyTestCase\">assert [4,5] as SortedSet == ([1,2,3,4,5] as SortedSet).intersect([4,5,6,7,8])</pre>\n     *\n     * @param left  a SortedSet\n     * @param right an Iterable\n     * @param comparator a Comparator\n     * @return a Set as an intersection of a SortedSet and an Iterable\n     * @since 2.5.0\n     */\n    public static <T> SortedSet<T> intersect(SortedSet<T> left, Iterable<T> right, Comparator<T> comparator) {\n        return (SortedSet<T>) intersect((Collection<T>) left, asCollection(right), comparator);\n    }\n    /**\n     * Create a Map composed of the intersection of both maps.\n     * Any entries that exist in both maps are added to the resultant map.\n     * <pre class=\"groovyTestCase\">assert [4:4,5:5] == [1:1,2:2,3:3,4:4,5:5].intersect([4:4,5:5,6:6,7:7,8:8])</pre>\n     * <pre class=\"groovyTestCase\">assert [1: 1, 2: 2, 3: 3, 4: 4].intersect( [1: 1.0, 2: 2, 5: 5] ) == [1:1, 2:2]</pre>\n     *\n     * @param left     a map\n     * @param right    a map\n     * @return a Map as an intersection of both maps\n     * @since 1.7.4\n     */\n    public static <K,V> Map<K,V> intersect(Map<K,V> left, Map<K,V> right) {\n        final Map<K,V> ansMap = createSimilarMap(left);\n        if (right != null && !right.isEmpty()) {\n            for (Map.Entry<K, V> e1 : left.entrySet()) {\n                for (Map.Entry<K, V> e2 : right.entrySet()) {\n                    if (DefaultTypeTransformation.compareEqual(e1, e2)) {\n                        ansMap.put(e1.getKey(), e1.getValue());\n                    }\n                }\n            }\n        }\n        return ansMap;\n    }\n    /**\n     * Returns <code>true</code> if the intersection of two iterables is empty.\n     * <pre class=\"groovyTestCase\">assert [1,2,3].disjoint([3,4,5]) == false</pre>\n     * <pre class=\"groovyTestCase\">assert [1,2].disjoint([3,4]) == true</pre>\n     *\n     * @param left  an Iterable\n     * @param right an Iterable\n     * @return boolean   <code>true</code> if the intersection of two iterables\n     *         is empty, <code>false</code> otherwise.\n     * @since 2.4.0\n     */\n<fim_suffix>    public static boolean disjoint(Iterable left, Iterable right) {\n        Collection leftCol = asCollection(left);\n        Collection rightCol = asCollection(right);\n        if (leftCol.isEmpty() || rightCol.isEmpty())\n            return true;\n        Collection pickFrom = new TreeSet(new NumberAwareComparator());\n        pickFrom.addAll(rightCol);\n        for (final Object o : leftCol) {\n            if (pickFrom.contains(o))\n                return false;\n        }\n        return true;\n    }<fim_middle>// function below has no smell\n"}