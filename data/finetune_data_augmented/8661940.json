{"text": "<fim_prefix>                    @Override protected void body() {\n                        long interval0 = interval;\n                        while (!isCancelled()) {\n                            try {\n                                U.sleep(interval0);\n                            }\n                            catch (IgniteInterruptedCheckedException ignored) {\n                                break;\n                            }\n                            IgniteBiTuple<GridContinuousBatch, Long> t = info.checkInterval();\n                            final GridContinuousBatch batch = t.get1();\n                            if (batch != null && batch.size() > 0) {\n                                try {\n                                    Collection<Object> toSnd = batch.collect();\n                                    boolean msg = toSnd.iterator().next() instanceof Message;\n                                    CI1<IgniteException> ackC = new CI1<IgniteException>() {\n                                        @Override public void apply(IgniteException e) {\n                                            if (e == null)\n                                                info.hnd.onBatchAcknowledged(routineId, batch, ctx);\n                                        }\n                                    };\n                                    sendNotification(nodeId,\n                                        routineId,\n                                        null,\n                                        toSnd,\n                                        hnd.orderedTopic(),\n                                        msg,\n                                        ackC);\n                                }\n                                catch (ClusterTopologyCheckedException ignored) {\n                                    if (log.isDebugEnabled())\n                                        log.debug(\"Failed to send notification to node (is node alive?): \" + nodeId);\n                                }\n                                catch (IgniteCheckedException e) {\n                                    U.error(log, \"Failed to send notification to node: \" + nodeId, e);\n                                }\n                            }\n                            interval0 = t.get2();\n                        }\n                    }\n                });\n                checker.setUncaughtExceptionHandler(new OomExceptionHandler(ctx));\n                bufCheckThreads.put(routineId, checker);\n                checker.start();\n            }\n            GridContinuousHandler.RegisterStatus status = hnd.register(nodeId, routineId, ctx);\n            if (status == GridContinuousHandler.RegisterStatus.DELAYED) {\n                info.markDelayedRegister();\n                return false;\n            }\n            else\n                return status == GridContinuousHandler.RegisterStatus.REGISTERED;\n        }\n        return false;\n    }\n    /**\n     * @param routineId Routine ID.\n     * @param hnd Handler\n     * @param loc If Handler unregistered on master node.\n     */\n    private void unregisterHandler(UUID routineId, GridContinuousHandler hnd, boolean loc) {\n        assert routineId != null;\n        assert hnd != null;\n        if (loc && hnd.orderedTopic() != null)\n            ctx.io().removeMessageListener(hnd.orderedTopic());\n        hnd.unregister(routineId, ctx);\n        IgniteThread checker = bufCheckThreads.remove(routineId);\n        if (checker != null)\n            checker.interrupt();\n    }\n    /**\n     * @param routineId Routine ID.\n     */\n    @SuppressWarnings(\"TooBroadScope\")\n    private void unregisterRemote(UUID routineId) {\n        RemoteRoutineInfo remote;\n        LocalRoutineInfo loc;\n        stopLock.lock();\n        try {\n            remote = rmtInfos.remove(routineId);\n            loc = locInfos.remove(routineId);\n            if (remote == null)\n                stopped.add(routineId);\n        }\n        finally {\n            stopLock.unlock();\n        }\n        if (log.isDebugEnabled())\n            log.debug(\"unregisterRemote [routineId=\" + routineId + \", loc=\" + loc + \", rmt=\" + remote + ']');\n        if (remote != null)\n            unregisterHandler(routineId, remote.hnd, false);\n        else if (loc != null) {\n            // Removes routine at node started it when stopRoutine called from another node.\n            unregisterHandler(routineId, loc.hnd, false);\n        }\n    }\n    /**\n     * @param nodeId Destination node ID.\n     * @param msg Message.\n     * @param orderedTopic Topic for ordered notifications.\n     *      If {@code null}, non-ordered message will be sent.\n     * @param ackC Ack closure.\n     * @throws IgniteCheckedException In case of error.\n     */\n    private void sendWithRetries(UUID nodeId, GridContinuousMessage msg, @Nullable Object orderedTopic,\n        IgniteInClosure<IgniteException> ackC)\n        throws IgniteCheckedException {\n        assert nodeId != null;\n        assert msg != null;\n        ClusterNode node = ctx.discovery().node(nodeId);\n        if (node != null)\n            sendWithRetries(node, msg, orderedTopic, ackC);\n        else\n            throw new ClusterTopologyCheckedException(\"Node for provided ID doesn't exist (did it leave the grid?): \" + nodeId);\n    }\n    /**\n     * @param node Destination node.\n     * @param msg Message.\n     * @param orderedTopic Topic for ordered notifications.\n     *      If {@code null}, non-ordered message will be sent.\n     * @param ackC Ack closure.\n     * @throws IgniteCheckedException In case of error.\n     */\n    private void sendWithRetries(ClusterNode node, GridContinuousMessage msg, @Nullable Object orderedTopic,\n        IgniteInClosure<IgniteException> ackC) throws IgniteCheckedException {\n        assert node != null;\n        assert msg != null;\n        sendWithRetries(F.asList(node), msg, orderedTopic, ackC);\n    }\n    /**\n     * @param nodes Destination nodes.\n     * @param msg Message.\n     * @param orderedTopic Topic for ordered notifications.\n     *      If {@code null}, non-ordered message will be sent.\n     * @param ackC Ack closure.\n     * @throws IgniteCheckedException In case of error.\n     */\n    private void sendWithRetries(Collection<? extends ClusterNode> nodes, GridContinuousMessage msg,\n        @Nullable Object orderedTopic, IgniteInClosure<IgniteException> ackC) throws IgniteCheckedException {\n        assert !F.isEmpty(nodes);\n        assert msg != null;\n        if (!msg.messages() &&\n            msg.data() != null &&\n            (nodes.size() > 1 || !ctx.localNodeId().equals(F.first(nodes).id())))\n            msg.dataBytes(U.marshal(marsh, msg.data()));\n        for (ClusterNode node : nodes) {\n            int cnt = 0;\n            while (cnt <= retryCnt) {\n                try {\n                    cnt++;\n                    if (orderedTopic != null) {\n                        ctx.io().sendOrderedMessage(\n                            node,\n                            orderedTopic,\n                            msg,\n                            SYSTEM_POOL,\n                            0,\n                            true,\n                            ackC);\n                    }\n                    else\n                        ctx.io().sendToGridTopic(node, TOPIC_CONTINUOUS, msg, SYSTEM_POOL, ackC);\n                    break;\n                }\n                catch (ClusterTopologyCheckedException | IgniteInterruptedCheckedException e) {\n                    throw e;\n                }\n                catch (IgniteCheckedException e) {\n                    if (!ctx.discovery().alive(node.id()))\n                        throw new ClusterTopologyCheckedException(\"Node left grid while sending message to: \" + node.id(), e);\n                    if (cnt == retryCnt)\n                        throw e;\n                    else if (log.isDebugEnabled())\n                        log.debug(\"Failed to send message to node (will retry): \" + node.id());\n                }\n                U.sleep(retryDelay);\n            }\n        }\n    }\n    /**\n     *\n     */\n<fim_suffix>    private class DiscoveryListener implements GridLocalEventListener, HighPriorityListener {\n        /** {@inheritDoc} */\n        @Override public void onEvent(Event evt) {\n            assert evt instanceof DiscoveryEvent;\n            assert evt.type() == EVT_NODE_LEFT || evt.type() == EVT_NODE_FAILED;\n            UUID nodeId = ((DiscoveryEvent)evt).eventNode().id();\n            if (discoProtoVer == 2) {\n                routinesInfo.onNodeFail(nodeId);\n                for (StartFuture fut : startFuts.values())\n                    fut.onNodeFail(nodeId);\n            }\n            clientInfos.remove(nodeId);\n            // Unregister handlers created by left node.\n            for (Map.Entry<UUID, RemoteRoutineInfo> e : rmtInfos.entrySet()) {\n                UUID routineId = e.getKey();\n                RemoteRoutineInfo info = e.getValue();\n                if (nodeId.equals(info.nodeId)) {\n                    if (info.autoUnsubscribe)\n                        unregisterRemote(routineId);\n                    if (info.hnd.isQuery())\n                        info.hnd.onNodeLeft();\n                }\n            }\n            for (Map.Entry<IgniteUuid, SyncMessageAckFuture> e : syncMsgFuts.entrySet()) {\n                SyncMessageAckFuture fut = e.getValue();\n                if (fut.nodeId().equals(nodeId)) {\n                    SyncMessageAckFuture fut0 = syncMsgFuts.remove(e.getKey());\n                    if (fut0 != null) {\n                        ClusterTopologyCheckedException err = new ClusterTopologyCheckedException(\n                            \"Node left grid while sending message to: \" + nodeId);\n                        fut0.onDone(err);\n                    }\n                }\n            }\n        }\n        /** {@inheritDoc} */\n        @Override public int order() {\n            return 1;\n        }\n    }<fim_middle>// class below has no smell\n"}