{"text": "<fim_prefix>/**\n *\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.zookeeper.recipes.queue;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.TreeMap;\nimport java.util.concurrent.CountDownLatch;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.apache.zookeeper.CreateMode;\nimport org.apache.zookeeper.KeeperException;\nimport org.apache.zookeeper.WatchedEvent;\nimport org.apache.zookeeper.Watcher;\nimport org.apache.zookeeper.ZooDefs;\nimport org.apache.zookeeper.ZooKeeper;\nimport org.apache.zookeeper.data.ACL;\nimport org.apache.zookeeper.data.Stat;\n/**\n * \n * A <a href=\"package.html\">protocol to implement a distributed queue</a>.\n * \n */\npublic class DistributedQueue {\n    private static final Logger LOG = LoggerFactory.getLogger(DistributedQueue.class);\n    private final String dir;\n    private ZooKeeper zookeeper;\n    private List<ACL> acl = ZooDefs.Ids.OPEN_ACL_UNSAFE;\n    private final String prefix = \"qn-\";\n    public DistributedQueue(ZooKeeper zookeeper, String dir, List<ACL> acl){\n        this.dir = dir;\n        if(acl != null){\n            this.acl = acl;\n        }\n        this.zookeeper = zookeeper;\n    }\n    /**\n     * Returns a Map of the children, ordered by id.\n     * @param watcher optional watcher on getChildren() operation.\n     * @return map from id to child name for all children\n     */\n    private Map<Long,String> orderedChildren(Watcher watcher) throws KeeperException, InterruptedException {\n        Map<Long,String> orderedChildren = new TreeMap<Long,String>();\n        List<String> childNames = null;\n        try{\n            childNames = zookeeper.getChildren(dir, watcher);\n        }catch (KeeperException.NoNodeException e){\n            throw e;\n        }\n        for(String childName : childNames){\n            try{\n                //Check format\n                if(!childName.regionMatches(0, prefix, 0, prefix.length())){\n                    LOG.warn(\"Found child node with improper name: \" + childName);\n                    continue;\n                }\n                String suffix = childName.substring(prefix.length());\n                Long childId = Long.parseLong(suffix);\n                orderedChildren.put(childId,childName);\n            }catch(NumberFormatException e){\n                LOG.warn(\"Found child node with improper format : \" + childName + \" \" + e,e);\n            }\n        }\n        return orderedChildren;\n    }\n    /**\n     * Find the smallest child node.\n     * @return The name of the smallest child node.\n     */\n    private String smallestChildName() throws KeeperException, InterruptedException {\n        long minId = Long.MAX_VALUE;\n        String minName = \"\";\n        List<String> childNames = null;\n        try{\n            childNames = zookeeper.getChildren(dir, false);\n        }catch(KeeperException.NoNodeException e){\n            LOG.warn(\"Caught: \" +e,e);\n            return null;\n        }\n        for(String childName : childNames){\n            try{\n                //Check format\n                if(!childName.regionMatches(0, prefix, 0, prefix.length())){\n                    LOG.warn(\"Found child node with improper name: \" + childName);\n                    continue;\n                }\n                String suffix = childName.substring(prefix.length());\n                long childId = Long.parseLong(suffix);\n                if(childId < minId){\n                    minId = childId;\n                    minName = childName;\n                }\n            }catch(NumberFormatException e){\n                LOG.warn(\"Found child node with improper format : \" + childName + \" \" + e,e);\n            }\n        }\n        if(minId < Long.MAX_VALUE){\n            return minName;\n        }else{\n            return null;\n        }\n    }\n    /**\n     * Return the head of the queue without modifying the queue.\n     * @return the data at the head of the queue.\n     * @throws NoSuchElementException\n     * @throws KeeperException\n     * @throws InterruptedException\n     */\n<fim_suffix>    public byte[] element() throws NoSuchElementException, KeeperException, InterruptedException {\n        Map<Long,String> orderedChildren;\n        // element, take, and remove follow the same pattern.\n        // We want to return the child node with the smallest sequence number.\n        // Since other clients are remove()ing and take()ing nodes concurrently, \n        // the child with the smallest sequence number in orderedChildren might be gone by the time we check.\n        // We don't call getChildren again until we have tried the rest of the nodes in sequence order.\n        while(true){\n            try{\n                orderedChildren = orderedChildren(null);\n            }catch(KeeperException.NoNodeException e){\n                throw new NoSuchElementException();\n            }\n            if(orderedChildren.size() == 0 ) throw new NoSuchElementException();\n            for(String headNode : orderedChildren.values()){\n                if(headNode != null){\n                    try{\n                        return zookeeper.getData(dir+\"/\"+headNode, false, null);\n                    }catch(KeeperException.NoNodeException e){\n                        //Another client removed the node first, try next\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Attempts to remove the head of the queue and return it.\n     * @return The former head of the queue\n     * @throws NoSuchElementException\n     * @throws KeeperException\n     * @throws InterruptedException\n     */\n    public byte[] remove() throws NoSuchElementException, KeeperException, InterruptedException {\n        Map<Long,String> orderedChildren;\n        // Same as for element.  Should refactor this.\n        while(true){\n            try{\n                orderedChildren = orderedChildren(null);\n            }catch(KeeperException.NoNodeException e){\n                throw new NoSuchElementException();\n            }\n            if(orderedChildren.size() == 0) throw new NoSuchElementException();\n            for(String headNode : orderedChildren.values()){\n                String path = dir +\"/\"+headNode;\n                try{\n                    byte[] data = zookeeper.getData(path, false, null);\n                    zookeeper.delete(path, -1);\n                    return data;\n                }catch(KeeperException.NoNodeException e){\n                    // Another client deleted the node first.\n                }\n            }\n        }\n    }\n    private static class LatchChildWatcher implements Watcher {\n        CountDownLatch latch;\n        public LatchChildWatcher(){\n            latch = new CountDownLatch(1);\n        }\n        public void process(WatchedEvent event){\n            LOG.debug(\"Watcher fired on path: \" + event.getPath() + \" state: \" + \n                    event.getState() + \" type \" + event.getType());\n            latch.countDown();\n        }\n        public void await() throws InterruptedException {\n            latch.await();\n        }\n    }\n    /**\n     * Removes the head of the queue and returns it, blocks until it succeeds.\n     * @return The former head of the queue\n     * @throws NoSuchElementException\n     * @throws KeeperException\n     * @throws InterruptedException\n     */\n    public byte[] take() throws KeeperException, InterruptedException {\n        Map<Long,String> orderedChildren;\n        // Same as for element.  Should refactor this.\n        while(true){\n            LatchChildWatcher childWatcher = new LatchChildWatcher();\n            try{\n                orderedChildren = orderedChildren(childWatcher);\n            }catch(KeeperException.NoNodeException e){\n                zookeeper.create(dir, new byte[0], acl, CreateMode.PERSISTENT);\n                continue;\n            }\n            if(orderedChildren.size() == 0){\n                childWatcher.await();\n                continue;\n            }\n            for(String headNode : orderedChildren.values()){\n                String path = dir +\"/\"+headNode;\n                try{\n                    byte[] data = zookeeper.getData(path, false, null);\n                    zookeeper.delete(path, -1);\n                    return data;\n                }catch(KeeperException.NoNodeException e){\n                    // Another client deleted the node first.\n                }\n            }\n        }\n    }\n    /**\n     * Inserts data into queue.\n     * @param data\n     * @return true if data was successfully added\n     */\n    public boolean offer(byte[] data) throws KeeperException, InterruptedException{\n        for(;;){\n            try{\n                zookeeper.create(dir+\"/\"+prefix, data, acl, CreateMode.PERSISTENT_SEQUENTIAL);\n                return true;<fim_middle>// function below has no smell\n"}